<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7250 - Lobby/TASServer
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7250%20-%20Lobby/TASServer&In-Reply-To=%3C20090311203953.B16463FC04%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002018.html">
   <LINK REL="Next"  HREF="002020.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7250 - Lobby/TASServer</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7250%20-%20Lobby/TASServer&In-Reply-To=%3C20090311203953.B16463FC04%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7250 - Lobby/TASServer">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Mar 11 21:39:53 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002018.html">[Taspring-linux-commit] r7249 - Lobby/TASServer
</A></li>
        <LI>Next message: <A HREF="002020.html">[Taspring-linux-commit] r7251 -	Lobby/TASServer/Documentation/Protocol
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2019">[ date ]</a>
              <a href="thread.html#2019">[ thread ]</a>
              <a href="subject.html#2019">[ subject ]</a>
              <a href="author.html#2019">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tvo
Date: 2009-03-11 21:39:52 +0100 (Wed, 11 Mar 2009)
New Revision: 7250

Removed:
   Lobby/TASServer/MapGrade.java
   Lobby/TASServer/MapGradeList.java
   Lobby/TASServer/MapGrading.java
Modified:
   Lobby/TASServer/Account.java
   Lobby/TASServer/Accounts.java
   Lobby/TASServer/Client.java
   Lobby/TASServer/TASServer.java
Log:
Removed map grading (entirely, command is just ignored.)



Modified: Lobby/TASServer/Account.java
===================================================================
--- Lobby/TASServer/Account.java	2009-03-11 20:00:27 UTC (rev 7249)
+++ Lobby/TASServer/Account.java	2009-03-11 20:39:52 UTC (rev 7250)
@@ -3,7 +3,7 @@
  *
  * TODO To change the template for this generated file go to
  * Window - Preferences - Java - Code Style - Code Templates
- * 
+ *
  * ---- NOTES ----
  * - Each account is uniquely identified by its username (I also used int ID in previous versions,
  *   but since all usernames must be unique, we don't need another unique identifier).
@@ -30,14 +30,14 @@
 	 * * bit 23: agreement bit. It tells us whether user has already
 	 *     read the &quot;terms of use&quot; and agreed to it. If not, we should
 	 *     first send him the agreement and wait until he confirms it (before
-	 *     allowing him to log on the server).    
-	 * * bit 24 - bot mode (0 - normal user, 1 - automated bot).     
+	 *     allowing him to log on the server).
+	 * * bit 24 - bot mode (0 - normal user, 1 - automated bot).
 	 * * bits 25 - 30 (6 bits): reserved for future use.
 	 * * bit 31: unused (integer sign)
-	 * 
+	 *
 	 */
-	
-	
+
+
 	/*
 	 * current rank categories:
 	 * &lt; 5h = newbie
@@ -47,7 +47,7 @@
 	 * 100h - 300h = experienced player
 	 * 300h - 1000h = highly experienced player
 	 * &gt; 1000h = veteran
-	 *  
+	 *
 	 * */
 	private static int rank1Limit = 60*5; // in minutes
 	private static int rank2Limit = 60*15; // in minutes
@@ -55,14 +55,14 @@
 	private static int rank4Limit = 60*100; // in minutes
 	private static int rank5Limit = 60*300; // in minutes
 	private static int rank6Limit = 60*1000; // in minutes
-	
+
 	public static int NIL_ACCESS = 0; // for clients that haven't logged in yet
 	public static int NORMAL_ACCESS = 1;
 	public static int PRIVILEGED_ACCESS = 2;
 	public static int ADMIN_ACCESS = 3;
-	
+
 	public static int NO_USER_ID = 0;
-	
+
 	public String user;
 	public String pass;
 	public int access; // access type. Bit 31 must be 0 (due to int being signed number - we don't want to use any binary complement conversions).
@@ -71,9 +71,8 @@
 	public String lastIP; // the most recent IP used to log into this account
 	public long registrationDate; // date when user registered this account. In miliseconds (refers to System.currentTimeMillis()). 0 means registration date is unknown (clients who registered in some early version when this field was not yet implemented. Note that this field was first introduced with Spring 0.67b3, Dec 18 2005).
 	public String lastCountry; // resolved country code for this user's IP when he last logged on. If country could not be resolved, &quot;XX&quot; is used for country code, otherwise a 2-char country code is used
-	public MapGradeList mapGrades; // list of map grades
-	
-	public Account(String user, String pass, int access, int lastUserID, long lastLogin, String lastIP, long registrationDate, String lastCountry, MapGradeList mapGrades)
+
+	public Account(String user, String pass, int access, int lastUserID, long lastLogin, String lastIP, long registrationDate, String lastCountry)
 	{
 		this.user = user;
 		this.pass = pass;
@@ -83,9 +82,8 @@
 		this.lastIP = lastIP;
 		this.registrationDate = registrationDate;
 		this.lastCountry = lastCountry;
-		this.mapGrades = mapGrades;
 	}
-	
+
 	public Account(Account acc) {
 		this.user = new String(acc.user);
 		this.pass = new String(acc.pass);
@@ -95,27 +93,26 @@
 		this.lastIP = acc.lastIP;
 		this.registrationDate = acc.registrationDate;
 		this.lastCountry = new String(acc.lastCountry);
-		this.mapGrades = MapGradeList.createFromString(acc.mapGrades.toString());
 	}
-	
+
 	public String toString() {
-		return user + &quot; &quot; + pass + &quot; &quot; + Integer.toString(access, 2) + &quot; &quot; + lastUserID + &quot; &quot; + lastLogin + &quot; &quot; + lastIP + &quot; &quot; + registrationDate + &quot; &quot; + lastCountry + &quot; &quot; + mapGrades.toString();
+		return user + &quot; &quot; + pass + &quot; &quot; + Integer.toString(access, 2) + &quot; &quot; + lastUserID + &quot; &quot; + lastLogin + &quot; &quot; + lastIP + &quot; &quot; + registrationDate + &quot; &quot; + lastCountry;
 	}
-	
+
 	public boolean equals(Object o) {
 		if (this == o) return true;
 		if (!(o instanceof Account)) return false;
 		return this.user.equals(((Account)o).user);
-	}	
-	
+	}
+
 	public int accessLevel() {
 		return access &amp; 0x7;
 	}
-	
+
 	public boolean getBotMode() {
 		return ((access &amp; 0x1000000) &gt;&gt; 24) == 1;
 	}
-	
+
 	public void setBotMode(boolean bot) {
 		int b = bot ? 1 : 0;
 		access = (access &amp; 0xFEFFFFFF) | (b &lt;&lt; 24);
@@ -125,11 +122,11 @@
 	public int getInGameTime() {
 		return (access &amp; 0x7FFFF8) &gt;&gt; 3;
 	}
-	
+
 	public void setInGameTime(int mins) {
 		access = (access &amp; 0xFF800007) | (mins &lt;&lt; 3);
 	}
-	
+
 	public boolean getAgreement() {
 		return ((access &amp; 0x800000) &gt;&gt; 23) == 1;
 	}
@@ -138,8 +135,8 @@
 	public void setAgreement(boolean agreed) {
 		int agr = agreed ? 1 : 0;
 		access = (access &amp; 0xFF7FFFFF) | (agr &lt;&lt; 23);
-	} 
-	
+	}
+
 	public int getRank() {
 		if (getInGameTime() &gt;= rank6Limit) return 6;
 		else if (getInGameTime() &gt; rank5Limit) return 5;
@@ -149,13 +146,13 @@
 		else if (getInGameTime() &gt; rank1Limit) return 1;
 		else return 0;
 	}
-	
-	/* adds mins minutes to client's in-game time (this time is used to calculate 
+
+	/* adds mins minutes to client's in-game time (this time is used to calculate
 	 * player's rank). Returns true if player's rank was changed, false otherwise. */
 	public boolean addMinsToInGameTime(int mins) {
 		int tmp = getRank();
 		setInGameTime(getInGameTime() + mins);
 		return tmp != getRank();
 	}
-	
+
 }

Modified: Lobby/TASServer/Accounts.java
===================================================================
--- Lobby/TASServer/Accounts.java	2009-03-11 20:00:27 UTC (rev 7249)
+++ Lobby/TASServer/Accounts.java	2009-03-11 20:39:52 UTC (rev 7250)
@@ -3,7 +3,7 @@
  *
  * TODO To change the template for this generated file go to
  * Window - Preferences - Java - Code Style - Code Templates
- * 
+ *
  */
 
 /**
@@ -19,7 +19,7 @@
 public class Accounts {
 	private static ArrayList&lt;Account&gt; accounts = new ArrayList&lt;Account&gt;(); // note: ArrayList is not synchronized! Use Vector class instead if multiple threads are going to access it.
 	private static SaveAccountsThread saveAccountsThread = null;
-	
+
 	// 'map' is used to speed up searching for accounts by username (TreeMap class implements efficient Red-Black trees)
 	private static TreeMap&lt;String, Account&gt; map = new TreeMap&lt;String, Account&gt;(
             new java.util.Comparator&lt;String&gt; () {
@@ -42,11 +42,11 @@
 
 	private static long saveAccountInfoInterval = 1000 * 60 * 60; // in milliseconds
 	private static long lastSaveAccountsTime = System.currentTimeMillis(); // time when we last saved accounts info to disk
-	
+
 	public static int getAccountsSize() {
 		return accounts.size();
 	}
-	
+
 	/* (re)loads accounts from disk */
 	public static boolean loadAccounts()
 	{
@@ -55,42 +55,35 @@
 			BufferedReader in = new BufferedReader(new FileReader(TASServer.ACCOUNTS_INFO_FILEPATH));
 
 			accounts.clear();
-			
+
 			String line;
 			String tokens[];
-			
+
             while ((line = in.readLine()) != null) {
             	if (line.equals(&quot;&quot;)) continue;
             	tokens = line.split(&quot; &quot;);
-            	MapGradeList mgl;
-            	if (tokens.length &gt; 8) mgl = MapGradeList.createFromString(Misc.makeSentence(tokens, 8));
-            	else mgl = new MapGradeList();
-            	if (mgl == null) {
-            		System.out.println(&quot;Error: malformed line in accounts data file: \&quot;&quot; + line + &quot;\&quot;&quot;);
-            		continue;
-            	}
-            	addAccount(new Account(tokens[0], tokens[1], Integer.parseInt(tokens[2], 2), Integer.parseInt(tokens[3]), Long.parseLong(tokens[4]), tokens[5], Long.parseLong(tokens[6]), tokens[7], mgl));
+            	addAccount(new Account(tokens[0], tokens[1], Integer.parseInt(tokens[2], 2), Integer.parseInt(tokens[3]), Long.parseLong(tokens[4]), tokens[5], Long.parseLong(tokens[6]), tokens[7]));
 	        }
-            
+
             in.close();
-			
+
 		} catch (IOException e) {
 			// catch possible io errors from readLine()
 			System.out.println(&quot;IOException error while trying to update accounts info from &quot; + TASServer.ACCOUNTS_INFO_FILEPATH + &quot;! Skipping ...&quot;);
 			return false;
 		}
-		
+
 		System.out.println(accounts.size() + &quot; accounts information read from &quot; + TASServer.ACCOUNTS_INFO_FILEPATH + &quot; (&quot; + (System.currentTimeMillis() - time) + &quot; ms)&quot;);
-		
+
 		return true;
 	}
-	
+
 	/* if block==false, this method will spawn a new thread which will save the accounts,
 	 * so this method can return immediately (non-blocking mode). If block==true, it will
 	 * not return until accounts have been saved to disk. */
 	public static void saveAccounts(boolean block) {
 		if ((saveAccountsThread != null) &amp;&amp; (saveAccountsThread.isAlive())) return; // already in progress. Let's just skip it ...
-		
+
 		lastSaveAccountsTime = System.currentTimeMillis();
 		saveAccountsThread = new SaveAccountsThread((List)accounts.clone());
 		saveAccountsThread.start();
@@ -100,11 +93,11 @@
 				saveAccountsThread.join(); // wait until thread returns
 		    } catch (InterruptedException e) {
 		    }
-		}		
-		
+		}
+
 		lastSaveAccountsTime = System.currentTimeMillis();
 	}
-	
+
 	/* will call saveAccounts() only if they haven't been saved for some time.
 	 * This method should be called periodically! */
 	public static void saveAccountsIfNeeded() {
@@ -113,16 +106,16 @@
 	    	// note: lastSaveAccountsTime will get updated in saveAccounts() method!
 	    }
 	}
-	
+
 	// returns 'null' if username is valid, or error description otherwise
 	public static String isUsernameValid(String username) {
 		if (username.length() &gt; 20) return &quot;Username too long&quot;;
 		if (username.length() &lt; 2) return &quot;Username too short&quot;;
 		if (!username.matches(&quot;^[A-Za-z0-9_]+$&quot;)) return &quot;Username contains invalid characters&quot;;
 		// everything is OK:
-		return null; 
+		return null;
 	}
-	
+
 	// returns 'null' if password is valid, or error description otherwise
 	public static String isPasswordValid(String password) {
 		if (password.length() &lt; 2) return &quot;Password too short&quot;;
@@ -130,9 +123,9 @@
 		// we have to allow a bit wider range of possible chars as base64 can produce chars such as +, = and /
 		if (!password.matches(&quot;^[\\x2B-\\x7A]+$&quot;)) return &quot;Password contains invalid characters&quot;;
 		// everything is OK:
-		return null; 
+		return null;
 	}
-	
+
 	// returns 'null' if username is valid, or error description otherwise.
 	// This is used with &quot;old&quot; format of usernames which could also contain &quot;[&quot; and &quot;]&quot; characters.
 	public static String isOldUsernameValid(String username) {
@@ -140,9 +133,9 @@
 		if (username.length() &lt; 2) return &quot;Username too short&quot;;
 		if (!username.matches(&quot;^[A-Za-z0-9_\\[\\]]+$&quot;)) return &quot;Username contains invalid characters&quot;;
 		// everything is OK:
-		return null; 
+		return null;
 	}
-	
+
 	// returns 'null' if password is valid, or error description otherwise. 'baseUsername' is used to test nickname against
 	// (nickname must contain part of username - it may only prefix and postfix the username)
 	public static String isNicknameValid(String nickname, String baseUsername) {
@@ -150,50 +143,50 @@
 		if (nickname.length() &lt; 2) return &quot;Nickname too short&quot;;
 
 		if (!nickname.matches(&quot;^[A-Za-z0-9_\\[\\]\\|]+$&quot;)) return &quot;Nickname contains invalid characters&quot;;
-		
+
 		// check if prefix is valid:
 		if (!nickname.matches(&quot;^([A-Za-z0-9\\[\\]\\|]+[\\|\\]])?&quot; + baseUsername)) return &quot;Invalid prefix found in nickname: embed your prefix in [] brackets or separate it by a | character&quot;;
 
 		// check if postfix is valid:
 		if (!nickname.matches(baseUsername + &quot;([\\|\\[][A-Za-z0-9\\[\\]\\|]+)?$&quot;)) return &quot;Invalid postfix found in nickname: embed your postfix in [] brackets or separate it by a | character&quot;;
-		
+
 		// check if prefix and postfix are both valid in one shot:
 		if (!nickname.matches(&quot;^([A-Za-z0-9\\[\\]\\|]+[\\|\\]])?&quot; + baseUsername + &quot;([\\|\\[][A-Za-z0-9\\[\\]\\|]+)?$&quot;)) return &quot;Nickname contains invalid prefix/postfix. Your username should be contained in your nickname!&quot;;
 
 		// everything is OK:
-		return null; 
-	}	
-	
+		return null;
+	}
+
 	/* WARNING: caller must check if username/password is valid etc. himself! */
 	public static void addAccount(Account acc) {
 		accounts.add(acc);
 		map.put(acc.user, acc);
 		mapNoCase.put(acc.user, acc);
-	}	
-	
+	}
+
 	public static boolean addAccountWithCheck(Account acc) {
 		if (isUsernameValid(acc.user) != null) return false;
 		if (isPasswordValid(acc.pass) != null) return false;
 
 		// check for duplicate entries:
 		if (doesAccountExist(acc.user)) return false;
-		
+
 		addAccount(acc);
 		return true;
 	}
-	
+
 	public static boolean removeAccount(Account acc) {
 		boolean result = accounts.remove(acc);
 		map.remove(acc.user);
 		mapNoCase.remove(acc.user);
 		return result;
 	}
-	
+
 	public static boolean removeAccount(String username) {
 		Account acc = getAccount(username);
 		if (acc == null) return false;
 		return removeAccount(acc);
-	}	
+	}
 
 	// returns null if account is not found:
 	public static Account getAccount(String username) {
@@ -208,27 +201,27 @@
 			return null;
 		}
 	}
-	
+
 	public static Account findAccountNoCase(String username) {
 		return mapNoCase.get(username);
 	}
-	
+
 	public static boolean doesAccountExist(String username) {
 		return getAccount(username) != null;
 	}
-	
+
 	/* will delete account 'oldAcc' and insert 'newAcc' into his position */
 	public static boolean replaceAccount(Account oldAcc, Account newAcc) {
 		int index = accounts.indexOf(oldAcc);
 		if (index == -1) return false; // 'oldAcc' does not exist!
-		
+
 		accounts.set(index, newAcc);
-		
+
 		map.remove(oldAcc.user);
 		mapNoCase.remove(oldAcc.user);
 		map.put(newAcc.user, newAcc);
 		mapNoCase.put(newAcc.user, newAcc);
-		
+
 		return true;
 	}
 

Modified: Lobby/TASServer/Client.java
===================================================================
--- Lobby/TASServer/Client.java	2009-03-11 20:00:27 UTC (rev 7249)
+++ Lobby/TASServer/Client.java	2009-03-11 20:39:52 UTC (rev 7250)
@@ -24,37 +24,35 @@
 public class Client {
 	public boolean alive = false; // if false, then this client is not &quot;valid&quot; anymore (we already killed him and closed his socket).
 	public boolean halfDead = false; // when we schedule client for kill (via Clients.killClientDelayed, for example) this flag is set to true. When true, we don't read or send any data to this client.
-	
+
 	public Account account;
 	public String IP;
-	public String localIP; // client's local IP which has to be send with LOGIN command (server can't figure out his local IP himself of course) 
+	public String localIP; // client's local IP which has to be send with LOGIN command (server can't figure out his local IP himself of course)
 	public int UDPSourcePort; // client's public UDP source port used with some NAT traversal techniques (e.g. &quot;hole punching&quot;)
 	public int status; // see MYSTATUS command for actual values of status
 	public int battleStatus; // see MYBATTLESTATUS command for actual values of battleStatus
 	public int teamColor; // see MYBATTLESTATUS for info on this one
 	public int battleID; // battle ID in which client is participating. Must be -1 if not participating in any battle.
 	public ArrayList&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;(); // list of channels user is participating in
-	
+
 	public SocketChannel sockChan;
 	public SelectionKey selKey;
 	public StringBuilder recvBuf;
 	private int msgID = TASServer.NO_MSG_ID; // -1 means no ID is used (NO_MSG_ID constant). This is the message/command ID used when sending command as described in the &quot;lobby protocol description&quot; document. Use setSendMsgID and resetSendMsgID methods to manipulate it.
 	private Queue&lt;ByteBuffer&gt; sendQueue = new LinkedList&lt;ByteBuffer&gt;(); // queue of &quot;delayed data&quot;. We failed sending this the first time, so we'll have to try sending it again some time.
 	private StringBuilder fastWrite; // temporary StringBuilder used with beginFastWrite() and endFastWrite() methods.
-	
+
 	public long inGameTime; // in milliseconds. Used internally to remember time when user entered game using System.currentTimeMillis().
 	public String country;
 	public int cpu; // in MHz if possible, or in MHz*1.4 if AMD. 0 means the client can't figure out it's CPU speed.
 	public String lobbyVersion; // e.g. &quot;TASClient 1.0&quot; (gets updated when server receives LOGIN command)
 	public long dataOverLastTimePeriod = 0; // how many bytes did client send over last recvRecordPeriod seconds. This is used with anti-flood protection.
 	public long timeOfLastReceive; // time (System.currentTimeMillis()) when we last heard from client (last data received)
-	public long lastMapGradesReceived = 0; // time when we last received MAPGRADES command from this user. This is needed to ensure user doesn't send this command too often as it creates much load on the server.
-	public String mapHashUponEnteringGame; // here we keep a hash of the map which was used at the moment this client changed his status to in-game. Its value is undefined (null) if client entered in-game withouth actually participating in a battle. We need this hash when updating map time info for this user (since this user could return from the game after battle host has closed the battle).
-	
+
 	public Client(SocketChannel sockChan) {
 		alive = true;
-		
-		account = new Account(&quot;&quot;, &quot;&quot;, Account.NIL_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;, new MapGradeList()); // no info on user/pass, zero access
+
+		account = new Account(&quot;&quot;, &quot;&quot;, Account.NIL_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;); // no info on user/pass, zero access
 		this.sockChan = sockChan;
 		IP = sockChan.socket().getInetAddress().getHostAddress();
 		// this fixes the issue with local user connecting to server as &quot;127.0.0.1&quot; (he can't host battles with that IP):
@@ -76,25 +74,24 @@
 		inGameTime = 0;
 		battleID = -1;
 		cpu = 0;
-		mapHashUponEnteringGame = null;
 
 		timeOfLastReceive = System.currentTimeMillis();
 	}
-	
+
 	// any messages sent via sendLine() method will contain this ID. See &quot;lobby protocol description&quot; document for more info on message/command IDs.
 	public void setSendMsgID(int ID) {
 		this.msgID = ID;
 	}
-	
+
 	public void resetSendMsgID(int ID) {
 		this.msgID = ID;
 	}
-	
+
 	/* will prefix the message with a msgID value, if it was previously set via setSendMsgID() method. */
 	public boolean sendLine(String text) {
 		return sendLine(text, msgID);
 	}
-	
+
 	/* the 'msgID' param overrides any previously set ID (via setSendMsgID method). Use NO_MSG_ID (which should equal to -1) for none.  */
 	public boolean sendLine(String text, int msgID) {
 		if (!alive) return false;
@@ -110,7 +107,7 @@
 			return true;
 		}
 
-		if (TASServer.DEBUG &gt; 1) 
+		if (TASServer.DEBUG &gt; 1)
 			if (account.accessLevel() != Account.NIL_ACCESS) System.out.println(&quot;[-&gt;&quot; + account.user + &quot;]&quot; + &quot; \&quot;&quot; + text + &quot;\&quot;&quot;);
 			else System.out.println(&quot;[-&gt;&quot; + IP + &quot;]&quot; + &quot; \&quot;&quot; + text + &quot;\&quot;&quot;);
 
@@ -155,28 +152,28 @@
 	public void sendWelcomeMessage() {
 		sendLine(&quot;TASServer &quot; + TASServer.VERSION + &quot; &quot; + TASServer.latestSpringVersion + &quot; &quot; + TASServer.NAT_TRAVERSAL_PORT + &quot; &quot; + (TASServer.LAN_MODE ? 1 : 0));
 	}
-	
+
 	/* should only be called by Clients.killClient() method! */
 	public void disconnect() {
 		if (!alive) {
 			System.out.println(&quot;PROBLEM DETECTED: disconnecting dead client. Skipping ...&quot;);
 			return ;
 		}
-		
+
 		try {
 			sockChan.close();
 		} catch (Exception e) {
 			System.out.println(&quot;Error: cannot disconnect socket!&quot;);
 		}
-		
+
 		sockChan = null;
 		selKey = null;
 	}
-	
+
 	/* joins client to &lt;chanName&gt; channel. If channel with that name
-	 * does not exist, it is created. Method returns channel object as a result. 
-	 * If client is already in the channel, it returns null as a result. 
-	 * This method does not check for a correct key in case the channel is locked, 
+	 * does not exist, it is created. Method returns channel object as a result.
+	 * If client is already in the channel, it returns null as a result.
+	 * This method does not check for a correct key in case the channel is locked,
 	 * caller of this method should do that before calling it.
 	 * This method also doesn't do any notificating of other clients in the channel,
 	 * caller must do all that. */
@@ -186,28 +183,28 @@
 			chan = new Channel(chanName);
 			Channels.addChannel(chan);
 		}
-		else if (this.channels.indexOf(chan) != -1) return null; // already in the channel 
+		else if (this.channels.indexOf(chan) != -1) return null; // already in the channel
 
 		chan.addClient(this);
 		this.channels.add(chan);
 		return chan;
 	}
-	
+
 	/* removes client from the channel and notifies all other clients in the channel about it.
-	 * If this was the last client in the channel, then channel is removed from channels list. 
+	 * If this was the last client in the channel, then channel is removed from channels list.
 	 * &quot;reason&quot; may be left blank (&quot;&quot;) if no reason is to be given. */
 	public boolean leaveChannel(Channel chan, String reason) {
 		boolean result = chan.removeClient(this);
-		
+
 		if (result) {
 			if (chan.getClientsSize() == 0) Channels.removeChannel(chan); // since channel is empty there is no point in keeping it in a channels list. If we would keep it, the channels list would grow larger and larger in time. We don't want that!
 			else for (int i = 0; i &lt; chan.getClientsSize(); i++) chan.getClient(i).sendLine(&quot;LEFT &quot; + chan.name + &quot; &quot; + this.account.user + (reason.equals(&quot;&quot;) ? &quot;&quot; : &quot; &quot; + reason));
 			this.channels.remove(chan);
-		} 
-		
+		}
+
 		return result;
 	}
-	
+
 	/* calls leaveChannel() for every channel client is participating in.
 	 * Also notifies all clients of his departure.
 	 * Also see comments for leaveChannel() method. */
@@ -217,7 +214,7 @@
 		}
 		this.channels.clear();
 	}
-	
+
 	/* will search the list of channels this user is participating in
 	 * and return the specified channel or null if client is not participating
 	 * in this channel. */
@@ -225,7 +222,7 @@
 		for (int i = 0; i &lt; channels.size(); i++) {
 			if (channels.get(i).name.equals(chanName)) return channels.get(i);
 		}
-		return null;		
+		return null;
 	}
 
 	/* tries to send the data from the sendQueue. Returns true if all data has been flushed or false otherwise. */
@@ -263,13 +260,13 @@
 
 		return sendQueue.size() == 0;
 	}
-	
+
 	public void beginFastWrite() {
 		if (fastWrite != null) {
 			System.out.println(&quot;Serious error detected: invalid use of beginFastWrite(). Check your code! Shutting down the server ...&quot;);
 			TASServer.closeServerAndExit();
 		}
-		
+
 		fastWrite = new StringBuilder();
 	}
 
@@ -278,32 +275,32 @@
 			System.out.println(&quot;Serious error detected: invalid use of endFastWrite(). Check your code! Shutting down the server ...&quot;);
 			TASServer.closeServerAndExit();
 		}
-		
+
 		String data = fastWrite.toString();
 		fastWrite = null;
 		if (data.equals(&quot;&quot;)) return ;
 		sendLine(data);
-	}	
+	}
 
 
 	/* various methods dealing with client status: */
-	
+
 	public boolean getInGameFromStatus() {
 		return (status &amp; 0x1) == 1;
 	}
-	
+
 	public boolean getAwayBitFromStatus() {
 		return ((status &amp; 0x2) &gt;&gt; 1) == 1;
 	}
-	
+
 	public int getRankFromStatus() {
 		return (status &amp; 0x1C) &gt;&gt; 2;
 	}
-	
+
 	public boolean getAccessFromStatus() {
 		return ((status &amp; 0x20) &gt;&gt; 5) == 1;
 	}
-	
+
 	public boolean getBotModeFromStatus() {
 		return ((status &amp; 0x40) &gt;&gt; 6) == 1;
 	}
@@ -311,11 +308,11 @@
 	public void setInGameToStatus(boolean inGame) {
 		status = (status &amp; 0xFFFFFFFE) | (inGame ? 1 : 0);
 	}
-	
+
 	public void setAwayBitToStatus(boolean away) {
 		status = (status &amp; 0xFFFFFFFD) | ((away ? 1 : 0) &lt;&lt; 1);
 	}
-	
+
 	public void setRankToStatus(int rank) {
 		status = (status &amp; 0xFFFFFFE3) | (rank &lt;&lt; 2);
 	}
@@ -323,9 +320,9 @@
 	public void setAccessToStatus(boolean access) {
 		status = (status &amp; 0xFFFFFFDF) | ((access ? 1 : 0) &lt;&lt; 5);
 	}
-	
+
 	public void setBotModeToStatus(boolean isBot) {
 		status = (status &amp; 0xFFFFFFBF) | ((isBot ? 1 : 0) &lt;&lt; 6);
 	}
-	
+
 }

Deleted: Lobby/TASServer/MapGrade.java
===================================================================
--- Lobby/TASServer/MapGrade.java	2009-03-11 20:00:27 UTC (rev 7249)
+++ Lobby/TASServer/MapGrade.java	2009-03-11 20:39:52 UTC (rev 7250)
@@ -1,30 +0,0 @@
-/*
- * Created on 2006.7.27
- *
- * - Since version 0.31 we are also keeping the time user has spent playing the map
- * 
- */
-
-/**
- * @author Betalord
- *
- * TODO To change the template for this generated type comment go to
- * Window - Preferences - Java - Code Style - Code Templates
- */
-
-public class MapGrade {
-	public String hash; // 32-bit map hash in hexadecimal form
-	public int grade; // a map grade in range [0..10], where 0 means user hasn't graded the map yet
-	public int mins; // number of minutes that user spent playing this map in total 
-
-	public MapGrade(String mapHash, int mapGrade, int mins) {
-		this.hash = mapHash;
-		this.grade = mapGrade;
-		this.mins = mins;
-	}
-	
-	public String toString() {
-		return hash + &quot; &quot; + grade + &quot; &quot; + mins; 
-	}	
-}
-

Deleted: Lobby/TASServer/MapGradeList.java
===================================================================
--- Lobby/TASServer/MapGradeList.java	2009-03-11 20:00:27 UTC (rev 7249)
+++ Lobby/TASServer/MapGradeList.java	2009-03-11 20:39:52 UTC (rev 7250)
@@ -1,86 +0,0 @@
-/*
- * Created on 2006.7.27
- *
- * TODO To change the template for this generated file go to
- * Window - Preferences - Java - Code Style - Code Templates
- * 
- * Note: MapGradeList class is THREAD-SAFE - make sure you keep it so 
- * since thread-safety is needed as saveAccounts() method saves
- * accounts in a separate thread.
- * 
- */
-
-/**
- * @author Betalord
- *
- * TODO To change the template for this generated type comment go to
- * Window - Preferences - Java - Code Style - Code Templates
- */
-
-import java.util.*;
-
-public class MapGradeList {
-	private Vector&lt;MapGrade&gt; list; // must be thread-safe list in order to ensure class'es thread-safety
-
-	public MapGradeList() {
-		list = new Vector&lt;MapGrade&gt;();
-	}
-	
-	public synchronized boolean add(MapGrade mg) {
-		return list.add(mg);
-	}
-	
-	public synchronized boolean remove(MapGrade mg) {
-		return list.remove(mg);
-	}
-	
-	public MapGrade elementAt(int index) {
-		try {
-			return list.elementAt(index);
-		} catch (IndexOutOfBoundsException e) {
-			return null;
-		}
-	}
-	
-	public int indexOf(Object elem) {
-		return list.indexOf(elem);
-	}
-	
-	public int size() {
-		return list.size();
-	}
-	
-	public synchronized MapGrade findMapGrade(String mapHash) {
-		for (int i = 0; i &lt; list.size(); i++)
-			if (list.get(i).hash.equals(mapHash)) return list.get(i);
-		return null;
-	}
-
-	public synchronized String toString() {
-		if (list.size() == 0) return &quot;&quot;;
-		else {
-			StringBuilder result = new StringBuilder();
-			for (int i = 0; i &lt; list.size(); i++) {
-				result.append(list.get(i).toString());
-				result.append(i == list.size()-1 ? &quot;&quot; : &quot; &quot;);
-			}
-			return result.toString();
-		}
-	}
-	
-	public static MapGradeList createFromString(String s) {
-		if (s.equals(&quot;&quot;)) return null;
-		String[] tokens = s.split(&quot; &quot;);
-		if (tokens.length % 3 != 0) return null;
-		MapGradeList result = new MapGradeList();
-		try {
-			for (int i = 0; i &lt; tokens.length / 3; i++) {
-				result.add(new MapGrade(tokens[i*3], Integer.parseInt(tokens[i*3+1]), Integer.parseInt(tokens[i*3+2])));
-			}
-		} catch (NumberFormatException e) {
-			return null;
-		}
-		return result;
-	}
-	
-}

Deleted: Lobby/TASServer/MapGrading.java
===================================================================
--- Lobby/TASServer/MapGrading.java	2009-03-11 20:00:27 UTC (rev 7249)
+++ Lobby/TASServer/MapGrading.java	2009-03-11 20:39:52 UTC (rev 7250)
@@ -1,106 +0,0 @@
-/*
- * Created on 2006.8.4
- *
- * TODO To change the template for this generated file go to
- * Window - Preferences - Java - Code Style - Code Templates
- * 
- */
-
-/**
- * @author Betalord
- *
- * TODO To change the template for this generated type comment go to
- * Window - Preferences - Java - Code Style - Code Templates
- */
-
-import java.util.*;
-
-public class MapGrading {
-	public static ArrayList&lt;GlobalMapGrade&gt; globalMapGrades = new ArrayList&lt;GlobalMapGrade&gt;();
-	
-	private static GlobalMapGrade findGlobalMapGrade(String mapHash) {
-		for (int i = 0; i &lt; globalMapGrades.size(); i++)
-			if (globalMapGrades.get(i).mapHash.equals(mapHash))
-				return globalMapGrades.get(i);
-		return null;
-	}
-	
-	/* will reconstruct global map grade list from accounts info */
-	public static void reconstructGlobalMapGrades() {
-		globalMapGrades.clear();
-		for (int i = 0; i &lt; Accounts.getAccountsSize(); i++) {
-			if (Accounts.getAccount(i).getRank() &lt; 3) continue ; // accept only grades from players with rank higher than &quot;beginner&quot;
-			MapGradeList grades = Accounts.getAccount(i).mapGrades;
-			if (grades.size() == 0) continue;
-			for (int j = 0; j &lt; grades.size(); j++) {
-				addGlobalGrade(grades.elementAt(j).hash, grades.elementAt(j).grade);
-			}
-		}
-	}
-
-	public static float getAvarageMapGrade(String mapHash) {
-		GlobalMapGrade mg = findGlobalMapGrade(mapHash);
-		if (mg == null) return 0;
-		else return mg.avGrade;
-	}
-	
-	public static int getNumberOfMapVotes(String mapHash) {
-		GlobalMapGrade mg = findGlobalMapGrade(mapHash);
-		if (mg == null) return 0;
-		else return mg.noVotes;
-	}
-	
-	/* where &quot;grade&quot; should be between 1 and 10 */
-	private static void addGlobalGrade(String mapHash, int grade) {
-		if (grade == 0) return ;
-		GlobalMapGrade mg = findGlobalMapGrade(mapHash);
-		if (mg == null) {
-			mg = new GlobalMapGrade(mapHash);
-			globalMapGrades.add(mg);
-		}
-		mg.avGrade = (mg.avGrade * mg.noVotes + grade) / (++mg.noVotes);
-	}
-	
-	/* will update client's grade list and also global grade list */
-	public static void updateLocalAndGlobalGrade(Client client, String mapHash, int grade) {
-		if (grade == 0) return ; // 0 means user hasn't graded the map yet, so we ignore it
-
-		if (client.account.getRank() &lt; 3) return ; // accept only grades from players with rank higher than &quot;beginner&quot;
-		
-		MapGrade mg = client.account.mapGrades.findMapGrade(mapHash);
-		if (mg == null) { // this is client's first time grading this map
-			mg = new MapGrade(mapHash, grade, 0);
-			client.account.mapGrades.add(mg);
-			// update global map grades:
-			GlobalMapGrade gmg = findGlobalMapGrade(mapHash);
-			if (gmg == null) {
-				gmg = new GlobalMapGrade(mapHash);
-				globalMapGrades.add(gmg);
-			}
-			gmg.avGrade = (gmg.avGrade * gmg.noVotes + grade) / (++gmg.noVotes);
-		} else { // client is only adjusting grade for this map
-			if (mg.grade == grade) return ; // no change
-			int diff = grade - mg.grade;
-			mg.grade = grade;
-			// update global map grades:
-			GlobalMapGrade gmg = findGlobalMapGrade(mapHash);
-			if (gmg == null) {
-				gmg = new GlobalMapGrade(mapHash);
-				globalMapGrades.add(gmg);
-			}
-			gmg.avGrade = (gmg.avGrade * gmg.noVotes + diff) / gmg.noVotes;
-		}		
-	}
-	
-	/* 'addMins' - how many minutes to add to the &quot;map grade&quot; */
-	public static void updateLocalMapGradeMins(Client client, String mapHash, int addMins) {
-		MapGrade mg = client.account.mapGrades.findMapGrade(mapHash);
-		if (mg == null) {
-			mg = new MapGrade(mapHash, 0, addMins);
-			client.account.mapGrades.add(mg);
-		} else {
-			mg.mins += addMins;
-		}
-	}
-	
-}

Modified: Lobby/TASServer/TASServer.java
===================================================================
--- Lobby/TASServer/TASServer.java	2009-03-11 20:00:27 UTC (rev 7249)
+++ Lobby/TASServer/TASServer.java	2009-03-11 20:39:52 UTC (rev 7250)
@@ -730,7 +730,7 @@
 						return false;
 					}
 
-				acc = new Account(commands[1], commands[2], Account.NORMAL_ACCESS, Account.NO_USER_ID, System.currentTimeMillis(), client.IP, System.currentTimeMillis(), client.country, new MapGradeList());
+				acc = new Account(commands[1], commands[2], Account.NORMAL_ACCESS, Account.NO_USER_ID, System.currentTimeMillis(), client.IP, System.currentTimeMillis(), client.country);
 				Accounts.addAccount(acc);
 				Accounts.saveAccounts(false); // let's save new accounts info to disk
 				client.sendLine(&quot;REGISTRATIONACCEPTED&quot;);
@@ -1594,8 +1594,8 @@
 						client.sendLine(&quot;DENIED Player with same name already logged in&quot;);
 						return false;
 					}
-					if ((commands[1].equals(lanAdminUsername)) &amp;&amp; (commands[2].equals(lanAdminPassword))) acc = new Account(commands[1], commands[2], Account.ADMIN_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;, new MapGradeList());
-					else acc = new Account(commands[1], commands[2], Account.NORMAL_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;, new MapGradeList());
+					if ((commands[1].equals(lanAdminUsername)) &amp;&amp; (commands[2].equals(lanAdminPassword))) acc = new Account(commands[1], commands[2], Account.ADMIN_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;);
+					else acc = new Account(commands[1], commands[2], Account.NORMAL_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;);
 					Accounts.addAccount(acc);
 					client.account = acc;
 				}
@@ -1688,7 +1688,7 @@
 					Channels.getChannel(i).muteList.rename(client.account.user, commands[1]);
 				}
 
-				acc = new Account(commands[1], client.account.pass, client.account.access, client.account.lastUserID, System.currentTimeMillis(), client.IP, client.account.registrationDate, client.account.lastCountry, client.account.mapGrades);
+				acc = new Account(commands[1], client.account.pass, client.account.access, client.account.lastUserID, System.currentTimeMillis(), client.IP, client.account.registrationDate, client.account.lastCountry);
 				client.sendLine(&quot;SERVERMSG Your account has been renamed to &lt;&quot; + commands[1] + &quot;&gt;. Reconnect with new account (you will now be automatically disconnected)!&quot;);
 				Clients.killClient(client, &quot;Quit: renaming account&quot;);
 				Accounts.replaceAccount(client.account, acc);
@@ -2048,17 +2048,13 @@
 							// tell clients to replace battle port with founder's public UDP source port:
 							bat.sendToAllExceptFounder(&quot;HOSTPORT &quot; + client.UDPSourcePort);
 						}
-						if (bat != null) client.mapHashUponEnteringGame = Misc.intToHex(bat.mapHash);
 					} else { // back from game
 						if (client.inGameTime != 0) { // we won't update clients who play by themselves (or with bots only), since some try to exploit the system by leaving computer alone in-battle for hours to increase their ranks
 							int diff = new Long((System.currentTimeMillis() - client.inGameTime) / 60000).intValue(); // in minutes
 							if (client.account.addMinsToInGameTime(diff)) {
 								client.setRankToStatus(client.account.getRank());
 							}
-							// we will also update map in-game time for this client here:
-							if(client.mapHashUponEnteringGame != null) MapGrading.updateLocalMapGradeMins(client, client.mapHashUponEnteringGame, diff);
 						}
-						client.mapHashUponEnteringGame = null;
 					}
 				}
 				Clients.notifyClientsOfNewClientStatus(client);
@@ -2661,47 +2657,6 @@
 				// relay the command
 				bat.sendToAllClients(loweyKeyCommand);
 			}
-			else if (commands[0].equals(&quot;MAPGRADES&quot;)) {
-				if (commands.length &lt; 2) return false;
-				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-
-				if (LAN_MODE) {
-					client.sendLine(&quot;MAPGRADESFAILED Unable to synchronize map grades - server is running in LAN mode!&quot;);
-					return false;
-				}
-
-				String[] tokens = Misc.makeSentence(commands, 1).split(&quot; &quot;);
-				if (tokens.length % 2 != 0) {
-					client.sendLine(&quot;MAPGRADESFAILED Invalid params to MAPGRADES command!&quot;);
-					return false;
-				}
-
-				if (System.currentTimeMillis() - client.lastMapGradesReceived &lt; minSleepTimeBetweenMapGrades * 1000) {
-					client.sendLine(&quot;MAPGRADESFAILED Less than &quot; + minSleepTimeBetweenMapGrades + &quot; seconds have passed since your last synchronization, try again later!&quot;);
-					return false;
-				}
-
-				String respond = &quot;MAPGRADES&quot;; // message that we will send back to the client
-				try {
-					for (int i = 0; i &lt; tokens.length / 2; i++) {
-						String hash = tokens[i*2].toUpperCase();
-						int grade;
-						try {
-							Long.parseLong(hash, 16);
-							grade = Integer.parseInt(tokens[i*2+1]);
-						} catch (NumberFormatException e) {
-							return false;
-						}
-						if ((grade &lt; 0) || (grade &gt; 10)) return false;
-						MapGrading.updateLocalAndGlobalGrade(client, hash, grade);
-						respond += &quot; &quot; + hash + &quot; &quot; + MapGrading.getAvarageMapGrade(hash) + &quot; &quot; + MapGrading.getNumberOfMapVotes(hash);
-					}
-					client.sendLine(respond);
-					client.lastMapGradesReceived = System.currentTimeMillis();
-				} catch (Exception e) {
-					return false;
-				}
-			}
 			else {
 				// unknown command!
 				return false;
@@ -2946,9 +2901,6 @@
 			System.out.println(&quot;&lt;IP2Country&gt; loaded in &quot; + tempTime + &quot; ms.&quot;);
 		}
 
-		// construct global map grade list:
-		MapGrading.reconstructGlobalMapGrades();
-
 		// start &quot;help UDP&quot; server:
 		helpUDPsrvr = new NATHelpServer(NAT_TRAVERSAL_PORT);
 		helpUDPsrvr.start();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002018.html">[Taspring-linux-commit] r7249 - Lobby/TASServer
</A></li>
	<LI>Next message: <A HREF="002020.html">[Taspring-linux-commit] r7251 -	Lobby/TASServer/Documentation/Protocol
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2019">[ date ]</a>
              <a href="thread.html#2019">[ thread ]</a>
              <a href="subject.html#2019">[ subject ]</a>
              <a href="author.html#2019">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
