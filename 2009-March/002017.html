<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7248 - Lobby/TASServer
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7248%20-%20Lobby/TASServer&In-Reply-To=%3C20090311194235.DE80148825%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002016.html">
   <LINK REL="Next"  HREF="002018.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7248 - Lobby/TASServer</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7248%20-%20Lobby/TASServer&In-Reply-To=%3C20090311194235.DE80148825%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7248 - Lobby/TASServer">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Mar 11 20:42:35 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002016.html">[Taspring-linux-commit] r7247 - Lobby/TASServer/Documentation
</A></li>
        <LI>Next message: <A HREF="002018.html">[Taspring-linux-commit] r7249 - Lobby/TASServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2017">[ date ]</a>
              <a href="thread.html#2017">[ thread ]</a>
              <a href="subject.html#2017">[ subject ]</a>
              <a href="author.html#2017">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tvo
Date: 2009-03-11 20:42:35 +0100 (Wed, 11 Mar 2009)
New Revision: 7248

Modified:
   Lobby/TASServer/TASServer.java
Log:
Backported small fix someone made on main server which disallows empty usernames in LAN mode.



Modified: Lobby/TASServer/TASServer.java
===================================================================
--- Lobby/TASServer/TASServer.java	2009-03-04 10:21:09 UTC (rev 7247)
+++ Lobby/TASServer/TASServer.java	2009-03-11 19:42:35 UTC (rev 7248)
@@ -1,7 +1,7 @@
 /*
  * Created on 2005.6.16
- * 
- * 
+ *
+ *
  * ---- INTERNAL CHANGELOG ----
  * *** 0.35 ***
  * * added 'servermode' argument to TASSERVER command
@@ -13,7 +13,7 @@
  * * added SETLATESTSPRINGVERSION and RELOADUPDATEPROPERTIES commands
  * *** 0.32 ***
  * * added option to mute by IP
- * * replaced CLIENTPORT command with CLIENTOIPPORT command and also 
+ * * replaced CLIENTPORT command with CLIENTOIPPORT command and also
  *   removed IP field from the ADDUSER command (this way IPs are no longer
  *   public unless you join a battle that uses nat traversal, where host
  *   needs to know your IP in order for the nat traversal trick to work)
@@ -36,16 +36,16 @@
  * *** 0.22 ***
  * * added SETCHANNELKEY command, also modified JOIN command to accept extra
  *   argument for locked channels
- * * added FORCELEAVECHANNEL command  
+ * * added FORCELEAVECHANNEL command
  * * LEFT command now contains (optional) &quot;reason&quot; parameter
  * * replaced CHANNELS command with CHANNEL and ENDOFCHANNELS commands (see
  *   protocol description)
- * * limited maximum length of chat messages  
+ * * limited maximum length of chat messages
  * *** 0.20 ***
  * * added CHANGEPASSWORD command
  * * GETINGAMETIME now also accepts no argument (to return your own in-game time)
  * * CHANNELTOPIC command now includes author name and time
- * * added -LOGMAIN switch 
+ * * added -LOGMAIN switch
  * * added GETLASTIP command, FINDIP is available to privileged users as well now
  * * fixed bug with /me being available even after being muted
  * * CHANNELMESSAGE command now available to moderators as well
@@ -56,12 +56,12 @@
  *   statistics.
  * * fixed RING command (only host can ring players participating in his own battle, unless
  *   the target is host himself)
- * * fixed KICK command so that now player who's been kicked is notified about it 
+ * * fixed KICK command so that now player who's been kicked is notified about it
  *   (also kick command accepts &quot;reason&quot; string now)
  * * added &quot;GETLASTLOGINTIME&quot; command (for moderators)
  * * fixed bug with clients behind same NAT not getting local IPs in certain cases
  * * added simple UDP server to help with NAT traversing (see NATHelpServer.java)
- * * added UDPSOURCEPORT, CLIENTPORT and HOSTPORT commands (used with NAT traversing)      
+ * * added UDPSOURCEPORT, CLIENTPORT and HOSTPORT commands (used with NAT traversing)
  * *** 0.191 ***
  * * fixed bug with server allowing clients to have several battles open at the same time
  * *** 0.19 ***
@@ -71,7 +71,7 @@
  * * added MUTE, UNMUTE and MUTELIST commands
  * * clients behind same NAT now get local IPs instead of external one (from the server).
  *   This should resolve some issues with people playing games behind same NAT.
- * * added &quot;agreement&quot;  
+ * * added &quot;agreement&quot;
  * *** 0.18 ***
  * * multiple mod side support (battle status bits have changed)
  * * user who flood are now automatically banned by server
@@ -80,20 +80,20 @@
  *   (max. in-game time server can record is 2^20 minutes)
  * * rewrote the network code to use java.nio classes. This fixes several known
  *   problems with server and also fixes multiplayer replay option.
- * * implemented simple anti-flood protection  
- * * removed old file transfer commands      
+ * * implemented simple anti-flood protection
+ * * removed old file transfer commands
  * *** 0.16 ***
  * * added new host option - diminishing metal maker returns
- * * switched to Webnet77's ip-to-country database, which seems to be more frequently 
+ * * switched to Webnet77's ip-to-country database, which seems to be more frequently
  *   updated: <A HREF="http://software77.net/cgi-bin/ip-country/geo-ip.pl">http://software77.net/cgi-bin/ip-country/geo-ip.pl</A>
- * * added &quot;locked&quot; parameter to UPDATEBATTLEINFO command   
+ * * added &quot;locked&quot; parameter to UPDATEBATTLEINFO command
  * * added &quot;multiplayer replays&quot; support
  * *** 0.152 ***
  * * fixed small bug with server not updating rank when maximum level has been reached
  * * added ban list
  * *** 0.151 ***
  * * added OFFERUPDATEEX command
- * * added country code support 
+ * * added country code support
  * * added simple protection against rank exploiters
  * * added cpu info (LOGIN command now requires additional parameter)
  * * limited usernames/passwords to 20 chars
@@ -103,117 +103,117 @@
  * *** 0.14 ***
  * * added FORCETEAMCOLOR command
  * * fixed bug which allowed users to register accounts with username/password containing
- *   chars from 43 to 57 (dec), which should be numbers (the correct number range is 48 
+ *   chars from 43 to 57 (dec), which should be numbers (the correct number range is 48
  *   to 57). Invalid chars are &quot;+&quot;, &quot;,&quot;, &quot;-&quot;, &quot;.&quot; and &quot;/&quot;.
- * * added ranking system  
+ * * added ranking system
  * *** 0.13 ***
  * * added AI support
  * * added KICKUSER command (admins only)
  * * fixed bug when server did not allow client to change its ally number if someone
  *   else used it, even if that was only a spectator.
- * * added away status bit  
+ * * added away status bit
  * * fixed bug when server denied  request to battle, if there were maxplayers+1 players
  *   already in the battle.
  * * added new commands: SERVERMSG, SERVERMSGBOX, REQUESTUPDATEFILE, GETFILE
  * * added some admin commands
  * * changed registration process so that now you can't register username which is same
- *   as someone elses, if we ignore case. Usernames are still case-sensitive though.  
+ *   as someone elses, if we ignore case. Usernames are still case-sensitive though.
  *
  *
  * ---- NOTES ----
- * 
+ *
  * * Client may participate in only one battle at the same time. If he is hosting a battle,
- *   he may not participate in other battles at the same time. Server checks for that 
+ *   he may not participate in other battles at the same time. Server checks for that
  *   automatically.
- *   
+ *
  * * Lines sent and received may be of any length. I've tested it with 600 KB long strings
  *   and it worked in both directions. Nevertheless, commands like &quot;CLIENTS&quot; still try to
  *   divide data into several lines, just to make sure client will receive it. Since delphi
  *   lobby client now supports lines of any length, dividing data into several lines is not
- *   needed anymore. Nevertheless I kept it just in case, to be compatible with other clients 
+ *   needed anymore. Nevertheless I kept it just in case, to be compatible with other clients
  *   which may emerge in the future. I don't divide data when sending info on battles
  *   and clients in battles. This lines may get long, but not longer than a couple of hundreds
  *   of bytes (they should always be under 1 KB in length).
- *   
+ *
  * * Sentences must be separated by TAB characters. This also means there should be no TABs
  *   present in your sentences, since TABs are delimiters. That is why you should always
  *   replace any TABs with spaces (2 or 8 usually).
- *   
+ *
  * * Syncing works by clients comparing host's hash code with their own. If the two codes
  *   match, client should update his battle status and so telling other clients in the battle
- *   that he is synced (or unsynced otherwise). Hash code comes from hashing mod's file 
+ *   that he is synced (or unsynced otherwise). Hash code comes from hashing mod's file
  *   and probably all the dependences too.
- * 
+ *
  * * Try not to edit account file manually! If you do, don't forget that access numbers
  *   must be in binary form!
- * 
+ *
  * * Team colors are currently set by players, perhaps it would be better if only host would
  *   be able to change them?
- * 
+ *
  * * Whenever you use killClient() within a for loop, don't forget to decrease loop
  *   counter as you will skip next client in the list otherwise. (this was the cause
  *   for some of the &quot;ambigious data&quot; errors). Or better, use the killClientDelayed()
- *   method.  
- * 
+ *   method.
+ *
  * * Note that access to long-s is not guaranteed to be atomic, but you should use synchronization
  *   anyway if you use multiple threads.
- *   
- * 
+ *
+ *
  * ---- LINKS ----
- *  
+ *
  * Great article on how to handle network timeouts in Java: <A HREF="http://www.javacoffeebreak.com/articles/network_timeouts/">http://www.javacoffeebreak.com/articles/network_timeouts/</A>
- * 
+ *
  * Another one on network timeouts and alike: <A HREF="http://www.mindprod.com/jgloss/socket.html">http://www.mindprod.com/jgloss/socket.html</A>
- * 
+ *
  * Great article on thread synchronization: <A HREF="http://today.java.net/pub/a/today/2004/08/02/sync1.html">http://today.java.net/pub/a/today/2004/08/02/sync1.html</A>
- * 
+ *
  * Throwing exceptions: <A HREF="http://java.sun.com/docs/books/tutorial/essential/exceptions/throwing.html">http://java.sun.com/docs/books/tutorial/essential/exceptions/throwing.html</A>
- * 
+ *
  * Sun's tutorial on sockets: <A HREF="http://java.sun.com/docs/books/tutorial/networking/sockets/">http://java.sun.com/docs/books/tutorial/networking/sockets/</A>
- * 
+ *
  * How to redirect program's output by duplicating handles in windows' command prompt: <A HREF="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/redirection.mspx">http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/redirection.mspx</A>
- * 
- * How to get local IP address (like &quot;192.168.1.1&quot; and not &quot;127.0.0.1&quot;): <A HREF="http://forum.java.sun.com/thread.jspa?threadID=619056&amp;messageID=3477258">http://forum.java.sun.com/thread.jspa?threadID=619056&amp;messageID=3477258</A> 
- * 
+ *
+ * How to get local IP address (like &quot;192.168.1.1&quot; and not &quot;127.0.0.1&quot;): <A HREF="http://forum.java.sun.com/thread.jspa?threadID=619056&amp;messageID=3477258">http://forum.java.sun.com/thread.jspa?threadID=619056&amp;messageID=3477258</A>
+ *
  * IP-to-country databases: <A HREF="http://ip-to-country.webhosting.info,">http://ip-to-country.webhosting.info,</A> <A HREF="http://software77.net/cgi-bin/ip-country/geo-ip.pl">http://software77.net/cgi-bin/ip-country/geo-ip.pl</A>
- * 
+ *
  * Another set of 232 country flags: <A HREF="http://www.ip2location.com/free.asp">http://www.ip2location.com/free.asp</A>
- * 
+ *
  * Some source code on how to build client-server with java.nio classes (I used ChatterServer.java code from this link): <A HREF="http://brackeen.com/javagamebook/ch06src.zip">http://brackeen.com/javagamebook/ch06src.zip</A>
  * (found it through this link: <A HREF="http://www.gamedev.net/community/forums/topic.asp?topic_id=318099">http://www.gamedev.net/community/forums/topic.asp?topic_id=318099</A>)
- * 
+ *
  * Source for some simple threaded UDP server: <A HREF="http://java.sun.com/docs/books/tutorial/networking/datagrams/example-1dot1/QuoteServerThread.java">http://java.sun.com/docs/books/tutorial/networking/datagrams/example-1dot1/QuoteServerThread.java</A>
- * 
+ *
  * How to properly document thread-safety when writing classes: <A HREF="http://www-128.ibm.com/developerworks/java/library/j-jtp09263.html">http://www-128.ibm.com/developerworks/java/library/j-jtp09263.html</A>
- * 
+ *
  * Good article on immutables (like String etc.): <A HREF="http://macchiato.com/columns/Durable2.html">http://macchiato.com/columns/Durable2.html</A>
- * 
+ *
  * General info on thread-safety in java: <A HREF="http://mindprod.com/jgloss/threadsafe.html">http://mindprod.com/jgloss/threadsafe.html</A>
- * 
+ *
  * How to use ZIP with java: <A HREF="http://java.sun.com/developer/technicalArticles/Programming/compression/">http://java.sun.com/developer/technicalArticles/Programming/compression/</A>
- * 
+ *
  * How to download file from URL: <A HREF="http://schmidt.devlib.org/java/file-download.html">http://schmidt.devlib.org/java/file-download.html</A>
- * 
+ *
  * Very good article on exceptions: <A HREF="http://www.freshsources.com/Apr01.html">http://www.freshsources.com/Apr01.html</A>
- * 
+ *
  * Short introduction to generics in JDK 1.5.0: <A HREF="http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html">http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html</A>
- * 
+ *
  * ---- NAT TRAVERSAL ----
- * 
+ *
  * Primary NAT traversal technique that this lobby server/client implements is &quot;hole punching&quot;
  * technique. See these links for more info:
- * 
+ *
  * <A HREF="http://www.brynosaurus.com/pub/net/p2pnat/">http://www.brynosaurus.com/pub/net/p2pnat/</A>
  * <A HREF="http://www.potaroo.net/ietf/idref/draft-ford-natp2p/">http://www.potaroo.net/ietf/idref/draft-ford-natp2p/</A>
  * <A HREF="http://www.newport-networks.com/whitepapers/nat-traversal1.html">http://www.newport-networks.com/whitepapers/nat-traversal1.html</A>
- * 
+ *
  * See source code for implementation details.
  *
  *
  * ---- PROTOCOL ----
- * 
+ *
  * [this section was moved to the Documentation folder in SVN]
- * 
+ *
  */
 
 /**
@@ -230,7 +230,7 @@
 import java.util.regex.*;
 
 public class TASServer {
-	
+
 	static final String VERSION = &quot;0.35&quot;;
 	static byte DEBUG = 1; // 0 - no verbose, 1 - normal verbose, 2 - extensive verbose
 	static String MOTD = &quot;Enjoy your stay :-)&quot;;
@@ -245,7 +245,7 @@
 	static final String UPDATE_PROPERTIES_FILENAME = &quot;updates.xml&quot;;
 	static final int DEFAULT_SERVER_PORT = 8200; // default server (TCP) port
 	static int serverPort = DEFAULT_SERVER_PORT; // actual server (TCP) port to be used (or currently in use)
-	static int NAT_TRAVERSAL_PORT = 8201; // default UDP port used with some NAT traversal technique. If this port is not forwarded, hole punching technique will not work. 
+	static int NAT_TRAVERSAL_PORT = 8201; // default UDP port used with some NAT traversal technique. If this port is not forwarded, hole punching technique will not work.
 	static final int TIMEOUT_LENGTH = 30000; // in milliseconds
 	static boolean LAN_MODE = false;
 	static boolean redirect = false; // if true, server is redirection clients to new IP
@@ -258,34 +258,34 @@
 	static PrintStream mainChanLog;
 	static String lanAdminUsername = &quot;admin&quot;; // default lan admin account. Can be overwritten with -LANADMIN switch. Used only when server is running in lan mode!
 	static String lanAdminPassword = Misc.encodePassword(&quot;admin&quot;);
-	static long purgeMutesInterval = 1000 * 3; // in miliseconds. On this interval, all channels' mute lists will be checked for expirations and purged accordingly. 
+	static long purgeMutesInterval = 1000 * 3; // in miliseconds. On this interval, all channels' mute lists will be checked for expirations and purged accordingly.
 	static long lastMutesPurgeTime = System.currentTimeMillis(); // time when we last purged mute lists of all channels
-	static String[] reservedAccountNames = {&quot;TASServer&quot;, &quot;Server&quot;, &quot;server&quot;}; // accounts with these names cannot be registered (since they may be used internally by the server) 
+	static String[] reservedAccountNames = {&quot;TASServer&quot;, &quot;Server&quot;, &quot;server&quot;}; // accounts with these names cannot be registered (since they may be used internally by the server)
 	static final long minSleepTimeBetweenMapGrades = 5; // minimum time (in seconds) required between two consecutive MAPGRADES command sent by the client. We need this to ensure that client doesn't send MAPGRADES command too often as it creates much load on the server.
-	private static int MAX_TEAMS = 16; // max. teams/allies numbers supported by Spring 
+	private static int MAX_TEAMS = 16; // max. teams/allies numbers supported by Spring
 	public static boolean initializationFinished = false; // we set this to 'true' just before we enter the main loop. We need this information when saving accounts for example, so that we don't dump empty accounts to disk when an error has occured before initialization has been completed
 	static ArrayList&lt;FailedLoginAttempt&gt; failedLoginAttempts = new ArrayList&lt;FailedLoginAttempt&gt;(); // here we store information on latest failed login attempts. We use it to block users from brute-forcing other accounts
 	static long lastFailedLoginsPurgeTime = System.currentTimeMillis(); // time when we last purged list of failed login attempts
-	
+
 	// database related:
 	public static DBInterface database;
 	private static String DB_URL = &quot;jdbc:<A HREF="mysql://127.0.0.1/spring">mysql://127.0.0.1/spring</A>&quot;;
 	private static String DB_username = &quot;&quot;;
 	private static String DB_password = &quot;&quot;;
-	
+
     private static final int READ_BUFFER_SIZE = 256; // size of the ByteBuffer used to read data from the socket channel. This size doesn't really matter - server will work with any size (tested with READ_BUFFER_SIZE==1), but too small buffer size may impact the performance.
     private static final int SEND_BUFFER_SIZE = 8192*2; // socket's send buffer size
     private static final long MAIN_LOOP_SLEEP = 10L;
     public static final int NO_MSG_ID = -1; // meaning message isn't using an ID (see protocol description on message/command IDs)
-    
+
     private static final int recvRecordPeriod = 10; // in seconds. Length of time period for which we keep record of bytes received from client. Used with anti-flood protection.
     private static final int maxBytesAlert = 20000; // maximum number of bytes received in the last recvRecordPeriod seconds from a single client before we raise &quot;flood alert&quot;. Used with anti-flood protection.
     private static final int maxBytesAlertForBot = 50000; // same as 'maxBytesAlert' but is used for clients in &quot;bot mode&quot; only (see client.status bits)
     private static long lastFloodCheckedTime = System.currentTimeMillis(); // time (in same format as System.currentTimeMillis) when we last updated it. Used with anti-flood protection.
     private static long maxChatMessageLength = 1024; // used with basic anti-flood protection. Any chat messages (channel or private chat messages) longer than this are considered flooding. Used with following commands: SAY, SAYEX, SAYPRIVATE, SAYBATTLE, SAYBATTLEEX
-    
+
     private static long lastTimeoutCheck = System.currentTimeMillis(); // time (System.currentTimeMillis()) when we last checked for timeouts from clients
-    
+
     private static ServerSocketChannel sSockChan;
     private static Selector readSelector;
     //***private static SelectionKey selectKey;
@@ -293,33 +293,33 @@
     private static ByteBuffer readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE); // see <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html">http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html</A> for difference between direct and non-direct buffers. In this case we should use direct buffers, this is also used by the author of java.nio chat example (see links) upon which this code is built on.
     public static CharsetDecoder asciiDecoder;
     public static CharsetEncoder asciiEncoder;
-    
+
     /* in 'updateProperties' we store a list of Spring versions and server responses to them.
-     * We use it when client doesn't have the latest Spring version or the lobby program 
+     * We use it when client doesn't have the latest Spring version or the lobby program
      * and requests an update from us. The XML file should normally contain at least the &quot;default&quot; key
      * which contains a standard response in case no suitable response is found.
      * Each text field associated with a key contains a full string that will be send to the client
-     * as a response, so it should contain a full server command. 
-     */    
-    private static Properties updateProperties = new Properties(); 
-    
+     * as a response, so it should contain a full server command.
+     */
+    private static Properties updateProperties = new Properties();
+
 	static NATHelpServer helpUDPsrvr;
-	
+
 	public static void writeMainChanLog(String text) {
 		if (!LOG_MAIN_CHANNEL) return;
-		
+
 		try {
 			mainChanLog.println(Misc.easyDateFormat(&quot;&lt;HH:mm:ss&gt; &quot;) + text);
 		} catch (Exception e) {
 			TASServer.LOG_MAIN_CHANNEL = false;
 			System.out.println(&quot;$ERROR: Unable to write main channel log file (MainChanLog.log)&quot;);
-		}		
+		}
 	}
-	
+
 	/* reads MOTD from disk (if file is found) */
 	private static boolean readMOTD(String fileName)
 	{
-		String newMOTD = &quot;&quot;; 
+		String newMOTD = &quot;&quot;;
 		try {
 			BufferedReader in = new BufferedReader(new FileReader(fileName));
 			String line;
@@ -334,47 +334,47 @@
 		MOTD = newMOTD;
 		return true;
 	}
-	
+
 	private static boolean readUpdateProperties(String fileName) {
-		FileInputStream fStream = null; 
-		try {  
-			fStream = new FileInputStream(fileName); 
-			updateProperties.loadFromXML(fStream); 
+		FileInputStream fStream = null;
+		try {
+			fStream = new FileInputStream(fileName);
+			updateProperties.loadFromXML(fStream);
 		} catch (IOException e) {
 			return false;
-		} finally {  
-			if (fStream != null) {  
-				try {  
-					fStream.close(); 
-				} catch (IOException e) {  
-				}  
-			}  
-		} 		
+		} finally {
+			if (fStream != null) {
+				try {
+					fStream.close();
+				} catch (IOException e) {
+				}
+			}
+		}
 		return true;
 	}
-	
+
 	private static boolean writeUpdateProperties(String fileName) {
-		FileOutputStream fStream = null; 
-		try {  
-			fStream = new FileOutputStream(fileName); 
-			updateProperties.storeToXML(fStream, null); 
+		FileOutputStream fStream = null;
+		try {
+			fStream = new FileOutputStream(fileName);
+			updateProperties.storeToXML(fStream, null);
 		} catch (IOException e) {
 			return false;
-		} finally {  
-			if (fStream != null) {  
-				try {  
-					fStream.close(); 
-				} catch (IOException e) {  
-				}  
-			}  
-		} 		
+		} finally {
+			if (fStream != null) {
+				try {
+					fStream.close();
+				} catch (IOException e) {
+				}
+			}
+		}
 		return true;
-	}	
+	}
 
 	/* reads agreement from disk (if file is found) */
 	private static void readAgreement()
 	{
-		String newAgreement = &quot;&quot;; 
+		String newAgreement = &quot;&quot;;
 		try {
 			BufferedReader in = new BufferedReader(new FileReader(AGREEMENT_FILENAME));
 			String line;
@@ -388,10 +388,10 @@
 		}
 		if (newAgreement.length() &gt; 2) agreement = newAgreement;
 	}
-	
+
 	public static void closeServerAndExit() {
 		System.out.println(&quot;Server stopped.&quot;);
-		if (!LAN_MODE &amp;&amp; initializationFinished) Accounts.saveAccounts(true); // we need to check if initialization has completed so that we don't save empty accounts array and so overwrite actual accounts 
+		if (!LAN_MODE &amp;&amp; initializationFinished) Accounts.saveAccounts(true); // we need to check if initialization has completed so that we don't save empty accounts array and so overwrite actual accounts
 		if (helpUDPsrvr != null &amp;&amp; helpUDPsrvr.isAlive()) {
 			helpUDPsrvr.stopServer();
 			try {
@@ -417,31 +417,31 @@
 		running = false;
 		System.exit(0);
 	}
-	
+
 	private static boolean changeCharset(String newCharset) throws IllegalCharsetNameException, UnsupportedCharsetException {
 		CharsetDecoder dec;
 		CharsetEncoder enc;
-		
+
 		dec = Charset.forName(newCharset).newDecoder();
 		enc = Charset.forName(newCharset).newEncoder();
-		
+
 		asciiDecoder = dec;
 	    asciiDecoder.replaceWith(&quot;?&quot;);
 	    asciiDecoder.onUnmappableCharacter(CodingErrorAction.REPLACE);
 	    asciiDecoder.onMalformedInput(CodingErrorAction.REPLACE);
-	    
+
 		asciiEncoder = enc;
 	    asciiEncoder.replaceWith(new byte[] { (byte)'?' });
 	    asciiEncoder.onUnmappableCharacter(CodingErrorAction.REPLACE);
 	    asciiEncoder.onMalformedInput(CodingErrorAction.REPLACE);
-	
+
 		return true;
 	}
-	
+
 	private static boolean startServer(int port) {
 		try {
 			changeCharset(&quot;ISO-8859-1&quot;); // initializes asciiDecoder and asciiEncoder
-			
+
 		    // open a non-blocking server socket channel
 		    sSockChan = ServerSocketChannel.open();
 		    sSockChan.configureBlocking(false);
@@ -453,22 +453,22 @@
 
 		    // get a selector for multiplexing the client channels
 		    readSelector = Selector.open();
-		    
+
 		} catch (IOException e) {
 		    System.out.println(&quot;Could not listen on port: &quot; + port);
 		    return false;
 		}
-		
+
 		System.out.println(&quot;Port &quot; + port + &quot; is open\n&quot; +
 				 &quot;Listening for connections ...&quot;);
-		
+
 		return true;
 	}
-	
+
 	private static void acceptNewConnections() {
 		try {
 		    SocketChannel clientChannel;
-		    // since sSockChan is non-blocking, this will return immediately 
+		    // since sSockChan is non-blocking, this will return immediately
 		    // regardless of whether there is a connection available
 		    while ((clientChannel = sSockChan.accept()) != null) {
 	        	if (redirect) {
@@ -476,15 +476,15 @@
 	        		redirectAndKill(clientChannel.socket());
 	        		continue;
 	        	}
-		    	
+
 		    	Client client = Clients.addNewClient(clientChannel, readSelector, SEND_BUFFER_SIZE);
 				if (client == null) continue;
-	        	
+
 		    	// from this point on, we know that client has been successfully connected
 				client.sendWelcomeMessage();
-				
+
 	        	if (DEBUG &gt; 0) System.out.println(&quot;New client connected: &quot; + client.IP);
-		    }		
+		    }
 		}
 		catch (IOException ioe) {
 		    System.out.println(&quot;error during accept(): &quot; + ioe.toString());
@@ -496,14 +496,14 @@
 
 	private static void readIncomingMessages() {
 		Client client = null;
-		
+
 		try {
 		    // non-blocking select, returns immediately regardless of how many keys are ready
 		    readSelector.selectNow();
-		    
+
 		    // fetch the keys
 		    Set readyKeys = readSelector.selectedKeys();
-		    
+
 		    // run through the keys and process each one
 		    Iterator i = readyKeys.iterator();
 		    while (i.hasNext()) {
@@ -515,13 +515,13 @@
 				readBuffer.clear();
 
 				client.timeOfLastReceive = System.currentTimeMillis();
-				
+
 				// read from the channel into our buffer
 				long nbytes = channel.read(readBuffer);
 				client.dataOverLastTimePeriod += nbytes;
-				
+
 				// basic anti-flood protection:
-				if ((client.account.accessLevel() &lt; Account.ADMIN_ACCESS) 
+				if ((client.account.accessLevel() &lt; Account.ADMIN_ACCESS)
 					&amp;&amp; (((client.getBotModeFromStatus() == false) &amp;&amp; (client.dataOverLastTimePeriod &gt; TASServer.maxBytesAlert)) ||
 					((client.getBotModeFromStatus() == true) &amp;&amp; (client.dataOverLastTimePeriod &gt; TASServer.maxBytesAlertForBot)))) {
 					System.out.println(&quot;WARNING: Flooding detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;)&quot;);
@@ -533,15 +533,15 @@
 					sn.addLine(&quot;Flooding detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;).&quot;);
 					sn.addLine(&quot;User has been kicked from the server.&quot;);
 					ServerNotifications.addNotification(sn);
-					
+
 					continue;
 				}
 
 				// check for end-of-stream
-				if (nbytes == -1) { 
+				if (nbytes == -1) {
 					if (DEBUG &gt; 0) System.out.println (&quot;Socket disconnected - killing client&quot;);
 					channel.close();
-					Clients.killClient(client); // will also close the socket channel 
+					Clients.killClient(client); // will also close the socket channel
 				} else {
 				    // use a CharsetDecoder to turn those bytes into a string
 				    // and append to client's StringBuilder
@@ -559,7 +559,7 @@
 				    	String command = line.substring(0, pos);
 				    	while (pos+1 &lt; line.length() &amp;&amp; (line.charAt(pos+1) == '\r' || line.charAt(pos+1) == '\n')) ++pos;
 				    	client.recvBuf.delete(0, pos+1);
-				    	
+
 				    	long time = System.currentTimeMillis();
 				    	tryToExecCommand(command, client);
 				    	time = System.currentTimeMillis() - time;
@@ -575,26 +575,26 @@
 		} catch(IOException ioe) {
 			System.out.println(&quot;exception during select(): possibly due to force disconnect. Killing the client ...&quot;);
 			try {
-				if (client != null) Clients.killClient(client, &quot;Quit: connection lost&quot;);				
+				if (client != null) Clients.killClient(client, &quot;Quit: connection lost&quot;);
 			} catch (Exception e) {
 			}
 		} catch(Exception e) {
 			System.out.println(&quot;exception in readIncomingMessages(): killing the client ... (&quot; + e.toString() + &quot;)&quot;);
 			try {
-				if (client != null) Clients.killClient(client, &quot;Quit: connection lost&quot;);		
+				if (client != null) Clients.killClient(client, &quot;Quit: connection lost&quot;);
 				e.printStackTrace(); //*** DEBUG
 			} catch (Exception ex) {
 			}
 		}
 	}
-	
+
 	private static Account verifyLogin(String user, String pass) {
 		Account acc = Accounts.getAccount(user);
 		if (acc == null) return null;
 		if (acc.pass.equals(pass)) return acc;
 		else return null;
 	}
-	
+
 	private static void recordFailedLoginAttempt(String username) {
 		FailedLoginAttempt attempt = findFailedLoginAttempt(username);
 		if (attempt == null) {
@@ -604,7 +604,7 @@
 		attempt.timeOfLastFailedAttempt = System.currentTimeMillis();
 		attempt.numOfFailedAttempts++;
 	}
-	
+
 	/** return null if no record found */
 	private static FailedLoginAttempt findFailedLoginAttempt(String username) {
 		for (int i = 0; i &lt; failedLoginAttempts.size(); i++) {
@@ -614,7 +614,7 @@
 		}
 		return null;
 	}
-	
+
 	/* Sends &quot;message of the day&quot; (MOTD) to client */
 	private static boolean sendMOTDToClient(Client client) {
 		client.beginFastWrite();
@@ -640,8 +640,8 @@
 		}
 		client.sendLine(&quot;AGREEMENTEND&quot;);
 		client.endFastWrite();
-	}	
-	
+	}
+
 	public static boolean redirectAndKill(Socket socket) {
 		if (!redirect) return false;
 		try {
@@ -651,18 +651,18 @@
 			return false;
 		}
 		return true;
-	}	
-	
-	/* Note: this method is not synchronized! 
+	}
+
+	/* Note: this method is not synchronized!
 	 * Note2: this method may be called recursively! */
 	public static boolean tryToExecCommand(String command, Client client) {
 		command = command.trim();
 		if (command.equals(&quot;&quot;)) return false;
 
-		if (DEBUG &gt; 1) 
+		if (DEBUG &gt; 1)
 			if (client.account.accessLevel() != Account.NIL_ACCESS) System.out.println(&quot;[&lt;-&quot; + client.account.user + &quot;]&quot; + &quot; \&quot;&quot; + command + &quot;\&quot;&quot;);
 			else System.out.println(&quot;[&lt;-&quot; + client.IP + &quot;]&quot; + &quot; \&quot;&quot; + command + &quot;\&quot;&quot;);
-		
+
 		int ID = NO_MSG_ID;
 		if (command.charAt(0) == '#') try {
 			if (!command.matches(&quot;^#\\d+\\s[\\s\\S]*&quot;)) return false; // malformed command
@@ -678,13 +678,13 @@
 		// parse command into tokens:
 		String[] commands = command.split(&quot; &quot;);
 		commands[0] = commands[0].toUpperCase();
-		
+
 		client.setSendMsgID(ID);
-		
+
 		try {
 			if (commands[0].equals(&quot;PING&quot;)) {
 				//***if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-			
+
 				client.sendLine(&quot;PONG&quot;);
 			}
 			if (commands[0].equals(&quot;REGISTER&quot;)) {
@@ -692,12 +692,12 @@
 					client.sendLine(&quot;REGISTRATIONDENIED Bad command arguments&quot;);
 					return false;
 				}
-							
+
 				if (client.account.accessLevel() != Account.NIL_ACCESS) { // only clients which aren't logged-in can register
 					client.sendLine(&quot;REGISTRATIONDENIED You are already logged-in, no need to register new account&quot;);
 					return false;
 				}
-				
+
 				if (LAN_MODE) { // no need to register account in LAN mode since it accepts any username
 					client.sendLine(&quot;REGISTRATIONDENIED Can't register in LAN-mode. Login with any username and password to proceed&quot;);
 					return false;
@@ -709,27 +709,27 @@
 					client.sendLine(&quot;REGISTRATIONDENIED Invalid username (reason: &quot; + valid + &quot;)&quot;);
 					return false;
 				}
-				
+
 				// validate password:
 				valid = Accounts.isPasswordValid(commands[2]);
 				if (valid != null) {
 					client.sendLine(&quot;REGISTRATIONDENIED Invalid password (reason: &quot; + valid + &quot;)&quot;);
 					return false;
 				}
-				
+
 				Account acc = Accounts.findAccountNoCase(commands[1]);
 				if (acc != null) {
 					client.sendLine(&quot;REGISTRATIONDENIED Account already exists&quot;);
 					return false;
 				}
-				
+
 				// check for reserved names:
 				for (int i = 0; i &lt; reservedAccountNames.length; i++)
 					if (reservedAccountNames[i].equals(commands[1])) {
 						client.sendLine(&quot;REGISTRATIONDENIED Invalid account name - you are trying to register a reserved account name&quot;);
 						return false;
 					}
-				
+
 				acc = new Account(commands[1], commands[2], Account.NORMAL_ACCESS, Account.NO_USER_ID, System.currentTimeMillis(), client.IP, System.currentTimeMillis(), client.country, new MapGradeList());
 				Accounts.addAccount(acc);
 				Accounts.saveAccounts(false); // let's save new accounts info to disk
@@ -738,17 +738,17 @@
 			else if (commands[0].equals(&quot;UPTIME&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
 				if (commands.length != 1) return false;
-				
+
 				client.sendLine(&quot;SERVERMSG Server's uptime is &quot; + Misc.timeToDHM(System.currentTimeMillis() - upTime));
 			}
 			/* some admin/moderator specific commands: */
 			else if (commands[0].equals(&quot;KICKUSER&quot;)) {
 				if (client.account.accessLevel() &lt; Account.PRIVILEGED_ACCESS) return false;
 				if (commands.length &lt; 2) return false;
-				
+
 				Client target = Clients.getClient(commands[1]);
 				String reason = &quot;&quot;;
-				if (commands.length &gt; 2) reason = &quot; (reason: &quot; + Misc.makeSentence(commands, 2) + &quot;)&quot;; 
+				if (commands.length &gt; 2) reason = &quot; (reason: &quot; + Misc.makeSentence(commands, 2) + &quot;)&quot;;
 				if (target == null) return false;
 				for (int i = 0; i &lt; Channels.getChannelsSize(); i++) {
 					if (Channels.getChannel(i).isClientInThisChannel(target)) {
@@ -761,9 +761,9 @@
 			else if (commands[0].equals(&quot;REMOVEACCOUNT&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 2) return false;
-				
+
 				if (!Accounts.removeAccount(commands[1])) return false;
-				
+
 				// if any user is connected to this account, kick him:
 				for (int j = 0; j &lt; Clients.getClientsSize(); j++) {
 					if (Clients.getClient(j).account.user.equals(commands[1])) {
@@ -771,40 +771,40 @@
 						j--;
 					}
 				}
-				
+
 				Accounts.saveAccounts(false); // let's save new accounts info to disk
 				client.sendLine(&quot;SERVERMSG You have successfully removed &lt;&quot; + commands[1] + &quot;&gt; account!&quot;);
 			}
 			else if (commands[0].equals(&quot;STOPSERVER&quot;)) {
 				// stop server gracefully:
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
-				
+
 				running = false;
 			}
 			else if (commands[0].equals(&quot;FORCESTOPSERVER&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
-				
+
 				closeServerAndExit();
 			}
 			else if (commands[0].equals(&quot;SAVEACCOUNTS&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
-				
+
 				Accounts.saveAccounts(false);
 				client.sendLine(&quot;SERVERMSG Accounts will be saved in a background thread.&quot;);
 			}
 			else if (commands[0].equals(&quot;CHANGEACCOUNTPASS&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 3) return false;
-				
+
 				Account acc = Accounts.getAccount(commands[1]);
-				if (acc == null) return false; 
+				if (acc == null) return false;
 				// validate password:
 				if (Accounts.isPasswordValid(commands[2]) != null) return false;
-				
+
 				acc.pass = commands[2];
-				
+
 				Accounts.saveAccounts(false); // save changes
-				
+
 				// add server notification:
 				ServerNotification sn = new ServerNotification(&quot;Account password changed by admin&quot;);
 				sn.addLine(&quot;Admin &lt;&quot; + client.account.user + &quot;&gt; has changed password for account &lt;&quot; + acc.user + &quot;&gt;&quot;);
@@ -816,25 +816,25 @@
 
 				int value;
 				try {
-					value = Integer.parseInt(commands[2]); 
+					value = Integer.parseInt(commands[2]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
-				
+
 				Account acc = Accounts.getAccount(commands[1]);
-				if (acc == null) return false; 
-				
+				if (acc == null) return false;
+
 				int oldAccess = acc.access;
 				acc.access = value;
-				
+
 				Accounts.saveAccounts(false); // save changes
 				 // just in case if rank got changed:
 				client.setRankToStatus(client.account.getRank());
-				
+
 				Clients.notifyClientsOfNewClientStatus(client);
 
 				client.sendLine(&quot;SERVERMSG You have changed password for &lt;&quot; + commands[1] + &quot;&gt; successfully.&quot;);
-				
+
 				// add server notification:
 				ServerNotification sn = new ServerNotification(&quot;Account access changed by admin&quot;);
 				sn.addLine(&quot;Admin &lt;&quot; + client.account.user + &quot;&gt; has changed access/status bits for account &lt;&quot; + acc.user + &quot;&gt;.&quot;);
@@ -850,7 +850,7 @@
 					client.sendLine(&quot;SERVERMSG User &lt;&quot; + commands[1] + &quot;&gt; not found!&quot;);
 					return false;
 				}
-				
+
 				client.sendLine(&quot;SERVERMSG &quot; + commands[1] + &quot;'s access code is &quot; + acc.access);
 			}
 			else if (commands[0].equals(&quot;REDIRECT&quot;)) {
@@ -860,22 +860,22 @@
 				redirectToIP = commands[1];
 				redirect = true;
 				Clients.sendToAllRegisteredUsers(&quot;BROADCAST &quot; + &quot;Server has entered redirection mode&quot;);
-				
+
 				// add server notification:
 				ServerNotification sn = new ServerNotification(&quot;Entered redirection mode&quot;);
 				sn.addLine(&quot;Admin &lt;&quot; + client.account.user + &quot;&gt; has enabled redirection mode. New address: &quot; + redirectToIP);
-				ServerNotifications.addNotification(sn);			
+				ServerNotifications.addNotification(sn);
 			}
 			else if (commands[0].equals(&quot;REDIRECTOFF&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 
 				redirect = false;
 				Clients.sendToAllRegisteredUsers(&quot;BROADCAST &quot; + &quot;Server has left redirection mode&quot;);
-				
+
 				// add server notification:
 				ServerNotification sn = new ServerNotification(&quot;Redirection mode disabled&quot;);
 				sn.addLine(&quot;Admin &lt;&quot; + client.account.user + &quot;&gt; has disabled redirection mode.&quot;);
-				ServerNotifications.addNotification(sn);			
+				ServerNotifications.addNotification(sn);
 			}
 			else if (commands[0].equals(&quot;BROADCAST&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
@@ -904,7 +904,7 @@
 			else if (commands[0].equals(&quot;FINDIP&quot;)) {
 				if (client.account.accessLevel() &lt; Account.PRIVILEGED_ACCESS) return false;
 				if (commands.length != 2) return false;
-				
+
 				boolean found = false;
 				String IP = commands[1];
 				String[] sp1 = IP.split(&quot;\\.&quot;);
@@ -912,7 +912,7 @@
 					client.sendLine(&quot;SERVERMSG Invalid IP address/range: &quot; + IP);
 					return false;
 				}
-				
+
 				for (int i = 0; i &lt; Clients.getClientsSize(); i++)
 				{
 					String[] sp2 = Clients.getClient(i).IP.split(&quot;\\.&quot;);
@@ -921,11 +921,11 @@
 					if (!sp1[1].equals(&quot;*&quot;)) if (!sp1[1].equals(sp2[1])) continue;
 					if (!sp1[2].equals(&quot;*&quot;)) if (!sp1[2].equals(sp2[2])) continue;
 					if (!sp1[3].equals(&quot;*&quot;)) if (!sp1[3].equals(sp2[3])) continue;
-					
+
 					found = true;
 					client.sendLine(&quot;SERVERMSG &quot; + IP + &quot; is bound to: &quot;+ Clients.getClient(i).account.user);
 				}
-					
+
 				// now let's check if this IP matches any recently used IP:
 				for (int i = 0; i &lt; Accounts.getAccountsSize(); i++) {
 					String[] sp2 = Accounts.getAccount(i).lastIP.split(&quot;\\.&quot;);
@@ -933,33 +933,33 @@
 					if (!sp1[0].equals(&quot;*&quot;)) if (!sp1[0].equals(sp2[0])) continue;
 					if (!sp1[1].equals(&quot;*&quot;)) if (!sp1[1].equals(sp2[1])) continue;
 					if (!sp1[2].equals(&quot;*&quot;)) if (!sp1[2].equals(sp2[2])) continue;
-					if (!sp1[3].equals(&quot;*&quot;)) if (!sp1[3].equals(sp2[3])) continue;				
+					if (!sp1[3].equals(&quot;*&quot;)) if (!sp1[3].equals(sp2[3])) continue;
 
 					if (Clients.getClient(Accounts.getAccount(i).user) == null) { // user is offline
 						found = true;
 						client.sendLine(&quot;SERVERMSG &quot; + IP + &quot; was recently bound to: &quot;+ Accounts.getAccount(i).user + &quot; (offline)&quot;);
 					}
-				}			
+				}
 
 				if (!found) client.sendLine(&quot;SERVERMSG No client is/was recently using IP: &quot; + IP); //*** perhaps add an explanation like &quot;(note that server only keeps track of last used IP addresses)&quot; ?
 			}
 			else if (commands[0].equals(&quot;GETLASTIP&quot;)) {
 				if (client.account.accessLevel() &lt; Account.PRIVILEGED_ACCESS) return false;
 				if (commands.length != 2) return false;
-				
+
 				Account acc = Accounts.getAccount(commands[1]);
 				if (acc == null) {
 					client.sendLine(&quot;SERVERMSG User &quot; + commands[1] + &quot; not found!&quot;);
 					return false;
 				}
-				
-				boolean online = Clients.isUserLoggedIn(acc); 
+
+				boolean online = Clients.isUserLoggedIn(acc);
 				client.sendLine(&quot;SERVERMSG &quot; + commands[1] + &quot;'s last IP was &quot; + acc.lastIP + &quot; (&quot; + (online ? &quot;online)&quot; : &quot;offline)&quot;));
-			}		
+			}
 			else if (commands[0].equals(&quot;GETACCOUNTINFO&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 2) return false;
-				
+
 				Account acc = Accounts.getAccount(commands[1]);
 				if (acc == null) {
 					client.sendLine(&quot;SERVERMSG Account &lt;&quot; + commands[1] + &quot;&gt; does not exist.&quot;);
@@ -973,51 +973,51 @@
 				 * to client specified as first argument. */
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length &lt; 3) return false;
-				
+
 				Client targetClient = Clients.getClient(commands[1]);
 				if (targetClient == null) return false;
-				
+
 				targetClient.sendLine(Misc.makeSentence(commands, 2));
 			}
 			else if (commands[0].equals(&quot;FORGEREVERSEMSG&quot;)) {
 				/* this command is used only for debugging purposes. It forces server to process
-				 * string passed to this command as if it were sent by the user specified 
+				 * string passed to this command as if it were sent by the user specified
 				 * in this command. */
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length &lt; 3) return false;
-				
+
 				Client targetClient = Clients.getClient(commands[1]);
 				if (targetClient == null) return false;
-				
+
 				tryToExecCommand(Misc.makeSentence(commands, 2), targetClient);
 			}
 			else if (commands[0].equals(&quot;GETIP&quot;)) {
 				if (client.account.accessLevel() &lt; Account.PRIVILEGED_ACCESS) return false;
 				if (commands.length != 2) return false;
-			
+
 				Client targetClient = Clients.getClient(commands[1]);
 				if (targetClient == null) return false;
-				
+
 				client.sendLine(&quot;SERVERMSG &quot; + targetClient.account.user + &quot;'s IP is &quot; + targetClient.IP);
 			}
 			else if (commands[0].equals(&quot;GETINGAMETIME&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (commands.length == 1) {
 					client.sendLine(&quot;SERVERMSG &quot; + &quot;Your in-game time is &quot; + client.account.getInGameTime() + &quot; minutes.&quot;);
 				} else {
 					if (client.account.accessLevel() &lt; Account.PRIVILEGED_ACCESS) {
 						client.sendLine(&quot;SERVERMSG You have no access to see other player's in-game time!&quot;);
 						return false;
-					} 
-					
+					}
+
 					if (commands.length != 2) return false;
 					Account acc = Accounts.getAccount(commands[1]);
 					if (acc == null) {
-						client.sendLine(&quot;SERVERMSG &quot; + &quot;GETINGAMETIME failed: user &quot; + commands[1] + &quot; not found!&quot;);	
+						client.sendLine(&quot;SERVERMSG &quot; + &quot;GETINGAMETIME failed: user &quot; + commands[1] + &quot; not found!&quot;);
 						return false;
 					}
-						
+
 					client.sendLine(&quot;SERVERMSG &quot; + acc.user + &quot;'s in-game time is &quot; + acc.getInGameTime() + &quot; minutes.&quot;);
 				}
 			}
@@ -1027,43 +1027,43 @@
 
 				int battleID;
 				try {
-					battleID = Integer.parseInt(commands[1]); 
+					battleID = Integer.parseInt(commands[1]);
 				} catch (NumberFormatException e) {
 					client.sendLine(&quot;SERVERMSG Invalid BattleID!&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				Battle bat = Battles.getBattleByID(battleID);
 				if (bat == null) {
 					client.sendLine(&quot;SERVERMSG Error: unknown BATTLE_ID!&quot;);
 					return false;
 				}
-				
+
 				Battles.closeBattleAndNotifyAll(bat);
-				
+
 			}
 			else if (commands[0].equals(&quot;MUTE&quot;)) {
 				if (client.account.accessLevel() &lt; Account.PRIVILEGED_ACCESS) return false;
 				if (commands.length &lt; 4) return false;
-				
+
 				Channel chan = Channels.getChannel(commands[1]);
-				if (chan == null) { 
+				if (chan == null) {
 					client.sendLine(&quot;SERVERMSG MUTE failed: Channel #&quot; + commands[1] + &quot; does not exist!&quot;);
 					return false;
 				}
-				
+
 				String username = commands[2];
 				if (chan.muteList.isMuted(username)) {
 					client.sendLine(&quot;SERVERMSG MUTE failed: User &lt;&quot; + username + &quot;&gt; is already muted. Unmute first!&quot;);
 					return false;
 				}
-				
+
 				Account targetAccount = Accounts.getAccount(username);
 				if (targetAccount == null) {
 					client.sendLine(&quot;SERVERMSG MUTE failed: User &lt;&quot; + username + &quot;&gt; does not exist&quot;);
 					return false;
 				}
-				
+
 				boolean muteByIP = false;
 				if (commands.length &gt; 4) {
 					String option = commands[4];
@@ -1073,17 +1073,17 @@
 						return false;
 					}
 				}
-				
+
 				int minutes;
 				try {
-					minutes = Integer.parseInt(commands[3]); 
+					minutes = Integer.parseInt(commands[3]);
 				} catch (NumberFormatException e) {
 					client.sendLine(&quot;SERVERMSG MUTE failed: Invalid argument - should be an integer&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				chan.muteList.mute(username, minutes*60, (muteByIP ? targetAccount.lastIP : null));
-				
+
 				client.sendLine(&quot;SERVERMSG You have muted &lt;&quot; + username + &quot;&gt; on channel #&quot; + chan.name + &quot;.&quot;);
 				chan.broadcast(&quot;&lt;&quot; + client.account.user + &quot;&gt; has muted &lt;&quot; + username + &quot;&gt;&quot;);
 			}
@@ -1092,17 +1092,17 @@
 				if (commands.length != 3) return false;
 
 				Channel chan = Channels.getChannel(commands[1]);
-				if (chan == null) { 
+				if (chan == null) {
 					client.sendLine(&quot;SERVERMSG UNMUTE failed: Channel #&quot; + commands[1] + &quot; does not exist!&quot;);
 					return false;
 				}
-				
+
 				String username = commands[2];
 				if (!chan.muteList.isMuted(username)) {
 					client.sendLine(&quot;SERVERMSG UNMUTE failed: User &lt;&quot; + username + &quot;&gt; is not on the mute list!&quot;);
 					return false;
 				}
-				
+
 				chan.muteList.unmute(username);
 				client.sendLine(&quot;SERVERMSG You have unmuted &lt;&quot; + username + &quot;&gt; on channel #&quot; + chan.name + &quot;.&quot;);
 				chan.broadcast(&quot;&lt;&quot; + client.account.user + &quot;&gt; has unmuted &lt;&quot; + username + &quot;&gt;&quot;);
@@ -1113,20 +1113,20 @@
 					client.sendLine(&quot;SERVERMSG MUTELIST failed: Invalid arguments!&quot;);
 					return false;
 				}
-				
+
 				Channel chan = Channels.getChannel(commands[1]);
-				if (chan == null) { 
+				if (chan == null) {
 					client.sendLine(&quot;SERVERMSG MUTELIST failed: Channel #&quot; + commands[1] + &quot; does not exist!&quot;);
 					return false;
 				}
 
 				client.sendLine(&quot;MUTELISTBEGIN &quot; + chan.name);
-				
+
 				int size = chan.muteList.size(); // we mustn't call muteList.size() in for loop since it will purge expired records each time and so we could have ArrayOutOfBounds exception
-				for (int i = 0; i &lt; size; i++) 
+				for (int i = 0; i &lt; size; i++)
 					if (chan.muteList.getRemainingSeconds(i) == 0) client.sendLine(&quot;MUTELIST &quot; + (String)chan.muteList.getUsername(i) + &quot;, indefinite time remaining&quot;);
 					else client.sendLine(&quot;MUTELIST &quot; + (String)chan.muteList.getUsername(i) + &quot;, &quot; + chan.muteList.getRemainingSeconds(i) + &quot; seconds remaining&quot;);
-						
+
 				client.sendLine(&quot;MUTELISTEND&quot;);
 			}
 			else if (commands[0].equals(&quot;CHANNELMESSAGE&quot;)) {
@@ -1134,18 +1134,18 @@
 				if (commands.length &lt; 3) return false;
 
 				Channel chan = Channels.getChannel(commands[1]);
-				if (chan == null) { 
+				if (chan == null) {
 					client.sendLine(&quot;SERVERMSG CHANNELMESSAGE failed: Channel #&quot; + commands[1] + &quot; does not exist!&quot;);
 					return false;
 				}
-				
+
 				chan.broadcast(Misc.makeSentence(commands, 2));
-			}		
+			}
 			else if (commands[0].equals(&quot;IP2COUNTRY&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 2) return false;
 
-				client.sendLine(&quot;SERVERMSG Country = &quot; + IP2Country.getCountryCode(Misc.IP2Long(Misc.makeSentence(commands, 1))));		
+				client.sendLine(&quot;SERVERMSG Country = &quot; + IP2Country.getCountryCode(Misc.IP2Long(Misc.makeSentence(commands, 1))));
 			}
 			else if (commands[0].equals(&quot;REINITIP2COUNTRY&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
@@ -1153,7 +1153,7 @@
 
 				if (IP2Country.initializeAll(Misc.makeSentence(commands, 1)))
 					client.sendLine(&quot;SERVERMSG IP2COUNTRY database initialized successfully!&quot;);
-				else 
+				else
 					client.sendLine(&quot;SERVERMSG Error while initializing IP2COUNTRY database!&quot;);
 			}
 			else if (commands[0].equals(&quot;UPDATEIP2COUNTRY&quot;)) {
@@ -1164,7 +1164,7 @@
 					client.sendLine(&quot;SERVERMSG IP2Country database update is already in progress, try again later.&quot;);
 					return false;
 				}
-				
+
 				client.sendLine(&quot;SERVERMSG Updating IP2country database ... Server will notify of success via server notification system.&quot;);
 				IP2Country.updateDatabase();
 			}
@@ -1190,7 +1190,7 @@
 					client.sendLine(&quot;SERVERMSG Error: Unsupported charset: &quot; + commands[1]);
 					return false;
 				}
-				
+
 				client.sendLine(&quot;SERVERMSG Charset set to &quot; + commands[1]);
 			}
 			else if (commands[0].equals(&quot;GETLOBBYVERSION&quot;)) {
@@ -1208,23 +1208,23 @@
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 1) return false;
 
-				int taken = Statistics.saveStatisticsToDisk(); 
+				int taken = Statistics.saveStatisticsToDisk();
 				if (taken == -1)
 					client.sendLine(&quot;SERVERMSG Unable to update statistics!&quot;);
-				else 
+				else
 					client.sendLine(&quot;SERVERMSG Statistics have been updated. Time taken to calculate: &quot; + taken + &quot; ms.&quot;);
 			}
 			else if (commands[0].equals(&quot;UPDATEMOTD&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 2) return false;
-				
+
 				if (!readMOTD(commands[1])) {
 					client.sendLine(&quot;SERVERMSG Error: unable to read MOTD from &quot; + commands[1]);
 					return false;
 				} else {
 					client.sendLine(&quot;SERVERMSG MOTD has been successfully updated from &quot; + commands[1]);
 				}
-			}		
+			}
 			else if (commands[0].equals(&quot;LONGTIMETODATE&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 2) return false;
@@ -1236,7 +1236,7 @@
 					client.sendLine(&quot;SERVERMSG LONGTIMETODATE failed: invalid argument.&quot;);
 					return false;
 				}
-				
+
 	     		client.sendLine(&quot;SERVERMSG LONGTIMETODATE result: &quot; + Misc.easyDateFormat(time, &quot;d MMM yyyy HH:mm:ss z&quot;));
 			}
 			else if (commands[0].equals(&quot;GETLASTLOGINTIME&quot;)) {
@@ -1248,7 +1248,7 @@
 					client.sendLine(&quot;SERVERMSG GETLASTLOGINTIME failed: &lt;&quot; + commands[1] + &quot;&gt; not found!&quot;);
 					return false;
 				}
-				
+
 				if (Clients.getClient(acc.user) == null) {
 					client.sendLine(&quot;SERVERMSG &lt;&quot; + acc.user + &quot;&gt;'s last login was on &quot; + Misc.easyDateFormat(acc.lastLogin, &quot;d MMM yyyy HH:mm:ss z&quot;));
 				} else {
@@ -1261,13 +1261,13 @@
 					client.sendLine(&quot;SERVERMSG Bad arguments (command SETCHANNELKEY)&quot;);
 					return false;
 				}
-				
+
 				Channel chan = Channels.getChannel(commands[1]);
 				if (chan == null) {
 					client.sendLine(&quot;SERVERMSG Error: Channel does not exist: &quot; + commands[1]);
 					return false;
 				}
-				
+
 				if (commands[2].equals(&quot;*&quot;)) {
 					if (chan.getKey().equals(&quot;&quot;)) {
 						client.sendLine(&quot;SERVERMSG Error: Unable to unlock channel - channel is not locked!&quot;);
@@ -1290,24 +1290,24 @@
 					client.sendLine(&quot;SERVERMSG Bad arguments (command FORCELEAVECHANNEL)&quot;);
 					return false;
 				}
-				
+
 				Channel chan = Channels.getChannel(commands[1]);
 				if (chan == null) {
 					client.sendLine(&quot;SERVERMSG Error: Channel does not exist: &quot; + commands[1]);
 					return false;
 				}
-				
+
 				Client target = Clients.getClient(commands[2]);
 				if (target == null) {
 					client.sendLine(&quot;SERVERMSG Error: &lt;&quot; + commands[2] + &quot;&gt; not found!&quot;);
 					return false;
 				}
-				
+
 				if (!chan.isClientInThisChannel(target)) {
 					client.sendLine(&quot;SERVERMSG Error: &lt;&quot; + commands[2] + &quot;&gt; is not in the channel #&quot; + chan.name + &quot;!&quot;);
 					return false;
 				}
-				
+
 				String reason = &quot;&quot;;
 				if (commands.length &gt; 3) reason = &quot; &quot; + Misc.makeSentence(commands, 3);
 				chan.broadcast(&quot;&lt;&quot; + client.account.user + &quot;&gt; has kicked &lt;&quot; + target.account.user + &quot;&gt; from the channel&quot; + (reason.equals(&quot;&quot;) ? &quot;&quot; : &quot; (reason:&quot; + reason + &quot;)&quot;));
@@ -1320,7 +1320,7 @@
 					client.sendLine(&quot;SERVERMSG Error: arguments missing (ADDNOTIFICATION command)&quot;);
 					return false;
 				}
-				
+
 				if (ServerNotifications.addNotification(new ServerNotification(&quot;Admin notification&quot;, client.account.user, Misc.makeSentence(commands, 1))))
 					client.sendLine(&quot;SERVERMSG Notification added.&quot;);
 				else
@@ -1338,7 +1338,7 @@
 					client.sendLine(&quot;SERVERMSG Error: user &lt;&quot; + commands[1] + &quot;&gt; not found online!&quot;);
 					return false;
 				}
-				
+
 				int size;
 				try {
 					size = c.sockChan.socket().getSendBufferSize();
@@ -1347,7 +1347,7 @@
 					client.sendLine(&quot;SERVERMSG Error: exception raised while trying to get send buffer size for &lt;&quot; + commands[1] + &quot;&gt;!&quot;);
 					return false;
 				}
-				
+
 				client.sendLine(&quot;SERVERMSG Send buffer size for &lt;&quot; + c.account.user + &quot;&gt; is set to &quot; + size + &quot; bytes.&quot;);
 			}
 			else if (commands[0].equals(&quot;MEMORYAVAILABLE&quot;)) {
@@ -1355,19 +1355,19 @@
 				if (commands.length != 1) {
 					return false;
 				}
-				
+
 				client.sendLine(&quot;SERVERMSG Amount of free memory in Java Virtual Machine: &quot; + Runtime.getRuntime().freeMemory() + &quot; bytes&quot;);
-			}		
+			}
 			else if (commands[0].equals(&quot;CALLGARBAGECOLLECTOR&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 1) {
 					return false;
 				}
-				
+
 				long time = System.nanoTime();
 				System.gc();
 				time = (System.nanoTime() - time) / 1000000;
-				
+
 				client.sendLine(&quot;SERVERMSG Garbage collector invoked (time taken: &quot; + time + &quot; ms)&quot;);
 			}
 			else if (commands[0].equals(&quot;TESTLOGIN&quot;)) {
@@ -1397,15 +1397,15 @@
 					client.sendLine(&quot;SERVERMSG Invalid 'mode' parameter (must be 0 or 1)!&quot;);
 					return false;
 				}
-				
+
 				Account acc = Accounts.getAccount(commands[1]);
 				if (acc == null) {
 					client.sendLine(&quot;SERVERMSG User &lt;&quot; + commands[1] + &quot;&gt; not found!&quot;);
 					return false;
 				}
-				
+
 				acc.setBotMode((mode == 0) ? false : true);
-				
+
 				client.sendLine(&quot;SERVERMSG Bot mode set to &quot;  + mode + &quot; for user &lt;&quot; + commands[1] + &quot;&gt;&quot;);
 			}
 			else if (commands[0].equals(&quot;GETREGISTRATIONDATE&quot;)) {
@@ -1419,7 +1419,7 @@
 				}
 
 				client.sendLine(&quot;SERVERMSG Registration timestamp for &lt;&quot; + commands[1] + &quot;&gt; is &quot; + acc.registrationDate + &quot; (&quot; + Misc.easyDateFormat(acc.registrationDate, &quot;d MMM yyyy HH:mm:ss z&quot;) + &quot;)&quot;);
-			}			
+			}
 			else if (commands[0].equals(&quot;SETLATESTSPRINGVERSION&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
 				if (commands.length != 2) {
@@ -1428,7 +1428,7 @@
 				}
 
 				latestSpringVersion = commands[1];
-				
+
 				client.sendLine(&quot;SERVERMSG Latest spring version has been set to &quot; + latestSpringVersion);
 			}
 			else if (commands[0].equals(&quot;RELOADUPDATEPROPERTIES&quot;)) {
@@ -1463,7 +1463,7 @@
 					return false;
 				}
 				targetClient.sendLine(&quot;ACQUIREUSERID&quot;);
-				
+
 				client.sendLine(&quot;SERVERMSG ACQUIREUSERID command was dispatched. Server will notify of response via notification system.&quot;);
 			}
 			else if (commands[0].equals(&quot;KILLALL&quot;)) {
@@ -1478,20 +1478,20 @@
 			}
 			else if (commands[0].equals(&quot;OUTPUTDBDRIVERSTATUS&quot;)) {
 				if (client.account.accessLevel() &lt; Account.ADMIN_ACCESS) return false;
-				
+
 				database.printDriverStats();
-				
+
 				client.sendLine(&quot;SERVERMSG DB driver status was printed to the console.&quot;);
-			}			
+			}
 			else if (commands[0].equals(&quot;CHANNELS&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				Channels.sendChannelListToClient(client);
 			}
 			else if (commands[0].equals(&quot;REQUESTUPDATEFILE&quot;)) {
 				//***if (client.account.accessLevel() &gt; Account.NIL_ACCESS) return false;
 				if (commands.length &lt; 2) return false;
-				
+
 				String version = Misc.makeSentence(commands, 1);
 				String response = updateProperties.getProperty(version);
 				if (response == null)
@@ -1502,7 +1502,7 @@
 
 				// send a response to the client:
 				client.sendLine(response);
-				
+
 				// kill client if no update has been found for him:
 				if (response.substring(0, 12).toUpperCase().equals(&quot;SERVERMSGBOX&quot;)) {
 					Clients.killClient(client);
@@ -1513,12 +1513,12 @@
 					client.sendLine(&quot;DENIED Already logged in&quot;);
 					return false; // user with accessLevel &gt; 0 cannot re-login
 				}
-				
+
 				if (commands.length &lt; 6) {
 					client.sendLine(&quot;DENIED Bad command arguments&quot;);
 					return false;
 				}
-				
+
 				String[] args2 = Misc.makeSentence(commands, 5).split(&quot;\t&quot;);
 				String lobbyVersion = args2[0];
 				int userID = Account.NO_USER_ID;
@@ -1527,21 +1527,21 @@
 					userID = (int)temp; // we transform unsigned 32 bit integer to a signed one
 				} catch (NumberFormatException e) {
 					client.sendLine(&quot;DENIED &lt;userID&gt; field should be an integer&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				int cpu;
 				try {
-					cpu = Integer.parseInt(commands[3]); 
+					cpu = Integer.parseInt(commands[3]);
 				} catch (NumberFormatException e) {
 					client.sendLine(&quot;DENIED &lt;cpu&gt; field should be an integer&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				if (!LAN_MODE) { // &quot;normal&quot;, non-LAN mode
 					String username = commands[1];
 					String password = commands[2];
-					
+
 					// protection from brute-forcing the account:
 					FailedLoginAttempt attempt = findFailedLoginAttempt(username);
 					if ((attempt != null) &amp;&amp; (attempt.numOfFailedAttempts &gt;= 3)) {
@@ -1557,7 +1557,7 @@
 						}
 						return false;
 					}
-					
+
 					Account acc = verifyLogin(username, password);
 					if (acc == null) {
 						client.sendLine(&quot;DENIED Bad username/password&quot;);
@@ -1586,22 +1586,25 @@
 					}
 					client.account = acc;
 				} else { // LAN_MODE == true
+					if (commands[1] == &quot;&quot;) {
+						client.sendLine(&quot;DENIED Cannot login with null username&quot;);
+					}
 					Account acc = Accounts.getAccount(commands[1]);
 					if (acc != null) {
 						client.sendLine(&quot;DENIED Player with same name already logged in&quot;);
 						return false;
 					}
-					if ((commands[1].equals(lanAdminUsername)) &amp;&amp; (commands[2].equals(lanAdminPassword))) acc = new Account(commands[1], commands[2], Account.ADMIN_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;, new MapGradeList()); 
+					if ((commands[1].equals(lanAdminUsername)) &amp;&amp; (commands[2].equals(lanAdminPassword))) acc = new Account(commands[1], commands[2], Account.ADMIN_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;, new MapGradeList());
 					else acc = new Account(commands[1], commands[2], Account.NORMAL_ACCESS, Account.NO_USER_ID, 0, &quot;?&quot;, 0, &quot;XX&quot;, new MapGradeList());
 					Accounts.addAccount(acc);
 					client.account = acc;
 				}
-				
+
 				// set client's status:
 				client.setRankToStatus(client.account.getRank());
 				client.setBotModeToStatus(client.account.getBotMode());
 				client.setAccessToStatus((((client.account.accessLevel() &gt;= Account.PRIVILEGED_ACCESS) &amp;&amp; (!LAN_MODE)) ? true : false));
-				
+
 				client.cpu = cpu;
 				client.account.lastLogin = System.currentTimeMillis();
 				client.account.lastCountry = client.country;
@@ -1610,8 +1613,8 @@
 				else client.localIP = commands[4];
 				client.lobbyVersion = lobbyVersion;
 				client.account.lastUserID = userID;
-				
-				// do the notifying and all: 
+
+				// do the notifying and all:
 				client.sendLine(&quot;ACCEPTED &quot; + client.account.user);
 				sendMOTDToClient(client);
 				Clients.sendListOfAllUsersToClient(client);
@@ -1619,11 +1622,11 @@
 				Clients.sendInfoOnStatusesToClient(client);
 				// notify client that we've finished sending login info:
 				client.sendLine(&quot;LOGININFOEND&quot;);
-				
+
 				// notify everyone about new client:
 				Clients.notifyClientsOfNewClientOnServer(client);
 				Clients.notifyClientsOfNewClientStatus(client);
-				
+
 				if (DEBUG &gt; 0) System.out.println(&quot;User just logged in: &quot; + client.account.user);
 			}
 			else if (commands[0].equals(&quot;CONFIRMAGREEMENT&quot;)) {
@@ -1632,66 +1635,66 @@
 			}
 			else if (commands[0].equals(&quot;USERID&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (commands.length != 2) {
 					client.sendLine(&quot;SERVERMSG Bad USERID command - too many or too few parameters&quot;);
 					return false;
 				}
-				
+
 				int userID = Account.NO_USER_ID;
 				try {
 					long temp = Long.parseLong(commands[1], 16);
 					userID = (int)temp; // we transform unsigned 32 bit integer to a signed one
 				} catch (NumberFormatException e) {
 					client.sendLine(&quot;SERVERMSG Bad USERID command - userID field should be an integer&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				client.account.lastUserID = userID;
-				
+
 				// add server notification:
 				ServerNotification sn = new ServerNotification(&quot;User ID received&quot;);
 				sn.addLine(&quot;&lt;&quot; + client.account.user + &quot;&gt; has generated a new user ID: &quot; + commands[1] + &quot;(&quot; + userID + &quot;)&quot;);
-				ServerNotifications.addNotification(sn);			
-			}			
+				ServerNotifications.addNotification(sn);
+			}
 			else if (commands[0].equals(&quot;RENAMEACCOUNT&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (commands.length != 2) {
 					client.sendLine(&quot;SERVERMSG Bad RENAMEACCOUNT command - too many or too few parameters&quot;);
 					return false;
 				}
-				
+
 				if (LAN_MODE) {
 					client.sendLine(&quot;SERVERMSG RENAMEACCOUNT failed: You cannot rename your account while server is running in LAN mode since you have no account!&quot;);
 					return false;
 				}
-				
+
 				// validate new username:
 				String valid = Accounts.isOldUsernameValid(commands[1]);
 				if (valid != null) {
 					client.sendLine(&quot;SERVERMSG RENAMEACCOUNT failed: Invalid username (reason: &quot; + valid + &quot;)&quot;);
 					return false;
 				}
-				
+
 				Account acc = Accounts.findAccountNoCase(commands[1]);
 				if (acc != null) {
 					client.sendLine(&quot;SERVERMSG RENAMEACCOUNT failed: Account with same username already exists!&quot;);
 					return false;
-				}			
+				}
 
 				// make sure all mutes are accordingly adjusted to new username:
 				for (int i = 0; i &lt; Channels.getChannelsSize(); i++) {
 					Channels.getChannel(i).muteList.rename(client.account.user, commands[1]);
 				}
-				
+
 				acc = new Account(commands[1], client.account.pass, client.account.access, client.account.lastUserID, System.currentTimeMillis(), client.IP, client.account.registrationDate, client.account.lastCountry, client.account.mapGrades);
 				client.sendLine(&quot;SERVERMSG Your account has been renamed to &lt;&quot; + commands[1] + &quot;&gt;. Reconnect with new account (you will now be automatically disconnected)!&quot;);
 				Clients.killClient(client, &quot;Quit: renaming account&quot;);
 				Accounts.replaceAccount(client.account, acc);
 				Accounts.saveAccounts(false); // let's save new accounts info to disk
 				Clients.sendToAllAdministrators(&quot;SERVERMSG [broadcast to all admins]: User &lt;&quot; + client.account.user + &quot;&gt; has just renamed his account to &lt;&quot; + commands[1] + &quot;&gt;&quot;);
-				
+
 				// add server notification:
 				ServerNotification sn = new ServerNotification(&quot;Account renamed&quot;);
 				sn.addLine(&quot;User &lt;&quot; + client.account.user + &quot;&gt; has renamed his account to &lt;&quot; + commands[1] + &quot;&gt;&quot;);
@@ -1699,29 +1702,29 @@
 			}
 			else if (commands[0].equals(&quot;CHANGEPASSWORD&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (commands.length != 3) {
 					client.sendLine(&quot;SERVERMSG Bad CHANGEPASSWORD command - too many or too few parameters&quot;);
 					return false;
 				}
-				
+
 				if (LAN_MODE) {
 					client.sendLine(&quot;SERVERMSG CHANGEPASSWORD failed: You cannot change your password while server is running in LAN mode!&quot;);
 					return false;
 				}
-				
+
 				if (!(commands[1].equals(client.account.pass))) {
 					client.sendLine(&quot;SERVERMSG CHANGEPASSWORD failed: Old password is incorrect!&quot;);
 					return false;
 				}
-				
+
 				// validate password:
 				String valid = Accounts.isPasswordValid(commands[2]);
 				if (valid != null) {
 					client.sendLine(&quot;SERVERMSG CHANGEPASSWORD failed: Invalid password (reason: &quot; + valid + &quot;)&quot;);
 					return false;
 				}
-				
+
 				client.account.pass = commands[2];
 
 				Accounts.saveAccounts(false); // let's save new accounts info to disk
@@ -1759,27 +1762,27 @@
 			else if (commands[0].equals(&quot;LEAVE&quot;)) {
 				if (commands.length &lt; 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				Channel chan = Channels.getChannel(commands[1]);
 				if (chan == null) return false;
-				
+
 				client.leaveChannel(chan, &quot;&quot;);
 			}
 			else if (commands[0].equals(&quot;CHANNELTOPIC&quot;)) {
 				if (commands.length &lt; 3) return false;
 				if (client.account.accessLevel() &lt; Account.PRIVILEGED_ACCESS) return false;
-				
+
 				Channel chan = Channels.getChannel(commands[1]);
 				if (chan == null) {
 					client.sendLine(&quot;SERVERMSG Error: Channel does not exist: &quot; + commands[1]);
 					return false;
 				}
-				
+
 				if (!chan.setTopic(Misc.makeSentence(commands, 2), client.account.user)) {
 					client.sendLine(&quot;SERVERMSG You've just disabled the topic for channel #&quot; + chan.name);
 					chan.broadcast(&quot;&lt;&quot; + client.account.user + &quot;&gt; has just disabled topic for #&quot; + chan.name);
 				} else {
-					client.sendLine(&quot;SERVERMSG You've just changed the topic for channel #&quot; + chan.name);				
+					client.sendLine(&quot;SERVERMSG You've just changed the topic for channel #&quot; + chan.name);
 					chan.broadcast(&quot;&lt;&quot; + client.account.user + &quot;&gt; has just changed topic for #&quot; + chan.name);
 					chan.sendLineToClients(&quot;CHANNELTOPIC &quot; + chan.name + &quot; &quot; + chan.getTopicAuthor() + &quot; &quot; + chan.getTopicChangedTime() + &quot; &quot; + chan.getTopic());
 				}
@@ -1787,10 +1790,10 @@
 			else if (commands[0].equals(&quot;SAY&quot;)) {
 				if (commands.length &lt; 3) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				Channel chan = client.getChannel(commands[1]);
 				if (chan == null) return false;
-				
+
 				if (chan.muteList.isMuted(client.account.user)) {
 					client.sendLine(&quot;SERVERMSG Message dropped. You are not allowed to talk in #&quot; + chan.name + &quot;! Please contact one of the moderators.&quot;);
 					return false;
@@ -1798,10 +1801,10 @@
 					client.sendLine(&quot;SERVERMSG Message dropped. You are not allowed to talk in #&quot; + chan.name + &quot; (muted by IP address)! If you believe this is an error, contact one of the moderators.&quot;);
 					return false;
 				}
-				
-				
+
+
 				String s = Misc.makeSentence(commands, 2);
-				// check for flooding:			
+				// check for flooding:
 				if ((s.length() &gt; maxChatMessageLength) &amp;&amp; (client.account.accessLevel() &lt; Account.ADMIN_ACCESS)) {
 					System.out.println(&quot;WARNING: Flooding detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;) [exceeded max. chat message size]&quot;);
 					client.sendLine(&quot;SERVERMSG Flooding detected - you have exceeded maximum allowed chat message size (&quot; + maxChatMessageLength + &quot; bytes). Your message has been ignored.&quot;);
@@ -1813,7 +1816,7 @@
 			else if (commands[0].equals(&quot;SAYEX&quot;)) {
 				if (commands.length &lt; 3) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				Channel chan = client.getChannel(commands[1]);
 				if (chan == null) return false;
 
@@ -1824,25 +1827,25 @@
 					client.sendLine(&quot;SERVERMSG Message dropped. You are not allowed to talk in #&quot; + chan.name + &quot; (muted by IP address)! If you believe this is an error, contact one of the moderators.&quot;);
 					return false;
 				}
-				
+
 				String s = Misc.makeSentence(commands, 2);
-				// check for flooding:			
+				// check for flooding:
 				if ((s.length() &gt; maxChatMessageLength) &amp;&amp; (client.account.accessLevel() &lt; Account.ADMIN_ACCESS)) {
 					System.out.println(&quot;WARNING: Flooding detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;) [exceeded max. chat message size]&quot;);
 					client.sendLine(&quot;SERVERMSG Flooding detected - you have exceeded maximum allowed chat message size (&quot; + maxChatMessageLength + &quot; bytes). Your message has been ignored.&quot;);
 					Clients.sendToAllAdministrators(&quot;SERVERMSG [broadcast to all admins]: Flooding has been detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;) - exceeded maximum chat message size. Ignoring ...&quot;);
 					return false;
 				}
-				
+
 				chan.sendLineToClients(&quot;SAIDEX &quot; + chan.name + &quot; &quot; + client.account.user + &quot; &quot; + s);
 			}
 			else if (commands[0].equals(&quot;SAYPRIVATE&quot;)) {
 				if (commands.length &lt; 3) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				Client target = Clients.getClient(commands[1]);
 				if (target == null) return false;
-				
+
 				String s = Misc.makeSentence(commands, 2);
 				// check for flooding:
 				if ((s.length() &gt; maxChatMessageLength) &amp;&amp; (client.account.accessLevel() &lt; Account.ADMIN_ACCESS)) {
@@ -1858,45 +1861,45 @@
 			else if (commands[0].equals(&quot;JOINBATTLE&quot;)) {
 				if (commands.length &lt; 2) return false; // requires 1 or 2 arguments (password is optional)
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				int battleID;
-				
+
 				try {
-					battleID = Integer.parseInt(commands[1]); 
+					battleID = Integer.parseInt(commands[1]);
 				} catch (NumberFormatException e) {
 					client.sendLine(&quot;JOINBATTLEFAILED &quot; + &quot;No battle ID!&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				if (client.battleID != -1) { // can't join a battle if already participating in another battle
 					client.sendLine(&quot;JOINBATTLEFAILED &quot; + &quot;Cannot participate in multiple battles at the same time!&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				Battle bat = Battles.getBattleByID(battleID);
-				
-				if (bat == null) { 
+
+				if (bat == null) {
 					client.sendLine(&quot;JOINBATTLEFAILED &quot; + &quot;Invalid battle ID!&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				if (bat.restricted()) {
 					if (commands.length &lt; 3) {
 						client.sendLine(&quot;JOINBATTLEFAILED &quot; + &quot;Password required&quot;);
-						return false; 
+						return false;
 					}
-					
+
 					if (!bat.password.equals(commands[2])) {
 						client.sendLine(&quot;JOINBATTLEFAILED &quot; + &quot;Invalid password&quot;);
-						return false; 
+						return false;
 					}
 				}
-				
+
 				if (bat.locked) {
 					client.sendLine(&quot;JOINBATTLEFAILED &quot; + &quot;You cannot join locked battles!&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				// do the actually joining and notifying:
 				client.battleStatus = 0; // reset client's battle status
 				client.battleID = battleID;
@@ -1910,12 +1913,12 @@
 					// make sure that clients behind NAT get local IPs and not external ones:
 					bat.founder.sendLine(&quot;CLIENTIPPORT &quot; + client.account.user + &quot; &quot; + (bat.founder.IP.equals(client.IP) ? client.localIP : client.IP) + &quot; &quot; + client.UDPSourcePort);
 				}
-				
+
 				client.sendLine(&quot;REQUESTBATTLESTATUS&quot;);
 				bat.sendDisabledUnitsListToClient(client);
 				bat.sendStartRectsListToClient(client);
 				bat.sendScriptTagsToClient(client);
-				
+
 				if (bat.type == 1) bat.sendScriptToClient(client);
 
 			}
@@ -1953,36 +1956,36 @@
 					local = client.IP.equals(Clients.getClient(i).IP);
 					Clients.getClient(i).sendLine(bat.createBattleOpenedCommandEx(local));
 				}
-				
+
 				client.sendLine(&quot;OPENBATTLE &quot; + bat.ID); // notify client that he successfully opened a new battle
 				client.sendLine(&quot;REQUESTBATTLESTATUS&quot;);
-			}		
+			}
 			else if (commands[0].equals(&quot;MYBATTLESTATUS&quot;)) {
 				if (commands.length != 3) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
-				
+
 				int newTeamColor;
 				try {
 					newTeamColor = Integer.parseInt(commands[2]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
 				client.teamColor = newTeamColor;
-				
+
 				int newStatus;
 				try {
 					newStatus = Integer.parseInt(commands[1]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
 				// update new battle status. Note: we ignore handicap value as it can be changed only by founder with HANDICAP command!
 				client.battleStatus = Misc.setHandicapOfBattleStatus(newStatus, Misc.getHandicapFromBattleStatus(client.battleStatus));
-				
+
 				// if game is full or game type is &quot;battle replay&quot;, force player's mode to spectator:
 				if ((bat.getClientsSize()+1-bat.spectatorCount() &gt; bat.maxPlayers) || (bat.type == 1)) {
 					client.battleStatus = Misc.setModeOfBattleStatus(client.battleStatus, 0);
@@ -1993,7 +1996,7 @@
 					if ((Misc.getTeamNoFromBattleStatus(bat.founder.battleStatus) == Misc.getTeamNoFromBattleStatus(client.battleStatus)) &amp;&amp; (Misc.getModeFromBattleStatus(bat.founder.battleStatus) != 0)) {
 						client.battleStatus = Misc.setAllyNoOfBattleStatus(client.battleStatus, Misc.getAllyNoFromBattleStatus(bat.founder.battleStatus));
 						client.teamColor = bat.founder.teamColor;
-					} 
+					}
 				for (int i = 0; i &lt; bat.getClientsSize(); i++)
 					if (bat.getClient(i) != client)
 						if ((Misc.getTeamNoFromBattleStatus(bat.getClient(i).battleStatus) == Misc.getTeamNoFromBattleStatus(client.battleStatus)) &amp;&amp; (Misc.getModeFromBattleStatus(bat.getClient(i).battleStatus) != 0)) {
@@ -2007,18 +2010,18 @@
 						client.teamColor = bat.getBot(i).teamColor;
 						break;
 					}
-						
+
 				bat.notifyClientsOfBattleStatus(client);
 			}
 			else if (commands[0].equals(&quot;MYSTATUS&quot;)) {
 				if (commands.length != 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				int newStatus;
 				try {
 					newStatus = Integer.parseInt(commands[1]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
 
 				// we must preserve rank bits, access bit and bot mode bit (client is not allowed to change them himself):
@@ -2026,13 +2029,13 @@
 				boolean tmp2 = client.getInGameFromStatus();
 				boolean tmp3 = client.getAccessFromStatus();
 				boolean tmp4 = client.getBotModeFromStatus();
-				
+
 				client.status = newStatus;
-				
+
 				client.setRankToStatus(tmp);
 				client.setAccessToStatus(tmp3);
 				client.setBotModeToStatus(tmp4);
-				
+
 				if (client.getInGameFromStatus() != tmp2) {
 					// user changed his in-game status.
 					if (tmp2 == false) { // client just entered game
@@ -2047,7 +2050,7 @@
 						}
 						if (bat != null) client.mapHashUponEnteringGame = Misc.intToHex(bat.mapHash);
 					} else { // back from game
-						if (client.inGameTime != 0) { // we won't update clients who play by themselves (or with bots only), since some try to exploit the system by leaving computer alone in-battle for hours to increase their ranks 
+						if (client.inGameTime != 0) { // we won't update clients who play by themselves (or with bots only), since some try to exploit the system by leaving computer alone in-battle for hours to increase their ranks
 							int diff = new Long((System.currentTimeMillis() - client.inGameTime) / 60000).intValue(); // in minutes
 							if (client.account.addMinsToInGameTime(diff)) {
 								client.setRankToStatus(client.account.getRank());
@@ -2063,50 +2066,50 @@
 			else if (commands[0].equals(&quot;SAYBATTLE&quot;)) {
 				if (commands.length &lt; 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
-				
-				String s = Misc.makeSentence(commands, 1); 
-				// check for flooding:			
+
+				String s = Misc.makeSentence(commands, 1);
+				// check for flooding:
 				if ((s.length() &gt; maxChatMessageLength) &amp;&amp; (client.account.accessLevel() &lt; Account.ADMIN_ACCESS)) {
 					System.out.println(&quot;WARNING: Flooding detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;) [exceeded max. chat message size]&quot;);
 					client.sendLine(&quot;SERVERMSG Flooding detected - you have exceeded maximum allowed chat message size (&quot; + maxChatMessageLength + &quot; bytes). Your message has been ignored.&quot;);
 					Clients.sendToAllAdministrators(&quot;SERVERMSG [broadcast to all admins]: Flooding has been detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;) - exceeded maximum chat message size. Ignoring ...&quot;);
 					return false;
-				}				
-				
+				}
+
 				bat.sendToAllClients(&quot;SAIDBATTLE &quot; + client.account.user + &quot; &quot; + s);
 			}
 			else if (commands[0].equals(&quot;SAYBATTLEEX&quot;)) {
 				if (commands.length &lt; 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 
 				String s = Misc.makeSentence(commands, 1);
-				// check for flooding:			
+				// check for flooding:
 				if ((s.length() &gt; maxChatMessageLength) &amp;&amp; (client.account.accessLevel() &lt; Account.ADMIN_ACCESS)) {
 					System.out.println(&quot;WARNING: Flooding detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;) [exceeded max. chat message size]&quot;);
 					client.sendLine(&quot;SERVERMSG Flooding detected - you have exceeded maximum allowed chat message size (&quot; + maxChatMessageLength + &quot; bytes). Your message has been ignored.&quot;);
 					Clients.sendToAllAdministrators(&quot;SERVERMSG [broadcast to all admins]: Flooding has been detected from &quot; + client.IP + &quot; (&quot; + client.account.user + &quot;) - exceeded maximum chat message size. Ignoring ...&quot;);
 					return false;
-				}				
-				
+				}
+
 				bat.sendToAllClients(&quot;SAIDBATTLEEX &quot; + client.account.user + &quot; &quot; + s);
 			}
 			else if (commands[0].equals(&quot;UPDATEBATTLEINFO&quot;)) {
 				if (commands.length &lt; 5) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 				if (bat.founder != client) return false; // only founder may change battle parameters!
-				
+
 				int spectatorCount = 0;
 				boolean locked;
 				int maphash;
@@ -2115,9 +2118,9 @@
 					locked = Misc.strToBool(commands[2]);
 					maphash = Integer.decode(commands[3]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
-				
+
 				bat.mapName = Misc.makeSentence(commands, 4);
 				bat.locked = locked;
 				bat.mapHash = maphash;
@@ -2126,40 +2129,40 @@
 			else if (commands[0].equals(&quot;HANDICAP&quot;)) {
 				if (commands.length != 3) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 				if (bat.founder != client) return false; // only founder can change handicap value of another user
-				
+
 				int value;
 				try {
 					value = Integer.parseInt(commands[2]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
 				if ((value &lt; 0) || (value &gt; 100)) return false;
 
 				Client target = Clients.getClient(commands[1]);
 				if (target == null) return false;
 				if (!bat.isClientInBattle(target)) return false;
-				
-				target.battleStatus = Misc.setHandicapOfBattleStatus(target.battleStatus, value); 
+
+				target.battleStatus = Misc.setHandicapOfBattleStatus(target.battleStatus, value);
 				bat.notifyClientsOfBattleStatus(target);
 			}
 			else if (commands[0].equals(&quot;KICKFROMBATTLE&quot;)) {
 				if (commands.length != 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 				if (bat.founder != client) return false; // only founder can kick other clients
-				
+
 				Client target = Clients.getClient(commands[1]);
 				if (target == null) return false;
 				if (!bat.isClientInBattle(target)) return false;
-				
+
 				bat.sendToAllClients(&quot;SAIDBATTLEEX &quot; + client.account.user + &quot; kicked &quot; + target.account.user + &quot; from battle&quot;);
 				// notify client that he was kicked from the battle:
 				target.sendLine(&quot;FORCEQUITBATTLE&quot;);
@@ -2169,123 +2172,123 @@
 			else if (commands[0].equals(&quot;FORCETEAMNO&quot;)) {
 				if (commands.length != 3) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 				if (bat.founder != client) return false; // only founder can force team/ally numbers
-				
+
 				int value;
 				try {
 					value = Integer.parseInt(commands[2]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
 				if ((value &lt; 0) || (value &gt; TASServer.MAX_TEAMS-1)) return false;
-				
+
 				Client target = Clients.getClient(commands[1]);
 				if (target == null) return false;
 				if (!bat.isClientInBattle(target)) return false;
-				
+
 				target.battleStatus = Misc.setTeamNoOfBattleStatus(target.battleStatus, value);
-				bat.notifyClientsOfBattleStatus(target); 
+				bat.notifyClientsOfBattleStatus(target);
 			}
 			else if (commands[0].equals(&quot;FORCEALLYNO&quot;)) {
 				if (commands.length != 3) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 				if (bat.founder != client) return false; // only founder can force team/ally numbers
-				
+
 				int value;
 				try {
 					value = Integer.parseInt(commands[2]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
 				if ((value &lt; 0) || (value &gt; TASServer.MAX_TEAMS-1)) return false;
-				
+
 				Client target = Clients.getClient(commands[1]);
 				if (target == null) return false;
 				if (!bat.isClientInBattle(target)) return false;
-				
+
 				target.battleStatus = Misc.setAllyNoOfBattleStatus(target.battleStatus, value);
-				bat.notifyClientsOfBattleStatus(target); 
-			}		
+				bat.notifyClientsOfBattleStatus(target);
+			}
 			else if (commands[0].equals(&quot;FORCETEAMCOLOR&quot;)) {
 				if (commands.length != 3) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 				if (bat.founder != client) return false; // only founder can force team color change
-				
+
 				int value;
 				try {
 					value = Integer.parseInt(commands[2]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
-				
+
 				Client target = Clients.getClient(commands[1]);
 				if (target == null) return false;
 				if (!bat.isClientInBattle(target)) return false;
-				
+
 				target.teamColor = value;
-				bat.notifyClientsOfBattleStatus(target); 
-			}	
+				bat.notifyClientsOfBattleStatus(target);
+			}
 			else if (commands[0].equals(&quot;FORCESPECTATORMODE&quot;)) {
 				if (commands.length != 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 				if (bat.founder != client) return false; // only founder can force spectator mode
-				
+
 				Client target = Clients.getClient(commands[1]);
 				if (target == null) return false;
 				if (!bat.isClientInBattle(target)) return false;
-				
+
 				if (Misc.getModeFromBattleStatus(target.battleStatus) == 0) return false; // no need to change it, it's already set to spectator mode!
-				
+
 				target.battleStatus = Misc.setModeOfBattleStatus(target.battleStatus, 0);
-				bat.notifyClientsOfBattleStatus(target); 
-			}		
+				bat.notifyClientsOfBattleStatus(target);
+			}
 			else if (commands[0].equals(&quot;ADDBOT&quot;)) {
 				if (commands.length &lt; 5) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 					closeServerAndExit();
 				}
-				
+
 				int value;
 				try {
-					value = Integer.parseInt(commands[2]); 
+					value = Integer.parseInt(commands[2]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
-				
+
 				int teamColor;
 				try {
-					teamColor = Integer.parseInt(commands[3]); 
+					teamColor = Integer.parseInt(commands[3]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
 
 				if (!commands[1].matches(&quot;^[A-Za-z0-9_]+$&quot;)) {
 					client.sendLine(&quot;SERVERMSGBOX Bad bot name. Try another!&quot;);
 					return false;
 				}
-				
+
 				if (bat.getBot(commands[1]) != null) {
 					client.sendLine(&quot;SERVERMSGBOX Bot name already assigned. Choose another!&quot;);
 					return false;
@@ -2293,72 +2296,72 @@
 
 				Bot bot = new Bot(commands[1], client.account.user, Misc.makeSentence(commands, 4), value, teamColor);
 				bat.addBot(bot);
-				
+
 				bat.sendToAllClients(&quot;ADDBOT &quot; + bat.ID + &quot; &quot; + bot.name + &quot; &quot; + client.account.user + &quot; &quot; + bot.battleStatus + &quot; &quot; + bot.teamColor + &quot; &quot; + bot.AIDll);
-				
+
 			}
 			else if (commands[0].equals(&quot;REMOVEBOT&quot;)) {
 				if (commands.length != 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 					closeServerAndExit();
 				}
-				
+
 				Bot bot = bat.getBot(commands[1]);
 				if (bot == null) return false;
-				
+
 				bat.removeBot(bot);
-				
+
 				bat.sendToAllClients(&quot;REMOVEBOT &quot; + bat.ID + &quot; &quot; + bot.name);
 			}
 			else if (commands[0].equals(&quot;UPDATEBOT&quot;)) {
 				if (commands.length != 4) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 					closeServerAndExit();
 				}
-				
+
 				Bot bot = bat.getBot(commands[1]);
 				if (bot == null) return false;
 
 				int value;
 				try {
-					value = Integer.parseInt(commands[2]); 
+					value = Integer.parseInt(commands[2]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
 
 				int teamColor;
 				try {
-					teamColor = Integer.parseInt(commands[3]); 
+					teamColor = Integer.parseInt(commands[3]);
 				} catch (NumberFormatException e) {
-					return false; 
+					return false;
 				}
-				
-				// only bot owner and battle host are allowed to update bot: 
-				if (!((client.account.user.equals(bot.ownerName)) || (client.account.user.equals(bat.founder.account.user)))) return false; 
-						
+
+				// only bot owner and battle host are allowed to update bot:
+				if (!((client.account.user.equals(bot.ownerName)) || (client.account.user.equals(bat.founder.account.user)))) return false;
+
 				bot.battleStatus = value;
 				bot.teamColor = teamColor;
 
-				//*** add: force ally and color number if someone else is using his team number already 
-				
+				//*** add: force ally and color number if someone else is using his team number already
+
 				bat.sendToAllClients(&quot;UPDATEBOT &quot; + bat.ID + &quot; &quot; + bot.name + &quot; &quot; + bot.battleStatus + &quot; &quot; + bot.teamColor);
 			}
 			else if (commands[0].equals(&quot;DISABLEUNITS&quot;)) {
 				if (commands.length &lt; 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
@@ -2370,13 +2373,13 @@
 					if (bat.disabledUnits.indexOf(commands[i]) != -1) continue;
 					bat.disabledUnits.add(commands[i]);
 				}
-				
+
 				bat.sendToAllExceptFounder(command);
-			}		
+			}
 			else if (commands[0].equals(&quot;ENABLEUNITS&quot;)) {
 				if (commands.length &lt; 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
@@ -2385,22 +2388,22 @@
 				for (int i = 1; i &lt; commands.length; i++) {
 					bat.disabledUnits.remove(commands[i]); // will ignore it if string is not found in the list
 				}
-				
+
 				bat.sendToAllExceptFounder(command);
-			}		
+			}
 			else if (commands[0].equals(&quot;ENABLEALLUNITS&quot;)) {
 				if (commands.length != 1) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) return false;
 				if (bat.founder != client) return false; // only founder can disable/enable units
 
 				bat.disabledUnits.clear();
-				
+
 				bat.sendToAllExceptFounder(command);
-			}		
+			}
 			else if (commands[0].equals(&quot;RING&quot;)) {
 				if (commands.length != 2) return false;
 				// privileged users can ring anyone, &quot;normal&quot; users can ring only when they are hosting
@@ -2412,46 +2415,46 @@
 
 					if (client.battleID == -1) {
 						client.sendLine(&quot;SERVERMSG RING command failed: You can only ring players participating in your own battle!&quot;);
-						return false; 
+						return false;
 					}
-					
+
 					Battle bat = Battles.getBattleByID(client.battleID);
 					if (bat == null) {
 						System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 						closeServerAndExit();
 					}
-					
+
 					if (!bat.isClientInBattle(commands[1])) {
 						client.sendLine(&quot;SERVERMSG RING command failed: You don't have permission to ring players other than those participating in your battle!&quot;);
 						return false;
 					}
-					
+
 					// only host can ring players participating in his own battle, unless target is host himself:
 					if ((client != bat.founder) &amp;&amp; (target != bat.founder)) {
 						client.sendLine(&quot;SERVERMSG RING command failed: You can ring only battle host, or if you are the battle host, only players participating in your own battle!&quot;);
 						return false;
 					}
-													
+
 					target.sendLine(&quot;RING &quot; + client.account.user);
 				} else { // privileged user
 					Client target = Clients.getClient(commands[1]);
 					if (target == null) return false;
-					
+
 					target.sendLine(&quot;RING &quot; + client.account.user);
 				}
 			}
 			else if (commands[0].equals(&quot;ADDSTARTRECT&quot;)) {
 				if (commands.length != 6) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 					closeServerAndExit();
 				}
-				
+
 				if (bat.founder != client) return false;
 
 				int allyno, left, top, right, bottom;
@@ -2464,35 +2467,35 @@
 				} catch (NumberFormatException e) {
 					client.sendLine(&quot;SERVERMSG Serious error: inconsistent data (&quot; + commands[0] + &quot; command). You will now be disconnected ...&quot;);
 					Clients.killClient(client, &quot;Quit: inconsistent data&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				if (bat.startRects[allyno].enabled) {
 					client.sendLine(&quot;SERVERMSG Serious error: inconsistent data (&quot; + commands[0] + &quot; command). You will now be disconnected ...&quot;);
 					Clients.killClient(client, &quot;Quit: inconsistent data&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				bat.startRects[allyno].enabled = true;
 				bat.startRects[allyno].left = left;
 				bat.startRects[allyno].top = top;
 				bat.startRects[allyno].right = right;
 				bat.startRects[allyno].bottom = bottom;
-				
+
 				bat.sendToAllExceptFounder(&quot;ADDSTARTRECT &quot; + allyno + &quot; &quot; + left + &quot; &quot; + top + &quot; &quot; + right + &quot; &quot; + bottom);
-			}		
+			}
 			else if (commands[0].equals(&quot;REMOVESTARTRECT&quot;)) {
 				if (commands.length != 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 					closeServerAndExit();
 				}
-				
+
 				if (bat.founder != client) return false;
 
 				int allyno;
@@ -2501,67 +2504,67 @@
 				} catch (NumberFormatException e) {
 					client.sendLine(&quot;SERVERMSG Serious error: inconsistent data (&quot; + commands[0] + &quot; command). You will now be disconnected ...&quot;);
 					Clients.killClient(client, &quot;Quit: inconsistent data&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				if (!bat.startRects[allyno].enabled) {
 					client.sendLine(&quot;SERVERMSG Serious error: inconsistent data (&quot; + commands[0] + &quot; command). You will now be disconnected ...&quot;);
 					Clients.killClient(client, &quot;Quit: inconsistent data&quot;);
-					return false; 
+					return false;
 				}
-				
+
 				bat.startRects[allyno].enabled = false;
-			
+
 				bat.sendToAllExceptFounder(&quot;REMOVESTARTRECT &quot; + allyno);
-			}		
+			}
 			else if (commands[0].equals(&quot;SCRIPTSTART&quot;)) {
 				if (commands.length != 1) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 					closeServerAndExit();
 				}
-				
+
 				bat.tempReplayScript.clear();
-			}				
+			}
 			else if (commands[0].equals(&quot;SCRIPT&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 					closeServerAndExit();
 				}
-				
+
 				bat.tempReplayScript.add(Misc.makeSentence(commands, 1));
-			}				
+			}
 			else if (commands[0].equals(&quot;SCRIPTEND&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
 					closeServerAndExit();
 				}
-				
+
 				// copy temp script to active script:
 				bat.ratifyTempScript();
-				
+
 				bat.sendScriptToAllExceptFounder();
-			} 				
+			}
 			else if (commands[0].equals(&quot;SETSCRIPTTAGS&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
@@ -2583,7 +2586,7 @@
 				}
 				String[] pairs = command.substring(pairsStart + 1).split(&quot;\t&quot;);
 				String validPairs = &quot;&quot;;
-				
+
 				for (int i = 0; i &lt; pairs.length; i++) {
 
 					String s = pairs[i];
@@ -2620,19 +2623,19 @@
 					if (validPairs.length() &gt; 0) {
 						validPairs += &quot;\t&quot;;
 					}
-					validPairs += key + &quot;=&quot; + value; 
+					validPairs += key + &quot;=&quot; + value;
 				}
 
 				// relay the valid pairs
 				if (validPairs.length() &gt; 0) {
 					bat.sendToAllClients(&quot;SETSCRIPTTAGS &quot; + validPairs);
 				}
-			}				
+			}
 			else if (commands[0].equals(&quot;REMOVESCRIPTTAGS&quot;)) {
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (client.battleID == -1) return false;
-				
+
 				Battle bat = Battles.getBattleByID(client.battleID);
 				if (bat == null) {
 					System.out.println(&quot;Serious error occured: Invalid battle ID. Server will now exit!&quot;);
@@ -2657,11 +2660,11 @@
 
 				// relay the command
 				bat.sendToAllClients(loweyKeyCommand);
-			}				
+			}
 			else if (commands[0].equals(&quot;MAPGRADES&quot;)) {
 				if (commands.length &lt; 2) return false;
 				if (client.account.accessLevel() &lt; Account.NORMAL_ACCESS) return false;
-				
+
 				if (LAN_MODE) {
 					client.sendLine(&quot;MAPGRADESFAILED Unable to synchronize map grades - server is running in LAN mode!&quot;);
 					return false;
@@ -2672,12 +2675,12 @@
 					client.sendLine(&quot;MAPGRADESFAILED Invalid params to MAPGRADES command!&quot;);
 					return false;
 				}
-				
+
 				if (System.currentTimeMillis() - client.lastMapGradesReceived &lt; minSleepTimeBetweenMapGrades * 1000) {
 					client.sendLine(&quot;MAPGRADESFAILED Less than &quot; + minSleepTimeBetweenMapGrades + &quot; seconds have passed since your last synchronization, try again later!&quot;);
 					return false;
 				}
-				
+
 				String respond = &quot;MAPGRADES&quot;; // message that we will send back to the client
 				try {
 					for (int i = 0; i &lt; tokens.length / 2; i++) {
@@ -2691,14 +2694,14 @@
 						}
 						if ((grade &lt; 0) || (grade &gt; 10)) return false;
 						MapGrading.updateLocalAndGlobalGrade(client, hash, grade);
-						respond += &quot; &quot; + hash + &quot; &quot; + MapGrading.getAvarageMapGrade(hash) + &quot; &quot; + MapGrading.getNumberOfMapVotes(hash); 
+						respond += &quot; &quot; + hash + &quot; &quot; + MapGrading.getAvarageMapGrade(hash) + &quot; &quot; + MapGrading.getNumberOfMapVotes(hash);
 					}
 					client.sendLine(respond);
 					client.lastMapGradesReceived = System.currentTimeMillis();
 				} catch (Exception e) {
 					return false;
 				}
-			} 	
+			}
 			else {
 				// unknown command!
 				return false;
@@ -2706,12 +2709,12 @@
 		} finally {
 			client.setSendMsgID(NO_MSG_ID);
 		}
-		
-		
+
+
 		return true;
-		
+
 	} // tryToExecCommand()
-	
+
 	/* processes all arguments from string 'args'. Raises an exception in case of errors. */
 	public static void processCommandLineArguments(String[] args) throws IOException, Exception {
 		// process command line arguments:
@@ -2726,10 +2729,10 @@
 					i++; // we must skip port number parameter in the next iteration
 				}
 				else if (s.equals(&quot;LAN&quot;)) {
-					LAN_MODE = true;						
+					LAN_MODE = true;
 				}
 				else if (s.equals(&quot;DEBUG&quot;)) {
-					int level = Integer.parseInt(args[i+1]);											
+					int level = Integer.parseInt(args[i+1]);
 					if ((level &lt; 0) || (level &gt; 127)) throw new IOException();
 					DEBUG = (byte)level;
 					i++;  // we must skip debug level parameter in the next iteration
@@ -2805,7 +2808,7 @@
 			}
 		}
 	}
-	
+
 	public static void main(String[] args) {
 
 		// process command line arguments:
@@ -2858,12 +2861,12 @@
 			System.out.println(&quot;-DBPASSWORD [password]&quot;);
 			System.out.println(&quot;  Will set password for the database (used only in \&quot;normal mode\&quot;, not LAN mode).\n&quot;);
 			System.out.println(&quot;&quot;);
-						
+
 			closeServerAndExit();
 		}
 
 		System.out.println(&quot;TASServer &quot; + VERSION + &quot; started on &quot; + Misc.easyDateFormat(&quot;yyyy.MM.dd 'at' hh:mm:ss z&quot;));
-		
+
 		// switch to lan mode if user accounts information is not present:
 		if (!LAN_MODE) {
 			if (!(new File(ACCOUNTS_INFO_FILEPATH)).exists()) {
@@ -2871,7 +2874,7 @@
 				LAN_MODE = true;
 			}
 		}
-		
+
 		// establish connection with database:
 		if (!LAN_MODE) {
 			database = new DBInterface();
@@ -2884,7 +2887,7 @@
 			}
 			System.out.println(&quot;Connection to database has been established.&quot;);
 		}
-		
+
 		if (!LAN_MODE) {
 			Accounts.loadAccounts();
 			BanSystem.fetchLatestBanList();
@@ -2892,19 +2895,19 @@
 		} else {
 			System.out.println(&quot;LAN mode enabled&quot;);
 		}
-		
+
 		if (RECORD_STATISTICS) {
 			// create statistics folder if it doesn't exist yet:
 			File file = new File(STATISTICS_FOLDER);
 			if (!file.exists()) {
 				boolean success = (file.mkdir());
-				if (!success) 
+				if (!success)
 					System.out.println(&quot;Error: unable to create folder: &quot; + STATISTICS_FOLDER);
-				else 
+				else
 					System.out.println(&quot;Created missing folder: &quot; + STATISTICS_FOLDER);
 			}
 		}
-		
+
 		if (LOG_MAIN_CHANNEL) {
 			try {
 				mainChanLog = new PrintStream(new BufferedOutputStream(new FileOutputStream(&quot;MainChanLog.log&quot;, true)), true);
@@ -2915,69 +2918,69 @@
 				e.printStackTrace();
 			}
 		}
-		
+
 		// create notifications folder if it doesn't exist yet:
 		if (!LAN_MODE) {
 			File file = new File(SERVER_NOTIFICATION_FOLDER);
 			if (!file.exists()) {
 				boolean success = (file.mkdir());
-				if (!success) 
+				if (!success)
 					System.out.println(&quot;Error: unable to create folder: &quot; + SERVER_NOTIFICATION_FOLDER);
-				else 
+				else
 					System.out.println(&quot;Created missing folder: &quot; + SERVER_NOTIFICATION_FOLDER);
 			}
 		}
-		
+
 		readMOTD(MOTD_FILENAME);
 		upTime = System.currentTimeMillis();
-		
+
 		if (readUpdateProperties(UPDATE_PROPERTIES_FILENAME)) {
 			System.out.println(&quot;\&quot;Update properties\&quot; read from &quot; + UPDATE_PROPERTIES_FILENAME);
 		}
-		
+
 		long tempTime = System.currentTimeMillis();
 		if (!IP2Country.initializeAll(IP2COUNTRY_FILENAME)) {
-			System.out.println(&quot;Unable to find or read &lt;IP2Country&gt; file. Skipping ...&quot;);			
+			System.out.println(&quot;Unable to find or read &lt;IP2Country&gt; file. Skipping ...&quot;);
 		} else {
 			tempTime = System.currentTimeMillis() - tempTime;
 			System.out.println(&quot;&lt;IP2Country&gt; loaded in &quot; + tempTime + &quot; ms.&quot;);
 		}
-			
-		// construct global map grade list:	
-		MapGrading.reconstructGlobalMapGrades();	
 
+		// construct global map grade list:
+		MapGrading.reconstructGlobalMapGrades();
+
 		// start &quot;help UDP&quot; server:
 		helpUDPsrvr = new NATHelpServer(NAT_TRAVERSAL_PORT);
 		helpUDPsrvr.start();
-		
+
 		// start server:
 		if (!startServer(serverPort)) closeServerAndExit();
-		
+
 		// add server notification:
 		ServerNotification sn = new ServerNotification(&quot;Server started&quot;);
 		sn.addLine(&quot;Server has been started on port &quot; + serverPort + &quot;. There are &quot; + Accounts.getAccountsSize() + &quot; accounts currently loaded. See server log for more info.&quot;);
 		ServerNotifications.addNotification(sn);
-		
+
 		initializationFinished = true; // we're through the initialization part
-		
+
 	    running = true;
 	    while (running) { // main loop
 
 	    	// check for new client connections
 		    acceptNewConnections();
-		    
+
 		    // check for incoming messages
 		    readIncomingMessages();
-		    
+
 		    // flush any data that is waiting to be sent
 		    Clients.flushData();
-		    
+
 		    // reset received bytes count every n seconds
 		    if (System.currentTimeMillis() - lastFloodCheckedTime &gt; recvRecordPeriod * 1000) {
 		    	lastFloodCheckedTime = System.currentTimeMillis();
 		    	for (int i = 0; i &lt; Clients.getClientsSize(); i++) Clients.getClient(i).dataOverLastTimePeriod = 0;
 		    }
-		    
+
 		    // check for timeouts:
 		    if (System.currentTimeMillis() - lastTimeoutCheck &gt; TIMEOUT_LENGTH) {
 		    	lastTimeoutCheck = System.currentTimeMillis();
@@ -2986,21 +2989,21 @@
 		    		if (Clients.getClient(i).halfDead) continue; // already scheduled for kill
 		    		if (now - Clients.getClient(i).timeOfLastReceive &gt; TIMEOUT_LENGTH) {
 		    			System.out.println(&quot;Timeout detected from &quot; + Clients.getClient(i).account.user + &quot; (&quot; + Clients.getClient(i).IP + &quot;). Client has been scheduled for kill ...&quot;);
-		    			Clients.killClientDelayed(Clients.getClient(i), &quot;Quit: timeout&quot;);		
+		    			Clients.killClientDelayed(Clients.getClient(i), &quot;Quit: timeout&quot;);
 		    		}
 		    	}
 		    }
-		    
+
 		    // kill all clients scheduled to be killed:
 		    Clients.processKillList();
-		    
+
 		    // update statistics:
 		    if ((RECORD_STATISTICS) &amp;&amp; (System.currentTimeMillis() - Statistics.lastStatisticsUpdate &gt; saveStatisticsInterval))
 		    	Statistics.saveStatisticsToDisk();
-		    	
+
 		    // check UDP server for any new packets:
 		    while (NATHelpServer.msgList.size() &gt; 0) {
-		    	DatagramPacket packet = (DatagramPacket)NATHelpServer.msgList.remove(0); 
+		    	DatagramPacket packet = (DatagramPacket)NATHelpServer.msgList.remove(0);
 	            InetAddress address = packet.getAddress();
 	            int p = packet.getPort();
 	            String data = new String(packet.getData(), packet.getOffset(), packet.getLength());
@@ -3010,7 +3013,7 @@
 	            client.UDPSourcePort = p;
 	            client.sendLine(&quot;UDPSOURCEPORT &quot; + p);
 		    }
-		    
+
 		    // save accounts info to disk on regular intervals:
 		    Accounts.saveAccountsIfNeeded();
 
@@ -3021,7 +3024,7 @@
 		    		Channels.getChannel(i).muteList.clearExpiredOnes();
 		    	}
 		    }
-		    
+
 		    // purge list of failed login attempts:
 		    if (System.currentTimeMillis() - lastFailedLoginsPurgeTime &gt; 1000) {
 		    	lastFailedLoginsPurgeTime = System.currentTimeMillis();
@@ -3033,7 +3036,7 @@
 		    		}
 		    	}
 		    }
-		    
+
 		    // sleep a bit
 		    try {
 		    	Thread.sleep(MAIN_LOOP_SLEEP);
@@ -3060,12 +3063,12 @@
 		} catch (Exception e) {
 			// ignore
 		}
-	    
+
 		// add server notification:
 		sn = new ServerNotification(&quot;Server stopped&quot;);
 		sn.addLine(&quot;Server has just been stopped gracefully. See server log for more info.&quot;);
 		ServerNotifications.addNotification(sn);
-		
+
         System.out.println(&quot;Server closed gracefully!&quot;);
 	}
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002016.html">[Taspring-linux-commit] r7247 - Lobby/TASServer/Documentation
</A></li>
	<LI>Next message: <A HREF="002018.html">[Taspring-linux-commit] r7249 - Lobby/TASServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2017">[ date ]</a>
              <a href="thread.html#2017">[ thread ]</a>
              <a href="subject.html#2017">[ subject ]</a>
              <a href="author.html#2017">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
