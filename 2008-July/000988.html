<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6208 - in branches/caiinterface: AI/Global	AI/Global/NullAI AI/Global/NullAI/Event AI/Global/RAI-0.553	AI/Global/RAI-0.553/Event rts/ExternalAI rts/Sim/Misc	rts/Sim/Units/CommandAI rts/System
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6208%20-%20in%20branches/caiinterface%3A%20AI/Global%0A%09AI/Global/NullAI%20AI/Global/NullAI/Event%20AI/Global/RAI-0.553%0A%09AI/Global/RAI-0.553/Event%20rts/ExternalAI%20rts/Sim/Misc%0A%09rts/Sim/Units/CommandAI%20rts/System&In-Reply-To=%3C20080721085938.D124248A3%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000987.html">
   <LINK REL="Next"  HREF="000989.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6208 - in branches/caiinterface: AI/Global	AI/Global/NullAI AI/Global/NullAI/Event AI/Global/RAI-0.553	AI/Global/RAI-0.553/Event rts/ExternalAI rts/Sim/Misc	rts/Sim/Units/CommandAI rts/System</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6208%20-%20in%20branches/caiinterface%3A%20AI/Global%0A%09AI/Global/NullAI%20AI/Global/NullAI/Event%20AI/Global/RAI-0.553%0A%09AI/Global/RAI-0.553/Event%20rts/ExternalAI%20rts/Sim/Misc%0A%09rts/Sim/Units/CommandAI%20rts/System&In-Reply-To=%3C20080721085938.D124248A3%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6208 - in branches/caiinterface: AI/Global	AI/Global/NullAI AI/Global/NullAI/Event AI/Global/RAI-0.553	AI/Global/RAI-0.553/Event rts/ExternalAI rts/Sim/Misc	rts/Sim/Units/CommandAI rts/System">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Mon Jul 21 10:59:38 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000987.html">[Taspring-linux-commit] r6207 - branches
</A></li>
        <LI>Next message: <A HREF="000989.html">[Taspring-linux-commit] r6209 - trunk/Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#988">[ date ]</a>
              <a href="thread.html#988">[ thread ]</a>
              <a href="subject.html#988">[ subject ]</a>
              <a href="author.html#988">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-07-21 10:59:37 +0200 (Mon, 21 Jul 2008)
New Revision: 6208

Added:
   branches/caiinterface/AI/Global/NullAI/
   branches/caiinterface/AI/Global/NullAI/AI.cpp
   branches/caiinterface/AI/Global/NullAI/AI.h
   branches/caiinterface/AI/Global/NullAI/AIExport.cpp
   branches/caiinterface/AI/Global/NullAI/AIExport.h
   branches/caiinterface/AI/Global/NullAI/AISCommands.cpp
   branches/caiinterface/AI/Global/NullAI/Event/
   branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDamagedEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDestroyedEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterLOSEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterRadarEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveLOSEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveRadarEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIEvents.h
   branches/caiinterface/AI/Global/NullAI/Event/AIInitEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIMessageEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AINullEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIPlayerCommandEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AISeismicPingEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUnitCapturedEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUnitCreatedEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUnitDamagedEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUnitDestroyedEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUnitFinishedEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUnitGivenEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUnitIdleEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUnitMoveFailedEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIUpdateEvent.h
   branches/caiinterface/AI/Global/NullAI/Event/AIWeaponFiredEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/AI.cpp
   branches/caiinterface/AI/Global/RAI-0.553/AI.h
   branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.cpp
   branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.h
   branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.cpp
   branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.h
   branches/caiinterface/AI/Global/RAI-0.553/AIExport.cpp
   branches/caiinterface/AI/Global/RAI-0.553/AIExport.h
   branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.cpp
   branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.h
   branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.cpp
   branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.h
   branches/caiinterface/AI/Global/RAI-0.553/AISCommands.cpp
   branches/caiinterface/AI/Global/RAI-0.553/Event/
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDamagedEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDestroyedEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterLOSEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterRadarEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveLOSEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveRadarEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvents.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIInitEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIMessageEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AINullEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIPlayerCommandEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AISeismicPingEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCapturedEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCreatedEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDamagedEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDestroyedEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitFinishedEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitGivenEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitIdleEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitMoveFailedEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIUpdateEvent.h
   branches/caiinterface/AI/Global/RAI-0.553/Event/AIWeaponFiredEvent.h
   branches/caiinterface/rts/ExternalAI/AILibrary.cpp
   branches/caiinterface/rts/ExternalAI/AILibrary.h
   branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp
   branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h
   branches/caiinterface/rts/ExternalAI/AISCommands.cpp
   branches/caiinterface/rts/ExternalAI/AISCommands.h
   branches/caiinterface/rts/ExternalAI/AISEvents.h
   branches/caiinterface/rts/ExternalAI/SAICallback.cpp
   branches/caiinterface/rts/ExternalAI/SAICallback.h
   branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp
   branches/caiinterface/rts/ExternalAI/SAIFloat3.h
Modified:
   branches/caiinterface/AI/Global/RAI-0.553/GlobalAIs.cpp
   branches/caiinterface/rts/ExternalAI/GlobalAI.cpp
   branches/caiinterface/rts/ExternalAI/GlobalAI.h
   branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp
   branches/caiinterface/rts/Sim/Misc/DamageArray.cpp
   branches/caiinterface/rts/Sim/Misc/DamageArray.h
   branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h
   branches/caiinterface/rts/System/float3.cpp
   branches/caiinterface/rts/System/float3.h
Log:
Initial change:
* some changes to the engine: loading AIs, float3, DamageArray &amp; CommandQueue
* C AI interface, consisting mainly of: IGlobalAI wrapper and Callback wrapper (IGlobalAICallback, IAICallback &amp; IAICheats)
* C++ AI interface wrapper: uses the new C interface in the background, but &quot;looking&quot; like the old/current C++ interface.
* RAI changed to use th enew interface (minimal changes)
* Adding a NullAI, which is comparable to TestGlobalAI, but using the new C interface

Added: branches/caiinterface/AI/Global/NullAI/AI.cpp
===================================================================
--- branches/caiinterface/AI/Global/NullAI/AI.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/AI.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,104 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AI.h&quot;
+#include &quot;Event/AIEvents.h&quot;
+#include &quot;ExternalAI/AISEvents.h&quot;
+
+CAI::CAI() : team(0) { 
+	
+}
+
+
+CAI::CAI(int team) : team(team) {
+	
+}
+
+int CAI::handleEvent(int eventID, void* event) {
+	CAIEvent* e;
+	switch(eventID) {
+		case EVENT_NULL:
+			e = new CAINullEvent();
+			break;
+		case EVENT_INIT:
+			e = new CAIInitEvent((SInitEvent*) event);
+			break;
+		case EVENT_UPDATE:
+			e = new CAIUpdateEvent((SUpdateEvent*) event);
+			break;
+		case EVENT_MESSAGE:	
+			e = new CAIMessageEvent((SMessageEvent*) event);
+			break;
+		case EVENT_UNIT_CREATED:
+			e = new CAIUnitCreatedEvent((SUnitCreatedEvent*) event);
+			break;
+		case EVENT_UNIT_FINISHED:
+			e = new CAIUnitFinishedEvent((SUnitFinishedEvent*) event);
+			break;
+		case EVENT_UNIT_IDLE:
+			e = new CAIUnitIdleEvent((SUnitIdleEvent*) event);
+			break;
+		case EVENT_UNIT_MOVE_FAILED:
+			e = new CAIUnitMoveFailedEvent((SUnitMoveFailedEvent*) event);
+			break;
+		case EVENT_UNIT_DAMAGED:
+			e = new CAIUnitDamagedEvent((SUnitDamagedEvent*) event);
+			break;
+		case EVENT_UNIT_DESTROYED: 
+			e = new CAIUnitDestroyedEvent((SUnitDestroyedEvent*) event);
+			break;
+		case EVENT_UNIT_GIVEN:
+			e = new CAIUnitGivenEvent((SUnitGivenEvent*) event);
+			break;
+		case EVENT_UNIT_CAPTURED:
+			e = new CAIUnitCapturedEvent((SUnitCapturedEvent*) event);
+			break;
+		case EVENT_ENEMY_ENTER_LOS:
+			e = new CAIEnemyEnterLOSEvent((SEnemyEnterLOSEvent*) event);
+			break;
+		case EVENT_ENEMY_LEAVE_LOS:
+			e = new CAIEnemyLeaveLOSEvent((SEnemyLeaveLOSEvent*) event);
+			break;
+		case EVENT_ENEMY_ENTER_RADAR:
+			e = new CAIEnemyEnterRadarEvent((SEnemyEnterRadarEvent*) event);
+			break;
+		case EVENT_ENEMY_LEAVE_RADAR:
+			e = new CAIEnemyLeaveRadarEvent((SEnemyLeaveRadarEvent*) event);
+			break;
+		case EVENT_ENEMY_DAMAGED:
+			e = new CAIEnemyDamagedEvent((SEnemyDamagedEvent*) event);
+			break;
+		case EVENT_ENEMY_DESTROYED: 
+			e = new CAIEnemyDestroyedEvent((SEnemyDestroyedEvent*) event);
+			break;
+		case EVENT_WEAPON_FIRED: 
+			e = new CAIWeaponFiredEvent((SWeaponFiredEvent*) event);
+			break;
+		case EVENT_PLAYER_COMMAND: 
+			e = new CAIPlayerCommandEvent((SPlayerCommandEvent*) event);
+			break;
+		case EVENT_SEISMIC_PING: 
+			e = new CAISeismicPingEvent((SSeismicPingEvent*) event);
+			break;
+		default:
+			e = new CAINullEvent();
+			break;
+	}
+	e-&gt;run(this);
+	delete e;
+	return 0;
+}


Property changes on: branches/caiinterface/AI/Global/NullAI/AI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/AI.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/AI.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/AI.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,33 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AI_H
+#define AI_H
+
+#include &lt;iostream&gt;
+
+class CAI { 
+public:
+    CAI();
+    CAI(int team);
+    virtual int handleEvent(int eventID, void* event);
+
+    int team;
+};
+
+
+#endif /*AI_H*/


Property changes on: branches/caiinterface/AI/Global/NullAI/AI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/AIExport.cpp
===================================================================
--- branches/caiinterface/AI/Global/NullAI/AIExport.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/AIExport.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,100 @@
+#include &quot;AIExport.h&quot;
+#include &quot;AI.h&quot;
+#include &lt;map&gt;
+
+/*
+If we do not have an init() method, then we would instead pass
+an event InitEvent to handleEvent. However, we would have to make
+handleEvent have to wait for an InitEvent as a special case, since
+the team in question would not yet exist. 
+
+Therefore, the handleEvent code would look like this:
+[code]
+DLL_EXPORT int handleEvent(int team, int eventID, void* event) {
+    if (eventID == INIT_EVENT) {
+        ais[team] = CAIObject();
+    }
+    if (ais.count(team) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[team].handleEvent(eventID, event);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}
+[/code]
+Advantages:
+* All events to AI go through handleEvent.
+* People don't get confused and start adding bananaSplitz() functions.
+
+Disadvantages:
+* We need to check for INIT_EVENT before *every message*.
+* These events will happen only once per game -- after that the check becomes a necessary waste of time.
+* Handling events is no longer about getting the right object to deal with an event, it also includes initialising object properly.
+
+I understand that we want to keep the interface simple. In fact,
+I think we should keep it as minimal as possible, and ideally everything
+would go through handleEvent. Practically though, it does not make sense
+to do this: we'll be wasting our own time for no good reason in the
+case of initialisation. 
+
+The (in my opinion much cleaner) alternative is the one I've implemented.
+Advantages:
+* One function that initialises a team before everything is passed to handlEvent
+* No redundant if statements.
+* Simple design.
+
+Disadvantage:
+* People might start adding other functions to the interface.
+
+I don't think that the disadvantage is a real one: it's pretty standard to 
+see initialisation as a special case. It's pretty clear that everything
+else goes through handleEvent. 
+
+The advantage is clear: a more efficient, simpler design. Of course, you could
+argue that the efficiency is nominal, one extra if per event is very little cost,
+and granted, that's true; but this doesn't change the fact that we're checking
+for a special case that we know only happens once at the beginning of the game, before
+every single event after.
+
+Of course, we still need an INIT_EVENT, since initialising the existance of a team
+member is not the same as initialising its state.
+
+You might also argue that we do this check in the handleEvent switch within each
+team. This is true, although the difference there is that a switch is translated
+to address lookups and so there is no increase in cost if there are more switch
+cases. 
+*/
+
+std::map&lt;int, CAI*&gt; ais;
+
+DLL_EXPORT int version() {
+    return 1;
+}
+
+// Since this is a C interface, we can only be told by the engine
+// to set up an AI with the number team that indicates a receiver
+// of any handleEvent() call.
+DLL_EXPORT void init(int team) {
+    // the map already has an AI for this team.
+    //TODO: raise an error, since it's probably a mistake if we're trying
+    //reinitialise a team that's already had init() called on it.
+    if (ais.count(team) &gt; 0) {
+        return;
+    }
+    //TODO:
+    // Change the line below so that CAI is 
+    // your AI, which should be a subclass of CAI that
+    // overrides the handleEvent() method.
+    ais[team] = new CAI(team);
+}
+
+DLL_EXPORT int handleEvent(int team, int eventID, void* event) {
+    // events sent to team -1 will always be to the AI object itself,
+    // not to a particular team.
+    if (ais.count(team) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[team]-&gt;handleEvent(eventID, event);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}


Property changes on: branches/caiinterface/AI/Global/NullAI/AIExport.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/AIExport.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/AIExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/AIExport.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,38 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AIEXPORT_H
+#define AIEXPORT_H
+
+// First we create extern declarations that will work across
+// different platforms.
+#ifndef DLL_EXPORT
+    #ifdef _WIN32
+        #define DLL_EXPORT extern &quot;C&quot; __declspec(dllexport)
+    #elif __GNUC__ &gt;= 4
+        // Support for '-fvisibility=hidden'.
+        #define DLL_EXPORT extern &quot;C&quot; __attribute__ ((visibility(&quot;default&quot;)))
+    #else
+        #define DLL_EXPORT extern &quot;C&quot;
+    #endif
+#endif
+
+DLL_EXPORT int version();
+DLL_EXPORT void init(int team);
+DLL_EXPORT int handleEvent(int team, int eventID, void* event);
+
+#endif /*AIEXPORT_H*/


Property changes on: branches/caiinterface/AI/Global/NullAI/AIExport.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/AISCommands.cpp
===================================================================
--- branches/caiinterface/AI/Global/NullAI/AISCommands.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/AISCommands.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,2 @@
+
+#include &quot;ExternalAI/AISCommands.cpp&quot;


Property changes on: branches/caiinterface/AI/Global/NullAI/AISCommands.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDamagedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDamagedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDamagedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyDamagedEvent : public CAIEvent {
+public:
+    CAIEnemyDamagedEvent(SEnemyDamagedEvent* event): event(*event) {}
+    ~CAIEnemyDamagedEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SEnemyDamagedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDamagedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDestroyedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDestroyedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDestroyedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyDestroyedEvent : public CAIEvent {
+public:
+    CAIEnemyDestroyedEvent(SEnemyDestroyedEvent* event): event(*event) {}
+    ~CAIEnemyDestroyedEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SEnemyDestroyedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyDestroyedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterLOSEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterLOSEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterLOSEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyEnterLOSEvent : public CAIEvent {
+public:
+    CAIEnemyEnterLOSEvent(SEnemyEnterLOSEvent* event): event(*event) {}
+    ~CAIEnemyEnterLOSEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SEnemyEnterLOSEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterLOSEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterRadarEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterRadarEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterRadarEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyEnterRadarEvent : public CAIEvent {
+public:
+    CAIEnemyEnterRadarEvent(SEnemyEnterRadarEvent* event): event(*event) {}
+    ~CAIEnemyEnterRadarEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SEnemyEnterRadarEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyEnterRadarEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveLOSEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveLOSEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveLOSEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyLeaveLOSEvent : public CAIEvent {
+public:
+    CAIEnemyLeaveLOSEvent(SEnemyLeaveLOSEvent* event): event(*event) {}
+    ~CAIEnemyLeaveLOSEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SEnemyLeaveLOSEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveLOSEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveRadarEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveRadarEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveRadarEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyLeaveRadarEvent : public CAIEvent {
+public:
+    CAIEnemyLeaveRadarEvent(SEnemyLeaveRadarEvent* event): event(*event) {}
+    ~CAIEnemyLeaveRadarEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SEnemyLeaveRadarEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIEnemyLeaveRadarEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,23 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEvent {
+public:
+    
+    virtual void run(CAI* ai) = 0;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIEvents.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIEvents.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIEvents.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,56 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+#ifndef AIEVENTS_H
+#define AIEVENTS_H
+
+#include &quot;../AI.h&quot;
+
+#include &quot;ExternalAI/AISEvents.h&quot;
+#include &quot;ExternalAI/AISCommands.h&quot;
+#include &quot;ExternalAI/SAICallback.h&quot;
+
+#include &quot;AIEvent.h&quot;
+#include &quot;AINullEvent.h&quot;
+
+#include &quot;AIInitEvent.h&quot;
+#include &quot;AIUpdateEvent.h&quot;
+
+#include &quot;AIMessageEvent.h&quot;
+
+#include &quot;AIUnitCreatedEvent.h&quot;
+#include &quot;AIUnitFinishedEvent.h&quot;
+#include &quot;AIUnitIdleEvent.h&quot;
+#include &quot;AIUnitMoveFailedEvent.h&quot;
+#include &quot;AIUnitDamagedEvent.h&quot;
+#include &quot;AIUnitDestroyedEvent.h&quot;
+#include &quot;AIUnitGivenEvent.h&quot;
+#include &quot;AIUnitCapturedEvent.h&quot;
+
+#include &quot;AIEnemyEnterLOSEvent.h&quot;
+#include &quot;AIEnemyLeaveLOSEvent.h&quot;
+#include &quot;AIEnemyEnterRadarEvent.h&quot;
+#include &quot;AIEnemyLeaveRadarEvent.h&quot;
+#include &quot;AIEnemyDamagedEvent.h&quot;
+#include &quot;AIEnemyDestroyedEvent.h&quot;
+
+#include &quot;AIWeaponFiredEvent.h&quot;
+#include &quot;AIPlayerCommandEvent.h&quot;
+#include &quot;AISeismicPingEvent.h&quot;
+
+#endif /*AIEVENTS_H*/


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIEvents.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIInitEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIInitEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIInitEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIInitEvent : public CAIEvent {
+public:
+    CAIInitEvent(SInitEvent* event): event(*event) {}
+    ~CAIInitEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SInitEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIInitEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIMessageEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIMessageEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIMessageEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIMessageEvent : public CAIEvent {
+public:
+    CAIMessageEvent(SMessageEvent* event): event(*event) {}
+    ~CAIMessageEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SMessageEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIMessageEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AINullEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AINullEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AINullEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,24 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+class CAINullEvent : public CAIEvent {
+public:
+    CAINullEvent() {}
+    ~CAINullEvent() {}
+    
+    void run(CAI* ai) {}
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AINullEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIPlayerCommandEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIPlayerCommandEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIPlayerCommandEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,30 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIPLAYERCOMMANDEVENT_H
+#define	_AIPLAYERCOMMANDEVENT_H
+
+class CAIPlayerCommandEvent : public CAIEvent {
+public:
+    CAIPlayerCommandEvent(SPlayerCommandEvent* event): event(*event) {}
+    ~CAIPlayerCommandEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SPlayerCommandEvent event;
+};
+
+#endif	/* _AIPLAYERCOMMANDEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIPlayerCommandEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AISeismicPingEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AISeismicPingEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AISeismicPingEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,30 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AISEISMICPINGEVENT_H
+#define	_AISEISMICPINGEVENT_H
+
+class CAISeismicPingEvent : public CAIEvent {
+public:
+    CAISeismicPingEvent(SSeismicPingEvent* event): event(*event) {}
+    ~CAISeismicPingEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SSeismicPingEvent event;
+};
+
+#endif	/* _AISEISMICPINGEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AISeismicPingEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUnitCapturedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUnitCapturedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUnitCapturedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,30 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIUNITCAPTUREDEVENT_H
+#define	_AIUNITCAPTUREDEVENT_H
+
+class CAIUnitCapturedEvent : public CAIEvent {
+public:
+    CAIUnitCapturedEvent(SUnitCapturedEvent* event): event(*event) {}
+    ~CAIUnitCapturedEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUnitCapturedEvent event;
+};
+
+#endif	/* _AIUNITCAPTUREDEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUnitCapturedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUnitCreatedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUnitCreatedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUnitCreatedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitCreatedEvent : public CAIEvent {
+public:
+    CAIUnitCreatedEvent(SUnitCreatedEvent* event): event(*event) {}
+    ~CAIUnitCreatedEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUnitCreatedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUnitCreatedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUnitDamagedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUnitDamagedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUnitDamagedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitDamagedEvent : public CAIEvent {
+public:
+    CAIUnitDamagedEvent(SUnitDamagedEvent* event): event(*event) {}
+    ~CAIUnitDamagedEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUnitDamagedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUnitDamagedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUnitDestroyedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUnitDestroyedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUnitDestroyedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitDestroyedEvent : public CAIEvent {
+public:
+    CAIUnitDestroyedEvent(SUnitDestroyedEvent* event): event(*event) {}
+    ~CAIUnitDestroyedEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUnitDestroyedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUnitDestroyedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUnitFinishedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUnitFinishedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUnitFinishedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitFinishedEvent : public CAIEvent {
+public:
+    CAIUnitFinishedEvent(SUnitFinishedEvent* event): event(*event) {}
+    ~CAIUnitFinishedEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUnitFinishedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUnitFinishedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUnitGivenEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUnitGivenEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUnitGivenEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,32 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIUNITGIVENEVENT_H
+#define	_AIUNITGIVENEVENT_H
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+
+class CAIUnitGivenEvent : public CAIEvent {
+public:
+    CAIUnitGivenEvent(SUnitGivenEvent* event): event(*event) {}
+    ~CAIUnitGivenEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUnitGivenEvent event;
+};
+
+#endif	/* _AIUNITGIVENEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUnitGivenEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUnitIdleEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUnitIdleEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUnitIdleEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitIdleEvent : public CAIEvent {
+public:
+    CAIUnitIdleEvent(SUnitIdleEvent* event): event(*event) {}
+    ~CAIUnitIdleEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUnitIdleEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUnitIdleEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUnitMoveFailedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUnitMoveFailedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUnitMoveFailedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitMoveFailedEvent : public CAIEvent {
+public:
+    CAIUnitMoveFailedEvent(SUnitMoveFailedEvent* event): event(*event) {}
+    ~CAIUnitMoveFailedEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUnitMoveFailedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUnitMoveFailedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIUpdateEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIUpdateEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIUpdateEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,27 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUpdateEvent : public CAIEvent {
+public:
+    CAIUpdateEvent(SUpdateEvent* event): event(*event) {}
+    ~CAIUpdateEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SUpdateEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIUpdateEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/NullAI/Event/AIWeaponFiredEvent.h
===================================================================
--- branches/caiinterface/AI/Global/NullAI/Event/AIWeaponFiredEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/NullAI/Event/AIWeaponFiredEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,30 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIWEAPONFIREDEVENT_H
+#define	_AIWEAPONFIREDEVENT_H
+
+class CAIWeaponFiredEvent : public CAIEvent {
+public:
+    CAIWeaponFiredEvent(SWeaponFiredEvent* event): event(*event) {}
+    ~CAIWeaponFiredEvent() {}
+    
+    void run(CAI* ai) {}
+private:
+    SWeaponFiredEvent event;
+};
+
+#endif	/* _AIWEAPONFIREDEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/NullAI/Event/AIWeaponFiredEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AI.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AI.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AI.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,104 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AI.h&quot;
+#include &quot;Event/AIEvents.h&quot;
+#include &quot;ExternalAI/AISEvents.h&quot;
+
+CAI::CAI() : team(0) { 
+	
+}
+
+
+CAI::CAI(int team) : team(team) {
+	
+}
+
+int CAI::handleEvent(int eventID, void* event) {
+	CAIEvent* e;
+	switch(eventID) {
+		case EVENT_NULL:
+			e = new CAINullEvent();
+			break;
+		case EVENT_INIT:
+			e = new CAIInitEvent((SInitEvent*) event);
+			break;
+		case EVENT_UPDATE:
+			e = new CAIUpdateEvent((SUpdateEvent*) event);
+			break;
+		case EVENT_MESSAGE:	
+			e = new CAIMessageEvent((SMessageEvent*) event);
+			break;
+		case EVENT_UNIT_CREATED:
+			e = new CAIUnitCreatedEvent((SUnitCreatedEvent*) event);
+			break;
+		case EVENT_UNIT_FINISHED:
+			e = new CAIUnitFinishedEvent((SUnitFinishedEvent*) event);
+			break;
+		case EVENT_UNIT_IDLE:
+			e = new CAIUnitIdleEvent((SUnitIdleEvent*) event);
+			break;
+		case EVENT_UNIT_MOVE_FAILED:
+			e = new CAIUnitMoveFailedEvent((SUnitMoveFailedEvent*) event);
+			break;
+		case EVENT_UNIT_DAMAGED:
+			e = new CAIUnitDamagedEvent((SUnitDamagedEvent*) event);
+			break;
+		case EVENT_UNIT_DESTROYED: 
+			e = new CAIUnitDestroyedEvent((SUnitDestroyedEvent*) event);
+			break;
+		case EVENT_UNIT_GIVEN:
+			e = new CAIUnitGivenEvent((SUnitGivenEvent*) event);
+			break;
+		case EVENT_UNIT_CAPTURED:
+			e = new CAIUnitCapturedEvent((SUnitCapturedEvent*) event);
+			break;
+		case EVENT_ENEMY_ENTER_LOS:
+			e = new CAIEnemyEnterLOSEvent((SEnemyEnterLOSEvent*) event);
+			break;
+		case EVENT_ENEMY_LEAVE_LOS:
+			e = new CAIEnemyLeaveLOSEvent((SEnemyLeaveLOSEvent*) event);
+			break;
+		case EVENT_ENEMY_ENTER_RADAR:
+			e = new CAIEnemyEnterRadarEvent((SEnemyEnterRadarEvent*) event);
+			break;
+		case EVENT_ENEMY_LEAVE_RADAR:
+			e = new CAIEnemyLeaveRadarEvent((SEnemyLeaveRadarEvent*) event);
+			break;
+		case EVENT_ENEMY_DAMAGED:
+			e = new CAIEnemyDamagedEvent((SEnemyDamagedEvent*) event);
+			break;
+		case EVENT_ENEMY_DESTROYED: 
+			e = new CAIEnemyDestroyedEvent((SEnemyDestroyedEvent*) event);
+			break;
+		case EVENT_WEAPON_FIRED: 
+			e = new CAIWeaponFiredEvent((SWeaponFiredEvent*) event);
+			break;
+		case EVENT_PLAYER_COMMAND: 
+			e = new CAIPlayerCommandEvent((SPlayerCommandEvent*) event);
+			break;
+		case EVENT_SEISMIC_PING: 
+			e = new CAISeismicPingEvent((SSeismicPingEvent*) event);
+			break;
+		default:
+			e = new CAINullEvent();
+			break;
+	}
+	e-&gt;run(this);
+	delete e;
+	return 0;
+}


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AI.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AI.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AI.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,33 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AI_H
+#define AI_H
+
+#include &lt;iostream&gt;
+
+class CAI { 
+public:
+    CAI();
+    CAI(int team);
+    virtual int handleEvent(int eventID, void* event);
+
+    int team;
+};
+
+
+#endif /*AI_H*/


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,2205 @@
+/*
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, se&lt;e &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIAICallback.h&quot;
+
+#include &quot;ExternalAI/AISCommands.h&quot;
+
+
+creg::Class* CCommandQueue::GetClass() { return NULL; }
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+UnitDef::~UnitDef() {
+    delete movedata;
+}
+CIcon::CIcon() {}
+CIcon::~CIcon() {}
+UnitDef::UnitDefWeapon::UnitDefWeapon() {}
+#include &quot;Sim/Features/FeatureDef.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+WeaponDef::~WeaponDef() {}
+DamageArray::DamageArray() {}
+
+#include &lt;string&gt;
+
+
+CAIAICallback::CAIAICallback()
+	: IAICallback(), teamId(-1), sAICallback(NULL)/*, aiCallback(NULL)*/ {
+	init();
+}
+
+CAIAICallback::CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/)
+	: IAICallback(), teamId(teamId), sAICallback(sAICallback)/*, aiCallback(aiCallback)*/ {
+	init();
+}
+
+
+void fillWithNULL(void** arr, int size) {
+	for (int i=0; i &lt; size; ++i) {
+		arr[i] = NULL;
+	}
+}
+void fillWithMinusOne(int* arr, int size) {
+	for (int i=0; i &lt; size; ++i) {
+		arr[i] = -1;
+	}
+}
+
+void CAIAICallback::init() {
+	
+	// init caches
+	int maxCacheSize = 512;
+	int maxUnits = 10000;
+	int maxGroups = 100;
+	
+	weaponDefs = new WeaponDef*[maxCacheSize]; fillWithNULL((void**)weaponDefs, maxCacheSize);
+	weaponDefFrames = new int[maxCacheSize]; fillWithMinusOne(weaponDefFrames, maxCacheSize);
+	
+	unitDefs = new UnitDef*[maxCacheSize]; fillWithNULL((void**)unitDefs, maxCacheSize);
+	unitDefFrames = new int[maxCacheSize]; fillWithMinusOne(unitDefFrames, maxCacheSize);
+	groupPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxGroups]; fillWithNULL((void**)groupPossibleCommands, maxGroups);
+	unitPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxUnits]; fillWithNULL((void**)unitPossibleCommands, maxUnits);
+	unitCurrentCommandQueues = new CCommandQueue*[maxUnits]; fillWithNULL((void**)unitCurrentCommandQueues, maxUnits);
+	
+	featureDefs = new FeatureDef*[maxCacheSize]; fillWithNULL((void**)featureDefs, maxCacheSize);
+	featureDefFrames = new int[maxCacheSize]; fillWithMinusOne(featureDefFrames, maxCacheSize);
+}
+
+
+//bool CAIAICallback::PosInCamera(float3 pos, float radius) {
+//	return aiCallback-&gt;PosInCamera(pos, radius);
+//}
+//
+//int CAIAICallback::GetCurrentFrame() {
+//	return aiCallback-&gt;GetCurrentFrame();
+//}
+//
+//int CAIAICallback::GetMyTeam() {
+//	return aiCallback-&gt;GetMyTeam();
+//}
+//
+//int CAIAICallback::GetMyAllyTeam() {
+//	return aiCallback-&gt;GetMyAllyTeam();
+//}
+//
+//int CAIAICallback::GetPlayerTeam(int player) {
+//	return aiCallback-&gt;GetPlayerTeam(player);
+//}
+//
+//const char* CAIAICallback::GetTeamSide(int team) {
+//	return aiCallback-&gt;GetTeamSide(team);
+//}
+//
+//int CAIAICallback::GetUnitGroup(int unitId) {
+//	return aiCallback-&gt;GetUnitGroup(unitId);
+//}
+//
+//int CAIAICallback::GetUnitAiHint(int unitId) {
+//	return aiCallback-&gt;GetUnitAiHint(unitId);
+//}
+//
+//int CAIAICallback::GetUnitTeam(int unitId) {
+//	return aiCallback-&gt;GetUnitTeam(unitId);
+//}
+//
+//int CAIAICallback::GetUnitAllyTeam(int unitId) {
+//	return aiCallback-&gt;GetUnitAllyTeam(unitId);
+//}
+//
+//float CAIAICallback::GetUnitHealth(int unitId) {
+//	return aiCallback-&gt;GetUnitHealth(unitId);
+//}
+//
+//float CAIAICallback::GetUnitMaxHealth(int unitId) {
+//	return aiCallback-&gt;GetUnitMaxHealth(unitId);
+//}
+//
+//float CAIAICallback::GetUnitSpeed(int unitId) {
+//	return aiCallback-&gt;GetUnitSpeed(unitId);
+//}
+//
+//float CAIAICallback::GetUnitPower(int unitId) {
+//	return aiCallback-&gt;GetUnitPower(unitId);
+//}
+//
+//float CAIAICallback::GetUnitExperience(int unitId) {
+//	return aiCallback-&gt;GetUnitExperience(unitId);
+//}
+//
+//float CAIAICallback::GetUnitMaxRange(int unitId) {
+//	return aiCallback-&gt;GetUnitMaxRange(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitActivated(int unitId) {
+//	return aiCallback-&gt;IsUnitActivated(unitId);
+//}
+//
+//bool CAIAICallback::UnitBeingBuilt(int unitId) {
+//	return aiCallback-&gt;UnitBeingBuilt(unitId);
+//}
+//
+//float3 CAIAICallback::GetUnitPos(int unitId) {
+//	return aiCallback-&gt;GetUnitPos(unitId);
+//}
+//
+//int CAIAICallback::GetBuildingFacing(int unitId) {
+//	return aiCallback-&gt;GetBuildingFacing(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitCloaked(int unitId) {
+//	return aiCallback-&gt;IsUnitCloaked(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitParalyzed(int unitId) {
+//	return aiCallback-&gt;IsUnitParalyzed(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitNeutral(int unitId) {
+//	return aiCallback-&gt;IsUnitNeutral(unitId);
+//}
+//
+//bool CAIAICallback::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+//	return aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
+//}
+//
+//float3 CAIAICallback::GetNextWaypoint(int pathid) {
+//	return aiCallback-&gt;GetNextWaypoint(pathid);
+//}
+//
+//float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;GetPathLength(start, end, pathType);
+//}
+//
+//int CAIAICallback::GetEnemyUnits(int* unitIds) {
+//	return aiCallback-&gt;GetEnemyUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds) {
+//	return aiCallback-&gt;GetEnemyUnitsInRadarAndLos(unitIds);
+//}
+//
+//int CAIAICallback::GetFriendlyUnits(int* unitIds) {
+//	return aiCallback-&gt;GetFriendlyUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetFriendlyUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetNeutralUnits(int* unitIds) {
+//	return aiCallback-&gt;GetNeutralUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetMapWidth() {
+//	return aiCallback-&gt;GetMapWidth();
+//}
+//
+//int CAIAICallback::GetMapHeight() {
+//	return aiCallback-&gt;GetMapHeight();
+//}
+//
+//const float* CAIAICallback::GetHeightMap() {
+//	return aiCallback-&gt;GetHeightMap();
+//}
+//
+//float CAIAICallback::GetMinHeight() {
+//	return aiCallback-&gt;GetMinHeight();
+//}
+//
+//float CAIAICallback::GetMaxHeight() {
+//	return aiCallback-&gt;GetMaxHeight();
+//}
+//
+//const float* CAIAICallback::GetSlopeMap() {
+//	return aiCallback-&gt;GetSlopeMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetLosMap() {
+//	return aiCallback-&gt;GetLosMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetRadarMap() {
+//	return aiCallback-&gt;GetRadarMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetJammerMap() {
+//	return aiCallback-&gt;GetJammerMap();
+//}
+//
+//const unsigned char* CAIAICallback::GetMetalMap() {
+//	return aiCallback-&gt;GetMetalMap();
+//}
+//
+//const char* CAIAICallback::GetMapName() {
+//	return aiCallback-&gt;GetMapName();
+//}
+//
+//const char* CAIAICallback::GetModName() {
+//	return aiCallback-&gt;GetModName();
+//}
+//
+//float CAIAICallback::GetElevation(float x, float z) {
+//	return aiCallback-&gt;GetElevation(x, z);
+//}
+//
+//float CAIAICallback::GetMaxMetal() {
+//	return aiCallback-&gt;GetMaxMetal();
+//}
+//
+//float CAIAICallback::GetExtractorRadius() {
+//	return aiCallback-&gt;GetExtractorRadius();
+//}
+//
+//float CAIAICallback::GetMinWind() {
+//	return aiCallback-&gt;GetMinWind();
+//}
+//
+//float CAIAICallback::GetMaxWind() {
+//	return aiCallback-&gt;GetMaxWind();
+//}
+//
+//float CAIAICallback::GetTidalStrength() {
+//	return aiCallback-&gt;GetTidalStrength();
+//}
+//
+//float CAIAICallback::GetGravity() {
+//	return aiCallback-&gt;GetGravity();
+//}
+//
+//bool CAIAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing) {
+//	return aiCallback-&gt;CanBuildAt(unitDef, pos, facing);
+//}
+//
+//float3 CAIAICallback::ClosestBuildSite(const UnitDef* unitDef, float3 pos, float searchRadius, int minDist, int facing) {
+//	return aiCallback-&gt;ClosestBuildSite(unitDef, pos, searchRadius, minDist, facing);
+//}
+//
+//bool CAIAICallback::GetProperty(int id, int property, void* dst) {
+//	return aiCallback-&gt;GetProperty(id, property, dst);
+//}
+//
+//bool CAIAICallback::GetValue(int id, void* dst) {
+//	return aiCallback-&gt;GetValue(id, dst);
+//}
+//
+//int CAIAICallback::GetFileSize(const char* name) {
+//	return aiCallback-&gt;GetFileSize(name);
+//}
+//
+//int CAIAICallback::GetSelectedUnits(int* unitIds) {
+//	return aiCallback-&gt;GetSelectedUnits(unitIds);
+//}
+//
+//float3 CAIAICallback::GetMousePos() {
+//	return aiCallback-&gt;GetMousePos();
+//}
+//
+//float CAIAICallback::GetMetal() {
+//	return aiCallback-&gt;GetMetal();
+//}
+//
+//float CAIAICallback::GetMetalIncome() {
+//	return aiCallback-&gt;GetMetalIncome();
+//}
+//
+//float CAIAICallback::GetMetalUsage() {
+//	return aiCallback-&gt;GetMetalUsage();
+//}
+//
+//float CAIAICallback::GetMetalStorage() {
+//	return aiCallback-&gt;GetMetalStorage();
+//}
+//
+//float CAIAICallback::GetEnergy() {
+//	return aiCallback-&gt;GetEnergy();
+//}
+//
+//float CAIAICallback::GetEnergyIncome() {
+//	return aiCallback-&gt;GetEnergyIncome();
+//}
+//
+//float CAIAICallback::GetEnergyUsage() {
+//	return aiCallback-&gt;GetEnergyUsage();
+//}
+//
+//float CAIAICallback::GetEnergyStorage() {
+//	return aiCallback-&gt;GetEnergyStorage();
+//}
+//
+//int CAIAICallback::GetFeatures(int *features, int max) {
+//	return aiCallback-&gt;GetFeatures(features, max);
+//}
+//
+//int CAIAICallback::GetFeatures(int *features, int max, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetFeatures(features, max, pos, radius);
+//}
+//
+//const FeatureDef* CAIAICallback::GetFeatureDef(int featureId) {
+//	return aiCallback-&gt;GetFeatureDef(featureId);
+//}
+//
+//float CAIAICallback::GetFeatureHealth(int featureId) {
+//	return aiCallback-&gt;GetFeatureHealth(featureId);
+//}
+//
+//float CAIAICallback::GetFeatureReclaimLeft(int featureId) {
+//	return aiCallback-&gt;GetFeatureReclaimLeft(featureId);
+//}
+//
+//float3 CAIAICallback::GetFeaturePos(int featureId) {
+//	return aiCallback-&gt;GetFeaturePos(featureId);
+//}
+//
+//int CAIAICallback::GetNumUnitDefs() {
+//	return aiCallback-&gt;GetNumUnitDefs();
+//}
+//
+//void CAIAICallback::GetUnitDefList(const UnitDef** list) {
+//	aiCallback-&gt;GetUnitDefList(list);
+//}
+
+//float CAIAICallback::GetUnitDefHeight(int def) {
+//	return aiCallback-&gt;GetUnitDefHeight(def);
+//}
+//
+//float CAIAICallback::GetUnitDefRadius(int def) {
+//	return aiCallback-&gt;GetUnitDefRadius(def);
+//}
+//
+//const float3* CAIAICallback::GetStartPos() {
+//	return aiCallback-&gt;GetStartPos();
+//}
+//
+//
+//
+//const WeaponDef* CAIAICallback::GetWeapon(const char* weaponname) {
+//	logT(&quot;CAIAICallback::GetWeapon() aiCallback&quot;);
+//	return aiCallback-&gt;GetWeapon(weaponname);
+//}
+//
+//const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
+//	logT(&quot;CAIAICallback::GetWeaponDefById() return NULL&quot;);
+//	return NULL;
+//}
+//
+//const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
+//	logT(&quot;CAIAICallback::GetFeatureDefById() aiCallback&quot;);
+//	return aiCallback-&gt;GetFeatureDefById(featureDefId);
+//}
+//
+//int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
+//	return aiCallback-&gt;GetMapPoints(pm, maxPoints);
+//}
+//
+//int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
+//	return aiCallback-&gt;GetMapLines(lm, maxLines);
+//}
+//
+//const UnitDef* CAIAICallback::GetUnitDef(const char* unitName) {
+//	return aiCallback-&gt;GetUnitDef(unitName);
+//}
+
+//const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
+//	return aiCallback-&gt;GetUnitDefById(unitDefId);
+//}
+
+//const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int unitId) {
+//	return aiCallback-&gt;GetGroupCommands(unitId);
+//}
+//
+//const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
+//	return aiCallback-&gt;GetUnitCommands(unitId);
+//}
+//
+//const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
+//	return aiCallback-&gt;GetCurrentUnitCommands(unitId);
+//}
+//
+//const UnitDef* CAIAICallback::GetUnitDef(int unitId) {
+//	return aiCallback-&gt;GetUnitDef(unitId);
+//}
+
+
+
+
+
+
+
+//void CAIAICallback::SendTextMsg(const char* text, int zone) {
+//	aiCallback-&gt;SendTextMsg(text, zone);
+//}
+//
+//void CAIAICallback::SetLastMsgPos(float3 pos) {
+//	aiCallback-&gt;SetLastMsgPos(pos);
+//}
+//
+//void CAIAICallback::AddNotification(float3 pos, float3 color, float alpha) {
+//	aiCallback-&gt;AddNotification(pos, color, alpha);
+//}
+//
+//bool CAIAICallback::SendResources(float mAmount, float eAmount, int receivingTeam) {
+//	return aiCallback-&gt;SendResources(mAmount, eAmount, receivingTeam);
+//}
+//
+//int CAIAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam) {
+//	return aiCallback-&gt;SendUnits(unitIDs, receivingTeam);
+//}
+//
+//void* CAIAICallback::CreateSharedMemArea(char* name, int size) {
+//	return aiCallback-&gt;CreateSharedMemArea(name, size);
+//}
+//
+//void CAIAICallback::ReleasedSharedMemArea(char* name) {
+//	aiCallback-&gt;ReleasedSharedMemArea(name);
+//}
+//
+//int CAIAICallback::CreateGroup(char* dll, unsigned aiNumber) {
+//	return aiCallback-&gt;CreateGroup(dll, aiNumber);
+//}
+//
+//void CAIAICallback::EraseGroup(int groupid) {
+//	aiCallback-&gt;EraseGroup(groupid);
+//}
+//
+//bool CAIAICallback::AddUnitToGroup(int unitId, int groupid) {
+//	return aiCallback-&gt;AddUnitToGroup(unitId, groupid);
+//}
+//
+//bool CAIAICallback::RemoveUnitFromGroup(int unitId) {
+//	return aiCallback-&gt;RemoveUnitFromGroup(unitId);
+//}
+//
+//int CAIAICallback::GiveGroupOrder(int unitId, Command* c) {
+//	return aiCallback-&gt;GiveGroupOrder(unitId, c);
+//}
+//
+//int CAIAICallback::GiveOrder(int unitId, Command* c) {
+//	return aiCallback-&gt;GiveOrder(unitId, c);
+//}
+//
+//int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;InitPath(start, end, pathType);
+//}
+//
+//float3 CAIAICallback::GetNextWaypoint(int pathId) {
+//	return aiCallback-&gt;GetNextWaypoint(pathId);
+//}
+//
+//float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;GetPathLength(start, end, pathType);
+//}
+//
+//void CAIAICallback::FreePath(int pathid) {
+//	aiCallback-&gt;FreePath(pathid);
+//}
+//
+//void CAIAICallback::LineDrawerStartPath(const float3&amp; pos, const float* color) {
+//	aiCallback-&gt;LineDrawerStartPath(pos, color);
+//}
+//
+//void CAIAICallback::LineDrawerFinishPath() {
+//	aiCallback-&gt;LineDrawerFinishPath();
+//}
+//
+//void CAIAICallback::LineDrawerDrawLine(const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerDrawLine(endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerDrawLineAndIcon(cmdID, endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerDrawIconAtLastPos(int cmdID) {
+//	aiCallback-&gt;LineDrawerDrawIconAtLastPos(cmdID);
+//}
+//
+//void CAIAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerBreak(endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerRestart() {
+//	aiCallback-&gt;LineDrawerRestart();
+//}
+//
+//void CAIAICallback::LineDrawerRestartSameColor() {
+//	aiCallback-&gt;LineDrawerRestartSameColor();
+//}
+//
+//int CAIAICallback::CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group) {
+//	return aiCallback-&gt;CreateSplineFigure(pos1, pos2, pos3, pos4, width, arrow, lifetime, group);
+//}
+//
+//int CAIAICallback::CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group) {
+//	return aiCallback-&gt;CreateLineFigure(pos1, pos2, width, arrow, lifetime, group);
+//}
+//
+//void CAIAICallback::SetFigureColor(int group, float red, float green, float blue, float alpha) {
+//	aiCallback-&gt;SetFigureColor(group, red, green, blue, alpha);
+//}
+//
+//void CAIAICallback::DeleteFigureGroup(int group) {
+//	aiCallback-&gt;DeleteFigureGroup(group);
+//}
+//
+//void CAIAICallback::DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing) {
+//	aiCallback-&gt;DrawUnit(name, pos, rotation, lifetime, team, transparent, drawBorder, facing);
+//}
+//
+//int CAIAICallback::HandleCommand(int commandId, void* data) {
+//	return aiCallback-&gt;HandleCommand(commandId, data);
+//}
+//
+//bool CAIAICallback::ReadFile(const char* name, void* buffer, int bufferLen) {
+//	return aiCallback-&gt;ReadFile(name, buffer, bufferLen);
+//}
+//
+//const char* CAIAICallback::CallLuaRules(const char* data, int inSize, int* outSize) {
+//	return aiCallback-&gt;CallLuaRules(data, inSize, outSize);
+//}
+// ################################ &lt;- OLD impl ################################
+
+
+
+
+// ################################ NEW impl -&gt; ################################
+bool CAIAICallback::PosInCamera(float3 pos, float radius) {
+	return sAICallback-&gt;Map_isPosInCamera(teamId, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetCurrentFrame() {
+	return sAICallback-&gt;Game_getCurrentFrame(teamId);
+}
+
+int CAIAICallback::GetMyTeam() {
+	return sAICallback-&gt;Game_getMyTeam(teamId);
+}
+
+int CAIAICallback::GetMyAllyTeam() {
+	return sAICallback-&gt;Game_getMyAllyTeam(teamId);
+}
+
+int CAIAICallback::GetPlayerTeam(int player) {
+	return sAICallback-&gt;Game_getPlayerTeam(teamId, player);
+}
+
+const char* CAIAICallback::GetTeamSide(int team) {
+	return sAICallback-&gt;Game_getTeamSide(teamId, team);
+}
+
+int CAIAICallback::GetUnitGroup(int unitId) {
+	return sAICallback-&gt;Unit_getGroup(teamId, unitId);
+}
+
+
+const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
+	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
+int ids[numCmds];
+const char* names[numCmds];
+const char* toolTips[numCmds];
+bool showUniques[numCmds];
+bool disableds[numCmds];
+int numParams[numCmds];
+const char** params[numCmds];
+sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
+sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
+sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
+sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
+sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
+sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
+for (int c=0; c &lt; numCmds; c++) {
+	params[c] = new const char*[numParams[c]];
+}
+sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, params);
+	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
+	for (int c=0; c &lt; numCmds; c++) {
+		CommandDescription commandDescription;
+		commandDescription.id = ids[c];
+		commandDescription.name = names[c];
+		commandDescription.tooltip = toolTips[c];
+		commandDescription.showUnique = showUniques[c];
+		commandDescription.disabled = disableds[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			commandDescription.params.push_back(params[c][p]);
+		}
+		cmdDescVec-&gt;push_back(commandDescription);
+	}
+	
+	// to prevent memory wholes
+	if (groupPossibleCommands[groupId] != NULL) {
+		delete groupPossibleCommands[groupId];
+	}
+	groupPossibleCommands[groupId] = cmdDescVec;
+	
+	return cmdDescVec;
+}
+
+
+const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
+	int numCmds = sAICallback-&gt;Unit_getNumSupportedCommands(teamId, unitId);
+int* ids = new int[numCmds];
+const char* names[numCmds];
+const char* toolTips[numCmds];
+bool showUniques[numCmds];
+bool disableds[numCmds];
+int numParams[numCmds];
+const char** params[numCmds];
+sAICallback-&gt;Unit_SupportedCommands_getId(teamId, unitId, ids);
+sAICallback-&gt;Unit_SupportedCommands_getName(teamId, unitId, names);
+sAICallback-&gt;Unit_SupportedCommands_getToolTip(teamId, unitId, toolTips);
+sAICallback-&gt;Unit_SupportedCommands_isShowUnique(teamId, unitId, showUniques);
+sAICallback-&gt;Unit_SupportedCommands_isDisabled(teamId, unitId, disableds);
+sAICallback-&gt;Unit_SupportedCommands_getNumParams(teamId, unitId, numParams);
+for (int c=0; c &lt; numCmds; c++) {
+	params[c] = new const char*[numParams[c]];
+}
+sAICallback-&gt;Unit_SupportedCommands_getParams(teamId, unitId, params);
+	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
+	for (int c=0; c &lt; numCmds; c++) {
+		CommandDescription commandDescription;
+		commandDescription.id = ids[c];
+		commandDescription.name = names[c];
+		commandDescription.tooltip = toolTips[c];
+		commandDescription.showUnique = showUniques[c];
+		commandDescription.disabled = disableds[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			commandDescription.params.push_back(params[c][p]);
+		}
+		cmdDescVec-&gt;push_back(commandDescription);
+	}
+	
+	// to prevent memory wholes
+	if (unitPossibleCommands[unitId] != NULL) {
+		delete unitPossibleCommands[unitId];
+	}
+	unitPossibleCommands[unitId] = cmdDescVec;
+	
+	return cmdDescVec;
+}
+
+const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
+	int numCmds = sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
+int ids[numCmds];
+unsigned char options[numCmds];
+unsigned int tags[numCmds];
+int timeOuts[numCmds];
+int numParams[numCmds];
+float* params[numCmds];
+sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
+sAICallback-&gt;Unit_CurrentCommands_getIds(teamId, unitId, ids);
+sAICallback-&gt;Unit_CurrentCommands_getOptions(teamId, unitId, options);
+sAICallback-&gt;Unit_CurrentCommands_getTag(teamId, unitId, tags);
+sAICallback-&gt;Unit_CurrentCommands_getTimeOut(teamId, unitId, timeOuts);
+sAICallback-&gt;Unit_CurrentCommands_getNumParams(teamId, unitId, numParams);
+for (int c=0; c &lt; numCmds; c++) {
+	params[c] = new float[numParams[c]];
+}	
+sAICallback-&gt;Unit_CurrentCommands_getParams(teamId, unitId, params);
+	CCommandQueue* cc = new CCommandQueue();
+	for (int c=0; c &lt; numCmds; c++) {
+		Command command;
+		command.id = ids[c];
+		command.options = options[c];
+		command.tag = tags[c];
+		command.timeOut = timeOuts[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			command.params.push_back(params[c][p]);
+		}
+		cc-&gt;push_back(command);
+	}
+	
+	// to prevent memory wholes
+	if (unitCurrentCommandQueues[unitId] != NULL) {
+		delete unitCurrentCommandQueues[unitId];
+	}
+	unitCurrentCommandQueues[unitId] = cc;
+	
+	return cc;
+}
+
+int CAIAICallback::GetUnitAiHint(int unitId) {
+	return sAICallback-&gt;Unit_getAiHint(teamId, unitId);
+}
+
+int CAIAICallback::GetUnitTeam(int unitId) {
+	return sAICallback-&gt;Unit_getTeam(teamId, unitId);
+}
+
+int CAIAICallback::GetUnitAllyTeam(int unitId) {
+	return sAICallback-&gt;Unit_getAllyTeam(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitHealth(int unitId) {
+	return sAICallback-&gt;Unit_getHealth(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitMaxHealth(int unitId) {
+	return sAICallback-&gt;Unit_getMaxHealth(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitSpeed(int unitId) {
+	return sAICallback-&gt;Unit_getSpeed(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitPower(int unitId) {
+	return sAICallback-&gt;Unit_getPower(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitExperience(int unitId) {
+	return sAICallback-&gt;Unit_getExperience(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitMaxRange(int unitId) {
+	return sAICallback-&gt;Unit_getMaxRange(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitActivated(int unitId) {
+	return sAICallback-&gt;Unit_isActivated(teamId, unitId);
+}
+
+bool CAIAICallback::UnitBeingBuilt(int unitId) {
+	return sAICallback-&gt;Unit_isBeingBuilt(teamId, unitId);
+}
+
+const UnitDef* CAIAICallback::GetUnitDef(int unitId) {
+	int unitDefId = sAICallback-&gt;Unit_getDefId(teamId, unitId);
+	return this-&gt;GetUnitDefById(unitDefId);
+}
+
+float3 CAIAICallback::GetUnitPos(int unitId) {
+	return float3(sAICallback-&gt;Unit_getPos(teamId, unitId));
+}
+
+int CAIAICallback::GetBuildingFacing(int unitId) {
+	return sAICallback-&gt;Unit_getBuildingFacing(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitCloaked(int unitId) {
+	return sAICallback-&gt;Unit_isCloaked(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitParalyzed(int unitId) {
+	return sAICallback-&gt;Unit_isParalyzed(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitNeutral(int unitId) {
+	return sAICallback-&gt;Unit_isNeutral(teamId, unitId);
+}
+
+bool CAIAICallback::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+	resourceInfo-&gt;energyMake = sAICallback-&gt;Unit_ResourceInfo_Energy_getMake(teamId, unitId);
+	if (resourceInfo-&gt;energyMake &lt; 0) return false;
+	resourceInfo-&gt;energyUse = sAICallback-&gt;Unit_ResourceInfo_Energy_getUse(teamId, unitId);
+	resourceInfo-&gt;metalMake = sAICallback-&gt;Unit_ResourceInfo_Metal_getMake(teamId, unitId);
+	resourceInfo-&gt;metalUse = sAICallback-&gt;Unit_ResourceInfo_Metal_getUse(teamId, unitId);
+	return true;
+}
+
+const UnitDef* CAIAICallback::GetUnitDef(const char* unitName) {
+	int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitName);
+	return this-&gt;GetUnitDefById(unitDefId);
+}
+
+
+const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
+	//logT(&quot;entering: GetUnitDefById sAICallback&quot;);
+	
+	bool doRecreate = unitDefFrames[unitDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+	UnitDef* unitDef = new UnitDef();
+unitDef-&gt;valid = sAICallback-&gt;UnitDef_isValid(teamId, unitDefId);
+unitDef-&gt;name = sAICallback-&gt;UnitDef_getName(teamId, unitDefId);
+unitDef-&gt;humanName = sAICallback-&gt;UnitDef_getHumanName(teamId, unitDefId);
+unitDef-&gt;filename = sAICallback-&gt;UnitDef_getFilename(teamId, unitDefId);
+unitDef-&gt;id = sAICallback-&gt;UnitDef_getId(teamId, unitDefId);
+unitDef-&gt;aihint = sAICallback-&gt;UnitDef_getAiHint(teamId, unitDefId);
+unitDef-&gt;cobID = sAICallback-&gt;UnitDef_getCobID(teamId, unitDefId);
+unitDef-&gt;techLevel = sAICallback-&gt;UnitDef_getTechLevel(teamId, unitDefId);
+unitDef-&gt;gaia = sAICallback-&gt;UnitDef_getGaia(teamId, unitDefId);
+unitDef-&gt;metalUpkeep = sAICallback-&gt;UnitDef_getMetalUpkeep(teamId, unitDefId);
+unitDef-&gt;energyUpkeep = sAICallback-&gt;UnitDef_getEnergyUpkeep(teamId, unitDefId);
+unitDef-&gt;metalMake = sAICallback-&gt;UnitDef_getMetalMake(teamId, unitDefId);
+unitDef-&gt;makesMetal = sAICallback-&gt;UnitDef_getMakesMetal(teamId, unitDefId);
+unitDef-&gt;energyMake = sAICallback-&gt;UnitDef_getEnergyMake(teamId, unitDefId);
+unitDef-&gt;metalCost = sAICallback-&gt;UnitDef_getMetalCost(teamId, unitDefId);
+unitDef-&gt;energyCost = sAICallback-&gt;UnitDef_getEnergyCost(teamId, unitDefId);
+unitDef-&gt;buildTime = sAICallback-&gt;UnitDef_getBuildTime(teamId, unitDefId);
+unitDef-&gt;extractsMetal = sAICallback-&gt;UnitDef_getExtractsMetal(teamId, unitDefId);
+unitDef-&gt;extractRange = sAICallback-&gt;UnitDef_getExtractRange(teamId, unitDefId);
+unitDef-&gt;windGenerator = sAICallback-&gt;UnitDef_getWindGenerator(teamId, unitDefId);
+unitDef-&gt;tidalGenerator = sAICallback-&gt;UnitDef_getTidalGenerator(teamId, unitDefId);
+unitDef-&gt;metalStorage = sAICallback-&gt;UnitDef_getMetalStorage(teamId, unitDefId);
+unitDef-&gt;energyStorage = sAICallback-&gt;UnitDef_getEnergyStorage(teamId, unitDefId);
+unitDef-&gt;autoHeal = sAICallback-&gt;UnitDef_getAutoHeal(teamId, unitDefId);
+unitDef-&gt;idleAutoHeal = sAICallback-&gt;UnitDef_getIdleAutoHeal(teamId, unitDefId);
+unitDef-&gt;idleTime = sAICallback-&gt;UnitDef_getIdleTime(teamId, unitDefId);
+unitDef-&gt;power = sAICallback-&gt;UnitDef_getPower(teamId, unitDefId);
+unitDef-&gt;health = sAICallback-&gt;UnitDef_getHealth(teamId, unitDefId);
+unitDef-&gt;category = sAICallback-&gt;UnitDef_getCategory(teamId, unitDefId);
+unitDef-&gt;speed = sAICallback-&gt;UnitDef_getSpeed(teamId, unitDefId);
+unitDef-&gt;turnRate = sAICallback-&gt;UnitDef_getTurnRate(teamId, unitDefId);
+unitDef-&gt;moveType = sAICallback-&gt;UnitDef_getMoveType(teamId, unitDefId);
+unitDef-&gt;upright = sAICallback-&gt;UnitDef_isUpright(teamId, unitDefId);
+unitDef-&gt;collide = sAICallback-&gt;UnitDef_isCollide(teamId, unitDefId);
+unitDef-&gt;controlRadius = sAICallback-&gt;UnitDef_getControlRadius(teamId, unitDefId);
+unitDef-&gt;losRadius = sAICallback-&gt;UnitDef_getLosRadius(teamId, unitDefId);
+unitDef-&gt;airLosRadius = sAICallback-&gt;UnitDef_getAirLosRadius(teamId, unitDefId);
+unitDef-&gt;losHeight = sAICallback-&gt;UnitDef_getLosHeight(teamId, unitDefId);
+unitDef-&gt;radarRadius = sAICallback-&gt;UnitDef_getRadarRadius(teamId, unitDefId);
+unitDef-&gt;sonarRadius = sAICallback-&gt;UnitDef_getSonarRadius(teamId, unitDefId);
+unitDef-&gt;jammerRadius = sAICallback-&gt;UnitDef_getJammerRadius(teamId, unitDefId);
+unitDef-&gt;sonarJamRadius = sAICallback-&gt;UnitDef_getSonarJamRadius(teamId, unitDefId);
+unitDef-&gt;seismicRadius = sAICallback-&gt;UnitDef_getSeismicRadius(teamId, unitDefId);
+unitDef-&gt;seismicSignature = sAICallback-&gt;UnitDef_getSeismicSignature(teamId, unitDefId);
+unitDef-&gt;stealth = sAICallback-&gt;UnitDef_isStealth(teamId, unitDefId);
+unitDef-&gt;sonarStealth = sAICallback-&gt;UnitDef_isSonarStealth(teamId, unitDefId);
+unitDef-&gt;buildRange3D = sAICallback-&gt;UnitDef_isBuildRange3D(teamId, unitDefId);
+unitDef-&gt;buildDistance = sAICallback-&gt;UnitDef_getBuildDistance(teamId, unitDefId);
+unitDef-&gt;buildSpeed = sAICallback-&gt;UnitDef_getBuildSpeed(teamId, unitDefId);
+unitDef-&gt;reclaimSpeed = sAICallback-&gt;UnitDef_getReclaimSpeed(teamId, unitDefId);
+unitDef-&gt;repairSpeed = sAICallback-&gt;UnitDef_getRepairSpeed(teamId, unitDefId);
+unitDef-&gt;maxRepairSpeed = sAICallback-&gt;UnitDef_getMaxRepairSpeed(teamId, unitDefId);
+unitDef-&gt;resurrectSpeed = sAICallback-&gt;UnitDef_getResurrectSpeed(teamId, unitDefId);
+unitDef-&gt;captureSpeed = sAICallback-&gt;UnitDef_getCaptureSpeed(teamId, unitDefId);
+unitDef-&gt;terraformSpeed = sAICallback-&gt;UnitDef_getTerraformSpeed(teamId, unitDefId);
+unitDef-&gt;mass = sAICallback-&gt;UnitDef_getMass(teamId, unitDefId);
+unitDef-&gt;pushResistant = sAICallback-&gt;UnitDef_isPushResistant(teamId, unitDefId);
+unitDef-&gt;strafeToAttack = sAICallback-&gt;UnitDef_isStrafeToAttack(teamId, unitDefId);
+unitDef-&gt;minCollisionSpeed = sAICallback-&gt;UnitDef_getMinCollisionSpeed(teamId, unitDefId);
+unitDef-&gt;slideTolerance = sAICallback-&gt;UnitDef_getSlideTolerance(teamId, unitDefId);
+unitDef-&gt;maxSlope = sAICallback-&gt;UnitDef_getMaxSlope(teamId, unitDefId);
+unitDef-&gt;maxHeightDif = sAICallback-&gt;UnitDef_getMaxHeightDif(teamId, unitDefId);
+unitDef-&gt;minWaterDepth = sAICallback-&gt;UnitDef_getMinWaterDepth(teamId, unitDefId);
+unitDef-&gt;waterline = sAICallback-&gt;UnitDef_getWaterline(teamId, unitDefId);
+unitDef-&gt;maxWaterDepth = sAICallback-&gt;UnitDef_getMaxWaterDepth(teamId, unitDefId);
+unitDef-&gt;armoredMultiple = sAICallback-&gt;UnitDef_getArmoredMultiple(teamId, unitDefId);
+unitDef-&gt;armorType = sAICallback-&gt;UnitDef_getArmorType(teamId, unitDefId);
+unitDef-&gt;flankingBonusMode = sAICallback-&gt;UnitDef_getFlankingBonusMode(teamId, unitDefId);
+unitDef-&gt;flankingBonusDir = float3(sAICallback-&gt;UnitDef_getFlankingBonusDir(teamId, unitDefId));
+unitDef-&gt;flankingBonusMax = sAICallback-&gt;UnitDef_getFlankingBonusMax(teamId, unitDefId);
+unitDef-&gt;flankingBonusMin = sAICallback-&gt;UnitDef_getFlankingBonusMin(teamId, unitDefId);
+unitDef-&gt;flankingBonusMobilityAdd = sAICallback-&gt;UnitDef_getFlankingBonusMobilityAdd(teamId, unitDefId);
+unitDef-&gt;collisionVolumeType = sAICallback-&gt;UnitDef_getCollisionVolumeType(teamId, unitDefId);
+unitDef-&gt;collisionVolumeScales = float3(sAICallback-&gt;UnitDef_getCollisionVolumeScales(teamId, unitDefId));
+unitDef-&gt;collisionVolumeOffsets = float3(sAICallback-&gt;UnitDef_getCollisionVolumeOffsets(teamId, unitDefId));
+unitDef-&gt;collisionVolumeTest = sAICallback-&gt;UnitDef_getCollisionVolumeTest(teamId, unitDefId);
+unitDef-&gt;maxWeaponRange = sAICallback-&gt;UnitDef_getMaxWeaponRange(teamId, unitDefId);
+unitDef-&gt;type = sAICallback-&gt;UnitDef_getType(teamId, unitDefId);
+unitDef-&gt;tooltip = sAICallback-&gt;UnitDef_getTooltip(teamId, unitDefId);
+unitDef-&gt;wreckName = sAICallback-&gt;UnitDef_getWreckName(teamId, unitDefId);
+unitDef-&gt;deathExplosion = sAICallback-&gt;UnitDef_getDeathExplosion(teamId, unitDefId);
+unitDef-&gt;selfDExplosion = sAICallback-&gt;UnitDef_getSelfDExplosion(teamId, unitDefId);
+unitDef-&gt;TEDClassString = sAICallback-&gt;UnitDef_getTedClassString(teamId, unitDefId);
+unitDef-&gt;categoryString = sAICallback-&gt;UnitDef_getCategoryString(teamId, unitDefId);
+unitDef-&gt;canSelfD = sAICallback-&gt;UnitDef_isCanSelfD(teamId, unitDefId);
+unitDef-&gt;selfDCountdown = sAICallback-&gt;UnitDef_getSelfDCountdown(teamId, unitDefId);
+unitDef-&gt;canSubmerge = sAICallback-&gt;UnitDef_isCanSubmerge(teamId, unitDefId);
+unitDef-&gt;canfly = sAICallback-&gt;UnitDef_isCanFly(teamId, unitDefId);
+unitDef-&gt;canmove = sAICallback-&gt;UnitDef_isCanMove(teamId, unitDefId);
+unitDef-&gt;canhover = sAICallback-&gt;UnitDef_isCanHover(teamId, unitDefId);
+unitDef-&gt;floater = sAICallback-&gt;UnitDef_isFloater(teamId, unitDefId);
+unitDef-&gt;builder = sAICallback-&gt;UnitDef_isBuilder(teamId, unitDefId);
+unitDef-&gt;activateWhenBuilt = sAICallback-&gt;UnitDef_isActivateWhenBuilt(teamId, unitDefId);
+unitDef-&gt;onoffable = sAICallback-&gt;UnitDef_isOnOffable(teamId, unitDefId);
+unitDef-&gt;fullHealthFactory = sAICallback-&gt;UnitDef_isFullHealthFactory(teamId, unitDefId);
+unitDef-&gt;factoryHeadingTakeoff = sAICallback-&gt;UnitDef_isFactoryHeadingTakeoff(teamId, unitDefId);
+unitDef-&gt;reclaimable = sAICallback-&gt;UnitDef_isReclaimable(teamId, unitDefId);
+unitDef-&gt;capturable = sAICallback-&gt;UnitDef_isCapturable(teamId, unitDefId);
+unitDef-&gt;canRestore = sAICallback-&gt;UnitDef_isCanRestore(teamId, unitDefId);
+unitDef-&gt;canRepair = sAICallback-&gt;UnitDef_isCanRepair(teamId, unitDefId);
+unitDef-&gt;canSelfRepair = sAICallback-&gt;UnitDef_isCanSelfRepair(teamId, unitDefId);
+unitDef-&gt;canReclaim = sAICallback-&gt;UnitDef_isCanReclaim(teamId, unitDefId);
+unitDef-&gt;canAttack = sAICallback-&gt;UnitDef_isCanAttack(teamId, unitDefId);
+unitDef-&gt;canPatrol = sAICallback-&gt;UnitDef_isCanPatrol(teamId, unitDefId);
+unitDef-&gt;canFight = sAICallback-&gt;UnitDef_isCanFight(teamId, unitDefId);
+unitDef-&gt;canGuard = sAICallback-&gt;UnitDef_isCanGuard(teamId, unitDefId);
+unitDef-&gt;canBuild = sAICallback-&gt;UnitDef_isCanBuild(teamId, unitDefId);
+unitDef-&gt;canAssist = sAICallback-&gt;UnitDef_isCanAssist(teamId, unitDefId);
+unitDef-&gt;canBeAssisted = sAICallback-&gt;UnitDef_isCanBeAssisted(teamId, unitDefId);
+unitDef-&gt;canRepeat = sAICallback-&gt;UnitDef_isCanRepeat(teamId, unitDefId);
+unitDef-&gt;canFireControl = sAICallback-&gt;UnitDef_isCanFireControl(teamId, unitDefId);
+unitDef-&gt;fireState = sAICallback-&gt;UnitDef_getFireState(teamId, unitDefId);
+unitDef-&gt;moveState = sAICallback-&gt;UnitDef_getMoveState(teamId, unitDefId);
+unitDef-&gt;wingDrag = sAICallback-&gt;UnitDef_getWingDrag(teamId, unitDefId);
+unitDef-&gt;wingAngle = sAICallback-&gt;UnitDef_getWingAngle(teamId, unitDefId);
+unitDef-&gt;drag = sAICallback-&gt;UnitDef_getDrag(teamId, unitDefId);
+unitDef-&gt;frontToSpeed = sAICallback-&gt;UnitDef_getFrontToSpeed(teamId, unitDefId);
+unitDef-&gt;speedToFront = sAICallback-&gt;UnitDef_getSpeedToFront(teamId, unitDefId);
+unitDef-&gt;myGravity = sAICallback-&gt;UnitDef_getMyGravity(teamId, unitDefId);
+unitDef-&gt;maxBank = sAICallback-&gt;UnitDef_getMaxBank(teamId, unitDefId);
+unitDef-&gt;maxPitch = sAICallback-&gt;UnitDef_getMaxPitch(teamId, unitDefId);
+unitDef-&gt;turnRadius = sAICallback-&gt;UnitDef_getTurnRadius(teamId, unitDefId);
+unitDef-&gt;wantedHeight = sAICallback-&gt;UnitDef_getWantedHeight(teamId, unitDefId);
+unitDef-&gt;verticalSpeed = sAICallback-&gt;UnitDef_getVerticalSpeed(teamId, unitDefId);
+unitDef-&gt;canCrash = sAICallback-&gt;UnitDef_isCanCrash(teamId, unitDefId);
+unitDef-&gt;hoverAttack = sAICallback-&gt;UnitDef_isHoverAttack(teamId, unitDefId);
+unitDef-&gt;airStrafe = sAICallback-&gt;UnitDef_isAirStrafe(teamId, unitDefId);
+unitDef-&gt;dlHoverFactor = sAICallback-&gt;UnitDef_getDlHoverFactor(teamId, unitDefId);
+unitDef-&gt;maxAcc = sAICallback-&gt;UnitDef_getMaxAcceleration(teamId, unitDefId);
+unitDef-&gt;maxDec = sAICallback-&gt;UnitDef_getMaxDeceleration(teamId, unitDefId);
+unitDef-&gt;maxAileron = sAICallback-&gt;UnitDef_getMaxAileron(teamId, unitDefId);
+unitDef-&gt;maxElevator = sAICallback-&gt;UnitDef_getMaxElevator(teamId, unitDefId);
+unitDef-&gt;maxRudder = sAICallback-&gt;UnitDef_getMaxRudder(teamId, unitDefId);
+//unitDef-&gt;yardmaps = sAICallback-&gt;UnitDef_getYardMaps(teamId, unitDefId);
+unitDef-&gt;xsize = sAICallback-&gt;UnitDef_getXSize(teamId, unitDefId);
+unitDef-&gt;ysize = sAICallback-&gt;UnitDef_getYSize(teamId, unitDefId);
+unitDef-&gt;buildangle = sAICallback-&gt;UnitDef_getBuildAngle(teamId, unitDefId);
+unitDef-&gt;loadingRadius = sAICallback-&gt;UnitDef_getLoadingRadius(teamId, unitDefId);
+unitDef-&gt;unloadSpread = sAICallback-&gt;UnitDef_getUnloadSpread(teamId, unitDefId);
+unitDef-&gt;transportCapacity = sAICallback-&gt;UnitDef_getTransportCapacity(teamId, unitDefId);
+unitDef-&gt;transportSize = sAICallback-&gt;UnitDef_getTransportSize(teamId, unitDefId);
+unitDef-&gt;minTransportSize = sAICallback-&gt;UnitDef_getMinTransportSize(teamId, unitDefId);
+unitDef-&gt;isAirBase = sAICallback-&gt;UnitDef_isAirBase(teamId, unitDefId);
+unitDef-&gt;transportMass = sAICallback-&gt;UnitDef_getTransportMass(teamId, unitDefId);
+unitDef-&gt;minTransportMass = sAICallback-&gt;UnitDef_getMinTransportMass(teamId, unitDefId);
+unitDef-&gt;holdSteady = sAICallback-&gt;UnitDef_isHoldSteady(teamId, unitDefId);
+unitDef-&gt;releaseHeld = sAICallback-&gt;UnitDef_isReleaseHeld(teamId, unitDefId);
+unitDef-&gt;cantBeTransported = sAICallback-&gt;UnitDef_isCantBeTransported(teamId, unitDefId);
+unitDef-&gt;transportByEnemy = sAICallback-&gt;UnitDef_isTransportByEnemy(teamId, unitDefId);
+unitDef-&gt;transportUnloadMethod = sAICallback-&gt;UnitDef_getTransportUnloadMethod(teamId, unitDefId);
+unitDef-&gt;fallSpeed = sAICallback-&gt;UnitDef_getFallSpeed(teamId, unitDefId);
+unitDef-&gt;unitFallSpeed = sAICallback-&gt;UnitDef_getUnitFallSpeed(teamId, unitDefId);
+unitDef-&gt;canCloak = sAICallback-&gt;UnitDef_isCanCloak(teamId, unitDefId);
+unitDef-&gt;startCloaked = sAICallback-&gt;UnitDef_isStartCloaked(teamId, unitDefId);
+unitDef-&gt;cloakCost = sAICallback-&gt;UnitDef_getCloakCost(teamId, unitDefId);
+unitDef-&gt;cloakCostMoving = sAICallback-&gt;UnitDef_getCloakCostMoving(teamId, unitDefId);
+unitDef-&gt;decloakDistance = sAICallback-&gt;UnitDef_getDecloakDistance(teamId, unitDefId);
+unitDef-&gt;decloakSpherical = sAICallback-&gt;UnitDef_isDecloakSpherical(teamId, unitDefId);
+unitDef-&gt;decloakOnFire = sAICallback-&gt;UnitDef_isDecloakOnFire(teamId, unitDefId);
+unitDef-&gt;canKamikaze = sAICallback-&gt;UnitDef_isCanKamikaze(teamId, unitDefId);
+unitDef-&gt;kamikazeDist = sAICallback-&gt;UnitDef_getKamikazeDist(teamId, unitDefId);
+unitDef-&gt;targfac = sAICallback-&gt;UnitDef_isTargetingFacility(teamId, unitDefId);
+unitDef-&gt;canDGun = sAICallback-&gt;UnitDef_isCanDGun(teamId, unitDefId);
+unitDef-&gt;needGeo = sAICallback-&gt;UnitDef_isNeedGeo(teamId, unitDefId);
+unitDef-&gt;isFeature = sAICallback-&gt;UnitDef_isFeature(teamId, unitDefId);
+unitDef-&gt;hideDamage = sAICallback-&gt;UnitDef_isHideDamage(teamId, unitDefId);
+unitDef-&gt;isCommander = sAICallback-&gt;UnitDef_isCommander(teamId, unitDefId);
+unitDef-&gt;showPlayerName = sAICallback-&gt;UnitDef_isShowPlayerName(teamId, unitDefId);
+unitDef-&gt;canResurrect = sAICallback-&gt;UnitDef_isCanResurrect(teamId, unitDefId);
+unitDef-&gt;canCapture = sAICallback-&gt;UnitDef_isCanCapture(teamId, unitDefId);
+unitDef-&gt;highTrajectoryType = sAICallback-&gt;UnitDef_getHighTrajectoryType(teamId, unitDefId);
+unitDef-&gt;noChaseCategory = sAICallback-&gt;UnitDef_getNoChaseCategory(teamId, unitDefId);
+unitDef-&gt;leaveTracks = sAICallback-&gt;UnitDef_isLeaveTracks(teamId, unitDefId);
+unitDef-&gt;trackWidth = sAICallback-&gt;UnitDef_getTrackWidth(teamId, unitDefId);
+unitDef-&gt;trackOffset = sAICallback-&gt;UnitDef_getTrackOffset(teamId, unitDefId);
+unitDef-&gt;trackStrength = sAICallback-&gt;UnitDef_getTrackStrength(teamId, unitDefId);
+unitDef-&gt;trackStretch = sAICallback-&gt;UnitDef_getTrackStretch(teamId, unitDefId);
+unitDef-&gt;trackType = sAICallback-&gt;UnitDef_getTrackType(teamId, unitDefId);
+unitDef-&gt;canDropFlare = sAICallback-&gt;UnitDef_isCanDropFlare(teamId, unitDefId);
+unitDef-&gt;flareReloadTime = sAICallback-&gt;UnitDef_getFlareReloadTime(teamId, unitDefId);
+unitDef-&gt;flareEfficiency = sAICallback-&gt;UnitDef_getFlareEfficiency(teamId, unitDefId);
+unitDef-&gt;flareDelay = sAICallback-&gt;UnitDef_getFlareDelay(teamId, unitDefId);
+unitDef-&gt;flareDropVector = float3(sAICallback-&gt;UnitDef_getFlareDropVector(teamId, unitDefId));
+unitDef-&gt;flareTime = sAICallback-&gt;UnitDef_getFlareTime(teamId, unitDefId);
+unitDef-&gt;flareSalvoSize = sAICallback-&gt;UnitDef_getFlareSalvoSize(teamId, unitDefId);
+unitDef-&gt;flareSalvoDelay = sAICallback-&gt;UnitDef_getFlareSalvoDelay(teamId, unitDefId);
+unitDef-&gt;smoothAnim = sAICallback-&gt;UnitDef_isSmoothAnim(teamId, unitDefId);
+unitDef-&gt;isMetalMaker = sAICallback-&gt;UnitDef_isMetalMaker(teamId, unitDefId);
+unitDef-&gt;canLoopbackAttack = sAICallback-&gt;UnitDef_isCanLoopbackAttack(teamId, unitDefId);
+unitDef-&gt;levelGround = sAICallback-&gt;UnitDef_isLevelGround(teamId, unitDefId);
+unitDef-&gt;useBuildingGroundDecal = sAICallback-&gt;UnitDef_isUseBuildingGroundDecal(teamId, unitDefId);
+unitDef-&gt;buildingDecalType = sAICallback-&gt;UnitDef_getBuildingDecalType(teamId, unitDefId);
+unitDef-&gt;buildingDecalSizeX = sAICallback-&gt;UnitDef_getBuildingDecalSizeX(teamId, unitDefId);
+unitDef-&gt;buildingDecalSizeY = sAICallback-&gt;UnitDef_getBuildingDecalSizeY(teamId, unitDefId);
+unitDef-&gt;buildingDecalDecaySpeed = sAICallback-&gt;UnitDef_getBuildingDecalDecaySpeed(teamId, unitDefId);
+unitDef-&gt;isFirePlatform = sAICallback-&gt;UnitDef_isFirePlatform(teamId, unitDefId);
+unitDef-&gt;maxFuel = sAICallback-&gt;UnitDef_getMaxFuel(teamId, unitDefId);
+unitDef-&gt;refuelTime = sAICallback-&gt;UnitDef_getRefuelTime(teamId, unitDefId);
+unitDef-&gt;minAirBasePower = sAICallback-&gt;UnitDef_getMinAirBasePower(teamId, unitDefId);
+unitDef-&gt;maxThisUnit = sAICallback-&gt;UnitDef_getMaxThisUnit(teamId, unitDefId);
+//unitDef-&gt;decoyDef = sAICallback-&gt;UnitDef_getDecoyDefId(teamId, unitDefId);
+unitDef-&gt;shieldWeaponDef = this-&gt;GetWeaponDefById(sAICallback-&gt;UnitDef_getShieldWeaponDefId(teamId, unitDefId));
+unitDef-&gt;stockpileWeaponDef = this-&gt;GetWeaponDefById(sAICallback-&gt;UnitDef_getStockpileWeaponDefId(teamId, unitDefId));
+{
+	int numBo = sAICallback-&gt;UnitDef_getNumBuildOptions(teamId, unitDefId);
+	int* bo = new int[numBo];
+	sAICallback-&gt;UnitDef_getBuildOptions(teamId, unitDefId, bo);
+	for (int b=0; b &lt; numBo; b++) {
+		unitDef-&gt;buildOptions[b] = sAICallback-&gt;UnitDef_getName(teamId, bo[b]);
+	}
+	delete [] bo;
+}
+{
+	int size = sAICallback-&gt;UnitDef_getNumCustomParams(teamId, unitDefId);
+	const char* cMap[size][2];
+	sAICallback-&gt;UnitDef_getCustomParams(teamId, unitDefId, cMap);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+		unitDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+	}
+}
+if (sAICallback-&gt;UnitDef_hasMoveData(teamId, unitDefId)) {
+	unitDef-&gt;movedata = new MoveData(NULL, -1);
+		unitDef-&gt;movedata-&gt;moveType = (enum MoveData::MoveType)sAICallback-&gt;UnitDef_MoveData_getMoveType(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;moveFamily = (enum MoveData::MoveFamily) sAICallback-&gt;UnitDef_MoveData_getMoveFamily(teamId, unitDefId);
+        unitDef-&gt;movedata-&gt;size = sAICallback-&gt;UnitDef_MoveData_getSize(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;depth = sAICallback-&gt;UnitDef_MoveData_getDepth(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxSlope = sAICallback-&gt;UnitDef_MoveData_getMaxSlope(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;slopeMod = sAICallback-&gt;UnitDef_MoveData_getSlopeMod(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;depthMod = sAICallback-&gt;UnitDef_MoveData_getDepthMod(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;pathType = sAICallback-&gt;UnitDef_MoveData_getPathType(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;crushStrength = sAICallback-&gt;UnitDef_MoveData_getCrushStrength(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxSpeed = sAICallback-&gt;UnitDef_MoveData_getMaxSpeed(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxTurnRate = sAICallback-&gt;UnitDef_MoveData_getMaxTurnRate(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxAcceleration = sAICallback-&gt;UnitDef_MoveData_getMaxAcceleration(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxBreaking = sAICallback-&gt;UnitDef_MoveData_getMaxBreaking(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;subMarine = sAICallback-&gt;UnitDef_MoveData_isSubMarine(teamId, unitDefId);
+	} else {
+		unitDef-&gt;movedata = NULL;
+	}
+int numWeapons = sAICallback-&gt;UnitDef_getNumUnitDefWeapons(teamId, unitDefId);
+for (int w=0; w &lt; numWeapons; ++w) {
+	unitDef-&gt;weapons.push_back(UnitDef::UnitDefWeapon());
+	unitDef-&gt;weapons[w].name = sAICallback-&gt;UnitDef_UnitDefWeapon_getName(teamId, unitDefId, w);
+	int weaponDefId = sAICallback-&gt;UnitDef_UnitDefWeapon_getWeaponDefId(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].def = this-&gt;GetWeaponDefById(weaponDefId);
+	unitDef-&gt;weapons[w].slavedTo = sAICallback-&gt;UnitDef_UnitDefWeapon_getSlavedTo(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].mainDir = float3(sAICallback-&gt;UnitDef_UnitDefWeapon_getMainDir(teamId, unitDefId, w));
+	unitDef-&gt;weapons[w].maxAngleDif = sAICallback-&gt;UnitDef_UnitDefWeapon_getMaxAngleDif(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].fuelUsage = sAICallback-&gt;UnitDef_UnitDefWeapon_getFuelUsage(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].badTargetCat = sAICallback-&gt;UnitDef_UnitDefWeapon_getBadTargetCat(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].onlyTargetCat = sAICallback-&gt;UnitDef_UnitDefWeapon_getOnlyTargetCat(teamId, unitDefId, w);
+}
+	if (unitDefs[unitDefId] != NULL) {
+		delete unitDefs[unitDefId];
+	}
+		unitDefs[unitDefId] = unitDef;
+		unitDefFrames[unitDefId] = currentFrame;
+	}
+
+	return unitDefs[unitDefId];
+}
+
+int CAIAICallback::GetEnemyUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getEnemies(teamId, unitIds);
+}
+
+int CAIAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getEnemiesIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getEnemiesInRadarAndLos(teamId, unitIds);
+}
+
+int CAIAICallback::GetFriendlyUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getFriendlies(teamId, unitIds);
+}
+
+int CAIAICallback::GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getFriendliesIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetNeutralUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getNeutrals(teamId, unitIds);
+}
+
+int CAIAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getNeutralsIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetMapWidth() {
+	return sAICallback-&gt;Map_getWidth(teamId);
+}
+
+int CAIAICallback::GetMapHeight() {
+	return sAICallback-&gt;Map_getHeight(teamId);
+}
+
+const float* CAIAICallback::GetHeightMap() {
+	return sAICallback-&gt;Map_getHeightMap(teamId);
+}
+
+float CAIAICallback::GetMinHeight() {
+	return sAICallback-&gt;Map_getMinHeight(teamId);
+}
+
+float CAIAICallback::GetMaxHeight() {
+	return sAICallback-&gt;Map_getMaxHeight(teamId);
+}
+
+const float* CAIAICallback::GetSlopeMap() {
+	return sAICallback-&gt;Map_getSlopeMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetLosMap() {
+	return sAICallback-&gt;Map_getLosMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetRadarMap() {
+	return sAICallback-&gt;Map_getRadarMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetJammerMap() {
+	return sAICallback-&gt;Map_getJammerMap(teamId);
+}
+
+const unsigned char* CAIAICallback::GetMetalMap() {
+	return sAICallback-&gt;Map_getMetalMap(teamId);
+}
+
+const char* CAIAICallback::GetMapName() {
+	return sAICallback-&gt;Map_getName(teamId);
+}
+
+const char* CAIAICallback::GetModName() {
+	return sAICallback-&gt;Mod_getName(teamId);
+}
+
+float CAIAICallback::GetElevation(float x, float z) {
+	return sAICallback-&gt;Map_getElevationAt(teamId, x, z);
+}
+
+float CAIAICallback::GetMaxMetal() {
+	return sAICallback-&gt;Map_getMaxMetal(teamId);
+}
+
+float CAIAICallback::GetExtractorRadius() {
+	return sAICallback-&gt;Map_getExtractorRadius(teamId);
+}
+
+float CAIAICallback::GetMinWind() {
+	return sAICallback-&gt;Map_getMinWind(teamId);
+}
+
+float CAIAICallback::GetMaxWind() {
+	return sAICallback-&gt;Map_getMaxWind(teamId);
+}
+
+float CAIAICallback::GetTidalStrength() {
+	return sAICallback-&gt;Map_getTidalStrength(teamId);
+}
+
+float CAIAICallback::GetGravity() {
+	return sAICallback-&gt;Map_getGravity(teamId);
+}
+
+bool CAIAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing) {
+	return sAICallback-&gt;Map_canBuildAt(teamId, unitDef-&gt;id, pos.toSAIFloat3(), facing);
+}
+
+float3 CAIAICallback::ClosestBuildSite(const UnitDef* unitDef, float3 pos, float searchRadius, int minDist, int facing) {
+	return float3(sAICallback-&gt;Map_findClosestBuildSite(teamId, unitDef-&gt;id, pos.toSAIFloat3(), searchRadius, minDist, facing));
+}
+
+/*
+bool CAIAICallback::GetProperty(int id, int property, void* dst) {
+//	return sAICallback-&gt;getProperty(teamId, id, property, dst);
+	return false;
+}
+*/
+bool CAIAICallback::GetProperty(int unitId, int propertyId, void *data)
+{
+    switch (propertyId) {
+        case AIVAL_UNITDEF: {
+            return false;
+        }
+        case AIVAL_CURRENT_FUEL: {
+            (*(float*)data) = sAICallback-&gt;Unit_getCurrentFuel(teamId, unitId);
+            return (*(float*)data) != -1.0f;
+        }
+        case AIVAL_STOCKPILED: {
+            (*(int*)data) = sAICallback-&gt;Unit_getStockpile(teamId, unitId);
+            return (*(int*)data) != -1;
+        }
+        case AIVAL_STOCKPILE_QUED: {
+            (*(int*)data) = sAICallback-&gt;Unit_getStockpileQueued(teamId, unitId);
+            return (*(int*)data) != -1;
+        }
+        case AIVAL_UNIT_MAXSPEED: {
+            (*(float*) data) = sAICallback-&gt;Unit_getMaxSpeed(teamId, unitId);
+            return (*(float*)data) != -1.0f;
+        }
+        default:
+            return false;
+	}
+	return false;
+}
+
+/*
+bool CAIAICallback::GetValue(int valueId, void* dst) {
+//	return sAICallback-&gt;getValue(teamId, valueId, dst);
+	return false;
+}
+*/
+bool CAIAICallback::GetValue(int valueId, void *data)
+{
+	switch (valueId) {
+		case AIVAL_NUMDAMAGETYPES:{
+			*((int*)data) = sAICallback-&gt;WeaponDef_STATIC_getNumDamageTypes(teamId);
+			return true;
+		}case AIVAL_EXCEPTION_HANDLING:{
+			*(bool*)data = sAICallback-&gt;Game_isExceptionHandlingEnabled(teamId);
+			return true;
+		}case AIVAL_MAP_CHECKSUM:{
+			*(unsigned int*)data = sAICallback-&gt;Map_getChecksum(teamId);
+			return true;
+		}case AIVAL_DEBUG_MODE:{
+			*(bool*)data = sAICallback-&gt;Game_isDebugModeEnabled(teamId);
+			return true;
+		}case AIVAL_GAME_MODE:{
+			*(int*)data = sAICallback-&gt;Game_getMode(teamId);
+			return true;
+		}case AIVAL_GAME_PAUSED:{
+			*(bool*)data = sAICallback-&gt;Game_isPaused(teamId);
+			return true;
+		}case AIVAL_GAME_SPEED_FACTOR:{
+			*(float*)data = sAICallback-&gt;Game_getSpeedFactor(teamId);
+			return true;
+		}case AIVAL_GUI_VIEW_RANGE:{
+			*(float*)data = sAICallback-&gt;Gui_getViewRange(teamId);
+			return true;
+		}case AIVAL_GUI_SCREENX:{
+			*(float*)data = sAICallback-&gt;Gui_getScreenX(teamId);
+			return true;
+		}case AIVAL_GUI_SCREENY:{
+			*(float*)data = sAICallback-&gt;Gui_getScreenY(teamId);
+			return true;
+		}case AIVAL_GUI_CAMERA_DIR:{
+			*(float3*)data = sAICallback-&gt;Gui_Camera_getDirection(teamId);
+			return true;
+		}case AIVAL_GUI_CAMERA_POS:{
+			*(float3*)data = sAICallback-&gt;Gui_Camera_getPosition(teamId);
+			return true;
+		}case AIVAL_LOCATE_FILE_R:{
+            sAICallback-&gt;File_locateForReading(teamId, (char*) data);
+			return true;
+		}case AIVAL_LOCATE_FILE_W:{
+            sAICallback-&gt;File_locateForWriting(teamId, (char*) data);
+			return true;
+		}
+		case AIVAL_UNIT_LIMIT: {
+			*(int*) data = sAICallback-&gt;Unit_STATIC_getLimit(teamId);
+			return true;
+		}
+		case AIVAL_SCRIPT: {
+			*(const char**) data = sAICallback-&gt;Game_getSetupScript(teamId);
+			return true;
+		}
+		default:
+			return false;
+	}
+}
+
+int CAIAICallback::GetFileSize(const char* name) {
+	return sAICallback-&gt;File_getSize(teamId, name);
+}
+
+int CAIAICallback::GetSelectedUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getSelected(teamId, unitIds);
+}
+
+float3 CAIAICallback::GetMousePos() {
+	return float3(sAICallback-&gt;Map_getMousePos(teamId));
+}
+
+int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
+	SAIFloat3* positions = new SAIFloat3[maxPoints];
+	unsigned char** colors = new unsigned char*[maxPoints];
+	const char** labels = new const char*[maxPoints];
+	int numPoints = sAICallback-&gt;Map_getPoints(teamId, positions, colors, labels, maxPoints);
+	for (int i=0; i &lt; numPoints; ++i) {
+		pm[i].pos = float3(positions[i]);
+		pm[i].color = colors[i];
+		pm[i].label = labels[i];
+	}
+	delete [] positions;
+	delete [] colors;
+	delete [] labels;
+	return numPoints;
+}
+
+int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
+	SAIFloat3* firstPositions = new SAIFloat3[maxLines];
+	SAIFloat3* secondPositions = new SAIFloat3[maxLines];
+	unsigned char** colors = new unsigned char*[maxLines];
+	int numLines = sAICallback-&gt;Map_getLines(teamId, firstPositions, secondPositions, colors, maxLines);
+	for (int i=0; i &lt; numLines; ++i) {
+		lm[i].pos = float3(firstPositions[i]);
+		lm[i].pos2 = float3(secondPositions[i]);
+		lm[i].color = colors[i];
+	}
+	delete [] firstPositions;
+	delete [] secondPositions;
+	delete [] colors;
+	return numLines;
+}
+
+float CAIAICallback::GetMetal() {
+	return sAICallback-&gt;ResourceInfo_Metal_getCurrent(teamId);
+}
+
+float CAIAICallback::GetMetalIncome() {
+	return sAICallback-&gt;ResourceInfo_Metal_getIncome(teamId);
+}
+
+float CAIAICallback::GetMetalUsage() {
+	return sAICallback-&gt;ResourceInfo_Metal_getUsage(teamId);
+}
+
+float CAIAICallback::GetMetalStorage() {
+	return sAICallback-&gt;ResourceInfo_Metal_getStorage(teamId);
+}
+
+float CAIAICallback::GetEnergy() {
+	return sAICallback-&gt;ResourceInfo_Energy_getCurrent(teamId);
+}
+
+float CAIAICallback::GetEnergyIncome() {
+	return sAICallback-&gt;ResourceInfo_Energy_getIncome(teamId);
+}
+
+float CAIAICallback::GetEnergyUsage() {
+	return sAICallback-&gt;ResourceInfo_Energy_getUsage(teamId);
+}
+
+float CAIAICallback::GetEnergyStorage() {
+	return sAICallback-&gt;ResourceInfo_Energy_getStorage(teamId);
+}
+
+int CAIAICallback::GetFeatures(int *featureIds, int max) {
+	return sAICallback-&gt;Feature_STATIC_getIds(teamId, featureIds, max);
+}
+
+int CAIAICallback::GetFeatures(int *featureIds, int max, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Feature_STATIC_getIdsIn(teamId, featureIds, max, pos.toSAIFloat3(), radius);
+}
+
+const FeatureDef* CAIAICallback::GetFeatureDef(int featureId) {
+	int featureDefId = sAICallback-&gt;Feature_getDefId(teamId, featureId);
+	return this-&gt;GetFeatureDefById(featureDefId);
+}
+
+const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
+	
+	bool doRecreate = featureDefFrames[featureDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+	FeatureDef* featureDef = new FeatureDef();
+featureDef-&gt;myName = sAICallback-&gt;FeatureDef_getName(teamId, featureDefId);
+featureDef-&gt;description = sAICallback-&gt;FeatureDef_getDescription(teamId, featureDefId);
+featureDef-&gt;filename = sAICallback-&gt;FeatureDef_getFilename(teamId, featureDefId);
+featureDef-&gt;id = sAICallback-&gt;FeatureDef_getId(teamId, featureDefId);
+featureDef-&gt;metal = sAICallback-&gt;FeatureDef_getMetal(teamId, featureDefId);
+featureDef-&gt;energy = sAICallback-&gt;FeatureDef_getEnergy(teamId, featureDefId);
+featureDef-&gt;maxHealth = sAICallback-&gt;FeatureDef_getMaxHealth(teamId, featureDefId);
+featureDef-&gt;reclaimTime = sAICallback-&gt;FeatureDef_getReclaimTime(teamId, featureDefId);
+featureDef-&gt;mass = sAICallback-&gt;FeatureDef_getMass(teamId, featureDefId);
+featureDef-&gt;collisionVolumeType = sAICallback-&gt;FeatureDef_getCollisionVolumeType(teamId, featureDefId);	
+featureDef-&gt;collisionVolumeScales = float3(sAICallback-&gt;FeatureDef_getCollisionVolumeScales(teamId, featureDefId));		
+featureDef-&gt;collisionVolumeOffsets = float3(sAICallback-&gt;FeatureDef_getCollisionVolumeOffsets(teamId, featureDefId));		
+featureDef-&gt;collisionVolumeTest = sAICallback-&gt;FeatureDef_getCollisionVolumeTest(teamId, featureDefId);			
+featureDef-&gt;upright = sAICallback-&gt;FeatureDef_isUpright(teamId, featureDefId);
+featureDef-&gt;drawType = sAICallback-&gt;FeatureDef_getDrawType(teamId, featureDefId);
+featureDef-&gt;modelname = sAICallback-&gt;FeatureDef_getModelName(teamId, featureDefId);
+featureDef-&gt;modelType = sAICallback-&gt;FeatureDef_getModelType(teamId, featureDefId);
+featureDef-&gt;destructable = sAICallback-&gt;FeatureDef_isDestructable(teamId, featureDefId);
+featureDef-&gt;reclaimable = sAICallback-&gt;FeatureDef_isReclaimable(teamId, featureDefId);
+featureDef-&gt;blocking = sAICallback-&gt;FeatureDef_isBlocking(teamId, featureDefId);
+featureDef-&gt;burnable = sAICallback-&gt;FeatureDef_isBurnable(teamId, featureDefId);
+featureDef-&gt;floating = sAICallback-&gt;FeatureDef_isFloating(teamId, featureDefId);
+featureDef-&gt;noSelect = sAICallback-&gt;FeatureDef_isNoSelect(teamId, featureDefId);
+featureDef-&gt;geoThermal = sAICallback-&gt;FeatureDef_isGeoThermal(teamId, featureDefId);
+featureDef-&gt;deathFeature = sAICallback-&gt;FeatureDef_getDeathFeature(teamId, featureDefId);
+featureDef-&gt;xsize = sAICallback-&gt;FeatureDef_getXsize(teamId, featureDefId);
+featureDef-&gt;ysize = sAICallback-&gt;FeatureDef_getYsize(teamId, featureDefId);
+{
+	int size = sAICallback-&gt;FeatureDef_getNumCustomParams(teamId, featureDefId);
+	featureDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+	const char* cMap[size][2];
+	sAICallback-&gt;FeatureDef_getCustomParams(teamId, featureDefId, cMap);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+		featureDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+	}
+}
+	if (featureDefs[featureDefId] != NULL) {
+		delete featureDefs[featureDefId];
+	}
+		featureDefs[featureDefId] = featureDef;
+		featureDefFrames[featureDefId] = currentFrame;
+	}
+
+	return featureDefs[featureDefId];
+}
+
+float CAIAICallback::GetFeatureHealth(int featureId) {
+	return sAICallback-&gt;Feature_getHealth(teamId, featureId);
+}
+
+float CAIAICallback::GetFeatureReclaimLeft(int featureId) {
+	return sAICallback-&gt;Feature_getReclaimLeft(teamId, featureId);
+}
+
+float3 CAIAICallback::GetFeaturePos(int featureId) {
+	return float3(sAICallback-&gt;Feature_getPos(teamId, featureId));
+}
+
+int CAIAICallback::GetNumUnitDefs() {
+	return sAICallback-&gt;UnitDef_STATIC_getNumIds(teamId);
+}
+
+void CAIAICallback::GetUnitDefList(const UnitDef** list) {
+	int numUnitDefs = sAICallback-&gt;UnitDef_STATIC_getNumIds(teamId);
+	int* unitDefIds = new int[numUnitDefs];
+	sAICallback-&gt;UnitDef_STATIC_getIds(teamId, unitDefIds);
+	for (int i=0; i &lt; numUnitDefs; ++i) {
+		list[i] = this-&gt;GetUnitDefById(unitDefIds[i]);
+	}
+}
+
+float CAIAICallback::GetUnitDefHeight(int def) {
+	return sAICallback-&gt;UnitDef_getHeight(teamId, def);
+}
+
+float CAIAICallback::GetUnitDefRadius(int def) {
+	return sAICallback-&gt;UnitDef_getRadius(teamId, def);
+}
+
+const WeaponDef* CAIAICallback::GetWeapon(const char* weaponName) {
+	int weaponDefId = sAICallback-&gt;WeaponDef_STATIC_getIdByName(teamId, weaponName);
+	return this-&gt;GetWeaponDefById(weaponDefId);
+}
+
+const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
+	
+//	logT(&quot;entering: GetWeaponDefById sAICallback&quot;);
+	if (weaponDefId &lt; 0) {
+		return NULL;
+	}
+	
+	bool doRecreate = weaponDefFrames[weaponDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+//weaponDef-&gt;damages = sAICallback-&gt;WeaponDef_getDamages(teamId, weaponDefId);
+//{
+int numTypes = sAICallback-&gt;WeaponDef_Damages_getNumTypes(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 1&quot;);
+//float* typeDamages = new float[numTypes];
+float typeDamages[numTypes];
+sAICallback-&gt;WeaponDef_Damages_getTypeDamages(teamId, weaponDefId, typeDamages);
+//	logT(&quot;GetWeaponDefById 2&quot;);
+//for(int i=0; i &lt; numTypes; ++i) {
+//	typeDamages[i] = sAICallback-&gt;WeaponDef_Damages_getType(teamId, weaponDefId, i);
+//}
+DamageArray da(numTypes, typeDamages);
+//	logT(&quot;GetWeaponDefById 3&quot;);
+//AIDamageArray tmpDa(numTypes, typeDamages);
+//AIDamageArray tmpDa;
+//weaponDef-&gt;damages = *(reinterpret_cast&lt;DamageArray*&gt;(&amp;tmpDa));
+//tmpDa.numTypes = numTypes;
+//tmpDa.damages = typeDamages;
+//delete tmpDa;
+//da.SetTypes(numTypes, typeDamages);
+//delete [] typeDamages;
+da.paralyzeDamageTime = sAICallback-&gt;WeaponDef_Damages_getParalyzeDamageTime(teamId, weaponDefId);
+da.impulseFactor = sAICallback-&gt;WeaponDef_Damages_getImpulseFactor(teamId, weaponDefId);
+da.impulseBoost = sAICallback-&gt;WeaponDef_Damages_getImpulseBoost(teamId, weaponDefId);
+da.craterMult = sAICallback-&gt;WeaponDef_Damages_getCraterMult(teamId, weaponDefId);
+da.craterBoost = sAICallback-&gt;WeaponDef_Damages_getCraterBoost(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 4&quot;);
+//}
+
+	WeaponDef* weaponDef = new WeaponDef(da);
+//	WeaponDef* weaponDef = new WeaponDef();
+//	logT(&quot;GetWeaponDefById 5&quot;);
+//	logI(&quot;GetWeaponDefById 5 defId: %d&quot;, weaponDefId);
+weaponDef-&gt;name = sAICallback-&gt;WeaponDef_getName(teamId, weaponDefId);
+weaponDef-&gt;type = sAICallback-&gt;WeaponDef_getType(teamId, weaponDefId);
+weaponDef-&gt;description = sAICallback-&gt;WeaponDef_getDescription(teamId, weaponDefId);
+weaponDef-&gt;filename = sAICallback-&gt;WeaponDef_getFilename(teamId, weaponDefId);
+weaponDef-&gt;cegTag = sAICallback-&gt;WeaponDef_getCegTag(teamId, weaponDefId);
+weaponDef-&gt;range = sAICallback-&gt;WeaponDef_getRange(teamId, weaponDefId);
+weaponDef-&gt;heightmod = sAICallback-&gt;WeaponDef_getHeightMod(teamId, weaponDefId);
+weaponDef-&gt;accuracy = sAICallback-&gt;WeaponDef_getAccuracy(teamId, weaponDefId);
+weaponDef-&gt;sprayAngle = sAICallback-&gt;WeaponDef_getSprayAngle(teamId, weaponDefId);
+weaponDef-&gt;movingAccuracy = sAICallback-&gt;WeaponDef_getMovingAccuracy(teamId, weaponDefId);
+weaponDef-&gt;targetMoveError = sAICallback-&gt;WeaponDef_getTargetMoveError(teamId, weaponDefId);
+weaponDef-&gt;leadLimit = sAICallback-&gt;WeaponDef_getLeadLimit(teamId, weaponDefId);
+weaponDef-&gt;leadBonus = sAICallback-&gt;WeaponDef_getLeadBonus(teamId, weaponDefId);
+weaponDef-&gt;predictBoost = sAICallback-&gt;WeaponDef_getPredictBoost(teamId, weaponDefId);
+weaponDef-&gt;areaOfEffect = sAICallback-&gt;WeaponDef_getAreaOfEffect(teamId, weaponDefId);
+weaponDef-&gt;noSelfDamage = sAICallback-&gt;WeaponDef_isNoSelfDamage(teamId, weaponDefId);
+weaponDef-&gt;fireStarter = sAICallback-&gt;WeaponDef_getFireStarter(teamId, weaponDefId);
+weaponDef-&gt;edgeEffectiveness = sAICallback-&gt;WeaponDef_getEdgeEffectiveness(teamId, weaponDefId);
+weaponDef-&gt;size = sAICallback-&gt;WeaponDef_getSize(teamId, weaponDefId);
+weaponDef-&gt;sizeGrowth = sAICallback-&gt;WeaponDef_getSizeGrowth(teamId, weaponDefId);
+weaponDef-&gt;collisionSize = sAICallback-&gt;WeaponDef_getCollisionSize(teamId, weaponDefId);
+weaponDef-&gt;salvosize = sAICallback-&gt;WeaponDef_getSalvoSize(teamId, weaponDefId);
+weaponDef-&gt;salvodelay = sAICallback-&gt;WeaponDef_getSalvoDelay(teamId, weaponDefId);
+weaponDef-&gt;reload = sAICallback-&gt;WeaponDef_getReload(teamId, weaponDefId);
+weaponDef-&gt;beamtime = sAICallback-&gt;WeaponDef_getBeamTime(teamId, weaponDefId);
+weaponDef-&gt;beamburst = sAICallback-&gt;WeaponDef_isBeamBurst(teamId, weaponDefId);
+weaponDef-&gt;waterBounce = sAICallback-&gt;WeaponDef_isWaterBounce(teamId, weaponDefId);
+weaponDef-&gt;groundBounce = sAICallback-&gt;WeaponDef_isGroundBounce(teamId, weaponDefId);
+weaponDef-&gt;bounceRebound = sAICallback-&gt;WeaponDef_getBounceRebound(teamId, weaponDefId);
+weaponDef-&gt;bounceSlip = sAICallback-&gt;WeaponDef_getBounceSlip(teamId, weaponDefId);
+weaponDef-&gt;numBounce = sAICallback-&gt;WeaponDef_getNumBounce(teamId, weaponDefId);
+weaponDef-&gt;maxAngle = sAICallback-&gt;WeaponDef_getMaxAngle(teamId, weaponDefId);
+weaponDef-&gt;restTime = sAICallback-&gt;WeaponDef_getRestTime(teamId, weaponDefId);
+weaponDef-&gt;uptime = sAICallback-&gt;WeaponDef_getUpTime(teamId, weaponDefId);
+weaponDef-&gt;flighttime = sAICallback-&gt;WeaponDef_getFlightTime(teamId, weaponDefId);
+weaponDef-&gt;metalcost = sAICallback-&gt;WeaponDef_getMetalCost(teamId, weaponDefId);
+weaponDef-&gt;energycost = sAICallback-&gt;WeaponDef_getEnergyCost(teamId, weaponDefId);
+weaponDef-&gt;supplycost = sAICallback-&gt;WeaponDef_getSupplyCost(teamId, weaponDefId);
+weaponDef-&gt;projectilespershot = sAICallback-&gt;WeaponDef_getProjectilesPerShot(teamId, weaponDefId);
+weaponDef-&gt;id = sAICallback-&gt;WeaponDef_getId(teamId, weaponDefId);
+weaponDef-&gt;tdfId = sAICallback-&gt;WeaponDef_getTdfId(teamId, weaponDefId);
+weaponDef-&gt;turret = sAICallback-&gt;WeaponDef_isTurret(teamId, weaponDefId);
+weaponDef-&gt;onlyForward = sAICallback-&gt;WeaponDef_isOnlyForward(teamId, weaponDefId);
+weaponDef-&gt;fixedLauncher = sAICallback-&gt;WeaponDef_isFixedLauncher(teamId, weaponDefId);
+weaponDef-&gt;waterweapon = sAICallback-&gt;WeaponDef_isWaterWeapon(teamId, weaponDefId);
+weaponDef-&gt;fireSubmersed = sAICallback-&gt;WeaponDef_isFireSubmersed(teamId, weaponDefId);
+weaponDef-&gt;submissile = sAICallback-&gt;WeaponDef_isSubMissile(teamId, weaponDefId);
+weaponDef-&gt;tracks = sAICallback-&gt;WeaponDef_isTracks(teamId, weaponDefId);
+weaponDef-&gt;dropped = sAICallback-&gt;WeaponDef_isDropped(teamId, weaponDefId);
+weaponDef-&gt;paralyzer = sAICallback-&gt;WeaponDef_isParalyzer(teamId, weaponDefId);
+weaponDef-&gt;impactOnly = sAICallback-&gt;WeaponDef_isImpactOnly(teamId, weaponDefId);
+weaponDef-&gt;noAutoTarget = sAICallback-&gt;WeaponDef_isNoAutoTarget(teamId, weaponDefId);
+weaponDef-&gt;manualfire = sAICallback-&gt;WeaponDef_isManualFire(teamId, weaponDefId);
+weaponDef-&gt;interceptor = sAICallback-&gt;WeaponDef_getInterceptor(teamId, weaponDefId);
+weaponDef-&gt;targetable = sAICallback-&gt;WeaponDef_getTargetable(teamId, weaponDefId);
+weaponDef-&gt;stockpile = sAICallback-&gt;WeaponDef_isStockpileable(teamId, weaponDefId);
+weaponDef-&gt;coverageRange = sAICallback-&gt;WeaponDef_getCoverageRange(teamId, weaponDefId);
+weaponDef-&gt;intensity = sAICallback-&gt;WeaponDef_getIntensity(teamId, weaponDefId);
+weaponDef-&gt;thickness = sAICallback-&gt;WeaponDef_getThickness(teamId, weaponDefId);
+weaponDef-&gt;laserflaresize = sAICallback-&gt;WeaponDef_getLaserFlareSize(teamId, weaponDefId);
+weaponDef-&gt;corethickness = sAICallback-&gt;WeaponDef_getCoreThickness(teamId, weaponDefId);
+weaponDef-&gt;duration = sAICallback-&gt;WeaponDef_getDuration(teamId, weaponDefId);
+weaponDef-&gt;lodDistance = sAICallback-&gt;WeaponDef_getLodDistance(teamId, weaponDefId);
+weaponDef-&gt;falloffRate = sAICallback-&gt;WeaponDef_getFalloffRate(teamId, weaponDefId);
+weaponDef-&gt;graphicsType = sAICallback-&gt;WeaponDef_getGraphicsType(teamId, weaponDefId);
+weaponDef-&gt;soundTrigger = sAICallback-&gt;WeaponDef_isSoundTrigger(teamId, weaponDefId);
+weaponDef-&gt;selfExplode = sAICallback-&gt;WeaponDef_isSelfExplode(teamId, weaponDefId);
+weaponDef-&gt;gravityAffected = sAICallback-&gt;WeaponDef_isGravityAffected(teamId, weaponDefId);
+weaponDef-&gt;highTrajectory = sAICallback-&gt;WeaponDef_getHighTrajectory(teamId, weaponDefId);
+weaponDef-&gt;myGravity = sAICallback-&gt;WeaponDef_getMyGravity(teamId, weaponDefId);
+weaponDef-&gt;twophase = sAICallback-&gt;WeaponDef_isTwoPhase(teamId, weaponDefId);
+weaponDef-&gt;guided = sAICallback-&gt;WeaponDef_isGuided(teamId, weaponDefId);
+weaponDef-&gt;vlaunch = sAICallback-&gt;WeaponDef_isVLaunched(teamId, weaponDefId);
+weaponDef-&gt;selfprop = sAICallback-&gt;WeaponDef_isSelfPropelled(teamId, weaponDefId);
+weaponDef-&gt;noExplode = sAICallback-&gt;WeaponDef_isNoExplode(teamId, weaponDefId);
+weaponDef-&gt;startvelocity = sAICallback-&gt;WeaponDef_getStartVelocity(teamId, weaponDefId);
+weaponDef-&gt;weaponacceleration = sAICallback-&gt;WeaponDef_getWeaponAcceleration(teamId, weaponDefId);
+weaponDef-&gt;turnrate = sAICallback-&gt;WeaponDef_getTurnRate(teamId, weaponDefId);
+weaponDef-&gt;maxvelocity = sAICallback-&gt;WeaponDef_getMaxVelocity(teamId, weaponDefId);
+weaponDef-&gt;projectilespeed = sAICallback-&gt;WeaponDef_getProjectileSpeed(teamId, weaponDefId);
+weaponDef-&gt;explosionSpeed = sAICallback-&gt;WeaponDef_getExplosionSpeed(teamId, weaponDefId);
+weaponDef-&gt;onlyTargetCategory = sAICallback-&gt;WeaponDef_getOnlyTargetCategory(teamId, weaponDefId);
+weaponDef-&gt;wobble = sAICallback-&gt;WeaponDef_getWobble(teamId, weaponDefId);
+weaponDef-&gt;dance = sAICallback-&gt;WeaponDef_getDance(teamId, weaponDefId);
+weaponDef-&gt;trajectoryHeight = sAICallback-&gt;WeaponDef_getTrajectoryHeight(teamId, weaponDefId);
+weaponDef-&gt;largeBeamLaser = sAICallback-&gt;WeaponDef_isLargeBeamLaser(teamId, weaponDefId);
+weaponDef-&gt;isShield = sAICallback-&gt;WeaponDef_isShield(teamId, weaponDefId);
+weaponDef-&gt;shieldRepulser = sAICallback-&gt;WeaponDef_isShieldRepulser(teamId, weaponDefId);
+weaponDef-&gt;smartShield = sAICallback-&gt;WeaponDef_isSmartShield(teamId, weaponDefId);
+weaponDef-&gt;exteriorShield = sAICallback-&gt;WeaponDef_isExteriorShield(teamId, weaponDefId);
+weaponDef-&gt;visibleShield = sAICallback-&gt;WeaponDef_isVisibleShield(teamId, weaponDefId);
+weaponDef-&gt;visibleShieldRepulse = sAICallback-&gt;WeaponDef_isVisibleShieldRepulse(teamId, weaponDefId);
+weaponDef-&gt;visibleShieldHitFrames = sAICallback-&gt;WeaponDef_getVisibleShieldHitFrames(teamId, weaponDefId);
+weaponDef-&gt;shieldEnergyUse = sAICallback-&gt;WeaponDef_getShieldEnergyUse(teamId, weaponDefId);
+weaponDef-&gt;shieldRadius = sAICallback-&gt;WeaponDef_getShieldRadius(teamId, weaponDefId);
+weaponDef-&gt;shieldForce = sAICallback-&gt;WeaponDef_getShieldForce(teamId, weaponDefId);
+weaponDef-&gt;shieldMaxSpeed = sAICallback-&gt;WeaponDef_getShieldMaxSpeed(teamId, weaponDefId);
+weaponDef-&gt;shieldPower = sAICallback-&gt;WeaponDef_getShieldPower(teamId, weaponDefId);
+weaponDef-&gt;shieldPowerRegen = sAICallback-&gt;WeaponDef_getShieldPowerRegen(teamId, weaponDefId);
+weaponDef-&gt;shieldPowerRegenEnergy = sAICallback-&gt;WeaponDef_getShieldPowerRegenEnergy(teamId, weaponDefId);
+weaponDef-&gt;shieldStartingPower = sAICallback-&gt;WeaponDef_getShieldStartingPower(teamId, weaponDefId);
+weaponDef-&gt;shieldRechargeDelay = sAICallback-&gt;WeaponDef_getShieldRechargeDelay(teamId, weaponDefId);
+weaponDef-&gt;shieldGoodColor = float3(sAICallback-&gt;WeaponDef_getShieldGoodColor(teamId, weaponDefId));
+weaponDef-&gt;shieldBadColor = float3(sAICallback-&gt;WeaponDef_getShieldBadColor(teamId, weaponDefId));
+weaponDef-&gt;shieldAlpha = sAICallback-&gt;WeaponDef_getShieldAlpha(teamId, weaponDefId);
+weaponDef-&gt;shieldInterceptType = sAICallback-&gt;WeaponDef_getShieldInterceptType(teamId, weaponDefId);
+weaponDef-&gt;interceptedByShieldType = sAICallback-&gt;WeaponDef_getInterceptedByShieldType(teamId, weaponDefId);
+weaponDef-&gt;avoidFriendly = sAICallback-&gt;WeaponDef_isAvoidFriendly(teamId, weaponDefId);
+weaponDef-&gt;avoidFeature = sAICallback-&gt;WeaponDef_isAvoidFeature(teamId, weaponDefId);
+weaponDef-&gt;avoidNeutral = sAICallback-&gt;WeaponDef_isAvoidNeutral(teamId, weaponDefId);
+weaponDef-&gt;targetBorder = sAICallback-&gt;WeaponDef_getTargetBorder(teamId, weaponDefId);
+weaponDef-&gt;cylinderTargetting = sAICallback-&gt;WeaponDef_getCylinderTargetting(teamId, weaponDefId);
+weaponDef-&gt;minIntensity = sAICallback-&gt;WeaponDef_getMinIntensity(teamId, weaponDefId);
+weaponDef-&gt;heightBoostFactor = sAICallback-&gt;WeaponDef_getHeightBoostFactor(teamId, weaponDefId);
+weaponDef-&gt;proximityPriority = sAICallback-&gt;WeaponDef_getProximityPriority(teamId, weaponDefId);
+weaponDef-&gt;collisionFlags = sAICallback-&gt;WeaponDef_getCollisionFlags(teamId, weaponDefId);
+weaponDef-&gt;sweepFire = sAICallback-&gt;WeaponDef_isSweepFire(teamId, weaponDefId);
+weaponDef-&gt;canAttackGround = sAICallback-&gt;WeaponDef_isCanAttackGround(teamId, weaponDefId);
+weaponDef-&gt;cameraShake = sAICallback-&gt;WeaponDef_getCameraShake(teamId, weaponDefId);
+weaponDef-&gt;dynDamageExp = sAICallback-&gt;WeaponDef_getDynDamageExp(teamId, weaponDefId);
+weaponDef-&gt;dynDamageMin = sAICallback-&gt;WeaponDef_getDynDamageMin(teamId, weaponDefId);
+weaponDef-&gt;dynDamageRange = sAICallback-&gt;WeaponDef_getDynDamageRange(teamId, weaponDefId);
+weaponDef-&gt;dynDamageInverted = sAICallback-&gt;WeaponDef_isDynDamageInverted(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 6&quot;);
+//{
+//	SProperties* sProperties = sAICallback-&gt;WeaponDef_getCustomParams(teamId, weaponDefId);
+//	weaponDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+//	int i;
+//	for (i=0; i &lt; sProperties-&gt;size; ++i) {
+//		weaponDef-&gt;customParams.insert(sProperties-&gt;map[i][0], sProperties-&gt;map[i][1]);
+//	}
+//	free(sProperties-&gt;map);
+//}
+{
+	int size = sAICallback-&gt;WeaponDef_getNumCustomParams(teamId, weaponDefId);
+	weaponDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+//	logT(&quot;GetWeaponDefById 7&quot;);
+//	logI(&quot;GetWeaponDefById 7 size: %d&quot;, size);
+//	int i;
+//	for (i=0; i &lt; size; ++i) {
+//		const char** entry = sAICallback-&gt;WeaponDef_getCustomParam(teamId, weaponDefId, i);
+////		weaponDef-&gt;customParams.insert(entry[0], entry[1]);
+//		weaponDef-&gt;customParams[entry[0]] = entry[1];
+////		free(entry);
+//	}
+//	const char*** cMap = (const char***) malloc(size*2*sizeof(char*));
+	const char* cMap[size][2];
+	sAICallback-&gt;WeaponDef_getCustomParams(teamId, weaponDefId, cMap);
+//	logT(&quot;GetWeaponDefById 8&quot;);
+//	logI(&quot;GetWeaponDefById 8 size: %d&quot;, size);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+//	logI(&quot;GetWeaponDefById 8 i: %d&quot;, i);
+		weaponDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+	}
+//	free(cMap);
+}
+//	logT(&quot;GetWeaponDefById 9&quot;);
+	if (weaponDefs[weaponDefId] != NULL) {
+		delete weaponDefs[weaponDefId];
+	}
+//	logT(&quot;GetWeaponDefById 10&quot;);
+		weaponDefs[weaponDefId] = weaponDef;
+//	logT(&quot;GetWeaponDefById 11&quot;);
+		weaponDefFrames[weaponDefId] = currentFrame;
+//	logT(&quot;GetWeaponDefById 12&quot;);
+	}
+
+//	logT(&quot;leaving: GetWeaponDefById sAICallback&quot;);
+	return weaponDefs[weaponDefId];
+}
+
+const float3* CAIAICallback::GetStartPos() {
+	return new float3(sAICallback-&gt;Map_getStartPos(teamId));
+}
+
+
+
+
+
+
+
+void CAIAICallback::SendTextMsg(const char* text, int zone) {
+	SSendTextMessageCommand cmd = {text, zone};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_TEXT_MESSAGE, &amp;cmd);
+}
+
+void CAIAICallback::SetLastMsgPos(float3 pos) {
+	SSetLastPosMessageCommand cmd = {pos.toSAIFloat3()}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SET_LAST_POS_MESSAGE, &amp;cmd);
+}
+
+void CAIAICallback::AddNotification(float3 pos, float3 color, float alpha) {
+	SAddNotificationDrawerCommand cmd = {pos.toSAIFloat3(), color.toSAIFloat3(), alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_ADD_NOTIFICATION, &amp;cmd);
+}
+
+bool CAIAICallback::SendResources(float mAmount, float eAmount, int receivingTeam) {
+		SSendResourcesCommand cmd = {mAmount, eAmount, receivingTeam}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_RESOURCES, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+int CAIAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIds, int receivingTeam) {
+	int arr_unitIds[unitIds.size()];
+	for (int i=0; i &lt; unitIds.size(); ++i) {
+		arr_unitIds[i] = unitIds[i];
+	}
+	SSendUnitsCommand cmd = {arr_unitIds, unitIds.size(), receivingTeam}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_UNITS, &amp;cmd); return cmd.ret_sentUnits;
+}
+
+void* CAIAICallback::CreateSharedMemArea(char* name, int size) {
+		SCreateSharedMemAreaCommand cmd = {name, size}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SHARED_MEM_AREA_CREATE, &amp;cmd); return cmd.ret_sharedMemArea;
+}
+
+void CAIAICallback::ReleasedSharedMemArea(char* name) {
+	SReleaseSharedMemAreaCommand cmd = {name}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SHARED_MEM_AREA_RELEASE, &amp;cmd);
+}
+
+int CAIAICallback::CreateGroup(char* libraryName, unsigned aiNumber) {
+		SCreateGroupCommand cmd = {libraryName, aiNumber}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_CREATE, &amp;cmd); return cmd.ret_groupId;
+}
+
+void CAIAICallback::EraseGroup(int groupId) {
+	SEraseGroupCommand cmd = {groupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_ERASE, &amp;cmd);
+}
+
+bool CAIAICallback::AddUnitToGroup(int unitId, int groupId) {
+		SAddUnitToGroupCommand cmd = {unitId, groupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_ADD_UNIT, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+bool CAIAICallback::RemoveUnitFromGroup(int unitId) {
+		SRemoveUnitFromGroupCommand cmd = {unitId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_REMOVE_UNIT, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+int CAIAICallback::GiveGroupOrder(int groupId, Command* c) {
+	return this-&gt;Internal_GiveOrder(-1, groupId, c);
+}
+
+int CAIAICallback::GiveOrder(int unitId, Command* c) {
+	return this-&gt;Internal_GiveOrder(unitId, -1, c);
+}
+
+int CAIAICallback::Internal_GiveOrder(int unitId, int groupId, Command* c) {
+	
+/*
+	int ret = -1;
+	
+	switch (c-&gt;id) {
+        case CMD_STOP:
+		{
+			SStopUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOP, &amp;cmd);
+			break;
+		}
+		case CMD_WAIT:
+		{
+			SWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT, &amp;cmd);
+			break;
+		}
+		case CMD_TIMEWAIT:
+		{
+			STimeWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_TIME, &amp;cmd);
+			break;
+		}
+		case CMD_DEATHWAIT:
+		{
+			SDeathWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_DEATH, &amp;cmd);
+			break;
+		}
+		case CMD_SQUADWAIT:
+		{
+			SSquadWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_SQUAD, &amp;cmd);
+			break;
+		}
+		case CMD_GATHERWAIT:
+		{
+			SGatherWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_GATHER, &amp;cmd);
+			break;
+		}
+		case CMD_MOVE:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SMoveUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_MOVE, &amp;cmd);
+			break;
+		}
+		case CMD_PATROL:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SPatrolUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_PATROL, &amp;cmd);
+			break;
+		}
+		case CMD_FIGHT:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SFightUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_FIGHT, &amp;cmd);
+			break;
+		}
+		case CMD_ATTACK:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SAttackUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_ATTACK, &amp;cmd);
+			} else {
+				SAIFloat3 toAttackPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SAttackAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toAttackPos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_ATTACK_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_GUARD:
+		{
+			SGuardUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GUARD, &amp;cmd);
+			break;
+		}
+		case CMD_AISELECT:
+		{
+			SAiSelectUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_AI_SELECT, &amp;cmd);
+			break;
+		}
+		case CMD_GROUPADD:
+		{
+			SGroupAddUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GROUP_ADD, &amp;cmd);
+			break;
+		}
+		case CMD_GROUPCLEAR:
+		{
+			SGroupClearUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GROUP_CLEAR, &amp;cmd);
+			break;
+		}
+		case CMD_REPAIR:
+		{
+			SRepairUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_REPAIR, &amp;cmd);
+			break;
+		}
+		case CMD_FIRE_STATE:
+		{
+			SSetFireStateUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_FIRE_STATE, &amp;cmd);
+			break;
+		}
+		case CMD_MOVE_STATE:
+		{
+			SSetMoveStateUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_MOVE_STATE, &amp;cmd);
+			break;
+		}
+		case CMD_SETBASE:
+		{
+			SAIFloat3 basePos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SSetBaseUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, basePos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_BASE, &amp;cmd);
+			break;
+		}
+		case CMD_SELFD:
+		{
+			SSelfDestroyUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SELF_DESTROY, &amp;cmd);
+			break;
+		}
+		case CMD_SET_WANTED_MAX_SPEED:
+		{
+			SSetWantedMaxSpeedUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_WANTED_MAX_SPEED, &amp;cmd);
+			break;
+		}
+		case CMD_LOAD_UNITS:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				int toLoadUnitId = (int) c-&gt;params[0];
+				SLoadUnitsUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, &amp;toLoadUnitId, 1};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_UNITS, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SLoadUnitsAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_UNITS_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_LOAD_ONTO:
+		{
+			SLoadOntoUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_ONTO, &amp;cmd);
+			break;
+		}
+		case CMD_UNLOAD_UNIT:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SUnloadUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos, (int) c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_UNLOAD_UNIT, &amp;cmd);
+			break;
+		}
+		case CMD_UNLOAD_UNITS:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SUnloadUnitsAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos, c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_UNLOAD_UNITS_AREA, &amp;cmd);
+			break;
+		}
+		case CMD_ONOFF:
+		{
+			SSetOnOffUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_ON_OFF, &amp;cmd);
+			break;
+		}
+		case CMD_RECLAIM:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SReclaimUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RECLAIM, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SReclaimAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RECLAIM_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_CLOAK:
+		{
+			SCloakUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CLOAK, &amp;cmd);
+			break;
+		}
+		case CMD_STOCKPILE:
+		{
+			SStockpileUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOCKPILE, &amp;cmd);
+			break;
+		}
+		case CMD_DGUN:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SDGunUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_D_GUN, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				SDGunPosUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_D_GUN_POS, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_RESTORE:
+		{
+			SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SRestoreAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESTORE_AREA, &amp;cmd);
+			break;
+		}
+		case CMD_REPEAT:
+		{
+			SSetRepeatUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_REPEAT, &amp;cmd);
+			break;
+		}
+		case CMD_TRAJECTORY:
+		{
+			SSetTrajectoryUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_TRAJECTORY, &amp;cmd);
+			break;
+		}
+		case CMD_RESURRECT:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SResurrectUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESURRECT, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SResurrectAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESURRECT_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_CAPTURE:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SCaptureUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CAPTURE, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SCaptureAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CAPTURE_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_AUTOREPAIRLEVEL:
+		{
+			SSetAutoRepairLevelUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL, &amp;cmd);
+			break;
+		}
+		case CMD_IDLEMODE:
+		{
+			SSetIdleModeUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_IDLE_MODE, &amp;cmd);
+			break;
+		}
+		default:
+		{
+			if (c-&gt;id &lt; 0) { // CMD_BUILD
+				int toBuildUnitDefId = -c-&gt;id;
+				SAIFloat3 buildPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				int facing = UNIT_COMMAND_BUILD_NO_FACING;
+				if (c-&gt;params.size() &gt;= 4) facing = c-&gt;params[3];
+				SBuildUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toBuildUnitDefId, buildPos, facing};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_BUILD, &amp;cmd);
+			} else { // CMD_CUSTOM
+				int cmdId = c-&gt;id;
+				int numParams = c-&gt;params.size();
+				float params[numParams];
+				SCustomUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, cmdId, params, numParams};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CUSTOM, &amp;cmd);
+			}
+			break;
+		}
+
+	}
+	
+	return ret;
+*/
+    int sCommandId;
+    void* sCommandData = mallocSUnitCommand(unitId, groupId, c, &amp;sCommandId);
+    
+    int ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, sCommandId, sCommandData);
+    
+    freeSUnitCommand(sCommandData, sCommandId);
+    
+    return ret;
+}
+
+int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
+		SInitPathCommand cmd = {start.toSAIFloat3(), end.toSAIFloat3(), pathType}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_INIT, &amp;cmd); return cmd.ret_pathId;
+}
+
+float3 CAIAICallback::GetNextWaypoint(int pathId) {
+		SGetNextWaypointPathCommand cmd = {pathId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_GET_NEXT_WAYPOINT, &amp;cmd); return float3(cmd.ret_nextWaypoint);
+}
+
+float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+		SGetApproximateLengthPathCommand cmd = {start.toSAIFloat3(), end.toSAIFloat3(), pathType}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_GET_APPROXIMATE_LENGTH, &amp;cmd); return cmd.ret_approximatePathLength;
+}
+
+void CAIAICallback::FreePath(int pathId) {
+	SFreePathCommand cmd = {pathId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_FREE, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerStartPath(const float3&amp; pos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SStartPathDrawerCommand cmd = {pos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_START, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerFinishPath() {
+	SFinishPathDrawerCommand cmd = {}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_FINISH, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawLine(const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SDrawLinePathDrawerCommand cmd = {endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_LINE, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawLineAndIcon(int cmdId, const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SDrawLineAndIconPathDrawerCommand cmd = {cmdId, endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawIconAtLastPos(int cmdId) {
+	SDrawIconAtLastPosPathDrawerCommand cmd = {cmdId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SBreakPathDrawerCommand cmd = {endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_BREAK, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerRestart() {
+	SRestartPathDrawerCommand cmd = {false}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_RESTART, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerRestartSameColor() {
+	SRestartPathDrawerCommand cmd = {true}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_RESTART, &amp;cmd);
+}
+
+int CAIAICallback::CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifeTime, int figureGroupId) {
+		SCreateSplineFigureDrawerCommand cmd = {pos1.toSAIFloat3(), pos2.toSAIFloat3(), pos3.toSAIFloat3(), pos4.toSAIFloat3(), width, arrow, lifeTime, figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_CREATE_SPLINE, &amp;cmd); return cmd.ret_newFigureGroupId;
+}
+
+int CAIAICallback::CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifeTime, int figureGroupId) {
+		SCreateLineFigureDrawerCommand cmd = {pos1.toSAIFloat3(), pos2.toSAIFloat3(), width, arrow, lifeTime, figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_CREATE_LINE, &amp;cmd); return cmd.ret_newFigureGroupId;
+}
+
+void CAIAICallback::SetFigureColor(int figureGroupId, float red, float green, float blue, float alpha) {
+	SAIFloat3 col3 = {red, green, blue};
+	SSetColorFigureDrawerCommand cmd = {figureGroupId, col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_SET_COLOR, &amp;cmd);
+}
+
+void CAIAICallback::DeleteFigureGroup(int figureGroupId) {
+	SDeleteFigureDrawerCommand cmd = {figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_DELETE, &amp;cmd);
+}
+
+void CAIAICallback::DrawUnit(const char* name, float3 pos, float rotation, int lifeTime, int unitTeamId, bool transparent, bool drawBorder, int facing) {
+	SDrawUnitDrawerCommand cmd = {sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, name), pos.toSAIFloat3(), rotation, lifeTime, unitTeamId, transparent, drawBorder, facing}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_DRAW_UNIT, &amp;cmd);
+}
+
+int CAIAICallback::HandleCommand(int commandId, void* data) {
+	
+	int cmdTopicIndex = commandId;
+	int ret = -99;
+	
+	switch (commandId) {
+		case AIHCQuerySubVersionId: {
+//			SQuerySubVersionCommand cmd;
+//			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			ret = sAICallback-&gt;Game_getAiInterfaceVersion(teamId);
+			break;
+		}
+		case AIHCAddMapPointId: {
+			AIHCAddMapPoint* myData = (AIHCAddMapPoint*) data;
+			SAddPointDrawCommand cmd = {myData-&gt;pos.toSAIFloat3(), myData-&gt;label};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCAddMapLineId: {
+			AIHCAddMapLine* myData = (AIHCAddMapLine*) data;
+			SAddLineDrawCommand cmd = {myData-&gt;posfrom.toSAIFloat3(), myData-&gt;posto.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCRemoveMapPointId: {
+			AIHCRemoveMapPoint* myData = (AIHCRemoveMapPoint*) data;
+			SRemovePointDrawCommand cmd = {myData-&gt;pos.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCSendStartPosId: {
+			AIHCSendStartPos* myData = (AIHCSendStartPos*) data;
+			SSendStartPosCommand cmd = {myData-&gt;ready, myData-&gt;pos.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+	}
+	
+	return ret;
+}
+
+bool CAIAICallback::ReadFile(const char* filename, void* buffer, int bufferLen) {
+//		SReadFileCommand cmd = {name, buffer, bufferLen}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_READ_FILE, &amp;cmd); return cmd.ret_isExecuted;
+	return sAICallback-&gt;File_getContent(teamId, filename, buffer, bufferLen);
+}
+
+const char* CAIAICallback::CallLuaRules(const char* data, int inSize, int* outSize) {
+		SCallLuaRulesCommand cmd = {data, inSize, outSize}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CALL_LUA_RULES, &amp;cmd); return cmd.ret_outData;
+}
+
+


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,212 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIAICALLBACK_H
+#define	_AIAICALLBACK_H
+
+
+#include &quot;ExternalAI/SAICallback.h&quot;
+#include &quot;ExternalAI/IAICallback.h&quot;
+
+/**
+ * The AI side wrapper over the C AI interface for IAICallback.
+ */
+class CAIAICallback : public IAICallback {
+public:
+    CAIAICallback();
+    CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/);
+
+	virtual void SendTextMsg(const char* text, int zone);
+	virtual void SetLastMsgPos(float3 pos);
+	virtual void AddNotification(float3 pos, float3 color, float alpha);
+
+	virtual bool SendResources(float mAmount, float eAmount, int receivingTeam);
+	
+	virtual int SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam);
+
+	virtual bool PosInCamera(float3 pos, float radius);
+
+	virtual int GetCurrentFrame();
+
+	virtual int GetMyTeam();
+	virtual int GetMyAllyTeam();
+	virtual int GetPlayerTeam(int player);
+	virtual const char* GetTeamSide(int team);
+
+	virtual void* CreateSharedMemArea(char* name, int size);
+	
+	virtual void ReleasedSharedMemArea(char* name);
+
+	virtual int CreateGroup(char* dll, unsigned aiNumber);							
+																						
+	virtual void EraseGroup(int groupid);											
+	virtual bool AddUnitToGroup(int unitid, int groupid);							
+																						
+	virtual bool RemoveUnitFromGroup(int unitid);									
+	virtual int GetUnitGroup(int unitid);											
+	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid);	
+	virtual int GiveGroupOrder(int unitid, Command* c);
+
+	virtual int GiveOrder(int unitid, Command* c);
+
+	virtual const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid);
+	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
+
+	virtual int GetUnitAiHint(int unitid);				
+	virtual int GetUnitTeam(int unitid);
+	virtual int GetUnitAllyTeam(int unitid);
+	virtual float GetUnitHealth(int unitid);			
+	virtual float GetUnitMaxHealth(int unitid);			
+	virtual float GetUnitSpeed(int unitid);				
+	virtual float GetUnitPower(int unitid);				
+	virtual float GetUnitExperience(int unitid);		
+	virtual float GetUnitMaxRange(int unitid);			
+	virtual bool IsUnitActivated (int unitid);
+	virtual bool UnitBeingBuilt(int unitid);			
+	virtual const UnitDef* GetUnitDef(int unitid);		
+															
+	virtual float3 GetUnitPos(int unitid);
+	virtual int GetBuildingFacing(int unitid);			
+	virtual bool IsUnitCloaked(int unitid);
+	virtual bool IsUnitParalyzed(int unitid);
+	virtual bool IsUnitNeutral(int unitid);
+	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
+
+	virtual const UnitDef* GetUnitDef(const char* unitName);
+	virtual const UnitDef* GetUnitDefById(int unitDefId);
+
+	virtual int InitPath(float3 start, float3 end, int pathType);
+	virtual float3 GetNextWaypoint(int pathid);
+	virtual void FreePath(int pathid);
+
+	virtual float GetPathLength(float3 start, float3 end, int pathType);
+
+	virtual int GetEnemyUnits(int* units);										
+	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);		
+	virtual int GetEnemyUnitsInRadarAndLos(int* units);							
+	virtual int GetFriendlyUnits(int* units);									
+	virtual int GetFriendlyUnits(int* units, const float3&amp; pos, float radius);	
+	virtual int GetNeutralUnits(int* units);									
+	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);	
+
+	virtual int GetMapWidth();
+	virtual int GetMapHeight();
+	virtual const float* GetHeightMap();			
+	virtual float GetMinHeight();					
+	virtual float GetMaxHeight();					
+	virtual const float* GetSlopeMap();				
+														
+	virtual const unsigned short* GetLosMap();		
+	virtual const unsigned short* GetRadarMap();	
+	virtual const unsigned short* GetJammerMap();	
+	virtual const unsigned char* GetMetalMap();		
+	virtual const char* GetMapName();
+	virtual const char* GetModName();
+
+	virtual float GetElevation(float x, float z);	
+
+	virtual float GetMaxMetal();					
+	virtual float GetExtractorRadius();				
+	virtual float GetMinWind();
+	virtual float GetMaxWind();
+	virtual float GetTidalStrength();
+	virtual float GetGravity();
+
+	virtual void LineDrawerStartPath(const float3&amp; pos, const float* color);
+	virtual void LineDrawerFinishPath();
+	virtual void LineDrawerDrawLine(const float3&amp; endPos, const float* color);
+	virtual void LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color);
+	virtual void LineDrawerDrawIconAtLastPos(int cmdID);
+	virtual void LineDrawerBreak(const float3&amp; endPos, const float* color);
+	virtual void LineDrawerRestart();
+	virtual void LineDrawerRestartSameColor();
+
+	virtual int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group);
+	virtual int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group);
+	virtual void SetFigureColor(int group, float red, float green, float blue, float alpha);
+	virtual void DeleteFigureGroup(int group);
+
+	virtual void DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing);
+
+	virtual bool CanBuildAt(const UnitDef* unitDef, float3 pos, int facing);
+	
+	virtual float3 ClosestBuildSite(const UnitDef* unitdef, float3 pos, float searchRadius, int minDist, int facing);
+
+	virtual bool GetProperty(int id, int property, void* dst);
+	virtual bool GetValue(int id, void* dst);
+	virtual int HandleCommand(int commandId, void* data);
+
+	virtual int GetFileSize(const char* name);								
+	virtual bool ReadFile(const char* name, void* buffer, int bufferLen);	
+
+	virtual int GetSelectedUnits(int* units);
+	virtual float3 GetMousePos();
+	virtual int GetMapPoints(PointMarker* pm, int maxPoints);
+	virtual int GetMapLines(LineMarker* lm, int maxLines);
+
+	virtual float GetMetal();					
+	virtual float GetMetalIncome();				
+	virtual float GetMetalUsage();				
+	virtual float GetMetalStorage();			
+
+	virtual float GetEnergy();					
+	virtual float GetEnergyIncome();			
+	virtual float GetEnergyUsage();				
+	virtual float GetEnergyStorage();			
+
+	virtual int GetFeatures(int *features, int max);
+	virtual int GetFeatures(int *features, int max, const float3&amp; pos, float radius);
+	virtual const FeatureDef* GetFeatureDef(int feature);
+	virtual const FeatureDef* GetFeatureDefById(int featureDefId);
+	virtual float GetFeatureHealth(int feature);
+	virtual float GetFeatureReclaimLeft(int feature);
+	virtual float3 GetFeaturePos(int feature);
+
+	virtual int GetNumUnitDefs();
+	virtual void GetUnitDefList(const UnitDef** list);
+	virtual float GetUnitDefHeight(int def);	
+	virtual float GetUnitDefRadius(int def);	
+
+	virtual const WeaponDef* GetWeapon(const char* weaponName);
+	virtual const WeaponDef* GetWeaponDefById(int weaponDefId);
+
+	virtual const float3* GetStartPos();
+
+	
+	virtual const char* CallLuaRules(const char* data, int inSize = -1, int* outSize = NULL);
+
+private:
+    int teamId;
+    SAICallback* sAICallback;
+//    IAICallback* aiCallback;
+//    int currentFrame;
+    void init();
+//    void setCurrentFrame(int frame) { currentFrame = frame; }
+    int Internal_GiveOrder(int unitId, int groupId, Command* c);
+    
+	// caches
+    WeaponDef** weaponDefs;
+    int* weaponDefFrames;
+    UnitDef** unitDefs;
+    int* unitDefFrames;
+	std::vector&lt;CommandDescription&gt;** groupPossibleCommands; // needed to prevent memory leacks
+	std::vector&lt;CommandDescription&gt;** unitPossibleCommands; // needed to prevent memory leacks
+	CCommandQueue** unitCurrentCommandQueues; // needed to prevent memory leacks
+    FeatureDef** featureDefs;
+    int* featureDefFrames;
+};
+
+#endif	/* _AIAICALLBACK_H */
+


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIAICallback.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,214 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIAICheats.h&quot;
+
+#include &quot;SAICallback.h&quot;
+#include &quot;ExternalAI/AISCommands.h&quot;
+
+
+CAIAICheats::CAIAICheats()
+    : IAICheats(), teamId(-1), sAICallback(NULL)/*, aiCheatCallback(NULL)*/, aiCallback(NULL) {
+    
+}
+
+CAIAICheats::CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback)
+    : IAICheats(), teamId(teamId), sAICallback(sAICallback)/*, aiCheatCallback(aiCheatCallback)*/, aiCallback(aiCallback) {
+    
+}
+
+void CAIAICheats::setCheatsEnabled(bool enabled) {
+    sAICallback-&gt;Cheats_setEnabled(teamId, enabled);
+}
+
+
+void CAIAICheats::SetMyHandicap(float handicap) {
+    setCheatsEnabled(true);
+    SSetMyHandicapCheatCommand cmd = {handicap};
+    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_SET_MY_HANDICAP, &amp;cmd);
+    setCheatsEnabled(false);
+}
+void CAIAICheats::GiveMeMetal(float amount) {
+    setCheatsEnabled(true);
+    SGiveMeMetalCheatCommand cmd = {amount};
+    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_METAL, &amp;cmd);
+    setCheatsEnabled(false);
+}
+void CAIAICheats::GiveMeEnergy(float amount) {
+    setCheatsEnabled(true);
+    SGiveMeEnergyCheatCommand cmd = {amount};
+    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_ENERGY, &amp;cmd);
+    setCheatsEnabled(false);
+}
+
+int CAIAICheats::CreateUnit(const char* unitDefName, float3 pos) {
+    setCheatsEnabled(true);
+    int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitDefName);
+    SGiveMeNewUnitCheatCommand cmd = {unitDefId, pos.toSAIFloat3()};
+    int unitId = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_NEW_UNIT, &amp;cmd);
+    setCheatsEnabled(false);
+    return unitId;
+}
+
+const UnitDef* CAIAICheats::GetUnitDef(int unitId) {
+    setCheatsEnabled(true);
+    const UnitDef* unitDef = aiCallback-&gt;GetUnitDef(unitId);
+    setCheatsEnabled(false);
+    return unitDef;
+}
+float3 CAIAICheats::GetUnitPos(int unitId) {
+    setCheatsEnabled(true);
+    float3 pos = aiCallback-&gt;GetUnitPos(unitId);
+    setCheatsEnabled(false);
+    return pos;
+}
+int CAIAICheats::GetEnemyUnits(int* unitIds) {
+    setCheatsEnabled(true);
+    int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds);
+    setCheatsEnabled(false);
+    return numUnits;
+}
+int CAIAICheats::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+    setCheatsEnabled(true);
+    int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
+    setCheatsEnabled(false);
+    return numUnits;
+}
+int CAIAICheats::GetNeutralUnits(int* unitIds) {
+    setCheatsEnabled(true);
+    int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds);
+    setCheatsEnabled(false);
+    return numUnits;
+}
+int CAIAICheats::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+    setCheatsEnabled(true);
+    int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
+    setCheatsEnabled(false);
+    return numUnits;
+}
+
+int CAIAICheats::GetUnitTeam(int unitId) {
+    setCheatsEnabled(true);
+    int t = aiCallback-&gt;GetUnitTeam(unitId);
+    setCheatsEnabled(false);
+    return t;
+}
+int CAIAICheats::GetUnitAllyTeam(int unitId) {
+    setCheatsEnabled(true);
+    int t = aiCallback-&gt;GetUnitAllyTeam(unitId);
+    setCheatsEnabled(false);
+    return t;
+}
+float CAIAICheats::GetUnitHealth(int unitId) {
+    setCheatsEnabled(true);
+    float health = aiCallback-&gt;GetUnitHealth(unitId);
+    setCheatsEnabled(false);
+    return health;
+}
+float CAIAICheats::GetUnitMaxHealth(int unitId) {
+    setCheatsEnabled(true);
+    float health = aiCallback-&gt;GetUnitMaxHealth(unitId);
+    setCheatsEnabled(false);
+    return health;
+}
+float CAIAICheats::GetUnitPower(int unitId) {
+    setCheatsEnabled(true);
+    float power = aiCallback-&gt;GetUnitPower(unitId);
+    setCheatsEnabled(false);
+    return power;
+}
+float CAIAICheats::GetUnitExperience(int unitId) {
+    setCheatsEnabled(true);
+    float experience = aiCallback-&gt;GetUnitExperience(unitId);
+    setCheatsEnabled(false);
+    return experience;
+}
+bool CAIAICheats::IsUnitActivated(int unitId) {
+    setCheatsEnabled(true);
+    bool activated = aiCallback-&gt;IsUnitActivated(unitId);
+    setCheatsEnabled(false);
+    return activated;
+}
+bool CAIAICheats::UnitBeingBuilt(int unitId) {
+    setCheatsEnabled(true);
+    bool isBeingBuilt = aiCallback-&gt;UnitBeingBuilt(unitId);
+    setCheatsEnabled(false);
+    return isBeingBuilt;
+}
+bool CAIAICheats::IsUnitNeutral(int unitId) {
+    setCheatsEnabled(true);
+    bool neutral = aiCallback-&gt;IsUnitNeutral(unitId);
+    setCheatsEnabled(false);
+    return neutral;
+}
+bool CAIAICheats::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+    setCheatsEnabled(true);
+    bool fetchOk = aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
+    setCheatsEnabled(false);
+    return fetchOk;
+}
+const CCommandQueue* CAIAICheats::GetCurrentUnitCommands(int unitId) {
+    setCheatsEnabled(true);
+    const CCommandQueue* cc = aiCallback-&gt;GetCurrentUnitCommands(unitId);
+    setCheatsEnabled(false);
+    return cc;
+}
+
+int CAIAICheats::GetBuildingFacing(int unitId) {
+    setCheatsEnabled(true);
+    int facing = aiCallback-&gt;GetBuildingFacing(unitId);
+    setCheatsEnabled(false);
+    return facing;
+}
+bool CAIAICheats::IsUnitCloaked(int unitId) {
+    setCheatsEnabled(true);
+    bool cloaked = aiCallback-&gt;IsUnitCloaked(unitId);
+    setCheatsEnabled(false);
+    return cloaked;
+}
+bool CAIAICheats::IsUnitParalyzed(int unitId) {
+    setCheatsEnabled(true);
+    bool paralyzed = aiCallback-&gt;IsUnitParalyzed(unitId);
+    setCheatsEnabled(false);
+    return paralyzed;
+}
+
+bool CAIAICheats::OnlyPassiveCheats() {
+    return sAICallback-&gt;Cheats_isOnlyPassive(teamId);
+}
+void CAIAICheats::EnableCheatEvents(bool enable) {
+    sAICallback-&gt;Cheats_setEventsEnabled(teamId, enable);
+}
+
+bool CAIAICheats::GetProperty(int id, int property, void* dst) {
+//    setCheatsEnabled(true);
+//    bool fetchOk = aiCallback-&gt;GetProperty(id, property, dst);
+//    setCheatsEnabled(false);
+//    return fetchOk;
+	return false;
+}
+bool CAIAICheats::GetValue(int id, void* dst) {
+//    setCheatsEnabled(true);
+//    bool fetchOk = aiCallback-&gt;GetValue(id, dst);
+//    setCheatsEnabled(false);
+//    return fetchOk;
+	return false;
+}
+int CAIAICheats::HandleCommand(int commandId, void* data) {
+    setCheatsEnabled(true);
+    int ret = aiCallback-&gt;HandleCommand(commandId, data);
+    setCheatsEnabled(false);
+    return ret;
+}


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,80 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIAICHEATS_H
+#define	_AIAICHEATS_H
+
+#include &quot;ExternalAI/SAICallback.h&quot;
+#include &quot;ExternalAI/IAICheats.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+#include &quot;AIAICallback.h&quot;
+
+/**
+ * The AI side wrapper over the C AI interface for IAICheats.
+ */
+class CAIAICheats : public IAICheats {
+public:
+    CAIAICheats();
+    CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback);
+
+
+    virtual void SetMyHandicap(float handicap);
+
+    virtual void GiveMeMetal(float amount);
+    virtual void GiveMeEnergy(float amount);
+
+    virtual int CreateUnit(const char* name, float3 pos);
+
+    virtual const UnitDef* GetUnitDef(int unitid);
+    virtual float3 GetUnitPos(int unitid);
+    virtual int GetEnemyUnits(int* units);
+    virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
+    virtual int GetNeutralUnits(int* units);
+    virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
+
+    virtual int GetUnitTeam(int unitid);
+    virtual int GetUnitAllyTeam(int unitid);
+    virtual float GetUnitHealth(int unitid);
+    virtual float GetUnitMaxHealth(int unitid);
+    virtual float GetUnitPower(int unitid);
+    virtual float GetUnitExperience(int unitid);
+    virtual bool IsUnitActivated(int unitid);
+    virtual bool UnitBeingBuilt(int unitid);
+    virtual bool IsUnitNeutral(int unitid);
+    virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
+    virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
+
+    virtual int GetBuildingFacing(int unitid);
+    virtual bool IsUnitCloaked(int unitid);
+    virtual bool IsUnitParalyzed(int unitid);
+
+    virtual bool OnlyPassiveCheats();
+    virtual void EnableCheatEvents(bool enable);
+
+    virtual bool GetProperty(int id, int property, void* dst);
+    virtual bool GetValue(int id, void* dst);
+    virtual int HandleCommand(int commandId, void* data);
+    
+private:
+    int teamId;
+    SAICallback* sAICallback;
+//    IAICheats* aiCheatCallback;
+//    IAICallback* aiCallback;
+    CAIAICallback* aiCallback;
+    void setCheatsEnabled(bool enable);
+};
+
+
+#endif	/* _AIAICHEATS_H */


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIAICheats.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIExport.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIExport.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIExport.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,105 @@
+#include &quot;AIExport.h&quot;
+
+#include &lt;map&gt;
+
+#include &quot;AI.h&quot;
+#include &quot;AIGlobalAI.h&quot;
+#include &quot;RAI.h&quot;
+
+/*
+If we do not have an init() method, then we would instead pass
+an event InitEvent to handleEvent. However, we would have to make
+handleEvent have to wait for an InitEvent as a special case, since
+the team in question would not yet exist. 
+
+Therefore, the handleEvent code would look like this:
+[code]
+DLL_EXPORT int handleEvent(int team, int eventID, void* event) {
+    if (eventID == INIT_EVENT) {
+        ais[team] = CAIObject();
+    }
+    if (ais.count(team) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[team].handleEvent(eventID, event);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}
+[/code]
+Advantages:
+* All events to AI go through handleEvent.
+* People don't get confused and start adding bananaSplitz() functions.
+
+Disadvantages:
+* We need to check for INIT_EVENT before *every message*.
+* These events will happen only once per game -- after that the check becomes a necessary waste of time.
+* Handling events is no longer about getting the right object to deal with an event, it also includes initialising object properly.
+
+I understand that we want to keep the interface simple. In fact,
+I think we should keep it as minimal as possible, and ideally everything
+would go through handleEvent. Practically though, it does not make sense
+to do this: we'll be wasting our own time for no good reason in the
+case of initialisation. 
+
+The (in my opinion much cleaner) alternative is the one I've implemented.
+Advantages:
+* One function that initialises a team before everything is passed to handlEvent
+* No redundant if statements.
+* Simple design.
+
+Disadvantage:
+* People might start adding other functions to the interface.
+
+I don't think that the disadvantage is a real one: it's pretty standard to 
+see initialisation as a special case. It's pretty clear that everything
+else goes through handleEvent. 
+
+The advantage is clear: a more efficient, simpler design. Of course, you could
+argue that the efficiency is nominal, one extra if per event is very little cost,
+and granted, that's true; but this doesn't change the fact that we're checking
+for a special case that we know only happens once at the beginning of the game, before
+every single event after.
+
+Of course, we still need an INIT_EVENT, since initialising the existance of a team
+member is not the same as initialising its state. (It's for this reason that
+I would consider renaming init() to create()).
+
+You might also argue that we do this check in the handleEvent switch within each
+team. This is true, although the difference there is that a switch is translated
+to address lookups and so there is no increase in cost if there are more switch
+cases. 
+*/
+
+std::map&lt;int, CAI*&gt; ais;
+
+DLL_EXPORT int version() {
+    return 1;
+}
+
+// Since this is a C interface, we can only be told by the engine
+// to set up an AI with the number team that indicates a receiver
+// of any handleEvent() call.
+DLL_EXPORT void init(int team) {
+    // the map already has an AI for this team.
+    //TODO: raise an error, since it's probably a mistake if we're trying
+    //reinitialise a team that's already had init() called on it.
+    if (ais.count(team) &gt; 0) {
+        return;
+    }
+    //TODO:
+    // Change the line below so that CAI is 
+    // your AI, which should be a subclass of CAI that
+    // overrides the handleEvent() method.
+    ais[team] = new CAIGlobalAI(team, new cRAI);
+}
+
+DLL_EXPORT int handleEvent(int team, int eventID, void* event) {
+    // events sent to team -1 will always be to the AI object itself,
+    // not to a particular team.
+    if (ais.count(team) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[team]-&gt;handleEvent(eventID, event);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIExport.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIExport.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIExport.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,38 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AIEXPORT_H
+#define AIEXPORT_H
+
+// First we create extern declarations that will work across
+// different platforms.
+#ifndef DLL_EXPORT
+    #ifdef _WIN32
+        #define DLL_EXPORT extern &quot;C&quot; __declspec(dllexport)
+    #elif __GNUC__ &gt;= 4
+        // Support for '-fvisibility=hidden'.
+        #define DLL_EXPORT extern &quot;C&quot; __attribute__ ((visibility(&quot;default&quot;)))
+    #else
+        #define DLL_EXPORT extern &quot;C&quot;
+    #endif
+#endif
+
+DLL_EXPORT int version();
+DLL_EXPORT void init(int team);
+DLL_EXPORT int handleEvent(int team, int eventID, void* event);
+
+#endif /*AIEXPORT_H*/


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIExport.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,33 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIGlobalAI.h&quot;
+
+CAIGlobalAI::CAIGlobalAI() : CAI(), gai(0) { 
+    
+}
+
+CAIGlobalAI::CAIGlobalAI(int team, IGlobalAI* gai) : CAI(team), gai(gai) {
+    
+}
+
+CAIGlobalAI::~CAIGlobalAI() {
+    delete gai;
+}
+void CAIGlobalAI::InitAI(IGlobalAICallback* globalAICallback, int team) {
+	gai-&gt;InitAI(globalAICallback, team);
+}


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,37 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AIGLOBALAI_H
+#define AIGLOBALAI_H
+
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+#include &quot;AI.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot; // Remove
+
+class CAIGlobalAI : public CAI {
+public:
+    CAIGlobalAI();
+    CAIGlobalAI(int team, IGlobalAI* gai);
+    ~CAIGlobalAI();
+
+    void InitAI(IGlobalAICallback* globalAICallback, int team);
+    
+    IGlobalAI* gai;
+};
+
+#endif /*AIGLOBALAI_H*/


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,52 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIGlobalAICallback.h&quot;
+#include &quot;AIAICallback.h&quot;
+#include &quot;AIAICheats.h&quot;
+
+CAIGlobalAICallback::CAIGlobalAICallback()
+    : IGlobalAICallback(), sAICallback(NULL), team(-1),
+        wrappedAICallback(NULL), wrappedAICheats(NULL) {
+    
+}
+
+CAIGlobalAICallback::CAIGlobalAICallback(SAICallback* sAICallback, int team)
+    : IGlobalAICallback(), sAICallback(sAICallback), team(team),
+        wrappedAICallback(NULL), wrappedAICheats(NULL) {
+    
+}
+
+CAIGlobalAICallback::~CAIGlobalAICallback() {
+    
+}
+
+
+IAICallback* CAIGlobalAICallback::GetAICallback() {
+    
+    if (wrappedAICallback == NULL) {
+        wrappedAICallback = new CAIAICallback(team, sAICallback/*, globalAICallback-&gt;GetAICallback()*/);
+    }
+    return wrappedAICallback;
+}
+
+IAICheats* CAIGlobalAICallback::GetCheatInterface() {
+    
+    if (wrappedAICheats == NULL) {
+        this-&gt;GetAICallback(); // to initialize
+        wrappedAICheats = new CAIAICheats(team, sAICallback/*, globalAICallback-&gt;GetCheatInterface()*/, wrappedAICallback);
+    }
+    return wrappedAICheats;
+}


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,46 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIGLOBALAICALLBACK_H
+#define	_AIGLOBALAICALLBACK_H
+
+#include &quot;ExternalAI/SAICallback.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+
+#include &quot;AIAICallback.h&quot;
+#include &quot;AIAICheats.h&quot;
+
+/**
+ * The AI side wrapper over the C AI interface for IGlobalAICallback.
+ */
+class CAIGlobalAICallback : public IGlobalAICallback {
+public:
+    CAIGlobalAICallback();
+    CAIGlobalAICallback(SAICallback* sAICallback, int team/*, IGlobalAICallback* globalAICallback*/);
+    ~CAIGlobalAICallback();
+
+    virtual IAICheats* GetCheatInterface();
+    virtual IAICallback* GetAICallback();
+    
+private:
+    SAICallback* sAICallback;
+    int team;
+//    IGlobalAICallback* globalAICallback; // deprecated
+    CAIAICallback* wrappedAICallback;
+    CAIAICheats* wrappedAICheats;
+};
+
+#endif	/* _AIGLOBALAICALLBACK_H */
+


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AIGlobalAICallback.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/AISCommands.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/AISCommands.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/AISCommands.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,2 @@
+
+#include &quot;ExternalAI/AISCommands.cpp&quot;


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/AISCommands.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDamagedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDamagedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDamagedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyDamagedEvent : public CAIEvent {
+public:
+    CAIEnemyDamagedEvent(SEnemyDamagedEvent* event): event(*event) {}
+    ~CAIEnemyDamagedEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;EnemyDamaged(event.enemy, event.attacker, event.damage, event.dir);
+    }
+private:
+    SEnemyDamagedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDamagedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDestroyedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDestroyedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDestroyedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyDestroyedEvent : public CAIEvent {
+public:
+    CAIEnemyDestroyedEvent(SEnemyDestroyedEvent* event): event(*event) {}
+    ~CAIEnemyDestroyedEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;EnemyDestroyed(event.enemy, event.attacker);
+    }
+private:
+    SEnemyDestroyedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyDestroyedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterLOSEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterLOSEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterLOSEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyEnterLOSEvent : public CAIEvent {
+public:
+    CAIEnemyEnterLOSEvent(SEnemyEnterLOSEvent* event): event(*event) {}
+    ~CAIEnemyEnterLOSEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;EnemyEnterLOS(event.enemy);
+    }
+private:
+    SEnemyEnterLOSEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterLOSEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterRadarEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterRadarEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterRadarEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyEnterRadarEvent : public CAIEvent {
+public:
+    CAIEnemyEnterRadarEvent(SEnemyEnterRadarEvent* event): event(*event) {}
+    ~CAIEnemyEnterRadarEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;EnemyEnterRadar(event.enemy);
+    }
+private:
+    SEnemyEnterRadarEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyEnterRadarEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveLOSEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveLOSEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveLOSEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyLeaveLOSEvent : public CAIEvent {
+public:
+    CAIEnemyLeaveLOSEvent(SEnemyLeaveLOSEvent* event): event(*event) {}
+    ~CAIEnemyLeaveLOSEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;EnemyLeaveLOS(event.enemy);
+    }
+private:
+    SEnemyLeaveLOSEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveLOSEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveRadarEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveRadarEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveRadarEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyLeaveRadarEvent : public CAIEvent {
+public:
+    CAIEnemyLeaveRadarEvent(SEnemyLeaveRadarEvent* event): event(*event) {}
+    ~CAIEnemyLeaveRadarEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;EnemyLeaveRadar(event.enemy);
+    }
+private:
+    SEnemyLeaveRadarEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEnemyLeaveRadarEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,23 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEvent {
+public:
+    
+    virtual void run(CAI* ai) = 0;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvents.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvents.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvents.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,55 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+#ifndef AIEVENTS_H
+#define AIEVENTS_H
+
+#include &quot;../AI.h&quot;
+#include &quot;../AIGlobalAI.h&quot;
+
+#include &quot;ExternalAI/AISEvents.h&quot;
+
+#include &quot;AIEvent.h&quot;
+#include &quot;AINullEvent.h&quot;
+
+#include &quot;AIInitEvent.h&quot;
+#include &quot;AIUpdateEvent.h&quot;
+
+#include &quot;AIMessageEvent.h&quot;
+
+#include &quot;AIUnitCreatedEvent.h&quot;
+#include &quot;AIUnitFinishedEvent.h&quot;
+#include &quot;AIUnitIdleEvent.h&quot;
+#include &quot;AIUnitMoveFailedEvent.h&quot;
+#include &quot;AIUnitDamagedEvent.h&quot;
+#include &quot;AIUnitDestroyedEvent.h&quot;
+#include &quot;AIUnitGivenEvent.h&quot;
+#include &quot;AIUnitCapturedEvent.h&quot;
+
+#include &quot;AIEnemyEnterLOSEvent.h&quot;
+#include &quot;AIEnemyLeaveLOSEvent.h&quot;
+#include &quot;AIEnemyEnterRadarEvent.h&quot;
+#include &quot;AIEnemyLeaveRadarEvent.h&quot;
+#include &quot;AIEnemyDamagedEvent.h&quot;
+#include &quot;AIEnemyDestroyedEvent.h&quot;
+
+#include &quot;AIWeaponFiredEvent.h&quot;
+#include &quot;AIPlayerCommandEvent.h&quot;
+#include &quot;AISeismicPingEvent.h&quot;
+
+#endif /*AIEVENTS_H*/


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIEvents.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIInitEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIInitEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIInitEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,34 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+#include &quot;../AIGlobalAICallback.h&quot;
+
+class CAIInitEvent : public CAIEvent {
+public:
+    CAIInitEvent(SInitEvent* event): event(*event) {}
+    ~CAIInitEvent() {}
+    
+    void run(CAI* ai) {
+        //((CAIGlobalAI*) ai)-&gt;gai-&gt;InitAI(event.callback, event.team);
+        //((CAIGlobalAI*) ai)-&gt;InitAI(event.c_callback, event.team, event.callback);
+        IGlobalAICallback* wrappedGlobalAICallback = new CAIGlobalAICallback(event.c_callback, event.team);
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;InitAI(wrappedGlobalAICallback, event.team);
+    }
+private:
+    SInitEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIInitEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIMessageEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIMessageEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIMessageEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIMessageEvent : public CAIEvent {
+public:
+    CAIMessageEvent(SMessageEvent* event): event(*event) {}
+    ~CAIMessageEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;GotChatMsg(event.message, event.player);
+    }
+private:
+    SMessageEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIMessageEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AINullEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AINullEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AINullEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,23 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+class CAINullEvent : public CAIEvent {
+public:
+    CAINullEvent() {}
+    ~CAINullEvent() {}
+    void run(CAI* ai) {}
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AINullEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIPlayerCommandEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIPlayerCommandEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIPlayerCommandEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,44 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIPLAYERCOMMANDEVENT_H
+#define	_AIPLAYERCOMMANDEVENT_H
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+#include &quot;ExternalAI/AISCommands.h&quot;
+
+class CAIPlayerCommandEvent : public CAIEvent {
+public:
+    CAIPlayerCommandEvent(SPlayerCommandEvent* event): event(*event) {}
+    ~CAIPlayerCommandEvent() {}
+    
+    void run(CAI* ai) {
+		int evtId = AI_EVENT_PLAYER_COMMAND;
+		std::vector&lt;int&gt; unitIds;
+		int i;
+		for (i=0; i &lt; event.numUnitIds; i++) {
+            unitIds.push_back(event.unitIds[i]);
+        }
+		Command* c = (Command*) newCommand(event.commandData, event.commandTopic);
+		IGlobalAI::PlayerCommandEvent evt = {unitIds, *c, event.playerId};
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;HandleEvent(evtId, &amp;evt);
+		delete c;
+    }
+private:
+    SPlayerCommandEvent event;
+};
+
+#endif	/* _AIPLAYERCOMMANDEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIPlayerCommandEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AISeismicPingEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AISeismicPingEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AISeismicPingEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,36 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AISEISMICPINGEVENT_H
+#define	_AISEISMICPINGEVENT_H
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+
+class CAISeismicPingEvent : public CAIEvent {
+public:
+    CAISeismicPingEvent(SSeismicPingEvent* event): event(*event) {}
+    ~CAISeismicPingEvent() {}
+    
+    void run(CAI* ai) {
+		int evtId = AI_EVENT_SEISMIC_PING;
+		IGlobalAI::SeismicPingEvent evt = {float3(event.pos), event.strength};
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;HandleEvent(evtId, &amp;evt);
+    }
+private:
+    SSeismicPingEvent event;
+};
+
+#endif	/* _AISEISMICPINGEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AISeismicPingEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCapturedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCapturedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCapturedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,36 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIUNITCAPTUREDEVENT_H
+#define	_AIUNITCAPTUREDEVENT_H
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+
+class CAIUnitCapturedEvent : public CAIEvent {
+public:
+    CAIUnitCapturedEvent(SUnitCapturedEvent* event): event(*event) {}
+    ~CAIUnitCapturedEvent() {}
+    
+    void run(CAI* ai) {
+		int evtId = AI_EVENT_UNITCAPTURED;
+		IGlobalAI::ChangeTeamEvent evt = {event.unitId, event.newTeamId, event.oldTeamId};
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;HandleEvent(evtId, &amp;evt);
+    }
+private:
+    SUnitCapturedEvent event;
+};
+
+#endif	/* _AIUNITCAPTUREDEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCapturedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCreatedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCreatedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCreatedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitCreatedEvent : public CAIEvent {
+public:
+    CAIUnitCreatedEvent(SUnitCreatedEvent* event): event(*event) {}
+    ~CAIUnitCreatedEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;UnitCreated(event.unit);
+    }
+private:
+    SUnitCreatedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitCreatedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDamagedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDamagedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDamagedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitDamagedEvent : public CAIEvent {
+public:
+    CAIUnitDamagedEvent(SUnitDamagedEvent* event): event(*event) {}
+    ~CAIUnitDamagedEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;UnitDamaged(event.unit, event.attacker, event.damage, event.dir);
+    }
+private:
+    SUnitDamagedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDamagedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDestroyedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDestroyedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDestroyedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitDestroyedEvent : public CAIEvent {
+public:
+    CAIUnitDestroyedEvent(SUnitDestroyedEvent* event): event(*event) {}
+    ~CAIUnitDestroyedEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;UnitDestroyed(event.unit, event.attacker);
+    }
+private:
+    SUnitDestroyedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitDestroyedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitFinishedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitFinishedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitFinishedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitFinishedEvent : public CAIEvent {
+public:
+    CAIUnitFinishedEvent(SUnitFinishedEvent* event): event(*event) {}
+    ~CAIUnitFinishedEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;UnitFinished(event.unit);
+    }
+private:
+    SUnitFinishedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitFinishedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitGivenEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitGivenEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitGivenEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,36 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIUNITGIVENEVENT_H
+#define	_AIUNITGIVENEVENT_H
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+
+class CAIUnitGivenEvent : public CAIEvent {
+public:
+    CAIUnitGivenEvent(SUnitGivenEvent* event): event(*event) {}
+    ~CAIUnitGivenEvent() {}
+    
+    void run(CAI* ai) {
+		int evtId = AI_EVENT_UNITGIVEN;
+		IGlobalAI::ChangeTeamEvent evt = {event.unitId, event.newTeamId, event.oldTeamId};
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;HandleEvent(evtId, &amp;evt);
+    }
+private:
+    SUnitGivenEvent event;
+};
+
+#endif	/* _AIUNITGIVENEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitGivenEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitIdleEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitIdleEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitIdleEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitIdleEvent : public CAIEvent {
+public:
+    CAIUnitIdleEvent(SUnitIdleEvent* event): event(*event) {}
+    ~CAIUnitIdleEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;UnitIdle(event.unit);
+    }
+private:
+    SUnitIdleEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitIdleEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitMoveFailedEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitMoveFailedEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitMoveFailedEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitMoveFailedEvent : public CAIEvent {
+public:
+    CAIUnitMoveFailedEvent(SUnitMoveFailedEvent* event): event(*event) {}
+    ~CAIUnitMoveFailedEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;UnitMoveFailed(event.unit);
+    }
+private:
+    SUnitMoveFailedEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUnitMoveFailedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUpdateEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIUpdateEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIUpdateEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUpdateEvent : public CAIEvent {
+public:
+    CAIUpdateEvent(SUpdateEvent* event): event(*event) {}
+    ~CAIUpdateEvent() {}
+    
+    void run(CAI* ai) {
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;Update();
+    }
+private:
+    SUpdateEvent event;
+};


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIUpdateEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Global/RAI-0.553/Event/AIWeaponFiredEvent.h
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/Event/AIWeaponFiredEvent.h	                        (rev 0)
+++ branches/caiinterface/AI/Global/RAI-0.553/Event/AIWeaponFiredEvent.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,40 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIWEAPONFIREDEVENT_H
+#define	_AIWEAPONFIREDEVENT_H
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+
+class CAIWeaponFiredEvent : public CAIEvent {
+public:
+    CAIWeaponFiredEvent(SWeaponFiredEvent* event): event(*event) {}
+    ~CAIWeaponFiredEvent() {}
+    
+    void run(CAI* ai) {
+		int evtId = AI_EVENT_WEAPON_FIRED;
+		//TODO: maybe: retrieve a WeaponDef that contains all attributes
+		// as thisone contians only the correct id
+		WeaponDef weaponDef;
+		weaponDef.id = event.weaponDefId;
+		IGlobalAI::WeaponFireEvent evt = {event.unitId, &amp;weaponDef};
+        ((CAIGlobalAI*) ai)-&gt;gai-&gt;HandleEvent(evtId, &amp;evt);
+    }
+private:
+    SWeaponFiredEvent event;
+};
+
+#endif	/* _AIWEAPONFIREDEVENT_H */
+


Property changes on: branches/caiinterface/AI/Global/RAI-0.553/Event/AIWeaponFiredEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/AI/Global/RAI-0.553/GlobalAIs.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/GlobalAIs.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Global/RAI-0.553/GlobalAIs.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -4,7 +4,7 @@
 
 /////////////////////////////////////////////////////////////////////////////
 
-std::set&lt;IGlobalAI*&gt; ais;
+std::set&lt;IGlobalAI*&gt; oldais;
 
 DLL_EXPORT int GetGlobalAiVersion()
 {
@@ -19,12 +19,12 @@
 DLL_EXPORT IGlobalAI* GetNewAI()
 {
 	cRAI* ai=new cRAI;
-	ais.insert(ai);
+	oldais.insert(ai);
 	return ai;
 }
 
 DLL_EXPORT void ReleaseAI(IGlobalAI* i)
 {
 	delete (cRAI*)i;
-	ais.erase(i);
+	oldais.erase(i);
 }

Added: branches/caiinterface/rts/ExternalAI/AILibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibrary.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AILibrary.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,78 @@
+/*
+ Copyright 2008  Nicolas Wu
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+ */
+
+#include &quot;AILibrary.h&quot;
+#include &lt;string&gt;
+#include &lt;iostream&gt;
+
+#include &quot;StdAfx.h&quot;
+#include &quot;Platform/FileSystem.h&quot;
+#include &quot;Platform/errorhandler.h&quot;
+#include &quot;Platform/SharedLib.h&quot;
+#include &quot;LogOutput.h&quot;
+
+
+CAILibrary::CAILibrary(const char* libName, int team) : libName(libName), team(team) {
+    init();
+}
+    
+CAILibrary::~CAILibrary() {
+    delete lib;
+}
+
+void CAILibrary::init() {
+    if (!filesystem.GetFilesize(libName)) {
+         char msg[512];
+         SNPRINTF(msg, 511, &quot;Error loading AI Library \&quot;%s\&quot; : library not found&quot;, libName);
+         handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+         return;
+     }
+    logOutput &lt;&lt; &quot;Loading AI Library&quot; &lt;&lt; libName &lt;&lt; &quot;\n&quot;;
+    
+    lib = SharedLib::Instantiate(libName);
+    // TODO: version checking
+    
+    _init = (AI_INIT) lib-&gt;FindAddress(&quot;init&quot;);
+    if (_init == 0) {
+        char msg[512];
+        SNPRINTF(
+                msg,
+                511,
+                &quot;Error loading AI Library \&quot;%s\&quot; : no \&quot;init\&quot; function exported&quot;,
+                libName);
+        handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+        return;
+    }
+    _init(team);
+    
+    _handleEvent = (AI_HANDLEEVENT) lib-&gt;FindAddress(&quot;handleEvent&quot;);
+    if (_handleEvent == 0) {
+        char msg[512];
+        SNPRINTF(
+                msg,
+                511,
+                &quot;Error loading AI Library \&quot;%s\&quot; : no \&quot;handleEvent\&quot; function exported&quot;,
+                libName);
+        handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+        return;
+    }
+}
+
+int CAILibrary::handleEvent(int eventID, void* event) {
+    _handleEvent(team, eventID, event);
+}
+


Property changes on: branches/caiinterface/rts/ExternalAI/AILibrary.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AILibrary.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,52 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AILIBRARY_H
+#define AILIBRARY_H
+
+#include &lt;string&gt;
+#include &quot;Object.h&quot;
+#include &quot;Platform/SharedLib.h&quot;
+
+// This class is responsable for loading a particular AI library, and 
+// handling handleEvent() messages intended for that member.
+
+class CAILibrary {
+public:
+    
+    CAILibrary(const char* libName,  int team);
+    ~CAILibrary();
+    
+    void init();
+    
+    int handleEvent(int eventID, void* event);
+    
+    typedef void (*AI_INIT)(int);
+    AI_INIT _init;
+    
+    typedef int (*AI_HANDLEEVENT)(int, int, void*);
+    AI_HANDLEEVENT _handleEvent;
+    
+    int team;
+private: 
+    const char* libName;
+    SharedLib* lib;
+    
+
+};
+
+#endif /*AILIBRARY_H*/


Property changes on: branches/caiinterface/rts/ExternalAI/AILibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,192 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AISCommands.h&quot;
+
+
+#include &quot;AILibraryGlobalAI.h&quot;
+#include &quot;AISEvents.h&quot;
+#include &quot;GlobalAICallback.h&quot;
+//#include &quot;SGlobalAICallback.h&quot;
+#include &quot;SAICallback.h&quot;
+#include &quot;float3.h&quot;
+#include &quot;SAIFloat3.h&quot;
+
+#include &lt;iostream&gt;
+
+//SGlobalAICallback* initSGlobalAICallback(int teamId, IGlobalAICallback* globalAICallback);
+SAICallback* initSAICallback(int teamId, IGlobalAICallback* aiGlobalCallback); // defined in &quot;SGlobalAICallback.cpp&quot;
+
+CAILibraryGlobalAI::CAILibraryGlobalAI(const char* libName, int team)  : CAILibrary(libName, team)
+{
+	CGlobalAI::team = team;
+	
+	ai = this;  
+	callback = new CGlobalAICallback(this);
+	InitAI(callback, team);
+}
+
+CAILibraryGlobalAI::~CAILibraryGlobalAI() {
+	delete callback;
+	ai = 0;
+}
+
+// This is the inherited interface from CGlobalAI, we don't
+// wish to do anything here.
+
+void CAILibraryGlobalAI::LoadAILib(int, const char*, bool) {
+}
+void CAILibraryGlobalAI::Serialize(creg::ISerializer *s) {
+}
+void CAILibraryGlobalAI::PostLoad() {
+}
+void CAILibraryGlobalAI::Load(std::istream *s) {
+}
+void CAILibraryGlobalAI::PreDestroy() {} 
+
+// This is the inherited interface from IGlobalAI
+void CAILibraryGlobalAI::InitAI(IGlobalAICallback* callback, int team) {
+//	SGlobalAICallback* c_callback = initSGlobalAICallback(team, callback);
+	SAICallback* c_callback = initSAICallback(team, callback);
+	SInitEvent event = {team, c_callback};
+	handleEvent(EVENT_INIT, &amp;event);
+}
+
+void CAILibraryGlobalAI::Update() {
+	SUpdateEvent event = {0};
+	handleEvent(EVENT_UPDATE, &amp;event);
+}
+
+void CAILibraryGlobalAI::Load(IGlobalAICallback* callback, std::istream *s) {
+	//TODO
+}
+
+void CAILibraryGlobalAI::Save(std::ostream *s) {
+	//TODO
+}
+
+// NOTE: this isn't the same as handleEvent, it's the one that's been inherited.
+int CAILibraryGlobalAI::HandleEvent(int aiEventId, const void *data) {
+
+	switch (aiEventId) {
+		case AI_EVENT_UNITGIVEN:
+		{
+			ChangeTeamEvent* evt = (ChangeTeamEvent*) data;
+			SUnitGivenEvent sEvent = {evt-&gt;unit, evt-&gt;oldteam, evt-&gt;newteam};
+			return handleEvent(EVENT_UNIT_GIVEN, &amp;sEvent);
+		}
+		case AI_EVENT_UNITCAPTURED:
+		{
+			ChangeTeamEvent* evt = (ChangeTeamEvent*) data;
+			SUnitCapturedEvent sEvent = {evt-&gt;unit, evt-&gt;oldteam, evt-&gt;newteam};
+			return handleEvent(EVENT_UNIT_CAPTURED, &amp;sEvent);
+		}
+		case AI_EVENT_WEAPON_FIRED:
+		{
+			WeaponFireEvent* evt = (WeaponFireEvent*) data;
+			SWeaponFiredEvent sEvent = {evt-&gt;unit, evt-&gt;def-&gt;id};
+			return handleEvent(EVENT_WEAPON_FIRED, &amp;sEvent);
+		}
+		case AI_EVENT_PLAYER_COMMAND:
+		{
+			PlayerCommandEvent* evt = (PlayerCommandEvent*) data;
+			int numUnits = evt-&gt;units.size();
+			int unitIds[numUnits];
+			int i;
+            for (i=0; i &lt; numUnits; ++i) {
+                unitIds[i] = evt-&gt;units.at(i);
+            }
+            int sCommandId;
+            void* sCommandData = mallocSUnitCommand(-1, -1, &amp;(evt-&gt;command), &amp;sCommandId);
+			SPlayerCommandEvent sEvent = {unitIds, numUnits, sCommandId, sCommandData, evt-&gt;player};
+			return handleEvent(EVENT_PLAYER_COMMAND, &amp;sEvent);
+		}
+		case AI_EVENT_SEISMIC_PING:
+		{
+			SeismicPingEvent* evt = (SeismicPingEvent*) data;
+			SSeismicPingEvent sEvent = {evt-&gt;pos.toSAIFloat3(), evt-&gt;strength};
+			return handleEvent(EVENT_SEISMIC_PING, &amp;sEvent);
+		}
+		default:
+			return 0;
+	}
+}
+
+
+void CAILibraryGlobalAI::GotChatMsg(const char* message,int player) {
+	SMessageEvent event = {player, message};
+	handleEvent(EVENT_MESSAGE, &amp;event);
+}
+
+void CAILibraryGlobalAI::UnitCreated(int unit) {
+	SUnitCreatedEvent event = {unit};
+	handleEvent(EVENT_UNIT_CREATED, &amp;event);
+}
+
+void CAILibraryGlobalAI::UnitFinished(int unit) {
+	SUnitFinishedEvent event = {unit};
+	handleEvent(EVENT_UNIT_FINISHED, &amp;event);
+}
+
+void CAILibraryGlobalAI::UnitIdle(int unit) {
+	SUnitIdleEvent event = {unit};
+	handleEvent(EVENT_UNIT_IDLE, &amp;event);
+}
+
+void CAILibraryGlobalAI::UnitMoveFailed(int unit) {
+	SUnitMoveFailedEvent event = {unit};
+	handleEvent(EVENT_UNIT_MOVE_FAILED, &amp;event);
+}
+
+void CAILibraryGlobalAI::UnitDamaged(int unit,int attacker,float damage, float3 dir) {
+	SUnitDamagedEvent event = {unit, attacker, damage, dir.toSAIFloat3()};
+	handleEvent(EVENT_UNIT_DAMAGED, &amp;event);
+}
+
+void CAILibraryGlobalAI::UnitDestroyed(int unit, int attacker) {
+	SUnitDestroyedEvent event = {unit, attacker};
+	handleEvent(EVENT_UNIT_DESTROYED, &amp;event);
+}
+
+void CAILibraryGlobalAI::EnemyEnterLOS(int enemy) {
+	SEnemyEnterLOSEvent event = {enemy};
+	handleEvent(EVENT_ENEMY_ENTER_LOS, &amp;event);
+}
+
+void CAILibraryGlobalAI::EnemyLeaveLOS(int enemy) {
+	SEnemyLeaveLOSEvent event = {enemy};
+	handleEvent(EVENT_ENEMY_LEAVE_LOS, &amp;event);
+}
+
+void CAILibraryGlobalAI::EnemyEnterRadar(int enemy) {
+	SEnemyEnterRadarEvent event = {enemy};
+	handleEvent(EVENT_ENEMY_ENTER_RADAR, &amp;event);
+}
+void CAILibraryGlobalAI::EnemyLeaveRadar(int enemy) {
+	SEnemyLeaveRadarEvent event = {enemy};
+	handleEvent(EVENT_ENEMY_LEAVE_RADAR, &amp;event);
+}
+
+void CAILibraryGlobalAI::EnemyDamaged(int enemy,int attacker,float damage,float3 dir) {
+	SEnemyDamagedEvent event = {enemy, attacker, damage, dir.toSAIFloat3()};
+	handleEvent(EVENT_ENEMY_DAMAGED, &amp;event);
+}
+
+void CAILibraryGlobalAI::EnemyDestroyed(int enemy, int attacker) {
+	SEnemyDestroyedEvent event = {enemy, attacker};
+	handleEvent(EVENT_ENEMY_DESTROYED, &amp;event);
+}


Property changes on: branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,67 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AILIBRARYGLOBALAI_H
+#define AILIBRARYGLOBALAI_H
+
+
+// This class extends GlobalAI, but implements the
+// AILibrary interface, which means it can deal with 
+// the new AI interface.
+
+// Unfortunately, GlobalAIHandler uses the ai parameter of CGlobalAI,
+// and so expects to use the IGlobalAI object.
+// We get around this by implementing all the IGlobalAI interface here
+// as well, and setting ai to this.
+
+#include &quot;AILibrary.h&quot;
+#include &quot;GlobalAI.h&quot;
+#include &quot;IGlobalAI.h&quot;
+
+class CAILibraryGlobalAI : public CGlobalAI, public IGlobalAI, public CAILibrary {
+	
+public:
+	CAILibraryGlobalAI(const char* libName, int team);
+	~CAILibraryGlobalAI();
+	
+	virtual void LoadAILib(int team, const char* libName, bool postLoad);
+	virtual void Serialize(creg::ISerializer*);
+	virtual void PostLoad();
+	virtual void Load(std::istream *s);
+	virtual void PreDestroy();
+	
+	virtual void InitAI(IGlobalAICallback* callback, int team);
+	virtual void UnitCreated(int unit);
+	virtual void UnitFinished(int unit);
+	virtual void UnitDestroyed(int unit, int attacker);
+	virtual void EnemyEnterLOS(int enemy);
+	virtual void EnemyLeaveLOS(int enemy);
+	virtual void EnemyEnterRadar(int enemy);
+	virtual void EnemyLeaveRadar(int enemy);
+	virtual void EnemyDamaged(int damaged,int attacker,float damage,float3 dir);
+	virtual void EnemyDestroyed(int enemy, int attacker);
+	virtual void UnitIdle(int unit);
+	virtual void GotChatMsg(const char* msg,int player);
+	virtual void UnitDamaged(int damaged,int attacker,float damage,float3 dir);
+	virtual void UnitMoveFailed(int unit);
+	virtual int HandleEvent (int msg, const void *data);
+	virtual void Update();
+	virtual void Load(IGlobalAICallback* callback,std::istream *s);
+	virtual void Save(std::ostream *s);
+};
+
+#endif /*AILIBRARYGLOBALAI_H*/


Property changes on: branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AISCommands.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AISCommands.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AISCommands.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,1161 @@
+/*
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AISCommands.h&quot;
+
+#include &lt;limits.h&gt;
+#include &quot;Sim/Units/CommandAI/Command.h&quot;
+
+void initSUnitCommand(void* sUnitCommand) {
+	SStopUnitCommand* scmd = (SStopUnitCommand*) sUnitCommand;
+	scmd-&gt;unitId = -1;
+	scmd-&gt;groupId = -1;
+	scmd-&gt;options = 0;
+	scmd-&gt;timeOut = INT_MAX;
+}
+
+void freeSUnitCommand(void* sCommandData, int sCommandId) {
+
+    switch (sCommandId) {
+        case COMMAND_UNIT_LOAD_UNITS:
+        {
+            SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) sCommandData;
+            free(cmd-&gt;toLoadUnitIds);
+            break;
+        }
+        case COMMAND_UNIT_CUSTOM:
+        {
+            SCustomUnitCommand* cmd = (SCustomUnitCommand*) sCommandData;
+            free(cmd-&gt;params);
+            break;
+        }
+    }
+
+    free(sCommandData);
+}
+
+void* mallocSUnitCommand(int unitId, int groupId, void* v_c, int sCommandId[0]) {
+
+    int sCmdId = COMMAND_NULL;
+    void* sCommandData;
+    
+    Command* c = (Command*) v_c;
+    switch (c-&gt;id) {
+        case CMD_STOP:
+        {
+            SStopUnitCommand* cmd = (SStopUnitCommand*) malloc(sizeof (SStopUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_STOP;
+            break;
+        }
+        case CMD_WAIT:
+        {
+            SWaitUnitCommand* cmd = (SWaitUnitCommand*) malloc(sizeof (SWaitUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_WAIT;
+            break;
+        }
+        case CMD_TIMEWAIT:
+        {
+            STimeWaitUnitCommand* cmd = (STimeWaitUnitCommand*) malloc(sizeof (STimeWaitUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;time = c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_WAIT_TIME;
+            break;
+        }
+        case CMD_DEATHWAIT:
+        {
+            SDeathWaitUnitCommand* cmd = (SDeathWaitUnitCommand*) malloc(sizeof (SDeathWaitUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toDieUnitId = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_WAIT_DEATH;
+            break;
+        }
+        case CMD_SQUADWAIT:
+        {
+            SSquadWaitUnitCommand* cmd = (SSquadWaitUnitCommand*) malloc(sizeof (SSquadWaitUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;numUnits = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_WAIT_SQUAD;
+            break;
+        }
+        case CMD_GATHERWAIT:
+        {
+            SGatherWaitUnitCommand* cmd = (SGatherWaitUnitCommand*) malloc(sizeof (SGatherWaitUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_WAIT_GATHER;
+            break;
+        }
+        case CMD_MOVE:
+        {
+            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+            SMoveUnitCommand* cmd = (SMoveUnitCommand*) malloc(sizeof (SMoveUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toPos = toPos;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_MOVE;
+            break;
+        }
+        case CMD_PATROL:
+        {
+            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+            SPatrolUnitCommand* cmd = (SPatrolUnitCommand*) malloc(sizeof (SPatrolUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toPos = toPos;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_PATROL;
+            break;
+        }
+        case CMD_FIGHT:
+        {
+            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+            SFightUnitCommand* cmd = (SFightUnitCommand*) malloc(sizeof (SFightUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toPos = toPos;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_FIGHT;
+            break;
+        }
+        case CMD_ATTACK:
+        {
+            if (c-&gt;params.size() &lt; 3) {
+                SAttackUnitCommand* cmd = (SAttackUnitCommand*) malloc(sizeof (SAttackUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;toAttackUnitId = (int) c-&gt;params[0];
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_ATTACK;
+            } else {
+                SAIFloat3 toAttackPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+                float radius = 0.0f;
+                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+                SAttackAreaUnitCommand* cmd = (SAttackAreaUnitCommand*) malloc(sizeof (SAttackAreaUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;toAttackPos = toAttackPos;
+                cmd-&gt;radius = radius;
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_ATTACK_AREA;
+            }
+            break;
+        }
+        case CMD_GUARD:
+        {
+            SGuardUnitCommand* cmd = (SGuardUnitCommand*) malloc(sizeof (SGuardUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toGuardUnitId = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_GUARD;
+            break;
+        }
+        case CMD_AISELECT:
+        {
+            SAiSelectUnitCommand* cmd = (SAiSelectUnitCommand*) malloc(sizeof (SAiSelectUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_AI_SELECT;
+            break;
+        }
+        case CMD_GROUPADD:
+        {
+            SGroupAddUnitCommand* cmd = (SGroupAddUnitCommand*) malloc(sizeof (SGroupAddUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toGroupId = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_GROUP_ADD;
+            break;
+        }
+        case CMD_GROUPCLEAR:
+        {
+            SGroupClearUnitCommand* cmd = (SGroupClearUnitCommand*) malloc(sizeof (SGroupClearUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_GROUP_CLEAR;
+            break;
+        }
+        case CMD_REPAIR:
+        {
+            SRepairUnitCommand* cmd = (SRepairUnitCommand*) malloc(sizeof (SRepairUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toRepairUnitId = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_REPAIR;
+            break;
+        }
+        case CMD_FIRE_STATE:
+        {
+            SSetFireStateUnitCommand* cmd = (SSetFireStateUnitCommand*) malloc(sizeof (SSetFireStateUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;fireState = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_FIRE_STATE;
+            break;
+        }
+        case CMD_MOVE_STATE:
+        {
+            SSetMoveStateUnitCommand* cmd = (SSetMoveStateUnitCommand*) malloc(sizeof (SSetMoveStateUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;moveState = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_MOVE_STATE;
+            break;
+        }
+        case CMD_SETBASE:
+        {
+            SAIFloat3 basePos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+            SSetBaseUnitCommand* cmd = (SSetBaseUnitCommand*) malloc(sizeof (SSetBaseUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;basePos = basePos;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_BASE;
+            break;
+        }
+        case CMD_SELFD:
+        {
+            SSelfDestroyUnitCommand* cmd = (SSelfDestroyUnitCommand*) malloc(sizeof (SSelfDestroyUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SELF_DESTROY;
+            break;
+        }
+        case CMD_SET_WANTED_MAX_SPEED:
+        {
+            SSetWantedMaxSpeedUnitCommand* cmd = (SSetWantedMaxSpeedUnitCommand*) malloc(sizeof (SSetWantedMaxSpeedUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;wantedMaxSpeed = c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_WANTED_MAX_SPEED;
+            break;
+        }
+        case CMD_LOAD_UNITS:
+        {
+            if (c-&gt;params.size() &lt; 3) {
+                //int numToLoadUnits = 1;
+                int numToLoadUnits = c-&gt;params.size();
+                
+                SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) malloc(sizeof (SLoadUnitsUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                
+                cmd-&gt;numToLoadUnits = numToLoadUnits;
+                cmd-&gt;toLoadUnitIds = (int*) calloc(numToLoadUnits, sizeof(int));
+                int i;
+                for (i=0; i &lt; numToLoadUnits; ++i) {
+                    cmd-&gt;toLoadUnitIds[i] = (int) c-&gt;params.at(i);
+                }
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_LOAD_UNITS;
+            } else {
+                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+                float radius = 0.0f;
+                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+                SLoadUnitsAreaUnitCommand* cmd = (SLoadUnitsAreaUnitCommand*) malloc(sizeof (SLoadUnitsAreaUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;pos = pos;
+                cmd-&gt;radius = radius;
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_LOAD_UNITS_AREA;
+            }
+            break;
+        }
+        case CMD_LOAD_ONTO:
+        {
+            SLoadOntoUnitCommand* cmd = (SLoadOntoUnitCommand*) malloc(sizeof (SLoadOntoUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;transporterUnitId = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_LOAD_ONTO;
+            break;
+        }
+        case CMD_UNLOAD_UNIT:
+        {
+            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+            SUnloadUnitCommand* cmd = (SUnloadUnitCommand*) malloc(sizeof (SUnloadUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toPos = toPos;
+            cmd-&gt;toUnloadUnitId = (int) c-&gt;params[3];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_UNLOAD_UNIT;
+            break;
+        }
+        case CMD_UNLOAD_UNITS:
+        {
+            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+            float radius = 0.0f;
+            if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+            SUnloadUnitsAreaUnitCommand* cmd = (SUnloadUnitsAreaUnitCommand*) malloc(sizeof (SUnloadUnitsAreaUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;toPos = toPos;
+            cmd-&gt;radius = radius;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_UNLOAD_UNITS_AREA;
+            break;
+        }
+        case CMD_ONOFF:
+        {
+            SSetOnOffUnitCommand* cmd = (SSetOnOffUnitCommand*) malloc(sizeof (SSetOnOffUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;on = (bool) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_ON_OFF;
+            break;
+        }
+        case CMD_RECLAIM:
+        {
+            if (c-&gt;params.size() &lt; 3) {
+                SReclaimUnitCommand* cmd = (SReclaimUnitCommand*) malloc(sizeof (SReclaimUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;toReclaimUnitIdOrFeatureId = (int) c-&gt;params[0];
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_RECLAIM;
+            } else {
+                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+                float radius = 0.0f;
+                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+                SReclaimAreaUnitCommand* cmd = (SReclaimAreaUnitCommand*) malloc(sizeof (SReclaimAreaUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;pos = pos;
+                cmd-&gt;radius = radius;
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_RECLAIM_AREA;
+            }
+            break;
+        }
+        case CMD_CLOAK:
+        {
+            SCloakUnitCommand* cmd = (SCloakUnitCommand*) malloc(sizeof (SCloakUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;cloak = (bool) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_CLOAK;
+            break;
+        }
+        case CMD_STOCKPILE:
+        {
+            SStockpileUnitCommand* cmd = (SStockpileUnitCommand*) malloc(sizeof (SStockpileUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_STOCKPILE;
+            break;
+        }
+        case CMD_DGUN:
+        {
+            if (c-&gt;params.size() &lt; 3) {
+                SDGunUnitCommand* cmd = (SDGunUnitCommand*) malloc(sizeof (SDGunUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;toAttackUnitId = (int) c-&gt;params[0];
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_D_GUN;
+            } else {
+                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+                SDGunPosUnitCommand* cmd = (SDGunPosUnitCommand*) malloc(sizeof (SDGunPosUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;pos = pos;
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_D_GUN_POS;
+            }
+            break;
+        }
+        case CMD_RESTORE:
+        {
+            SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+            float radius = 0.0f;
+            if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+            SRestoreAreaUnitCommand* cmd = (SRestoreAreaUnitCommand*) malloc(sizeof (SRestoreAreaUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;pos = pos;
+            cmd-&gt;radius = radius;
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_RESTORE_AREA;
+            break;
+        }
+        case CMD_REPEAT:
+        {
+            SSetRepeatUnitCommand* cmd = (SSetRepeatUnitCommand*) malloc(sizeof (SSetRepeatUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;repeat = (bool) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_REPEAT;
+            break;
+        }
+        case CMD_TRAJECTORY:
+        {
+            SSetTrajectoryUnitCommand* cmd = (SSetTrajectoryUnitCommand*) malloc(sizeof (SSetTrajectoryUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;trajectory = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_TRAJECTORY;
+            break;
+        }
+        case CMD_RESURRECT:
+        {
+            if (c-&gt;params.size() &lt; 3) {
+                SResurrectUnitCommand* cmd = (SResurrectUnitCommand*) malloc(sizeof (SResurrectUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;toResurrectFeatureId = (int) c-&gt;params[0];
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_RESURRECT;
+            } else {
+                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+                float radius = 0.0f;
+                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+                SResurrectAreaUnitCommand* cmd = (SResurrectAreaUnitCommand*) malloc(sizeof (SResurrectAreaUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;pos = pos;
+                cmd-&gt;radius = radius;
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_RESURRECT_AREA;
+            }
+            break;
+        }
+        case CMD_CAPTURE:
+        {
+            if (c-&gt;params.size() &lt; 3) {
+                SCaptureUnitCommand* cmd = (SCaptureUnitCommand*) malloc(sizeof (SCaptureUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;toCaptureUnitId = (int) c-&gt;params[0];
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_CAPTURE;
+            } else {
+                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+                float radius = 0.0f;
+                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+                SCaptureAreaUnitCommand* cmd = (SCaptureAreaUnitCommand*) malloc(sizeof (SCaptureAreaUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;pos = pos;
+                cmd-&gt;radius = radius;
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_CAPTURE_AREA;
+            }
+            break;
+        }
+        case CMD_AUTOREPAIRLEVEL:
+        {
+            SSetAutoRepairLevelUnitCommand* cmd = (SSetAutoRepairLevelUnitCommand*) malloc(sizeof (SSetAutoRepairLevelUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;autoRepairLevel = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL;
+            break;
+        }
+        case CMD_IDLEMODE:
+        {
+            SSetIdleModeUnitCommand* cmd = (SSetIdleModeUnitCommand*) malloc(sizeof (SSetIdleModeUnitCommand));
+            cmd-&gt;unitId = unitId;
+            cmd-&gt;groupId = groupId;
+            cmd-&gt;options = c-&gt;options;
+            cmd-&gt;timeOut = c-&gt;timeOut;
+            cmd-&gt;idleMode = (int) c-&gt;params[0];
+
+            sCommandData = cmd;
+            sCmdId = COMMAND_UNIT_SET_IDLE_MODE;
+            break;
+        }
+        default:
+        {
+            if (c-&gt;id &lt; 0) { // CMD_BUILD
+                int toBuildUnitDefId = -c-&gt;id;
+                SAIFloat3 buildPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+                int facing = UNIT_COMMAND_BUILD_NO_FACING;
+                if (c-&gt;params.size() &gt;= 4) facing = c-&gt;params[3];
+                SBuildUnitCommand* cmd = (SBuildUnitCommand*) malloc(sizeof (SBuildUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;toBuildUnitDefId = toBuildUnitDefId;
+                cmd-&gt;buildPos = buildPos;
+                cmd-&gt;facing = facing;
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_BUILD;
+            } else { // CMD_CUSTOM
+                int cmdId = c-&gt;id;
+                int numParams = c-&gt;params.size();
+                SCustomUnitCommand* cmd = (SCustomUnitCommand*) malloc(sizeof (SCustomUnitCommand));
+                cmd-&gt;unitId = unitId;
+                cmd-&gt;groupId = groupId;
+                cmd-&gt;options = c-&gt;options;
+                cmd-&gt;timeOut = c-&gt;timeOut;
+                cmd-&gt;cmdId = cmdId;
+                cmd-&gt;numParams = numParams;
+                cmd-&gt;params = (float*) calloc(numParams, sizeof(float));
+                int i;
+                for (i=0; i &lt; numParams; ++i) {
+                    cmd-&gt;params[i] = c-&gt;params.at(i);
+                }
+
+                sCommandData = cmd;
+                sCmdId = COMMAND_UNIT_CUSTOM;
+            }
+            break;
+        }
+
+    }
+
+    *sCommandId = sCmdId;
+    return sCommandData;
+}
+
+
+
+void* newCommand(void* sUnitCommandData, int sCommandId) {
+
+    Command* c = new Command();
+
+    switch (sCommandId) {
+        case COMMAND_UNIT_BUILD:
+        {
+            SBuildUnitCommand* cmd = (SBuildUnitCommand*) sUnitCommandData;
+            c-&gt;id = -cmd-&gt;toBuildUnitDefId;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;buildPos.x);
+            c-&gt;params.push_back(cmd-&gt;buildPos.y);
+            c-&gt;params.push_back(cmd-&gt;buildPos.z);
+            if (cmd-&gt;facing != UNIT_COMMAND_BUILD_NO_FACING) c-&gt;params.push_back(cmd-&gt;facing);
+            break;
+        }
+        case COMMAND_UNIT_STOP:
+        {
+            SStopUnitCommand* cmd = (SStopUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_STOP;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+            break;
+        }
+        case COMMAND_UNIT_WAIT:
+        {
+            SWaitUnitCommand* cmd = (SWaitUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_WAIT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+            break;
+        }
+        case COMMAND_UNIT_WAIT_TIME:
+        {
+            STimeWaitUnitCommand* cmd = (STimeWaitUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_WAITCODE_TIMEWAIT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;time);
+            break;
+        }
+        case COMMAND_UNIT_WAIT_DEATH:
+        {
+            SDeathWaitUnitCommand* cmd = (SDeathWaitUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_WAITCODE_DEATHWAIT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toDieUnitId);
+            break;
+        }
+        case COMMAND_UNIT_WAIT_SQUAD:
+        {
+            SSquadWaitUnitCommand* cmd = (SSquadWaitUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_WAITCODE_SQUADWAIT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;numUnits);
+            break;
+        }
+        case COMMAND_UNIT_WAIT_GATHER:
+        {
+            SGatherWaitUnitCommand* cmd = (SGatherWaitUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_WAITCODE_GATHERWAIT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+            break;
+        }
+        case COMMAND_UNIT_MOVE:
+        {
+            SMoveUnitCommand* cmd = (SMoveUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_MOVE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toPos.x);
+            c-&gt;params.push_back(cmd-&gt;toPos.y);
+            c-&gt;params.push_back(cmd-&gt;toPos.z);
+            break;
+        }
+        case COMMAND_UNIT_PATROL:
+        {
+            SPatrolUnitCommand* cmd = (SPatrolUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_PATROL;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toPos.x);
+            c-&gt;params.push_back(cmd-&gt;toPos.y);
+            c-&gt;params.push_back(cmd-&gt;toPos.z);
+            break;
+        }
+        case COMMAND_UNIT_FIGHT:
+        {
+            SFightUnitCommand* cmd = (SFightUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_FIGHT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toPos.x);
+            c-&gt;params.push_back(cmd-&gt;toPos.y);
+            c-&gt;params.push_back(cmd-&gt;toPos.z);
+            break;
+        }
+        case COMMAND_UNIT_ATTACK:
+        {
+            SAttackUnitCommand* cmd = (SAttackUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_ATTACK;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toAttackUnitId);
+            break;
+        }
+        case COMMAND_UNIT_ATTACK_AREA:
+        {
+            SAttackAreaUnitCommand* cmd = (SAttackAreaUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_ATTACK;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toAttackPos.x);
+            c-&gt;params.push_back(cmd-&gt;toAttackPos.y);
+            c-&gt;params.push_back(cmd-&gt;toAttackPos.z);
+            c-&gt;params.push_back(cmd-&gt;radius);
+            break;
+        }
+        case COMMAND_UNIT_GUARD:
+        {
+            SGuardUnitCommand* cmd = (SGuardUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_GUARD;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toGuardUnitId);
+            break;
+        }
+        case COMMAND_UNIT_AI_SELECT:
+        {
+            SAiSelectUnitCommand* cmd = (SAiSelectUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_AISELECT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+            break;
+        }
+        case COMMAND_UNIT_GROUP_ADD:
+        {
+            SGroupAddUnitCommand* cmd = (SGroupAddUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_GROUPADD;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toGroupId);
+            break;
+        }
+        case COMMAND_UNIT_GROUP_CLEAR:
+        {
+            SGroupClearUnitCommand* cmd = (SGroupClearUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_GROUPCLEAR;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+            break;
+        }
+        case COMMAND_UNIT_REPAIR:
+        {
+            SRepairUnitCommand* cmd = (SRepairUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_REPAIR;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toRepairUnitId);
+            break;
+        }
+        case COMMAND_UNIT_SET_FIRE_STATE:
+        {
+            SSetFireStateUnitCommand* cmd = (SSetFireStateUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_FIRE_STATE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;fireState);
+            break;
+        }
+        case COMMAND_UNIT_SET_MOVE_STATE:
+        {
+            SSetMoveStateUnitCommand* cmd = (SSetMoveStateUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_MOVE_STATE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;moveState);
+            break;
+        }
+        case COMMAND_UNIT_SET_BASE:
+        {
+            SSetBaseUnitCommand* cmd = (SSetBaseUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_SETBASE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;basePos.x);
+            c-&gt;params.push_back(cmd-&gt;basePos.y);
+            c-&gt;params.push_back(cmd-&gt;basePos.z);
+            break;
+        }
+        case COMMAND_UNIT_SELF_DESTROY:
+        {
+            SSelfDestroyUnitCommand* cmd = (SSelfDestroyUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_SELFD;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+            break;
+        }
+        case COMMAND_UNIT_SET_WANTED_MAX_SPEED:
+        {
+            SSetWantedMaxSpeedUnitCommand* cmd = (SSetWantedMaxSpeedUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_SET_WANTED_MAX_SPEED;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;wantedMaxSpeed);
+            break;
+        }
+        case COMMAND_UNIT_LOAD_UNITS:
+        {
+            SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_LOAD_UNITS;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            for (int i = 0; i &lt; cmd-&gt;numToLoadUnits; ++i) {
+                c-&gt;params.push_back(cmd-&gt;toLoadUnitIds[i]);
+            }
+            break;
+        }
+        case COMMAND_UNIT_LOAD_UNITS_AREA:
+        {
+            SLoadUnitsAreaUnitCommand* cmd = (SLoadUnitsAreaUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_LOAD_UNITS;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;pos.x);
+            c-&gt;params.push_back(cmd-&gt;pos.y);
+            c-&gt;params.push_back(cmd-&gt;pos.z);
+            c-&gt;params.push_back(cmd-&gt;radius);
+            break;
+        }
+        case COMMAND_UNIT_LOAD_ONTO:
+        {
+            SLoadOntoUnitCommand* cmd = (SLoadOntoUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_LOAD_ONTO;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;transporterUnitId);
+            break;
+        }
+        case COMMAND_UNIT_UNLOAD_UNITS_AREA:
+        {
+            SUnloadUnitsAreaUnitCommand* cmd = (SUnloadUnitsAreaUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_UNLOAD_UNITS;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toPos.x);
+            c-&gt;params.push_back(cmd-&gt;toPos.y);
+            c-&gt;params.push_back(cmd-&gt;toPos.z);
+            c-&gt;params.push_back(cmd-&gt;radius);
+            break;
+        }
+        case COMMAND_UNIT_UNLOAD_UNIT:
+        {
+            SUnloadUnitCommand* cmd = (SUnloadUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_UNLOAD_UNIT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toPos.x);
+            c-&gt;params.push_back(cmd-&gt;toPos.y);
+            c-&gt;params.push_back(cmd-&gt;toPos.z);
+            c-&gt;params.push_back(cmd-&gt;toUnloadUnitId);
+            break;
+        }
+        case COMMAND_UNIT_SET_ON_OFF:
+        {
+            SSetOnOffUnitCommand* cmd = (SSetOnOffUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_ONOFF;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;on);
+            break;
+        }
+        case COMMAND_UNIT_RECLAIM:
+        {
+            SReclaimUnitCommand* cmd = (SReclaimUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_RECLAIM;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toReclaimUnitIdOrFeatureId);
+            break;
+        }
+        case COMMAND_UNIT_RECLAIM_AREA:
+        {
+            SReclaimAreaUnitCommand* cmd = (SReclaimAreaUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_RECLAIM;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;pos.x);
+            c-&gt;params.push_back(cmd-&gt;pos.y);
+            c-&gt;params.push_back(cmd-&gt;pos.z);
+            c-&gt;params.push_back(cmd-&gt;radius);
+            break;
+        }
+        case COMMAND_UNIT_CLOAK:
+        {
+            SCloakUnitCommand* cmd = (SCloakUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_CLOAK;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;cloak);
+            break;
+        }
+        case COMMAND_UNIT_STOCKPILE:
+        {
+            SStockpileUnitCommand* cmd = (SStockpileUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_STOCKPILE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+            break;
+        }
+        case COMMAND_UNIT_D_GUN:
+        {
+            SDGunUnitCommand* cmd = (SDGunUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_DGUN;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toAttackUnitId);
+            break;
+        }
+        case COMMAND_UNIT_D_GUN_POS:
+        {
+            SDGunPosUnitCommand* cmd = (SDGunPosUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_DGUN;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;pos.x);
+            c-&gt;params.push_back(cmd-&gt;pos.y);
+            c-&gt;params.push_back(cmd-&gt;pos.z);
+            break;
+        }
+        case COMMAND_UNIT_RESTORE_AREA:
+        {
+            SRestoreAreaUnitCommand* cmd = (SRestoreAreaUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_RESTORE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;pos.x);
+            c-&gt;params.push_back(cmd-&gt;pos.y);
+            c-&gt;params.push_back(cmd-&gt;pos.z);
+            c-&gt;params.push_back(cmd-&gt;radius);
+            break;
+        }
+        case COMMAND_UNIT_SET_REPEAT:
+        {
+            SSetRepeatUnitCommand* cmd = (SSetRepeatUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_REPEAT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;repeat);
+            break;
+        }
+        case COMMAND_UNIT_SET_TRAJECTORY:
+        {
+            SSetTrajectoryUnitCommand* cmd = (SSetTrajectoryUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_TRAJECTORY;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;trajectory);
+            break;
+        }
+        case COMMAND_UNIT_RESURRECT:
+        {
+            SResurrectUnitCommand* cmd = (SResurrectUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_RESURRECT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toResurrectFeatureId);
+            break;
+        }
+        case COMMAND_UNIT_RESURRECT_AREA:
+        {
+            SResurrectAreaUnitCommand* cmd = (SResurrectAreaUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_RESURRECT;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;pos.x);
+            c-&gt;params.push_back(cmd-&gt;pos.y);
+            c-&gt;params.push_back(cmd-&gt;pos.z);
+            c-&gt;params.push_back(cmd-&gt;radius);
+            break;
+        }
+        case COMMAND_UNIT_CAPTURE:
+        {
+            SCaptureUnitCommand* cmd = (SCaptureUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_CAPTURE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;toCaptureUnitId);
+            break;
+        }
+        case COMMAND_UNIT_CAPTURE_AREA:
+        {
+            SCaptureAreaUnitCommand* cmd = (SCaptureAreaUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_CAPTURE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;pos.x);
+            c-&gt;params.push_back(cmd-&gt;pos.y);
+            c-&gt;params.push_back(cmd-&gt;pos.z);
+            c-&gt;params.push_back(cmd-&gt;radius);
+            break;
+        }
+        case COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL:
+        {
+            SSetAutoRepairLevelUnitCommand* cmd = (SSetAutoRepairLevelUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_AUTOREPAIRLEVEL;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;autoRepairLevel);
+            break;
+        }
+        case COMMAND_UNIT_SET_IDLE_MODE:
+        {
+            SSetIdleModeUnitCommand* cmd = (SSetIdleModeUnitCommand*) sUnitCommandData;
+            c-&gt;id = CMD_IDLEMODE;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            c-&gt;params.push_back(cmd-&gt;idleMode);
+            break;
+        }
+        case COMMAND_UNIT_CUSTOM:
+        {
+            SCustomUnitCommand* cmd = (SCustomUnitCommand*) sUnitCommandData;
+            c-&gt;id = cmd-&gt;cmdId;
+            c-&gt;options = cmd-&gt;options;
+            c-&gt;timeOut = cmd-&gt;timeOut;
+
+            for (int i = 0; i &lt; cmd-&gt;numParams; ++i) {
+                c-&gt;params.push_back(cmd-&gt;params[i]);
+            }
+            break;
+        }
+        default:
+        {
+            delete c;
+            c = NULL;
+        }
+    }
+
+    return c;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/AISCommands.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AISCommands.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AISCommands.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AISCommands.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,788 @@
+/*
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AISCOMMANDS_H
+#define	_AISCOMMANDS_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;SAIFloat3.h&quot;
+	
+
+#define COMMAND_TO_ID_ENGINE -1
+	
+	
+#define COMMAND_NULL 0
+#define COMMAND_DRAWER_POINT_ADD 1
+#define COMMAND_DRAWER_LINE_ADD 2
+#define COMMAND_DRAWER_POINT_REMOVE 3
+#define COMMAND_SEND_START_POS 4
+#define COMMAND_CHEATS_SET_MY_HANDICAP 5
+#define COMMAND_SEND_TEXT_MESSAGE 6
+#define COMMAND_SET_LAST_POS_MESSAGE 7
+#define COMMAND_SEND_RESOURCES 8
+#define COMMAND_SEND_UNITS 9
+#define COMMAND_SHARED_MEM_AREA_CREATE 10
+#define COMMAND_SHARED_MEM_AREA_RELEASE 11
+#define COMMAND_GROUP_CREATE 12
+#define COMMAND_GROUP_ERASE 13
+#define COMMAND_GROUP_ADD_UNIT 14
+#define COMMAND_GROUP_REMOVE_UNIT 15
+#define COMMAND_PATH_INIT 16
+#define COMMAND_PATH_GET_APPROXIMATE_LENGTH 17
+#define COMMAND_PATH_GET_NEXT_WAYPOINT 18
+#define COMMAND_PATH_FREE 19
+#define COMMAND_CHEATS_GIVE_ME_METAL 20
+#define COMMAND_CALL_LUA_RULES 21
+#define COMMAND_DRAWER_ADD_NOTIFICATION 22
+#define COMMAND_DRAWER_DRAW_UNIT 23
+#define COMMAND_DRAWER_PATH_START 24
+#define COMMAND_DRAWER_PATH_FINISH 25
+#define COMMAND_DRAWER_PATH_DRAW_LINE 26
+#define COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON 27
+#define COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS 28
+#define COMMAND_DRAWER_PATH_BREAK 29
+#define COMMAND_DRAWER_PATH_RESTART 30
+#define COMMAND_DRAWER_FIGURE_CREATE_SPLINE 31
+#define COMMAND_DRAWER_FIGURE_CREATE_LINE 32
+#define COMMAND_DRAWER_FIGURE_SET_COLOR 33
+#define COMMAND_DRAWER_FIGURE_DELETE 34
+#define COMMAND_UNIT_BUILD 35
+#define COMMAND_UNIT_STOP 36
+#define COMMAND_UNIT_WAIT 37
+#define COMMAND_UNIT_WAIT_TIME 38
+#define COMMAND_UNIT_WAIT_DEATH 39
+#define COMMAND_UNIT_WAIT_SQUAD 40
+#define COMMAND_UNIT_WAIT_GATHER 41
+#define COMMAND_UNIT_MOVE 42
+#define COMMAND_UNIT_PATROL 43
+#define COMMAND_UNIT_FIGHT 44
+#define COMMAND_UNIT_ATTACK 45
+#define COMMAND_UNIT_ATTACK_AREA 46
+#define COMMAND_UNIT_GUARD 47
+#define COMMAND_UNIT_AI_SELECT 48
+#define COMMAND_UNIT_GROUP_ADD 49
+#define COMMAND_UNIT_GROUP_CLEAR 50
+#define COMMAND_UNIT_REPAIR 51
+#define COMMAND_UNIT_SET_FIRE_STATE 52
+#define COMMAND_UNIT_SET_MOVE_STATE 53
+#define COMMAND_UNIT_SET_BASE 54
+#define COMMAND_UNIT_SELF_DESTROY 55
+#define COMMAND_UNIT_SET_WANTED_MAX_SPEED 56
+#define COMMAND_UNIT_LOAD_UNITS 57
+#define COMMAND_UNIT_LOAD_UNITS_AREA 58
+#define COMMAND_UNIT_LOAD_ONTO 59
+#define COMMAND_UNIT_UNLOAD_UNITS_AREA 60
+#define COMMAND_UNIT_UNLOAD_UNIT 61
+#define COMMAND_UNIT_SET_ON_OFF 62
+#define COMMAND_UNIT_RECLAIM 63
+#define COMMAND_UNIT_RECLAIM_AREA 64
+#define COMMAND_UNIT_CLOAK 65
+#define COMMAND_UNIT_STOCKPILE 66
+#define COMMAND_UNIT_D_GUN 67
+#define COMMAND_UNIT_D_GUN_POS 68
+#define COMMAND_UNIT_RESTORE_AREA 69
+#define COMMAND_UNIT_SET_REPEAT 70
+#define COMMAND_UNIT_SET_TRAJECTORY 71
+#define COMMAND_UNIT_RESURRECT 72
+#define COMMAND_UNIT_RESURRECT_AREA 73
+#define COMMAND_UNIT_CAPTURE 74
+#define COMMAND_UNIT_CAPTURE_AREA 75
+#define COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL 76
+#define COMMAND_UNIT_SET_IDLE_MODE 77
+#define COMMAND_UNIT_CUSTOM 78
+//#define COMMAND_UNIT_ATTACK_POS 
+//#define COMMAND_UNIT_INSERT 
+//#define COMMAND_UNIT_REMOVE 
+//#define COMMAND_UNIT_ATTACK_AREA 
+//#define COMMAND_UNIT_ATTACK_LOOPBACK 
+//#define COMMAND_UNIT_GROUP_SELECT 
+//#define COMMAND_UNIT_INTERNAL 
+#define COMMAND_CHEATS_GIVE_ME_ENERGY 79
+#define COMMAND_CHEATS_GIVE_ME_NEW_UNIT 80
+
+#define NUM_CMD_TOPICS 81
+
+	
+#define UNIT_COMMAND_OPTION_DONT_REPEAT	 (1 &lt;&lt; 3) //   8
+#define UNIT_COMMAND_OPTION_RIGHT_MOUSE_KEY (1 &lt;&lt; 4) //  16
+#define UNIT_COMMAND_OPTION_SHIFT_KEY	   (1 &lt;&lt; 5) //  32
+#define UNIT_COMMAND_OPTION_CONTROL_KEY	 (1 &lt;&lt; 6) //  64
+#define UNIT_COMMAND_OPTION_ALT_KEY		 (1 &lt;&lt; 7) // 128
+
+
+#define UNIT_COMMAND_BUILD_NO_FACING -1
+
+	
+	
+	struct SSetMyHandicapCheatCommand {
+		float handicap;
+	};
+	struct SGiveMeMetalCheatCommand {
+		float amount;
+	};
+	struct SGiveMeEnergyCheatCommand {
+		float amount;
+	};
+	struct SGiveMeNewUnitCheatCommand {
+		int unitDefId;
+		SAIFloat3 pos;
+		int ret_newUnitId;
+	};
+	
+	struct SSendTextMessageCommand {
+		const char* text;
+		int zone;
+	};
+
+	struct SSetLastPosMessageCommand {
+		SAIFloat3 pos;
+	};
+
+	struct SSendResourcesCommand {
+		float mAmount;
+		float eAmount;
+		int receivingTeam;
+		bool ret_isExecuted;
+	};
+
+	struct SSendUnitsCommand {
+		int* unitIds;
+		int numUnitIds;
+		int receivingTeam;
+		int ret_sentUnits;
+	};
+
+	struct SCreateSharedMemAreaCommand {
+		char* name;
+		int size;
+		void* ret_sharedMemArea;
+	};
+
+	struct SReleaseSharedMemAreaCommand {
+		char* name;
+	};
+
+	struct SCreateGroupCommand {
+		char* libraryName;
+		unsigned int aiNumber;
+		int ret_groupId;
+	};
+	struct SEraseGroupCommand {
+		int groupId;
+	};
+	struct SAddUnitToGroupCommand {
+		int groupId;
+		int unitId;
+		bool ret_isExecuted;
+	};
+	struct SRemoveUnitFromGroupCommand {
+		int unitId;
+		bool ret_isExecuted;
+	};
+
+	
+	struct SInitPathCommand {
+		SAIFloat3 start;
+		SAIFloat3 end;
+		int pathType;
+		int ret_pathId;
+	};
+	/**
+	 * Returns the approximate path cost between two points
+	 * note: needs to calculate the complete path so somewhat expensive
+	 * note: currently disabled, always returns 0
+	 */
+	struct SGetApproximateLengthPathCommand {
+		SAIFloat3 start;
+		SAIFloat3 end;
+		int pathType;
+		int ret_approximatePathLength;
+	};
+	struct SGetNextWaypointPathCommand {
+		int pathId;
+		SAIFloat3 ret_nextWaypoint;
+	};
+	struct SFreePathCommand {
+		int pathId;
+	};
+
+	struct SCallLuaRulesCommand {
+		const char* data;
+		int inSize;
+		int* outSize;
+		const char* ret_outData;
+	};
+
+	struct SSendStartPosCommand ///&lt; result of HandleCommand is 1 - ok supported
+	{
+		bool ready;
+		SAIFloat3 pos;
+	};
+
+	struct SAddNotificationDrawerCommand {
+		SAIFloat3 pos;
+		SAIFloat3 color;
+		float alpha;
+	};
+	struct SAddPointDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
+	{
+		SAIFloat3 pos; ///&lt; on this position, only x and z matter
+		char* label; ///&lt; create this text on pos in my team color
+	};
+	struct SRemovePointDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
+	{
+		SAIFloat3 pos; ///&lt; remove map points and lines near this point (100 distance)
+	};
+	struct SAddLineDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
+	{
+		SAIFloat3 posFrom; ///&lt; draw line from this pos
+		SAIFloat3 posTo; ///&lt; to this pos, again only x and z matter
+	};
+	
+	struct SStartPathDrawerCommand {
+		SAIFloat3 pos;
+		SAIFloat3 color;
+		float alpha;
+	};
+	struct SFinishPathDrawerCommand {
+	};
+	struct SDrawLinePathDrawerCommand {
+		SAIFloat3 endPos;
+		SAIFloat3 color;
+		float alpha;
+	};
+	struct SDrawLineAndIconPathDrawerCommand {
+		int cmdId;
+		SAIFloat3 endPos;
+		SAIFloat3 color;
+		float alpha;
+	};
+	struct SDrawIconAtLastPosPathDrawerCommand {
+		int cmdId;
+	};
+	struct SBreakPathDrawerCommand {
+		SAIFloat3 endPos;
+		SAIFloat3 color;
+		float alpha;
+	};
+	struct SRestartPathDrawerCommand {
+		bool sameColor;
+	};
+
+	/**
+	 * Creates a cubic Bezier spline figure (from pos1 to pos4 with control points pos2 and pos3)
+	 */
+	struct SCreateSplineFigureDrawerCommand {
+		SAIFloat3 pos1;
+		SAIFloat3 pos2;
+		SAIFloat3 pos3;
+		SAIFloat3 pos4;
+		float width;
+		bool arrow; // true: means that the figure will get an arrow at the end
+		int lifeTime; // how many frames a figure should live before being autoremoved, 0 means no removal
+		int figureGroupId; // use 0 to get a new group
+		int ret_newFigureGroupId; // the new group
+	};
+	struct SCreateLineFigureDrawerCommand {
+		SAIFloat3 pos1;
+		SAIFloat3 pos2;
+		float width;
+		bool arrow; // true: means that the figure will get an arrow at the end
+		int lifeTime; // how many frames a figure should live before being autoremoved, 0 means no removal
+		int figureGroupId; // use 0 to get a new group
+		int ret_newFigureGroupId; // the new group
+	};
+	struct SSetColorFigureDrawerCommand {
+		int figureGroupId;
+		SAIFloat3 color;
+		float alpha;
+	};
+	struct SDeleteFigureDrawerCommand {
+		int figureGroupId;
+	};
+
+	struct SDrawUnitDrawerCommand {
+		int toDrawUnitDefId;
+		SAIFloat3 pos;
+		float rotation;
+		int lifeTime;
+		int teamId;
+		bool transparent;
+		bool drawBorder;
+		int facing;
+	};
+
+	
+	
+	struct SBuildUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toBuildUnitDefId;
+		SAIFloat3 buildPos;
+		int facing; // set to UNIT_COMMAND_BUILD_NO_FACING if you want to specify no facing
+	};
+
+	struct SStopUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+	};	
+
+//	struct SInsertUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+//
+//	struct SRemoveUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+	struct SWaitUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+	};	
+
+	struct STimeWaitUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		// the time in seconds to wait
+		int time;
+	};	
+
+	struct SDeathWaitUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		// wait until this unit is dead
+		int toDieUnitId;
+	};	
+
+	struct SSquadWaitUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int numUnits;
+	};	
+
+	struct SGatherWaitUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+	};	
+
+	struct SMoveUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 toPos;
+	};	
+
+	struct SPatrolUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 toPos;
+	};	
+
+	struct SFightUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 toPos;
+	};	
+
+	struct SAttackUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toAttackUnitId;
+	};	
+
+//	struct SAttackPosUnitCommand {
+	struct SAttackAreaUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 toAttackPos;
+		float radius;
+	};	
+
+//	struct SAttackAreaUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+	struct SGuardUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toGuardUnitId;
+	};	
+
+	struct SAiSelectUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+	};	
+
+//	struct SGroupSelectUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+	struct SGroupAddUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toGroupId;
+	};	
+
+	struct SGroupClearUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+	};	
+
+	struct SRepairUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toRepairUnitId;
+	};	
+
+	struct SSetFireStateUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		// can be: 0=hold fire, 1=return fire, 2=fire at will
+		int fireState;
+	};	
+
+	struct SSetMoveStateUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int moveState;
+	};	
+
+	struct SSetBaseUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 basePos;
+	};	
+
+//	struct SInternalUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+	struct SSelfDestroyUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+	};	
+
+	struct SSetWantedMaxSpeedUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		float wantedMaxSpeed;
+	};	
+
+	struct SLoadUnitsUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int* toLoadUnitIds;
+		int numToLoadUnits;
+	};	
+
+	struct SLoadUnitsAreaUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 pos;
+		float radius;
+	};	
+
+	struct SLoadOntoUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int transporterUnitId;
+	};	
+
+	struct SUnloadUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 toPos;
+		int toUnloadUnitId;
+	};	
+
+	struct SUnloadUnitsAreaUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 toPos;
+		float radius;
+	};	
+
+	struct SSetOnOffUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		bool on;
+	};	
+
+	struct SReclaimUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toReclaimUnitIdOrFeatureId;
+	};	
+
+	struct SReclaimAreaUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 pos;
+		float radius;
+	};	
+
+	struct SCloakUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		bool cloak;
+	};	
+
+	struct SStockpileUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+	};	
+
+	struct SDGunUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toAttackUnitId;
+	};	
+
+	struct SDGunPosUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 pos;
+	};	
+
+	struct SRestoreAreaUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 pos;
+		float radius;
+	};	
+
+	struct SSetRepeatUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		bool repeat;
+	};	
+
+	struct SSetTrajectoryUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int trajectory;
+	};	
+
+	struct SResurrectUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toResurrectFeatureId;
+	};	
+
+	struct SResurrectAreaUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 pos;
+		float radius;
+	};	
+
+	struct SCaptureUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int toCaptureUnitId;
+	};	
+
+	struct SCaptureAreaUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		SAIFloat3 pos;
+		float radius;
+	};	
+
+	struct SSetAutoRepairLevelUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int autoRepairLevel;
+	};	
+
+//	struct SAttackLoopbackUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+	struct SSetIdleModeUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int idleMode;
+	};	
+
+	struct SCustomUnitCommand {
+		int unitId;
+		int groupId;
+		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+		int timeOut; // command execution-time in ?seconds?
+		
+		int cmdId;
+		float* params;
+		int numParams;
+	};
+
+	
+void initSUnitCommand(void* sUnitCommand);
+
+// legacy support functions
+// the void* c has to be of type Command*
+void* mallocSUnitCommand(int unitId, int groupId, void* c, int sCommandId[0]);
+void freeSUnitCommand(void* sCommandData, int sCommandId);
+// the returned void* is a Command*
+void* newCommand(void* sUnitCommandData, int sCommandId);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _AISCOMMANDS_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/AISCommands.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AISEvents.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AISEvents.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AISEvents.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,149 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AISEVENTS_H
+#define AISEVENTS_H
+
+#include &quot;SAIFloat3.h&quot;
+#include &quot;SAICallback.h&quot;
+
+#define EVENT_NULL				0
+#define EVENT_INIT				1
+#define EVENT_UPDATE			2
+#define EVENT_MESSAGE			3
+#define EVENT_UNIT_CREATED		4
+#define EVENT_UNIT_FINISHED		5
+#define EVENT_UNIT_IDLE			6
+#define EVENT_UNIT_MOVE_FAILED	7
+#define EVENT_UNIT_DAMAGED		8
+#define EVENT_UNIT_DESTROYED	9
+#define EVENT_UNIT_GIVEN		10
+#define EVENT_UNIT_CAPTURED		11
+#define EVENT_ENEMY_ENTER_LOS	12
+#define EVENT_ENEMY_LEAVE_LOS	13
+#define EVENT_ENEMY_ENTER_RADAR 14
+#define EVENT_ENEMY_LEAVE_RADAR 15
+#define EVENT_ENEMY_DAMAGED		16
+#define EVENT_ENEMY_DESTROYED	17
+#define EVENT_WEAPON_FIRED		18
+#define EVENT_PLAYER_COMMAND	19
+#define EVENT_SEISMIC_PING		20
+
+#define NUM_EVENTS				21
+
+
+struct SInitEvent {
+	int team;
+	SAICallback* c_callback;
+};
+
+struct SUpdateEvent {
+	int frame;
+};
+
+struct SMessageEvent {
+	int player;
+	const char* message;
+};
+
+struct SUnitCreatedEvent {
+	int unit;
+};
+
+struct SUnitFinishedEvent {
+	int unit;
+};
+
+struct SUnitIdleEvent {
+	int unit;
+};
+
+struct SUnitMoveFailedEvent {
+	int unit;
+};
+
+struct SUnitDamagedEvent {
+	int unit;
+	int attacker;
+	float damage;
+	SAIFloat3 dir;
+};
+
+struct SUnitDestroyedEvent {
+	int unit;
+	int attacker;
+};
+
+struct SUnitGivenEvent {
+	int unitId;
+	int oldTeamId;
+	int newTeamId;
+};
+
+struct SUnitCapturedEvent {
+	int unitId;
+	int oldTeamId;
+	int newTeamId;
+};
+
+struct SEnemyEnterLOSEvent {
+	int enemy;
+};
+
+struct SEnemyLeaveLOSEvent {
+	int enemy;
+};
+
+struct SEnemyEnterRadarEvent {
+	int enemy;
+};
+
+struct SEnemyLeaveRadarEvent {
+	int enemy;
+};
+
+struct SEnemyDamagedEvent {
+	int enemy;
+	int attacker;
+	float damage;
+	SAIFloat3 dir;
+};
+
+struct SEnemyDestroyedEvent {
+	int enemy;
+	int attacker;
+};
+
+struct SWeaponFiredEvent {
+	int unitId;
+	int weaponDefId;
+};
+
+struct SPlayerCommandEvent {
+	int* unitIds;
+	int numUnitIds;
+	int commandTopic; // see AISCommands.h COMMAND_* defines
+	void* commandData; // see AISCommands.h S*Command structs
+	int playerId;
+};
+
+struct SSeismicPingEvent {
+	SAIFloat3 pos;
+	float strength;
+};
+
+#endif /*AISEVENTS_H*/


Property changes on: branches/caiinterface/rts/ExternalAI/AISEvents.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/ExternalAI/GlobalAI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAI.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/rts/ExternalAI/GlobalAI.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -3,7 +3,6 @@
 #include &quot;IGlobalAI.h&quot;
 #include &quot;GlobalAICallback.h&quot;
 #include &quot;GlobalAIHandler.h&quot;
-#include &quot;GroupHandler.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Platform/SharedLib.h&quot;
@@ -47,6 +46,10 @@
 		} else throw;						\
 	}
 
+CGlobalAI::CGlobalAI() {
+    
+}
+
 CGlobalAI::CGlobalAI(int team, const char* botLibName): team(team), cheatevents(false), libName(botLibName? botLibName: &quot;&quot;)
 {
 	LoadAILib(team, botLibName, false);

Modified: branches/caiinterface/rts/ExternalAI/GlobalAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAI.h	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/rts/ExternalAI/GlobalAI.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -12,18 +12,19 @@
 {
 public:
 	CR_DECLARE(CGlobalAI);
+	CGlobalAI();
 	CGlobalAI(int team, const char* dll);
 	~CGlobalAI(void);
 
-	void LoadAILib(int, const char*, bool);
+	virtual void LoadAILib(int, const char*, bool);
 
 	void Serialize(creg::ISerializer *s);
 	void PostLoad();
-	void Load(std::istream *s);
-	void Save(std::ostream *s);
+	virtual void Load(std::istream *s);
+	virtual void Save(std::ostream *s);
 
-	void Update(void);
-	void PreDestroy(); // called just before all the units are destroyed
+	virtual void Update(void);
+	virtual void PreDestroy(); // called just before all the units are destroyed
 
 	int team;
 	bool cheatevents;

Modified: branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -1,3 +1,5 @@
+#include &lt;iostream&gt;
+
 #include &quot;StdAfx.h&quot;
 #include &quot;GlobalAIHandler.h&quot;
 #include &quot;GlobalAI.h&quot;
@@ -12,6 +14,8 @@
 #include &quot;System/Platform/errorhandler.h&quot;
 #include &quot;mmgr.h&quot;
 
+#include &quot;AILibraryGlobalAI.h&quot;
+
 CGlobalAIHandler* globalAI=0;
 
 CR_BIND_DERIVED(CGlobalAIHandler,CObject,)
@@ -241,8 +245,12 @@
 			ais[teamID] = 0;
 		}
 
-		ais[teamID] = SAFE_NEW CGlobalAI(teamID, dll);
-
+		//TODO : This is the crossover to the new AI
+		//Eventually we should rewrite a less hacky AILibraryHandler
+		//and change all calls to the global ai to be appropriate.
+		//ais[teamID] = SAFE_NEW CGlobalAI(teamID, dll);
+		ais[teamID] = SAFE_NEW CAILibraryGlobalAI(dll, teamID);
+		
 		if (!ais[teamID]-&gt;ai) {
 			delete ais[teamID];
 			ais[teamID] = 0;

Added: branches/caiinterface/rts/ExternalAI/SAICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAICallback.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SAICallback.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,3462 @@
+/*
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;SAICallback.h&quot;
+
+#include &quot;IGlobalAICallback.h&quot;
+#include &quot;IAICallback.h&quot;
+#include &quot;IAICheats.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+#include &quot;Sim/Features/FeatureDef.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+#include &quot;AISCommands.h&quot;
+
+
+IGlobalAICallback* team_globalCallback[MAX_AIS];
+IAICallback* team_callback[MAX_AIS];
+bool team_cheatingEnabled[MAX_AIS];
+IAICheats* team_cheatCallback[MAX_AIS];
+
+int fillCMap(const std::map&lt;std::string,std::string&gt;* map, const char* cMap[][2]) {
+	std::map&lt;std::string,std::string&gt;::const_iterator it;
+	int i;
+	for (i=0, it=map-&gt;begin(); it != map-&gt;end(); ++i, it++) {
+		cMap[i][0] = it-&gt;first.c_str();
+		cMap[i][1] = it-&gt;second.c_str();
+	}
+	return i;
+}
+void toFloatArr(const SAIFloat3* color, float alpha, float arrColor[4]) {
+	arrColor[0] = color-&gt;x;
+	arrColor[1] = color-&gt;y;
+	arrColor[2] = color-&gt;z;
+	arrColor[3] = alpha;
+}
+void fillVector(std::vector&lt;int&gt;* vector_unitIds, int* unitIds, int numUnitIds) {
+	for (int i=0; i &lt; numUnitIds; ++i) {
+		vector_unitIds-&gt;push_back(unitIds[i]);
+	}
+}
+
+const UnitDef* getUnitDefById(int teamId, int unitDefId) {
+	AIHCGetUnitDefById cmd = {unitDefId, NULL};
+	int ret = team_callback[teamId]-&gt;HandleCommand(AIHCGetUnitDefByIdId, &amp;cmd);
+	if (ret == 1) {
+		return cmd.ret;
+	} else {
+		return NULL;
+	}
+}
+const WeaponDef* getWeaponDefById(int teamId, int weaponDefId) {
+	AIHCGetWeaponDefById cmd = {weaponDefId, NULL};
+	int ret = team_callback[teamId]-&gt;HandleCommand(AIHCGetWeaponDefByIdId, &amp;cmd);
+	if (ret == 1) {
+		return cmd.ret;
+	} else {
+		return NULL;
+	}
+}
+const FeatureDef* getFeatureDefById(int teamId, int featureDefId) {
+	AIHCGetFeatureDefById cmd = {featureDefId, NULL};
+	int ret = team_callback[teamId]-&gt;HandleCommand(AIHCGetFeatureDefByIdId, &amp;cmd);
+	if (ret == 1) {
+		return cmd.ret;
+	} else {
+		return NULL;
+	}
+}
+
+int wrapper_HandleCommand(IAICallback* clb, IAICheats* clbCheat, int cmdId, void* cmdData) {
+	
+	int ret;
+	
+	if (clbCheat != NULL) {
+		ret = clbCheat-&gt;HandleCommand(cmdId, cmdData);
+	} else {
+		ret = clb-&gt;HandleCommand(cmdId, cmdData);
+	}
+	
+	return ret;
+}
+
+int _handleCommand(int teamId, int toId, int commandId, int commandTopic, void* commandData) {
+
+	int ret = 0;
+
+	IAICallback* clb = team_callback[teamId];
+	IAICheats* clbCheat = team_cheatCallback[teamId]; // if this is != NULL, cheating is enabled
+
+		
+	switch (commandTopic) {
+			
+		case COMMAND_CHEATS_SET_MY_HANDICAP:
+		{
+			SSetMyHandicapCheatCommand* cmd = (SSetMyHandicapCheatCommand*) commandData;
+			if (clbCheat != NULL) {
+				clbCheat-&gt;SetMyHandicap(cmd-&gt;handicap);
+				ret = 0;
+			} else {
+				ret = -1;
+			}
+			break;
+		}
+		case COMMAND_CHEATS_GIVE_ME_METAL:
+		{
+			SGiveMeMetalCheatCommand* cmd = (SGiveMeMetalCheatCommand*) commandData;
+			if (clbCheat != NULL) {
+				clbCheat-&gt;GiveMeMetal(cmd-&gt;amount);
+				ret = 0;
+			} else {
+				ret = -1;
+			}
+			break;
+		}
+		case COMMAND_CHEATS_GIVE_ME_ENERGY:
+		{
+			SGiveMeEnergyCheatCommand* cmd = (SGiveMeEnergyCheatCommand*) commandData;
+			if (clbCheat != NULL) {
+				clbCheat-&gt;GiveMeEnergy(cmd-&gt;amount);
+				ret = 0;
+			} else {
+				ret = -1;
+			}
+			break;
+		}
+		case COMMAND_CHEATS_GIVE_ME_NEW_UNIT:
+		{
+			SGiveMeNewUnitCheatCommand* cmd = (SGiveMeNewUnitCheatCommand*) commandData;
+			if (clbCheat != NULL) {
+				cmd-&gt;ret_newUnitId = clbCheat-&gt;CreateUnit(getUnitDefById(teamId, cmd-&gt;unitDefId)-&gt;name.c_str(), float3(cmd-&gt;pos));
+				if (cmd-&gt;ret_newUnitId &gt; 0) {
+					ret = 0;
+				} else {
+					ret = -2;
+				}
+			} else {
+				ret = -1;
+			}
+			break;
+		}
+	
+	
+		case COMMAND_SEND_START_POS:
+		{
+			SSendStartPosCommand* cmd = (SSendStartPosCommand*) commandData;
+			AIHCSendStartPos data = {cmd-&gt;ready, float3(cmd-&gt;pos)};
+			wrapper_HandleCommand(clb, clbCheat, AIHCSendStartPosId, &amp;data);
+			break;
+		}
+		case COMMAND_DRAWER_POINT_ADD:
+		{
+			SAddPointDrawCommand* cmd = (SAddPointDrawCommand*) commandData;
+			AIHCAddMapPoint data = {float3(cmd-&gt;pos), cmd-&gt;label};
+			wrapper_HandleCommand(clb, clbCheat, AIHCAddMapPointId, &amp;data);
+			break;
+		}
+		case COMMAND_DRAWER_POINT_REMOVE:
+		{
+			SRemovePointDrawCommand* cmd = (SRemovePointDrawCommand*) commandData;
+			AIHCRemoveMapPoint data = {float3(cmd-&gt;pos)};
+			wrapper_HandleCommand(clb, clbCheat, AIHCRemoveMapPointId, &amp;data);
+			break;
+		}
+		case COMMAND_DRAWER_LINE_ADD:
+		{
+			SAddLineDrawCommand* cmd = (SAddLineDrawCommand*) commandData;
+			AIHCAddMapLine data = {float3(cmd-&gt;posFrom), float3(cmd-&gt;posTo)};
+			wrapper_HandleCommand(clb, clbCheat, AIHCAddMapLineId, &amp;data);
+			break;
+		}
+		
+		
+		case COMMAND_SEND_TEXT_MESSAGE:
+		{
+			SSendTextMessageCommand* cmd = (SSendTextMessageCommand*) commandData;
+			clb-&gt;SendTextMsg(cmd-&gt;text, cmd-&gt;zone);
+			break;
+		}
+		case COMMAND_SET_LAST_POS_MESSAGE:
+		{
+			SSetLastPosMessageCommand* cmd = (SSetLastPosMessageCommand*) commandData;
+			clb-&gt;SetLastMsgPos(cmd-&gt;pos);
+			break;
+		}
+		case COMMAND_SEND_RESOURCES:
+		{
+			SSendResourcesCommand* cmd = (SSendResourcesCommand*) commandData;
+			cmd-&gt;ret_isExecuted = clb-&gt;SendResources(cmd-&gt;mAmount, cmd-&gt;eAmount, cmd-&gt;receivingTeam);
+			break;
+		}
+
+		case COMMAND_SEND_UNITS:
+		{
+			SSendUnitsCommand* cmd = (SSendUnitsCommand*) commandData;
+			std::vector&lt;int&gt; vector_unitIds;
+			fillVector(&amp;vector_unitIds, cmd-&gt;unitIds, cmd-&gt;numUnitIds);
+			cmd-&gt;ret_sentUnits = clb-&gt;SendUnits(vector_unitIds, cmd-&gt;receivingTeam);
+			break;
+		}
+
+		case COMMAND_SHARED_MEM_AREA_CREATE:
+		{
+			SCreateSharedMemAreaCommand* cmd = (SCreateSharedMemAreaCommand*) commandData;
+			cmd-&gt;ret_sharedMemArea = clb-&gt;CreateSharedMemArea(cmd-&gt;name, cmd-&gt;size);
+			break;
+		}
+		case COMMAND_SHARED_MEM_AREA_RELEASE:
+		{
+			SReleaseSharedMemAreaCommand* cmd = (SReleaseSharedMemAreaCommand*) commandData;
+			clb-&gt;ReleasedSharedMemArea(cmd-&gt;name);
+			break;
+		}
+
+		case COMMAND_GROUP_CREATE:
+		{
+			SCreateGroupCommand* cmd = (SCreateGroupCommand*) commandData;
+			cmd-&gt;ret_groupId = clb-&gt;CreateGroup(cmd-&gt;libraryName, cmd-&gt;aiNumber);
+			break;
+		}
+		case COMMAND_GROUP_ERASE:
+		{
+			SEraseGroupCommand* cmd = (SEraseGroupCommand*) commandData;
+			clb-&gt;EraseGroup(cmd-&gt;groupId);
+			break;
+		}
+		case COMMAND_GROUP_ADD_UNIT:
+		{
+			SAddUnitToGroupCommand* cmd = (SAddUnitToGroupCommand*) commandData;
+			cmd-&gt;ret_isExecuted = clb-&gt;AddUnitToGroup(cmd-&gt;unitId, cmd-&gt;groupId);
+			break;
+		}
+		case COMMAND_GROUP_REMOVE_UNIT:
+		{
+			SRemoveUnitFromGroupCommand* cmd = (SRemoveUnitFromGroupCommand*) commandData;
+			cmd-&gt;ret_isExecuted = clb-&gt;RemoveUnitFromGroup(cmd-&gt;unitId);
+			break;
+		}
+		case COMMAND_PATH_INIT:
+		{
+			SInitPathCommand* cmd = (SInitPathCommand*) commandData;
+			cmd-&gt;ret_pathId = clb-&gt;InitPath(float3(cmd-&gt;start), float3(cmd-&gt;end), cmd-&gt;pathType);
+			break;
+		}
+		case COMMAND_PATH_GET_APPROXIMATE_LENGTH:
+		{
+			SGetApproximateLengthPathCommand* cmd = (SGetApproximateLengthPathCommand*) commandData;
+			cmd-&gt;ret_approximatePathLength = clb-&gt;GetPathLength(float3(cmd-&gt;start), float3(cmd-&gt;end), cmd-&gt;pathType);
+			break;
+		}
+		case COMMAND_PATH_GET_NEXT_WAYPOINT:
+		{
+			SGetNextWaypointPathCommand* cmd = (SGetNextWaypointPathCommand*) commandData;
+			cmd-&gt;ret_nextWaypoint = clb-&gt;GetNextWaypoint(cmd-&gt;pathId).toSAIFloat3();
+			break;
+		}
+		case COMMAND_PATH_FREE:
+		{
+			SFreePathCommand* cmd = (SFreePathCommand*) commandData;
+			clb-&gt;FreePath(cmd-&gt;pathId);
+			break;
+		}
+		case COMMAND_CALL_LUA_RULES:
+		{
+			SCallLuaRulesCommand* cmd = (SCallLuaRulesCommand*) commandData;
+			cmd-&gt;ret_outData = clb-&gt;CallLuaRules(cmd-&gt;data, cmd-&gt;inSize, cmd-&gt;outSize);
+			break;
+		}
+
+
+		case COMMAND_DRAWER_ADD_NOTIFICATION:
+		{
+			SAddNotificationDrawerCommand* cmd = (SAddNotificationDrawerCommand*) commandData;
+			clb-&gt;AddNotification(float3(cmd-&gt;pos), float3(cmd-&gt;color), cmd-&gt;alpha);
+			break;
+		}
+		case COMMAND_DRAWER_PATH_START:
+		{
+			SStartPathDrawerCommand* cmd = (SStartPathDrawerCommand*) commandData;
+			float arrColor[4];
+			toFloatArr(&amp;cmd-&gt;color, cmd-&gt;alpha, arrColor);
+			clb-&gt;LineDrawerStartPath(float3(cmd-&gt;pos), arrColor);
+			break;
+		}
+		case COMMAND_DRAWER_PATH_FINISH:
+		{
+			//SFinishPathDrawerCommand* cmd = (SFinishPathDrawerCommand*) commandData;
+			clb-&gt;LineDrawerFinishPath();
+			break;
+		}
+		case COMMAND_DRAWER_PATH_DRAW_LINE:
+		{
+			SDrawLinePathDrawerCommand* cmd = (SDrawLinePathDrawerCommand*) commandData;
+			float arrColor[4];
+			toFloatArr(&amp;cmd-&gt;color, cmd-&gt;alpha, arrColor);
+			clb-&gt;LineDrawerDrawLine(float3(cmd-&gt;endPos), arrColor);
+			break;
+		}
+		case COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON:
+		{
+			SDrawLineAndIconPathDrawerCommand* cmd = (SDrawLineAndIconPathDrawerCommand*) commandData;
+			float arrColor[4];
+			toFloatArr(&amp;cmd-&gt;color, cmd-&gt;alpha, arrColor);
+			clb-&gt;LineDrawerDrawLineAndIcon(cmd-&gt;cmdId, float3(cmd-&gt;endPos), arrColor);
+			break;
+		}
+		case COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS:
+		{
+			SDrawIconAtLastPosPathDrawerCommand* cmd = (SDrawIconAtLastPosPathDrawerCommand*) commandData;
+			clb-&gt;LineDrawerDrawIconAtLastPos(cmd-&gt;cmdId);
+			break;
+		}
+		case COMMAND_DRAWER_PATH_BREAK:
+		{
+			SBreakPathDrawerCommand* cmd = (SBreakPathDrawerCommand*) commandData;
+			float arrColor[4];
+			toFloatArr(&amp;cmd-&gt;color, cmd-&gt;alpha, arrColor);
+			clb-&gt;LineDrawerBreak(float3(cmd-&gt;endPos), arrColor);
+			break;
+		}
+		case COMMAND_DRAWER_PATH_RESTART:
+		{
+			SRestartPathDrawerCommand* cmd = (SRestartPathDrawerCommand*) commandData;
+			if (cmd-&gt;sameColor) {
+				clb-&gt;LineDrawerRestartSameColor();
+			} else {
+				clb-&gt;LineDrawerRestart();
+			}
+			break;
+		}
+		case COMMAND_DRAWER_FIGURE_CREATE_SPLINE:
+		{
+			SCreateSplineFigureDrawerCommand* cmd = (SCreateSplineFigureDrawerCommand*) commandData;
+			cmd-&gt;ret_newFigureGroupId = clb-&gt;CreateSplineFigure(float3(cmd-&gt;pos1), float3(cmd-&gt;pos2), float3(cmd-&gt;pos3), float3(cmd-&gt;pos4), cmd-&gt;width, cmd-&gt;arrow, cmd-&gt;lifeTime, cmd-&gt;figureGroupId);
+			break;
+		}
+		case COMMAND_DRAWER_FIGURE_CREATE_LINE:
+		{
+			SCreateLineFigureDrawerCommand* cmd = (SCreateLineFigureDrawerCommand*) commandData;
+			cmd-&gt;ret_newFigureGroupId = clb-&gt;CreateLineFigure(float3(cmd-&gt;pos1), float3(cmd-&gt;pos2), cmd-&gt;width, cmd-&gt;arrow, cmd-&gt;lifeTime, cmd-&gt;figureGroupId);
+			break;
+		}
+		case COMMAND_DRAWER_FIGURE_SET_COLOR:
+		{
+			SSetColorFigureDrawerCommand* cmd = (SSetColorFigureDrawerCommand*) commandData;
+			clb-&gt;SetFigureColor(cmd-&gt;figureGroupId, cmd-&gt;color.x, cmd-&gt;color.y, cmd-&gt;color.z, cmd-&gt;alpha);
+			break;
+		}
+		case COMMAND_DRAWER_FIGURE_DELETE:
+		{
+			SDeleteFigureDrawerCommand* cmd = (SDeleteFigureDrawerCommand*) commandData;
+			clb-&gt;DeleteFigureGroup(cmd-&gt;figureGroupId);
+			break;
+		}
+		case COMMAND_DRAWER_DRAW_UNIT:
+		{
+			SDrawUnitDrawerCommand* cmd = (SDrawUnitDrawerCommand*) commandData;
+			clb-&gt;DrawUnit(getUnitDefById(teamId, cmd-&gt;toDrawUnitDefId)-&gt;name.c_str(), float3(cmd-&gt;pos), cmd-&gt;rotation, cmd-&gt;lifeTime, cmd-&gt;teamId, cmd-&gt;transparent, cmd-&gt;drawBorder, cmd-&gt;facing);
+			break;
+		}
+
+/*
+		case COMMAND_UNIT_BUILD:
+		{
+			SBuildUnitCommand* cmd = (SBuildUnitCommand*) commandData;
+			Command c;
+			c.id = -cmd-&gt;toBuildUnitDefId;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;buildPos.x);
+			c.params.push_back(cmd-&gt;buildPos.y);
+			c.params.push_back(cmd-&gt;buildPos.z);
+			if (cmd-&gt;facing != UNIT_COMMAND_BUILD_NO_FACING) c.params.push_back(cmd-&gt;facing);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_STOP:
+		{
+			SStopUnitCommand* cmd = (SStopUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_STOP;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+//		case COMMAND_UNIT_Insert:
+//		{
+//			SInsertUnitCommand* cmd = (SInsertUnitCommand*) commandData;
+//			Command c;
+//			c.id = CMD_Insert;
+//			c.options = cmd-&gt;options;
+//			c.timeOut = cmd-&gt;timeOut;
+//			c.params.push_back(cmd-&gt;toPos.x);
+//			c.params.push_back(cmd-&gt;toPos.y);
+//			c.params.push_back(cmd-&gt;toPos.z);
+//			if (cmd-&gt;unitId &gt;= 0) {
+//				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+//			} else {
+//				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+//			}
+//			break;
+//		}
+//		case COMMAND_UNIT_Remove:
+//		{
+//			SRemoveUnitCommand* cmd = (SRemoveUnitCommand*) commandData;
+//			Command c;
+//			c.id = CMD_Remove;
+//			c.options = cmd-&gt;options;
+//			c.timeOut = cmd-&gt;timeOut;
+//			c.params.push_back(cmd-&gt;toPos.x);
+//			c.params.push_back(cmd-&gt;toPos.y);
+//			c.params.push_back(cmd-&gt;toPos.z);
+//			if (cmd-&gt;unitId &gt;= 0) {
+//				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+//			} else {
+//				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+//			}
+//			break;
+//		}
+		case COMMAND_UNIT_WAIT:
+		{
+			SWaitUnitCommand* cmd = (SWaitUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_WAIT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_WAIT_TIME:
+		{
+			STimeWaitUnitCommand* cmd = (STimeWaitUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_WAITCODE_TIMEWAIT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;time);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_WAIT_DEATH:
+		{
+			SDeathWaitUnitCommand* cmd = (SDeathWaitUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_WAITCODE_DEATHWAIT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toDieUnitId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_WAIT_SQUAD:
+		{
+			SSquadWaitUnitCommand* cmd = (SSquadWaitUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_WAITCODE_SQUADWAIT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;numUnits);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_WAIT_GATHER:
+		{
+			SGatherWaitUnitCommand* cmd = (SGatherWaitUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_WAITCODE_GATHERWAIT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_MOVE:
+		{
+			SMoveUnitCommand* cmd = (SMoveUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_MOVE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toPos.x);
+			c.params.push_back(cmd-&gt;toPos.y);
+			c.params.push_back(cmd-&gt;toPos.z);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_PATROL:
+		{
+			SPatrolUnitCommand* cmd = (SPatrolUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_PATROL;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toPos.x);
+			c.params.push_back(cmd-&gt;toPos.y);
+			c.params.push_back(cmd-&gt;toPos.z);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_FIGHT:
+		{
+			SFightUnitCommand* cmd = (SFightUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_FIGHT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toPos.x);
+			c.params.push_back(cmd-&gt;toPos.y);
+			c.params.push_back(cmd-&gt;toPos.z);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_ATTACK:
+		{
+			SAttackUnitCommand* cmd = (SAttackUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_ATTACK;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toAttackUnitId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+//		case COMMAND_UNIT_AttackPos:
+//		{
+//			SAttackPosUnitCommand* cmd = (SAttackPosUnitCommand*) commandData;
+//			Command c;
+//			c.id = CMD_AttackPos;
+//			c.options = cmd-&gt;options;
+//			c.timeOut = cmd-&gt;timeOut;
+//			c.params.push_back(cmd-&gt;toPos.x);
+//			c.params.push_back(cmd-&gt;toPos.y);
+//			c.params.push_back(cmd-&gt;toPos.z);
+//			if (cmd-&gt;unitId &gt;= 0) {
+//				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+//			} else {
+//				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+//			}
+//			break;
+//		}
+		case COMMAND_UNIT_ATTACK_AREA:
+		{
+			SAttackAreaUnitCommand* cmd = (SAttackAreaUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_ATTACK;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toAttackPos.x);
+			c.params.push_back(cmd-&gt;toAttackPos.y);
+			c.params.push_back(cmd-&gt;toAttackPos.z);
+			c.params.push_back(cmd-&gt;radius);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_GUARD:
+		{
+			SGuardUnitCommand* cmd = (SGuardUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_GUARD;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toGuardUnitId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_AI_SELECT:
+		{
+			SAiSelectUnitCommand* cmd = (SAiSelectUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_AISELECT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+//			c.params.push_back(cmd-&gt;toPos.x);
+//			c.params.push_back(cmd-&gt;toPos.y);
+//			c.params.push_back(cmd-&gt;toPos.z);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+//		case COMMAND_UNIT_GroupSelect:
+//		{
+//			SGroupSelectUnitCommand* cmd = (SGroupSelectUnitCommand*) commandData;
+//			Command c;
+//			c.id = CMD_GroupSelect;
+//			c.options = cmd-&gt;options;
+//			c.timeOut = cmd-&gt;timeOut;
+//			c.params.push_back(cmd-&gt;toPos.x);
+//			c.params.push_back(cmd-&gt;toPos.y);
+//			c.params.push_back(cmd-&gt;toPos.z);
+//			if (cmd-&gt;unitId &gt;= 0) {
+//				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+//			} else {
+//				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+//			}
+//			break;
+//		}
+		case COMMAND_UNIT_GROUP_ADD:
+		{
+			SGroupAddUnitCommand* cmd = (SGroupAddUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_GROUPADD;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toGroupId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_GROUP_CLEAR:
+		{
+			SGroupClearUnitCommand* cmd = (SGroupClearUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_GROUPCLEAR;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_REPAIR:
+		{
+			SRepairUnitCommand* cmd = (SRepairUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_REPAIR;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toRepairUnitId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_SET_FIRE_STATE:
+		{
+			SSetFireStateUnitCommand* cmd = (SSetFireStateUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_FIRE_STATE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;fireState);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_SET_MOVE_STATE:
+		{
+			SSetMoveStateUnitCommand* cmd = (SSetMoveStateUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_MOVE_STATE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;moveState);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_SET_BASE:
+		{
+			SSetBaseUnitCommand* cmd = (SSetBaseUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_SETBASE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;basePos.x);
+			c.params.push_back(cmd-&gt;basePos.y);
+			c.params.push_back(cmd-&gt;basePos.z);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+//		case COMMAND_UNIT_Internal:
+//		{
+//			SInternalUnitCommand* cmd = (SInternalUnitCommand*) commandData;
+//			Command c;
+//			c.id = CMD_Internal;
+//			c.options = cmd-&gt;options;
+//			c.timeOut = cmd-&gt;timeOut;
+//			c.params.push_back(cmd-&gt;toPos.x);
+//			c.params.push_back(cmd-&gt;toPos.y);
+//			c.params.push_back(cmd-&gt;toPos.z);
+//			if (cmd-&gt;unitId &gt;= 0) {
+//				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+//			} else {
+//				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+//			}
+//			break;
+//		}
+		case COMMAND_UNIT_SELF_DESTROY:
+		{
+			SSelfDestroyUnitCommand* cmd = (SSelfDestroyUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_SELFD;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_SET_WANTED_MAX_SPEED:
+		{
+			SSetWantedMaxSpeedUnitCommand* cmd = (SSetWantedMaxSpeedUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_SET_WANTED_MAX_SPEED;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;wantedMaxSpeed);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_LOAD_UNITS:
+		{
+			SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_LOAD_UNITS;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			for (int i=0; i &lt; cmd-&gt;numToLoadUnits; ++i) {
+				c.params.push_back(cmd-&gt;toLoadUnitIds[i]);
+			}
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_LOAD_UNITS_AREA:
+		{
+			SLoadUnitsAreaUnitCommand* cmd = (SLoadUnitsAreaUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_LOAD_UNITS;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;pos.x);
+			c.params.push_back(cmd-&gt;pos.y);
+			c.params.push_back(cmd-&gt;pos.z);
+			c.params.push_back(cmd-&gt;radius);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_LOAD_ONTO:
+		{
+			SLoadOntoUnitCommand* cmd = (SLoadOntoUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_LOAD_ONTO;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;transporterUnitId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_UNLOAD_UNITS_AREA:
+		{
+			SUnloadUnitsAreaUnitCommand* cmd = (SUnloadUnitsAreaUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_UNLOAD_UNITS;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toPos.x);
+			c.params.push_back(cmd-&gt;toPos.y);
+			c.params.push_back(cmd-&gt;toPos.z);
+			c.params.push_back(cmd-&gt;radius);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_UNLOAD_UNIT:
+		{
+			SUnloadUnitCommand* cmd = (SUnloadUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_UNLOAD_UNIT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toPos.x);
+			c.params.push_back(cmd-&gt;toPos.y);
+			c.params.push_back(cmd-&gt;toPos.z);
+			c.params.push_back(cmd-&gt;toUnloadUnitId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_SET_ON_OFF:
+		{
+			SSetOnOffUnitCommand* cmd = (SSetOnOffUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_ONOFF;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;on);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_RECLAIM:
+		{
+			SReclaimUnitCommand* cmd = (SReclaimUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_RECLAIM;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toReclaimUnitIdOrFeatureId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_RECLAIM_AREA:
+		{
+			SReclaimAreaUnitCommand* cmd = (SReclaimAreaUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_RECLAIM;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;pos.x);
+			c.params.push_back(cmd-&gt;pos.y);
+			c.params.push_back(cmd-&gt;pos.z);
+			c.params.push_back(cmd-&gt;radius);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_CLOAK:
+		{
+			SCloakUnitCommand* cmd = (SCloakUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_CLOAK;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;cloak);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_STOCKPILE:
+		{
+			SStockpileUnitCommand* cmd = (SStockpileUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_STOCKPILE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_D_GUN:
+		{
+			SDGunUnitCommand* cmd = (SDGunUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_DGUN;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toAttackUnitId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_D_GUN_POS:
+		{
+			SDGunPosUnitCommand* cmd = (SDGunPosUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_DGUN;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;pos.x);
+			c.params.push_back(cmd-&gt;pos.y);
+			c.params.push_back(cmd-&gt;pos.z);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_RESTORE_AREA:
+		{
+			SRestoreAreaUnitCommand* cmd = (SRestoreAreaUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_RESTORE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;pos.x);
+			c.params.push_back(cmd-&gt;pos.y);
+			c.params.push_back(cmd-&gt;pos.z);
+			c.params.push_back(cmd-&gt;radius);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_SET_REPEAT:
+		{
+			SSetRepeatUnitCommand* cmd = (SSetRepeatUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_REPEAT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;repeat);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_SET_TRAJECTORY:
+		{
+			SSetTrajectoryUnitCommand* cmd = (SSetTrajectoryUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_TRAJECTORY;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;trajectory);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_RESURRECT:
+		{
+			SResurrectUnitCommand* cmd = (SResurrectUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_RESURRECT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toResurrectFeatureId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_RESURRECT_AREA:
+		{
+			SResurrectAreaUnitCommand* cmd = (SResurrectAreaUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_RESURRECT;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;pos.x);
+			c.params.push_back(cmd-&gt;pos.y);
+			c.params.push_back(cmd-&gt;pos.z);
+			c.params.push_back(cmd-&gt;radius);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_CAPTURE:
+		{
+			SCaptureUnitCommand* cmd = (SCaptureUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_CAPTURE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;toCaptureUnitId);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_CAPTURE_AREA:
+		{
+			SCaptureAreaUnitCommand* cmd = (SCaptureAreaUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_CAPTURE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;pos.x);
+			c.params.push_back(cmd-&gt;pos.y);
+			c.params.push_back(cmd-&gt;pos.z);
+			c.params.push_back(cmd-&gt;radius);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL:
+		{
+			SSetAutoRepairLevelUnitCommand* cmd = (SSetAutoRepairLevelUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_AUTOREPAIRLEVEL;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;autoRepairLevel);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+//		case COMMAND_UNIT_AttackLoopback:
+//		{
+//			SAttackLoopbackUnitCommand* cmd = (SAttackLoopbackUnitCommand*) commandData;
+//			Command c;
+//			c.id = CMD_AttackLoopback;
+//			c.options = cmd-&gt;options;
+//			c.timeOut = cmd-&gt;timeOut;
+//			c.params.push_back(cmd-&gt;toPos.x);
+//			c.params.push_back(cmd-&gt;toPos.y);
+//			c.params.push_back(cmd-&gt;toPos.z);
+//			if (cmd-&gt;unitId &gt;= 0) {
+//				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+//			} else {
+//				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+//			}
+//			break;
+//		}
+		case COMMAND_UNIT_SET_IDLE_MODE:
+		{
+			SSetIdleModeUnitCommand* cmd = (SSetIdleModeUnitCommand*) commandData;
+			Command c;
+			c.id = CMD_IDLEMODE;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			c.params.push_back(cmd-&gt;idleMode);
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+		case COMMAND_UNIT_CUSTOM:
+		{
+			SCustomUnitCommand* cmd = (SCustomUnitCommand*) commandData;
+			Command c;
+			c.id = cmd-&gt;cmdId;
+			c.options = cmd-&gt;options;
+			c.timeOut = cmd-&gt;timeOut;
+			
+			for (int i=0; i &lt; cmd-&gt;numParams; ++i) {
+				c.params.push_back(cmd-&gt;params[i]);
+			}
+			
+			if (cmd-&gt;unitId &gt;= 0) {
+				ret = clb-&gt;GiveOrder(cmd-&gt;unitId, &amp;c);
+			} else {
+				ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, &amp;c);
+			}
+			break;
+		}
+*/
+		default:
+		{
+			// check if it is a unit command
+			Command* c = (Command*) newCommand(commandData, commandTopic);
+			if (c != NULL) { // it is a unit command
+				SStopUnitCommand* cmd = (SStopUnitCommand*) commandData;
+				if (cmd-&gt;unitId &gt;= 0) {
+					ret = clb-&gt;GiveOrder(cmd-&gt;unitId, c);
+				} else {
+					ret = clb-&gt;GiveGroupOrder(cmd-&gt;groupId, c);
+				}
+				delete c;
+			} else { // it is no known command
+				ret = -1;
+			}
+		}
+		
+	}
+	
+	return ret;
+}
+
+
+
+
+//##############################################################################
+bool _Cheats_isEnabled(int teamId) {
+	team_cheatCallback[teamId] = NULL;
+	if (team_cheatingEnabled[teamId]) {
+		team_cheatCallback[teamId] = team_globalCallback[teamId]-&gt;GetCheatInterface();
+	}
+	return team_cheatCallback[teamId] != NULL;
+}
+
+bool _Cheats_setEnabled(int teamId, bool enabled) {
+//	bool isEnabled = _Cheats_isEnabled(teamId);
+//	
+//	if (enabled != isEnabled) {
+//		if (enable) {
+//			team_cheatCallback[teamId] = team_globalCallback[teamId]-&gt;GetCheatInterface();
+//		} else {
+//			team_cheatCallback[teamId] = NULL;
+//		}
+//	} else {
+//		return true;
+//	}
+//	
+//	isEnabled = _Cheats_isEnabled(teamId);
+//	return enabled != isEnabled;
+	
+	team_cheatingEnabled[teamId] = enabled;
+	return enabled == _Cheats_isEnabled(teamId);
+}
+
+bool _Cheats_setEventsEnabled(int teamId, bool enabled) {
+	if (_Cheats_isEnabled(teamId)) {
+		team_cheatCallback[teamId]-&gt;EnableCheatEvents(enabled);
+		return true;
+	} else {
+		return false;
+	}
+}
+
+bool _Cheats_isOnlyPassive(int teamId) {
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;OnlyPassiveCheats();
+	} else {
+		return true; //TODO: is this correct?
+	}
+}
+
+int _Game_getAiInterfaceVersion(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return wrapper_HandleCommand(clb, NULL, AIHCQuerySubVersionId, NULL);
+}
+
+bool _Map_isPosInCamera(int teamId, SAIFloat3 pos, float radius) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;PosInCamera(SAIFloat3(pos), radius);
+}
+
+int _Game_getCurrentFrame(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetCurrentFrame();
+}
+
+int _Game_getMyTeam(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMyTeam();
+}
+
+int _Game_getMyAllyTeam(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMyAllyTeam();
+}
+
+int _Game_getPlayerTeam(int teamId, int player) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetPlayerTeam(player);
+}
+
+const char* _Game_getTeamSide(int teamId, int team) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetTeamSide(team);
+}
+
+
+
+
+
+int _WeaponDef_STATIC_getNumDamageTypes(int teamId) {
+    int numDamageTypes;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numDamageTypes);
+    if (!fetchOk) {
+        numDamageTypes = -1;
+    }
+    return numDamageTypes;
+}
+unsigned int _Map_getChecksum(int teamId) {
+    unsigned int checksum;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_MAP_CHECKSUM, &amp;checksum);
+    if (!fetchOk) {
+        checksum = -1;
+    }
+    return checksum;
+}
+
+bool _Game_isExceptionHandlingEnabled(int teamId) {
+    bool exceptionHandlingEnabled;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_EXCEPTION_HANDLING, &amp;exceptionHandlingEnabled);
+    if (!fetchOk) {
+        exceptionHandlingEnabled = false;
+    }
+    return exceptionHandlingEnabled;
+}
+bool _Game_isDebugModeEnabled(int teamId) {
+    bool debugModeEnabled;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_DEBUG_MODE, &amp;debugModeEnabled);
+    if (!fetchOk) {
+        debugModeEnabled = false;
+    }
+    return debugModeEnabled;
+}
+int _Game_getMode(int teamId) {
+    int mode;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_MODE, &amp;mode);
+    if (!fetchOk) {
+        mode = -1;
+    }
+    return mode;
+}
+bool _Game_isPaused(int teamId) {
+    bool paused;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_PAUSED, &amp;paused);
+    if (!fetchOk) {
+        paused = false;
+    }
+    return paused;
+}
+float _Game_getSpeedFactor(int teamId) {
+    float speedFactor;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_SPEED_FACTOR, &amp;speedFactor);
+    if (!fetchOk) {
+        speedFactor = false;
+    }
+    return speedFactor;
+}
+
+float _Gui_getViewRange(int teamId) {
+    float viewRange;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_VIEW_RANGE, &amp;viewRange);
+    if (!fetchOk) {
+        viewRange = false;
+    }
+    return viewRange;
+}
+float _Gui_getScreenX(int teamId) {
+    float screenX;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_SCREENX, &amp;screenX);
+    if (!fetchOk) {
+        screenX = false;
+    }
+    return screenX;
+}
+float _Gui_getScreenY(int teamId) {
+    float screenY;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_SCREENY, &amp;screenY);
+    if (!fetchOk) {
+        screenY = false;
+    }
+    return screenY;
+}
+SAIFloat3 _Gui_Camera_getDirection(int teamId) {
+    float3 cameraDir;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_CAMERA_DIR, &amp;cameraDir);
+    if (!fetchOk) {
+        cameraDir = float3(1.0f, 0.0f, 0.0f);
+    }
+    return cameraDir.toSAIFloat3();
+}
+SAIFloat3 _Gui_Camera_getPosition(int teamId) {
+    float3 cameraPosition;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_CAMERA_POS, &amp;cameraPosition);
+    if (!fetchOk) {
+        cameraPosition = float3(1.0f, 0.0f, 0.0f);
+    }
+    return cameraPosition.toSAIFloat3();
+}
+
+bool _File_locateForReading(int teamId, char* filename) {
+	IAICallback* clb = team_callback[teamId];
+    return clb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename);
+}
+bool _File_locateForWriting(int teamId, char* filename) {
+	IAICallback* clb = team_callback[teamId];
+    return clb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
+}
+
+int _Unit_STATIC_getLimit(int teamId) {
+    int unitLimit;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_UNIT_LIMIT, &amp;unitLimit);
+    if (!fetchOk) {
+        unitLimit = -1;
+    }
+    return unitLimit;
+}
+const char* _Game_getSetupScript(int teamId) {
+    const char* setupScript;
+	IAICallback* clb = team_callback[teamId];
+    bool fetchOk = clb-&gt;GetValue(AIVAL_SCRIPT, &amp;setupScript);
+    if (!fetchOk) {
+        return NULL;
+    }
+    return setupScript;
+}
+
+
+
+
+
+
+
+//########### BEGINN UnitDef
+int _UnitDef_STATIC_getIds(int teamId, int* list) {
+	IAICallback* clb = team_callback[teamId];
+	int numUnitDefs = clb-&gt;GetNumUnitDefs();
+	const UnitDef** defList = (const UnitDef**) new UnitDef*[numUnitDefs];
+	clb-&gt;GetUnitDefList(defList);
+	int i;
+	for (i=0; i &lt; numUnitDefs; ++i) {
+		list[i] = defList[i]-&gt;id;
+	}
+	delete [] defList;
+	return numUnitDefs;
+}
+int _UnitDef_STATIC_getIdByName(int teamId, const char* unitName) {
+	IAICallback* clb = team_callback[teamId];
+	return clb-&gt;GetUnitDef(unitName)-&gt;id;
+}
+
+float _UnitDef_getHeight(int teamId, int unitDefId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitDefHeight(unitDefId);
+}
+float _UnitDef_getRadius(int teamId, int unitDefId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitDefRadius(unitDefId);
+}
+
+bool _UnitDef_isValid(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;valid;}
+const char* _UnitDef_getName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;name.c_str();}
+const char* _UnitDef_getHumanName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;humanName.c_str();}
+const char* _UnitDef_getFilename(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;filename.c_str();}
+int _UnitDef_getId(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;id;}
+int _UnitDef_getAiHint(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;aihint;}
+int _UnitDef_getCobID(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cobID;}
+int _UnitDef_getTechLevel(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;techLevel;}
+const char* _UnitDef_getGaia(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;gaia.c_str();}
+float _UnitDef_getMetalUpkeep(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalUpkeep;}
+float _UnitDef_getEnergyUpkeep(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyUpkeep;}
+float _UnitDef_getMetalMake(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalMake;}
+float _UnitDef_getMakesMetal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;makesMetal;}
+float _UnitDef_getEnergyMake(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyMake;}
+float _UnitDef_getMetalCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalCost;}
+float _UnitDef_getEnergyCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyCost;}
+float _UnitDef_getBuildTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildTime;}
+float _UnitDef_getExtractsMetal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;extractsMetal;}
+float _UnitDef_getExtractRange(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;extractRange;}
+float _UnitDef_getWindGenerator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;windGenerator;}
+float _UnitDef_getTidalGenerator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;tidalGenerator;}
+float _UnitDef_getMetalStorage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalStorage;}
+float _UnitDef_getEnergyStorage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyStorage;}
+float _UnitDef_getAutoHeal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;autoHeal;}
+float _UnitDef_getIdleAutoHeal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;idleAutoHeal;}
+int _UnitDef_getIdleTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;idleTime;}
+float _UnitDef_getPower(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;power;}
+float _UnitDef_getHealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;health;}
+unsigned int _UnitDef_getCategory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;category;}
+float _UnitDef_getSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;speed;}
+float _UnitDef_getTurnRate(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;turnRate;}
+int _UnitDef_getMoveType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;moveType;}
+bool _UnitDef_isUpright(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;upright;}
+bool _UnitDef_isCollide(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collide;}
+float _UnitDef_getControlRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;controlRadius;}
+float _UnitDef_getLosRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;losRadius;}
+float _UnitDef_getAirLosRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;airLosRadius;}
+float _UnitDef_getLosHeight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;losHeight;}
+int _UnitDef_getRadarRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;radarRadius;}
+int _UnitDef_getSonarRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarRadius;}
+int _UnitDef_getJammerRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;jammerRadius;}
+int _UnitDef_getSonarJamRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarJamRadius;}
+int _UnitDef_getSeismicRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;seismicRadius;}
+float _UnitDef_getSeismicSignature(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;seismicSignature;}
+bool _UnitDef_isStealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;stealth;}
+bool _UnitDef_isSonarStealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarStealth;}
+bool _UnitDef_isBuildRange3D(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildRange3D;}
+float _UnitDef_getBuildDistance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildDistance;}
+float _UnitDef_getBuildSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildSpeed;}
+float _UnitDef_getReclaimSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;reclaimSpeed;}
+float _UnitDef_getRepairSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;repairSpeed;}
+float _UnitDef_getMaxRepairSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxRepairSpeed;}
+float _UnitDef_getResurrectSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;resurrectSpeed;}
+float _UnitDef_getCaptureSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;captureSpeed;}
+float _UnitDef_getTerraformSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;terraformSpeed;}
+float _UnitDef_getMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;mass;}
+bool _UnitDef_isPushResistant(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;pushResistant;}
+bool _UnitDef_isStrafeToAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;strafeToAttack;}
+float _UnitDef_getMinCollisionSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minCollisionSpeed;}
+float _UnitDef_getSlideTolerance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;slideTolerance;}
+float _UnitDef_getMaxSlope(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxSlope;}
+float _UnitDef_getMaxHeightDif(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxHeightDif;}
+float _UnitDef_getMinWaterDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minWaterDepth;}
+float _UnitDef_getWaterline(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;waterline;}
+float _UnitDef_getMaxWaterDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxWaterDepth;}
+float _UnitDef_getArmoredMultiple(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;armoredMultiple;}
+int _UnitDef_getArmorType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;armorType;}
+int _UnitDef_getFlankingBonusMode(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMode;}
+SAIFloat3 _UnitDef_getFlankingBonusDir(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusDir.toSAIFloat3();}
+float _UnitDef_getFlankingBonusMax(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMax;}
+float _UnitDef_getFlankingBonusMin(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMin;}
+float _UnitDef_getFlankingBonusMobilityAdd(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMobilityAdd;}
+const char* _UnitDef_getCollisionVolumeType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeType.c_str();}
+SAIFloat3 _UnitDef_getCollisionVolumeScales(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeScales.toSAIFloat3();}
+SAIFloat3 _UnitDef_getCollisionVolumeOffsets(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeOffsets.toSAIFloat3();}
+int _UnitDef_getCollisionVolumeTest(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeTest;}
+float _UnitDef_getMaxWeaponRange(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxWeaponRange;}
+const char* _UnitDef_getType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;type.c_str();}
+const char* _UnitDef_getTooltip(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;tooltip.c_str();}
+const char* _UnitDef_getWreckName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wreckName.c_str();}
+const char* _UnitDef_getDeathExplosion(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;deathExplosion.c_str();}
+const char* _UnitDef_getSelfDExplosion(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;selfDExplosion.c_str();}
+const char* _UnitDef_getTedClassString(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;TEDClassString.c_str();}
+const char* _UnitDef_getCategoryString(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;categoryString.c_str();}
+bool _UnitDef_isCanSelfD(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSelfD;}
+int _UnitDef_getSelfDCountdown(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;selfDCountdown;}
+bool _UnitDef_isCanSubmerge(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSubmerge;}
+bool _UnitDef_isCanFly(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canfly;}
+bool _UnitDef_isCanMove(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canmove;}
+bool _UnitDef_isCanHover(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canhover;}
+bool _UnitDef_isFloater(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;floater;}
+bool _UnitDef_isBuilder(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;builder;}
+bool _UnitDef_isActivateWhenBuilt(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;activateWhenBuilt;}
+bool _UnitDef_isOnOffable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;onoffable;}
+bool _UnitDef_isFullHealthFactory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fullHealthFactory;}
+bool _UnitDef_isFactoryHeadingTakeoff(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;factoryHeadingTakeoff;}
+bool _UnitDef_isReclaimable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;reclaimable;}
+bool _UnitDef_isCapturable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;capturable;}
+bool _UnitDef_isCanRestore(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRestore;}
+bool _UnitDef_isCanRepair(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRepair;}
+bool _UnitDef_isCanSelfRepair(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSelfRepair;}
+bool _UnitDef_isCanReclaim(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canReclaim;}
+bool _UnitDef_isCanAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canAttack;}
+bool _UnitDef_isCanPatrol(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canPatrol;}
+bool _UnitDef_isCanFight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canFight;}
+bool _UnitDef_isCanGuard(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canGuard;}
+bool _UnitDef_isCanBuild(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canBuild;}
+bool _UnitDef_isCanAssist(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canAssist;}
+bool _UnitDef_isCanBeAssisted(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canBeAssisted;}
+bool _UnitDef_isCanRepeat(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRepeat;}
+bool _UnitDef_isCanFireControl(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canFireControl;}
+int _UnitDef_getFireState(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fireState;}
+int _UnitDef_getMoveState(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;moveState;}
+float _UnitDef_getWingDrag(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wingDrag;}
+float _UnitDef_getWingAngle(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wingAngle;}
+float _UnitDef_getDrag(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;drag;}
+float _UnitDef_getFrontToSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;frontToSpeed;}
+float _UnitDef_getSpeedToFront(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;speedToFront;}
+float _UnitDef_getMyGravity(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;myGravity;}
+float _UnitDef_getMaxBank(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxBank;}
+float _UnitDef_getMaxPitch(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxPitch;}
+float _UnitDef_getTurnRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;turnRadius;}
+float _UnitDef_getWantedHeight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wantedHeight;}
+float _UnitDef_getVerticalSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;verticalSpeed;}
+bool _UnitDef_isCanCrash(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCrash;}
+bool _UnitDef_isHoverAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;hoverAttack;}
+bool _UnitDef_isAirStrafe(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;airStrafe;}
+float _UnitDef_getDlHoverFactor(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;dlHoverFactor;}
+float _UnitDef_getMaxAcceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxAcc;}
+float _UnitDef_getMaxDeceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxDec;}
+float _UnitDef_getMaxAileron(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxAileron;}
+float _UnitDef_getMaxElevator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxElevator;}
+float _UnitDef_getMaxRudder(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxRudder;}
+//const unsigned char** _UnitDef_getYardMaps(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;yardmaps;}
+int _UnitDef_getXSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;xsize;}
+int _UnitDef_getYSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;ysize;}
+int _UnitDef_getBuildAngle(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildangle;}
+float _UnitDef_getLoadingRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;loadingRadius;}
+float _UnitDef_getUnloadSpread(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;unloadSpread;}
+int _UnitDef_getTransportCapacity(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportCapacity;}
+int _UnitDef_getTransportSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportSize;}
+int _UnitDef_getMinTransportSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minTransportSize;}
+bool _UnitDef_isAirBase(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isAirBase;}
+float _UnitDef_getTransportMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportMass;}
+float _UnitDef_getMinTransportMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minTransportMass;}
+bool _UnitDef_isHoldSteady(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;holdSteady;}
+bool _UnitDef_isReleaseHeld(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;releaseHeld;}
+bool _UnitDef_isCantBeTransported(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cantBeTransported;}
+bool _UnitDef_isTransportByEnemy(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportByEnemy;}
+int _UnitDef_getTransportUnloadMethod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportUnloadMethod;}
+float _UnitDef_getFallSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fallSpeed;}
+float _UnitDef_getUnitFallSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;unitFallSpeed;}
+bool _UnitDef_isCanCloak(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCloak;}
+bool _UnitDef_isStartCloaked(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;startCloaked;}
+float _UnitDef_getCloakCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cloakCost;}
+float _UnitDef_getCloakCostMoving(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cloakCostMoving;}
+float _UnitDef_getDecloakDistance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakDistance;}
+bool _UnitDef_isDecloakSpherical(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakSpherical;}
+bool _UnitDef_isDecloakOnFire(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakOnFire;}
+bool _UnitDef_isCanKamikaze(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canKamikaze;}
+float _UnitDef_getKamikazeDist(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;kamikazeDist;}
+bool _UnitDef_isTargetingFacility(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;targfac;}
+bool _UnitDef_isCanDGun(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canDGun;}
+bool _UnitDef_isNeedGeo(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;needGeo;}
+bool _UnitDef_isFeature(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isFeature;}
+bool _UnitDef_isHideDamage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;hideDamage;}
+bool _UnitDef_isCommander(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isCommander;}
+bool _UnitDef_isShowPlayerName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;showPlayerName;}
+bool _UnitDef_isCanResurrect(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canResurrect;}
+bool _UnitDef_isCanCapture(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCapture;}
+int _UnitDef_getHighTrajectoryType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;highTrajectoryType;}
+unsigned int _UnitDef_getNoChaseCategory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;noChaseCategory;}
+bool _UnitDef_isLeaveTracks(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;leaveTracks;}
+float _UnitDef_getTrackWidth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackWidth;}
+float _UnitDef_getTrackOffset(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackOffset;}
+float _UnitDef_getTrackStrength(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackStrength;}
+float _UnitDef_getTrackStretch(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackStretch;}
+int _UnitDef_getTrackType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackType;}
+bool _UnitDef_isCanDropFlare(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canDropFlare;}
+float _UnitDef_getFlareReloadTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareReloadTime;}
+float _UnitDef_getFlareEfficiency(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareEfficiency;}
+float _UnitDef_getFlareDelay(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareDelay;}
+SAIFloat3 _UnitDef_getFlareDropVector(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareDropVector.toSAIFloat3();}
+int _UnitDef_getFlareTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareTime;}
+int _UnitDef_getFlareSalvoSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareSalvoSize;}
+int _UnitDef_getFlareSalvoDelay(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareSalvoDelay;}
+bool _UnitDef_isSmoothAnim(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;smoothAnim;}
+bool _UnitDef_isMetalMaker(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isMetalMaker;}
+bool _UnitDef_isCanLoopbackAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canLoopbackAttack;}
+bool _UnitDef_isLevelGround(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;levelGround;}
+bool _UnitDef_isUseBuildingGroundDecal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;useBuildingGroundDecal;}
+int _UnitDef_getBuildingDecalType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalType;}
+int _UnitDef_getBuildingDecalSizeX(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalSizeX;}
+int _UnitDef_getBuildingDecalSizeY(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalSizeY;}
+float _UnitDef_getBuildingDecalDecaySpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalDecaySpeed;}
+bool _UnitDef_isFirePlatform(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isFirePlatform;}
+float _UnitDef_getMaxFuel(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxFuel;}
+float _UnitDef_getRefuelTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;refuelTime;}
+float _UnitDef_getMinAirBasePower(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minAirBasePower;}
+int _UnitDef_getMaxThisUnit(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxThisUnit;}
+int _UnitDef_getDecoyDefId(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decoyDef-&gt;id;}
+bool _UnitDef_isDontLand(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;DontLand();}
+int _UnitDef_getShieldWeaponDefId(int teamId, int unitDefId) {
+	const WeaponDef* wd = getUnitDefById(teamId, unitDefId)-&gt;shieldWeaponDef;
+	if (wd == NULL)
+		return -1;
+	else
+		return wd-&gt;id;
+}
+int _UnitDef_getStockpileWeaponDefId(int teamId, int unitDefId) {
+	const WeaponDef* wd = getUnitDefById(teamId, unitDefId)-&gt;stockpileWeaponDef;
+	if (wd == NULL)
+		return -1;
+	else
+		return wd-&gt;id;
+}
+int _UnitDef_getNumBuildOptions(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildOptions.size();}
+int _UnitDef_getBuildOptions(int teamId, int unitDefId, int* unitDefIds) {
+	const std::map&lt;int,std::string&gt;* bo = &amp;(getUnitDefById(teamId, unitDefId)-&gt;buildOptions);
+	int numBo = bo-&gt;size();
+	std::map&lt;int,std::string&gt;::const_iterator bb;
+	int b;
+	for (b=0, bb = bo-&gt;begin(); bb != bo-&gt;end(); ++b, bb++) {
+		unitDefIds[b] = _UnitDef_STATIC_getIdByName(teamId, bb-&gt;second.c_str());
+	}
+	return numBo;
+}
+int _UnitDef_getNumCustomParams(int teamId, int unitDefId) {
+	return getUnitDefById(teamId, unitDefId)-&gt;customParams.size();
+}
+int _UnitDef_getCustomParams(int teamId, int unitDefId, const char* map[][2]) {
+	return fillCMap(&amp;(getUnitDefById(teamId, unitDefId)-&gt;customParams), map);
+}
+bool _UnitDef_hasMoveData(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata != NULL;}
+int _UnitDef_MoveData_getMoveType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;moveType;}
+int _UnitDef_MoveData_getMoveFamily(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;moveFamily;}
+int _UnitDef_MoveData_getSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;size;}
+float _UnitDef_MoveData_getDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;depth;}
+float _UnitDef_MoveData_getMaxSlope(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxSlope;}
+float _UnitDef_MoveData_getSlopeMod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;slopeMod;}
+float _UnitDef_MoveData_getDepthMod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;depthMod;}
+int _UnitDef_MoveData_getPathType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;pathType;}
+float _UnitDef_MoveData_getCrushStrength(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;crushStrength;}
+float _UnitDef_MoveData_getMaxSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxSpeed;}
+short _UnitDef_MoveData_getMaxTurnRate(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxTurnRate;}
+float _UnitDef_MoveData_getMaxAcceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxAcceleration;}
+float _UnitDef_MoveData_getMaxBreaking(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxBreaking;}
+bool _UnitDef_MoveData_isSubMarine(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;subMarine;}
+int _UnitDef_getNumUnitDefWeapons(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.size();}
+const char* _UnitDef_UnitDefWeapon_getName(int teamId, int unitDefId, int weaponIndex) {
+	return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).name.c_str();
+}
+int _UnitDef_UnitDefWeapon_getWeaponDefId(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).def-&gt;id;}
+int _UnitDef_UnitDefWeapon_getSlavedTo(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).slavedTo;}
+SAIFloat3 _UnitDef_UnitDefWeapon_getMainDir(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).mainDir.toSAIFloat3();}
+float _UnitDef_UnitDefWeapon_getMaxAngleDif(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).maxAngleDif;}
+float _UnitDef_UnitDefWeapon_getFuelUsage(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).fuelUsage;}
+unsigned int _UnitDef_UnitDefWeapon_getBadTargetCat(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).badTargetCat;}
+unsigned int _UnitDef_UnitDefWeapon_getOnlyTargetCat(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).onlyTargetCat;}
+//########### END UnitDef
+
+
+
+
+
+//########### BEGINN Unit
+int _Unit_getDefId(int teamId, int unitId) {
+	const UnitDef* unitDef;
+	if (_Cheats_isEnabled(teamId)) {
+		unitDef = team_cheatCallback[teamId]-&gt;GetUnitDef(unitId);
+	} else {
+		unitDef = team_callback[teamId]-&gt;GetUnitDef(unitId);
+	}
+//	IAICallback* clb = team_callback[teamId];
+//	const UnitDef* unitDef = clb-&gt;GetUnitDef(unitId);
+	if (unitDef != NULL) {
+		return unitDef-&gt;id;
+	} else {
+		return -1;
+	}
+}
+int _Unit_getAiHint(int teamId, int unitId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitAiHint(unitId);
+}
+int _Unit_getGroup(int teamId, int unitId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitGroup(unitId);
+}
+int _Unit_getTeam(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitTeam(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetUnitTeam(unitId);
+	} else {
+		return team_callback[teamId]-&gt;GetUnitTeam(unitId);
+	}
+}
+int _Unit_getAllyTeam(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitAllyTeam(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetUnitAllyTeam(unitId);
+	} else {
+		return team_callback[teamId]-&gt;GetUnitAllyTeam(unitId);
+	}
+}
+int _Unit_getNumSupportedCommands(int teamId, int unitId) {
+	IAICallback* clb = team_callback[teamId];
+	return clb-&gt;GetUnitCommands(unitId)-&gt;size();
+}
+int _Unit_SupportedCommands_getId(int teamId, int unitId, int* ids) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		ids[i] = comDescs-&gt;at(i).id;
+	}
+	return numComDescs;
+}
+int _Unit_SupportedCommands_getName(int teamId, int unitId, const char** names) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		names[i] = comDescs-&gt;at(i).name.c_str();
+	}
+	return numComDescs;
+}
+int _Unit_SupportedCommands_getToolTip(int teamId, int unitId, const char** toolTips) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		toolTips[i] = comDescs-&gt;at(i).tooltip.c_str();
+	}
+	return numComDescs;
+}
+int _Unit_SupportedCommands_isShowUnique(int teamId, int unitId, bool* showUniques) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		showUniques[i] = comDescs-&gt;at(i).showUnique;
+	}
+	return numComDescs;
+}
+int _Unit_SupportedCommands_isDisabled(int teamId, int unitId, bool* disableds) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		disableds[i] = comDescs-&gt;at(i).disabled;
+	}
+	return numComDescs;
+}
+int _Unit_SupportedCommands_getNumParams(int teamId, int unitId, int* numParams) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		numParams[i] = comDescs-&gt;at(i).params.size();
+	}
+	return numComDescs;
+}
+int _Unit_SupportedCommands_getParams(int teamId, int unitId, const char*** params) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	int numComDescs = comDescs-&gt;size();
+	for (int c=0; c &lt; numComDescs; c++) {
+		const std::vector&lt;std::string&gt; ps = comDescs-&gt;at(c).params;
+		for (int p=0; p &lt; ps.size(); p++) {
+			params[c][p] = ps.at(p).c_str();
+		}
+	}
+	return numComDescs;
+}
+
+int _Unit_getStockpile(int teamId, int unitId) {
+    IAICallback* clb = team_callback[teamId];
+    int stockpile;
+    bool fetchOk = clb-&gt;GetProperty(AIVAL_STOCKPILED, unitId, &amp;stockpile);
+    if (!fetchOk) {
+        stockpile = -1;
+    }
+    return stockpile;
+}
+int _Unit_getStockpileQueued(int teamId, int unitId) {
+    IAICallback* clb = team_callback[teamId];
+    int stockpileQueue;
+    bool fetchOk = clb-&gt;GetProperty(AIVAL_STOCKPILE_QUED, unitId, &amp;stockpileQueue);
+    if (!fetchOk) {
+        stockpileQueue = -1;
+    }
+    return stockpileQueue;
+}
+float _Unit_getCurrentFuel(int teamId, int unitId) {
+    IAICallback* clb = team_callback[teamId];
+    float currentFuel;
+    bool fetchOk = clb-&gt;GetProperty(AIVAL_CURRENT_FUEL, unitId, &amp;currentFuel);
+    if (!fetchOk) {
+        currentFuel = -1.0f;
+    }
+    return currentFuel;
+}
+float _Unit_getMaxSpeed(int teamId, int unitId) {
+    IAICallback* clb = team_callback[teamId];
+    float maxSpeed;
+    bool fetchOk = clb-&gt;GetProperty(AIVAL_UNIT_MAXSPEED, unitId, &amp;maxSpeed);
+    if (!fetchOk) {
+        maxSpeed = -1.0f;
+    }
+    return maxSpeed;
+}
+
+float _Unit_getMaxRange(int teamId, int unitId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitMaxRange(unitId);
+}
+
+float _Unit_getMaxHealth(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitMaxHealth(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetUnitMaxHealth(unitId);
+	} else {
+		return team_callback[teamId]-&gt;GetUnitMaxHealth(unitId);
+	}
+}
+
+int _Unit_getNumCurrentCommands(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId];
+//	return clb-&gt;GetCurrentUnitCommands(unitId)-&gt;size();
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId)-&gt;size();
+	} else {
+		return team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId)-&gt;size();
+	}
+}
+int _Unit_CurrentCommands_getType(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId];
+//	CCommandQueue::QueueType qt = clb-&gt;GetCurrentUnitCommands(unitId)-&gt;GetType();
+//	return qt;
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId)-&gt;GetType();
+	} else {
+		return team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId)-&gt;GetType();
+	}
+}
+int _Unit_CurrentCommands_getIds(int teamId, int unitId, int* ids) {
+//	IAICallback* clb = team_callback[teamId];
+//	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
+	const CCommandQueue* cc = NULL;
+	if (_Cheats_isEnabled(teamId)) {
+		cc = team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	} else {
+		cc = team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	}
+	int numCommands = cc-&gt;size();
+	for (int c=0; c &lt; numCommands; ++c) {
+		ids[c] = cc-&gt;at(c).id;
+	}
+	return numCommands;
+}
+int _Unit_CurrentCommands_getOptions(int teamId, int unitId, unsigned char* options) {
+//	IAICallback* clb = team_callback[teamId];
+//	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
+	const CCommandQueue* cc = NULL;
+	if (_Cheats_isEnabled(teamId)) {
+		cc = team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	} else {
+		cc = team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	}
+	int numCommands = cc-&gt;size();
+	for (int c=0; c &lt; numCommands; ++c) {
+		options[c] = cc-&gt;at(c).options;
+	}
+	return numCommands;
+}
+int _Unit_CurrentCommands_getTag(int teamId, int unitId, unsigned int* tags) {
+//	IAICallback* clb = team_callback[teamId];
+//	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
+	const CCommandQueue* cc = NULL;
+	if (_Cheats_isEnabled(teamId)) {
+		cc = team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	} else {
+		cc = team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	}
+	int numCommands = cc-&gt;size();
+	for (int c=0; c &lt; numCommands; ++c) {
+		tags[c] = cc-&gt;at(c).tag;
+	}
+	return numCommands;
+}
+int _Unit_CurrentCommands_getTimeOut(int teamId, int unitId, int* timeOuts) {
+//	IAICallback* clb = team_callback[teamId];
+//	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
+	const CCommandQueue* cc = NULL;
+	if (_Cheats_isEnabled(teamId)) {
+		cc = team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	} else {
+		cc = team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	}
+	int numCommands = cc-&gt;size();
+	for (int c=0; c &lt; numCommands; ++c) {
+		timeOuts[c] = cc-&gt;at(c).timeOut;
+	}
+	return numCommands;
+}
+int _Unit_CurrentCommands_getNumParams(int teamId, int unitId, int* numParams) {
+//	IAICallback* clb = team_callback[teamId];
+//	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
+	const CCommandQueue* cc = NULL;
+	if (_Cheats_isEnabled(teamId)) {
+		cc = team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	} else {
+		cc = team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	}
+	int numCommands = cc-&gt;size();
+	for (int c=0; c &lt; numCommands; ++c) {
+		numParams[c] = cc-&gt;at(c).params.size();
+	}
+	return numCommands;
+}
+int _Unit_CurrentCommands_getParams(int teamId, int unitId, float** params) {
+//	IAICallback* clb = team_callback[teamId];
+//	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
+	const CCommandQueue* cc = NULL;
+	if (_Cheats_isEnabled(teamId)) {
+		cc = team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	} else {
+		cc = team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	}
+	int numCommands = cc-&gt;size();
+	for (int c=0; c &lt; numCommands; c++) {
+		const std::vector&lt;float&gt; ps = cc-&gt;at(c).params;
+		for (int p=0; p &lt; ps.size(); p++) {
+			params[c][p] = ps.at(p);
+		}
+	}
+	return numCommands;
+}
+
+float _Unit_getExperience(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitExperience(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetUnitExperience(unitId);
+	} else {
+		return team_callback[teamId]-&gt;GetUnitExperience(unitId);
+	}
+}
+
+float _Unit_getHealth(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitHealth(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetUnitHealth(unitId);
+	} else {
+		return team_callback[teamId]-&gt;GetUnitHealth(unitId);
+	}
+}
+float _Unit_getSpeed(int teamId, int unitId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitSpeed(unitId);
+}
+float _Unit_getPower(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId];return clb-&gt;GetUnitPower(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetUnitPower(unitId);
+	} else {
+		return team_callback[teamId]-&gt;GetUnitPower(unitId);
+	}
+}
+SAIFloat3 _Unit_getPos(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId];
+//	return clb-&gt;GetUnitPos(unitId).toSAIFloat3();
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetUnitPos(unitId).toSAIFloat3();
+	} else {
+		return team_callback[teamId]-&gt;GetUnitPos(unitId).toSAIFloat3();
+	}
+}
+float _Unit_ResourceInfo_Metal_getUse(int teamId, int unitId) {
+	
+	int res = -1.0F;
+	UnitResourceInfo resourceInfo;
+	
+//	IAICallback* clb = team_callback[teamId];
+//	bool fetchOk = clb-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	bool fetchOk;
+	if (_Cheats_isEnabled(teamId)) {
+		fetchOk = team_cheatCallback[teamId]-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	} else {
+		fetchOk = team_callback[teamId]-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	}
+	if (fetchOk) {
+		res = resourceInfo.metalUse;
+	}
+	
+	return res;
+}
+float _Unit_ResourceInfo_Metal_getMake(int teamId, int unitId) {
+	
+	int res = -1.0F;
+	UnitResourceInfo resourceInfo;
+	
+//	IAICallback* clb = team_callback[teamId];
+//	bool fetchOk = clb-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	bool fetchOk;
+	if (_Cheats_isEnabled(teamId)) {
+		fetchOk = team_cheatCallback[teamId]-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	} else {
+		fetchOk = team_callback[teamId]-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	}
+	if (fetchOk) {
+		res = resourceInfo.metalMake;
+	}
+	
+	return res;
+}
+float _Unit_ResourceInfo_Energy_getUse(int teamId, int unitId) {
+	
+	int res = -1.0F;
+	UnitResourceInfo resourceInfo;
+	
+//	IAICallback* clb = team_callback[teamId];
+//	bool fetchOk = clb-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	bool fetchOk;
+	if (_Cheats_isEnabled(teamId)) {
+		fetchOk = team_cheatCallback[teamId]-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	} else {
+		fetchOk = team_callback[teamId]-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	}
+	if (fetchOk) {
+		res = resourceInfo.energyUse;
+	}
+	
+	return res;
+}
+float _Unit_ResourceInfo_Energy_getMake(int teamId, int unitId) {
+	
+	int res = -1.0F;
+	UnitResourceInfo resourceInfo;
+	
+//	IAICallback* clb = team_callback[teamId];
+//	bool fetchOk = clb-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	bool fetchOk;
+	if (_Cheats_isEnabled(teamId)) {
+		fetchOk = team_cheatCallback[teamId]-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	} else {
+		fetchOk = team_callback[teamId]-&gt;GetUnitResourceInfo(unitId, &amp;resourceInfo);
+	}
+	if (fetchOk) {
+		res = resourceInfo.energyMake;
+	}
+	
+	return res;
+}
+bool _Unit_isActivated(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;IsUnitActivated(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;IsUnitActivated(unitId);
+	} else {
+		return team_callback[teamId]-&gt;IsUnitActivated(unitId);
+	}
+}
+bool _Unit_isBeingBuilt(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;UnitBeingBuilt(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;UnitBeingBuilt(unitId);
+	} else {
+		return team_callback[teamId]-&gt;UnitBeingBuilt(unitId);
+	}
+}
+bool _Unit_isCloaked(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;IsUnitCloaked(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;IsUnitCloaked(unitId);
+	} else {
+		return team_callback[teamId]-&gt;IsUnitCloaked(unitId);
+	}
+}
+bool _Unit_isParalyzed(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;IsUnitParalyzed(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;IsUnitParalyzed(unitId);
+	} else {
+		return team_callback[teamId]-&gt;IsUnitParalyzed(unitId);
+	}
+}
+bool _Unit_isNeutral(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;IsUnitNeutral(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;IsUnitNeutral(unitId);
+	} else {
+		return team_callback[teamId]-&gt;IsUnitNeutral(unitId);
+	}
+}
+int _Unit_getBuildingFacing(int teamId, int unitId) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetBuildingFacing(unitId);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetBuildingFacing(unitId);
+	} else {
+		return team_callback[teamId]-&gt;GetBuildingFacing(unitId);
+	}
+}
+//########### END Unit
+
+int _Unit_STATIC_getEnemies(int teamId, int* unitIds) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnemyUnits(unitIds);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetEnemyUnits(unitIds);
+	} else {
+		return team_callback[teamId]-&gt;GetEnemyUnits(unitIds);
+	}
+}
+
+int _Unit_STATIC_getEnemiesIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnemyUnits(unitIds, float3(pos), radius);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetEnemyUnits(unitIds, float3(pos), radius);
+	} else {
+		return team_callback[teamId]-&gt;GetEnemyUnits(unitIds, float3(pos), radius);
+	}
+}
+
+int _Unit_STATIC_getEnemiesInRadarAndLos(int teamId, int* unitIds) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnemyUnitsInRadarAndLos(unitIds);
+}
+
+int _Unit_STATIC_getFriendlies(int teamId, int* unitIds) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFriendlyUnits(unitIds);
+}
+
+int _Unit_STATIC_getFriendliesIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFriendlyUnits(unitIds, float3(pos), radius);
+}
+
+int _Unit_STATIC_getNeutrals(int teamId, int* unitIds) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetNeutralUnits(unitIds);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetNeutralUnits(unitIds);
+	} else {
+		return team_callback[teamId]-&gt;GetNeutralUnits(unitIds);
+	}
+}
+
+int _Unit_STATIC_getNeutralsIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetNeutralUnits(unitIds, float3(pos), radius);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetNeutralUnits(unitIds, float3(pos), radius);
+	} else {
+		return team_callback[teamId]-&gt;GetNeutralUnits(unitIds, float3(pos), radius);
+	}
+}
+
+const char* _Mod_getName(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetModName();
+}
+
+//########### BEGINN Map
+int _Map_getWidth(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMapWidth();
+}
+
+int _Map_getHeight(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMapHeight();
+}
+
+const float* _Map_getHeightMap(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetHeightMap();
+}
+
+float _Map_getMinHeight(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMinHeight();
+}
+
+float _Map_getMaxHeight(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMaxHeight();
+}
+
+const float* _Map_getSlopeMap(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetSlopeMap();
+}
+
+const unsigned short* _Map_getLosMap(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetLosMap();
+}
+
+const unsigned short* _Map_getRadarMap(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetRadarMap();
+}
+
+const unsigned short* _Map_getJammerMap(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetJammerMap();
+}
+
+const unsigned char* _Map_getMetalMap(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetalMap();
+}
+
+const char* _Map_getName(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMapName();
+}
+
+float _Map_getElevationAt(int teamId, float x, float z) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetElevation(x, z);
+}
+
+float _Map_getMaxMetal(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMaxMetal();
+}
+
+float _Map_getExtractorRadius(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetExtractorRadius();
+}
+
+float _Map_getMinWind(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMinWind();
+}
+
+float _Map_getMaxWind(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMaxWind();
+}
+
+float _Map_getTidalStrength(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetTidalStrength();
+}
+
+float _Map_getGravity(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetGravity();
+}
+
+bool _Map_canBuildAt(int teamId, int unitDefId, SAIFloat3 pos, int facing) {
+	IAICallback* clb = team_callback[teamId];
+	const UnitDef* unitDef = getUnitDefById(teamId, unitDefId);
+	return clb-&gt;CanBuildAt(unitDef, pos, facing);
+}
+
+SAIFloat3 _Map_findClosestBuildSite(int teamId, int unitDefId, SAIFloat3 pos, float searchRadius, int minDist, int facing) {
+	IAICallback* clb = team_callback[teamId];
+	const UnitDef* unitDef = getUnitDefById(teamId, unitDefId);
+	return clb-&gt;ClosestBuildSite(unitDef, pos, searchRadius, minDist, facing).toSAIFloat3();
+}
+
+int _Map_getPoints(int teamId, SAIFloat3* positions, unsigned char** colors, const char** labels, int maxPoints) {
+	IAICallback* clb = team_callback[teamId];
+	PointMarker* pm = new PointMarker[maxPoints];
+	int numPoints = clb-&gt;GetMapPoints(pm, maxPoints);
+	for (int i=0; i &lt; numPoints; ++i) {
+		positions[i] = pm[i].pos.toSAIFloat3();
+		colors[i] = pm[i].color;
+		labels[i] = pm[i].label;
+	}
+	delete [] pm;
+	return numPoints;
+}
+
+int _Map_getLines(int teamId, SAIFloat3* firstPositions, SAIFloat3* secondPositions, unsigned char** colors, int maxLines) {
+	IAICallback* clb = team_callback[teamId];
+	LineMarker* lm = new LineMarker[maxLines];
+	int numLines = clb-&gt;GetMapLines(lm, maxLines);
+	for (int i=0; i &lt; numLines; ++i) {
+		firstPositions[i] = lm[i].pos.toSAIFloat3();
+		secondPositions[i] = lm[i].pos2.toSAIFloat3();
+		colors[i] = lm[i].color;
+	}
+	delete [] lm;
+	return numLines;
+}
+//########### END Map
+
+
+/*
+bool _getProperty(int teamId, int id, int property, void* dst) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetProperty(id, property, dst);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetProperty(id, property, dst);
+	} else {
+		return team_callback[teamId]-&gt;GetProperty(id, property, dst);
+	}
+}
+
+bool _getValue(int teamId, int id, void* dst) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetValue(id, dst);
+	if (_Cheats_isEnabled(teamId)) {
+		return team_cheatCallback[teamId]-&gt;GetValue(id, dst);
+	} else {
+		return team_callback[teamId]-&gt;GetValue(id, dst);
+	}
+}
+*/
+
+int _File_getSize(int teamId, const char* filename) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFileSize(filename);
+}
+
+bool _File_getContent(int teamId, const char* filename, void* buffer, int bufferLen) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;ReadFile(filename, buffer, bufferLen);
+}
+
+int _Unit_STATIC_getSelected(int teamId, int* units) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetSelectedUnits(units);
+}
+
+SAIFloat3 _Map_getMousePos(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMousePos().toSAIFloat3();
+}
+
+float _ResourceInfo_Metal_getCurrent(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetal();
+}
+
+float _ResourceInfo_Metal_getIncome(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetalIncome();
+}
+
+float _ResourceInfo_Metal_getUsage(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetalUsage();
+}
+
+float _ResourceInfo_Metal_getStorage(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetalStorage();
+}
+
+float _ResourceInfo_Energy_getCurrent(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnergy();
+}
+
+float _ResourceInfo_Energy_getIncome(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnergyIncome();
+}
+
+float _ResourceInfo_Energy_getUsage(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnergyUsage();
+}
+
+float _ResourceInfo_Energy_getStorage(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnergyStorage();
+}
+
+int _Feature_STATIC_getIds(int teamId, int *featureIds, int max) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeatures(featureIds, max);
+}
+
+int _Feature_STATIC_getIdsIn(int teamId, int *featureIds, int max, SAIFloat3 pos, float radius) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeatures(featureIds, max, pos, radius);
+}
+
+//########### BEGINN FeatureDef
+const char* _FeatureDef_getName(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;myName.c_str();}
+const char* _FeatureDef_getDescription(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;description.c_str();}
+const char* _FeatureDef_getFilename(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;filename.c_str();}
+int _FeatureDef_getId(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;id;}
+float _FeatureDef_getMetal(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;metal;}
+float _FeatureDef_getEnergy(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;energy;}
+float _FeatureDef_getMaxHealth(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;maxHealth;}
+float _FeatureDef_getReclaimTime(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;reclaimTime;}
+float _FeatureDef_getMass(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;mass;}
+const char* _FeatureDef_getCollisionVolumeType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeType.c_str();}	
+SAIFloat3 _FeatureDef_getCollisionVolumeScales(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeScales.toSAIFloat3();}		
+SAIFloat3 _FeatureDef_getCollisionVolumeOffsets(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeOffsets.toSAIFloat3();}		
+int _FeatureDef_getCollisionVolumeTest(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeTest;}			
+bool _FeatureDef_isUpright(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;upright;}
+int _FeatureDef_getDrawType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;drawType;}
+const char* _FeatureDef_getModelName(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;modelname.c_str();}
+int _FeatureDef_getModelType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;modelType;}
+bool _FeatureDef_isDestructable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;destructable;}
+bool _FeatureDef_isReclaimable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;reclaimable;}
+bool _FeatureDef_isBlocking(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;blocking;}
+bool _FeatureDef_isBurnable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;burnable;}
+bool _FeatureDef_isFloating(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;floating;}
+bool _FeatureDef_isNoSelect(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;noSelect;}
+bool _FeatureDef_isGeoThermal(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;geoThermal;}
+const char* _FeatureDef_getDeathFeature(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;deathFeature.c_str();}
+int _FeatureDef_getXsize(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;xsize;}
+int _FeatureDef_getYsize(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;ysize;}
+int _FeatureDef_getNumCustomParams(int teamId, int featureDefId) {
+	return getFeatureDefById(teamId, featureDefId)-&gt;customParams.size();
+}
+int _FeatureDef_getCustomParams(int teamId, int featureDefId, const char* map[][2]) {
+	return fillCMap(&amp;(getFeatureDefById(teamId, featureDefId)-&gt;customParams), map);
+}
+//########### END FeatureDef
+
+int _Feature_getDefId(int teamId, int featureId) {
+	IAICallback* clb = team_callback[teamId];
+	return clb-&gt;GetFeatureDef(featureId)-&gt;id;
+}
+
+float _Feature_getHealth(int teamId, int feature) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeatureHealth(feature);
+}
+
+float _Feature_getReclaimLeft(int teamId, int feature) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeatureReclaimLeft(feature);
+}
+
+SAIFloat3 _Feature_getPos(int teamId, int feature) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeaturePos(feature).toSAIFloat3();
+}
+
+int _UnitDef_STATIC_getNumIds(int teamId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetNumUnitDefs();
+}
+
+//########### BEGINN WeaponDef
+int _WeaponDef_STATIC_getIdByName(int teamId, const char* weaponDefName) {
+	IAICallback* clb = team_callback[teamId];
+	return clb-&gt;GetWeapon(weaponDefName)-&gt;id;
+}
+
+const char* _WeaponDef_getName(int teamId, int weaponDefId) {
+	return getWeaponDefById(teamId, weaponDefId)-&gt;name.c_str();
+}
+const char* _WeaponDef_getType(int teamId, int weaponDefId) {
+	return getWeaponDefById(teamId, weaponDefId)-&gt;type.c_str();
+}
+const char* _WeaponDef_getDescription(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;description.c_str();}
+const char* _WeaponDef_getFilename(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;filename.c_str();}
+const char* _WeaponDef_getCegTag(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cegTag.c_str();}
+float _WeaponDef_getRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;range;}
+float _WeaponDef_getHeightMod(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;heightmod;}
+float _WeaponDef_getAccuracy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;accuracy;}
+float _WeaponDef_getSprayAngle(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sprayAngle;}
+float _WeaponDef_getMovingAccuracy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;movingAccuracy;}
+float _WeaponDef_getTargetMoveError(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetMoveError;}
+float _WeaponDef_getLeadLimit(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;leadLimit;}
+float _WeaponDef_getLeadBonus(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;leadBonus;}
+float _WeaponDef_getPredictBoost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;predictBoost;}
+int _WeaponDef_Damages_getParalyzeDamageTime(int teamId, int weaponDefId) {
+	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
+	return da.paralyzeDamageTime;
+}
+float _WeaponDef_Damages_getImpulseFactor(int teamId, int weaponDefId) {
+	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
+	return da.impulseFactor;
+}
+float _WeaponDef_Damages_getImpulseBoost(int teamId, int weaponDefId) {
+	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
+	return da.impulseBoost;
+}
+float _WeaponDef_Damages_getCraterMult(int teamId, int weaponDefId) {
+	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
+	return da.craterMult;
+}
+float _WeaponDef_Damages_getCraterBoost(int teamId, int weaponDefId) {
+	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
+	return da.craterBoost;
+}
+int _WeaponDef_Damages_getNumTypes(int teamId, int weaponDefId) {
+	return getWeaponDefById(teamId, weaponDefId)-&gt;damages.GetNumTypes();
+}
+void _WeaponDef_Damages_getTypeDamages(int teamId, int weaponDefId, float* typeDamages) {
+	int numTypes = _WeaponDef_Damages_getNumTypes(teamId, weaponDefId);
+	const WeaponDef* weaponDef = getWeaponDefById(teamId, weaponDefId);
+	for (int i=0; i &lt; numTypes; ++i) {
+		typeDamages[i] = weaponDef-&gt;damages[i];
+	}
+}
+float _WeaponDef_getAreaOfEffect(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;areaOfEffect;}
+bool _WeaponDef_isNoSelfDamage(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noSelfDamage;}
+float _WeaponDef_getFireStarter(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fireStarter;}
+float _WeaponDef_getEdgeEffectiveness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;edgeEffectiveness;}
+float _WeaponDef_getSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;size;}
+float _WeaponDef_getSizeGrowth(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sizeGrowth;}
+float _WeaponDef_getCollisionSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;collisionSize;}
+int _WeaponDef_getSalvoSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;salvosize;}
+float _WeaponDef_getSalvoDelay(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;salvodelay;}
+float _WeaponDef_getReload(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;reload;}
+float _WeaponDef_getBeamTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;beamtime;}
+bool _WeaponDef_isBeamBurst(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;beamburst;}
+bool _WeaponDef_isWaterBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;waterBounce;}
+bool _WeaponDef_isGroundBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;groundBounce;}
+float _WeaponDef_getBounceRebound(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;bounceRebound;}
+float _WeaponDef_getBounceSlip(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;bounceSlip;}
+int _WeaponDef_getNumBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;numBounce;}
+float _WeaponDef_getMaxAngle(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;maxAngle;}
+float _WeaponDef_getRestTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;restTime;}
+float _WeaponDef_getUpTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;uptime;}
+int _WeaponDef_getFlightTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;flighttime;}
+float _WeaponDef_getMetalCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;metalcost;}
+float _WeaponDef_getEnergyCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;energycost;}
+float _WeaponDef_getSupplyCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;supplycost;}
+int _WeaponDef_getProjectilesPerShot(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;projectilespershot;}
+int _WeaponDef_getId(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;id;}
+int _WeaponDef_getTdfId(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;tdfId;}
+bool _WeaponDef_isTurret(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;turret;}
+bool _WeaponDef_isOnlyForward(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;onlyForward;}
+bool _WeaponDef_isFixedLauncher(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fixedLauncher;}
+bool _WeaponDef_isWaterWeapon(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;waterweapon;}
+bool _WeaponDef_isFireSubmersed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fireSubmersed;}
+bool _WeaponDef_isSubMissile(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;submissile;}
+bool _WeaponDef_isTracks(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;tracks;}
+bool _WeaponDef_isDropped(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dropped;}
+bool _WeaponDef_isParalyzer(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;paralyzer;}
+bool _WeaponDef_isImpactOnly(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;impactOnly;}
+bool _WeaponDef_isNoAutoTarget(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noAutoTarget;}
+bool _WeaponDef_isManualFire(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;manualfire;}
+int _WeaponDef_getInterceptor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;interceptor;}
+int _WeaponDef_getTargetable(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetable;}
+bool _WeaponDef_isStockpileable(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;stockpile;}
+float _WeaponDef_getCoverageRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;coverageRange;}
+float _WeaponDef_getIntensity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;intensity;}
+float _WeaponDef_getThickness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;thickness;}
+float _WeaponDef_getLaserFlareSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;laserflaresize;}
+float _WeaponDef_getCoreThickness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;corethickness;}
+float _WeaponDef_getDuration(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;duration;}
+int _WeaponDef_getLodDistance(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;lodDistance;}
+float _WeaponDef_getFalloffRate(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;falloffRate;}
+int _WeaponDef_getGraphicsType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;graphicsType;}
+bool _WeaponDef_isSoundTrigger(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;soundTrigger;}
+bool _WeaponDef_isSelfExplode(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;selfExplode;}
+bool _WeaponDef_isGravityAffected(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;gravityAffected;}
+int _WeaponDef_getHighTrajectory(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;highTrajectory;}
+float _WeaponDef_getMyGravity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;myGravity;}
+bool _WeaponDef_isTwoPhase(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;twophase;}
+bool _WeaponDef_isGuided(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;guided;}
+bool _WeaponDef_isVLaunched(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;vlaunch;}
+bool _WeaponDef_isSelfPropelled(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;selfprop;}
+bool _WeaponDef_isNoExplode(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noExplode;}
+float _WeaponDef_getStartVelocity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;startvelocity;}
+float _WeaponDef_getWeaponAcceleration(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;weaponacceleration;}
+float _WeaponDef_getTurnRate(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;turnrate;}
+float _WeaponDef_getMaxVelocity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;maxvelocity;}
+float _WeaponDef_getProjectileSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;projectilespeed;}
+float _WeaponDef_getExplosionSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;explosionSpeed;}
+unsigned int _WeaponDef_getOnlyTargetCategory(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;onlyTargetCategory;}
+float _WeaponDef_getWobble(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;wobble;}
+float _WeaponDef_getDance(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dance;}
+float _WeaponDef_getTrajectoryHeight(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;trajectoryHeight;}
+bool _WeaponDef_isLargeBeamLaser(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;largeBeamLaser;}
+bool _WeaponDef_isShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;isShield;}
+bool _WeaponDef_isShieldRepulser(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRepulser;}
+bool _WeaponDef_isSmartShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;smartShield;}
+bool _WeaponDef_isExteriorShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;exteriorShield;}
+bool _WeaponDef_isVisibleShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShield;}
+bool _WeaponDef_isVisibleShieldRepulse(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShieldRepulse;}
+int _WeaponDef_getVisibleShieldHitFrames(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShieldHitFrames;}
+float _WeaponDef_getShieldEnergyUse(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldEnergyUse;}
+float _WeaponDef_getShieldRadius(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRadius;}
+float _WeaponDef_getShieldForce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldForce;}
+float _WeaponDef_getShieldMaxSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldMaxSpeed;}
+float _WeaponDef_getShieldPower(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPower;}
+float _WeaponDef_getShieldPowerRegen(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPowerRegen;}
+float _WeaponDef_getShieldPowerRegenEnergy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPowerRegenEnergy;}
+float _WeaponDef_getShieldStartingPower(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldStartingPower;}
+int _WeaponDef_getShieldRechargeDelay(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRechargeDelay;}
+SAIFloat3 _WeaponDef_getShieldGoodColor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldGoodColor.toSAIFloat3();}
+SAIFloat3 _WeaponDef_getShieldBadColor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldBadColor.toSAIFloat3();}
+float _WeaponDef_getShieldAlpha(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldAlpha;}
+unsigned int _WeaponDef_getShieldInterceptType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldInterceptType;}
+unsigned int _WeaponDef_getInterceptedByShieldType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;interceptedByShieldType;}
+bool _WeaponDef_isAvoidFriendly(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidFriendly;}
+bool _WeaponDef_isAvoidFeature(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidFeature;}
+bool _WeaponDef_isAvoidNeutral(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidNeutral;}
+float _WeaponDef_getTargetBorder(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetBorder;}
+float _WeaponDef_getCylinderTargetting(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cylinderTargetting;}
+float _WeaponDef_getMinIntensity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;minIntensity;}
+float _WeaponDef_getHeightBoostFactor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;heightBoostFactor;}
+float _WeaponDef_getProximityPriority(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;proximityPriority;}
+unsigned int _WeaponDef_getCollisionFlags(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;collisionFlags;}
+bool _WeaponDef_isSweepFire(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sweepFire;}
+bool _WeaponDef_isCanAttackGround(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;canAttackGround;}
+float _WeaponDef_getCameraShake(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cameraShake;}
+float _WeaponDef_getDynDamageExp(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageExp;}
+float _WeaponDef_getDynDamageMin(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageMin;}
+float _WeaponDef_getDynDamageRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageRange;}
+bool _WeaponDef_isDynDamageInverted(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageInverted;}
+int _WeaponDef_getNumCustomParams(int teamId, int weaponDefId) {
+	return getWeaponDefById(teamId, weaponDefId)-&gt;customParams.size();
+}
+int _WeaponDef_getCustomParams(int teamId, int weaponDefId, const char* map[][2]) {
+	return fillCMap(&amp;(getWeaponDefById(teamId, weaponDefId)-&gt;customParams), map);
+}
+//########### END WeaponDef
+
+
+SAIFloat3 _Map_getStartPos(int teamId) {
+	IAICallback* clb = team_callback[teamId];
+	return clb-&gt;GetStartPos()-&gt;toSAIFloat3();
+}
+
+
+
+
+
+
+
+
+
+
+
+/*
+void _sendTextMsg(int teamId, const char* text, int zone) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;SendTextMsg(text, zone);
+}
+
+void _setLastMsgPos(int teamId, SAIFloat3 pos) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;SetLastMsgPos(pos);
+}
+
+void _addNotification(int teamId, SAIFloat3 pos, SAIFloat3 color, float alpha) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;AddNotification(pos, color, alpha);
+}
+
+bool _sendResources(int teamId, float mAmount, float eAmount, int receivingTeam) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;SendResources(mAmount, eAmount, receivingTeam);
+}
+
+int _sendUnits(int teamId, int numUnitIds, const int* unitIds, int receivingTeam) {
+	IAICallback* clb = team_callback[teamId];
+	std::vector&lt;int&gt; unitIdVector(numUnitIds);
+	int i;
+	for (i=0; i &lt; numUnitIds; ++i) {
+		unitIdVector.push_back(unitIds[i]);
+	}
+	return clb-&gt;SendUnits(unitIdVector, receivingTeam);
+}
+
+void* _createSharedMemArea(int teamId, char* name, int size) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;CreateSharedMemArea(name, size);
+}
+
+void _releasedSharedMemArea(int teamId, char* name) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;ReleasedSharedMemArea(name);
+}
+
+int _Group_create(int teamId, char* dll, unsigned aiNumber) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;CreateGroup(dll, aiNumber);
+}
+
+void _Group_erase(int teamId, int groupId) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;EraseGroup(groupId);
+}
+*/
+
+int _Group_getNumSupportedCommands(int teamId, int groupId) {
+	IAICallback* clb = team_callback[teamId];
+	return clb-&gt;GetGroupCommands(groupId)-&gt;size();
+}
+int _Group_SupportedCommands_getId(int teamId, int groupId, int* ids) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		ids[i] = comDescs-&gt;at(i).id;
+	}
+	return numComDescs;
+}
+int _Group_SupportedCommands_getName(int teamId, int groupId, const char** names) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		names[i] = comDescs-&gt;at(i).name.c_str();
+	}
+	return numComDescs;
+}
+int _Group_SupportedCommands_getToolTip(int teamId, int groupId, const char** toolTips) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		toolTips[i] = comDescs-&gt;at(i).tooltip.c_str();
+	}
+	return numComDescs;
+}
+int _Group_SupportedCommands_isShowUnique(int teamId, int groupId, bool* showUniques) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		showUniques[i] = comDescs-&gt;at(i).showUnique;
+	}
+	return numComDescs;
+}
+int _Group_SupportedCommands_isDisabled(int teamId, int groupId, bool* disableds) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		disableds[i] = comDescs-&gt;at(i).disabled;
+	}
+	return numComDescs;
+}
+int _Group_SupportedCommands_getNumParams(int teamId, int groupId, int* numParams) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
+	int numComDescs = comDescs-&gt;size();
+	for (int i=0; i &lt; numComDescs; i++) {
+		numParams[i] = comDescs-&gt;at(i).params.size();
+	}
+	return numComDescs;
+}
+int _Group_SupportedCommands_getParams(int teamId, int groupId, const char*** params) {
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
+	int numComDescs = comDescs-&gt;size();
+	for (int c=0; c &lt; numComDescs; c++) {
+		const std::vector&lt;std::string&gt; ps = comDescs-&gt;at(c).params;
+		for (int p=0; p &lt; ps.size(); p++) {
+			params[c][p] = ps.at(p).c_str();
+		}
+	}
+	return numComDescs;
+}
+
+/*
+bool _Unit_addToGroup(int teamId, int unitId, int groupId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;AddUnitToGroup(unitId, groupId);
+}
+
+bool _Unit_removeFromGroup(int teamId, int unitId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;RemoveUnitFromGroup(unitId);
+}
+*/
+
+//int _Group_giveOrder(int teamId, int unitId, SAICommand* c) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GiveGroupOrder(unitId, c);
+//}
+//
+//int _Unit_giveOrder(int teamId, int unitId, SAICommand* c) {
+//	IAICallback* clb = team_callback[teamId]; return clb-&gt;GiveOrder(unitId, c);
+//}
+/*
+
+int _initPath(int teamId, SAIFloat3 start, SAIFloat3 end, int pathType) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;InitPath(start, end, pathType);
+}
+
+void _freePath(int teamId, int pathid) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;FreePath(pathid);
+}
+
+void _LineDrawer_startPath(int teamId, SAIFloat3 pos, const float* color) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerStartPath(pos, color);
+}
+
+void _LineDrawer_finishPath(int teamId) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerFinishPath();
+}
+
+void _LineDrawer_drawLine(int teamId, SAIFloat3 endPos, const float* color) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerDrawLine(endPos, color);
+}
+
+void _LineDrawer_drawLineAndIcon(int teamId, int cmdID, SAIFloat3 endPos, const float* color) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerDrawLineAndIcon(cmdID, endPos, color);
+}
+
+void _LineDrawer_drawIconAtLastPos(int teamId, int cmdID) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerDrawIconAtLastPos(cmdID);
+}
+
+void _LineDrawer_break(int teamId, SAIFloat3 endPos, const float* color) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerBreak(endPos, color);
+}
+
+void _LineDrawer_restart(int teamId) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerRestart();
+}
+
+void _LineDrawer_restartSameColor(int teamId) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerRestartSameColor();
+}
+
+int _createSplineFigure(int teamId, SAIFloat3 pos1, SAIFloat3 pos2, SAIFloat3 pos3, SAIFloat3 pos4, float width, int arrow, int lifetime, int figureGroupId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;CreateSplineFigure(pos1, pos2, pos3, pos4, width, arrow, lifetime, figureGroupId);
+}
+
+int _createLineFigure(int teamId, SAIFloat3 pos1, SAIFloat3 pos2, float width, int arrow, int lifetime, int figureGroupId) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;CreateLineFigure(pos1, pos2, width, arrow, lifetime, figureGroupId);
+}
+
+void _setFigureColor(int teamId, int group, float red, float green, float blue, float alpha) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;SetFigureColor(group, red, green, blue, alpha);
+}
+
+void _deleteFigureGroup(int teamId, int figureGroupId) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;DeleteFigureGroup(figureGroupId);
+}
+
+void _drawUnit(int teamId, const char* name, SAIFloat3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing) {
+	IAICallback* clb = team_callback[teamId]; clb-&gt;DrawUnit(name, pos, rotation, lifetime, team, transparent, drawBorder, facing);
+}
+*/
+
+//int _handleCommand(int teamId, int commandId, void* data) {
+//	IAICallback* clb = team_callback[teamId]; return wrapper_HandleCommand(clb, clbCheat, commandId, data);
+//}
+
+/*
+bool _readFile(int teamId, const char* name, void* buffer, int bufferLen) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;ReadFile(name, buffer, bufferLen);
+}
+
+const char* _callLuaRules(int teamId, const char* data, int inSize, int* outSize) {
+	IAICallback* clb = team_callback[teamId]; return clb-&gt;CallLuaRules(data, inSize, outSize);
+}
+*/
+//##############################################################################
+
+
+
+
+SAICallback* initSAICallback(int teamId, IGlobalAICallback* aiGlobalCallback) {
+	
+	SAICallback* sAICallback = new SAICallback();
+
+	sAICallback-&gt;handleCommand = _handleCommand;
+	sAICallback-&gt;Game_getCurrentFrame = _Game_getCurrentFrame;
+	sAICallback-&gt;Game_getAiInterfaceVersion = _Game_getAiInterfaceVersion;
+	sAICallback-&gt;Game_getMyTeam = _Game_getMyTeam;
+	sAICallback-&gt;Game_getMyAllyTeam = _Game_getMyAllyTeam;
+	sAICallback-&gt;Game_getPlayerTeam = _Game_getPlayerTeam;
+	sAICallback-&gt;Game_getTeamSide = _Game_getTeamSide;
+	sAICallback-&gt;WeaponDef_STATIC_getNumDamageTypes = _WeaponDef_STATIC_getNumDamageTypes;
+	sAICallback-&gt;Map_getChecksum = _Map_getChecksum;
+	sAICallback-&gt;Game_isExceptionHandlingEnabled = _Game_isExceptionHandlingEnabled;
+	sAICallback-&gt;Game_isDebugModeEnabled = _Game_isDebugModeEnabled;
+	sAICallback-&gt;Game_getMode = _Game_getMode;
+	sAICallback-&gt;Game_isPaused = _Game_isPaused;
+	sAICallback-&gt;Game_getSpeedFactor = _Game_getSpeedFactor;
+	sAICallback-&gt;Gui_getViewRange = _Gui_getViewRange;
+	sAICallback-&gt;Gui_getScreenX = _Gui_getScreenX;
+	sAICallback-&gt;Gui_getScreenY = _Gui_getScreenY;
+	sAICallback-&gt;Gui_Camera_getDirection = _Gui_Camera_getDirection;
+	sAICallback-&gt;Gui_Camera_getPosition = _Gui_Camera_getPosition;
+	sAICallback-&gt;File_locateForReading = _File_locateForReading;
+	sAICallback-&gt;File_locateForWriting = _File_locateForWriting;
+	sAICallback-&gt;Unit_STATIC_getLimit = _Unit_STATIC_getLimit;
+	sAICallback-&gt;Game_getSetupScript = _Game_getSetupScript;
+	sAICallback-&gt;Cheats_isEnabled = _Cheats_isEnabled;
+	sAICallback-&gt;Cheats_setEnabled = _Cheats_setEnabled;
+	sAICallback-&gt;Cheats_setEventsEnabled = _Cheats_setEventsEnabled;
+	sAICallback-&gt;Cheats_isOnlyPassive = _Cheats_isOnlyPassive;
+	sAICallback-&gt;ResourceInfo_Metal_getCurrent = _ResourceInfo_Metal_getCurrent;
+	sAICallback-&gt;ResourceInfo_Metal_getIncome = _ResourceInfo_Metal_getIncome;
+	sAICallback-&gt;ResourceInfo_Metal_getUsage = _ResourceInfo_Metal_getUsage;
+	sAICallback-&gt;ResourceInfo_Metal_getStorage = _ResourceInfo_Metal_getStorage;
+	sAICallback-&gt;ResourceInfo_Energy_getCurrent = _ResourceInfo_Energy_getCurrent;
+	sAICallback-&gt;ResourceInfo_Energy_getIncome = _ResourceInfo_Energy_getIncome;
+	sAICallback-&gt;ResourceInfo_Energy_getUsage = _ResourceInfo_Energy_getUsage;
+	sAICallback-&gt;ResourceInfo_Energy_getStorage = _ResourceInfo_Energy_getStorage;
+	sAICallback-&gt;File_getSize = _File_getSize;
+	sAICallback-&gt;File_getContent = _File_getContent;
+	sAICallback-&gt;UnitDef_STATIC_getIds = _UnitDef_STATIC_getIds;
+	sAICallback-&gt;UnitDef_STATIC_getNumIds = _UnitDef_STATIC_getNumIds;
+	sAICallback-&gt;UnitDef_STATIC_getIdByName = _UnitDef_STATIC_getIdByName;
+	sAICallback-&gt;UnitDef_getHeight = _UnitDef_getHeight;
+	sAICallback-&gt;UnitDef_getRadius = _UnitDef_getRadius;
+	sAICallback-&gt;UnitDef_isValid = _UnitDef_isValid;
+	sAICallback-&gt;UnitDef_getName = _UnitDef_getName;
+	sAICallback-&gt;UnitDef_getHumanName = _UnitDef_getHumanName;
+	sAICallback-&gt;UnitDef_getFilename = _UnitDef_getFilename;
+	sAICallback-&gt;UnitDef_getId = _UnitDef_getId;
+	sAICallback-&gt;UnitDef_getAiHint = _UnitDef_getAiHint;
+	sAICallback-&gt;UnitDef_getCobID = _UnitDef_getCobID;
+	sAICallback-&gt;UnitDef_getTechLevel = _UnitDef_getTechLevel;
+	sAICallback-&gt;UnitDef_getGaia = _UnitDef_getGaia;
+	sAICallback-&gt;UnitDef_getMetalUpkeep = _UnitDef_getMetalUpkeep;
+	sAICallback-&gt;UnitDef_getEnergyUpkeep = _UnitDef_getEnergyUpkeep;
+	sAICallback-&gt;UnitDef_getMetalMake = _UnitDef_getMetalMake;
+	sAICallback-&gt;UnitDef_getMakesMetal = _UnitDef_getMakesMetal;
+	sAICallback-&gt;UnitDef_getEnergyMake = _UnitDef_getEnergyMake;
+	sAICallback-&gt;UnitDef_getMetalCost = _UnitDef_getMetalCost;
+	sAICallback-&gt;UnitDef_getEnergyCost = _UnitDef_getEnergyCost;
+	sAICallback-&gt;UnitDef_getBuildTime = _UnitDef_getBuildTime;
+	sAICallback-&gt;UnitDef_getExtractsMetal = _UnitDef_getExtractsMetal;
+	sAICallback-&gt;UnitDef_getExtractRange = _UnitDef_getExtractRange;
+	sAICallback-&gt;UnitDef_getWindGenerator = _UnitDef_getWindGenerator;
+	sAICallback-&gt;UnitDef_getTidalGenerator = _UnitDef_getTidalGenerator;
+	sAICallback-&gt;UnitDef_getMetalStorage = _UnitDef_getMetalStorage;
+	sAICallback-&gt;UnitDef_getEnergyStorage = _UnitDef_getEnergyStorage;
+	sAICallback-&gt;UnitDef_getAutoHeal = _UnitDef_getAutoHeal;
+	sAICallback-&gt;UnitDef_getIdleAutoHeal = _UnitDef_getIdleAutoHeal;
+	sAICallback-&gt;UnitDef_getIdleTime = _UnitDef_getIdleTime;
+	sAICallback-&gt;UnitDef_getPower = _UnitDef_getPower;
+	sAICallback-&gt;UnitDef_getHealth = _UnitDef_getHealth;
+	sAICallback-&gt;UnitDef_getCategory = _UnitDef_getCategory;
+	sAICallback-&gt;UnitDef_getSpeed = _UnitDef_getSpeed;
+	sAICallback-&gt;UnitDef_getTurnRate = _UnitDef_getTurnRate;
+	sAICallback-&gt;UnitDef_getMoveType = _UnitDef_getMoveType;
+	sAICallback-&gt;UnitDef_isUpright = _UnitDef_isUpright;
+	sAICallback-&gt;UnitDef_isCollide = _UnitDef_isCollide;
+	sAICallback-&gt;UnitDef_getControlRadius = _UnitDef_getControlRadius;
+	sAICallback-&gt;UnitDef_getLosRadius = _UnitDef_getLosRadius;
+	sAICallback-&gt;UnitDef_getAirLosRadius = _UnitDef_getAirLosRadius;
+	sAICallback-&gt;UnitDef_getLosHeight = _UnitDef_getLosHeight;
+	sAICallback-&gt;UnitDef_getRadarRadius = _UnitDef_getRadarRadius;
+	sAICallback-&gt;UnitDef_getSonarRadius = _UnitDef_getSonarRadius;
+	sAICallback-&gt;UnitDef_getJammerRadius = _UnitDef_getJammerRadius;
+	sAICallback-&gt;UnitDef_getSonarJamRadius = _UnitDef_getSonarJamRadius;
+	sAICallback-&gt;UnitDef_getSeismicRadius = _UnitDef_getSeismicRadius;
+	sAICallback-&gt;UnitDef_getSeismicSignature = _UnitDef_getSeismicSignature;
+	sAICallback-&gt;UnitDef_isStealth = _UnitDef_isStealth;
+	sAICallback-&gt;UnitDef_isSonarStealth = _UnitDef_isSonarStealth;
+	sAICallback-&gt;UnitDef_isBuildRange3D = _UnitDef_isBuildRange3D;
+	sAICallback-&gt;UnitDef_getBuildDistance = _UnitDef_getBuildDistance;
+	sAICallback-&gt;UnitDef_getBuildSpeed = _UnitDef_getBuildSpeed;
+	sAICallback-&gt;UnitDef_getReclaimSpeed = _UnitDef_getReclaimSpeed;
+	sAICallback-&gt;UnitDef_getRepairSpeed = _UnitDef_getRepairSpeed;
+	sAICallback-&gt;UnitDef_getMaxRepairSpeed = _UnitDef_getMaxRepairSpeed;
+	sAICallback-&gt;UnitDef_getResurrectSpeed = _UnitDef_getResurrectSpeed;
+	sAICallback-&gt;UnitDef_getCaptureSpeed = _UnitDef_getCaptureSpeed;
+	sAICallback-&gt;UnitDef_getTerraformSpeed = _UnitDef_getTerraformSpeed;
+	sAICallback-&gt;UnitDef_getMass = _UnitDef_getMass;
+	sAICallback-&gt;UnitDef_isPushResistant = _UnitDef_isPushResistant;
+	sAICallback-&gt;UnitDef_isStrafeToAttack = _UnitDef_isStrafeToAttack;
+	sAICallback-&gt;UnitDef_getMinCollisionSpeed = _UnitDef_getMinCollisionSpeed;
+	sAICallback-&gt;UnitDef_getSlideTolerance = _UnitDef_getSlideTolerance;
+	sAICallback-&gt;UnitDef_getMaxSlope = _UnitDef_getMaxSlope;
+	sAICallback-&gt;UnitDef_getMaxHeightDif = _UnitDef_getMaxHeightDif;
+	sAICallback-&gt;UnitDef_getMinWaterDepth = _UnitDef_getMinWaterDepth;
+	sAICallback-&gt;UnitDef_getWaterline = _UnitDef_getWaterline;
+	sAICallback-&gt;UnitDef_getMaxWaterDepth = _UnitDef_getMaxWaterDepth;
+	sAICallback-&gt;UnitDef_getArmoredMultiple = _UnitDef_getArmoredMultiple;
+	sAICallback-&gt;UnitDef_getArmorType = _UnitDef_getArmorType;
+	sAICallback-&gt;UnitDef_getFlankingBonusMode = _UnitDef_getFlankingBonusMode;
+	sAICallback-&gt;UnitDef_getFlankingBonusDir = _UnitDef_getFlankingBonusDir;
+	sAICallback-&gt;UnitDef_getFlankingBonusMax = _UnitDef_getFlankingBonusMax;
+	sAICallback-&gt;UnitDef_getFlankingBonusMin = _UnitDef_getFlankingBonusMin;
+	sAICallback-&gt;UnitDef_getFlankingBonusMobilityAdd = _UnitDef_getFlankingBonusMobilityAdd;
+	sAICallback-&gt;UnitDef_getCollisionVolumeType = _UnitDef_getCollisionVolumeType;
+	sAICallback-&gt;UnitDef_getCollisionVolumeScales = _UnitDef_getCollisionVolumeScales;
+	sAICallback-&gt;UnitDef_getCollisionVolumeOffsets = _UnitDef_getCollisionVolumeOffsets;
+	sAICallback-&gt;UnitDef_getCollisionVolumeTest = _UnitDef_getCollisionVolumeTest;
+	sAICallback-&gt;UnitDef_getMaxWeaponRange = _UnitDef_getMaxWeaponRange;
+	sAICallback-&gt;UnitDef_getType = _UnitDef_getType;
+	sAICallback-&gt;UnitDef_getTooltip = _UnitDef_getTooltip;
+	sAICallback-&gt;UnitDef_getWreckName = _UnitDef_getWreckName;
+	sAICallback-&gt;UnitDef_getDeathExplosion = _UnitDef_getDeathExplosion;
+	sAICallback-&gt;UnitDef_getSelfDExplosion = _UnitDef_getSelfDExplosion;
+	sAICallback-&gt;UnitDef_getTedClassString = _UnitDef_getTedClassString;
+	sAICallback-&gt;UnitDef_getCategoryString = _UnitDef_getCategoryString;
+	sAICallback-&gt;UnitDef_isCanSelfD = _UnitDef_isCanSelfD;
+	sAICallback-&gt;UnitDef_getSelfDCountdown = _UnitDef_getSelfDCountdown;
+	sAICallback-&gt;UnitDef_isCanSubmerge = _UnitDef_isCanSubmerge;
+	sAICallback-&gt;UnitDef_isCanFly = _UnitDef_isCanFly;
+	sAICallback-&gt;UnitDef_isCanMove = _UnitDef_isCanMove;
+	sAICallback-&gt;UnitDef_isCanHover = _UnitDef_isCanHover;
+	sAICallback-&gt;UnitDef_isFloater = _UnitDef_isFloater;
+	sAICallback-&gt;UnitDef_isBuilder = _UnitDef_isBuilder;
+	sAICallback-&gt;UnitDef_isActivateWhenBuilt = _UnitDef_isActivateWhenBuilt;
+	sAICallback-&gt;UnitDef_isOnOffable = _UnitDef_isOnOffable;
+	sAICallback-&gt;UnitDef_isFullHealthFactory = _UnitDef_isFullHealthFactory;
+	sAICallback-&gt;UnitDef_isFactoryHeadingTakeoff = _UnitDef_isFactoryHeadingTakeoff;
+	sAICallback-&gt;UnitDef_isReclaimable = _UnitDef_isReclaimable;
+	sAICallback-&gt;UnitDef_isCapturable = _UnitDef_isCapturable;
+	sAICallback-&gt;UnitDef_isCanRestore = _UnitDef_isCanRestore;
+	sAICallback-&gt;UnitDef_isCanRepair = _UnitDef_isCanRepair;
+	sAICallback-&gt;UnitDef_isCanSelfRepair = _UnitDef_isCanSelfRepair;
+	sAICallback-&gt;UnitDef_isCanReclaim = _UnitDef_isCanReclaim;
+	sAICallback-&gt;UnitDef_isCanAttack = _UnitDef_isCanAttack;
+	sAICallback-&gt;UnitDef_isCanPatrol = _UnitDef_isCanPatrol;
+	sAICallback-&gt;UnitDef_isCanFight = _UnitDef_isCanFight;
+	sAICallback-&gt;UnitDef_isCanGuard = _UnitDef_isCanGuard;
+	sAICallback-&gt;UnitDef_isCanBuild = _UnitDef_isCanBuild;
+	sAICallback-&gt;UnitDef_isCanAssist = _UnitDef_isCanAssist;
+	sAICallback-&gt;UnitDef_isCanBeAssisted = _UnitDef_isCanBeAssisted;
+	sAICallback-&gt;UnitDef_isCanRepeat = _UnitDef_isCanRepeat;
+	sAICallback-&gt;UnitDef_isCanFireControl = _UnitDef_isCanFireControl;
+	sAICallback-&gt;UnitDef_getFireState = _UnitDef_getFireState;
+	sAICallback-&gt;UnitDef_getMoveState = _UnitDef_getMoveState;
+	sAICallback-&gt;UnitDef_getWingDrag = _UnitDef_getWingDrag;
+	sAICallback-&gt;UnitDef_getWingAngle = _UnitDef_getWingAngle;
+	sAICallback-&gt;UnitDef_getDrag = _UnitDef_getDrag;
+	sAICallback-&gt;UnitDef_getFrontToSpeed = _UnitDef_getFrontToSpeed;
+	sAICallback-&gt;UnitDef_getSpeedToFront = _UnitDef_getSpeedToFront;
+	sAICallback-&gt;UnitDef_getMyGravity = _UnitDef_getMyGravity;
+	sAICallback-&gt;UnitDef_getMaxBank = _UnitDef_getMaxBank;
+	sAICallback-&gt;UnitDef_getMaxPitch = _UnitDef_getMaxPitch;
+	sAICallback-&gt;UnitDef_getTurnRadius = _UnitDef_getTurnRadius;
+	sAICallback-&gt;UnitDef_getWantedHeight = _UnitDef_getWantedHeight;
+	sAICallback-&gt;UnitDef_getVerticalSpeed = _UnitDef_getVerticalSpeed;
+	sAICallback-&gt;UnitDef_isCanCrash = _UnitDef_isCanCrash;
+	sAICallback-&gt;UnitDef_isHoverAttack = _UnitDef_isHoverAttack;
+	sAICallback-&gt;UnitDef_isAirStrafe = _UnitDef_isAirStrafe;
+	sAICallback-&gt;UnitDef_getDlHoverFactor = _UnitDef_getDlHoverFactor;
+	sAICallback-&gt;UnitDef_getMaxAcceleration = _UnitDef_getMaxAcceleration;
+	sAICallback-&gt;UnitDef_getMaxDeceleration = _UnitDef_getMaxDeceleration;
+	sAICallback-&gt;UnitDef_getMaxAileron = _UnitDef_getMaxAileron;
+	sAICallback-&gt;UnitDef_getMaxElevator = _UnitDef_getMaxElevator;
+	sAICallback-&gt;UnitDef_getMaxRudder = _UnitDef_getMaxRudder;
+	sAICallback-&gt;UnitDef_getXSize = _UnitDef_getXSize;
+	sAICallback-&gt;UnitDef_getYSize = _UnitDef_getYSize;
+	sAICallback-&gt;UnitDef_getBuildAngle = _UnitDef_getBuildAngle;
+	sAICallback-&gt;UnitDef_getLoadingRadius = _UnitDef_getLoadingRadius;
+	sAICallback-&gt;UnitDef_getUnloadSpread = _UnitDef_getUnloadSpread;
+	sAICallback-&gt;UnitDef_getTransportCapacity = _UnitDef_getTransportCapacity;
+	sAICallback-&gt;UnitDef_getTransportSize = _UnitDef_getTransportSize;
+	sAICallback-&gt;UnitDef_getMinTransportSize = _UnitDef_getMinTransportSize;
+	sAICallback-&gt;UnitDef_isAirBase = _UnitDef_isAirBase;
+	sAICallback-&gt;UnitDef_getTransportMass = _UnitDef_getTransportMass;
+	sAICallback-&gt;UnitDef_getMinTransportMass = _UnitDef_getMinTransportMass;
+	sAICallback-&gt;UnitDef_isHoldSteady = _UnitDef_isHoldSteady;
+	sAICallback-&gt;UnitDef_isReleaseHeld = _UnitDef_isReleaseHeld;
+	sAICallback-&gt;UnitDef_isCantBeTransported = _UnitDef_isCantBeTransported;
+	sAICallback-&gt;UnitDef_isTransportByEnemy = _UnitDef_isTransportByEnemy;
+	sAICallback-&gt;UnitDef_getTransportUnloadMethod = _UnitDef_getTransportUnloadMethod;
+	sAICallback-&gt;UnitDef_getFallSpeed = _UnitDef_getFallSpeed;
+	sAICallback-&gt;UnitDef_getUnitFallSpeed = _UnitDef_getUnitFallSpeed;
+	sAICallback-&gt;UnitDef_isCanCloak = _UnitDef_isCanCloak;
+	sAICallback-&gt;UnitDef_isStartCloaked = _UnitDef_isStartCloaked;
+	sAICallback-&gt;UnitDef_getCloakCost = _UnitDef_getCloakCost;
+	sAICallback-&gt;UnitDef_getCloakCostMoving = _UnitDef_getCloakCostMoving;
+	sAICallback-&gt;UnitDef_getDecloakDistance = _UnitDef_getDecloakDistance;
+	sAICallback-&gt;UnitDef_isDecloakSpherical = _UnitDef_isDecloakSpherical;
+	sAICallback-&gt;UnitDef_isDecloakOnFire = _UnitDef_isDecloakOnFire;
+	sAICallback-&gt;UnitDef_isCanKamikaze = _UnitDef_isCanKamikaze;
+	sAICallback-&gt;UnitDef_getKamikazeDist = _UnitDef_getKamikazeDist;
+	sAICallback-&gt;UnitDef_isTargetingFacility = _UnitDef_isTargetingFacility;
+	sAICallback-&gt;UnitDef_isCanDGun = _UnitDef_isCanDGun;
+	sAICallback-&gt;UnitDef_isNeedGeo = _UnitDef_isNeedGeo;
+	sAICallback-&gt;UnitDef_isFeature = _UnitDef_isFeature;
+	sAICallback-&gt;UnitDef_isHideDamage = _UnitDef_isHideDamage;
+	sAICallback-&gt;UnitDef_isCommander = _UnitDef_isCommander;
+	sAICallback-&gt;UnitDef_isShowPlayerName = _UnitDef_isShowPlayerName;
+	sAICallback-&gt;UnitDef_isCanResurrect = _UnitDef_isCanResurrect;
+	sAICallback-&gt;UnitDef_isCanCapture = _UnitDef_isCanCapture;
+	sAICallback-&gt;UnitDef_getHighTrajectoryType = _UnitDef_getHighTrajectoryType;
+	sAICallback-&gt;UnitDef_getNoChaseCategory = _UnitDef_getNoChaseCategory;
+	sAICallback-&gt;UnitDef_isLeaveTracks = _UnitDef_isLeaveTracks;
+	sAICallback-&gt;UnitDef_getTrackWidth = _UnitDef_getTrackWidth;
+	sAICallback-&gt;UnitDef_getTrackOffset = _UnitDef_getTrackOffset;
+	sAICallback-&gt;UnitDef_getTrackStrength = _UnitDef_getTrackStrength;
+	sAICallback-&gt;UnitDef_getTrackStretch = _UnitDef_getTrackStretch;
+	sAICallback-&gt;UnitDef_getTrackType = _UnitDef_getTrackType;
+	sAICallback-&gt;UnitDef_isCanDropFlare = _UnitDef_isCanDropFlare;
+	sAICallback-&gt;UnitDef_getFlareReloadTime = _UnitDef_getFlareReloadTime;
+	sAICallback-&gt;UnitDef_getFlareEfficiency = _UnitDef_getFlareEfficiency;
+	sAICallback-&gt;UnitDef_getFlareDelay = _UnitDef_getFlareDelay;
+	sAICallback-&gt;UnitDef_getFlareDropVector = _UnitDef_getFlareDropVector;
+	sAICallback-&gt;UnitDef_getFlareTime = _UnitDef_getFlareTime;
+	sAICallback-&gt;UnitDef_getFlareSalvoSize = _UnitDef_getFlareSalvoSize;
+	sAICallback-&gt;UnitDef_getFlareSalvoDelay = _UnitDef_getFlareSalvoDelay;
+	sAICallback-&gt;UnitDef_isSmoothAnim = _UnitDef_isSmoothAnim;
+	sAICallback-&gt;UnitDef_isMetalMaker = _UnitDef_isMetalMaker;
+	sAICallback-&gt;UnitDef_isCanLoopbackAttack = _UnitDef_isCanLoopbackAttack;
+	sAICallback-&gt;UnitDef_isLevelGround = _UnitDef_isLevelGround;
+	sAICallback-&gt;UnitDef_isUseBuildingGroundDecal = _UnitDef_isUseBuildingGroundDecal;
+	sAICallback-&gt;UnitDef_getBuildingDecalType = _UnitDef_getBuildingDecalType;
+	sAICallback-&gt;UnitDef_getBuildingDecalSizeX = _UnitDef_getBuildingDecalSizeX;
+	sAICallback-&gt;UnitDef_getBuildingDecalSizeY = _UnitDef_getBuildingDecalSizeY;
+	sAICallback-&gt;UnitDef_getBuildingDecalDecaySpeed = _UnitDef_getBuildingDecalDecaySpeed;
+	sAICallback-&gt;UnitDef_isFirePlatform = _UnitDef_isFirePlatform;
+	sAICallback-&gt;UnitDef_getMaxFuel = _UnitDef_getMaxFuel;
+	sAICallback-&gt;UnitDef_getRefuelTime = _UnitDef_getRefuelTime;
+	sAICallback-&gt;UnitDef_getMinAirBasePower = _UnitDef_getMinAirBasePower;
+	sAICallback-&gt;UnitDef_getMaxThisUnit = _UnitDef_getMaxThisUnit;
+	sAICallback-&gt;UnitDef_getDecoyDefId = _UnitDef_getDecoyDefId;
+	sAICallback-&gt;UnitDef_isDontLand = _UnitDef_isDontLand;
+	sAICallback-&gt;UnitDef_getShieldWeaponDefId = _UnitDef_getShieldWeaponDefId;
+	sAICallback-&gt;UnitDef_getStockpileWeaponDefId = _UnitDef_getStockpileWeaponDefId;
+	sAICallback-&gt;UnitDef_getNumBuildOptions = _UnitDef_getNumBuildOptions;
+	sAICallback-&gt;UnitDef_getBuildOptions = _UnitDef_getBuildOptions;
+	sAICallback-&gt;UnitDef_getNumCustomParams = _UnitDef_getNumCustomParams;
+	sAICallback-&gt;UnitDef_getCustomParams = _UnitDef_getCustomParams;
+	sAICallback-&gt;UnitDef_hasMoveData = _UnitDef_hasMoveData;
+	sAICallback-&gt;UnitDef_MoveData_getMoveType = _UnitDef_MoveData_getMoveType;
+	sAICallback-&gt;UnitDef_MoveData_getMoveFamily = _UnitDef_MoveData_getMoveFamily;
+	sAICallback-&gt;UnitDef_MoveData_getSize = _UnitDef_MoveData_getSize;
+	sAICallback-&gt;UnitDef_MoveData_getDepth = _UnitDef_MoveData_getDepth;
+	sAICallback-&gt;UnitDef_MoveData_getMaxSlope = _UnitDef_MoveData_getMaxSlope;
+	sAICallback-&gt;UnitDef_MoveData_getSlopeMod = _UnitDef_MoveData_getSlopeMod;
+	sAICallback-&gt;UnitDef_MoveData_getDepthMod = _UnitDef_MoveData_getDepthMod;
+	sAICallback-&gt;UnitDef_MoveData_getPathType = _UnitDef_MoveData_getPathType;
+	sAICallback-&gt;UnitDef_MoveData_getCrushStrength = _UnitDef_MoveData_getCrushStrength;
+	sAICallback-&gt;UnitDef_MoveData_getMaxSpeed = _UnitDef_MoveData_getMaxSpeed;
+	sAICallback-&gt;UnitDef_MoveData_getMaxTurnRate = _UnitDef_MoveData_getMaxTurnRate;
+	sAICallback-&gt;UnitDef_MoveData_getMaxAcceleration = _UnitDef_MoveData_getMaxAcceleration;
+	sAICallback-&gt;UnitDef_MoveData_getMaxBreaking = _UnitDef_MoveData_getMaxBreaking;
+	sAICallback-&gt;UnitDef_MoveData_isSubMarine = _UnitDef_MoveData_isSubMarine;
+	sAICallback-&gt;UnitDef_getNumUnitDefWeapons = _UnitDef_getNumUnitDefWeapons;
+	sAICallback-&gt;UnitDef_UnitDefWeapon_getName = _UnitDef_UnitDefWeapon_getName;
+	sAICallback-&gt;UnitDef_UnitDefWeapon_getWeaponDefId = _UnitDef_UnitDefWeapon_getWeaponDefId;
+	sAICallback-&gt;UnitDef_UnitDefWeapon_getSlavedTo = _UnitDef_UnitDefWeapon_getSlavedTo;
+	sAICallback-&gt;UnitDef_UnitDefWeapon_getMainDir = _UnitDef_UnitDefWeapon_getMainDir;
+	sAICallback-&gt;UnitDef_UnitDefWeapon_getMaxAngleDif = _UnitDef_UnitDefWeapon_getMaxAngleDif;
+	sAICallback-&gt;UnitDef_UnitDefWeapon_getFuelUsage = _UnitDef_UnitDefWeapon_getFuelUsage;
+	sAICallback-&gt;UnitDef_UnitDefWeapon_getBadTargetCat = _UnitDef_UnitDefWeapon_getBadTargetCat;
+	sAICallback-&gt;UnitDef_UnitDefWeapon_getOnlyTargetCat = _UnitDef_UnitDefWeapon_getOnlyTargetCat;
+	sAICallback-&gt;Unit_STATIC_getEnemies = _Unit_STATIC_getEnemies;
+	sAICallback-&gt;Unit_STATIC_getEnemiesIn = _Unit_STATIC_getEnemiesIn;
+	sAICallback-&gt;Unit_STATIC_getEnemiesInRadarAndLos = _Unit_STATIC_getEnemiesInRadarAndLos;
+	sAICallback-&gt;Unit_STATIC_getFriendlies = _Unit_STATIC_getFriendlies;
+	sAICallback-&gt;Unit_STATIC_getFriendliesIn = _Unit_STATIC_getFriendliesIn;
+	sAICallback-&gt;Unit_STATIC_getNeutrals = _Unit_STATIC_getNeutrals;
+	sAICallback-&gt;Unit_STATIC_getNeutralsIn = _Unit_STATIC_getNeutralsIn;
+	sAICallback-&gt;Unit_STATIC_getSelected = _Unit_STATIC_getSelected;
+	sAICallback-&gt;Unit_getDefId = _Unit_getDefId;
+	sAICallback-&gt;Unit_getAiHint = _Unit_getAiHint;
+	sAICallback-&gt;Unit_getTeam = _Unit_getTeam;
+	sAICallback-&gt;Unit_getAllyTeam = _Unit_getAllyTeam;
+	sAICallback-&gt;Unit_getStockpile = _Unit_getStockpile;
+	sAICallback-&gt;Unit_getStockpileQueued = _Unit_getStockpileQueued;
+	sAICallback-&gt;Unit_getCurrentFuel = _Unit_getCurrentFuel;
+	sAICallback-&gt;Unit_getMaxSpeed = _Unit_getMaxSpeed;
+	sAICallback-&gt;Unit_getMaxRange = _Unit_getMaxRange;
+	sAICallback-&gt;Unit_getMaxHealth = _Unit_getMaxHealth;
+	sAICallback-&gt;Unit_getExperience = _Unit_getExperience;
+	sAICallback-&gt;Unit_getGroup = _Unit_getGroup;
+	sAICallback-&gt;Unit_getNumCurrentCommands = _Unit_getNumCurrentCommands;
+	sAICallback-&gt;Unit_CurrentCommands_getType = _Unit_CurrentCommands_getType;
+	sAICallback-&gt;Unit_CurrentCommands_getIds = _Unit_CurrentCommands_getIds;
+	sAICallback-&gt;Unit_CurrentCommands_getOptions = _Unit_CurrentCommands_getOptions;
+	sAICallback-&gt;Unit_CurrentCommands_getTag = _Unit_CurrentCommands_getTag;
+	sAICallback-&gt;Unit_CurrentCommands_getTimeOut = _Unit_CurrentCommands_getTimeOut;
+	sAICallback-&gt;Unit_CurrentCommands_getNumParams = _Unit_CurrentCommands_getNumParams;
+	sAICallback-&gt;Unit_CurrentCommands_getParams = _Unit_CurrentCommands_getParams;
+	sAICallback-&gt;Unit_getNumSupportedCommands = _Unit_getNumSupportedCommands;
+	sAICallback-&gt;Unit_SupportedCommands_getId = _Unit_SupportedCommands_getId;
+	sAICallback-&gt;Unit_SupportedCommands_getName = _Unit_SupportedCommands_getName;
+	sAICallback-&gt;Unit_SupportedCommands_getToolTip = _Unit_SupportedCommands_getToolTip;
+	sAICallback-&gt;Unit_SupportedCommands_isShowUnique = _Unit_SupportedCommands_isShowUnique;
+	sAICallback-&gt;Unit_SupportedCommands_isDisabled = _Unit_SupportedCommands_isDisabled;
+	sAICallback-&gt;Unit_SupportedCommands_getNumParams = _Unit_SupportedCommands_getNumParams;
+	sAICallback-&gt;Unit_SupportedCommands_getParams = _Unit_SupportedCommands_getParams;
+	sAICallback-&gt;Unit_getHealth = _Unit_getHealth;
+	sAICallback-&gt;Unit_getSpeed = _Unit_getSpeed;
+	sAICallback-&gt;Unit_getPower = _Unit_getPower;
+	sAICallback-&gt;Unit_ResourceInfo_Metal_getUse = _Unit_ResourceInfo_Metal_getUse;
+	sAICallback-&gt;Unit_ResourceInfo_Metal_getMake = _Unit_ResourceInfo_Metal_getMake;
+	sAICallback-&gt;Unit_ResourceInfo_Energy_getUse = _Unit_ResourceInfo_Energy_getUse;
+	sAICallback-&gt;Unit_ResourceInfo_Energy_getMake = _Unit_ResourceInfo_Energy_getMake;
+	sAICallback-&gt;Unit_getPos = _Unit_getPos;
+	sAICallback-&gt;Unit_isActivated = _Unit_isActivated;
+	sAICallback-&gt;Unit_isBeingBuilt = _Unit_isBeingBuilt;
+	sAICallback-&gt;Unit_isCloaked = _Unit_isCloaked;
+	sAICallback-&gt;Unit_isParalyzed = _Unit_isParalyzed;
+	sAICallback-&gt;Unit_isNeutral = _Unit_isNeutral;
+	sAICallback-&gt;Unit_getBuildingFacing = _Unit_getBuildingFacing;
+	sAICallback-&gt;Group_getNumSupportedCommands = _Group_getNumSupportedCommands;
+	sAICallback-&gt;Group_SupportedCommands_getId = _Group_SupportedCommands_getId;
+	sAICallback-&gt;Group_SupportedCommands_getName = _Group_SupportedCommands_getName;
+	sAICallback-&gt;Group_SupportedCommands_getToolTip = _Group_SupportedCommands_getToolTip;
+	sAICallback-&gt;Group_SupportedCommands_isShowUnique = _Group_SupportedCommands_isShowUnique;
+	sAICallback-&gt;Group_SupportedCommands_isDisabled = _Group_SupportedCommands_isDisabled;
+	sAICallback-&gt;Group_SupportedCommands_getNumParams = _Group_SupportedCommands_getNumParams;
+	sAICallback-&gt;Group_SupportedCommands_getParams = _Group_SupportedCommands_getParams;
+	sAICallback-&gt;Mod_getName = _Mod_getName;
+	sAICallback-&gt;Map_getStartPos = _Map_getStartPos;
+	sAICallback-&gt;Map_getMousePos = _Map_getMousePos;
+	sAICallback-&gt;Map_isPosInCamera = _Map_isPosInCamera;
+	sAICallback-&gt;Map_getWidth = _Map_getWidth;
+	sAICallback-&gt;Map_getHeight = _Map_getHeight;
+	sAICallback-&gt;Map_getHeightMap = _Map_getHeightMap;
+	sAICallback-&gt;Map_getMinHeight = _Map_getMinHeight;
+	sAICallback-&gt;Map_getMaxHeight = _Map_getMaxHeight;
+	sAICallback-&gt;Map_getSlopeMap = _Map_getSlopeMap;
+	sAICallback-&gt;Map_getLosMap = _Map_getLosMap;
+	sAICallback-&gt;Map_getRadarMap = _Map_getRadarMap;
+	sAICallback-&gt;Map_getJammerMap = _Map_getJammerMap;
+	sAICallback-&gt;Map_getMetalMap = _Map_getMetalMap;
+	sAICallback-&gt;Map_getName = _Map_getName;
+	sAICallback-&gt;Map_getElevationAt = _Map_getElevationAt;
+	sAICallback-&gt;Map_getMaxMetal = _Map_getMaxMetal;
+	sAICallback-&gt;Map_getExtractorRadius = _Map_getExtractorRadius;
+	sAICallback-&gt;Map_getMinWind = _Map_getMinWind;
+	sAICallback-&gt;Map_getMaxWind = _Map_getMaxWind;
+	sAICallback-&gt;Map_getTidalStrength = _Map_getTidalStrength;
+	sAICallback-&gt;Map_getGravity = _Map_getGravity;
+	sAICallback-&gt;Map_getPoints = _Map_getPoints;
+	sAICallback-&gt;Map_getLines = _Map_getLines;
+	sAICallback-&gt;Map_canBuildAt = _Map_canBuildAt;
+	sAICallback-&gt;Map_findClosestBuildSite = _Map_findClosestBuildSite;
+	sAICallback-&gt;FeatureDef_getName = _FeatureDef_getName;
+	sAICallback-&gt;FeatureDef_getDescription = _FeatureDef_getDescription;
+	sAICallback-&gt;FeatureDef_getFilename = _FeatureDef_getFilename;
+	sAICallback-&gt;FeatureDef_getId = _FeatureDef_getId;
+	sAICallback-&gt;FeatureDef_getMetal = _FeatureDef_getMetal;
+	sAICallback-&gt;FeatureDef_getEnergy = _FeatureDef_getEnergy;
+	sAICallback-&gt;FeatureDef_getMaxHealth = _FeatureDef_getMaxHealth;
+	sAICallback-&gt;FeatureDef_getReclaimTime = _FeatureDef_getReclaimTime;
+	sAICallback-&gt;FeatureDef_getMass = _FeatureDef_getMass;
+	sAICallback-&gt;FeatureDef_getCollisionVolumeType = _FeatureDef_getCollisionVolumeType;
+	sAICallback-&gt;FeatureDef_getCollisionVolumeScales = _FeatureDef_getCollisionVolumeScales;
+	sAICallback-&gt;FeatureDef_getCollisionVolumeOffsets = _FeatureDef_getCollisionVolumeOffsets;
+	sAICallback-&gt;FeatureDef_getCollisionVolumeTest = _FeatureDef_getCollisionVolumeTest;
+	sAICallback-&gt;FeatureDef_isUpright = _FeatureDef_isUpright;
+	sAICallback-&gt;FeatureDef_getDrawType = _FeatureDef_getDrawType;
+	sAICallback-&gt;FeatureDef_getModelName = _FeatureDef_getModelName;
+	sAICallback-&gt;FeatureDef_getModelType = _FeatureDef_getModelType;
+	sAICallback-&gt;FeatureDef_isDestructable = _FeatureDef_isDestructable;
+	sAICallback-&gt;FeatureDef_isReclaimable = _FeatureDef_isReclaimable;
+	sAICallback-&gt;FeatureDef_isBlocking = _FeatureDef_isBlocking;
+	sAICallback-&gt;FeatureDef_isBurnable = _FeatureDef_isBurnable;
+	sAICallback-&gt;FeatureDef_isFloating = _FeatureDef_isFloating;
+	sAICallback-&gt;FeatureDef_isNoSelect = _FeatureDef_isNoSelect;
+	sAICallback-&gt;FeatureDef_isGeoThermal = _FeatureDef_isGeoThermal;
+	sAICallback-&gt;FeatureDef_getDeathFeature = _FeatureDef_getDeathFeature;
+	sAICallback-&gt;FeatureDef_getXsize = _FeatureDef_getXsize;
+	sAICallback-&gt;FeatureDef_getYsize = _FeatureDef_getYsize;
+	sAICallback-&gt;FeatureDef_getNumCustomParams = _FeatureDef_getNumCustomParams;
+	sAICallback-&gt;FeatureDef_getCustomParams = _FeatureDef_getCustomParams;
+	sAICallback-&gt;Feature_STATIC_getIds = _Feature_STATIC_getIds;
+	sAICallback-&gt;Feature_STATIC_getIdsIn = _Feature_STATIC_getIdsIn;
+	sAICallback-&gt;Feature_getDefId = _Feature_getDefId;
+	sAICallback-&gt;Feature_getHealth = _Feature_getHealth;
+	sAICallback-&gt;Feature_getReclaimLeft = _Feature_getReclaimLeft;
+	sAICallback-&gt;Feature_getPos = _Feature_getPos;
+	sAICallback-&gt;WeaponDef_STATIC_getIdByName = _WeaponDef_STATIC_getIdByName;
+	sAICallback-&gt;WeaponDef_getName = _WeaponDef_getName;
+	sAICallback-&gt;WeaponDef_getType = _WeaponDef_getType;
+	sAICallback-&gt;WeaponDef_getDescription = _WeaponDef_getDescription;
+	sAICallback-&gt;WeaponDef_getFilename = _WeaponDef_getFilename;
+	sAICallback-&gt;WeaponDef_getCegTag = _WeaponDef_getCegTag;
+	sAICallback-&gt;WeaponDef_getRange = _WeaponDef_getRange;
+	sAICallback-&gt;WeaponDef_getHeightMod = _WeaponDef_getHeightMod;
+	sAICallback-&gt;WeaponDef_getAccuracy = _WeaponDef_getAccuracy;
+	sAICallback-&gt;WeaponDef_getSprayAngle = _WeaponDef_getSprayAngle;
+	sAICallback-&gt;WeaponDef_getMovingAccuracy = _WeaponDef_getMovingAccuracy;
+	sAICallback-&gt;WeaponDef_getTargetMoveError = _WeaponDef_getTargetMoveError;
+	sAICallback-&gt;WeaponDef_getLeadLimit = _WeaponDef_getLeadLimit;
+	sAICallback-&gt;WeaponDef_getLeadBonus = _WeaponDef_getLeadBonus;
+	sAICallback-&gt;WeaponDef_getPredictBoost = _WeaponDef_getPredictBoost;
+	sAICallback-&gt;WeaponDef_Damages_getParalyzeDamageTime = _WeaponDef_Damages_getParalyzeDamageTime;
+	sAICallback-&gt;WeaponDef_Damages_getImpulseFactor = _WeaponDef_Damages_getImpulseFactor;
+	sAICallback-&gt;WeaponDef_Damages_getImpulseBoost = _WeaponDef_Damages_getImpulseBoost;
+	sAICallback-&gt;WeaponDef_Damages_getCraterMult = _WeaponDef_Damages_getCraterMult;
+	sAICallback-&gt;WeaponDef_Damages_getCraterBoost = _WeaponDef_Damages_getCraterBoost;
+	sAICallback-&gt;WeaponDef_Damages_getNumTypes = _WeaponDef_Damages_getNumTypes;
+	sAICallback-&gt;WeaponDef_Damages_getTypeDamages = _WeaponDef_Damages_getTypeDamages;
+	sAICallback-&gt;WeaponDef_getAreaOfEffect = _WeaponDef_getAreaOfEffect;
+	sAICallback-&gt;WeaponDef_isNoSelfDamage = _WeaponDef_isNoSelfDamage;
+	sAICallback-&gt;WeaponDef_getFireStarter = _WeaponDef_getFireStarter;
+	sAICallback-&gt;WeaponDef_getEdgeEffectiveness = _WeaponDef_getEdgeEffectiveness;
+	sAICallback-&gt;WeaponDef_getSize = _WeaponDef_getSize;
+	sAICallback-&gt;WeaponDef_getSizeGrowth = _WeaponDef_getSizeGrowth;
+	sAICallback-&gt;WeaponDef_getCollisionSize = _WeaponDef_getCollisionSize;
+	sAICallback-&gt;WeaponDef_getSalvoSize = _WeaponDef_getSalvoSize;
+	sAICallback-&gt;WeaponDef_getSalvoDelay = _WeaponDef_getSalvoDelay;
+	sAICallback-&gt;WeaponDef_getReload = _WeaponDef_getReload;
+	sAICallback-&gt;WeaponDef_getBeamTime = _WeaponDef_getBeamTime;
+	sAICallback-&gt;WeaponDef_isBeamBurst = _WeaponDef_isBeamBurst;
+	sAICallback-&gt;WeaponDef_isWaterBounce = _WeaponDef_isWaterBounce;
+	sAICallback-&gt;WeaponDef_isGroundBounce = _WeaponDef_isGroundBounce;
+	sAICallback-&gt;WeaponDef_getBounceRebound = _WeaponDef_getBounceRebound;
+	sAICallback-&gt;WeaponDef_getBounceSlip = _WeaponDef_getBounceSlip;
+	sAICallback-&gt;WeaponDef_getNumBounce = _WeaponDef_getNumBounce;
+	sAICallback-&gt;WeaponDef_getMaxAngle = _WeaponDef_getMaxAngle;
+	sAICallback-&gt;WeaponDef_getRestTime = _WeaponDef_getRestTime;
+	sAICallback-&gt;WeaponDef_getUpTime = _WeaponDef_getUpTime;
+	sAICallback-&gt;WeaponDef_getFlightTime = _WeaponDef_getFlightTime;
+	sAICallback-&gt;WeaponDef_getMetalCost = _WeaponDef_getMetalCost;
+	sAICallback-&gt;WeaponDef_getEnergyCost = _WeaponDef_getEnergyCost;
+	sAICallback-&gt;WeaponDef_getSupplyCost = _WeaponDef_getSupplyCost;
+	sAICallback-&gt;WeaponDef_getProjectilesPerShot = _WeaponDef_getProjectilesPerShot;
+	sAICallback-&gt;WeaponDef_getId = _WeaponDef_getId;
+	sAICallback-&gt;WeaponDef_getTdfId = _WeaponDef_getTdfId;
+	sAICallback-&gt;WeaponDef_isTurret = _WeaponDef_isTurret;
+	sAICallback-&gt;WeaponDef_isOnlyForward = _WeaponDef_isOnlyForward;
+	sAICallback-&gt;WeaponDef_isFixedLauncher = _WeaponDef_isFixedLauncher;
+	sAICallback-&gt;WeaponDef_isWaterWeapon = _WeaponDef_isWaterWeapon;
+	sAICallback-&gt;WeaponDef_isFireSubmersed = _WeaponDef_isFireSubmersed;
+	sAICallback-&gt;WeaponDef_isSubMissile = _WeaponDef_isSubMissile;
+	sAICallback-&gt;WeaponDef_isTracks = _WeaponDef_isTracks;
+	sAICallback-&gt;WeaponDef_isDropped = _WeaponDef_isDropped;
+	sAICallback-&gt;WeaponDef_isParalyzer = _WeaponDef_isParalyzer;
+	sAICallback-&gt;WeaponDef_isImpactOnly = _WeaponDef_isImpactOnly;
+	sAICallback-&gt;WeaponDef_isNoAutoTarget = _WeaponDef_isNoAutoTarget;
+	sAICallback-&gt;WeaponDef_isManualFire = _WeaponDef_isManualFire;
+	sAICallback-&gt;WeaponDef_getInterceptor = _WeaponDef_getInterceptor;
+	sAICallback-&gt;WeaponDef_getTargetable = _WeaponDef_getTargetable;
+	sAICallback-&gt;WeaponDef_isStockpileable = _WeaponDef_isStockpileable;
+	sAICallback-&gt;WeaponDef_getCoverageRange = _WeaponDef_getCoverageRange;
+	sAICallback-&gt;WeaponDef_getIntensity = _WeaponDef_getIntensity;
+	sAICallback-&gt;WeaponDef_getThickness = _WeaponDef_getThickness;
+	sAICallback-&gt;WeaponDef_getLaserFlareSize = _WeaponDef_getLaserFlareSize;
+	sAICallback-&gt;WeaponDef_getCoreThickness = _WeaponDef_getCoreThickness;
+	sAICallback-&gt;WeaponDef_getDuration = _WeaponDef_getDuration;
+	sAICallback-&gt;WeaponDef_getLodDistance = _WeaponDef_getLodDistance;
+	sAICallback-&gt;WeaponDef_getFalloffRate = _WeaponDef_getFalloffRate;
+	sAICallback-&gt;WeaponDef_getGraphicsType = _WeaponDef_getGraphicsType;
+	sAICallback-&gt;WeaponDef_isSoundTrigger = _WeaponDef_isSoundTrigger;
+	sAICallback-&gt;WeaponDef_isSelfExplode = _WeaponDef_isSelfExplode;
+	sAICallback-&gt;WeaponDef_isGravityAffected = _WeaponDef_isGravityAffected;
+	sAICallback-&gt;WeaponDef_getHighTrajectory = _WeaponDef_getHighTrajectory;
+	sAICallback-&gt;WeaponDef_getMyGravity = _WeaponDef_getMyGravity;
+	sAICallback-&gt;WeaponDef_isTwoPhase = _WeaponDef_isTwoPhase;
+	sAICallback-&gt;WeaponDef_isGuided = _WeaponDef_isGuided;
+	sAICallback-&gt;WeaponDef_isVLaunched = _WeaponDef_isVLaunched;
+	sAICallback-&gt;WeaponDef_isSelfPropelled = _WeaponDef_isSelfPropelled;
+	sAICallback-&gt;WeaponDef_isNoExplode = _WeaponDef_isNoExplode;
+	sAICallback-&gt;WeaponDef_getStartVelocity = _WeaponDef_getStartVelocity;
+	sAICallback-&gt;WeaponDef_getWeaponAcceleration = _WeaponDef_getWeaponAcceleration;
+	sAICallback-&gt;WeaponDef_getTurnRate = _WeaponDef_getTurnRate;
+	sAICallback-&gt;WeaponDef_getMaxVelocity = _WeaponDef_getMaxVelocity;
+	sAICallback-&gt;WeaponDef_getProjectileSpeed = _WeaponDef_getProjectileSpeed;
+	sAICallback-&gt;WeaponDef_getExplosionSpeed = _WeaponDef_getExplosionSpeed;
+	sAICallback-&gt;WeaponDef_getOnlyTargetCategory = _WeaponDef_getOnlyTargetCategory;
+	sAICallback-&gt;WeaponDef_getWobble = _WeaponDef_getWobble;
+	sAICallback-&gt;WeaponDef_getDance = _WeaponDef_getDance;
+	sAICallback-&gt;WeaponDef_getTrajectoryHeight = _WeaponDef_getTrajectoryHeight;
+	sAICallback-&gt;WeaponDef_isLargeBeamLaser = _WeaponDef_isLargeBeamLaser;
+	sAICallback-&gt;WeaponDef_isShield = _WeaponDef_isShield;
+	sAICallback-&gt;WeaponDef_isShieldRepulser = _WeaponDef_isShieldRepulser;
+	sAICallback-&gt;WeaponDef_isSmartShield = _WeaponDef_isSmartShield;
+	sAICallback-&gt;WeaponDef_isExteriorShield = _WeaponDef_isExteriorShield;
+	sAICallback-&gt;WeaponDef_isVisibleShield = _WeaponDef_isVisibleShield;
+	sAICallback-&gt;WeaponDef_isVisibleShieldRepulse = _WeaponDef_isVisibleShieldRepulse;
+	sAICallback-&gt;WeaponDef_getVisibleShieldHitFrames = _WeaponDef_getVisibleShieldHitFrames;
+	sAICallback-&gt;WeaponDef_getShieldEnergyUse = _WeaponDef_getShieldEnergyUse;
+	sAICallback-&gt;WeaponDef_getShieldRadius = _WeaponDef_getShieldRadius;
+	sAICallback-&gt;WeaponDef_getShieldForce = _WeaponDef_getShieldForce;
+	sAICallback-&gt;WeaponDef_getShieldMaxSpeed = _WeaponDef_getShieldMaxSpeed;
+	sAICallback-&gt;WeaponDef_getShieldPower = _WeaponDef_getShieldPower;
+	sAICallback-&gt;WeaponDef_getShieldPowerRegen = _WeaponDef_getShieldPowerRegen;
+	sAICallback-&gt;WeaponDef_getShieldPowerRegenEnergy = _WeaponDef_getShieldPowerRegenEnergy;
+	sAICallback-&gt;WeaponDef_getShieldStartingPower = _WeaponDef_getShieldStartingPower;
+	sAICallback-&gt;WeaponDef_getShieldRechargeDelay = _WeaponDef_getShieldRechargeDelay;
+	sAICallback-&gt;WeaponDef_getShieldGoodColor = _WeaponDef_getShieldGoodColor;
+	sAICallback-&gt;WeaponDef_getShieldBadColor = _WeaponDef_getShieldBadColor;
+	sAICallback-&gt;WeaponDef_getShieldAlpha = _WeaponDef_getShieldAlpha;
+	sAICallback-&gt;WeaponDef_getShieldInterceptType = _WeaponDef_getShieldInterceptType;
+	sAICallback-&gt;WeaponDef_getInterceptedByShieldType = _WeaponDef_getInterceptedByShieldType;
+	sAICallback-&gt;WeaponDef_isAvoidFriendly = _WeaponDef_isAvoidFriendly;
+	sAICallback-&gt;WeaponDef_isAvoidFeature = _WeaponDef_isAvoidFeature;
+	sAICallback-&gt;WeaponDef_isAvoidNeutral = _WeaponDef_isAvoidNeutral;
+	sAICallback-&gt;WeaponDef_getTargetBorder = _WeaponDef_getTargetBorder;
+	sAICallback-&gt;WeaponDef_getCylinderTargetting = _WeaponDef_getCylinderTargetting;
+	sAICallback-&gt;WeaponDef_getMinIntensity = _WeaponDef_getMinIntensity;
+	sAICallback-&gt;WeaponDef_getHeightBoostFactor = _WeaponDef_getHeightBoostFactor;
+	sAICallback-&gt;WeaponDef_getProximityPriority = _WeaponDef_getProximityPriority;
+	sAICallback-&gt;WeaponDef_getCollisionFlags = _WeaponDef_getCollisionFlags;
+	sAICallback-&gt;WeaponDef_isSweepFire = _WeaponDef_isSweepFire;
+	sAICallback-&gt;WeaponDef_isCanAttackGround = _WeaponDef_isCanAttackGround;
+	sAICallback-&gt;WeaponDef_getCameraShake = _WeaponDef_getCameraShake;
+	sAICallback-&gt;WeaponDef_getDynDamageExp = _WeaponDef_getDynDamageExp;
+	sAICallback-&gt;WeaponDef_getDynDamageMin = _WeaponDef_getDynDamageMin;
+	sAICallback-&gt;WeaponDef_getDynDamageRange = _WeaponDef_getDynDamageRange;
+	sAICallback-&gt;WeaponDef_isDynDamageInverted = _WeaponDef_isDynDamageInverted;
+	sAICallback-&gt;WeaponDef_getNumCustomParams = _WeaponDef_getNumCustomParams;
+	sAICallback-&gt;WeaponDef_getCustomParams = _WeaponDef_getCustomParams;
+	
+	team_globalCallback[teamId] = aiGlobalCallback;
+//	team_callback[teamId] = aiCallback;
+	team_callback[teamId] = aiGlobalCallback-&gt;GetAICallback();
+	
+	return sAICallback;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/SAICallback.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/SAICallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAICallback.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SAICallback.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,665 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SAICALLBACK_H
+#define	_SAICALLBACK_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+    
+#define MAX_AIS 32
+    
+#include &quot;SAIFloat3.h&quot;
+
+
+/**
+ * Global AI Callback function pointers.
+ */
+struct SAICallback {
+
+/**
+ * Whenever an AI wants to change engine state in any way, it has to call this method.
+ * In other words, all commands from AIs to the engine (and other AIs) go through this method.
+ *
+ * teamId	the team number of the AI that sends the command
+ * toId		the team number of the AI that should receive the command,
+ * 		or COMMAND_TO_ID_ENGINE if it is meant for the engine
+ * commandId	used on asynchronous commands, this allows the AI to identify
+ * 		a possible result event, which would come with the same id
+ * commandTopic	unique identifyer of a command (see COMMAND_* defines in AISCommands.h)
+ * commandData	a commandTopic specific struct, which contains the data associated
+ * 		with the command (see *Command structs)
+ * return	0 if command handling ok, something else otherwise
+ */
+int (*handleCommand)(int teamId, int toId, int commandId, int commandTopic, void* commandData);
+
+
+// BEGINN misc callback functions
+int (*Game_getCurrentFrame)(int teamId); //TODO: deprecate, becuase we get the frame from the SUpdateEvent
+int (*Game_getAiInterfaceVersion)(int teamId);
+int (*Game_getMyTeam)(int teamId);
+int (*Game_getMyAllyTeam)(int teamId);
+int (*Game_getPlayerTeam)(int teamId, int playerId);
+const char* (*Game_getTeamSide)(int teamId, int otherTeamId);
+// END misc callback functions
+
+int (*WeaponDef_STATIC_getNumDamageTypes)(int teamId);
+unsigned int (*Map_getChecksum)(int teamId);
+
+bool (*Game_isExceptionHandlingEnabled)(int teamId);
+bool (*Game_isDebugModeEnabled)(int teamId);
+int (*Game_getMode)(int teamId);
+bool (*Game_isPaused)(int teamId);
+float (*Game_getSpeedFactor)(int teamId);
+
+float (*Gui_getViewRange)(int teamId);
+float (*Gui_getScreenX)(int teamId);
+float (*Gui_getScreenY)(int teamId);
+SAIFloat3 (*Gui_Camera_getDirection)(int teamId);
+SAIFloat3 (*Gui_Camera_getPosition)(int teamId);
+
+bool (*File_locateForReading)(int teamId, char* filename);
+bool (*File_locateForWriting)(int teamId, char* filename);
+
+int (*Unit_STATIC_getLimit)(int teamId);
+const char* (*Game_getSetupScript)(int teamId);
+
+
+// BEGINN kind of deprecated; it is recommended not to use these
+//bool (*getProperty)(int teamId, int id, int property, void* dst);
+//bool (*getValue)(int teamId, int id, void* dst);
+// END kind of deprecated; it is recommended not to use these
+
+
+// BEGINN OBJECT Cheats
+bool (*Cheats_isEnabled)(int teamId);
+bool (*Cheats_setEnabled)(int teamId, bool enable);
+bool (*Cheats_setEventsEnabled)(int teamId, bool enabled);
+bool (*Cheats_isOnlyPassive)(int teamId);
+// END OBJECT Cheats
+
+
+// BEGINN OBJECT ResourceInfo
+float (*ResourceInfo_Metal_getCurrent)(int teamId);
+float (*ResourceInfo_Metal_getIncome)(int teamId);
+float (*ResourceInfo_Metal_getUsage)(int teamId);
+float (*ResourceInfo_Metal_getStorage)(int teamId);
+float (*ResourceInfo_Energy_getCurrent)(int teamId);
+float (*ResourceInfo_Energy_getIncome)(int teamId);
+float (*ResourceInfo_Energy_getUsage)(int teamId);
+float (*ResourceInfo_Energy_getStorage)(int teamId);
+// END OBJECT ResourceInfo
+
+
+// BEGINN OBJECT File
+int (*File_getSize)(int teamId, const char* fileName);
+bool (*File_getContent)(int teamId, const char* filename, void* buffer, int bufferLen);
+// END OBJECT File
+
+
+// BEGINN OBJECT UnitDef
+int (*UnitDef_STATIC_getIds)(int teamId, int* unitDefIds);
+int (*UnitDef_STATIC_getNumIds)(int teamId);
+int (*UnitDef_STATIC_getIdByName)(int teamId, const char* unitName);
+
+float (*UnitDef_getHeight)(int teamId, int unitDefId);
+float (*UnitDef_getRadius)(int teamId, int unitDefId);
+
+bool (*UnitDef_isValid)(int teamId, int unitDefId);
+const char* (*UnitDef_getName)(int teamId, int unitDefId);
+const char* (*UnitDef_getHumanName)(int teamId, int unitDefId);
+const char* (*UnitDef_getFilename)(int teamId, int unitDefId);
+int (*UnitDef_getId)(int teamId, int unitDefId);
+int (*UnitDef_getAiHint)(int teamId, int unitDefId);
+int (*UnitDef_getCobID)(int teamId, int unitDefId);
+int (*UnitDef_getTechLevel)(int teamId, int unitDefId);
+const char* (*UnitDef_getGaia)(int teamId, int unitDefId);
+float (*UnitDef_getMetalUpkeep)(int teamId, int unitDefId);
+float (*UnitDef_getEnergyUpkeep)(int teamId, int unitDefId);
+float (*UnitDef_getMetalMake)(int teamId, int unitDefId);
+float (*UnitDef_getMakesMetal)(int teamId, int unitDefId);
+float (*UnitDef_getEnergyMake)(int teamId, int unitDefId);
+float (*UnitDef_getMetalCost)(int teamId, int unitDefId);
+float (*UnitDef_getEnergyCost)(int teamId, int unitDefId);
+float (*UnitDef_getBuildTime)(int teamId, int unitDefId);
+float (*UnitDef_getExtractsMetal)(int teamId, int unitDefId);
+float (*UnitDef_getExtractRange)(int teamId, int unitDefId);
+float (*UnitDef_getWindGenerator)(int teamId, int unitDefId);
+float (*UnitDef_getTidalGenerator)(int teamId, int unitDefId);
+float (*UnitDef_getMetalStorage)(int teamId, int unitDefId);
+float (*UnitDef_getEnergyStorage)(int teamId, int unitDefId);
+float (*UnitDef_getAutoHeal)(int teamId, int unitDefId);
+float (*UnitDef_getIdleAutoHeal)(int teamId, int unitDefId);
+int (*UnitDef_getIdleTime)(int teamId, int unitDefId);
+float (*UnitDef_getPower)(int teamId, int unitDefId);
+float (*UnitDef_getHealth)(int teamId, int unitDefId);
+unsigned int (*UnitDef_getCategory)(int teamId, int unitDefId);
+float (*UnitDef_getSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getTurnRate)(int teamId, int unitDefId);
+int (*UnitDef_getMoveType)(int teamId, int unitDefId);
+bool (*UnitDef_isUpright)(int teamId, int unitDefId);
+bool (*UnitDef_isCollide)(int teamId, int unitDefId);
+float (*UnitDef_getControlRadius)(int teamId, int unitDefId);
+float (*UnitDef_getLosRadius)(int teamId, int unitDefId);
+float (*UnitDef_getAirLosRadius)(int teamId, int unitDefId);
+float (*UnitDef_getLosHeight)(int teamId, int unitDefId);
+int (*UnitDef_getRadarRadius)(int teamId, int unitDefId);
+int (*UnitDef_getSonarRadius)(int teamId, int unitDefId);
+int (*UnitDef_getJammerRadius)(int teamId, int unitDefId);
+int (*UnitDef_getSonarJamRadius)(int teamId, int unitDefId);
+int (*UnitDef_getSeismicRadius)(int teamId, int unitDefId);
+float (*UnitDef_getSeismicSignature)(int teamId, int unitDefId);
+bool (*UnitDef_isStealth)(int teamId, int unitDefId);
+bool (*UnitDef_isSonarStealth)(int teamId, int unitDefId);
+bool (*UnitDef_isBuildRange3D)(int teamId, int unitDefId);
+float (*UnitDef_getBuildDistance)(int teamId, int unitDefId);
+float (*UnitDef_getBuildSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getReclaimSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getRepairSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getMaxRepairSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getResurrectSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getCaptureSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getTerraformSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getMass)(int teamId, int unitDefId);
+bool (*UnitDef_isPushResistant)(int teamId, int unitDefId);
+bool (*UnitDef_isStrafeToAttack)(int teamId, int unitDefId);
+float (*UnitDef_getMinCollisionSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getSlideTolerance)(int teamId, int unitDefId);
+float (*UnitDef_getMaxSlope)(int teamId, int unitDefId);
+float (*UnitDef_getMaxHeightDif)(int teamId, int unitDefId);
+float (*UnitDef_getMinWaterDepth)(int teamId, int unitDefId);
+float (*UnitDef_getWaterline)(int teamId, int unitDefId);
+float (*UnitDef_getMaxWaterDepth)(int teamId, int unitDefId);
+float (*UnitDef_getArmoredMultiple)(int teamId, int unitDefId);
+int (*UnitDef_getArmorType)(int teamId, int unitDefId);
+int (*UnitDef_getFlankingBonusMode)(int teamId, int unitDefId);
+SAIFloat3 (*UnitDef_getFlankingBonusDir)(int teamId, int unitDefId);
+float (*UnitDef_getFlankingBonusMax)(int teamId, int unitDefId);
+float (*UnitDef_getFlankingBonusMin)(int teamId, int unitDefId);
+float (*UnitDef_getFlankingBonusMobilityAdd)(int teamId, int unitDefId);
+const char* (*UnitDef_getCollisionVolumeType)(int teamId, int unitDefId);
+SAIFloat3 (*UnitDef_getCollisionVolumeScales)(int teamId, int unitDefId);
+SAIFloat3 (*UnitDef_getCollisionVolumeOffsets)(int teamId, int unitDefId);
+int (*UnitDef_getCollisionVolumeTest)(int teamId, int unitDefId);
+float (*UnitDef_getMaxWeaponRange)(int teamId, int unitDefId);
+const char* (*UnitDef_getType)(int teamId, int unitDefId);
+const char* (*UnitDef_getTooltip)(int teamId, int unitDefId);
+const char* (*UnitDef_getWreckName)(int teamId, int unitDefId);
+const char* (*UnitDef_getDeathExplosion)(int teamId, int unitDefId);
+const char* (*UnitDef_getSelfDExplosion)(int teamId, int unitDefId);
+const char* (*UnitDef_getTedClassString)(int teamId, int unitDefId);
+const char* (*UnitDef_getCategoryString)(int teamId, int unitDefId);
+bool (*UnitDef_isCanSelfD)(int teamId, int unitDefId);
+int (*UnitDef_getSelfDCountdown)(int teamId, int unitDefId);
+bool (*UnitDef_isCanSubmerge)(int teamId, int unitDefId);
+bool (*UnitDef_isCanFly)(int teamId, int unitDefId);
+bool (*UnitDef_isCanMove)(int teamId, int unitDefId);
+bool (*UnitDef_isCanHover)(int teamId, int unitDefId);
+bool (*UnitDef_isFloater)(int teamId, int unitDefId);
+bool (*UnitDef_isBuilder)(int teamId, int unitDefId);
+bool (*UnitDef_isActivateWhenBuilt)(int teamId, int unitDefId);
+bool (*UnitDef_isOnOffable)(int teamId, int unitDefId);
+bool (*UnitDef_isFullHealthFactory)(int teamId, int unitDefId);
+bool (*UnitDef_isFactoryHeadingTakeoff)(int teamId, int unitDefId);
+bool (*UnitDef_isReclaimable)(int teamId, int unitDefId);
+bool (*UnitDef_isCapturable)(int teamId, int unitDefId);
+bool (*UnitDef_isCanRestore)(int teamId, int unitDefId);
+bool (*UnitDef_isCanRepair)(int teamId, int unitDefId);
+bool (*UnitDef_isCanSelfRepair)(int teamId, int unitDefId);
+bool (*UnitDef_isCanReclaim)(int teamId, int unitDefId);
+bool (*UnitDef_isCanAttack)(int teamId, int unitDefId);
+bool (*UnitDef_isCanPatrol)(int teamId, int unitDefId);
+bool (*UnitDef_isCanFight)(int teamId, int unitDefId);
+bool (*UnitDef_isCanGuard)(int teamId, int unitDefId);
+bool (*UnitDef_isCanBuild)(int teamId, int unitDefId);
+bool (*UnitDef_isCanAssist)(int teamId, int unitDefId);
+bool (*UnitDef_isCanBeAssisted)(int teamId, int unitDefId);
+bool (*UnitDef_isCanRepeat)(int teamId, int unitDefId);
+bool (*UnitDef_isCanFireControl)(int teamId, int unitDefId);
+int (*UnitDef_getFireState)(int teamId, int unitDefId);
+int (*UnitDef_getMoveState)(int teamId, int unitDefId);
+float (*UnitDef_getWingDrag)(int teamId, int unitDefId);
+float (*UnitDef_getWingAngle)(int teamId, int unitDefId);
+float (*UnitDef_getDrag)(int teamId, int unitDefId);
+float (*UnitDef_getFrontToSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getSpeedToFront)(int teamId, int unitDefId);
+float (*UnitDef_getMyGravity)(int teamId, int unitDefId);
+float (*UnitDef_getMaxBank)(int teamId, int unitDefId);
+float (*UnitDef_getMaxPitch)(int teamId, int unitDefId);
+float (*UnitDef_getTurnRadius)(int teamId, int unitDefId);
+float (*UnitDef_getWantedHeight)(int teamId, int unitDefId);
+float (*UnitDef_getVerticalSpeed)(int teamId, int unitDefId);
+bool (*UnitDef_isCanCrash)(int teamId, int unitDefId);
+bool (*UnitDef_isHoverAttack)(int teamId, int unitDefId);
+bool (*UnitDef_isAirStrafe)(int teamId, int unitDefId);
+float (*UnitDef_getDlHoverFactor)(int teamId, int unitDefId);
+float (*UnitDef_getMaxAcceleration)(int teamId, int unitDefId);
+float (*UnitDef_getMaxDeceleration)(int teamId, int unitDefId);
+float (*UnitDef_getMaxAileron)(int teamId, int unitDefId);
+float (*UnitDef_getMaxElevator)(int teamId, int unitDefId);
+float (*UnitDef_getMaxRudder)(int teamId, int unitDefId);
+///* returned size is 4 */
+//const unsigned char** (*UnitDef_getYardMaps)(int teamId, int unitDefId);
+int (*UnitDef_getXSize)(int teamId, int unitDefId);
+int (*UnitDef_getYSize)(int teamId, int unitDefId);
+int (*UnitDef_getBuildAngle)(int teamId, int unitDefId);
+float (*UnitDef_getLoadingRadius)(int teamId, int unitDefId);
+float (*UnitDef_getUnloadSpread)(int teamId, int unitDefId);
+int (*UnitDef_getTransportCapacity)(int teamId, int unitDefId);
+int (*UnitDef_getTransportSize)(int teamId, int unitDefId);
+int (*UnitDef_getMinTransportSize)(int teamId, int unitDefId);
+bool (*UnitDef_isAirBase)(int teamId, int unitDefId);
+float (*UnitDef_getTransportMass)(int teamId, int unitDefId);
+float (*UnitDef_getMinTransportMass)(int teamId, int unitDefId);
+bool (*UnitDef_isHoldSteady)(int teamId, int unitDefId);
+bool (*UnitDef_isReleaseHeld)(int teamId, int unitDefId);
+bool (*UnitDef_isCantBeTransported)(int teamId, int unitDefId);
+bool (*UnitDef_isTransportByEnemy)(int teamId, int unitDefId);
+int (*UnitDef_getTransportUnloadMethod)(int teamId, int unitDefId);
+float (*UnitDef_getFallSpeed)(int teamId, int unitDefId);
+float (*UnitDef_getUnitFallSpeed)(int teamId, int unitDefId);
+bool (*UnitDef_isCanCloak)(int teamId, int unitDefId);
+bool (*UnitDef_isStartCloaked)(int teamId, int unitDefId);
+float (*UnitDef_getCloakCost)(int teamId, int unitDefId);
+float (*UnitDef_getCloakCostMoving)(int teamId, int unitDefId);
+float (*UnitDef_getDecloakDistance)(int teamId, int unitDefId);
+bool (*UnitDef_isDecloakSpherical)(int teamId, int unitDefId);
+bool (*UnitDef_isDecloakOnFire)(int teamId, int unitDefId);
+bool (*UnitDef_isCanKamikaze)(int teamId, int unitDefId);
+float (*UnitDef_getKamikazeDist)(int teamId, int unitDefId);
+bool (*UnitDef_isTargetingFacility)(int teamId, int unitDefId);
+bool (*UnitDef_isCanDGun)(int teamId, int unitDefId);
+bool (*UnitDef_isNeedGeo)(int teamId, int unitDefId);
+bool (*UnitDef_isFeature)(int teamId, int unitDefId);
+bool (*UnitDef_isHideDamage)(int teamId, int unitDefId);
+bool (*UnitDef_isCommander)(int teamId, int unitDefId);
+bool (*UnitDef_isShowPlayerName)(int teamId, int unitDefId);
+bool (*UnitDef_isCanResurrect)(int teamId, int unitDefId);
+bool (*UnitDef_isCanCapture)(int teamId, int unitDefId);
+int (*UnitDef_getHighTrajectoryType)(int teamId, int unitDefId);
+unsigned int (*UnitDef_getNoChaseCategory)(int teamId, int unitDefId);
+bool (*UnitDef_isLeaveTracks)(int teamId, int unitDefId);
+float (*UnitDef_getTrackWidth)(int teamId, int unitDefId);
+float (*UnitDef_getTrackOffset)(int teamId, int unitDefId);
+float (*UnitDef_getTrackStrength)(int teamId, int unitDefId);
+float (*UnitDef_getTrackStretch)(int teamId, int unitDefId);
+int (*UnitDef_getTrackType)(int teamId, int unitDefId);
+bool (*UnitDef_isCanDropFlare)(int teamId, int unitDefId);
+float (*UnitDef_getFlareReloadTime)(int teamId, int unitDefId);
+float (*UnitDef_getFlareEfficiency)(int teamId, int unitDefId);
+float (*UnitDef_getFlareDelay)(int teamId, int unitDefId);
+SAIFloat3 (*UnitDef_getFlareDropVector)(int teamId, int unitDefId);
+int (*UnitDef_getFlareTime)(int teamId, int unitDefId);
+int (*UnitDef_getFlareSalvoSize)(int teamId, int unitDefId);
+int (*UnitDef_getFlareSalvoDelay)(int teamId, int unitDefId);
+bool (*UnitDef_isSmoothAnim)(int teamId, int unitDefId);
+bool (*UnitDef_isMetalMaker)(int teamId, int unitDefId);
+bool (*UnitDef_isCanLoopbackAttack)(int teamId, int unitDefId);
+bool (*UnitDef_isLevelGround)(int teamId, int unitDefId);
+bool (*UnitDef_isUseBuildingGroundDecal)(int teamId, int unitDefId);
+int (*UnitDef_getBuildingDecalType)(int teamId, int unitDefId);
+int (*UnitDef_getBuildingDecalSizeX)(int teamId, int unitDefId);
+int (*UnitDef_getBuildingDecalSizeY)(int teamId, int unitDefId);
+float (*UnitDef_getBuildingDecalDecaySpeed)(int teamId, int unitDefId);
+bool (*UnitDef_isFirePlatform)(int teamId, int unitDefId);
+float (*UnitDef_getMaxFuel)(int teamId, int unitDefId);
+float (*UnitDef_getRefuelTime)(int teamId, int unitDefId);
+float (*UnitDef_getMinAirBasePower)(int teamId, int unitDefId);
+int (*UnitDef_getMaxThisUnit)(int teamId, int unitDefId);
+int (*UnitDef_getDecoyDefId)(int teamId, int unitDefId);
+bool (*UnitDef_isDontLand)(int teamId, int unitDefId);
+int (*UnitDef_getShieldWeaponDefId)(int teamId, int unitDefId);
+int (*UnitDef_getStockpileWeaponDefId)(int teamId, int unitDefId);
+int (*UnitDef_getNumBuildOptions)(int teamId, int unitDefId);
+int (*UnitDef_getBuildOptions)(int teamId, int unitDefId, int* unitDefIds);
+int (*UnitDef_getNumCustomParams)(int teamId, int unitDefId);
+int (*UnitDef_getCustomParams)(int teamId, int unitDefId, const char* map[][2]);
+bool (*UnitDef_hasMoveData)(int teamId, int unitDefId);
+/* enum MoveType { Ground_Move, Hover_Move, Ship_Move }; */
+int (*UnitDef_MoveData_getMoveType)(int teamId, int unitDefId);
+/* 0=tank,1=kbot,2=hover,3=ship */
+int (*UnitDef_MoveData_getMoveFamily)(int teamId, int unitDefId);
+int (*UnitDef_MoveData_getSize)(int teamId, int unitDefId);
+float (*UnitDef_MoveData_getDepth)(int teamId, int unitDefId);
+float (*UnitDef_MoveData_getMaxSlope)(int teamId, int unitDefId);
+float (*UnitDef_MoveData_getSlopeMod)(int teamId, int unitDefId);
+float (*UnitDef_MoveData_getDepthMod)(int teamId, int unitDefId);
+int (*UnitDef_MoveData_getPathType)(int teamId, int unitDefId);
+float (*UnitDef_MoveData_getCrushStrength)(int teamId, int unitDefId);
+float (*UnitDef_MoveData_getMaxSpeed)(int teamId, int unitDefId);
+short (*UnitDef_MoveData_getMaxTurnRate)(int teamId, int unitDefId);
+float (*UnitDef_MoveData_getMaxAcceleration)(int teamId, int unitDefId);
+float (*UnitDef_MoveData_getMaxBreaking)(int teamId, int unitDefId);
+bool (*UnitDef_MoveData_isSubMarine)(int teamId, int unitDefId);
+int (*UnitDef_getNumUnitDefWeapons)(int teamId, int unitDefId);
+const char* (*UnitDef_UnitDefWeapon_getName)(int teamId, int unitDefId, int weaponIndex);
+int (*UnitDef_UnitDefWeapon_getWeaponDefId)(int teamId, int unitDefId, int weaponIndex);
+int (*UnitDef_UnitDefWeapon_getSlavedTo)(int teamId, int unitDefId, int weaponIndex);
+SAIFloat3 (*UnitDef_UnitDefWeapon_getMainDir)(int teamId, int unitDefId, int weaponIndex);
+float (*UnitDef_UnitDefWeapon_getMaxAngleDif)(int teamId, int unitDefId, int weaponIndex);
+float (*UnitDef_UnitDefWeapon_getFuelUsage)(int teamId, int unitDefId, int weaponIndex);
+unsigned int (*UnitDef_UnitDefWeapon_getBadTargetCat)(int teamId, int unitDefId, int weaponIndex);
+unsigned int (*UnitDef_UnitDefWeapon_getOnlyTargetCat)(int teamId, int unitDefId, int weaponIndex);
+// END OBJECT UnitDef
+
+
+
+// BEGINN OBJECT Unit
+int (*Unit_STATIC_getEnemies)(int teamId, int* unitIds);
+int (*Unit_STATIC_getEnemiesIn)(int teamId, int* unitIds, SAIFloat3 pos, float radius);
+int (*Unit_STATIC_getEnemiesInRadarAndLos)(int teamId, int* units);
+int (*Unit_STATIC_getFriendlies)(int teamId, int* unitIds);
+int (*Unit_STATIC_getFriendliesIn)(int teamId, int* unitIds, SAIFloat3 pos, float radius);
+int (*Unit_STATIC_getNeutrals)(int teamId, int* unitIds);
+int (*Unit_STATIC_getNeutralsIn)(int teamId, int* unitIds, SAIFloat3 pos, float radius);
+int (*Unit_STATIC_getSelected)(int teamId, int* unitIds);
+
+int (*Unit_getDefId)(int teamId, int unitId);
+int (*Unit_getAiHint)(int teamId, int unitId);
+int (*Unit_getTeam)(int teamId, int unitId);
+int (*Unit_getAllyTeam)(int teamId, int unitId);
+
+int (*Unit_getStockpile)(int teamId, int unitId);
+int (*Unit_getStockpileQueued)(int teamId, int unitId);
+float (*Unit_getCurrentFuel)(int teamId, int unitId);
+float (*Unit_getMaxSpeed)(int teamId, int unitId);
+float (*Unit_getMaxRange)(int teamId, int unitId);
+float (*Unit_getMaxHealth)(int teamId, int unitId);
+float (*Unit_getExperience)(int teamId, int unitId);
+int (*Unit_getGroup)(int teamId, int unitId);
+int (*Unit_getNumCurrentCommands)(int teamId, int unitId);
+/* for the type of the command queue, see CCommandQueue::CommandQueueType CommandQueue.h */
+int (*Unit_CurrentCommands_getType)(int teamId, int unitId);
+/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
+int (*Unit_CurrentCommands_getIds)(int teamId, int unitId, int* ids);
+int (*Unit_CurrentCommands_getOptions)(int teamId, int unitId, unsigned char* options);
+int (*Unit_CurrentCommands_getTag)(int teamId, int unitId, unsigned int* tags);
+int (*Unit_CurrentCommands_getTimeOut)(int teamId, int unitId, int* timeOuts);
+int (*Unit_CurrentCommands_getNumParams)(int teamId, int unitId, int* numParams);
+int (*Unit_CurrentCommands_getParams)(int teamId, int unitId, float** params);
+int (*Unit_getNumSupportedCommands)(int teamId, int unitId);
+/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
+int (*Unit_SupportedCommands_getId)(int teamId, int unitId, int* ids);
+int (*Unit_SupportedCommands_getName)(int teamId, int unitId, const char** names);
+int (*Unit_SupportedCommands_getToolTip)(int teamId, int unitId, const char** toolTips);
+int (*Unit_SupportedCommands_isShowUnique)(int teamId, int unitId, bool* showUniques);
+int (*Unit_SupportedCommands_isDisabled)(int teamId, int unitId, bool* disableds);
+int (*Unit_SupportedCommands_getNumParams)(int teamId, int unitId, int* numParams);
+int (*Unit_SupportedCommands_getParams)(int teamId, int unitId, const char*** params);
+float (*Unit_getHealth)(int teamId, int unitId);
+float (*Unit_getSpeed)(int teamId, int unitId);
+float (*Unit_getPower)(int teamId, int unitId);
+float (*Unit_ResourceInfo_Metal_getUse)(int teamId, int unitId);
+float (*Unit_ResourceInfo_Metal_getMake)(int teamId, int unitId);
+float (*Unit_ResourceInfo_Energy_getUse)(int teamId, int unitId);
+float (*Unit_ResourceInfo_Energy_getMake)(int teamId, int unitId);
+SAIFloat3 (*Unit_getPos)(int teamId, int unitId);
+bool (*Unit_isActivated)(int teamId, int unitId);
+bool (*Unit_isBeingBuilt)(int teamId, int unitId);
+bool (*Unit_isCloaked)(int teamId, int unitId);
+bool (*Unit_isParalyzed)(int teamId, int unitId);
+bool (*Unit_isNeutral)(int teamId, int unitId);
+int (*Unit_getBuildingFacing)(int teamId, int unitId);
+// END OBJECT Unit
+
+
+// BEGINN OBJECT Group
+int (*Group_getNumSupportedCommands)(int teamId, int groupId);
+/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
+int (*Group_SupportedCommands_getId)(int teamId, int groupId, int* ids);
+int (*Group_SupportedCommands_getName)(int teamId, int groupId, const char** names);
+int (*Group_SupportedCommands_getToolTip)(int teamId, int groupId, const char** toolTips);
+int (*Group_SupportedCommands_isShowUnique)(int teamId, int groupId, bool* showUniques);
+int (*Group_SupportedCommands_isDisabled)(int teamId, int groupId, bool* disableds);
+int (*Group_SupportedCommands_getNumParams)(int teamId, int groupId, int* numParams);
+int (*Group_SupportedCommands_getParams)(int teamId, int groupId, const char*** params);
+// END OBJECT Group
+
+
+
+// BEGINN OBJECT Mod
+const char* (*Mod_getName)(int teamId);
+// END OBJECT Mod
+
+
+
+// BEGINN OBJECT Map
+SAIFloat3 (*Map_getStartPos)(int teamId);
+SAIFloat3 (*Map_getMousePos)(int teamId);
+bool (*Map_isPosInCamera)(int teamId, SAIFloat3 pos, float radius);
+int (*Map_getWidth)(int teamId);
+int (*Map_getHeight)(int teamId);
+const float* (*Map_getHeightMap)(int teamId);
+float (*Map_getMinHeight)(int teamId);
+float (*Map_getMaxHeight)(int teamId);
+const float* (*Map_getSlopeMap)(int teamId);
+const unsigned short* (*Map_getLosMap)(int teamId);
+const unsigned short* (*Map_getRadarMap)(int teamId);
+const unsigned short* (*Map_getJammerMap)(int teamId);
+const unsigned char* (*Map_getMetalMap)(int teamId);
+const char* (*Map_getName)(int teamId);
+float (*Map_getElevationAt)(int teamId, float x, float z);
+float (*Map_getMaxMetal)(int teamId);
+float (*Map_getExtractorRadius)(int teamId);
+float (*Map_getMinWind)(int teamId);
+float (*Map_getMaxWind)(int teamId);
+float (*Map_getTidalStrength)(int teamId);
+float (*Map_getGravity)(int teamId);
+int (*Map_getPoints)(int teamId, SAIFloat3* positions, unsigned char** colors, const char** labels, int maxPoints);
+int (*Map_getLines)(int teamId, SAIFloat3* firstPositions, SAIFloat3* secondPositions, unsigned char** colors, int maxLines);
+bool (*Map_canBuildAt)(int teamId, int unitDefId, SAIFloat3 pos, int facing);
+SAIFloat3 (*Map_findClosestBuildSite)(int teamId, int unitDefId, SAIFloat3 pos, float searchRadius, int minDist, int facing);
+// BEGINN OBJECT Map
+
+
+
+// BEGINN OBJECT FeatureDef
+//const SAIFeatureDef* (*getFeatureDef)(int teamId, int featureDefId);
+const char* (*FeatureDef_getName)(int teamId, int weaponDefId);
+const char* (*FeatureDef_getDescription)(int teamId, int weaponDefId);
+const char* (*FeatureDef_getFilename)(int teamId, int weaponDefId);
+int (*FeatureDef_getId)(int teamId, int weaponDefId);
+float (*FeatureDef_getMetal)(int teamId, int weaponDefId);
+float (*FeatureDef_getEnergy)(int teamId, int weaponDefId);
+float (*FeatureDef_getMaxHealth)(int teamId, int weaponDefId);
+float (*FeatureDef_getReclaimTime)(int teamId, int weaponDefId);
+float (*FeatureDef_getMass)(int teamId, int weaponDefId);
+const char* (*FeatureDef_getCollisionVolumeType)(int teamId, int weaponDefId);	
+SAIFloat3 (*FeatureDef_getCollisionVolumeScales)(int teamId, int weaponDefId);		
+SAIFloat3 (*FeatureDef_getCollisionVolumeOffsets)(int teamId, int weaponDefId);		
+int (*FeatureDef_getCollisionVolumeTest)(int teamId, int weaponDefId);			
+bool (*FeatureDef_isUpright)(int teamId, int weaponDefId);
+int (*FeatureDef_getDrawType)(int teamId, int weaponDefId);
+const char* (*FeatureDef_getModelName)(int teamId, int weaponDefId);
+int (*FeatureDef_getModelType)(int teamId, int weaponDefId);
+bool (*FeatureDef_isDestructable)(int teamId, int weaponDefId);
+bool (*FeatureDef_isReclaimable)(int teamId, int weaponDefId);
+bool (*FeatureDef_isBlocking)(int teamId, int weaponDefId);
+bool (*FeatureDef_isBurnable)(int teamId, int weaponDefId);
+bool (*FeatureDef_isFloating)(int teamId, int weaponDefId);
+bool (*FeatureDef_isNoSelect)(int teamId, int weaponDefId);
+bool (*FeatureDef_isGeoThermal)(int teamId, int weaponDefId);
+const char* (*FeatureDef_getDeathFeature)(int teamId, int weaponDefId);
+int (*FeatureDef_getXsize)(int teamId, int weaponDefId);
+int (*FeatureDef_getYsize)(int teamId, int weaponDefId);
+int (*FeatureDef_getNumCustomParams)(int teamId, int weaponDefId);
+int (*FeatureDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
+// END OBJECT FeatureDef
+
+
+// BEGINN OBJECT Feature
+int (*Feature_STATIC_getIds)(int teamId, int *featureIds, int max);
+int (*Feature_STATIC_getIdsIn)(int teamId, int *featureIds, int max, SAIFloat3 pos, float radius);
+
+int (*Feature_getDefId)(int teamId, int featureId);
+float (*Feature_getHealth)(int teamId, int featureId);
+float (*Feature_getReclaimLeft)(int teamId, int featureId);
+SAIFloat3 (*Feature_getPos)(int teamId, int featureId);
+// END OBJECT Feature
+
+
+
+// BEGINN OBJECT WeaponDef
+int (*WeaponDef_STATIC_getIdByName)(int teamId, const char* weaponDefName);
+
+//const SAIWeaponDef* (*getWeaponDef)(int teamId, int weaponDefId);
+const char* (*WeaponDef_getName)(int teamId, int weaponDefId);
+const char* (*WeaponDef_getType)(int teamId, int weaponDefId);
+const char* (*WeaponDef_getDescription)(int teamId, int weaponDefId);
+const char* (*WeaponDef_getFilename)(int teamId, int weaponDefId);
+const char* (*WeaponDef_getCegTag)(int teamId, int weaponDefId);
+float (*WeaponDef_getRange)(int teamId, int weaponDefId);
+float (*WeaponDef_getHeightMod)(int teamId, int weaponDefId);
+float (*WeaponDef_getAccuracy)(int teamId, int weaponDefId);
+float (*WeaponDef_getSprayAngle)(int teamId, int weaponDefId);
+float (*WeaponDef_getMovingAccuracy)(int teamId, int weaponDefId);
+float (*WeaponDef_getTargetMoveError)(int teamId, int weaponDefId);
+float (*WeaponDef_getLeadLimit)(int teamId, int weaponDefId);
+float (*WeaponDef_getLeadBonus)(int teamId, int weaponDefId);
+float (*WeaponDef_getPredictBoost)(int teamId, int weaponDefId);
+
+//DamageArray (*WeaponDef_getDamages)(int teamId, int weaponDefId);
+int (*WeaponDef_Damages_getParalyzeDamageTime)(int teamId, int weaponDefId);
+float (*WeaponDef_Damages_getImpulseFactor)(int teamId, int weaponDefId);
+float (*WeaponDef_Damages_getImpulseBoost)(int teamId, int weaponDefId);
+float (*WeaponDef_Damages_getCraterMult)(int teamId, int weaponDefId);
+float (*WeaponDef_Damages_getCraterBoost)(int teamId, int weaponDefId);
+int (*WeaponDef_Damages_getNumTypes)(int teamId, int weaponDefId);
+//float (*WeaponDef_Damages_getType)(int teamId, int weaponDefId, int typeIndex);
+void (*WeaponDef_Damages_getTypeDamages)(int teamId, int weaponDefId, float* typeDamages);
+
+float (*WeaponDef_getAreaOfEffect)(int teamId, int weaponDefId);
+bool (*WeaponDef_isNoSelfDamage)(int teamId, int weaponDefId);
+float (*WeaponDef_getFireStarter)(int teamId, int weaponDefId);
+float (*WeaponDef_getEdgeEffectiveness)(int teamId, int weaponDefId);
+float (*WeaponDef_getSize)(int teamId, int weaponDefId);
+float (*WeaponDef_getSizeGrowth)(int teamId, int weaponDefId);
+float (*WeaponDef_getCollisionSize)(int teamId, int weaponDefId);
+int (*WeaponDef_getSalvoSize)(int teamId, int weaponDefId);
+float (*WeaponDef_getSalvoDelay)(int teamId, int weaponDefId);
+float (*WeaponDef_getReload)(int teamId, int weaponDefId);
+float (*WeaponDef_getBeamTime)(int teamId, int weaponDefId);
+bool (*WeaponDef_isBeamBurst)(int teamId, int weaponDefId);
+bool (*WeaponDef_isWaterBounce)(int teamId, int weaponDefId);
+bool (*WeaponDef_isGroundBounce)(int teamId, int weaponDefId);
+float (*WeaponDef_getBounceRebound)(int teamId, int weaponDefId);
+float (*WeaponDef_getBounceSlip)(int teamId, int weaponDefId);
+int (*WeaponDef_getNumBounce)(int teamId, int weaponDefId);
+float (*WeaponDef_getMaxAngle)(int teamId, int weaponDefId);
+float (*WeaponDef_getRestTime)(int teamId, int weaponDefId);
+float (*WeaponDef_getUpTime)(int teamId, int weaponDefId);
+int (*WeaponDef_getFlightTime)(int teamId, int weaponDefId);
+float (*WeaponDef_getMetalCost)(int teamId, int weaponDefId);
+float (*WeaponDef_getEnergyCost)(int teamId, int weaponDefId);
+float (*WeaponDef_getSupplyCost)(int teamId, int weaponDefId);
+int (*WeaponDef_getProjectilesPerShot)(int teamId, int weaponDefId);
+int (*WeaponDef_getId)(int teamId, int weaponDefId);
+int (*WeaponDef_getTdfId)(int teamId, int weaponDefId);
+bool (*WeaponDef_isTurret)(int teamId, int weaponDefId);
+bool (*WeaponDef_isOnlyForward)(int teamId, int weaponDefId);
+bool (*WeaponDef_isFixedLauncher)(int teamId, int weaponDefId);
+bool (*WeaponDef_isWaterWeapon)(int teamId, int weaponDefId);
+bool (*WeaponDef_isFireSubmersed)(int teamId, int weaponDefId);
+bool (*WeaponDef_isSubMissile)(int teamId, int weaponDefId);
+bool (*WeaponDef_isTracks)(int teamId, int weaponDefId);
+bool (*WeaponDef_isDropped)(int teamId, int weaponDefId);
+bool (*WeaponDef_isParalyzer)(int teamId, int weaponDefId);
+bool (*WeaponDef_isImpactOnly)(int teamId, int weaponDefId);
+bool (*WeaponDef_isNoAutoTarget)(int teamId, int weaponDefId);
+bool (*WeaponDef_isManualFire)(int teamId, int weaponDefId);
+int (*WeaponDef_getInterceptor)(int teamId, int weaponDefId);
+int (*WeaponDef_getTargetable)(int teamId, int weaponDefId);
+bool (*WeaponDef_isStockpileable)(int teamId, int weaponDefId);
+float (*WeaponDef_getCoverageRange)(int teamId, int weaponDefId);
+float (*WeaponDef_getIntensity)(int teamId, int weaponDefId);
+float (*WeaponDef_getThickness)(int teamId, int weaponDefId);
+float (*WeaponDef_getLaserFlareSize)(int teamId, int weaponDefId);
+float (*WeaponDef_getCoreThickness)(int teamId, int weaponDefId);
+float (*WeaponDef_getDuration)(int teamId, int weaponDefId);
+int (*WeaponDef_getLodDistance)(int teamId, int weaponDefId);
+float (*WeaponDef_getFalloffRate)(int teamId, int weaponDefId);
+int (*WeaponDef_getGraphicsType)(int teamId, int weaponDefId);
+bool (*WeaponDef_isSoundTrigger)(int teamId, int weaponDefId);
+bool (*WeaponDef_isSelfExplode)(int teamId, int weaponDefId);
+bool (*WeaponDef_isGravityAffected)(int teamId, int weaponDefId);
+int (*WeaponDef_getHighTrajectory)(int teamId, int weaponDefId);
+float (*WeaponDef_getMyGravity)(int teamId, int weaponDefId);
+bool (*WeaponDef_isTwoPhase)(int teamId, int weaponDefId);
+bool (*WeaponDef_isGuided)(int teamId, int weaponDefId);
+bool (*WeaponDef_isVLaunched)(int teamId, int weaponDefId);
+bool (*WeaponDef_isSelfPropelled)(int teamId, int weaponDefId);
+bool (*WeaponDef_isNoExplode)(int teamId, int weaponDefId);
+float (*WeaponDef_getStartVelocity)(int teamId, int weaponDefId);
+float (*WeaponDef_getWeaponAcceleration)(int teamId, int weaponDefId);
+float (*WeaponDef_getTurnRate)(int teamId, int weaponDefId);
+float (*WeaponDef_getMaxVelocity)(int teamId, int weaponDefId);
+float (*WeaponDef_getProjectileSpeed)(int teamId, int weaponDefId);
+float (*WeaponDef_getExplosionSpeed)(int teamId, int weaponDefId);
+unsigned int (*WeaponDef_getOnlyTargetCategory)(int teamId, int weaponDefId);
+float (*WeaponDef_getWobble)(int teamId, int weaponDefId);
+float (*WeaponDef_getDance)(int teamId, int weaponDefId);
+float (*WeaponDef_getTrajectoryHeight)(int teamId, int weaponDefId);
+bool (*WeaponDef_isLargeBeamLaser)(int teamId, int weaponDefId);
+bool (*WeaponDef_isShield)(int teamId, int weaponDefId);
+bool (*WeaponDef_isShieldRepulser)(int teamId, int weaponDefId);
+bool (*WeaponDef_isSmartShield)(int teamId, int weaponDefId);
+bool (*WeaponDef_isExteriorShield)(int teamId, int weaponDefId);
+bool (*WeaponDef_isVisibleShield)(int teamId, int weaponDefId);
+bool (*WeaponDef_isVisibleShieldRepulse)(int teamId, int weaponDefId);
+int (*WeaponDef_getVisibleShieldHitFrames)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldEnergyUse)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldRadius)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldForce)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldMaxSpeed)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldPower)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldPowerRegen)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldPowerRegenEnergy)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldStartingPower)(int teamId, int weaponDefId);
+int (*WeaponDef_getShieldRechargeDelay)(int teamId, int weaponDefId);
+SAIFloat3 (*WeaponDef_getShieldGoodColor)(int teamId, int weaponDefId);
+SAIFloat3 (*WeaponDef_getShieldBadColor)(int teamId, int weaponDefId);
+float (*WeaponDef_getShieldAlpha)(int teamId, int weaponDefId);
+unsigned int (*WeaponDef_getShieldInterceptType)(int teamId, int weaponDefId);
+unsigned int (*WeaponDef_getInterceptedByShieldType)(int teamId, int weaponDefId);
+bool (*WeaponDef_isAvoidFriendly)(int teamId, int weaponDefId);
+bool (*WeaponDef_isAvoidFeature)(int teamId, int weaponDefId);
+bool (*WeaponDef_isAvoidNeutral)(int teamId, int weaponDefId);
+float (*WeaponDef_getTargetBorder)(int teamId, int weaponDefId);
+float (*WeaponDef_getCylinderTargetting)(int teamId, int weaponDefId);
+float (*WeaponDef_getMinIntensity)(int teamId, int weaponDefId);
+float (*WeaponDef_getHeightBoostFactor)(int teamId, int weaponDefId);
+float (*WeaponDef_getProximityPriority)(int teamId, int weaponDefId);
+unsigned int (*WeaponDef_getCollisionFlags)(int teamId, int weaponDefId);
+bool (*WeaponDef_isSweepFire)(int teamId, int weaponDefId);
+bool (*WeaponDef_isCanAttackGround)(int teamId, int weaponDefId);
+float (*WeaponDef_getCameraShake)(int teamId, int weaponDefId);
+float (*WeaponDef_getDynDamageExp)(int teamId, int weaponDefId);
+float (*WeaponDef_getDynDamageMin)(int teamId, int weaponDefId);
+float (*WeaponDef_getDynDamageRange)(int teamId, int weaponDefId);
+bool (*WeaponDef_isDynDamageInverted)(int teamId, int weaponDefId);
+int (*WeaponDef_getNumCustomParams)(int teamId, int weaponDefId);
+//const char** (*WeaponDef_getCustomParam)(int teamId, int weaponDefId, int index);
+int (*WeaponDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
+// END OBJECT WeaponDef
+
+};
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SAICALLBACK_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/SAICallback.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,13 @@
+
+#include &quot;SAIFloat3.h&quot;
+
+SAIFloat3 newSAIFloat3(float x, float y, float z) {
+    
+    SAIFloat3 sAIFloat3;
+    
+    sAIFloat3.x = x;
+    sAIFloat3.y = y;
+    sAIFloat3.z = z;
+    
+    return  sAIFloat3;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/SAIFloat3.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAIFloat3.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SAIFloat3.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -0,0 +1,49 @@
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SAIFLOAT3_H
+#define	_SAIFLOAT3_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct SAIFloat3 {
+    float x, y, z;
+};
+
+SAIFloat3 newSAIFloat3(float x, float y, float z);
+
+#ifdef	__cplusplus
+}
+#endif
+
+//#ifdef	__cplusplus
+//#include &quot;float3.h&quot;
+//
+//SAIFloat3 newSAIFloat3_Cpp(float3* f3) {
+//    
+//    SAIFloat3 sAIFloat3;
+//    
+//    sAIFloat3.x = f3-&gt;x;
+//    sAIFloat3.y = f3-&gt;y;
+//    sAIFloat3.z = f3-&gt;z;
+//    
+//    return  sAIFloat3;
+//}
+//#endif
+
+#endif	/* _SAIFLOAT3_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/SAIFloat3.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/Sim/Misc/DamageArray.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/DamageArray.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/rts/Sim/Misc/DamageArray.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -22,11 +22,10 @@
 }
 
 
-DamageArray::DamageArray()
+DamageArray::DamageArray() : paralyzeDamageTime(0),
+			impulseFactor(1.0f), impulseBoost(0.0f),
+			craterMult(1.0f), craterBoost(0.0f)
 {
-	paralyzeDamageTime = 0;
-	impulseBoost = craterBoost = 0.0f;
-	impulseFactor = craterMult = 1.0f;
 	if (damageArrayHandler) numTypes = damageArrayHandler-&gt;GetNumTypes();
 	else numTypes = 1;
 	damages = SAFE_NEW float[numTypes];
@@ -35,7 +34,7 @@
 }
 
 
-DamageArray::DamageArray(const DamageArray&amp; other)
+/*DamageArray::DamageArray(const DamageArray&amp; other)
 {
 	paralyzeDamageTime = other.paralyzeDamageTime;
 	impulseBoost = other.impulseBoost;
@@ -46,10 +45,10 @@
 	damages = SAFE_NEW float[numTypes];
 	for(int a = 0; a &lt; numTypes; ++a)
 		damages[a] = other.damages[a];
-}
+}*/
 
 
-DamageArray::~DamageArray()
+/*DamageArray::~DamageArray()
 {
 	delete[] damages;
-}
+}*/

Modified: branches/caiinterface/rts/Sim/Misc/DamageArray.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/DamageArray.h	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/rts/Sim/Misc/DamageArray.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -1,6 +1,9 @@
 #ifndef __DAMAGE_ARRAY_H__
 #define __DAMAGE_ARRAY_H__
 
+#include &quot;StdAfx.h&quot;
+#include &quot;DamageArrayHandler.h&quot;
+
 struct DamageArray
 {
 	CR_DECLARE_STRUCT(DamageArray);
@@ -8,9 +11,39 @@
 public:
 
 	DamageArray();
-	DamageArray(const DamageArray&amp; other);
-	~DamageArray();
 
+	/**
+	 * This constructor is currently only used by C++ AIs
+	 * which use the legacy C++ wrapper around the C AI interface.
+	 */
+	DamageArray(int numTypes, const float* typeDamages) :
+			numTypes(numTypes)
+	{
+		damages = new float[numTypes];
+		for(int a = 0; a &lt; numTypes; ++a) {
+			damages[a] = typeDamages[a];
+		}
+	}
+
+DamageArray(const DamageArray&amp; other)
+{
+	paralyzeDamageTime = other.paralyzeDamageTime;
+	impulseBoost = other.impulseBoost;
+	craterBoost = other.craterBoost;
+	impulseFactor = other.impulseFactor;
+	craterMult = other.craterMult;
+	numTypes = other.numTypes;
+	damages = SAFE_NEW float[numTypes];
+	for(int a = 0; a &lt; numTypes; ++a)
+		damages[a] = other.damages[a];
+}
+
+
+	~DamageArray()
+	{
+		delete[] damages;
+	}
+
 	void operator=(const DamageArray&amp; other) {
 		paralyzeDamageTime = other.paralyzeDamageTime;
 		impulseFactor = other.impulseFactor;
@@ -31,6 +64,8 @@
 		return da;
 	}
 
+	int GetNumTypes() const { return numTypes; }
+	float GetTypeDamage(int typeIndex) const { return damages[typeIndex]; }
 	float GetDefaultDamage() const { return damages[0]; }
 
 	int paralyzeDamageTime;

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -12,6 +12,7 @@
 
 	friend class CCommandAI;
 	friend class CFactoryCAI;
+	friend class CAIAICallback; // the C++ AI interface wrapper
 
 	CR_DECLARE(CCommandQueue);
 	public:

Modified: branches/caiinterface/rts/System/float3.cpp
===================================================================
--- branches/caiinterface/rts/System/float3.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/rts/System/float3.cpp	2008-07-21 08:59:37 UTC (rev 6208)
@@ -11,7 +11,7 @@
 CR_BIND(float3, );
 CR_REG_METADATA(float3, (CR_MEMBER(x), CR_MEMBER(y), CR_MEMBER(z)));
 
-float float3::maxxpos = 2048.0f; /**&lt; Maximum X position is 2048 */
+float float3::maxxpos = 2048.0f; /**&lt; Maximum x position is 2048 */
 float float3::maxzpos = 2048.0f; /**&lt; Maximum z position is 2048 */
 
 /**
@@ -54,3 +54,14 @@
 	}
 	return *this;
 }
+
+SAIFloat3 float3::toSAIFloat3() const {
+
+	SAIFloat3 sAIFloat3;
+
+	sAIFloat3.x = x;
+	sAIFloat3.y = y;
+	sAIFloat3.z = z;
+
+	return  sAIFloat3;
+}

Modified: branches/caiinterface/rts/System/float3.h
===================================================================
--- branches/caiinterface/rts/System/float3.h	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/rts/System/float3.h	2008-07-21 08:59:37 UTC (rev 6208)
@@ -10,6 +10,7 @@
 #include &quot;SFloat3.h&quot;
 #include &quot;lib/streflop/streflop_cond.h&quot;
 #include &quot;creg/creg.h&quot;
+#include &quot;ExternalAI/SAIFloat3.h&quot;
 
 /**
  * @brief float3 class
@@ -44,6 +45,31 @@
 	inline float3(const float x,const float y,const float z) : SFloat3(x,y,z) {}
 
 	/**
+	 * @brief Constructor
+	 * @param sAIFloat3 SAIFLoat3 sAIFLoat3
+	 *
+	 * With parameters, initializes x/y/z to the given SAIFLoat3.
+	 */
+	inline float3(const SAIFloat3&amp; sAIFloat3) : SFloat3(sAIFloat3.x, sAIFloat3.y, sAIFloat3.z) {}
+
+	/**
+	 * @brief operator =
+	 * @param t index in xyz array
+	 * @return const float3
+	 *
+	 * Same as plain [] operator but used in
+	 * a const context
+	 */
+	inline float3&amp; operator= (const SAIFloat3&amp; sAIFloat3) {
+		
+		x = sAIFloat3.x;
+		y = sAIFloat3.y;
+		z = sAIFloat3.z;
+
+		return *this;
+	}
+
+	/**
 	 * @brief Destructor
 	 *
 	 * Does nothing
@@ -442,6 +468,8 @@
 	static float maxzpos;
 
 	bool CheckInBounds(); //!&lt; Check if this vector is in bounds
+
+	SAIFloat3 toSAIFloat3() const;
 };
 
 #endif /* FLOAT3_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000987.html">[Taspring-linux-commit] r6207 - branches
</A></li>
	<LI>Next message: <A HREF="000989.html">[Taspring-linux-commit] r6209 - trunk/Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#988">[ date ]</a>
              <a href="thread.html#988">[ thread ]</a>
              <a href="subject.html#988">[ subject ]</a>
              <a href="author.html#988">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
