<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6196 - in trunk/Lobby/TASClient: .	Graphics LobbyComponents Python Python/engine Python/scripts	Python/scripts/subf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6196%20-%20in%20trunk/Lobby/TASClient%3A%20.%0A%09Graphics%20LobbyComponents%20Python%20Python/engine%20Python/scripts%0A%09Python/scripts/subf&In-Reply-To=%3C20080718011046.CB34D467A%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000975.html">
   <LINK REL="Next"  HREF="000977.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6196 - in trunk/Lobby/TASClient: .	Graphics LobbyComponents Python Python/engine Python/scripts	Python/scripts/subf</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6196%20-%20in%20trunk/Lobby/TASClient%3A%20.%0A%09Graphics%20LobbyComponents%20Python%20Python/engine%20Python/scripts%0A%09Python/scripts/subf&In-Reply-To=%3C20080718011046.CB34D467A%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6196 - in trunk/Lobby/TASClient: .	Graphics LobbyComponents Python Python/engine Python/scripts	Python/scripts/subf">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Jul 18 03:10:46 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000975.html">[Taspring-linux-commit] r6195 - in trunk/rts/Sim: . MoveTypes
</A></li>
        <LI>Next message: <A HREF="000977.html">[Taspring-linux-commit] r6197 - trunk/rts/ExternalAI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#976">[ date ]</a>
              <a href="thread.html#976">[ thread ]</a>
              <a href="subject.html#976">[ subject ]</a>
              <a href="author.html#976">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: satirik
Date: 2008-07-18 03:10:44 +0200 (Fri, 18 Jul 2008)
New Revision: 6196

Added:
   trunk/Lobby/TASClient/Graphics/host.bmp
   trunk/Lobby/TASClient/LobbyComponents/ExRichEdit.pas
   trunk/Lobby/TASClient/LobbyComponents/Langs.pas
   trunk/Lobby/TASClient/LobbyComponents/RichEdit2.pas
   trunk/Lobby/TASClient/LobbyComponents/WStrList.pas
   trunk/Lobby/TASClient/LobbyComponents/richole.pas
   trunk/Lobby/TASClient/LobbyScriptUnit.pas
   trunk/Lobby/TASClient/Python/
   trunk/Lobby/TASClient/Python/api.txt
   trunk/Lobby/TASClient/Python/engine/
   trunk/Lobby/TASClient/Python/engine/UserDict.py
   trunk/Lobby/TASClient/Python/engine/copy_reg.py
   trunk/Lobby/TASClient/Python/engine/dis.py
   trunk/Lobby/TASClient/Python/engine/handlers.py
   trunk/Lobby/TASClient/Python/engine/inspect.py
   trunk/Lobby/TASClient/Python/engine/linecache.py
   trunk/Lobby/TASClient/Python/engine/macpath.py
   trunk/Lobby/TASClient/Python/engine/ntpath.py
   trunk/Lobby/TASClient/Python/engine/opcode.py
   trunk/Lobby/TASClient/Python/engine/os.py
   trunk/Lobby/TASClient/Python/engine/posixpath.py
   trunk/Lobby/TASClient/Python/engine/re.py
   trunk/Lobby/TASClient/Python/engine/sre_compile.py
   trunk/Lobby/TASClient/Python/engine/sre_constants.py
   trunk/Lobby/TASClient/Python/engine/sre_parse.py
   trunk/Lobby/TASClient/Python/engine/stat.py
   trunk/Lobby/TASClient/Python/engine/string.py
   trunk/Lobby/TASClient/Python/engine/token.py
   trunk/Lobby/TASClient/Python/engine/tokenize.py
   trunk/Lobby/TASClient/Python/engine/types.py
   trunk/Lobby/TASClient/Python/modules/
   trunk/Lobby/TASClient/Python/scripts/
   trunk/Lobby/TASClient/Python/scripts/stick.py
   trunk/Lobby/TASClient/Python/scripts/subf/
   trunk/Lobby/TASClient/Python/scripts/subf/adminhelper.py
   trunk/Lobby/TASClient/Python/scripts/subf/caReplier.py
   trunk/Lobby/TASClient/Python/scripts/subf/code.py
   trunk/Lobby/TASClient/Python/scripts/subf/debugwindow.py
   trunk/Lobby/TASClient/Python/scripts/subf/offlinemessage.py
   trunk/Lobby/TASClient/Python/scripts/subf/pingpong.py
   trunk/Lobby/TASClient/Python/scripts/subf/print.py
   trunk/Lobby/TASClient/Python/scripts/subf/specOnJoin.py
   trunk/Lobby/TASClient/Python/scripts/subf/testnew.py
   trunk/Lobby/TASClient/PythonScriptDebugFormUnit.ddp
   trunk/Lobby/TASClient/PythonScriptDebugFormUnit.dfm
   trunk/Lobby/TASClient/PythonScriptDebugFormUnit.pas
Modified:
   trunk/Lobby/TASClient/BattleFormUnit.dfm
   trunk/Lobby/TASClient/BattleFormUnit.pas
   trunk/Lobby/TASClient/ColorsPreferenceUnit.pas
   trunk/Lobby/TASClient/DebugUnit.dfm
   trunk/Lobby/TASClient/DebugUnit.pas
   trunk/Lobby/TASClient/DisableUnitsFormUnit.pas
   trunk/Lobby/TASClient/ExceptionUnit.dfm
   trunk/Lobby/TASClient/Graphics/admin.bmp
   trunk/Lobby/TASClient/HelpUnit.dfm
   trunk/Lobby/TASClient/HighlightingUnit.ddp
   trunk/Lobby/TASClient/HighlightingUnit.pas
   trunk/Lobby/TASClient/HostBattleFormUnit.dfm
   trunk/Lobby/TASClient/HostBattleFormUnit.pas
   trunk/Lobby/TASClient/HttpGetUnit.dfm
   trunk/Lobby/TASClient/HttpGetUnit.pas
   trunk/Lobby/TASClient/MainUnit.ddp
   trunk/Lobby/TASClient/MainUnit.dfm
   trunk/Lobby/TASClient/MainUnit.pas
   trunk/Lobby/TASClient/MenuFormUnit.pas
   trunk/Lobby/TASClient/Misc.pas
   trunk/Lobby/TASClient/PreferencesFormUnit.pas
   trunk/Lobby/TASClient/ReplaysUnit.dfm
   trunk/Lobby/TASClient/ReplaysUnit.pas
   trunk/Lobby/TASClient/TASClient.dof
   trunk/Lobby/TASClient/TASClient.dpr
   trunk/Lobby/TASClient/TASClient.res
   trunk/Lobby/TASClient/Utility.pas
   trunk/Lobby/TASClient/WaitForAckUnit.pas
Log:
* disabled units bugs fixed
* admin icon added (gold = admin, normal = host)
* richedit control changed =&gt; fix the slow down because of a big chat log
* connect with password on lan server option added to the debug window
* ignore redirects option added to the debug window
* python scripting added, with 1 enabled script :
    + stick.py : type /stick userName spec={0/1} to auto join and leave a battle the user is in
    + others available test scripts like &quot;auto spec on join&quot; are available in the subf folder
* Open python scripting debug window button added in the debug window
* SP skins moved to the lobby folder

Modified: trunk/Lobby/TASClient/BattleFormUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/BattleFormUnit.dfm	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/BattleFormUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -1,6 +1,6 @@
 object BattleForm: TBattleForm
-  Left = 768
-  Top = 232
+  Left = 356
+  Top = 52
   Width = 787
   Height = 586
   Caption = 'Battle window'
@@ -3962,26 +3962,103 @@
         OnKeyDown = InputEditKeyDown
         OnKeyPress = InputEditKeyPress
       end
-      object ChatRichEdit: TTntRichEditURL
-        Left = 88
-        Top = 0
-        Width = 129
-        Height = 65
-        TabStop = False
-        Font.Charset = DEFAULT_CHARSET
-        Font.Color = clWindowText
-        Font.Height = -11
-        Font.Name = 'MS Sans Serif'
-        Font.Style = []
+      object ChatRichEdit: TExRichEdit
+        Left = 96
+        Top = 8
+        Width = 137
+        Height = 81
+        AutoURLDetect = adDefault
+        CustomURLs = &lt;
+          item
+            Name = 'e-mail'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'http'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'file'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'mailto'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'ftp'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'https'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'gopher'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'nntp'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'prospero'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'telnet'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'news'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end
+          item
+            Name = 'wais'
+            Color = clWindowText
+            Cursor = crDefault
+            Underline = True
+          end&gt;
         HideSelection = False
-        ParentFont = False
-        PlainText = True
+        LangOptions = [loAutoFont]
+        Language = 1036
         ReadOnly = True
         ScrollBars = ssVertical
+        ShowSelectionBar = False
         TabOrder = 1
-        OnDblClick = ChatRichEditDblClick
-        OnMouseDown = ChatRichEditMouseDown
-        OnURLClick = ChatRichEditURLClick
+        URLColor = clBlue
+        URLCursor = crHandPoint
+        OnMouseDown = ChaTRichEditMouseDown
+        OnURLClick = ChaTExRichEditURLClick
+        InputFormat = ifText
+        OutputFormat = ofRTF
+        SelectedInOut = False
+        PlainRTF = False
+        UndoLimit = 0
+        IncludeOLE = True
+        AllowInPlace = False
       end
     end
     object Panel1: TPanel
@@ -4025,6 +4102,7 @@
             Caption = 'Game options'
             Checked = True
             CustomWidth = 103
+            CustomHeight = 30
             ThemeType = tttNone
           end
           object DisabledUnitsTab: TSpTBXTabItem
@@ -4047,20 +4125,20 @@
           end
           object MapTabSheet: TSpTBXTabSheet
             Left = 0
-            Top = 23
+            Top = 34
             Width = 419
-            Height = 250
+            Height = 239
             Caption = 'Map options'
             ImageIndex = -1
             DesignSize = (
               419
-              250)
+              239)
             TabItem = 'MapTab'
             object MapOptionsScrollBox: TTntScrollBox
               Left = 2
               Top = 48
               Width = 414
-              Height = 200
+              Height = 189
               VertScrollBar.Smooth = True
               VertScrollBar.Tracking = True
               Anchors = [akLeft, akTop, akRight, akBottom]
@@ -4127,20 +4205,20 @@
           end
           object ModTabSheet: TSpTBXTabSheet
             Left = 0
-            Top = 23
+            Top = 34
             Width = 419
-            Height = 250
+            Height = 239
             Caption = 'Mod options'
             ImageIndex = -1
             DesignSize = (
               419
-              250)
+              239)
             TabItem = 'ModTab'
             object ModOptionsScrollBox: TTntScrollBox
               Left = 2
               Top = 48
               Width = 414
-              Height = 200
+              Height = 189
               VertScrollBar.Smooth = True
               VertScrollBar.Tracking = True
               Anchors = [akLeft, akTop, akRight, akBottom]
@@ -4207,20 +4285,20 @@
           end
           object SpTBXTabSheet1: TSpTBXTabSheet
             Left = 0
-            Top = 23
+            Top = 34
             Width = 419
-            Height = 250
+            Height = 239
             Caption = 'Disabled Units (0)'
             ImageIndex = -1
             DesignSize = (
               419
-              250)
+              239)
             TabItem = 'DisabledUnitsTab'
             object UnitsGroupBox: TSpTBXGroupBox
               Left = 8
               Top = 4
               Width = 401
-              Height = 237
+              Height = 226
               Caption = 'Disabled units'
               Anchors = [akLeft, akTop, akBottom]
               Color = clNone
@@ -4228,7 +4306,7 @@
               TabOrder = 0
               DesignSize = (
                 401
-                237)
+                226)
               object AddUnitsSpeedButton: TSpeedButton
                 Left = 264
                 Top = 10
@@ -4241,7 +4319,7 @@
                 Left = 16
                 Top = 32
                 Width = 369
-                Height = 193
+                Height = 182
                 Anchors = [akLeft, akTop, akRight, akBottom]
                 DefaultNodeHeight = 64
                 Header.AutoSizeIndex = 1
@@ -4276,9 +4354,9 @@
           end
           object SpTBXTabSheet2: TSpTBXTabSheet
             Left = 0
-            Top = 23
+            Top = 34
             Width = 419
-            Height = 250
+            Height = 239
             Caption = 'Game options'
             ImageIndex = -1
             TabItem = 'GameOptionsTab'

Modified: trunk/Lobby/TASClient/BattleFormUnit.pas
===================================================================
--- trunk/Lobby/TASClient/BattleFormUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/BattleFormUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -24,7 +24,8 @@
   ImageEx, JvSticker, JvExExtCtrls, JvImage, JvShape, JvLabel, TBXLists,
   SpTBXLists, ImgList, SpTBXjanTracker, SpTBXFormPopupMenu,IniFiles,
   HttpProt,MsMultiPartFormData, JvComponentBase, JvDSADialogs, Spin, Mask,
-  JvExMask, JvSpin, TntStdCtrls, TntForms, TntComCtrls,RichEdit,JclUnicode;
+  JvExMask, JvSpin, TntStdCtrls, TntForms, TntComCtrls,RichEdit,JclUnicode,
+  RichEdit2, ExRichEdit;
 
 type
 
@@ -216,7 +217,6 @@
     mnuNewGroup: TSpTBXItem;
     SpTBXSeparatorItem6: TSpTBXSeparatorItem;
     InputEdit: TSpTBXEdit;
-    ChatRichEdit: TTntRichEditURL;
     Panel4: TPanel;
     Splitter2: TSplitter;
     VDTBattleClients: TVirtualDrawTree;
@@ -289,6 +289,7 @@
     SpTBXItem12: TSpTBXItem;
     SpTBXSeparatorItem8: TSpTBXSeparatorItem;
     VDTDisabledUnits: TVirtualDrawTree;
+    ChatRichEdit: TExRichEdit;
 
     procedure CreateParams(var Params: TCreateParams); override;
 
@@ -374,7 +375,7 @@
     procedure TeamColorSpeedButtonClick(Sender: TObject);
     procedure AddUnitsSpeedButtonClick(Sender: TObject);
     procedure AddBotButtonClick(Sender: TObject);
-    procedure ChatRichEditURLClick(Sender: TObject; const URL: String);
+    procedure ChaTExRichEditURLClick(Sender: TObject; const URL: String);
     procedure MapImageMouseMove(Sender: TObject; Shift: TShiftState; X,
       Y: Integer);
     procedure MapImageMouseUp(Sender: TObject; Button: TMouseButton;
@@ -482,8 +483,6 @@
     procedure LockGameSpeedCheckBoxClick(Sender: TObject);
     procedure mnuNewGroupClick(Sender: TObject);
     procedure mnuRemoveFromGroupClick(Sender: TObject);
-    procedure ChatRichEditMouseDown(Sender: TObject; Button: TMouseButton;
-      Shift: TShiftState; X, Y: Integer);
     procedure btLoadModsDefaultMDOClick(Sender: TObject);
     procedure btLoadMapsDefaultMPOClick(Sender: TObject);
     procedure btSetAsDefaultMDOClick(Sender: TObject);
@@ -495,7 +494,10 @@
     procedure SpTBXItem12Click(Sender: TObject);
     procedure VDTDisabledUnitsDrawNode(Sender: TBaseVirtualTree;
       const PaintInfo: TVTPaintInfo);
-    procedure ChatRichEditDblClick(Sender: TObject);
+    procedure ChaTExRichEditDblClick(Sender: TObject);
+    procedure Button1Click(Sender: TObject);
+    procedure ChatRichEditMouseDown(Sender: TObject; Button: TMouseButton;
+      Shift: TShiftState; X, Y: Integer);
   private
     History: TWideStringList;
     HistoryIndex: Integer;
@@ -527,6 +529,7 @@
     procedure LoadMapOptionsDefault;
     procedure DisconnectButtonClick;overload;
     procedure PopulateDisabledUnitsVDT;
+    function isBattleReadyToStart: Boolean;
   end;
 
   TBattleParticipation = (None, Hosting, Joined);
@@ -643,7 +646,7 @@
   InitWaitFormUnit, AddBotUnit, Math, OnlineMapsUnit, ReplaysUnit, StrUtils,
   CustomColorUnit, StringParser, MapListFormUnit, AutoTeamsUnit,
   AutoStartRectsUnit, ColorPicker, UploadReplayUnit, ProgressBarWindow,
-  TntWideStrings;
+  TntWideStrings, LobbyScriptUnit;
 
 {$R *.dfm}
 
@@ -1331,6 +1334,7 @@
   tmp: Integer;
   i: integer;
   validMaps: TStringList;
+  dlMap: TDownloadMapThread;
 begin
   Result := False;
 
@@ -1431,6 +1435,9 @@
   BattleForm.Caption := 'Battle window (' + BattleState.Battle.ModName + ')'; // this has no effect since battle form was skinned using TSpTBXTitleBar!
   SpTBXTitleBar1.Caption := 'Battle window (' + BattleState.Battle.ModName + ')';
 
+  if Utility.MapList.IndexOf(BattleState.Battle.Map) = -1 then
+    dlMap := TDownloadMapThread.Create(false,BattleState.Battle.MapHash,BattleState.Battle.Map);
+
   Result := True;
 
   if not Preferences.DisableAllSounds then PlayResSound('battle');
@@ -1443,6 +1450,7 @@
   Battle: TBattle;
   tmp: Integer;
   i: Integer;
+  dlMap: TDownloadMapThread;
 begin
   Result := False;
 
@@ -1518,7 +1526,9 @@
   BattleForm.Caption := 'Battle window (' + BattleState.Battle.ModName + ')'; // this has no effect since battle form was skinned using TSpTBXTitleBar!
   SpTBXTitleBar1.Caption := 'Battle window (' + BattleState.Battle.ModName + ')';
 
-
+  if Utility.MapList.IndexOf(BattleState.Battle.Map) = -1 then
+    dlMap := TDownloadMapThread.Create(false,BattleState.Battle.MapHash,BattleState.Battle.Map);
+    
   Result := True;
 
   if not Preferences.DisableAllSounds then PlayResSound('battle');
@@ -2373,6 +2383,7 @@
 
   InputEdit.Align := alBottom;
   ChatRichEdit.Align := alClient;
+
   mask := SendMessage(ChatRichEdit.Handle, EM_GETEVENTMASK, 0, 0);
   SendMessage(ChatRichEdit.Handle, EM_SETEVENTMASK, 0, mask or ENM_LINK);
   SendMessage(ChatRichEdit.Handle, EM_AUTOURLDETECT, Integer(True), 0);
@@ -2442,26 +2453,38 @@
 
 end;
 
+function TBattleForm.isBattleReadyToStart: Boolean;
+begin
+  Result := (BattleState.Battle &lt;&gt; nil) and BattleState.Battle.AreAllClientsReady and BattleState.Battle.AreAllClientsSynced and LadderTeamReady and (BattleState.Status = Hosting);
+end;
+
 procedure TBattleForm.StartButtonClick(Sender: TObject);
 var
   res: Integer;
 begin
+  if not isBattleReadyToStart then
+  begin
+    StartButton.Enabled := False;
+    if not LobbyScriptUnit.ScriptStart then MessageDlg('The battle is not ready to start!', mtInformation, [mbOK], 0);
+    Exit;
+  end;
+
   if not BattleState.Battle.AreAllBotsSet then
   begin
-    MessageDlg('Two or more bots share the same team number. Please change that!', mtInformation, [mbOK], 0);
+    if not LobbyScriptUnit.ScriptStart then MessageDlg('Two or more bots share the same team number. Please change that!', mtInformation, [mbOK], 0);
     Exit;
   end;
 
   if BattleState.Battle.Clients.Count &gt; MAX_PLAYERS then
   begin
-    MessageDlg('Too many players (spring supports up to ' + IntToStr(MAX_PLAYERS) + ' players)!', mtWarning, [mbOK], 0);
+    if not LobbyScriptUnit.ScriptStart then MessageDlg('Too many players (spring supports up to ' + IntToStr(MAX_PLAYERS) + ' players)!', mtWarning, [mbOK], 0);
     Exit;
   end;
-  
+
   if BattleState.Battle.BattleType = 1 then // we're hosting an online replay
     if BattleReplayInfo.OriginalClients.Count + BattleState.Battle.Clients.Count &gt; MAX_PLAYERS then
     begin
-      MessageDlg('Too many players (spring supports up to ' + IntToStr(MAX_PLAYERS) + ' players, original players from the demo included)!', mtWarning, [mbOK], 0);
+      if not LobbyScriptUnit.ScriptStart then MessageDlg('Too many players (spring supports up to ' + IntToStr(MAX_PLAYERS) + ' players, original players from the demo included)!', mtWarning, [mbOK], 0);
       Exit;
     end;
 
@@ -2473,10 +2496,11 @@
     res := InitWaitForm.ShowModal;
     if res &lt;&gt; mrOK then
     begin
-      MessageDlg('Unable to acquire UDP source port from server. Try choosing another NAT traversal technique!', mtWarning, [mbOK], 0);
+      if not LobbyScriptUnit.ScriptStart then MessageDlg('Unable to acquire UDP source port from server. Try choosing another NAT traversal technique!', mtWarning, [mbOK], 0);
       Exit;
     end;
   end;
+  LobbyScriptUnit.StartBattleSuccess := True;
   PostMessage(BattleForm.Handle, WM_STARTGAME, 0, 0);
 end;
 
@@ -3448,7 +3472,7 @@
   AddBotForm.ShowModal;
 end;
 
-procedure TBattleForm.ChatRichEditURLClick(Sender: TObject;
+procedure TBattleForm.ChaTExRichEditURLClick(Sender: TObject;
   const URL: String);
 begin
   Misc.OpenURLInDefaultBrowser(URL);
@@ -4117,8 +4141,10 @@
           end;
 
           // hoster icon
-          if RealIndex = 0 then
-            MainForm.PlayerStateImageList.Draw(Canvas, R.Left + Pos, R.Top, 4);
+          if TClient(BattleState.Battle.Clients[RealIndex]).GetAccess then
+            MainForm.PlayerStateImageList.Draw(Canvas, R.Left + Pos, R.Top, 4)
+          else if RealIndex = 0 then
+            MainForm.PlayerStateImageList.Draw(Canvas, R.Left + Pos, R.Top, 5);
         end;
         NormalBot:
         begin
@@ -4134,7 +4160,11 @@
           if Preferences.ShowFlags then
           begin
             // Country Flag:
-            FlagBitmap := MainForm.GetFlagBitmap(TClient(BattleReplayInfo.OriginalClients[RealIndex]).Country);
+            try
+              FlagBitmap := MainForm.GetFlagBitmap(TClient(BattleReplayInfo.OriginalClients[RealIndex]).Country);
+            except
+              FlagBitmap := TBitmap.Create;
+            end;
             Canvas.Draw(R.Left, R.Top + 16 div 2 - FlagBitmap.Height div 2, FlagBitmap);
             Inc(Pos, FlagBitmap.Width + 4);
           end;
@@ -5618,7 +5648,7 @@
       except
         //MainForm.AddMainLog('Error: Ladder map list unavailable :'+IntToStr(TLadder(LadderList[BattleState.LadderIndex]).id), Colors.Error);
         UpdateMessageStatus('Error: Ladder server unavailable.');
-        Finalize(BattleState.Battle.AreAllClientsReady and BattleState.Battle.AreAllClientsSynced and BattleForm.LadderTeamReady);
+        Finalize(isBattleReadyToStart);
         MessageDlgThread('The ladder server is unavailable, if the ladder url has changed you may fix this by updating your lobby.',mtError,[mbOk],0);
         Synchronize(BattleForm.DisconnectButtonClick);
         Exit;
@@ -5676,7 +5706,7 @@
         Exit;
       end;
 
-      Finalize(BattleState.Battle.AreAllClientsReady and BattleState.Battle.AreAllClientsSynced and BattleForm.LadderTeamReady);
+      Finalize(isBattleReadyToStart);
   end;
  end;
 end;
@@ -6271,12 +6301,6 @@
   MainForm.mnuRemoveFromGroupClick(nil);
 end;
 
-procedure TBattleForm.ChatRichEditMouseDown(Sender: TObject;
-  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-begin
-  MainForm.RichEditMouseDown(Sender,Button,Shift,X,Y);
-end;
-
 procedure TBattleForm.btLoadModsDefaultMDOClick(Sender: TObject);
 var
   i:integer;
@@ -6497,11 +6521,14 @@
           availableWidth := R.Right-R.Left;
           availableHeight := R.Bottom-R.Top;
 
-          if (TBitmap(UnitBitmaps[nodeIndex]).Width/TBitmap(UnitBitmaps[nodeIndex]).Height) &gt; (availableWidth/availableHeight) then
-            Canvas.StretchDraw(Rect(R.Left,R.Top,R.Right,R.Top+Round(availableWidth*TBitmap(UnitBitmaps[nodeIndex]).Height/TBitmap(UnitBitmaps[nodeIndex]).Width)),TBitmap(UnitBitmaps[nodeIndex]))
-          else
-            Canvas.StretchDraw(Rect(R.Left,R.Top,R.Left+Round(availableHeight*TBitmap(UnitBitmaps[nodeIndex]).Width/TBitmap(UnitBitmaps[nodeIndex]).Height),R.Bottom),TBitmap(UnitBitmaps[nodeIndex]));
-        end;
+          if TBitmap(UnitBitmaps[nodeIndex]).Width &gt; 0 then
+          begin
+            if (TBitmap(UnitBitmaps[nodeIndex]).Width/TBitmap(UnitBitmaps[nodeIndex]).Height) &gt; (availableWidth/availableHeight) then
+              Canvas.StretchDraw(Rect(R.Left,R.Top,R.Right,R.Top+Round(availableWidth*TBitmap(UnitBitmaps[nodeIndex]).Height/TBitmap(UnitBitmaps[nodeIndex]).Width)),TBitmap(UnitBitmaps[nodeIndex]))
+            else
+              Canvas.StretchDraw(Rect(R.Left,R.Top,R.Left+Round(availableHeight*TBitmap(UnitBitmaps[nodeIndex]).Width/TBitmap(UnitBitmaps[nodeIndex]).Height),R.Bottom),TBitmap(UnitBitmaps[nodeIndex]));
+            end;
+          end;
       end;
       1: s := UnitNames[nodeIndex]; // unit name
       2: s := UnitList[nodeIndex]; // unit &quot;code name&quot;
@@ -6518,7 +6545,7 @@
   end;
 end;
 
-procedure TBattleForm.ChatRichEditDblClick(Sender: TObject);
+procedure TBattleForm.ChaTExRichEditDblClick(Sender: TObject);
 var
    ci, //Character Index
    lix, //Line Index
@@ -6529,10 +6556,10 @@
    SelectedNick: string;
    SelectedClient: TClient;
 begin
-   with TTntRichEdit(Sender) do
+   with TExRichEdit(Sender) do
    begin
      GetCursorPos(pt);
-     pt := TTntRichEdit(Sender).ScreenToClient(pt);
+     pt := TExRichEdit(Sender).ScreenToClient(pt);
      //Pt := Point(X, Y) ;
      ci := Perform(Messages.EM_CHARFROMPOS, 0, Integer(@Pt)) ;
      if ci &lt; 0 then Exit;
@@ -6558,4 +6585,16 @@
    end;
 end;
 
+procedure TBattleForm.Button1Click(Sender: TObject);
+begin
+  Utility.ExtractVFSDir('lups','');
+end;
+
+
+procedure TBattleForm.ChatRichEditMouseDown(Sender: TObject;
+  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
+begin
+  MainForm.RichEditMouseDown(Sender,Button,Shift,X,Y);
+end;
+
 end.

Modified: trunk/Lobby/TASClient/ColorsPreferenceUnit.pas
===================================================================
--- trunk/Lobby/TASClient/ColorsPreferenceUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/ColorsPreferenceUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -4,7 +4,8 @@
 
 uses
   Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, SpTBXItem, SpTBXControls, ExtCtrls, TBXDkPanels,Misc,MainUnit,TntComCtrls,SpTBXEditors;
+  Dialogs, SpTBXItem, SpTBXControls, ExtCtrls, TBXDkPanels,Misc,MainUnit,
+  TntComCtrls,SpTBXEditors,RichEdit2, ExRichEdit;
 
 type
   TColorsPreference = class(TForm)
@@ -243,7 +244,7 @@
 
   for i:=0 to MainForm.PageControl1.PageCount-1 do
   begin
-    ((MainForm.PageControl1.Pages[i] as TMyTabSheet).Controls[1] as TTntRichEdit).Font.Assign(CommonFont);
+    ((MainForm.PageControl1.Pages[i] as TMyTabSheet).Controls[1] as TExRichEdit).Font.Assign(CommonFont);
     ((MainForm.PageControl1.Pages[i] as TMyTabSheet).Controls[0] as TSpTBXEdit).Font.Assign(CommonFont);
   end;
 

Modified: trunk/Lobby/TASClient/DebugUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/DebugUnit.dfm	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/DebugUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -1,10 +1,10 @@
 object DebugForm: TDebugForm
-  Left = 285
-  Top = 195
+  Left = 884
+  Top = 138
   BorderStyle = bsDialog
   Caption = 'Debug options'
-  ClientHeight = 204
-  ClientWidth = 330
+  ClientHeight = 296
+  ClientWidth = 292
   Color = clBtnFace
   Font.Charset = DEFAULT_CHARSET
   Font.Color = clWindowText
@@ -19,8 +19,8 @@
   PixelsPerInch = 96
   TextHeight = 13
   object Button1: TButton
-    Left = 80
-    Top = 168
+    Left = 65
+    Top = 256
     Width = 75
     Height = 25
     Caption = 'OK'
@@ -44,8 +44,8 @@
     TabOrder = 2
   end
   object Button2: TButton
-    Left = 176
-    Top = 168
+    Left = 153
+    Top = 256
     Width = 75
     Height = 25
     Cancel = True
@@ -55,7 +55,7 @@
   end
   object GroupBox1: TGroupBox
     Left = 24
-    Top = 96
+    Top = 176
     Width = 153
     Height = 58
     Caption = 'Traffic (cumulative)'
@@ -97,16 +97,41 @@
     Caption = 'Ignore server version incompatibility'
     TabOrder = 5
   end
+  object CheckBox4: TCheckBox
+    Left = 24
+    Top = 88
+    Width = 297
+    Height = 17
+    Caption = 'Login with password on lan server'
+    TabOrder = 6
+  end
+  object CheckBox5: TCheckBox
+    Left = 24
+    Top = 112
+    Width = 297
+    Height = 17
+    Caption = 'Ignore redirects'
+    TabOrder = 7
+  end
+  object Button3: TButton
+    Left = 24
+    Top = 136
+    Width = 129
+    Height = 25
+    Caption = 'Open debug script form'
+    TabOrder = 8
+    OnClick = Button3Click
+  end
   object OpenDialog1: TOpenDialog
     Filter = 'LUA script|*.lua'
     Left = 280
-    Top = 168
+    Top = 224
   end
   object TrafficTimer: TTimer
     Enabled = False
     Interval = 200
     OnTimer = TrafficTimerTimer
     Left = 16
-    Top = 168
+    Top = 224
   end
 end

Modified: trunk/Lobby/TASClient/DebugUnit.pas
===================================================================
--- trunk/Lobby/TASClient/DebugUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/DebugUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -20,11 +20,15 @@
     DataSentLabel: TLabel;
     DataReceivedLabel: TLabel;
     CheckBox3: TCheckBox;
+    CheckBox4: TCheckBox;
+    CheckBox5: TCheckBox;
+    Button3: TButton;
     procedure Button1Click(Sender: TObject);
     procedure FormShow(Sender: TObject);
     procedure Button2Click(Sender: TObject);
     procedure FormHide(Sender: TObject);
     procedure TrafficTimerTimer(Sender: TObject);
+    procedure Button3Click(Sender: TObject);
   private
     { Private declarations }
   public
@@ -37,7 +41,7 @@
 implementation
 
 uses
-  MainUnit, PreferencesFormUnit, Misc;
+  MainUnit, PreferencesFormUnit, Misc, PythonScriptDebugFormUnit;
 
 {$R *.dfm}
 
@@ -46,6 +50,8 @@
   Debug.Enabled := CheckBox1.Checked;
   Debug.FilterPingPong := CheckBox2.Checked;
   Debug.IgnoreVersionIncompatibility := CheckBox3.Checked;
+  Debug.LoginWithPasswordOnLan := CheckBox4.Checked;
+  Debug.IgnoreRedirects := CheckBox5.Checked;
 
   Close;
 end;
@@ -75,4 +81,9 @@
   DataReceivedLabel.Caption := Misc.FormatFileSize2(Status.CumulativeDataRecv);
 end;
 
+procedure TDebugForm.Button3Click(Sender: TObject);
+begin
+  PythonScriptDebugForm.Show;
+end;
+
 end.

Modified: trunk/Lobby/TASClient/DisableUnitsFormUnit.pas
===================================================================
--- trunk/Lobby/TASClient/DisableUnitsFormUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/DisableUnitsFormUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -121,13 +121,16 @@
         begin
           availableWidth := R.Right-R.Left;
           availableHeight := R.Bottom-R.Top;
-          forceHeight := Round(availableWidth*TBitmap(UnitBitmaps[nodeIndex]).Height/TBitmap(UnitBitmaps[nodeIndex]).Width);
-          forceWidth := Round(availableHeight*TBitmap(UnitBitmaps[nodeIndex]).Width/TBitmap(UnitBitmaps[nodeIndex]).Height);
+          if TBitmap(UnitBitmaps[nodeIndex]).Width &gt; 0 then
+          begin
+            forceHeight := Round(availableWidth*TBitmap(UnitBitmaps[nodeIndex]).Height/TBitmap(UnitBitmaps[nodeIndex]).Width);
+            forceWidth := Round(availableHeight*TBitmap(UnitBitmaps[nodeIndex]).Width/TBitmap(UnitBitmaps[nodeIndex]).Height);
 
-          if ((TBitmap(UnitBitmaps[nodeIndex]).Width &gt; TBitmap(UnitBitmaps[nodeIndex]).Height) and (forceHeight &lt; availableHeight)) or (forceWidth &gt; availableWidth) then
-            Canvas.StretchDraw(Rect(R.Left,R.Top,R.Right,R.Top+forceHeight),TBitmap(UnitBitmaps[nodeIndex]))
-          else
-            Canvas.StretchDraw(Rect(R.Left,R.Top,R.Left+forceWidth,R.Bottom),TBitmap(UnitBitmaps[nodeIndex]));
+            if ((TBitmap(UnitBitmaps[nodeIndex]).Width &gt; TBitmap(UnitBitmaps[nodeIndex]).Height) and (forceHeight &lt; availableHeight)) or (forceWidth &gt; availableWidth) then
+              Canvas.StretchDraw(Rect(R.Left,R.Top,R.Right,R.Top+forceHeight),TBitmap(UnitBitmaps[nodeIndex]))
+            else
+              Canvas.StretchDraw(Rect(R.Left,R.Top,R.Left+forceWidth,R.Bottom),TBitmap(UnitBitmaps[nodeIndex]));
+          end;
         end;
       end;
       2: s := UnitNames[nodeIndex]; // unit name
@@ -276,7 +279,7 @@
     Node := VDTUnits.GetFirst;
     while Node &lt;&gt; nil do
     begin
-      Node.NodeHeight := VDTUnits.Header.Columns[1].Width;
+      VDTUnits.NodeHeight[Node] := VDTUnits.Header.Columns[1].Width;
       Node.TotalHeight := VDTUnits.Header.Columns[1].Width;
       Node := VDTUnits.GetNext(Node);
     end;

Modified: trunk/Lobby/TASClient/ExceptionUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/ExceptionUnit.dfm	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/ExceptionUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -1,6 +1,6 @@
 object ExceptionDialog: TExceptionDialog
-  Left = 363
-  Top = 284
+  Left = 951
+  Top = 289
   ActiveControl = OkBtn
   AutoScroll = False
   BorderIcons = [biSystemMenu]

Modified: trunk/Lobby/TASClient/Graphics/admin.bmp
===================================================================
(Binary files differ)

Added: trunk/Lobby/TASClient/Graphics/host.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/Lobby/TASClient/Graphics/host.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/Lobby/TASClient/HelpUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/HelpUnit.dfm	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/HelpUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -1248,31 +1248,31 @@
           Picture.Data = {
             07544269746D617036030000424D360300000000000036000000280000001000
             000010000000010018000000000000030000120B0000120B0000000000000000
-            0000FFFFFFFFFFFFA5A5A5818181606060868686FFFFFFFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFBFBFB3B3B38080
-            80D5D5D5626262FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFFB2B2B2BDBDBDFFFFFFFFFFFFB2B2B2D5D5D55F5F5FFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF606060AEAEAEFFFFFFFFFFFF8787
-            87D5D5D5848484FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFF6060608181819F9F9F5F5F5F808080D6D6D68A8A8AFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6060606060608080809E9E9ED5D5
-            D5808080D7D7D7A2A2A2FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFF828282808080808080767676D5D5D5FFFFFFD5D5D58E8E8EFFFFFF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FF909090D6D6D6FFFFFFD5D5D59D9D9DFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF727272D5D5D5FFFFFFD5D5D5
-            808080818181606060767676FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFF818181D5D5D5818181D5D5D5D5D5D5D6D6D6D6D6D6A9A9A9FF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF606060D5D5D5
-            8181815F5F5FA9A9A98181818A8A8AFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFFFFFFFF6060609F9F9F7E7E7EFFFFFFFFFFFFA5A5A59F9F9FFF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF606060808080
-            B1B1B1FFFFFFFFFFFFC0C0C0CBCBCBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFFFFFFFF6060605F5F5F8080809F9F9FCBCBCBFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF626262
-            626262808080C2C2C2FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-            FFFF}
+            0000FEFEFFFEFEFF4CA4D92680C6105FB22A85C9FEFEFFFEFEFFFEFEFFFEFEFF
+            FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFF72BEE55FB2DF257F
+            C59AD4EE1161B3FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFE
+            FEFF5DB1DF6EBCE4FEFEFFFEFEFF5DB1DF9AD4EE105EB1FEFEFFFEFEFFFEFEFF
+            FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFF105FB258ADDDFEFEFFFEFEFF2B86
+            C99AD4EE2883C8FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFE
+            FEFF105FB22680C6449ED6105EB1257FC59CD5EF2E89CBFEFEFFFEFEFFFEFEFF
+            FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFF105FB2105FB2257FC5439DD59AD4
+            EE257FC59ED6EF48A1D7FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFE
+            FEFFFEFEFF2781C7257FC5257FC51D75C09AD4EEFEFEFF9AD4EE328DCDFEFEFF
+            FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFE
+            FF348FCE9CD5EFFEFEFF9AD4EE429CD5FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFE
+            FEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFF1B71BD9AD4EEFEFEFF9AD4EE
+            257FC52680C6105FB21D75C0FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFE
+            FFFEFEFFFEFEFF2680C69AD4EE2680C69AD4EE9AD4EE9CD5EF9CD5EF51A8DBFE
+            FEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFF105FB29AD4EE
+            2680C6105EB151A8DB2680C62E89CBFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFE
+            FFFEFEFFFEFEFFFEFEFF105FB2449ED6237DC4FEFEFFFEFEFF4CA4D9449ED6FE
+            FEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFF105FB2257FC5
+            5CB0DFFEFEFFFEFEFF73BFE587CAEAFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFE
+            FFFEFEFFFEFEFFFEFEFF105FB2105EB1257FC5449ED687CAEAFEFEFFFEFEFFFE
+            FEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFF1161B3
+            1161B3257FC577C1E6FEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFE
+            FFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFEFEFFFE
+            FEFF}
           Transparent = True
         end
         object Image2: TImage

Modified: trunk/Lobby/TASClient/HighlightingUnit.ddp
===================================================================
(Binary files differ)

Modified: trunk/Lobby/TASClient/HighlightingUnit.pas
===================================================================
--- trunk/Lobby/TASClient/HighlightingUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/HighlightingUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -6,7 +6,8 @@
   Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
   Dialogs, StdCtrls, CheckLst, JvExCheckLst, JvCheckListBox, Buttons,
   ExtCtrls, ComCtrls, StrUtils, JvExStdCtrls, JvCombobox, JvColorCombo,
-  TntCheckLst, SpTBXEditors, SpTBXControls, TBXDkPanels, SpTBXItem,TntComCtrls;
+  TntCheckLst, SpTBXEditors, SpTBXControls, TBXDkPanels, SpTBXItem,TntComCtrls,
+  RichEdit2, ExRichEdit;
 
 type
   THighlightingForm = class(TForm)
@@ -24,7 +25,7 @@
     JvColorComboBox1: TJvColorComboBox;
 
     procedure CreateParams(var Params: TCreateParams); override;
-    function CheckLastLineForHighlights(RichEdit: TTntRichEdit; ChatTextPos: Integer): Boolean;
+    function CheckLastLineForHighlights(RichEdit: TExRichEdit; ChatTextPos: Integer): Boolean;
     procedure CloseButtonClick(Sender: TObject);
     procedure SaveHighlightsToFile(FileName: string);
     procedure LoadHighlightsFromFile(FileName: string);
@@ -134,7 +135,7 @@
 // will highlight all keywords and automatically pop-up notifications (if set so).
 // Returns TRUE if any word has been highlighted.
 // For ChatTextPos argument, see Misc.AddTextToRichEdit's comments!
-function THighlightingForm.CheckLastLineForHighlights(RichEdit: TTntRichEdit; ChatTextPos: Integer): Boolean;
+function THighlightingForm.CheckLastLineForHighlights(RichEdit: TExRichEdit; ChatTextPos: Integer): Boolean;
 var
   i: Integer;
   sn, su: string; // string normal, string uppercase
@@ -230,7 +231,7 @@
 
     for i := 0 to High(Highlights) do
     begin
-      RichEdit.SelStart := Length(RichEdit.Text) - (Length(sn) - Highlights[i].X) - 3;
+      RichEdit.SelStart := Length(RichEdit.Text) - (Length(sn) - Highlights[i].X) - 1;
       RichEdit.SelLength := Highlights[i].Y - Highlights[i].X;
       RichEdit.SelAttributes.Color := HighlightingForm.JvColorComboBox1.Colors[Max(0, Misc.MapColorNameToIndex(Preferences.HighlightColor, HighlightingForm.JvColorComboBox1))];
       RichEdit.SelAttributes.Style := [fsUnderLine];

Modified: trunk/Lobby/TASClient/HostBattleFormUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/HostBattleFormUnit.dfm	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/HostBattleFormUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -1,6 +1,6 @@
 object HostBattleForm: THostBattleForm
-  Left = 813
-  Top = 311
+  Left = 289
+  Top = 106
   BorderStyle = bsDialog
   Caption = 'Host battle'
   ClientHeight = 355
@@ -230,7 +230,7 @@
       AutoSize = False
       Caption = 'Host'
       DropDownCombo = True
-      DropDownMenu = HostPopupMenu
+      DropDownMenu = MainForm.ClientPopupMenu
       SmartFocus = False
       TabOrder = 17
       OnClick = HostButtonClick

Modified: trunk/Lobby/TASClient/HostBattleFormUnit.pas
===================================================================
--- trunk/Lobby/TASClient/HostBattleFormUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/HostBattleFormUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -63,7 +63,7 @@
   private
     { Private declarations }
   public
-    { Public declarations }
+    replay: TReplay;
   end;
   TLadderListThread = class(TDialogThread)
   private
@@ -94,7 +94,7 @@
 
 uses WaitForAckUnit, BattleFormUnit, Utility, InitWaitFormUnit,
   DisableUnitsFormUnit, HostInfoUnit, Misc, PreferencesFormUnit,
-  ReplaysUnit, Math, TntWideStrings;
+  ReplaysUnit, Math, TntWideStrings, LobbyScriptUnit;
 
 {$R *.dfm}
 
@@ -322,7 +322,6 @@
 var
   i: Integer;
   s: WideString;
-  replay: TReplay;
 begin
   try
     i := StrToInt(PortEdit.Text);
@@ -362,7 +361,6 @@
   DisableUnitsForm.PopulateUnitList;
   // change map in battle window to the one used in this replay:
 
-  replay := ReplaysForm.GetReplayFromNode(ReplaysForm.VDTReplays.FocusedNode);
   if Utility.MapList.IndexOf(replay.Script.ReadKeyValue('GAME/mapname')) = -1 then // this can not really happen since we already checked if we have this map
   begin
     MessageDlg('You don''t have the map: ' + replay.Script.ReadKeyValue('GAME/mapname'), mtWarning, [mbOK], 0);
@@ -520,8 +518,6 @@
 end;
 
 procedure THostBattleForm.HostReplay1Click(Sender: TObject);
-var
-  replay: TReplay;
 begin
   ReplaysForm.WatchButton.Visible := False;
   ReplaysForm.HostReplayButton.Visible := True;
@@ -544,15 +540,18 @@
   Label8.Visible := True;
   PasswordEdit.Visible := True;
 
-  if ReplaysForm.ShowModal &lt;&gt; mrOK then
+  if not LobbyScriptUnit.ScriptHostingReplayRunning then
   begin
-    ReplaysForm.WatchButton.Visible := True;
-    ReplaysForm.HostReplayButton.Visible := False;
-    Exit;
+    if ReplaysForm.ShowModal &lt;&gt; mrOK then
+    begin
+      ReplaysForm.WatchButton.Visible := True;
+      ReplaysForm.HostReplayButton.Visible := False;
+      Exit;
+    end;
+
+    replay := ReplaysForm.GetReplayFromNode(ReplaysForm.VDTReplays.FocusedNode);
   end;
 
-  replay := ReplaysForm.GetReplayFromNode(ReplaysForm.VDTReplays.FocusedNode);
-
   if Utility.MapList.IndexOf(replay.Script.ReadKeyValue('GAME/mapname')) = -1 then
   begin
     MessageDlg('You don''t have the map: ' + replay.Script.ReadKeyValue('GAME/mapname'), mtWarning, [mbOK], 0);

Modified: trunk/Lobby/TASClient/HttpGetUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/HttpGetUnit.dfm	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/HttpGetUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -1,8 +1,8 @@
 object HttpGetForm: THttpGetForm
-  Left = 638
-  Top = 589
+  Left = 1298
+  Top = 727
   BorderStyle = bsDialog
-  Caption = 'File download'
+  Caption = 'File download 4'
   ClientHeight = 178
   ClientWidth = 281
   Color = clBtnFace

Modified: trunk/Lobby/TASClient/HttpGetUnit.pas
===================================================================
--- trunk/Lobby/TASClient/HttpGetUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/HttpGetUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -98,14 +98,13 @@
 
   ReceivedLabel.Visible := True;
 
-  if (DownloadFile.ServerOptions and $4) = 4 then
-  begin
-    HttpGetForm.SpTBXTitleBar1.Caption := 'Auto-updating lobby ...';
-  end
+  if (DownloadFile.ServerOptions and 4) = 4 then
+    HttpGetForm.Caption := 'Auto-updating lobby ...'
+  else if (DownloadFile.ServerOptions and 8) = 8 then
+    HttpGetForm.Caption := 'Downloading map ...'
   else
-    HttpGetForm.SpTBXTitleBar1.Caption := 'File download';
+    HttpGetForm.Caption := 'File download';
 
-  HttpGetForm.SpTBXTitleBar1.Refresh;
 
   if DownloadStatus.Downloading then Exit;
   UpdateReceivedStatus;
@@ -163,9 +162,8 @@
         if (DownloadFile.ServerOptions and $2) = 2 then MainForm.Close;
       end;
     end
-    else
-      if (DownloadFile.ServerOptions and $4) = 4 then
-      begin
+    else if (DownloadFile.ServerOptions and $4) = 4 then
+    begin
         StatusLabel.Caption := 'Download complete, extracting new files ...';
         ReceivedLabel.Visible := False;
         appExePath := Application.ExeName;
@@ -193,9 +191,14 @@
           else
             MessageDlg('Error '+IntToStr(e) + ','+IntToStr(SevenZip1.LastError), mtError, [mbOK], 0)
         end;
-      end
-      else
-        MessageDlg('Download complete!', mtInformation, [mbOK], 0);
+    end
+    else if (DownloadFile.ServerOptions and 8) = 8 then
+    begin
+      BattleForm.ReloadMapListButtonClick(nil);
+      HttpGetForm.Close;
+    end
+    else
+      MessageDlg('Download complete!', mtInformation, [mbOK], 0);
   end;
 
   Result := True;
@@ -233,7 +236,10 @@
 
 procedure THttpGetForm.OnStartDownloadMessage(var Msg: TMessage); // responds to WM_STARTDOWNLOAD message
 begin
-  HttpGetForm.ShowModal;
+  if (DownloadFile.ServerOptions and 4) = 4 then
+    HttpGetForm.ShowModal
+  else
+    HttpGetForm.Show;
 end;
 
 procedure THttpGetForm.OnStartDownloadMessage2(var Msg: TMessage); // responds to WM_STARTDOWNLOAD2 message

Added: trunk/Lobby/TASClient/LobbyComponents/ExRichEdit.pas
===================================================================
--- trunk/Lobby/TASClient/LobbyComponents/ExRichEdit.pas	                        (rev 0)
+++ trunk/Lobby/TASClient/LobbyComponents/ExRichEdit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,194 @@
+unit ExRichEdit;
+
+interface
+
+uses
+    Graphics, RichEdit2, RichEdit,
+    Windows, Messages, SysUtils, Classes, Controls, StdCtrls, ComCtrls;
+
+type
+  TRichEditURLClick = procedure (Sender: TObject; url: string) of object;
+
+  TExRichEdit = class(TRichEdit98)
+  private
+    { Private declarations }
+    _scrolling: boolean;
+    _at_bottom: boolean;
+    _one_page: boolean;
+  protected
+    { Protected declarations }
+    procedure CreateWnd; override;
+    procedure WMVScroll(var msg: TMessage); message WM_VSCROLL;
+    procedure CheckBottom();
+  public
+    { Public declarations }
+    procedure InsertBitmap(bmp: Graphics.TBitmap);
+    procedure InsertRTF(rtf: string);
+    procedure ScrollToBottom();
+    procedure ScrollToTop();
+    procedure ScrollPageUp();
+    procedure ScrollPageDown();
+  published
+    { Published declarations }
+    property atBottom: boolean read _at_bottom;
+    property isScrolling: boolean read _scrolling;
+  end;
+
+const
+    EN_LINK = $070b;
+
+function BitmapToRTF(pict: Graphics.TBitmap): string;
+procedure Register;
+
+implementation
+uses
+    ShellAPI;
+
+procedure TExRichEdit.CreateWnd;
+begin
+    inherited;
+    _scrolling := false;
+    _at_bottom := true;
+end;
+
+// pgm 3/3/02 - Adding stuff to the rich edit control
+// so that we can directly insert bitmaps
+procedure TExRichEdit.InsertBitmap(bmp: Graphics.TBitmap);
+var
+    s : TStringStream;
+begin
+    // Insert a bitmap into the control
+    s := TStringStream.Create(BitmapToRTF(bmp));
+    RTFSelText := s.DataString;
+    s.Free;
+end;
+
+procedure TExRichEdit.InsertRTF(rtf: string);
+begin
+    RTFSelText := rtf;
+end;
+
+procedure TExRichEdit.CheckBottom();
+var
+    si: TSCROLLINFO;
+begin
+    si.cbSize := SizeOf(TScrollInfo);
+    si.fMask := SIF_ALL;
+    GetScrollInfo(Handle, SB_VERT, si);
+    if (si.nMin = -1) then
+        _one_page := true
+    else
+        _one_page := false;
+
+    if (si.nMax = -1) then
+        _at_bottom := true
+    else
+        _at_bottom := ((si.nPos + integer(si.nPage)) &gt;= si.nMax);
+end;
+
+// pgm 3/16/04 - Let's catch the scroll event and set our state
+procedure TExRichEdit.WMVScroll(var msg: TMessage);
+begin
+    if (msg.WParamLo = SB_ENDSCROLL) then begin
+        _scrolling := false;
+        CheckBottom();
+    end
+    else
+        _scrolling := true;
+
+    inherited;
+end;
+
+procedure TExRichEdit.ScrollPageUp();
+begin
+    Perform(EM_SCROLL, SB_PAGEUP, 0);
+    CheckBottom();
+end;
+
+procedure TExRichEdit.ScrollPageDown();
+begin
+    Perform(EM_SCROLL, SB_PAGEDOWN, 0);
+    CheckBottom();
+end;
+
+procedure TExRichEdit.ScrollToTop();
+begin
+    Perform(EM_SCROLL, SB_TOP, 0);
+    CheckBottom();
+end;
+
+procedure TExRichEdit.ScrollToBottom();
+var
+    rect: TRect;
+    r: LongBool;
+    si: TSCROLLINFO;
+    i: integer;
+    dy, bl, lc: longint;
+begin
+    si.cbSize := SizeOf(TScrollInfo);
+    si.fMask := SIF_ALL;
+    r := GetScrollInfo(Handle, SB_VERT, si);
+
+    if ((r) and (si.nMax &gt; 0)) then begin
+        // Get the character which is closest to the lower-right corner
+        // of the rectangle.
+        Perform(EM_GETRECT, 0, Longint(@rect));
+        i := Perform(EM_CHARFROMPOS, 0, integer(@rect.BottomRight));
+
+        // Get the line index which holds that char.
+        bl := Perform(EM_EXLINEFROMCHAR, 0, i);
+        lc := Perform(EM_GETLINECOUNT, 0, 0);
+
+        // dy = line-count - bottom-line
+        dy := lc - bl;
+
+        // Move by dy.
+        Perform(EM_LINESCROLL, 0, dy);
+    end;
+
+    _at_bottom := true;
+end;
+
+
+procedure Register;
+begin
+  RegisterComponents('Exodus Components', [TExRichEdit]);
+end;
+
+function BitmapToRTF(pict: Graphics.TBitmap): string;
+var
+    bi, bb, rtf: string;
+    bis, bbs: Cardinal;
+    achar: ShortString;
+    hexpict: string;
+    i: Integer;
+begin
+    GetDIBSizes(pict.Handle, bis, bbs);
+    SetLength(bi,bis);
+    SetLength(bb,bbs);
+    GetDIB(pict.Handle, pict.Palette, PChar(bi)^, PChar(bb)^);
+    rtf := '{\rtf1 {\pict\dibitmap ';
+    SetLength(hexpict,(Length(bb) + Length(bi)) * 2);
+    i := 2;
+    for bis := 1 to Length(bi) do begin
+        achar := Format('%x',[Integer(bi[bis])]);
+        if Length(achar) = 1 then
+            achar := '0' + achar;
+        hexpict[i-1] := achar[1];
+        hexpict[i] := achar[2];
+        inc(i,2);
+    end;
+    for bbs := 1 to Length(bb) do begin
+        achar := Format('%x',[Integer(bb[bbs])]);
+        if Length(achar) = 1 then
+            achar := '0' + achar;
+        hexpict[i-1] := achar[1];
+        hexpict[i] := achar[2];
+        inc(i,2);
+    end;
+    rtf := rtf + hexpict + ' }}';
+    Result := rtf;
+end;
+
+
+end.

Added: trunk/Lobby/TASClient/LobbyComponents/Langs.pas
===================================================================
--- trunk/Lobby/TASClient/LobbyComponents/Langs.pas	                        (rev 0)
+++ trunk/Lobby/TASClient/LobbyComponents/Langs.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,120 @@
+unit Langs;
+
+interface
+
+uses
+  Windows, SysUtils, Graphics, Classes;
+
+type
+  TLanguage = 0..$FFFF;
+  TLangOption = (loLocalized, loEnglish, loNative, loAbbrev);
+
+function LanguageName(Language: TLanguage): String;
+function LanguageToIdent(Language: Longint; var Ident: string): Boolean;
+function CharSetFromLocale(Language: TLanguage): TFontCharSet;
+function CodePageFromLocale(Language: TLanguage): Integer;
+function OEMCodePageFromLocale(Language: TLanguage): Integer;
+function CharToWide(const S: String; CodePage: Word): WideString;
+function WideToChar(const WS: WideString; CodePage: Word): String;
+function CharToChar(const S: String; CP1, CP2: Word): String;
+function LengthEx(S: String; CP: Word): Integer;
+
+implementation
+
+{This is a proper declaration of TranslateCharsetInfo}
+function TranslateCharsetInfo(lpSrc: Pointer; var lpCs: TCharsetInfo; dwFlags: DWORD): BOOL; stdcall;
+external gdi32;
+
+function LengthEx(S: String; CP: Word): Integer;
+var
+  P: PChar;
+begin
+  Result:= 0;
+  P:= @S[1];
+  while (P^&lt;&gt;#0) do
+    begin
+      Inc(Result);
+      P:= CharNextEx(CP, P, 0);
+    end;
+end;
+
+function LanguageName(Language: TLanguage): String;
+var
+  Buf: array[0..255] of Char;
+begin
+  GetLocaleInfo(Language, LOCALE_SLanguage, Buf, 255);
+  Result:= StrPas(Buf);
+end;
+
+function CodePageFromLocale(Language: TLanguage): Integer;
+var
+  Buf: array[0..6] of Char;
+begin
+  GetLocaleInfo(Language, LOCALE_IDefaultAnsiCodePage, Buf, 6);
+  Result:= StrToIntDef(Buf, GetACP);
+end;
+
+function OEMCodePageFromLocale(Language: TLanguage): Integer;
+var
+  Buf: array[0..6] of Char;
+begin
+  GetLocaleInfo(Language, LOCALE_IDefaultCodePage, Buf, 6);
+  Result:= StrToIntDef(Buf, GetOEMCP);
+end;
+
+function CharSetFromLocale(Language: TLanguage): TFontCharSet;
+var
+  CP: Integer;
+  CSI: TCharsetInfo;
+begin
+  CP:= CodePageFromLocale(Language);
+  TranslateCharsetInfo(Pointer(CP), CSI, TCI_SRCCODEPAGE);
+  Result:= CSI.ciCharset;
+end;
+
+function CharToWide(const S: String; CodePage: Word): WideString;
+var
+  L: Integer;
+begin
+  if S='' then
+    Result:= ''
+  else
+    begin
+      L:= MultiByteToWideChar(CodePage, 0, PChar(@S[1]), -1, nil, 0);
+      SetLength(Result, L-1);
+      MultiByteToWideChar(CodePage, 0, PChar(@S[1]), -1, PWideChar(@Result[1]), L-1);
+   end;
+end;
+
+function WideToChar(const WS: WideString; CodePage: Word): String;
+var
+  L: Integer;
+begin
+  if WS='' then
+    Result:= ''
+  else
+    begin
+      L:= WideCharToMultiByte(CodePage, 0, @WS[1], -1, nil, 0, nil, nil);
+      SetLength(Result, L-1);
+      WideCharToMultiByte(CodePage, 0, @WS[1], -1, @Result[1], L-1, nil, nil);
+    end;
+end;
+
+function CharToChar(const S: String; CP1, CP2: Word): String;
+begin
+  Result:= WideToChar(CharToWide(S, CP1), CP2);
+end;
+
+function LanguageToIdent(Language: Longint; var Ident: string): Boolean;
+var
+  Buf: array[0..255]of Char;
+begin
+  Result:= IsValidLocale(Language, LCID_INSTALLED);
+  if Result then
+    begin
+      GetLocaleInfo(Language, LOCALE_SLANGUAGE, Buf, 255);
+      SetString(Ident, Buf, StrLen(Buf));
+    end;
+end;
+
+end.

Added: trunk/Lobby/TASClient/LobbyComponents/RichEdit2.pas
===================================================================
--- trunk/Lobby/TASClient/LobbyComponents/RichEdit2.pas	                        (rev 0)
+++ trunk/Lobby/TASClient/LobbyComponents/RichEdit2.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,5221 @@
+unit RichEdit2;
+
+{
+  RichEdit98 and DBRichEdit98 components for Delphi 3.0-4.0. version 1.40
+  Author Alexander Obukhov, Minsk, Belarus &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">alex at niiomr.belpak.minsk.by</A>&gt;
+
+  OLE support code written by
+    Greg Chapman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">glc at well.com</A>&gt;
+    Mike Lindre &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">MikeL at chemware.co.uk</A>&gt;
+    Tomasz Kustra &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">tom_kust at friko5.onet.pl</A>&gt;
+    Sigi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">medcom at tm.net.my</A>&gt;
+
+  Thanks to:
+    Oliver Matla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">wolfpack at eulink.net</A>&gt;
+    Glenn Benes &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">gjbenes at infocompii.com</A>&gt;
+    Sven Opitz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">S.Opitz at Cardy.de</A>&gt;
+    Jolios Lin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">jolios3 at mail.photin.com.tw</A>&gt;
+    Tom Wang &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">wangtao at netchina.com.cn</A>&gt;
+    Doron Tal &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">dorontal at netvision.net.il</A>&gt;
+    Alexander Halser &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">halser at easycash.co.at</A>&gt;
+    Arentjan Banck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">ajbanck at davilex.nl</A>&gt;
+    Andre Van Der Merwe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">dart at iafrica.com</A>&gt;
+    Iain Magee &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">iain at swiftsoft.net</A>&gt;
+    Sigi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">medcom at tm.net.my</A>&gt;
+    Rob Schoenaker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">rschoenaker at kraan.com</A>&gt;
+    Laszlo Kovacs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">kovacsl at westel900.net</A>&gt;
+}
+
+interface
+
+uses
+    Langs, WStrList,
+    Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
+    StdCtrls, ComCtrls, ComStrs, RichEdit,
+    {$ifdef BDE_SUPPORT}
+    DB, DBCtrls,
+    {$endif}
+    ActiveX,OleCtnrs,olectrls,ComObj,OleDlg,RichOle,Menus, Printers;
+
+const
+  FT_DOWNWARD = 1;
+  DataFormatCount = 2;
+
+var
+  CF_RTF: Cardinal = 0;
+  CF_RTFNOOBJS: Cardinal = 0;
+  CF_RETEXTOBJ: Cardinal = 0;
+
+type
+{ The declarations of TTextRangeA and TTextRangeW in Richedit.pas are incorrect}
+  TTextRangeA = record
+    chrg: TCharRange;
+    lpstrText: PAnsiChar; {not AnsiChar!}
+  end;
+
+  TTextRangeW = record
+    chrg: TCharRange;
+    lpstrText: PWideChar; {not WideChar!}
+  end;
+
+  TTextRange = TTextRangeA;
+
+  TInputFormat=(ifText, ifRTF, ifUnicode);
+  TOutputFormat=(ofText, ofRTF, ofRTFNoObjs, ofTextized, ofUnicode);
+
+  TSearchType98 = (stBackward, stWholeWord, stMatchCase);
+  TSearchTypes98 = set of TSearchType98;
+
+  TCustomRichEdit98 = class;
+
+  TConsistentAttribute98 = (caBold, caColor, caFace, caItalic,
+    caSize, caStrikeOut, caUnderline, caProtected, caWeight,
+    caBackColor, caLanguage, caIndexKind, caOffset, caSpacing,
+    caKerning, caULType, caAnimation, caSmallCaps, caAllCaps,
+    caHidden, caOutline, caShadow, caEmboss, caImprint, caURL);
+  TConsistentAttributes98 = set of TConsistentAttribute98;
+
+  TIndexKind = (ikNone, ikSubscript, ikSuperscript);
+
+  TUnderlineType = (ultNone, ultSingle, ultWord, ultDouble, ultDotted, ultWave,
+                    ultThick, ultHair, ultDashDD, ultDashD, ultDash);
+
+  TAnimationType = (aniNone, aniLasVegas, aniBlink, aniSparkle, aniBlackAnts,
+                    aniRedAnts, aniShimmer);
+
+  TRichEditOleCallback = class(TInterfacedObject, IRichEditOleCallback)
+  private
+    FOwner: TCustomRichEdit98;
+  protected
+        function GetNewStorage(out stg: IStorage): HRESULT; stdcall;
+    function GetInPlaceContext(out Frame: IOleInPlaceFrame;
+         out Doc: IOleInPlaceUIWindow; var FrameInfo: TOleInPlaceFrameInfo): HRESULT; stdcall;
+    function ShowContainerUI(fShow: BOOL): HRESULT; stdcall;
+    function QueryInsertObject(const clsid: TCLSID; stg: IStorage; cp: longint): HRESULT; stdcall;
+    function DeleteObject(oleobj: IOLEObject): HRESULT; stdcall;
+    function QueryAcceptData(dataobj: IDataObject; var cfFormat: TClipFormat;
+         reco: DWORD; fReally: BOOL; hMetaPict: HGLOBAL): HRESULT; stdcall;
+    function ContextSensitiveHelp(fEnterMode: BOOL): HRESULT; stdcall;
+    function GetClipboardData(const chrg: TCharRange; reco: DWORD;
+         out dataobj: IDataObject): HRESULT; stdcall;
+    function GetDragDropEffect(fDrag: BOOL; grfKeyState: DWORD;
+         var dwEffect: DWORD): HRESULT; stdcall;
+    function GetContextMenu(seltype: Word; oleobj: IOleObject;
+         const chrg: TCharRange; var menu: HMENU): HRESULT; stdcall;
+  public
+    constructor Create(AOwner: TCustomRichEdit98);
+  end;
+
+
+  TTextAttributes98 = class(TPersistent)
+  private
+    RichEdit: TCustomRichEdit98;
+    FType: TAttributeType;
+    FOldAttr: TTextattributes;
+    procedure GetAttributes(var Format: TCharFormat2W);
+    function GetConsistentAttributes: TConsistentAttributes98;
+    procedure SetAttributes(var Format: TCharFormat2W);
+  protected
+    procedure InitFormat(var Format: TCharFormat2W);
+    procedure AssignTo(Dest: TPersistent); override;
+    function GetColor: TColor;
+    procedure SetColor(Value: TColor);
+    function GetName: TFontName;
+    procedure SetName(Value: TFontName);
+    function GetPitch: TFontPitch;
+    procedure SetPitch(Value: TFontPitch);
+    function GetProtected: Boolean;
+    procedure SetProtected(Value: Boolean);
+    function GetSize: Integer;
+    procedure SetSize(Value: Integer);
+    function GetHeight: Integer;
+    procedure SetHeight(Value: Integer);
+    function GetWeight: Word;
+    procedure SetWeight(Value: Word);
+    function GetBackColor: TColor;
+    procedure SetBackColor(Value: TColor);
+    function GetLanguage: TLanguage;
+    procedure SetLanguage(Value: TLanguage);
+    function GetIndexKind: TIndexKind;
+    procedure SetIndexKind(Value: TIndexKind);
+    function GetOffset: Double;
+    procedure SetOffset(Value: Double);
+    function GetSpacing: Double;
+    procedure SetSpacing(Value: Double);
+    function GetKerning: Double;
+    procedure SetKerning(Value: Double);
+    function GetUnderlineType: TUnderlineType;
+    procedure SetUnderlineType(Value: TUnderlineType);
+    function GetAnimation: TAnimationType;
+    procedure SetAnimation(Value: TAnimationType);
+    function GetBold: Boolean;
+    procedure SetBold(Value: Boolean);
+    function GetItalic: Boolean;
+    procedure SetItalic(Value: Boolean);
+    function GetStrikeOut: Boolean;
+    procedure SetStrikeOut(Value: Boolean);
+    function GetSmallCaps: Boolean;
+    procedure SetSmallCaps(Value: Boolean);
+    function GetAllCaps: Boolean;
+    procedure SetAllCaps(Value: Boolean);
+    function GetHidden: Boolean;
+    procedure SetHidden(Value: Boolean);
+    function GetOutline: Boolean;
+    procedure SetOutline(Value: Boolean);
+    function GetShadow: Boolean;
+    procedure SetShadow(Value: Boolean);
+    function GetEmboss: Boolean;
+    procedure SetEmboss(Value: Boolean);
+    function GetImprint: Boolean;
+    procedure SetImprint(Value: Boolean);
+    function GetStyle: TFontStyles;
+    procedure SetStyle(Value: TFontStyles);
+    function GetIsURL: Boolean;
+    procedure SetIsURL(Value: Boolean);
+  public
+    constructor Create(AOwner: TCustomRichEdit98; AttributeType: TAttributeType);
+    procedure Assign(Source: TPersistent); override;
+    property ConsistentAttributes: TConsistentAttributes98 read GetConsistentAttributes;
+    property Color: TColor read GetColor write SetColor;
+    property Name: TFontName read GetName write SetName;
+    property Pitch: TFontPitch read GetPitch write SetPitch;
+    property Protected: Boolean read GetProtected write SetProtected;
+    property Size: Integer read GetSize write SetSize;
+    property Height: Integer read GetHeight write SetHeight;
+    property Weight: Word read GetWeight write SetWeight;
+    property BackColor: TColor read GetBackColor write SetBackColor;
+    property Language: TLanguage read GetLanguage write SetLanguage;
+    property IndexKind: TIndexKind read GetIndexKind write SetIndexKind;
+    property Offset: Double read GetOffset write SetOffset;
+    property Spacing: Double read GetSpacing write SetSpacing;
+    property Kerning: Double read GetKerning write SetKerning;
+    property UnderlineType: TUnderlineType read GetUnderlineType write SetUnderlineType;
+    property Animation: TAnimationType read GetAnimation write SetAnimation;
+    property Bold: Boolean read GetBold write SetBold;
+    property Italic: Boolean read GetItalic write SetItalic;
+    property StrikeOut: Boolean read GetStrikeOut write SetStrikeOut;
+    property SmallCaps: Boolean read GetSmallCaps write SetSmallCaps;
+    property AllCaps: Boolean read GetAllCaps write SetAllCaps;
+    property Hidden: Boolean read GetHidden write SetHidden;
+    property Outline: Boolean read GetOutline write SetOutline;
+    property Shadow: Boolean read GetShadow write SetShadow;
+    property Emboss: Boolean read GetEmboss write SetEmboss;
+    property Imprint: Boolean read GetImprint write SetImprint;
+    property Style: TFontStyles read GetStyle write SetStyle;
+    property IsURL: Boolean read GetIsURL write SetIsURL;
+  end;
+
+  TLineSpacingRule = (lsrOrdinary, lsr15, lsrDouble, lsrAtLeast, lsrExactly,
+                      lsrMultiple);
+
+  TAlignment98 = (taLeft, taRight, taCenter, taJustify);
+
+  TNumberingStyle98 = (nsNone, nsBullet, nsNumber, nsLowerCase, nsUpperCase,
+                       nsLowerRoman, nsUpperRoman, nsSequence);
+
+  TNumberingFollow = (nfParenthesis, nfPeriod, nfEncloseParenthesis);
+
+  TBorderLocation = (blLeft, blRight, blTop, blBottom, blInside, blOutside);
+  TBorderLocations = set of TBorderLocation;
+
+  TBorderStyle = (bsNone, bs15, bs30, bs45, bs60, bs90, bs120, bs15Dbl,
+                  bs30Dbl, bs45Dbl, bs15Gray, bs15GrayDashed);
+
+  TShadingWeight = 0..100;
+
+  TShadingStyle = (shsNone, shsDarkHorizontal, shsDarkVertical, shsDarkDownDiagonal,
+                   shsDarkUpDiagonal, shsDarkGrid, shsDarkTrellis, shsLightHorizontal,
+                   shsLightVertical, shsLightDownDiagonal, shsLightUpDiagonal,
+                   shsLightGrid, shsLightTrellis);
+
+  TTabAlignment = (tbaLeft, tbaCenter, tbaRight, tbaDecimal, tbaWordBar);
+
+  TTabLeader = (tblNone, tblDotted, tblDashed, tblUnderlined, tblThick, tblDouble);
+
+  TParaAttributes98 = class(TParaAttributes)
+  private
+    RichEdit: TCustomRichEdit98;
+    procedure GetAttributes(var Paragraph: TParaFormat2);
+    procedure InitPara(var Paragraph: TParaFormat2);
+    procedure SetAttributes(var Paragraph: TParaFormat2);
+    function GetFirstIndent: Double;
+    procedure SetFirstIndent(Value: Double);
+    function GetLeftIndent: Double;
+    procedure SetLeftIndent(Value: Double);
+    function GetRightIndent: Double;
+    procedure SetRightIndent(Value: Double);
+    function GetSpaceBefore: Double;
+    procedure SetSpaceBefore(Value: Double);
+    function GetSpaceAfter: Double;
+    procedure SetSpaceAfter(Value: Double);
+    function GetLineSpacing: Double;
+    function GetLineSpacingRule: TLineSpacingRule;
+    function GetKeepTogether: Boolean;
+    procedure SetKeepTogether(Value: Boolean);
+    function GetKeepWithNext: Boolean;
+    procedure SetKeepWithNext(Value: Boolean);
+    function GetPageBreakBefore: Boolean;
+    procedure SetPageBreakBefore(Value: Boolean);
+    function GetNoLineNumber: Boolean;
+    procedure SetNoLineNumber(Value: Boolean);
+    function GetNoWidowControl: Boolean;
+    procedure SetNoWidowControl(Value: Boolean);
+    function GetDoNotHyphen: Boolean;
+    procedure SetDoNotHyphen(Value: Boolean);
+    function GetSideBySide: Boolean;
+    procedure SetSideBySide(Value: Boolean);
+    function GetAlignment: TAlignment98;
+    procedure SetAlignment(Value: TAlignment98);
+    function GetNumbering: TNumberingStyle98;
+    procedure SetNumbering(Value: TNumberingStyle98);
+    function GetNumberingStart: Word;
+    procedure SetNumberingStart(Value: Word);
+    function GetNumberingFollow: TNumberingFollow;
+    procedure SetNumberingFollow(Value: TNumberingFollow);
+    function GetNumberingTab: Double;
+    procedure SetNumberingTab(Value: Double);
+    function GetBorderSpace: Double;
+    function GetBorderWidth: Double;
+    function GetBorderLocations: TBorderLocations;
+    function GetBorderStyle: TBorderStyle;
+    function GetBorderColor: TColor;
+    function GetShadingWeight: TShadingWeight;
+    function GetShadingStyle: TShadingStyle;
+    function GetShadingColor: TColor;
+    function GetShadingBackColor: TColor;
+    function GetTabCount: Integer;
+    function GetTab(Index: Integer): Double;
+    function GetTabAlignment(Index: Integer): TTabAlignment;
+    function GetTabLeader(Index: Integer): TTabLeader;
+  public
+    constructor Create(AOwner: TCustomRichEdit98);
+    property Alignment: TAlignment98 read GetAlignment write SetAlignment;
+    property FirstIndent: Double read GetFirstIndent write SetFirstIndent;
+    property LeftIndent: Double read GetLeftIndent write SetLeftIndent;
+    property RightIndent: Double read GetRightIndent write SetRightIndent;
+    property SpaceBefore: Double read GetSpaceBefore write SetSpaceBefore;
+    property SpaceAfter: Double read GetSpaceAfter write SetSpaceAfter;
+    procedure SetLineSpacing(Rule: TLineSpacingRule; Value: Double);
+    property LineSpacing: Double read GetLineSpacing;
+    property LineSpacingRule: TLineSpacingRule read GetLineSpacingRule;
+    property KeepTogether: Boolean read GetKeepTogether write SetKeepTogether;
+    property KeepWithNext: Boolean read GetKeepWithNext write SetKeepWithNext;
+    property PageBreakBefore: Boolean read GetPageBreakBefore write SetPageBreakBefore;
+    property NoLineNumber: Boolean read GetNoLineNumber write SetNoLineNumber;
+    property NoWidowControl: Boolean read GetNoWidowControl write SetNoWidowControl;
+    property DoNotHyphen: Boolean read GetDoNotHyphen write SetDoNotHyphen;
+    property SideBySide: Boolean read GetSideBySide write SetSideBySide;
+    property Numbering: TNumberingStyle98 read GetNumbering write SetNumbering;
+    property NumberingStart: Word read GetNumberingStart write SetNumberingStart;
+    property NumberingFollow: TNumberingFollow read GetNumberingFollow write SetNumberingFollow;
+    property NumberingTab: Double read GetNumberingTab write SetNumberingTab;
+    property BorderSpace: Double read GetBorderSpace;
+    property BorderWidth: Double read GetBorderWidth;
+    property BorderLocations: TBorderLocations read GetBorderLocations;
+    property BorderStyle: TBorderStyle read GetBorderStyle;
+    property BorderColor: TColor read GetBorderColor;
+    procedure SetBorder(Space, Width: Double; Locations: TBorderLocations;
+                        Style: TBorderStyle; Color: TColor);
+    property ShadingWeight: TShadingWeight read GetShadingWeight;
+    property ShadingStyle: TShadingStyle read GetShadingStyle;
+    property ShadingColor: TColor read GetShadingColor;
+    property ShadingBackColor: TColor read GetShadingBackColor;
+    procedure SetShading(Weight: TShadingWeight; Style: TShadingStyle;
+                         Color, BackColor: TColor);
+    property TabCount: Integer read GetTabCount;
+    property Tab[Index: Integer]: Double read GetTab;
+    property TabAlignment[Index: Integer]: TTabAlignment read GetTabAlignment;
+    property TabLeader[Index: Integer]: TTabLeader read GetTabLeader;
+    procedure SetTab(Index: Integer; Value: Double; Alignment: TTabAlignment;
+                     Leader: TTabLeader);
+  end;
+
+  TURLClickEvent = procedure(Sender: TObject; URL: String) of object;
+  TURLMoveEvent = procedure(Sender: TObject; URL: String) of object;
+  TRichEditProgressEvent = procedure(Sender: TObject; Pos, Size: Integer) of object;
+
+  TUndoName = (unUnknown, unTyping, unDelete, unDragDrop, unCut, unPaste);
+
+  TLangOption = (loAutoKeyboard, loAutoFont, loIMECancelComplete, loIMEAlwaysSendNotify);
+  TLangOptions = set of TLangOption;
+
+  TSelType = (stText, stObject, stMultiChar, stMultiObject);
+  TSelectionType = set of TSelType;
+
+  TAutoURLDetect = (adNone, adDefault, adExtended);
+
+  TURLType = class(TCollectionItem)
+  private
+    FName: String;
+    FColor: TColor;
+    FCursor: Tcursor;
+    FUnderline: Boolean;
+  protected
+    function GetDisplayName: string; override;
+  public
+    procedure Assign(Source: TPersistent); override;
+  published
+    property Name: String read FName write FName;
+    property Color: TColor read FColor write FColor;
+    property Cursor: TCursor read FCursor write FCursor;
+    property Underline: Boolean read FUnderline write FUnderline;
+  end;
+
+  {$WARNINGS OFF}
+  TURLCollection = class(TCollection)
+  private
+    FOwner: TCustomRichEdit98;
+  protected
+    function GetOwner: TPersistent; override;
+    procedure SetItems(Index: Integer; Value: TURLType);
+    function GetItems(Index: Integer): TURLType;
+  public
+    procedure AddURLType(const Name: String; Color: TColor;
+                         Cursor: TCursor; Underline: Boolean);
+    property Owner: TCustomRichEdit98 read FOwner;
+    property Items[Index: Integer]: TURLType read GetItems write SetItems; default;
+  end;
+  {$WARNINGS ON}
+
+  TCustomRichEdit98 = class(TCustomRichEdit)
+  private
+    { Private declarations }
+    FUpdateCount: Integer;
+    FLibHandle: THandle;
+    FSelAttributes: TTextAttributes98;
+    FDefAttributes: TTextAttributes98;
+    FParagraph: TParaAttributes98;
+    FRichEditStrings: TStrings;
+    FWideStrings: TWideStrings;
+    FScreenLogPixels: Integer;
+    FAutoURLDetect: TAutoURLDetect;
+    FShowSelBar: Boolean;
+    FOnURLClick: TURLClickEvent;
+    FOnURLMove: TURLMoveEvent;
+    FOnSaveProgress: TRichEditProgressEvent;
+    FOnLoadProgress: TRichEditProgressEvent;
+    FURLColor: TColor;
+    FURLCursor: TCursor;
+    FLanguage: TLanguage;
+    FCP: Word;
+    FWide: Boolean;
+    FStreamSel: Boolean;
+    FStoreSS,
+    FStoreSL,
+    FStoreFVL: Integer;
+    FCROld: TCharRange;
+    FVer10: Boolean;
+//    FPlainText: Boolean;
+    FLangOptions: TLangOptions;
+    FDefWndProcW: TFNWndProc;
+    FDefWndProcA: TFNWndProc;
+    FURLs: TURLCollection;
+    FWordFormatting: Boolean;
+    FUndoLimit: Integer;
+
+    FPlainTextIn: TInputFormat;
+    FPlainTextOut: TOutputFormat;
+    FSelectedInOut: Boolean;
+    FPlainRTF: Boolean;
+
+    FPopupVerbMenu: TPopupMenu;
+    FAutoVerbMenu: Boolean;
+    FObjectVerbs: TStringList;
+    FSelObject: IOleObject;
+    FDrawAspect: Longint;
+    FViewSize: TPoint;
+    FIncludeOLE:Boolean;
+    FAllowInPlace: Boolean;
+    procedure DestroyVerbs;
+    procedure UpdateVerbs;
+    procedure PopupVerbMenuClick(Sender: TObject);
+    procedure DoVerb(Verb: Integer);
+    function GetCanPaste: Boolean;
+
+    procedure UpdateObject;
+    procedure UpdateView;
+    procedure SetIncludeOLE(Value:Boolean);
+    function GetIconMetaPict: HGlobal;
+    procedure CheckObject;
+    procedure SetDrawAspect(Iconic: Boolean; IconMetaPict: HGlobal);
+    property AllowInPlace: Boolean read FAllowInPlace write FAllowInPlace default True;
+
+    procedure SetDefAttributes(Value: TTextAttributes98);
+    procedure SetSelAttributes(Value: TTextAttributes98);
+    procedure SetShowSelBar(Value: Boolean);
+    procedure SetRichEditStrings(Value: TStrings);
+    procedure CNNotify(var Message: TWMNotify); message CN_NOTIFY;
+    procedure CNCommand(var Message: TWMCommand); message CN_COMMAND;
+    procedure WMDestroy(var Msg: TMessage); message WM_DESTROY;
+    function PrivatePerform(Msg: Cardinal; WParam, LParam: Longint): Longint;
+
+    procedure FindNonSpace(var CR: TCharRange);
+    procedure DetectURLs(CR: TCharRange);
+  protected
+    { Protected declarations }
+    procedure CreateWnd; override;
+    procedure CreateParams(var Params: TCreateParams); override;
+    procedure DefineProperties(Filer: TFiler); override;
+    procedure WMNCDestroy(var Message: TWMNCDestroy); message WM_NCDESTROY;
+    procedure WMSetText(var Message: TWMSetText); message WM_SETTEXT;
+    procedure WMGetText(var Message: TWMGetText); message WM_GETTEXT;
+    procedure WMGetTextLength(var Message: TWMGetTextLength); message WM_GETTEXTLENGTH;
+    procedure WMSetFont(var Message: TWMSetFont); message WM_SETFONT;
+    procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
+    procedure EMReplaceSel(var Message: TMessage); message EM_REPLACESEL;
+    procedure EMGetSelText(var Message: TMessage); message EM_GETSELTEXT;
+    procedure EMGetTextRange(var Message: TMessage); message EM_GETTEXTRANGE;
+    procedure EMGetLine(var Message: TMessage); message EM_GETLINE;
+    procedure EMStreamIn(var Message: TMessage); message EM_STREAMIN;
+    procedure EMStreamOut(var Message: TMessage); message EM_STREAMOUT;
+    procedure WMPaint(var Message: TWMPaint); message WM_PAINT;
+    procedure DoSetMaxLength(Value: Integer); override;
+    function GetLine: Integer;
+    procedure SetLine(Value: Integer);
+    function GetColumn: Integer;
+    procedure SetColumn(Value: Integer);
+    procedure SetAutoURLDetect(Value: TAutoURLDetect);
+    function GetFirstVisibleLine: Integer;
+    property Lines: TStrings read FRichEditStrings write SetRichEditStrings;
+    procedure ReadData(Reader: TReader);
+    procedure WriteData(Writer: TWriter);
+    function GetWideText: WideString;
+    procedure SetWideText(Value: WideString);
+    procedure SetLanguage(Value: TLanguage);
+    function GetWideSelText: WideString;
+    procedure SetWideSelText(Value: WideString);
+    property OnURLClick: TURLClickEvent read FOnURLClick write FOnURLClick;
+    property OnURLMove: TURLMoveEvent read FOnURLMove write FOnURLMove;
+    property OnSaveProgress: TRichEditProgressEvent read FOnSaveProgress write FOnSaveProgress;
+    property OnLoadProgress: TRichEditProgressEvent read FOnLoadProgress write FOnLoadProgress;
+    procedure CreateWindowHandle(const Params: TCreateParams); override;
+    procedure SetLangOptions(Value: TLangOptions);
+    procedure SetCustomURLs(Value: TURLCollection);
+    procedure CloseOLEObjects;
+    procedure CreateOLEObjectInterface;
+    function GetPopupMenu: TPopupMenu; override;
+    procedure SetRTFSelText(Value: String);
+    function GetRTFSelText: String;
+    function GetSelType: TSelectionType;
+    procedure SetUndoLimit(Value: Integer);
+  public
+    { Public declarations }
+    RichEditOle: IRichEditOle;
+    RichEditOleCallback: IRichEditOleCallback;
+    constructor Create(AOwner: TComponent); override;
+    destructor Destroy; override;
+
+    function ObjectSelected:Boolean;
+    procedure Clear; override;
+    procedure CreateLinkToFile(const FileName: string; Iconic: Boolean);
+    procedure CreateObject(const OleClassName: string; Iconic: Boolean);
+    procedure CreateObjectFromFile(const FileName: string; Iconic: Boolean);
+    procedure CreateObjectFromInfo(const CreateInfo: TCreateInfo);
+    procedure InsertObjectDialog;
+    function PasteSpecialDialog: Boolean;
+    function ChangeIconDialog: Boolean;
+    property AutoVerbMenu: boolean read FAutoVerbMenu write FAutoVerbMenu default true;
+    property InputFormat: TInputFormat read FPlainTextIn write FPlainTextIn;
+    property OutputFormat: TOutputFormat read FPlainTextOut write FPlainTextOut;
+    property SelectedInOut: Boolean read FSelectedInOut write FSelectedInOut;
+    property PlainRTF: Boolean read FPlainRTF write FPlainRTF;
+
+    // pgm 8/29/04 - Move these to public API
+    procedure BeginUpdate;
+    procedure EndUpdate;
+
+    procedure InsertFromFile(const FileName: String);
+    property Line: Integer read GetLine write SetLine;
+    property Col: Integer read GetColumn write SetColumn;
+    procedure SetCaret(Line, Column: Integer);
+    property DefAttributes: TTextAttributes98 read FDefAttributes write SetDefAttributes;
+    property SelAttributes: TTextAttributes98 read FSelAttributes write SetSelAttributes;
+    property Paragraph: TParaAttributes98 read FParagraph;
+    property ShowSelectionBar: Boolean read FShowSelBar write SetShowSelBar;
+    property WordFormatting: Boolean read FWordFormatting write FWordFormatting default True;
+    function FindText(const SearchStr: string;
+      StartPos, Length: Integer; Options: TSearchTypes98): Integer;
+    function FindWideText(const SearchStr: WideString;
+      StartPos, Length: Integer; Options: TSearchTypes98): Integer;
+    function CanUndo: Boolean;
+    procedure Undo;
+    function UndoName: TUndoName;
+    function CanRedo: Boolean;
+    procedure Redo;
+    function RedoName: TUndoName;
+    procedure StopGroupTyping;
+    property AutoURLDetect: TAutoURLDetect read FAutoURLDetect write SetAutoURLDetect;
+    property FirstVisibleLine: Integer read GetFirstVisibleLine;
+    function GetWordAtPos(Pos: Integer; var Start, Len: Integer): String;
+    property RTFSelText: String read GetRTFSelText write SetRTFSelText;
+    property WideText: WideString read GetWideText write SetWideText;
+    property Language: TLanguage read FLanguage write SetLanguage;
+    property LangOptions: TLangOptions read FLangOptions write SetLangOptions;
+    property WideLines: TWideStrings read FWideStrings stored False;
+    property WideSelText: WideString read GetWideSelText write SetWideSelText;
+    property CustomURLs: TURLCollection read FURLs write SetCustomURLs;
+    function CharAtPos(Pos: TPoint): Integer;
+    property IncludeOLE: Boolean read FIncludeOLE write SetIncludeOLE default False;
+    property CanPaste: Boolean read GetCanPaste;
+    property URLColor : TColor read FURLColor write FURLColor;
+    property URLCursor : TCursor read FURLCursor write FURLCursor;
+    property SelType: TSelectionType read GetSelType;
+    property UndoLimit: Integer read FUndoLimit write SetUndoLimit;
+  end;
+
+  TRichEdit98 = class(TCustomRichEdit98)
+  published
+    { Published declarations }
+    property Align;
+    property Alignment;
+    property AutoURLDetect;
+    property BorderStyle;
+    property Color;
+    property Ctl3D;
+    property CustomURLs;
+    property DragCursor;
+    property DragMode;
+    property Enabled;
+    property Font;
+    property HideSelection;
+    property HideScrollBars;
+    property ImeMode;
+    property ImeName;
+    property LangOptions;
+    property Language;
+    property Lines stored False;
+    property MaxLength;
+    property ParentColor;
+    property ParentCtl3D;
+    property ParentFont;
+    property ParentShowHint;
+//    property PlainText;
+    property PopupMenu;
+    property ReadOnly;
+    property ScrollBars;
+    property ShowHint;
+    property ShowSelectionBar;
+    property TabOrder;
+    property TabStop default True;
+    property URLColor;
+    property URLCursor;
+    property Visible;
+    property WantTabs;
+    property WantReturns;
+    property WordFormatting;
+    property WordWrap;
+    property OnChange;
+    property OnDblClick;
+    property OnDragDrop;
+    property OnDragOver;
+    property OnEndDrag;
+    property OnEnter;
+    property OnExit;
+    property OnKeyDown;
+    property OnKeyPress;
+    property OnKeyUp;
+    property OnLoadProgress;
+    property OnMouseDown;
+    property OnMouseMove;
+    property OnMouseUp;
+    property OnResizeRequest;
+    property OnSelectionChange;
+    property OnSaveProgress;
+    property OnStartDrag;
+    property OnProtectChange;
+    property OnSaveClipboard;
+    property OnURLClick;
+    property OnURLMove;
+    property AutoVerbMenu;
+    property InputFormat;
+    property OutputFormat;
+    property SelectedInOut;
+    property PlainRTF;
+    property UndoLimit;
+
+    property IncludeOLE;
+    property AllowInPlace;
+
+{$IFDEF VER120}
+    property Anchors;
+    property BiDiMode;
+    property BorderWidth;
+    property Constraints;
+    property DragKind;
+    property ParentBiDiMode;
+{$ENDIF}
+  end;
+
+{$ifdef BDE_SUPPORT}
+  TDBRichEdit98 = class(TCustomRichEdit98)
+  private
+    FDataLink: TFieldDataLink;
+    FAutoDisplay: Boolean;
+    FFocused: Boolean;
+    FMemoLoaded: Boolean;
+    FDataSave: string;
+    procedure BeginEditing;
+    procedure DataChange(Sender: TObject);
+    procedure EditingChange(Sender: TObject);
+    function GetDataField: string;
+    function GetDataSource: TDataSource;
+    function GetField: TField;
+    function GetReadOnly: Boolean;
+    procedure SetDataField(const Value: string);
+    procedure SetDataSource(Value: TDataSource);
+    procedure SetReadOnly(Value: Boolean);
+    procedure SetAutoDisplay(Value: Boolean);
+    procedure SetFocused(Value: Boolean);
+    procedure UpdateData(Sender: TObject);
+    procedure WMCut(var Message: TMessage); message WM_CUT;
+    procedure WMPaste(var Message: TMessage); message WM_PASTE;
+    procedure CMEnter(var Message: TCMEnter); message CM_ENTER;
+    procedure CMExit(var Message: TCMExit); message CM_EXIT;
+    procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
+    procedure CMGetDataLink(var Message: TMessage); message CM_GETDATALINK;
+  protected
+    procedure DefineProperties(Filer: TFiler); override;
+    procedure Change; override;
+    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
+    procedure KeyPress(var Key: Char); override;
+    procedure Loaded; override;
+    procedure Notification(AComponent: TComponent;
+      Operation: TOperation); override;
+  public
+    constructor Create(AOwner: TComponent); override;
+    destructor Destroy; override;
+    procedure LoadMemo;
+    property Field: TField read GetField;
+  published
+    property Align;
+    property Alignment;
+    property AutoDisplay: Boolean read FAutoDisplay write SetAutoDisplay default True;
+    property AutoURLDetect;
+    property BorderStyle;
+    property Color;
+    property Ctl3D;
+    property CustomURLs;
+    property DataField: string read GetDataField write SetDataField;
+    property DataSource: TDataSource read GetDataSource write SetDataSource;
+    property DragCursor;
+    property DragMode;
+    property Enabled;
+    property Font;
+    property HideSelection;
+    property HideScrollBars;
+    property ImeMode;
+    property ImeName;
+    property Language;
+    property LangOptions;
+    property MaxLength;
+    property ParentColor;
+    property ParentCtl3D;
+    property ParentFont;
+    property ParentShowHint;
+//    property PlainText;
+    property PopupMenu;
+    property ReadOnly: Boolean read GetReadOnly write SetReadOnly default False;
+    property ScrollBars;
+    property ShowHint;
+    property ShowSelectionBar;
+    property TabOrder;
+    property TabStop;
+    property Visible;
+    property WantReturns;
+    property WantTabs;
+    property WordFormatting;
+    property WordWrap;
+    property OnChange;
+    property OnClick;
+    property OnDblClick;
+    property OnDragDrop;
+    property OnDragOver;
+    property OnEndDrag;
+    property OnEnter;
+    property OnExit;
+    property OnKeyDown;
+    property OnKeyPress;
+    property OnKeyUp;
+    property OnLoadProgress;
+    property OnMouseDown;
+    property OnMouseMove;
+    property OnMouseUp;
+    property OnResizeRequest;
+    property OnSaveProgress;
+    property OnSelectionChange;
+    property OnProtectChange;
+    property OnSaveClipboard;
+    property OnStartDrag;
+    property OnURLClick;
+    property AutoVerbMenu;
+    property InputFormat;
+    property OutputFormat;
+    property SelectedInOut;
+    property PlainRTF;
+    property UndoLimit;
+
+    property IncludeOLE;
+    property AllowInPlace;
+
+{$IFDEF VER120}
+    property Anchors;
+    property BiDiMode;
+    property BorderWidth;
+    property Constraints;
+    property DragKind;
+    property ParentBiDiMode;
+{$ENDIF}
+  end;
+
+{$endif}
+
+const
+  RTFConversionFormat: TConversionFormat = (
+    ConversionClass: TConversion;
+    Extension: 'rtf';
+    Next: nil);
+  TextConversionFormat: TConversionFormat = (
+    ConversionClass: TConversion;
+    Extension: 'txt';
+    Next: @RTFConversionFormat);
+
+var
+  ConversionFormatList: PConversionFormat = @TextConversionFormat;
+
+procedure Register;
+
+implementation
+
+uses
+  TypInfo;
+
+var
+  PixPerInch: TPoint;
+  CFEmbeddedObject: Integer;
+  CFLinkSource: Integer;
+
+function PixelsToHimetric(const P: TPoint): TPoint;
+begin
+  Result.X := MulDiv(P.X, 2540, PixPerInch.X);
+  Result.Y := MulDiv(P.Y, 2540, PixPerInch.Y);
+end;
+
+procedure CenterWindow(Wnd: HWnd);
+var
+  Rect: TRect;
+begin
+  GetWindowRect(Wnd, Rect);
+  SetWindowPos(Wnd, 0,
+    (GetSystemMetrics(SM_CXSCREEN) - Rect.Right + Rect.Left) div 2,
+    (GetSystemMetrics(SM_CYSCREEN) - Rect.Bottom + Rect.Top) div 3,
+    0, 0, SWP_NOACTIVATE or SWP_NOSIZE or SWP_NOZORDER);
+end;
+
+function OleDialogHook(Wnd: HWnd; Msg, WParam, LParam: Longint): Longint; stdcall;
+begin
+  Result := 0;
+  if Msg = WM_INITDIALOG then
+  begin
+    if GetWindowLong(Wnd, GWL_STYLE) and WS_CHILD &lt;&gt; 0 then
+      Wnd := GetWindowLong(Wnd, GWL_HWNDPARENT);
+    CenterWindow(Wnd);
+    Result := 1;
+  end;
+end;
+
+function GetVCLFrameForm(Form: TCustomForm): IVCLFrameForm;
+begin
+  if Form.OleFormObject = nil then TOleForm.Create(Form);
+  Result := Form.OleFormObject as IVCLFrameForm;
+end;
+
+
+
+procedure Register;
+begin
+  RegisterComponents('Win32', [TRichEdit98]);
+{$ifdef BDE_SUPPORT}
+  RegisterComponents('Data Controls', [TDBRichEdit98]);
+{$endif}
+end;
+
+var
+  IsWinNT: Boolean;
+
+
+{ TTextAttributes98}
+
+constructor TTextAttributes98.Create(AOwner: TCustomRichEdit98;
+  AttributeType: TAttributeType);
+begin
+  inherited Create;
+  RichEdit := AOwner;
+  FType := AttributeType;
+  if RichEdit.FVer10 then
+    case FType of
+    atSelected:
+      FOldAttr:= TRichEdit(Richedit).SelAttributes;
+    atDefaultText:
+      FOldAttr:= TRichEdit(Richedit).DefAttributes;
+    end;
+end;
+
+procedure TTextAttributes98.InitFormat(var Format: TCharFormat2W);
+begin
+  FillChar(Format, SizeOf(TCharFormat2W), 0);
+  Format.cbSize := SizeOf(TCharFormat2W);
+end;
+
+function TTextAttributes98.GetConsistentAttributes: TConsistentAttributes98;
+var
+  Format: TCharFormat2W;
+begin
+  Result := [];
+  if RichEdit.HandleAllocated and (FType = atSelected) then
+  begin
+    InitFormat(Format);
+    RichEdit.Perform(EM_GETCHARFORMAT,
+      WPARAM(FType = atSelected), LPARAM(@Format));
+    with Format do
+    begin
+      if (dwMask and CFM_BOLD) &lt;&gt; 0 then Include(Result, caBold);
+      if (dwMask and CFM_COLOR) &lt;&gt; 0 then Include(Result, caColor);
+      if (dwMask and CFM_FACE) &lt;&gt; 0 then Include(Result, caFace);
+      if (dwMask and CFM_ITALIC) &lt;&gt; 0 then Include(Result, caItalic);
+      if (dwMask and CFM_SIZE) &lt;&gt; 0 then Include(Result, caSize);
+      if (dwMask and CFM_STRIKEOUT) &lt;&gt; 0 then Include(Result, caStrikeOut);
+      if (dwMask and CFM_UNDERLINE) &lt;&gt; 0 then Include(Result, caUnderline);
+      if (dwMask and CFM_PROTECTED) &lt;&gt; 0 then Include(Result, caProtected);
+      if (dwMask and CFM_WEIGHT) &lt;&gt; 0 then Include(Result, caWeight);
+      if (dwMask and CFM_BACKCOLOR) &lt;&gt; 0 then Include(Result, caBackColor);
+      if (dwMask and CFM_LCID) &lt;&gt; 0 then Include(Result, caLanguage);
+      if (dwMask and CFM_SUPERSCRIPT) &lt;&gt; 0 then Include(Result, caIndexKind);
+      if (dwMask and CFM_OFFSET) &lt;&gt; 0 then Include(Result, caOffset);
+      if (dwMask and CFM_SPACING) &lt;&gt; 0 then Include(Result, caSpacing);
+      if (dwMask and CFM_KERNING) &lt;&gt; 0 then Include(Result, caKerning);
+      if (dwMask and CFM_UNDERLINETYPE) &lt;&gt; 0 then Include(Result, caULType);
+      if (dwMask and CFM_ANIMATION) &lt;&gt; 0 then Include(Result, caAnimation);
+      if (dwMask and CFM_SMALLCAPS) &lt;&gt; 0 then Include(Result, caSmallCaps);
+      if (dwMask and CFM_ALLCAPS) &lt;&gt; 0 then Include(Result, caAllCaps);
+      if (dwMask and CFM_HIDDEN) &lt;&gt; 0 then Include(Result, caHidden);
+      if (dwMask and CFM_OUTLINE) &lt;&gt; 0 then Include(Result, caOutline);
+      if (dwMask and CFM_SHADOW) &lt;&gt; 0 then Include(Result, caShadow);
+      if (dwMask and CFM_EMBOSS) &lt;&gt; 0 then Include(Result, caEmboss);
+      if (dwMask and CFM_IMPRINT) &lt;&gt; 0 then Include(Result, caImprint);
+      if (dwMask and CFM_LINK)&lt;&gt;0 then Include(result, caURL);
+    end;
+  end;
+end;
+
+procedure TTextAttributes98.GetAttributes(var Format: TCharFormat2W);
+begin
+  InitFormat(Format);
+  if RichEdit.HandleAllocated then
+    RichEdit.Perform(EM_GETCHARFORMAT,
+      WPARAM(FType = atSelected), LPARAM(@Format));
+end;
+
+procedure TTextAttributes98.SetAttributes(var Format: TCharFormat2W);
+var
+  Flag: Longint;
+begin
+  if FType = atSelected then
+    begin
+      Flag:= SCF_SELECTION or SCF_USEUIRULES;
+      if (RichEdit.SelLength=0) and RichEdit.WordFormatting then
+        Flag:= Flag or SCF_WORD;
+    end
+  else
+    Flag:= SCF_DEFAULT;
+  if RichEdit.HandleAllocated then
+    RichEdit.Perform(EM_SETCHARFORMAT, Flag, LPARAM(@Format))
+end;
+
+procedure TTextAttributes98.Assign(Source: TPersistent);
+begin
+  if Source is TTextAttributes98 then       
+    begin
+      Color := TTextAttributes98(Source).Color;
+      Name := TTextAttributes98(Source).Name;
+      Size:= TTextAttributes98(Source).Size;
+      Pitch := TTextAttributes98(Source).Pitch;
+      Weight := TTextAttributes98(Source).Weight;
+      BackColor := TTextAttributes98(Source).BackColor;
+      Language := TTextAttributes98(Source).Language;
+      IndexKind := TTextAttributes98(Source).IndexKind;
+      Offset := TTextAttributes98(Source).Offset;
+      Spacing := TTextAttributes98(Source).Spacing;
+      Kerning := TTextAttributes98(Source).Kerning;
+      UnderlineType := TTextAttributes98(Source).UnderlineType;
+      Bold := TTextAttributes98(Source).Bold;
+      Italic := TTextAttributes98(Source).Italic;
+      StrikeOut:= TTextAttributes98(Source).StrikeOut;
+      Animation := TTextAttributes98(Source).Animation;
+      SmallCaps := TTextAttributes98(Source).SmallCaps;
+      AllCaps := TTextAttributes98(Source).AllCaps;
+      Hidden := TTextAttributes98(Source).Hidden;
+      Outline := TTextAttributes98(Source).Outline;
+      Shadow := TTextAttributes98(Source).Shadow;
+      Emboss := TTextAttributes98(Source).Emboss;
+      Imprint := TTextAttributes98(Source).Imprint;
+      IsURL:= TTextAttributes98(Source).IsURL;
+    end
+  else if Source is TTextAttributes then
+    begin
+      Color := TTextAttributes(Source).Color;
+      Name := TTextAttributes(Source).Name;
+      Size:= TTextAttributes(Source).Size;
+      Pitch := TTextAttributes(Source).Pitch;
+      Bold:= fsBold in TTextAttributes(Source).Style;
+      Italic:= fsItalic in TTextAttributes(Source).Style;
+      StrikeOut:= fsStrikeOut in TTextAttributes(Source).Style;
+      UnderlineType:= TUnderlineType(fsUnderline in TTextAttributes(Source).Style);
+    end
+  else if Source is TFont then
+    begin
+      Color := TFont(Source).Color;
+      Name := TFont(Source).Name;
+      Size:= TFont(Source).Size;
+      Pitch := TFont(Source).Pitch;
+      Bold:= fsBold in TFont(Source).Style;
+      Italic:= fsItalic in TFont(Source).Style;
+      StrikeOut:= fsStrikeOut in TFont(Source).Style;
+      UnderlineType:= TUnderlineType(fsUnderline in TFont(Source).Style);
+    end
+  else
+    inherited Assign(Source);
+end;
+
+procedure TTextAttributes98.AssignTo(Dest: TPersistent);
+begin
+  if Dest is TTextAttributes98 then
+    begin
+      TTextAttributes98(Dest).Color := Color;
+      TTextAttributes98(Dest).Name := Name;
+      TTextAttributes98(Dest).Size := Size;
+      TTextAttributes98(Dest).Pitch := Pitch;
+      TTextAttributes98(Dest).Weight := Weight;
+      TTextAttributes98(Dest).BackColor := BackColor;
+      TTextAttributes98(Dest).Language := Language;
+      TTextAttributes98(Dest).IndexKind := IndexKind;
+      TTextAttributes98(Dest).Offset := Offset;
+      TTextAttributes98(Dest).Spacing := Spacing;
+      TTextAttributes98(Dest).Kerning := Kerning;
+      TTextAttributes98(Dest).UnderlineType := UnderlineType;
+      TTextAttributes98(Dest).Bold := Bold;
+      TTextAttributes98(Dest).Italic := Italic;
+      TTextAttributes98(Dest).Animation := Animation;
+      TTextAttributes98(Dest).SmallCaps := SmallCaps;
+      TTextAttributes98(Dest).AllCaps := AllCaps;
+      TTextAttributes98(Dest).Hidden := Hidden;
+      TTextAttributes98(Dest).Outline := Outline;
+      TTextAttributes98(Dest).Shadow := Shadow;
+      TTextAttributes98(Dest).Emboss := Emboss;
+      TTextAttributes98(Dest).Imprint := Imprint;
+      TTextAttributes98(Dest).IsURL := IsURL;
+    end
+  else if Dest is TTextAttributes then
+    begin
+      TTextAttributes(Dest).Color := Color;
+      TTextAttributes(Dest).Name := Name;
+      if Bold then
+        TTextAttributes(Dest).Style:= [fsBold]
+      else
+        TTextAttributes(Dest).Style:= [];
+      if Italic then
+        TTextAttributes(Dest).Style:= TTextAttributes(Dest).Style+[fsItalic];
+      if UnderlineType&lt;&gt;ultNone then
+        TTextAttributes(Dest).Style:= TTextAttributes(Dest).Style+[fsUnderline];
+      TTextAttributes(Dest).Charset := CharsetFromLocale(Language);
+      TTextAttributes(Dest).Size := Size;
+      TTextAttributes(Dest).Pitch := Pitch;
+    end
+  else if Dest is TFont then
+    begin
+      TFont(Dest).Color := Color;
+      TFont(Dest).Name := Name;
+      if Bold then
+        TFont(Dest).Style:= [fsBold]
+      else
+        TFont(Dest).Style:= [];
+      if Italic then
+        TFont(Dest).Style:= TTextAttributes(Dest).Style+[fsItalic];
+      if UnderlineType&lt;&gt;ultNone then
+        TFont(Dest).Style:= TTextAttributes(Dest).Style+[fsUnderline];
+      TFont(Dest).Charset := CharsetFromLocale(Language);
+      TFont(Dest).Size := Size;
+      TFont(Dest).Pitch := Pitch;
+    end
+  else
+    inherited AssignTo(Dest);
+end;
+
+function TTextAttributes98.GetProtected: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= FOldAttr.Protected;
+      Exit;
+    end;
+  GetAttributes(Format);
+  with Format do
+    if (dwEffects and CFE_PROTECTED) &lt;&gt; 0 then
+      Result := True else
+      Result := False;
+end;
+
+procedure TTextAttributes98.SetProtected(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      FOldAttr.Protected:= Value;
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_PROTECTED;
+    if Value then dwEffects := CFE_PROTECTED;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetColor: TColor;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= FOldAttr.Color;
+      Exit;
+    end;
+  GetAttributes(Format);
+  with Format do
+    if (dwEffects and CFE_AUTOCOLOR) &lt;&gt; 0 then
+      Result := clWindowText else
+      Result := crTextColor;
+end;
+
+procedure TTextAttributes98.SetColor(Value: TColor);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      FOldAttr.Color:= Value;
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_COLOR;
+    if Value = clWindowText then
+      dwEffects := CFE_AUTOCOLOR
+    else
+      crTextColor := ColorToRGB(Value);
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetName: TFontName;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= FOldAttr.Name;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.szFaceName;
+end;
+
+procedure TTextAttributes98.SetName(Value: TFontName);
+var
+  Format: TCharFormat2W;
+  I: Integer;
+  W: WideString;
+begin
+  if RichEdit.FVer10 then
+    begin
+      FOldAttr.Name:= Value;
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_FACE;
+    W:= Value;
+    for I:= 0 to Length(Value)-1 do
+      szFaceName[I]:= W[I+1];
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetPitch: TFontPitch;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= FOldAttr.Pitch;
+      Exit;
+    end;
+  GetAttributes(Format);
+  case (Format.bPitchAndFamily and $03) of
+    DEFAULT_PITCH: Result := fpDefault;
+    VARIABLE_PITCH: Result := fpVariable;
+    FIXED_PITCH: Result := fpFixed;
+  else
+    Result := fpDefault;
+  end;
+end;
+
+procedure TTextAttributes98.SetPitch(Value: TFontPitch);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      FOldAttr.Pitch:= Value;
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    case Value of
+      fpVariable: Format.bPitchAndFamily := VARIABLE_PITCH;
+      fpFixed: Format.bPitchAndFamily := FIXED_PITCH;
+    else
+      Format.bPitchAndFamily := DEFAULT_PITCH;
+    end;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetSize: Integer;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= FOldAttr.Size;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.yHeight div 20;
+end;
+
+procedure TTextAttributes98.SetSize(Value: Integer);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      FOldAttr.Size:= Value;
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_SIZE;
+    yHeight := Value * 20;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetWeight: Word;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      if Bold then
+        Result:= 700
+      else
+        Result:= 400;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.wWeight;
+end;
+
+procedure TTextAttributes98.SetWeight(Value: Word);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_Weight;
+    wWeight := Value;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetBackColor: TColor;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= clNone;
+      Exit;
+    end;
+  GetAttributes(Format);
+  with Format do
+    Result := crBackColor;
+end;
+
+procedure TTextAttributes98.SetBackColor(Value: TColor);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_BACKCOLOR;
+    crBackColor := ColorToRGB(Value);
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetLanguage: TLanguage;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 2048;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.lid;
+end;
+
+procedure TTextAttributes98.SetLanguage(Value: TLanguage);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_LCID;
+    lid := Value;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetIndexKind: TIndexKind;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= ikNone;
+      Exit;
+    end;
+  GetAttributes(Format);
+  case (Format.dwEffects and CFM_SUPERSCRIPT) shr 16 of
+  1: Result:= ikSubscript;
+  2: Result:= ikSuperscript;
+  else Result:= ikNone;
+  end;
+end;
+
+procedure TTextAttributes98.SetIndexKind(Value: TIndexKind);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_SUPERSCRIPT;
+    dwEffects := Ord(Value) shl 16;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetOffset: Double;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.yOffset/20;
+end;
+
+procedure TTextAttributes98.SetOffset(Value: Double);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_OFFSET;
+    yOffset := Round(Value*20);
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetSpacing: Double;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.sSpacing/20;
+end;
+
+procedure TTextAttributes98.SetSpacing(Value: Double);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_SPACING;
+    sSpacing := Round(Value*20);
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetKerning: Double;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.wKerning/20;
+end;
+
+procedure TTextAttributes98.SetKerning(Value: Double);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_KERNING;
+    wKerning := Round(Value*20);
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetUnderlineType: TUnderlineType;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= TUnderlineType(fsUnderline in FOldAttr.Style);
+      Exit;
+    end;
+  GetAttributes(Format);
+  if (Format.dwEffects and Integer(CFE_UNDERLINE)) &lt;&gt;0 then
+    Result := TUnderlineType(Format.bUnderlineType)
+  else
+    Result:= ultNone;
+end;
+
+procedure TTextAttributes98.SetUnderlineType(Value: TUnderlineType);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      if Value=ultNone then
+        FOldAttr.Style:= FOldAttr.Style-[fsUnderline]
+      else
+        FOldAttr.Style:= FOldAttr.Style+[fsUnderline];
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_UNDERLINETYPE;
+    bUnderlineType := Byte(Value);
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetAnimation: TAnimationType;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= aniNone;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := TAnimationType(Format.bAnimation);
+end;
+
+procedure TTextAttributes98.SetAnimation(Value: TAnimationType);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_ANIMATION;
+    bAnimation := Byte(Value);
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetBold: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= fsBold in FOldAttr.Style;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_BOLD &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetBold(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      if Value then
+        FOldAttr.Style:= FOldAttr.Style+[fsBold]
+      else
+        FOldAttr.Style:= FOldAttr.Style-[fsBold];
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_BOLD;
+    if Value then
+      dwEffects:= CFE_BOLD;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetItalic: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= fsItalic in FOldAttr.Style;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_ITALIC &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetItalic(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      if Value then
+        FOldAttr.Style:= FOldAttr.Style+[fsItalic]
+      else
+        FOldAttr.Style:= FOldAttr.Style-[fsItalic];
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_ITALIC;
+    if Value then
+      dwEffects:= CFE_ITALIC;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetStrikeOut: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= fsstrikeOut in FOldAttr.Style;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_STRIKEOUT &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetStrikeOut(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      if Value then
+        FOldAttr.Style:= FOldAttr.Style+[fsStrikeout]
+      else
+        FOldAttr.Style:= FOldAttr.Style-[fsStrikeout];
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_STRIKEOUT;
+    if Value then
+      dwEffects:= CFE_STRIKEOUT;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetSmallCaps: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_SMALLCAPS &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetSmallCaps(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_SMALLCAPS;
+    if Value then
+      dwEffects:= CFE_SMALLCAPS;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetAllCaps: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_ALLCAPS &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetAllCaps(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_ALLCAPS;
+    if Value then
+      dwEffects:= CFE_ALLCAPS;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetHidden: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_HIDDEN &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetHidden(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_HIDDEN;
+    if Value then
+      dwEffects:= CFE_HIDDEN;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetOutline: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_OUTLINE &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetOutline(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_OUTLINE;
+    if Value then
+      dwEffects:= CFE_OUTLINE;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetShadow: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_SHADOW &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetShadow(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_SHADOW;
+    if Value then
+      dwEffects:= CFE_SHADOW;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetEmboss: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_EMBOSS &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetEmboss(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_EMBOSS;
+    if Value then
+      dwEffects:= CFE_EMBOSS;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetImprint: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_IMPRINT &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetImprint(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_IMPRINT;
+    if Value then
+      dwEffects:= CFE_IMPRINT;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetIsURL: Boolean;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Format);
+  Result := Format.dwEffects and CFE_LINK &lt;&gt;0;
+end;
+
+procedure TTextAttributes98.SetIsURL(Value: Boolean);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_LINK;
+    if Value then
+      dwEffects:= CFE_LINK;
+  end;
+  SetAttributes(Format);
+end;
+
+function TTextAttributes98.GetHeight: Integer;
+begin
+  Result := MulDiv(Size, RichEdit.FScreenLogPixels, 72);
+end;
+
+procedure TTextAttributes98.SetHeight(Value: Integer);
+begin
+  Size := MulDiv(Value, 72, RichEdit.FScreenLogPixels);
+end;
+
+function TTextAttributes98.GetStyle: TFontStyles;
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= FOldAttr.Style;
+      Exit;
+    end;
+  Result := [];
+  GetAttributes(Format);
+  with Format do
+  begin
+    if (dwEffects and Integer(CFE_BOLD)) &lt;&gt; 0 then Include(Result, fsBold);
+    if (dwEffects and Integer(CFE_ITALIC)) &lt;&gt; 0 then Include(Result, fsItalic);
+    if (dwEffects and Integer(CFE_UNDERLINE)) &lt;&gt; 0 then Include(Result, fsUnderline);
+    if (dwEffects and Integer(CFE_STRIKEOUT)) &lt;&gt; 0 then Include(Result, fsStrikeOut);
+  end;
+end;
+
+procedure TTextAttributes98.SetStyle(Value: TFontStyles);
+var
+  Format: TCharFormat2W;
+begin
+  if RichEdit.FVer10 then
+    begin
+      FOldAttr.Style:= Value;
+      Exit;
+    end;
+  InitFormat(Format);
+  with Format do
+  begin
+    dwMask := CFM_BOLD or CFM_ITALIC or CFM_STRIKEOUT or CFM_UNDERLINETYPE;
+    if fsBold in Value then dwEffects := dwEffects or CFE_BOLD;
+    if fsItalic in Value then dwEffects := dwEffects or CFE_ITALIC;
+    if fsStrikeOut in Value then dwEffects := dwEffects or CFE_STRIKEOUT;
+    bUnderlineType:= Ord(fsUnderline in Value);
+  end;
+  SetAttributes(Format);
+end;
+
+{ TParaAttributes98}
+constructor TParaAttributes98.Create(AOwner: TCustomRichEdit98);
+begin
+  inherited Create(AOwner);
+  RichEdit := AOwner;
+end;
+
+procedure TParaAttributes98.InitPara(var Paragraph: TParaFormat2);
+begin
+  FillChar(Paragraph, SizeOf(TParaFormat2), 0);
+  Paragraph.cbSize := SizeOf(TParaFormat2);
+end;
+
+procedure TParaAttributes98.GetAttributes(var Paragraph: TParaFormat2);
+begin
+  InitPara(Paragraph);
+  if RichEdit.HandleAllocated then
+    RichEdit.Perform(EM_GETPARAFORMAT, 0, LPARAM(@Paragraph));
+end;
+
+procedure TParaAttributes98.SetAttributes(var Paragraph: TParaFormat2);
+begin
+  if RichEdit.HandleAllocated then
+    RichEdit.Perform(EM_SETPARAFORMAT, 0, LPARAM(@Paragraph))
+end;
+
+function TParaAttributes98.GetFirstIndent: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= TRichEdit(RichEdit).Paragraph.FirstIndent;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.dxStartIndent/20;
+end;
+
+procedure TParaAttributes98.SetFirstIndent(Value: Double);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      TRichEdit(RichEdit).Paragraph.FirstIndent:= Round(Value);
+      Exit;
+    end;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_STARTINDENT;
+    dxStartIndent := Round(Value * 20);
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetLeftIndent: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= TRichEdit(RichEdit).Paragraph.LeftIndent;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.dxOffset/20;
+end;
+
+procedure TParaAttributes98.SetLeftIndent(Value: Double);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      TRichEdit(RichEdit).Paragraph.LeftIndent:= Round(Value);
+      Exit;
+    end;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_OFFSET;
+    dxOffset := Round(Value * 20);
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetRightIndent: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= TRichEdit(RichEdit).Paragraph.RightIndent;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.dxRightIndent/20;
+end;
+
+procedure TParaAttributes98.SetRightIndent(Value: Double);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      TRichEdit(RichEdit).Paragraph.RightIndent:= Round(Value);
+      Exit;
+    end;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_RIGHTINDENT;
+    dxRightIndent := Round(Value * 20);
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetSpaceBefore: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.dySpaceBefore/20;
+end;
+
+procedure TParaAttributes98.SetSpaceBefore(Value: Double);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_SPACEBEFORE;
+    dySpaceBefore := Round(Value*20);
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetSpaceAfter: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.dySpaceAfter/20;
+end;
+
+procedure TParaAttributes98.SetSpaceAfter(Value: Double);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_SPACEAFTER;
+    dySpaceAfter := Round(Value*20);
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetLineSpacing: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.dyLineSpacing/20;
+end;
+
+function TParaAttributes98.GetLineSpacingRule: TLineSpacingRule;
+var
+  Paragraph: TParaFormat2;
+begin
+  Result := lsrOrdinary;
+  if RichEdit.FVer10 then Exit;
+  GetAttributes(Paragraph);
+  Result := TLineSpacingRule(Paragraph.bLineSpacingRule);
+end;
+
+procedure TParaAttributes98.SetLineSpacing(Rule: TLineSpacingRule; Value: Double);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_LINESPACING;
+    bLineSpacingRule:= Ord(Rule);
+    dyLineSpacing := Round(Value*20);
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetKeepTogether: Boolean;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wReserved and PFE_KEEP &lt;&gt;0;
+end;
+
+procedure TParaAttributes98.SetKeepTogether(Value: Boolean);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_KEEP;
+    if Value then
+      wReserved:= PFE_KEEP;
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetKeepWithNext: Boolean;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wReserved and PFE_KEEPNEXT &lt;&gt;0;
+end;
+
+procedure TParaAttributes98.SetKeepWithNext(Value: Boolean);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_KEEPNEXT;
+    if Value then
+      wReserved:= PFE_KEEPNEXT;
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetPageBreakBefore: Boolean;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wReserved and PFE_PAGEBREAKBEFORE &lt;&gt;0;
+end;
+
+procedure TParaAttributes98.SetPageBreakBefore(Value: Boolean);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_PAGEBREAKBEFORE;
+    if Value then
+      wReserved:= PFE_PAGEBREAKBEFORE;
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetNoLineNumber: Boolean;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wReserved and PFE_NOLINENUMBER &lt;&gt;0;
+end;
+
+procedure TParaAttributes98.SetNoLineNumber(Value: Boolean);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_NOLINENUMBER;
+    if Value then
+      wReserved:= PFE_NOLINENUMBER;
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetNoWidowControl: Boolean;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wReserved and PFE_NOWIDOWCONTROL &lt;&gt;0;
+end;
+
+procedure TParaAttributes98.SetNoWidowControl(Value: Boolean);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_NOWIDOWCONTROL;
+    if Value then
+      wReserved:= PFE_NOWIDOWCONTROL;
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetDoNotHyphen: Boolean;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wReserved and PFE_DONOTHYPHEN &lt;&gt;0;
+end;
+
+procedure TParaAttributes98.SetDoNotHyphen(Value: Boolean);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_DONOTHYPHEN;
+    if Value then
+      wReserved:= PFE_DONOTHYPHEN;
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetSideBySide: Boolean;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= False;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wReserved and PFE_SIDEBYSIDE &lt;&gt;0;
+end;
+
+procedure TParaAttributes98.SetSideBySide(Value: Boolean);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_SIDEBYSIDE;
+    if Value then
+      wReserved:= PFE_SIDEBYSIDE;
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetAlignment: TAlignment98;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= TAlignment98(TRichEdit(RichEdit).Paragraph.Alignment);
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := TAlignment98(Paragraph.wAlignment - 1);
+end;
+
+procedure TParaAttributes98.SetAlignment(Value: TAlignment98);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      TRichEdit(RichEdit).Paragraph.Alignment:= TAlignment(Value);
+      Exit;
+    end;
+  InitPara(Paragraph);
+  with Paragraph do
+  begin
+    dwMask := PFM_ALIGNMENT;
+    wAlignment := Ord(Value) + 1;
+  end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetNumbering: TNumberingStyle98;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= TNumberingStyle98(TRichEdit(RichEdit).Paragraph.Numbering);
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := TNumberingStyle98(Paragraph.wNumbering);
+end;
+
+procedure TParaAttributes98.SetNumbering(Value: TNumberingStyle98);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      TRichEdit(RichEdit).Paragraph.Numbering:= TNumberingStyle(Value&lt;&gt;nsNone);
+      Exit;
+    end;
+  InitPara(Paragraph);
+  with Paragraph do
+    begin
+      dwMask := PFM_NUMBERING;
+      wNumbering := Word(Value);
+    end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetNumberingStart: Word;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wNumberingStart;
+end;
+
+procedure TParaAttributes98.SetNumberingStart(Value: Word);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+    begin
+      dwMask := PFM_NUMBERINGSTART;
+      wNumberingStart := Value;
+    end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetNumberingFollow: TNumberingFollow;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= nfPeriod;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := TNumberingFollow(Paragraph.wNumberingStyle);
+end;
+
+procedure TParaAttributes98.SetNumberingFollow(Value: TNumberingFollow);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+    begin
+      dwMask := PFM_NUMBERINGSTYLE;
+      wNumberingStyle := Word(Value);
+    end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetNumberingTab: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wNumberingTab/20;
+end;
+
+procedure TParaAttributes98.SetNumberingTab(Value: Double);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+    begin
+      dwMask := PFM_NUMBERINGTAB;
+      wNumberingTab := Round(Value*20);
+    end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetBorderSpace: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wBorderSpace/20;
+end;
+
+function TParaAttributes98.GetBorderWidth: Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then begin
+    Result := 0.1;
+    Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.wBorderWidth/20;
+end;
+
+function TParaAttributes98.GetBorderLocations: TBorderLocations;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= [];
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Byte(Result) := Lo(Paragraph.wBorders);
+end;
+
+function TParaAttributes98.GetBorderStyle: TBorderStyle;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then begin
+    Result := bsNone;
+    Exit;
+    end;
+  GetAttributes(Paragraph);
+  Byte(Result) := Hi(Paragraph.wBorders) and 15;
+end;
+
+const
+  IndexedColors: array[0..15]of TColor=
+  (clBlack, clBlue, clAqua, clLime, clFuchsia, clRed, clYellow, clWhite,
+   clNavy, clTeal, clGreen, clPurple, clMaroon, clOlive, clDkGray, clLtGray);
+
+function FindClosestColor(Color: TColor): Byte;
+var
+  I, N, NMin: Byte;
+begin
+  NMin:= 255;
+  Result := 0;
+  for I:= 0 to 15 do
+    begin
+      N:= Abs(TPaletteEntry(Color).peBlue-TPaletteEntry(IndexedColors[I]).peBlue)+
+          Abs(TPaletteEntry(Color).peGreen-TPaletteEntry(IndexedColors[I]).peGreen)+
+          Abs(TPaletteEntry(Color).peRed-TPaletteEntry(IndexedColors[I]).peRed);
+      if N&lt;NMin then begin
+          NMin := N;
+          Result := I;
+          if N = 0 then
+            Exit;
+        end;
+    end;
+end;
+
+function TParaAttributes98.GetBorderColor: TColor;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= clNone;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result:= IndexedColors[Hi(Paragraph.wBorders) shr 4];
+end;
+
+procedure TParaAttributes98.SetBorder(Space, Width: Double; Locations: TBorderLocations;
+                    Style: TBorderStyle; Color: TColor);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+    begin
+      dwMask := PFM_BORDER;
+      wBorderSpace := Round(Space*20);
+      wBorderWidth := Round(Width*20);
+      wBorders:= FindClosestColor(Color) shl 12 or Byte(Style) shl 8 or Byte(Locations);
+    end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetShadingWeight: TShadingWeight;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= 0;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := TShadingWeight(Paragraph.wShadingWeight);
+end;
+
+function TParaAttributes98.GetShadingStyle: TShadingStyle;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then begin
+    Result := shsNone;
+    Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := TShadingStyle(Paragraph.wShadingStyle and 15);
+end;
+
+function TParaAttributes98.GetShadingColor: TColor;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= clNone;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := IndexedColors[(Paragraph.wShadingStyle shr 4) and 15];
+end;
+
+function TParaAttributes98.GetShadingBackColor: TColor;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then begin
+    Result := clWindow;
+    Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := IndexedColors[(Paragraph.wShadingStyle shr 8) and 15];
+end;
+
+procedure TParaAttributes98.SetShading(Weight: TShadingWeight; Style: TShadingStyle;
+                                       Color, BackColor: TColor);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    Exit;
+  InitPara(Paragraph);
+  with Paragraph do
+    begin
+      dwMask := PFM_SHADING;
+      wShadingWeight := Weight;
+      wShadingStyle:= FindClosestColor(BackColor) shl 8 or
+                      FindClosestColor(Color) shl 4 or Byte(Style);
+    end;
+  SetAttributes(Paragraph);
+end;
+
+function TParaAttributes98.GetTabCount: Integer;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= TRichEdit(RichEdit).Paragraph.TabCount;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := Paragraph.cTabCount;
+end;
+
+function TParaAttributes98.GetTab(Index: Integer): Double;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= TRichEdit(RichEdit).Paragraph.Tab[Index];
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := (Paragraph.rgxTabs[Index] and $FFFFFF)/20;
+end;
+
+function TParaAttributes98.GetTabAlignment(Index: Integer): TTabAlignment;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= tbaLeft;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := TTabAlignment(Paragraph.rgxTabs[Index] shr 24 and 15);
+end;
+
+function TParaAttributes98.GetTabLeader(Index: Integer): TTabLeader;
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      Result:= tblNone;
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  Result := TTabLeader(Paragraph.rgxTabs[Index] shr 28);
+end;
+
+procedure TParaAttributes98.SetTab(Index: Integer; Value: Double;
+                                   Alignment: TTabAlignment; Leader: TTabLeader);
+var
+  Paragraph: TParaFormat2;
+begin
+  if RichEdit.FVer10 then
+    begin
+      TRichEdit(RichEdit).Paragraph.Tab[Index]:= Round(Value);
+      Exit;
+    end;
+  GetAttributes(Paragraph);
+  with Paragraph do
+  begin
+    rgxTabs[Index] := Round(Value * 20) or (Byte(Alignment) shl 24) or
+                      (Byte(Leader) shl 28);
+    dwMask := PFM_TABSTOPS;
+    if cTabCount &lt; Index then cTabCount := Index;
+    SetAttributes(Paragraph);
+  end;
+end;
+
+
+
+{ TRichEditStrings98 }
+
+const
+  ReadError = $0001;
+  WriteError = $0002;
+  NoError = $0000;
+  ReReadError = $0003;
+
+type
+  TSelection = record
+    StartPos, EndPos: Integer;
+  end;
+
+  PRichEditStreamInfo = ^TRichEditStreamInfo;
+  TRichEditStreamInfo = record
+    Converter: TConversion;
+    Stream: TStream;
+    RichEdit: TCustomRichEdit98;
+  end;
+
+  TRichEditStrings98 = class(TStrings)
+  private
+    RichEdit: TCustomRichEdit98;
+    FConverter: TConversion;
+    procedure EnableChange(const Value: Boolean);
+  protected
+    function Get(Index: Integer): string; override;
+    function GetCount: Integer; override;
+    procedure Put(Index: Integer; const S: string); override;
+    procedure SetUpdateState(Updating: Boolean); override;
+    procedure SetTextStr(const Value: string); override;
+//    function GetPlainText: Boolean;
+//    procedure SetPlainText(Value: Boolean);
+    function GetInputFormat: TInputFormat;
+    procedure SetInputFormat(Value: TInputFormat);
+    function GetOutputFormat: TOutputFormat;
+    procedure SetOutputFormat(Value: TOutputFormat);
+    function GetSelectedInOut:Boolean;
+    procedure SetSelectedInOut(Value: Boolean);
+    function GetPlainRTF: Boolean;
+    procedure SetPlainRTF(Value: Boolean);
+  public
+    procedure Clear; override;
+    procedure AddStrings(Strings: TStrings); override;
+    procedure Delete(Index: Integer); override;
+    procedure Insert(Index: Integer; const S: string); override;
+    procedure LoadFromFile(const FileName: string); override;
+    procedure LoadFromStream(Stream: TStream); override;
+    procedure SaveToFile(const FileName: string); override;
+    procedure SaveToStream(Stream: TStream); override;
+//    property PlainText: Boolean read GetPlainText write SetPlainText;
+    property InputFormat: TInputFormat read GetInputFormat write SetInputFormat;
+    property OutputFormat: TOutputFormat read GetOutputFormat write SetOutputFormat;
+    property SelectedInOut: Boolean read GetSelectedInOut write SetSelectedInOut;
+    property PlainRTF:Boolean read GetPlainRTF write SetPlainRTF;
+  end;
+
+  TWideRichEditStrings98 = class(TWideStrings)
+  private
+    RichEdit: TCustomRichEdit98;
+    procedure EnableChange(const Value: Boolean);
+  protected
+    function Get(Index: Integer): WideString; override;
+    function GetCount: Integer; override;
+    procedure Put(Index: Integer; const S: WideString); override;
+    procedure SetUpdateState(Updating: Boolean); override;
+    procedure SetTextStr(const Value: WideString); override;
+    procedure SetLanguage(Value: TLanguage); override;
+    function GetLanguage: TLanguage; override;
+//    function GetPlainText: Boolean;
+//    procedure SetPlainText(Value: Boolean);
+    function GetInputFormat: TInputFormat;
+    procedure SetInputFormat(Value: TInputFormat);
+    function GetOutputFormat: TOutputFormat;
+    procedure SetOutputFormat(Value: TOutputFormat);
+    function GetSelectedInOut:Boolean;
+    procedure SetSelectedInOut(Value: Boolean);
+    function GetPlainRTF: Boolean;
+    procedure SetPlainRTF(Value: Boolean);
+  public
+    procedure Clear; override;
+    procedure AddStrings(Strings: TWideStrings); override;
+    procedure Delete(Index: Integer); override;
+    procedure Insert(Index: Integer; const S: WideString); override;
+    procedure LoadFromFile(const FileName: string); override;
+    procedure LoadFromStream(Stream: TStream); override;
+    procedure SaveToFile(const FileName: string); override;
+    procedure SaveToStream(Stream: TStream); override;
+//    property PlainText: Boolean read GetPlainText write SetPlainText;
+    property InputFormat: TInputFormat read GetInputFormat write SetInputFormat;
+    property OutputFormat: TOutputFormat read GetOutputFormat write SetOutputFormat;
+    property SelectedInOut: Boolean read GetSelectedInOut write SetSelectedInOut;
+    property PlainRTF:Boolean read GetPlainRTF write SetPlainRTF;
+  end;
+
+procedure TRichEditStrings98.AddStrings(Strings: TStrings);
+var
+  SelChange: TNotifyEvent;
+begin
+  SelChange := RichEdit.OnSelectionChange;
+  RichEdit.OnSelectionChange := nil;
+  try
+    inherited AddStrings(Strings);
+  finally
+    RichEdit.OnSelectionChange := SelChange;
+  end;
+end;
+
+function TRichEditStrings98.GetCount: Integer;
+begin
+  Result := RichEdit.Perform(EM_GETLINECOUNT, 0, 0);
+  if RichEdit.Perform(EM_LINELENGTH,
+    RichEdit.Perform(EM_LINEINDEX, Result - 1, 0), 0) = 0 then Dec(Result);
+end;
+
+function TRichEditStrings98.Get(Index: Integer): string;
+begin
+  Result:= WideToChar(TWideRichEditStrings98(RichEdit.WideLines).Get(Index), RichEdit.FCP);
+end;
+
+procedure TRichEditStrings98.Put(Index: Integer; const S: string);
+begin
+  TWideRichEditStrings98(RichEdit.WideLines).Put(Index, CharToWide(S, RichEdit.FCP));
+end;
+
+procedure TRichEditStrings98.Insert(Index: Integer; const S: string);
+begin
+  TWideRichEditStrings98(RichEdit.WideLines).Insert(Index, CharToWide(S, RichEdit.FCP));
+end;
+
+procedure TRichEditStrings98.Delete(Index: Integer);
+begin
+  TWideRichEditStrings98(RichEdit.WideLines).Delete(Index);
+end;
+
+procedure TRichEditStrings98.Clear;
+begin
+  RichEdit.Clear;
+end;
+
+procedure TRichEditStrings98.SetUpdateState(Updating: Boolean);
+begin
+  RichEdit.Perform(WM_SETREDRAW, Ord(not Updating), 0);
+  if not Updating then begin
+    RichEdit.Refresh;
+    RichEdit.Perform(CM_TEXTCHANGED, 0, 0);
+  end;
+end;
+
+procedure TRichEditStrings98.EnableChange(const Value: Boolean);
+var
+  EventMask: Longint;
+begin
+  with RichEdit do
+  begin
+    if Value then
+      EventMask := Perform(EM_GETEVENTMASK, 0, 0) or ENM_CHANGE
+    else
+      EventMask := Perform(EM_GETEVENTMASK, 0, 0) and not ENM_CHANGE;
+    Perform(EM_SETEVENTMASK, 0, EventMask);
+  end;
+end;
+
+procedure TRichEditStrings98.SetTextStr(const Value: string);
+begin
+  EnableChange(False);
+  try
+    inherited SetTextStr(Value);
+  finally
+    EnableChange(True);
+  end;
+end;
+
+function TRichEditStrings98.GetInputFormat: TInputFormat;
+begin
+  Result:= RichEdit.InputFormat;
+end;
+
+procedure TRichEditStrings98.SetInputFormat(Value: TInputFormat);
+begin
+  RichEdit.InputFormat:= Value;
+end;
+
+function TRichEditStrings98.GetOutputFormat: TOutputFormat;
+begin
+  Result:= RichEdit.OutputFormat;
+end;
+
+procedure TRichEditStrings98.SetOutputFormat(Value: TOutputFormat);
+begin
+  RichEdit.OutputFormat:= Value;
+end;
+
+function TRichEditStrings98.GetSelectedInOut:Boolean;
+begin
+     Result:=RichEdit.SelectedInOut;
+end;
+
+procedure TRichEditStrings98.SetSelectedInOut(Value: Boolean);
+begin
+  RichEdit.SelectedInOut:=Value;
+end;
+
+function TRichEditStrings98.GetPlainRTF: Boolean;
+begin
+  Result:=RichEdit.PlainRTF;
+end;
+
+procedure TRichEditStrings98.SetPlainRTF(Value: Boolean);
+begin
+  RichEdit.PlainRTF:=Value;
+end;
+
+function StreamSave(dwCookie: Longint; pbBuff: PByte;
+  cb: Longint; var pcb: Longint): Longint; stdcall;
+var
+  StreamInfo: PRichEditStreamInfo;
+begin
+  Result := NoError;
+  StreamInfo := PRichEditStreamInfo(Pointer(dwCookie));
+  try
+    pcb := 0;
+    if StreamInfo^.Converter &lt;&gt; nil then
+      pcb:= StreamInfo^.Converter.ConvertWriteStream(StreamInfo^.Stream, PChar(pbBuff), cb);
+    if Assigned(StreamInfo^.RichEdit.FOnSaveProgress) then
+      StreamInfo^.RichEdit.FOnLoadProgress(StreamInfo^.RichEdit,
+                                           StreamInfo^.Stream.Position,
+                                           StreamInfo^.Stream.Size);
+  except
+    Result := WriteError;
+  end;
+end;
+
+function StreamLoad(dwCookie: Longint; pbBuff: PChar;
+  cb: Longint; var pcb: Longint): Longint; stdcall;
+var
+  StreamInfo: PRichEditStreamInfo;
+begin
+  Result := NoError;
+  StreamInfo := PRichEditStreamInfo(Pointer(dwCookie));
+  pcb:= 0;
+  try
+    if Assigned(StreamInfo^.RichEdit.FOnLoadProgress) then
+      StreamInfo^.RichEdit.FOnLoadProgress(StreamInfo^.RichEdit,
+                                           StreamInfo^.Stream.Position,
+                                           StreamInfo^.Stream.Size);
+    if StreamInfo^.Converter &lt;&gt; nil then
+      pcb:= StreamInfo^.Converter.ConvertReadStream(StreamInfo^.Stream, pbBuff, cb);
+  except
+    Result := ReadError;
+  end;
+end;
+
+procedure TRichEditStrings98.LoadFromStream(Stream: TStream);
+var
+  EditStream: TEditStream;
+  Position: Longint;
+  TextType: Longint;
+  StreamInfo: TRichEditStreamInfo;
+  Converter: TConversion;
+begin
+  StreamInfo.Stream := Stream;
+  if FConverter &lt;&gt; nil then
+    Converter := FConverter else
+    Converter := RichEdit.DefaultConverter.Create;
+  StreamInfo.Converter := Converter;
+  StreamInfo.RichEdit:= RichEdit;
+  try
+    with EditStream do
+    begin
+      dwCookie := LongInt(Pointer(@StreamInfo));
+      pfnCallBack := @StreamLoad;
+      dwError := 0;
+    end;
+    Position := Stream.Position;
+    case InputFormat of
+    ifText:
+      TextType:=SF_TEXT;
+    ifUnicode:
+      TextType:=SF_UNICODE or SF_TEXT;
+    else
+      TextType:=SF_RTF;
+    end;
+
+    if SelectedInOut then
+      TextType := (TextType or SFF_SELECTION)
+    else
+      TextType := (TextType or SFF_PLAINRTF);
+
+    RichEdit.Perform(EM_STREAMIN, TextType, Longint(@EditStream));
+    if ((TextType and SF_RTF)=SF_RTF) and (EditStream.dwError &lt;&gt; 0) then
+      begin
+        Stream.Position:= Position;
+        TextType:= SF_TEXT;
+        if SelectedInOut then
+          TextType:= TextType or SFF_SELECTION;
+        if PlainRTF then
+          TextType:= TextType or SFF_PLAINRTF;
+        RichEdit.Perform(EM_STREAMIN, TextType, Longint(@EditStream));
+        if EditStream.dwError &lt;&gt; 0 then
+          raise EOutOfResources.Create(sRichEditLoadFail);
+      end;
+  finally
+    if FConverter = nil then Converter.Free;
+    if RichEdit.AutoURLDetect=adExtended then
+      begin
+        RichEdit.FCROld.cpMin:= 0;
+        RichEdit.FCROld.cpMax:= GetWindowTextLength(RichEdit.Handle);
+        RichEdit.DetectURLs(RichEdit.FCROld);
+      end;
+  end;
+end;
+
+procedure TRichEditStrings98.SaveToStream(Stream: TStream);
+var
+  EditStream: TEditStream;
+  TextType: Longint;
+  StreamInfo: TRichEditStreamInfo;
+  Converter: TConversion;
+begin
+  if FConverter &lt;&gt; nil then
+    Converter := FConverter else
+    Converter := RichEdit.DefaultConverter.Create;
+  StreamInfo.Stream := Stream;
+  StreamInfo.Converter := Converter;
+  StreamInfo.RichEdit:= RichEdit;
+  try
+    with EditStream do
+    begin
+      dwCookie := LongInt(Pointer(@StreamInfo));
+      pfnCallBack := @StreamSave;
+      dwError := 0;
+    end;
+    case OutputFormat of
+    ofText:
+      TextType:= SF_TEXT;
+    ofRTFNoObjs:
+      TextType:= SF_RTFNOOBJS;
+    ofTextized:
+      TextType:= SF_TEXTIZED;
+    ofUnicode:
+      TextType:= SF_TEXT or SF_UNICODE;
+    else
+      TextType:= SF_RTF;
+    end;
+
+    if SelectedInOut then TextType := (TextType or SFF_SELECTION)
+    else TextType := (TextType or SFF_PLAINRTF);
+
+    RichEdit.Perform(EM_STREAMOUT, TextType, Longint(@EditStream));
+    if EditStream.dwError &lt;&gt; 0 then
+      raise EOutOfResources.Create(sRichEditSaveFail);
+  finally
+    if FConverter = nil then Converter.Free;
+  end;
+end;
+
+procedure TRichEditStrings98.LoadFromFile(const FileName: string);
+var
+  Ext: string;
+  Convert: PConversionFormat;
+begin
+  Ext := AnsiLowerCaseFileName(ExtractFileExt(Filename));
+  System.Delete(Ext, 1, 1);
+  Convert := ConversionFormatList;
+  while Convert &lt;&gt; nil do
+    with Convert^ do
+      if Extension &lt;&gt; Ext then Convert := Next
+      else Break;
+  if Convert = nil then
+    Convert := @TextConversionFormat;
+  FConverter := Convert^.ConversionClass.Create;
+  try
+    inherited LoadFromFile(FileName);
+  except
+    FConverter.Free;
+    FConverter := nil;
+    raise;
+  end;
+end;
+
+procedure TRichEditStrings98.SaveToFile(const FileName: string);
+var
+  Ext: string;
+  Convert: PConversionFormat;
+begin
+  Ext := AnsiLowerCaseFileName(ExtractFileExt(Filename));
+  System.Delete(Ext, 1, 1);
+  Convert := ConversionFormatList;
+  while Convert &lt;&gt; nil do
+    with Convert^ do
+      if Extension &lt;&gt; Ext then Convert := Next
+      else Break;
+  if Convert = nil then
+    Convert := @TextConversionFormat;
+  FConverter := Convert^.ConversionClass.Create;
+  try
+    inherited SaveToFile(FileName);
+  except
+    FConverter.Free;
+    FConverter := nil;
+    raise;
+  end;
+end;
+
+procedure TWideRichEditStrings98.AddStrings(Strings: TWideStrings);
+var
+  SelChange: TNotifyEvent;
+begin
+  SelChange := RichEdit.OnSelectionChange;
+  RichEdit.OnSelectionChange := nil;
+  try
+    inherited AddStrings(Strings);
+  finally
+    RichEdit.OnSelectionChange := SelChange;
+  end;
+end;
+
+function TWideRichEditStrings98.GetCount: Integer;
+begin
+  Result := RichEdit.Perform(EM_GETLINECOUNT, 0, 0);
+  if RichEdit.Perform(EM_LINELENGTH,
+    RichEdit.Perform(EM_LINEINDEX, Result - 1, 0), 0) = 0 then Dec(Result);
+end;
+
+function TWideRichEditStrings98.Get(Index: Integer): WideString;
+var
+  Text: array[0..4095] of WideChar;
+  L: Integer;
+begin
+  RichEdit.FWide:= True;
+  Word((@Text)^) := SizeOf(Text);
+  L := RichEdit.PrivatePerform(EM_GETLINE, Index, Longint(@Text));
+  if ((Text[L - 1] = #13) or (Text[L - 1] = #11)) then Dec(L, 1);  //CR or Shift-CR
+  SetString(Result, Text, L);
+  RichEdit.FWide:= False;
+end;
+
+procedure TWideRichEditStrings98.Put(Index: Integer; const S: WideString);
+var
+  Selection: TCharRange;
+begin
+  if Index &gt;= 0 then
+  begin
+    RichEdit.FWide:= True;
+    Selection.cpMin := RichEdit.Perform(EM_LINEINDEX, Index, 0);
+    if Selection.cpMin &lt;&gt; -1 then
+    begin
+      Selection.cpMax := Selection.cpMin +
+        RichEdit.Perform(EM_LINELENGTH, Selection.cpMin, 0);
+      RichEdit.Perform(EM_EXSETSEL, 0, Longint(@Selection));
+      // RichEdit.PrivatePerform(EM_REPLACESEL, 0, Longint(PChar(String(S)));
+      RichEdit.PrivatePerform(EM_REPLACESEL, 0, Longint(Addr(s)));
+    end;
+    RichEdit.FWide:= False;
+  end;
+end;
+
+procedure TWideRichEditStrings98.Insert(Index: Integer; const S: WideString);
+var
+  L: Integer;
+  Selection: TCharRange;
+  Str: WideString;
+begin
+  if Index &gt;= 0 then
+  begin
+    RichEdit.FWide:= True;
+    Selection.cpMin := RichEdit.Perform(EM_LINEINDEX, Index, 0);
+    if Selection.cpMin &gt;= 0 then
+      Str:= S+WideString(#13)
+    else begin
+      Selection.cpMin :=
+        RichEdit.Perform(EM_LINEINDEX, Index - 1, 0);
+      if Selection.cpMin &lt; 0 then Exit;
+      L := RichEdit.Perform(EM_LINELENGTH, Selection.cpMin, 0);
+      if L = 0 then Exit;
+      Inc(Selection.cpMin, L);
+      Str := WideString(#13)+S;
+    end;
+    Selection.cpMax := Selection.cpMin;
+    RichEdit.Perform(EM_EXSETSEL, 0, Longint(@Selection));
+    RichEdit.PrivatePerform(EM_REPLACESEL, 0, LongInt(@Str[1]));
+    if RichEdit.SelStart &lt;&gt; (Selection.cpMax + Length(Str)) then
+      raise EOutOfResources.Create(sRichEditInsertError);
+    RichEdit.FWide:= False;
+  end;
+end;
+
+procedure TWideRichEditStrings98.Delete(Index: Integer);
+const
+  Empty: PWideChar = '';
+var
+  Selection: TCharRange;
+begin
+  if Index &lt; 0 then Exit;
+  Selection.cpMin := RichEdit.Perform(EM_LINEINDEX, Index, 0);
+  if Selection.cpMin &lt;&gt; -1 then
+  begin
+    Selection.cpMax := RichEdit.Perform(EM_LINEINDEX, Index + 1, 0);
+    if Selection.cpMax = -1 then
+      Selection.cpMax := Selection.cpMin +
+        RichEdit.Perform(EM_LINELENGTH, Selection.cpMin, 0);
+    RichEdit.Perform(EM_EXSETSEL, 0, Longint(@Selection));
+    RichEdit.PrivatePerform(EM_REPLACESEL, 0, Longint(Empty));
+  end;
+end;
+
+procedure TWideRichEditStrings98.Clear;
+begin
+  RichEdit.Clear;
+end;
+
+procedure TWideRichEditStrings98.SetUpdateState(Updating: Boolean);
+begin
+  RichEdit.Perform(WM_SETREDRAW, Ord(not Updating), 0);
+  if not Updating then begin
+    RichEdit.Refresh;
+    RichEdit.PrivatePerform(CM_TEXTCHANGED, 0, 0);
+  end;
+end;
+
+procedure TWideRichEditStrings98.EnableChange(const Value: Boolean);
+var
+  EventMask: Longint;
+begin
+  with RichEdit do
+  begin
+    if Value then
+      EventMask := Perform(EM_GETEVENTMASK, 0, 0) or ENM_CHANGE
+    else
+      EventMask := Perform(EM_GETEVENTMASK, 0, 0) and not ENM_CHANGE;
+    Perform(EM_SETEVENTMASK, 0, EventMask);
+  end;
+end;
+
+procedure TWideRichEditStrings98.SetTextStr(const Value: WideString);
+begin
+  RichEdit.FWide:= True;
+  EnableChange(False);
+  try
+    inherited SetTextStr(Value);
+  finally
+    EnableChange(True);
+  end;
+  RichEdit.FWide:= False;
+end;
+{
+function TWideRichEditStrings98.GetPlainText: Boolean;
+begin
+  Result:= RichEdit.PlainText;
+end;
+
+procedure TWideRichEditStrings98.SetPlainText(Value: Boolean);
+begin
+  RichEdit.PlainText:= Value;
+end;
+}
+function TWideRichEditStrings98.GetInputFormat: TInputFormat;
+begin
+  Result:= RichEdit.InputFormat;
+end;
+
+procedure TWideRichEditStrings98.SetInputFormat(Value: TInputFormat);
+begin
+  RichEdit.InputFormat:= Value;
+end;
+
+function TWideRichEditStrings98.GetOutputFormat: TOutputFormat;
+begin
+  Result:= RichEdit.OutputFormat;
+end;
+
+procedure TWideRichEditStrings98.SetOutputFormat(Value: TOutputFormat);
+begin
+  RichEdit.OutputFormat:= Value;
+end;
+
+function TWideRichEditStrings98.GetSelectedInOut:Boolean;
+begin
+     Result:=RichEdit.SelectedInOut;
+end;
+
+procedure TWideRichEditStrings98.SetSelectedInOut(Value: Boolean);
+begin
+     RichEdit.SelectedInOut:=Value;
+end;
+
+function TWideRichEditStrings98.GetPlainRTF: Boolean;
+begin
+     Result:=RichEdit.PlainRTF;
+end;
+
+procedure TWideRichEditStrings98.SetPlainRTF(Value: Boolean);
+begin
+     RichEdit.PlainRTF:=Value;
+end;
+
+procedure TWideRichEditStrings98.LoadFromStream(Stream: TStream);
+begin
+  RichEdit.Lines.LoadFromStream(Stream);
+end;
+
+procedure TWideRichEditStrings98.SaveToStream(Stream: TStream);
+begin
+  RichEdit.Lines.SaveToStream(Stream);
+end;
+
+procedure TWideRichEditStrings98.LoadFromFile(const FileName: string);
+begin
+  RichEdit.Lines.LoadFromFile(FileName);
+end;
+
+procedure TWideRichEditStrings98.SaveToFile(const FileName: string);
+begin
+  RichEdit.Lines.SaveToFile(FileName);
+end;
+
+procedure TWideRichEditStrings98.SetLanguage(Value: TLanguage);
+begin
+  RichEdit.Language:= Value;
+end;
+
+function TWideRichEditStrings98.GetLanguage: TLanguage;
+begin
+  Result:= RichEdit.Language;
+end;
+
+
+
+
+
+{TURLType}
+procedure TURLType.Assign(Source: TPersistent);
+begin
+  if (Source is TURLType) then
+    begin
+      Name:= TURLType(Source).Name;
+      Color:= TURLType(Source).Color;
+      Cursor:= TURLType(Source).Cursor;
+      Underline:= TURLType(Source).Underline;
+    end;
+end;
+
+function TURLType.GetDisplayName: string;
+begin
+  Result:= Name;
+end;
+
+
+
+{TURLCollection}
+
+procedure TURLCollection.AddURLType(const Name: String; Color: TColor;
+                     Cursor: TCursor; Underline: Boolean);
+var
+  Item: TURLType;
+  I: INteger;
+begin
+  for I:= 0 to Count-1 do
+    begin
+      Item:= Items[I];
+      if Item.Name=Name then
+        begin
+          Item.Color:= Color;
+          Item.Cursor:= Cursor;
+          Item.Underline:= Underline;
+          Exit;
+        end;
+    end;
+  Item:= TURLType(Add);
+  Item.Name:= Name;
+  Item.Color:= Color;
+  Item.Cursor:= Cursor;
+  Item.Underline:= Underline;
+end;
+
+function TURLCollection.GetOwner: TPersistent;
+begin
+  Result:= FOwner;
+end;
+
+procedure TURLCollection.SetItems(Index: Integer; Value: TURLType);
+begin
+  if (Index&gt;-1) and (Index&lt;Count) then
+    Items[Index].Assign(Value);
+end;
+
+function TURLCollection.GetItems(Index: Integer): TURLType;
+begin
+  Result:= TURLType(inherited Items[Index]);
+end;
+
+
+
+
+
+{ TCustomRichEdit98 }
+
+constructor TCustomRichEdit98.Create(AOwner: TComponent);
+var
+  DC: HDC;
+begin
+  FUpdateCount:= 0;
+  FShowSelBar:= False;
+  FLangOptions:= [loAutoFont];
+  inherited Create(AOwner);
+  FSelAttributes := TTextAttributes98.Create(Self, atSelected);
+  FDefAttributes := TTextAttributes98.Create(Self, atDefaultText);
+  FParagraph := TParaAttributes98.Create(Self);
+  FRichEditStrings:= TRichEditStrings98.Create;
+  TRichEditStrings98(FRichEditStrings).RichEdit := Self;
+  FWideStrings := TWideRichEditStrings98.Create;
+  TWideRichEditStrings98(FWideStrings).RichEdit := Self;
+  DC := GetDC(0);
+  FScreenLogPixels := GetDeviceCaps(DC, LOGPIXELSY);
+  ReleaseDC(0, DC);
+  FWide:= False;
+  FWordFormatting:= True;
+  Language:= GetSystemDefaultLCID;
+  FURLs:= TURLCollection.Create(TURLType);
+  FURLs.FOwner:= Self;
+  FURLs.AddURLType('e-mail', clWindowText, crDefault, True);
+  FURLs.AddURLType('http', clWindowText, crDefault, True);
+  FURLs.AddURLType('file', clWindowText, crDefault, True);
+  FURLs.AddURLType('mailto', clWindowText, crDefault, True);
+  FURLs.AddURLType('ftp', clWindowText, crDefault, True);
+  FURLs.AddURLType('https', clWindowText, crDefault, True);
+  FURLs.AddURLType('gopher', clWindowText, crDefault, True);
+  FURLs.AddURLType('nntp', clWindowText, crDefault, True);
+  FURLs.AddURLType('prospero', clWindowText, crDefault, True);
+  FURLs.AddURLType('telnet', clWindowText, crDefault, True);
+  FURLs.AddURLType('news', clWindowText, crDefault, True);
+  FURLs.AddURLType('wais', clWindowText, crDefault, True);
+  FURLColor:= clBlue;
+  FURLCursor:= crHandpoint;
+  FStreamSel:= False;
+  FCROld.cpMin:= 0;
+  FCROld.cpMax:= 0;
+
+  FAutoVerbMenu:= true;
+  FPlainTextIn:= ifRTF;
+  FPlainTextOut:= ofRTF;
+  FPlainRTF:= False;
+  FSelectedInOut:= False;
+
+  FIncludeOLE:= False;
+end;
+
+destructor TCustomRichEdit98.Destroy;
+begin
+  FSelAttributes.Free;
+  FDefAttributes.Free;
+  FParagraph.Free;
+  FRichEditStrings.Free;
+  FWideStrings.Free;
+  FURLs.Free;
+
+  DestroyVerbs;
+
+  inherited Destroy;
+end;
+
+{$WARNINGS OFF}
+function TCustomRichEdit98.ObjectSelected:Boolean;
+var ReObject:TReObject;
+begin
+  Exit;
+  ReObject.cbStruct:= sizeof(TReObject);
+  result:=(RichEditOle.GetObject(REO_IOB_SELECTION, ReObject, REO_GETOBJ_POLEOBJ) = S_OK) and
+          Assigned(ReObject.oleobj);
+end;
+{$WARNINGS ON}
+
+procedure TCustomRichEdit98.CreateParams(var Params: TCreateParams);
+const
+  RichEditModuleName = 'RICHED20.DLL';
+  ControlClassName = 'RICHEDIT20W';
+  CS_OFF = CS_OWNDC or CS_CLASSDC or CS_PARENTDC or CS_GLOBALCLASS;
+  CS_ON = CS_VREDRAW or CS_HREDRAW;
+var
+  OldError: Longint;
+  WCW: TWndClassW;
+  WCA: TWndClassA;
+begin
+  OldError := SetErrorMode(SEM_NOOPENFILEERRORBOX);
+  FLibHandle := LoadLibrary(RichEditModuleName);
+  FVer10:= False;
+  if (FLibHandle &gt; 0) and (FLibHandle &lt; HINSTANCE_ERROR) then
+    FLibHandle := 0;
+  if FLibHandle=0 then
+    begin
+      FVer10:= True;
+      IsWinNT:= False;
+      inherited CreateParams(Params);
+      Exit;
+    end;
+  SetErrorMode(OldError);
+  if IsWinNT then
+    begin
+      GetClassInfoW(HInstance, ControlClassName, WCW);
+      FDefWndProcW:= WCW.lpfnWndProc;
+    end
+  else
+  GetClassInfoA(HInstance, ControlClassName, WCA);
+  FDefWndProcA:= WCA.lpfnWndProc;
+  inherited CreateParams(Params);
+//  Params.Style:= Params.Style or ES_SAVESEL;
+  Params.Style:= Params.Style or WS_CHILD or WS_CLIPCHILDREN or WS_CLIPSIBLINGS or ES_SAVESEL;
+  CreateSubClass(Params, ControlClassName);
+end;
+
+procedure TCustomRichEdit98.CreateWnd;
+var
+  Opt: Integer;
+begin
+  inherited CreateWnd;
+  SendMessage(Handle, EM_SETEVENTMASK, 0,
+    ENM_CHANGE or ENM_SELCHANGE or ENM_REQUESTRESIZE or
+    ENM_PROTECTED or ENM_LINK);
+  SendMessage(Handle, EM_AUTOURLDETECT, Ord(AutoURLDetect=adDefault), 0);
+  Opt:= Perform(EM_GETOPTIONS, 0, 0);
+  if FShowSelBar then
+    Opt:= Opt or ECO_SELECTIONBAR
+  else
+    Opt:= Opt and not ECO_SELECTIONBAR;
+  Perform(EM_SETOPTIONS, ECOOP_SET, Opt);
+  SetShowSelBar(FShowSelBar);
+  Perform(EM_SETLANGOPTIONS, 0, Byte(FLangOptions));
+
+  { Making tons of Access violation in RICHEDIT20.dll
+
+  if FIncludeOLE then
+    begin
+      if not RichEdit_GetOleInterface(Handle, RichEditOle) then
+        raise Exception.Create('Unable to get interface');
+      if not RichEdit_SetOleCallback(Handle, RichEditOlecallback) then
+        raise Exception.Create('Unable to set callback');
+    end;}
+end;
+
+procedure TCustomRichEdit98.CreateWindowHandle(const Params: TCreateParams);
+var
+  WCN: WideString;
+  P: TCreateParams;
+begin
+  if IsWinNT then
+    with Params do
+      begin
+        WCN:= WinClassName;
+        WindowHandle:= CreateWindowExW(ExStyle, @WCN[1], nil, Style,
+        X, Y, Width, Height, WndParent, 0, WindowClass.hInstance, Param);
+      end
+  else
+    begin
+      Move(Params, P, SizeOf(Params));
+      P.Caption:= nil;
+      inherited CreateWindowHandle(P);
+    end;
+end;
+
+procedure TCustomRichEdit98.CreateOLEObjectInterface;
+begin
+  RichEditOleCallback := TRichEditOleCallback.Create(Self);
+end;
+
+(*{procedure TCustomRichEdit98.CloseOLEObjects;                      {!!0.01 -- added method}
+var i: integer;
+    REObject: TREObject;
+begin
+  if not Assigned(RichEditOle) then Exit;
+  fillchar(REObject, sizeof(REObject), 0);
+  REObject.cbStruct:= sizeof(REObject);
+  for i:= 0 to Pred(RichEditOle.GetObjectCount) do begin
+    if RichEditOle.GetObject(i, REObject, REO_GETOBJ_POLEOBJ) = S_OK then
+      REObject.oleobj.Close(OLECLOSE_NOSAVE);
+  end;
+end;*)
+
+procedure TCustomRichEdit98.CloseOLEObjects; {!!0.01 -- added method}
+var
+  I: Integer;
+  ReObject: TReObject;
+begin
+  Exit;
+  if not Assigned(RichEditOle) then Exit;
+  if FSelObject&lt;&gt;nil then
+    begin
+      FSelObject.Close(OLECLOSE_NOSAVE);     /// very important
+      FSelObject:= nil;
+    end;
+  FillChar(ReObject, SizeOf(ReObject), 0);
+  ReObject.cbStruct := SizeOf(ReObject);
+  for I := 1 to RicheditOle.GetObjectCount do
+    if RichEditOle.GetObject(I, ReObject, REO_GETOBJ_POLEOBJ) = S_OK then
+      ReObject.oleobj.CLOSE(OLECLOSE_NOSAVE);
+end;
+
+procedure TCustomRichEdit98.WMNCDestroy(var Message: TWMNCDestroy);
+begin
+  inherited;
+  if FLibHandle &lt;&gt; 0 then FreeLibrary(FLibHandle);
+end;
+
+procedure TCustomRichEdit98.WMDestroy(var Msg: TMessage); {!!0.01 -- changed from WM_NCDESTROY}
+begin
+  CloseOLEObjects;                                {!!0.01}
+  RichEditOle:= nil;
+  inherited;
+end;
+
+procedure TCustomRichEdit98.EMReplaceSel(var Message: TMessage);
+var
+  W: WideString;
+begin
+  if not FWide then
+    begin
+      W:= CharToWide(PChar(Message.LParam), FCP);
+      if (Length(W) &gt; 0) then
+        Message.LParam := Integer(@W[1])
+      else
+        Message.LParam := 0;
+    end;
+  Message.WParam:= 1;
+  Message.Result:= PrivatePerform(Message.Msg, Message.WParam, Message.LParam);
+end;
+
+procedure TCustomRichEdit98.EMGetSelText(var Message: TMessage);
+var
+  W: WideString;
+  P: PChar;
+  L: Integer;
+begin
+  if SelLength=0 then
+    begin
+      Message.Result:= 0;
+      Exit;
+    end;
+  if not FWide then begin
+      P:= PChar(Message.LParam);
+      L:= SelLength;
+      SetLength(W, L);
+      Message.LParam:= Integer(@W[1]);
+      Message.Result:= PrivatePerform(Message.Msg, Message.WParam, Message.LParam);
+      WideCharToMultiByte(FCP, 0, @W[1], -1, P, L, nil, nil);
+      Message.LParam:= Integer(P);
+      end
+  else
+    Message.Result:= PrivatePerform(Message.Msg, Message.WParam, Message.LParam);
+end;
+
+procedure TCustomRichEdit98.EMGetTextRange(var Message: TMessage);
+var
+  W: WideString;
+  P: PChar;
+type
+  PTextRange = ^TTextRange;
+begin
+  if not FWide then begin
+     with PTextRange(Message.LParam)^ do begin
+        P:= lpstrText;
+        SetLength(W, Abs(chrg.cpMax - chrg.cpMin));
+        lpstrText:= PChar(@W[1]);
+        end;
+     Message.Result:= PrivatePerform(Message.Msg, Message.WParam, Message.LParam);
+     with PTextRange(Message.LParam)^ do begin
+        StrPCopy(P, WideToChar(W, FCP));
+        lpstrText:= P;
+        end;
+     end
+  else
+    Message.Result:= PrivatePerform(Message.Msg, Message.WParam, Message.LParam);
+end;
+
+procedure TCustomRichEdit98.Clear; {!!0.01 -- overriden to close objects}
+begin
+  CloseOLEObjects;
+  inherited Clear;
+end;
+
+const
+  URLChars = ['0'..'9', 'A'..'Z', 'a'..'z', ':', '.', '/', '\', '@'];
+
+procedure TCustomRichEdit98.FindNonSpace(var CR: TCharRange);
+var
+  TRS: TTextRange;
+  C: packed array[0..1]of Char;
+  L: Integer;
+begin
+  L:= GetWindowTextLength(Handle);
+  if CR.cpMin&gt;=L then
+    CR.cpMin:= L-1;
+  TRS.chrg.cpMin:= CR.cpMin;
+  TRS.chrg.cpMax:= CR.cpMin+1;
+  TRS.lpstrText:= @C[0];
+  while (TRS.chrg.cpMin&gt;0) do
+    begin
+      Perform(EM_GETTEXTRANGE, 0, Integer(@TRS));
+      if not (C[0] in URLChars) then
+        Break;
+      Dec(TRS.chrg.cpMin);
+      Dec(TRS.chrg.cpMax);
+    end;
+  CR.cpMin:= TRS.chrg.cpMin;
+  Perform(EM_GETTEXTRANGE, 0, Integer(@TRS));
+  if not (C[0] in URLChars) then
+    Inc(CR.cpMin);
+  if CR.cpMax&gt;=L then
+    Exit;
+  TRS.chrg.cpMin:= CR.cpMax;
+  TRS.chrg.cpMax:= CR.cpMax+1;
+  C:= '.';
+  while (TRS.chrg.cpMin&lt;=L) and (C[0] in URLChars) do
+    begin
+      Perform(EM_GETTEXTRANGE, 0, Integer(@TRS));
+      Inc(TRS.chrg.cpMin);
+      Inc(TRS.chrg.cpMax);
+    end;
+  CR.cpMax:= TRS.chrg.cpMin-1;
+end;
+
+procedure TCustomRichEdit98.DetectURLs(CR: TCharRange);
+var
+  P1, P2: Integer;
+  Word: String;
+  I, N: Integer;
+  URL, S: String;
+  TR: TTextRange;
+  OC,
+  OSC: TNotifyEvent;
+  Start: Integer;
+  B: Boolean;
+  URLType: TURLType;
+  FW: Boolean;
+begin
+  FW:= FWide;
+  FWide:= False;
+  TR.chrg:= CR;
+  FindNonSpace(TR.chrg);
+  if (TR.chrg.cpMin&gt;TR.chrg.cpMax) or (GetWindowTextLength(Handle)&lt;3) then
+    Exit;
+  BeginUpdate;
+  if TR.chrg.cpMin=TR.chrg.cpMax then
+    S:= WideText
+  else
+    begin
+      SetLength(S, TR.chrg.cpMax-TR.chrg.cpMin);
+      TR.lpstrText:= @S[1];
+      Perform(EM_GETTEXTRANGE, 0, Integer(@TR));
+    end;
+  FWide:= FW;
+  S:= AnsiUpperCase(S);
+  OC:= OnChange;
+  OSC:= OnSelectionChange;
+  OnChange:= nil;
+  OnSelectionChange:= nil;
+  Start:= TR.chrg.cpMin;
+  P1:= 1;
+  repeat
+    P2:= P1;
+    repeat
+      Inc(P2)
+    until not (S[P2] in URLChars);
+    Word:= Copy(S, P1, P2-P1);
+    I:= 1;
+    repeat
+      URLType:= FURLs[I];
+      URL:= AnsiUpperCase(URLType.Name+':');
+      B:= (AnsiPos(URL, Word)=1) and (Length(Word)&gt;Length(URL));
+      Inc(I);
+    until (I=FURLs.Count) or B;
+    if not B then
+      begin
+        N:= AnsiPos('@', Word);
+        B:= (N&gt;1) and (N&lt;Length(Word)) and (AnsiPos('.', Copy(Word, N+1, MaxInt))&gt;1);
+        URLType:= FURLs[0];
+      end;
+    CR.cpMin:= Start+P1-1;
+    CR.cpMax:= Start+P2-1;
+    Perform(EM_EXSETSEL, 0, Integer(@CR));
+    if B then
+      begin
+        SelAttributes.IsURL:= True;
+        if URLType.Color=clWindowText then
+          SelAttributes.Color:= URLColor
+        else
+          SelAttributes.Color:= URLType.Color;
+        SelAttributes.UnderlineType:= TUnderlineType(URLType.Underline);
+      end
+    else
+      begin
+        SelAttributes.IsURL:= False;
+        SelAttributes.Color:= clDefault;
+        SelAttributes.UnderlineType:= ultNone;
+      end;
+    P1:= P2;
+    if S[P1]=#0 then
+      Break;
+    repeat
+      Inc(P1);
+    until S[P1] in URLChars+[#0];
+  until S[P1]  in [#0..' '];
+
+  EndUpdate;
+  OnChange:= OC;
+  OnSelectionChange:= OSC;
+end;
+
+procedure TCustomRichEdit98.EMGetLine(var Message: TMessage);
+var
+  W: WideString;
+  P: PChar;
+  L: ^Word;
+begin
+  if not FWide then begin
+      P:= PChar(Message.LParam);
+      L:= Pointer(P);
+      SetLength(W, L^);
+      Message.LParam:= Integer(@W[1]);
+      W[1]:= WideChar(L^);
+      Message.Result:= PrivatePerform(Message.Msg, Message.WParam, Message.LParam);
+      StrPCopy(P, WideToChar(W, FCP));
+      Message.LParam:= Integer(P);
+    end
+  else
+    Message.Result:= PrivatePerform(Message.Msg, Message.WParam, Message.LParam);
+end;
+
+procedure TCustomRichEdit98.EMStreamIn(var Message: TMessage);
+begin
+  if FStreamSel then
+    Message.WParam:= Message.WParam or SFF_SELECTION;
+  inherited;
+end;
+
+procedure TCustomRichEdit98.EMStreamOut(var Message: TMessage);
+begin
+  if FStreamSel then
+    Message.WParam:= Message.WParam or SFF_SELECTION;
+  inherited;
+end;
+
+procedure TCustomRichEdit98.WMSetText(var Message: TWMSetText);
+var
+  W: WideString;
+begin
+  if (csDesigning in ComponentState) then
+    Message.Text:= nil
+  else if not FWide then
+    begin
+      W:= CharToWide(Message.Text, FCP);
+      if W&lt;&gt;'' then
+        Message.Text:= @W[1];
+    end;
+  Message.Result:= PrivatePerform(Message.Msg, Message.Unused, Integer(Message.Text));
+end;
+
+procedure TCustomRichEdit98.WMGetTextLength(var Message: TWMGetTextLength);
+var
+  GTL: TGetTextLengthEx;
+begin
+  GTL.flags:= GTL_DEFAULT;
+  GTL.codepage:= 1200;
+  Message.Result:= Perform(EM_GETTEXTLENGTHEX, Integer(@GTL), 0);
+end;
+
+procedure TCustomRichEdit98.WMGetText(var Message: TWMGetText);
+var
+  W: WideString;
+  P: PChar;
+  L: Integer;
+begin
+  if FWide then
+    begin
+      P:= Message.Text;
+      L:= Perform(WM_GETTEXTLENGTH, 0, 0);
+      SetLength(W, L);
+      Message.Text:= @W[1];
+      GetWindowTextW(Handle, @W[1], L);
+      StrPCopy(P, WideToChar(W, FCP));
+      Message.Text:= P;
+    end
+  else
+    inherited;
+end;
+
+procedure TCustomRichEdit98.WMSetFont(var Message: TWMSetFont);
+begin
+  FDefAttributes.Assign(Font);
+end;
+
+procedure TCustomRichEdit98.CNCommand(var Message: TWMCommand);
+var
+  CR, CRMax: TCharRange;
+begin
+  if not (csLoading in ComponentState) and not (csReading in ComponentState) and
+     (AutoURLDetect=adExtended) and (FURLs.Count&gt;0) and (Message.NotifyCode = EN_CHANGE) and
+     (FUpdateCount=0) then
+    begin
+      Perform(EM_EXGETSEL, 0, Integer(@CR));
+      CRMax:= CR;
+      if FCROld.cpMin&lt;CR.cpMin then
+        CRMax.cpMin:= FCROld.cpMin;
+      if FCROld.cpMax&gt;CR.cpMax then
+        CRMax.cpMax:= FCROld.cpMax;
+      DetectURLs(CRMax);
+      FCROld:= CR;
+    end;
+  inherited;
+end;
+
+procedure TCustomRichEdit98.CNNotify(var Message: TWMNotify);
+type
+  PENLink = ^TENLink;
+var
+  URL: String;
+  P: Integer;
+  URLType: TURLType;
+  I: Integer;
+  Cr: TCursor;
+begin
+  case Message.NMHdr^.code of
+  EN_LINK:
+    with PENLink(Pointer(Message.NMHdr))^ do
+      begin
+        URLType := nil;
+        FWide:= False;
+        URL:= WideText;
+        // URL:= Copy(URL, chrg.cpMin + 1, chrg.cpMax - chrg.cpMin {+ 1});
+        URL := Copy(WideText, chrg.cpMin + 1, chrg.cpMax - chrg.cpMin { + 1});
+        P:= Pos(':', URL);
+        if P&gt;1 then
+          for I:= 1 to FURLs.Count-1 do
+            begin
+              URLType:= FURLs[I];
+              if URLType.Name=AnsiLowerCase(Copy(URL, 1, P-1)) then
+                Break;
+            end
+        else if Pos('@', URL)&gt;1 then
+          URLType:= FURLs[0];
+        case msg of
+        WM_LBUTTONUP:
+          if Assigned(FOnURLClick) and (Length(URL)&gt;1) then
+            FOnURLClick(Self, URL);
+        WM_MOUSEMOVE:
+          begin
+            if (URLType &lt;&gt; nil) then begin
+                if URLType.Cursor=crDefault then
+                  if URLCursor=crDefault then
+                    CR:= crHandPoint
+                  else
+                    CR:= URLCursor
+                else
+                  Cr:= URLType.Cursor;
+                end
+            else
+                CR := crHandPoint;
+                
+            Windows.SetCursor(Screen.Cursors[Cr]);
+            if Assigned(FOnURLMove) and (Length(URL)&gt;1) then
+              FOnURLMove(Self, URL);
+          end;
+        end;
+      end;
+  else
+    inherited;
+  end;
+end;
+
+procedure TCustomRichEdit98.SetRichEditStrings(Value: TStrings);
+begin
+  FRichEditStrings.Assign(Value);
+end;
+
+procedure TCustomRichEdit98.SetSelAttributes(Value: TTextAttributes98);
+begin
+  SelAttributes.Assign(Value);
+end;
+
+procedure TCustomRichEdit98.SetDefAttributes(Value: TTextAttributes98);
+begin
+  DefAttributes.Assign(Value);
+end;
+
+function TCustomRichEdit98.GetLine: Integer;
+begin
+  Result:= Perform(EM_EXLINEFROMCHAR, 0, -1);
+end;
+
+procedure TCustomRichEdit98.SetLine(Value: Integer);
+begin
+  SetCaret(Value, Col);
+end;
+
+function TCustomRichEdit98.GetColumn: Integer;
+begin
+  Result:= SelStart - Perform(EM_LINEINDEX, -1, 0);
+end;
+
+procedure TCustomRichEdit98.SetColumn(Value: Integer);
+begin
+  SetCaret(Line, Value);
+end;
+
+procedure TCustomRichEdit98.SetCaret(Line, Column: Integer);
+var
+  L: Integer;
+begin
+  L:= Perform(EM_LINEINDEX, Line, 0);
+  if L&lt;0 then
+    Exit;
+  SelStart:= L+Column;
+end;
+
+procedure TCustomRichEdit98.SetShowSelBar(Value: Boolean);
+var
+  Opt: Integer;
+begin
+  if FShowSelBar&lt;&gt;Value then
+    begin
+      FShowSelBar:= Value;
+      Opt:= Perform(EM_GETOPTIONS, 0, 0);
+      if Value then
+        Opt:= Opt or ECO_SELECTIONBAR
+      else
+        Opt:= Opt and not ECO_SELECTIONBAR;
+      RecreateWnd;
+      Perform(EM_SETOPTIONS, ECOOP_SET, Opt);
+    end;
+end;
+
+function TCustomRichEdit98.CanUndo: Boolean;
+begin
+  Result:= Perform(EM_CANUNDO, 0, 0)&lt;&gt;0;
+end;
+
+procedure TCustomRichEdit98.Undo;
+begin
+  Perform(EM_UNDO, 0, 0);
+end;
+
+function TCustomRichEdit98.UndoName: TUndoName;
+begin
+  Result:= TUndoName(Perform(EM_GETUNDONAME, 0, 0));
+end;
+
+function TCustomRichEdit98.CanRedo: Boolean;
+begin
+  Result:= Perform(EM_CANREDO, 0, 0)&lt;&gt;0;
+end;
+
+procedure TCustomRichEdit98.Redo;
+begin
+  Perform(EM_REDO, 0, 0);
+end;
+
+function TCustomRichEdit98.RedoName: TUndoName;
+begin
+  Result:= TUndoName(Perform(EM_GETREDONAME, 0, 0));
+end;
+
+procedure TCustomRichEdit98.SetUndoLimit(Value: Integer);
+begin
+  FUndoLimit:= Value;
+  Perform(EM_SETUNDOLIMIT, Value, 0);
+end;
+
+procedure TCustomRichEdit98.SetAutoURLDetect(Value: TAutoURLDetect);
+begin
+  FAutoURLDetect:= Value;
+  Perform(EM_AUTOURLDETECT, Ord(Value=adDefault), 0)
+end;
+
+function TCustomRichEdit98.GetFirstVisibleLine: Integer;
+begin
+  Result:= Perform(EM_GETFIRSTVISIBLELINE, 0, 0);
+end;
+
+procedure TCustomRichEdit98.SetLanguage(Value: Tlanguage);
+begin
+  FLanguage:= Value;
+  FCP:= CodePageFromLocale(Value);
+end;
+
+procedure TCustomRichEdit98.CMFontChanged(var Message: TMessage);
+begin
+  FDefAttributes.Assign(Font);
+end;
+
+function TCustomRichEdit98.GetWordAtPos(Pos: Integer; var Start, Len: Integer): String;
+var
+  TR: TTextRange;
+begin
+  Start:= Perform(EM_FINDWORDBREAK, WB_LEFT, Pos);
+  Len:= Perform(EM_FINDWORDBREAK, WB_RIGHTBREAK, Pos) - Start;
+  TR.chrg.cpMin:= Start;
+  TR.chrg.cpMax:= Start+Len;
+  TR.lpstrText:= PChar(AllocMem(Len+1));
+  Perform(EM_GETTEXTRANGE, 0, LParam(@TR));
+  SetString(Result, TR.lpstrText, Len);
+  FreeMem(TR.lpstrText);
+end;
+
+procedure TCustomRichEdit98.SetCustomURLs(Value: TURLCollection);
+var
+  I: Integer;
+  Item: TURLType;
+begin
+  FURLS.Clear;
+  if Assigned(Value) then
+    for I:= 0 to Value.Count-1 do
+      begin
+        Item:= Value[I];
+        with Item do
+          FURLs.AddURLType(Name, Color, Cursor, Underline);
+      end;
+end;
+
+procedure TCustomRichEdit98.DefineProperties(Filer: TFiler);
+begin
+  Filer.DefineProperty('RTF', ReadData, WriteData, Perform(WM_GETTEXTLENGTH, 0, 0)&gt;0);
+end;
+
+procedure TCustomRichEdit98.ReadData(Reader: TReader);
+var
+  MS: TMemoryStream;
+  S: String;
+  OSC,
+  OC: TNotifyEvent;
+begin
+  MS := nil;
+  OSC := nil;
+  OC := nil;
+  try
+    OSC:= OnSelectionChange;
+    OC:= OnChange;
+    OnSelectionChange:= nil;
+    OnChange:= nil;
+    Clear;
+    DefAttributes.Assign(Font);
+    MS:= TMemoryStream.Create;
+    S:= Reader.ReadString;
+    MS.Write(S[1], Length(S));
+    MS.Position:= 0;
+    Lines.LoadFromStream(MS);
+  finally
+    if (MS &lt;&gt; nil) then
+        MS.Free;
+    if (Assigned(OSC)) then OnSelectionChange:= OSC;
+    if (Assigned(OC)) then OnChange:= OC;
+  end;
+end;
+
+procedure TCustomRichEdit98.WriteData(Writer: TWriter);
+var
+  MS: TMemoryStream;
+  C: Char;
+begin
+  if Perform(WM_GETTEXTLENGTH, 0, 0)=0 then
+    Exit;
+  MS:= TMemoryStream.Create;
+  Lines.SaveToStream(MS);
+  C:= #0;
+  MS.Write(C, 1);
+  Writer.WriteString(PChar(MS.Memory));
+  MS.Free;
+end;
+
+procedure TCustomRichEdit98.SetWideText(Value: WideString);
+begin
+  FWide:= True;
+//  SetWindowTextW(Handle, @Value[1]);
+  SendMessage(Handle, WM_SETTEXT, 0, Integer(@Value[1]));
+  FWide:= False;
+end;
+
+function TCustomRichEdit98.GetWideText: WideString;
+var
+  GTL: TGetTextLengthEx;
+  GT: TGetTextEx;
+  L: Integer;
+begin
+  GTL.flags:= GTL_DEFAULT;
+  GTL.codepage:= 1200;
+  L:= Perform(EM_GETTEXTLENGTHEX, Integer(@GTL), 0);
+  SetLength(Result, L);
+  GT.cb:= L*2+2;
+  GT.flags:= GT_DEFAULT;
+  GT.codepage:= 1200;
+  GT.lpDefaultChar:= nil;
+  GT.lpUsedDefChar:= nil;
+  PrivatePerform(EM_GETTEXTEX, Integer(@GT), Integer(@Result[1]));
+end;
+
+procedure TCustomRichEdit98.SetRTFSelText(Value: String);
+var
+  MS: TMemoryStream;
+  OldFormat: TInputFormat;
+begin
+  MS:= TMemoryStream.Create;
+  MS.Write(Value[1], Length(Value)+1);
+  MS.Position:= 0;
+  FStreamSel:= True;
+  OldFormat:= InputFormat;
+  InputFormat:= ifRTF;
+  Lines.LoadFromStream(MS);
+  InputFormat:= OldFormat;
+  FStreamSel:= False;
+  MS.Free;
+end;
+
+function TCustomRichEdit98.GetRTFSelText: String;
+var
+  MS: TMemoryStream;
+  OldFormat: TOutputFormat;
+begin
+  MS:= TMemoryStream.Create;
+  FStreamSel:= True;
+  OldFormat:= OutputFormat;
+  OutputFormat:= ofRTF;
+  Lines.SaveToStream(MS);
+  OutputFormat:= OldFormat;
+  FStreamSel:= False;
+  Result:= PChar(MS.Memory);
+  MS.Free;
+end;
+
+procedure TCustomRichEdit98.InsertFromFile(const FileName: String);
+begin
+  FStreamSel:= True;
+  Lines.LoadFromFile(FileName);
+  FStreamSel:= False;
+end;
+
+function TCustomRichEdit98.GetWideSelText: WideString;
+var
+  Length: Integer;
+begin
+  FWide:= True;
+  SetLength(Result, SelLength + 1);
+  Length := Perform(EM_GETSELTEXT, 0, Longint(@Result[1]));
+  SetLength(Result, Length);
+  FWide:= False;
+end;
+
+procedure TCustomRichEdit98.SetWideSelText(Value: WideString);
+begin
+  FWide:= True;
+
+  // pgm 5/8/02 - Fix range-check error for empty strings.
+  if (Length(Value) = 0) then exit;
+
+  Perform(EM_REPLACESEL, 1, Integer(@Value[1]));
+  FWide:= False;
+end;
+
+function TCustomRichEdit98.FindText(const SearchStr: string;
+  StartPos, Length: Integer; Options: TSearchTypes98): Integer;
+var
+  Find: TFindTextExW;
+  Flags: Integer;
+  W: WideString;
+begin
+  with Find.chrg do
+  begin
+    cpMin := StartPos;
+    if Length&gt;0 then
+      if stBackward in Options then
+        cpMax:= cpMin - Length
+      else
+        cpMax := cpMin + Length
+    else
+      cpMax:= -1;
+  end;
+  Flags := FT_DOWNWARD;
+  if stBackward in Options then Flags := Flags and not FT_DOWNWARD;
+  if stWholeWord in Options then Flags := Flags or FT_WHOLEWORD;
+  if stMatchCase in Options then Flags := Flags or FT_MATCHCASE;
+  W:= CharToWide(SearchStr, FCP);
+  Find.lpstrText := @W[1];
+  Result := SendMessage(Handle, EM_FINDTEXTEX, Flags, LongInt(@Find));
+end;
+
+function TCustomRichEdit98.FindWideText(const SearchStr: WideString;
+  StartPos, Length: Integer; Options: TSearchTypes98): Integer;
+var
+  Find: TFindTextExW;
+  Flags: Integer;
+begin
+  with Find.chrg do
+  begin
+    cpMin := StartPos;
+    if Length&gt;0 then
+      if stBackward in Options then
+        cpMax:= cpMin - Length
+      else
+        cpMax := cpMin + Length
+    else
+      cpMax:= -1;
+  end;
+  Flags := FT_DOWNWARD;
+  if stBackward in Options then Flags := Flags and not FT_DOWNWARD;
+  if stWholeWord in Options then Flags := Flags or FT_WHOLEWORD;
+  if stMatchCase in Options then Flags := Flags or FT_MATCHCASE;
+  Find.lpstrText := @SearchStr[1];
+  Result := SendMessage(Handle, EM_FINDTEXTEX, Flags, LongInt(@Find));
+end;
+
+procedure TCustomRichEdit98.SetLangOptions(Value: TLangOptions);
+var
+  LO: Byte;
+begin
+  FLangOptions:= Value;
+  Lo:= Byte(Value);
+  Perform(EM_SETLANGOPTIONS, 0, LO);
+end;
+
+function TCustomRichEdit98.PrivatePerform(Msg: Cardinal; WParam, LParam: Longint): Longint;
+begin
+  Result := 0;
+  if HandleAllocated then
+    if IsWinNT {and FWide }then
+      Result:= CallWindowProcW(FDefWndProcW, Handle, Msg, Wparam, Lparam)
+    else
+      Result:= CallWindowProcA(FDefWndProcA, Handle, Msg, Wparam, Lparam)
+end;
+
+procedure TCustomRichEdit98.BeginUpdate;
+begin
+  Inc(FUpdateCount);
+  Perform(WM_SETREDRAW, 0, 0);
+  FStoreSS:= SelStart;
+  FStoreSL:= SelLength;
+  FStoreFVL:= FirstVisibleLine;
+end;
+
+procedure TCustomRichEdit98.EndUpdate;
+begin
+  if FUpdateCount&gt;0 then
+    Dec(FUpdateCount);
+  if FUpdateCount=0 then
+    begin
+      SelStart:= FStoreSS;
+      SelLength:= FStoreSL;
+      while FirstVisibleLine&lt;&gt;FStoreFVL do
+        if FirstVisibleLine&lt;FStoreFVL then
+          Perform(EM_SCROLL, SB_LINEDOWN, 0)
+        else
+          Perform(EM_SCROLL, SB_LINEUP, 0);
+      Perform(WM_SETREDRAW, 1, 0);
+      Repaint;
+    end;
+end;
+
+procedure TCustomRichEdit98.WMPaint(var Message: TWMPaint);
+begin
+  if FUpdateCount=0 then
+    inherited
+  else
+    Message.Result:= 0;
+end;
+
+function TCustomRichEdit98.CharAtPos(Pos: TPoint): Integer;
+begin
+  Result:= Perform(EM_CHARFROMPOS, 0, Integer(@Pos));
+end;
+
+procedure TCustomRichEdit98.SetIncludeOLE(Value:Boolean);
+begin
+ FIncludeOLE := Value;
+ if Value then CreateOLEObjectInterface;
+ ReCreateWnd;
+end;
+
+{$WARNINGS OFF}
+function TCustomRichEdit98.GetPopupMenu: TPopupMenu;
+var
+  I: Integer;
+  Item: TMenuItem;
+  ReObject: TReObject;
+begin
+  Result := inherited GetPopupMenu;
+  if FAutoVerbMenu and Assigned(RichEditOle) then begin
+    ReObject.cbStruct:= sizeof(TReObject);
+    {if an object is selected, get its IOLEObject interface}
+    if (RichEditOle.GetObject(REO_IOB_SELECTION, ReObject, REO_GETOBJ_POLEOBJ) &lt;&gt; S_OK) or
+          not Assigned(ReObject.oleobj) then begin
+      {no object selected -- clean up any previous object info}
+      FSelObject:= nil;
+      DestroyVerbs;
+    end
+    else
+      if FSelObject = ReObject.oleobj then
+        {same object selected -- use already allocated menu}
+        Result:= FPopupVerbMenu
+//        if Result=nil then begin
+      else begin
+        {new object selected -- create a menu for it}
+        FSelObject:= ReObject.oleobj;
+        UpdateVerbs;
+        if FObjectVerbs.Count = 0 then
+          Result:= nil
+        else begin
+          FPopupVerbMenu:= TPopupMenu.Create(Self);
+          for I := 0 to FObjectVerbs.Count - 1 do begin
+            Item := TMenuItem.Create(Self);
+            Item.Caption := FObjectVerbs[I];
+            Item.Tag := I;
+            if TVerbInfo(FObjectVerbs.Objects[i]).Verb = 0 then
+              Item.Default:= true;              // Verb = 0 is the primary verb
+            Item.OnClick := PopupVerbMenuClick;
+            FPopupVerbMenu.Items.Add(Item);
+          end;
+          Result := FPopupVerbMenu;
+        end;
+      end;
+  end;
+end;
+{$WARNINGS ON}
+
+procedure TCustomRichEdit98.DestroyVerbs;
+begin
+  FPopupVerbMenu.Free;
+  FPopupVerbMenu := nil;
+  FObjectVerbs.Free;
+  FObjectVerbs := nil;
+end;
+
+procedure TCustomRichEdit98.UpdateVerbs;
+var
+  EnumOleVerb: IEnumOleVerb;
+  OleVerb: TOleVerb;
+  VerbInfo: TVerbInfo;
+begin
+  DestroyVerbs;
+  FObjectVerbs := TStringList.Create;
+  if FSelObject.EnumVerbs(EnumOleVerb) = 0 then
+  begin
+    while (EnumOleVerb.Next(1, OleVerb, nil) = 0) and
+      (OleVerb.lVerb &gt;= 0) and
+      (OleVerb.grfAttribs and OLEVERBATTRIB_ONCONTAINERMENU &lt;&gt; 0) do
+    begin
+      VerbInfo.Verb := OleVerb.lVerb;
+      VerbInfo.Flags := OleVerb.fuFlags;
+      FObjectVerbs.AddObject(OleVerb.lpszVerbName, TObject(VerbInfo));
+    end;
+  end;
+end;
+
+procedure TCustomRichEdit98.PopupVerbMenuClick(Sender: TObject);
+begin
+  DoVerb((Sender as TMenuItem).Tag);
+end;
+
+procedure TCustomRichEdit98.DoVerb(Verb: Integer);
+var
+  H: THandle;
+  R: TRect;
+  ClientSite: IOleClientSite;
+  PT:Integer;
+begin
+  if not Assigned(RichEditOle) or not Assigned(FSelObject) then Exit;
+  pt := 0;
+  if Verb &gt; 0 then begin
+    if FObjectVerbs = nil then UpdateVerbs;
+    if Verb &gt;= FObjectVerbs.Count then
+      raise EOleError.Create('Invalid Verb');
+    Verb := Smallint(Integer(FObjectVerbs.Objects[Verb]) and $0000FFFF);
+  end else
+    if Verb = ovPrimary then Verb := 0;
+  H := Handle;
+//  PT:=Point(AX,AY);
+  SendMessage(H,EM_POSFROMCHAR,pt,0)  ;
+R:=BoundsRect;
+//  R := ClientRect;
+
+  OleCheck(RichEditOle.GetClientSite(ClientSite));
+  OleCheck(FSelObject.DoVerb(Verb, nil, ClientSite, 0, H, R));
+end;
+
+procedure TCustomRichEdit98.InsertObjectDialog;
+var
+   Data: TOleUIInsertObject;
+   NameBuffer: array[0..255] of Char;
+   CreateInfo: TCreateInfo;
+begin
+     FillChar(Data, SizeOf(Data), 0);
+     FillChar(NameBuffer, SizeOf(NameBuffer), 0);
+     Data.cbStruct := SizeOf(Data);
+     Data.dwFlags := IOF_SELECTCREATENEW;
+     Data.hWndOwner := Application.Handle;
+     Data.lpfnHook := OleDialogHook;
+     Data.lpszFile := NameBuffer;
+     Data.cchFile := SizeOf(NameBuffer);
+     try
+        if OleUIInsertObject(Data) = OLEUI_OK then begin
+           if Data.dwFlags and IOF_SELECTCREATENEW &lt;&gt; 0 then begin
+              CreateInfo.CreateType := ctNewObject;
+              CreateInfo.ClassID := Data.clsid;
+           end
+           else
+           begin
+               if Data.dwFlags and IOF_CHECKLINK = 0 then
+               CreateInfo.CreateType := ctFromFile
+               else
+               CreateInfo.CreateType := ctLinkToFile;
+               CreateInfo.FileName := NameBuffer;
+               end;
+           CreateInfo.ShowAsIcon := Data.dwFlags and IOF_CHECKDISPLAYASICON &lt;&gt; 0;
+           CreateInfo.IconMetaPict := Data.hMetaPict;
+           CreateObjectFromInfo(CreateInfo);
+      if CreateInfo.CreateType = ctNewObject then
+//      begin
+      DoVerb(OvOpen);
+//      end
+//      else
+//      DoVerb(OVOpen);
+           end;
+  finally
+    DestroyMetaPict(Data.hMetaPict);
+  end;
+end;
+
+procedure TCustomRichEdit98.CreateObjectFromInfo(const CreateInfo:TCreateInfo);
+var
+   Storage:IStorage;
+   OleObject:IOleObject;
+   OleSite:IOleClientSite;
+   ReObject:TReObject;
+   Data: TOleUIChangeIcon;
+begin
+     try
+        RichEditOle.GetClientSite(OleSite);
+        RichEditOleCallback.GetNewStorage(Storage);
+        with CreateInfo do begin
+             case CreateType of
+                  ctNewObject:
+                              OleCheck(OleCreate(ClassID, IOleObject, OLERENDER_DRAW, nil,
+                              OleSite, Storage, OleObject));
+                  ctFromFile:
+                             OleCheck(OleCreateFromFile(GUID_NULL, PWideChar(FileName), IOleObject,
+                             OLERENDER_DRAW, nil, OleSite, Storage, OleObject));
+                  ctLinkToFile:
+                               OleCheck(OleCreateLinkToFile(PWideChar(FileName), IOleObject,
+                               OLERENDER_DRAW, nil, OleSite, Storage, OleObject));
+                  ctFromData:
+                             OleCheck(OleCreateFromData(DataObject, IOleObject,
+                             OLERENDER_DRAW, nil, OleSite, Storage, OleObject));
+                  ctLinkFromData:
+                                 OleCheck(OleCreateLinkFromData(DataObject, IOleObject,
+                                 OLERENDER_DRAW, nil, OleSite, Storage, OleObject));
+                  end;
+             FillChar(ReObject, SizeOf(TReObject), 0);
+             ReObject.cbStruct:=SizeOf(TReObject);
+             ReObject.cp:=SelStart;
+             ReObject.oleobj:=OleObject;
+             ReObject.clsid:=Data.clsid;
+             ReObject.stg:=Storage;
+             ReObject.olesite:=OleSite;
+             ReObject.sizel.cx:=0;
+             ReObject.sizel.cy:=0;
+             ReObject.dwUser:=0;
+             FSelObject:= OleObject;
+             ReObject.dwFlags:={REO_BELOWBASELINE or} REO_DYNAMICSIZE or REO_RESIZABLE;
+             if CreateInfo.ShowAsIcon then
+             Begin
+              ReObject.dvaspect:=DVASPECT_ICON;
+              FDrawAspect:=DVASPECT_ICON;
+              SetDrawaspect(True,ICONMETAPICT);
+             end
+             else
+             begin
+             FDrawaspect:=DVASPECT_CONTENT;
+             ReObject.dvaspect:=DVASPECT_CONTENT;
+             end;
+      If CreateInfo.CreateType=ctNewObject then
+             ReObject.dwFlags:= ReObject.dwFlags or REO_BLANK;
+         RicheditOle.SetHostNames(PWideChar(WideString(Application.Title)),
+                          PWideChar(WideString(Caption)));
+            Olecheck(RichEditOle.InsertObject(ReObject));
+            end;
+     except
+           raise;
+     end;
+
+end;
+
+procedure TCustomRichedit98.SetDrawAspect(Iconic: Boolean;
+  IconMetaPict: HGlobal);
+var
+  OleCache: IOleCache;
+  EnumStatData: IEnumStatData;
+  OldAspect, AdviseFlags, Connection: Longint;
+  TempMetaPict: HGlobal;
+  FormatEtc: TFormatEtc;
+  Medium: TStgMedium;
+  ClassID: TCLSID;
+  StatData: TStatData;
+
+begin
+  OldAspect := FDrawAspect;
+  if Iconic then
+  begin
+    FDrawAspect := DVASPECT_ICON;
+    AdviseFlags := ADVF_NODATA;
+  end else
+  begin
+    FDrawAspect := DVASPECT_CONTENT;
+    AdviseFlags := ADVF_PRIMEFIRST;
+  end;
+  if (FDrawAspect &lt;&gt; OldAspect) or (FDrawAspect = DVASPECT_ICON) then
+  begin
+    OleCache := FSelObject as IOleCache;
+    if FDrawAspect &lt;&gt; OldAspect then
+    begin
+      OleCheck(OleCache.EnumCache(EnumStatData));
+      if EnumStatData &lt;&gt; nil then
+        while EnumStatData.Next(1, StatData, nil) = 0 do
+          if StatData.formatetc.dwAspect = OldAspect then
+            OleCache.Uncache(StatData.dwConnection);
+      FillChar(FormatEtc, SizeOf(FormatEtc), 0);
+      FormatEtc.dwAspect := FDrawAspect;
+      FormatEtc.lIndex := -1;
+      OleCheck(OleCache.Cache(FormatEtc, AdviseFlags, Connection));
+    end;
+    if FDrawAspect = DVASPECT_ICON then
+    begin
+      TempMetaPict := 0;
+      if IconMetaPict = 0 then
+      begin
+        OleCheck(FSelObject.GetUserClassID(ClassID));
+        TempMetaPict := OleGetIconOfClass(ClassID, nil, True);
+        IconMetaPict := TempMetaPict;
+      end;
+      try
+        FormatEtc.cfFormat := CF_METAFILEPICT;
+        FormatEtc.ptd := nil;
+        FormatEtc.dwAspect := DVASPECT_ICON;
+        FormatEtc.lIndex := -1;
+        FormatEtc.tymed := TYMED_MFPICT;
+        Medium.tymed := TYMED_MFPICT;
+        Medium.hMetaFilePict := IconMetaPict;
+        Medium.unkForRelease := nil;
+        OleCheck(OleCache.Cache(FormatEtc, AdviseFlags, Connection));
+        OLECheck(OleCache.SetData(FormatEtc, Medium, False));
+      finally
+        DestroyMetaPict(TempMetaPict);
+      end;
+    end;
+    if FDrawAspect = DVASPECT_CONTENT then UpdateObject;
+    UpdateView;
+    end;
+end;
+
+function TCustomRichEdit98.PasteSpecialDialog: Boolean;
+const
+  PasteFormatCount = 2;
+var
+  Data: TOleUIPasteSpecial;
+  PasteFormats: array[0..PasteFormatCount - 1] of TOleUIPasteEntry;
+  CreateInfo: TCreateInfo;
+begin
+  Result := False;
+  if not CanPaste then Exit;
+  FillChar(Data, SizeOf(Data), 0);
+  FillChar(PasteFormats, SizeOf(PasteFormats), 0);
+  Data.cbStruct := SizeOf(Data);
+  Data.hWndOwner := Application.Handle;
+  Data.lpfnHook := OleDialogHook;
+  Data.arrPasteEntries := @PasteFormats;
+  Data.cPasteEntries := PasteFormatCount;
+  Data.arrLinkTypes := @CFLinkSource;
+  Data.cLinkTypes := 1;
+  PasteFormats[0].fmtetc.cfFormat := CFEmbeddedObject;
+  PasteFormats[0].fmtetc.dwAspect := DVASPECT_CONTENT;
+  PasteFormats[0].fmtetc.lIndex := -1;
+  PasteFormats[0].fmtetc.tymed := TYMED_ISTORAGE;
+  PasteFormats[0].lpstrFormatName := '%s';
+  PasteFormats[0].lpstrResultText := '%s';
+  PasteFormats[0].dwFlags := OLEUIPASTE_PASTE or OLEUIPASTE_ENABLEICON;
+  PasteFormats[1].fmtetc.cfFormat := CFLinkSource;
+  PasteFormats[1].fmtetc.dwAspect := DVASPECT_CONTENT;
+  PasteFormats[1].fmtetc.lIndex := -1;
+  PasteFormats[1].fmtetc.tymed := TYMED_ISTREAM;
+  PasteFormats[1].lpstrFormatName := '%s';
+  PasteFormats[1].lpstrResultText := '%s';
+  PasteFormats[1].dwFlags := OLEUIPASTE_LINKTYPE1 or OLEUIPASTE_ENABLEICON;
+  try
+    if OleUIPasteSpecial(Data) = OLEUI_OK then
+    begin
+      if Data.fLink then
+        CreateInfo.CreateType := ctLinkFromData else
+        CreateInfo.CreateType := ctFromData;
+        CreateInfo.ShowAsIcon := Data.dwFlags and PSF_CHECKDISPLAYASICON &lt;&gt; 0;
+        CreateInfo.IconMetaPict := Data.hMetaPict;
+        CreateInfo.DataObject := Data.lpSrcDataObj;
+        CreateObjectFromInfo(CreateInfo);
+      Result := True;
+    end;
+  finally
+    DestroyMetaPict(Data.hMetaPict);
+  end;
+end;
+
+function TCustomRichedit98.GetCanPaste: Boolean;
+var
+  DataObject: IDataObject;
+begin
+  Result := (OleGetClipboard(DataObject) &gt;= 0) and
+    ((OleQueryCreateFromData(DataObject) = 0) or
+     (OleQueryLinkFromData(DataObject) = 0));
+end;
+
+procedure TCustomRichEdit98.UpdateObject;
+begin
+  if FSelObject &lt;&gt; nil then
+  begin
+    OleCheck(FSelObject.Update);
+    Changed;
+  end;
+end;
+
+procedure TCustomRichEdit98.UpdateView;
+var
+  ViewObject2: IViewObject2;
+begin
+  if FSelObject.QueryInterface(IViewObject2, ViewObject2) &gt;= 0 then
+  begin
+    ViewObject2.GetExtent(FDrawAspect, - 1, nil, FViewSize);
+    //    AdjustBounds;
+  end;
+  Invalidate;
+  Changed;
+end;
+
+function TCustomRichedit98.ChangeIconDialog: Boolean;
+var
+  Data: TOleUIChangeIcon;
+begin
+  CheckObject;
+  Result := False;
+  FillChar(Data, SizeOf(Data), 0);
+  Data.cbStruct := SizeOf(Data);
+  Data.dwFlags := CIF_SELECTCURRENT;
+  Data.hWndOwner := Application.Handle;
+  Data.lpfnHook := OleDialogHook;
+  OleCheck(FSelObject.GetUserClassID(Data.clsid));
+  Data.hMetaPict := GetIconMetaPict;
+  try
+    if OleUIChangeIcon(Data) = OLEUI_OK then
+    begin
+      SetDrawAspect(True, Data.hMetaPict);
+      Result := True;
+    end;
+  finally
+    DestroyMetaPict(Data.hMetaPict);
+  end;
+end;
+
+function TCustomRichEdit98.GetIconMetaPict: HGlobal;
+var
+  DataObject: IDataObject;
+  FormatEtc: TFormatEtc;
+  Medium: TStgMedium;
+  ClassID: TCLSID;
+begin
+  CheckObject;
+  Result := 0;
+  if FDrawAspect = DVASPECT_ICON then
+  begin
+    FSelObject.QueryInterface(IDataObject, DataObject);
+    if DataObject &lt;&gt; nil then
+    begin
+      FormatEtc.cfFormat := CF_METAFILEPICT;
+      FormatEtc.ptd := nil;
+      FormatEtc.dwAspect := DVASPECT_ICON;
+      FormatEtc.lIndex := -1;
+      FormatEtc.tymed := TYMED_MFPICT;
+      if DataObject.GetData(FormatEtc, Medium) &gt;= 0 then
+        Result := Medium.hMetaFilePict;
+    end;
+  end;
+  if Result = 0 then
+  begin
+    OleCheck(FSelObject.GetUserClassID(ClassID));
+    Result := OleGetIconOfClass(ClassID, nil, True);
+  end;
+end;
+
+procedure TCustomRichedit98.CheckObject;
+begin
+  if FSelObject = nil then
+    raise EOleError.Create('EmptyDocument');
+end;
+
+procedure TCustomRichEdit98.CreateLinkToFile(const FileName: string;
+                                             Iconic: Boolean);
+var
+  CreateInfo: TCreateInfo;
+begin
+  CreateInfo.CreateType := ctLinkToFile;
+  CreateInfo.ShowAsIcon := Iconic;
+  CreateInfo.IconMetaPict := 0;
+  CreateInfo.FileName := FileName;
+  CreateObjectFromInfo(CreateInfo);
+end;
+
+procedure TCustomRichEdit98.CreateObject(const OleClassName: string;
+  Iconic: Boolean);
+var
+  CreateInfo: TCreateInfo;
+begin
+  CreateInfo.CreateType := ctNewObject;
+  CreateInfo.ShowAsIcon := Iconic;
+  CreateInfo.IconMetaPict := 0;
+  CreateInfo.ClassID := ProgIDToClassID(OleClassName);
+  CreateObjectFromInfo(CreateInfo);
+end;
+
+procedure TCustomRichEdit98.CreateObjectFromFile(const FileName: string;
+  Iconic: Boolean);
+var
+  CreateInfo: TCreateInfo;
+begin
+  CreateInfo.CreateType := ctFromFile;
+  CreateInfo.ShowAsIcon := Iconic;
+  CreateInfo.IconMetaPict := 0;
+  CreateInfo.FileName := FileName;
+  CreateObjectFromInfo(CreateInfo);
+end;
+
+procedure TCustomRichEdit98.StopGroupTyping;
+begin
+  Perform(EM_STOPGROUPTYPING, 0, 0);
+end;
+
+function TCustomRichEdit98.GetSelType: TSelectionType;
+var
+  B: Byte;
+begin
+  B:= Perform(EM_SELECTIONTYPE, 0, 0);
+  Result:= TSelectionType(B);
+end;
+
+procedure TCustomRichEdit98.DoSetMaxLength(Value: Integer);
+begin
+  if Value=0 then
+    Value:= MAXLONG;
+  SendMessage(Handle, EM_EXLIMITTEXT, 0, Value);
+end;
+
+{ TDBRichEdit98 }
+{$ifdef BDE_SUPPORT}
+constructor TDBRichEdit98.Create(AOwner: TComponent);
+begin
+  inherited Create(AOwner);
+  inherited ReadOnly := True;
+  FAutoDisplay := True;
+  FDataLink := TFieldDataLink.Create;
+  FDataLink.Control := Self;
+  FDataLink.OnDataChange := DataChange;
+  FDataLink.OnEditingChange := EditingChange;
+  FDataLink.OnUpdateData := UpdateData;
+end;
+
+destructor TDBRichEdit98.Destroy;
+begin
+  FDataLink.Free;
+  FDataLink := nil;
+  inherited Destroy;
+end;
+
+procedure TDBRichEdit98.Loaded;
+begin
+  inherited Loaded;
+  if (csDesigning in ComponentState) then DataChange(Self);
+end;
+
+procedure TDBRichEdit98.Notification(AComponent: TComponent;
+  Operation: TOperation);
+begin
+  inherited Notification(AComponent, Operation);
+  if (Operation = opRemove) and (FDataLink &lt;&gt; nil) and
+    (AComponent = DataSource) then DataSource := nil;
+end;
+
+procedure TDBRichEdit98.BeginEditing;
+begin
+  if not FDataLink.Editing then
+  try
+    if FDataLink.Field.IsBlob then
+      FDataSave := FDataLink.Field.AsString;
+    FDataLink.Edit;
+  finally
+    FDataSave := '';
+  end;
+end;
+
+procedure TDBRichEdit98.KeyDown(var Key: Word; Shift: TShiftState);
+begin
+  inherited KeyDown(Key, Shift);
+  if FMemoLoaded then
+  begin
+    if (Key = VK_DELETE) or (Key = VK_BACK) or
+      ((Key = VK_INSERT) and (ssShift in Shift)) or
+      (((Key = Ord('V')) or (Key = Ord('X'))) and (ssCtrl in Shift)) then
+      BeginEditing;
+  end;
+end;
+
+procedure TDBRichEdit98.KeyPress(var Key: Char);
+begin
+  inherited KeyPress(Key);
+  if FMemoLoaded then
+  begin
+    if (Key in [#32..#255]) and (FDataLink.Field &lt;&gt; nil) and
+      not FDataLink.Field.IsValidChar(Key) then
+    begin
+      MessageBeep(0);
+      Key := #0;
+    end;
+    case Key of
+      ^H, ^I, ^J, ^M, ^V, ^X, #32..#255:
+        BeginEditing;
+      #27:
+        FDataLink.Reset;
+    end;
+  end else
+  begin
+    if Key = #13 then LoadMemo;
+    Key := #0;
+  end;
+end;
+
+procedure TDBRichEdit98.Change;
+begin
+  if FMemoLoaded then FDataLink.Modified;
+  FMemoLoaded := True;
+  inherited Change;
+end;
+
+function TDBRichEdit98.GetDataSource: TDataSource;
+begin
+  Result := FDataLink.DataSource;
+end;
+
+procedure TDBRichEdit98.SetDataSource(Value: TDataSource);
+begin
+  FDataLink.DataSource := Value;
+  if Value &lt;&gt; nil then Value.FreeNotification(Self);
+end;
+
+function TDBRichEdit98.GetDataField: string;
+begin
+  Result := FDataLink.FieldName;
+end;
+
+procedure TDBRichEdit98.SetDataField(const Value: string);
+begin
+  FDataLink.FieldName := Value;
+end;
+
+function TDBRichEdit98.GetReadOnly: Boolean;
+begin
+  Result := FDataLink.ReadOnly;
+end;
+
+procedure TDBRichEdit98.SetReadOnly(Value: Boolean);
+begin
+  FDataLink.ReadOnly := Value;
+end;
+
+function TDBRichEdit98.GetField: TField;
+begin
+  Result := FDataLink.Field;
+end;
+
+procedure TDBRichEdit98.LoadMemo;
+begin
+  if not FMemoLoaded and Assigned(FDataLink.Field) and FDataLink.Field.IsBlob then
+  begin
+    try
+      Lines.Assign(FDataLink.Field);
+      FMemoLoaded := True;
+    except
+      { Rich Edit Load failure }
+      on E:EOutOfResources do
+        Lines.Text := Format('(%s)', [E.Message]);
+    end;
+    EditingChange(Self);
+  end;
+end;
+
+procedure TDBRichEdit98.DataChange(Sender: TObject);
+begin
+  if FDataLink.Field &lt;&gt; nil then
+    if FDataLink.Field.IsBlob then
+    begin
+      if FAutoDisplay or (FDataLink.Editing and FMemoLoaded) then
+      begin
+        { Check if the data has changed since we read it the first time }
+        if (FDataSave &lt;&gt; '') and (FDataSave = FDataLink.Field.AsString) then Exit;
+        FMemoLoaded := False;
+        LoadMemo;
+      end else
+      begin
+        Text := Format('(%s)', [FDataLink.Field.DisplayLabel]);
+        FMemoLoaded := False;
+      end;
+    end else
+    begin
+      if FFocused and FDataLink.CanModify then
+        Text := FDataLink.Field.Text
+      else
+        Text := FDataLink.Field.DisplayText;
+      FMemoLoaded := True;
+    end
+  else
+  begin
+    if csDesigning in ComponentState then Text := Name else Text := '';
+    FMemoLoaded := False;
+  end;
+  if HandleAllocated then
+    RedrawWindow(Handle, nil, 0, RDW_INVALIDATE or RDW_ERASE or RDW_FRAME);
+end;
+
+procedure TDBRichEdit98.EditingChange(Sender: TObject);
+begin
+  inherited ReadOnly := not (FDataLink.Editing and FMemoLoaded);
+end;
+
+procedure TDBRichEdit98.UpdateData(Sender: TObject);
+begin
+  if FDataLink.Field.IsBlob then
+    FDataLink.Field.Assign(Lines) else
+    FDataLink.Field.AsString := Text;
+end;
+
+procedure TDBRichEdit98.SetFocused(Value: Boolean);
+begin
+  if FFocused &lt;&gt; Value then
+  begin
+    FFocused := Value;
+    if not Assigned(FDataLink.Field) or not FDataLink.Field.IsBlob then
+      FDataLink.Reset;
+  end;
+end;
+
+procedure TDBRichEdit98.CMEnter(var Message: TCMEnter);
+begin
+  SetFocused(True);
+  inherited;
+  if SysLocale.FarEast and FDataLink.CanModify then
+    inherited ReadOnly := False;
+end;
+
+procedure TDBRichEdit98.CMExit(var Message: TCMExit);
+begin
+  try
+    FDataLink.UpdateRecord;
+  except
+    SetFocus;
+    raise;
+  end;
+  SetFocused(False);
+  inherited;
+end;
+
+procedure TDBRichEdit98.SetAutoDisplay(Value: Boolean);
+begin
+  if FAutoDisplay &lt;&gt; Value then
+  begin
+    FAutoDisplay := Value;
+    if Value then LoadMemo;
+  end;
+end;
+
+procedure TDBRichEdit98.WMLButtonDblClk(var Message: TWMLButtonDblClk);
+begin
+  if not FMemoLoaded then LoadMemo else inherited;
+end;
+
+procedure TDBRichEdit98.WMCut(var Message: TMessage);
+begin
+  BeginEditing;
+  inherited;
+end;
+
+procedure TDBRichEdit98.WMPaste(var Message: TMessage);
+begin
+  BeginEditing;
+  inherited;
+end;
+
+procedure TDBRichEdit98.CMGetDataLink(var Message: TMessage);
+begin
+  Message.Result := Integer(FDataLink);
+end;
+
+procedure TDBRichEdit98.DefineProperties(Filer: TFiler);
+begin
+end;
+{$endif}
+
+
+
+
+constructor TRichEditOleCallback.Create(AOwner: TCustomRichEdit98);
+begin
+  inherited Create;
+  FOwner:= AOwner;
+end;
+
+function TRichEditOleCallback.GetNewStorage(out stg: IStorage): HRESULT;
+var LockBytes: ILockBytes;
+begin
+  Result:= S_OK;
+  try
+    OleCheck(CreateILockBytesOnHGlobal(0, True, LockBytes));
+    OleCheck(StgCreateDocfileOnILockBytes(LockBytes, STGM_READWRITE
+      or STGM_SHARE_EXCLUSIVE or STGM_CREATE, 0, stg));
+  except
+    Result:= E_OUTOFMEMORY;
+  end;
+end;
+
+function TRichEditOleCallback.GetInPlaceContext(out Frame: IOleInPlaceFrame;
+       out Doc: IOleInPlaceUIWindow; var FrameInfo: TOleInPlaceFrameInfo): HRESULT;
+begin
+//  Result:= E_NOTIMPL;
+//  exit;
+ Doc:=nil;
+ Frame := GetVCLFrameForm(ValidParentForm(FOwner));
+ Frame._AddRef;
+  with frameInfo do
+  begin
+    fMDIApp := False;
+    Frame.GetWindow(hWndFrame);
+    hAccel := 0;
+    cAccelEntries := 0;
+   end;
+  Result := S_OK;
+end;
+
+function TRichEditOleCallback.ShowContainerUI(fShow: BOOL): HRESULT;
+begin
+// Result:=S_OK;
+  Result:= E_NOTIMPL;
+end;
+
+function TRichEditOleCallback.GetClipboardData(const chrg: TCharRange; reco: DWORD;
+         out dataobj: IDataObject): HRESULT;
+begin
+  Result:= E_NOTIMPL;
+end;
+
+function TRichEditOleCallback.ContextSensitiveHelp(fEnterMode: BOOL): HRESULT;
+begin
+  Result:= E_NOTIMPL;
+end;
+
+function TRichEditOleCallback.QueryInsertObject(const clsid: TCLSID; stg: IStorage;
+       cp: longint): HRESULT;
+begin
+  Result:= S_OK;
+end;
+
+function TRichEditOleCallback.DeleteObject(oleobj: IOLEObject): HRESULT;
+begin
+  FOwner.FSelObject:= nil;
+  oleobj.Close(OLECLOSE_NOSAVE);
+  Result:= S_OK;
+end;
+
+function TRichEditOleCallback.QueryAcceptData(dataobj: IDataObject; var cfFormat: TClipFormat;
+         reco: DWORD; fReally: BOOL; hMetaPict: HGLOBAL): HRESULT;
+begin
+  Result:= S_OK;
+end;
+
+function TRichEditOleCallback.GetDragDropEffect(fDrag: BOOL; grfKeyState: DWORD;
+         var dwEffect: DWORD): HRESULT;
+const MK_ALT = $20;
+var Effect: DWORD;
+begin
+  Result:= S_OK;
+	if not fDrag then begin // allowable dest effects
+		// check for force link
+		if ((grfKeyState and (MK_CONTROL or MK_SHIFT)) = (MK_CONTROL or MK_SHIFT)) then
+			Effect := DROPEFFECT_LINK
+		// check for force copy
+		else if ((grfKeyState and MK_CONTROL) = MK_CONTROL) then
+			Effect := DROPEFFECT_COPY
+		// check for force move
+		else if ((grfKeyState and MK_ALT) = MK_ALT) then
+			Effect := DROPEFFECT_MOVE
+		// default -- recommended action is move
+		else
+			Effect := DROPEFFECT_MOVE;
+		if (Effect and dwEffect &lt;&gt; 0) then // make sure allowed type
+			dwEffect := Effect;
+  end;
+end;
+
+function TRichEditOleCallback.GetContextMenu(seltype: Word; oleobj: IOleObject;
+         const chrg: TCharRange; var menu: HMENU): HRESULT;
+begin
+  menu:=0;
+  Result:= S_OK;
+end;
+
+var
+  OSVI: TOSVersionInfo;
+
+initialization
+  OSVI.dwOSVersionInfoSize:= SizeOf(OSVI);
+  GetVersionEx(OSVI);
+  IsWinNT:= OSVI.dwPlatformId=VER_PLATFORM_WIN32_NT;
+  CF_RTF:= RegisterClipboardFormat(RichEdit.CF_RTF);
+  CF_RTFNOOBJS:= RegisterClipboardFormat(RichEdit.CF_RTFNOOBJS);
+  CF_RETEXTOBJ:= RegisterClipboardFormat(RichEdit.CF_RETEXTOBJ);
+
+end.

Added: trunk/Lobby/TASClient/LobbyComponents/WStrList.pas
===================================================================
--- trunk/Lobby/TASClient/LobbyComponents/WStrList.pas	                        (rev 0)
+++ trunk/Lobby/TASClient/LobbyComponents/WStrList.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,1031 @@
+unit WStrList;
+
+interface
+
+uses
+  SysUtils, Windows, Classes, Langs;
+
+type
+{ TWideStrings class }
+
+  {$WARNINGS OFF}
+
+  TWideStrings = class(TStrings)
+  private
+    FUpdateCount: Integer;
+    FLanguage: TLanguage;
+    function GetCommaText: WideString;
+    function GetName(Index: Integer): WideString;
+    function GetValue(const Name: WideString): WideString;
+    procedure ReadData(Reader: TReader);
+    procedure SetCommaText(const Value: WideString);
+    procedure SetValue(const Name, Value: WideString);
+    procedure WriteData(Writer: TWriter);
+  protected
+    procedure DefineProperties(Filer: TFiler); override;
+    procedure Error(const Msg: string; Data: Integer);
+    function Get(Index: Integer): WideString; virtual; abstract;
+    function GetCapacity: Integer; virtual;
+    function GetCount: Integer; virtual; abstract;
+    function GetObject(Index: Integer): TObject; virtual;
+    function GetTextStr: WideString; virtual;
+    procedure Put(Index: Integer; const S: WideString); virtual;
+    procedure PutObject(Index: Integer; AObject: TObject); virtual;
+    procedure SetCapacity(NewCapacity: Integer); virtual;
+    procedure SetTextStr(const Value: WideString); virtual;
+    procedure SetUpdateState(Updating: Boolean); virtual;
+    procedure SetLanguage(Value: TLanguage); virtual;
+    function GetLanguage: TLanguage; virtual;
+  public
+    constructor Create;
+    function Add(const S: WideString): Integer; virtual;
+    function AddObject(const S: WideString; AObject: TObject): Integer; virtual;
+    procedure Append(const S: WideString);
+    procedure AddStrings(Strings: TWideStrings); virtual;
+    procedure Assign(Source: TPersistent); override;
+    procedure BeginUpdate;
+    procedure Clear; virtual; abstract;
+    procedure Delete(Index: Integer); virtual; abstract;
+    procedure EndUpdate;
+    function Equals(Strings: TWideStrings): Boolean;
+    procedure Exchange(Index1, Index2: Integer); virtual;
+    function GetText: PWideChar; virtual;
+    function IndexOf(const S: WideString): Integer; virtual;
+    function IndexOfName(const Name: WideString): Integer;
+    function IndexOfObject(AObject: TObject): Integer;
+    procedure Insert(Index: Integer; const S: WideString); virtual; abstract;
+    procedure InsertObject(Index: Integer; const S: WideString;
+      AObject: TObject);
+    procedure LoadFromFile(const FileName: string); virtual;
+    procedure LoadFromStream(Stream: TStream); virtual;
+    procedure Move(CurIndex, NewIndex: Integer); virtual;
+    procedure SaveToFile(const FileName: string); virtual;
+    procedure SaveToStream(Stream: TStream); virtual;
+    procedure SetText(Text: PWideChar); virtual;
+    property Capacity: Integer read GetCapacity write SetCapacity;
+    property CommaText: WideString read GetCommaText write SetCommaText;
+    property Count: Integer read GetCount;
+    property Names[Index: Integer]: WideString read GetName;
+    property Objects[Index: Integer]: TObject read GetObject write PutObject;
+    property Values[const Name: WideString]: WideString read GetValue write SetValue;
+    property Strings[Index: Integer]: WideString read Get write Put; default;
+    property Text: WideString read GetTextStr write SetTextStr;
+    property Language: TLanguage read GetLanguage write SetLanguage;
+  end;
+
+{ TWideStringList class }
+
+  PWideStringItem = ^TWideStringItem;
+  TWideStringItem = record
+    FString: WideString;
+    FObject: TObject;
+  end;
+
+  PWideStringItemList = ^TWideStringItemList;
+  TWideStringItemList = array[0..MaxListSize] of TWideStringItem;
+
+  TWideStringList = class(TWideStrings)
+  private
+    FList: PStringItemList;
+    FCount: Integer;
+    FCapacity: Integer;
+    FSorted: Boolean;
+    FDuplicates: TDuplicates;
+    FOnChange: TNotifyEvent;
+    FOnChanging: TNotifyEvent;
+    procedure ExchangeItems(Index1, Index2: Integer);
+    procedure Grow;
+    procedure QuickSort(L, R: Integer);
+    procedure InsertItem(Index: Integer; const S: WideString);
+    procedure SetSorted(Value: Boolean);
+  protected
+    procedure Changed; virtual;
+    procedure Changing; virtual;
+    function Get(Index: Integer): WideString; override;
+    function GetCapacity: Integer; override;
+    function GetCount: Integer; override;
+    function GetObject(Index: Integer): TObject; override;
+    procedure Put(Index: Integer; const S: WideString); override;
+    procedure PutObject(Index: Integer; AObject: TObject); override;
+    procedure SetCapacity(NewCapacity: Integer); override;
+    procedure SetUpdateState(Updating: Boolean); override;
+    procedure SetLanguage(Value: TLanguage); override;
+  public
+    destructor Destroy; override;
+    function Add(const S: WideString): Integer; override;
+    procedure Clear; override;
+    procedure Delete(Index: Integer); override;
+    procedure Exchange(Index1, Index2: Integer); override;
+    function Find(const S: WideString; var Index: Integer): Boolean; virtual;
+    function IndexOf(const S: WideString): Integer; override;
+    procedure Insert(Index: Integer; const S: WideString); override;
+    procedure Sort; virtual;
+    property Duplicates: TDuplicates read FDuplicates write FDuplicates;
+    property Sorted: Boolean read FSorted write SetSorted;
+    property OnChange: TNotifyEvent read FOnChange write FOnChange;
+    property OnChanging: TNotifyEvent read FOnChanging write FOnChanging;
+  end;
+
+  {$WARNINGS ON}
+
+
+function WideQuotedStr(const S: WideString; Quote: WideChar): WideString;
+function WideExtractQuotedStr(var Src: PWideChar; Quote: WideChar): WideString;
+
+implementation
+
+uses
+  RTLConsts, Consts;
+
+type
+  TCompareFunc = function (W1, W2: WideString; Locale: LCID): Integer;
+
+var
+  WideCompareText: TCompareFunc;
+
+const
+  BOM: Word = $FFFE; // Byte Order Mark
+
+function WideStrScan(Str: PWideChar; Chr: WideChar): PWideChar; assembler;
+asm
+        PUSH    EDI
+        PUSH    EAX
+        MOV     EDI,Str
+        MOV     ECX,0FFFFFFFFH
+        XOR     AX,AX
+        REPNE   SCASW
+        NOT     ECX
+        POP     EDI
+        MOV     AX,Chr
+        REPNE   SCASW
+        MOV     EAX,0
+        JNE     @@1
+        MOV     EAX,EDI
+        DEC     EAX
+@@1:    POP     EDI
+end;
+
+function WideStrEnd(Str: PWideChar): PWideChar; assembler;
+asm
+        MOV     EDX,EDI
+        MOV     EDI,EAX
+        MOV     ECX,0FFFFFFFFH
+        XOR     AX,AX
+        REPNE   SCASW
+        LEA     EAX,[EDI-1]
+        MOV     EDI,EDX
+end;
+
+function WideQuotedStr(const S: WideString; Quote: WideChar): WideString;
+var
+  P, Src, Dest: PWideChar;
+  AddCount: Integer;
+begin
+  AddCount := 0;
+  P := WideStrScan(PWideChar(S), Quote);
+  while P &lt;&gt; nil do
+  begin
+    Inc(P);
+    Inc(AddCount);
+    P := WideStrScan(P, Quote);
+  end;
+  if AddCount = 0 then
+  begin
+    Result := WideString(Quote) + S + WideString(Quote);
+    Exit;
+  end;
+  SetLength(Result, Length(S) + AddCount + 2);
+  Dest := Pointer(Result);
+  Dest^ := Quote;
+  Inc(Dest);
+  Src := Pointer(S);
+  P := WideStrScan(Src, Quote);
+  repeat
+    Inc(P);
+    Move(Src^, Dest^, P - Src);
+    Inc(Dest, P - Src);
+    Dest^ := Quote;
+    Inc(Dest);
+    Src := P;
+    P := WideStrScan(Src, Quote);
+  until P = nil;
+  P := WideStrEnd(Src);
+  Move(Src^, Dest^, P - Src);
+  Inc(Dest, P - Src);
+  Dest^ := Quote;
+end;
+
+function WideExtractQuotedStr(var Src: PWideChar; Quote: WideChar): WideString;
+var
+  P, Dest: PWideChar;
+  DropCount: Integer;
+begin
+  Result := '';
+  if (Src = nil) or (Src^ &lt;&gt; Quote) then Exit;
+  Inc(Src);
+  DropCount := 1;
+  P := Src;
+  Src := WideStrScan(Src, Quote);
+  while Src &lt;&gt; nil do   // count adjacent pairs of quote chars
+  begin
+    Inc(Src);
+    if Src^ &lt;&gt; Quote then Break;
+    Inc(Src);
+    Inc(DropCount);
+    Src := WideStrScan(Src, Quote);
+  end;
+  if Src = nil then Src := WideStrEnd(P);
+  if ((Src - P) &lt;= 1) then Exit;
+  if DropCount = 1 then
+    SetString(Result, P, Src - P - 1)
+  else
+  begin
+    SetLength(Result, Src - P - DropCount);
+    Dest := PWideChar(Result);
+    Src := WideStrScan(P, Quote);
+    while Src &lt;&gt; nil do
+    begin
+      Inc(Src);
+      if Src^ &lt;&gt; Quote then Break;
+      Move(P^, Dest^, Src - P);
+      Inc(Dest, Src - P);
+      Inc(Src);
+      P := Src;
+      Src := WideStrScan(Src, Quote);
+    end;
+    if Src = nil then Src := WideStrEnd(P);
+    Move(P^, Dest^, Src - P - 1);
+  end;
+end;
+
+function CompareTextWin95(W1, W2: WideString; Locale: LCID): Integer;
+var
+  S1, S2: string;
+  CP: Integer;
+  L1, L2: Integer;
+begin
+  L1:= Length(W1);
+  L2:= Length(W2);
+  SetLength(S1, L1);
+  SetLength(S2, L2);
+  CP:= CodePageFromLocale(Locale);
+  WideCharToMultiByte(CP, 0, @W1[1], L1, @S1[1], L1, nil, nil);
+  WideCharToMultiByte(CP, 0, @W2[1], L2, @S2[1], L2, nil, nil);
+  Result:= CompareStringA(Locale, NORM_IGNORECASE, @S1[1], Length(S1),
+                          @S2[1], Length(S2)) - 2;
+end;
+
+function CompareTextWinNT(W1, W2: WideString; Locale: LCID): Integer;
+begin
+  Result:= CompareStringW(Locale, NORM_IGNORECASE, @W1[1], Length(W1),
+                          @W2[1], Length(W2)) - 2;
+end;
+
+constructor TWideStrings.Create;
+begin
+  inherited;
+  FLanguage:= GetUserDefaultLCID;
+end;
+
+procedure TWideStrings.SetLanguage(Value: TLanguage);
+begin
+  FLanguage:= Value;
+end;
+
+function TWideStrings.Add(const S: WideString): Integer;
+begin
+  Result := GetCount;
+  Insert(Result, S);
+end;
+
+function TWideStrings.AddObject(const S: WideString; AObject: TObject): Integer;
+begin
+  Result := Add(S);
+  PutObject(Result, AObject);
+end;
+
+procedure TWideStrings.Append(const S: WideString);
+begin
+  Add(S);
+end;
+
+procedure TWideStrings.AddStrings(Strings: TWideStrings);
+var
+  I: Integer;
+begin
+  BeginUpdate;
+  try
+    for I := 0 to Strings.Count - 1 do
+      AddObject(Strings[I], Strings.Objects[I]);
+  finally
+    EndUpdate;
+  end;
+end;
+
+procedure TWideStrings.Assign(Source: TPersistent);
+var
+  I: Integer;
+begin
+  if Source is TWideStrings then
+  begin
+    BeginUpdate;
+    try
+      Clear;
+      AddStrings(TWideStrings(Source));
+    finally
+      EndUpdate;
+    end;
+    Exit;
+  end
+  else if Source is TStrings then
+  begin
+    BeginUpdate;
+    try
+      for I := 0 to TStrings(Source).Count - 1 do
+        AddObject(TStrings(Source)[I], TStrings(Source).Objects[I]);
+    finally
+      EndUpdate;
+    end;
+  end;
+  inherited Assign(Source);
+end;
+
+procedure TWideStrings.BeginUpdate;
+begin
+  if FUpdateCount = 0 then SetUpdateState(True);
+  Inc(FUpdateCount);
+end;
+
+procedure TWideStrings.DefineProperties(Filer: TFiler);
+
+  function DoWrite: Boolean;
+  begin
+    if Filer.Ancestor &lt;&gt; nil then
+    begin
+      Result := True;
+      if Filer.Ancestor is TWideStrings then
+        Result := not Equals(TWideStrings(Filer.Ancestor))
+    end
+    else Result := Count &gt; 0;
+  end;
+
+begin
+  Filer.DefineProperty('WideStrings', ReadData, WriteData, DoWrite);
+end;
+
+procedure TWideStrings.EndUpdate;
+begin
+  Dec(FUpdateCount);
+  if FUpdateCount = 0 then SetUpdateState(False);
+end;
+
+function TWideStrings.Equals(Strings: TWideStrings): Boolean;
+var
+  I, Count: Integer;
+begin
+  Result := False;
+  Count := GetCount;
+  if Count &lt;&gt; Strings.GetCount then Exit;
+  for I := 0 to Count - 1 do if Get(I) &lt;&gt; Strings.Get(I) then Exit;
+  Result := True;
+end;
+
+procedure TWideStrings.Error(const Msg: string; Data: Integer);
+
+  function ReturnAddr: Pointer;
+  asm
+          MOV     EAX,[EBP+4]
+  end;
+
+begin
+  raise EStringListError.CreateFmt(Msg, [Data]) at ReturnAddr;
+end;
+
+procedure TWideStrings.Exchange(Index1, Index2: Integer);
+var
+  TempObject: TObject;
+  TempString: WideString;
+begin
+  BeginUpdate;
+  try
+    TempString := Strings[Index1];
+    TempObject := Objects[Index1];
+    Strings[Index1] := Strings[Index2];
+    Objects[Index1] := Objects[Index2];
+    Strings[Index2] := TempString;
+    Objects[Index2] := TempObject;
+  finally
+    EndUpdate;
+  end;
+end;
+
+function TWideStrings.GetCapacity: Integer;
+begin  // descendants may optionally override/replace this default implementation
+  Result := Count;
+end;
+
+function TWideStrings.GetCommaText: WideString;
+var
+  S: WideString;
+  P: PWideChar;
+  I, Count: Integer;
+begin
+  Count := GetCount;
+  if (Count = 1) and (Get(0) = '') then
+    Result := '&quot;&quot;'
+  else
+  begin
+    Result := '';
+    for I := 0 to Count - 1 do
+    begin
+      S := Get(I);
+      P := PWideChar(S);
+      while not (P^ in [WideChar(#0)..WideChar(' '),WideChar('&quot;'),WideChar(',')]) do
+        P := CharNextW(P);
+      if (P^ &lt;&gt; #0) then S := WideQuotedStr(S, '&quot;');
+      Result := Result + S + ',';
+    end;
+    System.Delete(Result, Length(Result), 1);
+  end;
+end;
+
+function TWideStrings.GetName(Index: Integer): WideString;
+var
+  P: Integer;
+begin
+  Result := Get(Index);
+  P:= 1;
+  while Result[P]&lt;&gt;'=' do
+    Inc(P);
+  if P &lt;&gt; 0 then
+    SetLength(Result, P-1) else
+    SetLength(Result, 0);
+end;
+
+function TWideStrings.GetObject(Index: Integer): TObject;
+begin
+  Result := nil;
+end;
+
+function TWideStrings.GetText: PWideChar;
+var
+  TempStr: WideString;
+begin
+  TempStr:= GetTextStr;
+  Result := AllocMem(2*Length(TempStr)+10);
+  System.Move(TempStr[1], Result^, 2*Length(TempStr)+2);
+end;
+
+function TWideStrings.GetTextStr: WideString;
+var
+  I, L, Size, Count: Integer;
+  P: PWideChar;
+  S: WideString;
+begin
+  Count := GetCount;
+  Size := 0;
+  for I := 0 to Count - 1 do Inc(Size, Length(Get(I)) + 2);
+  SetString(Result, nil, Size);
+  P := Pointer(Result);
+  for I := 0 to Count - 1 do
+  begin
+    S := Get(I);
+    L := Length(S);
+    if L &lt;&gt; 0 then
+    begin
+      System.Move(Pointer(S)^, P^, L*2);
+      Inc(P, L);
+    end;
+    P^ := #13;
+    Inc(P);
+    P^ := #10;
+    Inc(P);
+  end;
+end;
+
+function TWideStrings.GetValue(const Name: WideString): WideString;
+var
+  I: Integer;
+begin
+  I := IndexOfName(Name);
+  if I &gt;= 0 then
+    Result := Copy(Get(I), Length(Name) + 2, MaxInt) else
+    Result := '';
+end;
+
+function TWideStrings.IndexOf(const S: WideString): Integer;
+begin
+  for Result := 0 to GetCount - 1 do
+    if WideCompareText(Get(Result), S, FLanguage) = 0 then Exit;
+  Result := -1;
+end;
+
+function TWideStrings.IndexOfName(const Name: WideString): Integer;
+var
+  P: Integer;
+  S: string;
+begin
+  for Result := 0 to GetCount - 1 do
+  begin
+    S := Get(Result);
+    P:= 1;
+    while S[P]&lt;&gt;'=' do
+      Inc(P);
+    if (P &lt;&gt; 0) and (WideCompareText(Copy(S, 1, P - 1), Name, FLanguage) = 0) then Exit;
+  end;
+  Result := -1;
+end;
+
+function TWideStrings.IndexOfObject(AObject: TObject): Integer;
+begin
+  for Result := 0 to GetCount - 1 do
+    if GetObject(Result) = AObject then Exit;
+  Result := -1;
+end;
+
+procedure TWideStrings.InsertObject(Index: Integer; const S: WideString;
+  AObject: TObject);
+begin
+  Insert(Index, S);
+  PutObject(Index, AObject);
+end;
+
+procedure TWideStrings.LoadFromFile(const FileName: string);
+var
+  Stream: TStream;
+begin
+  Stream := TFileStream.Create(FileName, fmOpenRead);
+  try
+    LoadFromStream(Stream);
+  finally
+    Stream.Free;
+  end;
+end;
+
+procedure TWideStrings.LoadFromStream(Stream: TStream);
+var
+  Size: Integer;
+  S: WideString;
+  Reverse: Boolean;
+  BOM: Word;
+  I: Integer;
+begin
+  BeginUpdate;
+  try
+    Stream.Read(BOM, 2);
+    Reverse:= False;
+    if BOM=$FEFF then
+      Reverse:= True
+    else if BOM&lt;&gt;$FFFE then
+      Stream.Seek(-2, soFromCurrent);
+    Size := Stream.Size - Stream.Position;
+    SetString(S, nil, Size div 2);
+    Stream.Read(Pointer(S)^, Size);
+    if Reverse then
+      for I:= 1 to Length(S) do
+        S[I]:= WideChar(Swap(Word(S[I])));
+    SetTextStr(S);
+  finally
+    EndUpdate;
+  end;
+end;
+
+procedure TWideStrings.Move(CurIndex, NewIndex: Integer);
+var
+  TempObject: TObject;
+  TempString: WideString;
+begin
+  if CurIndex &lt;&gt; NewIndex then
+  begin
+    BeginUpdate;
+    try
+      TempString := Get(CurIndex);
+      TempObject := GetObject(CurIndex);
+      Delete(CurIndex);
+      InsertObject(NewIndex, TempString, TempObject);
+    finally
+      EndUpdate;
+    end;
+  end;
+end;
+
+procedure TWideStrings.Put(Index: Integer; const S: WideString);
+var
+  TempObject: TObject;
+begin
+  TempObject := GetObject(Index);
+  Delete(Index);
+  InsertObject(Index, S, TempObject);
+end;
+
+procedure TWideStrings.PutObject(Index: Integer; AObject: TObject);
+begin
+end;
+
+procedure TWideStrings.ReadData(Reader: TReader);
+var
+  S: String;
+  W: WideString;
+  I: Integer;
+  Z: Integer;
+  N: Word;
+begin
+  BeginUpdate;
+  try
+    Clear;
+    S:= Reader.ReadString;
+    SetLength(W, Length(S) div 4);
+    for I:= 1 to Length(S) div 4 do
+      begin
+        Val('$'+S[I*4-3]+S[I*4-2]+S[I*4-1]+S[I*2], N, Z);
+        W[I]:= WideChar(N);
+      end;
+    Text:= W;
+  finally
+    EndUpdate;
+  end;
+end;
+
+procedure TWideStrings.SaveToFile(const FileName: string);
+var
+  Stream: TStream;
+begin
+  Stream := TFileStream.Create(FileName, fmCreate);
+  try
+    SaveToStream(Stream);
+  finally
+    Stream.Free;
+  end;
+end;
+
+procedure TWideStrings.SaveToStream(Stream: TStream);
+var
+  S: WideString;
+begin
+  S := GetTextStr;
+  Stream.Write(BOM, 2);
+  Stream.WriteBuffer(Pointer(S)^, Length(S)*2);
+end;
+
+procedure TWideStrings.SetCapacity(NewCapacity: Integer);
+begin
+  // do nothing - descendants may optionally implement this method
+end;
+
+procedure TWideStrings.SetCommaText(const Value: WideString);
+var
+  P, P1: PWideChar;
+  S: WideString;
+begin
+  BeginUpdate;
+  try
+    Clear;
+    P := PWideChar(Value);
+    while P^ in [WideChar(#1)..WideChar(' ')] do P := CharNextW(P);
+    while P^ &lt;&gt; #0 do
+    begin
+      if P^ = '&quot;' then
+        S := WideExtractQuotedStr(P, '&quot;')
+      else
+      begin
+        P1 := P;
+        while (P^ &gt; ' ') and (P^ &lt;&gt; ',') do P := CharNextW(P);
+        SetString(S, P1, P - P1);
+      end;
+      Add(S);
+      while P^ in [WideChar(#1)..WideChar(' ')] do P := CharNextW(P);
+      if P^ = ',' then
+        repeat
+          P := CharNextW(P);
+        until not (P^ in [WideChar(#1)..WideChar(' ')]);
+    end;
+  finally
+    EndUpdate;
+  end;
+end;
+
+procedure TWideStrings.SetText(Text: PWideChar);
+begin
+  SetTextStr(Text);
+end;
+
+procedure TWideStrings.SetTextStr(const Value: WideString);
+var
+  P, Start: PWideChar;
+  S: WideString;
+begin
+  BeginUpdate;
+  try
+    Clear;
+    P := Pointer(Value);
+    if P &lt;&gt; nil then
+      while P^ &lt;&gt; #0 do
+      begin
+        Start := P;
+        while not (P^ in [WideChar(#0), WideChar(#10), WideChar(#13)]) do Inc(P);
+        SetString(S, Start, P - Start);
+        Add(S);
+        if P^ = #13 then Inc(P);
+        if P^ = #10 then Inc(P);
+      end;
+  finally
+    EndUpdate;
+  end;
+end;
+
+procedure TWideStrings.SetUpdateState(Updating: Boolean);
+begin
+end;
+
+procedure TWideStrings.SetValue(const Name, Value: WideString);
+var
+  I: Integer;
+begin
+  I := IndexOfName(Name);
+  if Value &lt;&gt; '' then
+  begin
+    if I &lt; 0 then I := Add('');
+    Put(I, Name + '=' + Value);
+  end else
+  begin
+    if I &gt;= 0 then Delete(I);
+  end;
+end;
+
+procedure TWideStrings.WriteData(Writer: TWriter);
+var
+  I: Integer;
+  S: String;
+  W: WideString;
+begin
+  W:= Text;
+  S:= '';
+  for I := 1 to Length(W) do
+    S:= S+IntToHex(Word(W[1]), 4);
+  Writer.WriteString(S);
+end;
+
+function TWideStrings.GetLanguage: TLanguage;
+begin
+  Result:= Flanguage;
+end;
+
+{ TWideStringList }
+
+destructor TWideStringList.Destroy;
+begin
+  FOnChange := nil;
+  FOnChanging := nil;
+  inherited Destroy;
+  if FCount &lt;&gt; 0 then Finalize(FList^[0], FCount);
+  FCount := 0;
+  SetCapacity(0);
+end;
+
+function TWideStringList.Add(const S: WideString): Integer;
+begin
+  if not Sorted then
+    Result := FCount
+  else
+    if Find(S, Result) then
+      case Duplicates of
+        dupIgnore: Exit;
+        dupError: Error(SDuplicateString, 0);
+      end;
+  InsertItem(Result, S);
+end;
+
+procedure TWideStringList.Changed;
+begin
+  if (FUpdateCount = 0) and Assigned(FOnChange) then FOnChange(Self);
+end;
+
+procedure TWideStringList.Changing;
+begin
+  if (FUpdateCount = 0) and Assigned(FOnChanging) then FOnChanging(Self);
+end;
+
+procedure TWideStringList.Clear;
+begin
+  if FCount &lt;&gt; 0 then
+  begin
+    Changing;
+    Finalize(FList^[0], FCount);
+    FCount := 0;
+    SetCapacity(0);
+    Changed;
+  end;
+end;
+
+procedure TWideStringList.Delete(Index: Integer);
+begin
+  if (Index &lt; 0) or (Index &gt;= FCount) then Error(SListIndexError, Index);
+  Changing;
+  Finalize(FList^[Index]);
+  Dec(FCount);
+  if Index &lt; FCount then
+    System.Move(FList^[Index + 1], FList^[Index],
+      (FCount - Index) * SizeOf(TStringItem));
+  Changed;
+end;
+
+procedure TWideStringList.Exchange(Index1, Index2: Integer);
+begin
+  if (Index1 &lt; 0) or (Index1 &gt;= FCount) then Error(SListIndexError, Index1);
+  if (Index2 &lt; 0) or (Index2 &gt;= FCount) then Error(SListIndexError, Index2);
+  Changing;
+  ExchangeItems(Index1, Index2);
+  Changed;
+end;
+
+procedure TWideStringList.ExchangeItems(Index1, Index2: Integer);
+var
+  Temp: Integer;
+  Item1, Item2: PWideStringItem;
+begin
+  Item1 := @FList^[Index1];
+  Item2 := @FList^[Index2];
+  Temp := Integer(Item1^.FString);
+  Integer(Item1^.FString) := Integer(Item2^.FString);
+  Integer(Item2^.FString) := Temp;
+  Temp := Integer(Item1^.FObject);
+  Integer(Item1^.FObject) := Integer(Item2^.FObject);
+  Integer(Item2^.FObject) := Temp;
+end;
+
+function TWideStringList.Find(const S: WideString; var Index: Integer): Boolean;
+var
+  L, H, I, C: Integer;
+begin
+  Result := False;
+  L := 0;
+  H := FCount - 1;
+  while L &lt;= H do
+  begin
+    I := (L + H) shr 1;
+    C := WideCompareText(FList^[I].FString, S, FLanguage);
+    if C &lt; 0 then L := I + 1 else
+    begin
+      H := I - 1;
+      if C = 0 then
+      begin
+        Result := True;
+        if Duplicates &lt;&gt; dupAccept then L := I;
+      end;
+    end;
+  end;
+  Index := L;
+end;
+
+function TWideStringList.Get(Index: Integer): WideString;
+begin
+  if (Index &lt; 0) or (Index &gt;= FCount) then Error(SListIndexError, Index);
+  Result := FList^[Index].FString;
+end;
+
+function TWideStringList.GetCapacity: Integer;
+begin
+  Result := FCapacity;
+end;
+
+function TWideStringList.GetCount: Integer;
+begin
+  Result := FCount;
+end;
+
+function TWideStringList.GetObject(Index: Integer): TObject;
+begin
+  if (Index &lt; 0) or (Index &gt;= FCount) then Error(SListIndexError, Index);
+  Result := FList^[Index].FObject;
+end;
+
+procedure TWideStringList.Grow;
+var
+  Delta: Integer;
+begin
+  if FCapacity &gt; 64 then Delta := FCapacity div 4 else
+    if FCapacity &gt; 8 then Delta := 16 else
+      Delta := 4;
+  SetCapacity(FCapacity + Delta);
+end;
+
+function TWideStringList.IndexOf(const S: WideString): Integer;
+begin
+  if not Sorted then Result := inherited IndexOf(S) else
+    if not Find(S, Result) then Result := -1;
+end;
+
+procedure TWideStringList.Insert(Index: Integer; const S: WideString);
+begin
+  if Sorted then Error(SSortedListError, 0);
+  if (Index &lt; 0) or (Index &gt; FCount) then Error(SListIndexError, Index);
+  InsertItem(Index, S);
+end;
+
+procedure TWideStringList.InsertItem(Index: Integer; const S: WideString);
+begin
+  Changing;
+  if FCount = FCapacity then Grow;
+  if Index &lt; FCount then
+    System.Move(FList^[Index], FList^[Index + 1],
+      (FCount - Index) * SizeOf(TStringItem));
+  with FList^[Index] do
+  begin
+    Pointer(FString) := nil;
+    FObject := nil;
+    FString := S;
+  end;
+  Inc(FCount);
+  Changed;
+end;
+
+procedure TWideStringList.Put(Index: Integer; const S: WideString);
+begin
+  if Sorted then Error(SSortedListError, 0);
+  if (Index &lt; 0) or (Index &gt;= FCount) then Error(SListIndexError, Index);
+  Changing;
+  FList^[Index].FString := S;
+  Changed;
+end;
+
+procedure TWideStringList.PutObject(Index: Integer; AObject: TObject);
+begin
+  if (Index &lt; 0) or (Index &gt;= FCount) then Error(SListIndexError, Index);
+  Changing;
+  FList^[Index].FObject := AObject;
+  Changed;
+end;
+
+procedure TWideStringList.QuickSort(L, R: Integer);
+var
+  I, J: Integer;
+  P: WideString;
+begin
+  repeat
+    I := L;
+    J := R;
+    P := FList^[(L + R) shr 1].FString;
+    repeat
+      while WideCompareText(FList^[I].FString, P, FLanguage) &lt; 0 do Inc(I);
+      while WideCompareText(FList^[J].FString, P, FLanguage) &gt; 0 do Dec(J);
+      if I &lt;= J then
+      begin
+        ExchangeItems(I, J);
+        Inc(I);
+        Dec(J);
+      end;
+    until I &gt; J;
+    if L &lt; J then QuickSort(L, J);
+    L := I;
+  until I &gt;= R;
+end;
+
+procedure TWideStringList.SetCapacity(NewCapacity: Integer);
+begin
+  ReallocMem(FList, NewCapacity * SizeOf(TStringItem));
+  FCapacity := NewCapacity;
+end;
+
+procedure TWideStringList.SetSorted(Value: Boolean);
+begin
+  if FSorted &lt;&gt; Value then
+  begin
+    if Value then Sort;
+    FSorted := Value;
+  end;
+end;
+
+procedure TWideStringList.SetUpdateState(Updating: Boolean);
+begin
+  if Updating then Changing else Changed;
+end;
+
+procedure TWideStringList.Sort;
+begin
+  if not Sorted and (FCount &gt; 1) then
+  begin
+    Changing;
+    QuickSort(0, FCount - 1);
+    Changed;
+  end;
+end;
+
+procedure TWideStringList.SetLanguage(Value: TLanguage);
+begin
+  inherited;
+  if Sorted then
+    Sort;
+end;
+
+var
+  OSVI: TOSVersionInfoA;
+
+initialization
+  OSVI.dwOSVersionInfoSize:= SizeOf(OSVI);
+  GetVersionEx(OSVI);
+  if OSVI.dwPlatformId=VER_PLATFORM_WIN32_NT then
+    @WideCompareText:= @CompareTextWinNT
+  else
+    @WideCompareText:= @CompareTextWin95;
+
+end.

Added: trunk/Lobby/TASClient/LobbyComponents/richole.pas
===================================================================
--- trunk/Lobby/TASClient/LobbyComponents/richole.pas	                        (rev 0)
+++ trunk/Lobby/TASClient/LobbyComponents/richole.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,157 @@
+Unit RichOLE;
+
+{*
+ *	RICHOLE.H
+ *
+ *	Purpose:
+ *		OLE Extensions to the Rich Text Editor
+ *
+ *	Copyright (c) 1985-1996, Microsoft Corporation
+ *}
+
+{WEAKPACKAGEUNIT}
+{$MINENUMSIZE 4}
+
+interface
+
+uses Windows, ActiveX, Richedit,ComCtrls,ComObj,OleCtnrs;
+
+// Structure passed to GetObject and InsertObject
+type
+  TREOBJECT = packed record
+    cbStruct: DWORD;			// Size of structure
+    cp: longint;					// Character position of object
+    clsid: TCLSID;				// Class ID of object
+    oleobj: IOleObject;			// OLE object interface
+    stg: IStorage;				// Associated storage interface
+    olesite: IOLEClientSite;			// Associated client site interface
+    sizel: TSize;				// Size of object (may be 0,0)
+    dvaspect: DWORD;			// Display aspect to use
+    dwFlags: DWORD;			// Object status flags
+    dwUser: DWORD;				// Dword for user's use
+  end;
+
+const               
+// Flags to specify which interfaces should be returned in the structure above
+  REO_GETOBJ_NO_INTERFACES	= $00000000;
+  REO_GETOBJ_POLEOBJ			= $00000001;
+  REO_GETOBJ_PSTG				= $00000002;
+  REO_GETOBJ_POLESITE			= $00000004;
+  REO_GETOBJ_ALL_INTERFACES	= $00000007;
+
+// Place object at selection
+  REO_CP_SELECTION = $FFFFFFFF;
+
+// Use character position to specify object instead of index
+  REO_IOB_SELECTION = $FFFFFFFF;
+  REO_IOB_USE_CP  = $FFFFFFFE;
+
+// Object flags
+  REO_NULL			= $00000000;	// No flags
+  REO_READWRITEMASK	= $0000003F;	// Mask out RO bits
+  REO_DONTNEEDPALETTE	= $00000020;	// Object doesn't need palette
+  REO_BLANK			= $00000010;	// Object is blank
+  REO_DYNAMICSIZE		= $00000008;	// Object defines size always
+  REO_INVERTEDSELECT	= $00000004;	// Object drawn all inverted if sel
+  REO_BELOWBASELINE	= $00000002;	// Object sits below the baseline
+  REO_RESIZABLE		= $00000001;	// Object may be resized
+  REO_LINK			= $80000000;	// Object is a link (RO)
+  REO_STATIC			= $40000000;	// Object is static (RO)
+  REO_SELECTED		= $08000000;	// Object selected (RO)
+  REO_OPEN			= $04000000;	// Object open in its server (RO)
+  REO_INPLACEACTIVE	= $02000000;	// Object in place active (RO)
+  REO_HILITED			= $01000000;	// Object is to be hilited (RO)
+  REO_LINKAVAILABLE	= $00800000;	// Link believed available (RO)
+  REO_GETMETAFILE		= $00400000;	// Object requires metafile (RO)
+
+// flags for IRichEditOle::GetClipboardData(),
+// IRichEditOleCallback::GetClipboardData() and
+// IRichEditOleCallback::QueryAcceptData()
+  RECO_PASTE			= $00000000;	// paste from clipboard
+  RECO_DROP			= $00000001;	// drop
+  RECO_COPY			= $00000002;	// copy to the clipboard
+  RECO_CUT			= $00000003;	// cut to the clipboard
+  RECO_DRAG			= $00000004;	// drag
+
+{*
+ *	IRichEditOle
+ *
+ *	Purpose:
+ *		Interface used by the client of RichEdit to perform OLE-related
+ *		operations.
+ *
+ *	//$ REVIEW:
+ *		The methods herein may just want to be regular Windows messages.
+ *}
+
+type
+  IRichEditOle = interface(IUnknown)
+    ['{00020D00-0000-0000-C000-000000000046}']
+    function GetClientSite(out lplpolesite: IOLECLIENTSITE): HResult; stdcall;
+    function GetObjectCount: longint; stdcall;
+    function GetLinkCount: longint; stdcall;
+    function GetObject(iob: longint; out reobject: TREOBJECT; dwFlags: DWORD): HRESULT; stdcall;
+    function InsertObject(const reobject: TREOBJECT): HResult; stdcall;
+    function ConvertObject(iob: longint; const clsidNew: TCLSID;
+       lpStrUserTypeNew: POleStr): HRESULT; stdcall;
+    function ActivateAs(const clsid, clsidAs: TCLSID): HRESULT; stdcall;
+    function SetHostNames(lpstrContainerApp, lpstrContainerObj: POleStr): HRESULT; stdcall;
+    function SetLinkAvailable(iob: longint; fAvailable: BOOL): HRESULT; stdcall;
+    function SetDvaspect(iob: longint; dvaspect: DWORD): HRESULT; stdcall;
+    function HandsOffStorage(iob: longint): HRESULT; stdcall;
+    function SaveCompleted(iob: longint; stg: IStorage): HRESULT; stdcall;
+    function InPlaceDeactivate: HRESULT; stdcall;
+    function ContextSensitiveHelp(fEnterMode: BOOL): HRESULT; stdcall;
+    function GetClipboardData(const chrg: TCharRange; reco: DWORD;
+         out dataobj: IDataObject): HRESULT; stdcall;
+    function ImportDataObject(dataobj: IDataObject; cf: TClipFormat;
+         hMetaPict: HGLOBAL): HRESULT; stdcall;
+  end;
+
+{*
+ *	IRichEditOleCallback
+ *
+ *	Purpose:
+ *		Interface used by the RichEdit to get OLE-related stuff from the
+ *		application using RichEdit.
+ *}
+  IRichEditOleCallback = interface(IUnknown)
+    ['{00020D03-0000-0000-C000-000000000046}']
+    function GetNewStorage(out stg: IStorage): HRESULT; stdcall;
+    function GetInPlaceContext(out Frame: IOleInPlaceFrame;
+         out Doc: IOleInPlaceUIWindow; var FrameInfo: TOleInPlaceFrameInfo): HRESULT; stdcall;
+    function ShowContainerUI(fShow: BOOL): HRESULT; stdcall;
+    function QueryInsertObject(const clsid: TCLSID; stg: IStorage; cp: longint): HRESULT; stdcall;
+    function DeleteObject(oleobj: IOLEObject): HRESULT; stdcall;
+    function QueryAcceptData(dataobj: IDataObject; var cfFormat: TClipFormat;
+         reco: DWORD; fReally: BOOL; hMetaPict: HGLOBAL): HRESULT; stdcall;
+    function ContextSensitiveHelp(fEnterMode: BOOL): HRESULT; stdcall;
+    function GetClipboardData(const chrg: TCharRange; reco: DWORD;
+         out dataobj: IDataObject): HRESULT; stdcall;
+    function GetDragDropEffect(fDrag: BOOL; grfKeyState: DWORD;
+         var dwEffect: DWORD): HRESULT; stdcall;
+    function GetContextMenu(seltype: Word; oleobj: IOleObject;
+         const chrg: TCharRange; var menu: HMENU): HRESULT; stdcall;
+  end;
+
+
+
+function RichEdit_SetOleCallback(RichEdit: HWnd; OleInterface: IRichEditOleCallback): BOOL;
+function RichEdit_GetOleInterface(RichEdit: HWnd; out OleInterface: IRichEditOle): BOOL;
+
+implementation
+
+function RichEdit_SetOleCallback(RichEdit: HWnd; OleInterface: IRichEditOleCallback): BOOL;
+begin
+  Result:= BOOL(SendMessage(RichEdit, EM_SETOLECALLBACK, 0, longint(OleInterface)));
+end;
+
+function RichEdit_GetOleInterface(RichEdit: HWnd; out OleInterface: IRichEditOle): BOOL;
+begin
+  Result:= BOOL(SendMessage(RichEdit, EM_GETOLEINTERFACE, 0, longint(@OleInterface)));
+end;
+
+
+
+end.
+

Added: trunk/Lobby/TASClient/LobbyScriptUnit.pas
===================================================================
--- trunk/Lobby/TASClient/LobbyScriptUnit.pas	                        (rev 0)
+++ trunk/Lobby/TASClient/LobbyScriptUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,950 @@
+unit LobbyScriptUnit;
+
+interface
+uses
+  Windows, Messages, SysUtils, Variants, Graphics,
+  Misc,ExtCtrls, WrapDelphi, WrapDelphiClasses,PythonEngine,
+  PythonGUIInputOutput, Forms, StrUtils,Classes, JclDebug,
+  WSocket,MainUnit, class_TIntegerList;
+
+type
+  {$METHODINFO ON}
+
+  TCallback = class(TPersistent)
+    private
+      userRefCountList: TIntegerList;
+      pyUserList: TList;
+      pyBattleList: TList;
+      pyGroupList: TList;
+      pyMods: PPyObject;
+      pyMaps: PPyObject;
+      pyUsers: PPyObject;
+      pyBattles: PPyObject;
+      pyReplays: PPyObject;
+      pyGroups: PPyObject;
+      pyCurrentBattle: PPyObject;
+
+    protected
+      function GetPyBattle(Battle: TBattle): PPyObject;
+      function GetPyReplay(Replay: TReplay): PPyObject;
+      function GetPyReplayPlayer(ReplayPlayer: TReplayPlayer): PPyObject;
+      function GetPyUser(user: TClient): PPyObject;
+      function GetPyGroup(group: TClientGroup): PPyObject;
+      procedure RefreshPythonLists;
+      procedure ClearRefs;
+
+    public
+      // tasclient special functions
+      procedure ShowDebugWindow;
+      //procedure Print(data : string);
+
+      // official api
+      procedure ExitLobby;
+      procedure SocketConnect(adress: string; port: integer);
+      procedure PerformConnected;
+      procedure PerformDisconnected;
+      procedure Disconnect;
+      procedure LoadScripts;
+      procedure ReloadScripts;
+      procedure ReloadScript(name: WideString);
+      procedure SendProtocol(data: WideString);
+      procedure HandleProtocol(data: WideString);
+      //procedure NewThread(functionName: String;tuple: Variant);
+      function GetUsers: Variant;
+      function GetMyUser: Variant;
+      function GetBattles: Variant;
+      function GetReplays: Variant;
+      function GetGroups: Variant;
+      function GetMaps: Variant;
+      function GetMods: Variant;
+      function HostBattle(nbPlayers: integer; RankLimit: Integer; ModName: string; Description: string; Password: string; UDPHostPort: integer; NatTraversal: integer) : Boolean;
+      function HostReplay(replayFile: string; nbPlayers: integer; RankLimit: Integer; Description: string; Password: string; UDPHostPort: integer; NatTraversal: integer) : Boolean;
+      function JoinBattle(battleId: integer) : Boolean;
+      procedure LeaveBattle;
+      function StartBattle: Boolean;
+      function SetMyReadyStatus(b: Boolean): Boolean;
+      procedure SetMyBattleStatus(spec: boolean);
+      function GetCurrentBattle: Variant;
+
+      constructor Create;
+      destructor Destroy;
+      
+  end;
+
+  {$METHODINFO OFF}
+
+  TPyCallback = class(TPyDelphiPersistent)
+    // Constructors &amp; Destructors
+    constructor Create( APythonType : TPythonType ); override;
+    constructor CreateWith( PythonType : TPythonType; args : PPyObject ); override;
+    // Basic services
+    function  Repr : PPyObject; override;
+
+    class function  DelphiObjectClass : TClass; override;
+  end;
+
+  TScriptThread = class(TPythonThread)
+  private
+    functionName: string;
+    tuple: TStrings;
+
+  protected
+    procedure ExecuteWithPython; override;
+
+  public
+    constructor Create(fName: string; tup: Variant);
+  end;
+
+  procedure AcquireMainThread;
+  procedure ReleaseMainThread;
+  procedure PyDict_SetItemStringDecRef(dp: PPyObject; Key: PAnsiChar; const V : Variant);
+  procedure PyDict_SetItemDecRef(dp: PPyObject; Key: PPyObject; const V : Variant);
+var
+  MainThreadState: PPyThreadState;
+  MainInterpreterState: PPyInterpreterState;
+  ScriptHostingRunning: Boolean;
+  ScriptHostingReplayRunning: Boolean;
+  ScriptJoining: Boolean;
+  ScriptStart: Boolean;
+  StartBattleSuccess: Boolean;
+
+implementation
+
+uses PythonScriptDebugFormUnit, Utility, MapListFormUnit, HostBattleFormUnit, BattleFormUnit, ReplaysUnit;
+
+constructor TCallback.Create;
+begin
+  pyUserList := TList.Create;
+  pyBattleList := TList.Create;
+  pyGroupList := TList.Create;
+  userRefCountList := TIntegerList.Create;
+end;
+
+destructor TCallback.Destroy;
+var
+  i,j: integer;
+begin
+  with GetPythonEngine do
+  begin
+    for i:=0 to pyUserList.Count-1 do
+      for j:=1 to userRefCountList.Items[i] do
+        Py_XDECREF(pyUserList[i]);
+
+    for i:=0 to pyBattleList.Count-1 do
+      Py_XDECREF(pyBattleList[i]);
+
+    for i:=0 to pyGroupList.Count-1 do
+      Py_XDECREF(pyGroupList[i]);
+
+    pyUserList.Clear;
+    pyBattleList.Clear;
+    pyGroupList.Clear;
+    userRefCountList.Clear;
+
+    ClearRefs;
+  end;
+
+  inherited;
+end;
+
+procedure TCallback.ShowDebugWindow;
+begin
+  PythonScriptDebugForm.Show;
+end;
+
+procedure TCallback.ExitLobby;
+begin
+  Application.Terminate;
+end;
+
+procedure TCallback.Disconnect;
+begin
+  MainForm.TryToDisconnect;
+end;
+
+procedure TCallback.SocketConnect(adress: string; port: integer);
+begin
+  MainForm.TryToConnect(adress,IntToStr(port),true);
+end;
+
+procedure TCallback.PerformConnected;
+begin
+  MainForm.SocketSessionConnected(nil,0);
+end;
+
+procedure TCallback.PerformDisconnected;
+begin
+  MainForm.SocketChangeState(nil,wsConnected,wsClosed);
+end;
+
+
+procedure TCallback.LoadScripts;
+begin
+  AcquireMainThread;
+  try handlers._load; except end;
+  ReleaseMainThread;
+end;
+procedure TCallback.ReloadScripts;
+begin
+  AcquireMainThread;
+  try handlers._reloadall; except end;
+  ReleaseMainThread;
+end;
+procedure TCallback.ReloadScript(name: WideString);
+begin
+  AcquireMainThread;
+  try handlers._reload(name); except end;
+  ReleaseMainThread;
+end;
+procedure TCallback.SendProtocol(data: WideString);
+var
+  i:integer;
+begin
+  Exit;
+  i := Pos(data,' ');
+  ReleaseMainThread;
+  MainForm.TryToSendCommand(LeftStr(data,i-1),MidStr(data,i+1,9999999));
+  AcquireMainThread;
+end;
+procedure TCallback.HandleProtocol(data: WideString);
+begin
+  if Status.ConnectionState &lt;&gt; Connected then Exit;
+  ReleaseMainThread;
+  MainForm.ProcessRemoteCommand(data);
+  AcquireMainThread;
+end;
+
+{procedure TCallback.NewThread(functionName: String;tuple: Variant);
+begin
+    TScriptThread.Create(functionName, tuple);
+end;}
+
+{procedure TCallback.Print(data : string);
+begin
+  PythonScriptDebugFormUnit.printList.BeginUpdate;
+  PythonScriptDebugFormUnit.printList.Add(data);
+  PythonScriptDebugFormUnit.printList.EndUpdate;
+  PostMessage(PythonScriptDebugForm.Handle, WM_REFRESHOUTPUT, 0, 0);
+end;}
+
+procedure TCallback.RefreshPythonLists;
+var
+  i,j,k: integer;
+  battleClients: PPyObject;
+  groupUsers: PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    for i:=0 to pyGroupList.Count-1 do
+      Py_XDECREF(pyGroupList[i]);
+
+    for i:=0 to pyBattleList.Count-1 do
+      Py_XDECREF(pyBattleList[i]);
+
+    for i:=0 to pyUserList.Count-1 do
+      for j:=1 to userRefCountList.Items[i] do
+        Py_XDECREF(pyUserList[i]);
+
+
+    pyUserList.Clear;
+    pyBattleList.Clear;
+    pyGroupList.Clear;
+    userRefCountList.Clear;
+
+
+    // make the python user list
+    for i:=0 to AllClients.Count-1 do
+    begin
+      pyUserList.Add(GetPyUser(TClient(AllClients[i])));
+      userRefCountList.Add(1);
+    end;
+
+    // make the python battle list
+    for i:=0 to Battles.Count-1 do
+      pyBattleList.Add(GetPyBattle(TBattle(Battles[i])));
+
+    // make the python group list
+    for i:=0 to ClientGroups.Count-1 do
+      pyGroupList.Add(GetPyGroup(TClientGroup(ClientGroups[i])));
+
+    // add battle to users
+    for i:=0 to pyUserList.Count-1 do
+      with TClient(AllClients[i]) do
+        if InBattle then
+        begin
+          j := GetBattleId;
+
+          PyDict_SetItemString(PPyObject(pyUserList[i]),'Battle',PPyObject(pyBattleList[MainForm.GetBattleIndex(j)]));
+        end;
+
+    // add groups to users
+    for i:=0 to pyUserList.Count-1 do
+      with TClient(AllClients[i]) do
+        if GetGroup &gt; -1 then
+        begin
+          j := GetGroup;
+
+          PyDict_SetItemString(PPyObject(pyUserList[i]),'Group',PPyObject(pyGroupList[j]));
+        end;
+
+    // add users to battles
+    for i:=0 to pyBattleList.Count-1 do
+      with TBattle(Battles[i]) do
+      begin
+        battleClients := PyDict_New();
+        for j:= 0 to Clients.Count-1 do
+        begin
+          k := MainForm.GetClientIndexEx(TClient(Clients[j]).Name,AllClients);
+
+          PyDict_SetItemString(battleClients,PChar(TClient(Clients[j]).Name),PPyObject(pyUserList[k]));
+          userRefCountList.Items[k] := userRefCountList.Items[k]+1;
+        end;
+        PyDict_SetItemString(PPyObject(pyBattleList[i]),'Users',battleClients);
+        Py_XDECREF(battleClients);
+      end;
+
+    // add users to groups
+    for i:=0 to ClientGroups.Count-1 do
+      with TClientGroup(ClientGroups[i]) do
+      begin
+        groupUsers := PyDict_New();
+        for j:= 0 to Clients.Count-1 do
+        begin
+          k := MainForm.GetClientIndexEx(Clients[j],AllClients);
+
+          if k = -1 then
+            PyDict_SetItemStringDecRef(battleClients,Pchar(Clients[j]),'Not connected')
+          else
+          begin
+            PyDict_SetItemString(battleClients,Pchar(Clients[j]),PPyObject(pyUserList[k]));
+            userRefCountList.Items[k] := userRefCountList.Items[k]+1;
+          end;
+        end;
+        PyDict_SetItemString(PPyObject(pyGroupList[i]),'Users',groupUsers);
+        Py_XDECREF(groupUsers);
+      end;
+  end;
+end;
+
+function TCallback.GetMyUser: Variant;
+begin
+  Result := GetPythonEngine.PyObjectAsVariant(GetPyUser(Status.Me));
+end;
+
+function TCallback.GetUsers: Variant;
+var
+  i: integer;
+begin
+  with GetPythonEngine do
+  begin
+    ClearRefs;
+    pyUsers := PyDict_New();
+
+    RefreshPythonLists;
+
+    for i:=0 to AllClients.Count-1 do
+      PyDict_SetItemString(pyUsers,PChar(TClient(AllClients[i]).Name),PPyObject(pyUserList[i]));
+      
+    Result := PyObjectAsVariant(pyUsers);
+  end;
+end;
+
+function TCallback.GetCurrentBattle: Variant;
+var
+  i: integer;
+  pyO: PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    Result := PyObjectAsVariant(Py_None);
+    if BattleState.Status = None then
+      Exit;
+    ClearRefs;
+    pyCurrentBattle := PyDict_New();
+
+    RefreshPythonLists;
+
+    PyDict_SetItemString(pyCurrentBattle,'Battle',pyBattleList[MainForm.GetBattleIndex(BattleState.Battle.ID)]);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'GameEndCondition',BattleForm.GameEndRadioGroup.ItemIndex);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'StartPosMode',BattleForm.StartPosRadioGroup.ItemIndex);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'StartMetal',BattleForm.MetalTracker.Value);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'StartEnergy',BattleForm.EnergyTracker.Value);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'MaxUnits',BattleForm.UnitsTracker.Value);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'LimitDGun',BattleForm.LimitDGunCheckBox.Checked);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'GhostedBuildings',BattleForm.GhostedBuildingsCheckBox.Checked);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'DiminishingMMs',BattleForm.DiminishingMMsCheckBox.Checked);
+    PyDict_SetItemStringDecRef(pyCurrentBattle,'LockGameSpeed',BattleForm.LockGameSpeedCheckBox.Checked);
+
+    pyO := StringsToPyList(BattleState.DisabledUnits);
+    PyDict_SetItemString(pyCurrentBattle,'DisabledUnits',pyO);
+    Py_XDECREF(pyO);
+
+    Result := PyObjectAsVariant(pyCurrentBattle);
+  end;
+end;
+
+function TCallback.GetPyUser(user: TClient): PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    with user do
+    begin
+      Result := PyDict_New();
+
+      PyDict_SetItemStringDecRef( Result, 'Name', Name );
+      PyDict_SetItemStringDecRef( Result, 'Status', Status );
+      PyDict_SetItemStringDecRef( Result, 'BattleStatus', BattleStatus );
+      PyDict_SetItemStringDecRef( Result, 'TeamColor', TeamColor );
+      PyDict_SetItemStringDecRef( Result, 'InBattle', InBattle );
+      PyDict_SetItemStringDecRef( Result, 'Country', MainForm.GetCountryName(Country) );
+      PyDict_SetItemStringDecRef( Result, 'CountryCode', Country );
+      PyDict_SetItemStringDecRef( Result, 'CPU', CPU );
+      PyDict_SetItemStringDecRef( Result, 'IP', IP );
+      PyDict_SetItemStringDecRef( Result, 'PublicPort', PublicPort );
+      PyDict_SetItemStringDecRef( Result, 'Rank', GetRank );
+      PyDict_SetItemStringDecRef( Result, 'Group', GetGroup );
+      PyDict_SetItemStringDecRef( Result, 'BattleId', GetBattleId );
+      PyDict_SetItemStringDecRef( Result, 'TeamNo', GetTeamNo );
+      PyDict_SetItemStringDecRef( Result, 'AllyNo', GetAllyNo );
+      PyDict_SetItemStringDecRef( Result, 'Mode', GetMode );
+      PyDict_SetItemStringDecRef( Result, 'Sync', GetSync );
+      PyDict_SetItemStringDecRef( Result, 'Handicap', GetHandicap );
+      PyDict_SetItemStringDecRef( Result, 'ReadyStatus', GetReadyStatus );
+      PyDict_SetItemStringDecRef( Result, 'Side', GetSide );
+      PyDict_SetItemStringDecRef( Result, 'InGameStatus', GetInGameStatus );
+      PyDict_SetItemStringDecRef( Result, 'AwayStatus', GetAwayStatus );
+    end;
+  end;
+end;
+
+function TCallback.GetPyBattle(Battle: TBattle): PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    with Battle do
+    begin
+      Result := PyDict_New();
+
+      PyDict_SetItemStringDecRef( Result, 'Id', ID );
+      PyDict_SetItemStringDecRef( Result, 'BattleType', BattleType );
+      PyDict_SetItemStringDecRef( Result, 'NATType', NATType );
+      PyDict_SetItemStringDecRef( Result, 'RankLimit', RankLimit );
+      PyDict_SetItemStringDecRef( Result, 'Visible', Visible );
+      PyDict_SetItemStringDecRef( Result, 'Description', Description );
+      PyDict_SetItemStringDecRef( Result, 'Map', Map );
+      PyDict_SetItemStringDecRef( Result, 'MapHash', MapHash );
+      PyDict_SetItemStringDecRef( Result, 'SpectatorCount', SpectatorCount );
+      PyDict_SetItemStringDecRef( Result, 'Password', Password );
+      PyDict_SetItemStringDecRef( Result, 'IP', IP );
+      PyDict_SetItemStringDecRef( Result, 'Port', Port );
+      PyDict_SetItemStringDecRef( Result, 'MaxPlayers', MaxPlayers );
+      PyDict_SetItemStringDecRef( Result, 'ModName', ModName );
+      PyDict_SetItemStringDecRef( Result, 'HashCode', HashCode );
+      PyDict_SetItemStringDecRef( Result, 'Locked', Locked );
+    end;
+  end;
+end;
+
+function TCallback.GetPyReplay(Replay: TReplay): PPyObject;
+var
+  scriptPlayer: PPyObject;
+  i: integer;
+  pyO: PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    with Replay do
+    begin
+      Result := PyDict_New();
+
+      PyDict_SetItemStringDecRef( Result, 'FileName', FileName );
+      PyDict_SetItemStringDecRef( Result, 'Grade', Grade );
+      PyDict_SetItemStringDecRef( Result, 'Version', Version );
+      PyDict_SetItemStringDecRef( Result, 'SpringVersion', SpringVersion );
+      PyDict_SetItemStringDecRef( Result, 'FullFileName', FullFileName );
+      PyDict_SetItemStringDecRef( Result, 'Date', Date );
+      if Version &gt; 0 then
+      begin
+        PyDict_SetItemStringDecRef( Result, 'GameLength', demoHeader.gameTime );
+        PyDict_SetItemStringDecRef( Result, 'WallclockLength', demoHeader.wallclockTime );
+        PyDict_SetItemStringDecRef( Result, 'UnixTime', demoHeader.unixTime );
+        PyDict_SetItemStringDecRef( Result, 'MaxPlayers', demoHeader.maxPlayerNum );
+        PyDict_SetItemStringDecRef( Result, 'WinningTeam', demoHeader.winningAllyTeam );
+      end;
+      PyDict_SetItemStringDecRef( Result, 'MapName', Script.ReadMapName );
+      PyDict_SetItemStringDecRef( Result, 'ModName', Script.ReadModName );
+      PyDict_SetItemStringDecRef( Result, 'StartMetal', Script.ReadStartMetal );
+      PyDict_SetItemStringDecRef( Result, 'StartEnergy', Script.ReadStartEnergy );
+      PyDict_SetItemStringDecRef( Result, 'MaxUnits', Script.ReadMaxUnits );
+      PyDict_SetItemStringDecRef( Result, 'StartPosType', Script.ReadStartPosType );
+      PyDict_SetItemStringDecRef( Result, 'GameMode', Script.ReadGameMode );
+      PyDict_SetItemStringDecRef( Result, 'LimitDGun', Script.ReadLimitDGun );
+      PyDict_SetItemStringDecRef( Result, 'DiminishingMMs', Script.ReadDiminishingMMs );
+      PyDict_SetItemStringDecRef( Result, 'GhostedBuildings', Script.ReadGhostedBuildings );
+
+      scriptPlayer := PyDict_New();
+      for i:=0 to PlayerList.Count-1 do
+      begin
+        pyO := GetPyReplayPlayer(TReplayPlayer(PlayerList[i]^));
+        PyDict_SetItemString(scriptPlayer, PChar(TReplayPlayer(PlayerList[i]^).UserName), pyO);
+        Py_XDECREF(pyO);
+      end;
+      PyDict_SetItemString( Result, 'Users',  scriptPlayer);
+      Py_XDECREF(scriptPlayer);
+    end;
+  end;
+end;
+
+function TCallback.GetPyReplayPlayer(ReplayPlayer: TReplayPlayer): PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    with ReplayPlayer do
+    begin
+      Result := PyDict_New();
+
+      PyDict_SetItemStringDecRef( Result, 'UserName', UserName );
+      PyDict_SetItemStringDecRef( Result, 'Rank', Rank );
+      PyDict_SetItemStringDecRef( Result, 'CountryCode', CountryCode );
+      PyDict_SetItemStringDecRef( Result, 'Id', Id );
+      PyDict_SetItemStringDecRef( Result, 'Team', Team );
+      PyDict_SetItemStringDecRef( Result, 'Color', Color );
+      PyDict_SetItemStringDecRef( Result, 'Spectator', Spectator );
+
+      // stats
+      PyDict_SetItemStringDecRef( Result, 'MousePixels', Stats.mousePixels );
+      PyDict_SetItemStringDecRef( Result, 'MouseClicks', Stats.mouseClicks );
+      PyDict_SetItemStringDecRef( Result, 'KeyPresses', Stats.keyPresses );
+      PyDict_SetItemStringDecRef( Result, 'NumCommands', Stats.numCommands );
+      PyDict_SetItemStringDecRef( Result, 'UnitCommands', Stats.unitCommands );
+    end;
+  end;
+end;
+
+function TCallback.GetPyGroup(group: TClientGroup): PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    with group do
+    begin
+      Result := PyDict_New();
+
+      PyDict_SetItemStringDecRef( Result, 'Color', Color );
+      PyDict_SetItemStringDecRef( Result, 'AutoKick', AutoKick );
+      PyDict_SetItemStringDecRef( Result, 'AutoSpec', AutoSpec );
+      PyDict_SetItemStringDecRef( Result, 'NotifyOnHost', NotifyOnHost );
+      PyDict_SetItemStringDecRef( Result, 'NotifyOnJoin', NotifyOnJoin );
+      PyDict_SetItemStringDecRef( Result, 'NotifyOnBattleEnd', NotifyOnBattleEnd );
+      PyDict_SetItemStringDecRef( Result, 'NotifyOnConnect', NotifyOnConnect );
+      PyDict_SetItemStringDecRef( Result, 'HighlightBattles', HighlightBattles );
+    end;
+  end;
+end;
+
+function TCallback.GetReplays: Variant;
+var
+  i: integer;
+  pyO: PPyObject;
+begin
+  if ReplaysForm.LoadingPanel.Visible then Exit;
+
+  with GetPythonEngine do
+  begin
+    ClearRefs;
+    pyReplays := PyDict_New();
+
+    for i:=0 to ReplayList.Count-1 do
+    begin
+      pyO := GetPyReplay(TReplay(ReplayList[i]));
+      PyDict_SetItem(pyReplays,PyInt_FromLong(i),pyO);
+      Py_XDECREF(pyO);
+    end;
+
+    Result := PyObjectAsVariant(pyReplays);
+  end;
+end;
+
+function TCallback.GetBattles: Variant;
+var
+  i: integer;
+begin
+  with GetPythonEngine do
+  begin
+    ClearRefs;
+    pyBattles := PyDict_New();
+
+    RefreshPythonLists;
+
+    for i:=0 to Battles.Count-1 do
+      PyDict_SetItem(pyBattles,PyInt_FromLong(TBattle(Battles[i]).Id),PPyObject(pyBattleList[i]));
+
+    Result := PyObjectAsVariant(pyBattles);
+  end;
+end;
+
+procedure TCallback.ClearRefs;
+begin
+  with GetPythonEngine do
+  begin
+    Py_XDECREF(pyGroups);
+    Py_XDECREF(pyBattles);
+    Py_XDECREF(pyUsers);
+    Py_XDECREF(pyMods);
+    Py_XDECREF(pyMaps);
+    Py_XDECREF(pyReplays);
+    Py_XDECREF(pyCurrentBattle);
+  end;
+end;
+
+function TCallback.GetGroups: Variant;
+var
+  i: integer;
+begin
+  with GetPythonEngine do
+  begin
+    ClearRefs;
+    pyGroups := PyDict_New();
+
+    RefreshPythonLists;
+
+    for i:=0 to pyGroupList.Count-1 do
+      PyDict_SetItemString(pyGroups,PChar(TClientGroup(ClientGroups[i]).Name),PPyObject(pyGroupList[i]));
+
+    Result := PyObjectAsVariant(pyGroups);
+  end;
+end;
+
+function TCallback.GetMaps: Variant;
+var
+  pyMap: PPyObject;
+  pyPosition: PPyObject;
+  pyPositions: PPyObject;
+  i,j: integer;
+begin
+  with GetPythonEngine do
+  begin
+    ClearRefs;
+    pyMaps := PyDict_New();
+
+    for i:=0 to MapListForm.Maps.Count-1 do
+      with TMapItem(MapListForm.Maps[i]) do
+      begin
+        pyMap := PyDict_New();
+
+        PyDict_SetItemStringDecRef( pyMap, 'Hash', MapHash );
+        PyDict_SetItemStringDecRef( pyMap, 'MyGrade', MyGrade );
+        PyDict_SetItemStringDecRef( pyMap, 'GlobalGrade', GlobalGrade );
+        PyDict_SetItemStringDecRef( pyMap, 'TotalVotes', TotalVotes );
+        PyDict_SetItemStringDecRef( pyMap, 'Description', MapInfo.Description );
+        PyDict_SetItemStringDecRef( pyMap, 'TidalStrength', MapInfo.TidalStrength );
+        PyDict_SetItemStringDecRef( pyMap, 'Gravity', MapInfo.Gravity );
+        PyDict_SetItemStringDecRef( pyMap, 'MaxMetal', MapInfo.MaxMetal );
+        PyDict_SetItemStringDecRef( pyMap, 'ExtractorRadius', MapInfo.ExtractorRadius );
+        PyDict_SetItemStringDecRef( pyMap, 'MinWind', MapInfo.MinWind );
+        PyDict_SetItemStringDecRef( pyMap, 'MaxWind', MapInfo.MaxWind );
+        PyDict_SetItemStringDecRef( pyMap, 'Width', MapInfo.Width );
+        PyDict_SetItemStringDecRef( pyMap, 'Height', MapInfo.Height );
+
+        pyPositions := PyDict_New();
+        for j:=0 to MapInfo.PosCount-1 do
+        begin
+          pyPosition := PyDict_New();
+
+          PyDict_SetItemStringDecRef( pyPosition, 'x', MapInfo.Positions[j].x );
+          PyDict_SetItemStringDecRef( pyPosition, 'y', MapInfo.Positions[j].y );
+
+          PyDict_SetItem( pyPositions, PyInt_FromLong(j), pyPosition );
+          Py_XDECREF(pyPosition);
+        end;
+        PyDict_SetItemString( pyMap, 'StartPos', pyPositions );
+        Py_XDECREF(pyPositions);
+
+        PyDict_SetItemString(pyMaps,PChar(MapName) ,pyMap);
+        Py_XDECREF(pyMap);
+      end;
+
+    Result := PyObjectAsVariant(pyMaps);
+  end;
+end;
+
+function TCallback.GetMods: Variant;
+var
+  pyMod: PPyObject;
+  i: integer;
+begin
+  with GetPythonEngine do
+  begin
+    ClearRefs;
+    pyMods := PyDict_New();
+
+    for i:=0 to Utility.ModList.Count-1 do
+      begin
+        pyMod := PyDict_New();
+
+        PyDict_SetItemStringDecRef( pyMod, 'Archive', Utility.ModArchiveList[i] );
+
+        PyDict_SetItemString(pyMods,PChar(Utility.ModList[i]) ,pyMod);
+      end;
+
+    Result := PyObjectAsVariant(pyMods);
+  end;
+end;
+
+function TCallback.JoinBattle(battleId: integer) : Boolean;
+begin
+  Result := True;
+
+  ReleaseMainThread;
+  if BattleState.Status &lt;&gt; None then
+  begin
+    Result := False;
+    AcquireMainThread;
+    Exit;
+  end;
+
+  MainForm.JoinBattle(MainForm.GetBattle(battleId));
+
+  Result := BattleState.Status = Joined;
+  AcquireMainThread;
+end;
+
+function TCallback.HostReplay(replayFile: string; nbPlayers: integer; RankLimit: Integer; Description: string; Password: string; UDPHostPort: integer; NatTraversal: integer) : Boolean;
+begin
+  Result := True;
+
+  if ScriptHostingRunning or ScriptHostingReplayRunning or (BattleState.Status &lt;&gt; None) then
+  begin
+    Result := False;
+    Exit;
+  end;
+
+  ScriptHostingReplayRunning := True;
+  ScriptHostingRunning := True;
+
+  ReleaseMainThread;
+  with HostBattleForm do
+  begin
+    try
+      HostBattleForm.replay := ReplaysForm.GetReplayFromFileName(replayFile);
+
+      if HostBattleForm.replay = nil then
+      begin
+        ScriptHostingReplayRunning := false;
+        ScriptHostingRunning := false;
+        Result := false;
+        AcquireMainThread;
+        Exit;
+      end;
+
+      HostReplay1Click(HostReplay1);
+
+      PlayersTracker.Value := nbPlayers;
+      RankComboBox.ItemIndex := RankLimit;
+      TitleEdit.Text := Description;
+      PasswordEdit.Text := Password;
+      PortEdit.Text := IntToStr(UDPHostPort);
+      NATRadioGroup.ItemIndex := NatTraversal;
+
+      HostButtonClick(HostButton);
+
+      BattleForm.Show;
+
+      Result := BattleState.Status = Hosting;
+      ScriptHostingRunning := False;
+      ScriptHostingReplayRunning := False;
+    except
+      Result := false;
+    end;
+  end;
+  AcquireMainThread;
+end;
+
+function TCallback.HostBattle(nbPlayers: integer; RankLimit: Integer; ModName: string; Description: string; Password: string; UDPHostPort: integer; NatTraversal: integer) : Boolean;
+begin
+  Result := True;
+
+  if ScriptHostingRunning or (BattleState.Status &lt;&gt; None) then
+  begin
+    Result := False;
+    Exit;
+  end;
+
+  ScriptHostingRunning := True;
+
+  ReleaseMainThread;
+  with HostBattleForm do
+  begin
+    try
+      Host1Click(Host1);
+
+      PlayersTracker.Value := nbPlayers;
+      RankComboBox.ItemIndex := RankLimit;
+      ModsComboBox.ItemIndex := ModsComboBox.Items.IndexOf(ModName);
+      TitleEdit.Text := Description;
+      PasswordEdit.Text := Password;
+      PortEdit.Text := IntToStr(UDPHostPort);
+      NATRadioGroup.ItemIndex := NatTraversal;
+
+      HostButtonClick(HostButton);
+
+      BattleForm.Show;
+
+      Result := BattleState.Status = Hosting;
+      ScriptHostingRunning := False;
+    except
+      Result := false;
+    end;
+  end;
+  AcquireMainThread;
+end;
+
+procedure TCallback.LeaveBattle;
+begin
+  if BattleState.Status &lt;&gt; None then
+  begin
+    ReleaseMainThread;
+    BattleForm.DisconnectButtonClick;
+    AcquireMainThread;
+  end;
+end;
+function TCallback.StartBattle: Boolean;
+begin
+  Result := False;
+  if ScriptStart then
+    Exit;
+  ScriptStart := True;
+  StartBattleSuccess := False;
+  BattleForm.StartButtonClick(nil);
+  Result := StartBattleSuccess;
+  ScriptStart := False;
+end;
+
+function TCallback.SetMyReadyStatus(b: Boolean): Boolean;
+begin
+  Result := False;
+  if BattleState.Battle = nil then
+    Exit;
+  if b = BattleForm.AmIReady then
+  begin
+    Result := True;
+    Exit;
+  end;
+  ReleaseMainThread;
+  BattleForm.ReadyButtonClick(BattleForm.ReadyButton);
+  Result := BattleForm.AmIReady;
+  if Result then
+    Status.Me.SetReadyStatus(Result);
+  AcquireMainThread;
+end;
+
+procedure TCallback.SetMyBattleStatus(spec: boolean);
+begin
+  ReleaseMainThread;
+  BattleForm.SpectateCheckBox.Checked := spec;
+  BattleForm.SendMyBattleStatusToServer;
+  AcquireMainThread;
+end;
+
+{ TPyPoint }
+
+// We override the constructors
+
+constructor TPyCallback.Create( APythonType : TPythonType );
+begin
+  inherited;
+
+  DelphiObject := TCallback.Create;
+  Owned := True; // We own the objects we create
+end;
+
+constructor TPyCallback.CreateWith( PythonType : TPythonType; args : PPyObject );
+begin
+  inherited;
+end;
+
+class function TPyCallback.DelphiObjectClass: TClass;
+begin
+  Result := TCallback;
+end;
+
+function  TPyCallback.Repr : PPyObject;
+begin
+  with GetPythonEngine, DelphiObject as TCallback do
+    Result := VariantAsPyObject('Lobby script API');
+end;
+
+constructor TScriptThread.Create(fName: string; tup: Variant);
+begin
+  tuple := TStringList.Create;
+
+  functionName := fName;
+  with GetPythonEngine do
+    PyListToStrings(VariantAsPyObject(tup),tuple);
+
+  InterpreterState := MainInterpreterState;
+  FreeOnTerminate := True;
+  inherited Create(False);
+end;
+
+procedure TScriptThread.ExecuteWithPython;
+var
+  t: PPyObject;
+begin
+  try
+    with GetPythonEngine do
+    begin
+      t := StringsToPyTuple(tuple);
+      handlers.handleThread(functionName,PyObjectAsVariant(t));
+    end;
+
+  except
+    on E: Exception do
+    begin
+      PythonScriptDebugForm.Output.Lines.BeginUpdate;
+      PythonScriptDebugForm.Output.Lines.Add('');
+      PythonScriptDebugForm.Output.Lines.Add('Error while calling handleThread :'+E.Message);
+      PythonScriptDebugForm.Output.Lines.Add('----------------------------------');
+      JclLastExceptStackList.AddToStrings(PythonScriptDebugForm.Output.Lines, False, True, True);
+      PythonScriptDebugForm.Output.Lines.Add('----------------------------------');
+      PythonScriptDebugForm.Output.Lines.Add('');
+      PythonScriptDebugForm.Output.Lines.EndUpdate;
+    end;
+  end;
+end;
+
+procedure AcquireMainThread;
+begin
+   GetPythonEngine.PyEval_AcquireThread(MainThreadState);
+end;
+
+procedure ReleaseMainThread;
+begin
+   GetPythonEngine.PyEval_ReleaseThread(MainThreadState);
+end;
+
+procedure PyDict_SetItemStringDecRef(dp: PPyObject; Key: PAnsiChar; const V : Variant);
+var
+  o: PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    o := VariantAsPyObject(V);
+    PyDict_SetItemString(dp,Key,o);
+    Py_XDECREF(o);
+  end;
+end;
+
+procedure PyDict_SetItemDecRef(dp: PPyObject; Key: PPyObject; const V : Variant);
+var
+  o: PPyObject;
+begin
+  with GetPythonEngine do
+  begin
+    o := VariantAsPyObject(V);
+    PyDict_SetItem(dp,Key,o);
+    Py_XDECREF(o);
+  end;
+end;
+
+
+end.

Modified: trunk/Lobby/TASClient/MainUnit.ddp
===================================================================
(Binary files differ)

Modified: trunk/Lobby/TASClient/MainUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/MainUnit.dfm	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/MainUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -1,6 +1,6 @@
 object MainForm: TMainForm
-  Left = 826
-  Top = 271
+  Left = 631
+  Top = 286
   Width = 808
   Height = 549
   Caption = '.'
@@ -2265,7 +2265,7 @@
     Left = 209
     Top = 295
     Bitmap = {
-      494C010105000900040010001000FFFFFFFFFF10FFFFFFFFFFFFFFFF424D3600
+      494C010106000900040010001000FFFFFFFFFF10FFFFFFFFFFFFFFFF424D3600
       0000000000003600000028000000400000003000000001002000000000000030
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
@@ -2395,121 +2395,150 @@
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000A5A5A5008484
-      8400636363008484840000000000000000000000000000000000000000000000
+      00000000000000000000000000000000000000000000000000004CA4D9002680
+      C600105FB2002A85C90000000000000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000000000000A5A5A5008181
+      8100606060008686860000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000000000000000000000000000000000000000000072BEE5005FB2
+      DF00257FC5009AD4EE001161B300000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000000000000BFBFBF00B3B3
+      B30080808000D5D5D50062626200000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000BDBDBD00B5B5
-      B50084848400D6D6D60063636300000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      0000000000000000000000000000000000005DB1DF006EBCE400000000000000
+      00005DB1DF009AD4EE00105EB100000000000000000000000000000000000000
+      000000000000000000000000000000000000B2B2B200BDBDBD00000000000000
+      0000B2B2B200D5D5D5005F5F5F00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000B5B5B500BDBDBD00000000000000
-      0000B5B5B500D6D6D6005A5A5A00000000000000000000000000000000000000
+      000000000000000000000000000000000000105FB20058ADDD00000000000000
+      00002B86C9009AD4EE002883C800000000000000000000000000000000000000
+      00000000000000000000000000000000000060606000AEAEAE00000000000000
+      000087878700D5D5D50084848400000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000000000000000000000000000105FB2002680C600449ED600105E
+      B100257FC5009CD5EF002E89CB00000000000000000000000000000000000000
+      00000000000000000000000000000000000060606000818181009F9F9F005F5F
+      5F0080808000D6D6D6008A8A8A00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000063636300ADADAD00000000000000
-      000084848400D6D6D60084848400000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000000000000000000000000000105FB200105FB200257FC500439D
+      D5009AD4EE00257FC5009ED6EF0048A1D7000000000000000000000000000000
+      0000000000000000000000000000000000006060600060606000808080009E9E
+      9E00D5D5D50080808000D7D7D700A2A2A2000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000063636300848484009C9C9C005A5A
-      5A0084848400D6D6D6008C8C8C00000000000000000000000000000000000000
+      000000000000000000000000000000000000000000002781C700257FC500257F
+      C5001D75C0009AD4EE00000000009AD4EE00328DCD0000000000000000000000
+      0000000000000000000000000000000000000000000082828200808080008080
+      800076767600D5D5D50000000000D5D5D5008E8E8E0000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000348FCE009CD5EF00000000009AD4EE00429CD500000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000006363630063636300848484009C9C
-      9C00D6D6D60084848400D6D6D600A5A5A5000000000000000000000000000000
+      00000000000090909000D6D6D60000000000D5D5D5009D9D9D00000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000000000001B71BD009AD4EE00000000009AD4EE00257FC5002680
+      C600105FB2001D75C00000000000000000000000000000000000000000000000
+      0000000000000000000072727200D5D5D50000000000D5D5D500808080008181
+      8100606060007676760000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000084848400848484008484
-      840073737300D6D6D60000000000D6D6D6008C8C8C0000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      00000000000000000000000000002680C6009AD4EE002680C6009AD4EE009AD4
+      EE009CD5EF009CD5EF0051A8DB00000000000000000000000000000000000000
+      000000000000000000000000000081818100D5D5D50081818100D5D5D500D5D5
+      D500D6D6D600D6D6D600A9A9A900000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000094949400D6D6D60000000000D6D6D6009C9C9C00000000000000
+      000000000000000000000000000000000000105FB2009AD4EE002680C600105E
+      B10051A8DB002680C6002E89CB00000000000000000000000000000000000000
+      00000000000000000000000000000000000060606000D5D5D500818181005F5F
+      5F00A9A9A900818181008A8A8A00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000000000000000000000000000105FB200449ED600237DC4000000
+      0000000000004CA4D900449ED600000000000000000000000000000000000000
+      000000000000000000000000000000000000606060009F9F9F007E7E7E000000
+      000000000000A5A5A5009F9F9F00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000073737300D6D6D60000000000D6D6D600848484008484
-      8400636363007373730000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000000000000000000000000000105FB200257FC5005CB0DF000000
+      00000000000073BFE50087CAEA00000000000000000000000000000000000000
+      0000000000000000000000000000000000006060600080808000B1B1B1000000
+      000000000000C0C0C000CBCBCB00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000000000000000000000000000105FB200105EB100257FC500449E
+      D60087CAEA000000000000000000000000000000000000000000000000000000
+      000000000000000000000000000000000000606060005F5F5F00808080009F9F
+      9F00CBCBCB000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000084848400D6D6D60084848400D6D6D600D6D6
-      D600D6D6D600D6D6D600ADADAD00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
+      000000000000000000000000000000000000000000001161B3001161B300257F
+      C50077C1E6000000000000000000000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000062626200626262008080
+      8000C2C2C2000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000063636300D6D6D600848484005A5A
-      5A00ADADAD00848484008C8C8C00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000636363009C9C9C007B7B7B000000
-      000000000000A5A5A5009C9C9C00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000006363630084848400B5B5B5000000
-      000000000000C6C6C600CECECE00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000636363005A5A5A00848484009C9C
-      9C00CECECE000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000063636300636363008484
-      8400C6C6C6000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
@@ -2533,35 +2562,6 @@
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
       000000000000635A5A00AD946B00946B39009C7B4A00ADA58C00000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
@@ -2657,11 +2657,11 @@
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000C3FF000000000000C1FF000000000000
-      31FF00000000000031FF00000000000001FF00000000000000FF000000000000
-      827F000000000000F93F000000000000FC83000000000000FE01000000000000
-      FF01000000000000FF19000000000000FF19000000000000FF07000000000000
-      FF87000000000000FFFF000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
+      00000000000000000000000000000000C3FFC3FF00000000C1FFC1FF00000000
+      31FF31FF0000000031FF31FF0000000001FF01FF0000000000FF00FF00000000
+      827F827F00000000F93FF93F00000000FC83FC8300000000FE01FE0100000000
+      FF01FF0100000000FF19FF1900000000FF19FF1900000000FF07FF0700000000
+      FF87FF8700000000FFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
       FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF83FFC7FFC7FFC7FF01F
       F83FF83FF83FE00FF01FF01FF01FE00FF01FF01FF01FE00FF01FF01FF01FE00F
       F83FF83FF83FE00FFC7FFC7FFC7FF01FFFFFFFFFFFFFF83FFFFFFFFFFFFFFFFF
@@ -7083,7 +7083,52 @@
   end
   object SearchPlayerFormPopupMenu: TSpTBXFormPopupMenu
     OnPopup = SearchPlayerFormPopupMenuPopup
-    Left = 628
+    Left = 652
     Top = 62
   end
+  object HttpCli3: THttpCli
+    LocalAddr = '0.0.0.0'
+    ProxyPort = '80'
+    Agent = 'Mozilla/4.0 (compatible; ICS)'
+    Accept = 'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*'
+    NoCache = False
+    ContentTypePost = 'application/x-www-form-urlencoded'
+    MultiThreaded = False
+    RequestVer = '1.0'
+    FollowRelocation = True
+    LocationChangeMaxCount = 5
+    BandwidthLimit = 10000
+    BandwidthSampling = 1000
+    Options = []
+    SocksAuthentication = socksNoAuthentication
+    Left = 420
+    Top = 166
+  end
+  object PyEngine: TAtomPythonEngine
+    InitThreads = True
+    IO = PyInOut
+    Left = 452
+    Top = 166
+  end
+  object lobbyScriptModule: TPythonModule
+    Engine = PyEngine
+    ModuleName = 'lobbyscript'
+    Errors = &lt;&gt;
+    Left = 524
+    Top = 166
+  end
+  object lobbyscriptWrapper: TPyDelphiWrapper
+    Engine = PyEngine
+    OnInitialization = lobbyscriptWrapperInitialization
+    Module = lobbyScriptModule
+    Left = 556
+    Top = 166
+  end
+  object PyInOut: TPythonInputOutput
+    OnSendData = PyInOutSendData
+    UnicodeIO = False
+    RawOutput = False
+    Left = 492
+    Top = 166
+  end
 end

Modified: trunk/Lobby/TASClient/MainUnit.pas
===================================================================
--- trunk/Lobby/TASClient/MainUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/MainUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -33,7 +33,7 @@
     (how to get form's &quot;normal&quot; width, height, left and top values, even when form is maximized)
 
   * <A HREF="http://delphi.about.com/od/vclusing/l/aa111803a.htm">http://delphi.about.com/od/vclusing/l/aa111803a.htm</A>
-    (how to add hyperlink functionality to TRichEdit)
+    (how to add hyperlink functionality to TExRichEdit)
 
   * <A HREF="http://delphi.about.com/od/formsdialogs/l/aa073101b.htm">http://delphi.about.com/od/formsdialogs/l/aa073101b.htm</A>
     (great article on how to change various form's attributes, like changing visibility of form
@@ -205,7 +205,8 @@
   JvDesktopAlertForm, DateUtils, Winsock, TBXToolPals, SpTBXItem, TB2Item,
   TBX, SpTBXControls, TBXDkPanels, SpTBXFormPopupMenu,IniFiles,StrUtils,
   TntStdCtrls, SpTBXEditors, Mask, JvExMask, JvSpin,TntComCtrls,JclUnicode,
-  GR32_Image, SpTBXTabs;
+  GR32_Image, SpTBXTabs, PythonEngine, AtomPythonEngine,VarPyth, PythonGUIInputOutput,
+  WrapDelphi,RichEdit2, ExRichEdit, JvComponentBase, JvMTComponents;
 
 const
   CountryNames: array[0..240] of string = (
@@ -510,7 +511,6 @@
 
 const
   VERSION_NUMBER = '0.38'; // Must be float value! (with a period as a decimal seperator)
-  BETA_NUMBER = 330;
   CHECK_BETA_LOBBY_URL = '<A HREF="http://tasclient.no-ip.org/TASClient.txt">http://tasclient.no-ip.org/TASClient.txt</A>';
   PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER + ' beta';
   KEEP_ALIVE_INTERVAL = 10000; // in milliseconds. Tells us what should be the maximum &quot;silence&quot; time before we send a ping to the server.
@@ -537,7 +537,8 @@
   LOG_FOLDER = LOBBY_FOLDER + '\' + 'logs'; // this is where we store chat logs
   VAR_FOLDER = LOBBY_FOLDER + '\' + 'var';
   FILTERS_FOLDER = VAR_FOLDER + '\filters';
-  SPSKIN_FOLDER = 'TASClientSkins';
+  SPSKIN_FOLDER = LOBBY_FOLDER + '\SPSkins';
+  SCRIPTS_FOLDER = LOBBY_FOLDER + '\Python\engine';
   FIRST_UDP_SOURCEPORT = 8300; // udp source port (used with &quot;fixed source ports&quot; NAT traversal technique) of the second (first one is host) client in clients list of the battle. Third client uses this+1 port, fourth one this+2, etc.
   AIDLL_FOLDER = 'AI/Bot-libs'; // searching for *.dll in this folder will return all bots that you can use to play with
   MAP_DOWNLOADER_ENABLED = False; // integrated map downloader is currently disabled as FileUniverse.com is no longer hosting spring content
@@ -562,6 +563,7 @@
   WM_CONNECT_TO_NEXT_HOST = WM_USER + 10; // used with &quot;Connect to backup host if primary fails&quot; option
   WM_LOAD_NEXT_MINIMAP = WM_USER + 11; // used with loding missing minimaps from MapListForm (this message is sent to InitWaitForm)
   WM_AFTERCREATE = WM_USER + 12; // we send this signal once we've finished creating all forms. We will do some post-initialization here
+  WM_REFRESHOUTPUT = WM_USER + 13; // used to refresh script debug output
 
   QUEUE_LENGTH = 4096;
 
@@ -726,6 +728,22 @@
     constructor Create(Suspended : Boolean);
   end;
 
+  TDownloadMapThread = class(TThread)
+  private
+    MapHash: integer;
+    MapName: string;
+
+    procedure GetLink;
+    procedure OpenBrowser;
+    procedure OnTerminateProcedure(Sender : TObject);
+
+  protected
+    procedure Execute; override;
+
+  public
+    constructor Create(Suspended : Boolean;hash: integer;name: string);
+  end;
+
   TCheckNewBetaLobbyThread = class(TDialogThread)
   private
     confirmation: boolean;
@@ -1092,6 +1110,11 @@
     btSavePreset: TSpTBXButton;
     PresetNameTextbox: TSpTBXEdit;
     SinglePlayerButton: TSpTBXButton;
+    HttpCli3: THttpCli;
+    PyEngine: TAtomPythonEngine;
+    lobbyScriptModule: TPythonModule;
+    lobbyscriptWrapper: TPyDelphiWrapper;
+    PyInOut: TPythonInputOutput;
     procedure mnuOpenPrivateChatClick(Sender: TObject);
     procedure mnuSelectBattleClick(Sender: TObject);
     procedure SpTBXItem1Click(Sender: TObject);
@@ -1215,6 +1238,9 @@
     procedure btDeletePresetClick(Sender: TObject);
     procedure btClearPresetClick(Sender: TObject);
     procedure SinglePlayerButtonClick(Sender: TObject);
+    procedure lobbyscriptWrapperInitialization(Sender: TObject);
+    procedure PyInOutSendData(Sender: TObject;
+      const Data: String);
 
   published
     MainTitleBar: TSpTBXTitleBar;
@@ -1314,6 +1340,8 @@
     function GetClientByIP(IP: string): TClient; // returns nil if not found
     function GetClientIndexEx(Name: string; ClientList: TList): Integer;
 
+    function GetGroup(Name: string): TClientGroup; // returns nil if not found
+
     function GetBot(Name: string; Battle: TBattle): TBot;
 
     procedure TryToDisconnect;
@@ -1354,6 +1382,8 @@
     procedure ResetAutoKickMsgSentCounters;
     procedure ResetAutoSpecMsgSentCounters;
 
+    procedure initLobbyScript;
+
   published
     procedure ApplicationEvents1ShortCut(var Msg: TWMKey; var Handled: Boolean);
     procedure FormCreate(Sender: TObject);
@@ -1419,7 +1449,7 @@
 
   public
     procedure TryToConnect; overload;
-    procedure TryToConnect(ServerAddress, ServerPort: string); overload;
+    procedure TryToConnect(ServerAddress, ServerPort: string; DontRecoToBackup : boolean = false); overload;
 
     procedure AddMainLog(Text: WideString; Color: TColor); overload;
     procedure AddMainLog(Text: WideString; Color: TColor; AmbiguousCommandID: Integer); overload;
@@ -1443,6 +1473,8 @@
     Log: Boolean; // save local tab's text to disk on program exit
     FilterPingPong: Boolean;
     IgnoreVersionIncompatibility: Boolean;
+    LoginWithPasswordOnLan: Boolean;
+    IgnoreRedirects: Boolean;
   end;
 
   MainForm: TMainForm;
@@ -1574,8 +1606,10 @@
   MyInternetIp: String;
 
   JoinAsSpectator : Boolean;
-  
 
+  // script var
+  handlers: variant;
+
   function Dequeue: WideString; forward;
   function Enqueue(s: WideString): Integer; forward;
 
@@ -1588,7 +1622,8 @@
   HostBattleFormUnit, AgreementUnit, PerformFormUnit, HighlightingUnit,
   IgnoreListUnit, MuteListFormUnit, MapListFormUnit, SplashScreenUnit,
   LoginProgressFormUnit, GpIFF, SearchFormUnit, ManageGroups, ColorPicker,
-  AwayMessageFormUnit,JclStrings, SearchPlayerFormUnit, MenuFormUnit, Utility;
+  AwayMessageFormUnit,JclStrings, SearchPlayerFormUnit, MenuFormUnit, Utility,
+  PythonScriptDebugFormUnit,LobbyScriptUnit;
 
 {$R *.dfm}
 
@@ -1683,9 +1718,6 @@
 
   // message ID is currently still contained in this string, it will get extracted in ProcessRemoteCommand method
 
-  if Debug.Enabled and ((not Debug.FilterPingPong) or (s &lt;&gt; 'PONG')) then
-    if (s &lt;&gt; 'ACQUIREUSERID') or Status.Me.GetAccess then
-      AddMainLog('Server: &quot;' + s + '&quot;', Colors.Data);
   Status.LastCommandReceivedFull := s;
   // Status.LastCommandReceived will get assigned in ProcessRemoteCommand method!
   Inc(Status.CumulativeDataRecv, Length(s));
@@ -1928,7 +1960,7 @@
   index: Integer;
 begin
   if not FlagBitmapsInitialized then raise Exception.CreateFmt('Erro: FlagBitmaps not initialized! Please report this error!', []);
-
+  
   index := FlagBitmapsReverseTable[Ord(Country[1]), Ord(Country[2])];
   if index = -1 then index := FlagBitmapsReverseTable[Ord('x'), Ord('x')];
   Result := FlagBitmaps[index];
@@ -2185,6 +2217,20 @@
   Result := nil;
 end;
 
+function TMainForm.GetGroup(Name: string): TClientGroup;
+var
+  i: integer;
+begin
+  for i := 0 to ClientGroups.Count - 1 do
+    if TClientGroup(ClientGroups[i]).Name = Name then
+    begin
+      Result := TClientGroup(ClientGroups[i]);
+      Exit;
+    end;
+
+  Result := nil;
+end;
+
 function TMainForm.GetClientByIP(IP: string): TClient;
 var
   i: Integer;
@@ -3246,7 +3292,7 @@
 var
   p: TENLink;
   sURL: string;
-  CE : TTntRichEdit;
+  CE : TExRichEdit;
 begin
   if (Msg.Msg = WM_NOTIFY) then
   begin
@@ -3256,7 +3302,7 @@
       if (p.Msg = WM_LBUTTONDOWN) then
       begin
         try
-          CE := TTntRichEdit(Self.Controls[1] as TTntRichEdit);
+          CE := TExRichEdit(Self.Controls[1] as TExRichEdit);
           SendMessage(CE.Handle, EM_EXSETSEL, 0, Longint(@(p.chrg)));
           sURL := CE.SelText;
           Misc.OpenURLInDefaultBrowser(sURL);
@@ -3547,8 +3593,11 @@
     // finally apply post-initialization preferences:
     PreferencesForm.ApplyPostInitializationPreferences;
 
-    SplashScreenForm.UpdateText('loading menu ...');
-    MenuForm.LoadSkin(Preferences.SPSkin);
+    if not RunningUnderWine then
+    begin
+      SplashScreenForm.UpdateText('loading menu ...');
+      MenuForm.LoadSkin(Preferences.SPSkin);
+    end;
 
     // hide splash screen:
     SplashScreenForm.Close;
@@ -3568,9 +3617,9 @@
     ReplaysUnit.TReadReplaysThrd.Create(False); // start reading replays from disk
 
     // reenable auto URL detection for $local because it's doesn't work the first time
-    //mask := SendMessage(((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TTntRichEdit).Handle, EM_GETEVENTMASK, 0, 0);
-    //SendMessage(((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TTntRichEdit).Handle, EM_SETEVENTMASK, 0, mask or ENM_LINK);
-    //SendMessage(((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TTntRichEdit).Handle, EM_AUTOURLDETECT, Integer(True), 0);
+    //mask := SendMessage(((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Handle, EM_GETEVENTMASK, 0, 0);
+    //SendMessage(((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Handle, EM_SETEVENTMASK, 0, mask or ENM_LINK);
+    //SendMessage(((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Handle, EM_AUTOURLDETECT, Integer(True), 0);
 
     ReplaysForm.LoadReplayFiltersFromFile;
     ReplaysForm.UpdateReplayFilters;
@@ -3579,7 +3628,10 @@
     if RunningWithMainMenu then
       MenuForm.Show
     else
+    begin
       MainForm.Visible := True;
+      initLobbyScript;
+    end;
 
     // check new version
     if Preferences.CheckForNewVersion then
@@ -3649,10 +3701,10 @@
   that the entire line is the chat text. }
 procedure TMainForm.AddTextToChatWindow(Chat: TMyTabSheet; Text: WideString; Color: TColor; ChatTextPos: Integer; DoNotHighLight : Boolean = false);
 var
-  re: TTntRichEdit;
+  re: TExRichEdit;
   s: WideString;
 begin
-  re := Chat.Controls[1] as TTntRichEdit;
+  re := Chat.Controls[1] as TExRichEdit;
   if Preferences.TimeStamps then
   begin
     s := '[' + TimeToStr(Now) + '] ';
@@ -3685,7 +3737,7 @@
 function TMainForm.AddTabWindow(Caption: string; SetFocus: Boolean): Integer;
 var
   tmpts: TMyTabSheet;
-  tmpre: TTntRichEdit;
+  tmpre: TExRichEdit;
   tmped: TSpTBXEdit;
   mask: Word;
   FileName: string;
@@ -3708,20 +3760,24 @@
 
   tmpts.PageControl := PageControl1;
 
-  tmpre := TTntRichEdit.Create(tmpts);
+  tmpre := TExRichEdit.Create(tmpts);
   tmpre.Parent := tmpts;
   tmpre.Font.Assign(CommonFont);
   tmpre.ScrollBars := ssVertical;
   tmpre.ReadOnly := True;
-  tmpre.PlainText := True;
+  tmpre.AutoVerbMenu := False;
+  tmpre.PlainRTF := False;
   tmpre.WordWrap := True;
   tmpre.TabStop := False;
   tmpre.Align := alClient;
   tmpre.WantTabs := False;
   tmpre.HideSelection := False;
+  tmpre.IncludeOLE := False;
   tmpre.PopupMenu := RichEditPopupMenu;
   tmpre.OnMouseDown := RichEditMouseDown;
+  tmpre.AutoURLDetect := adDefault;
   tmpre.OnDblClick := RichEditDblClick;
+
   // enable auto URL detection:
   mask := SendMessage(tmpre.Handle, EM_GETEVENTMASK, 0, 0);
   SendMessage(tmpre.Handle, EM_SETEVENTMASK, 0, mask or ENM_LINK);
@@ -3876,6 +3932,7 @@
   res: Integer;
   str: WideString;
   pinginfo: PPingInfo;
+  handleCommandReturn: boolean;
 begin
 
   if s = '' then Exit;
@@ -3883,7 +3940,14 @@
   sl[0] := UpperCase(sl[0]);
 
   try
-    if sl[0] = 'CONNECT' then TryToConnect
+
+    handleCommandReturn := false;
+    AcquireMainThread;
+    try handleCommandReturn := handlers.handleCommand(s); except end;
+    ReleaseMainThread;
+
+    if handleCommandReturn then Exit
+    else if sl[0] = 'CONNECT' then TryToConnect
     else if (sl[0] = 'QUIT') and (sl.Count=1) then MainForm.Close
     else if (sl[0] = 'QUIT') and (sl.Count&gt;1) then
     begin
@@ -4214,7 +4278,7 @@
     end
     else if (sl[0] = 'VERSION') then
     begin
-      AddMainLog('TASClient version : '+VERSION_NUMBER+' rev '+IntToStr(BETA_NUMBER), Colors.Info);
+      AddMainLog('TASClient version : '+VERSION_NUMBER+' rev '+IntToStr(Misc.GetLobbyRevision), Colors.Info);
       Exit;
     end
     else if (sl[0] = 'TESTFLOOD') then
@@ -4339,6 +4403,16 @@
   luaOpt: TLuaOption;
   cTmp: TColor;
 begin
+  tmp := s;
+
+  AcquireMainThread;
+  try s := handlers.handleIn(s); except end;
+  ReleaseMainThread;
+
+  if Debug.Enabled and ((not Debug.FilterPingPong) or (s &lt;&gt; 'PONG')) then
+    if (s &lt;&gt; 'ACQUIREUSERID') or Status.Me.GetAccess then
+      AddMainLog('Server: &quot;' + s + '&quot;', Colors.Data);
+
   if s = '' then Exit;
   sl := ParseString(s, ' ');
   if sl[0][1] = '#' then // message ID is present. Lets extract it!
@@ -4398,9 +4472,12 @@
         AddMainLog('Error: Server sent ambiguous command!', Colors.Error, 0);
         Exit;
       end;
-      AddMainLog('Server is redirecting us to: ' + sl[1], Colors.Info);
-      Preferences.RedirectIP := sl[1];
-      PostMessage(MainForm.Handle, WM_FORCERECONNECT, 0, 0); // we must post a message, reconnecting from here won't work
+      if not Debug.IgnoreRedirects then
+      begin
+        AddMainLog('Server is redirecting us to: ' + sl[1], Colors.Info);
+        Preferences.RedirectIP := sl[1];
+        PostMessage(MainForm.Handle, WM_FORCERECONNECT, 0, 0); // we must post a message, reconnecting from here won't work
+      end;
     end
     else if sl[0] = 'AGREEMENT' then
     begin
@@ -4473,6 +4550,10 @@
           if not tmpBool then
             ProcessCommand('JOIN '+PageControl1.Pages[i].Caption,False);
         end;
+
+      AcquireMainThread;
+      try s := handlers.onLoggedIn(); except end;
+      ReleaseMainThread;
     end
     else if sl[0] = 'REGISTRATIONACCEPTED' then
     begin
@@ -5754,6 +5835,8 @@
           end;
           if Client = Status.Me then // this should normally not happen since we disconnect from the battle immediately after receiving FORCEQUITBATTLE command from the server
             BattleForm.ResetBattleScreen;
+
+          BattleForm.StartButton.Enabled := BattleForm.isBattleReadyToStart;
         end;
     end
     else if sl[0] = 'CLIENTSTATUS' then
@@ -6155,7 +6238,7 @@
 
           BattleForm.SendBattleInfoToServer;
         end;
-        BattleForm.StartButton.Enabled := BattleState.Battle.AreAllClientsReady and BattleState.Battle.AreAllClientsSynced and BattleForm.LadderTeamReady;
+        BattleForm.StartButton.Enabled := BattleForm.isBattleReadyToStart;
       end;
       BattleForm.RefreshTeamNbr;
       Client.StatusRefreshed := True;
@@ -6517,10 +6600,10 @@
    SelectedNick: string;
    SelectedClient: TClient;
 begin
-   with TTntRichEdit(Sender) do
+   with TExRichEdit(Sender) do
    begin
      GetCursorPos(pt);
-     pt := TTntRichEdit(Sender).ScreenToClient(pt);
+     pt := TExRichEdit(Sender).ScreenToClient(pt);
      //Pt := Point(X, Y) ;
      ci := Perform(Messages.EM_CHARFROMPOS, 0, Integer(@Pt)) ;
      if ci &lt; 0 then Exit;
@@ -6559,7 +6642,7 @@
 begin
   if Button = mbRight then
   begin
-   with TTntRichEdit(Sender) do
+   with TExRichEdit(Sender) do
    begin
      Pt := Point(X, Y) ;
      ci := Perform(Messages.EM_CHARFROMPOS, 0, Integer(@Pt)) ;
@@ -6584,7 +6667,7 @@
        ModerationSubmenuItem.Visible := Status.Me.GetAccess; // only moderators may see moderation menu!
        MuteSubitemMenu.Visible := LeftStr(PageControl1.ActivePage.Caption,1) = '#';
        mnuUnmute.Visible := LeftStr(PageControl1.ActivePage.Caption,1) = '#';
-       ClientPopupMenu.Popup(TTntRichEdit(Sender).ClientToScreen(pt).X,TTntRichEdit(Sender).ClientToScreen(pt).Y);
+       ClientPopupMenu.Popup(TExRichEdit(Sender).ClientToScreen(pt).X,TExRichEdit(Sender).ClientToScreen(pt).Y);
        RichEditSelectedClient := nil;
      end;
    end;
@@ -6793,6 +6876,9 @@
 procedure TMainForm.TryToDisconnect;
 begin;
   try
+    AcquireMainThread;
+    try handlers.onDisconnect; except end;
+    ReleaseMainThread;
     Socket.CloseDelayed; // we must call CloseDelayed and not just Close, because this method is called from various methods and events like OnDataAvailable!
     MainForm.MainTitleBar.Caption := PROGRAM_VERSION;
     MainForm.Caption := PROGRAM_VERSION;
@@ -6807,10 +6893,9 @@
   Status.CurrentAwayItem := -2; // status : available
 end;
 
-procedure TMainForm.TryToConnect(ServerAddress, ServerPort: string);
+procedure TMainForm.TryToConnect(ServerAddress, ServerPort: string; DontRecoToBackup : boolean = false);
 var
   bufsize: Integer;
-  t: TGetInternetIpThread;
 begin
   if Status.ConnectionState &lt;&gt; Disconnected then TryToDisconnect;
 
@@ -6826,10 +6911,10 @@
     WSocket_setsockopt(Socket.HSocket, SOL_SOCKET, SO_RCVBUF, @bufsize, SizeOf(bufsize));
     bufsize := 32768;
     WSocket_setsockopt(Socket.HSocket, SOL_SOCKET, SO_SNDBUF, @bufsize, SizeOf(bufsize));
-    //t := TGetInternetIpThread.Create(false);
+    //TGetInternetIpThread.Create(false);
   except
     AddMainLog('Error: cannot connect! (' + ServerAddress + ':' + ServerPort + ')', Colors.Error);
-    if Preferences.ReconnectToBackup then PostMessage(MainForm.Handle, WM_CONNECT_TO_NEXT_HOST, 0, 0);
+    if Preferences.ReconnectToBackup and not DontRecoToBackup then PostMessage(MainForm.Handle, WM_CONNECT_TO_NEXT_HOST, 0, 0);
   end;
 end;
 
@@ -6914,7 +6999,20 @@
     Exit;
   end;
 
+  AcquireMainThread;
   try
+    s := handlers.handleOut(s);
+    if s = '' then
+    begin
+      ReleaseMainThread;
+      exit;
+    end;
+  except
+  end;
+  ReleaseMainThread;
+
+
+  try
     sUTF8 := UTF8Encode(s+EOL);
     Socket.Send(PChar(sUTF8),length(sUTF8));
     Inc(Status.CumulativeDataSent, Length(s));
@@ -6955,11 +7053,15 @@
   ip: string;
   userid: string;
 begin;
+  AcquireMainThread;
+  try handlers.onLogin(); except end;
+  ReleaseMainThread;
+
   // let's send the login command:
   ReceivedAgreement.Clear; // clear temporary agreement, as server might send us a new one now
   ip := GetLocalIP;
   if ip = '' then ip := '*';
-  if ((Password = '') or (Status.ServerMode = 1{LAN MODE})) then Password := '*'; // probably local LAN mode. We have to send something as a password, so we just send an &quot;*&quot;.
+  if ((Password = '') or (Status.ServerMode = 1{LAN MODE}) and not Debug.LoginWithPasswordOnLan) then Password := '*'; // probably local LAN mode. We have to send something as a password, so we just send an &quot;*&quot;.
   userid := IntToHex(Misc.GetLobbyUserID, 1);
   TryToSendCommand('LOGIN', Username + ' ' + Password + ' ' + IntToStr(Status.MyCPU) + ' ' + ip + ' ' + PROGRAM_VERSION + IFF(userid &lt;&gt; '0', #9 + userid, ''));
 end;
@@ -7150,6 +7252,10 @@
   Status.CumulativeDataSent := 0;
   Status.CumulativeDataRecv := 0;
 
+  AcquireMainThread;
+  try handlers.onConnected(); except end;
+  ReleaseMainThread;
+
   AddMainLog('Connection established to ' + Socket.Addr, Colors.Info);
 end;
 
@@ -7615,7 +7721,10 @@
 
 procedure TMainForm.FormClose(Sender: TObject; var Action: TCloseAction);
 begin
-  if Debug.Log then ((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TRichEdit).Lines.SaveToFile(ExtractFilePath(Application.ExeName) + LOG_FILENAME);
+  AcquireMainThread;
+  try handlers.onClose; except end;
+
+  if Debug.Log then ((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Lines.SaveToFile(ExtractFilePath(Application.ExeName) + LOG_FILENAME);
   if FiltersButton.ImageIndex = 1 then
   begin
     FilterGroup.Height := 0;
@@ -7754,7 +7863,7 @@
 
 procedure TMainForm.Clearwindow1Click(Sender: TObject);
 begin
-  (PageControl1.ActivePage.Controls[1] as TTntRichEdit).Lines.Clear;
+  (PageControl1.ActivePage.Controls[1] as TExRichEdit).Lines.Clear;
 end;
 
 procedure TMainForm.ReplaysButtonClick(Sender: TObject);
@@ -8173,8 +8282,9 @@
     Brush.Color := $00ffdddd; { 0 b g r }
     Brush.Style := bsSolid;
     Rectangle(ClipRect);
-    Brush.Style := bsClear;
 
+    //Brush.Style := bsClear;
+
     if Header.Columns[Column].Text = 'Players' then
       TextOut(5, 2, Battle.ClientsToString)
     else if Header.Columns[Column].Text = 'Mod' then
@@ -8787,6 +8897,7 @@
   DlgTypeT := DlgType;
   ButtonsT := Buttons;
   HelpCtxT := HelpCtx;
+
   Synchronize(ShowLastMessage);
   Result := MessageDlgReturn;
 end;
@@ -8945,7 +9056,7 @@
 
 procedure TMainForm.Copy1Click(Sender: TObject);
 begin
-  (PageControl1.ActivePage.Controls[1] as TTntRichEdit).CopyToClipboard;
+  (PageControl1.ActivePage.Controls[1] as TExRichEdit).CopyToClipboard;
 end;
 
 procedure TMainForm.mnuIgnoreClick(Sender: TObject);
@@ -9481,12 +9592,12 @@
 var
   i: Integer;
    p: TPoint;
-   re : TTntRichEdit;
+   re : TExRichEdit;
 begin
   FixFormSizeConstraints(MainForm);
   for i:=0 to PageControl1.PageCount-1 do
   begin
-    re := PageControl1.Pages[i].Controls[1] as TTntRichEdit;
+    re := PageControl1.Pages[i].Controls[1] as TExRichEdit;
     re.SelLength := 0;
     re.SelStart := 0;
     re.SelStart := Length(re.text);
@@ -9640,13 +9751,14 @@
   try
     HttpCli2.Get;
   except
-    if Pos('Warning: Ladder server unavailable.',((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TTntRichEdit).Lines.Text) = 0 then
+    if Pos('Warning: Ladder server unavailable.',((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Lines.Text) = 0 then
       MainForm.AddMainLog('Warning: Ladder server unavailable.', Colors.Normal);
     Exit;
   end;
   HttpCli2.RcvdStream.Seek(0,0);
   SetLength(html, HttpCli2.RcvdStream.Size);
   HttpCli2.RcvdStream.ReadBuffer(Pointer(html)^, HttpCli2.RcvdStream.Size);
+  HttpCli2.RcvdStream.Free;
 
   // clear players cups
 
@@ -9663,7 +9775,7 @@
     try
       Misc.ParseDelimited(parse2,MidStr(parse1[i],Pos(' ',parse1[i]),MaxInt),#9,'');
     except
-      if Pos('Warning: Error while parsing top players ladder page.',((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TTntRichEdit).Lines.Text) = 0 then
+      if Pos('Warning: Error while parsing top players ladder page.',((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Lines.Text) = 0 then
         MainForm.AddMainLog('Warning: Error while parsing top players ladder page.', Colors.Normal);
       parse1.Free;
       parse2.Free;
@@ -9672,7 +9784,7 @@
     end;
     if parse2.Count &lt;&gt; 2 then
     begin
-      if Pos('Warning: Error while parsing top players ladder page.',((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TTntRichEdit).Lines.Text) = 0 then
+      if Pos('Warning: Error while parsing top players ladder page.',((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Lines.Text) = 0 then
         MainForm.AddMainLog('Warning: Error while parsing top players ladder page.', Colors.Normal);
       parse1.Free;
       parse2.Free;
@@ -9682,7 +9794,7 @@
     Misc.ParseDelimited(parse3,TrimRight(TrimLeft(parse2[1])),' ','');
     if parse3.Count &lt;&gt; 3 then
     begin
-      if Pos('Warning: Error while parsing top players ladder page.',((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TTntRichEdit).Lines.Text) = 0 then
+      if Pos('Warning: Error while parsing top players ladder page.',((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Lines.Text) = 0 then
         MainForm.AddMainLog('Warning: Error while parsing top players ladder page.', Colors.Normal);
       parse1.Free;
       parse2.Free;
@@ -9728,6 +9840,83 @@
   // nothing
 end;
 
+constructor TDownloadMapThread.Create(Suspended : Boolean;hash: integer;name: string);
+begin
+   FreeOnTerminate := True;
+   inherited Create(Suspended);
+   OnTerminate := OnTerminateProcedure;
+   MapHash := hash;
+   MapName := name;
+end;
+
+procedure TDownloadMapThread.Execute;
+begin
+  GetLink;
+end;
+
+procedure TDownloadMapThread.OpenBrowser;
+var
+  url: string;
+begin
+  url := StringReplace(MapName,'.smf','',[rfReplaceAll, rfIgnoreCase]);
+  url := '<A HREF="http://spring.jobjol.nl/search_result.php?search=">http://spring.jobjol.nl/search_result.php?search=</A>' + url+'&amp;select=select_all';
+  FixURL(url);
+  Misc.OpenURLInDefaultBrowser(url);
+end;
+
+procedure TDownloadMapThread.GetLink;
+var
+  html:string;
+begin
+  with MainForm do
+  begin
+
+
+  // direct download disabled
+  Synchronize(OpenBrowser);
+  Exit;
+
+  // get the html result
+  if Preferences.UseProxy then
+  begin
+    HttpCli3.Proxy := Preferences.ProxyAddress;
+    HttpCli3.ProxyPort := IntToStr(Preferences.ProxyPort);
+    HttpCli3.ProxyUsername := Preferences.ProxyUsername;
+    HttpCli3.ProxyPassword := Preferences.ProxyPassword
+  end
+  else HttpCli3.Proxy := '';
+  HttpCli3.URL := '<A HREF="http://evolutionrts.info/gethash.php?q=">http://evolutionrts.info/gethash.php?q=</A>'+IntToStr(MapHash);
+  HttpCli3.RcvdStream := TMemoryStream.Create;
+  try
+    HttpCli3.Get;
+  except
+    Synchronize(OpenBrowser);
+    Exit;
+  end;
+  HttpCli3.RcvdStream.Seek(0,0);
+  SetLength(html, HttpCli3.RcvdStream.Size);
+  HttpCli3.RcvdStream.ReadBuffer(Pointer(html)^, HttpCli3.RcvdStream.Size);
+  HttpCli3.RcvdStream.Free;
+
+  if html = '' then
+    Synchronize(OpenBrowser)
+  else
+  begin
+    html := StringReplace(html,#$A,'',[rfReplaceAll]);
+    DownloadFile.URL := '<A HREF="http://evolutionrts.info/">http://evolutionrts.info/</A>'+html;
+    DownloadFile.FileName := 'maps\'+Misc.ExtractFileNameFromUrl(DownloadFile.URL);
+    DownloadFile.ServerOptions := 8;
+    PostMessage(HttpGetForm.Handle, WM_STARTDOWNLOAD, 0, 0);
+  end;
+
+  end;
+end;
+
+procedure TDownloadMapThread.OnTerminateProcedure(Sender: TObject);
+begin
+  // nothing
+end;
+
 procedure TMainForm.LadderCupsRefreshTimer(Sender: TObject);
 var
   t: TLadderTopPlayersThread;
@@ -9767,6 +9956,9 @@
   else
     mnuQuickJoinPanel.Caption := 'Show Quick join panel';
 
+  mnuBattleDlMap.Enabled := Utility.MapList.IndexOf(SelectedBattle.Map) = -1;
+  mnuBattleDlMod.Enabled := Utility.ModList.IndexOf(SelectedBattle.ModName) = -1;
+
   VDTBattles.Repaint;
 end;
 
@@ -9984,7 +10176,7 @@
       HttpCli1.RcvdStream.ReadBuffer(Pointer(html)^, HttpCli1.RcvdStream.Size);
 
       Misc.ParseDelimited(parsedHtml,html,' ','');
-      if StrToInt(parsedHtml[0]) &gt; BETA_NUMBER then
+      if StrToInt(parsedHtml[0]) &gt; Misc.GetLobbyRevision then
       begin
         if not confirmation or (MessageDlgThread('A new beta version of the lobby is available, do you want to download it ?',mtInformation,[mbYes,mbNo],0) = mrYes) then
         begin
@@ -10011,14 +10203,10 @@
 
 procedure TMainForm.mnuBattleDlMapClick(Sender: TObject);
 var
-  url: string;
+  dlMap: TDownloadMapThread;
 begin
-  url := StringReplace(SelectedBattle.Map,'.smf','',[rfReplaceAll, rfIgnoreCase]);
-  {url := StringReplace(url,'_',' ',[rfReplaceAll, rfIgnoreCase]);
-  url := StringReplace(url,'-',' ',[rfReplaceAll, rfIgnoreCase]); }
-  url := '<A HREF="http://spring.jobjol.nl/search_result.php?search=">http://spring.jobjol.nl/search_result.php?search=</A>' + url+'&amp;select=select_all';
-  FixURL(url);
-  Misc.OpenURLInDefaultBrowser(url);
+  if Utility.MapList.IndexOf(SelectedBattle.Map) = -1 then
+    dlMap := TDownloadMapThread.Create(false,SelectedBattle.MapHash,SelectedBattle.Map);
 end;
 
 procedure TMainForm.mnuBattleDlModClick(Sender: TObject);
@@ -10240,4 +10428,48 @@
   MenuForm.Show;
 end;
 
+procedure TMainForm.lobbyscriptWrapperInitialization(Sender: TObject);
+var
+  p : PPyObject;
+begin
+  lobbyscriptWrapper.RegisterDelphiWrapper(TPyCallback);
+end;
+
+procedure TMainForm.initLobbyScript;
+begin
+
+  SysModule.path := NewPythonList;
+  SysModule.path.append('.\'+SCRIPTS_FOLDER);
+
+  try
+    handlers := Import('handlers');
+
+    with PyEngine do
+    begin
+      LobbyScriptUnit.MainInterpreterState := PyThreadState_Get.interp;
+      LobbyScriptUnit.MainThreadState := PyThreadState_Get;
+      LobbyScriptUnit.ScriptHostingRunning := False;
+      LobbyScriptUnit.ScriptHostingReplayRunning := False;
+      LobbyScriptUnit.ScriptJoining := False;
+      LobbyScriptUnit.ScriptStart := False;
+
+      handlers._load;
+
+      PyEval_ReleaseThread(LobbyScriptUnit.MainThreadState);
+    end;
+  except
+  end;
+
+
+end;
+
+procedure TMainForm.PyInOutSendData(Sender: TObject;
+  const Data: String);
+begin
+  PythonScriptDebugFormUnit.printList.BeginUpdate;
+  PythonScriptDebugFormUnit.printList.Add(Data);
+  PythonScriptDebugFormUnit.printList.EndUpdate;
+  PostMessage(PythonScriptDebugForm.Handle, WM_REFRESHOUTPUT, 0, 0);
+end;
+
 end.

Modified: trunk/Lobby/TASClient/MenuFormUnit.pas
===================================================================
--- trunk/Lobby/TASClient/MenuFormUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/MenuFormUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -8,7 +8,7 @@
   ExtCtrls,class_TIntegerList, MPlayer,MainUnit, SevenZipVCL,Contnrs,IniFiles;
 
 type
-  TPageType = (Main, CampaignsMenu,Campaign, CampaignMission, MissionsMenu, Mission, Skirmish, Loading);
+  TPageType = (Main, ModMain, CampaignsMenu, Campaign, CampaignMission, MissionsMenu, Mission, Skirmish, Loading);
 
   TMission =
   record
@@ -656,8 +656,8 @@
   htmlCode := replaceParams(htmlCode,fileName,'LOBBY:LOADSETTINGS',settingsNames,settingsValues);
 
   // save new html file and open it
-  SaveFile(CurrentPath+'temp654dsq.html',htmlCode);
-  htmlBrowser.NavigateToLocalFile(CurrentPath+'temp654dsq.html');
+  SaveFile(ExtractFilePath(CurrentPath+fileName)+'temp654dsq.html',htmlCode);
+  htmlBrowser.NavigateToLocalFile(ExtractFilePath(CurrentPath+fileName)+'temp654dsq.html');
   sl.Free;
 end;
 
@@ -1926,7 +1926,7 @@
 
   FileAttrs := faAnyFile;
 
-  if FindFirst(ExtractFilePath(Application.ExeName) + 'TASClientSkins\*.ssk', FileAttrs, sr) = 0 then
+  if FindFirst(ExtractFilePath(Application.ExeName) + SPSKIN_FOLDER + '\*.ssk', FileAttrs, sr) = 0 then
   begin
     repeat
       if (sr.Name &lt;&gt; '.') and (sr.Name &lt;&gt; '..') then

Modified: trunk/Lobby/TASClient/Misc.pas
===================================================================
--- trunk/Lobby/TASClient/Misc.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/Misc.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -10,7 +10,7 @@
 interface
 
 uses
-  SpTBXItem,JvSpin,Dialogs, Classes, ComCtrls, Windows, Graphics, MMSystem, Controls, Registry, SysUtils,
+  SpTBXItem,JvSpin,Dialogs, Classes, ComCtrls, Windows, Graphics, MMSystem, Controls, Registry, SysUtils,RichEdit2, ExRichEdit,
   WSocket, Winsock, ESBDates, GpTimeZone, JvColorCombo, Forms,StdCtrls,HttpProt,TntComCtrls,JclUnicode,TntSysUtils,PreferencesFormUnit,Variants;
 
 type
@@ -46,7 +46,7 @@
 function BoolToInt(b: Boolean): Integer;
 function IntToBool(i: Integer): Boolean;
 function HexToInt(HexStr: String): Integer;
-procedure AddTextToRichEdit(RichEdit: TTntRichEdit; Text: WideString; TextColor: TColor; Scroll: Boolean; ChatTextPos: Integer);
+procedure AddTextToRichEdit(RichEdit: TExRichEdit; Text: WideString; TextColor: TColor; Scroll: Boolean; ChatTextPos: Integer);
 procedure PlayResSound(RESName: string);
 procedure EnableControlAndChildren(Control: TWinControl); // enable group of controls
 procedure DisableControlAndChildren(Control: TWinControl); // disable group of controls
@@ -130,6 +130,8 @@
 function  GetLongPathName(FileName: string): string;
 Function DelTree(DirName : string): Boolean;
 Function BitmapFlip(Const Vertical : Boolean;Const Horizontal : Boolean;var BitmapIn : TBitmap;out BitmapOut : TBitmap): Boolean;
+function ExtractFileNameFromUrl(url: string): string;
+function GetLobbyRevision: integer;
 
 implementation
 
@@ -381,7 +383,7 @@
   get highlighted only in chat part of the text, not the header). If you don't specify ChatTextPos parameter, it is assumed
   that the entire line is the chat text.
 }
-procedure AddTextToRichEdit(RichEdit: TTntRichEdit; Text: WideString; TextColor: TColor; Scroll: Boolean; ChatTextPos: Integer);
+procedure AddTextToRichEdit(RichEdit: TExRichEdit; Text: WideString; TextColor: TColor; Scroll: Boolean; ChatTextPos: Integer);
 var
   SelStart, SelLength: Integer;
   p: TPoint;
@@ -389,45 +391,53 @@
   mask : Word;
 begin
   // enable auto URL detection each time because sometimes the links disapears
-  mask := SendMessage(RichEdit.Handle, EM_GETEVENTMASK, 0, 0);
-  SendMessage(RichEdit.Handle, EM_SETEVENTMASK, 0, mask or ENM_LINK);
-  SendMessage(RichEdit.Handle, EM_AUTOURLDETECT, Integer(True), 0);
+  //mask := SendMessage(RichEdit.Handle, EM_GETEVENTMASK, 0, 0);
+  //SendMessage(RichEdit.Handle, EM_SETEVENTMASK, 0, mask or ENM_LINK);
+  //SendMessage(RichEdit.Handle, EM_AUTOURLDETECT, Integer(True), 0);
 
   Text := Tnt_WideStringReplace(Text,#$0B,' ',[rfReplaceAll]);
 
-  RichEdit.Lines.BeginUpdate;
+  // save the scroll pos
+  SelStart := RichEdit.SelStart;
+  SelLength := RichEdit.SelLength;
+  SendMessage(RichEdit.Handle, WM_USER + 221 {EM_GETSCROLLPOS},  0, LPARAM(@p));
 
-    // save the scroll pos
-    SelStart := RichEdit.SelStart;
-    SelLength := RichEdit.SelLength;
-    SendMessage(RichEdit.Handle, WM_USER + 221 {EM_GETSCROLLPOS},  0, LPARAM(@p));
+  try
+    if Preferences.LimitChatLogs and (RichEdit.Lines.Count &gt;= Preferences.ChatLogsLimit+20) then
+    begin
+       RichEdit.SelStart  := 0;
+       RichEdit.SelLength := RichEdit.Perform(EM_LINEINDEX, 20, 0);
+       RichEdit.SelText   := '';
+    end;
 
+
+    RichEdit.SelLength := 0;
+    RichEdit.SelStart := RichEdit.GetTextLen;
+
     // get the scroll max
-    RichEdit.SelLength := 0;
-    RichEdit.SelStart := Length(RichEdit.Text);
     SendMessage(RichEdit.Handle, WM_USER + 221 {EM_GETSCROLLPOS},  0, LPARAM(@pMax));
 
-  try
-    if Preferences.LimitChatLogs and (RichEdit.Lines.Count &gt;= Preferences.ChatLogsLimit) then
-      RichEdit.Lines.Delete(0);
+    RichEdit.SelAttributes.Style := [];
+    RichEdit.SelAttributes.Color := TextColor;
+    
+    if RichEdit.SelStart = 0 then // to avoid the first empty line
+      RichEdit.WideSelText := Text
+    else
+      RichEdit.WideSelText :=  EOL + Text;
 
-    RichEdit.SelLength := 0;
-    RichEdit.SelStart := Length(RichEdit.Text);
-    RichEdit.SelAttributes.Color := TextColor;
-    RichEdit.Lines.Add(Text);
     // this will automatically highlight any keywords and pop-up notification windows (if set so):
     HighlightingForm.CheckLastLineForHighlights(RichEdit, ChatTextPos);
-  except
-  end;
 
-  if not Scroll or (p.Y &lt; Max(0,pMax.Y-20)) then
-  begin
     RichEdit.SelStart := SelStart;
     RichEdit.SelLength := SelLength;
-    SendMessage(RichEdit.Handle, WM_USER + 222 {EM_SETSCROLLPOS}, 0, LPARAM(@p));
+
+    if not Scroll or (p.Y &lt; Max(0,pMax.Y-20)) then
+      SendMessage(RichEdit.Handle, WM_USER + 222 {EM_SETSCROLLPOS}, 0, LPARAM(@p))
+    else
+      RichEdit.ScrollToBottom;
+
+  except
   end;
-
-  RichEdit.Lines.EndUpdate;
 end;
 
 { --------------------------------------------------------------------------- }
@@ -1959,8 +1969,8 @@
     Wnd := 0;
     pFrom := @DirBuf;
     wFunc := FO_DELETE;
-    fFlags := FOF_ALLOWUNDO;
-    fFlags := fFlags or FOF_NOCONFIRMATION;
+    //fFlags := FOF_ALLOWUNDO;  // add to the recycle bin instead of deleting
+    fFlags := FOF_NOCONFIRMATION;
     fFlags := fFlags or FOF_SILENT;
    end;
     Result := (SHFileOperation(SHFileOpStruct) = 0) ;
@@ -2014,5 +2024,45 @@
    End;
 End;
 
+function ExtractFileNameFromUrl(url: string): string;
+var
+  i: integer;
+begin
+  for i:=Length(url) downto 1 do
+  begin
+    if MidStr(url,i,1) = '/' then
+    begin
+      Result := MidStr(url,i+1,9999999);
+      Exit;
+    end;
+  end;
+end;
 
+function GetLobbyRevision: integer;
+var
+  exe: string;
+  n, Len: Cardinal;
+  versionBuff: string;
+  version: PChar;
+  sl: TStringList;
+begin
+  Result := 99999;
+
+  exe := Application.ExeName;
+  n := GetFileVersionInfoSize(PChar(exe),n);
+  SetLength(versionBuff,n);
+  GetFileVersionInfo(PChar(exe),0,n,PChar(versionBuff));
+  If VerQueryValue(PChar(versionBuff),PChar('StringFileInfo\040904E4\FileVersion'),Pointer(version),Len) Then
+  Begin
+    version := PChar(Trim(version)) ;
+    If Length(version) &gt; 0 Then
+    Begin
+      sl := TStringList.Create;
+      ParseDelimited(sl,version,'.','');
+      Result := StrToInt(sl[sl.Count-1]);
+    End;
+  End;
+end;
+
+
 end.

Modified: trunk/Lobby/TASClient/PreferencesFormUnit.pas
===================================================================
--- trunk/Lobby/TASClient/PreferencesFormUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/PreferencesFormUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -11,7 +11,8 @@
   JvPageList, JvNavigationPane, JvComponentBase, JvTabBar, JvLookOut,
   JvSpeedbar, JvExExtCtrls, JvCaptionPanel, JvExComCtrls, JvComCtrls, JvButton,
   JvMovableBevel, TntStdCtrls, SpTBXEditors, TBXThemes, TBXDkPanels,
-  SpTBXControls, SpTBXItem, TBX, SpTBXTabs, TB2Item, VirtualTrees, HttpProt,MainUnit,WSocket,TntComCtrls;
+  SpTBXControls, SpTBXItem, TBX, SpTBXTabs, TB2Item, VirtualTrees, HttpProt,
+  RichEdit2, ExRichEdit, MainUnit,WSocket,TntComCtrls;
 
 type
 
@@ -258,7 +259,7 @@
   end;
 
 const
-  DEFAULT_PREFERENCES: TPreferences = (ServerIP:'taspringmaster.clan-sy.com'; ServerPort:'8200'; TabStyle:0; TimeStamps: True; Username:''; Password:''; ConnectOnStartup: False; SortStyle: 1; BattleSortStyle: 1; BattleSortDirection: 0; BattleClientSortStyle: 2;FilterJoinLeftMessages: False;FilterBattleJoinLeftMessages: False; ShowFlags: True; MarkUnknownMaps: True; TaskbarButtons: True; JoinMainChannel: True; ReconnectToBackup: True; SaveLogs: True; UseSoundNotifications: True;AutoCompletionFromCurrentChannel: False; CheckForNewVersion: False; UseProxy: False; HighlightColor: 'Green'; UseNotificationsForHighlights: True; UseIgnoreList: False; WarnIfUsingNATTraversing: True; AutoFocusOnPM: True; MapSortStyle: 1; ThemeType: thtTBX; Theme: 'Miranda'; DisableAllSounds: False; SortLocal: False; DisplayQuickJoinPanel : True; LimitChatLogs: True; ChatLogsLimit: 800; SPSkin: 'default.ssk');
+  DEFAULT_PREFERENCES: TPreferences = (ServerIP:'taspringmaster.clan-sy.com'; ServerPort:'8200'; TabStyle:0; TimeStamps: True; Username:''; Password:''; ConnectOnStartup: False; SortStyle: 1; BattleSortStyle: 1; BattleSortDirection: 0; BattleClientSortStyle: 2;FilterJoinLeftMessages: False;FilterBattleJoinLeftMessages: False; ShowFlags: True; MarkUnknownMaps: True; TaskbarButtons: True; JoinMainChannel: True; ReconnectToBackup: True; SaveLogs: True; UseSoundNotifications: True;AutoCompletionFromCurrentChannel: False; CheckForNewVersion: False; UseProxy: False; HighlightColor: 'Green'; UseNotificationsForHighlights: True; UseIgnoreList: False; WarnIfUsingNATTraversing: True; AutoFocusOnPM: True; MapSortStyle: 1; ThemeType: thtTBX; Theme: 'Miranda'; DisableAllSounds: False; SortLocal: False; DisplayQuickJoinPanel : True; LimitChatLogs: False; ChatLogsLimit: 800; SPSkin: 'default.ssk');
 
 var
   PreferencesForm: TPreferencesForm;
@@ -353,7 +354,7 @@
 
     try CommonFont.Name := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences', 'FontName'); except end;
     try CommonFont.Size := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences', 'FontSize'); except end;
-    ((MainForm.PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TTntRichEdit).Font.Assign(CommonFont);
+    ((MainForm.PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Font.Assign(CommonFont);
     try Colors.Normal := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'Normal'); except end;
     try Colors.MyText := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'MyText'); except end;
     try Colors.AdminText := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'AdminText'); except end;
@@ -923,6 +924,7 @@
 
 procedure TPreferencesForm.FormShow(Sender: TObject);
 begin
+  PasswordChanged := false;
   SaveOnClose := False;
 end;
 
@@ -1401,7 +1403,7 @@
 
 procedure TPreferencesForm.PasswordEditChange(Sender: TObject);
 begin
-  if not PasswordEdit.Focused then Exit;
+  if not PasswordEdit.Focused and (SpTBXTabControl1.ActiveTabIndex = 1) then Exit;
   PasswordChanged := true;
 end;
 

Added: trunk/Lobby/TASClient/Python/api.txt
===================================================================
--- trunk/Lobby/TASClient/Python/api.txt	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/api.txt	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,38 @@
+callout :
+
+- Disconnect
+- ExitLobby
+- GetBattles
+- GetGroups
+- GetMaps
+- GetMods
+- GetMyUser
+- GetUsers
+- HandleProtocol(data)
+- LoadScripts
+- PerformConnected
+- PerformDisconnected
+- ReloadScript(scriptname)
+- ReloadScripts
+- SendProtocol(data)
+- ShowDebugWindow
+- SocketConnect(ip,port)
+- HostBattle(nbPlayers, RankLimit, ModName, Description, Password, UDPHostPort, NatTraversal) return true if success
+- JoinBattle(BattleId)
+- GetReplays
+- HostReplay(replayFile, nbPlayers, RankLimit, Description, Password, UDPHostPort, NatTraversal) return true if success
+- LeaveBattle
+- StartBattle
+- GetCurrentBattle
+
+Callin :
+
+- handleCommand(s)
+- handleIn(s)
+- onLoggedIn
+- onDisconnect
+- HandleOut(s)
+- onLogin
+- onConnected
+- onClose
+

Added: trunk/Lobby/TASClient/Python/engine/UserDict.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/UserDict.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/UserDict.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,175 @@
+&quot;&quot;&quot;A more or less complete user-defined wrapper around dictionary objects.&quot;&quot;&quot;
+
+class UserDict:
+    def __init__(self, dict=None, **kwargs):
+        self.data = {}
+        if dict is not None:
+            self.update(dict)
+        if len(kwargs):
+            self.update(kwargs)
+    def __repr__(self): return repr(self.data)
+    def __cmp__(self, dict):
+        if isinstance(dict, UserDict):
+            return cmp(self.data, dict.data)
+        else:
+            return cmp(self.data, dict)
+    def __len__(self): return len(self.data)
+    def __getitem__(self, key):
+        if key in self.data:
+            return self.data[key]
+        if hasattr(self.__class__, &quot;__missing__&quot;):
+            return self.__class__.__missing__(self, key)
+        raise KeyError(key)
+    def __setitem__(self, key, item): self.data[key] = item
+    def __delitem__(self, key): del self.data[key]
+    def clear(self): self.data.clear()
+    def copy(self):
+        if self.__class__ is UserDict:
+            return UserDict(self.data.copy())
+        import copy
+        data = self.data
+        try:
+            self.data = {}
+            c = copy.copy(self)
+        finally:
+            self.data = data
+        c.update(self)
+        return c
+    def keys(self): return self.data.keys()
+    def items(self): return self.data.items()
+    def iteritems(self): return self.data.iteritems()
+    def iterkeys(self): return self.data.iterkeys()
+    def itervalues(self): return self.data.itervalues()
+    def values(self): return self.data.values()
+    def has_key(self, key): return self.data.has_key(key)
+    def update(self, dict=None, **kwargs):
+        if dict is None:
+            pass
+        elif isinstance(dict, UserDict):
+            self.data.update(dict.data)
+        elif isinstance(dict, type({})) or not hasattr(dict, 'items'):
+            self.data.update(dict)
+        else:
+            for k, v in dict.items():
+                self[k] = v
+        if len(kwargs):
+            self.data.update(kwargs)
+    def get(self, key, failobj=None):
+        if not self.has_key(key):
+            return failobj
+        return self[key]
+    def setdefault(self, key, failobj=None):
+        if not self.has_key(key):
+            self[key] = failobj
+        return self[key]
+    def pop(self, key, *args):
+        return self.data.pop(key, *args)
+    def popitem(self):
+        return self.data.popitem()
+    def __contains__(self, key):
+        return key in self.data
+    @classmethod
+    def fromkeys(cls, iterable, value=None):
+        d = cls()
+        for key in iterable:
+            d[key] = value
+        return d
+
+class IterableUserDict(UserDict):
+    def __iter__(self):
+        return iter(self.data)
+
+class DictMixin:
+    # Mixin defining all dictionary methods for classes that already have
+    # a minimum dictionary interface including getitem, setitem, delitem,
+    # and keys. Without knowledge of the subclass constructor, the mixin
+    # does not define __init__() or copy().  In addition to the four base
+    # methods, progressively more efficiency comes with defining
+    # __contains__(), __iter__(), and iteritems().
+
+    # second level definitions support higher levels
+    def __iter__(self):
+        for k in self.keys():
+            yield k
+    def has_key(self, key):
+        try:
+            value = self[key]
+        except KeyError:
+            return False
+        return True
+    def __contains__(self, key):
+        return self.has_key(key)
+
+    # third level takes advantage of second level definitions
+    def iteritems(self):
+        for k in self:
+            yield (k, self[k])
+    def iterkeys(self):
+        return self.__iter__()
+
+    # fourth level uses definitions from lower levels
+    def itervalues(self):
+        for _, v in self.iteritems():
+            yield v
+    def values(self):
+        return [v for _, v in self.iteritems()]
+    def items(self):
+        return list(self.iteritems())
+    def clear(self):
+        for key in self.keys():
+            del self[key]
+    def setdefault(self, key, default=None):
+        try:
+            return self[key]
+        except KeyError:
+            self[key] = default
+        return default
+    def pop(self, key, *args):
+        if len(args) &gt; 1:
+            raise TypeError, &quot;pop expected at most 2 arguments, got &quot;\
+                              + repr(1 + len(args))
+        try:
+            value = self[key]
+        except KeyError:
+            if args:
+                return args[0]
+            raise
+        del self[key]
+        return value
+    def popitem(self):
+        try:
+            k, v = self.iteritems().next()
+        except StopIteration:
+            raise KeyError, 'container is empty'
+        del self[k]
+        return (k, v)
+    def update(self, other=None, **kwargs):
+        # Make progressively weaker assumptions about &quot;other&quot;
+        if other is None:
+            pass
+        elif hasattr(other, 'iteritems'):  # iteritems saves memory and lookups
+            for k, v in other.iteritems():
+                self[k] = v
+        elif hasattr(other, 'keys'):
+            for k in other.keys():
+                self[k] = other[k]
+        else:
+            for k, v in other:
+                self[k] = v
+        if kwargs:
+            self.update(kwargs)
+    def get(self, key, default=None):
+        try:
+            return self[key]
+        except KeyError:
+            return default
+    def __repr__(self):
+        return repr(dict(self.iteritems()))
+    def __cmp__(self, other):
+        if other is None:
+            return 1
+        if isinstance(other, DictMixin):
+            other = dict(other.iteritems())
+        return cmp(dict(self.iteritems()), other)
+    def __len__(self):
+        return len(self.keys())

Added: trunk/Lobby/TASClient/Python/engine/copy_reg.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/copy_reg.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/copy_reg.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,200 @@
+&quot;&quot;&quot;Helper to provide extensibility for pickle/cPickle.
+
+This is only useful to add pickle support for extension types defined in
+C, not for instances of user-defined classes.
+&quot;&quot;&quot;
+
+from types import ClassType as _ClassType
+
+__all__ = [&quot;pickle&quot;, &quot;constructor&quot;,
+           &quot;add_extension&quot;, &quot;remove_extension&quot;, &quot;clear_extension_cache&quot;]
+
+dispatch_table = {}
+
+def pickle(ob_type, pickle_function, constructor_ob=None):
+    if type(ob_type) is _ClassType:
+        raise TypeError(&quot;copy_reg is not intended for use with classes&quot;)
+
+    if not callable(pickle_function):
+        raise TypeError(&quot;reduction functions must be callable&quot;)
+    dispatch_table[ob_type] = pickle_function
+
+    # The constructor_ob function is a vestige of safe for unpickling.
+    # There is no reason for the caller to pass it anymore.
+    if constructor_ob is not None:
+        constructor(constructor_ob)
+
+def constructor(object):
+    if not callable(object):
+        raise TypeError(&quot;constructors must be callable&quot;)
+
+# Example: provide pickling support for complex numbers.
+
+try:
+    complex
+except NameError:
+    pass
+else:
+
+    def pickle_complex(c):
+        return complex, (c.real, c.imag)
+
+    pickle(complex, pickle_complex, complex)
+
+# Support for pickling new-style objects
+
+def _reconstructor(cls, base, state):
+    if base is object:
+        obj = object.__new__(cls)
+    else:
+        obj = base.__new__(cls, state)
+        base.__init__(obj, state)
+    return obj
+
+_HEAPTYPE = 1&lt;&lt;9
+
+# Python code for object.__reduce_ex__ for protocols 0 and 1
+
+def _reduce_ex(self, proto):
+    assert proto &lt; 2
+    for base in self.__class__.__mro__:
+        if hasattr(base, '__flags__') and not base.__flags__ &amp; _HEAPTYPE:
+            break
+    else:
+        base = object # not really reachable
+    if base is object:
+        state = None
+    else:
+        if base is self.__class__:
+            raise TypeError, &quot;can't pickle %s objects&quot; % base.__name__
+        state = base(self)
+    args = (self.__class__, base, state)
+    try:
+        getstate = self.__getstate__
+    except AttributeError:
+        if getattr(self, &quot;__slots__&quot;, None):
+            raise TypeError(&quot;a class that defines __slots__ without &quot;
+                            &quot;defining __getstate__ cannot be pickled&quot;)
+        try:
+            dict = self.__dict__
+        except AttributeError:
+            dict = None
+    else:
+        dict = getstate()
+    if dict:
+        return _reconstructor, args, dict
+    else:
+        return _reconstructor, args
+
+# Helper for __reduce_ex__ protocol 2
+
+def __newobj__(cls, *args):
+    return cls.__new__(cls, *args)
+
+def _slotnames(cls):
+    &quot;&quot;&quot;Return a list of slot names for a given class.
+
+    This needs to find slots defined by the class and its bases, so we
+    can't simply return the __slots__ attribute.  We must walk down
+    the Method Resolution Order and concatenate the __slots__ of each
+    class found there.  (This assumes classes don't modify their
+    __slots__ attribute to misrepresent their slots after the class is
+    defined.)
+    &quot;&quot;&quot;
+
+    # Get the value from a cache in the class if possible
+    names = cls.__dict__.get(&quot;__slotnames__&quot;)
+    if names is not None:
+        return names
+
+    # Not cached -- calculate the value
+    names = []
+    if not hasattr(cls, &quot;__slots__&quot;):
+        # This class has no slots
+        pass
+    else:
+        # Slots found -- gather slot names from all base classes
+        for c in cls.__mro__:
+            if &quot;__slots__&quot; in c.__dict__:
+                slots = c.__dict__['__slots__']
+                # if class has a single slot, it can be given as a string
+                if isinstance(slots, basestring):
+                    slots = (slots,)
+                for name in slots:
+                    # special descriptors
+                    if name in (&quot;__dict__&quot;, &quot;__weakref__&quot;):
+                        continue
+                    # mangled names
+                    elif name.startswith('__') and not name.endswith('__'):
+                        names.append('_%s%s' % (c.__name__, name))
+                    else:
+                        names.append(name)
+
+    # Cache the outcome in the class if at all possible
+    try:
+        cls.__slotnames__ = names
+    except:
+        pass # But don't die if we can't
+
+    return names
+
+# A registry of extension codes.  This is an ad-hoc compression
+# mechanism.  Whenever a global reference to &lt;module&gt;, &lt;name&gt; is about
+# to be pickled, the (&lt;module&gt;, &lt;name&gt;) tuple is looked up here to see
+# if it is a registered extension code for it.  Extension codes are
+# universal, so that the meaning of a pickle does not depend on
+# context.  (There are also some codes reserved for local use that
+# don't have this restriction.)  Codes are positive ints; 0 is
+# reserved.
+
+_extension_registry = {}                # key -&gt; code
+_inverted_registry = {}                 # code -&gt; key
+_extension_cache = {}                   # code -&gt; object
+# Don't ever rebind those names:  cPickle grabs a reference to them when
+# it's initialized, and won't see a rebinding.
+
+def add_extension(module, name, code):
+    &quot;&quot;&quot;Register an extension code.&quot;&quot;&quot;
+    code = int(code)
+    if not 1 &lt;= code &lt;= 0x7fffffff:
+        raise ValueError, &quot;code out of range&quot;
+    key = (module, name)
+    if (_extension_registry.get(key) == code and
+        _inverted_registry.get(code) == key):
+        return # Redundant registrations are benign
+    if key in _extension_registry:
+        raise ValueError(&quot;key %s is already registered with code %s&quot; %
+                         (key, _extension_registry[key]))
+    if code in _inverted_registry:
+        raise ValueError(&quot;code %s is already in use for key %s&quot; %
+                         (code, _inverted_registry[code]))
+    _extension_registry[key] = code
+    _inverted_registry[code] = key
+
+def remove_extension(module, name, code):
+    &quot;&quot;&quot;Unregister an extension code.  For testing only.&quot;&quot;&quot;
+    key = (module, name)
+    if (_extension_registry.get(key) != code or
+        _inverted_registry.get(code) != key):
+        raise ValueError(&quot;key %s is not registered with code %s&quot; %
+                         (key, code))
+    del _extension_registry[key]
+    del _inverted_registry[code]
+    if code in _extension_cache:
+        del _extension_cache[code]
+
+def clear_extension_cache():
+    _extension_cache.clear()
+
+# Standard extension code assignments
+
+# Reserved ranges
+
+# First  Last Count  Purpose
+#     1   127   127  Reserved for Python standard library
+#   128   191    64  Reserved for Zope
+#   192   239    48  Reserved for 3rd parties
+#   240   255    16  Reserved for private use (will never be assigned)
+#   256   Inf   Inf  Reserved for future assignment
+
+# Extension codes are assigned by the Python Software Foundation.

Added: trunk/Lobby/TASClient/Python/engine/dis.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/dis.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/dis.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,223 @@
+&quot;&quot;&quot;Disassembler of Python byte code into mnemonics.&quot;&quot;&quot;
+
+import sys
+import types
+
+from opcode import *
+from opcode import __all__ as _opcodes_all
+
+__all__ = [&quot;dis&quot;,&quot;disassemble&quot;,&quot;distb&quot;,&quot;disco&quot;] + _opcodes_all
+del _opcodes_all
+
+def dis(x=None):
+    &quot;&quot;&quot;Disassemble classes, methods, functions, or code.
+
+    With no argument, disassemble the last traceback.
+
+    &quot;&quot;&quot;
+    if x is None:
+        distb()
+        return
+    if type(x) is types.InstanceType:
+        x = x.__class__
+    if hasattr(x, 'im_func'):
+        x = x.im_func
+    if hasattr(x, 'func_code'):
+        x = x.func_code
+    if hasattr(x, '__dict__'):
+        items = x.__dict__.items()
+        items.sort()
+        for name, x1 in items:
+            if type(x1) in (types.MethodType,
+                            types.FunctionType,
+                            types.CodeType,
+                            types.ClassType):
+                print &quot;Disassembly of %s:&quot; % name
+                try:
+                    dis(x1)
+                except TypeError, msg:
+                    print &quot;Sorry:&quot;, msg
+                print
+    elif hasattr(x, 'co_code'):
+        disassemble(x)
+    elif isinstance(x, str):
+        disassemble_string(x)
+    else:
+        raise TypeError, \
+              &quot;don't know how to disassemble %s objects&quot; % \
+              type(x).__name__
+
+def distb(tb=None):
+    &quot;&quot;&quot;Disassemble a traceback (default: last traceback).&quot;&quot;&quot;
+    if tb is None:
+        try:
+            tb = sys.last_traceback
+        except AttributeError:
+            raise RuntimeError, &quot;no last traceback to disassemble&quot;
+        while tb.tb_next: tb = tb.tb_next
+    disassemble(tb.tb_frame.f_code, tb.tb_lasti)
+
+def disassemble(co, lasti=-1):
+    &quot;&quot;&quot;Disassemble a code object.&quot;&quot;&quot;
+    code = co.co_code
+    labels = findlabels(code)
+    linestarts = dict(findlinestarts(co))
+    n = len(code)
+    i = 0
+    extended_arg = 0
+    free = None
+    while i &lt; n:
+        c = code[i]
+        op = ord(c)
+        if i in linestarts:
+            if i &gt; 0:
+                print
+            print &quot;%3d&quot; % linestarts[i],
+        else:
+            print '   ',
+
+        if i == lasti: print '--&gt;',
+        else: print '   ',
+        if i in labels: print '&gt;&gt;',
+        else: print '  ',
+        print repr(i).rjust(4),
+        print opname[op].ljust(20),
+        i = i+1
+        if op &gt;= HAVE_ARGUMENT:
+            oparg = ord(code[i]) + ord(code[i+1])*256 + extended_arg
+            extended_arg = 0
+            i = i+2
+            if op == EXTENDED_ARG:
+                extended_arg = oparg*65536L
+            print repr(oparg).rjust(5),
+            if op in hasconst:
+                print '(' + repr(co.co_consts[oparg]) + ')',
+            elif op in hasname:
+                print '(' + co.co_names[oparg] + ')',
+            elif op in hasjrel:
+                print '(to ' + repr(i + oparg) + ')',
+            elif op in haslocal:
+                print '(' + co.co_varnames[oparg] + ')',
+            elif op in hascompare:
+                print '(' + cmp_op[oparg] + ')',
+            elif op in hasfree:
+                if free is None:
+                    free = co.co_cellvars + co.co_freevars
+                print '(' + free[oparg] + ')',
+        print
+
+def disassemble_string(code, lasti=-1, varnames=None, names=None,
+                       constants=None):
+    labels = findlabels(code)
+    n = len(code)
+    i = 0
+    while i &lt; n:
+        c = code[i]
+        op = ord(c)
+        if i == lasti: print '--&gt;',
+        else: print '   ',
+        if i in labels: print '&gt;&gt;',
+        else: print '  ',
+        print repr(i).rjust(4),
+        print opname[op].ljust(15),
+        i = i+1
+        if op &gt;= HAVE_ARGUMENT:
+            oparg = ord(code[i]) + ord(code[i+1])*256
+            i = i+2
+            print repr(oparg).rjust(5),
+            if op in hasconst:
+                if constants:
+                    print '(' + repr(constants[oparg]) + ')',
+                else:
+                    print '(%d)'%oparg,
+            elif op in hasname:
+                if names is not None:
+                    print '(' + names[oparg] + ')',
+                else:
+                    print '(%d)'%oparg,
+            elif op in hasjrel:
+                print '(to ' + repr(i + oparg) + ')',
+            elif op in haslocal:
+                if varnames:
+                    print '(' + varnames[oparg] + ')',
+                else:
+                    print '(%d)' % oparg,
+            elif op in hascompare:
+                print '(' + cmp_op[oparg] + ')',
+        print
+
+disco = disassemble                     # XXX For backwards compatibility
+
+def findlabels(code):
+    &quot;&quot;&quot;Detect all offsets in a byte code which are jump targets.
+
+    Return the list of offsets.
+
+    &quot;&quot;&quot;
+    labels = []
+    n = len(code)
+    i = 0
+    while i &lt; n:
+        c = code[i]
+        op = ord(c)
+        i = i+1
+        if op &gt;= HAVE_ARGUMENT:
+            oparg = ord(code[i]) + ord(code[i+1])*256
+            i = i+2
+            label = -1
+            if op in hasjrel:
+                label = i+oparg
+            elif op in hasjabs:
+                label = oparg
+            if label &gt;= 0:
+                if label not in labels:
+                    labels.append(label)
+    return labels
+
+def findlinestarts(code):
+    &quot;&quot;&quot;Find the offsets in a byte code which are start of lines in the source.
+
+    Generate pairs (offset, lineno) as described in Python/compile.c.
+
+    &quot;&quot;&quot;
+    byte_increments = [ord(c) for c in code.co_lnotab[0::2]]
+    line_increments = [ord(c) for c in code.co_lnotab[1::2]]
+
+    lastlineno = None
+    lineno = code.co_firstlineno
+    addr = 0
+    for byte_incr, line_incr in zip(byte_increments, line_increments):
+        if byte_incr:
+            if lineno != lastlineno:
+                yield (addr, lineno)
+                lastlineno = lineno
+            addr += byte_incr
+        lineno += line_incr
+    if lineno != lastlineno:
+        yield (addr, lineno)
+
+def _test():
+    &quot;&quot;&quot;Simple test program to disassemble a file.&quot;&quot;&quot;
+    if sys.argv[1:]:
+        if sys.argv[2:]:
+            sys.stderr.write(&quot;usage: python dis.py [-|file]\n&quot;)
+            sys.exit(2)
+        fn = sys.argv[1]
+        if not fn or fn == &quot;-&quot;:
+            fn = None
+    else:
+        fn = None
+    if fn is None:
+        f = sys.stdin
+    else:
+        f = open(fn)
+    source = f.read()
+    if fn is not None:
+        f.close()
+    else:
+        fn = &quot;&lt;stdin&gt;&quot;
+    code = compile(source, fn, &quot;exec&quot;)
+    dis(code)
+
+if __name__ == &quot;__main__&quot;:
+    _test()

Added: trunk/Lobby/TASClient/Python/engine/handlers.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/handlers.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/handlers.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,220 @@
+import lobbyscript
+api = lobbyscript.Callback()
+
+api.ShowDebugWindow()
+
+import sys, os
+basepath = sys.path[-1]
+sys.path.insert(1, os.path.join(basepath, '..', 'modules'))
+sys.path.insert(1, os.path.join(basepath, '..', 'scripts'))
+
+import inspect, time, thread
+scripts = {}
+
+global timers
+timers = []
+
+global threads
+threads = 0
+
+## TODO ##
+## Add try:except:traceback on everything
+##########
+
+global timer_lock
+timer_lock = thread.allocate_lock()
+
+global running
+global connected
+running = True
+connected = False
+
+def __timer_loop():
+	global timers
+	global running
+	global threads
+	threads += 1
+	while running:
+		timer_lock.acquire()
+		for i in xrange(len(timers)):
+			timers[i]['position'] -= 1
+			if timers[i]['position'] &lt;= 0:
+				timers[i]['position'] = timers[i]['max']
+				timers[i]['function']()
+		timer_lock.release()
+		time.sleep(1)
+	threads -= 1
+
+def _parse_timers():
+	global timers
+	print
+	print 'Parsing timers...'
+	timer_lock.acquire()
+	timers = []
+	for s in scripts:
+		script = scripts[s]
+		for attr in dir(script):
+			if attr.startswith('timer_'):
+				timer, secs = attr.split('_',1)
+				#try:
+				secs = int(secs)
+				exec 'timer = script.%s' % attr
+				if type(timer) == type(_parse_timers):
+					timers.append( {'function':timer, 'position':0, 'max':secs} )
+					print '%s registered timer function %s for every %s seconds' % (s, attr, secs)
+				else: print '%s is a bad timer hook -- it is not a function' % timer
+				#except: print '%s is a bad timer in script %s' % (attr, s)
+	print
+	timer_lock.release()
+
+def _load():
+	print 'Loading scripts:',
+	new = []
+	for s in os.listdir(os.path.join(basepath, '..', 'scripts')):
+		if not s.endswith('.py'): continue
+		s = os.path.split(s)[-1].rsplit('.py',1)[0]
+		if not s in scripts:
+			script = __import__(s)
+			if '_init' in dir(script):
+				script._init()
+			scripts[s] = script
+			new.append(s)
+	print ', '.join(new)
+	print
+	_parse_timers()
+	return new
+
+def _reloadall():
+	print 'Reloading scripts: ',
+	reloaded = []
+	for s in dict(scripts):
+		script = scripts[s]
+		if '_reload' in dir(script):
+			script._reload()
+		result = _reload(s)
+		reloaded.append(result)
+	print ', '.join(reloaded)
+	_parse_timers()
+	return reloaded
+
+def _reload(s):
+	script = scripts[s]
+	for a in dir(script):
+		if not a.startswith('__') or not a.endswith('__'):
+			exec 'del script.%s' % a # extremely hackish and will turn out something like 2.5 seconds slower
+									 # in 1 million runs than deleting directly... oh well :)
+	try:
+		reload(script)
+	except ImportError:
+		del scripts[s]
+		return '-%s' % s
+	if '_reinit' in dir(script):
+		script._reinit(api)
+	return s
+
+def _list():
+	reply = []
+	for s in scripts:
+		reply.append(s)
+	return ', '.join(reply)
+
+def _handle(direction, data):
+	for s in scripts:
+		if not data: return data
+
+		spaces = data.count(' ')
+		if spaces &gt;= 1:
+			cmd, args = data.split(' ',1)
+		else:
+			cmd = data
+			args = ''
+
+		funcname = '%s_%s' % (direction, cmd)
+		script = scripts[s]
+
+		if funcname in dir(script):
+			exec &quot;function = script.%s&quot; % funcname
+			if type(function) == type(_handle):
+
+				function_info = inspect.getargspec(function)
+				total_args = len(function_info[0])
+
+				if total_args == 0:
+					returned = function()
+				else:
+					if total_args &gt; spaces:
+						print 'Too many arguments in function %s of %s' % (funcname, s)
+					else:
+						args = args.split(' ',total_args-1)
+						returned = function(*args)
+				if returned == False: return
+				if data == None:
+					data = cmd
+				else:
+					if returned == None: data = ' '.join(args)
+					else: data = returned
+					if type(data) == tuple or type(data) == list: data = ' '.join(data)
+					if data: data = '%s %s' % (cmd, data)
+			else:
+				print ' %s has an attribute %s but it is not a function' % (s, funcname)
+	return data
+
+def handleIn(data, recursing=0):
+	return _handle('in', data)
+
+def handleOut(data, recursing=0):
+	return _handle('out', data)
+
+def _handle_callin(funcname, args=''):
+	if not funcname: return
+	for s in scripts:
+		script = scripts[s]
+		
+		spaces = args.count(' ')
+
+		if funcname in dir(script):
+			exec &quot;function = script.%s&quot; % funcname
+			if type(function) == type(_handle):
+
+				function_info = inspect.getargspec(function)
+				total_args = len(function_info[0])
+
+				if total_args == 0:
+					returned = function()
+				else:
+					if total_args &gt; spaces+1:
+						print 'Too many arguments in function %s of %s' % (funcname, s)
+						return False
+					else:
+						args = args.split(' ',total_args-1)
+						return function(*args)
+					
+			else:
+				print ' %s has an attribute %s but it is not a function' % (s, funcname)
+
+def onDisconnect():
+	_handle_callin('onDisconnect')
+
+def onConnected():
+	_handle_callin('onConnected')
+
+def onLogin():
+	_handle_callin('onLogin')
+
+def onLoggedIn():
+	_handle_callin('onLoggedIn')
+	
+def handleCommand(cmd):
+	spaces = cmd.count(' ')
+	if spaces &gt;= 1:
+		cmd, args = cmd.split(' ',1)
+	else:
+		cmd = cmd
+		args = ''
+	return _handle_callin('cmd_%s'%cmd, args)
+
+def onClose():
+	global running
+	running = False
+
+thread.start_new_thread(__timer_loop,())
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/engine/inspect.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/inspect.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/inspect.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,888 @@
+# -*- coding: iso-8859-1 -*-
+&quot;&quot;&quot;Get useful information from live Python objects.
+
+This module encapsulates the interface provided by the internal special
+attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.
+It also provides some help for examining source code and class layout.
+
+Here are some of the useful functions provided by this module:
+
+    ismodule(), isclass(), ismethod(), isfunction(), istraceback(),
+        isframe(), iscode(), isbuiltin(), isroutine() - check object types
+    getmembers() - get members of an object that satisfy a given condition
+
+    getfile(), getsourcefile(), getsource() - find an object's source code
+    getdoc(), getcomments() - get documentation on an object
+    getmodule() - determine the module that an object came from
+    getclasstree() - arrange classes so as to represent their hierarchy
+
+    getargspec(), getargvalues() - get info about function arguments
+    formatargspec(), formatargvalues() - format an argument spec
+    getouterframes(), getinnerframes() - get info about frames
+    currentframe() - get the current stack frame
+    stack(), trace() - get info about frames on the stack or in a traceback
+&quot;&quot;&quot;
+
+# This module is in the public domain.  No warranties.
+
+__author__ = 'Ka-Ping Yee &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">ping at lfw.org</A>&gt;'
+__date__ = '1 Jan 2001'
+
+import sys, os, types, string, re, dis, imp, tokenize, linecache
+from operator import attrgetter
+
+# ----------------------------------------------------------- type-checking
+def ismodule(object):
+    &quot;&quot;&quot;Return true if the object is a module.
+
+    Module objects provide these attributes:
+        __doc__         documentation string
+        __file__        filename (missing for built-in modules)&quot;&quot;&quot;
+    return isinstance(object, types.ModuleType)
+
+def isclass(object):
+    &quot;&quot;&quot;Return true if the object is a class.
+
+    Class objects provide these attributes:
+        __doc__         documentation string
+        __module__      name of module in which this class was defined&quot;&quot;&quot;
+    return isinstance(object, types.ClassType) or hasattr(object, '__bases__')
+
+def ismethod(object):
+    &quot;&quot;&quot;Return true if the object is an instance method.
+
+    Instance method objects provide these attributes:
+        __doc__         documentation string
+        __name__        name with which this method was defined
+        im_class        class object in which this method belongs
+        im_func         function object containing implementation of method
+        im_self         instance to which this method is bound, or None&quot;&quot;&quot;
+    return isinstance(object, types.MethodType)
+
+def ismethoddescriptor(object):
+    &quot;&quot;&quot;Return true if the object is a method descriptor.
+
+    But not if ismethod() or isclass() or isfunction() are true.
+
+    This is new in Python 2.2, and, for example, is true of int.__add__.
+    An object passing this test has a __get__ attribute but not a __set__
+    attribute, but beyond that the set of attributes varies.  __name__ is
+    usually sensible, and __doc__ often is.
+
+    Methods implemented via descriptors that also pass one of the other
+    tests return false from the ismethoddescriptor() test, simply because
+    the other tests promise more -- you can, e.g., count on having the
+    im_func attribute (etc) when an object passes ismethod().&quot;&quot;&quot;
+    return (hasattr(object, &quot;__get__&quot;)
+            and not hasattr(object, &quot;__set__&quot;) # else it's a data descriptor
+            and not ismethod(object)           # mutual exclusion
+            and not isfunction(object)
+            and not isclass(object))
+
+def isdatadescriptor(object):
+    &quot;&quot;&quot;Return true if the object is a data descriptor.
+
+    Data descriptors have both a __get__ and a __set__ attribute.  Examples are
+    properties (defined in Python) and getsets and members (defined in C).
+    Typically, data descriptors will also have __name__ and __doc__ attributes
+    (properties, getsets, and members have both of these attributes), but this
+    is not guaranteed.&quot;&quot;&quot;
+    return (hasattr(object, &quot;__set__&quot;) and hasattr(object, &quot;__get__&quot;))
+
+if hasattr(types, 'MemberDescriptorType'):
+    # CPython and equivalent
+    def ismemberdescriptor(object):
+        &quot;&quot;&quot;Return true if the object is a member descriptor.
+
+        Member descriptors are specialized descriptors defined in extension
+        modules.&quot;&quot;&quot;
+        return isinstance(object, types.MemberDescriptorType)
+else:
+    # Other implementations
+    def ismemberdescriptor(object):
+        &quot;&quot;&quot;Return true if the object is a member descriptor.
+
+        Member descriptors are specialized descriptors defined in extension
+        modules.&quot;&quot;&quot;
+        return False
+
+if hasattr(types, 'GetSetDescriptorType'):
+    # CPython and equivalent
+    def isgetsetdescriptor(object):
+        &quot;&quot;&quot;Return true if the object is a getset descriptor.
+
+        getset descriptors are specialized descriptors defined in extension
+        modules.&quot;&quot;&quot;
+        return isinstance(object, types.GetSetDescriptorType)
+else:
+    # Other implementations
+    def isgetsetdescriptor(object):
+        &quot;&quot;&quot;Return true if the object is a getset descriptor.
+
+        getset descriptors are specialized descriptors defined in extension
+        modules.&quot;&quot;&quot;
+        return False
+
+def isfunction(object):
+    &quot;&quot;&quot;Return true if the object is a user-defined function.
+
+    Function objects provide these attributes:
+        __doc__         documentation string
+        __name__        name with which this function was defined
+        func_code       code object containing compiled function bytecode
+        func_defaults   tuple of any default values for arguments
+        func_doc        (same as __doc__)
+        func_globals    global namespace in which this function was defined
+        func_name       (same as __name__)&quot;&quot;&quot;
+    return isinstance(object, types.FunctionType)
+
+def istraceback(object):
+    &quot;&quot;&quot;Return true if the object is a traceback.
+
+    Traceback objects provide these attributes:
+        tb_frame        frame object at this level
+        tb_lasti        index of last attempted instruction in bytecode
+        tb_lineno       current line number in Python source code
+        tb_next         next inner traceback object (called by this level)&quot;&quot;&quot;
+    return isinstance(object, types.TracebackType)
+
+def isframe(object):
+    &quot;&quot;&quot;Return true if the object is a frame object.
+
+    Frame objects provide these attributes:
+        f_back          next outer frame object (this frame's caller)
+        f_builtins      built-in namespace seen by this frame
+        f_code          code object being executed in this frame
+        f_exc_traceback traceback if raised in this frame, or None
+        f_exc_type      exception type if raised in this frame, or None
+        f_exc_value     exception value if raised in this frame, or None
+        f_globals       global namespace seen by this frame
+        f_lasti         index of last attempted instruction in bytecode
+        f_lineno        current line number in Python source code
+        f_locals        local namespace seen by this frame
+        f_restricted    0 or 1 if frame is in restricted execution mode
+        f_trace         tracing function for this frame, or None&quot;&quot;&quot;
+    return isinstance(object, types.FrameType)
+
+def iscode(object):
+    &quot;&quot;&quot;Return true if the object is a code object.
+
+    Code objects provide these attributes:
+        co_argcount     number of arguments (not including * or ** args)
+        co_code         string of raw compiled bytecode
+        co_consts       tuple of constants used in the bytecode
+        co_filename     name of file in which this code object was created
+        co_firstlineno  number of first line in Python source code
+        co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
+        co_lnotab       encoded mapping of line numbers to bytecode indices
+        co_name         name with which this code object was defined
+        co_names        tuple of names of local variables
+        co_nlocals      number of local variables
+        co_stacksize    virtual machine stack space required
+        co_varnames     tuple of names of arguments and local variables&quot;&quot;&quot;
+    return isinstance(object, types.CodeType)
+
+def isbuiltin(object):
+    &quot;&quot;&quot;Return true if the object is a built-in function or method.
+
+    Built-in functions and methods provide these attributes:
+        __doc__         documentation string
+        __name__        original name of this function or method
+        __self__        instance to which a method is bound, or None&quot;&quot;&quot;
+    return isinstance(object, types.BuiltinFunctionType)
+
+def isroutine(object):
+    &quot;&quot;&quot;Return true if the object is any kind of function or method.&quot;&quot;&quot;
+    return (isbuiltin(object)
+            or isfunction(object)
+            or ismethod(object)
+            or ismethoddescriptor(object))
+
+def getmembers(object, predicate=None):
+    &quot;&quot;&quot;Return all members of an object as (name, value) pairs sorted by name.
+    Optionally, only return members that satisfy a given predicate.&quot;&quot;&quot;
+    results = []
+    for key in dir(object):
+        value = getattr(object, key)
+        if not predicate or predicate(value):
+            results.append((key, value))
+    results.sort()
+    return results
+
+def classify_class_attrs(cls):
+    &quot;&quot;&quot;Return list of attribute-descriptor tuples.
+
+    For each name in dir(cls), the return list contains a 4-tuple
+    with these elements:
+
+        0. The name (a string).
+
+        1. The kind of attribute this is, one of these strings:
+               'class method'    created via classmethod()
+               'static method'   created via staticmethod()
+               'property'        created via property()
+               'method'          any other flavor of method
+               'data'            not a method
+
+        2. The class which defined this attribute (a class).
+
+        3. The object as obtained directly from the defining class's
+           __dict__, not via getattr.  This is especially important for
+           data attributes:  C.data is just a data object, but
+           C.__dict__['data'] may be a data descriptor with additional
+           info, like a __doc__ string.
+    &quot;&quot;&quot;
+
+    mro = getmro(cls)
+    names = dir(cls)
+    result = []
+    for name in names:
+        # Get the object associated with the name.
+        # Getting an obj from the __dict__ sometimes reveals more than
+        # using getattr.  Static and class methods are dramatic examples.
+        if name in cls.__dict__:
+            obj = cls.__dict__[name]
+        else:
+            obj = getattr(cls, name)
+
+        # Figure out where it was defined.
+        homecls = getattr(obj, &quot;__objclass__&quot;, None)
+        if homecls is None:
+            # search the dicts.
+            for base in mro:
+                if name in base.__dict__:
+                    homecls = base
+                    break
+
+        # Get the object again, in order to get it from the defining
+        # __dict__ instead of via getattr (if possible).
+        if homecls is not None and name in homecls.__dict__:
+            obj = homecls.__dict__[name]
+
+        # Also get the object via getattr.
+        obj_via_getattr = getattr(cls, name)
+
+        # Classify the object.
+        if isinstance(obj, staticmethod):
+            kind = &quot;static method&quot;
+        elif isinstance(obj, classmethod):
+            kind = &quot;class method&quot;
+        elif isinstance(obj, property):
+            kind = &quot;property&quot;
+        elif (ismethod(obj_via_getattr) or
+              ismethoddescriptor(obj_via_getattr)):
+            kind = &quot;method&quot;
+        else:
+            kind = &quot;data&quot;
+
+        result.append((name, kind, homecls, obj))
+
+    return result
+
+# ----------------------------------------------------------- class helpers
+def _searchbases(cls, accum):
+    # Simulate the &quot;classic class&quot; search order.
+    if cls in accum:
+        return
+    accum.append(cls)
+    for base in cls.__bases__:
+        _searchbases(base, accum)
+
+def getmro(cls):
+    &quot;Return tuple of base classes (including cls) in method resolution order.&quot;
+    if hasattr(cls, &quot;__mro__&quot;):
+        return cls.__mro__
+    else:
+        result = []
+        _searchbases(cls, result)
+        return tuple(result)
+
+# -------------------------------------------------- source code extraction
+def indentsize(line):
+    &quot;&quot;&quot;Return the indent size, in spaces, at the start of a line of text.&quot;&quot;&quot;
+    expline = string.expandtabs(line)
+    return len(expline) - len(string.lstrip(expline))
+
+def getdoc(object):
+    &quot;&quot;&quot;Get the documentation string for an object.
+
+    All tabs are expanded to spaces.  To clean up docstrings that are
+    indented to line up with blocks of code, any whitespace than can be
+    uniformly removed from the second line onwards is removed.&quot;&quot;&quot;
+    try:
+        doc = object.__doc__
+    except AttributeError:
+        return None
+    if not isinstance(doc, types.StringTypes):
+        return None
+    try:
+        lines = string.split(string.expandtabs(doc), '\n')
+    except UnicodeError:
+        return None
+    else:
+        # Find minimum indentation of any non-blank lines after first line.
+        margin = sys.maxint
+        for line in lines[1:]:
+            content = len(string.lstrip(line))
+            if content:
+                indent = len(line) - content
+                margin = min(margin, indent)
+        # Remove indentation.
+        if lines:
+            lines[0] = lines[0].lstrip()
+        if margin &lt; sys.maxint:
+            for i in range(1, len(lines)): lines[i] = lines[i][margin:]
+        # Remove any trailing or leading blank lines.
+        while lines and not lines[-1]:
+            lines.pop()
+        while lines and not lines[0]:
+            lines.pop(0)
+        return string.join(lines, '\n')
+
+def getfile(object):
+    &quot;&quot;&quot;Work out which source or compiled file an object was defined in.&quot;&quot;&quot;
+    if ismodule(object):
+        if hasattr(object, '__file__'):
+            return object.__file__
+        raise TypeError('arg is a built-in module')
+    if isclass(object):
+        object = sys.modules.get(object.__module__)
+        if hasattr(object, '__file__'):
+            return object.__file__
+        raise TypeError('arg is a built-in class')
+    if ismethod(object):
+        object = object.im_func
+    if isfunction(object):
+        object = object.func_code
+    if istraceback(object):
+        object = object.tb_frame
+    if isframe(object):
+        object = object.f_code
+    if iscode(object):
+        return object.co_filename
+    raise TypeError('arg is not a module, class, method, '
+                    'function, traceback, frame, or code object')
+
+def getmoduleinfo(path):
+    &quot;&quot;&quot;Get the module name, suffix, mode, and module type for a given file.&quot;&quot;&quot;
+    filename = os.path.basename(path)
+    suffixes = map(lambda (suffix, mode, mtype):
+                   (-len(suffix), suffix, mode, mtype), imp.get_suffixes())
+    suffixes.sort() # try longest suffixes first, in case they overlap
+    for neglen, suffix, mode, mtype in suffixes:
+        if filename[neglen:] == suffix:
+            return filename[:neglen], suffix, mode, mtype
+
+def getmodulename(path):
+    &quot;&quot;&quot;Return the module name for a given file, or None.&quot;&quot;&quot;
+    info = getmoduleinfo(path)
+    if info: return info[0]
+
+def getsourcefile(object):
+    &quot;&quot;&quot;Return the Python source file an object was defined in, if it exists.&quot;&quot;&quot;
+    filename = getfile(object)
+    if string.lower(filename[-4:]) in ('.pyc', '.pyo'):
+        filename = filename[:-4] + '.py'
+    for suffix, mode, kind in imp.get_suffixes():
+        if 'b' in mode and string.lower(filename[-len(suffix):]) == suffix:
+            # Looks like a binary file.  We want to only return a text file.
+            return None
+    if os.path.exists(filename):
+        return filename
+    # only return a non-existent filename if the module has a PEP 302 loader
+    if hasattr(getmodule(object, filename), '__loader__'):
+        return filename
+
+def getabsfile(object, _filename=None):
+    &quot;&quot;&quot;Return an absolute path to the source or compiled file for an object.
+
+    The idea is for each object to have a unique origin, so this routine
+    normalizes the result as much as possible.&quot;&quot;&quot;
+    if _filename is None:
+        _filename = getsourcefile(object) or getfile(object)
+    return os.path.normcase(os.path.abspath(_filename))
+
+modulesbyfile = {}
+_filesbymodname = {}
+
+def getmodule(object, _filename=None):
+    &quot;&quot;&quot;Return the module an object was defined in, or None if not found.&quot;&quot;&quot;
+    if ismodule(object):
+        return object
+    if hasattr(object, '__module__'):
+        return sys.modules.get(object.__module__)
+    # Try the filename to modulename cache
+    if _filename is not None and _filename in modulesbyfile:
+        return sys.modules.get(modulesbyfile[_filename])
+    # Try the cache again with the absolute file name
+    try:
+        file = getabsfile(object, _filename)
+    except TypeError:
+        return None
+    if file in modulesbyfile:
+        return sys.modules.get(modulesbyfile[file])
+    # Update the filename to module name cache and check yet again
+    # Copy sys.modules in order to cope with changes while iterating
+    for modname, module in sys.modules.items():
+        if ismodule(module) and hasattr(module, '__file__'):
+            f = module.__file__
+            if f == _filesbymodname.get(modname, None):
+                # Have already mapped this module, so skip it
+                continue
+            _filesbymodname[modname] = f
+            f = getabsfile(module)
+            # Always map to the name the module knows itself by
+            modulesbyfile[f] = modulesbyfile[
+                os.path.realpath(f)] = module.__name__
+    if file in modulesbyfile:
+        return sys.modules.get(modulesbyfile[file])
+    # Check the main module
+    main = sys.modules['__main__']
+    if not hasattr(object, '__name__'):
+        return None
+    if hasattr(main, object.__name__):
+        mainobject = getattr(main, object.__name__)
+        if mainobject is object:
+            return main
+    # Check builtins
+    builtin = sys.modules['__builtin__']
+    if hasattr(builtin, object.__name__):
+        builtinobject = getattr(builtin, object.__name__)
+        if builtinobject is object:
+            return builtin
+
+def findsource(object):
+    &quot;&quot;&quot;Return the entire source file and starting line number for an object.
+
+    The argument may be a module, class, method, function, traceback, frame,
+    or code object.  The source code is returned as a list of all the lines
+    in the file and the line number indexes a line in that list.  An IOError
+    is raised if the source code cannot be retrieved.&quot;&quot;&quot;
+    file = getsourcefile(object) or getfile(object)
+    module = getmodule(object, file)
+    if module:
+        lines = linecache.getlines(file, module.__dict__)
+    else:
+        lines = linecache.getlines(file)
+    if not lines:
+        raise IOError('could not get source code')
+
+    if ismodule(object):
+        return lines, 0
+
+    if isclass(object):
+        name = object.__name__
+        pat = re.compile(r'^(\s*)class\s*' + name + r'\b')
+        # make some effort to find the best matching class definition:
+        # use the one with the least indentation, which is the one
+        # that's most probably not inside a function definition.
+        candidates = []
+        for i in range(len(lines)):
+            match = pat.match(lines[i])
+            if match:
+                # if it's at toplevel, it's already the best one
+                if lines[i][0] == 'c':
+                    return lines, i
+                # else add whitespace to candidate list
+                candidates.append((match.group(1), i))
+        if candidates:
+            # this will sort by whitespace, and by line number,
+            # less whitespace first
+            candidates.sort()
+            return lines, candidates[0][1]
+        else:
+            raise IOError('could not find class definition')
+
+    if ismethod(object):
+        object = object.im_func
+    if isfunction(object):
+        object = object.func_code
+    if istraceback(object):
+        object = object.tb_frame
+    if isframe(object):
+        object = object.f_code
+    if iscode(object):
+        if not hasattr(object, 'co_firstlineno'):
+            raise IOError('could not find function definition')
+        lnum = object.co_firstlineno - 1
+        pat = re.compile(r'^(\s*def\s)|(.*(?&lt;!\w)lambda(:|\s))|^(\s*@)')
+        while lnum &gt; 0:
+            if pat.match(lines[lnum]): break
+            lnum = lnum - 1
+        return lines, lnum
+    raise IOError('could not find code object')
+
+def getcomments(object):
+    &quot;&quot;&quot;Get lines of comments immediately preceding an object's source code.
+
+    Returns None when source can't be found.
+    &quot;&quot;&quot;
+    try:
+        lines, lnum = findsource(object)
+    except (IOError, TypeError):
+        return None
+
+    if ismodule(object):
+        # Look for a comment block at the top of the file.
+        start = 0
+        if lines and lines[0][:2] == '#!': start = 1
+        while start &lt; len(lines) and string.strip(lines[start]) in ('', '#'):
+            start = start + 1
+        if start &lt; len(lines) and lines[start][:1] == '#':
+            comments = []
+            end = start
+            while end &lt; len(lines) and lines[end][:1] == '#':
+                comments.append(string.expandtabs(lines[end]))
+                end = end + 1
+            return string.join(comments, '')
+
+    # Look for a preceding block of comments at the same indentation.
+    elif lnum &gt; 0:
+        indent = indentsize(lines[lnum])
+        end = lnum - 1
+        if end &gt;= 0 and string.lstrip(lines[end])[:1] == '#' and \
+            indentsize(lines[end]) == indent:
+            comments = [string.lstrip(string.expandtabs(lines[end]))]
+            if end &gt; 0:
+                end = end - 1
+                comment = string.lstrip(string.expandtabs(lines[end]))
+                while comment[:1] == '#' and indentsize(lines[end]) == indent:
+                    comments[:0] = [comment]
+                    end = end - 1
+                    if end &lt; 0: break
+                    comment = string.lstrip(string.expandtabs(lines[end]))
+            while comments and string.strip(comments[0]) == '#':
+                comments[:1] = []
+            while comments and string.strip(comments[-1]) == '#':
+                comments[-1:] = []
+            return string.join(comments, '')
+
+class EndOfBlock(Exception): pass
+
+class BlockFinder:
+    &quot;&quot;&quot;Provide a tokeneater() method to detect the end of a code block.&quot;&quot;&quot;
+    def __init__(self):
+        self.indent = 0
+        self.islambda = False
+        self.started = False
+        self.passline = False
+        self.last = 1
+
+    def tokeneater(self, type, token, (srow, scol), (erow, ecol), line):
+        if not self.started:
+            # look for the first &quot;def&quot;, &quot;class&quot; or &quot;lambda&quot;
+            if token in (&quot;def&quot;, &quot;class&quot;, &quot;lambda&quot;):
+                if token == &quot;lambda&quot;:
+                    self.islambda = True
+                self.started = True
+            self.passline = True    # skip to the end of the line
+        elif type == tokenize.NEWLINE:
+            self.passline = False   # stop skipping when a NEWLINE is seen
+            self.last = srow
+            if self.islambda:       # lambdas always end at the first NEWLINE
+                raise EndOfBlock
+        elif self.passline:
+            pass
+        elif type == tokenize.INDENT:
+            self.indent = self.indent + 1
+            self.passline = True
+        elif type == tokenize.DEDENT:
+            self.indent = self.indent - 1
+            # the end of matching indent/dedent pairs end a block
+            # (note that this only works for &quot;def&quot;/&quot;class&quot; blocks,
+            #  not e.g. for &quot;if: else:&quot; or &quot;try: finally:&quot; blocks)
+            if self.indent &lt;= 0:
+                raise EndOfBlock
+        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):
+            # any other token on the same indentation level end the previous
+            # block as well, except the pseudo-tokens COMMENT and NL.
+            raise EndOfBlock
+
+def getblock(lines):
+    &quot;&quot;&quot;Extract the block of code at the top of the given list of lines.&quot;&quot;&quot;
+    blockfinder = BlockFinder()
+    try:
+        tokenize.tokenize(iter(lines).next, blockfinder.tokeneater)
+    except (EndOfBlock, IndentationError):
+        pass
+    return lines[:blockfinder.last]
+
+def getsourcelines(object):
+    &quot;&quot;&quot;Return a list of source lines and starting line number for an object.
+
+    The argument may be a module, class, method, function, traceback, frame,
+    or code object.  The source code is returned as a list of the lines
+    corresponding to the object and the line number indicates where in the
+    original source file the first line of code was found.  An IOError is
+    raised if the source code cannot be retrieved.&quot;&quot;&quot;
+    lines, lnum = findsource(object)
+
+    if ismodule(object): return lines, 0
+    else: return getblock(lines[lnum:]), lnum + 1
+
+def getsource(object):
+    &quot;&quot;&quot;Return the text of the source code for an object.
+
+    The argument may be a module, class, method, function, traceback, frame,
+    or code object.  The source code is returned as a single string.  An
+    IOError is raised if the source code cannot be retrieved.&quot;&quot;&quot;
+    lines, lnum = getsourcelines(object)
+    return string.join(lines, '')
+
+# --------------------------------------------------- class tree extraction
+def walktree(classes, children, parent):
+    &quot;&quot;&quot;Recursive helper function for getclasstree().&quot;&quot;&quot;
+    results = []
+    classes.sort(key=attrgetter('__module__', '__name__'))
+    for c in classes:
+        results.append((c, c.__bases__))
+        if c in children:
+            results.append(walktree(children[c], children, c))
+    return results
+
+def getclasstree(classes, unique=0):
+    &quot;&quot;&quot;Arrange the given list of classes into a hierarchy of nested lists.
+
+    Where a nested list appears, it contains classes derived from the class
+    whose entry immediately precedes the list.  Each entry is a 2-tuple
+    containing a class and a tuple of its base classes.  If the 'unique'
+    argument is true, exactly one entry appears in the returned structure
+    for each class in the given list.  Otherwise, classes using multiple
+    inheritance and their descendants will appear multiple times.&quot;&quot;&quot;
+    children = {}
+    roots = []
+    for c in classes:
+        if c.__bases__:
+            for parent in c.__bases__:
+                if not parent in children:
+                    children[parent] = []
+                children[parent].append(c)
+                if unique and parent in classes: break
+        elif c not in roots:
+            roots.append(c)
+    for parent in children:
+        if parent not in classes:
+            roots.append(parent)
+    return walktree(roots, children, None)
+
+# ------------------------------------------------ argument list extraction
+# These constants are from Python's compile.h.
+CO_OPTIMIZED, CO_NEWLOCALS, CO_VARARGS, CO_VARKEYWORDS = 1, 2, 4, 8
+
+def getargs(co):
+    &quot;&quot;&quot;Get information about the arguments accepted by a code object.
+
+    Three things are returned: (args, varargs, varkw), where 'args' is
+    a list of argument names (possibly containing nested lists), and
+    'varargs' and 'varkw' are the names of the * and ** arguments or None.&quot;&quot;&quot;
+
+    if not iscode(co):
+        raise TypeError('arg is not a code object')
+
+    nargs = co.co_argcount
+    names = co.co_varnames
+    args = list(names[:nargs])
+    step = 0
+
+    # The following acrobatics are for anonymous (tuple) arguments.
+    for i in range(nargs):
+        if args[i][:1] in ('', '.'):
+            stack, remain, count = [], [], []
+            while step &lt; len(co.co_code):
+                op = ord(co.co_code[step])
+                step = step + 1
+                if op &gt;= dis.HAVE_ARGUMENT:
+                    opname = dis.opname[op]
+                    value = ord(co.co_code[step]) + ord(co.co_code[step+1])*256
+                    step = step + 2
+                    if opname in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):
+                        remain.append(value)
+                        count.append(value)
+                    elif opname == 'STORE_FAST':
+                        stack.append(names[value])
+
+                        # Special case for sublists of length 1: def foo((bar))
+                        # doesn't generate the UNPACK_TUPLE bytecode, so if
+                        # `remain` is empty here, we have such a sublist.
+                        if not remain:
+                            stack[0] = [stack[0]]
+                            break
+                        else:
+                            remain[-1] = remain[-1] - 1
+                            while remain[-1] == 0:
+                                remain.pop()
+                                size = count.pop()
+                                stack[-size:] = [stack[-size:]]
+                                if not remain: break
+                                remain[-1] = remain[-1] - 1
+                            if not remain: break
+            args[i] = stack[0]
+
+    varargs = None
+    if co.co_flags &amp; CO_VARARGS:
+        varargs = co.co_varnames[nargs]
+        nargs = nargs + 1
+    varkw = None
+    if co.co_flags &amp; CO_VARKEYWORDS:
+        varkw = co.co_varnames[nargs]
+    return args, varargs, varkw
+
+def getargspec(func):
+    &quot;&quot;&quot;Get the names and default values of a function's arguments.
+
+    A tuple of four things is returned: (args, varargs, varkw, defaults).
+    'args' is a list of the argument names (it may contain nested lists).
+    'varargs' and 'varkw' are the names of the * and ** arguments or None.
+    'defaults' is an n-tuple of the default values of the last n arguments.
+    &quot;&quot;&quot;
+
+    if ismethod(func):
+        func = func.im_func
+    if not isfunction(func):
+        raise TypeError('arg is not a Python function')
+    args, varargs, varkw = getargs(func.func_code)
+    return args, varargs, varkw, func.func_defaults
+
+def getargvalues(frame):
+    &quot;&quot;&quot;Get information about arguments passed into a particular frame.
+
+    A tuple of four things is returned: (args, varargs, varkw, locals).
+    'args' is a list of the argument names (it may contain nested lists).
+    'varargs' and 'varkw' are the names of the * and ** arguments or None.
+    'locals' is the locals dictionary of the given frame.&quot;&quot;&quot;
+    args, varargs, varkw = getargs(frame.f_code)
+    return args, varargs, varkw, frame.f_locals
+
+def joinseq(seq):
+    if len(seq) == 1:
+        return '(' + seq[0] + ',)'
+    else:
+        return '(' + string.join(seq, ', ') + ')'
+
+def strseq(object, convert, join=joinseq):
+    &quot;&quot;&quot;Recursively walk a sequence, stringifying each element.&quot;&quot;&quot;
+    if type(object) in (list, tuple):
+        return join(map(lambda o, c=convert, j=join: strseq(o, c, j), object))
+    else:
+        return convert(object)
+
+def formatargspec(args, varargs=None, varkw=None, defaults=None,
+                  formatarg=str,
+                  formatvarargs=lambda name: '*' + name,
+                  formatvarkw=lambda name: '**' + name,
+                  formatvalue=lambda value: '=' + repr(value),
+                  join=joinseq):
+    &quot;&quot;&quot;Format an argument spec from the 4 values returned by getargspec.
+
+    The first four arguments are (args, varargs, varkw, defaults).  The
+    other four arguments are the corresponding optional formatting functions
+    that are called to turn names and values into strings.  The ninth
+    argument is an optional function to format the sequence of arguments.&quot;&quot;&quot;
+    specs = []
+    if defaults:
+        firstdefault = len(args) - len(defaults)
+    for i in range(len(args)):
+        spec = strseq(args[i], formatarg, join)
+        if defaults and i &gt;= firstdefault:
+            spec = spec + formatvalue(defaults[i - firstdefault])
+        specs.append(spec)
+    if varargs is not None:
+        specs.append(formatvarargs(varargs))
+    if varkw is not None:
+        specs.append(formatvarkw(varkw))
+    return '(' + string.join(specs, ', ') + ')'
+
+def formatargvalues(args, varargs, varkw, locals,
+                    formatarg=str,
+                    formatvarargs=lambda name: '*' + name,
+                    formatvarkw=lambda name: '**' + name,
+                    formatvalue=lambda value: '=' + repr(value),
+                    join=joinseq):
+    &quot;&quot;&quot;Format an argument spec from the 4 values returned by getargvalues.
+
+    The first four arguments are (args, varargs, varkw, locals).  The
+    next four arguments are the corresponding optional formatting functions
+    that are called to turn names and values into strings.  The ninth
+    argument is an optional function to format the sequence of arguments.&quot;&quot;&quot;
+    def convert(name, locals=locals,
+                formatarg=formatarg, formatvalue=formatvalue):
+        return formatarg(name) + formatvalue(locals[name])
+    specs = []
+    for i in range(len(args)):
+        specs.append(strseq(args[i], convert, join))
+    if varargs:
+        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
+    if varkw:
+        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
+    return '(' + string.join(specs, ', ') + ')'
+
+# -------------------------------------------------- stack frame extraction
+def getframeinfo(frame, context=1):
+    &quot;&quot;&quot;Get information about a frame or traceback object.
+
+    A tuple of five things is returned: the filename, the line number of
+    the current line, the function name, a list of lines of context from
+    the source code, and the index of the current line within that list.
+    The optional second argument specifies the number of lines of context
+    to return, which are centered around the current line.&quot;&quot;&quot;
+    if istraceback(frame):
+        lineno = frame.tb_lineno
+        frame = frame.tb_frame
+    else:
+        lineno = frame.f_lineno
+    if not isframe(frame):
+        raise TypeError('arg is not a frame or traceback object')
+
+    filename = getsourcefile(frame) or getfile(frame)
+    if context &gt; 0:
+        start = lineno - 1 - context//2
+        try:
+            lines, lnum = findsource(frame)
+        except IOError:
+            lines = index = None
+        else:
+            start = max(start, 1)
+            start = max(0, min(start, len(lines) - context))
+            lines = lines[start:start+context]
+            index = lineno - 1 - start
+    else:
+        lines = index = None
+
+    return (filename, lineno, frame.f_code.co_name, lines, index)
+
+def getlineno(frame):
+    &quot;&quot;&quot;Get the line number from a frame object, allowing for optimization.&quot;&quot;&quot;
+    # FrameType.f_lineno is now a descriptor that grovels co_lnotab
+    return frame.f_lineno
+
+def getouterframes(frame, context=1):
+    &quot;&quot;&quot;Get a list of records for a frame and all higher (calling) frames.
+
+    Each record contains a frame object, filename, line number, function
+    name, a list of lines of context, and index within the context.&quot;&quot;&quot;
+    framelist = []
+    while frame:
+        framelist.append((frame,) + getframeinfo(frame, context))
+        frame = frame.f_back
+    return framelist
+
+def getinnerframes(tb, context=1):
+    &quot;&quot;&quot;Get a list of records for a traceback's frame and all lower frames.
+
+    Each record contains a frame object, filename, line number, function
+    name, a list of lines of context, and index within the context.&quot;&quot;&quot;
+    framelist = []
+    while tb:
+        framelist.append((tb.tb_frame,) + getframeinfo(tb, context))
+        tb = tb.tb_next
+    return framelist
+
+currentframe = sys._getframe
+
+def stack(context=1):
+    &quot;&quot;&quot;Return a list of records for the stack above the caller's frame.&quot;&quot;&quot;
+    return getouterframes(sys._getframe(1), context)
+
+def trace(context=1):
+    &quot;&quot;&quot;Return a list of records for the stack below the current exception.&quot;&quot;&quot;
+    return getinnerframes(sys.exc_info()[2], context)

Added: trunk/Lobby/TASClient/Python/engine/linecache.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/linecache.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/linecache.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,136 @@
+&quot;&quot;&quot;Cache lines from files.
+
+This is intended to read lines from modules imported -- hence if a filename
+is not found, it will look down the module search path for a file by
+that name.
+&quot;&quot;&quot;
+
+import sys
+import os
+
+__all__ = [&quot;getline&quot;, &quot;clearcache&quot;, &quot;checkcache&quot;]
+
+def getline(filename, lineno, module_globals=None):
+    lines = getlines(filename, module_globals)
+    if 1 &lt;= lineno &lt;= len(lines):
+        return lines[lineno-1]
+    else:
+        return ''
+
+
+# The cache
+
+cache = {} # The cache
+
+
+def clearcache():
+    &quot;&quot;&quot;Clear the cache entirely.&quot;&quot;&quot;
+
+    global cache
+    cache = {}
+
+
+def getlines(filename, module_globals=None):
+    &quot;&quot;&quot;Get the lines for a file from the cache.
+    Update the cache if it doesn't contain an entry for this file already.&quot;&quot;&quot;
+
+    if filename in cache:
+        return cache[filename][2]
+    else:
+        return updatecache(filename, module_globals)
+
+
+def checkcache(filename=None):
+    &quot;&quot;&quot;Discard cache entries that are out of date.
+    (This is not checked upon each call!)&quot;&quot;&quot;
+
+    if filename is None:
+        filenames = cache.keys()
+    else:
+        if filename in cache:
+            filenames = [filename]
+        else:
+            return
+
+    for filename in filenames:
+        size, mtime, lines, fullname = cache[filename]
+        if mtime is None:
+            continue   # no-op for files loaded via a __loader__
+        try:
+            stat = os.stat(fullname)
+        except os.error:
+            del cache[filename]
+            continue
+        if size != stat.st_size or mtime != stat.st_mtime:
+            del cache[filename]
+
+
+def updatecache(filename, module_globals=None):
+    &quot;&quot;&quot;Update a cache entry and return its list of lines.
+    If something's wrong, print a message, discard the cache entry,
+    and return an empty list.&quot;&quot;&quot;
+
+    if filename in cache:
+        del cache[filename]
+    if not filename or filename[0] + filename[-1] == '&lt;&gt;':
+        return []
+
+    fullname = filename
+    try:
+        stat = os.stat(fullname)
+    except os.error, msg:
+        basename = os.path.split(filename)[1]
+
+        # Try for a __loader__, if available
+        if module_globals and '__loader__' in module_globals:
+            name = module_globals.get('__name__')
+            loader = module_globals['__loader__']
+            get_source = getattr(loader, 'get_source', None)
+
+            if name and get_source:
+                if basename.startswith(name.split('.')[-1]+'.'):
+                    try:
+                        data = get_source(name)
+                    except (ImportError, IOError):
+                        pass
+                    else:
+                        if data is None:
+                            # No luck, the PEP302 loader cannot find the source
+                            # for this module.
+                            return []
+                        cache[filename] = (
+                            len(data), None,
+                            [line+'\n' for line in data.splitlines()], fullname
+                        )
+                        return cache[filename][2]
+
+        # Try looking through the module search path.
+
+        for dirname in sys.path:
+            # When using imputil, sys.path may contain things other than
+            # strings; ignore them when it happens.
+            try:
+                fullname = os.path.join(dirname, basename)
+            except (TypeError, AttributeError):
+                # Not sufficiently string-like to do anything useful with.
+                pass
+            else:
+                try:
+                    stat = os.stat(fullname)
+                    break
+                except os.error:
+                    pass
+        else:
+            # No luck
+##          print '*** Cannot stat', filename, ':', msg
+            return []
+    try:
+        fp = open(fullname, 'rU')
+        lines = fp.readlines()
+        fp.close()
+    except IOError, msg:
+##      print '*** Cannot open', fullname, ':', msg
+        return []
+    size, mtime = stat.st_size, stat.st_mtime
+    cache[filename] = size, mtime, lines, fullname
+    return lines

Added: trunk/Lobby/TASClient/Python/engine/macpath.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/macpath.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/macpath.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,275 @@
+&quot;&quot;&quot;Pathname and path-related operations for the Macintosh.&quot;&quot;&quot;
+
+import os
+from stat import *
+
+__all__ = [&quot;normcase&quot;,&quot;isabs&quot;,&quot;join&quot;,&quot;splitdrive&quot;,&quot;split&quot;,&quot;splitext&quot;,
+           &quot;basename&quot;,&quot;dirname&quot;,&quot;commonprefix&quot;,&quot;getsize&quot;,&quot;getmtime&quot;,
+           &quot;getatime&quot;,&quot;getctime&quot;, &quot;islink&quot;,&quot;exists&quot;,&quot;lexists&quot;,&quot;isdir&quot;,&quot;isfile&quot;,
+           &quot;walk&quot;,&quot;expanduser&quot;,&quot;expandvars&quot;,&quot;normpath&quot;,&quot;abspath&quot;,
+           &quot;curdir&quot;,&quot;pardir&quot;,&quot;sep&quot;,&quot;pathsep&quot;,&quot;defpath&quot;,&quot;altsep&quot;,&quot;extsep&quot;,
+           &quot;devnull&quot;,&quot;realpath&quot;,&quot;supports_unicode_filenames&quot;]
+
+# strings representing various path-related bits and pieces
+curdir = ':'
+pardir = '::'
+extsep = '.'
+sep = ':'
+pathsep = '\n'
+defpath = ':'
+altsep = None
+devnull = 'Dev:Null'
+
+# Normalize the case of a pathname.  Dummy in Posix, but &lt;s&gt;.lower() here.
+
+def normcase(path):
+    return path.lower()
+
+
+def isabs(s):
+    &quot;&quot;&quot;Return true if a path is absolute.
+    On the Mac, relative paths begin with a colon,
+    but as a special case, paths with no colons at all are also relative.
+    Anything else is absolute (the string up to the first colon is the
+    volume name).&quot;&quot;&quot;
+
+    return ':' in s and s[0] != ':'
+
+
+def join(s, *p):
+    path = s
+    for t in p:
+        if (not s) or isabs(t):
+            path = t
+            continue
+        if t[:1] == ':':
+            t = t[1:]
+        if ':' not in path:
+            path = ':' + path
+        if path[-1:] != ':':
+            path = path + ':'
+        path = path + t
+    return path
+
+
+def split(s):
+    &quot;&quot;&quot;Split a pathname into two parts: the directory leading up to the final
+    bit, and the basename (the filename, without colons, in that directory).
+    The result (s, t) is such that join(s, t) yields the original argument.&quot;&quot;&quot;
+
+    if ':' not in s: return '', s
+    colon = 0
+    for i in range(len(s)):
+        if s[i] == ':': colon = i + 1
+    path, file = s[:colon-1], s[colon:]
+    if path and not ':' in path:
+        path = path + ':'
+    return path, file
+
+
+def splitext(p):
+    &quot;&quot;&quot;Split a path into root and extension.
+    The extension is everything starting at the last dot in the last
+    pathname component; the root is everything before that.
+    It is always true that root + ext == p.&quot;&quot;&quot;
+
+    i = p.rfind('.')
+    if i&lt;=p.rfind(':'):
+        return p, ''
+    else:
+        return p[:i], p[i:]
+
+
+def splitdrive(p):
+    &quot;&quot;&quot;Split a pathname into a drive specification and the rest of the
+    path.  Useful on DOS/Windows/NT; on the Mac, the drive is always
+    empty (don't use the volume name -- it doesn't have the same
+    syntactic and semantic oddities as DOS drive letters, such as there
+    being a separate current directory per drive).&quot;&quot;&quot;
+
+    return '', p
+
+
+# Short interfaces to split()
+
+def dirname(s): return split(s)[0]
+def basename(s): return split(s)[1]
+
+def ismount(s):
+    if not isabs(s):
+        return False
+    components = split(s)
+    return len(components) == 2 and components[1] == ''
+
+def isdir(s):
+    &quot;&quot;&quot;Return true if the pathname refers to an existing directory.&quot;&quot;&quot;
+
+    try:
+        st = os.stat(s)
+    except os.error:
+        return 0
+    return S_ISDIR(st.st_mode)
+
+
+# Get size, mtime, atime of files.
+
+def getsize(filename):
+    &quot;&quot;&quot;Return the size of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_size
+
+def getmtime(filename):
+    &quot;&quot;&quot;Return the last modification time of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_mtime
+
+def getatime(filename):
+    &quot;&quot;&quot;Return the last access time of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_atime
+
+
+def islink(s):
+    &quot;&quot;&quot;Return true if the pathname refers to a symbolic link.&quot;&quot;&quot;
+
+    try:
+        import Carbon.File
+        return Carbon.File.ResolveAliasFile(s, 0)[2]
+    except:
+        return False
+
+
+def isfile(s):
+    &quot;&quot;&quot;Return true if the pathname refers to an existing regular file.&quot;&quot;&quot;
+
+    try:
+        st = os.stat(s)
+    except os.error:
+        return False
+    return S_ISREG(st.st_mode)
+
+def getctime(filename):
+    &quot;&quot;&quot;Return the creation time of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_ctime
+
+def exists(s):
+    &quot;&quot;&quot;Test whether a path exists.  Returns False for broken symbolic links&quot;&quot;&quot;
+
+    try:
+        st = os.stat(s)
+    except os.error:
+        return False
+    return True
+
+# Is `stat`/`lstat` a meaningful difference on the Mac?  This is safe in any
+# case.
+
+def lexists(path):
+    &quot;&quot;&quot;Test whether a path exists.  Returns True for broken symbolic links&quot;&quot;&quot;
+
+    try:
+        st = os.lstat(path)
+    except os.error:
+        return False
+    return True
+
+# Return the longest prefix of all list elements.
+
+def commonprefix(m):
+    &quot;Given a list of pathnames, returns the longest common leading component&quot;
+    if not m: return ''
+    s1 = min(m)
+    s2 = max(m)
+    n = min(len(s1), len(s2))
+    for i in xrange(n):
+        if s1[i] != s2[i]:
+            return s1[:i]
+    return s1[:n]
+
+
+def expandvars(path):
+    &quot;&quot;&quot;Dummy to retain interface-compatibility with other operating systems.&quot;&quot;&quot;
+    return path
+
+
+def expanduser(path):
+    &quot;&quot;&quot;Dummy to retain interface-compatibility with other operating systems.&quot;&quot;&quot;
+    return path
+
+class norm_error(Exception):
+    &quot;&quot;&quot;Path cannot be normalized&quot;&quot;&quot;
+
+def normpath(s):
+    &quot;&quot;&quot;Normalize a pathname.  Will return the same result for
+    equivalent paths.&quot;&quot;&quot;
+
+    if &quot;:&quot; not in s:
+        return &quot;:&quot;+s
+
+    comps = s.split(&quot;:&quot;)
+    i = 1
+    while i &lt; len(comps)-1:
+        if comps[i] == &quot;&quot; and comps[i-1] != &quot;&quot;:
+            if i &gt; 1:
+                del comps[i-1:i+1]
+                i = i - 1
+            else:
+                # best way to handle this is to raise an exception
+                raise norm_error, 'Cannot use :: immediately after volume name'
+        else:
+            i = i + 1
+
+    s = &quot;:&quot;.join(comps)
+
+    # remove trailing &quot;:&quot; except for &quot;:&quot; and &quot;Volume:&quot;
+    if s[-1] == &quot;:&quot; and len(comps) &gt; 2 and s != &quot;:&quot;*len(s):
+        s = s[:-1]
+    return s
+
+
+def walk(top, func, arg):
+    &quot;&quot;&quot;Directory tree walk with callback function.
+
+    For each directory in the directory tree rooted at top (including top
+    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
+    dirname is the name of the directory, and fnames a list of the names of
+    the files and subdirectories in dirname (excluding '.' and '..').  func
+    may modify the fnames list in-place (e.g. via del or slice assignment),
+    and walk will only recurse into the subdirectories whose names remain in
+    fnames; this can be used to implement a filter, or to impose a specific
+    order of visiting.  No semantics are defined for, or required of, arg,
+    beyond that arg is always passed to func.  It can be used, e.g., to pass
+    a filename pattern, or a mutable object designed to accumulate
+    statistics.  Passing None for arg is common.&quot;&quot;&quot;
+
+    try:
+        names = os.listdir(top)
+    except os.error:
+        return
+    func(arg, top, names)
+    for name in names:
+        name = join(top, name)
+        if isdir(name) and not islink(name):
+            walk(name, func, arg)
+
+
+def abspath(path):
+    &quot;&quot;&quot;Return an absolute path.&quot;&quot;&quot;
+    if not isabs(path):
+        path = join(os.getcwd(), path)
+    return normpath(path)
+
+# realpath is a no-op on systems without islink support
+def realpath(path):
+    path = abspath(path)
+    try:
+        import Carbon.File
+    except ImportError:
+        return path
+    if not path:
+        return path
+    components = path.split(':')
+    path = components[0] + ':'
+    for c in components[1:]:
+        path = join(path, c)
+        path = Carbon.File.FSResolveAliasFile(path, 1)[0].as_pathname()
+    return path
+
+supports_unicode_filenames = False

Added: trunk/Lobby/TASClient/Python/engine/ntpath.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/ntpath.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/ntpath.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,511 @@
+# Module 'ntpath' -- common operations on WinNT/Win95 pathnames
+&quot;&quot;&quot;Common pathname manipulations, WindowsNT/95 version.
+
+Instead of importing this module directly, import os and refer to this
+module as os.path.
+&quot;&quot;&quot;
+
+import os
+import stat
+import sys
+
+__all__ = [&quot;normcase&quot;,&quot;isabs&quot;,&quot;join&quot;,&quot;splitdrive&quot;,&quot;split&quot;,&quot;splitext&quot;,
+           &quot;basename&quot;,&quot;dirname&quot;,&quot;commonprefix&quot;,&quot;getsize&quot;,&quot;getmtime&quot;,
+           &quot;getatime&quot;,&quot;getctime&quot;, &quot;islink&quot;,&quot;exists&quot;,&quot;lexists&quot;,&quot;isdir&quot;,&quot;isfile&quot;,
+           &quot;ismount&quot;,&quot;walk&quot;,&quot;expanduser&quot;,&quot;expandvars&quot;,&quot;normpath&quot;,&quot;abspath&quot;,
+           &quot;splitunc&quot;,&quot;curdir&quot;,&quot;pardir&quot;,&quot;sep&quot;,&quot;pathsep&quot;,&quot;defpath&quot;,&quot;altsep&quot;,
+           &quot;extsep&quot;,&quot;devnull&quot;,&quot;realpath&quot;,&quot;supports_unicode_filenames&quot;]
+
+# strings representing various path-related bits and pieces
+curdir = '.'
+pardir = '..'
+extsep = '.'
+sep = '\\'
+pathsep = ';'
+altsep = '/'
+defpath = '.;C:\\bin'
+if 'ce' in sys.builtin_module_names:
+    defpath = '\\Windows'
+elif 'os2' in sys.builtin_module_names:
+    # OS/2 w/ VACPP
+    altsep = '/'
+devnull = 'nul'
+
+# Normalize the case of a pathname and map slashes to backslashes.
+# Other normalizations (such as optimizing '../' away) are not done
+# (this is done by normpath).
+
+def normcase(s):
+    &quot;&quot;&quot;Normalize case of pathname.
+
+    Makes all characters lowercase and all slashes into backslashes.&quot;&quot;&quot;
+    return s.replace(&quot;/&quot;, &quot;\\&quot;).lower()
+
+
+# Return whether a path is absolute.
+# Trivial in Posix, harder on the Mac or MS-DOS.
+# For DOS it is absolute if it starts with a slash or backslash (current
+# volume), or if a pathname after the volume letter and colon / UNC resource
+# starts with a slash or backslash.
+
+def isabs(s):
+    &quot;&quot;&quot;Test whether a path is absolute&quot;&quot;&quot;
+    s = splitdrive(s)[1]
+    return s != '' and s[:1] in '/\\'
+
+
+# Join two (or more) paths.
+
+def join(a, *p):
+    &quot;&quot;&quot;Join two or more pathname components, inserting &quot;\\&quot; as needed&quot;&quot;&quot;
+    path = a
+    for b in p:
+        b_wins = 0  # set to 1 iff b makes path irrelevant
+        if path == &quot;&quot;:
+            b_wins = 1
+
+        elif isabs(b):
+            # This probably wipes out path so far.  However, it's more
+            # complicated if path begins with a drive letter:
+            #     1. join('c:', '/a') == 'c:/a'
+            #     2. join('c:/', '/a') == 'c:/a'
+            # But
+            #     3. join('c:/a', '/b') == '/b'
+            #     4. join('c:', 'd:/') = 'd:/'
+            #     5. join('c:/', 'd:/') = 'd:/'
+            if path[1:2] != &quot;:&quot; or b[1:2] == &quot;:&quot;:
+                # Path doesn't start with a drive letter, or cases 4 and 5.
+                b_wins = 1
+
+            # Else path has a drive letter, and b doesn't but is absolute.
+            elif len(path) &gt; 3 or (len(path) == 3 and
+                                   path[-1] not in &quot;/\\&quot;):
+                # case 3
+                b_wins = 1
+
+        if b_wins:
+            path = b
+        else:
+            # Join, and ensure there's a separator.
+            assert len(path) &gt; 0
+            if path[-1] in &quot;/\\&quot;:
+                if b and b[0] in &quot;/\\&quot;:
+                    path += b[1:]
+                else:
+                    path += b
+            elif path[-1] == &quot;:&quot;:
+                path += b
+            elif b:
+                if b[0] in &quot;/\\&quot;:
+                    path += b
+                else:
+                    path += &quot;\\&quot; + b
+            else:
+                # path is not empty and does not end with a backslash,
+                # but b is empty; since, e.g., split('a/') produces
+                # ('a', ''), it's best if join() adds a backslash in
+                # this case.
+                path += '\\'
+
+    return path
+
+
+# Split a path in a drive specification (a drive letter followed by a
+# colon) and the path specification.
+# It is always true that drivespec + pathspec == p
+def splitdrive(p):
+    &quot;&quot;&quot;Split a pathname into drive and path specifiers. Returns a 2-tuple
+&quot;(drive,path)&quot;;  either part may be empty&quot;&quot;&quot;
+    if p[1:2] == ':':
+        return p[0:2], p[2:]
+    return '', p
+
+
+# Parse UNC paths
+def splitunc(p):
+    &quot;&quot;&quot;Split a pathname into UNC mount point and relative path specifiers.
+
+    Return a 2-tuple (unc, rest); either part may be empty.
+    If unc is not empty, it has the form '//host/mount' (or similar
+    using backslashes).  unc+rest is always the input path.
+    Paths containing drive letters never have an UNC part.
+    &quot;&quot;&quot;
+    if p[1:2] == ':':
+        return '', p # Drive letter present
+    firstTwo = p[0:2]
+    if firstTwo == '//' or firstTwo == '\\\\':
+        # is a UNC path:
+        # vvvvvvvvvvvvvvvvvvvv equivalent to drive letter
+        # \\machine\mountpoint\directories...
+        #           directory ^^^^^^^^^^^^^^^
+        normp = normcase(p)
+        index = normp.find('\\', 2)
+        if index == -1:
+            ##raise RuntimeError, 'illegal UNC path: &quot;' + p + '&quot;'
+            return (&quot;&quot;, p)
+        index = normp.find('\\', index + 1)
+        if index == -1:
+            index = len(p)
+        return p[:index], p[index:]
+    return '', p
+
+
+# Split a path in head (everything up to the last '/') and tail (the
+# rest).  After the trailing '/' is stripped, the invariant
+# join(head, tail) == p holds.
+# The resulting head won't end in '/' unless it is the root.
+
+def split(p):
+    &quot;&quot;&quot;Split a pathname.
+
+    Return tuple (head, tail) where tail is everything after the final slash.
+    Either part may be empty.&quot;&quot;&quot;
+
+    d, p = splitdrive(p)
+    # set i to index beyond p's last slash
+    i = len(p)
+    while i and p[i-1] not in '/\\':
+        i = i - 1
+    head, tail = p[:i], p[i:]  # now tail has no slashes
+    # remove trailing slashes from head, unless it's all slashes
+    head2 = head
+    while head2 and head2[-1] in '/\\':
+        head2 = head2[:-1]
+    head = head2 or head
+    return d + head, tail
+
+
+# Split a path in root and extension.
+# The extension is everything starting at the last dot in the last
+# pathname component; the root is everything before that.
+# It is always true that root + ext == p.
+
+def splitext(p):
+    &quot;&quot;&quot;Split the extension from a pathname.
+
+    Extension is everything from the last dot to the end.
+    Return (root, ext), either part may be empty.&quot;&quot;&quot;
+
+    i = p.rfind('.')
+    if i&lt;=max(p.rfind('/'), p.rfind('\\')):
+        return p, ''
+    else:
+        return p[:i], p[i:]
+
+
+# Return the tail (basename) part of a path.
+
+def basename(p):
+    &quot;&quot;&quot;Returns the final component of a pathname&quot;&quot;&quot;
+    return split(p)[1]
+
+
+# Return the head (dirname) part of a path.
+
+def dirname(p):
+    &quot;&quot;&quot;Returns the directory component of a pathname&quot;&quot;&quot;
+    return split(p)[0]
+
+
+# Return the longest prefix of all list elements.
+
+def commonprefix(m):
+    &quot;Given a list of pathnames, returns the longest common leading component&quot;
+    if not m: return ''
+    s1 = min(m)
+    s2 = max(m)
+    n = min(len(s1), len(s2))
+    for i in xrange(n):
+        if s1[i] != s2[i]:
+            return s1[:i]
+    return s1[:n]
+
+
+# Get size, mtime, atime of files.
+
+def getsize(filename):
+    &quot;&quot;&quot;Return the size of a file, reported by os.stat()&quot;&quot;&quot;
+    return os.stat(filename).st_size
+
+def getmtime(filename):
+    &quot;&quot;&quot;Return the last modification time of a file, reported by os.stat()&quot;&quot;&quot;
+    return os.stat(filename).st_mtime
+
+def getatime(filename):
+    &quot;&quot;&quot;Return the last access time of a file, reported by os.stat()&quot;&quot;&quot;
+    return os.stat(filename).st_atime
+
+def getctime(filename):
+    &quot;&quot;&quot;Return the creation time of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_ctime
+
+# Is a path a symbolic link?
+# This will always return false on systems where posix.lstat doesn't exist.
+
+def islink(path):
+    &quot;&quot;&quot;Test for symbolic link.  On WindowsNT/95 always returns false&quot;&quot;&quot;
+    return False
+
+
+# Does a path exist?
+
+def exists(path):
+    &quot;&quot;&quot;Test whether a path exists&quot;&quot;&quot;
+    try:
+        st = os.stat(path)
+    except os.error:
+        return False
+    return True
+
+lexists = exists
+
+
+# Is a path a dos directory?
+# This follows symbolic links, so both islink() and isdir() can be true
+# for the same path.
+
+def isdir(path):
+    &quot;&quot;&quot;Test whether a path is a directory&quot;&quot;&quot;
+    try:
+        st = os.stat(path)
+    except os.error:
+        return False
+    return stat.S_ISDIR(st.st_mode)
+
+
+# Is a path a regular file?
+# This follows symbolic links, so both islink() and isdir() can be true
+# for the same path.
+
+def isfile(path):
+    &quot;&quot;&quot;Test whether a path is a regular file&quot;&quot;&quot;
+    try:
+        st = os.stat(path)
+    except os.error:
+        return False
+    return stat.S_ISREG(st.st_mode)
+
+
+# Is a path a mount point?  Either a root (with or without drive letter)
+# or an UNC path with at most a / or \ after the mount point.
+
+def ismount(path):
+    &quot;&quot;&quot;Test whether a path is a mount point (defined as root of drive)&quot;&quot;&quot;
+    unc, rest = splitunc(path)
+    if unc:
+        return rest in (&quot;&quot;, &quot;/&quot;, &quot;\\&quot;)
+    p = splitdrive(path)[1]
+    return len(p) == 1 and p[0] in '/\\'
+
+
+# Directory tree walk.
+# For each directory under top (including top itself, but excluding
+# '.' and '..'), func(arg, dirname, filenames) is called, where
+# dirname is the name of the directory and filenames is the list
+# of files (and subdirectories etc.) in the directory.
+# The func may modify the filenames list, to implement a filter,
+# or to impose a different order of visiting.
+
+def walk(top, func, arg):
+    &quot;&quot;&quot;Directory tree walk with callback function.
+
+    For each directory in the directory tree rooted at top (including top
+    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
+    dirname is the name of the directory, and fnames a list of the names of
+    the files and subdirectories in dirname (excluding '.' and '..').  func
+    may modify the fnames list in-place (e.g. via del or slice assignment),
+    and walk will only recurse into the subdirectories whose names remain in
+    fnames; this can be used to implement a filter, or to impose a specific
+    order of visiting.  No semantics are defined for, or required of, arg,
+    beyond that arg is always passed to func.  It can be used, e.g., to pass
+    a filename pattern, or a mutable object designed to accumulate
+    statistics.  Passing None for arg is common.&quot;&quot;&quot;
+
+    try:
+        names = os.listdir(top)
+    except os.error:
+        return
+    func(arg, top, names)
+    exceptions = ('.', '..')
+    for name in names:
+        if name not in exceptions:
+            name = join(top, name)
+            if isdir(name):
+                walk(name, func, arg)
+
+
+# Expand paths beginning with '~' or '~user'.
+# '~' means $HOME; '~user' means that user's home directory.
+# If the path doesn't begin with '~', or if the user or $HOME is unknown,
+# the path is returned unchanged (leaving error reporting to whatever
+# function is called with the expanded path as argument).
+# See also module 'glob' for expansion of *, ? and [...] in pathnames.
+# (A function should also be defined to do full *sh-style environment
+# variable expansion.)
+
+def expanduser(path):
+    &quot;&quot;&quot;Expand ~ and ~user constructs.
+
+    If user or $HOME is unknown, do nothing.&quot;&quot;&quot;
+    if path[:1] != '~':
+        return path
+    i, n = 1, len(path)
+    while i &lt; n and path[i] not in '/\\':
+        i = i + 1
+    if i == 1:
+        if 'HOME' in os.environ:
+            userhome = os.environ['HOME']
+        elif not 'HOMEPATH' in os.environ:
+            return path
+        else:
+            try:
+                drive = os.environ['HOMEDRIVE']
+            except KeyError:
+                drive = ''
+            userhome = join(drive, os.environ['HOMEPATH'])
+    else:
+        return path
+    return userhome + path[i:]
+
+
+# Expand paths containing shell variable substitutions.
+# The following rules apply:
+#       - no expansion within single quotes
+#       - no escape character, except for '$$' which is translated into '$'
+#       - ${varname} is accepted.
+#       - varnames can be made out of letters, digits and the character '_'
+# XXX With COMMAND.COM you can use any characters in a variable name,
+# XXX except '^|&lt;&gt;='.
+
+def expandvars(path):
+    &quot;&quot;&quot;Expand shell variables of form $var and ${var}.
+
+    Unknown variables are left unchanged.&quot;&quot;&quot;
+    if '$' not in path:
+        return path
+    import string
+    varchars = string.ascii_letters + string.digits + '_-'
+    res = ''
+    index = 0
+    pathlen = len(path)
+    while index &lt; pathlen:
+        c = path[index]
+        if c == '\'':   # no expansion within single quotes
+            path = path[index + 1:]
+            pathlen = len(path)
+            try:
+                index = path.index('\'')
+                res = res + '\'' + path[:index + 1]
+            except ValueError:
+                res = res + path
+                index = pathlen - 1
+        elif c == '$':  # variable or '$$'
+            if path[index + 1:index + 2] == '$':
+                res = res + c
+                index = index + 1
+            elif path[index + 1:index + 2] == '{':
+                path = path[index+2:]
+                pathlen = len(path)
+                try:
+                    index = path.index('}')
+                    var = path[:index]
+                    if var in os.environ:
+                        res = res + os.environ[var]
+                except ValueError:
+                    res = res + path
+                    index = pathlen - 1
+            else:
+                var = ''
+                index = index + 1
+                c = path[index:index + 1]
+                while c != '' and c in varchars:
+                    var = var + c
+                    index = index + 1
+                    c = path[index:index + 1]
+                if var in os.environ:
+                    res = res + os.environ[var]
+                if c != '':
+                    res = res + c
+        else:
+            res = res + c
+        index = index + 1
+    return res
+
+
+# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A\B.
+# Previously, this function also truncated pathnames to 8+3 format,
+# but as this module is called &quot;ntpath&quot;, that's obviously wrong!
+
+def normpath(path):
+    &quot;&quot;&quot;Normalize path, eliminating double slashes, etc.&quot;&quot;&quot;
+    path = path.replace(&quot;/&quot;, &quot;\\&quot;)
+    prefix, path = splitdrive(path)
+    # We need to be careful here. If the prefix is empty, and the path starts
+    # with a backslash, it could either be an absolute path on the current
+    # drive (\dir1\dir2\file) or a UNC filename (\\server\mount\dir1\file). It
+    # is therefore imperative NOT to collapse multiple backslashes blindly in
+    # that case.
+    # The code below preserves multiple backslashes when there is no drive
+    # letter. This means that the invalid filename \\\a\b is preserved
+    # unchanged, where a\\\b is normalised to a\b. It's not clear that there
+    # is any better behaviour for such edge cases.
+    if prefix == '':
+        # No drive letter - preserve initial backslashes
+        while path[:1] == &quot;\\&quot;:
+            prefix = prefix + &quot;\\&quot;
+            path = path[1:]
+    else:
+        # We have a drive letter - collapse initial backslashes
+        if path.startswith(&quot;\\&quot;):
+            prefix = prefix + &quot;\\&quot;
+            path = path.lstrip(&quot;\\&quot;)
+    comps = path.split(&quot;\\&quot;)
+    i = 0
+    while i &lt; len(comps):
+        if comps[i] in ('.', ''):
+            del comps[i]
+        elif comps[i] == '..':
+            if i &gt; 0 and comps[i-1] != '..':
+                del comps[i-1:i+1]
+                i -= 1
+            elif i == 0 and prefix.endswith(&quot;\\&quot;):
+                del comps[i]
+            else:
+                i += 1
+        else:
+            i += 1
+    # If the path is now empty, substitute '.'
+    if not prefix and not comps:
+        comps.append('.')
+    return prefix + &quot;\\&quot;.join(comps)
+
+
+# Return an absolute path.
+try:
+    from nt import _getfullpathname
+
+except ImportError: # not running on Windows - mock up something sensible
+    def abspath(path):
+        &quot;&quot;&quot;Return the absolute version of a path.&quot;&quot;&quot;
+        if not isabs(path):
+            path = join(os.getcwd(), path)
+        return normpath(path)
+
+else:  # use native Windows method on Windows
+    def abspath(path):
+        &quot;&quot;&quot;Return the absolute version of a path.&quot;&quot;&quot;
+
+        if path: # Empty path must return current working directory.
+            try:
+                path = _getfullpathname(path)
+            except WindowsError:
+                pass # Bad path - return unchanged.
+        else:
+            path = os.getcwd()
+        return normpath(path)
+
+# realpath is a no-op on systems without islink support
+realpath = abspath
+# Win9x family and earlier have no Unicode filename support.
+supports_unicode_filenames = (hasattr(sys, &quot;getwindowsversion&quot;) and
+                              sys.getwindowsversion()[3] &gt;= 2)

Added: trunk/Lobby/TASClient/Python/engine/opcode.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/opcode.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/opcode.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,185 @@
+
+&quot;&quot;&quot;
+opcode module - potentially shared between dis and other modules which
+operate on bytecodes (e.g. peephole optimizers).
+&quot;&quot;&quot;
+
+__all__ = [&quot;cmp_op&quot;, &quot;hasconst&quot;, &quot;hasname&quot;, &quot;hasjrel&quot;, &quot;hasjabs&quot;,
+           &quot;haslocal&quot;, &quot;hascompare&quot;, &quot;hasfree&quot;, &quot;opname&quot;, &quot;opmap&quot;,
+           &quot;HAVE_ARGUMENT&quot;, &quot;EXTENDED_ARG&quot;]
+
+cmp_op = ('&lt;', '&lt;=', '==', '!=', '&gt;', '&gt;=', 'in', 'not in', 'is',
+        'is not', 'exception match', 'BAD')
+
+hasconst = []
+hasname = []
+hasjrel = []
+hasjabs = []
+haslocal = []
+hascompare = []
+hasfree = []
+
+opmap = {}
+opname = [''] * 256
+for op in range(256): opname[op] = '&lt;%r&gt;' % (op,)
+del op
+
+def def_op(name, op):
+    opname[op] = name
+    opmap[name] = op
+
+def name_op(name, op):
+    def_op(name, op)
+    hasname.append(op)
+
+def jrel_op(name, op):
+    def_op(name, op)
+    hasjrel.append(op)
+
+def jabs_op(name, op):
+    def_op(name, op)
+    hasjabs.append(op)
+
+# Instruction opcodes for compiled code
+# Blank lines correspond to available opcodes
+
+def_op('STOP_CODE', 0)
+def_op('POP_TOP', 1)
+def_op('ROT_TWO', 2)
+def_op('ROT_THREE', 3)
+def_op('DUP_TOP', 4)
+def_op('ROT_FOUR', 5)
+
+def_op('NOP', 9)
+def_op('UNARY_POSITIVE', 10)
+def_op('UNARY_NEGATIVE', 11)
+def_op('UNARY_NOT', 12)
+def_op('UNARY_CONVERT', 13)
+
+def_op('UNARY_INVERT', 15)
+
+def_op('LIST_APPEND', 18)
+def_op('BINARY_POWER', 19)
+def_op('BINARY_MULTIPLY', 20)
+def_op('BINARY_DIVIDE', 21)
+def_op('BINARY_MODULO', 22)
+def_op('BINARY_ADD', 23)
+def_op('BINARY_SUBTRACT', 24)
+def_op('BINARY_SUBSCR', 25)
+def_op('BINARY_FLOOR_DIVIDE', 26)
+def_op('BINARY_TRUE_DIVIDE', 27)
+def_op('INPLACE_FLOOR_DIVIDE', 28)
+def_op('INPLACE_TRUE_DIVIDE', 29)
+def_op('SLICE+0', 30)
+def_op('SLICE+1', 31)
+def_op('SLICE+2', 32)
+def_op('SLICE+3', 33)
+
+def_op('STORE_SLICE+0', 40)
+def_op('STORE_SLICE+1', 41)
+def_op('STORE_SLICE+2', 42)
+def_op('STORE_SLICE+3', 43)
+
+def_op('DELETE_SLICE+0', 50)
+def_op('DELETE_SLICE+1', 51)
+def_op('DELETE_SLICE+2', 52)
+def_op('DELETE_SLICE+3', 53)
+
+def_op('INPLACE_ADD', 55)
+def_op('INPLACE_SUBTRACT', 56)
+def_op('INPLACE_MULTIPLY', 57)
+def_op('INPLACE_DIVIDE', 58)
+def_op('INPLACE_MODULO', 59)
+def_op('STORE_SUBSCR', 60)
+def_op('DELETE_SUBSCR', 61)
+def_op('BINARY_LSHIFT', 62)
+def_op('BINARY_RSHIFT', 63)
+def_op('BINARY_AND', 64)
+def_op('BINARY_XOR', 65)
+def_op('BINARY_OR', 66)
+def_op('INPLACE_POWER', 67)
+def_op('GET_ITER', 68)
+
+def_op('PRINT_EXPR', 70)
+def_op('PRINT_ITEM', 71)
+def_op('PRINT_NEWLINE', 72)
+def_op('PRINT_ITEM_TO', 73)
+def_op('PRINT_NEWLINE_TO', 74)
+def_op('INPLACE_LSHIFT', 75)
+def_op('INPLACE_RSHIFT', 76)
+def_op('INPLACE_AND', 77)
+def_op('INPLACE_XOR', 78)
+def_op('INPLACE_OR', 79)
+def_op('BREAK_LOOP', 80)
+def_op('WITH_CLEANUP', 81)
+def_op('LOAD_LOCALS', 82)
+def_op('RETURN_VALUE', 83)
+def_op('IMPORT_STAR', 84)
+def_op('EXEC_STMT', 85)
+def_op('YIELD_VALUE', 86)
+def_op('POP_BLOCK', 87)
+def_op('END_FINALLY', 88)
+def_op('BUILD_CLASS', 89)
+
+HAVE_ARGUMENT = 90              # Opcodes from here have an argument:
+
+name_op('STORE_NAME', 90)       # Index in name list
+name_op('DELETE_NAME', 91)      # &quot;&quot;
+def_op('UNPACK_SEQUENCE', 92)   # Number of tuple items
+jrel_op('FOR_ITER', 93)
+
+name_op('STORE_ATTR', 95)       # Index in name list
+name_op('DELETE_ATTR', 96)      # &quot;&quot;
+name_op('STORE_GLOBAL', 97)     # &quot;&quot;
+name_op('DELETE_GLOBAL', 98)    # &quot;&quot;
+def_op('DUP_TOPX', 99)          # number of items to duplicate
+def_op('LOAD_CONST', 100)       # Index in const list
+hasconst.append(100)
+name_op('LOAD_NAME', 101)       # Index in name list
+def_op('BUILD_TUPLE', 102)      # Number of tuple items
+def_op('BUILD_LIST', 103)       # Number of list items
+def_op('BUILD_MAP', 104)        # Always zero for now
+name_op('LOAD_ATTR', 105)       # Index in name list
+def_op('COMPARE_OP', 106)       # Comparison operator
+hascompare.append(106)
+name_op('IMPORT_NAME', 107)     # Index in name list
+name_op('IMPORT_FROM', 108)     # Index in name list
+
+jrel_op('JUMP_FORWARD', 110)    # Number of bytes to skip
+jrel_op('JUMP_IF_FALSE', 111)   # &quot;&quot;
+jrel_op('JUMP_IF_TRUE', 112)    # &quot;&quot;
+jabs_op('JUMP_ABSOLUTE', 113)   # Target byte offset from beginning of code
+
+name_op('LOAD_GLOBAL', 116)     # Index in name list
+
+jabs_op('CONTINUE_LOOP', 119)   # Target address
+jrel_op('SETUP_LOOP', 120)      # Distance to target address
+jrel_op('SETUP_EXCEPT', 121)    # &quot;&quot;
+jrel_op('SETUP_FINALLY', 122)   # &quot;&quot;
+
+def_op('LOAD_FAST', 124)        # Local variable number
+haslocal.append(124)
+def_op('STORE_FAST', 125)       # Local variable number
+haslocal.append(125)
+def_op('DELETE_FAST', 126)      # Local variable number
+haslocal.append(126)
+
+def_op('RAISE_VARARGS', 130)    # Number of raise arguments (1, 2, or 3)
+def_op('CALL_FUNCTION', 131)    # #args + (#kwargs &lt;&lt; 8)
+def_op('MAKE_FUNCTION', 132)    # Number of args with default values
+def_op('BUILD_SLICE', 133)      # Number of items
+def_op('MAKE_CLOSURE', 134)
+def_op('LOAD_CLOSURE', 135)
+hasfree.append(135)
+def_op('LOAD_DEREF', 136)
+hasfree.append(136)
+def_op('STORE_DEREF', 137)
+hasfree.append(137)
+
+def_op('CALL_FUNCTION_VAR', 140)     # #args + (#kwargs &lt;&lt; 8)
+def_op('CALL_FUNCTION_KW', 141)      # #args + (#kwargs &lt;&lt; 8)
+def_op('CALL_FUNCTION_VAR_KW', 142)  # #args + (#kwargs &lt;&lt; 8)
+def_op('EXTENDED_ARG', 143)
+EXTENDED_ARG = 143
+
+del def_op, name_op, jrel_op, jabs_op

Added: trunk/Lobby/TASClient/Python/engine/os.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/os.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/os.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,735 @@
+r&quot;&quot;&quot;OS routines for Mac, NT, or Posix depending on what system we're on.
+
+This exports:
+  - all functions from posix, nt, os2, mac, or ce, e.g. unlink, stat, etc.
+  - os.path is one of the modules posixpath, ntpath, or macpath
+  - os.name is 'posix', 'nt', 'os2', 'mac', 'ce' or 'riscos'
+  - os.curdir is a string representing the current directory ('.' or ':')
+  - os.pardir is a string representing the parent directory ('..' or '::')
+  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')
+  - os.extsep is the extension separator ('.' or '/')
+  - os.altsep is the alternate pathname separator (None or '/')
+  - os.pathsep is the component separator used in $PATH etc
+  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
+  - os.defpath is the default search path for executables
+  - os.devnull is the file path of the null device ('/dev/null', etc.)
+
+Programs that import and use 'os' stand a better chance of being
+portable between different platforms.  Of course, they must then
+only use functions that are defined by all platforms (e.g., unlink
+and opendir), and leave all pathname manipulation to os.path
+(e.g., split and join).
+&quot;&quot;&quot;
+
+#'
+
+import sys, errno
+
+_names = sys.builtin_module_names
+
+# Note:  more names are added to __all__ later.
+__all__ = [&quot;altsep&quot;, &quot;curdir&quot;, &quot;pardir&quot;, &quot;sep&quot;, &quot;pathsep&quot;, &quot;linesep&quot;,
+           &quot;defpath&quot;, &quot;name&quot;, &quot;path&quot;, &quot;devnull&quot;,
+           &quot;SEEK_SET&quot;, &quot;SEEK_CUR&quot;, &quot;SEEK_END&quot;]
+
+def _get_exports_list(module):
+    try:
+        return list(module.__all__)
+    except AttributeError:
+        return [n for n in dir(module) if n[0] != '_']
+
+if 'posix' in _names:
+    name = 'posix'
+    linesep = '\n'
+    from posix import *
+    try:
+        from posix import _exit
+    except ImportError:
+        pass
+    import posixpath as path
+
+    import posix
+    __all__.extend(_get_exports_list(posix))
+    del posix
+
+elif 'nt' in _names:
+    name = 'nt'
+    linesep = '\r\n'
+    from nt import *
+    try:
+        from nt import _exit
+    except ImportError:
+        pass
+    import ntpath as path
+
+    import nt
+    __all__.extend(_get_exports_list(nt))
+    del nt
+
+elif 'os2' in _names:
+    name = 'os2'
+    linesep = '\r\n'
+    from os2 import *
+    try:
+        from os2 import _exit
+    except ImportError:
+        pass
+    if sys.version.find('EMX GCC') == -1:
+        import ntpath as path
+    else:
+        import os2emxpath as path
+        from _emx_link import link
+
+    import os2
+    __all__.extend(_get_exports_list(os2))
+    del os2
+
+elif 'mac' in _names:
+    name = 'mac'
+    linesep = '\r'
+    from mac import *
+    try:
+        from mac import _exit
+    except ImportError:
+        pass
+    import macpath as path
+
+    import mac
+    __all__.extend(_get_exports_list(mac))
+    del mac
+
+elif 'ce' in _names:
+    name = 'ce'
+    linesep = '\r\n'
+    from ce import *
+    try:
+        from ce import _exit
+    except ImportError:
+        pass
+    # We can use the standard Windows path.
+    import ntpath as path
+
+    import ce
+    __all__.extend(_get_exports_list(ce))
+    del ce
+
+elif 'riscos' in _names:
+    name = 'riscos'
+    linesep = '\n'
+    from riscos import *
+    try:
+        from riscos import _exit
+    except ImportError:
+        pass
+    import riscospath as path
+
+    import riscos
+    __all__.extend(_get_exports_list(riscos))
+    del riscos
+
+else:
+    raise ImportError, 'no os specific module found'
+
+sys.modules['os.path'] = path
+from os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,
+    devnull)
+
+del _names
+
+# Python uses fixed values for the SEEK_ constants; they are mapped
+# to native constants if necessary in posixmodule.c
+SEEK_SET = 0
+SEEK_CUR = 1
+SEEK_END = 2
+
+#'
+
+# Super directory utilities.
+# (Inspired by Eric Raymond; the doc strings are mostly his)
+
+def makedirs(name, mode=0777):
+    &quot;&quot;&quot;makedirs(path [, mode=0777])
+
+    Super-mkdir; create a leaf directory and all intermediate ones.
+    Works like mkdir, except that any intermediate path segment (not
+    just the rightmost) will be created if it does not exist.  This is
+    recursive.
+
+    &quot;&quot;&quot;
+    head, tail = path.split(name)
+    if not tail:
+        head, tail = path.split(head)
+    if head and tail and not path.exists(head):
+        try:
+            makedirs(head, mode)
+        except OSError, e:
+            # be happy if someone already created the path
+            if e.errno != errno.EEXIST:
+                raise
+        if tail == curdir:           # xxx/newdir/. exists if xxx/newdir exists
+            return
+    mkdir(name, mode)
+
+def removedirs(name):
+    &quot;&quot;&quot;removedirs(path)
+
+    Super-rmdir; remove a leaf directory and all empty intermediate
+    ones.  Works like rmdir except that, if the leaf directory is
+    successfully removed, directories corresponding to rightmost path
+    segments will be pruned away until either the whole path is
+    consumed or an error occurs.  Errors during this latter phase are
+    ignored -- they generally mean that a directory was not empty.
+
+    &quot;&quot;&quot;
+    rmdir(name)
+    head, tail = path.split(name)
+    if not tail:
+        head, tail = path.split(head)
+    while head and tail:
+        try:
+            rmdir(head)
+        except error:
+            break
+        head, tail = path.split(head)
+
+def renames(old, new):
+    &quot;&quot;&quot;renames(old, new)
+
+    Super-rename; create directories as necessary and delete any left
+    empty.  Works like rename, except creation of any intermediate
+    directories needed to make the new pathname good is attempted
+    first.  After the rename, directories corresponding to rightmost
+    path segments of the old name will be pruned way until either the
+    whole path is consumed or a nonempty directory is found.
+
+    Note: this function can fail with the new directory structure made
+    if you lack permissions needed to unlink the leaf directory or
+    file.
+
+    &quot;&quot;&quot;
+    head, tail = path.split(new)
+    if head and tail and not path.exists(head):
+        makedirs(head)
+    rename(old, new)
+    head, tail = path.split(old)
+    if head and tail:
+        try:
+            removedirs(head)
+        except error:
+            pass
+
+__all__.extend([&quot;makedirs&quot;, &quot;removedirs&quot;, &quot;renames&quot;])
+
+def walk(top, topdown=True, onerror=None):
+    &quot;&quot;&quot;Directory tree generator.
+
+    For each directory in the directory tree rooted at top (including top
+    itself, but excluding '.' and '..'), yields a 3-tuple
+
+        dirpath, dirnames, filenames
+
+    dirpath is a string, the path to the directory.  dirnames is a list of
+    the names of the subdirectories in dirpath (excluding '.' and '..').
+    filenames is a list of the names of the non-directory files in dirpath.
+    Note that the names in the lists are just names, with no path components.
+    To get a full path (which begins with top) to a file or directory in
+    dirpath, do os.path.join(dirpath, name).
+
+    If optional arg 'topdown' is true or not specified, the triple for a
+    directory is generated before the triples for any of its subdirectories
+    (directories are generated top down).  If topdown is false, the triple
+    for a directory is generated after the triples for all of its
+    subdirectories (directories are generated bottom up).
+
+    When topdown is true, the caller can modify the dirnames list in-place
+    (e.g., via del or slice assignment), and walk will only recurse into the
+    subdirectories whose names remain in dirnames; this can be used to prune
+    the search, or to impose a specific order of visiting.  Modifying
+    dirnames when topdown is false is ineffective, since the directories in
+    dirnames have already been generated by the time dirnames itself is
+    generated.
+
+    By default errors from the os.listdir() call are ignored.  If
+    optional arg 'onerror' is specified, it should be a function; it
+    will be called with one argument, an os.error instance.  It can
+    report the error to continue with the walk, or raise the exception
+    to abort the walk.  Note that the filename is available as the
+    filename attribute of the exception object.
+
+    Caution:  if you pass a relative pathname for top, don't change the
+    current working directory between resumptions of walk.  walk never
+    changes the current directory, and assumes that the client doesn't
+    either.
+
+    Example:
+
+    from os.path import join, getsize
+    for root, dirs, files in walk('python/Lib/email'):
+        print root, &quot;consumes&quot;,
+        print sum([getsize(join(root, name)) for name in files]),
+        print &quot;bytes in&quot;, len(files), &quot;non-directory files&quot;
+        if 'CVS' in dirs:
+            dirs.remove('CVS')  # don't visit CVS directories
+    &quot;&quot;&quot;
+
+    from os.path import join, isdir, islink
+
+    # We may not have read permission for top, in which case we can't
+    # get a list of the files the directory contains.  os.path.walk
+    # always suppressed the exception then, rather than blow up for a
+    # minor reason when (say) a thousand readable directories are still
+    # left to visit.  That logic is copied here.
+    try:
+        # Note that listdir and error are globals in this module due
+        # to earlier import-*.
+        names = listdir(top)
+    except error, err:
+        if onerror is not None:
+            onerror(err)
+        return
+
+    dirs, nondirs = [], []
+    for name in names:
+        if isdir(join(top, name)):
+            dirs.append(name)
+        else:
+            nondirs.append(name)
+
+    if topdown:
+        yield top, dirs, nondirs
+    for name in dirs:
+        path = join(top, name)
+        if not islink(path):
+            for x in walk(path, topdown, onerror):
+                yield x
+    if not topdown:
+        yield top, dirs, nondirs
+
+__all__.append(&quot;walk&quot;)
+
+# Make sure os.environ exists, at least
+try:
+    environ
+except NameError:
+    environ = {}
+
+def execl(file, *args):
+    &quot;&quot;&quot;execl(file, *args)
+
+    Execute the executable file with argument list args, replacing the
+    current process. &quot;&quot;&quot;
+    execv(file, args)
+
+def execle(file, *args):
+    &quot;&quot;&quot;execle(file, *args, env)
+
+    Execute the executable file with argument list args and
+    environment env, replacing the current process. &quot;&quot;&quot;
+    env = args[-1]
+    execve(file, args[:-1], env)
+
+def execlp(file, *args):
+    &quot;&quot;&quot;execlp(file, *args)
+
+    Execute the executable file (which is searched for along $PATH)
+    with argument list args, replacing the current process. &quot;&quot;&quot;
+    execvp(file, args)
+
+def execlpe(file, *args):
+    &quot;&quot;&quot;execlpe(file, *args, env)
+
+    Execute the executable file (which is searched for along $PATH)
+    with argument list args and environment env, replacing the current
+    process. &quot;&quot;&quot;
+    env = args[-1]
+    execvpe(file, args[:-1], env)
+
+def execvp(file, args):
+    &quot;&quot;&quot;execp(file, args)
+
+    Execute the executable file (which is searched for along $PATH)
+    with argument list args, replacing the current process.
+    args may be a list or tuple of strings. &quot;&quot;&quot;
+    _execvpe(file, args)
+
+def execvpe(file, args, env):
+    &quot;&quot;&quot;execvpe(file, args, env)
+
+    Execute the executable file (which is searched for along $PATH)
+    with argument list args and environment env , replacing the
+    current process.
+    args may be a list or tuple of strings. &quot;&quot;&quot;
+    _execvpe(file, args, env)
+
+__all__.extend([&quot;execl&quot;,&quot;execle&quot;,&quot;execlp&quot;,&quot;execlpe&quot;,&quot;execvp&quot;,&quot;execvpe&quot;])
+
+def _execvpe(file, args, env=None):
+    if env is not None:
+        func = execve
+        argrest = (args, env)
+    else:
+        func = execv
+        argrest = (args,)
+        env = environ
+
+    head, tail = path.split(file)
+    if head:
+        func(file, *argrest)
+        return
+    if 'PATH' in env:
+        envpath = env['PATH']
+    else:
+        envpath = defpath
+    PATH = envpath.split(pathsep)
+    saved_exc = None
+    saved_tb = None
+    for dir in PATH:
+        fullname = path.join(dir, file)
+        try:
+            func(fullname, *argrest)
+        except error, e:
+            tb = sys.exc_info()[2]
+            if (e.errno != errno.ENOENT and e.errno != errno.ENOTDIR
+                and saved_exc is None):
+                saved_exc = e
+                saved_tb = tb
+    if saved_exc:
+        raise error, saved_exc, saved_tb
+    raise error, e, tb
+
+# Change environ to automatically call putenv() if it exists
+try:
+    # This will fail if there's no putenv
+    putenv
+except NameError:
+    pass
+else:
+    import UserDict
+
+    # Fake unsetenv() for Windows
+    # not sure about os2 here but
+    # I'm guessing they are the same.
+
+    if name in ('os2', 'nt'):
+        def unsetenv(key):
+            putenv(key, &quot;&quot;)
+
+    if name == &quot;riscos&quot;:
+        # On RISC OS, all env access goes through getenv and putenv
+        from riscosenviron import _Environ
+    elif name in ('os2', 'nt'):  # Where Env Var Names Must Be UPPERCASE
+        # But we store them as upper case
+        class _Environ(UserDict.IterableUserDict):
+            def __init__(self, environ):
+                UserDict.UserDict.__init__(self)
+                data = self.data
+                for k, v in environ.items():
+                    data[k.upper()] = v
+            def __setitem__(self, key, item):
+                putenv(key, item)
+                self.data[key.upper()] = item
+            def __getitem__(self, key):
+                return self.data[key.upper()]
+            try:
+                unsetenv
+            except NameError:
+                def __delitem__(self, key):
+                    del self.data[key.upper()]
+            else:
+                def __delitem__(self, key):
+                    unsetenv(key)
+                    del self.data[key.upper()]
+            def has_key(self, key):
+                return key.upper() in self.data
+            def __contains__(self, key):
+                return key.upper() in self.data
+            def get(self, key, failobj=None):
+                return self.data.get(key.upper(), failobj)
+            def update(self, dict=None, **kwargs):
+                if dict:
+                    try:
+                        keys = dict.keys()
+                    except AttributeError:
+                        # List of (key, value)
+                        for k, v in dict:
+                            self[k] = v
+                    else:
+                        # got keys
+                        # cannot use items(), since mappings
+                        # may not have them.
+                        for k in keys:
+                            self[k] = dict[k]
+                if kwargs:
+                    self.update(kwargs)
+            def copy(self):
+                return dict(self)
+
+    else:  # Where Env Var Names Can Be Mixed Case
+        class _Environ(UserDict.IterableUserDict):
+            def __init__(self, environ):
+                UserDict.UserDict.__init__(self)
+                self.data = environ
+            def __setitem__(self, key, item):
+                putenv(key, item)
+                self.data[key] = item
+            def update(self,  dict=None, **kwargs):
+                if dict:
+                    try:
+                        keys = dict.keys()
+                    except AttributeError:
+                        # List of (key, value)
+                        for k, v in dict:
+                            self[k] = v
+                    else:
+                        # got keys
+                        # cannot use items(), since mappings
+                        # may not have them.
+                        for k in keys:
+                            self[k] = dict[k]
+                if kwargs:
+                    self.update(kwargs)
+            try:
+                unsetenv
+            except NameError:
+                pass
+            else:
+                def __delitem__(self, key):
+                    unsetenv(key)
+                    del self.data[key]
+            def copy(self):
+                return dict(self)
+
+
+    environ = _Environ(environ)
+
+def getenv(key, default=None):
+    &quot;&quot;&quot;Get an environment variable, return None if it doesn't exist.
+    The optional second argument can specify an alternate default.&quot;&quot;&quot;
+    return environ.get(key, default)
+__all__.append(&quot;getenv&quot;)
+
+def _exists(name):
+    try:
+        eval(name)
+        return True
+    except NameError:
+        return False
+
+# Supply spawn*() (probably only for Unix)
+if _exists(&quot;fork&quot;) and not _exists(&quot;spawnv&quot;) and _exists(&quot;execv&quot;):
+
+    P_WAIT = 0
+    P_NOWAIT = P_NOWAITO = 1
+
+    # XXX Should we support P_DETACH?  I suppose it could fork()**2
+    # and close the std I/O streams.  Also, P_OVERLAY is the same
+    # as execv*()?
+
+    def _spawnvef(mode, file, args, env, func):
+        # Internal helper; func is the exec*() function to use
+        pid = fork()
+        if not pid:
+            # Child
+            try:
+                if env is None:
+                    func(file, args)
+                else:
+                    func(file, args, env)
+            except:
+                _exit(127)
+        else:
+            # Parent
+            if mode == P_NOWAIT:
+                return pid # Caller is responsible for waiting!
+            while 1:
+                wpid, sts = waitpid(pid, 0)
+                if WIFSTOPPED(sts):
+                    continue
+                elif WIFSIGNALED(sts):
+                    return -WTERMSIG(sts)
+                elif WIFEXITED(sts):
+                    return WEXITSTATUS(sts)
+                else:
+                    raise error, &quot;Not stopped, signaled or exited???&quot;
+
+    def spawnv(mode, file, args):
+        &quot;&quot;&quot;spawnv(mode, file, args) -&gt; integer
+
+Execute file with arguments from args in a subprocess.
+If mode == P_NOWAIT return the pid of the process.
+If mode == P_WAIT return the process's exit code if it exits normally;
+otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;
+        return _spawnvef(mode, file, args, None, execv)
+
+    def spawnve(mode, file, args, env):
+        &quot;&quot;&quot;spawnve(mode, file, args, env) -&gt; integer
+
+Execute file with arguments from args in a subprocess with the
+specified environment.
+If mode == P_NOWAIT return the pid of the process.
+If mode == P_WAIT return the process's exit code if it exits normally;
+otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;
+        return _spawnvef(mode, file, args, env, execve)
+
+    # Note: spawnvp[e] is't currently supported on Windows
+
+    def spawnvp(mode, file, args):
+        &quot;&quot;&quot;spawnvp(mode, file, args) -&gt; integer
+
+Execute file (which is looked for along $PATH) with arguments from
+args in a subprocess.
+If mode == P_NOWAIT return the pid of the process.
+If mode == P_WAIT return the process's exit code if it exits normally;
+otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;
+        return _spawnvef(mode, file, args, None, execvp)
+
+    def spawnvpe(mode, file, args, env):
+        &quot;&quot;&quot;spawnvpe(mode, file, args, env) -&gt; integer
+
+Execute file (which is looked for along $PATH) with arguments from
+args in a subprocess with the supplied environment.
+If mode == P_NOWAIT return the pid of the process.
+If mode == P_WAIT return the process's exit code if it exits normally;
+otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;
+        return _spawnvef(mode, file, args, env, execvpe)
+
+if _exists(&quot;spawnv&quot;):
+    # These aren't supplied by the basic Windows code
+    # but can be easily implemented in Python
+
+    def spawnl(mode, file, *args):
+        &quot;&quot;&quot;spawnl(mode, file, *args) -&gt; integer
+
+Execute file with arguments from args in a subprocess.
+If mode == P_NOWAIT return the pid of the process.
+If mode == P_WAIT return the process's exit code if it exits normally;
+otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;
+        return spawnv(mode, file, args)
+
+    def spawnle(mode, file, *args):
+        &quot;&quot;&quot;spawnle(mode, file, *args, env) -&gt; integer
+
+Execute file with arguments from args in a subprocess with the
+supplied environment.
+If mode == P_NOWAIT return the pid of the process.
+If mode == P_WAIT return the process's exit code if it exits normally;
+otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;
+        env = args[-1]
+        return spawnve(mode, file, args[:-1], env)
+
+
+    __all__.extend([&quot;spawnv&quot;, &quot;spawnve&quot;, &quot;spawnl&quot;, &quot;spawnle&quot;,])
+
+
+if _exists(&quot;spawnvp&quot;):
+    # At the moment, Windows doesn't implement spawnvp[e],
+    # so it won't have spawnlp[e] either.
+    def spawnlp(mode, file, *args):
+        &quot;&quot;&quot;spawnlp(mode, file, *args) -&gt; integer
+
+Execute file (which is looked for along $PATH) with arguments from
+args in a subprocess with the supplied environment.
+If mode == P_NOWAIT return the pid of the process.
+If mode == P_WAIT return the process's exit code if it exits normally;
+otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;
+        return spawnvp(mode, file, args)
+
+    def spawnlpe(mode, file, *args):
+        &quot;&quot;&quot;spawnlpe(mode, file, *args, env) -&gt; integer
+
+Execute file (which is looked for along $PATH) with arguments from
+args in a subprocess with the supplied environment.
+If mode == P_NOWAIT return the pid of the process.
+If mode == P_WAIT return the process's exit code if it exits normally;
+otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;
+        env = args[-1]
+        return spawnvpe(mode, file, args[:-1], env)
+
+
+    __all__.extend([&quot;spawnvp&quot;, &quot;spawnvpe&quot;, &quot;spawnlp&quot;, &quot;spawnlpe&quot;,])
+
+
+# Supply popen2 etc. (for Unix)
+if _exists(&quot;fork&quot;):
+    if not _exists(&quot;popen2&quot;):
+        def popen2(cmd, mode=&quot;t&quot;, bufsize=-1):
+            &quot;&quot;&quot;Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
+            may be a sequence, in which case arguments will be passed directly to
+            the program without shell intervention (as with os.spawnv()).  If 'cmd'
+            is a string it will be passed to the shell (as with os.system()). If
+            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
+            file objects (child_stdin, child_stdout) are returned.&quot;&quot;&quot;
+            import popen2
+            stdout, stdin = popen2.popen2(cmd, bufsize)
+            return stdin, stdout
+        __all__.append(&quot;popen2&quot;)
+
+    if not _exists(&quot;popen3&quot;):
+        def popen3(cmd, mode=&quot;t&quot;, bufsize=-1):
+            &quot;&quot;&quot;Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
+            may be a sequence, in which case arguments will be passed directly to
+            the program without shell intervention (as with os.spawnv()).  If 'cmd'
+            is a string it will be passed to the shell (as with os.system()). If
+            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
+            file objects (child_stdin, child_stdout, child_stderr) are returned.&quot;&quot;&quot;
+            import popen2
+            stdout, stdin, stderr = popen2.popen3(cmd, bufsize)
+            return stdin, stdout, stderr
+        __all__.append(&quot;popen3&quot;)
+
+    if not _exists(&quot;popen4&quot;):
+        def popen4(cmd, mode=&quot;t&quot;, bufsize=-1):
+            &quot;&quot;&quot;Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
+            may be a sequence, in which case arguments will be passed directly to
+            the program without shell intervention (as with os.spawnv()).  If 'cmd'
+            is a string it will be passed to the shell (as with os.system()). If
+            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
+            file objects (child_stdin, child_stdout_stderr) are returned.&quot;&quot;&quot;
+            import popen2
+            stdout, stdin = popen2.popen4(cmd, bufsize)
+            return stdin, stdout
+        __all__.append(&quot;popen4&quot;)
+
+import copy_reg as _copy_reg
+
+def _make_stat_result(tup, dict):
+    return stat_result(tup, dict)
+
+def _pickle_stat_result(sr):
+    (type, args) = sr.__reduce__()
+    return (_make_stat_result, args)
+
+try:
+    _copy_reg.pickle(stat_result, _pickle_stat_result, _make_stat_result)
+except NameError: # stat_result may not exist
+    pass
+
+def _make_statvfs_result(tup, dict):
+    return statvfs_result(tup, dict)
+
+def _pickle_statvfs_result(sr):
+    (type, args) = sr.__reduce__()
+    return (_make_statvfs_result, args)
+
+try:
+    _copy_reg.pickle(statvfs_result, _pickle_statvfs_result,
+                     _make_statvfs_result)
+except NameError: # statvfs_result may not exist
+    pass
+
+if not _exists(&quot;urandom&quot;):
+    def urandom(n):
+        &quot;&quot;&quot;urandom(n) -&gt; str
+
+        Return a string of n random bytes suitable for cryptographic use.
+
+        &quot;&quot;&quot;
+        try:
+            _urandomfd = open(&quot;/dev/urandom&quot;, O_RDONLY)
+        except (OSError, IOError):
+            raise NotImplementedError(&quot;/dev/urandom (or equivalent) not found&quot;)
+        bytes = &quot;&quot;
+        while len(bytes) &lt; n:
+            bytes += read(_urandomfd, n - len(bytes))
+        close(_urandomfd)
+        return bytes

Added: trunk/Lobby/TASClient/Python/engine/posixpath.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/posixpath.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/posixpath.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,453 @@
+&quot;&quot;&quot;Common operations on Posix pathnames.
+
+Instead of importing this module directly, import os and refer to
+this module as os.path.  The &quot;os.path&quot; name is an alias for this
+module on Posix systems; on other systems (e.g. Mac, Windows),
+os.path provides the same operations in a manner specific to that
+platform, and is an alias to another module (e.g. macpath, ntpath).
+
+Some of this can actually be useful on non-Posix systems too, e.g.
+for manipulation of the pathname component of URLs.
+&quot;&quot;&quot;
+
+import os
+import stat
+
+__all__ = [&quot;normcase&quot;,&quot;isabs&quot;,&quot;join&quot;,&quot;splitdrive&quot;,&quot;split&quot;,&quot;splitext&quot;,
+           &quot;basename&quot;,&quot;dirname&quot;,&quot;commonprefix&quot;,&quot;getsize&quot;,&quot;getmtime&quot;,
+           &quot;getatime&quot;,&quot;getctime&quot;,&quot;islink&quot;,&quot;exists&quot;,&quot;lexists&quot;,&quot;isdir&quot;,&quot;isfile&quot;,
+           &quot;ismount&quot;,&quot;walk&quot;,&quot;expanduser&quot;,&quot;expandvars&quot;,&quot;normpath&quot;,&quot;abspath&quot;,
+           &quot;samefile&quot;,&quot;sameopenfile&quot;,&quot;samestat&quot;,
+           &quot;curdir&quot;,&quot;pardir&quot;,&quot;sep&quot;,&quot;pathsep&quot;,&quot;defpath&quot;,&quot;altsep&quot;,&quot;extsep&quot;,
+           &quot;devnull&quot;,&quot;realpath&quot;,&quot;supports_unicode_filenames&quot;]
+
+# strings representing various path-related bits and pieces
+curdir = '.'
+pardir = '..'
+extsep = '.'
+sep = '/'
+pathsep = ':'
+defpath = ':/bin:/usr/bin'
+altsep = None
+devnull = '/dev/null'
+
+# Normalize the case of a pathname.  Trivial in Posix, string.lower on Mac.
+# On MS-DOS this may also turn slashes into backslashes; however, other
+# normalizations (such as optimizing '../' away) are not allowed
+# (another function should be defined to do that).
+
+def normcase(s):
+    &quot;&quot;&quot;Normalize case of pathname.  Has no effect under Posix&quot;&quot;&quot;
+    return s
+
+
+# Return whether a path is absolute.
+# Trivial in Posix, harder on the Mac or MS-DOS.
+
+def isabs(s):
+    &quot;&quot;&quot;Test whether a path is absolute&quot;&quot;&quot;
+    return s.startswith('/')
+
+
+# Join pathnames.
+# Ignore the previous parts if a part is absolute.
+# Insert a '/' unless the first part is empty or already ends in '/'.
+
+def join(a, *p):
+    &quot;&quot;&quot;Join two or more pathname components, inserting '/' as needed&quot;&quot;&quot;
+    path = a
+    for b in p:
+        if b.startswith('/'):
+            path = b
+        elif path == '' or path.endswith('/'):
+            path +=  b
+        else:
+            path += '/' + b
+    return path
+
+
+# Split a path in head (everything up to the last '/') and tail (the
+# rest).  If the path ends in '/', tail will be empty.  If there is no
+# '/' in the path, head  will be empty.
+# Trailing '/'es are stripped from head unless it is the root.
+
+def split(p):
+    &quot;&quot;&quot;Split a pathname.  Returns tuple &quot;(head, tail)&quot; where &quot;tail&quot; is
+    everything after the final slash.  Either part may be empty.&quot;&quot;&quot;
+    i = p.rfind('/') + 1
+    head, tail = p[:i], p[i:]
+    if head and head != '/'*len(head):
+        head = head.rstrip('/')
+    return head, tail
+
+
+# Split a path in root and extension.
+# The extension is everything starting at the last dot in the last
+# pathname component; the root is everything before that.
+# It is always true that root + ext == p.
+
+def splitext(p):
+    &quot;&quot;&quot;Split the extension from a pathname.  Extension is everything from the
+    last dot to the end.  Returns &quot;(root, ext)&quot;, either part may be empty.&quot;&quot;&quot;
+    i = p.rfind('.')
+    if i&lt;=p.rfind('/'):
+        return p, ''
+    else:
+        return p[:i], p[i:]
+
+
+# Split a pathname into a drive specification and the rest of the
+# path.  Useful on DOS/Windows/NT; on Unix, the drive is always empty.
+
+def splitdrive(p):
+    &quot;&quot;&quot;Split a pathname into drive and path. On Posix, drive is always
+    empty.&quot;&quot;&quot;
+    return '', p
+
+
+# Return the tail (basename) part of a path.
+
+def basename(p):
+    &quot;&quot;&quot;Returns the final component of a pathname&quot;&quot;&quot;
+    return split(p)[1]
+
+
+# Return the head (dirname) part of a path.
+
+def dirname(p):
+    &quot;&quot;&quot;Returns the directory component of a pathname&quot;&quot;&quot;
+    return split(p)[0]
+
+
+# Return the longest prefix of all list elements.
+
+def commonprefix(m):
+    &quot;Given a list of pathnames, returns the longest common leading component&quot;
+    if not m: return ''
+    s1 = min(m)
+    s2 = max(m)
+    n = min(len(s1), len(s2))
+    for i in xrange(n):
+        if s1[i] != s2[i]:
+            return s1[:i]
+    return s1[:n]
+
+# Get size, mtime, atime of files.
+
+def getsize(filename):
+    &quot;&quot;&quot;Return the size of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_size
+
+def getmtime(filename):
+    &quot;&quot;&quot;Return the last modification time of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_mtime
+
+def getatime(filename):
+    &quot;&quot;&quot;Return the last access time of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_atime
+
+def getctime(filename):
+    &quot;&quot;&quot;Return the metadata change time of a file, reported by os.stat().&quot;&quot;&quot;
+    return os.stat(filename).st_ctime
+
+# Is a path a symbolic link?
+# This will always return false on systems where os.lstat doesn't exist.
+
+def islink(path):
+    &quot;&quot;&quot;Test whether a path is a symbolic link&quot;&quot;&quot;
+    try:
+        st = os.lstat(path)
+    except (os.error, AttributeError):
+        return False
+    return stat.S_ISLNK(st.st_mode)
+
+
+# Does a path exist?
+# This is false for dangling symbolic links.
+
+def exists(path):
+    &quot;&quot;&quot;Test whether a path exists.  Returns False for broken symbolic links&quot;&quot;&quot;
+    try:
+        st = os.stat(path)
+    except os.error:
+        return False
+    return True
+
+
+# Being true for dangling symbolic links is also useful.
+
+def lexists(path):
+    &quot;&quot;&quot;Test whether a path exists.  Returns True for broken symbolic links&quot;&quot;&quot;
+    try:
+        st = os.lstat(path)
+    except os.error:
+        return False
+    return True
+
+
+# Is a path a directory?
+# This follows symbolic links, so both islink() and isdir() can be true
+# for the same path.
+
+def isdir(path):
+    &quot;&quot;&quot;Test whether a path is a directory&quot;&quot;&quot;
+    try:
+        st = os.stat(path)
+    except os.error:
+        return False
+    return stat.S_ISDIR(st.st_mode)
+
+
+# Is a path a regular file?
+# This follows symbolic links, so both islink() and isfile() can be true
+# for the same path.
+
+def isfile(path):
+    &quot;&quot;&quot;Test whether a path is a regular file&quot;&quot;&quot;
+    try:
+        st = os.stat(path)
+    except os.error:
+        return False
+    return stat.S_ISREG(st.st_mode)
+
+
+# Are two filenames really pointing to the same file?
+
+def samefile(f1, f2):
+    &quot;&quot;&quot;Test whether two pathnames reference the same actual file&quot;&quot;&quot;
+    s1 = os.stat(f1)
+    s2 = os.stat(f2)
+    return samestat(s1, s2)
+
+
+# Are two open files really referencing the same file?
+# (Not necessarily the same file descriptor!)
+
+def sameopenfile(fp1, fp2):
+    &quot;&quot;&quot;Test whether two open file objects reference the same file&quot;&quot;&quot;
+    s1 = os.fstat(fp1)
+    s2 = os.fstat(fp2)
+    return samestat(s1, s2)
+
+
+# Are two stat buffers (obtained from stat, fstat or lstat)
+# describing the same file?
+
+def samestat(s1, s2):
+    &quot;&quot;&quot;Test whether two stat buffers reference the same file&quot;&quot;&quot;
+    return s1.st_ino == s2.st_ino and \
+           s1.st_dev == s2.st_dev
+
+
+# Is a path a mount point?
+# (Does this work for all UNIXes?  Is it even guaranteed to work by Posix?)
+
+def ismount(path):
+    &quot;&quot;&quot;Test whether a path is a mount point&quot;&quot;&quot;
+    try:
+        s1 = os.lstat(path)
+        s2 = os.lstat(join(path, '..'))
+    except os.error:
+        return False # It doesn't exist -- so not a mount point :-)
+    dev1 = s1.st_dev
+    dev2 = s2.st_dev
+    if dev1 != dev2:
+        return True     # path/.. on a different device as path
+    ino1 = s1.st_ino
+    ino2 = s2.st_ino
+    if ino1 == ino2:
+        return True     # path/.. is the same i-node as path
+    return False
+
+
+# Directory tree walk.
+# For each directory under top (including top itself, but excluding
+# '.' and '..'), func(arg, dirname, filenames) is called, where
+# dirname is the name of the directory and filenames is the list
+# of files (and subdirectories etc.) in the directory.
+# The func may modify the filenames list, to implement a filter,
+# or to impose a different order of visiting.
+
+def walk(top, func, arg):
+    &quot;&quot;&quot;Directory tree walk with callback function.
+
+    For each directory in the directory tree rooted at top (including top
+    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
+    dirname is the name of the directory, and fnames a list of the names of
+    the files and subdirectories in dirname (excluding '.' and '..').  func
+    may modify the fnames list in-place (e.g. via del or slice assignment),
+    and walk will only recurse into the subdirectories whose names remain in
+    fnames; this can be used to implement a filter, or to impose a specific
+    order of visiting.  No semantics are defined for, or required of, arg,
+    beyond that arg is always passed to func.  It can be used, e.g., to pass
+    a filename pattern, or a mutable object designed to accumulate
+    statistics.  Passing None for arg is common.&quot;&quot;&quot;
+
+    try:
+        names = os.listdir(top)
+    except os.error:
+        return
+    func(arg, top, names)
+    for name in names:
+        name = join(top, name)
+        try:
+            st = os.lstat(name)
+        except os.error:
+            continue
+        if stat.S_ISDIR(st.st_mode):
+            walk(name, func, arg)
+
+
+# Expand paths beginning with '~' or '~user'.
+# '~' means $HOME; '~user' means that user's home directory.
+# If the path doesn't begin with '~', or if the user or $HOME is unknown,
+# the path is returned unchanged (leaving error reporting to whatever
+# function is called with the expanded path as argument).
+# See also module 'glob' for expansion of *, ? and [...] in pathnames.
+# (A function should also be defined to do full *sh-style environment
+# variable expansion.)
+
+def expanduser(path):
+    &quot;&quot;&quot;Expand ~ and ~user constructions.  If user or $HOME is unknown,
+    do nothing.&quot;&quot;&quot;
+    if not path.startswith('~'):
+        return path
+    i = path.find('/', 1)
+    if i &lt; 0:
+        i = len(path)
+    if i == 1:
+        if 'HOME' not in os.environ:
+            import pwd
+            userhome = pwd.getpwuid(os.getuid()).pw_dir
+        else:
+            userhome = os.environ['HOME']
+    else:
+        import pwd
+        try:
+            pwent = pwd.getpwnam(path[1:i])
+        except KeyError:
+            return path
+        userhome = pwent.pw_dir
+    userhome = userhome.rstrip('/')
+    return userhome + path[i:]
+
+
+# Expand paths containing shell variable substitutions.
+# This expands the forms $variable and ${variable} only.
+# Non-existent variables are left unchanged.
+
+_varprog = None
+
+def expandvars(path):
+    &quot;&quot;&quot;Expand shell variables of form $var and ${var}.  Unknown variables
+    are left unchanged.&quot;&quot;&quot;
+    global _varprog
+    if '$' not in path:
+        return path
+    if not _varprog:
+        import re
+        _varprog = re.compile(r'\$(\w+|\{[^}]*\})')
+    i = 0
+    while True:
+        m = _varprog.search(path, i)
+        if not m:
+            break
+        i, j = m.span(0)
+        name = m.group(1)
+        if name.startswith('{') and name.endswith('}'):
+            name = name[1:-1]
+        if name in os.environ:
+            tail = path[j:]
+            path = path[:i] + os.environ[name]
+            i = len(path)
+            path += tail
+        else:
+            i = j
+    return path
+
+
+# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A/B.
+# It should be understood that this may change the meaning of the path
+# if it contains symbolic links!
+
+def normpath(path):
+    &quot;&quot;&quot;Normalize path, eliminating double slashes, etc.&quot;&quot;&quot;
+    if path == '':
+        return '.'
+    initial_slashes = path.startswith('/')
+    # POSIX allows one or two initial slashes, but treats three or more
+    # as single slash.
+    if (initial_slashes and
+        path.startswith('//') and not path.startswith('///')):
+        initial_slashes = 2
+    comps = path.split('/')
+    new_comps = []
+    for comp in comps:
+        if comp in ('', '.'):
+            continue
+        if (comp != '..' or (not initial_slashes and not new_comps) or
+             (new_comps and new_comps[-1] == '..')):
+            new_comps.append(comp)
+        elif new_comps:
+            new_comps.pop()
+    comps = new_comps
+    path = '/'.join(comps)
+    if initial_slashes:
+        path = '/'*initial_slashes + path
+    return path or '.'
+
+
+def abspath(path):
+    &quot;&quot;&quot;Return an absolute path.&quot;&quot;&quot;
+    if not isabs(path):
+        path = join(os.getcwd(), path)
+    return normpath(path)
+
+
+# Return a canonical path (i.e. the absolute location of a file on the
+# filesystem).
+
+def realpath(filename):
+    &quot;&quot;&quot;Return the canonical path of the specified filename, eliminating any
+symbolic links encountered in the path.&quot;&quot;&quot;
+    if isabs(filename):
+        bits = ['/'] + filename.split('/')[1:]
+    else:
+        bits = [''] + filename.split('/')
+
+    for i in range(2, len(bits)+1):
+        component = join(*bits[0:i])
+        # Resolve symbolic links.
+        if islink(component):
+            resolved = _resolve_link(component)
+            if resolved is None:
+                # Infinite loop -- return original component + rest of the path
+                return abspath(join(*([component] + bits[i:])))
+            else:
+                newpath = join(*([resolved] + bits[i:]))
+                return realpath(newpath)
+
+    return abspath(filename)
+
+
+def _resolve_link(path):
+    &quot;&quot;&quot;Internal helper function.  Takes a path and follows symlinks
+    until we either arrive at something that isn't a symlink, or
+    encounter a path we've seen before (meaning that there's a loop).
+    &quot;&quot;&quot;
+    paths_seen = []
+    while islink(path):
+        if path in paths_seen:
+            # Already seen this path, so we must have a symlink loop
+            return None
+        paths_seen.append(path)
+        # Resolve where the link points to
+        resolved = os.readlink(path)
+        if not isabs(resolved):
+            dir = dirname(path)
+            path = normpath(join(dir, resolved))
+        else:
+            path = normpath(resolved)
+    return path
+
+supports_unicode_filenames = False

Added: trunk/Lobby/TASClient/Python/engine/re.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/re.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/re.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,323 @@
+#
+# Secret Labs' Regular Expression Engine
+#
+# re-compatible interface for the sre matching engine
+#
+# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
+#
+# This version of the SRE library can be redistributed under CNRI's
+# Python 1.6 license.  For any other use, please contact Secret Labs
+# AB (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">info at pythonware.com</A>).
+#
+# Portions of this engine have been developed in cooperation with
+# CNRI.  Hewlett-Packard provided funding for 1.6 integration and
+# other compatibility work.
+#
+
+r&quot;&quot;&quot;Support for regular expressions (RE).
+
+This module provides regular expression matching operations similar to
+those found in Perl.  It supports both 8-bit and Unicode strings; both
+the pattern and the strings being processed can contain null bytes and
+characters outside the US ASCII range.
+
+Regular expressions can contain both special and ordinary characters.
+Most ordinary characters, like &quot;A&quot;, &quot;a&quot;, or &quot;0&quot;, are the simplest
+regular expressions; they simply match themselves.  You can
+concatenate ordinary characters, so last matches the string 'last'.
+
+The special characters are:
+    &quot;.&quot;      Matches any character except a newline.
+    &quot;^&quot;      Matches the start of the string.
+    &quot;$&quot;      Matches the end of the string or just before the newline at
+             the end of the string.
+    &quot;*&quot;      Matches 0 or more (greedy) repetitions of the preceding RE.
+             Greedy means that it will match as many repetitions as possible.
+    &quot;+&quot;      Matches 1 or more (greedy) repetitions of the preceding RE.
+    &quot;?&quot;      Matches 0 or 1 (greedy) of the preceding RE.
+    *?,+?,?? Non-greedy versions of the previous three special characters.
+    {m,n}    Matches from m to n repetitions of the preceding RE.
+    {m,n}?   Non-greedy version of the above.
+    &quot;\\&quot;     Either escapes special characters or signals a special sequence.
+    []       Indicates a set of characters.
+             A &quot;^&quot; as the first character indicates a complementing set.
+    &quot;|&quot;      A|B, creates an RE that will match either A or B.
+    (...)    Matches the RE inside the parentheses.
+             The contents can be retrieved or matched later in the string.
+    (?iLmsux) Set the I, L, M, S, U, or X flag for the RE (see below).
+    (?:...)  Non-grouping version of regular parentheses.
+    (?P&lt;name&gt;...) The substring matched by the group is accessible by name.
+    (?P=name)     Matches the text matched earlier by the group named name.
+    (?#...)  A comment; ignored.
+    (?=...)  Matches if ... matches next, but doesn't consume the string.
+    (?!...)  Matches if ... doesn't match next.
+    (?&lt;=...) Matches if preceded by ... (must be fixed length).
+    (?&lt;!...) Matches if not preceded by ... (must be fixed length).
+    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
+                       the (optional) no pattern otherwise.
+
+The special sequences consist of &quot;\\&quot; and a character from the list
+below.  If the ordinary character is not on the list, then the
+resulting RE will match the second character.
+    \number  Matches the contents of the group of the same number.
+    \A       Matches only at the start of the string.
+    \Z       Matches only at the end of the string.
+    \b       Matches the empty string, but only at the start or end of a word.
+    \B       Matches the empty string, but not at the start or end of a word.
+    \d       Matches any decimal digit; equivalent to the set [0-9].
+    \D       Matches any non-digit character; equivalent to the set [^0-9].
+    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v].
+    \S       Matches any non-whitespace character; equiv. to [^ \t\n\r\f\v].
+    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_].
+             With LOCALE, it will match the set [0-9_] plus characters defined
+             as letters for the current locale.
+    \W       Matches the complement of \w.
+    \\       Matches a literal backslash.
+
+This module exports the following functions:
+    match    Match a regular expression pattern to the beginning of a string.
+    search   Search a string for the presence of a pattern.
+    sub      Substitute occurrences of a pattern found in a string.
+    subn     Same as sub, but also return the number of substitutions made.
+    split    Split a string by the occurrences of a pattern.
+    findall  Find all occurrences of a pattern in a string.
+    finditer Return an iterator yielding a match object for each match.
+    compile  Compile a pattern into a RegexObject.
+    purge    Clear the regular expression cache.
+    escape   Backslash all non-alphanumerics in a string.
+
+Some of the functions in this module takes flags as optional parameters:
+    I  IGNORECASE  Perform case-insensitive matching.
+    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
+    M  MULTILINE   &quot;^&quot; matches the beginning of lines (after a newline)
+                   as well as the string.
+                   &quot;$&quot; matches the end of lines (before a newline) as well
+                   as the end of the string.
+    S  DOTALL      &quot;.&quot; matches any character at all, including the newline.
+    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
+    U  UNICODE     Make \w, \W, \b, \B, dependent on the Unicode locale.
+
+This module also defines an exception 'error'.
+
+&quot;&quot;&quot;
+
+import sys
+import sre_compile
+import sre_parse
+
+# public symbols
+__all__ = [ &quot;match&quot;, &quot;search&quot;, &quot;sub&quot;, &quot;subn&quot;, &quot;split&quot;, &quot;findall&quot;,
+    &quot;compile&quot;, &quot;purge&quot;, &quot;template&quot;, &quot;escape&quot;, &quot;I&quot;, &quot;L&quot;, &quot;M&quot;, &quot;S&quot;, &quot;X&quot;,
+    &quot;U&quot;, &quot;IGNORECASE&quot;, &quot;LOCALE&quot;, &quot;MULTILINE&quot;, &quot;DOTALL&quot;, &quot;VERBOSE&quot;,
+    &quot;UNICODE&quot;, &quot;error&quot; ]
+
+__version__ = &quot;2.2.1&quot;
+
+# flags
+I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE # ignore case
+L = LOCALE = sre_compile.SRE_FLAG_LOCALE # assume current 8-bit locale
+U = UNICODE = sre_compile.SRE_FLAG_UNICODE # assume unicode locale
+M = MULTILINE = sre_compile.SRE_FLAG_MULTILINE # make anchors look for newline
+S = DOTALL = sre_compile.SRE_FLAG_DOTALL # make dot match newline
+X = VERBOSE = sre_compile.SRE_FLAG_VERBOSE # ignore whitespace and comments
+
+# sre extensions (experimental, don't rely on these)
+T = TEMPLATE = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking
+DEBUG = sre_compile.SRE_FLAG_DEBUG # dump pattern after compilation
+
+# sre exception
+error = sre_compile.error
+
+# --------------------------------------------------------------------
+# public interface
+
+def match(pattern, string, flags=0):
+    &quot;&quot;&quot;Try to apply the pattern at the start of the string, returning
+    a match object, or None if no match was found.&quot;&quot;&quot;
+    return _compile(pattern, flags).match(string)
+
+def search(pattern, string, flags=0):
+    &quot;&quot;&quot;Scan through string looking for a match to the pattern, returning
+    a match object, or None if no match was found.&quot;&quot;&quot;
+    return _compile(pattern, flags).search(string)
+
+def sub(pattern, repl, string, count=0):
+    &quot;&quot;&quot;Return the string obtained by replacing the leftmost
+    non-overlapping occurrences of the pattern in string by the
+    replacement repl.  repl can be either a string or a callable;
+    if a callable, it's passed the match object and must return
+    a replacement string to be used.&quot;&quot;&quot;
+    return _compile(pattern, 0).sub(repl, string, count)
+
+def subn(pattern, repl, string, count=0):
+    &quot;&quot;&quot;Return a 2-tuple containing (new_string, number).
+    new_string is the string obtained by replacing the leftmost
+    non-overlapping occurrences of the pattern in the source
+    string by the replacement repl.  number is the number of
+    substitutions that were made. repl can be either a string or a
+    callable; if a callable, it's passed the match object and must
+    return a replacement string to be used.&quot;&quot;&quot;
+    return _compile(pattern, 0).subn(repl, string, count)
+
+def split(pattern, string, maxsplit=0):
+    &quot;&quot;&quot;Split the source string by the occurrences of the pattern,
+    returning a list containing the resulting substrings.&quot;&quot;&quot;
+    return _compile(pattern, 0).split(string, maxsplit)
+
+def findall(pattern, string, flags=0):
+    &quot;&quot;&quot;Return a list of all non-overlapping matches in the string.
+
+    If one or more groups are present in the pattern, return a
+    list of groups; this will be a list of tuples if the pattern
+    has more than one group.
+
+    Empty matches are included in the result.&quot;&quot;&quot;
+    return _compile(pattern, flags).findall(string)
+
+if sys.hexversion &gt;= 0x02020000:
+    __all__.append(&quot;finditer&quot;)
+    def finditer(pattern, string, flags=0):
+        &quot;&quot;&quot;Return an iterator over all non-overlapping matches in the
+        string.  For each match, the iterator returns a match object.
+
+        Empty matches are included in the result.&quot;&quot;&quot;
+        return _compile(pattern, flags).finditer(string)
+
+def compile(pattern, flags=0):
+    &quot;Compile a regular expression pattern, returning a pattern object.&quot;
+    return _compile(pattern, flags)
+
+def purge():
+    &quot;Clear the regular expression cache&quot;
+    _cache.clear()
+    _cache_repl.clear()
+
+def template(pattern, flags=0):
+    &quot;Compile a template pattern, returning a pattern object&quot;
+    return _compile(pattern, flags|T)
+
+_alphanum = {}
+for c in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890':
+    _alphanum[c] = 1
+del c
+
+def escape(pattern):
+    &quot;Escape all non-alphanumeric characters in pattern.&quot;
+    s = list(pattern)
+    alphanum = _alphanum
+    for i in range(len(pattern)):
+        c = pattern[i]
+        if c not in alphanum:
+            if c == &quot;\000&quot;:
+                s[i] = &quot;\\000&quot;
+            else:
+                s[i] = &quot;\\&quot; + c
+    return pattern[:0].join(s)
+
+# --------------------------------------------------------------------
+# internals
+
+_cache = {}
+_cache_repl = {}
+
+_pattern_type = type(sre_compile.compile(&quot;&quot;, 0))
+
+_MAXCACHE = 100
+
+def _compile(*key):
+    # internal: compile pattern
+    cachekey = (type(key[0]),) + key
+    p = _cache.get(cachekey)
+    if p is not None:
+        return p
+    pattern, flags = key
+    if isinstance(pattern, _pattern_type):
+        return pattern
+    if not sre_compile.isstring(pattern):
+        raise TypeError, &quot;first argument must be string or compiled pattern&quot;
+    try:
+        p = sre_compile.compile(pattern, flags)
+    except error, v:
+        raise error, v # invalid expression
+    if len(_cache) &gt;= _MAXCACHE:
+        _cache.clear()
+    _cache[cachekey] = p
+    return p
+
+def _compile_repl(*key):
+    # internal: compile replacement pattern
+    p = _cache_repl.get(key)
+    if p is not None:
+        return p
+    repl, pattern = key
+    try:
+        p = sre_parse.parse_template(repl, pattern)
+    except error, v:
+        raise error, v # invalid expression
+    if len(_cache_repl) &gt;= _MAXCACHE:
+        _cache_repl.clear()
+    _cache_repl[key] = p
+    return p
+
+def _expand(pattern, match, template):
+    # internal: match.expand implementation hook
+    template = sre_parse.parse_template(template, pattern)
+    return sre_parse.expand_template(template, match)
+
+def _subx(pattern, template):
+    # internal: pattern.sub/subn implementation helper
+    template = _compile_repl(template, pattern)
+    if not template[0] and len(template[1]) == 1:
+        # literal replacement
+        return template[1][0]
+    def filter(match, template=template):
+        return sre_parse.expand_template(template, match)
+    return filter
+
+# register myself for pickling
+
+import copy_reg
+
+def _pickle(p):
+    return _compile, (p.pattern, p.flags)
+
+copy_reg.pickle(_pattern_type, _pickle, _compile)
+
+# --------------------------------------------------------------------
+# experimental stuff (see python-dev discussions for details)
+
+class Scanner:
+    def __init__(self, lexicon, flags=0):
+        from sre_constants import BRANCH, SUBPATTERN
+        self.lexicon = lexicon
+        # combine phrases into a compound pattern
+        p = []
+        s = sre_parse.Pattern()
+        s.flags = flags
+        for phrase, action in lexicon:
+            p.append(sre_parse.SubPattern(s, [
+                (SUBPATTERN, (len(p)+1, sre_parse.parse(phrase, flags))),
+                ]))
+        s.groups = len(p)+1
+        p = sre_parse.SubPattern(s, [(BRANCH, (None, p))])
+        self.scanner = sre_compile.compile(p)
+    def scan(self, string):
+        result = []
+        append = result.append
+        match = self.scanner.scanner(string).match
+        i = 0
+        while 1:
+            m = match()
+            if not m:
+                break
+            j = m.end()
+            if i == j:
+                break
+            action = self.lexicon[m.lastindex-1][1]
+            if callable(action):
+                self.match = m
+                action = action(self, m.group())
+            if action is not None:
+                append(action)
+            i = j
+        return result, string[i:]

Added: trunk/Lobby/TASClient/Python/engine/sre_compile.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/sre_compile.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/sre_compile.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,531 @@
+#
+# Secret Labs' Regular Expression Engine
+#
+# convert template to internal format
+#
+# Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.
+#
+# See the sre.py file for information on usage and redistribution.
+#
+
+&quot;&quot;&quot;Internal support module for sre&quot;&quot;&quot;
+
+import _sre, sys
+
+from sre_constants import *
+
+assert _sre.MAGIC == MAGIC, &quot;SRE module mismatch&quot;
+
+if _sre.CODESIZE == 2:
+    MAXCODE = 65535
+else:
+    MAXCODE = 0xFFFFFFFFL
+
+def _identityfunction(x):
+    return x
+
+def set(seq):
+    s = {}
+    for elem in seq:
+        s[elem] = 1
+    return s
+
+_LITERAL_CODES = set([LITERAL, NOT_LITERAL])
+_REPEATING_CODES = set([REPEAT, MIN_REPEAT, MAX_REPEAT])
+_SUCCESS_CODES = set([SUCCESS, FAILURE])
+_ASSERT_CODES = set([ASSERT, ASSERT_NOT])
+
+def _compile(code, pattern, flags):
+    # internal: compile a (sub)pattern
+    emit = code.append
+    _len = len
+    LITERAL_CODES = _LITERAL_CODES
+    REPEATING_CODES = _REPEATING_CODES
+    SUCCESS_CODES = _SUCCESS_CODES
+    ASSERT_CODES = _ASSERT_CODES
+    for op, av in pattern:
+        if op in LITERAL_CODES:
+            if flags &amp; SRE_FLAG_IGNORECASE:
+                emit(OPCODES[OP_IGNORE[op]])
+                emit(_sre.getlower(av, flags))
+            else:
+                emit(OPCODES[op])
+                emit(av)
+        elif op is IN:
+            if flags &amp; SRE_FLAG_IGNORECASE:
+                emit(OPCODES[OP_IGNORE[op]])
+                def fixup(literal, flags=flags):
+                    return _sre.getlower(literal, flags)
+            else:
+                emit(OPCODES[op])
+                fixup = _identityfunction
+            skip = _len(code); emit(0)
+            _compile_charset(av, flags, code, fixup)
+            code[skip] = _len(code) - skip
+        elif op is ANY:
+            if flags &amp; SRE_FLAG_DOTALL:
+                emit(OPCODES[ANY_ALL])
+            else:
+                emit(OPCODES[ANY])
+        elif op in REPEATING_CODES:
+            if flags &amp; SRE_FLAG_TEMPLATE:
+                raise error, &quot;internal: unsupported template operator&quot;
+                emit(OPCODES[REPEAT])
+                skip = _len(code); emit(0)
+                emit(av[0])
+                emit(av[1])
+                _compile(code, av[2], flags)
+                emit(OPCODES[SUCCESS])
+                code[skip] = _len(code) - skip
+            elif _simple(av) and op is not REPEAT:
+                if op is MAX_REPEAT:
+                    emit(OPCODES[REPEAT_ONE])
+                else:
+                    emit(OPCODES[MIN_REPEAT_ONE])
+                skip = _len(code); emit(0)
+                emit(av[0])
+                emit(av[1])
+                _compile(code, av[2], flags)
+                emit(OPCODES[SUCCESS])
+                code[skip] = _len(code) - skip
+            else:
+                emit(OPCODES[REPEAT])
+                skip = _len(code); emit(0)
+                emit(av[0])
+                emit(av[1])
+                _compile(code, av[2], flags)
+                code[skip] = _len(code) - skip
+                if op is MAX_REPEAT:
+                    emit(OPCODES[MAX_UNTIL])
+                else:
+                    emit(OPCODES[MIN_UNTIL])
+        elif op is SUBPATTERN:
+            if av[0]:
+                emit(OPCODES[MARK])
+                emit((av[0]-1)*2)
+            # _compile_info(code, av[1], flags)
+            _compile(code, av[1], flags)
+            if av[0]:
+                emit(OPCODES[MARK])
+                emit((av[0]-1)*2+1)
+        elif op in SUCCESS_CODES:
+            emit(OPCODES[op])
+        elif op in ASSERT_CODES:
+            emit(OPCODES[op])
+            skip = _len(code); emit(0)
+            if av[0] &gt;= 0:
+                emit(0) # look ahead
+            else:
+                lo, hi = av[1].getwidth()
+                if lo != hi:
+                    raise error, &quot;look-behind requires fixed-width pattern&quot;
+                emit(lo) # look behind
+            _compile(code, av[1], flags)
+            emit(OPCODES[SUCCESS])
+            code[skip] = _len(code) - skip
+        elif op is CALL:
+            emit(OPCODES[op])
+            skip = _len(code); emit(0)
+            _compile(code, av, flags)
+            emit(OPCODES[SUCCESS])
+            code[skip] = _len(code) - skip
+        elif op is AT:
+            emit(OPCODES[op])
+            if flags &amp; SRE_FLAG_MULTILINE:
+                av = AT_MULTILINE.get(av, av)
+            if flags &amp; SRE_FLAG_LOCALE:
+                av = AT_LOCALE.get(av, av)
+            elif flags &amp; SRE_FLAG_UNICODE:
+                av = AT_UNICODE.get(av, av)
+            emit(ATCODES[av])
+        elif op is BRANCH:
+            emit(OPCODES[op])
+            tail = []
+            tailappend = tail.append
+            for av in av[1]:
+                skip = _len(code); emit(0)
+                # _compile_info(code, av, flags)
+                _compile(code, av, flags)
+                emit(OPCODES[JUMP])
+                tailappend(_len(code)); emit(0)
+                code[skip] = _len(code) - skip
+            emit(0) # end of branch
+            for tail in tail:
+                code[tail] = _len(code) - tail
+        elif op is CATEGORY:
+            emit(OPCODES[op])
+            if flags &amp; SRE_FLAG_LOCALE:
+                av = CH_LOCALE[av]
+            elif flags &amp; SRE_FLAG_UNICODE:
+                av = CH_UNICODE[av]
+            emit(CHCODES[av])
+        elif op is GROUPREF:
+            if flags &amp; SRE_FLAG_IGNORECASE:
+                emit(OPCODES[OP_IGNORE[op]])
+            else:
+                emit(OPCODES[op])
+            emit(av-1)
+        elif op is GROUPREF_EXISTS:
+            emit(OPCODES[op])
+            emit(av[0]-1)
+            skipyes = _len(code); emit(0)
+            _compile(code, av[1], flags)
+            if av[2]:
+                emit(OPCODES[JUMP])
+                skipno = _len(code); emit(0)
+                code[skipyes] = _len(code) - skipyes + 1
+                _compile(code, av[2], flags)
+                code[skipno] = _len(code) - skipno
+            else:
+                code[skipyes] = _len(code) - skipyes + 1
+        else:
+            raise ValueError, (&quot;unsupported operand type&quot;, op)
+
+def _compile_charset(charset, flags, code, fixup=None):
+    # compile charset subprogram
+    emit = code.append
+    if fixup is None:
+        fixup = _identityfunction
+    for op, av in _optimize_charset(charset, fixup):
+        emit(OPCODES[op])
+        if op is NEGATE:
+            pass
+        elif op is LITERAL:
+            emit(fixup(av))
+        elif op is RANGE:
+            emit(fixup(av[0]))
+            emit(fixup(av[1]))
+        elif op is CHARSET:
+            code.extend(av)
+        elif op is BIGCHARSET:
+            code.extend(av)
+        elif op is CATEGORY:
+            if flags &amp; SRE_FLAG_LOCALE:
+                emit(CHCODES[CH_LOCALE[av]])
+            elif flags &amp; SRE_FLAG_UNICODE:
+                emit(CHCODES[CH_UNICODE[av]])
+            else:
+                emit(CHCODES[av])
+        else:
+            raise error, &quot;internal: unsupported set operator&quot;
+    emit(OPCODES[FAILURE])
+
+def _optimize_charset(charset, fixup):
+    # internal: optimize character set
+    out = []
+    outappend = out.append
+    charmap = [0]*256
+    try:
+        for op, av in charset:
+            if op is NEGATE:
+                outappend((op, av))
+            elif op is LITERAL:
+                charmap[fixup(av)] = 1
+            elif op is RANGE:
+                for i in range(fixup(av[0]), fixup(av[1])+1):
+                    charmap[i] = 1
+            elif op is CATEGORY:
+                # XXX: could append to charmap tail
+                return charset # cannot compress
+    except IndexError:
+        # character set contains unicode characters
+        return _optimize_unicode(charset, fixup)
+    # compress character map
+    i = p = n = 0
+    runs = []
+    runsappend = runs.append
+    for c in charmap:
+        if c:
+            if n == 0:
+                p = i
+            n = n + 1
+        elif n:
+            runsappend((p, n))
+            n = 0
+        i = i + 1
+    if n:
+        runsappend((p, n))
+    if len(runs) &lt;= 2:
+        # use literal/range
+        for p, n in runs:
+            if n == 1:
+                outappend((LITERAL, p))
+            else:
+                outappend((RANGE, (p, p+n-1)))
+        if len(out) &lt; len(charset):
+            return out
+    else:
+        # use bitmap
+        data = _mk_bitmap(charmap)
+        outappend((CHARSET, data))
+        return out
+    return charset
+
+def _mk_bitmap(bits):
+    data = []
+    dataappend = data.append
+    if _sre.CODESIZE == 2:
+        start = (1, 0)
+    else:
+        start = (1L, 0L)
+    m, v = start
+    for c in bits:
+        if c:
+            v = v + m
+        m = m + m
+        if m &gt; MAXCODE:
+            dataappend(v)
+            m, v = start
+    return data
+
+# To represent a big charset, first a bitmap of all characters in the
+# set is constructed. Then, this bitmap is sliced into chunks of 256
+# characters, duplicate chunks are eliminated, and each chunk is
+# given a number. In the compiled expression, the charset is
+# represented by a 16-bit word sequence, consisting of one word for
+# the number of different chunks, a sequence of 256 bytes (128 words)
+# of chunk numbers indexed by their original chunk position, and a
+# sequence of chunks (16 words each).
+
+# Compression is normally good: in a typical charset, large ranges of
+# Unicode will be either completely excluded (e.g. if only cyrillic
+# letters are to be matched), or completely included (e.g. if large
+# subranges of Kanji match). These ranges will be represented by
+# chunks of all one-bits or all zero-bits.
+
+# Matching can be also done efficiently: the more significant byte of
+# the Unicode character is an index into the chunk number, and the
+# less significant byte is a bit index in the chunk (just like the
+# CHARSET matching).
+
+# In UCS-4 mode, the BIGCHARSET opcode still supports only subsets
+# of the basic multilingual plane; an efficient representation
+# for all of UTF-16 has not yet been developed. This means,
+# in particular, that negated charsets cannot be represented as
+# bigcharsets.
+
+def _optimize_unicode(charset, fixup):
+    try:
+        import array
+    except ImportError:
+        return charset
+    charmap = [0]*65536
+    negate = 0
+    try:
+        for op, av in charset:
+            if op is NEGATE:
+                negate = 1
+            elif op is LITERAL:
+                charmap[fixup(av)] = 1
+            elif op is RANGE:
+                for i in xrange(fixup(av[0]), fixup(av[1])+1):
+                    charmap[i] = 1
+            elif op is CATEGORY:
+                # XXX: could expand category
+                return charset # cannot compress
+    except IndexError:
+        # non-BMP characters
+        return charset
+    if negate:
+        if sys.maxunicode != 65535:
+            # XXX: negation does not work with big charsets
+            return charset
+        for i in xrange(65536):
+            charmap[i] = not charmap[i]
+    comps = {}
+    mapping = [0]*256
+    block = 0
+    data = []
+    for i in xrange(256):
+        chunk = tuple(charmap[i*256:(i+1)*256])
+        new = comps.setdefault(chunk, block)
+        mapping[i] = new
+        if new == block:
+            block = block + 1
+            data = data + _mk_bitmap(chunk)
+    header = [block]
+    if _sre.CODESIZE == 2:
+        code = 'H'
+    else:
+        code = 'I'
+    # Convert block indices to byte array of 256 bytes
+    mapping = array.array('b', mapping).tostring()
+    # Convert byte array to word array
+    mapping = array.array(code, mapping)
+    assert mapping.itemsize == _sre.CODESIZE
+    header = header + mapping.tolist()
+    data[0:0] = header
+    return [(BIGCHARSET, data)]
+
+def _simple(av):
+    # check if av is a &quot;simple&quot; operator
+    lo, hi = av[2].getwidth()
+    if lo == 0 and hi == MAXREPEAT:
+        raise error, &quot;nothing to repeat&quot;
+    return lo == hi == 1 and av[2][0][0] != SUBPATTERN
+
+def _compile_info(code, pattern, flags):
+    # internal: compile an info block.  in the current version,
+    # this contains min/max pattern width, and an optional literal
+    # prefix or a character map
+    lo, hi = pattern.getwidth()
+    if lo == 0:
+        return # not worth it
+    # look for a literal prefix
+    prefix = []
+    prefixappend = prefix.append
+    prefix_skip = 0
+    charset = [] # not used
+    charsetappend = charset.append
+    if not (flags &amp; SRE_FLAG_IGNORECASE):
+        # look for literal prefix
+        for op, av in pattern.data:
+            if op is LITERAL:
+                if len(prefix) == prefix_skip:
+                    prefix_skip = prefix_skip + 1
+                prefixappend(av)
+            elif op is SUBPATTERN and len(av[1]) == 1:
+                op, av = av[1][0]
+                if op is LITERAL:
+                    prefixappend(av)
+                else:
+                    break
+            else:
+                break
+        # if no prefix, look for charset prefix
+        if not prefix and pattern.data:
+            op, av = pattern.data[0]
+            if op is SUBPATTERN and av[1]:
+                op, av = av[1][0]
+                if op is LITERAL:
+                    charsetappend((op, av))
+                elif op is BRANCH:
+                    c = []
+                    cappend = c.append
+                    for p in av[1]:
+                        if not p:
+                            break
+                        op, av = p[0]
+                        if op is LITERAL:
+                            cappend((op, av))
+                        else:
+                            break
+                    else:
+                        charset = c
+            elif op is BRANCH:
+                c = []
+                cappend = c.append
+                for p in av[1]:
+                    if not p:
+                        break
+                    op, av = p[0]
+                    if op is LITERAL:
+                        cappend((op, av))
+                    else:
+                        break
+                else:
+                    charset = c
+            elif op is IN:
+                charset = av
+##     if prefix:
+##         print &quot;*** PREFIX&quot;, prefix, prefix_skip
+##     if charset:
+##         print &quot;*** CHARSET&quot;, charset
+    # add an info block
+    emit = code.append
+    emit(OPCODES[INFO])
+    skip = len(code); emit(0)
+    # literal flag
+    mask = 0
+    if prefix:
+        mask = SRE_INFO_PREFIX
+        if len(prefix) == prefix_skip == len(pattern.data):
+            mask = mask + SRE_INFO_LITERAL
+    elif charset:
+        mask = mask + SRE_INFO_CHARSET
+    emit(mask)
+    # pattern length
+    if lo &lt; MAXCODE:
+        emit(lo)
+    else:
+        emit(MAXCODE)
+        prefix = prefix[:MAXCODE]
+    if hi &lt; MAXCODE:
+        emit(hi)
+    else:
+        emit(0)
+    # add literal prefix
+    if prefix:
+        emit(len(prefix)) # length
+        emit(prefix_skip) # skip
+        code.extend(prefix)
+        # generate overlap table
+        table = [-1] + ([0]*len(prefix))
+        for i in xrange(len(prefix)):
+            table[i+1] = table[i]+1
+            while table[i+1] &gt; 0 and prefix[i] != prefix[table[i+1]-1]:
+                table[i+1] = table[table[i+1]-1]+1
+        code.extend(table[1:]) # don't store first entry
+    elif charset:
+        _compile_charset(charset, flags, code)
+    code[skip] = len(code) - skip
+
+try:
+    unicode
+except NameError:
+    STRING_TYPES = (type(&quot;&quot;),)
+else:
+    STRING_TYPES = (type(&quot;&quot;), type(unicode(&quot;&quot;)))
+
+def isstring(obj):
+    for tp in STRING_TYPES:
+        if isinstance(obj, tp):
+            return 1
+    return 0
+
+def _code(p, flags):
+
+    flags = p.pattern.flags | flags
+    code = []
+
+    # compile info block
+    _compile_info(code, p, flags)
+
+    # compile the pattern
+    _compile(code, p.data, flags)
+
+    code.append(OPCODES[SUCCESS])
+
+    return code
+
+def compile(p, flags=0):
+    # internal: convert pattern list to internal format
+
+    if isstring(p):
+        import sre_parse
+        pattern = p
+        p = sre_parse.parse(p, flags)
+    else:
+        pattern = None
+
+    code = _code(p, flags)
+
+    # print code
+
+    # XXX: &lt;fl&gt; get rid of this limitation!
+    if p.pattern.groups &gt; 100:
+        raise AssertionError(
+            &quot;sorry, but this version only supports 100 named groups&quot;
+            )
+
+    # map in either direction
+    groupindex = p.pattern.groupdict
+    indexgroup = [None] * p.pattern.groups
+    for k, i in groupindex.items():
+        indexgroup[i] = k
+
+    return _sre.compile(
+        pattern, flags | p.pattern.flags, code,
+        p.pattern.groups-1,
+        groupindex, indexgroup
+        )

Added: trunk/Lobby/TASClient/Python/engine/sre_constants.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/sre_constants.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/sre_constants.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,261 @@
+#
+# Secret Labs' Regular Expression Engine
+#
+# various symbols used by the regular expression engine.
+# run this script to update the _sre include files!
+#
+# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
+#
+# See the sre.py file for information on usage and redistribution.
+#
+
+&quot;&quot;&quot;Internal support module for sre&quot;&quot;&quot;
+
+# update when constants are added or removed
+
+MAGIC = 20031017
+
+# max code word in this release
+
+MAXREPEAT = 65535
+
+# SRE standard exception (access as sre.error)
+# should this really be here?
+
+class error(Exception):
+    pass
+
+# operators
+
+FAILURE = &quot;failure&quot;
+SUCCESS = &quot;success&quot;
+
+ANY = &quot;any&quot;
+ANY_ALL = &quot;any_all&quot;
+ASSERT = &quot;assert&quot;
+ASSERT_NOT = &quot;assert_not&quot;
+AT = &quot;at&quot;
+BIGCHARSET = &quot;bigcharset&quot;
+BRANCH = &quot;branch&quot;
+CALL = &quot;call&quot;
+CATEGORY = &quot;category&quot;
+CHARSET = &quot;charset&quot;
+GROUPREF = &quot;groupref&quot;
+GROUPREF_IGNORE = &quot;groupref_ignore&quot;
+GROUPREF_EXISTS = &quot;groupref_exists&quot;
+IN = &quot;in&quot;
+IN_IGNORE = &quot;in_ignore&quot;
+INFO = &quot;info&quot;
+JUMP = &quot;jump&quot;
+LITERAL = &quot;literal&quot;
+LITERAL_IGNORE = &quot;literal_ignore&quot;
+MARK = &quot;mark&quot;
+MAX_REPEAT = &quot;max_repeat&quot;
+MAX_UNTIL = &quot;max_until&quot;
+MIN_REPEAT = &quot;min_repeat&quot;
+MIN_UNTIL = &quot;min_until&quot;
+NEGATE = &quot;negate&quot;
+NOT_LITERAL = &quot;not_literal&quot;
+NOT_LITERAL_IGNORE = &quot;not_literal_ignore&quot;
+RANGE = &quot;range&quot;
+REPEAT = &quot;repeat&quot;
+REPEAT_ONE = &quot;repeat_one&quot;
+SUBPATTERN = &quot;subpattern&quot;
+MIN_REPEAT_ONE = &quot;min_repeat_one&quot;
+
+# positions
+AT_BEGINNING = &quot;at_beginning&quot;
+AT_BEGINNING_LINE = &quot;at_beginning_line&quot;
+AT_BEGINNING_STRING = &quot;at_beginning_string&quot;
+AT_BOUNDARY = &quot;at_boundary&quot;
+AT_NON_BOUNDARY = &quot;at_non_boundary&quot;
+AT_END = &quot;at_end&quot;
+AT_END_LINE = &quot;at_end_line&quot;
+AT_END_STRING = &quot;at_end_string&quot;
+AT_LOC_BOUNDARY = &quot;at_loc_boundary&quot;
+AT_LOC_NON_BOUNDARY = &quot;at_loc_non_boundary&quot;
+AT_UNI_BOUNDARY = &quot;at_uni_boundary&quot;
+AT_UNI_NON_BOUNDARY = &quot;at_uni_non_boundary&quot;
+
+# categories
+CATEGORY_DIGIT = &quot;category_digit&quot;
+CATEGORY_NOT_DIGIT = &quot;category_not_digit&quot;
+CATEGORY_SPACE = &quot;category_space&quot;
+CATEGORY_NOT_SPACE = &quot;category_not_space&quot;
+CATEGORY_WORD = &quot;category_word&quot;
+CATEGORY_NOT_WORD = &quot;category_not_word&quot;
+CATEGORY_LINEBREAK = &quot;category_linebreak&quot;
+CATEGORY_NOT_LINEBREAK = &quot;category_not_linebreak&quot;
+CATEGORY_LOC_WORD = &quot;category_loc_word&quot;
+CATEGORY_LOC_NOT_WORD = &quot;category_loc_not_word&quot;
+CATEGORY_UNI_DIGIT = &quot;category_uni_digit&quot;
+CATEGORY_UNI_NOT_DIGIT = &quot;category_uni_not_digit&quot;
+CATEGORY_UNI_SPACE = &quot;category_uni_space&quot;
+CATEGORY_UNI_NOT_SPACE = &quot;category_uni_not_space&quot;
+CATEGORY_UNI_WORD = &quot;category_uni_word&quot;
+CATEGORY_UNI_NOT_WORD = &quot;category_uni_not_word&quot;
+CATEGORY_UNI_LINEBREAK = &quot;category_uni_linebreak&quot;
+CATEGORY_UNI_NOT_LINEBREAK = &quot;category_uni_not_linebreak&quot;
+
+OPCODES = [
+
+    # failure=0 success=1 (just because it looks better that way :-)
+    FAILURE, SUCCESS,
+
+    ANY, ANY_ALL,
+    ASSERT, ASSERT_NOT,
+    AT,
+    BRANCH,
+    CALL,
+    CATEGORY,
+    CHARSET, BIGCHARSET,
+    GROUPREF, GROUPREF_EXISTS, GROUPREF_IGNORE,
+    IN, IN_IGNORE,
+    INFO,
+    JUMP,
+    LITERAL, LITERAL_IGNORE,
+    MARK,
+    MAX_UNTIL,
+    MIN_UNTIL,
+    NOT_LITERAL, NOT_LITERAL_IGNORE,
+    NEGATE,
+    RANGE,
+    REPEAT,
+    REPEAT_ONE,
+    SUBPATTERN,
+    MIN_REPEAT_ONE
+
+]
+
+ATCODES = [
+    AT_BEGINNING, AT_BEGINNING_LINE, AT_BEGINNING_STRING, AT_BOUNDARY,
+    AT_NON_BOUNDARY, AT_END, AT_END_LINE, AT_END_STRING,
+    AT_LOC_BOUNDARY, AT_LOC_NON_BOUNDARY, AT_UNI_BOUNDARY,
+    AT_UNI_NON_BOUNDARY
+]
+
+CHCODES = [
+    CATEGORY_DIGIT, CATEGORY_NOT_DIGIT, CATEGORY_SPACE,
+    CATEGORY_NOT_SPACE, CATEGORY_WORD, CATEGORY_NOT_WORD,
+    CATEGORY_LINEBREAK, CATEGORY_NOT_LINEBREAK, CATEGORY_LOC_WORD,
+    CATEGORY_LOC_NOT_WORD, CATEGORY_UNI_DIGIT, CATEGORY_UNI_NOT_DIGIT,
+    CATEGORY_UNI_SPACE, CATEGORY_UNI_NOT_SPACE, CATEGORY_UNI_WORD,
+    CATEGORY_UNI_NOT_WORD, CATEGORY_UNI_LINEBREAK,
+    CATEGORY_UNI_NOT_LINEBREAK
+]
+
+def makedict(list):
+    d = {}
+    i = 0
+    for item in list:
+        d[item] = i
+        i = i + 1
+    return d
+
+OPCODES = makedict(OPCODES)
+ATCODES = makedict(ATCODES)
+CHCODES = makedict(CHCODES)
+
+# replacement operations for &quot;ignore case&quot; mode
+OP_IGNORE = {
+    GROUPREF: GROUPREF_IGNORE,
+    IN: IN_IGNORE,
+    LITERAL: LITERAL_IGNORE,
+    NOT_LITERAL: NOT_LITERAL_IGNORE
+}
+
+AT_MULTILINE = {
+    AT_BEGINNING: AT_BEGINNING_LINE,
+    AT_END: AT_END_LINE
+}
+
+AT_LOCALE = {
+    AT_BOUNDARY: AT_LOC_BOUNDARY,
+    AT_NON_BOUNDARY: AT_LOC_NON_BOUNDARY
+}
+
+AT_UNICODE = {
+    AT_BOUNDARY: AT_UNI_BOUNDARY,
+    AT_NON_BOUNDARY: AT_UNI_NON_BOUNDARY
+}
+
+CH_LOCALE = {
+    CATEGORY_DIGIT: CATEGORY_DIGIT,
+    CATEGORY_NOT_DIGIT: CATEGORY_NOT_DIGIT,
+    CATEGORY_SPACE: CATEGORY_SPACE,
+    CATEGORY_NOT_SPACE: CATEGORY_NOT_SPACE,
+    CATEGORY_WORD: CATEGORY_LOC_WORD,
+    CATEGORY_NOT_WORD: CATEGORY_LOC_NOT_WORD,
+    CATEGORY_LINEBREAK: CATEGORY_LINEBREAK,
+    CATEGORY_NOT_LINEBREAK: CATEGORY_NOT_LINEBREAK
+}
+
+CH_UNICODE = {
+    CATEGORY_DIGIT: CATEGORY_UNI_DIGIT,
+    CATEGORY_NOT_DIGIT: CATEGORY_UNI_NOT_DIGIT,
+    CATEGORY_SPACE: CATEGORY_UNI_SPACE,
+    CATEGORY_NOT_SPACE: CATEGORY_UNI_NOT_SPACE,
+    CATEGORY_WORD: CATEGORY_UNI_WORD,
+    CATEGORY_NOT_WORD: CATEGORY_UNI_NOT_WORD,
+    CATEGORY_LINEBREAK: CATEGORY_UNI_LINEBREAK,
+    CATEGORY_NOT_LINEBREAK: CATEGORY_UNI_NOT_LINEBREAK
+}
+
+# flags
+SRE_FLAG_TEMPLATE = 1 # template mode (disable backtracking)
+SRE_FLAG_IGNORECASE = 2 # case insensitive
+SRE_FLAG_LOCALE = 4 # honour system locale
+SRE_FLAG_MULTILINE = 8 # treat target as multiline string
+SRE_FLAG_DOTALL = 16 # treat target as a single string
+SRE_FLAG_UNICODE = 32 # use unicode locale
+SRE_FLAG_VERBOSE = 64 # ignore whitespace and comments
+SRE_FLAG_DEBUG = 128 # debugging
+
+# flags for INFO primitive
+SRE_INFO_PREFIX = 1 # has prefix
+SRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)
+SRE_INFO_CHARSET = 4 # pattern starts with character from given set
+
+if __name__ == &quot;__main__&quot;:
+    def dump(f, d, prefix):
+        items = d.items()
+        items.sort(key=lambda a: a[1])
+        for k, v in items:
+            f.write(&quot;#define %s_%s %s\n&quot; % (prefix, k.upper(), v))
+    f = open(&quot;sre_constants.h&quot;, &quot;w&quot;)
+    f.write(&quot;&quot;&quot;\
+/*
+ * Secret Labs' Regular Expression Engine
+ *
+ * regular expression matching engine
+ *
+ * NOTE: This file is generated by sre_constants.py.  If you need
+ * to change anything in here, edit sre_constants.py and run it.
+ *
+ * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.
+ *
+ * See the _sre.c file for information on usage and redistribution.
+ */
+
+&quot;&quot;&quot;)
+
+    f.write(&quot;#define SRE_MAGIC %d\n&quot; % MAGIC)
+
+    dump(f, OPCODES, &quot;SRE_OP&quot;)
+    dump(f, ATCODES, &quot;SRE&quot;)
+    dump(f, CHCODES, &quot;SRE&quot;)
+
+    f.write(&quot;#define SRE_FLAG_TEMPLATE %d\n&quot; % SRE_FLAG_TEMPLATE)
+    f.write(&quot;#define SRE_FLAG_IGNORECASE %d\n&quot; % SRE_FLAG_IGNORECASE)
+    f.write(&quot;#define SRE_FLAG_LOCALE %d\n&quot; % SRE_FLAG_LOCALE)
+    f.write(&quot;#define SRE_FLAG_MULTILINE %d\n&quot; % SRE_FLAG_MULTILINE)
+    f.write(&quot;#define SRE_FLAG_DOTALL %d\n&quot; % SRE_FLAG_DOTALL)
+    f.write(&quot;#define SRE_FLAG_UNICODE %d\n&quot; % SRE_FLAG_UNICODE)
+    f.write(&quot;#define SRE_FLAG_VERBOSE %d\n&quot; % SRE_FLAG_VERBOSE)
+
+    f.write(&quot;#define SRE_INFO_PREFIX %d\n&quot; % SRE_INFO_PREFIX)
+    f.write(&quot;#define SRE_INFO_LITERAL %d\n&quot; % SRE_INFO_LITERAL)
+    f.write(&quot;#define SRE_INFO_CHARSET %d\n&quot; % SRE_INFO_CHARSET)
+
+    f.close()
+    print &quot;done&quot;

Added: trunk/Lobby/TASClient/Python/engine/sre_parse.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/sre_parse.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/sre_parse.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,796 @@
+#
+# Secret Labs' Regular Expression Engine
+#
+# convert re-style regular expression to sre pattern
+#
+# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
+#
+# See the sre.py file for information on usage and redistribution.
+#
+
+&quot;&quot;&quot;Internal support module for sre&quot;&quot;&quot;
+
+# XXX: show string offset and offending character for all errors
+
+import sys
+
+from sre_constants import *
+
+def set(seq):
+    s = {}
+    for elem in seq:
+        s[elem] = 1
+    return s
+
+SPECIAL_CHARS = &quot;.\\[{()*+?^$|&quot;
+REPEAT_CHARS = &quot;*+?{&quot;
+
+DIGITS = set(&quot;0123456789&quot;)
+
+OCTDIGITS = set(&quot;01234567&quot;)
+HEXDIGITS = set(&quot;0123456789abcdefABCDEF&quot;)
+
+WHITESPACE = set(&quot; \t\n\r\v\f&quot;)
+
+ESCAPES = {
+    r&quot;\a&quot;: (LITERAL, ord(&quot;\a&quot;)),
+    r&quot;\b&quot;: (LITERAL, ord(&quot;\b&quot;)),
+    r&quot;\f&quot;: (LITERAL, ord(&quot;\f&quot;)),
+    r&quot;\n&quot;: (LITERAL, ord(&quot;\n&quot;)),
+    r&quot;\r&quot;: (LITERAL, ord(&quot;\r&quot;)),
+    r&quot;\t&quot;: (LITERAL, ord(&quot;\t&quot;)),
+    r&quot;\v&quot;: (LITERAL, ord(&quot;\v&quot;)),
+    r&quot;\\&quot;: (LITERAL, ord(&quot;\\&quot;))
+}
+
+CATEGORIES = {
+    r&quot;\A&quot;: (AT, AT_BEGINNING_STRING), # start of string
+    r&quot;\b&quot;: (AT, AT_BOUNDARY),
+    r&quot;\B&quot;: (AT, AT_NON_BOUNDARY),
+    r&quot;\d&quot;: (IN, [(CATEGORY, CATEGORY_DIGIT)]),
+    r&quot;\D&quot;: (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),
+    r&quot;\s&quot;: (IN, [(CATEGORY, CATEGORY_SPACE)]),
+    r&quot;\S&quot;: (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),
+    r&quot;\w&quot;: (IN, [(CATEGORY, CATEGORY_WORD)]),
+    r&quot;\W&quot;: (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),
+    r&quot;\Z&quot;: (AT, AT_END_STRING), # end of string
+}
+
+FLAGS = {
+    # standard flags
+    &quot;i&quot;: SRE_FLAG_IGNORECASE,
+    &quot;L&quot;: SRE_FLAG_LOCALE,
+    &quot;m&quot;: SRE_FLAG_MULTILINE,
+    &quot;s&quot;: SRE_FLAG_DOTALL,
+    &quot;x&quot;: SRE_FLAG_VERBOSE,
+    # extensions
+    &quot;t&quot;: SRE_FLAG_TEMPLATE,
+    &quot;u&quot;: SRE_FLAG_UNICODE,
+}
+
+class Pattern:
+    # master pattern object.  keeps track of global attributes
+    def __init__(self):
+        self.flags = 0
+        self.open = []
+        self.groups = 1
+        self.groupdict = {}
+    def opengroup(self, name=None):
+        gid = self.groups
+        self.groups = gid + 1
+        if name is not None:
+            ogid = self.groupdict.get(name, None)
+            if ogid is not None:
+                raise error, (&quot;redefinition of group name %s as group %d; &quot;
+                              &quot;was group %d&quot; % (repr(name), gid,  ogid))
+            self.groupdict[name] = gid
+        self.open.append(gid)
+        return gid
+    def closegroup(self, gid):
+        self.open.remove(gid)
+    def checkgroup(self, gid):
+        return gid &lt; self.groups and gid not in self.open
+
+class SubPattern:
+    # a subpattern, in intermediate form
+    def __init__(self, pattern, data=None):
+        self.pattern = pattern
+        if data is None:
+            data = []
+        self.data = data
+        self.width = None
+    def dump(self, level=0):
+        nl = 1
+        seqtypes = type(()), type([])
+        for op, av in self.data:
+            print level*&quot;  &quot; + op,; nl = 0
+            if op == &quot;in&quot;:
+                # member sublanguage
+                print; nl = 1
+                for op, a in av:
+                    print (level+1)*&quot;  &quot; + op, a
+            elif op == &quot;branch&quot;:
+                print; nl = 1
+                i = 0
+                for a in av[1]:
+                    if i &gt; 0:
+                        print level*&quot;  &quot; + &quot;or&quot;
+                    a.dump(level+1); nl = 1
+                    i = i + 1
+            elif type(av) in seqtypes:
+                for a in av:
+                    if isinstance(a, SubPattern):
+                        if not nl: print
+                        a.dump(level+1); nl = 1
+                    else:
+                        print a, ; nl = 0
+            else:
+                print av, ; nl = 0
+            if not nl: print
+    def __repr__(self):
+        return repr(self.data)
+    def __len__(self):
+        return len(self.data)
+    def __delitem__(self, index):
+        del self.data[index]
+    def __getitem__(self, index):
+        return self.data[index]
+    def __setitem__(self, index, code):
+        self.data[index] = code
+    def __getslice__(self, start, stop):
+        return SubPattern(self.pattern, self.data[start:stop])
+    def insert(self, index, code):
+        self.data.insert(index, code)
+    def append(self, code):
+        self.data.append(code)
+    def getwidth(self):
+        # determine the width (min, max) for this subpattern
+        if self.width:
+            return self.width
+        lo = hi = 0L
+        UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
+        REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
+        for op, av in self.data:
+            if op is BRANCH:
+                i = sys.maxint
+                j = 0
+                for av in av[1]:
+                    l, h = av.getwidth()
+                    i = min(i, l)
+                    j = max(j, h)
+                lo = lo + i
+                hi = hi + j
+            elif op is CALL:
+                i, j = av.getwidth()
+                lo = lo + i
+                hi = hi + j
+            elif op is SUBPATTERN:
+                i, j = av[1].getwidth()
+                lo = lo + i
+                hi = hi + j
+            elif op in REPEATCODES:
+                i, j = av[2].getwidth()
+                lo = lo + long(i) * av[0]
+                hi = hi + long(j) * av[1]
+            elif op in UNITCODES:
+                lo = lo + 1
+                hi = hi + 1
+            elif op == SUCCESS:
+                break
+        self.width = int(min(lo, sys.maxint)), int(min(hi, sys.maxint))
+        return self.width
+
+class Tokenizer:
+    def __init__(self, string):
+        self.string = string
+        self.index = 0
+        self.__next()
+    def __next(self):
+        if self.index &gt;= len(self.string):
+            self.next = None
+            return
+        char = self.string[self.index]
+        if char[0] == &quot;\\&quot;:
+            try:
+                c = self.string[self.index + 1]
+            except IndexError:
+                raise error, &quot;bogus escape (end of line)&quot;
+            char = char + c
+        self.index = self.index + len(char)
+        self.next = char
+    def match(self, char, skip=1):
+        if char == self.next:
+            if skip:
+                self.__next()
+            return 1
+        return 0
+    def get(self):
+        this = self.next
+        self.__next()
+        return this
+    def tell(self):
+        return self.index, self.next
+    def seek(self, index):
+        self.index, self.next = index
+
+def isident(char):
+    return &quot;a&quot; &lt;= char &lt;= &quot;z&quot; or &quot;A&quot; &lt;= char &lt;= &quot;Z&quot; or char == &quot;_&quot;
+
+def isdigit(char):
+    return &quot;0&quot; &lt;= char &lt;= &quot;9&quot;
+
+def isname(name):
+    # check that group name is a valid string
+    if not isident(name[0]):
+        return False
+    for char in name[1:]:
+        if not isident(char) and not isdigit(char):
+            return False
+    return True
+
+def _class_escape(source, escape):
+    # handle escape code inside character class
+    code = ESCAPES.get(escape)
+    if code:
+        return code
+    code = CATEGORIES.get(escape)
+    if code:
+        return code
+    try:
+        c = escape[1:2]
+        if c == &quot;x&quot;:
+            # hexadecimal escape (exactly two digits)
+            while source.next in HEXDIGITS and len(escape) &lt; 4:
+                escape = escape + source.get()
+            escape = escape[2:]
+            if len(escape) != 2:
+                raise error, &quot;bogus escape: %s&quot; % repr(&quot;\\&quot; + escape)
+            return LITERAL, int(escape, 16) &amp; 0xff
+        elif c in OCTDIGITS:
+            # octal escape (up to three digits)
+            while source.next in OCTDIGITS and len(escape) &lt; 4:
+                escape = escape + source.get()
+            escape = escape[1:]
+            return LITERAL, int(escape, 8) &amp; 0xff
+        elif c in DIGITS:
+            raise error, &quot;bogus escape: %s&quot; % repr(escape)
+        if len(escape) == 2:
+            return LITERAL, ord(escape[1])
+    except ValueError:
+        pass
+    raise error, &quot;bogus escape: %s&quot; % repr(escape)
+
+def _escape(source, escape, state):
+    # handle escape code in expression
+    code = CATEGORIES.get(escape)
+    if code:
+        return code
+    code = ESCAPES.get(escape)
+    if code:
+        return code
+    try:
+        c = escape[1:2]
+        if c == &quot;x&quot;:
+            # hexadecimal escape
+            while source.next in HEXDIGITS and len(escape) &lt; 4:
+                escape = escape + source.get()
+            if len(escape) != 4:
+                raise ValueError
+            return LITERAL, int(escape[2:], 16) &amp; 0xff
+        elif c == &quot;0&quot;:
+            # octal escape
+            while source.next in OCTDIGITS and len(escape) &lt; 4:
+                escape = escape + source.get()
+            return LITERAL, int(escape[1:], 8) &amp; 0xff
+        elif c in DIGITS:
+            # octal escape *or* decimal group reference (sigh)
+            if source.next in DIGITS:
+                escape = escape + source.get()
+                if (escape[1] in OCTDIGITS and escape[2] in OCTDIGITS and
+                    source.next in OCTDIGITS):
+                    # got three octal digits; this is an octal escape
+                    escape = escape + source.get()
+                    return LITERAL, int(escape[1:], 8) &amp; 0xff
+            # not an octal escape, so this is a group reference
+            group = int(escape[1:])
+            if group &lt; state.groups:
+                if not state.checkgroup(group):
+                    raise error, &quot;cannot refer to open group&quot;
+                return GROUPREF, group
+            raise ValueError
+        if len(escape) == 2:
+            return LITERAL, ord(escape[1])
+    except ValueError:
+        pass
+    raise error, &quot;bogus escape: %s&quot; % repr(escape)
+
+def _parse_sub(source, state, nested=1):
+    # parse an alternation: a|b|c
+
+    items = []
+    itemsappend = items.append
+    sourcematch = source.match
+    while 1:
+        itemsappend(_parse(source, state))
+        if sourcematch(&quot;|&quot;):
+            continue
+        if not nested:
+            break
+        if not source.next or sourcematch(&quot;)&quot;, 0):
+            break
+        else:
+            raise error, &quot;pattern not properly closed&quot;
+
+    if len(items) == 1:
+        return items[0]
+
+    subpattern = SubPattern(state)
+    subpatternappend = subpattern.append
+
+    # check if all items share a common prefix
+    while 1:
+        prefix = None
+        for item in items:
+            if not item:
+                break
+            if prefix is None:
+                prefix = item[0]
+            elif item[0] != prefix:
+                break
+        else:
+            # all subitems start with a common &quot;prefix&quot;.
+            # move it out of the branch
+            for item in items:
+                del item[0]
+            subpatternappend(prefix)
+            continue # check next one
+        break
+
+    # check if the branch can be replaced by a character set
+    for item in items:
+        if len(item) != 1 or item[0][0] != LITERAL:
+            break
+    else:
+        # we can store this as a character set instead of a
+        # branch (the compiler may optimize this even more)
+        set = []
+        setappend = set.append
+        for item in items:
+            setappend(item[0])
+        subpatternappend((IN, set))
+        return subpattern
+
+    subpattern.append((BRANCH, (None, items)))
+    return subpattern
+
+def _parse_sub_cond(source, state, condgroup):
+    item_yes = _parse(source, state)
+    if source.match(&quot;|&quot;):
+        item_no = _parse(source, state)
+        if source.match(&quot;|&quot;):
+            raise error, &quot;conditional backref with more than two branches&quot;
+    else:
+        item_no = None
+    if source.next and not source.match(&quot;)&quot;, 0):
+        raise error, &quot;pattern not properly closed&quot;
+    subpattern = SubPattern(state)
+    subpattern.append((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))
+    return subpattern
+
+_PATTERNENDERS = set(&quot;|)&quot;)
+_ASSERTCHARS = set(&quot;=!&lt;&quot;)
+_LOOKBEHINDASSERTCHARS = set(&quot;=!&quot;)
+_REPEATCODES = set([MIN_REPEAT, MAX_REPEAT])
+
+def _parse(source, state):
+    # parse a simple pattern
+    subpattern = SubPattern(state)
+
+    # precompute constants into local variables
+    subpatternappend = subpattern.append
+    sourceget = source.get
+    sourcematch = source.match
+    _len = len
+    PATTERNENDERS = _PATTERNENDERS
+    ASSERTCHARS = _ASSERTCHARS
+    LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
+    REPEATCODES = _REPEATCODES
+
+    while 1:
+
+        if source.next in PATTERNENDERS:
+            break # end of subpattern
+        this = sourceget()
+        if this is None:
+            break # end of pattern
+
+        if state.flags &amp; SRE_FLAG_VERBOSE:
+            # skip whitespace and comments
+            if this in WHITESPACE:
+                continue
+            if this == &quot;#&quot;:
+                while 1:
+                    this = sourceget()
+                    if this in (None, &quot;\n&quot;):
+                        break
+                continue
+
+        if this and this[0] not in SPECIAL_CHARS:
+            subpatternappend((LITERAL, ord(this)))
+
+        elif this == &quot;[&quot;:
+            # character set
+            set = []
+            setappend = set.append
+##          if sourcematch(&quot;:&quot;):
+##              pass # handle character classes
+            if sourcematch(&quot;^&quot;):
+                setappend((NEGATE, None))
+            # check remaining characters
+            start = set[:]
+            while 1:
+                this = sourceget()
+                if this == &quot;]&quot; and set != start:
+                    break
+                elif this and this[0] == &quot;\\&quot;:
+                    code1 = _class_escape(source, this)
+                elif this:
+                    code1 = LITERAL, ord(this)
+                else:
+                    raise error, &quot;unexpected end of regular expression&quot;
+                if sourcematch(&quot;-&quot;):
+                    # potential range
+                    this = sourceget()
+                    if this == &quot;]&quot;:
+                        if code1[0] is IN:
+                            code1 = code1[1][0]
+                        setappend(code1)
+                        setappend((LITERAL, ord(&quot;-&quot;)))
+                        break
+                    elif this:
+                        if this[0] == &quot;\\&quot;:
+                            code2 = _class_escape(source, this)
+                        else:
+                            code2 = LITERAL, ord(this)
+                        if code1[0] != LITERAL or code2[0] != LITERAL:
+                            raise error, &quot;bad character range&quot;
+                        lo = code1[1]
+                        hi = code2[1]
+                        if hi &lt; lo:
+                            raise error, &quot;bad character range&quot;
+                        setappend((RANGE, (lo, hi)))
+                    else:
+                        raise error, &quot;unexpected end of regular expression&quot;
+                else:
+                    if code1[0] is IN:
+                        code1 = code1[1][0]
+                    setappend(code1)
+
+            # XXX: &lt;fl&gt; should move set optimization to compiler!
+            if _len(set)==1 and set[0][0] is LITERAL:
+                subpatternappend(set[0]) # optimization
+            elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
+                subpatternappend((NOT_LITERAL, set[1][1])) # optimization
+            else:
+                # XXX: &lt;fl&gt; should add charmap optimization here
+                subpatternappend((IN, set))
+
+        elif this and this[0] in REPEAT_CHARS:
+            # repeat previous item
+            if this == &quot;?&quot;:
+                min, max = 0, 1
+            elif this == &quot;*&quot;:
+                min, max = 0, MAXREPEAT
+
+            elif this == &quot;+&quot;:
+                min, max = 1, MAXREPEAT
+            elif this == &quot;{&quot;:
+                if source.next == &quot;}&quot;:
+                    subpatternappend((LITERAL, ord(this)))
+                    continue
+                here = source.tell()
+                min, max = 0, MAXREPEAT
+                lo = hi = &quot;&quot;
+                while source.next in DIGITS:
+                    lo = lo + source.get()
+                if sourcematch(&quot;,&quot;):
+                    while source.next in DIGITS:
+                        hi = hi + sourceget()
+                else:
+                    hi = lo
+                if not sourcematch(&quot;}&quot;):
+                    subpatternappend((LITERAL, ord(this)))
+                    source.seek(here)
+                    continue
+                if lo:
+                    min = int(lo)
+                if hi:
+                    max = int(hi)
+                if max &lt; min:
+                    raise error, &quot;bad repeat interval&quot;
+            else:
+                raise error, &quot;not supported&quot;
+            # figure out which item to repeat
+            if subpattern:
+                item = subpattern[-1:]
+            else:
+                item = None
+            if not item or (_len(item) == 1 and item[0][0] == AT):
+                raise error, &quot;nothing to repeat&quot;
+            if item[0][0] in REPEATCODES:
+                raise error, &quot;multiple repeat&quot;
+            if sourcematch(&quot;?&quot;):
+                subpattern[-1] = (MIN_REPEAT, (min, max, item))
+            else:
+                subpattern[-1] = (MAX_REPEAT, (min, max, item))
+
+        elif this == &quot;.&quot;:
+            subpatternappend((ANY, None))
+
+        elif this == &quot;(&quot;:
+            group = 1
+            name = None
+            condgroup = None
+            if sourcematch(&quot;?&quot;):
+                group = 0
+                # options
+                if sourcematch(&quot;P&quot;):
+                    # python extensions
+                    if sourcematch(&quot;&lt;&quot;):
+                        # named group: skip forward to end of name
+                        name = &quot;&quot;
+                        while 1:
+                            char = sourceget()
+                            if char is None:
+                                raise error, &quot;unterminated name&quot;
+                            if char == &quot;&gt;&quot;:
+                                break
+                            name = name + char
+                        group = 1
+                        if not isname(name):
+                            raise error, &quot;bad character in group name&quot;
+                    elif sourcematch(&quot;=&quot;):
+                        # named backreference
+                        name = &quot;&quot;
+                        while 1:
+                            char = sourceget()
+                            if char is None:
+                                raise error, &quot;unterminated name&quot;
+                            if char == &quot;)&quot;:
+                                break
+                            name = name + char
+                        if not isname(name):
+                            raise error, &quot;bad character in group name&quot;
+                        gid = state.groupdict.get(name)
+                        if gid is None:
+                            raise error, &quot;unknown group name&quot;
+                        subpatternappend((GROUPREF, gid))
+                        continue
+                    else:
+                        char = sourceget()
+                        if char is None:
+                            raise error, &quot;unexpected end of pattern&quot;
+                        raise error, &quot;unknown specifier: ?P%s&quot; % char
+                elif sourcematch(&quot;:&quot;):
+                    # non-capturing group
+                    group = 2
+                elif sourcematch(&quot;#&quot;):
+                    # comment
+                    while 1:
+                        if source.next is None or source.next == &quot;)&quot;:
+                            break
+                        sourceget()
+                    if not sourcematch(&quot;)&quot;):
+                        raise error, &quot;unbalanced parenthesis&quot;
+                    continue
+                elif source.next in ASSERTCHARS:
+                    # lookahead assertions
+                    char = sourceget()
+                    dir = 1
+                    if char == &quot;&lt;&quot;:
+                        if source.next not in LOOKBEHINDASSERTCHARS:
+                            raise error, &quot;syntax error&quot;
+                        dir = -1 # lookbehind
+                        char = sourceget()
+                    p = _parse_sub(source, state)
+                    if not sourcematch(&quot;)&quot;):
+                        raise error, &quot;unbalanced parenthesis&quot;
+                    if char == &quot;=&quot;:
+                        subpatternappend((ASSERT, (dir, p)))
+                    else:
+                        subpatternappend((ASSERT_NOT, (dir, p)))
+                    continue
+                elif sourcematch(&quot;(&quot;):
+                    # conditional backreference group
+                    condname = &quot;&quot;
+                    while 1:
+                        char = sourceget()
+                        if char is None:
+                            raise error, &quot;unterminated name&quot;
+                        if char == &quot;)&quot;:
+                            break
+                        condname = condname + char
+                    group = 2
+                    if isname(condname):
+                        condgroup = state.groupdict.get(condname)
+                        if condgroup is None:
+                            raise error, &quot;unknown group name&quot;
+                    else:
+                        try:
+                            condgroup = int(condname)
+                        except ValueError:
+                            raise error, &quot;bad character in group name&quot;
+                else:
+                    # flags
+                    if not source.next in FLAGS:
+                        raise error, &quot;unexpected end of pattern&quot;
+                    while source.next in FLAGS:
+                        state.flags = state.flags | FLAGS[sourceget()]
+            if group:
+                # parse group contents
+                if group == 2:
+                    # anonymous group
+                    group = None
+                else:
+                    group = state.opengroup(name)
+                if condgroup:
+                    p = _parse_sub_cond(source, state, condgroup)
+                else:
+                    p = _parse_sub(source, state)
+                if not sourcematch(&quot;)&quot;):
+                    raise error, &quot;unbalanced parenthesis&quot;
+                if group is not None:
+                    state.closegroup(group)
+                subpatternappend((SUBPATTERN, (group, p)))
+            else:
+                while 1:
+                    char = sourceget()
+                    if char is None:
+                        raise error, &quot;unexpected end of pattern&quot;
+                    if char == &quot;)&quot;:
+                        break
+                    raise error, &quot;unknown extension&quot;
+
+        elif this == &quot;^&quot;:
+            subpatternappend((AT, AT_BEGINNING))
+
+        elif this == &quot;$&quot;:
+            subpattern.append((AT, AT_END))
+
+        elif this and this[0] == &quot;\\&quot;:
+            code = _escape(source, this, state)
+            subpatternappend(code)
+
+        else:
+            raise error, &quot;parser error&quot;
+
+    return subpattern
+
+def parse(str, flags=0, pattern=None):
+    # parse 're' pattern into list of (opcode, argument) tuples
+
+    source = Tokenizer(str)
+
+    if pattern is None:
+        pattern = Pattern()
+    pattern.flags = flags
+    pattern.str = str
+
+    p = _parse_sub(source, pattern, 0)
+
+    tail = source.get()
+    if tail == &quot;)&quot;:
+        raise error, &quot;unbalanced parenthesis&quot;
+    elif tail:
+        raise error, &quot;bogus characters at end of regular expression&quot;
+
+    if flags &amp; SRE_FLAG_DEBUG:
+        p.dump()
+
+    if not (flags &amp; SRE_FLAG_VERBOSE) and p.pattern.flags &amp; SRE_FLAG_VERBOSE:
+        # the VERBOSE flag was switched on inside the pattern.  to be
+        # on the safe side, we'll parse the whole thing again...
+        return parse(str, p.pattern.flags)
+
+    return p
+
+def parse_template(source, pattern):
+    # parse 're' replacement string into list of literals and
+    # group references
+    s = Tokenizer(source)
+    sget = s.get
+    p = []
+    a = p.append
+    def literal(literal, p=p, pappend=a):
+        if p and p[-1][0] is LITERAL:
+            p[-1] = LITERAL, p[-1][1] + literal
+        else:
+            pappend((LITERAL, literal))
+    sep = source[:0]
+    if type(sep) is type(&quot;&quot;):
+        makechar = chr
+    else:
+        makechar = unichr
+    while 1:
+        this = sget()
+        if this is None:
+            break # end of replacement string
+        if this and this[0] == &quot;\\&quot;:
+            # group
+            c = this[1:2]
+            if c == &quot;g&quot;:
+                name = &quot;&quot;
+                if s.match(&quot;&lt;&quot;):
+                    while 1:
+                        char = sget()
+                        if char is None:
+                            raise error, &quot;unterminated group name&quot;
+                        if char == &quot;&gt;&quot;:
+                            break
+                        name = name + char
+                if not name:
+                    raise error, &quot;bad group name&quot;
+                try:
+                    index = int(name)
+                    if index &lt; 0:
+                        raise error, &quot;negative group number&quot;
+                except ValueError:
+                    if not isname(name):
+                        raise error, &quot;bad character in group name&quot;
+                    try:
+                        index = pattern.groupindex[name]
+                    except KeyError:
+                        raise IndexError, &quot;unknown group name&quot;
+                a((MARK, index))
+            elif c == &quot;0&quot;:
+                if s.next in OCTDIGITS:
+                    this = this + sget()
+                    if s.next in OCTDIGITS:
+                        this = this + sget()
+                literal(makechar(int(this[1:], 8) &amp; 0xff))
+            elif c in DIGITS:
+                isoctal = False
+                if s.next in DIGITS:
+                    this = this + sget()
+                    if (c in OCTDIGITS and this[2] in OCTDIGITS and
+                        s.next in OCTDIGITS):
+                        this = this + sget()
+                        isoctal = True
+                        literal(makechar(int(this[1:], 8) &amp; 0xff))
+                if not isoctal:
+                    a((MARK, int(this[1:])))
+            else:
+                try:
+                    this = makechar(ESCAPES[this][1])
+                except KeyError:
+                    pass
+                literal(this)
+        else:
+            literal(this)
+    # convert template to groups and literals lists
+    i = 0
+    groups = []
+    groupsappend = groups.append
+    literals = [None] * len(p)
+    for c, s in p:
+        if c is MARK:
+            groupsappend((i, s))
+            # literal[i] is already None
+        else:
+            literals[i] = s
+        i = i + 1
+    return groups, literals
+
+def expand_template(template, match):
+    g = match.group
+    sep = match.string[:0]
+    groups, literals = template
+    literals = literals[:]
+    try:
+        for index, group in groups:
+            literals[index] = s = g(group)
+            if s is None:
+                raise error, &quot;unmatched group&quot;
+    except IndexError:
+        raise error, &quot;invalid group reference&quot;
+    return sep.join(literals)

Added: trunk/Lobby/TASClient/Python/engine/stat.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/stat.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/stat.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,86 @@
+&quot;&quot;&quot;Constants/functions for interpreting results of os.stat() and os.lstat().
+
+Suggested usage: from stat import *
+&quot;&quot;&quot;
+
+# XXX Strictly spoken, this module may have to be adapted for each POSIX
+# implementation; in practice, however, the numeric constants used by
+# stat() are almost universal (even for stat() emulations on non-UNIX
+# systems like MS-DOS).
+
+# Indices for stat struct members in tuple returned by os.stat()
+
+ST_MODE  = 0
+ST_INO   = 1
+ST_DEV   = 2
+ST_NLINK = 3
+ST_UID   = 4
+ST_GID   = 5
+ST_SIZE  = 6
+ST_ATIME = 7
+ST_MTIME = 8
+ST_CTIME = 9
+
+# Extract bits from the mode
+
+def S_IMODE(mode):
+    return mode &amp; 07777
+
+def S_IFMT(mode):
+    return mode &amp; 0170000
+
+# Constants used as S_IFMT() for various file types
+# (not all are implemented on all systems)
+
+S_IFDIR  = 0040000
+S_IFCHR  = 0020000
+S_IFBLK  = 0060000
+S_IFREG  = 0100000
+S_IFIFO  = 0010000
+S_IFLNK  = 0120000
+S_IFSOCK = 0140000
+
+# Functions to test for each file type
+
+def S_ISDIR(mode):
+    return S_IFMT(mode) == S_IFDIR
+
+def S_ISCHR(mode):
+    return S_IFMT(mode) == S_IFCHR
+
+def S_ISBLK(mode):
+    return S_IFMT(mode) == S_IFBLK
+
+def S_ISREG(mode):
+    return S_IFMT(mode) == S_IFREG
+
+def S_ISFIFO(mode):
+    return S_IFMT(mode) == S_IFIFO
+
+def S_ISLNK(mode):
+    return S_IFMT(mode) == S_IFLNK
+
+def S_ISSOCK(mode):
+    return S_IFMT(mode) == S_IFSOCK
+
+# Names for permission bits
+
+S_ISUID = 04000
+S_ISGID = 02000
+S_ENFMT = S_ISGID
+S_ISVTX = 01000
+S_IREAD = 00400
+S_IWRITE = 00200
+S_IEXEC = 00100
+S_IRWXU = 00700
+S_IRUSR = 00400
+S_IWUSR = 00200
+S_IXUSR = 00100
+S_IRWXG = 00070
+S_IRGRP = 00040
+S_IWGRP = 00020
+S_IXGRP = 00010
+S_IRWXO = 00007
+S_IROTH = 00004
+S_IWOTH = 00002
+S_IXOTH = 00001

Added: trunk/Lobby/TASClient/Python/engine/string.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/string.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/string.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,529 @@
+&quot;&quot;&quot;A collection of string operations (most are no longer used).
+
+Warning: most of the code you see here isn't normally used nowadays.
+Beginning with Python 1.6, many of these functions are implemented as
+methods on the standard string object. They used to be implemented by
+a built-in module called strop, but strop is now obsolete itself.
+
+Public module variables:
+
+whitespace -- a string containing all characters considered whitespace
+lowercase -- a string containing all characters considered lowercase letters
+uppercase -- a string containing all characters considered uppercase letters
+letters -- a string containing all characters considered letters
+digits -- a string containing all characters considered decimal digits
+hexdigits -- a string containing all characters considered hexadecimal digits
+octdigits -- a string containing all characters considered octal digits
+punctuation -- a string containing all characters considered punctuation
+printable -- a string containing all characters considered printable
+
+&quot;&quot;&quot;
+
+# Some strings for ctype-style character classification
+whitespace = ' \t\n\r\v\f'
+lowercase = 'abcdefghijklmnopqrstuvwxyz'
+uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+letters = lowercase + uppercase
+ascii_lowercase = lowercase
+ascii_uppercase = uppercase
+ascii_letters = ascii_lowercase + ascii_uppercase
+digits = '0123456789'
+hexdigits = digits + 'abcdef' + 'ABCDEF'
+octdigits = '01234567'
+punctuation = &quot;&quot;&quot;!&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~&quot;&quot;&quot;
+printable = digits + letters + punctuation + whitespace
+
+# Case conversion helpers
+# Use str to convert Unicode literal in case of -U
+l = map(chr, xrange(256))
+_idmap = str('').join(l)
+del l
+
+# Functions which aren't available as string methods.
+
+# Capitalize the words in a string, e.g. &quot; aBc  dEf &quot; -&gt; &quot;Abc Def&quot;.
+def capwords(s, sep=None):
+    &quot;&quot;&quot;capwords(s, [sep]) -&gt; string
+
+    Split the argument into words using split, capitalize each
+    word using capitalize, and join the capitalized words using
+    join. Note that this replaces runs of whitespace characters by
+    a single space.
+
+    &quot;&quot;&quot;
+    return (sep or ' ').join([x.capitalize() for x in s.split(sep)])
+
+
+# Construct a translation string
+_idmapL = None
+def maketrans(fromstr, tostr):
+    &quot;&quot;&quot;maketrans(frm, to) -&gt; string
+
+    Return a translation table (a string of 256 bytes long)
+    suitable for use in string.translate.  The strings frm and to
+    must be of the same length.
+
+    &quot;&quot;&quot;
+    if len(fromstr) != len(tostr):
+        raise ValueError, &quot;maketrans arguments must have same length&quot;
+    global _idmapL
+    if not _idmapL:
+        _idmapL = map(None, _idmap)
+    L = _idmapL[:]
+    fromstr = map(ord, fromstr)
+    for i in range(len(fromstr)):
+        L[fromstr[i]] = tostr[i]
+    return ''.join(L)
+
+
+
+####################################################################
+import re as _re
+
+class _multimap:
+    &quot;&quot;&quot;Helper class for combining multiple mappings.
+
+    Used by .{safe_,}substitute() to combine the mapping and keyword
+    arguments.
+    &quot;&quot;&quot;
+    def __init__(self, primary, secondary):
+        self._primary = primary
+        self._secondary = secondary
+
+    def __getitem__(self, key):
+        try:
+            return self._primary[key]
+        except KeyError:
+            return self._secondary[key]
+
+
+class _TemplateMetaclass(type):
+    pattern = r&quot;&quot;&quot;
+    %(delim)s(?:
+      (?P&lt;escaped&gt;%(delim)s) |   # Escape sequence of two delimiters
+      (?P&lt;named&gt;%(id)s)      |   # delimiter and a Python identifier
+      {(?P&lt;braced&gt;%(id)s)}   |   # delimiter and a braced identifier
+      (?P&lt;invalid&gt;)              # Other ill-formed delimiter exprs
+    )
+    &quot;&quot;&quot;
+
+    def __init__(cls, name, bases, dct):
+        super(_TemplateMetaclass, cls).__init__(name, bases, dct)
+        if 'pattern' in dct:
+            pattern = cls.pattern
+        else:
+            pattern = _TemplateMetaclass.pattern % {
+                'delim' : _re.escape(cls.delimiter),
+                'id'    : cls.idpattern,
+                }
+        cls.pattern = _re.compile(pattern, _re.IGNORECASE | _re.VERBOSE)
+
+
+class Template:
+    &quot;&quot;&quot;A string class for supporting $-substitutions.&quot;&quot;&quot;
+    __metaclass__ = _TemplateMetaclass
+
+    delimiter = '$'
+    idpattern = r'[_a-z][_a-z0-9]*'
+
+    def __init__(self, template):
+        self.template = template
+
+    # Search for $$, $identifier, ${identifier}, and any bare $'s
+
+    def _invalid(self, mo):
+        i = mo.start('invalid')
+        lines = self.template[:i].splitlines(True)
+        if not lines:
+            colno = 1
+            lineno = 1
+        else:
+            colno = i - len(''.join(lines[:-1]))
+            lineno = len(lines)
+        raise ValueError('Invalid placeholder in string: line %d, col %d' %
+                         (lineno, colno))
+
+    def substitute(self, *args, **kws):
+        if len(args) &gt; 1:
+            raise TypeError('Too many positional arguments')
+        if not args:
+            mapping = kws
+        elif kws:
+            mapping = _multimap(kws, args[0])
+        else:
+            mapping = args[0]
+        # Helper function for .sub()
+        def convert(mo):
+            # Check the most common path first.
+            named = mo.group('named') or mo.group('braced')
+            if named is not None:
+                val = mapping[named]
+                # We use this idiom instead of str() because the latter will
+                # fail if val is a Unicode containing non-ASCII characters.
+                return '%s' % (val,)
+            if mo.group('escaped') is not None:
+                return self.delimiter
+            if mo.group('invalid') is not None:
+                self._invalid(mo)
+            raise ValueError('Unrecognized named group in pattern',
+                             self.pattern)
+        return self.pattern.sub(convert, self.template)
+
+    def safe_substitute(self, *args, **kws):
+        if len(args) &gt; 1:
+            raise TypeError('Too many positional arguments')
+        if not args:
+            mapping = kws
+        elif kws:
+            mapping = _multimap(kws, args[0])
+        else:
+            mapping = args[0]
+        # Helper function for .sub()
+        def convert(mo):
+            named = mo.group('named')
+            if named is not None:
+                try:
+                    # We use this idiom instead of str() because the latter
+                    # will fail if val is a Unicode containing non-ASCII
+                    return '%s' % (mapping[named],)
+                except KeyError:
+                    return self.delimiter + named
+            braced = mo.group('braced')
+            if braced is not None:
+                try:
+                    return '%s' % (mapping[braced],)
+                except KeyError:
+                    return self.delimiter + '{' + braced + '}'
+            if mo.group('escaped') is not None:
+                return self.delimiter
+            if mo.group('invalid') is not None:
+                return self.delimiter
+            raise ValueError('Unrecognized named group in pattern',
+                             self.pattern)
+        return self.pattern.sub(convert, self.template)
+
+
+
+####################################################################
+# NOTE: Everything below here is deprecated.  Use string methods instead.
+# This stuff will go away in Python 3.0.
+
+# Backward compatible names for exceptions
+index_error = ValueError
+atoi_error = ValueError
+atof_error = ValueError
+atol_error = ValueError
+
+# convert UPPER CASE letters to lower case
+def lower(s):
+    &quot;&quot;&quot;lower(s) -&gt; string
+
+    Return a copy of the string s converted to lowercase.
+
+    &quot;&quot;&quot;
+    return s.lower()
+
+# Convert lower case letters to UPPER CASE
+def upper(s):
+    &quot;&quot;&quot;upper(s) -&gt; string
+
+    Return a copy of the string s converted to uppercase.
+
+    &quot;&quot;&quot;
+    return s.upper()
+
+# Swap lower case letters and UPPER CASE
+def swapcase(s):
+    &quot;&quot;&quot;swapcase(s) -&gt; string
+
+    Return a copy of the string s with upper case characters
+    converted to lowercase and vice versa.
+
+    &quot;&quot;&quot;
+    return s.swapcase()
+
+# Strip leading and trailing tabs and spaces
+def strip(s, chars=None):
+    &quot;&quot;&quot;strip(s [,chars]) -&gt; string
+
+    Return a copy of the string s with leading and trailing
+    whitespace removed.
+    If chars is given and not None, remove characters in chars instead.
+    If chars is unicode, S will be converted to unicode before stripping.
+
+    &quot;&quot;&quot;
+    return s.strip(chars)
+
+# Strip leading tabs and spaces
+def lstrip(s, chars=None):
+    &quot;&quot;&quot;lstrip(s [,chars]) -&gt; string
+
+    Return a copy of the string s with leading whitespace removed.
+    If chars is given and not None, remove characters in chars instead.
+
+    &quot;&quot;&quot;
+    return s.lstrip(chars)
+
+# Strip trailing tabs and spaces
+def rstrip(s, chars=None):
+    &quot;&quot;&quot;rstrip(s [,chars]) -&gt; string
+
+    Return a copy of the string s with trailing whitespace removed.
+    If chars is given and not None, remove characters in chars instead.
+
+    &quot;&quot;&quot;
+    return s.rstrip(chars)
+
+
+# Split a string into a list of space/tab-separated words
+def split(s, sep=None, maxsplit=-1):
+    &quot;&quot;&quot;split(s [,sep [,maxsplit]]) -&gt; list of strings
+
+    Return a list of the words in the string s, using sep as the
+    delimiter string.  If maxsplit is given, splits at no more than
+    maxsplit places (resulting in at most maxsplit+1 words).  If sep
+    is not specified or is None, any whitespace string is a separator.
+
+    (split and splitfields are synonymous)
+
+    &quot;&quot;&quot;
+    return s.split(sep, maxsplit)
+splitfields = split
+
+# Split a string into a list of space/tab-separated words
+def rsplit(s, sep=None, maxsplit=-1):
+    &quot;&quot;&quot;rsplit(s [,sep [,maxsplit]]) -&gt; list of strings
+
+    Return a list of the words in the string s, using sep as the
+    delimiter string, starting at the end of the string and working
+    to the front.  If maxsplit is given, at most maxsplit splits are
+    done. If sep is not specified or is None, any whitespace string
+    is a separator.
+    &quot;&quot;&quot;
+    return s.rsplit(sep, maxsplit)
+
+# Join fields with optional separator
+def join(words, sep = ' '):
+    &quot;&quot;&quot;join(list [,sep]) -&gt; string
+
+    Return a string composed of the words in list, with
+    intervening occurrences of sep.  The default separator is a
+    single space.
+
+    (joinfields and join are synonymous)
+
+    &quot;&quot;&quot;
+    return sep.join(words)
+joinfields = join
+
+# Find substring, raise exception if not found
+def index(s, *args):
+    &quot;&quot;&quot;index(s, sub [,start [,end]]) -&gt; int
+
+    Like find but raises ValueError when the substring is not found.
+
+    &quot;&quot;&quot;
+    return s.index(*args)
+
+# Find last substring, raise exception if not found
+def rindex(s, *args):
+    &quot;&quot;&quot;rindex(s, sub [,start [,end]]) -&gt; int
+
+    Like rfind but raises ValueError when the substring is not found.
+
+    &quot;&quot;&quot;
+    return s.rindex(*args)
+
+# Count non-overlapping occurrences of substring
+def count(s, *args):
+    &quot;&quot;&quot;count(s, sub[, start[,end]]) -&gt; int
+
+    Return the number of occurrences of substring sub in string
+    s[start:end].  Optional arguments start and end are
+    interpreted as in slice notation.
+
+    &quot;&quot;&quot;
+    return s.count(*args)
+
+# Find substring, return -1 if not found
+def find(s, *args):
+    &quot;&quot;&quot;find(s, sub [,start [,end]]) -&gt; in
+
+    Return the lowest index in s where substring sub is found,
+    such that sub is contained within s[start,end].  Optional
+    arguments start and end are interpreted as in slice notation.
+
+    Return -1 on failure.
+
+    &quot;&quot;&quot;
+    return s.find(*args)
+
+# Find last substring, return -1 if not found
+def rfind(s, *args):
+    &quot;&quot;&quot;rfind(s, sub [,start [,end]]) -&gt; int
+
+    Return the highest index in s where substring sub is found,
+    such that sub is contained within s[start,end].  Optional
+    arguments start and end are interpreted as in slice notation.
+
+    Return -1 on failure.
+
+    &quot;&quot;&quot;
+    return s.rfind(*args)
+
+# for a bit of speed
+_float = float
+_int = int
+_long = long
+
+# Convert string to float
+def atof(s):
+    &quot;&quot;&quot;atof(s) -&gt; float
+
+    Return the floating point number represented by the string s.
+
+    &quot;&quot;&quot;
+    return _float(s)
+
+
+# Convert string to integer
+def atoi(s , base=10):
+    &quot;&quot;&quot;atoi(s [,base]) -&gt; int
+
+    Return the integer represented by the string s in the given
+    base, which defaults to 10.  The string s must consist of one
+    or more digits, possibly preceded by a sign.  If base is 0, it
+    is chosen from the leading characters of s, 0 for octal, 0x or
+    0X for hexadecimal.  If base is 16, a preceding 0x or 0X is
+    accepted.
+
+    &quot;&quot;&quot;
+    return _int(s, base)
+
+
+# Convert string to long integer
+def atol(s, base=10):
+    &quot;&quot;&quot;atol(s [,base]) -&gt; long
+
+    Return the long integer represented by the string s in the
+    given base, which defaults to 10.  The string s must consist
+    of one or more digits, possibly preceded by a sign.  If base
+    is 0, it is chosen from the leading characters of s, 0 for
+    octal, 0x or 0X for hexadecimal.  If base is 16, a preceding
+    0x or 0X is accepted.  A trailing L or l is not accepted,
+    unless base is 0.
+
+    &quot;&quot;&quot;
+    return _long(s, base)
+
+
+# Left-justify a string
+def ljust(s, width, *args):
+    &quot;&quot;&quot;ljust(s, width[, fillchar]) -&gt; string
+
+    Return a left-justified version of s, in a field of the
+    specified width, padded with spaces as needed.  The string is
+    never truncated.  If specified the fillchar is used instead of spaces.
+
+    &quot;&quot;&quot;
+    return s.ljust(width, *args)
+
+# Right-justify a string
+def rjust(s, width, *args):
+    &quot;&quot;&quot;rjust(s, width[, fillchar]) -&gt; string
+
+    Return a right-justified version of s, in a field of the
+    specified width, padded with spaces as needed.  The string is
+    never truncated.  If specified the fillchar is used instead of spaces.
+
+    &quot;&quot;&quot;
+    return s.rjust(width, *args)
+
+# Center a string
+def center(s, width, *args):
+    &quot;&quot;&quot;center(s, width[, fillchar]) -&gt; string
+
+    Return a center version of s, in a field of the specified
+    width. padded with spaces as needed.  The string is never
+    truncated.  If specified the fillchar is used instead of spaces.
+
+    &quot;&quot;&quot;
+    return s.center(width, *args)
+
+# Zero-fill a number, e.g., (12, 3) --&gt; '012' and (-3, 3) --&gt; '-03'
+# Decadent feature: the argument may be a string or a number
+# (Use of this is deprecated; it should be a string as with ljust c.s.)
+def zfill(x, width):
+    &quot;&quot;&quot;zfill(x, width) -&gt; string
+
+    Pad a numeric string x with zeros on the left, to fill a field
+    of the specified width.  The string x is never truncated.
+
+    &quot;&quot;&quot;
+    if not isinstance(x, basestring):
+        x = repr(x)
+    return x.zfill(width)
+
+# Expand tabs in a string.
+# Doesn't take non-printing chars into account, but does understand \n.
+def expandtabs(s, tabsize=8):
+    &quot;&quot;&quot;expandtabs(s [,tabsize]) -&gt; string
+
+    Return a copy of the string s with all tab characters replaced
+    by the appropriate number of spaces, depending on the current
+    column, and the tabsize (default 8).
+
+    &quot;&quot;&quot;
+    return s.expandtabs(tabsize)
+
+# Character translation through look-up table.
+def translate(s, table, deletions=&quot;&quot;):
+    &quot;&quot;&quot;translate(s,table [,deletions]) -&gt; string
+
+    Return a copy of the string s, where all characters occurring
+    in the optional argument deletions are removed, and the
+    remaining characters have been mapped through the given
+    translation table, which must be a string of length 256.  The
+    deletions argument is not allowed for Unicode strings.
+
+    &quot;&quot;&quot;
+    if deletions:
+        return s.translate(table, deletions)
+    else:
+        # Add s[:0] so that if s is Unicode and table is an 8-bit string,
+        # table is converted to Unicode.  This means that table *cannot*
+        # be a dictionary -- for that feature, use u.translate() directly.
+        return s.translate(table + s[:0])
+
+# Capitalize a string, e.g. &quot;aBc  dEf&quot; -&gt; &quot;Abc  def&quot;.
+def capitalize(s):
+    &quot;&quot;&quot;capitalize(s) -&gt; string
+
+    Return a copy of the string s with only its first character
+    capitalized.
+
+    &quot;&quot;&quot;
+    return s.capitalize()
+
+# Substring replacement (global)
+def replace(s, old, new, maxsplit=-1):
+    &quot;&quot;&quot;replace (str, old, new[, maxsplit]) -&gt; string
+
+    Return a copy of string str with all occurrences of substring
+    old replaced by new. If the optional argument maxsplit is
+    given, only the first maxsplit occurrences are replaced.
+
+    &quot;&quot;&quot;
+    return s.replace(old, new, maxsplit)
+
+
+# Try importing optional built-in module &quot;strop&quot; -- if it exists,
+# it redefines some string operations that are 100-1000 times faster.
+# It also defines values for whitespace, lowercase and uppercase
+# that match &lt;ctype.h&gt;'s definitions.
+
+try:
+    from strop import maketrans, lowercase, uppercase, whitespace
+    letters = lowercase + uppercase
+except ImportError:
+    pass                                          # Use the original versions

Added: trunk/Lobby/TASClient/Python/engine/token.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/token.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/token.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,141 @@
+#! /usr/bin/env python
+
+&quot;&quot;&quot;Token constants (from &quot;token.h&quot;).&quot;&quot;&quot;
+
+#  This file is automatically generated; please don't muck it up!
+#
+#  To update the symbols in this file, 'cd' to the top directory of
+#  the python source tree after building the interpreter and run:
+#
+#    python Lib/token.py
+
+#--start constants--
+ENDMARKER = 0
+NAME = 1
+NUMBER = 2
+STRING = 3
+NEWLINE = 4
+INDENT = 5
+DEDENT = 6
+LPAR = 7
+RPAR = 8
+LSQB = 9
+RSQB = 10
+COLON = 11
+COMMA = 12
+SEMI = 13
+PLUS = 14
+MINUS = 15
+STAR = 16
+SLASH = 17
+VBAR = 18
+AMPER = 19
+LESS = 20
+GREATER = 21
+EQUAL = 22
+DOT = 23
+PERCENT = 24
+BACKQUOTE = 25
+LBRACE = 26
+RBRACE = 27
+EQEQUAL = 28
+NOTEQUAL = 29
+LESSEQUAL = 30
+GREATEREQUAL = 31
+TILDE = 32
+CIRCUMFLEX = 33
+LEFTSHIFT = 34
+RIGHTSHIFT = 35
+DOUBLESTAR = 36
+PLUSEQUAL = 37
+MINEQUAL = 38
+STAREQUAL = 39
+SLASHEQUAL = 40
+PERCENTEQUAL = 41
+AMPEREQUAL = 42
+VBAREQUAL = 43
+CIRCUMFLEXEQUAL = 44
+LEFTSHIFTEQUAL = 45
+RIGHTSHIFTEQUAL = 46
+DOUBLESTAREQUAL = 47
+DOUBLESLASH = 48
+DOUBLESLASHEQUAL = 49
+AT = 50
+OP = 51
+ERRORTOKEN = 52
+N_TOKENS = 53
+NT_OFFSET = 256
+#--end constants--
+
+tok_name = {}
+for _name, _value in globals().items():
+    if type(_value) is type(0):
+        tok_name[_value] = _name
+
+
+def ISTERMINAL(x):
+    return x &lt; NT_OFFSET
+
+def ISNONTERMINAL(x):
+    return x &gt;= NT_OFFSET
+
+def ISEOF(x):
+    return x == ENDMARKER
+
+
+def main():
+    import re
+    import sys
+    args = sys.argv[1:]
+    inFileName = args and args[0] or &quot;Include/token.h&quot;
+    outFileName = &quot;Lib/token.py&quot;
+    if len(args) &gt; 1:
+        outFileName = args[1]
+    try:
+        fp = open(inFileName)
+    except IOError, err:
+        sys.stdout.write(&quot;I/O error: %s\n&quot; % str(err))
+        sys.exit(1)
+    lines = fp.read().split(&quot;\n&quot;)
+    fp.close()
+    prog = re.compile(
+        &quot;#define[ \t][ \t]*([A-Z0-9][A-Z0-9_]*)[ \t][ \t]*([0-9][0-9]*)&quot;,
+        re.IGNORECASE)
+    tokens = {}
+    for line in lines:
+        match = prog.match(line)
+        if match:
+            name, val = match.group(1, 2)
+            val = int(val)
+            tokens[val] = name          # reverse so we can sort them...
+    keys = tokens.keys()
+    keys.sort()
+    # load the output skeleton from the target:
+    try:
+        fp = open(outFileName)
+    except IOError, err:
+        sys.stderr.write(&quot;I/O error: %s\n&quot; % str(err))
+        sys.exit(2)
+    format = fp.read().split(&quot;\n&quot;)
+    fp.close()
+    try:
+        start = format.index(&quot;#--start constants--&quot;) + 1
+        end = format.index(&quot;#--end constants--&quot;)
+    except ValueError:
+        sys.stderr.write(&quot;target does not contain format markers&quot;)
+        sys.exit(3)
+    lines = []
+    for val in keys:
+        lines.append(&quot;%s = %d&quot; % (tokens[val], val))
+    format[start:end] = lines
+    try:
+        fp = open(outFileName, 'w')
+    except IOError, err:
+        sys.stderr.write(&quot;I/O error: %s\n&quot; % str(err))
+        sys.exit(4)
+    fp.write(&quot;\n&quot;.join(format))
+    fp.close()
+
+
+if __name__ == &quot;__main__&quot;:
+    main()

Added: trunk/Lobby/TASClient/Python/engine/tokenize.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/tokenize.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/tokenize.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,345 @@
+&quot;&quot;&quot;Tokenization help for Python programs.
+
+generate_tokens(readline) is a generator that breaks a stream of
+text into Python tokens.  It accepts a readline-like method which is called
+repeatedly to get the next line of input (or &quot;&quot; for EOF).  It generates
+5-tuples with these members:
+
+    the token type (see token.py)
+    the token (a string)
+    the starting (row, column) indices of the token (a 2-tuple of ints)
+    the ending (row, column) indices of the token (a 2-tuple of ints)
+    the original line (string)
+
+It is designed to match the working of the Python tokenizer exactly, except
+that it produces COMMENT tokens for comments and gives type OP for all
+operators
+
+Older entry points
+    tokenize_loop(readline, tokeneater)
+    tokenize(readline, tokeneater=printtoken)
+are the same, except instead of generating tokens, tokeneater is a callback
+function to which the 5 fields described above are passed as 5 arguments,
+each time a new token is found.&quot;&quot;&quot;
+
+__author__ = 'Ka-Ping Yee &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">ping at lfw.org</A>&gt;'
+__credits__ = \
+    'GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro'
+
+import string, re
+from token import *
+
+import token
+__all__ = [x for x in dir(token) if x[0] != '_'] + [&quot;COMMENT&quot;, &quot;tokenize&quot;,
+           &quot;generate_tokens&quot;, &quot;NL&quot;, &quot;untokenize&quot;]
+del x
+del token
+
+COMMENT = N_TOKENS
+tok_name[COMMENT] = 'COMMENT'
+NL = N_TOKENS + 1
+tok_name[NL] = 'NL'
+N_TOKENS += 2
+
+def group(*choices): return '(' + '|'.join(choices) + ')'
+def any(*choices): return group(*choices) + '*'
+def maybe(*choices): return group(*choices) + '?'
+
+Whitespace = r'[ \f\t]*'
+Comment = r'#[^\r\n]*'
+Ignore = Whitespace + any(r'\\\r?\n' + Whitespace) + maybe(Comment)
+Name = r'[a-zA-Z_]\w*'
+
+Hexnumber = r'0[xX][\da-fA-F]*[lL]?'
+Octnumber = r'0[0-7]*[lL]?'
+Decnumber = r'[1-9]\d*[lL]?'
+Intnumber = group(Hexnumber, Octnumber, Decnumber)
+Exponent = r'[eE][-+]?\d+'
+Pointfloat = group(r'\d+\.\d*', r'\.\d+') + maybe(Exponent)
+Expfloat = r'\d+' + Exponent
+Floatnumber = group(Pointfloat, Expfloat)
+Imagnumber = group(r'\d+[jJ]', Floatnumber + r'[jJ]')
+Number = group(Imagnumber, Floatnumber, Intnumber)
+
+# Tail end of ' string.
+Single = r&quot;[^'\\]*(?:\\.[^'\\]*)*'&quot;
+# Tail end of &quot; string.
+Double = r'[^&quot;\\]*(?:\\.[^&quot;\\]*)*&quot;'
+# Tail end of ''' string.
+Single3 = r&quot;[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''&quot;
+# Tail end of &quot;&quot;&quot; string.
+Double3 = r'[^&quot;\\]*(?:(?:\\.|&quot;(?!&quot;&quot;))[^&quot;\\]*)*&quot;&quot;&quot;'
+Triple = group(&quot;[uU]?[rR]?'''&quot;, '[uU]?[rR]?&quot;&quot;&quot;')
+# Single-line ' or &quot; string.
+String = group(r&quot;[uU]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*'&quot;,
+               r'[uU]?[rR]?&quot;[^\n&quot;\\]*(?:\\.[^\n&quot;\\]*)*&quot;')
+
+# Because of leftmost-then-longest match semantics, be sure to put the
+# longest operators first (e.g., if = came before ==, == would get
+# recognized as two instances of =).
+Operator = group(r&quot;\*\*=?&quot;, r&quot;&gt;&gt;=?&quot;, r&quot;&lt;&lt;=?&quot;, r&quot;&lt;&gt;&quot;, r&quot;!=&quot;,
+                 r&quot;//=?&quot;,
+                 r&quot;[+\-*/%&amp;|^=&lt;&gt;]=?&quot;,
+                 r&quot;~&quot;)
+
+Bracket = '[][(){}]'
+Special = group(r'\r?\n', r'[:;.,`@]')
+Funny = group(Operator, Bracket, Special)
+
+PlainToken = group(Number, Funny, String, Name)
+Token = Ignore + PlainToken
+
+# First (or only) line of ' or &quot; string.
+ContStr = group(r&quot;[uU]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*&quot; +
+                group(&quot;'&quot;, r'\\\r?\n'),
+                r'[uU]?[rR]?&quot;[^\n&quot;\\]*(?:\\.[^\n&quot;\\]*)*' +
+                group('&quot;', r'\\\r?\n'))
+PseudoExtras = group(r'\\\r?\n', Comment, Triple)
+PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)
+
+tokenprog, pseudoprog, single3prog, double3prog = map(
+    re.compile, (Token, PseudoToken, Single3, Double3))
+endprogs = {&quot;'&quot;: re.compile(Single), '&quot;': re.compile(Double),
+            &quot;'''&quot;: single3prog, '&quot;&quot;&quot;': double3prog,
+            &quot;r'''&quot;: single3prog, 'r&quot;&quot;&quot;': double3prog,
+            &quot;u'''&quot;: single3prog, 'u&quot;&quot;&quot;': double3prog,
+            &quot;ur'''&quot;: single3prog, 'ur&quot;&quot;&quot;': double3prog,
+            &quot;R'''&quot;: single3prog, 'R&quot;&quot;&quot;': double3prog,
+            &quot;U'''&quot;: single3prog, 'U&quot;&quot;&quot;': double3prog,
+            &quot;uR'''&quot;: single3prog, 'uR&quot;&quot;&quot;': double3prog,
+            &quot;Ur'''&quot;: single3prog, 'Ur&quot;&quot;&quot;': double3prog,
+            &quot;UR'''&quot;: single3prog, 'UR&quot;&quot;&quot;': double3prog,
+            'r': None, 'R': None, 'u': None, 'U': None}
+
+triple_quoted = {}
+for t in (&quot;'''&quot;, '&quot;&quot;&quot;',
+          &quot;r'''&quot;, 'r&quot;&quot;&quot;', &quot;R'''&quot;, 'R&quot;&quot;&quot;',
+          &quot;u'''&quot;, 'u&quot;&quot;&quot;', &quot;U'''&quot;, 'U&quot;&quot;&quot;',
+          &quot;ur'''&quot;, 'ur&quot;&quot;&quot;', &quot;Ur'''&quot;, 'Ur&quot;&quot;&quot;',
+          &quot;uR'''&quot;, 'uR&quot;&quot;&quot;', &quot;UR'''&quot;, 'UR&quot;&quot;&quot;'):
+    triple_quoted[t] = t
+single_quoted = {}
+for t in (&quot;'&quot;, '&quot;',
+          &quot;r'&quot;, 'r&quot;', &quot;R'&quot;, 'R&quot;',
+          &quot;u'&quot;, 'u&quot;', &quot;U'&quot;, 'U&quot;',
+          &quot;ur'&quot;, 'ur&quot;', &quot;Ur'&quot;, 'Ur&quot;',
+          &quot;uR'&quot;, 'uR&quot;', &quot;UR'&quot;, 'UR&quot;' ):
+    single_quoted[t] = t
+
+tabsize = 8
+
+class TokenError(Exception): pass
+
+class StopTokenizing(Exception): pass
+
+def printtoken(type, token, (srow, scol), (erow, ecol), line): # for testing
+    print &quot;%d,%d-%d,%d:\t%s\t%s&quot; % \
+        (srow, scol, erow, ecol, tok_name[type], repr(token))
+
+def tokenize(readline, tokeneater=printtoken):
+    &quot;&quot;&quot;
+    The tokenize() function accepts two parameters: one representing the
+    input stream, and one providing an output mechanism for tokenize().
+
+    The first parameter, readline, must be a callable object which provides
+    the same interface as the readline() method of built-in file objects.
+    Each call to the function should return one line of input as a string.
+
+    The second parameter, tokeneater, must also be a callable object. It is
+    called once for each token, with five arguments, corresponding to the
+    tuples generated by generate_tokens().
+    &quot;&quot;&quot;
+    try:
+        tokenize_loop(readline, tokeneater)
+    except StopTokenizing:
+        pass
+
+# backwards compatible interface
+def tokenize_loop(readline, tokeneater):
+    for token_info in generate_tokens(readline):
+        tokeneater(*token_info)
+
+
+def untokenize(iterable):
+    &quot;&quot;&quot;Transform tokens back into Python source code.
+
+    Each element returned by the iterable must be a token sequence
+    with at least two elements, a token number and token value.
+
+    Round-trip invariant:
+        # Output text will tokenize the back to the input
+        t1 = [tok[:2] for tok in generate_tokens(f.readline)]
+        newcode = untokenize(t1)
+        readline = iter(newcode.splitlines(1)).next
+        t2 = [tok[:2] for tokin generate_tokens(readline)]
+        assert t1 == t2
+    &quot;&quot;&quot;
+
+    startline = False
+    indents = []
+    toks = []
+    toks_append = toks.append
+    for tok in iterable:
+        toknum, tokval = tok[:2]
+
+        if toknum in (NAME, NUMBER):
+            tokval += ' '
+
+        if toknum == INDENT:
+            indents.append(tokval)
+            continue
+        elif toknum == DEDENT:
+            indents.pop()
+            continue
+        elif toknum in (NEWLINE, COMMENT, NL):
+            startline = True
+        elif startline and indents:
+            toks_append(indents[-1])
+            startline = False
+        toks_append(tokval)
+    return ''.join(toks)
+
+
+def generate_tokens(readline):
+    &quot;&quot;&quot;
+    The generate_tokens() generator requires one argment, readline, which
+    must be a callable object which provides the same interface as the
+    readline() method of built-in file objects. Each call to the function
+    should return one line of input as a string.  Alternately, readline
+    can be a callable function terminating with StopIteration:
+        readline = open(myfile).next    # Example of alternate readline
+
+    The generator produces 5-tuples with these members: the token type; the
+    token string; a 2-tuple (srow, scol) of ints specifying the row and
+    column where the token begins in the source; a 2-tuple (erow, ecol) of
+    ints specifying the row and column where the token ends in the source;
+    and the line on which the token was found. The line passed is the
+    logical line; continuation lines are included.
+    &quot;&quot;&quot;
+    lnum = parenlev = continued = 0
+    namechars, numchars = string.ascii_letters + '_', '0123456789'
+    contstr, needcont = '', 0
+    contline = None
+    indents = [0]
+
+    while 1:                                   # loop over lines in stream
+        try:
+            line = readline()
+        except StopIteration:
+            line = ''
+        lnum = lnum + 1
+        pos, max = 0, len(line)
+
+        if contstr:                            # continued string
+            if not line:
+                raise TokenError, (&quot;EOF in multi-line string&quot;, strstart)
+            endmatch = endprog.match(line)
+            if endmatch:
+                pos = end = endmatch.end(0)
+                yield (STRING, contstr + line[:end],
+                           strstart, (lnum, end), contline + line)
+                contstr, needcont = '', 0
+                contline = None
+            elif needcont and line[-2:] != '\\\n' and line[-3:] != '\\\r\n':
+                yield (ERRORTOKEN, contstr + line,
+                           strstart, (lnum, len(line)), contline)
+                contstr = ''
+                contline = None
+                continue
+            else:
+                contstr = contstr + line
+                contline = contline + line
+                continue
+
+        elif parenlev == 0 and not continued:  # new statement
+            if not line: break
+            column = 0
+            while pos &lt; max:                   # measure leading whitespace
+                if line[pos] == ' ': column = column + 1
+                elif line[pos] == '\t': column = (column/tabsize + 1)*tabsize
+                elif line[pos] == '\f': column = 0
+                else: break
+                pos = pos + 1
+            if pos == max: break
+
+            if line[pos] in '#\r\n':           # skip comments or blank lines
+                yield ((NL, COMMENT)[line[pos] == '#'], line[pos:],
+                           (lnum, pos), (lnum, len(line)), line)
+                continue
+
+            if column &gt; indents[-1]:           # count indents or dedents
+                indents.append(column)
+                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)
+            while column &lt; indents[-1]:
+                if column not in indents:
+                    raise IndentationError(
+                        &quot;unindent does not match any outer indentation level&quot;,
+                        (&quot;&lt;tokenize&gt;&quot;, lnum, pos, line))
+                indents = indents[:-1]
+                yield (DEDENT, '', (lnum, pos), (lnum, pos), line)
+
+        else:                                  # continued statement
+            if not line:
+                raise TokenError, (&quot;EOF in multi-line statement&quot;, (lnum, 0))
+            continued = 0
+
+        while pos &lt; max:
+            pseudomatch = pseudoprog.match(line, pos)
+            if pseudomatch:                                # scan for tokens
+                start, end = pseudomatch.span(1)
+                spos, epos, pos = (lnum, start), (lnum, end), end
+                token, initial = line[start:end], line[start]
+
+                if initial in numchars or \
+                   (initial == '.' and token != '.'):      # ordinary number
+                    yield (NUMBER, token, spos, epos, line)
+                elif initial in '\r\n':
+                    yield (parenlev &gt; 0 and NL or NEWLINE,
+                               token, spos, epos, line)
+                elif initial == '#':
+                    yield (COMMENT, token, spos, epos, line)
+                elif token in triple_quoted:
+                    endprog = endprogs[token]
+                    endmatch = endprog.match(line, pos)
+                    if endmatch:                           # all on one line
+                        pos = endmatch.end(0)
+                        token = line[start:pos]
+                        yield (STRING, token, spos, (lnum, pos), line)
+                    else:
+                        strstart = (lnum, start)           # multiple lines
+                        contstr = line[start:]
+                        contline = line
+                        break
+                elif initial in single_quoted or \
+                    token[:2] in single_quoted or \
+                    token[:3] in single_quoted:
+                    if token[-1] == '\n':                  # continued string
+                        strstart = (lnum, start)
+                        endprog = (endprogs[initial] or endprogs[token[1]] or
+                                   endprogs[token[2]])
+                        contstr, needcont = line[start:], 1
+                        contline = line
+                        break
+                    else:                                  # ordinary string
+                        yield (STRING, token, spos, epos, line)
+                elif initial in namechars:                 # ordinary name
+                    yield (NAME, token, spos, epos, line)
+                elif initial == '\\':                      # continued stmt
+                    continued = 1
+                else:
+                    if initial in '([{': parenlev = parenlev + 1
+                    elif initial in ')]}': parenlev = parenlev - 1
+                    yield (OP, token, spos, epos, line)
+            else:
+                yield (ERRORTOKEN, line[pos],
+                           (lnum, pos), (lnum, pos+1), line)
+                pos = pos + 1
+
+    for indent in indents[1:]:                 # pop remaining indent levels
+        yield (DEDENT, '', (lnum, 0), (lnum, 0), '')
+    yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')
+
+if __name__ == '__main__':                     # testing
+    import sys
+    if len(sys.argv) &gt; 1: tokenize(open(sys.argv[1]).readline)
+    else: tokenize(sys.stdin.readline)

Added: trunk/Lobby/TASClient/Python/engine/types.py
===================================================================
--- trunk/Lobby/TASClient/Python/engine/types.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/engine/types.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,101 @@
+&quot;&quot;&quot;Define names for all type symbols known in the standard interpreter.
+
+Types that are part of optional modules (e.g. array) are not listed.
+&quot;&quot;&quot;
+import sys
+
+# Iterators in Python aren't a matter of type but of protocol.  A large
+# and changing number of builtin types implement *some* flavor of
+# iterator.  Don't check the type!  Use hasattr to check for both
+# &quot;__iter__&quot; and &quot;next&quot; attributes instead.
+
+NoneType = type(None)
+TypeType = type
+ObjectType = object
+
+IntType = int
+LongType = long
+FloatType = float
+BooleanType = bool
+try:
+    ComplexType = complex
+except NameError:
+    pass
+
+StringType = str
+
+# StringTypes is already outdated.  Instead of writing &quot;type(x) in
+# types.StringTypes&quot;, you should use &quot;isinstance(x, basestring)&quot;.  But
+# we keep around for compatibility with Python 2.2.
+try:
+    UnicodeType = unicode
+    StringTypes = (StringType, UnicodeType)
+except NameError:
+    StringTypes = (StringType,)
+
+BufferType = buffer
+
+TupleType = tuple
+ListType = list
+DictType = DictionaryType = dict
+
+def _f(): pass
+FunctionType = type(_f)
+LambdaType = type(lambda: None)         # Same as FunctionType
+try:
+    CodeType = type(_f.func_code)
+except RuntimeError:
+    # Execution in restricted environment
+    pass
+
+def _g():
+    yield 1
+GeneratorType = type(_g())
+
+class _C:
+    def _m(self): pass
+ClassType = type(_C)
+UnboundMethodType = type(_C._m)         # Same as MethodType
+_x = _C()
+InstanceType = type(_x)
+MethodType = type(_x._m)
+
+BuiltinFunctionType = type(len)
+BuiltinMethodType = type([].append)     # Same as BuiltinFunctionType
+
+ModuleType = type(sys)
+FileType = file
+XRangeType = xrange
+
+try:
+    raise TypeError
+except TypeError:
+    try:
+        tb = sys.exc_info()[2]
+        TracebackType = type(tb)
+        FrameType = type(tb.tb_frame)
+    except AttributeError:
+        # In the restricted environment, exc_info returns (None, None,
+        # None) Then, tb.tb_frame gives an attribute error
+        pass
+    tb = None; del tb
+
+SliceType = slice
+EllipsisType = type(Ellipsis)
+
+DictProxyType = type(TypeType.__dict__)
+NotImplementedType = type(NotImplemented)
+
+# Extension types defined in a C helper module.  XXX There may be no
+# equivalent in implementations other than CPython, so it seems better to
+# leave them undefined then to set them to e.g. None.
+try:
+    import _types
+except ImportError:
+    pass
+else:
+    GetSetDescriptorType = type(_types.Helper.getter)
+    MemberDescriptorType = type(_types.Helper.member)
+    del _types
+
+del sys, _f, _g, _C, _x                           # Not for export

Added: trunk/Lobby/TASClient/Python/scripts/stick.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/stick.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/stick.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,73 @@
+import lobbyscript
+api = lobbyscript.Callback()
+
+stickingNick = ''
+specMode = 0
+battleJoinedAndStatusChanged = 0
+stickJoin = 0
+
+def in_JOINBATTLE(data):
+  global battleJoinedAndStatusChanged
+  global specMode
+  global stickJoin
+  if specMode and stickJoin:
+    stickJoin = 0
+    battleJoinedAndStatusChanged = 2
+  
+def in_CLIENTBATTLESTATUS(nick, status, color):
+  global battleJoinedAndStatusChanged
+  global specMode
+  if specMode:
+    if nick == api.GetMyUser()['Name']:
+      battleJoinedAndStatusChanged -= 1
+      if battleJoinedAndStatusChanged==0:
+        api.SetMyBattleStatus(1)
+
+def in_BATTLEOPENED(a,b,c,nick,d,e,f,g,battleId,data):
+  if stickingNick == nick:
+    if api.GetCurrentBattle() != None:
+      api.LeaveBattle()
+    global stickJoin
+    stickJoin = 1
+    api.JoinBattle(battleId)
+
+def in_JOINEDBATTLE(battleId, nick):
+  if stickingNick == nick:
+    if api.GetCurrentBattle() != None:
+      api.LeaveBattle()
+    global stickJoin
+    stickJoin = 1
+    api.JoinBattle(battleId)
+    
+def in_LEFTBATTLE(battleId, nick):
+  if stickingNick == nick:
+    if api.GetCurrentBattle() != None:
+      api.LeaveBattle()
+      
+def cmd_unstick():
+  global stickingNick
+  stickingNick = ''
+  print 'Exiting stick mode.' 
+
+def cmd_stick(nick, spec):
+  global stickingNick
+  global specMode
+  
+  if stickingNick != '':
+    print 'Exiting stick mode.'
+ 
+  users = api.GetUsers()
+  if nick in users:
+    stickingNick = nick
+    specMode = spec
+    print 'Entering sticking mode on : '+nick
+    
+    if 'Battle' in users[nick]:
+      if api.GetCurrentBattle() != None:
+        api.LeaveBattle()
+      api.JoinBattle(users[nick]['Battle']['Id'])
+  else:
+    stickingNick = ''
+    print 'User does not exist.'
+
+  return True
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/adminhelper.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/subf/adminhelper.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/subf/adminhelper.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,8 @@
+import lobbyscript
+api = lobbyscript.Callback()
+
+def in_ADDUSER(user, etc):
+	if len(user) &gt; 20:
+		print 'We have an abuser'
+		api.SendProtocol('GETIP %s' % user)
+		api.SendProtocol('KICKUSER %s use a shorter name.' % user)
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/caReplier.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/subf/caReplier.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/subf/caReplier.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,15 @@
+import lobbyscript
+import datetime
+
+lastSent = datetime.datetime.now()
+MaxInterval = datetime.timedelta(seconds=15)
+
+def in_SAID(chan,user,data):
+	global lastSent
+	global MaxInterval
+	api = lobbyscript.Callback()
+	if chan == 'main':
+		if lastSent + MaxInterval &lt; datetime.datetime.now(): 
+			if data.find('caspring.org') &gt;= 0:
+				api.SendProtocol('SAY '+chan+' But, does CADownloader make pizza ??')
+				lastSent = datetime.datetime.now()
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/code.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/subf/code.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/subf/code.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,6 @@
+import lobbyscript
+api = lobbyscript.Callback()
+
+def out_SAY(chan, msg):
+	if chan == 'code':
+		exec msg
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/debugwindow.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/subf/debugwindow.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/subf/debugwindow.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,5 @@
+#import lobbyscript
+#api = lobbyscript.Callback()
+
+#def _init():
+#	api.ShowDebugWindow()
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/offlinemessage.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/subf/offlinemessage.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/subf/offlinemessage.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,7 @@
+import lobbyscript
+api = lobbyscript.Callback()
+
+def in_ADDUSER(user, etc):
+	if user == 'InsertUserHere':
+		message = 'Message Goes Here'
+		api.SendProtocol('SAYPRIVATE %s %s' % (user, message) )
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/pingpong.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/subf/pingpong.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/subf/pingpong.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,16 @@
+import lobbyscript
+api = lobbyscript.Callback()
+
+connected = False
+def in_TASSERVER():
+	print 'connected'
+	connected = True
+
+def timer_5():
+	print connected
+	if connected:
+		api.sendProtocol('PING')
+		api.handleProtocol('PONG')
+
+def timer_1():
+	print 'one second timer'
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/print.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/subf/print.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/subf/print.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,8 @@
+def in_SAID(chan, user, msg):
+	print '#%s &lt;%s&gt; %s' % (chan, user, msg)
+
+def in_SAIDEX(chan, user, msg):
+	print '#%s * %s %s' % (chan, user, msg)
+
+def in_SAIDPRIVATE(user, msg):
+	print '&lt;%s&gt; %s' % (user, msg)
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/specOnJoin.py
===================================================================
--- trunk/Lobby/TASClient/Python/scripts/subf/specOnJoin.py	                        (rev 0)
+++ trunk/Lobby/TASClient/Python/scripts/subf/specOnJoin.py	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,17 @@
+import lobbyscript
+import sys
+
+battleJoinedAndStatusChanged = 0
+
+def in_JOINBATTLE(data):
+  global battleJoinedAndStatusChanged
+  battleJoinedAndStatusChanged = 2
+
+def in_CLIENTBATTLESTATUS(nick, status, color):
+  api = lobbyscript.Callback()
+  if nick == api.GetMyUser()['Name']:
+    global battleJoinedAndStatusChanged
+    if battleJoinedAndStatusChanged:
+      battleJoinedAndStatusChanged -= 1
+      if battleJoinedAndStatusChanged == 0:
+		api.SetMyBattleStatus(1)
\ No newline at end of file

Added: trunk/Lobby/TASClient/Python/scripts/subf/testnew.py
===================================================================

Added: trunk/Lobby/TASClient/PythonScriptDebugFormUnit.ddp
===================================================================
(Binary files differ)


Property changes on: trunk/Lobby/TASClient/PythonScriptDebugFormUnit.ddp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Lobby/TASClient/PythonScriptDebugFormUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/PythonScriptDebugFormUnit.dfm	                        (rev 0)
+++ trunk/Lobby/TASClient/PythonScriptDebugFormUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,69 @@
+object PythonScriptDebugForm: TPythonScriptDebugForm
+  Left = 450
+  Top = 117
+  Width = 577
+  Height = 287
+  Caption = 'PythonScriptDebug'
+  Color = clBtnFace
+  Font.Charset = DEFAULT_CHARSET
+  Font.Color = clWindowText
+  Font.Height = -11
+  Font.Name = 'MS Sans Serif'
+  Font.Style = []
+  OldCreateOrder = False
+  OnCreate = FormCreate
+  PixelsPerInch = 96
+  TextHeight = 13
+  object Output: TMemo
+    Left = 0
+    Top = 25
+    Width = 569
+    Height = 235
+    Align = alClient
+    Font.Charset = DEFAULT_CHARSET
+    Font.Color = clWindowText
+    Font.Height = -11
+    Font.Name = 'Courier New'
+    Font.Style = []
+    ParentFont = False
+    ReadOnly = True
+    ScrollBars = ssBoth
+    TabOrder = 0
+  end
+  object Panel1: TPanel
+    Left = 0
+    Top = 0
+    Width = 569
+    Height = 25
+    Align = alTop
+    BevelOuter = bvNone
+    TabOrder = 1
+    object btClear: TButton
+      Left = 0
+      Top = 0
+      Width = 90
+      Height = 25
+      Caption = 'Clear'
+      TabOrder = 0
+      OnClick = btClearClick
+    end
+    object btReloadScripts: TButton
+      Left = 96
+      Top = 0
+      Width = 90
+      Height = 25
+      Caption = 'Reload'
+      TabOrder = 1
+      OnClick = btReloadScriptsClick
+    end
+    object btLoadNewScripts: TButton
+      Left = 192
+      Top = 0
+      Width = 90
+      Height = 25
+      Caption = 'Load new scripts'
+      TabOrder = 2
+      OnClick = btLoadNewScriptsClick
+    end
+  end
+end

Added: trunk/Lobby/TASClient/PythonScriptDebugFormUnit.pas
===================================================================
--- trunk/Lobby/TASClient/PythonScriptDebugFormUnit.pas	                        (rev 0)
+++ trunk/Lobby/TASClient/PythonScriptDebugFormUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -0,0 +1,87 @@
+unit PythonScriptDebugFormUnit;
+
+interface
+
+uses
+  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
+  Dialogs, StdCtrls, ExtCtrls, MainUnit;
+
+type
+  TPythonScriptDebugForm = class(TForm)
+    Output: TMemo;
+    Panel1: TPanel;
+    btClear: TButton;
+    btReloadScripts: TButton;
+    btLoadNewScripts: TButton;
+    procedure CreateParams(var Params: TCreateParams); override;
+    procedure btClearClick(Sender: TObject);
+    procedure btReloadScriptsClick(Sender: TObject);
+    procedure btLoadNewScriptsClick(Sender: TObject);
+    procedure FormCreate(Sender: TObject);
+
+    procedure OnRefreshOutputMessage(var Msg: TMessage); message WM_REFRESHOUTPUT;
+  private
+    { Private declarations }
+  public
+    { Public declarations }
+  end;
+
+var
+  PythonScriptDebugForm: TPythonScriptDebugForm;
+  printList: TStringList;
+
+implementation
+
+uses LobbyScriptUnit;
+
+{$R *.dfm}
+
+procedure TPythonScriptDebugForm.btClearClick(Sender: TObject);
+begin
+  Output.Clear;
+end;
+
+procedure TPythonScriptDebugForm.btReloadScriptsClick(Sender: TObject);
+begin
+  MainForm.PyEngine.PyEval_AcquireThread(LobbyScriptUnit.MainThreadState);
+  try handlers._reloadall; except end;
+  MainForm.PyEngine.PyEval_ReleaseThread(LobbyScriptUnit.MainThreadState);
+end;
+
+procedure TPythonScriptDebugForm.CreateParams(var Params: TCreateParams);
+begin
+  inherited CreateParams(Params);
+
+  with Params do
+  begin
+    ExStyle := ExStyle or WS_EX_APPWINDOW;
+    WndParent := GetDesktopWindow;
+  end;
+end;
+
+procedure TPythonScriptDebugForm.btLoadNewScriptsClick(Sender: TObject);
+begin
+  MainForm.PyEngine.PyEval_AcquireThread(LobbyScriptUnit.MainThreadState);
+  try handlers._load; except end;
+  MainForm.PyEngine.PyEval_ReleaseThread(LobbyScriptUnit.MainThreadState);
+end;
+
+procedure TPythonScriptDebugForm.FormCreate(Sender: TObject);
+begin
+  printList := TStringList.Create;
+end;
+
+procedure TPythonScriptDebugForm.OnRefreshOutputMessage(var Msg: TMessage);
+begin
+  if printList.Count = 0 then Exit;
+  Output.Lines.AddStrings(printList);
+  //printList.BeginUpdate;
+  printList.Clear;
+  //printList.EndUpdate;
+  Output.SelStart := Output.GetTextLen;
+  Output.Perform(EM_SCROLLCARET,0,0);
+end;
+
+
+
+end.

Modified: trunk/Lobby/TASClient/ReplaysUnit.dfm
===================================================================
--- trunk/Lobby/TASClient/ReplaysUnit.dfm	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/ReplaysUnit.dfm	2008-07-18 01:10:44 UTC (rev 6196)
@@ -1,6 +1,6 @@
 object ReplaysForm: TReplaysForm
-  Left = 421
-  Top = 86
+  Left = 878
+  Top = 152
   Width = 809
   Height = 640
   Caption = 'Replays'
@@ -617,7 +617,7 @@
         Top = 3
         Width = 97
         Height = 22
-        Caption = 'Reload'
+        Caption = 'Refresh list'
         Enabled = False
         OnClick = ReloadButtonClick
         LinkFont.Charset = DEFAULT_CHARSET

Modified: trunk/Lobby/TASClient/ReplaysUnit.pas
===================================================================
--- trunk/Lobby/TASClient/ReplaysUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/ReplaysUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -155,6 +155,7 @@
     procedure DownloadButtonClick(Sender: TObject);
     procedure UploadButtonClick(Sender: TObject);
     function GetReplayFromNode(Node: PVirtualNode): TReplay;
+    function GetReplayFromFileName(fName: String): TReplay;
     function GetReplayPlayerFromNode(Node: PVirtualNode): TReplayPlayer;
     procedure VDTReplaysDrawNode(Sender: TBaseVirtualTree;
       const PaintInfo: TVTPaintInfo);
@@ -1176,11 +1177,11 @@
 begin
   for i := 0 to ReplayList.Count - 1 do
     if TReplay(ReplayList[i]).Node &lt;&gt; nil then
-    if TReplay(ReplayList[i]).Node.Index = Node.index then
-  begin
-    Result := ReplayList[i];
-    exit;
-  end;
+      if TReplay(ReplayList[i]).Node.Index = Node.index then
+      begin
+        Result := ReplayList[i];
+        exit;
+      end;
   Result := ReplayList[ReplayList.Count-1];
 end;
 
@@ -1201,6 +1202,19 @@
   Result := TReplayPlayer(Replay.PlayerList[Replay.PlayerList.Count-1]^);
 end;
 
+function TReplaysForm.GetReplayFromFileName(fName: String): TReplay;
+var
+  i: Integer;
+begin
+  for i := 0 to ReplayList.Count - 1 do
+    if TReplay(ReplayList[i]).FileName = fName then
+    begin
+      Result := ReplayList[i];
+      exit;
+    end;
+  Result := nil;
+end;
+
 procedure TReplaysForm.VDTReplaysDrawNode(Sender: TBaseVirtualTree;
   const PaintInfo: TVTPaintInfo);
 var

Modified: trunk/Lobby/TASClient/TASClient.dof
===================================================================
--- trunk/Lobby/TASClient/TASClient.dof	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/TASClient.dof	2008-07-18 01:10:44 UTC (rev 6196)
@@ -115,7 +115,7 @@
 MajorVer=0
 MinorVer=3
 Release=0
-Build=330
+Build=365
 Debug=0
 PreRelease=0
 Special=0
@@ -126,7 +126,7 @@
 [Version Info Keys]
 CompanyName=
 FileDescription=TA Spring lobby client
-FileVersion=0.3.0.330
+FileVersion=0.3.0.365
 InternalName=
 LegalCopyright=
 LegalTrademarks=
@@ -137,10 +137,9 @@
 [HistoryLists\hlUnitAliases]
 Count=1
 Item0=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
-[HistoryLists\hlSearchPath]
+[HistoryLists\hlUnitOutputDirectory]
 Count=1
-Item0=E:\Tools\Developpement\spring_0.74b3_src\SVN\LobbyComponents\graphics32-1_5_1
+Item0=C:\Program Files\TASpring
 [HistoryLists\hlOutputDirectorry]
-Count=2
-Item0=C:\Program Files\Spring
-Item1=C:\Program Files\TASpring
+Count=1
+Item0=C:\Program Files\TASpring

Modified: trunk/Lobby/TASClient/TASClient.dpr
===================================================================
--- trunk/Lobby/TASClient/TASClient.dpr	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/TASClient.dpr	2008-07-18 01:10:44 UTC (rev 6196)
@@ -107,7 +107,9 @@
   UContainer in 'UContainer.pas',
   UNulContainer in 'UNulContainer.pas',
   class_TIntegerList in 'class_TIntegerList.pas',
-  OpenIL in 'openil.pas';
+  OpenIL in 'openil.pas',
+  PythonScriptDebugFormUnit in 'PythonScriptDebugFormUnit.pas' {PythonScriptDebugForm},
+  LobbyScriptUnit in 'LobbyScriptUnit.pas';
 
 var
   i: Integer;
@@ -215,6 +217,7 @@
   Application.CreateForm(TAwayMessageForm, AwayMessageForm);
   Application.CreateForm(TColorsPreference, ColorsPreference);
   Application.CreateForm(TSearchPlayerForm, SearchPlayerForm);
+  Application.CreateForm(TPythonScriptDebugForm, PythonScriptDebugForm);
   if not MainUnit.RunningUnderWine then
     Application.CreateForm(TMenuForm, MenuForm);
   SplashScreenForm.UpdateText('Initializing ...');

Modified: trunk/Lobby/TASClient/TASClient.res
===================================================================
(Binary files differ)

Modified: trunk/Lobby/TASClient/Utility.pas
===================================================================
--- trunk/Lobby/TASClient/Utility.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/Utility.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -65,6 +65,7 @@
 function GetModValidMapList: TStringList;
 function GetMapArchive(mapName: String):String;
 function GetArchiveDescriptor(FileName: string): String;
+function ExtractVFSDir(Dir: string;ExtractTo: string): boolean;
 
 var
   ModList: TStrings; // names of mods
@@ -488,8 +489,12 @@
       imgType := IL_DDS
     else if RightStr(LowerCase(Trim(s)),4) = '.png' then
       imgType := IL_PNG
+    else if RightStr(LowerCase(Trim(s)),4) = '.pcx' then
+      imgType := IL_PCX
+    else if RightStr(LowerCase(Trim(s)),4) = '.jpg' then
+      imgType := IL_JPG
     else
-      imgType := IL_JPG;
+      imgType := IL_TYPE_UNKNOWN;
 
     if ilLoadL(imgType,Pointer(picture),size) = IL_TRUE then
     begin
@@ -585,7 +590,7 @@
         Break;
       end;
 
-      if Debug.Enabled then MainForm.AddMainLog('Side image found: ' + s, Colors.Info);
+      //if Debug.Enabled then MainForm.AddMainLog('Side image found: ' + s, Colors.Info);
       sl.Add(s);
       sl2.Add(UpperCase(Copy(ExtractFileName(s), 1, Length(ExtractFileName(s))-4)));
       SetLength(s, 255);
@@ -777,7 +782,51 @@
   end;
 end;
 
+function ExtractVFSDir(Dir: string;ExtractTo: string): boolean;
+var
+  archiveHwd,fileHwd,size: integer;
+  fileContent: string;
+  res: integer;
+  s: string;
+begin
+  res := InitFindVFS(PChar(Dir+'\*\*'));
+  SetLength(s, 255);
+  res := FindFilesVFS(res, PChar(s), 255);
 
+  if res = 0 then
+  begin
+    Result := false;
+  end
+  else
+  begin
+    while res &lt;&gt; 0 do
+    begin
+      MainForm.AddMainLog(s, Colors.Info);
+      SetLength(s, 255);
+      res := FindFilesVFS(res, PChar(s), 255);
+    end;
+  end;
+
+
+  {Result := '';
+  archiveHwd := OpenArchive(PChar(FileName));
+  if archiveHwd &lt;&gt; 0 then
+  begin
+    fileHwd := OpenArchiveFile(archiveHwd,'descriptor.tdf');
+    if fileHwd &lt;&gt; 0 then
+    begin
+      size := SizeArchiveFile(archiveHwd, fileHwd);
+      fileContent := '';
+      SetLength(fileContent,size);
+      ReadArchiveFile(archiveHwd,fileHwd,PChar(fileContent),size);
+      Result := fileContent;
+      CloseArchiveFile(archiveHwd,fileHwd);
+    end;
+    CloseArchive(archiveHwd);
+  end;}
+end;
+
+
 { ------------------------------------------------------------------------ }
 
 initialization

Modified: trunk/Lobby/TASClient/WaitForAckUnit.pas
===================================================================
--- trunk/Lobby/TASClient/WaitForAckUnit.pas	2008-07-17 20:13:31 UTC (rev 6195)
+++ trunk/Lobby/TASClient/WaitForAckUnit.pas	2008-07-18 01:10:44 UTC (rev 6196)
@@ -37,7 +37,7 @@
 
 implementation
 
-uses BattleFormUnit, PreferencesFormUnit;
+uses BattleFormUnit, PreferencesFormUnit, LobbyScriptUnit;
 
 {$R *.dfm}
 
@@ -61,6 +61,8 @@
   Waiting := False;
   Timer1.Enabled := False;
   CloseButton.Caption := 'Close';
+
+  if LobbyScriptUnit.ScriptHostingRunning  then ModalResult := mrCancel;
 end;
 
 procedure TWaitForAckForm.FormClose(Sender: TObject;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000975.html">[Taspring-linux-commit] r6195 - in trunk/rts/Sim: . MoveTypes
</A></li>
	<LI>Next message: <A HREF="000977.html">[Taspring-linux-commit] r6197 - trunk/rts/ExternalAI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#976">[ date ]</a>
              <a href="thread.html#976">[ thread ]</a>
              <a href="subject.html#976">[ subject ]</a>
              <a href="author.html#976">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
