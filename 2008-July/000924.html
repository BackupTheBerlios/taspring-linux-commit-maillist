<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6144 - in trunk: .	AI/Global/CSAI/BuildTools game/LuaUI game/LuaUI/Widgets rts	rts/ExternalAI rts/Game rts/Game/UI rts/Lua rts/Map	rts/Map/SMF rts/Rendering rts/Rendering/Env rts/Rendering/GL	rts/Rendering/Textures rts/Rendering/UnitModels rts/Sim	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes	rts/Sim/Objects rts/Sim/Path rts/Sim/Projectiles	rts/Sim/Units rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Units/UnitTypes rts/Sim/Weapons rts/System	rts/System/FileSystem rts/System/Platform	rts/System/Platform/Linux rts/System/Script rts/build/scons	rts/lib/gml rts/lib/lua rts/lib/lua/include rts/lib/lua/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6144%20-%20in%20trunk%3A%20.%0A%09AI/Global/CSAI/BuildTools%20game/LuaUI%20game/LuaUI/Widgets%20rts%0A%09rts/ExternalAI%20rts/Game%20rts/Game/UI%20rts/Lua%20rts/Map%0A%09rts/Map/SMF%20rts/Rendering%20rts/Rendering/Env%20rts/Rendering/GL%0A%09rts/Rendering/Textures%20rts/Rendering/UnitModels%20rts/Sim%0A%09rts/Sim/Features%20rts/Sim/Misc%20rts/Sim/MoveTypes%0A%09rts/Sim/Objects%20rts/Sim/Path%20rts/Sim/Projectiles%0A%09rts/Sim/Units%20rts/Sim/Units/COB%20rts/Sim/Units/CommandAI%0A%09rts/Sim/Units/UnitTypes%20rts/Sim/Weapons%20rts/System%0A%09rts/System/FileSystem%20rts/System/Platform%0A%09rts/System/Platform/Linux%20rts/System/Script%20rts/build/scons%0A%09rts/lib/gml%20rts/lib/lua%20rts/lib/lua/include%20rts/lib/lua/src&In-Reply-To=%3C20080711211831.3C0114636%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000923.html">
   <LINK REL="Next"  HREF="000925.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6144 - in trunk: .	AI/Global/CSAI/BuildTools game/LuaUI game/LuaUI/Widgets rts	rts/ExternalAI rts/Game rts/Game/UI rts/Lua rts/Map	rts/Map/SMF rts/Rendering rts/Rendering/Env rts/Rendering/GL	rts/Rendering/Textures rts/Rendering/UnitModels rts/Sim	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes	rts/Sim/Objects rts/Sim/Path rts/Sim/Projectiles	rts/Sim/Units rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Units/UnitTypes rts/Sim/Weapons rts/System	rts/System/FileSystem rts/System/Platform	rts/System/Platform/Linux rts/System/Script rts/build/scons	rts/lib/gml rts/lib/lua rts/lib/lua/include rts/lib/lua/src</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6144%20-%20in%20trunk%3A%20.%0A%09AI/Global/CSAI/BuildTools%20game/LuaUI%20game/LuaUI/Widgets%20rts%0A%09rts/ExternalAI%20rts/Game%20rts/Game/UI%20rts/Lua%20rts/Map%0A%09rts/Map/SMF%20rts/Rendering%20rts/Rendering/Env%20rts/Rendering/GL%0A%09rts/Rendering/Textures%20rts/Rendering/UnitModels%20rts/Sim%0A%09rts/Sim/Features%20rts/Sim/Misc%20rts/Sim/MoveTypes%0A%09rts/Sim/Objects%20rts/Sim/Path%20rts/Sim/Projectiles%0A%09rts/Sim/Units%20rts/Sim/Units/COB%20rts/Sim/Units/CommandAI%0A%09rts/Sim/Units/UnitTypes%20rts/Sim/Weapons%20rts/System%0A%09rts/System/FileSystem%20rts/System/Platform%0A%09rts/System/Platform/Linux%20rts/System/Script%20rts/build/scons%0A%09rts/lib/gml%20rts/lib/lua%20rts/lib/lua/include%20rts/lib/lua/src&In-Reply-To=%3C20080711211831.3C0114636%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6144 - in trunk: .	AI/Global/CSAI/BuildTools game/LuaUI game/LuaUI/Widgets rts	rts/ExternalAI rts/Game rts/Game/UI rts/Lua rts/Map	rts/Map/SMF rts/Rendering rts/Rendering/Env rts/Rendering/GL	rts/Rendering/Textures rts/Rendering/UnitModels rts/Sim	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes	rts/Sim/Objects rts/Sim/Path rts/Sim/Projectiles	rts/Sim/Units rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Units/UnitTypes rts/Sim/Weapons rts/System	rts/System/FileSystem rts/System/Platform	rts/System/Platform/Linux rts/System/Script rts/build/scons	rts/lib/gml rts/lib/lua rts/lib/lua/include rts/lib/lua/src">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Jul 11 23:18:30 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000923.html">[Taspring-linux-commit] r6143 - trunk/rts/lib/lua/src
</A></li>
        <LI>Next message: <A HREF="000925.html">[Taspring-linux-commit] r6145 - in trunk:	installer/builddata/springcontent/shaders rts/Rendering/Env	rts/System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#924">[ date ]</a>
              <a href="thread.html#924">[ thread ]</a>
              <a href="subject.html#924">[ subject ]</a>
              <a href="author.html#924">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: trepan
Date: 2008-07-11 23:18:27 +0200 (Fri, 11 Jul 2008)
New Revision: 6144

Added:
   trunk/rts/Lua/LuaIO.cpp
   trunk/rts/Lua/LuaIO.h
   trunk/rts/Sim/Units/UnitDefImage.h
   trunk/rts/System/EventClient.cpp
   trunk/rts/System/EventClient.h
   trunk/rts/System/EventHandler.cpp
   trunk/rts/System/EventHandler.h
Removed:
   trunk/rts/Lua/LuaCallInHandler.cpp
   trunk/rts/Lua/LuaCallInHandler.h
   trunk/rts/Sim/Units/UnitImage.h
Modified:
   trunk/AI/Global/CSAI/BuildTools/_UnitDefProxy.h
   trunk/SConstruct
   trunk/game/LuaUI/Widgets/camera_smooth_move.lua
   trunk/game/LuaUI/Widgets/gui_xray_shader.lua
   trunk/game/LuaUI/callins.lua
   trunk/game/LuaUI/fonts.lua
   trunk/game/LuaUI/widgets.lua
   trunk/rts/CMakeLists.txt
   trunk/rts/ExternalAI/Group.cpp
   trunk/rts/Game/Game.cpp
   trunk/rts/Game/GameHelper.cpp
   trunk/rts/Game/Player.cpp
   trunk/rts/Game/SelectedUnits.cpp
   trunk/rts/Game/Team.cpp
   trunk/rts/Game/UI/GameSetupDrawer.cpp
   trunk/rts/Game/UI/GuiHandler.cpp
   trunk/rts/Game/UI/GuiHandler.h
   trunk/rts/Game/UI/LuaUI.cpp
   trunk/rts/Game/UI/MiniMap.cpp
   trunk/rts/Game/UI/MouseHandler.cpp
   trunk/rts/Game/UI/TooltipConsole.cpp
   trunk/rts/Lua/LuaFeatureDefs.cpp
   trunk/rts/Lua/LuaHandle.cpp
   trunk/rts/Lua/LuaHandle.h
   trunk/rts/Lua/LuaHandleSynced.cpp
   trunk/rts/Lua/LuaInputReceiver.cpp
   trunk/rts/Lua/LuaMaterial.cpp
   trunk/rts/Lua/LuaOpenGL.cpp
   trunk/rts/Lua/LuaOpenGL.h
   trunk/rts/Lua/LuaParser.cpp
   trunk/rts/Lua/LuaPathFinder.cpp
   trunk/rts/Lua/LuaRules.cpp
   trunk/rts/Lua/LuaShaders.cpp
   trunk/rts/Lua/LuaShaders.h
   trunk/rts/Lua/LuaSyncedCtrl.cpp
   trunk/rts/Lua/LuaSyncedCtrl.h
   trunk/rts/Lua/LuaSyncedMoveCtrl.cpp
   trunk/rts/Lua/LuaSyncedRead.cpp
   trunk/rts/Lua/LuaSyncedRead.h
   trunk/rts/Lua/LuaUnitDefs.cpp
   trunk/rts/Lua/LuaUnitRendering.cpp
   trunk/rts/Lua/LuaUnsyncedCtrl.cpp
   trunk/rts/Lua/LuaUnsyncedCtrl.h
   trunk/rts/Lua/LuaUnsyncedRead.cpp
   trunk/rts/Lua/LuaUnsyncedRead.h
   trunk/rts/Lua/LuaUtils.cpp
   trunk/rts/Lua/LuaVFS.cpp
   trunk/rts/Lua/LuaWeaponDefs.cpp
   trunk/rts/Map/BasicMapDamage.cpp
   trunk/rts/Map/MapInfo.cpp
   trunk/rts/Map/MapInfo.h
   trunk/rts/Map/SMF/BFGroundDrawer.cpp
   trunk/rts/Map/SMF/SmfReadMap.cpp
   trunk/rts/Rendering/Env/AdvWater.cpp
   trunk/rts/Rendering/Env/BumpWater.cpp
   trunk/rts/Rendering/Env/DynWater.cpp
   trunk/rts/Rendering/GL/myGL.h
   trunk/rts/Rendering/IconHandler.cpp
   trunk/rts/Rendering/IconHandler.h
   trunk/rts/Rendering/ShadowHandler.cpp
   trunk/rts/Rendering/Textures/Bitmap.cpp
   trunk/rts/Rendering/Textures/Bitmap.h
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Sim/Features/FeatureHandler.cpp
   trunk/rts/Sim/Misc/LosHandler.cpp
   trunk/rts/Sim/Misc/LosHandler.h
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
   trunk/rts/Sim/Objects/SolidObject.cpp
   trunk/rts/Sim/Path/PathEstimator.cpp
   trunk/rts/Sim/Projectiles/ExplosionGenerator.cpp
   trunk/rts/Sim/Projectiles/ExplosionGenerator.h
   trunk/rts/Sim/Projectiles/Projectile.cpp
   trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
   trunk/rts/Sim/Projectiles/ProjectileHandler.h
   trunk/rts/Sim/SideParser.cpp
   trunk/rts/Sim/Units/COB/CobInstance.cpp
   trunk/rts/Sim/Units/CommandAI/Command.cpp
   trunk/rts/Sim/Units/CommandAI/Command.h
   trunk/rts/Sim/Units/CommandAI/CommandAI.cpp
   trunk/rts/Sim/Units/CommandAI/CommandQueue.h
   trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/Unit.h
   trunk/rts/Sim/Units/UnitDef.h
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/Sim/Units/UnitDefHandler.h
   trunk/rts/Sim/Units/UnitHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/Sim/Units/UnitTypes/Builder.cpp
   trunk/rts/Sim/Units/UnitTypes/Factory.cpp
   trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp
   trunk/rts/Sim/Weapons/Weapon.cpp
   trunk/rts/System/FileSystem/FileHandler.h
   trunk/rts/System/FileSystem/VFSModes.h
   trunk/rts/System/GlobalStuff.cpp
   trunk/rts/System/GlobalStuff.h
   trunk/rts/System/Platform/FileSystem.cpp
   trunk/rts/System/Platform/FileSystem.h
   trunk/rts/System/Platform/Linux/UnixFileSystemHandler.cpp
   trunk/rts/System/Script/LuaFunctions.cpp
   trunk/rts/System/SpringApp.cpp
   trunk/rts/build/scons/rts.py
   trunk/rts/lib/gml/gml.cpp
   trunk/rts/lib/gml/gml.h
   trunk/rts/lib/gml/gmlsrv.h
   trunk/rts/lib/lua/README_SPRING
   trunk/rts/lib/lua/include/LuaInclude.h
   trunk/rts/lib/lua/include/lua.h
   trunk/rts/lib/lua/include/luaconf.h
   trunk/rts/lib/lua/src/lapi.cpp
   trunk/rts/lib/lua/src/liolib.cpp
   trunk/rts/lib/lua/src/lmathlib.cpp
   trunk/rts/lib/lua/src/loslib.cpp
   trunk/rts/lib/lua/src/lstate.cpp
   trunk/rts/lib/lua/src/lstate.h
   trunk/rts/lib/lua/src/lvm.cpp
Log:

*** NOTE ***

  I expect a little breakage with this one ...
  committing to see how the buildbot reacts to it.

***********

- ifdef'ed all GML dependencies with USE_GML
  (I don't want it &quot;sort of&quot; removed, I want it gone)

- replaced LuaCallInHandler (luaCallIns) with EventHandler (eventHandler)
  (CLuaHandle is now based on CEventClient, as could external AIs be)

- fixed Projectile IDs so that they won't exceed lua's integer range
  as quickly (lua uses float, with a 2^24 contiguous integer range)
  With the comment example of 1000 projectiles per frame (extreme), you
  wouldn't get past 10 minutes.

- fixed LuaSyncedCtrl::ParseProjectile so that it checks for allyTeam control

- removed the std::pair&lt;&gt; cruft from EventHandler

- added geometry shader support to LuaOpenGL

- added the new call-ins:
  - PlayerChanged(playerID)  (player changed team or spectating state)
  - TeamChanged(teamID)      (team changed allyteam, not useful yet)
  - UnitCommand(unitID, unitDefID, unitTeam, cmdID, cmdOpts, cmdParams)
      * note that cmdOpts is a number

- added LuaSyncedRead Spring.GetUnitLastAttacker()

- added LuaSyncedRead Spring.GetUnitFuel()
- added LuaSyncedCtrl Spring.SetUnitFuel()

- replaced Spring.GetMouseMiniMapState() with:
    Spring.GetMiniMapGeometry() -&gt;
      posX, posY, sizeX, sizeY, minimized, maximized, &lt;false | &quot;left&quot; | &quot;right&quot;&gt;

- added LuaSyncedRead Spring.GetUnitSensorRadius(unitID, &lt;type&gt;)
- added LuaSyncedCtrl Spring.SetUnitSensorRadius(unitID, &lt;type&gt;, radius)
    &lt;type&gt; can be:
      'los'
      'airLos'
      'radar'
      'radarJammer'
      'sonar'
      'sonarJammer'
      'seismic'

- lua unit 'facing' parameters can now use long strings:
    'north', 'south', 'east', 'west'

- the Spring.UnitCreated() call-out now accepts unitDef names and unitDef IDs

- fonts.lua can load fonts from the VFS
  (and will create LuaUI/Fonts/ if it does not exist)

- replaced some lua_gettop() checks with luaL_check...()

- added the lua_toint(), lua_tofloat(), and luaL_checkfloat() convenience calls

- renamed CommandDescription's  onlyKey  to  hidden

- copied CommandDescription's  disabled  property in ExternalAI/Group.cpp




Modified: trunk/AI/Global/CSAI/BuildTools/_UnitDefProxy.h
===================================================================
--- trunk/AI/Global/CSAI/BuildTools/_UnitDefProxy.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/AI/Global/CSAI/BuildTools/_UnitDefProxy.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -143,7 +143,7 @@
    int get_buildingDecalSizeX(){ return actualunitdef-&gt;buildingDecalSizeX; }
    int get_buildingDecalSizeY(){ return actualunitdef-&gt;buildingDecalSizeY; }
    double get_buildingDecalDecaySpeed(){ return actualunitdef-&gt;buildingDecalDecaySpeed; }
-   bool get_isfireplatform(){ return actualunitdef-&gt;isfireplatform; }
+   bool get_isfireplatform(){ return actualunitdef-&gt;isFirePlatform; }
    bool get_showNanoFrame(){ return actualunitdef-&gt;showNanoFrame; }
    bool get_showNanoSpray(){ return actualunitdef-&gt;showNanoSpray; }
    double get_maxFuel(){ return actualunitdef-&gt;maxFuel; }

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/SConstruct	2008-07-11 21:18:27 UTC (rev 6144)
@@ -90,6 +90,7 @@
 unitsync_extra_files = [
 	'rts/Game/GameVersion.cpp',
 	'rts/Lua/LuaUtils.cpp',
+	'rts/Lua/LuaIO.cpp',
 	'rts/Lua/LuaParser.cpp',
 	'rts/Map/MapParser.cpp',
 	'rts/Rendering/Textures/Bitmap.cpp',

Modified: trunk/game/LuaUI/Widgets/camera_smooth_move.lua
===================================================================
--- trunk/game/LuaUI/Widgets/camera_smooth_move.lua	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/game/LuaUI/Widgets/camera_smooth_move.lua	2008-07-11 21:18:27 UTC (rev 6144)
@@ -158,6 +158,7 @@
 end
 
 
+-- FIXME -- this algo could still use some lovin'
 function widget:MouseWheel(up, value)
   local cs = spGetCameraState()
   local a,c,m,s = spGetModKeyState()
@@ -168,7 +169,6 @@
     print(dy)
     spSetCameraState({
       py = py + dy,
---      vy = cs.vy + value,
     }, 0)
     return true
   end
@@ -185,7 +185,6 @@
     local dy = gpos[2] - cs.py
     local dz = gpos[3] - cs.pz
     local d = math.sqrt((dx * dx) + (dy * dy) + (dz * dz))
---    local s = (up and -1 or 1) / d
     local s = (up and 1 or -1) * (1 / 8)
     
     dx = dx * s
@@ -205,71 +204,36 @@
 end
 
 
-function widget:MouseWheel2(up, value)
-  local cs = spGetCameraState()
-  local a,c,m,s = spGetModKeyState()
-  if (not m) then
-    local py = math.abs(cs.py)
-    local dy = (1 + math.pow(py * 100, 0.25)) * (up and -1 or 1)
-    local dy = (py / 10) * (up and -1 or 1)
-    print(dy)
-    spSetCameraState({
-      py = py + dy,
---      vy = cs.vy + value,
-    }, 0)
-    return true
-  end
-  if (cs.name ~= 'free') then
-    return false
-  end
-  local scale = value * 10
-  local mx, my = spGetMouseState()
-  local _, gpos = spTraceScreenRay(mx, my, true)
-  if (not gpos) then
-    spSetCameraState({ vy = cs.vy + scale}, 0)
-  else
-    local dx = gpos[1] - cs.px
-    local dy = gpos[2] - cs.py
-    local dz = gpos[3] - cs.pz
-    local d = math.sqrt((dx * dx) + (dy * dy) + (dz * dz))
-    local s = -scale / d
-    dx = dx * s
-    dy = dy * s
-    dz = dz * s
-    local newCS = {
-      vx = cs.vx + dx,
-      vy = cs.vy + dy,
-      vz = cs.vz + dz,
-    }
-    spSetCameraState(newCS, 0)
-  end
-  return true
-end
-
-
 local function DrawPoint(x, y, c, s)
   glPointSize(s)
   glColor(c)
-  glBeginEnd(GL_POINTS, function(x, y)
-    glVertex(x, y)
-  end, x, y)
+  glBeginEnd(GL_POINTS, glVertex, x, y)
 end
 
 
+local function DrawLine(x0, y0, c0, x1, y1, c1)
+  glColor(c0); glVertex(x0, y0)
+  glColor(c1); glVertex(x1, y1)
+end
+
+
+local red   = { 1, 0, 0 }
+local green = { 0, 1, 0 }
+local black = { 0, 0, 0 }
+local white = { 1, 1, 1 }
+
+
 function widget:DrawScreen()
   if (active) then
     local x, y = spGetMouseState()
 
-    DrawPoint(mx, my, { 0, 0, 0 }, 14)
-    DrawPoint(mx, my, { 1, 1, 1 }, 11)
-    DrawPoint(mx, my, { 0, 0, 0 },  8)
-    DrawPoint(mx, my, { 1, 0, 0 },  5)
+    DrawPoint(mx, my, black, 14)
+    DrawPoint(mx, my, white, 11)
+    DrawPoint(mx, my, black,  8)
+    DrawPoint(mx, my, red,    5)
 
     glLineWidth(2)
-    glBeginEnd(GL_LINES, function()
-      glColor(0, 1, 0); glVertex(x,  y)
-      glColor(1, 0, 0); glVertex(mx, my)
-    end)
+    glBeginEnd(GL_LINES, DrawLine, x, y, green, mx, my, red)
     glLineWidth(1)
 
     DrawPoint(x, y, { 0, 1, 0 },  5)

Modified: trunk/game/LuaUI/Widgets/gui_xray_shader.lua
===================================================================
--- trunk/game/LuaUI/Widgets/gui_xray_shader.lua	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/game/LuaUI/Widgets/gui_xray_shader.lua	2008-07-11 21:18:27 UTC (rev 6144)
@@ -48,6 +48,7 @@
 local spGetTeamList          = Spring.GetTeamList
 local spGetTeamUnits         = Spring.GetTeamUnits
 local spIsUnitVisible        = Spring.IsUnitVisible
+local spIsUnitIconic         = Spring.IsUnitIconic
 
 
 --------------------------------------------------------------------------------
@@ -104,15 +105,15 @@
 
       void main()
       {
-              vec4 P = gl_ModelViewMatrix * gl_Vertex;
+        vec4 P = gl_ModelViewMatrix * gl_Vertex;
               
-              eyeVec = P.xyz;
+        eyeVec = P.xyz;
               
-              normal  = gl_NormalMatrix * gl_Normal;
+        normal  = gl_NormalMatrix * gl_Normal;
               
-              color = gl_Color.rgb;
+        color = gl_Color.rgb;
               
-              gl_Position = gl_ProjectionMatrix * P;
+        gl_Position = gl_ProjectionMatrix * P;
       }
     ]],  
  
@@ -125,12 +126,12 @@
 
       void main()
       {
-          float opac = dot(normalize(normal), normalize(eyeVec));
-          opac = 1.0 - abs(opac);
-          opac = pow(opac, edgeExponent);
+        float opac = dot(normalize(normal), normalize(eyeVec));
+        opac = 1.0 - abs(opac);
+        opac = pow(opac, edgeExponent);
           
-          gl_FragColor.rgb = color;
-          gl_FragColor.a = opac;
+        gl_FragColor.rgb = color;
+        gl_FragColor.a = opac;
       }
     ]],
   })
@@ -188,7 +189,7 @@
   for _, teamID in ipairs(spGetTeamList()) do
     SetTeamColor(teamID)
     for _, unitID in ipairs(spGetTeamUnits(teamID)) do
-      if (spIsUnitVisible(unitID)) then
+      if (spIsUnitVisible(unitID, nil, true)) then
         glUnit(unitID, true)
       end
     end

Modified: trunk/game/LuaUI/callins.lua
===================================================================
--- trunk/game/LuaUI/callins.lua	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/game/LuaUI/callins.lua	2008-07-11 21:18:27 UTC (rev 6144)
@@ -41,6 +41,7 @@
   &quot;UnitTaken&quot;,
   &quot;UnitGiven&quot;,
   &quot;UnitIdle&quot;,
+  &quot;UnitCommand&quot;,
   &quot;UnitSeismicPing&quot;,
   &quot;UnitEnteredRadar&quot;,
   &quot;UnitEnteredLos&quot;,

Modified: trunk/game/LuaUI/fonts.lua
===================================================================
--- trunk/game/LuaUI/fonts.lua	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/game/LuaUI/fonts.lua	2008-07-11 21:18:27 UTC (rev 6144)
@@ -18,7 +18,9 @@
 -- &quot;:n:&quot; sets it to nearest texture filtering
 local DefaultFontName = &quot;:n:&quot; .. LUAUI_DIRNAME .. &quot;Fonts/FreeMonoBold_12&quot;
 
+Spring.CreateDir(LUAUI_DIRNAME .. 'Fonts')
 
+
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 
@@ -91,17 +93,22 @@
   if ((not name) or (not size)) then
     return false
   end
-  local fullName
-  if (VFS.FileExists(name .. '.ttf', VFS.RAW_ONLY)) then
-    fullName = name .. '.ttf'
-  elseif (VFS.FileExists(name .. '.otf', VFS.RAW_ONLY)) then
+
+  local fullName = name .. '.ttf'
+  local inData = VFS.LoadFile(fullName)
+  if (not inData) then
     fullName = name .. '.otf'
-  else
+    inData = VFS.LoadFile(fullName)
+  end
+  if (not inData) then
     return false
   end
-  print('CreateFontFiles = ' .. fullName .. '.ttf, ' .. size)
+  
+  print('CreateFontFiles = ' .. fullName .. ', ' .. size)
+
   return
     Spring.MakeFont(fullName, {
+      inData = inData,
       height = tonumber(size),
       minChar = 0,
       maxChar = 255,

Modified: trunk/game/LuaUI/widgets.lua
===================================================================
--- trunk/game/LuaUI/widgets.lua	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/game/LuaUI/widgets.lua	2008-07-11 21:18:27 UTC (rev 6144)
@@ -107,6 +107,8 @@
   'GameFrame',
   'GameSetup',
   'TeamDied',
+  'TeamChanged',
+  'PlayerChanged',
   'ShockFront',
   'WorldTooltip',
   'MapDrawCmd',
@@ -118,6 +120,7 @@
   'UnitTaken',
   'UnitGiven',
   'UnitIdle',
+  'UnitCommand',
   'UnitCmdDone',
   'UnitDamaged',
   'UnitEnteredRadar',
@@ -289,6 +292,9 @@
 
 
 local function GetWidgetInfo(name, mode)
+
+  do return end -- FIXME
+
   local lines = VFS.LoadFile(name, mode)
 
   local infoLines = {}
@@ -1443,7 +1449,7 @@
     for _,w in ipairs(self.GetTooltipList) do
       if (w:IsAbove(x, y)) then
         local tip = w:GetTooltip(x, y)
-        if (string.len(tip) &gt; 0) then
+        if ((type(tip) == 'string') and (#tip &gt; 0)) then
           return tip
         end
       end
@@ -1452,8 +1458,8 @@
   else
     for _,w in ipairs(self.TweakGetTooltipList) do
       if (w:TweakIsAbove(x, y)) then
-        local tip = w:TweakGetTooltip(x, y)
-        if (string.len(tip) &gt; 0) then
+        local tip = w:TweakGetTooltip(x, y) or ''
+        if ((type(tip) == 'string') and (#tip &gt; 0)) then
           return tip
         end
       end
@@ -1498,6 +1504,22 @@
 end
 
 
+function widgetHandler:TeamChanged(teamID)
+  for _,w in ipairs(self.TeamChangedList) do
+    w:TeamChanged(teamID)
+  end
+  return
+end
+
+
+function widgetHandler:PlayerChanged(playerID)
+  for _,w in ipairs(self.PlayerChangedList) do
+    w:PlayerChanged(playerID)
+  end
+  return
+end
+
+
 function widgetHandler:GameFrame(frameNum)
   for _,w in ipairs(self.GameFrameList) do
     w:GameFrame(frameNum)
@@ -1622,6 +1644,16 @@
 end
 
 
+function widgetHandler:UnitCommand(unitID, unitDefID, unitTeam,
+                                   cmdId, cmdOpts, cmdParams)
+  for _,w in ipairs(self.UnitCommandList) do
+    w:UnitCommand(unitID, unitDefID, unitTeam,
+                  cmdId, cmdOpts, cmdParams)
+  end
+  return
+end
+
+
 function widgetHandler:UnitCmdDone(unitID, unitDefID, unitTeam, cmdID, cmdTag)
   for _,w in ipairs(self.UnitCmdDoneList) do
     w:UnitCmdDone(unitID, unitDefID, unitTeam, cmdID, cmdTag)

Modified: trunk/rts/CMakeLists.txt
===================================================================
--- trunk/rts/CMakeLists.txt	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/CMakeLists.txt	2008-07-11 21:18:27 UTC (rev 6144)
@@ -32,6 +32,11 @@
 	ADD_DEFINITIONS(-DDIRECT_CONTROL_ALLOWED)
 endif (DIRECT_CONTROL)
 
+SET(USE_GML TRUE CACHE BOOL &quot;Use the GML OpenGL threading library?&quot;)
+if (USE_GML)
+	ADD_DEFINITIONS(-DUSE_GML)
+endif (USE_GML)
+
 IF (UNIX)
 	ADD_DEFINITIONS(-DNO_AVI)
 	

Modified: trunk/rts/ExternalAI/Group.cpp
===================================================================
--- trunk/rts/ExternalAI/Group.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/ExternalAI/Group.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -279,10 +279,12 @@
 			c.mouseicon = i-&gt;mouseicon.c_str();
 			c.tooltip   = i-&gt;tooltip.c_str();
 			c.showUnique  = i-&gt;showUnique;
-			c.onlyKey     = i-&gt;onlyKey;
+			c.hidden      = i-&gt;hidden;
+			c.disabled    = i-&gt;disabled;
 			c.onlyTexture = i-&gt;onlyTexture;
-			for (vector&lt;string&gt;::const_iterator j = i-&gt;params.begin(); j != i-&gt;params.end(); ++j)
+			for (vector&lt;string&gt;::const_iterator j = i-&gt;params.begin(); j != i-&gt;params.end(); ++j) {
 				c.params.push_back(j-&gt;c_str());
+			}
 			myCommands.push_back(c);
 			c.params.clear();
 		}

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/Game.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -76,7 +76,6 @@
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaInputReceiver.h&quot;
 #include &quot;Lua/LuaHandle.h&quot;
 #include &quot;Lua/LuaGaia.h&quot;
@@ -111,8 +110,9 @@
 #include &quot;StartScripts/Script.h&quot;
 #include &quot;StartScripts/ScriptHandler.h&quot;
 #include &quot;Sync/SyncedPrimitiveIO.h&quot;
+#include &quot;System/EventHandler.h&quot;
+#include &quot;System/Sound.h&quot;
 #include &quot;System/FileSystem/SimpleParser.h&quot;
-#include &quot;System/Sound.h&quot;
 #include &quot;System/Platform/NullSound.h&quot;
 #include &quot;System/Net/RawPacket.h&quot;
 #include &quot;Platform/Clipboard.h&quot;
@@ -154,8 +154,10 @@
 
 #include &lt;boost/thread/barrier.hpp&gt;
 
+#ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
 gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+#endif
 
 extern Uint8 *keys;
 extern bool globalQuit;
@@ -427,6 +429,13 @@
 
 	globalAI = SAFE_NEW CGlobalAIHandler();
 
+	CPlayer* p = gs-&gt;players[gu-&gt;myPlayerNum];
+	if(!gameSetup || net-&gt;localDemoPlayback) {
+		p-&gt;playerName = configHandler.GetString(&quot;name&quot;, &quot;&quot;);
+	} else {
+		GameSetupDrawer::Enable();
+	}
+
 	if (gs-&gt;useLuaRules) {
 		PrintLoadMsg(&quot;Loading LuaRules&quot;);
 		CLuaRules::LoadHandler();
@@ -435,7 +444,7 @@
 		PrintLoadMsg(&quot;Loading LuaGaia&quot;);
 		CLuaGaia::LoadHandler();
 	}
-	if (!!configHandler.GetInt(&quot;LuaUI&quot;, 0)) {
+	if (!!configHandler.GetInt(&quot;LuaUI&quot;, 1)) {
 		PrintLoadMsg(&quot;Loading LuaUI&quot;);
 		CLuaUI::LoadHandler();
 	}
@@ -450,13 +459,6 @@
 		glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);
 	}
 
-	CPlayer* p = gs-&gt;players[gu-&gt;myPlayerNum];
-	if(!gameSetup || net-&gt;localDemoPlayback) {
-		p-&gt;playerName = configHandler.GetString(&quot;name&quot;, &quot;&quot;);
-	} else {
-		GameSetupDrawer::Enable();
-	}
-
 	lastframe = SDL_GetTicks();
 	lastModGameTimeMeasure = lastframe;
 	lastUpdate = lastframe;
@@ -465,7 +467,7 @@
 	updateDeltaSeconds = 0.0f;
 	script = CScriptHandler::Instance().chosenScript;
 	assert(script);
-	luaCallIns.GamePreload();
+	eventHandler.GamePreload();
 
 	glFogfv(GL_FOG_COLOR, mapInfo-&gt;atmosphere.fogColor);
 	glFogf(GL_FOG_START, 0.0f);
@@ -621,7 +623,7 @@
 	delete water;
 	water = CBaseWater::GetWater();
 
-	luaCallIns.ViewResize();
+	eventHandler.ViewResize();
 }
 
 
@@ -1748,11 +1750,14 @@
 	}
 	else if (cmd == &quot;gathermode&quot;) {
 		if (guihandler != NULL) {
+			bool gatherMode;
 			if (action.extra.empty()) {
-				guihandler-&gt;SetGatherMode(!guihandler-&gt;GetGatherMode());
+				gatherMode = !guihandler-&gt;GetGatherMode();
 			} else {
-				guihandler-&gt;SetGatherMode(!!atoi(action.extra.c_str()));
+				gatherMode = !!atoi(action.extra.c_str());
 			}
+			guihandler-&gt;SetGatherMode(gatherMode);
+			logOutput.Print(&quot;gathermode %s&quot;, gatherMode ? &quot;enabled&quot; : &quot;disabled&quot;);
 		}
 	}
 	else if (cmd == &quot;pastetext&quot;) {
@@ -2430,7 +2435,7 @@
 	if (!net-&gt;Active() &amp;&amp; !gameOver) {
 		logOutput.Print(&quot;Lost connection to gameserver&quot;);
 		gameOver = true;
-		luaCallIns.GameOver();
+		eventHandler.GameOver();
 		GameEnd();
 	}
 
@@ -2440,7 +2445,7 @@
 		infoConsole-&gt;GetNewRawLines(lines);
 		for (unsigned int i = 0; i &lt; lines.size(); i++) {
 			const CInfoConsole::RawLine&amp; rawLine = lines[i];
-			luaCallIns.AddConsoleLine(rawLine.text, rawLine.zone);
+			eventHandler.AddConsoleLine(rawLine.text, rawLine.zone);
 		}
 	}
 
@@ -2484,7 +2489,7 @@
 	}
 
 	selectedUnits.Draw();
-	luaCallIns.DrawWorldPreUnit();
+	eventHandler.DrawWorldPreUnit();
 	unitDrawer-&gt;Draw(false);
 	featureHandler-&gt;Draw();
 
@@ -2514,7 +2519,7 @@
 		sky-&gt;DrawSun();
 	}
 
-	luaCallIns.DrawWorld();
+	eventHandler.DrawWorld();
 
 	LuaUnsyncedCtrl::DrawUnitCommandQueues();
 	if (cmdColors.AlwaysDrawQueue() || guihandler-&gt;GetQueueKeystate()) {
@@ -2587,21 +2592,23 @@
 	return true;
 }
 
-#if GML_ENABLE_DRAWALL
+#ifndef USE_GML
 bool CGame::Draw() {
-#else
+#else // USE_GML
+#  if GML_ENABLE_DRAWALL
+bool CGame::Draw() {
+#  else
 bool CGame::DrawMT() {
-#endif
+#  endif
 	gmlProcessor.Work(&amp;CGame::DrawMTcb,NULL,NULL,this,gmlThreadCount,TRUE,NULL,1,2,2,FALSE);
 	return TRUE;
 }
-
-
-#if GML_ENABLE_DRAWALL
+#  if GML_ENABLE_DRAWALL
 bool CGame::DrawMT() {
-#else
+#  else
 bool CGame::Draw() {
-#endif
+#  endif
+#endif // USE_GML
 
 	ASSERT_UNSYNCED_MODE;
 
@@ -2617,14 +2624,13 @@
 
 	LuaUnsyncedCtrl::ClearUnitCommandQueues();
 
-	luaCallIns.Update();
+	eventHandler.Update();
 
-	luaCallIns.DrawGenesis();
+	eventHandler.DrawGenesis();
 
 	// XXX ugly hack to minimize luaUI errors
 	if (luaUI &amp;&amp; luaUI-&gt;GetCallInErrors() &gt;= 5) {
-		// FIXME: trepan -- I want error reports, make this verbose and annoying
-		for (int annoy = 0; annoy &lt; 32; annoy++) {
+		for (int annoy = 0; annoy &lt; 8; annoy++) {
 			logOutput &lt;&lt; &quot;5 errors deep in LuaUI, disabling...\n&quot;;
 		}
 		guihandler-&gt;RunLayoutCommand(&quot;disable&quot;);
@@ -2729,7 +2735,7 @@
 
 	glDisable(GL_FOG);
 
-	luaCallIns.DrawScreenEffects();
+	eventHandler.DrawScreenEffects();
 
 	if (mouse-&gt;locked &amp;&amp; (crossSize &gt; 0.0f)) {
 		glColor4f(1.0f, 1.0f, 1.0f, 0.5f);
@@ -2978,44 +2984,49 @@
 
 void CGame::StartPlaying()
 {
-	playing=true;
+	playing = true;
 	GameSetupDrawer::Disable();
-	lastTick=clock();
+	lastTick = clock();
 	lastframe = SDL_GetTicks();
+
 	ENTER_MIXED;
-	gu-&gt;myTeam=gs-&gt;players[gu-&gt;myPlayerNum]-&gt;team;
-	gu-&gt;myAllyTeam=gs-&gt;AllyTeam(gu-&gt;myTeam);
-//	grouphandler-&gt;team=gu-&gt;myTeam;
+	gu-&gt;myTeam = gs-&gt;players[gu-&gt;myPlayerNum]-&gt;team;
+	gu-&gt;myAllyTeam = gs-&gt;AllyTeam(gu-&gt;myTeam);
+//	grouphandler-&gt;team = gu-&gt;myTeam;
 	CLuaUI::UpdateTeams();
+
 	ENTER_SYNCED;
 	script-&gt;GameStart();
-	luaCallIns.GameStart();
-
+	eventHandler.GameStart();
 }
 
 
 // This will be run by a separate thread in parallel with the Sim
 // ONLY 100% THREAD SAFE UNSYNCED STUFF HERE PLEASE
 void CGame::UnsyncedStuff() {
-	if(!skipping) {
+	if (!skipping) {
 		infoConsole-&gt;Update();
 	}
 }
 
 
-#if GML_ENABLE_SIM
+#ifndef USE_GML
 void CGame::SimFrame() {
-#else
+#else // USE_GML
+#  if GML_ENABLE_SIM
+void CGame::SimFrame() {
+#  else
 void CGame::SimFrameMT() {
-#endif
+#  endif
 	gmlProcessor.Work(&amp;CGame::SimFrameMTcb,NULL,NULL,this,2,FALSE,NULL,1,2,2,FALSE,&amp;CGame::UnsyncedStuffcb);
 }
-
-#if GML_ENABLE_SIM
+#  if GML_ENABLE_SIM
 void CGame::SimFrameMT() {
-#else
+#  else
 void CGame::SimFrame() {
-#endif
+#  endif
+#endif // USE_GML
+
 	good_fpu_control_registers(&quot;CGame::SimFrame&quot;);
 	lastFrameTime = SDL_GetTicks();
 	ASSERT_SYNCED_MODE;
@@ -3052,26 +3063,29 @@
 		sound-&gt;NewFrame();
 		treeDrawer-&gt;Update();
 		globalAI-&gt;Update();
-		for (int a = 0; a &lt; MAX_TEAMS; a++)
+		for (int a = 0; a &lt; MAX_TEAMS; a++) {
 			grouphandlers[a]-&gt;Update();
+		}
 		profiler.Update();
 		unitDrawer-&gt;Update();
 #ifdef DIRECT_CONTROL_ALLOWED
-		if(gu-&gt;directControl){
-			unsigned char status=0;
-			if(camMove[0]) status|=1;
-			if(camMove[1]) status|=2;
-			if(camMove[2]) status|=4;
-			if(camMove[3]) status|=8;
-			if(mouse-&gt;buttons[SDL_BUTTON_LEFT].pressed) status|=16;
-			if(mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed) status|=32;
-			shortint2 hp=GetHAndPFromVector(camera-&gt;forward);
+		if (gu-&gt;directControl) {
+			unsigned char status = 0;
+			if (camMove[0]) { status |= (1 &lt;&lt; 0); }
+			if (camMove[1]) { status |= (1 &lt;&lt; 1); }
+			if (camMove[2]) { status |= (1 &lt;&lt; 2); }
+			if (camMove[3]) { status |= (1 &lt;&lt; 3); }
+			if (mouse-&gt;buttons[SDL_BUTTON_LEFT].pressed)  { status |= (1 &lt;&lt; 4); }
+			if (mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed) { status |= (1 &lt;&lt; 5); }
+			shortint2 hp = GetHAndPFromVector(camera-&gt;forward);
 
-			if(hp.x!=oldHeading || hp.y!=oldPitch || oldStatus!=status){
-				oldHeading=hp.x;
-				oldPitch=hp.y;
-				oldStatus=status;
-				net-&gt;Send(CBaseNetProtocol::Get().SendDirectControlUpdate(gu-&gt;myPlayerNum, status, hp.x, hp.y));
+			if (hp.x != oldHeading || hp.y != oldPitch || oldStatus != status) {
+				oldHeading = hp.x;
+				oldPitch = hp.y;
+				oldStatus = status;
+				net-&gt;Send(
+					CBaseNetProtocol::Get().SendDirectControlUpdate(gu-&gt;myPlayerNum,
+					                                                status, hp.x, hp.y));
 			}
 		}
 #endif
@@ -3235,7 +3249,7 @@
 				if (!gameOver)
 				{
 					gameOver=true;
-					luaCallIns.GameOver();
+					eventHandler.GameOver();
 					GameEnd();
 				}
 				POP_CODE_MODE;
@@ -3295,7 +3309,7 @@
 			case NETMSG_GAMEOVER: {
 				ENTER_MIXED;
 				gameOver=true;
-				luaCallIns.GameOver();
+				eventHandler.GameOver();
 				if (gu-&gt;autoQuit) {
 					logOutput.Print(&quot;Automatical quit enforced from commandline&quot;);
 					globalQuit = true;
@@ -3795,8 +3809,6 @@
 							gu-&gt;spectating           = false;
 							gu-&gt;spectatingFullView   = false;
 							gu-&gt;spectatingFullSelect = false;
-							gu-&gt;spectatingFullView   = false;
-							gu-&gt;spectatingFullSelect = false;
 							selectedUnits.ClearSelected();
 							unitTracker.Disable();
 							CLuaUI::UpdateTeams();
@@ -3805,6 +3817,7 @@
 							gs-&gt;Team(newTeam)-&gt;leader = player;
 						}
 						CPlayer::UpdateControlledTeams();
+						eventHandler.PlayerChanged(player);
 						break;
 					}
 					default: {
@@ -3821,11 +3834,12 @@
 				if (whichAllyTeam &lt; MAX_TEAMS &amp;&amp; whichAllyTeam &gt;= 0) {
 					// FIXME - need to reset unit allyTeams
 					//       - need to reset unit texture for 3do
-					//       - need a call-in for lua and AIs
+					//       - need a call-in for AIs
 					gs-&gt;SetAlly(gs-&gt;AllyTeam(gs-&gt;players[player]-&gt;team), whichAllyTeam, allied);
 				} else {
 					logOutput.Print(&quot;Player %i sent out wrong allyTeam index in alliance message&quot;, player);
 				}
+				eventHandler.TeamChanged(gs-&gt;players[player]-&gt;team);
 				break;
 			}
 			case NETMSG_CCOMMAND: {
@@ -4096,10 +4110,11 @@
 	logOutput.Print(&quot;Memdump finished&quot;);
 }
 
+
 void CGame::DrawDirectControlHud(void)
 {
 #ifdef DIRECT_CONTROL_ALLOWED
-	CUnit* unit=gu-&gt;directControl;
+	CUnit* unit = gu-&gt;directControl;
 	glPushMatrix();
 
 	glEnable(GL_BLEND);
@@ -4112,9 +4127,9 @@
 		glTranslatef(0.1f,0.5f,0);
 		glScalef(0.25f, 0.25f * gu-&gt;aspectRatio, 0.25f);
 
-		if(unit-&gt;moveType-&gt;useHeading){
+		if (unit-&gt;moveType-&gt;useHeading) {
 			glPushMatrix();
-			glRotatef(unit-&gt;heading*180.0f/32768+180,0,0,1);
+			glRotatef(unit-&gt;heading * 180.0f / 32768 + 180, 0, 0, 1);
 
 			glColor4f(0.3f, 0.9f, 0.3f, 0.4f);
 			glBegin(GL_TRIANGLE_FAN);
@@ -4130,14 +4145,17 @@
 
 		glEnable(GL_DEPTH_TEST);
 		glPushMatrix();
-		if(unit-&gt;moveType-&gt;useHeading){
-			float scale=0.4f/unit-&gt;radius;
-			glScalef(scale,scale,scale);
-			glRotatef(90,1,0,0);
+		if (unit-&gt;moveType-&gt;useHeading) {
+			const float scale = 0.4f/unit-&gt;radius;
+			glScalef(scale, scale, scale);
+			glRotatef(90, 1, 0, 0);
 		} else {
-			float scale=0.2f/unit-&gt;radius;
-			glScalef(scale,scale,-scale);
-			CMatrix44f m(ZeroVector,float3(camera-&gt;right.x,camera-&gt;up.x,camera-&gt;forward.x),float3(camera-&gt;right.y,camera-&gt;up.y,camera-&gt;forward.y),float3(camera-&gt;right.z,camera-&gt;up.z,camera-&gt;forward.z));
+			const float scale = 0.2f / unit-&gt;radius;
+			glScalef(scale, scale, -scale);
+			CMatrix44f m(ZeroVector,
+			             float3(camera-&gt;right.x, camera-&gt;up.x, camera-&gt;forward.x),
+			             float3(camera-&gt;right.y, camera-&gt;up.y, camera-&gt;forward.y),
+			             float3(camera-&gt;right.z, camera-&gt;up.z, camera-&gt;forward.z));
 			glMultMatrixf(m.m);
 		}
 		glTranslatef3(-unit-&gt;pos - (unit-&gt;speed * gu-&gt;timeOffset));
@@ -4149,7 +4167,7 @@
 		glDisable(GL_TEXTURE_2D);
 		glEnable(GL_BLEND);
 
-		if(unit-&gt;moveType-&gt;useHeading){
+		if (unit-&gt;moveType-&gt;useHeading) {
 			glPushMatrix();
 			glRotatef(GetHeadingFromVector(camera-&gt;forward.x,camera-&gt;forward.z)*180.0f/32768+180,0,0,1);
 			glScalef(0.4f,0.4f,0.3f);
@@ -4306,6 +4324,7 @@
 #endif
 }
 
+
 void CGame::GameEnd()
 {
 	SAFE_NEW CEndGameBox();

Modified: trunk/rts/Game/GameHelper.cpp
===================================================================
--- trunk/rts/Game/GameHelper.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/GameHelper.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -9,7 +9,6 @@
 #include &quot;GameHelper.h&quot;
 #include &quot;Game/UI/LuaUI.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
 #include &quot;Map/ReadMap.h&quot;
@@ -33,6 +32,7 @@
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
 //////////////////////////////////////////////////////////////////////
@@ -79,7 +79,7 @@
 			}
 		}
 	}
-	bool noGfx = luaCallIns.Explosion(weaponId, pos, owner);
+	bool noGfx = eventHandler.Explosion(weaponId, pos, owner);
 
 #ifdef TRACE_SYNC
 	tracefile &lt;&lt; &quot;Explosion: &quot;;

Modified: trunk/rts/Game/Player.cpp
===================================================================
--- trunk/rts/Game/Player.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/Player.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -11,6 +11,7 @@
 #  include &quot;Camera.h&quot;
 #  include &lt;assert.h&gt;
 #endif
+#include &quot;System/EventHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND(CPlayer,);
@@ -136,6 +137,7 @@
 		gu-&gt;spectatingFullView   = true;
 		gu-&gt;spectatingFullSelect = true;
 	}
+	eventHandler.PlayerChanged(playerNum);
 }
 
 

Modified: trunk/rts/Game/SelectedUnits.cpp
===================================================================
--- trunk/rts/Game/SelectedUnits.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/SelectedUnits.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -15,7 +15,6 @@
 #include &quot;ExternalAI/GroupHandler.h&quot;
 #include &quot;ExternalAI/Group.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;UI/CommandColors.h&quot;
 #include &quot;UI/GuiHandler.h&quot;
 #include &quot;UI/LuaUI.h&quot;
@@ -31,6 +30,7 @@
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
 #include &quot;Sim/Units/CommandAI/LineDrawer.h&quot;
 #include &quot;Sim/Units/UnitTypes/TransportUnit.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;Player.h&quot;
 #include &quot;Camera.h&quot;
@@ -75,46 +75,52 @@
 
 CSelectedUnits::AvailableCommandsStruct CSelectedUnits::GetAvailableCommands()
 {
-	possibleCommandsChanged=false;
+	possibleCommandsChanged = false;
 
-	if(selectedGroup!=-1 &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai){
+	if (selectedGroup != -1 &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai) {
 		AvailableCommandsStruct ac;
-		ac.commandPage=grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;lastCommandPage;
-		ac.commands=grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;GetPossibleCommands();
+		ac.commandPage = grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;lastCommandPage;
+		ac.commands = grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;GetPossibleCommands();
 
 		CommandDescription c;			//make sure we can clear the group even when selected
-		c.id=CMD_GROUPCLEAR;
-		c.action=&quot;groupclear&quot;;
-		c.type=CMDTYPE_ICON;
-		c.name=&quot;Clear group&quot;;
-		c.tooltip=&quot;Removes the units from any group they belong to&quot;;
+		c.id      = CMD_GROUPCLEAR;
+		c.action  = &quot;groupclear&quot;;
+		c.type    = CMDTYPE_ICON;
+		c.name    = &quot;Clear group&quot;;
+		c.tooltip = &quot;Removes the units from any group they belong to&quot;;
 		ac.commands.push_back(c);
 
 		return ac;
 	}
 
-	int commandPage=1000;
-	int foundGroup=-2;
-	int foundGroup2=-2;
-	map&lt;int,int&gt; count;
+	int commandPage = 1000;
+	int foundGroup = -2;
+	int foundGroup2 = -2;
+	map&lt;int, int&gt; states;
 
-	for(CUnitSet::iterator ui=selectedUnits.begin();ui!=selectedUnits.end();++ui){
-		vector&lt;CommandDescription&gt;* c=&amp;(*ui)-&gt;commandAI-&gt;GetPossibleCommands();
+	for (CUnitSet::iterator ui = selectedUnits.begin(); ui != selectedUnits.end(); ++ui) {
+		vector&lt;CommandDescription&gt;* c = &amp;(*ui)-&gt;commandAI-&gt;GetPossibleCommands();
 		vector&lt;CommandDescription&gt;::iterator ci;
-		for(ci=c-&gt;begin();ci!=c-&gt;end();++ci)
-			count[ci-&gt;id]=1;
-		if((*ui)-&gt;commandAI-&gt;lastSelectedCommandPage&lt;commandPage)
-			commandPage=(*ui)-&gt;commandAI-&gt;lastSelectedCommandPage;
+		for (ci = c-&gt;begin(); ci != c-&gt;end(); ++ci) {
+			states[ci-&gt;id] = ci-&gt;disabled ? 2 : 1;
+		}
+		if ((*ui)-&gt;commandAI-&gt;lastSelectedCommandPage &lt; commandPage) {
+			commandPage = (*ui)-&gt;commandAI-&gt;lastSelectedCommandPage;
+		}
 
-		if(foundGroup==-2 &amp;&amp; (*ui)-&gt;group)
-			foundGroup=(*ui)-&gt;group-&gt;id;
-		if(!(*ui)-&gt;group || foundGroup!=(*ui)-&gt;group-&gt;id)
-			foundGroup=-1;
+		if (foundGroup == -2 &amp;&amp; (*ui)-&gt;group) {
+			foundGroup = (*ui)-&gt;group-&gt;id;
+		}
+		if (!(*ui)-&gt;group || foundGroup!=(*ui)-&gt;group-&gt;id) {
+			foundGroup = -1;
+		}
 
-		if(foundGroup2==-2 &amp;&amp; (*ui)-&gt;group)
-			foundGroup2=(*ui)-&gt;group-&gt;id;
-		if(foundGroup2&gt;=0 &amp;&amp; (*ui)-&gt;group &amp;&amp; (*ui)-&gt;group-&gt;id!=foundGroup2)
-			foundGroup2=-1;
+		if (foundGroup2 == -2 &amp;&amp; (*ui)-&gt;group) {
+			foundGroup2 = (*ui)-&gt;group-&gt;id;
+		}
+		if (foundGroup2 &gt;= 0 &amp;&amp; (*ui)-&gt;group &amp;&amp; (*ui)-&gt;group-&gt;id != foundGroup2) {
+			foundGroup2 = -1;
+		}
 	}
 
 	vector&lt;CommandDescription&gt; groupCommands;
@@ -143,11 +149,11 @@
 		// add the selected units to a previous group (that at least one unit is also selected from)
 		if ((foundGroup &lt; 0) &amp;&amp; (foundGroup2 &gt;= 0)) {
 			CommandDescription c;
-			c.id=CMD_GROUPADD;
-			c.action=&quot;groupadd&quot;;
-			c.type=CMDTYPE_ICON;
-			c.name=&quot;Add to group&quot;;
-			c.tooltip=&quot;Adds the selected to an existing group (of which one or more units is already selected)&quot;;
+			c.id      = CMD_GROUPADD;
+			c.action  = &quot;groupadd&quot;;
+			c.type    = CMDTYPE_ICON;
+			c.name    = &quot;Add to group&quot;;
+			c.tooltip = &quot;Adds the selected to an existing group (of which one or more units is already selected)&quot;;
 			groupCommands.push_back(c);
 		}
 
@@ -155,11 +161,11 @@
 		if (foundGroup &gt;= 0) {
 			CommandDescription c;
 
-			c.id=CMD_GROUPSELECT;
-			c.action=&quot;groupselect&quot;;
-			c.type=CMDTYPE_ICON;
-			c.name=&quot;Select group&quot;;
-			c.tooltip=&quot;Select the group that these units belong to&quot;;
+			c.id      = CMD_GROUPSELECT;
+			c.action  = &quot;groupselect&quot;;
+			c.type    = CMDTYPE_ICON;
+			c.name    = &quot;Select group&quot;;
+			c.tooltip = &quot;Select the group that these units belong to&quot;;
 			groupCommands.push_back(c);
 		}
 
@@ -167,70 +173,72 @@
 		if (foundGroup2 != -2) {
 			CommandDescription c;
 
-			c.id=CMD_GROUPCLEAR;
-			c.action=&quot;groupclear&quot;;
-			c.type=CMDTYPE_ICON;
-			c.name=&quot;Clear group&quot;;
-			c.tooltip=&quot;Removes the units from any group they belong to&quot;;
+			c.id      = CMD_GROUPCLEAR;
+			c.action  = &quot;groupclear&quot;;
+			c.type    = CMDTYPE_ICON;
+			c.name    = &quot;Clear group&quot;;
+			c.tooltip = &quot;Removes the units from any group they belong to&quot;;
 			groupCommands.push_back(c);
 		}
 	} // end if (!gs-&gt;noHelperAIs)
 
 	vector&lt;CommandDescription&gt; commands ;
 	// load the first set  (separating build and non-build commands)
-	for(CUnitSet::iterator ui=selectedUnits.begin();ui!=selectedUnits.end();++ui){
-		vector&lt;CommandDescription&gt;* c=&amp;(*ui)-&gt;commandAI-&gt;GetPossibleCommands();
+	for (CUnitSet::iterator ui = selectedUnits.begin(); ui != selectedUnits.end(); ++ui) {
+		vector&lt;CommandDescription&gt;* c = &amp;(*ui)-&gt;commandAI-&gt;GetPossibleCommands();
 		vector&lt;CommandDescription&gt;::iterator ci;
-		for(ci=c-&gt;begin(); ci!=c-&gt;end(); ++ci){
+		for (ci = c-&gt;begin(); ci != c-&gt;end(); ++ci) {
 			if (buildIconsFirst) {
 				if (ci-&gt;id &gt;= 0) { continue; }
 			} else {
 				if (ci-&gt;id &lt; 0)  { continue; }
 			}
-			if(ci-&gt;showUnique &amp;&amp; selectedUnits.size()&gt;1)
+			if (ci-&gt;showUnique &amp;&amp; selectedUnits.size() &gt; 1) {
 				continue;
-			if(count[ci-&gt;id]&gt;0){
+			}
+			if (states[ci-&gt;id] &gt; 0) {
 				commands.push_back(*ci);
-				count[ci-&gt;id]=0;
+				states[ci-&gt;id] = 0;
 			}
 		}
 	}
 
 	if (!buildIconsFirst &amp;&amp; !gs-&gt;noHelperAIs) {
 		vector&lt;CommandDescription&gt;::iterator ci;
-		for(ci=groupCommands.begin(); ci!=groupCommands.end(); ++ci){
+		for(ci = groupCommands.begin(); ci != groupCommands.end(); ++ci) {
 			commands.push_back(*ci);
 		}
 	}
 
 	// load the second set  (all those that have not already been included)
-	for(CUnitSet::iterator ui=selectedUnits.begin();ui!=selectedUnits.end();++ui){
-		vector&lt;CommandDescription&gt;* c=&amp;(*ui)-&gt;commandAI-&gt;GetPossibleCommands();
+	for (CUnitSet::iterator ui = selectedUnits.begin(); ui != selectedUnits.end(); ++ui) {
+		vector&lt;CommandDescription&gt;* c = &amp;(*ui)-&gt;commandAI-&gt;GetPossibleCommands();
 		vector&lt;CommandDescription&gt;::iterator ci;
-		for(ci=c-&gt;begin(); ci!=c-&gt;end(); ++ci){
+		for (ci = c-&gt;begin(); ci != c-&gt;end(); ++ci) {
 			if (buildIconsFirst) {
 				if (ci-&gt;id &lt; 0)  { continue; }
 			} else {
 				if (ci-&gt;id &gt;= 0) { continue; }
 			}
-			if(ci-&gt;showUnique &amp;&amp; selectedUnits.size()&gt;1)
+			if (ci-&gt;showUnique &amp;&amp; selectedUnits.size() &gt; 1) {
 				continue;
-			if(count[ci-&gt;id]&gt;0){
+			}
+			if (states[ci-&gt;id] &gt; 0) {
 				commands.push_back(*ci);
-				count[ci-&gt;id]=0;
+				states[ci-&gt;id] = 0;
 			}
 		}
 	}
 	if (buildIconsFirst &amp;&amp; !gs-&gt;noHelperAIs) {
 		vector&lt;CommandDescription&gt;::iterator ci;
-		for(ci=groupCommands.begin(); ci!=groupCommands.end(); ++ci){
+		for (ci = groupCommands.begin(); ci != groupCommands.end(); ++ci) {
 			commands.push_back(*ci);
 		}
 	}
 
 	AvailableCommandsStruct ac;
-	ac.commandPage=commandPage;
-	ac.commands=commands;
+	ac.commandPage = commandPage;
+	ac.commands = commands;
 	return ac;
 }
 
@@ -349,7 +357,7 @@
 {
 	// if unit is being transported by eg. Hulk or Atlas
 	// then we should not be able to select it
-	if (unit-&gt;transporter != NULL &amp;&amp; !unit-&gt;transporter-&gt;unitDef-&gt;isfireplatform) {
+	if (unit-&gt;transporter != NULL &amp;&amp; !unit-&gt;transporter-&gt;unitDef-&gt;isFirePlatform) {
 		return;
 	}
 
@@ -418,8 +426,8 @@
 	}
 	ENTER_UNSYNCED;
 
+	selectionChanged=true;
 	possibleCommandsChanged=true;
-	selectionChanged=true;
 }
 
 
@@ -608,7 +616,7 @@
 {
 	// NOTE: the unitDef-&gt;aihint value is being ignored
 	int luaCmd;
-	if (luaCallIns.DefaultCommand(unit, feature, luaCmd)) {
+	if (eventHandler.DefaultCommand(unit, feature, luaCmd)) {
 		return luaCmd;
 	}
 

Modified: trunk/rts/Game/Team.cpp
===================================================================
--- trunk/rts/Game/Team.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/Team.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -8,16 +8,16 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;Player.h&quot;
 #include &quot;Game/UI/LuaUI.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;ExternalAI/GlobalAI.h&quot;
+#include &quot;ExternalAI/GlobalAIHandler.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;creg/STL_List.h&quot;
 #include &quot;creg/STL_Map.h&quot;
 #include &quot;creg/STL_Set.h&quot;
-#include &quot;ExternalAI/GlobalAI.h&quot;
-#include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;mmgr.h&quot;
 #include &quot;NetProtocol.h&quot;
 
@@ -286,7 +286,7 @@
 
 	CLuaUI::UpdateTeams();
   CPlayer::UpdateControlledTeams();
-	luaCallIns.TeamDied(teamNum);
+	eventHandler.TeamDied(teamNum);
 }
 
 void CTeam::StartposMessage(const float3&amp; pos, const bool isReady)
@@ -330,12 +330,12 @@
 	metalReceived = 0;
 	energyReceived = 0;
 
-	float eShare=0,mShare=0;
-	for(int a=0; a &lt; gs-&gt;activeTeams; ++a){
-		if((a != teamNum) &amp;&amp; gs-&gt;AlliedTeams(teamNum,a)){
+	float eShare = 0.0f, mShare = 0.0f;
+	for (int a = 0; a &lt; gs-&gt;activeTeams; ++a) {
+		if ((a != teamNum) &amp;&amp; gs-&gt;AlliedTeams(teamNum, a)) {
 			CTeam* team = gs-&gt;Team(a);
 			eShare += std::max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy);
-			mShare += std::max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal);
+			mShare += std::max(0.0f, (team-&gt;metalStorage  * 0.99f) - team-&gt;metal);
 		}
 	}
 
@@ -347,14 +347,15 @@
 	const float eExcess = std::max(0.0f, energy - (energyStorage * energyShare));
 	const float mExcess = std::max(0.0f, metal  - (metalStorage  * metalShare));
 
-	float de=0,dm=0;
-	if (eShare &gt; 0)
-		de = std::min(1.0f,eExcess/eShare);
-	if (mShare &gt; 0)
-		dm = std::min(1.0f,mExcess/mShare);
-
-	for(int a=0; a &lt; gs-&gt;activeTeams; ++a){
-		if((a != teamNum) &amp;&amp; gs-&gt;AlliedTeams(teamNum,a)){
+	float de = 0.0f, dm = 0.0f;
+	if (eShare &gt; 0.0f) {
+		de = std::min(1.0f, eExcess/eShare);
+	}
+	if (mShare &gt; 0.0f) {
+		dm = std::min(1.0f, mExcess/mShare);
+	}
+	for (int a = 0; a &lt; gs-&gt;activeTeams; ++a) {
+		if ((a != teamNum) &amp;&amp; gs-&gt;AlliedTeams(teamNum, a)) {
 			CTeam* team = gs-&gt;Team(a);
 
 			const float edif = std::max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy) * de;
@@ -447,7 +448,7 @@
 		}
 	}
 
-	if(units.empty() &amp;&amp; !gaia) {
+	if (units.empty() &amp;&amp; !gaia) {
 		Died();
 	}
 }

Modified: trunk/rts/Game/UI/GameSetupDrawer.cpp
===================================================================
--- trunk/rts/Game/UI/GameSetupDrawer.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/UI/GameSetupDrawer.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -13,8 +13,8 @@
 #include &quot;../Team.h&quot;
 #include &quot;../GameSetup.h&quot;
 #include &quot;StartPosSelecter.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Rendering/glFont.h&quot;
+#include &quot;System/EventHandler.h&quot;
 
 extern Uint8 *keys;
 
@@ -24,7 +24,7 @@
 
 void GameSetupDrawer::Enable()
 {
-	assert(instance == 0);
+	assert(instance == NULL);
 	assert(gameSetup);
 
 	instance = new GameSetupDrawer();
@@ -35,10 +35,11 @@
 {
 	if (instance) {
 		delete instance;
-		instance = 0;
+		instance = NULL;
 	}
 }
 
+
 void GameSetupDrawer::StartCountdown(unsigned time)
 {
 	if (instance) {
@@ -107,7 +108,7 @@
 
 	CStartPosSelecter* selector = CStartPosSelecter::selector;
 	bool ready = (selector == NULL);
-	if (luaCallIns.GameSetup(state, ready, playerStates)) {
+	if (eventHandler.GameSetup(state, ready, playerStates)) {
 		if (selector) {
 			selector-&gt;ShowReady(false);
 			if (ready) {

Modified: trunk/rts/Game/UI/GuiHandler.cpp
===================================================================
--- trunk/rts/Game/UI/GuiHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/UI/GuiHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -19,13 +19,16 @@
 #include &quot;Game/Game.h&quot;
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;Lua/LuaTextures.h&quot;
+#include &quot;Lua/LuaGaia.h&quot;
+#include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/MetalMap.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/glFont.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/GL/glExtra.h&quot;
 #include &quot;Rendering/GL/glList.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
@@ -44,6 +47,7 @@
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/FileSystem/SimpleParser.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
@@ -533,7 +537,7 @@
 
 	// separate the visible/hidden icons
 	for (cdi = ac.commands.begin(); cdi != ac.commands.end(); ++cdi){
-		if (cdi-&gt;onlyKey) {
+		if (cdi-&gt;hidden) {
 			hidden.push_back(*cdi);
 		} else {
 			commands.push_back(*cdi);
@@ -689,11 +693,11 @@
 			                index);
 		}
 	}
-	// remove unwanted commands  (and mark all as onlyKey)
+	// remove unwanted commands  (and mark all as hidden)
 	std::vector&lt;CommandDescription&gt; tmpCmds;
 	for (i = 0; i &lt; cmds.size(); i++) {
 		if (removeIDs.find(i) == removeIDs.end()) {
-			cmds[i].onlyKey = true;
+			cmds[i].hidden = true;
 			tmpCmds.push_back(cmds[i]);
 		}
 	}
@@ -701,7 +705,7 @@
 
 	// add the custom commands
 	for (i = 0; i &lt; customCmds.size(); i++) {
-		customCmds[i].onlyKey = true;
+		customCmds[i].hidden = true;
 		cmds.push_back(customCmds[i]);
 	}
 	const int cmdCount = (int)cmds.size();
@@ -803,7 +807,7 @@
 		if ((index &gt;= 0) &amp;&amp; (index &lt; cmdCount)) {
 
 			icon.commandsID = index;
-			cmds[index].onlyKey = false;
+			cmds[index].hidden = false;
 
 			const int slot = (ii % tmpIconsPerPage);
 			const float fx = (float)(slot % tmpXicons);
@@ -854,7 +858,7 @@
 
 void CGuiHandler::GiveCommand(const Command&amp; cmd, bool fromUser) const
 {
-	if (luaCallIns.CommandNotify(cmd)) {
+	if (eventHandler.CommandNotify(cmd)) {
 		return;
 	}
 
@@ -917,7 +921,7 @@
 	if (!changedGroups.empty()) {
 		set&lt;int&gt;::const_iterator it;
 		for (it = changedGroups.begin(); it != changedGroups.end(); ++it) {
-			luaCallIns.GroupChanged(*it);
+			eventHandler.GroupChanged(*it);
 		}
 		changedGroups.clear();
 	}
@@ -1010,8 +1014,11 @@
 		}
 	}
 
-	if (gatherMode &amp;&amp; (mouse-&gt;cursorText == &quot;Move&quot;))
+	if (gatherMode &amp;&amp;
+	    (mouse-&gt;cursorText == &quot;Move&quot;) ||
+	    (mouse-&gt;cursorText == &quot;Fight&quot;)) {
 		newCursor = &quot;GatherWait&quot;;
+	}
 	
 	mouse-&gt;SetCursor(newCursor);
 }
@@ -1058,11 +1065,6 @@
 }
 
 
-void CGuiHandler::MouseMove(int x, int y, int dx, int dy, int button)
-{
-}
-
-
 void CGuiHandler::MouseRelease(int x, int y, int button)
 {
 	int iconCmd = -1;
@@ -1075,8 +1077,8 @@
 
 	if (!invertQueueKey &amp;&amp; needShift &amp;&amp; !keys[SDLK_LSHIFT]) {
 		SetShowingMetal(false);
-		inCommand=-1;
-		needShift=false;
+		inCommand = -1;
+		needShift = false;
 	}
 
 	if (button &lt; 0) {
@@ -1098,7 +1100,7 @@
 	}
 
 	if ((iconCmd &gt;= 0) &amp;&amp; (iconCmd &lt; commands.size())) {
-		const bool rmb = (button == SDL_BUTTON_LEFT) ? false : true;
+		const bool rmb = (button == SDL_BUTTON_RIGHT);
 		SetActiveCommand(iconCmd, rmb);
 		return;
 	}
@@ -1479,7 +1481,7 @@
 }
 
 
-int CGuiHandler::GetDefaultCommand(int x,int y) const
+int CGuiHandler::GetDefaultCommand(int x, int y) const
 {
 	CInputReceiver* ir = NULL;
 	if (!game-&gt;hideInterface) {
@@ -1814,7 +1816,7 @@
 		const int cmdType = cmdDesc.type;
 
 		// set the activePage
-		if (!cmdDesc.onlyKey &amp;&amp;
+		if (!cmdDesc.hidden &amp;&amp;
 				(((cmdType == CMDTYPE_ICON) &amp;&amp;
 					 ((cmdDesc.id &lt; 0) ||
 						(cmdDesc.id == CMD_STOCKPILE))) ||
@@ -2608,7 +2610,7 @@
 		const Box&amp; b = icon.visual;
 		glEnable(GL_TEXTURE_2D);
 		glColor4f(1.0f, 1.0f, 1.0f, textureAlpha);
-		glBindTexture(GL_TEXTURE_2D, unitDefHandler-&gt;GetUnitImage(ud));
+		glBindTexture(GL_TEXTURE_2D, unitDefHandler-&gt;GetUnitDefImage(ud));
 		glBegin(GL_QUADS);
 		glTexCoord2f(0.0f, 0.0f); glVertex2f(b.x1, b.y1);
 		glTexCoord2f(1.0f, 0.0f); glVertex2f(b.x2, b.y1);
@@ -2666,16 +2668,76 @@
 		return false;
 	}
 
-	glBindTexture(GL_TEXTURE_2D, unitDefHandler-&gt;GetUnitImage(ud));
+	glBindTexture(GL_TEXTURE_2D, unitDefHandler-&gt;GetUnitDefImage(ud));
 
 	return true;
 }
 
 
+static inline bool BindIconTexByString(const std::string&amp; str)
+{
+	char* endPtr;
+	const char* startPtr = str.c_str() + 1; // skip the '^'
+	const int unitDefID = (int)strtol(startPtr, &amp;endPtr, 10);
+	if (endPtr == startPtr) {
+		return false; // bad unitID spec
+	}
+	// UnitDefHandler's array size is (numUnitDefs + 1)
+	if ((unitDefID &lt;= 0) || (unitDefID &gt; unitDefHandler-&gt;numUnitDefs)) {
+		return false;
+	}
+	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
+	if (ud == NULL) {
+		return false;
+	}
+
+	ud-&gt;iconType-&gt;BindTexture();
+
+	return true;
+}
+
+
+static inline bool BindLuaTexByString(const std::string&amp; str)
+{
+	CLuaHandle* luaHandle = NULL;
+	const char scriptType = str[1];
+	switch (str[1]) {
+		case 'u': { luaHandle = luaUI; break; }
+		case 'g': { luaHandle = luaGaia; break; }
+		case 'm': { luaHandle = luaRules; break; }
+		default:  { break; }
+	}
+	if (luaHandle == NULL) {
+		return false;
+	}
+	if (str[2] != LuaTextures::prefix) { // '!'
+		return false;
+	}
+
+	const string luaTexStr = str.substr(2);
+	const LuaTextures::Texture* texInfo =
+		luaHandle-&gt;GetTextures().GetInfo(luaTexStr);
+	if (texInfo == NULL) {
+		return false;
+	}
+
+	if (texInfo-&gt;target != GL_TEXTURE_2D) {
+		return false;
+	}
+	glBindTexture(GL_TEXTURE_2D, texInfo-&gt;id);
+
+	return true;
+}
+
+
 static bool BindTextureString(const std::string&amp; str)
 {
 	if (str[0] == '#') {
 		return BindUnitTexByString(str);
+	} else if (str[0] == '^') {
+		return BindIconTexByString(str);
+	} else if (str[0] == LuaTextures::prefix) { // '!'
+		return BindLuaTexByString(str);
 	} else {
 		return CNamedTextures::Bind(str);
 	}

Modified: trunk/rts/Game/UI/GuiHandler.h
===================================================================
--- trunk/rts/Game/UI/GuiHandler.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/UI/GuiHandler.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -32,7 +32,6 @@
 		bool KeyPressed(unsigned short key, bool isRepeat);
 		bool KeyReleased(unsigned short key);
 		bool MousePress(int x, int y, int button);
-		void MouseMove(int x, int y, int dx, int dy, int button);
 		void MouseRelease(int x, int y, int button);
 		bool IsAbove(int x, int y);
 		std::string GetTooltip(int x, int y);

Modified: trunk/rts/Game/UI/LuaUI.cpp
===================================================================
--- trunk/rts/Game/UI/LuaUI.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/UI/LuaUI.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -4,6 +4,8 @@
 //////////////////////////////////////////////////////////////////////
 
 #include &quot;LuaUI.h&quot;
+
+#include &lt;stdio.h&gt;
 #include &lt;set&gt;
 #include &lt;cctype&gt;
 #include &lt;SDL_keysym.h&gt;
@@ -14,7 +16,6 @@
 #include &quot;LuaInclude.h&quot;
 
 #include &quot;Lua/LuaCallInCheck.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaUtils.h&quot;
 #include &quot;Lua/LuaConstGL.h&quot;
 #include &quot;Lua/LuaConstCMD.h&quot;
@@ -30,6 +31,7 @@
 #include &quot;Lua/LuaScream.h&quot;
 #include &quot;Lua/LuaOpenGL.h&quot;
 #include &quot;Lua/LuaVFS.h&quot;
+#include &quot;Lua/LuaIO.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;ExternalAI/Group.h&quot;
 #include &quot;ExternalAI/GroupHandler.h&quot;
@@ -60,6 +62,7 @@
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/NetProtocol.h&quot;
 #include &quot;System/SpringApp.h&quot;
@@ -150,13 +153,21 @@
 	LUA_OPEN_LIB(L, luaopen_package);
 	LUA_OPEN_LIB(L, luaopen_debug);
 
+	// setup the lua IO access check functions
+	lua_set_fopen(L, LuaIO::fopen);
+	lua_set_popen(L, LuaIO::popen, LuaIO::pclose);
+	lua_set_system(L, LuaIO::system);
+	lua_set_remove(L, LuaIO::remove);
+	lua_set_rename(L, LuaIO::rename);
+
 	// remove a few dangerous calls
 	lua_getglobal(L, &quot;io&quot;);
 	lua_pushstring(L, &quot;popen&quot;); lua_pushnil(L); lua_rawset(L, -3);
 	lua_pop(L, 1);
 	lua_getglobal(L, &quot;os&quot;);
-	lua_pushstring(L, &quot;exit&quot;);    lua_pushnil(L); lua_rawset(L, -3);
-	lua_pushstring(L, &quot;execute&quot;); lua_pushnil(L); lua_rawset(L, -3);
+	lua_pushstring(L, &quot;exit&quot;);      lua_pushnil(L); lua_rawset(L, -3);
+	lua_pushstring(L, &quot;execute&quot;);   lua_pushnil(L); lua_rawset(L, -3);
+	lua_pushstring(L, &quot;setlocale&quot;); lua_pushnil(L); lua_rawset(L, -3);
 	lua_pop(L, 1);
 
 	lua_pushvalue(L, LUA_GLOBALSINDEX);
@@ -196,7 +207,7 @@
 	}
 
 	// register for call-ins
-	luaCallIns.AddHandle(this);
+	eventHandler.AddClient(this);
 
 	// update extra call-ins
 	UnsyncedUpdateCallIn(&quot;WorldTooltip&quot;);
@@ -269,9 +280,9 @@
 	}
 
 	if (HasCallIn(name)) {
-		luaCallIns.InsertCallIn(this, name);
+		eventHandler.InsertEvent(this, name);
 	} else {
-		luaCallIns.RemoveCallIn(this, name);
+		eventHandler.RemoveEvent(this, name);
 	}
 	return true;
 }
@@ -516,7 +527,7 @@
 	// get the results
 	const int args = lua_gettop(L);
 
-	if ((args == 1) &amp;&amp; (lua_isstring(L, -1)) &amp;&amp;
+	if (lua_israwstring(L, -1) &amp;&amp;
 	    (string(lua_tostring(L, -1)) == &quot;disabled&quot;)) {
 		lua_settop(L, top);
 		return false; // no warnings
@@ -539,8 +550,8 @@
 		lua_settop(L, top);
 		return false;
 	}
-	xButtons = (int)lua_tonumber(L, 2);
-	yButtons = (int)lua_tonumber(L, 3);
+	xButtons = lua_toint(L, 2);
+	yButtons = lua_toint(L, 3);
 
 	if (!GetLuaIntList(L, 4, removeCmds)) {
 		logOutput.Print(&quot;LayoutButtons() bad removeCommands table\n&quot;);
@@ -609,7 +620,7 @@
 			HSTR_PUSH_NUMBER(L, &quot;type&quot;,     cmds[i].type);
 			HSTR_PUSH_STRING(L, &quot;action&quot;,   cmds[i].action);
 			HSTR_PUSH_STRING(L, &quot;texture&quot;,  cmds[i].iconname);
-			HSTR_PUSH_BOOL(L,   &quot;hidden&quot;,   cmds[i].onlyKey);
+			HSTR_PUSH_BOOL(L,   &quot;hidden&quot;,   cmds[i].hidden);
 			HSTR_PUSH_BOOL(L,   &quot;disabled&quot;, cmds[i].disabled);
 
 			HSTR_PUSH(L, &quot;params&quot;);
@@ -639,8 +650,8 @@
 			lua_pop(L, 2);
 			return false;
 		}
-		const int key = (int)lua_tonumber(L, -2);
-		const int value = (int)lua_tonumber(L, -1) - CMD_INDEX_OFFSET;
+		const int key = lua_toint(L, -2);
+		const int value = lua_toint(L, -1) - CMD_INDEX_OFFSET;
 		intMap[key] = value;
 	}
 
@@ -659,7 +670,7 @@
 			lua_pop(L, 2);
 			return false;
 		}
-		const int value = (int)lua_tonumber(L, -1) - CMD_INDEX_OFFSET;
+		const int value = lua_toint(L, -1) - CMD_INDEX_OFFSET;
 		intList.push_back(value);
 	}
 
@@ -681,7 +692,7 @@
 			return false;
 		}
 		ReStringPair rp;
-		rp.cmdIndex = (int)lua_tonumber(L, -2) - CMD_INDEX_OFFSET;
+		rp.cmdIndex = lua_toint(L, -2) - CMD_INDEX_OFFSET;
 		rp.texture = lua_tostring(L, -1);
 		reStringList.push_back(rp);
 	}
@@ -704,14 +715,14 @@
 			return false;
 		}
 		ReParamsPair paramsPair;
-		paramsPair.cmdIndex = (int)lua_tonumber(L, -2) - CMD_INDEX_OFFSET;
+		paramsPair.cmdIndex = lua_toint(L, -2) - CMD_INDEX_OFFSET;
 		const int paramTable = lua_gettop(L);
 		for (lua_pushnil(L); lua_next(L, paramTable) != 0; lua_pop(L, 1)) {
 			if (!lua_israwnumber(L, -2) || !lua_isstring(L, -1)) {
 				lua_pop(L, 4);
 				return false;
 			}
-			const int paramIndex = (int)lua_tonumber(L, -2);
+			const int paramIndex = lua_toint(L, -2);
 			const string paramValue = lua_tostring(L, -1);
 			paramsPair.params[paramIndex] = paramValue;
 		}
@@ -872,15 +883,15 @@
 {
 	luaUI-&gt;haveShockFront = true;
 	if (lua_isnumber(L, 1)) {
-		const float value = max(0.0f, (float)lua_tonumber(L, 1));
+		const float value = max(0.0f, lua_tofloat(L, 1));
 		luaUI-&gt;shockFrontMinArea = value;
 	}
 	if (lua_isnumber(L, 2)) {
-		const float value = max(0.0f, (float)lua_tonumber(L, 2));
+		const float value = max(0.0f, lua_tofloat(L, 2));
 		luaUI-&gt;shockFrontMinPower = value;
 	}
 	if (lua_isnumber(L, 3)) {
-		const float value = max(1.0f, (float)lua_tonumber(L, 3));
+		const float value = max(1.0f, lua_tofloat(L, 3));
 		luaUI-&gt;shockFrontDistAdj = value;
 	}
 	return 0;

Modified: trunk/rts/Game/UI/MiniMap.cpp
===================================================================
--- trunk/rts/Game/UI/MiniMap.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/UI/MiniMap.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -17,7 +17,6 @@
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;GuiHandler.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaUnsyncedCtrl.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/Ground.h&quot;
@@ -51,8 +50,9 @@
 #include &quot;Sim/Units/UnitTracker.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
+#include &quot;System/EventHandler.h&quot;
+#include &quot;System/Sound.h&quot;
 #include &quot;System/FileSystem/SimpleParser.h&quot;
-#include &quot;System/Sound.h&quot;
 #include &quot;TimeProfiler.h&quot;
 #include &quot;TooltipConsole.h&quot;
 #include &quot;mmgr.h&quot;
@@ -1223,7 +1223,7 @@
 	DrawNotes();
 
 	// allow the LUA scripts to draw into the minimap
-	luaCallIns.DrawInMiniMap();
+	eventHandler.DrawInMiniMap();
 
 	// reset the modelview
 	glLoadIdentity();

Modified: trunk/rts/Game/UI/MouseHandler.cpp
===================================================================
--- trunk/rts/Game/UI/MouseHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/UI/MouseHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -26,7 +26,6 @@
 #include &quot;Game/Player.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaInputReceiver.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
@@ -41,6 +40,7 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitTracker.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -477,7 +477,7 @@
 void CMouseHandler::MouseWheel(bool up)
 {
 	const float value = up ? +scrollWheelSpeed : -scrollWheelSpeed;
-	if (luaCallIns.MouseWheel(up, value)) {
+	if (eventHandler.MouseWheel(up, value)) {
 		return;
 	}
 	camHandler-&gt;GetCurrentController().MouseWheelMove(value);

Modified: trunk/rts/Game/UI/TooltipConsole.cpp
===================================================================
--- trunk/rts/Game/UI/TooltipConsole.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Game/UI/TooltipConsole.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -10,13 +10,13 @@
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/MetalMap.h&quot;
 #include &quot;Map/ReadMap.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -180,7 +180,7 @@
 
 std::string CTooltipConsole::MakeUnitString(const CUnit* unit)
 {
-	string custom = luaCallIns.WorldTooltip(unit, NULL, NULL);
+	string custom = eventHandler.WorldTooltip(unit, NULL, NULL);
 	if (!custom.empty()) {
 		return custom;
 	}
@@ -297,7 +297,7 @@
 
 std::string CTooltipConsole::MakeFeatureString(const CFeature* feature)
 {
-	string custom = luaCallIns.WorldTooltip(NULL, feature, NULL);
+	string custom = eventHandler.WorldTooltip(NULL, feature, NULL);
 	if (!custom.empty()) {
 		return custom;
 	}
@@ -329,7 +329,7 @@
 
 std::string CTooltipConsole::MakeGroundString(const float3&amp; pos)
 {
-	string custom = luaCallIns.WorldTooltip(NULL, NULL, &amp;pos);
+	string custom = eventHandler.WorldTooltip(NULL, NULL, &amp;pos);
 	if (!custom.empty()) {
 		return custom;
 	}

Deleted: trunk/rts/Lua/LuaCallInHandler.cpp
===================================================================
--- trunk/rts/Lua/LuaCallInHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaCallInHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -1,711 +0,0 @@
-#include &quot;StdAfx.h&quot;
-// LuaCallInHandler.cpp: implementation of the CLuaCallInHandler class.
-//
-//////////////////////////////////////////////////////////////////////
-
-#include &quot;LuaCallInHandler.h&quot;
-
-#include &quot;LuaInclude.h&quot;
-
-#include &quot;LuaHandle.h&quot;
-#include &quot;LuaOpenGL.h&quot;
-
-
-CLuaCallInHandler luaCallIns;
-
-
-/******************************************************************************/
-/******************************************************************************/
-
-CLuaCallInHandler::CLuaCallInHandler()
-{
-	mouseOwner = NULL;
-
-	callInMap[&quot;GamePreload&quot;]         = &listGamePreload;
-	callInMap[&quot;GameStart&quot;]           = &listGameStart;
-	callInMap[&quot;GameOver&quot;]            = &listGameOver;
-	callInMap[&quot;TeamDied&quot;]            = &listTeamDied;
-
-	callInMap[&quot;UnitCreated&quot;]         = &listUnitCreated;
-	callInMap[&quot;UnitFinished&quot;]        = &listUnitFinished;
-	callInMap[&quot;UnitFromFactory&quot;]     = &listUnitFromFactory;
-	callInMap[&quot;UnitDestroyed&quot;]       = &listUnitDestroyed;
-	callInMap[&quot;UnitTaken&quot;]           = &listUnitTaken;
-	callInMap[&quot;UnitGiven&quot;]           = &listUnitGiven;
-
-	callInMap[&quot;UnitIdle&quot;]            = &listUnitIdle;
-	callInMap[&quot;UnitCmdDone&quot;]         = &listUnitCmdDone;
-	callInMap[&quot;UnitDamaged&quot;]         = &listUnitDamaged;
-	callInMap[&quot;UnitExperience&quot;]      = &listUnitExperience;
-	callInMap[&quot;UnitSeismicPing&quot;]     = &listUnitSeismicPing;
-	callInMap[&quot;UnitEnteredRadar&quot;]    = &listUnitEnteredRadar;
-	callInMap[&quot;UnitEnteredLos&quot;]      = &listUnitEnteredLos;
-	callInMap[&quot;UnitLeftRadar&quot;]       = &listUnitLeftRadar;
-	callInMap[&quot;UnitLeftLos&quot;]         = &listUnitLeftLos;
-
-	callInMap[&quot;UnitEnteredWater&quot;]    = &listUnitEnteredWater;
-	callInMap[&quot;UnitEnteredAir&quot;]      = &listUnitEnteredAir;
-	callInMap[&quot;UnitLeftWater&quot;]       = &listUnitLeftWater;
-	callInMap[&quot;UnitLeftAir&quot;]         = &listUnitLeftAir;
-
-	callInMap[&quot;UnitLoaded&quot;]          = &listUnitLoaded;
-	callInMap[&quot;UnitUnloaded&quot;]        = &listUnitUnloaded;
-
-	callInMap[&quot;UnitCloaked&quot;]         = &listUnitCloaked;
-	callInMap[&quot;UnitDecloaked&quot;]       = &listUnitDecloaked;
-
-	callInMap[&quot;FeatureCreated&quot;]      = &listFeatureCreated;
-	callInMap[&quot;FeatureDestroyed&quot;]    = &listFeatureDestroyed;
-
-	callInMap[&quot;ProjectileCreated&quot;]   = &listProjectileCreated;
-	callInMap[&quot;ProjectileDestroyed&quot;] = &listProjectileDestroyed;
-
-	callInMap[&quot;Explosion&quot;]           = &listExplosion;
-
-	callInMap[&quot;StockpileChanged&quot;]    = &listStockpileChanged;
-
-	callInMap[&quot;Update&quot;]              = &listUpdate;
-
-	callInMap[&quot;ViewResize&quot;]          = &listViewResize;
-
-	callInMap[&quot;DefaultCommand&quot;]      = &listDefaultCommand;
-
-	callInMap[&quot;DrawGenesis&quot;]         = &listDrawGenesis;
-	callInMap[&quot;DrawWorld&quot;]           = &listDrawWorld;
-	callInMap[&quot;DrawWorldPreUnit&quot;]    = &listDrawWorldPreUnit;
-	callInMap[&quot;DrawWorldShadow&quot;]     = &listDrawWorldShadow;
-	callInMap[&quot;DrawWorldReflection&quot;] = &listDrawWorldReflection;
-	callInMap[&quot;DrawWorldRefraction&quot;] = &listDrawWorldRefraction;
-	callInMap[&quot;DrawScreenEffects&quot;]   = &listDrawScreenEffects;
-	callInMap[&quot;DrawScreen&quot;]          = &listDrawScreen;
-	callInMap[&quot;DrawInMiniMap&quot;]       = &listDrawInMiniMap;
-
-  // from LuaUI
-  callInMap[&quot;KeyPress&quot;]        = &listKeyPress;
-  callInMap[&quot;KeyRelease&quot;]      = &listKeyRelease;
-  callInMap[&quot;MouseMove&quot;]       = &listMouseMove;
-  callInMap[&quot;MousePress&quot;]      = &listMousePress;
-  callInMap[&quot;MouseRelease&quot;]    = &listMouseRelease;
-  callInMap[&quot;MouseWheel&quot;]      = &listMouseWheel;
-  callInMap[&quot;IsAbove&quot;]         = &listIsAbove;
-  callInMap[&quot;GetTooltip&quot;]      = &listGetTooltip;
-  callInMap[&quot;CommandNotify&quot;]   = &listCommandNotify;
-  callInMap[&quot;AddConsoleLine&quot;]  = &listAddConsoleLine;
-  callInMap[&quot;GroupChanged&quot;]    = &listGroupChanged;
-  callInMap[&quot;GameSetup&quot;]       = &listGameSetup;
-  callInMap[&quot;WorldTooltip&quot;]    = &listWorldTooltip;
-  callInMap[&quot;MapDrawCmd&quot;]      = &listMapDrawCmd;
-}
-
-
-CLuaCallInHandler::~CLuaCallInHandler()
-{
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-
-void CLuaCallInHandler::AddHandle(CLuaHandle* lh)
-{
-	ListInsert(handles, lh);
-
-#define ADDHANDLE(name) \
-  if (lh-&gt;HasCallIn(#name)) { ListInsert(list ## name, lh); }
-  
-	ADDHANDLE(GamePreload);
-	ADDHANDLE(GameStart);
-	ADDHANDLE(GameOver);
-	ADDHANDLE(TeamDied);
-
-	ADDHANDLE(UnitCreated);
-	ADDHANDLE(UnitFinished);
-	ADDHANDLE(UnitFromFactory);
-	ADDHANDLE(UnitDestroyed);
-	ADDHANDLE(UnitTaken);
-	ADDHANDLE(UnitGiven);
-
-	ADDHANDLE(UnitIdle);
-	ADDHANDLE(UnitCmdDone);
-	ADDHANDLE(UnitDamaged);
-	ADDHANDLE(UnitExperience);
-
-	ADDHANDLE(UnitSeismicPing);
-	ADDHANDLE(UnitEnteredRadar);
-	ADDHANDLE(UnitEnteredLos);
-	ADDHANDLE(UnitLeftRadar);
-	ADDHANDLE(UnitLeftLos);
-
-	ADDHANDLE(UnitEnteredWater);
-	ADDHANDLE(UnitEnteredAir);
-	ADDHANDLE(UnitLeftWater);
-	ADDHANDLE(UnitLeftAir);
-
-	ADDHANDLE(UnitLoaded);
-	ADDHANDLE(UnitUnloaded);
-
-	ADDHANDLE(UnitCloaked);
-	ADDHANDLE(UnitDecloaked);
-
-	ADDHANDLE(FeatureCreated);
-	ADDHANDLE(FeatureDestroyed);
-
-	ADDHANDLE(ProjectileCreated);
-	ADDHANDLE(ProjectileDestroyed);
-
-	ADDHANDLE(Explosion);
-
-	ADDHANDLE(StockpileChanged);
-
-	ADDHANDLE(Update);
-
-	ADDHANDLE(ViewResize);
-
-	ADDHANDLE(DefaultCommand);
-
-	ADDHANDLE(DrawGenesis);
-	ADDHANDLE(DrawWorld);
-	ADDHANDLE(DrawWorldPreUnit);
-	ADDHANDLE(DrawWorldShadow);
-	ADDHANDLE(DrawWorldReflection);
-	ADDHANDLE(DrawWorldRefraction);
-	ADDHANDLE(DrawScreenEffects);
-	ADDHANDLE(DrawScreen);
-	ADDHANDLE(DrawInMiniMap);
-
-  // from LuaUI
-  ADDHANDLE(KeyPress);
-  ADDHANDLE(KeyRelease);
-  ADDHANDLE(MouseMove);
-  ADDHANDLE(MousePress);
-  ADDHANDLE(MouseRelease);
-  ADDHANDLE(MouseWheel);
-  ADDHANDLE(IsAbove);
-  ADDHANDLE(GetTooltip);
-  ADDHANDLE(CommandNotify);
-  ADDHANDLE(AddConsoleLine);
-  ADDHANDLE(GroupChanged);
-  ADDHANDLE(GameSetup);
-  ADDHANDLE(WorldTooltip);
-  ADDHANDLE(MapDrawCmd);
-}
-
-
-void CLuaCallInHandler::RemoveHandle(CLuaHandle* lh)
-{
-	if (mouseOwner == lh) {
-		// ??
-		mouseOwner == NULL;
-	}
-
-	ListRemove(handles, lh);
-
-	ListRemove(listGamePreload, lh);
-	ListRemove(listGameStart, lh);
-	ListRemove(listGameOver, lh);
-	ListRemove(listTeamDied, lh);
-
-	ListRemove(listUnitCreated, lh);
-	ListRemove(listUnitFinished, lh);
-	ListRemove(listUnitFromFactory, lh);
-	ListRemove(listUnitDestroyed, lh);
-
-	ListRemove(listUnitTaken, lh);
-	ListRemove(listUnitGiven, lh);
-
-	ListRemove(listUnitIdle, lh);
-	ListRemove(listUnitCmdDone, lh);
-	ListRemove(listUnitDamaged, lh);
-	ListRemove(listUnitExperience, lh);
-
-	ListRemove(listUnitSeismicPing, lh);
-	ListRemove(listUnitEnteredRadar, lh);
-	ListRemove(listUnitEnteredLos, lh);
-	ListRemove(listUnitLeftRadar, lh);
-	ListRemove(listUnitLeftLos, lh);
-
-	ListRemove(listUnitEnteredWater, lh);
-	ListRemove(listUnitEnteredAir, lh);
-	ListRemove(listUnitLeftWater, lh);
-	ListRemove(listUnitLeftAir, lh);
-
-	ListRemove(listUnitLoaded, lh);
-	ListRemove(listUnitUnloaded, lh);
-
-	ListRemove(listUnitCloaked, lh);
-	ListRemove(listUnitDecloaked, lh);
-
-	ListRemove(listFeatureCreated, lh);
-	ListRemove(listFeatureDestroyed, lh);
-
-	ListRemove(listProjectileCreated, lh);
-	ListRemove(listProjectileDestroyed, lh);
-
-	ListRemove(listExplosion, lh);
-
-	ListRemove(listStockpileChanged, lh);
-
-	ListRemove(listUpdate, lh);
-
-	ListRemove(listViewResize, lh);
-
-	ListRemove(listDefaultCommand, lh);
-
-	ListRemove(listDrawGenesis, lh);
-	ListRemove(listDrawWorld, lh);
-	ListRemove(listDrawWorldPreUnit, lh);
-	ListRemove(listDrawWorldShadow, lh);
-	ListRemove(listDrawWorldReflection, lh);
-	ListRemove(listDrawWorldRefraction, lh);
-	ListRemove(listDrawScreenEffects, lh);
-	ListRemove(listDrawScreen, lh);
-	ListRemove(listDrawInMiniMap, lh);
-
-  // from LuaUI
-  ListRemove(listKeyPress, lh);
-  ListRemove(listKeyRelease, lh);
-  ListRemove(listMouseMove, lh);
-  ListRemove(listMousePress, lh);
-  ListRemove(listMouseRelease, lh);
-  ListRemove(listMouseWheel, lh);
-  ListRemove(listIsAbove, lh);
-  ListRemove(listGetTooltip, lh);
-  ListRemove(listCommandNotify, lh);
-  ListRemove(listAddConsoleLine, lh);
-  ListRemove(listGroupChanged, lh);
-  ListRemove(listGameSetup, lh);
-  ListRemove(listWorldTooltip, lh);
-  ListRemove(listMapDrawCmd, lh);
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-
-bool CLuaCallInHandler::ManagedCallIn(const string&amp; ciName)
-{
-	return (callInMap.find(ciName) != callInMap.end());
-}
-
-
-bool CLuaCallInHandler::UnsyncedCallIn(const string&amp; ciName)
-{
-	if ((ciName == &quot;Update&quot;)              ||
-	    (ciName == &quot;DefaultCommand&quot;)      ||
-	    (ciName == &quot;ViewResize&quot;)          ||
-	    (ciName == &quot;DrawGenesis&quot;)         ||
-	    (ciName == &quot;DrawWorld&quot;)           ||
-	    (ciName == &quot;DrawWorldPreUnit&quot;)    ||
-	    (ciName == &quot;DrawWorldShadow&quot;)     ||
-	    (ciName == &quot;DrawWorldReflection&quot;) ||
-	    (ciName == &quot;DrawWorldRefraction&quot;) ||
-	    (ciName == &quot;DrawScreenEffects&quot;)   ||
-	    (ciName == &quot;DrawScreen&quot;)          ||
-	    (ciName == &quot;DrawInMiniMap&quot;)       ||
-	    (ciName == &quot;DrawUnit&quot;)            ||
-	    (ciName == &quot;AICallIn&quot;)            ||
-      // from LuaUI
-      (ciName == &quot;KeyPress&quot;)            ||
-      (ciName == &quot;KeyRelease&quot;)          ||
-      (ciName == &quot;MouseMove&quot;)           ||
-      (ciName == &quot;MousePress&quot;)          ||
-      (ciName == &quot;MouseRelease&quot;)        ||
-      (ciName == &quot;MouseWheel&quot;)          ||
-      (ciName == &quot;IsAbove&quot;)             ||
-      (ciName == &quot;GetTooltip&quot;)          ||
-      (ciName == &quot;CommandNotify&quot;)       ||
-      (ciName == &quot;AddConsoleLine&quot;)      ||
-      (ciName == &quot;GroupChanged&quot;)        ||
-      (ciName == &quot;GameSetup&quot;)           ||
-      (ciName == &quot;WorldTooltip&quot;)        ||
-      (ciName == &quot;MapDrawCmd&quot;)) {
-		return true;
-	}
-	return false;
-}
-
-
-bool CLuaCallInHandler::InsertCallIn(CLuaHandle* lh, const string&amp; ciName)
-{
-	map&lt;string, CallInList*&gt;::iterator it = callInMap.find(ciName);
-	if (it == callInMap.end()) {
-		return false;
-	}
-	ListInsert(*(it-&gt;second), lh);
-	return true;
-}
-
-
-bool CLuaCallInHandler::RemoveCallIn(CLuaHandle* lh, const string&amp; ciName)
-{
-	map&lt;string, CallInList*&gt;::iterator it = callInMap.find(ciName);
-	if (it == callInMap.end()) {
-		return false;
-	}
-	ListRemove(*(it-&gt;second), lh);
-	return true;
-}
-
-
-/******************************************************************************/
-
-void CLuaCallInHandler::ListInsert(CallInList&amp; ciList, CLuaHandle* lh)
-{
-	CallInList::iterator it;
-	for (it = ciList.begin(); it != ciList.end(); ++it) {
-		const CLuaHandle* lhList = *it;
-		if (lh == lhList) {
-			return; // already in the list
-		}
-		else if ((lh-&gt;order &lt; lhList-&gt;order) ||
-		         ((lh-&gt;order == lhList-&gt;order) &amp;&amp;
-		          (lh-&gt;name &lt; lhList-&gt;name))) {
-			ciList.insert(it, lh);
-			return;
-		}
-	}
-	ciList.push_back(lh);
-}
-
-
-void CLuaCallInHandler::ListRemove(CallInList&amp; ciList, CLuaHandle* lh)
-{
-	CallInList newList;
-	for (int i = 0; i &lt; ciList.size(); i++) {
-		if (lh != ciList[i]) {
-			newList.push_back(ciList[i]);
-		}
-	}
-	ciList = newList;
-}
-		
-
-/******************************************************************************/
-/******************************************************************************/
-
-void CLuaCallInHandler::GamePreload()
-{
-	const int count = listGamePreload.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listGamePreload[i];
-		lh-&gt;GamePreload();
-	}	
-}
-
-void CLuaCallInHandler::GameStart()
-{
-	const int count = listGameStart.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listGameStart[i];
-		lh-&gt;GameStart();
-	}	
-}
-
-void CLuaCallInHandler::GameOver()
-{
-	const int count = listGameOver.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listGameOver[i];
-		lh-&gt;GameOver();
-	}
-}
-
-
-void CLuaCallInHandler::TeamDied(int teamID)
-{
-	const int count = listTeamDied.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listTeamDied[i];
-		lh-&gt;TeamDied(teamID);
-	}
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-
-void CLuaCallInHandler::Update()
-{
-	const int count = listUpdate.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUpdate[i];
-		lh-&gt;Update();
-	}
-}
-
-
-void CLuaCallInHandler::ViewResize()
-{
-	const int count = listViewResize.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listViewResize[i];
-		lh-&gt;ViewResize();
-	}
-}
-
-
-#define DRAW_CALLIN(name)                         \
-  void CLuaCallInHandler:: Draw ## name ()        \
-  {                                               \
-    const int count = listDraw ## name.size();    \
-    if (count &lt;= 0) {                             \
-      return;                                     \
-    }                                             \
-                                                  \
-    LuaOpenGL::EnableDraw ## name ();             \
-    listDraw ## name [0]-&gt;Draw ## name ();        \
-                                                  \
-    for (int i = 1; i &lt; count; i++) {             \
-      LuaOpenGL::ResetDraw ## name ();            \
-      CLuaHandle* lh = listDraw ## name [i];      \
-      lh-&gt; Draw ## name ();                       \
-    }                                             \
-                                                  \
-    LuaOpenGL::DisableDraw ## name ();            \
-  }
-
-DRAW_CALLIN(Genesis)
-DRAW_CALLIN(World)
-DRAW_CALLIN(WorldPreUnit)
-DRAW_CALLIN(WorldShadow)
-DRAW_CALLIN(WorldReflection)
-DRAW_CALLIN(WorldRefraction)
-DRAW_CALLIN(ScreenEffects)
-DRAW_CALLIN(Screen)
-DRAW_CALLIN(InMiniMap)
-
-
-/******************************************************************************/
-/******************************************************************************/
-//
-// from LuaUI
-//
-
-
-static inline bool CheckModUICtrl(const CLuaHandle* lh)
-{
-	return CLuaHandle::GetModUICtrl() || 
-	       CLuaHandle::GetActiveHandle()-&gt;GetUserMode();
-}
-
-
-
-
-bool CLuaCallInHandler::CommandNotify(const Command&amp; cmd)
-{
-	// reverse order, user has the override
-	const int count = listCommandNotify.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listCommandNotify[i];
-		if (CheckModUICtrl(lh)) {
-			if (lh-&gt;CommandNotify(cmd)) {
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-
-bool CLuaCallInHandler::KeyPress(unsigned short key, bool isRepeat)
-{
-	// reverse order, user has the override
-	const int count = listKeyPress.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listKeyPress[i];
-		if (CheckModUICtrl(lh)) {
-			if (lh-&gt;KeyPress(key, isRepeat)) {
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-
-bool CLuaCallInHandler::KeyRelease(unsigned short key)
-{
-	// reverse order, user has the override
-	const int count = listKeyRelease.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listKeyRelease[i];
-		if (CheckModUICtrl(lh)) {
-			if (lh-&gt;KeyRelease(key)) {
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-
-bool CLuaCallInHandler::MousePress(int x, int y, int button)
-{
-	// reverse order, user has the override
-	const int count = listMousePress.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listMousePress[i];
-		if (CheckModUICtrl(lh)) {
-			if (lh-&gt;MousePress(x, y, button)) {
-				mouseOwner = lh;
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-
-// return a cmd index, or -1
-int CLuaCallInHandler::MouseRelease(int x, int y, int button)
-{
-	if (mouseOwner == NULL) {
-		return -1;
-	}
-	const int retval = mouseOwner-&gt;MouseRelease(x, y, button);
-	mouseOwner = NULL;
-	return retval;
-}
-
-
-bool CLuaCallInHandler::MouseMove(int x, int y, int dx, int dy, int button)
-{
-	if (mouseOwner == NULL) {
-		return false;
-	}
-	return mouseOwner-&gt;MouseMove(x, y, dx, dy, button);
-}
-
-
-bool CLuaCallInHandler::MouseWheel(bool up, float value)
-{
-	// reverse order, user has the override
-	const int count = listMouseWheel.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listMouseWheel[i];
-		if (CheckModUICtrl(lh)) {
-			if (lh-&gt;MouseWheel(up, value)) {
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-
-bool CLuaCallInHandler::IsAbove(int x, int y)
-{
-	// reverse order, user has the override
-	const int count = listIsAbove.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listIsAbove[i];
-		if (CheckModUICtrl(lh)) {
-			if (lh-&gt;IsAbove(x, y)) {
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-
-string CLuaCallInHandler::GetTooltip(int x, int y)
-{
-	// reverse order, user has the override
-	const int count = listGetTooltip.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listGetTooltip[i];
-		if (CheckModUICtrl(lh)) {
-			const string tt = lh-&gt;GetTooltip(x, y);
-			if (!tt.empty()) {
-				return tt;
-			}
-		}
-	}
-	return &quot;&quot;;
-}
-
-
-bool CLuaCallInHandler::AddConsoleLine(const string&amp; msg, int zone)
-{
-	const int count = listAddConsoleLine.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listAddConsoleLine[i];
-		if (CheckModUICtrl(lh)) {
-			lh-&gt;AddConsoleLine(msg, zone);
-		}
-	}
-	return true;
-}
-
-
-bool CLuaCallInHandler::GroupChanged(int groupID)
-{
-	const int count = listGroupChanged.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listGroupChanged[i];
-		if (CheckModUICtrl(lh)) {
-			lh-&gt;GroupChanged(groupID);
-		}
-	}
-	return false;
-}
-
-
-
-bool CLuaCallInHandler::GameSetup(const string&amp; state, bool&amp; ready,
-                                  const map&lt;int, string&gt;&amp; playerStates)
-{
-	// reverse order, user has the override
-	const int count = listGameSetup.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listGameSetup[i];
-		if (CheckModUICtrl(lh)) {
-			if (lh-&gt;GameSetup(state, ready, playerStates)) {
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-
-string CLuaCallInHandler::WorldTooltip(const CUnit* unit,
-                                       const CFeature* feature,
-                                       const float3* groundPos)
-{
-	// reverse order, user has the override
-	const int count = listWorldTooltip.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listWorldTooltip[i];
-		if (CheckModUICtrl(lh)) {
-			const string tt = lh-&gt;WorldTooltip(unit, feature, groundPos);
-			if (!tt.empty()) {
-				return tt;
-			}
-		}
-	}
-	return &quot;&quot;;
-}
-
-
-bool CLuaCallInHandler::MapDrawCmd(int playerID, int type,
-                                   const float3* pos0, const float3* pos1,
-                                   const string* label)
-{
-	// reverse order, user has the override
-	const int count = listMapDrawCmd.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listMapDrawCmd[i];
-		if (CheckModUICtrl(lh)) {
-			if (lh-&gt;MapDrawCmd(playerID, type, pos0, pos1, label)) {
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-
-/******************************************************************************/
-/******************************************************************************/

Deleted: trunk/rts/Lua/LuaCallInHandler.h
===================================================================
--- trunk/rts/Lua/LuaCallInHandler.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaCallInHandler.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -1,542 +0,0 @@
-#ifndef LUA_CALL_IN_HANDLER_H
-#define LUA_CALL_IN_HANDLER_H
-// LuaCallInHandler.h: interface for the CLuaCallInHandler class.
-//
-// NOTE: this should probably be merged with GlobalAIHandler.h,
-//       make a base class for both GlobalAI and LuaHandle
-//
-//////////////////////////////////////////////////////////////////////
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;map&gt;
-using std::string;
-using std::vector;
-using std::map;
-
-#include &quot;LuaHandle.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
-#include &quot;Sim/Features/Feature.h&quot;
-
-
-class CUnit;
-class CWeapon;
-class CFeature;
-class CProjectile;
-struct Command;
-
-
-class CLuaCallInHandler
-{
-	public:
-		CLuaCallInHandler();
-		~CLuaCallInHandler();
-
-		void AddHandle(CLuaHandle* lh);
-		void RemoveHandle(CLuaHandle* lh);
-
-		bool ManagedCallIn(const string&amp; ciName);
-		bool UnsyncedCallIn(const string&amp; ciName);
-
-		bool InsertCallIn(CLuaHandle* lh, const string&amp; ciName);
-		bool RemoveCallIn(CLuaHandle* lh, const string&amp; ciName);
-
-	public:
-		// Synced
-		void GamePreload();
-		void GameStart();
-		void GameOver();
-		void TeamDied(int teamID);
-
-		void PlayerRemoved(int playerID); // not implemented
-
-		void UnitCreated(const CUnit* unit, const CUnit* builder);
-		void UnitFinished(const CUnit* unit);
-		void UnitFromFactory(const CUnit* unit, const CUnit* factory,
-		                     bool userOrders);
-		void UnitDestroyed(const CUnit* unit, const CUnit* attacker);
-		void UnitTaken(const CUnit* unit, int newTeam);
-		void UnitGiven(const CUnit* unit, int oldTeam);
-
-		void UnitIdle(const CUnit* unit);
-		void UnitCmdDone(const CUnit* unit, int cmdType, int cmdTag);
-		void UnitDamaged(const CUnit* unit, const CUnit* attacker,
-		                 float damage, int weaponID, bool paralyzer);
-		void UnitExperience(const CUnit* unit, float oldExperience);
-
-		void UnitSeismicPing(const CUnit* unit, int allyTeam,
-		                     const float3&amp; pos, float strength);
-		void UnitEnteredRadar(const CUnit* unit, int allyTeam);
-		void UnitEnteredLos(const CUnit* unit, int allyTeam);
-		void UnitLeftRadar(const CUnit* unit, int allyTeam);
-		void UnitLeftLos(const CUnit* unit, int allyTeam);
-
-		void UnitEnteredWater(const CUnit* unit);
-		void UnitEnteredAir(const CUnit* unit);
-		void UnitLeftWater(const CUnit* unit);
-		void UnitLeftAir(const CUnit* unit);
-
-		void UnitLoaded(const CUnit* unit, const CUnit* transport);
-		void UnitUnloaded(const CUnit* unit, const CUnit* transport);
-
-		void UnitCloaked(const CUnit* unit);
-		void UnitDecloaked(const CUnit* unit);
-
-		void FeatureCreated(const CFeature* feature);
-		void FeatureDestroyed(const CFeature* feature);
-
-		void ProjectileCreated(const std::pair&lt;CProjectile*, int&gt;&amp; projectilePair);
-		void ProjectileDestroyed(const std::pair&lt;CProjectile*, int&gt;&amp; projectilePair);
-
-		void StockpileChanged(const CUnit* unit,
-		                      const CWeapon* weapon, int oldCount);
-	
-		bool Explosion(int weaponID, const float3&amp; pos, const CUnit* owner);
-
-		// Unsynced
-		void Update();
-
-		void ViewResize();
-
-		bool DefaultCommand(const CUnit* unit, const CFeature* feature, int&amp; cmd);
-
-		void DrawGenesis();
-		void DrawWorld();
-		void DrawWorldPreUnit();
-		void DrawWorldShadow();
-		void DrawWorldReflection();
-		void DrawWorldRefraction();
-		void DrawScreenEffects();
-		void DrawScreen();
-		void DrawInMiniMap();
-
-		// from LuaUI
-		bool KeyPress(unsigned short key, bool isRepeat);
-		bool KeyRelease(unsigned short key);
-		bool MouseMove(int x, int y, int dx, int dy, int button);
-		bool MousePress(int x, int y, int button);
-		int  MouseRelease(int x, int y, int button); // return a cmd index, or -1
-		bool MouseWheel(bool up, float value);
-		bool IsAbove(int x, int y);
-		string GetTooltip(int x, int y);
-
-		bool CommandNotify(const Command&amp; cmd);
-
-		bool AddConsoleLine(const string&amp; msg, int zone);
-
-		bool GroupChanged(int groupID);
-
-		bool GameSetup(const string&amp; state, bool&amp; ready,
-		               const map&lt;int, string&gt;&amp; playerStates);
-
-		string WorldTooltip(const CUnit* unit,
-		                    const CFeature* feature,
-		                    const float3* groundPos);
-
-		bool MapDrawCmd(int playerID, int type,
-		                const float3* pos0,
-		                const float3* pos1,
-		                const string* labe);
-
-//FIXME		void ShockFront(float power, const float3&amp; pos, float areaOfEffect);
-
-	private:
-		typedef vector&lt;CLuaHandle*&gt; CallInList;
-
-	private:
-		void ListInsert(CallInList&amp; ciList, CLuaHandle* lh);
-		void ListRemove(CallInList&amp; ciList, CLuaHandle* lh);
-
-	private:
-		CLuaHandle* mouseOwner;
-
-	private:
-		map&lt;string, CallInList*&gt; callInMap;
-
-		CallInList handles;
-
-		CallInList listGamePreload;
-		CallInList listGameStart;
-		CallInList listGameOver;
-		CallInList listTeamDied;
-
-		CallInList listUnitCreated;
-		CallInList listUnitFinished;
-		CallInList listUnitFromFactory;
-		CallInList listUnitDestroyed;
-		CallInList listUnitTaken;
-		CallInList listUnitGiven;
-
-		CallInList listUnitIdle;
-		CallInList listUnitCmdDone;
-		CallInList listUnitDamaged;
-		CallInList listUnitExperience;
-
-		CallInList listUnitSeismicPing;
-		CallInList listUnitEnteredRadar;
-		CallInList listUnitEnteredLos;
-		CallInList listUnitLeftRadar;
-		CallInList listUnitLeftLos;
-
-		CallInList listUnitEnteredWater;
-		CallInList listUnitEnteredAir;
-		CallInList listUnitLeftWater;
-		CallInList listUnitLeftAir;
-
-		CallInList listUnitLoaded;
-		CallInList listUnitUnloaded;
-
-		CallInList listUnitCloaked;
-		CallInList listUnitDecloaked;
-
-		CallInList listFeatureCreated;
-		CallInList listFeatureDestroyed;
-
-		CallInList listProjectileCreated;
-		CallInList listProjectileDestroyed;
-
-		CallInList listStockpileChanged;
-
-		CallInList listExplosion;
-
-		CallInList listUpdate;
-
-		CallInList listViewResize;
-
-		CallInList listDefaultCommand;
-
-		CallInList listDrawGenesis;
-		CallInList listDrawWorld;
-		CallInList listDrawWorldPreUnit;
-		CallInList listDrawWorldShadow;
-		CallInList listDrawWorldReflection;
-		CallInList listDrawWorldRefraction;
-		CallInList listDrawScreenEffects;
-		CallInList listDrawScreen;
-		CallInList listDrawInMiniMap;
-
-		// from LuaUI
-		CallInList listKeyPress;
-		CallInList listKeyRelease;
-		CallInList listMouseMove;
-		CallInList listMousePress;
-		CallInList listMouseRelease;
-		CallInList listMouseWheel;
-		CallInList listIsAbove;
-		CallInList listGetTooltip;
-		CallInList listConfigCommand;
-		CallInList listCommandNotify;
-		CallInList listAddConsoleLine;
-		CallInList listGroupChanged;
-		CallInList listGameSetup;
-		CallInList listWorldTooltip;
-		CallInList listMapDrawCmd;
-};
-
-
-extern CLuaCallInHandler luaCallIns;
-
-
-//
-// Inlined call-in loops
-//
-
-inline void CLuaCallInHandler::UnitCreated(const CUnit* unit,
-                                           const CUnit* builder)
-{
-	const int unitAllyTeam = unit-&gt;allyteam;
-	const int count = listUnitCreated.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitCreated[i];
-		if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == unitAllyTeam)) {
-			lh-&gt;UnitCreated(unit, builder);
-		}
-	}
-}
-
-
-#define UNIT_CALLIN_NO_PARAM(name)                                        \
-	inline void CLuaCallInHandler:: Unit ## name (const CUnit* unit)        \
-	{                                                                       \
-		const int unitAllyTeam = unit-&gt;allyteam;                              \
-		const int count = listUnit ## name.size();                            \
-		for (int i = 0; i &lt; count; i++) {                                     \
-			CLuaHandle* lh = listUnit ## name [i];                              \
-			if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == unitAllyTeam)) { \
-				lh-&gt; Unit ## name (unit);                                         \
-			}                                                                   \
-		}                                                                     \
-	}
-
-UNIT_CALLIN_NO_PARAM(Finished)
-UNIT_CALLIN_NO_PARAM(Idle)
-UNIT_CALLIN_NO_PARAM(Cloaked)
-UNIT_CALLIN_NO_PARAM(Decloaked)
-UNIT_CALLIN_NO_PARAM(EnteredWater)
-UNIT_CALLIN_NO_PARAM(EnteredAir)
-UNIT_CALLIN_NO_PARAM(LeftWater)
-UNIT_CALLIN_NO_PARAM(LeftAir)
-
-
-#define UNIT_CALLIN_INT_PARAM(name)                                       \
-	inline void CLuaCallInHandler:: Unit ## name (const CUnit* unit, int p) \
-	{                                                                       \
-		const int unitAllyTeam = unit-&gt;allyteam;                              \
-		const int count = listUnit ## name.size();                            \
-		for (int i = 0; i &lt; count; i++) {                                     \
-			CLuaHandle* lh = listUnit ## name [i];                              \
-			if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == unitAllyTeam)) { \
-				lh-&gt; Unit ## name (unit, p);                                      \
-			}                                                                   \
-		}                                                                     \
-	}
-
-UNIT_CALLIN_INT_PARAM(Taken)
-UNIT_CALLIN_INT_PARAM(Given)
-
-
-#define UNIT_CALLIN_LOS_PARAM(name)                                        \
-	inline void CLuaCallInHandler:: Unit ## name (const CUnit* unit, int at) \
-	{                                                                        \
-		const int count = listUnit ## name.size();                             \
-		for (int i = 0; i &lt; count; i++) {                                      \
-			CLuaHandle* lh = listUnit ## name [i];                               \
-			if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == at)) {            \
-				lh-&gt; Unit ## name (unit, at);                                      \
-			}                                                                    \
-		}                                                                      \
-	}
-
-UNIT_CALLIN_LOS_PARAM(EnteredRadar)
-UNIT_CALLIN_LOS_PARAM(EnteredLos)
-UNIT_CALLIN_LOS_PARAM(LeftRadar)
-UNIT_CALLIN_LOS_PARAM(LeftLos)
-
-
-inline void CLuaCallInHandler::UnitFromFactory(const CUnit* unit,
-                                               const CUnit* factory,
-                                               bool userOrders)
-{
-	const int unitAllyTeam = unit-&gt;allyteam;
-	const int count = listUnitFromFactory.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitFromFactory[i];
-		if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == unitAllyTeam)) {
-			lh-&gt;UnitFromFactory(unit, factory, userOrders);
-		}
-	}
-}
-
-
-inline void CLuaCallInHandler::UnitDestroyed(const CUnit* unit,
-                                             const CUnit* attacker)
-{
-	const int unitAllyTeam = unit-&gt;allyteam;
-	const int count = listUnitDestroyed.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitDestroyed[i];
-		if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == unitAllyTeam)) {
-			lh-&gt;UnitDestroyed(unit, attacker);
-		}
-	}
-}
-
-
-inline void CLuaCallInHandler::UnitCmdDone(const CUnit* unit,
-                                           int cmdID, int cmdTag)
-{
-	const int unitAllyTeam = unit-&gt;allyteam;
-	const int count = listUnitCmdDone.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitCmdDone[i];
-		if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == unitAllyTeam)) {
-			lh-&gt;UnitCmdDone(unit, cmdID, cmdTag);
-		}
-	}
-}
-
-
-inline void CLuaCallInHandler::UnitDamaged(const CUnit* unit,
-                                           const CUnit* attacker,
-                                           float damage, int weaponID,
-                                           bool paralyzer)
-{
-	const int unitAllyTeam = unit-&gt;allyteam;
-	const int count = listUnitDamaged.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitDamaged[i];
-		if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == unitAllyTeam)) {
-			lh-&gt;UnitDamaged(unit, attacker, damage, weaponID, paralyzer);
-		}
-	}
-}
-
-
-inline void CLuaCallInHandler::UnitExperience(const CUnit* unit,
-                                              float oldExperience)
-{
-	const int unitAllyTeam = unit-&gt;allyteam;
-	const int count = listUnitExperience.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitExperience[i];
-		if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == unitAllyTeam)) {
-			lh-&gt;UnitExperience(unit, oldExperience);
-		}
-	}
-}
-
-
-inline void  CLuaCallInHandler::UnitSeismicPing(const CUnit* unit,
-                                                int allyTeam,
-                                                const float3&amp; pos,
-                                                float strength)
-{
-	const int count = listUnitSeismicPing.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitSeismicPing[i];
-		if (lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == allyTeam)) {
-			lh-&gt;UnitSeismicPing(unit, allyTeam, pos, strength);
-		}
-	}
-}
-
-
-inline void CLuaCallInHandler::UnitLoaded(const CUnit* unit,
-                                          const CUnit* transport)
-{
-	const int count = listUnitLoaded.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitLoaded[i];
-		const int lhAllyTeam = lh-&gt;GetReadAllyTeam();
-		if (lh-&gt;GetFullRead() ||
-		    (lhAllyTeam == unit-&gt;allyteam) ||
-		    (lhAllyTeam == transport-&gt;allyteam)) {
-			lh-&gt;UnitLoaded(unit, transport);
-		}
-	}
-}
-
-
-inline void CLuaCallInHandler::UnitUnloaded(const CUnit* unit,
-                                            const CUnit* transport)
-{
-	const int count = listUnitUnloaded.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listUnitUnloaded[i];
-		const int lhAllyTeam = lh-&gt;GetReadAllyTeam();
-		if (lh-&gt;GetFullRead() ||
-		    (lhAllyTeam == unit-&gt;allyteam) ||
-		    (lhAllyTeam == transport-&gt;allyteam)) {
-			lh-&gt;UnitUnloaded(unit, transport);
-		}
-	}
-}
-
-
-inline void CLuaCallInHandler::FeatureCreated(const CFeature* feature)
-{
-	const int featureAllyTeam = feature-&gt;allyteam;
-	const int count = listFeatureCreated.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listFeatureCreated[i];
-		if ((featureAllyTeam &lt; 0) || // global team
-		    lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == featureAllyTeam)) {
-			lh-&gt;FeatureCreated(feature);
-		}
-	}
-}
-
-inline void CLuaCallInHandler::FeatureDestroyed(const CFeature* feature)
-{
-	const int featureAllyTeam = feature-&gt;allyteam;
-	const int count = listFeatureDestroyed.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listFeatureDestroyed[i];
-		if ((featureAllyTeam &lt; 0) || // global team
-		    lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == featureAllyTeam)) {
-			lh-&gt;FeatureDestroyed(feature);
-		}
-	}
-}
-
-
-
-inline void CLuaCallInHandler::ProjectileCreated(const std::pair&lt;CProjectile*, int&gt;&amp; projectilePair)
-{
-	const CProjectile* pro = projectilePair.first;
-	const int proAllyTeam = projectilePair.second;
-	const int count = listProjectileCreated.size();
-
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listProjectileCreated[i];
-		if ((proAllyTeam &lt; 0) || // projectile had no owner at creation
-		    lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == proAllyTeam)) {
-			lh-&gt;ProjectileCreated(pro);
-		}
-	}
-}
-
-inline void CLuaCallInHandler::ProjectileDestroyed(const std::pair&lt;CProjectile*, int&gt;&amp; projectilePair)
-{
-	const CProjectile* pro = projectilePair.first;
-	const int proAllyTeam = projectilePair.second;
-	const int count = listProjectileDestroyed.size();
-
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listProjectileDestroyed[i];
-		if ((proAllyTeam &lt; 0) || // projectile had no owner at creation
-		    lh-&gt;GetFullRead() || (lh-&gt;GetReadAllyTeam() == proAllyTeam)) {
-			lh-&gt;ProjectileDestroyed(pro);
-		}
-	}
-}
-
-
-
-inline void CLuaCallInHandler::StockpileChanged(const CUnit* unit,
-                                                const CWeapon* weapon,
-                                                int oldCount)
-{
-	const int count = listStockpileChanged.size();
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listStockpileChanged[i];
-		const int lhAllyTeam = lh-&gt;GetReadAllyTeam();
-		if (lh-&gt;GetFullRead() || (lhAllyTeam == unit-&gt;allyteam)) {
-			lh-&gt;StockpileChanged(unit, weapon, oldCount);
-		}
-	}
-}
-
-
-inline bool CLuaCallInHandler::Explosion(int weaponID,
-                                         const float3&amp; pos, const CUnit* owner)
-{
-	const int count = listExplosion.size();
-	bool noGfx = false;
-	for (int i = 0; i &lt; count; i++) {
-		CLuaHandle* lh = listExplosion[i];
-		if (lh-&gt;GetFullRead()) {
-			noGfx = noGfx || lh-&gt;Explosion(weaponID, pos, owner);
-		}
-	}
-	return noGfx;
-}
-
-
-inline bool CLuaCallInHandler::DefaultCommand(const CUnit* unit,
-                                              const CFeature* feature,
-                                              int&amp; cmd)
-{
-	// reverse order, user has the override
-	const int count = listDefaultCommand.size();
-	for (int i = (count - 1); i &gt;= 0; i--) {
-		CLuaHandle* lh = listDefaultCommand[i];
-		if (lh-&gt;DefaultCommand(unit, feature, cmd)) {
-			return true;
-		}
-	}
-	return false;
-}
-
-
-#endif /* LUA_CALL_IN_HANDLER_H */

Modified: trunk/rts/Lua/LuaFeatureDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaFeatureDefs.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaFeatureDefs.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -247,7 +247,7 @@
 			return 0;
 		}
 		case INT_TYPE: {
-			*((int*)p) = (int)lua_tonumber(L, -1);
+			*((int*)p) = lua_toint(L, -1);
 			return 0;
 		}
 		case BOOL_TYPE: {
@@ -255,7 +255,7 @@
 			return 0;
 		}
 		case FLOAT_TYPE: {
-			*((float*)p) = (float)lua_tonumber(L, -1);
+			*((float*)p) = lua_tofloat(L, -1);
 			return 0;
 		}
 		case STRING_TYPE: {

Modified: trunk/rts/Lua/LuaHandle.cpp
===================================================================
--- trunk/rts/Lua/LuaHandle.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaHandle.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -14,7 +14,6 @@
 #include &quot;Lua/LuaRules.h&quot;
 
 #include &quot;LuaCallInCheck.h&quot;
-#include &quot;LuaCallInHandler.h&quot;
 #include &quot;LuaHashString.h&quot;
 #include &quot;LuaOpenGL.h&quot;
 #include &quot;LuaBitOps.h&quot;
@@ -31,6 +30,7 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/SpringApp.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
@@ -44,7 +44,7 @@
 
 CLuaHandle* CLuaHandle::activeHandle = NULL;
 bool CLuaHandle::activeFullRead    = false;
-int CLuaHandle::activeReadAllyTeam = CLuaHandle::NoAccessTeam;
+int CLuaHandle::activeReadAllyTeam = CEventClient::NoAccessTeam;
 
 
 /******************************************************************************/
@@ -52,8 +52,7 @@
 
 CLuaHandle::CLuaHandle(const string&amp; _name, int _order,
                        bool _userMode, LuaCobCallback callback)
-: name       (_name),
-  order      (_order),
+: CEventClient(_name, _order, false), // FIXME
   userMode   (_userMode),
   cobCallback(callback),
   killMe     (false),
@@ -66,7 +65,7 @@
 
 CLuaHandle::~CLuaHandle()
 {
-	luaCallIns.RemoveHandle(this);
+	eventHandler.RemoveClient(this);
 
 	// free the lua state
 	KillLua();
@@ -169,7 +168,7 @@
 {
 	const int top = lua_gettop(L);
 	if (top != 0) {
-		logOutput.Print(&quot;WARNING: %s stack check: top = %i\n&quot;, name.c_str(), top);
+		logOutput.Print(&quot;WARNING: %s stack check: top = %i\n&quot;, GetName().c_str(), top);
 		lua_settop(L, 0);
 	}
 }
@@ -186,7 +185,7 @@
 	SetActiveHandle(orig);
 
 	if (error != 0) {
-		logOutput.Print(&quot;%s::RunCallIn: error = %i, %s, %s\n&quot;, name.c_str(), error,
+		logOutput.Print(&quot;%s::RunCallIn: error = %i, %s, %s\n&quot;, GetName().c_str(), error,
 		                hs.GetString().c_str(), lua_tostring(L, -1));
 		lua_pop(L, 1);
 		// log only errors that lead to a crash
@@ -283,6 +282,40 @@
 }
 
 
+void CLuaHandle::TeamChanged(int teamID)
+{
+	LUA_CALL_IN_CHECK(L);	
+	lua_checkstack(L, 3);
+	static const LuaHashString cmdStr(&quot;TeamChanged&quot;);
+	if (!cmdStr.GetGlobalFunc(L)) {
+		return; // the call is not defined
+	}
+
+	lua_pushnumber(L, teamID);
+
+	// call the routine
+	RunCallIn(cmdStr, 1, 0);
+	return;
+}
+
+
+void CLuaHandle::PlayerChanged(int playerID)
+{
+	LUA_CALL_IN_CHECK(L);	
+	lua_checkstack(L, 3);
+	static const LuaHashString cmdStr(&quot;PlayerChanged&quot;);
+	if (!cmdStr.GetGlobalFunc(L)) {
+		return; // the call is not defined
+	}
+
+	lua_pushnumber(L, playerID);
+
+	// call the routine
+	RunCallIn(cmdStr, 1, 0);
+	return;
+}
+
+
 /******************************************************************************/
 
 inline void CLuaHandle::UnitCallIn(const LuaHashString&amp; hs, const CUnit* unit)
@@ -431,6 +464,36 @@
 }
 
 
+void CLuaHandle::UnitCommand(const CUnit* unit, const Command&amp; command)
+{
+	LUA_CALL_IN_CHECK(L);	
+	lua_checkstack(L, 10);
+	static const LuaHashString cmdStr(&quot;UnitCommand&quot;);
+	if (!cmdStr.GetGlobalFunc(L)) {
+		return; // the call is not defined
+	}
+
+	lua_pushnumber(L, unit-&gt;id);
+	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
+	lua_pushnumber(L, unit-&gt;team);
+
+	lua_pushnumber(L, command.id);
+	lua_pushnumber(L, command.options);
+
+	const vector&lt;float&gt; params = command.params;
+	lua_createtable(L, params.size(), 0);
+	for (unsigned int i = 0; i &lt; params.size(); i++) {
+		lua_pushnumber(L, i + 1);
+		lua_pushnumber(L, params[i]);
+		lua_rawset(L, -3);
+	}
+
+	// call the routine
+	RunCallIn(cmdStr, 6, 0);
+	return;
+}
+
+
 void CLuaHandle::UnitCmdDone(const CUnit* unit, int cmdID, int cmdTag)
 {
 	LUA_CALL_IN_CHECK(L);	
@@ -738,7 +801,7 @@
 	const bool b = (projectile-&gt;owner != 0x0);
 
 	lua_pushnumber(L, projectile-&gt;id);
-	lua_pushnumber(L, b? projectile-&gt;owner-&gt;id: -1);
+	lua_pushnumber(L, b ? projectile-&gt;owner-&gt;id : -1);
 
 	// call the routine
 	RunCallIn(cmdStr, 2, 0);
@@ -792,10 +855,8 @@
 	RunCallIn(cmdStr, (owner == NULL) ? 4 : 5, 1);
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return false;
 	}
@@ -1006,7 +1067,7 @@
 		return false;
 	}
 
-	cmd = (int)lua_tonumber(L, -1);
+	cmd = lua_toint(L, -1);
 	lua_pop(L, 1);
 	return true;
 }
@@ -1177,8 +1238,19 @@
 /******************************************************************************/
 /******************************************************************************/
 
+static inline bool CheckModUICtrl()
+{
+	return CLuaHandle::GetModUICtrl() || 
+	       CLuaHandle::GetActiveHandle()-&gt;GetUserMode();
+}
+
+
+
 bool CLuaHandle::KeyPress(unsigned short key, bool isRepeat)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 6);
 	static const LuaHashString cmdStr(&quot;KeyPress&quot;);
@@ -1219,6 +1291,9 @@
 
 bool CLuaHandle::KeyRelease(unsigned short key)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 5);
 	static const LuaHashString cmdStr(&quot;KeyRelease&quot;);
@@ -1256,6 +1331,9 @@
 
 bool CLuaHandle::MousePress(int x, int y, int button)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 5);
 	static const LuaHashString cmdStr(&quot;MousePress&quot;);
@@ -1284,6 +1362,9 @@
 
 int CLuaHandle::MouseRelease(int x, int y, int button)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 5);
 	static const LuaHashString cmdStr(&quot;MouseRelease&quot;);
@@ -1304,7 +1385,7 @@
 		lua_pop(L, 1);
 		return -1;
 	}
-	const int retval = (int)lua_tonumber(L, -1) - 1;
+	const int retval = lua_toint(L, -1) - 1;
 	lua_pop(L, 1);
 	return retval;
 }
@@ -1312,6 +1393,9 @@
 
 bool CLuaHandle::MouseMove(int x, int y, int dx, int dy, int button)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 7);
 	static const LuaHashString cmdStr(&quot;MouseMove&quot;);
@@ -1342,6 +1426,9 @@
 
 bool CLuaHandle::MouseWheel(bool up, float value)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 4);
 	static const LuaHashString cmdStr(&quot;MouseWheel&quot;);
@@ -1369,6 +1456,9 @@
 
 bool CLuaHandle::IsAbove(int x, int y)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 4);
 	static const LuaHashString cmdStr(&quot;IsAbove&quot;);
@@ -1396,6 +1486,9 @@
 
 string CLuaHandle::GetTooltip(int x, int y)
 {
+	if (!CheckModUICtrl()) {
+		return &quot;&quot;;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 4);
 	static const LuaHashString cmdStr(&quot;GetTooltip&quot;);
@@ -1423,6 +1516,9 @@
 
 bool CLuaHandle::ConfigCommand(const string&amp; command)
 {
+	if (!CheckModUICtrl()) {
+		return true; // FIXME ?
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 2);
 	static const LuaHashString cmdStr(&quot;ConfigureLayout&quot;);
@@ -1442,6 +1538,9 @@
 
 bool CLuaHandle::CommandNotify(const Command&amp; cmd)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 5);
 	static const LuaHashString cmdStr(&quot;CommandNotify&quot;);
@@ -1474,9 +1573,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;CommandNotify() bad return value (%i)\n&quot;, args);
+		logOutput.Print(&quot;CommandNotify() bad return value\n&quot;);
 		lua_pop(L, 1);
 		return false;
 	}
@@ -1489,6 +1587,9 @@
 
 bool CLuaHandle::AddConsoleLine(const string&amp; msg, int zone)
 {
+	if (!CheckModUICtrl()) {
+		return true; // FIXME?
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 4);
 	static const LuaHashString cmdStr(&quot;AddConsoleLine&quot;);
@@ -1511,6 +1612,9 @@
 
 bool CLuaHandle::GroupChanged(int groupID)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 3);
 	static const LuaHashString cmdStr(&quot;GroupChanged&quot;);
@@ -1534,6 +1638,9 @@
                                 const CFeature* feature,
                                 const float3* groundPos)
 {
+	if (!CheckModUICtrl()) {
+		return &quot;&quot;;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 6);
 	static const LuaHashString cmdStr(&quot;WorldTooltip&quot;);
@@ -1584,6 +1691,9 @@
                             const float3* pos1,
                             const string* label)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 9);
 	static const LuaHashString cmdStr(&quot;MapDrawCmd&quot;);
@@ -1646,6 +1756,9 @@
 bool CLuaHandle::GameSetup(const string&amp; state, bool&amp; ready,
                            const map&lt;int, string&gt;&amp; playerStates)
 {
+	if (!CheckModUICtrl()) {
+		return false;
+	}
 	LUA_CALL_IN_CHECK(L);
 	lua_checkstack(L, 5);
 	static const LuaHashString cmdStr(&quot;GameSetup&quot;);
@@ -1702,9 +1815,10 @@
 		HSTR_PUSH_CFUNC(L, &quot;GetSelectTeam&quot;,   CallOutGetSelectTeam);
 		HSTR_PUSH_CFUNC(L, &quot;GetGlobal&quot;,       CallOutGetGlobal);
 		HSTR_PUSH_CFUNC(L, &quot;GetRegistry&quot;,     CallOutGetRegistry);
+		HSTR_PUSH_CFUNC(L, &quot;GetCallInList&quot;,   CallOutGetCallInList);
 		// special team constants
-		HSTR_PUSH_NUMBER(L, &quot;NO_ACCESS_TEAM&quot;,  NoAccessTeam);
-		HSTR_PUSH_NUMBER(L, &quot;ALL_ACCESS_TEAM&quot;, AllAccessTeam);
+		HSTR_PUSH_NUMBER(L, &quot;NO_ACCESS_TEAM&quot;,  CEventClient::NoAccessTeam);
+		HSTR_PUSH_NUMBER(L, &quot;ALL_ACCESS_TEAM&quot;, CEventClient::AllAccessTeam);
 //FIXME		LuaArrays::PushEntries(L);
 	}
 	lua_rawset(L, -3);
@@ -1719,7 +1833,7 @@
 
 int CLuaHandle::CallOutGetName(lua_State* L)
 {
-	lua_pushstring(L, activeHandle-&gt;name.c_str());
+	lua_pushstring(L, activeHandle-&gt;GetName().c_str());
 	return 1;
 }
 
@@ -1793,6 +1907,24 @@
 }
 
 
+int CLuaHandle::CallOutGetCallInList(lua_State* L)
+{
+	vector&lt;string&gt; list;
+	eventHandler.GetEventList(list);
+	lua_createtable(L, 0, list.size());
+	for (unsigned int i = 0; i &lt; list.size(); i++) {
+		lua_pushstring(L, list[i].c_str());
+		lua_newtable(L); {
+			lua_pushliteral(L, &quot;unsynced&quot;);
+			lua_pushboolean(L, eventHandler.IsUnsynced(list[i]));
+			lua_rawset(L, -3);
+		}
+		lua_rawset(L, -3);
+	}
+	return 1;
+}
+
+
 int CLuaHandle::CallOutSyncedUpdateCallIn(lua_State* L)
 {
 	const int args = lua_gettop(L);

Modified: trunk/rts/Lua/LuaHandle.h
===================================================================
--- trunk/rts/Lua/LuaHandle.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaHandle.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -11,6 +11,7 @@
 using std::vector;
 using std::set;
 
+#include &quot;System/EventClient.h&quot;
 //FIXME#include &quot;LuaArrays.h&quot;
 #include &quot;LuaShaders.h&quot;
 #include &quot;LuaTextures.h&quot;
@@ -20,11 +21,11 @@
 #include &quot;LuaDisplayLists.h&quot;
 
 
-#define LUA_HANDLE_ORDER_UNITS          0
-#define LUA_HANDLE_ORDER_RULES          1
+#define LUA_HANDLE_ORDER_RULES          0
+#define LUA_HANDLE_ORDER_UNITS          1
 #define LUA_HANDLE_ORDER_GAIA           2
-#define LUA_HANDLE_ORDER_UNITS_UNSYNCED 3
-#define LUA_HANDLE_ORDER_RULES_UNSYNCED 4
+#define LUA_HANDLE_ORDER_RULES_UNSYNCED 3
+#define LUA_HANDLE_ORDER_UNITS_UNSYNCED 4
 #define LUA_HANDLE_ORDER_GAIA_UNSYNCED  5
 #define LUA_HANDLE_ORDER_UI             6
 
@@ -41,20 +42,14 @@
 typedef void (*LuaCobCallback)(int retCode, void* unitID, void* data);
 
 
-class CLuaHandle {
+class CLuaHandle : public CEventClient
+{
 	public:
-		const string&amp; GetName() const { return name; }
 		void CheckStack();
 		int GetCallInErrors() const { return callinErrors; }
 		void ResetCallinErrors() { callinErrors = 0; }
 		
 	public:
-		enum SpecialTeams {
-			NoAccessTeam   = -1,
-			AllAccessTeam  = -2,
-			MinSpecialTeam = -2
-		};
-
 		inline bool CanCtrlTeam(int team) {
 			if (ctrlTeam &lt; 0) {
 				return (ctrlTeam == AllAccessTeam);
@@ -92,12 +87,11 @@
 		CLuaDisplayLists&amp; GetDisplayLists() { return displayLists; }
 
 	public:
-		const string name;
-		const int order;
 		const bool userMode;
 
 	public: // call-ins
-		virtual bool HasCallIn(const string&amp; name) { return false; }
+		virtual bool HasCallIn(const string&amp; name) { return false; } // FIXME
+		bool WantsEvent(const string&amp; name)  { return HasCallIn(name); } // FIXME
 		virtual bool SyncedUpdateCallIn(const string&amp; name) { return false; }
 		virtual bool UnsyncedUpdateCallIn(const string&amp; name) { return false; }
 
@@ -111,6 +105,8 @@
 		void GameStart();
 		void GameOver();
 		void TeamDied(int teamID);
+		void TeamChanged(int teamID);
+		void PlayerChanged(int playerID);
 
 		void UnitCreated(const CUnit* unit, const CUnit* builder);
 		void UnitFinished(const CUnit* unit);
@@ -121,6 +117,7 @@
 		void UnitGiven(const CUnit* unit, int oldTeam);
 
 		void UnitIdle(const CUnit* unit);
+		void UnitCommand(const CUnit* unit, const Command&amp; command);
 		void UnitCmdDone(const CUnit* unit, int cmdID, int cmdTag);
 		void UnitDamaged(const CUnit* unit, const CUnit* attacker,
 		                 float damage, int weaponID, bool paralyzer);
@@ -232,13 +229,16 @@
 		void UnitCallIn(const LuaHashString&amp; hs, const CUnit* unit);
 		bool PushUnsyncedCallIn(const LuaHashString&amp; hs);
 
+		inline bool CheckModUICtrl() { return modUICtrl || userMode; }
+
 	protected:
 		lua_State* L;
 
 		bool killMe;
 		string killMsg;
 
-		bool synced;
+		bool synced; // FIXME -- remove this once the lua_State split is done
+		             //          (use the constant CEventClient version ...)
 
 		bool fullCtrl;
 		bool fullRead;
@@ -282,6 +282,7 @@
 		static int CallOutGetSelectTeam(lua_State* L);
 		static int CallOutGetGlobal(lua_State* L);
 		static int CallOutGetRegistry(lua_State* L);
+		static int CallOutGetCallInList(lua_State* L);
 		static int CallOutSyncedUpdateCallIn(lua_State* L);
 		static int CallOutUnsyncedUpdateCallIn(lua_State* L);
 

Modified: trunk/rts/Lua/LuaHandleSynced.cpp
===================================================================
--- trunk/rts/Lua/LuaHandleSynced.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaHandleSynced.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -10,7 +10,6 @@
 #include &quot;LuaInclude.h&quot;
 
 #include &quot;LuaCallInCheck.h&quot;
-#include &quot;LuaCallInHandler.h&quot;
 #include &quot;LuaUtils.h&quot;
 #include &quot;LuaConstGL.h&quot;
 #include &quot;LuaConstCMD.h&quot;
@@ -37,6 +36,7 @@
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Units/COB/CobInstance.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;System/Platform/FileSystem.h&quot;
@@ -57,11 +57,11 @@
 /******************************************************************************/
 /******************************************************************************/
 
-CLuaHandleSynced::CLuaHandleSynced(const string&amp; name, int order,
+CLuaHandleSynced::CLuaHandleSynced(const string&amp; _name, int _order,
                                    LuaCobCallback callback,
                                    const string&amp; msgPrefix)
 : messagePrefix(msgPrefix),
-  CLuaHandle(name, order, false, callback),
+  CLuaHandle(_name, _order, false, callback),
   allowChanges(false),
   allowUnsafeChanges(false),
   teamsLocked(false)
@@ -158,7 +158,7 @@
 	}
 
 	// register for call-ins
-	luaCallIns.AddHandle(this);
+	eventHandler.AddClient(this);
 
 	SetActiveHandle(origHandle);
 }
@@ -428,7 +428,7 @@
 	}
 	else if (!lua_isfunction(L, -1)) {
 		lua_settop(L, 0);
-		logOutput.Print(&quot;%s in %s is not a function&quot;, funcName, name.c_str());
+		logOutput.Print(&quot;%s in %s is not a function&quot;, funcName, GetName().c_str());
 		return false;
 	}
 	lua_pushvalue(L, unsynced);
@@ -549,7 +549,7 @@
 	if ((name != &quot;DrawUnit&quot;) &amp;&amp;
 	    (name != &quot;AICallIn&quot;) &amp;&amp;
 	    (name != &quot;RecvFromSynced&quot;) &amp;&amp;
-	    !luaCallIns.UnsyncedCallIn(name)) {
+	    !eventHandler.IsUnsynced(name)) {
 		tableIndex = LUA_GLOBALSINDEX;  // synced call-ins in GLOBAL
 	} else {
 		tableIndex = LUA_REGISTRYINDEX; // unsynced call-ins in REGISTRY
@@ -571,13 +571,13 @@
 bool CLuaHandleSynced::SyncedUpdateCallIn(const string&amp; name)
 {
 	if ((name == &quot;RecvFromSynced&quot;) ||
-	    luaCallIns.UnsyncedCallIn(name)) {
+	    eventHandler.IsUnsynced(name)) {
 		return false;
 	}
 	if (HasCallIn(name)) {
-		luaCallIns.InsertCallIn(this, name);
+		eventHandler.InsertEvent(this, name);
 	} else {
-		luaCallIns.RemoveCallIn(this, name);
+		eventHandler.RemoveEvent(this, name);
 	}
 	return true;
 }	
@@ -586,14 +586,14 @@
 bool CLuaHandleSynced::UnsyncedUpdateCallIn(const string&amp; name)
 {
 	if ((name != &quot;RecvFromSynced&quot;) &amp;&amp;
-	    !luaCallIns.UnsyncedCallIn(name)) {
+	    !eventHandler.IsUnsynced(name)) {
 		  return false;
 	}
 	if (name != &quot;RecvFromSynced&quot;) {
 		if (HasCallIn(name)) {
-			luaCallIns.InsertCallIn(this, name);
+			eventHandler.InsertEvent(this, name);
 		} else {
-			luaCallIns.RemoveCallIn(this, name);
+			eventHandler.RemoveEvent(this, name);
 		}
 	}
 	SetupUnsyncedFunction(name.c_str());
@@ -691,7 +691,7 @@
 void CLuaHandleSynced::GameFrame(int frameNumber)
 {
 	if (killMe) {
-		string msg = name;
+		string msg = GetName();
 		if (!killMsg.empty()) {
 			msg += &quot;: &quot; + killMsg;
 		}
@@ -911,15 +911,15 @@
 		lua_pushnumber(L, gs-&gt;randFloat());
 	}
 	else if ((args == 1) &amp;&amp; lua_isnumber(L, 1)) {
-		const int maxn = (int)lua_tonumber(L, 1);
+		const int maxn = lua_toint(L, 1);
 		if (maxn &lt; 1) {
 			luaL_error(L, &quot;error: too small upper limit (%d) given to math.random(), should be &gt;= 1 {synced}&quot;, maxn);
 		}
 		lua_pushnumber(L, 1 + (gs-&gt;randInt() % maxn));
 	}
 	else if ((args == 2) &amp;&amp; lua_isnumber(L, 1) &amp;&amp; lua_isnumber(L, 2)) {
-		const int lower = (int)lua_tonumber(L, 1);
-		const int upper = (int)lua_tonumber(L, 2);
+		const int lower = lua_toint(L, 1);
+		const int upper = lua_toint(L, 2);
 		if (lower &gt;= upper) {
 			luaL_error(L, &quot;Empty interval in math.random() {synced}&quot;);
 		}
@@ -1001,17 +1001,17 @@
 
 	// parse the new access
 	if (lua_isnumber(L, 1)) {
-		const int teamID = (int)lua_tonumber(L, 1);
+		const int teamID = lua_toint(L, 1);
 		if ((teamID &lt; MinSpecialTeam) || (teamID &gt;= gs-&gt;activeTeams)) {
 			luaL_error(L, &quot;Bad teamID in SetCtrlTeam&quot;);
 		}
 		// ctrl
 		lhs-&gt;ctrlTeam = teamID;
-		lhs-&gt;fullCtrl = (lhs-&gt;ctrlTeam == AllAccessTeam);
+		lhs-&gt;fullCtrl = (lhs-&gt;ctrlTeam == CEventClient::AllAccessTeam);
 		// read
 		lhs-&gt;readTeam = teamID;
 		lhs-&gt;readAllyTeam = (teamID &lt; 0) ? teamID : gs-&gt;AllyTeam(teamID);
-		lhs-&gt;fullRead = (lhs-&gt;readAllyTeam == AllAccessTeam);
+		lhs-&gt;fullRead = (lhs-&gt;readAllyTeam == CEventClient::AllAccessTeam);
 		activeFullRead     = lhs-&gt;fullRead;
 		activeReadAllyTeam = lhs-&gt;readAllyTeam;
 		// select
@@ -1024,19 +1024,19 @@
 				continue;
 			}
 			const string key = lua_tostring(L, -2);
-			const int teamID = (int)lua_tonumber(L, -1);
+			const int teamID = lua_toint(L, -1);
 			if ((teamID &lt; MinSpecialTeam) || (teamID &gt;= gs-&gt;activeTeams)) {
 				luaL_error(L, &quot;Bad teamID in SetCtrlTeam&quot;);
 			}
 
 			if (key == &quot;ctrl&quot;) {
 				lhs-&gt;ctrlTeam = teamID;
-				lhs-&gt;fullCtrl = (lhs-&gt;ctrlTeam == AllAccessTeam);
+				lhs-&gt;fullCtrl = (lhs-&gt;ctrlTeam == CEventClient::AllAccessTeam);
 			}
 			else if (key == &quot;read&quot;) {
 				lhs-&gt;readTeam = teamID;
 				lhs-&gt;readAllyTeam = (teamID &lt; 0) ? teamID : gs-&gt;AllyTeam(teamID);
-				lhs-&gt;fullRead = (lhs-&gt;readAllyTeam == AllAccessTeam);
+				lhs-&gt;fullRead = (lhs-&gt;readAllyTeam == CEventClient::AllAccessTeam);
 				activeFullRead     = lhs-&gt;fullRead;
 				activeReadAllyTeam = lhs-&gt;readAllyTeam;
 			}
@@ -1158,7 +1158,7 @@
 int CLuaHandleSynced::GetWatchWeapon(lua_State* L)
 {
 	CLuaHandleSynced* lhs = GetActiveHandle();
-	const int weaponID = (int)luaL_checknumber(L, 1);
+	const int weaponID = luaL_checkint(L, 1);
 	if ((weaponID &lt; 0) || (weaponID &gt;= (int)lhs-&gt;watchWeapons.size())) {
 		return 0;
 	}
@@ -1170,7 +1170,7 @@
 int CLuaHandleSynced::SetWatchWeapon(lua_State* L)
 {
 	CLuaHandleSynced* lhs = GetActiveHandle();
-	const int weaponID = (int)luaL_checknumber(L, 1);
+	const int weaponID = luaL_checkint(L, 1);
 	if ((weaponID &lt; 0) || (weaponID &gt;= (int)lhs-&gt;watchWeapons.size())) {
 		return 0;
 	}

Added: trunk/rts/Lua/LuaIO.cpp
===================================================================
--- trunk/rts/Lua/LuaIO.cpp	                        (rev 0)
+++ trunk/rts/Lua/LuaIO.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -0,0 +1,149 @@
+#include &quot;StdAfx.h&quot;
+// LuaIO.cpp: implementation of the LuaIO class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &quot;LuaIO.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;string&gt;
+using std::string;
+
+#include &quot;LuaHandle.h&quot;
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+static bool IsSafePath(const string&amp; path)
+{
+	// keep searches within the Spring directory
+	if ((path[0] == '/') || (path[0] == '\\') ||
+	    ((path.size() &gt;= 2) &amp;&amp; (path[1] == ':'))) {
+		return false;
+	}
+	if (path.find(&quot;..&quot;) != string::npos) {
+		return false;
+	}
+	return true;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+bool LuaIO::IsSimplePath(const string&amp; path)
+{
+	// keep searches within the Spring directory
+	if ((path[0] == '/') || (path[0] == '\\') ||
+	    ((path.size() &gt;= 2) &amp;&amp; (path[1] == ':'))) {
+		return false;
+	}
+	if (path.find(&quot;..&quot;) != string::npos) {
+		return false;
+	}
+	return true;
+}
+
+
+bool LuaIO::SafeExecPath(const string&amp; path)
+{
+	return true;
+}
+
+
+bool LuaIO::SafeReadPath(const string&amp; path)
+{
+	return IsSimplePath(path);
+}
+
+
+bool LuaIO::SafeWritePath(const string&amp; path)
+{
+	string prefix = &quot;&quot;; // FIXME
+#if !defined UNITSYNC &amp;&amp; !defined DEDICATED
+	const CLuaHandle* lh = CLuaHandle::GetActiveHandle();
+	if (lh != NULL) {
+		prefix = lh-&gt;GetName() + &quot;/&quot; + &quot;write&quot;;
+	}
+#endif
+	if (path.compare(0, prefix.size(), prefix) != 0) {
+		return false;
+	}
+	return true;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+FILE* LuaIO::fopen(lua_State* L, const char* path, const char* mode)
+{
+	bool read  = false;
+	bool write = false;
+
+	// check the mode string
+	const string modeStr = StringToLower(mode);
+	if (modeStr.find_first_not_of(&quot;rwabt+&quot;) != string::npos) {
+		errno = EINVAL;
+		return NULL;
+	}
+	if (!IsSafePath(path)) {
+		errno = EPERM; //EACCESS?
+		return NULL;
+	}
+	return ::fopen(path, mode);
+}
+
+
+FILE* LuaIO::popen(lua_State* L, const char* command, const char* type)
+{
+	// check the type string
+	const string typeStr = StringToLower(type);
+	if (typeStr.find_first_not_of(&quot;rw&quot;) != string::npos) {
+		errno = EINVAL;
+		return NULL;
+	}
+	errno = EINVAL;	
+	return NULL;
+}
+
+
+int LuaIO::pclose(lua_State* L, FILE* stream)
+{
+	errno = ECHILD;	
+	return -1;
+}
+
+
+int LuaIO::system(lua_State* L, const char* command)
+{
+	return -1;
+}
+
+
+int LuaIO::remove(lua_State* L, const char* pathname)
+{
+	if (!SafeWritePath(pathname)) {
+		errno = EPERM; //EACCESS?
+		return -1;
+	}
+	return ::remove(pathname);
+}
+
+
+int LuaIO::rename(lua_State* L, const char* oldpath, const char* newpath)
+{
+	if (!SafeWritePath(oldpath) ||
+			!SafeWritePath(newpath)) {
+		errno = EPERM; //EACCESS?
+		return -1;
+	}
+	return ::rename(oldpath, newpath);
+}
+
+
+/******************************************************************************/
+/******************************************************************************/

Added: trunk/rts/Lua/LuaIO.h
===================================================================
--- trunk/rts/Lua/LuaIO.h	                        (rev 0)
+++ trunk/rts/Lua/LuaIO.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -0,0 +1,31 @@
+#ifndef LUA_IO_H
+#define LUA_IO_H
+// LuaIO.h: interface for the LuaIO class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &lt;stdio.h&gt;
+
+struct lua_State;
+
+
+class LuaIO {
+	public:
+		static FILE* fopen(lua_State* L, const char* path, const char* mode);
+		static FILE* popen(lua_State* L, const char* command, const char* type);
+		static int   pclose(lua_State* L, FILE* stream);
+		static int   system(lua_State* L, const char* command);
+		static int   remove(lua_State* L, const char* pathname);
+		static int   rename(lua_State* L, const char* oldpath, const char* newpath);
+
+	public:
+		// relative path, with no ..'s
+		static bool IsSimplePath(const std::string&amp; path);
+
+		static bool SafeExecPath(const std::string&amp; path);
+		static bool SafeReadPath(const std::string&amp; path);
+		static bool SafeWritePath(const std::string&amp; path);
+};
+
+
+#endif /* LUA_IO_H */

Modified: trunk/rts/Lua/LuaInputReceiver.cpp
===================================================================
--- trunk/rts/Lua/LuaInputReceiver.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaInputReceiver.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -6,7 +6,7 @@
 #include &lt;string&gt;
 
 #include &quot;LuaInputReceiver.h&quot;
-#include &quot;LuaCallInHandler.h&quot;
+#include &quot;System/EventHandler.h&quot;
 
 
 LuaInputReceiver* luaInputReceiver = NULL;
@@ -25,47 +25,47 @@
 
 bool LuaInputReceiver::KeyPressed(unsigned short key, bool isRepeat)
 {
-	return luaCallIns.KeyPress(key, isRepeat);
+	return eventHandler.KeyPress(key, isRepeat);
 }
 
 
 bool LuaInputReceiver::KeyReleased(unsigned short key)
 {
-	return luaCallIns.KeyRelease(key);
+	return eventHandler.KeyRelease(key);
 }
 
 
 bool LuaInputReceiver::MousePress(int x, int y, int button)
 {
-	return luaCallIns.MousePress(x, y, button);
+	return eventHandler.MousePress(x, y, button);
 }
 
 
 void LuaInputReceiver::MouseMove(int x, int y, int dx, int dy, int button)
 {
-	luaCallIns.MouseMove(x, y, dx, dy, button);
+	eventHandler.MouseMove(x, y, dx, dy, button);
 }
 
 
 void LuaInputReceiver::MouseRelease(int x, int y, int button)
 {
-	luaCallIns.MouseRelease(x, y, button);
+	eventHandler.MouseRelease(x, y, button);
 }
 
 
 bool LuaInputReceiver::IsAbove(int x, int y)
 {
-	return luaCallIns.IsAbove(x, y);
+	return eventHandler.IsAbove(x, y);
 }
 
 
 std::string LuaInputReceiver::GetTooltip(int x, int y)
 {
-	return luaCallIns.GetTooltip(x, y);
+	return eventHandler.GetTooltip(x, y);
 }
 
 
 void LuaInputReceiver::Draw()
 {
-	return luaCallIns.DrawScreen();
+	return eventHandler.DrawScreen();
 }

Modified: trunk/rts/Lua/LuaMaterial.cpp
===================================================================
--- trunk/rts/Lua/LuaMaterial.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaMaterial.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -332,7 +332,7 @@
 	}
 
 	const int maxTex = std::max(texCount, prev.texCount);
-	for (int t = maxTex-1; t &gt;= 0; t--) {
+	for (int t = (maxTex - 1); t &gt;= 0; t--) {
 		glActiveTexture(GL_TEXTURE0 + t);
 		textures[t].Execute(prev.textures[t]);
 	}

Modified: trunk/rts/Lua/LuaOpenGL.cpp
===================================================================
--- trunk/rts/Lua/LuaOpenGL.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaOpenGL.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -42,6 +42,7 @@
 #include &quot;Rendering/GL/glExtra.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/IFramebuffer.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/Textures/NamedTextures.h&quot;
 #include &quot;Rendering/Textures/TextureHandler.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
@@ -52,7 +53,7 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
-#include &quot;Sim/Units/UnitImage.h&quot;
+#include &quot;Sim/Units/UnitDefImage.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitTypes/TransportUnit.h&quot;
 #include &quot;Sim/Units/CommandAI/LineDrawer.h&quot;
@@ -172,6 +173,7 @@
 	REGISTER_LUA_CFUNC(Lighting);
 	REGISTER_LUA_CFUNC(ShadeModel);
 	REGISTER_LUA_CFUNC(Scissor);
+	REGISTER_LUA_CFUNC(Viewport);
 	REGISTER_LUA_CFUNC(ColorMask);
 	REGISTER_LUA_CFUNC(DepthMask);
 	REGISTER_LUA_CFUNC(DepthTest);
@@ -294,6 +296,7 @@
 	REGISTER_LUA_CFUNC(Finish);
 
 	REGISTER_LUA_CFUNC(ReadPixels);
+	REGISTER_LUA_CFUNC(SaveImage);
 
 	if (haveGL20) {
 		REGISTER_LUA_CFUNC(CreateQuery);
@@ -364,6 +367,8 @@
 	glDisable(GL_COLOR_LOGIC_OP);
 	glLogicOp(GL_INVERT);
 
+	// FIXME glViewport(gl); depends on the mode
+
 	// FIXME -- depends on the mode       glDisable(GL_FOG);
 
 	glDisable(GL_CULL_FACE);
@@ -432,8 +437,14 @@
 //
 
 const GLbitfield AttribBits =
-	GL_ENABLE_BIT | GL_POLYGON_BIT | GL_LINE_BIT | GL_POINT_BIT |
-	GL_DEPTH_BUFFER_BIT | GL_LIGHTING_BIT | GL_COLOR_BUFFER_BIT;
+	GL_COLOR_BUFFER_BIT |
+	GL_DEPTH_BUFFER_BIT |
+	GL_ENABLE_BIT       |
+	GL_LIGHTING_BIT     |
+	GL_LINE_BIT         |
+	GL_POINT_BIT        |
+	GL_POLYGON_BIT      |
+	GL_VIEWPORT_BIT;
 
 
 inline void LuaOpenGL::EnableCommon(DrawMode mode)
@@ -1057,8 +1068,8 @@
 	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.ConfigScreen()&quot;);
 	}
-	screenWidth = (float)lua_tonumber(L, 1);
-	screenDistance = (float)lua_tonumber(L, 2);
+	screenWidth = lua_tofloat(L, 1);
+	screenDistance = lua_tofloat(L, 2);
 	return 0;
 }
 
@@ -1106,10 +1117,10 @@
 	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.ConfigMiniMap()&quot;);
 	}
-	const int px = (int)lua_tonumber(L, 1);
-	const int py = (int)lua_tonumber(L, 2);
-	const int sx = (int)lua_tonumber(L, 3);
-	const int sy = (int)lua_tonumber(L, 4);
+	const int px = lua_toint(L, 1);
+	const int py = lua_toint(L, 2);
+	const int sx = lua_toint(L, 3);
+	const int sy = lua_toint(L, 4);
 	minimap-&gt;SetGeometry(px, py, sx, sy);
 	return 0;
 }
@@ -1236,7 +1247,7 @@
 			return NULL;
 		}
 	}
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
 	}
@@ -1248,7 +1259,7 @@
 	const CLuaHandle* lh = CLuaHandle::GetActiveHandle();
 	const int readAllyTeam = lh-&gt;GetReadAllyTeam();
 	if (readAllyTeam &lt; 0) {
-		if (readAllyTeam == CLuaHandle::NoAccessTeam) {
+		if (readAllyTeam == CEventClient::NoAccessTeam) {
 			return NULL;
 		}
 	} else {
@@ -1285,7 +1296,7 @@
 				(water-&gt;drawReflection) ? LUAMAT_OPAQUE_REFLECT : LUAMAT_OPAQUE;
 			lod = unit-&gt;CalcLOD(unit-&gt;luaMats[matType].GetLastLOD());
 		} else {
-			int tmpLod = (int)lua_tonumber(L, 3);
+			int tmpLod = lua_toint(L, 3);
 			if (tmpLod &lt; 0) {
 				useLOD = false;
 			} else {
@@ -1346,7 +1357,7 @@
 				(water-&gt;drawReflection) ? LUAMAT_OPAQUE_REFLECT : LUAMAT_OPAQUE;
 			lod = unit-&gt;CalcLOD(unit-&gt;luaMats[matType].GetLastLOD());
 		} else {
-			int tmpLod = (int)lua_tonumber(L, 3);
+			int tmpLod = lua_toint(L, 3);
 			if (tmpLod &lt; 0) {
 				useLOD = false;
 			} else {
@@ -1396,12 +1407,12 @@
 	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.UnitShape(unitDefID, team)&quot;);
 	}
-	const int unitDefID = (int)lua_tonumber(L, 1);
+	const int unitDefID = lua_toint(L, 1);
 	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 	if (ud == NULL) {
 		return 0;
 	}
-	const int teamID = (int)lua_tonumber(L, 2);
+	const int teamID = lua_toint(L, 2);
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
 		return 0;
 	}
@@ -1433,7 +1444,7 @@
 	}
 	const LocalS3DOModel* localModel = unit-&gt;localmodel;
 
-	const int piece = (int)luaL_checknumber(L, 2) - 1;
+	const int piece = luaL_checkint(L, 2) - 1;
 	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
 		return 0;
 	}
@@ -1455,7 +1466,7 @@
 	if (localModel == NULL) {
 		return 0;
 	}
-	const int piece = (int)luaL_checknumber(L, 2) - 1;
+	const int piece = luaL_checkint(L, 2) - 1;
 	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
 		return 0;
 	}
@@ -1480,7 +1491,7 @@
 	if (localModel == NULL) {
 		return 0;
 	}
-	const int piece = (int)luaL_checknumber(L, 2) - 1;
+	const int piece = luaL_checkint(L, 2) - 1;
 	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
 		return 0;
 	}
@@ -1501,7 +1512,7 @@
 	const CLuaHandle* lh = CLuaHandle::GetActiveHandle();
 	const int readAllyTeam = lh-&gt;GetReadAllyTeam();
 	if (readAllyTeam &lt; 0) {
-		return (readAllyTeam == CLuaHandle::AllAccessTeam);
+		return (readAllyTeam == CEventClient::AllAccessTeam);
 	}
 	if ((readAllyTeam != feature-&gt;allyteam) &amp;&amp;
 	    (!loshandler-&gt;InLos(feature-&gt;pos, readAllyTeam))) {
@@ -1517,7 +1528,7 @@
 	if ((args &lt; 1) || !lua_isnumber(L, index)) {
 		luaL_error(L, &quot;Incorrect arguments to %s(featureID)&quot;, caller);
 	}
-	const int featureID = (int)lua_tonumber(L, index);
+	const int featureID = lua_toint(L, index);
 	const CFeatureSet&amp; fset = featureHandler-&gt;GetActiveFeatures();
 	CFeatureSet::const_iterator it = fset.find(featureID);
 
@@ -1554,8 +1565,8 @@
 {
 	CheckDrawingEnabled(L, __FUNCTION__);
 
-	const int fDefID = (int)luaL_checknumber(L, 1);
-	const int teamID = (int)luaL_checknumber(L, 2);
+	const int fDefID = luaL_checkint(L, 1);
+	const int teamID = luaL_checkint(L, 2);
 
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
 		return 0;
@@ -1590,7 +1601,7 @@
 			return NULL;
 		}
 	}
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
 	}
@@ -1735,14 +1746,14 @@
 	    !lua_isnumber(L, 4) || !lua_isnumber(L, 5)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.DrawGroundCircle()&quot;);
 	}
-	const float3 pos((float)lua_tonumber(L, 1),
-	                 (float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3));
-	const float r  = (float)lua_tonumber(L, 4);
-	const int divs =   (int)lua_tonumber(L, 5);
+	const float3 pos(lua_tofloat(L, 1),
+	                 lua_tofloat(L, 2),
+	                 lua_tofloat(L, 3));
+	const float r  = lua_tofloat(L, 4);
+	const int divs =   lua_toint(L, 5);
 
 	if ((args &gt;= 6) &amp;&amp; lua_isnumber(L, 6)) {
-		// const float slope = (float) lua_tonumber(L, 6);
+		// const float slope = lua_tofloat(L, 6);
 		glBallisticCircle(pos, r, NULL, divs);
 	} else {
 		glSurfaceCircle(pos, r, divs);
@@ -1876,7 +1887,7 @@
 	for (int i = 0; i &lt; size; i++) {
 		lua_rawgeti(L, table, (i + 1));
 		if (lua_isnumber(L, -1)) {
-			array[i] = (float)lua_tonumber(L, -1);
+			array[i] = lua_tofloat(L, -1);
 			lua_pop(L, 1);
 		} else {
 			lua_pop(L, 1);
@@ -2029,24 +2040,24 @@
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.Vertex()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, -1);
+		const float x = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 2);
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.Vertex()&quot;);
 		}
-		const float y = (float)lua_tonumber(L, -1);
+		const float y = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 3);
 		if (!lua_isnumber(L, -1)) {
 			glVertex2f(x, y);
 			return 0;
 		}
-		const float z = (float)lua_tonumber(L, -1);
+		const float z = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 4);
 		if (!lua_isnumber(L, -1)) {
 			glVertex3f(x, y, z);
 			return 0;
 		}
-		const float w = (float)lua_tonumber(L, -1);
+		const float w = lua_tofloat(L, -1);
 		glVertex4f(x, y, z, w);
 		return 0;
 	}
@@ -2055,17 +2066,17 @@
 		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
 			luaL_error(L, &quot;Bad data passed to gl.Vertex()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 1);
-		const float y = (float)lua_tonumber(L, 2);
-		const float z = (float)lua_tonumber(L, 3);
+		const float x = lua_tofloat(L, 1);
+		const float y = lua_tofloat(L, 2);
+		const float z = lua_tofloat(L, 3);
 		glVertex3f(x, y, z);
 	}
 	else if (args == 2) {
 		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
 			luaL_error(L, &quot;Bad data passed to gl.Vertex()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 1);
-		const float y = (float)lua_tonumber(L, 2);
+		const float x = lua_tofloat(L, 1);
+		const float y = lua_tofloat(L, 2);
 		glVertex2f(x, y);
 	}
 	else if (args == 4) {
@@ -2073,10 +2084,10 @@
 		    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
 			luaL_error(L, &quot;Bad data passed to gl.Vertex()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 1);
-		const float y = (float)lua_tonumber(L, 2);
-		const float z = (float)lua_tonumber(L, 3);
-		const float w = (float)lua_tonumber(L, 4);
+		const float x = lua_tofloat(L, 1);
+		const float y = lua_tofloat(L, 2);
+		const float z = lua_tofloat(L, 3);
+		const float w = lua_tofloat(L, 4);
 		glVertex4f(x, y, z, w);
 	}
 	else {
@@ -2101,17 +2112,17 @@
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.Normal()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, -1);
+		const float x = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 2);
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.Normal()&quot;);
 		}
-		const float y = (float)lua_tonumber(L, -1);
+		const float y = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 3);
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.Normal()&quot;);
 		}
-		const float z = (float)lua_tonumber(L, -1);
+		const float z = lua_tofloat(L, -1);
 		glNormal3f(x, y, z);
 		return 0;
 	}
@@ -2119,9 +2130,9 @@
 	if (args &lt; 3) {
 		luaL_error(L, &quot;Incorrect arguments to gl.Normal()&quot;);
 	}
-	const float x = (float)lua_tonumber(L, 1);
-	const float y = (float)lua_tonumber(L, 2);
-	const float z = (float)lua_tonumber(L, 3);
+	const float x = lua_tofloat(L, 1);
+	const float y = lua_tofloat(L, 2);
+	const float z = lua_tofloat(L, 3);
 	glNormal3f(x, y, z);
 	return 0;
 }
@@ -2135,7 +2146,7 @@
 
 	if (args == 1) {
 		if (lua_isnumber(L, 1)) {
-			const float x = (float)lua_tonumber(L, 1);
+			const float x = lua_tofloat(L, 1);
 			glTexCoord1f(x);
 			return 0;
 		}
@@ -2146,25 +2157,25 @@
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad 2data passed to gl.TexCoord()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, -1);
+		const float x = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 2);
 		if (!lua_isnumber(L, -1)) {
 			glTexCoord1f(x);
 			return 0;
 		}
-		const float y = (float)lua_tonumber(L, -1);
+		const float y = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 3);
 		if (!lua_isnumber(L, -1)) {
 			glTexCoord2f(x, y);
 			return 0;
 		}
-		const float z = (float)lua_tonumber(L, -1);
+		const float z = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 4);
 		if (!lua_isnumber(L, -1)) {
 			glTexCoord3f(x, y, z);
 			return 0;
 		}
-		const float w = (float)lua_tonumber(L, -1);
+		const float w = lua_tofloat(L, -1);
 		glTexCoord4f(x, y, z, w);
 		return 0;
 	}
@@ -2173,17 +2184,17 @@
 		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
 			luaL_error(L, &quot;Bad data passed to gl.TexCoord()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 1);
-		const float y = (float)lua_tonumber(L, 2);
+		const float x = lua_tofloat(L, 1);
+		const float y = lua_tofloat(L, 2);
 		glTexCoord2f(x, y);
 	}
 	else if (args == 3) {
 		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
 			luaL_error(L, &quot;Bad data passed to gl.TexCoord()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 1);
-		const float y = (float)lua_tonumber(L, 2);
-		const float z = (float)lua_tonumber(L, 3);
+		const float x = lua_tofloat(L, 1);
+		const float y = lua_tofloat(L, 2);
+		const float z = lua_tofloat(L, 3);
 		glTexCoord3f(x, y, z);
 	}
 	else if (args == 4) {
@@ -2191,10 +2202,10 @@
 		    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
 			luaL_error(L, &quot;Bad data passed to gl.TexCoord()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 1);
-		const float y = (float)lua_tonumber(L, 2);
-		const float z = (float)lua_tonumber(L, 3);
-		const float w = (float)lua_tonumber(L, 4);
+		const float x = lua_tofloat(L, 1);
+		const float y = lua_tofloat(L, 2);
+		const float z = lua_tofloat(L, 3);
+		const float w = lua_tofloat(L, 4);
 		glTexCoord4f(x, y, z, w);
 	}
 	else {
@@ -2208,7 +2219,7 @@
 {
 	CheckDrawingEnabled(L, __FUNCTION__);
 
-	const int texNum = (int)luaL_checknumber(L, 1);
+	const int texNum = luaL_checkint(L, 1);
 	if ((texNum &lt; 0) || (texNum &gt;= MAX_TEXTURE_UNITS)) {
 		luaL_error(L, &quot;Bad texture unit passed to gl.MultiTexCoord()&quot;);
 	}
@@ -2218,7 +2229,7 @@
 
 	if (args == 1) {
 		if (lua_isnumber(L, 2)) {
-			const float x = (float)lua_tonumber(L, 2);
+			const float x = lua_tofloat(L, 2);
 			glMultiTexCoord1f(texUnit, x);
 			return 0;
 		}
@@ -2229,25 +2240,25 @@
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.MultiTexCoord()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, -1);
+		const float x = lua_tofloat(L, -1);
 		lua_rawgeti(L, 2, 2);
 		if (!lua_isnumber(L, -1)) {
 			glMultiTexCoord1f(texUnit, x);
 			return 0;
 		}
-		const float y = (float)lua_tonumber(L, -1);
+		const float y = lua_tofloat(L, -1);
 		lua_rawgeti(L, 2, 3);
 		if (!lua_isnumber(L, -1)) {
 			glMultiTexCoord2f(texUnit, x, y);
 			return 0;
 		}
-		const float z = (float)lua_tonumber(L, -1);
+		const float z = lua_tofloat(L, -1);
 		lua_rawgeti(L, 2, 4);
 		if (!lua_isnumber(L, -1)) {
 			glMultiTexCoord3f(texUnit, x, y, z);
 			return 0;
 		}
-		const float w = (float)lua_tonumber(L, -1);
+		const float w = lua_tofloat(L, -1);
 		glMultiTexCoord4f(texUnit, x, y, z, w);
 		return 0;
 	}
@@ -2256,17 +2267,17 @@
 		if (!lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
 			luaL_error(L, &quot;Bad data passed to gl.MultiTexCoord()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 2);
-		const float y = (float)lua_tonumber(L, 3);
+		const float x = lua_tofloat(L, 2);
+		const float y = lua_tofloat(L, 3);
 		glMultiTexCoord2f(texUnit, x, y);
 	}
 	else if (args == 3) {
 		if (!lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
 			luaL_error(L, &quot;Bad data passed to gl.MultiTexCoord()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 2);
-		const float y = (float)lua_tonumber(L, 3);
-		const float z = (float)lua_tonumber(L, 4);
+		const float x = lua_tofloat(L, 2);
+		const float y = lua_tofloat(L, 3);
+		const float z = lua_tofloat(L, 4);
 		glMultiTexCoord3f(texUnit, x, y, z);
 	}
 	else if (args == 4) {
@@ -2274,10 +2285,10 @@
 		    !lua_isnumber(L, 4) || !lua_isnumber(L, 5)) {
 			luaL_error(L, &quot;Bad data passed to gl.MultiTexCoord()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, 2);
-		const float y = (float)lua_tonumber(L, 3);
-		const float z = (float)lua_tonumber(L, 4);
-		const float w = (float)lua_tonumber(L, 5);
+		const float x = lua_tofloat(L, 2);
+		const float y = lua_tofloat(L, 3);
+		const float z = lua_tofloat(L, 4);
+		const float w = lua_tofloat(L, 5);
 		glMultiTexCoord4f(texUnit, x, y, z, w);
 	}
 	else {
@@ -2301,17 +2312,17 @@
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.SecondaryColor()&quot;);
 		}
-		const float x = (float)lua_tonumber(L, -1);
+		const float x = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 2);
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.SecondaryColor()&quot;);
 		}
-		const float y = (float)lua_tonumber(L, -1);
+		const float y = lua_tofloat(L, -1);
 		lua_rawgeti(L, 1, 3);
 		if (!lua_isnumber(L, -1)) {
 			luaL_error(L, &quot;Bad data passed to gl.SecondaryColor()&quot;);
 		}
-		const float z = (float)lua_tonumber(L, -1);
+		const float z = lua_tofloat(L, -1);
 		glSecondaryColor3f(x, y, z);
 		return 0;
 	}
@@ -2319,9 +2330,9 @@
 	if (args &lt; 3) {
 		luaL_error(L, &quot;Incorrect arguments to gl.SecondaryColor()&quot;);
 	}
-	const float x = (float)lua_tonumber(L, 1);
-	const float y = (float)lua_tonumber(L, 2);
-	const float z = (float)lua_tonumber(L, 3);
+	const float x = lua_tofloat(L, 1);
+	const float y = lua_tofloat(L, 2);
+	const float z = lua_tofloat(L, 3);
 	glSecondaryColor3f(x, y, z);
 	return 0;
 }
@@ -2331,7 +2342,7 @@
 {
 	CheckDrawingEnabled(L, __FUNCTION__);
 
-	const float value = (float)luaL_checknumber(L, 1);
+	const float value = luaL_checkfloat(L, 1);
 	glFogCoordf(value);
 	return 0;
 }
@@ -2360,10 +2371,10 @@
 	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.Rect()&quot;);
 	}
-	const float x1 = (float)lua_tonumber(L, 1);
-	const float y1 = (float)lua_tonumber(L, 2);
-	const float x2 = (float)lua_tonumber(L, 3);
-	const float y2 = (float)lua_tonumber(L, 4);
+	const float x1 = lua_tofloat(L, 1);
+	const float y1 = lua_tofloat(L, 2);
+	const float x2 = lua_tofloat(L, 3);
+	const float y2 = lua_tofloat(L, 4);
 
 	glRectf(x1, y1, x2, y2);
 	return 0;
@@ -2380,10 +2391,10 @@
 	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.TexRect()&quot;);
 	}
-	const float x1 = (float)lua_tonumber(L, 1);
-	const float y1 = (float)lua_tonumber(L, 2);
-	const float x2 = (float)lua_tonumber(L, 3);
-	const float y2 = (float)lua_tonumber(L, 4);
+	const float x1 = lua_tofloat(L, 1);
+	const float y1 = lua_tofloat(L, 2);
+	const float x2 = lua_tofloat(L, 3);
+	const float y2 = lua_tofloat(L, 4);
 
 	// Spring's textures get loaded with a vertical flip
 	// We change that for the default settings.
@@ -2418,10 +2429,10 @@
 	    !lua_isnumber(L, 7) || !lua_isnumber(L, 8)) {
 		luaL_error(L, &quot;Incorrect texcoord arguments to gl.TexRect()&quot;);
 	}
-	const float s1 = (float)lua_tonumber(L, 5);
-	const float t1 = (float)lua_tonumber(L, 6);
-	const float s2 = (float)lua_tonumber(L, 7);
-	const float t2 = (float)lua_tonumber(L, 8);
+	const float s1 = lua_tofloat(L, 5);
+	const float t1 = lua_tofloat(L, 6);
+	const float s2 = lua_tofloat(L, 7);
+	const float t2 = lua_tofloat(L, 8);
 	glBegin(GL_QUADS); {
 		glTexCoord2f(s1, t1); glVertex2f(x1, y1);
 		glTexCoord2f(s2, t1); glVertex2f(x2, y1);
@@ -2649,6 +2660,21 @@
 }
 
 
+int LuaOpenGL::Viewport(lua_State* L)
+{
+	CheckDrawingEnabled(L, __FUNCTION__);
+
+	const int x = luaL_checkint(L, 1);
+	const int y = luaL_checkint(L, 1);
+	const int w = luaL_checkint(L, 1);
+	const int h = luaL_checkint(L, 1);
+
+	glViewport(x, y, w, h);
+
+	return 0;
+}
+
+
 int LuaOpenGL::ColorMask(lua_State* L)
 {
 	CheckDrawingEnabled(L, __FUNCTION__);
@@ -3140,7 +3166,7 @@
 		GLint factor     =    (GLint)lua_tonumber(L, 1);
 		GLushort pattern = (GLushort)lua_tonumber(L, 2);
 		if ((args &gt;= 3) &amp;&amp; lua_isnumber(L, 3)) {
-			int shift = (int)lua_tonumber(L, 3);
+			int shift = lua_toint(L, 3);
 			while (shift &lt; 0) { shift += 16; }
 			shift = (shift % 16);
 			unsigned int pat = pattern &amp; 0xFFFF;
@@ -3163,7 +3189,7 @@
 	if ((args != 1) || !lua_isnumber(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.LineWidth()&quot;);
 	}
-	glLineWidth((float)lua_tonumber(L, 1));
+	glLineWidth(lua_tofloat(L, 1));
 	return 0;
 }
 
@@ -3174,7 +3200,7 @@
 	if ((args != 1) || !lua_isnumber(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.PointSize()&quot;);
 	}
-	glPointSize((float)lua_tonumber(L, 1));
+	glPointSize(lua_tofloat(L, 1));
 	return 0;
 }
 
@@ -3218,15 +3244,15 @@
 
 	const int args = lua_gettop(L);
 	if (args &gt;= 4) {
-		const float sizeMin = (float)luaL_checknumber(L, 4);
+		const float sizeMin = luaL_checkfloat(L, 4);
 		glPointParameterf(GL_POINT_SIZE_MIN, sizeMin);
 	}
 	if (args &gt;= 5) {
-		const float sizeMax = (float)luaL_checknumber(L, 5);
+		const float sizeMax = luaL_checkfloat(L, 5);
 		glPointParameterf(GL_POINT_SIZE_MAX, sizeMax);
 	}
 	if (args &gt;= 6) {
-		const float sizeFade = (float)luaL_checknumber(L, 6);
+		const float sizeFade = luaL_checkfloat(L, 6);
 		glPointParameterf(GL_POINT_FADE_THRESHOLD_SIZE, sizeFade);
 	}
 
@@ -3351,7 +3377,7 @@
 		} else {
 			const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 			if (ud != NULL) {
-				glBindTexture(GL_TEXTURE_2D, unitDefHandler-&gt;GetUnitImage(ud));
+				glBindTexture(GL_TEXTURE_2D, unitDefHandler-&gt;GetUnitDefImage(ud));
 				glEnable(GL_TEXTURE_2D);
 				lua_pushboolean(L, true);
 			} else {
@@ -3359,7 +3385,25 @@
 			}
 		}
 	}
-	else if (texture[0] == LuaTextures::prefix) {
+	else if (texture[0] == '^') {
+		// unit icon
+		char* endPtr;
+		const char* startPtr = texture.c_str() + 1; // skip the '^'
+		const int unitDefID = (int)strtol(startPtr, &amp;endPtr, 10);
+		if (endPtr == startPtr) {
+			lua_pushboolean(L, false);
+		} else {
+			const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
+			if (ud != NULL) {
+				ud-&gt;iconType-&gt;BindTexture();
+				glEnable(GL_TEXTURE_2D);
+				lua_pushboolean(L, true);
+			} else {
+				lua_pushboolean(L, false);
+			}
+		}
+	}
+	else if (texture[0] == LuaTextures::prefix) { // '!'
 		// dynamic texture
 		LuaTextures&amp; textures = CLuaHandle::GetActiveTextures();
 		if (textures.Bind(texture)) {
@@ -3486,7 +3530,7 @@
 		luaL_error(L, &quot;Incorrect arguments to gl.DeleteTexture()&quot;);
 	}
 	const string texture = lua_tostring(L, 1);
-	if (texture[0] == LuaTextures::prefix) {
+	if (texture[0] == LuaTextures::prefix) { // '!'
 		LuaTextures&amp; textures = CLuaHandle::GetActiveTextures();
 		lua_pushboolean(L, textures.Free(texture));
 	} else {
@@ -3571,26 +3615,37 @@
 		char* endPtr;
 		const char* startPtr = texture.c_str() + 1; // skip the '#'
 		const int unitDefID = (int)strtol(startPtr, &amp;endPtr, 10);
-		// UnitDefHandler's array size is (numUnitDefs + 1)
 		if (endPtr == startPtr) {
 			return 0;
 		}
-		else {
-			const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
-			if (ud == NULL) {
-				return 0;
-			}
-			lua_newtable(L);
-			HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, ud-&gt;unitImage-&gt;imageSizeX);
-			HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, ud-&gt;unitImage-&gt;imageSizeY);
-			// HSTR_PUSH_BOOL(L,   &quot;alpha&quot;, texInfo-&gt;alpha);  FIXME
-			// HSTR_PUSH_NUMBER(L, &quot;type&quot;,  texInfo-&gt;type);
+		const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
+		if (ud == NULL) {
+			return 0;
 		}
+		lua_newtable(L);
+		unitDefHandler-&gt;GetUnitDefImage(ud); // forced existance
+		HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, ud-&gt;buildPic-&gt;imageSizeX);
+		HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, ud-&gt;buildPic-&gt;imageSizeY);
 	}
+	else if (texture[0] == '^') {
+		char* endPtr;
+		const char* startPtr = texture.c_str() + 1; // skip the '^'
+		const int unitDefID = (int)strtol(startPtr, &amp;endPtr, 10);
+		if (endPtr == startPtr) {
+			return 0;
+		}
+		const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
+		if (ud == NULL) {
+			return 0;
+		}
+		lua_newtable(L);
+		HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, ud-&gt;iconType-&gt;GetSizeX());
+		HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, ud-&gt;iconType-&gt;GetSizeY());
+	}
 	else if (texture[0] == '%') {
 		return PushUnitTextureInfo(L, texture);
 	}
-	else if (texture[0] == LuaTextures::prefix) {
+	else if (texture[0] == LuaTextures::prefix) { // '!'
 		LuaTextures&amp; textures = CLuaHandle::GetActiveTextures();
 		const LuaTextures::Texture* tex = textures.GetInfo(texture);
 		if (tex == NULL) {
@@ -3652,7 +3707,7 @@
 	CheckDrawingEnabled(L, __FUNCTION__);
 
 	const string texture = luaL_checkstring(L, 1);
-	if (texture[0] != LuaTextures::prefix) {
+	if (texture[0] != LuaTextures::prefix) { // '!'
 		luaL_error(L, &quot;gl.CopyToTexture() can only write to lua textures&quot;);
 	}
 	LuaTextures&amp; textures = CLuaHandle::GetActiveTextures();
@@ -3684,7 +3739,7 @@
 	CheckDrawingEnabled(L, __FUNCTION__);
 
 	const string texture = luaL_checkstring(L, 1);
-	if (texture[0] != LuaTextures::prefix) {
+	if (texture[0] != LuaTextures::prefix) { // '!'
 		luaL_error(L, &quot;gl.RenderToTexture() can only write to fbo textures&quot;);
 	}
 	if (!lua_isfunction(L, 2)) {
@@ -3730,7 +3785,7 @@
 {
 	//CheckDrawingEnabled(L, __FUNCTION__);
 	const string&amp; texStr = luaL_checkstring(L, 1);
-	if (texStr[0] != LuaTextures::prefix) {
+	if (texStr[0] != LuaTextures::prefix) { // '!'
 		return 0;
 	}
 	LuaTextures&amp; textures = CLuaHandle::GetActiveTextures();
@@ -3755,7 +3810,7 @@
 	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isfunction(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.ActiveTexture(number, func, ...)&quot;);
 	}
-	const int texNum = (int)lua_tonumber(L, 1);
+	const int texNum = lua_toint(L, 1);
 	if ((texNum &lt; 0) || (texNum &gt;= MAX_TEXTURE_UNITS)) {
 		luaL_error(L, &quot;Bad texture unit passed to gl.ActiveTexture()&quot;);
 		return 0;
@@ -3806,7 +3861,7 @@
 int LuaOpenGL::MultiTexEnv(lua_State* L)
 {
 	CheckDrawingEnabled(L, __FUNCTION__);
-	const int texNum    =    (int)luaL_checknumber(L, 1);
+	const int texNum    =    luaL_checkint(L, 1);
 	const GLenum target = (GLenum)luaL_checknumber(L, 2);
 	const GLenum pname  = (GLenum)luaL_checknumber(L, 3);
 
@@ -3893,7 +3948,7 @@
 {
 	CheckDrawingEnabled(L, __FUNCTION__);
 
-	const int texNum = (int)luaL_checknumber(L, 1);
+	const int texNum = luaL_checkint(L, 1);
 	if ((texNum &lt; 0) || (texNum &gt;= MAX_TEXTURE_UNITS)) {
 		luaL_error(L, &quot;Bad texture unit passed to gl.MultiTexGen()&quot;);
 	}
@@ -3992,9 +4047,9 @@
 	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.Translate(x, y, z)&quot;);
 	}
-	const float x = (float)lua_tonumber(L, 1);
-	const float y = (float)lua_tonumber(L, 2);
-	const float z = (float)lua_tonumber(L, 3);
+	const float x = lua_tofloat(L, 1);
+	const float y = lua_tofloat(L, 2);
+	const float z = lua_tofloat(L, 3);
 	glTranslatef(x, y, z);
 	return 0;
 }
@@ -4009,9 +4064,9 @@
 	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.Scale(x, y, z)&quot;);
 	}
-	const float x = (float)lua_tonumber(L, 1);
-	const float y = (float)lua_tonumber(L, 2);
-	const float z = (float)lua_tonumber(L, 3);
+	const float x = lua_tofloat(L, 1);
+	const float y = lua_tofloat(L, 2);
+	const float z = lua_tofloat(L, 3);
 	glScalef(x, y, z);
 	return 0;
 }
@@ -4027,10 +4082,10 @@
 	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.Rotate(r, x, y, z)&quot;);
 	}
-	const float r = (float)lua_tonumber(L, 1);
-	const float x = (float)lua_tonumber(L, 2);
-	const float y = (float)lua_tonumber(L, 3);
-	const float z = (float)lua_tonumber(L, 4);
+	const float r = lua_tofloat(L, 1);
+	const float x = lua_tofloat(L, 2);
+	const float y = lua_tofloat(L, 3);
+	const float z = lua_tofloat(L, 4);
 	glRotatef(r, x, y, z);
 	return 0;
 }
@@ -4132,7 +4187,7 @@
 	if ((args &lt; 2) || !lua_isnumber(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to gl.ClipPlane&quot;);
 	}
-	const int plane = (int)lua_tonumber(L, 1);
+	const int plane = lua_toint(L, 1);
 	if ((plane &lt; 1) || (plane &gt; 2)) {
 		luaL_error(L, &quot;gl.ClipPlane: bad plane number (use 1 or 2)&quot;);
 	}
@@ -4370,7 +4425,7 @@
 		glGetFloatv(pname, matrix);
 
 		if (lua_isnumber(L, 2)) {
-			const int index = (int)lua_tonumber(L, 2);
+			const int index = lua_toint(L, 2);
 			if ((index &lt; 0) || (index &gt;= 16)) {
 				return 0;
 			}
@@ -4662,6 +4717,57 @@
 }
 
 
+int LuaOpenGL::SaveImage(lua_State* L)
+{
+	const string filename = luaL_checkstring(L, 1);
+
+	const int x0 = luaL_checkint(L, 2) + gu-&gt;viewPosX;
+	const int y0 = luaL_checkint(L, 3) + gu-&gt;viewPosY;
+	const int x1 = luaL_checkint(L, 4) + gu-&gt;viewPosX;
+	const int y1 = luaL_checkint(L, 5) + gu-&gt;viewPosY;
+
+	bool alpha = false;
+	bool yflip = false;
+	const int table = 6;
+	if (lua_istable(L, table)) {
+		lua_getfield(L, table, &quot;alpha&quot;);
+		if (lua_isboolean(L, -1)) {
+			alpha = lua_toboolean(L, -1);
+		}
+		lua_pop(L, 1);
+		lua_getfield(L, table, &quot;yflip&quot;);
+		if (lua_isboolean(L, -1)) {
+			yflip = lua_toboolean(L, -1);
+		}
+		lua_pop(L, 1);
+	}
+
+	const int xsize = (x1 - x0) + 1;
+	const int ysize = (y1 - y0) + 1;
+	if ((xsize &lt;= 0) || (ysize &lt;= 0)) {
+		return 0;
+	}
+	const int memsize = xsize * ysize * 4;	
+
+	unsigned char* img = SAFE_NEW unsigned char[memsize];
+	memset(img, 0, memsize);
+	glReadPixels(x0, y0, xsize, ysize, GL_RGBA, GL_UNSIGNED_BYTE, img);
+
+	CBitmap bitmap(img, xsize, ysize);
+	if (!yflip) {
+		bitmap.ReverseYAxis();
+	}
+
+	// FIXME Check file path permission here
+
+	lua_pushboolean(L, bitmap.Save(filename, !alpha));
+
+	delete[] img;
+
+	return 1;
+}
+
+
 /******************************************************************************/
 
 int LuaOpenGL::CreateQuery(lua_State* L)

Modified: trunk/rts/Lua/LuaOpenGL.h
===================================================================
--- trunk/rts/Lua/LuaOpenGL.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaOpenGL.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -136,6 +136,7 @@
 		static int Lighting(lua_State* L);
 		static int ShadeModel(lua_State* L);
 		static int Scissor(lua_State* L);
+		static int Viewport(lua_State* L);
 		static int ColorMask(lua_State* L);
 		static int DepthMask(lua_State* L);
 		static int DepthTest(lua_State* L);
@@ -256,6 +257,7 @@
 		static int Finish(lua_State* L);
 
 		static int ReadPixels(lua_State* L);
+		static int SaveImage(lua_State* L);
 
 		static int CreateQuery(lua_State* L);
 		static int DeleteQuery(lua_State* L);

Modified: trunk/rts/Lua/LuaParser.cpp
===================================================================
--- trunk/rts/Lua/LuaParser.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaParser.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -12,6 +12,7 @@
 
 #include &quot;LuaInclude.h&quot;
 
+#include &quot;LuaIO.h&quot;
 #include &quot;LuaUtils.h&quot;
 
 #include &quot;Game/GameSetup.h&quot;
@@ -440,9 +441,7 @@
 	}
 
 	const string dir = luaL_checkstring(L, 1);
-	// keep searches within the Spring directory
-	if ((dir[0] == '/') || (dir[0] == '\\') ||
-	    ((dir.size() &gt;= 2) &amp;&amp; (dir[1] == ':'))) {
+	if (!LuaIO::IsSimplePath(dir)) {
 		return 0;
 	}
 	const string pat = luaL_optstring(L, 2, &quot;*&quot;);
@@ -478,6 +477,9 @@
 
 	// filename [, fenv]
 	const string filename = luaL_checkstring(L, 1);
+	if (!LuaIO::IsSimplePath(filename)) {
+		luaL_error(L, &quot;bad pathname&quot;);
+	}
 	string modes = luaL_optstring(L, 3, currentParser-&gt;accessModes.c_str());
 	modes = CFileHandler::AllowModes(modes, currentParser-&gt;accessModes);
 
@@ -547,6 +549,9 @@
 	}
 
 	const string filename = luaL_checkstring(L, 1);
+	if (!LuaIO::IsSimplePath(filename)) {
+		return 0;
+	}
 	string modes = luaL_optstring(L, 2, currentParser-&gt;accessModes.c_str());
 	modes = CFileHandler::AllowModes(modes, currentParser-&gt;accessModes);
 
@@ -576,6 +581,9 @@
 		luaL_error(L, &quot;invalid call to FileExists() after execution&quot;);
 	}
 	const string filename = luaL_checkstring(L, 1);
+	if (!LuaIO::IsSimplePath(filename)) {
+		return 0;
+	}
 	CFileHandler fh(filename, currentParser-&gt;accessModes);
 	lua_pushboolean(L, fh.FileExists());
 	return 1;
@@ -934,7 +942,7 @@
 	const int table = lua_gettop(L);
 	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
 		if (lua_israwnumber(L, -2)) {
-			const int value = (int)lua_tonumber(L, -2);
+			const int value = lua_toint(L, -2);
 			data.push_back(value);
 		}
 	}
@@ -974,8 +982,8 @@
 	const int table = lua_gettop(L);
 	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
 		if (lua_israwnumber(L, -2) &amp;&amp; lua_isnumber(L, -1)) {
-			const int   key   =   (int)lua_tonumber(L, -2);
-			const float value = (float)lua_tonumber(L, -1);
+			const int   key   =   lua_toint(L, -2);
+			const float value = lua_tofloat(L, -1);
 			data[key] = value;
 		}
 	}
@@ -991,7 +999,7 @@
 	const int table = lua_gettop(L);
 	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
 		if (lua_israwnumber(L, -2) &amp;&amp; lua_isstring(L, -1)) {
-			const int    key   = (int)lua_tonumber(L, -2);
+			const int    key   = lua_toint(L, -2);
 			const string value = lua_tostring(L, -1);
 			data[key] = value;
 		}
@@ -1009,7 +1017,7 @@
 	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
 		if (lua_israwstring(L, -2) &amp;&amp; lua_isnumber(L, -1)) {
 			const string key   = lua_tostring(L, -2);
-			const float  value = (float)lua_tonumber(L, -1);
+			const float  value = lua_tofloat(L, -1);
 			data[key] = value;
 		}
 	}
@@ -1049,7 +1057,7 @@
 		lua_pop(L, 1);
 		return false;
 	}
-	value = (float)lua_tonumber(L, -1);
+	value = lua_tofloat(L, -1);
 	lua_pop(L, 1);
 	return true;
 }
@@ -1083,7 +1091,7 @@
 		return true;
 	}
 	else if (lua_isnumber(L, index)) {
-		value = ((float)lua_tonumber(L, index) != 0.0f);
+		value = (lua_tofloat(L, index) != 0.0f);
 		return true;
 	}
 	else if (lua_isstring(L, index)) {
@@ -1116,7 +1124,7 @@
 		lua_pop(L, 1);
 		return def;
 	}
-	const int value = (int)lua_tonumber(L, -1);
+	const int value = lua_toint(L, -1);
 	lua_pop(L, 1);
 	return value;
 }
@@ -1146,7 +1154,7 @@
 		lua_pop(L, 1);
 		return def;
 	}
-	const float value = (float)lua_tonumber(L, -1);
+	const float value = lua_tofloat(L, -1);
 	lua_pop(L, 1);
 	return value;
 }
@@ -1197,7 +1205,7 @@
 		lua_pop(L, 1);
 		return def;
 	}
-	const int value = (int)lua_tonumber(L, -1);
+	const int value = lua_toint(L, -1);
 	lua_pop(L, 1);
 	return value;
 }
@@ -1227,7 +1235,7 @@
 		lua_pop(L, 1);
 		return def;
 	}
-	const float value = (float)lua_tonumber(L, -1);
+	const float value = lua_tofloat(L, -1);
 	lua_pop(L, 1);
 	return value;
 }

Modified: trunk/rts/Lua/LuaPathFinder.cpp
===================================================================
--- trunk/rts/Lua/LuaPathFinder.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaPathFinder.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -53,12 +53,12 @@
 
 	float3 callerPos = ZeroVector;
 	if (args &gt;= 4) {
-		callerPos.x = (float)luaL_checknumber(L, 2);
-		callerPos.y = (float)luaL_checknumber(L, 3);
-		callerPos.z = (float)luaL_checknumber(L, 4);
+		callerPos.x = luaL_checkfloat(L, 2);
+		callerPos.y = luaL_checkfloat(L, 3);
+		callerPos.z = luaL_checkfloat(L, 4);
 	}
 
-	const float minDist = (float)luaL_optnumber(L, 5, 0.0f);
+	const float minDist = luaL_optfloat(L, 5, 0.0f);
 
 	const float3 point = pathManager-&gt;NextWaypoint(pathID, callerPos, minDist);
 
@@ -176,7 +176,7 @@
 		moveData = moveinfo-&gt;GetMoveDataFromName(moveName, true);
 	}
 	else {
-		const int moveID = (int)luaL_checknumber(L, 1);
+		const int moveID = luaL_checkint(L, 1);
 		if ((moveID &lt; 0) || (moveID &gt;= moveinfo-&gt;moveData.size())) {
 			luaL_error(L, &quot;Invalid moveID passed to RequestPath&quot;);
 		}
@@ -187,15 +187,15 @@
 		return 0;
 	}
 
-	const float3 start((float)luaL_checknumber(L, 2),
-	                   (float)luaL_checknumber(L, 3),
-	                   (float)luaL_checknumber(L, 4));
+	const float3 start(luaL_checkfloat(L, 2),
+	                   luaL_checkfloat(L, 3),
+	                   luaL_checkfloat(L, 4));
 
-	const float3   end((float)luaL_checknumber(L, 5),
-	                   (float)luaL_checknumber(L, 6),
-	                   (float)luaL_checknumber(L, 7));
+	const float3   end(luaL_checkfloat(L, 5),
+	                   luaL_checkfloat(L, 6),
+	                   luaL_checkfloat(L, 7));
 
-	const float radius = (float)luaL_optnumber(L, 8, 8.0f);
+	const float radius = luaL_optfloat(L, 8, 8.0f);
 
 	const int pathID =
 		pathManager-&gt;RequestPath(moveData, start, end, radius, NULL);

Modified: trunk/rts/Lua/LuaRules.cpp
===================================================================
--- trunk/rts/Lua/LuaRules.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaRules.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -312,10 +312,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -374,10 +372,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -416,10 +412,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -455,10 +449,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -495,10 +487,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
-	if ((args != 1) || !lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -535,10 +525,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
-	if ((args != 1) || !lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -575,10 +563,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
-	if ((args != 1) || !lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -612,10 +598,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -651,10 +635,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
-	if ((args != 1) || !lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -689,10 +671,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
-	if ((args != 1) || !lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -728,10 +708,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return true;
 	}
@@ -766,10 +744,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return false;
 	}
@@ -810,10 +786,8 @@
 	}
 
 	// get the results
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return false;
 	}
@@ -855,10 +829,8 @@
 		return false;
 	}
 
-	const int args = lua_gettop(L);
 	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
+		logOutput.Print(&quot;%s() bad return value\n&quot;, cmdStr.GetString().c_str());
 		lua_pop(L, 1);
 		return false;
 	}
@@ -920,7 +892,7 @@
 	if (currentCobArgs == NULL) {
 		luaL_error(L, &quot;Error in UnpackCobArg(), no current args&quot;);
 	}
-	const int arg = (int)luaL_checknumber(L, 1) - 1;
+	const int arg = luaL_checkint(L, 1) - 1;
 	if ((arg &lt; 0) || (arg &gt;= MAX_LUA_COB_ARGS)) {
 		luaL_error(L, &quot;Error in UnpackCobArg(), bad index&quot;);
 	}
@@ -991,7 +963,7 @@
 	for (int a = 1; a &lt;= retArgs; a++) {
 		const int index = (a + top);
 		if (lua_isnumber(L, index)) {
-			args[a] = (int)lua_tonumber(L, index);
+			args[a] = lua_toint(L, index);
 		}
 		else if (lua_isboolean(L, index)) {
 			args[a] = lua_toboolean(L, index) ? 1 : 0;
@@ -1000,8 +972,8 @@
 			lua_rawgeti(L, index, 1);
 			lua_rawgeti(L, index, 2);
 			if (lua_isnumber(L, -2) &amp;&amp; lua_isnumber(L, -1)) {
-				const int x = (int)lua_tonumber(L, -2);
-				const int z = (int)lua_tonumber(L, -1);
+				const int x = lua_toint(L, -2);
+				const int z = lua_toint(L, -1);
 				args[a] = PACKXZ(x, z);
 			} else {
 				args[a] = 0;
@@ -1054,8 +1026,7 @@
 int CLuaRules::SetRulesInfoMap(lua_State* L)
 {
 	assert(luaRules != NULL);
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_istable(L, 1)) {
+	if (!lua_istable(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to SetRulesInfoMap(teamID)&quot;);
 	}
 	map&lt;string, string&gt;&amp; infoMap = luaRules-&gt;infoMap;
@@ -1084,7 +1055,7 @@
 	int pIndex = -1;
 
 	if (lua_israwnumber(L, index)) {
-		pIndex = (int)lua_tonumber(L, index) - 1;
+		pIndex = lua_toint(L, index) - 1;
 	}
 	else if (lua_israwstring(L, index)) {
 		const string pName = lua_tostring(L, index);
@@ -1110,7 +1081,7 @@
 	if (!lua_isnumber(L, valIndex)) {
 		luaL_error(L, &quot;Incorrect arguments to %s()&quot;, caller);
 	}
-	params[pIndex] = (float)lua_tonumber(L, valIndex);
+	params[pIndex] = lua_tofloat(L, valIndex);
 	return;
 }
 
@@ -1134,7 +1105,7 @@
 			return;
 		}
 		else if (lua_israwnumber(L, -1)) {
-			const float value = (float)lua_tonumber(L, -1);
+			const float value = lua_tofloat(L, -1);
 			params.push_back(value);
 		}
 		else if (lua_istable(L, -1)) {
@@ -1181,7 +1152,7 @@
 	if (!lua_isnumber(L, index)) {
 		luaL_error(L, &quot;%s(): Bad teamID type\n&quot;, caller);
 	}
-	const int teamID = (int)lua_tonumber(L, index);
+	const int teamID = lua_toint(L, index);
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
 		luaL_error(L, &quot;%s(): Bad teamID: %i\n&quot;, teamID);
 	}
@@ -1230,7 +1201,7 @@
 	if (!lua_isnumber(L, luaIndex)) {
 		luaL_error(L, &quot;%s(): Bad unitID&quot;, caller);
 	}
-	const int unitID = (int)lua_tonumber(L, luaIndex);
+	const int unitID = lua_toint(L, luaIndex);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
 	}

Modified: trunk/rts/Lua/LuaShaders.cpp
===================================================================
--- trunk/rts/Lua/LuaShaders.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaShaders.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -46,6 +46,8 @@
 	REGISTER_LUA_CFUNC(UniformInt);
 	REGISTER_LUA_CFUNC(UniformMatrix);
 
+	REGISTER_LUA_CFUNC(SetShaderParameter);
+
 	REGISTER_LUA_CFUNC(GetShaderLog);
 
 	return true;
@@ -98,7 +100,7 @@
 
 GLuint LuaShaders::GetProgramName(lua_State* L, int index) const
 {
-	const int progID = (GLuint)luaL_checknumber(L, 1);
+	const int progID = (GLuint)luaL_checkint(L, 1);
 	if ((progID &lt;= 0) || (progID &gt;= (int)programs.size())) {
 		return 0;
 	}
@@ -172,7 +174,7 @@
 	for (int i = 0; i &lt; size; i++) {
 		lua_rawgeti(L, table, (i + 1));
 		if (lua_isnumber(L, -1)) {
-			array[i] = (int)lua_tonumber(L, -1);
+			array[i] = lua_toint(L, -1);
 			lua_pop(L, 1);
 		} else {
 			lua_pop(L, 1);
@@ -192,7 +194,7 @@
 	for (int i = 0; i &lt; size; i++) {
 		lua_rawgeti(L, table, (i + 1));
 		if (lua_isnumber(L, -1)) {
-			array[i] = (float)lua_tonumber(L, -1);
+			array[i] = lua_tofloat(L, -1);
 			lua_pop(L, 1);
 		} else {
 			lua_pop(L, 1);
@@ -205,8 +207,7 @@
 
 static bool ParseUniformTable(lua_State* L, int index, GLuint progName)
 {
-	lua_pushstring(L, &quot;uniform&quot;);
-	lua_gettable(L, index);
+	lua_getfield(L, index, &quot;uniform&quot;);
 	if (lua_istable(L, -1)) {
 		const int table = lua_gettop(L);
 		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
@@ -215,7 +216,7 @@
 				const GLint loc = glGetUniformLocation(progName, name.c_str());
 				if (loc &gt;= 0) {
 					if (lua_israwnumber(L, -1)) {
-						const float value = (float)lua_tonumber(L, -1);
+						const float value = lua_tofloat(L, -1);
 						glUniform1f(loc, value);
 					}
 					else if (lua_istable(L, -1)) {
@@ -239,8 +240,7 @@
 
 static bool ParseUniformIntTable(lua_State* L, int index, GLuint progName)
 {
-	lua_pushstring(L, &quot;uniformInt&quot;);
-	lua_gettable(L, index);
+	lua_getfield(L, index, &quot;uniformInt&quot;);
 	if (lua_istable(L, -1)) {
 		const int table = lua_gettop(L);
 		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
@@ -249,7 +249,7 @@
 				const GLint loc = glGetUniformLocation(progName, name.c_str());
 				if (loc &gt;= 0) {
 					if (lua_israwnumber(L, -1)) {
-						const int value = (int)lua_tonumber(L, -1);
+						const int value = lua_toint(L, -1);
 						glUniform1i(loc, value);
 					}
 					else if (lua_istable(L, -1)) {
@@ -273,8 +273,7 @@
 
 static bool ParseUniformMatrixTable(lua_State* L, int index, GLuint progName)
 {
-	lua_pushstring(L, &quot;uniformMatrix&quot;);
-	lua_gettable(L, index);
+	lua_getfield(L, index, &quot;uniformMatrix&quot;);
 	if (lua_istable(L, -1)) {
 		const int table = lua_gettop(L);
 		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
@@ -329,6 +328,11 @@
 	}
 
 	GLuint obj = glCreateShader(type);
+	if (obj == 0) {
+		LuaShaders&amp; shaders = CLuaHandle::GetActiveShaders();
+		shaders.errorLog = &quot;Could not create shader object&quot;;
+		return 0;
+	}
 
 	const int count = (int)sources.size();
 	
@@ -352,6 +356,11 @@
 		
 		LuaShaders&amp; shaders = CLuaHandle::GetActiveShaders();
 		shaders.errorLog = log;
+		if (shaders.errorLog.empty()) {
+			shaders.errorLog = &quot;Empty error message:  code = &quot;
+			                   + IntToString(result) + &quot; (0x&quot;
+			                   + IntToString(result, &quot;%04X&quot;) + &quot;)&quot;;
+		}
 		
 		glDeleteShader(obj);
 
@@ -367,14 +376,9 @@
 static bool ParseSources(lua_State* L, int table,
                          const char* type, vector&lt;string&gt;&amp; srcs)
 {
-	if (!lua_istable(L, 1)) {
-		return false;
-	}
-
-	lua_pushstring(L, type);
-	lua_gettable(L, table);
+	lua_getfield(L, table, type);
 	
-	if (lua_isstring(L, -1)) {
+	if (lua_israwstring(L, -1)) {
 		const string src = lua_tostring(L, -1);
 		if (!src.empty()) {
 			srcs.push_back(src);
@@ -393,6 +397,8 @@
 		}
 	}
 	else if (!lua_isnil(L, -1)) {
+		LuaShaders&amp; shaders = CLuaHandle::GetActiveShaders();
+		shaders.errorLog = &quot;Invalid &quot; + string(type) + &quot; shader source&quot;;
 		lua_pop(L, 1);
 		return false;
 	}
@@ -402,6 +408,32 @@
 }
 
 
+static bool ApplyGeometryParameters(lua_State* L, int table, GLuint prog)
+{
+	if (!glProgramParameteriEXT) {
+		return true;
+	}
+
+	struct { const char* name; GLenum param; } parameters[] = {
+		{ &quot;geoInputType&quot;,   GL_GEOMETRY_INPUT_TYPE_EXT },
+		{ &quot;geoOutputType&quot;,  GL_GEOMETRY_OUTPUT_TYPE_EXT },
+		{ &quot;geoOutputVerts&quot;, GL_GEOMETRY_VERTICES_OUT_EXT }
+	};
+
+	const int count = sizeof(parameters) / sizeof(parameters[0]);
+	for (int i = 0; i &lt; count; i++) {
+		lua_getfield(L, table, parameters[i].name);
+		if (lua_israwnumber(L, -1)) {
+			const GLint type = lua_toint(L, -1);
+			glProgramParameteriEXT(prog, parameters[i].param, type);
+		}
+		lua_pop(L, 1);
+	}
+
+	return true;
+}
+
+
 int LuaShaders::CreateShader(lua_State* L)
 {
 	const int args = lua_gettop(L);
@@ -410,12 +442,14 @@
 	}
 
 	vector&lt;string&gt; vertSrcs;
+	vector&lt;string&gt; geomSrcs;
 	vector&lt;string&gt; fragSrcs;
 	if (!ParseSources(L, 1, &quot;vertex&quot;,   vertSrcs) ||
+	    !ParseSources(L, 1, &quot;geometry&quot;, geomSrcs) ||
 	    !ParseSources(L, 1, &quot;fragment&quot;, fragSrcs)) {
 		return 0;
 	}
-	if (vertSrcs.empty() &amp;&amp; fragSrcs.empty()) {
+	if (vertSrcs.empty() &amp;&amp; fragSrcs.empty() &amp;&amp; geomSrcs.empty()) {
 		return 0;
 	}
 
@@ -424,9 +458,15 @@
 	if (!success) {
 		return 0;
 	}
+	const GLuint geomObj = CompileObject(geomSrcs, GL_GEOMETRY_SHADER_EXT, success);
+	if (!success) {
+		glDeleteShader(vertObj);
+		return 0;
+	}
 	const GLuint fragObj = CompileObject(fragSrcs, GL_FRAGMENT_SHADER, success);
 	if (!success) {
 		glDeleteShader(vertObj);
+		glDeleteShader(geomObj);
 		return 0;
 	}
 
@@ -439,6 +479,11 @@
 		glAttachShader(prog, vertObj);
 		p.objects.push_back(Object(vertObj, GL_VERTEX_SHADER));
 	}
+	if (geomObj != 0) {
+		glAttachShader(prog, geomObj);
+		p.objects.push_back(Object(geomObj, GL_GEOMETRY_SHADER_EXT));
+		ApplyGeometryParameters(L, 1, prog); // done before linking
+	}
 	if (fragObj != 0) {
 		glAttachShader(prog, fragObj);
 		p.objects.push_back(Object(fragObj, GL_FRAGMENT_SHADER));
@@ -476,7 +521,7 @@
 	if (lua_isnil(L, 1)) {
 		return 0;
 	}
-	const int progID = (int)luaL_checknumber(L, 1);
+	const int progID = luaL_checkint(L, 1);
 	LuaShaders&amp; shaders = CLuaHandle::GetActiveShaders();
 	shaders.RemoveProgram(progID);
 	return 0;
@@ -487,7 +532,7 @@
 {
 	CheckDrawingEnabled(L, __FUNCTION__);
 
-	const int progID = (int)luaL_checknumber(L, 1);
+	const int progID = luaL_checkint(L, 1);
 	if (progID == 0) {
 		glUseProgram(0);
 		lua_pushboolean(L, true);
@@ -508,7 +553,7 @@
 
 int LuaShaders::ActiveShader(lua_State* L)
 {
-	const int progID = (int)luaL_checkint(L, 1);
+	const int progID = luaL_checkint(L, 1);
 	luaL_checktype(L, 2, LUA_TFUNCTION);
 
 	GLuint progName;
@@ -611,7 +656,6 @@
 		}
 		lua_rawset(L, -3);
 	}
-	HSTR_PUSH_NUMBER(L, &quot;n&quot;, uniformCount);
 	
 	return 1;
 }
@@ -637,7 +681,7 @@
 
 int LuaShaders::Uniform(lua_State* L)
 {
-	if (activeShaderDepth == 0) {
+	if (activeShaderDepth &lt;= 0) {
 		CheckDrawingEnabled(L, __FUNCTION__);
 	}
 	const GLuint location = (GLuint)luaL_checknumber(L, 1);
@@ -646,28 +690,28 @@
 	switch (values) {
 		case 1: {
 			glUniform1f(location,
-									(float)luaL_checknumber(L, 2));
+									luaL_checkfloat(L, 2));
 			break;
 		}
 		case 2: {
 			glUniform2f(location,
-									(float)luaL_checknumber(L, 2),
-									(float)luaL_checknumber(L, 3));
+									luaL_checkfloat(L, 2),
+									luaL_checkfloat(L, 3));
 			break;
 		}
 		case 3: {
 			glUniform3f(location,
-									(float)luaL_checknumber(L, 2),
-									(float)luaL_checknumber(L, 3),
-									(float)luaL_checknumber(L, 4));
+									luaL_checkfloat(L, 2),
+									luaL_checkfloat(L, 3),
+									luaL_checkfloat(L, 4));
 			break;
 		}
 		case 4: {
 			glUniform4f(location,
-									(float)luaL_checknumber(L, 2),
-									(float)luaL_checknumber(L, 3),
-									(float)luaL_checknumber(L, 4),
-									(float)luaL_checknumber(L, 5));
+									luaL_checkfloat(L, 2),
+									luaL_checkfloat(L, 3),
+									luaL_checkfloat(L, 4),
+									luaL_checkfloat(L, 5));
 			break;
 		}
 		default: {
@@ -680,7 +724,7 @@
 
 int LuaShaders::UniformInt(lua_State* L)
 {
-	if (activeShaderDepth == 0) {
+	if (activeShaderDepth &lt;= 0) {
 		CheckDrawingEnabled(L, __FUNCTION__);
 	}
 	const GLuint location = (GLuint)luaL_checknumber(L, 1);
@@ -689,28 +733,28 @@
 	switch (values) {
 		case 1: {
 			glUniform1i(location,
-									(int)luaL_checknumber(L, 2));
+									luaL_checkint(L, 2));
 			break;
 		}
 		case 2: {
 			glUniform2i(location,
-									(int)luaL_checknumber(L, 2),
-									(int)luaL_checknumber(L, 3));
+									luaL_checkint(L, 2),
+									luaL_checkint(L, 3));
 			break;
 		}
 		case 3: {
 			glUniform3i(location,
-									(int)luaL_checknumber(L, 2),
-									(int)luaL_checknumber(L, 3),
-									(int)luaL_checknumber(L, 4));
+									luaL_checkint(L, 2),
+									luaL_checkint(L, 3),
+									luaL_checkint(L, 4));
 			break;
 		}
 		case 4: {
 			glUniform4i(location,
-									(int)luaL_checknumber(L, 2),
-									(int)luaL_checknumber(L, 3),
-									(int)luaL_checknumber(L, 4),
-									(int)luaL_checknumber(L, 5));
+									luaL_checkint(L, 2),
+									luaL_checkint(L, 3),
+									luaL_checkint(L, 4),
+									luaL_checkint(L, 5));
 			break;
 		}
 		default: {
@@ -733,7 +777,7 @@
 
 int LuaShaders::UniformMatrix(lua_State* L)
 {
-	if (activeShaderDepth == 0) {
+	if (activeShaderDepth &lt;= 0) {
 		CheckDrawingEnabled(L, __FUNCTION__);
 	}
 	const GLuint location = (GLuint)luaL_checknumber(L, 1);
@@ -768,7 +812,7 @@
 		case (2 * 2): {
 			float array[2 * 2];
 			for (int i = 0; i &lt; (2 * 2); i++) {
-				array[i] = (float)luaL_checknumber(L, i + 2);
+				array[i] = luaL_checkfloat(L, i + 2);
 			}
 			glUniformMatrix2fv(location, 1, GL_FALSE, array);
 			break;
@@ -776,7 +820,7 @@
 		case (3 * 3): {
 			float array[3 * 3];
 			for (int i = 0; i &lt; (3 * 3); i++) {
-				array[i] = (float)luaL_checknumber(L, i + 2);
+				array[i] = luaL_checkfloat(L, i + 2);
 			}
 			glUniformMatrix3fv(location, 1, GL_FALSE, array);
 			break;
@@ -784,7 +828,7 @@
 		case (4 * 4): {
 			float array[4 * 4];
 			for (int i = 0; i &lt; (4 * 4); i++) {
-				array[i] = (float)luaL_checknumber(L, i + 2);
+				array[i] = luaL_checkfloat(L, i + 2);
 			}
 			glUniformMatrix4fv(location, 1, GL_FALSE, array);
 			break;
@@ -797,5 +841,28 @@
 }
 
 
+int LuaShaders::SetShaderParameter(lua_State* L)
+{
+	if (activeShaderDepth &lt;= 0) {
+		CheckDrawingEnabled(L, __FUNCTION__);
+	}
+
+	const LuaShaders&amp; shaders = CLuaHandle::GetActiveShaders();
+	const GLuint progName = shaders.GetProgramName(L, 1);
+	if (progName == 0) {
+		return 0;
+	}
+
+	const GLenum param = (GLenum)luaL_checkint(L, 2);
+	const GLint  value =  (GLint)luaL_checkint(L, 3);
+
+	if (glProgramParameteriEXT) {
+		glProgramParameteriEXT(progName, param, value);
+	}
+
+	return 0;
+}
+
+
 /******************************************************************************/
 /******************************************************************************/

Modified: trunk/rts/Lua/LuaShaders.h
===================================================================
--- trunk/rts/Lua/LuaShaders.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaShaders.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -62,6 +62,8 @@
 		static int UniformInt(lua_State* L);
 		static int UniformMatrix(lua_State* L);
 
+		static int SetShaderParameter(lua_State* );
+
 		static int GetShaderLog(lua_State* L);
 
 	private:

Modified: trunk/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -120,6 +120,7 @@
 	REGISTER_LUA_CFUNC(SetUnitStockpile);
 	REGISTER_LUA_CFUNC(SetUnitWeaponState);
 	REGISTER_LUA_CFUNC(SetUnitExperience);
+	REGISTER_LUA_CFUNC(SetUnitArmored);
 	REGISTER_LUA_CFUNC(SetUnitLosMask);
 	REGISTER_LUA_CFUNC(SetUnitLosState);
 	REGISTER_LUA_CFUNC(SetUnitCloak);
@@ -130,12 +131,15 @@
 	REGISTER_LUA_CFUNC(SetUnitBuildSpeed);
 	REGISTER_LUA_CFUNC(SetUnitBlocking);
 	REGISTER_LUA_CFUNC(SetUnitShieldState);
+	REGISTER_LUA_CFUNC(SetUnitFlanking);
 	REGISTER_LUA_CFUNC(SetUnitTravel);
+	REGISTER_LUA_CFUNC(SetUnitFuel);
 	REGISTER_LUA_CFUNC(SetUnitMoveGoal);
 	REGISTER_LUA_CFUNC(SetUnitLineage);
 	REGISTER_LUA_CFUNC(SetUnitNeutral);
 	REGISTER_LUA_CFUNC(SetUnitTarget);
 	REGISTER_LUA_CFUNC(SetUnitCollisionVolumeData);
+	REGISTER_LUA_CFUNC(SetUnitSensorRadius);
 
 	REGISTER_LUA_CFUNC(SetUnitPhysics);
 	REGISTER_LUA_CFUNC(SetUnitPosition);
@@ -144,6 +148,7 @@
 
 	REGISTER_LUA_CFUNC(AddUnitDamage);
 	REGISTER_LUA_CFUNC(AddUnitImpulse);
+	REGISTER_LUA_CFUNC(AddUnitSeismicPing);
 
 	REGISTER_LUA_CFUNC(AddUnitResource);
 	REGISTER_LUA_CFUNC(UseUnitResource);
@@ -174,7 +179,6 @@
 	REGISTER_LUA_CFUNC(GiveOrderArrayToUnitMap);
 	REGISTER_LUA_CFUNC(GiveOrderArrayToUnitArray);
 
-
 	REGISTER_LUA_CFUNC(LevelHeightMap);
 	REGISTER_LUA_CFUNC(AdjustHeightMap);
 	REGISTER_LUA_CFUNC(RevertHeightMap);
@@ -229,32 +233,42 @@
 {
 	const int ctrlTeam = CtrlTeam();
 	if (ctrlTeam &lt; 0) {
-		return (ctrlTeam == CLuaHandle::AllAccessTeam) ? true : false;
+		return (ctrlTeam == CEventClient::AllAccessTeam) ? true : false;
 	}
 	return (ctrlTeam == teamID);
 }
 
 
+static inline bool CanControlAllyTeam(int allyTeamID)
+{
+	const int ctrlTeam = CtrlTeam();
+	if (ctrlTeam &lt; 0) {
+		return (ctrlTeam == CEventClient::AllAccessTeam) ? true : false;
+	}
+	return (gs-&gt;AllyTeam(ctrlTeam) == allyTeamID);
+}
+
+
 static inline bool CanControlUnit(const CUnit* unit)
 {
 	const int ctrlTeam = CtrlTeam();
 	if (ctrlTeam &lt; 0) {
-		return (ctrlTeam == CLuaHandle::AllAccessTeam) ? true : false;
+		return (ctrlTeam == CEventClient::AllAccessTeam) ? true : false;
 	}
 	return (ctrlTeam == unit-&gt;team);
 }
 
 
-static inline bool CanControlFeatureAllyTeam(int allyTeam)
+static inline bool CanControlFeatureAllyTeam(int allyTeamID)
 {
 	const int ctrlTeam = CtrlTeam();
 	if (ctrlTeam &lt; 0) {
-		return (ctrlTeam == CLuaHandle::AllAccessTeam) ? true : false;
+		return (ctrlTeam == CEventClient::AllAccessTeam) ? true : false;
 	}
-	if (allyTeam &lt; 0) {
+	if (allyTeamID &lt; 0) {
 		return (ctrlTeam == gs-&gt;gaiaTeamID);
 	}
-	return (gs-&gt;AllyTeam(ctrlTeam) == allyTeam);
+	return (gs-&gt;AllyTeam(ctrlTeam) == allyTeamID);
 }
 
 
@@ -264,6 +278,19 @@
 }
 
 
+static inline bool CanControlProjectileAllyTeam(int allyTeamID)
+{
+	const int ctrlTeam = CtrlTeam();
+	if (ctrlTeam &lt; 0) {
+		return (ctrlTeam == CEventClient::AllAccessTeam) ? true : false;
+	}
+	if (allyTeamID &lt; 0) {
+		return false;
+	}
+	return (gs-&gt;AllyTeam(ctrlTeam) == allyTeamID);
+}
+
+
 /******************************************************************************/
 /******************************************************************************/
 //
@@ -275,7 +302,7 @@
 	if (!lua_isnumber(L, index)) {
 		luaL_error(L, &quot;%s(): Bad unitID&quot;, caller);
 	}
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;%s(): Bad unitID: %d\n&quot;, caller, unitID);
 	}
@@ -306,7 +333,7 @@
 	if (!lua_isnumber(L, index)) {
 		luaL_error(L, &quot;Incorrect arguments to %s(featureID)&quot;, caller);
 	}
-	const int featureID = (int)lua_tonumber(L, index);
+	const int featureID = lua_toint(L, index);
 	const CFeatureSet&amp; fset = featureHandler-&gt;GetActiveFeatures();
 	CFeatureSet::const_iterator it = fset.find(featureID);
 
@@ -320,21 +347,20 @@
 }
 
 
-static inline CProjectile* ParseProjectile(lua_State* L, const char* caller, int index)
+static inline CProjectile* ParseProjectile(lua_State* L,
+                                           const char* caller, int index)
 {
 	if (!lua_isnumber(L, index)) {
 		luaL_error(L, &quot;%s(): Bad projectile ID&quot;, caller);
 	}
-
-	const int proID = (int) lua_tonumber(L, index);
-	ProjectileMap::iterator it = ph-&gt;weaponProjectileIDs.find(proID);
-
-	if (it == ph-&gt;weaponProjectileIDs.end()) {
-		luaL_error(L, &quot;%s(): Bad projectile ID: %d\n&quot;, caller, proID);
+	const ProjectileMapPair* pmp = ph-&gt;GetMapPairByID(lua_toint(L, index));
+	if (pmp == NULL) {
+		return NULL;
 	}
-
-	const ProjectileMapPair&amp; pp = it-&gt;second;
-	return pp.first;
+	if (!CanControlProjectileAllyTeam(pmp-&gt;second)) {
+		return NULL;
+	}
+	return pmp-&gt;first;
 }
 
 
@@ -344,7 +370,7 @@
 		luaL_error(L, &quot;%s(): Bad teamID&quot;, caller);
 		return NULL;
 	}
-	const int teamID = (int)lua_tonumber(L, index);
+	const int teamID = lua_toint(L, index);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		luaL_error(L, &quot;%s(): Bad teamID: %d&quot;, caller, teamID);
 	}
@@ -359,7 +385,7 @@
 static CUnit* CheckUnitID(lua_State* L, int index)
 {
 	luaL_checknumber(L, index);
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;Bad unitID: %d\n&quot;, unitID);
 	}
@@ -374,7 +400,7 @@
 static CPlayer* CheckPlayerID(lua_State* L, int index)
 {
 	luaL_checknumber(L, index);
-	const int playerID = (int)lua_tonumber(L, index);
+	const int playerID = lua_toint(L, index);
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		luaL_error(L, &quot;Bad playerID: %d\n&quot;, playerID);
 	}
@@ -400,7 +426,7 @@
 			return -1;
 		}
 		if (index &lt; size) {
-			array[index] = (float)lua_tonumber(L, -1);
+			array[index] = lua_tofloat(L, -1);
 			index++;
 		}
 	}
@@ -410,15 +436,19 @@
 
 static int ParseFacing(lua_State* L, const char* caller, int index)
 {
-	if (lua_isnumber(L, index)) {
-		return (int)lua_tonumber(L, index);
+	if (lua_israwnumber(L, index)) {
+		return lua_toint(L, index);
 	}
-	else if (lua_isstring(L, index)) {
+	else if (lua_israwstring(L, index)) {
 		const string dir = StringToLower(lua_tostring(L, index));
 		if (dir == &quot;s&quot;) { return 0; }
 		if (dir == &quot;e&quot;) { return 1; }
 		if (dir == &quot;n&quot;) { return 2; }
 		if (dir == &quot;w&quot;) { return 3; }
+		if (dir == &quot;south&quot;) { return 0; }
+		if (dir == &quot;east&quot;)  { return 1; }
+		if (dir == &quot;north&quot;) { return 2; }
+		if (dir == &quot;west&quot;)  { return 3; }
 		luaL_error(L, &quot;%s(): bad facing string&quot;, caller);
 	}
 	luaL_error(L, &quot;%s(): bad facing parameter&quot;, caller);
@@ -434,12 +464,7 @@
 
 int LuaSyncedCtrl::AddTeamResource(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) ||
-	    !lua_isnumber(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to AddTeamResource()&quot;);
-	}
-	const int teamID = (int)lua_tonumber(L, 1);
+	const int teamID = luaL_checkint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -451,9 +476,9 @@
 		return 0;
 	}
 
-	const string type = lua_tostring(L, 2);
+	const string type = luaL_checkstring(L, 2);
 
-	const float value = max(0.0f, float(lua_tonumber(L, 3)));
+	const float value = max(0.0f, luaL_checkfloat(L, 3));
 
 	if ((type == &quot;m&quot;) || (type == &quot;metal&quot;)) {
 		team-&gt;AddMetal(value);
@@ -467,11 +492,7 @@
 
 int LuaSyncedCtrl::UseTeamResource(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to UseTeamResource()&quot;);
-	}
-	const int teamID = (int)lua_tonumber(L, 1);
+	const int teamID = luaL_checkint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -525,18 +546,16 @@
 		}
 		return 1;
 	}
+	else {
+		luaL_error(L, &quot;bad arguments&quot;);
+	}
 	return 0;
 }
 
 
 int LuaSyncedCtrl::SetTeamResource(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) ||
-	    !lua_isnumber(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to SetTeamResource()&quot;);
-	}
-	const int teamID = (int)lua_tonumber(L, 1);
+	const int teamID = luaL_checkint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -548,9 +567,9 @@
 		return 0;
 	}
 
-	const string type = lua_tostring(L, 2);
+	const string type = luaL_checkstring(L, 2);
 
-	const float value = max(0.0f, (float)lua_tonumber(L, 3));
+	const float value = max(0.0f, luaL_checkfloat(L, 3));
 
 	if ((type == &quot;m&quot;) || (type == &quot;metal&quot;)) {
 		team-&gt;metal = min(team-&gt;metalStorage, value);
@@ -572,12 +591,7 @@
 
 int LuaSyncedCtrl::SetTeamShareLevel(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) ||
-	    !lua_isnumber(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to SetTeamShareLevel()&quot;);
-	}
-	const int teamID = (int)lua_tonumber(L, 1);
+	const int teamID = luaL_checkint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -589,9 +603,9 @@
 		return 0;
 	}
 
-	const string type = lua_tostring(L, 2);
+	const string type = luaL_checkstring(L, 2);
 
-	const float value = (float)lua_tonumber(L, 3);
+	const float value = luaL_checkfloat(L, 3);
 
 	if ((type == &quot;m&quot;) || (type == &quot;metal&quot;)) {
 		team-&gt;metalShare = max(0.0f, min(1.0f, value));
@@ -611,14 +625,14 @@
 {
 	for (int a = first; a &lt;= last; a++) {
 		if (lua_isnumber(L, a)) {
-			args.push_back((int)lua_tonumber(L, a));
+			args.push_back(lua_toint(L, a));
 		}
 		else if (lua_istable(L, a)) {
 			lua_rawgeti(L, a, 1);
 			lua_rawgeti(L, a, 2);
 			if (lua_isnumber(L, -2) &amp;&amp; lua_isnumber(L, -1)) {
-				const int x = (int)lua_tonumber(L, -2);
-				const int z = (int)lua_tonumber(L, -1);
+				const int x = lua_toint(L, -2);
+				const int z = lua_toint(L, -1);
 				args.push_back(PACKXZ(x, z));
 			} else {
 				args.push_back(0);
@@ -656,15 +670,15 @@
 	// collect the arguments
 	vector&lt;int&gt; cobArgs;
 	ParseCobArgs(L, 4, args, cobArgs);
-	const int retParams = min((int)lua_tonumber(L, 3),
+	const int retParams = min(lua_toint(L, 3),
 	                          min(MAX_LUA_COB_ARGS, (int)cobArgs.size()));
 
 	int retval;
-	if (lua_isnumber(L, 2)) {
-		const int funcId = (int)lua_tonumber(L, 2);
+	if (lua_israwnumber(L, 2)) {
+		const int funcId = lua_toint(L, 2);
 		retval = unit-&gt;cob-&gt;RawCall(funcId, cobArgs);
 	}
-	else if (lua_isstring(L, 2)) {
+	else if (lua_israwstring(L, 2)) {
 		const string funcName = lua_tostring(L, 2);
 		retval = unit-&gt;cob-&gt;Call(funcName, cobArgs);
 	}
@@ -704,20 +718,20 @@
 	// collect the arguments
 	vector&lt;int&gt; cobArgs;
 	ParseCobArgs(L, 5, args, cobArgs);
-	const int retParams = min((int)lua_tonumber(L, 3),
+	const int retParams = min(lua_toint(L, 3),
 	                          min(MAX_LUA_COB_ARGS, (int)cobArgs.size()));
 
 	// callback data
-	float cbData = (float)lua_tonumber(L, 4);
+	float cbData = lua_tofloat(L, 4);
 
 	int retval;
-	if (lua_isnumber(L, 2)) {
-		const int funcId = (int)lua_tonumber(L, 2);
+	if (lua_israwnumber(L, 2)) {
+		const int funcId = lua_toint(L, 2);
 		retval = unit-&gt;cob-&gt;RawCall(funcId, cobArgs,
 		                            CLuaHandle::GetActiveCallback(),
 		                            (void*) unit-&gt;id, (void*) *((int*)&amp;cbData));
 	}
-	else if (lua_isstring(L, 2)) {
+	else if (lua_israwstring(L, 2)) {
 		const string funcName = lua_tostring(L, 2);
 		retval = unit-&gt;cob-&gt;Call(funcName, cobArgs,
 		                         CLuaHandle::GetActiveCallback(),
@@ -778,7 +792,7 @@
 		arg++;
 	}
 
-	const int val = (int)luaL_checknumber(L, arg); arg++;
+	const int val = luaL_checkint(L, arg); arg++;
 
 	int p[4];
 	for (int a = 0; a &lt; 4; a++, arg++) {
@@ -811,14 +825,14 @@
 		return 0;
 	}
 	const int args = lua_gettop(L); // number of arguments
-	const int val = (int)luaL_checknumber(L, 2);
+	const int val = luaL_checkint(L, 2);
 	int param;
 	if (args == 3) {
-		param = (int)luaL_checknumber(L, 3);
+		param = luaL_checkint(L, 3);
 	}
 	else {
-		const int x = (int)luaL_checknumber(L, 3);
-		const int z = (int)luaL_checknumber(L, 4);
+		const int x = luaL_checkint(L, 3);
+		const int z = luaL_checkint(L, 4);
 		param = PACKXZ(x, z);
 	}
 	unit-&gt;cob-&gt;SetUnitVal(val, param);
@@ -832,28 +846,33 @@
 int LuaSyncedCtrl::CreateUnit(lua_State* L)
 {
 	CheckAllowGameChanges(L);
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 5) ||
-	    !lua_isstring(L, 1) || // name, pos, facing[, teamID]
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4) ||
-	    !(lua_isnumber(L, 5) || lua_isstring(L, 5))) {
+
+	const UnitDef* unitDef = NULL;
+	if (lua_israwstring(L, 1)) {
+		const string defName = lua_tostring(L, 1);
+		unitDef = unitDefHandler-&gt;GetUnitByName(defName);
+		if (unitDef == NULL) {
+			luaL_error(L, &quot;CreateUnit() bad unitDef name: %s&quot;, defName.c_str());
+		}
+	} else if (lua_israwnumber(L, 1)) {
+		const int defID = lua_toint(L, 1);
+		unitDef = unitDefHandler-&gt;GetUnitByID(defID);
+		if (unitDef == NULL) {
+			luaL_error(L, &quot;CreateUnit() bad unitDef ID: %i&quot;, defID);
+		}
+	} else {
 		luaL_error(L, &quot;Incorrect arguments to CreateUnit()&quot;);
 	}
 
-	const string&amp; defName = lua_tostring(L, 1);
-	const UnitDef* unitDef = unitDefHandler-&gt;GetUnitByName(defName);
-	if (unitDef == NULL) {
-		luaL_error(L, &quot;CreateUnit() bad unit name: %s&quot;, defName.c_str());
-	}
+	const float3 pos(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
 
-	const float3 pos((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
 	const int facing = ParseFacing(L, __FUNCTION__, 5);
 
 	int teamID = CtrlTeam();
-	if ((args &gt;= 6) &amp;&amp; lua_isnumber(L, 6)) {
-		teamID = (int)lua_tonumber(L, 6);
+	if (lua_israwnumber(L, 6)) {
+		teamID = lua_toint(L, 6);
 	}
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
 		luaL_error(L, &quot;CreateUnit(): bad team number: %d&quot;, teamID);
@@ -881,7 +900,8 @@
 		luaL_error(L, &quot;CreateUnit() recursion is not permitted&quot;);
 	}
 	inCreateUnit = true;
-	CUnit* unit = unitLoader.LoadUnit(defName, pos, teamID, false, facing, NULL);
+	CUnit* unit = unitLoader.LoadUnit(unitDef-&gt;name, pos, teamID,
+	                                  false, facing, NULL);
 	inCreateUnit = false;
 
 	if (unit) {
@@ -935,12 +955,8 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to TransferUnit()&quot;);
-	}
 
-	const int newTeam = (int)lua_tonumber(L, 2);
+	const int newTeam = luaL_checkint(L, 2);
 	if ((newTeam &lt; 0) || (newTeam &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -950,17 +966,16 @@
 	}
 
 	bool given = true;
-	if (FullCtrl()) {
-		if ((args &gt;= 3) &amp;&amp; lua_isboolean(L, 3)) {
-			given = lua_toboolean(L, 3);
-		}
+	if (FullCtrl() &amp;&amp; lua_isboolean(L, 3)) {
+		given = lua_toboolean(L, 3);
 	}
 
 	if (inTransferUnit) {
 		luaL_error(L, &quot;TransferUnit() recursion is not permitted&quot;);
 	}
 	inTransferUnit = true;
-	unit-&gt;ChangeTeam(newTeam, given ? CUnit::ChangeGiven : CUnit::ChangeCaptured);
+	unit-&gt;ChangeTeam(newTeam, given ? CUnit::ChangeGiven
+	                                : CUnit::ChangeCaptured);
 	inTransferUnit = false;
 
 	return 0;
@@ -976,7 +991,7 @@
 		return 0;
 	}
 	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_istable(L, 2)) {
+	if (!lua_istable(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitCosts&quot;);
 	}
 	const int table = 2;
@@ -1042,13 +1057,12 @@
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args == 3) &amp;&amp; lua_isstring(L, 2) &amp;&amp; lua_isnumber(L, 3)) {
-		const string key = lua_tostring(L, 2);
-		const float value = lua_tonumber(L, 3);
+	if (lua_israwstring(L, 2)) {
+		const string key = luaL_checkstring(L, 2);
+		const float value = luaL_checkfloat(L, 3);
 		SetUnitResourceParam(unit, key, value);
 	}
-	else if ((args == 2) &amp;&amp; lua_istable(L, 2)) {
+	else if (lua_istable(L, 2)) {
 		const int table = 2;
 		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
 			if (!lua_israwstring(L, -2) || !lua_isnumber(L, -1)) {
@@ -1074,11 +1088,7 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isstring(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitTooltip()&quot;);
-	}
-	unit-&gt;tooltip = lua_tostring(L, 2);
+	unit-&gt;tooltip = luaL_checkstring(L, 2);
 	return 0;
 }
 
@@ -1089,13 +1099,9 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if (args &lt; 2) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitHealth()&quot;);
-	}
 
 	if (lua_isnumber(L, 2)) {
-		float health = (float)lua_tonumber(L, 2);
+		float health = lua_tofloat(L, 2);
 		health = min(unit-&gt;maxHealth, health);
 		unit-&gt;health = health;
 	}
@@ -1104,7 +1110,7 @@
 		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
 			if (lua_israwstring(L, -2) &amp;&amp; lua_isnumber(L, -1)) {
 				const string key = lua_tostring(L, -2);
-				const float value = (float)lua_tonumber(L, -1);
+				const float value = lua_tofloat(L, -1);
 				if (key == &quot;health&quot;) {
 					unit-&gt;health = min(unit-&gt;maxHealth, value);
 				}
@@ -1142,7 +1148,7 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	unit-&gt;maxHealth = (float)luaL_checknumber(L, 2);
+	unit-&gt;maxHealth = luaL_checkfloat(L, 2);
 	if (unit-&gt;maxHealth &lt;= 0.0f) {
 		unit-&gt;maxHealth = 1.0f;
 	}
@@ -1172,7 +1178,7 @@
 	}
 
 	if (lua_isnumber(L, 3)) {
-		const float percent = max(0.0f, min(1.0f, (float)lua_tonumber(L, 3)));
+		const float percent = max(0.0f, min(1.0f, lua_tofloat(L, 3)));
 		unit-&gt;stockpileWeapon-&gt;buildPercent = percent;
 	}
 
@@ -1187,7 +1193,7 @@
 		return 0;
 	}
 
-	const int weaponNum = (int)luaL_checknumber(L,2);
+	const int weaponNum = luaL_checkint(L,2);
 	if ((weaponNum &lt; 0) || (weaponNum &gt;= unit-&gt;weapons.size())) {
 		return 0;
 	}
@@ -1198,7 +1204,7 @@
 		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
 			if (lua_israwstring(L, -2) &amp;&amp; lua_isnumber(L, -1)) {
 				const string key = lua_tostring(L, -2);
-				const float value = (float)lua_tonumber(L, -1);
+				const float value = lua_tofloat(L, -1);
 				// FIXME: KDR -- missing checks and updates?
 				if (key == &quot;reloadstate&quot;) {
 					weapon-&gt;reloadStatus = (int)value;
@@ -1232,12 +1238,25 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const float experience = max(0.0f, (float)luaL_checknumber(L, 2));
+	const float experience = max(0.0f, luaL_checkfloat(L, 2));
 	unit-&gt;AddExperience(experience - unit-&gt;experience);
 	return 0;
 }
 
 
+int LuaSyncedCtrl::SetUnitArmored(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	if (lua_isboolean(L, 2)) {
+		unit-&gt;armoredState = lua_toboolean(L, 2);
+	}
+	return 0;
+}
+
+
 static unsigned char ParseLosBits(lua_State* L, int index, unsigned char bits)
 {
 	if (lua_isnumber(L, index)) {
@@ -1322,20 +1341,17 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if (args &lt; 2) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitCloak()&quot;);
-	}
+
 	if (lua_isboolean(L, 2)) {
 		unit-&gt;scriptCloak = lua_toboolean(L, 2) ? 1 : 0;
 	} else if (lua_isnumber(L, 2)) {
-		unit-&gt;scriptCloak = (int)lua_tonumber(L, 2);
+		unit-&gt;scriptCloak = lua_toint(L, 2);
 	} else if (!lua_isnil(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitCloak()&quot;);
 	}
 
 	if (lua_israwnumber(L, 3)) {
-		unit-&gt;decloakDistance = (float)lua_tonumber(L, 3);
+		unit-&gt;decloakDistance = lua_tofloat(L, 3);
 	}
 	else if (lua_isboolean(L, 3)) {
 		const float defDist = unit-&gt;unitDef-&gt;decloakDistance;
@@ -1356,8 +1372,7 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isboolean(L, 2)) {
+	if (!lua_isboolean(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitStealth()&quot;);
 	}
 	unit-&gt;stealth = lua_toboolean(L, 2);
@@ -1371,8 +1386,7 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isboolean(L, 2)) {
+	if (!lua_isboolean(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitSonarStealth()&quot;);
 	}
 	unit-&gt;sonarStealth = lua_toboolean(L, 2);
@@ -1386,8 +1400,7 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isboolean(L, 2)) {
+	if (!lua_isboolean(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitAlwaysVisible()&quot;);
 	}
 	unit-&gt;alwaysVisible = lua_toboolean(L, 2);
@@ -1405,15 +1418,8 @@
 	if (mex == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitMetalExtraction()&quot;);
-	}
-	const float depth = (float)lua_tonumber(L, 2);
-	float range = mex-&gt;GetExtractionRange();
-	if ((args &gt;= 3) &amp;&amp; lua_isnumber(L, 3)) {
-		range = (float)lua_tonumber(L, 3);
-	}
+	const float depth = luaL_checkfloat(L, 2);
+	const float range = luaL_optfloat(L, 3, mex-&gt;GetExtractionRange());
 	mex-&gt;ResetExtraction();
 	mex-&gt;SetExtractionRangeAndDepth(range, depth);
 	return 0;
@@ -1426,36 +1432,35 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitBuildSpeed()&quot;);
-	}
+
 	const float buildScale = (1.0f / 32.0f);
-	const float buildSpeed = buildScale * max(0.0f, (float)lua_tonumber(L, 2));
+	const float buildSpeed = buildScale * max(0.0f, luaL_checkfloat(L, 2));
+
 	CFactory* factory = dynamic_cast&lt;CFactory*&gt;(unit);
 	if (factory) {
 		factory-&gt;buildSpeed = buildSpeed;
 		return 0;
 	}
+
 	CBuilder* builder = dynamic_cast&lt;CBuilder*&gt;(unit);
 	if (!builder) {
 		return 0;
 	}
 	builder-&gt;buildSpeed = buildSpeed;
-	if ((args &gt;= 3) &amp;&amp; lua_isnumber(L, 3)) {
-		builder-&gt;repairSpeed    = buildScale * max(0.0f, (float)lua_tonumber(L, 3));
+	if (lua_isnumber(L, 3)) {
+		builder-&gt;repairSpeed    = buildScale * max(0.0f, lua_tofloat(L, 3));
 	}
-	if ((args &gt;= 4) &amp;&amp; lua_isnumber(L, 4)) {
-		builder-&gt;reclaimSpeed   = buildScale * max(0.0f, (float)lua_tonumber(L, 4));
+	if (lua_isnumber(L, 4)) {
+		builder-&gt;reclaimSpeed   = buildScale * max(0.0f, lua_tofloat(L, 4));
 	}
-	if ((args &gt;= 5) &amp;&amp; lua_isnumber(L, 5)) {
-		builder-&gt;resurrectSpeed = buildScale * max(0.0f, (float)lua_tonumber(L, 5));
+	if (lua_isnumber(L, 5)) {
+		builder-&gt;resurrectSpeed = buildScale * max(0.0f, lua_tofloat(L, 5));
 	}
-	if ((args &gt;= 6) &amp;&amp; lua_isnumber(L, 6)) {
-		builder-&gt;captureSpeed   = buildScale * max(0.0f, (float)lua_tonumber(L, 6));
+	if (lua_isnumber(L, 6)) {
+		builder-&gt;captureSpeed   = buildScale * max(0.0f, lua_tofloat(L, 6));
 	}
-	if ((args &gt;= 7) &amp;&amp; lua_isnumber(L, 7)) {
-		builder-&gt;terraformSpeed = buildScale * max(0.0f, (float)lua_tonumber(L, 7));
+	if (lua_isnumber(L, 7)) {
+		builder-&gt;terraformSpeed = buildScale * max(0.0f, lua_tofloat(L, 7));
 	}
 	return 0;
 }
@@ -1467,14 +1472,16 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isboolean(L, 2)) {
+	if (!lua_isboolean(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitBlocking()&quot;);
 	}
+	const bool longTerm = lua_isboolean(L, 3) &amp;&amp; lua_toboolean(L, 3);
 	if (lua_toboolean(L, 2)) {
+		if (longTerm) { unit-&gt;blocking = true; }
 		unit-&gt;Block();
 	} else {
 		unit-&gt;UnBlock();
+		if (longTerm) { unit-&gt;blocking = false; }
 	}
 	return 0;
 }
@@ -1494,12 +1501,51 @@
 		shield-&gt;isEnabled = lua_toboolean(L, 2);
 	}
 	if (lua_isnumber(L, 3)) {
-		shield-&gt;curPower = (float)lua_tonumber(L, 3);
+		shield-&gt;curPower = lua_tofloat(L, 3);
 	}
 	return 0;
 }
 
 
+int LuaSyncedCtrl::SetUnitFlanking(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+
+	const string key = luaL_checkstring(L, 2);
+
+	if (key == &quot;mode&quot;) {
+		unit-&gt;flankingBonusMode = luaL_checkint(L, 3);
+	}
+	else if (key == &quot;dir&quot;) {
+		float3 dir(luaL_checkfloat(L, 3),
+		           luaL_checkfloat(L, 4),
+		           luaL_checkfloat(L, 5));
+		unit-&gt;flankingBonusDir = dir.Normalize();
+	}
+	else if (key == &quot;moveFactor&quot;) {
+		unit-&gt;flankingBonusMobilityAdd = luaL_checkfloat(L, 3);
+	}
+	else if (key == &quot;minDamage&quot;) {
+		const float minDamage = luaL_checkfloat(L, 3);
+		const float maxDamage = unit-&gt;flankingBonusAvgDamage +
+		                        unit-&gt;flankingBonusDifDamage;
+		unit-&gt;flankingBonusAvgDamage = (maxDamage + minDamage) * 0.5f;
+		unit-&gt;flankingBonusDifDamage = (maxDamage - minDamage) * 0.5f;
+	}
+	else if (key == &quot;maxDamage&quot;) {
+		const float maxDamage = luaL_checkfloat(L, 3);
+		const float minDamage = unit-&gt;flankingBonusAvgDamage -
+		                        unit-&gt;flankingBonusDifDamage;
+		unit-&gt;flankingBonusAvgDamage = (maxDamage + minDamage) * 0.5f;
+		unit-&gt;flankingBonusDifDamage = (maxDamage - minDamage) * 0.5f;
+	}
+	return 0;
+}
+
+
 int LuaSyncedCtrl::SetUnitTravel(lua_State* L)
 {
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
@@ -1507,15 +1553,26 @@
 		return 0;
 	}
 	if (lua_isnumber(L, 2)) {
-		unit-&gt;travel = (float)lua_tonumber(L, 2);
+		unit-&gt;travel = lua_tofloat(L, 2);
 	}
 	if (lua_isnumber(L, 3)) {
-		unit-&gt;travelPeriod = (float)lua_tonumber(L, 3);
+		unit-&gt;travelPeriod = lua_tofloat(L, 3);
 	}
 	return 0;
 }
 
 
+int LuaSyncedCtrl::SetUnitFuel(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	unit-&gt;currentFuel = luaL_checkfloat(L, 2);
+	return 0;
+}
+
+
 int LuaSyncedCtrl::SetUnitLineage(lua_State* L)
 {
 	if (!FullCtrl()) {
@@ -1558,9 +1615,9 @@
 	}
 	const int args = lua_gettop(L);
 	if (args &gt;= 4) {
-		const float3 pos((float)lua_tonumber(L, 2),
-		                 (float)lua_tonumber(L, 3),
-		                 (float)lua_tonumber(L, 4));
+		const float3 pos(luaL_checkfloat(L, 2),
+		                 luaL_checkfloat(L, 3),
+		                 luaL_checkfloat(L, 4));
 		const bool dgun = lua_isboolean(L, 5) &amp;&amp; lua_toboolean(L, 5);
 		unit-&gt;AttackGround(pos, dgun);
 	}
@@ -1584,31 +1641,71 @@
 		return 0;
 	}
 
-	const int args = lua_gettop(L);
-	if (args == 10) {
-		const float xs = float(lua_tonumber(L, 2));
-		const float ys = float(lua_tonumber(L, 3));
-		const float zs = float(lua_tonumber(L, 4));
-		const float xo = float(lua_tonumber(L, 5));
-		const float yo = float(lua_tonumber(L, 6));
-		const float zo = float(lua_tonumber(L, 7));
-		const int vType = int(lua_tonumber(L,  8));
-		const int tType = int(lua_tonumber(L,  9));
-		const int pAxis = int(lua_tonumber(L, 10));
+	const float xs = luaL_checkfloat(L, 2);
+	const float ys = luaL_checkfloat(L, 3);
+	const float zs = luaL_checkfloat(L, 4);
+	const float xo = luaL_checkfloat(L, 5);
+	const float yo = luaL_checkfloat(L, 6);
+	const float zo = luaL_checkfloat(L, 7);
+	const int vType = luaL_checkint(L,  8);
+	const int tType = luaL_checkint(L,  9);
+	const int pAxis = luaL_checkint(L, 10);
 
-		const float3 scales(xs, ys, zs);
-		const float3 offsets(xo, yo, zo);
+	const float3 scales(xs, ys, zs);
+	const float3 offsets(xo, yo, zo);
 
-		unit-&gt;collisionVolume-&gt;Init(scales, offsets, vType, tType, pAxis);
+	unit-&gt;collisionVolume-&gt;Init(scales, offsets, vType, tType, pAxis);
+
+	return 0;
+}
+
+
+int LuaSyncedCtrl::SetUnitSensorRadius(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+
+	const string key = luaL_checkstring(L, 2);
+	const float radius = luaL_checkfloat(L, 3);
+
+	const int radarDiv    = (SQUARE_SIZE * RADAR_SIZE);
+	const int radarRadius = (int)(radius / (float)radarDiv);
+
+	if (key == &quot;los&quot;) {
+		const int losRange = (int)(radius * loshandler-&gt;invLosDiv);
+		unit-&gt;ChangeLos(losRange, unit-&gt;realAirLosRadius);
+		unit-&gt;realLosRadius = losRange;
+		lua_pushnumber(L, unit-&gt;losRadius * loshandler-&gt;losDiv);
+	} else if (key == &quot;airLos&quot;) {
+		const int airRange = (int)(radius * loshandler-&gt;invAirDiv);
+		unit-&gt;ChangeLos(unit-&gt;realLosRadius, airRange);
+		unit-&gt;realAirLosRadius = airRange;
+		lua_pushnumber(L, unit-&gt;airLosRadius * loshandler-&gt;airDiv);
+	} else if (key == &quot;radar&quot;) {
+		unit-&gt;ChangeSensorRadius(&amp;unit-&gt;radarRadius, radarRadius);
+		lua_pushnumber(L, unit-&gt;radarRadius * radarDiv);
+	} else if (key == &quot;sonar&quot;) {
+		unit-&gt;ChangeSensorRadius(&amp;unit-&gt;sonarRadius, radarRadius);
+		lua_pushnumber(L, unit-&gt;sonarRadius * radarDiv);
+	} else if (key == &quot;seismic&quot;) {
+		unit-&gt;ChangeSensorRadius(&amp;unit-&gt;seismicRadius, radarRadius);
+		lua_pushnumber(L, unit-&gt;seismicRadius * radarDiv);
+	} else if (key == &quot;radarJammer&quot;) {
+		unit-&gt;ChangeSensorRadius(&amp;unit-&gt;jammerRadius, radarRadius);
+		lua_pushnumber(L, unit-&gt;jammerRadius * radarDiv);
+	} else if (key == &quot;sonarJammer&quot;) {
+		unit-&gt;ChangeSensorRadius(&amp;unit-&gt;sonarJamRadius, radarRadius);
+		lua_pushnumber(L, unit-&gt;sonarJamRadius * radarDiv);
 	} else {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitCollisionVolumeData()&quot;);
+		return 0; // unknown sensor type
 	}
 
-	return 0;
+	return 1;
 }
 
 
-
 int LuaSyncedCtrl::SetUnitMoveGoal(lua_State* L)
 {
 	CheckAllowGameChanges(L);
@@ -1619,11 +1716,11 @@
 	if (unit-&gt;moveType == NULL) {
 		return 0;
 	}
-	const float3 pos((float)luaL_checknumber(L, 2),
-									 (float)luaL_checknumber(L, 3),
-									 (float)luaL_checknumber(L, 4));
-	const float radius = (float)luaL_optnumber(L, 5, 0.0f);
-	const float speed  = (float)luaL_optnumber(L, 6, unit-&gt;maxSpeed * 2.0f);
+	const float3 pos(luaL_checkfloat(L, 2),
+									 luaL_checkfloat(L, 3),
+									 luaL_checkfloat(L, 4));
+	const float radius = luaL_optfloat(L, 5, 0.0f);
+	const float speed  = luaL_optfloat(L, 6, unit-&gt;maxSpeed * 2.0f);
 
 	unit-&gt;moveType-&gt;StartMoving(pos, radius, speed);
 
@@ -1678,22 +1775,18 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitPosition()&quot;);
-	}
 
 	if (lua_isnumber(L, 4)) {
-		float3 pos((float)lua_tonumber(L, 2),
-							 (float)lua_tonumber(L, 3),
-							 (float)lua_tonumber(L, 4));
+		float3 pos(luaL_checkfloat(L, 2),
+							 luaL_checkfloat(L, 3),
+							 luaL_checkfloat(L, 4));
 		unit-&gt;ForcedMove(pos);
 		return 0;
 	}
 
 	float x, y, z;
-	x = (float)lua_tonumber(L, 2);
-	z = (float)lua_tonumber(L, 3);
+	x = luaL_checkfloat(L, 2);
+	z = luaL_checkfloat(L, 3);
 	if (lua_isboolean(L, 4) &amp;&amp; lua_toboolean(L, 4)) {
 		y = ground-&gt;GetHeight(x, z);
 	} else {
@@ -1711,14 +1804,9 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitRotation()&quot;);
-	}
-	const float3 rot((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
+	const float3 rot(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
 	CMatrix44f matrix;
 	matrix.RotateZ(rot.z);
 	matrix.RotateX(rot.x);
@@ -1747,14 +1835,9 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitVelocity()&quot;);
-	}
-	float3 dir((float)lua_tonumber(L, 2),
-	           (float)lua_tonumber(L, 3),
-	           (float)lua_tonumber(L, 4));
+	float3 dir(luaL_checkfloat(L, 2),
+	           luaL_checkfloat(L, 3),
+	           luaL_checkfloat(L, 4));
 	unit-&gt;speed = dir;
 	return 0;
 }
@@ -1766,13 +1849,13 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const float damage   = (float)luaL_checknumber(L, 2);
+	const float damage   = luaL_checkfloat(L, 2);
 	const int paralyze   = luaL_optint(L, 3, 0);
 	const int attackerID = luaL_optint(L, 4, -1);
 	const int weaponID   = luaL_optint(L, 5, -1);
-	const float3 impulse = float3((float)luaL_optnumber(L, 6, 0.0f),
-	                              (float)luaL_optnumber(L, 7, 0.0f),
-	                              (float)luaL_optnumber(L, 8, 0.0f));
+	const float3 impulse = float3(luaL_optfloat(L, 6, 0.0f),
+	                              luaL_optfloat(L, 7, 0.0f),
+	                              luaL_optfloat(L, 8, 0.0f));
 
 	CUnit* attacker = NULL;
 	if (attackerID &gt;= 0) {
@@ -1805,20 +1888,27 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to AddUnitImpulse()&quot;);
-	}
-	float3 impulse((float)lua_tonumber(L, 2),
-	               (float)lua_tonumber(L, 3),
-	               (float)lua_tonumber(L, 4));
+	float3 impulse(luaL_checkfloat(L, 2),
+	               luaL_checkfloat(L, 3),
+	               luaL_checkfloat(L, 4));
 	unit-&gt;residualImpulse += impulse;
 	unit-&gt;moveType-&gt;ImpulseAdded();
 	return 0;
 }
 
 
+int LuaSyncedCtrl::AddUnitSeismicPing(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	const float pingSize = luaL_checkfloat(L, 2);
+	unit-&gt;DoSeismicPing(pingSize);
+	return 0;
+}
+
+
 /******************************************************************************/
 
 int LuaSyncedCtrl::AddUnitResource(lua_State* L)
@@ -1828,15 +1918,10 @@
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) || !lua_isstring(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to AddUnitResource()&quot;);
-	}
+	const string type = luaL_checkstring(L, 2);
 
-	const string type = lua_tostring(L, 2);
+	const float value = max(0.0f, luaL_checkfloat(L, 3));
 
-	const float value = max(0.0f, float(lua_tonumber(L, 3)));
-
 	if ((type == &quot;m&quot;) || (type == &quot;metal&quot;)) {
 		unit-&gt;AddMetal(value);
 	}
@@ -1854,11 +1939,6 @@
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if (args &lt; 2) {
-		luaL_error(L, &quot;Incorrect arguments to UseUnitResource()&quot;);
-	}
-
 	if (lua_isstring(L, 2)) {
 		const string type = lua_tostring(L, 2);
 		const float value = max(0.0f, float(lua_tonumber(L, 3)));
@@ -1898,6 +1978,10 @@
 		}
 		return 1;
 	}
+	else {
+		luaL_error(L, &quot;Incorrect arguments to UseUnitResource()&quot;);
+	}
+		
 	return 0;
 }
 
@@ -1938,25 +2022,24 @@
 int LuaSyncedCtrl::CreateFeature(lua_State* L)
 {
 	CheckAllowGameChanges(L);
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    // name, pos[, heading[, allyTeam]]
-	    !lua_isstring(L, 1) ||
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to CreateFeature()&quot;);
+
+	const FeatureDef* featureDef = NULL;
+	if (lua_israwstring(L, 1)) {
+		featureDef = featureHandler-&gt;GetFeatureDef(lua_tostring(L, 1));
+	} else if (lua_israwnumber(L, 1)) {
+		featureDef = featureHandler-&gt;GetFeatureDefByID(lua_toint(L, 1));
 	}
-	const string defName = lua_tostring(L, 1);
-	const FeatureDef* featureDef = featureHandler-&gt;GetFeatureDef(defName);
 	if (featureDef == NULL) {
 		return 0; // do not error  (featureDefs are dynamic)
 	}
-	const float3 pos((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
 
+	const float3 pos(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
+
 	short int heading = 0;
-	if ((args &gt;= 5) &amp;&amp; lua_isnumber(L, 5)) {
-		heading = (int)lua_tonumber(L, 5);
+	if (lua_isnumber(L, 5)) {
+		heading = lua_toint(L, 5);
 	}
 
 	int team = CtrlTeam();
@@ -1966,8 +2049,8 @@
 
 	// FIXME -- separate teamcolor/allyteam arguments
 
-	if ((args &gt;= 6) &amp;&amp; lua_isnumber(L, 6)) {
-		team = (int)lua_tonumber(L, 6);
+	if (lua_isnumber(L, 6)) {
+		team = lua_toint(L, 6);
 		if (team &lt; -1) {
 			team = -1;
 		} else if (team &gt;= MAX_TEAMS) {
@@ -2023,11 +2106,7 @@
 	if (feature == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to TransferFeature()&quot;);
-	}
-	const int team = (int)lua_tonumber(L, 2);
+	const int team = luaL_checkint(L, 2);
 	if (team &gt;= MAX_TEAMS) {
 		return 0;
 	}
@@ -2041,11 +2120,7 @@
 	if (feature == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetFeatureHealth()&quot;);
-	}
-	feature-&gt;health = (float)lua_tonumber(L, 2);
+	feature-&gt;health = luaL_checkfloat(L, 2);
 	return 0;
 }
 
@@ -2056,11 +2131,7 @@
 	if (feature == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetFeatureReclaim()&quot;);
-	}
-	feature-&gt;reclaimLeft = (float)lua_tonumber(L, 2);
+	feature-&gt;reclaimLeft = luaL_checkfloat(L, 2);
 	return 0;
 }
 
@@ -2071,14 +2142,9 @@
 	if (feature == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to SetFeaturePosition()&quot;);
-	}
-	const float3 pos((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
+	const float3 pos(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
 	feature-&gt;ForcedMove(pos);
 	return 0;
 }
@@ -2090,14 +2156,9 @@
 	if (feature == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to SetFeatureDirection()&quot;);
-	}
-	float3 dir((float)lua_tonumber(L, 2),
-	           (float)lua_tonumber(L, 3),
-	           (float)lua_tonumber(L, 4));
+	float3 dir(luaL_checkfloat(L, 2),
+	           luaL_checkfloat(L, 3),
+	           luaL_checkfloat(L, 4));
 	dir.Normalize();
 	feature-&gt;ForcedSpin(dir);
 	return 0;
@@ -2110,11 +2171,9 @@
 	if (feature == NULL) {
 		return 0;
 	}
+	feature-&gt;createdFromUnit = luaL_checkstring(L, 2);
+
 	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isstring(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetFeatureResurrect()&quot;);
-	}
-	feature-&gt;createdFromUnit = lua_tostring(L, 2);
 	if (args &gt;= 3) {
 		feature-&gt;buildFacing = ParseFacing(L, __FUNCTION__, 3);
 	}
@@ -2128,8 +2187,7 @@
 	if (feature == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isboolean(L, 2)) {
+	if (!lua_isboolean(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetFeatureNoSelect()&quot;);
 	}
 	feature-&gt;noSelect = !!lua_toboolean(L, 2);
@@ -2147,79 +2205,64 @@
 		return 0;
 	}
 
-	const int args = lua_gettop(L);
-	if (args == 10) {
-		const float xs = float(lua_tonumber(L, 2));
-		const float ys = float(lua_tonumber(L, 3));
-		const float zs = float(lua_tonumber(L, 4));
-		const float xo = float(lua_tonumber(L, 5));
-		const float yo = float(lua_tonumber(L, 6));
-		const float zo = float(lua_tonumber(L, 7));
-		const int vType = int(lua_tonumber(L,  8));
-		const int tType = int(lua_tonumber(L,  9));
-		const int pAxis = int(lua_tonumber(L, 10));
+	const float xs = luaL_checkfloat(L, 2);
+	const float ys = luaL_checkfloat(L, 3);
+	const float zs = luaL_checkfloat(L, 4);
+	const float xo = luaL_checkfloat(L, 5);
+	const float yo = luaL_checkfloat(L, 6);
+	const float zo = luaL_checkfloat(L, 7);
+	const int vType = luaL_checkint(L,  8);
+	const int tType = luaL_checkint(L,  9);
+	const int pAxis = luaL_checkint(L, 10);
 
-		const float3 scales(xs, ys, zs);
-		const float3 offsets(xo, yo, zo);
+	const float3 scales(xs, ys, zs);
+	const float3 offsets(xo, yo, zo);
 
-		feature-&gt;collisionVolume-&gt;Init(scales, offsets, vType, tType, pAxis);
-	} else {
-		luaL_error(L, &quot;Incorrect arguments to SetFeatureCollisionVolumeData()&quot;);
-	}
+	feature-&gt;collisionVolume-&gt;Init(scales, offsets, vType, tType, pAxis);
 
 	return 0;
 }
 
-
 /******************************************************************************/
 /******************************************************************************/
 
 int LuaSyncedCtrl::SetProjectilePosition(lua_State* L)
 {
-	CProjectile* pro = ParseProjectile(L, __FUNCTION__, 1);
-	if (pro == NULL) {
+	CProjectile* proj = ParseProjectile(L, __FUNCTION__, 1);
+	if (proj == NULL) {
 		return 0;
 	}
 
-	const int argc = lua_gettop(L);
-	if (argc == 4) {
-		pro-&gt;pos.x = lua_isnumber(L, 2)? float(lua_tonumber(L, 2)): 0.0f;
-		pro-&gt;pos.y = lua_isnumber(L, 3)? float(lua_tonumber(L, 3)): 0.0f;
-		pro-&gt;pos.z = lua_isnumber(L, 4)? float(lua_tonumber(L, 4)): 0.0f;
-	} else {
-		luaL_error(L, &quot;Incorrect arguments to SetProjectilePosition()&quot;);
-	}
+	proj-&gt;pos.x = luaL_optfloat(L, 2, 0.0f);
+	proj-&gt;pos.y = luaL_optfloat(L, 3, 0.0f);
+	proj-&gt;pos.z = luaL_optfloat(L, 4, 0.0f);
 
 	return 0;
 }
 
+
 int LuaSyncedCtrl::SetProjectileVelocity(lua_State* L)
 {
-	CProjectile* pro = ParseProjectile(L, __FUNCTION__, 1);
-	if (pro == NULL) {
+	CProjectile* proj = ParseProjectile(L, __FUNCTION__, 1);
+	if (proj == NULL) {
 		return 0;
 	}
 
-	const int argc = lua_gettop(L);
-	if (argc == 4) {
-		pro-&gt;speed.x = lua_isnumber(L, 2)? float(lua_tonumber(L, 2)): 0.0f;
-		pro-&gt;speed.y = lua_isnumber(L, 3)? float(lua_tonumber(L, 3)): 0.0f;
-		pro-&gt;speed.z = lua_isnumber(L, 4)? float(lua_tonumber(L, 4)): 0.0f;
-	} else {
-		luaL_error(L, &quot;Incorrect arguments to SetProjectileVelocity()&quot;);
-	}
+	proj-&gt;speed.x = luaL_optfloat(L, 2, 0.0f);
+	proj-&gt;speed.y = luaL_optfloat(L, 3, 0.0f);
+	proj-&gt;speed.z = luaL_optfloat(L, 4, 0.0f);
 
 	return 0;
 }
 
 int LuaSyncedCtrl::SetProjectileCollision(lua_State* L)
 {
-	CProjectile* pro = ParseProjectile(L, __FUNCTION__, 1);
-	if (pro == NULL) {
+	CProjectile* proj = ParseProjectile(L, __FUNCTION__, 1);
+	if (proj == NULL) {
 		return 0;
 	}
 
-	pro-&gt;Collision();
+	proj-&gt;Collision();
 
 	return 0;
 }
@@ -2465,23 +2508,16 @@
 
 	const int args = lua_gettop(L); // number of arguments
 	if (args == 3) {
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2)|| !lua_isnumber(L, 3)) {
-			luaL_error(L, &quot;Incorrect arguments to %s()&quot;, caller);
-		}
-		fx1 = fx2 = (float)lua_tonumber(L, 1);
-		fz1 = fz2 = (float)lua_tonumber(L, 2);
-		factor    = (float)lua_tonumber(L, 3);
+		fx1 = fx2 = luaL_checkfloat(L, 1);
+		fz1 = fz2 = luaL_checkfloat(L, 2);
+		factor    = luaL_checkfloat(L, 3);
 	}
 	else if (args == 5) {
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) ||
-		    !lua_isnumber(L, 3) || !lua_isnumber(L, 4) || !lua_isnumber(L, 5)) {
-			luaL_error(L, &quot;Incorrect arguments to %s()&quot;, caller);
-		}
-		fx1    = (float)lua_tonumber(L, 1);
-		fz1    = (float)lua_tonumber(L, 2);
-		fx2    = (float)lua_tonumber(L, 3);
-		fz2    = (float)lua_tonumber(L, 4);
-		factor = (float)lua_tonumber(L, 5);
+		fx1    = luaL_checkfloat(L, 1);
+		fz1    = luaL_checkfloat(L, 2);
+		fx2    = luaL_checkfloat(L, 3);
+		fz2    = luaL_checkfloat(L, 4);
+		factor = luaL_checkfloat(L, 5);
 	}
 	else {
 		luaL_error(L, &quot;Incorrect arguments to %s()&quot;, caller);
@@ -2577,32 +2613,24 @@
 
 int LuaSyncedCtrl::SpawnCEG(lua_State* L)
 {
-	const int argc = lua_gettop(L);
+	const string name = luaL_checkstring(L, 1);
+	const float3 pos(luaL_optfloat(L, 2, 0.0f),
+									 luaL_optfloat(L, 3, 0.0f),
+									 luaL_optfloat(L, 4, 0.0f));
+	const float3 dir(luaL_optfloat(L, 5, 0.0f),
+									 luaL_optfloat(L, 6, 0.0f),
+									 luaL_optfloat(L, 7, 0.0f));
+	const float rad = luaL_optfloat(L, 8, 0.0f);
+	const float dmg = luaL_optfloat(L, 9, 0.0f);
+	const float dmgMod = 1.0f;
+	if (name.empty()) {
+		return 0;
+	}
 
-	if (argc == 9 &amp;&amp; lua_isstring(L, 1)) {
-		const string name = lua_tostring(L, 1);
-		const float posx  = lua_isnumber(L, 2)? lua_tonumber(L, 2): 0.0f;
-		const float posy  = lua_isnumber(L, 3)? lua_tonumber(L, 3): 0.0f;
-		const float posz  = lua_isnumber(L, 4)? lua_tonumber(L, 4): 0.0f;
-		const float dirx  = lua_isnumber(L, 5)? lua_tonumber(L, 5): 0.0f;
-		const float diry  = lua_isnumber(L, 6)? lua_tonumber(L, 6): 0.0f;
-		const float dirz  = lua_isnumber(L, 7)? lua_tonumber(L, 7): 0.0f;
-		const float rad   = lua_isnumber(L, 8)? lua_tonumber(L, 8): 0.0f;
-		const float dmg   = lua_isnumber(L, 9)? lua_tonumber(L, 9): 0.0f;
-		const float dmgMod = 1.0f;
+	CCustomExplosionGenerator g;
+	g.Load(explGenHandler, name);
+	g.Explosion(pos, dmg, rad, 0x0, dmgMod, 0x0, dir);
 
-		if (!name.empty()) {
-			const float3 pos(posx, posy, posz);
-			const float3 dir(dirx, diry, dirz);
-
-			CCustomExplosionGenerator g;
-			g.Load(explGenHandler, name);
-			g.Explosion(pos, dmg, rad, 0x0, dmgMod, 0x0, dir);
-		}
-	} else {
-		luaL_error(L, &quot;Incorrect arguments to SpawnCEG()&quot;);
-	}
-
 	return 0;
 }
 
@@ -2614,8 +2642,7 @@
 	if (!FullCtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isboolean(L, 1)) {
+	if (!lua_isboolean(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to SetNoPause()&quot;);
 	}
 	// Important: only works in server mode, has no effect in client mode
@@ -2631,8 +2658,7 @@
 	if (!FullCtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isboolean(L, 1)) {
+	if (!lua_isboolean(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitToFeature()&quot;);
 	}
 	uh-&gt;morphUnitToFeature = lua_toboolean(L, 1);
@@ -2645,19 +2671,19 @@
 	if (!FullCtrl()) {
 		return 0;
 	}
-	const float expGrade = (float)luaL_checknumber(L, 1);
+	const float expGrade = luaL_checkfloat(L, 1);
 	CUnit::SetExpGrade(expGrade);
 
 	// NOTE: for testing, should be using modrules.tdf
 	if (gs-&gt;cheatEnabled) {
 		if (lua_isnumber(L, 2)) {
-			CUnit::SetExpPowerScale((float)lua_tonumber(L, 2));
+			CUnit::SetExpPowerScale(lua_tofloat(L, 2));
 		}
 		if (lua_isnumber(L, 3)) {
-			CUnit::SetExpHealthScale((float)lua_tonumber(L, 3));
+			CUnit::SetExpHealthScale(lua_tofloat(L, 3));
 		}
 		if (lua_isnumber(L, 4)) {
-			CUnit::SetExpReloadScale((float)lua_tonumber(L, 4));
+			CUnit::SetExpReloadScale(lua_tofloat(L, 4));
 		}
 	}
 	return 0;
@@ -2674,7 +2700,7 @@
 		return false;
 	}
 	if (lua_isnumber(L, -1)) {
-		value = (int)lua_tonumber(L, -1);
+		value = lua_toint(L, -1);
 	} else {
 		luaL_error(L, &quot;bad %s argument&quot;, name.c_str());
 	}
@@ -2737,7 +2763,7 @@
 	while (true) {
 		lua_rawgeti(L, index, i);
 		if (lua_isnumber(L, -1)) {
-			floatvec.push_back((float)lua_tonumber(L, -1));
+			floatvec.push_back(lua_tofloat(L, -1));
 			lua_pop(L, 1);
 			i++;
 		} else {
@@ -2755,7 +2781,7 @@
 	while (true) {
 		lua_rawgeti(L, index, i);
 		if (lua_isnumber(L, -1)) {
-			intvec.push_back((int)lua_tonumber(L, -1));
+			intvec.push_back(lua_toint(L, -1));
 			lua_pop(L, 1);
 			i++;
 		} else {
@@ -2788,7 +2814,7 @@
 		    ParseNamedString(L, key, &quot;tooltip&quot;,     cd.tooltip)    ||
 		    ParseNamedString(L, key, &quot;texture&quot;,     cd.iconname)   ||
 		    ParseNamedString(L, key, &quot;cursor&quot;,      cd.mouseicon)  ||
-		    ParseNamedBool(L,   key, &quot;hidden&quot;,      cd.onlyKey)    ||
+		    ParseNamedBool(L,   key, &quot;hidden&quot;,      cd.hidden)     ||
 		    ParseNamedBool(L,   key, &quot;disabled&quot;,    cd.disabled)   ||
 		    ParseNamedBool(L,   key, &quot;showUnique&quot;,  cd.showUnique) ||
 		    ParseNamedBool(L,   key, &quot;onlyTexture&quot;, cd.onlyTexture)) {
@@ -2811,11 +2837,6 @@
 	if (!FullCtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 3) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_istable(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to EditUnitCmdDesc&quot;);
-	}
 
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
 	if (unit == NULL) {
@@ -2823,7 +2844,7 @@
 	}
 	vector&lt;CommandDescription&gt;&amp; cmdDescs = unit-&gt;commandAI-&gt;possibleCommands;
 
-	const int cmdDescID = (int)lua_tonumber(L, 2) - 1;
+	const int cmdDescID = luaL_checkint(L, 2) - 1;
 	if ((cmdDescID &lt; 0) || (cmdDescID &gt;= (int)cmdDescs.size())) {
 		return 0;
 	}
@@ -2860,7 +2881,7 @@
 
 	int cmdDescID = (int)cmdDescs.size();
 	if (args &gt;= 3) {
-		cmdDescID = (int)lua_tonumber(L, 2) - 1;
+		cmdDescID = lua_toint(L, 2) - 1;
 		if (cmdDescID &lt; 0) {
 			cmdDescID = 0;
 		}
@@ -2888,10 +2909,6 @@
 	if (!FullCtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to RemoveUnitCmdDesc&quot;);
-	}
 
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
 	if (unit == NULL) {
@@ -2900,8 +2917,8 @@
 	vector&lt;CommandDescription&gt;&amp; cmdDescs = unit-&gt;commandAI-&gt;possibleCommands;
 
 	int cmdDescID = (int)cmdDescs.size() - 1;
-	if ((args &gt;= 2) &amp;&amp; lua_isnumber(L, 2)) {
-		cmdDescID = (int)lua_tonumber(L, 2) - 1;
+	if (lua_isnumber(L, 2)) {
+		cmdDescID = lua_toint(L, 2) - 1;
 	}
 
 	if ((cmdDescID &lt; 0) || (cmdDescID &gt;= (int)cmdDescs.size())) {

Modified: trunk/rts/Lua/LuaSyncedCtrl.h
===================================================================
--- trunk/rts/Lua/LuaSyncedCtrl.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaSyncedCtrl.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -56,6 +56,7 @@
 		static int SetUnitStockpile(lua_State* L);
 		static int SetUnitWeaponState(lua_State* L);
 		static int SetUnitExperience(lua_State* L);
+		static int SetUnitArmored(lua_State* L);
 		static int SetUnitLosMask(lua_State* L);
 		static int SetUnitLosState(lua_State* L);
 		static int SetUnitCloak(lua_State* L);
@@ -66,12 +67,15 @@
 		static int SetUnitBuildSpeed(lua_State* L);
 		static int SetUnitBlocking(lua_State* L);
 		static int SetUnitShieldState(lua_State* L);
+		static int SetUnitFlanking(lua_State* L);
 		static int SetUnitTravel(lua_State* L);
+		static int SetUnitFuel(lua_State* L);
 		static int SetUnitMoveGoal(lua_State* L);
 		static int SetUnitLineage(lua_State* L);
 		static int SetUnitNeutral(lua_State* L);
 		static int SetUnitTarget(lua_State* L);
 		static int SetUnitCollisionVolumeData(lua_State* L);
+		static int SetUnitSensorRadius(lua_State* L);
 
 		static int SetUnitPhysics(lua_State* L);
 		static int SetUnitPosition(lua_State* L);
@@ -80,6 +84,7 @@
 
 		static int AddUnitDamage(lua_State* L);
 		static int AddUnitImpulse(lua_State* L);
+		static int AddUnitSeismicPing(lua_State* L);
 
 		static int AddUnitResource(lua_State* L);
 		static int UseUnitResource(lua_State* L);

Modified: trunk/rts/Lua/LuaSyncedMoveCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedMoveCtrl.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaSyncedMoveCtrl.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -97,7 +97,7 @@
 {
 	const int ctrlTeam = CtrlTeam();
 	if (ctrlTeam &lt; 0) {
-		return (ctrlTeam == CLuaHandle::AllAccessTeam) ? true : false;
+		return (ctrlTeam == CEventClient::AllAccessTeam) ? true : false;
 	}
 	return (ctrlTeam == unit-&gt;team);
 }
@@ -108,7 +108,7 @@
 	if (!lua_isnumber(L, index)) {
 		luaL_error(L, &quot;%s(): Bad unitID&quot;, caller);
 	}
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
 	}
@@ -199,7 +199,7 @@
 	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetTag()&quot;);
 	}
-	moveType-&gt;tag = (int)lua_tonumber(L, 2);
+	moveType-&gt;tag = lua_toint(L, 2);
 	return 0;
 }
 
@@ -230,7 +230,7 @@
 	}
 
 	if (lua_isnumber(L, 2)) {
-		const int state = (int)lua_tonumber(L, 2);
+		const int state = lua_toint(L, 2);
 		if ((state &lt; AMoveType::Done) || (state &gt; AMoveType::Failed)) {
 			luaL_error(L, &quot;SetProgressState(): bad state value (%i)&quot;, state);
 		}
@@ -280,15 +280,15 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	const float3 pos((float)luaL_checknumber(L, 2),
-	                 (float)luaL_checknumber(L, 3),
-	                 (float)luaL_checknumber(L, 4));
-	const float3 vel((float)luaL_checknumber(L, 5),
-	                 (float)luaL_checknumber(L, 6),
-	                 (float)luaL_checknumber(L, 7));
-	const float3 rot((float)luaL_checknumber(L, 8),
-	                 (float)luaL_checknumber(L, 9),
-	                 (float)luaL_checknumber(L, 10));
+	const float3 pos(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
+	const float3 vel(luaL_checkfloat(L, 5),
+	                 luaL_checkfloat(L, 6),
+	                 luaL_checkfloat(L, 7));
+	const float3 rot(luaL_checkfloat(L, 8),
+	                 luaL_checkfloat(L, 9),
+	                 luaL_checkfloat(L, 10));
 	moveType-&gt;SetPhysics(pos, vel, rot);
 	return 0;
 }
@@ -300,9 +300,9 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	const float3 pos((float)luaL_checknumber(L, 2),
-	                 (float)luaL_checknumber(L, 3),
-	                 (float)luaL_checknumber(L, 4));
+	const float3 pos(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
 	moveType-&gt;SetPosition(pos);
 	return 0;
 }
@@ -314,9 +314,9 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	const float3 vel((float)luaL_checknumber(L, 2),
-	                 (float)luaL_checknumber(L, 3),
-	                 (float)luaL_checknumber(L, 4));
+	const float3 vel(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
 	moveType-&gt;SetVelocity(vel);
 	return 0;
 }
@@ -328,9 +328,9 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	const float3 relVel((float)luaL_checknumber(L, 2),
-	                    (float)luaL_checknumber(L, 3),
-	                    (float)luaL_checknumber(L, 4));
+	const float3 relVel(luaL_checkfloat(L, 2),
+	                    luaL_checkfloat(L, 3),
+	                    luaL_checkfloat(L, 4));
 	moveType-&gt;SetRelativeVelocity(relVel);
 	return 0;
 }
@@ -342,9 +342,9 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	const float3 rot((float)luaL_checknumber(L, 2),
-	                 (float)luaL_checknumber(L, 3),
-	                 (float)luaL_checknumber(L, 4));
+	const float3 rot(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
 	moveType-&gt;SetRotation(rot);
 	return 0;
 }
@@ -356,9 +356,9 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	const float3 rotOff((float)luaL_checknumber(L, 2),
-	                    (float)luaL_checknumber(L, 3),
-	                    (float)luaL_checknumber(L, 4));
+	const float3 rotOff(luaL_checkfloat(L, 2),
+	                    luaL_checkfloat(L, 3),
+	                    luaL_checkfloat(L, 4));
 	moveType-&gt;SetRotationOffset(rotOff);
 	return 0;
 }
@@ -370,9 +370,9 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	const float3 rotVel((float)luaL_checknumber(L, 2),
-	                    (float)luaL_checknumber(L, 3),
-	                    (float)luaL_checknumber(L, 4));
+	const float3 rotVel(luaL_checkfloat(L, 2),
+	                    luaL_checkfloat(L, 3),
+	                    luaL_checkfloat(L, 4));
 	moveType-&gt;SetRotationVelocity(rotVel);
 	return 0;
 }
@@ -428,7 +428,7 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	moveType-&gt;groundOffset = (float)luaL_checknumber(L, 2);
+	moveType-&gt;groundOffset = luaL_checkfloat(L, 2);
 	return 0;
 }
 
@@ -439,7 +439,7 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	moveType-&gt;gravityFactor = (float)luaL_checknumber(L, 2);
+	moveType-&gt;gravityFactor = luaL_checkfloat(L, 2);
 	return 0;
 }
 
@@ -450,7 +450,7 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	moveType-&gt;drag = (float)luaL_checknumber(L, 2);
+	moveType-&gt;drag = luaL_checkfloat(L, 2);
 	return 0;
 }
 
@@ -461,7 +461,7 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	moveType-&gt;windFactor = (float)luaL_checknumber(L, 2);
+	moveType-&gt;windFactor = luaL_checkfloat(L, 2);
 	return 0;
 }
 
@@ -472,12 +472,12 @@
 	if (moveType == NULL) {
 		return 0;
 	}
-	const float3 mins((float)luaL_checknumber(L, 2),
-	                  (float)luaL_checknumber(L, 3),
-	                  (float)luaL_checknumber(L, 4));
-	const float3 maxs((float)luaL_checknumber(L, 5),
-	                  (float)luaL_checknumber(L, 6),
-	                  (float)luaL_checknumber(L, 7));
+	const float3 mins(luaL_checkfloat(L, 2),
+	                  luaL_checkfloat(L, 3),
+	                  luaL_checkfloat(L, 4));
+	const float3 maxs(luaL_checkfloat(L, 5),
+	                  luaL_checkfloat(L, 6),
+	                  luaL_checkfloat(L, 7));
 	moveType-&gt;mins = mins;
 	moveType-&gt;maxs = maxs;
 	return 0;

Modified: trunk/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedRead.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaSyncedRead.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -189,10 +189,12 @@
 	REGISTER_LUA_CFUNC(GetUnitResources);
 	REGISTER_LUA_CFUNC(GetUnitExperience);
 	REGISTER_LUA_CFUNC(GetUnitStates);
+	REGISTER_LUA_CFUNC(GetUnitArmored);
 	REGISTER_LUA_CFUNC(GetUnitIsActive);
 	REGISTER_LUA_CFUNC(GetUnitIsCloaked);
 	REGISTER_LUA_CFUNC(GetUnitSelfDTime);
 	REGISTER_LUA_CFUNC(GetUnitStockpile);
+	REGISTER_LUA_CFUNC(GetUnitSensorRadius);
 	REGISTER_LUA_CFUNC(GetUnitHeight);
 	REGISTER_LUA_CFUNC(GetUnitRadius);
 	REGISTER_LUA_CFUNC(GetUnitPosition);
@@ -205,9 +207,12 @@
 	REGISTER_LUA_CFUNC(GetUnitTransporter);
 	REGISTER_LUA_CFUNC(GetUnitIsTransporting);
 	REGISTER_LUA_CFUNC(GetUnitShieldState);
+	REGISTER_LUA_CFUNC(GetUnitFlanking);
 	REGISTER_LUA_CFUNC(GetUnitWeaponState);
 	REGISTER_LUA_CFUNC(GetUnitTravel);
+	REGISTER_LUA_CFUNC(GetUnitFuel);
 	REGISTER_LUA_CFUNC(GetUnitEstimatedPath);
+	REGISTER_LUA_CFUNC(GetUnitLastAttacker);
 	REGISTER_LUA_CFUNC(GetUnitLosState);
 	REGISTER_LUA_CFUNC(GetUnitSeparation);
 	REGISTER_LUA_CFUNC(GetUnitDefDimensions);
@@ -384,7 +389,7 @@
 			return NULL;
 		}
 	}
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		if (caller != NULL) {
 			luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
@@ -447,7 +452,7 @@
 	if (!lua_isnumber(L, index)) {
 		luaL_error(L, &quot;Bad playerID type in %s()\n&quot;, caller);
 	}
-	const int playerID = (int)lua_tonumber(L, index);
+	const int playerID = lua_toint(L, index);
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		luaL_error(L, &quot;Bad playerID in %s\n&quot;, caller);
 	}
@@ -464,7 +469,7 @@
 	if (!lua_isnumber(L, index)) {
 		luaL_error(L, &quot;Bad teamID type in %s()\n&quot;, caller);
 	}
-	const int teamID = (int)lua_tonumber(L, index);
+	const int teamID = lua_toint(L, index);
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
 		luaL_error(L, &quot;Bad teamID in %s\n&quot;, caller);
 	}
@@ -477,7 +482,7 @@
 	if (!lua_isnumber(L, index)) {
 		luaL_error(L, &quot;Bad teamID type in %s()\n&quot;, caller);
 	}
-	const int teamID = (int)lua_tonumber(L, index);
+	const int teamID = lua_toint(L, index);
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
 		luaL_error(L, &quot;Bad teamID in %s\n&quot;, caller);
 	}
@@ -499,7 +504,7 @@
 	for (int i = 0; i &lt; size; i++) {
 		lua_rawgeti(L, table, (i + 1));
 		if (lua_isnumber(L, -1)) {
-			array[i] = (float)lua_tonumber(L, -1);
+			array[i] = lua_tofloat(L, -1);
 			lua_pop(L, 1);
 		} else {
 			lua_pop(L, 1);
@@ -554,7 +559,7 @@
 	int pIndex = -1;
 
 	if (lua_israwnumber(L, index)) {
-		pIndex = (int)lua_tonumber(L, index) - 1;
+		pIndex = lua_toint(L, index) - 1;
 	}
 	else if (lua_israwstring(L, index)) {
 		const string pName = lua_tostring(L, index);
@@ -623,6 +628,7 @@
 	return 1;
 }
 
+
 int LuaSyncedRead::FixedAllies(lua_State* L)
 {
 	CheckNoArgs(L, __FUNCTION__);
@@ -787,12 +793,8 @@
 
 int LuaSyncedRead::GetHeadingFromVector(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to GetHeadingFromVector()&quot;);
-	}
-	const float x = (float)lua_tonumber(L, 1);
-	const float z = (float)lua_tonumber(L, 2);
+	const float x = luaL_checkfloat(L, 1);
+	const float z = luaL_checkfloat(L, 2);
 	const short int heading = ::GetHeadingFromVector(x, z);
 	lua_pushnumber(L, heading);
 	return 1;
@@ -801,11 +803,7 @@
 
 int LuaSyncedRead::GetVectorFromHeading(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetVectorFromHeading()&quot;);
-	}
-	const short int h = (short int)lua_tonumber(L, 1);
+	const short int h = (short int)luaL_checknumber(L, 1);
 	const float3&amp; vec = ::GetVectorFromHeading(h);
 	lua_pushnumber(L, vec.x);
 	lua_pushnumber(L, vec.z);
@@ -829,7 +827,7 @@
 		return 2;
 	}
 	else if (lua_israwnumber(L, 1)) {
-		const unsigned int index = (int)lua_tonumber(L, 1) - 1;
+		const unsigned int index = lua_toint(L, 1) - 1;
 		if (!sideParser.ValidSide(index)) {
 			return 0;
 		}
@@ -864,12 +862,7 @@
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetAllyTeamStartBox()&quot;);
-	}
-
-	const int allyTeam = (int)lua_tonumber(L, 1);
+	const int allyTeam = (int)luaL_checkint(L, 1);
 	if ((allyTeam &lt; 0) || (allyTeam &gt;= gs-&gt;activeAllyTeams)) {
 		luaL_error(L, &quot;Bad allyTeam (%i) in GetAllyTeamStartBox()&quot;, allyTeam);
 	}
@@ -887,11 +880,6 @@
 
 int LuaSyncedRead::GetTeamStartPosition(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamStartPosition()&quot;);
-	}
-
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
 		return 0;
@@ -936,7 +924,7 @@
 
 	int allyTeamID = -1;
 	if (args == 1) {
-		allyTeamID = (int)lua_tonumber(L, 1);
+		allyTeamID = lua_toint(L, 1);
 		if ((allyTeamID &lt; 0) || (allyTeamID &gt;= gs-&gt;activeAllyTeams)) {
 			return 0;
 		}
@@ -967,7 +955,7 @@
 	bool active = false;
 
 	if (lua_isnumber(L, 1)) {
-		teamID = (int)lua_tonumber(L, 1);
+		teamID = lua_toint(L, 1);
 		if (lua_isboolean(L, 2)) {
 			active = lua_toboolean(L, 2);
 		}
@@ -975,7 +963,7 @@
 	else if (lua_isboolean(L, 1)) {
 		active = lua_toboolean(L, 1);
 		if (lua_isnumber(L, 2)) {
-			teamID = (int)lua_tonumber(L, 2);
+			teamID = lua_toint(L, 2);
 		}
 	}
 
@@ -1010,7 +998,7 @@
 
 int LuaSyncedRead::GetTeamInfo(lua_State* L)
 {
-	const int teamID = (int)luaL_checknumber(L, 1);
+	const int teamID = luaL_checkint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -1038,11 +1026,6 @@
 
 int LuaSyncedRead::GetTeamResources(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isstring(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamResources(teamID, \&quot;type\&quot;)&quot;);
-	}
-
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
 		return 0;
@@ -1053,7 +1036,7 @@
 		return 0;
 	}
 
-	const string type = lua_tostring(L, 2);
+	const string type = luaL_checkstring(L, 2);
 	if (type == &quot;metal&quot;) {
 		lua_pushnumber(L, team-&gt;metal);
 		lua_pushnumber(L, team-&gt;metalStorage);
@@ -1083,11 +1066,6 @@
 
 int LuaSyncedRead::GetTeamUnitStats(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamUnitStats(teamID)&quot;);
-	}
-
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
 		return 0;
@@ -1166,13 +1144,13 @@
 
 	int start = 0;
 	if ((args &gt;= 2) &amp;&amp; lua_isnumber(L, 2)) {
-		start = (int)lua_tonumber(L, 2) - 1;
+		start = lua_toint(L, 2) - 1;
 		start = max(0, min(statCount - 1, start));
 	}
 
 	int end = start;
 	if ((args &gt;= 3) &amp;&amp; lua_isnumber(L, 3)) {
-		end = (int)lua_tonumber(L, 3) - 1;
+		end = lua_toint(L, 3) - 1;
 		end = max(0, min(statCount - 1, end));
 	}
 
@@ -1233,12 +1211,7 @@
 
 int LuaSyncedRead::GetPlayerInfo(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetPlayerInfo(playerID)&quot;);
-	}
-
-	const int playerID = (int)lua_tonumber(L, 1);
+	const int playerID = luaL_checkint(L, 1);
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return 0;
 	}
@@ -1274,12 +1247,7 @@
 #ifndef DIRECT_CONTROL_ALLOWED
 	return 0;
 #else
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetPlayerControlledUnit(playerID)&quot;);
-	}
-
-	const int playerID = (int)lua_tonumber(L, 1);
+	const int playerID = luaL_checkint(L, 1);
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return 0;
 	}
@@ -1294,7 +1262,7 @@
 		return 0;
 	}
 
-	if ((readAllyTeam == CLuaHandle::NoAccessTeam) ||
+	if ((readAllyTeam == CEventClient::NoAccessTeam) ||
 	    ((readAllyTeam &gt;= 0) &amp;&amp; !gs-&gt;Ally(unit-&gt;allyteam, readAllyTeam))) {
 		return 0;
 	}
@@ -1307,12 +1275,8 @@
 
 int LuaSyncedRead::AreTeamsAllied(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, -1) || !lua_isnumber(L, -2)) {
-		luaL_error(L, &quot;Incorrect arguments to AreTeamsAllied(team1, team2)&quot;);
-	}
-	const int team1 = (int)lua_tonumber(L, -1);
-	const int team2 = (int)lua_tonumber(L, -2);
+	const int team1 = (int)luaL_checkint(L, -1);
+	const int team2 = (int)luaL_checkint(L, -2);
 	if ((team1 &lt; 0) || (team1 &gt;= gs-&gt;activeTeams) ||
 	    (team2 &lt; 0) || (team2 &gt;= gs-&gt;activeTeams)) {
 		return 0;
@@ -1324,12 +1288,8 @@
 
 int LuaSyncedRead::ArePlayersAllied(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, -1) || !lua_isnumber(L, -2)) {
-		luaL_error(L, &quot;Incorrect arguments to ArePlayersAllied(p1, p2)&quot;);
-	}
-	const int player1 = (int)lua_tonumber(L, -1);
-	const int player2 = (int)lua_tonumber(L, -2);
+	const int player1 = luaL_checkint(L, -1);
+	const int player2 = luaL_checkint(L, -2);
 	if ((player1 &lt; 0) || (player1 &gt;= MAX_PLAYERS) ||
 	    (player2 &lt; 0) || (player2 &gt;= MAX_PLAYERS)) {
 		return 0;
@@ -1381,15 +1341,10 @@
 
 int LuaSyncedRead::GetTeamUnits(lua_State* L)
 {
-	if (readAllyTeam == CLuaHandle::NoAccessTeam) {
+	if (readAllyTeam == CEventClient::NoAccessTeam) {
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamUnits(teamID)&quot;);
-	}
-
 	// parse the team
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
@@ -1433,15 +1388,10 @@
 
 int LuaSyncedRead::GetTeamUnitsSorted(lua_State* L)
 {
-	if (readAllyTeam == CLuaHandle::NoAccessTeam) {
+	if (readAllyTeam == CEventClient::NoAccessTeam) {
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamUnitsSorted(teamID)&quot;);
-	}
-
 	// parse the team
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
@@ -1506,15 +1456,10 @@
 
 int LuaSyncedRead::GetTeamUnitsCounts(lua_State* L)
 {
-	if (readAllyTeam == CLuaHandle::NoAccessTeam) {
+	if (readAllyTeam == CEventClient::NoAccessTeam) {
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamUnitsCounts(teamID)&quot;);
-	}
-
 	// parse the team
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
@@ -1605,16 +1550,10 @@
 
 int LuaSyncedRead::GetTeamUnitsByDefs(lua_State* L)
 {
-	if (readAllyTeam == CLuaHandle::NoAccessTeam) {
+	if (readAllyTeam == CEventClient::NoAccessTeam) {
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 1) ||
-	    !(lua_isnumber(L, 2) || lua_istable(L, 2))) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamUnitsByDefs()&quot;);
-	}
-
 	// parse the team
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
@@ -1627,7 +1566,7 @@
 	// parse the unitDefs
 	set&lt;int&gt; defs;
 	if (lua_isnumber(L, 2)) {
-		const int unitDefID = (int)lua_tonumber(L, 2);
+		const int unitDefID = lua_toint(L, 2);
 		const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 		InsertSearchUnitDefs(ud, allied, defs);
 	}
@@ -1635,7 +1574,7 @@
 		const int table = 2;
 		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
 			if (!lua_isnumber(L, -1)) {
-				const int unitDefID = (int)lua_tonumber(L, -1);
+				const int unitDefID = lua_toint(L, -1);
 				const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 				InsertSearchUnitDefs(ud, allied, defs);
 			}
@@ -1670,15 +1609,10 @@
 
 int LuaSyncedRead::GetTeamUnitDefCount(lua_State* L)
 {
-	if (readAllyTeam == CLuaHandle::NoAccessTeam) {
+	if (readAllyTeam == CEventClient::NoAccessTeam) {
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamUnitDefCount()&quot;);
-	}
-
 	// parse the team
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
@@ -1687,7 +1621,7 @@
 	const int teamID = team-&gt;teamNum;
 
 	// parse the unitDef
-	const int unitDefID = (int)lua_tonumber(L, 2);
+	const int unitDefID = luaL_checkint(L, 2);
 	const UnitDef* unitDef = unitDefHandler-&gt;GetUnitByID(unitDefID);
 	if (unitDef == NULL) {
 		luaL_error(L, &quot;Bad unitDefID in GetTeamUnitDefCount()&quot;);
@@ -1743,15 +1677,10 @@
 
 int LuaSyncedRead::GetTeamUnitCount(lua_State* L)
 {
-	if (readAllyTeam == CLuaHandle::NoAccessTeam) {
+	if (readAllyTeam == CEventClient::NoAccessTeam) {
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetTeamUnitCount()&quot;);
-	}
-
 	// parse the team
 	const CTeam* team = ParseTeam(L, __FUNCTION__, 1);
 	if (team == NULL) {
@@ -1833,7 +1762,7 @@
 	if (!lua_isnumber(L, index)) {
 		return AllUnits;
 	}
-	const int teamID = (int)lua_tonumber(L, index);
+	const int teamID = lua_toint(L, index);
 	if (fullRead &amp;&amp; (teamID &lt; 0)) {
 		// MyUnits, AllyUnits, and EnemyUnits do not apply to fullRead
 		return AllUnits;
@@ -1849,16 +1778,10 @@
 
 int LuaSyncedRead::GetUnitsInRectangle(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) ||
-	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to GetUnitsInRectangle()&quot;);
-	}
-	const float xmin = (float)lua_tonumber(L, 1);
-	const float zmin = (float)lua_tonumber(L, 2);
-	const float xmax = (float)lua_tonumber(L, 3);
-	const float zmax = (float)lua_tonumber(L, 4);
+	const float xmin = luaL_checkfloat(L, 1);
+	const float zmin = luaL_checkfloat(L, 2);
+	const float xmax = luaL_checkfloat(L, 3);
+	const float zmax = luaL_checkfloat(L, 4);
 
 	const float3 mins(xmin, 0.0f, zmin);
 	const float3 maxs(xmax, 0.0f, zmax);
@@ -1902,19 +1825,12 @@
 
 int LuaSyncedRead::GetUnitsInBox(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 6) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) ||
-	    !lua_isnumber(L, 4) || !lua_isnumber(L, 5) || !lua_isnumber(L, 6)) {
-		luaL_error(L,
-			&quot;Incorrect arguments to GetUnitsInBox(xmin,ymin,zmin, xmax,ymax,zmax&quot;);
-	}
-	const float xmin = (float)lua_tonumber(L, 1);
-	const float ymin = (float)lua_tonumber(L, 2);
-	const float zmin = (float)lua_tonumber(L, 3);
-	const float xmax = (float)lua_tonumber(L, 4);
-	const float ymax = (float)lua_tonumber(L, 5);
-	const float zmax = (float)lua_tonumber(L, 6);
+	const float xmin = luaL_checkfloat(L, 1);
+	const float ymin = luaL_checkfloat(L, 2);
+	const float zmin = luaL_checkfloat(L, 3);
+	const float xmax = luaL_checkfloat(L, 4);
+	const float ymax = luaL_checkfloat(L, 5);
+	const float zmax = luaL_checkfloat(L, 6);
 
 	const float3 mins(xmin, 0.0f, zmin);
 	const float3 maxs(xmax, 0.0f, zmax);
@@ -1962,14 +1878,9 @@
 
 int LuaSyncedRead::GetUnitsInCylinder(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to GetUnitsInCylinder()&quot;);
-	}
-	const float x = (float)lua_tonumber(L, 1);
-	const float z = (float)lua_tonumber(L, 2);
-	const float radius = (float)lua_tonumber(L, 3);
+	const float x      = luaL_checkfloat(L, 1);
+	const float z      = luaL_checkfloat(L, 2);
+	const float radius = luaL_checkfloat(L, 3);
 	const float radSqr = (radius * radius);
 
 	const float3 mins(x - radius, 0.0f, z - radius);
@@ -2021,16 +1932,10 @@
 
 int LuaSyncedRead::GetUnitsInSphere(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) ||
-	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to GetUnitsInSphere()&quot;);
-	}
-	const float x = (float)lua_tonumber(L, 1);
-	const float y = (float)lua_tonumber(L, 2);
-	const float z = (float)lua_tonumber(L, 3);
-	const float radius = (float)lua_tonumber(L, 4);
+	const float x      = luaL_checkfloat(L, 1);
+	const float y      = luaL_checkfloat(L, 2);
+	const float z      = luaL_checkfloat(L, 3);
+	const float radius = luaL_checkfloat(L, 4);
 	const float radSqr = (radius * radius);
 
 	const float3 pos(x, y, z);
@@ -2104,8 +2009,7 @@
 
 int LuaSyncedRead::GetUnitsInPlanes(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_istable(L, 1)) {
+	if (!lua_istable(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to GetUnitsInPlanes()&quot;);
 	}
 
@@ -2240,16 +2144,10 @@
 
 int LuaSyncedRead::GetFeaturesInRectangle(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 4) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) ||
-	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L, &quot;Incorrect arguments to GetFeaturesInRectangle()&quot;);
-	}
-	const float xmin = (float)lua_tonumber(L, 1);
-	const float zmin = (float)lua_tonumber(L, 2);
-	const float xmax = (float)lua_tonumber(L, 3);
-	const float zmax = (float)lua_tonumber(L, 4);
+	const float xmin = luaL_checkfloat(L, 1);
+	const float zmin = luaL_checkfloat(L, 2);
+	const float xmax = luaL_checkfloat(L, 3);
+	const float zmax = luaL_checkfloat(L, 4);
 
 	const float3 mins(xmin, 0.0f, zmin);
 	const float3 maxs(xmax, 0.0f, zmax);
@@ -2338,6 +2236,17 @@
 }
 
 
+int LuaSyncedRead::GetUnitArmored(lua_State* L)
+{
+	CUnit* unit = ParseAllyUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	lua_pushboolean(L, unit-&gt;armoredState);
+	return 1;
+}
+
+
 int LuaSyncedRead::GetUnitIsActive(lua_State* L)
 {
 	CUnit* unit = ParseAllyUnit(L, __FUNCTION__, 1);
@@ -2387,6 +2296,38 @@
 }
 
 
+int LuaSyncedRead::GetUnitSensorRadius(lua_State* L)
+{
+	CUnit* unit = ParseAllyUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	const string key = luaL_checkstring(L, 2);
+
+	const int radarDiv = (SQUARE_SIZE * RADAR_SIZE);
+
+	if (key == &quot;los&quot;) {
+		lua_pushnumber(L, unit-&gt;losRadius * loshandler-&gt;losDiv);
+	} else if (key == &quot;airLos&quot;) {
+		lua_pushnumber(L, unit-&gt;airLosRadius * loshandler-&gt;airDiv);
+	} else if (key == &quot;radar&quot;) {
+		lua_pushnumber(L, unit-&gt;radarRadius * radarDiv);
+	} else if (key == &quot;sonar&quot;) {
+		lua_pushnumber(L, unit-&gt;sonarRadius * radarDiv);
+	} else if (key == &quot;seismic&quot;) {
+		lua_pushnumber(L, unit-&gt;seismicRadius * radarDiv);
+	} else if (key == &quot;radarJammer&quot;) {
+		lua_pushnumber(L, unit-&gt;jammerRadius * radarDiv);
+	} else if (key == &quot;sonarJammer&quot;) {
+		lua_pushnumber(L, unit-&gt;sonarJamRadius * radarDiv);
+	} else {
+		return 0; // unknown sensor type
+	}
+
+	return 1;
+}
+
+
 int LuaSyncedRead::GetUnitTooltip(lua_State* L)
 {
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
@@ -2745,17 +2686,63 @@
 }
 
 
-int LuaSyncedRead::GetUnitWeaponState(lua_State* L)
+int LuaSyncedRead::GetUnitFlanking(lua_State* L)
 {
 	CUnit* unit = ParseAllyUnit(L, __FUNCTION__, 1);
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to GetUnitWeaponState()&quot;);
+	if (lua_israwstring(L, 2)) {
+		const string key = lua_tostring(L, 2);
+		if (key == &quot;mode&quot;) {
+			lua_pushnumber(L, unit-&gt;flankingBonusMode);
+			return 1;
+		}
+		else if (key == &quot;dir&quot;) {
+			lua_pushnumber(L, unit-&gt;flankingBonusDir.x);
+			lua_pushnumber(L, unit-&gt;flankingBonusDir.y);
+			lua_pushnumber(L, unit-&gt;flankingBonusDir.z);
+			return 3;
+		}
+		else if (key == &quot;moveFactor&quot;) {
+			lua_pushnumber(L, unit-&gt;flankingBonusMobilityAdd);
+			return 1;
+		}
+		else if (key == &quot;minDamage&quot;) {
+			lua_pushnumber(L, unit-&gt;flankingBonusAvgDamage -
+												unit-&gt;flankingBonusDifDamage);
+			return 1;
+		}
+		else if (key == &quot;maxDamage&quot;) {
+			lua_pushnumber(L, unit-&gt;flankingBonusAvgDamage +
+												unit-&gt;flankingBonusDifDamage);
+			return 1;
+		}
 	}
-	const int weaponNum = (int)lua_tonumber(L, 2);
+	else if (lua_isnoneornil(L, 2)) {
+		lua_pushnumber(L, unit-&gt;flankingBonusMode);
+		lua_pushnumber(L, unit-&gt;flankingBonusMobilityAdd);
+		lua_pushnumber(L, unit-&gt;flankingBonusAvgDamage - // min
+		                  unit-&gt;flankingBonusDifDamage);
+		lua_pushnumber(L, unit-&gt;flankingBonusAvgDamage + // max
+		                  unit-&gt;flankingBonusDifDamage);
+		lua_pushnumber(L, unit-&gt;flankingBonusDir.x);
+		lua_pushnumber(L, unit-&gt;flankingBonusDir.y);
+		lua_pushnumber(L, unit-&gt;flankingBonusDir.z);
+		return 7;
+	}
+	
+	return 0;
+}
+
+
+int LuaSyncedRead::GetUnitWeaponState(lua_State* L)
+{
+	CUnit* unit = ParseAllyUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	const int weaponNum = luaL_checkint(L, 2);
 	if ((weaponNum &lt; 0) || (weaponNum &gt;= unit-&gt;weapons.size())) {
 		return 0;
 	}
@@ -2781,6 +2768,17 @@
 }
 
 
+int LuaSyncedRead::GetUnitFuel(lua_State* L)
+{
+	CUnit* unit = ParseAllyUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	lua_pushnumber(L, unit-&gt;currentFuel);
+	return 1;
+}
+
+
 int LuaSyncedRead::GetUnitEstimatedPath(lua_State* L)
 {
 	CUnit* unit = ParseAllyUnit(L, __FUNCTION__, 1);
@@ -2829,6 +2827,21 @@
 }
 
 
+int LuaSyncedRead::GetUnitLastAttacker(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	if ((unit-&gt;lastAttacker == NULL) ||
+	    !IsUnitVisible(unit-&gt;lastAttacker)) {
+		return 0;
+	}
+	lua_pushnumber(L, unit-&gt;lastAttacker-&gt;id);
+	return 1;
+}
+
+
 int LuaSyncedRead::GetUnitLosState(lua_State* L)
 {
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
@@ -2849,7 +2862,7 @@
 	const unsigned short losStatus = unit-&gt;losStatus[allyTeam];
 
 	if (fullRead &amp;&amp; lua_isboolean(L, 3) &amp;&amp; lua_toboolean(L, 3)) {
-		lua_pushnumber(L, losStatus);
+		lua_pushnumber(L, losStatus); // return a numberic value
 		return 1;
 	}
 	
@@ -2895,7 +2908,7 @@
 
 	float dist;
 	const int args = lua_gettop(L); // number of arguments
-	if ((args &gt;= 3) &amp;&amp; lua_isboolean(L, 3) &amp;&amp; lua_toboolean(L, 3)) {
+	if (lua_isboolean(L, 3) &amp;&amp; lua_toboolean(L, 3)) {
 		dist = pos1.distance2D(pos2);
 	} else {
 		dist = pos1.distance(pos2);
@@ -2908,11 +2921,7 @@
 
 int LuaSyncedRead::GetUnitDefDimensions(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetUnitDefDimensions()&quot;);
-	}
-	const int unitDefID = (int)lua_tonumber(L, 1);
+	const int unitDefID = luaL_checkint(L, 1);
 	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 	if (ud == NULL) {
 		return 0;
@@ -3020,7 +3029,7 @@
 	// get the desired number of commands to return
 	int count = -1;
 	if (args &gt;= 2) {
- 		count = (int)lua_tonumber(L, 2);
+ 		count = lua_toint(L, 2);
 	}
 	if (count &lt; 0) {
 		count = (int)queue-&gt;size();
@@ -3054,7 +3063,7 @@
 	// get the desired number of commands to return
 	int count = -1;
 	if (args &gt;= 2) {
- 		count = (int)lua_tonumber(L, 2);
+ 		count = lua_toint(L, 2);
 	}
 	if (count &lt; 0) {
 		count = (int)commandQue.size();
@@ -3145,7 +3154,7 @@
 	// get the desired number of commands to return
 	int count = -1;
 	if (args &gt;= 2) {
- 		count = (int)lua_tonumber(L, 2);
+ 		count = lua_toint(L, 2);
 	}
 	if (count &lt; 0) {
 		count = (int)commandQue.size();
@@ -3187,7 +3196,7 @@
 	// get the desired number of commands to return
 	int count = -1;
 	if (args &gt;= 2) {
- 		count = (int)lua_tonumber(L, 2);
+ 		count = lua_toint(L, 2);
 	}
 	if (count &lt; 0) {
 		count = (int)queue-&gt;size();
@@ -3331,7 +3340,7 @@
 	HSTR_PUSH_STRING(L, &quot;tooltip&quot;,     cd.tooltip);
 	HSTR_PUSH_STRING(L, &quot;texture&quot;,     cd.iconname);
 	HSTR_PUSH_STRING(L, &quot;cursor&quot;,      cd.mouseicon);
-	HSTR_PUSH_BOOL(L,   &quot;hidden&quot;,      cd.onlyKey);
+	HSTR_PUSH_BOOL(L,   &quot;hidden&quot;,      cd.hidden);
 	HSTR_PUSH_BOOL(L,   &quot;disabled&quot;,    cd.disabled);
 	HSTR_PUSH_BOOL(L,   &quot;showUnique&quot;,  cd.showUnique);
 	HSTR_PUSH_BOOL(L,   &quot;onlyTexture&quot;, cd.onlyTexture);
@@ -3362,10 +3371,10 @@
 	int startIndex = 0;
 	int endIndex = lastDesc;
 	if ((args &gt;= 2) &amp;&amp; lua_isnumber(L, 2)) {
-		startIndex = (int)lua_tonumber(L, 2) - 1;
+		startIndex = lua_toint(L, 2) - 1;
 		startIndex = max(0, min(lastDesc, startIndex));
 		if ((args &gt;= 3) &amp;&amp; lua_isnumber(L, 3)) {
-			endIndex = (int)lua_tonumber(L, 3) - 1;
+			endIndex = lua_toint(L, 3) - 1;
 			endIndex = max(0, min(lastDesc, endIndex));
 		} else {
 			endIndex = startIndex;
@@ -3391,11 +3400,7 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to FindUnitCmdDesc()&quot;);
-	}
-	const int cmdID = (int)lua_tonumber(L, 2);
+	const int cmdID = luaL_checkint(L, 2);
 
 	vector&lt;CommandDescription&gt;&amp; cmdDescs = unit-&gt;commandAI-&gt;possibleCommands;
 	for (int i = 0; i &lt; (int)cmdDescs.size(); i++) {
@@ -3429,15 +3434,14 @@
 
 static CFeature* ParseFeature(lua_State* L, const char* caller, int index)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isnumber(L, index)) {
+	if (!lua_isnumber(L, index)) {
 		if (caller != NULL) {
 			luaL_error(L, &quot;Incorrect arguments to %s(featureID)&quot;, caller);
 		} else {
 			return NULL;
 		}
 	}
-	const int featureID = (int)lua_tonumber(L, index);
+	const int featureID = lua_toint(L, index);
 	const CFeatureSet&amp; fset = featureHandler-&gt;GetActiveFeatures();
 	CFeatureSet::const_iterator it = fset.find(featureID);
 
@@ -3734,8 +3738,8 @@
 
 int LuaSyncedRead::GetGroundHeight(lua_State* L)
 {
-	const float x = (float)luaL_checknumber(L, 1);
-	const float z = (float)luaL_checknumber(L, 2);
+	const float x = luaL_checkfloat(L, 1);
+	const float z = luaL_checkfloat(L, 2);
 	// GetHeight2() does not clamp the value to (&gt;= 0)
 	lua_pushnumber(L, ground-&gt;GetHeight2(x, z));
 	return 1;
@@ -3744,8 +3748,8 @@
 
 int LuaSyncedRead::GetGroundOrigHeight(lua_State* L)
 {
-	const float x = (float)luaL_checknumber(L, 1);
-	const float z = (float)luaL_checknumber(L, 2);
+	const float x = luaL_checkfloat(L, 1);
+	const float z = luaL_checkfloat(L, 2);
 	lua_pushnumber(L, ground-&gt;GetOrigHeight(x, z));
 	return 1;
 }
@@ -3753,8 +3757,8 @@
 
 int LuaSyncedRead::GetGroundNormal(lua_State* L)
 {
-	const float x = (float)luaL_checknumber(L, 1);
-	const float z = (float)luaL_checknumber(L, 2);
+	const float x = luaL_checkfloat(L, 1);
+	const float z = luaL_checkfloat(L, 2);
 	const float3 normal = ground-&gt;GetSmoothNormal(x, z);
 	lua_pushnumber(L, normal.x);
 	lua_pushnumber(L, normal.y);
@@ -3765,8 +3769,8 @@
 
 int LuaSyncedRead::GetGroundInfo(lua_State* L)
 {
-	const float x = (float)luaL_checknumber(L, 1);
-	const float z = (float)luaL_checknumber(L, 2);
+	const float x = luaL_checkfloat(L, 1);
+	const float z = luaL_checkfloat(L, 2);
 
 	const int ix = (int)(max(0.0f, min(float3::maxxpos, x)) / 16.0f);
 	const int iz = (int)(max(0.0f, min(float3::maxzpos, z)) / 16.0f);
@@ -3798,14 +3802,14 @@
 
 	const int args = lua_gettop(L); // number of arguments
 	if (args == 2) {
-		fx1 = fx2 = (float)luaL_checknumber(L, 1);
-		fz1 = fz2 = (float)luaL_checknumber(L, 2);
+		fx1 = fx2 = luaL_checkfloat(L, 1);
+		fz1 = fz2 = luaL_checkfloat(L, 2);
 	}
 	else if (args == 4) {
-		fx1 = (float)luaL_checknumber(L, 1);
-		fz1 = (float)luaL_checknumber(L, 2);
-		fx2 = (float)luaL_checknumber(L, 3);
-		fz2 = (float)luaL_checknumber(L, 4);
+		fx1 = luaL_checkfloat(L, 1);
+		fz1 = luaL_checkfloat(L, 2);
+		fx2 = luaL_checkfloat(L, 3);
+		fz2 = luaL_checkfloat(L, 4);
 	}
 	else {
 		luaL_error(L, &quot;Incorrect arguments to %s()&quot;, caller);
@@ -3878,15 +3882,19 @@
 static int ParseFacing(lua_State* L, const char* caller, int index)
 {
 	// FIXME -- duplicate in LuaSyncedCtrl.cpp
-	if (lua_isnumber(L, index)) {
-		return max(0, min(3, (int)lua_tonumber(L, index)));
+	if (lua_israwnumber(L, index)) {
+		return max(0, min(3, lua_toint(L, index)));
 	}
-	else if (lua_isstring(L, index)) {
+	else if (lua_israwstring(L, index)) {
 		const string dir = StringToLower(lua_tostring(L, index));
 		if (dir == &quot;s&quot;) { return 0; }
 		if (dir == &quot;e&quot;) { return 1; }
 		if (dir == &quot;n&quot;) { return 2; }
 		if (dir == &quot;w&quot;) { return 3; }
+		if (dir == &quot;south&quot;) { return 0; }
+		if (dir == &quot;east&quot;)  { return 1; }
+		if (dir == &quot;north&quot;) { return 2; }
+		if (dir == &quot;west&quot;)  { return 3; }
 		luaL_error(L, &quot;%s(): bad facing string&quot;, caller);
 	}
 	luaL_error(L, &quot;%s(): bad facing parameter&quot;, caller);
@@ -3896,13 +3904,7 @@
 
 int LuaSyncedRead::TestBuildOrder(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 5) || !lua_isnumber(L, 1) ||
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L,
-			&quot;Incorrect arguments to TestBuildOrder(unitDefID, x, y, z, facing&quot;);
-	}
-	const int unitDefID = (int)lua_tonumber(L, 1);
+	const int unitDefID = luaL_checkint(L, 1);
 	if ((unitDefID &lt; 0) || (unitDefID &gt; unitDefHandler-&gt;numUnitDefs)) {
 		lua_pushboolean(L, 0);
 		return 1;
@@ -3913,9 +3915,9 @@
 		return 1;
 	}
 
-	const float3 pos((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
+	const float3 pos(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
 	const int facing = ParseFacing(L, __FUNCTION__, 5);
 
 	BuildInfo bi;
@@ -3946,20 +3948,14 @@
 
 int LuaSyncedRead::Pos2BuildPos(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 4) || !lua_isnumber(L, 1) ||
-	    !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
-		luaL_error(L,
-			&quot;Incorrect arguments to Pos2BuildPos(unitDefID, x, y, z)&quot;);
-	}
-	const int unitDefID = (int)lua_tonumber(L, 1);
+	const int unitDefID = luaL_checkint(L, 1);
 	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 	if (ud == NULL) {
 		return 0;
 	}
-	const float3 pos((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
+	const float3 pos(luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3),
+	                 luaL_checkfloat(L, 4));
 
 	const float3 buildPos = helper-&gt;Pos2BuildPos(pos, ud);
 
@@ -3999,9 +3995,9 @@
 
 int LuaSyncedRead::GetPositionLosState(lua_State* L)
 {
-	const float3 pos((float)luaL_checknumber(L, 1),
-	                 (float)luaL_checknumber(L, 2),
-	                 (float)luaL_checknumber(L, 3));
+	const float3 pos(luaL_checkfloat(L, 1),
+	                 luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3));
 
 	const int allyTeamID = GetEffectiveLosAllyTeam(L, 4);
 
@@ -4036,9 +4032,9 @@
 
 int LuaSyncedRead::IsPosInLos(lua_State* L)
 {
-	const float3 pos((float)luaL_checknumber(L, 1),
-	                 (float)luaL_checknumber(L, 2),
-	                 (float)luaL_checknumber(L, 3));
+	const float3 pos(luaL_checkfloat(L, 1),
+	                 luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3));
 
 	const int allyTeamID = GetEffectiveLosAllyTeam(L, 4);
 
@@ -4062,9 +4058,9 @@
 
 int LuaSyncedRead::IsPosInRadar(lua_State* L)
 {
-	const float3 pos((float)luaL_checknumber(L, 1),
-	                 (float)luaL_checknumber(L, 2),
-	                 (float)luaL_checknumber(L, 3));
+	const float3 pos(luaL_checkfloat(L, 1),
+	                 luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3));
 
 	const int allyTeamID = GetEffectiveLosAllyTeam(L, 4);
 
@@ -4088,9 +4084,9 @@
 
 int LuaSyncedRead::IsPosInAirLos(lua_State* L)
 {
-	const float3 pos((float)luaL_checknumber(L, 1),
-	                 (float)luaL_checknumber(L, 2),
-	                 (float)luaL_checknumber(L, 3));
+	const float3 pos(luaL_checkfloat(L, 1),
+	                 luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3));
 
 	const int allyTeamID = GetEffectiveLosAllyTeam(L, 4);
 
@@ -4117,10 +4113,10 @@
 int LuaSyncedRead::GetClosestValidPosition(lua_State* L)
 {
 	// FIXME -- finish this
-	const int unitDefID = (int)luaL_checknumber(L, 1);
-	const float x     = (float)luaL_checknumber(L, 2);
-	const float z     = (float)luaL_checknumber(L, 3);
-	const float r     = (float)luaL_checknumber(L, 4);
+	const int unitDefID = luaL_checkint(L, 1);
+	const float x     = luaL_checkfloat(L, 2);
+	const float z     = luaL_checkfloat(L, 3);
+	const float r     = luaL_checkfloat(L, 4);
 	const int mx = (int)max(0 , min(gs-&gt;mapx - 1, (int)(x / SQUARE_SIZE)));
 	const int mz = (int)max(0 , min(gs-&gt;mapy - 1, (int)(z / SQUARE_SIZE)));
 	return 0;
@@ -4222,7 +4218,7 @@
 	}
 	const LocalS3DOModel* localModel = unit-&gt;localmodel;
 
-	const int piece = (int)luaL_checknumber(L, 2) - 1;
+	const int piece = luaL_checkint(L, 2) - 1;
 	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
 		return 0;
 	}
@@ -4251,7 +4247,7 @@
 	if (localModel == NULL) {
 		return 0;
 	}
-	const int piece = (int)luaL_checknumber(L, 2) - 1;
+	const int piece = luaL_checkint(L, 2) - 1;
 	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
 		return 0;
 	}
@@ -4273,7 +4269,7 @@
 	if (localModel == NULL) {
 		return 0;
 	}
-	const int piece = (int)luaL_checknumber(L, 2) - 1;
+	const int piece = luaL_checkint(L, 2) - 1;
 	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
 		return 0;
 	}
@@ -4306,7 +4302,7 @@
 	if (localModel == NULL) {
 		return 0;
 	}
-	const int piece = (int)luaL_checknumber(L, 2) - 1;
+	const int piece = luaL_checkint(L, 2) - 1;
 	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
 		return 0;
 	}
@@ -4328,7 +4324,7 @@
 	if (localModel == NULL) {
 		return 0;
 	}
-	const int piece = (int)luaL_checknumber(L, 2) - 1;
+	const int piece = luaL_checkint(L, 2) - 1;
 	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
 		return 0;
 	}
@@ -4365,7 +4361,7 @@
 		return 1;
 	}
 
-	const int scriptPiece = (int)lua_tonumber(L, 2);
+	const int scriptPiece = lua_toint(L, 2);
 	const int piece = localModel-&gt;ScriptToArray(scriptPiece);
 	if (piece &lt; 0) {
 		return 0;

Modified: trunk/rts/Lua/LuaSyncedRead.h
===================================================================
--- trunk/rts/Lua/LuaSyncedRead.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaSyncedRead.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -97,10 +97,12 @@
 		static int GetUnitResources(lua_State* L);
 		static int GetUnitExperience(lua_State* L);
 		static int GetUnitStates(lua_State* L);
+		static int GetUnitArmored(lua_State* L);
 		static int GetUnitIsActive(lua_State* L);
 		static int GetUnitIsCloaked(lua_State* L);
 		static int GetUnitSelfDTime(lua_State* L);
 		static int GetUnitStockpile(lua_State* L);
+		static int GetUnitSensorRadius(lua_State* L);
 		static int GetUnitHeight(lua_State* L);
 		static int GetUnitRadius(lua_State* L);
 		static int GetUnitPosition(lua_State* L);
@@ -113,9 +115,12 @@
 		static int GetUnitTransporter(lua_State* L);
 		static int GetUnitIsTransporting(lua_State* L);
 		static int GetUnitShieldState(lua_State* L);
+		static int GetUnitFlanking(lua_State* L);
 		static int GetUnitWeaponState(lua_State* L);
 		static int GetUnitTravel(lua_State* L);
+		static int GetUnitFuel(lua_State* L);
 		static int GetUnitEstimatedPath(lua_State* L);
+		static int GetUnitLastAttacker(lua_State* L);
 
 		static int GetUnitCommands(lua_State* L);
 		static int GetFactoryCounts(lua_State* L);

Modified: trunk/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaUnitDefs.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaUnitDefs.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -37,7 +37,7 @@
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
-#include &quot;Sim/Units/UnitImage.h&quot;
+#include &quot;Sim/Units/UnitDefImage.h&quot;
 #include &quot;Sim/Units/UnitTypes/Builder.h&quot;
 #include &quot;Sim/Units/UnitTypes/Factory.h&quot;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
@@ -235,7 +235,7 @@
 			return 0;
 		}
 		case INT_TYPE: {
-			*((int*)p) = (int)lua_tonumber(L, -1);
+			*((int*)p) = lua_toint(L, -1);
 			return 0;
 		}
 		case BOOL_TYPE: {
@@ -243,7 +243,7 @@
 			return 0;
 		}
 		case FLOAT_TYPE: {
-			*((float*)p) = (float)lua_tonumber(L, -1);
+			*((float*)p) = lua_tofloat(L, -1);
 			return 0;
 		}
 		case STRING_TYPE: {
@@ -669,7 +669,7 @@
 	ADD_STRING(&quot;deathExplosion&quot;, ud.deathExplosion);
 	ADD_STRING(&quot;selfDExplosion&quot;, ud.selfDExplosion);
 
-	ADD_STRING(&quot;buildpicname&quot;, ud.unitImage-&gt;buildPicName);
+	ADD_STRING(&quot;buildpicname&quot;, ud.buildPicName);
 
 	ADD_INT(&quot;aihint&quot;, ud.aihint);
 	ADD_INT(&quot;cobID&quot;,  ud.cobID);
@@ -846,7 +846,7 @@
 	ADD_FLOAT(&quot;transportMass&quot;,         ud.transportMass);
 	ADD_FLOAT(&quot;loadingRadius&quot;,         ud.loadingRadius);
 	ADD_BOOL( &quot;isAirBase&quot;,             ud.isAirBase);
-	ADD_BOOL( &quot;isFirePlatform&quot;,        ud.isfireplatform);
+	ADD_BOOL( &quot;isFirePlatform&quot;,        ud.isFirePlatform);
 	ADD_BOOL( &quot;holdSteady&quot;,            ud.holdSteady);
 	ADD_BOOL( &quot;releaseHeld&quot;,           ud.releaseHeld);
 	ADD_BOOL( &quot;transportByEnemy&quot;,      ud.transportByEnemy);

Modified: trunk/rts/Lua/LuaUnitRendering.cpp
===================================================================
--- trunk/rts/Lua/LuaUnitRendering.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaUnitRendering.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -81,7 +81,7 @@
 			return NULL;
 		}
 	}
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
 	}
@@ -122,7 +122,7 @@
 	if (lod &gt;= unit-&gt;lodCount) {
 		return 0;
 	}
-	const float lpp = (float)luaL_checknumber(L, 3);
+	const float lpp = luaL_checkfloat(L, 3);
 	unit-&gt;lodLengths[lod] = lpp;
 	return 0;
 }
@@ -139,7 +139,7 @@
 	}
 	// adjusted for 45 degree FOV with a 1024x768 screen
 	const float scale = 2.0f * (float)streflop::tanf((45.0 * 0.5) * (PI / 180.0)) / 768.0f;
-	const float dist = (float)luaL_checknumber(L, 3);
+	const float dist = luaL_checkfloat(L, 3);
 	unit-&gt;lodLengths[lod] = dist * scale;
 	return 0;
 }
@@ -304,7 +304,7 @@
 		if (ud == NULL) {
 			return;
 		}
-		texID = unitDefHandler-&gt;GetUnitImage(ud);
+		texID = unitDefHandler-&gt;GetUnitDefImage(ud);
 	}
 	else if (image[0] == LuaTextures::prefix) {
 		// dynamic texture
@@ -409,7 +409,7 @@
 		}
 		const string key = StringToLower(lua_tostring(L, -2));
 		if (key == &quot;order&quot;) {
-			mat.order = (int)luaL_checknumber(L, -1);
+			mat.order = luaL_checkint(L, -1);
 		}
 		else if (key == &quot;shader&quot;) {
 			ParseShader(L, caller, -1, mat.shader);
@@ -419,7 +419,7 @@
 			  const int texTable = (int)lua_gettop(L);
 				for (lua_pushnil(L); lua_next(L, texTable) != 0; lua_pop(L, 1)) {
 					if (lua_israwnumber(L, -2)) {
-						const int texUnit = (int)lua_tonumber(L, -2);
+						const int texUnit = lua_toint(L, -2);
 						if ((texUnit &gt;= 0) &amp;&amp; (texUnit &lt; LuaMatTexture::maxTexUnits)) {
 							ParseTexture(L, caller, -1, mat.textures[texUnit]);
 						}
@@ -624,7 +624,7 @@
 
 int LuaUnitRendering::SetUnitLuaDraw(lua_State* L)
 {
-	const int unitID = (int)luaL_checknumber(L, 1);
+	const int unitID = luaL_checkint(L, 1);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		return 0;
 	}

Modified: trunk/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -20,6 +20,7 @@
 #include &quot;LuaHandle.h&quot;
 #include &quot;LuaHashString.h&quot;
 #include &quot;LuaUtils.h&quot;
+#include &quot;LuaTextures.h&quot;
 
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;ExternalAI/Group.h&quot;
@@ -166,6 +167,7 @@
 	REGISTER_LUA_CFUNC(SetLosViewColors);
 
 	REGISTER_LUA_CFUNC(SetUnitDefIcon);
+	REGISTER_LUA_CFUNC(SetUnitDefImage);
 
 	REGISTER_LUA_CFUNC(SetUnitGroup);
 
@@ -212,7 +214,7 @@
 {
 	const int ctrlTeam = CtrlTeam();
 	if (ctrlTeam &lt; 0) {
-		return (ctrlTeam == CLuaHandle::AllAccessTeam) ? true : false;
+		return (ctrlTeam == CEventClient::AllAccessTeam) ? true : false;
 	}
 	return (ctrlTeam == team);
 }
@@ -222,7 +224,7 @@
 {
 	const int ctrlTeam = CtrlTeam();
 	if (ctrlTeam &lt; 0) {
-		return (ctrlTeam == CLuaHandle::AllAccessTeam) ? true : false;
+		return (ctrlTeam == CEventClient::AllAccessTeam) ? true : false;
 	}
 	return (gs-&gt;AllyTeam(ctrlTeam) == allyteam);
 }
@@ -243,7 +245,7 @@
 			return NULL;
 		}
 	}
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
 	}
@@ -288,7 +290,7 @@
 	}
 	const int selectTeam = CLuaHandle::GetActiveHandle()-&gt;GetSelectTeam();
 	if (selectTeam &lt; 0) {
-		return (selectTeam == CLuaHandle::AllAccessTeam) ? unit : NULL;
+		return (selectTeam == CEventClient::AllAccessTeam) ? unit : NULL;
 	}
 	if (selectTeam == unit-&gt;team) {
 		return unit;
@@ -419,7 +421,7 @@
 	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isstring(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SendMessageToPlayer()&quot;);
 	}
-	const int playerID = (int)lua_tonumber(L, 1);
+	const int playerID = lua_toint(L, 1);
 	if (playerID == gu-&gt;myPlayerNum) {
 		PrintMessage(L, lua_tostring(L, 2));
 	}
@@ -433,7 +435,7 @@
 	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isstring(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SendMessageToTeam()&quot;);
 	}
-	const int teamID = (int)lua_tonumber(L, 1);
+	const int teamID = lua_toint(L, 1);
 	if (teamID == gu-&gt;myTeam) {
 		PrintMessage(L, lua_tostring(L, 2));
 	}
@@ -447,7 +449,7 @@
 	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isstring(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SendMessageToAllyTeam()&quot;);
 	}
-	const int allyTeamID = (int)lua_tonumber(L, 1);
+	const int allyTeamID = lua_toint(L, 1);
 	if (allyTeamID == gu-&gt;myAllyTeam) {
 		PrintMessage(L, lua_tostring(L, 2));
 	}
@@ -469,15 +471,15 @@
 	if (soundID &gt; 0) {
 		float volume = 1.0f;
 		if (args &gt;= 2) {
-			volume = (float)lua_tonumber(L, 2);
+			volume = lua_tofloat(L, 2);
 		}
 
 		if (args &lt; 5) {
 			sound-&gt;PlaySample(soundID, volume);
 		} else {
-			const float3 pos((float)lua_tonumber(L, 3),
-			                 (float)lua_tonumber(L, 4),
-			                 (float)lua_tonumber(L, 5));
+			const float3 pos(lua_tofloat(L, 3),
+			                 lua_tofloat(L, 4),
+			                 lua_tofloat(L, 5));
 			sound-&gt;PlaySample(soundID, pos, volume);
 		}
 		success = true;
@@ -503,9 +505,9 @@
 		sound-&gt;PlayStream(soundFile, volume);
 	}
 	else {
-		const float3 pos((float) lua_tonumber(L, 3),
-						 (float) lua_tonumber(L, 4),
-						 (float) lua_tonumber(L, 5));
+		const float3 pos(luaL_checkfloat(L, 3),
+		                 luaL_checkfloat(L, 4),
+		                 luaL_checkfloat(L, 5));
 		sound-&gt;PlayStream(soundFile, volume, pos);
 	}
 
@@ -557,10 +559,10 @@
 	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4)) {
 		luaL_error(L, &quot;Incorrect arguments to AddWorldIcon(id, x, y, z&quot;);
 	}
-	const int cmdID = (int)lua_tonumber(L, 1);
-	const float3 pos((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
+	const int cmdID = lua_toint(L, 1);
+	const float3 pos(lua_tofloat(L, 2),
+	                 lua_tofloat(L, 3),
+	                 lua_tofloat(L, 4));
 	cursorIcons.AddIcon(cmdID, pos);
 	return 0;
 }
@@ -575,9 +577,9 @@
 		luaL_error(L, &quot;Incorrect arguments to AddWorldIcon(text, x, y, z&quot;);
 	}
 	const string text = lua_tostring(L, 1);
-	const float3 pos((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
+	const float3 pos(lua_tofloat(L, 2),
+	                 lua_tofloat(L, 3),
+	                 lua_tofloat(L, 4));
 	cursorIcons.AddIconText(text, pos);
 	return 0;
 }
@@ -593,18 +595,18 @@
 		luaL_error(L,
 			&quot;Incorrect arguments to AddWorldUnit(unitDefID, x, y, z, team, facing)&quot;);
 	}
-	const int unitDefID = (int)lua_tonumber(L, 1);
+	const int unitDefID = lua_toint(L, 1);
 	if ((unitDefID &lt; 0) || (unitDefID &gt; unitDefHandler-&gt;numUnitDefs)) {
 		return 0;
 	}
-	const float3 pos((float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3),
-	                 (float)lua_tonumber(L, 4));
-	const int team = (int)lua_tonumber(L, 5);
+	const float3 pos(lua_tofloat(L, 2),
+	                 lua_tofloat(L, 3),
+	                 lua_tofloat(L, 4));
+	const int team = lua_toint(L, 5);
 	if ((team &lt; 0) || (team &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
-	const int facing = (int)lua_tonumber(L, 6);
+	const int facing = lua_toint(L, 6);
 	cursorIcons.AddBuildIcon(-unitDefID, pos, team, facing);
 	return 0;
 }
@@ -648,13 +650,13 @@
 	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
 		luaL_error(L, &quot;Incorrect arguments to SetCameraTarget(x, y, z)&quot;);
 	}
-	const float3 pos((float)lua_tonumber(L, 1),
-	                 (float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3));
+	const float3 pos(lua_tofloat(L, 1),
+	                 lua_tofloat(L, 2),
+	                 lua_tofloat(L, 3));
 
 	float transTime = 0.5f;
 	if ((args &gt;= 4) &amp;&amp; lua_isnumber(L, 4)) {
-		transTime = (float)lua_tonumber(L, 4);
+		transTime = lua_tofloat(L, 4);
 	}
 
 	camHandler-&gt;GetCurrentController().SetPos(pos);
@@ -674,7 +676,7 @@
 		luaL_error(L, &quot;Incorrect arguments to SetCameraState(table, camTime)&quot;);
 	}
 
-	const float camTime = (float)luaL_checknumber(L, 2);
+	const float camTime = luaL_checkfloat(L, 2);
 	
 	CCameraController::StateMap camState;
 
@@ -683,7 +685,7 @@
 		if (lua_israwstring(L, -2)) {
 			const string key = lua_tostring(L, -2);
 			if (lua_isnumber(L, -1)) {
-				camState[key] = (float)lua_tonumber(L, -1);
+				camState[key] = lua_tofloat(L, -1);
 			}
 			else if (lua_isboolean(L, -1)) {
 				camState[key] = lua_toboolean(L, -1) ? +1.0f : -1.0f;
@@ -764,7 +766,7 @@
 {
 	// FIXME: doesn't work for 3DO team textures
 	//        doesn't play nicely with cached team color (in scripts, etc...)
-	const int teamID = (int)luaL_checknumber(L, 1);
+	const int teamID = luaL_checkint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
 		return 0;
 	}
@@ -840,11 +842,11 @@
 
 int LuaUnsyncedCtrl::SetCustomCommandDrawData(lua_State* L)
 {
-	const int cmdID = (int)luaL_checknumber(L, 1);
+	const int cmdID = luaL_checkint(L, 1);
 
 	int iconID = 0;
 	if (lua_israwnumber(L, 2)) {
-		iconID = (int)lua_tonumber(L, 2);
+		iconID = lua_toint(L, 2);
 	}
 	else if (lua_israwstring(L, 2)) {
 		iconID = cmdID;
@@ -867,7 +869,7 @@
 		for (int i = 0; i &lt; 4; i++) {
 			lua_rawgeti(L, table, i + 1);
 			if (lua_israwnumber(L, -1)) {
-				color[i] = (float)lua_tonumber(L, -1);
+				color[i] = lua_tofloat(L, -1);
 				lua_pop(L, 1);
 			} else {
 				lua_pop(L, 1);
@@ -1156,10 +1158,10 @@
 		return 0;
 	}
 	const int args = lua_gettop(L); // number of arguments
-	const int cmdIndex = (int)lua_tonumber(L, 1) - CMD_INDEX_OFFSET;
+	const int cmdIndex = lua_toint(L, 1) - CMD_INDEX_OFFSET;
 	int button = 1; // LMB
 	if ((args &gt;= 2) &amp;&amp; lua_isnumber(L, 2)) {
-		button = (int)lua_tonumber(L, 2);
+		button = lua_toint(L, 2);
 	}
 
 	if (args &lt;= 2) {
@@ -1258,8 +1260,8 @@
 	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to WarpMouse()&quot;);
 	}
-	const int x = (int)lua_tonumber(L, 1);
-	const int y = gu-&gt;viewSizeY - (int)lua_tonumber(L, 2) - 1;
+	const int x = lua_toint(L, 1);
+	const int y = gu-&gt;viewSizeY - lua_toint(L, 2) - 1;
 	mouse-&gt;WarpMouse(x, y);
 	return 0;
 }
@@ -1270,14 +1272,8 @@
 	if (!CheckModUICtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isstring(L, 1) ||
-	    ((args &gt;= 2) &amp;&amp; !lua_isnumber(L, 2))) {
-		luaL_error(L,
-			&quot;Incorrect arguments to SetMouseCursor(\&quot;name\&quot;, [scale])&quot;);
-	}
-	mouse-&gt;cursorText = lua_tostring(L, 1);
-	if (args &gt;= 2) {
+	mouse-&gt;SetCursor(luaL_checkstring(L, 1));
+	if (lua_israwnumber(L, 2)) {
 		mouse-&gt;cursorScale = lua_tonumber(L, 2);
 	}
 	return 0;
@@ -1294,12 +1290,12 @@
 	if (camera == NULL) {
 		return 0;
 	}
-	const float px = (float)luaL_optnumber(L, 1, 0.0f);
-	const float py = (float)luaL_optnumber(L, 2, 0.0f);
-	const float pz = (float)luaL_optnumber(L, 3, 0.0f);
-	const float tx = (float)luaL_optnumber(L, 4, 0.0f);
-	const float ty = (float)luaL_optnumber(L, 5, 0.0f);
-	const float tz = (float)luaL_optnumber(L, 6, 0.0f);
+	const float px = luaL_optfloat(L, 1, 0.0f);
+	const float py = luaL_optfloat(L, 2, 0.0f);
+	const float pz = luaL_optfloat(L, 3, 0.0f);
+	const float tx = luaL_optfloat(L, 4, 0.0f);
+	const float ty = luaL_optfloat(L, 5, 0.0f);
+	const float tz = luaL_optfloat(L, 6, 0.0f);
 	camera-&gt;posOffset = float3(px, py, pz);
 	camera-&gt;tiltOffset = float3(tx, ty, tz);
 	return 0;
@@ -1317,7 +1313,7 @@
 	for (int i = 0; i &lt; size; i++) {
 		lua_rawgeti(L, table, (i + 1));
 		if (lua_isnumber(L, -1)) {
-			array[i] = (float)lua_tonumber(L, -1);
+			array[i] = lua_tofloat(L, -1);
 			lua_pop(L, 1);
 		} else {
 			lua_pop(L, 1);
@@ -1364,16 +1360,8 @@
 	if (!CheckModUICtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || (args &gt; 2) || !lua_isstring(L, 1) ||
-	    ((args == 2) &amp;&amp; !lua_isnumber(L, 2))) {
-		luaL_error(L, &quot;Incorrect arguments to GetConfigInt()&quot;);
-	}
-	const string name = lua_tostring(L, 1);
-	int def = 0;
-	if (args == 2) {
-		def = (int)lua_tonumber(L, 2);
-	}
+	const string name = luaL_checkstring(L, 1);
+	const int def     = luaL_optint(L, 2, 0);
 	const int value = configHandler.GetInt(name, def);
 	lua_pushnumber(L, value);
 	return 1;
@@ -1385,12 +1373,8 @@
 	if (!CheckModUICtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isstring(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetConfigInt()&quot;);
-	}
-	const string name = lua_tostring(L, 1);
-	const int value = (int)lua_tonumber(L, 2);
+	const string name = luaL_checkstring(L, 1);
+	const int value   = luaL_checkint(L, 2);
 	configHandler.SetInt(name, value);
 	return 0;
 }
@@ -1401,16 +1385,8 @@
 	if (!CheckModUICtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || (args &gt; 2) || !lua_isstring(L, 1) ||
-	    ((args == 2) &amp;&amp; !lua_isstring(L, 2))) {
-		luaL_error(L, &quot;Incorrect arguments to GetConfigString()&quot;);
-	}
-	const string name = lua_tostring(L, 1);
-	string def;
-	if (args == 2) {
-		def = lua_tostring(L, 2);
-	}
+	const string name = luaL_checkstring(L, 1);
+	const string def  = luaL_optstring(L, 2, &quot;&quot;);
 	const string value = configHandler.GetString(name, def);
 	lua_pushstring(L, value.c_str());
 	return 1;
@@ -1422,12 +1398,8 @@
 	if (!CheckModUICtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isstring(L, 1) || !lua_isstring(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetConfigString()&quot;);
-	}
-	const string name = lua_tostring(L, 1);
-	const string value = lua_tostring(L, 2);
+	const string name  = luaL_checkstring(L, 1);
+	const string value = luaL_checkstring(L, 2);
 	configHandler.SetString(name, value);
 	return 0;
 }
@@ -1440,19 +1412,14 @@
 	if (!CheckModUICtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isstring(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to CreateDir()&quot;);
-	}
+	const string dir = luaL_checkstring(L, 1);
 
 	// keep directories within the Spring directory
-	const string dir = lua_tostring(L, 1);
 	if ((dir[0] == '/') || (dir[0] == '\\') ||
 	    (strstr(dir.c_str(), &quot;..&quot;) != NULL) ||
 	    ((dir.size() &gt; 0) &amp;&amp; (dir[1] == ':'))) {
 		luaL_error(L, &quot;Invalid CreateDir() access: %s&quot;, dir.c_str());
 	}
-
 	const bool success = filesystem.CreateDirectory(dir);
 	lua_pushboolean(L, success);
 	return 1;
@@ -1466,21 +1433,30 @@
 	if (!CheckModUICtrl()) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isstring(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to MakeFont()&quot;);
+
+	int tableIndex = 1;
+	string inputFile;
+	string inputData;
+	if (lua_israwstring(L, 1)) {
+		inputFile = lua_tostring(L, 1);
+		tableIndex++;
 	}
+
 	FontTexture::Reset();
-	FontTexture::SetInFileName(lua_tostring(L, 1));
-	if ((args &gt;= 2) &amp;&amp; lua_istable(L, 2)) {
-		const int table = 2;
-		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
+	if (lua_istable(L, tableIndex)) {
+		for (lua_pushnil(L); lua_next(L, tableIndex) != 0; lua_pop(L, 1)) {
 			if (lua_israwstring(L, -2)) {
 				const string key = lua_tostring(L, -2);
-				if (lua_type(L, -1) == LUA_TSTRING) {//lua_isstring(L, -1)) {
-					if ((key == &quot;outName&quot;) &amp;&amp; lua_isstring(L, -1)) {
+				if (lua_israwstring(L, -1)) {
+					if (key == &quot;outName&quot;) {
 						FontTexture::SetOutBaseName(lua_tostring(L, -1));
 					}
+					else if (key == &quot;inData&quot;) {
+						size_t len = 0;
+						const char* ptr = lua_tolstring(L, -1, &amp;len);
+						inputData.assign(ptr, len);
+						FontTexture::SetInData(inputData);
+					}
 				}
 				else if (lua_isnumber(L, -1)) {
 					const unsigned int value = (unsigned int)lua_tonumber(L, -1);
@@ -1509,6 +1485,12 @@
 			}
 		}
 	}
+
+	if (!inputFile.empty()) {
+		// inputData has the override
+		FontTexture::SetInFileName(inputFile);
+	}
+
 	lua_pushboolean(L, FontTexture::Execute());
 	return 1;
 }
@@ -1526,7 +1508,7 @@
 		luaL_error(L,
 			&quot;Incorrect arguments to SetUnitDefIcon(unitDefID, \&quot;icon\&quot;)&quot;);
 	}
-	const int unitDefID = (int)lua_tonumber(L, 1);
+	const int unitDefID = lua_toint(L, 1);
 	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 	if (ud == NULL) {
 		return 0;
@@ -1556,6 +1538,43 @@
 }
 
 
+int LuaUnsyncedCtrl::SetUnitDefImage(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+
+	const int unitDefID = luaL_checkint(L, 1);
+	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
+	if (ud == NULL) {
+		return 0;
+	}
+
+	if (lua_isnoneornil(L, 2)) {
+		// reset to default texture
+		unitDefHandler-&gt;SetUnitDefImage(ud, ud-&gt;buildPicName);
+		return 0;
+	}
+
+	if (!lua_israwstring(L, 2)) {
+		return 0;
+	}
+	const string texName = lua_tostring(L, 2);
+
+	if (texName[0] == LuaTextures::prefix) { // '!'
+		LuaTextures&amp; textures = CLuaHandle::GetActiveTextures();
+		const LuaTextures::Texture* tex = textures.GetInfo(texName);
+		if (tex == NULL) {
+			return 0;
+		}
+		unitDefHandler-&gt;SetUnitDefImage(ud, tex-&gt;id, tex-&gt;xsize, tex-&gt;ysize);
+	} else {
+		unitDefHandler-&gt;SetUnitDefImage(ud, texName);
+	}
+	return 0;
+}
+
+
 /******************************************************************************/
 
 int LuaUnsyncedCtrl::SetUnitGroup(lua_State* L)
@@ -1575,7 +1594,7 @@
 	if ((args &lt; 1) || !lua_isnumber(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitGroup()&quot;);
 	}
-	const int groupID = (int)lua_tonumber(L, 2);
+	const int groupID = lua_toint(L, 2);
 
 	if (groupID == -1) {
 		unit-&gt;SetGroup(NULL);
@@ -1903,7 +1922,7 @@
 	}
 
 	const string shareType = lua_tostring(L, 1);
-	const float shareLevel = max(0.0f, min(1.0f, (float)lua_tonumber(L, 2)));
+	const float shareLevel = max(0.0f, min(1.0f, lua_tofloat(L, 2)));
 
 	if (shareType == &quot;metal&quot;) {
 		net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, shareLevel, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare));
@@ -1932,7 +1951,7 @@
 	    ((args &gt;= 3) &amp;&amp; !lua_isnumber(L, 3))) {
 		luaL_error(L, &quot;Incorrect arguments to ShareResources()&quot;);
 	}
-	const int teamID = (int)lua_tonumber(L, 1);
+	const int teamID = lua_toint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -1950,7 +1969,7 @@
 		selectedUnits.ClearSelected();
 	}
 	else if (args &gt;= 3) {
-		const float amount = (float)lua_tonumber(L, 3);
+		const float amount = lua_tofloat(L, 3);
 		if (type == &quot;metal&quot;) {
 			net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 0, amount, 0.0f));
 		}
@@ -1979,9 +1998,9 @@
 	    ((args &gt;= 4) &amp;&amp; !lua_isstring(L, 4))) {
 		luaL_error(L, &quot;Incorrect arguments to MarkerAddPoint(x, y, z[, text])&quot;);
 	}
-	const float3 pos((float)lua_tonumber(L, 1),
-	                 (float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3));
+	const float3 pos(lua_tofloat(L, 1),
+	                 lua_tofloat(L, 2),
+	                 lua_tofloat(L, 3));
 	string text = &quot;&quot;;
 	if (args &gt;= 4) {
 	  text = lua_tostring(L, 4);
@@ -2009,12 +2028,12 @@
 		luaL_error(L,
 			&quot;Incorrect arguments to MarkerAddLine(x1, y1, z1, x2, y2, z2)&quot;);
 	}
-	const float3 pos1((float)lua_tonumber(L, 1),
-	                  (float)lua_tonumber(L, 2),
-	                  (float)lua_tonumber(L, 3));
-	const float3 pos2((float)lua_tonumber(L, 4),
-	                  (float)lua_tonumber(L, 5),
-	                  (float)lua_tonumber(L, 6));
+	const float3 pos1(lua_tofloat(L, 1),
+	                  lua_tofloat(L, 2),
+	                  lua_tofloat(L, 3));
+	const float3 pos2(lua_tofloat(L, 4),
+	                  lua_tofloat(L, 5),
+	                  lua_tofloat(L, 6));
 
 	inMapDrawer-&gt;SendLine(pos1, pos2);
 
@@ -2035,9 +2054,9 @@
 	    !lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
 		luaL_error(L, &quot;Incorrect arguments to MarkerDeletePositionl(x, y, z)&quot;);
 	}
-	const float3 pos((float)lua_tonumber(L, 1),
-	                 (float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3));
+	const float3 pos(lua_tofloat(L, 1),
+	                 lua_tofloat(L, 2),
+	                 lua_tofloat(L, 3));
 
 	inMapDrawer-&gt;SendErase(pos);
 

Modified: trunk/rts/Lua/LuaUnsyncedCtrl.h
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCtrl.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaUnsyncedCtrl.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -81,6 +81,7 @@
 		static int MakeFont(lua_State* L);
 
 		static int SetUnitDefIcon(lua_State* L);
+		static int SetUnitDefImage(lua_State* L);
 
 		static int SetActiveCommand(lua_State* L);
 

Modified: trunk/rts/Lua/LuaUnsyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedRead.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaUnsyncedRead.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -39,6 +39,7 @@
 #include &quot;Game/UI/MiniMap.h&quot;
 #include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
+#include &quot;Map/Ground.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
@@ -79,6 +80,7 @@
 	REGISTER_LUA_CFUNC(IsReplay);
 	REGISTER_LUA_CFUNC(GetModUICtrl);
 
+	REGISTER_LUA_CFUNC(GetDrawFrame);
 	REGISTER_LUA_CFUNC(GetFrameTimeOffset);
 	REGISTER_LUA_CFUNC(GetLastUpdateSeconds);
 	REGISTER_LUA_CFUNC(GetHasLag);
@@ -86,6 +88,8 @@
 	REGISTER_LUA_CFUNC(GetViewGeometry);
 	REGISTER_LUA_CFUNC(GetWindowGeometry);
 	REGISTER_LUA_CFUNC(GetScreenGeometry);
+	REGISTER_LUA_CFUNC(GetMiniMapGeometry);
+	REGISTER_LUA_CFUNC(GetMiniMapDualScreen);
 
 	REGISTER_LUA_CFUNC(IsAABBInView);
 	REGISTER_LUA_CFUNC(IsSphereInView);
@@ -93,6 +97,7 @@
 	REGISTER_LUA_CFUNC(IsUnitAllied);
 	REGISTER_LUA_CFUNC(IsUnitInView);
 	REGISTER_LUA_CFUNC(IsUnitVisible);
+	REGISTER_LUA_CFUNC(IsUnitIcon);
 	REGISTER_LUA_CFUNC(IsUnitSelected);
 
 	REGISTER_LUA_CFUNC(GetUnitLuaDraw);
@@ -155,9 +160,8 @@
 	REGISTER_LUA_CFUNC(GetActivePage);
 
 	REGISTER_LUA_CFUNC(GetMouseState);
-	REGISTER_LUA_CFUNC(GetMouseMiniMapState);
+	REGISTER_LUA_CFUNC(GetMouseCursor);
 	REGISTER_LUA_CFUNC(GetMouseStartPosition);
-	REGISTER_LUA_CFUNC(GetMouseCursor);
 
 	REGISTER_LUA_CFUNC(GetKeyState);
 	REGISTER_LUA_CFUNC(GetModKeyState);
@@ -206,7 +210,7 @@
 		luaL_error(L, &quot;%s(): Bad unitID&quot;, caller);
 		return NULL;
 	}
-	const int unitID = (int)lua_tonumber(L, index);
+	const int unitID = lua_toint(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
 		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
 	}
@@ -294,8 +298,51 @@
 }
 
 
+int LuaUnsyncedRead::GetMiniMapGeometry(lua_State* L)
+{
+	if (minimap == NULL) {
+		return 0;
+	}
+	lua_pushnumber(L, minimap-&gt;GetPosX());
+	lua_pushnumber(L, minimap-&gt;GetPosY());
+	lua_pushnumber(L, minimap-&gt;GetSizeX());
+	lua_pushnumber(L, minimap-&gt;GetSizeY());
+	lua_pushboolean(L, minimap-&gt;GetMinimized());
+	lua_pushboolean(L, minimap-&gt;GetMaximized());
+
+	return 6;
+}
+
+
+int LuaUnsyncedRead::GetMiniMapDualScreen(lua_State* L)
+{
+	if (minimap == NULL) {
+		return 0;
+	}
+	if (!gu-&gt;dualScreenMode) {
+		lua_pushboolean(L, false);
+	} else {
+		if (gu-&gt;dualScreenMiniMapOnLeft) {
+			lua_pushliteral(L, &quot;left&quot;);
+		} else {
+			lua_pushliteral(L, &quot;right&quot;);
+		}
+	}
+	return 1;
+}
+
+
 /******************************************************************************/
 
+int LuaUnsyncedRead::GetDrawFrame(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, gu-&gt;drawFrame &amp; 0xFFFF);
+	lua_pushnumber(L, (gu-&gt;drawFrame &gt;&gt; 16) &amp; 0xFFFF);
+	return 2;
+}
+
+
 int LuaUnsyncedRead::GetFrameTimeOffset(lua_State* L)
 {
 	CheckNoArgs(L, __FUNCTION__);
@@ -320,12 +367,12 @@
 
 int LuaUnsyncedRead::IsAABBInView(lua_State* L)
 {
-	float3 mins = float3((float)luaL_checknumber(L, 1),
-	                     (float)luaL_checknumber(L, 2),
-	                     (float)luaL_checknumber(L, 3));
-	float3 maxs = float3((float)luaL_checknumber(L, 4),
-	                     (float)luaL_checknumber(L, 5),
-	                     (float)luaL_checknumber(L, 6));
+	float3 mins = float3(luaL_checkfloat(L, 1),
+	                     luaL_checkfloat(L, 2),
+	                     luaL_checkfloat(L, 3));
+	float3 maxs = float3(luaL_checkfloat(L, 4),
+	                     luaL_checkfloat(L, 5),
+	                     luaL_checkfloat(L, 6));
 	lua_pushboolean(L, camera-&gt;InView(mins, maxs));
 	return 1;
 }
@@ -333,18 +380,10 @@
 
 int LuaUnsyncedRead::IsSphereInView(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to IsSphereInView()&quot;);
-	}
-	const float3 pos((float)lua_tonumber(L, 1),
-	                 (float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3));
-	float radius = 0.0f;
-	if ((args &gt;= 4) &amp;&amp; lua_isnumber(L, 4)) {
-		radius = (float)lua_tonumber(L, 4);
-	}
+	const float3 pos(luaL_checkfloat(L, 1),
+	                 luaL_checkfloat(L, 2),
+	                 luaL_checkfloat(L, 3));
+	const float radius = lua_israwnumber(L, 4) ? lua_tofloat(L, 4) : 0.0f;
 
 	lua_pushboolean(L, camera-&gt;InView(pos, radius));
 	return 1;
@@ -377,6 +416,16 @@
 }
 
 
+static bool UnitIsIcon(const CUnit* unit)
+{
+	const float sqDist = (unit-&gt;pos - camera-&gt;pos).SqLength();
+	const float iconLength = unitDrawer-&gt;iconLength;
+	const float iconDistSqrMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistanceSqr();
+	const float realIconLength = iconLength * iconDistSqrMult;
+	return (sqDist &gt; realIconLength);
+}
+
+
 int LuaUnsyncedRead::IsUnitVisible(lua_State* L)
 {
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
@@ -384,24 +433,41 @@
 		return 0;
 	}
 	const float radius = luaL_optnumber(L, 2, unit-&gt;radius);
+	const bool checkIcon = lua_toboolean(L, 3);
+
 	if (readAllyTeam &lt; 0) {
 		if (!fullRead) {
 			lua_pushboolean(L, false);
 		} else {
-			lua_pushboolean(L, camera-&gt;InView(unit-&gt;midPos, radius));
+			lua_pushboolean(L,
+				(!checkIcon || !UnitIsIcon(unit)) &amp;&amp;
+				camera-&gt;InView(unit-&gt;midPos, radius));
 		}
 	}
 	else {
 		if ((unit-&gt;losStatus[readAllyTeam] &amp; LOS_INLOS) == 0) {
 			lua_pushboolean(L, false);
-		} else { // FIXME -- iconMode?
-			lua_pushboolean(L, camera-&gt;InView(unit-&gt;midPos, radius));
+		} else {
+			lua_pushboolean(L,
+				(!checkIcon || !UnitIsIcon(unit)) &amp;&amp;
+				camera-&gt;InView(unit-&gt;midPos, radius));
 		}
 	}
 	return 1;
 }
 
 
+int LuaUnsyncedRead::IsUnitIcon(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	lua_pushboolean(L, UnitIsIcon(unit));
+	return 1;
+}
+
+
 int LuaUnsyncedRead::IsUnitSelected(lua_State* L)
 {
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
@@ -521,7 +587,7 @@
 	bool fixedRadius = false;
 	float radius = 30.0f; // value from UnitDrawer.cpp
 	if (lua_israwnumber(L, 2)) {
-		radius = (float)lua_tonumber(L, 2);
+		radius = lua_tofloat(L, 2);
 		if (radius &lt; 0.0f) {
 			fixedRadius = true;
 			radius = -radius;
@@ -894,14 +960,9 @@
 
 int LuaUnsyncedRead::WorldToScreenCoords(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 3) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to WorldToScreenCoords(x,y,z)&quot;);
-	}
-	const float3 worldPos((float)lua_tonumber(L, 1),
-	                      (float)lua_tonumber(L, 2),
-	                      (float)lua_tonumber(L, 3));
+	const float3 worldPos(luaL_checkfloat(L, 1),
+	                      luaL_checkfloat(L, 2),
+	                      luaL_checkfloat(L, 3));
 	const float3 winPos = camera-&gt;CalcWindowCoordinates(worldPos);
 	lua_pushnumber(L, winPos.x);
 	lua_pushnumber(L, winPos.y);
@@ -912,20 +973,43 @@
 
 int LuaUnsyncedRead::TraceScreenRay(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) ||
-	    ((args &gt;= 3) &amp;&amp; !lua_isboolean(L, 3))) {
-		luaL_error(L, &quot;Incorrect arguments to TraceScreenRay()&quot;);
-	}
+	// window coordinates
+	const int mx = luaL_checkint(L, 1);
+	const int my = luaL_checkint(L, 2);
+	const bool onlyCoords = (lua_isboolean(L, 3) &amp;&amp; lua_toboolean(L, 3));
+	const bool useMiniMap = (lua_isboolean(L, 4) &amp;&amp; lua_toboolean(L, 4));
 
-	// window coordinates
-	const int mx = (int) lua_tonumber(L, 1);
-	const int my = (int) lua_tonumber(L, 2);
 	const int wx = mx + gu-&gt;viewPosX;
 	const int wy = gu-&gt;viewSizeY - 1 - my - gu-&gt;viewPosY;
 
+	if (useMiniMap &amp;&amp; (minimap != NULL) &amp;&amp; !minimap-&gt;GetMinimized()) {
+		const int px = minimap-&gt;GetPosX() - gu-&gt;viewPosX; // for left dualscreen
+		const int py = minimap-&gt;GetPosY();
+		const int sx = minimap-&gt;GetSizeX();
+		const int sy = minimap-&gt;GetSizeY();
+		if ((mx &gt;= px) &amp;&amp; (mx &lt; (px + sx)) &amp;&amp;
+		    (my &gt;= py) &amp;&amp; (my &lt; (py + sy))) {
+			const float3 pos = minimap-&gt;GetMapPosition(wx, wy);
+			if (!onlyCoords) {
+				const CUnit* unit = minimap-&gt;GetSelectUnit(pos);
+				if (unit != NULL) {
+					lua_pushstring(L, &quot;unit&quot;);
+					lua_pushnumber(L, unit-&gt;id);
+					return 2;
+				}
+			}
+			const float posY = ground-&gt;GetHeight2(pos.x, pos.z);
+			lua_pushstring(L, &quot;ground&quot;);
+			lua_newtable(L);
+			lua_pushnumber(L, 1); lua_pushnumber(L, pos.x); lua_rawset(L, -3);
+			lua_pushnumber(L, 2); lua_pushnumber(L, posY);  lua_rawset(L, -3);
+			lua_pushnumber(L, 3); lua_pushnumber(L, pos.z); lua_rawset(L, -3);
+			return 2;
+		}
+	}
+
 	if ((mx &lt; 0) || (mx &gt;= gu-&gt;viewSizeX) ||
-		(my &lt; 0) || (my &gt;= gu-&gt;viewSizeY)) {
+	    (my &lt; 0) || (my &gt;= gu-&gt;viewSizeY)) {
 		return 0;
 	}
 
@@ -935,7 +1019,6 @@
 	const float3&amp; pos = camera-&gt;pos;
 	const float3 dir = camera-&gt;CalcPixelDir(wx, wy);
 
-	const bool onlyCoords = ((args &gt;= 3) &amp;&amp; lua_toboolean(L, 3));
 
 // FIXME	const int origAllyTeam = gu-&gt;myAllyTeam;
 //	gu-&gt;myAllyTeam = readAllyTeam;
@@ -1012,7 +1095,7 @@
 	const PlayerRoster::SortType oldSort = playerRoster.GetSortType();
 
 	if (args == 1) {
-		const int type = (int)lua_tonumber(L, 1);
+		const int type = lua_toint(L, 1);
 		playerRoster.SetSortTypeByCode((PlayerRoster::SortType)type);
 	}
 
@@ -1037,7 +1120,7 @@
 
 int LuaUnsyncedRead::GetTeamColor(lua_State* L)
 {
-	const int teamID = (int)luaL_checknumber(L, 1);
+	const int teamID = luaL_checkint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -1057,7 +1140,7 @@
 
 int LuaUnsyncedRead::GetTeamOrigColor(lua_State* L)
 {
-	const int teamID = (int)luaL_checknumber(L, 1);
+	const int teamID = luaL_checkint(L, 1);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
 		return 0;
 	}
@@ -1180,7 +1263,7 @@
 	HSTR_PUSH_STRING(L, &quot;tooltip&quot;,     cd.tooltip);
 	HSTR_PUSH_STRING(L, &quot;texture&quot;,     cd.iconname);
 	HSTR_PUSH_STRING(L, &quot;cursor&quot;,      cd.mouseicon);
-	HSTR_PUSH_BOOL(L,   &quot;hidden&quot;,      cd.onlyKey);
+	HSTR_PUSH_BOOL(L,   &quot;hidden&quot;,      cd.hidden);
 	HSTR_PUSH_BOOL(L,   &quot;disabled&quot;,    cd.disabled);
 	HSTR_PUSH_BOOL(L,   &quot;showUnique&quot;,  cd.showUnique);
 	HSTR_PUSH_BOOL(L,   &quot;onlyTexture&quot;, cd.onlyTexture);
@@ -1226,7 +1309,7 @@
 	if ((args != 1) || !lua_isnumber(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to GetActiveCmdDesc()&quot;);
 	}
-	const int cmdIndex = (int)lua_tonumber(L, 1) - CMD_INDEX_OFFSET;
+	const int cmdIndex = lua_toint(L, 1) - CMD_INDEX_OFFSET;
 
 	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
 	const int cmdDescCount = (int)cmdDescs.size();
@@ -1243,7 +1326,7 @@
 	if (guihandler == NULL) {
 		return 0;
 	}
-	const int cmdId = (int)luaL_checknumber(L, 1);
+	const int cmdId = luaL_checkint(L, 1);
 
 	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
 	const int cmdDescCount = (int)cmdDescs.size();
@@ -1319,18 +1402,12 @@
 }
 
 
-int LuaUnsyncedRead::GetMouseMiniMapState(lua_State* L)
+int LuaUnsyncedRead::GetMouseCursor(lua_State* L)
 {
-	if (minimap == NULL) {
-		return 0;
-	}
-	lua_pushnumber(L, minimap-&gt;GetPosX());
-	lua_pushnumber(L, minimap-&gt;GetPosY());
-	lua_pushnumber(L, minimap-&gt;GetSizeX());
-	lua_pushnumber(L, minimap-&gt;GetSizeY());
-	lua_pushboolean(L, minimap-&gt;GetMinimized());
-	lua_pushboolean(L, minimap-&gt;GetMaximized());
-	return 6;
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushstring(L, mouse-&gt;cursorText.c_str());
+	lua_pushnumber(L, mouse-&gt;cursorScale);
+	return 2;
 }
 
 
@@ -1356,15 +1433,6 @@
 }
 
 
-int LuaUnsyncedRead::GetMouseCursor(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushstring(L, mouse-&gt;cursorText.c_str());
-	lua_pushnumber(L, mouse-&gt;cursorScale);
-	return 2;
-}
-
-
 /******************************************************************************/
 /******************************************************************************/
 
@@ -1374,7 +1442,7 @@
 	if ((args != 1) || !lua_isnumber(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to GetKeyState(keycode)&quot;);
 	}
-	const int key = (int)lua_tonumber(L, 1);
+	const int key = lua_toint(L, 1);
 	if ((key &lt; 0) || (key &gt;= SDLK_LAST)) {
 		lua_pushboolean(L, 0);
 	} else {
@@ -1446,7 +1514,7 @@
 
 	int start = 0;
 	if (args &gt;= 1) {
-		const int maxLines = (int)lua_tonumber(L, 1);
+		const int maxLines = lua_toint(L, 1);
 		if (maxLines &lt; lineCount) {
 			start = (lineCount - maxLines);
 		}
@@ -1504,7 +1572,7 @@
 	if ((args != 1) || !lua_isnumber(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to GetKeySymbol(keycode)&quot;);
 	}
-	const int keycode = (int)lua_tonumber(L, 1);
+	const int keycode = lua_toint(L, 1);
 	lua_pushstring(L, keyCodes-&gt;GetName(keycode).c_str());
 	lua_pushstring(L, keyCodes-&gt;GetDefaultName(keycode).c_str());
 	return 2;
@@ -1622,7 +1690,7 @@
 		luaL_error(L, &quot;Incorrect arguments to GetGroupAIName(groupID)&quot;);
 	}
 
-	const int groupID = (int)lua_tonumber(L, 1);
+	const int groupID = lua_toint(L, 1);
 	if ((groupID &lt; 0) || (groupID &gt;= (int)grouphandlers[gu-&gt;myTeam]-&gt;groups.size())) {
 		return 0; // bad group
 	}
@@ -1663,7 +1731,7 @@
 
 int LuaUnsyncedRead::GetGroupUnits(lua_State* L)
 {
-	const int groupID = (int)luaL_checknumber(L, 1);
+	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
 	    (groups[groupID] == NULL)) {
@@ -1688,7 +1756,7 @@
 
 int LuaUnsyncedRead::GetGroupUnitsSorted(lua_State* L)
 {
-	const int groupID = (int)luaL_checknumber(L, 1);
+	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
 	    (groups[groupID] == NULL)) {
@@ -1727,7 +1795,7 @@
 
 int LuaUnsyncedRead::GetGroupUnitsCounts(lua_State* L)
 {
-	const int groupID = (int)luaL_checknumber(L, 1);
+	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
 	    (groups[groupID] == NULL)) {
@@ -1763,7 +1831,7 @@
 
 int LuaUnsyncedRead::GetGroupUnitsCount(lua_State* L)
 {
-	const int groupID = (int)luaL_checknumber(L, 1);
+	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
 	    (groups[groupID] == NULL)) {
@@ -1806,7 +1874,7 @@
 
 int LuaUnsyncedRead::GetPlayerTraffic(lua_State* L)
 {
-	const int playerID = (int)luaL_checknumber(L, 1);
+	const int playerID = luaL_checkint(L, 1);
 	const int packetID = (int)luaL_optnumber(L, 2, -1);
 
 	const std::map&lt;int, CGame::PlayerTrafficInfo&gt;&amp; traffic

Modified: trunk/rts/Lua/LuaUnsyncedRead.h
===================================================================
--- trunk/rts/Lua/LuaUnsyncedRead.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaUnsyncedRead.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -15,6 +15,7 @@
 		static int IsReplay(lua_State* L);
 		static int GetModUICtrl(lua_State* L);
 
+		static int GetDrawFrame(lua_State* L);
 		static int GetFrameTimeOffset(lua_State* L);
 		static int GetLastUpdateSeconds(lua_State* L);
 		static int GetHasLag(lua_State* L);
@@ -22,6 +23,8 @@
 		static int GetViewGeometry(lua_State* L);
 		static int GetWindowGeometry(lua_State* L);
 		static int GetScreenGeometry(lua_State* L);
+		static int GetMiniMapGeometry(lua_State* L);
+		static int GetMiniMapDualScreen(lua_State* L);
 
 		static int IsAABBInView(lua_State* L);
 		static int IsSphereInView(lua_State* L);
@@ -29,6 +32,7 @@
 		static int IsUnitAllied(lua_State* L);
 		static int IsUnitInView(lua_State* L);
 		static int IsUnitVisible(lua_State* L);
+		static int IsUnitIcon(lua_State* L);
 		static int IsUnitSelected(lua_State* L);
 
 		static int GetUnitLuaDraw(lua_State* L);
@@ -77,11 +81,9 @@
 		static int GetFPS(lua_State* L);
 
 		static int GetMouseState(lua_State* L);
-		static int GetMouseMiniMapState(lua_State* L);
+		static int GetMouseCursor(lua_State* L);
 		static int GetMouseStartPosition(lua_State* L);
 
-		static int GetMouseCursor(lua_State* L);
-
 		static int GetKeyState(lua_State* L);
 		static int GetModKeyState(lua_State* L);
 		static int GetPressedKeys(lua_State* L);

Modified: trunk/rts/Lua/LuaUtils.cpp
===================================================================
--- trunk/rts/Lua/LuaUtils.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaUtils.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -236,7 +236,7 @@
 	if (!lua_isnumber(L, idIndex)) {
 		luaL_error(L, &quot;%s(): bad command ID&quot;, caller);
 	}
-	cmd.id = (int)lua_tonumber(L, idIndex);
+	cmd.id = lua_toint(L, idIndex);
 
 	// params
 	const int paramTable = (idIndex + 1);
@@ -248,7 +248,7 @@
 			if (!lua_isnumber(L, -1)) {
 				luaL_error(L, &quot;%s(): bad param table entry&quot;, caller);
 			}
-			const float value = (float)lua_tonumber(L, -1);
+			const float value = lua_tofloat(L, -1);
 			cmd.params.push_back(value);
 		}
 	}
@@ -268,7 +268,7 @@
 	if (!lua_isnumber(L, -1)) {
 		luaL_error(L, &quot;%s(): bad command ID&quot;, caller);
 	}
-	cmd.id = (int)lua_tonumber(L, -1);
+	cmd.id = lua_toint(L, -1);
 	lua_pop(L, 1);
 
 	// params
@@ -282,7 +282,7 @@
 			if (!lua_isnumber(L, -1)) {
 				luaL_error(L, &quot;%s(): bad param table entry&quot;, caller);
 			}
-			const float value = (float)lua_tonumber(L, -1);
+			const float value = lua_tofloat(L, -1);
 			cmd.params.push_back(value);
 		}
 	}

Modified: trunk/rts/Lua/LuaVFS.cpp
===================================================================
--- trunk/rts/Lua/LuaVFS.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaVFS.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -15,6 +15,7 @@
 
 #include &quot;LuaHandle.h&quot;
 #include &quot;LuaHashString.h&quot;
+#include &quot;LuaIO.h&quot;
 #include &quot;LuaUtils.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
@@ -92,7 +93,7 @@
 {
 	const int args = lua_gettop(L);
 	if (index &lt; 0) {
-		index = (args - index + 1);
+		index = (args + index + 1);
 	}
 	if ((index &lt; 1) || (index &gt; args)) {
 		if (synced &amp;&amp; !CLuaHandle::GetDevMode()) {
@@ -101,7 +102,7 @@
 		return SPRING_VFS_RAW_FIRST;
 	}
 
-	if (!lua_isstring(L, index)) {
+	if (!lua_israwstring(L, index)) {
 		luaL_error(L, &quot;Bad VFS access mode&quot;);
 	}
 
@@ -143,6 +144,9 @@
 	}
 
 	const string filename = lua_tostring(L, 1);
+	if (!LuaIO::IsSimplePath(filename)) {
+//FIXME		return 0;
+	}
 
 	const string modes = GetModes(L, 3, synced);
 	
@@ -216,6 +220,9 @@
 	}
 
 	const string filename = lua_tostring(L, 1);
+	if (!LuaIO::IsSimplePath(filename)) {
+//FIXME		return 0;
+	}
 
 	const string modes = GetModes(L, 2, synced);
 
@@ -250,6 +257,9 @@
 	}
 
 	const string filename = lua_tostring(L, 1);
+	if (!LuaIO::IsSimplePath(filename)) {
+//FIXME		return 0;
+	}
 
 	const string modes = GetModes(L, 2, synced);
 
@@ -284,9 +294,8 @@
 
 	const string dir = lua_tostring(L, 1);
 	// keep searches within the Spring directory
-	if ((dir[0] == '/') || (dir[0] == '\\') ||
-	    ((dir.size() &gt;= 2) &amp;&amp; (dir[1] == ':'))) {
-		return 0;
+	if (!LuaIO::IsSimplePath(dir)) {
+//FIXME		return 0;
 	}
 	const string pattern = luaL_optstring(L, 2, &quot;*&quot;);
 	const string modes = GetModes(L, 3, synced);
@@ -343,9 +352,8 @@
 
 	const string dir = lua_tostring(L, 1);
 	// keep searches within the Spring directory
-	if ((dir[0] == '/') || (dir[0] == '\\') ||
-	    ((dir.size() &gt;= 2) &amp;&amp; (dir[1] == ':'))) {
-		return 0;
+	if (!LuaIO::IsSimplePath(dir)) {
+//FIXME		return 0;
 	}
 	const string pattern = luaL_optstring(L, 2, &quot;*&quot;);
 	const string modes = GetModes(L, 3, synced);
@@ -395,6 +403,9 @@
 int LuaVFS::UseArchive(lua_State* L)
 {
 	const string filename = luaL_checkstring(L, 1);
+	if (!LuaIO::IsSimplePath(filename)) {
+//FIXME		return 0;
+	}
 
 	int funcIndex = 2;
 	string modes = SPRING_VFS_ALL;
@@ -479,13 +490,13 @@
 }
 
 
-int LuaVFS::PackU8(lua_State* L)  { return PackType&lt;boost::uint8_t&gt;(L); }
+int LuaVFS::PackU8(lua_State*  L) { return PackType&lt;boost::uint8_t&gt;(L);  }
 int LuaVFS::PackU16(lua_State* L) { return PackType&lt;boost::uint16_t&gt;(L); }
 int LuaVFS::PackU32(lua_State* L) { return PackType&lt;boost::uint32_t&gt;(L); }
-int LuaVFS::PackS8(lua_State* L)  { return PackType&lt;boost::int8_t&gt;(L); }
-int LuaVFS::PackS16(lua_State* L) { return PackType&lt;boost::int16_t&gt;(L); }
-int LuaVFS::PackS32(lua_State* L) { return PackType&lt;boost::int32_t&gt;(L); }
-int LuaVFS::PackF32(lua_State* L) { return PackType&lt;float&gt;(L); }
+int LuaVFS::PackS8(lua_State*  L) { return PackType&lt;boost::int8_t&gt;(L);   }
+int LuaVFS::PackS16(lua_State* L) { return PackType&lt;boost::int16_t&gt;(L);  }
+int LuaVFS::PackS32(lua_State* L) { return PackType&lt;boost::int32_t&gt;(L);  }
+int LuaVFS::PackF32(lua_State* L) { return PackType&lt;float&gt;(L);           }
 
 
 /******************************************************************************/
@@ -500,7 +511,7 @@
 	const char* str = lua_tolstring(L, 1, &amp;len);
 
 	if (lua_isnumber(L, 2)) {
-		const int pos = (int)lua_tonumber(L, 2);
+		const int pos = lua_toint(L, 2);
 		if ((pos &lt; 1) || (pos &gt;= len)) {
 			return 0;
 		}
@@ -521,7 +532,7 @@
 	}
 	else {
 		const int maxCount = (len / eSize);
-		int tableCount = (int)lua_tonumber(L, 3);
+		int tableCount = lua_toint(L, 3);
 		if (tableCount &lt; 0) {
 			tableCount = maxCount;
 		}
@@ -542,13 +553,13 @@
 }
 
 
-int LuaVFS::UnpackU8(lua_State* L)  { return UnpackType&lt;boost::uint8_t&gt;(L); }
+int LuaVFS::UnpackU8(lua_State*  L) { return UnpackType&lt;boost::uint8_t&gt;(L);  }
 int LuaVFS::UnpackU16(lua_State* L) { return UnpackType&lt;boost::uint16_t&gt;(L); }
 int LuaVFS::UnpackU32(lua_State* L) { return UnpackType&lt;boost::uint32_t&gt;(L); }
-int LuaVFS::UnpackS8(lua_State* L)  { return UnpackType&lt;boost::int8_t&gt;(L); }
-int LuaVFS::UnpackS16(lua_State* L) { return UnpackType&lt;boost::int16_t&gt;(L); }
-int LuaVFS::UnpackS32(lua_State* L) { return UnpackType&lt;boost::int32_t&gt;(L); }
-int LuaVFS::UnpackF32(lua_State* L) { return UnpackType&lt;float&gt;(L); }
+int LuaVFS::UnpackS8(lua_State*  L) { return UnpackType&lt;boost::int8_t&gt;(L);   }
+int LuaVFS::UnpackS16(lua_State* L) { return UnpackType&lt;boost::int16_t&gt;(L);  }
+int LuaVFS::UnpackS32(lua_State* L) { return UnpackType&lt;boost::int32_t&gt;(L);  }
+int LuaVFS::UnpackF32(lua_State* L) { return UnpackType&lt;float&gt;(L);           }
 
 
 /******************************************************************************/

Modified: trunk/rts/Lua/LuaWeaponDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaWeaponDefs.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Lua/LuaWeaponDefs.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -201,7 +201,7 @@
 			return 0;
 		}
 		case INT_TYPE: {
-			*((int*)p) = (int)lua_tonumber(L, -1);
+			*((int*)p) = lua_toint(L, -1);
 			return 0;
 		}
 		case BOOL_TYPE: {
@@ -209,7 +209,7 @@
 			return 0;
 		}
 		case FLOAT_TYPE: {
-			*((float*)p) = (float)lua_tonumber(L, -1);
+			*((float*)p) = lua_tofloat(L, -1);
 			return 0;
 		}
 		case STRING_TYPE: {

Modified: trunk/rts/Map/BasicMapDamage.cpp
===================================================================
--- trunk/rts/Map/BasicMapDamage.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Map/BasicMapDamage.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -99,8 +99,10 @@
 				treeDrawer-&gt;RemoveGrass(x,y);
 		}
 	}
+	// calculate how much to offset the buildings in the explosion radius with
+	// (while still keeping the ground under them flat)
 	std::vector&lt;CUnit*&gt; units=qf-&gt;GetUnitsExact(pos,radius);
-	for(std::vector&lt;CUnit*&gt;::iterator ui=units.begin();ui!=units.end();++ui){		//calculate how much to offset the buildings in the explosion radius with (while still keeping the ground under them flat
+	for(std::vector&lt;CUnit*&gt;::iterator ui=units.begin();ui!=units.end();++ui){
 		if((*ui)-&gt;blockHeightChanges &amp;&amp; (*ui)-&gt;isMarkedOnBlockingMap){
 			CUnit* unit=*ui;
 

Modified: trunk/rts/Map/MapInfo.cpp
===================================================================
--- trunk/rts/Map/MapInfo.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Map/MapInfo.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -33,7 +33,7 @@
 const CMapInfo* mapInfo;
 
 
-CMapInfo::CMapInfo(const string&amp; mapName)
+CMapInfo::CMapInfo(const string&amp; mapName, bool onlyBasics)
 {
 	map.name = mapName;
 
@@ -54,13 +54,15 @@
 	resRoot = &resTbl;
 
 	ReadGlobal();
-	ReadAtmosphere();
-	ReadGui();
-	ReadLight();
-	ReadWater();
-	ReadSmf();
-	ReadSm3();
-	ReadTerrainTypes();
+	if (!onlyBasics) {
+		ReadAtmosphere();
+		ReadGui();
+		ReadLight();
+		ReadWater();
+		ReadSmf();
+		ReadSm3();
+		ReadTerrainTypes();
+	}
 }
 
 
@@ -74,7 +76,8 @@
 	const LuaTable topTable = *mapRoot;
 	
 	map.humanName    = topTable.GetString(&quot;description&quot;, map.name);
-	map.wantedScript = topTable.GetString(&quot;script&quot;, map.wantedScript);
+	map.author       = topTable.GetString(&quot;author&quot;, &quot;&quot;);
+	map.wantedScript = topTable.GetString(&quot;script&quot;, &quot;&quot;);
 
 	map.hardness      = topTable.GetFloat(&quot;maphardness&quot;, 100.0f);
 	map.notDeformable = topTable.GetBool(&quot;notDeformable&quot;, false);

Modified: trunk/rts/Map/MapInfo.h
===================================================================
--- trunk/rts/Map/MapInfo.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Map/MapInfo.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -27,7 +27,7 @@
 {
 public:
 
-	CMapInfo(const std::string&amp; mapName);
+	CMapInfo(const std::string&amp; mapName, bool onlyBasics = false);
 	~CMapInfo();
 
 	/* The settings are just public members because:
@@ -62,6 +62,7 @@
 		std::string name;      ///&lt; The filename as passed to the constructor.
 		std::string wantedScript;
 		std::string humanName; ///&lt; &quot;MAP\\Description&quot;
+		std::string author;
 		float hardness;        ///&lt; &quot;MAP\\MapHardness&quot;
 		bool  notDeformable;
 		/** Stores the gravity as a negative number in units/frame^2

Modified: trunk/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- trunk/rts/Map/SMF/BFGroundDrawer.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Map/SMF/BFGroundDrawer.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -14,8 +14,10 @@
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
+#ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
 extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+#endif
 
 using std::min;
 using std::max;

Modified: trunk/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- trunk/rts/Map/SMF/SmfReadMap.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Map/SMF/SmfReadMap.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -16,8 +16,10 @@
 #include &quot;bitops.h&quot;
 #include &quot;mmgr.h&quot;
 
+#ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
 extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+#endif
 
 using namespace std;
 

Modified: trunk/rts/Rendering/Env/AdvWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvWater.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/Env/AdvWater.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -15,7 +15,7 @@
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -344,7 +344,7 @@
 	unitDrawer-&gt;Draw(true);
 	featureHandler-&gt;Draw();
 	ph-&gt;Draw(true);
-	luaCallIns.DrawWorldReflection();
+	eventHandler.DrawWorldReflection();
 
 	game-&gt;SetDrawMode(CGame::normalDraw);
 

Modified: trunk/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/Env/BumpWater.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -25,7 +25,7 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &lt;boost/format.hpp&gt;
 
@@ -673,7 +673,7 @@
 	featureHandler-&gt;Draw();
 	drawReflection=false;
 	ph-&gt;Draw(false,true);
-	luaCallIns.DrawWorldRefraction();
+	eventHandler.DrawWorldRefraction();
 
 	glDisable(GL_CLIP_PLANE2);
 	game-&gt;SetDrawMode(CGame::normalDraw);
@@ -725,7 +725,7 @@
 	unitDrawer-&gt;Draw(true);
 	featureHandler-&gt;Draw();
 	ph-&gt;Draw(true);
-	luaCallIns.DrawWorldReflection();
+	eventHandler.DrawWorldReflection();
 
 	game-&gt;SetDrawMode(CGame::normalDraw);
 	drawReflection=false;

Modified: trunk/rts/Rendering/Env/DynWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/DynWater.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/Env/DynWater.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -18,10 +18,10 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;System/EventHandler.h&quot;
 
 #define W_SIZE 5
 #define WF_SIZE 5120
@@ -448,7 +448,7 @@
 	unitDrawer-&gt;Draw(true);
 	featureHandler-&gt;Draw();
 	ph-&gt;Draw(true);
-	luaCallIns.DrawWorldReflection();
+	eventHandler.DrawWorldReflection();
 
 	sky-&gt;DrawSun();
 
@@ -502,7 +502,7 @@
 	featureHandler-&gt;Draw();
 	drawReflection=false;
 	ph-&gt;Draw(false,true);
-	luaCallIns.DrawWorldRefraction();
+	eventHandler.DrawWorldRefraction();
 	glDisable(GL_CLIP_PLANE2);
 
 	game-&gt;SetDrawMode(CGame::normalDraw);

Modified: trunk/rts/Rendering/GL/myGL.h
===================================================================
--- trunk/rts/Rendering/GL/myGL.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/GL/myGL.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -8,9 +8,12 @@
 
 #include &lt;string&gt;
 #include &lt;GL/glew.h&gt;
+
 #include &quot;lib/gml/gml.h&quot;
+
 #include &quot;float3.h&quot;
 
+
 inline void glVertexf3(const float3 &amp;v)
 {
 	glVertex3f(v.x,v.y,v.z);

Modified: trunk/rts/Rendering/IconHandler.cpp
===================================================================
--- trunk/rts/Rendering/IconHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/IconHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -43,7 +43,7 @@
 	}
 	else {
 		defIconData = SAFE_NEW CIconData(&quot;default&quot;, GetDefaultTexture(),
-																		 1.0f, 1.0f, false, false);
+																		 1.0f, 1.0f, false, false, 128, 128);
 		iconMap[&quot;default&quot;] = CIcon(defIconData);
 	}
 }
@@ -88,6 +88,7 @@
                            float size, float distance, bool radAdj)
 {
 	unsigned int texID;
+	int xsize, ysize;
 
 	bool ownTexture = true;
 
@@ -95,13 +96,18 @@
 		CBitmap bitmap;
 		if (!textureName.empty() &amp;&amp; bitmap.Load(textureName)) {
 			texID = bitmap.CreateTexture(true);
+			
 			glBindTexture(GL_TEXTURE_2D, texID);
 			const GLenum wrapMode = GLEW_EXT_texture_edge_clamp ?
 			                        GL_CLAMP_TO_EDGE : GL_CLAMP;
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);
+			xsize = bitmap.xsize;
+			ysize = bitmap.ysize;
 		} else {
 			texID = GetDefaultTexture();
+			xsize = 128;
+			ysize = 128;
 			ownTexture = false;
 		}
 	}
@@ -114,8 +120,8 @@
 		FreeIcon(iconName);
 	}
 
-	CIconData* iconData =
-		SAFE_NEW CIconData(iconName, texID,  size, distance, radAdj, ownTexture);
+	CIconData* iconData = SAFE_NEW CIconData(iconName, texID,  size, distance,
+	                                         radAdj, ownTexture, xsize, ysize);
 
 	iconMap[iconName] = CIcon(iconData);
 
@@ -255,17 +261,20 @@
 
 CIconData::CIconData()
 : ownTexture(false), refCount(123456), name(&quot;safety&quot;), texID(0),
-  size(1.0f), distance(1.0f), distSqr(1.0f), radiusAdjust(false)
+  size(1.0f), distance(1.0f), distSqr(1.0f), radiusAdjust(false),
+  xsize(1), ysize(1)
 {
 }
 
 
 CIconData::CIconData(const std::string&amp; _name, unsigned int _texID,
-                     float _size, float _distance, bool radAdj, bool ownTex)
+                     float _size, float _distance, bool radAdj, bool ownTex,
+                     int _xsize, int _ysize)
 : ownTexture(ownTex), refCount(0),
   name(_name), texID(_texID),
   size(_size), distance(_distance),
-  radiusAdjust(radAdj)
+  radiusAdjust(radAdj),
+  xsize(_xsize), ysize(_ysize)
 {
 	distSqr = distance * distance;
 }
@@ -302,6 +311,8 @@
 	distance     = iconData-&gt;distance;
 	distSqr      = iconData-&gt;distSqr;
 	radiusAdjust = iconData-&gt;radiusAdjust;
+	xsize        = iconData-&gt;xsize;
+	ysize        = iconData-&gt;ysize;
 	ownTexture   = false;
 }
 

Modified: trunk/rts/Rendering/IconHandler.h
===================================================================
--- trunk/rts/Rendering/IconHandler.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/IconHandler.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -16,7 +16,7 @@
 		CIconData(); // for CIconHandler::safetyData
 		CIconData(const std::string&amp; name, unsigned int texID,
 		          float size, float distance, bool radiusAdjust,
-		          bool ownTexture);
+		          bool ownTexture, int xsize, int ysize);
 		~CIconData();
 
 		void Ref();
@@ -34,6 +34,8 @@
 		inline const float        GetDistance()     const { return distance;     }
 		inline const float        GetDistanceSqr()  const { return distSqr;      }
 		inline const bool         GetRadiusAdjust() const { return radiusAdjust; }
+		inline const int          GetSizeX()        const { return xsize;        }
+		inline const int          GetSizeY()        const { return ysize;        }
 
 	private:
 		bool ownTexture;
@@ -41,6 +43,8 @@
 
 		std::string name;
 		unsigned int texID;
+		int xsize;
+		int ysize;
 		float size;
 		float distance;
 		float distSqr;

Modified: trunk/rts/Rendering/ShadowHandler.cpp
===================================================================
--- trunk/rts/Rendering/ShadowHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/ShadowHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -1,6 +1,5 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;ShadowHandler.h&quot;
-#include &quot;GL/myGL.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;UnitModels/UnitDrawer.h&quot;
@@ -12,9 +11,10 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Game/UI/MiniMap.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/IFramebuffer.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
-#include &quot;GL/IFramebuffer.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
 CShadowHandler* shadowHandler=0;
@@ -157,7 +157,7 @@
 	featureHandler-&gt;DrawShadowPass();
 	readmap-&gt;GetGroundDrawer()-&gt;DrawShadowPass();
 	treeDrawer-&gt;DrawShadowPass();
-	luaCallIns.DrawWorldShadow();
+	eventHandler.DrawWorldShadow();
 
 	inShadowPass=false;
 }

Modified: trunk/rts/Rendering/Textures/Bitmap.cpp
===================================================================
--- trunk/rts/Rendering/Textures/Bitmap.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/Textures/Bitmap.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -267,45 +267,58 @@
 }
 
 
-void CBitmap::Save(string const&amp; filename)
+bool CBitmap::Save(string const&amp; filename, bool opaque)
 {
 	if (type == BitmapTypeDDS) {
-		ddsimage-&gt;save(filename);
-		return;
+		return ddsimage-&gt;save(filename);
 	}
 
-#if !defined(USE_QUICKTIME) // Use devil on Windows/Linux/...
+#if defined(USE_QUICKTIME)
+
+	return false; // I'll add a quicktime exporter for mac soonish...Krysole
+
+#else
+
+	// Use DevIL on Windows/Linux/...
+
 	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);
 	ilEnable(IL_ORIGIN_SET);
 
-	unsigned char* buf=SAFE_NEW unsigned char[xsize*ysize*4];
+	unsigned char* buf = SAFE_NEW unsigned char[xsize * ysize * 4];
+	const int ymax = (ysize - 1);
 	/* HACK Flip the image so it saves the right way up.
 		(Fiddling with ilOriginFunc didn't do anything?)
 		Duplicated with ReverseYAxis. */
-	for(int y=0;y&lt;ysize;++y){
-		for(int x=0;x&lt;xsize;++x){
-			buf[((ysize-1-y)*xsize+x)*4+0] = mem[((y)*xsize+x)*4+0];
-			buf[((ysize-1-y)*xsize+x)*4+1] = mem[((y)*xsize+x)*4+1];
-			buf[((ysize-1-y)*xsize+x)*4+2] = mem[((y)*xsize+x)*4+2];
-			buf[((ysize-1-y)*xsize+x)*4+3] = 0xff; // mem[((y)*xsize+x)*4+3];
+	for (int y = 0; y &lt; ysize; ++y) {
+		for (int x = 0; x &lt; xsize; ++x) {
+			const int bi = 4 * (x + (xsize * (ymax - y)));
+			const int mi = 4 * (x + (xsize * (y)));
+			buf[bi + 0] = mem[mi + 0];
+			buf[bi + 1] = mem[mi + 1];
+			buf[bi + 2] = mem[mi + 2];
+			buf[bi + 3] = opaque ? 0xff : mem[mi + 3];
 		}
 	}
 
 	ilHint(IL_COMPRESSION_HINT, IL_USE_COMPRESSION);
-	ilSetInteger (IL_JPG_QUALITY, 80);
+	ilSetInteger(IL_JPG_QUALITY, 80);
 
 	ILuint ImageName = 0;
 	ilGenImages(1, &amp;ImageName);
 	ilBindImage(ImageName);
 
-	ilTexImage(xsize,ysize,1,4,IL_RGBA,IL_UNSIGNED_BYTE,NULL);
+	ilTexImage(xsize, ysize, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, NULL);
 	ilSetData(buf);
 
-	ilSaveImage((char*)( filesystem.LocateFile(filename, FileSystem::WRITE).c_str() ));
+	const string fullpath = filesystem.LocateFile(filename, FileSystem::WRITE);
+	const bool success = ilSaveImage((char*)fullpath.c_str());
 
 	ilDeleteImages(1,&amp;ImageName);
 	delete[] buf;
-#endif // I'll add a quicktime exporter for mac soonish...Krysole
+
+	return success;
+
+#endif // USE_QUICKTIME
 }
 
 

Modified: trunk/rts/Rendering/Textures/Bitmap.h
===================================================================
--- trunk/rts/Rendering/Textures/Bitmap.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/Textures/Bitmap.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -25,7 +25,7 @@
 	void Alloc(int w,int h);
 	bool Load(string const&amp; filename, unsigned char defaultAlpha=255);
 	bool LoadGrayscale(string const&amp; filename);
-	void Save(string const&amp; filename);
+	bool Save(string const&amp; filename, bool opaque = true);
 
 	unsigned int CreateTexture(bool mipmaps=false);
 	unsigned int CreateDDSTexture();

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -42,8 +42,10 @@
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;mmgr.h&quot;
 
+#ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
 extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+#endif
 
 CUnitDrawer* unitDrawer;
 static bool luaDrawing = false; // FIXME

Modified: trunk/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- trunk/rts/Sim/Features/FeatureHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Features/FeatureHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -7,7 +7,6 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
@@ -24,6 +23,7 @@
 #include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/BuilderCAI.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/TimeProfiler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;mmgr.h&quot;
@@ -382,6 +382,8 @@
 {
 	ASSERT_SYNCED_MODE;
 
+	// FIXME -- randomize me, pretty please
+	//          (could be done in blocks, if (empty) { add 5000 freeIDs } ?)
 	if (freeIDs.empty()) {
 		feature-&gt;id = nextFreeID++;
 	} else {
@@ -399,7 +401,7 @@
 		feature-&gt;drawQuad = quad;
 	}
 
-	luaCallIns.FeatureCreated(feature);
+	eventHandler.FeatureCreated(feature);
 
 	return feature-&gt;id ;
 }
@@ -410,7 +412,7 @@
 	ASSERT_SYNCED_MODE;
 	toBeRemoved.push_back(feature-&gt;id);
 
-	luaCallIns.FeatureDestroyed(feature);
+	eventHandler.FeatureDestroyed(feature);
 }
 
 

Modified: trunk/rts/Sim/Misc/LosHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/LosHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Misc/LosHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -97,8 +97,10 @@
 	airSizeY = std::max(1, gs-&gt;mapy &gt;&gt; airMipLevel);
 	losSizeX = std::max(1, gs-&gt;mapx &gt;&gt; losMipLevel);
 	losSizeY = std::max(1, gs-&gt;mapy &gt;&gt; losMipLevel);
-	invLosDiv = 1 / ((float)SQUARE_SIZE * (1 &lt;&lt; losMipLevel));
-	invAirDiv = 1 / ((float)SQUARE_SIZE * (1 &lt;&lt; airMipLevel));
+	losDiv = (SQUARE_SIZE * (1 &lt;&lt; losMipLevel));
+	airDiv = (SQUARE_SIZE * (1 &lt;&lt; airMipLevel));
+	invLosDiv = 1.0f / losDiv;
+	invAirDiv = 1.0f / airDiv;
 
 	requireSonarUnderWater = modInfo.requireSonarUnderWater;
 
@@ -128,6 +130,7 @@
 		terrainHeight[a]=10;
 }
 
+
 CLosHandler::~CLosHandler()
 {
 	std::list&lt;LosInstance*&gt;::iterator li;
@@ -141,48 +144,53 @@
 
 }
 
-void CLosHandler::MoveUnit(CUnit *unit,bool redoCurrent)
+
+void CLosHandler::MoveUnit(CUnit *unit, bool redoCurrent)
 {
 	SCOPED_TIMER(&quot;Los&quot;);
-	float3 losPos=unit-&gt;pos;
+	float3 losPos = unit-&gt;pos;
 	losPos.CheckInBounds();
 
-	const int allyteam=unit-&gt;allyteam;
-	unit-&gt;lastLosUpdate=gs-&gt;frameNum;
+	const int allyteam = unit-&gt;allyteam;
+	unit-&gt;lastLosUpdate = gs-&gt;frameNum;
 
-	if(unit-&gt;losRadius&lt;=0){
+	if (unit-&gt;losRadius &lt;= 0) {
 		return;
 	}
-	const int xmap=(int)(losPos.x*invLosDiv);
-	const int ymap=(int)(losPos.z*invLosDiv);
-	const int baseSquare=max(0,min(losSizeY-1,(ymap)))*losSizeX + max(0,min(losSizeX-1,xmap));
-	const int baseX=max(0,min(losSizeX-1,xmap));
-	const int baseY=max(0,min(losSizeY-1,(ymap)));
+	const int xmap = (int)(losPos.x*invLosDiv);
+	const int ymap = (int)(losPos.z*invLosDiv);
+	const int baseSquare = max(0,min(losSizeY-1,(ymap)))*losSizeX + max(0,min(losSizeX-1,xmap));
+	const int baseX = max(0,min(losSizeX-1,xmap));
+	const int baseY = max(0,min(losSizeY-1,(ymap)));
 
 	LosInstance* instance;
-	if(redoCurrent){
-		if(!unit-&gt;los){
+	if (redoCurrent) {
+		if (!unit-&gt;los) {
 			return;
 		}
-		instance=unit-&gt;los;
+		instance = unit-&gt;los;
 		CleanupInstance(instance);
 		instance-&gt;losSquares.clear();
-		instance-&gt;baseX=baseX;
-		instance-&gt;baseY=baseY;
-		instance-&gt;baseSquare=baseSquare;	//this could be a problem if several units are sharing the same instance
-		int baseAirSquare=max(0,min(airSizeY-1,((int)(losPos.z*invAirDiv))))*airSizeX + max(0,min(airSizeX-1,(int)(losPos.x*invAirDiv)));
-		instance-&gt;baseAirSquare=baseAirSquare;
+		instance-&gt;baseX = baseX;
+		instance-&gt;baseY = baseY;
+		instance-&gt;baseSquare = baseSquare;	//this could be a problem if several units are sharing the same instance
+		int baseAirSquare = max(0,min(airSizeY-1,((int)(losPos.z*invAirDiv))))*airSizeX + max(0,min(airSizeX-1,(int)(losPos.x*invAirDiv)));
+		instance-&gt;baseAirSquare = baseAirSquare;
 	} else {
-		if(unit-&gt;los &amp;&amp; unit-&gt;los-&gt;baseSquare==baseSquare){
+		if (unit-&gt;los &amp;&amp; (unit-&gt;los-&gt;baseSquare == baseSquare)) {
 			return;
 		}
 		FreeInstance(unit-&gt;los);
-		int hash=GetHashNum(unit);
+		int hash = GetHashNum(unit);
 		std::list&lt;LosInstance*&gt;::iterator lii;
-		for(lii=instanceHash[hash].begin();lii!=instanceHash[hash].end();++lii){
-			if((*lii)-&gt;baseSquare==baseSquare &amp;&amp; (*lii)-&gt;losSize==unit-&gt;losRadius &amp;&amp; (*lii)-&gt;airLosSize==unit-&gt;airLosRadius &amp;&amp; (*lii)-&gt;baseHeight==unit-&gt;losHeight &amp;&amp; (*lii)-&gt;allyteam==allyteam){
+		for (lii = instanceHash[hash].begin(); lii != instanceHash[hash].end(); ++lii) {
+			if ((*lii)-&gt;baseSquare == baseSquare         &amp;&amp;
+			    (*lii)-&gt;losSize    == unit-&gt;losRadius    &amp;&amp;
+			    (*lii)-&gt;airLosSize == unit-&gt;airLosRadius &amp;&amp;
+			    (*lii)-&gt;baseHeight == unit-&gt;losHeight    &amp;&amp;
+			    (*lii)-&gt;allyteam   == allyteam) {
 				AllocInstance(*lii);
-				unit-&gt;los=*lii;
+				unit-&gt;los = *lii;
 				return;
 			}
 		}
@@ -191,28 +199,31 @@
 		instanceHash[hash].push_back(instance);
 		unit-&gt;los=instance;
 	}
-	if(xmap-unit-&gt;losRadius&lt;0 || xmap+unit-&gt;losRadius&gt;=losSizeX || ymap-unit-&gt;losRadius&lt;0 || ymap+unit-&gt;losRadius&gt;=losSizeY)
-		SafeLosAdd(instance,xmap,ymap);
-	else
+	if (xmap-unit-&gt;losRadius &lt; 0 || xmap+unit-&gt;losRadius &gt;= losSizeX ||
+	    ymap-unit-&gt;losRadius &lt; 0 || ymap+unit-&gt;losRadius &gt;= losSizeY) {
+		SafeLosAdd(instance, xmap, ymap);
+	} else {
 		LosAdd(instance);
+	}
 }
 
+
 void CLosHandler::LosAdd(LosInstance* instance)
 {
 	assert(instance);
 	assert(instance-&gt;allyteam &lt; gs-&gt;activeAllyTeams);
 	assert(instance-&gt;allyteam &gt;= 0);
 
-	const int allyteam=instance-&gt;allyteam;
-	const int mapSquare=instance-&gt;baseSquare;
+	const int allyteam  = instance-&gt;allyteam;
+	const int mapSquare = instance-&gt;baseSquare;
 
 	LosAddAir(instance);
 
-	int tablenum=instance-&gt;losSize;
-	if(tablenum&gt;MAX_LOS_TABLE){
-		tablenum=MAX_LOS_TABLE;
+	int tablenum = instance-&gt;losSize;
+	if (tablenum &gt; MAX_LOS_TABLE) {
+		tablenum = MAX_LOS_TABLE;
 	}
-	LosTable&amp; table=lostables[tablenum-1];
+	LosTable&amp; table = lostables[tablenum - 1];
 
 	instance-&gt;losSquares.push_back(mapSquare);
 	losMap[allyteam][mapSquare]++;
@@ -220,11 +231,11 @@
 	for(LosTable::iterator li=table.begin();li!=table.end();++li){
 		LosLine&amp; line=*li;
 		const float baseHeight=readmap-&gt;mipHeightmap[losMipLevel][mapSquare]+instance-&gt;baseHeight-15;
-		float maxAng1=-1000;
-		float maxAng2=-1000;
-		float maxAng3=-1000;
-		float maxAng4=-1000;
-		float r=1;
+		float maxAng1 = -1000;
+		float maxAng2 = -1000;
+		float maxAng3 = -1000;
+		float maxAng4 = -1000;
+		float r = 1;
 		for(LosLine::iterator linei=line.begin();linei!=line.end();++linei){
 			float invR=1.0f/r;
 			int square=mapSquare+linei-&gt;x+linei-&gt;y*losSizeX;
@@ -283,6 +294,7 @@
 	}
 }
 
+
 void CLosHandler::SafeLosAdd(LosInstance* instance,int xm,int ym)
 {
 	int xmap=xm;
@@ -299,14 +311,14 @@
 	}
 	LosTable&amp; table=lostables[tablenum-1];
 
-	for(LosTable::iterator li=table.begin();li!=table.end();++li){
-		LosLine&amp; line=*li;
+	for (LosTable::iterator li = table.begin(); li != table.end(); ++li) {
+		LosLine&amp; line = *li;
 		float baseHeight=readmap-&gt;mipHeightmap[losMipLevel][mapSquare]+instance-&gt;baseHeight-15;
-		float maxAng1=-1000;
-		float maxAng2=-1000;
-		float maxAng3=-1000;
-		float maxAng4=-1000;
-		float r=1;
+		float maxAng1 = -1000;
+		float maxAng2 = -1000;
+		float maxAng3 = -1000;
+		float maxAng4 = -1000;
+		float r = 1;
 		instance-&gt;losSquares.push_back(mapSquare);
 		losMap[allyteam][mapSquare]++;
 
@@ -372,6 +384,7 @@
 	}
 }
 
+
 void CLosHandler::OutputTable(int Table)
 {
 	LosTable lostable;
@@ -440,6 +453,7 @@
 	delete[] PaintTable;
 }
 
+
 CLosHandler::LosLine CLosHandler::OutputLine(int x, int y, int Line)
 {
 	LosLine losline;
@@ -470,6 +484,7 @@
 	return losline;
 }
 
+
 void CLosHandler::DrawLine(char* PaintTable, int x, int y, int Size)
 {
 	int x0 = 0;
@@ -498,6 +513,7 @@
 	}
 }
 
+
 int CLosHandler::Round(float Num)
 {
   if((Num - (int)Num) &lt;0.5f)
@@ -506,6 +522,7 @@
     return (int)Num+1;
 }
 
+
 void CLosHandler::FreeInstance(LosInstance* instance)
 {
 	if(instance==0)
@@ -544,6 +561,7 @@
 	}
 }
 
+
 int CLosHandler::GetHashNum(CUnit* unit)
 {
 	unsigned int t=unit-&gt;mapSquare*unit-&gt;losRadius+unit-&gt;allyteam;
@@ -551,6 +569,7 @@
 	return t%2309;
 }
 
+
 void CLosHandler::AllocInstance(LosInstance* instance)
 {
 	if(instance-&gt;refCount==0){
@@ -563,6 +582,7 @@
 	instance-&gt;refCount++;
 }
 
+
 void CLosHandler::CleanupInstance(LosInstance* instance)
 {
 	for(std::vector&lt;int&gt;::iterator lsi=instance-&gt;losSquares.begin();lsi!=instance-&gt;losSquares.end();++lsi){
@@ -588,6 +608,7 @@
 	}
 }
 
+
 void CLosHandler::LosAddAir(LosInstance* instance)
 {
 	/*int by=(instance-&gt;baseSquare/gs-&gt;hmapx);
@@ -616,6 +637,7 @@
 	}
 }
 
+
 void CLosHandler::Update(void)
 {
 	while(!delayQue.empty() &amp;&amp; delayQue.front().timeoutTime&lt;gs-&gt;frameNum){
@@ -624,6 +646,7 @@
 	}
 }
 
+
 void CLosHandler::DelayedFreeInstance(LosInstance* instance)
 {
 	DelayedInstance di;

Modified: trunk/rts/Sim/Misc/LosHandler.h
===================================================================
--- trunk/rts/Sim/Misc/LosHandler.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Misc/LosHandler.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -144,6 +144,8 @@
 
 	int losMipLevel;
 	int airMipLevel;
+	int losDiv;
+	int airDiv;
 	float invLosDiv;
 	float invAirDiv;
 	int airSizeX;

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -968,7 +968,7 @@
 	// Obstacle-avoidance-system only needs to be run if the unit wants to move
 	if (pathId) {
 		float3 avoidanceDir = desiredDir;
-		// Speed-optimizer. Reduces the times this system is ran.
+		// Speed-optimizer. Reduces the times this system is run.
 		if (gs-&gt;frameNum &gt;= nextObstacleAvoidanceUpdate) {
 			nextObstacleAvoidanceUpdate = gs-&gt;frameNum + 4;
 
@@ -979,16 +979,18 @@
 			int lty = wsy - moveSquareY + 5;
 
 			if (ltx &gt;= 0 &amp;&amp; ltx &lt; 11 &amp;&amp; lty &gt;= 0 &amp;&amp; lty &lt; 11) {
-				for (std::vector&lt;int2&gt;::iterator li = lineTable[lty][ltx].begin(); li != lineTable[lty][ltx].end(); ++li) {
-					int x = (moveSquareX + li-&gt;x) * 2;
-					int y = (moveSquareY + li-&gt;y) * 2;
-					int mask = CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN | CMoveMath::BLOCK_MOBILE_BUSY;
-
-					if ((owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;IsBlocked(*owner-&gt;unitDef-&gt;movedata, x, y) &amp; mask) ||
-							owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, x, y) &lt;= 0.01f) {
+				std::vector&lt;int2&gt;::iterator li;
+				for (li = lineTable[lty][ltx].begin(); li != lineTable[lty][ltx].end(); ++li) {
+					const int x = (moveSquareX + li-&gt;x) * 2;
+					const int y = (moveSquareY + li-&gt;y) * 2;
+					const int blockBits = CMoveMath::BLOCK_STRUCTURE |
+					                      CMoveMath::BLOCK_TERRAIN   | 
+					                      CMoveMath::BLOCK_MOBILE_BUSY;
+					MoveData&amp; moveData  = *owner-&gt;unitDef-&gt;movedata;
+					if ((moveData.moveMath-&gt;IsBlocked(moveData, x, y) &amp; blockBits) ||
+					    (moveData.moveMath-&gt;SpeedMod(moveData, x, y) &lt;= 0.01f)) {
 						// not reachable, force a new path to be calculated next slowupdate
 						++etaFailures;
-
 						if (DEBUG_CONTROLLER) {
 							logOutput.Print(&quot;Waypoint path blocked for unit %i&quot;, owner-&gt;id);
 						}

Modified: trunk/rts/Sim/Objects/SolidObject.cpp
===================================================================
--- trunk/rts/Sim/Objects/SolidObject.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Objects/SolidObject.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -94,7 +94,10 @@
 	if (isMarkedOnBlockingMap)
 		UnBlock();
 
-	if (blocking &amp;&amp; (physicalState == OnGround || physicalState == Floating || physicalState == Hovering || physicalState == Submarine)) {
+	if (blocking &amp;&amp; (physicalState == OnGround ||
+	                 physicalState == Floating ||
+	                 physicalState == Hovering ||
+	                 physicalState == Submarine)) {
 		// use the object's yardmap if available
 		if (yardMap) {
 			groundBlockingObjectMap-&gt;AddGroundBlockingObject(this, yardMap);

Modified: trunk/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- trunk/rts/Sim/Path/PathEstimator.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Path/PathEstimator.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -173,11 +173,15 @@
 }
 
 void CPathEstimator::InitEstimator(const std::string&amp; name) {
-	#if (BOOST_VERSION &gt;= 103500)
+#if (BOOST_VERSION &gt;= 103500)
 	int numThreads = boost::thread::hardware_concurrency();
-	#else
-	int numThreads = GML_CPU_COUNT; //configHandler.GetInt(&quot;HardwareThreadCount&quot;, 2);
-	#endif
+#else
+#  ifdef USE_GML	
+	int numThreads = GML_CPU_COUNT;
+#  else
+	int numThreads = configHandler.GetInt(&quot;HardwareThreadCount&quot;, 2);
+#  endif
+#endif
 
 	if (numThreads &gt; 1) {
 		// spawn the threads for InitVerticesAndBlocks()

Modified: trunk/rts/Sim/Projectiles/ExplosionGenerator.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/ExplosionGenerator.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Projectiles/ExplosionGenerator.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -55,14 +55,15 @@
 	string n = name;
 	for (;;) {
 		map&lt;string,string&gt;::iterator i = aliases.find(n);
-		if (i == aliases.end())
+		if (i == aliases.end()) {
 			break;
-
+		}
 		n = i-&gt;second;
 	}
 	creg::Class *cls = creg::System::GetClass(n);
-	if (!cls)
+	if (!cls) {
 		throw content_error(&quot;Unknown class: &quot; + name);
+	}
 	return cls;
 }
 
@@ -161,7 +162,9 @@
 }
 
 
-void CStdExplosionGenerator::Explosion(const float3 &amp;pos, float damage, float radius, CUnit *owner,float gfxMod, CUnit *hit, const float3 &amp;dir)
+void CStdExplosionGenerator::Explosion(const float3 &amp;pos, float damage,
+                                       float radius, CUnit *owner,float gfxMod,
+                                       CUnit *hit, const float3 &amp;dir)
 {
 	PUSH_CODE_MODE;
 	ENTER_MIXED;

Modified: trunk/rts/Sim/Projectiles/ExplosionGenerator.h
===================================================================
--- trunk/rts/Sim/Projectiles/ExplosionGenerator.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Projectiles/ExplosionGenerator.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -6,9 +6,11 @@
 #include &quot;Sim/Objects/WorldObject.h&quot;
 #include &lt;map&gt;
 
+
 class CUnit;
 class CExplosionGenerator;
 
+
 class CExpGenSpawnable : public CWorldObject
 {
 public:
@@ -19,6 +21,7 @@
 	virtual void Init(const float3&amp; pos, CUnit *owner)=0;
 };
 
+
 class ClassAliasList 
 {
 public:
@@ -31,6 +34,7 @@
 	std::map&lt;std::string, std::string&gt; aliases;
 };
 
+
 class CExplosionGeneratorHandler
 {
 public:
@@ -59,6 +63,7 @@
 	virtual void Load(CExplosionGeneratorHandler* loader, const std::string&amp; tag) = 0;
 };
 
+
 class CStdExplosionGenerator : public CExplosionGenerator
 {
 public:
@@ -68,9 +73,10 @@
 	virtual ~CStdExplosionGenerator();
 
 	void Explosion(const float3 &amp;pos, float damage, float radius, CUnit *owner,float gfxMod, CUnit *hit,const float3 &amp;dir);
-	void Load (CExplosionGeneratorHandler* loader, const std::string&amp; tag);
+	void Load(CExplosionGeneratorHandler* loader, const std::string&amp; tag);
 };
 
+
 /* Defines the result of an explosion as a series of new projectiles */
 class CCustomExplosionGenerator : public CStdExplosionGenerator
 {
@@ -113,6 +119,8 @@
 	void Explosion(const float3 &amp;pos, float damage, float radius, CUnit *owner,float gfxMod, CUnit *hit, const float3 &amp;dir);
 };
 
+
 extern CExplosionGeneratorHandler* explGenHandler;
 
+
 #endif 

Modified: trunk/rts/Sim/Projectiles/Projectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/Projectile.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Projectiles/Projectile.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -46,13 +46,14 @@
 {}
 
 
-void CProjectile::Init (const float3&amp; explosionPos, CUnit* owner)
+void CProjectile::Init(const float3&amp; explosionPos, CUnit* owner)
 {
 	pos += explosionPos;
 	SetRadius(1.7f);
 	ph-&gt;AddProjectile(this);
-	if (owner)
+	if (owner) {
 		AddDeathDependence(owner);
+	}
 }
 
 

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -8,7 +8,6 @@
 #include &quot;Projectile.h&quot;
 #include &quot;ProjectileHandler.h&quot;
 #include &quot;Game/Camera.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapInfo.h&quot;
@@ -31,6 +30,7 @@
 #include &quot;Sim/Projectiles/Unsynced/ShieldPartProjectile.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/TimeProfiler.h&quot;
 #include &quot;System/creg/STL_Map.h&quot;
@@ -46,7 +46,8 @@
 CR_REG_METADATA(CProjectileHandler, (
 	CR_MEMBER(ps),
 	CR_MEMBER(weaponProjectileIDs),
-	CR_MEMBER(curWeaponProjectileID),
+	CR_MEMBER(freeIDs),
+	CR_MEMBER(maxUsedID),
 	CR_MEMBER(groundFlashes),
 	CR_RESERVED(32),
 	CR_SERIALIZER(Serialize),
@@ -66,8 +67,14 @@
 	currentParticles = 0;
 	particleSaturation = 0;
 	numPerlinProjectiles = 0;
-	curWeaponProjectileID = 0;
 
+	// preload some IDs
+	// (note that 0 is reserved for unsynced projectiles)
+	for (int i = 1; i &lt;= 12345; i++) {
+		freeIDs.push_back(i);
+	}
+	maxUsedID = freeIDs.size();
+
 	textureAtlas = SAFE_NEW CTextureAtlas(2048, 2048);
 
 	// used to block resources_map.tdf from loading textures
@@ -405,8 +412,11 @@
 				ProjectileMap::iterator it = weaponProjectileIDs.find(p-&gt;id);
 				const ProjectileMapPair&amp; pp = it-&gt;second;
 
-				luaCallIns.ProjectileDestroyed(pp);
+				eventHandler.ProjectileDestroyed(pp.first, pp.second);
 				weaponProjectileIDs.erase(it);
+				if (p-&gt;id != 0) {
+					freeIDs.push_back(p-&gt;id);
+				}
 			}
 
 			delete p;
@@ -691,12 +701,23 @@
 	if (p-&gt;synced &amp;&amp; p-&gt;weapon) {
 		// &lt;ps&gt; stores both synced and unsynced projectiles,
 		// only keep track of IDs of the synced ones for Lua
-		p-&gt;id = curWeaponProjectileID++;
+		int newID = 0;
+		if (!freeIDs.empty()) {
+			newID = freeIDs.front();
+			freeIDs.pop_front();
+		} else {
+			maxUsedID++;
+			newID = maxUsedID;
+			if (maxUsedID &gt; (1 &lt;&lt; 24)) {
+				logOutput.Print(&quot;LUA projectile IDs are now out of range&quot;);
+			}
+		}
+		p-&gt;id = newID;
 		// projectile owner can die before projectile itself
 		// does, so copy the allyteam at projectile creation
-		ProjectileMapPair pp(p, p-&gt;owner? p-&gt;owner-&gt;allyteam: -1);
-		luaCallIns.ProjectileCreated(pp);
+		ProjectileMapPair pp(p, p-&gt;owner ? p-&gt;owner-&gt;allyteam : -1);
 		weaponProjectileIDs[p-&gt;id] = pp;
+		eventHandler.ProjectileCreated(pp.first, pp.second);
 	}
 }
 

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.h
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -19,12 +19,15 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;float3.h&quot;
 
+
+class CGroundFlash;
+class IFramebuffer;
+
+
 typedef std::list&lt;CProjectile*&gt; Projectile_List;
 typedef std::pair&lt;CProjectile*, int&gt; ProjectileMapPair;
 typedef std::map&lt;unsigned int, ProjectileMapPair&gt; ProjectileMap;
 
-class CGroundFlash;
-class IFramebuffer;
 
 class CProjectileHandler
 {
@@ -35,6 +38,14 @@
 	void Serialize(creg::ISerializer *s);
 	void PostLoad();
 
+	inline const ProjectileMapPair* GetMapPairByID(int id) const {
+		ProjectileMap::const_iterator it = weaponProjectileIDs.find(id);
+		if (it == weaponProjectileIDs.end()) {
+			return NULL;
+		}
+		return &amp;(it-&gt;second);
+	}
+
 	void CheckUnitCol();
 	void LoadSmoke(unsigned char tex[512][512][4], int xoffs, int yoffs, char* filename, char* alphafile);
 
@@ -58,8 +69,9 @@
 	};
 
 	Projectile_List ps;						// contains both synced and unsynced projectiles
+	int maxUsedID;
+	std::list&lt;int&gt; freeIDs;
 	ProjectileMap weaponProjectileIDs;		// ID ==&gt; &lt;projectile, allyteam&gt; map for weapon projectiles
-	unsigned int curWeaponProjectileID;		// enough IDs for 40 hours at 1000 projectiles per frame
 
 	std::vector&lt;projdist&gt; distlist;
 
@@ -142,7 +154,11 @@
 	IFramebuffer *perlinFB;
 	bool drawPerlinTex;
 	std::vector&lt;CGroundFlash*&gt; groundFlashes;
+
 };
+
+
 extern CProjectileHandler* ph;
 
+
 #endif /* PROJECTILEHANDLER_H */

Modified: trunk/rts/Sim/SideParser.cpp
===================================================================
--- trunk/rts/Sim/SideParser.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/SideParser.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -34,6 +34,14 @@
 
 	LuaParser parser(&quot;gamedata/sidedata.lua&quot;,
 	                 SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+#if !defined UNITSYNC &amp;&amp; !defined DEDICATED
+	// this should not be included with unitsync:
+	// 1. avoids linkage with LuaSyncedRead
+	// 2. ModOptions are not valid during unitsync mod parsing
+	parser.GetTable(&quot;Spring&quot;);
+	parser.AddFunc(&quot;GetModOptions&quot;, LuaSyncedRead::GetModOptions);
+	parser.EndTable();
+#endif
 	if (!parser.Execute()) {
 		errorLog = parser.GetErrorLog();
 		return false;

Modified: trunk/rts/Sim/Units/COB/CobInstance.cpp
===================================================================
--- trunk/rts/Sim/Units/COB/CobInstance.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/COB/CobInstance.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -1575,33 +1575,23 @@
 			break;
 		}
 		case RADAR_RADIUS: {
-			radarhandler-&gt;RemoveUnit(unit);
-			unit-&gt;radarRadius = param;
-			radarhandler-&gt;MoveUnit(unit);
+			unit-&gt;ChangeSensorRadius(&amp;unit-&gt;radarRadius, param);
 			break;
 		}
 		case JAMMER_RADIUS: {
-			radarhandler-&gt;RemoveUnit(unit);
-			unit-&gt;jammerRadius = param;
-			radarhandler-&gt;MoveUnit(unit);
+			unit-&gt;ChangeSensorRadius(&amp;unit-&gt;jammerRadius, param);
 			break;
 		}
 		case SONAR_RADIUS: {
-			radarhandler-&gt;RemoveUnit(unit);
-			unit-&gt;sonarRadius = param;
-			radarhandler-&gt;MoveUnit(unit);
+			unit-&gt;ChangeSensorRadius(&amp;unit-&gt;sonarRadius, param);
 			break;
 		}
 		case SONAR_JAM_RADIUS: {
-			radarhandler-&gt;RemoveUnit(unit);
-			unit-&gt;sonarJamRadius = param;
-			radarhandler-&gt;MoveUnit(unit);
+			unit-&gt;ChangeSensorRadius(&amp;unit-&gt;sonarJamRadius, param);
 			break;
 		}
 		case SEISMIC_RADIUS: {
-			radarhandler-&gt;RemoveUnit(unit);
-			unit-&gt;seismicRadius = param;
-			radarhandler-&gt;MoveUnit(unit);
+			unit-&gt;ChangeSensorRadius(&amp;unit-&gt;seismicRadius, param);
 			break;
 		}
 		case CURRENT_FUEL: {

Modified: trunk/rts/Sim/Units/CommandAI/Command.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/Command.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/CommandAI/Command.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -29,10 +29,10 @@
 				CR_MEMBER(mouseicon),
 				CR_MEMBER(tooltip),
 
+				CR_MEMBER(hidden),
+				CR_MEMBER(disabled),
 				CR_MEMBER(showUnique),
-				CR_MEMBER(onlyKey),
 				CR_MEMBER(onlyTexture),
-				CR_MEMBER(disabled),
 
 				CR_MEMBER(params),
 				CR_RESERVED(32)

Modified: trunk/rts/Sim/Units/CommandAI/Command.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/Command.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/CommandAI/Command.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -112,10 +112,10 @@
 	CR_DECLARE_STRUCT(CommandDescription);
 
 	CommandDescription()
-	: showUnique(false),
-	  onlyKey(false),
-	  onlyTexture(false),
-	  disabled(false) {};
+	: hidden(false),
+	  disabled(false),
+	  showUnique(false),
+	  onlyTexture(false) {}
 
 	int id;    // CMD_xxx     code  (custom codes can also be used)
 	int type;  // CMDTYPE_xxx code 
@@ -126,10 +126,10 @@
 	std::string mouseicon;  // mouse cursor
 	std::string tooltip;    // tooltip text
 
+	bool hidden;       // if true dont show a button for the command
+	bool disabled;     // for greying-out commands
 	bool showUnique;   // command only applies to single units
-	bool onlyKey;      // if true dont show a button for the command
 	bool onlyTexture;  // do not draw the name if the texture is available
-	bool disabled;     // for greying-out commands
 
 	std::vector&lt;std::string&gt; params;
 };

Modified: trunk/rts/Sim/Units/CommandAI/CommandAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -11,8 +11,8 @@
 #include &quot;Game/UI/CursorIcons.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/glExtra.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
+#include &quot;Map/Ground.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/MoveTypes/MoveType.h&quot;
@@ -23,7 +23,7 @@
 #include &quot;Sim/Units/UnitTypes/Factory.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
-#include &quot;Map/Ground.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;LoadSaveInterface.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;myMath.h&quot;
@@ -141,9 +141,9 @@
 	c.tooltip = &quot;TimeWait: Wait for a period of time before continuing&quot;;
 	c.params.push_back(&quot;1&quot;);  // min
 	c.params.push_back(&quot;60&quot;); // max
-	c.onlyKey = true;
+	c.hidden = true;
 	possibleCommands.push_back(c);
- 	c.onlyKey = false;
+ 	c.hidden = false;
 	c.params.clear();
 
 	// only for games with 2 ally teams  --  checked later
@@ -153,9 +153,9 @@
 	c.name = &quot;DeathWait&quot;;
 	c.mouseicon=c.name;
 	c.tooltip = &quot;DeathWait: Wait until units die before continuing&quot;;
-	c.onlyKey = true;
+	c.hidden = true;
 	possibleCommands.push_back(c);
- 	c.onlyKey = false;
+ 	c.hidden = false;
 
 	c.id = CMD_SQUADWAIT;
 	c.action = &quot;squadwait&quot;;
@@ -165,9 +165,9 @@
 	c.tooltip = &quot;SquadWait: Wait for a number of units to arrive before continuing&quot;;
 	c.params.push_back(&quot;2&quot;);   // min
 	c.params.push_back(&quot;100&quot;); // max
-	c.onlyKey = true;
+	c.hidden = true;
 	possibleCommands.push_back(c);
- 	c.onlyKey = false;
+ 	c.hidden = false;
 	c.params.clear();
 
 	c.id = CMD_GATHERWAIT;
@@ -176,9 +176,9 @@
 	c.name = &quot;GatherWait&quot;;
 	c.mouseicon=c.name;
 	c.tooltip = &quot;GatherWait: Wait until all units arrive before continuing&quot;;
-	c.onlyKey = true;
+	c.hidden = true;
 	possibleCommands.push_back(c);
- 	c.onlyKey = false;
+ 	c.hidden = false;
 
 	if (owner-&gt;unitDef-&gt;canSelfD) {
 		c.id = CMD_SELFD;
@@ -187,9 +187,9 @@
 		c.name = &quot;SelfD&quot;;
 		c.mouseicon = c.name;
 		c.tooltip = &quot;SelfD: Tells the unit to self destruct&quot;;
-		c.onlyKey = true;
+		c.hidden = true;
 		possibleCommands.push_back(c);
-	 	c.onlyKey = false;
+	 	c.hidden = false;
 	}
 //	nonQueingCommands.insert(CMD_SELFD);
 
@@ -456,6 +456,7 @@
 	if (luaRules &amp;&amp; !luaRules-&gt;AllowCommand(owner, c, fromSynced)) {
 		return;
 	}
+	eventHandler.UnitCommand(owner, c);
 	this-&gt;GiveCommandReal(c); // send to the sub-classes
 }
 
@@ -729,7 +730,7 @@
 		if (!owner-&gt;group) {
 			globalAI-&gt;UnitIdle(owner);
 		}
-		luaCallIns.UnitIdle(owner);
+		eventHandler.UnitIdle(owner);
 	}
 
 	return;
@@ -832,7 +833,7 @@
 		if (owner-&gt;group) {
 			owner-&gt;group-&gt;CommandFinished(owner-&gt;id, cmd.id);
 		}
-		luaCallIns.UnitCmdDone(owner, cmd.id, cmd.tag);
+		eventHandler.UnitCmdDone(owner, cmd.id, cmd.tag);
 	}
 
 	queue-&gt;insert(insertIt, newCmd);
@@ -1354,13 +1355,13 @@
 	if (owner-&gt;group) {
 		owner-&gt;group-&gt;CommandFinished(owner-&gt;id, cmdID);
 	}
-	luaCallIns.UnitCmdDone(owner, cmdID, cmdTag);
+	eventHandler.UnitCmdDone(owner, cmdID, cmdTag);
 
 	if (commandQue.empty()) {
 		if (!owner-&gt;group) {
 			globalAI-&gt;UnitIdle(owner);
 		}
-		luaCallIns.UnitIdle(owner);
+		eventHandler.UnitIdle(owner);
 	}
 
 	if (lastFinishCommand != gs-&gt;frameNum) {	//avoid infinite loops

Modified: trunk/rts/Sim/Units/CommandAI/CommandQueue.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/CommandQueue.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/CommandAI/CommandQueue.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -42,16 +42,16 @@
 		inline void push_back(const Command&amp; cmd);
 		inline void push_front(const Command&amp; cmd);
 
-		inline void insert(iterator pos, const Command&amp; cmd);
+		inline iterator insert(iterator pos, const Command&amp; cmd);
 
 		inline void pop_back()  { queue.pop_back(); }
 		inline void pop_front() { queue.pop_front(); }
 
-		inline void erase(iterator pos) {
-			queue.erase(pos);
+		inline iterator erase(iterator pos) {
+			return queue.erase(pos);
 		}
-		inline void erase(iterator first, iterator last) {
-			queue.erase(first, last);
+		inline iterator erase(iterator first, iterator last) {
+			return queue.erase(first, last);
 		}
 		inline void clear() { queue.clear(); }
 
@@ -116,11 +116,12 @@
 }
 
 
-inline void CCommandQueue::insert(iterator pos, const Command&amp; cmd)
+inline CCommandQueue::iterator CCommandQueue::insert(iterator pos,
+                                                     const Command&amp; cmd)
 {
 	Command tmpCmd = cmd;
 	tmpCmd.tag = GetNextTag();
-	queue.insert(pos, tmpCmd);
+	return queue.insert(pos, tmpCmd);
 }
 
 

Modified: trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -99,9 +99,9 @@
 	c.name=&quot;Load units&quot;;
 	c.mouseicon=c.name;
 	c.tooltip=&quot;Sets the unit to load itself onto a transport&quot;;
-	c.onlyKey = true;
+	c.hidden = true;
 	possibleCommands.push_back(c);
-	c.onlyKey = false;
+	c.hidden = false;
 
 	if (owner-&gt;unitDef-&gt;canmove) {
 		c.id=CMD_MOVE;

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -17,7 +17,6 @@
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Game/UI/MiniMap.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MetalMap.h&quot;
@@ -47,6 +46,7 @@
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;System/LoadSaveInterface.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Matrix44f.h&quot;
@@ -132,7 +132,8 @@
 	los(0),
 	userAttackPos(0,0,0),
 	crashing(false),
-	cob(0),
+	cob(NULL),
+	script(NULL),
 	flankingBonusMode(0),
 	flankingBonusDir(1.0f, 0.0f, 0.0f),
 	flankingBonusAvgDamage(1.4f),
@@ -294,6 +295,7 @@
 	}
 
 	delete cob;
+	//FIXME delete script;
 	delete localmodel;
 }
 
@@ -410,6 +412,7 @@
 	UpdateMidPos();
 }
 
+
 void CUnit::SetRight(const SyncedFloat3&amp; newDir)
 {
 	rightdir = newDir;
@@ -422,12 +425,14 @@
 	UpdateMidPos();
 }
 
+
 void CUnit::UpdateMidPos()
 {
 	midPos = pos + (frontdir * relMidPos.z) + (updir * relMidPos.y)
 		+ (rightdir * relMidPos.x);
 }
 
+
 void CUnit::Drop(float3 parentPos,float3 parentDir, CUnit* parent)
 {
 	//drop unit from position
@@ -515,16 +520,16 @@
 
 	if (inAir != oldInAir) {
 		if (inAir) {
-			luaCallIns.UnitEnteredAir(this);
+			eventHandler.UnitEnteredAir(this);
 		} else {
-			luaCallIns.UnitLeftAir(this);
+			eventHandler.UnitLeftAir(this);
 		}
 	}
 	if (inWater != oldInWater) {
 		if (inWater) {
-			luaCallIns.UnitEnteredWater(this);
+			eventHandler.UnitEnteredWater(this);
 		} else {
-			luaCallIns.UnitLeftWater(this);
+			eventHandler.UnitLeftWater(this);
 		}
 	}
 
@@ -578,20 +583,20 @@
 	if (diffBits) {
 		if (diffBits &amp; LOS_INLOS) {
 			if (newStatus &amp; LOS_INLOS) {
-				luaCallIns.UnitEnteredLos(this, at);
+				eventHandler.UnitEnteredLos(this, at);
 				globalAI-&gt;UnitEnteredLos(this, at);
 			} else {
-				luaCallIns.UnitLeftLos(this, at);
+				eventHandler.UnitLeftLos(this, at);
 				globalAI-&gt;UnitLeftLos(this, at);
 			}
 		}
 
 		if (diffBits &amp; LOS_INRADAR) {
 			if (newStatus &amp; LOS_INRADAR) {
-				luaCallIns.UnitEnteredRadar(this, at);
+				eventHandler.UnitEnteredRadar(this, at);
 				globalAI-&gt;UnitEnteredRadar(this, at);
 			} else {
-				luaCallIns.UnitLeftRadar(this, at);
+				eventHandler.UnitLeftRadar(this, at);
 				globalAI-&gt;UnitLeftRadar(this, at);
 			}
 		}
@@ -670,7 +675,7 @@
 
 	if (stunned) {
 		// de-stun only if we are not (still) inside a non-firebase transport
-		if (paralyzeDamage &lt; health &amp;&amp; !(transporter &amp;&amp; !transporter-&gt;unitDef-&gt;isfireplatform) ) {
+		if (paralyzeDamage &lt; health &amp;&amp; !(transporter &amp;&amp; !transporter-&gt;unitDef-&gt;isFirePlatform) ) {
 			stunned = false;
 		}
 		const bool oldCloak = isCloaked;
@@ -681,9 +686,9 @@
 		}
 		if (oldCloak != isCloaked) {
 			if (isCloaked) {
-				luaCallIns.UnitCloaked(this);
+				eventHandler.UnitCloaked(this);
 			} else {
-				luaCallIns.UnitDecloaked(this);
+				eventHandler.UnitDecloaked(this);
 			}
 		}
 		UpdateResources();
@@ -819,9 +824,9 @@
 
 	if (oldCloak != isCloaked) {
 		if (isCloaked) {
-			luaCallIns.UnitCloaked(this);
+			eventHandler.UnitCloaked(this);
 		} else {
-			luaCallIns.UnitDecloaked(this);
+			eventHandler.UnitDecloaked(this);
 		}
 	}
 
@@ -889,6 +894,7 @@
 	UpdateTerrainType();
 }
 
+
 void CUnit::SetDirectionFromHeading(void)
 {
 	frontdir=GetVectorFromHeading(heading);
@@ -908,6 +914,7 @@
 	}
 }
 
+
 void CUnit::DoDamage(const DamageArray&amp; damages, CUnit *attacker,const float3&amp; impulse, int weaponId)
 {
 	if (isDead) {
@@ -1064,7 +1071,7 @@
 		}
 	}
 
-	luaCallIns.UnitDamaged(this, attacker, damage, weaponId, !!damages.paralyzeDamageTime);
+	eventHandler.UnitDamaged(this, attacker, damage, weaponId, !!damages.paralyzeDamageTime);
 	globalAI-&gt;UnitDamaged(this, attacker, damage);
 
 	if (health &lt;= 0.0f) {
@@ -1153,6 +1160,29 @@
 /******************************************************************************/
 /******************************************************************************/
 
+void CUnit::ChangeSensorRadius(int* valuePtr, int newValue)
+{
+	if (hasRadarCapacity) {
+		radarhandler-&gt;RemoveUnit(this);
+	}
+
+	*valuePtr = newValue;
+
+	if (newValue != 0) {
+		hasRadarCapacity = true;
+	}
+	else if (hasRadarCapacity) {
+		hasRadarCapacity = radarRadius || jammerRadius   ||
+		                   sonarRadius || sonarJamRadius ||
+		                   seismicRadius;
+	}
+
+	if (hasRadarCapacity) {
+		radarhandler-&gt;MoveUnit(this);
+	}
+}
+
+
 void CUnit::AddExperience(float exp)
 {
 	const float oldExp = experience;
@@ -1165,7 +1195,7 @@
 		const int oldGrade = (int)(oldLimExp     / expGrade);
 		const int newGrade = (int)(limExperience / expGrade);
 		if (oldGrade != newGrade) {
-			luaCallIns.UnitExperience(this, oldExp);
+			eventHandler.UnitExperience(this, oldExp);
 		}
 	}
 
@@ -1198,12 +1228,12 @@
 		                             ph-&gt;seismictex, 30, 15, 0, pingSize, 1,
 		                             float3(0.8f,0.0f,0.0f));
 	}
-	for (int a=0; a&lt;gs-&gt;activeAllyTeams; ++a) {
+	for (int a = 0; a &lt; gs-&gt;activeAllyTeams; ++a) {
 		if (radarhandler-&gt;InSeismicDistance(this, a)) {
 			const float3 err(errorScale[a] * (0.5f - rx), 0.0f,
-							 errorScale[a] * (0.5f - rz));
+			                 errorScale[a] * (0.5f - rz));
 			const float3 pingPos = (pos + err);
-			luaCallIns.UnitSeismicPing(this, a, pingPos, pingSize);
+			eventHandler.UnitSeismicPing(this, a, pingPos, pingSize);
 			globalAI-&gt;SeismicPing(a, this, pingPos, pingSize);
 		}
 	}
@@ -1250,7 +1280,7 @@
 	selectedUnits.RemoveUnit(this);
 	SetGroup(0);
 
-	luaCallIns.UnitTaken(this, newteam);
+	eventHandler.UnitTaken(this, newteam);
 	globalAI-&gt;UnitTaken(this, oldteam);
 
 	// reset states and clear the queues
@@ -1321,7 +1351,7 @@
 		airBaseHandler-&gt;RegisterAirBase(this);
 	}
 
-	luaCallIns.UnitGiven(this, oldteam);
+	eventHandler.UnitGiven(this, oldteam);
 	globalAI-&gt;UnitGiven(this, oldteam);
 
 	return true;
@@ -1551,7 +1581,7 @@
 		c.params.clear();
 	}
 
-	luaCallIns.UnitCreated(this, builder);
+	eventHandler.UnitCreated(this, builder);
 	globalAI-&gt;UnitCreated(this); // FIXME -- add builder?
 }
 
@@ -1746,11 +1776,11 @@
 		airBaseHandler-&gt;RegisterAirBase(this);
 	}
 
-	luaCallIns.UnitFinished(this);
+	eventHandler.UnitFinished(this);
 	globalAI-&gt;UnitFinished(this);
 
 	if (oldCloak != isCloaked) {
-		luaCallIns.UnitCloaked(this); // do this after the UnitFinished call-in
+		eventHandler.UnitCloaked(this); // do this after the UnitFinished call-in
 	}
 
 	if (unitDef-&gt;isFeature &amp;&amp; uh-&gt;morphUnitToFeature) {
@@ -1792,7 +1822,7 @@
 	isDead = true;
 	deathSpeed = speed;
 
-	luaCallIns.UnitDestroyed(this, attacker);
+	eventHandler.UnitDestroyed(this, attacker);
 	globalAI-&gt;UnitDestroyed(this, attacker);
 
 	blockHeightChanges = false;
@@ -1962,12 +1992,10 @@
 
 void CUnit::PushWind(float x, float z, float strength)
 {
-	if(strength &gt; unitDef-&gt;windGenerator)
-	{
+	if (strength &gt; unitDef-&gt;windGenerator) {
 		cob-&gt;Call(COBFN_SetSpeed, (int)(unitDef-&gt;windGenerator*3000.0f));
 	}
-	else
-	{
+	else {
 		cob-&gt;Call(COBFN_SetSpeed, (int)(strength*3000.0f));
 	}
 
@@ -2110,6 +2138,8 @@
 	model = unitDef-&gt;LoadModel(team);
 	SetRadius(model-&gt;radius);
 
+	//FIXME script = SAFE_NEW CUnitScript(this);
+	//FIXME localmodel = modelParser-&gt;CreateLocalModel(model, script-&gt;GetPieces());
 	cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + unitDef-&gt;name+&quot;.cob&quot;), this);
 	localmodel = modelParser-&gt;CreateLocalModel(model, &amp;cob-&gt;pieces);
 
@@ -2309,6 +2339,7 @@
 				CR_RESERVED(32),
 				//CR_MEMBER(model),
 				//CR_MEMBER(cob),
+				//CR_MEMBER(script),
 				//CR_MEMBER(localmodel),
 
 				CR_MEMBER(tooltip),

Modified: trunk/rts/Sim/Units/Unit.h
===================================================================
--- trunk/rts/Sim/Units/Unit.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/Unit.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -21,6 +21,7 @@
 class AMoveType;
 class CUnitAI;
 class CWeapon;
+class CUnitScript;
 struct DamageArray;
 struct LocalS3DOModel;
 struct LosInstance;
@@ -83,6 +84,7 @@
 	virtual void Kill(float3&amp; impulse);
 	virtual void FinishedBuilding(void);
 	void ChangeLos(int l, int airlos);
+	void ChangeSensorRadius(int* valuePtr, int newValue);
 	bool AddBuildPower(float amount,CUnit* builder);		//negative amount=reclaim, return= true -&gt; build power was succesfully applied
 	void Activate();		//turn the unit on
 	void Deactivate();		//turn the unit off
@@ -310,6 +312,7 @@
 	//CUnit3DLoader::UnitModel* model;
 	S3DOModel *model;
 	CCobInstance *cob;
+	CUnitScript* script;
 	LocalS3DOModel *localmodel;
 
 	std::string tooltip;

Modified: trunk/rts/Sim/Units/UnitDef.h
===================================================================
--- trunk/rts/Sim/Units/UnitDef.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitDef.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -13,7 +13,7 @@
 struct MoveData;
 struct WeaponDef;
 struct S3DOModel;
-struct UnitImage;
+struct UnitDefImage;
 struct CollisionVolume;
 class CExplosionGenerator;
 
@@ -93,7 +93,6 @@
 	~UnitDef();
 	S3DOModel* LoadModel(int team) const;
 
-	UnitImage* unitImage;	// GLuint wrapper pointing to build-pic data of this unit type
 	bool valid;
 	std::string name;
 	std::string humanName;
@@ -231,9 +230,12 @@
 	std::string deathExplosion;
 	std::string selfDExplosion;
 
-	std::string TEDClassString;	//these might be changed later for something better
+	std::string TEDClassString;	// these might be changed later for something better
 	std::string categoryString;
 
+	std::string buildPicName;
+	mutable UnitDefImage* buildPic;
+
 	mutable CIcon iconType;
 
 	bool canSelfD;
@@ -310,6 +312,7 @@
 	int transportSize;
 	int minTransportSize;
 	bool isAirBase;
+	bool isFirePlatform;							// should the carried units still be able to shoot?
 	float transportMass;
 	float minTransportMass;
 	bool holdSteady;
@@ -384,7 +387,6 @@
 	int buildingDecalSizeX;
 	int buildingDecalSizeY;
 	float buildingDecalDecaySpeed;
-	bool isfireplatform;							// should the carried units still be able to shoot?
 
 	bool showNanoFrame;								// Does the nano frame animation get shown during construction?
 	bool showNanoSpray;								// Does nano spray get shown at all?

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -7,7 +7,7 @@
 #include &lt;cctype&gt;
 
 #include &quot;UnitDef.h&quot;
-#include &quot;UnitImage.h&quot;
+#include &quot;UnitDefImage.h&quot;
 
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;Game/Game.h&quot;
@@ -119,10 +119,10 @@
 		unitDefs[id].name = unitName;
 		unitDefs[id].id = id;
 		unitDefs[id].buildangle = 0;
-		unitDefs[id].unitImage  = 0;
-		unitDefs[id].collisionVolume = 0;
+		unitDefs[id].buildPic   = NULL;
+		unitDefs[id].decoyDef   = NULL;
 		unitDefs[id].techLevel  = -1;
-		unitDefs[id].decoyDef   = NULL;
+		unitDefs[id].collisionVolume = NULL;
 		unitID[unitName] = id;
 		for (int ym = 0; ym &lt; 4; ym++) {
 			unitDefs[id].yardmaps[ym] = 0;
@@ -150,18 +150,23 @@
 {
 	// delete any eventual yardmaps
 	for (int i = 1; i &lt;= numUnitDefs; i++) {
-		for (int u = 0; u &lt; 4; u++)
-			delete[] unitDefs[i].yardmaps[u];
+		UnitDef&amp; ud = unitDefs[i];
+		for (int u = 0; u &lt; 4; u++) {
+			delete[] ud.yardmaps[u];
+		}
 
-		if (unitDefs[i].unitImage) {
-			glDeleteTextures(1, &amp;unitDefs[i].unitImage-&gt;textureID);
-			delete unitDefs[i].unitImage;
-			unitDefs[i].unitImage = 0;
+		if (ud.buildPic) {
+			if (ud.buildPic-&gt;textureOwner) {
+				glDeleteTextures(1, &amp;unitDefs[i].buildPic-&gt;textureID);
+			}
+			delete ud.buildPic;
+			ud.buildPic = NULL;
 		}
 
-		delete unitDefs[i].collisionVolume;
-		unitDefs[i].collisionVolume = 0;
+		delete ud.collisionVolume;
+		ud.collisionVolume = NULL;
 	}
+
 	delete[] unitDefs;
 	delete weaponDefHandler;
 }
@@ -240,7 +245,7 @@
 	UnitDef&amp; ud = unitDefs[id];
 
 	// allocate and fill ud-&gt;unitImage
-	GetUnitImage(&amp;unitDefs[id], udTable.GetString(&quot;buildPic&quot;, &quot;&quot;));
+	ud.buildPicName = udTable.GetString(&quot;buildPic&quot;, &quot;&quot;);
 
 	ud.humanName = udTable.GetString(&quot;name&quot;, &quot;&quot;);
 
@@ -452,7 +457,7 @@
 	ud.transportSize     = udTable.GetInt(&quot;transportSize&quot;,      0);
 	ud.minTransportSize  = udTable.GetInt(&quot;minTransportSize&quot;,   0);
 	ud.transportCapacity = udTable.GetInt(&quot;transportCapacity&quot;,  0);
-	ud.isfireplatform    = udTable.GetBool(&quot;isFirePlatform&quot;,    false);
+	ud.isFirePlatform    = udTable.GetBool(&quot;isFirePlatform&quot;,    false);
 	ud.isAirBase         = udTable.GetBool(&quot;isAirBase&quot;,         false);
 	ud.loadingRadius     = udTable.GetFloat(&quot;loadingRadius&quot;,    220.0f);
 	ud.unloadSpread      = udTable.GetFloat(&quot;unloadSpread&quot;,     1.0f);
@@ -974,39 +979,63 @@
 }
 
 
-unsigned int CUnitDefHandler::GetUnitImage(const UnitDef* unitdef, std::string buildPicName)
+unsigned int CUnitDefHandler::GetUnitDefImage(const UnitDef* unitDef)
 {
-	if (unitdef-&gt;unitImage != 0) {
-		return (unitdef-&gt;unitImage-&gt;textureID);
+	if (unitDef-&gt;buildPic != NULL) {
+		return (unitDef-&gt;buildPic-&gt;textureID);
 	}
-
+	SetUnitDefImage(unitDef, unitDef-&gt;buildPicName);
+	return unitDef-&gt;buildPic-&gt;textureID;
+}
+	
+	
+void CUnitDefHandler::SetUnitDefImage(const UnitDef* unitDef,
+                                      const std::string&amp; texName)
+{
+	if (unitDef-&gt;buildPic == NULL) {
+		unitDef-&gt;buildPic = SAFE_NEW UnitDefImage;
+	} else if (unitDef-&gt;buildPic-&gt;textureOwner) {
+		glDeleteTextures(1, &amp;unitDef-&gt;buildPic-&gt;textureID);
+	}
+		
 	CBitmap bitmap;
 
-	if (!buildPicName.empty()) {
-		bitmap.Load(&quot;unitpics/&quot; + buildPicName);
+	if (!texName.empty()) {
+		bitmap.Load(&quot;unitpics/&quot; + texName);
 	}
 	else {
-		if (!LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.dds&quot;, bitmap) &amp;&amp;
-		    !LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.png&quot;, bitmap) &amp;&amp;
-		    !LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.pcx&quot;, bitmap) &amp;&amp;
-		    !LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.bmp&quot;, bitmap)) {
+		if (!LoadBuildPic(&quot;unitpics/&quot; + unitDef-&gt;name + &quot;.dds&quot;, bitmap) &amp;&amp;
+		    !LoadBuildPic(&quot;unitpics/&quot; + unitDef-&gt;name + &quot;.png&quot;, bitmap) &amp;&amp;
+		    !LoadBuildPic(&quot;unitpics/&quot; + unitDef-&gt;name + &quot;.pcx&quot;, bitmap) &amp;&amp;
+		    !LoadBuildPic(&quot;unitpics/&quot; + unitDef-&gt;name + &quot;.bmp&quot;, bitmap)) {
 			bitmap.Alloc(1, 1); // last resort
 		}
 	}
 
 	const unsigned int texID = bitmap.CreateTexture(false);
 
-	PUSH_CODE_MODE;
-	ENTER_SYNCED;
-	UnitDef&amp; ud = unitDefs[unitdef-&gt;id]; // get away with the const
-	ud.unitImage = SAFE_NEW UnitImage;
-	ud.unitImage-&gt;buildPicName = buildPicName;
-	ud.unitImage-&gt;textureID = texID;
-	ud.unitImage-&gt;imageSizeX = bitmap.xsize;
-	ud.unitImage-&gt;imageSizeY = bitmap.ysize;
-	POP_CODE_MODE;
+	UnitDefImage* unitImage = unitDef-&gt;buildPic;
+	unitImage-&gt;textureID = texID;
+	unitImage-&gt;textureOwner = true;
+	unitImage-&gt;imageSizeX = bitmap.xsize;
+	unitImage-&gt;imageSizeY = bitmap.ysize;
+}
 
-	return texID;
+
+void CUnitDefHandler::SetUnitDefImage(const UnitDef* unitDef,
+                                      unsigned int texID, int xsize, int ysize)
+{
+	if (unitDef-&gt;buildPic == NULL) {
+		unitDef-&gt;buildPic = SAFE_NEW UnitDefImage;
+	} else if (unitDef-&gt;buildPic-&gt;textureOwner) {
+		glDeleteTextures(1, &amp;unitDef-&gt;buildPic-&gt;textureID);
+	}
+
+	UnitDefImage* unitImage = unitDef-&gt;buildPic;
+	unitImage-&gt;textureID = texID;
+	unitImage-&gt;textureOwner = false;
+	unitImage-&gt;imageSizeX = xsize;
+	unitImage-&gt;imageSizeY = ysize;
 }
 
 

Modified: trunk/rts/Sim/Units/UnitDefHandler.h
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitDefHandler.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -31,7 +31,13 @@
 	void AssignTechLevels();
 	const UnitDef* GetUnitByName(std::string name);
 	const UnitDef* GetUnitByID(int id);
-	unsigned int GetUnitImage(const UnitDef* unitdef, std::string buildPicName = &quot;&quot;);
+
+	unsigned int GetUnitDefImage(const UnitDef* unitDef);
+	void SetUnitDefImage(const UnitDef* unitDef,
+	                     const std::string&amp; texName);
+	void SetUnitDefImage(const UnitDef* unitDef,
+	                     unsigned int texID, int sizex, int sizey);
+
 	bool SaveTechLevels(const std::string&amp; filename, const std::string&amp; modname);
 
 	bool noCost;

Copied: trunk/rts/Sim/Units/UnitDefImage.h (from rev 6096, trunk/rts/Sim/Units/UnitImage.h)
===================================================================
--- trunk/rts/Sim/Units/UnitDefImage.h	                        (rev 0)
+++ trunk/rts/Sim/Units/UnitDefImage.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -0,0 +1,19 @@
+#ifndef UNIT_DEF_IMAGE
+#define UNIT_DEF_IMAGE
+
+#include &quot;StdAfx.h&quot;
+#include &quot;creg/creg.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+
+struct UnitDefImage
+{
+	CR_DECLARE_STRUCT(UnitDefImage);
+	UnitDefImage() { imageSizeX = -1; imageSizeY = -1; }
+
+	int imageSizeX;
+	int imageSizeY;
+	GLuint textureID;
+	bool textureOwner; 
+};
+
+#endif // UNIT_DEF_IMAGE

Modified: trunk/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -196,8 +196,8 @@
 	// builds say many buildings at once and then many mobile ones etc)
 	activeUnits.insert(ui, unit);
 
-	// randomize the unitID assignment so that lua widgets
-	// can't determine enemy unit counts from unitIDs alone
+	// randomize the unitID assignment so that lua widgets can
+	// not easily determine enemy unit counts from unitIDs alone
 	assert(freeIDs.size() &gt; 0);
 	const unsigned int freeSlot = gs-&gt;randInt() % freeIDs.size();
 	const unsigned int freeMax  = freeIDs.size() - 1;

Deleted: trunk/rts/Sim/Units/UnitImage.h
===================================================================
--- trunk/rts/Sim/Units/UnitImage.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitImage.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -1,19 +0,0 @@
-#ifndef UNIT_IMAGE
-#define UNIT_IMAGE
-
-#include &quot;StdAfx.h&quot;
-#include &quot;creg/creg.h&quot;
-#include &quot;Rendering/GL/myGL.h&quot;
-
-struct UnitImage
-{
-	CR_DECLARE_STRUCT(UnitImage);
-	UnitImage() { imageSizeX = -1; imageSizeY = -1; }
-
-	std::string buildPicName;
-	int imageSizeX;
-	int imageSizeY;
-	GLuint textureID;
-};
-
-#endif

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -214,7 +214,7 @@
 		SAFE_NEW CCommandAI(unit);
 	}
 
-	if (ud-&gt;canmove &amp;&amp; !ud-&gt;canfly &amp;&amp; type!=&quot;Factory&quot;) {
+	if (ud-&gt;canmove &amp;&amp; !ud-&gt;canfly &amp;&amp; (type != &quot;Factory&quot;)) {
 		CGroundMoveType* mt = SAFE_NEW CGroundMoveType(unit);
 		mt-&gt;maxSpeed = ud-&gt;speed / GAME_SPEED;
 		mt-&gt;maxWantedSpeed = ud-&gt;speed / GAME_SPEED;
@@ -228,7 +228,8 @@
 		mt-&gt;moveType = ud-&gt;moveType;
 		mt-&gt;accRate = ud-&gt;maxAcc;
 		mt-&gt;decRate = ud-&gt;maxDec;
-		mt-&gt;floatOnWater = (ud-&gt;movedata-&gt;moveType == MoveData::Hover_Move || ud-&gt;movedata-&gt;moveType == MoveData::Ship_Move);
+		mt-&gt;floatOnWater = (ud-&gt;movedata-&gt;moveType == MoveData::Hover_Move ||
+		                    ud-&gt;movedata-&gt;moveType == MoveData::Ship_Move);
 
 		if (!unit-&gt;beingBuilt) {
 			// otherwise set this when finished building instead
@@ -260,7 +261,7 @@
 			mt-&gt;accRate = ud-&gt;maxAcc;
 			mt-&gt;decRate = ud-&gt;maxDec;
 			mt-&gt;wantedHeight = ud-&gt;wantedHeight + gs-&gt;randFloat() * 5;
-			mt-&gt;orgWantedHeight=mt-&gt;wantedHeight;
+			mt-&gt;orgWantedHeight = mt-&gt;wantedHeight;
 			mt-&gt;dontLand = ud-&gt;DontLand();
 			mt-&gt;collide = ud-&gt;collide;
 			mt-&gt;altitudeRate = ud-&gt;verticalSpeed;
@@ -284,7 +285,8 @@
 			mt-&gt;maxBank = ud-&gt;maxBank;
 			mt-&gt;maxPitch = ud-&gt;maxPitch;
 			mt-&gt;turnRadius = ud-&gt;turnRadius;
-			mt-&gt;wantedHeight = ud-&gt;wantedHeight*1.5f+(gs-&gt;randFloat()-0.3f)*15*(mt-&gt;isFighter?2:1);
+			mt-&gt;wantedHeight = (ud-&gt;wantedHeight * 1.5f) +
+			                   ((gs-&gt;randFloat() - 0.3f) * 15 * (mt-&gt;isFighter ? 2 : 1));
 
 			mt-&gt;maxAcc = ud-&gt;maxAcc;
 			mt-&gt;maxAileron = ud-&gt;maxAileron;
@@ -322,8 +324,6 @@
 		unit-&gt;collisionVolume-&gt;SetDefaultScale(unit-&gt;model-&gt;radius * scaleFactor);
 	}
 
-
-
 	if (ud-&gt;floater) {
 		// restrict our depth to our waterline
 		unit-&gt;pos.y = std::max(-ud-&gt;waterline, ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z));
@@ -454,11 +454,9 @@
 	weapon-&gt;metalFireCost = weapondef-&gt;metalcost;
 	weapon-&gt;energyFireCost = weapondef-&gt;energycost;
 
-
 	weapon-&gt;fireSoundId = weapondef-&gt;firesound.getID(0);
 	weapon-&gt;fireSoundVolume = weapondef-&gt;firesound.getVolume(0);
 
-
 	weapon-&gt;onlyForward = weapondef-&gt;onlyForward;
 	if (owner-&gt;unitDef-&gt;type == &quot;Fighter&quot; &amp;&amp; !owner-&gt;unitDef-&gt;hoverAttack) {
 		// fighter aircraft have too big tolerance in TA

Modified: trunk/rts/Sim/Units/UnitTypes/Builder.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Builder.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitTypes/Builder.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -10,7 +10,6 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
@@ -27,6 +26,7 @@
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -241,7 +241,7 @@
 				if (scriptCloak &lt;= 2) {
 					if (isCloaked) {
 						isCloaked = false;
-						luaCallIns.UnitDecloaked(this);
+						eventHandler.UnitDecloaked(this);
 					}
 					curCloakTimeout = gs-&gt;frameNum + cloakTimeout;
 				}
@@ -270,7 +270,7 @@
 		if (scriptCloak &lt;= 2) {
 			if (isCloaked) {
 				isCloaked = false;
-				luaCallIns.UnitDecloaked(this);
+				eventHandler.UnitDecloaked(this);
 			}
 			curCloakTimeout = gs-&gt;frameNum + cloakTimeout;
 		}

Modified: trunk/rts/Sim/Units/UnitTypes/Factory.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Factory.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitTypes/Factory.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -13,7 +13,6 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
@@ -26,6 +25,7 @@
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Matrix44f.h&quot;
@@ -224,7 +224,7 @@
 				}
 				waitCommandsAI.AddLocalUnit(curBuild, this);
 			}
-			luaCallIns.UnitFromFactory(curBuild, this, userOrders);
+			eventHandler.UnitFromFactory(curBuild, this, userOrders);
 
 			StopBuild();
 		}

Modified: trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -1,6 +1,6 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;TransportUnit.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Sim/MoveTypes/TAAirMoveType.h&quot;
 #include &quot;Sim/MoveTypes/GroundMoveType.h&quot;
@@ -8,7 +8,7 @@
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Misc/DamageArray.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
-#include &quot;Game/SelectedUnits.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;creg/STL_List.h&quot;
 #include &quot;mmgr.h&quot;
@@ -110,7 +110,7 @@
 			}
 			ti-&gt;unit-&gt;speed = speed;
 
-			luaCallIns.UnitUnloaded(ti-&gt;unit, this);
+			eventHandler.UnitUnloaded(ti-&gt;unit, this);
 		}
 	}
 
@@ -151,7 +151,7 @@
 	unit-&gt;AddDeathDependence (this);
 	unit-&gt;transporter = this;
 	unit-&gt;toBeTransported=false;
-	if (!unitDef-&gt;isfireplatform) {
+	if (!unitDef-&gt;isFirePlatform) {
 		unit-&gt;stunned=true;	//make sure unit doesnt fire etc in transport
 		selectedUnits.RemoveUnit(unit);
 	}
@@ -173,7 +173,7 @@
 	unit-&gt;CalculateTerrainType();
 	unit-&gt;UpdateTerrainType();
 
-	luaCallIns.UnitLoaded(unit, this);
+	eventHandler.UnitLoaded(unit, this);
 }
 
 void CTransportUnit::DetachUnit(CUnit* unit)
@@ -208,7 +208,7 @@
 			unit-&gt;CalculateTerrainType();
 			unit-&gt;UpdateTerrainType();
 
-			luaCallIns.UnitUnloaded(unit, this);
+			eventHandler.UnitUnloaded(unit, this);
 
 			break;
 		}
@@ -228,7 +228,7 @@
 			if (dynamic_cast&lt;CTAAirMoveType*&gt;(moveType))
 				unit-&gt;moveType-&gt;useHeading=true;
 
-			unit-&gt;stunned=false; // de-stun in case it isfireplatform=0
+			unit-&gt;stunned=false; // de-stun in case it isFirePlatform=0
 			loshandler-&gt;MoveUnit(unit,false);
 
 			//add an additional move command for after we land
@@ -247,7 +247,7 @@
 			unit-&gt;moveType-&gt;LeaveTransport();
 			unit-&gt;CalculateTerrainType();
 			unit-&gt;UpdateTerrainType();
-			luaCallIns.UnitUnloaded(unit, this);
+			eventHandler.UnitUnloaded(unit, this);
 
 			break;
 		}
@@ -267,7 +267,7 @@
 			unit-&gt;transporter=0;
 			if (dynamic_cast&lt;CTAAirMoveType*&gt;(moveType))
 				unit-&gt;moveType-&gt;useHeading=true;
-			unit-&gt;stunned=false; // de-stun in case it isfireplatform=0
+			unit-&gt;stunned=false; // de-stun in case it isFirePlatform=0
 			unit-&gt;Block();
 
 			loshandler-&gt;MoveUnit(unit,false);
@@ -284,7 +284,7 @@
 			unit-&gt;moveType-&gt;LeaveTransport();
 			unit-&gt;CalculateTerrainType();
 			unit-&gt;UpdateTerrainType();
-			luaCallIns.UnitUnloaded(unit, this);
+			eventHandler.UnitUnloaded(unit, this);
 
 			break;
 		}

Modified: trunk/rts/Sim/Weapons/Weapon.cpp
===================================================================
--- trunk/rts/Sim/Weapons/Weapon.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/Sim/Weapons/Weapon.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -10,7 +10,6 @@
 #include &quot;Game/Player.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
@@ -25,6 +24,7 @@
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;System/EventHandler.h&quot;
 #include &quot;WeaponDefHandler.h&quot;
 #include &quot;Weapon.h&quot;
 #include &quot;mmgr.h&quot;
@@ -315,7 +315,7 @@
 			numStockpileQued--;
 			numStockpiled++;
 			owner-&gt;commandAI-&gt;StockpileChanged(this);
-			luaCallIns.StockpileChanged(owner, this, oldCount);
+			eventHandler.StockpileChanged(owner, this, oldCount);
 		}
 	}
 
@@ -354,7 +354,7 @@
 					const int oldCount = numStockpiled;
 					numStockpiled--;
 					owner-&gt;commandAI-&gt;StockpileChanged(this);
-					luaCallIns.StockpileChanged(owner, this, oldCount);
+					eventHandler.StockpileChanged(owner, this, oldCount);
 				} else {
 					owner-&gt;UseEnergy(energyFireCost);
 					owner-&gt;UseMetal(metalFireCost);
@@ -427,7 +427,7 @@
 			if (owner-&gt;unitDef-&gt;decloakOnFire &amp;&amp; (owner-&gt;scriptCloak &lt;= 2)) {
 				if (owner-&gt;isCloaked) {
 					owner-&gt;isCloaked = false;
-					luaCallIns.UnitDecloaked(owner);
+					eventHandler.UnitDecloaked(owner);
 				}
 				owner-&gt;curCloakTimeout = gs-&gt;frameNum + owner-&gt;cloakTimeout;
 			}

Added: trunk/rts/System/EventClient.cpp
===================================================================
--- trunk/rts/System/EventClient.cpp	                        (rev 0)
+++ trunk/rts/System/EventClient.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -0,0 +1,141 @@
+#include &quot;StdAfx.h&quot;
+// EventClient.cpp: implementation of the CEventClient class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &quot;EventClient.h&quot;
+using std::string;
+
+/******************************************************************************/
+/******************************************************************************/
+
+CEventClient::CEventClient(const string&amp; _name, int _order, bool _synced)
+: name(_name),
+  order(_order),
+  synced(_synced)
+{
+}
+
+
+CEventClient::~CEventClient()
+{
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+//
+//  Synced
+//
+
+void CEventClient::GamePreload() { return; }
+void CEventClient::GameStart() { return; }
+void CEventClient::GameOver() { return; }
+void CEventClient::TeamDied(int teamID) { return; }
+void CEventClient::TeamChanged(int teamID) { return; }
+void CEventClient::PlayerChanged(int playerID) { return; }
+void CEventClient::PlayerRemoved(int playerID) { return; }
+
+void CEventClient::UnitCreated(const CUnit* unit, const CUnit* builder) { return; }
+void CEventClient::UnitFinished(const CUnit* unit) { return; }
+void CEventClient::UnitFromFactory(const CUnit* unit, const CUnit* factory,
+                                   bool userOrders) { return; }
+void CEventClient::UnitDestroyed(const CUnit* unit, const CUnit* attacker) { return; }
+void CEventClient::UnitTaken(const CUnit* unit, int newTeam) { return; }
+void CEventClient::UnitGiven(const CUnit* unit, int oldTeam) { return; }
+
+void CEventClient::UnitIdle(const CUnit* unit) { return; }
+void CEventClient::UnitCommand(const CUnit* unit, const Command&amp; command) { return; }
+void CEventClient::UnitCmdDone(const CUnit* unit, int cmdType, int cmdTag) { return; }
+void CEventClient::UnitDamaged(const CUnit* unit, const CUnit* attacker,
+                               float damage, int weaponID, bool paralyzer) { return; }
+void CEventClient::UnitExperience(const CUnit* unit, float oldExperience) { return; }
+
+void CEventClient::UnitSeismicPing(const CUnit* unit, int allyTeam,
+                             const float3&amp; pos, float strength) { return; }
+void CEventClient::UnitEnteredRadar(const CUnit* unit, int allyTeam) { return; }
+void CEventClient::UnitEnteredLos(const CUnit* unit, int allyTeam) { return; }
+void CEventClient::UnitLeftRadar(const CUnit* unit, int allyTeam) { return; }
+void CEventClient::UnitLeftLos(const CUnit* unit, int allyTeam) { return; }
+
+void CEventClient::UnitEnteredWater(const CUnit* unit) { return; }
+void CEventClient::UnitEnteredAir(const CUnit* unit) { return; }
+void CEventClient::UnitLeftWater(const CUnit* unit) { return; }
+void CEventClient::UnitLeftAir(const CUnit* unit) { return; }
+
+void CEventClient::UnitLoaded(const CUnit* unit, const CUnit* transport) { return; }
+void CEventClient::UnitUnloaded(const CUnit* unit, const CUnit* transport) { return; }
+
+void CEventClient::UnitCloaked(const CUnit* unit) { return; }
+void CEventClient::UnitDecloaked(const CUnit* unit) { return; }
+
+void CEventClient::FeatureCreated(const CFeature* feature) { return; }
+void CEventClient::FeatureDestroyed(const CFeature* feature) { return; }
+
+void CEventClient::ProjectileCreated(const CProjectile* proj) { return; }
+void CEventClient::ProjectileDestroyed(const CProjectile* proj) { return; }
+
+void CEventClient::StockpileChanged(const CUnit* unit,
+                                    const CWeapon* weapon, int oldCount) { return; }
+
+bool CEventClient::Explosion(int weaponID, const float3&amp; pos, const CUnit* owner)
+{
+  return false;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+//
+//  Unsynced
+//
+
+void CEventClient::Update() { return; }
+
+void CEventClient::ViewResize() { return; }
+
+bool CEventClient::DefaultCommand(const CUnit* unit, const CFeature* feature, int&amp; cmd)
+{
+  return false;
+}
+
+void CEventClient::DrawGenesis() { return; }
+void CEventClient::DrawWorld() { return; }
+void CEventClient::DrawWorldPreUnit() { return; }
+void CEventClient::DrawWorldShadow() { return; }
+void CEventClient::DrawWorldReflection() { return; }
+void CEventClient::DrawWorldRefraction() { return; }
+void CEventClient::DrawScreenEffects() { return; }
+void CEventClient::DrawScreen() { return; }
+void CEventClient::DrawInMiniMap() { return; }
+
+// from LuaUI
+bool CEventClient::KeyPress(unsigned short key, bool isRepeat) { return false; }
+bool CEventClient::KeyRelease(unsigned short key) { return false; }
+bool CEventClient::MouseMove(int x, int y, int dx, int dy, int button) { return false; }
+bool CEventClient::MousePress(int x, int y, int button) { return false; }
+int  CEventClient::MouseRelease(int x, int y, int button) { return -1; } // FIXME - bool / void?
+bool CEventClient::MouseWheel(bool up, float value) { return false; }
+bool CEventClient::IsAbove(int x, int y) { return false; }
+string CEventClient::GetTooltip(int x, int y) { return &quot;&quot;; }
+
+bool CEventClient::CommandNotify(const Command&amp; cmd) { return false; }
+
+bool CEventClient::AddConsoleLine(const string&amp; msg, int zone) { return false; }
+
+bool CEventClient::GroupChanged(int groupID) { return false; }
+
+bool CEventClient::GameSetup(const string&amp; state, bool&amp; ready,
+                             const map&lt;int, string&gt;&amp; playerStates) { return false; }
+
+string CEventClient::WorldTooltip(const CUnit* unit,
+                                 const CFeature* feature,
+                                 const float3* groundPos) { return false; }
+
+bool CEventClient::MapDrawCmd(int playerID, int type,
+                        const float3* pos0,
+                        const float3* pos1,
+                        const string* label) { return false; }
+
+/******************************************************************************/
+/******************************************************************************/

Added: trunk/rts/System/EventClient.h
===================================================================
--- trunk/rts/System/EventClient.h	                        (rev 0)
+++ trunk/rts/System/EventClient.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -0,0 +1,156 @@
+#ifndef EVENT_CLIENT_H
+#define EVENT_CLIENT_H
+// EventClient.h: interface for the CEventClient class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;map&gt;
+using std::string;
+using std::vector;
+using std::map;
+
+class CUnit;
+class CWeapon;
+class CFeature;
+class CProjectile;
+struct Command;
+
+
+class CEventClient
+{
+	public:
+		enum SpecialTeams {
+			NoAccessTeam   = -1,
+			AllAccessTeam  = -2,
+			MinSpecialTeam = AllAccessTeam 
+		};
+
+	public:
+		inline const std::string&amp; GetName()   const { return name;   }
+		inline int                GetOrder()  const { return order;  }
+		inline bool               GetSynced() const { return synced; }
+
+		// used by the eventHandler to register
+		// call-ins when an EventClient is being added
+		virtual bool WantsEvent(const std::string&amp; eventName) { return false; }
+
+		// used by the eventHandler to route certain event types
+		virtual int  GetReadAllyTeam() const { return NoAccessTeam; }
+		virtual bool GetFullRead()     const { return GetReadAllyTeam() == AllAccessTeam; }
+		inline bool CanReadAllyTeam(int allyTeam) {
+			return GetFullRead() || (GetReadAllyTeam() == allyTeam);
+		}
+
+	private:
+		const std::string name;
+		const int         order;
+		const bool        synced;
+
+	protected:
+		CEventClient(const std::string&amp; name, int order, bool synced);
+		virtual ~CEventClient();
+
+	public:
+		// Synced
+		virtual void GamePreload();
+		virtual void GameStart();
+		virtual void GameOver();
+		virtual void TeamDied(int teamID);
+		virtual void TeamChanged(int teamID);
+		virtual void PlayerChanged(int playerID);
+		virtual void PlayerRemoved(int playerID);
+
+		virtual void UnitCreated(const CUnit* unit, const CUnit* builder);
+		virtual void UnitFinished(const CUnit* unit);
+		virtual void UnitFromFactory(const CUnit* unit, const CUnit* factory,
+		                             bool userOrders);
+		virtual void UnitDestroyed(const CUnit* unit, const CUnit* attacker);
+		virtual void UnitTaken(const CUnit* unit, int newTeam);
+		virtual void UnitGiven(const CUnit* unit, int oldTeam);
+
+		virtual void UnitIdle(const CUnit* unit);
+		virtual void UnitCommand(const CUnit* unit, const Command&amp; command);
+		virtual void UnitCmdDone(const CUnit* unit, int cmdType, int cmdTag);
+		virtual void UnitDamaged(const CUnit* unit, const CUnit* attacker,
+		                         float damage, int weaponID, bool paralyzer);
+		virtual void UnitExperience(const CUnit* unit, float oldExperience);
+
+		virtual void UnitSeismicPing(const CUnit* unit, int allyTeam,
+		                             const float3&amp; pos, float strength);
+		virtual void UnitEnteredRadar(const CUnit* unit, int allyTeam);
+		virtual void UnitEnteredLos(const CUnit* unit, int allyTeam);
+		virtual void UnitLeftRadar(const CUnit* unit, int allyTeam);
+		virtual void UnitLeftLos(const CUnit* unit, int allyTeam);
+
+		virtual void UnitEnteredWater(const CUnit* unit);
+		virtual void UnitEnteredAir(const CUnit* unit);
+		virtual void UnitLeftWater(const CUnit* unit);
+		virtual void UnitLeftAir(const CUnit* unit);
+
+		virtual void UnitLoaded(const CUnit* unit, const CUnit* transport);
+		virtual void UnitUnloaded(const CUnit* unit, const CUnit* transport);
+
+		virtual void UnitCloaked(const CUnit* unit);
+		virtual void UnitDecloaked(const CUnit* unit);
+
+		virtual void FeatureCreated(const CFeature* feature);
+		virtual void FeatureDestroyed(const CFeature* feature);
+
+		virtual void ProjectileCreated(const CProjectile* proj);
+		virtual void ProjectileDestroyed(const CProjectile* proj);
+
+		virtual void StockpileChanged(const CUnit* unit,
+		                              const CWeapon* weapon, int oldCount);
+	
+		virtual bool Explosion(int weaponID, const float3&amp; pos, const CUnit* owner);
+
+		// Unsynced
+		virtual void Update();
+
+		virtual void ViewResize();
+
+		virtual bool DefaultCommand(const CUnit* unit, const CFeature* feature, int&amp; cmd);
+
+		virtual void DrawGenesis();
+		virtual void DrawWorld();
+		virtual void DrawWorldPreUnit();
+		virtual void DrawWorldShadow();
+		virtual void DrawWorldReflection();
+		virtual void DrawWorldRefraction();
+		virtual void DrawScreenEffects();
+		virtual void DrawScreen();
+		virtual void DrawInMiniMap();
+
+		// from LuaUI
+		virtual bool KeyPress(unsigned short key, bool isRepeat);
+		virtual bool KeyRelease(unsigned short key);
+		virtual bool MouseMove(int x, int y, int dx, int dy, int button);
+		virtual bool MousePress(int x, int y, int button);
+		virtual int  MouseRelease(int x, int y, int button); // FIXME - bool / void?
+		virtual bool MouseWheel(bool up, float value);
+		virtual bool IsAbove(int x, int y);
+		virtual std::string GetTooltip(int x, int y);
+
+		virtual bool CommandNotify(const Command&amp; cmd);
+
+		virtual bool AddConsoleLine(const std::string&amp; msg, int zone);
+
+		virtual bool GroupChanged(int groupID);
+
+		virtual bool GameSetup(const std::string&amp; state, bool&amp; ready,
+		                       const map&lt;int, std::string&gt;&amp; playerStates);
+
+		virtual std::string WorldTooltip(const CUnit* unit,
+		                                 const CFeature* feature,
+		                                 const float3* groundPos);
+
+		virtual bool MapDrawCmd(int playerID, int type,
+		                        const float3* pos0,
+		                        const float3* pos1,
+		                        const std::string* label);
+};
+
+
+#endif /* EVENT_CLIENT_H */

Added: trunk/rts/System/EventHandler.cpp
===================================================================
--- trunk/rts/System/EventHandler.cpp	                        (rev 0)
+++ trunk/rts/System/EventHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -0,0 +1,570 @@
+#include &quot;StdAfx.h&quot;
+// EventHandler.cpp: implementation of the CEventHandler class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &quot;EventHandler.h&quot;
+#include &quot;Lua/LuaOpenGL.h&quot;  // FIXME -- should be moved
+
+using std::string;
+using std::vector;
+using std::map;
+
+
+CEventHandler eventHandler;
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+#define SETUP_EVENT(name, props) SetupEvent(#name, &amp;list ## name, props)
+
+void CEventHandler::SetupEvent(const string&amp; eName,
+                               EventClientList* list, int props)
+{
+	eventMap[eName] = EventInfo(eName, list, props);
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+CEventHandler::CEventHandler()
+{
+	mouseOwner = NULL;
+
+	// unmanaged call-ins
+	eventMap[&quot;AIEvent&quot;] = EventInfo(&quot;AIEvent&quot;, NULL, UNSYNCED_BIT);
+	eventMap[&quot;DrawUnit&quot;] = EventInfo(&quot;DrawUnit&quot;, NULL, UNSYNCED_BIT);
+
+	// synced call-ins
+	SETUP_EVENT(GamePreload,   MANAGED_BIT);
+	SETUP_EVENT(GameStart,     MANAGED_BIT);
+	SETUP_EVENT(GameOver,      MANAGED_BIT);
+	SETUP_EVENT(TeamDied,      MANAGED_BIT);
+	SETUP_EVENT(TeamChanged,   MANAGED_BIT);
+	SETUP_EVENT(PlayerChanged, MANAGED_BIT);
+
+	SETUP_EVENT(UnitCreated,     MANAGED_BIT);
+	SETUP_EVENT(UnitFinished,    MANAGED_BIT);
+	SETUP_EVENT(UnitFromFactory, MANAGED_BIT);
+	SETUP_EVENT(UnitDestroyed,   MANAGED_BIT);
+	SETUP_EVENT(UnitTaken,       MANAGED_BIT);
+	SETUP_EVENT(UnitGiven,       MANAGED_BIT);
+
+	SETUP_EVENT(UnitIdle,       MANAGED_BIT);
+	SETUP_EVENT(UnitCommand,    MANAGED_BIT);
+	SETUP_EVENT(UnitCmdDone,    MANAGED_BIT);
+	SETUP_EVENT(UnitDamaged,    MANAGED_BIT);
+	SETUP_EVENT(UnitExperience, MANAGED_BIT);
+
+	SETUP_EVENT(UnitSeismicPing,  MANAGED_BIT);
+	SETUP_EVENT(UnitEnteredRadar, MANAGED_BIT);
+	SETUP_EVENT(UnitEnteredLos,   MANAGED_BIT);
+	SETUP_EVENT(UnitLeftRadar,    MANAGED_BIT);
+	SETUP_EVENT(UnitLeftLos,      MANAGED_BIT);
+
+	SETUP_EVENT(UnitEnteredWater, MANAGED_BIT);
+	SETUP_EVENT(UnitEnteredAir,   MANAGED_BIT);
+	SETUP_EVENT(UnitLeftWater,    MANAGED_BIT);
+	SETUP_EVENT(UnitLeftAir,      MANAGED_BIT);
+
+	SETUP_EVENT(UnitLoaded,    MANAGED_BIT);
+	SETUP_EVENT(UnitUnloaded,  MANAGED_BIT);
+	SETUP_EVENT(UnitCloaked,   MANAGED_BIT);
+	SETUP_EVENT(UnitDecloaked, MANAGED_BIT);
+
+	SETUP_EVENT(FeatureCreated,   MANAGED_BIT);
+	SETUP_EVENT(FeatureDestroyed, MANAGED_BIT);
+
+	SETUP_EVENT(ProjectileCreated,   MANAGED_BIT);
+	SETUP_EVENT(ProjectileDestroyed, MANAGED_BIT);
+
+	SETUP_EVENT(Explosion, MANAGED_BIT);
+
+	SETUP_EVENT(StockpileChanged, MANAGED_BIT);
+
+	// unsynced call-ins
+	SETUP_EVENT(Update,         MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(ViewResize,     MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DefaultCommand, MANAGED_BIT | UNSYNCED_BIT);
+
+	SETUP_EVENT(DrawGenesis,         MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DrawWorld,           MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DrawWorldPreUnit,    MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DrawWorldShadow,     MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DrawWorldReflection, MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DrawWorldRefraction, MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DrawScreenEffects,   MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DrawScreen,          MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(DrawInMiniMap,       MANAGED_BIT | UNSYNCED_BIT);
+
+  SETUP_EVENT(KeyPress,       MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(KeyRelease,     MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(MouseMove,      MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(MousePress,     MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(MouseRelease,   MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(MouseWheel,     MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(IsAbove,        MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(GetTooltip,     MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(CommandNotify,  MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(AddConsoleLine, MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(GroupChanged,   MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(GameSetup,      MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(WorldTooltip,   MANAGED_BIT | UNSYNCED_BIT);
+  SETUP_EVENT(MapDrawCmd,     MANAGED_BIT | UNSYNCED_BIT);
+}
+
+
+CEventHandler::~CEventHandler()
+{
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+void CEventHandler::AddClient(CEventClient* ec)
+{
+	ListInsert(handles, ec);
+
+	EventMap::const_iterator it;
+	for (it = eventMap.begin(); it != eventMap.end(); ++it) {
+		const EventInfo&amp; ei = it-&gt;second;
+		if (ei.HasPropBit(MANAGED_BIT) &amp;&amp; (ei.GetList() != NULL)) {
+			if (ec-&gt;WantsEvent(it-&gt;first)) {
+				ListInsert(*ei.GetList(), ec);
+			}
+		}
+	}
+}
+
+
+void CEventHandler::RemoveClient(CEventClient* ec)
+{
+	if (mouseOwner == ec) {
+		mouseOwner = NULL;
+	}
+
+	ListRemove(handles, ec);
+
+	EventMap::const_iterator it;
+	for (it = eventMap.begin(); it != eventMap.end(); ++it) {
+		const EventInfo&amp; ei = it-&gt;second;
+		if (ei.HasPropBit(MANAGED_BIT) &amp;&amp; (ei.GetList() != NULL)) {
+			ListRemove(*ei.GetList(), ec);
+		}
+	}
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+void CEventHandler::GetEventList(vector&lt;string&gt;&amp; list) const
+{
+	list.clear();
+	EventMap::const_iterator it;
+	for (it = eventMap.begin(); it != eventMap.end(); ++it) {
+		list.push_back(it-&gt;first);
+	}
+}
+
+
+bool CEventHandler::IsKnown(const string&amp; eName) const
+{
+	return (eventMap.find(eName) != eventMap.end());
+}
+
+
+bool CEventHandler::IsManaged(const string&amp; eName) const
+{
+	EventMap::const_iterator it = eventMap.find(eName);
+	return ((it != eventMap.end()) &amp;&amp; (it-&gt;second.HasPropBit(MANAGED_BIT)));
+}
+
+
+bool CEventHandler::IsUnsynced(const string&amp; eName) const
+{
+	EventMap::const_iterator it = eventMap.find(eName);
+	return ((it != eventMap.end()) &amp;&amp; (it-&gt;second.HasPropBit(UNSYNCED_BIT)));
+}
+
+
+bool CEventHandler::IsController(const string&amp; eName) const
+{
+	EventMap::const_iterator it = eventMap.find(eName);
+	return ((it != eventMap.end()) &amp;&amp; (it-&gt;second.HasPropBit(CONTROL_BIT)));
+}
+
+
+/******************************************************************************/
+
+bool CEventHandler::InsertEvent(CEventClient* ec, const string&amp; ciName)
+{
+	EventMap::iterator it = eventMap.find(ciName);
+	if ((it == eventMap.end()) || (it-&gt;second.GetList() == NULL)) {
+		return false;
+	}
+	ListInsert(*it-&gt;second.GetList(), ec);
+	return true;
+}
+
+
+bool CEventHandler::RemoveEvent(CEventClient* ec, const string&amp; ciName)
+{
+	EventMap::iterator it = eventMap.find(ciName);
+	if ((it == eventMap.end()) || (it-&gt;second.GetList() == NULL)) {
+		return false;
+	}
+	ListRemove(*it-&gt;second.GetList(), ec);
+	return true;
+}
+
+
+/******************************************************************************/
+
+void CEventHandler::ListInsert(EventClientList&amp; ecList, CEventClient* ec)
+{
+	EventClientList::iterator it;
+	for (it = ecList.begin(); it != ecList.end(); ++it) {
+		const CEventClient* ecIt = *it;
+		if (ec == ecIt) {
+			return; // already in the list
+		}
+		else if ((ec-&gt;GetOrder()  &lt;  ecIt-&gt;GetOrder()) ||
+		         ((ec-&gt;GetOrder() == ecIt-&gt;GetOrder()) &amp;&amp;
+		          (ec-&gt;GetName()  &lt;  ecIt-&gt;GetName()))) { // should not happen
+			ecList.insert(it, ec);
+			return;
+		}
+	}
+	ecList.push_back(ec);
+}
+
+
+void CEventHandler::ListRemove(EventClientList&amp; ecList, CEventClient* ec)
+{
+	// FIXME: efficient, hardly
+	EventClientList newList;
+	for (int i = 0; i &lt; ecList.size(); i++) {
+		if (ec != ecList[i]) {
+			newList.push_back(ecList[i]);
+		}
+	}
+	ecList = newList;
+}
+		
+
+/******************************************************************************/
+/******************************************************************************/
+
+void CEventHandler::GamePreload()
+{
+	const int count = listGamePreload.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listGamePreload[i];
+		ec-&gt;GamePreload();
+	}	
+}
+
+void CEventHandler::GameStart()
+{
+	const int count = listGameStart.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listGameStart[i];
+		ec-&gt;GameStart();
+	}	
+}
+
+void CEventHandler::GameOver()
+{
+	const int count = listGameOver.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listGameOver[i];
+		ec-&gt;GameOver();
+	}
+}
+
+
+void CEventHandler::TeamDied(int teamID)
+{
+	const int count = listTeamDied.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listTeamDied[i];
+		ec-&gt;TeamDied(teamID);
+	}
+}
+
+
+void CEventHandler::TeamChanged(int teamID)
+{
+	const int count = listTeamChanged.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listTeamChanged[i];
+		ec-&gt;TeamChanged(teamID);
+	}
+}
+
+
+void CEventHandler::PlayerChanged(int playerID)
+{
+	const int count = listPlayerChanged.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listPlayerChanged[i];
+		ec-&gt;PlayerChanged(playerID);
+	}
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+void CEventHandler::Update()
+{
+	const int count = listUpdate.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUpdate[i];
+		ec-&gt;Update();
+	}
+}
+
+
+void CEventHandler::ViewResize()
+{
+	const int count = listViewResize.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listViewResize[i];
+		ec-&gt;ViewResize();
+	}
+}
+
+
+#define DRAW_CALLIN(name)                         \
+  void CEventHandler:: Draw ## name ()        \
+  {                                               \
+    const int count = listDraw ## name.size();    \
+    if (count &lt;= 0) {                             \
+      return;                                     \
+    }                                             \
+                                                  \
+    LuaOpenGL::EnableDraw ## name ();             \
+    listDraw ## name [0]-&gt;Draw ## name ();        \
+                                                  \
+    for (int i = 1; i &lt; count; i++) {             \
+      LuaOpenGL::ResetDraw ## name ();            \
+      CEventClient* ec = listDraw ## name [i];      \
+      ec-&gt; Draw ## name ();                       \
+    }                                             \
+                                                  \
+    LuaOpenGL::DisableDraw ## name ();            \
+  }
+
+DRAW_CALLIN(Genesis)
+DRAW_CALLIN(World)
+DRAW_CALLIN(WorldPreUnit)
+DRAW_CALLIN(WorldShadow)
+DRAW_CALLIN(WorldReflection)
+DRAW_CALLIN(WorldRefraction)
+DRAW_CALLIN(ScreenEffects)
+DRAW_CALLIN(Screen)
+DRAW_CALLIN(InMiniMap)
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+bool CEventHandler::CommandNotify(const Command&amp; cmd)
+{
+	// reverse order, user has the override
+	const int count = listCommandNotify.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listCommandNotify[i];
+		if (ec-&gt;CommandNotify(cmd)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+
+bool CEventHandler::KeyPress(unsigned short key, bool isRepeat)
+{
+	// reverse order, user has the override
+	const int count = listKeyPress.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listKeyPress[i];
+		if (ec-&gt;KeyPress(key, isRepeat)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+
+bool CEventHandler::KeyRelease(unsigned short key)
+{
+	// reverse order, user has the override
+	const int count = listKeyRelease.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listKeyRelease[i];
+		if (ec-&gt;KeyRelease(key)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+
+bool CEventHandler::MousePress(int x, int y, int button)
+{
+	// reverse order, user has the override
+	const int count = listMousePress.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listMousePress[i];
+		if (ec-&gt;MousePress(x, y, button)) {
+			mouseOwner = ec;
+			return true;
+		}
+	}
+	return false;
+}
+
+
+// return a cmd index, or -1
+int CEventHandler::MouseRelease(int x, int y, int button)
+{
+	if (mouseOwner == NULL) {
+		return -1;
+	}
+	const int retval = mouseOwner-&gt;MouseRelease(x, y, button);
+	mouseOwner = NULL;
+	return retval;
+}
+
+
+bool CEventHandler::MouseMove(int x, int y, int dx, int dy, int button)
+{
+	if (mouseOwner == NULL) {
+		return false;
+	}
+	return mouseOwner-&gt;MouseMove(x, y, dx, dy, button);
+}
+
+
+bool CEventHandler::MouseWheel(bool up, float value)
+{
+	// reverse order, user has the override
+	const int count = listMouseWheel.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listMouseWheel[i];
+		if (ec-&gt;MouseWheel(up, value)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+
+bool CEventHandler::IsAbove(int x, int y)
+{
+	// reverse order, user has the override
+	const int count = listIsAbove.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listIsAbove[i];
+		if (ec-&gt;IsAbove(x, y)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+
+string CEventHandler::GetTooltip(int x, int y)
+{
+	// reverse order, user has the override
+	const int count = listGetTooltip.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listGetTooltip[i];
+		const string tt = ec-&gt;GetTooltip(x, y);
+		if (!tt.empty()) {
+			return tt;
+		}
+	}
+	return &quot;&quot;;
+}
+
+
+bool CEventHandler::AddConsoleLine(const string&amp; msg, int zone)
+{
+	const int count = listAddConsoleLine.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listAddConsoleLine[i];
+		ec-&gt;AddConsoleLine(msg, zone);
+	}
+	return true;
+}
+
+
+bool CEventHandler::GroupChanged(int groupID)
+{
+	const int count = listGroupChanged.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listGroupChanged[i];
+		ec-&gt;GroupChanged(groupID);
+	}
+	return false;
+}
+
+
+
+bool CEventHandler::GameSetup(const string&amp; state, bool&amp; ready,
+                                  const map&lt;int, string&gt;&amp; playerStates)
+{
+	// reverse order, user has the override
+	const int count = listGameSetup.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listGameSetup[i];
+		if (ec-&gt;GameSetup(state, ready, playerStates)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+
+string CEventHandler::WorldTooltip(const CUnit* unit,
+                                   const CFeature* feature,
+                                   const float3* groundPos)
+{
+	// reverse order, user has the override
+	const int count = listWorldTooltip.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listWorldTooltip[i];
+		const string tt = ec-&gt;WorldTooltip(unit, feature, groundPos);
+		if (!tt.empty()) {
+			return tt;
+		}
+	}
+	return &quot;&quot;;
+}
+
+
+bool CEventHandler::MapDrawCmd(int playerID, int type,
+                               const float3* pos0, const float3* pos1,
+                                   const string* label)
+{
+	// reverse order, user has the override
+	const int count = listMapDrawCmd.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listMapDrawCmd[i];
+		if (ec-&gt;MapDrawCmd(playerID, type, pos0, pos1, label)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/

Added: trunk/rts/System/EventHandler.h
===================================================================
--- trunk/rts/System/EventHandler.h	                        (rev 0)
+++ trunk/rts/System/EventHandler.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -0,0 +1,588 @@
+#ifndef EVENT_HANDLER_H
+#define EVENT_HANDLER_H
+// EventHandler.h: interface for the CEventHandler class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;map&gt;
+
+#include &quot;EventClient.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sim/Features/Feature.h&quot;
+
+
+class CUnit;
+class CWeapon;
+class CFeature;
+class CProjectile;
+struct Command;
+
+
+class CEventHandler
+{
+	public:
+		CEventHandler();
+		~CEventHandler();
+
+		void AddClient(CEventClient* ec);
+		void RemoveClient(CEventClient* ec);
+
+		bool InsertEvent(CEventClient* ec, const std::string&amp; ciName);
+		bool RemoveEvent(CEventClient* ec, const std::string&amp; ciName);
+
+		void GetEventList(std::vector&lt;std::string&gt;&amp; list) const;
+
+		bool IsKnown(const std::string&amp; ciName) const;
+		bool IsManaged(const std::string&amp; ciName) const;
+		bool IsUnsynced(const std::string&amp; ciName) const;
+		bool IsController(const std::string&amp; ciName) const;
+
+	public:
+		// Synced
+		void GamePreload();
+		void GameStart();
+		void GameOver();
+		void TeamDied(int teamID);
+		void TeamChanged(int teamID);
+		void PlayerChanged(int playerID);
+		void PlayerRemoved(int playerID);
+
+		void UnitCreated(const CUnit* unit, const CUnit* builder);
+		void UnitFinished(const CUnit* unit);
+		void UnitFromFactory(const CUnit* unit, const CUnit* factory,
+		                     bool userOrders);
+		void UnitDestroyed(const CUnit* unit, const CUnit* attacker);
+		void UnitTaken(const CUnit* unit, int newTeam);
+		void UnitGiven(const CUnit* unit, int oldTeam);
+
+		void UnitIdle(const CUnit* unit);
+		void UnitCommand(const CUnit* unit, const Command&amp; command);
+		void UnitCmdDone(const CUnit* unit, int cmdType, int cmdTag);
+		void UnitDamaged(const CUnit* unit, const CUnit* attacker,
+		                 float damage, int weaponID, bool paralyzer);
+		void UnitExperience(const CUnit* unit, float oldExperience);
+
+		void UnitSeismicPing(const CUnit* unit, int allyTeam,
+		                     const float3&amp; pos, float strength);
+		void UnitEnteredRadar(const CUnit* unit, int allyTeam);
+		void UnitEnteredLos(const CUnit* unit, int allyTeam);
+		void UnitLeftRadar(const CUnit* unit, int allyTeam);
+		void UnitLeftLos(const CUnit* unit, int allyTeam);
+
+		void UnitEnteredWater(const CUnit* unit);
+		void UnitEnteredAir(const CUnit* unit);
+		void UnitLeftWater(const CUnit* unit);
+		void UnitLeftAir(const CUnit* unit);
+
+		void UnitLoaded(const CUnit* unit, const CUnit* transport);
+		void UnitUnloaded(const CUnit* unit, const CUnit* transport);
+
+		void UnitCloaked(const CUnit* unit);
+		void UnitDecloaked(const CUnit* unit);
+
+		void FeatureCreated(const CFeature* feature);
+		void FeatureDestroyed(const CFeature* feature);
+
+		void ProjectileCreated(const CProjectile* proj, int allyTeam);
+		void ProjectileDestroyed(const CProjectile* proj, int allyTeam);
+
+		bool Explosion(int weaponID, const float3&amp; pos, const CUnit* owner);
+
+		void StockpileChanged(const CUnit* unit,
+		                      const CWeapon* weapon, int oldCount);
+	
+		// Unsynced
+		void Update();
+
+		void ViewResize();
+
+		bool DefaultCommand(const CUnit* unit, const CFeature* feature, int&amp; cmd);
+
+		void DrawGenesis();
+		void DrawWorld();
+		void DrawWorldPreUnit();
+		void DrawWorldShadow();
+		void DrawWorldReflection();
+		void DrawWorldRefraction();
+		void DrawScreenEffects();
+		void DrawScreen();
+		void DrawInMiniMap();
+
+		// from LuaUI
+		bool KeyPress(unsigned short key, bool isRepeat);
+		bool KeyRelease(unsigned short key);
+		bool MouseMove(int x, int y, int dx, int dy, int button);
+		bool MousePress(int x, int y, int button);
+		int  MouseRelease(int x, int y, int button); // return a cmd index, or -1
+		bool MouseWheel(bool up, float value);
+		bool IsAbove(int x, int y);
+		std::string GetTooltip(int x, int y);
+
+		bool CommandNotify(const Command&amp; cmd);
+
+		bool AddConsoleLine(const std::string&amp; msg, int zone);
+
+		bool GroupChanged(int groupID);
+
+		bool GameSetup(const std::string&amp; state, bool&amp; ready,
+		               const map&lt;int, std::string&gt;&amp; playerStates);
+
+		std::string WorldTooltip(const CUnit* unit,
+		                         const CFeature* feature,
+		                         const float3* groundPos);
+
+		bool MapDrawCmd(int playerID, int type,
+		                const float3* pos0,
+		                const float3* pos1,
+		                const std::string* label);
+
+//FIXME		void ShockFront(float power, const float3&amp; pos, float areaOfEffect);
+
+	private:
+		typedef vector&lt;CEventClient*&gt; EventClientList;
+
+		enum EventPropertyBits {
+			MANAGED_BIT  = (1 &lt;&lt; 0), // managed by eventHandler
+			UNSYNCED_BIT = (1 &lt;&lt; 1), // delivers unsynced information
+			CONTROL_BIT  = (1 &lt;&lt; 2)  // controls synced information
+		};
+		
+		class EventInfo {
+			public:
+				EventInfo() : propBits(0), list(NULL) {}
+				EventInfo(const std::string&amp; _name, EventClientList* _list, int _bits)
+				: name(_name), list(_list), propBits(_bits) {}
+				~EventInfo() {}
+
+				inline const std::string&amp; GetName() const { return name; }
+				inline EventClientList* GetList() const { return list; }
+				inline int GetPropBits() const { return propBits; }
+				inline bool HasPropBit(int bit) const { return propBits &amp; bit; }
+				
+			private:
+				std::string name;
+				EventClientList* list;
+				int propBits;
+		};
+
+		typedef map&lt;std::string, EventInfo&gt; EventMap;
+
+	private:
+		void SetupEvent(const std::string&amp; ciName,
+		                EventClientList* list, int props);
+		void ListInsert(EventClientList&amp; ciList, CEventClient* ec);
+		void ListRemove(EventClientList&amp; ciList, CEventClient* ec);
+
+	private:
+		CEventClient* mouseOwner;
+
+	private:
+		EventMap eventMap;
+
+		EventClientList handles;
+
+		// synced
+		EventClientList listGamePreload;
+		EventClientList listGameStart;
+		EventClientList listGameOver;
+		EventClientList listTeamDied;
+		EventClientList listTeamChanged;
+		EventClientList listPlayerChanged;
+
+		EventClientList listUnitCreated;
+		EventClientList listUnitFinished;
+		EventClientList listUnitFromFactory;
+		EventClientList listUnitDestroyed;
+		EventClientList listUnitTaken;
+		EventClientList listUnitGiven;
+
+		EventClientList listUnitIdle;
+		EventClientList listUnitCommand;
+		EventClientList listUnitCmdDone;
+		EventClientList listUnitDamaged;
+		EventClientList listUnitExperience;
+
+		EventClientList listUnitSeismicPing;
+		EventClientList listUnitEnteredRadar;
+		EventClientList listUnitEnteredLos;
+		EventClientList listUnitLeftRadar;
+		EventClientList listUnitLeftLos;
+
+		EventClientList listUnitEnteredWater;
+		EventClientList listUnitEnteredAir;
+		EventClientList listUnitLeftWater;
+		EventClientList listUnitLeftAir;
+
+		EventClientList listUnitLoaded;
+		EventClientList listUnitUnloaded;
+
+		EventClientList listUnitCloaked;
+		EventClientList listUnitDecloaked;
+
+		EventClientList listFeatureCreated;
+		EventClientList listFeatureDestroyed;
+
+		EventClientList listProjectileCreated;
+		EventClientList listProjectileDestroyed;
+
+		EventClientList listExplosion;
+
+		EventClientList listStockpileChanged;
+
+		// unsynced
+		EventClientList listUpdate;
+
+		EventClientList listViewResize;
+
+		EventClientList listDefaultCommand;
+
+		EventClientList listDrawGenesis;
+		EventClientList listDrawWorld;
+		EventClientList listDrawWorldPreUnit;
+		EventClientList listDrawWorldShadow;
+		EventClientList listDrawWorldReflection;
+		EventClientList listDrawWorldRefraction;
+		EventClientList listDrawScreenEffects;
+		EventClientList listDrawScreen;
+		EventClientList listDrawInMiniMap;
+
+		// from LuaUI
+		EventClientList listKeyPress;
+		EventClientList listKeyRelease;
+		EventClientList listMouseMove;
+		EventClientList listMousePress;
+		EventClientList listMouseRelease;
+		EventClientList listMouseWheel;
+		EventClientList listIsAbove;
+		EventClientList listGetTooltip;
+		EventClientList listConfigCommand;
+		EventClientList listCommandNotify;
+		EventClientList listAddConsoleLine;
+		EventClientList listGroupChanged;
+		EventClientList listGameSetup;
+		EventClientList listWorldTooltip;
+		EventClientList listMapDrawCmd;
+};
+
+
+extern CEventHandler eventHandler;
+
+
+/******************************************************************************/
+/******************************************************************************/
+//
+// Inlined call-in loops
+//
+
+inline void CEventHandler::UnitCreated(const CUnit* unit,
+                                           const CUnit* builder)
+{
+	const int unitAllyTeam = unit-&gt;allyteam;
+	const int count = listUnitCreated.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitCreated[i];
+		if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {
+			ec-&gt;UnitCreated(unit, builder);
+		}
+	}
+}
+
+
+#define UNIT_CALLIN_NO_PARAM(name)                                 \
+	inline void CEventHandler:: Unit ## name (const CUnit* unit) \
+	{                                                                \
+		const int unitAllyTeam = unit-&gt;allyteam;                       \
+		const int count = listUnit ## name.size();                     \
+		for (int i = 0; i &lt; count; i++) {                              \
+			CEventClient* ec = listUnit ## name [i];                       \
+			if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {                     \
+				ec-&gt; Unit ## name (unit);                                  \
+			}                                                            \
+		}                                                              \
+	}
+
+UNIT_CALLIN_NO_PARAM(Finished)
+UNIT_CALLIN_NO_PARAM(Idle)
+UNIT_CALLIN_NO_PARAM(Cloaked)
+UNIT_CALLIN_NO_PARAM(Decloaked)
+UNIT_CALLIN_NO_PARAM(EnteredWater)
+UNIT_CALLIN_NO_PARAM(EnteredAir)
+UNIT_CALLIN_NO_PARAM(LeftWater)
+UNIT_CALLIN_NO_PARAM(LeftAir)
+
+
+#define UNIT_CALLIN_INT_PARAM(name)                                       \
+	inline void CEventHandler:: Unit ## name (const CUnit* unit, int p) \
+	{                                                                       \
+		const int unitAllyTeam = unit-&gt;allyteam;                              \
+		const int count = listUnit ## name.size();                            \
+		for (int i = 0; i &lt; count; i++) {                                     \
+			CEventClient* ec = listUnit ## name [i];                              \
+			if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {                            \
+				ec-&gt; Unit ## name (unit, p);                                      \
+			}                                                                   \
+		}                                                                     \
+	}
+
+UNIT_CALLIN_INT_PARAM(Taken)
+UNIT_CALLIN_INT_PARAM(Given)
+
+
+#define UNIT_CALLIN_LOS_PARAM(name)                                        \
+	inline void CEventHandler:: Unit ## name (const CUnit* unit, int at) \
+	{                                                                        \
+		const int count = listUnit ## name.size();                             \
+		for (int i = 0; i &lt; count; i++) {                                      \
+			CEventClient* ec = listUnit ## name [i];                               \
+			if (ec-&gt;CanReadAllyTeam(at)) {                                       \
+				ec-&gt; Unit ## name (unit, at);                                      \
+			}                                                                    \
+		}                                                                      \
+	}
+
+UNIT_CALLIN_LOS_PARAM(EnteredRadar)
+UNIT_CALLIN_LOS_PARAM(EnteredLos)
+UNIT_CALLIN_LOS_PARAM(LeftRadar)
+UNIT_CALLIN_LOS_PARAM(LeftLos)
+
+
+inline void CEventHandler::UnitFromFactory(const CUnit* unit,
+                                               const CUnit* factory,
+                                               bool userOrders)
+{
+	const int unitAllyTeam = unit-&gt;allyteam;
+	const int count = listUnitFromFactory.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitFromFactory[i];
+		if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {
+			ec-&gt;UnitFromFactory(unit, factory, userOrders);
+		}
+	}
+}
+
+
+inline void CEventHandler::UnitDestroyed(const CUnit* unit,
+                                             const CUnit* attacker)
+{
+	const int unitAllyTeam = unit-&gt;allyteam;
+	const int count = listUnitDestroyed.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitDestroyed[i];
+		if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {
+			ec-&gt;UnitDestroyed(unit, attacker);
+		}
+	}
+}
+
+
+inline void CEventHandler::UnitCommand(const CUnit* unit,
+                                           const Command&amp; command)
+{
+	const int unitAllyTeam = unit-&gt;allyteam;
+	const int count = listUnitCommand.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitCommand[i];
+		if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {
+			ec-&gt;UnitCommand(unit, command);
+		}
+	}
+}
+
+
+inline void CEventHandler::UnitCmdDone(const CUnit* unit,
+                                           int cmdID, int cmdTag)
+{
+	const int unitAllyTeam = unit-&gt;allyteam;
+	const int count = listUnitCmdDone.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitCmdDone[i];
+		if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {
+			ec-&gt;UnitCmdDone(unit, cmdID, cmdTag);
+		}
+	}
+}
+
+
+inline void CEventHandler::UnitDamaged(const CUnit* unit,
+                                           const CUnit* attacker,
+                                           float damage, int weaponID,
+                                           bool paralyzer)
+{
+	const int unitAllyTeam = unit-&gt;allyteam;
+	const int count = listUnitDamaged.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitDamaged[i];
+		if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {
+			ec-&gt;UnitDamaged(unit, attacker, damage, weaponID, paralyzer);
+		}
+	}
+}
+
+
+inline void CEventHandler::UnitExperience(const CUnit* unit,
+                                              float oldExperience)
+{
+	const int unitAllyTeam = unit-&gt;allyteam;
+	const int count = listUnitExperience.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitExperience[i];
+		if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {
+			ec-&gt;UnitExperience(unit, oldExperience);
+		}
+	}
+}
+
+
+inline void  CEventHandler::UnitSeismicPing(const CUnit* unit,
+                                                int allyTeam,
+                                                const float3&amp; pos,
+                                                float strength)
+{
+	const int count = listUnitSeismicPing.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitSeismicPing[i];
+		if (ec-&gt;CanReadAllyTeam(allyTeam)) {
+			ec-&gt;UnitSeismicPing(unit, allyTeam, pos, strength);
+		}
+	}
+}
+
+
+inline void CEventHandler::UnitLoaded(const CUnit* unit,
+                                          const CUnit* transport)
+{
+	const int count = listUnitLoaded.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitLoaded[i];
+		const int ecAllyTeam = ec-&gt;GetReadAllyTeam();
+		if (ec-&gt;GetFullRead() ||
+		    (ecAllyTeam == unit-&gt;allyteam) ||
+		    (ecAllyTeam == transport-&gt;allyteam)) {
+			ec-&gt;UnitLoaded(unit, transport);
+		}
+	}
+}
+
+
+inline void CEventHandler::UnitUnloaded(const CUnit* unit,
+                                            const CUnit* transport)
+{
+	const int count = listUnitUnloaded.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listUnitUnloaded[i];
+		const int ecAllyTeam = ec-&gt;GetReadAllyTeam();
+		if (ec-&gt;GetFullRead() ||
+		    (ecAllyTeam == unit-&gt;allyteam) ||
+		    (ecAllyTeam == transport-&gt;allyteam)) {
+			ec-&gt;UnitUnloaded(unit, transport);
+		}
+	}
+}
+
+
+inline void CEventHandler::FeatureCreated(const CFeature* feature)
+{
+	const int featureAllyTeam = feature-&gt;allyteam;
+	const int count = listFeatureCreated.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listFeatureCreated[i];
+		if ((featureAllyTeam &lt; 0) || // global team
+		    ec-&gt;CanReadAllyTeam(featureAllyTeam)) {
+			ec-&gt;FeatureCreated(feature);
+		}
+	}
+}
+
+inline void CEventHandler::FeatureDestroyed(const CFeature* feature)
+{
+	const int featureAllyTeam = feature-&gt;allyteam;
+	const int count = listFeatureDestroyed.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listFeatureDestroyed[i];
+		if ((featureAllyTeam &lt; 0) || // global team
+		    ec-&gt;CanReadAllyTeam(featureAllyTeam)) {
+			ec-&gt;FeatureDestroyed(feature);
+		}
+	}
+}
+
+
+
+inline void CEventHandler::ProjectileCreated(const CProjectile* proj,
+                                                 int allyTeam)
+{
+	const int count = listProjectileCreated.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listProjectileCreated[i];
+		if ((allyTeam &lt; 0) || // projectile had no owner at creation
+		    ec-&gt;CanReadAllyTeam(allyTeam)) {
+			ec-&gt;ProjectileCreated(proj);
+		}
+	}
+}
+
+
+inline void CEventHandler::ProjectileDestroyed(const CProjectile* proj,
+                                                   int allyTeam)
+{
+	const int count = listProjectileDestroyed.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listProjectileDestroyed[i];
+		if ((allyTeam &lt; 0) || // projectile had no owner at creation
+		    ec-&gt;CanReadAllyTeam(allyTeam)) {
+			ec-&gt;ProjectileDestroyed(proj);
+		}
+	}
+}
+
+
+inline bool CEventHandler::Explosion(int weaponID,
+                                         const float3&amp; pos, const CUnit* owner)
+{
+	const int count = listExplosion.size();
+	bool noGfx = false;
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listExplosion[i];
+		if (ec-&gt;GetFullRead()) {
+			noGfx = noGfx || ec-&gt;Explosion(weaponID, pos, owner);
+		}
+	}
+	return noGfx;
+}
+
+
+inline void CEventHandler::StockpileChanged(const CUnit* unit,
+                                                const CWeapon* weapon,
+                                                int oldCount)
+{
+	const int unitAllyTeam = unit-&gt;allyteam;
+	const int count = listStockpileChanged.size();
+	for (int i = 0; i &lt; count; i++) {
+		CEventClient* ec = listStockpileChanged[i];
+		const int ecAllyTeam = ec-&gt;GetReadAllyTeam();
+		if (ec-&gt;CanReadAllyTeam(unitAllyTeam)) {
+			ec-&gt;StockpileChanged(unit, weapon, oldCount);
+		}
+	}
+}
+
+
+inline bool CEventHandler::DefaultCommand(const CUnit* unit,
+                                              const CFeature* feature,
+                                              int&amp; cmd)
+{
+	// reverse order, user has the override
+	const int count = listDefaultCommand.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CEventClient* ec = listDefaultCommand[i];
+		if (ec-&gt;DefaultCommand(unit, feature, cmd)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+
+#endif /* EVENT_HANDLER_H */

Modified: trunk/rts/System/FileSystem/FileHandler.h
===================================================================
--- trunk/rts/System/FileSystem/FileHandler.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/FileSystem/FileHandler.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -28,6 +28,9 @@
 		bool LoadStringData(std::string&amp; data);
 
 	public:
+		static bool InReadDir(const std::string&amp; path);
+		static bool InWriteDir(const std::string&amp; path);
+
 		static std::vector&lt;std::string&gt; FindFiles(const std::string&amp; path, const std::string&amp; pattern);
 
 		static std::vector&lt;std::string&gt; DirList(const std::string&amp; path,

Modified: trunk/rts/System/FileSystem/VFSModes.h
===================================================================
--- trunk/rts/System/FileSystem/VFSModes.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/FileSystem/VFSModes.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -3,9 +3,9 @@
 
 
 #define SPRING_VFS_RAW  &quot;r&quot;
-#define SPRING_VFS_MOD  &quot;M&quot;
-#define SPRING_VFS_MAP  &quot;m&quot;
-#define SPRING_VFS_BASE &quot;b&quot;
+#define SPRING_VFS_MOD  &quot;M&quot;  // currently equivalent to SPRING_VFS_ZIP
+#define SPRING_VFS_MAP  &quot;m&quot;  // currently equivalent to SPRING_VFS_ZIP
+#define SPRING_VFS_BASE &quot;b&quot;  // currently equivalent to SPRING_VFS_ZIP
 #define SPRING_VFS_NONE &quot; &quot;
 #define SPRING_VFS_MOD_BASE   SPRING_VFS_MOD  SPRING_VFS_BASE
 #define SPRING_VFS_MAP_BASE   SPRING_VFS_MAP  SPRING_VFS_BASE

Modified: trunk/rts/System/GlobalStuff.cpp
===================================================================
--- trunk/rts/System/GlobalStuff.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/GlobalStuff.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -289,6 +289,7 @@
 	modGameTime = 0;
 	gameTime = 0;
 	lastFrameTime = 0;
+	drawFrame = 1;
 	viewSizeX = 100;
 	viewSizeY = 100;
 	pixelX = 0.01f;

Modified: trunk/rts/System/GlobalStuff.h
===================================================================
--- trunk/rts/System/GlobalStuff.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/GlobalStuff.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -493,6 +493,9 @@
 	 */
 	float lastFrameTime;
 
+	// the draw frame number (never 0)
+	unsigned int drawFrame;
+
 	// the screen size in pixels
 	int screenSizeX;
 	int screenSizeY;

Modified: trunk/rts/System/Platform/FileSystem.cpp
===================================================================
--- trunk/rts/System/Platform/FileSystem.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/Platform/FileSystem.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -31,17 +31,19 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;mmgr.h&quot;
 
+
 #define fs (FileSystemHandler::GetInstance())
 
 FileSystem filesystem;
 
+
 ////////////////////////////////////////
 ////////// FileSystemHandler
 
 /**
  * @brief The global data directory handler instance
  */
-FileSystemHandler* FileSystemHandler::instance;
+FileSystemHandler* FileSystemHandler::instance = NULL;
 
 /**
  * @brief get the data directory handler instance
@@ -369,20 +371,37 @@
  */
 std::string FileSystem::LocateFile(std::string file, int flags) const
 {
-	if (!CheckFile(file))
+	if (!CheckFile(file)) {
 		return &quot;&quot;;
+	}
+
 	FixSlashes(file);
 
 	if (flags &amp; WRITE) {
-
-		if (flags &amp; CREATE_DIRS)
+		if (flags &amp; CREATE_DIRS) {
 			CreateDirectory(GetDirectory(file));
-
+		}
 		return file;
 	}
+
 	return fs.LocateFile(file);
 }
 
+
+bool FileSystem::InReadDir(const std::string&amp; path)
+{
+	const std::vector&lt;std::string&gt; readDirs = fs.GetDataDirectories();
+	return true;
+}
+
+
+bool FileSystem::InWriteDir(const std::string&amp; path, const std::string&amp; prefix)
+{
+	const std::string writeDir = fs.GetWriteDir();
+	return true;
+}
+
+
 /**
  * @brief remove a file
  *

Modified: trunk/rts/System/Platform/FileSystem.h
===================================================================
--- trunk/rts/System/Platform/FileSystem.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/Platform/FileSystem.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -35,9 +35,9 @@
 		virtual bool mkdir(const std::string&amp; dir) const = 0;
 
 		// custom functions
-		virtual std::string GetWriteDir() const = 0;
 		virtual std::vector&lt;std::string&gt; FindFiles(const std::string&amp; dir, const std::string&amp; pattern, int flags) const = 0;
 		virtual std::string LocateFile(const std::string&amp; file) const = 0;
+		virtual std::string GetWriteDir() const = 0;
 		virtual std::vector&lt;std::string&gt; GetDataDirectories() const = 0;
 
 		int GetNativePathSeparator() const { return native_path_separator; }
@@ -91,6 +91,8 @@
 		std::string glob_to_regex(const std::string&amp; glob) const;
 		std::string&amp; FixSlashes  (std::string&amp; path) const;
 		std::string&amp; ForwardSlashes(std::string&amp; path) const;
+		bool InReadDir(const std::string&amp; path);
+		bool InWriteDir(const std::string&amp; path, const std::string&amp; prefix = &quot;&quot;);
 
 	private:
 		bool CheckFile(const std::string&amp; file) const;

Modified: trunk/rts/System/Platform/Linux/UnixFileSystemHandler.cpp
===================================================================
--- trunk/rts/System/Platform/Linux/UnixFileSystemHandler.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/Platform/Linux/UnixFileSystemHandler.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -66,6 +66,7 @@
 	vfsHandler = new CVFSHandler();
 }
 
+
 /**
  * @brief Creates the archive scanner and vfs handler
  *
@@ -78,7 +79,7 @@
 		FileSystemHandler('\\')
 #endif
 {
-	if(initialize){
+	if (initialize) {
 		locater.LocateDataDirs();
 		InitVFS();
 	}
@@ -90,16 +91,18 @@
 	configHandler.Deallocate();
 }
 
+
 /**
  * @brief returns the highest priority writable directory, aka the writedir
  */
 std::string UnixFileSystemHandler::GetWriteDir() const
 {
 	const DataDir* writedir = locater.GetWriteDir();
-	assert(writedir &amp;&amp; writedir-&gt;writable); //duh
+	assert(writedir &amp;&amp; writedir-&gt;writable); // duh
 	return writedir-&gt;path;
 }
 
+
 /**
  * @brief find files
  * @param dir path in which to start looking (tried relative to each data directory)
@@ -116,7 +119,7 @@
 	std::vector&lt;std::string&gt; matches;
 
 	// if it's an absolute path, don't look for it in the data directories
-	if (dir[0] == '/' || (dir.length() &gt; 1 &amp;&amp; dir[1] == ':')) {
+	if ((dir[0] == '/') || ((dir.length() &gt; 1) &amp;&amp; (dir[1] == ':'))) {
 		FindFilesSingleDir(matches, dir, pattern, flags);
 		return matches;
 	}
@@ -128,34 +131,40 @@
 	return matches;
 }
 
+
 std::string UnixFileSystemHandler::LocateFile(const std::string&amp; file) const
 {
 	// if it's an absolute path, don't look for it in the data directories
 #ifdef WIN32
-	if (file.length()&gt;1 &amp;&amp; file[1] == ':')
+	if ((file.length() &gt; 1) &amp;&amp; (file[1] == ':')) {
 		return file;
+	}
 
 	const std::vector&lt;DataDir&gt;&amp; datadirs = locater.GetDataDirs();
 	for (std::vector&lt;DataDir&gt;::const_iterator d = datadirs.begin(); d != datadirs.end(); ++d) {
 		std::string fn(d-&gt;path + file);
-		if (_access(fn.c_str(), 4) == 0)
+		if (_access(fn.c_str(), 4) == 0) {
 			return fn;
+		}
 	}
 	return file;
 #else
-	if (file[0] == '/')
+	if (file[0] == '/') {
 		return file;
+	}
 
 	const std::vector&lt;DataDir&gt;&amp; datadirs = locater.GetDataDirs();
 	for (std::vector&lt;DataDir&gt;::const_iterator d = datadirs.begin(); d != datadirs.end(); ++d) {
 		std::string fn(d-&gt;path + file);
-		if (access(fn.c_str(), R_OK | F_OK) == 0)
+		if (access(fn.c_str(), R_OK | F_OK) == 0) {
 			return fn;
+		}
 	}
 	return file;
 #endif
 }
 
+
 std::vector&lt;std::string&gt; UnixFileSystemHandler::GetDataDirectories() const
 {
 	std::vector&lt;std::string&gt; f;
@@ -167,6 +176,7 @@
 	return f;
 }
 
+
 /**
  * @brief creates a rwxr-xr-x dir in the writedir
  *
@@ -208,6 +218,7 @@
 	return false;
 }
 
+
 static void FindFiles(std::vector&lt;std::string&gt;&amp; matches, const std::string&amp; dir, const boost::regex &amp;regexpattern, int flags)
 {
 #ifdef _WIN32

Modified: trunk/rts/System/Script/LuaFunctions.cpp
===================================================================
--- trunk/rts/System/Script/LuaFunctions.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/Script/LuaFunctions.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -13,7 +13,6 @@
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/StartScripts/Script.h&quot;
 #include &quot;Game/UI/EndGameBox.h&quot;
-#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Map/MapParser.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
@@ -25,6 +24,7 @@
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;Sim/Units/UnitTypes/TransportUnit.h&quot;
+#include &quot;System/EventHandler.h&quot;
 
 using namespace std;
 using namespace luabind;
@@ -39,7 +39,7 @@
 	{
 		SAFE_NEW CEndGameBox();
 		game-&gt;gameOver = true;
-		luaCallIns.GameOver();
+		eventHandler.GameOver();
 	}
 
 	void CreateGlobalAI( int teamnumber, std::string dllname )

Modified: trunk/rts/System/SpringApp.cpp
===================================================================
--- trunk/rts/System/SpringApp.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/System/SpringApp.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -802,6 +802,10 @@
 		if (!activeController-&gt;Update()) {
 			ret = 0;
 		} else {
+			gu-&gt;drawFrame++;
+			if (gu-&gt;drawFrame == 0) {
+				gu-&gt;drawFrame++;
+			}
 			ret = activeController-&gt;Draw();
 		}
 	}

Modified: trunk/rts/build/scons/rts.py
===================================================================
--- trunk/rts/build/scons/rts.py	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/build/scons/rts.py	2008-07-11 21:18:27 UTC (rev 6144)
@@ -86,6 +86,7 @@
 	usropts.AddOptions(
 		#permanent options
 		('platform',          'Set to linux, freebsd or windows', None),
+		('gml',               'Set to false to disable OpenGL thread library', True),
 		('debug',             'Set to yes to produce a binary with debug information', 0),
 		('debugdefines',      'Set to no to suppress DEBUG and _DEBUG preprocessor #defines (use to add symbols to release build)', True),
 		('syncdebug',         'Set to yes to enable the sync debugger', False),
@@ -102,7 +103,7 @@
 		('datadir',           'Data directory (relative to prefix)', 'share/games/spring'),
 		('bindir',            'Directory for executables (rel. to prefix)', 'games'),
 		('libdir',            'Directory for AI plugin modules (rel. to prefix)', 'lib/spring'),
-		('strip',             'Discard symbols from the executable (only when neither debugging nor profiling)', True),
+		('strip',             'Discard symbols from the executable (only when neither debugging nor profiling)', False),
 		#porting options - optional in a first phase
 		('disable_avi',       'Set to no to turn on avi support', 'False on windows, True otherwise'),
 		#other ported parts
@@ -146,7 +147,7 @@
 	if 'configure' in sys.argv:
 
 		# be paranoid, unset existing variables
-		for key in ['platform', 'debug', 'optimize', 'profile', 'profile_use', 'profile_generate', 'cpppath',
+		for key in ['platform', 'gml', 'debug', 'optimize', 'profile', 'profile_use', 'profile_generate', 'cpppath',
 			'libpath', 'prefix', 'installprefix', 'datadir', 'bindir', 'libdir', 'cachedir', 'strip',
 			'disable_avi', 'use_tcmalloc', 'use_mmgr', 'LINKFLAGS', 'LIBPATH', 'LIBS', 'CCFLAGS',
 			'CXXFLAGS', 'CPPDEFINES', 'CPPPATH', 'CC', 'CXX', 'is_configured', 'spring_defines']:
@@ -346,6 +347,7 @@
 			#else:
 			#	env['CXXFLAGS'] = env['CCFLAGS']
 
+		bool_opt('gml', True)
 		bool_opt('strip', False)
 		bool_opt('disable_avi', env['platform'] != 'windows')
 		bool_opt('use_tcmalloc', False)
@@ -362,6 +364,13 @@
 		env.AppendUnique(CPPDEFINES = ['_REENTRANT', '_SZ_ONE_DIRECTORY'])
 		spring_defines = []
 
+		# gml library
+		if env['gml']:
+			spring_defines += ['USE_GML']
+			print 'GML OpenGL thread library is enabled'
+		else:
+			print 'GML OpenGL thread library NOT enabled'
+
 		# Add define specifying type of floating point math to use.
 		if env['fpmath']:
 			if env['fpmath'] == 'sse':

Modified: trunk/rts/lib/gml/gml.cpp
===================================================================
--- trunk/rts/lib/gml/gml.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/gml/gml.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -31,6 +31,8 @@
 // Please note: Some functions may require more advanced coding to implement
 // If a function is not yet supported by GML, a compile error pointing to 'GML_FUNCTION_NOT_IMPLEMENTED' will occur
 
+#ifdef USE_GML
+
 #include &quot;gmlcls.h&quot;
 #include &quot;gml.h&quot;
 
@@ -1003,3 +1005,4 @@
 //  GML_DEBUG(&quot;ExecuteSync &quot;,procs);
 }
 
+#endif // USE_GML

Modified: trunk/rts/lib/gml/gml.h
===================================================================
--- trunk/rts/lib/gml/gml.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/gml/gml.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -9,6 +9,11 @@
 #ifndef GML_H
 #define GML_H
 
+#ifndef USE_GML
+#  define GML_VECTOR      std::vector
+#  define GML_CLASSVECTOR std::vector
+#else
+
 #include &lt;set&gt;
 #include &lt;map&gt;
 #include &lt;GL/glew.h&gt;
@@ -156,4 +161,6 @@
 #define GML_CLASSVECTOR std::vector
 #endif
 
+#endif // USE_GML
+
 #endif

Modified: trunk/rts/lib/gml/gmlsrv.h
===================================================================
--- trunk/rts/lib/gml/gmlsrv.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/gml/gmlsrv.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -9,6 +9,8 @@
 #ifndef GMLSRV_H
 #define GMLSRV_H
 
+#ifdef USE_GML
+
 #include &lt;boost/thread/barrier.hpp&gt;
 #include  &lt;boost/bind.hpp&gt;
 
@@ -260,4 +262,6 @@
 	}
 };
 
+#endif // USE_GML
+
 #endif

Modified: trunk/rts/lib/lua/README_SPRING
===================================================================
--- trunk/rts/lib/lua/README_SPRING	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/README_SPRING	2008-07-11 21:18:27 UTC (rev 6144)
@@ -45,3 +45,10 @@
        LUA_COMPAT_LSTR
        LUA_COMPAT_GFIND
        LUA_COMPAT_OPENLIB
+
+  10. Added the following to lua.h  (and associated code)
+        lua_set_fopen()
+        lua_set_popen()
+        lua_set_system()
+        lua_set_remove()
+        lua_set_rename()

Modified: trunk/rts/lib/lua/include/LuaInclude.h
===================================================================
--- trunk/rts/lib/lua/include/LuaInclude.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/include/LuaInclude.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -30,4 +30,28 @@
 }
 
 
+inline int lua_toint(lua_State* L, int idx)
+{
+  return (int)lua_tointeger(L, idx);
+}
+
+
+inline float lua_tofloat(lua_State* L, int idx)
+{
+  return (float)lua_tonumber(L, idx);
+}
+
+
+inline float luaL_checkfloat(lua_State* L, int idx)
+{
+  return (float)luaL_checknumber(L, idx);
+}
+
+
+inline float luaL_optfloat(lua_State* L, int idx, float def)
+{
+  return (float)luaL_optnumber(L, idx, def);
+}
+
+
 #endif // SPRING_LUA_INCLUDE

Modified: trunk/rts/lib/lua/include/lua.h
===================================================================
--- trunk/rts/lib/lua/include/lua.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/include/lua.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -107,6 +107,21 @@
 typedef unsigned int lua_Hash;
 
 
+/*
+** SPRING additions for io access security
+*/
+#include &lt;stdio.h&gt;
+typedef FILE* (*lua_Func_fopen)(lua_State* L, const char* path, const char* mode);
+typedef FILE* (*lua_Func_popen)(lua_State* L, const char* command, const char* type);
+typedef int   (*lua_Func_pclose)(lua_State* L, FILE* stream);
+typedef int   (*lua_Func_system)(lua_State* L, const char* command);
+typedef int   (*lua_Func_remove)(lua_State* L, const char* pathname);
+typedef int   (*lua_Func_rename)(lua_State* L, const char* oldpath, const char* newpath);
+LUA_API void lua_set_fopen(lua_State* L, lua_Func_fopen);
+LUA_API void lua_set_popen(lua_State* L, lua_Func_popen, lua_Func_pclose);
+LUA_API void lua_set_system(lua_State* L, lua_Func_system);
+LUA_API void lua_set_remove(lua_State* L, lua_Func_remove);
+LUA_API void lua_set_rename(lua_State* L, lua_Func_rename);
 
 /*
 ** state manipulation

Modified: trunk/rts/lib/lua/include/luaconf.h
===================================================================
--- trunk/rts/lib/lua/include/luaconf.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/include/luaconf.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -569,6 +569,7 @@
 /* On a Microsoft compiler, use assembler */
 #if defined(_MSC_VER)
 
+#warning Using ASM for lua_number2int  (SPRING)
 #define lua_number2int(i,d)   __asm fld d   __asm fistp i
 #define lua_number2integer(i,n)		lua_number2int(i, n)
 
@@ -576,6 +577,7 @@
    with a DirectX idiosyncrasy */
 #else
 
+#warning Using casting for lua_number2int  (SPRING)
 union luai_Cast { double l_d; long l_l; };
 #define lua_number2int(i,d) \
   { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }

Modified: trunk/rts/lib/lua/src/lapi.cpp
===================================================================
--- trunk/rts/lib/lua/src/lapi.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/src/lapi.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -1099,3 +1099,38 @@
   return name;
 }
 
+
+/* SPRING syscall additions */
+LUA_API void lua_set_fopen(lua_State* L, lua_Func_fopen func) {
+  G(L)-&gt;fopen_func = func;
+}
+
+
+LUA_API void lua_set_popen(lua_State* L, lua_Func_popen popen_func,
+                                         lua_Func_pclose pclose_func) {
+  if (popen_func &amp;&amp; pclose_func) {
+    G(L)-&gt;popen_func  = popen_func;
+    G(L)-&gt;pclose_func = pclose_func;
+  } else {
+    G(L)-&gt;popen_func  = NULL;
+    G(L)-&gt;pclose_func = NULL;
+  }
+}
+
+
+LUA_API void lua_set_system(lua_State* L, lua_Func_system func) {
+  G(L)-&gt;system_func = func;
+}
+
+
+LUA_API void lua_set_remove(lua_State* L, lua_Func_remove func) {
+  G(L)-&gt;remove_func = func;
+}
+
+
+LUA_API void lua_set_rename(lua_State* L, lua_Func_rename func) {
+  G(L)-&gt;rename_func = func;
+}
+/* END SPRING syscall additions */
+
+

Modified: trunk/rts/lib/lua/src/liolib.cpp
===================================================================
--- trunk/rts/lib/lua/src/liolib.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/src/liolib.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -17,6 +17,7 @@
 
 #include &quot;lauxlib.h&quot;
 #include &quot;lualib.h&quot;
+#include &quot;lstate.h&quot; /* SPRING */
 
 
 
@@ -27,6 +28,17 @@
 static const char *const fnames[] = {&quot;input&quot;, &quot;output&quot;};
 
 
+/* SPRING */
+static FILE* lua_fopen(lua_State* L, const char* filename, const char* mode)
+{
+  if (G(L)-&gt;fopen_func) {
+    return G(L)-&gt;fopen_func(L, filename, mode);
+  }
+  errno = EIO; /* why not? */
+  return NULL;
+}
+
+
 static int pushresult (lua_State *L, int i, const char *filename) {
   int en = errno;  /* calls to Lua API may change this value */
   if (i) {
@@ -98,7 +110,7 @@
 */
 static int io_pclose (lua_State *L) {
   FILE **p = topfile(L);
-  int ok = lua_pclose(L, *p);
+  int ok = lua_pclose(L, *p); // FIXME - SPRING L-&gt;pclose_func
   *p = NULL;
   return pushresult(L, ok, NULL);
 }
@@ -150,7 +162,7 @@
   const char *filename = luaL_checkstring(L, 1);
   const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
   FILE **pf = newfile(L);
-  *pf = fopen(filename, mode);
+  *pf = lua_fopen(L, filename, mode);
   return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
 }
 
@@ -159,7 +171,7 @@
   const char *filename = luaL_checkstring(L, 1);
   const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
   FILE **pf = newfile(L);
-  *pf = lua_popen(L, filename, mode);
+  *pf = lua_popen(L, filename, mode); // FIXME - SPRING L-&gt;popen_func
   return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
 }
 
@@ -186,7 +198,7 @@
     const char *filename = lua_tostring(L, 1);
     if (filename) {
       FILE **pf = newfile(L);
-      *pf = fopen(filename, mode);
+      *pf = lua_fopen(L, filename, mode);
       if (*pf == NULL)
         fileerror(L, 1, filename);
     }
@@ -238,7 +250,7 @@
   else {
     const char *filename = luaL_checkstring(L, 1);
     FILE **pf = newfile(L);
-    *pf = fopen(filename, &quot;r&quot;);
+    *pf = lua_fopen(L, filename, &quot;r&quot;);
     if (*pf == NULL)
       fileerror(L, 1, filename);
     aux_lines(L, lua_gettop(L), 1);

Modified: trunk/rts/lib/lua/src/lmathlib.cpp
===================================================================
--- trunk/rts/lib/lua/src/lmathlib.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/src/lmathlib.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -7,7 +7,7 @@
 
 #include &lt;stdlib.h&gt;
 //SPRING#include &lt;math.h&gt;
-#include &quot;streflop_cond.h&quot;
+#include &quot;streflop_cond.h&quot; // FIXME -- should always be compiled with streflop
 
 #define lmathlib_c
 #define LUA_LIB

Modified: trunk/rts/lib/lua/src/loslib.cpp
===================================================================
--- trunk/rts/lib/lua/src/loslib.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/src/loslib.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -18,6 +18,7 @@
 
 #include &quot;lauxlib.h&quot;
 #include &quot;lualib.h&quot;
+#include &quot;lstate.h&quot; /* SPRING */
 
 
 static int os_pushresult (lua_State *L, int i, const char *filename) {
@@ -36,21 +37,38 @@
 
 
 static int os_execute (lua_State *L) {
-  lua_pushinteger(L, system(luaL_optstring(L, 1, NULL)));
+  if (!G(L)-&gt;system_func) { /* SPRING */
+    lua_pushinteger(L, -1);
+  } else {
+    lua_pushinteger(L, G(L)-&gt;system_func(L, luaL_optstring(L, 1, NULL)));
+  }
   return 1;
 }
 
 
 static int os_remove (lua_State *L) {
   const char *filename = luaL_checkstring(L, 1);
-  return os_pushresult(L, remove(filename) == 0, filename);
+  int success = 0;
+  if (!G(L)-&gt;remove_func) { /* SPRING */
+    lua_pushnil(L);
+    lua_pushliteral(L, &quot;os.remove() is not available&quot;);
+    lua_pushnumber(L, 0);
+    return 3;
+  }
+  return os_pushresult(L, G(L)-&gt;remove_func(L, filename) == 0, filename);
 }
 
 
 static int os_rename (lua_State *L) {
   const char *fromname = luaL_checkstring(L, 1);
   const char *toname = luaL_checkstring(L, 2);
-  return os_pushresult(L, rename(fromname, toname) == 0, fromname);
+  if (!G(L)-&gt;rename_func) { /* SPRING */
+    lua_pushnil(L);
+    lua_pushliteral(L, &quot;os.rename() is not available&quot;);
+    lua_pushnumber(L, 0);
+    return 3;
+  }
+  return os_pushresult(L, G(L)-&gt;rename_func(L, fromname, toname) == 0, fromname);
 }
 
 

Modified: trunk/rts/lib/lua/src/lstate.cpp
===================================================================
--- trunk/rts/lib/lua/src/lstate.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/src/lstate.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -186,6 +186,15 @@
   }
   else
     luai_userstateopen(L);
+
+  /* SPRING additions, default to disabled functions */
+  g-&gt;fopen_func  = NULL;
+  g-&gt;popen_func  = NULL;
+  g-&gt;pclose_func = NULL;
+  g-&gt;system_func = NULL;
+  g-&gt;remove_func = NULL;
+  g-&gt;rename_func = NULL;
+
   return L;
 }
 

Modified: trunk/rts/lib/lua/src/lstate.h
===================================================================
--- trunk/rts/lib/lua/src/lstate.h	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/src/lstate.h	2008-07-11 21:18:27 UTC (rev 6144)
@@ -91,6 +91,15 @@
   UpVal uvhead;  /* head of double-linked list of all open upvalues */
   struct Table *mt[NUM_TAGS];  /* metatables for basic types */
   TString *tmname[TM_N];  /* array with tag-method names */
+
+  /* SPRING additions */
+  lua_Func_fopen  fopen_func;
+  lua_Func_popen  popen_func;
+  lua_Func_pclose pclose_func;
+  lua_Func_system system_func;
+  lua_Func_remove remove_func;
+  lua_Func_rename rename_func;
+
 } global_State;
 
 

Modified: trunk/rts/lib/lua/src/lvm.cpp
===================================================================
--- trunk/rts/lib/lua/src/lvm.cpp	2008-07-11 20:46:41 UTC (rev 6143)
+++ trunk/rts/lib/lua/src/lvm.cpp	2008-07-11 21:18:27 UTC (rev 6144)
@@ -9,7 +9,11 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
-#include &lt;cmath&gt; // SPRING -- for luaV_tostring
+//SPRING#include &lt;math.h&gt;
+#include &quot;streflop_cond.h&quot; // FIXME -- should always be compiled with streflop
+#ifdef UNITSYNC
+using std::isfinite;
+#endif
 
 #define lvm_c
 #define LUA_CORE
@@ -54,15 +58,15 @@
     lua_Number n = nvalue(obj);
     // SPRING -- synced safety change
     //        -- need a custom number formatter?
-	if (std::isfinite(n)) {
+    if (isfinite(n)) {
       lua_number2str(s, n);
     }
     else {
-      if (std::isnan(n)) {
+      if (isnan(n)) {
         strcpy(s, &quot;nan&quot;);
       }
       else {
-        const int inf_type = std::isinf(n);
+        const int inf_type = isinf(n);
         if (inf_type == 1) {
           strcpy(s, &quot;+inf&quot;);
         } else if (inf_type == -1) {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000923.html">[Taspring-linux-commit] r6143 - trunk/rts/lib/lua/src
</A></li>
	<LI>Next message: <A HREF="000925.html">[Taspring-linux-commit] r6145 - in trunk:	installer/builddata/springcontent/shaders rts/Rendering/Env	rts/System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#924">[ date ]</a>
              <a href="thread.html#924">[ thread ]</a>
              <a href="subject.html#924">[ subject ]</a>
              <a href="author.html#924">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
