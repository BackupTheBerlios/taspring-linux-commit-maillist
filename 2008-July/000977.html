<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6197 - trunk/rts/ExternalAI
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6197%20-%20trunk/rts/ExternalAI&In-Reply-To=%3C20080718134455.644174632%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000976.html">
   <LINK REL="Next"  HREF="000978.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6197 - trunk/rts/ExternalAI</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6197%20-%20trunk/rts/ExternalAI&In-Reply-To=%3C20080718134455.644174632%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6197 - trunk/rts/ExternalAI">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Jul 18 15:44:54 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000976.html">[Taspring-linux-commit] r6196 - in trunk/Lobby/TASClient: .	Graphics LobbyComponents Python Python/engine Python/scripts	Python/scripts/subf
</A></li>
        <LI>Next message: <A HREF="000978.html">[Taspring-linux-commit] r6198 - trunk/rts/Sim/Weapons
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#977">[ date ]</a>
              <a href="thread.html#977">[ thread ]</a>
              <a href="subject.html#977">[ subject ]</a>
              <a href="author.html#977">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-07-18 15:44:52 +0200 (Fri, 18 Jul 2008)
New Revision: 6197

Modified:
   trunk/rts/ExternalAI/AICallback.cpp
   trunk/rts/ExternalAI/AICallback.h
   trunk/rts/ExternalAI/IAICallback.h
Log:
In IAICallback and AICallback:
* renaming parameter names to be be consistent (mainly camel-casing)
* adding 3 new AI-Commands: AIHCGetUnitDefById, AIHCGetWeaponDefById, AIHCGetFeatureDefById

Modified: trunk/rts/ExternalAI/AICallback.cpp
===================================================================
--- trunk/rts/ExternalAI/AICallback.cpp	2008-07-18 01:10:44 UTC (rev 6196)
+++ trunk/rts/ExternalAI/AICallback.cpp	2008-07-18 13:44:52 UTC (rev 6197)
@@ -103,15 +103,15 @@
 
 
 
-bool CAICallback::SendResources(float mAmount, float eAmount, int receivingTeam)
+bool CAICallback::SendResources(float mAmount, float eAmount, int receivingTeamId)
 {
 	typedef unsigned char ubyte;
 	bool ret = false;
 
-	if (team != receivingTeam) {
-		if (receivingTeam &gt;= 0 &amp;&amp; receivingTeam &lt; (MAX_TEAMS - 1)) {
-			if (gs-&gt;Team(receivingTeam) &amp;&amp; gs-&gt;Team(team)) {
-				if (!gs-&gt;Team(receivingTeam)-&gt;isDead &amp;&amp; !gs-&gt;Team(team)-&gt;isDead) {
+	if (team != receivingTeamId) {
+		if (receivingTeamId &gt;= 0 &amp;&amp; receivingTeamId &lt; (MAX_TEAMS - 1)) {
+			if (gs-&gt;Team(receivingTeamId) &amp;&amp; gs-&gt;Team(team)) {
+				if (!gs-&gt;Team(receivingTeamId)-&gt;isDead &amp;&amp; !gs-&gt;Team(team)-&gt;isDead) {
 					// note: we can't use the existing SendShare()
 					// since its handler in CGame uses myPlayerNum
 					// (NETMSG_SHARE param) to determine which team
@@ -124,7 +124,7 @@
 					eAmount = std::max(0.0f, std::min(eAmount, GetEnergy()));
 					std::vector&lt;short&gt; empty;
 
-					net-&gt;Send(CBaseNetProtocol::Get().SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeam), mAmount, eAmount, empty));
+					net-&gt;Send(CBaseNetProtocol::Get().SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeamId), mAmount, eAmount, empty));
 				}
 			}
 		}
@@ -133,18 +133,18 @@
 	return ret;
 }
 
-int CAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam)
+int CAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIds, int receivingTeamId)
 {
 	typedef unsigned char ubyte;
 	std::vector&lt;short&gt; sentUnitIDs;
 
-	if (team != receivingTeam) {
-		if (receivingTeam &gt;= 0 &amp;&amp; receivingTeam &lt; (MAX_TEAMS - 1)) {
-			if (gs-&gt;Team(receivingTeam) &amp;&amp; gs-&gt;Team(team)) {
-				if (!gs-&gt;Team(receivingTeam)-&gt;isDead &amp;&amp; !gs-&gt;Team(team)-&gt;isDead) {
+	if (team != receivingTeamId) {
+		if (receivingTeamId &gt;= 0 &amp;&amp; receivingTeamId &lt; (MAX_TEAMS - 1)) {
+			if (gs-&gt;Team(receivingTeamId) &amp;&amp; gs-&gt;Team(team)) {
+				if (!gs-&gt;Team(receivingTeamId)-&gt;isDead &amp;&amp; !gs-&gt;Team(team)-&gt;isDead) {
 					// we must iterate over the ID's to check if
 					// all of them really belong to the AI's team
-					for (std::vector&lt;int&gt;::const_iterator it = unitIDs.begin(); it != unitIDs.end(); it++ ) {
+					for (std::vector&lt;int&gt;::const_iterator it = unitIds.begin(); it != unitIds.end(); it++ ) {
 						const int unitID = *it;
 
 						if (unitID &gt; 0 &amp;&amp; unitID &lt; MAX_UNITS) {
@@ -166,7 +166,7 @@
 					if (sentUnitIDs.size() &gt; 0) {
 						// we can't use SendShare() here either, since
 						// AI's don't have a notion of &quot;selected units&quot;
-						net-&gt;Send(CBaseNetProtocol::Get().SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeam), 0.0f, 0.0f, sentUnitIDs));
+						net-&gt;Send(CBaseNetProtocol::Get().SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeamId), 0.0f, 0.0f, sentUnitIDs));
 					}
 				}
 			}
@@ -210,18 +210,18 @@
 	return gs-&gt;AllyTeam(team);
 }
 
-int CAICallback::GetPlayerTeam(int player)
+int CAICallback::GetPlayerTeam(int playerId)
 {
-	CPlayer *pl = gs-&gt;players [player];
+	CPlayer *pl = gs-&gt;players [playerId];
 	if (pl-&gt;spectator)
 		return -1;
 	return pl-&gt;team;
 }
 
-const char* CAICallback::GetTeamSide(int team)
+const char* CAICallback::GetTeamSide(int teamId)
 {
-	if (team &lt; gs-&gt;activeTeams &amp;&amp; gameSetup) {
-		return gs-&gt;Team(team)-&gt;side.c_str();
+	if (teamId &lt; gs-&gt;activeTeams &amp;&amp; gameSetup) {
+		return gs-&gt;Team(teamId)-&gt;side.c_str();
 	} else {
 		// if this is not a GameSetup-type game but a
 		// GlobalAI-test one, the side-strings for all
@@ -244,38 +244,38 @@
 	globalAI-&gt;ReleaseAIBuffer(team,name);
 }
 
-int CAICallback::CreateGroup(char* dll, unsigned aiNumber)
+int CAICallback::CreateGroup(char* libraryName, unsigned aiNumber)
 {
 	AIKey key;
-	key.dllName=dll;
+	key.dllName=libraryName;
 	key.aiNumber=aiNumber;
 	CGroup* g=gh-&gt;CreateNewGroup(key);
 	return g-&gt;id;
 }
 
-void CAICallback::EraseGroup(int groupid)
+void CAICallback::EraseGroup(int groupId)
 {
-	if (CHECK_GROUPID(groupid)) {
-		if(gh-&gt;groups[groupid])
-			gh-&gt;RemoveGroup(gh-&gt;groups[groupid]);
+	if (CHECK_GROUPID(groupId)) {
+		if(gh-&gt;groups[groupId])
+			gh-&gt;RemoveGroup(gh-&gt;groups[groupId]);
 	}
 }
 
-bool CAICallback::AddUnitToGroup(int unitid, int groupid)
+bool CAICallback::AddUnitToGroup(int unitId, int groupId)
 {
-	if (CHECK_UNITID(unitid) &amp;&amp; CHECK_GROUPID(groupid)) {
-		CUnit* u=uh-&gt;units[unitid];
-		if(u &amp;&amp; u-&gt;team==team &amp;&amp; gh-&gt;groups[groupid]){
-			return u-&gt;SetGroup(gh-&gt;groups[groupid]);
+	if (CHECK_UNITID(unitId) &amp;&amp; CHECK_GROUPID(groupId)) {
+		CUnit* u=uh-&gt;units[unitId];
+		if(u &amp;&amp; u-&gt;team==team &amp;&amp; gh-&gt;groups[groupId]){
+			return u-&gt;SetGroup(gh-&gt;groups[groupId]);
 		}
 	}
 	return false;
 }
 
-bool CAICallback::RemoveUnitFromGroup(int unitid)
+bool CAICallback::RemoveUnitFromGroup(int unitId)
 {
-	if (CHECK_UNITID(unitid)) {
-		CUnit* u=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* u=uh-&gt;units[unitId];
 		if(u &amp;&amp; u-&gt;team==team){
 			u-&gt;SetGroup(0);
 			return true;
@@ -284,12 +284,12 @@
 	return false;
 }
 
-int CAICallback::GetUnitGroup(int unitid)
+int CAICallback::GetUnitGroup(int unitId)
 {
-	if (CHECK_UNITID(unitid)) {
-		CUnit *unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit *unit = uh-&gt;units[unitId];
 		if (unit &amp;&amp; unit-&gt;team == team) {
-			CGroup* g=uh-&gt;units[unitid]-&gt;group;
+			CGroup* g=uh-&gt;units[unitId]-&gt;group;
 			if(g)
 				return g-&gt;id;
 		}
@@ -297,37 +297,37 @@
 	return -1;
 }
 
-const std::vector&lt;CommandDescription&gt;* CAICallback::GetGroupCommands(int groupid)
+const std::vector&lt;CommandDescription&gt;* CAICallback::GetGroupCommands(int groupId)
 {
 	static std::vector&lt;CommandDescription&gt; tempcmds;
 
-	if (CHECK_GROUPID(groupid)) {
-		if(gh-&gt;groups[groupid] &amp;&amp; gh-&gt;groups[groupid]-&gt;ai)
-			return &amp;gh-&gt;groups[groupid]-&gt;ai-&gt;GetPossibleCommands();
+	if (CHECK_GROUPID(groupId)) {
+		if(gh-&gt;groups[groupId] &amp;&amp; gh-&gt;groups[groupId]-&gt;ai)
+			return &amp;gh-&gt;groups[groupId]-&gt;ai-&gt;GetPossibleCommands();
 	}
 	return &tempcmds;
 }
 
-int CAICallback::GiveGroupOrder(int groupid, Command* c)
+int CAICallback::GiveGroupOrder(int groupId, Command* c)
 {
-	if (CHECK_GROUPID(groupid) &amp;&amp; c != NULL) {
-		if(gh-&gt;groups[groupid] &amp;&amp; gh-&gt;groups[groupid]-&gt;ai)
-			gh-&gt;groups[groupid]-&gt;ai-&gt;GiveCommand(c);
+	if (CHECK_GROUPID(groupId) &amp;&amp; c != NULL) {
+		if(gh-&gt;groups[groupId] &amp;&amp; gh-&gt;groups[groupId]-&gt;ai)
+			gh-&gt;groups[groupId]-&gt;ai-&gt;GiveCommand(c);
 	}
 	return 0;
 }
 
-int CAICallback::GiveOrder(int unitid, Command* c)
+int CAICallback::GiveOrder(int unitId, Command* c)
 {
 	verify ();
 
-	if (!CHECK_UNITID(unitid) || c == NULL)
+	if (!CHECK_UNITID(unitId) || c == NULL)
 		return -1;
 
 	if (noMessages)
 		return -1;
 
-	CUnit *unit = uh-&gt;units[unitid];
+	CUnit *unit = uh-&gt;units[unitId];
 
 	if (!unit)
 		return -1;
@@ -338,35 +338,35 @@
 	if (unit-&gt;team != team)
 		return -1;
 
-	net-&gt;Send(CBaseNetProtocol::Get().SendAICommand(gu-&gt;myPlayerNum, unitid, c-&gt;id, c-&gt;options, c-&gt;params));
+	net-&gt;Send(CBaseNetProtocol::Get().SendAICommand(gu-&gt;myPlayerNum, unitId, c-&gt;id, c-&gt;options, c-&gt;params));
 	return 0;
 }
 
-const vector&lt;CommandDescription&gt;* CAICallback::GetUnitCommands(int unitid)
+const vector&lt;CommandDescription&gt;* CAICallback::GetUnitCommands(int unitId)
 {
-	if (CHECK_UNITID(unitid)) {
-		CUnit *unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit *unit = uh-&gt;units[unitId];
 		if (unit &amp;&amp; unit-&gt;team == team)
 			return &amp;unit-&gt;commandAI-&gt;possibleCommands;
 	}
 	return 0;
 }
 
-const CCommandQueue* CAICallback::GetCurrentUnitCommands(int unitid)
+const CCommandQueue* CAICallback::GetCurrentUnitCommands(int unitId)
 {
-	if (CHECK_UNITID(unitid)) {
-		CUnit *unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit *unit = uh-&gt;units[unitId];
 		if (unit &amp;&amp; unit-&gt;team == team)
 			return &amp;unit-&gt;commandAI-&gt;commandQue;
 	}
 	return 0;
 }
 
-int CAICallback::GetUnitAiHint(int unitid)
+int CAICallback::GetUnitAiHint(int unitId)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 		if (unit) {
 			const int allyTeam = gs-&gt;AllyTeam(team);
 			if (gs-&gt;Ally(unit-&gt;allyteam, allyTeam)) {
@@ -386,11 +386,11 @@
 	return 0;
 }
 
-int CAICallback::GetUnitTeam(int unitid)
+int CAICallback::GetUnitTeam(int unitId)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
 			return unit-&gt;team;
 		}
@@ -398,11 +398,11 @@
 	return 0;
 }
 
-int CAICallback::GetUnitAllyTeam(int unitid)
+int CAICallback::GetUnitAllyTeam(int unitId)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
 			return unit-&gt;allyteam;
 		}
@@ -410,11 +410,11 @@
 	return 0;
 }
 
-float CAICallback::GetUnitHealth(int unitid)
+float CAICallback::GetUnitHealth(int unitId)
 {
 	verify();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 
 		if (unit) {
 			const int allyTeam = gs-&gt;AllyTeam(team);
@@ -439,11 +439,11 @@
 	return 0;
 }
 
-float CAICallback::GetUnitMaxHealth(int unitid)		//the units max health
+float CAICallback::GetUnitMaxHealth(int unitId)		//the units max health
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 		if (unit) {
 			const int allyTeam = gs-&gt;AllyTeam(team);
 			if (gs-&gt;Ally(unit-&gt;allyteam, allyTeam)) {
@@ -464,11 +464,11 @@
 	return 0;
 }
 
-float CAICallback::GetUnitSpeed(int unitid)				//the units max speed
+float CAICallback::GetUnitSpeed(int unitId)				//the units max speed
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 		if (unit) {
 			const int allyTeam = gs-&gt;AllyTeam(team);
 			if (gs-&gt;Ally(unit-&gt;allyteam, allyTeam)) {
@@ -488,11 +488,11 @@
 	return 0;
 }
 
-float CAICallback::GetUnitPower(int unitid)				//sort of the measure of the units overall power
+float CAICallback::GetUnitPower(int unitId)				//sort of the measure of the units overall power
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 		if (unit) {
 			const int allyTeam = gs-&gt;AllyTeam(team);
 			if (gs-&gt;Ally(unit-&gt;allyteam, allyTeam)) {
@@ -513,11 +513,11 @@
 	return 0;
 }
 
-float CAICallback::GetUnitExperience(int unitid)	//how experienced the unit is (0.0-1.0)
+float CAICallback::GetUnitExperience(int unitId)	//how experienced the unit is (0.0-1.0)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			return unit-&gt;experience;
 		}
@@ -525,11 +525,11 @@
 	return 0;
 }
 
-float CAICallback::GetUnitMaxRange(int unitid)		//the furthest any weapon of the unit can fire
+float CAICallback::GetUnitMaxRange(int unitId)		//the furthest any weapon of the unit can fire
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 		if (unit) {
 			const int allyTeam = gs-&gt;AllyTeam(team);
 			if (gs-&gt;Ally(unit-&gt;allyteam, allyTeam)) {
@@ -549,11 +549,11 @@
 	return 0;
 }
 
-const UnitDef* CAICallback::GetUnitDef(int unitid)
+const UnitDef* CAICallback::GetUnitDef(int unitId)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 		if (unit) {
 			const UnitDef* unitDef = unit-&gt;unitDef;
 			const int allyTeam = gs-&gt;AllyTeam(team);
@@ -580,12 +580,16 @@
 {
 	return unitDefHandler-&gt;GetUnitByName(unitName);
 }
+const UnitDef* CAICallback::GetUnitDefById (int unitDefId)
+{
+	return unitDefHandler-&gt;GetUnitByID(unitDefId);
+}
 
-float3 CAICallback::GetUnitPos(int unitid)
+float3 CAICallback::GetUnitPos(int unitId)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INLOS|LOS_INRADAR))){
 			return helper-&gt;GetUnitErrorPos(unit,gs-&gt;AllyTeam(team));
 		}
@@ -593,10 +597,10 @@
 	return ZeroVector;
 }
 
-int CAICallback::GetBuildingFacing(int unitid) {
+int CAICallback::GetBuildingFacing(int unitId) {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
 			return unit-&gt;buildFacing;
 		}
@@ -604,10 +608,10 @@
 	return 0;
 }
 
-bool CAICallback::IsUnitCloaked(int unitid) {
+bool CAICallback::IsUnitCloaked(int unitId) {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
 			return unit-&gt;isCloaked;
 		}
@@ -615,11 +619,11 @@
 	return false;
 }
 
-bool CAICallback::IsUnitParalyzed(int unitid){
+bool CAICallback::IsUnitParalyzed(int unitId){
 	verify();
 
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			return unit-&gt;stunned;
 		}
@@ -628,11 +632,11 @@
 	return false;
 }
 
-bool CAICallback::IsUnitNeutral(int unitid) {
+bool CAICallback::IsUnitNeutral(int unitId) {
 	verify();
 
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 
 		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			if (unit-&gt;IsNeutral())
@@ -648,14 +652,14 @@
 	return pathManager-&gt;RequestPath(moveinfo-&gt;moveData.at(pathType),start,end);
 }
 
-float3 CAICallback::GetNextWaypoint(int pathid)
+float3 CAICallback::GetNextWaypoint(int pathId)
 {
-	return pathManager-&gt;NextWaypoint(pathid,ZeroVector);
+	return pathManager-&gt;NextWaypoint(pathId,ZeroVector);
 }
 
-void CAICallback::FreePath(int pathid)
+void CAICallback::FreePath(int pathId)
 {
-	pathManager-&gt;DeletePath(pathid);
+	pathManager-&gt;DeletePath(pathId);
 }
 
 float CAICallback::GetPathLength(float3 start, float3 end, int pathType)
@@ -667,7 +671,7 @@
 
 
 
-int CAICallback::GetEnemyUnits(int* units)
+int CAICallback::GetEnemyUnits(int* unitIds)
 {
 	verify();
 	std::list&lt;CUnit*&gt;::iterator ui;
@@ -679,7 +683,7 @@
 		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp;
 		    (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			if (!IsUnitNeutral(u-&gt;id)) {
-				units[a++] = u-&gt;id;
+				unitIds[a++] = u-&gt;id;
 			}
 		}
 	}
@@ -687,7 +691,7 @@
 	return a;
 }
 
-int CAICallback::GetEnemyUnitsInRadarAndLos(int* units)
+int CAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds)
 {
 	verify();
 	std::list&lt;CUnit*&gt;::iterator ui;
@@ -698,7 +702,7 @@
 
 		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INLOS | LOS_INRADAR))) {
 			if (!IsUnitNeutral(u-&gt;id)) {
-				units[a++] = u-&gt;id;
+				unitIds[a++] = u-&gt;id;
 			}
 		}
 	}
@@ -706,7 +710,7 @@
 	return a;
 }
 
-int CAICallback::GetEnemyUnits(int* units, const float3&amp; pos, float radius)
+int CAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius)
 {
 	verify();
 	vector&lt;CUnit*&gt; unit = qf-&gt;GetUnitsExact(pos, radius);
@@ -718,7 +722,7 @@
 
 		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			if (!IsUnitNeutral(u-&gt;id)) {
-				units[a] = u-&gt;id;
+				unitIds[a] = u-&gt;id;
 				++a;
 			}
 		}
@@ -728,7 +732,7 @@
 }
 
 
-int CAICallback::GetFriendlyUnits(int *units)
+int CAICallback::GetFriendlyUnits(int *unitIds)
 {
 	verify();
 	int a = 0;
@@ -740,7 +744,7 @@
 			// IsUnitNeutral does a LOS check, but inconsequential
 			// since we can always see friendly units anyway
 			if (!IsUnitNeutral(u-&gt;id)) {
-				units[a++] = u-&gt;id;
+				unitIds[a++] = u-&gt;id;
 			}
 		}
 	}
@@ -748,7 +752,7 @@
 	return a;
 }
 
-int CAICallback::GetFriendlyUnits(int *units, const float3&amp; pos, float radius)
+int CAICallback::GetFriendlyUnits(int *unitIds, const float3&amp; pos, float radius)
 {
 	verify();
 	vector&lt;CUnit*&gt; unit = qf-&gt;GetUnitsExact(pos, radius);
@@ -762,7 +766,7 @@
 			// IsUnitNeutral does a LOS check, but inconsequential
 			// since we can always see friendly units anyway
 			if (!IsUnitNeutral(u-&gt;id)) {
-				units[a] = u-&gt;id;
+				unitIds[a] = u-&gt;id;
 				++a;
 			}
 		}
@@ -772,7 +776,7 @@
 }
 
 
-int CAICallback::GetNeutralUnits(int* units)
+int CAICallback::GetNeutralUnits(int* unitIds)
 {
 	verify();
 	int a = 0;
@@ -782,14 +786,14 @@
 
 		// IsUnitNeutral does the LOS check
 		if (IsUnitNeutral(u-&gt;id)) {
-			units[a++] = u-&gt;id;
+			unitIds[a++] = u-&gt;id;
 		}
 	}
 
 	return a;
 }
 
-int CAICallback::GetNeutralUnits(int* units, const float3&amp; pos, float radius)
+int CAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius)
 {
 	verify();
 	vector&lt;CUnit*&gt; unit = qf-&gt;GetUnitsExact(pos, radius);
@@ -801,7 +805,7 @@
 
 		// IsUnitNeutral does the LOS check
 		if (IsUnitNeutral(u-&gt;id)) {
-			units[a] = u-&gt;id;
+			unitIds[a] = u-&gt;id;
 			++a;
 		}
 	}
@@ -933,14 +937,14 @@
 	lineDrawer.DrawLine(endPos,color);
 }
 
-void CAICallback::LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color)
+void CAICallback::LineDrawerDrawLineAndIcon(int commandId, const float3&amp; endPos, const float* color)
 {
-	lineDrawer.DrawLineAndIcon(cmdID,endPos,color);
+	lineDrawer.DrawLineAndIcon(commandId,endPos,color);
 }
 
-void CAICallback::LineDrawerDrawIconAtLastPos(int cmdID)
+void CAICallback::LineDrawerDrawIconAtLastPos(int commandId)
 {
-	lineDrawer.DrawIconAtLastPos(cmdID);
+	lineDrawer.DrawIconAtLastPos(commandId);
 }
 
 void CAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color)
@@ -978,17 +982,17 @@
 	geometricObjects-&gt;DeleteGroup(group);
 }
 
-void CAICallback::DrawUnit(const char* name,float3 pos,float rotation,int lifetime,int team,bool transparent,bool drawBorder,int facing)
+void CAICallback::DrawUnit(const char* unitName,float3 pos,float rotation,int lifetime,int teamId,bool transparent,bool drawBorder,int facing)
 {
 	CUnitDrawer::TempDrawUnit tdu;
-	tdu.unitdef=unitDefHandler-&gt;GetUnitByName(name);
+	tdu.unitdef=unitDefHandler-&gt;GetUnitByName(unitName);
 	if(!tdu.unitdef){
-		logOutput.Print(&quot;Uknown unit in CAICallback::DrawUnit %s&quot;,name);
+		logOutput.Print(&quot;Uknown unit in CAICallback::DrawUnit %s&quot;,unitName);
 		return;
 	}
 	tdu.pos=pos;
 	tdu.rotation=rotation;
-	tdu.team=team;
+	tdu.team=teamId;
 	tdu.drawBorder=drawBorder;
 	tdu.facing=facing;
 	std::pair&lt;int,CUnitDrawer::TempDrawUnit&gt; tp(gs-&gt;frameNum+lifetime,tdu);
@@ -998,7 +1002,7 @@
 		unitDrawer-&gt;tempDrawUnits.insert(tp);
 }
 
-bool CAICallback::CanBuildAt(const UnitDef* unitDef,float3 pos, int facing)
+bool CAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing)
 {
 	CFeature* f;
 	BuildInfo bi(unitDef, pos, facing);
@@ -1130,10 +1134,10 @@
 	return gs-&gt;Team(team)-&gt;energyStorage;
 }
 
-bool CAICallback::GetUnitResourceInfo (int unitid, UnitResourceInfo *i)
+bool CAICallback::GetUnitResourceInfo (int unitId, UnitResourceInfo *i)
 {
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS))
 		{
 			i-&gt;energyMake = unit-&gt;energyMake;
@@ -1146,22 +1150,22 @@
 	return false;
 }
 
-bool CAICallback::IsUnitActivated (int unitid)
+bool CAICallback::IsUnitActivated (int unitId)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS))
 			return unit-&gt;activated;
 	}
 	return false;
 }
 
-bool CAICallback::UnitBeingBuilt (int unitid)
+bool CAICallback::UnitBeingBuilt (int unitId)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit=uh-&gt;units[unitId];
 		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS))
 			return unit-&gt;beingBuilt;
 	}
@@ -1227,6 +1231,10 @@
 
 	return 0;
 }
+const FeatureDef* CAICallback::GetFeatureDefById(int featureDefId)
+{
+	return featureHandler-&gt;GetFeatureDefByID(featureDefId);
+}
 
 float CAICallback::GetFeatureHealth (int feature)
 {
@@ -1358,6 +1366,24 @@
 	case AIHCSendStartPosId:
 		SendStartPos(((AIHCSendStartPos *)data)-&gt;ready,((AIHCSendStartPos *)data)-&gt;pos);
 		return 1;
+	case AIHCGetUnitDefByIdId:
+	{
+		AIHCGetUnitDefById* cmdData = (AIHCGetUnitDefById*) data;
+		cmdData-&gt;ret = GetUnitDefById(cmdData-&gt;unitDefId);
+		return 1;
+	}
+	case AIHCGetWeaponDefByIdId:
+	{
+		AIHCGetWeaponDefById* cmdData = (AIHCGetWeaponDefById*) data;
+		cmdData-&gt;ret = GetWeaponDefById(cmdData-&gt;weaponDefId);
+		return 1;
+	}
+	case AIHCGetFeatureDefByIdId:
+	{
+		AIHCGetFeatureDefById* cmdData = (AIHCGetFeatureDefById*) data;
+		cmdData-&gt;ret = GetFeatureDefById(cmdData-&gt;featureDefId);
+		return 1;
+	}
 	default:
 		return 0;
 	}
@@ -1390,11 +1416,11 @@
 }
 
 
-bool CAICallback::GetProperty(int unitid, int property, void *data)
+bool CAICallback::GetProperty(int unitId, int property, void *data)
 {
 	verify ();
-	if (CHECK_UNITID(unitid)) {
-		CUnit* unit = uh-&gt;units[unitid];
+	if (CHECK_UNITID(unitId)) {
+		CUnit* unit = uh-&gt;units[unitId];
 		const int allyTeam = gs-&gt;AllyTeam(team);
 		if (!(unit &amp;&amp; (unit-&gt;losStatus[allyTeam] &amp; LOS_INLOS))) {
 			return false;  //return if the unit doesn't exist or cant be seen
@@ -1445,9 +1471,9 @@
 }
 
 
-int CAICallback::GetFileSize (const char *name)
+int CAICallback::GetFileSize (const char *filename)
 {
-	CFileHandler fh (name);
+	CFileHandler fh (filename);
 
 	if (!fh.FileExists ())
 		return -1;
@@ -1456,9 +1482,9 @@
 }
 
 
-int CAICallback::GetFileSize (const char *name, const char* modes)
+int CAICallback::GetFileSize (const char *filename, const char* modes)
 {
-	CFileHandler fh (name, modes);
+	CFileHandler fh (filename, modes);
 
 	if (!fh.FileExists ())
 		return -1;
@@ -1467,9 +1493,9 @@
 }
 
 
-bool CAICallback::ReadFile (const char *name, void *buffer, int bufferLength)
+bool CAICallback::ReadFile (const char *filename, void *buffer, int bufferLength)
 {
-	CFileHandler fh (name);
+	CFileHandler fh (filename);
 	int fs;
 	if (!fh.FileExists() || bufferLength &lt; (fs = fh.FileSize()))
 		return false;
@@ -1479,10 +1505,10 @@
 }
 
 
-bool CAICallback::ReadFile (const char *name, const char* modes,
+bool CAICallback::ReadFile (const char *filename, const char* modes,
                             void *buffer, int bufferLength)
 {
-	CFileHandler fh (name, modes);
+	CFileHandler fh (filename, modes);
 	int fs;
 	if (!fh.FileExists() || bufferLength &lt; (fs = fh.FileSize()))
 		return false;
@@ -1493,7 +1519,7 @@
 
 
 // Additions to the interface by Alik
-int CAICallback::GetSelectedUnits(int *units)
+int CAICallback::GetSelectedUnits(int *unitIds)
 {
 	verify();
 	int a = 0;
@@ -1502,7 +1528,7 @@
 	// the AI lib matches the AI's actual allyteam
 	if (gu-&gt;myAllyTeam == gs-&gt;AllyTeam(team)) {
 		for (CUnitSet::iterator ui = selectedUnits.selectedUnits.begin(); ui != selectedUnits.selectedUnits.end(); ++ui)
-			units[a++] = (*ui)-&gt;id;
+			unitIds[a++] = (*ui)-&gt;id;
 	}
 	return a;
 }
@@ -1566,10 +1592,14 @@
 }
 
 
-const WeaponDef* CAICallback::GetWeapon(const char* weaponname)
+const WeaponDef* CAICallback::GetWeapon(const char* weaponName)
 {
-	return weaponDefHandler-&gt;GetWeapon(weaponname);
+	return weaponDefHandler-&gt;GetWeapon(weaponName);
 }
+const WeaponDef* CAICallback::GetWeaponDefById(int weaponDefId)
+{
+	return weaponDefHandler-&gt;GetWeaponById(weaponDefId);
+}
 
 
 bool CAICallback::CanBuildUnit(int unitDefID)

Modified: trunk/rts/ExternalAI/AICallback.h
===================================================================
--- trunk/rts/ExternalAI/AICallback.h	2008-07-18 01:10:44 UTC (rev 6196)
+++ trunk/rts/ExternalAI/AICallback.h	2008-07-18 13:44:52 UTC (rev 6197)
@@ -24,65 +24,68 @@
 	void SetLastMsgPos(float3 pos);
 	void AddNotification(float3 pos, float3 color, float alpha);
 
-	bool SendResources(float mAmount, float eAmount, int receivingTeam);
-	int SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam);
+	bool SendResources(float mAmount, float eAmount, int receivingTeamId);
+	int SendUnits(const std::vector&lt;int&gt;&amp; unitIds, int receivingTeamId);
 
 	bool PosInCamera(float3 pos, float radius);
 
 	int GetCurrentFrame();
 	int GetMyTeam();
 	int GetMyAllyTeam();
-	int GetPlayerTeam(int player);
-	const char* GetTeamSide(int team);
+	int GetPlayerTeam(int playerId);
+	const char* GetTeamSide(int teamId);
 	void* CreateSharedMemArea(char* name, int size);
 	void ReleasedSharedMemArea(char* name);
 
-	int CreateGroup(char* dll, unsigned aiNumber);
-	void EraseGroup(int groupid);
-	bool AddUnitToGroup(int unitid, int groupid);
-	bool RemoveUnitFromGroup(int unitid);
-	int GetUnitGroup(int unitid);
-	const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid);
-	int GiveGroupOrder(int unitid, Command* c);
+	int CreateGroup(char* libraryName, unsigned aiNumber);
+	void EraseGroup(int groupId);
+	bool AddUnitToGroup(int unitId, int groupId);
+	bool RemoveUnitFromGroup(int unitId);
+	int GetUnitGroup(int unitId);
+	const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int groupId);
+	int GiveGroupOrder(int unitId, Command* c);
 
-	int GiveOrder(int unitid,Command* c);
-	const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid);
-	const CCommandQueue* GetCurrentUnitCommands(int unitid);
+	int GiveOrder(int unitId,Command* c);
+	const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitId);
+	const CCommandQueue* GetCurrentUnitCommands(int unitId);
 
-	int GetUnitAiHint(int unitid);
-	int GetUnitTeam(int unitid);
-	int GetUnitAllyTeam(int unitid);
-	float GetUnitHealth(int unitid);
-	float GetUnitMaxHealth(int unitid);
-	float GetUnitSpeed(int unitid);
-	float GetUnitPower(int unitid);
-	float GetUnitExperience(int unitid);
-	float GetUnitMaxRange(int unitid);
-	bool IsUnitActivated (int unitid);
-	bool UnitBeingBuilt(int unitid);
-	const UnitDef* GetUnitDef(int unitid);
-	float3 GetUnitPos(int unitid);
-	int GetBuildingFacing(int unitid);
-	bool IsUnitCloaked(int unitid);
-	bool IsUnitParalyzed(int unitid);
-	bool IsUnitNeutral(int unitid);
-	bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
+	int GetUnitAiHint(int unitId);
+	int GetUnitTeam(int unitId);
+	int GetUnitAllyTeam(int unitId);
+	float GetUnitHealth(int unitId);
+	float GetUnitMaxHealth(int unitId);
+	float GetUnitSpeed(int unitId);
+	float GetUnitPower(int unitId);
+	float GetUnitExperience(int unitId);
+	float GetUnitMaxRange(int unitId);
+	bool IsUnitActivated (int unitId);
+	bool UnitBeingBuilt(int unitId);
+	const UnitDef* GetUnitDef(int unitId);
+	float3 GetUnitPos(int unitId);
+	int GetBuildingFacing(int unitId);
+	bool IsUnitCloaked(int unitId);
+	bool IsUnitParalyzed(int unitId);
+	bool IsUnitNeutral(int unitId);
+	bool GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo);
 
 	const UnitDef* GetUnitDef(const char* unitName);
+private:
+	const UnitDef* GetUnitDefById(int unitDefId);
+public:
 
 	int InitPath(float3 start, float3 end, int pathType);
-	float3 GetNextWaypoint(int pathid);
-	void FreePath(int pathid);
+	float3 GetNextWaypoint(int pathId);
+	void FreePath(int pathId);
 
 	float GetPathLength(float3 start, float3 end, int pathType);
 
-	int GetEnemyUnits(int* units);
-	int GetEnemyUnitsInRadarAndLos(int* units);
-	int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
-	int GetFriendlyUnits(int* units);
-	int GetFriendlyUnits(int* units, const float3&amp; pos, float radius);
-	int GetNeutralUnits(int* units);
-	int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
+	int GetEnemyUnits(int* unitIds);
+	int GetEnemyUnitsInRadarAndLos(int* unitIds);
+	int GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius);
+	int GetFriendlyUnits(int* unitIds);
+	int GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius);
+	int GetNeutralUnits(int* unitIds);
+	int GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius);
 
 
 	int GetMapWidth();
@@ -110,18 +113,18 @@
 	void LineDrawerStartPath(const float3&amp; pos, const float* color);
 	void LineDrawerFinishPath();
 	void LineDrawerDrawLine(const float3&amp; endPos, const float* color);
-	void LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color);
-	void LineDrawerDrawIconAtLastPos(int cmdID);
+	void LineDrawerDrawLineAndIcon(int commandId, const float3&amp; endPos, const float* color);
+	void LineDrawerDrawIconAtLastPos(int commandId);
 	void LineDrawerBreak(const float3&amp; endPos, const float* color);
 	void LineDrawerRestart();
 	void LineDrawerRestartSameColor();
 
-	int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group);
-	int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group);
-	void SetFigureColor(int group,float red, float green, float blue, float alpha);
-	void DeleteFigureGroup(int group);
+	int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int figureGroupId);
+	int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int figureGroupId);
+	void SetFigureColor(int figureGroupId,float red, float green, float blue, float alpha);
+	void DeleteFigureGroup(int figureGroupId);
 
-	void DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing);
+	void DrawUnit(const char* unitName, float3 pos, float rotation, int lifetime, int teamId, bool transparent, bool drawBorder, int facing);
 
 	bool CanBuildAt(const UnitDef* unitDef, float3 pos, int facing);
 	float3 ClosestBuildSite(const UnitDef* unitdef, float3 pos, float searchRadius, int minDist, int facing);
@@ -136,26 +139,29 @@
 	float GetEnergyUsage();
 	float GetEnergyStorage();
 
-	int GetFeatures(int* features, int max);
-	int GetFeatures(int* features, int max, const float3&amp; pos, float radius);
-	const FeatureDef* GetFeatureDef (int feature);
-	float GetFeatureHealth(int feature);
-	float GetFeatureReclaimLeft(int feature);
-	float3 GetFeaturePos (int feature);
+	int GetFeatures(int* featureIds, int max);
+	int GetFeatures(int* featureIds, int max, const float3&amp; pos, float radius);
+	const FeatureDef* GetFeatureDef(int featureId);
+private:
+	const FeatureDef* GetFeatureDefById(int featureDefId);
+public:
+	float GetFeatureHealth(int featureId);
+	float GetFeatureReclaimLeft(int featureId);
+	float3 GetFeaturePos (int featureId);
 
-	bool GetProperty(int unit, int property, void* dst);
+	bool GetProperty(int unitId, int property, void* dst);
 	bool GetValue(int id, void* dst);
 	int HandleCommand(int commandId, void* data);
 
-	int GetFileSize(const char* name);
-	bool ReadFile(const char* name, void* buffer,int bufferLen);
-	int GetFileSize(const char* name, const char* modes);
-	bool ReadFile(const char* name, const char* modes, void* buffer, int bufferLen);
+	int GetFileSize(const char* filename);
+	bool ReadFile(const char* filename, void* buffer,int bufferLen);
+	int GetFileSize(const char* filename, const char* modes);
+	bool ReadFile(const char* filename, const char* modes, void* buffer, int bufferLen);
 
 	int GetNumUnitDefs();
 	void GetUnitDefList (const UnitDef** list);
 
-	int GetSelectedUnits(int* units);
+	int GetSelectedUnits(int* unitIds);
 	float3 GetMousePos();
 	int GetMapPoints(PointMarker* pm, int maxPoints);
 	int GetMapLines(LineMarker* lm, int maxLines);
@@ -163,7 +169,10 @@
 	float GetUnitDefRadius(int def);
 	float GetUnitDefHeight(int def);
 
-	const WeaponDef* GetWeapon(const char* weaponname);
+	const WeaponDef* GetWeapon(const char* weaponName);
+private:
+	const WeaponDef* GetWeaponDefById(int weaponDefId);
+public:
 
 	// false if a unit cannot currently be created
 	bool CanBuildUnit(int unitDefID);

Modified: trunk/rts/ExternalAI/IAICallback.h
===================================================================
--- trunk/rts/ExternalAI/IAICallback.h	2008-07-18 01:10:44 UTC (rev 6196)
+++ trunk/rts/ExternalAI/IAICallback.h	2008-07-18 13:44:52 UTC (rev 6197)
@@ -67,6 +67,9 @@
 #define AIHCAddMapLineId 2
 #define AIHCRemoveMapPointId 3
 #define AIHCSendStartPosId 4
+#define AIHCGetUnitDefByIdId 5
+#define AIHCGetWeaponDefByIdId 6
+#define AIHCGetFeatureDefByIdId 7
 
 struct AIHCAddMapPoint ///&lt; result of HandleCommand is 1 - ok supported
 {
@@ -91,7 +94,25 @@
 	float3 pos;
 };
 
+struct AIHCGetUnitDefById ///&lt; result of HandleCommand is 1 - ok supported
+{
+	int unitDefId;
+	const UnitDef* ret;
+};
 
+struct AIHCGetWeaponDefById ///&lt; result of HandleCommand is 1 - ok supported
+{
+	int weaponDefId;
+	const WeaponDef* ret;
+};
+
+struct AIHCGetFeatureDefById ///&lt; result of HandleCommand is 1 - ok supported
+{
+	int featureDefId;
+	const FeatureDef* ret;
+};
+
+
 class SPRING_API IAICallback
 {
 public:
@@ -111,7 +132,7 @@
 	// * AI's should check each unit if it is still under control of their
 	//   team after the transaction via UnitTaken() and UnitGiven(), since
 	//   LuaRules might block part of it
-	virtual int SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam) = 0;
+	virtual int SendUnits(const std::vector&lt;int&gt;&amp; unitIds, int receivingTeamId) = 0;
 
 	// checks if pos is within view of the current camera, using radius as a margin
 	virtual bool PosInCamera(float3 pos, float radius) = 0;
@@ -123,8 +144,8 @@
 
 	virtual int GetMyTeam() = 0;
 	virtual int GetMyAllyTeam() = 0;
-	virtual int GetPlayerTeam(int player) = 0;
-	virtual const char* GetTeamSide(int team) = 0;
+	virtual int GetPlayerTeam(int playerId) = 0;
+	virtual const char* GetTeamSide(int teamId) = 0;
 
 	// returns the size of the created area, this is initialized to all 0 if not previously created
 	// set something to !0 to tell other AI's that the area is already initialized when they try to
@@ -133,44 +154,44 @@
 	// release your reference to a memory area
 	virtual void ReleasedSharedMemArea(char* name) = 0;
 
-	virtual int CreateGroup(char* dll, unsigned aiNumber) = 0;							// creates a group and return the id it was given, return -1 on
+	virtual int CreateGroup(char* libraryName, unsigned aiNumber) = 0;							// creates a group and return the id it was given, return -1 on
 																						// failure (dll didn't exist, etc)
-	virtual void EraseGroup(int groupid) = 0;											// erases a specified group
-	virtual bool AddUnitToGroup(int unitid, int groupid) = 0;							// adds a unit to a specific group, if it was previously in a group
+	virtual void EraseGroup(int groupId) = 0;											// erases a specified group
+	virtual bool AddUnitToGroup(int unitId, int groupId) = 0;							// adds a unit to a specific group, if it was previously in a group
 																						// it is removed from that, return false if the group didn't exist
 																						// or didn't accept the unit
-	virtual bool RemoveUnitFromGroup(int unitid) = 0;									// removes a unit from its group
-	virtual int GetUnitGroup(int unitid) = 0;											// returns the group a unit belongs to, -1 if none
-	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid) = 0;	// the commands that this unit can understand, other commands will be ignored
-	virtual int GiveGroupOrder(int unitid, Command* c) = 0;
+	virtual bool RemoveUnitFromGroup(int unitId) = 0;									// removes a unit from its group
+	virtual int GetUnitGroup(int unitId) = 0;											// returns the group a unit belongs to, -1 if none
+	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int groupId) = 0;	// the commands that this group can understand, other commands will be ignored
+	virtual int GiveGroupOrder(int unitId, Command* c) = 0;
 
-	virtual int GiveOrder(int unitid, Command* c) = 0;
+	virtual int GiveOrder(int unitId, Command* c) = 0;
 
-	virtual const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid) = 0;
-	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid) = 0;
+	virtual const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitId) = 0;         // the commands that this unit can understand, other commands will be ignored
+	virtual const CCommandQueue* GetCurrentUnitCommands(int unitId) = 0;
 
 	// these functions always work on allied units, but for
 	// enemies only when you have LOS on them (so watch out
 	// when calling GetUnitDef)
-	virtual int GetUnitAiHint(int unitid) = 0;				// integer telling something about the units main function, not implemented yet
-	virtual int GetUnitTeam(int unitid) = 0;
-	virtual int GetUnitAllyTeam(int unitid) = 0;
-	virtual float GetUnitHealth(int unitid) = 0;			// the unit's current health
-	virtual float GetUnitMaxHealth(int unitid) = 0;			// the unit's max health
-	virtual float GetUnitSpeed(int unitid) = 0;				// the unit's max speed
-	virtual float GetUnitPower(int unitid) = 0;				// sort of the measure of the units overall power
-	virtual float GetUnitExperience(int unitid) = 0;		// how experienced the unit is (0.0f-1.0f)
-	virtual float GetUnitMaxRange(int unitid) = 0;			// the furthest any weapon of the unit can fire
-	virtual bool IsUnitActivated (int unitid) = 0;
-	virtual bool UnitBeingBuilt(int unitid) = 0;			// true if the unit is currently being built
-	virtual const UnitDef* GetUnitDef(int unitid) = 0;		// returns the unit's unitdef struct from which you can read all the
+	virtual int GetUnitAiHint(int unitId) = 0;				// integer telling something about the units main function, not implemented yet
+	virtual int GetUnitTeam(int unitId) = 0;
+	virtual int GetUnitAllyTeam(int unitId) = 0;
+	virtual float GetUnitHealth(int unitId) = 0;			// the unit's current health
+	virtual float GetUnitMaxHealth(int unitId) = 0;			// the unit's max health
+	virtual float GetUnitSpeed(int unitId) = 0;				// the unit's max speed
+	virtual float GetUnitPower(int unitId) = 0;				// sort of the measure of the units overall power
+	virtual float GetUnitExperience(int unitId) = 0;		// how experienced the unit is (0.0f-1.0f)
+	virtual float GetUnitMaxRange(int unitId) = 0;			// the furthest any weapon of the unit can fire
+	virtual bool IsUnitActivated (int unitId) = 0;
+	virtual bool UnitBeingBuilt(int unitId) = 0;			// true if the unit is currently being built
+	virtual const UnitDef* GetUnitDef(int unitId) = 0;		// returns the unit's unitdef struct from which you can read all the
 															// statistics of the unit, do NOT try to change any values in it
-	virtual float3 GetUnitPos(int unitid) = 0;
-	virtual int GetBuildingFacing(int unitid) = 0;			// returns the unit's build facing (0-3)
-	virtual bool IsUnitCloaked(int unitid) = 0;
-	virtual bool IsUnitParalyzed(int unitid) = 0;
-	virtual bool IsUnitNeutral(int unitid) = 0;
-	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo) = 0;
+	virtual float3 GetUnitPos(int unitId) = 0;
+	virtual int GetBuildingFacing(int unitId) = 0;			// returns the unit's build facing (0-3)
+	virtual bool IsUnitCloaked(int unitId) = 0;
+	virtual bool IsUnitParalyzed(int unitId) = 0;
+	virtual bool IsUnitNeutral(int unitId) = 0;
+	virtual bool GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) = 0;
 
 	virtual const UnitDef* GetUnitDef(const char* unitName) = 0;
 
@@ -181,8 +202,8 @@
 	// * the waypoint's x and z coordinates are returned in x and z while y is used for error codes
 	//   y &gt;= 0: worked ok, y = -2: still thinking call again, y = -1: end of path reached or invalid path
 	virtual int InitPath(float3 start, float3 end, int pathType) = 0;
-	virtual float3 GetNextWaypoint(int pathid) = 0;
-	virtual void FreePath(int pathid) = 0;
+	virtual float3 GetNextWaypoint(int pathId) = 0;
+	virtual void FreePath(int pathId) = 0;
 
 	// returns the approximate path cost between two points(note that
 	// it needs to calculate the complete path so somewhat expensive)
@@ -194,13 +215,13 @@
 	// * the return value indicates how many units were returned, the rest of the array is unchanged
 	// * all forms of GetEnemyUnits and GetFriendlyUnits filter out any neutrals, use the GetNeutral
 	//   callbacks to retrieve them
-	virtual int GetEnemyUnits(int* units) = 0;										// returns all known (in LOS) enemy units
-	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius) = 0;		// returns all known enemy units within radius from pos
-	virtual int GetEnemyUnitsInRadarAndLos(int* units) = 0;							// returns all enemy units in radar and los
-	virtual int GetFriendlyUnits(int* units) = 0;									// returns all friendly units
-	virtual int GetFriendlyUnits(int* units, const float3&amp; pos, float radius) = 0;	// returns all friendly units within radius from pos
-	virtual int GetNeutralUnits(int* units) = 0;									// returns all known (in LOS) neutral units
-	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius) = 0;	// returns all known neutral units within radius from pos
+	virtual int GetEnemyUnits(int* unitIds) = 0;										// returns all known (in LOS) enemy units
+	virtual int GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) = 0;		// returns all known enemy units within radius from pos
+	virtual int GetEnemyUnitsInRadarAndLos(int* unitIds) = 0;							// returns all enemy units in radar and los
+	virtual int GetFriendlyUnits(int* unitIds) = 0;									// returns all friendly units
+	virtual int GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) = 0;	// returns all friendly units within radius from pos
+	virtual int GetNeutralUnits(int* unitIds) = 0;									// returns all known (in LOS) neutral units
+	virtual int GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) = 0;	// returns all known neutral units within radius from pos
 
 	// the following functions are used to get information about the map
 	// * do NOT modify or delete any of the pointers returned
@@ -236,29 +257,29 @@
 	virtual void LineDrawerStartPath(const float3&amp; pos, const float* color) = 0;
 	virtual void LineDrawerFinishPath() = 0;
 	virtual void LineDrawerDrawLine(const float3&amp; endPos, const float* color) = 0;
-	virtual void LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color) = 0;
-	virtual void LineDrawerDrawIconAtLastPos(int cmdID) = 0;
+	virtual void LineDrawerDrawLineAndIcon(int commandId, const float3&amp; endPos, const float* color) = 0;
+	virtual void LineDrawerDrawIconAtLastPos(int commandId) = 0;
 	virtual void LineDrawerBreak(const float3&amp; endPos, const float* color) = 0;
 	virtual void LineDrawerRestart() = 0;
 	virtual void LineDrawerRestartSameColor() = 0;
 
 	// the following functions allow the AI to draw figures in the world
-	// * each figure is part of a group
-	// * when creating figures use 0 as group to get a new one, the return value is the new group
-	// * the lifetime is how many frames a figure should live before being autoremoved, 0 means no removal
+	// * each figure is part of a figureGroup
+	// * when creating figures use 0 as figureGroupId to get a new figureGroup, the return value is the new figureGroup
+	// * the lifeTime is how many frames a figure should live before being autoremoved, 0 means no removal
 	// * arrow != 0 means that the figure will get an arrow at the end
 	//
 	// creates a cubic Bezier spline figure (from pos1 to pos4 with control points pos2 and pos3)
-	virtual int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group) = 0;
-	virtual int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group) = 0;
-	virtual void SetFigureColor(int group, float red, float green, float blue, float alpha) = 0;
-	virtual void DeleteFigureGroup(int group) = 0;
+	virtual int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifeTime, int figureGroupId) = 0;
+	virtual int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifeTime, int figureGroupId) = 0;
+	virtual void SetFigureColor(int figureGroupId, float red, float green, float blue, float alpha) = 0;
+	virtual void DeleteFigureGroup(int figureGroupId) = 0;
 
 	// this function allows you to draw units in the map
 	// * they only show up on the local player's screen
 	// * they will be drawn in the &quot;standard pose&quot; (as if before any COB scripts are run)
 	// * the rotation is in radians, team affects the color of the unit
-	virtual void DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing = 0) = 0;
+	virtual void DrawUnit(const char* unitName, float3 pos, float rotation, int lifeTime, int teamId, bool transparent, bool drawBorder, int facing = 0) = 0;
 
 	virtual bool CanBuildAt(const UnitDef* unitDef, float3 pos, int facing = 0) = 0;
 	// returns the closest position from a given position that the building can be built at
@@ -271,11 +292,11 @@
 	virtual bool GetValue(int id, void* dst) = 0;
 	virtual int HandleCommand(int commandId, void* data) = 0;
 
-	virtual int GetFileSize(const char* name) = 0;								// return -1 when the file doesn't exist
-	virtual bool ReadFile(const char* name, void* buffer, int bufferLen) = 0;	// returns false when file doesn't exist or buffer is too small
+	virtual int GetFileSize(const char* filename) = 0;								// return -1 when the file doesn't exist
+	virtual bool ReadFile(const char* filename, void* buffer, int bufferLen) = 0;	// returns false when file doesn't exist or buffer is too small
 
 	// added by alik
-	virtual int GetSelectedUnits(int* units) = 0;
+	virtual int GetSelectedUnits(int* unitIds) = 0;
 	virtual float3 GetMousePos() = 0;
 	virtual int GetMapPoints(PointMarker* pm, int maxPoints) = 0;
 	virtual int GetMapLines(LineMarker* lm, int maxLines) = 0;
@@ -290,19 +311,19 @@
 	virtual float GetEnergyUsage() = 0;				// current energy usage for team
 	virtual float GetEnergyStorage() = 0;			// curent energy storage capacity for team
 
-	virtual int GetFeatures(int *features, int max) = 0;
-	virtual int GetFeatures(int *features, int max, const float3&amp; pos, float radius) = 0;
-	virtual const FeatureDef* GetFeatureDef(int feature) = 0;
-	virtual float GetFeatureHealth(int feature) = 0;
-	virtual float GetFeatureReclaimLeft(int feature) = 0;
-	virtual float3 GetFeaturePos(int feature) = 0;
+	virtual int GetFeatures(int *featureIds, int max) = 0;
+	virtual int GetFeatures(int *featureIds, int max, const float3&amp; pos, float radius) = 0;
+	virtual const FeatureDef* GetFeatureDef(int featureId) = 0;
+	virtual float GetFeatureHealth(int featureId) = 0;
+	virtual float GetFeatureReclaimLeft(int featureId) = 0;
+	virtual float3 GetFeaturePos(int featureId) = 0;
 
 	virtual int GetNumUnitDefs() = 0;
 	virtual void GetUnitDefList(const UnitDef** list) = 0;
-	virtual float GetUnitDefHeight(int def) = 0;	// forces loading of the unit model
-	virtual float GetUnitDefRadius(int def) = 0;	// forces loading of the unit model
+	virtual float GetUnitDefHeight(int unitDefId) = 0;	// forces loading of the unit model
+	virtual float GetUnitDefRadius(int unitDefId) = 0;	// forces loading of the unit model
 
-	virtual const WeaponDef* GetWeapon(const char* weaponname) = 0;
+	virtual const WeaponDef* GetWeapon(const char* weaponName) = 0;
 
 	virtual const float3* GetStartPos() = 0;
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000976.html">[Taspring-linux-commit] r6196 - in trunk/Lobby/TASClient: .	Graphics LobbyComponents Python Python/engine Python/scripts	Python/scripts/subf
</A></li>
	<LI>Next message: <A HREF="000978.html">[Taspring-linux-commit] r6198 - trunk/rts/Sim/Weapons
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#977">[ date ]</a>
              <a href="thread.html#977">[ thread ]</a>
              <a href="subject.html#977">[ subject ]</a>
              <a href="author.html#977">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
