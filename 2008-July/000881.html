<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6101 - in trunk/rts: Sim/Misc	Sim/MoveTypes Sim/MoveTypes/MoveMath Sim/Objects Sim/Path	Sim/Units build/vstudio8
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6101%20-%20in%20trunk/rts%3A%20Sim/Misc%0A%09Sim/MoveTypes%20Sim/MoveTypes/MoveMath%20Sim/Objects%20Sim/Path%0A%09Sim/Units%20build/vstudio8&In-Reply-To=%3C20080703031207.8634F48A6%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000880.html">
   <LINK REL="Next"  HREF="000882.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6101 - in trunk/rts: Sim/Misc	Sim/MoveTypes Sim/MoveTypes/MoveMath Sim/Objects Sim/Path	Sim/Units build/vstudio8</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6101%20-%20in%20trunk/rts%3A%20Sim/Misc%0A%09Sim/MoveTypes%20Sim/MoveTypes/MoveMath%20Sim/Objects%20Sim/Path%0A%09Sim/Units%20build/vstudio8&In-Reply-To=%3C20080703031207.8634F48A6%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6101 - in trunk/rts: Sim/Misc	Sim/MoveTypes Sim/MoveTypes/MoveMath Sim/Objects Sim/Path	Sim/Units build/vstudio8">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Jul  3 05:12:07 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000880.html">[Taspring-linux-commit] r6100 - in trunk: . rts/build/scons	rts/build/vstudio8 rts/lib
</A></li>
        <LI>Next message: <A HREF="000882.html">[Taspring-linux-commit] r6102 - in trunk: . Documentation	rts/ExternalAI rts/Game rts/Game/UI rts/Lua rts/Map	rts/System rts/lib/gml tools/DedicatedServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#881">[ date ]</a>
              <a href="thread.html#881">[ thread ]</a>
              <a href="subject.html#881">[ subject ]</a>
              <a href="author.html#881">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-07-03 05:12:06 +0200 (Thu, 03 Jul 2008)
New Revision: 6101

Removed:
   trunk/rts/Sim/MoveTypes/Mobility.cpp
   trunk/rts/Sim/MoveTypes/Mobility.h
Modified:
   trunk/rts/Sim/Misc/CollisionHandler.cpp
   trunk/rts/Sim/Misc/CollisionHandler.h
   trunk/rts/Sim/Misc/CollisionVolume.h
   trunk/rts/Sim/MoveTypes/AirMoveType.cpp
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
   trunk/rts/Sim/MoveTypes/MoveInfo.cpp
   trunk/rts/Sim/MoveTypes/MoveInfo.h
   trunk/rts/Sim/MoveTypes/MoveMath/MoveMath.cpp
   trunk/rts/Sim/MoveTypes/MoveMath/MoveMath.h
   trunk/rts/Sim/MoveTypes/MoveType.cpp
   trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
   trunk/rts/Sim/Objects/SolidObject.h
   trunk/rts/Sim/Path/PathEstimator.cpp
   trunk/rts/Sim/Path/PathFinder.cpp
   trunk/rts/Sim/Path/PathManager.cpp
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/Sim/Units/UnitHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/build/vstudio8/rts.vcproj
Log:
* remove CMobility (it was a mostly-dead wrapper around MoveData, which now holds its members)
* general whitespace / formatting touchups


Modified: trunk/rts/Sim/Misc/CollisionHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/CollisionHandler.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Misc/CollisionHandler.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -170,6 +170,17 @@
 
 
 
+bool CCollisionHandler::MouseHit(const CUnit* u, const float3&amp; p0, const float3&amp; p1, const CollisionVolume* v, CollisionQuery* q)
+{
+	// TODO: use in CGameHelper::GuiTraceRay()
+	CMatrix44f m;
+	u-&gt;GetTransformMatrix(m, true);
+	m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
+	m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
+
+	return CCollisionHandler::Intersect(v, m, p0, p1, q);
+}
+
 bool CCollisionHandler::Intersect(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
 {
 	const CollisionVolume* v = u-&gt;collisionVolume;
@@ -245,6 +256,12 @@
 		} break;
 	}
 
+	if (q) {
+		// transform the intersection points
+		q-&gt;p0 = m.Mul(q-&gt;p0);
+		q-&gt;p1 = m.Mul(q-&gt;p1);
+	}
+
 	return intersect;
 }
 
@@ -309,8 +326,8 @@
 		} else {
 			// two solutions for t
 			const float rD = fastmath::sqrt(D);
-			const float t0 = (-B + rD) * 0.5f;
-			const float t1 = (-B - rD) * 0.5f;
+			const float t0 = (-B - rD) * 0.5f;
+			const float t1 = (-B + rD) * 0.5f;
 			// const float t0 = (-B + rD) / (2.0f * A);
 			// const float t1 = (-B - rD) / (2.0f * A);
 			// get the intersection points in sphere-space
@@ -345,8 +362,8 @@
 	const float3 dir = (pi1 - pi0).Normalize();
 
 	// end-cap plane normals
-	float3 n0;
-	float3 n1;
+	float3 n0 = ZVec;
+	float3 n1 = ZVec;
 
 	// pi0 transformed to unit-cylinder space
 	float3 pii0;
@@ -368,8 +385,8 @@
 			pass = (pi0.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; v-&gt;axisHScales.x);
 			pii0 = float3(pi0.x, pi0.y * v-&gt;axisHIScales.y, pi0.z * v-&gt;axisHIScales.z);
 
-			n0 = float3( 1.0f, 0.0f, 0.0f);
-			n1 = float3(-1.0f, 0.0f, 0.0f);
+			n0.x =  1.0f;
+			n1.x = -1.0f;
 
 			// get the parameters for the (2D)
 			// yz-plane ellipse surface equation
@@ -382,8 +399,8 @@
 			pass = (pi0.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; v-&gt;axisHScales.y);
 			pii0 = float3(pi0.x * v-&gt;axisHIScales.x, pi0.y, pi0.z * v-&gt;axisHIScales.z);
 
-			n0 = float3(0.0f,  1.0f, 0.0f);
-			n1 = float3(0.0f, -1.0f, 0.0f);
+			n0.y =  1.0f;
+			n1.y = -1.0f;
 
 			// get the parameters for the (2D)
 			// xz-plane ellipse surface equation
@@ -396,8 +413,8 @@
 			pass = (pi0.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; v-&gt;axisHScales.z);
 			pii0 = float3(pi0.x * v-&gt;axisHIScales.x, pi0.y * v-&gt;axisHIScales.y, pi0.z);
 
-			n0 = float3(0.0f, 0.0f,  1.0f);
-			n1 = float3(0.0f, 0.0f, -1.0f);
+			n0.z =  1.0f;
+			n1.z = -1.0f;
 
 			// get the parameters for the (2D)
 			// xy-plane ellipse surface equation
@@ -418,10 +435,10 @@
 		return true;
 	}
 
-	const int pAx = v-&gt;primaryAxis;
+	const int pAx  = v-&gt;primaryAxis;
 	const int sAx0 = v-&gt;secondaryAxes[0];
 	const int sAx1 = v-&gt;secondaryAxes[1];
-	const float D = (B * B) - (4.0f * A * C);
+	const float D  = (B * B) - (4.0f * A * C);
 
 	if (D &lt; -EPS) {
 		return false;
@@ -434,7 +451,7 @@
 
 		if (D &lt; EPS) {
 			// one solution for t
-			t0 = -D / (2.0f * A); p0 = pi0 + (dir * t0);
+			t0 = -B / (2.0f * A); p0 = pi0 + (dir * t0);
 
 			if (p0[pAx] &gt; -v-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; v-&gt;axisHScales[pAx]) {
 				// intersection point &lt;p0&gt; falls between cylinder
@@ -455,8 +472,8 @@
 		} else {
 			// two solutions for t
 			const float rD = fastmath::sqrt(D);
-			t0 = (-B + rD) / (2.0f * A); p0 = pi0 + (dir * t0);
-			t1 = (-B - rD) / (2.0f * A); p1 = pi0 + (dir * t1);
+			t0 = (-B - rD) / (2.0f * A); p0 = pi0 + (dir * t0);
+			t1 = (-B + rD) / (2.0f * A); p1 = pi0 + (dir * t1);
 
 			// test the 1st intersection point
 			// along the cylinder's major axis

Modified: trunk/rts/Sim/Misc/CollisionHandler.h
===================================================================
--- trunk/rts/Sim/Misc/CollisionHandler.h	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Misc/CollisionHandler.h	2008-07-03 03:12:06 UTC (rev 6101)
@@ -17,9 +17,9 @@
 		b1 = false; t1 = 0.0f; p1 = ZeroVector;
 	}
 
-	bool b0, b1;
-	float t0, t1;
-	float3 p0, p1;
+	bool b0, b1;	// true if ingress (b0) or egress (b1) point on ray segment
+	float t0, t1;	// distance parameter for ingress and egress point
+	float3 p0, p1;	// ray-volume ingress and egress points
 };
 
 // responsible for detecting hits between projectiles
@@ -34,6 +34,7 @@
 
 		static bool DetectHit(const CUnit*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0);
 		static bool DetectHit(const CFeature*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0);
+		static bool MouseHit(const CUnit*, const float3&amp; p0, const float3&amp; p1, const CollisionVolume*, CollisionQuery* q);
 
 	private:
 		static bool Collision(const CUnit*, const float3&amp;);

Modified: trunk/rts/Sim/Misc/CollisionVolume.h
===================================================================
--- trunk/rts/Sim/Misc/CollisionVolume.h	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Misc/CollisionVolume.h	2008-07-03 03:12:06 UTC (rev 6101)
@@ -15,21 +15,27 @@
 struct CollisionVolume {
 	CR_DECLARE_STRUCT(CollisionVolume);
 
-	CollisionVolume() {}
+	CollisionVolume():
+		volumeBoundingRadius(1.0f), volumeType(COLVOL_TYPE_ELLIPSOID),
+		testType(COLVOL_TEST_DISC), primaryAxis(COLVOL_AXIS_Z) {
+		secondaryAxes[0] = COLVOL_AXIS_X;
+		secondaryAxes[1] = COLVOL_AXIS_Y;
+		spherical = true;
+	}
 	CollisionVolume(const CollisionVolume* src) {
-		axisScales = src-&gt;axisScales;
-		axisHScales = src-&gt;axisHScales;
-		axisHScalesSq = src-&gt;axisHScalesSq;
-		axisHIScales = src-&gt;axisHIScales;
-		axisOffsets = src-&gt;axisOffsets;
-		volumeBoundingRadius = src-&gt;volumeBoundingRadius;
+		axisScales             = src-&gt;axisScales;
+		axisHScales            = src-&gt;axisHScales;
+		axisHScalesSq          = src-&gt;axisHScalesSq;
+		axisHIScales           = src-&gt;axisHIScales;
+		axisOffsets            = src-&gt;axisOffsets;
+		volumeBoundingRadius   = src-&gt;volumeBoundingRadius;
 		volumeBoundingRadiusSq = src-&gt;volumeBoundingRadiusSq;
-		volumeType = src-&gt;volumeType;
-		testType = src-&gt;testType;
-		primaryAxis = src-&gt;primaryAxis;
-		secondaryAxes[0] = src-&gt;secondaryAxes[0];
-		secondaryAxes[1] = src-&gt;secondaryAxes[1];
-		spherical = src-&gt;spherical;
+		volumeType             = src-&gt;volumeType;
+		testType               = src-&gt;testType;
+		primaryAxis            = src-&gt;primaryAxis;
+		secondaryAxes[0]       = src-&gt;secondaryAxes[0];
+		secondaryAxes[1]       = src-&gt;secondaryAxes[1];
+		spherical              = src-&gt;spherical;
 	}
 
 	CollisionVolume(const std::string&amp; volTypeStr, const float3&amp; volScales, const float3&amp; volOffsets, int tstType) {

Modified: trunk/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -5,7 +5,6 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapInfo.h&quot;
-#include &quot;Mobility.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
@@ -383,7 +382,7 @@
 			owner-&gt;pos.y = ground-&gt;GetApproximateHeight(owner-&gt;pos.x, owner-&gt;pos.z) + wantedHeight * 5  + 100;
 
 		int newmapSquare = ground-&gt;GetSquare(owner-&gt;pos);
-		if(newmapSquare != owner-&gt;mapSquare){
+		if (newmapSquare != owner-&gt;mapSquare) {
 			owner-&gt;mapSquare = newmapSquare;
 			float oldlh = owner-&gt;losHeight;
 			float h = owner-&gt;pos.y - ground-&gt;GetApproximateHeight(owner-&gt;pos.x, owner-&gt;pos.z);
@@ -394,8 +393,9 @@
 
 			owner-&gt;losHeight = oldlh;
 		}
+
 		qf-&gt;MovedUnit(owner);
-		owner-&gt;isUnderWater = owner-&gt;pos.y + owner-&gt;model-&gt;height &lt; 0;
+		owner-&gt;isUnderWater = (owner-&gt;pos.y + owner-&gt;model-&gt;height &lt; 0.0f);
 	}
 }
 

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -22,7 +22,6 @@
 #include &quot;Game/Player.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
-#include &quot;Mobility.h&quot;
 #include &quot;MoveMath/MoveMath.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
@@ -182,18 +181,19 @@
 
 CGroundMoveType::~CGroundMoveType()
 {
-	if(pathId)
+	if (pathId) {
 		pathManager-&gt;DeletePath(pathId);
-
-	if(owner-&gt;myTrack)
+	}
+	if (owner-&gt;myTrack) {
 		groundDecals-&gt;RemoveUnit(owner);
+	}
 }
 
 void CGroundMoveType::PostLoad()
 {
-	//HACK:Initializing path after load
+	//HACK: re-initialize path after load
 	if (pathId) {
-		pathId = pathManager-&gt;RequestPath(owner-&gt;mobility-&gt;moveData, owner-&gt;pos, goalPos, goalRadius,owner);
+		pathId = pathManager-&gt;RequestPath(owner-&gt;mobility, owner-&gt;pos, goalPos, goalRadius, owner);
 	}
 }
 
@@ -225,10 +225,7 @@
 	if (owner-&gt;stunned) {
 		owner-&gt;cob-&gt;Call(COBFN_StopMoving);
 		owner-&gt;speed = ZeroVector;
-	}
-
-
-	if (!owner-&gt;stunned) {
+	} else {
 #ifdef DIRECT_CONTROL_ALLOWED
 		if (owner-&gt;directControl) {
 			waypoint = owner-&gt;pos+owner-&gt;frontdir * 100;
@@ -323,10 +320,10 @@
 			float3 tempSpeed = flatFrontDir * currentSpeed;
 			owner-&gt;pos += tempSpeed;
 
-			float wh;
+			float wh = 0.0f;
 			if (floatOnWater) {
 				wh = ground-&gt;GetHeight(owner-&gt;pos.x, owner-&gt;pos.z);
-				if (wh == 0)
+				if (wh == 0.0f)
 					wh =- owner-&gt;unitDef-&gt;waterline;
 			} else {
 				wh = ground-&gt;GetHeight2(owner-&gt;pos.x, owner-&gt;pos.z);
@@ -344,20 +341,21 @@
 		// these checks must be executed even when we are stunned
 		TestNewTerrainSquare();
 		CheckCollision();
-		float wh;
 
+		float wh = 0.0f;
 		if (floatOnWater) {
 			wh = ground-&gt;GetHeight(owner-&gt;pos.x, owner-&gt;pos.z);
-			if (wh == 0)
-				wh=-owner-&gt;unitDef-&gt;waterline;
+			if (wh == 0.0f)
+				wh = -owner-&gt;unitDef-&gt;waterline;
 		} else {
 			wh = ground-&gt;GetHeight2(owner-&gt;pos.x, owner-&gt;pos.z);
 		}
 
-		if (!(owner-&gt;falling || flying))
+		if (!(owner-&gt;falling || flying)) {
 			owner-&gt;pos.y = wh;
+		}
 
-		owner-&gt;speed = owner-&gt;pos-oldPos;
+		owner-&gt;speed = owner-&gt;pos - oldPos;
 		owner-&gt;UpdateMidPos();
 		oldPos = owner-&gt;pos;
 
@@ -381,7 +379,7 @@
 
 	// if we've strayed too far away from path, then need to reconsider
 	if (progressState == Active &amp;&amp; etaFailures &gt; 8) {
-		if (owner-&gt;pos.distance2D(goalPos)&gt;200 || CheckGoalFeasability()) {
+		if (owner-&gt;pos.distance2D(goalPos) &gt; 200 || CheckGoalFeasability()) {
 			if (DEBUG_CONTROLLER)
 				logOutput.Print(&quot;Unit eta failure %i&quot;, owner-&gt;id);
 			StopEngine();
@@ -396,18 +394,19 @@
 	// If the action is active, but not the engine and the
 	// re-try-delay has passed, then start the engine.
 	if (progressState == Active &amp;&amp; !pathId &amp;&amp; gs-&gt;frameNum &gt; restartDelay) {
-		if (DEBUG_CONTROLLER)
+		if (DEBUG_CONTROLLER) {
 			logOutput.Print(&quot;Unit restart %i&quot;, owner-&gt;id);
+		}
 		StartEngine();
 	}
 
 	if (!flying) {
-		// just kindly move it into the map again instead of deleteing
+		// just kindly move it into the map again instead of deleting
 		owner-&gt;pos.CheckInBounds();
 	}
 
 	if (!(owner-&gt;falling || flying)) {
-		float wh;
+		float wh = 0.0f;
 
 		// need the following if the ground changes
 		// height while the unit is standing still
@@ -429,7 +428,7 @@
 		if (newmapSquare != owner-&gt;mapSquare) {
 			owner-&gt;mapSquare = newmapSquare;
 
-			loshandler-&gt;MoveUnit(owner,false);
+			loshandler-&gt;MoveUnit(owner, false);
 			if (owner-&gt;hasRadarCapacity)
 				radarhandler-&gt;MoveUnit(owner);
 
@@ -437,7 +436,12 @@
 			// owner-&gt;Block();
 		}
 		qf-&gt;MovedUnit(owner);
-		owner-&gt;isUnderWater = owner-&gt;pos.y + owner-&gt;height &lt; 1;
+
+		// NOTE: submarines aren't always deep enough to be fully
+		// submerged (yet should always have the isUnderWater flag
+		// set)
+		const float s = (owner-&gt;mobility-&gt;moveType == MoveData::Ship_Move)? 0.5f: 1.0f;
+		owner-&gt;isUnderWater = ((owner-&gt;pos.y + owner-&gt;height * s) &lt; 0.0f);
 	}
 }
 
@@ -460,7 +464,7 @@
 	tracefile &lt;&lt; owner-&gt;pos.x &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;pos.y &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;pos.z &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
 #endif
 
-	if(progressState == Active) {
+	if (progressState == Active) {
 		StopEngine();
 	}
 
@@ -475,8 +479,9 @@
 	progressState = Active;
 
 	//Starts the engine.
-	if (DEBUG_CONTROLLER)
+	if (DEBUG_CONTROLLER) {
 		logOutput &lt;&lt; owner-&gt;id &lt;&lt; &quot;: StartMoving() starting engine.\n&quot;;
+	}
 	StartEngine();
 
 	ENTER_UNSYNCED;
@@ -909,77 +914,84 @@
 
 void CGroundMoveType::CalcSkidRot(void)
 {
-	owner-&gt;heading+=(short int)skidRotSpeed;
+	owner-&gt;heading += (short int) skidRotSpeed;
 
 	owner-&gt;frontdir = GetVectorFromHeading(owner-&gt;heading);
-	if(owner-&gt;upright){
-		owner-&gt;updir=UpVector;
-		owner-&gt;rightdir=owner-&gt;frontdir.cross(owner-&gt;updir);
+
+	if (owner-&gt;upright) {
+		owner-&gt;updir = UpVector;
+		owner-&gt;rightdir = owner-&gt;frontdir.cross(owner-&gt;updir);
 	} else {
-		owner-&gt;updir=ground-&gt;GetSmoothNormal(owner-&gt;pos.x, owner-&gt;pos.z);
-		owner-&gt;rightdir=owner-&gt;frontdir.cross(owner-&gt;updir);
+		owner-&gt;updir = ground-&gt;GetSmoothNormal(owner-&gt;pos.x, owner-&gt;pos.z);
+		owner-&gt;rightdir = owner-&gt;frontdir.cross(owner-&gt;updir);
 		owner-&gt;rightdir.Normalize();
-		owner-&gt;frontdir=owner-&gt;updir.cross(owner-&gt;rightdir);
+		owner-&gt;frontdir = owner-&gt;updir.cross(owner-&gt;rightdir);
 	}
 
-	skidRotPos2+=skidRotSpeed2;
+	skidRotPos2 += skidRotSpeed2;
 
-	float cosp=cos(skidRotPos2*PI*2);
-	float sinp=sin(skidRotPos2*PI*2);
+	float cosp = cos(skidRotPos2 * PI * 2.0f);
+	float sinp = sin(skidRotPos2 * PI * 2.0f);
 
-	float3 f1=skidRotVector*skidRotVector.dot(owner-&gt;frontdir);
-	float3 f2=owner-&gt;frontdir-f1;
-	f2=f2*cosp+f2.cross(skidRotVector)*sinp;
-	owner-&gt;frontdir=f1+f2;
+	float3 f1 = skidRotVector * skidRotVector.dot(owner-&gt;frontdir);
+	float3 f2 = owner-&gt;frontdir - f1;
+	f2 = f2 * cosp + f2.cross(skidRotVector) * sinp;
+	owner-&gt;frontdir = f1 + f2;
 
-	float3 r1=skidRotVector*skidRotVector.dot(owner-&gt;rightdir);
-	float3 r2=owner-&gt;rightdir-r1;
-	r2=r2*cosp+r2.cross(skidRotVector)*sinp;
-	owner-&gt;rightdir=r1+r2;
+	float3 r1 = skidRotVector * skidRotVector.dot(owner-&gt;rightdir);
+	float3 r2 = owner-&gt;rightdir - r1;
+	r2 = r2 * cosp + r2.cross(skidRotVector) * sinp;
+	owner-&gt;rightdir = r1 + r2;
 
-	float3 u1=skidRotVector*skidRotVector.dot(owner-&gt;updir);
-	float3 u2=owner-&gt;updir-u1;
-	u2=u2*cosp+u2.cross(skidRotVector)*sinp;
-	owner-&gt;updir=u1+u2;
+	float3 u1 = skidRotVector * skidRotVector.dot(owner-&gt;updir);
+	float3 u2 = owner-&gt;updir - u1;
+	u2 = u2 * cosp + u2.cross(skidRotVector) * sinp;
+	owner-&gt;updir = u1 + u2;
 }
 
-const float AVOIDANCE_DISTANCE = 1.0f;				//How far away a unit should start avoiding an obstacle. Multiplied with distance to waypoint.
-const float AVOIDANCE_STRENGTH = 2.0f;				//How strongly an object should be avoided. Raise this value to give some more marginal.
-const float FORCE_FIELD_DISTANCE = 50;				//How faar away a unit may be affected by the force-field. Multiplied with speed of the unit.
-const float FORCE_FIELD_STRENGTH = 0.4f;				//Maximum strenght of the force-field.
 
+const float AVOIDANCE_DISTANCE = 1.0f;				// How far away a unit should start avoiding an obstacle. Multiplied with distance to waypoint.
+const float AVOIDANCE_STRENGTH = 2.0f;				// How strongly an object should be avoided. Raise this value to give some more marginal.
+const float FORCE_FIELD_DISTANCE = 50;				// How faar away a unit may be affected by the force-field. Multiplied with speed of the unit.
+const float FORCE_FIELD_STRENGTH = 0.4f;			// Maximum strenght of the force-field.
 
 
+
 /*
-Dynamic obstacle avoidance.
-Helps the unit to follow the path even when it's not perfect.
-*/
+ * Dynamic obstacle avoidance, helps the unit to
+ * follow the path even when it's not perfect.
+ */
 float3 CGroundMoveType::ObstacleAvoidance(float3 desiredDir) {
-	//NOTE: Based on the requirement that all objects has symetrical footprints.
-	//		If this is false, then radius has to be calculated in a different way!
+	// NOTE: based on the requirement that all objects has symetrical footprints.
+	// If this is false, then radius has to be calculated in a different way!
 
 	// Obstacle-avoidance-system only needs to be run if the unit wants to move
 	if (pathId) {
 		float3 avoidanceDir = desiredDir;
-		//Speed-optimizer. Reduces the times this system is runned.
-		if(gs-&gt;frameNum&gt;=nextObstacleAvoidanceUpdate) {
+		// Speed-optimizer. Reduces the times this system is ran.
+		if (gs-&gt;frameNum &gt;= nextObstacleAvoidanceUpdate) {
 			nextObstacleAvoidanceUpdate = gs-&gt;frameNum + 4;
 
 			// first check if the current waypoint is reachable
 			int wsx = (int) waypoint.x / (SQUARE_SIZE * 2);
 			int wsy = (int) waypoint.z / (SQUARE_SIZE * 2);
-			int ltx = wsx-moveSquareX + 5;
-			int lty = wsy-moveSquareY + 5;
+			int ltx = wsx - moveSquareX + 5;
+			int lty = wsy - moveSquareY + 5;
 
 			if (ltx &gt;= 0 &amp;&amp; ltx &lt; 11 &amp;&amp; lty &gt;= 0 &amp;&amp; lty &lt; 11) {
 				for (std::vector&lt;int2&gt;::iterator li = lineTable[lty][ltx].begin(); li != lineTable[lty][ltx].end(); ++li) {
 					int x = (moveSquareX + li-&gt;x) * 2;
 					int y = (moveSquareY + li-&gt;y) * 2;
-					if ((owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;IsBlocked(*owner-&gt;unitDef-&gt;movedata, x, y) &amp; (CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN | CMoveMath::BLOCK_MOBILE_BUSY)) || owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, x,y)&lt;=0.01f){
-						++etaFailures;		// not reachable, force a new path to be calculated next slowupdate
+					int mask = CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN | CMoveMath::BLOCK_MOBILE_BUSY;
 
-						if (DEBUG_CONTROLLER)
-							logOutput.Print(&quot;Waypoint path blocked %i&quot;, owner-&gt;id);
+					if ((owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;IsBlocked(*owner-&gt;unitDef-&gt;movedata, x, y) &amp; mask) ||
+							owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, x, y) &lt;= 0.01f) {
+						// not reachable, force a new path to be calculated next slowupdate
+						++etaFailures;
+
+						if (DEBUG_CONTROLLER) {
+							logOutput.Print(&quot;Waypoint path blocked for unit %i&quot;, owner-&gt;id);
+						}
 						break;
 					}
 				}
@@ -987,24 +999,24 @@
 
 			// now we do the obstacle avoidance proper
 			float currentDistanceToGoal = owner-&gt;pos.distance2D(goalPos);
-			float3 rightOfPath = desiredDir.cross(float3(0,1,0));
+			float3 rightOfPath = desiredDir.cross(float3(0.0f, 1.0f, 0.0f));
 			float3 rightOfAvoid = rightOfPath;
-			float speedf=owner-&gt;speed.Length2D();
+			float speedf = owner-&gt;speed.Length2D();
 
-			float avoidLeft = 0;
-			float avoidRight = 0;
+			float avoidLeft = 0.0f;
+			float avoidRight = 0.0f;
 
 
-
-			vector&lt;CSolidObject*&gt; nearbyObjects = qf-&gt;GetSolidsExact(owner-&gt;pos, speedf*35 + 30 + owner-&gt;xsize/2);
+			vector&lt;CSolidObject*&gt; nearbyObjects = qf-&gt;GetSolidsExact(owner-&gt;pos, speedf * 35 + 30 + owner-&gt;xsize / 2);
 			vector&lt;CSolidObject*&gt; objectsOnPath;
 			vector&lt;CSolidObject*&gt;::iterator oi;
 
 			for (oi = nearbyObjects.begin(); oi != nearbyObjects.end(); oi++) {
 				CSolidObject* object = *oi;
-				// Basic blocking-check.
-				MoveData* moveData = owner-&gt;mobility-&gt;moveData;
+				MoveData* moveData = owner-&gt;mobility;
+				CMoveMath* moveMath = moveData-&gt;moveMath;
 
+				// basic blocking-check
 				if (object != owner &amp;&amp; moveData-&gt;moveMath-&gt;IsBlocking(*moveData, object) &amp;&amp; desiredDir.dot(object-&gt;pos - owner-&gt;pos) &gt; 0) {
 					float3 objectToUnit = (owner-&gt;pos - object-&gt;pos - object-&gt;speed * 30);
 					float distanceToObject = objectToUnit.Length();
@@ -1023,16 +1035,16 @@
 							if (DEBUG_CONTROLLER &amp;&amp; selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end())
 								geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, object-&gt;pos + UpVector * 20, 3, 1, 4);
 
-							if (objectDistToAvoidDirCenter &gt; 0) {
+							if (objectDistToAvoidDirCenter &gt; 0.0f) {
 								avoidRight += (radiusSum - objectDistToAvoidDirCenter) * AVOIDANCE_STRENGTH / distanceToObject;
 								avoidanceDir += (rightOfAvoid * avoidRight);
 								avoidanceDir.Normalize();
-								rightOfAvoid = avoidanceDir.cross(float3(0, 1, 0));
+								rightOfAvoid = avoidanceDir.cross(float3(0.0f, 1.0f, 0.0f));
 							} else {
 								avoidLeft += (radiusSum - fabs(objectDistToAvoidDirCenter)) * AVOIDANCE_STRENGTH / distanceToObject;
 								avoidanceDir -= (rightOfAvoid * avoidLeft);
 								avoidanceDir.Normalize();
-								rightOfAvoid = avoidanceDir.cross(float3(0, 1, 0));
+								rightOfAvoid = avoidanceDir.cross(float3(0.0f, 1.0f, 0.0f));
 							}
 							objectsOnPath.push_back(object);
 						}
@@ -1044,12 +1056,12 @@
 
 
 			// Sum up avoidance.
-			avoidanceVec = (desiredDir.cross(float3(0, 1, 0)) * (avoidRight - avoidLeft));
+			avoidanceVec = (desiredDir.cross(float3(0.0f, 1.0f, 0.0f)) * (avoidRight - avoidLeft));
 			if (DEBUG_CONTROLLER &amp;&amp; selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end()) {
 				int a = geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + avoidanceVec * 40, 7, 1, 4);
 				geometricObjects-&gt;SetColor(a, 1, 0.3f, 0.3f, 0.6f);
 
-				a=geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + desiredDir * 40, 7, 1, 4);
+				a = geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + desiredDir * 40, 7, 1, 4);
 				geometricObjects-&gt;SetColor(a, 0.3f, 0.3f, 1, 0.6f);
 			}
 		}
@@ -1067,38 +1079,40 @@
 
 
 
-/*
-Calculates an aproximation of the physical 2D-distance
-between given two objects.
-*/
-float CGroundMoveType::Distance2D(CSolidObject *object1, CSolidObject *object2, float marginal)
+// Calculates an aproximation of the physical 2D-distance between given two objects.
+float CGroundMoveType::Distance2D(CSolidObject* object1, CSolidObject* object2, float marginal)
 {
-	//Calculating the distance in (x,z) depening in the look of the footprint.
+	// calculate the distance in (x,z) depending
+	// on the shape of the object footprints
 	float dist2D;
-	if(object1-&gt;xsize == object1-&gt;ysize || object2-&gt;xsize == object2-&gt;ysize) {
-		//Using xsize as a cynlindrical radius.
+	if (object1-&gt;xsize == object1-&gt;ysize || object2-&gt;xsize == object2-&gt;ysize) {
+		// use xsize as a cylindrical radius.
 		float3 distVec = (object1-&gt;midPos - object2-&gt;midPos);
-		dist2D = distVec.Length2D() - (object1-&gt;xsize + object2-&gt;xsize)*SQUARE_SIZE/2 + 2*marginal;
+		dist2D = distVec.Length2D() - (object1-&gt;xsize + object2-&gt;xsize) * SQUARE_SIZE / 2 + 2 * marginal;
 	} else {
-		//Pytagorean sum of the x and z distance.
+		// Pytagorean sum of the x and z distance.
 		float3 distVec;
-		distVec.x = fabs(object1-&gt;midPos.x - object2-&gt;midPos.x) - (object1-&gt;xsize + object2-&gt;xsize)*SQUARE_SIZE/2 + 2*marginal;
-		distVec.z = fabs(object1-&gt;midPos.z - object2-&gt;midPos.z) - (object1-&gt;ysize + object2-&gt;ysize)*SQUARE_SIZE/2 + 2*marginal;
-		if(distVec.x &gt; 0.0f &amp;&amp; distVec.z &gt; 0.0f)
+		float xdiff = streflop::fabs(object1-&gt;midPos.x - object2-&gt;midPos.x);
+		float zdiff = streflop::fabs(object1-&gt;midPos.z - object2-&gt;midPos.z);
+
+		distVec.x = xdiff - (object1-&gt;xsize + object2-&gt;xsize) * SQUARE_SIZE / 2 + 2 * marginal;
+		distVec.z = zdiff - (object1-&gt;ysize + object2-&gt;ysize) * SQUARE_SIZE / 2 + 2 * marginal;
+
+		if (distVec.x &gt; 0.0f &amp;&amp; distVec.z &gt; 0.0f) {
 			dist2D = distVec.Length2D();
-		else if(distVec.x &lt; 0.0f &amp;&amp; distVec.z &lt; 0.0f)
+		} else if (distVec.x &lt; 0.0f &amp;&amp; distVec.z &lt; 0.0f) {
 			dist2D = -distVec.Length2D();
-		else if(distVec.x &gt; 0.0f)
+		} else if (distVec.x &gt; 0.0f) {
 			dist2D = distVec.x;
-		else
+		} else {
 			dist2D = distVec.z;
+		}
 	}
+
 	return dist2D;
 }
 
-/*
-Creates a path to the goal.
-*/
+// Creates a path to the goal.
 void CGroundMoveType::GetNewPath()
 {
 	if(owner-&gt;pos.distance2D(lastGetPathPos)&lt;20){
@@ -1117,11 +1131,9 @@
 	}
 
 	pathManager-&gt;DeletePath(pathId);
-
-	pathId = pathManager-&gt;RequestPath(owner-&gt;mobility-&gt;moveData, owner-&gt;pos, goalPos, goalRadius,owner);
-
-	nextWaypoint=owner-&gt;pos;
-	//With new path recived, can't be at waypoint.
+	pathId = pathManager-&gt;RequestPath(owner-&gt;mobility, owner-&gt;pos, goalPos, goalRadius, owner);
+	nextWaypoint = owner-&gt;pos;
+	// new path received, can't be at waypoint.
 	if(pathId){
 		atGoal = false;
 		haveFinalWaypoint=false;
@@ -1224,27 +1236,30 @@
 Initializes motion.
 */
 void CGroundMoveType::StartEngine() {
-	//Will be runned only if engine is no path
-	//and the unit is not already at the goal.
-	if(!pathId &amp;&amp; !atGoal) {
+	// ran only if the unit has no path and is not already at goal
+	if (!pathId &amp;&amp; !atGoal) {
 		GetNewPath();
-		//Engine will be activated only if a path could be found.
-		if(pathId) {
-			pathFailures=0;
-			etaFailures=0;
-			owner-&gt;isMoving=true;
+
+		// activate &quot;engine&quot; only if a path was found
+		if (pathId) {
+			pathFailures = 0;
+			etaFailures = 0;
+			owner-&gt;isMoving = true;
 			owner-&gt;cob-&gt;Call(COBFN_StartMoving);
 
-			if(DEBUG_CONTROLLER)
+			if (DEBUG_CONTROLLER) {
 				logOutput &lt;&lt; &quot;Engine started&quot; &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
+			}
 		} else {
-			if(DEBUG_CONTROLLER)
+			if (DEBUG_CONTROLLER) {
 				logOutput &lt;&lt; &quot;Engine start failed: &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
+			}
 
 			Fail();
 		}
 	}
-	nextObstacleAvoidanceUpdate=gs-&gt;frameNum;
+
+	nextObstacleAvoidanceUpdate = gs-&gt;frameNum;
 	//SetDeltaSpeed();
 }
 
@@ -1252,23 +1267,25 @@
 Stops motion.
 */
 void CGroundMoveType::StopEngine() {
-	//Will be runned only if engine is active.
-	if(pathId) {
-		//Deactivating engine.
+	// ran only if engine is active
+	if (pathId) {
+		// Deactivating engine.
 		pathManager-&gt;DeletePath(pathId);
 		pathId = 0;
-		if(!atGoal)
+		if (!atGoal) {
 			waypoint = Here();
+		}
 
-		//Stop animation.
+		// Stop animation.
 		owner-&gt;cob-&gt;Call(COBFN_StopMoving);
 
-		if(DEBUG_CONTROLLER)
+		if (DEBUG_CONTROLLER) {
 			logOutput &lt;&lt; &quot;Engine stopped.&quot; &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
+		}
 	}
-	owner-&gt;isMoving=false;
-	wantedSpeed=0;
-	//SetDeltaSpeed();
+	owner-&gt;isMoving = false;
+	wantedSpeed = 0;
+	// SetDeltaSpeed();
 }
 
 
@@ -1419,9 +1436,9 @@
 				float colDepth = fabs(owner-&gt;pos.x - xmove);
 				dif *= dl != 0 ? colDepth / dl : 0;
 
-				// adjust our own position a
-				// bit so we have to turn less
-				// FIXME CAN PLACE US IN BUILDING
+				// adjust our own position a bit so
+				// we have to turn less (FIXME: can
+				// place us in building)
 				owner-&gt;pos -= dif * (1 - part);
 				// safe cast (only units can be mobile)
 				CUnit* u = (CUnit*) c;
@@ -1443,7 +1460,7 @@
 				}
 			}
 
-			MoveData* m = owner-&gt;mobility-&gt;moveData;
+			MoveData* m = owner-&gt;mobility;
 
 			// if other party can be overrun then overrun it
 			if (!m-&gt;moveMath-&gt;IsBlocking(*m, c)) {
@@ -1485,9 +1502,9 @@
 				float colDepth = fabs(owner-&gt;pos.z - zmove);
 				dif *= dl != 0 ? colDepth / dl : 0;
 
-				// adjust our own position a
-				// bit so we have to turn less
-				// FIXME CAN PLACE US IN BUILDING
+				// adjust our own position a bit so
+				// we have to turn less (FIXME: can
+				// place us in building)
 				owner-&gt;pos -= dif * (1 - part);
 				// safe cast (only units can be mobile)
 				CUnit* u = (CUnit*) c;
@@ -1509,7 +1526,7 @@
 				}
 			}
 
-			MoveData* m = owner-&gt;mobility-&gt;moveData;
+			MoveData* m = owner-&gt;mobility;
 
 			// if other party can be overrun then overrun it
 			if (!m-&gt;moveMath-&gt;IsBlocking(*m, c)) {
@@ -1605,98 +1622,111 @@
 
 void CGroundMoveType::TestNewTerrainSquare(void)
 {
-	int newMoveSquareX=(int)owner-&gt;pos.x / (SQUARE_SIZE*2);		//first make sure we dont go into any terrain we cant get out of
-	int newMoveSquareY=(int)owner-&gt;pos.z / (SQUARE_SIZE*2);
+	// first make sure we dont go into any terrain we cant get out of
+	int newMoveSquareX = (int) owner-&gt;pos.x / (SQUARE_SIZE * 2);
+	int newMoveSquareY = (int) owner-&gt;pos.z / (SQUARE_SIZE * 2);
 
-	if(newMoveSquareX!=moveSquareX || newMoveSquareY!=moveSquareY){
-		float cmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, moveSquareX*2,moveSquareY*2);
-		if(fabs(owner-&gt;frontdir.x)&lt;fabs(owner-&gt;frontdir.z)){
-			if(newMoveSquareX&gt;moveSquareX){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.x=moveSquareX*SQUARE_SIZE*2+(SQUARE_SIZE*2-0.01f);
-					newMoveSquareX=moveSquareX;
+	if (newMoveSquareX != moveSquareX || newMoveSquareY != moveSquareY) {
+		float cmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, moveSquareX * 2, moveSquareY * 2);
+
+		if (fabs(owner-&gt;frontdir.x) &lt; fabs(owner-&gt;frontdir.z)) {
+			if (newMoveSquareX &gt; moveSquareX) {
+				float nmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
+				if (cmod &gt; 0.01f &amp;&amp; nmod &lt;= 0.01f) {
+					owner-&gt;pos.x = moveSquareX * SQUARE_SIZE * 2 + (SQUARE_SIZE * 2 - 0.01f);
+					newMoveSquareX = moveSquareX;
 				}
-			} else if(newMoveSquareX&lt;moveSquareX){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.x=moveSquareX*SQUARE_SIZE*2+0.01f;
-					newMoveSquareX=moveSquareX;
+			} else if (newMoveSquareX &lt; moveSquareX) {
+				float nmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
+				if (cmod &gt; 0.01f &amp;&amp; nmod &lt;= 0.01f) {
+					owner-&gt;pos.x = moveSquareX * SQUARE_SIZE * 2 + 0.01f;
+					newMoveSquareX = moveSquareX;
 				}
 			}
-			if(newMoveSquareY&gt;moveSquareY){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.z=moveSquareY*SQUARE_SIZE*2+(SQUARE_SIZE*2-0.01f);
-					newMoveSquareY=moveSquareY;
+			if (newMoveSquareY &gt; moveSquareY) {
+				float nmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
+				if (cmod &gt; 0.01f &amp;&amp; nmod &lt;= 0.01f) {
+					owner-&gt;pos.z = moveSquareY * SQUARE_SIZE * 2 + (SQUARE_SIZE * 2 - 0.01f);
+					newMoveSquareY = moveSquareY;
 				}
-			} else if(newMoveSquareY&lt;moveSquareY){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.z=moveSquareY*SQUARE_SIZE*2+0.01f;
-					newMoveSquareY=moveSquareY;
+			} else if (newMoveSquareY &lt; moveSquareY) {
+				float nmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
+				if (cmod &gt; 0.01f &amp;&amp; nmod &lt;= 0.01f) {
+					owner-&gt;pos.z = moveSquareY * SQUARE_SIZE * 2 + 0.01f;
+					newMoveSquareY = moveSquareY;
 				}
 			}
 		} else {
-			if(newMoveSquareY&gt;moveSquareY){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.z=moveSquareY*SQUARE_SIZE*2+(SQUARE_SIZE*2-0.01f);
-					newMoveSquareY=moveSquareY;
+			if (newMoveSquareY &gt; moveSquareY) {
+				float nmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
+				if (cmod&gt;0.01f &amp;&amp; nmod &lt;= 0.01f) {
+					owner-&gt;pos.z = moveSquareY * SQUARE_SIZE * 2 + (SQUARE_SIZE * 2 - 0.01f);
+					newMoveSquareY = moveSquareY;
 				}
-			} else if(newMoveSquareY&lt;moveSquareY){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.z=moveSquareY*SQUARE_SIZE*2+0.01f;
-					newMoveSquareY=moveSquareY;
+			} else if (newMoveSquareY &lt; moveSquareY) {
+				float nmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
+				if (cmod &gt; 0.01f &amp;&amp; nmod &lt;= 0.01f) {
+					owner-&gt;pos.z = moveSquareY * SQUARE_SIZE * 2 + 0.01f;
+					newMoveSquareY = moveSquareY;
 				}
 			}
-			if(newMoveSquareX&gt;moveSquareX){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.x=moveSquareX*SQUARE_SIZE*2+(SQUARE_SIZE*2-0.01f);
-					newMoveSquareX=moveSquareX;
+
+			if (newMoveSquareX &gt; moveSquareX) {
+				float nmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
+				if (cmod &gt; 0.01f &amp;&amp; nmod &lt;= 0.01f) {
+					owner-&gt;pos.x = moveSquareX * SQUARE_SIZE * 2 + (SQUARE_SIZE * 2 - 0.01f);
+					newMoveSquareX = moveSquareX;
 				}
-			} else if(newMoveSquareX&lt;moveSquareX){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.x=moveSquareX*SQUARE_SIZE*2+0.01f;
-					newMoveSquareX=moveSquareX;
+			} else if (newMoveSquareX &lt; moveSquareX) {
+				float nmod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
+				if (cmod &gt; 0.01f &amp;&amp; nmod &lt;= 0.01f) {
+					owner-&gt;pos.x = moveSquareX * SQUARE_SIZE * 2 + 0.01f;
+					newMoveSquareX = moveSquareX;
 				}
 			}
 		}
-		if(newMoveSquareX!=moveSquareX || newMoveSquareY!=moveSquareY){
-			moveSquareX=newMoveSquareX;
-			moveSquareY=newMoveSquareY;
-			terrainSpeed=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, (moveSquareX)*2,(moveSquareY)*2);
-			etaWaypoint = int(30.0f / (requestedSpeed*terrainSpeed+0.001f)) + gs-&gt;frameNum+50;
-			etaWaypoint2 = int(25.0f / (requestedSpeed*terrainSpeed+0.001f)) + gs-&gt;frameNum+10;
 
-			int nwsx=(int)nextWaypoint.x / (SQUARE_SIZE*2);		//if we have moved check if we can get a new waypoint
-			int nwsy=(int)nextWaypoint.z / (SQUARE_SIZE*2);
+		if (newMoveSquareX != moveSquareX || newMoveSquareY != moveSquareY) {
+			moveSquareX = newMoveSquareX;
+			moveSquareY = newMoveSquareY;
+			terrainSpeed = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, moveSquareX * 2, moveSquareY * 2);
+			etaWaypoint = int(30.0f / (requestedSpeed * terrainSpeed + 0.001f)) + gs-&gt;frameNum + 50;
+			etaWaypoint2 = int(25.0f / (requestedSpeed * terrainSpeed + 0.001f)) + gs-&gt;frameNum + 10;
 
-			int numIter=0;
-			//lowered the original 6 absolute distance to slightly more than 4.5f euclidian distance
-			//to fix units getting stuck in buildings --tvo
-			//My first fix set it to 21, as the pathfinding was still considered broken by many I reduced it to 11 (arbitrarily)
-			//Does anyone know whether lowering this constant has any adverse side effects? Like e.g. more CPU usage? --tvo
-			while((nwsx-moveSquareX)*(nwsx-moveSquareX)+(nwsy-moveSquareY)*(nwsy-moveSquareY) &lt; 11 &amp;&amp; !haveFinalWaypoint &amp;&amp; pathId){
-				int ltx=nwsx-moveSquareX+5;
-				int lty=nwsy-moveSquareY+5;
-				bool wpOk=true;
-				for(std::vector&lt;int2&gt;::iterator li=lineTable[lty][ltx].begin();li!=lineTable[lty][ltx].end();++li){
-					int x=(moveSquareX+li-&gt;x)*2;
-					int y=(moveSquareY+li-&gt;y)*2;
-					if((owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;IsBlocked(*owner-&gt;unitDef-&gt;movedata, x, y) &amp; (CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN | CMoveMath::BLOCK_MOBILE | CMoveMath::BLOCK_MOBILE_BUSY)) || owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, x,y)&lt;=0.01f){
-						wpOk=false;
+			// if we have moved check if we can get a new waypoint
+			int nwsx = (int) nextWaypoint.x / (SQUARE_SIZE * 2);
+			int nwsy = (int) nextWaypoint.z / (SQUARE_SIZE * 2);
+			int numIter = 0;
+
+			// lowered the original 6 absolute distance to slightly more than 4.5f euclidian distance
+			// to fix units getting stuck in buildings --tvo
+			// My first fix set it to 21, as the pathfinding was still considered broken by many I reduced it to 11 (arbitrarily)
+			// Does anyone know whether lowering this constant has any adverse side effects? Like e.g. more CPU usage? --tvo
+			while ((nwsx - moveSquareX) * (nwsx - moveSquareX) + (nwsy - moveSquareY) * (nwsy - moveSquareY) &lt; 11 &amp;&amp; !haveFinalWaypoint &amp;&amp; pathId) {
+				int ltx = nwsx - moveSquareX + 5;
+				int lty = nwsy - moveSquareY + 5;
+				bool wpOk = true;
+
+				for (std::vector&lt;int2&gt;::iterator li = lineTable[lty][ltx].begin(); li != lineTable[lty][ltx].end(); ++li) {
+					int x = (moveSquareX + li-&gt;x) * 2;
+					int y = (moveSquareY + li-&gt;y) * 2;
+					int blockMask =
+						(CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN |
+						CMoveMath::BLOCK_MOBILE | CMoveMath::BLOCK_MOBILE_BUSY);
+					CMoveMath* mmath = owner-&gt;unitDef-&gt;movedata-&gt;moveMath;
+
+					if ((mmath-&gt;IsBlocked(*owner-&gt;unitDef-&gt;movedata, x, y) &amp; blockMask) ||
+						mmath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, x, y) &lt;= 0.01f) {
+						wpOk = false;
 						break;
 					}
 				}
-				if(!wpOk || numIter&gt;6)
+				if (!wpOk || numIter &gt; 6) {
 					break;
+				}
 				GetNextWaypoint();
-				nwsx=(int)nextWaypoint.x / (SQUARE_SIZE*2);
-				nwsy=(int)nextWaypoint.z / (SQUARE_SIZE*2);
+				nwsx = (int) nextWaypoint.x / (SQUARE_SIZE * 2);
+				nwsy = (int) nextWaypoint.z / (SQUARE_SIZE * 2);
 				++numIter;
 			}
 		}
@@ -1705,49 +1735,54 @@
 
 bool CGroundMoveType::CheckGoalFeasability(void)
 {
-	float goalDist=goalPos.distance2D(owner-&gt;pos);
+	float goalDist = goalPos.distance2D(owner-&gt;pos);
 
-	int minx = (int) std::max(0.f,(goalPos.x-goalDist)/(SQUARE_SIZE*2));
-	int minz = (int) std::max(0.f,(goalPos.z-goalDist)/(SQUARE_SIZE*2));
+	int minx = (int) std::max(0.0f, (goalPos.x - goalDist) / (SQUARE_SIZE * 2));
+	int minz = (int) std::max(0.0f, (goalPos.z - goalDist) / (SQUARE_SIZE * 2));
+	int maxx = (int) std::min(float(gs-&gt;hmapx - 1), (goalPos.x + goalDist) / (SQUARE_SIZE * 2));
+	int maxz = (int) std::min(float(gs-&gt;hmapy - 1), (goalPos.z + goalDist) / (SQUARE_SIZE * 2));
 
-	int maxx = (int) std::min(float(gs-&gt;hmapx-1),(goalPos.x+goalDist)/(SQUARE_SIZE*2));
-	int maxz = (int) std::min(float(gs-&gt;hmapy-1),(goalPos.z+goalDist)/(SQUARE_SIZE*2));
+	MoveData* md = owner-&gt;unitDef-&gt;movedata;
+	CMoveMath* mm = md-&gt;moveMath;
 
-	MoveData* md=owner-&gt;unitDef-&gt;movedata;
-	CMoveMath* mm=md-&gt;moveMath;
+	float numBlocked = 0.0f;
+	float numSquares = 0.0f;
 
-	float numBlocked=0;
-	float numSquares=0;
+	for (int z = minz; z &lt;= maxz; ++z) {
+		for (int x = minx; x &lt;= maxx; ++x) {
+			float3 pos(x * SQUARE_SIZE * 2, 0, z * SQUARE_SIZE * 2);
+			if ((pos - goalPos).SqLength2D() &lt; goalDist * goalDist) {
+				int blockingType = mm-&gt;SquareIsBlocked(*md, x * 2, z * 2);
 
-	for(int z=minz;z&lt;=maxz;++z){
-		for(int x=minx;x&lt;=maxx;++x){
-			float3 pos(x*SQUARE_SIZE*2,0,z*SQUARE_SIZE*2);
-			if((pos-goalPos).SqLength2D()&lt;goalDist*goalDist){
-				int blockingType=mm-&gt;SquareIsBlocked(*md,x*2,z*2);
-				if((blockingType &amp; CMoveMath::BLOCK_STRUCTURE) || mm-&gt;SpeedMod(*md,x*2,z*2)&lt;0.01f){
-					numBlocked+=0.3f;
-					numSquares+=0.3f;
+				if ((blockingType &amp; CMoveMath::BLOCK_STRUCTURE) || mm-&gt;SpeedMod(*md, x * 2, z * 2) &lt; 0.01f) {
+					numBlocked += 0.3f;
+					numSquares += 0.3f;
 				} else {
-					numSquares+=1.0f;
-					if(blockingType)
-						numBlocked+=1.0f;
+					numSquares += 1.0f;
+					if (blockingType) {
+						numBlocked += 1.0f;
+					}
 				}
 			}
 		}
 	}
-	if(numSquares&gt;0){
-		float partBlocked=numBlocked/numSquares;
-		if(DEBUG_CONTROLLER)
-			logOutput.Print(&quot;Part blocked %i %.0f%% %.0f&quot;,owner-&gt;id,partBlocked*100,goalDist);
-		if(partBlocked&gt;0.4f)
+
+	if (numSquares &gt; 0.0f) {
+		float partBlocked = numBlocked / numSquares;
+		if (DEBUG_CONTROLLER) {
+			logOutput.Print(&quot;Percentage of blocked squares for unit %i: %.0f%% (goal distance: %.0f)&quot;,
+				owner-&gt;id, partBlocked * 100.0f, goalDist);
+		}
+		if (partBlocked &gt; 0.4f) {
 			return false;
+		}
 	}
 	return true;
 }
 
 void CGroundMoveType::LeaveTransport(void)
 {
-	oldPos=owner-&gt;pos+UpVector*0.001f;
+	oldPos = owner-&gt;pos + UpVector * 0.001f;
 }
 
 void CGroundMoveType::KeepPointingTo(float3 pos, float distance, bool aggressive){

Deleted: trunk/rts/Sim/MoveTypes/Mobility.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/Mobility.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/Mobility.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -1,33 +0,0 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;Mobility.h&quot;
-
-CR_BIND(CMobility, );
-
-CR_REG_METADATA(CMobility, (
-	CR_MEMBER(moveData),
-
-	CR_MEMBER(maxSpeed),
-	CR_MEMBER(maxTurnRate),
-
-	CR_MEMBER(maxAcceleration),
-	CR_MEMBER(maxBreaking),
-
-	CR_MEMBER(canFly),
-	CR_MEMBER(subMarine)));
-
-
-/*
-Constructor
-*/
-CMobility::CMobility() :
-moveData(0),
-maxSpeed(0),
-maxTurnRate(0),
-maxAcceleration(0),
-maxBreaking(0),
-canFly(false),
-subMarine(false) {
-}
-
-CMobility::~CMobility() {
-}

Deleted: trunk/rts/Sim/MoveTypes/Mobility.h
===================================================================
--- trunk/rts/Sim/MoveTypes/Mobility.h	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/Mobility.h	2008-07-03 03:12:06 UTC (rev 6101)
@@ -1,25 +0,0 @@
-#ifndef MOBILITY_H
-#define MOBILITY_H
-
-#include &quot;MoveInfo.h&quot;
-#include &quot;creg/creg.h&quot;
-
-class CMobility {
-	CR_DECLARE(CMobility);
-public:
-	CMobility();
-	virtual ~CMobility();
-
-	MoveData* moveData;
-
-	float maxSpeed;
-	short maxTurnRate;
-
-	float maxAcceleration;
-	float maxBreaking;
-
-	bool canFly;
-	bool subMarine;
-};
-
-#endif

Modified: trunk/rts/Sim/MoveTypes/MoveInfo.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/MoveInfo.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/MoveInfo.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -18,30 +18,37 @@
 CR_BIND(CMoveInfo, );
 
 CR_REG_METADATA(MoveData, (
-		CR_ENUM_MEMBER(moveType),
-		CR_MEMBER(size),
+	CR_ENUM_MEMBER(moveType),
+	CR_ENUM_MEMBER(moveFamily),
+	CR_MEMBER(size),
 
-		CR_MEMBER(depth),
-		CR_MEMBER(maxSlope),
-		CR_MEMBER(slopeMod),
-		CR_MEMBER(depthMod),
+	CR_MEMBER(depth),
+	CR_MEMBER(maxSlope),
+	CR_MEMBER(slopeMod),
+	CR_MEMBER(depthMod),
 
-		CR_MEMBER(pathType),
-		CR_MEMBER(moveMath),
-		CR_MEMBER(crushStrength),
-		CR_MEMBER(moveFamily),
+	CR_MEMBER(pathType),
+	CR_MEMBER(moveMath),
+	CR_MEMBER(crushStrength),
 
-		CR_MEMBER(name),
-		CR_RESERVED(16)
-		));
+	CR_MEMBER(maxSpeed),
+	CR_MEMBER(maxTurnRate),
+	CR_MEMBER(maxAcceleration),
+	CR_MEMBER(maxBreaking),
+	CR_MEMBER(canFly),
+	CR_MEMBER(subMarine),
 
+	CR_MEMBER(name),
+	CR_RESERVED(16)
+));
+
 CR_REG_METADATA(CMoveInfo, (
-		CR_MEMBER(moveData),
-		CR_MEMBER(name2moveData),
-		CR_MEMBER(moveInfoChecksum),
-		CR_MEMBER(terrainType2MoveFamilySpeed),
-		CR_RESERVED(16)
-		));
+	CR_MEMBER(moveData),
+	CR_MEMBER(name2moveData),
+	CR_MEMBER(moveInfoChecksum),
+	CR_MEMBER(terrainType2MoveFamilySpeed),
+	CR_RESERVED(16)
+));
 
 
 CMoveInfo* moveinfo;
@@ -67,7 +74,7 @@
 			break;
 		}
 
-		MoveData* md = SAFE_NEW MoveData;
+		MoveData* md = SAFE_NEW MoveData();
 		const string name = moveTable.GetString(&quot;name&quot;, &quot;&quot;);
 
 		md-&gt;name = name;
@@ -81,12 +88,12 @@
 		    (name.find(&quot;SHIP&quot;) != string::npos)) {
 			md-&gt;moveType = MoveData::Ship_Move;
 			md-&gt;depth = moveTable.GetFloat(&quot;minWaterDepth&quot;, 10.0f);
-			md-&gt;moveFamily = 3;
+			md-&gt;moveFamily = MoveData::Ship;
 		}
 		else if (name.find(&quot;HOVER&quot;) != string::npos) {
 			md-&gt;moveType = MoveData::Hover_Move;
 			md-&gt;maxSlope = DegreesToMaxSlope(moveTable.GetFloat(&quot;maxSlope&quot;, 15.0f));
-			md-&gt;moveFamily = 2;
+			md-&gt;moveFamily = MoveData::Hover;
 		}
 		else {
 			md-&gt;moveType = MoveData::Ground_Move;
@@ -94,9 +101,9 @@
 			md-&gt;depth = moveTable.GetFloat(&quot;maxWaterDepth&quot;, 0.0f);
 			md-&gt;maxSlope = DegreesToMaxSlope(moveTable.GetFloat(&quot;maxSlope&quot;, 60.0f));
 			if (name.find(&quot;TANK&quot;) != string::npos) {
-				md-&gt;moveFamily = 0;
+				md-&gt;moveFamily = MoveData::Tank;
 			} else {
-				md-&gt;moveFamily = 1;
+				md-&gt;moveFamily = MoveData::KBot;
 			}
 		}
 
@@ -135,8 +142,7 @@
 {
 	if (!exactMatch) {
 		return moveData[name2moveData[name]];
-	}
-	else {
+	} else {
 		map&lt;string, int&gt;::const_iterator it = name2moveData.find(name);
 		if (it == name2moveData.end()) {
 			return NULL;

Modified: trunk/rts/Sim/MoveTypes/MoveInfo.h
===================================================================
--- trunk/rts/Sim/MoveTypes/MoveInfo.h	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/MoveInfo.h	2008-07-03 03:12:06 UTC (rev 6101)
@@ -7,17 +7,48 @@
 
 class CMoveMath;
 
-struct MoveData{
+struct MoveData {
 	CR_DECLARE_STRUCT(MoveData);
+
+	MoveData(float _maxAcc = 0.0f, float _maxBreaking = 0.0f,
+			float _maxSpeed = 0.0f, short _maxTurnRate = 0,
+			bool _canFly = false, bool _subMarine = false,
+			const MoveData* udefMD = 0x0):
+		maxSpeed(_maxSpeed), maxTurnRate(_maxTurnRate), maxAcceleration(_maxAcc),
+		maxBreaking(_maxBreaking), canFly(_canFly), subMarine(_subMarine)
+	{
+		// udefMD is null when reading the MoveDefs
+		moveType      = udefMD? udefMD-&gt;moveType:      MoveData::Ground_Move;
+		size          = udefMD? udefMD-&gt;size:          0;
+		depth         = udefMD? udefMD-&gt;depth:         0.0f;
+		maxSlope      = udefMD? udefMD-&gt;maxSlope:      0.0f;
+		slopeMod      = udefMD? udefMD-&gt;slopeMod:      0.0f;
+		depthMod      = udefMD? udefMD-&gt;depthMod:      0.0f;
+		pathType      = udefMD? udefMD-&gt;pathType:      0;
+		moveMath      = udefMD? udefMD-&gt;moveMath:      0x0;
+		crushStrength = udefMD? udefMD-&gt;crushStrength: 0.0f;
+		moveFamily    = udefMD? udefMD-&gt;moveFamily:    MoveData::Tank;
+		name          = udefMD? udefMD-&gt;name:          &quot;&quot;;
+	}
+
+
 	enum MoveType {
 		Ground_Move,
 		Hover_Move,
 		Ship_Move
 	};
-	MoveType moveType;
-	int size;
+	enum MoveFamily {
+		Tank,
+		KBot,
+		Hover,
+		Ship
+	};
 
-	float depth;
+	MoveType moveType;			// NOTE: rename? (because of (AMoveType*) CUnit::moveType)
+	MoveFamily moveFamily;
+
+	int size;					// of the footprint
+	float depth;				// minWaterDepth for ships, maxWaterDepth otherwise
 	float maxSlope;
 	float slopeMod;
 	float depthMod;
@@ -25,11 +56,22 @@
 	int pathType;
 	CMoveMath* moveMath;
 	float crushStrength;
-	int moveFamily;				//0=tank,1=kbot,2=hover,3=ship
 
 	std::string name;
+
+
+	// CMobility refugees
+	float maxSpeed;
+	short maxTurnRate;
+
+	float maxAcceleration;
+	float maxBreaking;
+
+	bool canFly;
+	bool subMarine;				// always false
 };
 
+
 class CMoveInfo
 {
 	CR_DECLARE(CMoveInfo);
@@ -38,7 +80,7 @@
 	~CMoveInfo();
 
 	std::vector&lt;MoveData*&gt; moveData;
-	std::map&lt;std::string,int&gt; name2moveData;
+	std::map&lt;std::string, int&gt; name2moveData;
 	MoveData* GetMoveDataFromName(const std::string&amp; name, bool exactMatch = false);
 	unsigned int moveInfoChecksum;
 

Modified: trunk/rts/Sim/MoveTypes/MoveMath/MoveMath.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/MoveMath/MoveMath.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/MoveMath/MoveMath.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -10,201 +10,192 @@
 
 CR_BIND_INTERFACE(CMoveMath);
 
-/*
-Converts a point-request into a square-positional request.
-*/
+CMoveMath::~CMoveMath() {
+}
+
+/* Converts a point-request into a square-positional request. */
 float CMoveMath::SpeedMod(const MoveData&amp; moveData, float3 pos) {
-	int x = ((int)pos.x) / SQUARE_SIZE;
-	int z = ((int)pos.z) / SQUARE_SIZE;
+	int x = int(pos.x / SQUARE_SIZE);
+	int z = int(pos.z / SQUARE_SIZE);
 	return SpeedMod(moveData, x, z);
 }
 
 
-/*
-Extract height and slope data from given square and make
-a sub-functional call for calculations upon whose data.
-*/
+/* calculate the local speed-modifier for this movedata */
 float CMoveMath::SpeedMod(const MoveData&amp; moveData, int xSquare, int zSquare) {
-	//Error-check
-	if(xSquare &lt; 0 || zSquare &lt; 0
-	|| xSquare &gt;= gs-&gt;mapx || zSquare &gt;= gs-&gt;mapy)
+	// Error-check
+	if (xSquare &lt; 0 || zSquare &lt; 0 || xSquare &gt;= gs-&gt;mapx || zSquare &gt;= gs-&gt;mapy) {
 		return 0.0f;
+	}
 
-	//Extract data.
-	int square = xSquare/2 + zSquare/2 * gs-&gt;hmapx;
+	// Extract data.
+	int square = xSquare / 2 + zSquare / 2 * gs-&gt;hmapx;
 	float height = readmap-&gt;mipHeightmap[1][square];
 	float slope = readmap-&gt;slopemap[square];
-	float typemod=moveinfo-&gt;terrainType2MoveFamilySpeed[readmap-&gt;typemap[square]][moveData.moveFamily];
+	float typemod = moveinfo-&gt;terrainType2MoveFamilySpeed[readmap-&gt;typemap[square]][moveData.moveFamily];
 
-	//Call calculations.
-	return SpeedMod(moveData, height, slope)*typemod;
+	return (SpeedMod(moveData, height, slope) * typemod);
 }
 
-float CMoveMath::SpeedMod(const MoveData&amp; moveData, float3 pos,const float3&amp; moveDir) {
-	int x = (int)pos.x / SQUARE_SIZE;
-	int z = (int)pos.z / SQUARE_SIZE;
+float CMoveMath::SpeedMod(const MoveData&amp; moveData, float3 pos, const float3&amp; moveDir) {
+	int x = int(pos.x / SQUARE_SIZE);
+	int z = int(pos.z / SQUARE_SIZE);
 	return SpeedMod(moveData, x, z,moveDir);
 }
 
 
-/*
-Extract height and slope data from given square and make
-a sub-functional call for calculations upon whose data.
-*/
 float CMoveMath::SpeedMod(const MoveData&amp; moveData, int xSquare, int zSquare,const float3&amp; moveDir) {
-	//Error-check
-	if(xSquare &lt; 0 || zSquare &lt; 0
-	|| xSquare &gt;= gs-&gt;mapx || zSquare &gt;= gs-&gt;mapy)
+	// Error-check
+	if (xSquare &lt; 0 || zSquare &lt; 0 || xSquare &gt;= gs-&gt;mapx || zSquare &gt;= gs-&gt;mapy) {
 		return 0.0f;
+	}
 
-	//Extract data.
-	int square = xSquare/2 + zSquare/2 * gs-&gt;hmapx;
+	// Extract data.
+	int square = xSquare / 2 + zSquare / 2 * gs-&gt;hmapx;
 	float height = readmap-&gt;mipHeightmap[1][square];
 	float slope = readmap-&gt;slopemap[square];
 
-	float3 flatNorm=readmap-&gt;facenormals[(xSquare + zSquare * gs-&gt;mapx)*2];
-	flatNorm.y=0;
+	float3 flatNorm = readmap-&gt;facenormals[(xSquare + zSquare * gs-&gt;mapx) * 2];
+	flatNorm.y = 0;
 	flatNorm.Normalize();
-	float moveSlope=-moveDir.dot(flatNorm);
-	float typemod=moveinfo-&gt;terrainType2MoveFamilySpeed[readmap-&gt;typemap[square]][moveData.moveFamily];
+	float moveSlope = -moveDir.dot(flatNorm);
+	float typemod = moveinfo-&gt;terrainType2MoveFamilySpeed[readmap-&gt;typemap[square]][moveData.moveFamily];
 
-	//Call calculations.
-	return SpeedMod(moveData, height, slope,moveSlope)*typemod;
+	return (SpeedMod(moveData, height, slope, moveSlope) * typemod);
 }
 
-/*
-Converts a point-request into a square-positional request.
-*/
-int CMoveMath::IsBlocked(const MoveData&amp; moveData, float3 pos) {
-	int x = (int)(pos.x / SQUARE_SIZE);
-	int z = (int)(pos.z / SQUARE_SIZE);
-	return IsBlocked(moveData, x, z);
+
+/* Converts a point-request into a square-positional request. */
+int CMoveMath::IsBlocked(const MoveData&amp; moveData, float3 pos, bool fromEst) {
+	int x = int(pos.x / SQUARE_SIZE);
+	int z = int(pos.z / SQUARE_SIZE);
+	return IsBlocked(moveData, x, z, fromEst);
 }
 
-/*
-Check if a given square-position is accessable by the footprint.
-this one check terrain
-*/
-int CMoveMath::IsBlocked(const MoveData&amp; moveData, int xSquare, int zSquare) {
-	if(CMoveMath::SpeedMod(moveData, xSquare, zSquare) == 0.0f)
-		return true;
+/* Check if a given square-position is accessable by the movedata footprint. */
+int CMoveMath::IsBlocked(const MoveData&amp; moveData, int xSquare, int zSquare, bool fromEst) {
+	if (CMoveMath::SpeedMod(moveData, xSquare, zSquare) == 0.0f) {
+		return 1;
+	}
 
-	int ret=0;
+	int ret = 0;
 
-	ret|=SquareIsBlocked(moveData, xSquare, zSquare);
-	ret|=SquareIsBlocked(moveData, xSquare - moveData.size/2, zSquare - moveData.size/2);
-	ret|=SquareIsBlocked(moveData, xSquare + moveData.size/2 - 1, zSquare - moveData.size/2);
-	ret|=SquareIsBlocked(moveData, xSquare - moveData.size/2, zSquare + moveData.size/2 - 1);
-	ret|=SquareIsBlocked(moveData, xSquare + moveData.size/2 - 1, zSquare + moveData.size/2 - 1);
+	ret |= SquareIsBlocked(moveData, xSquare                        , zSquare                        , fromEst);
+	ret |= SquareIsBlocked(moveData, xSquare - moveData.size / 2    , zSquare - moveData.size / 2    , fromEst);
+	ret |= SquareIsBlocked(moveData, xSquare + moveData.size / 2 - 1, zSquare - moveData.size / 2    , fromEst);
+	ret |= SquareIsBlocked(moveData, xSquare - moveData.size / 2    , zSquare + moveData.size / 2 - 1, fromEst);
+	ret |= SquareIsBlocked(moveData, xSquare + moveData.size / 2 - 1, zSquare + moveData.size / 2 - 1, fromEst);
 
 	return ret;
 }
 
 /*
-Check if a given square-position is accessable by the footprint.
-this one doesnt check terrain
-but do check so it doesnt run over something small if its big
-*/
-int CMoveMath::IsBlocked2(const MoveData&amp; moveData, int xSquare, int zSquare) 
-{
-	int ret=0;
+ * Check if a given square-position is accessable given the movedata footprint.
+ * Doesn't check terrain, but takes size into account so it does not run over
+ * something small if footprint is big.
+ */
+int CMoveMath::IsBlocked2(const MoveData&amp; moveData, int xSquare, int zSquare, bool fromEst) {
+	int ret = 0;
 
-	switch(moveData.size){
-	case 12:
-	case 11:
-		ret|=SquareIsBlocked(moveData, xSquare+4, zSquare+4);
-		ret|=SquareIsBlocked(moveData, xSquare-6, zSquare+4);
-		ret|=SquareIsBlocked(moveData, xSquare-6, zSquare-6);
-		ret|=SquareIsBlocked(moveData, xSquare+4, zSquare-6);
-	case 8:
-	case 7:
-		ret|=SquareIsBlocked(moveData, xSquare+2, zSquare+2);
-		ret|=SquareIsBlocked(moveData, xSquare-4, zSquare+2);
-		ret|=SquareIsBlocked(moveData, xSquare-4, zSquare-4);
-		ret|=SquareIsBlocked(moveData, xSquare+2, zSquare-4);
-	case 4:
-	case 3:
-		ret|=SquareIsBlocked(moveData, xSquare, zSquare);
-		ret|=SquareIsBlocked(moveData, xSquare-2, zSquare);
-		ret|=SquareIsBlocked(moveData, xSquare, zSquare-2);
-		ret|=SquareIsBlocked(moveData, xSquare-2, zSquare-2);
-		break;
+	switch (moveData.size) {
+		case 12:
+		case 11:
+			ret |= SquareIsBlocked(moveData, xSquare + 4, zSquare + 4, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 6, zSquare + 4, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 6, zSquare - 6, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare + 4, zSquare - 6, fromEst);
+		case 8:
+		case 7:
+			ret |= SquareIsBlocked(moveData, xSquare + 2, zSquare + 2, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 4, zSquare + 2, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 4, zSquare - 4, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare + 2, zSquare - 4, fromEst);
+		case 4:
+		case 3:
+			ret |= SquareIsBlocked(moveData, xSquare    , zSquare    , fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 2, zSquare    , fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare    , zSquare - 2, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 2, zSquare - 2, fromEst);
+			break;
 
-	case 14:
-	case 13:
-		ret|=SquareIsBlocked(moveData, xSquare+6, zSquare+6);
-		ret|=SquareIsBlocked(moveData, xSquare-6, zSquare+6);
-		ret|=SquareIsBlocked(moveData, xSquare-6, zSquare-6);
-		ret|=SquareIsBlocked(moveData, xSquare+6, zSquare-6);
-	case 10:
-	case 9:
-		ret|=SquareIsBlocked(moveData, xSquare+4, zSquare+4);
-		ret|=SquareIsBlocked(moveData, xSquare-4, zSquare+4);
-		ret|=SquareIsBlocked(moveData, xSquare-4, zSquare-4);
-		ret|=SquareIsBlocked(moveData, xSquare+4, zSquare-4);
-	case 6:
-	case 5:
-		ret|=SquareIsBlocked(moveData, xSquare+2, zSquare+2);
-		ret|=SquareIsBlocked(moveData, xSquare-2, zSquare+2);
-		ret|=SquareIsBlocked(moveData, xSquare-2, zSquare-2);
-		ret|=SquareIsBlocked(moveData, xSquare+2, zSquare-2);
-	case 2:
-	case 1:
-		ret|=SquareIsBlocked(moveData, xSquare, zSquare);
-		break;
+		case 14:
+		case 13:
+			ret |= SquareIsBlocked(moveData, xSquare + 6, zSquare + 6, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 6, zSquare + 6, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 6, zSquare - 6, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare + 6, zSquare - 6, fromEst);
+		case 10:
+		case 9:
+			ret |= SquareIsBlocked(moveData, xSquare + 4, zSquare + 4, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 4, zSquare + 4, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 4, zSquare - 4, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare + 4, zSquare - 4, fromEst);
+		case 6:
+		case 5:
+			ret |= SquareIsBlocked(moveData, xSquare + 2, zSquare + 2, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 2, zSquare + 2, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare - 2, zSquare - 2, fromEst);
+			ret |= SquareIsBlocked(moveData, xSquare + 2, zSquare - 2, fromEst);
+		case 2:
+		case 1:
+			ret |= SquareIsBlocked(moveData, xSquare, zSquare, fromEst);
+			break;
 
-	default:
-		logOutput.Print(&quot;Unknown size in IsBlocked2 %i&quot;,moveData.size);
-		break;
+		default:
+			logOutput.Print(&quot;Unknown footprint size in IsBlocked2() (%i)&quot;, moveData.size);
+			break;
 	};
+
 	return ret;
 }
 
 /*
-Simply check if the object is blocking or not.
-*/
+ * check if an object is blocking or not for a given MoveData (feature
+ * objects block iif their mass exceeds the movedata's crush-strength).
+ * NOTE: modify for selective blocking
+ */
 bool CMoveMath::IsBlocking(const MoveData&amp; moveData, const CSolidObject* object) {
-	return object-&gt;blocking &amp;&amp; (!dynamic_cast&lt;const CFeature*&gt;(object) || object-&gt;mass &gt; moveData.crushStrength);
+	return
+		(object-&gt;blocking &amp;&amp; (!dynamic_cast&lt;const CFeature*&gt;(object) ||
+		object-&gt;mass &gt; moveData.crushStrength));
 }
 
 
-/*
-Converts a point-request into a square-positional request.
-*/
+/* Converts a point-request into a square-positional request. */
 float CMoveMath::yLevel(const float3 pos) {
-	int x = (int)(pos.x / SQUARE_SIZE);
-	int z = (int)(pos.z / SQUARE_SIZE);
+	int x = int(pos.x / SQUARE_SIZE);
+	int z = int(pos.z / SQUARE_SIZE);
 	return yLevel(x, z);
 }
 
-/*
-Check if a single square is accessable.
-*/
-int CMoveMath::SquareIsBlocked(const MoveData&amp; moveData, int xSquare, int zSquare) {
-	//Error-check
-	if(xSquare &lt; 0 || zSquare &lt; 0
-	|| xSquare &gt;= gs-&gt;mapx || zSquare &gt;= gs-&gt;mapy)
-		return true;
+/* Check if a single square is accessable (for any object which uses the given movedata). */
+int CMoveMath::SquareIsBlocked(const MoveData&amp; moveData, int xSquare, int zSquare, bool fromEst) {
+	// Error-check
+	if (xSquare &lt; 0 || zSquare &lt; 0 || xSquare &gt;= gs-&gt;mapx || zSquare &gt;= gs-&gt;mapy) {
+		return 1;
+	}
 
 	CSolidObject* obstacle = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(xSquare + zSquare * gs-&gt;mapx);
-	if(obstacle) {
-		if(obstacle-&gt;mobility) {
-			if(obstacle-&gt;isMoving){
+	if (obstacle) {
+		if (obstacle-&gt;mobility) {
+			// mobile obstacle
+			if (obstacle-&gt;isMoving) {
 				return BLOCK_MOVING;
 			} else {
-				if(!((CUnit*)obstacle)-&gt;beingBuilt &amp;&amp; ((CUnit*)obstacle)-&gt;commandAI-&gt;commandQue.empty()){
+				if (!((CUnit*) obstacle)-&gt;beingBuilt &amp;&amp; ((CUnit*) obstacle)-&gt;commandAI-&gt;commandQue.empty()) {
+					// idling mobile unit
 					return BLOCK_MOBILE;
 				} else {
+					// busy mobile unit (but not following path)
 					return BLOCK_MOBILE_BUSY;
 				}
 			}
 		} else {
-			if(IsBlocking(moveData, obstacle))
+			if (IsBlocking(moveData, obstacle)) {
 				return BLOCK_STRUCTURE;
+			}
 		}
 	}
-  return 0;
-}
 
-CMoveMath::~CMoveMath() {
+	return 0;
 }

Modified: trunk/rts/Sim/MoveTypes/MoveMath/MoveMath.h
===================================================================
--- trunk/rts/Sim/MoveTypes/MoveMath/MoveMath.h	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/MoveMath/MoveMath.h	2008-07-03 03:12:06 UTC (rev 6101)
@@ -8,15 +8,15 @@
 class CMoveMath {
 	CR_DECLARE(CMoveMath);
 public:
-	//Block-check-options
-	//Note: Whose options are hierarchial, with CHECK_STRUCTURE as the first check.
+	// Block-check-options
+	// Note: options are hierarchical, with CHECK_STRUCTURE as the first check.
 	const static int BLOCK_MOVING = 1;
 	const static int BLOCK_MOBILE = 2;
 	const static int BLOCK_MOBILE_BUSY = 4;
 	const static int BLOCK_STRUCTURE = 8;
 	const static int BLOCK_TERRAIN = 16;
 
-	//SpeedMod returns a speed-multiplier for given position or data.
+	// returns a speed-multiplier for given position or data
 	float SpeedMod(const MoveData&amp; moveData, float3 pos);
 	float SpeedMod(const MoveData&amp; moveData, int xSquare, int zSquare);
 	virtual float SpeedMod(const MoveData&amp; moveData, float height, float slope) = 0;
@@ -24,21 +24,20 @@
 	float SpeedMod(const MoveData&amp; moveData, int xSquare, int zSquare,const float3&amp; moveDir);
 	virtual float SpeedMod(const MoveData&amp; moveData, float height, float slope,float moveSlope) = 0;
 
-	//IsBlocked tells whenever a position is blocked(=none-accessable) or not.
-	int IsBlocked(const MoveData&amp; moveData, float3 pos);
-	int IsBlocked(const MoveData&amp; moveData, int xSquare, int zSquare);
+	// tells whether a position is blocked (inaccessable for a given object's movedata)
+	int IsBlocked(const MoveData&amp; moveData, float3 pos, bool fromEst = false);
+	int IsBlocked(const MoveData&amp; moveData, int xSquare, int zSquare, bool fromEst = false);
+	int IsBlocked2(const MoveData&amp; moveData, int xSquare, int zSquare, bool fromEst = false);
 
-	int IsBlocked2(const MoveData&amp; moveData, int xSquare, int zSquare);
-
-	//IsBlocking tells whenever a given object are blocking the given movedata or not.
+	// tells whether a given object is blocking the given movedata
 	bool IsBlocking(const MoveData&amp; moveData, const CSolidObject* object);
 
-	//Gives the y-coordinate the unit will &quot;stand on&quot;.
+	// gives the y-coordinate the unit will &quot;stand on&quot;
 	float yLevel(float3 pos);
 	virtual float yLevel(int xSquare, int Square) = 0;
 
-	//Investigate the block-status of a single quare.
-	int SquareIsBlocked(const MoveData&amp; moveData, int xSquare, int zSquare);
+	// returns the block-status of a single quare
+	int SquareIsBlocked(const MoveData&amp; moveData, int xSquare, int zSquare, bool fromEst = false);
 
 	virtual ~CMoveMath();
 };

Modified: trunk/rts/Sim/MoveTypes/MoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/MoveType.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/MoveType.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -72,11 +72,11 @@
 
 void AMoveType::SlowUpdate()
 {
-	owner-&gt;pos.y = ground-&gt;GetHeight2(owner-&gt;pos.x,owner-&gt;pos.z);
-	if(owner-&gt;floatOnWater &amp;&amp; owner-&gt;pos.y&lt; -owner-&gt;unitDef-&gt;waterline) {
+	owner-&gt;pos.y = ground-&gt;GetHeight2(owner-&gt;pos.x, owner-&gt;pos.z);
+	if (owner-&gt;floatOnWater &amp;&amp; owner-&gt;pos.y &lt; -owner-&gt;unitDef-&gt;waterline) {
 		owner-&gt;pos.y = -owner-&gt;unitDef-&gt;waterline;
 	}
-	owner-&gt;midPos.y=owner-&gt;pos.y+owner-&gt;relMidPos.y;
+	owner-&gt;midPos.y = owner-&gt;pos.y + owner-&gt;relMidPos.y;
 };
 
 void AMoveType::LeaveTransport(void)

Modified: trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -2,7 +2,6 @@
 
 #include &quot;TAAirMoveType.h&quot;
 
-#include &quot;Mobility.h&quot;
 #include &quot;Game/Player.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
@@ -912,7 +911,7 @@
 	}
 
 	qf-&gt;MovedUnit(owner);
-	owner-&gt;isUnderWater = (owner-&gt;pos.y + owner-&gt;model-&gt;height &lt; 0);
+	owner-&gt;isUnderWater = (owner-&gt;pos.y + owner-&gt;model-&gt;height &lt; 0.0f);
 }
 
 //Returns true if indicated position is a suitable landing spot

Modified: trunk/rts/Sim/Objects/SolidObject.h
===================================================================
--- trunk/rts/Sim/Objects/SolidObject.h	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Objects/SolidObject.h	2008-07-03 03:12:06 UTC (rev 6101)
@@ -2,7 +2,7 @@
 #define SOLID_OBJECT_H
 
 #include &quot;WorldObject.h&quot;
-#include &quot;Sim/MoveTypes/Mobility.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;GlobalStuff.h&quot;
 #include &quot;Sync/SyncedFloat3.h&quot;
 
@@ -38,12 +38,12 @@
 	// Static properties.
 	float mass;									// The physical mass of this object.
 	bool blocking;								// If this object is blocking/collidable. (NOTE: Some objects could be flat =&gt; not collidable.)
-	bool floatOnWater;							// If the object will float or not in water.	(TODO: &quot;float dencity;&quot; would give more dynamic.)
+	bool floatOnWater;							// If the object will float or not in water. (TODO: &quot;float density;&quot; would be more dynamic.)
 	bool isUnderWater;
-	bool immobile;								// Immobile objects could not be moved. (Except perhaps in y, to make them stay on gound.)
-	bool blockHeightChanges;					// map height cant change under this object
-	int xsize;									// The x-size of this object, according to it's footprint.
-	int ysize;									// The z-size of this object, according to it's footprint. NOTE: This one should have been called zsize!
+	bool immobile;								// Immobile objects can not be moved. (Except perhaps along y-axis, to make them stay on ground.)
+	bool blockHeightChanges;					// map height cannot change under this object
+	int xsize;									// The x-size of this object, according to its footprint.
+	int ysize;									// The z-size of this object, according to its footprint. (NOTE: This one should have been called zsize!)
 	float height;								// The height of this object.
 	short heading;								// Contains the same information as frontdir, but in a short signed integer.
 	
@@ -58,7 +58,7 @@
 	float3 residualImpulse;						// Used to sum up external impulses.
 
 	// Mobility
-	CMobility *mobility;						// holds information about the mobility of this object (0 means object can not move on its own)
+	MoveData* mobility;							// holds information about the mobility and movedata of this object (0 means object can not move on its own)
 
 	// Map
 	int2 mapPos;								// Current position on GroundBlockingMap.

Modified: trunk/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- trunk/rts/Sim/Path/PathEstimator.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Path/PathEstimator.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -330,9 +330,11 @@
 			int dx = x - (BLOCK_SIZE &gt;&gt; 1);
 			int dz = z - (BLOCK_SIZE &gt;&gt; 1);
 			float cost = (dx * dx + dz * dz) + num / (0.001f + moveData.moveMath-&gt;SpeedMod(moveData, lowerX + x, lowerZ + z));
+			int mask = CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN;
 
-			if (moveData.moveMath-&gt;IsBlocked2(moveData, lowerX + x, lowerZ + z) &amp; (CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN))
+			if (moveData.moveMath-&gt;IsBlocked2(moveData, lowerX + x, lowerZ + z, true) &amp; mask) {
 				cost += 1000000.0f;
+			}
 			if (cost &lt; best) {
 				best = cost;
 				bestX = x;
@@ -740,7 +742,7 @@
 		int xGSquare = block.x * BLOCK_SIZE + goalSqrOffset.x;
 		int zGSquare = block.y * BLOCK_SIZE + goalSqrOffset.y;
 		// in first case try to use an offset defined by goal...
-		if (!moveData.moveMath-&gt;IsBlocked(moveData, moveMathOptions, xGSquare, zGSquare)) {
+		if (!moveData.moveMath-&gt;IsBlocced(moveData, moveMathOptions, xGSquare, zGSquare)) {
 			float3 pos = SquareToFloat3(xGSquare, zGSquare);
 			pos.y = moveData.moveMath-&gt;yLevel(xGSquare, zGSquare);
 			path.path.push_back(pos);

Modified: trunk/rts/Sim/Path/PathFinder.cpp
===================================================================
--- trunk/rts/Sim/Path/PathFinder.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Path/PathFinder.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -417,7 +417,7 @@
 	}
 
 	//Looking for improvements.
-	if(!exactPath	&amp;&amp; heuristicCost &lt; goalHeuristic) {
+	if (!exactPath &amp;&amp; heuristicCost &lt; goalHeuristic) {
 		goalSquare = sqr;
 		goalHeuristic = heuristicCost;
 	}
@@ -541,18 +541,19 @@
 If the goal area is small and blocked then it's considered blocked, else not.
 */
 bool CPathFinderDef::GoalIsBlocked(const MoveData&amp; moveData, unsigned int moveMathOptions) const {
-	if((sqGoalRadius &lt; SQUARE_SIZE*SQUARE_SIZE*4 || sqGoalRadius &lt;= (moveData.size/2)*(moveData.size/2)*1.5f*SQUARE_SIZE*SQUARE_SIZE)
-	&amp;&amp; (moveData.moveMath-&gt;IsBlocked(moveData, goal) &amp; moveMathOptions))
-		return true;
-	else
-		return false;
+	const float r0 = SQUARE_SIZE * SQUARE_SIZE * 4;
+	const float r1 = (moveData.size / 2) * (moveData.size / 2) * 1.5f * SQUARE_SIZE * SQUARE_SIZE;
+
+	return
+		((sqGoalRadius &lt; r0 || sqGoalRadius &lt;= r1) &amp;&amp;
+		(moveData.moveMath-&gt;IsBlocked(moveData, goal) &amp; moveMathOptions));
 }
 
 int2 CPathFinderDef::GoalSquareOffset(int blockSize) const {
 	int blockPixelSize = blockSize * SQUARE_SIZE;
 	int2 offset;
-	offset.x = ((int)goal.x % blockPixelSize) / SQUARE_SIZE;
-	offset.y = ((int)goal.z % blockPixelSize) / SQUARE_SIZE;
+	offset.x = ((int) goal.x % blockPixelSize) / SQUARE_SIZE;
+	offset.y = ((int) goal.z % blockPixelSize) / SQUARE_SIZE;
 	return offset;
 }
 

Modified: trunk/rts/Sim/Path/PathManager.cpp
===================================================================
--- trunk/rts/Sim/Path/PathManager.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Path/PathManager.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -30,26 +30,27 @@
 */
 CPathManager::CPathManager() {
 	//--TODO: Move to creation of MoveData!--//
-	//Create MoveMaths.
+	// create the MoveMaths
 	ground = SAFE_NEW CGroundMoveMath();
 	hover = SAFE_NEW CHoverMoveMath();
 	sea = SAFE_NEW CShipMoveMath();
 
 	float waterDamage = mapInfo-&gt;water.damage;
-	if(waterDamage&gt;=1000)
-		CGroundMoveMath::waterCost=0;
-	else
-		CGroundMoveMath::waterCost=1/(1.0f+waterDamage*0.1f);
+	if (waterDamage &gt;= 1000.0f) {
+		CGroundMoveMath::waterCost = 0.0f;
+	} else {
+		CGroundMoveMath::waterCost = 1.0f / (1.0f + waterDamage * 0.1f);
+	}
 
-	CHoverMoveMath::noWaterMove=waterDamage&gt;=10000;
+	CHoverMoveMath::noWaterMove = (waterDamage &gt;= 10000.0f);
 
-	//Address movemath and pathtype to movedata.
+	// assign movemath and pathtype to the movedata's
 	int counter = 0;
 	std::vector&lt;MoveData*&gt;::iterator mi;
-	for(mi = moveinfo-&gt;moveData.begin(); mi &lt; moveinfo-&gt;moveData.end(); mi++) {
+	for (mi = moveinfo-&gt;moveData.begin(); mi &lt; moveinfo-&gt;moveData.end(); mi++) {
 		(*mi)-&gt;pathType = counter;
-//		(*mi)-&gt;crushStrength = 0;
-		switch((*mi)-&gt;moveType) {
+
+		switch ((*mi)-&gt;moveType) {
 			case MoveData::Ground_Move:
 				(*mi)-&gt;moveMath = ground;
 				break;
@@ -62,14 +63,13 @@
 		}
 		counter++;
 	}
-	//---------------------------------------//
 
-	//Create pathfinder and estimators.
+	// Create pathfinder and estimators.
 	pf = new CPathFinder();
 	pe = new CPathEstimator(pf, 8, CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN, &quot;pe&quot;);
 	pe2 = new CPathEstimator(pf, 32, CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN, &quot;pe2&quot;);
 
-	//Reset id-counter.
+	// Reset id-counter.
 	nextPathId = 0;
 }
 
@@ -93,65 +93,70 @@
 Help-function.
 Turns a start-&gt;goal-request into a will defined request.
 */
-unsigned int CPathManager::RequestPath(const MoveData* moveData, float3 startPos, float3 goalPos, float goalRadius,CSolidObject* caller) {
+unsigned int CPathManager::RequestPath(const MoveData* moveData, float3 startPos, float3 goalPos, float goalRadius, CSolidObject* caller) {
 	startPos.CheckInBounds();
 	goalPos.CheckInBounds();
-	if(startPos.x&gt;gs-&gt;mapx*SQUARE_SIZE-5)
-		startPos.x=gs-&gt;mapx*SQUARE_SIZE-5;
-	if(goalPos.z&gt;gs-&gt;mapy*SQUARE_SIZE-5)
-		goalPos.z=gs-&gt;mapy*SQUARE_SIZE-5;
 
-	//Create a estimator definition.
-	CRangedGoalWithCircularConstraint * rangedGoalPED = SAFE_NEW CRangedGoalWithCircularConstraint(startPos,goalPos, goalRadius,3,2000);
+	if (startPos.x &gt; gs-&gt;mapx * SQUARE_SIZE - 5) { startPos.x = gs-&gt;mapx * SQUARE_SIZE - 5; }
+	if (goalPos.z &gt; gs-&gt;mapy * SQUARE_SIZE - 5) { goalPos.z = gs-&gt;mapy * SQUARE_SIZE - 5; }
 
-	//Make request.
-	return RequestPath(moveData, startPos, rangedGoalPED,goalPos,caller);
+	// Create an estimator definition.
+	CRangedGoalWithCircularConstraint* rangedGoalPED = SAFE_NEW CRangedGoalWithCircularConstraint(startPos,goalPos, goalRadius, 3, 2000);
+
+	// Make request.
+	return RequestPath(moveData, startPos, rangedGoalPED, goalPos, caller);
 }
 
 
 /*
 Request a new multipath, store the result and return an handle-id to it.
 */
-unsigned int CPathManager::RequestPath(const MoveData* moveData, float3 startPos, CPathFinderDef* peDef,float3 goalPos,CSolidObject* caller) {
-//	static int calls = 0;
-//	logOutput &lt;&lt; &quot;RequestPath() called: &quot; &lt;&lt; (++calls) &lt;&lt; &quot;\n&quot;;	//Debug
-
+unsigned int CPathManager::RequestPath(const MoveData* moveData, float3 startPos, CPathFinderDef* peDef, float3 goalPos, CSolidObject* caller) {
 	SCOPED_TIMER(&quot;AI:PFS&quot;);
 
-	//Creates a new multipath.
+	// Creates a new multipath.
 	MultiPath* newPath = SAFE_NEW MultiPath(startPos, peDef, moveData);
-	newPath-&gt;finalGoal=goalPos;
-	newPath-&gt;caller=caller;
+	newPath-&gt;finalGoal = goalPos;
+	newPath-&gt;caller = caller;
 
-	if(caller)
+	if (caller) {
 		caller-&gt;UnBlock();
+	}
 
-	unsigned int retValue=0;
-	//Choose finder dependent on distance to goal.
+	unsigned int retValue = 0;
+	// Choose finder dependent on distance to goal.
 	float distanceToGoal = peDef-&gt;Heuristic(int(startPos.x / SQUARE_SIZE), int(startPos.z / SQUARE_SIZE));
-	if(distanceToGoal &lt; DETAILED_DISTANCE) {
-		//Get a detailed path.
-		IPath::SearchResult result = pf-&gt;GetPath(*moveData, startPos, *peDef, newPath-&gt;detailedPath,true);
-		if(result == IPath::Ok || result == IPath::GoalOutOfRange) {
-			retValue=Store(newPath);
+
+	if (distanceToGoal &lt; DETAILED_DISTANCE) {
+		// Get a detailed path.
+		IPath::SearchResult result = pf-&gt;GetPath(*moveData, startPos, *peDef, newPath-&gt;detailedPath, true);
+
+		if (result == IPath::Ok || result == IPath::GoalOutOfRange) {
+			retValue = Store(newPath);
 		} else {
 			delete newPath;
 		}
-	} else if(distanceToGoal &lt; ESTIMATE_DISTANCE) {
-		//Get an estimate path.
+	} else if (distanceToGoal &lt; ESTIMATE_DISTANCE) {
+		// Get an estimate path.
 		IPath::SearchResult result = pe-&gt;GetPath(*moveData, startPos, *peDef, newPath-&gt;estimatedPath);
-		if(result == IPath::Ok || result == IPath::GoalOutOfRange) {
-			//Turn a part of it into detailed path.
+
+		if (result == IPath::Ok || result == IPath::GoalOutOfRange) {
+			// Turn a part of it into detailed path.
 			EstimateToDetailed(*newPath, startPos);
-			//Store the path.
-			retValue=Store(newPath);
-		} else {	//if we fail see if it can work find a better block to start from
-			float3 sp=pe-&gt;FindBestBlockCenter(moveData,startPos);
-			if(sp.x!=0 &amp;&amp; (((int)sp.x)/(SQUARE_SIZE*8)!=((int)startPos.x)/(SQUARE_SIZE*8) || ((int)sp.z)/(SQUARE_SIZE*8)!=((int)startPos.z)/(SQUARE_SIZE*8))){
+			// Store the path.
+			retValue = Store(newPath);
+		} else {
+			// if we fail see if it can work find a better block to start from
+			float3 sp = pe-&gt;FindBestBlockCenter(moveData, startPos);
+
+			if (sp.x != 0 &amp;&amp;
+				(((int) sp.x) / (SQUARE_SIZE * 8) != ((int) startPos.x) / (SQUARE_SIZE * 8) ||
+				((int) sp.z) / (SQUARE_SIZE * 8) != ((int) startPos.z) / (SQUARE_SIZE * 8))) {
 				IPath::SearchResult result = pe-&gt;GetPath(*moveData, sp, *peDef, newPath-&gt;estimatedPath);
-				if(result == IPath::Ok || result == IPath::GoalOutOfRange) {
+
+				if (result == IPath::Ok || result == IPath::GoalOutOfRange) {
 					EstimateToDetailed(*newPath, startPos);
-					retValue=Store(newPath);
+					retValue = Store(newPath);
 				} else {
 					delete newPath;
 				}
@@ -160,27 +165,35 @@
 			}
 		}
 	} else {
-		//Get a low-res. estimate path.
+		// Get a low-res. estimate path.
 		IPath::SearchResult result = pe2-&gt;GetPath(*moveData, startPos, *peDef, newPath-&gt;estimatedPath2);
-		if(result == IPath::Ok || result == IPath::GoalOutOfRange) {
-			//Turn a part of it into hi-res. estimate path.
+
+		if (result == IPath::Ok || result == IPath::GoalOutOfRange) {
+			// Turn a part of it into hi-res. estimate path.
 			Estimate2ToEstimate(*newPath, startPos);
-			//And estimate into detailed.
+			// And estimate into detailed.
 			EstimateToDetailed(*newPath, startPos);
-			//Store the path.
-			retValue=Store(newPath);
-		} else {	//sometimes the 32*32 squares can be wrong so if it fail to get a path also try with 8*8 squares
+			// Store the path.
+			retValue = Store(newPath);
+		} else {
+			// sometimes the 32*32 squares can be wrong so if it fails to get a path also try with 8*8 squares
 			IPath::SearchResult result = pe-&gt;GetPath(*moveData, startPos, *peDef, newPath-&gt;estimatedPath);
-			if(result == IPath::Ok || result == IPath::GoalOutOfRange) {
+
+			if (result == IPath::Ok || result == IPath::GoalOutOfRange) {
 				EstimateToDetailed(*newPath, startPos);
-				retValue=Store(newPath);
-			} else { //8*8 can also fail rarely, so see if we can find a better 8*8 to start from
-				float3 sp=pe-&gt;FindBestBlockCenter(moveData,startPos);
-				if(sp.x!=0 &amp;&amp; (((int)sp.x)/(SQUARE_SIZE*8)!=((int)startPos.x)/(SQUARE_SIZE*8) || ((int)sp.z)/(SQUARE_SIZE*8)!=((int)startPos.z)/(SQUARE_SIZE*8))){
+				retValue = Store(newPath);
+			} else {
+				// 8*8 can also fail rarely, so see if we can find a better 8*8 to start from
+				float3 sp = pe-&gt;FindBestBlockCenter(moveData, startPos);
+
+				if (sp.x != 0 &amp;&amp;
+					(((int) sp.x) / (SQUARE_SIZE * 8) != ((int) startPos.x) / (SQUARE_SIZE * 8) ||
+					((int) sp.z) / (SQUARE_SIZE * 8) != ((int) startPos.z) / (SQUARE_SIZE * 8))) {
 					IPath::SearchResult result = pe-&gt;GetPath(*moveData, sp, *peDef, newPath-&gt;estimatedPath);
-					if(result == IPath::Ok || result == IPath::GoalOutOfRange) {
+
+					if (result == IPath::Ok || result == IPath::GoalOutOfRange) {
 						EstimateToDetailed(*newPath, startPos);
-						retValue=Store(newPath);
+						retValue = Store(newPath);
 					} else {
 						delete newPath;
 					}
@@ -190,8 +203,9 @@
 			}
 		}
 	}
-	if(caller)
+	if (caller) {
 		caller-&gt;Block();
+	}
 	return retValue;
 }
 

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -1504,7 +1504,7 @@
 	blocking = true;
 
 	// some torp launchers etc are exactly in the surface and should be considered uw anyway
-	if ((pos.y + model-&gt;height) &lt; 1) {
+	if ((pos.y + model-&gt;height) &lt; 0.0f) {
 		isUnderWater = true;
 	}
 

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -637,7 +637,7 @@
 		ud.movedata = moveinfo-&gt;GetMoveDataFromName(moveclass);
 		if ((ud.movedata-&gt;moveType == MoveData::Hover_Move) ||
 		    (ud.movedata-&gt;moveType == MoveData::Ship_Move)) {
-			ud.upright=true;
+			ud.upright = true;
 		}
 		if (ud.canhover) {
 			if (ud.movedata-&gt;moveType != MoveData::Hover_Move) {

Modified: trunk/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitHandler.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Units/UnitHandler.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -372,12 +372,14 @@
 		}
 	}
 
-	for(int x=x1; x&lt;x2; x+=SQUARE_SIZE){
-		for(int z=z1; z&lt;z2; z+=SQUARE_SIZE){
-			int tbs=TestBuildSquare(float3(x,h,z),buildInfo.def,feature,allyteam);
-			canBuild=min(canBuild,tbs);
-			if(canBuild==0)
+	for (int x = x1; x &lt; x2; x += SQUARE_SIZE) {
+		for (int z = z1; z &lt; z2; z += SQUARE_SIZE) {
+			int tbs = TestBuildSquare(float3(x, h, z), buildInfo.def, feature, allyteam);
+			canBuild = min(canBuild, tbs);
+
+			if (canBuild == 0) {
 				return 0;
+			}
 		}
 	}
 
@@ -385,21 +387,22 @@
 }
 
 
-int CUnitHandler::TestBuildSquare(const float3&amp; pos, const UnitDef *unitdef, CFeature *&amp;feature, int allyteam)
+int CUnitHandler::TestBuildSquare(const float3&amp; pos, const UnitDef* unitdef, CFeature*&amp; feature, int allyteam)
 {
-	int ret=2;
-	if(pos.x&lt;0 || pos.x&gt;=gs-&gt;mapx*SQUARE_SIZE || pos.z&lt;0 || pos.z&gt;=gs-&gt;mapy*SQUARE_SIZE)
+	if (pos.x &lt; 0 || pos.x &gt;= gs-&gt;mapx * SQUARE_SIZE || pos.z &lt; 0 || pos.z &gt;= gs-&gt;mapy * SQUARE_SIZE) {
 		return 0;
+	}
 
-	int yardxpos=int(pos.x+4)/SQUARE_SIZE;
-	int yardypos=int(pos.z+4)/SQUARE_SIZE;
+	int ret = 2;
+	int yardxpos = int(pos.x + 4) / SQUARE_SIZE;
+	int yardypos = int(pos.z + 4) / SQUARE_SIZE;
 	CSolidObject* s;
-	if ((s = groundBlockingObjectMap-&gt;GroundBlocked(yardypos*gs-&gt;mapx+yardxpos))) {
+
+	if ((s = groundBlockingObjectMap-&gt;GroundBlocked(yardypos * gs-&gt;mapx + yardxpos))) {
 		if (dynamic_cast&lt;CFeature*&gt;(s)) {
-			feature = (CFeature*)s;
-		}
-		else if (!dynamic_cast&lt;CUnit*&gt;(s) || (allyteam &lt; 0) ||
-		         (((CUnit*)s)-&gt;losStatus[allyteam] &amp; LOS_INLOS)) {
+			feature = (CFeature*) s;
+		} else if (!dynamic_cast&lt;CUnit*&gt;(s) || (allyteam &lt; 0) ||
+			(((CUnit*) s)-&gt;losStatus[allyteam] &amp; LOS_INLOS)) {
 			if (s-&gt;immobile) {
 				return 0;
 			} else {
@@ -408,24 +411,28 @@
 		}
 	}
 
-	if(!unitdef-&gt;floater)
-	{
-		float* heightmap=readmap-&gt;GetHeightmap();
-		int x=(int) (pos.x/SQUARE_SIZE);
-		int z=(int) (pos.z/SQUARE_SIZE);
-		float orgh=readmap-&gt;orgheightmap[z*(gs-&gt;mapx+1)+x];
-		float h=heightmap[z*(gs-&gt;mapx+1)+x];
-		float hdif=unitdef-&gt;maxHeightDif;
-		if(pos.y&gt;orgh+hdif &amp;&amp; pos.y&gt;h+hdif)
-			return 0;
-		if(pos.y&lt;orgh-hdif &amp;&amp; pos.y&lt;h-hdif)
-			return 0;
+	if (!unitdef-&gt;floater) {
+		float* heightmap = readmap-&gt;GetHeightmap();
+		int x = (int) (pos.x / SQUARE_SIZE);
+		int z = (int) (pos.z / SQUARE_SIZE);
+		float orgh = readmap-&gt;orgheightmap[z * (gs-&gt;mapx + 1) + x];
+		float h = heightmap[z * (gs-&gt;mapx + 1) + x];
+		float hdif = unitdef-&gt;maxHeightDif;
+
+		if (pos.y &gt; orgh + hdif &amp;&amp; pos.y &gt; h + hdif) { return 0; }
+		if (pos.y &lt; orgh - hdif &amp;&amp; pos.y &lt; h - hdif) { return 0; }
 	}
-	float groundheight = ground-&gt;GetHeight2(pos.x,pos.z);
-	if(!unitdef-&gt;floater &amp;&amp; groundheight&lt;-unitdef-&gt;maxWaterDepth)
+
+	const float groundheight = ground-&gt;GetHeight2(pos.x, pos.z);
+
+	if (!unitdef-&gt;floater &amp;&amp; groundheight &lt; -unitdef-&gt;maxWaterDepth) {
+		// ground is deeper than our maxWaterDepth, cannot build here
 		return 0;
-	if(groundheight&gt;-unitdef-&gt;minWaterDepth)
+	}
+	if (groundheight &gt; -unitdef-&gt;minWaterDepth) {
+		// round is shallower than our minWaterDepth, cannot build here
 		return 0;
+	}
 
 	return ret;
 }

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-07-03 03:12:06 UTC (rev 6101)
@@ -83,8 +83,10 @@
 
 	if (!build) {
 		pos.y = ground-&gt;GetHeight2(pos.x, pos.z);
-		if (ud-&gt;floater &amp;&amp; pos.y &lt; 0)
-			pos.y = -ud-&gt;waterline;
+		if (ud-&gt;floater &amp;&amp; pos.y &lt; 0.0f) {
+			// adjust to waterline iif we are submerged
+ 			pos.y = -ud-&gt;waterline;
+		}
 	}
 	bool blocking = false;	//Used to tell if ground area shall be blocked of not.
 
@@ -214,55 +216,52 @@
 
 	if (ud-&gt;canmove &amp;&amp; !ud-&gt;canfly &amp;&amp; type!=&quot;Factory&quot;) {
 		CGroundMoveType* mt = SAFE_NEW CGroundMoveType(unit);
-		mt-&gt;maxSpeed=ud-&gt;speed/GAME_SPEED;
-		mt-&gt;maxWantedSpeed=ud-&gt;speed/GAME_SPEED;
-		mt-&gt;turnRate=ud-&gt;turnRate;
-		mt-&gt;baseTurnRate=ud-&gt;turnRate;
-		if (!mt-&gt;accRate)
+		mt-&gt;maxSpeed = ud-&gt;speed / GAME_SPEED;
+		mt-&gt;maxWantedSpeed = ud-&gt;speed / GAME_SPEED;
+		mt-&gt;turnRate = ud-&gt;turnRate;
+		mt-&gt;baseTurnRate = ud-&gt;turnRate;
+
+		if (!mt-&gt;accRate) {
 			logOutput &lt;&lt; &quot;acceleration of &quot; &lt;&lt; ud-&gt;name.c_str() &lt;&lt; &quot; is zero!!\n&quot;;
-		mt-&gt;moveType=ud-&gt;moveType;
-		mt-&gt;accRate=ud-&gt;maxAcc;
-		mt-&gt;decRate=ud-&gt;maxDec;
-		mt-&gt;floatOnWater=ud-&gt;movedata-&gt;moveType==MoveData::Hover_Move || ud-&gt;movedata-&gt;moveType==MoveData::Ship_Move;
-		if(!unit-&gt;beingBuilt)
-			unit-&gt;mass=ud-&gt;mass;	//otherwise set this when finished building instead
-		unit-&gt;moveType=mt;
+		}
 
+		mt-&gt;moveType = ud-&gt;moveType;
+		mt-&gt;accRate = ud-&gt;maxAcc;
+		mt-&gt;decRate = ud-&gt;maxDec;
+		mt-&gt;floatOnWater = (ud-&gt;movedata-&gt;moveType == MoveData::Hover_Move || ud-&gt;movedata-&gt;moveType == MoveData::Ship_Move);
 
-		//Ground-mobility
-		unit-&gt;mobility = SAFE_NEW CMobility();
-		unit-&gt;mobility-&gt;canFly = false;
-		unit-&gt;mobility-&gt;subMarine = false;		//Not always correct, as submarines are treated as ships.
-		unit-&gt;mobility-&gt;maxAcceleration = ud-&gt;maxAcc;
-		unit-&gt;mobility-&gt;maxBreaking = -3*ud-&gt;maxAcc;
-		unit-&gt;mobility-&gt;maxSpeed = ud-&gt;speed / GAME_SPEED;
-		unit-&gt;mobility-&gt;maxTurnRate = (short int) ud-&gt;turnRate;
-		unit-&gt;mobility-&gt;moveData = ud-&gt;movedata;
+		if (!unit-&gt;beingBuilt) {
+			// otherwise set this when finished building instead
+			unit-&gt;mass = ud-&gt;mass;
+		}
+		unit-&gt;moveType = mt;
 
-	} else if(ud-&gt;canfly) {
-		//Air-mobility
-		unit-&gt;mobility = SAFE_NEW CMobility();
-		unit-&gt;mobility-&gt;canFly = true;
-		unit-&gt;mobility-&gt;subMarine = false;
-		unit-&gt;mobility-&gt;maxAcceleration = ud-&gt;maxAcc;
-		unit-&gt;mobility-&gt;maxBreaking = -3*ud-&gt;maxAcc;	//Correct?
-		unit-&gt;mobility-&gt;maxSpeed = ud-&gt;speed / GAME_SPEED;
-		unit-&gt;mobility-&gt;maxTurnRate = (short int) ud-&gt;turnRate;
-		unit-&gt;mobility-&gt;moveData = ud-&gt;movedata;
+		// Ground-mobility
+		unit-&gt;mobility = SAFE_NEW MoveData(ud-&gt;maxAcc, ud-&gt;maxAcc * -3.0f,
+			ud-&gt;speed / GAME_SPEED, (short int) ud-&gt;turnRate, false, false,
+			ud-&gt;movedata);
 
-		if(!unit-&gt;beingBuilt)
-			unit-&gt;mass=ud-&gt;mass; //otherwise set this when finished building instead
+	} else if (ud-&gt;canfly) {
+		// Air-mobility
+		unit-&gt;mobility = SAFE_NEW MoveData(ud-&gt;maxAcc, ud-&gt;maxAcc * -3.0f,
+			ud-&gt;speed / GAME_SPEED, (short int) ud-&gt;turnRate, true, false,
+			ud-&gt;movedata);
 
+		if (!unit-&gt;beingBuilt) {
+			// otherwise set this when finished building instead
+			unit-&gt;mass = ud-&gt;mass;
+		}
+
 		if ((type == &quot;Builder&quot;) || ud-&gt;hoverAttack || ud-&gt;transportCapacity) {
-			CTAAirMoveType *mt = SAFE_NEW CTAAirMoveType(unit);
+			CTAAirMoveType* mt = SAFE_NEW CTAAirMoveType(unit);
 
 			mt-&gt;turnRate = ud-&gt;turnRate;
 			mt-&gt;maxSpeed = ud-&gt;speed / GAME_SPEED;
 			mt-&gt;accRate = ud-&gt;maxAcc;
 			mt-&gt;decRate = ud-&gt;maxDec;
-			mt-&gt;wantedHeight = ud-&gt;wantedHeight+gs-&gt;randFloat()*5;
+			mt-&gt;wantedHeight = ud-&gt;wantedHeight + gs-&gt;randFloat() * 5;
 			mt-&gt;orgWantedHeight=mt-&gt;wantedHeight;
-			mt-&gt;dontLand = ud-&gt;DontLand ();
+			mt-&gt;dontLand = ud-&gt;DontLand();
 			mt-&gt;collide = ud-&gt;collide;
 			mt-&gt;altitudeRate = ud-&gt;verticalSpeed;
 
@@ -326,6 +325,7 @@
 
 
 	if (ud-&gt;floater) {
+		// restrict our depth to our waterline
 		unit-&gt;pos.y = std::max(-ud-&gt;waterline, ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z));
 	} else {
 		unit-&gt;pos.y = ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z);

Modified: trunk/rts/build/vstudio8/rts.vcproj
===================================================================
--- trunk/rts/build/vstudio8/rts.vcproj	2008-07-02 16:33:58 UTC (rev 6100)
+++ trunk/rts/build/vstudio8/rts.vcproj	2008-07-03 03:12:06 UTC (rev 6101)
@@ -3073,14 +3073,6 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Sim\MoveTypes\Mobility.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;..\..\Sim\MoveTypes\Mobility.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
 					RelativePath=&quot;..\..\Sim\MoveTypes\MoveInfo.cpp&quot;
 					&gt;
 				&lt;/File&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000880.html">[Taspring-linux-commit] r6100 - in trunk: . rts/build/scons	rts/build/vstudio8 rts/lib
</A></li>
	<LI>Next message: <A HREF="000882.html">[Taspring-linux-commit] r6102 - in trunk: . Documentation	rts/ExternalAI rts/Game rts/Game/UI rts/Lua rts/Map	rts/System rts/lib/gml tools/DedicatedServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#881">[ date ]</a>
              <a href="thread.html#881">[ thread ]</a>
              <a href="subject.html#881">[ subject ]</a>
              <a href="author.html#881">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
