<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6124 - in trunk:	installer/builddata/bitmaps installer/builddata/bitmaps/bitmaps	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SMF rts/Rendering/Env rts/Rendering/GL	rts/Sim/Projectiles/WeaponProjectiles rts/System
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6124%20-%20in%20trunk%3A%0A%09installer/builddata/bitmaps%20installer/builddata/bitmaps/bitmaps%0A%09installer/builddata/springcontent/shaders%20rts/Game%20rts/Lua%0A%09rts/Map%20rts/Map/SMF%20rts/Rendering/Env%20rts/Rendering/GL%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/System&In-Reply-To=%3C20080708211540.5E792492F%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000903.html">
   <LINK REL="Next"  HREF="000905.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6124 - in trunk:	installer/builddata/bitmaps installer/builddata/bitmaps/bitmaps	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SMF rts/Rendering/Env rts/Rendering/GL	rts/Sim/Projectiles/WeaponProjectiles rts/System</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6124%20-%20in%20trunk%3A%0A%09installer/builddata/bitmaps%20installer/builddata/bitmaps/bitmaps%0A%09installer/builddata/springcontent/shaders%20rts/Game%20rts/Lua%0A%09rts/Map%20rts/Map/SMF%20rts/Rendering/Env%20rts/Rendering/GL%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/System&In-Reply-To=%3C20080708211540.5E792492F%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6124 - in trunk:	installer/builddata/bitmaps installer/builddata/bitmaps/bitmaps	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SMF rts/Rendering/Env rts/Rendering/GL	rts/Sim/Projectiles/WeaponProjectiles rts/System">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Tue Jul  8 23:15:40 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000903.html">[Taspring-linux-commit] r6123 - trunk/rts/Game/UI
</A></li>
        <LI>Next message: <A HREF="000905.html">[Taspring-linux-commit] r6125 - trunk/rts/Lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#904">[ date ]</a>
              <a href="thread.html#904">[ thread ]</a>
              <a href="subject.html#904">[ subject ]</a>
              <a href="author.html#904">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jk
Date: 2008-07-08 23:15:39 +0200 (Tue, 08 Jul 2008)
New Revision: 6124

Added:
   trunk/installer/builddata/bitmaps/bitmaps/shorewaverand.bmp
   trunk/installer/builddata/springcontent/shaders/bumpWaterCoastBlurFS.glsl
Modified:
   trunk/installer/builddata/bitmaps/README.txt
   trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
   trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
   trunk/rts/Game/Camera.cpp
   trunk/rts/Lua/LuaMaterial.cpp
   trunk/rts/Map/MapInfo.cpp
   trunk/rts/Map/MapInfo.h
   trunk/rts/Map/ReadMap.h
   trunk/rts/Map/SMF/BFGroundTextures.cpp
   trunk/rts/Map/SMF/BFGroundTextures.h
   trunk/rts/Map/SMF/SmfReadMap.cpp
   trunk/rts/Rendering/Env/BumpWater.cpp
   trunk/rts/Rendering/Env/BumpWater.h
   trunk/rts/Rendering/GL/FBO.cpp
   trunk/rts/Rendering/GL/myGL.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
   trunk/rts/System/GlobalStuff.h
   trunk/rts/System/SpringApp.cpp
   trunk/rts/System/SpringApp.h
Log:
*fixed some displaylists/textures weren't deleted on shutdown
*reduce # of PBOs in BFGroundTextures (30-&gt;10)
*removed some unused variables in BFGroundTextures
*use fastmath in BFGroundTextures
*updated BumpWater:
  *it uses now a screen depth copy to blend stuff much smoother
  *use FBOs for everything (and use CTT as fallback)
  *fixed BumpWaterRefraction=2 mode (mode 1 uses a screen copy (fast), mode 2 uses an own render pass, so underwater particles are distorted and there isn't a ghost distortion around units above the water)
  *cleaned up shader
  *added BumpWaterBlurReflection option
  *added preview version of shorewaves (still not finished, it seems I am hitting a hardware limit of my 7600GT)
  *added many new map options
  *RENAMED some user options / map options!

  *so there are the following user options (default in brackets):
    BumpWaterTexSizeReflection = 32,64,128,(256),512,1024,2048
    BumpWaterReflection        = 0,(1)
    BumpWaterRefraction        = 0:=off, (1):=screencopy, 2:=own rendering pass
    BumpWaterShoreWaves        = (0),1
    BumpWaterAnisotropy        = (0.0) - 12.0
    BumpWaterUseDepthTexture   = 0,(1)
    BumpWaterDepthBits         = 16,(24),32
    BumpWaterBlurReflection    = (0),1

  *and the map options (new/changed marked with a *):
    surfaceColor          = (0.75f, 0.8f, 0.85f)
    surfaceAlpha          = 0.55f
    *diffuseColor         = (1.0f, 1.0f, 1.0f)
    specularColor         = groundSunColor
    *specularPower        = 20.0f (RENAMED!!! this was specularFactor before)
    *specularFactor       = 1.0f
    *ambientFactor        = 1.0f
    *diffuseFactor        = 1.0f
    fresnelMin            = 0.2f (0.0&lt;x&lt;=1.0)
    fresnelMax            = 0.7f (&lt;1.0-fresnelMin)
    fresnelPower          = 4.0f
    *reflectionDistortion = 1.0f
    *blurBase             = 2.0f
    *blurExponent         = 1.5f
    *perlinStartFreq      = 8.0f (those perlin.. influence the wave sizes)
    *perlinLacunarity     = 3.0f
    *perlinAmplitude      = 0.9f (0.0&lt;x&lt;=1.0)

Modified: trunk/installer/builddata/bitmaps/README.txt
===================================================================
--- trunk/installer/builddata/bitmaps/README.txt	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/installer/builddata/bitmaps/README.txt	2008-07-08 21:15:39 UTC (rev 6124)
@@ -67,3 +67,4 @@
 wake.tga		Yeha
 waterbump.png		jK
 caustics/*		jK (with GPL app: <A HREF="http://www.lysator.liu.se/~kand/caustics/">http://www.lysator.liu.se/~kand/caustics/</A>)
+shorewaverand.bmp	jK
\ No newline at end of file

Added: trunk/installer/builddata/bitmaps/bitmaps/shorewaverand.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/shorewaverand.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/springcontent/shaders/bumpWaterCoastBlurFS.glsl
===================================================================
--- trunk/installer/builddata/springcontent/shaders/bumpWaterCoastBlurFS.glsl	                        (rev 0)
+++ trunk/installer/builddata/springcontent/shaders/bumpWaterCoastBlurFS.glsl	2008-07-08 21:15:39 UTC (rev 6124)
@@ -0,0 +1,70 @@
+uniform sampler2D tex0;
+uniform vec2 blurDir;
+
+const float kernel = 1.0/10.0;
+
+void main(void) {
+  vec2 texCoord = gl_TexCoord[0].st;
+
+  const vec2 texel = vec2(dFdx(gl_TexCoord[0].s),dFdy(gl_TexCoord[0].t));
+
+  // 0 distance
+  gl_FragColor  = texture2D(tex0, texCoord );
+  if (gl_FragColor.r&gt;0.0) {
+    vec4 blur;
+    blur.x = texture2D(tex0, texCoord+vec2(texel.x,0.0) ).r;
+    blur.y = texture2D(tex0, texCoord+vec2(0.0,texel.y) ).r;
+    blur.z = texture2D(tex0, texCoord+vec2(-texel.x,0.0) ).r;
+    blur.w = texture2D(tex0, texCoord+vec2(0.0,-texel.y) ).r;
+    gl_FragColor.r = dot(blur,vec4(0.2))+gl_FragColor.r*0.2;
+    return;
+  }
+
+  // 1 texel distance
+  vec4 blur;
+  blur.x = texture2D(tex0, texCoord-texel ).r;
+  blur.y = texture2D(tex0, texCoord-vec2(0.0,texel.y) ).r;
+  blur.z = texture2D(tex0, texCoord-vec2(-texel.x,texel.y) ).r;
+  blur.w = texture2D(tex0, texCoord-vec2(texel.x,0.0) ).r;
+
+  vec4 blur2;
+  blur2.x = texture2D(tex0, texCoord+texel ).r;
+  blur2.y = texture2D(tex0, texCoord+vec2(0.0,texel.y) ).r;
+  blur2.z = texture2D(tex0, texCoord+vec2(-texel.x,texel.y) ).r;
+  blur2.w = texture2D(tex0, texCoord+vec2(texel.x,0.0) ).r;
+
+  blur = max(blur,blur2);
+  blur.xy = max(blur.xy,blur.zw);
+  blur.x  = max(blur.x,blur.y);
+  if (blur.x&gt;0.0) { gl_FragColor.r=blur.x-kernel; return;}
+
+  // 2 texel distance
+  blur.x = 0.0;// texture2D(tex0, texCoord-2.0*texel ).r;
+  blur.y = texture2D(tex0, texCoord-vec2(texel.x,2.0*texel.y) ).r;
+  blur.z = texture2D(tex0, texCoord-vec2(0.0,2.0*texel.y) ).r;
+  blur.w = texture2D(tex0, texCoord-vec2(-texel.x,2.0*texel.y) ).r;
+
+  blur2.x = 0.0;// texture2D(tex0, texCoord+vec2(2.0*texel.x,-2.0*texel.y) ).r;
+  blur2.y = texture2D(tex0, texCoord+vec2(2.0*texel.x,-texel.y) ).r;
+  blur2.z = texture2D(tex0, texCoord+vec2(2.0*texel.x,0.0) ).r;
+  blur2.w = texture2D(tex0, texCoord+vec2(2.0*texel.x,texel.y) ).r;
+
+  vec4 blur3;
+  blur3.x = 0.0;// texture2D(tex0, texCoord+2.0*texel ).r;
+  blur3.y = texture2D(tex0, texCoord+vec2(texel.x,2.0*texel.y) ).r;
+  blur3.z = texture2D(tex0, texCoord+vec2(0.0,2.0*texel.y) ).r;
+  blur3.w = texture2D(tex0, texCoord+vec2(-texel.x,2.0*texel.y) ).r;
+
+  vec4 blur4;
+  blur4.x = 0.0;// texture2D(tex0, texCoord-vec2(2.0*texel.x,-2.0*texel.y) ).r;
+  blur4.y = texture2D(tex0, texCoord-vec2(2.0*texel.x,-texel.y) ).r;
+  blur4.z = texture2D(tex0, texCoord-vec2(2.0*texel.x,0.0) ).r;
+  blur4.w = texture2D(tex0, texCoord-vec2(2.0*texel.x,texel.y) ).r;
+
+  blur = max(blur,blur2);
+  blur = max(blur,blur3);
+  blur = max(blur,blur4);
+  blur.xy = max(blur.xy,blur.zw);
+  blur.x  = max(blur.x,blur.y);
+  if (blur.x&gt;0.0) { gl_FragColor.r=blur.x-kernel-kernel; return;}
+}
\ No newline at end of file

Modified: trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
===================================================================
--- trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-07-08 21:15:39 UTC (rev 6124)
@@ -1,6 +1,6 @@
 /**
  * @project Spring RTS
- * @file bumpWaterVS.glsl
+ * @file bumpWaterFS.glsl
  * @brief An extended bumpmapping water shader
  * @author jK
  *
@@ -10,102 +10,239 @@
 
 //////////////////////////////////////////////////
 // runtime defined constants are:
-// #define SurfaceColor   vec4
-// #define SpecularColor  vec3
-// #define SpecularFactor float
-// #define MapMid         vec3
-// #define SunDir         vec3
-// #define FresnelMin     float
-// #define FresnelMax     float
-// #define FresnelPower   float
-// #define ScreenInverse  vec2
-// #define ViewPos        vec2
-// #define SunDir         vec3
+// #define SurfaceColor     vec4
+// #define DiffuseColor     vec3
+// #define PlaneColor       vec4  (unused)
+// #define AmbientFactor    float
+// #define DiffuseFactor    float   (note: it is the map defined value multipled with 15x!)
+// #define SpecularColor    vec3
+// #define SpecularPower    float
+// #define SpecularFactor   float
+// #define PerlinStartFreq  float
+// #define PerlinFreq       float
+// #define PerlinAmp        float
+// #define Speed            float
+// #define FresnelMin       float
+// #define FresnelMax       float
+// #define FresnelPower     float
+// #define ScreenInverse    vec2
+// #define ViewPos          vec2
+// #define MapMid           vec3
+// #define SunDir           vec3
+// #define ReflDistortion   float
+// #define BlurBase         vec2
+// #define BlurExponent     float
+// #define PerlinStartFreq  float
+// #define PerlinLacunarity float
+// #define PerlinAmp        float
 
+//////////////////////////////////////////////////
+// possible flags are:
+// //#define use_heightmap
+// #define use_reflection
+// #define use_refraction
+// #define use_shorewaves
+// #define use_depth
+// #define blur_reflection
+
 #extension GL_ARB_texture_rectangle : enable
-//#extension GL_ARB_shader_texture_lod : enable
 
+#define CausticDepth 0.5
+#define CausticRange 0.45
+#define WavesLength  0.15
+
+//////////////////////////////////////////////////
+// Uniforms + Varyings
+
   uniform sampler2D normalmap;
   uniform sampler2D heightmap;
   uniform sampler2D caustic;
   uniform sampler2D foam;
   uniform sampler2D reflection;
   uniform sampler2DRect refraction;
+  uniform sampler2D coastmap;
+  uniform sampler2DRect depthmap;
+  uniform sampler2D waverand;
   uniform float frame;
   uniform vec3 eyePos;
 
   varying vec3 eyeVec;
   varying vec3 ligVec;
 
+//////////////////////////////////////////////////
+// Depth conversion
+
+  float pm15 = gl_ProjectionMatrix[2][3];
+  float pm11 = gl_ProjectionMatrix[2][3];
+  float convertDepthToZ(float d) {
+    return pm15 / (((d * 2.0) - 1.0) + pm11);
+  }
+
+
+//////////////////////////////////////////////////
+// shorewaves functions
+const float InvWavesLength = 1.0/WavesLength;
+
+float smoothlimit(const float x, const float step) {
+  if (x&gt;step)
+    //return step * smoothstep(1.0,step,x);
+    return step - (mod(x,step)*step)/(1.0-step);
+  else
+    return x;
+}
+
+
+float waveIntensity(const float x, const float step) {
+  float front = 1.0-(abs(x-step))/(1.0-step);
+  //float front = smoothstep(1.0-step,0.0,abs(x-step));
+  if (x&lt;step)
+    return max(front,x*0.5);
+  else
+    return front;
+}
+
+//////////////////////////////////////////////////
+// MAIN()
+
   void main(void) {
+// GET WATERDEPTH
 #ifdef use_heightmap
-    float waterdepth = texture2D(heightmap,gl_TexCoord[0].st).r;
-    if (waterdepth&lt;0.0) {
+    float waterdepth = -texture2D(heightmap,gl_TexCoord[0].st).r;
+    if (waterdepth&lt;0.0) discard;
 #else
-    float waterdepth = texture2D(heightmap,gl_TexCoord[0].pq).a; //heightmap in alpha channel
-    if (waterdepth&lt;1.0) {
-      float invwaterdepth = 1.0-waterdepth;
+    float waterdepth = 1.0-texture2D(heightmap,gl_TexCoord[0].pq).a; //heightmap in alpha channel
+    if (waterdepth==0.0) discard;
+    //float invwaterdepth = 1.0-waterdepth;
 #endif
-      gl_FragColor.a = 1.0;
 
-      vec3 eVec = normalize(eyeVec);
+#ifdef use_depth
+    float tz = texture2DRect(depthmap, gl_FragCoord.xy-ViewPos ).r;
+    float shallowScale = clamp( abs( convertDepthToZ(tz) - convertDepthToZ(gl_FragCoord.z) )/3.0, 0.0,1.0);
+#else
+    float shallowScale = waterdepth;
+#endif
 
-      vec3 octave4 = texture2D(normalmap,(gl_TexCoord[0].st+frame*vec2(-1.0,1.0))*40.0).rgb;
-      vec3 octave3 = texture2D(normalmap,(gl_TexCoord[0].st+frame)*100.0,-1.0).rgb;
-      vec3 octave2 = texture2D(normalmap,(gl_TexCoord[0].st-frame)*20.0,-1.0).rgb;
-      vec3 octave1 = texture2D(normalmap,(gl_TexCoord[0].st+frame)*5.0).rgb;
+    gl_FragColor.a = 1.0;
 
-      vec3 normal = (octave1+octave2+octave3+octave4)*0.5;
-      normal = normalize( normal - 1.0).xzy;
+// NORMALMAP
+    vec3 octave1 = texture2D(normalmap,gl_TexCoord[0].st).rgb;
+    vec3 octave2 = texture2D(normalmap,gl_TexCoord[1].pq).rgb;
+    vec3 octave3 = texture2D(normalmap,gl_TexCoord[2].st).rgb;
+    vec3 octave4 = texture2D(normalmap,gl_TexCoord[3].pq).rgb;
 
-      float eyeNormalCos = dot(-eVec, normal);
+    const float a = PerlinAmp;
+    octave1 = (octave1*2.0-1.0)*a;
+    octave2 = (octave2*2.0-1.0)*a*a;
+    octave3 = (octave3*2.0-1.0)*a*a*a;
+    octave4 = (octave4*2.0-1.0)*a*a*a*a;
 
-      vec3 reflectDir = reflect(normalize(-ligVec), normal);
-      float specular  = pow( max(dot(reflectDir,eVec), 0.0) , SpecularFactor);
-      float diffuse   = pow( dot(normal,SunDir) ,3.0)*0.1;
-      float ambient   = smoothstep(-1.3,0.0,eyeNormalCos);
-      vec3  waterSurface = SurfaceColor.rgb + vec3(diffuse+ambient);
+    vec3 normal = octave1+octave2+octave3+octave4;
+    normal = normalize( normal ).xzy;
+
+    vec3 eVec   = normalize(eyeVec); // wait for texture fetches
+    float eyeNormalCos = dot(-eVec, normal);
+    float angle = (1.0-abs(eyeNormalCos));
+
+
+// AMBIENT &amp; DIFFUSE
+    vec3 reflectDir   = reflect(normalize(-ligVec), normal);
+    float specular    = SpecularFactor * angle * pow( max(dot(reflectDir,eVec), 0.0) , SpecularPower) * shallowScale;
+    const vec3 SunLow = SunDir * vec3(1.0,0.1,1.0);
+    float diffuse     = pow( max( dot(normal,SunLow) ,0.0 ) ,3.0)*DiffuseFactor;
+    float ambient     = smoothstep(-1.3,0.0,eyeNormalCos)*AmbientFactor;
+    vec3 waterSurface = SurfaceColor.rgb + DiffuseColor*diffuse + vec3(ambient);
 #ifdef use_heightmap
-      float maxWaterDepth= -30.0;
-      float surfaceMix   = (SurfaceColor.a + diffuse)*(waterdepth/maxWaterDepth);
-      float refractDistortion = 60.0*(1.0-pow(gl_FragCoord.z,80.0))*(waterdepth/maxWaterDepth);
+    float maxWaterDepth= -30.0;
+    float surfaceMix   = (SurfaceColor.a + diffuse)*(waterdepth/maxWaterDepth);
+    float refractDistortion = 60.0*(1.0-pow(gl_FragCoord.z,80.0))*(waterdepth/maxWaterDepth);
 #else
-      float surfaceMix   = (SurfaceColor.a + diffuse)*(1.0-waterdepth);
-      float refractDistortion = 60.0*(1.0-pow(gl_FragCoord.z,80.0))*invwaterdepth;
+    float surfaceMix   = (SurfaceColor.a + diffuse)*shallowScale;
+    float refractDistortion = 60.0*(1.0-pow(gl_FragCoord.z,80.0))*shallowScale;
 #endif
 
+
+// REFRACTION
 #ifdef use_refraction
-      vec3 refrColor   = texture2DRect(refraction, gl_FragCoord.xy-ViewPos + normal.xz*refractDistortion ).rgb;
-      gl_FragColor.rgb = mix(waterSurface,refrColor, surfaceMix);
+    vec3 refrColor = texture2DRect(refraction, gl_FragCoord.xy-ViewPos + normal.xz*refractDistortion ).rgb;
+    gl_FragColor.rgb = mix(refrColor,waterSurface, 0.1+surfaceMix);
 #else
-      gl_FragColor.rgb = waterSurface;
-      gl_FragColor.a   = surfaceMix + specular;
+    gl_FragColor.rgb = waterSurface;
+    gl_FragColor.a   = surfaceMix + specular;
 #endif
 
+
+// CAUSTICS
 #ifdef use_heightmap
-      if ((waterdepth/maxWaterDepth)&lt;1.0) {
-        vec3 caust = texture2D(caustic,gl_TexCoord[0].st*80.0).rgb;
-        gl_FragColor.rgb = mix(gl_FragColor.rgb,refrColor+(caust*(waterdepth/maxWaterDepth)*0.22),1.0-(waterdepth/maxWaterDepth));
+    if ((waterdepth/maxWaterDepth)&lt;1.0) {
+      vec3 caust = texture2D(caustic,gl_TexCoord[0].st*80.0).rgb;
+      gl_FragColor.rgb = mix(gl_FragColor.rgb,refrColor+(caust*(waterdepth/maxWaterDepth)*0.25),1.0-(waterdepth/maxWaterDepth));
+    }
 #else
-      if (waterdepth&gt;0.0) {
-        vec3 caust = texture2D(caustic,gl_TexCoord[0].st*75.0).rgb;
+    if (waterdepth&gt;0.0) {
+      vec3 caust = texture2D(caustic,gl_TexCoord[0].st*75.0).rgb;
   #ifdef use_refraction
-        gl_FragColor.rgb = mix(gl_FragColor.rgb,refrColor+(caust*invwaterdepth)*0.22,waterdepth);
+      float caustBlend = smoothstep(CausticRange,0.0,abs(waterdepth-CausticDepth));
+      gl_FragColor.rgb += caust*caustBlend*0.08;  
   #else
-        gl_FragColor.a *= min(invwaterdepth*4.0,1.0);
-        gl_FragColor.rgb += caust*waterdepth*0.6;
+      gl_FragColor.a *= min(waterdepth*4.0,1.0);
+      gl_FragColor.rgb += caust*(1.0-waterdepth)*0.6;
   #endif
+    }
 #endif
-      }
 
-      float angle = (1.0-abs(eyeNormalCos));
 
+// SHORE WAVES
+#ifdef use_shorewaves
+    vec3 shorewavesColor = vec3(0.0);
+    float inwaterdepth = 1.0-waterdepth;
+    //if (waterdepth&lt;1.0) {
+      float coastdist = texture2D(coastmap, gl_TexCoord[0].st ).r;
+      //if (coastdist&gt;0.0 &amp;&amp; coastdist&lt;0.25) {
+        vec3 wavefoam  = texture2D(foam, gl_TexCoord[0].st*160.0+frame ).rgb;
+        wavefoam += texture2D(foam, gl_TexCoord[0].st*90.0+frame ).rgb;
+        wavefoam *= 0.5;
+
+        float fframe = fract(frame);
+        for (float i=0.0; i&lt;1.0; i+=1.0) {
+          float frac = fract(i+fframe*40.0)*1.4-0.2;
+          float f = frac-coastdist;
+          if (abs(f)&gt;WavesLength) continue;
+          float rand = texture2D(waverand, gl_TexCoord[0].st*2.0+frame+i ).r;
+          float f2 = waveIntensity( min(1.0,(WavesLength-f)*InvWavesLength) ,0.93);
+          shorewavesColor += wavefoam*f2*rand*rand;
+        }
+
+        shorewavesColor *= coastdist;
+      //}
+    //}
+    float iwd = smoothlimit(inwaterdepth, 0.8);
+    gl_FragColor.rgb += shorewavesColor*iwd*1.5;
+#endif
+
+
+// REFLECTION
 #ifdef use_reflection
-      float fresnel    = FresnelMin + FresnelMax * pow(angle,FresnelPower);
-      vec3 reflColor   = texture2D(reflection,vec2(0.0,1.0) - (gl_FragCoord.xy-ViewPos)*ScreenInverse + normal.xz*0.09).rgb;
-      gl_FragColor.rgb = mix(gl_FragColor.rgb, reflColor, fresnel);
+    float fresnel    = FresnelMin + FresnelMax * pow(angle,FresnelPower);
+    vec2 reftexcoord = vec2(0.0,1.0) - (gl_FragCoord.xy-ViewPos)*ScreenInverse - vec2(0.0,2.0*ScreenInverse.y) + normal.xz*0.09*ReflDistortion;
+    vec3 reflColor   = texture2D(reflection,reftexcoord.st).rgb;
+
+  #ifdef blur_reflection
+    const vec2 v = BlurBase;
+    const vec2 s = BlurExponent;
+    reflColor   += texture2D(reflection,reftexcoord.st+v).rgb;
+    reflColor   += texture2D(reflection,reftexcoord.st+v*s).rgb;
+    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s).rgb;
+    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s).rgb;
+    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s).rgb;
+    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s*s).rgb;
+    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s*s*s).rgb;
+    reflColor   *= 0.125;
+  #endif
+
+    gl_FragColor.rgb = mix(gl_FragColor.rgb, reflColor, fresnel*shallowScale);
 #endif
 
-      gl_FragColor.rgb += SpecularColor*specular*angle;
-    }else{ discard; }
-  }
+
+// SPECULAR
+    gl_FragColor.rgb += specular*SpecularColor;
+  }
\ No newline at end of file

Modified: trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
===================================================================
--- trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl	2008-07-08 21:15:39 UTC (rev 6124)
@@ -1,29 +1,43 @@
-/**
- * @project Spring RTS
- * @file bumpWaterVS.glsl
- * @brief An extended bumpmapping water shader
- * @author jK
- *
- * Copyright (C) 2008.  Licensed under the terms of the
- * GNU GPL, v2 or later.
- */
-
-//////////////////////////////////////////////////
-// runtime defined constants are:
-// #define MapMid vec3
-// #define SunDir vec3
-
-uniform vec3 eyePos;
-varying vec3 eyeVec;
-varying vec3 ligVec;
-
-void main(void)
-{
-	gl_Position = ftransform();
-	gl_TexCoord[0] = gl_MultiTexCoord0;
-	//gl_FrontColor  = gl_Color;
-	//gl_FrontSecondaryColor = gl_SecondaryColor;
-	eyeVec = eyePos - gl_Vertex.xyz;
-	//ligVec = normalize(lightDir*200.0 - gl_Vertex.xyz - gl_Vertex.xyz); //FIXME use map midpoint!!
-	ligVec = normalize(SunDir*20000.0 + MapMid - gl_Vertex.xyz);
-}
+/**
+ * @project Spring RTS
+ * @file bumpWaterVS.glsl
+ * @brief An extended bumpmapping water shader
+ * @author jK
+ *
+ * Copyright (C) 2008.  Licensed under the terms of the
+ * GNU GPL, v2 or later.
+ */
+
+//////////////////////////////////////////////////
+// runtime defined constants are:
+// #define MapMid           vec3
+// #define SunDir           vec3
+// #define PerlinStartFreq  float
+// #define PerlinLacunarity float
+// #define PerlinAmp        float
+
+#define Speed 12.0
+
+uniform float frame;
+uniform vec3 eyePos;
+varying vec3 eyeVec;
+varying vec3 ligVec;
+
+void main(void)
+{
+	gl_Position = ftransform();
+
+	const float fstart = PerlinStartFreq;
+	const float f      = PerlinLacunarity;
+	gl_TexCoord[0].st = (vec2(-1.0,-1.0)+gl_MultiTexCoord0.st+0.75)*fstart      +frame*Speed;
+	gl_TexCoord[1].st = (vec2(-1.0, 1.0)+gl_MultiTexCoord0.st+0.50)*fstart*f    -frame*Speed;
+	gl_TexCoord[2].st = (vec2( 1.0,-1.0)+gl_MultiTexCoord0.st+0.25)*fstart*f*f  +frame*Speed*vec2(1.0,-1.0);
+	gl_TexCoord[3].st = (vec2( 1.0, 1.0)+gl_MultiTexCoord0.st+0.00)*fstart*f*f*f+frame*Speed*vec2(-1.0,1.0);
+	gl_TexCoord[0].pq = vec2(0.0,0.0);
+	gl_TexCoord[1].pq = vec2(0.0,0.0);
+	gl_TexCoord[2].pq = vec2(0.0,0.0);
+	gl_TexCoord[3].pq = vec2(0.0,0.0);
+
+	eyeVec = eyePos - gl_Vertex.xyz;
+	ligVec = normalize(SunDir*20000.0 + MapMid - gl_Vertex.xyz);
+}

Modified: trunk/rts/Game/Camera.cpp
===================================================================
--- trunk/rts/Game/Camera.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Game/Camera.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -52,6 +52,7 @@
 
 CCamera::~CCamera()
 {
+	glDeleteLists(billboardList,1);
 }
 
 

Modified: trunk/rts/Lua/LuaMaterial.cpp
===================================================================
--- trunk/rts/Lua/LuaMaterial.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Lua/LuaMaterial.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -332,11 +332,10 @@
 	}
 
 	const int maxTex = std::max(texCount, prev.texCount);
-	for (int t = 0; t &lt; maxTex; t++) {
+	for (int t = maxTex-1; t &gt;= 0; t--) {
 		glActiveTexture(GL_TEXTURE0 + t);
 		textures[t].Execute(prev.textures[t]);
 	}
-	glActiveTexture(GL_TEXTURE0);
 
 	if (useCamera != prev.useCamera) {
 		if (useCamera) {

Modified: trunk/rts/Map/MapInfo.cpp
===================================================================
--- trunk/rts/Map/MapInfo.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Map/MapInfo.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -164,19 +164,32 @@
 	water.baseColor = wt.GetFloat3(&quot;baseColor&quot;, float3(0.0f, 0.0f, 0.0f));
 	water.minColor  = wt.GetFloat3(&quot;minColor&quot;,  float3(0.0f, 0.0f, 0.0f));
 
-	water.surfaceColor = wt.GetFloat3(&quot;surfaceColor&quot;, float3(0.75f, 0.8f, 0.85f));
-	water.surfaceAlpha = wt.GetFloat(&quot;surfaceAlpha&quot;,  0.55f);
+	water.ambientFactor = wt.GetFloat(&quot;ambientFactor&quot;, 1.0f);
+	water.diffuseFactor = wt.GetFloat(&quot;diffuseFactor&quot;, 1.0f);
+	water.specularFactor= wt.GetFloat(&quot;specularFactor&quot;,1.0f);
+	water.specularPower = wt.GetFloat(&quot;specularPower&quot;, 20.0f);
 
 	water.planeColor = wt.GetFloat3(&quot;planeColor&quot;, float3(0.0f, 0.4f, 0.0f));
 	hasWaterPlane    = wt.KeyExists(&quot;planeColor&quot;);
 
-	water.specularColor  = wt.GetFloat3(&quot;specularColor&quot;, light.groundSunColor);
-	water.specularFactor = wt.GetFloat(&quot;specularFactor&quot;, 20.0f);
+	water.surfaceColor  = wt.GetFloat3(&quot;surfaceColor&quot;, float3(0.75f, 0.8f, 0.85f));
+	water.surfaceAlpha  = wt.GetFloat(&quot;surfaceAlpha&quot;,  0.55f);
+	water.diffuseColor  = wt.GetFloat3(&quot;diffuseColor&quot;,  float3(1.0f, 1.0f, 1.0f));
+	water.specularColor = wt.GetFloat3(&quot;specularColor&quot;, light.groundSunColor);
 
 	water.fresnelMin   = wt.GetFloat(&quot;fresnelMin&quot;,   0.2f);
-	water.fresnelMax   = wt.GetFloat(&quot;fresnelMax&quot;,   0.3f);
+	water.fresnelMax   = wt.GetFloat(&quot;fresnelMax&quot;,   0.7f);
 	water.fresnelPower = wt.GetFloat(&quot;fresnelPower&quot;, 4.0f);
 
+	water.reflDistortion = wt.GetFloat(&quot;reflectionDistortion&quot;, 1.0f);
+
+	water.blurBase     = wt.GetFloat(&quot;blurBase&quot;, 2.0f);
+	water.blurExponent = wt.GetFloat(&quot;blurExponent&quot;, 1.5f);
+
+	water.perlinStartFreq  = wt.GetFloat(&quot;perlinStartFreq&quot;,  8.0f);
+	water.perlinLacunarity = wt.GetFloat(&quot;perlinLacunarity&quot;, 3.0f);
+	water.perlinAmplitude  = wt.GetFloat(&quot;perlinAmplitude&quot;,  0.9f);
+
 	water.texture       = wt.GetString(&quot;texture&quot;,       &quot;&quot;);
 	water.foamTexture   = wt.GetString(&quot;foamTexture&quot;,   &quot;&quot;);
 	water.normalTexture = wt.GetString(&quot;normalTexture&quot;, &quot;&quot;);

Modified: trunk/rts/Map/MapInfo.h
===================================================================
--- trunk/rts/Map/MapInfo.h	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Map/MapInfo.h	2008-07-08 21:15:39 UTC (rev 6124)
@@ -114,13 +114,23 @@
 		float3 baseColor;
 		float3 minColor;
 		float3 surfaceColor;
-		float surfaceAlpha;
+		float  surfaceAlpha;
 		float3 planeColor;
+		float3 diffuseColor;
 		float3 specularColor;
-		float specularFactor;
-		float fresnelMin;
-		float fresnelMax;
-		float fresnelPower;
+		float  ambientFactor;
+		float  diffuseFactor;
+		float  specularFactor;
+		float  specularPower;
+		float  fresnelMin;
+		float  fresnelMax;
+		float  fresnelPower;
+		float  reflDistortion;
+		float  blurBase;
+		float  blurExponent;
+		float  perlinStartFreq;
+		float  perlinLacunarity;
+		float  perlinAmplitude;
 		std::string texture;
 		std::string foamTexture;
 		std::string normalTexture;

Modified: trunk/rts/Map/ReadMap.h
===================================================================
--- trunk/rts/Map/ReadMap.h	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Map/ReadMap.h	2008-07-08 21:15:39 UTC (rev 6124)
@@ -50,7 +50,7 @@
 	float* orgheightmap;
 	float* centerheightmap;
 	static const int numHeightMipMaps = 7;	//number of heightmap mipmaps, including full resolution
-	float* mipHeightmap[numHeightMipMaps];	//array of pointers to heightmap in diferent resolution, mipHeightmap[0] is full resolution, mipHeightmap[n+1] is half resolution of mipHeightmap[n]
+	float* mipHeightmap[numHeightMipMaps];	//array of pointers to heightmap in different resolutions, mipHeightmap[0] is full resolution, mipHeightmap[n+1] is half resolution of mipHeightmap[n]
 	float* slopemap;
 	float3* facenormals;
 	unsigned char* typemap;

Modified: trunk/rts/Map/SMF/BFGroundTextures.cpp
===================================================================
--- trunk/rts/Map/SMF/BFGroundTextures.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Map/SMF/BFGroundTextures.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -18,7 +18,7 @@
 {
 	usePBO = false;
 	if (GLEW_EXT_pixel_buffer_object &amp;&amp; rm-&gt;usePBO) {
-		glGenBuffers(30, pboIDs);
+		glGenBuffers(10, pboIDs);
 		currentPBO=0;
 		usePBO = true;
 	}
@@ -110,17 +110,20 @@
 			LoadSquare(x, y, 2);
 		}
 	}
-
-	inRead = false;
 }
 
 CBFGroundTextures::~CBFGroundTextures(void)
 {
+	for (int i = 0; i &lt; numBigTexX * numBigTexY; ++i) {
+		glDeleteTextures(1, &amp;squares[i].texture);
+	}
+
 	delete[] squares;
 	delete[] tileMap;
 	delete[] tiles;
+
 	if (usePBO) {
-		glDeleteBuffers(30,pboIDs);
+		glDeleteBuffers(10,pboIDs);
 	}
 }
 
@@ -149,16 +152,9 @@
 
 void CBFGroundTextures::DrawUpdate(void)
 {
-	float maxDif = 0;
-	float totalDif = 0;
-	int maxX;
-	int maxY;
-	int wantedNew;
-	int currentReadWantedLevel;
-
 	for (int y = 0; y &lt; numBigTexY; ++y) {
-		float dy = cam2-&gt;pos.z - y * bigSquareSize * SQUARE_SIZE - 64 * SQUARE_SIZE;
-		dy = max(0.0f, float(fabs(dy) - 64.0f * SQUARE_SIZE));
+		float dy = cam2-&gt;pos.z - y * bigSquareSize * SQUARE_SIZE - (SQUARE_SIZE &lt;&lt; 6);
+		dy = max(0.0f, float(fabs(dy) - (SQUARE_SIZE &lt;&lt; 6)));
 
 		for (int x = 0; x &lt; numBigTexX; ++x) {
 			if (!TexSquareInView(x, y)) {
@@ -169,8 +165,8 @@
 
 			GroundSquare* square = &amp;squares[y * numBigTexX + x];
 
-			float dx = cam2-&gt;pos.x - x * bigSquareSize * SQUARE_SIZE - 64 * SQUARE_SIZE;
-			dx = max(0.0f, float(fabs(dx) - 64.0f * SQUARE_SIZE));
+			float dx = cam2-&gt;pos.x - x * bigSquareSize * SQUARE_SIZE - (SQUARE_SIZE &lt;&lt; 6);
+			dx = max(0.0f, float(fabs(dx) - (SQUARE_SIZE &lt;&lt; 6)));
 			float dist = fastmath::sqrt(dx * dx + dy * dy);
 
 			if (square-&gt;lastUsed &lt; gs-&gt;frameNum - 60)
@@ -183,26 +179,6 @@
 			if (wantedLevel &lt; square-&gt;texLevel - 1)
 				wantedLevel = square-&gt;texLevel - 1;
 
-			float dif = square-&gt;texLevel + 0.5f - wantedLevel;
-			if (dif &lt; 0)
-				dif *= -0.5f;
-
-			if ((int) wantedLevel != square-&gt;texLevel) {
-				if (dist &lt; 8)
-					dif += 5;
-
-				totalDif += dif;
-
-				if (dif &gt; maxDif) {
-					maxDif = dif;
-					maxX = x;
-					maxY = y;
-					wantedNew = (int) wantedLevel;
-				}
-			}
-			if (inRead &amp;&amp; x == readX &amp;&amp; y == readY) {
-				currentReadWantedLevel = (int) wantedLevel;
-			}
 			if (square-&gt;texLevel != (int) wantedLevel) {
 				glDeleteTextures(1, &amp;square-&gt;texture);
 				LoadSquare(x, y, (int) wantedLevel);
@@ -220,9 +196,8 @@
 	GLubyte* buf=NULL; bool usedPBO=false;
 
 	if (usePBO) {
-		if (currentPBO &gt; 29) currentPBO=0;
+		if (currentPBO &gt; 9) currentPBO=0;
 		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboIDs[currentPBO++]);
-
 		glBufferData(GL_PIXEL_UNPACK_BUFFER, size * size / 2, 0, GL_STREAM_DRAW);
 
 		//map the buffer object into client's memory
@@ -246,13 +221,12 @@
 
 			for (int yt = 0; yt &lt; numblocks; yt++) {
 				for (int xt = 0; xt &lt; numblocks; xt++) {
-					GLfloat* sbuf = (GLfloat*)&amp;tile[(xt + yt * numblocks) * 8];
-					GLfloat* dbuf = (GLfloat*)&amp;buf[(x1 * numblocks + xt + (y1 * numblocks + yt) * (numblocks * 32)) * 8];
+					GLint* sbuf = (GLint*)&amp;tile[(xt + yt * numblocks) * 8];
+					GLint* dbuf = (GLint*)&amp;buf[(x1 * numblocks + xt + (y1 * numblocks + yt) * (numblocks * 32)) * 8];
 
-					//copy 4 bytes at once
-					for (int i = 0; i &lt; 2; i++) {
-						dbuf[i] = sbuf[i];
-					}
+					//copy 2x 4 bytes at once
+					dbuf[0] = sbuf[0];
+					dbuf[1] = sbuf[1];
 				}
 			}
 		}
@@ -260,10 +234,13 @@
 
 	glGenTextures(1, &amp;square-&gt;texture);
 	glBindTexture(GL_TEXTURE_2D, square-&gt;texture);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, 1);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	if (GLEW_EXT_texture_edge_clamp) {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	}
 	if (map-&gt;anisotropy != 0.0f)
 		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, map-&gt;anisotropy);
 

Modified: trunk/rts/Map/SMF/BFGroundTextures.h
===================================================================
--- trunk/rts/Map/SMF/BFGroundTextures.h	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Map/SMF/BFGroundTextures.h	2008-07-08 21:15:39 UTC (rev 6124)
@@ -35,25 +35,15 @@
 
 	GroundSquare* squares;
 
-	// variables controlling background reading of textures
-	bool inRead;
-	int readProgress;
-	int readX;
-	int readY;
-	GroundSquare* readSquare;
-	int readLevel;
-	unsigned char* readBuffer;
-	unsigned char* readTempLine;
-
 	int* tileMap;
 	int tileSize;
 	char* tiles;
 	int tileMapXSize;
 	int tileMapYSize;
 
-	// use Pixel Buffer Objects for async. uploading (DMA)?
+	//! use Pixel Buffer Objects for async. uploading (DMA)?
 	bool usePBO;
-	GLuint pboIDs[30];
+	GLuint pboIDs[10];
 	int currentPBO;
 
 	float anisotropy;

Modified: trunk/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- trunk/rts/Map/SMF/SmfReadMap.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Map/SMF/SmfReadMap.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -72,7 +72,7 @@
 	float3::maxxpos=gs-&gt;mapx*SQUARE_SIZE-1;
 	float3::maxzpos=gs-&gt;mapy*SQUARE_SIZE-1;
 
-	heightmap=SAFE_NEW float[(gs-&gt;mapx+1)*(gs-&gt;mapy+1)];//SAFE_NEW float[(gs-&gt;mapx+1)*(gs-&gt;mapy+1)];
+	heightmap=SAFE_NEW float[(gs-&gt;mapx+1)*(gs-&gt;mapy+1)];
 
 	//CFileHandler ifs((string(&quot;maps/&quot;)+stupidGlobalMapname).c_str());
 

Modified: trunk/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Rendering/Env/BumpWater.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -13,6 +13,7 @@
 #include &quot;BumpWater.h&quot;
 #include &quot;Game/Game.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/IFramebuffer.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Map/MapInfo.h&quot;
@@ -23,6 +24,7 @@
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &lt;boost/format.hpp&gt;
@@ -34,8 +36,18 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-static void PrintLog(GLuint obj)
+static void PrintShaderLog(GLuint obj)
 {
+	// WAS COMPILATION SUCCESSFUL ?
+	GLint compiled;
+	if(glIsShader(obj))
+		glGetShaderiv(obj,GL_COMPILE_STATUS,&amp;compiled);
+	else
+		glGetProgramiv(obj,GL_COMPILE_STATUS,&amp;compiled);
+
+	if (compiled) return;
+
+	// GET INFOLOG
 	int infologLength = 0;
 	int maxLength;
 
@@ -54,41 +66,41 @@
 	if (infologLength &gt; 0) {
 		string str(infoLog, infologLength);
 		delete[] infoLog;
-		throw content_error(string(&quot;BumpWater shader error: &quot; + str));
+		logOutput.Print(&quot;BumpWater shader error: &quot; + str); //string size is limited with content_error()
+		throw content_error(string(&quot;BumpWater shader error!&quot;));
 	}
-
 	delete[] infoLog;
 }
 
 
-void PrintFboError(GLenum error)
+static void PrintFboError(string fbo, GLenum error)
 {
 	switch(error) {
 		case GL_FRAMEBUFFER_COMPLETE_EXT:
 			break;
 		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: missing a required image/buffer attachment!&quot;);
+			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)has no images/buffers attached!&quot;);
 			break;
 		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: has no images/buffers attached!&quot;);
+			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)missing a required image/buffer attachment!&quot;);
 			break;
 		case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: has mismatched image/buffer dimensions!&quot;);
+			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)has mismatched image/buffer dimensions!&quot;);
 			break;
 		case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: colorbuffer attachments have different types!&quot;);
+			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)colorbuffer attachments have different types!&quot;);
 			break;
 		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: trying to draw to non-attached color buffer!&quot;);
+			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)incomplete draw buffers!&quot;);
 			break;
 		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: trying to read from a non-attached color buffer!&quot;);
+			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)trying to read from a non-attached color buffer!&quot;);
 			break;
 		case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: format is not supported by current graphics card/driver!&quot;);
+			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)format is not supported by current graphics card/driver!&quot;);
 			break;
 		default:
-			logOutput.Print(&quot;BumpWater-FBO: *UNKNOWN ERROR*&quot;);
+			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)*UNKNOWN ERROR*&quot;);
 			break;
 	}
 }
@@ -98,15 +110,9 @@
 	CFileHandler fh(file);
 	if (!fh.FileExists())
 		throw content_error(&quot;Can't load shader &quot; + file);
-
 	string text;
 	text.resize(fh.FileSize());
-	//char* cstr = SAFE_NEW char[fh.FileSize()+1];
-
 	fh.Read(&amp;text[0], text.length());
-	//fh.Read(cstr,fh.FileSize());
-	//cstr[fh.FileSize()] = 0;
-
 	return text;
 }
 
@@ -130,7 +136,7 @@
 	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; %1$.12f\n&quot;) % x);
 }
 
-static GLuint LoadTexture(const string&amp; filename)
+static GLuint LoadTexture(const string&amp; filename, const float anisotropy = 0.0f)
 {
 	GLuint texID;
 	CBitmap bm;
@@ -141,29 +147,54 @@
 	glBindTexture(GL_TEXTURE_2D, texID);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
-	//glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 3.0f);
-	glBuildMipmaps(GL_TEXTURE_2D, GLEW_ARB_texture_compression?GL_COMPRESSED_RGB_ARB:GL_RGB8, bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+	if (anisotropy &gt; 0.0f)
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
+	glBuildMipmaps(GL_TEXTURE_2D, GLEW_ARB_texture_compression?GL_COMPRESSED_RGBA_ARB:GL_RGBA8, bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
 	return texID;
 }
 
 CBumpWater::CBumpWater()
 {
+	/** LOAD USER CONFIGS **/
 	reflTexSize = next_power_of_2(configHandler.GetInt(&quot;BumpWaterTexSizeReflection&quot;, 256));
-	reflection = !!configHandler.GetInt(&quot;BumpWaterReflection&quot;, 1);
-	refraction = configHandler.GetInt(&quot;BumpWaterRefraction&quot;, 1);  //0:=off, 1:=screencopy, 2:=own rendering cycle
-	waves = !!configHandler.GetInt(&quot;BumpBeachWaves&quot;, 1);
+	reflection  = !!configHandler.GetInt(&quot;BumpWaterReflection&quot;, 1);
+	refraction  = configHandler.GetInt(&quot;BumpWaterRefraction&quot;, 1);  //0:=off, 1:=screencopy, 2:=own rendering cycle
+	shorewaves  = !!configHandler.GetInt(&quot;BumpWaterShoreWaves&quot;, 0);
+	anisotropy  = atof(configHandler.GetString(&quot;BumpWaterAnisotropy&quot;, &quot;0.0&quot;).c_str());
+	depthCopy   = !!configHandler.GetInt(&quot;BumpWaterUseDepthTexture&quot;, 1);
+	depthBits   = configHandler.GetInt(&quot;BumpWaterDepthBits&quot;, 24);
+	blurRefl    = !!configHandler.GetInt(&quot;BumpWaterBlurReflection&quot;, 0);
 
-	if (!GLEW_EXT_framebuffer_object) {
-		reflection = false;
+	if (refraction&gt;1)
+		drawSolid = true;
+
+
+	/** CHECK HARDWARE **/
+	if (!GL_ARB_shading_language_100)
+		throw content_error(&quot;BumpWater: your hardware/driver setup does not support GLSL.&quot;);
+
+	if (!(GLEW_ARB_texture_rectangle || GLEW_EXT_texture_rectangle))
+		refraction = 0;
+
+	shorewaves = shorewaves &amp;&amp; (GLEW_EXT_framebuffer_object);
+
+
+	/** CREATE TEXTURES **/
+	if (refraction&gt;0 || depthCopy) {
+		if(GLEW_ARB_texture_rectangle || GLEW_EXT_texture_rectangle) {
+			target = GL_TEXTURE_RECTANGLE_ARB;
+			screenTextureX = gu-&gt;viewSizeX;
+			screenTextureY = gu-&gt;viewSizeY;
+		}else{
+			target = GL_TEXTURE_2D;
+			screenTextureX = next_power_of_2(gu-&gt;viewSizeX);
+			screenTextureY = next_power_of_2(gu-&gt;viewSizeY);
+		}
 	}
 
 	if (refraction&gt;0) {
 		// CREATE REFRACTION TEXTURE
 		glGenTextures(1, &amp;refractTexture);
-		//if(GLEW_ARB_texture_non_power_of_two || GLEW_EXT_texture_non_power_of_two)
-		//	target = GL_TEXTURE_2D;
-		//else //if(GLEW_ARB_texture_rectangle || GLEW_EXT_texture_rectangle)
-			target = GL_TEXTURE_RECTANGLE_ARB;
 		glBindTexture(target, refractTexture);
 		glTexParameteri(target,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
 		glTexParameteri(target,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
@@ -174,14 +205,7 @@
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 		}
-		if(target == GL_TEXTURE_RECTANGLE_ARB) {
-			refrSizeX = gu-&gt;viewSizeX;
-			refrSizeY = gu-&gt;viewSizeY;
-		} else{
-			refrSizeX = next_power_of_2(gu-&gt;viewSizeX);
-			refrSizeY = next_power_of_2(gu-&gt;viewSizeY);
-		}
-		glTexImage2D(target, 0, GL_RGB8, refrSizeX, refrSizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
+		glTexImage2D(target, 0, GL_RGBA8, screenTextureX, screenTextureY, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
 	}
 
 	if (reflection) {
@@ -198,29 +222,76 @@
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 		}
 		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, reflTexSize, reflTexSize, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+	}
 
-		// CREATE DEPTH RBO FOR REFLECTION FBO
-		glGenRenderbuffersEXT(1, &amp;rbo);
-		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbo);
-		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT32, reflTexSize, reflTexSize);
+	if (depthCopy) {
+		glGenTextures(1, &amp;depthTexture);
+		glBindTexture(target, depthTexture);
+		glTexParameteri(target,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+		glTexParameteri(target,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+		GLuint depthFormat = GL_DEPTH_COMPONENT;
+		switch (gu-&gt;depthBufferBits) {
+			case 16: depthFormat = GL_DEPTH_COMPONENT16; break;
+			case 24: depthFormat = GL_DEPTH_COMPONENT24; break;
+			case 32: depthFormat = GL_DEPTH_COMPONENT32; break;
+		}
+		glTexImage2D(target, 0, depthFormat, screenTextureX, screenTextureY, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
+	}
 
-		// CREATE REFLECTION FBO AND BIND TEXTURE&amp;RBO
-		glGenFramebuffersEXT(1,&amp;fbo);
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo);
-		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, reflectTexture, 0);
-		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, rbo);
-		GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-		if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-			PrintFboError(status);
-			//logOutput.Print(&quot;BumpWater: FBO not ready&quot;);
+
+	/** CREATE FBOs **/
+	if (GLEW_EXT_framebuffer_object) {
+		GLuint depthRBOFormat = GL_DEPTH_COMPONENT;
+		switch (depthBits) {
+			case 16: depthRBOFormat = GL_DEPTH_COMPONENT16; break;
+			case 24: depthRBOFormat = GL_DEPTH_COMPONENT24; break;
+			case 32: depthRBOFormat = GL_DEPTH_COMPONENT32; break;
 		}
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+		if (reflection) {
+			glGenRenderbuffersEXT(1, &amp;reflectRBO);
+			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, reflectRBO);
+			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, depthRBOFormat, reflTexSize, reflTexSize);
+
+			glGenFramebuffersEXT(1,&amp;reflectFBO);
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
+			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, reflectRBO);
+			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, reflectTexture, 0);
+			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
+				PrintFboError(&quot;reflection&quot;,status);
+				glDeleteRenderbuffersEXT(1, &amp;reflectRBO);
+				glDeleteFramebuffersEXT(1,  &amp;reflectFBO);
+				reflectFBO = 0;
+			}
+		}
+
+		if (refraction&gt;0) {
+			glGenRenderbuffersEXT(1, &amp;refractRBO);
+			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, refractRBO);
+			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, depthRBOFormat, screenTextureX, screenTextureY);
+
+			glGenFramebuffersEXT(1,&amp;refractFBO);
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, refractFBO);
+			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, refractRBO);
+			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, target, refractTexture, 0);
+			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
+				PrintFboError(&quot;refraction&quot;,status);
+				glDeleteRenderbuffersEXT(1, &amp;refractRBO);
+				glDeleteFramebuffersEXT(1,  &amp;refractFBO);
+				refractFBO = 0;
+			}
+		}
+
 	}
 
 
-	foamTexture = LoadTexture(mapInfo-&gt;water.foamTexture);
-	normalTexture = LoadTexture(mapInfo-&gt;water.normalTexture);
-	//heightTexture = readmap-&gt;GetShadingTexture();
+	/** LOAD TEXTURES **/
+	foamTexture     = LoadTexture( mapInfo-&gt;water.foamTexture );
+	normalTexture   = LoadTexture( mapInfo-&gt;water.normalTexture , anisotropy );
 
 	// caustic textures
 	const vector&lt;string&gt;&amp; causticNames = mapInfo-&gt;water.causticTextures;
@@ -231,82 +302,133 @@
 		caustTextures.push_back(LoadTexture(causticNames[i]));
 	}
 
-	/* DEFINE SOME RUNTIME CONSTANTS (I don't use Uniforms for that, 'cos the glsl compiler can't optimize those!) */
+	if (shorewaves) {
+		waveRandTexture = LoadTexture( &quot;bitmaps/shorewaverand.bmp&quot; );
+
+		const GLchar* fsSource = LoadShaderSource(&quot;shaders/bumpWaterCoastBlurFS.glsl&quot;).c_str();
+		blurFP = glCreateShader(GL_FRAGMENT_SHADER);
+		glShaderSource(blurFP, 1, &amp;fsSource, NULL);
+		glCompileShader(blurFP);
+		PrintShaderLog(blurFP);
+
+		blurShader = glCreateProgram();
+		glAttachShader(blurShader, blurFP);
+		glLinkProgram(blurShader);
+		PrintShaderLog(blurShader);
+		blurDirLoc    = glGetUniformLocation(blurShader, &quot;blurDir&quot;);
+		GLuint texLoc = glGetUniformLocation(blurShader, &quot;tex0&quot;);
+		glUniform1i(texLoc, 0);
+
+		glGenFramebuffersEXT(1,&amp;coastFBO);
+		GenerateCoastMap();
+	}
+
+
+	/** DEFINE SOME SHADER RUNTIME CONSTANTS (I don't use Uniforms for that, because the glsl compiler can't optimize those!) **/
 	string definitions;
 	if (reflection)   definitions += &quot;#define use_reflection\n&quot;;
-	if (refraction&gt;0) definitions += &quot;#define use_refraction\n\n&quot;;
-	GLSLDefineConstf4(definitions, &quot;SurfaceColor&quot;, mapInfo-&gt;water.surfaceColor*0.4, mapInfo-&gt;water.surfaceAlpha );
-	GLSLDefineConstf3(definitions, &quot;SpecularColor&quot;, mapInfo-&gt;water.specularColor );
-	GLSLDefineConstf1(definitions, &quot;SpecularFactor&quot;, mapInfo-&gt;water.specularFactor);
-	GLSLDefineConstf3(definitions, &quot;SunDir&quot;, mapInfo-&gt;light.sunDir );
-	GLSLDefineConstf3(definitions, &quot;MapMid&quot;, float3(readmap-&gt;width*SQUARE_SIZE*0.5f,0.0f,readmap-&gt;height*SQUARE_SIZE*0.5f) );
-	GLSLDefineConstf2(definitions, &quot;ScreenInverse&quot;, -1.0f/gu-&gt;viewSizeX, 1.0f/gu-&gt;viewSizeY );
-	GLSLDefineConstf2(definitions, &quot;ViewPos&quot;, gu-&gt;viewPosX,gu-&gt;viewPosY );
-	GLSLDefineConstf1(definitions, &quot;FresnelMin&quot;,  mapInfo-&gt;water.fresnelMin);
-	GLSLDefineConstf1(definitions, &quot;FresnelMax&quot;,  mapInfo-&gt;water.fresnelMax);
-	GLSLDefineConstf1(definitions, &quot;FresnelPower&quot;, mapInfo-&gt;water.fresnelPower);
+	if (refraction&gt;0) definitions += &quot;#define use_refraction\n&quot;;
+	if (shorewaves)   definitions += &quot;#define use_shorewaves\n&quot;;
+	if (depthCopy)    definitions += &quot;#define use_depth\n&quot;;
+	if (blurRefl)     definitions += &quot;#define blur_reflection\n&quot;;
+	GLSLDefineConstf4(definitions, &quot;SurfaceColor&quot;,   mapInfo-&gt;water.surfaceColor*0.4, mapInfo-&gt;water.surfaceAlpha );
+	GLSLDefineConstf4(definitions, &quot;PlaneColor&quot;,     mapInfo-&gt;water.planeColor*0.4, mapInfo-&gt;water.surfaceAlpha );
+	GLSLDefineConstf3(definitions, &quot;DiffuseColor&quot;,   mapInfo-&gt;water.diffuseColor );
+	GLSLDefineConstf3(definitions, &quot;SpecularColor&quot;,  mapInfo-&gt;water.specularColor );
+	GLSLDefineConstf1(definitions, &quot;SpecularPower&quot;,  mapInfo-&gt;water.specularPower );
+	GLSLDefineConstf1(definitions, &quot;SpecularFactor&quot;, mapInfo-&gt;water.specularFactor );
+	GLSLDefineConstf1(definitions, &quot;AmbientFactor&quot;,  mapInfo-&gt;water.ambientFactor );
+	GLSLDefineConstf1(definitions, &quot;DiffuseFactor&quot;,  mapInfo-&gt;water.diffuseFactor*15.0f );
+	GLSLDefineConstf3(definitions, &quot;SunDir&quot;,         mapInfo-&gt;light.sunDir );
+	GLSLDefineConstf3(definitions, &quot;MapMid&quot;,         float3(readmap-&gt;width*SQUARE_SIZE*0.5f,0.0f,readmap-&gt;height*SQUARE_SIZE*0.5f) );
+	GLSLDefineConstf2(definitions, &quot;ScreenInverse&quot;,  -1.0f/gu-&gt;viewSizeX, 1.0f/gu-&gt;viewSizeY );
+	GLSLDefineConstf2(definitions, &quot;ViewPos&quot;,        gu-&gt;viewPosX,gu-&gt;viewPosY );
+	GLSLDefineConstf1(definitions, &quot;FresnelMin&quot;,     mapInfo-&gt;water.fresnelMin);
+	GLSLDefineConstf1(definitions, &quot;FresnelMax&quot;,     mapInfo-&gt;water.fresnelMax);
+	GLSLDefineConstf1(definitions, &quot;FresnelPower&quot;,   mapInfo-&gt;water.fresnelPower);
+	GLSLDefineConstf1(definitions, &quot;ReflDistortion&quot;, mapInfo-&gt;water.reflDistortion);
+	GLSLDefineConstf2(definitions, &quot;BlurBase&quot;,       0.0f,mapInfo-&gt;water.blurBase/gu-&gt;viewSizeY);
+	GLSLDefineConstf1(definitions, &quot;BlurExponent&quot;,   mapInfo-&gt;water.blurExponent);
+	GLSLDefineConstf1(definitions, &quot;PerlinStartFreq&quot;,  mapInfo-&gt;water.perlinStartFreq);
+	GLSLDefineConstf1(definitions, &quot;PerlinLacunarity&quot;, mapInfo-&gt;water.perlinLacunarity);
+	GLSLDefineConstf1(definitions, &quot;PerlinAmp&quot;,        mapInfo-&gt;water.perlinAmplitude);
 
-	/* LOAD SHADERS */
+	/** LOAD SHADERS **/
 	string vsSource = LoadShaderSource(&quot;shaders/bumpWaterVS.glsl&quot;);
 	string fsSource = LoadShaderSource(&quot;shaders/bumpWaterFS.glsl&quot;);
 
 	vector&lt;GLint&gt; lengths(2);
 	vector&lt;const GLchar*&gt; strings(2);
-	lengths[0]=definitions.length();
-	strings[0]=definitions.c_str();
+	lengths[0] = definitions.length();
+	strings[0] = definitions.c_str();
 
 	waterVP = glCreateShader(GL_VERTEX_SHADER);
-	lengths[1]=vsSource.length();
-	strings[1]=vsSource.c_str();
+	lengths[1] = vsSource.length();
+	strings[1] = vsSource.c_str();
 	glShaderSource(waterVP, strings.size(), &amp;strings.front(), &amp;lengths.front());
 	glCompileShader(waterVP);
-	PrintLog(waterVP);
+	PrintShaderLog(waterVP);
 
 	waterFP = glCreateShader(GL_FRAGMENT_SHADER);
-	lengths[1]= fsSource.length();
+	lengths[1] = fsSource.length();
 	strings[1] = fsSource.c_str();
 	glShaderSource(waterFP, strings.size(), &amp;strings.front(), &amp;lengths.front());
 	glCompileShader(waterFP);
-	PrintLog(waterFP);
+	PrintShaderLog(waterFP);
 
-	//delete vsSource; delete fsSource;
-
 	waterShader = glCreateProgram();
 	glAttachShader(waterShader, waterVP);
 	glAttachShader(waterShader, waterFP);
 	glLinkProgram(waterShader);
-	PrintLog(waterShader);
+	PrintShaderLog(waterShader);
 
-	/* BIND TEXTURE UNIFORMS */
+
+	/** BIND TEXTURE UNIFORMS **/
 	glUseProgram(waterShader);
 		eyePosLoc     = glGetUniformLocation(waterShader, &quot;eyePos&quot;);
 		frameLoc      = glGetUniformLocation(waterShader, &quot;frame&quot;);
-		normalmapLoc  = glGetUniformLocation(waterShader, &quot;normalmap&quot;);
-		heightmapLoc  = glGetUniformLocation(waterShader, &quot;heightmap&quot;);
-		causticLoc    = glGetUniformLocation(waterShader, &quot;caustic&quot;);
-		foamLoc       = glGetUniformLocation(waterShader, &quot;foam&quot;);
-		reflectionLoc = glGetUniformLocation(waterShader, &quot;reflection&quot;);
-		refractionLoc = glGetUniformLocation(waterShader, &quot;refraction&quot;);
 
+		GLuint normalmapLoc  = glGetUniformLocation(waterShader, &quot;normalmap&quot;);
+		GLuint heightmapLoc  = glGetUniformLocation(waterShader, &quot;heightmap&quot;);
+		GLuint causticLoc    = glGetUniformLocation(waterShader, &quot;caustic&quot;);
+		GLuint foamLoc       = glGetUniformLocation(waterShader, &quot;foam&quot;);
+		GLuint reflectionLoc = glGetUniformLocation(waterShader, &quot;reflection&quot;);
+		GLuint refractionLoc = glGetUniformLocation(waterShader, &quot;refraction&quot;);
+		GLuint depthmapLoc   = glGetUniformLocation(waterShader, &quot;depthmap&quot;);
+		GLuint coastmapLoc   = glGetUniformLocation(waterShader, &quot;coastmap&quot;);
+		GLuint waverandLoc   = glGetUniformLocation(waterShader, &quot;waverand&quot;);
+
 		glUniform1i(normalmapLoc, 0);
 		glUniform1i(heightmapLoc, 1);
 		glUniform1i(causticLoc, 2);
 		glUniform1i(foamLoc, 3);
 		glUniform1i(reflectionLoc, 4);
 		glUniform1i(refractionLoc, 5);
+		glUniform1i(coastmapLoc, 6);
+		glUniform1i(depthmapLoc, 7);
+		glUniform1i(waverandLoc, 8);
 	glUseProgram(0);
 }
 
 CBumpWater::~CBumpWater()
 {
-	if (reflection) {
+	if (reflection)
 		glDeleteTextures(1, &amp;reflectTexture);
-		glDeleteRenderbuffersEXT(1, &amp;rbo);
-		glDeleteFramebuffersEXT(1, &amp;fbo);
-	}
 	if (refraction&gt;0)
 		glDeleteTextures(1, &amp;refractTexture);
+	if (depthCopy)
+		glDeleteTextures(1, &amp;depthTexture);
 
+	if (reflectFBO) {
+		glDeleteRenderbuffersEXT(1, &amp;reflectRBO);
+		glDeleteFramebuffersEXT(1,  &amp;reflectFBO);
+	}
+
+	if (refractFBO) {
+		glDeleteRenderbuffersEXT(1, &amp;refractRBO);
+		glDeleteFramebuffersEXT(1,  &amp;refractFBO);
+	}
+
 	glDeleteTextures(1, &amp;foamTexture);
 	glDeleteTextures(1, &amp;normalTexture);
 	for (int i = 0; i &lt; (int)caustTextures.size(); i++) {
@@ -316,11 +438,124 @@
 	glDeleteShader(waterVP);
 	glDeleteShader(waterFP);
 	glDeleteProgram(waterShader);
+
+	if (shorewaves) {
+		glDeleteTextures(1, &amp;coastTexture);
+		glDeleteTextures(1, &amp;waveRandTexture);
+
+		if (coastFBO)
+			glDeleteFramebuffersEXT(1,  &amp;coastFBO);
+
+		glDeleteShader(blurFP);
+		glDeleteProgram(blurShader);
+	}
 }
 
+
+void CBumpWater::GenerateCoastMap()
+{
+	/*GLfloat* normalmap = SAFE_NEW GLfloat[gs-&gt;mapx*gs-&gt;mapy*4];
+	for (int y = 0; y &lt; gs-&gt;mapy; y++) {
+		for (int x = 0; x &lt; gs-&gt;mapx; x++) {
+			float3&amp; normal = readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2];
+			normalmap[(y*gs-&gt;mapx+x)*4]   = normal.x;
+			normalmap[(y*gs-&gt;mapx+x)*4+1] = normal.y;
+			normalmap[(y*gs-&gt;mapx+x)*4+2] = normal.z;
+			normalmap[(y*gs-&gt;mapx+x)*4+3] = 1;
+		}
+	}*/
+
+	const float* heightMap = readmap-&gt;GetHeightmap();
+	GLfloat* coastmap = SAFE_NEW GLfloat[gs-&gt;mapx*gs-&gt;mapy*4];
+	for (int y = 0; y &lt; gs-&gt;mapy; y++) {
+		for (int x = 0; x &lt; gs-&gt;mapx; x++) {
+			const float&amp; height = heightMap[(y*(gs-&gt;mapx+1)+x)];
+			coastmap[(y*gs-&gt;mapx+x)*4]   = (height&gt;0.0f)?1:0;
+			coastmap[(y*gs-&gt;mapx+x)*4+1] = (height&gt;0.0f)?1:0;
+			coastmap[(y*gs-&gt;mapx+x)*4+2] = (height&gt;0.0f)?1:0;
+			coastmap[(y*gs-&gt;mapx+x)*4+3] = height;
+		}
+	}
+	
+	glGenTextures(1, &amp;coastTexture);
+	glBindTexture(GL_TEXTURE_2D, coastTexture);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F_ARB, gs-&gt;mapx, gs-&gt;mapy, 0, GL_RGBA, GL_FLOAT, coastmap);
+	glGenerateMipmapEXT(GL_TEXTURE_2D);
+	delete[] coastmap;
+
+	GLuint coast2Texture;
+	glGenTextures(1, &amp;coast2Texture);
+	glBindTexture(GL_TEXTURE_2D, coast2Texture);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F_ARB, gs-&gt;mapx, gs-&gt;mapy, 0, GL_RGBA, GL_FLOAT, NULL);
+
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, coastFBO);
+	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coast2Texture, 0);
+	GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+		
+	if (status == GL_FRAMEBUFFER_COMPLETE_EXT) {
+		glActiveTexture(GL_TEXTURE0);
+		glDisable(GL_DEPTH_TEST);
+		glDepthMask(GL_FALSE);
+		glDisable(GL_BLEND);
+
+		glMatrixMode(GL_PROJECTION);
+		glLoadIdentity();
+		glOrtho(0,1,0,1,-1,1);
+		glMatrixMode(GL_MODELVIEW);
+		glLoadIdentity();
+
+		glViewport(0,0,gs-&gt;mapx, gs-&gt;mapy);
+		glUseProgram(blurShader);
+
+		for (int i=0; i&lt;10; ++i){
+			glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
+			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coast2Texture, 0);
+
+			glBindTexture(GL_TEXTURE_2D, coastTexture);
+			glBegin(GL_QUADS);
+			glTexCoord2f(0,0); glVertex2f(0,0);
+			glTexCoord2f(0,1); glVertex2f(0,1);
+			glTexCoord2f(1,1); glVertex2f(1,1);
+			glTexCoord2f(1,0); glVertex2f(1,0);
+			glEnd();
+
+			glUniform2f(blurDirLoc,0.0f,1.0f/gs-&gt;mapy);
+			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coastTexture, 0);
+
+			glBindTexture(GL_TEXTURE_2D, coast2Texture);
+			glBegin(GL_QUADS);
+			glTexCoord2f(0,0); glVertex2f(0,0);
+			glTexCoord2f(0,1); glVertex2f(0,1);
+			glTexCoord2f(1,1); glVertex2f(1,1);
+			glTexCoord2f(1,0); glVertex2f(1,0);
+			glEnd();
+		}
+
+		glUseProgram(0);
+		glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
+	}else PrintFboError(&quot;coast&quot;,status);
+
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	glDeleteTextures(1, &amp;coast2Texture);
+
+	glBindTexture(GL_TEXTURE_2D, coastTexture);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
+	glGenerateMipmapEXT(GL_TEXTURE_2D);
+}
+
+
 void CBumpWater::Draw()
 {
-	if(readmap-&gt;minheight&gt;10)
+	if(readmap-&gt;minheight&gt;1)
 		return;
 
 	if (refraction == 1) {
@@ -331,11 +566,19 @@
 		glDisable(target);
 	}
 
+	if (depthCopy) {
+		// _SCREENCOPY_ DEPTH TEXTURE
+		glBindTexture(target, depthTexture);
+		glEnable(target);
+		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
+		glDisable(target);
+	}
+
 	glDisable(GL_ALPHA_TEST);
+	if (refraction&lt;2)
+		glDepthMask(0);
 	if (refraction&gt;0)
 		glDisable(GL_BLEND);
-	if (refraction&lt;2)
-		glDepthMask(0);
 
 	const int causticTexNum = (gs-&gt;frameNum % caustTextures.size());
 	glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, readmap-&gt;GetShadingTexture());
@@ -343,6 +586,9 @@
 	glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, foamTexture);
 	glActiveTexture(GL_TEXTURE4); glBindTexture(GL_TEXTURE_2D, reflectTexture);
 	glActiveTexture(GL_TEXTURE5); glBindTexture(target,        refractTexture);
+	glActiveTexture(GL_TEXTURE6); glBindTexture(GL_TEXTURE_2D, coastTexture);
+	glActiveTexture(GL_TEXTURE7); glBindTexture(target,        depthTexture);
+	glActiveTexture(GL_TEXTURE8); glBindTexture(GL_TEXTURE_2D, waveRandTexture);
 	glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, normalTexture);
 
 	glUseProgram(waterShader);
@@ -364,11 +610,33 @@
 
 	if (refraction&lt;2)
 		glDepthMask(1);
+	if (refraction&gt;0)
+		glEnable(GL_BLEND);
 }
 
+void CBumpWater::Update()
+{
+	if (readmap-&gt;minheight&gt;1 || mapInfo-&gt;map.voidWater)
+		return;
+
+	float3 w = wind.GetCurrentWind();
+	texcoord1.x += w.x*0.001f;
+	texcoord1.y += w.z*0.001f;
+/*
+	texcoord1.x += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
+	texcoord2.x += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
+	texcoord3.x += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
+	texcoord4.x += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
+	texcoord1.y += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
+	texcoord2.y += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
+	texcoord3.y += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
+	texcoord4.y += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
+*/
+}
+
 void CBumpWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;minheight &gt; 10 || mapInfo-&gt;map.voidWater)
+	if (readmap-&gt;minheight&gt;1 || mapInfo-&gt;map.voidWater)
 		return;
 
 	if (refraction&gt;1) DrawRefraction(game);
@@ -378,12 +646,14 @@
 void CBumpWater::DrawRefraction(CGame* game)
 {
 	// _RENDER_ REFRACTION TEXTURE
-	drawRefraction=true;
+	if (refractFBO)
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, refractFBO);
+
 	camera-&gt;Update(false);
-	glViewport(0,0,refrSizeX,refrSizeY);
+	glViewport(0,0,screenTextureX,screenTextureY);
 
-	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
-	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	glClear(GL_DEPTH_BUFFER_BIT);
+	glDisable(GL_FOG);
 
 	float3 oldsun=unitDrawer-&gt;unitSunColor;
 	float3 oldambient=unitDrawer-&gt;unitAmbientColor;
@@ -392,11 +662,11 @@
 	unitDrawer-&gt;unitAmbientColor*=float3(0.6f,0.8f,1.0f);
 
 	game-&gt;SetDrawMode(CGame::refractionDraw);
+	drawRefraction=true;
 
 	glEnable(GL_CLIP_PLANE2);
-	double plane[4]={0,-1,0,2};
+	static double plane[4]={0,-1,0,5};
 	glClipPlane(GL_CLIP_PLANE2 ,plane);
-	drawReflection=true;
 
 	readmap-&gt;GetGroundDrawer()-&gt;Draw();
 	unitDrawer-&gt;Draw(false,true);
@@ -409,13 +679,17 @@
 	game-&gt;SetDrawMode(CGame::normalDraw);
 	drawRefraction=false;
 
-	glBindTexture(target, refractTexture);
-	glEnable(target);
-	glCopyTexSubImage2D(target,0,0,0,0,0,refrSizeX,refrSizeY);
-	glDisable(target);
+	if (refractFBO) {
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	}else{
+		glBindTexture(target, refractTexture);
+		glEnable(target);
+		glCopyTexSubImage2D(target,0,0,0,0,0,screenTextureX,screenTextureY);
+		glDisable(target);
+	}
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
-	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
+	glEnable(GL_FOG);
 
 	unitDrawer-&gt;unitSunColor=oldsun;
 	unitDrawer-&gt;unitAmbientColor=oldambient;
@@ -424,7 +698,8 @@
 void CBumpWater::DrawReflection(CGame* game)
 {
 	// CREATE REFLECTION TEXTURE
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo);
+	if (reflectFBO)
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
 
 	CCamera *realCam = camera;
 	camera = new CCamera(*realCam);
@@ -436,16 +711,13 @@
 	camera-&gt;Update(false);
 
 	glViewport(0,0,reflTexSize,reflTexSize);
+	glClear(GL_DEPTH_BUFFER_BIT);
 
-	glClearColor(0.2f,0.4f,0.2f,1);
-	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
 	game-&gt;SetDrawMode(CGame::reflectionDraw);
-
 	sky-&gt;Draw();
 
 	glEnable(GL_CLIP_PLANE2);
-	double plane[4]={0,1,0,0}; // make angle dependent?
+	static double plane[4]={0,1,0,1};
 	glClipPlane(GL_CLIP_PLANE2 ,plane);
 	drawReflection=true;
 
@@ -459,10 +731,16 @@
 	drawReflection=false;
 	glDisable(GL_CLIP_PLANE2);
 
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	if (reflectFBO) {
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	}else{
+		glBindTexture(GL_TEXTURE_2D, reflectTexture);
+		glEnable(GL_TEXTURE_2D);
+		glCopyTexSubImage2D(GL_TEXTURE_2D,0,0,0,0,0,reflTexSize, reflTexSize);
+		glDisable(GL_TEXTURE_2D);
+	}
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
-	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 
 	delete camera;
 	camera = realCam;

Modified: trunk/rts/Rendering/Env/BumpWater.h
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.h	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Rendering/Env/BumpWater.h	2008-07-08 21:15:39 UTC (rev 6124)
@@ -11,6 +11,7 @@
 class CBumpWater : public CBaseWater
 {
 public:
+	void Update();
 	void UpdateWater(CGame* game);
 	void DrawReflection(CGame* game);
 	void DrawRefraction(CGame* game);
@@ -20,27 +21,36 @@
 	virtual int GetID() const { return 4; }
 
 private:
+	void GenerateCoastMap();
+	
 	// user options
-	bool reflection;
-	char refraction; //0:=off, 1:=screencopy, 2:=own rendering cycle
-	int  reflTexSize;
-	bool waves;
+	bool  reflection;
+	char  refraction; // 0:=off, 1:=screencopy, 2:=own rendering cycle
+	int   reflTexSize;
+	bool  shorewaves;
+	bool  depthCopy;  // uses a screen depth copy, which allows a nicer interpolation between deep sea and shallow water
+	float anisotropy;
+	char  depthBits;  // depthBits for reflection/refraction RBO
+	bool  blurRefl;
 
-	// map options
-	float3 surfaceColor;
-	float3 specularColor;
-
-	int  refrSizeX;
-	int  refrSizeY;
-
-	unsigned int target; // of the refract texture
+	
+	unsigned int target; // for screen copies (color/depth)
+	int  screenTextureX;
+	int  screenTextureY;
+	
 	GLuint refractTexture;
 	GLuint reflectTexture;
-	GLuint rbo;
-	GLuint fbo;
-
-	GLuint foamTexture;
-	GLuint normalTexture;
+	GLuint reflectRBO;
+	GLuint refractRBO;
+	GLuint reflectFBO;
+	GLuint refractFBO;
+	GLuint coastFBO;
+	
+	GLuint  waveRandTexture;
+	GLuint  foamTexture;
+	GLuint  normalTexture;
+	GLuint  coastTexture;
+	GLuint  depthTexture; // screen depth copy
 	GLuint* heightTexture;
 	std::vector&lt;GLuint&gt; caustTextures;
 
@@ -48,21 +58,18 @@
 	GLuint waterVP;
 	GLuint waterShader;
 	
+	GLuint blurFP;
+	GLuint blurShader;
+	GLuint blurDirLoc;
+
+	GLuint frameLoc;
 	GLuint midPosLoc;
 	GLuint eyePosLoc;
-	GLuint lightDirLoc;
-	GLuint fresnelMinLoc;
-	GLuint fresnelMaxLoc;
-	GLuint fresnelPowerLoc;
-	GLuint frameLoc;
-	GLuint screenInverseLoc;
-	GLuint viewPosLoc;
-	GLuint normalmapLoc;
-	GLuint heightmapLoc;
-	GLuint causticLoc;
-	GLuint foamLoc;
-	GLuint reflectionLoc;
-	GLuint refractionLoc;
+
+	float3 texcoord1;
+	float3 texcoord2;
+	float3 texcoord3;
+	float3 texcoord4;
 };
 
 #endif // __BUMP_WATER_H__

Modified: trunk/rts/Rendering/GL/FBO.cpp
===================================================================
--- trunk/rts/Rendering/GL/FBO.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Rendering/GL/FBO.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -38,17 +38,17 @@
 FBO::FBO(int requires, int w, int h) : frameBuffer(0), depthRenderBuffer(0), requires(requires)
 {
 	glGenFramebuffersEXT(1,&amp;frameBuffer);
-	select();
 	// Is a depth renderbuffer needed?
 	if ((requires &amp; FBO_NEED_DEPTH) &amp;&amp; !(requires &amp; FBO_NEED_DEPTH_TEXTURE))
 	{
+		select();
 		glGenRenderbuffersEXT(1, &amp;depthRenderBuffer);
 		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, depthRenderBuffer);
 		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, w, h);
 		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
 										GL_RENDERBUFFER_EXT, depthRenderBuffer);
+		deselect();
 	}
-	deselect();
 }
 
 /**

Modified: trunk/rts/Rendering/GL/myGL.cpp
===================================================================
--- trunk/rts/Rendering/GL/myGL.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Rendering/GL/myGL.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -74,7 +74,7 @@
 	logOutput.Print(&quot;GL:   %s\n&quot;, glGetString(GL_RENDERER));
 	logOutput.Print(&quot;GLEW: %s\n&quot;, glewGetString(GLEW_VERSION));
 
-	/* Get available fullscreen/hardware modes */
+	/** Get available fullscreen/hardware modes **/
 /*
 	SDL_Rect **modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_OPENGL|SDL_RESIZABLE);
 
@@ -143,14 +143,13 @@
 	
 	// create mipmapped texture
 	if (glGenerateMipmapEXT) {
-	//if (GLEW_EXT_framebuffer_object) { // Hurray (again), ATi only supports half of the extension
 		// newest method
 		glTexImage2D(target, 0, internalFormat, width, height, 0, format, type, data);
-		glGenerateMipmapEXT(GL_TEXTURE_2D);
+		glGenerateMipmapEXT(target);
 	}else if (GLEW_VERSION_1_4) {
 		// This required GL-1.4
 		// instead of using glu, we rely on glTexImage2D to create the Mipmaps.
-		glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
+		glTexParameteri(target, GL_GENERATE_MIPMAP, GL_TRUE);
 		glTexImage2D(target, 0, internalFormat, width, height, 0, format, type, data);
 	} else
 		gluBuild2DMipmaps(target, internalFormat, width, height, format, type, data);

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -405,19 +405,7 @@
 	rightdir.Normalize();
 	float3 updir=rightdir.cross(dir);
 
-	CMatrix44f transMatrix;
-	transMatrix[0]=-rightdir.x;
-	transMatrix[1]=-rightdir.y;
-	transMatrix[2]=-rightdir.z;
-	transMatrix[4]=updir.x;
-	transMatrix[5]=updir.y;
-	transMatrix[6]=updir.z;
-	transMatrix[8]=dir.x;
-	transMatrix[9]=dir.y;
-	transMatrix[10]=dir.z;
-	transMatrix[12]=interPos.x;
-	transMatrix[13]=interPos.y;
-	transMatrix[14]=interPos.z;
+	CMatrix44f transMatrix(interPos,-rightdir,updir,dir);
 	glMultMatrixf(&amp;transMatrix[0]);
 
 	glCallList(modelDispList);

Modified: trunk/rts/System/GlobalStuff.h
===================================================================
--- trunk/rts/System/GlobalStuff.h	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/System/GlobalStuff.h	2008-07-08 21:15:39 UTC (rev 6124)
@@ -525,6 +525,13 @@
 	float aspectRatio;
 
 	/**
+	 * @brief Depthbuffer bits
+	 *
+	 * depthbuffer precision
+	 */
+	int depthBufferBits;
+
+	/**
 	 * @brief my player num
 	 *
 	 * Local player's number

Modified: trunk/rts/System/SpringApp.cpp
===================================================================
--- trunk/rts/System/SpringApp.cpp	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/System/SpringApp.cpp	2008-07-08 21:15:39 UTC (rev 6124)
@@ -180,6 +180,8 @@
 	ENTER_UNSYNCED;
 	gu = SAFE_NEW CGlobalUnsyncedStuff();
 
+	gu-&gt;depthBufferBits = depthBufferBits;
+
 	if (cmdline-&gt;result(&quot;minimise&quot;)) {
 		gu-&gt;active = false;
 		SDL_WM_IconifyWindow();
@@ -354,7 +356,9 @@
 #else
 	const int defaultDepthSize = 16;
 #endif
-	SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, configHandler.GetInt(&quot;DepthBufferBits&quot;, defaultDepthSize));
+	depthBufferBits = configHandler.GetInt(&quot;DepthBufferBits&quot;, defaultDepthSize);
+
+	SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, depthBufferBits);
 	SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, configHandler.GetInt(&quot;StencilBufferBits&quot;, 1));
 
 	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);

Modified: trunk/rts/System/SpringApp.h
===================================================================
--- trunk/rts/System/SpringApp.h	2008-07-08 01:28:50 UTC (rev 6123)
+++ trunk/rts/System/SpringApp.h	2008-07-08 21:15:39 UTC (rev 6124)
@@ -83,6 +83,13 @@
 	 */
 	bool FSAA;
 
+	/**
+	 * @brief depthBufferBits
+	 *
+	 * number of Depthbuffer bits
+	 */
+	bool depthBufferBits;
+
 private:
 	static void SigAbrtHandler(int unused);
 };


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000903.html">[Taspring-linux-commit] r6123 - trunk/rts/Game/UI
</A></li>
	<LI>Next message: <A HREF="000905.html">[Taspring-linux-commit] r6125 - trunk/rts/Lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#904">[ date ]</a>
              <a href="thread.html#904">[ thread ]</a>
              <a href="subject.html#904">[ subject ]</a>
              <a href="author.html#904">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
