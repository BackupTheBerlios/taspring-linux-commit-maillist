<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5513 - in trunk/Lobby/AFLobby:	nbproject/private src src/aflobby	src/aflobby/contentdownloader src/org src/org/klomp	src/org/klomp/snark src/org/klomp/snark/bencode	src/org/klomp/snark/cmd src/org/klomp/snark/tracker
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5513%20-%20in%20trunk/Lobby/AFLobby%3A%0A%09nbproject/private%20src%20src/aflobby%0A%09src/aflobby/contentdownloader%20src/org%20src/org/klomp%0A%09src/org/klomp/snark%20src/org/klomp/snark/bencode%0A%09src/org/klomp/snark/cmd%20src/org/klomp/snark/tracker&In-Reply-To=%3CE1JRG3D-0001Wi-1O%40proserver.fnord.lan%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000319.html">
   <LINK REL="Next"  HREF="000321.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5513 - in trunk/Lobby/AFLobby:	nbproject/private src src/aflobby	src/aflobby/contentdownloader src/org src/org/klomp	src/org/klomp/snark src/org/klomp/snark/bencode	src/org/klomp/snark/cmd src/org/klomp/snark/tracker</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5513%20-%20in%20trunk/Lobby/AFLobby%3A%0A%09nbproject/private%20src%20src/aflobby%0A%09src/aflobby/contentdownloader%20src/org%20src/org/klomp%0A%09src/org/klomp/snark%20src/org/klomp/snark/bencode%0A%09src/org/klomp/snark/cmd%20src/org/klomp/snark/tracker&In-Reply-To=%3CE1JRG3D-0001Wi-1O%40proserver.fnord.lan%3E"
       TITLE="[Taspring-linux-commit] r5513 - in trunk/Lobby/AFLobby:	nbproject/private src src/aflobby	src/aflobby/contentdownloader src/org src/org/klomp	src/org/klomp/snark src/org/klomp/snark/bencode	src/org/klomp/snark/cmd src/org/klomp/snark/tracker">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Tue Feb 19 01:09:35 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000319.html">[Taspring-linux-commit] r5512 - trunk/Lobby/TASClient
</A></li>
        <LI>Next message: <A HREF="000321.html">[Taspring-linux-commit] r5514 -	trunk/Lobby/AFLobby/src/aflobby/contentdownloader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#320">[ date ]</a>
              <a href="thread.html#320">[ thread ]</a>
              <a href="subject.html#320">[ subject ]</a>
              <a href="author.html#320">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tnowell
Date: 2008-02-19 01:09:34 +0100 (Tue, 19 Feb 2008)
New Revision: 5513

Added:
   trunk/Lobby/AFLobby/src/aflobby/contentdownloader/
   trunk/Lobby/AFLobby/src/aflobby/contentdownloader/CContentDownloadHandler.java
   trunk/Lobby/AFLobby/src/aflobby/contentdownloader/CContentInterface.java
   trunk/Lobby/AFLobby/src/org/
   trunk/Lobby/AFLobby/src/org/klomp/
   trunk/Lobby/AFLobby/src/org/klomp/snark/
   trunk/Lobby/AFLobby/src/org/klomp/snark/BitField.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/ConnectionAcceptor.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/CoordinatorListener.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/HttpAcceptor.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/Message.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/MetaInfo.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/Peer.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerAcceptor.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerCheckerTask.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerConnectionIn.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerConnectionOut.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerCoordinator.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerID.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerListener.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerMonitorTask.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/PeerState.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/Request.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/ShutdownListener.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/Snark.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/SnarkShutdown.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/StaticSnark.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/Storage.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/StorageListener.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/Tracker.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/TrackerClient.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/TrackerInfo.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/
   trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BDecoder.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BEValue.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BEncoder.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/InvalidBEncodingException.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/
   trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/ConsoleStorageReporter.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/SnarkApplication.java
   trunk/Lobby/AFLobby/src/org/klomp/snark/tracker/
   trunk/Lobby/AFLobby/src/org/klomp/snark/tracker/TrackerApplication.java
Modified:
   trunk/Lobby/AFLobby/nbproject/private/private.properties
   trunk/Lobby/AFLobby/src/aflobby/CBattleWindow.form
   trunk/Lobby/AFLobby/src/aflobby/CBattleWindow.java
   trunk/Lobby/AFLobby/src/aflobby/CChannelView.form
   trunk/Lobby/AFLobby/src/aflobby/CChannelView.java
   trunk/Lobby/AFLobby/src/aflobby/Main.java
Log:
- added snark library
- modified snark library slightly to allow specifying a target folder
- fixed two crash bugs
- added 2 classes for downloading files via torrents

Modified: trunk/Lobby/AFLobby/nbproject/private/private.properties
===================================================================
--- trunk/Lobby/AFLobby/nbproject/private/private.properties	2008-02-18 20:46:53 UTC (rev 5512)
+++ trunk/Lobby/AFLobby/nbproject/private/private.properties	2008-02-19 00:09:34 UTC (rev 5513)
@@ -1,9 +1,9 @@
 application.args=netbeans
 do.depend=true
 do.jar=true
-file.reference.substance.jar=D:\\SpringSVN_Development\\Lobby\\AFLobby\\substance.jar
+file.reference.substance.jar=E:\\media\\documents\\Development\\SPRING_SVN_TRUNK\\Lobby\\AFLobby\\substance.jar
 javac.debug=true
 javadoc.preview=true
-jaxws.endorsed.dir=C:\\Program Files\\NetBeans 6.0\\java1\\modules\\ext\\jaxws21\\api
-user.properties.file=C:\\Users\\tarendai-std\\.netbeans\\6.0\\build.properties
-work.dir=D:\\Program Files\\Spring
+jaxws.endorsed.dir=C:\\Program Files (x86)\\NetBeans 6.0.1\\java1\\modules\\ext\\jaxws21\\api
+user.properties.file=C:\\Users\\tarendai\\.netbeans\\6.0\\build.properties
+work.dir=E:\\Program Files (x86)2\\Spring

Modified: trunk/Lobby/AFLobby/src/aflobby/CBattleWindow.form
===================================================================
--- trunk/Lobby/AFLobby/src/aflobby/CBattleWindow.form	2008-02-18 20:46:53 UTC (rev 5512)
+++ trunk/Lobby/AFLobby/src/aflobby/CBattleWindow.form	2008-02-19 00:09:34 UTC (rev 5513)
@@ -84,9 +84,9 @@
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                           &lt;Group type=&quot;102&quot; alignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                               &lt;Group type=&quot;103&quot; groupAlignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
-                                  &lt;Component id=&quot;jToolBar2&quot; alignment=&quot;0&quot; pref=&quot;523&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
+                                  &lt;Component id=&quot;jToolBar2&quot; alignment=&quot;0&quot; pref=&quot;517&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
                                   &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
-                                      &lt;Component id=&quot;jScrollPane4&quot; pref=&quot;459&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                                      &lt;Component id=&quot;jScrollPane4&quot; pref=&quot;452&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                                       &lt;Component id=&quot;sayButton&quot; min=&quot;-2&quot; pref=&quot;58&quot; max=&quot;-2&quot; attributes=&quot;1&quot;/&gt;
                                   &lt;/Group&gt;
@@ -108,7 +108,7 @@
                               &lt;/Group&gt;
                           &lt;/Group&gt;
                           &lt;Group type=&quot;102&quot; alignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                              &lt;Component id=&quot;jSplitPane1&quot; pref=&quot;526&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;jSplitPane1&quot; pref=&quot;521&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                               &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jLabel7&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;1&quot;/&gt;
                           &lt;/Group&gt;
@@ -123,13 +123,13 @@
                       &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                           &lt;Group type=&quot;102&quot; attributes=&quot;0&quot;&gt;
-                              &lt;Component id=&quot;jSplitPane1&quot; pref=&quot;409&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;jSplitPane1&quot; pref=&quot;397&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                               &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jToolBar2&quot; min=&quot;-2&quot; pref=&quot;25&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
                           &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
                               &lt;Component id=&quot;jLabel7&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
-                              &lt;EmptySpace pref=&quot;147&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;EmptySpace pref=&quot;134&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;LockToggle&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
                       &lt;/Group&gt;
@@ -236,13 +236,6 @@
 
               &lt;Layout class=&quot;org.netbeans.modules.form.compat2.layouts.support.JSplitPaneSupportLayout&quot;/&gt;
               &lt;SubComponents&gt;
-                &lt;Component class=&quot;aflobby.CChatPanel&quot; name=&quot;Chat&quot;&gt;
-                  &lt;Constraints&gt;
-                    &lt;Constraint layoutClass=&quot;org.netbeans.modules.form.compat2.layouts.support.JSplitPaneSupportLayout&quot; value=&quot;org.netbeans.modules.form.compat2.layouts.support.JSplitPaneSupportLayout$JSplitPaneConstraintsDescription&quot;&gt;
-                      &lt;JSplitPaneConstraints position=&quot;right&quot;/&gt;
-                    &lt;/Constraint&gt;
-                  &lt;/Constraints&gt;
-                &lt;/Component&gt;
                 &lt;Container class=&quot;javax.swing.JPanel&quot; name=&quot;jPanel1&quot;&gt;
                   &lt;Constraints&gt;
                     &lt;Constraint layoutClass=&quot;org.netbeans.modules.form.compat2.layouts.support.JSplitPaneSupportLayout&quot; value=&quot;org.netbeans.modules.form.compat2.layouts.support.JSplitPaneSupportLayout$JSplitPaneConstraintsDescription&quot;&gt;
@@ -265,13 +258,13 @@
                               &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;ColourPanel&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
                           &lt;/Group&gt;
-                          &lt;Component id=&quot;jScrollPane2&quot; alignment=&quot;0&quot; pref=&quot;524&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;Component id=&quot;jScrollPane2&quot; alignment=&quot;0&quot; pref=&quot;519&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
                     &lt;/DimensionLayout&gt;
                     &lt;DimensionLayout dim=&quot;1&quot;&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                           &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
-                              &lt;Component id=&quot;jScrollPane2&quot; pref=&quot;177&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;jScrollPane2&quot; pref=&quot;188&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                               &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Group type=&quot;103&quot; groupAlignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
                                   &lt;Group type=&quot;103&quot; groupAlignment=&quot;3&quot; attributes=&quot;0&quot;&gt;
@@ -418,7 +411,7 @@
                       &lt;Layout&gt;
                         &lt;DimensionLayout dim=&quot;0&quot;&gt;
                           &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                              &lt;EmptySpace min=&quot;0&quot; pref=&quot;61&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;EmptySpace min=&quot;0&quot; pref=&quot;38&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
                         &lt;/DimensionLayout&gt;
                         &lt;DimensionLayout dim=&quot;1&quot;&gt;
@@ -430,6 +423,26 @@
                     &lt;/Container&gt;
                   &lt;/SubComponents&gt;
                 &lt;/Container&gt;
+                &lt;Container class=&quot;aflobby.UI.CChatPanel&quot; name=&quot;Chat&quot;&gt;
+                  &lt;Constraints&gt;
+                    &lt;Constraint layoutClass=&quot;org.netbeans.modules.form.compat2.layouts.support.JSplitPaneSupportLayout&quot; value=&quot;org.netbeans.modules.form.compat2.layouts.support.JSplitPaneSupportLayout$JSplitPaneConstraintsDescription&quot;&gt;
+                      &lt;JSplitPaneConstraints position=&quot;right&quot;/&gt;
+                    &lt;/Constraint&gt;
+                  &lt;/Constraints&gt;
+
+                  &lt;Layout&gt;
+                    &lt;DimensionLayout dim=&quot;0&quot;&gt;
+                      &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+                          &lt;EmptySpace min=&quot;0&quot; pref=&quot;519&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                      &lt;/Group&gt;
+                    &lt;/DimensionLayout&gt;
+                    &lt;DimensionLayout dim=&quot;1&quot;&gt;
+                      &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+                          &lt;EmptySpace min=&quot;0&quot; pref=&quot;157&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                      &lt;/Group&gt;
+                    &lt;/DimensionLayout&gt;
+                  &lt;/Layout&gt;
+                &lt;/Container&gt;
               &lt;/SubComponents&gt;
             &lt;/Container&gt;
             &lt;Container class=&quot;javax.swing.JScrollPane&quot; name=&quot;jScrollPane4&quot;&gt;
@@ -561,7 +574,7 @@
                           &lt;/Group&gt;
                       &lt;/Group&gt;
                       &lt;EmptySpace type=&quot;unrelated&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
-                      &lt;Component id=&quot;jScrollPane3&quot; pref=&quot;330&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                      &lt;Component id=&quot;jScrollPane3&quot; pref=&quot;324&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                   &lt;/Group&gt;
               &lt;/Group&gt;
@@ -571,9 +584,9 @@
                   &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
                       &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
-                          &lt;Component id=&quot;jScrollPane3&quot; alignment=&quot;0&quot; pref=&quot;498&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;Component id=&quot;jScrollPane3&quot; alignment=&quot;0&quot; pref=&quot;492&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
-                              &lt;Component id=&quot;MapPickerLabel&quot; pref=&quot;433&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;MapPickerLabel&quot; pref=&quot;427&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                               &lt;EmptySpace min=&quot;-2&quot; pref=&quot;41&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Group type=&quot;103&quot; groupAlignment=&quot;3&quot; attributes=&quot;0&quot;&gt;
                                   &lt;Component id=&quot;reload_maplist&quot; alignment=&quot;3&quot; min=&quot;-2&quot; pref=&quot;24&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -667,7 +680,7 @@
                   &lt;Group type=&quot;102&quot; attributes=&quot;0&quot;&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                          &lt;Component id=&quot;jScrollPane1&quot; alignment=&quot;0&quot; pref=&quot;790&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;Component id=&quot;jScrollPane1&quot; alignment=&quot;0&quot; pref=&quot;786&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Component id=&quot;HostButtonsPanel&quot; alignment=&quot;0&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -680,7 +693,7 @@
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;Component id=&quot;HostButtonsPanel&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
-                      &lt;Component id=&quot;jScrollPane1&quot; pref=&quot;447&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                      &lt;Component id=&quot;jScrollPane1&quot; pref=&quot;434&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                   &lt;/Group&gt;
               &lt;/Group&gt;
@@ -793,7 +806,7 @@
                       &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                           &lt;Component id=&quot;jLabel9&quot; alignment=&quot;0&quot; min=&quot;-2&quot; pref=&quot;145&quot; max=&quot;-2&quot; attributes=&quot;1&quot;/&gt;
-                          &lt;Component id=&quot;jSeparator1&quot; alignment=&quot;0&quot; pref=&quot;790&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;Component id=&quot;jSeparator1&quot; alignment=&quot;0&quot; pref=&quot;786&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;102&quot; alignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                               &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                                   &lt;Component id=&quot;jLabel14&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -908,7 +921,7 @@
                               &lt;/Group&gt;
                           &lt;/Group&gt;
                       &lt;/Group&gt;
-                      &lt;EmptySpace pref=&quot;200&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                      &lt;EmptySpace pref=&quot;166&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                   &lt;/Group&gt;
               &lt;/Group&gt;
             &lt;/DimensionLayout&gt;
@@ -1088,7 +1101,7 @@
               &lt;Layout&gt;
                 &lt;DimensionLayout dim=&quot;0&quot;&gt;
                   &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                      &lt;EmptySpace min=&quot;0&quot; pref=&quot;327&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                      &lt;EmptySpace min=&quot;0&quot; pref=&quot;312&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                   &lt;/Group&gt;
                 &lt;/DimensionLayout&gt;
                 &lt;DimensionLayout dim=&quot;1&quot;&gt;
@@ -1122,8 +1135,8 @@
                       &lt;/Group&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                          &lt;Component id=&quot;UnRestrictAllUnitsButton&quot; alignment=&quot;0&quot; pref=&quot;196&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
-                          &lt;Component id=&quot;UnRestrictUnitButton&quot; pref=&quot;196&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
+                          &lt;Component id=&quot;UnRestrictAllUnitsButton&quot; alignment=&quot;0&quot; pref=&quot;191&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
+                          &lt;Component id=&quot;UnRestrictUnitButton&quot; pref=&quot;191&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
                           &lt;Component id=&quot;jPanel5&quot; alignment=&quot;0&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -1145,7 +1158,7 @@
                           &lt;Group type=&quot;102&quot; alignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                               &lt;Component id=&quot;jLabel1&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
-                              &lt;Component id=&quot;jScrollPane6&quot; pref=&quot;478&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;jScrollPane6&quot; pref=&quot;469&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
                       &lt;/Group&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -1169,8 +1182,8 @@
                       &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
                           &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;103&quot; groupAlignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
-                              &lt;Component id=&quot;RestrictedUnitsCombo&quot; alignment=&quot;0&quot; pref=&quot;164&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
-                              &lt;Component id=&quot;RestrictUnitButton&quot; alignment=&quot;0&quot; pref=&quot;164&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;RestrictedUnitsCombo&quot; alignment=&quot;0&quot; pref=&quot;155&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;RestrictUnitButton&quot; alignment=&quot;0&quot; pref=&quot;155&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
                           &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
@@ -1283,9 +1296,9 @@
                   &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
                       &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                          &lt;Component id=&quot;jScrollPane12&quot; alignment=&quot;1&quot; pref=&quot;790&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;Component id=&quot;jScrollPane12&quot; alignment=&quot;1&quot; pref=&quot;786&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
-                              &lt;Component id=&quot;jLabel8&quot; pref=&quot;520&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;jLabel8&quot; pref=&quot;515&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                               &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jButton4&quot; min=&quot;-2&quot; pref=&quot;266&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
@@ -1298,7 +1311,7 @@
               &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                   &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
                       &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
-                      &lt;Component id=&quot;jScrollPane12&quot; pref=&quot;464&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                      &lt;Component id=&quot;jScrollPane12&quot; pref=&quot;457&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                       &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
                           &lt;Component id=&quot;jButton4&quot; min=&quot;-2&quot; pref=&quot;28&quot; max=&quot;-2&quot; attributes=&quot;1&quot;/&gt;

Modified: trunk/Lobby/AFLobby/src/aflobby/CBattleWindow.java
===================================================================
--- trunk/Lobby/AFLobby/src/aflobby/CBattleWindow.java	2008-02-18 20:46:53 UTC (rev 5512)
+++ trunk/Lobby/AFLobby/src/aflobby/CBattleWindow.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -449,10 +449,11 @@
             tjb = null;
         }
         
-        battlemodel.Exit();
-        battlemodel = null;
+        if(battlemodel != null){
+            battlemodel.Exit();
+            battlemodel = null;
+        }
         
-        
 
         Runnable doWorkRunnable = new Runnable() {
             public void run() {
@@ -1513,7 +1514,6 @@
         cSmileyCombo1 = new aflobby.UI.CSmileyCombo();
         sayButton = new javax.swing.JButton();
         jSplitPane1 = new javax.swing.JSplitPane();
-        Chat = new aflobby.UI.CChatPanel();
         jPanel1 = new javax.swing.JPanel();
         jScrollPane2 = new javax.swing.JScrollPane();
         playerBattleTable = new javax.swing.JTable();
@@ -1522,6 +1522,7 @@
         RaceCombo = new javax.swing.JComboBox();
         ColourButton = new javax.swing.JButton();
         ColourPanel = new javax.swing.JPanel();
+        Chat = new aflobby.UI.CChatPanel();
         jScrollPane4 = new javax.swing.JScrollPane();
         UserMessage = new javax.swing.JTextArea();
         GameStartButton = new javax.swing.JButton();
@@ -1584,7 +1585,7 @@
         jLabel8 = new javax.swing.JLabel();
 
         setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
-        setTitle(&quot;BattleName :: Server&quot;);
+        setTitle(&quot;BattleName :: Server&quot;); // NOI18N
         setExtendedState(MAXIMIZED_BOTH);
         setIconImage(CUISettings.GetWindowIcon());
         setMinimumSize(new java.awt.Dimension(875, 590));
@@ -1635,7 +1636,6 @@
         jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
         jSplitPane1.setResizeWeight(0.5);
         jSplitPane1.setOneTouchExpandable(true);
-        jSplitPane1.setRightComponent(Chat);
 
         playerBattleTable.setModel(playertablemodel);
         jScrollPane2.setViewportView(playerBattleTable);
@@ -1666,7 +1666,7 @@
         });
 
         ColourButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(&quot;/images/UI/colourpickerwheel16.png&quot;))); // NOI18N
-        ColourButton.setText(&quot;Change Colour&quot;);
+        ColourButton.setText(&quot;Change Colour&quot;); // NOI18N
         ColourButton.setMargin(new java.awt.Insets(2, 6, 2, 6));
         ColourButton.addActionListener(new java.awt.event.ActionListener() {
             public void actionPerformed(java.awt.event.ActionEvent evt) {
@@ -1681,7 +1681,7 @@
         ColourPanel.setLayout(ColourPanelLayout);
         ColourPanelLayout.setHorizontalGroup(
             ColourPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
-            .addGap(0, 285, Short.MAX_VALUE)
+            .addGap(0, 38, Short.MAX_VALUE)
         );
         ColourPanelLayout.setVerticalGroup(
             ColourPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
@@ -1703,12 +1703,12 @@
                 .addComponent(ColourButton)
                 .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                 .addComponent(ColourPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
-            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 748, Short.MAX_VALUE)
+            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 519, Short.MAX_VALUE)
         );
         jPanel1Layout.setVerticalGroup(
             jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
             .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
-                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 173, Short.MAX_VALUE)
+                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 188, Short.MAX_VALUE)
                 .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                 .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                     .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
@@ -1724,6 +1724,19 @@
 
         jSplitPane1.setTopComponent(jPanel1);
 
+        javax.swing.GroupLayout ChatLayout = new javax.swing.GroupLayout(Chat);
+        Chat.setLayout(ChatLayout);
+        ChatLayout.setHorizontalGroup(
+            ChatLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
+            .addGap(0, 519, Short.MAX_VALUE)
+        );
+        ChatLayout.setVerticalGroup(
+            ChatLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
+            .addGap(0, 157, Short.MAX_VALUE)
+        );
+
+        jSplitPane1.setRightComponent(Chat);
+
         UserMessage.setColumns(20);
         UserMessage.setLineWrap(true);
         UserMessage.setRows(2);
@@ -1795,9 +1808,9 @@
                 .addGroup(chatpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                     .addGroup(chatpanelLayout.createSequentialGroup()
                         .addGroup(chatpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
-                            .addComponent(jToolBar2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 747, Short.MAX_VALUE)
+                            .addComponent(jToolBar2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 517, Short.MAX_VALUE)
                             .addGroup(chatpanelLayout.createSequentialGroup()
-                                .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 683, Short.MAX_VALUE)
+                                .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 452, Short.MAX_VALUE)
                                 .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                 .addComponent(sayButton, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)))
                         .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
@@ -1812,7 +1825,7 @@
                                     .addComponent(ReadyToggle, javax.swing.GroupLayout.PREFERRED_SIZE, 124, javax.swing.GroupLayout.PREFERRED_SIZE)
                                     .addComponent(ExitButton, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                     .addGroup(chatpanelLayout.createSequentialGroup()
-                        .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 750, Short.MAX_VALUE)
+                        .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 521, Short.MAX_VALUE)
                         .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                         .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                 .addContainerGap())
@@ -1826,12 +1839,12 @@
                 .addContainerGap()
                 .addGroup(chatpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                     .addGroup(chatpanelLayout.createSequentialGroup()
-                        .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 401, Short.MAX_VALUE)
+                        .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 397, Short.MAX_VALUE)
                         .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                         .addComponent(jToolBar2, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                     .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, chatpanelLayout.createSequentialGroup()
                         .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
-                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 139, Short.MAX_VALUE)
+                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 134, Short.MAX_VALUE)
                         .addComponent(LockToggle)))
                 .addGap(6, 6, 6)
                 .addGroup(chatpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
@@ -1897,7 +1910,7 @@
                         .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                         .addComponent(ChMapButton, javax.swing.GroupLayout.PREFERRED_SIZE, 222, javax.swing.GroupLayout.PREFERRED_SIZE)))
                 .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
-                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 330, Short.MAX_VALUE)
+                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 324, Short.MAX_VALUE)
                 .addContainerGap())
         );
         MapTabLayout.setVerticalGroup(
@@ -1905,9 +1918,9 @@
             .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, MapTabLayout.createSequentialGroup()
                 .addContainerGap()
                 .addGroup(MapTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
-                    .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 498, Short.MAX_VALUE)
+                    .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 492, Short.MAX_VALUE)
                     .addGroup(MapTabLayout.createSequentialGroup()
-                        .addComponent(MapPickerLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 433, Short.MAX_VALUE)
+                        .addComponent(MapPickerLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 427, Short.MAX_VALUE)
                         .addGap(41, 41, 41)
                         .addGroup(MapTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                             .addComponent(reload_maplist, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
@@ -1919,14 +1932,14 @@
 
         HostButtonsPanel.setOpaque(false);
 
-        jButton1.setText(&quot;Fix Teams&quot;);
+        jButton1.setText(&quot;Fix Teams&quot;); // NOI18N
         jButton1.addActionListener(new java.awt.event.ActionListener() {
             public void actionPerformed(java.awt.event.ActionEvent evt) {
                 jButton1ActionPerformed(evt);
             }
         });
 
-        jButton2.setText(&quot;Force FFA&quot;);
+        jButton2.setText(&quot;Force FFA&quot;); // NOI18N
         jButton2.addActionListener(new java.awt.event.ActionListener() {
             public void actionPerformed(java.awt.event.ActionEvent evt) {
                 jButton2ActionPerformed(evt);
@@ -1978,7 +1991,7 @@
             .addGroup(jPanel6Layout.createSequentialGroup()
                 .addContainerGap()
                 .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
-                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 790, Short.MAX_VALUE)
+                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 786, Short.MAX_VALUE)
                     .addComponent(HostButtonsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                 .addContainerGap())
         );
@@ -1988,24 +2001,24 @@
                 .addContainerGap()
                 .addComponent(HostButtonsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                 .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
-                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 447, Short.MAX_VALUE)
+                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 434, Short.MAX_VALUE)
                 .addContainerGap())
         );
 
         GameOptionsPane.addTab(&quot;Game Options&quot;, jPanel6);
 
-        AddAIButton.setText(&quot;Add AI&quot;);
+        AddAIButton.setText(&quot;Add AI&quot;); // NOI18N
         AddAIButton.addActionListener(new java.awt.event.ActionListener() {
             public void actionPerformed(java.awt.event.ActionEvent evt) {
                 AddAIButtonActionPerformed(evt);
             }
         });
 
-        jLabel9.setText(&quot;Add an AI&quot;);
+        jLabel9.setText(&quot;Add an AI&quot;); // NOI18N
 
-        jLabel10.setText(&quot;Modify an AI&quot;);
+        jLabel10.setText(&quot;Modify an AI&quot;); // NOI18N
 
-        jLabel11.setText(&quot;AI to edit:&quot;);
+        jLabel11.setText(&quot;AI to edit:&quot;); // NOI18N
 
         MyAIsCombo.setEnabled(false);
         MyAIsCombo.addActionListener(new java.awt.event.ActionListener() {
@@ -2014,7 +2027,7 @@
             }
         });
 
-        RemoveAIButton.setText(&quot;Remove This AI&quot;);
+        RemoveAIButton.setText(&quot;Remove This AI&quot;); // NOI18N
         RemoveAIButton.setEnabled(false);
         RemoveAIButton.addActionListener(new java.awt.event.ActionListener() {
             public void actionPerformed(java.awt.event.ActionEvent evt) {
@@ -2022,7 +2035,7 @@
             }
         });
 
-        UpdateAIButton.setText(&quot;Update AI&quot;);
+        UpdateAIButton.setText(&quot;Update AI&quot;); // NOI18N
         UpdateAIButton.setEnabled(false);
         UpdateAIButton.addActionListener(new java.awt.event.ActionListener() {
             public void actionPerformed(java.awt.event.ActionEvent evt) {
@@ -2030,30 +2043,30 @@
             }
         });
 
-        jLabel12.setText(&quot;AI Race:&quot;);
+        jLabel12.setText(&quot;AI Race:&quot;); // NOI18N
 
         EditAIRaceCombo.setEnabled(false);
 
-        jLabel13.setText(&quot;AI Ally:&quot;);
+        jLabel13.setText(&quot;AI Ally:&quot;); // NOI18N
 
         EditAIAllyCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { &quot;Ally Team 1&quot;, &quot;Ally Team 2&quot;, &quot;Ally Team 3&quot;, &quot;Ally Team 4&quot;, &quot;Ally Team 5&quot;, &quot;Ally Team 6&quot;, &quot;Ally Team 7&quot;, &quot;Ally Team 8&quot;, &quot;Ally Team 9&quot;, &quot;Ally Team 10&quot;, &quot;Ally Team 11&quot;, &quot;Ally Team 12&quot;, &quot;Ally Team 13&quot;, &quot;Ally Team 14&quot;, &quot;Ally Team 15&quot;, &quot;Ally Team 16&quot; }));
         EditAIAllyCombo.setEnabled(false);
 
-        jLabel14.setText(&quot;Choose an AI:&quot;);
+        jLabel14.setText(&quot;Choose an AI:&quot;); // NOI18N
 
-        jLabel15.setText(&quot;Pick a name:&quot;);
+        jLabel15.setText(&quot;Pick a name:&quot;); // NOI18N
 
-        jLabel16.setText(&quot;(no spaces in AI names)&quot;);
+        jLabel16.setText(&quot;(no spaces in AI names)&quot;); // NOI18N
 
-        jLabel17.setText(&quot;AI Race:&quot;);
+        jLabel17.setText(&quot;AI Race:&quot;); // NOI18N
 
-        jLabel18.setText(&quot;Difficulty:&quot;);
+        jLabel18.setText(&quot;Difficulty:&quot;); // NOI18N
 
         jComboBox5.setModel(new javax.swing.DefaultComboBoxModel(new String[] { &quot;Easy&quot;, &quot;Moderate&quot;, &quot;Difficult&quot; }));
         jComboBox5.setEnabled(false);
 
         jButton3.setIcon(new javax.swing.ImageIcon(getClass().getResource(&quot;/images/UI/colourpickerwheel.png&quot;))); // NOI18N
-        jButton3.setText(&quot;Change Colour&quot;);
+        jButton3.setText(&quot;Change Colour&quot;); // NOI18N
         jButton3.setEnabled(false);
         jButton3.addActionListener(new java.awt.event.ActionListener() {
             public void actionPerformed(java.awt.event.ActionEvent evt) {
@@ -2067,7 +2080,7 @@
         AIColourPanel.setLayout(AIColourPanelLayout);
         AIColourPanelLayout.setHorizontalGroup(
             AIColourPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
-            .addGap(0, 327, Short.MAX_VALUE)
+            .addGap(0, 312, Short.MAX_VALUE)
         );
         AIColourPanelLayout.setVerticalGroup(
             AIColourPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
@@ -2082,7 +2095,7 @@
                 .addContainerGap()
                 .addGroup(AITabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                     .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE)
-                    .addComponent(jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 790, Short.MAX_VALUE)
+                    .addComponent(jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 786, Short.MAX_VALUE)
                     .addGroup(AITabLayout.createSequentialGroup()
                         .addGroup(AITabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                             .addComponent(jLabel14)
@@ -2178,7 +2191,7 @@
                         .addGroup(AITabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                             .addComponent(AIColourPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                             .addComponent(jButton3, javax.swing.GroupLayout.DEFAULT_SIZE, 47, Short.MAX_VALUE))))
-                .addContainerGap(200, Short.MAX_VALUE))
+                .addContainerGap(166, Short.MAX_VALUE))
         );
 
         AITabLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {AIColourPanel, jButton3});
@@ -2201,8 +2214,8 @@
             .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel5Layout.createSequentialGroup()
                 .addContainerGap()
                 .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
-                    .addComponent(RestrictedUnitsCombo, javax.swing.GroupLayout.Alignment.LEADING, 0, 164, Short.MAX_VALUE)
-                    .addComponent(RestrictUnitButton, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 164, Short.MAX_VALUE))
+                    .addComponent(RestrictedUnitsCombo, javax.swing.GroupLayout.Alignment.LEADING, 0, 155, Short.MAX_VALUE)
+                    .addComponent(RestrictUnitButton, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 155, Short.MAX_VALUE))
                 .addContainerGap())
         );
         jPanel5Layout.setVerticalGroup(
@@ -2248,8 +2261,8 @@
                     .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 588, javax.swing.GroupLayout.PREFERRED_SIZE))
                 .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                 .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
-                    .addComponent(UnRestrictAllUnitsButton, javax.swing.GroupLayout.DEFAULT_SIZE, 196, Short.MAX_VALUE)
-                    .addComponent(UnRestrictUnitButton, javax.swing.GroupLayout.DEFAULT_SIZE, 196, Short.MAX_VALUE)
+                    .addComponent(UnRestrictAllUnitsButton, javax.swing.GroupLayout.DEFAULT_SIZE, 191, Short.MAX_VALUE)
+                    .addComponent(UnRestrictUnitButton, javax.swing.GroupLayout.DEFAULT_SIZE, 191, Short.MAX_VALUE)
                     .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                 .addContainerGap())
         );
@@ -2267,7 +2280,7 @@
                     .addGroup(jPanel7Layout.createSequentialGroup()
                         .addComponent(jLabel1)
                         .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
-                        .addComponent(jScrollPane6, javax.swing.GroupLayout.DEFAULT_SIZE, 478, Short.MAX_VALUE)))
+                        .addComponent(jScrollPane6, javax.swing.GroupLayout.DEFAULT_SIZE, 469, Short.MAX_VALUE)))
                 .addContainerGap())
         );
 
@@ -2281,7 +2294,7 @@
         ScriptPreview.setFont(new java.awt.Font(&quot;Arial&quot;, 0, 13));
         ScriptPreview.setLineWrap(true);
         ScriptPreview.setRows(5);
-        ScriptPreview.setText(&quot;Please press refresh below&quot;);
+        ScriptPreview.setText(&quot;Please press refresh below&quot;); // NOI18N
         ScriptPreview.setWrapStyleWord(true);
         jScrollPane12.setViewportView(ScriptPreview);
 
@@ -2304,9 +2317,9 @@
             .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                 .addContainerGap()
                 .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
-                    .addComponent(jScrollPane12, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 790, Short.MAX_VALUE)
+                    .addComponent(jScrollPane12, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 786, Short.MAX_VALUE)
                     .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
-                        .addComponent(jLabel8, javax.swing.GroupLayout.DEFAULT_SIZE, 520, Short.MAX_VALUE)
+                        .addComponent(jLabel8, javax.swing.GroupLayout.DEFAULT_SIZE, 515, Short.MAX_VALUE)
                         .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                         .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 266, javax.swing.GroupLayout.PREFERRED_SIZE)))
                 .addContainerGap())
@@ -2315,7 +2328,7 @@
             jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
             .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                 .addContainerGap()
-                .addComponent(jScrollPane12, javax.swing.GroupLayout.DEFAULT_SIZE, 464, Short.MAX_VALUE)
+                .addComponent(jScrollPane12, javax.swing.GroupLayout.DEFAULT_SIZE, 457, Short.MAX_VALUE)
                 .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                 .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                     .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)

Modified: trunk/Lobby/AFLobby/src/aflobby/CChannelView.form
===================================================================
--- trunk/Lobby/AFLobby/src/aflobby/CChannelView.form	2008-02-18 20:46:53 UTC (rev 5512)
+++ trunk/Lobby/AFLobby/src/aflobby/CChannelView.form	2008-02-19 00:09:34 UTC (rev 5513)
@@ -111,15 +111,15 @@
                       &lt;Group type=&quot;102&quot; alignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                           &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                              &lt;Component id=&quot;WelcomeLabel&quot; alignment=&quot;0&quot; pref=&quot;813&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;WelcomeLabel&quot; alignment=&quot;0&quot; pref=&quot;809&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Group type=&quot;102&quot; alignment=&quot;1&quot; attributes=&quot;0&quot;&gt;
-                                  &lt;Component id=&quot;SearchBox&quot; pref=&quot;706&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
+                                  &lt;Component id=&quot;SearchBox&quot; pref=&quot;691&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
                                   &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                                   &lt;Component id=&quot;jButton3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;1&quot;/&gt;
                               &lt;/Group&gt;
-                              &lt;Component id=&quot;ingame_label&quot; alignment=&quot;0&quot; pref=&quot;813&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
-                              &lt;Component id=&quot;number_of_battles&quot; alignment=&quot;0&quot; pref=&quot;813&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
-                              &lt;Component id=&quot;ladderLabel&quot; alignment=&quot;0&quot; pref=&quot;813&quot; max=&quot;32767&quot; attributes=&quot;1&quot;/&gt;
+                              &lt;Component id=&quot;ingame_label&quot; alignment=&quot;0&quot; pref=&quot;809&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;number_of_battles&quot; alignment=&quot;0&quot; pref=&quot;809&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                              &lt;Component id=&quot;ladderLabel&quot; alignment=&quot;0&quot; pref=&quot;809&quot; max=&quot;32767&quot; attributes=&quot;1&quot;/&gt;
                               &lt;Group type=&quot;102&quot; attributes=&quot;0&quot;&gt;
                                   &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                                       &lt;Group type=&quot;103&quot; alignment=&quot;0&quot; groupAlignment=&quot;0&quot; max=&quot;-2&quot; attributes=&quot;0&quot;&gt;
@@ -132,7 +132,7 @@
                                       &lt;Component id=&quot;jButton14&quot; linkSize=&quot;9&quot; alignment=&quot;0&quot; min=&quot;-2&quot; pref=&quot;74&quot; max=&quot;-2&quot; attributes=&quot;3&quot;/&gt;
                                   &lt;/Group&gt;
                                   &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
-                                  &lt;Component id=&quot;jScrollPane4&quot; pref=&quot;629&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                                  &lt;Component id=&quot;jScrollPane4&quot; pref=&quot;624&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                               &lt;/Group&gt;
                           &lt;/Group&gt;
                           &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -170,7 +170,7 @@
                                   &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                                   &lt;Component id=&quot;jButton14&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;/Group&gt;
-                              &lt;Component id=&quot;jScrollPane4&quot; pref=&quot;376&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
+                              &lt;Component id=&quot;jScrollPane4&quot; pref=&quot;359&quot; max=&quot;32767&quot; attributes=&quot;2&quot;/&gt;
                           &lt;/Group&gt;
                           &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
@@ -402,7 +402,7 @@
                           &lt;/Group&gt;
                           &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Component id=&quot;jButton2&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
-                          &lt;EmptySpace pref=&quot;123&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace pref=&quot;84&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
                       &lt;Group type=&quot;102&quot; alignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
                           &lt;EmptySpace min=&quot;-2&quot; pref=&quot;10&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -420,7 +420,7 @@
                       &lt;Group type=&quot;102&quot; attributes=&quot;0&quot;&gt;
                           &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Component id=&quot;jLabel1&quot; min=&quot;-2&quot; pref=&quot;35&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
-                          &lt;EmptySpace pref=&quot;10&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;103&quot; groupAlignment=&quot;3&quot; attributes=&quot;0&quot;&gt;
                               &lt;Component id=&quot;HostBattleName&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jLabel6&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -430,12 +430,12 @@
                               &lt;Component id=&quot;HostMaxPlayers&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jLabel5&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
-                          &lt;EmptySpace pref=&quot;10&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;103&quot; groupAlignment=&quot;3&quot; attributes=&quot;0&quot;&gt;
                               &lt;Component id=&quot;jComboBox1&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jLabel2&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
-                          &lt;EmptySpace pref=&quot;10&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;103&quot; groupAlignment=&quot;3&quot; attributes=&quot;0&quot;&gt;
                               &lt;Component id=&quot;HostMod&quot; alignment=&quot;3&quot; min=&quot;-2&quot; pref=&quot;20&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;hostReloadmodlist&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -448,7 +448,7 @@
                               &lt;Component id=&quot;jButton2&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jLabel12&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
-                          &lt;EmptySpace pref=&quot;14&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace pref=&quot;9&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;103&quot; groupAlignment=&quot;3&quot; attributes=&quot;0&quot;&gt;
                               &lt;Component id=&quot;HostPassword&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jLabel8&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -458,7 +458,7 @@
                               &lt;Component id=&quot;HostRankLimitCombo&quot; alignment=&quot;3&quot; min=&quot;-2&quot; pref=&quot;23&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jLabel11&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;/Group&gt;
-                          &lt;EmptySpace pref=&quot;11&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Group type=&quot;103&quot; groupAlignment=&quot;3&quot; attributes=&quot;0&quot;&gt;
                               &lt;Component id=&quot;HostUDPPort&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                               &lt;Component id=&quot;jLabel9&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
@@ -468,7 +468,7 @@
                               &lt;Component id=&quot;HostNATCombo&quot; alignment=&quot;3&quot; min=&quot;-2&quot; pref=&quot;24&quot; max=&quot;-2&quot; attributes=&quot;1&quot;/&gt;
                               &lt;Component id=&quot;jLabel10&quot; alignment=&quot;3&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;1&quot;/&gt;
                           &lt;/Group&gt;
-                          &lt;EmptySpace pref=&quot;180&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace pref=&quot;174&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                           &lt;Component id=&quot;HostButton&quot; min=&quot;-2&quot; pref=&quot;23&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                           &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
@@ -720,12 +720,12 @@
                   &lt;Layout&gt;
                     &lt;DimensionLayout dim=&quot;0&quot;&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                          &lt;EmptySpace min=&quot;0&quot; pref=&quot;813&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace min=&quot;0&quot; pref=&quot;809&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
                     &lt;/DimensionLayout&gt;
                     &lt;DimensionLayout dim=&quot;1&quot;&gt;
                       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-                          &lt;EmptySpace min=&quot;0&quot; pref=&quot;510&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                          &lt;EmptySpace min=&quot;0&quot; pref=&quot;504&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
                       &lt;/Group&gt;
                     &lt;/DimensionLayout&gt;
                   &lt;/Layout&gt;

Modified: trunk/Lobby/AFLobby/src/aflobby/CChannelView.java
===================================================================
--- trunk/Lobby/AFLobby/src/aflobby/CChannelView.java	2008-02-18 20:46:53 UTC (rev 5512)
+++ trunk/Lobby/AFLobby/src/aflobby/CChannelView.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -1144,7 +1144,8 @@
             Runnable doWorkRunnable2 = new Runnable() {
 
                 public void run() {
-                    for(String s : LM.playermanager.activeplayers){
+                    String[] sp = (String[]) LM.playermanager.activeplayers.toArray().clone();
+                    for(String s : sp){
                         CPlayer p = LM.playermanager.GetPlayer(s);
                         playerTablePanel.AddPlayer(p);
                     }

Modified: trunk/Lobby/AFLobby/src/aflobby/Main.java
===================================================================
--- trunk/Lobby/AFLobby/src/aflobby/Main.java	2008-02-18 20:46:53 UTC (rev 5512)
+++ trunk/Lobby/AFLobby/src/aflobby/Main.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -11,6 +11,8 @@
 
 import aflobby.UI.CUserSettings;
 import aflobby.UI.WarningWindow;
+import aflobby.contentdownloader.CContentDownloadHandler;
+import aflobby.contentdownloader.CContentInterface;
 import aflobby.helpers.BrowserLauncher;
 import java.awt.Color;
 import java.awt.Toolkit;
@@ -198,6 +200,9 @@
      */
     public static void main (String[] args) {
 
+        CContentInterface cci = new CContentInterface();
+        CContentDownloadHandler cdh = new CContentDownloadHandler(&quot;-16801973&quot;);
+        cdh.Download();
         for (String s : args){
             if(s.equalsIgnoreCase(&quot;netbeans&quot;)){
                 dev_environment = true;

Added: trunk/Lobby/AFLobby/src/aflobby/contentdownloader/CContentDownloadHandler.java
===================================================================
--- trunk/Lobby/AFLobby/src/aflobby/contentdownloader/CContentDownloadHandler.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/aflobby/contentdownloader/CContentDownloadHandler.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,39 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package aflobby.contentdownloader;
+
+import java.io.IOException;
+import org.klomp.snark.Snark;
+import org.klomp.snark.cmd.ConsoleStorageReporter;
+
+/**
+ *
+ * @author tarendai
+ */
+public class CContentDownloadHandler {
+
+    private Snark torrent;
+    private String hash =&quot;&quot;;
+    private String targetpath=&quot;&quot;;
+    
+    public CContentDownloadHandler(String hash, String targetpath){
+        //
+        this.targetpath = targetpath;
+        this.hash = hash;
+    }
+    
+    public void Download(){
+        //
+        torrent  = new Snark(&quot;<A HREF="http://tracker.caspring.org/caupdater/torrents/">http://tracker.caspring.org/caupdater/torrents/</A>&quot;+hash+&quot;.torrent&quot;,null,-1,new ConsoleStorageReporter(),null,targetpath);
+        try {
+            torrent.setupNetwork();
+            torrent.collectPieces();
+        } catch (IOException ioe) {
+            //System.exit(-1);
+            ioe.printStackTrace();
+        }
+    }
+}

Added: trunk/Lobby/AFLobby/src/aflobby/contentdownloader/CContentInterface.java
===================================================================
--- trunk/Lobby/AFLobby/src/aflobby/contentdownloader/CContentInterface.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/aflobby/contentdownloader/CContentInterface.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,70 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package aflobby.contentdownloader;
+
+import java.util.Map;
+import java.util.TreeMap;
+
+/**
+ *
+ * @author tarendai
+ */
+public class CContentInterface {
+
+    public Map&lt;String,String&gt; contenthashmap = null;
+    public Map&lt;String,String&gt; hashcontentmap = null;
+    public Map&lt;String,CContentDownloadHandler&gt; handlers;
+    
+    public boolean initialized = false;
+    
+    public String torurl =&quot;<A HREF="http://tracker.caspring.org/caupdater/torrents.txt">http://tracker.caspring.org/caupdater/torrents.txt</A>&quot;;
+    
+    public CContentInterface(){
+        //
+        contenthashmap = new TreeMap&lt;String,String&gt;();
+        hashcontentmap = new TreeMap&lt;String,String&gt;();
+        handlers = new TreeMap&lt;String,CContentDownloadHandler&gt;();
+        
+        String torrents =&quot;&quot;;
+        torrents = aflobby.Misc.getURLContent(torurl, &quot;&quot;);
+        
+        String[] fields = torrents.split(&quot;\n&quot;);
+        for(String field : fields){
+            
+            int s = field.lastIndexOf(&quot;|&quot;);
+            
+            String contentname = field.substring(0,s);
+            String hashvalue = field.substring(s+1);
+            
+            contenthashmap.put(contentname, hashvalue);
+            hashcontentmap.put(hashvalue, contentname);
+        }
+        
+    }
+    
+    public String GeContentHash(String contentname){
+        return contenthashmap.get(contentname);
+    }
+    
+    public String GetHashContentName(String hash){
+        return hashcontentmap.get(hash);
+    }
+    
+    public CContentDownloadHandler GetHandler(String hash){
+        //
+        if(handlers.containsKey(hash)){
+            return handlers.get(hash);
+        }
+        return null;
+    }
+    
+    public CContentDownloadHandler CreateHandler(String hash){
+        //
+        return null;
+    }
+    
+}
+

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/BitField.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/BitField.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/BitField.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,143 @@
+/*
+ * BitField - Container of a byte array representing set and unset bits.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+/**
+ * Container of a byte array representing set and unset bits.
+ */
+public class BitField
+{
+
+    private final byte[] bitfield;
+
+    private final int size;
+
+    /**
+     * Creates a new BitField that represents &lt;code&gt;size&lt;/code&gt; unset bits.
+     */
+    public BitField (int size)
+    {
+        this.size = size;
+        int arraysize = ((size - 1) / 8) + 1;
+        bitfield = new byte[arraysize];
+    }
+
+    /**
+     * Creates a new BitField that represents &lt;code&gt;size&lt;/code&gt; bits as set by
+     * the given byte array. This will make a copy of the array. Extra bytes
+     * will be ignored.
+     * 
+     * @exception ArrayOutOfBoundsException
+     *                if give byte array is not large enough.
+     */
+    public BitField (byte[] bitfield, int size)
+    {
+        this.size = size;
+        int arraysize = ((size - 1) / 8) + 1;
+        this.bitfield = new byte[arraysize];
+
+        // XXX - More correct would be to check that unused bits are
+        // cleared or clear them explicitly ourselves.
+        System.arraycopy(bitfield, 0, this.bitfield, 0, arraysize);
+    }
+
+    /**
+     * This returns the actual byte array used. Changes to this array effect
+     * this BitField. Note that some bits at the end of the byte array are
+     * supposed to be always unset if they represent bits bigger then the size
+     * of the bitfield.
+     */
+    public byte[] getFieldBytes ()
+    {
+        return bitfield;
+    }
+
+    /**
+     * Return the size of the BitField. The returned value is one bigger then
+     * the last valid bit number (since bit numbers are counted from zero).
+     */
+    public int size ()
+    {
+        return size;
+    }
+
+    /**
+     * Sets the given bit to true.
+     * 
+     * @exception IndexOutOfBoundsException
+     *                if bit is smaller then zero bigger then size (inclusive).
+     */
+    public void set (int bit)
+    {
+        if (bit &lt; 0 || bit &gt;= size) {
+            throw new IndexOutOfBoundsException(Integer.toString(bit));
+        }
+        int index = bit / 8;
+        int mask = 128 &gt;&gt; (bit % 8);
+        bitfield[index] |= mask;
+    }
+
+    /**
+     * Return true if the bit is set or false if it is not.
+     * 
+     * @exception IndexOutOfBoundsException
+     *                if bit is smaller then zero bigger then size (inclusive).
+     */
+    public boolean get (int bit)
+    {
+        if (bit &lt; 0 || bit &gt;= size) {
+            throw new IndexOutOfBoundsException(Integer.toString(bit));
+        }
+
+        int index = bit / 8;
+        int mask = 128 &gt;&gt; (bit % 8);
+        return (bitfield[index] &amp; mask) != 0;
+    }
+
+    @Override
+    public String toString ()
+    {
+        // Not very efficient
+        StringBuffer sb = new StringBuffer(&quot;BitField[&quot;);
+        for (int i = 0; i &lt; size; i++) {
+            if (get(i)) {
+                sb.append(' ');
+                sb.append(i);
+            }
+        }
+        sb.append(&quot; ]&quot;);
+
+        return sb.toString();
+    }
+
+    public String getHumanReadable()
+    {
+        StringBuffer sb = new StringBuffer();
+        for (int i = 0; i &lt; size; i++) {
+            if (get(i)) {
+                sb.append('+');
+            } else {
+                sb.append('-');
+            }
+        }
+        return sb.toString();
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/ConnectionAcceptor.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/ConnectionAcceptor.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/ConnectionAcceptor.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,148 @@
+/*
+ * ConnectionAcceptor - Accepts connections and routes them to sub-acceptors.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Accepts connections on a TCP port and routes them to sub-acceptors.
+ */
+public class ConnectionAcceptor implements Runnable
+{
+    private final ServerSocket serverSocket;
+
+    private final HttpAcceptor httpacceptor;
+
+    private final PeerAcceptor peeracceptor;
+
+    private Thread thread;
+
+    private boolean stop;
+
+    public ConnectionAcceptor (ServerSocket serverSocket,
+        HttpAcceptor httpacceptor, PeerAcceptor peeracceptor)
+    {
+        this.serverSocket = serverSocket;
+        this.httpacceptor = httpacceptor;
+        this.peeracceptor = peeracceptor;
+
+        stop = false;
+    }
+
+    public void start ()
+    {
+        thread = new Thread(this);
+        thread.start();
+    }
+
+    public void halt ()
+    {
+        stop = true;
+
+        ServerSocket ss = serverSocket;
+        if (ss != null) {
+            try {
+                ss.close();
+            } catch (IOException ioe) {
+            }
+        }
+
+        Thread t = thread;
+        if (t != null) {
+            t.interrupt();
+        }
+    }
+
+    public int getPort ()
+    {
+        return serverSocket.getLocalPort();
+    }
+
+    public void run ()
+    {
+        while (!stop) {
+            try {
+                final Socket socket = serverSocket.accept();
+                Thread t = new Thread(&quot;Connection-&quot; + socket) {
+                    @Override
+                    public void run ()
+                    {
+                        try {
+                            InputStream in = socket.getInputStream();
+                            OutputStream out = socket.getOutputStream();
+                            BufferedInputStream bis = new BufferedInputStream(
+                                in);
+                            BufferedOutputStream bos = new BufferedOutputStream(
+                                out);
+
+                            // See what kind of connection it is.
+                            if (httpacceptor != null) {
+                                byte[] scratch = new byte[4];
+                                bis.mark(4);
+                                int len = bis.read(scratch);
+                                if (len != 4) {
+                                    throw new IOException(
+                                        &quot;Need at least 4 bytes&quot;);
+                                }
+                                bis.reset();
+                                if (scratch[0] == 19 &amp;&amp; scratch[1] == 'B'
+                                    &amp;&amp; scratch[2] == 'i' &amp;&amp; scratch[3] == 't') {
+                                    peeracceptor.connection(socket, bis, bos);
+                                } else if (scratch[0] == 'G'
+                                    &amp;&amp; scratch[1] == 'E' &amp;&amp; scratch[2] == 'T'
+                                    &amp;&amp; scratch[3] == ' ') {
+                                    httpacceptor.connection(socket, bis, bos);
+                                }
+                            } else {
+                                peeracceptor.connection(socket, bis, bos);
+                            }
+                        } catch (IOException ioe) {
+                            try {
+                                socket.close();
+                            } catch (IOException ignored) {
+                            }
+                        }
+                    }
+                };
+                t.start();
+            } catch (IOException ioe) {
+                log.log(Level.SEVERE, &quot;Error while accepting&quot;, ioe);
+                stop = true;
+            }
+        }
+
+        try {
+            serverSocket.close();
+        } catch (IOException ignored) {
+        }
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.server&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/CoordinatorListener.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/CoordinatorListener.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/CoordinatorListener.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,33 @@
+/*
+ * CoordinatorListener.java - Callback when a peer changes state
+ * 
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+/**
+ * Callback used when some peer changes state.
+ */
+public interface CoordinatorListener
+{
+    /**
+     * Called when the PeerCoordinator notices a change in the state of a peer.
+     */
+    void peerChange (PeerCoordinator coordinator, Peer peer);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/HttpAcceptor.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/HttpAcceptor.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/HttpAcceptor.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,245 @@
+/*
+ * HttpAcceptor - Accepts incomming http connections. Copyright (C) 2003 Mark J.
+ * Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.Socket;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.StringTokenizer;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class HttpAcceptor
+{
+    private static final String SNARKHTML = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;iso-8859-1\&quot;?&gt;&quot;
+        + &quot;&lt;!DOCTYPE html PUBLIC \&quot;-//W3C//DTD HTML 4.0 Transitional//EN\&quot;&quot;
+        + &quot;\&quot;<A HREF="http://www.w3.org/TR/html4/loose.dtd\">http://www.w3.org/TR/html4/loose.dtd\</A>&quot;&gt;&quot;
+        + &quot;&lt;html&gt;&quot;
+        + &quot;&lt;head&gt;&lt;title&gt;Snark Client&lt;/title&gt;&lt;/head&gt;&quot;
+        + &quot;&lt;body&gt;&quot;
+        + &quot;&lt;h1&gt;Snark Client&lt;/h1&gt;&quot;
+        + &quot;&lt;p&gt;Snark is a client for downloading and sharing files distributed with the BitTorrent protocol. It is not a normal webserver.&lt;/p&gt;&quot;
+        + &quot;&lt;p&gt;&lt;a href=\&quot;announce\&quot;&gt;Tracker&lt;/a&gt;&lt;/p&gt;&quot;
+        + &quot;&lt;hr&gt;&lt;p&gt;For more info see &lt;a href=\&quot;<A HREF="http://www.klomp.org/snark/\">http://www.klomp.org/snark/\</A>&quot;&gt;The Hunting of the Snark Project&lt;/a&gt;&lt;/p&gt;&quot;
+        + &quot;&lt;/body&gt;&quot; + &quot;&lt;/html&gt;&quot;;
+
+    private static final byte[] SNARKPAGE;
+
+    private static final String ASCII = &quot;US-ASCII&quot;;
+
+    private static final byte[] CRLF = new byte[] { '\r', '\n' };
+
+    private static final byte[] HTTP_STATUS;
+
+    private static final byte[] CONTENT_LENGTH;
+
+    private static final byte[] CONTENT_TYPE;
+
+    static {
+        try {
+            SNARKPAGE = SNARKHTML.getBytes(ASCII);
+
+            String STATUS = &quot;HTTP/1.0 &quot;;
+            HTTP_STATUS = STATUS.getBytes(ASCII);
+            CONTENT_LENGTH = &quot;Content-Length: &quot;.getBytes(ASCII);
+            CONTENT_TYPE = &quot;Content-Type: &quot;.getBytes(ASCII);
+        } catch (UnsupportedEncodingException uee) {
+            // Cannot happen, US-ASCII unknown?
+            throw new InternalError(uee.toString());
+        }
+    }
+
+    private final Tracker tracker;
+
+    /**
+     * Creates a HttpAcceptor that can handle torrent metadata of the given
+     * Tracker.
+     */
+    public HttpAcceptor (Tracker tracker)
+    {
+        this.tracker = tracker;
+    }
+
+    public void connection (Socket sock, BufferedInputStream bis,
+        BufferedOutputStream bos) throws IOException
+    {
+        BufferedReader br = new BufferedReader(
+            new InputStreamReader(bis, ASCII));
+
+        String resource = readRequest(br);
+        log.log(Level.FINE, &quot;HTTP request for: &quot; + resource);
+
+        if (resource != null) {
+            Map headers = readHeaders(br);
+            log.log(Level.FINER, headers.toString());
+
+            if (resource.equals(&quot;/&quot;)) {
+                sendData(bos, SNARKPAGE, &quot;text/html&quot;);
+            } else if (resource.startsWith(&quot;/announce&quot;)) {
+                Map params = parseParams(resource);
+                byte[] response = tracker.handleRequest(sock.getInetAddress(),
+                    sock.getPort(), params);
+                sendData(bos, response, &quot;application/octet-stream&quot;);
+            } else if (resource.endsWith(&quot;.torrent&quot;)) {
+                MetaInfo info = tracker.getMetaInfo(
+                    resource.substring(1, resource.length() - 8));
+                if (info != null) {
+                    byte[] torrent = info.getTorrentData();
+                    sendData(bos, torrent, &quot;application/x-bittorrent&quot;);
+                } else {
+                    sendError(bos, 404, &quot;Unable to locate that hash.&quot;);
+                }
+            } else {
+                sendError(bos, 404, &quot;Snark Client. Not a real webserver.&quot;);
+            }
+        } else {
+            sendError(bos, 500, &quot;Snark Client. Not a real webserver.&quot;);
+        }
+
+        sock.close();
+    }
+
+    /**
+     * Processes an incoming HTTP request. Only handles the most basic GET
+     * requests. Returns the (URLEncoded) requested resource or null if the
+     * request wasn't a valid GET request.
+     */
+    private static String readRequest (BufferedReader br) throws IOException
+    {
+        String request = br.readLine();
+        if (request != null &amp;&amp; request.startsWith(&quot;GET &quot;)) {
+            String resource;
+            int index = request.indexOf(' ', 4);
+            if (index == -1) {
+                resource = request.substring(4);
+            } else {
+                resource = request.substring(4, index);
+            }
+            return resource;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Consumes all headers and puts them into a Map mapping header value to
+     * header key Strings.
+     */
+    private static Map&lt;String, String&gt; readHeaders (BufferedReader br)
+        throws IOException
+    {
+        Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;();
+        String header = br.readLine();
+        while (header != null &amp;&amp; header.length() != 0) {
+            header = br.readLine();
+            if (header != null &amp;&amp; header.length() != 0) {
+                int index = header.indexOf(&quot;: &quot;);
+                if (index != -1) {
+                    String key = header.substring(0, index);
+                    String value = header.substring(index + 2);
+                    m.put(key, value);
+                }
+            }
+        }
+        return m;
+    }
+
+    /**
+     * Sends a HTTP OK, the necessary headers and the data.
+     */
+    private static void sendData (OutputStream out, byte[] data,
+        String content_type) throws IOException
+    {
+        sendData(out, 200, &quot;OK&quot;, data, content_type);
+    }
+
+    private static void sendData (OutputStream out, int responseCode,
+        String reason, byte[] data, String content_type) throws IOException
+    {
+        log.log(Level.FINER, &quot;HTTP/1.0 &quot; + responseCode + &quot; &quot; + reason + &quot; &quot;
+            + content_type + &quot; (&quot; + data.length + &quot; bytes)&quot;);
+        byte[] type = content_type.getBytes(ASCII);
+
+        // Status line
+        out.write(HTTP_STATUS);
+        out.write(Integer.toString(responseCode).getBytes(ASCII));
+        out.write(' ');
+        out.write(reason.getBytes(ASCII));
+        out.write(CRLF);
+
+        // Entity headers
+        out.write(CONTENT_LENGTH);
+        out.write(Integer.toString(data.length).getBytes(ASCII));
+        out.write(CRLF);
+
+        out.write(CONTENT_TYPE);
+        out.write(type);
+        out.write(CRLF);
+
+        // Start of data
+        out.write(CRLF);
+
+        out.write(data);
+        out.flush();
+    }
+
+    private static void sendError (OutputStream out, int responseCode,
+        String reason) throws IOException
+    {
+        sendData(out, responseCode, reason, reason.getBytes(ASCII),
+            &quot;text/plain&quot;);
+    }
+
+    /**
+     * Returns a key to value map of the GET request query string parameters. It
+     * expects a '?' and the urlencoded key=value pairs. Note that the key and
+     * value are NOT url decoded before putting in the paramaters map.
+     */
+    private static Map&lt;String, String&gt; parseParams (String request)
+    {
+        Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;();
+        int index = request.indexOf('?');
+        if (index != -1) {
+            String params = request.substring(index + 1);
+            StringTokenizer st = new StringTokenizer(params, &quot;&amp;&quot;);
+            while (st.hasMoreTokens()) {
+                String token = st.nextToken();
+                index = token.indexOf('=');
+                if (index != -1) {
+                    String key = token.substring(0, index);
+                    String value = token.substring(index + 1);
+                    m.put(key, value);
+                }
+            }
+        }
+        return m;
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.server&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/Message.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/Message.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/Message.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,156 @@
+/*
+ * Message - A protocol message which can be send through a DataOutputStream.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+// Used to queue outgoing connections
+// sendMessage() should be used to translate them to wire format.
+class Message
+{
+    final static byte KEEP_ALIVE = -1;
+
+    final static byte CHOKE = 0;
+
+    final static byte UNCHOKE = 1;
+
+    final static byte INTERESTED = 2;
+
+    final static byte UNINTERESTED = 3;
+
+    final static byte HAVE = 4;
+
+    final static byte BITFIELD = 5;
+
+    final static byte REQUEST = 6;
+
+    final static byte PIECE = 7;
+
+    final static byte CANCEL = 8;
+
+    // Not all fields are used for every message.
+    // KEEP_ALIVE doesn't have a real wire representation
+    byte type;
+
+    // Used for HAVE, REQUEST, PIECE and CANCEL messages.
+    int piece;
+
+    // Used for REQUEST, PIECE and CANCEL messages.
+    int begin;
+
+    int length;
+
+    // Used for PIECE and BITFIELD messages
+    byte[] data;
+
+    int off;
+
+    int len;
+
+    /** Utility method for sending a message through a DataStream. */
+    void sendMessage (DataOutputStream dos) throws IOException
+    {
+        // KEEP_ALIVE is special.
+        if (type == KEEP_ALIVE) {
+            dos.writeInt(0);
+            return;
+        }
+
+        // Calculate the total length in bytes
+
+        // Type is one byte.
+        int datalen = 1;
+
+        // piece is 4 bytes.
+        if (type == HAVE || type == REQUEST || type == PIECE || type == CANCEL) {
+            datalen += 4;
+        }
+
+        // begin/offset is 4 bytes
+        if (type == REQUEST || type == PIECE || type == CANCEL) {
+            datalen += 4;
+        }
+
+        // length is 4 bytes
+        if (type == REQUEST || type == CANCEL) {
+            datalen += 4;
+        }
+
+        // add length of data for piece or bitfield array.
+        if (type == BITFIELD || type == PIECE) {
+            datalen += len;
+        }
+
+        // Send length
+        dos.writeInt(datalen);
+        dos.writeByte(type &amp; 0xFF);
+
+        // Send additional info (piece number)
+        if (type == HAVE || type == REQUEST || type == PIECE || type == CANCEL) {
+            dos.writeInt(piece);
+        }
+
+        // Send additional info (begin/offset)
+        if (type == REQUEST || type == PIECE || type == CANCEL) {
+            dos.writeInt(begin);
+        }
+
+        // Send additional info (length); for PIECE this is implicit.
+        if (type == REQUEST || type == CANCEL) {
+            dos.writeInt(length);
+        }
+
+        // Send actual data
+        if (type == BITFIELD || type == PIECE) {
+            dos.write(data, off, len);
+        }
+    }
+
+    @Override
+    public String toString ()
+    {
+        switch (type) {
+        case KEEP_ALIVE:
+            return &quot;KEEP_ALIVE&quot;;
+        case CHOKE:
+            return &quot;CHOKE&quot;;
+        case UNCHOKE:
+            return &quot;UNCHOKE&quot;;
+        case INTERESTED:
+            return &quot;INTERESTED&quot;;
+        case UNINTERESTED:
+            return &quot;UNINTERESTED&quot;;
+        case HAVE:
+            return &quot;HAVE(&quot; + piece + &quot;)&quot;;
+        case BITFIELD:
+            return &quot;BITFIELD&quot;;
+        case REQUEST:
+            return &quot;REQUEST(&quot; + piece + &quot;,&quot; + begin + &quot;,&quot; + length + &quot;)&quot;;
+        case PIECE:
+            return &quot;PIECE(&quot; + piece + &quot;,&quot; + begin + &quot;,&quot; + length + &quot;)&quot;;
+        case CANCEL:
+            return &quot;CANCEL(&quot; + piece + &quot;,&quot; + begin + &quot;,&quot; + length + &quot;)&quot;;
+        default:
+            return &quot;&lt;UNKNOWN&gt;&quot;;
+        }
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/MetaInfo.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/MetaInfo.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/MetaInfo.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,389 @@
+/*
+ * MetaInfo - Holds all information gotten from a torrent file. Copyright (C)
+ * 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.klomp.snark.bencode.BDecoder;
+import org.klomp.snark.bencode.BEValue;
+import org.klomp.snark.bencode.BEncoder;
+import org.klomp.snark.bencode.InvalidBEncodingException;
+
+public class MetaInfo
+{
+    private final String announce;
+
+    private final byte[] info_hash;
+
+    private final String name;
+
+    private final List&lt;List&lt;String&gt;&gt; files;
+
+    private final List&lt;Long&gt; lengths;
+
+    private final int piece_length;
+
+    private final byte[] piece_hashes;
+
+    private final long length;
+
+    private byte[] torrentdata;
+
+    MetaInfo (String announce, String name, List&lt;List&lt;String&gt;&gt; files,
+        List&lt;Long&gt; lengths, int piece_length, byte[] piece_hashes, long length)
+    {
+        this.announce = announce;
+        this.name = name;
+        this.files = files;
+        this.lengths = lengths;
+        this.piece_length = piece_length;
+        this.piece_hashes = piece_hashes;
+        this.length = length;
+
+        this.info_hash = calculateInfoHash();
+    }
+
+    /**
+     * Creates a new MetaInfo from the given InputStream. The InputStream must
+     * start with a correctly bencoded dictonary describing the torrent.
+     */
+    public MetaInfo (InputStream in) throws IOException
+    {
+        this(new BDecoder(in));
+    }
+
+    /**
+     * Creates a new MetaInfo from the given BDecoder. The BDecoder must have a
+     * complete dictionary describing the torrent.
+     */
+    public MetaInfo (BDecoder be) throws IOException
+    {
+        // Note that evaluation order matters here...
+        this(be.bdecodeMap().getMap());
+    }
+
+    /**
+     * Creates a new MetaInfo from a Map of BEValues and the SHA1 over the
+     * original bencoded info dictonary (this is a hack, we could reconstruct
+     * the bencoded stream and recalculate the hash). Will throw a
+     * InvalidBEncodingException if the given map does not contain a valid
+     * announce string or info dictonary.
+     */
+    public MetaInfo (Map m) throws InvalidBEncodingException
+    {
+        BEValue val = (BEValue)m.get(&quot;announce&quot;);
+        if (val == null) {
+            throw new InvalidBEncodingException(&quot;Missing announce string&quot;);
+        }
+        this.announce = val.getString();
+
+        val = (BEValue)m.get(&quot;info&quot;);
+        if (val == null) {
+            throw new InvalidBEncodingException(&quot;Missing info map&quot;);
+        }
+        Map info = val.getMap();
+
+        val = (BEValue)info.get(&quot;name&quot;);
+        if (val == null) {
+            throw new InvalidBEncodingException(&quot;Missing name string&quot;);
+        }
+        name = val.getString();
+
+        val = (BEValue)info.get(&quot;piece length&quot;);
+        if (val == null) {
+            throw new InvalidBEncodingException(&quot;Missing piece length number&quot;);
+        }
+        piece_length = val.getInt();
+
+        val = (BEValue)info.get(&quot;pieces&quot;);
+        if (val == null) {
+            throw new InvalidBEncodingException(&quot;Missing piece bytes&quot;);
+        }
+        piece_hashes = val.getBytes();
+
+        val = (BEValue)info.get(&quot;length&quot;);
+        if (val != null) {
+            // Single file case.
+            length = val.getLong();
+            files = null;
+            lengths = null;
+        } else {
+            // Multi file case.
+            val = (BEValue)info.get(&quot;files&quot;);
+            if (val == null) {
+                throw new InvalidBEncodingException(
+                    &quot;Missing length number and/or files list&quot;);
+            }
+
+            List list = val.getList();
+            int size = list.size();
+            if (size == 0) {
+                throw new InvalidBEncodingException(&quot;zero size files list&quot;);
+            }
+
+            files = new ArrayList&lt;List&lt;String&gt;&gt;(size);
+            lengths = new ArrayList&lt;Long&gt;(size);
+            long l = 0;
+            for (int i = 0; i &lt; list.size(); i++) {
+                Map desc = ((BEValue)list.get(i)).getMap();
+                val = (BEValue)desc.get(&quot;length&quot;);
+                if (val == null) {
+                    throw new InvalidBEncodingException(&quot;Missing length number&quot;);
+                }
+                long len = val.getLong();
+                lengths.add(len);
+                l += len;
+
+                val = (BEValue)desc.get(&quot;path&quot;);
+                if (val == null) {
+                    throw new InvalidBEncodingException(&quot;Missing path list&quot;);
+                }
+                List&lt;BEValue&gt; path_list = val.getList();
+                int path_length = path_list.size();
+                if (path_length == 0) {
+                    throw new InvalidBEncodingException(
+                        &quot;zero size file path list&quot;);
+                }
+
+                List&lt;String&gt; file = new ArrayList&lt;String&gt;(path_length);
+                for (BEValue value : path_list) {
+                    file.add(value.getString());
+                }
+
+                files.add(file);
+            }
+            length = l;
+        }
+
+        info_hash = calculateInfoHash();
+    }
+
+    /**
+     * Returns the string representing the URL of the tracker for this torrent.
+     */
+    public String getAnnounce ()
+    {
+        return announce;
+    }
+
+    /**
+     * Returns the original 20 byte SHA1 hash over the bencoded info map.
+     */
+    public byte[] getInfoHash ()
+    {
+        // XXX - Should we return a clone, just to be sure?
+        return info_hash;
+    }
+
+    public String getHexInfoHash ()
+    {
+        return hexencode(info_hash);
+    }
+
+    /**
+     * Returns the piece hashes. Only used by storage so package local.
+     */
+    byte[] getPieceHashes ()
+    {
+        return piece_hashes;
+    }
+
+    /**
+     * Returns the requested name for the file or toplevel directory. If it is a
+     * toplevel directory name getFiles() will return a non-null List of file
+     * name hierarchy name.
+     */
+    public String getName ()
+    {
+        return name;
+    }
+
+    /**
+     * Returns a list of lists of file name hierarchies or null if it is a
+     * single name. It has the same size as the list returned by getLengths().
+     */
+    public List getFiles ()
+    {
+        // XXX - Immutable?
+        return files;
+    }
+
+    /**
+     * Returns a list of Longs indication the size of the individual files, or
+     * null if it is a single file. It has the same size as the list returned by
+     * getFiles().
+     */
+    public List getLengths ()
+    {
+        // XXX - Immutable?
+        return lengths;
+    }
+
+    /**
+     * Returns the number of pieces.
+     */
+    public int getPieces ()
+    {
+        return piece_hashes.length / 20;
+    }
+
+    /**
+     * Return the length of a piece. All pieces are of equal length except for
+     * the last one (&lt;code&gt;getPieces()-1&lt;/code&gt;).
+     * 
+     * @exception IndexOutOfBoundsException
+     *                when piece is equal to or greater then the number of
+     *                pieces in the torrent.
+     */
+    public int getPieceLength (int piece)
+    {
+        int pieces = getPieces();
+        if (piece &gt;= 0 &amp;&amp; piece &lt; pieces - 1) {
+            return piece_length;
+        } else if (piece == pieces - 1) {
+            return (int)(length - piece * piece_length);
+        } else {
+            throw new IndexOutOfBoundsException(&quot;no piece: &quot; + piece);
+        }
+    }
+
+    /**
+     * Checks that the given piece has the same SHA1 hash as the given byte
+     * array. Returns random results or IndexOutOfBoundsExceptions when the
+     * piece number is unknown.
+     */
+    public boolean checkPiece (int piece, byte[] bs, int off, int length)
+    {
+        // Check digest
+        MessageDigest sha1;
+        try {
+            sha1 = MessageDigest.getInstance(&quot;SHA&quot;);
+        } catch (NoSuchAlgorithmException nsae) {
+            throw new InternalError(&quot;No SHA digest available: &quot; + nsae);
+        }
+
+        sha1.update(bs, off, length);
+        byte[] hash = sha1.digest();
+        for (int i = 0; i &lt; 20; i++) {
+            if (hash[i] != piece_hashes[20 * piece + i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns the total length of the torrent in bytes.
+     */
+    public long getTotalLength ()
+    {
+        return length;
+    }
+
+    @Override
+    public String toString ()
+    {
+        return &quot;MetaInfo[info_hash='&quot; + hexencode(info_hash) + &quot;', announce='&quot;
+            + announce + &quot;', name='&quot; + name + &quot;', files=&quot; + files
+            + &quot;, #pieces='&quot; + piece_hashes.length / 20 + &quot;', piece_length='&quot;
+            + piece_length + &quot;', length='&quot; + length + &quot;']&quot;;
+    }
+
+    /**
+     * Encode a byte array as a hex encoded string.
+     */
+    private static String hexencode (byte[] bs)
+    {
+        StringBuffer sb = new StringBuffer(bs.length * 2);
+        for (byte element : bs) {
+            int c = element &amp; 0xFF;
+            if (c &lt; 16) {
+                sb.append('0');
+            }
+            sb.append(Integer.toHexString(c));
+        }
+
+        return sb.toString();
+    }
+
+    /**
+     * Creates a copy of this MetaInfo that shares everything except the
+     * announce URL.
+     */
+    public MetaInfo reannounce (String announce)
+    {
+        return new MetaInfo(announce, name, files, lengths, piece_length,
+            piece_hashes, length);
+    }
+
+    public byte[] getTorrentData ()
+    {
+        if (torrentdata == null) {
+            Map&lt;String, Object&gt; m = new HashMap&lt;String, Object&gt;();
+            m.put(&quot;announce&quot;, announce);
+            Map info = createInfoMap();
+            m.put(&quot;info&quot;, info);
+            torrentdata = BEncoder.bencode(m);
+        }
+        return torrentdata;
+    }
+
+    private Map&lt;String, Object&gt; createInfoMap ()
+    {
+        Map&lt;String, Object&gt; info = new HashMap&lt;String, Object&gt;();
+        info.put(&quot;name&quot;, name);
+        info.put(&quot;piece length&quot;, piece_length);
+        info.put(&quot;pieces&quot;, piece_hashes);
+        if (files == null) {
+            info.put(&quot;length&quot;, new Long(length));
+        } else {
+            List&lt;Map&lt;String, Object&gt;&gt; l = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();
+            for (int i = 0; i &lt; files.size(); i++) {
+                Map&lt;String, Object&gt; file = new HashMap&lt;String, Object&gt;();
+                file.put(&quot;path&quot;, files.get(i));
+                file.put(&quot;length&quot;, lengths.get(i));
+                l.add(file);
+            }
+            info.put(&quot;files&quot;, l);
+        }
+        return info;
+    }
+
+    private byte[] calculateInfoHash ()
+    {
+        Map&lt;String, Object&gt; info = createInfoMap();
+        byte[] infoBytes = BEncoder.bencode(info);
+        try {
+            MessageDigest digest = MessageDigest.getInstance(&quot;SHA&quot;);
+            return digest.digest(infoBytes);
+        } catch (NoSuchAlgorithmException nsa) {
+            throw new InternalError(nsa.toString());
+        }
+    }
+
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/Peer.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/Peer.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/Peer.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,393 @@
+/*
+ * Peer - All public information concerning a peer. Copyright (C) 2003 Mark J.
+ * Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.net.Socket;
+import java.util.Arrays;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class Peer implements Comparable&lt;Peer&gt;
+{
+    // Identifying property, the peer id of the other side.
+    private final PeerID peerID;
+
+    private final byte[] my_id;
+
+    private final MetaInfo metainfo;
+
+    // The data in/output streams set during the handshake and used by
+    // the actual connections.
+    private DataInputStream din;
+
+    private DataOutputStream dout;
+
+    // Keeps state for in/out connections. Non-null when the handshake
+    // was successful, the connection setup and runs
+    PeerState state;
+
+    private boolean deregister = true;
+
+    /**
+     * Creates a disconnected peer given a PeerID, your own id and the relevant
+     * MetaInfo.
+     */
+    public Peer (PeerID peerID, byte[] my_id, MetaInfo metainfo)
+        throws IOException
+    {
+        this.peerID = peerID;
+        this.my_id = my_id;
+        this.metainfo = metainfo;
+    }
+
+    /**
+     * Creates a unconnected peer from the input and output stream got from the
+     * socket. Note that the complete handshake (which can take some time or
+     * block indefinitely) is done in the calling Thread to get the remote peer
+     * id. To completely start the connection call the connect() method.
+     * 
+     * @exception IOException
+     *                when an error occurred during the handshake.
+     */
+    public Peer (final Socket sock, BufferedInputStream bis,
+        BufferedOutputStream bos, byte[] my_id, MetaInfo metainfo)
+        throws IOException
+    {
+        this.my_id = my_id;
+        this.metainfo = metainfo;
+
+        byte[] id = handshake(bis, bos);
+        this.peerID = new PeerID(id, sock.getInetAddress(), sock.getPort());
+    }
+
+    /**
+     * Returns the id of the peer.
+     */
+    public PeerID getPeerID ()
+    {
+        return peerID;
+    }
+
+    /**
+     * Returns the String representation of the peerID.
+     */
+    @Override
+    public String toString ()
+    {
+        return peerID.toString();
+    }
+
+    /**
+     * The hash code of a Peer is the hash code of the peerID.
+     */
+    @Override
+    public int hashCode ()
+    {
+        return peerID.hashCode();
+    }
+
+    /**
+     * Two Peers are equal when they have the same PeerID. All other properties
+     * are ignored.
+     */
+    @Override
+    public boolean equals (Object o)
+    {
+        if (o instanceof Peer) {
+            Peer p = (Peer)o;
+            return peerID.equals(p.peerID);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Compares the PeerIDs.
+     */
+    public int compareTo (Peer p)
+    {
+        return peerID.compareTo(p.peerID);
+    }
+
+    /**
+     * Runs the connection to the other peer. This method does not return until
+     * the connection is terminated.
+     * 
+     * When the connection is correctly started the connected() method of the
+     * given PeerListener is called. If the connection ends or the connection
+     * could not be setup correctly the disconnected() method is called.
+     * 
+     * If the given BitField is non-null it is send to the peer as first
+     * message.
+     */
+    public void runConnection (PeerListener listener, BitField bitfield)
+    {
+        if (state != null) {
+            throw new IllegalStateException(&quot;Peer already started&quot;);
+        }
+
+        try {
+            // Do we need to handshake?
+            if (din == null) {
+                Socket sock = new Socket(peerID.getAddress(), peerID.getPort());
+                BufferedInputStream bis = new BufferedInputStream(
+                    sock.getInputStream());
+                BufferedOutputStream bos = new BufferedOutputStream(
+                    sock.getOutputStream());
+                byte[] id = handshake(bis, bos);
+                byte[] expected_id = peerID.getID();
+                if (!Arrays.equals(expected_id, id)) {
+                    throw new IOException(&quot;Unexpected peerID '&quot;
+                        + PeerID.idencode(id) + &quot;' expected '&quot;
+                        + PeerID.idencode(expected_id) + &quot;'&quot;);
+                }
+            }
+
+            PeerConnectionIn in = new PeerConnectionIn(this, din);
+            PeerConnectionOut out = new PeerConnectionOut(this, dout);
+            PeerState s = new PeerState(this, listener, metainfo, in, out);
+
+            // Send our bitmap
+            if (bitfield != null) {
+                s.out.sendBitfield(bitfield);
+            }
+
+            // We are up and running!
+            state = s;
+            listener.connected(this);
+
+            // Use this thread for running the incomming connection.
+            // The outgoing connection has created its own Thread.
+            s.in.run();
+        } catch (IOException eofe) {
+            log.log(Level.FINE, &quot;Peer connection to &quot; + peerID.getAddress() + &quot; failed &quot;, eofe);
+        } catch (Throwable t) {
+            log.log(Level.SEVERE, &quot;Peer connection failed &quot; + toString(), t);
+            t.printStackTrace();
+        } finally {
+            if (deregister) {
+                listener.disconnected(this);
+            }
+        }
+    }
+
+    /**
+     * Sets DataIn/OutputStreams, does the handshake and returns the id reported
+     * by the other side.
+     */
+    private byte[] handshake (BufferedInputStream bis, BufferedOutputStream bos)
+        throws IOException
+    {
+        din = new DataInputStream(bis);
+        dout = new DataOutputStream(bos);
+
+        // Handshake write - header
+        dout.write(19);
+        dout.write(&quot;BitTorrent protocol&quot;.getBytes(&quot;UTF-8&quot;));
+        // Handshake write - zeros
+        byte[] zeros = new byte[8];
+        dout.write(zeros);
+        // Handshake write - metainfo hash
+        byte[] shared_hash = metainfo.getInfoHash();
+        dout.write(shared_hash);
+        // Handshake write - peer id
+        dout.write(my_id);
+        dout.flush();
+
+        // Handshake read - header
+        byte b = din.readByte();
+        if (b != 19) {
+            throw new IOException(&quot;Handshake failure, expected 19, got &quot;
+                + (b &amp; 0xff));
+        }
+
+        byte[] bs = new byte[19];
+        din.readFully(bs);
+        String bittorrentProtocol = new String(bs, &quot;UTF-8&quot;);
+        if (!&quot;BitTorrent protocol&quot;.equals(bittorrentProtocol)) {
+            throw new IOException(&quot;Handshake failure, expected &quot;
+                + &quot;'Bittorrent protocol', got '&quot; + bittorrentProtocol + &quot;'&quot;);
+        }
+
+        // Handshake read - zeros
+        din.readFully(zeros);
+
+        // Handshake read - metainfo hash
+        bs = new byte[20];
+        din.readFully(bs);
+        if (!Arrays.equals(shared_hash, bs)) {
+            throw new IOException(&quot;Unexpected MetaInfo hash&quot;);
+        }
+
+        // Handshake read - peer id
+        din.readFully(bs);
+        return bs;
+    }
+
+    public boolean isConnected ()
+    {
+        return state != null;
+    }
+
+    /**
+     * Disconnects this peer if it was connected. If deregister is true,
+     * PeerListener.disconnected() will be called when the connection is
+     * completely terminated. Otherwise the connection is silently terminated.
+     */
+    public void disconnect (boolean deregister)
+    {
+        // Both in and out connection will call this.
+        this.deregister = deregister;
+        disconnect();
+    }
+
+    void disconnect ()
+    {
+        PeerState s = state;
+        if (s != null) {
+            state = null;
+
+            PeerConnectionIn in = s.in;
+            if (in != null) {
+                in.disconnect();
+            }
+            PeerConnectionOut out = s.out;
+            if (out != null) {
+                out.disconnect();
+            }
+        }
+    }
+
+    /**
+     * Tell the peer we have another piece.
+     */
+    public void have (int piece)
+    {
+        PeerState s = state;
+        if (s != null) {
+            s.havePiece(piece);
+        }
+    }
+
+    /**
+     * Whether or not the peer is interested in pieces we have. Returns false if
+     * not connected.
+     */
+    public boolean isInterested ()
+    {
+        PeerState s = state;
+        return (s != null) &amp;&amp; s.interested;
+    }
+
+    /**
+     * Sets whether or not we are interested in pieces from this peer. Defaults
+     * to false. When interest is true and this peer unchokes us then we start
+     * downloading from it. Has no effect when not connected.
+     */
+    public void setInteresting (boolean interest)
+    {
+        PeerState s = state;
+        if (s != null) {
+            s.setInteresting(interest);
+        }
+    }
+
+    /**
+     * Whether or not the peer has pieces we want from it. Returns false if not
+     * connected.
+     */
+    public boolean isInteresting ()
+    {
+        PeerState s = state;
+        return (s != null) &amp;&amp; s.interesting;
+    }
+
+    /**
+     * Sets whether or not we are choking the peer. Defaults to true. When choke
+     * is false and the peer requests some pieces we upload them, otherwise
+     * requests of this peer are ignored.
+     */
+    public void setChoking (boolean choke)
+    {
+        PeerState s = state;
+        if (s != null) {
+            s.setChoking(choke);
+        }
+    }
+
+    /**
+     * Whether or not we are choking the peer. Returns true when not connected.
+     */
+    public boolean isChoking ()
+    {
+        PeerState s = state;
+        return (s == null) || s.choking;
+    }
+
+    /**
+     * Whether or not the peer choked us. Returns true when not connected.
+     */
+    public boolean isChoked ()
+    {
+        PeerState s = state;
+        return (s == null) || s.choked;
+    }
+
+    /**
+     * Returns the number of bytes that have been downloaded. Can be reset to
+     * zero with &lt;code&gt;resetCounters()&lt;/code&gt;/
+     */
+    public long getDownloaded ()
+    {
+        PeerState s = state;
+        return (s != null) ? s.downloaded : 0;
+    }
+
+    /**
+     * Returns the number of bytes that have been uploaded. Can be reset to zero
+     * with &lt;code&gt;resetCounters()&lt;/code&gt;/
+     */
+    public long getUploaded ()
+    {
+        PeerState s = state;
+        return (s != null) ? s.uploaded : 0;
+    }
+
+    /**
+     * Resets the downloaded and uploaded counters to zero.
+     */
+    public void resetCounters ()
+    {
+        PeerState s = state;
+        if (s != null) {
+            s.downloaded = 0;
+            s.uploaded = 0;
+        }
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.peer&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerAcceptor.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerAcceptor.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerAcceptor.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,54 @@
+/*
+ * PeerAcceptor - Accepts incomming connections from peers. Copyright (C) 2003
+ * Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.net.Socket;
+
+/**
+ * Accepts incomming connections from peers. The ConnectionAcceptor will call
+ * the connection() method when it detects an incomming BT protocol connection.
+ * The PeerAcceptor will then create a new peer if the PeerCoordinator wants
+ * more peers.
+ */
+public class PeerAcceptor
+{
+    private final PeerCoordinator coordinator;
+
+    public PeerAcceptor (PeerCoordinator coordinator)
+    {
+        this.coordinator = coordinator;
+    }
+
+    public void connection (Socket socket, BufferedInputStream bis,
+        BufferedOutputStream bos) throws IOException
+    {
+        if (coordinator.needPeers()) {
+            Peer peer = new Peer(socket, bis, bos, coordinator.getID(),
+                coordinator.getMetaInfo());
+            coordinator.addPeer(peer);
+        } else {
+            socket.close();
+        }
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerCheckerTask.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerCheckerTask.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerCheckerTask.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,187 @@
+/*
+ * PeerCheckTasks - TimerTask that checks for good/bad up/downloaders. Copyright
+ * (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.TimerTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * TimerTask that checks for good/bad up/downloader. Works together with the
+ * PeerCoordinator to select which Peers get (un)choked.
+ */
+class PeerCheckerTask extends TimerTask
+{
+    private static final long KILOPERSECOND = 1024 * (PeerCoordinator.CHECK_PERIOD / 1000);
+
+    private final PeerCoordinator coordinator;
+
+    PeerCheckerTask (PeerCoordinator coordinator)
+    {
+        this.coordinator = coordinator;
+    }
+
+    @Override
+    public void run ()
+    {
+        synchronized (coordinator.peers) {
+            // Calculate total uploading and worst downloader.
+            long worstdownload = Long.MAX_VALUE;
+            Peer worstDownloader = null;
+
+            int peers = 0;
+            int uploaders = 0;
+            int downloaders = 0;
+            int interested = 0;
+            int interesting = 0;
+            int choking = 0;
+            int choked = 0;
+
+            long uploaded = 0;
+            long downloaded = 0;
+
+            // Keep track of peers we remove now,
+            // we will add them back to the end of the list.
+            List&lt;Peer&gt; removed = new ArrayList&lt;Peer&gt;();
+
+            Iterator it = coordinator.peers.iterator();
+            while (it.hasNext()) {
+                Peer peer = (Peer)it.next();
+
+                // Remove dying peers
+                if (!peer.isConnected()) {
+                    it.remove();
+                    continue;
+                }
+
+                peers++;
+
+                if (!peer.isChoking()) {
+                    uploaders++;
+                }
+                if (!peer.isChoked() &amp;&amp; peer.isInteresting()) {
+                    downloaders++;
+                }
+                if (peer.isInterested()) {
+                    interested++;
+                }
+                if (peer.isInteresting()) {
+                    interesting++;
+                }
+                if (peer.isChoking()) {
+                    choking++;
+                }
+                if (peer.isChoked()) {
+                    choked++;
+                }
+
+                // XXX - We should calculate the up/download rate a bit
+                // more intelligently
+                long upload = peer.getUploaded();
+                uploaded += upload;
+                long download = peer.getDownloaded();
+                downloaded += download;
+                peer.resetCounters();
+
+                log.log(Level.FINEST, peer + &quot;:&quot; + &quot; ul: &quot; + upload
+                    / KILOPERSECOND + &quot; dl: &quot; + download / KILOPERSECOND
+                    + &quot; i: &quot; + peer.isInterested() + &quot; I: &quot;
+                    + peer.isInteresting() + &quot; c: &quot; + peer.isChoking() + &quot; C: &quot;
+                    + peer.isChoked());
+
+                // If we are at our max uploaders and we have lots of other
+                // interested peers try to make some room.
+                // (Note use of coordinator.uploaders)
+                if (coordinator.uploaders &gt;= PeerCoordinator.MAX_UPLOADERS
+                    &amp;&amp; interested &gt; PeerCoordinator.MAX_UPLOADERS
+                    &amp;&amp; !peer.isChoking()) {
+                    // Check if it still wants pieces from us.
+                    if (!peer.isInterested()) {
+                        log.log(Level.FINER, &quot;Choke uninterested peer: &quot; + peer);
+                        peer.setChoking(true);
+                        uploaders--;
+                        coordinator.uploaders--;
+
+                        // Put it at the back of the list
+                        it.remove();
+                        removed.add(peer);
+                    } else if (peer.isChoked()) {
+                        // If they are choking us make someone else a downloader
+                        log.log(Level.FINEST, &quot;Choke choking peer: &quot; + peer);
+                        peer.setChoking(true);
+                        uploaders--;
+                        coordinator.uploaders--;
+
+                        // Put it at the back of the list
+                        it.remove();
+                        removed.add(peer);
+                    } else if (peer.isInteresting() &amp;&amp; !peer.isChoked()
+                        &amp;&amp; download == 0) {
+                        // We are downloading but didn't receive anything...
+                        log.log(Level.FINEST,
+                            &quot;Choke downloader that doesn't deliver:&quot; + peer);
+                        peer.setChoking(true);
+                        uploaders--;
+                        coordinator.uploaders--;
+
+                        // Put it at the back of the list
+                        it.remove();
+                        removed.add(peer);
+                    } else if (!peer.isChoking() &amp;&amp; download &lt; worstdownload) {
+                        // Make sure download is good if we are uploading
+                        worstdownload = download;
+                        worstDownloader = peer;
+                    }
+                }
+            }
+
+            // Resync actual uploaders value
+            // (can shift a bit by disconnecting peers)
+            coordinator.uploaders = uploaders;
+
+            // Remove the worst downloader if needed.
+            if (uploaders &gt;= PeerCoordinator.MAX_UPLOADERS
+                &amp;&amp; interested &gt; PeerCoordinator.MAX_UPLOADERS
+                &amp;&amp; worstDownloader != null) {
+                log.log(Level.FINEST, &quot;Choke worst downloader: &quot;
+                    + worstDownloader);
+
+                worstDownloader.setChoking(true);
+                coordinator.uploaders--;
+
+                // Put it at the back of the list
+                coordinator.peers.remove(worstDownloader);
+                removed.add(worstDownloader);
+            }
+
+            // Optimistically unchoke a peer
+            coordinator.unchokePeer();
+
+            // Put peers back at the end of the list that we removed earlier.
+            coordinator.peers.addAll(removed);
+        }
+    }
+
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.peer&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerConnectionIn.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerConnectionIn.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerConnectionIn.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,150 @@
+/*
+ * PeerConnectionIn - Handles incomming messages and hands them to PeerState.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+class PeerConnectionIn implements Runnable
+{
+    private final Peer peer;
+
+    private final DataInputStream din;
+
+    private Thread thread;
+
+    private boolean quit;
+
+    public PeerConnectionIn (Peer peer, DataInputStream din)
+    {
+        this.peer = peer;
+        this.din = din;
+        quit = false;
+    }
+
+    void disconnect ()
+    {
+        if (quit == true) {
+            return;
+        }
+
+        quit = true;
+        Thread t = thread;
+        if (t != null) {
+            t.interrupt();
+        }
+    }
+
+    public void run ()
+    {
+        thread = Thread.currentThread();
+        try {
+            PeerState ps = peer.state;
+            while (!quit &amp;&amp; ps != null) {
+                // Common variables used for some messages.
+                int piece;
+                int begin;
+                int len;
+
+                // Wait till we hear something...
+                // The length of a complete message in bytes.
+                int i = din.readInt();
+                if (i &lt; 0) {
+                    throw new IOException(&quot;Unexpected length prefix: &quot; + i);
+                }
+
+                if (i == 0) {
+                    ps.keepAliveMessage();
+                    continue;
+                }
+
+                byte b = din.readByte();
+                Message m = new Message();
+                m.type = b;
+                switch (b) {
+                case 0:
+                    ps.chokeMessage(true);
+                    break;
+                case 1:
+                    ps.chokeMessage(false);
+                    break;
+                case 2:
+                    ps.interestedMessage(true);
+                    break;
+                case 3:
+                    ps.interestedMessage(false);
+                    break;
+                case 4:
+                    piece = din.readInt();
+                    ps.haveMessage(piece);
+                    break;
+                case 5:
+                    byte[] bitmap = new byte[i - 1];
+                    din.readFully(bitmap);
+                    ps.bitfieldMessage(bitmap);
+                    break;
+                case 6:
+                    piece = din.readInt();
+                    begin = din.readInt();
+                    len = din.readInt();
+                    ps.requestMessage(piece, begin, len);
+                    break;
+                case 7:
+                    piece = din.readInt();
+                    begin = din.readInt();
+                    len = i - 9;
+                    Request req = ps.getOutstandingRequest(piece, begin, len);
+                    byte[] piece_bytes;
+                    if (req != null) {
+                        piece_bytes = req.bs;
+                        din.readFully(piece_bytes, begin, len);
+                        ps.pieceMessage(req);
+                    } else {
+                        // XXX - Consume but throw away afterwards.
+                        piece_bytes = new byte[len];
+                        din.readFully(piece_bytes);
+                    }
+                    break;
+                case 8:
+                    piece = din.readInt();
+                    begin = din.readInt();
+                    len = din.readInt();
+                    ps.cancelMessage(piece, begin, len);
+                    break;
+                default:
+                    byte[] bs = new byte[i - 1];
+                    din.readFully(bs);
+                    ps.unknownMessage(b, bs);
+                }
+            }
+        } catch (IOException ioe) {
+            // Ignore, probably the other side closed connection.
+        } catch (Throwable t) {
+            log.log(Level.SEVERE, peer + &quot; failed&quot;, t);
+        } finally {
+            peer.disconnect();
+        }
+    }
+
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.peer&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerConnectionOut.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerConnectionOut.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerConnectionOut.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,319 @@
+/*
+ * PeerConnectionOut - Keeps a queue of outgoing messages and delivers them.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+class PeerConnectionOut implements Runnable
+{
+    private final Peer peer;
+
+    private final DataOutputStream dout;
+
+    private Thread thread;
+
+    private boolean quit;
+
+    private List&lt;Message&gt; sendQueue = new ArrayList&lt;Message&gt;();
+
+    public PeerConnectionOut (Peer peer, DataOutputStream dout)
+    {
+        this.peer = peer;
+        this.dout = dout;
+
+        quit = false;
+        thread = new Thread(this);
+        thread.start();
+    }
+
+    /**
+     * Continuesly monitors for more outgoing messages that have to be send.
+     * Stops if quit is true of an IOException occurs.
+     */
+    public void run ()
+    {
+        try {
+            while (!quit) {
+                Message m = null;
+                PeerState state = null;
+                synchronized (sendQueue) {
+                    while (!quit &amp;&amp; sendQueue.isEmpty()) {
+                        try {
+                            // Make sure everything will reach the other side.
+                            dout.flush();
+
+                            // Wait till more data arrives.
+                            sendQueue.wait();
+                        } catch (InterruptedException ie) {
+                            /* ignored */
+                        }
+                    }
+                    state = peer.state;
+                    if (!quit &amp;&amp; state != null) {
+                        // Piece messages are big. So if there are other
+                        // (control) messages make sure they are send first.
+                        // Also remove request messages from the queue if
+                        // we are currently being choked to prevent them from
+                        // being send even if we get unchoked a little later.
+                        // (Since we will resent them anyway in that case.)
+                        // And remove piece messages if we are choking.
+                        Iterator it = sendQueue.iterator();
+                        while (m == null &amp;&amp; it.hasNext()) {
+                            Message nm = (Message)it.next();
+                            if (nm.type == Message.PIECE) {
+                                if (state.choking) {
+                                    it.remove();
+                                }
+                                nm = null;
+                            } else if (nm.type == Message.REQUEST
+                                &amp;&amp; state.choked) {
+                                it.remove();
+                                nm = null;
+                            }
+
+                            if (m == null &amp;&amp; nm != null) {
+                                m = nm;
+                                it.remove();
+                            }
+                        }
+                        if (m == null &amp;&amp; sendQueue.size() &gt; 0) {
+                            m = sendQueue.remove(0);
+                        }
+                    }
+                }
+                if (m != null) {
+                    log.log(Level.ALL, &quot;Send &quot; + peer + &quot;: &quot; + m);
+                    m.sendMessage(dout);
+
+                    // Remove all piece messages after sending a choke message.
+                    if (m.type == Message.CHOKE) {
+                        removeMessage(Message.PIECE);
+                    }
+
+                    // XXX - Should also register overhead...
+                    if (m.type == Message.PIECE) {
+                        state.uploaded(m.len);
+                    }
+
+                    m = null;
+                }
+            }
+        } catch (IOException ioe) {
+            // Ignore, probably other side closed connection.
+        } catch (Throwable t) {
+            log.log(Level.SEVERE, peer + &quot; failed&quot;, t);
+        } finally {
+            quit = true;
+            peer.disconnect();
+        }
+    }
+
+    public void disconnect ()
+    {
+        synchronized (sendQueue) {
+            if (quit == true) {
+                return;
+            }
+
+            quit = true;
+            thread.interrupt();
+
+            sendQueue.clear();
+            sendQueue.notify();
+        }
+    }
+
+    /**
+     * Adds a message to the sendQueue and notifies the method waiting on the
+     * sendQueue to change.
+     */
+    private void addMessage (Message m)
+    {
+        synchronized (sendQueue) {
+            sendQueue.add(m);
+            sendQueue.notify();
+        }
+    }
+
+    /**
+     * Removes a particular message type from the queue.
+     * 
+     * @param type
+     *            the Message type to remove.
+     * @returns true when a message of the given type was removed, false
+     *          otherwise.
+     */
+    private boolean removeMessage (int type)
+    {
+        boolean removed = false;
+        synchronized (sendQueue) {
+            Iterator it = sendQueue.iterator();
+            while (it.hasNext()) {
+                Message m = (Message)it.next();
+                if (m.type == type) {
+                    it.remove();
+                    removed = true;
+                }
+            }
+        }
+        return removed;
+    }
+
+    void sendAlive ()
+    {
+        Message m = new Message();
+        m.type = Message.KEEP_ALIVE;
+        addMessage(m);
+    }
+
+    void sendChoke (boolean choke)
+    {
+        // We cancel the (un)choke but keep PIECE messages.
+        // PIECE messages are purged if a choke is actually send.
+        synchronized (sendQueue) {
+            int inverseType = choke ? Message.UNCHOKE : Message.CHOKE;
+            if (!removeMessage(inverseType)) {
+                Message m = new Message();
+                if (choke) {
+                    m.type = Message.CHOKE;
+                } else {
+                    m.type = Message.UNCHOKE;
+                }
+                addMessage(m);
+            }
+        }
+    }
+
+    void sendInterest (boolean interest)
+    {
+        synchronized (sendQueue) {
+            int inverseType = interest ? Message.UNINTERESTED
+                : Message.INTERESTED;
+            if (!removeMessage(inverseType)) {
+                Message m = new Message();
+                if (interest) {
+                    m.type = Message.INTERESTED;
+                } else {
+                    m.type = Message.UNINTERESTED;
+                }
+                addMessage(m);
+            }
+        }
+    }
+
+    void sendHave (int piece)
+    {
+        Message m = new Message();
+        m.type = Message.HAVE;
+        m.piece = piece;
+        addMessage(m);
+    }
+
+    void sendBitfield (BitField bitfield)
+    {
+        Message m = new Message();
+        m.type = Message.BITFIELD;
+        m.data = bitfield.getFieldBytes();
+        m.off = 0;
+        m.len = m.data.length;
+        addMessage(m);
+    }
+
+    void sendRequests (List requests)
+    {
+        Iterator it = requests.iterator();
+        while (it.hasNext()) {
+            Request req = (Request)it.next();
+            sendRequest(req);
+        }
+    }
+
+    void sendRequest (Request req)
+    {
+        Message m = new Message();
+        m.type = Message.REQUEST;
+        m.piece = req.piece;
+        m.begin = req.off;
+        m.length = req.len;
+        addMessage(m);
+    }
+
+    void sendPiece (int piece, int begin, int length, byte[] bytes)
+    {
+        Message m = new Message();
+        m.type = Message.PIECE;
+        m.piece = piece;
+        m.begin = begin;
+        m.length = length;
+        m.data = bytes;
+        m.off = begin;
+        m.len = length;
+        addMessage(m);
+    }
+
+    void sendCancel (Request req)
+    {
+        // See if it is still in our send queue
+        synchronized (sendQueue) {
+            Iterator it = sendQueue.iterator();
+            while (it.hasNext()) {
+                Message m = (Message)it.next();
+                if (m.type == Message.REQUEST &amp;&amp; m.piece == req.piece
+                    &amp;&amp; m.begin == req.off &amp;&amp; m.length == req.len) {
+                    it.remove();
+                }
+            }
+        }
+
+        // Always send, just to be sure it it is really canceled.
+        Message m = new Message();
+        m.type = Message.CANCEL;
+        m.piece = req.piece;
+        m.begin = req.off;
+        m.length = req.len;
+        addMessage(m);
+    }
+
+    // Called by the PeerState when the other side doesn't want this
+    // request to be handled anymore. Removes any pending Piece Message
+    // from out send queue.
+    void cancelRequest (int piece, int begin, int length)
+    {
+        synchronized (sendQueue) {
+            Iterator it = sendQueue.iterator();
+            while (it.hasNext()) {
+                Message m = (Message)it.next();
+                if (m.type == Message.PIECE &amp;&amp; m.piece == piece
+                    &amp;&amp; m.begin == begin &amp;&amp; m.length == length) {
+                    it.remove();
+                }
+            }
+        }
+    }
+
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.peer&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerCoordinator.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerCoordinator.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerCoordinator.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,498 @@
+/*
+ * PeerCoordinator - Coordinates which peers do what (up and downloading).
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Timer;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Coordinates what peer does what.
+ */
+public class PeerCoordinator implements PeerListener
+{
+    final MetaInfo metainfo;
+
+    final Storage storage;
+
+    // package local for access by CheckDownLoadersTask
+    final static long CHECK_PERIOD = 20 * 1000; // 20 seconds
+
+    final static int MAX_CONNECTIONS = 24;
+
+    final static int MAX_UPLOADERS = 4;
+
+    // Approximation of the number of current uploaders.
+    // Resynced by PeerChecker once in a while.
+    int uploaders = 0;
+
+    // final static int MAX_DOWNLOADERS = MAX_CONNECTIONS;
+    // int downloaders = 0;
+
+    private long uploaded;
+
+    private long downloaded;
+
+    // synchronize on this when changing peers or downloaders
+    public final List&lt;Peer&gt; peers = new ArrayList&lt;Peer&gt;();
+
+    /** Timer to handle all periodical tasks. */
+    private final Timer timer = new Timer(true);
+
+    private final byte[] id;
+
+    // Some random wanted pieces
+    private final List&lt;Integer&gt; wantedPieces;
+
+    private boolean halted = false;
+
+    private final CoordinatorListener listener;
+
+    private TrackerClient client;
+
+    public PeerCoordinator (byte[] id, MetaInfo metainfo, Storage storage,
+        CoordinatorListener listener)
+    {
+        this.id = id;
+        this.metainfo = metainfo;
+        this.storage = storage;
+        this.listener = listener;
+
+        // Make a random list of piece numbers
+        wantedPieces = new ArrayList&lt;Integer&gt;();
+        BitField bitfield = storage.getBitField();
+        for (int i = 0; i &lt; metainfo.getPieces(); i++) {
+            if (!bitfield.get(i)) {
+                wantedPieces.add(i);
+            }
+        }
+        Collections.shuffle(wantedPieces);
+
+        // Install a timer to check the uploaders.
+        timer.schedule(new PeerCheckerTask(this), CHECK_PERIOD, CHECK_PERIOD);
+    }
+
+    public void setTracker (TrackerClient client)
+    {
+        this.client = client;
+    }
+
+    public byte[] getID ()
+    {
+        return id;
+    }
+
+    public boolean completed ()
+    {
+        return storage.complete();
+    }
+
+    public int getPeers ()
+    {
+        synchronized (peers) {
+            return peers.size();
+        }
+    }
+
+    /**
+     * Returns how many bytes are still needed to get the complete file.
+     */
+    public long getLeft ()
+    {
+        // XXX - Only an approximation.
+        return storage.needed() * metainfo.getPieceLength(0);
+    }
+
+    /**
+     * Returns the total number of uploaded bytes of all peers.
+     */
+    public long getUploaded ()
+    {
+        return uploaded;
+    }
+
+    /**
+     * Returns the total number of downloaded bytes of all peers.
+     */
+    public long getDownloaded ()
+    {
+        return downloaded;
+    }
+
+    public MetaInfo getMetaInfo ()
+    {
+        return metainfo;
+    }
+
+    public boolean needPeers ()
+    {
+        synchronized (peers) {
+            return !halted &amp;&amp; peers.size() &lt; MAX_CONNECTIONS;
+        }
+    }
+
+    public void halt ()
+    {
+        halted = true;
+        synchronized (peers) {
+            // Stop peer checker task.
+            timer.cancel();
+
+            // Stop peers.
+            Iterator it = peers.iterator();
+            while (it.hasNext()) {
+                Peer peer = (Peer)it.next();
+                peer.disconnect();
+                it.remove();
+            }
+        }
+    }
+
+    public void connected (Peer peer)
+    {
+        if (halted) {
+            peer.disconnect(false);
+            return;
+        }
+
+        synchronized (peers) {
+            if (peerIDInList(peer.getPeerID(), peers)) {
+                log.log(Level.FINER, &quot;Already connected to: &quot; + peer);
+                peer.disconnect(false); // Don't deregister this
+                // connection/peer.
+            } else {
+                log.log(Level.FINER, &quot;New connection to peer: &quot; + peer);
+
+                // Add it to the beginning of the list.
+                // And try to optimistically make it a uploader.
+                peers.add(0, peer);
+                unchokePeer();
+
+                if (listener != null) {
+                    listener.peerChange(this, peer);
+                }
+            }
+        }
+    }
+
+    private static boolean peerIDInList (PeerID pid, List peers)
+    {
+        Iterator it = peers.iterator();
+        while (it.hasNext()) {
+            if (pid.sameID(((Peer)it.next()).getPeerID())) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void addPeer (final Peer peer)
+    {
+        if (halted) {
+            peer.disconnect(false);
+            return;
+        }
+
+        boolean need_more;
+        synchronized (peers) {
+            need_more = !peer.isConnected() &amp;&amp; peers.size() &lt; MAX_CONNECTIONS;
+        }
+
+        if (need_more) {
+            // Run the peer with us as listener and the current bitfield.
+            final PeerListener listener = this;
+            final BitField bitfield = storage.getBitField();
+            Runnable r = new Runnable() {
+                public void run ()
+                {
+                    peer.runConnection(listener, bitfield);
+                }
+            };
+            String threadName = peer.toString();
+            new Thread(r, threadName).start();
+        } else if (log.getLevel().intValue() &lt;= Level.FINER.intValue()) {
+            if (peer.isConnected()) {
+                log.log(Level.FINER, &quot;Add peer already connected: &quot; + peer);
+            } else {
+                log.log(Level.FINER, &quot;MAX_CONNECTIONS = &quot; + MAX_CONNECTIONS
+                    + &quot; not accepting extra peer: &quot; + peer);
+            }
+        }
+    }
+
+    // (Optimistically) unchoke. Should be called with peers synchronized
+    void unchokePeer ()
+    {
+        // linked list will contain all interested peers that we choke.
+        // At the start are the peers that have us unchoked at the end the
+        // other peer that are interested, but are choking us.
+        List&lt;Peer&gt; interested = new LinkedList&lt;Peer&gt;();
+        Iterator it = peers.iterator();
+        while (it.hasNext()) {
+            Peer peer = (Peer)it.next();
+            if (uploaders &lt; MAX_UPLOADERS &amp;&amp; peer.isChoking()
+                &amp;&amp; peer.isInterested()) {
+                if (!peer.isChoked()) {
+                    interested.add(0, peer);
+                } else {
+                    interested.add(peer);
+                }
+            }
+        }
+
+        while (uploaders &lt; MAX_UPLOADERS &amp;&amp; interested.size() &gt; 0) {
+            Peer peer = interested.remove(0);
+            log.log(Level.FINER, &quot;Unchoke: &quot; + peer);
+            peer.setChoking(false);
+            uploaders++;
+            // Put peer back at the end of the list.
+            peers.remove(peer);
+            peers.add(peer);
+        }
+    }
+
+    public byte[] getBitMap ()
+    {
+        return storage.getBitField().getFieldBytes();
+    }
+
+    /**
+     * Returns true if we don't have the given piece yet.
+     */
+    public boolean gotHave (Peer peer, int piece)
+    {
+        if (listener != null) {
+            listener.peerChange(this, peer);
+        }
+
+        synchronized (wantedPieces) {
+            return wantedPieces.contains(new Integer(piece));
+        }
+    }
+
+    /**
+     * Returns true if the given bitfield contains at least one piece we are
+     * interested in.
+     */
+    public boolean gotBitField (Peer peer, BitField bitfield)
+    {
+        if (listener != null) {
+            listener.peerChange(this, peer);
+        }
+
+        synchronized (wantedPieces) {
+            Iterator it = wantedPieces.iterator();
+            while (it.hasNext()) {
+                int i = ((Integer)it.next()).intValue();
+                if (bitfield.get(i)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns one of pieces in the given BitField that is still wanted or -1 if
+     * none of the given pieces are wanted.
+     */
+    public int wantPiece (Peer peer, BitField havePieces)
+    {
+        if (halted) {
+            return -1;
+        }
+
+        synchronized (wantedPieces) {
+            Integer piece = null;
+            Iterator it = wantedPieces.iterator();
+            while (piece == null &amp;&amp; it.hasNext()) {
+                Integer i = (Integer)it.next();
+                if (havePieces.get(i.intValue())) {
+                    it.remove();
+                    piece = i;
+                }
+            }
+
+            if (piece == null) {
+                return -1;
+            }
+
+            // We add it back at the back of the list. It will be removed
+            // if gotPiece is called later. This means that the last
+            // couple of pieces might very well be asked from multiple
+            // peers but that is OK.
+            wantedPieces.add(piece);
+
+            return piece.intValue();
+        }
+    }
+
+    /**
+     * Returns a byte array containing the requested piece or null of the piece
+     * is unknown.
+     */
+    public byte[] gotRequest (Peer peer, int piece)
+        throws IOException
+    {
+        if (halted) {
+            return null;
+        }
+
+        try {
+            return storage.getPiece(piece);
+        } catch (IOException ioe) {
+            Snark.abort(&quot;Error reading storage&quot;, ioe);
+            return null; // Never reached.
+        }
+    }
+
+    /**
+     * Called when a peer has uploaded some bytes of a piece.
+     */
+    public void uploaded (Peer peer, int size)
+    {
+        uploaded += size;
+
+        if (listener != null) {
+            listener.peerChange(this, peer);
+        }
+    }
+
+    /**
+     * Called when a peer has downloaded some bytes of a piece.
+     */
+    public void downloaded (Peer peer, int size)
+    {
+        downloaded += size;
+
+        if (listener != null) {
+            listener.peerChange(this, peer);
+        }
+    }
+
+    /**
+     * Returns false if the piece is no good (according to the hash). In that
+     * case the peer that supplied the piece should probably be blacklisted.
+     */
+    public boolean gotPiece (Peer peer, int piece, byte[] bs)
+        throws IOException
+    {
+        if (halted) {
+            return true; // We don't actually care anymore.
+        }
+
+        synchronized (wantedPieces) {
+            Integer p = new Integer(piece);
+            if (!wantedPieces.contains(p)) {
+                log.log(Level.FINER, peer + &quot; piece &quot; + piece
+                    + &quot; no longer needed&quot;);
+
+                // No need to announce have piece to peers.
+                // Assume we got a good piece, we don't really care anymore.
+                return true;
+            }
+
+            try {
+                if (storage.putPiece(piece, bs)) {
+                    log.log(Level.FINER, &quot;Recv p&quot; + piece + &quot; &quot; + peer);
+                } else {
+                    // Oops. We didn't actually download this then... :(
+                    downloaded -= metainfo.getPieceLength(piece);
+                    log.log(Level.INFO, &quot;Got BAD piece &quot; + piece + &quot; from &quot;
+                        + peer);
+                    return false; // No need to announce BAD piece to peers.
+                }
+            } catch (IOException ioe) {
+                Snark.abort(&quot;Error writing storage&quot;, ioe);
+            }
+            wantedPieces.remove(p);
+        }
+
+        // Announce to the world we have it!
+        synchronized (peers) {
+            Iterator it = peers.iterator();
+            while (it.hasNext()) {
+                Peer p = (Peer)it.next();
+                if (p.isConnected()) {
+                    p.have(piece);
+                }
+            }
+        }
+
+        if (completed()) {
+            client.interrupt();
+        }
+        return true;
+    }
+
+    public void gotChoke (Peer peer, boolean choke)
+    {
+        log.log(Level.FINER, &quot;Got choke(&quot; + choke + &quot;): &quot; + peer);
+
+        if (listener != null) {
+            listener.peerChange(this, peer);
+        }
+    }
+
+    public void gotInterest (Peer peer, boolean interest)
+    {
+        if (interest) {
+            synchronized (peers) {
+                if (uploaders &lt; MAX_UPLOADERS) {
+                    if (peer.isChoking()) {
+                        uploaders++;
+                        peer.setChoking(false);
+                        log.log(Level.FINER, &quot;Unchoke: &quot; + peer);
+                    }
+                }
+            }
+        }
+
+        if (listener != null) {
+            listener.peerChange(this, peer);
+        }
+    }
+
+    public void disconnected (Peer peer)
+    {
+        log.log(Level.FINER, &quot;Disconnected &quot; + peer);
+
+        synchronized (peers) {
+            // Make sure it is no longer in our lists
+            if (peers.remove(peer)) {
+                // Unchoke some random other peer
+                unchokePeer();
+            }
+        }
+
+        if (listener != null) {
+            listener.peerChange(this, peer);
+        }
+    }
+
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.peer&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerID.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerID.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerID.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,210 @@
+/*
+ * PeerID - All public information concerning a peer. Copyright (C) 2003 Mark J.
+ * Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Map;
+
+import org.klomp.snark.bencode.BDecoder;
+import org.klomp.snark.bencode.BEValue;
+import org.klomp.snark.bencode.InvalidBEncodingException;
+
+public class PeerID implements Comparable
+{
+    private final byte[] id;
+
+    private final InetAddress address;
+
+    private final int port;
+
+    private final int hash;
+
+    public PeerID (byte[] id, InetAddress address, int port)
+    {
+        this.id = id;
+        this.address = address;
+        this.port = port;
+
+        hash = calculateHash();
+    }
+
+    /**
+     * Creates a PeerID from a BDecoder.
+     */
+    public PeerID (BDecoder be) throws IOException
+    {
+        this(be.bdecodeMap().getMap());
+    }
+
+    /**
+     * Creates a PeerID from a Map containing BEncoded peer id, ip and port.
+     */
+    public PeerID (Map m)
+        throws InvalidBEncodingException, UnknownHostException
+    {
+        BEValue bevalue = (BEValue)m.get(&quot;peer id&quot;);
+        if (bevalue == null) {
+            throw new InvalidBEncodingException(&quot;peer id missing&quot;);
+        }
+        id = bevalue.getBytes();
+
+        bevalue = (BEValue)m.get(&quot;ip&quot;);
+        if (bevalue == null) {
+            throw new InvalidBEncodingException(&quot;ip missing&quot;);
+        }
+        address = InetAddress.getByName(bevalue.getString());
+
+        bevalue = (BEValue)m.get(&quot;port&quot;);
+        if (bevalue == null) {
+            throw new InvalidBEncodingException(&quot;port missing&quot;);
+        }
+        port = bevalue.getInt();
+
+        hash = calculateHash();
+    }
+
+    public byte[] getID ()
+    {
+        return id;
+    }
+
+    public InetAddress getAddress ()
+    {
+        return address;
+    }
+
+    public int getPort ()
+    {
+        return port;
+    }
+
+    private int calculateHash ()
+    {
+        int b = 0;
+        for (byte element : id) {
+            b ^= element;
+        }
+        return (b ^ address.hashCode()) ^ port;
+    }
+
+    /**
+     * The hash code of a PeerID is the exclusive or of all id bytes.
+     */
+    @Override
+    public int hashCode ()
+    {
+        return hash;
+    }
+
+    /**
+     * Returns true if and only if this peerID and the given peerID have the
+     * same 20 bytes as ID.
+     */
+    public boolean sameID (PeerID pid)
+    {
+        boolean equal = true;
+        for (int i = 0; equal &amp;&amp; i &lt; id.length; i++) {
+            equal = id[i] == pid.id[i];
+        }
+        return equal;
+    }
+
+    /**
+     * Two PeerIDs are equal when they have the same id, address and port.
+     */
+    @Override
+    public boolean equals (Object o)
+    {
+        if (o instanceof PeerID) {
+            PeerID pid = (PeerID)o;
+
+            return port == pid.port &amp;&amp; address.equals(pid.address)
+                &amp;&amp; sameID(pid);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Compares port, address and id.
+     */
+    public int compareTo (Object o)
+    {
+        PeerID pid = (PeerID)o;
+
+        int result = port - pid.port;
+        if (result != 0) {
+            return result;
+        }
+
+        result = address.hashCode() - pid.address.hashCode();
+        if (result != 0) {
+            return result;
+        }
+
+        for (byte element : id) {
+            result = element - element;
+            if (result != 0) {
+                return result;
+            }
+        }
+
+        return 0;
+    }
+
+    /**
+     * Returns the String &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">id at address</A>:port&quot; where id is the hex encoded id with
+     * leading zeros removed.
+     */
+    @Override
+    public String toString ()
+    {
+        return idencode(id) + &quot;@&quot; + address + &quot;:&quot; + port;
+    }
+
+    /**
+     * Encode an id as a hex encoded string and remove leading zeros.
+     */
+    public static String idencode (byte[] bs)
+    {
+        boolean leading_zeros = true;
+
+        StringBuffer sb = new StringBuffer(bs.length * 2);
+        for (byte element : bs) {
+            int c = element &amp; 0xFF;
+            if (leading_zeros &amp;&amp; c == 0) {
+                continue;
+            } else {
+                leading_zeros = false;
+            }
+
+            if (c &lt; 16) {
+                sb.append('0');
+            }
+            sb.append(Integer.toHexString(c));
+        }
+
+        return sb.toString();
+    }
+
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerListener.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerListener.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerListener.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,166 @@
+/*
+ * PeerListener - Interface for listening to peer events. Copyright (C) 2003
+ * Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.IOException;
+
+/**
+ * Listener for Peer events.
+ */
+public interface PeerListener
+{
+    /**
+     * Called when the connection to the peer has started and the handshake was
+     * successfull.
+     * 
+     * @param peer
+     *            the Peer that just got connected.
+     */
+    void connected (Peer peer);
+
+    /**
+     * Called when the connection to the peer was terminated or the connection
+     * handshake failed.
+     * 
+     * @param peer
+     *            the Peer that just got disconnected.
+     */
+    void disconnected (Peer peer);
+
+    /**
+     * Called when a choke message is received.
+     * 
+     * @param peer
+     *            the Peer that got the message.
+     * @param choke
+     *            true when the peer got a choke message, false when the peer
+     *            got an unchoke message.
+     */
+    void gotChoke (Peer peer, boolean choke);
+
+    /**
+     * Called when an interested message is received.
+     * 
+     * @param peer
+     *            the Peer that got the message.
+     * @param interest
+     *            true when the peer got a interested message, false when the
+     *            peer got an uninterested message.
+     */
+    void gotInterest (Peer peer, boolean interest);
+
+    /**
+     * Called when a have piece message is received. If the method returns true
+     * and the peer has not yet received a interested message or we indicated
+     * earlier to be not interested then an interested message will be send.
+     * 
+     * @param peer
+     *            the Peer that got the message.
+     * @param piece
+     *            the piece number that the per just got.
+     * 
+     * @return true when it is a piece that we want, false if the piece is
+     *         already known.
+     */
+    boolean gotHave (Peer peer, int piece);
+
+    /**
+     * Called when a bitmap message is received. If this method returns true a
+     * interested message will be send back to the peer.
+     * 
+     * @param peer
+     *            the Peer that got the message.
+     * @param bitfield
+     *            a BitField containing the pieces that the other side has.
+     * 
+     * @return true when the BitField contains pieces we want, false if the
+     *         piece is already known.
+     */
+    boolean gotBitField (Peer peer, BitField bitfield);
+
+    /**
+     * Called when a piece is received from the peer. The piece must be
+     * requested by Peer.request() first. If this method returns false that
+     * means the Peer provided a corrupted piece and the connection will be
+     * closed.
+     * 
+     * @param peer
+     *            the Peer that got the piece.
+     * @param piece
+     *            the piece number received.
+     * @param bs
+     *            the byte array containing the piece.
+     * 
+     * @return true when the bytes represent the piece, false otherwise.
+     * @throws IOException 
+     */
+    boolean gotPiece (Peer peer, int piece, byte[] bs) throws IOException;
+
+    /**
+     * Called when the peer wants (part of) a piece from us. Only called when
+     * the peer is not choked by us (&lt;code&gt;peer.choke(false)&lt;/code&gt; was
+     * called).
+     * 
+     * @param peer
+     *            the Peer that wants the piece.
+     * @param piece
+     *            the piece number requested.
+     * 
+     * @return a byte array containing the piece or null when the piece is not
+     *         available (which is a protocol error).
+     */
+    byte[] gotRequest (Peer peer, int piece) throws IOException;
+
+    /**
+     * Called when a (partial) piece has been downloaded from the peer.
+     * 
+     * @param peer
+     *            the Peer from which size bytes where downloaded.
+     * @param size
+     *            the number of bytes that where downloaded.
+     */
+    void downloaded (Peer peer, int size);
+
+    /**
+     * Called when a (partial) piece has been uploaded to the peer.
+     * 
+     * @param peer
+     *            the Peer to which size bytes where uploaded.
+     * @param size
+     *            the number of bytes that where uploaded.
+     */
+    void uploaded (Peer peer, int size);
+
+    /**
+     * Called when we are downloading from the peer and need to ask for a new
+     * piece. Might be called multiple times before &lt;code&gt;gotPiece()&lt;/code&gt; is
+     * called.
+     * 
+     * @param peer
+     *            the Peer that will be asked to provide the piece.
+     * @param bitfield
+     *            a BitField containing the pieces that the other side has.
+     * 
+     * @return one of the pieces from the bitfield that we want or -1 if we are
+     *         no longer interested in the peer.
+     */
+    int wantPiece (Peer peer, BitField bitfield);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerMonitorTask.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerMonitorTask.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerMonitorTask.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,130 @@
+/*
+ * PeerMonitorTasks - TimerTask that monitors the peers and total up/down speed
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.util.Iterator;
+import java.util.TimerTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * TimerTask that monitors the peers and total up/download speeds. Works
+ * together with the main Snark class to report periodical statistics.
+ */
+public class PeerMonitorTask extends TimerTask
+{
+    public static final long MONITOR_PERIOD = 10 * 1000; // Ten seconds.
+
+    private static final long KILOPERSECOND = 1024 * (MONITOR_PERIOD / 1000);
+
+    private final PeerCoordinator coordinator;
+
+    private long lastDownloaded = 0;
+
+    private long lastUploaded = 0;
+
+    public PeerMonitorTask (PeerCoordinator coordinator)
+    {
+        this.coordinator = coordinator;
+    }
+
+    @Override
+    public void run ()
+    {
+        // Get some statistics
+        int peers = 0;
+        int uploaders = 0;
+        int downloaders = 0;
+        int interested = 0;
+        int interesting = 0;
+        int choking = 0;
+        int choked = 0;
+
+        synchronized (coordinator.peers) {
+            Iterator it = coordinator.peers.iterator();
+            while (it.hasNext()) {
+                Peer peer = (Peer)it.next();
+
+                // Don't list dying peers
+                if (!peer.isConnected()) {
+                    continue;
+                }
+
+                peers++;
+
+                if (!peer.isChoking()) {
+                    uploaders++;
+                }
+                if (!peer.isChoked() &amp;&amp; peer.isInteresting()) {
+                    downloaders++;
+                }
+                if (peer.isInterested()) {
+                    interested++;
+                }
+                if (peer.isInteresting()) {
+                    interesting++;
+                }
+                if (peer.isChoking()) {
+                    choking++;
+                }
+                if (peer.isChoked()) {
+                    choked++;
+                }
+            }
+        }
+
+        // Print some statistics
+        long downloaded = coordinator.getDownloaded();
+        String totalDown;
+        if (downloaded &gt;= 10 * 1024 * 1024) {
+            totalDown = (downloaded / (1024 * 1024)) + &quot;MB&quot;;
+        } else {
+            totalDown = (downloaded / 1024) + &quot;KB&quot;;
+        }
+        long uploaded = coordinator.getUploaded();
+        String totalUp;
+        if (uploaded &gt;= 10 * 1024 * 1024) {
+            totalUp = (uploaded / (1024 * 1024)) + &quot;MB&quot;;
+        } else {
+            totalUp = (uploaded / 1024) + &quot;KB&quot;;
+        }
+
+        int needP = coordinator.storage.needed();
+        long needMB = needP * coordinator.metainfo.getPieceLength(0)
+            / (1024 * 1024);
+        int totalP = coordinator.metainfo.getPieces();
+        long totalMB = coordinator.metainfo.getTotalLength() / (1024 * 1024);
+
+        log.log(Level.INFO, &quot;Down: &quot; + (downloaded - lastDownloaded)
+            / KILOPERSECOND + &quot;KB/s&quot; + &quot; (&quot; + totalDown + &quot;)&quot; + &quot; Up: &quot;
+            + (uploaded - lastUploaded) / KILOPERSECOND + &quot;KB/s&quot; + &quot; (&quot;
+            + totalUp + &quot;)&quot; + &quot; Need &quot; + needP + &quot; (&quot; + needMB + &quot;MB)&quot; + &quot; of &quot;
+            + totalP + &quot; (&quot; + totalMB + &quot;MB)&quot; + &quot; pieces&quot;);
+        log.log(Level.INFO, peers + &quot;: Download #&quot; + downloaders + &quot; Upload #&quot;
+            + uploaders + &quot; Interested #&quot; + interested + &quot; Interesting #&quot;
+            + interesting + &quot; Choking #&quot; + choking + &quot; Choked #&quot; + choked);
+        lastDownloaded = downloaded;
+        lastUploaded = uploaded;
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.status&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/PeerState.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/PeerState.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/PeerState.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,481 @@
+/*
+ * PeerState - Keeps track of the Peer state through connection callbacks.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+class PeerState
+{
+    final Peer peer;
+
+    final PeerListener listener;
+
+    final MetaInfo metainfo;
+
+    // Interesting and choking describes whether we are interested in or
+    // are choking the other side.
+    boolean interesting = false;
+
+    boolean choking = true;
+
+    // Interested and choked describes whether the other side is
+    // interested in us or choked us.
+    boolean interested = false;
+
+    boolean choked = true;
+
+    // Package local for use by Peer.
+    long downloaded;
+
+    long uploaded;
+
+    BitField bitfield;
+
+    // Package local for use by Peer.
+    final PeerConnectionIn in;
+
+    final PeerConnectionOut out;
+
+    // Outstanding request
+    private final List&lt;Request&gt; outstandingRequests = new ArrayList&lt;Request&gt;();
+
+    private Request lastRequest = null;
+
+    // If we have te resend outstanding requests (true after we got choked).
+    private boolean resend = false;
+
+    private final static int MAX_PIPELINE = 5;
+
+    private final static int PARTSIZE = 16384; // 16K
+
+    PeerState (Peer peer, PeerListener listener, MetaInfo metainfo,
+        PeerConnectionIn in, PeerConnectionOut out)
+    {
+        this.peer = peer;
+        this.listener = listener;
+        this.metainfo = metainfo;
+
+        this.in = in;
+        this.out = out;
+    }
+
+    // NOTE Methods that inspect or change the state synchronize (on this).
+
+    void keepAliveMessage ()
+    {
+        log.log(Level.FINEST, peer + &quot; rcv alive&quot;);
+        /* XXX - ignored */
+    }
+
+    void chokeMessage (boolean choke)
+    {
+        log.log(Level.FINEST, peer + &quot; rcv &quot; + (choke ? &quot;&quot; : &quot;un&quot;) + &quot;choked&quot;);
+
+        choked = choke;
+        if (choked) {
+            resend = true;
+        }
+
+        listener.gotChoke(peer, choke);
+
+        if (!choked &amp;&amp; interesting) {
+            request();
+        }
+    }
+
+    void interestedMessage (boolean interest)
+    {
+        log.log(Level.FINEST, peer + &quot; rcv &quot; + (interest ? &quot;&quot; : &quot;un&quot;)
+            + &quot;interested&quot;);
+        interested = interest;
+        listener.gotInterest(peer, interest);
+    }
+
+    void haveMessage (int piece)
+    {
+        log.log(Level.FINEST, peer + &quot; rcv have(&quot; + piece + &quot;)&quot;);
+        // Sanity check
+        if (piece &lt; 0 || piece &gt;= metainfo.getPieces()) {
+            // XXX disconnect?
+            log.log(Level.FINER, &quot;Got strange 'have: &quot; + piece
+                + &quot;' message from &quot; + peer);
+            return;
+        }
+
+        synchronized (this) {
+            // Can happen if the other side never send a bitfield message.
+            if (bitfield == null) {
+                bitfield = new BitField(metainfo.getPieces());
+            }
+
+            bitfield.set(piece);
+        }
+
+        if (listener.gotHave(peer, piece)) {
+            setInteresting(true);
+        }
+    }
+
+    void bitfieldMessage (byte[] bitmap)
+    {
+        synchronized (this) {
+            log.log(Level.FINEST, peer + &quot; rcv bitfield&quot;);
+            if (bitfield != null) {
+                // XXX - Be liberal in what you accept?
+                log.log(Level.FINER, &quot;Got unexpected bitfield message from &quot;
+                    + peer);
+                return;
+            }
+
+            // XXX - Check for weird bitfield and disconnect?
+            bitfield = new BitField(bitmap, metainfo.getPieces());
+        }
+        setInteresting(listener.gotBitField(peer, bitfield));
+    }
+
+    void requestMessage (int piece, int begin, int length)
+        throws IOException
+    {
+        log.log(Level.FINEST, peer + &quot; rcv request(&quot; + piece + &quot;, &quot; + begin
+            + &quot;, &quot; + length + &quot;) &quot;);
+        if (choking) {
+            log.log(Level.FINER, &quot;Request received, but choking &quot; + peer);
+            return;
+        }
+
+        // Sanity check
+        if (piece &lt; 0 || piece &gt;= metainfo.getPieces() || begin &lt; 0
+            || begin &gt; metainfo.getPieceLength(piece) || length &lt;= 0
+            || length &gt; 4 * PARTSIZE) {
+            // XXX - Protocol error -&gt; disconnect?
+            log.log(Level.FINER, &quot;Got strange 'request: &quot; + piece + &quot;, &quot;
+                + begin + &quot;, &quot; + length + &quot;' message from &quot; + peer);
+            return;
+        }
+
+        byte[] pieceBytes = listener.gotRequest(peer, piece);
+        if (pieceBytes == null) {
+            // XXX - Protocol error-&gt; diconnect?
+            log.log(Level.FINER, &quot;Got request for unknown piece: &quot; + piece);
+            return;
+        }
+
+        // More sanity checks
+        if (begin &gt;= pieceBytes.length || begin + length &gt; pieceBytes.length) {
+            // XXX - Protocol error-&gt; disconnect?
+            log.log(Level.FINER, &quot;Got out of range 'request: &quot; + piece + &quot;, &quot;
+                + begin + &quot;, &quot; + length + &quot;' message from &quot; + peer);
+            return;
+        }
+
+        log.log(Level.FINEST, &quot;Sending (&quot; + piece + &quot;, &quot; + begin + &quot;, &quot;
+            + length + &quot;)&quot; + &quot; to &quot; + peer);
+        out.sendPiece(piece, begin, length, pieceBytes);
+
+        // Tell about last subpiece delivery.
+        if (begin + length == pieceBytes.length) {
+            log.log(Level.FINEST, &quot;Send p&quot; + piece + &quot; &quot; + peer);
+        }
+    }
+
+    /**
+     * Called when some bytes have left the outgoing connection. XXX - Should
+     * indicate whether it was a real piece or overhead.
+     */
+    void uploaded (int size)
+    {
+        uploaded += size;
+        listener.uploaded(peer, size);
+    }
+
+    /**
+     * Called when a partial piece request has been handled by PeerConnectionIn.
+     */
+    void pieceMessage (Request req)
+        throws IOException
+    {
+        int size = req.len;
+        downloaded += size;
+        listener.downloaded(peer, size);
+
+        // Last chunk needed for this piece?
+        if (getFirstOutstandingRequest(req.piece) == -1) {
+            if (listener.gotPiece(peer, req.piece, req.bs)) {
+                log.log(Level.FINEST, &quot;Got &quot; + req.piece + &quot;: &quot; + peer);
+            } else {
+                log.log(Level.FINEST, &quot;Got BAD &quot; + req.piece + &quot; from &quot; + peer);
+                // XXX ARGH What now !?!
+                downloaded = 0;
+            }
+        }
+    }
+
+    synchronized private int getFirstOutstandingRequest (int piece)
+    {
+        for (int i = 0; i &lt; outstandingRequests.size(); i++) {
+            if ((outstandingRequests.get(i)).piece == piece) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Called when a piece message is being processed by the incoming
+     * connection. Returns null when there was no such request. It also
+     * requeues/sends requests when it thinks that they must have been lost.
+     */
+    Request getOutstandingRequest (int piece, int begin, int length)
+    {
+        log.log(Level.FINEST, &quot;getChunk(&quot; + piece + &quot;,&quot; + begin + &quot;,&quot; + length
+            + &quot;) &quot; + peer);
+
+        int r = getFirstOutstandingRequest(piece);
+
+        // Unrequested piece number?
+        if (r == -1) {
+            log.log(Level.FINER, &quot;Unrequested 'piece: &quot; + piece + &quot;, &quot; + begin
+                + &quot;, &quot; + length + &quot;' received from &quot; + peer);
+            downloaded = 0; // XXX - punishment?
+            return null;
+        }
+
+        // Lookup the correct piece chunk request from the list.
+        Request req;
+        synchronized (this) {
+            req = outstandingRequests.get(r);
+            while (req.piece == piece &amp;&amp; req.off != begin
+                &amp;&amp; r &lt; outstandingRequests.size() - 1) {
+                r++;
+                req = outstandingRequests.get(r);
+            }
+
+            // Something wrong?
+            if (req.piece != piece || req.off != begin || req.len != length) {
+                log.log(Level.FINER, &quot;Unrequested or unneeded 'piece: &quot; + piece
+                    + &quot;, &quot; + begin + &quot;, &quot; + length + &quot;' received from &quot; + peer);
+                downloaded = 0; // XXX - punishment?
+                return null;
+            }
+
+            // Report missing requests.
+            if (r != 0) {
+                String errmsg = &quot;Some requests dropped, got &quot; + req +
+                    &quot;, wanted:&quot;;
+                for (int i = 0; i &lt; r; i++) {
+                    Request dropReq = outstandingRequests.remove(0);
+                    outstandingRequests.add(dropReq);
+                    // We used to rerequest the missing chunks but that mostly
+                    // just confuses the other side. So now we just keep
+                    // waiting for them. They will be rerequested when we get
+                    // choked/unchoked again.
+                    /*
+                     * if (!choked) out.sendRequest(dropReq);
+                     */
+                    errmsg += &quot; &quot; + dropReq;
+                }
+                errmsg += &quot; &quot; + peer;
+                log.log(Level.FINER, errmsg);
+            }
+            outstandingRequests.remove(0);
+        }
+
+        // Request more if necessary to keep the pipeline filled.
+        addRequest();
+
+        return req;
+
+    }
+
+    void cancelMessage (int piece, int begin, int length)
+    {
+        log.log(Level.FINEST, &quot;Got cancel message (&quot; + piece + &quot;, &quot; + begin
+            + &quot;, &quot; + length + &quot;)&quot;);
+        out.cancelRequest(piece, begin, length);
+    }
+
+    void unknownMessage (int type, byte[] bs)
+    {
+        log.log(Level.WARNING, &quot;Ignoring unknown message type: &quot; + type
+            + &quot; length: &quot; + bs.length);
+    }
+
+    void havePiece (int piece)
+    {
+        log.log(Level.FINEST, &quot;Tell &quot; + peer + &quot; havePiece(&quot; + piece + &quot;)&quot;);
+
+        synchronized (this) {
+            // Tell the other side that we are no longer interested in any of
+            // the outstanding requests for this piece.
+            if (lastRequest != null &amp;&amp; lastRequest.piece == piece) {
+                lastRequest = null;
+            }
+
+            Iterator it = outstandingRequests.iterator();
+            while (it.hasNext()) {
+                Request req = (Request)it.next();
+                if (req.piece == piece) {
+                    it.remove();
+                    // Send cancel even when we are choked to make sure that it
+                    // is
+                    // really never ever send.
+                    out.sendCancel(req);
+                }
+            }
+        }
+
+        // Tell the other side that we really have this piece.
+        out.sendHave(piece);
+
+        // Request something else if necessary.
+        addRequest();
+
+        synchronized (this) {
+            // Is the peer still interesting?
+            if (lastRequest == null) {
+                setInteresting(false);
+            }
+        }
+    }
+
+    // Starts or resumes requesting pieces.
+    private void request ()
+    {
+        // Are there outstanding requests that have to be resend?
+        if (resend) {
+            out.sendRequests(outstandingRequests);
+            resend = false;
+        }
+
+        // Add/Send some more requests if necessary.
+        addRequest();
+    }
+
+    /**
+     * Adds a new request to the outstanding requests list.
+     */
+    private void addRequest ()
+    {
+        boolean more_pieces = true;
+        while (more_pieces) {
+            synchronized (this) {
+                more_pieces = outstandingRequests.size() &lt; MAX_PIPELINE;
+            }
+
+            // We want something and we don't have outstanding requests?
+            if (more_pieces &amp;&amp; lastRequest == null) {
+                more_pieces = requestNextPiece();
+            } else if (more_pieces) // We want something
+            {
+                int pieceLength;
+                boolean isLastChunk;
+                synchronized (this) {
+                    pieceLength = metainfo.getPieceLength(lastRequest.piece);
+                    isLastChunk = lastRequest.off + lastRequest.len == pieceLength;
+                }
+
+                // Last part of a piece?
+                if (isLastChunk) {
+                    more_pieces = requestNextPiece();
+                } else {
+                    synchronized (this) {
+                        int nextPiece = lastRequest.piece;
+                        int nextBegin = lastRequest.off + PARTSIZE;
+                        byte[] bs = lastRequest.bs;
+                        int maxLength = pieceLength - nextBegin;
+                        int nextLength = maxLength &gt; PARTSIZE ? PARTSIZE
+                            : maxLength;
+                        Request req = new Request(nextPiece, bs, nextBegin,
+                            nextLength);
+                        outstandingRequests.add(req);
+                        if (!choked) {
+                            out.sendRequest(req);
+                        }
+                        lastRequest = req;
+                    }
+                }
+            }
+        }
+
+        log.log(Level.FINEST, peer + &quot; requests &quot; + outstandingRequests);
+    }
+
+    // Starts requesting first chunk of next piece. Returns true if
+    // something has been added to the requests, false otherwise.
+    private boolean requestNextPiece ()
+    {
+        // Check that we already know what the other side has.
+        if (bitfield != null) {
+            int nextPiece = listener.wantPiece(peer, bitfield);
+            log.log(Level.FINEST, peer + &quot; want piece &quot; + nextPiece);
+            synchronized (this) {
+                if (nextPiece != -1
+                    &amp;&amp; (lastRequest == null || lastRequest.piece != nextPiece)) {
+                    int piece_length = metainfo.getPieceLength(nextPiece);
+                    byte[] bs = new byte[piece_length];
+
+                    int length = Math.min(piece_length, PARTSIZE);
+                    Request req = new Request(nextPiece, bs, 0, length);
+                    outstandingRequests.add(req);
+                    if (!choked) {
+                        out.sendRequest(req);
+                    }
+                    lastRequest = req;
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    synchronized void setInteresting (boolean interest)
+    {
+        log.log(Level.FINEST, peer + &quot; setInteresting(&quot; + interest + &quot;)&quot;);
+
+        if (interest != interesting) {
+            interesting = interest;
+            out.sendInterest(interest);
+
+            if (interesting &amp;&amp; !choked) {
+                request();
+            }
+        }
+    }
+
+    synchronized void setChoking (boolean choke)
+    {
+        log.log(Level.FINEST, peer + &quot; setChoking(&quot; + choke + &quot;)&quot;);
+
+        if (choking != choke) {
+            choking = choke;
+            out.sendChoke(choke);
+        }
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.peer&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/Request.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/Request.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/Request.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,83 @@
+/*
+ * Request - Holds all information needed for a (partial) piece request.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+/**
+ * Holds all information needed for a partial piece request.
+ */
+class Request
+{
+    final int piece;
+
+    final byte[] bs;
+
+    final int off;
+
+    final int len;
+
+    /**
+     * Creates a new Request.
+     * 
+     * @param piece
+     *            Piece number requested.
+     * @param bs
+     *            byte array where response should be stored.
+     * @param off
+     *            the offset in the array.
+     * @param len
+     *            the number of bytes requested.
+     */
+    Request (int piece, byte[] bs, int off, int len)
+    {
+        this.piece = piece;
+        this.bs = bs;
+        this.off = off;
+        this.len = len;
+
+        // Sanity check
+        if (piece &lt; 0 || off &lt; 0 || len &lt;= 0 || off + len &gt; bs.length) {
+            throw new IndexOutOfBoundsException(&quot;Illegal Request &quot; + toString());
+        }
+    }
+
+    @Override
+    public int hashCode ()
+    {
+        return piece ^ off ^ len;
+    }
+
+    @Override
+    public boolean equals (Object o)
+    {
+        if (o instanceof Request) {
+            Request req = (Request)o;
+            return req.piece == piece &amp;&amp; req.off == off &amp;&amp; req.len == len;
+        }
+
+        return false;
+    }
+
+    @Override
+    public String toString ()
+    {
+        return &quot;(&quot; + piece + &quot;,&quot; + off + &quot;,&quot; + len + &quot;)&quot;;
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/ShutdownListener.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/ShutdownListener.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/ShutdownListener.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,34 @@
+/*
+ * ShutdownListener - Callback for end of shutdown sequence
+ * 
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+/**
+ * Callback for end of shutdown sequence.
+ */
+public interface ShutdownListener
+{
+    /**
+     * Called when the SnarkShutdown hook has finished shutting down all
+     * subcomponents.
+     */
+    void shutdown ();
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/Snark.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/Snark.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/Snark.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,383 @@
+/*
+ * Snark - Main snark program startup class. Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.UnknownHostException;
+import java.util.Random;
+import java.util.logging.ConsoleHandler;
+import java.util.logging.Handler;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.klomp.snark.bencode.BDecoder;
+
+/**
+ * Main Snark object used to fetch or serve a given file.
+ * 
+ * @author Mark Wielaard (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">mark at klomp.org</A>)
+ */
+public class Snark
+{
+    /** The lowest port Snark will listen on for connections */
+    public final static int MIN_PORT = 6881;
+
+    /** The highest port Snark will listen on for connections */
+    public final static int MAX_PORT = 6889;
+
+    /** The path to the file being torrented */
+    public String torrent;
+
+    /** The metadata known about the torrent */
+    public MetaInfo meta;
+
+    /** The storage helper assisting us */
+    public Storage storage;
+
+    /** The coordinator managing our peers */
+    public PeerCoordinator coordinator;
+
+    /** Parcels out incoming requests to the appropriate places */
+    public ConnectionAcceptor acceptor;
+
+    /** Obtains information on new peers. */
+    public TrackerClient trackerclient;
+    
+    public String targetFolder;
+
+    /**
+     * Constructs a Snark client.
+     * @param torrent The address of the torrent to download or file to serve
+     * @param ip The IP address to use when serving data
+     * @param user_port The port number to use
+     * @param slistener A custom {@link StorageListener} to use
+     * @param clistener A custom {@link CoordinatorListener} to use
+     */
+    public Snark (String torrent, String ip, int user_port,
+        StorageListener slistener, CoordinatorListener clistener,String targetFolder)
+    {
+        this.targetFolder = targetFolder;
+        this.slistener = slistener;
+        this.clistener = clistener;
+        this.torrent = torrent;
+        this.user_port = user_port;
+        this.ip = ip;
+
+        // Create a new ID and fill it with something random. First nine
+        // zeros bytes, then three bytes filled with snark and then
+        // sixteen random bytes.
+        Random random = new Random();
+        int i;
+        for (i = 0; i &lt; 9; i++) {
+            id[i] = 0;
+        }
+        id[i++] = snark;
+        id[i++] = snark;
+        id[i++] = snark;
+        while (i &lt; 20) {
+            id[i++] = (byte)random.nextInt(256);
+        }
+
+        log.log(Level.FINE, &quot;My peer id: &quot; + PeerID.idencode(id));
+    }
+
+    /**
+     * Sets the global logging level of Snark.
+     */
+    public static void setLogLevel (Level level)
+    {
+        log.setLevel(level);
+        log.setUseParentHandlers(false);
+        Handler handler = new ConsoleHandler();
+        handler.setLevel(level);
+        log.addHandler(handler);
+    }
+
+    /**
+     * Returns a human-readable state of Snark.
+     */
+    public String getStateString ()
+    {
+        return activities[activity];
+    }
+
+    /**
+     * Returns the integer code for the human-readable state of Snark.
+     */
+    public int getState ()
+    {
+        return activity;
+    }
+
+    /**
+     * Establishes basic information such as {@link #id}, opens ports,
+     * and determines whether to act as a peer or seed.
+     */
+    public void setupNetwork ()
+        throws IOException
+    {
+        activity = NETWORK_SETUP;
+
+        IOException lastException = null;
+        if (user_port != -1) {
+            port = user_port;
+            try {
+                serversocket = new ServerSocket(port);
+            } catch (IOException ioe) {
+                lastException = ioe;
+            }
+        } else {
+            for (port = MIN_PORT; serversocket == null &amp;&amp; port &lt;= MAX_PORT; port++) {
+                try {
+                    serversocket = new ServerSocket(port);
+                } catch (IOException ioe) {
+                    lastException = ioe;
+                }
+            }
+        }
+        if (serversocket == null) {
+            String message = &quot;Cannot accept incoming connections &quot;;
+            if (user_port == -1) {
+                message = message + &quot;tried ports &quot; + MIN_PORT + &quot; - &quot;
+                    + MAX_PORT;
+            } else {
+                message = message + &quot;on port &quot; + user_port;
+            }
+
+            if (ip != null || user_port != -1) {
+                abort(message, lastException);
+            } else {
+                log.log(Level.WARNING, message);
+            }
+            port = -1;
+        } else {
+            port = serversocket.getLocalPort();
+            log.log(Level.FINE, &quot;Listening on port: &quot; + port);
+        }
+
+        // Figure out what the torrent argument represents.
+        meta = null;
+        File f = null;
+        try {
+            InputStream in;
+            f = new File(torrent);
+            if (f.exists()) {
+                in = new FileInputStream(f);
+            } else {
+                activity = GETTING_TORRENT;
+                URL u = new URL(torrent);
+                URLConnection c = u.openConnection();
+                c.connect();
+                in = c.getInputStream();
+
+                if (c instanceof HttpURLConnection) {
+                    // Check whether the page exists
+                    int code = ((HttpURLConnection)c).getResponseCode();
+                    if (code / 100 != 2) {
+                        // responses
+                        abort(&quot;Loading page '&quot; + torrent + &quot;' gave error code &quot;
+                            + code + &quot;, it probably doesn't exists&quot;);
+                    }
+                }
+            }
+            meta = new MetaInfo(new BDecoder(in));
+        } catch (IOException ioe) {
+            // OK, so it wasn't a torrent metainfo file.
+            if (f != null &amp;&amp; f.exists()) {
+                if (ip == null) {
+                    abort(&quot;'&quot; + torrent + &quot;' exists,&quot;
+                        + &quot; but is not a valid torrent metainfo file.&quot;
+                        + System.getProperty(&quot;line.separator&quot;)
+                        + &quot;  (use --share to create a torrent from it&quot;
+                        + &quot; and start sharing)&quot;, ioe);
+                } else {
+                    // Try to create a new metainfo file
+                    log.log(Level.INFO,
+                        &quot;Trying to create metainfo torrent for '&quot; + torrent
+                            + &quot;'&quot;);
+                    try {
+                        activity = CREATING_TORRENT;
+                        storage = new Storage(f, &quot;<A HREF="http://">http://</A>&quot; + ip + &quot;:&quot; + port
+                            + &quot;/announce&quot;, slistener,targetFolder);
+                        storage.create();
+                        meta = storage.getMetaInfo();
+                    } catch (IOException ioe2) {
+                        abort(&quot;Could not create torrent for '&quot; + torrent + &quot;'&quot;,
+                            ioe2);
+                    }
+                }
+            } else {
+                abort(&quot;Cannot open '&quot; + torrent + &quot;'&quot;, ioe);
+            }
+        }
+
+        log.log(Level.INFO, meta.toString());
+    }
+
+    /**
+     * Start the upload/download process and begins exchanging pieces
+     * with other peers.
+     */
+    public void collectPieces ()
+        throws IOException
+    {
+        // When the metainfo torrent was created from an existing file/dir
+        // it already exists.
+        if (storage == null) {
+            try {
+                activity = CHECKING_STORAGE;
+                storage = new Storage(meta, slistener,targetFolder);
+                storage.check();
+            } catch (IOException ioe) {
+                abort(&quot;Could not create storage&quot;, ioe);
+            }
+        }
+
+        activity = COLLECTING_PIECES;
+        coordinator = new PeerCoordinator(id, meta, storage, clistener);
+        HttpAcceptor httpacceptor;
+        if (ip != null) {
+            MetaInfo m = meta.reannounce(&quot;<A HREF="http://">http://</A>&quot; + ip + &quot;:&quot; + port
+                + &quot;/announce&quot;);
+            Tracker tracker = new Tracker(m);
+            try {
+                tracker.addPeer(meta.getHexInfoHash(),
+                    new PeerID(id, InetAddress.getByName(ip), port));
+            } catch (UnknownHostException oops) {
+                abort(&quot;Could not start tracker for &quot; + ip, oops);
+            }
+            httpacceptor = new HttpAcceptor(tracker);
+            // Debug code for writing out .torrent to disk
+            /*
+            byte[] torrentData = tracker.getMetaInfo(
+                meta.getHexInfoHash()).getTorrentData();
+            try {
+                log.log(Level.INFO, &quot;Writing torrent to file &quot; + torrent
+                    + &quot;.torrent&quot;);
+                FileOutputStream fos = new FileOutputStream(torrent
+                    + &quot;.torrent&quot;);
+                fos.write(torrentData);
+                fos.close();
+            } catch (IOException e) {
+                log.log(Level.WARNING, &quot;Could not save torrent file.&quot;);
+            }
+            */
+        } else {
+            httpacceptor = null;
+        }
+
+        PeerAcceptor peeracceptor = new PeerAcceptor(coordinator);
+        acceptor = new ConnectionAcceptor(serversocket, httpacceptor,
+            peeracceptor);
+        acceptor.start();
+
+        if (ip != null) {
+            log.log(Level.INFO, &quot;Torrent available on &quot; + &quot;<A HREF="http://">http://</A>&quot; + ip + &quot;:&quot;
+                + port + &quot;/&quot; + meta.getHexInfoHash() + &quot;.torrent&quot;);
+        }
+
+        trackerclient = new TrackerClient(meta, coordinator, port);
+        trackerclient.start();
+        coordinator.setTracker(trackerclient);
+    }
+
+    /**
+     * Aborts program abnormally.
+     */
+    public static void abort (String s)
+        throws IOException
+    {
+        abort(s, null);
+    }
+
+    /**
+     * Aborts program abnormally.
+     */
+    public static void abort (String s, IOException ioe)
+        throws IOException
+    {
+        log.log(Level.SEVERE, s, ioe);
+        throw new IOException(s);
+    }
+
+    /** The listen port requested by the user */
+    protected int user_port;
+
+    /** The port number Snark listens on */
+    protected int port;
+
+    /** The IP address to listen on, if applicable */
+    protected String ip;
+
+    /** The {@link StorageListener} to send updates to */
+    protected StorageListener slistener;
+
+    /** The {@link CoordinatorListener} to send updates to */
+    protected CoordinatorListener clistener;
+
+    /** Our BitTorrent client id number, randomly assigned */
+    protected byte[] id = new byte[20];
+
+    /** The server socket that we are using to listen for connections */
+    protected ServerSocket serversocket;
+
+    /**
+     * A magic constant used to identify the Snark library in the clientid.
+     * 
+     * &lt;pre&gt;Taking Three as the subject to reason about--
+     * A convenient number to state--
+     * We add Seven, and Ten, and then multiply out
+     * By One Thousand diminished by Eight.
+     *
+     * The result we proceed to divide, as you see,
+     * By Nine Hundred and Ninety Two:
+     * Then subtract Seventeen, and the answer must be
+     * Exactly and perfectly true.&lt;/pre&gt;
+     */
+    protected static final byte snark =
+        (((3 + 7 + 10) * (1000 - 8)) / 992) - 17;
+
+    /** An integer indicating Snark's current activity. */
+    protected int activity = NOT_STARTED;
+
+    /** The list of possible activities */
+    protected static final String[] activities =
+        {&quot;Not started&quot;, &quot;Network setup&quot;, &quot;Getting torrent&quot;, &quot;Creating torrent&quot;,
+        &quot;Checking storage&quot;, &quot;Collecting pieces&quot;, &quot;Seeding&quot;};
+
+    public static final int NOT_STARTED = 0;
+    public static final int NETWORK_SETUP = 1;
+    public static final int GETTING_TORRENT = 2;
+    public static final int CREATING_TORRENT = 3;
+    public static final int CHECKING_STORAGE = 4;
+    public static final int COLLECTING_PIECES = 5;
+    public static final int SEEDING = 6;
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/SnarkShutdown.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/SnarkShutdown.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/SnarkShutdown.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,83 @@
+/*
+ * TrackerShutdown - Makes sure everything ends correctly when shutting down.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Makes sure everything ends correctly when shutting down.
+ */
+public class SnarkShutdown extends Thread
+{
+    private final Snark snark;
+
+    private final ShutdownListener listener;
+
+    public SnarkShutdown (Snark snark, ShutdownListener listener)
+    {
+        this.snark = snark;
+        this.listener = listener;
+    }
+
+    @Override
+    public void run ()
+    {
+        log.log(Level.INFO, &quot;Shutting down...&quot;);
+
+        log.log(Level.FINE, &quot;Halting ConnectionAcceptor...&quot;);
+        if (snark.acceptor != null) {
+            snark.acceptor.halt();
+        }
+
+        log.log(Level.FINE, &quot;Halting TrackerClient...&quot;);
+        if (snark.trackerclient != null) {
+            snark.trackerclient.halt();
+        }
+
+        log.log(Level.FINE, &quot;Halting PeerCoordinator...&quot;);
+        if (snark.coordinator != null) {
+            snark.coordinator.halt();
+        }
+
+        log.log(Level.FINE, &quot;Closing Storage...&quot;);
+        if (snark.storage != null) {
+            try {
+                snark.storage.close();
+            } catch (IOException ioe) {
+                log.log(Level.SEVERE, &quot;Couldn't properly close storage&quot;, ioe);
+            }
+        }
+
+        // XXX - Should actually wait till done...
+        try {
+            log.log(Level.FINE, &quot;Waiting 5 seconds...&quot;);
+            Thread.sleep(5 * 1000);
+        } catch (InterruptedException ie) { /* ignored */
+        }
+
+        listener.shutdown();
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.server&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/StaticSnark.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/StaticSnark.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/StaticSnark.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,52 @@
+/*
+ * StaticSnark - Main snark startup class for staticly linking with gcj.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.security.Provider;
+import java.security.Security;
+
+import org.klomp.snark.cmd.SnarkApplication;
+
+/**
+ * Main snark startup class for staticly linking with gcj. It references somee
+ * necessary classes that are normally loaded through reflection.
+ * 
+ * @author Mark Wielaard (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">mark at klomp.org</A>)
+ */
+public class StaticSnark
+{
+    public static void main (String[] args)
+    {
+        try {
+            // The GNU security provider is needed for SHA-1 MessageDigest
+            // checking. So make sure it is available as a security provider.
+            Provider gnu = (Provider)Class.forName(
+                &quot;gnu.java.security.provider.Gnu&quot;).newInstance();
+            Security.addProvider(gnu);
+        } catch (Exception e) {
+            System.err.println(&quot;Unable to load GNU security provider&quot;);
+            System.exit(-1);
+        }
+
+        // And finally call the normal starting point.
+        SnarkApplication.main(args);
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/Storage.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/Storage.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/Storage.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,524 @@
+/*
+ * Storage - Class used to store and retrieve pieces. Copyright (C) 2003 Mark J.
+ * Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.StringTokenizer;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Maintains pieces on disk. Can be used to store and retrieve pieces.
+ */
+public class Storage
+{
+    private MetaInfo metainfo;
+
+    private long[] lengths;
+
+    private RandomAccessFile[] rafs;
+
+    private String[] names;
+
+    private final StorageListener listener;
+
+    private final BitField bitfield;
+
+    private int needed;
+    
+    String targetFolder;
+
+    // XXX - Not always set correctly
+    int piece_size;
+
+    int pieces;
+
+    /** The default piece size. */
+    private static int MIN_PIECE_SIZE = 256 * 1024;
+
+    /** The maximum number of pieces in a torrent. */
+    private static long MAX_PIECES = 100 * 1024 / 20;
+
+    /**
+     * Creates a new storage based on the supplied MetaInfo. This will try to
+     * create and/or check all needed files in the MetaInfo.
+     * 
+     * @exception IOException
+     *                when creating and/or checking files fails.
+     */
+    public Storage (MetaInfo metainfo, StorageListener listener,String targetFolder)
+        throws IOException
+    {
+        //this.filebase = filebase;
+        this.metainfo = metainfo;
+        this.listener = listener;
+        this.targetFolder = targetFolder;
+        needed = metainfo.getPieces();
+        bitfield = new BitField(needed);
+    }
+
+    /**
+     * Creates a storage from the existing file or directory together with an
+     * appropriate MetaInfo file as can be announced on the given announce
+     * String location.
+     */
+    public Storage (File baseFile, String announce, StorageListener listener,String targetFolder)
+        throws IOException
+    {
+        this.listener = listener;
+        this.targetFolder = targetFolder;
+        // Create names, rafs and lengths arrays.
+        getFiles(baseFile);
+
+        long total = 0;
+        ArrayList&lt;Long&gt; lengthsList = new ArrayList&lt;Long&gt;();
+        for (long length : lengths) {
+            total += length;
+            lengthsList.add(length);
+        }
+
+        piece_size = MIN_PIECE_SIZE;
+        pieces = (int)((total - 1) / piece_size) + 1;
+        while (pieces &gt; MAX_PIECES) {
+            piece_size = piece_size * 2;
+            pieces = (int)((total - 1) / piece_size) + 1;
+        }
+
+        // Note that piece_hashes and the bitfield will be filled after
+        // the MetaInfo is created.
+        byte[] piece_hashes = new byte[20 * pieces];
+        bitfield = new BitField(pieces);
+        needed = 0;
+
+        List&lt;List&lt;String&gt;&gt; files = new ArrayList&lt;List&lt;String&gt;&gt;();
+        for (String element : names) {
+            List&lt;String&gt; file = new ArrayList&lt;String&gt;();
+            StringTokenizer st = new StringTokenizer(element, File.separator);
+            while (st.hasMoreTokens()) {
+                String part = st.nextToken();
+                file.add(part);
+            }
+            files.add(file);
+        }
+
+        if (files.size() == 1) {
+            files = null;
+            lengthsList = null;
+        }
+
+        // Note that the piece_hashes are not correctly setup yet.
+        metainfo = new MetaInfo(announce, baseFile.getName(), files,
+            lengthsList, piece_size, piece_hashes, total);
+
+    }
+
+    // Creates piece hases for a new storage.
+    public void create () throws IOException
+    {
+        // Calculate piece_hashes
+        MessageDigest digest = null;
+        try {
+            digest = MessageDigest.getInstance(&quot;SHA&quot;);
+        } catch (NoSuchAlgorithmException nsa) {
+            throw new InternalError(nsa.toString());
+        }
+
+        byte[] piece_hashes = metainfo.getPieceHashes();
+
+        byte[] piece = new byte[piece_size];
+        for (int i = 0; i &lt; pieces; i++) {
+            int length = getUncheckedPiece(i, piece, 0);
+            digest.update(piece, 0, length);
+            byte[] hash = digest.digest();
+            for (int j = 0; j &lt; 20; j++) {
+                piece_hashes[20 * i + j] = hash[j];
+            }
+
+            bitfield.set(i);
+
+            if (listener != null) {
+                listener.storageChecked(this, i, true);
+            }
+        }
+
+        if (listener != null) {
+            listener.storageAllChecked(this);
+        }
+
+        // Reannounce to force recalculating the info_hash.
+        metainfo = metainfo.reannounce(metainfo.getAnnounce());
+    }
+
+    private void getFiles (File base) throws IOException
+    {
+        base = new File(base.getPath()+targetFolder);
+        ArrayList&lt;File&gt; files = new ArrayList&lt;File&gt;();
+        addFiles(files, base);
+
+        int size = files.size();
+        names = new String[size];
+        lengths = new long[size];
+        rafs = new RandomAccessFile[size];
+
+        int i = 0;
+        Iterator it = files.iterator();
+        while (it.hasNext()) {
+            File f = (File)it.next();
+            names[i] = f.getPath();
+            lengths[i] = f.length();
+            rafs[i] = new RandomAccessFile(f, &quot;r&quot;);
+            i++;
+        }
+    }
+
+    private static void addFiles (List&lt;File&gt; l, File f)
+    {
+        if (!f.isDirectory()) {
+            l.add(f);
+        } else {
+            File[] files = f.listFiles();
+            if (files == null) {
+                log.log(Level.WARNING, &quot;Skipping '&quot; + f
+                    + &quot;' not a normal file.&quot;);
+                return;
+            }
+            for (File element : files) {
+                addFiles(l, element);
+            }
+        }
+    }
+
+    /**
+     * Returns the MetaInfo associated with this Storage.
+     */
+    public MetaInfo getMetaInfo ()
+    {
+        return metainfo;
+    }
+
+    /**
+     * How many pieces are still missing from this storage.
+     */
+    public int needed ()
+    {
+        return needed;
+    }
+
+    /**
+     * Whether or not this storage contains all pieces if the MetaInfo.
+     */
+    public boolean complete ()
+    {
+        return needed == 0;
+    }
+
+    /**
+     * The BitField that tells which pieces this storage contains. Do not change
+     * this since this is the current state of the storage.
+     */
+    public BitField getBitField ()
+    {
+        return bitfield;
+    }
+
+    /**
+     * Creates (and/or checks) all files from the metainfo file list.
+     */
+    public void check () throws IOException
+    {
+        File base = new File(targetFolder+filterName(metainfo.getName()));
+
+        List files = metainfo.getFiles();
+        if (files == null) {
+            // Create base as file.
+            log.log(Level.INFO, &quot;Creating/Checking file: &quot; + base);
+            if (!base.createNewFile() &amp;&amp; !base.exists()) {
+                throw new IOException(&quot;Could not create file &quot; + base);
+            }
+
+            lengths = new long[1];
+            rafs = new RandomAccessFile[1];
+            names = new String[1];
+            lengths[0] = metainfo.getTotalLength();
+            rafs[0] = new RandomAccessFile(base, &quot;rw&quot;);
+            names[0] = base.getName();
+        } else {
+            // Create base as dir.
+            log.log(Level.INFO, &quot;Creating/Checking directory: &quot; + base);
+            if (!base.mkdir() &amp;&amp; !base.isDirectory()) {
+                throw new IOException(&quot;Could not create directory &quot; + base);
+            }
+
+            List ls = metainfo.getLengths();
+            int size = files.size();
+            long total = 0;
+            lengths = new long[size];
+            rafs = new RandomAccessFile[size];
+            names = new String[size];
+            for (int i = 0; i &lt; size; i++) {
+                File f = createFileFromNames(base, (List)files.get(i));
+                lengths[i] = ((Long)ls.get(i)).longValue();
+                total += lengths[i];
+                rafs[i] = new RandomAccessFile(f, &quot;rw&quot;);
+                names[i] = f.getName();
+            }
+
+            // Sanity check for metainfo file.
+            long metalength = metainfo.getTotalLength();
+            if (total != metalength) {
+                throw new IOException(&quot;File lengths do not add up &quot; + total
+                    + &quot; != &quot; + metalength);
+            }
+        }
+        checkCreateFiles();
+    }
+
+    /**
+     * Removes 'suspicious' characters from the give file name.
+     */
+    private String filterName (String name)
+    {
+        // XXX - Is this enough?
+        return name.replace(File.separatorChar, '_');
+    }
+
+    private File createFileFromNames (File base, List names) throws IOException
+    {
+        File f = null;
+        Iterator it = names.iterator();
+        while (it.hasNext()) {
+            String name = filterName((String)it.next());
+            if (it.hasNext()) {
+                // Another dir in the hierarchy.
+                f = new File(base, name);
+                if (!f.mkdir() &amp;&amp; !f.isDirectory()) {
+                    throw new IOException(&quot;Could not create directory &quot; + f);
+                }
+                base = f;
+            } else {
+                // The final element (file) in the hierarchy.
+                f = new File(base, name);
+                if (!f.createNewFile() &amp;&amp; !f.exists()) {
+                    throw new IOException(&quot;Could not create file &quot; + f);
+                }
+            }
+        }
+        return f;
+    }
+
+    private void checkCreateFiles () throws IOException
+    {
+        // Whether we are resuming or not,
+        // if any of the files already exists we assume we are resuming.
+        boolean resume = false;
+
+        // Make sure all files are available and of correct length
+        for (int i = 0; i &lt; rafs.length; i++) {
+            long length = rafs[i].length();
+            if (length == lengths[i]) {
+                if (listener != null) {
+                    listener.storageAllocated(this, length);
+                }
+                resume = true; // XXX Could dynamicly check
+            } else if (length == 0) {
+                allocateFile(i);
+            } else {
+                log.log(Level.FINE, &quot;Truncating '&quot; + names[i]
+                    + &quot;' from &quot; + lengths + &quot; to &quot; + lengths[i] + &quot;bytes&quot;);
+                rafs[i].setLength(lengths[i]);
+                allocateFile(i);
+            }
+        }
+
+        // Check which pieces match and which don't
+        if (resume) {
+            pieces = metainfo.getPieces();
+            byte[] piece = new byte[metainfo.getPieceLength(0)];
+            for (int i = 0; i &lt; pieces; i++) {
+                int length = getUncheckedPiece(i, piece, 0);
+                boolean correctHash = metainfo.checkPiece(i, piece, 0, length);
+                if (correctHash) {
+                    bitfield.set(i);
+                    needed--;
+                }
+
+                if (listener != null) {
+                    listener.storageChecked(this, i, correctHash);
+                }
+            }
+        }
+
+        if (listener != null) {
+            listener.storageAllChecked(this);
+        }
+    }
+
+    private void allocateFile (int nr) throws IOException
+    {
+        // XXX - Is this the best way to make sure we have enough space for
+        // the whole file?
+        listener.storageCreateFile(this, names[nr], lengths[nr]);
+        final int ZEROBLOCKSIZE = metainfo.getPieceLength(0);
+        byte[] zeros = new byte[ZEROBLOCKSIZE];
+        int i;
+        for (i = 0; i &lt; lengths[nr] / ZEROBLOCKSIZE; i++) {
+            rafs[nr].write(zeros);
+            if (listener != null) {
+                listener.storageAllocated(this, ZEROBLOCKSIZE);
+            }
+        }
+        int size = (int)(lengths[nr] - i * ZEROBLOCKSIZE);
+        rafs[nr].write(zeros, 0, size);
+        if (listener != null) {
+            listener.storageAllocated(this, size);
+        }
+    }
+
+    /**
+     * Closes the Storage and makes sure that all RandomAccessFiles are closed.
+     * The Storage is unusable after this.
+     */
+    public void close () throws IOException
+    {
+        for (RandomAccessFile element : rafs) {
+            synchronized (element) {
+                element.close();
+            }
+        }
+    }
+
+    /**
+     * Returns a byte array containing the requested piece or null if the
+     * storage doesn't contain the piece yet.
+     */
+    public byte[] getPiece (int piece) throws IOException
+    {
+        if (!bitfield.get(piece)) {
+            return null;
+        }
+
+        byte[] bs = new byte[metainfo.getPieceLength(piece)];
+        getUncheckedPiece(piece, bs, 0);
+        return bs;
+    }
+
+    /**
+     * Put the piece in the Storage if it is correct.
+     * 
+     * @return true if the piece was correct (sha metainfo hash matches),
+     *         otherwise false.
+     * @exception IOException
+     *                when some storage related error occurs.
+     */
+    public boolean putPiece (int piece, byte[] bs) throws IOException
+    {
+        // First check if the piece is correct.
+        // If we were paranoia we could copy the array first.
+        int length = bs.length;
+        boolean correctHash = metainfo.checkPiece(piece, bs, 0, length);
+        if (listener != null) {
+            listener.storageChecked(this, piece, correctHash);
+        }
+        if (!correctHash) {
+            return false;
+        }
+
+        synchronized (bitfield) {
+            if (bitfield.get(piece)) {
+                return true; // No need to store twice.
+            } else {
+                bitfield.set(piece);
+                needed--;
+            }
+        }
+
+        long start = piece * metainfo.getPieceLength(0);
+        int i = 0;
+        long raflen = lengths[i];
+        while (start &gt; raflen) {
+            i++;
+            start -= raflen;
+            raflen = lengths[i];
+        }
+
+        int written = 0;
+        int off = 0;
+        while (written &lt; length) {
+            int need = length - written;
+            int len = (start + need &lt; raflen) ? need : (int)(raflen - start);
+            synchronized (rafs[i]) {
+                rafs[i].seek(start);
+                rafs[i].write(bs, off + written, len);
+            }
+            written += len;
+            if (need - len &gt; 0) {
+                i++;
+                raflen = lengths[i];
+                start = 0;
+            }
+        }
+
+        return true;
+    }
+
+    private int getUncheckedPiece (int piece, byte[] bs, int off)
+        throws IOException
+    {
+        // XXX - copy/paste code from putPiece().
+        long start = piece * metainfo.getPieceLength(0);
+        int length = metainfo.getPieceLength(piece);
+        int i = 0;
+        long raflen = lengths[i];
+        while (start &gt; raflen) {
+            i++;
+            start -= raflen;
+            raflen = lengths[i];
+        }
+
+        int read = 0;
+        while (read &lt; length) {
+            int need = length - read;
+            int len = (start + need &lt; raflen) ? need : (int)(raflen - start);
+            synchronized (rafs[i]) {
+                rafs[i].seek(start);
+                rafs[i].readFully(bs, off + read, len);
+            }
+            read += len;
+            if (need - len &gt; 0) {
+                i++;
+                raflen = lengths[i];
+                start = 0;
+            }
+        }
+
+        return length;
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.Storage&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/StorageListener.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/StorageListener.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/StorageListener.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,51 @@
+/*
+ * StorageListener.java - Interface used as callback when storage changes.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+/**
+ * Callback used when Storage changes.
+ */
+public interface StorageListener
+{
+    /**
+     * Called when the storage creates a new file of a given length.
+     */
+    void storageCreateFile (Storage storage, String name, long length);
+
+    /**
+     * Called to indicate that length bytes have been allocated.
+     */
+    void storageAllocated (Storage storage, long length);
+
+    /**
+     * Called when storage is being checked and the num piece of that total
+     * pieces has been checked. When the piece hash matches the expected piece
+     * hash checked will be true, otherwise it will be false.
+     */
+    void storageChecked (Storage storage, int num, boolean checked);
+
+    /**
+     * Called when all pieces in the storage have been checked. Does not mean
+     * that the storage is complete, just that the state of the storage is
+     * known.
+     */
+    void storageAllChecked (Storage storage);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/Tracker.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/Tracker.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/Tracker.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,202 @@
+/*
+ * Tracker - Keeps track of clients sharing a particular torrent MetaInfo.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.ByteArrayOutputStream;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.klomp.snark.bencode.BEncoder;
+
+/**
+ * Keeps track of clients sharing a particular torrent MetaInfo.
+ */
+public class Tracker
+{
+    private static final int INTERVAL_SEC = 15 * 60; // 15 minutes.
+
+    private final Map&lt;String, MetaInfo&gt; metainfo =
+        new HashMap&lt;String, MetaInfo&gt;();
+
+    private final Set&lt;String&gt; info_hashes = new HashSet&lt;String&gt;();
+
+    private Map&lt;String, HashSet&lt;PeerID&gt;&gt; peers =
+        new HashMap&lt;String, HashSet&lt;PeerID&gt;&gt;();
+
+    public Tracker (HashSet&lt;String&gt; hashes)
+    {
+        for (String hash : hashes) {
+            info_hashes.add(hash);
+            peers.put(hash, new HashSet&lt;PeerID&gt;());
+        }
+    }
+
+    public Tracker (MetaInfo info)
+    {
+        String hash = info.getHexInfoHash();
+        info_hashes.add(hash);
+        metainfo.put(hash, info);
+        peers.put(hash, new HashSet&lt;PeerID&gt;());
+    }
+
+    public MetaInfo getMetaInfo (String hash)
+    {
+        return metainfo.get(hash);
+    }
+
+    public void addPeer (String info_hash, PeerID peer)
+    {
+        HashSet&lt;PeerID&gt; peerset = peers.get(info_hash);
+        if (peerset != null) {
+            synchronized (peerset) {
+                peerset.add(peer);
+            }
+        }
+    }
+
+    public byte[] handleRequest (InetAddress address, int port, Map params)
+    {
+        log.log(Level.FINE, &quot;TrackerReq &quot; + address + &quot;:&quot; + port + &quot; -&gt; &quot;
+            + params);
+
+        String info_hash_value = (String)params.get(&quot;info_hash&quot;);
+        if (info_hash_value == null) {
+            return failure(&quot;No info_hash given&quot;);
+        }
+        info_hash_value = info_hash_value.replace(&quot;%&quot;, &quot;&quot;);
+
+        boolean found = false;
+        for (String hash : info_hashes) {
+            if (hash.equals(info_hash_value)) {
+                found = true;
+            }
+        }
+        if (!found) {
+            return failure(&quot;Tracker doesn't handle given info_hash&quot;);
+        }
+
+        byte[] peer_id;
+        String peer_id_value = (String)params.get(&quot;peer_id&quot;);
+        if (peer_id_value == null) {
+            return failure(&quot;No peer_id given&quot;);
+        }
+
+        peer_id = urldecode(peer_id_value);
+        if (peer_id.length != 20) {
+            return failure(&quot;peer_id must be 20 bytes long&quot;);
+        }
+
+        int peer_port;
+        String peer_port_value = (String)params.get(&quot;port&quot;);
+        if (peer_port_value == null) {
+            return failure(&quot;No port given&quot;);
+        }
+
+        try {
+            peer_port = Integer.parseInt(peer_port_value);
+        } catch (NumberFormatException nfe) {
+            return failure(&quot;port not a number: &quot; + nfe);
+        }
+
+        // This is unsafe although other trackers support it.
+        // It is nice for people that use proxies, but opens up
+        // a whole can of worms (filling the tracker with fake ips).
+        //
+        // It could bee allowed for private use and local addresses
+        // See RFC1918 and 127.0.0.0/8.
+        /*
+         * String ip = (String)params.get(&quot;ip&quot;); if (ip != null) { try { address =
+         * InetAddress.getByName(ip); } catch (UnknownHostException uhe) { } }
+         */
+
+        PeerID peer = new PeerID(peer_id, address, peer_port);
+
+        Map&lt;String, Object&gt; response = new HashMap&lt;String, Object&gt;();
+        Set&lt;PeerID&gt; peerset = peers.get(info_hash_value);
+        synchronized (peerset) {
+            String event = (String)params.get(&quot;event&quot;);
+            if (&quot;stopped&quot;.equals(event)) {
+                peerset.remove(peer);
+            } else {
+                peerset.add(peer);
+            }
+
+            response.put(&quot;interval&quot;, new Integer(INTERVAL_SEC));
+            List&lt;Map&lt;String, Object&gt;&gt; peerList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();
+            Iterator it = peerset.iterator();
+            while (it.hasNext()) {
+                PeerID peerID = (PeerID)it.next();
+                Map&lt;String, Object&gt; m = new HashMap&lt;String, Object&gt;();
+                m.put(&quot;peer id&quot;, peerID.getID());
+                m.put(&quot;ip&quot;, peerID.getAddress().getHostAddress());
+                m.put(&quot;port&quot;, new Integer(peerID.getPort()));
+                peerList.add(m);
+            }
+            response.put(&quot;peers&quot;, peerList);
+        }
+
+        log.log(Level.FINE, &quot;Tracker response: &quot; + response);
+
+        return BEncoder.bencode(response);
+    }
+
+    private static byte[] failure (String s)
+    {
+        Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;();
+        m.put(&quot;failure reason&quot;, s);
+        return BEncoder.bencode(m);
+    }
+
+    /**
+     * Cheap (but slow) urldecode String to byte array.
+     */
+    static byte[] urldecode (String s)
+    {
+        s = s.replace('+', ' ');
+        char[] cs = s.toCharArray();
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        int i = 0;
+        while (i &lt; cs.length) {
+            if (cs[i] != '%') {
+                baos.write((byte)cs[i]);
+                i++;
+            } else if (i + 2 &lt; cs.length) {
+                int val = 16 * Character.digit(cs[i + 1], 16)
+                    + Character.digit(cs[i + 2], 16);
+                baos.write((byte)val);
+                i += 3;
+            } else {
+                i++;
+            }
+        }
+        return baos.toByteArray();
+    }
+
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.Tracker&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/TrackerClient.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/TrackerClient.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/TrackerClient.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,258 @@
+/*
+ * TrackerClient - Class that informs a tracker and gets new peers. Copyright
+ * (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.Iterator;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Informs metainfo tracker of events and gets new peers for peer coordinator.
+ * 
+ * @author Mark Wielaard (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">mark at klomp.org</A>)
+ */
+public class TrackerClient extends Thread
+{
+    private static final String NO_EVENT = &quot;&quot;;
+
+    private static final String STARTED_EVENT = &quot;started&quot;;
+
+    private static final String COMPLETED_EVENT = &quot;completed&quot;;
+
+    private static final String STOPPED_EVENT = &quot;stopped&quot;;
+
+    private final static int SLEEP = 1; // Check in with tracker every minute
+
+    private final MetaInfo meta;
+
+    private final PeerCoordinator coordinator;
+
+    private final int port;
+
+    private boolean stop;
+
+    private long interval;
+
+    private long lastRequestTime;
+
+    public TrackerClient (MetaInfo meta, PeerCoordinator coordinator, int port)
+    {
+        // Set unique name.
+        super(&quot;TrackerClient-&quot; + urlencode(coordinator.getID()));
+        this.meta = meta;
+        this.coordinator = coordinator;
+
+        // XXX - No way to actaully give the tracker feedback that we
+        // don't run a peer acceptor on any port so use discard 9/tcp sink null
+        this.port = (port == -1) ? 9 : port;
+
+        stop = false;
+    }
+
+    /**
+     * Interrupts this Thread to stop it.
+     */
+    public void halt ()
+    {
+        stop = true;
+        this.interrupt();
+    }
+
+    @Override
+    public void run ()
+    {
+        // XXX - Support other IPs
+        String announce = meta.getAnnounce();
+        String infoHash = urlencode(meta.getInfoHash());
+        String peerID = urlencode(coordinator.getID());
+
+        long uploaded = coordinator.getUploaded();
+        long downloaded = coordinator.getDownloaded();
+        long left = coordinator.getLeft();
+
+        boolean completed = coordinator.completed();
+
+        boolean started = false;
+        try {
+            int failures = 0;
+            while (!started &amp;&amp; failures &lt; MAX_FAILURE_COUNT) {
+                try {
+                    // Send start.
+                    TrackerInfo info = doRequest(announce, infoHash, peerID,
+                        uploaded, downloaded, left, STARTED_EVENT);
+                    Iterator it = info.getPeers().iterator();
+                    while (it.hasNext()) {
+                        coordinator.addPeer((Peer)it.next());
+                    }
+                    started = true;
+                } catch (IOException ioe) {
+                    // Probably not fatal (if it doesn't last to long...)
+                    log.log(Level.WARNING, &quot;Could not contact tracker at '&quot;
+                        + announce, ioe);
+                }
+
+                if (!started) {
+                    failures++;
+                    log.log(Level.FINER, &quot;     Retrying in 5s...&quot;);
+                    try {
+                        // Sleep five seconds...
+                        Thread.sleep(5 * 1000);
+                    } catch (InterruptedException interrupt) {
+                        // ignore
+                    }
+                }
+            }
+
+            if (failures &gt;= MAX_FAILURE_COUNT) {
+                throw new IOException(&quot;Could not establish initial connection&quot;);
+            }
+
+            while (!stop) {
+                try {
+                    // Sleep some minutes...
+                    Thread.sleep(SLEEP * 60 * 1000);
+                } catch (InterruptedException interrupt) {
+                    // ignore
+                }
+
+                if (stop) {
+                    break;
+                }
+
+                uploaded = coordinator.getUploaded();
+                downloaded = coordinator.getDownloaded();
+                left = coordinator.getLeft();
+
+                // First time we got a complete download?
+                String event;
+                if (!completed &amp;&amp; coordinator.completed()) {
+                    completed = true;
+                    event = COMPLETED_EVENT;
+                } else {
+                    event = NO_EVENT;
+                }
+
+                // Only do a request when necessary.
+                if (event == COMPLETED_EVENT || coordinator.needPeers()
+                    || System.currentTimeMillis() &gt; lastRequestTime + interval) {
+                    try {
+                        TrackerInfo info = doRequest(announce, infoHash,
+                            peerID, uploaded, downloaded, left, event);
+
+                        Iterator it = info.getPeers().iterator();
+                        while (it.hasNext()) {
+                            coordinator.addPeer((Peer)it.next());
+                        }
+                    } catch (IOException ioe) {
+                        // Probably not fatal (if it doesn't last to long...)
+                        log.log(Level.WARNING, &quot;Could not contact tracker at '&quot;
+                            + announce, ioe);
+                    }
+                }
+            }
+
+        } catch (Throwable t) {
+            log.log(Level.SEVERE, &quot;Fatal exception in TrackerClient&quot;, t);
+        } finally {
+            try {
+                if (started) {
+                    doRequest(announce, infoHash, peerID, uploaded, downloaded,
+                        left, STOPPED_EVENT);
+                }
+            } catch (IOException ioe) { /* ignored */
+            }
+        }
+
+    }
+
+    private TrackerInfo doRequest (String announce, String infoHash,
+        String peerID, long uploaded, long downloaded, long left, String event)
+        throws IOException
+    {
+        String s = announce + &quot;?info_hash=&quot; + infoHash + &quot;&amp;peer_id=&quot; + peerID
+            + &quot;&amp;port=&quot; + port + &quot;&amp;uploaded=&quot; + uploaded + &quot;&amp;downloaded=&quot;
+            + downloaded + &quot;&amp;left=&quot; + left
+            + ((event != NO_EVENT) ? (&quot;&amp;event=&quot; + event) : &quot;&quot;);
+        URL u = new URL(s);
+        log.log(Level.FINE, &quot;Sending TrackerClient request: &quot; + u);
+
+        URLConnection c = u.openConnection();
+        c.connect();
+        InputStream in = c.getInputStream();
+
+        if (c instanceof HttpURLConnection) {
+            // Check whether the page exists
+            int code = ((HttpURLConnection)c).getResponseCode();
+            if (code == HttpURLConnection.HTTP_FORBIDDEN) {
+                throw new IOException(&quot;Tracker doesn't handle given info_hash&quot;);
+            } else if (code / 100 != 2) {
+                throw new IOException(&quot;Loading '&quot; + s + &quot;' gave error code &quot;
+                    + code + &quot;, it probably doesn't exist&quot;);
+            }
+        }
+
+        TrackerInfo info = new TrackerInfo(in, coordinator.getID(),
+            coordinator.getMetaInfo());
+        log.log(Level.FINE, &quot;TrackerClient response: &quot; + info);
+        lastRequestTime = System.currentTimeMillis();
+
+        String failure = info.getFailureReason();
+        if (failure != null) {
+            throw new IOException(failure);
+        }
+
+        interval = info.getInterval() * 1000;
+        return info;
+    }
+
+    /**
+     * Very lazy byte[] to URL encoder. Just encodes everything, even &quot;normal&quot;
+     * chars.
+     */
+    static String urlencode (byte[] bs)
+    {
+        StringBuffer sb = new StringBuffer(bs.length * 3);
+        for (byte element : bs) {
+            int c = element &amp; 0xFF;
+            sb.append('%');
+            if (c &lt; 16) {
+                sb.append('0');
+            }
+            sb.append(Integer.toHexString(c));
+        }
+
+        return sb.toString();
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.TrackerClient&quot;);
+
+    /**
+     * The maximum number of times that we are allowed to fail to make an
+     * initial contact with the tracker before we bail
+     */
+    protected static final int MAX_FAILURE_COUNT = 2;
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/TrackerInfo.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/TrackerInfo.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/TrackerInfo.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,131 @@
+/*
+ * TrackerInfo - Holds information returned by a tracker, mainly the peer list.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.klomp.snark.bencode.BDecoder;
+import org.klomp.snark.bencode.BEValue;
+import org.klomp.snark.bencode.InvalidBEncodingException;
+
+public class TrackerInfo
+{
+    private final String failure_reason;
+
+    private final int interval;
+
+    private final Set peers;
+
+    public TrackerInfo (InputStream in, byte[] my_id, MetaInfo metainfo)
+        throws IOException
+    {
+        this(new BDecoder(in), my_id, metainfo);
+    }
+
+    public TrackerInfo (BDecoder be, byte[] my_id, MetaInfo metainfo)
+        throws IOException
+    {
+        this(be.bdecodeMap().getMap(), my_id, metainfo);
+    }
+
+    public TrackerInfo (Map m, byte[] my_id, MetaInfo metainfo)
+        throws IOException
+    {
+        BEValue reason = (BEValue)m.get(&quot;failure reason&quot;);
+        if (reason != null) {
+            failure_reason = reason.getString();
+            interval = -1;
+            peers = null;
+        } else {
+            failure_reason = null;
+            BEValue beInterval = (BEValue)m.get(&quot;interval&quot;);
+            if (beInterval == null) {
+                throw new InvalidBEncodingException(&quot;No interval given&quot;);
+            } else {
+                interval = beInterval.getInt();
+            }
+            BEValue bePeers = (BEValue)m.get(&quot;peers&quot;);
+            if (bePeers == null) {
+                throw new InvalidBEncodingException(&quot;No peer list&quot;);
+            } else {
+                peers = getPeers(bePeers.getList(), my_id, metainfo);
+            }
+        }
+    }
+
+    public static Set getPeers (InputStream in, byte[] my_id, MetaInfo metainfo)
+        throws IOException
+    {
+        return getPeers(new BDecoder(in), my_id, metainfo);
+    }
+
+    public static Set getPeers (BDecoder be, byte[] my_id, MetaInfo metainfo)
+        throws IOException
+    {
+        return getPeers(be.bdecodeList().getList(), my_id, metainfo);
+    }
+
+    public static Set&lt;Peer&gt; getPeers (List l, byte[] my_id, MetaInfo metainfo)
+        throws IOException
+    {
+        Set&lt;Peer&gt; peers = new HashSet&lt;Peer&gt;(l.size());
+
+        Iterator it = l.iterator();
+        while (it.hasNext()) {
+            PeerID peerID = new PeerID(((BEValue)it.next()).getMap());
+            peers.add(new Peer(peerID, my_id, metainfo));
+        }
+
+        return peers;
+    }
+
+    public Set getPeers ()
+    {
+        return peers;
+    }
+
+    public String getFailureReason ()
+    {
+        return failure_reason;
+    }
+
+    public int getInterval ()
+    {
+        return interval;
+    }
+
+    @Override
+    public String toString ()
+    {
+        if (failure_reason != null) {
+            return &quot;TrackerInfo[FAILED: &quot; + failure_reason + &quot;]&quot;;
+        } else {
+            return &quot;TrackerInfo[interval=&quot; + interval + &quot;, peers=&quot; + peers
+                + &quot;]&quot;;
+        }
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BDecoder.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BDecoder.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BDecoder.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,358 @@
+/*
+ * BDecoder - Converts an InputStream to BEValues. Copyright (C) 2003 Mark J.
+ * Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark.bencode;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Decodes a bencoded stream to &lt;code&gt;BEValue&lt;/code&gt;s.
+ * 
+ * A bencoded byte stream can represent byte arrays, numbers, lists and maps
+ * (dictionaries).
+ * 
+ * It currently contains a hack to indicate a name of a dictionary of which a
+ * SHA-1 digest hash should be calculated (the hash over the original bencoded
+ * bytes).
+ * 
+ * @author Mark Wielaard (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">mark at klomp.org</A>).
+ */
+public class BDecoder
+{
+    // The InputStream to BDecode.
+    private final InputStream in;
+
+    // The last indicator read.
+    // Zero if unknown.
+    // '0'..'9' indicates a byte[].
+    // 'i' indicates an Number.
+    // 'l' indicates a List.
+    // 'd' indicates a Map.
+    // 'e' indicates end of Number, List or Map (only used internally).
+    // -1 indicates end of stream.
+    // Call getNextIndicator to get the current value (will never return zero).
+    private int indicator = 0;
+
+    // Used for ugly hack to get SHA hash over the metainfo info map
+    private String special_map = &quot;info&quot;;
+
+    private boolean in_special_map = false;
+
+    private final MessageDigest sha_digest;
+
+    // Ugly hack. Return the SHA has over bytes that make up the special map.
+    public byte[] get_special_map_digest ()
+    {
+        byte[] result = sha_digest.digest();
+        return result;
+    }
+
+    // Ugly hack. Name defaults to &quot;info&quot;.
+    public void set_special_map_name (String name)
+    {
+        special_map = name;
+    }
+
+    /**
+     * Initalizes a new BDecoder. Nothing is read from the given
+     * &lt;code&gt;InputStream&lt;/code&gt; yet.
+     */
+    public BDecoder (InputStream in)
+    {
+        this.in = in;
+        // XXX - Used for ugly hack.
+        try {
+            sha_digest = MessageDigest.getInstance(&quot;SHA&quot;);
+        } catch (NoSuchAlgorithmException nsa) {
+            throw new InternalError(nsa.toString());
+        }
+    }
+
+    /**
+     * Creates a new BDecoder and immediatly decodes the first value it sees.
+     * 
+     * @return The first BEValue on the stream or null when the stream has
+     *         ended.
+     * 
+     * @exception InvalidBEncoding
+     *                when the stream doesn't start with a bencoded value or the
+     *                stream isn't a bencoded stream at all.
+     * @exception IOException
+     *                when somthing bad happens with the stream to read from.
+     */
+    public static BEValue bdecode (InputStream in) throws IOException
+    {
+        return new BDecoder(in).bdecode();
+    }
+
+    /**
+     * Returns what the next bencoded object will be on the stream or -1 when
+     * the end of stream has been reached. Can return something unexpected (not
+     * '0' .. '9', 'i', 'l' or 'd') when the stream isn't bencoded.
+     * 
+     * This might or might not read one extra byte from the stream.
+     */
+    public int getNextIndicator () throws IOException
+    {
+        if (indicator == 0) {
+            indicator = in.read();
+            // XXX - Used for ugly hack
+            if (in_special_map) {
+                sha_digest.update((byte)indicator);
+            }
+        }
+        return indicator;
+    }
+
+    /**
+     * Gets the next indicator and returns either null when the stream has ended
+     * or bdecodes the rest of the stream and returns the appropriate BEValue
+     * encoded object.
+     */
+    public BEValue bdecode () throws IOException
+    {
+        indicator = getNextIndicator();
+        if (indicator == -1) {
+            return null;
+        }
+
+        if (indicator &gt;= '0' &amp;&amp; indicator &lt;= '9') {
+            return bdecodeBytes();
+        } else if (indicator == 'i') {
+            return bdecodeNumber();
+        } else if (indicator == 'l') {
+            return bdecodeList();
+        } else if (indicator == 'd') {
+            return bdecodeMap();
+        } else {
+            throw new InvalidBEncodingException(&quot;Unknown indicator '&quot;
+                + indicator + &quot;'&quot;);
+        }
+    }
+
+    /**
+     * Returns the next bencoded value on the stream and makes sure it is a byte
+     * array. If it is not a bencoded byte array it will throw
+     * InvalidBEncodingException.
+     */
+    public BEValue bdecodeBytes () throws IOException
+    {
+        int c = getNextIndicator();
+        int num = c - '0';
+        if (num &lt; 0 || num &gt; 9) {
+            throw new InvalidBEncodingException(&quot;Number expected, not '&quot;
+                + (char)c + &quot;'&quot;);
+        }
+        indicator = 0;
+
+        c = read();
+        int i = c - '0';
+        while (i &gt;= 0 &amp;&amp; i &lt;= 9) {
+            // XXX - This can overflow!
+            num = num * 10 + i;
+            c = read();
+            i = c - '0';
+        }
+
+        if (c != ':') {
+            throw new InvalidBEncodingException(&quot;Colon expected, not '&quot;
+                + (char)c + &quot;'&quot;);
+        }
+
+        return new BEValue(read(num));
+    }
+
+    /**
+     * Returns the next bencoded value on the stream and makes sure it is a
+     * number. If it is not a number it will throw InvalidBEncodingException.
+     */
+    public BEValue bdecodeNumber () throws IOException
+    {
+        int c = getNextIndicator();
+        if (c != 'i') {
+            throw new InvalidBEncodingException(&quot;Expected 'i', not '&quot; + (char)c
+                + &quot;'&quot;);
+        }
+        indicator = 0;
+
+        c = read();
+        if (c == '0') {
+            c = read();
+            if (c == 'e') {
+                return new BEValue(BigInteger.ZERO);
+            } else {
+                throw new InvalidBEncodingException(&quot;'e' expected after zero,&quot;
+                    + &quot; not '&quot; + (char)c + &quot;'&quot;);
+            }
+        }
+
+        // XXX - We don't support more the 255 char big integers
+        char[] chars = new char[256];
+        int off = 0;
+
+        if (c == '-') {
+            c = read();
+            if (c == '0') {
+                throw new InvalidBEncodingException(&quot;Negative zero not allowed&quot;);
+            }
+            chars[off] = (char)c;
+            off++;
+        }
+
+        if (c &lt; '1' || c &gt; '9') {
+            throw new InvalidBEncodingException(&quot;Invalid Integer start '&quot;
+                + (char)c + &quot;'&quot;);
+        }
+        chars[off] = (char)c;
+        off++;
+
+        c = read();
+        int i = c - '0';
+        while (i &gt;= 0 &amp;&amp; i &lt;= 9) {
+            chars[off] = (char)c;
+            off++;
+            c = read();
+            i = c - '0';
+        }
+
+        if (c != 'e') {
+            throw new InvalidBEncodingException(&quot;Integer should end with 'e'&quot;);
+        }
+
+        String s = new String(chars, 0, off);
+        return new BEValue(new BigInteger(s));
+    }
+
+    /**
+     * Returns the next bencoded value on the stream and makes sure it is a
+     * list. If it is not a list it will throw InvalidBEncodingException.
+     */
+    public BEValue bdecodeList () throws IOException
+    {
+        int c = getNextIndicator();
+        if (c != 'l') {
+            throw new InvalidBEncodingException(&quot;Expected 'l', not '&quot; + (char)c
+                + &quot;'&quot;);
+        }
+        indicator = 0;
+
+        List&lt;BEValue&gt; result = new ArrayList&lt;BEValue&gt;();
+        c = getNextIndicator();
+        while (c != 'e') {
+            result.add(bdecode());
+            c = getNextIndicator();
+        }
+        indicator = 0;
+
+        return new BEValue(result);
+    }
+
+    /**
+     * Returns the next bencoded value on the stream and makes sure it is a map
+     * (dictonary). If it is not a map it will throw InvalidBEncodingException.
+     */
+    public BEValue bdecodeMap () throws IOException
+    {
+        int c = getNextIndicator();
+        if (c != 'd') {
+            throw new InvalidBEncodingException(&quot;Expected 'd', not '&quot; + (char)c
+                + &quot;'&quot;);
+        }
+        indicator = 0;
+
+        Map&lt;String, BEValue&gt; result = new HashMap&lt;String, BEValue&gt;();
+        c = getNextIndicator();
+        while (c != 'e') {
+            // Dictonary keys are always strings.
+            String key = bdecode().getString();
+
+            // XXX ugly hack
+            boolean special = special_map.equals(key);
+            if (special) {
+                in_special_map = true;
+            }
+
+            BEValue value = bdecode();
+            result.put(key, value);
+
+            // XXX ugly hack continued
+            if (special) {
+                in_special_map = false;
+            }
+
+            c = getNextIndicator();
+        }
+        indicator = 0;
+
+        return new BEValue(result);
+    }
+
+    /**
+     * Returns the next byte read from the InputStream (as int). Throws
+     * EOFException if InputStream.read() returned -1.
+     */
+    private int read () throws IOException
+    {
+        int c = in.read();
+        if (c == -1) {
+            throw new EOFException();
+        }
+        if (in_special_map) {
+            sha_digest.update((byte)c);
+        }
+        return c;
+    }
+
+    /**
+     * Returns a byte[] containing length valid bytes starting at offset zero.
+     * Throws EOFException if InputStream.read() returned -1 before all
+     * requested bytes could be read. Note that the byte[] returned might be
+     * bigger then requested but will only contain length valid bytes. The
+     * returned byte[] will be reused when this method is called again.
+     */
+    private byte[] read (int length) throws IOException
+    {
+        byte[] result = new byte[length];
+
+        int read = 0;
+        while (read &lt; length) {
+            int i = in.read(result, read, length - read);
+            if (i == -1) {
+                throw new EOFException();
+            }
+            read += i;
+        }
+
+        if (in_special_map) {
+            sha_digest.update(result, 0, length);
+        }
+        return result;
+    }
+
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BEValue.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BEValue.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BEValue.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,172 @@
+/*
+ * BEValue - Holds different types that a bencoded byte array can represent.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark.bencode;
+
+import java.io.UnsupportedEncodingException;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Holds different types that a bencoded byte array can represent. You need to
+ * call the correct get method to get the correct java type object. If the
+ * BEValue wasn't actually of the requested type you will get a
+ * InvalidBEncodingException.
+ * 
+ * @author Mark Wielaard (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">mark at klomp.org</A>)
+ */
+public class BEValue
+{
+    // This is either a byte[], Number, List or Map.
+    private final Object value;
+
+    public BEValue (byte[] value)
+    {
+        this.value = value;
+    }
+
+    public BEValue (Number value)
+    {
+        this.value = value;
+    }
+
+    public BEValue (List value)
+    {
+        this.value = value;
+    }
+
+    public BEValue (Map value)
+    {
+        this.value = value;
+    }
+
+    /**
+     * Returns this BEValue as a String. This operation only succeeds when the
+     * BEValue is a byte[], otherwise it will throw a InvalidBEncodingException.
+     * The byte[] will be interpreted as UTF-8 encoded characters.
+     */
+    public String getString () throws InvalidBEncodingException
+    {
+        try {
+            return new String(getBytes(), &quot;UTF-8&quot;);
+        } catch (ClassCastException cce) {
+            throw new InvalidBEncodingException(cce.toString());
+        } catch (UnsupportedEncodingException uee) {
+            throw new InternalError(uee.toString());
+        }
+    }
+
+    /**
+     * Returns this BEValue as a byte[]. This operation only succeeds when the
+     * BEValue is actually a byte[], otherwise it will throw a
+     * InvalidBEncodingException.
+     */
+    public byte[] getBytes () throws InvalidBEncodingException
+    {
+        try {
+            return (byte[])value;
+        } catch (ClassCastException cce) {
+            throw new InvalidBEncodingException(cce.toString());
+        }
+    }
+
+    /**
+     * Returns this BEValue as a Number. This operation only succeeds when the
+     * BEValue is actually a Number, otherwise it will throw a
+     * InvalidBEncodingException.
+     */
+    public Number getNumber () throws InvalidBEncodingException
+    {
+        try {
+            return (Number)value;
+        } catch (ClassCastException cce) {
+            throw new InvalidBEncodingException(cce.toString());
+        }
+    }
+
+    /**
+     * Returns this BEValue as int. This operation only succeeds when the
+     * BEValue is actually a Number, otherwise it will throw a
+     * InvalidBEncodingException. The returned int is the result of
+     * &lt;code&gt;Number.intValue()&lt;/code&gt;.
+     */
+    public int getInt () throws InvalidBEncodingException
+    {
+        return getNumber().intValue();
+    }
+
+    /**
+     * Returns this BEValue as long. This operation only succeeds when the
+     * BEValue is actually a Number, otherwise it will throw a
+     * InvalidBEncodingException. The returned long is the result of
+     * &lt;code&gt;Number.longValue()&lt;/code&gt;.
+     */
+    public long getLong () throws InvalidBEncodingException
+    {
+        return getNumber().longValue();
+    }
+
+    /**
+     * Returns this BEValue as a List of BEValues. This operation only succeeds
+     * when the BEValue is actually a List, otherwise it will throw a
+     * InvalidBEncodingException.
+     */
+    public List&lt;BEValue&gt; getList () throws InvalidBEncodingException
+    {
+        try {
+            return (List&lt;BEValue&gt;)value;
+        } catch (ClassCastException cce) {
+            throw new InvalidBEncodingException(cce.toString());
+        }
+    }
+
+    /**
+     * Returns this BEValue as a Map of BEValue keys and BEValue values. This
+     * operation only succeeds when the BEValue is actually a Map, otherwise it
+     * will throw a InvalidBEncodingException.
+     */
+    public Map getMap () throws InvalidBEncodingException
+    {
+        try {
+            return (Map)value;
+        } catch (ClassCastException cce) {
+            throw new InvalidBEncodingException(cce.toString());
+        }
+    }
+
+    @Override
+    public String toString ()
+    {
+        String valueString;
+        if (value instanceof byte[]) {
+            byte[] bs = (byte[])value;
+            // XXX - Stupid heuristic...
+            if (bs.length &lt;= 12) {
+                valueString = new String(bs);
+            } else {
+                valueString = &quot;bytes:&quot; + bs.length;
+            }
+        } else {
+            valueString = value.toString();
+        }
+
+        return &quot;BEValue[&quot; + valueString + &quot;]&quot;;
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BEncoder.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BEncoder.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/BEncoder.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,171 @@
+/*
+ * BDecoder - Converts an InputStream to BEValues. Copyright (C) 2003 Mark J.
+ * Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark.bencode;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class BEncoder
+{
+
+    public static byte[] bencode (Object o) throws IllegalArgumentException
+    {
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            bencode(o, baos);
+            return baos.toByteArray();
+        } catch (IOException ioe) {
+            throw new InternalError(ioe.toString());
+        }
+    }
+
+    public static void bencode (Object o, OutputStream out) throws IOException,
+        IllegalArgumentException
+    {
+        if (o instanceof String) {
+            bencode((String)o, out);
+        } else if (o instanceof byte[]) {
+            bencode((byte[])o, out);
+        } else if (o instanceof Number) {
+            bencode((Number)o, out);
+        } else if (o instanceof List) {
+            bencode((List)o, out);
+        } else if (o instanceof Map) {
+            bencode((Map&lt;String, Object&gt;)o, out);
+        } else {
+            throw new IllegalArgumentException(&quot;Cannot bencode: &quot;
+                + o.getClass());
+        }
+    }
+
+    public static byte[] bencode (String s)
+    {
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            bencode(s, baos);
+            return baos.toByteArray();
+        } catch (IOException ioe) {
+            throw new InternalError(ioe.toString());
+        }
+    }
+
+    public static void bencode (String s, OutputStream out) throws IOException
+    {
+        byte[] bs = s.getBytes(&quot;UTF-8&quot;);
+        bencode(bs, out);
+    }
+
+    public static byte[] bencode (Number n)
+    {
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            bencode(n, baos);
+            return baos.toByteArray();
+        } catch (IOException ioe) {
+            throw new InternalError(ioe.toString());
+        }
+    }
+
+    public static void bencode (Number n, OutputStream out) throws IOException
+    {
+        out.write('i');
+        String s = n.toString();
+        out.write(s.getBytes(&quot;UTF-8&quot;));
+        out.write('e');
+    }
+
+    public static byte[] bencode (List l)
+    {
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            bencode(l, baos);
+            return baos.toByteArray();
+        } catch (IOException ioe) {
+            throw new InternalError(ioe.toString());
+        }
+    }
+
+    public static void bencode (List l, OutputStream out) throws IOException
+    {
+        out.write('l');
+        Iterator it = l.iterator();
+        while (it.hasNext()) {
+            bencode(it.next(), out);
+        }
+        out.write('e');
+    }
+
+    public static byte[] bencode (byte[] bs)
+    {
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            bencode(bs, baos);
+            return baos.toByteArray();
+        } catch (IOException ioe) {
+            throw new InternalError(ioe.toString());
+        }
+    }
+
+    public static void bencode (byte[] bs, OutputStream out) throws IOException
+    {
+        String l = Integer.toString(bs.length);
+        out.write(l.getBytes(&quot;UTF-8&quot;));
+        out.write(':');
+        out.write(bs);
+    }
+
+    public static byte[] bencode (Map&lt;String, Object&gt; m)
+    {
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            bencode(m, baos);
+            return baos.toByteArray();
+        } catch (IOException ioe) {
+            throw new InternalError(ioe.toString());
+        }
+    }
+
+    public static void bencode (Map&lt;String, Object&gt; m, OutputStream out)
+        throws IOException
+    {
+        out.write('d');
+
+        // Keys must be sorted. XXX - But is this the correct order?
+        Set&lt;String&gt; s = m.keySet();
+        List&lt;String&gt; l = new ArrayList&lt;String&gt;(s);
+        Collections.sort(l);
+
+        for (String key : l) {
+            Object value = m.get(key);
+            bencode(key, out);
+            bencode(value, out);
+        }
+
+        out.write('e');
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/InvalidBEncodingException.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/InvalidBEncodingException.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/bencode/InvalidBEncodingException.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,36 @@
+/*
+ * InvalidBEncodingException - Thrown when a bencoded stream is corrupted.
+ * Copyright (C) 2003 Mark J. Wielaard
+ * 
+ * This file is part of Snark.
+ * 
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package org.klomp.snark.bencode;
+
+import java.io.IOException;
+
+/**
+ * Exception thrown when a bencoded stream is corrupted.
+ * 
+ * @author Mark Wielaard (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">mark at klomp.org</A>)
+ */
+public class InvalidBEncodingException extends IOException
+{
+    public InvalidBEncodingException (String message)
+    {
+        super(message);
+    }
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/ConsoleStorageReporter.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/ConsoleStorageReporter.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/ConsoleStorageReporter.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,73 @@
+package org.klomp.snark.cmd;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.klomp.snark.MetaInfo;
+import org.klomp.snark.Storage;
+import org.klomp.snark.StorageListener;
+
+/**
+ * Reports the status of allocation of space via logging data to
+ * the console.
+ * 
+ * @author Elizabeth Fong (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">elizabeth at ctyalcove.org</A>)
+ */
+public class ConsoleStorageReporter implements StorageListener
+{
+    public void storageCreateFile (Storage storage, String name, long length)
+    {
+        log.log(Level.FINE, &quot;Creating file '&quot; + name + &quot;' of length &quot; +
+            length + &quot;: &quot;);
+    }
+
+    // How much storage space has been allocated
+    private long allocated = 0;
+
+    public void storageAllocated (Storage storage, long length)
+    {
+        System.err.print(&quot;.&quot;);
+        allocated += length;
+        if (allocated == storage.getMetaInfo().getTotalLength()) {
+            System.err.println();
+            log.log(Level.INFO, &quot;Finished allocating storage space&quot;);
+        }
+    }
+
+    boolean allChecked = false;
+
+    boolean checking = false;
+
+    public void storageChecked (Storage storage, int num, boolean checked)
+    {
+        if (!allChecked &amp;&amp; !checking) {
+            // Use the MetaInfo from the storage since our own might not
+            // yet be setup correctly.
+            MetaInfo meta = storage.getMetaInfo();
+            if (meta != null) {
+                log.log(Level.INFO, &quot;Checking existing &quot; + meta.getPieces()
+                    + &quot; pieces: &quot;);
+            }
+            checking = true;
+        }
+        if (checking) {
+            if (checked) {
+                System.err.print(&quot;+&quot;);
+            } else {
+                System.err.print(&quot;-&quot;);
+            }
+        } else {
+            log.log(Level.FINE, &quot;Got &quot; + (checked ? &quot;&quot; : &quot;BAD &quot;) + &quot;piece: &quot;
+                + num);
+        }
+    }
+
+    public void storageAllChecked (Storage storage)
+    {
+        allChecked = true;
+        checking = false;
+    }
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.storage&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/SnarkApplication.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/SnarkApplication.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/cmd/SnarkApplication.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,293 @@
+package org.klomp.snark.cmd;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintStream;
+import java.util.Iterator;
+import java.util.List;
+import java.util.logging.Logger;
+import java.util.logging.Level;
+import java.util.Timer;
+import java.util.TimerTask;
+
+import org.klomp.snark.CoordinatorListener;
+import org.klomp.snark.Peer;
+import org.klomp.snark.PeerMonitorTask;
+import org.klomp.snark.ShutdownListener;
+import org.klomp.snark.Snark;
+import org.klomp.snark.SnarkShutdown;
+import org.klomp.snark.StorageListener;
+
+/**
+ * A basic command line interface to the Snark library.
+ * 
+ * @author Elizabeth Fong (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">elizabeth at threerings.net</A>)
+ */
+public class SnarkApplication
+{
+    public static void main (String[] args)
+    {
+        System.out.println(copyright);
+        System.out.println();
+
+        // Parse debug, share/ip and torrent file options.
+        Snark snark = parseArguments(args, new ConsoleStorageReporter(), null);
+        boolean interactive = true;
+        boolean showPeers = false;
+        for (String arg : args) {
+            if (arg.equals(&quot;--no-commands&quot;)) {
+                interactive = false;
+            }
+            if (arg.equals(&quot;--show-peers&quot;) || arg.equals(&quot;--share&quot;)) {
+                showPeers = true;
+            }
+        };
+
+        // Set things up to exit gracefully
+        ShutdownListener listener = new ShutdownListener() {
+            // documentation inherited from interface ShutdownListener
+            public void shutdown ()
+            {
+                // Should not be necessary since all non-deamon threads should
+                // have died. But in reality this does not always happen.
+                System.exit(0);
+            }
+        };
+        SnarkShutdown hook = new SnarkShutdown(snark, listener);
+        Runtime.getRuntime().addShutdownHook(hook);
+
+        // Let's start grabbing files!
+        try {
+            snark.setupNetwork();
+            snark.collectPieces();
+        } catch (IOException ioe) {
+            System.exit(-1);
+        }
+
+        // If requested, periodically monitor progress.
+        if (showPeers) {
+            Timer timer = new Timer(true);
+            TimerTask monitor = new PeerMonitorTask(snark.coordinator);
+            timer.schedule(monitor, PeerMonitorTask.MONITOR_PERIOD,
+                PeerMonitorTask.MONITOR_PERIOD);
+        }
+
+        // Start interactive command interpreter if desired
+        if (interactive) {
+            doInteractive(snark, hook);
+        }
+    }
+
+    /**
+     * Initializes the user-interactive readline interface to Snark
+     */
+    protected static void doInteractive (Snark snark, SnarkShutdown hook)
+    {
+        boolean quit = false;
+
+        System.out.println();
+        System.out.println(usage);
+        System.out.println();
+
+        try {
+            BufferedReader br = new BufferedReader(new InputStreamReader(
+                System.in));
+            String line = br.readLine();
+            while (!quit &amp;&amp; line != null) {
+                line = line.toLowerCase();
+                if (&quot;quit&quot;.equals(line)) {
+                    quit = true;
+                } else if (&quot;list&quot;.equals(line)) {
+                    synchronized (snark.coordinator.peers) {
+                        System.out.println(snark.coordinator.peers.size()
+                            + &quot; peers -&quot; + &quot; (i)nterested,&quot; + &quot; (I)nteresting,&quot;
+                            + &quot; (c)hoking,&quot; + &quot; (C)hoked:&quot;);
+                        Iterator it = snark.coordinator.peers.iterator();
+                        while (it.hasNext()) {
+                            Peer peer = (Peer)it.next();
+                            System.out.println(peer);
+                            System.out.println(&quot;\ti: &quot; + peer.isInterested()
+                                + &quot; I: &quot; + peer.isInteresting() + &quot; c: &quot;
+                                + peer.isChoking() + &quot; C: &quot; + peer.isChoked());
+                        }
+                    }
+                } else if (&quot;info&quot;.equals(line)) {
+                    System.out.println(&quot;Name: &quot; + snark.meta.getName());
+                    System.out.println(&quot;Torrent: &quot; + snark.torrent);
+                    System.out.println(&quot;Tracker: &quot; + snark.meta.getAnnounce());
+                    List files = snark.meta.getFiles();
+                    System.out.println(&quot;Files: &quot;
+                        + ((files == null) ? 1 : files.size()));
+                    System.out.println(&quot;Pieces: &quot; + snark.meta.getPieces());
+                    System.out.println(&quot;Piece size: &quot;
+                        + snark.meta.getPieceLength(0) / 1024 + &quot; KB&quot;);
+                    System.out.println(&quot;Total size: &quot;
+                        + snark.meta.getTotalLength() / (1024 * 1024) + &quot; MB&quot;);
+                } else if (&quot;state&quot;.equals(line)) {
+                    System.out.println(
+                        snark.storage.getBitField().getHumanReadable());
+                    System.out.println(&quot;Total peers: &quot;
+                        + snark.coordinator.getPeers());
+                    System.out.println(&quot;Total size: &quot;
+                        + snark.meta.getTotalLength() / (1024 * 1024) + &quot; MB&quot;);
+                    System.out.println(&quot;Total remaining: &quot;
+                        + snark.coordinator.getLeft() / (1024 * 1024) + &quot; MB&quot;);
+                    System.out.println(&quot;Total downloaded: &quot;
+                        + snark.coordinator.getDownloaded());
+                    System.out.println(&quot;Total uploaded: &quot;
+                        + snark.coordinator.getUploaded());
+                } else if (&quot;&quot;.equals(line) || &quot;help&quot;.equals(line)) {
+                    System.out.println(usage);
+                    System.out.println(help);
+                } else {
+                    System.out.println(&quot;Unknown command: &quot; + line);
+                    System.out.println(usage);
+                }
+
+                if (!quit) {
+                    System.out.println();
+                    line = br.readLine();
+                }
+            }
+        } catch (IOException ioe) {
+            log.log(Level.SEVERE, &quot;Unable to read stdin&quot;, ioe);
+        }
+
+        // Explicit shutdown.
+        Runtime.getRuntime().removeShutdownHook(hook);
+        hook.start();
+    }
+
+    /**
+     * Prints messages about proper usage of the Snark application.
+     */
+    protected static void usage (String s)
+    {
+        PrintStream stream = System.out;
+        if (s != null) {
+            stream = System.err;
+            stream.println(&quot;snark: &quot; + s);
+        }
+        stream.println(&quot;Usage: snark [--debug [level]] [--no-commands] [--port &lt;port&gt;]&quot;);
+        stream.println(&quot;  [--show-peers] [--share (&lt;ip&gt;|&lt;host&gt;)] (&lt;url&gt;|&lt;file&gt;|&lt;dir&gt;)&quot;);
+        stream.println(&quot;  --debug\tShows some extra info and stacktraces&quot;);
+        stream.println(&quot;    level\tHow much debug details to show&quot;);
+        stream.println(&quot;         \t(defaults to &quot; + Level.SEVERE
+            + &quot;, with --debug to &quot; + Level.INFO + &quot;, highest level is &quot;
+            + Level.ALL + &quot;).&quot;);
+        stream.println(&quot;  --no-commands\tDon't read interactive commands or show usage info.&quot;);
+        stream.println(&quot;  --port\tThe port to listen on for incomming connections&quot;);
+        stream.println(&quot;        \t(if not given defaults to first free port between &quot;
+            + Snark.MIN_PORT + &quot;-&quot; + Snark.MAX_PORT + &quot;).&quot;);
+        stream.println(&quot;  --show-peers\tIf enabled, periodically prints peer information.&quot;);
+        stream.println(&quot;  --share\tStart torrent tracker on &lt;ip&gt; address or &lt;host&gt; name.&quot;);
+        stream.println(&quot;  &lt;url&gt;  \tURL pointing to .torrent metainfo file to download/share.&quot;);
+        stream.println(&quot;  &lt;file&gt; \tEither a local .torrent metainfo file to download&quot;);
+        stream.println(&quot;         \tor (with --share) a file to share.&quot;);
+        stream.println(&quot;  &lt;dir&gt;  \tA directory with files to share (needs --share).&quot;);
+        System.exit(-1);
+    }
+
+    /**
+     * A convenience method for parsing arguments passed via the command line
+     * where no overriding of the listeners is required.
+     */
+    public static Snark parseArguments (String[] args)
+    {
+        return parseArguments(args, null, null);
+    }
+
+    /**
+     * Sets debug, ip and torrent variables then creates a Snark instance. Calls
+     * usage(), which terminates the program, if non-valid argument list. The
+     * given listeners will be passed to all components that take one.
+     */
+    public static Snark parseArguments (String[] args,
+        StorageListener slistener, CoordinatorListener clistener)
+    {
+        int user_port = -1;
+        String ip = null;
+        String torrent = null;
+        Level level = Level.INFO;
+
+        int i = 0;
+        while (i &lt; args.length) {
+            if (args[i].equals(&quot;--debug&quot;)) {
+                level = Level.FINE;
+                i++;
+
+                // Try if there is an level argument.
+                if (i &lt; args.length) {
+                    try {
+                        level = Level.parse(args[i]);
+                    } catch (IllegalArgumentException iae) {
+                        // continue parsing arguments
+                    }
+                    i++;
+                }
+            } else if (args[i].equals(&quot;--port&quot;)) {
+                if (args.length - 1 &lt; i + 1) {
+                    usage(&quot;--port needs port number to listen on&quot;);
+                }
+                try {
+                    user_port = Integer.parseInt(args[i + 1]);
+                } catch (NumberFormatException nfe) {
+                    usage(&quot;--port argument must be a number (&quot; + nfe + &quot;)&quot;);
+                }
+                i += 2;
+            } else if (args[i].equals(&quot;--share&quot;)) {
+                if (args.length - 1 &lt; i + 1) {
+                    usage(&quot;--share needs local ip-address or host-name&quot;);
+                }
+                ip = args[i + 1];
+                i += 2;
+            } else if (args[i].equals(&quot;--no-commands&quot;) ||
+                    args[i].equals(&quot;--show-peers&quot;)) {
+                // ignore, processed elsewhere.
+                i++;
+            } else if (args[i].equals(&quot;--help&quot;)) {
+                usage(null);
+            } else {
+                torrent = args[i];
+                i++;
+                break;
+            }
+        }
+        log.setLevel(level);
+        Snark.setLogLevel(level);
+
+        if (torrent == null || i != args.length) {
+            if (torrent != null &amp;&amp; torrent.startsWith(&quot;-&quot;)) {
+                usage(&quot;Unknown option '&quot; + torrent + &quot;'.&quot;);
+            } else {
+                usage(&quot;Need exactly one &lt;url&gt;, &lt;file&gt; or &lt;dir&gt;.&quot;);
+            }
+        }
+
+        Snark snark = new Snark(torrent, ip, user_port, slistener, clistener,&quot;&quot;);
+        return snark;
+    }
+
+    protected static final String newline = System.getProperty(&quot;line.separator&quot;);
+
+    protected static final String copyright =
+        &quot;The Hunting of the Snark Project - &quot;
+        + &quot;Copyright (C) 2003 Mark J. Wielaard, (c) 2006 Three Rings Design&quot;
+        + newline
+        + newline
+        + &quot;Snark comes with ABSOLUTELY NO WARRANTY.  This is free software, and&quot;
+        + newline
+        + &quot;you are welcome to redistribute it under certain conditions; read the&quot;
+        + newline + &quot;COPYING file for details.&quot;;
+
+    /** The message displayed when entering the interactive interface */
+    protected static final String usage =
+        &quot;Press return for help. Type \&quot;quit\&quot; and return to stop.&quot;;
+
+    /** A list of commands that the interactive interface accepts */
+    protected static final String help = &quot;Commands: 'info', 'list', 'quit'.&quot;;
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.cmd&quot;);
+}

Added: trunk/Lobby/AFLobby/src/org/klomp/snark/tracker/TrackerApplication.java
===================================================================
--- trunk/Lobby/AFLobby/src/org/klomp/snark/tracker/TrackerApplication.java	                        (rev 0)
+++ trunk/Lobby/AFLobby/src/org/klomp/snark/tracker/TrackerApplication.java	2008-02-19 00:09:34 UTC (rev 5513)
@@ -0,0 +1,136 @@
+package org.klomp.snark.tracker;
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.net.ServerSocket;
+import java.util.HashSet;
+import java.util.logging.Logger;
+import java.util.logging.Level;
+
+import org.klomp.snark.ConnectionAcceptor;
+import org.klomp.snark.HttpAcceptor;
+import org.klomp.snark.Snark;
+import org.klomp.snark.Tracker;
+
+/**
+ * A basic command line interface to the Snark library.
+ * 
+ * @author Elizabeth Fong (<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">elizabeth at threerings.net</A>)
+ */
+public class TrackerApplication
+{
+    public static void main (String[] args)
+    {
+        System.out.println(copyright);
+        System.out.println();
+
+        // Parse debug, share/ip and torrent file options.
+        try {
+            ConnectionAcceptor acceptor = parseArguments(args);
+            acceptor.start();
+            while (true) {
+                
+            }
+        } catch (IOException ioe) {
+            log.log(Level.SEVERE, &quot;Could not open port&quot;, ioe);
+        }
+    }
+
+    /**
+     * Prints messages about proper usage of the Snark application.
+     */
+    protected static void usage (String s)
+    {
+        PrintStream stream = System.out;
+        if (s != null) {
+            stream = System.err;
+            stream.println(&quot;snark: &quot; + s);
+        }
+        stream.println(
+            &quot;Usage: snark [--debug [level]] [--no-commands] [--port &lt;port&gt;] &lt;hash&gt; [&lt;hash&gt; ...]&quot;);
+        stream.println(&quot;  --debug\tShows some extra info and stacktraces&quot;);
+        stream.println(&quot;    level\tHow much debug details to show&quot;);
+        stream.println(&quot;         \t(defaults to &quot; + Level.SEVERE
+            + &quot;, with --debug to &quot; + Level.INFO + &quot;, highest level is &quot;
+            + Level.ALL + &quot;).&quot;);
+        stream.println(&quot;  --port\tThe port to listen on for incomming connections&quot;);
+        stream.println(&quot;        \t(if not given defaults to 6969)&quot;);
+        stream.println(&quot;  &lt;hash&gt;  \tAn infohash for a torrent file shared using the tracker.&quot;);
+        System.exit(-1);
+    }
+
+    /**
+     * Sets debug, ip and torrent variables then creates a Snark instance. Calls
+     * usage(), which terminates the program, if non-valid argument list. The
+     * given listeners will be passed to all components that take one.
+     */
+    public static ConnectionAcceptor parseArguments (String[] args)
+        throws IOException
+    {
+        int user_port = DEFAULT_PORT;
+        Level level = Level.INFO;
+        HashSet&lt;String&gt; hashes = new HashSet&lt;String&gt;();
+
+        int i = 0;
+        while (i &lt; args.length) {
+            if (args[i].equals(&quot;--debug&quot;)) {
+                level = Level.FINE;
+                i++;
+
+                // Try if there is an level argument.
+                if (i &lt; args.length) {
+                    try {
+                        level = Level.parse(args[i]);
+                    } catch (IllegalArgumentException iae) {
+                        // continue parsing arguments
+                    }
+                }
+            } else if (args[i].equals(&quot;--port&quot;)) {
+                if (args.length - 1 &lt; i + 1) {
+                    usage(&quot;--port needs port number to listen on&quot;);
+                }
+                try {
+                    user_port = Integer.parseInt(args[i + 1]);
+                } catch (NumberFormatException nfe) {
+                    usage(&quot;--port argument must be a number (&quot; + nfe + &quot;)&quot;);
+                }
+                i += 2;
+            } else if (args[i].equals(&quot;--help&quot;)) {
+                usage(null);
+            } else {
+                hashes.add(args[i]);
+                i++;
+                break;
+            }
+        }
+        log.setLevel(level);
+        Snark.setLogLevel(level);
+
+        if (hashes.isEmpty()) {
+            usage(&quot;Need at least one &lt;hash&gt;.&quot;);
+        }
+
+        Tracker tracker = new Tracker(hashes);
+        HttpAcceptor httpacceptor = new HttpAcceptor(tracker);
+        ConnectionAcceptor acceptor = new ConnectionAcceptor(
+            new ServerSocket(user_port), httpacceptor, null);
+        return acceptor;
+    }
+
+    protected static final String newline = System.getProperty(&quot;line.separator&quot;);
+
+    protected static final String copyright =
+        &quot;The Hunting of the Snark Project - &quot;
+        + &quot;Copyright (C) 2003 Mark J. Wielaard, (c) 2006 Three Rings Design&quot;
+        + newline
+        + newline
+        + &quot;Snark comes with ABSOLUTELY NO WARRANTY.  This is free software, and&quot;
+        + newline
+        + &quot;you are welcome to redistribute it under certain conditions; read the&quot;
+        + newline + &quot;COPYING file for details.&quot;;
+
+    /** The Java logger used to process our log events. */
+    protected static final Logger log = Logger.getLogger(&quot;org.klomp.snark.cmd&quot;);
+
+    protected static final int DEFAULT_PORT = 6969;
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000319.html">[Taspring-linux-commit] r5512 - trunk/Lobby/TASClient
</A></li>
	<LI>Next message: <A HREF="000321.html">[Taspring-linux-commit] r5514 -	trunk/Lobby/AFLobby/src/aflobby/contentdownloader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#320">[ date ]</a>
              <a href="thread.html#320">[ thread ]</a>
              <a href="subject.html#320">[ subject ]</a>
              <a href="author.html#320">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
