<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6486 - in trunk: AI/Global/KAI-0.2	AI/Global/KAIK-0.13 AI/Global/NTai/AI/NTai/Helpers	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Lua rts/Map	rts/Rendering/Env rts/Sim/Features rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Weapons
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6486%20-%20in%20trunk%3A%20AI/Global/KAI-0.2%0A%09AI/Global/KAIK-0.13%20AI/Global/NTai/AI/NTai/Helpers%0A%09installer/builddata/springcontent/LuaGadgets%0A%09installer/builddata/springcontent/gamedata%20rts/Lua%20rts/Map%0A%09rts/Rendering/Env%20rts/Sim/Features%20rts/Sim/Projectiles%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Weapons&In-Reply-To=%3C20080930103140.970764A61%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001255.html">
   <LINK REL="Next"  HREF="001257.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6486 - in trunk: AI/Global/KAI-0.2	AI/Global/KAIK-0.13 AI/Global/NTai/AI/NTai/Helpers	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Lua rts/Map	rts/Rendering/Env rts/Sim/Features rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Weapons</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6486%20-%20in%20trunk%3A%20AI/Global/KAI-0.2%0A%09AI/Global/KAIK-0.13%20AI/Global/NTai/AI/NTai/Helpers%0A%09installer/builddata/springcontent/LuaGadgets%0A%09installer/builddata/springcontent/gamedata%20rts/Lua%20rts/Map%0A%09rts/Rendering/Env%20rts/Sim/Features%20rts/Sim/Projectiles%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Weapons&In-Reply-To=%3C20080930103140.970764A61%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6486 - in trunk: AI/Global/KAI-0.2	AI/Global/KAIK-0.13 AI/Global/NTai/AI/NTai/Helpers	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Lua rts/Map	rts/Rendering/Env rts/Sim/Features rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Weapons">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Tue Sep 30 12:31:40 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001255.html">[Taspring-linux-commit] r6485 - trunk/installer/sections
</A></li>
        <LI>Next message: <A HREF="001257.html">[Taspring-linux-commit] r6487 - in trunk/rts: Map Rendering/Env
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1256">[ date ]</a>
              <a href="thread.html#1256">[ thread ]</a>
              <a href="subject.html#1256">[ subject ]</a>
              <a href="author.html#1256">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jk
Date: 2008-09-30 12:31:39 +0200 (Tue, 30 Sep 2008)
New Revision: 6486

Modified:
   trunk/AI/Global/KAI-0.2/DamageControl.cpp
   trunk/AI/Global/KAI-0.2/UnitTable.cpp
   trunk/AI/Global/KAIK-0.13/UnitTable.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/ubuild.cpp
   trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua
   trunk/installer/builddata/springcontent/gamedata/weapondefs_post.lua
   trunk/rts/Lua/LuaFeatureDefs.cpp
   trunk/rts/Lua/LuaRules.cpp
   trunk/rts/Lua/LuaWeaponDefs.cpp
   trunk/rts/Map/MapInfo.cpp
   trunk/rts/Map/MapInfo.h
   trunk/rts/Rendering/Env/AdvWater.cpp
   trunk/rts/Rendering/Env/BasicWater.cpp
   trunk/rts/Rendering/Env/BumpWater.cpp
   trunk/rts/Rendering/Env/DynWater.cpp
   trunk/rts/Rendering/Env/RefractWater.cpp
   trunk/rts/Sim/Features/FeatureDef.h
   trunk/rts/Sim/Features/FeatureHandler.cpp
   trunk/rts/Sim/Projectiles/FlareProjectile.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp
   trunk/rts/Sim/Weapons/WeaponDefHandler.cpp
   trunk/rts/Sim/Weapons/WeaponDefHandler.h
Log:
Map
 * added new mapInfo tag: alwaysRenderWater (bypass min. mapheight check. usefull for map surrounding water)
Lua
 * added cmdTag to AllowCommand &amp; CommandFallback (note the synced argument in AllowCommand was moved!)
Features
 * added smokeTime tag to featuredefs (default 300)
 * added resurrectable tag to featuredefs: -1 := only if it is the first sibling of the unit's deathfeatures (default), 0 := never, 1 := always
Weapons
 * added gravityAffected weapondef tag and marked the dropped tag as depreciated (it still work, but should be removed in 77b2 or later)
 * removed the ballistic weapondef tag, it did the same as the dropped tag. (lua does the backward compability again)
 * removed the following weapondef tags from the engine code and ai code (those were only used for OTA weapontype detection, which is lua's job now): twoPhase,guidance,vlaunch,selfprop
Rendering
 * fixed flares rendering

Modified: trunk/AI/Global/KAI-0.2/DamageControl.cpp
===================================================================
--- trunk/AI/Global/KAI-0.2/DamageControl.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/AI/Global/KAI-0.2/DamageControl.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -288,7 +288,7 @@
 					if(victim-&gt;speed &gt; 0){ // Better not use !=  as floats can have many forms of 0
 						accuracy *= 1-(unit-&gt;weapons[i].def-&gt;targetMoveError);
 					}					
-					float basedamage = unit-&gt;weapons[i].def-&gt;damages[armortype] * unit-&gt;weapons[i].def-&gt;salvosize / unit-&gt;weapons[i].def-&gt;reload;	
+					float basedamage = unit-&gt;weapons[i].def-&gt;damages[armortype] * unit-&gt;weapons[i].def-&gt;salvosize * unit-&gt;weapons[i].def-&gt;projectilespershot / unit-&gt;weapons[i].def-&gt;reload;	
 					float AOE = unit-&gt;weapons[i].def-&gt;areaOfEffect * 0.7;
 					float tohitprobability;
 					float impactarea;
@@ -335,14 +335,15 @@
 						tohitprobability = 1;
 					}
 					//L(&quot;Guidance: &quot; &lt;&lt; unit-&gt;weapons[i].def-&gt;guided &lt;&lt; &quot; Turning: &quot; &lt;&lt; unit-&gt;weapons[i].def-&gt;turnrate);
-					if((!unit-&gt;weapons[i].def-&gt;guided || unit-&gt;weapons[i].def-&gt;vlaunch) &amp;&amp; (unit-&gt;weapons[i].def-&gt;projectilespeed &gt; 0 || unit-&gt;weapons[i].def-&gt;dropped) &amp;&amp; victim-&gt;speed != 0 &amp;&amp; unit-&gt;weapons[i].def-&gt;beamtime == 1){
+				//FIXME turnrate can be set for weapons that don't support it (only StarburstLauncher and MissileLauncher support it)!
+					if((unit-&gt;weapons[i].def-&gt;turnrate == 0.0f  ||  unit-&gt;weapons[i].def-&gt;type == string(&quot;StarburstLauncher&quot;)) &amp;&amp; (unit-&gt;weapons[i].def-&gt;projectilespeed &gt; 0 || unit-&gt;weapons[i].def-&gt;dropped) &amp;&amp; victim-&gt;speed != 0 &amp;&amp; unit-&gt;weapons[i].def-&gt;beamtime == 1){
 						if(unit-&gt;weapons[i].def-&gt;type == string(&quot;Cannon&quot;)){
 							timetoarrive = (2*u*sin(firingangle))/gravity;
 						}
 						else{
 							if(!unit-&gt;weapons[i].def-&gt;dropped){
 								timetoarrive = distancetravelled / (unit-&gt;weapons[i].def-&gt;projectilespeed * 30);
-								if(unit-&gt;weapons[i].def-&gt;vlaunch){
+								if(unit-&gt;weapons[i].def-&gt;type == string(&quot;StarburstLauncher&quot;)){
 									timetoarrive += unit-&gt;weapons[i].def-&gt;uptime;
 								}
 							}

Modified: trunk/AI/Global/KAI-0.2/UnitTable.cpp
===================================================================
--- trunk/AI/Global/KAI-0.2/UnitTable.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/AI/Global/KAI-0.2/UnitTable.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -1078,7 +1078,7 @@
 					float weaponaoe=0;
 					for (std::vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i2=me-&gt;def-&gt;weapons.begin();i2!=me-&gt;def-&gt;weapons.end();i2++) {
 						if (weapondist&lt;i2-&gt;def-&gt;range) weapondist = i2-&gt;def-&gt;range;
-						if (i2-&gt;def-&gt;vlaunch) vlaunchweapon = true;
+						if (i2-&gt;def-&gt;type == string(&quot;StarburstLauncher&quot;)) vlaunchweapon = true;
 						if (weaponaoe&lt;i2-&gt;def-&gt;areaOfEffect) weapondist = i2-&gt;def-&gt;range;
 					}
 

Modified: trunk/AI/Global/KAIK-0.13/UnitTable.cpp
===================================================================
--- trunk/AI/Global/KAIK-0.13/UnitTable.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/AI/Global/KAIK-0.13/UnitTable.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -367,7 +367,7 @@
 						tohitprobability = 1;
 					}
 
-					if (!unit-&gt;weapons[i].def-&gt;guided &amp;&amp; unit-&gt;weapons[i].def-&gt;projectilespeed != 0 &amp;&amp; victim-&gt;speed != 0 &amp;&amp; unit-&gt;weapons[i].def-&gt;beamtime == 1) {
+					if (unit-&gt;weapons[i].def-&gt;turnrate == 0.0f &amp;&amp; unit-&gt;weapons[i].def-&gt;projectilespeed != 0 &amp;&amp; victim-&gt;speed != 0 &amp;&amp; unit-&gt;weapons[i].def-&gt;beamtime == 1) {
 						if (unit-&gt;weapons[i].def-&gt;type == string(&quot;Cannon&quot;)) {
 							timetoarrive = (2 * u * sin(firingangle)) / gravity;
 						} else {

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/ubuild.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/ubuild.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/ubuild.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -498,7 +498,7 @@
 
 				if(p-&gt;GetUnitDef()-&gt;metalCost+p-&gt;GetUnitDef()-&gt;energyCost &gt; (G-&gt;cb-&gt;GetEnergyStorage()+G-&gt;cb-&gt;GetMetalStorage())*atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;2.1&quot;, &quot;AI\\cheap_multiplier&quot;).c_str())) continue;
 				bool good = true;
-				if(p-&gt;GetUnitDef()-&gt;canfly ==false) good = false;
+				if(p-&gt;GetUnitDef()-&gt;canfly == false) good = false;
 				if(p-&gt;GetUnitDef()-&gt;weapons.empty() == true) good = false;
 				if(p-&gt;GetUnitDef()-&gt;builder == true) good = false;
 				if(p-&gt;GetUnitDef()-&gt;transportCapacity &gt; 0) good = false;
@@ -507,7 +507,7 @@
 					if(i-&gt;def-&gt;interceptor &gt; 0){
 						continue;
 					}
-					if(i-&gt;def-&gt;vlaunch == true){
+					if(i-&gt;def-&gt;type == string(&quot;StarburstLauncher&quot;)){
 						found = true;
 						break;
 					}

Modified: trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua
===================================================================
--- trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua	2008-09-30 10:31:39 UTC (rev 6486)
@@ -1,1628 +1,1628 @@
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  file:    gadgets.lua
---  brief:   the gadget manager, a call-in router
---  author:  Dave Rodgers
---
---  Copyright (C) 2007.
---  Licensed under the terms of the GNU GPL, v2 or later.
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  TODO:  - get rid of the ':'/self referencing, it's a waste of cycles
---         - (De)RegisterCOBCallback(data)
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local SAFEWRAP = 0
--- 0: disabled
--- 1: enabled, but can be overriden by gadget.GetInfo().unsafe
--- 2: always enabled
-
-
-local HANDLER_DIR = 'LuaGadgets/'
-local GADGETS_DIR = Script.GetName():gsub('US$', '') .. '/Gadgets/'
-
-
-local VFSMODE = VFS.ZIP_ONLY -- FIXME: ZIP_FIRST ?
-if (Spring.IsDevLuaEnabled()) then
-  VFSMODE = VFS.RAW_ONLY
-end
-
-
-VFS.Include(HANDLER_DIR .. 'setupdefs.lua', nil, VFSMODE)
-VFS.Include(HANDLER_DIR .. 'system.lua',    nil, VFSMODE)
-VFS.Include(HANDLER_DIR .. 'callins.lua',   nil, VFSMODE)
-
-local actionHandler = VFS.Include(HANDLER_DIR .. 'actions.lua', nil, VFSMODE)
-
-
---------------------------------------------------------------------------------
-
-function pgl() -- (print gadget list)  FIXME: move this into a gadget
-  for k,v in ipairs(gadgetHandler.gadgets) do
-    Spring.Echo(
-      string.format(&quot;%3i  %3i  %s&quot;, k, v.ghInfo.layer, v.ghInfo.name)
-    )
-  end
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  the gadgetHandler object
---
-
-gadgetHandler = {
-
-  gadgets = {},
-
-  orderList = {},
-
-  knownGadgets = {},
-  knownCount = 0,
-  knownChanged = true,
-  
-  GG = {}, -- shared table for gadgets
-
-  globals = {}, -- global vars/funcs
-
-  CMDIDs = {},
-
-  xViewSize    = 1,
-  yViewSize    = 1,
-  xViewSizeOld = 1,
-  yViewSizeOld = 1,
-
-  mouseOwner = nil,
-}
-
-
--- these call-ins are set to 'nil' if not used
--- they are setup in UpdateCallIns()
-local callInLists = {
-  'Shutdown',
-
-  'GamePreload',
-  'GameStart',
-  'GameOver',
-  'TeamDied',
-
-  'GameFrame',
-
-  'ViewResize',  -- FIXME ?
-
-  'TextCommand',  -- FIXME ?
-  'GotChatMsg',
-  'RecvLuaMsg',
-
-  -- Unit CallIns
-  'UnitCreated',
-  'UnitFinished',
-  'UnitFromFactory',
-  'UnitDestroyed',
-  'UnitExperience',
-  'UnitIdle',
-  'UnitCmdDone',
-  'UnitDamaged',
-  'UnitTaken',
-  'UnitGiven',
-  'UnitEnteredRadar',
-  'UnitEnteredLos',
-  'UnitLeftRadar',
-  'UnitLeftLos',
-  'UnitSeismicPing',
-  'UnitLoaded',
-  'UnitUnloaded',
-  'UnitCloaked',
-  'UnitDecloaked',
-  'StockpileChanged',
-
-  -- Feature CallIns
-  'FeatureCreated',
-  'FeatureDestroyed',
-
-  -- Projectile CallIns
-  'ProjectileCreated',
-  'ProjectileDestroyed',
-
-  -- Misc Synced CallIns
-  'Explosion',
-
-  -- LuaRules CallIns
-  'CommandFallback',
-  'AllowCommand',
-  'AllowUnitCreation',
-  'AllowUnitTransfer',
-  'AllowUnitBuildStep',
-  'AllowFeatureCreation',
-  'AllowResourceLevel',
-  'AllowResourceTransfer',
-  'AllowDirectUnitControl',
-  'MoveCtrlNotify',
-  'TerraformComplete',
-  -- unsynced
-  'DrawUnit',
-  'AICallIn',
-
-  -- COB CallIn  (FIXME?)
-  'CobCallback',
-
-  -- Unsynced CallIns
-  'Update',
-  'DefaultCommand',
-  'DrawGenesis',
-  'DrawWorld',
-  'DrawWorldPreUnit',
-  'DrawWorldShadow',
-  'DrawWorldReflection',
-  'DrawWorldRefraction',
-  'DrawScreenEffects',
-  'DrawScreen',
-  'DrawInMiniMap',
-  'RecvFromSynced',
-
-  -- moved from LuaUI
-  'KeyPress',
-  'KeyRelease',
-  'MousePress',
-  'MouseRelease',
-  'MouseMove',
-  'MouseWheel',
-  'IsAbove',
-  'GetTooltip',
-
-  -- FIXME -- not implemented  (more of these?)
-  'WorldTooltip',
-  'MapDrawCmd',
-  'GameSetup',
-  'DefaultCommand',
-}
-
-
--- initialize the call-in lists
-do
-  for _,listname in ipairs(callInLists) do
-    gadgetHandler[listname .. 'List'] = {}
-  end
-end
-
-
--- Utility call
-local isSyncedCode = (SendToUnsynced ~= nil)
-local function IsSyncedCode()
-  return isSyncedCode
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  Reverse integer iterator for drawing
---
-
-local function rev_iter(t, key)
-  if (key &lt;= 1) then
-    return nil
-  else
-    local nkey = key - 1
-    return nkey, t[nkey]
-  end
-end
-
-local function ripairs(t)
-  return rev_iter, t, (1 + #t)
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  returns:  basename, dirname
---
-
-local function Basename(fullpath)
-  local _,_,base = string.find(fullpath, &quot;([^\\/:]*)$&quot;)
-  local _,_,path = string.find(fullpath, &quot;(.*[\\/:])[^\\/:]*$&quot;)
-  if (path == nil) then path = &quot;&quot; end
-  return base, path
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-function gadgetHandler:Initialize()
-  local unsortedGadgets = {}
-
-  -- get the gadget names
-  local gadgetFiles = VFS.DirList(GADGETS_DIR, &quot;*.lua&quot;, VFSMODE)
---  table.sort(gadgetFiles)
-
-  for k,gf in ipairs(gadgetFiles) do
-    Spring.Echo('gf1 = ' .. gf) -- FIXME
-  end
-
-  -- stuff the gadgets into unsortedGadgets
-  for k,gf in ipairs(gadgetFiles) do
-    Spring.Echo('gf2 = ' .. gf) -- FIXME
-    local gadget = self:LoadGadget(gf)
-    if (gadget) then
-      table.insert(unsortedGadgets, gadget)
-    end
-  end
-
-  -- sort the gadgets  
-  table.sort(unsortedGadgets, function(g1, g2)
-    local l1 = g1.ghInfo.layer
-    local l2 = g2.ghInfo.layer
-    if (l1 ~= l2) then
-      return (l1 &lt; l2)
-    end
-    local n1 = g1.ghInfo.name
-    local n2 = g2.ghInfo.name
-    local o1 = self.orderList[n1]
-    local o2 = self.orderList[n2]
-    if (o1 ~= o2) then
-      return (o1 &lt; o2)
-    else
-      return (n1 &lt; n2)
-    end
-  end)
-
-  -- add the gadgets  
-  for _,g in ipairs(unsortedGadgets) do
-    gadgetHandler:InsertGadget(g)
-
-    local name = g.ghInfo.name
-    local basename = g.ghInfo.basename
-    Spring.Echo(string.format(&quot;Loaded gadget:  %-18s  &lt;%s&gt;&quot;, name, basename))
-  end
-end
-
-
-function gadgetHandler:LoadGadget(filename)
-  local basename = Basename(filename)
-  local text = VFS.LoadFile(filename, VFSMODE)
-  if (text == nil) then
-    Spring.Echo('1Failed to load: ' .. filename)
-    return nil
-  end
-  local chunk, err = loadstring(text, filename)
-  if (chunk == nil) then
-    Spring.Echo('Failed to load: ' .. basename .. '  (' .. err .. ')')
-    return nil
-  end
-  
-  local gadget = gadgetHandler:NewGadget()
-
-  setfenv(chunk, gadget)
-  local success, err = pcall(chunk)
-  if (not success) then
-    Spring.Echo('Failed to load: ' .. basename .. '  (' .. err .. ')')
-    return nil
-  end
-  if (err == false) then
-    return nil -- gadget asked for a quiet death
-  end
-
-  -- raw access to gadgetHandler
-  if (gadget.GetInfo and gadget:GetInfo().handler) then
-    gadget.gadgetHandler = self
-  end
-
-  self:FinalizeGadget(gadget, filename, basename)
-  local name = gadget.ghInfo.name
-
-  err = self:ValidateGadget(gadget)
-  if (err) then
-    Spring.Echo('Failed to load: ' .. basename .. '  (' .. err .. ')')
-    return nil
-  end
-
-  local knownInfo = self.knownGadgets[name]
-  if (knownInfo) then
-    if (knownInfo.active) then
-      Spring.Echo('Failed to load: ' .. basename .. '  (duplicate name)')
-      return nil
-    end
-  else
-    -- create a knownInfo table
-    knownInfo = {}
-    knownInfo.desc     = gadget.ghInfo.desc
-    knownInfo.author   = gadget.ghInfo.author
-    knownInfo.basename = gadget.ghInfo.basename
-    knownInfo.filename = gadget.ghInfo.filename
-    self.knownGadgets[name] = knownInfo
-    self.knownCount = self.knownCount + 1
-    self.knownChanged = true
-  end
-  knownInfo.active = true
-
-  local info  = gadget.GetInfo and gadget:GetInfo()
-  local order = self.orderList[name]
-  if (((order ~= nil) and (order &gt; 0)) or
-      ((order == nil) and ((info == nil) or info.enabled))) then
-    -- this will be an active gadget
-    if (order == nil) then
-      self.orderList[name] = 12345  -- back of the pack
-    else
-      self.orderList[name] = order
-    end
-  else
-    self.orderList[name] = 0
-    self.knownGadgets[name].active = false
-    return nil
-  end
-
-  return gadget
-end
-
-
-function gadgetHandler:NewGadget()
-  local gadget = {}
-  -- load the system calls into the gadget table
-  for k,v in pairs(System) do
-    gadget[k] = v
-  end
-  gadget._G = _G         -- the global table
-  gadget.GG = self.GG    -- the shared table
-  gadget.gadget = gadget -- easy self referencing
-
-  -- wrapped calls (closures)
-  gadget.gadgetHandler = {}
-  local gh = gadget.gadgetHandler
-  local self = self
-
-  gadget.include  = function (f)
-    return VFS.Include(f, gadget, VFSMODE)
-  end
-
-  gh.RaiseGadget  = function (_) self:RaiseGadget(gadget)      end
-  gh.LowerGadget  = function (_) self:LowerGadget(gadget)      end
-  gh.RemoveGadget = function (_) self:RemoveGadget(gadget)     end
-  gh.GetViewSizes = function (_) return self:GetViewSizes()    end
-  gh.GetHourTimer = function (_) return self:GetHourTimer()    end
-  gh.IsSyncedCode = function (_) return IsSyncedCode()         end
-
-  gh.UpdateCallIn = function (_, name)
-    self:UpdateGadgetCallIn(name, gadget)
-  end
-  gh.RemoveCallIn = function (_, name)
-    self:RemoveGadgetCallIn(name, gadget)
-  end
-
-  gh.RegisterCMDID = function(_, id)
-    self:RegisterCMDID(gadget, id)
-  end
-
-  gh.RegisterGlobal = function(_, name, value)
-    return self:RegisterGlobal(gadget, name, value)
-  end
-  gh.DeregisterGlobal = function(_, name)
-    return self:DeregisterGlobal(gadget, name)
-  end
-  gh.SetGlobal = function(_, name, value)
-    return self:SetGlobal(gadget, name, value)
-  end
-
-  gh.AddChatAction = function (_, cmd, func, help)
-    return actionHandler.AddChatAction(gadget, cmd, func, help)
-  end
-  gh.RemoveChatAction = function (_, cmd)
-    return actionHandler.RemoveChatAction(gadget, cmd)
-  end
-
-  if (not IsSyncedCode()) then
-    gh.AddSyncAction = function(_, cmd, func, help)
-      return actionHandler.AddSyncAction(gadget, cmd, func, help)
-    end
-    gh.RemoveSyncAction = function(_, cmd)
-      return actionHandler.RemoveSyncAction(gadget, cmd)
-    end
-  end
-
-  -- for proxied call-ins
-  gh.IsMouseOwner = function (_)
-    return (self.mouseOwner == gadget)
-  end
-  gh.DisownMouse  = function (_)
-    if (self.mouseOwner == gadget) then
-      self.mouseOwner = nil
-    end
-  end
-
-  return gadget
-end
-
-
-function gadgetHandler:FinalizeGadget(gadget, filename, basename)
-  local gi = {}
-
-  gi.filename = filename
-  gi.basename = basename
-  if (gadget.GetInfo == nil) then
-    gi.name  = basename
-    gi.layer = 0
-  else
-    local info = gadget:GetInfo()
-    gi.name      = info.name    or basename
-    gi.layer     = info.layer   or 0
-    gi.desc      = info.desc    or &quot;&quot;
-    gi.author    = info.author  or &quot;&quot;
-    gi.license   = info.license or &quot;&quot;
-    gi.enabled   = info.enabled or false
-  end
-
-  gadget.ghInfo = {}  --  a proxy table
-  local mt = {
-    __index = gi,
-    __newindex = function() error(&quot;ghInfo tables are read-only&quot;) end,
-    __metatable = &quot;protected&quot;
-  }
-  setmetatable(gadget.ghInfo, mt)
-end
-
-
-function gadgetHandler:ValidateGadget(gadget)
-  if (gadget.GetTooltip and not gadget.IsAbove) then
-    return &quot;Gadget has GetTooltip() but not IsAbove()&quot;
-  end
-  if (gadget.TweakGetTooltip and not gadget.TweakIsAbove) then
-    return &quot;Gadget has TweakGetTooltip() but not TweakIsAbove()&quot;
-  end
-  return nil
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local function SafeWrap(func, funcName)
-  local gh = gadgetHandler
-  return function(g, ...)
-    local r = { pcall(func, g, ...) }
-    if (r[1]) then
-      table.remove(r, 1)
-      return unpack(r)
-    else
-      if (funcName ~= 'Shutdown') then
-        gadgetHandler:RemoveGadget(g)
-      else
-        Spring.Echo('Error in Shutdown')
-      end
-      local name = g.ghInfo.name
-      Spring.Echo(r[2])
-      Spring.Echo('Removed gadget: ' .. name)
-      return nil
-    end
-  end
-end
-
-
-local function SafeWrapGadget(gadget)
-  if (SAFEWRAP &lt;= 0) then
-    return
-  elseif (SAFEWRAP == 1) then
-    if (gadget.GetInfo and gadget.GetInfo().unsafe) then
-      Spring.Echo('LuaUI: loaded unsafe gadget: ' .. gadget.ghInfo.name)
-      return
-    end
-  end
-
-  for _,ciName in ipairs(callInLists) do
-    if (gadget[ciName]) then
-      gadget[ciName] = SafeWrap(gadget[ciName], ciName)
-    end
-    if (gadget.Initialize) then
-      gadget.Initialize = SafeWrap(gadget.Initialize, 'Initialize')
-    end
-  end
-end
-
-
---------------------------------------------------------------------------------
-
-local function ArrayInsert(t, f, g)
-  if (f) then
-    local layer = g.ghInfo.layer
-    local index = 1
-    for i,v in ipairs(t) do
-      if (v == g) then
-        return -- already in the table
-      end
-      if (layer &gt;= v.ghInfo.layer) then
-        index = i + 1
-      end
-    end
-    table.insert(t, index, g)
-  end
-end
-
-
-local function ArrayRemove(t, g)
-  for k,v in ipairs(t) do
-    if (v == g) then
-      table.remove(t, k)
-      -- break
-    end
-  end
-end
-
-
-function gadgetHandler:InsertGadget(gadget)
-  if (gadget == nil) then
-    return
-  end
-
-  ArrayInsert(self.gadgets, true, gadget)
-  for _,listname in ipairs(callInLists) do
-    local func = gadget[listname]
-    if (type(func) == 'function') then
-      ArrayInsert(self[listname..'List'], func, gadget)
-    end
-  end
-
-  self:UpdateCallIns()
-  if (gadget.Initialize) then
-    gadget:Initialize()
-  end
-  self:UpdateCallIns()
-end
-
-
-function gadgetHandler:RemoveGadget(gadget)
-  if (gadget == nil) then
-    return
-  end
-
-  local name = gadget.ghInfo.name
-  self.knownGadgets[name].active = false
-  if (gadget.Shutdown) then
-    gadget:Shutdown()
-  end
-
-  ArrayRemove(self.gadgets, gadget)
-  self:RemoveGadgetGlobals(gadget)
-  actionHandler.RemoveGadgetActions(gadget)
-  for _,listname in ipairs(callInLists) do
-    ArrayRemove(self[listname..'List'], gadget)
-  end
-
-  for id,g in pairs(self.CMDIDs) do
-    if (g == gadget) then
-      self.CMDIDs[id] = nil
-    end
-  end
-
-  self:UpdateCallIns()
-end
-
-
---------------------------------------------------------------------------------
-
-function gadgetHandler:UpdateCallIn(name)
-  local listName = name .. 'List'
-  if ((#self[listName] &gt; 0)       or
-      (name == 'GotChatMsg')      or
-      (name == 'RecvFromSynced')) then
-    local selffunc = self[name]
-    _G[name] = function(...)
-      return selffunc(self, ...)
-    end
-  else
-    _G[name] = nil
-  end
-  Script.UpdateCallIn(name)
-end
-
-
-function gadgetHandler:UpdateGadgetCallIn(name, g)
-  local listName = name .. 'List'
-  local ciList = self[listName]
-  if (ciList) then
-    local func = g[name]
-    if (type(func) == 'function') then
-      ArrayInsert(ciList, func, g)
-    else
-      ArrayRemove(ciList, g)
-    end
-    self:UpdateCallIn(name)
-  else
-    Spring.Echo('UpdateGadgetCallIn: bad name: ' .. name)
-  end
-end
-
-
-function gadgetHandler:RemoveGadgetCallIn(name, g)
-  local listName = name .. 'List'
-  local ciList = self[listName]
-  if (ciList) then
-    ArrayRemove(ciList, g)
-    self:UpdateCallIn(name)
-  else
-    Spring.Echo('RemoveGadgetCallIn: bad name: ' .. name)
-  end
-end
-
-
-function gadgetHandler:UpdateCallIns()
-  for _,name in ipairs(callInLists) do
-    self:UpdateCallIn(name)
-  end
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-function gadgetHandler:EnableGadget(name)
-  local ki = self.knownGadgets[name]
-  if (not ki) then
-    Spring.Echo(&quot;EnableGadget(), could not find gadget: &quot; .. tostring(name))
-    return false
-  end
-  if (not ki.active) then
-    Spring.Echo('Loading:  '..ki.filename)
-    local order = gadgetHandler.orderList[name]
-    if (not order or (order &lt;= 0)) then
-      self.orderList[name] = 1
-    end
-    local w = self:LoadGadget(ki.filename)
-    if (not w) then return false end
-    self:InsertGadget(w)
-  end
-  return true
-end
-
-
-function gadgetHandler:DisableGadget(name)
-  local ki = self.knownGadgets[name]
-  if (not ki) then
-    Spring.Echo(&quot;DisableGadget(), could not find gadget: &quot; .. tostring(name))
-    return false
-  end
-  if (ki.active) then
-    local w = self:FindGadget(name)
-    if (not w) then return false end
-    Spring.Echo('Removed:  '..ki.filename)
-    self:RemoveGadget(w)     -- deactivate
-    self.orderList[name] = 0 -- disable
-  end
-  return true
-end
-
-
-function gadgetHandler:ToggleGadget(name)
-  local ki = self.knownGadgets[name]
-  if (not ki) then
-    Spring.Echo(&quot;ToggleGadget(), could not find gadget: &quot; .. tostring(name))
-    return
-  end
-  if (ki.active) then
-    return self:DisableGadget(name)
-  elseif (self.orderList[name] &lt;= 0) then
-    return self:EnableGadget(name)
-  else
-    -- the gadget is not active, but enabled; disable it
-    self.orderList[name] = 0
-  end
-  return true
-end
-
-
---------------------------------------------------------------------------------
-
-local function FindGadgetIndex(t, w)
-  for k,v in ipairs(t) do
-    if (v == w) then
-      return k
-    end
-  end
-  return nil
-end
-
-
-local function FindLowestIndex(t, i, layer)
-  for x = (i - 1), 1, -1 do
-    if (t[x].ghInfo.layer &lt; layer) then
-      return x + 1
-    end
-  end
-  return 1
-end
-
-
-function gadgetHandler:RaiseGadget(gadget)
-  if (gadget == nil) then
-    return
-  end
-  local function Raise(t, f, w)
-    if (f == nil) then return end
-    local i = FindGadgetIndex(t, w)
-    if (i == nil) then return end
-    local n = FindLowestIndex(t, i, w.ghInfo.layer)
-    if (n and (n &lt; i)) then
-      table.remove(t, i)
-      table.insert(t, n, w)
-    end
-  end
-  Raise(self.gadgets, true, gadget)
-  for _,listname in ipairs(callInLists) do
-    Raise(self[listname..'List'], gadget[listname], gadget)
-  end
-end
-
-
-local function FindHighestIndex(t, i, layer)
-  local ts = #t
-  for x = (i + 1),ts do
-    if (t[x].ghInfo.layer &gt; layer) then
-      return (x - 1)
-    end
-  end
-  return (ts + 1)
-end
-
-
-function gadgetHandler:LowerGadget(gadget)
-  if (gadget == nil) then
-    return
-  end
-  local function Lower(t, f, w)
-    if (f == nil) then return end
-    local i = FindGadgetIndex(t, w)
-    if (i == nil) then return end
-    local n = FindHighestIndex(t, i, w.ghInfo.layer)
-    if (n and (n &gt; i)) then
-      table.insert(t, n, w)
-      table.remove(t, i)
-    end
-  end
-  Lower(self.gadgets, true, gadget)
-  for _,listname in ipairs(callInLists) do
-    Lower(self[listname..'List'], gadget[listname], gadget)
-  end
-end
-
-
-function gadgetHandler:FindGadget(name)
-  if (type(name) ~= 'string') then
-    return nil
-  end
-  for k,v in ipairs(self.gadgets) do
-    if (name == v.ghInfo.name) then
-      return v,k
-    end
-  end
-  return nil
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  Global var/func management
---
-
-function gadgetHandler:RegisterGlobal(owner, name, value)
-  if ((name == nil)        or
-      (_G[name])           or
-      (self.globals[name]) or
-      (CallInsMap[name])) then
-    return false
-  end
-  _G[name] = value
-  self.globals[name] = owner
-  return true
-end
-
-
-function gadgetHandler:DeregisterGlobal(owner, name)
-  if (name == nil) then
-    return false
-  end
-  _G[name] = nil
-  self.globals[name] = nil
-  return true
-end
-
-
-function gadgetHandler:SetGlobal(owner, name, value)
-  if ((name == nil) or (self.globals[name] ~= owner)) then
-    return false
-  end
-  _G[name] = value
-  return true
-end
-
-
-function gadgetHandler:RemoveGadgetGlobals(owner)
-  local count = 0
-  for name, o in pairs(self.globals) do
-    if (o == owner) then
-      _G[name] = nil
-      self.globals[name] = nil
-      count = count + 1
-    end
-  end
-  return count
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  Helper facilities
---
-
-local hourTimer = 0
-
-
-function gadgetHandler:GetHourTimer()
-  return hourTimer
-end
-
-
-function gadgetHandler:GetViewSizes()
-  return self.xViewSize, self.yViewSize
-end
-
-
-function gadgetHandler:RegisterCMDID(gadget, id)
-  if (id &lt; 30000) then
-    Spring.Echo('Gadget (' .. gadget.ghInfo.name .. ') ' ..
-                'tried to register a CMD_ID &lt; 30000')
-    Script.Kill('Bad CMD_ID code: ' .. id)
-  end
-  if (id &gt;= 40000) then
-    Spring.Echo('Gadget (' .. gadget.ghInfo.name .. ') ' ..
-                'tried to register a CMD_ID &gt;= 40000')
-    Script.Kill('Bad CMD_ID code: ' .. id)
-  end
-  if (self.CMDIDs[id] ~= nil) then
-    Spring.Echo('Gadget (' .. gadget.ghInfo.name .. ') ' ..
-                'tried to register a CMD_ID &gt;= 40000')
-    Script.Kill('Duplicate CMD_ID code: ' .. id)
-  end
-  self.CMDIDs[id] = gadget
-end
-
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  The call-in distribution routines
---
-
-function gadgetHandler:GamePreload()
-  for _,g in ipairs(self.GamePreloadList) do
-    g:GamePreload()
-  end
-  return
-end
-
-function gadgetHandler:GameStart()
-  for _,g in ipairs(self.GameStartList) do
-    g:GameStart()
-  end
-  return
-end
-
-function gadgetHandler:Shutdown()
-  for _,g in ipairs(self.ShutdownList) do
-    g:Shutdown()
-  end
-  return
-end
-
-function gadgetHandler:GameFrame(frameNum)
-  for _,g in ipairs(self.GameFrameList) do
-    g:GameFrame(frameNum)
-  end
-  return
-end
-
-
-function gadgetHandler:RecvFromSynced(...)
-  if (actionHandler.RecvFromSynced(...)) then
-    return
-  end
-  for _,g in ipairs(self.RecvFromSyncedList) do
-    if (g:RecvFromSynced(...)) then
-      return
-    end
-  end
-  return
-end
-
-
-function gadgetHandler:GotChatMsg(msg, player)
-  if ((player == 0) and Spring.IsCheatingEnabled()) then
-    local sp = '^%s*'    -- start pattern
-    local ep = '%s+(.*)' -- end pattern
-    local s, e, match
-    s, e, match = string.find(msg, sp..'togglegadget'..ep)
-    if (match) then
-      self:ToggleGadget(match)
-      return true
-    end
-    s, e, match = string.find(msg, sp..'enablegadget'..ep)
-    if (match) then
-      self:EnableGadget(match)
-      return true
-    end
-    s, e, match = string.find(msg, sp..'disablegadget'..ep)
-    if (match) then
-      self:DisableGadget(match)
-      return true
-    end
-  end
-
-  if (actionHandler.GotChatMsg(msg, player)) then
-    return true
-  end
-
-  for _,g in ipairs(self.GotChatMsgList) do
-    if (g:GotChatMsg(msg, player)) then
-      return true
-    end
-  end
-
-  if (IsSyncedCode()) then
-    SendToUnsynced(player, msg)
-  end
-
-  return false
-end
-
-
-function gadgetHandler:RecvLuaMsg(msg, player)
-  for _,g in ipairs(self.RecvLuaMsgList) do
-    if (g:RecvLuaMsg(msg, player)) then
-      return true
-    end
-  end
-  return false
-end
-
-
---------------------------------------------------------------------------------
---
---  Drawing call-ins
---
-
--- generates ViewResize() calls for the gadgets
-function gadgetHandler:SetViewSize(vsx, vsy)
-  self.xViewSize = vsx
-  self.yViewSize = vsy
-  if ((self.xViewSizeOld ~= vsx) or
-      (self.yViewSizeOld ~= vsy)) then
-    gadgetHandler:ViewResize(vsx, vsy)
-    self.xViewSizeOld = vsx
-    self.yViewSizeOld = vsy
-  end
-end
-
-
-function gadgetHandler:ViewResize(vsx, vsy)
-  for _,g in ipairs(self.ViewResizeList) do
-    g:ViewResize(vsx, vsy)
-  end
-  return
-end
-
-
---------------------------------------------------------------------------------
---
---  Game call-ins
---
-
-function gadgetHandler:GameOver()
-  for _,g in ipairs(self.GameOverList) do
-    g:GameOver()
-  end
-  return
-end
-
-
-function gadgetHandler:TeamDied(teamID)
-  for _,g in ipairs(self.TeamDiedList) do
-    g:TeamDied(teamID)
-  end
-  return
-end
-
-
---------------------------------------------------------------------------------
---
---  LuaRules Game call-ins
---
-
-function gadgetHandler:DrawUnit(unitID, drawMode)
-  for _,g in ipairs(self.DrawUnitList) do
-    if (g:DrawUnit(unitID, drawMode)) then
-      return true
-    end
-  end
-  return false
-end
-
-
-function gadgetHandler:AICallIn(dataStr)
-  for _,g in ipairs(self.AICallInList) do
-    local dataRet = g:AICallIn(dataStr)
-    if (dataRet) then
-      return dataRet
-    end
-  end
-end
-
-
-function gadgetHandler:CommandFallback(unitID, unitDefID, unitTeam,
-                                       cmdID, cmdParams, cmdOptions)
-  for _,g in ipairs(self.CommandFallbackList) do
-    local used, remove = g:CommandFallback(unitID, unitDefID, unitTeam,
-                                           cmdID, cmdParams, cmdOptions)
-    if (used) then
-      return remove
-    end
-  end
-  return true  -- remove the command
-end
-
-
-function gadgetHandler:AllowCommand(unitID, unitDefID, unitTeam,
-                                    cmdID, cmdParams, cmdOptions, synced)
-  for _,g in ipairs(self.AllowCommandList) do
-    if (not g:AllowCommand(unitID, unitDefID, unitTeam,
-                           cmdID, cmdParams, cmdOptions, synced)) then
-      return false
-    end
-  end
-  return true
-end
-
-
-function gadgetHandler:AllowUnitCreation(unitDefID, builderID,
-                                         builderTeam, x, y, z)
-  for _,g in ipairs(self.AllowUnitCreationList) do
-    if (not g:AllowUnitCreation(unitDefID, builderID,
-                                builderTeam, x, y, z)) then
-      return false
-    end
-  end
-  return true
-end
-
-
-function gadgetHandler:AllowUnitTransfer(unitID, unitDefID,
-                                         oldTeam, newTeam, capture)
-  for _,g in ipairs(self.AllowUnitTransferList) do
-    if (not g:AllowUnitTransfer(unitID, unitDefID,
-                                oldTeam, newTeam, capture)) then
-      return false
-    end
-  end
-  return true
-end
-
-
-function gadgetHandler:AllowUnitBuildStep(builderID, builderTeam,
-                                          unitID, unitDefID, part)
-  for _,g in ipairs(self.AllowUnitBuildStepList) do
-    if (not g:AllowUnitBuildStep(builderID, builderTeam,
-                                 unitID, unitDefID, part)) then
-      return false
-    end
-  end
-  return true
-end
-
-
-function gadgetHandler:AllowFeatureCreation(featureDefID, teamID, x, y, z)
-  for _,g in ipairs(self.AllowFeatureCreationList) do
-    if (not g:AllowFeatureCreation(featureDefID, teamID, x, y, z)) then
-      return false
-    end
-  end
-  return true
-end
-
-
-function gadgetHandler:AllowResourceLevel(teamID, res, level)
-  for _,g in ipairs(self.AllowResourceLevelList) do
-    if (not g:AllowResourceLevel(teamID, res, level)) then
-      return false
-    end
-  end
-  return true
-end
-
-
-function gadgetHandler:AllowResourceTransfer(teamID, res, level)
-  for _,g in ipairs(self.AllowResourceTransferList) do
-    if (not g:AllowResourceTransfer(teamID, res, level)) then
-      return false
-    end
-  end
-  return true
-end
-
-
-function gadgetHandler:AllowDirectUnitControl(unitID, unitDefID, unitTeam,
-                                              playerID)
-  for _,g in ipairs(self.AllowDirectUnitControlList) do
-    if (not g:AllowDirectUnitControl(unitID, unitDefID, unitTeam,
-                                     playerID)) then
-      return false
-    end
-  end
-  return true
-end
-
-
-function gadgetHandler:MoveCtrlNotify(unitID, unitDefID, unitTeam, data)
-  local state = false
-  for _,g in ipairs(self.MoveCtrlNotifyList) do
-    if (g:MoveCtrlNotify(unitID, unitDefID, unitTeam, data)) then
-      state = true
-    end
-  end
-  return state
-end
-
-
-function gadgetHandler:TerraformComplete(unitID, unitDefID, unitTeam,
-                                       buildUnitID, buildUnitDefID, buildUnitTeam)
-  for _,g in ipairs(self.TerraformCompleteList) do
-    local stop = g:TerraformComplete(unitID, unitDefID, unitTeam,
-                                       buildUnitID, buildUnitDefID, buildUnitTeam)
-    if (stop) then
-      return true
-    end
-  end
-  return false
-end
-
-
---------------------------------------------------------------------------------
---
---  Unit call-ins
---
-
-function gadgetHandler:UnitCreated(unitID, unitDefID, unitTeam, builderID)
-  for _,g in ipairs(self.UnitCreatedList) do
-    g:UnitCreated(unitID, unitDefID, unitTeam, builderID)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitFinished(unitID, unitDefID, unitTeam)
-  for _,g in ipairs(self.UnitFinishedList) do
-    g:UnitFinished(unitID, unitDefID, unitTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitFromFactory(unitID, unitDefID, unitTeam,
-                                       factID, factDefID, userOrders)
-  for _,g in ipairs(self.UnitFromFactoryList) do
-    g:UnitFromFactory(unitID, unitDefID, unitTeam,
-                      factID, factDefID, userOrders)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitDestroyed(unitID,     unitDefID,     unitTeam,
-                                     attackerID, attackerDefID, attackerTeam)
-  for _,g in ipairs(self.UnitDestroyedList) do
-    g:UnitDestroyed(unitID,     unitDefID,     unitTeam,
-                    attackerID, attackerDefID, attackerTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitExperience(unitID, unitDefID, unitTeam,
-                                      experience, oldExperience)
-  for _,g in ipairs(self.UnitExperienceList) do
-    g:UnitExperience(unitID, unitDefID, unitTeam, experience, oldExperience)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitIdle(unitID, unitDefID, unitTeam)
-  for _,g in ipairs(self.UnitIdleList) do
-    g:UnitIdle(unitID, unitDefID, unitTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitCmdDone(unitID, unitDefID, unitTeam, cmdID, cmdTag)
-  for _,g in ipairs(self.UnitCmdDoneList) do
-    g:UnitCmdDone(unitID, unitDefID, unitTeam, cmdID, cmdTag)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitDamaged(unitID, unitDefID, unitTeam,
-                                   damage, paralyzer, weaponID,
-                                   attackerID, attackerDefID, attackerTeam)
-  for _,g in ipairs(self.UnitDamagedList) do
-    g:UnitDamaged(unitID, unitDefID, unitTeam,
-                  damage, paralyzer, weaponID,
-                  attackerID, attackerDefID, attackerTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitTaken(unitID, unitDefID, unitTeam, newTeam)
-  for _,g in ipairs(self.UnitTakenList) do
-    g:UnitTaken(unitID, unitDefID, unitTeam, newTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitGiven(unitID, unitDefID, unitTeam, oldTeam)
-  for _,g in ipairs(self.UnitGivenList) do
-    g:UnitGiven(unitID, unitDefID, unitTeam, oldTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitEnteredRadar(unitID, unitTeam, allyTeam, unitDefID)
-  for _,g in ipairs(self.UnitEnteredRadarList) do
-    g:UnitEnteredRadar(unitID, unitTeam, allyTeam, unitDefID)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitEnteredLos(unitID, unitTeam, allyTeam, unitDefID)
-  for _,g in ipairs(self.UnitEnteredLosList) do
-    g:UnitEnteredLos(unitID, unitTeam, allyTeam, unitDefID)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitLeftRadar(unitID, unitTeam, allyTeam, unitDefID)
-  for _,g in ipairs(self.UnitLeftRadarList) do
-    g:UnitLeftRadar(unitID, unitTeam, allyTeam, unitDefID)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitLeftLos(unitID, unitTeam, allyTeam, unitDefID)
-  for _,g in ipairs(self.UnitLeftLosList) do
-    g:UnitLeftLos(unitID, unitTeam, allyTeam, unitDefID)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitSeismicPing(x, y, z, strength,
-                                       allyTeam, unitID, unitDefID)
-  for _,g in ipairs(self.UnitSeismicPingList) do
-    g:UnitSeismicPing(x, y, z, strength,
-                      allyTeam, unitID, unitDefID)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitLoaded(unitID, unitDefID, unitTeam,
-                                  transportID, transportTeam)
-  for _,g in ipairs(self.UnitLoadedList) do
-    g:UnitLoaded(unitID, unitDefID, unitTeam,
-                 transportID, transportTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitUnloaded(unitID, unitDefID, unitTeam,
-                                    transportID, transportTeam)
-  for _,g in ipairs(self.UnitUnloadedList) do
-    g:UnitUnloaded(unitID, unitDefID, unitTeam,
-                   transportID, transportTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitCloaked(unitID, unitDefID, unitTeam)
-  for _,g in ipairs(self.UnitCloakedList) do
-    g:UnitCloaked(unitID, unitDefID, unitTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:UnitDecloaked(unitID, unitDefID, unitTeam)
-  for _,g in ipairs(self.UnitDecloakedList) do
-    g:UnitDecloaked(unitID, unitDefID, unitTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:StockpileChanged(unitID, unitDefID, unitTeam,
-                                        weaponNum, oldCount, newCount)
-  for _,g in ipairs(self.StockpileChangedList) do
-    g:StockpileChanged(unitID, unitDefID, unitTeam,
-                       weaponNum, oldCount, newCount)
-  end
-  return
-end
-
-
---------------------------------------------------------------------------------
---
---  Feature call-ins
---
-
-function gadgetHandler:FeatureCreated(featureID, allyTeam)
-  for _,g in ipairs(self.FeatureCreatedList) do
-    g:FeatureCreated(featureID, allyTeam)
-  end
-  return
-end
-
-
-function gadgetHandler:FeatureDestroyed(featureID, allyTeam)
-  for _,g in ipairs(self.FeatureDestroyedList) do
-    g:FeatureDestroyed(featureID, allyTeam)
-  end
-  return
-end
-
-
---------------------------------------------------------------------------------
---
---  Projectile call-ins
---
-
-function gadgetHandler:ProjectileCreated(proID, proOwnerID)
-  for _,g in ipairs(self.ProjectileCreatedList) do
-    g:ProjectileCreated(proID, proOwnerID)
-  end
-  return
-end
-
-
-function gadgetHandler:ProjectileDestroyed(proID)
-  for _,g in ipairs(self.ProjectileDestroyedList) do
-    g:ProjectileDestroyed(proID)
-  end
-  return
-end
-
-
---------------------------------------------------------------------------------
---
---  Misc call-ins
---
-
-function gadgetHandler:Explosion(weaponID, px, py, pz, ownerID)
-  local noGfx = false
-  for _,g in ipairs(self.ExplosionList) do
-    noGfx = noGfx or g:Explosion(weaponID, px, py, pz, ownerID)
-  end
-  return noGfx
-end
-
-
---------------------------------------------------------------------------------
---
---  Draw call-ins
---
-
-function gadgetHandler:Update()
-  for _,g in ipairs(self.UpdateList) do
-    g:Update()
-  end
-  return
-end
-
-
-function gadgetHandler:DefaultCommand(type, id)
-  for _,g in ipairs(self.DefaultCommandList) do
-    local id = g:DefaultCommand(type, id)
-    if (id) then
-      return id
-    end
-  end
-  return
-end
-
-
-function gadgetHandler:DrawGenesis()
-  for _,g in ipairs(self.DrawGenesisList) do
-    g:DrawGenesis()
-  end
-  return
-end
-
-
-function gadgetHandler:DrawWorld()
-  for _,g in ipairs(self.DrawWorldList) do
-    g:DrawWorld()
-  end
-  return
-end
-
-
-function gadgetHandler:DrawWorldPreUnit()
-  for _,g in ipairs(self.DrawWorldPreUnitList) do
-    g:DrawWorldPreUnit()
-  end
-  return
-end
-
-
-function gadgetHandler:DrawWorldShadow()
-  for _,g in ipairs(self.DrawWorldShadowList) do
-    g:DrawWorldShadow()
-  end
-  return
-end
-
-
-function gadgetHandler:DrawWorldReflection()
-  for _,g in ipairs(self.DrawWorldReflectionList) do
-    g:DrawWorldReflection()
-  end
-  return
-end
-
-
-function gadgetHandler:DrawWorldRefraction()
-  for _,g in ipairs(self.DrawWorldRefractionList) do
-    g:DrawWorldRefraction()
-  end
-  return
-end
-
-
-function gadgetHandler:DrawScreenEffects(vsx, vsy)
-  for _,g in ipairs(self.DrawScreenEffectsList) do
-    g:DrawScreenEffects(vsx, vsy)
-  end
-  return
-end
-
-
-function gadgetHandler:DrawScreen(vsx, vsy)
-  for _,g in ipairs(self.DrawScreenList) do
-    g:DrawScreen(vsx, vsy)
-  end
-  return
-end
-
-
-function gadgetHandler:DrawInMiniMap(mmsx, mmsy)
-  for _,g in ipairs(self.DrawInMiniMapList) do
-    g:DrawInMiniMap(mmsx, mmsy)
-  end
-  return
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-function gadgetHandler:KeyPress(key, mods, isRepeat, label, unicode)
-  for _,g in ipairs(self.KeyPressList) do
-    if (g:KeyPress(key, mods, isRepeat, label, unicode)) then
-      return true
-    end
-  end
-  return false
-end
-
-
-function gadgetHandler:KeyRelease(key, mods, label, unicode)
-  for _,g in ipairs(self.KeyReleaseList) do
-    if (g:KeyRelease(key, mods, label, unicode)) then
-      return true
-    end
-  end
-  return false
-end
-
-
-function gadgetHandler:MousePress(x, y, button)
-  local mo = self.mouseOwner
-  if (mo) then
-    mo:MousePress(x, y, button)
-    return true  --  already have an active press
-  end
-  for _,g in ipairs(self.MousePressList) do
-    if (g:MousePress(x, y, button)) then
-      self.mouseOwner = g
-      return true
-    end
-  end
-  return false
-end
-
-
-function gadgetHandler:MouseMove(x, y, dx, dy, button)
-  local mo = self.mouseOwner
-  if (mo and mo.MouseMove) then
-    return mo:MouseMove(x, y, dx, dy, button)
-  end
-end
-
-
-function gadgetHandler:MouseRelease(x, y, button)
-  local mo = self.mouseOwner
-  local mx, my, lmb, mmb, rmb = Spring.GetMouseState()
-  if (not (lmb or mmb or rmb)) then
-    self.mouseOwner = nil
-  end
-  if (mo and mo.MouseRelease) then
-    return mo:MouseRelease(x, y, button)
-  end
-  return -1
-end
-
-
-function gadgetHandler:MouseWheel(up, value)
-  for _,g in ipairs(self.MouseWheelList) do
-    if (g:MouseWheel(up, value)) then
-      return true
-    end
-  end
-  return false
-end
-
-
-function gadgetHandler:IsAbove(x, y)
-  for _,g in ipairs(self.IsAboveList) do
-    if (g:IsAbove(x, y)) then
-      return true
-    end
-  end
-  return false
-end
-
-
-function gadgetHandler:GetTooltip(x, y)
-  for _,g in ipairs(self.GetTooltipList) do
-    if (g:IsAbove(x, y)) then
-      local tip = g:GetTooltip(x, y)
-      if (string.len(tip) &gt; 0) then
-        return tip
-      end
-    end
-  end
-  return ''
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-gadgetHandler:Initialize()
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  file:    gadgets.lua
+--  brief:   the gadget manager, a call-in router
+--  author:  Dave Rodgers
+--
+--  Copyright (C) 2007.
+--  Licensed under the terms of the GNU GPL, v2 or later.
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  TODO:  - get rid of the ':'/self referencing, it's a waste of cycles
+--         - (De)RegisterCOBCallback(data)
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local SAFEWRAP = 0
+-- 0: disabled
+-- 1: enabled, but can be overriden by gadget.GetInfo().unsafe
+-- 2: always enabled
+
+
+local HANDLER_DIR = 'LuaGadgets/'
+local GADGETS_DIR = Script.GetName():gsub('US$', '') .. '/Gadgets/'
+
+
+local VFSMODE = VFS.ZIP_ONLY -- FIXME: ZIP_FIRST ?
+if (Spring.IsDevLuaEnabled()) then
+  VFSMODE = VFS.RAW_ONLY
+end
+
+
+VFS.Include(HANDLER_DIR .. 'setupdefs.lua', nil, VFSMODE)
+VFS.Include(HANDLER_DIR .. 'system.lua',    nil, VFSMODE)
+VFS.Include(HANDLER_DIR .. 'callins.lua',   nil, VFSMODE)
+
+local actionHandler = VFS.Include(HANDLER_DIR .. 'actions.lua', nil, VFSMODE)
+
+
+--------------------------------------------------------------------------------
+
+function pgl() -- (print gadget list)  FIXME: move this into a gadget
+  for k,v in ipairs(gadgetHandler.gadgets) do
+    Spring.Echo(
+      string.format(&quot;%3i  %3i  %s&quot;, k, v.ghInfo.layer, v.ghInfo.name)
+    )
+  end
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  the gadgetHandler object
+--
+
+gadgetHandler = {
+
+  gadgets = {},
+
+  orderList = {},
+
+  knownGadgets = {},
+  knownCount = 0,
+  knownChanged = true,
+  
+  GG = {}, -- shared table for gadgets
+
+  globals = {}, -- global vars/funcs
+
+  CMDIDs = {},
+
+  xViewSize    = 1,
+  yViewSize    = 1,
+  xViewSizeOld = 1,
+  yViewSizeOld = 1,
+
+  mouseOwner = nil,
+}
+
+
+-- these call-ins are set to 'nil' if not used
+-- they are setup in UpdateCallIns()
+local callInLists = {
+  'Shutdown',
+
+  'GamePreload',
+  'GameStart',
+  'GameOver',
+  'TeamDied',
+
+  'GameFrame',
+
+  'ViewResize',  -- FIXME ?
+
+  'TextCommand',  -- FIXME ?
+  'GotChatMsg',
+  'RecvLuaMsg',
+
+  -- Unit CallIns
+  'UnitCreated',
+  'UnitFinished',
+  'UnitFromFactory',
+  'UnitDestroyed',
+  'UnitExperience',
+  'UnitIdle',
+  'UnitCmdDone',
+  'UnitDamaged',
+  'UnitTaken',
+  'UnitGiven',
+  'UnitEnteredRadar',
+  'UnitEnteredLos',
+  'UnitLeftRadar',
+  'UnitLeftLos',
+  'UnitSeismicPing',
+  'UnitLoaded',
+  'UnitUnloaded',
+  'UnitCloaked',
+  'UnitDecloaked',
+  'StockpileChanged',
+
+  -- Feature CallIns
+  'FeatureCreated',
+  'FeatureDestroyed',
+
+  -- Projectile CallIns
+  'ProjectileCreated',
+  'ProjectileDestroyed',
+
+  -- Misc Synced CallIns
+  'Explosion',
+
+  -- LuaRules CallIns
+  'CommandFallback',
+  'AllowCommand',
+  'AllowUnitCreation',
+  'AllowUnitTransfer',
+  'AllowUnitBuildStep',
+  'AllowFeatureCreation',
+  'AllowResourceLevel',
+  'AllowResourceTransfer',
+  'AllowDirectUnitControl',
+  'MoveCtrlNotify',
+  'TerraformComplete',
+  -- unsynced
+  'DrawUnit',
+  'AICallIn',
+
+  -- COB CallIn  (FIXME?)
+  'CobCallback',
+
+  -- Unsynced CallIns
+  'Update',
+  'DefaultCommand',
+  'DrawGenesis',
+  'DrawWorld',
+  'DrawWorldPreUnit',
+  'DrawWorldShadow',
+  'DrawWorldReflection',
+  'DrawWorldRefraction',
+  'DrawScreenEffects',
+  'DrawScreen',
+  'DrawInMiniMap',
+  'RecvFromSynced',
+
+  -- moved from LuaUI
+  'KeyPress',
+  'KeyRelease',
+  'MousePress',
+  'MouseRelease',
+  'MouseMove',
+  'MouseWheel',
+  'IsAbove',
+  'GetTooltip',
+
+  -- FIXME -- not implemented  (more of these?)
+  'WorldTooltip',
+  'MapDrawCmd',
+  'GameSetup',
+  'DefaultCommand',
+}
+
+
+-- initialize the call-in lists
+do
+  for _,listname in ipairs(callInLists) do
+    gadgetHandler[listname .. 'List'] = {}
+  end
+end
+
+
+-- Utility call
+local isSyncedCode = (SendToUnsynced ~= nil)
+local function IsSyncedCode()
+  return isSyncedCode
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  Reverse integer iterator for drawing
+--
+
+local function rev_iter(t, key)
+  if (key &lt;= 1) then
+    return nil
+  else
+    local nkey = key - 1
+    return nkey, t[nkey]
+  end
+end
+
+local function ripairs(t)
+  return rev_iter, t, (1 + #t)
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  returns:  basename, dirname
+--
+
+local function Basename(fullpath)
+  local _,_,base = string.find(fullpath, &quot;([^\\/:]*)$&quot;)
+  local _,_,path = string.find(fullpath, &quot;(.*[\\/:])[^\\/:]*$&quot;)
+  if (path == nil) then path = &quot;&quot; end
+  return base, path
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+function gadgetHandler:Initialize()
+  local unsortedGadgets = {}
+
+  -- get the gadget names
+  local gadgetFiles = VFS.DirList(GADGETS_DIR, &quot;*.lua&quot;, VFSMODE)
+--  table.sort(gadgetFiles)
+
+  for k,gf in ipairs(gadgetFiles) do
+    Spring.Echo('gf1 = ' .. gf) -- FIXME
+  end
+
+  -- stuff the gadgets into unsortedGadgets
+  for k,gf in ipairs(gadgetFiles) do
+    Spring.Echo('gf2 = ' .. gf) -- FIXME
+    local gadget = self:LoadGadget(gf)
+    if (gadget) then
+      table.insert(unsortedGadgets, gadget)
+    end
+  end
+
+  -- sort the gadgets  
+  table.sort(unsortedGadgets, function(g1, g2)
+    local l1 = g1.ghInfo.layer
+    local l2 = g2.ghInfo.layer
+    if (l1 ~= l2) then
+      return (l1 &lt; l2)
+    end
+    local n1 = g1.ghInfo.name
+    local n2 = g2.ghInfo.name
+    local o1 = self.orderList[n1]
+    local o2 = self.orderList[n2]
+    if (o1 ~= o2) then
+      return (o1 &lt; o2)
+    else
+      return (n1 &lt; n2)
+    end
+  end)
+
+  -- add the gadgets  
+  for _,g in ipairs(unsortedGadgets) do
+    gadgetHandler:InsertGadget(g)
+
+    local name = g.ghInfo.name
+    local basename = g.ghInfo.basename
+    Spring.Echo(string.format(&quot;Loaded gadget:  %-18s  &lt;%s&gt;&quot;, name, basename))
+  end
+end
+
+
+function gadgetHandler:LoadGadget(filename)
+  local basename = Basename(filename)
+  local text = VFS.LoadFile(filename, VFSMODE)
+  if (text == nil) then
+    Spring.Echo('1Failed to load: ' .. filename)
+    return nil
+  end
+  local chunk, err = loadstring(text, filename)
+  if (chunk == nil) then
+    Spring.Echo('Failed to load: ' .. basename .. '  (' .. err .. ')')
+    return nil
+  end
+  
+  local gadget = gadgetHandler:NewGadget()
+
+  setfenv(chunk, gadget)
+  local success, err = pcall(chunk)
+  if (not success) then
+    Spring.Echo('Failed to load: ' .. basename .. '  (' .. err .. ')')
+    return nil
+  end
+  if (err == false) then
+    return nil -- gadget asked for a quiet death
+  end
+
+  -- raw access to gadgetHandler
+  if (gadget.GetInfo and gadget:GetInfo().handler) then
+    gadget.gadgetHandler = self
+  end
+
+  self:FinalizeGadget(gadget, filename, basename)
+  local name = gadget.ghInfo.name
+
+  err = self:ValidateGadget(gadget)
+  if (err) then
+    Spring.Echo('Failed to load: ' .. basename .. '  (' .. err .. ')')
+    return nil
+  end
+
+  local knownInfo = self.knownGadgets[name]
+  if (knownInfo) then
+    if (knownInfo.active) then
+      Spring.Echo('Failed to load: ' .. basename .. '  (duplicate name)')
+      return nil
+    end
+  else
+    -- create a knownInfo table
+    knownInfo = {}
+    knownInfo.desc     = gadget.ghInfo.desc
+    knownInfo.author   = gadget.ghInfo.author
+    knownInfo.basename = gadget.ghInfo.basename
+    knownInfo.filename = gadget.ghInfo.filename
+    self.knownGadgets[name] = knownInfo
+    self.knownCount = self.knownCount + 1
+    self.knownChanged = true
+  end
+  knownInfo.active = true
+
+  local info  = gadget.GetInfo and gadget:GetInfo()
+  local order = self.orderList[name]
+  if (((order ~= nil) and (order &gt; 0)) or
+      ((order == nil) and ((info == nil) or info.enabled))) then
+    -- this will be an active gadget
+    if (order == nil) then
+      self.orderList[name] = 12345  -- back of the pack
+    else
+      self.orderList[name] = order
+    end
+  else
+    self.orderList[name] = 0
+    self.knownGadgets[name].active = false
+    return nil
+  end
+
+  return gadget
+end
+
+
+function gadgetHandler:NewGadget()
+  local gadget = {}
+  -- load the system calls into the gadget table
+  for k,v in pairs(System) do
+    gadget[k] = v
+  end
+  gadget._G = _G         -- the global table
+  gadget.GG = self.GG    -- the shared table
+  gadget.gadget = gadget -- easy self referencing
+
+  -- wrapped calls (closures)
+  gadget.gadgetHandler = {}
+  local gh = gadget.gadgetHandler
+  local self = self
+
+  gadget.include  = function (f)
+    return VFS.Include(f, gadget, VFSMODE)
+  end
+
+  gh.RaiseGadget  = function (_) self:RaiseGadget(gadget)      end
+  gh.LowerGadget  = function (_) self:LowerGadget(gadget)      end
+  gh.RemoveGadget = function (_) self:RemoveGadget(gadget)     end
+  gh.GetViewSizes = function (_) return self:GetViewSizes()    end
+  gh.GetHourTimer = function (_) return self:GetHourTimer()    end
+  gh.IsSyncedCode = function (_) return IsSyncedCode()         end
+
+  gh.UpdateCallIn = function (_, name)
+    self:UpdateGadgetCallIn(name, gadget)
+  end
+  gh.RemoveCallIn = function (_, name)
+    self:RemoveGadgetCallIn(name, gadget)
+  end
+
+  gh.RegisterCMDID = function(_, id)
+    self:RegisterCMDID(gadget, id)
+  end
+
+  gh.RegisterGlobal = function(_, name, value)
+    return self:RegisterGlobal(gadget, name, value)
+  end
+  gh.DeregisterGlobal = function(_, name)
+    return self:DeregisterGlobal(gadget, name)
+  end
+  gh.SetGlobal = function(_, name, value)
+    return self:SetGlobal(gadget, name, value)
+  end
+
+  gh.AddChatAction = function (_, cmd, func, help)
+    return actionHandler.AddChatAction(gadget, cmd, func, help)
+  end
+  gh.RemoveChatAction = function (_, cmd)
+    return actionHandler.RemoveChatAction(gadget, cmd)
+  end
+
+  if (not IsSyncedCode()) then
+    gh.AddSyncAction = function(_, cmd, func, help)
+      return actionHandler.AddSyncAction(gadget, cmd, func, help)
+    end
+    gh.RemoveSyncAction = function(_, cmd)
+      return actionHandler.RemoveSyncAction(gadget, cmd)
+    end
+  end
+
+  -- for proxied call-ins
+  gh.IsMouseOwner = function (_)
+    return (self.mouseOwner == gadget)
+  end
+  gh.DisownMouse  = function (_)
+    if (self.mouseOwner == gadget) then
+      self.mouseOwner = nil
+    end
+  end
+
+  return gadget
+end
+
+
+function gadgetHandler:FinalizeGadget(gadget, filename, basename)
+  local gi = {}
+
+  gi.filename = filename
+  gi.basename = basename
+  if (gadget.GetInfo == nil) then
+    gi.name  = basename
+    gi.layer = 0
+  else
+    local info = gadget:GetInfo()
+    gi.name      = info.name    or basename
+    gi.layer     = info.layer   or 0
+    gi.desc      = info.desc    or &quot;&quot;
+    gi.author    = info.author  or &quot;&quot;
+    gi.license   = info.license or &quot;&quot;
+    gi.enabled   = info.enabled or false
+  end
+
+  gadget.ghInfo = {}  --  a proxy table
+  local mt = {
+    __index = gi,
+    __newindex = function() error(&quot;ghInfo tables are read-only&quot;) end,
+    __metatable = &quot;protected&quot;
+  }
+  setmetatable(gadget.ghInfo, mt)
+end
+
+
+function gadgetHandler:ValidateGadget(gadget)
+  if (gadget.GetTooltip and not gadget.IsAbove) then
+    return &quot;Gadget has GetTooltip() but not IsAbove()&quot;
+  end
+  if (gadget.TweakGetTooltip and not gadget.TweakIsAbove) then
+    return &quot;Gadget has TweakGetTooltip() but not TweakIsAbove()&quot;
+  end
+  return nil
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local function SafeWrap(func, funcName)
+  local gh = gadgetHandler
+  return function(g, ...)
+    local r = { pcall(func, g, ...) }
+    if (r[1]) then
+      table.remove(r, 1)
+      return unpack(r)
+    else
+      if (funcName ~= 'Shutdown') then
+        gadgetHandler:RemoveGadget(g)
+      else
+        Spring.Echo('Error in Shutdown')
+      end
+      local name = g.ghInfo.name
+      Spring.Echo(r[2])
+      Spring.Echo('Removed gadget: ' .. name)
+      return nil
+    end
+  end
+end
+
+
+local function SafeWrapGadget(gadget)
+  if (SAFEWRAP &lt;= 0) then
+    return
+  elseif (SAFEWRAP == 1) then
+    if (gadget.GetInfo and gadget.GetInfo().unsafe) then
+      Spring.Echo('LuaUI: loaded unsafe gadget: ' .. gadget.ghInfo.name)
+      return
+    end
+  end
+
+  for _,ciName in ipairs(callInLists) do
+    if (gadget[ciName]) then
+      gadget[ciName] = SafeWrap(gadget[ciName], ciName)
+    end
+    if (gadget.Initialize) then
+      gadget.Initialize = SafeWrap(gadget.Initialize, 'Initialize')
+    end
+  end
+end
+
+
+--------------------------------------------------------------------------------
+
+local function ArrayInsert(t, f, g)
+  if (f) then
+    local layer = g.ghInfo.layer
+    local index = 1
+    for i,v in ipairs(t) do
+      if (v == g) then
+        return -- already in the table
+      end
+      if (layer &gt;= v.ghInfo.layer) then
+        index = i + 1
+      end
+    end
+    table.insert(t, index, g)
+  end
+end
+
+
+local function ArrayRemove(t, g)
+  for k,v in ipairs(t) do
+    if (v == g) then
+      table.remove(t, k)
+      -- break
+    end
+  end
+end
+
+
+function gadgetHandler:InsertGadget(gadget)
+  if (gadget == nil) then
+    return
+  end
+
+  ArrayInsert(self.gadgets, true, gadget)
+  for _,listname in ipairs(callInLists) do
+    local func = gadget[listname]
+    if (type(func) == 'function') then
+      ArrayInsert(self[listname..'List'], func, gadget)
+    end
+  end
+
+  self:UpdateCallIns()
+  if (gadget.Initialize) then
+    gadget:Initialize()
+  end
+  self:UpdateCallIns()
+end
+
+
+function gadgetHandler:RemoveGadget(gadget)
+  if (gadget == nil) then
+    return
+  end
+
+  local name = gadget.ghInfo.name
+  self.knownGadgets[name].active = false
+  if (gadget.Shutdown) then
+    gadget:Shutdown()
+  end
+
+  ArrayRemove(self.gadgets, gadget)
+  self:RemoveGadgetGlobals(gadget)
+  actionHandler.RemoveGadgetActions(gadget)
+  for _,listname in ipairs(callInLists) do
+    ArrayRemove(self[listname..'List'], gadget)
+  end
+
+  for id,g in pairs(self.CMDIDs) do
+    if (g == gadget) then
+      self.CMDIDs[id] = nil
+    end
+  end
+
+  self:UpdateCallIns()
+end
+
+
+--------------------------------------------------------------------------------
+
+function gadgetHandler:UpdateCallIn(name)
+  local listName = name .. 'List'
+  if ((#self[listName] &gt; 0)       or
+      (name == 'GotChatMsg')      or
+      (name == 'RecvFromSynced')) then
+    local selffunc = self[name]
+    _G[name] = function(...)
+      return selffunc(self, ...)
+    end
+  else
+    _G[name] = nil
+  end
+  Script.UpdateCallIn(name)
+end
+
+
+function gadgetHandler:UpdateGadgetCallIn(name, g)
+  local listName = name .. 'List'
+  local ciList = self[listName]
+  if (ciList) then
+    local func = g[name]
+    if (type(func) == 'function') then
+      ArrayInsert(ciList, func, g)
+    else
+      ArrayRemove(ciList, g)
+    end
+    self:UpdateCallIn(name)
+  else
+    Spring.Echo('UpdateGadgetCallIn: bad name: ' .. name)
+  end
+end
+
+
+function gadgetHandler:RemoveGadgetCallIn(name, g)
+  local listName = name .. 'List'
+  local ciList = self[listName]
+  if (ciList) then
+    ArrayRemove(ciList, g)
+    self:UpdateCallIn(name)
+  else
+    Spring.Echo('RemoveGadgetCallIn: bad name: ' .. name)
+  end
+end
+
+
+function gadgetHandler:UpdateCallIns()
+  for _,name in ipairs(callInLists) do
+    self:UpdateCallIn(name)
+  end
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+function gadgetHandler:EnableGadget(name)
+  local ki = self.knownGadgets[name]
+  if (not ki) then
+    Spring.Echo(&quot;EnableGadget(), could not find gadget: &quot; .. tostring(name))
+    return false
+  end
+  if (not ki.active) then
+    Spring.Echo('Loading:  '..ki.filename)
+    local order = gadgetHandler.orderList[name]
+    if (not order or (order &lt;= 0)) then
+      self.orderList[name] = 1
+    end
+    local w = self:LoadGadget(ki.filename)
+    if (not w) then return false end
+    self:InsertGadget(w)
+  end
+  return true
+end
+
+
+function gadgetHandler:DisableGadget(name)
+  local ki = self.knownGadgets[name]
+  if (not ki) then
+    Spring.Echo(&quot;DisableGadget(), could not find gadget: &quot; .. tostring(name))
+    return false
+  end
+  if (ki.active) then
+    local w = self:FindGadget(name)
+    if (not w) then return false end
+    Spring.Echo('Removed:  '..ki.filename)
+    self:RemoveGadget(w)     -- deactivate
+    self.orderList[name] = 0 -- disable
+  end
+  return true
+end
+
+
+function gadgetHandler:ToggleGadget(name)
+  local ki = self.knownGadgets[name]
+  if (not ki) then
+    Spring.Echo(&quot;ToggleGadget(), could not find gadget: &quot; .. tostring(name))
+    return
+  end
+  if (ki.active) then
+    return self:DisableGadget(name)
+  elseif (self.orderList[name] &lt;= 0) then
+    return self:EnableGadget(name)
+  else
+    -- the gadget is not active, but enabled; disable it
+    self.orderList[name] = 0
+  end
+  return true
+end
+
+
+--------------------------------------------------------------------------------
+
+local function FindGadgetIndex(t, w)
+  for k,v in ipairs(t) do
+    if (v == w) then
+      return k
+    end
+  end
+  return nil
+end
+
+
+local function FindLowestIndex(t, i, layer)
+  for x = (i - 1), 1, -1 do
+    if (t[x].ghInfo.layer &lt; layer) then
+      return x + 1
+    end
+  end
+  return 1
+end
+
+
+function gadgetHandler:RaiseGadget(gadget)
+  if (gadget == nil) then
+    return
+  end
+  local function Raise(t, f, w)
+    if (f == nil) then return end
+    local i = FindGadgetIndex(t, w)
+    if (i == nil) then return end
+    local n = FindLowestIndex(t, i, w.ghInfo.layer)
+    if (n and (n &lt; i)) then
+      table.remove(t, i)
+      table.insert(t, n, w)
+    end
+  end
+  Raise(self.gadgets, true, gadget)
+  for _,listname in ipairs(callInLists) do
+    Raise(self[listname..'List'], gadget[listname], gadget)
+  end
+end
+
+
+local function FindHighestIndex(t, i, layer)
+  local ts = #t
+  for x = (i + 1),ts do
+    if (t[x].ghInfo.layer &gt; layer) then
+      return (x - 1)
+    end
+  end
+  return (ts + 1)
+end
+
+
+function gadgetHandler:LowerGadget(gadget)
+  if (gadget == nil) then
+    return
+  end
+  local function Lower(t, f, w)
+    if (f == nil) then return end
+    local i = FindGadgetIndex(t, w)
+    if (i == nil) then return end
+    local n = FindHighestIndex(t, i, w.ghInfo.layer)
+    if (n and (n &gt; i)) then
+      table.insert(t, n, w)
+      table.remove(t, i)
+    end
+  end
+  Lower(self.gadgets, true, gadget)
+  for _,listname in ipairs(callInLists) do
+    Lower(self[listname..'List'], gadget[listname], gadget)
+  end
+end
+
+
+function gadgetHandler:FindGadget(name)
+  if (type(name) ~= 'string') then
+    return nil
+  end
+  for k,v in ipairs(self.gadgets) do
+    if (name == v.ghInfo.name) then
+      return v,k
+    end
+  end
+  return nil
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  Global var/func management
+--
+
+function gadgetHandler:RegisterGlobal(owner, name, value)
+  if ((name == nil)        or
+      (_G[name])           or
+      (self.globals[name]) or
+      (CallInsMap[name])) then
+    return false
+  end
+  _G[name] = value
+  self.globals[name] = owner
+  return true
+end
+
+
+function gadgetHandler:DeregisterGlobal(owner, name)
+  if (name == nil) then
+    return false
+  end
+  _G[name] = nil
+  self.globals[name] = nil
+  return true
+end
+
+
+function gadgetHandler:SetGlobal(owner, name, value)
+  if ((name == nil) or (self.globals[name] ~= owner)) then
+    return false
+  end
+  _G[name] = value
+  return true
+end
+
+
+function gadgetHandler:RemoveGadgetGlobals(owner)
+  local count = 0
+  for name, o in pairs(self.globals) do
+    if (o == owner) then
+      _G[name] = nil
+      self.globals[name] = nil
+      count = count + 1
+    end
+  end
+  return count
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  Helper facilities
+--
+
+local hourTimer = 0
+
+
+function gadgetHandler:GetHourTimer()
+  return hourTimer
+end
+
+
+function gadgetHandler:GetViewSizes()
+  return self.xViewSize, self.yViewSize
+end
+
+
+function gadgetHandler:RegisterCMDID(gadget, id)
+  if (id &lt; 30000) then
+    Spring.Echo('Gadget (' .. gadget.ghInfo.name .. ') ' ..
+                'tried to register a CMD_ID &lt; 30000')
+    Script.Kill('Bad CMD_ID code: ' .. id)
+  end
+  if (id &gt;= 40000) then
+    Spring.Echo('Gadget (' .. gadget.ghInfo.name .. ') ' ..
+                'tried to register a CMD_ID &gt;= 40000')
+    Script.Kill('Bad CMD_ID code: ' .. id)
+  end
+  if (self.CMDIDs[id] ~= nil) then
+    Spring.Echo('Gadget (' .. gadget.ghInfo.name .. ') ' ..
+                'tried to register a CMD_ID &gt;= 40000')
+    Script.Kill('Duplicate CMD_ID code: ' .. id)
+  end
+  self.CMDIDs[id] = gadget
+end
+
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  The call-in distribution routines
+--
+
+function gadgetHandler:GamePreload()
+  for _,g in ipairs(self.GamePreloadList) do
+    g:GamePreload()
+  end
+  return
+end
+
+function gadgetHandler:GameStart()
+  for _,g in ipairs(self.GameStartList) do
+    g:GameStart()
+  end
+  return
+end
+
+function gadgetHandler:Shutdown()
+  for _,g in ipairs(self.ShutdownList) do
+    g:Shutdown()
+  end
+  return
+end
+
+function gadgetHandler:GameFrame(frameNum)
+  for _,g in ipairs(self.GameFrameList) do
+    g:GameFrame(frameNum)
+  end
+  return
+end
+
+
+function gadgetHandler:RecvFromSynced(...)
+  if (actionHandler.RecvFromSynced(...)) then
+    return
+  end
+  for _,g in ipairs(self.RecvFromSyncedList) do
+    if (g:RecvFromSynced(...)) then
+      return
+    end
+  end
+  return
+end
+
+
+function gadgetHandler:GotChatMsg(msg, player)
+  if ((player == 0) and Spring.IsCheatingEnabled()) then
+    local sp = '^%s*'    -- start pattern
+    local ep = '%s+(.*)' -- end pattern
+    local s, e, match
+    s, e, match = string.find(msg, sp..'togglegadget'..ep)
+    if (match) then
+      self:ToggleGadget(match)
+      return true
+    end
+    s, e, match = string.find(msg, sp..'enablegadget'..ep)
+    if (match) then
+      self:EnableGadget(match)
+      return true
+    end
+    s, e, match = string.find(msg, sp..'disablegadget'..ep)
+    if (match) then
+      self:DisableGadget(match)
+      return true
+    end
+  end
+
+  if (actionHandler.GotChatMsg(msg, player)) then
+    return true
+  end
+
+  for _,g in ipairs(self.GotChatMsgList) do
+    if (g:GotChatMsg(msg, player)) then
+      return true
+    end
+  end
+
+  if (IsSyncedCode()) then
+    SendToUnsynced(player, msg)
+  end
+
+  return false
+end
+
+
+function gadgetHandler:RecvLuaMsg(msg, player)
+  for _,g in ipairs(self.RecvLuaMsgList) do
+    if (g:RecvLuaMsg(msg, player)) then
+      return true
+    end
+  end
+  return false
+end
+
+
+--------------------------------------------------------------------------------
+--
+--  Drawing call-ins
+--
+
+-- generates ViewResize() calls for the gadgets
+function gadgetHandler:SetViewSize(vsx, vsy)
+  self.xViewSize = vsx
+  self.yViewSize = vsy
+  if ((self.xViewSizeOld ~= vsx) or
+      (self.yViewSizeOld ~= vsy)) then
+    gadgetHandler:ViewResize(vsx, vsy)
+    self.xViewSizeOld = vsx
+    self.yViewSizeOld = vsy
+  end
+end
+
+
+function gadgetHandler:ViewResize(vsx, vsy)
+  for _,g in ipairs(self.ViewResizeList) do
+    g:ViewResize(vsx, vsy)
+  end
+  return
+end
+
+
+--------------------------------------------------------------------------------
+--
+--  Game call-ins
+--
+
+function gadgetHandler:GameOver()
+  for _,g in ipairs(self.GameOverList) do
+    g:GameOver()
+  end
+  return
+end
+
+
+function gadgetHandler:TeamDied(teamID)
+  for _,g in ipairs(self.TeamDiedList) do
+    g:TeamDied(teamID)
+  end
+  return
+end
+
+
+--------------------------------------------------------------------------------
+--
+--  LuaRules Game call-ins
+--
+
+function gadgetHandler:DrawUnit(unitID, drawMode)
+  for _,g in ipairs(self.DrawUnitList) do
+    if (g:DrawUnit(unitID, drawMode)) then
+      return true
+    end
+  end
+  return false
+end
+
+
+function gadgetHandler:AICallIn(dataStr)
+  for _,g in ipairs(self.AICallInList) do
+    local dataRet = g:AICallIn(dataStr)
+    if (dataRet) then
+      return dataRet
+    end
+  end
+end
+
+
+function gadgetHandler:CommandFallback(unitID, unitDefID, unitTeam,
+                                       cmdID, cmdParams, cmdOptions, cmdTag)
+  for _,g in ipairs(self.CommandFallbackList) do
+    local used, remove = g:CommandFallback(unitID, unitDefID, unitTeam,
+                                           cmdID, cmdParams, cmdOptions, cmdTag)
+    if (used) then
+      return remove
+    end
+  end
+  return true  -- remove the command
+end
+
+
+function gadgetHandler:AllowCommand(unitID, unitDefID, unitTeam,
+                                    cmdID, cmdParams, cmdOptions, cmdTag, synced)
+  for _,g in ipairs(self.AllowCommandList) do
+    if (not g:AllowCommand(unitID, unitDefID, unitTeam,
+                           cmdID, cmdParams, cmdOptions, cmdTag, synced)) then
+      return false
+    end
+  end
+  return true
+end
+
+
+function gadgetHandler:AllowUnitCreation(unitDefID, builderID,
+                                         builderTeam, x, y, z)
+  for _,g in ipairs(self.AllowUnitCreationList) do
+    if (not g:AllowUnitCreation(unitDefID, builderID,
+                                builderTeam, x, y, z)) then
+      return false
+    end
+  end
+  return true
+end
+
+
+function gadgetHandler:AllowUnitTransfer(unitID, unitDefID,
+                                         oldTeam, newTeam, capture)
+  for _,g in ipairs(self.AllowUnitTransferList) do
+    if (not g:AllowUnitTransfer(unitID, unitDefID,
+                                oldTeam, newTeam, capture)) then
+      return false
+    end
+  end
+  return true
+end
+
+
+function gadgetHandler:AllowUnitBuildStep(builderID, builderTeam,
+                                          unitID, unitDefID, part)
+  for _,g in ipairs(self.AllowUnitBuildStepList) do
+    if (not g:AllowUnitBuildStep(builderID, builderTeam,
+                                 unitID, unitDefID, part)) then
+      return false
+    end
+  end
+  return true
+end
+
+
+function gadgetHandler:AllowFeatureCreation(featureDefID, teamID, x, y, z)
+  for _,g in ipairs(self.AllowFeatureCreationList) do
+    if (not g:AllowFeatureCreation(featureDefID, teamID, x, y, z)) then
+      return false
+    end
+  end
+  return true
+end
+
+
+function gadgetHandler:AllowResourceLevel(teamID, res, level)
+  for _,g in ipairs(self.AllowResourceLevelList) do
+    if (not g:AllowResourceLevel(teamID, res, level)) then
+      return false
+    end
+  end
+  return true
+end
+
+
+function gadgetHandler:AllowResourceTransfer(teamID, res, level)
+  for _,g in ipairs(self.AllowResourceTransferList) do
+    if (not g:AllowResourceTransfer(teamID, res, level)) then
+      return false
+    end
+  end
+  return true
+end
+
+
+function gadgetHandler:AllowDirectUnitControl(unitID, unitDefID, unitTeam,
+                                              playerID)
+  for _,g in ipairs(self.AllowDirectUnitControlList) do
+    if (not g:AllowDirectUnitControl(unitID, unitDefID, unitTeam,
+                                     playerID)) then
+      return false
+    end
+  end
+  return true
+end
+
+
+function gadgetHandler:MoveCtrlNotify(unitID, unitDefID, unitTeam, data)
+  local state = false
+  for _,g in ipairs(self.MoveCtrlNotifyList) do
+    if (g:MoveCtrlNotify(unitID, unitDefID, unitTeam, data)) then
+      state = true
+    end
+  end
+  return state
+end
+
+
+function gadgetHandler:TerraformComplete(unitID, unitDefID, unitTeam,
+                                       buildUnitID, buildUnitDefID, buildUnitTeam)
+  for _,g in ipairs(self.TerraformCompleteList) do
+    local stop = g:TerraformComplete(unitID, unitDefID, unitTeam,
+                                       buildUnitID, buildUnitDefID, buildUnitTeam)
+    if (stop) then
+      return true
+    end
+  end
+  return false
+end
+
+
+--------------------------------------------------------------------------------
+--
+--  Unit call-ins
+--
+
+function gadgetHandler:UnitCreated(unitID, unitDefID, unitTeam, builderID)
+  for _,g in ipairs(self.UnitCreatedList) do
+    g:UnitCreated(unitID, unitDefID, unitTeam, builderID)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitFinished(unitID, unitDefID, unitTeam)
+  for _,g in ipairs(self.UnitFinishedList) do
+    g:UnitFinished(unitID, unitDefID, unitTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitFromFactory(unitID, unitDefID, unitTeam,
+                                       factID, factDefID, userOrders)
+  for _,g in ipairs(self.UnitFromFactoryList) do
+    g:UnitFromFactory(unitID, unitDefID, unitTeam,
+                      factID, factDefID, userOrders)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitDestroyed(unitID,     unitDefID,     unitTeam,
+                                     attackerID, attackerDefID, attackerTeam)
+  for _,g in ipairs(self.UnitDestroyedList) do
+    g:UnitDestroyed(unitID,     unitDefID,     unitTeam,
+                    attackerID, attackerDefID, attackerTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitExperience(unitID, unitDefID, unitTeam,
+                                      experience, oldExperience)
+  for _,g in ipairs(self.UnitExperienceList) do
+    g:UnitExperience(unitID, unitDefID, unitTeam, experience, oldExperience)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitIdle(unitID, unitDefID, unitTeam)
+  for _,g in ipairs(self.UnitIdleList) do
+    g:UnitIdle(unitID, unitDefID, unitTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitCmdDone(unitID, unitDefID, unitTeam, cmdID, cmdTag)
+  for _,g in ipairs(self.UnitCmdDoneList) do
+    g:UnitCmdDone(unitID, unitDefID, unitTeam, cmdID, cmdTag)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitDamaged(unitID, unitDefID, unitTeam,
+                                   damage, paralyzer, weaponID,
+                                   attackerID, attackerDefID, attackerTeam)
+  for _,g in ipairs(self.UnitDamagedList) do
+    g:UnitDamaged(unitID, unitDefID, unitTeam,
+                  damage, paralyzer, weaponID,
+                  attackerID, attackerDefID, attackerTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitTaken(unitID, unitDefID, unitTeam, newTeam)
+  for _,g in ipairs(self.UnitTakenList) do
+    g:UnitTaken(unitID, unitDefID, unitTeam, newTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitGiven(unitID, unitDefID, unitTeam, oldTeam)
+  for _,g in ipairs(self.UnitGivenList) do
+    g:UnitGiven(unitID, unitDefID, unitTeam, oldTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitEnteredRadar(unitID, unitTeam, allyTeam, unitDefID)
+  for _,g in ipairs(self.UnitEnteredRadarList) do
+    g:UnitEnteredRadar(unitID, unitTeam, allyTeam, unitDefID)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitEnteredLos(unitID, unitTeam, allyTeam, unitDefID)
+  for _,g in ipairs(self.UnitEnteredLosList) do
+    g:UnitEnteredLos(unitID, unitTeam, allyTeam, unitDefID)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitLeftRadar(unitID, unitTeam, allyTeam, unitDefID)
+  for _,g in ipairs(self.UnitLeftRadarList) do
+    g:UnitLeftRadar(unitID, unitTeam, allyTeam, unitDefID)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitLeftLos(unitID, unitTeam, allyTeam, unitDefID)
+  for _,g in ipairs(self.UnitLeftLosList) do
+    g:UnitLeftLos(unitID, unitTeam, allyTeam, unitDefID)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitSeismicPing(x, y, z, strength,
+                                       allyTeam, unitID, unitDefID)
+  for _,g in ipairs(self.UnitSeismicPingList) do
+    g:UnitSeismicPing(x, y, z, strength,
+                      allyTeam, unitID, unitDefID)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitLoaded(unitID, unitDefID, unitTeam,
+                                  transportID, transportTeam)
+  for _,g in ipairs(self.UnitLoadedList) do
+    g:UnitLoaded(unitID, unitDefID, unitTeam,
+                 transportID, transportTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitUnloaded(unitID, unitDefID, unitTeam,
+                                    transportID, transportTeam)
+  for _,g in ipairs(self.UnitUnloadedList) do
+    g:UnitUnloaded(unitID, unitDefID, unitTeam,
+                   transportID, transportTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitCloaked(unitID, unitDefID, unitTeam)
+  for _,g in ipairs(self.UnitCloakedList) do
+    g:UnitCloaked(unitID, unitDefID, unitTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:UnitDecloaked(unitID, unitDefID, unitTeam)
+  for _,g in ipairs(self.UnitDecloakedList) do
+    g:UnitDecloaked(unitID, unitDefID, unitTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:StockpileChanged(unitID, unitDefID, unitTeam,
+                                        weaponNum, oldCount, newCount)
+  for _,g in ipairs(self.StockpileChangedList) do
+    g:StockpileChanged(unitID, unitDefID, unitTeam,
+                       weaponNum, oldCount, newCount)
+  end
+  return
+end
+
+
+--------------------------------------------------------------------------------
+--
+--  Feature call-ins
+--
+
+function gadgetHandler:FeatureCreated(featureID, allyTeam)
+  for _,g in ipairs(self.FeatureCreatedList) do
+    g:FeatureCreated(featureID, allyTeam)
+  end
+  return
+end
+
+
+function gadgetHandler:FeatureDestroyed(featureID, allyTeam)
+  for _,g in ipairs(self.FeatureDestroyedList) do
+    g:FeatureDestroyed(featureID, allyTeam)
+  end
+  return
+end
+
+
+--------------------------------------------------------------------------------
+--
+--  Projectile call-ins
+--
+
+function gadgetHandler:ProjectileCreated(proID, proOwnerID)
+  for _,g in ipairs(self.ProjectileCreatedList) do
+    g:ProjectileCreated(proID, proOwnerID)
+  end
+  return
+end
+
+
+function gadgetHandler:ProjectileDestroyed(proID)
+  for _,g in ipairs(self.ProjectileDestroyedList) do
+    g:ProjectileDestroyed(proID)
+  end
+  return
+end
+
+
+--------------------------------------------------------------------------------
+--
+--  Misc call-ins
+--
+
+function gadgetHandler:Explosion(weaponID, px, py, pz, ownerID)
+  local noGfx = false
+  for _,g in ipairs(self.ExplosionList) do
+    noGfx = noGfx or g:Explosion(weaponID, px, py, pz, ownerID)
+  end
+  return noGfx
+end
+
+
+--------------------------------------------------------------------------------
+--
+--  Draw call-ins
+--
+
+function gadgetHandler:Update()
+  for _,g in ipairs(self.UpdateList) do
+    g:Update()
+  end
+  return
+end
+
+
+function gadgetHandler:DefaultCommand(type, id)
+  for _,g in ipairs(self.DefaultCommandList) do
+    local id = g:DefaultCommand(type, id)
+    if (id) then
+      return id
+    end
+  end
+  return
+end
+
+
+function gadgetHandler:DrawGenesis()
+  for _,g in ipairs(self.DrawGenesisList) do
+    g:DrawGenesis()
+  end
+  return
+end
+
+
+function gadgetHandler:DrawWorld()
+  for _,g in ipairs(self.DrawWorldList) do
+    g:DrawWorld()
+  end
+  return
+end
+
+
+function gadgetHandler:DrawWorldPreUnit()
+  for _,g in ipairs(self.DrawWorldPreUnitList) do
+    g:DrawWorldPreUnit()
+  end
+  return
+end
+
+
+function gadgetHandler:DrawWorldShadow()
+  for _,g in ipairs(self.DrawWorldShadowList) do
+    g:DrawWorldShadow()
+  end
+  return
+end
+
+
+function gadgetHandler:DrawWorldReflection()
+  for _,g in ipairs(self.DrawWorldReflectionList) do
+    g:DrawWorldReflection()
+  end
+  return
+end
+
+
+function gadgetHandler:DrawWorldRefraction()
+  for _,g in ipairs(self.DrawWorldRefractionList) do
+    g:DrawWorldRefraction()
+  end
+  return
+end
+
+
+function gadgetHandler:DrawScreenEffects(vsx, vsy)
+  for _,g in ipairs(self.DrawScreenEffectsList) do
+    g:DrawScreenEffects(vsx, vsy)
+  end
+  return
+end
+
+
+function gadgetHandler:DrawScreen(vsx, vsy)
+  for _,g in ipairs(self.DrawScreenList) do
+    g:DrawScreen(vsx, vsy)
+  end
+  return
+end
+
+
+function gadgetHandler:DrawInMiniMap(mmsx, mmsy)
+  for _,g in ipairs(self.DrawInMiniMapList) do
+    g:DrawInMiniMap(mmsx, mmsy)
+  end
+  return
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+function gadgetHandler:KeyPress(key, mods, isRepeat, label, unicode)
+  for _,g in ipairs(self.KeyPressList) do
+    if (g:KeyPress(key, mods, isRepeat, label, unicode)) then
+      return true
+    end
+  end
+  return false
+end
+
+
+function gadgetHandler:KeyRelease(key, mods, label, unicode)
+  for _,g in ipairs(self.KeyReleaseList) do
+    if (g:KeyRelease(key, mods, label, unicode)) then
+      return true
+    end
+  end
+  return false
+end
+
+
+function gadgetHandler:MousePress(x, y, button)
+  local mo = self.mouseOwner
+  if (mo) then
+    mo:MousePress(x, y, button)
+    return true  --  already have an active press
+  end
+  for _,g in ipairs(self.MousePressList) do
+    if (g:MousePress(x, y, button)) then
+      self.mouseOwner = g
+      return true
+    end
+  end
+  return false
+end
+
+
+function gadgetHandler:MouseMove(x, y, dx, dy, button)
+  local mo = self.mouseOwner
+  if (mo and mo.MouseMove) then
+    return mo:MouseMove(x, y, dx, dy, button)
+  end
+end
+
+
+function gadgetHandler:MouseRelease(x, y, button)
+  local mo = self.mouseOwner
+  local mx, my, lmb, mmb, rmb = Spring.GetMouseState()
+  if (not (lmb or mmb or rmb)) then
+    self.mouseOwner = nil
+  end
+  if (mo and mo.MouseRelease) then
+    return mo:MouseRelease(x, y, button)
+  end
+  return -1
+end
+
+
+function gadgetHandler:MouseWheel(up, value)
+  for _,g in ipairs(self.MouseWheelList) do
+    if (g:MouseWheel(up, value)) then
+      return true
+    end
+  end
+  return false
+end
+
+
+function gadgetHandler:IsAbove(x, y)
+  for _,g in ipairs(self.IsAboveList) do
+    if (g:IsAbove(x, y)) then
+      return true
+    end
+  end
+  return false
+end
+
+
+function gadgetHandler:GetTooltip(x, y)
+  for _,g in ipairs(self.GetTooltipList) do
+    if (g:IsAbove(x, y)) then
+      local tip = g:GetTooltip(x, y)
+      if (string.len(tip) &gt; 0) then
+        return tip
+      end
+    end
+  end
+  return ''
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+gadgetHandler:Initialize()
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+

Modified: trunk/installer/builddata/springcontent/gamedata/weapondefs_post.lua
===================================================================
--- trunk/installer/builddata/springcontent/gamedata/weapondefs_post.lua	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/installer/builddata/springcontent/gamedata/weapondefs_post.lua	2008-09-30 10:31:39 UTC (rev 6486)
@@ -82,6 +82,11 @@
       wd.weapontype = &quot;Cannon&quot;;
     end
   end
+
+  -- 
+  if (tobool(wd.ballistic) or tobool(wd.dropped)) then
+    wd.gravityaffected = true
+  end
 end
 
 --------------------------------------------------------------------------------

Modified: trunk/rts/Lua/LuaFeatureDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaFeatureDefs.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Lua/LuaFeatureDefs.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -448,7 +448,10 @@
 	ADD_BOOL(&quot;floating&quot;,     fd.floating);
 	ADD_BOOL(&quot;geoThermal&quot;,   fd.geoThermal);
 	ADD_BOOL(&quot;noSelect&quot;,     fd.noSelect);
+	ADD_INT(&quot;resurrectable&quot;, fd.resurrectable);
 
+	ADD_INT(&quot;smokeTime&quot;,    fd.smokeTime);
+
 	// name of feature that this turn into when killed (not reclaimed)
 	ADD_STRING(&quot;deathFeature&quot;, fd.deathFeature);
 

Modified: trunk/rts/Lua/LuaRules.cpp
===================================================================
--- trunk/rts/Lua/LuaRules.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Lua/LuaRules.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -278,7 +278,7 @@
 	}
 
 	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 8);
+	lua_checkstack(L, 9);
 	static const LuaHashString cmdStr(&quot;CommandFallback&quot;);
 	if (!cmdStr.GetGlobalFunc(L)) {
 		return true; // the call is not defined
@@ -309,8 +309,11 @@
 	HSTR_PUSH_BOOL(L, &quot;shift&quot;, !!(cmd.options &amp; SHIFT_KEY));
 	HSTR_PUSH_BOOL(L, &quot;right&quot;, !!(cmd.options &amp; RIGHT_MOUSE_KEY));
 
+	// push the command tag
+	lua_pushnumber(L, cmd.tag);
+
 	// call the function
-	if (!RunCallIn(cmdStr, 6, 1)) {
+	if (!RunCallIn(cmdStr, 7, 1)) {
 		return true;
 	}
 
@@ -336,7 +339,7 @@
 	}
 
 	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 9);
+	lua_checkstack(L, 10);
 	static const LuaHashString cmdStr(&quot;AllowCommand&quot;);
 	if (!cmdStr.GetGlobalFunc(L)) {
 		return true; // the call is not defined
@@ -367,10 +370,13 @@
 	HSTR_PUSH_BOOL(L, &quot;shift&quot;, !!(cmd.options &amp; SHIFT_KEY));
 	HSTR_PUSH_BOOL(L, &quot;right&quot;, !!(cmd.options &amp; RIGHT_MOUSE_KEY));
 
+	// push the command tag
+	lua_pushnumber(L, cmd.tag);
+
 	lua_pushboolean(L, fromSynced);
 
 	// call the function
-	if (!RunCallIn(cmdStr, 7, 1)) {
+	if (!RunCallIn(cmdStr, 8, 1)) {
 		return true;
 	}
 

Modified: trunk/rts/Lua/LuaWeaponDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaWeaponDefs.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Lua/LuaWeaponDefs.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -506,10 +506,6 @@
 
 	ADD_BOOL(&quot;selfExplode&quot;, wd.selfExplode);
 	ADD_BOOL(&quot;gravityAffected&quot;, wd.gravityAffected);
-	ADD_BOOL(&quot;twoPhase&quot;, wd.twophase);
-	ADD_BOOL(&quot;guided&quot;, wd.guided);
-	ADD_BOOL(&quot;vlaunch&quot;, wd.vlaunch);
-	ADD_BOOL(&quot;selfprop&quot;, wd.selfprop);
 	ADD_BOOL(&quot;noExplode&quot;, wd.noExplode);
 	ADD_FLOAT(&quot;startvelocity&quot;, wd.startvelocity);
 	ADD_FLOAT(&quot;weaponAcceleration&quot;, wd.weaponacceleration);

Modified: trunk/rts/Map/MapInfo.cpp
===================================================================
--- trunk/rts/Map/MapInfo.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Map/MapInfo.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -201,6 +201,8 @@
 
 	water.shoreWaves = wt.GetBool(&quot;shoreWaves&quot;, true);
 
+	water.alwaysRenderWater = wt.GetBool(&quot;alwaysRenderWater&quot;, false);
+
 	// use 'resources.lua' for missing fields  (our the engine defaults)
 	const LuaTable resGfxMaps = resRoot-&gt;SubTable(&quot;graphics&quot;).SubTable(&quot;maps&quot;);
 

Modified: trunk/rts/Map/MapInfo.h
===================================================================
--- trunk/rts/Map/MapInfo.h	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Map/MapInfo.h	2008-09-30 10:31:39 UTC (rev 6486)
@@ -133,6 +133,7 @@
 		float  perlinLacunarity;
 		float  perlinAmplitude;
 		bool   shoreWaves;
+		bool   alwaysRenderWater; ///&lt; if false the renderers will render it only if currentMinMapHeight&lt;0
 		unsigned char numTiles;
 		std::string texture;
 		std::string foamTexture;

Modified: trunk/rts/Rendering/Env/AdvWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvWater.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Rendering/Env/AdvWater.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -120,7 +120,7 @@
 
 void CAdvWater::Draw(bool useBlending)
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f)
+	if (!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	float3 dir,zpos;
@@ -228,7 +228,7 @@
 
 void CAdvWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f || mapInfo-&gt;map.voidWater)
+	if ((!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
 	glViewport(0,0,128,128);

Modified: trunk/rts/Rendering/Env/BasicWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BasicWater.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Rendering/Env/BasicWater.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -36,12 +36,13 @@
 
 CBasicWater::~CBasicWater()
 {
-	glDeleteTextures (1, &amp;texture);
+	glDeleteTextures(1, &amp;texture);
+	glDeleteLists(displist,1);
 }
 
 void CBasicWater::Draw()
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f)
+	if (!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	if(displist == 0) {

Modified: trunk/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Rendering/Env/BumpWater.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -643,7 +643,7 @@
 
 void CBumpWater::Update()
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f || mapInfo-&gt;map.voidWater)
+	if ((!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
 	float3 w = wind.GetCurrentWind();
@@ -686,7 +686,7 @@
 
 void CBumpWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f || mapInfo-&gt;map.voidWater)
+	if ((!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
 	if (refraction&gt;1) DrawRefraction(game);
@@ -954,7 +954,7 @@
 
 void CBumpWater::Draw()
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f)
+	if (!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	if (refraction == 1) {

Modified: trunk/rts/Rendering/Env/DynWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/DynWater.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Rendering/Env/DynWater.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -265,7 +265,7 @@
 
 void CDynWater::Draw()
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f)
+	if (!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	glDisable(GL_BLEND);
@@ -355,7 +355,7 @@
 
 void CDynWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f || mapInfo-&gt;map.voidWater)
+	if ((!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
 	glDisable(GL_DEPTH_TEST);
@@ -378,7 +378,7 @@
 
 void CDynWater::Update()
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f)
+	if (!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	oldCamPosBig=camPosBig;

Modified: trunk/rts/Rendering/Env/RefractWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/RefractWater.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Rendering/Env/RefractWater.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -5,6 +5,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;RefractWater.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;bitops.h&quot;
 
@@ -42,7 +43,7 @@
 
 void CRefractWater::Draw()
 {
-	if (readmap-&gt;currMinHeight &gt; 1.0f)
+	if (!mapInfo-&gt;water.alwaysRenderWater &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	glActiveTextureARB(GL_TEXTURE2_ARB);

Modified: trunk/rts/Sim/Features/FeatureDef.h
===================================================================
--- trunk/rts/Sim/Features/FeatureDef.h	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Sim/Features/FeatureDef.h	2008-09-30 10:31:39 UTC (rev 6486)
@@ -20,7 +20,7 @@
 	FeatureDef():
 		metal(0), energy(0), maxHealth(0), reclaimTime(0), mass(0),
 		upright(false), drawType(0), modelType(0),
-		destructable(false), reclaimable(true), blocking(false),
+		resurrectable(false), destructable(false), reclaimable(true), blocking(false),
 		burnable(false), floating(false), noSelect(false), geoThermal(false),
 		xsize(0), ysize(0) {}
 
@@ -46,10 +46,10 @@
 	bool useCSOffset;
 	*/
 
-	std::string collisionVolumeType;	// can be &quot;Ell&quot;, &quot;CylT&quot; (where T is one of &quot;XYZ&quot;), or &quot;Box&quot;
-	float3 collisionVolumeScales;		// the collision volume's full axis lengths
-	float3 collisionVolumeOffsets;		// relative to the feature's center position
-	int collisionVolumeTest;			// 0: discrete, 1: continuous
+	std::string collisionVolumeType;  /// can be &quot;Ell&quot;, &quot;CylT&quot; (where T is one of &quot;XYZ&quot;), or &quot;Box&quot;
+	float3 collisionVolumeScales;     /// the collision volume's full axis lengths
+	float3 collisionVolumeOffsets;    /// relative to the feature's center position
+	int collisionVolumeTest;          /// 0: discrete, 1: continuous
 
 	bool upright;
 	int drawType;
@@ -58,6 +58,11 @@
 	/// used by tree etc
 	int modelType;
 
+	/// -1 := only if it is the 1st wreckage of the unitdef (default), 0 := no it isn't, 1 := yes it is
+	int  resurrectable;
+
+	int smokeTime;
+
 	bool destructable;
 	bool reclaimable;
 	bool blocking;

Modified: trunk/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- trunk/rts/Sim/Features/FeatureHandler.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Sim/Features/FeatureHandler.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -55,12 +55,14 @@
 		//CR_MEMBER(model), FIXME
 		CR_MEMBER(modelname),
 		CR_MEMBER(modelType),
+		CR_MEMBER(resurrectable),
 		CR_MEMBER(destructable),
 		CR_MEMBER(blocking),
 		CR_MEMBER(burnable),
 		CR_MEMBER(floating),
 		CR_MEMBER(geoThermal),
 		CR_MEMBER(deathFeature),
+		CR_MEMBER(smokeTime),
 		CR_MEMBER(xsize),
 		CR_MEMBER(ysize)
 		));
@@ -206,10 +208,11 @@
 
 	fd-&gt;description = fdTable.GetString(&quot;description&quot;, &quot;&quot;);
 
-	fd-&gt;blocking     = fdTable.GetBool(&quot;blocking&quot;,       true);
-	fd-&gt;burnable     = fdTable.GetBool(&quot;flammable&quot;,      false);
-	fd-&gt;destructable = !fdTable.GetBool(&quot;indestructible&quot;, false);
-	fd-&gt;reclaimable  = fdTable.GetBool(&quot;reclaimable&quot;, fd-&gt;destructable);
+	fd-&gt;blocking      =  fdTable.GetBool(&quot;blocking&quot;,       true);
+	fd-&gt;burnable      =  fdTable.GetBool(&quot;flammable&quot;,      false);
+	fd-&gt;destructable  = !fdTable.GetBool(&quot;indestructible&quot;, false);
+	fd-&gt;reclaimable   =  fdTable.GetBool(&quot;reclaimable&quot;,    fd-&gt;destructable);
+	fd-&gt;resurrectable =  fdTable.GetInt(&quot;resurrectable&quot;,   -1);
 
 	//this seem to be the closest thing to floating that ta wreckage contains
 	fd-&gt;floating = fdTable.GetBool(&quot;nodrawundergray&quot;, true);
@@ -226,6 +229,8 @@
 	fd-&gt;maxHealth   = fdTable.GetFloat(&quot;damage&quot;, 0.0f);
 	fd-&gt;reclaimTime = fdTable.GetFloat(&quot;reclaimTime&quot;, (fd-&gt;metal + fd-&gt;energy));
 
+	fd-&gt;smokeTime = fdTable.GetInt(&quot;smokeTime&quot;, 300);
+
 	fd-&gt;drawType = DRAWTYPE_3DO;
 	fd-&gt;modelname = fdTable.GetString(&quot;object&quot;, &quot;&quot;);
 	if (!fd-&gt;modelname.empty()) {
@@ -422,32 +427,34 @@
 	const float3&amp; speed)
 {
 	ASSERT_SYNCED_MODE;
-	if (name.empty()) {
-		return NULL;
-	}
-	const FeatureDef* fd = GetFeatureDef(name);
+	const FeatureDef* fd;
+	const std::string* defname = &name;
 
-	if (!fd) {
+	int i = iter;
+	do {
+		if (name.empty()) return NULL;
+		fd = GetFeatureDef(*defname);
+		if (!fd) return NULL;
+		defname = &amp;(fd-&gt;deathFeature);
+	}while (--i &gt; 0);
+
+	if (luaRules &amp;&amp; !luaRules-&gt;AllowFeatureCreation(fd, team, pos))
 		return NULL;
-	}
 
-	if (iter &gt; 1) {
-		return CreateWreckage(pos, fd-&gt;deathFeature, rot, facing, iter - 1, team, allyteam, emitSmoke, &quot;&quot;, speed);
+	if (!fd-&gt;modelname.empty()) {
+		if (fd-&gt;resurrectable==0 || (iter&gt;1 &amp;&amp; fd-&gt;resurrectable&lt;0))
+			fromUnit = &quot;&quot;;
+
+		CFeature* f = SAFE_NEW CFeature;
+		f-&gt;Initialize(pos, fd, (short int) rot, facing, team, fromUnit, speed);
+
+		// allow area-reclaiming wrecks of all units, including your own (they set allyteam = -1)
+		f-&gt;allyteam = allyteam;
+		if (emitSmoke &amp;&amp; fd-&gt;blocking)
+			f-&gt;emitSmokeTime = fd-&gt;smokeTime;
+
+		return f;
 	}
-	else {
-		if (luaRules &amp;&amp; !luaRules-&gt;AllowFeatureCreation(fd, team, pos)) {
-			return NULL;
-		}
-		if (!fd-&gt;modelname.empty()) {
-			CFeature* f = SAFE_NEW CFeature;
-			f-&gt;Initialize(pos, fd, (short int) rot, facing, team, fromUnit, speed);
-			// allow area-reclaiming wrecks of all units, including your own (they set allyteam = -1)
-			f-&gt;allyteam = allyteam;
-			if (emitSmoke &amp;&amp; f-&gt;blocking)
-				f-&gt;emitSmokeTime = 300;
-			return f;
-		}
-	}
 	return NULL;
 }
 

Modified: trunk/rts/Sim/Projectiles/FlareProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/FlareProjectile.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Sim/Projectiles/FlareProjectile.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -61,7 +61,8 @@
 		speed*=0.95f;
 		speed.y+=mapInfo-&gt;map.gravity*0.3f;
 
-		if(owner &amp;&amp; lastSub&lt;gs-&gt;frameNum-owner-&gt;unitDef-&gt;flareSalvoDelay &amp;&amp; numSub&lt;owner-&gt;unitDef-&gt;flareSalvoSize){
+		//FIXME: just spawn new flares, if new missiles incoming?
+		if(owner &amp;&amp; lastSub&lt;(gs-&gt;frameNum - owner-&gt;unitDef-&gt;flareSalvoDelay) &amp;&amp; numSub&lt;owner-&gt;unitDef-&gt;flareSalvoSize){
 			subPos.push_back(owner-&gt;pos);
 			float3 s=owner-&gt;speed;
 			s+=owner-&gt;rightdir*owner-&gt;unitDef-&gt;flareDropVector.x;
@@ -98,14 +99,14 @@
 	inArray=true;
 	unsigned char col[4];
 	float alpha=std::max(0.0f,1-(gs-&gt;frameNum-activateFrame)*alphaFalloff);
-	col[0]=(unsigned char)alpha*255;
+	col[0]=(unsigned char)(alpha*255);
 	col[1]=(unsigned char)(alpha*0.5f)*255;
 	col[2]=(unsigned char)(alpha*0.2f)*255;
 	col[3]=1;
 
+	float rad=6.0;
 	for(int a=0;a&lt;numSub;++a){
 		float3 interPos=subPos[a]+subSpeed[a]*gu-&gt;timeOffset;
-		float rad=5;
 
 		va-&gt;AddVertexTC(interPos-camera-&gt;right*rad-camera-&gt;up*rad,ph-&gt;flareprojectiletex.xstart,ph-&gt;flareprojectiletex.ystart,col);
 		va-&gt;AddVertexTC(interPos+camera-&gt;right*rad-camera-&gt;up*rad,ph-&gt;flareprojectiletex.xend,ph-&gt;flareprojectiletex.ystart,col);

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -73,10 +73,8 @@
 	if (ttl == 0) {
 		Collision();
 	} else {
-		if (ttl &gt; 0) {
-			if (cegTag.size() &gt; 0) {
-				ceg.Explosion(pos, ttl, areaOfEffect, 0x0, 0.0f, 0x0, speed);
-			}
+		if (cegTag.size() &gt; 0 &amp;&amp; ttl &gt; 0) {
+			ceg.Explosion(pos, ttl, areaOfEffect, 0x0, 0.0f, 0x0, speed);
 		}
 	}
 
@@ -133,16 +131,19 @@
 		col[3] = int(weaponDef-&gt;intensity * 255);
 	}
 
+	const AtlasedTexture* tex = weaponDef-&gt;visuals.texture1;
+	const float  alphaDecay = weaponDef-&gt;visuals.alphaDecay;
+	const float  sizeDecay  = weaponDef-&gt;visuals.sizeDecay;
+	const float  separation = weaponDef-&gt;visuals.separation;
+	const bool   noGap      = weaponDef-&gt;visuals.noGap;
+	const int    stages     = weaponDef-&gt;visuals.stages;
+	const float  invStages  = 1.0f / (float)stages;
+	const float3 interPos   = pos + (speed * gu-&gt;timeOffset);
+
 	float3 dir = speed;
 	dir.Normalize();
+	dir *= separation * 0.6f;
 
-	const float alphaDecay = weaponDef-&gt;visuals.alphaDecay;
-	const float sizeDecay  = weaponDef-&gt;visuals.sizeDecay;
-	const float separation = weaponDef-&gt;visuals.separation;
-	const bool  noGap      = weaponDef-&gt;visuals.noGap;
-	const int   stages     = weaponDef-&gt;visuals.stages;
-	const float invStages  = 1.0f / (float)stages;
-
 	for (int a = 0; a &lt; stages; ++a) {
 		const float aDecay = (stages - (a * alphaDecay)) * invStages;
 		col[0] = int(aDecay * col[0]);
@@ -153,20 +154,12 @@
 		const float  size  = drawRadius * (1.0f - (a * sizeDecay));
 		const float3 up    = camera-&gt;up    * size;
 		const float3 right = camera-&gt;right * size;
+		const float3 interPos2 = interPos - ((noGap)?(dir * size * a):(dir * drawRadius * a));
 
-		float3 interPos = pos + (speed * gu-&gt;timeOffset);
-		if (noGap) {
-			interPos -= (dir * separation * size * 0.6f * a);
-		} else {
-			interPos -= (dir * separation * drawRadius * 0.6f * a);
-		}
-
-		const AtlasedTexture* tex = weaponDef-&gt;visuals.texture1;
-
-		va-&gt;AddVertexTC(interPos - right - up, tex-&gt;xstart, tex-&gt;ystart, col);
-		va-&gt;AddVertexTC(interPos + right - up, tex-&gt;xend,   tex-&gt;ystart, col);
-		va-&gt;AddVertexTC(interPos + right + up, tex-&gt;xend,   tex-&gt;yend,   col);
-		va-&gt;AddVertexTC(interPos - right + up, tex-&gt;xstart, tex-&gt;yend,   col);
+		va-&gt;AddVertexTC(interPos2 - right - up, tex-&gt;xstart, tex-&gt;ystart, col);
+		va-&gt;AddVertexTC(interPos2 + right - up, tex-&gt;xend,   tex-&gt;ystart, col);
+		va-&gt;AddVertexTC(interPos2 + right + up, tex-&gt;xend,   tex-&gt;yend,   col);
+		va-&gt;AddVertexTC(interPos2 - right + up, tex-&gt;xstart, tex-&gt;yend,   col);
 	}
 }
 

Modified: trunk/rts/Sim/Weapons/WeaponDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-09-30 10:31:39 UTC (rev 6486)
@@ -63,15 +63,10 @@
 
 void CWeaponDefHandler::ParseWeapon(const LuaTable&amp; wdTable, WeaponDef&amp; wd)
 {
-	bool ballistic;
 	//bool twophase;
 	bool manualBombSettings; //Allow the user to manually specify the burst and burstrate for his AircraftBomb
-	//bool guided;
-	//bool vlaunch;
 	int color;
 	int color2;
-	//bool tracking;
-	//bool selfprop;
 	//bool turret;
 	//bool smokeTrail;
 	//string modelName;
@@ -96,13 +91,8 @@
 
 	wd.minIntensity = wdTable.GetFloat(&quot;minIntensity&quot;, 0.0f);
 
-	wd.dropped  = wdTable.GetBool(&quot;dropped&quot;, false);
+	wd.dropped  = wdTable.GetBool(&quot;dropped&quot;, false); //FIXME: unused in the engine?
 	manualBombSettings = wdTable.GetBool(&quot;manualBombSettings&quot;, false);
-	ballistic   = wdTable.GetBool(&quot;ballistic&quot;,   false);
-	wd.twophase = wdTable.GetBool(&quot;twoPhase&quot;,    false);
-	wd.guided   = wdTable.GetBool(&quot;guidance&quot;,    false);
-	wd.vlaunch  = wdTable.GetBool(&quot;vlaunch&quot;,     false);
-	wd.selfprop = wdTable.GetBool(&quot;selfprop&quot;,    false);
 	wd.turret   = wdTable.GetBool(&quot;turret&quot;,      false);
 	wd.highTrajectory = wdTable.GetInt(&quot;highTrajectory&quot;, 2);
 	wd.noSelfDamage   = wdTable.GetBool(&quot;noSelfDamage&quot;, false);
@@ -142,10 +132,7 @@
 	wd.visuals.noGap         = wdTable.GetBool(&quot;noGap&quot;,         true);
 	wd.visuals.stages        = wdTable.GetInt(&quot;stages&quot;,         5);
 
-	wd.gravityAffected = false;
-	if (wd.dropped || ballistic) {
-		wd.gravityAffected = true;
-	}
+	wd.gravityAffected = wdTable.GetBool(&quot;gravityAffected&quot;, wd.dropped);
 
 	wd.type = wdTable.GetString(&quot;weaponType&quot;, &quot;Cannon&quot;);
 
@@ -204,8 +191,8 @@
 	
 	wd.damages.impulseFactor = wdTable.GetFloat(&quot;impulseFactor&quot;, 1.0f);
 	wd.damages.impulseBoost  = wdTable.GetFloat(&quot;impulseBoost&quot;,  0.0f);
-	wd.damages.craterMult    = wdTable.GetFloat(&quot;craterMult&quot;,  wd.damages.impulseFactor);
-	wd.damages.craterBoost   = wdTable.GetFloat(&quot;craterBoost&quot;, 0.0f);
+	wd.damages.craterMult    = wdTable.GetFloat(&quot;craterMult&quot;,    wd.damages.impulseFactor);
+	wd.damages.craterBoost   = wdTable.GetFloat(&quot;craterBoost&quot;,   0.0f);
 
 	wd.areaOfEffect = wdTable.GetFloat(&quot;areaOfEffect&quot;, 8.0f) * 0.5f;
 	wd.edgeEffectiveness = wdTable.GetFloat(&quot;edgeEffectiveness&quot;, 0.0f);
@@ -295,9 +282,9 @@
 		wd.shieldRechargeDelay    = (int)(wdTable.GetFloat(&quot;shieldRechargeDelay&quot;, 0) * GAME_SPEED);
 		wd.shieldStartingPower    = wdTable.GetFloat(&quot;shieldStartingPower&quot;,    0.0f);
 		wd.shieldInterceptType    = wdTable.GetInt(&quot;shieldInterceptType&quot;, 0);
-		wd.shieldBadColor  = wdTable.GetFloat3(&quot;shieldBadColor&quot;,  shieldBadColor);
-		wd.shieldGoodColor = wdTable.GetFloat3(&quot;shieldGoodColor&quot;, shieldGoodColor);
-		wd.shieldAlpha = wdTable.GetFloat(&quot;shieldAlpha&quot;, 0.2f);
+		wd.shieldBadColor         = wdTable.GetFloat3(&quot;shieldBadColor&quot;,  shieldBadColor);
+		wd.shieldGoodColor        = wdTable.GetFloat3(&quot;shieldGoodColor&quot;, shieldGoodColor);
+		wd.shieldAlpha            = wdTable.GetFloat(&quot;shieldAlpha&quot;, 0.2f);
 	}
 
 

Modified: trunk/rts/Sim/Weapons/WeaponDefHandler.h
===================================================================
--- trunk/rts/Sim/Weapons/WeaponDefHandler.h	2008-09-29 18:16:57 UTC (rev 6485)
+++ trunk/rts/Sim/Weapons/WeaponDefHandler.h	2008-09-30 10:31:39 UTC (rev 6486)
@@ -37,20 +37,20 @@
 	std::string type;
 	std::string description;
 	std::string filename;
-	std::string cegTag;						// tag of CEG that projectiles fired by this weapon should use
+	std::string cegTag;        // tag of CEG that projectiles fired by this weapon should use
 
 	GuiSoundSet firesound;
 	GuiSoundSet soundhit;
 
 	float range;
 	float heightmod;
-	float accuracy;							// inaccuracy of whole burst
-	float sprayAngle;						// inaccuracy of individual shots inside burst
-	float movingAccuracy;					// inaccuracy while owner moving
-	float targetMoveError;					// fraction of targets move speed that is used as error offset
-	float leadLimit;                        // maximum distance the weapon will lead the target
-	float leadBonus;                        // factor for increasing the leadLimit with experience
-	float predictBoost;                     // replaces hardcoded behaviour for burnblow cannons
+	float accuracy;            // inaccuracy of whole burst
+	float sprayAngle;          // inaccuracy of individual shots inside burst
+	float movingAccuracy;      // inaccuracy while owner moving
+	float targetMoveError;     // fraction of targets move speed that is used as error offset
+	float leadLimit;           // maximum distance the weapon will lead the target
+	float leadBonus;           // factor for increasing the leadLimit with experience
+	float predictBoost;        // replaces hardcoded behaviour for burnblow cannons
 
 	DamageArray damages;
 	float areaOfEffect;
@@ -93,20 +93,20 @@
 	bool fixedLauncher;
 	bool waterweapon;
 	bool fireSubmersed;
-	bool submissile;							// Lets a torpedo travel above water like it does below water
+	bool submissile;            // Lets a torpedo travel above water like it does below water
 	bool tracks;
 	bool dropped;
-	bool paralyzer;								// weapon will only paralyze not do real damage
-	bool impactOnly;                             // The weapon damages by impacting, not by exploding
+	bool paralyzer;             // weapon will only paralyze not do real damage
+	bool impactOnly;            // The weapon damages by impacting, not by exploding
 
-	bool noAutoTarget;							// cant target stuff (for antinuke,dgun)
-	bool manualfire;							// use dgun button
-	int interceptor;							// anti nuke
-	int targetable;								// nuke (can be shot by interceptor)
+	bool noAutoTarget;          // cant target stuff (for antinuke,dgun)
+	bool manualfire;            // use dgun button
+	int interceptor;            // anti nuke
+	int targetable;             // nuke (can be shot by interceptor)
 	bool stockpile;
-	float coverageRange;						// range of anti nuke
+	float coverageRange;        // range of anti nuke
 
-	float stockpileTime;						// builtime of a missile
+	float stockpileTime;        // builtime of a missile
 
 	float intensity;
 	float thickness;
@@ -121,12 +121,8 @@
 
 	bool selfExplode;
 	bool gravityAffected;
-	int highTrajectory;                         //Per-weapon high traj setting, 0=low, 1=high, 2=unit
+	int highTrajectory;         //Per-weapon high traj setting, 0=low, 1=high, 2=unit
 	float myGravity;
-	bool twophase;
-	bool guided;
-	bool vlaunch;
-	bool selfprop;
 	bool noExplode;
 	float startvelocity;
 	float weaponacceleration;
@@ -153,7 +149,7 @@
 
 		bool smokeTrail;
 		bool beamweapon;
-		bool hardStop;   //whether the shot should fade out or stop and contract at max range
+		bool hardStop;   // whether the shot should fade out or stop and contract at max range
 
 		AtlasedTexture *texture1;
 		AtlasedTexture *texture2;
@@ -177,43 +173,43 @@
 
 	bool largeBeamLaser;
 
-	bool isShield;								// if the weapon is a shield rather than a weapon
-	bool shieldRepulser;						// if the weapon should be repulsed or absorbed
-	bool smartShield;							// only affect enemy projectiles
-	bool exteriorShield;						// only affect stuff coming from outside shield radius
-	bool visibleShield;							// if the shield should be graphically shown
-	bool visibleShieldRepulse;					// if a small graphic should be shown at each repulse
-	int  visibleShieldHitFrames;				// number of frames to draw the shield after it has been hit
-	float shieldEnergyUse;						// energy use per shot or per second depending on projectile
-	float shieldRadius;							// size of shielded area
-	float shieldForce;							// shield acceleration on plasma stuff
-	float shieldMaxSpeed;						// max speed shield can repulse plasma like weapons with
-	float shieldPower;							// how much damage the shield can reflect (0=infinite)
-	float shieldPowerRegen;						// how fast the power regenerates per second
-	float shieldPowerRegenEnergy;				// how much energy is needed to regenerate power per second
-	float shieldStartingPower;					// how much power the shield has when first created
-	int   shieldRechargeDelay;					// number of frames to delay recharging by after each hit
-	float3 shieldGoodColor;						// color when shield at full power
-	float3 shieldBadColor;						// color when shield is empty
-	float shieldAlpha;							// shield alpha value
+	bool isShield;                   // if the weapon is a shield rather than a weapon
+	bool shieldRepulser;             // if the weapon should be repulsed or absorbed
+	bool smartShield;                // only affect enemy projectiles
+	bool exteriorShield;             // only affect stuff coming from outside shield radius
+	bool visibleShield;              // if the shield should be graphically shown
+	bool visibleShieldRepulse;       // if a small graphic should be shown at each repulse
+	int  visibleShieldHitFrames;     // number of frames to draw the shield after it has been hit
+	float shieldEnergyUse;           // energy use per shot or per second depending on projectile
+	float shieldRadius;              // size of shielded area
+	float shieldForce;               // shield acceleration on plasma stuff
+	float shieldMaxSpeed;            // max speed shield can repulse plasma like weapons with
+	float shieldPower;               // how much damage the shield can reflect (0=infinite)
+	float shieldPowerRegen;          // how fast the power regenerates per second
+	float shieldPowerRegenEnergy;    // how much energy is needed to regenerate power per second
+	float shieldStartingPower;       // how much power the shield has when first created
+	int   shieldRechargeDelay;       // number of frames to delay recharging by after each hit
+	float3 shieldGoodColor;          // color when shield at full power
+	float3 shieldBadColor;           // color when shield is empty
+	float shieldAlpha;               // shield alpha value
 
-	unsigned int shieldInterceptType;			// type of shield (bitfield)
-	unsigned int interceptedByShieldType;		// weapon can be affected by shields where (shieldInterceptType &amp; interceptedByShieldType) is not zero
+	unsigned int shieldInterceptType;      // type of shield (bitfield)
+	unsigned int interceptedByShieldType;  // weapon can be affected by shields where (shieldInterceptType &amp; interceptedByShieldType) is not zero
 
-	bool avoidFriendly;							// if true, try to avoid friendly units while aiming
-	bool avoidFeature;							// if true, try to avoid features while aiming
-	bool avoidNeutral;							// if true, try to avoid neutral units while aiming
+	bool avoidFriendly;     // if true, try to avoid friendly units while aiming
+	bool avoidFeature;      // if true, try to avoid features while aiming
+	bool avoidNeutral;      // if true, try to avoid neutral units while aiming
 
-	float targetBorder;							// if nonzero, targetting units will TryTarget at the edge of collision sphere (radius*tag value, [-1;1]) instead of its centre
-	float cylinderTargetting;					// if greater than 0, range will be checked in a cylinder (height=range*cylinderTargetting) instead of a sphere
-	float minIntensity;							// for beamlasers - always hit with some minimum intensity (a damage coeffcient normally dependent on distance). do not confuse with intensity tag, it's completely unrelated.
-	float heightBoostFactor;					// controls cannon range height boost. default: -1 -- automatically calculate a more or less sane value
-	float proximityPriority;					// multiplier for the distance to the target for priority calculations
+	float targetBorder;          // if nonzero, targetting units will TryTarget at the edge of collision sphere (radius*tag value, [-1;1]) instead of its centre
+	float cylinderTargetting;    // if greater than 0, range will be checked in a cylinder (height=range*cylinderTargetting) instead of a sphere
+	float minIntensity;          // for beamlasers - always hit with some minimum intensity (a damage coeffcient normally dependent on distance). do not confuse with intensity tag, it's completely unrelated.
+	float heightBoostFactor;     // controls cannon range height boost. default: -1 -- automatically calculate a more or less sane value
+	float proximityPriority;     // multiplier for the distance to the target for priority calculations
 
 	unsigned int collisionFlags;
 
-	CExplosionGenerator* explosionGenerator;	// can be zero for default explosions
-	CExplosionGenerator* bounceExplosionGenerator; //called when a projectile bounces
+	CExplosionGenerator* explosionGenerator;        // can be zero for default explosions
+	CExplosionGenerator* bounceExplosionGenerator;  // called when a projectile bounces
 
 	bool sweepFire;
 	bool canAttackGround;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001255.html">[Taspring-linux-commit] r6485 - trunk/installer/sections
</A></li>
	<LI>Next message: <A HREF="001257.html">[Taspring-linux-commit] r6487 - in trunk/rts: Map Rendering/Env
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1256">[ date ]</a>
              <a href="thread.html#1256">[ thread ]</a>
              <a href="subject.html#1256">[ subject ]</a>
              <a href="author.html#1256">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
