<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6356 - in branches/0.77-branch:	Lobby/TASClient Lobby/TASClient/Python/scripts/subf rts/Game	tools/ArchiveMoverLinux tools/ArchiveMoverLinux/libmlsevenzip	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6356%20-%20in%20branches/0.77-branch%3A%0A%09Lobby/TASClient%20Lobby/TASClient/Python/scripts/subf%20rts/Game%0A%09tools/ArchiveMoverLinux%20tools/ArchiveMoverLinux/libmlsevenzip%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil&In-Reply-To=%3C20080904081250.F103F48A4%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001125.html">
   <LINK REL="Next"  HREF="001127.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6356 - in branches/0.77-branch:	Lobby/TASClient Lobby/TASClient/Python/scripts/subf rts/Game	tools/ArchiveMoverLinux tools/ArchiveMoverLinux/libmlsevenzip	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6356%20-%20in%20branches/0.77-branch%3A%0A%09Lobby/TASClient%20Lobby/TASClient/Python/scripts/subf%20rts/Game%0A%09tools/ArchiveMoverLinux%20tools/ArchiveMoverLinux/libmlsevenzip%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib%0A%09tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil&In-Reply-To=%3C20080904081250.F103F48A4%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6356 - in branches/0.77-branch:	Lobby/TASClient Lobby/TASClient/Python/scripts/subf rts/Game	tools/ArchiveMoverLinux tools/ArchiveMoverLinux/libmlsevenzip	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib	tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Sep  4 10:12:50 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001125.html">[Taspring-linux-commit] r6355 - trunk/Lobby/TASClient
</A></li>
        <LI>Next message: <A HREF="001127.html">[Taspring-linux-commit] r6357 - in trunk/rts: Rendering/Env Sim/Path
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1126">[ date ]</a>
              <a href="thread.html#1126">[ thread ]</a>
              <a href="subject.html#1126">[ subject ]</a>
              <a href="author.html#1126">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: Auswaschbar
Date: 2008-09-04 10:12:47 +0200 (Thu, 04 Sep 2008)
New Revision: 6356

Added:
   branches/0.77-branch/Lobby/TASClient/MapSelectionFormUnit.dfm
   branches/0.77-branch/Lobby/TASClient/MapSelectionFormUnit.pas
   branches/0.77-branch/Lobby/TASClient/Python/scripts/subf/windowedTASClient.py
   branches/0.77-branch/tools/ArchiveMoverLinux/archive.ml
   branches/0.77-branch/tools/ArchiveMoverLinux/datadir.ml
   branches/0.77-branch/tools/ArchiveMoverLinux/fileSystem.ml
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/Makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml
   branches/0.77-branch/tools/ArchiveMoverLinux/sd7.ml
   branches/0.77-branch/tools/ArchiveMoverLinux/sdz.ml
Removed:
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/Makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c
   branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml
Modified:
   branches/0.77-branch/Lobby/TASClient/BattleFormUnit.dfm
   branches/0.77-branch/Lobby/TASClient/BattleFormUnit.pas
   branches/0.77-branch/Lobby/TASClient/LobbyScriptUnit.pas
   branches/0.77-branch/Lobby/TASClient/MainUnit.dfm
   branches/0.77-branch/Lobby/TASClient/MainUnit.pas
   branches/0.77-branch/Lobby/TASClient/MapListFormUnit.pas
   branches/0.77-branch/Lobby/TASClient/TASClient.dof
   branches/0.77-branch/Lobby/TASClient/TASClient.dpr
   branches/0.77-branch/Lobby/TASClient/TASClient.res
   branches/0.77-branch/rts/Game/GameServer.cpp
   branches/0.77-branch/tools/ArchiveMoverLinux/Makefile
   branches/0.77-branch/tools/ArchiveMoverLinux/mover.ml
Log:
* update 0.77-branch


Modified: branches/0.77-branch/Lobby/TASClient/BattleFormUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/BattleFormUnit.dfm	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/Lobby/TASClient/BattleFormUnit.dfm	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,7 +1,7 @@
 object BattleForm: TBattleForm
-  Left = 168
-  Top = 122
-  Width = 787
+  Left = 684
+  Top = 169
+  Width = 783
   Height = 586
   Caption = 'Battle window'
   Color = clBtnFace
@@ -24,13 +24,13 @@
   object SpTBXTitleBar1: TSpTBXTitleBar
     Left = 0
     Top = 0
-    Width = 779
+    Width = 775
     Height = 559
     Caption = 'Battle window'
     object Splitter1: TSplitter
       Left = 4
       Top = 413
-      Width = 771
+      Width = 767
       Height = 3
       Cursor = crVSplit
       Align = alTop
@@ -40,7 +40,7 @@
     object Splitter2: TSplitter
       Left = 4
       Top = 305
-      Width = 771
+      Width = 767
       Height = 3
       Cursor = crVSplit
       Align = alTop
@@ -50,7 +50,7 @@
     object Panel3: TSpTBXPanel
       Left = 4
       Top = 514
-      Width = 771
+      Width = 767
       Height = 41
       Align = alBottom
       Color = clNone
@@ -59,7 +59,7 @@
       BorderType = pbrRaised
       TBXStyleBackground = True
       DesignSize = (
-        771
+        767
         41)
       object StartButton: TSpTBXButton
         Left = 104
@@ -153,7 +153,7 @@
         LinkFont.Style = [fsUnderline]
       end
       object LadderRulesButton: TSpTBXButton
-        Left = 685
+        Left = 681
         Top = 8
         Width = 75
         Height = 25
@@ -188,7 +188,7 @@
     object Panel2: TPanel
       Left = 4
       Top = 416
-      Width = 771
+      Width = 767
       Height = 98
       Align = alClient
       TabOrder = 2
@@ -4064,12 +4064,12 @@
     object Panel1: TPanel
       Left = 4
       Top = 30
-      Width = 771
+      Width = 767
       Height = 275
       Align = alTop
       TabOrder = 3
       object Panel5: TPanel
-        Left = 351
+        Left = 347
         Top = 1
         Width = 419
         Height = 273
@@ -4083,14 +4083,13 @@
           Height = 273
           Align = alClient
           Color = clBtnFace
-          ActiveTabIndex = 0
+          ActiveTabIndex = 2
           TabAutofit = True
           ThemeType = tttNone
           OnActiveTabChange = SpTBXTabControl1ActiveTabChange
           HiddenItems = &lt;&gt;
           object GameOptionsTab: TSpTBXTabItem
             Caption = 'Game options'
-            Checked = True
             CustomWidth = 103
             CustomHeight = 30
             ThemeType = tttNone
@@ -4104,6 +4103,7 @@
           object MapTab: TSpTBXTabItem
             Caption = 'Map options'
             Wrapping = twWrap
+            Checked = True
             CustomWidth = 103
             ThemeType = tttNone
           end
@@ -4113,86 +4113,6 @@
             CustomWidth = 103
             ThemeType = tttNone
           end
-          object MapTabSheet: TSpTBXTabSheet
-            Left = 0
-            Top = 34
-            Width = 419
-            Height = 239
-            Caption = 'Map options'
-            ImageIndex = -1
-            DesignSize = (
-              419
-              239)
-            TabItem = 'MapTab'
-            object MapOptionsScrollBox: TTntScrollBox
-              Left = 8
-              Top = 48
-              Width = 402
-              Height = 189
-              VertScrollBar.Smooth = True
-              VertScrollBar.Tracking = True
-              Anchors = [akLeft, akTop, akRight, akBottom]
-              BiDiMode = bdLeftToRight
-              BorderStyle = bsNone
-              Color = clBtnFace
-              Ctl3D = False
-              ParentBiDiMode = False
-              ParentBackground = True
-              ParentColor = False
-              ParentCtl3D = False
-              TabOrder = 0
-            end
-            object panelMapOptionsDefault: TSpTBXPanel
-              Left = 8
-              Top = 4
-              Width = 402
-              Height = 41
-              Align = alCustom
-              TabOrder = 1
-              object btLoadDefaultMPO: TSpTBXButton
-                Left = 149
-                Top = 8
-                Width = 113
-                Height = 25
-                Caption = 'Load default'
-                TabOrder = 0
-                OnClick = btLoadDefaultMPOClick
-                LinkFont.Charset = DEFAULT_CHARSET
-                LinkFont.Color = clBlue
-                LinkFont.Height = -11
-                LinkFont.Name = 'MS Sans Serif'
-                LinkFont.Style = [fsUnderline]
-              end
-              object btSetAsDefaultMPO: TSpTBXButton
-                Left = 269
-                Top = 8
-                Width = 113
-                Height = 25
-                Caption = 'Set as default'
-                TabOrder = 1
-                OnClick = btSetAsDefaultMPOClick
-                LinkFont.Charset = DEFAULT_CHARSET
-                LinkFont.Color = clBlue
-                LinkFont.Height = -11
-                LinkFont.Name = 'MS Sans Serif'
-                LinkFont.Style = [fsUnderline]
-              end
-              object btLoadMapsDefaultMPO: TSpTBXButton
-                Left = 29
-                Top = 8
-                Width = 113
-                Height = 25
-                Caption = 'Load map'#39's default'
-                TabOrder = 2
-                OnClick = btLoadMapsDefaultMPOClick
-                LinkFont.Charset = DEFAULT_CHARSET
-                LinkFont.Color = clBlue
-                LinkFont.Height = -11
-                LinkFont.Name = 'MS Sans Serif'
-                LinkFont.Style = [fsUnderline]
-              end
-            end
-          end
           object SpTBXTabSheet1: TSpTBXTabSheet
             Left = 0
             Top = 34
@@ -4612,12 +4532,92 @@
               LinkFont.Style = [fsUnderline]
             end
           end
+          object MapTabSheet: TSpTBXTabSheet
+            Left = 0
+            Top = 34
+            Width = 419
+            Height = 239
+            Caption = 'Map options'
+            ImageIndex = -1
+            DesignSize = (
+              419
+              239)
+            TabItem = 'MapTab'
+            object MapOptionsScrollBox: TTntScrollBox
+              Left = 8
+              Top = 48
+              Width = 402
+              Height = 189
+              VertScrollBar.Smooth = True
+              VertScrollBar.Tracking = True
+              Anchors = [akLeft, akTop, akRight, akBottom]
+              BiDiMode = bdLeftToRight
+              BorderStyle = bsNone
+              Color = clBtnFace
+              Ctl3D = False
+              ParentBiDiMode = False
+              ParentBackground = True
+              ParentColor = False
+              ParentCtl3D = False
+              TabOrder = 0
+            end
+            object panelMapOptionsDefault: TSpTBXPanel
+              Left = 8
+              Top = 4
+              Width = 402
+              Height = 41
+              Align = alCustom
+              TabOrder = 1
+              object btLoadDefaultMPO: TSpTBXButton
+                Left = 149
+                Top = 8
+                Width = 113
+                Height = 25
+                Caption = 'Load default'
+                TabOrder = 0
+                OnClick = btLoadDefaultMPOClick
+                LinkFont.Charset = DEFAULT_CHARSET
+                LinkFont.Color = clBlue
+                LinkFont.Height = -11
+                LinkFont.Name = 'MS Sans Serif'
+                LinkFont.Style = [fsUnderline]
+              end
+              object btSetAsDefaultMPO: TSpTBXButton
+                Left = 269
+                Top = 8
+                Width = 113
+                Height = 25
+                Caption = 'Set as default'
+                TabOrder = 1
+                OnClick = btSetAsDefaultMPOClick
+                LinkFont.Charset = DEFAULT_CHARSET
+                LinkFont.Color = clBlue
+                LinkFont.Height = -11
+                LinkFont.Name = 'MS Sans Serif'
+                LinkFont.Style = [fsUnderline]
+              end
+              object btLoadMapsDefaultMPO: TSpTBXButton
+                Left = 29
+                Top = 8
+                Width = 113
+                Height = 25
+                Caption = 'Load map'#39's default'
+                TabOrder = 2
+                OnClick = btLoadMapsDefaultMPOClick
+                LinkFont.Charset = DEFAULT_CHARSET
+                LinkFont.Color = clBlue
+                LinkFont.Height = -11
+                LinkFont.Name = 'MS Sans Serif'
+                LinkFont.Style = [fsUnderline]
+              end
+            end
+          end
         end
       end
       object Panel6: TPanel
         Left = 1
         Top = 1
-        Width = 350
+        Width = 346
         Height = 273
         Align = alClient
         BevelOuter = bvNone
@@ -4626,7 +4626,7 @@
         object MapPanel: TSpTBXPanel
           Left = 0
           Top = 0
-          Width = 350
+          Width = 346
           Height = 273
           Align = alClient
           Color = clNone
@@ -4636,12 +4636,12 @@
           OnResize = MapPanelResize
           TBXStyleBackground = True
           DesignSize = (
-            350
+            346
             273)
           object Bevel2: TBevel
             Left = 0
             Top = 219
-            Width = 350
+            Width = 346
             Height = 46
             Anchors = [akLeft, akRight, akBottom]
             Shape = bsTopLine
@@ -4649,7 +4649,7 @@
           object MapImage: TImageEx
             Left = 5
             Top = 5
-            Width = 221
+            Width = 217
             Height = 216
             Cursor = crHandPoint
             Hint = 'No map'
@@ -4665,7 +4665,7 @@
           object MapDescLabel: TSpTBXLabel
             Left = 8
             Top = 224
-            Width = 334
+            Width = 330
             Height = 41
             Caption = 'MapDescLabel'
             Anchors = [akLeft, akRight, akBottom]
@@ -4681,7 +4681,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object TidalStrengthLabel: TSpTBXLabel
-            Left = 237
+            Left = 233
             Top = 143
             Width = 76
             Height = 13
@@ -4694,7 +4694,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object GravityLabel: TSpTBXLabel
-            Left = 237
+            Left = 233
             Top = 158
             Width = 45
             Height = 13
@@ -4707,7 +4707,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object MaxMetalLabel: TSpTBXLabel
-            Left = 237
+            Left = 233
             Top = 173
             Width = 63
             Height = 13
@@ -4720,7 +4720,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object ExtRadiusLabel: TSpTBXLabel
-            Left = 237
+            Left = 233
             Top = 188
             Width = 85
             Height = 13
@@ -4733,7 +4733,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object WindLabel: TSpTBXLabel
-            Left = 237
+            Left = 233
             Top = 203
             Width = 86
             Height = 13
@@ -4746,7 +4746,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object SpTBXPanel1: TSpTBXPanel
-            Left = 229
+            Left = 225
             Top = 4
             Width = 113
             Height = 122
@@ -4766,12 +4766,11 @@
             object MapsButton: TTBXButton
               Left = 8
               Top = 7
-              Width = 97
+              Width = 81
               Height = 17
               BorderSize = 2
               Caption = 'More maps ...'
-              DropDownCombo = True
-              DropDownMenu = MapsPopupMenu
+              SmartFocus = False
               TabOrder = 0
               OnClick = MapsButtonClick
             end
@@ -4815,9 +4814,22 @@
               TabOrder = 4
               OnClick = DownloadMapButtonClick
             end
+            object DropDownMapSelectionButton: TSpTBXButton
+              Left = 88
+              Top = 7
+              Width = 17
+              Height = 17
+              TabOrder = 5
+              DropDownMenu = MapsPopupMenu
+              LinkFont.Charset = DEFAULT_CHARSET
+              LinkFont.Color = clBlue
+              LinkFont.Height = -11
+              LinkFont.Name = 'MS Sans Serif'
+              LinkFont.Style = [fsUnderline]
+            end
           end
           object MapSizeLabel: TSpTBXLabel
-            Left = 237
+            Left = 233
             Top = 128
             Width = 54
             Height = 13
@@ -4835,17 +4847,17 @@
     object Panel4: TPanel
       Left = 4
       Top = 308
-      Width = 771
+      Width = 767
       Height = 105
       Align = alTop
       TabOrder = 4
       DesignSize = (
-        771
+        767
         105)
       object VDTBattleClients: TVirtualDrawTree
         Left = 8
         Top = 8
-        Width = 461
+        Width = 457
         Height = 89
         Anchors = [akLeft, akTop, akRight, akBottom]
         Font.Charset = DEFAULT_CHARSET
@@ -4932,7 +4944,7 @@
           end&gt;
       end
       object MyOptionsGroupBox: TSpTBXGroupBox
-        Left = 521
+        Left = 517
         Top = 5
         Width = 242
         Height = 92
@@ -5044,7 +5056,7 @@
         end
       end
       object lblTeamNbr: TSpTBXLabel
-        Left = 474
+        Left = 470
         Top = 8
         Width = 44
         Height = 13
@@ -5210,14 +5222,6 @@
     object SpTBXSeparatorItem9: TSpTBXSeparatorItem
     end
   end
-  object MapsPopupMenu: TSpTBXPopupMenu
-    Left = 184
-    Top = 48
-    object MapsPopupStringList: TSpTBXStringList
-      MaxVisibleItems = 20
-      OnClick = MapsPopupMenuItemClick
-    end
-  end
   object BalanceTeamsPopupMenu: TSpTBXPopupMenu
     Left = 492
     Top = 425
@@ -5391,4 +5395,12 @@
     object SpTBXSeparatorItem12: TSpTBXSeparatorItem
     end
   end
+  object MapsPopupMenu: TSpTBXFormPopupMenu
+    TrackButton = tbLeftButton
+    OnPopup = MapsPopupMenuPopup
+    BorderStyle = pbsSizeableRightBottom
+    PopupFocus = True
+    Left = 189
+    Top = 40
+  end
 end

Modified: branches/0.77-branch/Lobby/TASClient/BattleFormUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/BattleFormUnit.pas	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/Lobby/TASClient/BattleFormUnit.pas	2008-09-04 08:12:47 UTC (rev 6356)
@@ -21,11 +21,11 @@
   JvTransparentButton, JvgSpeedButton, JvgShadow, JvgButton, JvExStdCtrls,
   JvXPCore, JvXPButtons, TBXToolPals, TB2Item, TBX, SpTBXItem, TBXDkPanels,
   SpTBXControls, TBXExtItems, TB2ExtItems, SpTBXEditors, SpTBXTabs, JvLED,
-  ImageEx, JvSticker, JvExExtCtrls, JvImage, JvShape, JvLabel, TBXLists,
+  ImageEx, JvSticker, JvExExtCtrls, JvImage, JvShape, JvLabel,
   SpTBXLists, ImgList, SpTBXjanTracker, SpTBXFormPopupMenu,IniFiles,
   HttpProt,MsMultiPartFormData, JvComponentBase, JvDSADialogs, Spin, Mask,
   JvExMask, JvSpin, TntStdCtrls, TntForms, TntComCtrls,RichEdit,JclUnicode,
-  RichEdit2, ExRichEdit, class_TIntegerList;
+  RichEdit2, ExRichEdit, class_TIntegerList, TBXLists;
 
 type
 
@@ -179,8 +179,6 @@
     SpTBXSeparatorItem1: TSpTBXSeparatorItem;
     SpTBXSeparatorItem2: TSpTBXSeparatorItem;
     SpTBXItem7: TSpTBXItem;
-    MapsPopupMenu: TSpTBXPopupMenu;
-    MapsPopupStringList: TSpTBXStringList;
     ForceSpectatorModeItem: TSpTBXItem;
     SpTBXTitleBar1: TSpTBXTitleBar;
     Panel3: TSpTBXPanel;
@@ -311,6 +309,8 @@
     SpTBXSeparatorItem11: TSpTBXSeparatorItem;
     SpTBXSeparatorItem12: TSpTBXSeparatorItem;
     DownloadMapButton: TTBXButton;
+    MapsPopupMenu: TSpTBXFormPopupMenu;
+    DropDownMapSelectionButton: TSpTBXButton;
 
     procedure CreateParams(var Params: TCreateParams); override;
 
@@ -340,7 +340,8 @@
     procedure ChangeMapToFirstOne;
     procedure ChangeMap(MapIndex: Integer); // 'MapIndex' refers to index in Utility.MapList
     procedure CheckMapSync;
-    procedure PopulatePopupMenuMapList; // will populate 'MapsPopupMenu' with map names
+    procedure PopulatePopupMenuMapList;
+    procedure PopulatePopupMenuMapListF(filter: string = ''); // will populate 'MapsPopupMenu' with map names
     procedure MapsPopupMenuItemClick(Sender: TObject);
 
     procedure OnStartGameMessage(var Msg: TMessage); message WM_STARTGAME;
@@ -516,10 +517,12 @@
     procedure VDTDisabledUnitsDrawNode(Sender: TBaseVirtualTree;
       const PaintInfo: TVTPaintInfo);
     procedure ChatExRichEditDblClick(Sender: TObject);
-    procedure Button1Click(Sender: TObject);
     procedure ChatRichEditMouseDown(Sender: TObject; Button: TMouseButton;
       Shift: TShiftState; X, Y: Integer);
     procedure DownloadMapButtonClick(Sender: TObject);
+    procedure MapListFilterTextBoxChange(Sender: TObject;
+      const Text: WideString);
+    procedure MapsPopupMenuPopup(Sender: TObject);
   private
     History: TWideStringList;
     HistoryIndex: Integer;
@@ -668,7 +671,8 @@
   InitWaitFormUnit, AddBotUnit, Math, OnlineMapsUnit, ReplaysUnit, StrUtils,
   CustomColorUnit, StringParser, MapListFormUnit, AutoTeamsUnit,
   AutoStartRectsUnit, ColorPicker, UploadReplayUnit, ProgressBarWindow,
-  TntWideStrings, LobbyScriptUnit, SpringDownloaderFormUnit;
+  TntWideStrings, LobbyScriptUnit, SpringDownloaderFormUnit,
+  MapSelectionFormUnit;
 
 {$R *.dfm}
 
@@ -1104,7 +1108,7 @@
   MapDescLabel.Hint := MapDescLabel.Caption;
 
   FCurrentMapIndex := -1;
-  MapsPopupStringList.ItemIndex := -1;
+  MapSelectionForm.MapListBox.ItemIndex := -1;
 
   MapImage.Hint := 'No map';
 
@@ -1131,7 +1135,7 @@
 
 procedure TBattleForm.ChangeMapToFirstOne;
 begin
-  ChangeMap(Utility.MapList.IndexOf(MapsPopupStringList.Strings.Strings[0]));
+  ChangeMap(Utility.MapList.IndexOf(MapSelectionForm.MapListBox.Items.Strings[0]));
 end;
 
 procedure TBattleForm.ChangeMap(MapIndex: Integer);
@@ -1180,7 +1184,7 @@
   Preferences.LastOpenMap := GetMapItem(MapIndex).MapName;
 
   FCurrentMapIndex := MapIndex;
-  MapsPopupStringList.ItemIndex := MapIndex;
+  MapSelectionForm.MapListBox.ItemIndex := MapIndex;
 
   MapImage.Hint := GetMapItem(MapIndex).MapName;
 
@@ -1200,51 +1204,46 @@
 end;
 
 procedure TBattleForm.PopulatePopupMenuMapList;
+begin
+  PopulatePopupMenuMapListF(MapSelectionForm.FilterTextBox.Text);
+end;
+
+procedure TBattleForm.PopulatePopupMenuMapListF(filter: string = '');
 var
   i: Integer;
   validMaps: TStringList;
 begin
-  MapsPopupStringList.Strings.Clear;
-  if not BattleForm.IsBattleActive then
-  begin
-    MapsPopupStringList.Strings.Assign(Utility.MapList);
-    Exit;
-  end;
+  MapSelectionForm.MapListBox.Items.BeginUpdate;
+  MapSelectionForm.MapListBox.Items.Clear;
 
-  if BattleState.LadderIndex &gt; -1 then
-  begin
-    for i:=0 to Utility.MapList.Count-1 do
-      if (TLadder(LadderList[BattleState.LadderIndex]).Maps.IndexOf(Utility.MapList[i]) &gt;= 0) and ((Utility.ModValidMaps.Count =0) or (Utility.ModValidMaps.IndexOf(Utility.MapList[i]) &gt;= 0)) then
-        MapsPopupStringList.Strings.Add(Utility.MapList[i]);
-  end
-  else
-  begin
-    if Utility.ModValidMaps.Count = 0 then
-      MapsPopupStringList.Strings.Assign(Utility.MapList)
-    else
-      for i:=0 to validMaps.Count-1 do
-        if Utility.MapList.IndexOf(Utility.ModValidMaps[i]) &gt;= 0 then
-          MapsPopupStringList.Strings.Add(Utility.ModValidMaps[i]);
-  end;
+  for i:=0 to Utility.MapList.Count-1 do
+    if (
+      ((filter = '') or (Pos(LowerCase(filter),LowerCase(Utility.MapList[i])) &gt; 0)) and // filter
+      ((Utility.ModValidMaps = nil) or (Utility.ModValidMaps.Count = 0) or (Utility.MapList.IndexOf(Utility.ModValidMaps[i]) &gt;= 0)) and // valid maps
+      ((BattleState.LadderIndex = -1) or (TLadder(LadderList[BattleState.LadderIndex]).Maps.IndexOf(Utility.MapList[i]) &gt;= 0)) // ladder maps
+    ) then
+      MapSelectionForm.MapListBox.Items.Add(Utility.MapList[i]);
+  MapSelectionForm.MapListBox.Items.EndUpdate;
 end;
 
 procedure TBattleForm.MapsPopupMenuItemClick(Sender: TObject);
 var
   index : integer;
 begin
-  index :=  Utility.MapList.IndexOf(MapsPopupStringList.Strings.Strings[MapsPopupStringList.ItemIndex]);
+  if MapSelectionForm.MapListBox.ItemIndex = -1 then Exit;
+  index :=  Utility.MapList.IndexOf(MapSelectionForm.MapListBox.Items.Strings[MapSelectionForm.MapListBox.ItemIndex]);
   if IsBattleActive and (BattleState.Status = Joined) then
   begin
     //*** MessageDlg('Only battle host is able to change map!', mtWarning, [mbOK], 0);
     MainForm.TryToSendCommand('SAYBATTLEEX', 'suggests ' + Utility.MapList[index]);
-    MapsPopupStringList.ItemIndex := CurrentMapIndex;
+    MapSelectionForm.MapListBox.ItemIndex := CurrentMapIndex;
     Exit;
   end;
 
   if IsBattleActive and (BattleState.Battle.BattleType = 1) then
   begin
     MessageDlg('Cannot change map while hosting battle replay!', mtWarning, [mbOK], 0);
-    MapsPopupStringList.ItemIndex := CurrentMapIndex;
+    MapSelectionForm.MapListBox.ItemIndex := CurrentMapIndex;
     Exit;
   end;
 
@@ -1426,13 +1425,8 @@
 
   // display only mod maps
   validMaps := GetModValidMapList;
-  if validMaps.Count &gt;0 then
-  begin
-    MapsPopupStringList.Strings.Clear;
-    for i:=0 to validMaps.Count-1 do
-      if Utility.MapList.IndexOf(validMaps[i]) &gt; -1 then
-        MapsPopupStringList.Strings.Add(validMaps[i]);
-  end;
+
+  PopulatePopupMenuMapList;
   
   // update map:
   if (CurrentMapIndex = -1) or (Battle.Map &lt;&gt; GetMapItem(CurrentMapIndex).MapName) then
@@ -1666,14 +1660,7 @@
 
   // display only mod maps
   validMaps := GetModValidMapList;
-  if validMaps.Count &gt;0 then
-  begin
-    MapsPopupStringList.Strings.Clear;
-    for i:=0 to validMaps.Count-1 do
-      if Utility.MapList.IndexOf(validMaps[i]) &gt; -1 then
-        MapsPopupStringList.Strings.Add(validMaps[i]);
-    ChangeMap(Utility.MapList.IndexOf(MapsPopupStringList.Strings[0]))
-  end;
+  PopulatePopupMenuMapList;
 
   // load map options
   if CurrentMapIndex &gt; -1 then
@@ -1815,14 +1802,14 @@
     if not Preferences.DisableAllSounds then PlayResSound('battle');
   end;
 
-  MapsPopupStringList.Strings.Assign(Utility.MapList);
+  PopulatePopupMenuMapList;
 
   BattleState.Status := None;
 
   BattleState.DisabledUnits.Clear;
   PopulateDisabledUnitsVDT;
 
-  MapsPopupStringList.Enabled := True;
+  MapSelectionForm.MapListBox.Enabled := True;
 
   StartPosRadioGroup.Enabled := False;
   GameEndRadioGroup.Enabled := False;
@@ -1875,6 +1862,8 @@
   if UnknownScriptTagList.ValueList &lt;&gt; nil then
     UnknownScriptTagList.ValueList.Clear;
 
+  MapSelectionForm.FilterTextBox.Text := '';
+
   MainForm.ResetAutoKickMsgSentCounters;
   MainForm.ResetAutoSpecMsgSentCounters;
 //*** anything else?
@@ -2416,6 +2405,7 @@
   Left := 10;
   Top := 10;
   BattleState.DisabledUnits := TStringList.Create;
+  BattleState.LadderIndex := -1;
 
   FCurrentMapIndex := -1;
 
@@ -5627,9 +5617,9 @@
 
 procedure TLadderMapThread.Initialize;
 begin
-    BattleForm.MapsPopupStringList.Enabled := false;
-    BattleForm.MapsPopupStringList.Strings.Clear;
-    BattleForm.MapsPopupStringList.Strings.Add('Loading ladder map list ...');
+    MapSelectionForm.MapListBox.Enabled := false;
+    MapSelectionForm.MapListBox.Items.Clear;
+    MapSelectionForm.MapListBox.Items.Add('Loading ladder map list ...');
     BattleForm.StartButton.Enabled := False;
 end;
 
@@ -5643,13 +5633,13 @@
 begin
   if BattleState.Status = Hosting then
     BattleForm.StartButton.Enabled := StartButtonEnabled;
-  BattleForm.MapsPopupStringList.Enabled := True;
+  MapSelectionForm.MapListBox.Enabled := True;
   BattleForm.MapPanelResize(nil);
 end;
 
 procedure TLadderMapThread.ShowMessageStatus;
 begin
-  BattleForm.MapsPopupStringList.Strings.Strings[0] := StatusMsg;
+  MapSelectionForm.MapListBox.Items.Strings[0] := StatusMsg;
 end;
 
 procedure TLadderMapThread.UpdateMessageStatus(msg : string);
@@ -5719,7 +5709,7 @@
 
     if BattleState.Status = Hosting then
     begin
-      if MapsPopupStringList.Strings.Count &gt; 0 then
+      if MapSelectionForm.MapListBox.Items.Count &gt; 0 then
       begin
         Synchronize(ChangeMapToFirstOne);
         if IsBattleActive and (BattleState.Status = Hosting) then
@@ -6581,7 +6571,7 @@
   map : TMapItem;
   mapImgSpaceWidth,mapImgSpaceHeight : double;
 begin
-  //if not MapsPopupStringList.Enabled then
+  //if not MapSelectionForm.MapListBox.Enabled then
     //Exit;
   mapImgSpaceWidth := MapPanel.Width-134;
   mapImgSpaceHeight := MapPanel.Height-62;
@@ -6747,12 +6737,6 @@
    end;
 end;
 
-procedure TBattleForm.Button1Click(Sender: TObject);
-begin
-  Utility.ExtractVFSDir('lups','');
-end;
-
-
 procedure TBattleForm.ChatRichEditMouseDown(Sender: TObject;
   Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
 begin
@@ -6769,4 +6753,16 @@
   end;
 end;
 
+procedure TBattleForm.MapListFilterTextBoxChange(Sender: TObject;
+  const Text: WideString);
+begin
+  PopulatePopupMenuMapListF(Text);
+end;
+
+procedure TBattleForm.MapsPopupMenuPopup(Sender: TObject);
+begin
+  MapSelectionForm.SetFocus;
+  MapSelectionForm.FilterTextBox.SetFocus;
+end;
+
 end.

Modified: branches/0.77-branch/Lobby/TASClient/LobbyScriptUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/LobbyScriptUnit.pas	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/Lobby/TASClient/LobbyScriptUnit.pas	2008-09-04 08:12:47 UTC (rev 6356)
@@ -2,14 +2,22 @@
 
 interface
 uses
-  Windows, Messages, SysUtils, Variants, Graphics,
-  Misc,ExtCtrls, WrapDelphi, WrapDelphiClasses,PythonEngine,
-  PythonGUIInputOutput, Forms, StrUtils,Classes, JclDebug,
+  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
+  Dialogs,Misc,ExtCtrls, WrapDelphi, WrapDelphiClasses,PythonEngine,
+  PythonGUIInputOutput, StrUtils, JclDebug,
   WSocket,MainUnit, class_TIntegerList, RichEdit2, ExRichEdit,
-  SyncObjs,SpTBXItem, TB2Item, JvDesktopAlert, Controls,
-  SpTBXControls, SpTBXTabs;
+  SyncObjs,SpTBXItem, TB2Item, JvDesktopAlert,
+  SpTBXControls, SpTBXTabs,Forms;
 
 type
+  TScriptForm = class(TForm)
+    procedure CreateParams(var Params: TCreateParams); override;
+  private
+    { Private declarations }
+  public
+    { Public declarations }
+  end;
+
   TScriptNotificationCallback = record
     moduleName : string;
     functionName : string;
@@ -65,6 +73,7 @@
       function AddSplitter(name: string;parent : string):boolean;
       function AddTabsPanel(name: string;parent : string):boolean;
       function AddTab(caption: string;name: string;tabsPanel : string):boolean;
+      function AddForm(name: string;caption: string; style: integer):boolean;
 
       procedure RemoveFromMenu(id: integer);
   end;
@@ -1691,6 +1700,30 @@
   end;
 end;
 
+function TGUI.AddForm(name: string;caption: string; style: integer):boolean;
+var
+  p: TScriptForm;
+begin
+  try
+    p := TScriptForm.CreateNew(Application);
+    p.Name := name;
+    p.Caption := caption;
+
+    case style of
+      0: p.BorderStyle := bsNone;
+      1: p.BorderStyle := bsSingle;
+      2: p.BorderStyle := bsSizeable;
+      3: p.BorderStyle := bsDialog;
+      4: p.BorderStyle := bsToolWindow;
+      5: p.BorderStyle := bsSizeToolWin;
+    end;
+    p.Show;
+    Result := True;
+  except
+    Result := False;
+  end;
+end;
+
 procedure TGUI.LockGUI;
 begin
   CS.Enter;
@@ -1926,5 +1959,16 @@
   Result := JoinStringList(sl,'.');
 end;
 
+procedure TScriptForm.CreateParams(var Params: TCreateParams);
+begin
+  inherited CreateParams(Params);
 
+  with Params do
+  begin
+    ExStyle := ExStyle or WS_EX_APPWINDOW;
+    WndParent := GetDesktopWindow;
+  end;
+end;
+
+
 end.

Modified: branches/0.77-branch/Lobby/TASClient/MainUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/MainUnit.dfm	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/Lobby/TASClient/MainUnit.dfm	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,6 +1,6 @@
 object MainForm: TMainForm
-  Left = 480
-  Top = 329
+  Left = 515
+  Top = 119
   Width = 729
   Height = 543
   Caption = '.'
@@ -6458,8 +6458,8 @@
   end
   object SearchFormPopupMenu: TSpTBXFormPopupMenu
     PopupFocus = True
-    Left = 548
-    Top = 78
+    Left = 452
+    Top = 86
   end
   object BattleListPopupMenu: TSpTBXPopupMenu
     OnInitPopup = BattleListPopupMenuInitPopup
@@ -6524,7 +6524,7 @@
     end
   end
   object HelpPopupMenu: TSpTBXPopupMenu
-    Left = 448
+    Left = 368
     Top = 86
     object mnuHelp: TSpTBXItem
       Caption = 'Help'

Modified: branches/0.77-branch/Lobby/TASClient/MainUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/MainUnit.pas	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/Lobby/TASClient/MainUnit.pas	2008-09-04 08:12:47 UTC (rev 6356)
@@ -522,7 +522,7 @@
 const
   VERSION_NUMBER = '0.38'; // Must be float value! (with a period as a decimal seperator)
   CHECK_BETA_LOBBY_URL = '<A HREF="http://tasclient.no-ip.org/TASClient_update_v2.txt">http://tasclient.no-ip.org/TASClient_update_v2.txt</A>';
-  PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER + ' RC10';
+  PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER + ' RC12';
   KEEP_ALIVE_INTERVAL = 10000; // in milliseconds. Tells us what should be the maximum &quot;silence&quot; time before we send a ping to the server.
   ASSUME_TIMEOUT_INTERVAL = 30000; // in milliseconds. Must be greater than KEEP_ALIVE_INTERVAL! If server hasn't send any data to us within this interval, then we assume timeout occured. It's us who must make sure we get constant replies from server by pinging it.
   LOCAL_TAB = '$Local'; // caption of main (command) tab window. Must be special so that is different from channel names or user names, that is why there is a &quot;$&quot; in front of it.
@@ -1664,7 +1664,7 @@
   LoginProgressFormUnit, GpIFF, SearchFormUnit, ManageGroups, ColorPicker,
   AwayMessageFormUnit,JclStrings, SearchPlayerFormUnit, MenuFormUnit, Utility,
   PythonScriptDebugFormUnit,LobbyScriptUnit, SpringDownloaderFormUnit,
-  SyncObjs, LogonFormUnit;
+  SyncObjs, LogonFormUnit, MapSelectionFormUnit;
 
 {$R *.dfm}
 
@@ -3708,6 +3708,7 @@
 
     SearchFormPopupMenu.PopupForm := SearchForm;
     SearchPlayerFormPopupMenu.PopupForm := SearchPlayerForm;
+    BattleForm.MapsPopupMenu.PopupForm := MapSelectionForm;
 
     if Preferences.ConnectOnStartup and  not RunningWithMainMenu then
     begin

Modified: branches/0.77-branch/Lobby/TASClient/MapListFormUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/MapListFormUnit.pas	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/Lobby/TASClient/MapListFormUnit.pas	2008-09-04 08:12:47 UTC (rev 6356)
@@ -176,7 +176,7 @@
 implementation
 
 uses BattleFormUnit, PreferencesFormUnit, InitWaitFormUnit,
-  SpTBXLists, TntWideStrings;
+  SpTBXLists, TntWideStrings, MapSelectionFormUnit;
 
 {$R *.dfm}
 
@@ -1005,7 +1005,7 @@
   for i := 0 to SortedMaps.Count - 1 do begin
     sl := TStringList.Create;
 
-    TMapItem(SortedMaps[i]).MainPanel.Visible := (not BattleForm.IsBattleActive) or (BattleForm.MapsPopupStringList.Strings.IndexOf(TMapItem(SortedMaps[i]).MapName) &gt;= 0);
+    TMapItem(SortedMaps[i]).MainPanel.Visible := (not BattleForm.IsBattleActive) or (MapSelectionForm.MapListBox.Items.IndexOf(TMapItem(SortedMaps[i]).MapName) &gt;= 0);
 
     Misc.ParseDelimited(sl,s,' ','');
     for k:=0 to sl.Count -1 do

Copied: branches/0.77-branch/Lobby/TASClient/MapSelectionFormUnit.dfm (from rev 6351, trunk/Lobby/TASClient/MapSelectionFormUnit.dfm)
===================================================================
--- branches/0.77-branch/Lobby/TASClient/MapSelectionFormUnit.dfm	                        (rev 0)
+++ branches/0.77-branch/Lobby/TASClient/MapSelectionFormUnit.dfm	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,59 @@
+object MapSelectionForm: TMapSelectionForm
+  Left = 1003
+  Top = 185
+  Width = 257
+  Height = 355
+  Caption = 'MapSelectionForm'
+  Color = clBtnFace
+  Font.Charset = DEFAULT_CHARSET
+  Font.Color = clWindowText
+  Font.Height = -11
+  Font.Name = 'MS Sans Serif'
+  Font.Style = []
+  OldCreateOrder = False
+  DesignSize = (
+    249
+    328)
+  PixelsPerInch = 96
+  TextHeight = 13
+  object MapListBox: TSpTBXListBox
+    Left = 4
+    Top = 40
+    Width = 241
+    Height = 284
+    Anchors = [akLeft, akTop, akRight, akBottom]
+    ItemHeight = 16
+    TabOrder = 0
+    OnDblClick = MapListBoxDblClick
+  end
+  object SpTBXLabel1: TSpTBXLabel
+    Left = 8
+    Top = 10
+    Width = 28
+    Height = 13
+    Caption = 'Filter :'
+    LinkFont.Charset = DEFAULT_CHARSET
+    LinkFont.Color = clBlue
+    LinkFont.Height = -11
+    LinkFont.Name = 'MS Sans Serif'
+    LinkFont.Style = [fsUnderline]
+  end
+  object FilterTextBox: TSpTBXEdit
+    Left = 40
+    Top = 8
+    Width = 199
+    Height = 21
+    Anchors = [akLeft, akTop, akRight]
+    TabOrder = 2
+    OnChange = FilterTextBoxChange
+  end
+  object Panel1: TPanel
+    Left = 8
+    Top = 33
+    Width = 231
+    Height = 2
+    Anchors = [akLeft, akTop, akRight]
+    BevelOuter = bvLowered
+    TabOrder = 3
+  end
+end

Copied: branches/0.77-branch/Lobby/TASClient/MapSelectionFormUnit.pas (from rev 6351, trunk/Lobby/TASClient/MapSelectionFormUnit.pas)
===================================================================
--- branches/0.77-branch/Lobby/TASClient/MapSelectionFormUnit.pas	                        (rev 0)
+++ branches/0.77-branch/Lobby/TASClient/MapSelectionFormUnit.pas	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,40 @@
+unit MapSelectionFormUnit;
+
+interface
+
+uses
+  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
+  Dialogs, ExtCtrls, StdCtrls, SpTBXEditors, TBXDkPanels, SpTBXControls,
+  TntStdCtrls;
+
+type
+  TMapSelectionForm = class(TForm)
+    MapListBox: TSpTBXListBox;
+    SpTBXLabel1: TSpTBXLabel;
+    FilterTextBox: TSpTBXEdit;
+    Panel1: TPanel;
+    procedure FilterTextBoxChange(Sender: TObject);
+    procedure MapListBoxDblClick(Sender: TObject);
+  end;
+
+var
+  MapSelectionForm: TMapSelectionForm;
+
+implementation
+
+uses BattleFormUnit;
+
+{$R *.dfm}
+
+procedure TMapSelectionForm.FilterTextBoxChange(Sender: TObject);
+begin
+  BattleForm.PopulatePopupMenuMapListF(FilterTextBox.Text);
+end;
+
+procedure TMapSelectionForm.MapListBoxDblClick(Sender: TObject);
+begin
+  BattleForm.MapsPopupMenuItemClick(nil);
+  Close;
+end;
+
+end.

Copied: branches/0.77-branch/Lobby/TASClient/Python/scripts/subf/windowedTASClient.py (from rev 6355, trunk/Lobby/TASClient/Python/scripts/subf/windowedTASClient.py)
===================================================================
--- branches/0.77-branch/Lobby/TASClient/Python/scripts/subf/windowedTASClient.py	                        (rev 0)
+++ branches/0.77-branch/Lobby/TASClient/Python/scripts/subf/windowedTASClient.py	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,23 @@
+import lobbyscript
+
+api = lobbyscript.Callback()
+gui = lobbyscript.GUI()
+
+
+def changeComponentProp(comp,prop,value):
+  p = gui.GetControlProperties(comp)
+  p[prop] = value
+  gui.SetControlProperties(comp,p)
+
+def _init():
+  gui.AddForm('PlayerListForm','Player List',2)
+  changeComponentProp('MainForm.Panel2','parent','PlayerListForm')
+  changeComponentProp('MainForm.Panel2','align',5)
+  
+  gui.AddForm('BattleListForm','Battle List',2)
+  changeComponentProp('MainForm.Panel3','parent','BattleListForm')
+  changeComponentProp('MainForm.Panel3','align',5)
+  
+  gui.AddForm('ToolBarForm','TASClient Toolbar',2)
+  changeComponentProp('MainForm.Panel4','parent','ToolBarForm')
+  changeComponentProp('MainForm.Panel4','align',5)
\ No newline at end of file

Modified: branches/0.77-branch/Lobby/TASClient/TASClient.dof
===================================================================
--- branches/0.77-branch/Lobby/TASClient/TASClient.dof	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/Lobby/TASClient/TASClient.dof	2008-09-04 08:12:47 UTC (rev 6356)
@@ -115,7 +115,7 @@
 MajorVer=0
 MinorVer=3
 Release=0
-Build=429
+Build=437
 Debug=0
 PreRelease=0
 Special=0
@@ -126,7 +126,7 @@
 [Version Info Keys]
 CompanyName=
 FileDescription=TA Spring lobby client
-FileVersion=0.3.0.429
+FileVersion=0.3.0.437
 InternalName=
 LegalCopyright=
 LegalTrademarks=

Modified: branches/0.77-branch/Lobby/TASClient/TASClient.dpr
===================================================================
--- branches/0.77-branch/Lobby/TASClient/TASClient.dpr	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/Lobby/TASClient/TASClient.dpr	2008-09-04 08:12:47 UTC (rev 6356)
@@ -111,7 +111,8 @@
   PythonScriptDebugFormUnit in 'PythonScriptDebugFormUnit.pas' {PythonScriptDebugForm},
   LobbyScriptUnit in 'LobbyScriptUnit.pas',
   SpringDownloaderFormUnit in 'SpringDownloaderFormUnit.pas' {SpringDownloaderForm},
-  LogonFormUnit in 'LogonFormUnit.pas' {LogonForm};
+  LogonFormUnit in 'LogonFormUnit.pas' {LogonForm},
+  MapSelectionFormUnit in 'MapSelectionFormUnit.pas' {MapSelectionForm};
 
 var
   i: Integer;
@@ -183,6 +184,8 @@
 
   Application.Title := 'TASClient';
   Application.CreateForm(TMainForm, MainForm);
+  Application.CreateForm(TMapSelectionForm, MapSelectionForm);
+  Application.CreateForm(TLogonForm, LogonForm);
   Application.CreateForm(TColorPickerForm, ColorPickerForm);
   Application.CreateForm(TPreferencesForm, PreferencesForm);
   Application.CreateForm(TBattleForm, BattleForm);
@@ -220,7 +223,6 @@
   Application.CreateForm(TColorsPreference, ColorsPreference);
   Application.CreateForm(TSearchPlayerForm, SearchPlayerForm);
   Application.CreateForm(TPythonScriptDebugForm, PythonScriptDebugForm);
-  Application.CreateForm(TLogonForm, LogonForm);
   //Application.CreateForm(TSpringDownloaderForm, SpringDownloaderForm);
   if not MainUnit.RunningUnderWine then
     Application.CreateForm(TMenuForm, MenuForm);

Modified: branches/0.77-branch/Lobby/TASClient/TASClient.res
===================================================================
(Binary files differ)

Modified: branches/0.77-branch/rts/Game/GameServer.cpp
===================================================================
--- branches/0.77-branch/rts/Game/GameServer.cpp	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/rts/Game/GameServer.cpp	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1213,7 +1213,7 @@
 				hasPlayer = true;
 			}
 		}
-		if (!setup || !gs-&gt;Team(a)-&gt;dllAI.empty())
+		if (!setup || gs-&gt;Team(a)-&gt;isAI)
 			hasPlayer = true;
 
 		if (!gs-&gt;Team(a)-&gt;isDead &amp;&amp; !gs-&gt;Team(a)-&gt;gaia &amp;&amp; hasPlayer)

Modified: branches/0.77-branch/tools/ArchiveMoverLinux/Makefile
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/Makefile	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/Makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,14 +1,18 @@
-ML_SOURCES = mover.ml
-ML_SEARCH = -I +lablgtk2  -I +zip -I +extlib
-ML_LIBS = lablgtk.cmxa gtkInit.cmx unix.cmxa zip.cmxa extLib.cmxa
+ML_SOURCES = fileSystem.ml sdz.ml sd7.ml archive.ml datadir.ml mover.ml
+ML_SEARCH = -I +lablgtk2  -I +zip -I +extlib -I libmlsevenzip
+ML_LIBS = unix.cmxa sevenzip.cmxa zip.cmxa extLib.cmxa lablgtk.cmxa gtkInit.cmx
 
 all: mover
 
-mover: $(ML_SOURCES)
+mover: $(ML_SOURCES) libmlsevenzip
 	ocamlopt -o mover $(ML_SEARCH) $(ML_LIBS) $(ML_SOURCES)
 
+libmlsevenzip:
+	$(MAKE) -C libmlsevenzip
+
 clean:
+	$(MAKE) -C libmlsevenzip clean
 	rm -f *.cmi  *.cmo  *.cmx  *.o mover
 
 
-.PHONY: all clean
+.PHONY: all clean libmlsevenzip

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/archive.ml (from rev 6351, trunk/tools/ArchiveMoverLinux/archive.ml)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/archive.ml	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/archive.ml	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,44 @@
+open ExtString
+exception Error of string
+  
+type kind = Mod | Map | Unknown
+    
+let load path =
+  try
+    if String.ends_with path &quot;.sdz&quot; then
+      Sdz.In.load path
+    else if String.ends_with path &quot;.sd7&quot; then
+      Sd7.In.load path
+    else
+    raise (Error (Printf.sprintf &quot;Unknown archive type: %s&quot; path))
+  with
+      Zip.Error (path, _, s) -&gt; raise (Error (Printf.sprintf &quot;%s: %s&quot; path s))
+    | Sevenzip.Error s -&gt; raise (Error (Printf.sprintf &quot;%s: %s&quot; path s))
+    | Sys_error s -&gt; raise (Error s)      
+      
+let detect_kind path =
+  let archive = load path in
+  let entries = archive#entries in
+  let test_files func =
+    let f entry = func (String.lowercase entry#name) in
+      List.exists f entries
+  in
+  let is_map path =
+    let dirname = Filename.dirname path in
+    let basename = Filename.basename path in
+      if dirname = &quot;maps&quot; then
+        if String.ends_with basename &quot;.smf&quot; then
+          true
+        else if String.ends_with basename &quot;.sm3&quot; then
+          true
+        else
+          false
+      else
+        false in
+    
+    archive#unload;
+    if test_files is_map then Map
+    else if test_files (fun filename -&gt; filename = &quot;modinfo.tdf&quot;) then Mod
+    else if test_files (fun filename -&gt; filename = &quot;modinfo.lua&quot;) then Mod
+    else Unknown
+

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/datadir.ml (from rev 6351, trunk/tools/ArchiveMoverLinux/datadir.ml)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/datadir.ml	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/datadir.ml	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,48 @@
+open ExtString
+let detect_home_dir () =
+  try
+    let home_dir = Sys.getenv &quot;HOME&quot; in
+      Some home_dir
+  with Not_found -&gt; None
+    
+let detect_springrc home_dir =
+  try
+    let springrc = Filename.concat home_dir &quot;.springrc&quot; in
+    let in_file = open_in springrc in
+    let input = IO.input_channel in_file in
+    let rec loop option =
+      try 
+        let line = IO.read_line input in
+          try
+            let (key, value) = String.split line &quot;=&quot; in
+              if key = &quot;SpringData&quot; then
+                loop (Some value)
+              else
+                loop option
+          with Invalid_string -&gt; loop option
+      with IO.No_more_input -&gt; option in
+    let option = loop None in
+      close_in in_file;
+      option
+  with Sys_error _ -&gt; None
+    
+let detect_etc home_dir =
+  try
+    let in_file = open_in &quot;/etc/spring/datadir&quot; in
+    let input = IO.input_channel in_file in
+    let format = IO.read_line input in
+    let (_, dir) = String.replace format &quot;$HOME&quot; home_dir in
+      close_in in_file;
+      Some dir
+  with Sys_error _ -&gt; None
+    
+let detect () =
+  match detect_home_dir () with
+      Some home_dir -&gt;
+        (match detect_springrc home_dir with
+             Some spring_dir -&gt; spring_dir
+           | None -&gt;
+               (match detect_etc home_dir with
+                    Some etc_dir -&gt; etc_dir
+                  | None -&gt; Filename.concat home_dir &quot;.spring&quot;))
+    | None -&gt; &quot;&quot;

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/fileSystem.ml (from rev 6351, trunk/tools/ArchiveMoverLinux/fileSystem.ml)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/fileSystem.ml	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/fileSystem.ml	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,28 @@
+let copy src dst =
+  let string = String.create 4096 in
+  let in_chan = open_in_bin src in
+  let out_chan = open_out_bin dst in
+    
+  let rec f () =
+    let n = input in_chan string 0 (String.length string) in
+      if n = 0 then
+        ()
+      else
+        begin
+          output out_chan string 0 n;
+          f ()
+        end in
+    
+    f ();
+    close_in in_chan;
+    close_out out_chan
+      
+let move src dst =
+  if src != dst then
+    try
+      Sys.rename src dst
+    with Sys_error _ -&gt;
+      copy src dst;
+      Sys.remove src
+  else
+    ()

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/Makefile
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/Makefile	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/Makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,33 +0,0 @@
-CFLAGS = -I../../../rts
-LD_FLAGS = -Llibmlsevenzip
-LIBS = -lml_sevenzip
-
-all: sevenzip.cmxa libml_sevenzip.a 
-
-sevenzip.cmxa: sevenzip.cmx
-	ocamlopt -cclib &quot;$(LD_FLAGS) $(LIBS)&quot; -a -o sevenzip.cmxa sevenzip.cmx
-
-sevenzip.cmx: sevenzip.ml
-	ocamlopt -o sevenzip.cmx -c sevenzip.ml
-
-libsevenzip:
-	$(MAKE) -C libsevenzip/Archive/7z -f makefile.gcc
-
-libml_sevenzip.a: ml_sevenzip.o libsevenzip
-	ar rc libml_sevenzip.a ml_sevenzip.o libsevenzip/Archive/7z/*.o
-	ranlib libml_sevenzip.a
-
-ml_sevenzip.o: ml_sevenzip.c
-	ocamlopt -ccopt &quot;$(CFLAGS)&quot; -o ml_sevenzip.o ml_sevenzip.c
-
-clean:
-	$(MAKE) -C libsevenzip/Archive/7z -f makefile.gcc clean
-	rm -rf *.cmx
-	rm -rf *.cmi
-	rm -rf *.o
-	rm -rf *.a
-	rm -rf *.cmxa
-	rm -f test
-
-
-.PHONY: all clean libsevenzip

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/Makefile (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/Makefile)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/Makefile	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/Makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,33 @@
+CFLAGS = -I../../../rts
+LD_FLAGS = -Llibmlsevenzip
+LIBS = -lml_sevenzip
+
+all: sevenzip.cmxa libml_sevenzip.a 
+
+sevenzip.cmxa: sevenzip.cmx
+	ocamlopt -cclib &quot;$(LD_FLAGS) $(LIBS)&quot; -a -o sevenzip.cmxa sevenzip.cmx
+
+sevenzip.cmx: sevenzip.ml
+	ocamlopt -o sevenzip.cmx -c sevenzip.ml
+
+libsevenzip:
+	$(MAKE) -C libsevenzip/Archive/7z -f makefile.gcc
+
+libml_sevenzip.a: ml_sevenzip.o libsevenzip
+	ar rc libml_sevenzip.a ml_sevenzip.o libsevenzip/Archive/7z/*.o
+	ranlib libml_sevenzip.a
+
+ml_sevenzip.o: ml_sevenzip.c
+	ocamlopt -ccopt &quot;$(CFLAGS)&quot; -o ml_sevenzip.o ml_sevenzip.c
+
+clean:
+	$(MAKE) -C libsevenzip/Archive/7z -f makefile.gcc clean
+	rm -rf *.cmx
+	rm -rf *.cmi
+	rm -rf *.o
+	rm -rf *.a
+	rm -rf *.cmxa
+	rm -f test
+
+
+.PHONY: all clean libsevenzip

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,36 +0,0 @@
-/* 7zBuf.c -- Byte Buffer
-2008-03-28
-Igor Pavlov
-Public domain */
-
-#include &quot;7zBuf.h&quot;
-
-void Buf_Init(CBuf *p)
-{
-  p-&gt;data = 0;
-  p-&gt;size = 0;
-}
-
-int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc)
-{
-  p-&gt;size = 0;
-  if (size == 0)
-  {
-    p-&gt;data = 0;
-    return 1;
-  }
-  p-&gt;data = (Byte *)alloc-&gt;Alloc(alloc, size);
-  if (p-&gt;data != 0)
-  {
-    p-&gt;size = size;
-    return 1;
-  }
-  return 0;
-}
-
-void Buf_Free(CBuf *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;data);
-  p-&gt;data = 0;
-  p-&gt;size = 0;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,36 @@
+/* 7zBuf.c -- Byte Buffer
+2008-03-28
+Igor Pavlov
+Public domain */
+
+#include &quot;7zBuf.h&quot;
+
+void Buf_Init(CBuf *p)
+{
+  p-&gt;data = 0;
+  p-&gt;size = 0;
+}
+
+int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc)
+{
+  p-&gt;size = 0;
+  if (size == 0)
+  {
+    p-&gt;data = 0;
+    return 1;
+  }
+  p-&gt;data = (Byte *)alloc-&gt;Alloc(alloc, size);
+  if (p-&gt;data != 0)
+  {
+    p-&gt;size = size;
+    return 1;
+  }
+  return 0;
+}
+
+void Buf_Free(CBuf *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;data);
+  p-&gt;data = 0;
+  p-&gt;size = 0;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,21 +0,0 @@
-/* 7zBuf.h -- Byte Buffer
-2008-05-01
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_BUF_H
-#define __7Z_BUF_H
-
-#include &quot;Types.h&quot;
-
-typedef struct
-{
-  Byte *data;
-  size_t size;
-} CBuf;
-
-void Buf_Init(CBuf *p);
-int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc);
-void Buf_Free(CBuf *p, ISzAlloc *alloc);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zBuf.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,21 @@
+/* 7zBuf.h -- Byte Buffer
+2008-05-01
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_BUF_H
+#define __7Z_BUF_H
+
+#include &quot;Types.h&quot;
+
+typedef struct
+{
+  Byte *data;
+  size_t size;
+} CBuf;
+
+void Buf_Init(CBuf *p);
+int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc);
+void Buf_Free(CBuf *p, ISzAlloc *alloc);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,35 +0,0 @@
-/* 7zCrc.c -- CRC32 calculation
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#include &quot;7zCrc.h&quot;
-
-#define kCrcPoly 0xEDB88320
-UInt32 g_CrcTable[256];
-
-void MY_FAST_CALL CrcGenerateTable(void)
-{
-  UInt32 i;
-  for (i = 0; i &lt; 256; i++)
-  {
-    UInt32 r = i;
-    int j;
-    for (j = 0; j &lt; 8; j++)
-      r = (r &gt;&gt; 1) ^ (kCrcPoly &amp; ~((r &amp; 1) - 1));
-    g_CrcTable[i] = r;
-  }
-}
-
-UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
-{
-  const Byte *p = (const Byte *)data;
-  for (; size &gt; 0 ; size--, p++)
-    v = CRC_UPDATE_BYTE(v, *p);
-  return v;
-}
-
-UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size)
-{
-  return CrcUpdate(CRC_INIT_VAL, data, size) ^ 0xFFFFFFFF;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,35 @@
+/* 7zCrc.c -- CRC32 calculation
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include &quot;7zCrc.h&quot;
+
+#define kCrcPoly 0xEDB88320
+UInt32 g_CrcTable[256];
+
+void MY_FAST_CALL CrcGenerateTable(void)
+{
+  UInt32 i;
+  for (i = 0; i &lt; 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j &lt; 8; j++)
+      r = (r &gt;&gt; 1) ^ (kCrcPoly &amp; ~((r &amp; 1) - 1));
+    g_CrcTable[i] = r;
+  }
+}
+
+UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
+{
+  const Byte *p = (const Byte *)data;
+  for (; size &gt; 0 ; size--, p++)
+    v = CRC_UPDATE_BYTE(v, *p);
+  return v;
+}
+
+UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size)
+{
+  return CrcUpdate(CRC_INIT_VAL, data, size) ^ 0xFFFFFFFF;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,24 +0,0 @@
-/* 7zCrc.h -- CRC32 calculation
-2008-03-13
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_CRC_H
-#define __7Z_CRC_H
-
-#include &lt;stddef.h&gt;
-
-#include &quot;Types.h&quot;
-
-extern UInt32 g_CrcTable[];
-
-void MY_FAST_CALL CrcGenerateTable(void);
-
-#define CRC_INIT_VAL 0xFFFFFFFF
-#define CRC_GET_DIGEST(crc) ((crc) ^ 0xFFFFFFFF)
-#define CRC_UPDATE_BYTE(crc, b) (g_CrcTable[((crc) ^ (b)) &amp; 0xFF] ^ ((crc) &gt;&gt; 8))
-
-UInt32 MY_FAST_CALL CrcUpdate(UInt32 crc, const void *data, size_t size);
-UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/7zCrc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,24 @@
+/* 7zCrc.h -- CRC32 calculation
+2008-03-13
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_CRC_H
+#define __7Z_CRC_H
+
+#include &lt;stddef.h&gt;
+
+#include &quot;Types.h&quot;
+
+extern UInt32 g_CrcTable[];
+
+void MY_FAST_CALL CrcGenerateTable(void);
+
+#define CRC_INIT_VAL 0xFFFFFFFF
+#define CRC_GET_DIGEST(crc) ((crc) ^ 0xFFFFFFFF)
+#define CRC_UPDATE_BYTE(crc, b) (g_CrcTable[((crc) ^ (b)) &amp; 0xFF] ^ ((crc) &gt;&gt; 8))
+
+UInt32 MY_FAST_CALL CrcUpdate(UInt32 crc, const void *data, size_t size);
+UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,122 +0,0 @@
-/* Alloc.c -- Memory allocation functions
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifdef _WIN32
-#include &lt;windows.h&gt;
-#endif
-#include &lt;stdlib.h&gt;
-
-#include &quot;Alloc.h&quot;
-
-/* #define _SZ_ALLOC_DEBUG */
-
-/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
-#ifdef _SZ_ALLOC_DEBUG
-#include &lt;stdio.h&gt;
-int g_allocCount = 0;
-int g_allocCountMid = 0;
-int g_allocCountBig = 0;
-#endif
-
-void *MyAlloc(size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount++);
-  #endif
-  return malloc(size);
-}
-
-void MyFree(void *address)
-{
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-    fprintf(stderr, &quot;\nFree; count = %10d&quot;, --g_allocCount);
-  #endif
-  free(address);
-}
-
-#ifdef _WIN32
-
-void *MidAlloc(size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc_Mid %10d bytes;  count = %10d&quot;, size, g_allocCountMid++);
-  #endif
-  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
-}
-
-void MidFree(void *address)
-{
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-    fprintf(stderr, &quot;\nFree_Mid; count = %10d&quot;, --g_allocCountMid);
-  #endif
-  if (address == 0)
-    return;
-  VirtualFree(address, 0, MEM_RELEASE);
-}
-
-#ifndef MEM_LARGE_PAGES
-#undef _7ZIP_LARGE_PAGES
-#endif
-
-#ifdef _7ZIP_LARGE_PAGES
-SIZE_T g_LargePageSize = 0;
-typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
-#endif
-
-void SetLargePageSize()
-{
-  #ifdef _7ZIP_LARGE_PAGES
-  SIZE_T size = 0;
-  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
-        GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;GetLargePageMinimum&quot;);
-  if (largePageMinimum == 0)
-    return;
-  size = largePageMinimum();
-  if (size == 0 || (size &amp; (size - 1)) != 0)
-    return;
-  g_LargePageSize = size;
-  #endif
-}
-
-
-void *BigAlloc(size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc_Big %10d bytes;  count = %10d&quot;, size, g_allocCountBig++);
-  #endif
-  
-  #ifdef _7ZIP_LARGE_PAGES
-  if (g_LargePageSize != 0 &amp;&amp; g_LargePageSize &lt;= (1 &lt;&lt; 30) &amp;&amp; size &gt;= (1 &lt;&lt; 18))
-  {
-    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) &amp; (~(g_LargePageSize - 1)),
-        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
-    if (res != 0)
-      return res;
-  }
-  #endif
-  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
-}
-
-void BigFree(void *address)
-{
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-    fprintf(stderr, &quot;\nFree_Big; count = %10d&quot;, --g_allocCountBig);
-  #endif
-  
-  if (address == 0)
-    return;
-  VirtualFree(address, 0, MEM_RELEASE);
-}
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,122 @@
+/* Alloc.c -- Memory allocation functions
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifdef _WIN32
+#include &lt;windows.h&gt;
+#endif
+#include &lt;stdlib.h&gt;
+
+#include &quot;Alloc.h&quot;
+
+/* #define _SZ_ALLOC_DEBUG */
+
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+#ifdef _SZ_ALLOC_DEBUG
+#include &lt;stdio.h&gt;
+int g_allocCount = 0;
+int g_allocCountMid = 0;
+int g_allocCountBig = 0;
+#endif
+
+void *MyAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount++);
+  #endif
+  return malloc(size);
+}
+
+void MyFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree; count = %10d&quot;, --g_allocCount);
+  #endif
+  free(address);
+}
+
+#ifdef _WIN32
+
+void *MidAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_Mid %10d bytes;  count = %10d&quot;, size, g_allocCountMid++);
+  #endif
+  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void MidFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree_Mid; count = %10d&quot;, --g_allocCountMid);
+  #endif
+  if (address == 0)
+    return;
+  VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#ifndef MEM_LARGE_PAGES
+#undef _7ZIP_LARGE_PAGES
+#endif
+
+#ifdef _7ZIP_LARGE_PAGES
+SIZE_T g_LargePageSize = 0;
+typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
+#endif
+
+void SetLargePageSize()
+{
+  #ifdef _7ZIP_LARGE_PAGES
+  SIZE_T size = 0;
+  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
+        GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;GetLargePageMinimum&quot;);
+  if (largePageMinimum == 0)
+    return;
+  size = largePageMinimum();
+  if (size == 0 || (size &amp; (size - 1)) != 0)
+    return;
+  g_LargePageSize = size;
+  #endif
+}
+
+
+void *BigAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_Big %10d bytes;  count = %10d&quot;, size, g_allocCountBig++);
+  #endif
+  
+  #ifdef _7ZIP_LARGE_PAGES
+  if (g_LargePageSize != 0 &amp;&amp; g_LargePageSize &lt;= (1 &lt;&lt; 30) &amp;&amp; size &gt;= (1 &lt;&lt; 18))
+  {
+    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) &amp; (~(g_LargePageSize - 1)),
+        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
+    if (res != 0)
+      return res;
+  }
+  #endif
+  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void BigFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree_Big; count = %10d&quot;, --g_allocCountBig);
+  #endif
+  
+  if (address == 0)
+    return;
+  VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,32 +0,0 @@
-/* Alloc.h -- Memory allocation functions
-2008-03-13
-Igor Pavlov
-Public domain */
-
-#ifndef __COMMON_ALLOC_H
-#define __COMMON_ALLOC_H
-
-#include &lt;stddef.h&gt;
-
-void *MyAlloc(size_t size);
-void MyFree(void *address);
-
-#ifdef _WIN32
-
-void SetLargePageSize();
-
-void *MidAlloc(size_t size);
-void MidFree(void *address);
-void *BigAlloc(size_t size);
-void BigFree(void *address);
-
-#else
-
-#define MidAlloc(size) MyAlloc(size)
-#define MidFree(address) MyFree(address)
-#define BigAlloc(size) MyAlloc(size)
-#define BigFree(address) MyFree(address)
-
-#endif
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Alloc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,32 @@
+/* Alloc.h -- Memory allocation functions
+2008-03-13
+Igor Pavlov
+Public domain */
+
+#ifndef __COMMON_ALLOC_H
+#define __COMMON_ALLOC_H
+
+#include &lt;stddef.h&gt;
+
+void *MyAlloc(size_t size);
+void MyFree(void *address);
+
+#ifdef _WIN32
+
+void SetLargePageSize();
+
+void *MidAlloc(size_t size);
+void MidFree(void *address);
+void *BigAlloc(size_t size);
+void BigFree(void *address);
+
+#else
+
+#define MidAlloc(size) MyAlloc(size)
+#define MidFree(address) MyFree(address)
+#define BigAlloc(size) MyAlloc(size)
+#define BigFree(address) MyFree(address)
+
+#endif
+
+#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive)

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,187 +0,0 @@
-# Microsoft Developer Studio Project File - Name=&quot;7z&quot; - Package Owner=&lt;4&gt;
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
-
-CFG=7z - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;7z.mak&quot;.
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;7z.mak&quot; CFG=&quot;7z - Win32 Debug&quot;
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE &quot;7z - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
-!MESSAGE &quot;7z - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName &quot;&quot;
-# PROP Scc_LocalPath &quot;&quot;
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  &quot;$(CFG)&quot; == &quot;7z - Win32 Release&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir &quot;Release&quot;
-# PROP BASE Intermediate_Dir &quot;Release&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir &quot;Release&quot;
-# PROP Intermediate_Dir &quot;Release&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
-# ADD CPP /nologo /MD /W3 /GX /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
-# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;Release/7zDec.exe&quot; /opt:NOWIN98
-# SUBTRACT LINK32 /pdb:none
-
-!ELSEIF  &quot;$(CFG)&quot; == &quot;7z - Win32 Debug&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir &quot;Debug&quot;
-# PROP BASE Intermediate_Dir &quot;Debug&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir &quot;Debug&quot;
-# PROP Intermediate_Dir &quot;Debug&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
-# ADD CPP /nologo /W4 /Gm /GX /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
-# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;Debug/7zDec.exe&quot; /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name &quot;7z - Win32 Release&quot;
-# Name &quot;7z - Win32 Debug&quot;
-# Begin Group &quot;Common&quot;
-
-# PROP Default_Filter &quot;&quot;
-# Begin Source File
-
-SOURCE=..\..\7zBuf.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\7zBuf.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\7zCrc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\7zCrc.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Bcj2.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Bcj2.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Bra.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Bra86.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\LzmaDec.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\LzmaDec.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Types.h
-# End Source File
-# End Group
-# Begin Source File
-
-SOURCE=.\7zAlloc.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zAlloc.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zDecode.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zDecode.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zExtract.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zExtract.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zHeader.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zHeader.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zIn.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zIn.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zItem.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zItem.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zMain.c
-# End Source File
-# End Target
-# End Project

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,187 @@
+# Microsoft Developer Studio Project File - Name=&quot;7z&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
+
+CFG=7z - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;7z.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;7z.mak&quot; CFG=&quot;7z - Win32 Debug&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;7z - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE &quot;7z - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;7z - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;Release/7zDec.exe&quot; /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;7z - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /W4 /Gm /GX /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;Debug/7zDec.exe&quot; /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;7z - Win32 Release&quot;
+# Name &quot;7z - Win32 Debug&quot;
+# Begin Group &quot;Common&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\..\7zBuf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zBuf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zCrc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zCrc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bcj2.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bcj2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bra.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bra86.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Types.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\7zAlloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zAlloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMain.c
+# End Source File
+# End Target
+# End Project

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,29 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: &quot;7z&quot;=.\7z.dsp - Package Owner=&lt;4&gt;
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;4&gt;
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;3&gt;
-{{{
-}}}
-
-###############################################################################
-

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;7z&quot;=.\7z.dsp - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,79 +0,0 @@
-/* 7zAlloc.c -- Allocation functions
-2008-03-28
-Igor Pavlov
-Public domain */
-
-#include &lt;stdlib.h&gt;
-#include &quot;7zAlloc.h&quot;
-
-/* #define _SZ_ALLOC_DEBUG */
-/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
-
-#ifdef _SZ_ALLOC_DEBUG
-
-#ifdef _WIN32
-#include &lt;windows.h&gt;
-#endif
-
-#include &lt;stdio.h&gt;
-int g_allocCount = 0;
-int g_allocCountTemp = 0;
-
-#endif
-
-void *SzAlloc(void *p, size_t size)
-{
-  p = p;
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount);
-  g_allocCount++;
-  #endif
-  return malloc(size);
-}
-
-void SzFree(void *p, void *address)
-{
-  p = p;
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-  {
-    g_allocCount--;
-    fprintf(stderr, &quot;\nFree; count = %10d&quot;, g_allocCount);
-  }
-  #endif
-  free(address);
-}
-
-void *SzAllocTemp(void *p, size_t size)
-{
-  p = p;
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc_temp %10d bytes;  count = %10d&quot;, size, g_allocCountTemp);
-  g_allocCountTemp++;
-  #ifdef _WIN32
-  return HeapAlloc(GetProcessHeap(), 0, size);
-  #endif
-  #endif
-  return malloc(size);
-}
-
-void SzFreeTemp(void *p, void *address)
-{
-  p = p;
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-  {
-    g_allocCountTemp--;
-    fprintf(stderr, &quot;\nFree_temp; count = %10d&quot;, g_allocCountTemp);
-  }
-  #ifdef _WIN32
-  HeapFree(GetProcessHeap(), 0, address);
-  return;
-  #endif
-  #endif
-  free(address);
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,79 @@
+/* 7zAlloc.c -- Allocation functions
+2008-03-28
+Igor Pavlov
+Public domain */
+
+#include &lt;stdlib.h&gt;
+#include &quot;7zAlloc.h&quot;
+
+/* #define _SZ_ALLOC_DEBUG */
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+
+#ifdef _SZ_ALLOC_DEBUG
+
+#ifdef _WIN32
+#include &lt;windows.h&gt;
+#endif
+
+#include &lt;stdio.h&gt;
+int g_allocCount = 0;
+int g_allocCountTemp = 0;
+
+#endif
+
+void *SzAlloc(void *p, size_t size)
+{
+  p = p;
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount);
+  g_allocCount++;
+  #endif
+  return malloc(size);
+}
+
+void SzFree(void *p, void *address)
+{
+  p = p;
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCount--;
+    fprintf(stderr, &quot;\nFree; count = %10d&quot;, g_allocCount);
+  }
+  #endif
+  free(address);
+}
+
+void *SzAllocTemp(void *p, size_t size)
+{
+  p = p;
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_temp %10d bytes;  count = %10d&quot;, size, g_allocCountTemp);
+  g_allocCountTemp++;
+  #ifdef _WIN32
+  return HeapAlloc(GetProcessHeap(), 0, size);
+  #endif
+  #endif
+  return malloc(size);
+}
+
+void SzFreeTemp(void *p, void *address)
+{
+  p = p;
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCountTemp--;
+    fprintf(stderr, &quot;\nFree_temp; count = %10d&quot;, g_allocCountTemp);
+  }
+  #ifdef _WIN32
+  HeapFree(GetProcessHeap(), 0, address);
+  return;
+  #endif
+  #endif
+  free(address);
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,17 +0,0 @@
-/* 7zAlloc.h -- Allocation functions
-2008-03-28
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_ALLOC_H
-#define __7Z_ALLOC_H
-
-#include &lt;stddef.h&gt;
-
-void *SzAlloc(void *p, size_t size);
-void SzFree(void *p, void *address);
-
-void *SzAllocTemp(void *p, size_t size);
-void SzFreeTemp(void *p, void *address);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,17 @@
+/* 7zAlloc.h -- Allocation functions
+2008-03-28
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_ALLOC_H
+#define __7Z_ALLOC_H
+
+#include &lt;stddef.h&gt;
+
+void *SzAlloc(void *p, size_t size);
+void SzFree(void *p, void *address);
+
+void *SzAllocTemp(void *p, size_t size);
+void SzFreeTemp(void *p, void *address);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,339 +0,0 @@
-/* 7zDecode.c  Decoding from 7z folder
-2008-08-05
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zDecode.h for license options */
-
-#include &lt;string.h&gt;
-
-#include &quot;7zDecode.h&quot;
-#include &quot;../../LzmaDec.h&quot;
-#include &quot;../../Bra.h&quot;
-#include &quot;../../Bcj2.h&quot;
-
-#define k_Copy 0
-#define k_LZMA 0x30101
-#define k_BCJ 0x03030103
-#define k_BCJ2 0x0303011B
-
-/*
-#ifdef _LZMA_IN_CB
-*/
-
-static SRes SzDecodeLzma(CSzCoderInfo *coder, CFileSize inSize, ISzInStream *inStream,
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
-{
-  CLzmaDec state;
-  int res = SZ_OK;
-  size_t _inSize;
-  Byte *inBuf = NULL;
-
-  LzmaDec_Construct(&amp;state);
-  RINOK(LzmaDec_AllocateProbs(&amp;state, coder-&gt;Props.data, (unsigned)coder-&gt;Props.size, allocMain));
-  state.dic = outBuffer;
-  state.dicBufSize = outSize;
-  LzmaDec_Init(&amp;state);
-
-  _inSize = 0;
-
-  for (;;)
-  {
-    if (_inSize == 0)
-    {
-      _inSize = (1 &lt;&lt; 18);
-      if (_inSize &gt; inSize)
-        _inSize = (size_t)(inSize);
-      res = inStream-&gt;Read((void *)inStream, (void **)&amp;inBuf, &amp;_inSize);
-      if (res != SZ_OK)
-        break;
-      inSize -= _inSize;
-    }
-
-    {
-      SizeT inProcessed = _inSize, dicPos = state.dicPos;
-      ELzmaStatus status;
-      res = LzmaDec_DecodeToDic(&amp;state, outSize, inBuf, &amp;inProcessed, LZMA_FINISH_END, &amp;status);
-      _inSize -= inProcessed;
-      inBuf = (Byte *)inBuf + inProcessed;
-      if (res != SZ_OK)
-        break;
-      if (state.dicPos == state.dicBufSize || (inProcessed == 0 &amp;&amp; dicPos == state.dicPos))
-      {
-        if (state.dicBufSize != outSize || _inSize != 0 ||
-            (status != LZMA_STATUS_FINISHED_WITH_MARK &amp;&amp;
-             status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK))
-          res = SZ_ERROR_DATA;
-        break;
-      }
-    }
-  }
-
-  LzmaDec_FreeProbs(&amp;state, allocMain);
-
-  return res;
-}
-
-static SRes SzDecodeCopy(CFileSize inSize, ISzInStream *inStream, Byte *outBuffer)
-{
-  while (inSize &gt; 0)
-  {
-    void *inBuffer;
-    size_t curSize = (1 &lt;&lt; 18);
-    if (curSize &gt; inSize)
-      curSize = (size_t)(inSize);
-    RINOK(inStream-&gt;Read((void *)inStream, (void **)&amp;inBuffer, &amp;curSize));
-    if (curSize == 0)
-      return SZ_ERROR_INPUT_EOF;
-    memcpy(outBuffer, inBuffer, curSize);
-    outBuffer += curSize;
-    inSize -= curSize;
-  }
-  return SZ_OK;
-}
-/*
-#endif
-*/
-
-#define IS_UNSUPPORTED_METHOD(m) ((m) != k_Copy &amp;&amp; (m) != k_LZMA)
-#define IS_UNSUPPORTED_CODER(c) (IS_UNSUPPORTED_METHOD(c.MethodID) || c.NumInStreams != 1 || c.NumOutStreams != 1)
-#define IS_NO_BCJ(c) (c.MethodID != k_BCJ || c.NumInStreams != 1 || c.NumOutStreams != 1)
-#define IS_NO_BCJ2(c) (c.MethodID != k_BCJ2 || c.NumInStreams != 4 || c.NumOutStreams != 1)
-
-SRes CheckSupportedFolder(const CSzFolder *f)
-{
-  if (f-&gt;NumCoders &lt; 1 || f-&gt;NumCoders &gt; 4)
-    return SZ_ERROR_UNSUPPORTED;
-  if (IS_UNSUPPORTED_CODER(f-&gt;Coders[0]))
-    return SZ_ERROR_UNSUPPORTED;
-  if (f-&gt;NumCoders == 1)
-  {
-    if (f-&gt;NumPackStreams != 1 || f-&gt;PackStreams[0] != 0 || f-&gt;NumBindPairs != 0)
-      return SZ_ERROR_UNSUPPORTED;
-    return SZ_OK;
-  }
-  if (f-&gt;NumCoders == 2)
-  {
-    if (IS_NO_BCJ(f-&gt;Coders[1]) ||
-        f-&gt;NumPackStreams != 1 || f-&gt;PackStreams[0] != 0 ||
-        f-&gt;NumBindPairs != 1 ||
-        f-&gt;BindPairs[0].InIndex != 1 || f-&gt;BindPairs[0].OutIndex != 0)
-      return SZ_ERROR_UNSUPPORTED;
-    return SZ_OK;
-  }
-  if (f-&gt;NumCoders == 4)
-  {
-    if (IS_UNSUPPORTED_CODER(f-&gt;Coders[1]) ||
-        IS_UNSUPPORTED_CODER(f-&gt;Coders[2]) ||
-        IS_NO_BCJ2(f-&gt;Coders[3]))
-      return SZ_ERROR_UNSUPPORTED;
-    if (f-&gt;NumPackStreams != 4 ||
-        f-&gt;PackStreams[0] != 2 ||
-        f-&gt;PackStreams[1] != 6 ||
-        f-&gt;PackStreams[2] != 1 ||
-        f-&gt;PackStreams[3] != 0 ||
-        f-&gt;NumBindPairs != 3 ||
-        f-&gt;BindPairs[0].InIndex != 5 || f-&gt;BindPairs[0].OutIndex != 0 ||
-        f-&gt;BindPairs[1].InIndex != 4 || f-&gt;BindPairs[1].OutIndex != 1 ||
-        f-&gt;BindPairs[2].InIndex != 3 || f-&gt;BindPairs[2].OutIndex != 2)
-      return SZ_ERROR_UNSUPPORTED;
-    return SZ_OK;
-  }
-  return SZ_ERROR_UNSUPPORTED;
-}
-
-CFileSize GetSum(const CFileSize *values, UInt32 index)
-{
-  CFileSize sum = 0;
-  UInt32 i;
-  for (i = 0; i &lt; index; i++)
-    sum += values[i];
-  return sum;
-}
-
-SRes SzDecode2(const CFileSize *packSizes, const CSzFolder *folder,
-    /*
-    #ifdef _LZMA_IN_CB
-    */
-    ISzInStream *inStream, CFileSize startPos,
-    /*
-    #else
-    const Byte *inBuffer,
-    #endif
-    */
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain,
-    Byte *tempBuf[])
-{
-  UInt32 ci;
-  size_t tempSizes[3] = { 0, 0, 0};
-  size_t tempSize3 = 0;
-  Byte *tempBuf3 = 0;
-
-  RINOK(CheckSupportedFolder(folder));
-
-  for (ci = 0; ci &lt; folder-&gt;NumCoders; ci++)
-  {
-    CSzCoderInfo *coder = &amp;folder-&gt;Coders[ci];
-
-    if (coder-&gt;MethodID == k_Copy || coder-&gt;MethodID == k_LZMA)
-    {
-      UInt32 si = 0;
-      CFileSize offset;
-      CFileSize inSize;
-      Byte *outBufCur = outBuffer;
-      size_t outSizeCur = outSize;
-      if (folder-&gt;NumCoders == 4)
-      {
-        UInt32 indices[] = { 3, 2, 0 };
-        CFileSize unpackSize = folder-&gt;UnpackSizes[ci];
-        si = indices[ci];
-        if (ci &lt; 2)
-        {
-          Byte *temp;
-          outSizeCur = (size_t)unpackSize;
-          if (outSizeCur != unpackSize)
-            return SZ_ERROR_MEM;
-          temp = (Byte *)IAlloc_Alloc(allocMain, outSizeCur);
-          if (temp == 0 &amp;&amp; outSizeCur != 0)
-            return SZ_ERROR_MEM;
-          outBufCur = tempBuf[1 - ci] = temp;
-          tempSizes[1 - ci] = outSizeCur;
-        }
-        else if (ci == 2)
-        {
-          if (unpackSize &gt; outSize) // check it
-            return SZ_ERROR_PARAM; // check it
-          tempBuf3 = outBufCur = outBuffer + (outSize - (size_t)unpackSize);
-          tempSize3 = outSizeCur = (size_t)unpackSize;
-        }
-        else
-          return SZ_ERROR_UNSUPPORTED;
-      }
-      offset = GetSum(packSizes, si);
-      inSize = packSizes[si];
-      /*
-      #ifdef _LZMA_IN_CB
-      */
-      RINOK(inStream-&gt;Seek(inStream, startPos + offset, SZ_SEEK_SET));
-      /*
-      #endif
-      */
-
-      if (coder-&gt;MethodID == k_Copy)
-      {
-        if (inSize != outSizeCur) // check it
-          return SZ_ERROR_DATA;
-        
-        /*
-        #ifdef _LZMA_IN_CB
-        */
-        RINOK(SzDecodeCopy(inSize, inStream, outBufCur));
-        /*
-        #else
-        memcpy(outBufCur, inBuffer + (size_t)offset, (size_t)inSize);
-        #endif
-        */
-      }
-      else
-      {
-        /*
-        #ifdef _LZMA_IN_CB
-        */
-        SRes res = SzDecodeLzma(coder, inSize,
-            inStream,
-            outBufCur, outSizeCur, allocMain);
-        /*
-        #else
-        SizeT lzmaOutSizeT = outSizeCur;
-        SizeT lzmaInSizeT = (SizeT)inSize;
-        SRes res = LzmaDecode(outBufCur, &amp;lzmaOutSizeT,
-            inBuffer + (size_t)offset, &amp;lzmaInSizeT,
-            coder-&gt;Props.Items, (unsigned)coder-&gt;Props.size, LZMA_FINISH_BYTE, allocMain);
-        #endif
-        */
-
-        RINOK(res);
-      }
-    }
-    else if (coder-&gt;MethodID == k_BCJ)
-    {
-      UInt32 state;
-      if (ci != 1)
-        return SZ_ERROR_UNSUPPORTED;
-      x86_Convert_Init(state);
-      x86_Convert(outBuffer, outSize, 0, &amp;state, 0);
-    }
-    else if (coder-&gt;MethodID == k_BCJ2)
-    {
-      CFileSize offset = GetSum(packSizes, 1);
-      CFileSize s3Size = packSizes[1];
-      SRes res;
-      if (ci != 3)
-        return SZ_ERROR_UNSUPPORTED;
-
-      /*
-      #ifdef _LZMA_IN_CB
-      */
-      RINOK(inStream-&gt;Seek(inStream, startPos + offset, SZ_SEEK_SET));
-      tempSizes[2] = (size_t)s3Size;
-      if (tempSizes[2] != s3Size)
-        return SZ_ERROR_MEM;
-      tempBuf[2] = (Byte *)IAlloc_Alloc(allocMain, tempSizes[2]);
-      if (tempBuf[2] == 0 &amp;&amp; tempSizes[2] != 0)
-        return SZ_ERROR_MEM;
-      res = SzDecodeCopy(s3Size, inStream, tempBuf[2]);
-      RINOK(res)
-      /*
-      #endif
-      */
-
-      res = Bcj2_Decode(
-          tempBuf3, tempSize3,
-          tempBuf[0], tempSizes[0],
-          tempBuf[1], tempSizes[1],
-          /*
-          #ifdef _LZMA_IN_CB
-          */
-          tempBuf[2], tempSizes[2],
-          /*
-          #else
-          inBuffer + (size_t)offset, (size_t)s3Size,
-          #endif
-          */
-          outBuffer, outSize);
-      RINOK(res)
-    }
-    else
-      return SZ_ERROR_UNSUPPORTED;
-  }
-  return SZ_OK;
-}
-
-SRes SzDecode(const CFileSize *packSizes, const CSzFolder *folder,
-    /*
-    #ifdef _LZMA_IN_CB
-    */
-    ISzInStream *inStream, CFileSize startPos,
-    /*
-    #else
-    const Byte *inBuffer,
-    #endif
-    */
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
-{
-  Byte *tempBuf[3] = { 0, 0, 0};
-  int i;
-  SRes res = SzDecode2(packSizes, folder,
-      /*
-      #ifdef _LZMA_IN_CB
-      */
-      inStream, startPos,
-      /*
-      #else
-      inBuffer,
-      #endif
-      */
-      outBuffer, outSize, allocMain, tempBuf);
-  for (i = 0; i &lt; 3; i++)
-    IAlloc_Free(allocMain, tempBuf[i]);
-  return res;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,339 @@
+/* 7zDecode.c  Decoding from 7z folder
+2008-08-05
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zDecode.h for license options */
+
+#include &lt;string.h&gt;
+
+#include &quot;7zDecode.h&quot;
+#include &quot;../../LzmaDec.h&quot;
+#include &quot;../../Bra.h&quot;
+#include &quot;../../Bcj2.h&quot;
+
+#define k_Copy 0
+#define k_LZMA 0x30101
+#define k_BCJ 0x03030103
+#define k_BCJ2 0x0303011B
+
+/*
+#ifdef _LZMA_IN_CB
+*/
+
+static SRes SzDecodeLzma(CSzCoderInfo *coder, CFileSize inSize, ISzInStream *inStream,
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
+{
+  CLzmaDec state;
+  int res = SZ_OK;
+  size_t _inSize;
+  Byte *inBuf = NULL;
+
+  LzmaDec_Construct(&amp;state);
+  RINOK(LzmaDec_AllocateProbs(&amp;state, coder-&gt;Props.data, (unsigned)coder-&gt;Props.size, allocMain));
+  state.dic = outBuffer;
+  state.dicBufSize = outSize;
+  LzmaDec_Init(&amp;state);
+
+  _inSize = 0;
+
+  for (;;)
+  {
+    if (_inSize == 0)
+    {
+      _inSize = (1 &lt;&lt; 18);
+      if (_inSize &gt; inSize)
+        _inSize = (size_t)(inSize);
+      res = inStream-&gt;Read((void *)inStream, (void **)&amp;inBuf, &amp;_inSize);
+      if (res != SZ_OK)
+        break;
+      inSize -= _inSize;
+    }
+
+    {
+      SizeT inProcessed = _inSize, dicPos = state.dicPos;
+      ELzmaStatus status;
+      res = LzmaDec_DecodeToDic(&amp;state, outSize, inBuf, &amp;inProcessed, LZMA_FINISH_END, &amp;status);
+      _inSize -= inProcessed;
+      inBuf = (Byte *)inBuf + inProcessed;
+      if (res != SZ_OK)
+        break;
+      if (state.dicPos == state.dicBufSize || (inProcessed == 0 &amp;&amp; dicPos == state.dicPos))
+      {
+        if (state.dicBufSize != outSize || _inSize != 0 ||
+            (status != LZMA_STATUS_FINISHED_WITH_MARK &amp;&amp;
+             status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK))
+          res = SZ_ERROR_DATA;
+        break;
+      }
+    }
+  }
+
+  LzmaDec_FreeProbs(&amp;state, allocMain);
+
+  return res;
+}
+
+static SRes SzDecodeCopy(CFileSize inSize, ISzInStream *inStream, Byte *outBuffer)
+{
+  while (inSize &gt; 0)
+  {
+    void *inBuffer;
+    size_t curSize = (1 &lt;&lt; 18);
+    if (curSize &gt; inSize)
+      curSize = (size_t)(inSize);
+    RINOK(inStream-&gt;Read((void *)inStream, (void **)&amp;inBuffer, &amp;curSize));
+    if (curSize == 0)
+      return SZ_ERROR_INPUT_EOF;
+    memcpy(outBuffer, inBuffer, curSize);
+    outBuffer += curSize;
+    inSize -= curSize;
+  }
+  return SZ_OK;
+}
+/*
+#endif
+*/
+
+#define IS_UNSUPPORTED_METHOD(m) ((m) != k_Copy &amp;&amp; (m) != k_LZMA)
+#define IS_UNSUPPORTED_CODER(c) (IS_UNSUPPORTED_METHOD(c.MethodID) || c.NumInStreams != 1 || c.NumOutStreams != 1)
+#define IS_NO_BCJ(c) (c.MethodID != k_BCJ || c.NumInStreams != 1 || c.NumOutStreams != 1)
+#define IS_NO_BCJ2(c) (c.MethodID != k_BCJ2 || c.NumInStreams != 4 || c.NumOutStreams != 1)
+
+SRes CheckSupportedFolder(const CSzFolder *f)
+{
+  if (f-&gt;NumCoders &lt; 1 || f-&gt;NumCoders &gt; 4)
+    return SZ_ERROR_UNSUPPORTED;
+  if (IS_UNSUPPORTED_CODER(f-&gt;Coders[0]))
+    return SZ_ERROR_UNSUPPORTED;
+  if (f-&gt;NumCoders == 1)
+  {
+    if (f-&gt;NumPackStreams != 1 || f-&gt;PackStreams[0] != 0 || f-&gt;NumBindPairs != 0)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  if (f-&gt;NumCoders == 2)
+  {
+    if (IS_NO_BCJ(f-&gt;Coders[1]) ||
+        f-&gt;NumPackStreams != 1 || f-&gt;PackStreams[0] != 0 ||
+        f-&gt;NumBindPairs != 1 ||
+        f-&gt;BindPairs[0].InIndex != 1 || f-&gt;BindPairs[0].OutIndex != 0)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  if (f-&gt;NumCoders == 4)
+  {
+    if (IS_UNSUPPORTED_CODER(f-&gt;Coders[1]) ||
+        IS_UNSUPPORTED_CODER(f-&gt;Coders[2]) ||
+        IS_NO_BCJ2(f-&gt;Coders[3]))
+      return SZ_ERROR_UNSUPPORTED;
+    if (f-&gt;NumPackStreams != 4 ||
+        f-&gt;PackStreams[0] != 2 ||
+        f-&gt;PackStreams[1] != 6 ||
+        f-&gt;PackStreams[2] != 1 ||
+        f-&gt;PackStreams[3] != 0 ||
+        f-&gt;NumBindPairs != 3 ||
+        f-&gt;BindPairs[0].InIndex != 5 || f-&gt;BindPairs[0].OutIndex != 0 ||
+        f-&gt;BindPairs[1].InIndex != 4 || f-&gt;BindPairs[1].OutIndex != 1 ||
+        f-&gt;BindPairs[2].InIndex != 3 || f-&gt;BindPairs[2].OutIndex != 2)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  return SZ_ERROR_UNSUPPORTED;
+}
+
+CFileSize GetSum(const CFileSize *values, UInt32 index)
+{
+  CFileSize sum = 0;
+  UInt32 i;
+  for (i = 0; i &lt; index; i++)
+    sum += values[i];
+  return sum;
+}
+
+SRes SzDecode2(const CFileSize *packSizes, const CSzFolder *folder,
+    /*
+    #ifdef _LZMA_IN_CB
+    */
+    ISzInStream *inStream, CFileSize startPos,
+    /*
+    #else
+    const Byte *inBuffer,
+    #endif
+    */
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain,
+    Byte *tempBuf[])
+{
+  UInt32 ci;
+  size_t tempSizes[3] = { 0, 0, 0};
+  size_t tempSize3 = 0;
+  Byte *tempBuf3 = 0;
+
+  RINOK(CheckSupportedFolder(folder));
+
+  for (ci = 0; ci &lt; folder-&gt;NumCoders; ci++)
+  {
+    CSzCoderInfo *coder = &amp;folder-&gt;Coders[ci];
+
+    if (coder-&gt;MethodID == k_Copy || coder-&gt;MethodID == k_LZMA)
+    {
+      UInt32 si = 0;
+      CFileSize offset;
+      CFileSize inSize;
+      Byte *outBufCur = outBuffer;
+      size_t outSizeCur = outSize;
+      if (folder-&gt;NumCoders == 4)
+      {
+        UInt32 indices[] = { 3, 2, 0 };
+        CFileSize unpackSize = folder-&gt;UnpackSizes[ci];
+        si = indices[ci];
+        if (ci &lt; 2)
+        {
+          Byte *temp;
+          outSizeCur = (size_t)unpackSize;
+          if (outSizeCur != unpackSize)
+            return SZ_ERROR_MEM;
+          temp = (Byte *)IAlloc_Alloc(allocMain, outSizeCur);
+          if (temp == 0 &amp;&amp; outSizeCur != 0)
+            return SZ_ERROR_MEM;
+          outBufCur = tempBuf[1 - ci] = temp;
+          tempSizes[1 - ci] = outSizeCur;
+        }
+        else if (ci == 2)
+        {
+          if (unpackSize &gt; outSize) // check it
+            return SZ_ERROR_PARAM; // check it
+          tempBuf3 = outBufCur = outBuffer + (outSize - (size_t)unpackSize);
+          tempSize3 = outSizeCur = (size_t)unpackSize;
+        }
+        else
+          return SZ_ERROR_UNSUPPORTED;
+      }
+      offset = GetSum(packSizes, si);
+      inSize = packSizes[si];
+      /*
+      #ifdef _LZMA_IN_CB
+      */
+      RINOK(inStream-&gt;Seek(inStream, startPos + offset, SZ_SEEK_SET));
+      /*
+      #endif
+      */
+
+      if (coder-&gt;MethodID == k_Copy)
+      {
+        if (inSize != outSizeCur) // check it
+          return SZ_ERROR_DATA;
+        
+        /*
+        #ifdef _LZMA_IN_CB
+        */
+        RINOK(SzDecodeCopy(inSize, inStream, outBufCur));
+        /*
+        #else
+        memcpy(outBufCur, inBuffer + (size_t)offset, (size_t)inSize);
+        #endif
+        */
+      }
+      else
+      {
+        /*
+        #ifdef _LZMA_IN_CB
+        */
+        SRes res = SzDecodeLzma(coder, inSize,
+            inStream,
+            outBufCur, outSizeCur, allocMain);
+        /*
+        #else
+        SizeT lzmaOutSizeT = outSizeCur;
+        SizeT lzmaInSizeT = (SizeT)inSize;
+        SRes res = LzmaDecode(outBufCur, &amp;lzmaOutSizeT,
+            inBuffer + (size_t)offset, &amp;lzmaInSizeT,
+            coder-&gt;Props.Items, (unsigned)coder-&gt;Props.size, LZMA_FINISH_BYTE, allocMain);
+        #endif
+        */
+
+        RINOK(res);
+      }
+    }
+    else if (coder-&gt;MethodID == k_BCJ)
+    {
+      UInt32 state;
+      if (ci != 1)
+        return SZ_ERROR_UNSUPPORTED;
+      x86_Convert_Init(state);
+      x86_Convert(outBuffer, outSize, 0, &amp;state, 0);
+    }
+    else if (coder-&gt;MethodID == k_BCJ2)
+    {
+      CFileSize offset = GetSum(packSizes, 1);
+      CFileSize s3Size = packSizes[1];
+      SRes res;
+      if (ci != 3)
+        return SZ_ERROR_UNSUPPORTED;
+
+      /*
+      #ifdef _LZMA_IN_CB
+      */
+      RINOK(inStream-&gt;Seek(inStream, startPos + offset, SZ_SEEK_SET));
+      tempSizes[2] = (size_t)s3Size;
+      if (tempSizes[2] != s3Size)
+        return SZ_ERROR_MEM;
+      tempBuf[2] = (Byte *)IAlloc_Alloc(allocMain, tempSizes[2]);
+      if (tempBuf[2] == 0 &amp;&amp; tempSizes[2] != 0)
+        return SZ_ERROR_MEM;
+      res = SzDecodeCopy(s3Size, inStream, tempBuf[2]);
+      RINOK(res)
+      /*
+      #endif
+      */
+
+      res = Bcj2_Decode(
+          tempBuf3, tempSize3,
+          tempBuf[0], tempSizes[0],
+          tempBuf[1], tempSizes[1],
+          /*
+          #ifdef _LZMA_IN_CB
+          */
+          tempBuf[2], tempSizes[2],
+          /*
+          #else
+          inBuffer + (size_t)offset, (size_t)s3Size,
+          #endif
+          */
+          outBuffer, outSize);
+      RINOK(res)
+    }
+    else
+      return SZ_ERROR_UNSUPPORTED;
+  }
+  return SZ_OK;
+}
+
+SRes SzDecode(const CFileSize *packSizes, const CSzFolder *folder,
+    /*
+    #ifdef _LZMA_IN_CB
+    */
+    ISzInStream *inStream, CFileSize startPos,
+    /*
+    #else
+    const Byte *inBuffer,
+    #endif
+    */
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
+{
+  Byte *tempBuf[3] = { 0, 0, 0};
+  int i;
+  SRes res = SzDecode2(packSizes, folder,
+      /*
+      #ifdef _LZMA_IN_CB
+      */
+      inStream, startPos,
+      /*
+      #else
+      inBuffer,
+      #endif
+      */
+      outBuffer, outSize, allocMain, tempBuf);
+  for (i = 0; i &lt; 3; i++)
+    IAlloc_Free(allocMain, tempBuf[i]);
+  return res;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,26 +0,0 @@
-/* 7zDecode.h -- Decoding from 7z folder
-2008-04-09
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zItem.h for license options */
-
-#ifndef __7Z_DECODE_H
-#define __7Z_DECODE_H
-
-#include &quot;7zItem.h&quot;
-
-#include &quot;7zIn.h&quot;
-
-SRes SzDecode(const CFileSize *packSizes, const CSzFolder *folder,
-    /*
-    #ifdef _LZMA_IN_CB
-    */
-    ISzInStream *stream, CFileSize startPos,
-    /*
-    #else
-    const Byte *inBuffer,
-    #endif
-    */
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,26 @@
+/* 7zDecode.h -- Decoding from 7z folder
+2008-04-09
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zItem.h for license options */
+
+#ifndef __7Z_DECODE_H
+#define __7Z_DECODE_H
+
+#include &quot;7zItem.h&quot;
+
+#include &quot;7zIn.h&quot;
+
+SRes SzDecode(const CFileSize *packSizes, const CSzFolder *folder,
+    /*
+    #ifdef _LZMA_IN_CB
+    */
+    ISzInStream *stream, CFileSize startPos,
+    /*
+    #else
+    const Byte *inBuffer,
+    #endif
+    */
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,96 +0,0 @@
-/* 7zExtract.c -- Extracting from 7z archive
-2008-08-17
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zExtract.h for license options */
-
-#include &quot;7zExtract.h&quot;
-#include &quot;7zDecode.h&quot;
-#include &quot;../../7zCrc.h&quot;
-
-SRes SzAr_Extract(
-    const CSzArEx *p,
-    ISzInStream *inStream,
-    UInt32 fileIndex,
-    UInt32 *blockIndex,
-    Byte **outBuffer,
-    size_t *outBufferSize,
-    size_t *offset,
-    size_t *outSizeProcessed,
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp)
-{
-  UInt32 folderIndex = p-&gt;FileIndexToFolderIndexMap[fileIndex];
-  SRes res = SZ_OK;
-  *offset = 0;
-  *outSizeProcessed = 0;
-  if (folderIndex == (UInt32)-1)
-  {
-    IAlloc_Free(allocMain, *outBuffer);
-    *blockIndex = folderIndex;
-    *outBuffer = 0;
-    *outBufferSize = 0;
-    return SZ_OK;
-  }
-
-  if (*outBuffer == 0 || *blockIndex != folderIndex)
-  {
-    CSzFolder *folder = p-&gt;db.Folders + folderIndex;
-    CFileSize unpackSizeSpec = SzFolder_GetUnpackSize(folder);
-    size_t unpackSize = (size_t)unpackSizeSpec;
-    CFileSize startOffset = SzArEx_GetFolderStreamPos(p, folderIndex, 0);
-
-    if (unpackSize != unpackSizeSpec)
-      return SZ_ERROR_MEM;
-    *blockIndex = folderIndex;
-    IAlloc_Free(allocMain, *outBuffer);
-    *outBuffer = 0;
-    
-    RINOK(inStream-&gt;Seek(inStream, startOffset, SZ_SEEK_SET));
-    
-    if (res == SZ_OK)
-    {
-      *outBufferSize = unpackSize;
-      if (unpackSize != 0)
-      {
-        *outBuffer = (Byte *)IAlloc_Alloc(allocMain, unpackSize);
-        if (*outBuffer == 0)
-          res = SZ_ERROR_MEM;
-      }
-      if (res == SZ_OK)
-      {
-        res = SzDecode(p-&gt;db.PackSizes +
-          p-&gt;FolderStartPackStreamIndex[folderIndex], folder,
-          inStream, startOffset,
-          *outBuffer, unpackSize, allocTemp);
-        if (res == SZ_OK)
-        {
-          if (folder-&gt;UnpackCRCDefined)
-          {
-            if (CrcCalc(*outBuffer, unpackSize) != folder-&gt;UnpackCRC)
-              res = SZ_ERROR_CRC;
-          }
-        }
-      }
-    }
-  }
-  if (res == SZ_OK)
-  {
-    UInt32 i;
-    CSzFileItem *fileItem = p-&gt;db.Files + fileIndex;
-    *offset = 0;
-    for (i = p-&gt;FolderStartFileIndex[folderIndex]; i &lt; fileIndex; i++)
-      *offset += (UInt32)p-&gt;db.Files[i].Size;
-    *outSizeProcessed = (size_t)fileItem-&gt;Size;
-    if (*offset + *outSizeProcessed &gt; *outBufferSize)
-      return SZ_ERROR_FAIL;
-    {
-      if (fileItem-&gt;FileCRCDefined)
-      {
-        if (CrcCalc(*outBuffer + *offset, *outSizeProcessed) != fileItem-&gt;FileCRC)
-          res = SZ_ERROR_CRC;
-      }
-    }
-  }
-  return res;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,96 @@
+/* 7zExtract.c -- Extracting from 7z archive
+2008-08-17
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zExtract.h for license options */
+
+#include &quot;7zExtract.h&quot;
+#include &quot;7zDecode.h&quot;
+#include &quot;../../7zCrc.h&quot;
+
+SRes SzAr_Extract(
+    const CSzArEx *p,
+    ISzInStream *inStream,
+    UInt32 fileIndex,
+    UInt32 *blockIndex,
+    Byte **outBuffer,
+    size_t *outBufferSize,
+    size_t *offset,
+    size_t *outSizeProcessed,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt32 folderIndex = p-&gt;FileIndexToFolderIndexMap[fileIndex];
+  SRes res = SZ_OK;
+  *offset = 0;
+  *outSizeProcessed = 0;
+  if (folderIndex == (UInt32)-1)
+  {
+    IAlloc_Free(allocMain, *outBuffer);
+    *blockIndex = folderIndex;
+    *outBuffer = 0;
+    *outBufferSize = 0;
+    return SZ_OK;
+  }
+
+  if (*outBuffer == 0 || *blockIndex != folderIndex)
+  {
+    CSzFolder *folder = p-&gt;db.Folders + folderIndex;
+    CFileSize unpackSizeSpec = SzFolder_GetUnpackSize(folder);
+    size_t unpackSize = (size_t)unpackSizeSpec;
+    CFileSize startOffset = SzArEx_GetFolderStreamPos(p, folderIndex, 0);
+
+    if (unpackSize != unpackSizeSpec)
+      return SZ_ERROR_MEM;
+    *blockIndex = folderIndex;
+    IAlloc_Free(allocMain, *outBuffer);
+    *outBuffer = 0;
+    
+    RINOK(inStream-&gt;Seek(inStream, startOffset, SZ_SEEK_SET));
+    
+    if (res == SZ_OK)
+    {
+      *outBufferSize = unpackSize;
+      if (unpackSize != 0)
+      {
+        *outBuffer = (Byte *)IAlloc_Alloc(allocMain, unpackSize);
+        if (*outBuffer == 0)
+          res = SZ_ERROR_MEM;
+      }
+      if (res == SZ_OK)
+      {
+        res = SzDecode(p-&gt;db.PackSizes +
+          p-&gt;FolderStartPackStreamIndex[folderIndex], folder,
+          inStream, startOffset,
+          *outBuffer, unpackSize, allocTemp);
+        if (res == SZ_OK)
+        {
+          if (folder-&gt;UnpackCRCDefined)
+          {
+            if (CrcCalc(*outBuffer, unpackSize) != folder-&gt;UnpackCRC)
+              res = SZ_ERROR_CRC;
+          }
+        }
+      }
+    }
+  }
+  if (res == SZ_OK)
+  {
+    UInt32 i;
+    CSzFileItem *fileItem = p-&gt;db.Files + fileIndex;
+    *offset = 0;
+    for (i = p-&gt;FolderStartFileIndex[folderIndex]; i &lt; fileIndex; i++)
+      *offset += (UInt32)p-&gt;db.Files[i].Size;
+    *outSizeProcessed = (size_t)fileItem-&gt;Size;
+    if (*offset + *outSizeProcessed &gt; *outBufferSize)
+      return SZ_ERROR_FAIL;
+    {
+      if (fileItem-&gt;FileCRCDefined)
+      {
+        if (CrcCalc(*outBuffer + *offset, *outSizeProcessed) != fileItem-&gt;FileCRC)
+          res = SZ_ERROR_CRC;
+      }
+    }
+  }
+  return res;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,44 +0,0 @@
-/* 7zExtract.h -- Extracting from 7z archive
-2008-08-05
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zItem.h for license options */
-
-#ifndef __7Z_EXTRACT_H
-#define __7Z_EXTRACT_H
-
-#include &quot;7zIn.h&quot;
-
-/*
-  SzExtract extracts file from archive
-
-  *outBuffer must be 0 before first call for each new archive.
-
-  Extracting cache:
-    If you need to decompress more than one file, you can send
-    these values from previous call:
-      *blockIndex,
-      *outBuffer,
-      *outBufferSize
-    You can consider &quot;*outBuffer&quot; as cache of solid block. If your archive is solid,
-    it will increase decompression speed.
-  
-    If you use external function, you can declare these 3 cache variables
-    (blockIndex, outBuffer, outBufferSize) as static in that external function.
-    
-    Free *outBuffer and set *outBuffer to 0, if you want to flush cache.
-*/
-
-SRes SzAr_Extract(
-    const CSzArEx *db,
-    ISzInStream *inStream,
-    UInt32 fileIndex,         /* index of file */
-    UInt32 *blockIndex,       /* index of solid block */
-    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
-    size_t *outBufferSize,    /* buffer size for output buffer */
-    size_t *offset,           /* offset of stream for required file in *outBuffer */
-    size_t *outSizeProcessed, /* size of file in *outBuffer */
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,44 @@
+/* 7zExtract.h -- Extracting from 7z archive
+2008-08-05
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zItem.h for license options */
+
+#ifndef __7Z_EXTRACT_H
+#define __7Z_EXTRACT_H
+
+#include &quot;7zIn.h&quot;
+
+/*
+  SzExtract extracts file from archive
+
+  *outBuffer must be 0 before first call for each new archive.
+
+  Extracting cache:
+    If you need to decompress more than one file, you can send
+    these values from previous call:
+      *blockIndex,
+      *outBuffer,
+      *outBufferSize
+    You can consider &quot;*outBuffer&quot; as cache of solid block. If your archive is solid,
+    it will increase decompression speed.
+  
+    If you use external function, you can declare these 3 cache variables
+    (blockIndex, outBuffer, outBufferSize) as static in that external function.
+    
+    Free *outBuffer and set *outBuffer to 0, if you want to flush cache.
+*/
+
+SRes SzAr_Extract(
+    const CSzArEx *db,
+    ISzInStream *inStream,
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,9 +0,0 @@
-/*  7zHeader.c -- 7z Headers
-2008-04-09
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zHeader.h for license options */
-
-#include &quot;7zHeader.h&quot;
-
-Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,9 @@
+/*  7zHeader.c -- 7z Headers
+2008-04-09
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zHeader.h for license options */
+
+#include &quot;7zHeader.h&quot;
+
+Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,59 +0,0 @@
-/* 7zHeader.h -- 7z Headers
-2008-07-14
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaDec.h for license options */
-
-#ifndef __7Z_HEADER_H
-#define __7Z_HEADER_H
-
-#include &quot;../../Types.h&quot;
-
-#define k7zSignatureSize 6
-extern Byte k7zSignature[k7zSignatureSize];
-
-#define k7zMajorVersion 0
-
-#define k7zStartHeaderSize 0x20
-
-enum EIdEnum
-{
-  k7zIdEnd,
-    
-  k7zIdHeader,
-    
-  k7zIdArchiveProperties,
-    
-  k7zIdAdditionalStreamsInfo,
-  k7zIdMainStreamsInfo,
-  k7zIdFilesInfo,
-  
-  k7zIdPackInfo,
-  k7zIdUnpackInfo,
-  k7zIdSubStreamsInfo,
-  
-  k7zIdSize,
-  k7zIdCRC,
-  
-  k7zIdFolder,
-  
-  k7zIdCodersUnpackSize,
-  k7zIdNumUnpackStream,
-  
-  k7zIdEmptyStream,
-  k7zIdEmptyFile,
-  k7zIdAnti,
-  
-  k7zIdName,
-  k7zIdCTime,
-  k7zIdATime,
-  k7zIdMTime,
-  k7zIdWinAttributes,
-  k7zIdComment,
-  
-  k7zIdEncodedHeader,
-  
-  k7zIdStartPos,
-  k7zIdDummy
-};
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,59 @@
+/* 7zHeader.h -- 7z Headers
+2008-07-14
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaDec.h for license options */
+
+#ifndef __7Z_HEADER_H
+#define __7Z_HEADER_H
+
+#include &quot;../../Types.h&quot;
+
+#define k7zSignatureSize 6
+extern Byte k7zSignature[k7zSignatureSize];
+
+#define k7zMajorVersion 0
+
+#define k7zStartHeaderSize 0x20
+
+enum EIdEnum
+{
+  k7zIdEnd,
+    
+  k7zIdHeader,
+    
+  k7zIdArchiveProperties,
+    
+  k7zIdAdditionalStreamsInfo,
+  k7zIdMainStreamsInfo,
+  k7zIdFilesInfo,
+  
+  k7zIdPackInfo,
+  k7zIdUnpackInfo,
+  k7zIdSubStreamsInfo,
+  
+  k7zIdSize,
+  k7zIdCRC,
+  
+  k7zIdFolder,
+  
+  k7zIdCodersUnpackSize,
+  k7zIdNumUnpackStream,
+  
+  k7zIdEmptyStream,
+  k7zIdEmptyFile,
+  k7zIdAnti,
+  
+  k7zIdName,
+  k7zIdCTime,
+  k7zIdATime,
+  k7zIdMTime,
+  k7zIdWinAttributes,
+  k7zIdComment,
+  
+  k7zIdEncodedHeader,
+  
+  k7zIdStartPos,
+  k7zIdDummy
+};
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,1265 +0,0 @@
-/* 7zIn.c -- 7z Input functions
-2008-08-17
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zIn.h for license options */
-
-#include &quot;7zIn.h&quot;
-#include &quot;7zDecode.h&quot;
-#include &quot;../../7zCrc.h&quot;
-
-#define RINOM(x) { if ((x) == 0) return SZ_ERROR_MEM; }
-
-void SzArEx_Init(CSzArEx *p)
-{
-  SzAr_Init(&amp;p-&gt;db);
-  p-&gt;FolderStartPackStreamIndex = 0;
-  p-&gt;PackStreamStartPositions = 0;
-  p-&gt;FolderStartFileIndex = 0;
-  p-&gt;FileIndexToFolderIndexMap = 0;
-}
-
-void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc)
-{
-  IAlloc_Free(alloc, p-&gt;FolderStartPackStreamIndex);
-  IAlloc_Free(alloc, p-&gt;PackStreamStartPositions);
-  IAlloc_Free(alloc, p-&gt;FolderStartFileIndex);
-  IAlloc_Free(alloc, p-&gt;FileIndexToFolderIndexMap);
-  SzAr_Free(&amp;p-&gt;db, alloc);
-  SzArEx_Init(p);
-}
-
-/*
-CFileSize GetFolderPackStreamSize(int folderIndex, int streamIndex) const
-{
-  return PackSizes[FolderStartPackStreamIndex[folderIndex] + streamIndex];
-}
-
-CFileSize GetFilePackSize(int fileIndex) const
-{
-  int folderIndex = FileIndexToFolderIndexMap[fileIndex];
-  if (folderIndex &gt;= 0)
-  {
-    const CSzFolder &amp;folderInfo = Folders[folderIndex];
-    if (FolderStartFileIndex[folderIndex] == fileIndex)
-    return GetFolderFullPackSize(folderIndex);
-  }
-  return 0;
-}
-*/
-
-#define MY_ALLOC(T, p, size, alloc) { if ((size) == 0) p = 0; else \
-  if ((p = (T *)IAlloc_Alloc(alloc, (size) * sizeof(T))) == 0) return SZ_ERROR_MEM; }
-
-static SRes SzArEx_Fill(CSzArEx *p, ISzAlloc *alloc)
-{
-  UInt32 startPos = 0;
-  CFileSize startPosSize = 0;
-  UInt32 i;
-  UInt32 folderIndex = 0;
-  UInt32 indexInFolder = 0;
-  MY_ALLOC(UInt32, p-&gt;FolderStartPackStreamIndex, p-&gt;db.NumFolders, alloc);
-  for (i = 0; i &lt; p-&gt;db.NumFolders; i++)
-  {
-    p-&gt;FolderStartPackStreamIndex[i] = startPos;
-    startPos += p-&gt;db.Folders[i].NumPackStreams;
-  }
-
-  MY_ALLOC(CFileSize, p-&gt;PackStreamStartPositions, p-&gt;db.NumPackStreams, alloc);
-
-  for (i = 0; i &lt; p-&gt;db.NumPackStreams; i++)
-  {
-    p-&gt;PackStreamStartPositions[i] = startPosSize;
-    startPosSize += p-&gt;db.PackSizes[i];
-  }
-
-  MY_ALLOC(UInt32, p-&gt;FolderStartFileIndex, p-&gt;db.NumFolders, alloc);
-  MY_ALLOC(UInt32, p-&gt;FileIndexToFolderIndexMap, p-&gt;db.NumFiles, alloc);
-
-  for (i = 0; i &lt; p-&gt;db.NumFiles; i++)
-  {
-    CSzFileItem *file = p-&gt;db.Files + i;
-    int emptyStream = !file-&gt;HasStream;
-    if (emptyStream &amp;&amp; indexInFolder == 0)
-    {
-      p-&gt;FileIndexToFolderIndexMap[i] = (UInt32)-1;
-      continue;
-    }
-    if (indexInFolder == 0)
-    {
-      /*
-      v3.13 incorrectly worked with empty folders
-      v4.07: Loop for skipping empty folders
-      */
-      for (;;)
-      {
-        if (folderIndex &gt;= p-&gt;db.NumFolders)
-          return SZ_ERROR_ARCHIVE;
-        p-&gt;FolderStartFileIndex[folderIndex] = i;
-        if (p-&gt;db.Folders[folderIndex].NumUnpackStreams != 0)
-          break;
-        folderIndex++;
-      }
-    }
-    p-&gt;FileIndexToFolderIndexMap[i] = folderIndex;
-    if (emptyStream)
-      continue;
-    indexInFolder++;
-    if (indexInFolder &gt;= p-&gt;db.Folders[folderIndex].NumUnpackStreams)
-    {
-      folderIndex++;
-      indexInFolder = 0;
-    }
-  }
-  return SZ_OK;
-}
-
-
-CFileSize SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder)
-{
-  return p-&gt;ArchiveInfo.DataStartPosition +
-    p-&gt;PackStreamStartPositions[p-&gt;FolderStartPackStreamIndex[folderIndex] + indexInFolder];
-}
-
-int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, CFileSize *resSize)
-{
-  UInt32 packStreamIndex = p-&gt;FolderStartPackStreamIndex[folderIndex];
-  CSzFolder *folder = p-&gt;db.Folders + folderIndex;
-  CFileSize size = 0;
-  UInt32 i;
-  for (i = 0; i &lt; folder-&gt;NumPackStreams; i++)
-  {
-    CFileSize t = size + p-&gt;db.PackSizes[packStreamIndex + i];
-    if (t &lt; size) // check it
-      return SZ_ERROR_FAIL;
-    size = t;
-  }
-  *resSize = size;
-  return SZ_OK;
-}
-
-
-/*
-SRes SzReadTime(const CObjectVector&lt;CBuf&gt; &amp;dataVector,
-    CObjectVector&lt;CSzFileItem&gt; &amp;files, UInt64 type)
-{
-  CBoolVector boolVector;
-  RINOK(ReadBoolVector2(files.Size(), boolVector))
-
-  CStreamSwitch streamSwitch;
-  RINOK(streamSwitch.Set(this, &amp;dataVector));
-
-  for (int i = 0; i &lt; files.Size(); i++)
-  {
-    CSzFileItem &amp;file = files[i];
-    CArchiveFileTime fileTime;
-    bool defined = boolVector[i];
-    if (defined)
-    {
-      UInt32 low, high;
-      RINOK(SzReadUInt32(low));
-      RINOK(SzReadUInt32(high));
-      fileTime.dwLowDateTime = low;
-      fileTime.dwHighDateTime = high;
-    }
-    switch(type)
-    {
-      case k7zIdCTime: file.IsCTimeDefined = defined; if (defined) file.CTime = fileTime; break;
-      case k7zIdATime: file.IsATimeDefined = defined; if (defined) file.ATime = fileTime; break;
-      case k7zIdMTime: file.IsMTimeDefined = defined; if (defined) file.MTime = fileTime; break;
-    }
-  }
-  return SZ_OK;
-}
-*/
-
-static SRes SafeReadDirect(ISzInStream *inStream, Byte *data, size_t size)
-{
-  while (size &gt; 0)
-  {
-    void *inBufferSpec;
-    size_t processedSize = size;
-    const Byte *inBuffer;
-    RINOK(inStream-&gt;Read(inStream, (void **)&amp;inBufferSpec, &amp;processedSize));
-    inBuffer = (const Byte *)inBufferSpec;
-    if (processedSize == 0)
-      return SZ_ERROR_INPUT_EOF;
-    size -= processedSize;
-    do
-      *data++ = *inBuffer++;
-    while (--processedSize != 0);
-  }
-  return SZ_OK;
-}
-
-static SRes SafeReadDirectByte(ISzInStream *inStream, Byte *data)
-{
-  return SafeReadDirect(inStream, data, 1);
-}
-
-static SRes SafeReadDirectUInt32(ISzInStream *inStream, UInt32 *value, UInt32 *crc)
-{
-  int i;
-  *value = 0;
-  for (i = 0; i &lt; 4; i++)
-  {
-    Byte b;
-    RINOK(SafeReadDirectByte(inStream, &amp;b));
-    *value |= ((UInt32)b &lt;&lt; (8 * i));
-    *crc = CRC_UPDATE_BYTE(*crc, b);
-  }
-  return SZ_OK;
-}
-
-static SRes SafeReadDirectUInt64(ISzInStream *inStream, UInt64 *value, UInt32 *crc)
-{
-  int i;
-  *value = 0;
-  for (i = 0; i &lt; 8; i++)
-  {
-    Byte b;
-    RINOK(SafeReadDirectByte(inStream, &amp;b));
-    *value |= ((UInt64)b &lt;&lt; (8 * i));
-    *crc = CRC_UPDATE_BYTE(*crc, b);
-  }
-  return SZ_OK;
-}
-
-static int TestSignatureCandidate(Byte *testBytes)
-{
-  size_t i;
-  for (i = 0; i &lt; k7zSignatureSize; i++)
-    if (testBytes[i] != k7zSignature[i])
-      return 0;
-  return 1;
-}
-
-typedef struct _CSzState
-{
-  Byte *Data;
-  size_t Size;
-}CSzData;
-
-static SRes SzReadByte(CSzData *sd, Byte *b)
-{
-  if (sd-&gt;Size == 0)
-    return SZ_ERROR_ARCHIVE;
-  sd-&gt;Size--;
-  *b = *sd-&gt;Data++;
-  return SZ_OK;
-}
-
-static SRes SzReadBytes(CSzData *sd, Byte *data, size_t size)
-{
-  size_t i;
-  for (i = 0; i &lt; size; i++)
-  {
-    RINOK(SzReadByte(sd, data + i));
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadUInt32(CSzData *sd, UInt32 *value)
-{
-  int i;
-  *value = 0;
-  for (i = 0; i &lt; 4; i++)
-  {
-    Byte b;
-    RINOK(SzReadByte(sd, &amp;b));
-    *value |= ((UInt32)(b) &lt;&lt; (8 * i));
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadNumber(CSzData *sd, UInt64 *value)
-{
-  Byte firstByte;
-  Byte mask = 0x80;
-  int i;
-  RINOK(SzReadByte(sd, &amp;firstByte));
-  *value = 0;
-  for (i = 0; i &lt; 8; i++)
-  {
-    Byte b;
-    if ((firstByte &amp; mask) == 0)
-    {
-      UInt64 highPart = firstByte &amp; (mask - 1);
-      *value += (highPart &lt;&lt; (8 * i));
-      return SZ_OK;
-    }
-    RINOK(SzReadByte(sd, &amp;b));
-    *value |= ((UInt64)b &lt;&lt; (8 * i));
-    mask &gt;&gt;= 1;
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadSize(CSzData *sd, CFileSize *value)
-{
-  UInt64 value64;
-  RINOK(SzReadNumber(sd, &amp;value64));
-  *value = (CFileSize)value64;
-  return SZ_OK;
-}
-
-static SRes SzReadNumber32(CSzData *sd, UInt32 *value)
-{
-  UInt64 value64;
-  RINOK(SzReadNumber(sd, &amp;value64));
-  if (value64 &gt;= 0x80000000)
-    return SZ_ERROR_UNSUPPORTED;
-  if (value64 &gt;= ((UInt64)(1) &lt;&lt; ((sizeof(size_t) - 1) * 8 + 2)))
-    return SZ_ERROR_UNSUPPORTED;
-  *value = (UInt32)value64;
-  return SZ_OK;
-}
-
-static SRes SzReadID(CSzData *sd, UInt64 *value)
-{
-  return SzReadNumber(sd, value);
-}
-
-static SRes SzSkeepDataSize(CSzData *sd, UInt64 size)
-{
-  if (size &gt; sd-&gt;Size)
-    return SZ_ERROR_ARCHIVE;
-  sd-&gt;Size -= (size_t)size;
-  sd-&gt;Data += (size_t)size;
-  return SZ_OK;
-}
-
-static SRes SzSkeepData(CSzData *sd)
-{
-  UInt64 size;
-  RINOK(SzReadNumber(sd, &amp;size));
-  return SzSkeepDataSize(sd, size);
-}
-
-static SRes SzReadArchiveProperties(CSzData *sd)
-{
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdEnd)
-      break;
-    SzSkeepData(sd);
-  }
-  return SZ_OK;
-}
-
-static SRes SzWaitAttribute(CSzData *sd, UInt64 attribute)
-{
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == attribute)
-      return SZ_OK;
-    if (type == k7zIdEnd)
-      return SZ_ERROR_ARCHIVE;
-    RINOK(SzSkeepData(sd));
-  }
-}
-
-static SRes SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
-{
-  Byte b = 0;
-  Byte mask = 0;
-  size_t i;
-  MY_ALLOC(Byte, *v, numItems, alloc);
-  for (i = 0; i &lt; numItems; i++)
-  {
-    if (mask == 0)
-    {
-      RINOK(SzReadByte(sd, &amp;b));
-      mask = 0x80;
-    }
-    (*v)[i] = (Byte)(((b &amp; mask) != 0) ? 1 : 0);
-    mask &gt;&gt;= 1;
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
-{
-  Byte allAreDefined;
-  size_t i;
-  RINOK(SzReadByte(sd, &amp;allAreDefined));
-  if (allAreDefined == 0)
-    return SzReadBoolVector(sd, numItems, v, alloc);
-  MY_ALLOC(Byte, *v, numItems, alloc);
-  for (i = 0; i &lt; numItems; i++)
-    (*v)[i] = 1;
-  return SZ_OK;
-}
-
-static SRes SzReadHashDigests(
-    CSzData *sd,
-    size_t numItems,
-    Byte **digestsDefined,
-    UInt32 **digests,
-    ISzAlloc *alloc)
-{
-  size_t i;
-  RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, alloc));
-  MY_ALLOC(UInt32, *digests, numItems, alloc);
-  for (i = 0; i &lt; numItems; i++)
-    if ((*digestsDefined)[i])
-    {
-      RINOK(SzReadUInt32(sd, (*digests) + i));
-    }
-  return SZ_OK;
-}
-
-static SRes SzReadPackInfo(
-    CSzData *sd,
-    CFileSize *dataOffset,
-    UInt32 *numPackStreams,
-    CFileSize **packSizes,
-    Byte **packCRCsDefined,
-    UInt32 **packCRCs,
-    ISzAlloc *alloc)
-{
-  UInt32 i;
-  RINOK(SzReadSize(sd, dataOffset));
-  RINOK(SzReadNumber32(sd, numPackStreams));
-
-  RINOK(SzWaitAttribute(sd, k7zIdSize));
-
-  MY_ALLOC(CFileSize, *packSizes, (size_t)*numPackStreams, alloc);
-
-  for (i = 0; i &lt; *numPackStreams; i++)
-  {
-    RINOK(SzReadSize(sd, (*packSizes) + i));
-  }
-
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdEnd)
-      break;
-    if (type == k7zIdCRC)
-    {
-      RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, alloc));
-      continue;
-    }
-    RINOK(SzSkeepData(sd));
-  }
-  if (*packCRCsDefined == 0)
-  {
-    MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, alloc);
-    MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);
-    for (i = 0; i &lt; *numPackStreams; i++)
-    {
-      (*packCRCsDefined)[i] = 0;
-      (*packCRCs)[i] = 0;
-    }
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadSwitch(CSzData *sd)
-{
-  Byte external;
-  RINOK(SzReadByte(sd, &amp;external));
-  return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;
-}
-
-static SRes SzGetNextFolderItem(CSzData *sd, CSzFolder *folder, ISzAlloc *alloc)
-{
-  UInt32 numCoders;
-  UInt32 numBindPairs;
-  UInt32 numPackedStreams;
-  UInt32 i;
-  UInt32 numInStreams = 0;
-  UInt32 numOutStreams = 0;
-  RINOK(SzReadNumber32(sd, &amp;numCoders));
-  folder-&gt;NumCoders = numCoders;
-
-  MY_ALLOC(CSzCoderInfo, folder-&gt;Coders, (size_t)numCoders, alloc);
-
-  for (i = 0; i &lt; numCoders; i++)
-    SzCoderInfo_Init(folder-&gt;Coders + i);
-
-  for (i = 0; i &lt; numCoders; i++)
-  {
-    Byte mainByte;
-    CSzCoderInfo *coder = folder-&gt;Coders + i;
-    {
-      unsigned idSize, j;
-      Byte longID[15];
-      RINOK(SzReadByte(sd, &amp;mainByte));
-      idSize = (unsigned)(mainByte &amp; 0xF);
-      RINOK(SzReadBytes(sd, longID, idSize));
-      if (idSize &gt; sizeof(coder-&gt;MethodID))
-        return SZ_ERROR_UNSUPPORTED;
-      coder-&gt;MethodID = 0;
-      for (j = 0; j &lt; idSize; j++)
-        coder-&gt;MethodID |= (CMethodID)longID[idSize - 1 - j] &lt;&lt; (8 * j);
-
-      if ((mainByte &amp; 0x10) != 0)
-      {
-        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumInStreams));
-        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumOutStreams));
-      }
-      else
-      {
-        coder-&gt;NumInStreams = 1;
-        coder-&gt;NumOutStreams = 1;
-      }
-      if ((mainByte &amp; 0x20) != 0)
-      {
-        UInt64 propertiesSize = 0;
-        RINOK(SzReadNumber(sd, &amp;propertiesSize));
-        if (!Buf_Create(&amp;coder-&gt;Props, (size_t)propertiesSize, alloc))
-          return SZ_ERROR_MEM;
-        RINOK(SzReadBytes(sd, coder-&gt;Props.data, (size_t)propertiesSize));
-      }
-    }
-    while ((mainByte &amp; 0x80) != 0)
-    {
-      RINOK(SzReadByte(sd, &amp;mainByte));
-      RINOK(SzSkeepDataSize(sd, (mainByte &amp; 0xF)));
-      if ((mainByte &amp; 0x10) != 0)
-      {
-        UInt32 n;
-        RINOK(SzReadNumber32(sd, &amp;n));
-        RINOK(SzReadNumber32(sd, &amp;n));
-      }
-      if ((mainByte &amp; 0x20) != 0)
-      {
-        UInt64 propertiesSize = 0;
-        RINOK(SzReadNumber(sd, &amp;propertiesSize));
-        RINOK(SzSkeepDataSize(sd, propertiesSize));
-      }
-    }
-    numInStreams += (UInt32)coder-&gt;NumInStreams;
-    numOutStreams += (UInt32)coder-&gt;NumOutStreams;
-  }
-
-  numBindPairs = numOutStreams - 1;
-  folder-&gt;NumBindPairs = numBindPairs;
-
-
-  MY_ALLOC(CBindPair, folder-&gt;BindPairs, (size_t)numBindPairs, alloc);
-
-  for (i = 0; i &lt; numBindPairs; i++)
-  {
-    CBindPair *bindPair = folder-&gt;BindPairs + i;;
-    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;InIndex));
-    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;OutIndex));
-  }
-
-  numPackedStreams = numInStreams - (UInt32)numBindPairs;
-
-  folder-&gt;NumPackStreams = numPackedStreams;
-  MY_ALLOC(UInt32, folder-&gt;PackStreams, (size_t)numPackedStreams, alloc);
-
-  if (numPackedStreams == 1)
-  {
-    UInt32 j;
-    UInt32 pi = 0;
-    for (j = 0; j &lt; numInStreams; j++)
-      if (SzFolder_FindBindPairForInStream(folder, j) &lt; 0)
-      {
-        folder-&gt;PackStreams[pi++] = j;
-        break;
-      }
-  }
-  else
-    for (i = 0; i &lt; numPackedStreams; i++)
-    {
-      RINOK(SzReadNumber32(sd, folder-&gt;PackStreams + i));
-    }
-  return SZ_OK;
-}
-
-static SRes SzReadUnpackInfo(
-    CSzData *sd,
-    UInt32 *numFolders,
-    CSzFolder **folders,  /* for alloc */
-    ISzAlloc *alloc,
-    ISzAlloc *allocTemp)
-{
-  UInt32 i;
-  RINOK(SzWaitAttribute(sd, k7zIdFolder));
-  RINOK(SzReadNumber32(sd, numFolders));
-  {
-    RINOK(SzReadSwitch(sd));
-
-    MY_ALLOC(CSzFolder, *folders, (size_t)*numFolders, alloc);
-
-    for (i = 0; i &lt; *numFolders; i++)
-      SzFolder_Init((*folders) + i);
-
-    for (i = 0; i &lt; *numFolders; i++)
-    {
-      RINOK(SzGetNextFolderItem(sd, (*folders) + i, alloc));
-    }
-  }
-
-  RINOK(SzWaitAttribute(sd, k7zIdCodersUnpackSize));
-
-  for (i = 0; i &lt; *numFolders; i++)
-  {
-    UInt32 j;
-    CSzFolder *folder = (*folders) + i;
-    UInt32 numOutStreams = SzFolder_GetNumOutStreams(folder);
-
-    MY_ALLOC(CFileSize, folder-&gt;UnpackSizes, (size_t)numOutStreams, alloc);
-
-    for (j = 0; j &lt; numOutStreams; j++)
-    {
-      RINOK(SzReadSize(sd, folder-&gt;UnpackSizes + j));
-    }
-  }
-
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdEnd)
-      return SZ_OK;
-    if (type == k7zIdCRC)
-    {
-      SRes res;
-      Byte *crcsDefined = 0;
-      UInt32 *crcs = 0;
-      res = SzReadHashDigests(sd, *numFolders, &amp;crcsDefined, &amp;crcs, allocTemp);
-      if (res == SZ_OK)
-      {
-        for (i = 0; i &lt; *numFolders; i++)
-        {
-          CSzFolder *folder = (*folders) + i;
-          folder-&gt;UnpackCRCDefined = crcsDefined[i];
-          folder-&gt;UnpackCRC = crcs[i];
-        }
-      }
-      IAlloc_Free(allocTemp, crcs);
-      IAlloc_Free(allocTemp, crcsDefined);
-      RINOK(res);
-      continue;
-    }
-    RINOK(SzSkeepData(sd));
-  }
-}
-
-static SRes SzReadSubStreamsInfo(
-    CSzData *sd,
-    UInt32 numFolders,
-    CSzFolder *folders,
-    UInt32 *numUnpackStreams,
-    CFileSize **unpackSizes,
-    Byte **digestsDefined,
-    UInt32 **digests,
-    ISzAlloc *allocTemp)
-{
-  UInt64 type = 0;
-  UInt32 i;
-  UInt32 si = 0;
-  UInt32 numDigests = 0;
-
-  for (i = 0; i &lt; numFolders; i++)
-    folders[i].NumUnpackStreams = 1;
-  *numUnpackStreams = numFolders;
-
-  for (;;)
-  {
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdNumUnpackStream)
-    {
-      *numUnpackStreams = 0;
-      for (i = 0; i &lt; numFolders; i++)
-      {
-        UInt32 numStreams;
-        RINOK(SzReadNumber32(sd, &amp;numStreams));
-        folders[i].NumUnpackStreams = numStreams;
-        *numUnpackStreams += numStreams;
-      }
-      continue;
-    }
-    if (type == k7zIdCRC || type == k7zIdSize)
-      break;
-    if (type == k7zIdEnd)
-      break;
-    RINOK(SzSkeepData(sd));
-  }
-
-  if (*numUnpackStreams == 0)
-  {
-    *unpackSizes = 0;
-    *digestsDefined = 0;
-    *digests = 0;
-  }
-  else
-  {
-    *unpackSizes = (CFileSize *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(CFileSize));
-    RINOM(*unpackSizes);
-    *digestsDefined = (Byte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(Byte));
-    RINOM(*digestsDefined);
-    *digests = (UInt32 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt32));
-    RINOM(*digests);
-  }
-
-  for (i = 0; i &lt; numFolders; i++)
-  {
-    /*
-    v3.13 incorrectly worked with empty folders
-    v4.07: we check that folder is empty
-    */
-    CFileSize sum = 0;
-    UInt32 j;
-    UInt32 numSubstreams = folders[i].NumUnpackStreams;
-    if (numSubstreams == 0)
-      continue;
-    if (type == k7zIdSize)
-    for (j = 1; j &lt; numSubstreams; j++)
-    {
-      CFileSize size;
-      RINOK(SzReadSize(sd, &amp;size));
-      (*unpackSizes)[si++] = size;
-      sum += size;
-    }
-    (*unpackSizes)[si++] = SzFolder_GetUnpackSize(folders + i) - sum;
-  }
-  if (type == k7zIdSize)
-  {
-    RINOK(SzReadID(sd, &amp;type));
-  }
-
-  for (i = 0; i &lt; *numUnpackStreams; i++)
-  {
-    (*digestsDefined)[i] = 0;
-    (*digests)[i] = 0;
-  }
-
-
-  for (i = 0; i &lt; numFolders; i++)
-  {
-    UInt32 numSubstreams = folders[i].NumUnpackStreams;
-    if (numSubstreams != 1 || !folders[i].UnpackCRCDefined)
-      numDigests += numSubstreams;
-  }
-
- 
-  si = 0;
-  for (;;)
-  {
-    if (type == k7zIdCRC)
-    {
-      int digestIndex = 0;
-      Byte *digestsDefined2 = 0;
-      UInt32 *digests2 = 0;
-      SRes res = SzReadHashDigests(sd, numDigests, &amp;digestsDefined2, &amp;digests2, allocTemp);
-      if (res == SZ_OK)
-      {
-        for (i = 0; i &lt; numFolders; i++)
-        {
-          CSzFolder *folder = folders + i;
-          UInt32 numSubstreams = folder-&gt;NumUnpackStreams;
-          if (numSubstreams == 1 &amp;&amp; folder-&gt;UnpackCRCDefined)
-          {
-            (*digestsDefined)[si] = 1;
-            (*digests)[si] = folder-&gt;UnpackCRC;
-            si++;
-          }
-          else
-          {
-            UInt32 j;
-            for (j = 0; j &lt; numSubstreams; j++, digestIndex++)
-            {
-              (*digestsDefined)[si] = digestsDefined2[digestIndex];
-              (*digests)[si] = digests2[digestIndex];
-              si++;
-            }
-          }
-        }
-      }
-      IAlloc_Free(allocTemp, digestsDefined2);
-      IAlloc_Free(allocTemp, digests2);
-      RINOK(res);
-    }
-    else if (type == k7zIdEnd)
-      return SZ_OK;
-    else
-    {
-      RINOK(SzSkeepData(sd));
-    }
-    RINOK(SzReadID(sd, &amp;type));
-  }
-}
-
-
-static SRes SzReadStreamsInfo(
-    CSzData *sd,
-    CFileSize *dataOffset,
-    CSzAr *p,
-    UInt32 *numUnpackStreams,
-    CFileSize **unpackSizes, /* allocTemp */
-    Byte **digestsDefined,   /* allocTemp */
-    UInt32 **digests,        /* allocTemp */
-    ISzAlloc *alloc,
-    ISzAlloc *allocTemp)
-{
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if ((UInt64)(int)type != type)
-      return SZ_ERROR_UNSUPPORTED;
-    switch((int)type)
-    {
-      case k7zIdEnd:
-        return SZ_OK;
-      case k7zIdPackInfo:
-      {
-        RINOK(SzReadPackInfo(sd, dataOffset, &amp;p-&gt;NumPackStreams,
-            &amp;p-&gt;PackSizes, &amp;p-&gt;PackCRCsDefined, &amp;p-&gt;PackCRCs, alloc));
-        break;
-      }
-      case k7zIdUnpackInfo:
-      {
-        RINOK(SzReadUnpackInfo(sd, &amp;p-&gt;NumFolders, &amp;p-&gt;Folders, alloc, allocTemp));
-        break;
-      }
-      case k7zIdSubStreamsInfo:
-      {
-        RINOK(SzReadSubStreamsInfo(sd, p-&gt;NumFolders, p-&gt;Folders,
-            numUnpackStreams, unpackSizes, digestsDefined, digests, allocTemp));
-        break;
-      }
-      default:
-        return SZ_ERROR_UNSUPPORTED;
-    }
-  }
-}
-
-Byte kUtf8Limits[5] = { 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
-
-static SRes SzReadFileNames(CSzData *sd, UInt32 numFiles, CSzFileItem *files, ISzAlloc *alloc)
-{
-  UInt32 i;
-  for (i = 0; i &lt; numFiles; i++)
-  {
-    UInt32 len = 0;
-    UInt32 pos = 0;
-    CSzFileItem *file = files + i;
-    while (pos + 2 &lt;= sd-&gt;Size)
-    {
-      int numAdds;
-      UInt32 value = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
-      pos += 2;
-      len++;
-      if (value == 0)
-        break;
-      if (value &lt; 0x80)
-        continue;
-      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
-      {
-        UInt32 c2;
-        if (value &gt;= 0xDC00)
-          return SZ_ERROR_ARCHIVE;
-        if (pos + 2 &gt; sd-&gt;Size)
-          return SZ_ERROR_ARCHIVE;
-        c2 = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
-        pos += 2;
-        if (c2 &lt; 0xDC00 || c2 &gt;= 0xE000)
-          return SZ_ERROR_ARCHIVE;
-        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
-      }
-      for (numAdds = 1; numAdds &lt; 5; numAdds++)
-        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
-          break;
-      len += numAdds;
-    }
-
-    MY_ALLOC(char, file-&gt;Name, (size_t)len, alloc);
-
-    len = 0;
-    while (2 &lt;= sd-&gt;Size)
-    {
-      int numAdds;
-      UInt32 value = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
-      SzSkeepDataSize(sd, 2);
-      if (value &lt; 0x80)
-      {
-        file-&gt;Name[len++] = (char)value;
-        if (value == 0)
-          break;
-        continue;
-      }
-      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
-      {
-        UInt32 c2 = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
-        SzSkeepDataSize(sd, 2);
-        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
-      }
-      for (numAdds = 1; numAdds &lt; 5; numAdds++)
-        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
-          break;
-      file-&gt;Name[len++] = (char)(kUtf8Limits[numAdds - 1] + (value &gt;&gt; (6 * numAdds)));
-      do
-      {
-        numAdds--;
-        file-&gt;Name[len++] = (char)(0x80 + ((value &gt;&gt; (6 * numAdds)) &amp; 0x3F));
-      }
-      while (numAdds &gt; 0);
-
-      len += numAdds;
-    }
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadHeader2(
-    CSzArEx *p,   /* allocMain */
-    CSzData *sd,
-    CFileSize **unpackSizes,  /* allocTemp */
-    Byte **digestsDefined,    /* allocTemp */
-    UInt32 **digests,         /* allocTemp */
-    Byte **emptyStreamVector, /* allocTemp */
-    Byte **emptyFileVector,   /* allocTemp */
-    Byte **lwtVector,         /* allocTemp */
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp)
-{
-  UInt64 type;
-  UInt32 numUnpackStreams = 0;
-  UInt32 numFiles = 0;
-  CSzFileItem *files = 0;
-  UInt32 numEmptyStreams = 0;
-  UInt32 i;
-
-  RINOK(SzReadID(sd, &amp;type));
-
-  if (type == k7zIdArchiveProperties)
-  {
-    RINOK(SzReadArchiveProperties(sd));
-    RINOK(SzReadID(sd, &amp;type));
-  }
- 
- 
-  if (type == k7zIdMainStreamsInfo)
-  {
-    RINOK(SzReadStreamsInfo(sd,
-        &amp;p-&gt;ArchiveInfo.DataStartPosition,
-        &amp;p-&gt;db,
-        &amp;numUnpackStreams,
-        unpackSizes,
-        digestsDefined,
-        digests, allocMain, allocTemp));
-    p-&gt;ArchiveInfo.DataStartPosition += p-&gt;ArchiveInfo.StartPositionAfterHeader;
-    RINOK(SzReadID(sd, &amp;type));
-  }
-
-  if (type == k7zIdEnd)
-    return SZ_OK;
-  if (type != k7zIdFilesInfo)
-    return SZ_ERROR_ARCHIVE;
-  
-  RINOK(SzReadNumber32(sd, &amp;numFiles));
-  p-&gt;db.NumFiles = numFiles;
-
-  MY_ALLOC(CSzFileItem, files, (size_t)numFiles, allocMain);
-
-  p-&gt;db.Files = files;
-  for (i = 0; i &lt; numFiles; i++)
-    SzFile_Init(files + i);
-
-  for (;;)
-  {
-    UInt64 type;
-    UInt64 size;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdEnd)
-      break;
-    RINOK(SzReadNumber(sd, &amp;size));
-
-    if ((UInt64)(int)type != type)
-    {
-      RINOK(SzSkeepDataSize(sd, size));
-    }
-    else
-    switch((int)type)
-    {
-      case k7zIdName:
-      {
-        RINOK(SzReadSwitch(sd));
-        RINOK(SzReadFileNames(sd, numFiles, files, allocMain))
-        break;
-      }
-      case k7zIdEmptyStream:
-      {
-        RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp));
-        numEmptyStreams = 0;
-        for (i = 0; i &lt; numFiles; i++)
-          if ((*emptyStreamVector)[i])
-            numEmptyStreams++;
-        break;
-      }
-      case k7zIdEmptyFile:
-      {
-        RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp));
-        break;
-      }
-      case k7zIdMTime:
-      {
-        RINOK(SzReadBoolVector2(sd, numFiles, lwtVector, allocTemp));
-        RINOK(SzReadSwitch(sd));
-        for (i = 0; i &lt; numFiles; i++)
-        {
-          CSzFileItem *f = &amp;files[i];
-          Byte defined = (*lwtVector)[i];
-          f-&gt;MTimeDefined = defined;
-          f-&gt;MTime.Low = f-&gt;MTime.High = 0;
-          if (defined)
-          {
-            RINOK(SzReadUInt32(sd, &amp;f-&gt;MTime.Low));
-            RINOK(SzReadUInt32(sd, &amp;f-&gt;MTime.High));
-          }
-        }
-        break;
-      }
-      default:
-      {
-        RINOK(SzSkeepDataSize(sd, size));
-      }
-    }
-  }
-
-  {
-    UInt32 emptyFileIndex = 0;
-    UInt32 sizeIndex = 0;
-    for (i = 0; i &lt; numFiles; i++)
-    {
-      CSzFileItem *file = files + i;
-      file-&gt;IsAnti = 0;
-      if (*emptyStreamVector == 0)
-        file-&gt;HasStream = 1;
-      else
-        file-&gt;HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
-      if (file-&gt;HasStream)
-      {
-        file-&gt;IsDir = 0;
-        file-&gt;Size = (*unpackSizes)[sizeIndex];
-        file-&gt;FileCRC = (*digests)[sizeIndex];
-        file-&gt;FileCRCDefined = (Byte)(*digestsDefined)[sizeIndex];
-        sizeIndex++;
-      }
-      else
-      {
-        if (*emptyFileVector == 0)
-          file-&gt;IsDir = 1;
-        else
-          file-&gt;IsDir = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
-        emptyFileIndex++;
-        file-&gt;Size = 0;
-        file-&gt;FileCRCDefined = 0;
-      }
-    }
-  }
-  return SzArEx_Fill(p, allocMain);
-}
-
-static SRes SzReadHeader(
-    CSzArEx *p,
-    CSzData *sd,
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp)
-{
-  CFileSize *unpackSizes = 0;
-  Byte *digestsDefined = 0;
-  UInt32 *digests = 0;
-  Byte *emptyStreamVector = 0;
-  Byte *emptyFileVector = 0;
-  Byte *lwtVector = 0;
-  SRes res = SzReadHeader2(p, sd,
-      &amp;unpackSizes, &amp;digestsDefined, &amp;digests,
-      &amp;emptyStreamVector, &amp;emptyFileVector, &amp;lwtVector,
-      allocMain, allocTemp);
-  IAlloc_Free(allocTemp, unpackSizes);
-  IAlloc_Free(allocTemp, digestsDefined);
-  IAlloc_Free(allocTemp, digests);
-  IAlloc_Free(allocTemp, emptyStreamVector);
-  IAlloc_Free(allocTemp, emptyFileVector);
-  IAlloc_Free(allocTemp, lwtVector);
-  return res;
-}
-
-static SRes SzReadAndDecodePackedStreams2(
-    ISzInStream *inStream,
-    CSzData *sd,
-    CBuf *outBuffer,
-    CFileSize baseOffset,
-    CSzAr *p,
-    CFileSize **unpackSizes,
-    Byte **digestsDefined,
-    UInt32 **digests,
-    ISzAlloc *allocTemp)
-{
-
-  UInt32 numUnpackStreams = 0;
-  CFileSize dataStartPos;
-  CSzFolder *folder;
-  CFileSize unpackSize;
-  SRes res;
-
-  RINOK(SzReadStreamsInfo(sd, &amp;dataStartPos, p,
-      &amp;numUnpackStreams,  unpackSizes, digestsDefined, digests,
-      allocTemp, allocTemp));
-  
-  dataStartPos += baseOffset;
-  if (p-&gt;NumFolders != 1)
-    return SZ_ERROR_ARCHIVE;
-
-  folder = p-&gt;Folders;
-  unpackSize = SzFolder_GetUnpackSize(folder);
-  
-  RINOK(inStream-&gt;Seek(inStream, dataStartPos, SZ_SEEK_SET));
-
-  if (!Buf_Create(outBuffer, (size_t)unpackSize, allocTemp))
-    return SZ_ERROR_MEM;
-  
-  res = SzDecode(p-&gt;PackSizes, folder,
-          inStream, dataStartPos,
-          outBuffer-&gt;data, (size_t)unpackSize, allocTemp);
-  RINOK(res);
-  if (folder-&gt;UnpackCRCDefined)
-    if (CrcCalc(outBuffer-&gt;data, (size_t)unpackSize) != folder-&gt;UnpackCRC)
-      return SZ_ERROR_CRC;
-  return SZ_OK;
-}
-
-static SRes SzReadAndDecodePackedStreams(
-    ISzInStream *inStream,
-    CSzData *sd,
-    CBuf *outBuffer,
-    CFileSize baseOffset,
-    ISzAlloc *allocTemp)
-{
-  CSzAr p;
-  CFileSize *unpackSizes = 0;
-  Byte *digestsDefined = 0;
-  UInt32 *digests = 0;
-  SRes res;
-  SzAr_Init(&amp;p);
-  res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset,
-    &amp;p, &amp;unpackSizes, &amp;digestsDefined, &amp;digests,
-    allocTemp);
-  SzAr_Free(&amp;p, allocTemp);
-  IAlloc_Free(allocTemp, unpackSizes);
-  IAlloc_Free(allocTemp, digestsDefined);
-  IAlloc_Free(allocTemp, digests);
-  return res;
-}
-
-static SRes SzArEx_Open2(
-    CSzArEx *p,
-    ISzInStream *inStream,
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp)
-{
-  Byte signature[k7zSignatureSize];
-  Byte version;
-  UInt32 crcFromArchive;
-  UInt64 nextHeaderOffset;
-  UInt64 nextHeaderSize;
-  UInt32 nextHeaderCRC;
-  UInt32 crc = 0;
-  CFileSize pos = 0;
-  CBuf buffer;
-  CSzData sd;
-  SRes res;
-
-  if (SafeReadDirect(inStream, signature, k7zSignatureSize) != SZ_OK)
-    return SZ_ERROR_NO_ARCHIVE;
-
-  if (!TestSignatureCandidate(signature))
-    return SZ_ERROR_NO_ARCHIVE;
-
-  /*
-  p.Clear();
-  p.ArchiveInfo.StartPosition = _arhiveBeginStreamPosition;
-  */
-  RINOK(SafeReadDirectByte(inStream, &amp;version));
-  if (version != k7zMajorVersion)
-    return SZ_ERROR_UNSUPPORTED;
-  RINOK(SafeReadDirectByte(inStream, &amp;version));
-
-  RINOK(SafeReadDirectUInt32(inStream, &amp;crcFromArchive, &amp;crc));
-
-  crc = CRC_INIT_VAL;
-  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderOffset, &amp;crc));
-  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderSize, &amp;crc));
-  RINOK(SafeReadDirectUInt32(inStream, &amp;nextHeaderCRC, &amp;crc));
-
-  pos = k7zStartHeaderSize;
-  p-&gt;ArchiveInfo.StartPositionAfterHeader = pos;
-  
-  if (CRC_GET_DIGEST(crc) != crcFromArchive)
-    return SZ_ERROR_CRC;
-
-  if (nextHeaderSize == 0)
-    return SZ_OK;
-
-  RINOK(inStream-&gt;Seek(inStream, (CFileSize)(pos + nextHeaderOffset), SZ_SEEK_SET));
-
-  if (!Buf_Create(&amp;buffer, (size_t)nextHeaderSize, allocTemp))
-    return SZ_ERROR_MEM;
-
-  res = SafeReadDirect(inStream, buffer.data, (size_t)nextHeaderSize);
-  if (res == SZ_OK)
-  {
-    res = SZ_ERROR_ARCHIVE;
-    if (CrcCalc(buffer.data, (size_t)nextHeaderSize) == nextHeaderCRC)
-    {
-      for (;;)
-      {
-        UInt64 type;
-        sd.Data = buffer.data;
-        sd.Size = buffer.size;
-        res = SzReadID(&amp;sd, &amp;type);
-        if (res != SZ_OK)
-          break;
-        if (type == k7zIdHeader)
-        {
-          res = SzReadHeader(p, &amp;sd, allocMain, allocTemp);
-          break;
-        }
-        if (type != k7zIdEncodedHeader)
-        {
-          res = SZ_ERROR_UNSUPPORTED;
-          break;
-        }
-        {
-          CBuf outBuffer;
-          Buf_Init(&amp;outBuffer);
-          res = SzReadAndDecodePackedStreams(inStream, &amp;sd, &amp;outBuffer,
-              p-&gt;ArchiveInfo.StartPositionAfterHeader,
-              allocTemp);
-          if (res != SZ_OK)
-          {
-            Buf_Free(&amp;outBuffer, allocTemp);
-            break;
-          }
-          Buf_Free(&amp;buffer, allocTemp);
-          buffer.data = outBuffer.data;
-          buffer.size = outBuffer.size;
-        }
-      }
-    }
-  }
-  Buf_Free(&amp;buffer, allocTemp);
-  return res;
-}
-
-SRes SzArEx_Open(CSzArEx *p, ISzInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp)
-{
-  SRes res = SzArEx_Open2(p, inStream, allocMain, allocTemp);
-  if (res != SZ_OK)
-    SzArEx_Free(p, allocMain);
-  return res;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,1265 @@
+/* 7zIn.c -- 7z Input functions
+2008-08-17
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zIn.h for license options */
+
+#include &quot;7zIn.h&quot;
+#include &quot;7zDecode.h&quot;
+#include &quot;../../7zCrc.h&quot;
+
+#define RINOM(x) { if ((x) == 0) return SZ_ERROR_MEM; }
+
+void SzArEx_Init(CSzArEx *p)
+{
+  SzAr_Init(&amp;p-&gt;db);
+  p-&gt;FolderStartPackStreamIndex = 0;
+  p-&gt;PackStreamStartPositions = 0;
+  p-&gt;FolderStartFileIndex = 0;
+  p-&gt;FileIndexToFolderIndexMap = 0;
+}
+
+void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc)
+{
+  IAlloc_Free(alloc, p-&gt;FolderStartPackStreamIndex);
+  IAlloc_Free(alloc, p-&gt;PackStreamStartPositions);
+  IAlloc_Free(alloc, p-&gt;FolderStartFileIndex);
+  IAlloc_Free(alloc, p-&gt;FileIndexToFolderIndexMap);
+  SzAr_Free(&amp;p-&gt;db, alloc);
+  SzArEx_Init(p);
+}
+
+/*
+CFileSize GetFolderPackStreamSize(int folderIndex, int streamIndex) const
+{
+  return PackSizes[FolderStartPackStreamIndex[folderIndex] + streamIndex];
+}
+
+CFileSize GetFilePackSize(int fileIndex) const
+{
+  int folderIndex = FileIndexToFolderIndexMap[fileIndex];
+  if (folderIndex &gt;= 0)
+  {
+    const CSzFolder &amp;folderInfo = Folders[folderIndex];
+    if (FolderStartFileIndex[folderIndex] == fileIndex)
+    return GetFolderFullPackSize(folderIndex);
+  }
+  return 0;
+}
+*/
+
+#define MY_ALLOC(T, p, size, alloc) { if ((size) == 0) p = 0; else \
+  if ((p = (T *)IAlloc_Alloc(alloc, (size) * sizeof(T))) == 0) return SZ_ERROR_MEM; }
+
+static SRes SzArEx_Fill(CSzArEx *p, ISzAlloc *alloc)
+{
+  UInt32 startPos = 0;
+  CFileSize startPosSize = 0;
+  UInt32 i;
+  UInt32 folderIndex = 0;
+  UInt32 indexInFolder = 0;
+  MY_ALLOC(UInt32, p-&gt;FolderStartPackStreamIndex, p-&gt;db.NumFolders, alloc);
+  for (i = 0; i &lt; p-&gt;db.NumFolders; i++)
+  {
+    p-&gt;FolderStartPackStreamIndex[i] = startPos;
+    startPos += p-&gt;db.Folders[i].NumPackStreams;
+  }
+
+  MY_ALLOC(CFileSize, p-&gt;PackStreamStartPositions, p-&gt;db.NumPackStreams, alloc);
+
+  for (i = 0; i &lt; p-&gt;db.NumPackStreams; i++)
+  {
+    p-&gt;PackStreamStartPositions[i] = startPosSize;
+    startPosSize += p-&gt;db.PackSizes[i];
+  }
+
+  MY_ALLOC(UInt32, p-&gt;FolderStartFileIndex, p-&gt;db.NumFolders, alloc);
+  MY_ALLOC(UInt32, p-&gt;FileIndexToFolderIndexMap, p-&gt;db.NumFiles, alloc);
+
+  for (i = 0; i &lt; p-&gt;db.NumFiles; i++)
+  {
+    CSzFileItem *file = p-&gt;db.Files + i;
+    int emptyStream = !file-&gt;HasStream;
+    if (emptyStream &amp;&amp; indexInFolder == 0)
+    {
+      p-&gt;FileIndexToFolderIndexMap[i] = (UInt32)-1;
+      continue;
+    }
+    if (indexInFolder == 0)
+    {
+      /*
+      v3.13 incorrectly worked with empty folders
+      v4.07: Loop for skipping empty folders
+      */
+      for (;;)
+      {
+        if (folderIndex &gt;= p-&gt;db.NumFolders)
+          return SZ_ERROR_ARCHIVE;
+        p-&gt;FolderStartFileIndex[folderIndex] = i;
+        if (p-&gt;db.Folders[folderIndex].NumUnpackStreams != 0)
+          break;
+        folderIndex++;
+      }
+    }
+    p-&gt;FileIndexToFolderIndexMap[i] = folderIndex;
+    if (emptyStream)
+      continue;
+    indexInFolder++;
+    if (indexInFolder &gt;= p-&gt;db.Folders[folderIndex].NumUnpackStreams)
+    {
+      folderIndex++;
+      indexInFolder = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+
+CFileSize SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder)
+{
+  return p-&gt;ArchiveInfo.DataStartPosition +
+    p-&gt;PackStreamStartPositions[p-&gt;FolderStartPackStreamIndex[folderIndex] + indexInFolder];
+}
+
+int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, CFileSize *resSize)
+{
+  UInt32 packStreamIndex = p-&gt;FolderStartPackStreamIndex[folderIndex];
+  CSzFolder *folder = p-&gt;db.Folders + folderIndex;
+  CFileSize size = 0;
+  UInt32 i;
+  for (i = 0; i &lt; folder-&gt;NumPackStreams; i++)
+  {
+    CFileSize t = size + p-&gt;db.PackSizes[packStreamIndex + i];
+    if (t &lt; size) // check it
+      return SZ_ERROR_FAIL;
+    size = t;
+  }
+  *resSize = size;
+  return SZ_OK;
+}
+
+
+/*
+SRes SzReadTime(const CObjectVector&lt;CBuf&gt; &amp;dataVector,
+    CObjectVector&lt;CSzFileItem&gt; &amp;files, UInt64 type)
+{
+  CBoolVector boolVector;
+  RINOK(ReadBoolVector2(files.Size(), boolVector))
+
+  CStreamSwitch streamSwitch;
+  RINOK(streamSwitch.Set(this, &amp;dataVector));
+
+  for (int i = 0; i &lt; files.Size(); i++)
+  {
+    CSzFileItem &amp;file = files[i];
+    CArchiveFileTime fileTime;
+    bool defined = boolVector[i];
+    if (defined)
+    {
+      UInt32 low, high;
+      RINOK(SzReadUInt32(low));
+      RINOK(SzReadUInt32(high));
+      fileTime.dwLowDateTime = low;
+      fileTime.dwHighDateTime = high;
+    }
+    switch(type)
+    {
+      case k7zIdCTime: file.IsCTimeDefined = defined; if (defined) file.CTime = fileTime; break;
+      case k7zIdATime: file.IsATimeDefined = defined; if (defined) file.ATime = fileTime; break;
+      case k7zIdMTime: file.IsMTimeDefined = defined; if (defined) file.MTime = fileTime; break;
+    }
+  }
+  return SZ_OK;
+}
+*/
+
+static SRes SafeReadDirect(ISzInStream *inStream, Byte *data, size_t size)
+{
+  while (size &gt; 0)
+  {
+    void *inBufferSpec;
+    size_t processedSize = size;
+    const Byte *inBuffer;
+    RINOK(inStream-&gt;Read(inStream, (void **)&amp;inBufferSpec, &amp;processedSize));
+    inBuffer = (const Byte *)inBufferSpec;
+    if (processedSize == 0)
+      return SZ_ERROR_INPUT_EOF;
+    size -= processedSize;
+    do
+      *data++ = *inBuffer++;
+    while (--processedSize != 0);
+  }
+  return SZ_OK;
+}
+
+static SRes SafeReadDirectByte(ISzInStream *inStream, Byte *data)
+{
+  return SafeReadDirect(inStream, data, 1);
+}
+
+static SRes SafeReadDirectUInt32(ISzInStream *inStream, UInt32 *value, UInt32 *crc)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 4; i++)
+  {
+    Byte b;
+    RINOK(SafeReadDirectByte(inStream, &amp;b));
+    *value |= ((UInt32)b &lt;&lt; (8 * i));
+    *crc = CRC_UPDATE_BYTE(*crc, b);
+  }
+  return SZ_OK;
+}
+
+static SRes SafeReadDirectUInt64(ISzInStream *inStream, UInt64 *value, UInt32 *crc)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 8; i++)
+  {
+    Byte b;
+    RINOK(SafeReadDirectByte(inStream, &amp;b));
+    *value |= ((UInt64)b &lt;&lt; (8 * i));
+    *crc = CRC_UPDATE_BYTE(*crc, b);
+  }
+  return SZ_OK;
+}
+
+static int TestSignatureCandidate(Byte *testBytes)
+{
+  size_t i;
+  for (i = 0; i &lt; k7zSignatureSize; i++)
+    if (testBytes[i] != k7zSignature[i])
+      return 0;
+  return 1;
+}
+
+typedef struct _CSzState
+{
+  Byte *Data;
+  size_t Size;
+}CSzData;
+
+static SRes SzReadByte(CSzData *sd, Byte *b)
+{
+  if (sd-&gt;Size == 0)
+    return SZ_ERROR_ARCHIVE;
+  sd-&gt;Size--;
+  *b = *sd-&gt;Data++;
+  return SZ_OK;
+}
+
+static SRes SzReadBytes(CSzData *sd, Byte *data, size_t size)
+{
+  size_t i;
+  for (i = 0; i &lt; size; i++)
+  {
+    RINOK(SzReadByte(sd, data + i));
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadUInt32(CSzData *sd, UInt32 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 4; i++)
+  {
+    Byte b;
+    RINOK(SzReadByte(sd, &amp;b));
+    *value |= ((UInt32)(b) &lt;&lt; (8 * i));
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadNumber(CSzData *sd, UInt64 *value)
+{
+  Byte firstByte;
+  Byte mask = 0x80;
+  int i;
+  RINOK(SzReadByte(sd, &amp;firstByte));
+  *value = 0;
+  for (i = 0; i &lt; 8; i++)
+  {
+    Byte b;
+    if ((firstByte &amp; mask) == 0)
+    {
+      UInt64 highPart = firstByte &amp; (mask - 1);
+      *value += (highPart &lt;&lt; (8 * i));
+      return SZ_OK;
+    }
+    RINOK(SzReadByte(sd, &amp;b));
+    *value |= ((UInt64)b &lt;&lt; (8 * i));
+    mask &gt;&gt;= 1;
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadSize(CSzData *sd, CFileSize *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &amp;value64));
+  *value = (CFileSize)value64;
+  return SZ_OK;
+}
+
+static SRes SzReadNumber32(CSzData *sd, UInt32 *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &amp;value64));
+  if (value64 &gt;= 0x80000000)
+    return SZ_ERROR_UNSUPPORTED;
+  if (value64 &gt;= ((UInt64)(1) &lt;&lt; ((sizeof(size_t) - 1) * 8 + 2)))
+    return SZ_ERROR_UNSUPPORTED;
+  *value = (UInt32)value64;
+  return SZ_OK;
+}
+
+static SRes SzReadID(CSzData *sd, UInt64 *value)
+{
+  return SzReadNumber(sd, value);
+}
+
+static SRes SzSkeepDataSize(CSzData *sd, UInt64 size)
+{
+  if (size &gt; sd-&gt;Size)
+    return SZ_ERROR_ARCHIVE;
+  sd-&gt;Size -= (size_t)size;
+  sd-&gt;Data += (size_t)size;
+  return SZ_OK;
+}
+
+static SRes SzSkeepData(CSzData *sd)
+{
+  UInt64 size;
+  RINOK(SzReadNumber(sd, &amp;size));
+  return SzSkeepDataSize(sd, size);
+}
+
+static SRes SzReadArchiveProperties(CSzData *sd)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    SzSkeepData(sd);
+  }
+  return SZ_OK;
+}
+
+static SRes SzWaitAttribute(CSzData *sd, UInt64 attribute)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == attribute)
+      return SZ_OK;
+    if (type == k7zIdEnd)
+      return SZ_ERROR_ARCHIVE;
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+static SRes SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+{
+  Byte b = 0;
+  Byte mask = 0;
+  size_t i;
+  MY_ALLOC(Byte, *v, numItems, alloc);
+  for (i = 0; i &lt; numItems; i++)
+  {
+    if (mask == 0)
+    {
+      RINOK(SzReadByte(sd, &amp;b));
+      mask = 0x80;
+    }
+    (*v)[i] = (Byte)(((b &amp; mask) != 0) ? 1 : 0);
+    mask &gt;&gt;= 1;
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+{
+  Byte allAreDefined;
+  size_t i;
+  RINOK(SzReadByte(sd, &amp;allAreDefined));
+  if (allAreDefined == 0)
+    return SzReadBoolVector(sd, numItems, v, alloc);
+  MY_ALLOC(Byte, *v, numItems, alloc);
+  for (i = 0; i &lt; numItems; i++)
+    (*v)[i] = 1;
+  return SZ_OK;
+}
+
+static SRes SzReadHashDigests(
+    CSzData *sd,
+    size_t numItems,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *alloc)
+{
+  size_t i;
+  RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, alloc));
+  MY_ALLOC(UInt32, *digests, numItems, alloc);
+  for (i = 0; i &lt; numItems; i++)
+    if ((*digestsDefined)[i])
+    {
+      RINOK(SzReadUInt32(sd, (*digests) + i));
+    }
+  return SZ_OK;
+}
+
+static SRes SzReadPackInfo(
+    CSzData *sd,
+    CFileSize *dataOffset,
+    UInt32 *numPackStreams,
+    CFileSize **packSizes,
+    Byte **packCRCsDefined,
+    UInt32 **packCRCs,
+    ISzAlloc *alloc)
+{
+  UInt32 i;
+  RINOK(SzReadSize(sd, dataOffset));
+  RINOK(SzReadNumber32(sd, numPackStreams));
+
+  RINOK(SzWaitAttribute(sd, k7zIdSize));
+
+  MY_ALLOC(CFileSize, *packSizes, (size_t)*numPackStreams, alloc);
+
+  for (i = 0; i &lt; *numPackStreams; i++)
+  {
+    RINOK(SzReadSize(sd, (*packSizes) + i));
+  }
+
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    if (type == k7zIdCRC)
+    {
+      RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, alloc));
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+  if (*packCRCsDefined == 0)
+  {
+    MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, alloc);
+    MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);
+    for (i = 0; i &lt; *numPackStreams; i++)
+    {
+      (*packCRCsDefined)[i] = 0;
+      (*packCRCs)[i] = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadSwitch(CSzData *sd)
+{
+  Byte external;
+  RINOK(SzReadByte(sd, &amp;external));
+  return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;
+}
+
+static SRes SzGetNextFolderItem(CSzData *sd, CSzFolder *folder, ISzAlloc *alloc)
+{
+  UInt32 numCoders;
+  UInt32 numBindPairs;
+  UInt32 numPackedStreams;
+  UInt32 i;
+  UInt32 numInStreams = 0;
+  UInt32 numOutStreams = 0;
+  RINOK(SzReadNumber32(sd, &amp;numCoders));
+  folder-&gt;NumCoders = numCoders;
+
+  MY_ALLOC(CSzCoderInfo, folder-&gt;Coders, (size_t)numCoders, alloc);
+
+  for (i = 0; i &lt; numCoders; i++)
+    SzCoderInfo_Init(folder-&gt;Coders + i);
+
+  for (i = 0; i &lt; numCoders; i++)
+  {
+    Byte mainByte;
+    CSzCoderInfo *coder = folder-&gt;Coders + i;
+    {
+      unsigned idSize, j;
+      Byte longID[15];
+      RINOK(SzReadByte(sd, &amp;mainByte));
+      idSize = (unsigned)(mainByte &amp; 0xF);
+      RINOK(SzReadBytes(sd, longID, idSize));
+      if (idSize &gt; sizeof(coder-&gt;MethodID))
+        return SZ_ERROR_UNSUPPORTED;
+      coder-&gt;MethodID = 0;
+      for (j = 0; j &lt; idSize; j++)
+        coder-&gt;MethodID |= (CMethodID)longID[idSize - 1 - j] &lt;&lt; (8 * j);
+
+      if ((mainByte &amp; 0x10) != 0)
+      {
+        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumInStreams));
+        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumOutStreams));
+      }
+      else
+      {
+        coder-&gt;NumInStreams = 1;
+        coder-&gt;NumOutStreams = 1;
+      }
+      if ((mainByte &amp; 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &amp;propertiesSize));
+        if (!Buf_Create(&amp;coder-&gt;Props, (size_t)propertiesSize, alloc))
+          return SZ_ERROR_MEM;
+        RINOK(SzReadBytes(sd, coder-&gt;Props.data, (size_t)propertiesSize));
+      }
+    }
+    while ((mainByte &amp; 0x80) != 0)
+    {
+      RINOK(SzReadByte(sd, &amp;mainByte));
+      RINOK(SzSkeepDataSize(sd, (mainByte &amp; 0xF)));
+      if ((mainByte &amp; 0x10) != 0)
+      {
+        UInt32 n;
+        RINOK(SzReadNumber32(sd, &amp;n));
+        RINOK(SzReadNumber32(sd, &amp;n));
+      }
+      if ((mainByte &amp; 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &amp;propertiesSize));
+        RINOK(SzSkeepDataSize(sd, propertiesSize));
+      }
+    }
+    numInStreams += (UInt32)coder-&gt;NumInStreams;
+    numOutStreams += (UInt32)coder-&gt;NumOutStreams;
+  }
+
+  numBindPairs = numOutStreams - 1;
+  folder-&gt;NumBindPairs = numBindPairs;
+
+
+  MY_ALLOC(CBindPair, folder-&gt;BindPairs, (size_t)numBindPairs, alloc);
+
+  for (i = 0; i &lt; numBindPairs; i++)
+  {
+    CBindPair *bindPair = folder-&gt;BindPairs + i;;
+    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;InIndex));
+    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;OutIndex));
+  }
+
+  numPackedStreams = numInStreams - (UInt32)numBindPairs;
+
+  folder-&gt;NumPackStreams = numPackedStreams;
+  MY_ALLOC(UInt32, folder-&gt;PackStreams, (size_t)numPackedStreams, alloc);
+
+  if (numPackedStreams == 1)
+  {
+    UInt32 j;
+    UInt32 pi = 0;
+    for (j = 0; j &lt; numInStreams; j++)
+      if (SzFolder_FindBindPairForInStream(folder, j) &lt; 0)
+      {
+        folder-&gt;PackStreams[pi++] = j;
+        break;
+      }
+  }
+  else
+    for (i = 0; i &lt; numPackedStreams; i++)
+    {
+      RINOK(SzReadNumber32(sd, folder-&gt;PackStreams + i));
+    }
+  return SZ_OK;
+}
+
+static SRes SzReadUnpackInfo(
+    CSzData *sd,
+    UInt32 *numFolders,
+    CSzFolder **folders,  /* for alloc */
+    ISzAlloc *alloc,
+    ISzAlloc *allocTemp)
+{
+  UInt32 i;
+  RINOK(SzWaitAttribute(sd, k7zIdFolder));
+  RINOK(SzReadNumber32(sd, numFolders));
+  {
+    RINOK(SzReadSwitch(sd));
+
+    MY_ALLOC(CSzFolder, *folders, (size_t)*numFolders, alloc);
+
+    for (i = 0; i &lt; *numFolders; i++)
+      SzFolder_Init((*folders) + i);
+
+    for (i = 0; i &lt; *numFolders; i++)
+    {
+      RINOK(SzGetNextFolderItem(sd, (*folders) + i, alloc));
+    }
+  }
+
+  RINOK(SzWaitAttribute(sd, k7zIdCodersUnpackSize));
+
+  for (i = 0; i &lt; *numFolders; i++)
+  {
+    UInt32 j;
+    CSzFolder *folder = (*folders) + i;
+    UInt32 numOutStreams = SzFolder_GetNumOutStreams(folder);
+
+    MY_ALLOC(CFileSize, folder-&gt;UnpackSizes, (size_t)numOutStreams, alloc);
+
+    for (j = 0; j &lt; numOutStreams; j++)
+    {
+      RINOK(SzReadSize(sd, folder-&gt;UnpackSizes + j));
+    }
+  }
+
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      return SZ_OK;
+    if (type == k7zIdCRC)
+    {
+      SRes res;
+      Byte *crcsDefined = 0;
+      UInt32 *crcs = 0;
+      res = SzReadHashDigests(sd, *numFolders, &amp;crcsDefined, &amp;crcs, allocTemp);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i &lt; *numFolders; i++)
+        {
+          CSzFolder *folder = (*folders) + i;
+          folder-&gt;UnpackCRCDefined = crcsDefined[i];
+          folder-&gt;UnpackCRC = crcs[i];
+        }
+      }
+      IAlloc_Free(allocTemp, crcs);
+      IAlloc_Free(allocTemp, crcsDefined);
+      RINOK(res);
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+static SRes SzReadSubStreamsInfo(
+    CSzData *sd,
+    UInt32 numFolders,
+    CSzFolder *folders,
+    UInt32 *numUnpackStreams,
+    CFileSize **unpackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type = 0;
+  UInt32 i;
+  UInt32 si = 0;
+  UInt32 numDigests = 0;
+
+  for (i = 0; i &lt; numFolders; i++)
+    folders[i].NumUnpackStreams = 1;
+  *numUnpackStreams = numFolders;
+
+  for (;;)
+  {
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdNumUnpackStream)
+    {
+      *numUnpackStreams = 0;
+      for (i = 0; i &lt; numFolders; i++)
+      {
+        UInt32 numStreams;
+        RINOK(SzReadNumber32(sd, &amp;numStreams));
+        folders[i].NumUnpackStreams = numStreams;
+        *numUnpackStreams += numStreams;
+      }
+      continue;
+    }
+    if (type == k7zIdCRC || type == k7zIdSize)
+      break;
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzSkeepData(sd));
+  }
+
+  if (*numUnpackStreams == 0)
+  {
+    *unpackSizes = 0;
+    *digestsDefined = 0;
+    *digests = 0;
+  }
+  else
+  {
+    *unpackSizes = (CFileSize *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(CFileSize));
+    RINOM(*unpackSizes);
+    *digestsDefined = (Byte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(Byte));
+    RINOM(*digestsDefined);
+    *digests = (UInt32 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt32));
+    RINOM(*digests);
+  }
+
+  for (i = 0; i &lt; numFolders; i++)
+  {
+    /*
+    v3.13 incorrectly worked with empty folders
+    v4.07: we check that folder is empty
+    */
+    CFileSize sum = 0;
+    UInt32 j;
+    UInt32 numSubstreams = folders[i].NumUnpackStreams;
+    if (numSubstreams == 0)
+      continue;
+    if (type == k7zIdSize)
+    for (j = 1; j &lt; numSubstreams; j++)
+    {
+      CFileSize size;
+      RINOK(SzReadSize(sd, &amp;size));
+      (*unpackSizes)[si++] = size;
+      sum += size;
+    }
+    (*unpackSizes)[si++] = SzFolder_GetUnpackSize(folders + i) - sum;
+  }
+  if (type == k7zIdSize)
+  {
+    RINOK(SzReadID(sd, &amp;type));
+  }
+
+  for (i = 0; i &lt; *numUnpackStreams; i++)
+  {
+    (*digestsDefined)[i] = 0;
+    (*digests)[i] = 0;
+  }
+
+
+  for (i = 0; i &lt; numFolders; i++)
+  {
+    UInt32 numSubstreams = folders[i].NumUnpackStreams;
+    if (numSubstreams != 1 || !folders[i].UnpackCRCDefined)
+      numDigests += numSubstreams;
+  }
+
+ 
+  si = 0;
+  for (;;)
+  {
+    if (type == k7zIdCRC)
+    {
+      int digestIndex = 0;
+      Byte *digestsDefined2 = 0;
+      UInt32 *digests2 = 0;
+      SRes res = SzReadHashDigests(sd, numDigests, &amp;digestsDefined2, &amp;digests2, allocTemp);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i &lt; numFolders; i++)
+        {
+          CSzFolder *folder = folders + i;
+          UInt32 numSubstreams = folder-&gt;NumUnpackStreams;
+          if (numSubstreams == 1 &amp;&amp; folder-&gt;UnpackCRCDefined)
+          {
+            (*digestsDefined)[si] = 1;
+            (*digests)[si] = folder-&gt;UnpackCRC;
+            si++;
+          }
+          else
+          {
+            UInt32 j;
+            for (j = 0; j &lt; numSubstreams; j++, digestIndex++)
+            {
+              (*digestsDefined)[si] = digestsDefined2[digestIndex];
+              (*digests)[si] = digests2[digestIndex];
+              si++;
+            }
+          }
+        }
+      }
+      IAlloc_Free(allocTemp, digestsDefined2);
+      IAlloc_Free(allocTemp, digests2);
+      RINOK(res);
+    }
+    else if (type == k7zIdEnd)
+      return SZ_OK;
+    else
+    {
+      RINOK(SzSkeepData(sd));
+    }
+    RINOK(SzReadID(sd, &amp;type));
+  }
+}
+
+
+static SRes SzReadStreamsInfo(
+    CSzData *sd,
+    CFileSize *dataOffset,
+    CSzAr *p,
+    UInt32 *numUnpackStreams,
+    CFileSize **unpackSizes, /* allocTemp */
+    Byte **digestsDefined,   /* allocTemp */
+    UInt32 **digests,        /* allocTemp */
+    ISzAlloc *alloc,
+    ISzAlloc *allocTemp)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if ((UInt64)(int)type != type)
+      return SZ_ERROR_UNSUPPORTED;
+    switch((int)type)
+    {
+      case k7zIdEnd:
+        return SZ_OK;
+      case k7zIdPackInfo:
+      {
+        RINOK(SzReadPackInfo(sd, dataOffset, &amp;p-&gt;NumPackStreams,
+            &amp;p-&gt;PackSizes, &amp;p-&gt;PackCRCsDefined, &amp;p-&gt;PackCRCs, alloc));
+        break;
+      }
+      case k7zIdUnpackInfo:
+      {
+        RINOK(SzReadUnpackInfo(sd, &amp;p-&gt;NumFolders, &amp;p-&gt;Folders, alloc, allocTemp));
+        break;
+      }
+      case k7zIdSubStreamsInfo:
+      {
+        RINOK(SzReadSubStreamsInfo(sd, p-&gt;NumFolders, p-&gt;Folders,
+            numUnpackStreams, unpackSizes, digestsDefined, digests, allocTemp));
+        break;
+      }
+      default:
+        return SZ_ERROR_UNSUPPORTED;
+    }
+  }
+}
+
+Byte kUtf8Limits[5] = { 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+static SRes SzReadFileNames(CSzData *sd, UInt32 numFiles, CSzFileItem *files, ISzAlloc *alloc)
+{
+  UInt32 i;
+  for (i = 0; i &lt; numFiles; i++)
+  {
+    UInt32 len = 0;
+    UInt32 pos = 0;
+    CSzFileItem *file = files + i;
+    while (pos + 2 &lt;= sd-&gt;Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
+      pos += 2;
+      len++;
+      if (value == 0)
+        break;
+      if (value &lt; 0x80)
+        continue;
+      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
+      {
+        UInt32 c2;
+        if (value &gt;= 0xDC00)
+          return SZ_ERROR_ARCHIVE;
+        if (pos + 2 &gt; sd-&gt;Size)
+          return SZ_ERROR_ARCHIVE;
+        c2 = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
+        pos += 2;
+        if (c2 &lt; 0xDC00 || c2 &gt;= 0xE000)
+          return SZ_ERROR_ARCHIVE;
+        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds &lt; 5; numAdds++)
+        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
+          break;
+      len += numAdds;
+    }
+
+    MY_ALLOC(char, file-&gt;Name, (size_t)len, alloc);
+
+    len = 0;
+    while (2 &lt;= sd-&gt;Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
+      SzSkeepDataSize(sd, 2);
+      if (value &lt; 0x80)
+      {
+        file-&gt;Name[len++] = (char)value;
+        if (value == 0)
+          break;
+        continue;
+      }
+      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
+      {
+        UInt32 c2 = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
+        SzSkeepDataSize(sd, 2);
+        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds &lt; 5; numAdds++)
+        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
+          break;
+      file-&gt;Name[len++] = (char)(kUtf8Limits[numAdds - 1] + (value &gt;&gt; (6 * numAdds)));
+      do
+      {
+        numAdds--;
+        file-&gt;Name[len++] = (char)(0x80 + ((value &gt;&gt; (6 * numAdds)) &amp; 0x3F));
+      }
+      while (numAdds &gt; 0);
+
+      len += numAdds;
+    }
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadHeader2(
+    CSzArEx *p,   /* allocMain */
+    CSzData *sd,
+    CFileSize **unpackSizes,  /* allocTemp */
+    Byte **digestsDefined,    /* allocTemp */
+    UInt32 **digests,         /* allocTemp */
+    Byte **emptyStreamVector, /* allocTemp */
+    Byte **emptyFileVector,   /* allocTemp */
+    Byte **lwtVector,         /* allocTemp */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type;
+  UInt32 numUnpackStreams = 0;
+  UInt32 numFiles = 0;
+  CSzFileItem *files = 0;
+  UInt32 numEmptyStreams = 0;
+  UInt32 i;
+
+  RINOK(SzReadID(sd, &amp;type));
+
+  if (type == k7zIdArchiveProperties)
+  {
+    RINOK(SzReadArchiveProperties(sd));
+    RINOK(SzReadID(sd, &amp;type));
+  }
+ 
+ 
+  if (type == k7zIdMainStreamsInfo)
+  {
+    RINOK(SzReadStreamsInfo(sd,
+        &amp;p-&gt;ArchiveInfo.DataStartPosition,
+        &amp;p-&gt;db,
+        &amp;numUnpackStreams,
+        unpackSizes,
+        digestsDefined,
+        digests, allocMain, allocTemp));
+    p-&gt;ArchiveInfo.DataStartPosition += p-&gt;ArchiveInfo.StartPositionAfterHeader;
+    RINOK(SzReadID(sd, &amp;type));
+  }
+
+  if (type == k7zIdEnd)
+    return SZ_OK;
+  if (type != k7zIdFilesInfo)
+    return SZ_ERROR_ARCHIVE;
+  
+  RINOK(SzReadNumber32(sd, &amp;numFiles));
+  p-&gt;db.NumFiles = numFiles;
+
+  MY_ALLOC(CSzFileItem, files, (size_t)numFiles, allocMain);
+
+  p-&gt;db.Files = files;
+  for (i = 0; i &lt; numFiles; i++)
+    SzFile_Init(files + i);
+
+  for (;;)
+  {
+    UInt64 type;
+    UInt64 size;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzReadNumber(sd, &amp;size));
+
+    if ((UInt64)(int)type != type)
+    {
+      RINOK(SzSkeepDataSize(sd, size));
+    }
+    else
+    switch((int)type)
+    {
+      case k7zIdName:
+      {
+        RINOK(SzReadSwitch(sd));
+        RINOK(SzReadFileNames(sd, numFiles, files, allocMain))
+        break;
+      }
+      case k7zIdEmptyStream:
+      {
+        RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp));
+        numEmptyStreams = 0;
+        for (i = 0; i &lt; numFiles; i++)
+          if ((*emptyStreamVector)[i])
+            numEmptyStreams++;
+        break;
+      }
+      case k7zIdEmptyFile:
+      {
+        RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp));
+        break;
+      }
+      case k7zIdMTime:
+      {
+        RINOK(SzReadBoolVector2(sd, numFiles, lwtVector, allocTemp));
+        RINOK(SzReadSwitch(sd));
+        for (i = 0; i &lt; numFiles; i++)
+        {
+          CSzFileItem *f = &amp;files[i];
+          Byte defined = (*lwtVector)[i];
+          f-&gt;MTimeDefined = defined;
+          f-&gt;MTime.Low = f-&gt;MTime.High = 0;
+          if (defined)
+          {
+            RINOK(SzReadUInt32(sd, &amp;f-&gt;MTime.Low));
+            RINOK(SzReadUInt32(sd, &amp;f-&gt;MTime.High));
+          }
+        }
+        break;
+      }
+      default:
+      {
+        RINOK(SzSkeepDataSize(sd, size));
+      }
+    }
+  }
+
+  {
+    UInt32 emptyFileIndex = 0;
+    UInt32 sizeIndex = 0;
+    for (i = 0; i &lt; numFiles; i++)
+    {
+      CSzFileItem *file = files + i;
+      file-&gt;IsAnti = 0;
+      if (*emptyStreamVector == 0)
+        file-&gt;HasStream = 1;
+      else
+        file-&gt;HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
+      if (file-&gt;HasStream)
+      {
+        file-&gt;IsDir = 0;
+        file-&gt;Size = (*unpackSizes)[sizeIndex];
+        file-&gt;FileCRC = (*digests)[sizeIndex];
+        file-&gt;FileCRCDefined = (Byte)(*digestsDefined)[sizeIndex];
+        sizeIndex++;
+      }
+      else
+      {
+        if (*emptyFileVector == 0)
+          file-&gt;IsDir = 1;
+        else
+          file-&gt;IsDir = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
+        emptyFileIndex++;
+        file-&gt;Size = 0;
+        file-&gt;FileCRCDefined = 0;
+      }
+    }
+  }
+  return SzArEx_Fill(p, allocMain);
+}
+
+static SRes SzReadHeader(
+    CSzArEx *p,
+    CSzData *sd,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  CFileSize *unpackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  Byte *emptyStreamVector = 0;
+  Byte *emptyFileVector = 0;
+  Byte *lwtVector = 0;
+  SRes res = SzReadHeader2(p, sd,
+      &amp;unpackSizes, &amp;digestsDefined, &amp;digests,
+      &amp;emptyStreamVector, &amp;emptyFileVector, &amp;lwtVector,
+      allocMain, allocTemp);
+  IAlloc_Free(allocTemp, unpackSizes);
+  IAlloc_Free(allocTemp, digestsDefined);
+  IAlloc_Free(allocTemp, digests);
+  IAlloc_Free(allocTemp, emptyStreamVector);
+  IAlloc_Free(allocTemp, emptyFileVector);
+  IAlloc_Free(allocTemp, lwtVector);
+  return res;
+}
+
+static SRes SzReadAndDecodePackedStreams2(
+    ISzInStream *inStream,
+    CSzData *sd,
+    CBuf *outBuffer,
+    CFileSize baseOffset,
+    CSzAr *p,
+    CFileSize **unpackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+
+  UInt32 numUnpackStreams = 0;
+  CFileSize dataStartPos;
+  CSzFolder *folder;
+  CFileSize unpackSize;
+  SRes res;
+
+  RINOK(SzReadStreamsInfo(sd, &amp;dataStartPos, p,
+      &amp;numUnpackStreams,  unpackSizes, digestsDefined, digests,
+      allocTemp, allocTemp));
+  
+  dataStartPos += baseOffset;
+  if (p-&gt;NumFolders != 1)
+    return SZ_ERROR_ARCHIVE;
+
+  folder = p-&gt;Folders;
+  unpackSize = SzFolder_GetUnpackSize(folder);
+  
+  RINOK(inStream-&gt;Seek(inStream, dataStartPos, SZ_SEEK_SET));
+
+  if (!Buf_Create(outBuffer, (size_t)unpackSize, allocTemp))
+    return SZ_ERROR_MEM;
+  
+  res = SzDecode(p-&gt;PackSizes, folder,
+          inStream, dataStartPos,
+          outBuffer-&gt;data, (size_t)unpackSize, allocTemp);
+  RINOK(res);
+  if (folder-&gt;UnpackCRCDefined)
+    if (CrcCalc(outBuffer-&gt;data, (size_t)unpackSize) != folder-&gt;UnpackCRC)
+      return SZ_ERROR_CRC;
+  return SZ_OK;
+}
+
+static SRes SzReadAndDecodePackedStreams(
+    ISzInStream *inStream,
+    CSzData *sd,
+    CBuf *outBuffer,
+    CFileSize baseOffset,
+    ISzAlloc *allocTemp)
+{
+  CSzAr p;
+  CFileSize *unpackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  SRes res;
+  SzAr_Init(&amp;p);
+  res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset,
+    &amp;p, &amp;unpackSizes, &amp;digestsDefined, &amp;digests,
+    allocTemp);
+  SzAr_Free(&amp;p, allocTemp);
+  IAlloc_Free(allocTemp, unpackSizes);
+  IAlloc_Free(allocTemp, digestsDefined);
+  IAlloc_Free(allocTemp, digests);
+  return res;
+}
+
+static SRes SzArEx_Open2(
+    CSzArEx *p,
+    ISzInStream *inStream,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  Byte signature[k7zSignatureSize];
+  Byte version;
+  UInt32 crcFromArchive;
+  UInt64 nextHeaderOffset;
+  UInt64 nextHeaderSize;
+  UInt32 nextHeaderCRC;
+  UInt32 crc = 0;
+  CFileSize pos = 0;
+  CBuf buffer;
+  CSzData sd;
+  SRes res;
+
+  if (SafeReadDirect(inStream, signature, k7zSignatureSize) != SZ_OK)
+    return SZ_ERROR_NO_ARCHIVE;
+
+  if (!TestSignatureCandidate(signature))
+    return SZ_ERROR_NO_ARCHIVE;
+
+  /*
+  p.Clear();
+  p.ArchiveInfo.StartPosition = _arhiveBeginStreamPosition;
+  */
+  RINOK(SafeReadDirectByte(inStream, &amp;version));
+  if (version != k7zMajorVersion)
+    return SZ_ERROR_UNSUPPORTED;
+  RINOK(SafeReadDirectByte(inStream, &amp;version));
+
+  RINOK(SafeReadDirectUInt32(inStream, &amp;crcFromArchive, &amp;crc));
+
+  crc = CRC_INIT_VAL;
+  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderOffset, &amp;crc));
+  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderSize, &amp;crc));
+  RINOK(SafeReadDirectUInt32(inStream, &amp;nextHeaderCRC, &amp;crc));
+
+  pos = k7zStartHeaderSize;
+  p-&gt;ArchiveInfo.StartPositionAfterHeader = pos;
+  
+  if (CRC_GET_DIGEST(crc) != crcFromArchive)
+    return SZ_ERROR_CRC;
+
+  if (nextHeaderSize == 0)
+    return SZ_OK;
+
+  RINOK(inStream-&gt;Seek(inStream, (CFileSize)(pos + nextHeaderOffset), SZ_SEEK_SET));
+
+  if (!Buf_Create(&amp;buffer, (size_t)nextHeaderSize, allocTemp))
+    return SZ_ERROR_MEM;
+
+  res = SafeReadDirect(inStream, buffer.data, (size_t)nextHeaderSize);
+  if (res == SZ_OK)
+  {
+    res = SZ_ERROR_ARCHIVE;
+    if (CrcCalc(buffer.data, (size_t)nextHeaderSize) == nextHeaderCRC)
+    {
+      for (;;)
+      {
+        UInt64 type;
+        sd.Data = buffer.data;
+        sd.Size = buffer.size;
+        res = SzReadID(&amp;sd, &amp;type);
+        if (res != SZ_OK)
+          break;
+        if (type == k7zIdHeader)
+        {
+          res = SzReadHeader(p, &amp;sd, allocMain, allocTemp);
+          break;
+        }
+        if (type != k7zIdEncodedHeader)
+        {
+          res = SZ_ERROR_UNSUPPORTED;
+          break;
+        }
+        {
+          CBuf outBuffer;
+          Buf_Init(&amp;outBuffer);
+          res = SzReadAndDecodePackedStreams(inStream, &amp;sd, &amp;outBuffer,
+              p-&gt;ArchiveInfo.StartPositionAfterHeader,
+              allocTemp);
+          if (res != SZ_OK)
+          {
+            Buf_Free(&amp;outBuffer, allocTemp);
+            break;
+          }
+          Buf_Free(&amp;buffer, allocTemp);
+          buffer.data = outBuffer.data;
+          buffer.size = outBuffer.size;
+        }
+      }
+    }
+  }
+  Buf_Free(&amp;buffer, allocTemp);
+  return res;
+}
+
+SRes SzArEx_Open(CSzArEx *p, ISzInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp)
+{
+  SRes res = SzArEx_Open2(p, inStream, allocMain, allocTemp);
+  if (res != SZ_OK)
+    SzArEx_Free(p, allocMain);
+  return res;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,63 +0,0 @@
-/* 7zIn.h -- 7z Input functions
-2008-08-05
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zItem.h for license options */
-
-#ifndef __7Z_IN_H
-#define __7Z_IN_H
-
-#include &quot;7zHeader.h&quot;
-#include &quot;7zItem.h&quot;
-
-typedef struct
-{
-  CFileSize StartPositionAfterHeader;
-  CFileSize DataStartPosition;
-} CInArchiveInfo;
-
-typedef struct
-{
-  CSzAr db;
-  CInArchiveInfo ArchiveInfo;
-  UInt32 *FolderStartPackStreamIndex;
-  CFileSize *PackStreamStartPositions;
-  UInt32 *FolderStartFileIndex;
-  UInt32 *FileIndexToFolderIndexMap;
-} CSzArEx;
-
-void SzArEx_Init(CSzArEx *p);
-void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc);
-CFileSize SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder);
-int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, CFileSize *resSize);
-
-typedef enum
-{
-  SZ_SEEK_SET = 0,
-  SZ_SEEK_CUR = 1,
-  SZ_SEEK_END = 2
-} ESzSeek;
-
-typedef struct
-{
-  SRes (*Read)(void *object, void **buf, size_t *size);
-    /* if (input(*size) != 0 &amp;&amp; output(*size) == 0) means end_of_stream.
-       (output(*size) &lt; input(*size)) is allowed */
-  SRes (*Seek)(void *object, CFileSize pos, ESzSeek origin);
-} ISzInStream;
-
- 
-/*
-Errors:
-SZ_ERROR_NO_ARCHIVE
-SZ_ERROR_ARCHIVE
-SZ_ERROR_UNSUPPORTED
-SZ_ERROR_MEM
-SZ_ERROR_CRC
-SZ_ERROR_INPUT_EOF
-SZ_ERROR_FAIL
-*/
-
-SRes SzArEx_Open(CSzArEx *p, ISzInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp);
- 
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,63 @@
+/* 7zIn.h -- 7z Input functions
+2008-08-05
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zItem.h for license options */
+
+#ifndef __7Z_IN_H
+#define __7Z_IN_H
+
+#include &quot;7zHeader.h&quot;
+#include &quot;7zItem.h&quot;
+
+typedef struct
+{
+  CFileSize StartPositionAfterHeader;
+  CFileSize DataStartPosition;
+} CInArchiveInfo;
+
+typedef struct
+{
+  CSzAr db;
+  CInArchiveInfo ArchiveInfo;
+  UInt32 *FolderStartPackStreamIndex;
+  CFileSize *PackStreamStartPositions;
+  UInt32 *FolderStartFileIndex;
+  UInt32 *FileIndexToFolderIndexMap;
+} CSzArEx;
+
+void SzArEx_Init(CSzArEx *p);
+void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc);
+CFileSize SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder);
+int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, CFileSize *resSize);
+
+typedef enum
+{
+  SZ_SEEK_SET = 0,
+  SZ_SEEK_CUR = 1,
+  SZ_SEEK_END = 2
+} ESzSeek;
+
+typedef struct
+{
+  SRes (*Read)(void *object, void **buf, size_t *size);
+    /* if (input(*size) != 0 &amp;&amp; output(*size) == 0) means end_of_stream.
+       (output(*size) &lt; input(*size)) is allowed */
+  SRes (*Seek)(void *object, CFileSize pos, ESzSeek origin);
+} ISzInStream;
+
+ 
+/*
+Errors:
+SZ_ERROR_NO_ARCHIVE
+SZ_ERROR_ARCHIVE
+SZ_ERROR_UNSUPPORTED
+SZ_ERROR_MEM
+SZ_ERROR_CRC
+SZ_ERROR_INPUT_EOF
+SZ_ERROR_FAIL
+*/
+
+SRes SzArEx_Open(CSzArEx *p, ISzInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp);
+ 
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,130 +0,0 @@
-/* 7zItem.c -- 7z Items
-2008-08-05
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zItem.h for license options */
-
-#include &quot;7zItem.h&quot;
-
-void SzCoderInfo_Init(CSzCoderInfo *p)
-{
-  Buf_Init(&amp;p-&gt;Props);
-}
-
-void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc)
-{
-  Buf_Free(&amp;p-&gt;Props, alloc);
-  SzCoderInfo_Init(p);
-}
-
-void SzFolder_Init(CSzFolder *p)
-{
-  p-&gt;Coders = 0;
-  p-&gt;BindPairs = 0;
-  p-&gt;PackStreams = 0;
-  p-&gt;UnpackSizes = 0;
-  p-&gt;NumCoders = 0;
-  p-&gt;NumBindPairs = 0;
-  p-&gt;NumPackStreams = 0;
-  p-&gt;UnpackCRCDefined = 0;
-  p-&gt;UnpackCRC = 0;
-  p-&gt;NumUnpackStreams = 0;
-}
-
-void SzFolder_Free(CSzFolder *p, ISzAlloc *alloc)
-{
-  UInt32 i;
-  if (p-&gt;Coders)
-    for (i = 0; i &lt; p-&gt;NumCoders; i++)
-      SzCoderInfo_Free(&amp;p-&gt;Coders[i], alloc);
-  IAlloc_Free(alloc, p-&gt;Coders);
-  IAlloc_Free(alloc, p-&gt;BindPairs);
-  IAlloc_Free(alloc, p-&gt;PackStreams);
-  IAlloc_Free(alloc, p-&gt;UnpackSizes);
-  SzFolder_Init(p);
-}
-
-UInt32 SzFolder_GetNumOutStreams(CSzFolder *p)
-{
-  UInt32 result = 0;
-  UInt32 i;
-  for (i = 0; i &lt; p-&gt;NumCoders; i++)
-    result += p-&gt;Coders[i].NumOutStreams;
-  return result;
-}
-
-int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex)
-{
-  UInt32 i;
-  for (i = 0; i &lt; p-&gt;NumBindPairs; i++)
-    if (p-&gt;BindPairs[i].InIndex == inStreamIndex)
-      return i;
-  return -1;
-}
-
-
-int SzFolder_FindBindPairForOutStream(CSzFolder *p, UInt32 outStreamIndex)
-{
-  UInt32 i;
-  for (i = 0; i &lt; p-&gt;NumBindPairs; i++)
-    if (p-&gt;BindPairs[i].OutIndex == outStreamIndex)
-      return i;
-  return -1;
-}
-
-CFileSize SzFolder_GetUnpackSize(CSzFolder *p)
-{
-  int i = (int)SzFolder_GetNumOutStreams(p);
-  if (i == 0)
-    return 0;
-  for (i--; i &gt;= 0; i--)
-    if (SzFolder_FindBindPairForOutStream(p, i) &lt; 0)
-      return p-&gt;UnpackSizes[i];
-  /* throw 1; */
-  return 0;
-}
-
-void SzFile_Init(CSzFileItem *p)
-{
-  p-&gt;HasStream = 1;
-  p-&gt;IsDir = 0;
-  p-&gt;IsAnti = 0;
-  p-&gt;FileCRCDefined = 0;
-  p-&gt;MTimeDefined = 0;
-  p-&gt;Name = 0;
-}
-
-static void SzFile_Free(CSzFileItem *p, ISzAlloc *alloc)
-{
-  IAlloc_Free(alloc, p-&gt;Name);
-  SzFile_Init(p);
-}
-
-void SzAr_Init(CSzAr *p)
-{
-  p-&gt;PackSizes = 0;
-  p-&gt;PackCRCsDefined = 0;
-  p-&gt;PackCRCs = 0;
-  p-&gt;Folders = 0;
-  p-&gt;Files = 0;
-  p-&gt;NumPackStreams = 0;
-  p-&gt;NumFolders = 0;
-  p-&gt;NumFiles = 0;
-}
-
-void SzAr_Free(CSzAr *p, ISzAlloc *alloc)
-{
-  UInt32 i;
-  if (p-&gt;Folders)
-    for (i = 0; i &lt; p-&gt;NumFolders; i++)
-      SzFolder_Free(&amp;p-&gt;Folders[i], alloc);
-  if (p-&gt;Files)
-    for (i = 0; i &lt; p-&gt;NumFiles; i++)
-      SzFile_Free(&amp;p-&gt;Files[i], alloc);
-  IAlloc_Free(alloc, p-&gt;PackSizes);
-  IAlloc_Free(alloc, p-&gt;PackCRCsDefined);
-  IAlloc_Free(alloc, p-&gt;PackCRCs);
-  IAlloc_Free(alloc, p-&gt;Folders);
-  IAlloc_Free(alloc, p-&gt;Files);
-  SzAr_Init(p);
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,130 @@
+/* 7zItem.c -- 7z Items
+2008-08-05
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zItem.h for license options */
+
+#include &quot;7zItem.h&quot;
+
+void SzCoderInfo_Init(CSzCoderInfo *p)
+{
+  Buf_Init(&amp;p-&gt;Props);
+}
+
+void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc)
+{
+  Buf_Free(&amp;p-&gt;Props, alloc);
+  SzCoderInfo_Init(p);
+}
+
+void SzFolder_Init(CSzFolder *p)
+{
+  p-&gt;Coders = 0;
+  p-&gt;BindPairs = 0;
+  p-&gt;PackStreams = 0;
+  p-&gt;UnpackSizes = 0;
+  p-&gt;NumCoders = 0;
+  p-&gt;NumBindPairs = 0;
+  p-&gt;NumPackStreams = 0;
+  p-&gt;UnpackCRCDefined = 0;
+  p-&gt;UnpackCRC = 0;
+  p-&gt;NumUnpackStreams = 0;
+}
+
+void SzFolder_Free(CSzFolder *p, ISzAlloc *alloc)
+{
+  UInt32 i;
+  if (p-&gt;Coders)
+    for (i = 0; i &lt; p-&gt;NumCoders; i++)
+      SzCoderInfo_Free(&amp;p-&gt;Coders[i], alloc);
+  IAlloc_Free(alloc, p-&gt;Coders);
+  IAlloc_Free(alloc, p-&gt;BindPairs);
+  IAlloc_Free(alloc, p-&gt;PackStreams);
+  IAlloc_Free(alloc, p-&gt;UnpackSizes);
+  SzFolder_Init(p);
+}
+
+UInt32 SzFolder_GetNumOutStreams(CSzFolder *p)
+{
+  UInt32 result = 0;
+  UInt32 i;
+  for (i = 0; i &lt; p-&gt;NumCoders; i++)
+    result += p-&gt;Coders[i].NumOutStreams;
+  return result;
+}
+
+int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex)
+{
+  UInt32 i;
+  for (i = 0; i &lt; p-&gt;NumBindPairs; i++)
+    if (p-&gt;BindPairs[i].InIndex == inStreamIndex)
+      return i;
+  return -1;
+}
+
+
+int SzFolder_FindBindPairForOutStream(CSzFolder *p, UInt32 outStreamIndex)
+{
+  UInt32 i;
+  for (i = 0; i &lt; p-&gt;NumBindPairs; i++)
+    if (p-&gt;BindPairs[i].OutIndex == outStreamIndex)
+      return i;
+  return -1;
+}
+
+CFileSize SzFolder_GetUnpackSize(CSzFolder *p)
+{
+  int i = (int)SzFolder_GetNumOutStreams(p);
+  if (i == 0)
+    return 0;
+  for (i--; i &gt;= 0; i--)
+    if (SzFolder_FindBindPairForOutStream(p, i) &lt; 0)
+      return p-&gt;UnpackSizes[i];
+  /* throw 1; */
+  return 0;
+}
+
+void SzFile_Init(CSzFileItem *p)
+{
+  p-&gt;HasStream = 1;
+  p-&gt;IsDir = 0;
+  p-&gt;IsAnti = 0;
+  p-&gt;FileCRCDefined = 0;
+  p-&gt;MTimeDefined = 0;
+  p-&gt;Name = 0;
+}
+
+static void SzFile_Free(CSzFileItem *p, ISzAlloc *alloc)
+{
+  IAlloc_Free(alloc, p-&gt;Name);
+  SzFile_Init(p);
+}
+
+void SzAr_Init(CSzAr *p)
+{
+  p-&gt;PackSizes = 0;
+  p-&gt;PackCRCsDefined = 0;
+  p-&gt;PackCRCs = 0;
+  p-&gt;Folders = 0;
+  p-&gt;Files = 0;
+  p-&gt;NumPackStreams = 0;
+  p-&gt;NumFolders = 0;
+  p-&gt;NumFiles = 0;
+}
+
+void SzAr_Free(CSzAr *p, ISzAlloc *alloc)
+{
+  UInt32 i;
+  if (p-&gt;Folders)
+    for (i = 0; i &lt; p-&gt;NumFolders; i++)
+      SzFolder_Free(&amp;p-&gt;Folders[i], alloc);
+  if (p-&gt;Files)
+    for (i = 0; i &lt; p-&gt;NumFiles; i++)
+      SzFile_Free(&amp;p-&gt;Files[i], alloc);
+  IAlloc_Free(alloc, p-&gt;PackSizes);
+  IAlloc_Free(alloc, p-&gt;PackCRCsDefined);
+  IAlloc_Free(alloc, p-&gt;PackCRCs);
+  IAlloc_Free(alloc, p-&gt;Folders);
+  IAlloc_Free(alloc, p-&gt;Files);
+  SzAr_Init(p);
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,98 +0,0 @@
-/* 7zItem.h -- 7z Items
-2008-07-09
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaDec.h for license options */
-
-#ifndef __7Z_ITEM_H
-#define __7Z_ITEM_H
-
-#include &quot;../../7zBuf.h&quot;
-
-/* #define _SZ_FILE_SIZE_32 */
-/* You can define _SZ_FILE_SIZE_32, if you don't need support for files larger than 4 GB*/
-
-#ifdef _SZ_FILE_SIZE_32
-typedef UInt32 CFileSize;
-#else
-typedef UInt64 CFileSize;
-#endif
-
-typedef UInt64 CMethodID;
-
-typedef struct
-{
-  UInt32 NumInStreams;
-  UInt32 NumOutStreams;
-  CMethodID MethodID;
-  CBuf Props;
-} CSzCoderInfo;
-
-void SzCoderInfo_Init(CSzCoderInfo *p);
-void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc);
-
-typedef struct
-{
-  UInt32 InIndex;
-  UInt32 OutIndex;
-} CBindPair;
-
-typedef struct
-{
-  CSzCoderInfo *Coders;
-  CBindPair *BindPairs;
-  UInt32 *PackStreams;
-  CFileSize *UnpackSizes;
-  UInt32 NumCoders;
-  UInt32 NumBindPairs;
-  UInt32 NumPackStreams;
-  int UnpackCRCDefined;
-  UInt32 UnpackCRC;
-
-  UInt32 NumUnpackStreams;
-} CSzFolder;
-
-void SzFolder_Init(CSzFolder *p);
-CFileSize SzFolder_GetUnpackSize(CSzFolder *p);
-int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex);
-UInt32 SzFolder_GetNumOutStreams(CSzFolder *p);
-CFileSize SzFolder_GetUnpackSize(CSzFolder *p);
-
-typedef struct
-{
-  UInt32 Low;
-  UInt32 High;
-} CNtfsFileTime;
-
-typedef struct
-{
-  CNtfsFileTime MTime;
-  CFileSize Size;
-  char *Name;
-  UInt32 FileCRC;
-
-  Byte HasStream;
-  Byte IsDir;
-  Byte IsAnti;
-  Byte FileCRCDefined;
-  Byte MTimeDefined;
-} CSzFileItem;
-
-void SzFile_Init(CSzFileItem *p);
-
-typedef struct
-{
-  CFileSize *PackSizes;
-  Byte *PackCRCsDefined;
-  UInt32 *PackCRCs;
-  CSzFolder *Folders;
-  CSzFileItem *Files;
-  UInt32 NumPackStreams;
-  UInt32 NumFolders;
-  UInt32 NumFiles;
-} CSzAr;
-
-void SzAr_Init(CSzAr *p);
-void SzAr_Free(CSzAr *p, ISzAlloc *alloc);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,98 @@
+/* 7zItem.h -- 7z Items
+2008-07-09
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaDec.h for license options */
+
+#ifndef __7Z_ITEM_H
+#define __7Z_ITEM_H
+
+#include &quot;../../7zBuf.h&quot;
+
+/* #define _SZ_FILE_SIZE_32 */
+/* You can define _SZ_FILE_SIZE_32, if you don't need support for files larger than 4 GB*/
+
+#ifdef _SZ_FILE_SIZE_32
+typedef UInt32 CFileSize;
+#else
+typedef UInt64 CFileSize;
+#endif
+
+typedef UInt64 CMethodID;
+
+typedef struct
+{
+  UInt32 NumInStreams;
+  UInt32 NumOutStreams;
+  CMethodID MethodID;
+  CBuf Props;
+} CSzCoderInfo;
+
+void SzCoderInfo_Init(CSzCoderInfo *p);
+void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc);
+
+typedef struct
+{
+  UInt32 InIndex;
+  UInt32 OutIndex;
+} CBindPair;
+
+typedef struct
+{
+  CSzCoderInfo *Coders;
+  CBindPair *BindPairs;
+  UInt32 *PackStreams;
+  CFileSize *UnpackSizes;
+  UInt32 NumCoders;
+  UInt32 NumBindPairs;
+  UInt32 NumPackStreams;
+  int UnpackCRCDefined;
+  UInt32 UnpackCRC;
+
+  UInt32 NumUnpackStreams;
+} CSzFolder;
+
+void SzFolder_Init(CSzFolder *p);
+CFileSize SzFolder_GetUnpackSize(CSzFolder *p);
+int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex);
+UInt32 SzFolder_GetNumOutStreams(CSzFolder *p);
+CFileSize SzFolder_GetUnpackSize(CSzFolder *p);
+
+typedef struct
+{
+  UInt32 Low;
+  UInt32 High;
+} CNtfsFileTime;
+
+typedef struct
+{
+  CNtfsFileTime MTime;
+  CFileSize Size;
+  char *Name;
+  UInt32 FileCRC;
+
+  Byte HasStream;
+  Byte IsDir;
+  Byte IsAnti;
+  Byte FileCRCDefined;
+  Byte MTimeDefined;
+} CSzFileItem;
+
+void SzFile_Init(CSzFileItem *p);
+
+typedef struct
+{
+  CFileSize *PackSizes;
+  Byte *PackCRCsDefined;
+  UInt32 *PackCRCs;
+  CSzFolder *Folders;
+  CSzFileItem *Files;
+  UInt32 NumPackStreams;
+  UInt32 NumFolders;
+  UInt32 NumFiles;
+} CSzAr;
+
+void SzAr_Init(CSzAr *p);
+void SzAr_Free(CSzAr *p, ISzAlloc *alloc);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,426 +0,0 @@
-/* 7zMain.c - Test application for 7z Decoder
-2008-08-17
-Igor Pavlov
-Public domain */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#ifdef _WIN32
-#define USE_WINDOWS_FUNCTIONS
-#endif
-
-#ifdef USE_WINDOWS_FUNCTIONS
-#include &lt;windows.h&gt;
-#endif
-
-#include &quot;7zIn.h&quot;
-#include &quot;7zExtract.h&quot;
-#include &quot;7zAlloc.h&quot;
-
-#include &quot;../../7zCrc.h&quot;
-
-
-#ifdef USE_WINDOWS_FUNCTIONS
-typedef HANDLE MY_FILE_HANDLE;
-#else
-typedef FILE *MY_FILE_HANDLE;
-#endif
-
-void ConvertNumberToString(CFileSize value, char *s)
-{
-  char temp[32];
-  int pos = 0;
-  do
-  {
-    temp[pos++] = (char)('0' + (int)(value % 10));
-    value /= 10;
-  }
-  while (value != 0);
-  do
-    *s++ = temp[--pos];
-  while (pos &gt; 0);
-  *s = '\0';
-}
-
-#define PERIOD_4 (4 * 365 + 1)
-#define PERIOD_100 (PERIOD_4 * 25 - 1)
-#define PERIOD_400 (PERIOD_100 * 4 + 1)
-
-void ConvertFileTimeToString(CNtfsFileTime *ft, char *s)
-{
-  unsigned year, mon, day, hour, min, sec;
-  UInt64 v64 = ft-&gt;Low | ((UInt64)ft-&gt;High &lt;&lt; 32);
-  Byte ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-  unsigned temp;
-  UInt32 v;
-  v64 /= 10000000;
-  sec = (unsigned)(v64 % 60);
-  v64 /= 60;
-  min = (unsigned)(v64 % 60);
-  v64 /= 60;
-  hour = (unsigned)(v64 % 24);
-  v64 /= 24;
-
-  v = (UInt32)v64;
-
-  year = (unsigned)(1601 + v / PERIOD_400 * 400);
-  v %= PERIOD_400;
-
-  temp = (unsigned)(v / PERIOD_100);
-  if (temp == 4)
-    temp = 3;
-  year += temp * 100;
-  v -= temp * PERIOD_100;
-
-  temp = v / PERIOD_4;
-  if (temp == 25)
-    temp = 24;
-  year += temp * 4;
-  v -= temp * PERIOD_4;
-
-  temp = v / 365;
-  if (temp == 4)
-    temp = 3;
-  year += temp;
-  v -= temp * 365;
-
-  if (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0))
-    ms[1] = 29;
-  for (mon = 1; mon &lt;= 12; mon++)
-  {
-    unsigned s = ms[mon - 1];
-    if (v &lt; s)
-      break;
-    v -= s;
-  }
-  day = (unsigned)v + 1;
-  sprintf(s, &quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, year, mon, day, hour, min, sec);
-}
-
-
-#ifdef USE_WINDOWS_FUNCTIONS
-/*
-   ReadFile and WriteFile functions in Windows have BUG:
-   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
-   from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES
-   (Insufficient system resources exist to complete the requested service).
-*/
-#define kChunkSizeMax (1 &lt;&lt; 24)
-#endif
-
-size_t MyReadFile(MY_FILE_HANDLE file, void *data, size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef USE_WINDOWS_FUNCTIONS
-  {
-    size_t processedSize = 0;
-    do
-    {
-      DWORD curSize = (size &gt; kChunkSizeMax) ? kChunkSizeMax : (DWORD)size;
-      DWORD processedLoc = 0;
-      BOOL res = ReadFile(file, data, curSize, &amp;processedLoc, NULL);
-      data = (void *)((unsigned char *)data + processedLoc);
-      size -= processedLoc;
-      processedSize += processedLoc;
-      if (!res || processedLoc == 0)
-        break;
-    }
-    while (size &gt; 0);
-    return processedSize;
-  }
-  #else
-  return fread(data, 1, size, file);
-  #endif
-}
-
-size_t MyWriteFile(MY_FILE_HANDLE file, void *data, size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef USE_WINDOWS_FUNCTIONS
-  {
-    size_t processedSize = 0;
-    do
-    {
-      DWORD curSize = (size &gt; kChunkSizeMax) ? kChunkSizeMax : (DWORD)size;
-      DWORD processedLoc = 0;
-      BOOL res = WriteFile(file, data, curSize, &amp;processedLoc, NULL);
-      data = (void *)((unsigned char *)data + processedLoc);
-      size -= processedLoc;
-      processedSize += processedLoc;
-      if (!res)
-        break;
-    }
-    while (size &gt; 0);
-    return processedSize;
-  }
-  #else
-  return fwrite(data, 1, size, file);
-  #endif
-}
-
-int MyCloseFile(MY_FILE_HANDLE file)
-{
-  #ifdef USE_WINDOWS_FUNCTIONS
-  return (CloseHandle(file) != FALSE) ? 0 : 1;
-  #else
-  return fclose(file);
-  #endif
-}
-
-typedef struct _CFileInStream
-{
-  ISzInStream InStream;
-  MY_FILE_HANDLE File;
-} CFileInStream;
-
-
-#define kBufferSize (1 &lt;&lt; 12)
-Byte g_Buffer[kBufferSize];
-
-SRes SzFileReadImp(void *object, void **buffer, size_t *size)
-{
-  CFileInStream *s = (CFileInStream *)object;
-  if (*size &gt; kBufferSize)
-    *size = kBufferSize;
-  *size = MyReadFile(s-&gt;File, g_Buffer, *size);
-  *buffer = g_Buffer;
-  return SZ_OK;
-}
-
-SRes SzFileSeekImp(void *object, CFileSize pos, ESzSeek origin)
-{
-  CFileInStream *s = (CFileInStream *)object;
-
-  #ifdef USE_WINDOWS_FUNCTIONS
-  {
-    LARGE_INTEGER value;
-    DWORD moveMethod;
-    value.LowPart = (DWORD)pos;
-    value.HighPart = (LONG)((UInt64)pos &gt;&gt; 32);
-    #ifdef _SZ_FILE_SIZE_32
-    /* VC 6.0 has bug with &gt;&gt; 32 shifts. */
-    value.HighPart = 0;
-    #endif
-    switch (origin)
-    {
-      case SZ_SEEK_SET: moveMethod = FILE_BEGIN; break;
-      case SZ_SEEK_CUR: moveMethod = FILE_CURRENT; break;
-      case SZ_SEEK_END: moveMethod = FILE_END; break;
-      default: return SZ_ERROR_PARAM;
-    }
-    value.LowPart = SetFilePointer(s-&gt;File, value.LowPart, &amp;value.HighPart, moveMethod);
-    if (value.LowPart == 0xFFFFFFFF)
-      if (GetLastError() != NO_ERROR)
-        return SZ_ERROR_FAIL;
-    return SZ_OK;
-  }
-  #else
-  int moveMethod;
-  int res;
-  switch (origin)
-  {
-    case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
-    case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
-    case SZ_SEEK_END: moveMethod = SEEK_END; break;
-    default: return SZ_ERROR_PARAM;
-  }
-  res = fseek(s-&gt;File, (long)pos, moveMethod );
-  return (res == 0) ? SZ_OK : SZ_ERROR_FAIL;
-  #endif
-}
-
-void PrintError(char *sz)
-{
-  printf(&quot;\nERROR: %s\n&quot;, sz);
-}
-
-int MY_CDECL main(int numargs, char *args[])
-{
-  CFileInStream archiveStream;
-  CSzArEx db;
-  SRes res;
-  ISzAlloc allocImp;
-  ISzAlloc allocTempImp;
-
-  printf(&quot;\n7z ANSI-C Decoder 4.59  Copyright (c) 1999-2008 Igor Pavlov  2008-07-09\n&quot;);
-  if (numargs == 1)
-  {
-    printf(
-      &quot;\nUsage: 7zDec &lt;command&gt; &lt;archive_name&gt;\n\n&quot;
-      &quot;&lt;Commands&gt;\n&quot;
-      &quot;  e: Extract files from archive\n&quot;
-      &quot;  l: List contents of archive\n&quot;
-      &quot;  t: Test integrity of archive\n&quot;);
-    return 0;
-  }
-  if (numargs &lt; 3)
-  {
-    PrintError(&quot;incorrect command&quot;);
-    return 1;
-  }
-
-  archiveStream.File =
-  #ifdef USE_WINDOWS_FUNCTIONS
-  CreateFileA(args[2], GENERIC_READ, FILE_SHARE_READ,
-      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-  if (archiveStream.File == INVALID_HANDLE_VALUE)
-  #else
-  archiveStream.File = fopen(args[2], &quot;rb&quot;);
-  if (archiveStream.File == 0)
-  #endif
-  {
-    PrintError(&quot;can not open input file&quot;);
-    return 1;
-  }
-
-  archiveStream.InStream.Read = SzFileReadImp;
-  archiveStream.InStream.Seek = SzFileSeekImp;
-
-  allocImp.Alloc = SzAlloc;
-  allocImp.Free = SzFree;
-
-  allocTempImp.Alloc = SzAllocTemp;
-  allocTempImp.Free = SzFreeTemp;
-
-  CrcGenerateTable();
-
-  SzArEx_Init(&amp;db);
-  res = SzArEx_Open(&amp;db, &amp;archiveStream.InStream, &amp;allocImp, &amp;allocTempImp);
-  if (res == SZ_OK)
-  {
-    char *command = args[1];
-    int listCommand = 0;
-    int testCommand = 0;
-    int extractCommand = 0;
-    if (strcmp(command, &quot;l&quot;) == 0)
-      listCommand = 1;
-    if (strcmp(command, &quot;t&quot;) == 0)
-      testCommand = 1;
-    else if (strcmp(command, &quot;e&quot;) == 0)
-      extractCommand = 1;
-
-    if (listCommand)
-    {
-      UInt32 i;
-      for (i = 0; i &lt; db.db.NumFiles; i++)
-      {
-        CSzFileItem *f = db.db.Files + i;
-        char s[32], t[32];
-        ConvertNumberToString(f-&gt;Size, s);
-        if (f-&gt;MTimeDefined)
-          ConvertFileTimeToString(&amp;f-&gt;MTime, t);
-        else
-          strcpy(t, &quot;                   &quot;);
-
-        printf(&quot;%10s %s  %s\n&quot;, s, t, f-&gt;Name);
-      }
-    }
-    else if (testCommand || extractCommand)
-    {
-      UInt32 i;
-
-      /*
-      if you need cache, use these 3 variables.
-      if you use external function, you can make these variable as static.
-      */
-      UInt32 blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */
-      Byte *outBuffer = 0; /* it must be 0 before first call for each new archive. */
-      size_t outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */
-
-      printf(&quot;\n&quot;);
-      for (i = 0; i &lt; db.db.NumFiles; i++)
-      {
-        size_t offset;
-        size_t outSizeProcessed;
-        CSzFileItem *f = db.db.Files + i;
-        if (f-&gt;IsDir)
-          printf(&quot;Directory &quot;);
-        else
-          printf(testCommand ?
-            &quot;Testing   &quot;:
-            &quot;Extracting&quot;);
-        printf(&quot; %s&quot;, f-&gt;Name);
-        if (f-&gt;IsDir)
-        {
-          printf(&quot;\n&quot;);
-          continue;
-        }
-        res = SzAr_Extract(&amp;db, &amp;archiveStream.InStream, i,
-            &amp;blockIndex, &amp;outBuffer, &amp;outBufferSize,
-            &amp;offset, &amp;outSizeProcessed,
-            &amp;allocImp, &amp;allocTempImp);
-        if (res != SZ_OK)
-          break;
-        if (!testCommand)
-        {
-          MY_FILE_HANDLE outputHandle;
-          size_t processedSize;
-          char *fileName = f-&gt;Name;
-          size_t nameLen = strlen(f-&gt;Name);
-          for (; nameLen &gt; 0; nameLen--)
-            if (f-&gt;Name[nameLen - 1] == '/')
-            {
-              fileName = f-&gt;Name + nameLen;
-              break;
-            }
-            
-          outputHandle =
-          #ifdef USE_WINDOWS_FUNCTIONS
-            CreateFileA(fileName, GENERIC_WRITE, FILE_SHARE_READ,
-                NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
-          if (outputHandle == INVALID_HANDLE_VALUE)
-          #else
-          fopen(fileName, &quot;wb+&quot;);
-          if (outputHandle == 0)
-          #endif
-          {
-            PrintError(&quot;can not open output file&quot;);
-            res = SZ_ERROR_FAIL;
-            break;
-          }
-          processedSize = MyWriteFile(outputHandle, outBuffer + offset, outSizeProcessed);
-          if (processedSize != outSizeProcessed)
-          {
-            PrintError(&quot;can not write output file&quot;);
-            res = SZ_ERROR_FAIL;
-            break;
-          }
-          if (MyCloseFile(outputHandle))
-          {
-            PrintError(&quot;can not close output file&quot;);
-            res = SZ_ERROR_FAIL;
-            break;
-          }
-        }
-        printf(&quot;\n&quot;);
-      }
-      IAlloc_Free(&amp;allocImp, outBuffer);
-    }
-    else
-    {
-      PrintError(&quot;incorrect command&quot;);
-      res = SZ_ERROR_FAIL;
-    }
-  }
-  SzArEx_Free(&amp;db, &amp;allocImp);
-
-  MyCloseFile(archiveStream.File);
-  if (res == SZ_OK)
-  {
-    printf(&quot;\nEverything is Ok\n&quot;);
-    return 0;
-  }
-  if (res == SZ_ERROR_UNSUPPORTED)
-    PrintError(&quot;decoder doesn't support this archive&quot;);
-  else if (res == SZ_ERROR_MEM)
-    PrintError(&quot;can not allocate memory&quot;);
-  else if (res == SZ_ERROR_CRC)
-    PrintError(&quot;CRC error&quot;);
-  else
-    printf(&quot;\nERROR #%d\n&quot;, res);
-  return 1;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,426 @@
+/* 7zMain.c - Test application for 7z Decoder
+2008-08-17
+Igor Pavlov
+Public domain */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#ifdef _WIN32
+#define USE_WINDOWS_FUNCTIONS
+#endif
+
+#ifdef USE_WINDOWS_FUNCTIONS
+#include &lt;windows.h&gt;
+#endif
+
+#include &quot;7zIn.h&quot;
+#include &quot;7zExtract.h&quot;
+#include &quot;7zAlloc.h&quot;
+
+#include &quot;../../7zCrc.h&quot;
+
+
+#ifdef USE_WINDOWS_FUNCTIONS
+typedef HANDLE MY_FILE_HANDLE;
+#else
+typedef FILE *MY_FILE_HANDLE;
+#endif
+
+void ConvertNumberToString(CFileSize value, char *s)
+{
+  char temp[32];
+  int pos = 0;
+  do
+  {
+    temp[pos++] = (char)('0' + (int)(value % 10));
+    value /= 10;
+  }
+  while (value != 0);
+  do
+    *s++ = temp[--pos];
+  while (pos &gt; 0);
+  *s = '\0';
+}
+
+#define PERIOD_4 (4 * 365 + 1)
+#define PERIOD_100 (PERIOD_4 * 25 - 1)
+#define PERIOD_400 (PERIOD_100 * 4 + 1)
+
+void ConvertFileTimeToString(CNtfsFileTime *ft, char *s)
+{
+  unsigned year, mon, day, hour, min, sec;
+  UInt64 v64 = ft-&gt;Low | ((UInt64)ft-&gt;High &lt;&lt; 32);
+  Byte ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+  unsigned temp;
+  UInt32 v;
+  v64 /= 10000000;
+  sec = (unsigned)(v64 % 60);
+  v64 /= 60;
+  min = (unsigned)(v64 % 60);
+  v64 /= 60;
+  hour = (unsigned)(v64 % 24);
+  v64 /= 24;
+
+  v = (UInt32)v64;
+
+  year = (unsigned)(1601 + v / PERIOD_400 * 400);
+  v %= PERIOD_400;
+
+  temp = (unsigned)(v / PERIOD_100);
+  if (temp == 4)
+    temp = 3;
+  year += temp * 100;
+  v -= temp * PERIOD_100;
+
+  temp = v / PERIOD_4;
+  if (temp == 25)
+    temp = 24;
+  year += temp * 4;
+  v -= temp * PERIOD_4;
+
+  temp = v / 365;
+  if (temp == 4)
+    temp = 3;
+  year += temp;
+  v -= temp * 365;
+
+  if (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0))
+    ms[1] = 29;
+  for (mon = 1; mon &lt;= 12; mon++)
+  {
+    unsigned s = ms[mon - 1];
+    if (v &lt; s)
+      break;
+    v -= s;
+  }
+  day = (unsigned)v + 1;
+  sprintf(s, &quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, year, mon, day, hour, min, sec);
+}
+
+
+#ifdef USE_WINDOWS_FUNCTIONS
+/*
+   ReadFile and WriteFile functions in Windows have BUG:
+   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
+   from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES
+   (Insufficient system resources exist to complete the requested service).
+*/
+#define kChunkSizeMax (1 &lt;&lt; 24)
+#endif
+
+size_t MyReadFile(MY_FILE_HANDLE file, void *data, size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef USE_WINDOWS_FUNCTIONS
+  {
+    size_t processedSize = 0;
+    do
+    {
+      DWORD curSize = (size &gt; kChunkSizeMax) ? kChunkSizeMax : (DWORD)size;
+      DWORD processedLoc = 0;
+      BOOL res = ReadFile(file, data, curSize, &amp;processedLoc, NULL);
+      data = (void *)((unsigned char *)data + processedLoc);
+      size -= processedLoc;
+      processedSize += processedLoc;
+      if (!res || processedLoc == 0)
+        break;
+    }
+    while (size &gt; 0);
+    return processedSize;
+  }
+  #else
+  return fread(data, 1, size, file);
+  #endif
+}
+
+size_t MyWriteFile(MY_FILE_HANDLE file, void *data, size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef USE_WINDOWS_FUNCTIONS
+  {
+    size_t processedSize = 0;
+    do
+    {
+      DWORD curSize = (size &gt; kChunkSizeMax) ? kChunkSizeMax : (DWORD)size;
+      DWORD processedLoc = 0;
+      BOOL res = WriteFile(file, data, curSize, &amp;processedLoc, NULL);
+      data = (void *)((unsigned char *)data + processedLoc);
+      size -= processedLoc;
+      processedSize += processedLoc;
+      if (!res)
+        break;
+    }
+    while (size &gt; 0);
+    return processedSize;
+  }
+  #else
+  return fwrite(data, 1, size, file);
+  #endif
+}
+
+int MyCloseFile(MY_FILE_HANDLE file)
+{
+  #ifdef USE_WINDOWS_FUNCTIONS
+  return (CloseHandle(file) != FALSE) ? 0 : 1;
+  #else
+  return fclose(file);
+  #endif
+}
+
+typedef struct _CFileInStream
+{
+  ISzInStream InStream;
+  MY_FILE_HANDLE File;
+} CFileInStream;
+
+
+#define kBufferSize (1 &lt;&lt; 12)
+Byte g_Buffer[kBufferSize];
+
+SRes SzFileReadImp(void *object, void **buffer, size_t *size)
+{
+  CFileInStream *s = (CFileInStream *)object;
+  if (*size &gt; kBufferSize)
+    *size = kBufferSize;
+  *size = MyReadFile(s-&gt;File, g_Buffer, *size);
+  *buffer = g_Buffer;
+  return SZ_OK;
+}
+
+SRes SzFileSeekImp(void *object, CFileSize pos, ESzSeek origin)
+{
+  CFileInStream *s = (CFileInStream *)object;
+
+  #ifdef USE_WINDOWS_FUNCTIONS
+  {
+    LARGE_INTEGER value;
+    DWORD moveMethod;
+    value.LowPart = (DWORD)pos;
+    value.HighPart = (LONG)((UInt64)pos &gt;&gt; 32);
+    #ifdef _SZ_FILE_SIZE_32
+    /* VC 6.0 has bug with &gt;&gt; 32 shifts. */
+    value.HighPart = 0;
+    #endif
+    switch (origin)
+    {
+      case SZ_SEEK_SET: moveMethod = FILE_BEGIN; break;
+      case SZ_SEEK_CUR: moveMethod = FILE_CURRENT; break;
+      case SZ_SEEK_END: moveMethod = FILE_END; break;
+      default: return SZ_ERROR_PARAM;
+    }
+    value.LowPart = SetFilePointer(s-&gt;File, value.LowPart, &amp;value.HighPart, moveMethod);
+    if (value.LowPart == 0xFFFFFFFF)
+      if (GetLastError() != NO_ERROR)
+        return SZ_ERROR_FAIL;
+    return SZ_OK;
+  }
+  #else
+  int moveMethod;
+  int res;
+  switch (origin)
+  {
+    case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
+    case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
+    case SZ_SEEK_END: moveMethod = SEEK_END; break;
+    default: return SZ_ERROR_PARAM;
+  }
+  res = fseek(s-&gt;File, (long)pos, moveMethod );
+  return (res == 0) ? SZ_OK : SZ_ERROR_FAIL;
+  #endif
+}
+
+void PrintError(char *sz)
+{
+  printf(&quot;\nERROR: %s\n&quot;, sz);
+}
+
+int MY_CDECL main(int numargs, char *args[])
+{
+  CFileInStream archiveStream;
+  CSzArEx db;
+  SRes res;
+  ISzAlloc allocImp;
+  ISzAlloc allocTempImp;
+
+  printf(&quot;\n7z ANSI-C Decoder 4.59  Copyright (c) 1999-2008 Igor Pavlov  2008-07-09\n&quot;);
+  if (numargs == 1)
+  {
+    printf(
+      &quot;\nUsage: 7zDec &lt;command&gt; &lt;archive_name&gt;\n\n&quot;
+      &quot;&lt;Commands&gt;\n&quot;
+      &quot;  e: Extract files from archive\n&quot;
+      &quot;  l: List contents of archive\n&quot;
+      &quot;  t: Test integrity of archive\n&quot;);
+    return 0;
+  }
+  if (numargs &lt; 3)
+  {
+    PrintError(&quot;incorrect command&quot;);
+    return 1;
+  }
+
+  archiveStream.File =
+  #ifdef USE_WINDOWS_FUNCTIONS
+  CreateFileA(args[2], GENERIC_READ, FILE_SHARE_READ,
+      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+  if (archiveStream.File == INVALID_HANDLE_VALUE)
+  #else
+  archiveStream.File = fopen(args[2], &quot;rb&quot;);
+  if (archiveStream.File == 0)
+  #endif
+  {
+    PrintError(&quot;can not open input file&quot;);
+    return 1;
+  }
+
+  archiveStream.InStream.Read = SzFileReadImp;
+  archiveStream.InStream.Seek = SzFileSeekImp;
+
+  allocImp.Alloc = SzAlloc;
+  allocImp.Free = SzFree;
+
+  allocTempImp.Alloc = SzAllocTemp;
+  allocTempImp.Free = SzFreeTemp;
+
+  CrcGenerateTable();
+
+  SzArEx_Init(&amp;db);
+  res = SzArEx_Open(&amp;db, &amp;archiveStream.InStream, &amp;allocImp, &amp;allocTempImp);
+  if (res == SZ_OK)
+  {
+    char *command = args[1];
+    int listCommand = 0;
+    int testCommand = 0;
+    int extractCommand = 0;
+    if (strcmp(command, &quot;l&quot;) == 0)
+      listCommand = 1;
+    if (strcmp(command, &quot;t&quot;) == 0)
+      testCommand = 1;
+    else if (strcmp(command, &quot;e&quot;) == 0)
+      extractCommand = 1;
+
+    if (listCommand)
+    {
+      UInt32 i;
+      for (i = 0; i &lt; db.db.NumFiles; i++)
+      {
+        CSzFileItem *f = db.db.Files + i;
+        char s[32], t[32];
+        ConvertNumberToString(f-&gt;Size, s);
+        if (f-&gt;MTimeDefined)
+          ConvertFileTimeToString(&amp;f-&gt;MTime, t);
+        else
+          strcpy(t, &quot;                   &quot;);
+
+        printf(&quot;%10s %s  %s\n&quot;, s, t, f-&gt;Name);
+      }
+    }
+    else if (testCommand || extractCommand)
+    {
+      UInt32 i;
+
+      /*
+      if you need cache, use these 3 variables.
+      if you use external function, you can make these variable as static.
+      */
+      UInt32 blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */
+      Byte *outBuffer = 0; /* it must be 0 before first call for each new archive. */
+      size_t outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */
+
+      printf(&quot;\n&quot;);
+      for (i = 0; i &lt; db.db.NumFiles; i++)
+      {
+        size_t offset;
+        size_t outSizeProcessed;
+        CSzFileItem *f = db.db.Files + i;
+        if (f-&gt;IsDir)
+          printf(&quot;Directory &quot;);
+        else
+          printf(testCommand ?
+            &quot;Testing   &quot;:
+            &quot;Extracting&quot;);
+        printf(&quot; %s&quot;, f-&gt;Name);
+        if (f-&gt;IsDir)
+        {
+          printf(&quot;\n&quot;);
+          continue;
+        }
+        res = SzAr_Extract(&amp;db, &amp;archiveStream.InStream, i,
+            &amp;blockIndex, &amp;outBuffer, &amp;outBufferSize,
+            &amp;offset, &amp;outSizeProcessed,
+            &amp;allocImp, &amp;allocTempImp);
+        if (res != SZ_OK)
+          break;
+        if (!testCommand)
+        {
+          MY_FILE_HANDLE outputHandle;
+          size_t processedSize;
+          char *fileName = f-&gt;Name;
+          size_t nameLen = strlen(f-&gt;Name);
+          for (; nameLen &gt; 0; nameLen--)
+            if (f-&gt;Name[nameLen - 1] == '/')
+            {
+              fileName = f-&gt;Name + nameLen;
+              break;
+            }
+            
+          outputHandle =
+          #ifdef USE_WINDOWS_FUNCTIONS
+            CreateFileA(fileName, GENERIC_WRITE, FILE_SHARE_READ,
+                NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+          if (outputHandle == INVALID_HANDLE_VALUE)
+          #else
+          fopen(fileName, &quot;wb+&quot;);
+          if (outputHandle == 0)
+          #endif
+          {
+            PrintError(&quot;can not open output file&quot;);
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+          processedSize = MyWriteFile(outputHandle, outBuffer + offset, outSizeProcessed);
+          if (processedSize != outSizeProcessed)
+          {
+            PrintError(&quot;can not write output file&quot;);
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+          if (MyCloseFile(outputHandle))
+          {
+            PrintError(&quot;can not close output file&quot;);
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+        }
+        printf(&quot;\n&quot;);
+      }
+      IAlloc_Free(&amp;allocImp, outBuffer);
+    }
+    else
+    {
+      PrintError(&quot;incorrect command&quot;);
+      res = SZ_ERROR_FAIL;
+    }
+  }
+  SzArEx_Free(&amp;db, &amp;allocImp);
+
+  MyCloseFile(archiveStream.File);
+  if (res == SZ_OK)
+  {
+    printf(&quot;\nEverything is Ok\n&quot;);
+    return 0;
+  }
+  if (res == SZ_ERROR_UNSUPPORTED)
+    PrintError(&quot;decoder doesn't support this archive&quot;);
+  else if (res == SZ_ERROR_MEM)
+    PrintError(&quot;can not allocate memory&quot;);
+  else if (res == SZ_ERROR_CRC)
+    PrintError(&quot;CRC error&quot;);
+  else
+    printf(&quot;\nERROR #%d\n&quot;, res);
+  return 1;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,30 +0,0 @@
-MY_STATIC_LINK=1
-
-PROG = 7zDec.exe
-
-C_OBJS = \
-  $O\7zBuf.obj \
-  $O\7zCrc.obj \
-  $O\LzmaDec.obj \
-  $O\Bra86.obj \
-  $O\Bcj2.obj \
-
-7Z_OBJS = \
-  $O\7zAlloc.obj \
-  $O\7zDecode.obj \
-  $O\7zExtract.obj \
-  $O\7zHeader.obj \
-  $O\7zIn.obj \
-  $O\7zItem.obj \
-  $O\7zMain.obj \
-
-OBJS = \
-  $(7Z_OBJS) \
-  $(C_OBJS) \
-
-!include &quot;../../../CPP/Build.mak&quot;
-
-$(7Z_OBJS): $(*B).c
-	$(COMPL_O1)
-$(C_OBJS): ../../$(*B).c
-	$(COMPL_O2)

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,30 @@
+MY_STATIC_LINK=1
+
+PROG = 7zDec.exe
+
+C_OBJS = \
+  $O\7zBuf.obj \
+  $O\7zCrc.obj \
+  $O\LzmaDec.obj \
+  $O\Bra86.obj \
+  $O\Bcj2.obj \
+
+7Z_OBJS = \
+  $O\7zAlloc.obj \
+  $O\7zDecode.obj \
+  $O\7zExtract.obj \
+  $O\7zHeader.obj \
+  $O\7zIn.obj \
+  $O\7zItem.obj \
+  $O\7zMain.obj \
+
+OBJS = \
+  $(7Z_OBJS) \
+  $(C_OBJS) \
+
+!include &quot;../../../CPP/Build.mak&quot;
+
+$(7Z_OBJS): $(*B).c
+	$(COMPL_O1)
+$(C_OBJS): ../../$(*B).c
+	$(COMPL_O2)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,50 +0,0 @@
-PROG = 7zDec
-CXX = g++
-CC = gcc
-LIB =
-RM = rm -f
-CFLAGS = -c -O2 -Wall
-
-OBJS = 7zAlloc.o 7zBuf.o 7zCrc.o 7zDecode.o 7zExtract.o 7zHeader.o 7zIn.o 7zItem.o LzmaDec.o Bra86.o Bcj2.o
-
-all: $(OBJS)
-
-7zAlloc.o: 7zAlloc.c
-	$(CC) $(CFLAGS) 7zAlloc.c
-
-7zBuf.o: ../../7zBuf.c
-	$(CC) $(CFLAGS) ../../7zBuf.c
-
-7zCrc.o: ../../7zCrc.c
-	$(CC) $(CFLAGS) ../../7zCrc.c
-
-7zDecode.o: 7zDecode.c
-	$(CC) $(CFLAGS) 7zDecode.c
-
-7zExtract.o: 7zExtract.c
-	$(CC) $(CFLAGS) 7zExtract.c
-
-7zHeader.o: 7zHeader.c
-	$(CC) $(CFLAGS) 7zHeader.c
-
-7zIn.o: 7zIn.c
-	$(CC) $(CFLAGS) 7zIn.c
-
-7zItem.o: 7zItem.c
-	$(CC) $(CFLAGS) 7zItem.c
-
-7zMain.o: 7zMain.c
-	$(CC) $(CFLAGS) 7zMain.c
-
-LzmaDec.o: ../../LzmaDec.c
-	$(CC) $(CFLAGS) ../../LzmaDec.c
-
-Bra86.o: ../../Bra86.c
-	$(CC) $(CFLAGS) ../../Bra86.c
-
-Bcj2.o: ../../Bcj2.c
-	$(CC) $(CFLAGS) ../../Bcj2.c
-
-clean:
-	-$(RM) $(PROG) $(OBJS)
-

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,50 @@
+PROG = 7zDec
+CXX = g++
+CC = gcc
+LIB =
+RM = rm -f
+CFLAGS = -c -O2 -Wall
+
+OBJS = 7zAlloc.o 7zBuf.o 7zCrc.o 7zDecode.o 7zExtract.o 7zHeader.o 7zIn.o 7zItem.o LzmaDec.o Bra86.o Bcj2.o
+
+all: $(OBJS)
+
+7zAlloc.o: 7zAlloc.c
+	$(CC) $(CFLAGS) 7zAlloc.c
+
+7zBuf.o: ../../7zBuf.c
+	$(CC) $(CFLAGS) ../../7zBuf.c
+
+7zCrc.o: ../../7zCrc.c
+	$(CC) $(CFLAGS) ../../7zCrc.c
+
+7zDecode.o: 7zDecode.c
+	$(CC) $(CFLAGS) 7zDecode.c
+
+7zExtract.o: 7zExtract.c
+	$(CC) $(CFLAGS) 7zExtract.c
+
+7zHeader.o: 7zHeader.c
+	$(CC) $(CFLAGS) 7zHeader.c
+
+7zIn.o: 7zIn.c
+	$(CC) $(CFLAGS) 7zIn.c
+
+7zItem.o: 7zItem.c
+	$(CC) $(CFLAGS) 7zItem.c
+
+7zMain.o: 7zMain.c
+	$(CC) $(CFLAGS) 7zMain.c
+
+LzmaDec.o: ../../LzmaDec.c
+	$(CC) $(CFLAGS) ../../LzmaDec.c
+
+Bra86.o: ../../Bra86.c
+	$(CC) $(CFLAGS) ../../Bra86.c
+
+Bcj2.o: ../../Bcj2.c
+	$(CC) $(CFLAGS) ../../Bcj2.c
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,134 +0,0 @@
-/* Bcj2.c -- Converter for x86 code (BCJ2)
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#include &quot;Bcj2.h&quot;
-
-#ifdef _LZMA_PROB32
-#define CProb UInt32
-#else
-#define CProb UInt16
-#endif
-
-#define IsJcc(b0, b1) ((b0) == 0x0F &amp;&amp; ((b1) &amp; 0xF0) == 0x80)
-#define IsJ(b0, b1) ((b1 &amp; 0xFE) == 0xE8 || IsJcc(b0, b1))
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
-#define kNumMoveBits 5
-
-#define RC_READ_BYTE (*buffer++)
-#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }
-#define RC_INIT2 code = 0; range = 0xFFFFFFFF; \
-  { int i; for (i = 0; i &lt; 5; i++) { RC_TEST; code = (code &lt;&lt; 8) | RC_READ_BYTE; }}
-
-#define NORMALIZE if (range &lt; kTopValue) { RC_TEST; range &lt;&lt;= 8; code = (code &lt;&lt; 8) | RC_READ_BYTE; }
-
-#define IF_BIT_0(p) ttt = *(p); bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
-#define UPDATE_0(p) range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) &gt;&gt; kNumMoveBits)); NORMALIZE;
-#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt &gt;&gt; kNumMoveBits)); NORMALIZE;
-
-int Bcj2_Decode(
-    const Byte *buf0, SizeT size0,
-    const Byte *buf1, SizeT size1,
-    const Byte *buf2, SizeT size2,
-    const Byte *buf3, SizeT size3,
-    Byte *outBuf, SizeT outSize)
-{
-  CProb p[256 + 2];
-  SizeT inPos = 0, outPos = 0;
-
-  const Byte *buffer, *bufferLim;
-  UInt32 range, code;
-  Byte prevByte = 0;
-
-  unsigned int i;
-  for (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++)
-    p[i] = kBitModelTotal &gt;&gt; 1;
-
-  buffer = buf3;
-  bufferLim = buffer + size3;
-  RC_INIT2
-
-  if (outSize == 0)
-    return SZ_OK;
-
-  for (;;)
-  {
-    Byte b;
-    CProb *prob;
-    UInt32 bound;
-    UInt32 ttt;
-
-    SizeT limit = size0 - inPos;
-    if (outSize - outPos &lt; limit)
-      limit = outSize - outPos;
-    while (limit != 0)
-    {
-      Byte b = buf0[inPos];
-      outBuf[outPos++] = b;
-      if (IsJ(prevByte, b))
-        break;
-      inPos++;
-      prevByte = b;
-      limit--;
-    }
-
-    if (limit == 0 || outPos == outSize)
-      break;
-
-    b = buf0[inPos++];
-
-    if (b == 0xE8)
-      prob = p + prevByte;
-    else if (b == 0xE9)
-      prob = p + 256;
-    else
-      prob = p + 257;
-
-    IF_BIT_0(prob)
-    {
-      UPDATE_0(prob)
-      prevByte = b;
-    }
-    else
-    {
-      UInt32 dest;
-      const Byte *v;
-      UPDATE_1(prob)
-      if (b == 0xE8)
-      {
-        v = buf1;
-        if (size1 &lt; 4)
-          return SZ_ERROR_DATA;
-        buf1 += 4;
-        size1 -= 4;
-      }
-      else
-      {
-        v = buf2;
-        if (size2 &lt; 4)
-          return SZ_ERROR_DATA;
-        buf2 += 4;
-        size2 -= 4;
-      }
-      dest = (((UInt32)v[0] &lt;&lt; 24) | ((UInt32)v[1] &lt;&lt; 16) |
-          ((UInt32)v[2] &lt;&lt; 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
-      outBuf[outPos++] = (Byte)dest;
-      if (outPos == outSize)
-        break;
-      outBuf[outPos++] = (Byte)(dest &gt;&gt; 8);
-      if (outPos == outSize)
-        break;
-      outBuf[outPos++] = (Byte)(dest &gt;&gt; 16);
-      if (outPos == outSize)
-        break;
-      outBuf[outPos++] = prevByte = (Byte)(dest &gt;&gt; 24);
-    }
-  }
-  return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,134 @@
+/* Bcj2.c -- Converter for x86 code (BCJ2)
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#include &quot;Bcj2.h&quot;
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define IsJcc(b0, b1) ((b0) == 0x0F &amp;&amp; ((b1) &amp; 0xF0) == 0x80)
+#define IsJ(b0, b1) ((b1 &amp; 0xFE) == 0xE8 || IsJcc(b0, b1))
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*buffer++)
+#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }
+#define RC_INIT2 code = 0; range = 0xFFFFFFFF; \
+  { int i; for (i = 0; i &lt; 5; i++) { RC_TEST; code = (code &lt;&lt; 8) | RC_READ_BYTE; }}
+
+#define NORMALIZE if (range &lt; kTopValue) { RC_TEST; range &lt;&lt;= 8; code = (code &lt;&lt; 8) | RC_READ_BYTE; }
+
+#define IF_BIT_0(p) ttt = *(p); bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
+#define UPDATE_0(p) range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) &gt;&gt; kNumMoveBits)); NORMALIZE;
+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt &gt;&gt; kNumMoveBits)); NORMALIZE;
+
+int Bcj2_Decode(
+    const Byte *buf0, SizeT size0,
+    const Byte *buf1, SizeT size1,
+    const Byte *buf2, SizeT size2,
+    const Byte *buf3, SizeT size3,
+    Byte *outBuf, SizeT outSize)
+{
+  CProb p[256 + 2];
+  SizeT inPos = 0, outPos = 0;
+
+  const Byte *buffer, *bufferLim;
+  UInt32 range, code;
+  Byte prevByte = 0;
+
+  unsigned int i;
+  for (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++)
+    p[i] = kBitModelTotal &gt;&gt; 1;
+
+  buffer = buf3;
+  bufferLim = buffer + size3;
+  RC_INIT2
+
+  if (outSize == 0)
+    return SZ_OK;
+
+  for (;;)
+  {
+    Byte b;
+    CProb *prob;
+    UInt32 bound;
+    UInt32 ttt;
+
+    SizeT limit = size0 - inPos;
+    if (outSize - outPos &lt; limit)
+      limit = outSize - outPos;
+    while (limit != 0)
+    {
+      Byte b = buf0[inPos];
+      outBuf[outPos++] = b;
+      if (IsJ(prevByte, b))
+        break;
+      inPos++;
+      prevByte = b;
+      limit--;
+    }
+
+    if (limit == 0 || outPos == outSize)
+      break;
+
+    b = buf0[inPos++];
+
+    if (b == 0xE8)
+      prob = p + prevByte;
+    else if (b == 0xE9)
+      prob = p + 256;
+    else
+      prob = p + 257;
+
+    IF_BIT_0(prob)
+    {
+      UPDATE_0(prob)
+      prevByte = b;
+    }
+    else
+    {
+      UInt32 dest;
+      const Byte *v;
+      UPDATE_1(prob)
+      if (b == 0xE8)
+      {
+        v = buf1;
+        if (size1 &lt; 4)
+          return SZ_ERROR_DATA;
+        buf1 += 4;
+        size1 -= 4;
+      }
+      else
+      {
+        v = buf2;
+        if (size2 &lt; 4)
+          return SZ_ERROR_DATA;
+        buf2 += 4;
+        size2 -= 4;
+      }
+      dest = (((UInt32)v[0] &lt;&lt; 24) | ((UInt32)v[1] &lt;&lt; 16) |
+          ((UInt32)v[2] &lt;&lt; 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
+      outBuf[outPos++] = (Byte)dest;
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = (Byte)(dest &gt;&gt; 8);
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = (Byte)(dest &gt;&gt; 16);
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = prevByte = (Byte)(dest &gt;&gt; 24);
+    }
+  }
+  return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,32 +0,0 @@
-/* Bcj2.h -- Converter for x86 code (BCJ2)
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#ifndef __BCJ2_H
-#define __BCJ2_H
-
-#include &quot;Types.h&quot;
-
-/*
-Conditions:
-  outSize &lt;= FullOutputSize,
-  where FullOutputSize is full size of output stream of x86_2 filter.
-
-If buf0 overlaps outBuf, there are two required conditions:
-  1) (buf0 &gt;= outBuf)
-  2) (buf0 + size0 &gt;= outBuf + FullOutputSize).
-
-Returns:
-  SZ_OK
-  SZ_ERROR_DATA - Data error
-*/
-
-int Bcj2_Decode(
-    const Byte *buf0, SizeT size0,
-    const Byte *buf1, SizeT size1,
-    const Byte *buf2, SizeT size2,
-    const Byte *buf3, SizeT size3,
-    Byte *outBuf, SizeT outSize);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bcj2.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,32 @@
+/* Bcj2.h -- Converter for x86 code (BCJ2)
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#ifndef __BCJ2_H
+#define __BCJ2_H
+
+#include &quot;Types.h&quot;
+
+/*
+Conditions:
+  outSize &lt;= FullOutputSize,
+  where FullOutputSize is full size of output stream of x86_2 filter.
+
+If buf0 overlaps outBuf, there are two required conditions:
+  1) (buf0 &gt;= outBuf)
+  2) (buf0 + size0 &gt;= outBuf + FullOutputSize).
+
+Returns:
+  SZ_OK
+  SZ_ERROR_DATA - Data error
+*/
+
+int Bcj2_Decode(
+    const Byte *buf0, SizeT size0,
+    const Byte *buf1, SizeT size1,
+    const Byte *buf2, SizeT size2,
+    const Byte *buf3, SizeT size3,
+    Byte *outBuf, SizeT outSize);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,135 +0,0 @@
-/* Bra.c -- converters for RISC  code
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#include &quot;Bra.h&quot;
-
-SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  SizeT i;
-  if (size &lt; 4)
-    return 0;
-  size -= 4;
-  ip += 8;
-  for (i = 0; i &lt;= size; i += 4)
-  {
-    if (data[i + 3] == 0xEB)
-    {
-      UInt32 dest;
-      UInt32 src = ((UInt32)data[i + 2] &lt;&lt; 16) | ((UInt32)data[i + 1] &lt;&lt; 8) | (data[i + 0]);
-      src &lt;&lt;= 2;
-      if (encoding)
-        dest = ip + (UInt32)i + src;
-      else
-        dest = src - (ip + (UInt32)i);
-      dest &gt;&gt;= 2;
-      data[i + 2] = (Byte)(dest &gt;&gt; 16);
-      data[i + 1] = (Byte)(dest &gt;&gt; 8);
-      data[i + 0] = (Byte)dest;
-    }
-  }
-  return i;
-}
-
-SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  SizeT i;
-  if (size &lt; 4)
-    return 0;
-  size -= 4;
-  ip += 4;
-  for (i = 0; i &lt;= size; i += 2)
-  {
-    if ((data[i + 1] &amp; 0xF8) == 0xF0 &amp;&amp;
-        (data[i + 3] &amp; 0xF8) == 0xF8)
-    {
-      UInt32 dest;
-      UInt32 src =
-        (((UInt32)data[i + 1] &amp; 0x7) &lt;&lt; 19) |
-        ((UInt32)data[i + 0] &lt;&lt; 11) |
-        (((UInt32)data[i + 3] &amp; 0x7) &lt;&lt; 8) |
-        (data[i + 2]);
-      
-      src &lt;&lt;= 1;
-      if (encoding)
-        dest = ip + (UInt32)i + src;
-      else
-        dest = src - (ip + (UInt32)i);
-      dest &gt;&gt;= 1;
-      
-      data[i + 1] = (Byte)(0xF0 | ((dest &gt;&gt; 19) &amp; 0x7));
-      data[i + 0] = (Byte)(dest &gt;&gt; 11);
-      data[i + 3] = (Byte)(0xF8 | ((dest &gt;&gt; 8) &amp; 0x7));
-      data[i + 2] = (Byte)dest;
-      i += 2;
-    }
-  }
-  return i;
-}
-
-SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  SizeT i;
-  if (size &lt; 4)
-    return 0;
-  size -= 4;
-  for (i = 0; i &lt;= size; i += 4)
-  {
-    if ((data[i] &gt;&gt; 2) == 0x12 &amp;&amp; (data[i + 3] &amp; 3) == 1)
-    {
-      UInt32 src = ((UInt32)(data[i + 0] &amp; 3) &lt;&lt; 24) |
-        ((UInt32)data[i + 1] &lt;&lt; 16) |
-        ((UInt32)data[i + 2] &lt;&lt; 8) |
-        ((UInt32)data[i + 3] &amp; (~3));
-      
-      UInt32 dest;
-      if (encoding)
-        dest = ip + (UInt32)i + src;
-      else
-        dest = src - (ip + (UInt32)i);
-      data[i + 0] = (Byte)(0x48 | ((dest &gt;&gt; 24) &amp;  0x3));
-      data[i + 1] = (Byte)(dest &gt;&gt; 16);
-      data[i + 2] = (Byte)(dest &gt;&gt; 8);
-      data[i + 3] &amp;= 0x3;
-      data[i + 3] |= dest;
-    }
-  }
-  return i;
-}
-
-SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  UInt32 i;
-  if (size &lt; 4)
-    return 0;
-  size -= 4;
-  for (i = 0; i &lt;= size; i += 4)
-  {
-    if (data[i] == 0x40 &amp;&amp; (data[i + 1] &amp; 0xC0) == 0x00 ||
-        data[i] == 0x7F &amp;&amp; (data[i + 1] &amp; 0xC0) == 0xC0)
-    {
-      UInt32 src =
-        ((UInt32)data[i + 0] &lt;&lt; 24) |
-        ((UInt32)data[i + 1] &lt;&lt; 16) |
-        ((UInt32)data[i + 2] &lt;&lt; 8) |
-        ((UInt32)data[i + 3]);
-      UInt32 dest;
-      
-      src &lt;&lt;= 2;
-      if (encoding)
-        dest = ip + i + src;
-      else
-        dest = src - (ip + i);
-      dest &gt;&gt;= 2;
-      
-      dest = (((0 - ((dest &gt;&gt; 22) &amp; 1)) &lt;&lt; 22) &amp; 0x3FFFFFFF) | (dest &amp; 0x3FFFFF) | 0x40000000;
-
-      data[i + 0] = (Byte)(dest &gt;&gt; 24);
-      data[i + 1] = (Byte)(dest &gt;&gt; 16);
-      data[i + 2] = (Byte)(dest &gt;&gt; 8);
-      data[i + 3] = (Byte)dest;
-    }
-  }
-  return i;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,135 @@
+/* Bra.c -- converters for RISC  code
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#include &quot;Bra.h&quot;
+
+SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size &lt; 4)
+    return 0;
+  size -= 4;
+  ip += 8;
+  for (i = 0; i &lt;= size; i += 4)
+  {
+    if (data[i + 3] == 0xEB)
+    {
+      UInt32 dest;
+      UInt32 src = ((UInt32)data[i + 2] &lt;&lt; 16) | ((UInt32)data[i + 1] &lt;&lt; 8) | (data[i + 0]);
+      src &lt;&lt;= 2;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      dest &gt;&gt;= 2;
+      data[i + 2] = (Byte)(dest &gt;&gt; 16);
+      data[i + 1] = (Byte)(dest &gt;&gt; 8);
+      data[i + 0] = (Byte)dest;
+    }
+  }
+  return i;
+}
+
+SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size &lt; 4)
+    return 0;
+  size -= 4;
+  ip += 4;
+  for (i = 0; i &lt;= size; i += 2)
+  {
+    if ((data[i + 1] &amp; 0xF8) == 0xF0 &amp;&amp;
+        (data[i + 3] &amp; 0xF8) == 0xF8)
+    {
+      UInt32 dest;
+      UInt32 src =
+        (((UInt32)data[i + 1] &amp; 0x7) &lt;&lt; 19) |
+        ((UInt32)data[i + 0] &lt;&lt; 11) |
+        (((UInt32)data[i + 3] &amp; 0x7) &lt;&lt; 8) |
+        (data[i + 2]);
+      
+      src &lt;&lt;= 1;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      dest &gt;&gt;= 1;
+      
+      data[i + 1] = (Byte)(0xF0 | ((dest &gt;&gt; 19) &amp; 0x7));
+      data[i + 0] = (Byte)(dest &gt;&gt; 11);
+      data[i + 3] = (Byte)(0xF8 | ((dest &gt;&gt; 8) &amp; 0x7));
+      data[i + 2] = (Byte)dest;
+      i += 2;
+    }
+  }
+  return i;
+}
+
+SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size &lt; 4)
+    return 0;
+  size -= 4;
+  for (i = 0; i &lt;= size; i += 4)
+  {
+    if ((data[i] &gt;&gt; 2) == 0x12 &amp;&amp; (data[i + 3] &amp; 3) == 1)
+    {
+      UInt32 src = ((UInt32)(data[i + 0] &amp; 3) &lt;&lt; 24) |
+        ((UInt32)data[i + 1] &lt;&lt; 16) |
+        ((UInt32)data[i + 2] &lt;&lt; 8) |
+        ((UInt32)data[i + 3] &amp; (~3));
+      
+      UInt32 dest;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      data[i + 0] = (Byte)(0x48 | ((dest &gt;&gt; 24) &amp;  0x3));
+      data[i + 1] = (Byte)(dest &gt;&gt; 16);
+      data[i + 2] = (Byte)(dest &gt;&gt; 8);
+      data[i + 3] &amp;= 0x3;
+      data[i + 3] |= dest;
+    }
+  }
+  return i;
+}
+
+SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  UInt32 i;
+  if (size &lt; 4)
+    return 0;
+  size -= 4;
+  for (i = 0; i &lt;= size; i += 4)
+  {
+    if (data[i] == 0x40 &amp;&amp; (data[i + 1] &amp; 0xC0) == 0x00 ||
+        data[i] == 0x7F &amp;&amp; (data[i + 1] &amp; 0xC0) == 0xC0)
+    {
+      UInt32 src =
+        ((UInt32)data[i + 0] &lt;&lt; 24) |
+        ((UInt32)data[i + 1] &lt;&lt; 16) |
+        ((UInt32)data[i + 2] &lt;&lt; 8) |
+        ((UInt32)data[i + 3]);
+      UInt32 dest;
+      
+      src &lt;&lt;= 2;
+      if (encoding)
+        dest = ip + i + src;
+      else
+        dest = src - (ip + i);
+      dest &gt;&gt;= 2;
+      
+      dest = (((0 - ((dest &gt;&gt; 22) &amp; 1)) &lt;&lt; 22) &amp; 0x3FFFFFFF) | (dest &amp; 0x3FFFFF) | 0x40000000;
+
+      data[i + 0] = (Byte)(dest &gt;&gt; 24);
+      data[i + 1] = (Byte)(dest &gt;&gt; 16);
+      data[i + 2] = (Byte)(dest &gt;&gt; 8);
+      data[i + 3] = (Byte)dest;
+    }
+  }
+  return i;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,62 +0,0 @@
-/* Bra.h -- Branch converters for executables
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaDec.h for license options */
-
-#ifndef __BRA_H
-#define __BRA_H
-
-#include &quot;Types.h&quot;
-
-/*
-These functions convert relative addresses to absolute addresses
-in CALL instructions to increase the compression ratio.
-  
-  In:
-    data     - data buffer
-    size     - size of data
-    ip       - current virtual Instruction Pinter (IP) value
-    state    - state variable for x86 converter
-    encoding - 0 (for decoding), 1 (for encoding)
-  
-  Out:
-    state    - state variable for x86 converter
-
-  Returns:
-    The number of processed bytes. If you call these functions with multiple calls,
-    you must start next call with first byte after block of processed bytes.
-  
-  Type   Endian  Alignment  LookAhead
-  
-  x86    little      1          4
-  ARMT   little      2          2
-  ARM    little      4          0
-  PPC     big        4          0
-  SPARC   big        4          0
-  IA64   little     16          0
-
-  size must be &gt;= Alignment + LookAhead, if it's not last block.
-  If (size &lt; Alignment + LookAhead), converter returns 0.
-
-  Example:
-
-    UInt32 ip = 0;
-    for ()
-    {
-      // size must be &gt;= Alignment + LookAhead, if it's not last block
-      SizeT processed = Convert(data, size, ip, 1);
-      data += processed;
-      size -= processed;
-      ip += processed;
-    }
-*/
-
-#define x86_Convert_Init(state) { state = 0; }
-SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
-SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,62 @@
+/* Bra.h -- Branch converters for executables
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaDec.h for license options */
+
+#ifndef __BRA_H
+#define __BRA_H
+
+#include &quot;Types.h&quot;
+
+/*
+These functions convert relative addresses to absolute addresses
+in CALL instructions to increase the compression ratio.
+  
+  In:
+    data     - data buffer
+    size     - size of data
+    ip       - current virtual Instruction Pinter (IP) value
+    state    - state variable for x86 converter
+    encoding - 0 (for decoding), 1 (for encoding)
+  
+  Out:
+    state    - state variable for x86 converter
+
+  Returns:
+    The number of processed bytes. If you call these functions with multiple calls,
+    you must start next call with first byte after block of processed bytes.
+  
+  Type   Endian  Alignment  LookAhead
+  
+  x86    little      1          4
+  ARMT   little      2          2
+  ARM    little      4          0
+  PPC     big        4          0
+  SPARC   big        4          0
+  IA64   little     16          0
+
+  size must be &gt;= Alignment + LookAhead, if it's not last block.
+  If (size &lt; Alignment + LookAhead), converter returns 0.
+
+  Example:
+
+    UInt32 ip = 0;
+    for ()
+    {
+      // size must be &gt;= Alignment + LookAhead, if it's not last block
+      SizeT processed = Convert(data, size, ip, 1);
+      data += processed;
+      size -= processed;
+      ip += processed;
+    }
+*/
+
+#define x86_Convert_Init(state) { state = 0; }
+SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
+SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,87 +0,0 @@
-/* Bra86.c -- converter for x86 code (BCJ)
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#include &quot;Bra.h&quot;
-
-#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
-
-const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
-const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
-
-SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
-{
-  SizeT bufferPos = 0, prevPosT;
-  UInt32 prevMask = *state &amp; 0x7;
-  if (size &lt; 5)
-    return 0;
-  ip += 5;
-  prevPosT = (SizeT)0 - 1;
-
-  for (;;)
-  {
-    Byte *p = data + bufferPos;
-    Byte *limit = data + size - 4;
-    for (; p &lt; limit; p++)
-      if ((*p &amp; 0xFE) == 0xE8)
-        break;
-    bufferPos = (SizeT)(p - data);
-    if (p &gt;= limit)
-      break;
-    prevPosT = bufferPos - prevPosT;
-    if (prevPosT &gt; 3)
-      prevMask = 0;
-    else
-    {
-      prevMask = (prevMask &lt;&lt; ((int)prevPosT - 1)) &amp; 0x7;
-      if (prevMask != 0)
-      {
-        Byte b = p[4 - kMaskToBitNumber[prevMask]];
-        if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
-        {
-          prevPosT = bufferPos;
-          prevMask = ((prevMask &lt;&lt; 1) &amp; 0x7) | 1;
-          bufferPos++;
-          continue;
-        }
-      }
-    }
-    prevPosT = bufferPos;
-
-    if (Test86MSByte(p[4]))
-    {
-      UInt32 src = ((UInt32)p[4] &lt;&lt; 24) | ((UInt32)p[3] &lt;&lt; 16) | ((UInt32)p[2] &lt;&lt; 8) | ((UInt32)p[1]);
-      UInt32 dest;
-      for (;;)
-      {
-        Byte b;
-        int index;
-        if (encoding)
-          dest = (ip + (UInt32)bufferPos) + src;
-        else
-          dest = src - (ip + (UInt32)bufferPos);
-        if (prevMask == 0)
-          break;
-        index = kMaskToBitNumber[prevMask] * 8;
-        b = (Byte)(dest &gt;&gt; (24 - index));
-        if (!Test86MSByte(b))
-          break;
-        src = dest ^ ((1 &lt;&lt; (32 - index)) - 1);
-      }
-      p[4] = (Byte)(~(((dest &gt;&gt; 24) &amp; 1) - 1));
-      p[3] = (Byte)(dest &gt;&gt; 16);
-      p[2] = (Byte)(dest &gt;&gt; 8);
-      p[1] = (Byte)dest;
-      bufferPos += 5;
-    }
-    else
-    {
-      prevMask = ((prevMask &lt;&lt; 1) &amp; 0x7) | 1;
-      bufferPos++;
-    }
-  }
-  prevPosT = bufferPos - prevPosT;
-  *state = ((prevPosT &gt; 3) ? 0 : ((prevMask &lt;&lt; ((int)prevPosT - 1)) &amp; 0x7));
-  return bufferPos;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Bra86.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,87 @@
+/* Bra86.c -- converter for x86 code (BCJ)
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#include &quot;Bra.h&quot;
+
+#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
+
+const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
+const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
+
+SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
+{
+  SizeT bufferPos = 0, prevPosT;
+  UInt32 prevMask = *state &amp; 0x7;
+  if (size &lt; 5)
+    return 0;
+  ip += 5;
+  prevPosT = (SizeT)0 - 1;
+
+  for (;;)
+  {
+    Byte *p = data + bufferPos;
+    Byte *limit = data + size - 4;
+    for (; p &lt; limit; p++)
+      if ((*p &amp; 0xFE) == 0xE8)
+        break;
+    bufferPos = (SizeT)(p - data);
+    if (p &gt;= limit)
+      break;
+    prevPosT = bufferPos - prevPosT;
+    if (prevPosT &gt; 3)
+      prevMask = 0;
+    else
+    {
+      prevMask = (prevMask &lt;&lt; ((int)prevPosT - 1)) &amp; 0x7;
+      if (prevMask != 0)
+      {
+        Byte b = p[4 - kMaskToBitNumber[prevMask]];
+        if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
+        {
+          prevPosT = bufferPos;
+          prevMask = ((prevMask &lt;&lt; 1) &amp; 0x7) | 1;
+          bufferPos++;
+          continue;
+        }
+      }
+    }
+    prevPosT = bufferPos;
+
+    if (Test86MSByte(p[4]))
+    {
+      UInt32 src = ((UInt32)p[4] &lt;&lt; 24) | ((UInt32)p[3] &lt;&lt; 16) | ((UInt32)p[2] &lt;&lt; 8) | ((UInt32)p[1]);
+      UInt32 dest;
+      for (;;)
+      {
+        Byte b;
+        int index;
+        if (encoding)
+          dest = (ip + (UInt32)bufferPos) + src;
+        else
+          dest = src - (ip + (UInt32)bufferPos);
+        if (prevMask == 0)
+          break;
+        index = kMaskToBitNumber[prevMask] * 8;
+        b = (Byte)(dest &gt;&gt; (24 - index));
+        if (!Test86MSByte(b))
+          break;
+        src = dest ^ ((1 &lt;&lt; (32 - index)) - 1);
+      }
+      p[4] = (Byte)(~(((dest &gt;&gt; 24) &amp; 1) - 1));
+      p[3] = (Byte)(dest &gt;&gt; 16);
+      p[2] = (Byte)(dest &gt;&gt; 8);
+      p[1] = (Byte)dest;
+      bufferPos += 5;
+    }
+    else
+    {
+      prevMask = ((prevMask &lt;&lt; 1) &amp; 0x7) | 1;
+      bufferPos++;
+    }
+  }
+  prevPosT = bufferPos - prevPosT;
+  *state = ((prevPosT &gt; 3) ? 0 : ((prevMask &lt;&lt; ((int)prevPosT - 1)) &amp; 0x7));
+  return bufferPos;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,69 +0,0 @@
-/* BraIA64.c -- converter for IA-64 code
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#include &quot;Bra.h&quot;
-
-static const Byte kBranchTable[32] =
-{
-  0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0,
-  4, 4, 6, 6, 0, 0, 7, 7,
-  4, 4, 0, 0, 4, 4, 0, 0
-};
-
-SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  SizeT i;
-  if (size &lt; 16)
-    return 0;
-  size -= 16;
-  for (i = 0; i &lt;= size; i += 16)
-  {
-    UInt32 instrTemplate = data[i] &amp; 0x1F;
-    UInt32 mask = kBranchTable[instrTemplate];
-    UInt32 bitPos = 5;
-    int slot;
-    for (slot = 0; slot &lt; 3; slot++, bitPos += 41)
-    {
-      UInt32 bytePos, bitRes;
-      UInt64 instruction, instNorm;
-      int j;
-      if (((mask &gt;&gt; slot) &amp; 1) == 0)
-        continue;
-      bytePos = (bitPos &gt;&gt; 3);
-      bitRes = bitPos &amp; 0x7;
-      instruction = 0;
-      for (j = 0; j &lt; 6; j++)
-        instruction += (UInt64)data[i + j + bytePos] &lt;&lt; (8 * j);
-
-      instNorm = instruction &gt;&gt; bitRes;
-      if (((instNorm &gt;&gt; 37) &amp; 0xF) == 0x5 &amp;&amp; ((instNorm &gt;&gt; 9) &amp; 0x7) == 0)
-      {
-        UInt32 src = (UInt32)((instNorm &gt;&gt; 13) &amp; 0xFFFFF);
-        UInt32 dest;
-        src |= ((UInt32)(instNorm &gt;&gt; 36) &amp; 1) &lt;&lt; 20;
-        
-        src &lt;&lt;= 4;
-        
-        if (encoding)
-          dest = ip + (UInt32)i + src;
-        else
-          dest = src - (ip + (UInt32)i);
-        
-        dest &gt;&gt;= 4;
-        
-        instNorm &amp;= ~((UInt64)(0x8FFFFF) &lt;&lt; 13);
-        instNorm |= ((UInt64)(dest &amp; 0xFFFFF) &lt;&lt; 13);
-        instNorm |= ((UInt64)(dest &amp; 0x100000) &lt;&lt; (36 - 20));
-        
-        instruction &amp;= (1 &lt;&lt; bitRes) - 1;
-        instruction |= (instNorm &lt;&lt; bitRes);
-        for (j = 0; j &lt; 6; j++)
-          data[i + j + bytePos] = (Byte)(instruction &gt;&gt; (8 * j));
-      }
-    }
-  }
-  return i;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/BraIA64.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,69 @@
+/* BraIA64.c -- converter for IA-64 code
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#include &quot;Bra.h&quot;
+
+static const Byte kBranchTable[32] =
+{
+  0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  4, 4, 6, 6, 0, 0, 7, 7,
+  4, 4, 0, 0, 4, 4, 0, 0
+};
+
+SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size &lt; 16)
+    return 0;
+  size -= 16;
+  for (i = 0; i &lt;= size; i += 16)
+  {
+    UInt32 instrTemplate = data[i] &amp; 0x1F;
+    UInt32 mask = kBranchTable[instrTemplate];
+    UInt32 bitPos = 5;
+    int slot;
+    for (slot = 0; slot &lt; 3; slot++, bitPos += 41)
+    {
+      UInt32 bytePos, bitRes;
+      UInt64 instruction, instNorm;
+      int j;
+      if (((mask &gt;&gt; slot) &amp; 1) == 0)
+        continue;
+      bytePos = (bitPos &gt;&gt; 3);
+      bitRes = bitPos &amp; 0x7;
+      instruction = 0;
+      for (j = 0; j &lt; 6; j++)
+        instruction += (UInt64)data[i + j + bytePos] &lt;&lt; (8 * j);
+
+      instNorm = instruction &gt;&gt; bitRes;
+      if (((instNorm &gt;&gt; 37) &amp; 0xF) == 0x5 &amp;&amp; ((instNorm &gt;&gt; 9) &amp; 0x7) == 0)
+      {
+        UInt32 src = (UInt32)((instNorm &gt;&gt; 13) &amp; 0xFFFFF);
+        UInt32 dest;
+        src |= ((UInt32)(instNorm &gt;&gt; 36) &amp; 1) &lt;&lt; 20;
+        
+        src &lt;&lt;= 4;
+        
+        if (encoding)
+          dest = ip + (UInt32)i + src;
+        else
+          dest = src - (ip + (UInt32)i);
+        
+        dest &gt;&gt;= 4;
+        
+        instNorm &amp;= ~((UInt64)(0x8FFFFF) &lt;&lt; 13);
+        instNorm |= ((UInt64)(dest &amp; 0xFFFFF) &lt;&lt; 13);
+        instNorm |= ((UInt64)(dest &amp; 0x100000) &lt;&lt; (36 - 20));
+        
+        instruction &amp;= (1 &lt;&lt; bitRes) - 1;
+        instruction |= (instNorm &lt;&lt; bitRes);
+        for (j = 0; j &lt; 6; j++)
+          data[i + j + bytePos] = (Byte)(instruction &gt;&gt; (8 * j));
+      }
+    }
+  }
+  return i;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,69 +0,0 @@
-/* CpuArch.h
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __CPUARCH_H
-#define __CPUARCH_H
-
-/*
-LITTLE_ENDIAN_UNALIGN means:
-  1) CPU is LITTLE_ENDIAN
-  2) it's allowed to make unaligned memory accesses
-if LITTLE_ENDIAN_UNALIGN is not defined, it means that we don't know
-about these properties of platform.
-*/
-
-#if defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) || defined(__i386__) || defined(__x86_64__)
-#define LITTLE_ENDIAN_UNALIGN
-#endif
-
-#ifdef LITTLE_ENDIAN_UNALIGN
-
-#define GetUi16(p) (*(const UInt16 *)(p))
-#define GetUi32(p) (*(const UInt32 *)(p))
-#define GetUi64(p) (*(const UInt64 *)(p))
-#define SetUi32(p, d) *(UInt32 *)(p) = (d);
-
-#else
-
-#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] &lt;&lt; 8))
-
-#define GetUi32(p) ( \
-             ((const Byte *)(p))[0]        | \
-    ((UInt32)((const Byte *)(p))[1] &lt;&lt;  8) | \
-    ((UInt32)((const Byte *)(p))[2] &lt;&lt; 16) | \
-    ((UInt32)((const Byte *)(p))[3] &lt;&lt; 24))
-
-#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) &lt;&lt; 32))
-
-#define SetUi32(p, d) { UInt32 _x_ = (d); \
-    ((Byte *)(p))[0] = (Byte)_x_; \
-    ((Byte *)(p))[1] = (Byte)(_x_ &gt;&gt; 8); \
-    ((Byte *)(p))[2] = (Byte)(_x_ &gt;&gt; 16); \
-    ((Byte *)(p))[3] = (Byte)(_x_ &gt;&gt; 24); }
-
-#endif
-
-#if defined(LITTLE_ENDIAN_UNALIGN) &amp;&amp; defined(_WIN64) &amp;&amp; (_MSC_VER &gt;= 1300)
-
-#pragma intrinsic(_byteswap_ulong)
-#pragma intrinsic(_byteswap_uint64)
-#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
-#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))
-
-#else
-
-#define GetBe32(p) ( \
-    ((UInt32)((const Byte *)(p))[0] &lt;&lt; 24) | \
-    ((UInt32)((const Byte *)(p))[1] &lt;&lt; 16) | \
-    ((UInt32)((const Byte *)(p))[2] &lt;&lt;  8) | \
-             ((const Byte *)(p))[3] )
-
-#define GetBe64(p) (((UInt64)GetBe32(p) &lt;&lt; 32) | GetBe32(((const Byte *)(p)) + 4))
-
-#endif
-
-#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] &lt;&lt; 8) | ((const Byte *)(p))[1])
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/CpuArch.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,69 @@
+/* CpuArch.h
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __CPUARCH_H
+#define __CPUARCH_H
+
+/*
+LITTLE_ENDIAN_UNALIGN means:
+  1) CPU is LITTLE_ENDIAN
+  2) it's allowed to make unaligned memory accesses
+if LITTLE_ENDIAN_UNALIGN is not defined, it means that we don't know
+about these properties of platform.
+*/
+
+#if defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) || defined(__i386__) || defined(__x86_64__)
+#define LITTLE_ENDIAN_UNALIGN
+#endif
+
+#ifdef LITTLE_ENDIAN_UNALIGN
+
+#define GetUi16(p) (*(const UInt16 *)(p))
+#define GetUi32(p) (*(const UInt32 *)(p))
+#define GetUi64(p) (*(const UInt64 *)(p))
+#define SetUi32(p, d) *(UInt32 *)(p) = (d);
+
+#else
+
+#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] &lt;&lt; 8))
+
+#define GetUi32(p) ( \
+             ((const Byte *)(p))[0]        | \
+    ((UInt32)((const Byte *)(p))[1] &lt;&lt;  8) | \
+    ((UInt32)((const Byte *)(p))[2] &lt;&lt; 16) | \
+    ((UInt32)((const Byte *)(p))[3] &lt;&lt; 24))
+
+#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) &lt;&lt; 32))
+
+#define SetUi32(p, d) { UInt32 _x_ = (d); \
+    ((Byte *)(p))[0] = (Byte)_x_; \
+    ((Byte *)(p))[1] = (Byte)(_x_ &gt;&gt; 8); \
+    ((Byte *)(p))[2] = (Byte)(_x_ &gt;&gt; 16); \
+    ((Byte *)(p))[3] = (Byte)(_x_ &gt;&gt; 24); }
+
+#endif
+
+#if defined(LITTLE_ENDIAN_UNALIGN) &amp;&amp; defined(_WIN64) &amp;&amp; (_MSC_VER &gt;= 1300)
+
+#pragma intrinsic(_byteswap_ulong)
+#pragma intrinsic(_byteswap_uint64)
+#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
+#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))
+
+#else
+
+#define GetBe32(p) ( \
+    ((UInt32)((const Byte *)(p))[0] &lt;&lt; 24) | \
+    ((UInt32)((const Byte *)(p))[1] &lt;&lt; 16) | \
+    ((UInt32)((const Byte *)(p))[2] &lt;&lt;  8) | \
+             ((const Byte *)(p))[3] )
+
+#define GetBe64(p) (((UInt64)GetBe32(p) &lt;&lt; 32) | GetBe32(((const Byte *)(p)) + 4))
+
+#endif
+
+#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] &lt;&lt; 8) | ((const Byte *)(p))[1])
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,753 +0,0 @@
-/* LzFind.c  -- Match finder for LZ algorithms
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#include &lt;string.h&gt;
-
-#include &quot;LzFind.h&quot;
-#include &quot;LzHash.h&quot;
-
-#define kEmptyHashValue 0
-#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
-#define kNormalizeStepMin (1 &lt;&lt; 10) /* it must be power of 2 */
-#define kNormalizeMask (~(kNormalizeStepMin - 1))
-#define kMaxHistorySize ((UInt32)3 &lt;&lt; 30)
-
-#define kStartMaxLen 3
-
-static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
-{
-  if (!p-&gt;directInput)
-  {
-    alloc-&gt;Free(alloc, p-&gt;bufferBase);
-    p-&gt;bufferBase = 0;
-  }
-}
-
-/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be &lt; 4G) */
-
-static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
-{
-  UInt32 blockSize = p-&gt;keepSizeBefore + p-&gt;keepSizeAfter + keepSizeReserv;
-  if (p-&gt;directInput)
-  {
-    p-&gt;blockSize = blockSize;
-    return 1;
-  }
-  if (p-&gt;bufferBase == 0 || p-&gt;blockSize != blockSize)
-  {
-    LzInWindow_Free(p, alloc);
-    p-&gt;blockSize = blockSize;
-    p-&gt;bufferBase = (Byte *)alloc-&gt;Alloc(alloc, (size_t)blockSize);
-  }
-  return (p-&gt;bufferBase != 0);
-}
-
-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p-&gt;buffer; }
-Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p-&gt;buffer[index]; }
-
-UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p-&gt;streamPos - p-&gt;pos; }
-
-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-{
-  p-&gt;posLimit -= subValue;
-  p-&gt;pos -= subValue;
-  p-&gt;streamPos -= subValue;
-}
-
-static void MatchFinder_ReadBlock(CMatchFinder *p)
-{
-  if (p-&gt;streamEndWasReached || p-&gt;result != SZ_OK)
-    return;
-  for (;;)
-  {
-    Byte *dest = p-&gt;buffer + (p-&gt;streamPos - p-&gt;pos);
-    size_t size = (p-&gt;bufferBase + p-&gt;blockSize - dest);
-    if (size == 0)
-      return;
-    p-&gt;result = p-&gt;stream-&gt;Read(p-&gt;stream, dest, &amp;size);
-    if (p-&gt;result != SZ_OK)
-      return;
-    if (size == 0)
-    {
-      p-&gt;streamEndWasReached = 1;
-      return;
-    }
-    p-&gt;streamPos += (UInt32)size;
-    if (p-&gt;streamPos - p-&gt;pos &gt; p-&gt;keepSizeAfter)
-      return;
-  }
-}
-
-void MatchFinder_MoveBlock(CMatchFinder *p)
-{
-  memmove(p-&gt;bufferBase,
-    p-&gt;buffer - p-&gt;keepSizeBefore,
-    (size_t)(p-&gt;streamPos - p-&gt;pos + p-&gt;keepSizeBefore));
-  p-&gt;buffer = p-&gt;bufferBase + p-&gt;keepSizeBefore;
-}
-
-int MatchFinder_NeedMove(CMatchFinder *p)
-{
-  /* if (p-&gt;streamEndWasReached) return 0; */
-  return ((size_t)(p-&gt;bufferBase + p-&gt;blockSize - p-&gt;buffer) &lt;= p-&gt;keepSizeAfter);
-}
-
-void MatchFinder_ReadIfRequired(CMatchFinder *p)
-{
-  if (p-&gt;streamEndWasReached)
-    return;
-  if (p-&gt;keepSizeAfter &gt;= p-&gt;streamPos - p-&gt;pos)
-    MatchFinder_ReadBlock(p);
-}
-
-static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
-{
-  if (MatchFinder_NeedMove(p))
-    MatchFinder_MoveBlock(p);
-  MatchFinder_ReadBlock(p);
-}
-
-static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
-{
-  p-&gt;cutValue = 32;
-  p-&gt;btMode = 1;
-  p-&gt;numHashBytes = 4;
-  /* p-&gt;skipModeBits = 0; */
-  p-&gt;directInput = 0;
-  p-&gt;bigHash = 0;
-}
-
-#define kCrcPoly 0xEDB88320
-
-void MatchFinder_Construct(CMatchFinder *p)
-{
-  UInt32 i;
-  p-&gt;bufferBase = 0;
-  p-&gt;directInput = 0;
-  p-&gt;hash = 0;
-  MatchFinder_SetDefaultSettings(p);
-
-  for (i = 0; i &lt; 256; i++)
-  {
-    UInt32 r = i;
-    int j;
-    for (j = 0; j &lt; 8; j++)
-      r = (r &gt;&gt; 1) ^ (kCrcPoly &amp; ~((r &amp; 1) - 1));
-    p-&gt;crc[i] = r;
-  }
-}
-
-static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;hash);
-  p-&gt;hash = 0;
-}
-
-void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
-{
-  MatchFinder_FreeThisClassMemory(p, alloc);
-  LzInWindow_Free(p, alloc);
-}
-
-static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
-{
-  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
-  if (sizeInBytes / sizeof(CLzRef) != num)
-    return 0;
-  return (CLzRef *)alloc-&gt;Alloc(alloc, sizeInBytes);
-}
-
-int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-    ISzAlloc *alloc)
-{
-  UInt32 sizeReserv;
-  if (historySize &gt; kMaxHistorySize)
-  {
-    MatchFinder_Free(p, alloc);
-    return 0;
-  }
-  sizeReserv = historySize &gt;&gt; 1;
-  if (historySize &gt; ((UInt32)2 &lt;&lt; 30))
-    sizeReserv = historySize &gt;&gt; 2;
-  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 &lt;&lt; 19);
-
-  p-&gt;keepSizeBefore = historySize + keepAddBufferBefore + 1;
-  p-&gt;keepSizeAfter = matchMaxLen + keepAddBufferAfter;
-  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
-  if (LzInWindow_Create(p, sizeReserv, alloc))
-  {
-    UInt32 newCyclicBufferSize = (historySize /* &gt;&gt; p-&gt;skipModeBits */) + 1;
-    UInt32 hs;
-    p-&gt;matchMaxLen = matchMaxLen;
-    {
-      p-&gt;fixedHashSize = 0;
-      if (p-&gt;numHashBytes == 2)
-        hs = (1 &lt;&lt; 16) - 1;
-      else
-      {
-        hs = historySize - 1;
-        hs |= (hs &gt;&gt; 1);
-        hs |= (hs &gt;&gt; 2);
-        hs |= (hs &gt;&gt; 4);
-        hs |= (hs &gt;&gt; 8);
-        hs &gt;&gt;= 1;
-        /* hs &gt;&gt;= p-&gt;skipModeBits; */
-        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
-        if (hs &gt; (1 &lt;&lt; 24))
-        {
-          if (p-&gt;numHashBytes == 3)
-            hs = (1 &lt;&lt; 24) - 1;
-          else
-            hs &gt;&gt;= 1;
-        }
-      }
-      p-&gt;hashMask = hs;
-      hs++;
-      if (p-&gt;numHashBytes &gt; 2) p-&gt;fixedHashSize += kHash2Size;
-      if (p-&gt;numHashBytes &gt; 3) p-&gt;fixedHashSize += kHash3Size;
-      if (p-&gt;numHashBytes &gt; 4) p-&gt;fixedHashSize += kHash4Size;
-      hs += p-&gt;fixedHashSize;
-    }
-
-    {
-      UInt32 prevSize = p-&gt;hashSizeSum + p-&gt;numSons;
-      UInt32 newSize;
-      p-&gt;historySize = historySize;
-      p-&gt;hashSizeSum = hs;
-      p-&gt;cyclicBufferSize = newCyclicBufferSize;
-      p-&gt;numSons = (p-&gt;btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
-      newSize = p-&gt;hashSizeSum + p-&gt;numSons;
-      if (p-&gt;hash != 0 &amp;&amp; prevSize == newSize)
-        return 1;
-      MatchFinder_FreeThisClassMemory(p, alloc);
-      p-&gt;hash = AllocRefs(newSize, alloc);
-      if (p-&gt;hash != 0)
-      {
-        p-&gt;son = p-&gt;hash + p-&gt;hashSizeSum;
-        return 1;
-      }
-    }
-  }
-  MatchFinder_Free(p, alloc);
-  return 0;
-}
-
-static void MatchFinder_SetLimits(CMatchFinder *p)
-{
-  UInt32 limit = kMaxValForNormalize - p-&gt;pos;
-  UInt32 limit2 = p-&gt;cyclicBufferSize - p-&gt;cyclicBufferPos;
-  if (limit2 &lt; limit)
-    limit = limit2;
-  limit2 = p-&gt;streamPos - p-&gt;pos;
-  if (limit2 &lt;= p-&gt;keepSizeAfter)
-  {
-    if (limit2 &gt; 0)
-      limit2 = 1;
-  }
-  else
-    limit2 -= p-&gt;keepSizeAfter;
-  if (limit2 &lt; limit)
-    limit = limit2;
-  {
-    UInt32 lenLimit = p-&gt;streamPos - p-&gt;pos;
-    if (lenLimit &gt; p-&gt;matchMaxLen)
-      lenLimit = p-&gt;matchMaxLen;
-    p-&gt;lenLimit = lenLimit;
-  }
-  p-&gt;posLimit = p-&gt;pos + limit;
-}
-
-void MatchFinder_Init(CMatchFinder *p)
-{
-  UInt32 i;
-  for (i = 0; i &lt; p-&gt;hashSizeSum; i++)
-    p-&gt;hash[i] = kEmptyHashValue;
-  p-&gt;cyclicBufferPos = 0;
-  p-&gt;buffer = p-&gt;bufferBase;
-  p-&gt;pos = p-&gt;streamPos = p-&gt;cyclicBufferSize;
-  p-&gt;result = SZ_OK;
-  p-&gt;streamEndWasReached = 0;
-  MatchFinder_ReadBlock(p);
-  MatchFinder_SetLimits(p);
-}
-
-static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
-{
-  return (p-&gt;pos - p-&gt;historySize - 1) &amp; kNormalizeMask;
-}
-
-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
-{
-  UInt32 i;
-  for (i = 0; i &lt; numItems; i++)
-  {
-    UInt32 value = items[i];
-    if (value &lt;= subValue)
-      value = kEmptyHashValue;
-    else
-      value -= subValue;
-    items[i] = value;
-  }
-}
-
-static void MatchFinder_Normalize(CMatchFinder *p)
-{
-  UInt32 subValue = MatchFinder_GetSubValue(p);
-  MatchFinder_Normalize3(subValue, p-&gt;hash, p-&gt;hashSizeSum + p-&gt;numSons);
-  MatchFinder_ReduceOffsets(p, subValue);
-}
-
-static void MatchFinder_CheckLimits(CMatchFinder *p)
-{
-  if (p-&gt;pos == kMaxValForNormalize)
-    MatchFinder_Normalize(p);
-  if (!p-&gt;streamEndWasReached &amp;&amp; p-&gt;keepSizeAfter == p-&gt;streamPos - p-&gt;pos)
-    MatchFinder_CheckAndMoveAndRead(p);
-  if (p-&gt;cyclicBufferPos == p-&gt;cyclicBufferSize)
-    p-&gt;cyclicBufferPos = 0;
-  MatchFinder_SetLimits(p);
-}
-
-static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-    UInt32 *distances, UInt32 maxLen)
-{
-  son[_cyclicBufferPos] = curMatch;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
-      return distances;
-    {
-      const Byte *pb = cur - delta;
-      curMatch = son[_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)];
-      if (pb[maxLen] == cur[maxLen] &amp;&amp; *pb == *cur)
-      {
-        UInt32 len = 0;
-        while (++len != lenLimit)
-          if (pb[len] != cur[len])
-            break;
-        if (maxLen &lt; len)
-        {
-          *distances++ = maxLen = len;
-          *distances++ = delta - 1;
-          if (len == lenLimit)
-            return distances;
-        }
-      }
-    }
-  }
-}
-
-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-    UInt32 *distances, UInt32 maxLen)
-{
-  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
-  UInt32 len0 = 0, len1 = 0;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
-    {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      return distances;
-    }
-    {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
-      const Byte *pb = cur - delta;
-      UInt32 len = (len0 &lt; len1 ? len0 : len1);
-      if (pb[len] == cur[len])
-      {
-        if (++len != lenLimit &amp;&amp; pb[len] == cur[len])
-          while (++len != lenLimit)
-            if (pb[len] != cur[len])
-              break;
-        if (maxLen &lt; len)
-        {
-          *distances++ = maxLen = len;
-          *distances++ = delta - 1;
-          if (len == lenLimit)
-          {
-            *ptr1 = pair[0];
-            *ptr0 = pair[1];
-            return distances;
-          }
-        }
-      }
-      if (pb[len] &lt; cur[len])
-      {
-        *ptr1 = curMatch;
-        ptr1 = pair + 1;
-        curMatch = *ptr1;
-        len1 = len;
-      }
-      else
-      {
-        *ptr0 = curMatch;
-        ptr0 = pair;
-        curMatch = *ptr0;
-        len0 = len;
-      }
-    }
-  }
-}
-
-static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
-{
-  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
-  UInt32 len0 = 0, len1 = 0;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
-    {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      return;
-    }
-    {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
-      const Byte *pb = cur - delta;
-      UInt32 len = (len0 &lt; len1 ? len0 : len1);
-      if (pb[len] == cur[len])
-      {
-        while (++len != lenLimit)
-          if (pb[len] != cur[len])
-            break;
-        {
-          if (len == lenLimit)
-          {
-            *ptr1 = pair[0];
-            *ptr0 = pair[1];
-            return;
-          }
-        }
-      }
-      if (pb[len] &lt; cur[len])
-      {
-        *ptr1 = curMatch;
-        ptr1 = pair + 1;
-        curMatch = *ptr1;
-        len1 = len;
-      }
-      else
-      {
-        *ptr0 = curMatch;
-        ptr0 = pair;
-        curMatch = *ptr0;
-        len0 = len;
-      }
-    }
-  }
-}
-
-#define MOVE_POS \
-  ++p-&gt;cyclicBufferPos; \
-  p-&gt;buffer++; \
-  if (++p-&gt;pos == p-&gt;posLimit) MatchFinder_CheckLimits(p);
-
-#define MOVE_POS_RET MOVE_POS return offset;
-
-static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
-
-#define GET_MATCHES_HEADER2(minLen, ret_op) \
-  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
-  lenLimit = p-&gt;lenLimit; { if (lenLimit &lt; minLen) { MatchFinder_MovePos(p); ret_op; }} \
-  cur = p-&gt;buffer;
-
-#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
-#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
-
-#define MF_PARAMS(p) p-&gt;pos, p-&gt;buffer, p-&gt;son, p-&gt;cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue
-
-#define GET_MATCHES_FOOTER(offset, maxLen) \
-  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
-  distances + offset, maxLen) - distances); MOVE_POS_RET;
-
-#define SKIP_FOOTER \
-  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
-
-static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(2)
-  HASH2_CALC;
-  curMatch = p-&gt;hash[hashValue];
-  p-&gt;hash[hashValue] = p-&gt;pos;
-  offset = 0;
-  GET_MATCHES_FOOTER(offset, 1)
-}
-
-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(3)
-  HASH_ZIP_CALC;
-  curMatch = p-&gt;hash[hashValue];
-  p-&gt;hash[hashValue] = p-&gt;pos;
-  offset = 0;
-  GET_MATCHES_FOOTER(offset, 2)
-}
-
-static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 hash2Value, delta2, maxLen, offset;
-  GET_MATCHES_HEADER(3)
-
-  HASH3_CALC;
-
-  delta2 = p-&gt;pos - p-&gt;hash[hash2Value];
-  curMatch = p-&gt;hash[kFix3HashSize + hashValue];
-  
-  p-&gt;hash[hash2Value] =
-  p-&gt;hash[kFix3HashSize + hashValue] = p-&gt;pos;
-
-
-  maxLen = 2;
-  offset = 0;
-  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
-  {
-    for (; maxLen != lenLimit; maxLen++)
-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-        break;
-    distances[0] = maxLen;
-    distances[1] = delta2 - 1;
-    offset = 2;
-    if (maxLen == lenLimit)
-    {
-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-      MOVE_POS_RET;
-    }
-  }
-  GET_MATCHES_FOOTER(offset, maxLen)
-}
-
-static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-  GET_MATCHES_HEADER(4)
-
-  HASH4_CALC;
-
-  delta2 = p-&gt;pos - p-&gt;hash[                hash2Value];
-  delta3 = p-&gt;pos - p-&gt;hash[kFix3HashSize + hash3Value];
-  curMatch = p-&gt;hash[kFix4HashSize + hashValue];
-  
-  p-&gt;hash[                hash2Value] =
-  p-&gt;hash[kFix3HashSize + hash3Value] =
-  p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
-
-  maxLen = 1;
-  offset = 0;
-  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
-  {
-    distances[0] = maxLen = 2;
-    distances[1] = delta2 - 1;
-    offset = 2;
-  }
-  if (delta2 != delta3 &amp;&amp; delta3 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta3) == *cur)
-  {
-    maxLen = 3;
-    distances[offset + 1] = delta3 - 1;
-    offset += 2;
-    delta2 = delta3;
-  }
-  if (offset != 0)
-  {
-    for (; maxLen != lenLimit; maxLen++)
-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-        break;
-    distances[offset - 2] = maxLen;
-    if (maxLen == lenLimit)
-    {
-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-      MOVE_POS_RET;
-    }
-  }
-  if (maxLen &lt; 3)
-    maxLen = 3;
-  GET_MATCHES_FOOTER(offset, maxLen)
-}
-
-static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-  GET_MATCHES_HEADER(4)
-
-  HASH4_CALC;
-
-  delta2 = p-&gt;pos - p-&gt;hash[                hash2Value];
-  delta3 = p-&gt;pos - p-&gt;hash[kFix3HashSize + hash3Value];
-  curMatch = p-&gt;hash[kFix4HashSize + hashValue];
-
-  p-&gt;hash[                hash2Value] =
-  p-&gt;hash[kFix3HashSize + hash3Value] =
-  p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
-
-  maxLen = 1;
-  offset = 0;
-  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
-  {
-    distances[0] = maxLen = 2;
-    distances[1] = delta2 - 1;
-    offset = 2;
-  }
-  if (delta2 != delta3 &amp;&amp; delta3 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta3) == *cur)
-  {
-    maxLen = 3;
-    distances[offset + 1] = delta3 - 1;
-    offset += 2;
-    delta2 = delta3;
-  }
-  if (offset != 0)
-  {
-    for (; maxLen != lenLimit; maxLen++)
-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-        break;
-    distances[offset - 2] = maxLen;
-    if (maxLen == lenLimit)
-    {
-      p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
-      MOVE_POS_RET;
-    }
-  }
-  if (maxLen &lt; 3)
-    maxLen = 3;
-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-    distances + offset, maxLen) - (distances));
-  MOVE_POS_RET
-}
-
-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(3)
-  HASH_ZIP_CALC;
-  curMatch = p-&gt;hash[hashValue];
-  p-&gt;hash[hashValue] = p-&gt;pos;
-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-    distances, 2) - (distances));
-  MOVE_POS_RET
-}
-
-static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(2)
-    HASH2_CALC;
-    curMatch = p-&gt;hash[hashValue];
-    p-&gt;hash[hashValue] = p-&gt;pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(3)
-    HASH_ZIP_CALC;
-    curMatch = p-&gt;hash[hashValue];
-    p-&gt;hash[hashValue] = p-&gt;pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 hash2Value;
-    SKIP_HEADER(3)
-    HASH3_CALC;
-    curMatch = p-&gt;hash[kFix3HashSize + hashValue];
-    p-&gt;hash[hash2Value] =
-    p-&gt;hash[kFix3HashSize + hashValue] = p-&gt;pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 hash2Value, hash3Value;
-    SKIP_HEADER(4)
-    HASH4_CALC;
-    curMatch = p-&gt;hash[kFix4HashSize + hashValue];
-    p-&gt;hash[                hash2Value] =
-    p-&gt;hash[kFix3HashSize + hash3Value] = p-&gt;pos;
-    p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 hash2Value, hash3Value;
-    SKIP_HEADER(4)
-    HASH4_CALC;
-    curMatch = p-&gt;hash[kFix4HashSize + hashValue];
-    p-&gt;hash[                hash2Value] =
-    p-&gt;hash[kFix3HashSize + hash3Value] =
-    p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
-    p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
-    MOVE_POS
-  }
-  while (--num != 0);
-}
-
-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(3)
-    HASH_ZIP_CALC;
-    curMatch = p-&gt;hash[hashValue];
-    p-&gt;hash[hashValue] = p-&gt;pos;
-    p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
-    MOVE_POS
-  }
-  while (--num != 0);
-}
-
-void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
-{
-  vTable-&gt;Init = (Mf_Init_Func)MatchFinder_Init;
-  vTable-&gt;GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
-  vTable-&gt;GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-  vTable-&gt;GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
-  if (!p-&gt;btMode)
-  {
-    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
-    vTable-&gt;Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
-  }
-  else if (p-&gt;numHashBytes == 2)
-  {
-    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
-    vTable-&gt;Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
-  }
-  else if (p-&gt;numHashBytes == 3)
-  {
-    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
-    vTable-&gt;Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
-  }
-  else
-  {
-    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-    vTable-&gt;Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
-  }
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,753 @@
+/* LzFind.c  -- Match finder for LZ algorithms
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#include &lt;string.h&gt;
+
+#include &quot;LzFind.h&quot;
+#include &quot;LzHash.h&quot;
+
+#define kEmptyHashValue 0
+#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
+#define kNormalizeStepMin (1 &lt;&lt; 10) /* it must be power of 2 */
+#define kNormalizeMask (~(kNormalizeStepMin - 1))
+#define kMaxHistorySize ((UInt32)3 &lt;&lt; 30)
+
+#define kStartMaxLen 3
+
+static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
+{
+  if (!p-&gt;directInput)
+  {
+    alloc-&gt;Free(alloc, p-&gt;bufferBase);
+    p-&gt;bufferBase = 0;
+  }
+}
+
+/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be &lt; 4G) */
+
+static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
+{
+  UInt32 blockSize = p-&gt;keepSizeBefore + p-&gt;keepSizeAfter + keepSizeReserv;
+  if (p-&gt;directInput)
+  {
+    p-&gt;blockSize = blockSize;
+    return 1;
+  }
+  if (p-&gt;bufferBase == 0 || p-&gt;blockSize != blockSize)
+  {
+    LzInWindow_Free(p, alloc);
+    p-&gt;blockSize = blockSize;
+    p-&gt;bufferBase = (Byte *)alloc-&gt;Alloc(alloc, (size_t)blockSize);
+  }
+  return (p-&gt;bufferBase != 0);
+}
+
+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p-&gt;buffer; }
+Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p-&gt;buffer[index]; }
+
+UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p-&gt;streamPos - p-&gt;pos; }
+
+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
+{
+  p-&gt;posLimit -= subValue;
+  p-&gt;pos -= subValue;
+  p-&gt;streamPos -= subValue;
+}
+
+static void MatchFinder_ReadBlock(CMatchFinder *p)
+{
+  if (p-&gt;streamEndWasReached || p-&gt;result != SZ_OK)
+    return;
+  for (;;)
+  {
+    Byte *dest = p-&gt;buffer + (p-&gt;streamPos - p-&gt;pos);
+    size_t size = (p-&gt;bufferBase + p-&gt;blockSize - dest);
+    if (size == 0)
+      return;
+    p-&gt;result = p-&gt;stream-&gt;Read(p-&gt;stream, dest, &amp;size);
+    if (p-&gt;result != SZ_OK)
+      return;
+    if (size == 0)
+    {
+      p-&gt;streamEndWasReached = 1;
+      return;
+    }
+    p-&gt;streamPos += (UInt32)size;
+    if (p-&gt;streamPos - p-&gt;pos &gt; p-&gt;keepSizeAfter)
+      return;
+  }
+}
+
+void MatchFinder_MoveBlock(CMatchFinder *p)
+{
+  memmove(p-&gt;bufferBase,
+    p-&gt;buffer - p-&gt;keepSizeBefore,
+    (size_t)(p-&gt;streamPos - p-&gt;pos + p-&gt;keepSizeBefore));
+  p-&gt;buffer = p-&gt;bufferBase + p-&gt;keepSizeBefore;
+}
+
+int MatchFinder_NeedMove(CMatchFinder *p)
+{
+  /* if (p-&gt;streamEndWasReached) return 0; */
+  return ((size_t)(p-&gt;bufferBase + p-&gt;blockSize - p-&gt;buffer) &lt;= p-&gt;keepSizeAfter);
+}
+
+void MatchFinder_ReadIfRequired(CMatchFinder *p)
+{
+  if (p-&gt;streamEndWasReached)
+    return;
+  if (p-&gt;keepSizeAfter &gt;= p-&gt;streamPos - p-&gt;pos)
+    MatchFinder_ReadBlock(p);
+}
+
+static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
+{
+  if (MatchFinder_NeedMove(p))
+    MatchFinder_MoveBlock(p);
+  MatchFinder_ReadBlock(p);
+}
+
+static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
+{
+  p-&gt;cutValue = 32;
+  p-&gt;btMode = 1;
+  p-&gt;numHashBytes = 4;
+  /* p-&gt;skipModeBits = 0; */
+  p-&gt;directInput = 0;
+  p-&gt;bigHash = 0;
+}
+
+#define kCrcPoly 0xEDB88320
+
+void MatchFinder_Construct(CMatchFinder *p)
+{
+  UInt32 i;
+  p-&gt;bufferBase = 0;
+  p-&gt;directInput = 0;
+  p-&gt;hash = 0;
+  MatchFinder_SetDefaultSettings(p);
+
+  for (i = 0; i &lt; 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j &lt; 8; j++)
+      r = (r &gt;&gt; 1) ^ (kCrcPoly &amp; ~((r &amp; 1) - 1));
+    p-&gt;crc[i] = r;
+  }
+}
+
+static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;hash);
+  p-&gt;hash = 0;
+}
+
+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
+{
+  MatchFinder_FreeThisClassMemory(p, alloc);
+  LzInWindow_Free(p, alloc);
+}
+
+static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
+{
+  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
+  if (sizeInBytes / sizeof(CLzRef) != num)
+    return 0;
+  return (CLzRef *)alloc-&gt;Alloc(alloc, sizeInBytes);
+}
+
+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+    ISzAlloc *alloc)
+{
+  UInt32 sizeReserv;
+  if (historySize &gt; kMaxHistorySize)
+  {
+    MatchFinder_Free(p, alloc);
+    return 0;
+  }
+  sizeReserv = historySize &gt;&gt; 1;
+  if (historySize &gt; ((UInt32)2 &lt;&lt; 30))
+    sizeReserv = historySize &gt;&gt; 2;
+  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 &lt;&lt; 19);
+
+  p-&gt;keepSizeBefore = historySize + keepAddBufferBefore + 1;
+  p-&gt;keepSizeAfter = matchMaxLen + keepAddBufferAfter;
+  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
+  if (LzInWindow_Create(p, sizeReserv, alloc))
+  {
+    UInt32 newCyclicBufferSize = (historySize /* &gt;&gt; p-&gt;skipModeBits */) + 1;
+    UInt32 hs;
+    p-&gt;matchMaxLen = matchMaxLen;
+    {
+      p-&gt;fixedHashSize = 0;
+      if (p-&gt;numHashBytes == 2)
+        hs = (1 &lt;&lt; 16) - 1;
+      else
+      {
+        hs = historySize - 1;
+        hs |= (hs &gt;&gt; 1);
+        hs |= (hs &gt;&gt; 2);
+        hs |= (hs &gt;&gt; 4);
+        hs |= (hs &gt;&gt; 8);
+        hs &gt;&gt;= 1;
+        /* hs &gt;&gt;= p-&gt;skipModeBits; */
+        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
+        if (hs &gt; (1 &lt;&lt; 24))
+        {
+          if (p-&gt;numHashBytes == 3)
+            hs = (1 &lt;&lt; 24) - 1;
+          else
+            hs &gt;&gt;= 1;
+        }
+      }
+      p-&gt;hashMask = hs;
+      hs++;
+      if (p-&gt;numHashBytes &gt; 2) p-&gt;fixedHashSize += kHash2Size;
+      if (p-&gt;numHashBytes &gt; 3) p-&gt;fixedHashSize += kHash3Size;
+      if (p-&gt;numHashBytes &gt; 4) p-&gt;fixedHashSize += kHash4Size;
+      hs += p-&gt;fixedHashSize;
+    }
+
+    {
+      UInt32 prevSize = p-&gt;hashSizeSum + p-&gt;numSons;
+      UInt32 newSize;
+      p-&gt;historySize = historySize;
+      p-&gt;hashSizeSum = hs;
+      p-&gt;cyclicBufferSize = newCyclicBufferSize;
+      p-&gt;numSons = (p-&gt;btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
+      newSize = p-&gt;hashSizeSum + p-&gt;numSons;
+      if (p-&gt;hash != 0 &amp;&amp; prevSize == newSize)
+        return 1;
+      MatchFinder_FreeThisClassMemory(p, alloc);
+      p-&gt;hash = AllocRefs(newSize, alloc);
+      if (p-&gt;hash != 0)
+      {
+        p-&gt;son = p-&gt;hash + p-&gt;hashSizeSum;
+        return 1;
+      }
+    }
+  }
+  MatchFinder_Free(p, alloc);
+  return 0;
+}
+
+static void MatchFinder_SetLimits(CMatchFinder *p)
+{
+  UInt32 limit = kMaxValForNormalize - p-&gt;pos;
+  UInt32 limit2 = p-&gt;cyclicBufferSize - p-&gt;cyclicBufferPos;
+  if (limit2 &lt; limit)
+    limit = limit2;
+  limit2 = p-&gt;streamPos - p-&gt;pos;
+  if (limit2 &lt;= p-&gt;keepSizeAfter)
+  {
+    if (limit2 &gt; 0)
+      limit2 = 1;
+  }
+  else
+    limit2 -= p-&gt;keepSizeAfter;
+  if (limit2 &lt; limit)
+    limit = limit2;
+  {
+    UInt32 lenLimit = p-&gt;streamPos - p-&gt;pos;
+    if (lenLimit &gt; p-&gt;matchMaxLen)
+      lenLimit = p-&gt;matchMaxLen;
+    p-&gt;lenLimit = lenLimit;
+  }
+  p-&gt;posLimit = p-&gt;pos + limit;
+}
+
+void MatchFinder_Init(CMatchFinder *p)
+{
+  UInt32 i;
+  for (i = 0; i &lt; p-&gt;hashSizeSum; i++)
+    p-&gt;hash[i] = kEmptyHashValue;
+  p-&gt;cyclicBufferPos = 0;
+  p-&gt;buffer = p-&gt;bufferBase;
+  p-&gt;pos = p-&gt;streamPos = p-&gt;cyclicBufferSize;
+  p-&gt;result = SZ_OK;
+  p-&gt;streamEndWasReached = 0;
+  MatchFinder_ReadBlock(p);
+  MatchFinder_SetLimits(p);
+}
+
+static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
+{
+  return (p-&gt;pos - p-&gt;historySize - 1) &amp; kNormalizeMask;
+}
+
+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
+{
+  UInt32 i;
+  for (i = 0; i &lt; numItems; i++)
+  {
+    UInt32 value = items[i];
+    if (value &lt;= subValue)
+      value = kEmptyHashValue;
+    else
+      value -= subValue;
+    items[i] = value;
+  }
+}
+
+static void MatchFinder_Normalize(CMatchFinder *p)
+{
+  UInt32 subValue = MatchFinder_GetSubValue(p);
+  MatchFinder_Normalize3(subValue, p-&gt;hash, p-&gt;hashSizeSum + p-&gt;numSons);
+  MatchFinder_ReduceOffsets(p, subValue);
+}
+
+static void MatchFinder_CheckLimits(CMatchFinder *p)
+{
+  if (p-&gt;pos == kMaxValForNormalize)
+    MatchFinder_Normalize(p);
+  if (!p-&gt;streamEndWasReached &amp;&amp; p-&gt;keepSizeAfter == p-&gt;streamPos - p-&gt;pos)
+    MatchFinder_CheckAndMoveAndRead(p);
+  if (p-&gt;cyclicBufferPos == p-&gt;cyclicBufferSize)
+    p-&gt;cyclicBufferPos = 0;
+  MatchFinder_SetLimits(p);
+}
+
+static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+    UInt32 *distances, UInt32 maxLen)
+{
+  son[_cyclicBufferPos] = curMatch;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
+      return distances;
+    {
+      const Byte *pb = cur - delta;
+      curMatch = son[_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)];
+      if (pb[maxLen] == cur[maxLen] &amp;&amp; *pb == *cur)
+      {
+        UInt32 len = 0;
+        while (++len != lenLimit)
+          if (pb[len] != cur[len])
+            break;
+        if (maxLen &lt; len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+            return distances;
+        }
+      }
+    }
+  }
+}
+
+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+    UInt32 *distances, UInt32 maxLen)
+{
+  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
+  UInt32 len0 = 0, len1 = 0;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      return distances;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 &lt; len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        if (++len != lenLimit &amp;&amp; pb[len] == cur[len])
+          while (++len != lenLimit)
+            if (pb[len] != cur[len])
+              break;
+        if (maxLen &lt; len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            return distances;
+          }
+        }
+      }
+      if (pb[len] &lt; cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+}
+
+static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
+{
+  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
+  UInt32 len0 = 0, len1 = 0;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      return;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 &lt; len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        while (++len != lenLimit)
+          if (pb[len] != cur[len])
+            break;
+        {
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            return;
+          }
+        }
+      }
+      if (pb[len] &lt; cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+}
+
+#define MOVE_POS \
+  ++p-&gt;cyclicBufferPos; \
+  p-&gt;buffer++; \
+  if (++p-&gt;pos == p-&gt;posLimit) MatchFinder_CheckLimits(p);
+
+#define MOVE_POS_RET MOVE_POS return offset;
+
+static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
+
+#define GET_MATCHES_HEADER2(minLen, ret_op) \
+  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
+  lenLimit = p-&gt;lenLimit; { if (lenLimit &lt; minLen) { MatchFinder_MovePos(p); ret_op; }} \
+  cur = p-&gt;buffer;
+
+#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
+#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
+
+#define MF_PARAMS(p) p-&gt;pos, p-&gt;buffer, p-&gt;son, p-&gt;cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue
+
+#define GET_MATCHES_FOOTER(offset, maxLen) \
+  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
+  distances + offset, maxLen) - distances); MOVE_POS_RET;
+
+#define SKIP_FOOTER \
+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
+
+static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(2)
+  HASH2_CALC;
+  curMatch = p-&gt;hash[hashValue];
+  p-&gt;hash[hashValue] = p-&gt;pos;
+  offset = 0;
+  GET_MATCHES_FOOTER(offset, 1)
+}
+
+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(3)
+  HASH_ZIP_CALC;
+  curMatch = p-&gt;hash[hashValue];
+  p-&gt;hash[hashValue] = p-&gt;pos;
+  offset = 0;
+  GET_MATCHES_FOOTER(offset, 2)
+}
+
+static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, delta2, maxLen, offset;
+  GET_MATCHES_HEADER(3)
+
+  HASH3_CALC;
+
+  delta2 = p-&gt;pos - p-&gt;hash[hash2Value];
+  curMatch = p-&gt;hash[kFix3HashSize + hashValue];
+  
+  p-&gt;hash[hash2Value] =
+  p-&gt;hash[kFix3HashSize + hashValue] = p-&gt;pos;
+
+
+  maxLen = 2;
+  offset = 0;
+  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[0] = maxLen;
+    distances[1] = delta2 - 1;
+    offset = 2;
+    if (maxLen == lenLimit)
+    {
+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+      MOVE_POS_RET;
+    }
+  }
+  GET_MATCHES_FOOTER(offset, maxLen)
+}
+
+static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+  GET_MATCHES_HEADER(4)
+
+  HASH4_CALC;
+
+  delta2 = p-&gt;pos - p-&gt;hash[                hash2Value];
+  delta3 = p-&gt;pos - p-&gt;hash[kFix3HashSize + hash3Value];
+  curMatch = p-&gt;hash[kFix4HashSize + hashValue];
+  
+  p-&gt;hash[                hash2Value] =
+  p-&gt;hash[kFix3HashSize + hash3Value] =
+  p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
+
+  maxLen = 1;
+  offset = 0;
+  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
+  {
+    distances[0] = maxLen = 2;
+    distances[1] = delta2 - 1;
+    offset = 2;
+  }
+  if (delta2 != delta3 &amp;&amp; delta3 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta3) == *cur)
+  {
+    maxLen = 3;
+    distances[offset + 1] = delta3 - 1;
+    offset += 2;
+    delta2 = delta3;
+  }
+  if (offset != 0)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[offset - 2] = maxLen;
+    if (maxLen == lenLimit)
+    {
+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+      MOVE_POS_RET;
+    }
+  }
+  if (maxLen &lt; 3)
+    maxLen = 3;
+  GET_MATCHES_FOOTER(offset, maxLen)
+}
+
+static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+  GET_MATCHES_HEADER(4)
+
+  HASH4_CALC;
+
+  delta2 = p-&gt;pos - p-&gt;hash[                hash2Value];
+  delta3 = p-&gt;pos - p-&gt;hash[kFix3HashSize + hash3Value];
+  curMatch = p-&gt;hash[kFix4HashSize + hashValue];
+
+  p-&gt;hash[                hash2Value] =
+  p-&gt;hash[kFix3HashSize + hash3Value] =
+  p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
+
+  maxLen = 1;
+  offset = 0;
+  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
+  {
+    distances[0] = maxLen = 2;
+    distances[1] = delta2 - 1;
+    offset = 2;
+  }
+  if (delta2 != delta3 &amp;&amp; delta3 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta3) == *cur)
+  {
+    maxLen = 3;
+    distances[offset + 1] = delta3 - 1;
+    offset += 2;
+    delta2 = delta3;
+  }
+  if (offset != 0)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[offset - 2] = maxLen;
+    if (maxLen == lenLimit)
+    {
+      p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
+      MOVE_POS_RET;
+    }
+  }
+  if (maxLen &lt; 3)
+    maxLen = 3;
+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+    distances + offset, maxLen) - (distances));
+  MOVE_POS_RET
+}
+
+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(3)
+  HASH_ZIP_CALC;
+  curMatch = p-&gt;hash[hashValue];
+  p-&gt;hash[hashValue] = p-&gt;pos;
+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+    distances, 2) - (distances));
+  MOVE_POS_RET
+}
+
+static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(2)
+    HASH2_CALC;
+    curMatch = p-&gt;hash[hashValue];
+    p-&gt;hash[hashValue] = p-&gt;pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(3)
+    HASH_ZIP_CALC;
+    curMatch = p-&gt;hash[hashValue];
+    p-&gt;hash[hashValue] = p-&gt;pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value;
+    SKIP_HEADER(3)
+    HASH3_CALC;
+    curMatch = p-&gt;hash[kFix3HashSize + hashValue];
+    p-&gt;hash[hash2Value] =
+    p-&gt;hash[kFix3HashSize + hashValue] = p-&gt;pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value, hash3Value;
+    SKIP_HEADER(4)
+    HASH4_CALC;
+    curMatch = p-&gt;hash[kFix4HashSize + hashValue];
+    p-&gt;hash[                hash2Value] =
+    p-&gt;hash[kFix3HashSize + hash3Value] = p-&gt;pos;
+    p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value, hash3Value;
+    SKIP_HEADER(4)
+    HASH4_CALC;
+    curMatch = p-&gt;hash[kFix4HashSize + hashValue];
+    p-&gt;hash[                hash2Value] =
+    p-&gt;hash[kFix3HashSize + hash3Value] =
+    p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
+    p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
+    MOVE_POS
+  }
+  while (--num != 0);
+}
+
+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(3)
+    HASH_ZIP_CALC;
+    curMatch = p-&gt;hash[hashValue];
+    p-&gt;hash[hashValue] = p-&gt;pos;
+    p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
+    MOVE_POS
+  }
+  while (--num != 0);
+}
+
+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
+{
+  vTable-&gt;Init = (Mf_Init_Func)MatchFinder_Init;
+  vTable-&gt;GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
+  vTable-&gt;GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
+  vTable-&gt;GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
+  if (!p-&gt;btMode)
+  {
+    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
+    vTable-&gt;Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
+  }
+  else if (p-&gt;numHashBytes == 2)
+  {
+    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
+    vTable-&gt;Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
+  }
+  else if (p-&gt;numHashBytes == 3)
+  {
+    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
+    vTable-&gt;Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
+  }
+  else
+  {
+    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
+    vTable-&gt;Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+  }
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,116 +0,0 @@
-/* LzFind.h  -- Match finder for LZ algorithms
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-You can use any of the following license options:
-  1) GNU Lesser General Public License (GNU LGPL)
-  2) Common Public License (CPL)
-  3) Common Development and Distribution License (CDDL) Version 1.0
-  4) Igor Pavlov, as the author of this code, expressly permits you to
-     statically or dynamically link your code (or bind by name) to this file,
-     while you keep this file unmodified.
-*/
-
-#ifndef __LZFIND_H
-#define __LZFIND_H
-
-#include &quot;Types.h&quot;
-
-typedef UInt32 CLzRef;
-
-typedef struct _CMatchFinder
-{
-  Byte *buffer;
-  UInt32 pos;
-  UInt32 posLimit;
-  UInt32 streamPos;
-  UInt32 lenLimit;
-
-  UInt32 cyclicBufferPos;
-  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
-
-  UInt32 matchMaxLen;
-  CLzRef *hash;
-  CLzRef *son;
-  UInt32 hashMask;
-  UInt32 cutValue;
-
-  Byte *bufferBase;
-  ISeqInStream *stream;
-  int streamEndWasReached;
-
-  UInt32 blockSize;
-  UInt32 keepSizeBefore;
-  UInt32 keepSizeAfter;
-
-  UInt32 numHashBytes;
-  int directInput;
-  int btMode;
-  /* int skipModeBits; */
-  int bigHash;
-  UInt32 historySize;
-  UInt32 fixedHashSize;
-  UInt32 hashSizeSum;
-  UInt32 numSons;
-  SRes result;
-  UInt32 crc[256];
-} CMatchFinder;
-
-#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)-&gt;buffer)
-#define Inline_MatchFinder_GetIndexByte(p, index) ((p)-&gt;buffer[(Int32)(index)])
-
-#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)-&gt;streamPos - (p)-&gt;pos)
-
-int MatchFinder_NeedMove(CMatchFinder *p);
-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
-void MatchFinder_MoveBlock(CMatchFinder *p);
-void MatchFinder_ReadIfRequired(CMatchFinder *p);
-
-void MatchFinder_Construct(CMatchFinder *p);
-
-/* Conditions:
-     historySize &lt;= 3 GB
-     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter &lt; 511MB
-*/
-int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-    ISzAlloc *alloc);
-void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
-
-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-    UInt32 *distances, UInt32 maxLen);
-
-/*
-Conditions:
-  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
-  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
-*/
-
-typedef void (*Mf_Init_Func)(void *object);
-typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
-typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
-typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
-typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
-typedef void (*Mf_Skip_Func)(void *object, UInt32);
-
-typedef struct _IMatchFinder
-{
-  Mf_Init_Func Init;
-  Mf_GetIndexByte_Func GetIndexByte;
-  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
-  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
-  Mf_GetMatches_Func GetMatches;
-  Mf_Skip_Func Skip;
-} IMatchFinder;
-
-void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
-
-void MatchFinder_Init(CMatchFinder *p);
-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFind.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,116 @@
+/* LzFind.h  -- Match finder for LZ algorithms
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+You can use any of the following license options:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  3) Common Development and Distribution License (CDDL) Version 1.0
+  4) Igor Pavlov, as the author of this code, expressly permits you to
+     statically or dynamically link your code (or bind by name) to this file,
+     while you keep this file unmodified.
+*/
+
+#ifndef __LZFIND_H
+#define __LZFIND_H
+
+#include &quot;Types.h&quot;
+
+typedef UInt32 CLzRef;
+
+typedef struct _CMatchFinder
+{
+  Byte *buffer;
+  UInt32 pos;
+  UInt32 posLimit;
+  UInt32 streamPos;
+  UInt32 lenLimit;
+
+  UInt32 cyclicBufferPos;
+  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
+
+  UInt32 matchMaxLen;
+  CLzRef *hash;
+  CLzRef *son;
+  UInt32 hashMask;
+  UInt32 cutValue;
+
+  Byte *bufferBase;
+  ISeqInStream *stream;
+  int streamEndWasReached;
+
+  UInt32 blockSize;
+  UInt32 keepSizeBefore;
+  UInt32 keepSizeAfter;
+
+  UInt32 numHashBytes;
+  int directInput;
+  int btMode;
+  /* int skipModeBits; */
+  int bigHash;
+  UInt32 historySize;
+  UInt32 fixedHashSize;
+  UInt32 hashSizeSum;
+  UInt32 numSons;
+  SRes result;
+  UInt32 crc[256];
+} CMatchFinder;
+
+#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)-&gt;buffer)
+#define Inline_MatchFinder_GetIndexByte(p, index) ((p)-&gt;buffer[(Int32)(index)])
+
+#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)-&gt;streamPos - (p)-&gt;pos)
+
+int MatchFinder_NeedMove(CMatchFinder *p);
+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
+void MatchFinder_MoveBlock(CMatchFinder *p);
+void MatchFinder_ReadIfRequired(CMatchFinder *p);
+
+void MatchFinder_Construct(CMatchFinder *p);
+
+/* Conditions:
+     historySize &lt;= 3 GB
+     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter &lt; 511MB
+*/
+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+    ISzAlloc *alloc);
+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
+
+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *distances, UInt32 maxLen);
+
+/*
+Conditions:
+  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
+  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
+*/
+
+typedef void (*Mf_Init_Func)(void *object);
+typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
+typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
+typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
+typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
+typedef void (*Mf_Skip_Func)(void *object, UInt32);
+
+typedef struct _IMatchFinder
+{
+  Mf_Init_Func Init;
+  Mf_GetIndexByte_Func GetIndexByte;
+  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
+  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
+  Mf_GetMatches_Func GetMatches;
+  Mf_Skip_Func Skip;
+} IMatchFinder;
+
+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
+
+void MatchFinder_Init(CMatchFinder *p);
+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,795 +0,0 @@
-/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#include &quot;LzHash.h&quot;
-
-#include &quot;LzFindMt.h&quot;
-
-void MtSync_Construct(CMtSync *p)
-{
-  p-&gt;wasCreated = False;
-  p-&gt;csWasInitialized = False;
-  p-&gt;csWasEntered = False;
-  Thread_Construct(&amp;p-&gt;thread);
-  Event_Construct(&amp;p-&gt;canStart);
-  Event_Construct(&amp;p-&gt;wasStarted);
-  Event_Construct(&amp;p-&gt;wasStopped);
-  Semaphore_Construct(&amp;p-&gt;freeSemaphore);
-  Semaphore_Construct(&amp;p-&gt;filledSemaphore);
-}
-
-void MtSync_GetNextBlock(CMtSync *p)
-{
-  if (p-&gt;needStart)
-  {
-    p-&gt;numProcessedBlocks = 1;
-    p-&gt;needStart = False;
-    p-&gt;stopWriting = False;
-    p-&gt;exit = False;
-    Event_Reset(&amp;p-&gt;wasStarted);
-    Event_Reset(&amp;p-&gt;wasStopped);
-
-    Event_Set(&amp;p-&gt;canStart);
-    Event_Wait(&amp;p-&gt;wasStarted);
-  }
-  else
-  {
-    CriticalSection_Leave(&amp;p-&gt;cs);
-    p-&gt;csWasEntered = False;
-    p-&gt;numProcessedBlocks++;
-    Semaphore_Release1(&amp;p-&gt;freeSemaphore);
-  }
-  Semaphore_Wait(&amp;p-&gt;filledSemaphore);
-  CriticalSection_Enter(&amp;p-&gt;cs);
-  p-&gt;csWasEntered = True;
-}
-
-/* MtSync_StopWriting must be called if Writing was started */
-
-void MtSync_StopWriting(CMtSync *p)
-{
-  UInt32 myNumBlocks = p-&gt;numProcessedBlocks;
-  if (!Thread_WasCreated(&amp;p-&gt;thread) || p-&gt;needStart)
-    return;
-  p-&gt;stopWriting = True;
-  if (p-&gt;csWasEntered)
-  {
-    CriticalSection_Leave(&amp;p-&gt;cs);
-    p-&gt;csWasEntered = False;
-  }
-  Semaphore_Release1(&amp;p-&gt;freeSemaphore);
- 
-  Event_Wait(&amp;p-&gt;wasStopped);
-
-  while (myNumBlocks++ != p-&gt;numProcessedBlocks)
-  {
-    Semaphore_Wait(&amp;p-&gt;filledSemaphore);
-    Semaphore_Release1(&amp;p-&gt;freeSemaphore);
-  }
-  p-&gt;needStart = True;
-}
-
-void MtSync_Destruct(CMtSync *p)
-{
-  if (Thread_WasCreated(&amp;p-&gt;thread))
-  {
-    MtSync_StopWriting(p);
-    p-&gt;exit = True;
-    if (p-&gt;needStart)
-      Event_Set(&amp;p-&gt;canStart);
-    Thread_Wait(&amp;p-&gt;thread);
-    Thread_Close(&amp;p-&gt;thread);
-  }
-  if (p-&gt;csWasInitialized)
-  {
-    CriticalSection_Delete(&amp;p-&gt;cs);
-    p-&gt;csWasInitialized = False;
-  }
-
-  Event_Close(&amp;p-&gt;canStart);
-  Event_Close(&amp;p-&gt;wasStarted);
-  Event_Close(&amp;p-&gt;wasStopped);
-  Semaphore_Close(&amp;p-&gt;freeSemaphore);
-  Semaphore_Close(&amp;p-&gt;filledSemaphore);
-
-  p-&gt;wasCreated = False;
-}
-
-#define RINOK_THREAD(x) { if ((x) != 0) return SZ_ERROR_THREAD; }
-
-static SRes MtSync_Create2(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
-{
-  if (p-&gt;wasCreated)
-    return SZ_OK;
-
-  RINOK_THREAD(CriticalSection_Init(&amp;p-&gt;cs));
-  p-&gt;csWasInitialized = True;
-
-  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;canStart));
-  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;wasStarted));
-  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;wasStopped));
-  
-  RINOK_THREAD(Semaphore_Create(&amp;p-&gt;freeSemaphore, numBlocks, numBlocks));
-  RINOK_THREAD(Semaphore_Create(&amp;p-&gt;filledSemaphore, 0, numBlocks));
-
-  p-&gt;needStart = True;
-  
-  RINOK_THREAD(Thread_Create(&amp;p-&gt;thread, startAddress, obj));
-  p-&gt;wasCreated = True;
-  return SZ_OK;
-}
-
-static SRes MtSync_Create(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
-{
-  SRes res = MtSync_Create2(p, startAddress, obj, numBlocks);
-  if (res != SZ_OK)
-    MtSync_Destruct(p);
-  return res;
-}
-
-void MtSync_Init(CMtSync *p) { p-&gt;needStart = True; }
-
-#define kMtMaxValForNormalize 0xFFFFFFFF
-
-#define DEF_GetHeads2(name, v, action) \
-static void GetHeads ## name(const Byte *p, UInt32 pos, \
-UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc) \
-{ action; for (; numHeads != 0; numHeads--) { \
-const UInt32 value = (v); p++; *heads++ = pos - hash[value]; hash[value] = pos++;  } }
-
-#define DEF_GetHeads(name, v) DEF_GetHeads2(name, v, ;)
-
-DEF_GetHeads2(2,  (p[0] | ((UInt32)p[1] &lt;&lt; 8)), hashMask = hashMask; crc = crc; )
-DEF_GetHeads(3,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8)) &amp; hashMask)
-DEF_GetHeads(4,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ (crc[p[3]] &lt;&lt; 5)) &amp; hashMask)
-DEF_GetHeads(4b, (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ ((UInt32)p[3] &lt;&lt; 16)) &amp; hashMask)
-DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ (crc[p[3]] &lt;&lt; 5) ^ (crc[p[4]] &lt;&lt; 3)) &amp; hashMask)
-
-void HashThreadFunc(CMatchFinderMt *mt)
-{
-  CMtSync *p = &amp;mt-&gt;hashSync;
-  for (;;)
-  {
-    UInt32 numProcessedBlocks = 0;
-    Event_Wait(&amp;p-&gt;canStart);
-    Event_Set(&amp;p-&gt;wasStarted);
-    for (;;)
-    {
-      if (p-&gt;exit)
-        return;
-      if (p-&gt;stopWriting)
-      {
-        p-&gt;numProcessedBlocks = numProcessedBlocks;
-        Event_Set(&amp;p-&gt;wasStopped);
-        break;
-      }
-
-      {
-        CMatchFinder *mf = mt-&gt;MatchFinder;
-        if (MatchFinder_NeedMove(mf))
-        {
-          CriticalSection_Enter(&amp;mt-&gt;btSync.cs);
-          CriticalSection_Enter(&amp;mt-&gt;hashSync.cs);
-          {
-            const Byte *beforePtr = MatchFinder_GetPointerToCurrentPos(mf);
-            const Byte *afterPtr;
-            MatchFinder_MoveBlock(mf);
-            afterPtr = MatchFinder_GetPointerToCurrentPos(mf);
-            mt-&gt;pointerToCurPos -= beforePtr - afterPtr;
-            mt-&gt;buffer -= beforePtr - afterPtr;
-          }
-          CriticalSection_Leave(&amp;mt-&gt;btSync.cs);
-          CriticalSection_Leave(&amp;mt-&gt;hashSync.cs);
-          continue;
-        }
-
-        Semaphore_Wait(&amp;p-&gt;freeSemaphore);
-
-        MatchFinder_ReadIfRequired(mf);
-        if (mf-&gt;pos &gt; (kMtMaxValForNormalize - kMtHashBlockSize))
-        {
-          UInt32 subValue = (mf-&gt;pos - mf-&gt;historySize - 1);
-          MatchFinder_ReduceOffsets(mf, subValue);
-          MatchFinder_Normalize3(subValue, mf-&gt;hash + mf-&gt;fixedHashSize, mf-&gt;hashMask + 1);
-        }
-        {
-          UInt32 *heads = mt-&gt;hashBuf + ((numProcessedBlocks++) &amp; kMtHashNumBlocksMask) * kMtHashBlockSize;
-          UInt32 num = mf-&gt;streamPos - mf-&gt;pos;
-          heads[0] = 2;
-          heads[1] = num;
-          if (num &gt;= mf-&gt;numHashBytes)
-          {
-            num = num - mf-&gt;numHashBytes + 1;
-            if (num &gt; kMtHashBlockSize - 2)
-              num = kMtHashBlockSize - 2;
-            mt-&gt;GetHeadsFunc(mf-&gt;buffer, mf-&gt;pos, mf-&gt;hash + mf-&gt;fixedHashSize, mf-&gt;hashMask, heads + 2, num, mf-&gt;crc);
-            heads[0] += num;
-          }
-          mf-&gt;pos += num;
-          mf-&gt;buffer += num;
-        }
-      }
-
-      Semaphore_Release1(&amp;p-&gt;filledSemaphore);
-    }
-  }
-}
-
-void MatchFinderMt_GetNextBlock_Hash(CMatchFinderMt *p)
-{
-  MtSync_GetNextBlock(&amp;p-&gt;hashSync);
-  p-&gt;hashBufPosLimit = p-&gt;hashBufPos = ((p-&gt;hashSync.numProcessedBlocks - 1) &amp; kMtHashNumBlocksMask) * kMtHashBlockSize;
-  p-&gt;hashBufPosLimit += p-&gt;hashBuf[p-&gt;hashBufPos++];
-  p-&gt;hashNumAvail = p-&gt;hashBuf[p-&gt;hashBufPos++];
-}
-
-#define kEmptyHashValue 0
-
-/* #define MFMT_GM_INLINE */
-
-#ifdef MFMT_GM_INLINE
-
-#define NO_INLINE MY_FAST_CALL
-
-Int32 NO_INLINE GetMatchesSpecN(UInt32 lenLimit, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-    UInt32 *_distances, UInt32 _maxLen, const UInt32 *hash, Int32 limit, UInt32 size, UInt32 *posRes)
-{
-  do
-  {
-  UInt32 *distances = _distances + 1;
-  UInt32 curMatch = pos - *hash++;
-
-  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
-  UInt32 len0 = 0, len1 = 0;
-  UInt32 cutValue = _cutValue;
-  UInt32 maxLen = _maxLen;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
-    {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      break;
-    }
-    {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
-      const Byte *pb = cur - delta;
-      UInt32 len = (len0 &lt; len1 ? len0 : len1);
-      if (pb[len] == cur[len])
-      {
-        if (++len != lenLimit &amp;&amp; pb[len] == cur[len])
-          while (++len != lenLimit)
-            if (pb[len] != cur[len])
-              break;
-        if (maxLen &lt; len)
-        {
-          *distances++ = maxLen = len;
-          *distances++ = delta - 1;
-          if (len == lenLimit)
-          {
-            *ptr1 = pair[0];
-            *ptr0 = pair[1];
-            break;
-          }
-        }
-      }
-      if (pb[len] &lt; cur[len])
-      {
-        *ptr1 = curMatch;
-        ptr1 = pair + 1;
-        curMatch = *ptr1;
-        len1 = len;
-      }
-      else
-      {
-        *ptr0 = curMatch;
-        ptr0 = pair;
-        curMatch = *ptr0;
-        len0 = len;
-      }
-    }
-  }
-  pos++;
-  _cyclicBufferPos++;
-  cur++;
-  {
-    UInt32 num = (UInt32)(distances - _distances);
-    *_distances = num - 1;
-    _distances += num;
-    limit -= num;
-  }
-  }
-  while (limit &gt; 0 &amp;&amp; --size != 0);
-  *posRes = pos;
-  return limit;
-}
-
-#endif
-
-void BtGetMatches(CMatchFinderMt *p, UInt32 *distances)
-{
-  UInt32 numProcessed = 0;
-  UInt32 curPos = 2;
-  UInt32 limit = kMtBtBlockSize - (p-&gt;matchMaxLen * 2);
-  distances[1] = p-&gt;hashNumAvail;
-  while (curPos &lt; limit)
-  {
-    if (p-&gt;hashBufPos == p-&gt;hashBufPosLimit)
-    {
-      MatchFinderMt_GetNextBlock_Hash(p);
-      distances[1] = numProcessed + p-&gt;hashNumAvail;
-      if (p-&gt;hashNumAvail &gt;= p-&gt;numHashBytes)
-        continue;
-      for (; p-&gt;hashNumAvail != 0; p-&gt;hashNumAvail--)
-        distances[curPos++] = 0;
-      break;
-    }
-    {
-      UInt32 size = p-&gt;hashBufPosLimit - p-&gt;hashBufPos;
-      UInt32 lenLimit = p-&gt;matchMaxLen;
-      UInt32 pos = p-&gt;pos;
-      UInt32 cyclicBufferPos = p-&gt;cyclicBufferPos;
-      if (lenLimit &gt;= p-&gt;hashNumAvail)
-        lenLimit = p-&gt;hashNumAvail;
-      {
-        UInt32 size2 = p-&gt;hashNumAvail - lenLimit + 1;
-        if (size2 &lt; size)
-          size = size2;
-        size2 = p-&gt;cyclicBufferSize - cyclicBufferPos;
-        if (size2 &lt; size)
-          size = size2;
-      }
-      #ifndef MFMT_GM_INLINE
-      while (curPos &lt; limit &amp;&amp; size-- != 0)
-      {
-        UInt32 *startDistances = distances + curPos;
-        UInt32 num = (UInt32)(GetMatchesSpec1(lenLimit, pos - p-&gt;hashBuf[p-&gt;hashBufPos++],
-          pos, p-&gt;buffer, p-&gt;son, cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue,
-          startDistances + 1, p-&gt;numHashBytes - 1) - startDistances);
-        *startDistances = num - 1;
-        curPos += num;
-        cyclicBufferPos++;
-        pos++;
-        p-&gt;buffer++;
-      }
-      #else
-      {
-        UInt32 posRes;
-        curPos = limit - GetMatchesSpecN(lenLimit, pos, p-&gt;buffer, p-&gt;son, cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue,
-          distances + curPos, p-&gt;numHashBytes - 1, p-&gt;hashBuf + p-&gt;hashBufPos, (Int32)(limit - curPos) , size, &amp;posRes);
-        p-&gt;hashBufPos += posRes - pos;
-        cyclicBufferPos += posRes - pos;
-        p-&gt;buffer += posRes - pos;
-        pos = posRes;
-      }
-      #endif
-
-      numProcessed += pos - p-&gt;pos;
-      p-&gt;hashNumAvail -= pos - p-&gt;pos;
-      p-&gt;pos = pos;
-      if (cyclicBufferPos == p-&gt;cyclicBufferSize)
-        cyclicBufferPos = 0;
-      p-&gt;cyclicBufferPos = cyclicBufferPos;
-    }
-  }
-  distances[0] = curPos;
-}
-
-void BtFillBlock(CMatchFinderMt *p, UInt32 globalBlockIndex)
-{
-  CMtSync *sync = &amp;p-&gt;hashSync;
-  if (!sync-&gt;needStart)
-  {
-    CriticalSection_Enter(&amp;sync-&gt;cs);
-    sync-&gt;csWasEntered = True;
-  }
-  
-  BtGetMatches(p, p-&gt;btBuf + (globalBlockIndex &amp; kMtBtNumBlocksMask) * kMtBtBlockSize);
-
-  if (p-&gt;pos &gt; kMtMaxValForNormalize - kMtBtBlockSize)
-  {
-    UInt32 subValue = p-&gt;pos - p-&gt;cyclicBufferSize;
-    MatchFinder_Normalize3(subValue, p-&gt;son, p-&gt;cyclicBufferSize * 2);
-    p-&gt;pos -= subValue;
-  }
-
-  if (!sync-&gt;needStart)
-  {
-    CriticalSection_Leave(&amp;sync-&gt;cs);
-    sync-&gt;csWasEntered = False;
-  }
-}
-
-void BtThreadFunc(CMatchFinderMt *mt)
-{
-  CMtSync *p = &amp;mt-&gt;btSync;
-  for (;;)
-  {
-    UInt32 blockIndex = 0;
-    Event_Wait(&amp;p-&gt;canStart);
-    Event_Set(&amp;p-&gt;wasStarted);
-    for (;;)
-    {
-      if (p-&gt;exit)
-        return;
-      if (p-&gt;stopWriting)
-      {
-        p-&gt;numProcessedBlocks = blockIndex;
-        MtSync_StopWriting(&amp;mt-&gt;hashSync);
-        Event_Set(&amp;p-&gt;wasStopped);
-        break;
-      }
-      Semaphore_Wait(&amp;p-&gt;freeSemaphore);
-      BtFillBlock(mt, blockIndex++);
-      Semaphore_Release1(&amp;p-&gt;filledSemaphore);
-    }
-  }
-}
-
-void MatchFinderMt_Construct(CMatchFinderMt *p)
-{
-  p-&gt;hashBuf = 0;
-  MtSync_Construct(&amp;p-&gt;hashSync);
-  MtSync_Construct(&amp;p-&gt;btSync);
-}
-
-void MatchFinderMt_FreeMem(CMatchFinderMt *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;hashBuf);
-  p-&gt;hashBuf = 0;
-}
-
-void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc)
-{
-  MtSync_Destruct(&amp;p-&gt;hashSync);
-  MtSync_Destruct(&amp;p-&gt;btSync);
-  MatchFinderMt_FreeMem(p, alloc);
-}
-
-#define kHashBufferSize (kMtHashBlockSize * kMtHashNumBlocks)
-#define kBtBufferSize (kMtBtBlockSize * kMtBtNumBlocks)
-
-static unsigned MY_STD_CALL HashThreadFunc2(void *p) { HashThreadFunc((CMatchFinderMt *)p);  return 0; }
-static unsigned MY_STD_CALL BtThreadFunc2(void *p)
-{
-  Byte allocaDummy[0x180];
-  int i = 0;
-  for (i = 0; i &lt; 16; i++)
-    allocaDummy[i] = (Byte)i;
-  BtThreadFunc((CMatchFinderMt *)p);
-  return 0;
-}
-
-SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
-    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc)
-{
-  CMatchFinder *mf = p-&gt;MatchFinder;
-  p-&gt;historySize = historySize;
-  if (kMtBtBlockSize &lt;= matchMaxLen * 4)
-    return SZ_ERROR_PARAM;
-  if (p-&gt;hashBuf == 0)
-  {
-    p-&gt;hashBuf = (UInt32 *)alloc-&gt;Alloc(alloc, (kHashBufferSize + kBtBufferSize) * sizeof(UInt32));
-    if (p-&gt;hashBuf == 0)
-      return SZ_ERROR_MEM;
-    p-&gt;btBuf = p-&gt;hashBuf + kHashBufferSize;
-  }
-  keepAddBufferBefore += (kHashBufferSize + kBtBufferSize);
-  keepAddBufferAfter += kMtHashBlockSize;
-  if (!MatchFinder_Create(mf, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter, alloc))
-    return SZ_ERROR_MEM;
-
-  RINOK(MtSync_Create(&amp;p-&gt;hashSync, HashThreadFunc2, p, kMtHashNumBlocks));
-  RINOK(MtSync_Create(&amp;p-&gt;btSync, BtThreadFunc2, p, kMtBtNumBlocks));
-  return SZ_OK;
-}
-
-/* Call it after ReleaseStream / SetStream */
-void MatchFinderMt_Init(CMatchFinderMt *p)
-{
-  CMatchFinder *mf = p-&gt;MatchFinder;
-  p-&gt;btBufPos = p-&gt;btBufPosLimit = 0;
-  p-&gt;hashBufPos = p-&gt;hashBufPosLimit = 0;
-  MatchFinder_Init(mf);
-  p-&gt;pointerToCurPos = MatchFinder_GetPointerToCurrentPos(mf);
-  p-&gt;btNumAvailBytes = 0;
-  p-&gt;lzPos = p-&gt;historySize + 1;
-
-  p-&gt;hash = mf-&gt;hash;
-  p-&gt;fixedHashSize = mf-&gt;fixedHashSize;
-  p-&gt;crc = mf-&gt;crc;
-
-  p-&gt;son = mf-&gt;son;
-  p-&gt;matchMaxLen = mf-&gt;matchMaxLen;
-  p-&gt;numHashBytes = mf-&gt;numHashBytes;
-  p-&gt;pos = mf-&gt;pos;
-  p-&gt;buffer = mf-&gt;buffer;
-  p-&gt;cyclicBufferPos = mf-&gt;cyclicBufferPos;
-  p-&gt;cyclicBufferSize = mf-&gt;cyclicBufferSize;
-  p-&gt;cutValue = mf-&gt;cutValue;
-}
-
-/* ReleaseStream is required to finish multithreading */
-void MatchFinderMt_ReleaseStream(CMatchFinderMt *p)
-{
-  MtSync_StopWriting(&amp;p-&gt;btSync);
-  /* p-&gt;MatchFinder-&gt;ReleaseStream(); */
-}
-
-void MatchFinderMt_Normalize(CMatchFinderMt *p)
-{
-  MatchFinder_Normalize3(p-&gt;lzPos - p-&gt;historySize - 1, p-&gt;hash, p-&gt;fixedHashSize);
-  p-&gt;lzPos = p-&gt;historySize + 1;
-}
-
-void MatchFinderMt_GetNextBlock_Bt(CMatchFinderMt *p)
-{
-  UInt32 blockIndex;
-  MtSync_GetNextBlock(&amp;p-&gt;btSync);
-  blockIndex = ((p-&gt;btSync.numProcessedBlocks - 1) &amp; kMtBtNumBlocksMask);
-  p-&gt;btBufPosLimit = p-&gt;btBufPos = blockIndex * kMtBtBlockSize;
-  p-&gt;btBufPosLimit += p-&gt;btBuf[p-&gt;btBufPos++];
-  p-&gt;btNumAvailBytes = p-&gt;btBuf[p-&gt;btBufPos++];
-  if (p-&gt;lzPos &gt;= kMtMaxValForNormalize - kMtBtBlockSize)
-    MatchFinderMt_Normalize(p);
-}
-
-const Byte * MatchFinderMt_GetPointerToCurrentPos(CMatchFinderMt *p)
-{
-  return p-&gt;pointerToCurPos;
-}
-
-#define GET_NEXT_BLOCK_IF_REQUIRED if (p-&gt;btBufPos == p-&gt;btBufPosLimit) MatchFinderMt_GetNextBlock_Bt(p);
-
-UInt32 MatchFinderMt_GetNumAvailableBytes(CMatchFinderMt *p)
-{
-  GET_NEXT_BLOCK_IF_REQUIRED;
-  return p-&gt;btNumAvailBytes;
-}
-
-Byte MatchFinderMt_GetIndexByte(CMatchFinderMt *p, Int32 index)
-{
-  return p-&gt;pointerToCurPos[index];
-}
-
-UInt32 * MixMatches2(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
-{
-  UInt32 hash2Value, curMatch2;
-  UInt32 *hash = p-&gt;hash;
-  const Byte *cur = p-&gt;pointerToCurPos;
-  UInt32 lzPos = p-&gt;lzPos;
-  MT_HASH2_CALC
-      
-  curMatch2 = hash[hash2Value];
-  hash[hash2Value] = lzPos;
-
-  if (curMatch2 &gt;= matchMinPos)
-    if (cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
-    {
-      *distances++ = 2;
-      *distances++ = lzPos - curMatch2 - 1;
-    }
-  return distances;
-}
-
-UInt32 * MixMatches3(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
-{
-  UInt32 hash2Value, hash3Value, curMatch2, curMatch3;
-  UInt32 *hash = p-&gt;hash;
-  const Byte *cur = p-&gt;pointerToCurPos;
-  UInt32 lzPos = p-&gt;lzPos;
-  MT_HASH3_CALC
-
-  curMatch2 = hash[                hash2Value];
-  curMatch3 = hash[kFix3HashSize + hash3Value];
-  
-  hash[                hash2Value] =
-  hash[kFix3HashSize + hash3Value] =
-    lzPos;
-
-  if (curMatch2 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
-  {
-    distances[1] = lzPos - curMatch2 - 1;
-    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
-    {
-      distances[0] = 3;
-      return distances + 2;
-    }
-    distances[0] = 2;
-    distances += 2;
-  }
-  if (curMatch3 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
-  {
-    *distances++ = 3;
-    *distances++ = lzPos - curMatch3 - 1;
-  }
-  return distances;
-}
-
-/*
-UInt32 *MixMatches4(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
-{
-  UInt32 hash2Value, hash3Value, hash4Value, curMatch2, curMatch3, curMatch4;
-  UInt32 *hash = p-&gt;hash;
-  const Byte *cur = p-&gt;pointerToCurPos;
-  UInt32 lzPos = p-&gt;lzPos;
-  MT_HASH4_CALC
-      
-  curMatch2 = hash[                hash2Value];
-  curMatch3 = hash[kFix3HashSize + hash3Value];
-  curMatch4 = hash[kFix4HashSize + hash4Value];
-  
-  hash[                hash2Value] =
-  hash[kFix3HashSize + hash3Value] =
-  hash[kFix4HashSize + hash4Value] =
-    lzPos;
-
-  if (curMatch2 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
-  {
-    distances[1] = lzPos - curMatch2 - 1;
-    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
-    {
-      distances[0] =  (cur[(ptrdiff_t)curMatch2 - lzPos + 3] == cur[3]) ? 4 : 3;
-      return distances + 2;
-    }
-    distances[0] = 2;
-    distances += 2;
-  }
-  if (curMatch3 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
-  {
-    distances[1] = lzPos - curMatch3 - 1;
-    if (cur[(ptrdiff_t)curMatch3 - lzPos + 3] == cur[3])
-    {
-      distances[0] = 4;
-      return distances + 2;
-    }
-    distances[0] = 3;
-    distances += 2;
-  }
-
-  if (curMatch4 &gt;= matchMinPos)
-    if (
-      cur[(ptrdiff_t)curMatch4 - lzPos] == cur[0] &amp;&amp;
-      cur[(ptrdiff_t)curMatch4 - lzPos + 3] == cur[3]
-      )
-    {
-      *distances++ = 4;
-      *distances++ = lzPos - curMatch4 - 1;
-    }
-  return distances;
-}
-*/
-
-#define INCREASE_LZ_POS p-&gt;lzPos++; p-&gt;pointerToCurPos++;
-
-UInt32 MatchFinderMt2_GetMatches(CMatchFinderMt *p, UInt32 *distances)
-{
-  const UInt32 *btBuf = p-&gt;btBuf + p-&gt;btBufPos;
-  UInt32 len = *btBuf++;
-  p-&gt;btBufPos += 1 + len;
-  p-&gt;btNumAvailBytes--;
-  {
-    UInt32 i;
-    for (i = 0; i &lt; len; i += 2)
-    {
-      *distances++ = *btBuf++;
-      *distances++ = *btBuf++;
-    }
-  }
-  INCREASE_LZ_POS
-  return len;
-}
-
-UInt32 MatchFinderMt_GetMatches(CMatchFinderMt *p, UInt32 *distances)
-{
-  const UInt32 *btBuf = p-&gt;btBuf + p-&gt;btBufPos;
-  UInt32 len = *btBuf++;
-  p-&gt;btBufPos += 1 + len;
-
-  if (len == 0)
-  {
-    if (p-&gt;btNumAvailBytes-- &gt;= 4)
-      len = (UInt32)(p-&gt;MixMatchesFunc(p, p-&gt;lzPos - p-&gt;historySize, distances) - (distances));
-  }
-  else
-  {
-    /* Condition: there are matches in btBuf with length &lt; p-&gt;numHashBytes */
-    UInt32 *distances2;
-    p-&gt;btNumAvailBytes--;
-    distances2 = p-&gt;MixMatchesFunc(p, p-&gt;lzPos - btBuf[1], distances);
-    do
-    {
-      *distances2++ = *btBuf++;
-      *distances2++ = *btBuf++;
-    }
-    while ((len -= 2) != 0);
-    len  = (UInt32)(distances2 - (distances));
-  }
-  INCREASE_LZ_POS
-  return len;
-}
-
-#define SKIP_HEADER2  do { GET_NEXT_BLOCK_IF_REQUIRED
-#define SKIP_HEADER(n) SKIP_HEADER2 if (p-&gt;btNumAvailBytes-- &gt;= (n)) { const Byte *cur = p-&gt;pointerToCurPos; UInt32 *hash = p-&gt;hash;
-#define SKIP_FOOTER } INCREASE_LZ_POS p-&gt;btBufPos += p-&gt;btBuf[p-&gt;btBufPos] + 1; } while (--num != 0);
-
-void MatchFinderMt0_Skip(CMatchFinderMt *p, UInt32 num)
-{
-  SKIP_HEADER2 { p-&gt;btNumAvailBytes--;
-  SKIP_FOOTER
-}
-
-void MatchFinderMt2_Skip(CMatchFinderMt *p, UInt32 num)
-{
-  SKIP_HEADER(2)
-      UInt32 hash2Value;
-      MT_HASH2_CALC
-      hash[hash2Value] = p-&gt;lzPos;
-  SKIP_FOOTER
-}
-
-void MatchFinderMt3_Skip(CMatchFinderMt *p, UInt32 num)
-{
-  SKIP_HEADER(3)
-      UInt32 hash2Value, hash3Value;
-      MT_HASH3_CALC
-      hash[kFix3HashSize + hash3Value] =
-      hash[                hash2Value] =
-        p-&gt;lzPos;
-  SKIP_FOOTER
-}
-
-/*
-void MatchFinderMt4_Skip(CMatchFinderMt *p, UInt32 num)
-{
-  SKIP_HEADER(4)
-      UInt32 hash2Value, hash3Value, hash4Value;
-      MT_HASH4_CALC
-      hash[kFix4HashSize + hash4Value] =
-      hash[kFix3HashSize + hash3Value] =
-      hash[                hash2Value] =
-        p-&gt;lzPos;
-  SKIP_FOOTER
-}
-*/
-
-void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable)
-{
-  vTable-&gt;Init = (Mf_Init_Func)MatchFinderMt_Init;
-  vTable-&gt;GetIndexByte = (Mf_GetIndexByte_Func)MatchFinderMt_GetIndexByte;
-  vTable-&gt;GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinderMt_GetNumAvailableBytes;
-  vTable-&gt;GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinderMt_GetPointerToCurrentPos;
-  vTable-&gt;GetMatches = (Mf_GetMatches_Func)MatchFinderMt_GetMatches;
-  switch(p-&gt;MatchFinder-&gt;numHashBytes)
-  {
-    case 2:
-      p-&gt;GetHeadsFunc = GetHeads2;
-      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)0;
-      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt0_Skip;
-      vTable-&gt;GetMatches = (Mf_GetMatches_Func)MatchFinderMt2_GetMatches;
-      break;
-    case 3:
-      p-&gt;GetHeadsFunc = GetHeads3;
-      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches2;
-      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt2_Skip;
-      break;
-    default:
-    /* case 4: */
-      p-&gt;GetHeadsFunc = p-&gt;MatchFinder-&gt;bigHash ? GetHeads4b : GetHeads4;
-      /* p-&gt;GetHeadsFunc = GetHeads4; */
-      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches3;
-      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt3_Skip;
-      break;
-    /*
-    default:
-      p-&gt;GetHeadsFunc = GetHeads5;
-      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches4;
-      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt4_Skip;
-      break;
-    */
-  }
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,795 @@
+/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#include &quot;LzHash.h&quot;
+
+#include &quot;LzFindMt.h&quot;
+
+void MtSync_Construct(CMtSync *p)
+{
+  p-&gt;wasCreated = False;
+  p-&gt;csWasInitialized = False;
+  p-&gt;csWasEntered = False;
+  Thread_Construct(&amp;p-&gt;thread);
+  Event_Construct(&amp;p-&gt;canStart);
+  Event_Construct(&amp;p-&gt;wasStarted);
+  Event_Construct(&amp;p-&gt;wasStopped);
+  Semaphore_Construct(&amp;p-&gt;freeSemaphore);
+  Semaphore_Construct(&amp;p-&gt;filledSemaphore);
+}
+
+void MtSync_GetNextBlock(CMtSync *p)
+{
+  if (p-&gt;needStart)
+  {
+    p-&gt;numProcessedBlocks = 1;
+    p-&gt;needStart = False;
+    p-&gt;stopWriting = False;
+    p-&gt;exit = False;
+    Event_Reset(&amp;p-&gt;wasStarted);
+    Event_Reset(&amp;p-&gt;wasStopped);
+
+    Event_Set(&amp;p-&gt;canStart);
+    Event_Wait(&amp;p-&gt;wasStarted);
+  }
+  else
+  {
+    CriticalSection_Leave(&amp;p-&gt;cs);
+    p-&gt;csWasEntered = False;
+    p-&gt;numProcessedBlocks++;
+    Semaphore_Release1(&amp;p-&gt;freeSemaphore);
+  }
+  Semaphore_Wait(&amp;p-&gt;filledSemaphore);
+  CriticalSection_Enter(&amp;p-&gt;cs);
+  p-&gt;csWasEntered = True;
+}
+
+/* MtSync_StopWriting must be called if Writing was started */
+
+void MtSync_StopWriting(CMtSync *p)
+{
+  UInt32 myNumBlocks = p-&gt;numProcessedBlocks;
+  if (!Thread_WasCreated(&amp;p-&gt;thread) || p-&gt;needStart)
+    return;
+  p-&gt;stopWriting = True;
+  if (p-&gt;csWasEntered)
+  {
+    CriticalSection_Leave(&amp;p-&gt;cs);
+    p-&gt;csWasEntered = False;
+  }
+  Semaphore_Release1(&amp;p-&gt;freeSemaphore);
+ 
+  Event_Wait(&amp;p-&gt;wasStopped);
+
+  while (myNumBlocks++ != p-&gt;numProcessedBlocks)
+  {
+    Semaphore_Wait(&amp;p-&gt;filledSemaphore);
+    Semaphore_Release1(&amp;p-&gt;freeSemaphore);
+  }
+  p-&gt;needStart = True;
+}
+
+void MtSync_Destruct(CMtSync *p)
+{
+  if (Thread_WasCreated(&amp;p-&gt;thread))
+  {
+    MtSync_StopWriting(p);
+    p-&gt;exit = True;
+    if (p-&gt;needStart)
+      Event_Set(&amp;p-&gt;canStart);
+    Thread_Wait(&amp;p-&gt;thread);
+    Thread_Close(&amp;p-&gt;thread);
+  }
+  if (p-&gt;csWasInitialized)
+  {
+    CriticalSection_Delete(&amp;p-&gt;cs);
+    p-&gt;csWasInitialized = False;
+  }
+
+  Event_Close(&amp;p-&gt;canStart);
+  Event_Close(&amp;p-&gt;wasStarted);
+  Event_Close(&amp;p-&gt;wasStopped);
+  Semaphore_Close(&amp;p-&gt;freeSemaphore);
+  Semaphore_Close(&amp;p-&gt;filledSemaphore);
+
+  p-&gt;wasCreated = False;
+}
+
+#define RINOK_THREAD(x) { if ((x) != 0) return SZ_ERROR_THREAD; }
+
+static SRes MtSync_Create2(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
+{
+  if (p-&gt;wasCreated)
+    return SZ_OK;
+
+  RINOK_THREAD(CriticalSection_Init(&amp;p-&gt;cs));
+  p-&gt;csWasInitialized = True;
+
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;canStart));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;wasStarted));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;wasStopped));
+  
+  RINOK_THREAD(Semaphore_Create(&amp;p-&gt;freeSemaphore, numBlocks, numBlocks));
+  RINOK_THREAD(Semaphore_Create(&amp;p-&gt;filledSemaphore, 0, numBlocks));
+
+  p-&gt;needStart = True;
+  
+  RINOK_THREAD(Thread_Create(&amp;p-&gt;thread, startAddress, obj));
+  p-&gt;wasCreated = True;
+  return SZ_OK;
+}
+
+static SRes MtSync_Create(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
+{
+  SRes res = MtSync_Create2(p, startAddress, obj, numBlocks);
+  if (res != SZ_OK)
+    MtSync_Destruct(p);
+  return res;
+}
+
+void MtSync_Init(CMtSync *p) { p-&gt;needStart = True; }
+
+#define kMtMaxValForNormalize 0xFFFFFFFF
+
+#define DEF_GetHeads2(name, v, action) \
+static void GetHeads ## name(const Byte *p, UInt32 pos, \
+UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc) \
+{ action; for (; numHeads != 0; numHeads--) { \
+const UInt32 value = (v); p++; *heads++ = pos - hash[value]; hash[value] = pos++;  } }
+
+#define DEF_GetHeads(name, v) DEF_GetHeads2(name, v, ;)
+
+DEF_GetHeads2(2,  (p[0] | ((UInt32)p[1] &lt;&lt; 8)), hashMask = hashMask; crc = crc; )
+DEF_GetHeads(3,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8)) &amp; hashMask)
+DEF_GetHeads(4,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ (crc[p[3]] &lt;&lt; 5)) &amp; hashMask)
+DEF_GetHeads(4b, (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ ((UInt32)p[3] &lt;&lt; 16)) &amp; hashMask)
+DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ (crc[p[3]] &lt;&lt; 5) ^ (crc[p[4]] &lt;&lt; 3)) &amp; hashMask)
+
+void HashThreadFunc(CMatchFinderMt *mt)
+{
+  CMtSync *p = &amp;mt-&gt;hashSync;
+  for (;;)
+  {
+    UInt32 numProcessedBlocks = 0;
+    Event_Wait(&amp;p-&gt;canStart);
+    Event_Set(&amp;p-&gt;wasStarted);
+    for (;;)
+    {
+      if (p-&gt;exit)
+        return;
+      if (p-&gt;stopWriting)
+      {
+        p-&gt;numProcessedBlocks = numProcessedBlocks;
+        Event_Set(&amp;p-&gt;wasStopped);
+        break;
+      }
+
+      {
+        CMatchFinder *mf = mt-&gt;MatchFinder;
+        if (MatchFinder_NeedMove(mf))
+        {
+          CriticalSection_Enter(&amp;mt-&gt;btSync.cs);
+          CriticalSection_Enter(&amp;mt-&gt;hashSync.cs);
+          {
+            const Byte *beforePtr = MatchFinder_GetPointerToCurrentPos(mf);
+            const Byte *afterPtr;
+            MatchFinder_MoveBlock(mf);
+            afterPtr = MatchFinder_GetPointerToCurrentPos(mf);
+            mt-&gt;pointerToCurPos -= beforePtr - afterPtr;
+            mt-&gt;buffer -= beforePtr - afterPtr;
+          }
+          CriticalSection_Leave(&amp;mt-&gt;btSync.cs);
+          CriticalSection_Leave(&amp;mt-&gt;hashSync.cs);
+          continue;
+        }
+
+        Semaphore_Wait(&amp;p-&gt;freeSemaphore);
+
+        MatchFinder_ReadIfRequired(mf);
+        if (mf-&gt;pos &gt; (kMtMaxValForNormalize - kMtHashBlockSize))
+        {
+          UInt32 subValue = (mf-&gt;pos - mf-&gt;historySize - 1);
+          MatchFinder_ReduceOffsets(mf, subValue);
+          MatchFinder_Normalize3(subValue, mf-&gt;hash + mf-&gt;fixedHashSize, mf-&gt;hashMask + 1);
+        }
+        {
+          UInt32 *heads = mt-&gt;hashBuf + ((numProcessedBlocks++) &amp; kMtHashNumBlocksMask) * kMtHashBlockSize;
+          UInt32 num = mf-&gt;streamPos - mf-&gt;pos;
+          heads[0] = 2;
+          heads[1] = num;
+          if (num &gt;= mf-&gt;numHashBytes)
+          {
+            num = num - mf-&gt;numHashBytes + 1;
+            if (num &gt; kMtHashBlockSize - 2)
+              num = kMtHashBlockSize - 2;
+            mt-&gt;GetHeadsFunc(mf-&gt;buffer, mf-&gt;pos, mf-&gt;hash + mf-&gt;fixedHashSize, mf-&gt;hashMask, heads + 2, num, mf-&gt;crc);
+            heads[0] += num;
+          }
+          mf-&gt;pos += num;
+          mf-&gt;buffer += num;
+        }
+      }
+
+      Semaphore_Release1(&amp;p-&gt;filledSemaphore);
+    }
+  }
+}
+
+void MatchFinderMt_GetNextBlock_Hash(CMatchFinderMt *p)
+{
+  MtSync_GetNextBlock(&amp;p-&gt;hashSync);
+  p-&gt;hashBufPosLimit = p-&gt;hashBufPos = ((p-&gt;hashSync.numProcessedBlocks - 1) &amp; kMtHashNumBlocksMask) * kMtHashBlockSize;
+  p-&gt;hashBufPosLimit += p-&gt;hashBuf[p-&gt;hashBufPos++];
+  p-&gt;hashNumAvail = p-&gt;hashBuf[p-&gt;hashBufPos++];
+}
+
+#define kEmptyHashValue 0
+
+/* #define MFMT_GM_INLINE */
+
+#ifdef MFMT_GM_INLINE
+
+#define NO_INLINE MY_FAST_CALL
+
+Int32 NO_INLINE GetMatchesSpecN(UInt32 lenLimit, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *_distances, UInt32 _maxLen, const UInt32 *hash, Int32 limit, UInt32 size, UInt32 *posRes)
+{
+  do
+  {
+  UInt32 *distances = _distances + 1;
+  UInt32 curMatch = pos - *hash++;
+
+  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
+  UInt32 len0 = 0, len1 = 0;
+  UInt32 cutValue = _cutValue;
+  UInt32 maxLen = _maxLen;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      break;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 &lt; len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        if (++len != lenLimit &amp;&amp; pb[len] == cur[len])
+          while (++len != lenLimit)
+            if (pb[len] != cur[len])
+              break;
+        if (maxLen &lt; len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            break;
+          }
+        }
+      }
+      if (pb[len] &lt; cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+  pos++;
+  _cyclicBufferPos++;
+  cur++;
+  {
+    UInt32 num = (UInt32)(distances - _distances);
+    *_distances = num - 1;
+    _distances += num;
+    limit -= num;
+  }
+  }
+  while (limit &gt; 0 &amp;&amp; --size != 0);
+  *posRes = pos;
+  return limit;
+}
+
+#endif
+
+void BtGetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  UInt32 numProcessed = 0;
+  UInt32 curPos = 2;
+  UInt32 limit = kMtBtBlockSize - (p-&gt;matchMaxLen * 2);
+  distances[1] = p-&gt;hashNumAvail;
+  while (curPos &lt; limit)
+  {
+    if (p-&gt;hashBufPos == p-&gt;hashBufPosLimit)
+    {
+      MatchFinderMt_GetNextBlock_Hash(p);
+      distances[1] = numProcessed + p-&gt;hashNumAvail;
+      if (p-&gt;hashNumAvail &gt;= p-&gt;numHashBytes)
+        continue;
+      for (; p-&gt;hashNumAvail != 0; p-&gt;hashNumAvail--)
+        distances[curPos++] = 0;
+      break;
+    }
+    {
+      UInt32 size = p-&gt;hashBufPosLimit - p-&gt;hashBufPos;
+      UInt32 lenLimit = p-&gt;matchMaxLen;
+      UInt32 pos = p-&gt;pos;
+      UInt32 cyclicBufferPos = p-&gt;cyclicBufferPos;
+      if (lenLimit &gt;= p-&gt;hashNumAvail)
+        lenLimit = p-&gt;hashNumAvail;
+      {
+        UInt32 size2 = p-&gt;hashNumAvail - lenLimit + 1;
+        if (size2 &lt; size)
+          size = size2;
+        size2 = p-&gt;cyclicBufferSize - cyclicBufferPos;
+        if (size2 &lt; size)
+          size = size2;
+      }
+      #ifndef MFMT_GM_INLINE
+      while (curPos &lt; limit &amp;&amp; size-- != 0)
+      {
+        UInt32 *startDistances = distances + curPos;
+        UInt32 num = (UInt32)(GetMatchesSpec1(lenLimit, pos - p-&gt;hashBuf[p-&gt;hashBufPos++],
+          pos, p-&gt;buffer, p-&gt;son, cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue,
+          startDistances + 1, p-&gt;numHashBytes - 1) - startDistances);
+        *startDistances = num - 1;
+        curPos += num;
+        cyclicBufferPos++;
+        pos++;
+        p-&gt;buffer++;
+      }
+      #else
+      {
+        UInt32 posRes;
+        curPos = limit - GetMatchesSpecN(lenLimit, pos, p-&gt;buffer, p-&gt;son, cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue,
+          distances + curPos, p-&gt;numHashBytes - 1, p-&gt;hashBuf + p-&gt;hashBufPos, (Int32)(limit - curPos) , size, &amp;posRes);
+        p-&gt;hashBufPos += posRes - pos;
+        cyclicBufferPos += posRes - pos;
+        p-&gt;buffer += posRes - pos;
+        pos = posRes;
+      }
+      #endif
+
+      numProcessed += pos - p-&gt;pos;
+      p-&gt;hashNumAvail -= pos - p-&gt;pos;
+      p-&gt;pos = pos;
+      if (cyclicBufferPos == p-&gt;cyclicBufferSize)
+        cyclicBufferPos = 0;
+      p-&gt;cyclicBufferPos = cyclicBufferPos;
+    }
+  }
+  distances[0] = curPos;
+}
+
+void BtFillBlock(CMatchFinderMt *p, UInt32 globalBlockIndex)
+{
+  CMtSync *sync = &amp;p-&gt;hashSync;
+  if (!sync-&gt;needStart)
+  {
+    CriticalSection_Enter(&amp;sync-&gt;cs);
+    sync-&gt;csWasEntered = True;
+  }
+  
+  BtGetMatches(p, p-&gt;btBuf + (globalBlockIndex &amp; kMtBtNumBlocksMask) * kMtBtBlockSize);
+
+  if (p-&gt;pos &gt; kMtMaxValForNormalize - kMtBtBlockSize)
+  {
+    UInt32 subValue = p-&gt;pos - p-&gt;cyclicBufferSize;
+    MatchFinder_Normalize3(subValue, p-&gt;son, p-&gt;cyclicBufferSize * 2);
+    p-&gt;pos -= subValue;
+  }
+
+  if (!sync-&gt;needStart)
+  {
+    CriticalSection_Leave(&amp;sync-&gt;cs);
+    sync-&gt;csWasEntered = False;
+  }
+}
+
+void BtThreadFunc(CMatchFinderMt *mt)
+{
+  CMtSync *p = &amp;mt-&gt;btSync;
+  for (;;)
+  {
+    UInt32 blockIndex = 0;
+    Event_Wait(&amp;p-&gt;canStart);
+    Event_Set(&amp;p-&gt;wasStarted);
+    for (;;)
+    {
+      if (p-&gt;exit)
+        return;
+      if (p-&gt;stopWriting)
+      {
+        p-&gt;numProcessedBlocks = blockIndex;
+        MtSync_StopWriting(&amp;mt-&gt;hashSync);
+        Event_Set(&amp;p-&gt;wasStopped);
+        break;
+      }
+      Semaphore_Wait(&amp;p-&gt;freeSemaphore);
+      BtFillBlock(mt, blockIndex++);
+      Semaphore_Release1(&amp;p-&gt;filledSemaphore);
+    }
+  }
+}
+
+void MatchFinderMt_Construct(CMatchFinderMt *p)
+{
+  p-&gt;hashBuf = 0;
+  MtSync_Construct(&amp;p-&gt;hashSync);
+  MtSync_Construct(&amp;p-&gt;btSync);
+}
+
+void MatchFinderMt_FreeMem(CMatchFinderMt *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;hashBuf);
+  p-&gt;hashBuf = 0;
+}
+
+void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc)
+{
+  MtSync_Destruct(&amp;p-&gt;hashSync);
+  MtSync_Destruct(&amp;p-&gt;btSync);
+  MatchFinderMt_FreeMem(p, alloc);
+}
+
+#define kHashBufferSize (kMtHashBlockSize * kMtHashNumBlocks)
+#define kBtBufferSize (kMtBtBlockSize * kMtBtNumBlocks)
+
+static unsigned MY_STD_CALL HashThreadFunc2(void *p) { HashThreadFunc((CMatchFinderMt *)p);  return 0; }
+static unsigned MY_STD_CALL BtThreadFunc2(void *p)
+{
+  Byte allocaDummy[0x180];
+  int i = 0;
+  for (i = 0; i &lt; 16; i++)
+    allocaDummy[i] = (Byte)i;
+  BtThreadFunc((CMatchFinderMt *)p);
+  return 0;
+}
+
+SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc)
+{
+  CMatchFinder *mf = p-&gt;MatchFinder;
+  p-&gt;historySize = historySize;
+  if (kMtBtBlockSize &lt;= matchMaxLen * 4)
+    return SZ_ERROR_PARAM;
+  if (p-&gt;hashBuf == 0)
+  {
+    p-&gt;hashBuf = (UInt32 *)alloc-&gt;Alloc(alloc, (kHashBufferSize + kBtBufferSize) * sizeof(UInt32));
+    if (p-&gt;hashBuf == 0)
+      return SZ_ERROR_MEM;
+    p-&gt;btBuf = p-&gt;hashBuf + kHashBufferSize;
+  }
+  keepAddBufferBefore += (kHashBufferSize + kBtBufferSize);
+  keepAddBufferAfter += kMtHashBlockSize;
+  if (!MatchFinder_Create(mf, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter, alloc))
+    return SZ_ERROR_MEM;
+
+  RINOK(MtSync_Create(&amp;p-&gt;hashSync, HashThreadFunc2, p, kMtHashNumBlocks));
+  RINOK(MtSync_Create(&amp;p-&gt;btSync, BtThreadFunc2, p, kMtBtNumBlocks));
+  return SZ_OK;
+}
+
+/* Call it after ReleaseStream / SetStream */
+void MatchFinderMt_Init(CMatchFinderMt *p)
+{
+  CMatchFinder *mf = p-&gt;MatchFinder;
+  p-&gt;btBufPos = p-&gt;btBufPosLimit = 0;
+  p-&gt;hashBufPos = p-&gt;hashBufPosLimit = 0;
+  MatchFinder_Init(mf);
+  p-&gt;pointerToCurPos = MatchFinder_GetPointerToCurrentPos(mf);
+  p-&gt;btNumAvailBytes = 0;
+  p-&gt;lzPos = p-&gt;historySize + 1;
+
+  p-&gt;hash = mf-&gt;hash;
+  p-&gt;fixedHashSize = mf-&gt;fixedHashSize;
+  p-&gt;crc = mf-&gt;crc;
+
+  p-&gt;son = mf-&gt;son;
+  p-&gt;matchMaxLen = mf-&gt;matchMaxLen;
+  p-&gt;numHashBytes = mf-&gt;numHashBytes;
+  p-&gt;pos = mf-&gt;pos;
+  p-&gt;buffer = mf-&gt;buffer;
+  p-&gt;cyclicBufferPos = mf-&gt;cyclicBufferPos;
+  p-&gt;cyclicBufferSize = mf-&gt;cyclicBufferSize;
+  p-&gt;cutValue = mf-&gt;cutValue;
+}
+
+/* ReleaseStream is required to finish multithreading */
+void MatchFinderMt_ReleaseStream(CMatchFinderMt *p)
+{
+  MtSync_StopWriting(&amp;p-&gt;btSync);
+  /* p-&gt;MatchFinder-&gt;ReleaseStream(); */
+}
+
+void MatchFinderMt_Normalize(CMatchFinderMt *p)
+{
+  MatchFinder_Normalize3(p-&gt;lzPos - p-&gt;historySize - 1, p-&gt;hash, p-&gt;fixedHashSize);
+  p-&gt;lzPos = p-&gt;historySize + 1;
+}
+
+void MatchFinderMt_GetNextBlock_Bt(CMatchFinderMt *p)
+{
+  UInt32 blockIndex;
+  MtSync_GetNextBlock(&amp;p-&gt;btSync);
+  blockIndex = ((p-&gt;btSync.numProcessedBlocks - 1) &amp; kMtBtNumBlocksMask);
+  p-&gt;btBufPosLimit = p-&gt;btBufPos = blockIndex * kMtBtBlockSize;
+  p-&gt;btBufPosLimit += p-&gt;btBuf[p-&gt;btBufPos++];
+  p-&gt;btNumAvailBytes = p-&gt;btBuf[p-&gt;btBufPos++];
+  if (p-&gt;lzPos &gt;= kMtMaxValForNormalize - kMtBtBlockSize)
+    MatchFinderMt_Normalize(p);
+}
+
+const Byte * MatchFinderMt_GetPointerToCurrentPos(CMatchFinderMt *p)
+{
+  return p-&gt;pointerToCurPos;
+}
+
+#define GET_NEXT_BLOCK_IF_REQUIRED if (p-&gt;btBufPos == p-&gt;btBufPosLimit) MatchFinderMt_GetNextBlock_Bt(p);
+
+UInt32 MatchFinderMt_GetNumAvailableBytes(CMatchFinderMt *p)
+{
+  GET_NEXT_BLOCK_IF_REQUIRED;
+  return p-&gt;btNumAvailBytes;
+}
+
+Byte MatchFinderMt_GetIndexByte(CMatchFinderMt *p, Int32 index)
+{
+  return p-&gt;pointerToCurPos[index];
+}
+
+UInt32 * MixMatches2(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, curMatch2;
+  UInt32 *hash = p-&gt;hash;
+  const Byte *cur = p-&gt;pointerToCurPos;
+  UInt32 lzPos = p-&gt;lzPos;
+  MT_HASH2_CALC
+      
+  curMatch2 = hash[hash2Value];
+  hash[hash2Value] = lzPos;
+
+  if (curMatch2 &gt;= matchMinPos)
+    if (cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+    {
+      *distances++ = 2;
+      *distances++ = lzPos - curMatch2 - 1;
+    }
+  return distances;
+}
+
+UInt32 * MixMatches3(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, curMatch2, curMatch3;
+  UInt32 *hash = p-&gt;hash;
+  const Byte *cur = p-&gt;pointerToCurPos;
+  UInt32 lzPos = p-&gt;lzPos;
+  MT_HASH3_CALC
+
+  curMatch2 = hash[                hash2Value];
+  curMatch3 = hash[kFix3HashSize + hash3Value];
+  
+  hash[                hash2Value] =
+  hash[kFix3HashSize + hash3Value] =
+    lzPos;
+
+  if (curMatch2 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch2 - 1;
+    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
+    {
+      distances[0] = 3;
+      return distances + 2;
+    }
+    distances[0] = 2;
+    distances += 2;
+  }
+  if (curMatch3 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
+  {
+    *distances++ = 3;
+    *distances++ = lzPos - curMatch3 - 1;
+  }
+  return distances;
+}
+
+/*
+UInt32 *MixMatches4(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, hash4Value, curMatch2, curMatch3, curMatch4;
+  UInt32 *hash = p-&gt;hash;
+  const Byte *cur = p-&gt;pointerToCurPos;
+  UInt32 lzPos = p-&gt;lzPos;
+  MT_HASH4_CALC
+      
+  curMatch2 = hash[                hash2Value];
+  curMatch3 = hash[kFix3HashSize + hash3Value];
+  curMatch4 = hash[kFix4HashSize + hash4Value];
+  
+  hash[                hash2Value] =
+  hash[kFix3HashSize + hash3Value] =
+  hash[kFix4HashSize + hash4Value] =
+    lzPos;
+
+  if (curMatch2 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch2 - 1;
+    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
+    {
+      distances[0] =  (cur[(ptrdiff_t)curMatch2 - lzPos + 3] == cur[3]) ? 4 : 3;
+      return distances + 2;
+    }
+    distances[0] = 2;
+    distances += 2;
+  }
+  if (curMatch3 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch3 - 1;
+    if (cur[(ptrdiff_t)curMatch3 - lzPos + 3] == cur[3])
+    {
+      distances[0] = 4;
+      return distances + 2;
+    }
+    distances[0] = 3;
+    distances += 2;
+  }
+
+  if (curMatch4 &gt;= matchMinPos)
+    if (
+      cur[(ptrdiff_t)curMatch4 - lzPos] == cur[0] &amp;&amp;
+      cur[(ptrdiff_t)curMatch4 - lzPos + 3] == cur[3]
+      )
+    {
+      *distances++ = 4;
+      *distances++ = lzPos - curMatch4 - 1;
+    }
+  return distances;
+}
+*/
+
+#define INCREASE_LZ_POS p-&gt;lzPos++; p-&gt;pointerToCurPos++;
+
+UInt32 MatchFinderMt2_GetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  const UInt32 *btBuf = p-&gt;btBuf + p-&gt;btBufPos;
+  UInt32 len = *btBuf++;
+  p-&gt;btBufPos += 1 + len;
+  p-&gt;btNumAvailBytes--;
+  {
+    UInt32 i;
+    for (i = 0; i &lt; len; i += 2)
+    {
+      *distances++ = *btBuf++;
+      *distances++ = *btBuf++;
+    }
+  }
+  INCREASE_LZ_POS
+  return len;
+}
+
+UInt32 MatchFinderMt_GetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  const UInt32 *btBuf = p-&gt;btBuf + p-&gt;btBufPos;
+  UInt32 len = *btBuf++;
+  p-&gt;btBufPos += 1 + len;
+
+  if (len == 0)
+  {
+    if (p-&gt;btNumAvailBytes-- &gt;= 4)
+      len = (UInt32)(p-&gt;MixMatchesFunc(p, p-&gt;lzPos - p-&gt;historySize, distances) - (distances));
+  }
+  else
+  {
+    /* Condition: there are matches in btBuf with length &lt; p-&gt;numHashBytes */
+    UInt32 *distances2;
+    p-&gt;btNumAvailBytes--;
+    distances2 = p-&gt;MixMatchesFunc(p, p-&gt;lzPos - btBuf[1], distances);
+    do
+    {
+      *distances2++ = *btBuf++;
+      *distances2++ = *btBuf++;
+    }
+    while ((len -= 2) != 0);
+    len  = (UInt32)(distances2 - (distances));
+  }
+  INCREASE_LZ_POS
+  return len;
+}
+
+#define SKIP_HEADER2  do { GET_NEXT_BLOCK_IF_REQUIRED
+#define SKIP_HEADER(n) SKIP_HEADER2 if (p-&gt;btNumAvailBytes-- &gt;= (n)) { const Byte *cur = p-&gt;pointerToCurPos; UInt32 *hash = p-&gt;hash;
+#define SKIP_FOOTER } INCREASE_LZ_POS p-&gt;btBufPos += p-&gt;btBuf[p-&gt;btBufPos] + 1; } while (--num != 0);
+
+void MatchFinderMt0_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER2 { p-&gt;btNumAvailBytes--;
+  SKIP_FOOTER
+}
+
+void MatchFinderMt2_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(2)
+      UInt32 hash2Value;
+      MT_HASH2_CALC
+      hash[hash2Value] = p-&gt;lzPos;
+  SKIP_FOOTER
+}
+
+void MatchFinderMt3_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(3)
+      UInt32 hash2Value, hash3Value;
+      MT_HASH3_CALC
+      hash[kFix3HashSize + hash3Value] =
+      hash[                hash2Value] =
+        p-&gt;lzPos;
+  SKIP_FOOTER
+}
+
+/*
+void MatchFinderMt4_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(4)
+      UInt32 hash2Value, hash3Value, hash4Value;
+      MT_HASH4_CALC
+      hash[kFix4HashSize + hash4Value] =
+      hash[kFix3HashSize + hash3Value] =
+      hash[                hash2Value] =
+        p-&gt;lzPos;
+  SKIP_FOOTER
+}
+*/
+
+void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable)
+{
+  vTable-&gt;Init = (Mf_Init_Func)MatchFinderMt_Init;
+  vTable-&gt;GetIndexByte = (Mf_GetIndexByte_Func)MatchFinderMt_GetIndexByte;
+  vTable-&gt;GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinderMt_GetNumAvailableBytes;
+  vTable-&gt;GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinderMt_GetPointerToCurrentPos;
+  vTable-&gt;GetMatches = (Mf_GetMatches_Func)MatchFinderMt_GetMatches;
+  switch(p-&gt;MatchFinder-&gt;numHashBytes)
+  {
+    case 2:
+      p-&gt;GetHeadsFunc = GetHeads2;
+      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)0;
+      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt0_Skip;
+      vTable-&gt;GetMatches = (Mf_GetMatches_Func)MatchFinderMt2_GetMatches;
+      break;
+    case 3:
+      p-&gt;GetHeadsFunc = GetHeads3;
+      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches2;
+      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt2_Skip;
+      break;
+    default:
+    /* case 4: */
+      p-&gt;GetHeadsFunc = p-&gt;MatchFinder-&gt;bigHash ? GetHeads4b : GetHeads4;
+      /* p-&gt;GetHeadsFunc = GetHeads4; */
+      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches3;
+      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt3_Skip;
+      break;
+    /*
+    default:
+      p-&gt;GetHeadsFunc = GetHeads5;
+      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches4;
+      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt4_Skip;
+      break;
+    */
+  }
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,99 +0,0 @@
-/* LzFindMt.h  -- multithreaded Match finder for LZ algorithms
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#ifndef __LZFINDMT_H
-#define __LZFINDMT_H
-
-#include &quot;Threads.h&quot;
-#include &quot;LzFind.h&quot;
-
-#define kMtHashBlockSize (1 &lt;&lt; 13)
-#define kMtHashNumBlocks (1 &lt;&lt; 3)
-#define kMtHashNumBlocksMask (kMtHashNumBlocks - 1)
-
-#define kMtBtBlockSize (1 &lt;&lt; 14)
-#define kMtBtNumBlocks (1 &lt;&lt; 6)
-#define kMtBtNumBlocksMask (kMtBtNumBlocks - 1)
-
-typedef struct _CMtSync
-{
-  Bool wasCreated;
-  Bool needStart;
-  Bool exit;
-  Bool stopWriting;
-
-  CThread thread;
-  CAutoResetEvent canStart;
-  CAutoResetEvent wasStarted;
-  CAutoResetEvent wasStopped;
-  CSemaphore freeSemaphore;
-  CSemaphore filledSemaphore;
-  Bool csWasInitialized;
-  Bool csWasEntered;
-  CCriticalSection cs;
-  UInt32 numProcessedBlocks;
-} CMtSync;
-
-typedef UInt32 * (*Mf_Mix_Matches)(void *p, UInt32 matchMinPos, UInt32 *distances);
-
-/* kMtCacheLineDummy must be &gt;= size_of_CPU_cache_line */
-#define kMtCacheLineDummy 128
-
-typedef void (*Mf_GetHeads)(const Byte *buffer, UInt32 pos,
-  UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc);
-
-typedef struct _CMatchFinderMt
-{
-  /* LZ */
-  const Byte *pointerToCurPos;
-  UInt32 *btBuf;
-  UInt32 btBufPos;
-  UInt32 btBufPosLimit;
-  UInt32 lzPos;
-  UInt32 btNumAvailBytes;
-
-  UInt32 *hash;
-  UInt32 fixedHashSize;
-  UInt32 historySize;
-  const UInt32 *crc;
-
-  Mf_Mix_Matches MixMatchesFunc;
-  
-  /* LZ + BT */
-  CMtSync btSync;
-  Byte btDummy[kMtCacheLineDummy];
-
-  /* BT */
-  UInt32 *hashBuf;
-  UInt32 hashBufPos;
-  UInt32 hashBufPosLimit;
-  UInt32 hashNumAvail;
-
-  CLzRef *son;
-  UInt32 matchMaxLen;
-  UInt32 numHashBytes;
-  UInt32 pos;
-  Byte *buffer;
-  UInt32 cyclicBufferPos;
-  UInt32 cyclicBufferSize; /* it must be historySize + 1 */
-  UInt32 cutValue;
-
-  /* BT + Hash */
-  CMtSync hashSync;
-  /* Byte hashDummy[kMtCacheLineDummy]; */
-  
-  /* Hash */
-  Mf_GetHeads GetHeadsFunc;
-  CMatchFinder *MatchFinder;
-} CMatchFinderMt;
-
-void MatchFinderMt_Construct(CMatchFinderMt *p);
-void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc);
-SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
-    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc);
-void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable);
-void MatchFinderMt_ReleaseStream(CMatchFinderMt *p);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzFindMt.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,99 @@
+/* LzFindMt.h  -- multithreaded Match finder for LZ algorithms
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#ifndef __LZFINDMT_H
+#define __LZFINDMT_H
+
+#include &quot;Threads.h&quot;
+#include &quot;LzFind.h&quot;
+
+#define kMtHashBlockSize (1 &lt;&lt; 13)
+#define kMtHashNumBlocks (1 &lt;&lt; 3)
+#define kMtHashNumBlocksMask (kMtHashNumBlocks - 1)
+
+#define kMtBtBlockSize (1 &lt;&lt; 14)
+#define kMtBtNumBlocks (1 &lt;&lt; 6)
+#define kMtBtNumBlocksMask (kMtBtNumBlocks - 1)
+
+typedef struct _CMtSync
+{
+  Bool wasCreated;
+  Bool needStart;
+  Bool exit;
+  Bool stopWriting;
+
+  CThread thread;
+  CAutoResetEvent canStart;
+  CAutoResetEvent wasStarted;
+  CAutoResetEvent wasStopped;
+  CSemaphore freeSemaphore;
+  CSemaphore filledSemaphore;
+  Bool csWasInitialized;
+  Bool csWasEntered;
+  CCriticalSection cs;
+  UInt32 numProcessedBlocks;
+} CMtSync;
+
+typedef UInt32 * (*Mf_Mix_Matches)(void *p, UInt32 matchMinPos, UInt32 *distances);
+
+/* kMtCacheLineDummy must be &gt;= size_of_CPU_cache_line */
+#define kMtCacheLineDummy 128
+
+typedef void (*Mf_GetHeads)(const Byte *buffer, UInt32 pos,
+  UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc);
+
+typedef struct _CMatchFinderMt
+{
+  /* LZ */
+  const Byte *pointerToCurPos;
+  UInt32 *btBuf;
+  UInt32 btBufPos;
+  UInt32 btBufPosLimit;
+  UInt32 lzPos;
+  UInt32 btNumAvailBytes;
+
+  UInt32 *hash;
+  UInt32 fixedHashSize;
+  UInt32 historySize;
+  const UInt32 *crc;
+
+  Mf_Mix_Matches MixMatchesFunc;
+  
+  /* LZ + BT */
+  CMtSync btSync;
+  Byte btDummy[kMtCacheLineDummy];
+
+  /* BT */
+  UInt32 *hashBuf;
+  UInt32 hashBufPos;
+  UInt32 hashBufPosLimit;
+  UInt32 hashNumAvail;
+
+  CLzRef *son;
+  UInt32 matchMaxLen;
+  UInt32 numHashBytes;
+  UInt32 pos;
+  Byte *buffer;
+  UInt32 cyclicBufferPos;
+  UInt32 cyclicBufferSize; /* it must be historySize + 1 */
+  UInt32 cutValue;
+
+  /* BT + Hash */
+  CMtSync hashSync;
+  /* Byte hashDummy[kMtCacheLineDummy]; */
+  
+  /* Hash */
+  Mf_GetHeads GetHeadsFunc;
+  CMatchFinder *MatchFinder;
+} CMatchFinderMt;
+
+void MatchFinderMt_Construct(CMatchFinderMt *p);
+void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc);
+SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc);
+void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable);
+void MatchFinderMt_ReleaseStream(CMatchFinderMt *p);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,56 +0,0 @@
-/* LzHash.h  -- HASH functions for LZ algorithms
-2008-03-26
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#ifndef __LZHASH_H
-#define __LZHASH_H
-
-#define kHash2Size (1 &lt;&lt; 10)
-#define kHash3Size (1 &lt;&lt; 16)
-#define kHash4Size (1 &lt;&lt; 20)
-
-#define kFix3HashSize (kHash2Size)
-#define kFix4HashSize (kHash2Size + kHash3Size)
-#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
-
-#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] &lt;&lt; 8);
-
-#define HASH3_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hashValue = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; p-&gt;hashMask; }
-
-#define HASH4_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
-  hashValue = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)) &amp; p-&gt;hashMask; }
-
-#define HASH5_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
-  hash4Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)); \
-  hashValue = (hash4Value ^ (p-&gt;crc[cur[4]] &lt;&lt; 3)) &amp; p-&gt;hashMask; \
-  hash4Value &amp;= (kHash4Size - 1); }
-
-/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] &lt;&lt; 8)) ^ p-&gt;crc[cur[2]]) &amp; 0xFFFF; */
-#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] &lt;&lt; 8)) ^ p-&gt;crc[cur[1]]) &amp; 0xFFFF;
-
-
-#define MT_HASH2_CALC \
-  hash2Value = (p-&gt;crc[cur[0]] ^ cur[1]) &amp; (kHash2Size - 1);
-
-#define MT_HASH3_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); }
-
-#define MT_HASH4_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
-  hash4Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)) &amp; (kHash4Size - 1); }
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzHash.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,56 @@
+/* LzHash.h  -- HASH functions for LZ algorithms
+2008-03-26
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#ifndef __LZHASH_H
+#define __LZHASH_H
+
+#define kHash2Size (1 &lt;&lt; 10)
+#define kHash3Size (1 &lt;&lt; 16)
+#define kHash4Size (1 &lt;&lt; 20)
+
+#define kFix3HashSize (kHash2Size)
+#define kFix4HashSize (kHash2Size + kHash3Size)
+#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
+
+#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] &lt;&lt; 8);
+
+#define HASH3_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hashValue = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; p-&gt;hashMask; }
+
+#define HASH4_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
+  hashValue = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)) &amp; p-&gt;hashMask; }
+
+#define HASH5_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
+  hash4Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)); \
+  hashValue = (hash4Value ^ (p-&gt;crc[cur[4]] &lt;&lt; 3)) &amp; p-&gt;hashMask; \
+  hash4Value &amp;= (kHash4Size - 1); }
+
+/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] &lt;&lt; 8)) ^ p-&gt;crc[cur[2]]) &amp; 0xFFFF; */
+#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] &lt;&lt; 8)) ^ p-&gt;crc[cur[1]]) &amp; 0xFFFF;
+
+
+#define MT_HASH2_CALC \
+  hash2Value = (p-&gt;crc[cur[0]] ^ cur[1]) &amp; (kHash2Size - 1);
+
+#define MT_HASH3_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); }
+
+#define MT_HASH4_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
+  hash4Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)) &amp; (kHash4Size - 1); }
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,1014 +0,0 @@
-/* LzmaDec.c -- LZMA Decoder
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaDec.h for license options */
-
-#include &quot;LzmaDec.h&quot;
-
-#include &lt;string.h&gt;
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
-#define kNumMoveBits 5
-
-#define RC_INIT_SIZE 5
-
-#define NORMALIZE if (range &lt; kTopValue) { range &lt;&lt;= 8; code = (code &lt;&lt; 8) | (*buf++); }
-
-#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
-#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) &gt;&gt; kNumMoveBits));
-#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt &gt;&gt; kNumMoveBits));
-#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
-  { UPDATE_0(p); i = (i + i); A0; } else \
-  { UPDATE_1(p); i = (i + i) + 1; A1; }
-#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
-
-#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
-#define TREE_DECODE(probs, limit, i) \
-  { i = 1; do { TREE_GET_BIT(probs, i); } while (i &lt; limit); i -= limit; }
-
-/* #define _LZMA_SIZE_OPT */
-
-#ifdef _LZMA_SIZE_OPT
-#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 &lt;&lt; 6), i)
-#else
-#define TREE_6_DECODE(probs, i) \
-  { i = 1; \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  i -= 0x40; }
-#endif
-
-#define NORMALIZE_CHECK if (range &lt; kTopValue) { if (buf &gt;= bufLimit) return DUMMY_ERROR; range &lt;&lt;= 8; code = (code &lt;&lt; 8) | (*buf++); }
-
-#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
-#define UPDATE_0_CHECK range = bound;
-#define UPDATE_1_CHECK range -= bound; code -= bound;
-#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
-  { UPDATE_0_CHECK; i = (i + i); A0; } else \
-  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
-#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
-#define TREE_DECODE_CHECK(probs, limit, i) \
-  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i &lt; limit); i -= limit; }
-
-
-#define kNumPosBitsMax 4
-#define kNumPosStatesMax (1 &lt;&lt; kNumPosBitsMax)
-
-#define kLenNumLowBits 3
-#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
-#define kLenNumMidBits 3
-#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
-#define kLenNumHighBits 8
-#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
-
-#define LenChoice 0
-#define LenChoice2 (LenChoice + 1)
-#define LenLow (LenChoice2 + 1)
-#define LenMid (LenLow + (kNumPosStatesMax &lt;&lt; kLenNumLowBits))
-#define LenHigh (LenMid + (kNumPosStatesMax &lt;&lt; kLenNumMidBits))
-#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
-
-
-#define kNumStates 12
-#define kNumLitStates 7
-
-#define kStartPosModelIndex 4
-#define kEndPosModelIndex 14
-#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex &gt;&gt; 1))
-
-#define kNumPosSlotBits 6
-#define kNumLenToPosStates 4
-
-#define kNumAlignBits 4
-#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
-
-#define kMatchMinLen 2
-#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-
-#define IsMatch 0
-#define IsRep (IsMatch + (kNumStates &lt;&lt; kNumPosBitsMax))
-#define IsRepG0 (IsRep + kNumStates)
-#define IsRepG1 (IsRepG0 + kNumStates)
-#define IsRepG2 (IsRepG1 + kNumStates)
-#define IsRep0Long (IsRepG2 + kNumStates)
-#define PosSlot (IsRep0Long + (kNumStates &lt;&lt; kNumPosBitsMax))
-#define SpecPos (PosSlot + (kNumLenToPosStates &lt;&lt; kNumPosSlotBits))
-#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
-#define LenCoder (Align + kAlignTableSize)
-#define RepLenCoder (LenCoder + kNumLenProbs)
-#define Literal (RepLenCoder + kNumLenProbs)
-
-#define LZMA_BASE_SIZE 1846
-#define LZMA_LIT_SIZE 768
-
-#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE &lt;&lt; ((p)-&gt;lc + (p)-&gt;lp)))
-
-#if Literal != LZMA_BASE_SIZE
-StopCompilingDueBUG
-#endif
-
-/*
-#define LZMA_STREAM_WAS_FINISHED_ID (-1)
-#define LZMA_SPEC_LEN_OFFSET (-3)
-*/
-
-const Byte kLiteralNextStates[kNumStates * 2] =
-{
-  0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
-  7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10
-};
-
-#define LZMA_DIC_MIN (1 &lt;&lt; 12)
-
-/* First LZMA-symbol is always decoded.
-And it decodes new LZMA-symbols while (buf &lt; bufLimit), but &quot;buf&quot; is without last normalization
-Out:
-  Result:
-    0 - OK
-    1 - Error
-  p-&gt;remainLen:
-    &lt; kMatchSpecLenStart : normal remain
-    = kMatchSpecLenStart : finished
-    = kMatchSpecLenStart + 1 : Flush marker
-    = kMatchSpecLenStart + 2 : State Init Marker
-*/
-
-static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-{
-  CLzmaProb *probs = p-&gt;probs;
-
-  unsigned state = p-&gt;state;
-  UInt32 rep0 = p-&gt;reps[0], rep1 = p-&gt;reps[1], rep2 = p-&gt;reps[2], rep3 = p-&gt;reps[3];
-  unsigned pbMask = ((unsigned)1 &lt;&lt; (p-&gt;prop.pb)) - 1;
-  unsigned lpMask = ((unsigned)1 &lt;&lt; (p-&gt;prop.lp)) - 1;
-  unsigned lc = p-&gt;prop.lc;
-
-  Byte *dic = p-&gt;dic;
-  SizeT dicBufSize = p-&gt;dicBufSize;
-  SizeT dicPos = p-&gt;dicPos;
-  
-  UInt32 processedPos = p-&gt;processedPos;
-  UInt32 checkDicSize = p-&gt;checkDicSize;
-  unsigned len = 0;
-
-  const Byte *buf = p-&gt;buf;
-  UInt32 range = p-&gt;range;
-  UInt32 code = p-&gt;code;
-
-  do
-  {
-    CLzmaProb *prob;
-    UInt32 bound;
-    unsigned ttt;
-    unsigned posState = processedPos &amp; pbMask;
-
-    prob = probs + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
-    IF_BIT_0(prob)
-    {
-      unsigned symbol;
-      UPDATE_0(prob);
-      prob = probs + Literal;
-      if (checkDicSize != 0 || processedPos != 0)
-        prob += (LZMA_LIT_SIZE * (((processedPos &amp; lpMask) &lt;&lt; lc) +
-        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] &gt;&gt; (8 - lc))));
-
-      if (state &lt; kNumLitStates)
-      {
-        symbol = 1;
-        do { GET_BIT(prob + symbol, symbol) } while (symbol &lt; 0x100);
-      }
-      else
-      {
-        unsigned matchByte = p-&gt;dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
-        unsigned offs = 0x100;
-        symbol = 1;
-        do
-        {
-          unsigned bit;
-          CLzmaProb *probLit;
-          matchByte &lt;&lt;= 1;
-          bit = (matchByte &amp; offs);
-          probLit = prob + offs + bit + symbol;
-          GET_BIT2(probLit, symbol, offs &amp;= ~bit, offs &amp;= bit)
-        }
-        while (symbol &lt; 0x100);
-      }
-      dic[dicPos++] = (Byte)symbol;
-      processedPos++;
-
-      state = kLiteralNextStates[state];
-      /* if (state &lt; 4) state = 0; else if (state &lt; 10) state -= 3; else state -= 6; */
-      continue;
-    }
-    else
-    {
-      UPDATE_1(prob);
-      prob = probs + IsRep + state;
-      IF_BIT_0(prob)
-      {
-        UPDATE_0(prob);
-        state += kNumStates;
-        prob = probs + LenCoder;
-      }
-      else
-      {
-        UPDATE_1(prob);
-        if (checkDicSize == 0 &amp;&amp; processedPos == 0)
-          return SZ_ERROR_DATA;
-        prob = probs + IsRepG0 + state;
-        IF_BIT_0(prob)
-        {
-          UPDATE_0(prob);
-          prob = probs + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
-          IF_BIT_0(prob)
-          {
-            UPDATE_0(prob);
-            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
-            dicPos++;
-            processedPos++;
-            state = state &lt; kNumLitStates ? 9 : 11;
-            continue;
-          }
-          UPDATE_1(prob);
-        }
-        else
-        {
-          UInt32 distance;
-          UPDATE_1(prob);
-          prob = probs + IsRepG1 + state;
-          IF_BIT_0(prob)
-          {
-            UPDATE_0(prob);
-            distance = rep1;
-          }
-          else
-          {
-            UPDATE_1(prob);
-            prob = probs + IsRepG2 + state;
-            IF_BIT_0(prob)
-            {
-              UPDATE_0(prob);
-              distance = rep2;
-            }
-            else
-            {
-              UPDATE_1(prob);
-              distance = rep3;
-              rep3 = rep2;
-            }
-            rep2 = rep1;
-          }
-          rep1 = rep0;
-          rep0 = distance;
-        }
-        state = state &lt; kNumLitStates ? 8 : 11;
-        prob = probs + RepLenCoder;
-      }
-      {
-        unsigned limit, offset;
-        CLzmaProb *probLen = prob + LenChoice;
-        IF_BIT_0(probLen)
-        {
-          UPDATE_0(probLen);
-          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
-          offset = 0;
-          limit = (1 &lt;&lt; kLenNumLowBits);
-        }
-        else
-        {
-          UPDATE_1(probLen);
-          probLen = prob + LenChoice2;
-          IF_BIT_0(probLen)
-          {
-            UPDATE_0(probLen);
-            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
-            offset = kLenNumLowSymbols;
-            limit = (1 &lt;&lt; kLenNumMidBits);
-          }
-          else
-          {
-            UPDATE_1(probLen);
-            probLen = prob + LenHigh;
-            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-            limit = (1 &lt;&lt; kLenNumHighBits);
-          }
-        }
-        TREE_DECODE(probLen, limit, len);
-        len += offset;
-      }
-
-      if (state &gt;= kNumStates)
-      {
-        UInt32 distance;
-        prob = probs + PosSlot +
-            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt; kNumPosSlotBits);
-        TREE_6_DECODE(prob, distance);
-        if (distance &gt;= kStartPosModelIndex)
-        {
-          unsigned posSlot = (unsigned)distance;
-          int numDirectBits = (int)(((distance &gt;&gt; 1) - 1));
-          distance = (2 | (distance &amp; 1));
-          if (posSlot &lt; kEndPosModelIndex)
-          {
-            distance &lt;&lt;= numDirectBits;
-            prob = probs + SpecPos + distance - posSlot - 1;
-            {
-              UInt32 mask = 1;
-              unsigned i = 1;
-              do
-              {
-                GET_BIT2(prob + i, i, ; , distance |= mask);
-                mask &lt;&lt;= 1;
-              }
-              while (--numDirectBits != 0);
-            }
-          }
-          else
-          {
-            numDirectBits -= kNumAlignBits;
-            do
-            {
-              NORMALIZE
-              range &gt;&gt;= 1;
-              
-              {
-                UInt32 t;
-                code -= range;
-                t = (0 - ((UInt32)code &gt;&gt; 31)); /* (UInt32)((Int32)code &gt;&gt; 31) */
-                distance = (distance &lt;&lt; 1) + (t + 1);
-                code += range &amp; t;
-              }
-              /*
-              distance &lt;&lt;= 1;
-              if (code &gt;= range)
-              {
-                code -= range;
-                distance |= 1;
-              }
-              */
-            }
-            while (--numDirectBits != 0);
-            prob = probs + Align;
-            distance &lt;&lt;= kNumAlignBits;
-            {
-              unsigned i = 1;
-              GET_BIT2(prob + i, i, ; , distance |= 1);
-              GET_BIT2(prob + i, i, ; , distance |= 2);
-              GET_BIT2(prob + i, i, ; , distance |= 4);
-              GET_BIT2(prob + i, i, ; , distance |= 8);
-            }
-            if (distance == (UInt32)0xFFFFFFFF)
-            {
-              len += kMatchSpecLenStart;
-              state -= kNumStates;
-              break;
-            }
-          }
-        }
-        rep3 = rep2;
-        rep2 = rep1;
-        rep1 = rep0;
-        rep0 = distance + 1;
-        if (checkDicSize == 0)
-        {
-          if (distance &gt;= processedPos)
-            return SZ_ERROR_DATA;
-        }
-        else if (distance &gt;= checkDicSize)
-          return SZ_ERROR_DATA;
-        state = (state &lt; kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
-        /* state = kLiteralNextStates[state]; */
-      }
-
-      len += kMatchMinLen;
-
-      {
-        SizeT rem = limit - dicPos;
-        unsigned curLen = ((rem &lt; len) ? (unsigned)rem : len);
-        SizeT pos = (dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0);
-
-        processedPos += curLen;
-
-        len -= curLen;
-        if (pos + curLen &lt;= dicBufSize)
-        {
-          Byte *dest = dic + dicPos;
-          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
-          const Byte *lim = dest + curLen;
-          dicPos += curLen;
-          do
-            *(dest) = (Byte)*(dest + src);
-          while (++dest != lim);
-        }
-        else
-        {
-          do
-          {
-            dic[dicPos++] = dic[pos];
-            if (++pos == dicBufSize)
-              pos = 0;
-          }
-          while (--curLen != 0);
-        }
-      }
-    }
-  }
-  while (dicPos &lt; limit &amp;&amp; buf &lt; bufLimit);
-  NORMALIZE;
-  p-&gt;buf = buf;
-  p-&gt;range = range;
-  p-&gt;code = code;
-  p-&gt;remainLen = len;
-  p-&gt;dicPos = dicPos;
-  p-&gt;processedPos = processedPos;
-  p-&gt;reps[0] = rep0;
-  p-&gt;reps[1] = rep1;
-  p-&gt;reps[2] = rep2;
-  p-&gt;reps[3] = rep3;
-  p-&gt;state = state;
-
-  return SZ_OK;
-}
-
-static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
-{
-  if (p-&gt;remainLen != 0 &amp;&amp; p-&gt;remainLen &lt; kMatchSpecLenStart)
-  {
-    Byte *dic = p-&gt;dic;
-    SizeT dicPos = p-&gt;dicPos;
-    SizeT dicBufSize = p-&gt;dicBufSize;
-    unsigned len = p-&gt;remainLen;
-    UInt32 rep0 = p-&gt;reps[0];
-    if (limit - dicPos &lt; len)
-      len = (unsigned)(limit - dicPos);
-
-    if (p-&gt;checkDicSize == 0 &amp;&amp; p-&gt;prop.dicSize - p-&gt;processedPos &lt;= len)
-      p-&gt;checkDicSize = p-&gt;prop.dicSize;
-
-    p-&gt;processedPos += len;
-    p-&gt;remainLen -= len;
-    while (len-- != 0)
-    {
-      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
-      dicPos++;
-    }
-    p-&gt;dicPos = dicPos;
-  }
-}
-
-/* LzmaDec_DecodeReal2 decodes LZMA-symbols and sets p-&gt;needFlush and p-&gt;needInit, if required. */
-
-static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-{
-  do
-  {
-    SizeT limit2 = limit;
-    if (p-&gt;checkDicSize == 0)
-    {
-      UInt32 rem = p-&gt;prop.dicSize - p-&gt;processedPos;
-      if (limit - p-&gt;dicPos &gt; rem)
-        limit2 = p-&gt;dicPos + rem;
-    }
-    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
-    if (p-&gt;processedPos &gt;= p-&gt;prop.dicSize)
-      p-&gt;checkDicSize = p-&gt;prop.dicSize;
-    LzmaDec_WriteRem(p, limit);
-  }
-  while (p-&gt;dicPos &lt; limit &amp;&amp; p-&gt;buf &lt; bufLimit &amp;&amp; p-&gt;remainLen &lt; kMatchSpecLenStart);
-
-  if (p-&gt;remainLen &gt; kMatchSpecLenStart)
-  {
-    p-&gt;remainLen = kMatchSpecLenStart;
-  }
-  return 0;
-}
-
-typedef enum
-{
-  DUMMY_ERROR, /* unexpected end of input stream */
-  DUMMY_LIT,
-  DUMMY_MATCH,
-  DUMMY_REP
-} ELzmaDummy;
-
-static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
-{
-  UInt32 range = p-&gt;range;
-  UInt32 code = p-&gt;code;
-  const Byte *bufLimit = buf + inSize;
-  CLzmaProb *probs = p-&gt;probs;
-  unsigned state = p-&gt;state;
-  ELzmaDummy res;
-
-  {
-    CLzmaProb *prob;
-    UInt32 bound;
-    unsigned ttt;
-    unsigned posState = (p-&gt;processedPos) &amp; ((1 &lt;&lt; p-&gt;prop.pb) - 1);
-
-    prob = probs + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
-    IF_BIT_0_CHECK(prob)
-    {
-      UPDATE_0_CHECK
-
-      /* if (bufLimit - buf &gt;= 7) return DUMMY_LIT; */
-
-      prob = probs + Literal;
-      if (p-&gt;checkDicSize != 0 || p-&gt;processedPos != 0)
-        prob += (LZMA_LIT_SIZE *
-          ((((p-&gt;processedPos) &amp; ((1 &lt;&lt; (p-&gt;prop.lp)) - 1)) &lt;&lt; p-&gt;prop.lc) +
-          (p-&gt;dic[(p-&gt;dicPos == 0 ? p-&gt;dicBufSize : p-&gt;dicPos) - 1] &gt;&gt; (8 - p-&gt;prop.lc))));
-
-      if (state &lt; kNumLitStates)
-      {
-        unsigned symbol = 1;
-        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol &lt; 0x100);
-      }
-      else
-      {
-        unsigned matchByte = p-&gt;dic[p-&gt;dicPos - p-&gt;reps[0] +
-            ((p-&gt;dicPos &lt; p-&gt;reps[0]) ? p-&gt;dicBufSize : 0)];
-        unsigned offs = 0x100;
-        unsigned symbol = 1;
-        do
-        {
-          unsigned bit;
-          CLzmaProb *probLit;
-          matchByte &lt;&lt;= 1;
-          bit = (matchByte &amp; offs);
-          probLit = prob + offs + bit + symbol;
-          GET_BIT2_CHECK(probLit, symbol, offs &amp;= ~bit, offs &amp;= bit)
-        }
-        while (symbol &lt; 0x100);
-      }
-      res = DUMMY_LIT;
-    }
-    else
-    {
-      unsigned len;
-      UPDATE_1_CHECK;
-
-      prob = probs + IsRep + state;
-      IF_BIT_0_CHECK(prob)
-      {
-        UPDATE_0_CHECK;
-        state = 0;
-        prob = probs + LenCoder;
-        res = DUMMY_MATCH;
-      }
-      else
-      {
-        UPDATE_1_CHECK;
-        res = DUMMY_REP;
-        prob = probs + IsRepG0 + state;
-        IF_BIT_0_CHECK(prob)
-        {
-          UPDATE_0_CHECK;
-          prob = probs + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
-          IF_BIT_0_CHECK(prob)
-          {
-            UPDATE_0_CHECK;
-            NORMALIZE_CHECK;
-            return DUMMY_REP;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-          }
-        }
-        else
-        {
-          UPDATE_1_CHECK;
-          prob = probs + IsRepG1 + state;
-          IF_BIT_0_CHECK(prob)
-          {
-            UPDATE_0_CHECK;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-            prob = probs + IsRepG2 + state;
-            IF_BIT_0_CHECK(prob)
-            {
-              UPDATE_0_CHECK;
-            }
-            else
-            {
-              UPDATE_1_CHECK;
-            }
-          }
-        }
-        state = kNumStates;
-        prob = probs + RepLenCoder;
-      }
-      {
-        unsigned limit, offset;
-        CLzmaProb *probLen = prob + LenChoice;
-        IF_BIT_0_CHECK(probLen)
-        {
-          UPDATE_0_CHECK;
-          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
-          offset = 0;
-          limit = 1 &lt;&lt; kLenNumLowBits;
-        }
-        else
-        {
-          UPDATE_1_CHECK;
-          probLen = prob + LenChoice2;
-          IF_BIT_0_CHECK(probLen)
-          {
-            UPDATE_0_CHECK;
-            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
-            offset = kLenNumLowSymbols;
-            limit = 1 &lt;&lt; kLenNumMidBits;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-            probLen = prob + LenHigh;
-            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-            limit = 1 &lt;&lt; kLenNumHighBits;
-          }
-        }
-        TREE_DECODE_CHECK(probLen, limit, len);
-        len += offset;
-      }
-
-      if (state &lt; 4)
-      {
-        unsigned posSlot;
-        prob = probs + PosSlot +
-            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt;
-            kNumPosSlotBits);
-        TREE_DECODE_CHECK(prob, 1 &lt;&lt; kNumPosSlotBits, posSlot);
-        if (posSlot &gt;= kStartPosModelIndex)
-        {
-          int numDirectBits = ((posSlot &gt;&gt; 1) - 1);
-
-          /* if (bufLimit - buf &gt;= 8) return DUMMY_MATCH; */
-
-          if (posSlot &lt; kEndPosModelIndex)
-          {
-            prob = probs + SpecPos + ((2 | (posSlot &amp; 1)) &lt;&lt; numDirectBits) - posSlot - 1;
-          }
-          else
-          {
-            numDirectBits -= kNumAlignBits;
-            do
-            {
-              NORMALIZE_CHECK
-              range &gt;&gt;= 1;
-              code -= range &amp; (((code - range) &gt;&gt; 31) - 1);
-              /* if (code &gt;= range) code -= range; */
-            }
-            while (--numDirectBits != 0);
-            prob = probs + Align;
-            numDirectBits = kNumAlignBits;
-          }
-          {
-            unsigned i = 1;
-            do
-            {
-              GET_BIT_CHECK(prob + i, i);
-            }
-            while (--numDirectBits != 0);
-          }
-        }
-      }
-    }
-  }
-  NORMALIZE_CHECK;
-  return res;
-}
-
-
-static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
-{
-  p-&gt;code = ((UInt32)data[1] &lt;&lt; 24) | ((UInt32)data[2] &lt;&lt; 16) | ((UInt32)data[3] &lt;&lt; 8) | ((UInt32)data[4]);
-  p-&gt;range = 0xFFFFFFFF;
-  p-&gt;needFlush = 0;
-}
-
-void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-{
-  p-&gt;needFlush = 1;
-  p-&gt;remainLen = 0;
-  p-&gt;tempBufSize = 0;
-
-  if (initDic)
-  {
-    p-&gt;processedPos = 0;
-    p-&gt;checkDicSize = 0;
-    p-&gt;needInitState = 1;
-  }
-  if (initState)
-    p-&gt;needInitState = 1;
-}
-
-void LzmaDec_Init(CLzmaDec *p)
-{
-  p-&gt;dicPos = 0;
-  LzmaDec_InitDicAndState(p, True, True);
-}
-
-static void LzmaDec_InitStateReal(CLzmaDec *p)
-{
-  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (p-&gt;prop.lc + p-&gt;prop.lp));
-  UInt32 i;
-  CLzmaProb *probs = p-&gt;probs;
-  for (i = 0; i &lt; numProbs; i++)
-    probs[i] = kBitModelTotal &gt;&gt; 1;
-  p-&gt;reps[0] = p-&gt;reps[1] = p-&gt;reps[2] = p-&gt;reps[3] = 1;
-  p-&gt;state = 0;
-  p-&gt;needInitState = 0;
-}
-
-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-    ELzmaFinishMode finishMode, ELzmaStatus *status)
-{
-  SizeT inSize = *srcLen;
-  (*srcLen) = 0;
-  LzmaDec_WriteRem(p, dicLimit);
-  
-  *status = LZMA_STATUS_NOT_SPECIFIED;
-
-  while (p-&gt;remainLen != kMatchSpecLenStart)
-  {
-      int checkEndMarkNow;
-
-      if (p-&gt;needFlush != 0)
-      {
-        for (; inSize &gt; 0 &amp;&amp; p-&gt;tempBufSize &lt; RC_INIT_SIZE; (*srcLen)++, inSize--)
-          p-&gt;tempBuf[p-&gt;tempBufSize++] = *src++;
-        if (p-&gt;tempBufSize &lt; RC_INIT_SIZE)
-        {
-          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-          return SZ_OK;
-        }
-        if (p-&gt;tempBuf[0] != 0)
-          return SZ_ERROR_DATA;
-
-        LzmaDec_InitRc(p, p-&gt;tempBuf);
-        p-&gt;tempBufSize = 0;
-      }
-
-      checkEndMarkNow = 0;
-      if (p-&gt;dicPos &gt;= dicLimit)
-      {
-        if (p-&gt;remainLen == 0 &amp;&amp; p-&gt;code == 0)
-        {
-          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
-          return SZ_OK;
-        }
-        if (finishMode == LZMA_FINISH_ANY)
-        {
-          *status = LZMA_STATUS_NOT_FINISHED;
-          return SZ_OK;
-        }
-        if (p-&gt;remainLen != 0)
-        {
-          *status = LZMA_STATUS_NOT_FINISHED;
-          return SZ_ERROR_DATA;
-        }
-        checkEndMarkNow = 1;
-      }
-
-      if (p-&gt;needInitState)
-        LzmaDec_InitStateReal(p);
-  
-      if (p-&gt;tempBufSize == 0)
-      {
-        SizeT processed;
-        const Byte *bufLimit;
-        if (inSize &lt; LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-        {
-          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
-          if (dummyRes == DUMMY_ERROR)
-          {
-            memcpy(p-&gt;tempBuf, src, inSize);
-            p-&gt;tempBufSize = (unsigned)inSize;
-            (*srcLen) += inSize;
-            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-            return SZ_OK;
-          }
-          if (checkEndMarkNow &amp;&amp; dummyRes != DUMMY_MATCH)
-          {
-            *status = LZMA_STATUS_NOT_FINISHED;
-            return SZ_ERROR_DATA;
-          }
-          bufLimit = src;
-        }
-        else
-          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
-        p-&gt;buf = src;
-        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
-          return SZ_ERROR_DATA;
-        processed = p-&gt;buf - src;
-        (*srcLen) += processed;
-        src += processed;
-        inSize -= processed;
-      }
-      else
-      {
-        unsigned rem = p-&gt;tempBufSize, lookAhead = 0;
-        while (rem &lt; LZMA_REQUIRED_INPUT_MAX &amp;&amp; lookAhead &lt; inSize)
-          p-&gt;tempBuf[rem++] = src[lookAhead++];
-        p-&gt;tempBufSize = rem;
-        if (rem &lt; LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-        {
-          int dummyRes = LzmaDec_TryDummy(p, p-&gt;tempBuf, rem);
-          if (dummyRes == DUMMY_ERROR)
-          {
-            (*srcLen) += lookAhead;
-            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-            return SZ_OK;
-          }
-          if (checkEndMarkNow &amp;&amp; dummyRes != DUMMY_MATCH)
-          {
-            *status = LZMA_STATUS_NOT_FINISHED;
-            return SZ_ERROR_DATA;
-          }
-        }
-        p-&gt;buf = p-&gt;tempBuf;
-        if (LzmaDec_DecodeReal2(p, dicLimit, p-&gt;buf) != 0)
-          return SZ_ERROR_DATA;
-        lookAhead -= (rem - (unsigned)(p-&gt;buf - p-&gt;tempBuf));
-        (*srcLen) += lookAhead;
-        src += lookAhead;
-        inSize -= lookAhead;
-        p-&gt;tempBufSize = 0;
-      }
-  }
-  if (p-&gt;code == 0)
-    *status = LZMA_STATUS_FINISHED_WITH_MARK;
-  return (p-&gt;code == 0) ? SZ_OK : SZ_ERROR_DATA;
-}
-
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
-{
-  SizeT outSize = *destLen;
-  SizeT inSize = *srcLen;
-  *srcLen = *destLen = 0;
-  for (;;)
-  {
-    SizeT inSizeCur = inSize, outSizeCur, dicPos;
-    ELzmaFinishMode curFinishMode;
-    SRes res;
-    if (p-&gt;dicPos == p-&gt;dicBufSize)
-      p-&gt;dicPos = 0;
-    dicPos = p-&gt;dicPos;
-    if (outSize &gt; p-&gt;dicBufSize - dicPos)
-    {
-      outSizeCur = p-&gt;dicBufSize;
-      curFinishMode = LZMA_FINISH_ANY;
-    }
-    else
-    {
-      outSizeCur = dicPos + outSize;
-      curFinishMode = finishMode;
-    }
-
-    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &amp;inSizeCur, curFinishMode, status);
-    src += inSizeCur;
-    inSize -= inSizeCur;
-    *srcLen += inSizeCur;
-    outSizeCur = p-&gt;dicPos - dicPos;
-    memcpy(dest, p-&gt;dic + dicPos, outSizeCur);
-    dest += outSizeCur;
-    outSize -= outSizeCur;
-    *destLen += outSizeCur;
-    if (res != 0)
-      return res;
-    if (outSizeCur == 0 || outSize == 0)
-      return SZ_OK;
-  }
-}
-
-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;probs);
-  p-&gt;probs = 0;
-}
-
-static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;dic);
-  p-&gt;dic = 0;
-}
-
-void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
-{
-  LzmaDec_FreeProbs(p, alloc);
-  LzmaDec_FreeDict(p, alloc);
-}
-
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-{
-  UInt32 dicSize;
-  Byte d;
-  
-  if (size &lt; LZMA_PROPS_SIZE)
-    return SZ_ERROR_UNSUPPORTED;
-  else
-    dicSize = data[1] | ((UInt32)data[2] &lt;&lt; 8) | ((UInt32)data[3] &lt;&lt; 16) | ((UInt32)data[4] &lt;&lt; 24);
- 
-  if (dicSize &lt; LZMA_DIC_MIN)
-    dicSize = LZMA_DIC_MIN;
-  p-&gt;dicSize = dicSize;
-
-  d = data[0];
-  if (d &gt;= (9 * 5 * 5))
-    return SZ_ERROR_UNSUPPORTED;
-
-  p-&gt;lc = d % 9;
-  d /= 9;
-  p-&gt;pb = d / 5;
-  p-&gt;lp = d % 5;
-
-  return SZ_OK;
-}
-
-static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
-{
-  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
-  if (p-&gt;probs == 0 || numProbs != p-&gt;numProbs)
-  {
-    LzmaDec_FreeProbs(p, alloc);
-    p-&gt;probs = (CLzmaProb *)alloc-&gt;Alloc(alloc, numProbs * sizeof(CLzmaProb));
-    p-&gt;numProbs = numProbs;
-    if (p-&gt;probs == 0)
-      return SZ_ERROR_MEM;
-  }
-  return SZ_OK;
-}
-
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-{
-  CLzmaProps propNew;
-  RINOK(LzmaProps_Decode(&amp;propNew, props, propsSize));
-  RINOK(LzmaDec_AllocateProbs2(p, &amp;propNew, alloc));
-  p-&gt;prop = propNew;
-  return SZ_OK;
-}
-
-SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-{
-  CLzmaProps propNew;
-  SizeT dicBufSize;
-  RINOK(LzmaProps_Decode(&amp;propNew, props, propsSize));
-  RINOK(LzmaDec_AllocateProbs2(p, &amp;propNew, alloc));
-  dicBufSize = propNew.dicSize;
-  if (p-&gt;dic == 0 || dicBufSize != p-&gt;dicBufSize)
-  {
-    LzmaDec_FreeDict(p, alloc);
-    p-&gt;dic = (Byte *)alloc-&gt;Alloc(alloc, dicBufSize);
-    if (p-&gt;dic == 0)
-    {
-      LzmaDec_FreeProbs(p, alloc);
-      return SZ_ERROR_MEM;
-    }
-  }
-  p-&gt;dicBufSize = dicBufSize;
-  p-&gt;prop = propNew;
-  return SZ_OK;
-}
-
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-    ELzmaStatus *status, ISzAlloc *alloc)
-{
-  CLzmaDec p;
-  SRes res;
-  SizeT inSize = *srcLen;
-  SizeT outSize = *destLen;
-  *srcLen = *destLen = 0;
-  if (inSize &lt; RC_INIT_SIZE)
-    return SZ_ERROR_INPUT_EOF;
-
-  LzmaDec_Construct(&amp;p);
-  res = LzmaDec_AllocateProbs(&amp;p, propData, propSize, alloc);
-  if (res != 0)
-    return res;
-  p.dic = dest;
-  p.dicBufSize = outSize;
-
-  LzmaDec_Init(&amp;p);
-  
-  *srcLen = inSize;
-  res = LzmaDec_DecodeToDic(&amp;p, outSize, src, srcLen, finishMode, status);
-
-  if (res == SZ_OK &amp;&amp; *status == LZMA_STATUS_NEEDS_MORE_INPUT)
-    res = SZ_ERROR_INPUT_EOF;
-
-  (*destLen) = p.dicPos;
-  LzmaDec_FreeProbs(&amp;p, alloc);
-  return res;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,1014 @@
+/* LzmaDec.c -- LZMA Decoder
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaDec.h for license options */
+
+#include &quot;LzmaDec.h&quot;
+
+#include &lt;string.h&gt;
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_INIT_SIZE 5
+
+#define NORMALIZE if (range &lt; kTopValue) { range &lt;&lt;= 8; code = (code &lt;&lt; 8) | (*buf++); }
+
+#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
+#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) &gt;&gt; kNumMoveBits));
+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt &gt;&gt; kNumMoveBits));
+#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
+  { UPDATE_0(p); i = (i + i); A0; } else \
+  { UPDATE_1(p); i = (i + i) + 1; A1; }
+#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
+
+#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
+#define TREE_DECODE(probs, limit, i) \
+  { i = 1; do { TREE_GET_BIT(probs, i); } while (i &lt; limit); i -= limit; }
+
+/* #define _LZMA_SIZE_OPT */
+
+#ifdef _LZMA_SIZE_OPT
+#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 &lt;&lt; 6), i)
+#else
+#define TREE_6_DECODE(probs, i) \
+  { i = 1; \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  i -= 0x40; }
+#endif
+
+#define NORMALIZE_CHECK if (range &lt; kTopValue) { if (buf &gt;= bufLimit) return DUMMY_ERROR; range &lt;&lt;= 8; code = (code &lt;&lt; 8) | (*buf++); }
+
+#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
+#define UPDATE_0_CHECK range = bound;
+#define UPDATE_1_CHECK range -= bound; code -= bound;
+#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
+  { UPDATE_0_CHECK; i = (i + i); A0; } else \
+  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
+#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
+#define TREE_DECODE_CHECK(probs, limit, i) \
+  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i &lt; limit); i -= limit; }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 &lt;&lt; kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax &lt;&lt; kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax &lt;&lt; kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex &gt;&gt; 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
+
+#define kMatchMinLen 2
+#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates &lt;&lt; kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE &lt;&lt; ((p)-&gt;lc + (p)-&gt;lp)))
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+/*
+#define LZMA_STREAM_WAS_FINISHED_ID (-1)
+#define LZMA_SPEC_LEN_OFFSET (-3)
+*/
+
+const Byte kLiteralNextStates[kNumStates * 2] =
+{
+  0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
+  7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10
+};
+
+#define LZMA_DIC_MIN (1 &lt;&lt; 12)
+
+/* First LZMA-symbol is always decoded.
+And it decodes new LZMA-symbols while (buf &lt; bufLimit), but &quot;buf&quot; is without last normalization
+Out:
+  Result:
+    0 - OK
+    1 - Error
+  p-&gt;remainLen:
+    &lt; kMatchSpecLenStart : normal remain
+    = kMatchSpecLenStart : finished
+    = kMatchSpecLenStart + 1 : Flush marker
+    = kMatchSpecLenStart + 2 : State Init Marker
+*/
+
+static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+{
+  CLzmaProb *probs = p-&gt;probs;
+
+  unsigned state = p-&gt;state;
+  UInt32 rep0 = p-&gt;reps[0], rep1 = p-&gt;reps[1], rep2 = p-&gt;reps[2], rep3 = p-&gt;reps[3];
+  unsigned pbMask = ((unsigned)1 &lt;&lt; (p-&gt;prop.pb)) - 1;
+  unsigned lpMask = ((unsigned)1 &lt;&lt; (p-&gt;prop.lp)) - 1;
+  unsigned lc = p-&gt;prop.lc;
+
+  Byte *dic = p-&gt;dic;
+  SizeT dicBufSize = p-&gt;dicBufSize;
+  SizeT dicPos = p-&gt;dicPos;
+  
+  UInt32 processedPos = p-&gt;processedPos;
+  UInt32 checkDicSize = p-&gt;checkDicSize;
+  unsigned len = 0;
+
+  const Byte *buf = p-&gt;buf;
+  UInt32 range = p-&gt;range;
+  UInt32 code = p-&gt;code;
+
+  do
+  {
+    CLzmaProb *prob;
+    UInt32 bound;
+    unsigned ttt;
+    unsigned posState = processedPos &amp; pbMask;
+
+    prob = probs + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
+    IF_BIT_0(prob)
+    {
+      unsigned symbol;
+      UPDATE_0(prob);
+      prob = probs + Literal;
+      if (checkDicSize != 0 || processedPos != 0)
+        prob += (LZMA_LIT_SIZE * (((processedPos &amp; lpMask) &lt;&lt; lc) +
+        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] &gt;&gt; (8 - lc))));
+
+      if (state &lt; kNumLitStates)
+      {
+        symbol = 1;
+        do { GET_BIT(prob + symbol, symbol) } while (symbol &lt; 0x100);
+      }
+      else
+      {
+        unsigned matchByte = p-&gt;dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
+        unsigned offs = 0x100;
+        symbol = 1;
+        do
+        {
+          unsigned bit;
+          CLzmaProb *probLit;
+          matchByte &lt;&lt;= 1;
+          bit = (matchByte &amp; offs);
+          probLit = prob + offs + bit + symbol;
+          GET_BIT2(probLit, symbol, offs &amp;= ~bit, offs &amp;= bit)
+        }
+        while (symbol &lt; 0x100);
+      }
+      dic[dicPos++] = (Byte)symbol;
+      processedPos++;
+
+      state = kLiteralNextStates[state];
+      /* if (state &lt; 4) state = 0; else if (state &lt; 10) state -= 3; else state -= 6; */
+      continue;
+    }
+    else
+    {
+      UPDATE_1(prob);
+      prob = probs + IsRep + state;
+      IF_BIT_0(prob)
+      {
+        UPDATE_0(prob);
+        state += kNumStates;
+        prob = probs + LenCoder;
+      }
+      else
+      {
+        UPDATE_1(prob);
+        if (checkDicSize == 0 &amp;&amp; processedPos == 0)
+          return SZ_ERROR_DATA;
+        prob = probs + IsRepG0 + state;
+        IF_BIT_0(prob)
+        {
+          UPDATE_0(prob);
+          prob = probs + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
+          IF_BIT_0(prob)
+          {
+            UPDATE_0(prob);
+            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
+            dicPos++;
+            processedPos++;
+            state = state &lt; kNumLitStates ? 9 : 11;
+            continue;
+          }
+          UPDATE_1(prob);
+        }
+        else
+        {
+          UInt32 distance;
+          UPDATE_1(prob);
+          prob = probs + IsRepG1 + state;
+          IF_BIT_0(prob)
+          {
+            UPDATE_0(prob);
+            distance = rep1;
+          }
+          else
+          {
+            UPDATE_1(prob);
+            prob = probs + IsRepG2 + state;
+            IF_BIT_0(prob)
+            {
+              UPDATE_0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UPDATE_1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state &lt; kNumLitStates ? 8 : 11;
+        prob = probs + RepLenCoder;
+      }
+      {
+        unsigned limit, offset;
+        CLzmaProb *probLen = prob + LenChoice;
+        IF_BIT_0(probLen)
+        {
+          UPDATE_0(probLen);
+          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
+          offset = 0;
+          limit = (1 &lt;&lt; kLenNumLowBits);
+        }
+        else
+        {
+          UPDATE_1(probLen);
+          probLen = prob + LenChoice2;
+          IF_BIT_0(probLen)
+          {
+            UPDATE_0(probLen);
+            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            limit = (1 &lt;&lt; kLenNumMidBits);
+          }
+          else
+          {
+            UPDATE_1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            limit = (1 &lt;&lt; kLenNumHighBits);
+          }
+        }
+        TREE_DECODE(probLen, limit, len);
+        len += offset;
+      }
+
+      if (state &gt;= kNumStates)
+      {
+        UInt32 distance;
+        prob = probs + PosSlot +
+            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt; kNumPosSlotBits);
+        TREE_6_DECODE(prob, distance);
+        if (distance &gt;= kStartPosModelIndex)
+        {
+          unsigned posSlot = (unsigned)distance;
+          int numDirectBits = (int)(((distance &gt;&gt; 1) - 1));
+          distance = (2 | (distance &amp; 1));
+          if (posSlot &lt; kEndPosModelIndex)
+          {
+            distance &lt;&lt;= numDirectBits;
+            prob = probs + SpecPos + distance - posSlot - 1;
+            {
+              UInt32 mask = 1;
+              unsigned i = 1;
+              do
+              {
+                GET_BIT2(prob + i, i, ; , distance |= mask);
+                mask &lt;&lt;= 1;
+              }
+              while (--numDirectBits != 0);
+            }
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              NORMALIZE
+              range &gt;&gt;= 1;
+              
+              {
+                UInt32 t;
+                code -= range;
+                t = (0 - ((UInt32)code &gt;&gt; 31)); /* (UInt32)((Int32)code &gt;&gt; 31) */
+                distance = (distance &lt;&lt; 1) + (t + 1);
+                code += range &amp; t;
+              }
+              /*
+              distance &lt;&lt;= 1;
+              if (code &gt;= range)
+              {
+                code -= range;
+                distance |= 1;
+              }
+              */
+            }
+            while (--numDirectBits != 0);
+            prob = probs + Align;
+            distance &lt;&lt;= kNumAlignBits;
+            {
+              unsigned i = 1;
+              GET_BIT2(prob + i, i, ; , distance |= 1);
+              GET_BIT2(prob + i, i, ; , distance |= 2);
+              GET_BIT2(prob + i, i, ; , distance |= 4);
+              GET_BIT2(prob + i, i, ; , distance |= 8);
+            }
+            if (distance == (UInt32)0xFFFFFFFF)
+            {
+              len += kMatchSpecLenStart;
+              state -= kNumStates;
+              break;
+            }
+          }
+        }
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        rep0 = distance + 1;
+        if (checkDicSize == 0)
+        {
+          if (distance &gt;= processedPos)
+            return SZ_ERROR_DATA;
+        }
+        else if (distance &gt;= checkDicSize)
+          return SZ_ERROR_DATA;
+        state = (state &lt; kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
+        /* state = kLiteralNextStates[state]; */
+      }
+
+      len += kMatchMinLen;
+
+      {
+        SizeT rem = limit - dicPos;
+        unsigned curLen = ((rem &lt; len) ? (unsigned)rem : len);
+        SizeT pos = (dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0);
+
+        processedPos += curLen;
+
+        len -= curLen;
+        if (pos + curLen &lt;= dicBufSize)
+        {
+          Byte *dest = dic + dicPos;
+          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
+          const Byte *lim = dest + curLen;
+          dicPos += curLen;
+          do
+            *(dest) = (Byte)*(dest + src);
+          while (++dest != lim);
+        }
+        else
+        {
+          do
+          {
+            dic[dicPos++] = dic[pos];
+            if (++pos == dicBufSize)
+              pos = 0;
+          }
+          while (--curLen != 0);
+        }
+      }
+    }
+  }
+  while (dicPos &lt; limit &amp;&amp; buf &lt; bufLimit);
+  NORMALIZE;
+  p-&gt;buf = buf;
+  p-&gt;range = range;
+  p-&gt;code = code;
+  p-&gt;remainLen = len;
+  p-&gt;dicPos = dicPos;
+  p-&gt;processedPos = processedPos;
+  p-&gt;reps[0] = rep0;
+  p-&gt;reps[1] = rep1;
+  p-&gt;reps[2] = rep2;
+  p-&gt;reps[3] = rep3;
+  p-&gt;state = state;
+
+  return SZ_OK;
+}
+
+static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
+{
+  if (p-&gt;remainLen != 0 &amp;&amp; p-&gt;remainLen &lt; kMatchSpecLenStart)
+  {
+    Byte *dic = p-&gt;dic;
+    SizeT dicPos = p-&gt;dicPos;
+    SizeT dicBufSize = p-&gt;dicBufSize;
+    unsigned len = p-&gt;remainLen;
+    UInt32 rep0 = p-&gt;reps[0];
+    if (limit - dicPos &lt; len)
+      len = (unsigned)(limit - dicPos);
+
+    if (p-&gt;checkDicSize == 0 &amp;&amp; p-&gt;prop.dicSize - p-&gt;processedPos &lt;= len)
+      p-&gt;checkDicSize = p-&gt;prop.dicSize;
+
+    p-&gt;processedPos += len;
+    p-&gt;remainLen -= len;
+    while (len-- != 0)
+    {
+      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
+      dicPos++;
+    }
+    p-&gt;dicPos = dicPos;
+  }
+}
+
+/* LzmaDec_DecodeReal2 decodes LZMA-symbols and sets p-&gt;needFlush and p-&gt;needInit, if required. */
+
+static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+{
+  do
+  {
+    SizeT limit2 = limit;
+    if (p-&gt;checkDicSize == 0)
+    {
+      UInt32 rem = p-&gt;prop.dicSize - p-&gt;processedPos;
+      if (limit - p-&gt;dicPos &gt; rem)
+        limit2 = p-&gt;dicPos + rem;
+    }
+    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
+    if (p-&gt;processedPos &gt;= p-&gt;prop.dicSize)
+      p-&gt;checkDicSize = p-&gt;prop.dicSize;
+    LzmaDec_WriteRem(p, limit);
+  }
+  while (p-&gt;dicPos &lt; limit &amp;&amp; p-&gt;buf &lt; bufLimit &amp;&amp; p-&gt;remainLen &lt; kMatchSpecLenStart);
+
+  if (p-&gt;remainLen &gt; kMatchSpecLenStart)
+  {
+    p-&gt;remainLen = kMatchSpecLenStart;
+  }
+  return 0;
+}
+
+typedef enum
+{
+  DUMMY_ERROR, /* unexpected end of input stream */
+  DUMMY_LIT,
+  DUMMY_MATCH,
+  DUMMY_REP
+} ELzmaDummy;
+
+static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
+{
+  UInt32 range = p-&gt;range;
+  UInt32 code = p-&gt;code;
+  const Byte *bufLimit = buf + inSize;
+  CLzmaProb *probs = p-&gt;probs;
+  unsigned state = p-&gt;state;
+  ELzmaDummy res;
+
+  {
+    CLzmaProb *prob;
+    UInt32 bound;
+    unsigned ttt;
+    unsigned posState = (p-&gt;processedPos) &amp; ((1 &lt;&lt; p-&gt;prop.pb) - 1);
+
+    prob = probs + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
+    IF_BIT_0_CHECK(prob)
+    {
+      UPDATE_0_CHECK
+
+      /* if (bufLimit - buf &gt;= 7) return DUMMY_LIT; */
+
+      prob = probs + Literal;
+      if (p-&gt;checkDicSize != 0 || p-&gt;processedPos != 0)
+        prob += (LZMA_LIT_SIZE *
+          ((((p-&gt;processedPos) &amp; ((1 &lt;&lt; (p-&gt;prop.lp)) - 1)) &lt;&lt; p-&gt;prop.lc) +
+          (p-&gt;dic[(p-&gt;dicPos == 0 ? p-&gt;dicBufSize : p-&gt;dicPos) - 1] &gt;&gt; (8 - p-&gt;prop.lc))));
+
+      if (state &lt; kNumLitStates)
+      {
+        unsigned symbol = 1;
+        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol &lt; 0x100);
+      }
+      else
+      {
+        unsigned matchByte = p-&gt;dic[p-&gt;dicPos - p-&gt;reps[0] +
+            ((p-&gt;dicPos &lt; p-&gt;reps[0]) ? p-&gt;dicBufSize : 0)];
+        unsigned offs = 0x100;
+        unsigned symbol = 1;
+        do
+        {
+          unsigned bit;
+          CLzmaProb *probLit;
+          matchByte &lt;&lt;= 1;
+          bit = (matchByte &amp; offs);
+          probLit = prob + offs + bit + symbol;
+          GET_BIT2_CHECK(probLit, symbol, offs &amp;= ~bit, offs &amp;= bit)
+        }
+        while (symbol &lt; 0x100);
+      }
+      res = DUMMY_LIT;
+    }
+    else
+    {
+      unsigned len;
+      UPDATE_1_CHECK;
+
+      prob = probs + IsRep + state;
+      IF_BIT_0_CHECK(prob)
+      {
+        UPDATE_0_CHECK;
+        state = 0;
+        prob = probs + LenCoder;
+        res = DUMMY_MATCH;
+      }
+      else
+      {
+        UPDATE_1_CHECK;
+        res = DUMMY_REP;
+        prob = probs + IsRepG0 + state;
+        IF_BIT_0_CHECK(prob)
+        {
+          UPDATE_0_CHECK;
+          prob = probs + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
+          IF_BIT_0_CHECK(prob)
+          {
+            UPDATE_0_CHECK;
+            NORMALIZE_CHECK;
+            return DUMMY_REP;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+          }
+        }
+        else
+        {
+          UPDATE_1_CHECK;
+          prob = probs + IsRepG1 + state;
+          IF_BIT_0_CHECK(prob)
+          {
+            UPDATE_0_CHECK;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+            prob = probs + IsRepG2 + state;
+            IF_BIT_0_CHECK(prob)
+            {
+              UPDATE_0_CHECK;
+            }
+            else
+            {
+              UPDATE_1_CHECK;
+            }
+          }
+        }
+        state = kNumStates;
+        prob = probs + RepLenCoder;
+      }
+      {
+        unsigned limit, offset;
+        CLzmaProb *probLen = prob + LenChoice;
+        IF_BIT_0_CHECK(probLen)
+        {
+          UPDATE_0_CHECK;
+          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
+          offset = 0;
+          limit = 1 &lt;&lt; kLenNumLowBits;
+        }
+        else
+        {
+          UPDATE_1_CHECK;
+          probLen = prob + LenChoice2;
+          IF_BIT_0_CHECK(probLen)
+          {
+            UPDATE_0_CHECK;
+            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            limit = 1 &lt;&lt; kLenNumMidBits;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            limit = 1 &lt;&lt; kLenNumHighBits;
+          }
+        }
+        TREE_DECODE_CHECK(probLen, limit, len);
+        len += offset;
+      }
+
+      if (state &lt; 4)
+      {
+        unsigned posSlot;
+        prob = probs + PosSlot +
+            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt;
+            kNumPosSlotBits);
+        TREE_DECODE_CHECK(prob, 1 &lt;&lt; kNumPosSlotBits, posSlot);
+        if (posSlot &gt;= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot &gt;&gt; 1) - 1);
+
+          /* if (bufLimit - buf &gt;= 8) return DUMMY_MATCH; */
+
+          if (posSlot &lt; kEndPosModelIndex)
+          {
+            prob = probs + SpecPos + ((2 | (posSlot &amp; 1)) &lt;&lt; numDirectBits) - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              NORMALIZE_CHECK
+              range &gt;&gt;= 1;
+              code -= range &amp; (((code - range) &gt;&gt; 31) - 1);
+              /* if (code &gt;= range) code -= range; */
+            }
+            while (--numDirectBits != 0);
+            prob = probs + Align;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            unsigned i = 1;
+            do
+            {
+              GET_BIT_CHECK(prob + i, i);
+            }
+            while (--numDirectBits != 0);
+          }
+        }
+      }
+    }
+  }
+  NORMALIZE_CHECK;
+  return res;
+}
+
+
+static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
+{
+  p-&gt;code = ((UInt32)data[1] &lt;&lt; 24) | ((UInt32)data[2] &lt;&lt; 16) | ((UInt32)data[3] &lt;&lt; 8) | ((UInt32)data[4]);
+  p-&gt;range = 0xFFFFFFFF;
+  p-&gt;needFlush = 0;
+}
+
+void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
+{
+  p-&gt;needFlush = 1;
+  p-&gt;remainLen = 0;
+  p-&gt;tempBufSize = 0;
+
+  if (initDic)
+  {
+    p-&gt;processedPos = 0;
+    p-&gt;checkDicSize = 0;
+    p-&gt;needInitState = 1;
+  }
+  if (initState)
+    p-&gt;needInitState = 1;
+}
+
+void LzmaDec_Init(CLzmaDec *p)
+{
+  p-&gt;dicPos = 0;
+  LzmaDec_InitDicAndState(p, True, True);
+}
+
+static void LzmaDec_InitStateReal(CLzmaDec *p)
+{
+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (p-&gt;prop.lc + p-&gt;prop.lp));
+  UInt32 i;
+  CLzmaProb *probs = p-&gt;probs;
+  for (i = 0; i &lt; numProbs; i++)
+    probs[i] = kBitModelTotal &gt;&gt; 1;
+  p-&gt;reps[0] = p-&gt;reps[1] = p-&gt;reps[2] = p-&gt;reps[3] = 1;
+  p-&gt;state = 0;
+  p-&gt;needInitState = 0;
+}
+
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
+    ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT inSize = *srcLen;
+  (*srcLen) = 0;
+  LzmaDec_WriteRem(p, dicLimit);
+  
+  *status = LZMA_STATUS_NOT_SPECIFIED;
+
+  while (p-&gt;remainLen != kMatchSpecLenStart)
+  {
+      int checkEndMarkNow;
+
+      if (p-&gt;needFlush != 0)
+      {
+        for (; inSize &gt; 0 &amp;&amp; p-&gt;tempBufSize &lt; RC_INIT_SIZE; (*srcLen)++, inSize--)
+          p-&gt;tempBuf[p-&gt;tempBufSize++] = *src++;
+        if (p-&gt;tempBufSize &lt; RC_INIT_SIZE)
+        {
+          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+          return SZ_OK;
+        }
+        if (p-&gt;tempBuf[0] != 0)
+          return SZ_ERROR_DATA;
+
+        LzmaDec_InitRc(p, p-&gt;tempBuf);
+        p-&gt;tempBufSize = 0;
+      }
+
+      checkEndMarkNow = 0;
+      if (p-&gt;dicPos &gt;= dicLimit)
+      {
+        if (p-&gt;remainLen == 0 &amp;&amp; p-&gt;code == 0)
+        {
+          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
+          return SZ_OK;
+        }
+        if (finishMode == LZMA_FINISH_ANY)
+        {
+          *status = LZMA_STATUS_NOT_FINISHED;
+          return SZ_OK;
+        }
+        if (p-&gt;remainLen != 0)
+        {
+          *status = LZMA_STATUS_NOT_FINISHED;
+          return SZ_ERROR_DATA;
+        }
+        checkEndMarkNow = 1;
+      }
+
+      if (p-&gt;needInitState)
+        LzmaDec_InitStateReal(p);
+  
+      if (p-&gt;tempBufSize == 0)
+      {
+        SizeT processed;
+        const Byte *bufLimit;
+        if (inSize &lt; LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
+        {
+          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
+          if (dummyRes == DUMMY_ERROR)
+          {
+            memcpy(p-&gt;tempBuf, src, inSize);
+            p-&gt;tempBufSize = (unsigned)inSize;
+            (*srcLen) += inSize;
+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+            return SZ_OK;
+          }
+          if (checkEndMarkNow &amp;&amp; dummyRes != DUMMY_MATCH)
+          {
+            *status = LZMA_STATUS_NOT_FINISHED;
+            return SZ_ERROR_DATA;
+          }
+          bufLimit = src;
+        }
+        else
+          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
+        p-&gt;buf = src;
+        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
+          return SZ_ERROR_DATA;
+        processed = p-&gt;buf - src;
+        (*srcLen) += processed;
+        src += processed;
+        inSize -= processed;
+      }
+      else
+      {
+        unsigned rem = p-&gt;tempBufSize, lookAhead = 0;
+        while (rem &lt; LZMA_REQUIRED_INPUT_MAX &amp;&amp; lookAhead &lt; inSize)
+          p-&gt;tempBuf[rem++] = src[lookAhead++];
+        p-&gt;tempBufSize = rem;
+        if (rem &lt; LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
+        {
+          int dummyRes = LzmaDec_TryDummy(p, p-&gt;tempBuf, rem);
+          if (dummyRes == DUMMY_ERROR)
+          {
+            (*srcLen) += lookAhead;
+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+            return SZ_OK;
+          }
+          if (checkEndMarkNow &amp;&amp; dummyRes != DUMMY_MATCH)
+          {
+            *status = LZMA_STATUS_NOT_FINISHED;
+            return SZ_ERROR_DATA;
+          }
+        }
+        p-&gt;buf = p-&gt;tempBuf;
+        if (LzmaDec_DecodeReal2(p, dicLimit, p-&gt;buf) != 0)
+          return SZ_ERROR_DATA;
+        lookAhead -= (rem - (unsigned)(p-&gt;buf - p-&gt;tempBuf));
+        (*srcLen) += lookAhead;
+        src += lookAhead;
+        inSize -= lookAhead;
+        p-&gt;tempBufSize = 0;
+      }
+  }
+  if (p-&gt;code == 0)
+    *status = LZMA_STATUS_FINISHED_WITH_MARK;
+  return (p-&gt;code == 0) ? SZ_OK : SZ_ERROR_DATA;
+}
+
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT outSize = *destLen;
+  SizeT inSize = *srcLen;
+  *srcLen = *destLen = 0;
+  for (;;)
+  {
+    SizeT inSizeCur = inSize, outSizeCur, dicPos;
+    ELzmaFinishMode curFinishMode;
+    SRes res;
+    if (p-&gt;dicPos == p-&gt;dicBufSize)
+      p-&gt;dicPos = 0;
+    dicPos = p-&gt;dicPos;
+    if (outSize &gt; p-&gt;dicBufSize - dicPos)
+    {
+      outSizeCur = p-&gt;dicBufSize;
+      curFinishMode = LZMA_FINISH_ANY;
+    }
+    else
+    {
+      outSizeCur = dicPos + outSize;
+      curFinishMode = finishMode;
+    }
+
+    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &amp;inSizeCur, curFinishMode, status);
+    src += inSizeCur;
+    inSize -= inSizeCur;
+    *srcLen += inSizeCur;
+    outSizeCur = p-&gt;dicPos - dicPos;
+    memcpy(dest, p-&gt;dic + dicPos, outSizeCur);
+    dest += outSizeCur;
+    outSize -= outSizeCur;
+    *destLen += outSizeCur;
+    if (res != 0)
+      return res;
+    if (outSizeCur == 0 || outSize == 0)
+      return SZ_OK;
+  }
+}
+
+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;probs);
+  p-&gt;probs = 0;
+}
+
+static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;dic);
+  p-&gt;dic = 0;
+}
+
+void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
+{
+  LzmaDec_FreeProbs(p, alloc);
+  LzmaDec_FreeDict(p, alloc);
+}
+
+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
+{
+  UInt32 dicSize;
+  Byte d;
+  
+  if (size &lt; LZMA_PROPS_SIZE)
+    return SZ_ERROR_UNSUPPORTED;
+  else
+    dicSize = data[1] | ((UInt32)data[2] &lt;&lt; 8) | ((UInt32)data[3] &lt;&lt; 16) | ((UInt32)data[4] &lt;&lt; 24);
+ 
+  if (dicSize &lt; LZMA_DIC_MIN)
+    dicSize = LZMA_DIC_MIN;
+  p-&gt;dicSize = dicSize;
+
+  d = data[0];
+  if (d &gt;= (9 * 5 * 5))
+    return SZ_ERROR_UNSUPPORTED;
+
+  p-&gt;lc = d % 9;
+  d /= 9;
+  p-&gt;pb = d / 5;
+  p-&gt;lp = d % 5;
+
+  return SZ_OK;
+}
+
+static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
+{
+  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
+  if (p-&gt;probs == 0 || numProbs != p-&gt;numProbs)
+  {
+    LzmaDec_FreeProbs(p, alloc);
+    p-&gt;probs = (CLzmaProb *)alloc-&gt;Alloc(alloc, numProbs * sizeof(CLzmaProb));
+    p-&gt;numProbs = numProbs;
+    if (p-&gt;probs == 0)
+      return SZ_ERROR_MEM;
+  }
+  return SZ_OK;
+}
+
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+{
+  CLzmaProps propNew;
+  RINOK(LzmaProps_Decode(&amp;propNew, props, propsSize));
+  RINOK(LzmaDec_AllocateProbs2(p, &amp;propNew, alloc));
+  p-&gt;prop = propNew;
+  return SZ_OK;
+}
+
+SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+{
+  CLzmaProps propNew;
+  SizeT dicBufSize;
+  RINOK(LzmaProps_Decode(&amp;propNew, props, propsSize));
+  RINOK(LzmaDec_AllocateProbs2(p, &amp;propNew, alloc));
+  dicBufSize = propNew.dicSize;
+  if (p-&gt;dic == 0 || dicBufSize != p-&gt;dicBufSize)
+  {
+    LzmaDec_FreeDict(p, alloc);
+    p-&gt;dic = (Byte *)alloc-&gt;Alloc(alloc, dicBufSize);
+    if (p-&gt;dic == 0)
+    {
+      LzmaDec_FreeProbs(p, alloc);
+      return SZ_ERROR_MEM;
+    }
+  }
+  p-&gt;dicBufSize = dicBufSize;
+  p-&gt;prop = propNew;
+  return SZ_OK;
+}
+
+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+    ELzmaStatus *status, ISzAlloc *alloc)
+{
+  CLzmaDec p;
+  SRes res;
+  SizeT inSize = *srcLen;
+  SizeT outSize = *destLen;
+  *srcLen = *destLen = 0;
+  if (inSize &lt; RC_INIT_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+
+  LzmaDec_Construct(&amp;p);
+  res = LzmaDec_AllocateProbs(&amp;p, propData, propSize, alloc);
+  if (res != 0)
+    return res;
+  p.dic = dest;
+  p.dicBufSize = outSize;
+
+  LzmaDec_Init(&amp;p);
+  
+  *srcLen = inSize;
+  res = LzmaDec_DecodeToDic(&amp;p, outSize, src, srcLen, finishMode, status);
+
+  if (res == SZ_OK &amp;&amp; *status == LZMA_STATUS_NEEDS_MORE_INPUT)
+    res = SZ_ERROR_INPUT_EOF;
+
+  (*destLen) = p.dicPos;
+  LzmaDec_FreeProbs(&amp;p, alloc);
+  return res;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,232 +0,0 @@
-/* LzmaDec.h -- LZMA Decoder
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-You can use any of the following license options:
-  1) GNU Lesser General Public License (GNU LGPL)
-  2) Common Public License (CPL)
-  3) Common Development and Distribution License (CDDL) Version 1.0
-  4) Igor Pavlov, as the author of this code, expressly permits you to
-     statically or dynamically link your code (or bind by name) to this file,
-     while you keep this file unmodified.
-*/
-
-#ifndef __LZMADEC_H
-#define __LZMADEC_H
-
-#include &quot;Types.h&quot;
-
-/* #define _LZMA_PROB32 */
-/* _LZMA_PROB32 can increase the speed on some CPUs,
-   but memory usage for CLzmaDec::probs will be doubled in that case */
-
-#ifdef _LZMA_PROB32
-#define CLzmaProb UInt32
-#else
-#define CLzmaProb UInt16
-#endif
-
-
-/* ---------- LZMA Properties ---------- */
-
-#define LZMA_PROPS_SIZE 5
-
-typedef struct _CLzmaProps
-{
-  unsigned lc, lp, pb;
-  UInt32 dicSize;
-} CLzmaProps;
-
-/* LzmaProps_Decode - decodes properties
-Returns:
-  SZ_OK
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-*/
-
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
-
-
-/* ---------- LZMA Decoder state ---------- */
-
-/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
-   Num bits = log2((2^11 / 31) ^ 22) + 26 &lt; 134 + 26 = 160; */
-
-#define LZMA_REQUIRED_INPUT_MAX 20
-
-typedef struct
-{
-  CLzmaProps prop;
-  CLzmaProb *probs;
-  Byte *dic;
-  const Byte *buf;
-  UInt32 range, code;
-  SizeT dicPos;
-  SizeT dicBufSize;
-  UInt32 processedPos;
-  UInt32 checkDicSize;
-  unsigned state;
-  UInt32 reps[4];
-  unsigned remainLen;
-  int needFlush;
-  int needInitState;
-  UInt32 numProbs;
-  unsigned tempBufSize;
-  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
-} CLzmaDec;
-
-#define LzmaDec_Construct(p) { (p)-&gt;dic = 0; (p)-&gt;probs = 0; }
-
-void LzmaDec_Init(CLzmaDec *p);
-
-/* There are two types of LZMA streams:
-     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-
-typedef enum
-{
-  LZMA_FINISH_ANY,   /* finish at any point */
-  LZMA_FINISH_END    /* block must be finished at the end */
-} ELzmaFinishMode;
-
-/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
-
-   You must use LZMA_FINISH_END, when you know that current output buffer
-   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
-
-   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
-   and output value of destLen will be less than output buffer size limit.
-   You can check status result also.
-
-   You can use multiple checks to test data integrity after full decompression:
-     1) Check Result and &quot;status&quot; variable.
-     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
-     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
-        You must use correct finish mode in that case. */
-
-typedef enum
-{
-  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
-  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
-  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
-  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
-  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
-} ELzmaStatus;
-
-/* ELzmaStatus is used only as output value for function call */
-
-
-/* ---------- Interfaces ---------- */
-
-/* There are 3 levels of interfaces:
-     1) Dictionary Interface
-     2) Buffer Interface
-     3) One Call Interface
-   You can select any of these interfaces, but don't mix functions from different
-   groups for same object. */
-
-
-/* There are two variants to allocate state for Dictionary Interface:
-     1) LzmaDec_Allocate / LzmaDec_Free
-     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
-   You can use variant 2, if you set dictionary buffer manually.
-   For Buffer Interface you must always use variant 1.
-
-LzmaDec_Allocate* can return:
-  SZ_OK
-  SZ_ERROR_MEM         - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-*/
-   
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
-
-SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
-void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
-
-/* ---------- Dictionary Interface ---------- */
-
-/* You can use it, if you want to eliminate the overhead for data copying from
-   dictionary to some other external buffer.
-   You must work with CLzmaDec variables directly in this interface.
-
-   STEPS:
-     LzmaDec_Constr()
-     LzmaDec_Allocate()
-     for (each new stream)
-     {
-       LzmaDec_Init()
-       while (it needs more decompression)
-       {
-         LzmaDec_DecodeToDic()
-         use data from CLzmaDec::dic and update CLzmaDec::dicPos
-       }
-     }
-     LzmaDec_Free()
-*/
-
-/* LzmaDec_DecodeToDic
-   
-   The decoding to internal dictionary buffer (CLzmaDec::dic).
-   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (dicLimit).
-  LZMA_FINISH_ANY - Decode just dicLimit bytes.
-  LZMA_FINISH_END - Stream must be finished after dicLimit.
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_NEEDS_MORE_INPUT
-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-  SZ_ERROR_DATA - Data error
-*/
-
-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- Buffer Interface ---------- */
-
-/* It's zlib-like interface.
-   See LzmaDec_DecodeToDic description for information about STEPS and return results,
-   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
-   to work with CLzmaDec variables manually.
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - Decode just destLen bytes.
-  LZMA_FINISH_END - Stream must be finished after (*destLen).
-*/
-
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- One Call Interface ---------- */
-
-/* LzmaDecode
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - Decode just destLen bytes.
-  LZMA_FINISH_END - Stream must be finished after (*destLen).
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-  SZ_ERROR_DATA - Data error
-  SZ_ERROR_MEM  - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
-*/
-
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-    ELzmaStatus *status, ISzAlloc *alloc);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaDec.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,232 @@
+/* LzmaDec.h -- LZMA Decoder
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+You can use any of the following license options:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  3) Common Development and Distribution License (CDDL) Version 1.0
+  4) Igor Pavlov, as the author of this code, expressly permits you to
+     statically or dynamically link your code (or bind by name) to this file,
+     while you keep this file unmodified.
+*/
+
+#ifndef __LZMADEC_H
+#define __LZMADEC_H
+
+#include &quot;Types.h&quot;
+
+/* #define _LZMA_PROB32 */
+/* _LZMA_PROB32 can increase the speed on some CPUs,
+   but memory usage for CLzmaDec::probs will be doubled in that case */
+
+#ifdef _LZMA_PROB32
+#define CLzmaProb UInt32
+#else
+#define CLzmaProb UInt16
+#endif
+
+
+/* ---------- LZMA Properties ---------- */
+
+#define LZMA_PROPS_SIZE 5
+
+typedef struct _CLzmaProps
+{
+  unsigned lc, lp, pb;
+  UInt32 dicSize;
+} CLzmaProps;
+
+/* LzmaProps_Decode - decodes properties
+Returns:
+  SZ_OK
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+*/
+
+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
+
+
+/* ---------- LZMA Decoder state ---------- */
+
+/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
+   Num bits = log2((2^11 / 31) ^ 22) + 26 &lt; 134 + 26 = 160; */
+
+#define LZMA_REQUIRED_INPUT_MAX 20
+
+typedef struct
+{
+  CLzmaProps prop;
+  CLzmaProb *probs;
+  Byte *dic;
+  const Byte *buf;
+  UInt32 range, code;
+  SizeT dicPos;
+  SizeT dicBufSize;
+  UInt32 processedPos;
+  UInt32 checkDicSize;
+  unsigned state;
+  UInt32 reps[4];
+  unsigned remainLen;
+  int needFlush;
+  int needInitState;
+  UInt32 numProbs;
+  unsigned tempBufSize;
+  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
+} CLzmaDec;
+
+#define LzmaDec_Construct(p) { (p)-&gt;dic = 0; (p)-&gt;probs = 0; }
+
+void LzmaDec_Init(CLzmaDec *p);
+
+/* There are two types of LZMA streams:
+     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
+     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
+
+typedef enum
+{
+  LZMA_FINISH_ANY,   /* finish at any point */
+  LZMA_FINISH_END    /* block must be finished at the end */
+} ELzmaFinishMode;
+
+/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
+
+   You must use LZMA_FINISH_END, when you know that current output buffer
+   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
+
+   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
+   and output value of destLen will be less than output buffer size limit.
+   You can check status result also.
+
+   You can use multiple checks to test data integrity after full decompression:
+     1) Check Result and &quot;status&quot; variable.
+     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
+     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
+        You must use correct finish mode in that case. */
+
+typedef enum
+{
+  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
+  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
+  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
+  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
+  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
+} ELzmaStatus;
+
+/* ELzmaStatus is used only as output value for function call */
+
+
+/* ---------- Interfaces ---------- */
+
+/* There are 3 levels of interfaces:
+     1) Dictionary Interface
+     2) Buffer Interface
+     3) One Call Interface
+   You can select any of these interfaces, but don't mix functions from different
+   groups for same object. */
+
+
+/* There are two variants to allocate state for Dictionary Interface:
+     1) LzmaDec_Allocate / LzmaDec_Free
+     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
+   You can use variant 2, if you set dictionary buffer manually.
+   For Buffer Interface you must always use variant 1.
+
+LzmaDec_Allocate* can return:
+  SZ_OK
+  SZ_ERROR_MEM         - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+*/
+   
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
+
+SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
+void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
+
+/* ---------- Dictionary Interface ---------- */
+
+/* You can use it, if you want to eliminate the overhead for data copying from
+   dictionary to some other external buffer.
+   You must work with CLzmaDec variables directly in this interface.
+
+   STEPS:
+     LzmaDec_Constr()
+     LzmaDec_Allocate()
+     for (each new stream)
+     {
+       LzmaDec_Init()
+       while (it needs more decompression)
+       {
+         LzmaDec_DecodeToDic()
+         use data from CLzmaDec::dic and update CLzmaDec::dicPos
+       }
+     }
+     LzmaDec_Free()
+*/
+
+/* LzmaDec_DecodeToDic
+   
+   The decoding to internal dictionary buffer (CLzmaDec::dic).
+   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (dicLimit).
+  LZMA_FINISH_ANY - Decode just dicLimit bytes.
+  LZMA_FINISH_END - Stream must be finished after dicLimit.
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_NEEDS_MORE_INPUT
+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+  SZ_ERROR_DATA - Data error
+*/
+
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- Buffer Interface ---------- */
+
+/* It's zlib-like interface.
+   See LzmaDec_DecodeToDic description for information about STEPS and return results,
+   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
+   to work with CLzmaDec variables manually.
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - Decode just destLen bytes.
+  LZMA_FINISH_END - Stream must be finished after (*destLen).
+*/
+
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- One Call Interface ---------- */
+
+/* LzmaDecode
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - Decode just destLen bytes.
+  LZMA_FINISH_END - Stream must be finished after (*destLen).
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+  SZ_ERROR_DATA - Data error
+  SZ_ERROR_MEM  - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
+*/
+
+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+    ELzmaStatus *status, ISzAlloc *alloc);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,2275 +0,0 @@
-/* LzmaEnc.c -- LZMA Encoder
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaEnc.h for license options */
-
-#include &lt;string.h&gt;
-
-/* #define SHOW_STAT */
-/* #define SHOW_STAT2 */
-
-#if defined(SHOW_STAT) || defined(SHOW_STAT2)
-#include &lt;stdio.h&gt;
-#endif
-
-#include &quot;LzmaEnc.h&quot;
-
-#include &quot;LzFind.h&quot;
-#ifdef COMPRESS_MF_MT
-#include &quot;LzFindMt.h&quot;
-#endif
-
-#ifdef SHOW_STAT
-static int ttt = 0;
-#endif
-
-#define kBlockSizeMax ((1 &lt;&lt; LZMA_NUM_BLOCK_SIZE_BITS) - 1)
-
-#define kBlockSize (9 &lt;&lt; 10)
-#define kUnpackBlockSize (1 &lt;&lt; 18)
-#define kMatchArraySize (1 &lt;&lt; 21)
-#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
-
-#define kNumMaxDirectBits (31)
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
-#define kNumMoveBits 5
-#define kProbInitValue (kBitModelTotal &gt;&gt; 1)
-
-#define kNumMoveReducingBits 4
-#define kNumBitPriceShiftBits 4
-#define kBitPrice (1 &lt;&lt; kNumBitPriceShiftBits)
-
-void LzmaEncProps_Init(CLzmaEncProps *p)
-{
-  p-&gt;level = 5;
-  p-&gt;dictSize = p-&gt;mc = 0;
-  p-&gt;lc = p-&gt;lp = p-&gt;pb = p-&gt;algo = p-&gt;fb = p-&gt;btMode = p-&gt;numHashBytes = p-&gt;numThreads = -1;
-  p-&gt;writeEndMark = 0;
-}
-
-void LzmaEncProps_Normalize(CLzmaEncProps *p)
-{
-  int level = p-&gt;level;
-  if (level &lt; 0) level = 5;
-  p-&gt;level = level;
-  if (p-&gt;dictSize == 0) p-&gt;dictSize = (level &lt;= 5 ? (1 &lt;&lt; (level * 2 + 14)) : (level == 6 ? (1 &lt;&lt; 25) : (1 &lt;&lt; 26)));
-  if (p-&gt;lc &lt; 0) p-&gt;lc = 3;
-  if (p-&gt;lp &lt; 0) p-&gt;lp = 0;
-  if (p-&gt;pb &lt; 0) p-&gt;pb = 2;
-  if (p-&gt;algo &lt; 0) p-&gt;algo = (level &lt; 5 ? 0 : 1);
-  if (p-&gt;fb &lt; 0) p-&gt;fb = (level &lt; 7 ? 32 : 64);
-  if (p-&gt;btMode &lt; 0) p-&gt;btMode = (p-&gt;algo == 0 ? 0 : 1);
-  if (p-&gt;numHashBytes &lt; 0) p-&gt;numHashBytes = 4;
-  if (p-&gt;mc == 0)  p-&gt;mc = (16 + (p-&gt;fb &gt;&gt; 1)) &gt;&gt; (p-&gt;btMode ? 0 : 1);
-  if (p-&gt;numThreads &lt; 0) p-&gt;numThreads = ((p-&gt;btMode &amp;&amp; p-&gt;algo) ? 2 : 1);
-}
-
-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-{
-  CLzmaEncProps props = *props2;
-  LzmaEncProps_Normalize(&amp;props);
-  return props.dictSize;
-}
-
-/* #define LZMA_LOG_BSR */
-/* Define it for Intel's CPU */
-
-
-#ifdef LZMA_LOG_BSR
-
-#define kDicLogSizeMaxCompress 30
-
-#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&amp;i, (pos)); res = (i + i) + ((pos &gt;&gt; (i - 1)) &amp; 1); }
-
-UInt32 GetPosSlot1(UInt32 pos)
-{
-  UInt32 res;
-  BSR2_RET(pos, res);
-  return res;
-}
-#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-#define GetPosSlot(pos, res) { if (pos &lt; 2) res = pos; else BSR2_RET(pos, res); }
-
-#else
-
-#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
-#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
-
-void LzmaEnc_FastPosInit(Byte *g_FastPos)
-{
-  int c = 2, slotFast;
-  g_FastPos[0] = 0;
-  g_FastPos[1] = 1;
-  
-  for (slotFast = 2; slotFast &lt; kNumLogBits * 2; slotFast++)
-  {
-    UInt32 k = (1 &lt;&lt; ((slotFast &gt;&gt; 1) - 1));
-    UInt32 j;
-    for (j = 0; j &lt; k; j++, c++)
-      g_FastPos[c] = (Byte)slotFast;
-  }
-}
-
-#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) &amp; \
-  (0 - (((((UInt32)1 &lt;&lt; (kNumLogBits + 6)) - 1) - pos) &gt;&gt; 31))); \
-  res = p-&gt;g_FastPos[pos &gt;&gt; i] + (i * 2); }
-/*
-#define BSR2_RET(pos, res) { res = (pos &lt; (1 &lt;&lt; (kNumLogBits + 6))) ? \
-  p-&gt;g_FastPos[pos &gt;&gt; 6] + 12 : \
-  p-&gt;g_FastPos[pos &gt;&gt; (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
-*/
-
-#define GetPosSlot1(pos) p-&gt;g_FastPos[pos]
-#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-#define GetPosSlot(pos, res) { if (pos &lt; kNumFullDistances) res = p-&gt;g_FastPos[pos]; else BSR2_RET(pos, res); }
-
-#endif
-
-
-#define LZMA_NUM_REPS 4
-
-typedef unsigned CState;
-
-typedef struct _COptimal
-{
-  UInt32 price;
-
-  CState state;
-  int prev1IsChar;
-  int prev2;
-
-  UInt32 posPrev2;
-  UInt32 backPrev2;
-
-  UInt32 posPrev;
-  UInt32 backPrev;
-  UInt32 backs[LZMA_NUM_REPS];
-} COptimal;
-
-#define kNumOpts (1 &lt;&lt; 12)
-
-#define kNumLenToPosStates 4
-#define kNumPosSlotBits 6
-#define kDicLogSizeMin 0
-#define kDicLogSizeMax 32
-#define kDistTableSizeMax (kDicLogSizeMax * 2)
-
-
-#define kNumAlignBits 4
-#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
-#define kAlignMask (kAlignTableSize - 1)
-
-#define kStartPosModelIndex 4
-#define kEndPosModelIndex 14
-#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
-
-#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex / 2))
-
-#ifdef _LZMA_PROB32
-#define CLzmaProb UInt32
-#else
-#define CLzmaProb UInt16
-#endif
-
-#define LZMA_PB_MAX 4
-#define LZMA_LC_MAX 8
-#define LZMA_LP_MAX 4
-
-#define LZMA_NUM_PB_STATES_MAX (1 &lt;&lt; LZMA_PB_MAX)
-
-
-#define kLenNumLowBits 3
-#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
-#define kLenNumMidBits 3
-#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
-#define kLenNumHighBits 8
-#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
-
-#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-
-#define LZMA_MATCH_LEN_MIN 2
-#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
-
-#define kNumStates 12
-
-typedef struct
-{
-  CLzmaProb choice;
-  CLzmaProb choice2;
-  CLzmaProb low[LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumLowBits];
-  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumMidBits];
-  CLzmaProb high[kLenNumHighSymbols];
-} CLenEnc;
-
-typedef struct
-{
-  CLenEnc p;
-  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
-  UInt32 tableSize;
-  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
-} CLenPriceEnc;
-
-typedef struct _CRangeEnc
-{
-  UInt32 range;
-  Byte cache;
-  UInt64 low;
-  UInt64 cacheSize;
-  Byte *buf;
-  Byte *bufLim;
-  Byte *bufBase;
-  ISeqOutStream *outStream;
-  UInt64 processed;
-  SRes res;
-} CRangeEnc;
-
-typedef struct _CSeqInStreamBuf
-{
-  ISeqInStream funcTable;
-  const Byte *data;
-  SizeT rem;
-} CSeqInStreamBuf;
-
-static SRes MyRead(void *pp, void *data, size_t *size)
-{
-  size_t curSize = *size;
-  CSeqInStreamBuf *p = (CSeqInStreamBuf *)pp;
-  if (p-&gt;rem &lt; curSize)
-    curSize = p-&gt;rem;
-  memcpy(data, p-&gt;data, curSize);
-  p-&gt;rem -= curSize;
-  p-&gt;data += curSize;
-  *size = curSize;
-  return SZ_OK;
-}
-
-typedef struct
-{
-  CLzmaProb *litProbs;
-
-  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-  CLzmaProb isRep[kNumStates];
-  CLzmaProb isRepG0[kNumStates];
-  CLzmaProb isRepG1[kNumStates];
-  CLzmaProb isRepG2[kNumStates];
-  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-
-  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 &lt;&lt; kNumPosSlotBits];
-  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-  CLzmaProb posAlignEncoder[1 &lt;&lt; kNumAlignBits];
-  
-  CLenPriceEnc lenEnc;
-  CLenPriceEnc repLenEnc;
-
-  UInt32 reps[LZMA_NUM_REPS];
-  UInt32 state;
-} CSaveState;
-
-typedef struct _CLzmaEnc
-{
-  IMatchFinder matchFinder;
-  void *matchFinderObj;
-
-  #ifdef COMPRESS_MF_MT
-  Bool mtMode;
-  CMatchFinderMt matchFinderMt;
-  #endif
-
-  CMatchFinder matchFinderBase;
-
-  #ifdef COMPRESS_MF_MT
-  Byte pad[128];
-  #endif
-  
-  UInt32 optimumEndIndex;
-  UInt32 optimumCurrentIndex;
-
-  UInt32 longestMatchLength;
-  UInt32 numPairs;
-  UInt32 numAvail;
-  COptimal opt[kNumOpts];
-  
-  #ifndef LZMA_LOG_BSR
-  Byte g_FastPos[1 &lt;&lt; kNumLogBits];
-  #endif
-
-  UInt32 ProbPrices[kBitModelTotal &gt;&gt; kNumMoveReducingBits];
-  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
-  UInt32 numFastBytes;
-  UInt32 additionalOffset;
-  UInt32 reps[LZMA_NUM_REPS];
-  UInt32 state;
-
-  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
-  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
-  UInt32 alignPrices[kAlignTableSize];
-  UInt32 alignPriceCount;
-
-  UInt32 distTableSize;
-
-  unsigned lc, lp, pb;
-  unsigned lpMask, pbMask;
-
-  CLzmaProb *litProbs;
-
-  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-  CLzmaProb isRep[kNumStates];
-  CLzmaProb isRepG0[kNumStates];
-  CLzmaProb isRepG1[kNumStates];
-  CLzmaProb isRepG2[kNumStates];
-  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-
-  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 &lt;&lt; kNumPosSlotBits];
-  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-  CLzmaProb posAlignEncoder[1 &lt;&lt; kNumAlignBits];
-  
-  CLenPriceEnc lenEnc;
-  CLenPriceEnc repLenEnc;
-
-  unsigned lclp;
-
-  Bool fastMode;
-  
-  CRangeEnc rc;
-
-  Bool writeEndMark;
-  UInt64 nowPos64;
-  UInt32 matchPriceCount;
-  Bool finished;
-  Bool multiThread;
-
-  SRes result;
-  UInt32 dictSize;
-  UInt32 matchFinderCycles;
-
-  ISeqInStream *inStream;
-  CSeqInStreamBuf seqBufInStream;
-
-  CSaveState saveState;
-} CLzmaEnc;
-
-void LzmaEnc_SaveState(CLzmaEncHandle pp)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  CSaveState *dest = &amp;p-&gt;saveState;
-  int i;
-  dest-&gt;lenEnc = p-&gt;lenEnc;
-  dest-&gt;repLenEnc = p-&gt;repLenEnc;
-  dest-&gt;state = p-&gt;state;
-
-  for (i = 0; i &lt; kNumStates; i++)
-  {
-    memcpy(dest-&gt;isMatch[i], p-&gt;isMatch[i], sizeof(p-&gt;isMatch[i]));
-    memcpy(dest-&gt;isRep0Long[i], p-&gt;isRep0Long[i], sizeof(p-&gt;isRep0Long[i]));
-  }
-  for (i = 0; i &lt; kNumLenToPosStates; i++)
-    memcpy(dest-&gt;posSlotEncoder[i], p-&gt;posSlotEncoder[i], sizeof(p-&gt;posSlotEncoder[i]));
-  memcpy(dest-&gt;isRep, p-&gt;isRep, sizeof(p-&gt;isRep));
-  memcpy(dest-&gt;isRepG0, p-&gt;isRepG0, sizeof(p-&gt;isRepG0));
-  memcpy(dest-&gt;isRepG1, p-&gt;isRepG1, sizeof(p-&gt;isRepG1));
-  memcpy(dest-&gt;isRepG2, p-&gt;isRepG2, sizeof(p-&gt;isRepG2));
-  memcpy(dest-&gt;posEncoders, p-&gt;posEncoders, sizeof(p-&gt;posEncoders));
-  memcpy(dest-&gt;posAlignEncoder, p-&gt;posAlignEncoder, sizeof(p-&gt;posAlignEncoder));
-  memcpy(dest-&gt;reps, p-&gt;reps, sizeof(p-&gt;reps));
-  memcpy(dest-&gt;litProbs, p-&gt;litProbs, (0x300 &lt;&lt; p-&gt;lclp) * sizeof(CLzmaProb));
-}
-
-void LzmaEnc_RestoreState(CLzmaEncHandle pp)
-{
-  CLzmaEnc *dest = (CLzmaEnc *)pp;
-  const CSaveState *p = &amp;dest-&gt;saveState;
-  int i;
-  dest-&gt;lenEnc = p-&gt;lenEnc;
-  dest-&gt;repLenEnc = p-&gt;repLenEnc;
-  dest-&gt;state = p-&gt;state;
-
-  for (i = 0; i &lt; kNumStates; i++)
-  {
-    memcpy(dest-&gt;isMatch[i], p-&gt;isMatch[i], sizeof(p-&gt;isMatch[i]));
-    memcpy(dest-&gt;isRep0Long[i], p-&gt;isRep0Long[i], sizeof(p-&gt;isRep0Long[i]));
-  }
-  for (i = 0; i &lt; kNumLenToPosStates; i++)
-    memcpy(dest-&gt;posSlotEncoder[i], p-&gt;posSlotEncoder[i], sizeof(p-&gt;posSlotEncoder[i]));
-  memcpy(dest-&gt;isRep, p-&gt;isRep, sizeof(p-&gt;isRep));
-  memcpy(dest-&gt;isRepG0, p-&gt;isRepG0, sizeof(p-&gt;isRepG0));
-  memcpy(dest-&gt;isRepG1, p-&gt;isRepG1, sizeof(p-&gt;isRepG1));
-  memcpy(dest-&gt;isRepG2, p-&gt;isRepG2, sizeof(p-&gt;isRepG2));
-  memcpy(dest-&gt;posEncoders, p-&gt;posEncoders, sizeof(p-&gt;posEncoders));
-  memcpy(dest-&gt;posAlignEncoder, p-&gt;posAlignEncoder, sizeof(p-&gt;posAlignEncoder));
-  memcpy(dest-&gt;reps, p-&gt;reps, sizeof(p-&gt;reps));
-  memcpy(dest-&gt;litProbs, p-&gt;litProbs, (0x300 &lt;&lt; dest-&gt;lclp) * sizeof(CLzmaProb));
-}
-
-SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  CLzmaEncProps props = *props2;
-  LzmaEncProps_Normalize(&amp;props);
-
-  if (props.lc &gt; LZMA_LC_MAX || props.lp &gt; LZMA_LP_MAX || props.pb &gt; LZMA_PB_MAX ||
-      props.dictSize &gt; (1 &lt;&lt; kDicLogSizeMaxCompress) || props.dictSize &gt; (1 &lt;&lt; 30))
-    return SZ_ERROR_PARAM;
-  p-&gt;dictSize = props.dictSize;
-  p-&gt;matchFinderCycles = props.mc;
-  {
-    unsigned fb = props.fb;
-    if (fb &lt; 5)
-      fb = 5;
-    if (fb &gt; LZMA_MATCH_LEN_MAX)
-      fb = LZMA_MATCH_LEN_MAX;
-    p-&gt;numFastBytes = fb;
-  }
-  p-&gt;lc = props.lc;
-  p-&gt;lp = props.lp;
-  p-&gt;pb = props.pb;
-  p-&gt;fastMode = (props.algo == 0);
-  p-&gt;matchFinderBase.btMode = props.btMode;
-  {
-    UInt32 numHashBytes = 4;
-    if (props.btMode)
-    {
-      if (props.numHashBytes &lt; 2)
-        numHashBytes = 2;
-      else if (props.numHashBytes &lt; 4)
-        numHashBytes = props.numHashBytes;
-    }
-    p-&gt;matchFinderBase.numHashBytes = numHashBytes;
-  }
-
-  p-&gt;matchFinderBase.cutValue = props.mc;
-
-  p-&gt;writeEndMark = props.writeEndMark;
-
-  #ifdef COMPRESS_MF_MT
-  /*
-  if (newMultiThread != _multiThread)
-  {
-    ReleaseMatchFinder();
-    _multiThread = newMultiThread;
-  }
-  */
-  p-&gt;multiThread = (props.numThreads &gt; 1);
-  #endif
-
-  return SZ_OK;
-}
-
-static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
-static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
-static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
-static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
-
-#define IsCharState(s) ((s) &lt; 7)
-
-#define GetLenToPosState(len) (((len) &lt; kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
-
-#define kInfinityPrice (1 &lt;&lt; 30)
-
-static void RangeEnc_Construct(CRangeEnc *p)
-{
-  p-&gt;outStream = 0;
-  p-&gt;bufBase = 0;
-}
-
-#define RangeEnc_GetProcessed(p) ((p)-&gt;processed + ((p)-&gt;buf - (p)-&gt;bufBase) + (p)-&gt;cacheSize)
-
-#define RC_BUF_SIZE (1 &lt;&lt; 16)
-static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
-{
-  if (p-&gt;bufBase == 0)
-  {
-    p-&gt;bufBase = (Byte *)alloc-&gt;Alloc(alloc, RC_BUF_SIZE);
-    if (p-&gt;bufBase == 0)
-      return 0;
-    p-&gt;bufLim = p-&gt;bufBase + RC_BUF_SIZE;
-  }
-  return 1;
-}
-
-static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;bufBase);
-  p-&gt;bufBase = 0;
-}
-
-static void RangeEnc_Init(CRangeEnc *p)
-{
-  /* Stream.Init(); */
-  p-&gt;low = 0;
-  p-&gt;range = 0xFFFFFFFF;
-  p-&gt;cacheSize = 1;
-  p-&gt;cache = 0;
-
-  p-&gt;buf = p-&gt;bufBase;
-
-  p-&gt;processed = 0;
-  p-&gt;res = SZ_OK;
-}
-
-static void RangeEnc_FlushStream(CRangeEnc *p)
-{
-  size_t num;
-  if (p-&gt;res != SZ_OK)
-    return;
-  num = p-&gt;buf - p-&gt;bufBase;
-  if (num != p-&gt;outStream-&gt;Write(p-&gt;outStream, p-&gt;bufBase, num))
-    p-&gt;res = SZ_ERROR_WRITE;
-  p-&gt;processed += num;
-  p-&gt;buf = p-&gt;bufBase;
-}
-
-static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
-{
-  if ((UInt32)p-&gt;low &lt; (UInt32)0xFF000000 || (int)(p-&gt;low &gt;&gt; 32) != 0)
-  {
-    Byte temp = p-&gt;cache;
-    do
-    {
-      Byte *buf = p-&gt;buf;
-      *buf++ = (Byte)(temp + (Byte)(p-&gt;low &gt;&gt; 32));
-      p-&gt;buf = buf;
-      if (buf == p-&gt;bufLim)
-        RangeEnc_FlushStream(p);
-      temp = 0xFF;
-    }
-    while (--p-&gt;cacheSize != 0);
-    p-&gt;cache = (Byte)((UInt32)p-&gt;low &gt;&gt; 24);
-  }
-  p-&gt;cacheSize++;
-  p-&gt;low = (UInt32)p-&gt;low &lt;&lt; 8;
-}
-
-static void RangeEnc_FlushData(CRangeEnc *p)
-{
-  int i;
-  for (i = 0; i &lt; 5; i++)
-    RangeEnc_ShiftLow(p);
-}
-
-static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
-{
-  do
-  {
-    p-&gt;range &gt;&gt;= 1;
-    p-&gt;low += p-&gt;range &amp; (0 - ((value &gt;&gt; --numBits) &amp; 1));
-    if (p-&gt;range &lt; kTopValue)
-    {
-      p-&gt;range &lt;&lt;= 8;
-      RangeEnc_ShiftLow(p);
-    }
-  }
-  while (numBits != 0);
-}
-
-static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
-{
-  UInt32 ttt = *prob;
-  UInt32 newBound = (p-&gt;range &gt;&gt; kNumBitModelTotalBits) * ttt;
-  if (symbol == 0)
-  {
-    p-&gt;range = newBound;
-    ttt += (kBitModelTotal - ttt) &gt;&gt; kNumMoveBits;
-  }
-  else
-  {
-    p-&gt;low += newBound;
-    p-&gt;range -= newBound;
-    ttt -= ttt &gt;&gt; kNumMoveBits;
-  }
-  *prob = (CLzmaProb)ttt;
-  if (p-&gt;range &lt; kTopValue)
-  {
-    p-&gt;range &lt;&lt;= 8;
-    RangeEnc_ShiftLow(p);
-  }
-}
-
-static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
-{
-  symbol |= 0x100;
-  do
-  {
-    RangeEnc_EncodeBit(p, probs + (symbol &gt;&gt; 8), (symbol &gt;&gt; 7) &amp; 1);
-    symbol &lt;&lt;= 1;
-  }
-  while (symbol &lt; 0x10000);
-}
-
-static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
-{
-  UInt32 offs = 0x100;
-  symbol |= 0x100;
-  do
-  {
-    matchByte &lt;&lt;= 1;
-    RangeEnc_EncodeBit(p, probs + (offs + (matchByte &amp; offs) + (symbol &gt;&gt; 8)), (symbol &gt;&gt; 7) &amp; 1);
-    symbol &lt;&lt;= 1;
-    offs &amp;= ~(matchByte ^ symbol);
-  }
-  while (symbol &lt; 0x10000);
-}
-
-void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-{
-  UInt32 i;
-  for (i = (1 &lt;&lt; kNumMoveReducingBits) / 2; i &lt; kBitModelTotal; i += (1 &lt;&lt; kNumMoveReducingBits))
-  {
-    const int kCyclesBits = kNumBitPriceShiftBits;
-    UInt32 w = i;
-    UInt32 bitCount = 0;
-    int j;
-    for (j = 0; j &lt; kCyclesBits; j++)
-    {
-      w = w * w;
-      bitCount &lt;&lt;= 1;
-      while (w &gt;= ((UInt32)1 &lt;&lt; 16))
-      {
-        w &gt;&gt;= 1;
-        bitCount++;
-      }
-    }
-    ProbPrices[i &gt;&gt; kNumMoveReducingBits] = ((kNumBitModelTotalBits &lt;&lt; kCyclesBits) - 15 - bitCount);
-  }
-}
-
-
-#define GET_PRICE(prob, symbol) \
-  p-&gt;ProbPrices[((prob) ^ (((-(int)(symbol))) &amp; (kBitModelTotal - 1))) &gt;&gt; kNumMoveReducingBits];
-
-#define GET_PRICEa(prob, symbol) \
-  ProbPrices[((prob) ^ ((-((int)(symbol))) &amp; (kBitModelTotal - 1))) &gt;&gt; kNumMoveReducingBits];
-
-#define GET_PRICE_0(prob) p-&gt;ProbPrices[(prob) &gt;&gt; kNumMoveReducingBits]
-#define GET_PRICE_1(prob) p-&gt;ProbPrices[((prob) ^ (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits]
-
-#define GET_PRICE_0a(prob) ProbPrices[(prob) &gt;&gt; kNumMoveReducingBits]
-#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits]
-
-static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  symbol |= 0x100;
-  do
-  {
-    price += GET_PRICEa(probs[symbol &gt;&gt; 8], (symbol &gt;&gt; 7) &amp; 1);
-    symbol &lt;&lt;= 1;
-  }
-  while (symbol &lt; 0x10000);
-  return price;
-}
-
-static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  UInt32 offs = 0x100;
-  symbol |= 0x100;
-  do
-  {
-    matchByte &lt;&lt;= 1;
-    price += GET_PRICEa(probs[offs + (matchByte &amp; offs) + (symbol &gt;&gt; 8)], (symbol &gt;&gt; 7) &amp; 1);
-    symbol &lt;&lt;= 1;
-    offs &amp;= ~(matchByte ^ symbol);
-  }
-  while (symbol &lt; 0x10000);
-  return price;
-}
-
-
-static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-{
-  UInt32 m = 1;
-  int i;
-  for (i = numBitLevels; i != 0;)
-  {
-    UInt32 bit;
-    i--;
-    bit = (symbol &gt;&gt; i) &amp; 1;
-    RangeEnc_EncodeBit(rc, probs + m, bit);
-    m = (m &lt;&lt; 1) | bit;
-  }
-}
-
-static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-{
-  UInt32 m = 1;
-  int i;
-  for (i = 0; i &lt; numBitLevels; i++)
-  {
-    UInt32 bit = symbol &amp; 1;
-    RangeEnc_EncodeBit(rc, probs + m, bit);
-    m = (m &lt;&lt; 1) | bit;
-    symbol &gt;&gt;= 1;
-  }
-}
-
-static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  symbol |= (1 &lt;&lt; numBitLevels);
-  while (symbol != 1)
-  {
-    price += GET_PRICEa(probs[symbol &gt;&gt; 1], symbol &amp; 1);
-    symbol &gt;&gt;= 1;
-  }
-  return price;
-}
-
-static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  UInt32 m = 1;
-  int i;
-  for (i = numBitLevels; i != 0; i--)
-  {
-    UInt32 bit = symbol &amp; 1;
-    symbol &gt;&gt;= 1;
-    price += GET_PRICEa(probs[m], bit);
-    m = (m &lt;&lt; 1) | bit;
-  }
-  return price;
-}
-
-
-static void LenEnc_Init(CLenEnc *p)
-{
-  unsigned i;
-  p-&gt;choice = p-&gt;choice2 = kProbInitValue;
-  for (i = 0; i &lt; (LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumLowBits); i++)
-    p-&gt;low[i] = kProbInitValue;
-  for (i = 0; i &lt; (LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumMidBits); i++)
-    p-&gt;mid[i] = kProbInitValue;
-  for (i = 0; i &lt; kLenNumHighSymbols; i++)
-    p-&gt;high[i] = kProbInitValue;
-}
-
-static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
-{
-  if (symbol &lt; kLenNumLowSymbols)
-  {
-    RangeEnc_EncodeBit(rc, &amp;p-&gt;choice, 0);
-    RcTree_Encode(rc, p-&gt;low + (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, symbol);
-  }
-  else
-  {
-    RangeEnc_EncodeBit(rc, &amp;p-&gt;choice, 1);
-    if (symbol &lt; kLenNumLowSymbols + kLenNumMidSymbols)
-    {
-      RangeEnc_EncodeBit(rc, &amp;p-&gt;choice2, 0);
-      RcTree_Encode(rc, p-&gt;mid + (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
-    }
-    else
-    {
-      RangeEnc_EncodeBit(rc, &amp;p-&gt;choice2, 1);
-      RcTree_Encode(rc, p-&gt;high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
-    }
-  }
-}
-
-static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
-{
-  UInt32 a0 = GET_PRICE_0a(p-&gt;choice);
-  UInt32 a1 = GET_PRICE_1a(p-&gt;choice);
-  UInt32 b0 = a1 + GET_PRICE_0a(p-&gt;choice2);
-  UInt32 b1 = a1 + GET_PRICE_1a(p-&gt;choice2);
-  UInt32 i = 0;
-  for (i = 0; i &lt; kLenNumLowSymbols; i++)
-  {
-    if (i &gt;= numSymbols)
-      return;
-    prices[i] = a0 + RcTree_GetPrice(p-&gt;low + (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
-  }
-  for (; i &lt; kLenNumLowSymbols + kLenNumMidSymbols; i++)
-  {
-    if (i &gt;= numSymbols)
-      return;
-    prices[i] = b0 + RcTree_GetPrice(p-&gt;mid + (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
-  }
-  for (; i &lt; numSymbols; i++)
-    prices[i] = b1 + RcTree_GetPrice(p-&gt;high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
-}
-
-static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
-{
-  LenEnc_SetPrices(&amp;p-&gt;p, posState, p-&gt;tableSize, p-&gt;prices[posState], ProbPrices);
-  p-&gt;counters[posState] = p-&gt;tableSize;
-}
-
-static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
-{
-  UInt32 posState;
-  for (posState = 0; posState &lt; numPosStates; posState++)
-    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-}
-
-static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
-{
-  LenEnc_Encode(&amp;p-&gt;p, rc, symbol, posState);
-  if (updatePrice)
-    if (--p-&gt;counters[posState] == 0)
-      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-}
-
-
-
-
-static void MovePos(CLzmaEnc *p, UInt32 num)
-{
-  #ifdef SHOW_STAT
-  ttt += num;
-  printf(&quot;\n MovePos %d&quot;, num);
-  #endif
-  if (num != 0)
-  {
-    p-&gt;additionalOffset += num;
-    p-&gt;matchFinder.Skip(p-&gt;matchFinderObj, num);
-  }
-}
-
-static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
-{
-  UInt32 lenRes = 0, numPairs;
-  p-&gt;numAvail = p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj);
-  numPairs = p-&gt;matchFinder.GetMatches(p-&gt;matchFinderObj, p-&gt;matches);
-  #ifdef SHOW_STAT
-  printf(&quot;\n i = %d numPairs = %d    &quot;, ttt, numPairs / 2);
-  ttt++;
-  {
-    UInt32 i;
-    for (i = 0; i &lt; numPairs; i += 2)
-      printf(&quot;%2d %6d   | &quot;, p-&gt;matches[i], p-&gt;matches[i + 1]);
-  }
-  #endif
-  if (numPairs &gt; 0)
-  {
-    lenRes = p-&gt;matches[numPairs - 2];
-    if (lenRes == p-&gt;numFastBytes)
-    {
-      const Byte *pby = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-      UInt32 distance = p-&gt;matches[numPairs - 1] + 1;
-      UInt32 numAvail = p-&gt;numAvail;
-      if (numAvail &gt; LZMA_MATCH_LEN_MAX)
-        numAvail = LZMA_MATCH_LEN_MAX;
-      {
-        const Byte *pby2 = pby - distance;
-        for (; lenRes &lt; numAvail &amp;&amp; pby[lenRes] == pby2[lenRes]; lenRes++);
-      }
-    }
-  }
-  p-&gt;additionalOffset++;
-  *numDistancePairsRes = numPairs;
-  return lenRes;
-}
-
-
-#define MakeAsChar(p) (p)-&gt;backPrev = (UInt32)(-1); (p)-&gt;prev1IsChar = False;
-#define MakeAsShortRep(p) (p)-&gt;backPrev = 0; (p)-&gt;prev1IsChar = False;
-#define IsShortRep(p) ((p)-&gt;backPrev == 0)
-
-static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
-{
-  return
-    GET_PRICE_0(p-&gt;isRepG0[state]) +
-    GET_PRICE_0(p-&gt;isRep0Long[state][posState]);
-}
-
-static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
-{
-  UInt32 price;
-  if (repIndex == 0)
-  {
-    price = GET_PRICE_0(p-&gt;isRepG0[state]);
-    price += GET_PRICE_1(p-&gt;isRep0Long[state][posState]);
-  }
-  else
-  {
-    price = GET_PRICE_1(p-&gt;isRepG0[state]);
-    if (repIndex == 1)
-      price += GET_PRICE_0(p-&gt;isRepG1[state]);
-    else
-    {
-      price += GET_PRICE_1(p-&gt;isRepG1[state]);
-      price += GET_PRICE(p-&gt;isRepG2[state], repIndex - 2);
-    }
-  }
-  return price;
-}
-
-static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
-{
-  return p-&gt;repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
-    GetPureRepPrice(p, repIndex, state, posState);
-}
-
-static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
-{
-  UInt32 posMem = p-&gt;opt[cur].posPrev;
-  UInt32 backMem = p-&gt;opt[cur].backPrev;
-  p-&gt;optimumEndIndex = cur;
-  do
-  {
-    if (p-&gt;opt[cur].prev1IsChar)
-    {
-      MakeAsChar(&amp;p-&gt;opt[posMem])
-      p-&gt;opt[posMem].posPrev = posMem - 1;
-      if (p-&gt;opt[cur].prev2)
-      {
-        p-&gt;opt[posMem - 1].prev1IsChar = False;
-        p-&gt;opt[posMem - 1].posPrev = p-&gt;opt[cur].posPrev2;
-        p-&gt;opt[posMem - 1].backPrev = p-&gt;opt[cur].backPrev2;
-      }
-    }
-    {
-      UInt32 posPrev = posMem;
-      UInt32 backCur = backMem;
-      
-      backMem = p-&gt;opt[posPrev].backPrev;
-      posMem = p-&gt;opt[posPrev].posPrev;
-      
-      p-&gt;opt[posPrev].backPrev = backCur;
-      p-&gt;opt[posPrev].posPrev = cur;
-      cur = posPrev;
-    }
-  }
-  while (cur != 0);
-  *backRes = p-&gt;opt[0].backPrev;
-  p-&gt;optimumCurrentIndex  = p-&gt;opt[0].posPrev;
-  return p-&gt;optimumCurrentIndex;
-}
-
-#define LIT_PROBS(pos, prevByte) (p-&gt;litProbs + ((((pos) &amp; p-&gt;lpMask) &lt;&lt; p-&gt;lc) + ((prevByte) &gt;&gt; (8 - p-&gt;lc))) * 0x300)
-
-static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
-{
-  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
-  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
-  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
-  UInt32 *matches;
-  const Byte *data;
-  Byte curByte, matchByte;
-  if (p-&gt;optimumEndIndex != p-&gt;optimumCurrentIndex)
-  {
-    const COptimal *opt = &amp;p-&gt;opt[p-&gt;optimumCurrentIndex];
-    UInt32 lenRes = opt-&gt;posPrev - p-&gt;optimumCurrentIndex;
-    *backRes = opt-&gt;backPrev;
-    p-&gt;optimumCurrentIndex = opt-&gt;posPrev;
-    return lenRes;
-  }
-  p-&gt;optimumCurrentIndex = p-&gt;optimumEndIndex = 0;
-  
-  if (p-&gt;additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &amp;numPairs);
-  else
-  {
-    mainLen = p-&gt;longestMatchLength;
-    numPairs = p-&gt;numPairs;
-  }
-
-  numAvail = p-&gt;numAvail;
-  if (numAvail &lt; 2)
-  {
-    *backRes = (UInt32)(-1);
-    return 1;
-  }
-  if (numAvail &gt; LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
-
-  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-  repMaxIndex = 0;
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-  {
-    UInt32 lenTest;
-    const Byte *data2;
-    reps[i] = p-&gt;reps[i];
-    data2 = data - (reps[i] + 1);
-    if (data[0] != data2[0] || data[1] != data2[1])
-    {
-      repLens[i] = 0;
-      continue;
-    }
-    for (lenTest = 2; lenTest &lt; numAvail &amp;&amp; data[lenTest] == data2[lenTest]; lenTest++);
-    repLens[i] = lenTest;
-    if (lenTest &gt; repLens[repMaxIndex])
-      repMaxIndex = i;
-  }
-  if (repLens[repMaxIndex] &gt;= p-&gt;numFastBytes)
-  {
-    UInt32 lenRes;
-    *backRes = repMaxIndex;
-    lenRes = repLens[repMaxIndex];
-    MovePos(p, lenRes - 1);
-    return lenRes;
-  }
-
-  matches = p-&gt;matches;
-  if (mainLen &gt;= p-&gt;numFastBytes)
-  {
-    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
-  }
-  curByte = *data;
-  matchByte = *(data - (reps[0] + 1));
-
-  if (mainLen &lt; 2 &amp;&amp; curByte != matchByte &amp;&amp; repLens[repMaxIndex] &lt; 2)
-  {
-    *backRes = (UInt32)-1;
-    return 1;
-  }
-
-  p-&gt;opt[0].state = (CState)p-&gt;state;
-
-  posState = (position &amp; p-&gt;pbMask);
-
-  {
-    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-    p-&gt;opt[1].price = GET_PRICE_0(p-&gt;isMatch[p-&gt;state][posState]) +
-        (!IsCharState(p-&gt;state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p-&gt;ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p-&gt;ProbPrices));
-  }
-
-  MakeAsChar(&amp;p-&gt;opt[1]);
-
-  matchPrice = GET_PRICE_1(p-&gt;isMatch[p-&gt;state][posState]);
-  repMatchPrice = matchPrice + GET_PRICE_1(p-&gt;isRep[p-&gt;state]);
-
-  if (matchByte == curByte)
-  {
-    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p-&gt;state, posState);
-    if (shortRepPrice &lt; p-&gt;opt[1].price)
-    {
-      p-&gt;opt[1].price = shortRepPrice;
-      MakeAsShortRep(&amp;p-&gt;opt[1]);
-    }
-  }
-  lenEnd = ((mainLen &gt;= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
-
-  if (lenEnd &lt; 2)
-  {
-    *backRes = p-&gt;opt[1].backPrev;
-    return 1;
-  }
-
-  p-&gt;opt[1].posPrev = 0;
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-    p-&gt;opt[0].backs[i] = reps[i];
-
-  len = lenEnd;
-  do
-    p-&gt;opt[len--].price = kInfinityPrice;
-  while (len &gt;= 2);
-
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-  {
-    UInt32 repLen = repLens[i];
-    UInt32 price;
-    if (repLen &lt; 2)
-      continue;
-    price = repMatchPrice + GetPureRepPrice(p, i, p-&gt;state, posState);
-    do
-    {
-      UInt32 curAndLenPrice = price + p-&gt;repLenEnc.prices[posState][repLen - 2];
-      COptimal *opt = &amp;p-&gt;opt[repLen];
-      if (curAndLenPrice &lt; opt-&gt;price)
-      {
-        opt-&gt;price = curAndLenPrice;
-        opt-&gt;posPrev = 0;
-        opt-&gt;backPrev = i;
-        opt-&gt;prev1IsChar = False;
-      }
-    }
-    while (--repLen &gt;= 2);
-  }
-
-  normalMatchPrice = matchPrice + GET_PRICE_0(p-&gt;isRep[p-&gt;state]);
-
-  len = ((repLens[0] &gt;= 2) ? repLens[0] + 1 : 2);
-  if (len &lt;= mainLen)
-  {
-    UInt32 offs = 0;
-    while (len &gt; matches[offs])
-      offs += 2;
-    for (; ; len++)
-    {
-      COptimal *opt;
-      UInt32 distance = matches[offs + 1];
-
-      UInt32 curAndLenPrice = normalMatchPrice + p-&gt;lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
-      UInt32 lenToPosState = GetLenToPosState(len);
-      if (distance &lt; kNumFullDistances)
-        curAndLenPrice += p-&gt;distancesPrices[lenToPosState][distance];
-      else
-      {
-        UInt32 slot;
-        GetPosSlot2(distance, slot);
-        curAndLenPrice += p-&gt;alignPrices[distance &amp; kAlignMask] + p-&gt;posSlotPrices[lenToPosState][slot];
-      }
-      opt = &amp;p-&gt;opt[len];
-      if (curAndLenPrice &lt; opt-&gt;price)
-      {
-        opt-&gt;price = curAndLenPrice;
-        opt-&gt;posPrev = 0;
-        opt-&gt;backPrev = distance + LZMA_NUM_REPS;
-        opt-&gt;prev1IsChar = False;
-      }
-      if (len == matches[offs])
-      {
-        offs += 2;
-        if (offs == numPairs)
-          break;
-      }
-    }
-  }
-
-  cur = 0;
-
-    #ifdef SHOW_STAT2
-    if (position &gt;= 0)
-    {
-      unsigned i;
-      printf(&quot;\n pos = %4X&quot;, position);
-      for (i = cur; i &lt;= lenEnd; i++)
-      printf(&quot;\nprice[%4X] = %d&quot;, position - cur + i, p-&gt;opt[i].price);
-    }
-    #endif
-
-  for (;;)
-  {
-    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
-    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
-    Bool nextIsChar;
-    Byte curByte, matchByte;
-    const Byte *data;
-    COptimal *curOpt;
-    COptimal *nextOpt;
-
-    cur++;
-    if (cur == lenEnd)
-      return Backward(p, backRes, cur);
-
-    newLen = ReadMatchDistances(p, &amp;numPairs);
-    if (newLen &gt;= p-&gt;numFastBytes)
-    {
-      p-&gt;numPairs = numPairs;
-      p-&gt;longestMatchLength = newLen;
-      return Backward(p, backRes, cur);
-    }
-    position++;
-    curOpt = &amp;p-&gt;opt[cur];
-    posPrev = curOpt-&gt;posPrev;
-    if (curOpt-&gt;prev1IsChar)
-    {
-      posPrev--;
-      if (curOpt-&gt;prev2)
-      {
-        state = p-&gt;opt[curOpt-&gt;posPrev2].state;
-        if (curOpt-&gt;backPrev2 &lt; LZMA_NUM_REPS)
-          state = kRepNextStates[state];
-        else
-          state = kMatchNextStates[state];
-      }
-      else
-        state = p-&gt;opt[posPrev].state;
-      state = kLiteralNextStates[state];
-    }
-    else
-      state = p-&gt;opt[posPrev].state;
-    if (posPrev == cur - 1)
-    {
-      if (IsShortRep(curOpt))
-        state = kShortRepNextStates[state];
-      else
-        state = kLiteralNextStates[state];
-    }
-    else
-    {
-      UInt32 pos;
-      const COptimal *prevOpt;
-      if (curOpt-&gt;prev1IsChar &amp;&amp; curOpt-&gt;prev2)
-      {
-        posPrev = curOpt-&gt;posPrev2;
-        pos = curOpt-&gt;backPrev2;
-        state = kRepNextStates[state];
-      }
-      else
-      {
-        pos = curOpt-&gt;backPrev;
-        if (pos &lt; LZMA_NUM_REPS)
-          state = kRepNextStates[state];
-        else
-          state = kMatchNextStates[state];
-      }
-      prevOpt = &amp;p-&gt;opt[posPrev];
-      if (pos &lt; LZMA_NUM_REPS)
-      {
-        UInt32 i;
-        reps[0] = prevOpt-&gt;backs[pos];
-        for (i = 1; i &lt;= pos; i++)
-          reps[i] = prevOpt-&gt;backs[i - 1];
-        for (; i &lt; LZMA_NUM_REPS; i++)
-          reps[i] = prevOpt-&gt;backs[i];
-      }
-      else
-      {
-        UInt32 i;
-        reps[0] = (pos - LZMA_NUM_REPS);
-        for (i = 1; i &lt; LZMA_NUM_REPS; i++)
-          reps[i] = prevOpt-&gt;backs[i - 1];
-      }
-    }
-    curOpt-&gt;state = (CState)state;
-
-    curOpt-&gt;backs[0] = reps[0];
-    curOpt-&gt;backs[1] = reps[1];
-    curOpt-&gt;backs[2] = reps[2];
-    curOpt-&gt;backs[3] = reps[3];
-
-    curPrice = curOpt-&gt;price;
-    nextIsChar = False;
-    data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-    curByte = *data;
-    matchByte = *(data - (reps[0] + 1));
-
-    posState = (position &amp; p-&gt;pbMask);
-
-    curAnd1Price = curPrice + GET_PRICE_0(p-&gt;isMatch[state][posState]);
-    {
-      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-      curAnd1Price +=
-        (!IsCharState(state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p-&gt;ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p-&gt;ProbPrices));
-    }
-
-    nextOpt = &amp;p-&gt;opt[cur + 1];
-
-    if (curAnd1Price &lt; nextOpt-&gt;price)
-    {
-      nextOpt-&gt;price = curAnd1Price;
-      nextOpt-&gt;posPrev = cur;
-      MakeAsChar(nextOpt);
-      nextIsChar = True;
-    }
-
-    matchPrice = curPrice + GET_PRICE_1(p-&gt;isMatch[state][posState]);
-    repMatchPrice = matchPrice + GET_PRICE_1(p-&gt;isRep[state]);
-    
-    if (matchByte == curByte &amp;&amp; !(nextOpt-&gt;posPrev &lt; cur &amp;&amp; nextOpt-&gt;backPrev == 0))
-    {
-      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
-      if (shortRepPrice &lt;= nextOpt-&gt;price)
-      {
-        nextOpt-&gt;price = shortRepPrice;
-        nextOpt-&gt;posPrev = cur;
-        MakeAsShortRep(nextOpt);
-        nextIsChar = True;
-      }
-    }
-    numAvailFull = p-&gt;numAvail;
-    {
-      UInt32 temp = kNumOpts - 1 - cur;
-      if (temp &lt; numAvailFull)
-        numAvailFull = temp;
-    }
-
-    if (numAvailFull &lt; 2)
-      continue;
-    numAvail = (numAvailFull &lt;= p-&gt;numFastBytes ? numAvailFull : p-&gt;numFastBytes);
-
-    if (!nextIsChar &amp;&amp; matchByte != curByte) /* speed optimization */
-    {
-      /* try Literal + rep0 */
-      UInt32 temp;
-      UInt32 lenTest2;
-      const Byte *data2 = data - (reps[0] + 1);
-      UInt32 limit = p-&gt;numFastBytes + 1;
-      if (limit &gt; numAvailFull)
-        limit = numAvailFull;
-
-      for (temp = 1; temp &lt; limit &amp;&amp; data[temp] == data2[temp]; temp++);
-      lenTest2 = temp - 1;
-      if (lenTest2 &gt;= 2)
-      {
-        UInt32 state2 = kLiteralNextStates[state];
-        UInt32 posStateNext = (position + 1) &amp; p-&gt;pbMask;
-        UInt32 nextRepMatchPrice = curAnd1Price +
-            GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
-            GET_PRICE_1(p-&gt;isRep[state2]);
-        /* for (; lenTest2 &gt;= 2; lenTest2--) */
-        {
-          UInt32 curAndLenPrice;
-          COptimal *opt;
-          UInt32 offset = cur + 1 + lenTest2;
-          while (lenEnd &lt; offset)
-            p-&gt;opt[++lenEnd].price = kInfinityPrice;
-          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-          opt = &amp;p-&gt;opt[offset];
-          if (curAndLenPrice &lt; opt-&gt;price)
-          {
-            opt-&gt;price = curAndLenPrice;
-            opt-&gt;posPrev = cur + 1;
-            opt-&gt;backPrev = 0;
-            opt-&gt;prev1IsChar = True;
-            opt-&gt;prev2 = False;
-          }
-        }
-      }
-    }
-    
-    startLen = 2; /* speed optimization */
-    {
-    UInt32 repIndex;
-    for (repIndex = 0; repIndex &lt; LZMA_NUM_REPS; repIndex++)
-    {
-      UInt32 lenTest;
-      UInt32 lenTestTemp;
-      UInt32 price;
-      const Byte *data2 = data - (reps[repIndex] + 1);
-      if (data[0] != data2[0] || data[1] != data2[1])
-        continue;
-      for (lenTest = 2; lenTest &lt; numAvail &amp;&amp; data[lenTest] == data2[lenTest]; lenTest++);
-      while (lenEnd &lt; cur + lenTest)
-        p-&gt;opt[++lenEnd].price = kInfinityPrice;
-      lenTestTemp = lenTest;
-      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
-      do
-      {
-        UInt32 curAndLenPrice = price + p-&gt;repLenEnc.prices[posState][lenTest - 2];
-        COptimal *opt = &amp;p-&gt;opt[cur + lenTest];
-        if (curAndLenPrice &lt; opt-&gt;price)
-        {
-          opt-&gt;price = curAndLenPrice;
-          opt-&gt;posPrev = cur;
-          opt-&gt;backPrev = repIndex;
-          opt-&gt;prev1IsChar = False;
-        }
-      }
-      while (--lenTest &gt;= 2);
-      lenTest = lenTestTemp;
-      
-      if (repIndex == 0)
-        startLen = lenTest + 1;
-        
-      /* if (_maxMode) */
-        {
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p-&gt;numFastBytes;
-          UInt32 nextRepMatchPrice;
-          if (limit &gt; numAvailFull)
-            limit = numAvailFull;
-          for (; lenTest2 &lt; limit &amp;&amp; data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 &gt;= 2)
-          {
-            UInt32 state2 = kRepNextStates[state];
-            UInt32 posStateNext = (position + lenTest) &amp; p-&gt;pbMask;
-            UInt32 curAndLenCharPrice =
-                price + p-&gt;repLenEnc.prices[posState][lenTest - 2] +
-                GET_PRICE_0(p-&gt;isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-                    data[lenTest], data2[lenTest], p-&gt;ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (position + lenTest + 1) &amp; p-&gt;pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p-&gt;isRep[state2]);
-            
-            /* for (; lenTest2 &gt;= 2; lenTest2--) */
-            {
-              UInt32 curAndLenPrice;
-              COptimal *opt;
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              while (lenEnd &lt; offset)
-                p-&gt;opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-              opt = &amp;p-&gt;opt[offset];
-              if (curAndLenPrice &lt; opt-&gt;price)
-              {
-                opt-&gt;price = curAndLenPrice;
-                opt-&gt;posPrev = cur + lenTest + 1;
-                opt-&gt;backPrev = 0;
-                opt-&gt;prev1IsChar = True;
-                opt-&gt;prev2 = True;
-                opt-&gt;posPrev2 = cur;
-                opt-&gt;backPrev2 = repIndex;
-              }
-            }
-          }
-        }
-    }
-    }
-    /* for (UInt32 lenTest = 2; lenTest &lt;= newLen; lenTest++) */
-    if (newLen &gt; numAvail)
-    {
-      newLen = numAvail;
-      for (numPairs = 0; newLen &gt; matches[numPairs]; numPairs += 2);
-      matches[numPairs] = newLen;
-      numPairs += 2;
-    }
-    if (newLen &gt;= startLen)
-    {
-      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p-&gt;isRep[state]);
-      UInt32 offs, curBack, posSlot;
-      UInt32 lenTest;
-      while (lenEnd &lt; cur + newLen)
-        p-&gt;opt[++lenEnd].price = kInfinityPrice;
-
-      offs = 0;
-      while (startLen &gt; matches[offs])
-        offs += 2;
-      curBack = matches[offs + 1];
-      GetPosSlot2(curBack, posSlot);
-      for (lenTest = /*2*/ startLen; ; lenTest++)
-      {
-        UInt32 curAndLenPrice = normalMatchPrice + p-&gt;lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
-        UInt32 lenToPosState = GetLenToPosState(lenTest);
-        COptimal *opt;
-        if (curBack &lt; kNumFullDistances)
-          curAndLenPrice += p-&gt;distancesPrices[lenToPosState][curBack];
-        else
-          curAndLenPrice += p-&gt;posSlotPrices[lenToPosState][posSlot] + p-&gt;alignPrices[curBack &amp; kAlignMask];
-        
-        opt = &amp;p-&gt;opt[cur + lenTest];
-        if (curAndLenPrice &lt; opt-&gt;price)
-        {
-          opt-&gt;price = curAndLenPrice;
-          opt-&gt;posPrev = cur;
-          opt-&gt;backPrev = curBack + LZMA_NUM_REPS;
-          opt-&gt;prev1IsChar = False;
-        }
-
-        if (/*_maxMode &amp;&amp; */lenTest == matches[offs])
-        {
-          /* Try Match + Literal + Rep0 */
-          const Byte *data2 = data - (curBack + 1);
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p-&gt;numFastBytes;
-          UInt32 nextRepMatchPrice;
-          if (limit &gt; numAvailFull)
-            limit = numAvailFull;
-          for (; lenTest2 &lt; limit &amp;&amp; data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 &gt;= 2)
-          {
-            UInt32 state2 = kMatchNextStates[state];
-            UInt32 posStateNext = (position + lenTest) &amp; p-&gt;pbMask;
-            UInt32 curAndLenCharPrice = curAndLenPrice +
-                GET_PRICE_0(p-&gt;isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-                    data[lenTest], data2[lenTest], p-&gt;ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (posStateNext + 1) &amp; p-&gt;pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p-&gt;isRep[state2]);
-            
-            /* for (; lenTest2 &gt;= 2; lenTest2--) */
-            {
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              UInt32 curAndLenPrice;
-              COptimal *opt;
-              while (lenEnd &lt; offset)
-                p-&gt;opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-              opt = &amp;p-&gt;opt[offset];
-              if (curAndLenPrice &lt; opt-&gt;price)
-              {
-                opt-&gt;price = curAndLenPrice;
-                opt-&gt;posPrev = cur + lenTest + 1;
-                opt-&gt;backPrev = 0;
-                opt-&gt;prev1IsChar = True;
-                opt-&gt;prev2 = True;
-                opt-&gt;posPrev2 = cur;
-                opt-&gt;backPrev2 = curBack + LZMA_NUM_REPS;
-              }
-            }
-          }
-          offs += 2;
-          if (offs == numPairs)
-            break;
-          curBack = matches[offs + 1];
-          if (curBack &gt;= kNumFullDistances)
-            GetPosSlot2(curBack, posSlot);
-        }
-      }
-    }
-  }
-}
-
-#define ChangePair(smallDist, bigDist) (((bigDist) &gt;&gt; 7) &gt; (smallDist))
-
-static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
-{
-  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
-  const Byte *data;
-  const UInt32 *matches;
-
-  if (p-&gt;additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &amp;numPairs);
-  else
-  {
-    mainLen = p-&gt;longestMatchLength;
-    numPairs = p-&gt;numPairs;
-  }
-
-  numAvail = p-&gt;numAvail;
-  *backRes = (UInt32)-1;
-  if (numAvail &lt; 2)
-    return 1;
-  if (numAvail &gt; LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
-  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-
-  repLen = repIndex = 0;
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-  {
-    UInt32 len;
-    const Byte *data2 = data - (p-&gt;reps[i] + 1);
-    if (data[0] != data2[0] || data[1] != data2[1])
-      continue;
-    for (len = 2; len &lt; numAvail &amp;&amp; data[len] == data2[len]; len++);
-    if (len &gt;= p-&gt;numFastBytes)
-    {
-      *backRes = i;
-      MovePos(p, len - 1);
-      return len;
-    }
-    if (len &gt; repLen)
-    {
-      repIndex = i;
-      repLen = len;
-    }
-  }
-
-  matches = p-&gt;matches;
-  if (mainLen &gt;= p-&gt;numFastBytes)
-  {
-    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
-  }
-
-  mainDist = 0; /* for GCC */
-  if (mainLen &gt;= 2)
-  {
-    mainDist = matches[numPairs - 1];
-    while (numPairs &gt; 2 &amp;&amp; mainLen == matches[numPairs - 4] + 1)
-    {
-      if (!ChangePair(matches[numPairs - 3], mainDist))
-        break;
-      numPairs -= 2;
-      mainLen = matches[numPairs - 2];
-      mainDist = matches[numPairs - 1];
-    }
-    if (mainLen == 2 &amp;&amp; mainDist &gt;= 0x80)
-      mainLen = 1;
-  }
-
-  if (repLen &gt;= 2 &amp;&amp; (
-        (repLen + 1 &gt;= mainLen) ||
-        (repLen + 2 &gt;= mainLen &amp;&amp; mainDist &gt;= (1 &lt;&lt; 9)) ||
-        (repLen + 3 &gt;= mainLen &amp;&amp; mainDist &gt;= (1 &lt;&lt; 15))))
-  {
-    *backRes = repIndex;
-    MovePos(p, repLen - 1);
-    return repLen;
-  }
-  
-  if (mainLen &lt; 2 || numAvail &lt;= 2)
-    return 1;
-
-  p-&gt;longestMatchLength = ReadMatchDistances(p, &amp;p-&gt;numPairs);
-  if (p-&gt;longestMatchLength &gt;= 2)
-  {
-    UInt32 newDistance = matches[p-&gt;numPairs - 1];
-    if ((p-&gt;longestMatchLength &gt;= mainLen &amp;&amp; newDistance &lt; mainDist) ||
-        (p-&gt;longestMatchLength == mainLen + 1 &amp;&amp; !ChangePair(mainDist, newDistance)) ||
-        (p-&gt;longestMatchLength &gt; mainLen + 1) ||
-        (p-&gt;longestMatchLength + 1 &gt;= mainLen &amp;&amp; mainLen &gt;= 3 &amp;&amp; ChangePair(newDistance, mainDist)))
-      return 1;
-  }
-  
-  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-  {
-    UInt32 len, limit;
-    const Byte *data2 = data - (p-&gt;reps[i] + 1);
-    if (data[0] != data2[0] || data[1] != data2[1])
-      continue;
-    limit = mainLen - 1;
-    for (len = 2; len &lt; limit &amp;&amp; data[len] == data2[len]; len++);
-    if (len &gt;= limit)
-      return 1;
-  }
-  *backRes = mainDist + LZMA_NUM_REPS;
-  MovePos(p, mainLen - 2);
-  return mainLen;
-}
-
-static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
-{
-  UInt32 len;
-  RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 1);
-  RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 0);
-  p-&gt;state = kMatchNextStates[p-&gt;state];
-  len = LZMA_MATCH_LEN_MIN;
-  LenEnc_Encode2(&amp;p-&gt;lenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
-  RcTree_Encode(&amp;p-&gt;rc, p-&gt;posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 &lt;&lt; kNumPosSlotBits) - 1);
-  RangeEnc_EncodeDirectBits(&amp;p-&gt;rc, (((UInt32)1 &lt;&lt; 30) - 1) &gt;&gt; kNumAlignBits, 30 - kNumAlignBits);
-  RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posAlignEncoder, kNumAlignBits, kAlignMask);
-}
-
-static SRes CheckErrors(CLzmaEnc *p)
-{
-  if (p-&gt;result != SZ_OK)
-    return p-&gt;result;
-  if (p-&gt;rc.res != SZ_OK)
-    p-&gt;result = SZ_ERROR_WRITE;
-  if (p-&gt;matchFinderBase.result != SZ_OK)
-    p-&gt;result = SZ_ERROR_READ;
-  if (p-&gt;result != SZ_OK)
-    p-&gt;finished = True;
-  return p-&gt;result;
-}
-
-static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
-{
-  /* ReleaseMFStream(); */
-  p-&gt;finished = True;
-  if (p-&gt;writeEndMark)
-    WriteEndMarker(p, nowPos &amp; p-&gt;pbMask);
-  RangeEnc_FlushData(&amp;p-&gt;rc);
-  RangeEnc_FlushStream(&amp;p-&gt;rc);
-  return CheckErrors(p);
-}
-
-static void FillAlignPrices(CLzmaEnc *p)
-{
-  UInt32 i;
-  for (i = 0; i &lt; kAlignTableSize; i++)
-    p-&gt;alignPrices[i] = RcTree_ReverseGetPrice(p-&gt;posAlignEncoder, kNumAlignBits, i, p-&gt;ProbPrices);
-  p-&gt;alignPriceCount = 0;
-}
-
-static void FillDistancesPrices(CLzmaEnc *p)
-{
-  UInt32 tempPrices[kNumFullDistances];
-  UInt32 i, lenToPosState;
-  for (i = kStartPosModelIndex; i &lt; kNumFullDistances; i++)
-  {
-    UInt32 posSlot = GetPosSlot1(i);
-    UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
-    UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
-    tempPrices[i] = RcTree_ReverseGetPrice(p-&gt;posEncoders + base - posSlot - 1, footerBits, i - base, p-&gt;ProbPrices);
-  }
-
-  for (lenToPosState = 0; lenToPosState &lt; kNumLenToPosStates; lenToPosState++)
-  {
-    UInt32 posSlot;
-    const CLzmaProb *encoder = p-&gt;posSlotEncoder[lenToPosState];
-    UInt32 *posSlotPrices = p-&gt;posSlotPrices[lenToPosState];
-    for (posSlot = 0; posSlot &lt; p-&gt;distTableSize; posSlot++)
-      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p-&gt;ProbPrices);
-    for (posSlot = kEndPosModelIndex; posSlot &lt; p-&gt;distTableSize; posSlot++)
-      posSlotPrices[posSlot] += ((((posSlot &gt;&gt; 1) - 1) - kNumAlignBits) &lt;&lt; kNumBitPriceShiftBits);
-
-    {
-      UInt32 *distancesPrices = p-&gt;distancesPrices[lenToPosState];
-      UInt32 i;
-      for (i = 0; i &lt; kStartPosModelIndex; i++)
-        distancesPrices[i] = posSlotPrices[i];
-      for (; i &lt; kNumFullDistances; i++)
-        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
-    }
-  }
-  p-&gt;matchPriceCount = 0;
-}
-
-void LzmaEnc_Construct(CLzmaEnc *p)
-{
-  RangeEnc_Construct(&amp;p-&gt;rc);
-  MatchFinder_Construct(&amp;p-&gt;matchFinderBase);
-  #ifdef COMPRESS_MF_MT
-  MatchFinderMt_Construct(&amp;p-&gt;matchFinderMt);
-  p-&gt;matchFinderMt.MatchFinder = &amp;p-&gt;matchFinderBase;
-  #endif
-
-  {
-    CLzmaEncProps props;
-    LzmaEncProps_Init(&amp;props);
-    LzmaEnc_SetProps(p, &amp;props);
-  }
-
-  #ifndef LZMA_LOG_BSR
-  LzmaEnc_FastPosInit(p-&gt;g_FastPos);
-  #endif
-
-  LzmaEnc_InitPriceTables(p-&gt;ProbPrices);
-  p-&gt;litProbs = 0;
-  p-&gt;saveState.litProbs = 0;
-}
-
-CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
-{
-  void *p;
-  p = alloc-&gt;Alloc(alloc, sizeof(CLzmaEnc));
-  if (p != 0)
-    LzmaEnc_Construct((CLzmaEnc *)p);
-  return p;
-}
-
-void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;litProbs);
-  alloc-&gt;Free(alloc, p-&gt;saveState.litProbs);
-  p-&gt;litProbs = 0;
-  p-&gt;saveState.litProbs = 0;
-}
-
-void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  #ifdef COMPRESS_MF_MT
-  MatchFinderMt_Destruct(&amp;p-&gt;matchFinderMt, allocBig);
-  #endif
-  MatchFinder_Free(&amp;p-&gt;matchFinderBase, allocBig);
-  LzmaEnc_FreeLits(p, alloc);
-  RangeEnc_Free(&amp;p-&gt;rc, alloc);
-}
-
-void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
-  alloc-&gt;Free(alloc, p);
-}
-
-static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
-{
-  UInt32 nowPos32, startPos32;
-  if (p-&gt;inStream != 0)
-  {
-    p-&gt;matchFinderBase.stream = p-&gt;inStream;
-    p-&gt;matchFinder.Init(p-&gt;matchFinderObj);
-    p-&gt;inStream = 0;
-  }
-
-  if (p-&gt;finished)
-    return p-&gt;result;
-  RINOK(CheckErrors(p));
-
-  nowPos32 = (UInt32)p-&gt;nowPos64;
-  startPos32 = nowPos32;
-
-  if (p-&gt;nowPos64 == 0)
-  {
-    UInt32 numPairs;
-    Byte curByte;
-    if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) == 0)
-      return Flush(p, nowPos32);
-    ReadMatchDistances(p, &amp;numPairs);
-    RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][0], 0);
-    p-&gt;state = kLiteralNextStates[p-&gt;state];
-    curByte = p-&gt;matchFinder.GetIndexByte(p-&gt;matchFinderObj, 0 - p-&gt;additionalOffset);
-    LitEnc_Encode(&amp;p-&gt;rc, p-&gt;litProbs, curByte);
-    p-&gt;additionalOffset--;
-    nowPos32++;
-  }
-
-  if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) != 0)
-  for (;;)
-  {
-    UInt32 pos, len, posState;
-
-    if (p-&gt;fastMode)
-      len = GetOptimumFast(p, &amp;pos);
-    else
-      len = GetOptimum(p, nowPos32, &amp;pos);
-
-    #ifdef SHOW_STAT2
-    printf(&quot;\n pos = %4X,   len = %d   pos = %d&quot;, nowPos32, len, pos);
-    #endif
-
-    posState = nowPos32 &amp; p-&gt;pbMask;
-    if (len == 1 &amp;&amp; pos == (UInt32)-1)
-    {
-      Byte curByte;
-      CLzmaProb *probs;
-      const Byte *data;
-
-      RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 0);
-      data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - p-&gt;additionalOffset;
-      curByte = *data;
-      probs = LIT_PROBS(nowPos32, *(data - 1));
-      if (IsCharState(p-&gt;state))
-        LitEnc_Encode(&amp;p-&gt;rc, probs, curByte);
-      else
-        LitEnc_EncodeMatched(&amp;p-&gt;rc, probs, curByte, *(data - p-&gt;reps[0] - 1));
-      p-&gt;state = kLiteralNextStates[p-&gt;state];
-    }
-    else
-    {
-      RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 1);
-      if (pos &lt; LZMA_NUM_REPS)
-      {
-        RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 1);
-        if (pos == 0)
-        {
-          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG0[p-&gt;state], 0);
-          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep0Long[p-&gt;state][posState], ((len == 1) ? 0 : 1));
-        }
-        else
-        {
-          UInt32 distance = p-&gt;reps[pos];
-          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG0[p-&gt;state], 1);
-          if (pos == 1)
-            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG1[p-&gt;state], 0);
-          else
-          {
-            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG1[p-&gt;state], 1);
-            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG2[p-&gt;state], pos - 2);
-            if (pos == 3)
-              p-&gt;reps[3] = p-&gt;reps[2];
-            p-&gt;reps[2] = p-&gt;reps[1];
-          }
-          p-&gt;reps[1] = p-&gt;reps[0];
-          p-&gt;reps[0] = distance;
-        }
-        if (len == 1)
-          p-&gt;state = kShortRepNextStates[p-&gt;state];
-        else
-        {
-          LenEnc_Encode2(&amp;p-&gt;repLenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
-          p-&gt;state = kRepNextStates[p-&gt;state];
-        }
-      }
-      else
-      {
-        UInt32 posSlot;
-        RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 0);
-        p-&gt;state = kMatchNextStates[p-&gt;state];
-        LenEnc_Encode2(&amp;p-&gt;lenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
-        pos -= LZMA_NUM_REPS;
-        GetPosSlot(pos, posSlot);
-        RcTree_Encode(&amp;p-&gt;rc, p-&gt;posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
-        
-        if (posSlot &gt;= kStartPosModelIndex)
-        {
-          UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
-          UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
-          UInt32 posReduced = pos - base;
-
-          if (posSlot &lt; kEndPosModelIndex)
-            RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posEncoders + base - posSlot - 1, footerBits, posReduced);
-          else
-          {
-            RangeEnc_EncodeDirectBits(&amp;p-&gt;rc, posReduced &gt;&gt; kNumAlignBits, footerBits - kNumAlignBits);
-            RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posAlignEncoder, kNumAlignBits, posReduced &amp; kAlignMask);
-            p-&gt;alignPriceCount++;
-          }
-        }
-        p-&gt;reps[3] = p-&gt;reps[2];
-        p-&gt;reps[2] = p-&gt;reps[1];
-        p-&gt;reps[1] = p-&gt;reps[0];
-        p-&gt;reps[0] = pos;
-        p-&gt;matchPriceCount++;
-      }
-    }
-    p-&gt;additionalOffset -= len;
-    nowPos32 += len;
-    if (p-&gt;additionalOffset == 0)
-    {
-      UInt32 processed;
-      if (!p-&gt;fastMode)
-      {
-        if (p-&gt;matchPriceCount &gt;= (1 &lt;&lt; 7))
-          FillDistancesPrices(p);
-        if (p-&gt;alignPriceCount &gt;= kAlignTableSize)
-          FillAlignPrices(p);
-      }
-      if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) == 0)
-        break;
-      processed = nowPos32 - startPos32;
-      if (useLimits)
-      {
-        if (processed + kNumOpts + 300 &gt;= maxUnpackSize ||
-            RangeEnc_GetProcessed(&amp;p-&gt;rc) + kNumOpts * 2 &gt;= maxPackSize)
-          break;
-      }
-      else if (processed &gt;= (1 &lt;&lt; 15))
-      {
-        p-&gt;nowPos64 += nowPos32 - startPos32;
-        return CheckErrors(p);
-      }
-    }
-  }
-  p-&gt;nowPos64 += nowPos32 - startPos32;
-  return Flush(p, nowPos32);
-}
-
-#define kBigHashDicLimit ((UInt32)1 &lt;&lt; 24)
-
-static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  UInt32 beforeSize = kNumOpts;
-  Bool btMode;
-  if (!RangeEnc_Alloc(&amp;p-&gt;rc, alloc))
-    return SZ_ERROR_MEM;
-  btMode = (p-&gt;matchFinderBase.btMode != 0);
-  #ifdef COMPRESS_MF_MT
-  p-&gt;mtMode = (p-&gt;multiThread &amp;&amp; !p-&gt;fastMode &amp;&amp; btMode);
-  #endif
-
-  {
-    unsigned lclp = p-&gt;lc + p-&gt;lp;
-    if (p-&gt;litProbs == 0 || p-&gt;saveState.litProbs == 0 || p-&gt;lclp != lclp)
-    {
-      LzmaEnc_FreeLits(p, alloc);
-      p-&gt;litProbs = (CLzmaProb *)alloc-&gt;Alloc(alloc, (0x300 &lt;&lt; lclp) * sizeof(CLzmaProb));
-      p-&gt;saveState.litProbs = (CLzmaProb *)alloc-&gt;Alloc(alloc, (0x300 &lt;&lt; lclp) * sizeof(CLzmaProb));
-      if (p-&gt;litProbs == 0 || p-&gt;saveState.litProbs == 0)
-      {
-        LzmaEnc_FreeLits(p, alloc);
-        return SZ_ERROR_MEM;
-      }
-      p-&gt;lclp = lclp;
-    }
-  }
-
-  p-&gt;matchFinderBase.bigHash = (p-&gt;dictSize &gt; kBigHashDicLimit);
-
-  if (beforeSize + p-&gt;dictSize &lt; keepWindowSize)
-    beforeSize = keepWindowSize - p-&gt;dictSize;
-
-  #ifdef COMPRESS_MF_MT
-  if (p-&gt;mtMode)
-  {
-    RINOK(MatchFinderMt_Create(&amp;p-&gt;matchFinderMt, p-&gt;dictSize, beforeSize, p-&gt;numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
-    p-&gt;matchFinderObj = &amp;p-&gt;matchFinderMt;
-    MatchFinderMt_CreateVTable(&amp;p-&gt;matchFinderMt, &amp;p-&gt;matchFinder);
-  }
-  else
-  #endif
-  {
-    if (!MatchFinder_Create(&amp;p-&gt;matchFinderBase, p-&gt;dictSize, beforeSize, p-&gt;numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
-      return SZ_ERROR_MEM;
-    p-&gt;matchFinderObj = &amp;p-&gt;matchFinderBase;
-    MatchFinder_CreateVTable(&amp;p-&gt;matchFinderBase, &amp;p-&gt;matchFinder);
-  }
-  return SZ_OK;
-}
-
-void LzmaEnc_Init(CLzmaEnc *p)
-{
-  UInt32 i;
-  p-&gt;state = 0;
-  for (i = 0 ; i &lt; LZMA_NUM_REPS; i++)
-    p-&gt;reps[i] = 0;
-
-  RangeEnc_Init(&amp;p-&gt;rc);
-
-
-  for (i = 0; i &lt; kNumStates; i++)
-  {
-    UInt32 j;
-    for (j = 0; j &lt; LZMA_NUM_PB_STATES_MAX; j++)
-    {
-      p-&gt;isMatch[i][j] = kProbInitValue;
-      p-&gt;isRep0Long[i][j] = kProbInitValue;
-    }
-    p-&gt;isRep[i] = kProbInitValue;
-    p-&gt;isRepG0[i] = kProbInitValue;
-    p-&gt;isRepG1[i] = kProbInitValue;
-    p-&gt;isRepG2[i] = kProbInitValue;
-  }
-
-  {
-    UInt32 num = 0x300 &lt;&lt; (p-&gt;lp + p-&gt;lc);
-    for (i = 0; i &lt; num; i++)
-      p-&gt;litProbs[i] = kProbInitValue;
-  }
-
-  {
-    for (i = 0; i &lt; kNumLenToPosStates; i++)
-    {
-      CLzmaProb *probs = p-&gt;posSlotEncoder[i];
-      UInt32 j;
-      for (j = 0; j &lt; (1 &lt;&lt; kNumPosSlotBits); j++)
-        probs[j] = kProbInitValue;
-    }
-  }
-  {
-    for (i = 0; i &lt; kNumFullDistances - kEndPosModelIndex; i++)
-      p-&gt;posEncoders[i] = kProbInitValue;
-  }
-
-  LenEnc_Init(&amp;p-&gt;lenEnc.p);
-  LenEnc_Init(&amp;p-&gt;repLenEnc.p);
-
-  for (i = 0; i &lt; (1 &lt;&lt; kNumAlignBits); i++)
-    p-&gt;posAlignEncoder[i] = kProbInitValue;
-
-  p-&gt;optimumEndIndex = 0;
-  p-&gt;optimumCurrentIndex = 0;
-  p-&gt;additionalOffset = 0;
-
-  p-&gt;pbMask = (1 &lt;&lt; p-&gt;pb) - 1;
-  p-&gt;lpMask = (1 &lt;&lt; p-&gt;lp) - 1;
-}
-
-void LzmaEnc_InitPrices(CLzmaEnc *p)
-{
-  if (!p-&gt;fastMode)
-  {
-    FillDistancesPrices(p);
-    FillAlignPrices(p);
-  }
-
-  p-&gt;lenEnc.tableSize =
-  p-&gt;repLenEnc.tableSize =
-      p-&gt;numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
-  LenPriceEnc_UpdateTables(&amp;p-&gt;lenEnc, 1 &lt;&lt; p-&gt;pb, p-&gt;ProbPrices);
-  LenPriceEnc_UpdateTables(&amp;p-&gt;repLenEnc, 1 &lt;&lt; p-&gt;pb, p-&gt;ProbPrices);
-}
-
-static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  UInt32 i;
-  for (i = 0; i &lt; (UInt32)kDicLogSizeMaxCompress; i++)
-    if (p-&gt;dictSize &lt;= ((UInt32)1 &lt;&lt; i))
-      break;
-  p-&gt;distTableSize = i * 2;
-
-  p-&gt;finished = False;
-  p-&gt;result = SZ_OK;
-  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
-  LzmaEnc_Init(p);
-  LzmaEnc_InitPrices(p);
-  p-&gt;nowPos64 = 0;
-  return SZ_OK;
-}
-
-static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqInStream *inStream, ISeqOutStream *outStream,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  p-&gt;inStream = inStream;
-  p-&gt;rc.outStream = outStream;
-  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
-}
-
-SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
-    ISeqInStream *inStream, UInt32 keepWindowSize,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  p-&gt;inStream = inStream;
-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-}
-
-static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
-{
-  p-&gt;seqBufInStream.funcTable.Read = MyRead;
-  p-&gt;seqBufInStream.data = src;
-  p-&gt;seqBufInStream.rem = srcLen;
-}
-
-SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  LzmaEnc_SetInputBuf(p, src, srcLen);
-  p-&gt;inStream = &amp;p-&gt;seqBufInStream.funcTable;
-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-}
-
-void LzmaEnc_Finish(CLzmaEncHandle pp)
-{
-  #ifdef COMPRESS_MF_MT
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  if (p-&gt;mtMode)
-    MatchFinderMt_ReleaseStream(&amp;p-&gt;matchFinderMt);
-  #endif
-}
-
-typedef struct _CSeqOutStreamBuf
-{
-  ISeqOutStream funcTable;
-  Byte *data;
-  SizeT rem;
-  Bool overflow;
-} CSeqOutStreamBuf;
-
-static size_t MyWrite(void *pp, const void *data, size_t size)
-{
-  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
-  if (p-&gt;rem &lt; size)
-  {
-    size = p-&gt;rem;
-    p-&gt;overflow = True;
-  }
-  memcpy(p-&gt;data, data, size);
-  p-&gt;rem -= size;
-  p-&gt;data += size;
-  return size;
-}
-
-
-UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
-{
-  const CLzmaEnc *p = (CLzmaEnc *)pp;
-  return p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj);
-}
-
-const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
-{
-  const CLzmaEnc *p = (CLzmaEnc *)pp;
-  return p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - p-&gt;additionalOffset;
-}
-
-SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
-    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  UInt64 nowPos64;
-  SRes res;
-  CSeqOutStreamBuf outStream;
-
-  outStream.funcTable.Write = MyWrite;
-  outStream.data = dest;
-  outStream.rem = *destLen;
-  outStream.overflow = False;
-
-  p-&gt;writeEndMark = False;
-  p-&gt;finished = False;
-  p-&gt;result = SZ_OK;
-
-  if (reInit)
-    LzmaEnc_Init(p);
-  LzmaEnc_InitPrices(p);
-  nowPos64 = p-&gt;nowPos64;
-  RangeEnc_Init(&amp;p-&gt;rc);
-  p-&gt;rc.outStream = &amp;outStream.funcTable;
-
-  res = LzmaEnc_CodeOneBlock(pp, True, desiredPackSize, *unpackSize);
-  
-  *unpackSize = (UInt32)(p-&gt;nowPos64 - nowPos64);
-  *destLen -= outStream.rem;
-  if (outStream.overflow)
-    return SZ_ERROR_OUTPUT_EOF;
-
-  return res;
-}
-
-SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  SRes res = SZ_OK;
-
-  #ifdef COMPRESS_MF_MT
-  Byte allocaDummy[0x300];
-  int i = 0;
-  for (i = 0; i &lt; 16; i++)
-    allocaDummy[i] = (Byte)i;
-  #endif
-
-  RINOK(LzmaEnc_Prepare(pp, inStream, outStream, alloc, allocBig));
-
-  for (;;)
-  {
-    res = LzmaEnc_CodeOneBlock(pp, False, 0, 0);
-    if (res != SZ_OK || p-&gt;finished != 0)
-      break;
-    if (progress != 0)
-    {
-      res = progress-&gt;Progress(progress, p-&gt;nowPos64, RangeEnc_GetProcessed(&amp;p-&gt;rc));
-      if (res != SZ_OK)
-      {
-        res = SZ_ERROR_PROGRESS;
-        break;
-      }
-    }
-  }
-  LzmaEnc_Finish(pp);
-  return res;
-}
-
-SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  int i;
-  UInt32 dictSize = p-&gt;dictSize;
-  if (*size &lt; LZMA_PROPS_SIZE)
-    return SZ_ERROR_PARAM;
-  *size = LZMA_PROPS_SIZE;
-  props[0] = (Byte)((p-&gt;pb * 5 + p-&gt;lp) * 9 + p-&gt;lc);
-
-  for (i = 11; i &lt;= 30; i++)
-  {
-    if (dictSize &lt;= ((UInt32)2 &lt;&lt; i))
-    {
-      dictSize = (2 &lt;&lt; i);
-      break;
-    }
-    if (dictSize &lt;= ((UInt32)3 &lt;&lt; i))
-    {
-      dictSize = (3 &lt;&lt; i);
-      break;
-    }
-  }
-
-  for (i = 0; i &lt; 4; i++)
-    props[1 + i] = (Byte)(dictSize &gt;&gt; (8 * i));
-  return SZ_OK;
-}
-
-SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  SRes res;
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-
-  CSeqOutStreamBuf outStream;
-
-  LzmaEnc_SetInputBuf(p, src, srcLen);
-
-  outStream.funcTable.Write = MyWrite;
-  outStream.data = dest;
-  outStream.rem = *destLen;
-  outStream.overflow = False;
-
-  p-&gt;writeEndMark = writeEndMark;
-  res = LzmaEnc_Encode(pp, &amp;outStream.funcTable, &amp;p-&gt;seqBufInStream.funcTable,
-      progress, alloc, allocBig);
-
-  *destLen -= outStream.rem;
-  if (outStream.overflow)
-    return SZ_ERROR_OUTPUT_EOF;
-  return res;
-}
-
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
-  SRes res;
-  if (p == 0)
-    return SZ_ERROR_MEM;
-
-  res = LzmaEnc_SetProps(p, props);
-  if (res == SZ_OK)
-  {
-    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
-    if (res == SZ_OK)
-      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
-          writeEndMark, progress, alloc, allocBig);
-  }
-
-  LzmaEnc_Destroy(p, alloc, allocBig);
-  return res;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,2275 @@
+/* LzmaEnc.c -- LZMA Encoder
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaEnc.h for license options */
+
+#include &lt;string.h&gt;
+
+/* #define SHOW_STAT */
+/* #define SHOW_STAT2 */
+
+#if defined(SHOW_STAT) || defined(SHOW_STAT2)
+#include &lt;stdio.h&gt;
+#endif
+
+#include &quot;LzmaEnc.h&quot;
+
+#include &quot;LzFind.h&quot;
+#ifdef COMPRESS_MF_MT
+#include &quot;LzFindMt.h&quot;
+#endif
+
+#ifdef SHOW_STAT
+static int ttt = 0;
+#endif
+
+#define kBlockSizeMax ((1 &lt;&lt; LZMA_NUM_BLOCK_SIZE_BITS) - 1)
+
+#define kBlockSize (9 &lt;&lt; 10)
+#define kUnpackBlockSize (1 &lt;&lt; 18)
+#define kMatchArraySize (1 &lt;&lt; 21)
+#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
+
+#define kNumMaxDirectBits (31)
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+#define kProbInitValue (kBitModelTotal &gt;&gt; 1)
+
+#define kNumMoveReducingBits 4
+#define kNumBitPriceShiftBits 4
+#define kBitPrice (1 &lt;&lt; kNumBitPriceShiftBits)
+
+void LzmaEncProps_Init(CLzmaEncProps *p)
+{
+  p-&gt;level = 5;
+  p-&gt;dictSize = p-&gt;mc = 0;
+  p-&gt;lc = p-&gt;lp = p-&gt;pb = p-&gt;algo = p-&gt;fb = p-&gt;btMode = p-&gt;numHashBytes = p-&gt;numThreads = -1;
+  p-&gt;writeEndMark = 0;
+}
+
+void LzmaEncProps_Normalize(CLzmaEncProps *p)
+{
+  int level = p-&gt;level;
+  if (level &lt; 0) level = 5;
+  p-&gt;level = level;
+  if (p-&gt;dictSize == 0) p-&gt;dictSize = (level &lt;= 5 ? (1 &lt;&lt; (level * 2 + 14)) : (level == 6 ? (1 &lt;&lt; 25) : (1 &lt;&lt; 26)));
+  if (p-&gt;lc &lt; 0) p-&gt;lc = 3;
+  if (p-&gt;lp &lt; 0) p-&gt;lp = 0;
+  if (p-&gt;pb &lt; 0) p-&gt;pb = 2;
+  if (p-&gt;algo &lt; 0) p-&gt;algo = (level &lt; 5 ? 0 : 1);
+  if (p-&gt;fb &lt; 0) p-&gt;fb = (level &lt; 7 ? 32 : 64);
+  if (p-&gt;btMode &lt; 0) p-&gt;btMode = (p-&gt;algo == 0 ? 0 : 1);
+  if (p-&gt;numHashBytes &lt; 0) p-&gt;numHashBytes = 4;
+  if (p-&gt;mc == 0)  p-&gt;mc = (16 + (p-&gt;fb &gt;&gt; 1)) &gt;&gt; (p-&gt;btMode ? 0 : 1);
+  if (p-&gt;numThreads &lt; 0) p-&gt;numThreads = ((p-&gt;btMode &amp;&amp; p-&gt;algo) ? 2 : 1);
+}
+
+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
+{
+  CLzmaEncProps props = *props2;
+  LzmaEncProps_Normalize(&amp;props);
+  return props.dictSize;
+}
+
+/* #define LZMA_LOG_BSR */
+/* Define it for Intel's CPU */
+
+
+#ifdef LZMA_LOG_BSR
+
+#define kDicLogSizeMaxCompress 30
+
+#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&amp;i, (pos)); res = (i + i) + ((pos &gt;&gt; (i - 1)) &amp; 1); }
+
+UInt32 GetPosSlot1(UInt32 pos)
+{
+  UInt32 res;
+  BSR2_RET(pos, res);
+  return res;
+}
+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
+#define GetPosSlot(pos, res) { if (pos &lt; 2) res = pos; else BSR2_RET(pos, res); }
+
+#else
+
+#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
+#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
+
+void LzmaEnc_FastPosInit(Byte *g_FastPos)
+{
+  int c = 2, slotFast;
+  g_FastPos[0] = 0;
+  g_FastPos[1] = 1;
+  
+  for (slotFast = 2; slotFast &lt; kNumLogBits * 2; slotFast++)
+  {
+    UInt32 k = (1 &lt;&lt; ((slotFast &gt;&gt; 1) - 1));
+    UInt32 j;
+    for (j = 0; j &lt; k; j++, c++)
+      g_FastPos[c] = (Byte)slotFast;
+  }
+}
+
+#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) &amp; \
+  (0 - (((((UInt32)1 &lt;&lt; (kNumLogBits + 6)) - 1) - pos) &gt;&gt; 31))); \
+  res = p-&gt;g_FastPos[pos &gt;&gt; i] + (i * 2); }
+/*
+#define BSR2_RET(pos, res) { res = (pos &lt; (1 &lt;&lt; (kNumLogBits + 6))) ? \
+  p-&gt;g_FastPos[pos &gt;&gt; 6] + 12 : \
+  p-&gt;g_FastPos[pos &gt;&gt; (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
+*/
+
+#define GetPosSlot1(pos) p-&gt;g_FastPos[pos]
+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
+#define GetPosSlot(pos, res) { if (pos &lt; kNumFullDistances) res = p-&gt;g_FastPos[pos]; else BSR2_RET(pos, res); }
+
+#endif
+
+
+#define LZMA_NUM_REPS 4
+
+typedef unsigned CState;
+
+typedef struct _COptimal
+{
+  UInt32 price;
+
+  CState state;
+  int prev1IsChar;
+  int prev2;
+
+  UInt32 posPrev2;
+  UInt32 backPrev2;
+
+  UInt32 posPrev;
+  UInt32 backPrev;
+  UInt32 backs[LZMA_NUM_REPS];
+} COptimal;
+
+#define kNumOpts (1 &lt;&lt; 12)
+
+#define kNumLenToPosStates 4
+#define kNumPosSlotBits 6
+#define kDicLogSizeMin 0
+#define kDicLogSizeMax 32
+#define kDistTableSizeMax (kDicLogSizeMax * 2)
+
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
+#define kAlignMask (kAlignTableSize - 1)
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
+
+#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex / 2))
+
+#ifdef _LZMA_PROB32
+#define CLzmaProb UInt32
+#else
+#define CLzmaProb UInt16
+#endif
+
+#define LZMA_PB_MAX 4
+#define LZMA_LC_MAX 8
+#define LZMA_LP_MAX 4
+
+#define LZMA_NUM_PB_STATES_MAX (1 &lt;&lt; LZMA_PB_MAX)
+
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
+
+#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
+
+#define LZMA_MATCH_LEN_MIN 2
+#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
+
+#define kNumStates 12
+
+typedef struct
+{
+  CLzmaProb choice;
+  CLzmaProb choice2;
+  CLzmaProb low[LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumLowBits];
+  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumMidBits];
+  CLzmaProb high[kLenNumHighSymbols];
+} CLenEnc;
+
+typedef struct
+{
+  CLenEnc p;
+  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
+  UInt32 tableSize;
+  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
+} CLenPriceEnc;
+
+typedef struct _CRangeEnc
+{
+  UInt32 range;
+  Byte cache;
+  UInt64 low;
+  UInt64 cacheSize;
+  Byte *buf;
+  Byte *bufLim;
+  Byte *bufBase;
+  ISeqOutStream *outStream;
+  UInt64 processed;
+  SRes res;
+} CRangeEnc;
+
+typedef struct _CSeqInStreamBuf
+{
+  ISeqInStream funcTable;
+  const Byte *data;
+  SizeT rem;
+} CSeqInStreamBuf;
+
+static SRes MyRead(void *pp, void *data, size_t *size)
+{
+  size_t curSize = *size;
+  CSeqInStreamBuf *p = (CSeqInStreamBuf *)pp;
+  if (p-&gt;rem &lt; curSize)
+    curSize = p-&gt;rem;
+  memcpy(data, p-&gt;data, curSize);
+  p-&gt;rem -= curSize;
+  p-&gt;data += curSize;
+  *size = curSize;
+  return SZ_OK;
+}
+
+typedef struct
+{
+  CLzmaProb *litProbs;
+
+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
+  CLzmaProb isRep[kNumStates];
+  CLzmaProb isRepG0[kNumStates];
+  CLzmaProb isRepG1[kNumStates];
+  CLzmaProb isRepG2[kNumStates];
+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
+
+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 &lt;&lt; kNumPosSlotBits];
+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
+  CLzmaProb posAlignEncoder[1 &lt;&lt; kNumAlignBits];
+  
+  CLenPriceEnc lenEnc;
+  CLenPriceEnc repLenEnc;
+
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 state;
+} CSaveState;
+
+typedef struct _CLzmaEnc
+{
+  IMatchFinder matchFinder;
+  void *matchFinderObj;
+
+  #ifdef COMPRESS_MF_MT
+  Bool mtMode;
+  CMatchFinderMt matchFinderMt;
+  #endif
+
+  CMatchFinder matchFinderBase;
+
+  #ifdef COMPRESS_MF_MT
+  Byte pad[128];
+  #endif
+  
+  UInt32 optimumEndIndex;
+  UInt32 optimumCurrentIndex;
+
+  UInt32 longestMatchLength;
+  UInt32 numPairs;
+  UInt32 numAvail;
+  COptimal opt[kNumOpts];
+  
+  #ifndef LZMA_LOG_BSR
+  Byte g_FastPos[1 &lt;&lt; kNumLogBits];
+  #endif
+
+  UInt32 ProbPrices[kBitModelTotal &gt;&gt; kNumMoveReducingBits];
+  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
+  UInt32 numFastBytes;
+  UInt32 additionalOffset;
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 state;
+
+  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
+  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
+  UInt32 alignPrices[kAlignTableSize];
+  UInt32 alignPriceCount;
+
+  UInt32 distTableSize;
+
+  unsigned lc, lp, pb;
+  unsigned lpMask, pbMask;
+
+  CLzmaProb *litProbs;
+
+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
+  CLzmaProb isRep[kNumStates];
+  CLzmaProb isRepG0[kNumStates];
+  CLzmaProb isRepG1[kNumStates];
+  CLzmaProb isRepG2[kNumStates];
+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
+
+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 &lt;&lt; kNumPosSlotBits];
+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
+  CLzmaProb posAlignEncoder[1 &lt;&lt; kNumAlignBits];
+  
+  CLenPriceEnc lenEnc;
+  CLenPriceEnc repLenEnc;
+
+  unsigned lclp;
+
+  Bool fastMode;
+  
+  CRangeEnc rc;
+
+  Bool writeEndMark;
+  UInt64 nowPos64;
+  UInt32 matchPriceCount;
+  Bool finished;
+  Bool multiThread;
+
+  SRes result;
+  UInt32 dictSize;
+  UInt32 matchFinderCycles;
+
+  ISeqInStream *inStream;
+  CSeqInStreamBuf seqBufInStream;
+
+  CSaveState saveState;
+} CLzmaEnc;
+
+void LzmaEnc_SaveState(CLzmaEncHandle pp)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  CSaveState *dest = &amp;p-&gt;saveState;
+  int i;
+  dest-&gt;lenEnc = p-&gt;lenEnc;
+  dest-&gt;repLenEnc = p-&gt;repLenEnc;
+  dest-&gt;state = p-&gt;state;
+
+  for (i = 0; i &lt; kNumStates; i++)
+  {
+    memcpy(dest-&gt;isMatch[i], p-&gt;isMatch[i], sizeof(p-&gt;isMatch[i]));
+    memcpy(dest-&gt;isRep0Long[i], p-&gt;isRep0Long[i], sizeof(p-&gt;isRep0Long[i]));
+  }
+  for (i = 0; i &lt; kNumLenToPosStates; i++)
+    memcpy(dest-&gt;posSlotEncoder[i], p-&gt;posSlotEncoder[i], sizeof(p-&gt;posSlotEncoder[i]));
+  memcpy(dest-&gt;isRep, p-&gt;isRep, sizeof(p-&gt;isRep));
+  memcpy(dest-&gt;isRepG0, p-&gt;isRepG0, sizeof(p-&gt;isRepG0));
+  memcpy(dest-&gt;isRepG1, p-&gt;isRepG1, sizeof(p-&gt;isRepG1));
+  memcpy(dest-&gt;isRepG2, p-&gt;isRepG2, sizeof(p-&gt;isRepG2));
+  memcpy(dest-&gt;posEncoders, p-&gt;posEncoders, sizeof(p-&gt;posEncoders));
+  memcpy(dest-&gt;posAlignEncoder, p-&gt;posAlignEncoder, sizeof(p-&gt;posAlignEncoder));
+  memcpy(dest-&gt;reps, p-&gt;reps, sizeof(p-&gt;reps));
+  memcpy(dest-&gt;litProbs, p-&gt;litProbs, (0x300 &lt;&lt; p-&gt;lclp) * sizeof(CLzmaProb));
+}
+
+void LzmaEnc_RestoreState(CLzmaEncHandle pp)
+{
+  CLzmaEnc *dest = (CLzmaEnc *)pp;
+  const CSaveState *p = &amp;dest-&gt;saveState;
+  int i;
+  dest-&gt;lenEnc = p-&gt;lenEnc;
+  dest-&gt;repLenEnc = p-&gt;repLenEnc;
+  dest-&gt;state = p-&gt;state;
+
+  for (i = 0; i &lt; kNumStates; i++)
+  {
+    memcpy(dest-&gt;isMatch[i], p-&gt;isMatch[i], sizeof(p-&gt;isMatch[i]));
+    memcpy(dest-&gt;isRep0Long[i], p-&gt;isRep0Long[i], sizeof(p-&gt;isRep0Long[i]));
+  }
+  for (i = 0; i &lt; kNumLenToPosStates; i++)
+    memcpy(dest-&gt;posSlotEncoder[i], p-&gt;posSlotEncoder[i], sizeof(p-&gt;posSlotEncoder[i]));
+  memcpy(dest-&gt;isRep, p-&gt;isRep, sizeof(p-&gt;isRep));
+  memcpy(dest-&gt;isRepG0, p-&gt;isRepG0, sizeof(p-&gt;isRepG0));
+  memcpy(dest-&gt;isRepG1, p-&gt;isRepG1, sizeof(p-&gt;isRepG1));
+  memcpy(dest-&gt;isRepG2, p-&gt;isRepG2, sizeof(p-&gt;isRepG2));
+  memcpy(dest-&gt;posEncoders, p-&gt;posEncoders, sizeof(p-&gt;posEncoders));
+  memcpy(dest-&gt;posAlignEncoder, p-&gt;posAlignEncoder, sizeof(p-&gt;posAlignEncoder));
+  memcpy(dest-&gt;reps, p-&gt;reps, sizeof(p-&gt;reps));
+  memcpy(dest-&gt;litProbs, p-&gt;litProbs, (0x300 &lt;&lt; dest-&gt;lclp) * sizeof(CLzmaProb));
+}
+
+SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  CLzmaEncProps props = *props2;
+  LzmaEncProps_Normalize(&amp;props);
+
+  if (props.lc &gt; LZMA_LC_MAX || props.lp &gt; LZMA_LP_MAX || props.pb &gt; LZMA_PB_MAX ||
+      props.dictSize &gt; (1 &lt;&lt; kDicLogSizeMaxCompress) || props.dictSize &gt; (1 &lt;&lt; 30))
+    return SZ_ERROR_PARAM;
+  p-&gt;dictSize = props.dictSize;
+  p-&gt;matchFinderCycles = props.mc;
+  {
+    unsigned fb = props.fb;
+    if (fb &lt; 5)
+      fb = 5;
+    if (fb &gt; LZMA_MATCH_LEN_MAX)
+      fb = LZMA_MATCH_LEN_MAX;
+    p-&gt;numFastBytes = fb;
+  }
+  p-&gt;lc = props.lc;
+  p-&gt;lp = props.lp;
+  p-&gt;pb = props.pb;
+  p-&gt;fastMode = (props.algo == 0);
+  p-&gt;matchFinderBase.btMode = props.btMode;
+  {
+    UInt32 numHashBytes = 4;
+    if (props.btMode)
+    {
+      if (props.numHashBytes &lt; 2)
+        numHashBytes = 2;
+      else if (props.numHashBytes &lt; 4)
+        numHashBytes = props.numHashBytes;
+    }
+    p-&gt;matchFinderBase.numHashBytes = numHashBytes;
+  }
+
+  p-&gt;matchFinderBase.cutValue = props.mc;
+
+  p-&gt;writeEndMark = props.writeEndMark;
+
+  #ifdef COMPRESS_MF_MT
+  /*
+  if (newMultiThread != _multiThread)
+  {
+    ReleaseMatchFinder();
+    _multiThread = newMultiThread;
+  }
+  */
+  p-&gt;multiThread = (props.numThreads &gt; 1);
+  #endif
+
+  return SZ_OK;
+}
+
+static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
+static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
+static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
+static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
+
+#define IsCharState(s) ((s) &lt; 7)
+
+#define GetLenToPosState(len) (((len) &lt; kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
+
+#define kInfinityPrice (1 &lt;&lt; 30)
+
+static void RangeEnc_Construct(CRangeEnc *p)
+{
+  p-&gt;outStream = 0;
+  p-&gt;bufBase = 0;
+}
+
+#define RangeEnc_GetProcessed(p) ((p)-&gt;processed + ((p)-&gt;buf - (p)-&gt;bufBase) + (p)-&gt;cacheSize)
+
+#define RC_BUF_SIZE (1 &lt;&lt; 16)
+static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
+{
+  if (p-&gt;bufBase == 0)
+  {
+    p-&gt;bufBase = (Byte *)alloc-&gt;Alloc(alloc, RC_BUF_SIZE);
+    if (p-&gt;bufBase == 0)
+      return 0;
+    p-&gt;bufLim = p-&gt;bufBase + RC_BUF_SIZE;
+  }
+  return 1;
+}
+
+static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;bufBase);
+  p-&gt;bufBase = 0;
+}
+
+static void RangeEnc_Init(CRangeEnc *p)
+{
+  /* Stream.Init(); */
+  p-&gt;low = 0;
+  p-&gt;range = 0xFFFFFFFF;
+  p-&gt;cacheSize = 1;
+  p-&gt;cache = 0;
+
+  p-&gt;buf = p-&gt;bufBase;
+
+  p-&gt;processed = 0;
+  p-&gt;res = SZ_OK;
+}
+
+static void RangeEnc_FlushStream(CRangeEnc *p)
+{
+  size_t num;
+  if (p-&gt;res != SZ_OK)
+    return;
+  num = p-&gt;buf - p-&gt;bufBase;
+  if (num != p-&gt;outStream-&gt;Write(p-&gt;outStream, p-&gt;bufBase, num))
+    p-&gt;res = SZ_ERROR_WRITE;
+  p-&gt;processed += num;
+  p-&gt;buf = p-&gt;bufBase;
+}
+
+static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
+{
+  if ((UInt32)p-&gt;low &lt; (UInt32)0xFF000000 || (int)(p-&gt;low &gt;&gt; 32) != 0)
+  {
+    Byte temp = p-&gt;cache;
+    do
+    {
+      Byte *buf = p-&gt;buf;
+      *buf++ = (Byte)(temp + (Byte)(p-&gt;low &gt;&gt; 32));
+      p-&gt;buf = buf;
+      if (buf == p-&gt;bufLim)
+        RangeEnc_FlushStream(p);
+      temp = 0xFF;
+    }
+    while (--p-&gt;cacheSize != 0);
+    p-&gt;cache = (Byte)((UInt32)p-&gt;low &gt;&gt; 24);
+  }
+  p-&gt;cacheSize++;
+  p-&gt;low = (UInt32)p-&gt;low &lt;&lt; 8;
+}
+
+static void RangeEnc_FlushData(CRangeEnc *p)
+{
+  int i;
+  for (i = 0; i &lt; 5; i++)
+    RangeEnc_ShiftLow(p);
+}
+
+static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
+{
+  do
+  {
+    p-&gt;range &gt;&gt;= 1;
+    p-&gt;low += p-&gt;range &amp; (0 - ((value &gt;&gt; --numBits) &amp; 1));
+    if (p-&gt;range &lt; kTopValue)
+    {
+      p-&gt;range &lt;&lt;= 8;
+      RangeEnc_ShiftLow(p);
+    }
+  }
+  while (numBits != 0);
+}
+
+static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
+{
+  UInt32 ttt = *prob;
+  UInt32 newBound = (p-&gt;range &gt;&gt; kNumBitModelTotalBits) * ttt;
+  if (symbol == 0)
+  {
+    p-&gt;range = newBound;
+    ttt += (kBitModelTotal - ttt) &gt;&gt; kNumMoveBits;
+  }
+  else
+  {
+    p-&gt;low += newBound;
+    p-&gt;range -= newBound;
+    ttt -= ttt &gt;&gt; kNumMoveBits;
+  }
+  *prob = (CLzmaProb)ttt;
+  if (p-&gt;range &lt; kTopValue)
+  {
+    p-&gt;range &lt;&lt;= 8;
+    RangeEnc_ShiftLow(p);
+  }
+}
+
+static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
+{
+  symbol |= 0x100;
+  do
+  {
+    RangeEnc_EncodeBit(p, probs + (symbol &gt;&gt; 8), (symbol &gt;&gt; 7) &amp; 1);
+    symbol &lt;&lt;= 1;
+  }
+  while (symbol &lt; 0x10000);
+}
+
+static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
+{
+  UInt32 offs = 0x100;
+  symbol |= 0x100;
+  do
+  {
+    matchByte &lt;&lt;= 1;
+    RangeEnc_EncodeBit(p, probs + (offs + (matchByte &amp; offs) + (symbol &gt;&gt; 8)), (symbol &gt;&gt; 7) &amp; 1);
+    symbol &lt;&lt;= 1;
+    offs &amp;= ~(matchByte ^ symbol);
+  }
+  while (symbol &lt; 0x10000);
+}
+
+void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
+{
+  UInt32 i;
+  for (i = (1 &lt;&lt; kNumMoveReducingBits) / 2; i &lt; kBitModelTotal; i += (1 &lt;&lt; kNumMoveReducingBits))
+  {
+    const int kCyclesBits = kNumBitPriceShiftBits;
+    UInt32 w = i;
+    UInt32 bitCount = 0;
+    int j;
+    for (j = 0; j &lt; kCyclesBits; j++)
+    {
+      w = w * w;
+      bitCount &lt;&lt;= 1;
+      while (w &gt;= ((UInt32)1 &lt;&lt; 16))
+      {
+        w &gt;&gt;= 1;
+        bitCount++;
+      }
+    }
+    ProbPrices[i &gt;&gt; kNumMoveReducingBits] = ((kNumBitModelTotalBits &lt;&lt; kCyclesBits) - 15 - bitCount);
+  }
+}
+
+
+#define GET_PRICE(prob, symbol) \
+  p-&gt;ProbPrices[((prob) ^ (((-(int)(symbol))) &amp; (kBitModelTotal - 1))) &gt;&gt; kNumMoveReducingBits];
+
+#define GET_PRICEa(prob, symbol) \
+  ProbPrices[((prob) ^ ((-((int)(symbol))) &amp; (kBitModelTotal - 1))) &gt;&gt; kNumMoveReducingBits];
+
+#define GET_PRICE_0(prob) p-&gt;ProbPrices[(prob) &gt;&gt; kNumMoveReducingBits]
+#define GET_PRICE_1(prob) p-&gt;ProbPrices[((prob) ^ (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits]
+
+#define GET_PRICE_0a(prob) ProbPrices[(prob) &gt;&gt; kNumMoveReducingBits]
+#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits]
+
+static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  symbol |= 0x100;
+  do
+  {
+    price += GET_PRICEa(probs[symbol &gt;&gt; 8], (symbol &gt;&gt; 7) &amp; 1);
+    symbol &lt;&lt;= 1;
+  }
+  while (symbol &lt; 0x10000);
+  return price;
+}
+
+static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  UInt32 offs = 0x100;
+  symbol |= 0x100;
+  do
+  {
+    matchByte &lt;&lt;= 1;
+    price += GET_PRICEa(probs[offs + (matchByte &amp; offs) + (symbol &gt;&gt; 8)], (symbol &gt;&gt; 7) &amp; 1);
+    symbol &lt;&lt;= 1;
+    offs &amp;= ~(matchByte ^ symbol);
+  }
+  while (symbol &lt; 0x10000);
+  return price;
+}
+
+
+static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+{
+  UInt32 m = 1;
+  int i;
+  for (i = numBitLevels; i != 0;)
+  {
+    UInt32 bit;
+    i--;
+    bit = (symbol &gt;&gt; i) &amp; 1;
+    RangeEnc_EncodeBit(rc, probs + m, bit);
+    m = (m &lt;&lt; 1) | bit;
+  }
+}
+
+static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+{
+  UInt32 m = 1;
+  int i;
+  for (i = 0; i &lt; numBitLevels; i++)
+  {
+    UInt32 bit = symbol &amp; 1;
+    RangeEnc_EncodeBit(rc, probs + m, bit);
+    m = (m &lt;&lt; 1) | bit;
+    symbol &gt;&gt;= 1;
+  }
+}
+
+static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  symbol |= (1 &lt;&lt; numBitLevels);
+  while (symbol != 1)
+  {
+    price += GET_PRICEa(probs[symbol &gt;&gt; 1], symbol &amp; 1);
+    symbol &gt;&gt;= 1;
+  }
+  return price;
+}
+
+static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  UInt32 m = 1;
+  int i;
+  for (i = numBitLevels; i != 0; i--)
+  {
+    UInt32 bit = symbol &amp; 1;
+    symbol &gt;&gt;= 1;
+    price += GET_PRICEa(probs[m], bit);
+    m = (m &lt;&lt; 1) | bit;
+  }
+  return price;
+}
+
+
+static void LenEnc_Init(CLenEnc *p)
+{
+  unsigned i;
+  p-&gt;choice = p-&gt;choice2 = kProbInitValue;
+  for (i = 0; i &lt; (LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumLowBits); i++)
+    p-&gt;low[i] = kProbInitValue;
+  for (i = 0; i &lt; (LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumMidBits); i++)
+    p-&gt;mid[i] = kProbInitValue;
+  for (i = 0; i &lt; kLenNumHighSymbols; i++)
+    p-&gt;high[i] = kProbInitValue;
+}
+
+static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
+{
+  if (symbol &lt; kLenNumLowSymbols)
+  {
+    RangeEnc_EncodeBit(rc, &amp;p-&gt;choice, 0);
+    RcTree_Encode(rc, p-&gt;low + (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, symbol);
+  }
+  else
+  {
+    RangeEnc_EncodeBit(rc, &amp;p-&gt;choice, 1);
+    if (symbol &lt; kLenNumLowSymbols + kLenNumMidSymbols)
+    {
+      RangeEnc_EncodeBit(rc, &amp;p-&gt;choice2, 0);
+      RcTree_Encode(rc, p-&gt;mid + (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
+    }
+    else
+    {
+      RangeEnc_EncodeBit(rc, &amp;p-&gt;choice2, 1);
+      RcTree_Encode(rc, p-&gt;high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
+    }
+  }
+}
+
+static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
+{
+  UInt32 a0 = GET_PRICE_0a(p-&gt;choice);
+  UInt32 a1 = GET_PRICE_1a(p-&gt;choice);
+  UInt32 b0 = a1 + GET_PRICE_0a(p-&gt;choice2);
+  UInt32 b1 = a1 + GET_PRICE_1a(p-&gt;choice2);
+  UInt32 i = 0;
+  for (i = 0; i &lt; kLenNumLowSymbols; i++)
+  {
+    if (i &gt;= numSymbols)
+      return;
+    prices[i] = a0 + RcTree_GetPrice(p-&gt;low + (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
+  }
+  for (; i &lt; kLenNumLowSymbols + kLenNumMidSymbols; i++)
+  {
+    if (i &gt;= numSymbols)
+      return;
+    prices[i] = b0 + RcTree_GetPrice(p-&gt;mid + (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
+  }
+  for (; i &lt; numSymbols; i++)
+    prices[i] = b1 + RcTree_GetPrice(p-&gt;high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
+}
+
+static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
+{
+  LenEnc_SetPrices(&amp;p-&gt;p, posState, p-&gt;tableSize, p-&gt;prices[posState], ProbPrices);
+  p-&gt;counters[posState] = p-&gt;tableSize;
+}
+
+static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
+{
+  UInt32 posState;
+  for (posState = 0; posState &lt; numPosStates; posState++)
+    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
+}
+
+static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
+{
+  LenEnc_Encode(&amp;p-&gt;p, rc, symbol, posState);
+  if (updatePrice)
+    if (--p-&gt;counters[posState] == 0)
+      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
+}
+
+
+
+
+static void MovePos(CLzmaEnc *p, UInt32 num)
+{
+  #ifdef SHOW_STAT
+  ttt += num;
+  printf(&quot;\n MovePos %d&quot;, num);
+  #endif
+  if (num != 0)
+  {
+    p-&gt;additionalOffset += num;
+    p-&gt;matchFinder.Skip(p-&gt;matchFinderObj, num);
+  }
+}
+
+static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
+{
+  UInt32 lenRes = 0, numPairs;
+  p-&gt;numAvail = p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj);
+  numPairs = p-&gt;matchFinder.GetMatches(p-&gt;matchFinderObj, p-&gt;matches);
+  #ifdef SHOW_STAT
+  printf(&quot;\n i = %d numPairs = %d    &quot;, ttt, numPairs / 2);
+  ttt++;
+  {
+    UInt32 i;
+    for (i = 0; i &lt; numPairs; i += 2)
+      printf(&quot;%2d %6d   | &quot;, p-&gt;matches[i], p-&gt;matches[i + 1]);
+  }
+  #endif
+  if (numPairs &gt; 0)
+  {
+    lenRes = p-&gt;matches[numPairs - 2];
+    if (lenRes == p-&gt;numFastBytes)
+    {
+      const Byte *pby = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+      UInt32 distance = p-&gt;matches[numPairs - 1] + 1;
+      UInt32 numAvail = p-&gt;numAvail;
+      if (numAvail &gt; LZMA_MATCH_LEN_MAX)
+        numAvail = LZMA_MATCH_LEN_MAX;
+      {
+        const Byte *pby2 = pby - distance;
+        for (; lenRes &lt; numAvail &amp;&amp; pby[lenRes] == pby2[lenRes]; lenRes++);
+      }
+    }
+  }
+  p-&gt;additionalOffset++;
+  *numDistancePairsRes = numPairs;
+  return lenRes;
+}
+
+
+#define MakeAsChar(p) (p)-&gt;backPrev = (UInt32)(-1); (p)-&gt;prev1IsChar = False;
+#define MakeAsShortRep(p) (p)-&gt;backPrev = 0; (p)-&gt;prev1IsChar = False;
+#define IsShortRep(p) ((p)-&gt;backPrev == 0)
+
+static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
+{
+  return
+    GET_PRICE_0(p-&gt;isRepG0[state]) +
+    GET_PRICE_0(p-&gt;isRep0Long[state][posState]);
+}
+
+static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
+{
+  UInt32 price;
+  if (repIndex == 0)
+  {
+    price = GET_PRICE_0(p-&gt;isRepG0[state]);
+    price += GET_PRICE_1(p-&gt;isRep0Long[state][posState]);
+  }
+  else
+  {
+    price = GET_PRICE_1(p-&gt;isRepG0[state]);
+    if (repIndex == 1)
+      price += GET_PRICE_0(p-&gt;isRepG1[state]);
+    else
+    {
+      price += GET_PRICE_1(p-&gt;isRepG1[state]);
+      price += GET_PRICE(p-&gt;isRepG2[state], repIndex - 2);
+    }
+  }
+  return price;
+}
+
+static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
+{
+  return p-&gt;repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
+    GetPureRepPrice(p, repIndex, state, posState);
+}
+
+static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
+{
+  UInt32 posMem = p-&gt;opt[cur].posPrev;
+  UInt32 backMem = p-&gt;opt[cur].backPrev;
+  p-&gt;optimumEndIndex = cur;
+  do
+  {
+    if (p-&gt;opt[cur].prev1IsChar)
+    {
+      MakeAsChar(&amp;p-&gt;opt[posMem])
+      p-&gt;opt[posMem].posPrev = posMem - 1;
+      if (p-&gt;opt[cur].prev2)
+      {
+        p-&gt;opt[posMem - 1].prev1IsChar = False;
+        p-&gt;opt[posMem - 1].posPrev = p-&gt;opt[cur].posPrev2;
+        p-&gt;opt[posMem - 1].backPrev = p-&gt;opt[cur].backPrev2;
+      }
+    }
+    {
+      UInt32 posPrev = posMem;
+      UInt32 backCur = backMem;
+      
+      backMem = p-&gt;opt[posPrev].backPrev;
+      posMem = p-&gt;opt[posPrev].posPrev;
+      
+      p-&gt;opt[posPrev].backPrev = backCur;
+      p-&gt;opt[posPrev].posPrev = cur;
+      cur = posPrev;
+    }
+  }
+  while (cur != 0);
+  *backRes = p-&gt;opt[0].backPrev;
+  p-&gt;optimumCurrentIndex  = p-&gt;opt[0].posPrev;
+  return p-&gt;optimumCurrentIndex;
+}
+
+#define LIT_PROBS(pos, prevByte) (p-&gt;litProbs + ((((pos) &amp; p-&gt;lpMask) &lt;&lt; p-&gt;lc) + ((prevByte) &gt;&gt; (8 - p-&gt;lc))) * 0x300)
+
+static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
+{
+  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
+  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
+  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
+  UInt32 *matches;
+  const Byte *data;
+  Byte curByte, matchByte;
+  if (p-&gt;optimumEndIndex != p-&gt;optimumCurrentIndex)
+  {
+    const COptimal *opt = &amp;p-&gt;opt[p-&gt;optimumCurrentIndex];
+    UInt32 lenRes = opt-&gt;posPrev - p-&gt;optimumCurrentIndex;
+    *backRes = opt-&gt;backPrev;
+    p-&gt;optimumCurrentIndex = opt-&gt;posPrev;
+    return lenRes;
+  }
+  p-&gt;optimumCurrentIndex = p-&gt;optimumEndIndex = 0;
+  
+  if (p-&gt;additionalOffset == 0)
+    mainLen = ReadMatchDistances(p, &amp;numPairs);
+  else
+  {
+    mainLen = p-&gt;longestMatchLength;
+    numPairs = p-&gt;numPairs;
+  }
+
+  numAvail = p-&gt;numAvail;
+  if (numAvail &lt; 2)
+  {
+    *backRes = (UInt32)(-1);
+    return 1;
+  }
+  if (numAvail &gt; LZMA_MATCH_LEN_MAX)
+    numAvail = LZMA_MATCH_LEN_MAX;
+
+  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+  repMaxIndex = 0;
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+  {
+    UInt32 lenTest;
+    const Byte *data2;
+    reps[i] = p-&gt;reps[i];
+    data2 = data - (reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+    {
+      repLens[i] = 0;
+      continue;
+    }
+    for (lenTest = 2; lenTest &lt; numAvail &amp;&amp; data[lenTest] == data2[lenTest]; lenTest++);
+    repLens[i] = lenTest;
+    if (lenTest &gt; repLens[repMaxIndex])
+      repMaxIndex = i;
+  }
+  if (repLens[repMaxIndex] &gt;= p-&gt;numFastBytes)
+  {
+    UInt32 lenRes;
+    *backRes = repMaxIndex;
+    lenRes = repLens[repMaxIndex];
+    MovePos(p, lenRes - 1);
+    return lenRes;
+  }
+
+  matches = p-&gt;matches;
+  if (mainLen &gt;= p-&gt;numFastBytes)
+  {
+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
+    MovePos(p, mainLen - 1);
+    return mainLen;
+  }
+  curByte = *data;
+  matchByte = *(data - (reps[0] + 1));
+
+  if (mainLen &lt; 2 &amp;&amp; curByte != matchByte &amp;&amp; repLens[repMaxIndex] &lt; 2)
+  {
+    *backRes = (UInt32)-1;
+    return 1;
+  }
+
+  p-&gt;opt[0].state = (CState)p-&gt;state;
+
+  posState = (position &amp; p-&gt;pbMask);
+
+  {
+    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+    p-&gt;opt[1].price = GET_PRICE_0(p-&gt;isMatch[p-&gt;state][posState]) +
+        (!IsCharState(p-&gt;state) ?
+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p-&gt;ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p-&gt;ProbPrices));
+  }
+
+  MakeAsChar(&amp;p-&gt;opt[1]);
+
+  matchPrice = GET_PRICE_1(p-&gt;isMatch[p-&gt;state][posState]);
+  repMatchPrice = matchPrice + GET_PRICE_1(p-&gt;isRep[p-&gt;state]);
+
+  if (matchByte == curByte)
+  {
+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p-&gt;state, posState);
+    if (shortRepPrice &lt; p-&gt;opt[1].price)
+    {
+      p-&gt;opt[1].price = shortRepPrice;
+      MakeAsShortRep(&amp;p-&gt;opt[1]);
+    }
+  }
+  lenEnd = ((mainLen &gt;= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
+
+  if (lenEnd &lt; 2)
+  {
+    *backRes = p-&gt;opt[1].backPrev;
+    return 1;
+  }
+
+  p-&gt;opt[1].posPrev = 0;
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+    p-&gt;opt[0].backs[i] = reps[i];
+
+  len = lenEnd;
+  do
+    p-&gt;opt[len--].price = kInfinityPrice;
+  while (len &gt;= 2);
+
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+  {
+    UInt32 repLen = repLens[i];
+    UInt32 price;
+    if (repLen &lt; 2)
+      continue;
+    price = repMatchPrice + GetPureRepPrice(p, i, p-&gt;state, posState);
+    do
+    {
+      UInt32 curAndLenPrice = price + p-&gt;repLenEnc.prices[posState][repLen - 2];
+      COptimal *opt = &amp;p-&gt;opt[repLen];
+      if (curAndLenPrice &lt; opt-&gt;price)
+      {
+        opt-&gt;price = curAndLenPrice;
+        opt-&gt;posPrev = 0;
+        opt-&gt;backPrev = i;
+        opt-&gt;prev1IsChar = False;
+      }
+    }
+    while (--repLen &gt;= 2);
+  }
+
+  normalMatchPrice = matchPrice + GET_PRICE_0(p-&gt;isRep[p-&gt;state]);
+
+  len = ((repLens[0] &gt;= 2) ? repLens[0] + 1 : 2);
+  if (len &lt;= mainLen)
+  {
+    UInt32 offs = 0;
+    while (len &gt; matches[offs])
+      offs += 2;
+    for (; ; len++)
+    {
+      COptimal *opt;
+      UInt32 distance = matches[offs + 1];
+
+      UInt32 curAndLenPrice = normalMatchPrice + p-&gt;lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
+      UInt32 lenToPosState = GetLenToPosState(len);
+      if (distance &lt; kNumFullDistances)
+        curAndLenPrice += p-&gt;distancesPrices[lenToPosState][distance];
+      else
+      {
+        UInt32 slot;
+        GetPosSlot2(distance, slot);
+        curAndLenPrice += p-&gt;alignPrices[distance &amp; kAlignMask] + p-&gt;posSlotPrices[lenToPosState][slot];
+      }
+      opt = &amp;p-&gt;opt[len];
+      if (curAndLenPrice &lt; opt-&gt;price)
+      {
+        opt-&gt;price = curAndLenPrice;
+        opt-&gt;posPrev = 0;
+        opt-&gt;backPrev = distance + LZMA_NUM_REPS;
+        opt-&gt;prev1IsChar = False;
+      }
+      if (len == matches[offs])
+      {
+        offs += 2;
+        if (offs == numPairs)
+          break;
+      }
+    }
+  }
+
+  cur = 0;
+
+    #ifdef SHOW_STAT2
+    if (position &gt;= 0)
+    {
+      unsigned i;
+      printf(&quot;\n pos = %4X&quot;, position);
+      for (i = cur; i &lt;= lenEnd; i++)
+      printf(&quot;\nprice[%4X] = %d&quot;, position - cur + i, p-&gt;opt[i].price);
+    }
+    #endif
+
+  for (;;)
+  {
+    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
+    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
+    Bool nextIsChar;
+    Byte curByte, matchByte;
+    const Byte *data;
+    COptimal *curOpt;
+    COptimal *nextOpt;
+
+    cur++;
+    if (cur == lenEnd)
+      return Backward(p, backRes, cur);
+
+    newLen = ReadMatchDistances(p, &amp;numPairs);
+    if (newLen &gt;= p-&gt;numFastBytes)
+    {
+      p-&gt;numPairs = numPairs;
+      p-&gt;longestMatchLength = newLen;
+      return Backward(p, backRes, cur);
+    }
+    position++;
+    curOpt = &amp;p-&gt;opt[cur];
+    posPrev = curOpt-&gt;posPrev;
+    if (curOpt-&gt;prev1IsChar)
+    {
+      posPrev--;
+      if (curOpt-&gt;prev2)
+      {
+        state = p-&gt;opt[curOpt-&gt;posPrev2].state;
+        if (curOpt-&gt;backPrev2 &lt; LZMA_NUM_REPS)
+          state = kRepNextStates[state];
+        else
+          state = kMatchNextStates[state];
+      }
+      else
+        state = p-&gt;opt[posPrev].state;
+      state = kLiteralNextStates[state];
+    }
+    else
+      state = p-&gt;opt[posPrev].state;
+    if (posPrev == cur - 1)
+    {
+      if (IsShortRep(curOpt))
+        state = kShortRepNextStates[state];
+      else
+        state = kLiteralNextStates[state];
+    }
+    else
+    {
+      UInt32 pos;
+      const COptimal *prevOpt;
+      if (curOpt-&gt;prev1IsChar &amp;&amp; curOpt-&gt;prev2)
+      {
+        posPrev = curOpt-&gt;posPrev2;
+        pos = curOpt-&gt;backPrev2;
+        state = kRepNextStates[state];
+      }
+      else
+      {
+        pos = curOpt-&gt;backPrev;
+        if (pos &lt; LZMA_NUM_REPS)
+          state = kRepNextStates[state];
+        else
+          state = kMatchNextStates[state];
+      }
+      prevOpt = &amp;p-&gt;opt[posPrev];
+      if (pos &lt; LZMA_NUM_REPS)
+      {
+        UInt32 i;
+        reps[0] = prevOpt-&gt;backs[pos];
+        for (i = 1; i &lt;= pos; i++)
+          reps[i] = prevOpt-&gt;backs[i - 1];
+        for (; i &lt; LZMA_NUM_REPS; i++)
+          reps[i] = prevOpt-&gt;backs[i];
+      }
+      else
+      {
+        UInt32 i;
+        reps[0] = (pos - LZMA_NUM_REPS);
+        for (i = 1; i &lt; LZMA_NUM_REPS; i++)
+          reps[i] = prevOpt-&gt;backs[i - 1];
+      }
+    }
+    curOpt-&gt;state = (CState)state;
+
+    curOpt-&gt;backs[0] = reps[0];
+    curOpt-&gt;backs[1] = reps[1];
+    curOpt-&gt;backs[2] = reps[2];
+    curOpt-&gt;backs[3] = reps[3];
+
+    curPrice = curOpt-&gt;price;
+    nextIsChar = False;
+    data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+    curByte = *data;
+    matchByte = *(data - (reps[0] + 1));
+
+    posState = (position &amp; p-&gt;pbMask);
+
+    curAnd1Price = curPrice + GET_PRICE_0(p-&gt;isMatch[state][posState]);
+    {
+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+      curAnd1Price +=
+        (!IsCharState(state) ?
+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p-&gt;ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p-&gt;ProbPrices));
+    }
+
+    nextOpt = &amp;p-&gt;opt[cur + 1];
+
+    if (curAnd1Price &lt; nextOpt-&gt;price)
+    {
+      nextOpt-&gt;price = curAnd1Price;
+      nextOpt-&gt;posPrev = cur;
+      MakeAsChar(nextOpt);
+      nextIsChar = True;
+    }
+
+    matchPrice = curPrice + GET_PRICE_1(p-&gt;isMatch[state][posState]);
+    repMatchPrice = matchPrice + GET_PRICE_1(p-&gt;isRep[state]);
+    
+    if (matchByte == curByte &amp;&amp; !(nextOpt-&gt;posPrev &lt; cur &amp;&amp; nextOpt-&gt;backPrev == 0))
+    {
+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
+      if (shortRepPrice &lt;= nextOpt-&gt;price)
+      {
+        nextOpt-&gt;price = shortRepPrice;
+        nextOpt-&gt;posPrev = cur;
+        MakeAsShortRep(nextOpt);
+        nextIsChar = True;
+      }
+    }
+    numAvailFull = p-&gt;numAvail;
+    {
+      UInt32 temp = kNumOpts - 1 - cur;
+      if (temp &lt; numAvailFull)
+        numAvailFull = temp;
+    }
+
+    if (numAvailFull &lt; 2)
+      continue;
+    numAvail = (numAvailFull &lt;= p-&gt;numFastBytes ? numAvailFull : p-&gt;numFastBytes);
+
+    if (!nextIsChar &amp;&amp; matchByte != curByte) /* speed optimization */
+    {
+      /* try Literal + rep0 */
+      UInt32 temp;
+      UInt32 lenTest2;
+      const Byte *data2 = data - (reps[0] + 1);
+      UInt32 limit = p-&gt;numFastBytes + 1;
+      if (limit &gt; numAvailFull)
+        limit = numAvailFull;
+
+      for (temp = 1; temp &lt; limit &amp;&amp; data[temp] == data2[temp]; temp++);
+      lenTest2 = temp - 1;
+      if (lenTest2 &gt;= 2)
+      {
+        UInt32 state2 = kLiteralNextStates[state];
+        UInt32 posStateNext = (position + 1) &amp; p-&gt;pbMask;
+        UInt32 nextRepMatchPrice = curAnd1Price +
+            GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
+            GET_PRICE_1(p-&gt;isRep[state2]);
+        /* for (; lenTest2 &gt;= 2; lenTest2--) */
+        {
+          UInt32 curAndLenPrice;
+          COptimal *opt;
+          UInt32 offset = cur + 1 + lenTest2;
+          while (lenEnd &lt; offset)
+            p-&gt;opt[++lenEnd].price = kInfinityPrice;
+          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+          opt = &amp;p-&gt;opt[offset];
+          if (curAndLenPrice &lt; opt-&gt;price)
+          {
+            opt-&gt;price = curAndLenPrice;
+            opt-&gt;posPrev = cur + 1;
+            opt-&gt;backPrev = 0;
+            opt-&gt;prev1IsChar = True;
+            opt-&gt;prev2 = False;
+          }
+        }
+      }
+    }
+    
+    startLen = 2; /* speed optimization */
+    {
+    UInt32 repIndex;
+    for (repIndex = 0; repIndex &lt; LZMA_NUM_REPS; repIndex++)
+    {
+      UInt32 lenTest;
+      UInt32 lenTestTemp;
+      UInt32 price;
+      const Byte *data2 = data - (reps[repIndex] + 1);
+      if (data[0] != data2[0] || data[1] != data2[1])
+        continue;
+      for (lenTest = 2; lenTest &lt; numAvail &amp;&amp; data[lenTest] == data2[lenTest]; lenTest++);
+      while (lenEnd &lt; cur + lenTest)
+        p-&gt;opt[++lenEnd].price = kInfinityPrice;
+      lenTestTemp = lenTest;
+      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
+      do
+      {
+        UInt32 curAndLenPrice = price + p-&gt;repLenEnc.prices[posState][lenTest - 2];
+        COptimal *opt = &amp;p-&gt;opt[cur + lenTest];
+        if (curAndLenPrice &lt; opt-&gt;price)
+        {
+          opt-&gt;price = curAndLenPrice;
+          opt-&gt;posPrev = cur;
+          opt-&gt;backPrev = repIndex;
+          opt-&gt;prev1IsChar = False;
+        }
+      }
+      while (--lenTest &gt;= 2);
+      lenTest = lenTestTemp;
+      
+      if (repIndex == 0)
+        startLen = lenTest + 1;
+        
+      /* if (_maxMode) */
+        {
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = lenTest2 + p-&gt;numFastBytes;
+          UInt32 nextRepMatchPrice;
+          if (limit &gt; numAvailFull)
+            limit = numAvailFull;
+          for (; lenTest2 &lt; limit &amp;&amp; data[lenTest2] == data2[lenTest2]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 &gt;= 2)
+          {
+            UInt32 state2 = kRepNextStates[state];
+            UInt32 posStateNext = (position + lenTest) &amp; p-&gt;pbMask;
+            UInt32 curAndLenCharPrice =
+                price + p-&gt;repLenEnc.prices[posState][lenTest - 2] +
+                GET_PRICE_0(p-&gt;isMatch[state2][posStateNext]) +
+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                    data[lenTest], data2[lenTest], p-&gt;ProbPrices);
+            state2 = kLiteralNextStates[state2];
+            posStateNext = (position + lenTest + 1) &amp; p-&gt;pbMask;
+            nextRepMatchPrice = curAndLenCharPrice +
+                GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
+                GET_PRICE_1(p-&gt;isRep[state2]);
+            
+            /* for (; lenTest2 &gt;= 2; lenTest2--) */
+            {
+              UInt32 curAndLenPrice;
+              COptimal *opt;
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              while (lenEnd &lt; offset)
+                p-&gt;opt[++lenEnd].price = kInfinityPrice;
+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              opt = &amp;p-&gt;opt[offset];
+              if (curAndLenPrice &lt; opt-&gt;price)
+              {
+                opt-&gt;price = curAndLenPrice;
+                opt-&gt;posPrev = cur + lenTest + 1;
+                opt-&gt;backPrev = 0;
+                opt-&gt;prev1IsChar = True;
+                opt-&gt;prev2 = True;
+                opt-&gt;posPrev2 = cur;
+                opt-&gt;backPrev2 = repIndex;
+              }
+            }
+          }
+        }
+    }
+    }
+    /* for (UInt32 lenTest = 2; lenTest &lt;= newLen; lenTest++) */
+    if (newLen &gt; numAvail)
+    {
+      newLen = numAvail;
+      for (numPairs = 0; newLen &gt; matches[numPairs]; numPairs += 2);
+      matches[numPairs] = newLen;
+      numPairs += 2;
+    }
+    if (newLen &gt;= startLen)
+    {
+      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p-&gt;isRep[state]);
+      UInt32 offs, curBack, posSlot;
+      UInt32 lenTest;
+      while (lenEnd &lt; cur + newLen)
+        p-&gt;opt[++lenEnd].price = kInfinityPrice;
+
+      offs = 0;
+      while (startLen &gt; matches[offs])
+        offs += 2;
+      curBack = matches[offs + 1];
+      GetPosSlot2(curBack, posSlot);
+      for (lenTest = /*2*/ startLen; ; lenTest++)
+      {
+        UInt32 curAndLenPrice = normalMatchPrice + p-&gt;lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
+        UInt32 lenToPosState = GetLenToPosState(lenTest);
+        COptimal *opt;
+        if (curBack &lt; kNumFullDistances)
+          curAndLenPrice += p-&gt;distancesPrices[lenToPosState][curBack];
+        else
+          curAndLenPrice += p-&gt;posSlotPrices[lenToPosState][posSlot] + p-&gt;alignPrices[curBack &amp; kAlignMask];
+        
+        opt = &amp;p-&gt;opt[cur + lenTest];
+        if (curAndLenPrice &lt; opt-&gt;price)
+        {
+          opt-&gt;price = curAndLenPrice;
+          opt-&gt;posPrev = cur;
+          opt-&gt;backPrev = curBack + LZMA_NUM_REPS;
+          opt-&gt;prev1IsChar = False;
+        }
+
+        if (/*_maxMode &amp;&amp; */lenTest == matches[offs])
+        {
+          /* Try Match + Literal + Rep0 */
+          const Byte *data2 = data - (curBack + 1);
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = lenTest2 + p-&gt;numFastBytes;
+          UInt32 nextRepMatchPrice;
+          if (limit &gt; numAvailFull)
+            limit = numAvailFull;
+          for (; lenTest2 &lt; limit &amp;&amp; data[lenTest2] == data2[lenTest2]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 &gt;= 2)
+          {
+            UInt32 state2 = kMatchNextStates[state];
+            UInt32 posStateNext = (position + lenTest) &amp; p-&gt;pbMask;
+            UInt32 curAndLenCharPrice = curAndLenPrice +
+                GET_PRICE_0(p-&gt;isMatch[state2][posStateNext]) +
+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                    data[lenTest], data2[lenTest], p-&gt;ProbPrices);
+            state2 = kLiteralNextStates[state2];
+            posStateNext = (posStateNext + 1) &amp; p-&gt;pbMask;
+            nextRepMatchPrice = curAndLenCharPrice +
+                GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
+                GET_PRICE_1(p-&gt;isRep[state2]);
+            
+            /* for (; lenTest2 &gt;= 2; lenTest2--) */
+            {
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              UInt32 curAndLenPrice;
+              COptimal *opt;
+              while (lenEnd &lt; offset)
+                p-&gt;opt[++lenEnd].price = kInfinityPrice;
+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              opt = &amp;p-&gt;opt[offset];
+              if (curAndLenPrice &lt; opt-&gt;price)
+              {
+                opt-&gt;price = curAndLenPrice;
+                opt-&gt;posPrev = cur + lenTest + 1;
+                opt-&gt;backPrev = 0;
+                opt-&gt;prev1IsChar = True;
+                opt-&gt;prev2 = True;
+                opt-&gt;posPrev2 = cur;
+                opt-&gt;backPrev2 = curBack + LZMA_NUM_REPS;
+              }
+            }
+          }
+          offs += 2;
+          if (offs == numPairs)
+            break;
+          curBack = matches[offs + 1];
+          if (curBack &gt;= kNumFullDistances)
+            GetPosSlot2(curBack, posSlot);
+        }
+      }
+    }
+  }
+}
+
+#define ChangePair(smallDist, bigDist) (((bigDist) &gt;&gt; 7) &gt; (smallDist))
+
+static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
+{
+  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
+  const Byte *data;
+  const UInt32 *matches;
+
+  if (p-&gt;additionalOffset == 0)
+    mainLen = ReadMatchDistances(p, &amp;numPairs);
+  else
+  {
+    mainLen = p-&gt;longestMatchLength;
+    numPairs = p-&gt;numPairs;
+  }
+
+  numAvail = p-&gt;numAvail;
+  *backRes = (UInt32)-1;
+  if (numAvail &lt; 2)
+    return 1;
+  if (numAvail &gt; LZMA_MATCH_LEN_MAX)
+    numAvail = LZMA_MATCH_LEN_MAX;
+  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+
+  repLen = repIndex = 0;
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+  {
+    UInt32 len;
+    const Byte *data2 = data - (p-&gt;reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+      continue;
+    for (len = 2; len &lt; numAvail &amp;&amp; data[len] == data2[len]; len++);
+    if (len &gt;= p-&gt;numFastBytes)
+    {
+      *backRes = i;
+      MovePos(p, len - 1);
+      return len;
+    }
+    if (len &gt; repLen)
+    {
+      repIndex = i;
+      repLen = len;
+    }
+  }
+
+  matches = p-&gt;matches;
+  if (mainLen &gt;= p-&gt;numFastBytes)
+  {
+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
+    MovePos(p, mainLen - 1);
+    return mainLen;
+  }
+
+  mainDist = 0; /* for GCC */
+  if (mainLen &gt;= 2)
+  {
+    mainDist = matches[numPairs - 1];
+    while (numPairs &gt; 2 &amp;&amp; mainLen == matches[numPairs - 4] + 1)
+    {
+      if (!ChangePair(matches[numPairs - 3], mainDist))
+        break;
+      numPairs -= 2;
+      mainLen = matches[numPairs - 2];
+      mainDist = matches[numPairs - 1];
+    }
+    if (mainLen == 2 &amp;&amp; mainDist &gt;= 0x80)
+      mainLen = 1;
+  }
+
+  if (repLen &gt;= 2 &amp;&amp; (
+        (repLen + 1 &gt;= mainLen) ||
+        (repLen + 2 &gt;= mainLen &amp;&amp; mainDist &gt;= (1 &lt;&lt; 9)) ||
+        (repLen + 3 &gt;= mainLen &amp;&amp; mainDist &gt;= (1 &lt;&lt; 15))))
+  {
+    *backRes = repIndex;
+    MovePos(p, repLen - 1);
+    return repLen;
+  }
+  
+  if (mainLen &lt; 2 || numAvail &lt;= 2)
+    return 1;
+
+  p-&gt;longestMatchLength = ReadMatchDistances(p, &amp;p-&gt;numPairs);
+  if (p-&gt;longestMatchLength &gt;= 2)
+  {
+    UInt32 newDistance = matches[p-&gt;numPairs - 1];
+    if ((p-&gt;longestMatchLength &gt;= mainLen &amp;&amp; newDistance &lt; mainDist) ||
+        (p-&gt;longestMatchLength == mainLen + 1 &amp;&amp; !ChangePair(mainDist, newDistance)) ||
+        (p-&gt;longestMatchLength &gt; mainLen + 1) ||
+        (p-&gt;longestMatchLength + 1 &gt;= mainLen &amp;&amp; mainLen &gt;= 3 &amp;&amp; ChangePair(newDistance, mainDist)))
+      return 1;
+  }
+  
+  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+  {
+    UInt32 len, limit;
+    const Byte *data2 = data - (p-&gt;reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+      continue;
+    limit = mainLen - 1;
+    for (len = 2; len &lt; limit &amp;&amp; data[len] == data2[len]; len++);
+    if (len &gt;= limit)
+      return 1;
+  }
+  *backRes = mainDist + LZMA_NUM_REPS;
+  MovePos(p, mainLen - 2);
+  return mainLen;
+}
+
+static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
+{
+  UInt32 len;
+  RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 1);
+  RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 0);
+  p-&gt;state = kMatchNextStates[p-&gt;state];
+  len = LZMA_MATCH_LEN_MIN;
+  LenEnc_Encode2(&amp;p-&gt;lenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
+  RcTree_Encode(&amp;p-&gt;rc, p-&gt;posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 &lt;&lt; kNumPosSlotBits) - 1);
+  RangeEnc_EncodeDirectBits(&amp;p-&gt;rc, (((UInt32)1 &lt;&lt; 30) - 1) &gt;&gt; kNumAlignBits, 30 - kNumAlignBits);
+  RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posAlignEncoder, kNumAlignBits, kAlignMask);
+}
+
+static SRes CheckErrors(CLzmaEnc *p)
+{
+  if (p-&gt;result != SZ_OK)
+    return p-&gt;result;
+  if (p-&gt;rc.res != SZ_OK)
+    p-&gt;result = SZ_ERROR_WRITE;
+  if (p-&gt;matchFinderBase.result != SZ_OK)
+    p-&gt;result = SZ_ERROR_READ;
+  if (p-&gt;result != SZ_OK)
+    p-&gt;finished = True;
+  return p-&gt;result;
+}
+
+static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
+{
+  /* ReleaseMFStream(); */
+  p-&gt;finished = True;
+  if (p-&gt;writeEndMark)
+    WriteEndMarker(p, nowPos &amp; p-&gt;pbMask);
+  RangeEnc_FlushData(&amp;p-&gt;rc);
+  RangeEnc_FlushStream(&amp;p-&gt;rc);
+  return CheckErrors(p);
+}
+
+static void FillAlignPrices(CLzmaEnc *p)
+{
+  UInt32 i;
+  for (i = 0; i &lt; kAlignTableSize; i++)
+    p-&gt;alignPrices[i] = RcTree_ReverseGetPrice(p-&gt;posAlignEncoder, kNumAlignBits, i, p-&gt;ProbPrices);
+  p-&gt;alignPriceCount = 0;
+}
+
+static void FillDistancesPrices(CLzmaEnc *p)
+{
+  UInt32 tempPrices[kNumFullDistances];
+  UInt32 i, lenToPosState;
+  for (i = kStartPosModelIndex; i &lt; kNumFullDistances; i++)
+  {
+    UInt32 posSlot = GetPosSlot1(i);
+    UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
+    UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+    tempPrices[i] = RcTree_ReverseGetPrice(p-&gt;posEncoders + base - posSlot - 1, footerBits, i - base, p-&gt;ProbPrices);
+  }
+
+  for (lenToPosState = 0; lenToPosState &lt; kNumLenToPosStates; lenToPosState++)
+  {
+    UInt32 posSlot;
+    const CLzmaProb *encoder = p-&gt;posSlotEncoder[lenToPosState];
+    UInt32 *posSlotPrices = p-&gt;posSlotPrices[lenToPosState];
+    for (posSlot = 0; posSlot &lt; p-&gt;distTableSize; posSlot++)
+      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p-&gt;ProbPrices);
+    for (posSlot = kEndPosModelIndex; posSlot &lt; p-&gt;distTableSize; posSlot++)
+      posSlotPrices[posSlot] += ((((posSlot &gt;&gt; 1) - 1) - kNumAlignBits) &lt;&lt; kNumBitPriceShiftBits);
+
+    {
+      UInt32 *distancesPrices = p-&gt;distancesPrices[lenToPosState];
+      UInt32 i;
+      for (i = 0; i &lt; kStartPosModelIndex; i++)
+        distancesPrices[i] = posSlotPrices[i];
+      for (; i &lt; kNumFullDistances; i++)
+        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
+    }
+  }
+  p-&gt;matchPriceCount = 0;
+}
+
+void LzmaEnc_Construct(CLzmaEnc *p)
+{
+  RangeEnc_Construct(&amp;p-&gt;rc);
+  MatchFinder_Construct(&amp;p-&gt;matchFinderBase);
+  #ifdef COMPRESS_MF_MT
+  MatchFinderMt_Construct(&amp;p-&gt;matchFinderMt);
+  p-&gt;matchFinderMt.MatchFinder = &amp;p-&gt;matchFinderBase;
+  #endif
+
+  {
+    CLzmaEncProps props;
+    LzmaEncProps_Init(&amp;props);
+    LzmaEnc_SetProps(p, &amp;props);
+  }
+
+  #ifndef LZMA_LOG_BSR
+  LzmaEnc_FastPosInit(p-&gt;g_FastPos);
+  #endif
+
+  LzmaEnc_InitPriceTables(p-&gt;ProbPrices);
+  p-&gt;litProbs = 0;
+  p-&gt;saveState.litProbs = 0;
+}
+
+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
+{
+  void *p;
+  p = alloc-&gt;Alloc(alloc, sizeof(CLzmaEnc));
+  if (p != 0)
+    LzmaEnc_Construct((CLzmaEnc *)p);
+  return p;
+}
+
+void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;litProbs);
+  alloc-&gt;Free(alloc, p-&gt;saveState.litProbs);
+  p-&gt;litProbs = 0;
+  p-&gt;saveState.litProbs = 0;
+}
+
+void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  #ifdef COMPRESS_MF_MT
+  MatchFinderMt_Destruct(&amp;p-&gt;matchFinderMt, allocBig);
+  #endif
+  MatchFinder_Free(&amp;p-&gt;matchFinderBase, allocBig);
+  LzmaEnc_FreeLits(p, alloc);
+  RangeEnc_Free(&amp;p-&gt;rc, alloc);
+}
+
+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
+  alloc-&gt;Free(alloc, p);
+}
+
+static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
+{
+  UInt32 nowPos32, startPos32;
+  if (p-&gt;inStream != 0)
+  {
+    p-&gt;matchFinderBase.stream = p-&gt;inStream;
+    p-&gt;matchFinder.Init(p-&gt;matchFinderObj);
+    p-&gt;inStream = 0;
+  }
+
+  if (p-&gt;finished)
+    return p-&gt;result;
+  RINOK(CheckErrors(p));
+
+  nowPos32 = (UInt32)p-&gt;nowPos64;
+  startPos32 = nowPos32;
+
+  if (p-&gt;nowPos64 == 0)
+  {
+    UInt32 numPairs;
+    Byte curByte;
+    if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) == 0)
+      return Flush(p, nowPos32);
+    ReadMatchDistances(p, &amp;numPairs);
+    RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][0], 0);
+    p-&gt;state = kLiteralNextStates[p-&gt;state];
+    curByte = p-&gt;matchFinder.GetIndexByte(p-&gt;matchFinderObj, 0 - p-&gt;additionalOffset);
+    LitEnc_Encode(&amp;p-&gt;rc, p-&gt;litProbs, curByte);
+    p-&gt;additionalOffset--;
+    nowPos32++;
+  }
+
+  if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) != 0)
+  for (;;)
+  {
+    UInt32 pos, len, posState;
+
+    if (p-&gt;fastMode)
+      len = GetOptimumFast(p, &amp;pos);
+    else
+      len = GetOptimum(p, nowPos32, &amp;pos);
+
+    #ifdef SHOW_STAT2
+    printf(&quot;\n pos = %4X,   len = %d   pos = %d&quot;, nowPos32, len, pos);
+    #endif
+
+    posState = nowPos32 &amp; p-&gt;pbMask;
+    if (len == 1 &amp;&amp; pos == (UInt32)-1)
+    {
+      Byte curByte;
+      CLzmaProb *probs;
+      const Byte *data;
+
+      RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 0);
+      data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - p-&gt;additionalOffset;
+      curByte = *data;
+      probs = LIT_PROBS(nowPos32, *(data - 1));
+      if (IsCharState(p-&gt;state))
+        LitEnc_Encode(&amp;p-&gt;rc, probs, curByte);
+      else
+        LitEnc_EncodeMatched(&amp;p-&gt;rc, probs, curByte, *(data - p-&gt;reps[0] - 1));
+      p-&gt;state = kLiteralNextStates[p-&gt;state];
+    }
+    else
+    {
+      RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 1);
+      if (pos &lt; LZMA_NUM_REPS)
+      {
+        RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 1);
+        if (pos == 0)
+        {
+          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG0[p-&gt;state], 0);
+          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep0Long[p-&gt;state][posState], ((len == 1) ? 0 : 1));
+        }
+        else
+        {
+          UInt32 distance = p-&gt;reps[pos];
+          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG0[p-&gt;state], 1);
+          if (pos == 1)
+            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG1[p-&gt;state], 0);
+          else
+          {
+            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG1[p-&gt;state], 1);
+            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG2[p-&gt;state], pos - 2);
+            if (pos == 3)
+              p-&gt;reps[3] = p-&gt;reps[2];
+            p-&gt;reps[2] = p-&gt;reps[1];
+          }
+          p-&gt;reps[1] = p-&gt;reps[0];
+          p-&gt;reps[0] = distance;
+        }
+        if (len == 1)
+          p-&gt;state = kShortRepNextStates[p-&gt;state];
+        else
+        {
+          LenEnc_Encode2(&amp;p-&gt;repLenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
+          p-&gt;state = kRepNextStates[p-&gt;state];
+        }
+      }
+      else
+      {
+        UInt32 posSlot;
+        RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 0);
+        p-&gt;state = kMatchNextStates[p-&gt;state];
+        LenEnc_Encode2(&amp;p-&gt;lenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
+        pos -= LZMA_NUM_REPS;
+        GetPosSlot(pos, posSlot);
+        RcTree_Encode(&amp;p-&gt;rc, p-&gt;posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
+        
+        if (posSlot &gt;= kStartPosModelIndex)
+        {
+          UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
+          UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+          UInt32 posReduced = pos - base;
+
+          if (posSlot &lt; kEndPosModelIndex)
+            RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posEncoders + base - posSlot - 1, footerBits, posReduced);
+          else
+          {
+            RangeEnc_EncodeDirectBits(&amp;p-&gt;rc, posReduced &gt;&gt; kNumAlignBits, footerBits - kNumAlignBits);
+            RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posAlignEncoder, kNumAlignBits, posReduced &amp; kAlignMask);
+            p-&gt;alignPriceCount++;
+          }
+        }
+        p-&gt;reps[3] = p-&gt;reps[2];
+        p-&gt;reps[2] = p-&gt;reps[1];
+        p-&gt;reps[1] = p-&gt;reps[0];
+        p-&gt;reps[0] = pos;
+        p-&gt;matchPriceCount++;
+      }
+    }
+    p-&gt;additionalOffset -= len;
+    nowPos32 += len;
+    if (p-&gt;additionalOffset == 0)
+    {
+      UInt32 processed;
+      if (!p-&gt;fastMode)
+      {
+        if (p-&gt;matchPriceCount &gt;= (1 &lt;&lt; 7))
+          FillDistancesPrices(p);
+        if (p-&gt;alignPriceCount &gt;= kAlignTableSize)
+          FillAlignPrices(p);
+      }
+      if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) == 0)
+        break;
+      processed = nowPos32 - startPos32;
+      if (useLimits)
+      {
+        if (processed + kNumOpts + 300 &gt;= maxUnpackSize ||
+            RangeEnc_GetProcessed(&amp;p-&gt;rc) + kNumOpts * 2 &gt;= maxPackSize)
+          break;
+      }
+      else if (processed &gt;= (1 &lt;&lt; 15))
+      {
+        p-&gt;nowPos64 += nowPos32 - startPos32;
+        return CheckErrors(p);
+      }
+    }
+  }
+  p-&gt;nowPos64 += nowPos32 - startPos32;
+  return Flush(p, nowPos32);
+}
+
+#define kBigHashDicLimit ((UInt32)1 &lt;&lt; 24)
+
+static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  UInt32 beforeSize = kNumOpts;
+  Bool btMode;
+  if (!RangeEnc_Alloc(&amp;p-&gt;rc, alloc))
+    return SZ_ERROR_MEM;
+  btMode = (p-&gt;matchFinderBase.btMode != 0);
+  #ifdef COMPRESS_MF_MT
+  p-&gt;mtMode = (p-&gt;multiThread &amp;&amp; !p-&gt;fastMode &amp;&amp; btMode);
+  #endif
+
+  {
+    unsigned lclp = p-&gt;lc + p-&gt;lp;
+    if (p-&gt;litProbs == 0 || p-&gt;saveState.litProbs == 0 || p-&gt;lclp != lclp)
+    {
+      LzmaEnc_FreeLits(p, alloc);
+      p-&gt;litProbs = (CLzmaProb *)alloc-&gt;Alloc(alloc, (0x300 &lt;&lt; lclp) * sizeof(CLzmaProb));
+      p-&gt;saveState.litProbs = (CLzmaProb *)alloc-&gt;Alloc(alloc, (0x300 &lt;&lt; lclp) * sizeof(CLzmaProb));
+      if (p-&gt;litProbs == 0 || p-&gt;saveState.litProbs == 0)
+      {
+        LzmaEnc_FreeLits(p, alloc);
+        return SZ_ERROR_MEM;
+      }
+      p-&gt;lclp = lclp;
+    }
+  }
+
+  p-&gt;matchFinderBase.bigHash = (p-&gt;dictSize &gt; kBigHashDicLimit);
+
+  if (beforeSize + p-&gt;dictSize &lt; keepWindowSize)
+    beforeSize = keepWindowSize - p-&gt;dictSize;
+
+  #ifdef COMPRESS_MF_MT
+  if (p-&gt;mtMode)
+  {
+    RINOK(MatchFinderMt_Create(&amp;p-&gt;matchFinderMt, p-&gt;dictSize, beforeSize, p-&gt;numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
+    p-&gt;matchFinderObj = &amp;p-&gt;matchFinderMt;
+    MatchFinderMt_CreateVTable(&amp;p-&gt;matchFinderMt, &amp;p-&gt;matchFinder);
+  }
+  else
+  #endif
+  {
+    if (!MatchFinder_Create(&amp;p-&gt;matchFinderBase, p-&gt;dictSize, beforeSize, p-&gt;numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
+      return SZ_ERROR_MEM;
+    p-&gt;matchFinderObj = &amp;p-&gt;matchFinderBase;
+    MatchFinder_CreateVTable(&amp;p-&gt;matchFinderBase, &amp;p-&gt;matchFinder);
+  }
+  return SZ_OK;
+}
+
+void LzmaEnc_Init(CLzmaEnc *p)
+{
+  UInt32 i;
+  p-&gt;state = 0;
+  for (i = 0 ; i &lt; LZMA_NUM_REPS; i++)
+    p-&gt;reps[i] = 0;
+
+  RangeEnc_Init(&amp;p-&gt;rc);
+
+
+  for (i = 0; i &lt; kNumStates; i++)
+  {
+    UInt32 j;
+    for (j = 0; j &lt; LZMA_NUM_PB_STATES_MAX; j++)
+    {
+      p-&gt;isMatch[i][j] = kProbInitValue;
+      p-&gt;isRep0Long[i][j] = kProbInitValue;
+    }
+    p-&gt;isRep[i] = kProbInitValue;
+    p-&gt;isRepG0[i] = kProbInitValue;
+    p-&gt;isRepG1[i] = kProbInitValue;
+    p-&gt;isRepG2[i] = kProbInitValue;
+  }
+
+  {
+    UInt32 num = 0x300 &lt;&lt; (p-&gt;lp + p-&gt;lc);
+    for (i = 0; i &lt; num; i++)
+      p-&gt;litProbs[i] = kProbInitValue;
+  }
+
+  {
+    for (i = 0; i &lt; kNumLenToPosStates; i++)
+    {
+      CLzmaProb *probs = p-&gt;posSlotEncoder[i];
+      UInt32 j;
+      for (j = 0; j &lt; (1 &lt;&lt; kNumPosSlotBits); j++)
+        probs[j] = kProbInitValue;
+    }
+  }
+  {
+    for (i = 0; i &lt; kNumFullDistances - kEndPosModelIndex; i++)
+      p-&gt;posEncoders[i] = kProbInitValue;
+  }
+
+  LenEnc_Init(&amp;p-&gt;lenEnc.p);
+  LenEnc_Init(&amp;p-&gt;repLenEnc.p);
+
+  for (i = 0; i &lt; (1 &lt;&lt; kNumAlignBits); i++)
+    p-&gt;posAlignEncoder[i] = kProbInitValue;
+
+  p-&gt;optimumEndIndex = 0;
+  p-&gt;optimumCurrentIndex = 0;
+  p-&gt;additionalOffset = 0;
+
+  p-&gt;pbMask = (1 &lt;&lt; p-&gt;pb) - 1;
+  p-&gt;lpMask = (1 &lt;&lt; p-&gt;lp) - 1;
+}
+
+void LzmaEnc_InitPrices(CLzmaEnc *p)
+{
+  if (!p-&gt;fastMode)
+  {
+    FillDistancesPrices(p);
+    FillAlignPrices(p);
+  }
+
+  p-&gt;lenEnc.tableSize =
+  p-&gt;repLenEnc.tableSize =
+      p-&gt;numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
+  LenPriceEnc_UpdateTables(&amp;p-&gt;lenEnc, 1 &lt;&lt; p-&gt;pb, p-&gt;ProbPrices);
+  LenPriceEnc_UpdateTables(&amp;p-&gt;repLenEnc, 1 &lt;&lt; p-&gt;pb, p-&gt;ProbPrices);
+}
+
+static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  UInt32 i;
+  for (i = 0; i &lt; (UInt32)kDicLogSizeMaxCompress; i++)
+    if (p-&gt;dictSize &lt;= ((UInt32)1 &lt;&lt; i))
+      break;
+  p-&gt;distTableSize = i * 2;
+
+  p-&gt;finished = False;
+  p-&gt;result = SZ_OK;
+  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
+  LzmaEnc_Init(p);
+  LzmaEnc_InitPrices(p);
+  p-&gt;nowPos64 = 0;
+  return SZ_OK;
+}
+
+static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqInStream *inStream, ISeqOutStream *outStream,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  p-&gt;inStream = inStream;
+  p-&gt;rc.outStream = outStream;
+  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
+}
+
+SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
+    ISeqInStream *inStream, UInt32 keepWindowSize,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  p-&gt;inStream = inStream;
+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+}
+
+static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
+{
+  p-&gt;seqBufInStream.funcTable.Read = MyRead;
+  p-&gt;seqBufInStream.data = src;
+  p-&gt;seqBufInStream.rem = srcLen;
+}
+
+SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
+    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  LzmaEnc_SetInputBuf(p, src, srcLen);
+  p-&gt;inStream = &amp;p-&gt;seqBufInStream.funcTable;
+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+}
+
+void LzmaEnc_Finish(CLzmaEncHandle pp)
+{
+  #ifdef COMPRESS_MF_MT
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  if (p-&gt;mtMode)
+    MatchFinderMt_ReleaseStream(&amp;p-&gt;matchFinderMt);
+  #endif
+}
+
+typedef struct _CSeqOutStreamBuf
+{
+  ISeqOutStream funcTable;
+  Byte *data;
+  SizeT rem;
+  Bool overflow;
+} CSeqOutStreamBuf;
+
+static size_t MyWrite(void *pp, const void *data, size_t size)
+{
+  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
+  if (p-&gt;rem &lt; size)
+  {
+    size = p-&gt;rem;
+    p-&gt;overflow = True;
+  }
+  memcpy(p-&gt;data, data, size);
+  p-&gt;rem -= size;
+  p-&gt;data += size;
+  return size;
+}
+
+
+UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
+{
+  const CLzmaEnc *p = (CLzmaEnc *)pp;
+  return p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj);
+}
+
+const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
+{
+  const CLzmaEnc *p = (CLzmaEnc *)pp;
+  return p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - p-&gt;additionalOffset;
+}
+
+SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
+    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  UInt64 nowPos64;
+  SRes res;
+  CSeqOutStreamBuf outStream;
+
+  outStream.funcTable.Write = MyWrite;
+  outStream.data = dest;
+  outStream.rem = *destLen;
+  outStream.overflow = False;
+
+  p-&gt;writeEndMark = False;
+  p-&gt;finished = False;
+  p-&gt;result = SZ_OK;
+
+  if (reInit)
+    LzmaEnc_Init(p);
+  LzmaEnc_InitPrices(p);
+  nowPos64 = p-&gt;nowPos64;
+  RangeEnc_Init(&amp;p-&gt;rc);
+  p-&gt;rc.outStream = &amp;outStream.funcTable;
+
+  res = LzmaEnc_CodeOneBlock(pp, True, desiredPackSize, *unpackSize);
+  
+  *unpackSize = (UInt32)(p-&gt;nowPos64 - nowPos64);
+  *destLen -= outStream.rem;
+  if (outStream.overflow)
+    return SZ_ERROR_OUTPUT_EOF;
+
+  return res;
+}
+
+SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  SRes res = SZ_OK;
+
+  #ifdef COMPRESS_MF_MT
+  Byte allocaDummy[0x300];
+  int i = 0;
+  for (i = 0; i &lt; 16; i++)
+    allocaDummy[i] = (Byte)i;
+  #endif
+
+  RINOK(LzmaEnc_Prepare(pp, inStream, outStream, alloc, allocBig));
+
+  for (;;)
+  {
+    res = LzmaEnc_CodeOneBlock(pp, False, 0, 0);
+    if (res != SZ_OK || p-&gt;finished != 0)
+      break;
+    if (progress != 0)
+    {
+      res = progress-&gt;Progress(progress, p-&gt;nowPos64, RangeEnc_GetProcessed(&amp;p-&gt;rc));
+      if (res != SZ_OK)
+      {
+        res = SZ_ERROR_PROGRESS;
+        break;
+      }
+    }
+  }
+  LzmaEnc_Finish(pp);
+  return res;
+}
+
+SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  int i;
+  UInt32 dictSize = p-&gt;dictSize;
+  if (*size &lt; LZMA_PROPS_SIZE)
+    return SZ_ERROR_PARAM;
+  *size = LZMA_PROPS_SIZE;
+  props[0] = (Byte)((p-&gt;pb * 5 + p-&gt;lp) * 9 + p-&gt;lc);
+
+  for (i = 11; i &lt;= 30; i++)
+  {
+    if (dictSize &lt;= ((UInt32)2 &lt;&lt; i))
+    {
+      dictSize = (2 &lt;&lt; i);
+      break;
+    }
+    if (dictSize &lt;= ((UInt32)3 &lt;&lt; i))
+    {
+      dictSize = (3 &lt;&lt; i);
+      break;
+    }
+  }
+
+  for (i = 0; i &lt; 4; i++)
+    props[1 + i] = (Byte)(dictSize &gt;&gt; (8 * i));
+  return SZ_OK;
+}
+
+SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  SRes res;
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+
+  CSeqOutStreamBuf outStream;
+
+  LzmaEnc_SetInputBuf(p, src, srcLen);
+
+  outStream.funcTable.Write = MyWrite;
+  outStream.data = dest;
+  outStream.rem = *destLen;
+  outStream.overflow = False;
+
+  p-&gt;writeEndMark = writeEndMark;
+  res = LzmaEnc_Encode(pp, &amp;outStream.funcTable, &amp;p-&gt;seqBufInStream.funcTable,
+      progress, alloc, allocBig);
+
+  *destLen -= outStream.rem;
+  if (outStream.overflow)
+    return SZ_ERROR_OUTPUT_EOF;
+  return res;
+}
+
+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
+  SRes res;
+  if (p == 0)
+    return SZ_ERROR_MEM;
+
+  res = LzmaEnc_SetProps(p, props);
+  if (res == SZ_OK)
+  {
+    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
+    if (res == SZ_OK)
+      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
+          writeEndMark, progress, alloc, allocBig);
+  }
+
+  LzmaEnc_Destroy(p, alloc, allocBig);
+  return res;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,74 +0,0 @@
-/*  LzmaEnc.h -- LZMA Encoder
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#ifndef __LZMAENC_H
-#define __LZMAENC_H
-
-#include &quot;Types.h&quot;
-
-#define LZMA_PROPS_SIZE 5
-
-typedef struct _CLzmaEncProps
-{
-  int level;       /*  0 &lt;= level &lt;= 9 */
-  UInt32 dictSize; /* (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 27) for 32-bit version
-                      (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 30) for 64-bit version
-                       default = (1 &lt;&lt; 24) */
-  int lc;          /* 0 &lt;= lc &lt;= 8, default = 3 */
-  int lp;          /* 0 &lt;= lp &lt;= 4, default = 0 */
-  int pb;          /* 0 &lt;= pb &lt;= 4, default = 2 */
-  int algo;        /* 0 - fast, 1 - normal, default = 1 */
-  int fb;          /* 5 &lt;= fb &lt;= 273, default = 32 */
-  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
-  int numHashBytes; /* 2, 3 or 4, default = 4 */
-  UInt32 mc;        /* 1 &lt;= mc &lt;= (1 &lt;&lt; 30), default = 32 */
-  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
-  int numThreads;  /* 1 or 2, default = 2 */
-} CLzmaEncProps;
-
-void LzmaEncProps_Init(CLzmaEncProps *p);
-void LzmaEncProps_Normalize(CLzmaEncProps *p);
-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
-
-
-/* ---------- CLzmaEncHandle Interface ---------- */
-
-/* LzmaEnc_* functions can return the following exit codes:
-Returns:
-  SZ_OK           - OK
-  SZ_ERROR_MEM    - Memory allocation error
-  SZ_ERROR_PARAM  - Incorrect paramater in props
-  SZ_ERROR_WRITE  - Write callback error.
-  SZ_ERROR_PROGRESS - some break from progress callback
-  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
-*/
-
-typedef void * CLzmaEncHandle;
-
-CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
-void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
-SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
-SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-
-/* ---------- One Call Interface ---------- */
-
-/* LzmaEncode
-Return code:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaEnc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,74 @@
+/*  LzmaEnc.h -- LZMA Encoder
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#ifndef __LZMAENC_H
+#define __LZMAENC_H
+
+#include &quot;Types.h&quot;
+
+#define LZMA_PROPS_SIZE 5
+
+typedef struct _CLzmaEncProps
+{
+  int level;       /*  0 &lt;= level &lt;= 9 */
+  UInt32 dictSize; /* (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 27) for 32-bit version
+                      (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 30) for 64-bit version
+                       default = (1 &lt;&lt; 24) */
+  int lc;          /* 0 &lt;= lc &lt;= 8, default = 3 */
+  int lp;          /* 0 &lt;= lp &lt;= 4, default = 0 */
+  int pb;          /* 0 &lt;= pb &lt;= 4, default = 2 */
+  int algo;        /* 0 - fast, 1 - normal, default = 1 */
+  int fb;          /* 5 &lt;= fb &lt;= 273, default = 32 */
+  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
+  int numHashBytes; /* 2, 3 or 4, default = 4 */
+  UInt32 mc;        /* 1 &lt;= mc &lt;= (1 &lt;&lt; 30), default = 32 */
+  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
+  int numThreads;  /* 1 or 2, default = 2 */
+} CLzmaEncProps;
+
+void LzmaEncProps_Init(CLzmaEncProps *p);
+void LzmaEncProps_Normalize(CLzmaEncProps *p);
+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
+
+
+/* ---------- CLzmaEncHandle Interface ---------- */
+
+/* LzmaEnc_* functions can return the following exit codes:
+Returns:
+  SZ_OK           - OK
+  SZ_ERROR_MEM    - Memory allocation error
+  SZ_ERROR_PARAM  - Incorrect paramater in props
+  SZ_ERROR_WRITE  - Write callback error.
+  SZ_ERROR_PROGRESS - some break from progress callback
+  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
+*/
+
+typedef void * CLzmaEncHandle;
+
+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
+SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
+SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+/* ---------- One Call Interface ---------- */
+
+/* LzmaEncode
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,4 +0,0 @@
-EXPORTS
-  LzmaCompress
-  LzmaUncompress
-

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,4 @@
+EXPORTS
+  LzmaCompress
+  LzmaUncompress
+

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,178 +0,0 @@
-# Microsoft Developer Studio Project File - Name=&quot;LzmaLib&quot; - Package Owner=&lt;4&gt;
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE &quot;Win32 (x86) Dynamic-Link Library&quot; 0x0102
-
-CFG=LzmaLib - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;LzmaLib.mak&quot;.
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;LzmaLib.mak&quot; CFG=&quot;LzmaLib - Win32 Debug&quot;
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE &quot;LzmaLib - Win32 Release&quot; (based on &quot;Win32 (x86) Dynamic-Link Library&quot;)
-!MESSAGE &quot;LzmaLib - Win32 Debug&quot; (based on &quot;Win32 (x86) Dynamic-Link Library&quot;)
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName &quot;&quot;
-# PROP Scc_LocalPath &quot;&quot;
-CPP=cl.exe
-MTL=midl.exe
-RSC=rc.exe
-
-!IF  &quot;$(CFG)&quot; == &quot;LzmaLib - Win32 Release&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir &quot;Release&quot;
-# PROP BASE Intermediate_Dir &quot;Release&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir &quot;Release&quot;
-# PROP Intermediate_Dir &quot;Release&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /YX /FD /c
-# ADD CPP /nologo /Gr /MT /W3 /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /D &quot;COMPRESS_MF_MT&quot; /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
-# ADD MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
-# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:&quot;C:\Util\LZMA.dll&quot; /opt:NOWIN98
-# SUBTRACT LINK32 /pdb:none
-
-!ELSEIF  &quot;$(CFG)&quot; == &quot;LzmaLib - Win32 Debug&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir &quot;Debug&quot;
-# PROP BASE Intermediate_Dir &quot;Debug&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir &quot;Debug&quot;
-# PROP Intermediate_Dir &quot;Debug&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /D &quot;COMPRESS_MF_MT&quot; /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
-# ADD MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
-# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:&quot;C:\Util\LZMA.dll&quot; /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name &quot;LzmaLib - Win32 Release&quot;
-# Name &quot;LzmaLib - Win32 Debug&quot;
-# Begin Group &quot;Spec&quot;
-
-# PROP Default_Filter &quot;&quot;
-# Begin Source File
-
-SOURCE=.\LzmaLib.def
-# End Source File
-# Begin Source File
-
-SOURCE=.\LzmaLibExports.c
-# End Source File
-# End Group
-# Begin Source File
-
-SOURCE=..\Alloc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Alloc.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\IStream.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFind.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFind.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFindMt.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFindMt.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzHash.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaDec.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaDec.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaEnc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaEnc.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaLib.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaLib.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\resource.rc
-# End Source File
-# Begin Source File
-
-SOURCE=..\Threads.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Threads.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\Types.h
-# End Source File
-# End Target
-# End Project

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,178 @@
+# Microsoft Developer Studio Project File - Name=&quot;LzmaLib&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Dynamic-Link Library&quot; 0x0102
+
+CFG=LzmaLib - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;LzmaLib.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;LzmaLib.mak&quot; CFG=&quot;LzmaLib - Win32 Debug&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;LzmaLib - Win32 Release&quot; (based on &quot;Win32 (x86) Dynamic-Link Library&quot;)
+!MESSAGE &quot;LzmaLib - Win32 Debug&quot; (based on &quot;Win32 (x86) Dynamic-Link Library&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;LzmaLib - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /YX /FD /c
+# ADD CPP /nologo /Gr /MT /W3 /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /D &quot;COMPRESS_MF_MT&quot; /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
+# ADD MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:&quot;C:\Util\LZMA.dll&quot; /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;LzmaLib - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /D &quot;COMPRESS_MF_MT&quot; /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
+# ADD MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:&quot;C:\Util\LZMA.dll&quot; /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;LzmaLib - Win32 Release&quot;
+# Name &quot;LzmaLib - Win32 Debug&quot;
+# Begin Group &quot;Spec&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=.\LzmaLib.def
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaLibExports.c
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\Alloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Alloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\IStream.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzHash.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaLib.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaLib.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\resource.rc
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\Types.h
+# End Source File
+# End Target
+# End Project

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,29 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: &quot;LzmaLib&quot;=.\LzmaLib.dsp - Package Owner=&lt;4&gt;
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;4&gt;
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;3&gt;
-{{{
-}}}
-
-###############################################################################
-

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;LzmaLib&quot;=.\LzmaLib.dsp - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,14 +0,0 @@
-/* LzmaLibExports.c  -- LZMA library DLL Entry point
-2008-03-26
-Igor Pavlov
-Public domain */
-
-#include &lt;windows.h&gt;
-
-BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
-{
-  hInstance = hInstance;
-  dwReason = dwReason;
-  lpReserved = lpReserved;
-  return TRUE;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,14 @@
+/* LzmaLibExports.c  -- LZMA library DLL Entry point
+2008-03-26
+Igor Pavlov
+Public domain */
+
+#include &lt;windows.h&gt;
+
+BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
+{
+  hInstance = hInstance;
+  dwReason = dwReason;
+  lpReserved = lpReserved;
+  return TRUE;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,37 +0,0 @@
-MY_STATIC_LINK=1
-SLIB = sLZMA.lib
-PROG = LZMA.dll
-SLIBPATH = $O\$(SLIB)
-
-DEF_FILE = LzmaLib.def
-CFLAGS = $(CFLAGS) \
-  -DCOMPRESS_MF_MT \
-
-LIBS = $(LIBS) oleaut32.lib
-
-LIB_OBJS = \
-  $O\LzmaLibExports.obj \
-
-C_OBJS = \
-  $O\Alloc.obj \
-  $O\LzFind.obj \
-  $O\LzFindMt.obj \
-  $O\LzmaDec.obj \
-  $O\LzmaEnc.obj \
-  $O\LzmaLib.obj \
-  $O\Threads.obj \
-
-OBJS = \
-  $(LIB_OBJS) \
-  $(C_OBJS) \
-  $O\resource.res
-
-!include &quot;../../CPP/Build.mak&quot;
-
-$(SLIBPATH): $O $(OBJS)
-	lib -out:$(SLIBPATH) $(OBJS) $(LIBS)
-
-$(LIB_OBJS): $(*B).c
-	$(COMPL_O2)
-$(C_OBJS): ../$(*B).c
-	$(COMPL_O2)

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,37 @@
+MY_STATIC_LINK=1
+SLIB = sLZMA.lib
+PROG = LZMA.dll
+SLIBPATH = $O\$(SLIB)
+
+DEF_FILE = LzmaLib.def
+CFLAGS = $(CFLAGS) \
+  -DCOMPRESS_MF_MT \
+
+LIBS = $(LIBS) oleaut32.lib
+
+LIB_OBJS = \
+  $O\LzmaLibExports.obj \
+
+C_OBJS = \
+  $O\Alloc.obj \
+  $O\LzFind.obj \
+  $O\LzFindMt.obj \
+  $O\LzmaDec.obj \
+  $O\LzmaEnc.obj \
+  $O\LzmaLib.obj \
+  $O\Threads.obj \
+
+OBJS = \
+  $(LIB_OBJS) \
+  $(C_OBJS) \
+  $O\resource.res
+
+!include &quot;../../CPP/Build.mak&quot;
+
+$(SLIBPATH): $O $(OBJS)
+	lib -out:$(SLIBPATH) $(OBJS) $(LIBS)
+
+$(LIB_OBJS): $(*B).c
+	$(COMPL_O2)
+$(C_OBJS): ../$(*B).c
+	$(COMPL_O2)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,4 +0,0 @@
-#include &quot;../../CPP/7zip/MyVersionInfo.rc&quot;
-
-MY_VERSION_INFO_DLL(&quot;LZMA library&quot;, &quot;LZMA&quot;)
-

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib/resource.rc	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,4 @@
+#include &quot;../../CPP/7zip/MyVersionInfo.rc&quot;
+
+MY_VERSION_INFO_DLL(&quot;LZMA library&quot;, &quot;LZMA&quot;)
+

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,46 +0,0 @@
-/* LzmaLib.c -- LZMA library wrapper
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#include &quot;LzmaEnc.h&quot;
-#include &quot;LzmaDec.h&quot;
-#include &quot;Alloc.h&quot;
-#include &quot;LzmaLib.h&quot;
-
-static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
-static void SzFree(void *p, void *address) { p = p; MyFree(address); }
-static ISzAlloc g_Alloc = { SzAlloc, SzFree };
-
-MY_STDAPI LzmaCompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  srcLen,
-  unsigned char *outProps, size_t *outPropsSize,
-  int level, /* 0 &lt;= level &lt;= 9, default = 5 */
-  unsigned dictSize, /* use (1 &lt;&lt; N) or (3 &lt;&lt; N). 4 KB &lt; dictSize &lt;= 128 MB */
-  int lc, /* 0 &lt;= lc &lt;= 8, default = 3  */
-  int lp, /* 0 &lt;= lp &lt;= 4, default = 0  */
-  int pb, /* 0 &lt;= pb &lt;= 4, default = 2  */
-  int fb,  /* 5 &lt;= fb &lt;= 273, default = 32 */
-  int numThreads /* 1 or 2, default = 2 */
-)
-{
-  CLzmaEncProps props;
-  LzmaEncProps_Init(&amp;props);
-  props.level = level;
-  props.dictSize = dictSize;
-  props.lc = lc;
-  props.lp = lp;
-  props.pb = pb;
-  props.fb = fb;
-  props.numThreads = numThreads;
-
-  return LzmaEncode(dest, destLen, src, srcLen, &amp;props, outProps, outPropsSize, 0,
-      NULL, &amp;g_Alloc, &amp;g_Alloc);
-}
-
-
-MY_STDAPI LzmaUncompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  *srcLen,
-  const unsigned char *props, size_t propsSize)
-{
-  ELzmaStatus status;
-  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &amp;status, &amp;g_Alloc);
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,46 @@
+/* LzmaLib.c -- LZMA library wrapper
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include &quot;LzmaEnc.h&quot;
+#include &quot;LzmaDec.h&quot;
+#include &quot;Alloc.h&quot;
+#include &quot;LzmaLib.h&quot;
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+MY_STDAPI LzmaCompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  srcLen,
+  unsigned char *outProps, size_t *outPropsSize,
+  int level, /* 0 &lt;= level &lt;= 9, default = 5 */
+  unsigned dictSize, /* use (1 &lt;&lt; N) or (3 &lt;&lt; N). 4 KB &lt; dictSize &lt;= 128 MB */
+  int lc, /* 0 &lt;= lc &lt;= 8, default = 3  */
+  int lp, /* 0 &lt;= lp &lt;= 4, default = 0  */
+  int pb, /* 0 &lt;= pb &lt;= 4, default = 2  */
+  int fb,  /* 5 &lt;= fb &lt;= 273, default = 32 */
+  int numThreads /* 1 or 2, default = 2 */
+)
+{
+  CLzmaEncProps props;
+  LzmaEncProps_Init(&amp;props);
+  props.level = level;
+  props.dictSize = dictSize;
+  props.lc = lc;
+  props.lp = lp;
+  props.pb = pb;
+  props.fb = fb;
+  props.numThreads = numThreads;
+
+  return LzmaEncode(dest, destLen, src, srcLen, &amp;props, outProps, outPropsSize, 0,
+      NULL, &amp;g_Alloc, &amp;g_Alloc);
+}
+
+
+MY_STDAPI LzmaUncompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  *srcLen,
+  const unsigned char *props, size_t propsSize)
+{
+  ELzmaStatus status;
+  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &amp;status, &amp;g_Alloc);
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,135 +0,0 @@
-/* LzmaLib.h -- LZMA library interface
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __LZMALIB_H
-#define __LZMALIB_H
-
-#include &quot;Types.h&quot;
-
-#ifdef __cplusplus
-  #define MY_EXTERN_C extern &quot;C&quot;
-#else
-  #define MY_EXTERN_C extern
-#endif
-
-#define MY_STDAPI MY_EXTERN_C int MY_STD_CALL
-
-#define LZMA_PROPS_SIZE 5
-
-/*
-RAM requirements for LZMA:
-  for compression:   (dictSize * 11.5 + 6 MB) + state_size
-  for decompression: dictSize + state_size
-    state_size = (4 + (1.5 &lt;&lt; (lc + lp))) KB
-    by default (lc=3, lp=0), state_size = 16 KB.
-
-LZMA properties (5 bytes) format
-    Offset Size  Description
-      0     1    lc, lp and pb in encoded form.
-      1     4    dictSize (little endian).
-*/
-
-/*
-LzmaCompress
-------------
-
-outPropsSize -
-     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
-     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
-
-  LZMA Encoder will use defult values for any parameter, if it is
-  -1  for any from: level, loc, lp, pb, fb, numThreads
-   0  for dictSize
-  
-level - compression level: 0 &lt;= level &lt;= 9;
-
-  level dictSize algo  fb
-    0:    16 KB   0    32
-    1:    64 KB   0    32
-    2:   256 KB   0    32
-    3:     1 MB   0    32
-    4:     4 MB   0    32
-    5:    16 MB   1    32
-    6:    32 MB   1    32
-    7+:   64 MB   1    64
- 
-  The default value for &quot;level&quot; is 5.
-
-  algo = 0 means fast method
-  algo = 1 means normal method
-
-dictSize - The dictionary size in bytes. The maximum value is
-        128 MB = (1 &lt;&lt; 27) bytes for 32-bit version
-          1 GB = (1 &lt;&lt; 30) bytes for 64-bit version
-     The default value is 16 MB = (1 &lt;&lt; 24) bytes.
-     It's recommended to use the dictionary that is larger than 4 KB and
-     that can be calculated as (1 &lt;&lt; N) or (3 &lt;&lt; N) sizes.
-
-lc - The number of literal context bits (high bits of previous literal).
-     It can be in the range from 0 to 8. The default value is 3.
-     Sometimes lc=4 gives the gain for big files.
-
-lp - The number of literal pos bits (low bits of current position for literals).
-     It can be in the range from 0 to 4. The default value is 0.
-     The lp switch is intended for periodical data when the period is equal to 2^lp.
-     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
-     better to set lc=0, if you change lp switch.
-
-pb - The number of pos bits (low bits of current position).
-     It can be in the range from 0 to 4. The default value is 2.
-     The pb switch is intended for periodical data when the period is equal 2^pb.
-
-fb - Word size (the number of fast bytes).
-     It can be in the range from 5 to 273. The default value is 32.
-     Usually, a big number gives a little bit better compression ratio and
-     slower compression process.
-
-numThreads - The number of thereads. 1 or 2. The default value is 2.
-     Fast mode (algo = 0) can use only 1 thread.
-
-Out:
-  destLen  - processed output size
-Returns:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-MY_STDAPI LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,
-  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */
-  int level,      /* 0 &lt;= level &lt;= 9, default = 5 */
-  unsigned dictSize,  /* default = (1 &lt;&lt; 24) */
-  int lc,        /* 0 &lt;= lc &lt;= 8, default = 3  */
-  int lp,        /* 0 &lt;= lp &lt;= 4, default = 0  */
-  int pb,        /* 0 &lt;= pb &lt;= 4, default = 2  */
-  int fb,        /* 5 &lt;= fb &lt;= 273, default = 32 */
-  int numThreads /* 1 or 2, default = 2 */
-  );
-
-/*
-LzmaUncompress
---------------
-In:
-  dest     - output data
-  destLen  - output data size
-  src      - input data
-  srcLen   - input data size
-Out:
-  destLen  - processed output size
-  srcLen   - processed input size
-Returns:
-  SZ_OK                - OK
-  SZ_ERROR_DATA        - Data error
-  SZ_ERROR_MEM         - Memory allocation arror
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
-*/
-
-MY_STDAPI LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, SizeT *srcLen,
-  const unsigned char *props, size_t propsSize);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaLib.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,135 @@
+/* LzmaLib.h -- LZMA library interface
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMALIB_H
+#define __LZMALIB_H
+
+#include &quot;Types.h&quot;
+
+#ifdef __cplusplus
+  #define MY_EXTERN_C extern &quot;C&quot;
+#else
+  #define MY_EXTERN_C extern
+#endif
+
+#define MY_STDAPI MY_EXTERN_C int MY_STD_CALL
+
+#define LZMA_PROPS_SIZE 5
+
+/*
+RAM requirements for LZMA:
+  for compression:   (dictSize * 11.5 + 6 MB) + state_size
+  for decompression: dictSize + state_size
+    state_size = (4 + (1.5 &lt;&lt; (lc + lp))) KB
+    by default (lc=3, lp=0), state_size = 16 KB.
+
+LZMA properties (5 bytes) format
+    Offset Size  Description
+      0     1    lc, lp and pb in encoded form.
+      1     4    dictSize (little endian).
+*/
+
+/*
+LzmaCompress
+------------
+
+outPropsSize -
+     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
+     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
+
+  LZMA Encoder will use defult values for any parameter, if it is
+  -1  for any from: level, loc, lp, pb, fb, numThreads
+   0  for dictSize
+  
+level - compression level: 0 &lt;= level &lt;= 9;
+
+  level dictSize algo  fb
+    0:    16 KB   0    32
+    1:    64 KB   0    32
+    2:   256 KB   0    32
+    3:     1 MB   0    32
+    4:     4 MB   0    32
+    5:    16 MB   1    32
+    6:    32 MB   1    32
+    7+:   64 MB   1    64
+ 
+  The default value for &quot;level&quot; is 5.
+
+  algo = 0 means fast method
+  algo = 1 means normal method
+
+dictSize - The dictionary size in bytes. The maximum value is
+        128 MB = (1 &lt;&lt; 27) bytes for 32-bit version
+          1 GB = (1 &lt;&lt; 30) bytes for 64-bit version
+     The default value is 16 MB = (1 &lt;&lt; 24) bytes.
+     It's recommended to use the dictionary that is larger than 4 KB and
+     that can be calculated as (1 &lt;&lt; N) or (3 &lt;&lt; N) sizes.
+
+lc - The number of literal context bits (high bits of previous literal).
+     It can be in the range from 0 to 8. The default value is 3.
+     Sometimes lc=4 gives the gain for big files.
+
+lp - The number of literal pos bits (low bits of current position for literals).
+     It can be in the range from 0 to 4. The default value is 0.
+     The lp switch is intended for periodical data when the period is equal to 2^lp.
+     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
+     better to set lc=0, if you change lp switch.
+
+pb - The number of pos bits (low bits of current position).
+     It can be in the range from 0 to 4. The default value is 2.
+     The pb switch is intended for periodical data when the period is equal 2^pb.
+
+fb - Word size (the number of fast bytes).
+     It can be in the range from 5 to 273. The default value is 32.
+     Usually, a big number gives a little bit better compression ratio and
+     slower compression process.
+
+numThreads - The number of thereads. 1 or 2. The default value is 2.
+     Fast mode (algo = 0) can use only 1 thread.
+
+Out:
+  destLen  - processed output size
+Returns:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+MY_STDAPI LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,
+  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */
+  int level,      /* 0 &lt;= level &lt;= 9, default = 5 */
+  unsigned dictSize,  /* default = (1 &lt;&lt; 24) */
+  int lc,        /* 0 &lt;= lc &lt;= 8, default = 3  */
+  int lp,        /* 0 &lt;= lp &lt;= 4, default = 0  */
+  int pb,        /* 0 &lt;= pb &lt;= 4, default = 2  */
+  int fb,        /* 5 &lt;= fb &lt;= 273, default = 32 */
+  int numThreads /* 1 or 2, default = 2 */
+  );
+
+/*
+LzmaUncompress
+--------------
+In:
+  dest     - output data
+  destLen  - output data size
+  src      - input data
+  srcLen   - input data size
+Out:
+  destLen  - processed output size
+  srcLen   - processed input size
+Returns:
+  SZ_OK                - OK
+  SZ_ERROR_DATA        - Data error
+  SZ_ERROR_MEM         - Memory allocation arror
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
+*/
+
+MY_STDAPI LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, SizeT *srcLen,
+  const unsigned char *props, size_t propsSize);
+
+#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,61 +0,0 @@
-/* Lzma86Dec.c -- LZMA + x86 (BCJ) Filter Decoder
-2008-04-07
-Igor Pavlov
-Public domain */
-
-#include &quot;Lzma86Dec.h&quot;
-
-#include &quot;../Alloc.h&quot;
-#include &quot;../Bra.h&quot;
-#include &quot;../LzmaDec.h&quot;
-
-#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
-#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
-
-static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
-static void SzFree(void *p, void *address) { p = p; MyFree(address); }
-static ISzAlloc g_Alloc = { SzAlloc, SzFree };
-
-SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize)
-{
-  unsigned i;
-  if (srcLen &lt; LZMA86_HEADER_SIZE)
-    return SZ_ERROR_INPUT_EOF;
-  *unpackSize = 0;
-  for (i = 0; i &lt; sizeof(UInt64); i++)
-    *unpackSize += ((UInt64)src[LZMA86_SIZE_OFFSET + i]) &lt;&lt; (8 * i);
-  return SZ_OK;
-}
-
-SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen)
-{
-  SRes res;
-  int useFilter;
-  SizeT inSizePure;
-  ELzmaStatus status;
-
-  if (*srcLen &lt; LZMA86_HEADER_SIZE)
-    return SZ_ERROR_INPUT_EOF;
-
-  useFilter = src[0];
-
-  if (useFilter &gt; 1)
-  {
-    *destLen = 0;
-    return SZ_ERROR_UNSUPPORTED;
-  }
-
-  inSizePure = *srcLen - LZMA86_HEADER_SIZE;
-  res = LzmaDecode(dest, destLen, src + LZMA86_HEADER_SIZE, &amp;inSizePure,
-      src + 1, LZMA_PROPS_SIZE, LZMA_FINISH_ANY, &amp;status, &amp;g_Alloc);
-  *srcLen = inSizePure + LZMA86_HEADER_SIZE;
-  if (res != SZ_OK)
-    return res;
-  if (useFilter == 1)
-  {
-    UInt32 x86State;
-    x86_Convert_Init(x86State);
-    x86_Convert(dest, *destLen, 0, &amp;x86State, 0);
-  }
-  return SZ_OK;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,61 @@
+/* Lzma86Dec.c -- LZMA + x86 (BCJ) Filter Decoder
+2008-04-07
+Igor Pavlov
+Public domain */
+
+#include &quot;Lzma86Dec.h&quot;
+
+#include &quot;../Alloc.h&quot;
+#include &quot;../Bra.h&quot;
+#include &quot;../LzmaDec.h&quot;
+
+#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
+#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize)
+{
+  unsigned i;
+  if (srcLen &lt; LZMA86_HEADER_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+  *unpackSize = 0;
+  for (i = 0; i &lt; sizeof(UInt64); i++)
+    *unpackSize += ((UInt64)src[LZMA86_SIZE_OFFSET + i]) &lt;&lt; (8 * i);
+  return SZ_OK;
+}
+
+SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen)
+{
+  SRes res;
+  int useFilter;
+  SizeT inSizePure;
+  ELzmaStatus status;
+
+  if (*srcLen &lt; LZMA86_HEADER_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+
+  useFilter = src[0];
+
+  if (useFilter &gt; 1)
+  {
+    *destLen = 0;
+    return SZ_ERROR_UNSUPPORTED;
+  }
+
+  inSizePure = *srcLen - LZMA86_HEADER_SIZE;
+  res = LzmaDecode(dest, destLen, src + LZMA86_HEADER_SIZE, &amp;inSizePure,
+      src + 1, LZMA_PROPS_SIZE, LZMA_FINISH_ANY, &amp;status, &amp;g_Alloc);
+  *srcLen = inSizePure + LZMA86_HEADER_SIZE;
+  if (res != SZ_OK)
+    return res;
+  if (useFilter == 1)
+  {
+    UInt32 x86State;
+    x86_Convert_Init(x86State);
+    x86_Convert(dest, *destLen, 0, &amp;x86State, 0);
+  }
+  return SZ_OK;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,45 +0,0 @@
-/* Lzma86Dec.h -- LZMA + x86 (BCJ) Filter Decoder
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __LZMA86DEC_H
-#define __LZMA86DEC_H
-
-#include &quot;../Types.h&quot;
-
-/*
-Lzma86_GetUnpackSize:
-  In:
-    src      - input data
-    srcLen   - input data size
-  Out:
-    unpackSize - size of uncompressed stream
-  Return code:
-    SZ_OK               - OK
-    SZ_ERROR_INPUT_EOF  - Error in headers
-*/
-
-SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize);
-
-/*
-Lzma86_Decode:
-  In:
-    dest     - output data
-    destLen  - output data size
-    src      - input data
-    srcLen   - input data size
-  Out:
-    destLen  - processed output size
-    srcLen   - processed input size
-  Return code:
-    SZ_OK           - OK
-    SZ_ERROR_DATA  - Data error
-    SZ_ERROR_MEM   - Memory allocation error
-    SZ_ERROR_UNSUPPORTED - unsupported file
-    SZ_ERROR_INPUT_EOF - it needs more bytes in input buffer
-*/
-
-SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,45 @@
+/* Lzma86Dec.h -- LZMA + x86 (BCJ) Filter Decoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMA86DEC_H
+#define __LZMA86DEC_H
+
+#include &quot;../Types.h&quot;
+
+/*
+Lzma86_GetUnpackSize:
+  In:
+    src      - input data
+    srcLen   - input data size
+  Out:
+    unpackSize - size of uncompressed stream
+  Return code:
+    SZ_OK               - OK
+    SZ_ERROR_INPUT_EOF  - Error in headers
+*/
+
+SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize);
+
+/*
+Lzma86_Decode:
+  In:
+    dest     - output data
+    destLen  - output data size
+    src      - input data
+    srcLen   - input data size
+  Out:
+    destLen  - processed output size
+    srcLen   - processed input size
+  Return code:
+    SZ_OK           - OK
+    SZ_ERROR_DATA  - Data error
+    SZ_ERROR_MEM   - Memory allocation error
+    SZ_ERROR_UNSUPPORTED - unsupported file
+    SZ_ERROR_INPUT_EOF - it needs more bytes in input buffer
+*/
+
+SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,113 +0,0 @@
-/* Lzma86Enc.c -- LZMA + x86 (BCJ) Filter Encoder
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#include &lt;string.h&gt;
-
-#include &quot;Lzma86Enc.h&quot;
-
-#include &quot;../Alloc.h&quot;
-#include &quot;../Bra.h&quot;
-#include &quot;../LzmaEnc.h&quot;
-
-#define SZE_OUT_OVERFLOW SZE_DATA_ERROR
-
-static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
-static void SzFree(void *p, void *address) { p = p; MyFree(address); }
-static ISzAlloc g_Alloc = { SzAlloc, SzFree };
-
-#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
-#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
-
-int Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
-    int level, UInt32 dictSize, int filterMode)
-{
-  size_t outSize2 = *destLen;
-  Byte *filteredStream;
-  Bool useFilter;
-  int mainResult = SZ_ERROR_OUTPUT_EOF;
-  CLzmaEncProps props;
-  LzmaEncProps_Init(&amp;props);
-  props.level = level;
-  props.dictSize = dictSize;
-  
-  *destLen = 0;
-  if (outSize2 &lt; LZMA86_HEADER_SIZE)
-    return SZ_ERROR_OUTPUT_EOF;
-
-  {
-    int i;
-    UInt64 t = srcLen;
-    for (i = 0; i &lt; 8; i++, t &gt;&gt;= 8)
-      dest[LZMA86_SIZE_OFFSET + i] = (Byte)t;
-  }
-
-  filteredStream = 0;
-  useFilter = (filterMode != SZ_FILTER_NO);
-  if (useFilter)
-  {
-    if (srcLen != 0)
-    {
-      filteredStream = (Byte *)MyAlloc(srcLen);
-      if (filteredStream == 0)
-        return SZ_ERROR_MEM;
-      memcpy(filteredStream, src, srcLen);
-    }
-    {
-      UInt32 x86State;
-      x86_Convert_Init(x86State);
-      x86_Convert(filteredStream, srcLen, 0, &amp;x86State, 1);
-    }
-  }
-
-  {
-    size_t minSize = 0;
-    Bool bestIsFiltered = False;
-
-    /* passes for SZ_FILTER_AUTO:
-        0 - BCJ + LZMA
-        1 - LZMA
-        2 - BCJ + LZMA agaian, if pass 0 (BCJ + LZMA) is better.
-    */
-    int numPasses = (filterMode == SZ_FILTER_AUTO) ? 3 : 1;
-
-    int i;
-    for (i = 0; i &lt; numPasses; i++)
-    {
-      size_t outSizeProcessed = outSize2 - LZMA86_HEADER_SIZE;
-      size_t outPropsSize = 5;
-      SRes curRes;
-      Bool curModeIsFiltered = (numPasses &gt; 1 &amp;&amp; i == numPasses - 1);
-      if (curModeIsFiltered &amp;&amp; !bestIsFiltered)
-        break;
-      if (useFilter &amp;&amp; i == 0)
-        curModeIsFiltered = True;
-      
-      curRes = LzmaEncode(dest + LZMA86_HEADER_SIZE, &amp;outSizeProcessed,
-          curModeIsFiltered ? filteredStream : src, srcLen,
-          &amp;props, dest + 1, &amp;outPropsSize, 0,
-          NULL, &amp;g_Alloc, &amp;g_Alloc);
-      
-      if (curRes != SZ_ERROR_OUTPUT_EOF)
-      {
-        if (curRes != SZ_OK)
-        {
-          mainResult = curRes;
-          break;
-        }
-        if (outSizeProcessed &lt;= minSize || mainResult != SZ_OK)
-        {
-          minSize = outSizeProcessed;
-          bestIsFiltered = curModeIsFiltered;
-          mainResult = SZ_OK;
-        }
-      }
-    }
-    dest[0] = (bestIsFiltered ? 1 : 0);
-    *destLen = LZMA86_HEADER_SIZE + minSize;
-  }
-  if (useFilter)
-    MyFree(filteredStream);
-  return mainResult;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,113 @@
+/* Lzma86Enc.c -- LZMA + x86 (BCJ) Filter Encoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include &lt;string.h&gt;
+
+#include &quot;Lzma86Enc.h&quot;
+
+#include &quot;../Alloc.h&quot;
+#include &quot;../Bra.h&quot;
+#include &quot;../LzmaEnc.h&quot;
+
+#define SZE_OUT_OVERFLOW SZE_DATA_ERROR
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
+#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
+
+int Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
+    int level, UInt32 dictSize, int filterMode)
+{
+  size_t outSize2 = *destLen;
+  Byte *filteredStream;
+  Bool useFilter;
+  int mainResult = SZ_ERROR_OUTPUT_EOF;
+  CLzmaEncProps props;
+  LzmaEncProps_Init(&amp;props);
+  props.level = level;
+  props.dictSize = dictSize;
+  
+  *destLen = 0;
+  if (outSize2 &lt; LZMA86_HEADER_SIZE)
+    return SZ_ERROR_OUTPUT_EOF;
+
+  {
+    int i;
+    UInt64 t = srcLen;
+    for (i = 0; i &lt; 8; i++, t &gt;&gt;= 8)
+      dest[LZMA86_SIZE_OFFSET + i] = (Byte)t;
+  }
+
+  filteredStream = 0;
+  useFilter = (filterMode != SZ_FILTER_NO);
+  if (useFilter)
+  {
+    if (srcLen != 0)
+    {
+      filteredStream = (Byte *)MyAlloc(srcLen);
+      if (filteredStream == 0)
+        return SZ_ERROR_MEM;
+      memcpy(filteredStream, src, srcLen);
+    }
+    {
+      UInt32 x86State;
+      x86_Convert_Init(x86State);
+      x86_Convert(filteredStream, srcLen, 0, &amp;x86State, 1);
+    }
+  }
+
+  {
+    size_t minSize = 0;
+    Bool bestIsFiltered = False;
+
+    /* passes for SZ_FILTER_AUTO:
+        0 - BCJ + LZMA
+        1 - LZMA
+        2 - BCJ + LZMA agaian, if pass 0 (BCJ + LZMA) is better.
+    */
+    int numPasses = (filterMode == SZ_FILTER_AUTO) ? 3 : 1;
+
+    int i;
+    for (i = 0; i &lt; numPasses; i++)
+    {
+      size_t outSizeProcessed = outSize2 - LZMA86_HEADER_SIZE;
+      size_t outPropsSize = 5;
+      SRes curRes;
+      Bool curModeIsFiltered = (numPasses &gt; 1 &amp;&amp; i == numPasses - 1);
+      if (curModeIsFiltered &amp;&amp; !bestIsFiltered)
+        break;
+      if (useFilter &amp;&amp; i == 0)
+        curModeIsFiltered = True;
+      
+      curRes = LzmaEncode(dest + LZMA86_HEADER_SIZE, &amp;outSizeProcessed,
+          curModeIsFiltered ? filteredStream : src, srcLen,
+          &amp;props, dest + 1, &amp;outPropsSize, 0,
+          NULL, &amp;g_Alloc, &amp;g_Alloc);
+      
+      if (curRes != SZ_ERROR_OUTPUT_EOF)
+      {
+        if (curRes != SZ_OK)
+        {
+          mainResult = curRes;
+          break;
+        }
+        if (outSizeProcessed &lt;= minSize || mainResult != SZ_OK)
+        {
+          minSize = outSizeProcessed;
+          bestIsFiltered = curModeIsFiltered;
+          mainResult = SZ_OK;
+        }
+      }
+    }
+    dest[0] = (bestIsFiltered ? 1 : 0);
+    *destLen = LZMA86_HEADER_SIZE + minSize;
+  }
+  if (useFilter)
+    MyFree(filteredStream);
+  return mainResult;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,72 +0,0 @@
-/* Lzma86Enc.h -- LZMA + x86 (BCJ) Filter Encoder
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __LZMA86ENC_H
-#define __LZMA86ENC_H
-
-#include &quot;../Types.h&quot;
-
-/*
-It's an example for LZMA + x86 Filter use.
-You can use .lzma86 extension, if you write that stream to file.
-.lzma86 header adds one additional byte to standard .lzma header.
-.lzma86 header (14 bytes):
-  Offset Size  Description
-    0     1    = 0 - no filter,
-               = 1 - x86 filter
-    1     1    lc, lp and pb in encoded form
-    2     4    dictSize (little endian)
-    6     8    uncompressed size (little endian)
-
-
-Lzma86_Encode
--------------
-level - compression level: 0 &lt;= level &lt;= 9, the default value for &quot;level&quot; is 5.
-
-
-dictSize - The dictionary size in bytes. The maximum value is
-        128 MB = (1 &lt;&lt; 27) bytes for 32-bit version
-          1 GB = (1 &lt;&lt; 30) bytes for 64-bit version
-     The default value is 16 MB = (1 &lt;&lt; 24) bytes, for level = 5.
-     It's recommended to use the dictionary that is larger than 4 KB and
-     that can be calculated as (1 &lt;&lt; N) or (3 &lt;&lt; N) sizes.
-     For better compression ratio dictSize must be &gt;= inSize.
-
-filterMode:
-    SZ_FILTER_NO   - no Filter
-    SZ_FILTER_YES  - x86 Filter
-    SZ_FILTER_AUTO - it tries both alternatives to select best.
-              Encoder will use 2 or 3 passes:
-              2 passes when FILTER_NO provides better compression.
-              3 passes when FILTER_YES provides better compression.
-
-Lzma86Encode allocates Data with MyAlloc functions.
-RAM Requirements for compressing:
-  RamSize = dictionarySize * 11.5 + 6MB + FilterBlockSize
-      filterMode     FilterBlockSize
-     SZ_FILTER_NO         0
-     SZ_FILTER_YES      inSize
-     SZ_FILTER_AUTO     inSize
-
-
-Return code:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-enum ESzFilterMode
-{
-  SZ_FILTER_NO,
-  SZ_FILTER_YES,
-  SZ_FILTER_AUTO
-};
-
-SRes Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
-    int level, UInt32 dictSize, int filterMode);
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,72 @@
+/* Lzma86Enc.h -- LZMA + x86 (BCJ) Filter Encoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMA86ENC_H
+#define __LZMA86ENC_H
+
+#include &quot;../Types.h&quot;
+
+/*
+It's an example for LZMA + x86 Filter use.
+You can use .lzma86 extension, if you write that stream to file.
+.lzma86 header adds one additional byte to standard .lzma header.
+.lzma86 header (14 bytes):
+  Offset Size  Description
+    0     1    = 0 - no filter,
+               = 1 - x86 filter
+    1     1    lc, lp and pb in encoded form
+    2     4    dictSize (little endian)
+    6     8    uncompressed size (little endian)
+
+
+Lzma86_Encode
+-------------
+level - compression level: 0 &lt;= level &lt;= 9, the default value for &quot;level&quot; is 5.
+
+
+dictSize - The dictionary size in bytes. The maximum value is
+        128 MB = (1 &lt;&lt; 27) bytes for 32-bit version
+          1 GB = (1 &lt;&lt; 30) bytes for 64-bit version
+     The default value is 16 MB = (1 &lt;&lt; 24) bytes, for level = 5.
+     It's recommended to use the dictionary that is larger than 4 KB and
+     that can be calculated as (1 &lt;&lt; N) or (3 &lt;&lt; N) sizes.
+     For better compression ratio dictSize must be &gt;= inSize.
+
+filterMode:
+    SZ_FILTER_NO   - no Filter
+    SZ_FILTER_YES  - x86 Filter
+    SZ_FILTER_AUTO - it tries both alternatives to select best.
+              Encoder will use 2 or 3 passes:
+              2 passes when FILTER_NO provides better compression.
+              3 passes when FILTER_YES provides better compression.
+
+Lzma86Encode allocates Data with MyAlloc functions.
+RAM Requirements for compressing:
+  RamSize = dictionarySize * 11.5 + 6MB + FilterBlockSize
+      filterMode     FilterBlockSize
+     SZ_FILTER_NO         0
+     SZ_FILTER_YES      inSize
+     SZ_FILTER_AUTO     inSize
+
+
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+enum ESzFilterMode
+{
+  SZ_FILTER_NO,
+  SZ_FILTER_YES,
+  SZ_FILTER_AUTO
+};
+
+SRes Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
+    int level, UInt32 dictSize, int filterMode);
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,311 +0,0 @@
-/* LzmaUtil.c -- Test application for LZMA compression
-2008-08-05
-Igor Pavlov
-public domain */
-
-#define _CRT_SECURE_NO_WARNINGS
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;../LzmaDec.h&quot;
-#include &quot;../LzmaEnc.h&quot;
-#include &quot;../Alloc.h&quot;
-
-const char *kCantReadMessage = &quot;Can not read input file&quot;;
-const char *kCantWriteMessage = &quot;Can not write output file&quot;;
-const char *kCantAllocateMessage = &quot;Can not allocate memory&quot;;
-const char *kDataErrorMessage = &quot;Data error&quot;;
-
-static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
-static void SzFree(void *p, void *address) {  p = p; MyFree(address); }
-static ISzAlloc g_Alloc = { SzAlloc, SzFree };
-
-#define kInBufferSize (1 &lt;&lt; 15)
-#define kOutBufferSize (1 &lt;&lt; 15)
-
-unsigned char g_InBuffer[kInBufferSize];
-unsigned char g_OutBuffer[kOutBufferSize];
-
-size_t MyReadFile(FILE *file, void *data, size_t size)
-  { return fread(data, 1, size, file); }
-
-int MyReadFileAndCheck(FILE *file, void *data, size_t size)
-  { return (MyReadFile(file, data, size) == size); }
-
-size_t MyWriteFile(FILE *file, const void *data, size_t size)
-{
-  if (size == 0)
-    return 0;
-  return fwrite(data, 1, size, file);
-}
-
-int MyWriteFileAndCheck(FILE *file, const void *data, size_t size)
-  { return (MyWriteFile(file, data, size) == size); }
-
-long MyGetFileLength(FILE *file)
-{
-  long length;
-  fseek(file, 0, SEEK_END);
-  length = ftell(file);
-  fseek(file, 0, SEEK_SET);
-  return length;
-}
-
-void PrintHelp(char *buffer)
-{
-  strcat(buffer, &quot;\nLZMA Utility 4.58 Copyright (c) 1999-2008 Igor Pavlov  2008-04-11\n&quot;
-      &quot;\nUsage:  lzma &lt;e|d&gt; inputFile outputFile\n&quot;
-             &quot;  e: encode file\n&quot;
-             &quot;  d: decode file\n&quot;);
-}
-
-int PrintError(char *buffer, const char *message)
-{
-  strcat(buffer, &quot;\nError: &quot;);
-  strcat(buffer, message);
-  strcat(buffer, &quot;\n&quot;);
-  return 1;
-}
-
-int PrintErrorNumber(char *buffer, SRes val)
-{
-  sprintf(buffer + strlen(buffer), &quot;\nError code: %x\n&quot;, (unsigned)val);
-  return 1;
-}
-
-int PrintUserError(char *buffer)
-{
-  return PrintError(buffer, &quot;Incorrect command&quot;);
-}
-
-#define IN_BUF_SIZE (1 &lt;&lt; 16)
-#define OUT_BUF_SIZE (1 &lt;&lt; 16)
-
-static int Decode(FILE *inFile, FILE *outFile, char *rs)
-{
-  UInt64 unpackSize;
-  int thereIsSize; /* = 1, if there is uncompressed size in headers */
-  int i;
-  int res = 0;
-  
-  CLzmaDec state;
-
-  /* header: 5 bytes of LZMA properties and 8 bytes of uncompressed size */
-  unsigned char header[LZMA_PROPS_SIZE + 8];
-
-  /* Read and parse header */
-
-  if (!MyReadFileAndCheck(inFile, header, sizeof(header)))
-    return PrintError(rs, kCantReadMessage);
-
-  unpackSize = 0;
-  thereIsSize = 0;
-  for (i = 0; i &lt; 8; i++)
-  {
-    unsigned char b = header[LZMA_PROPS_SIZE + i];
-    if (b != 0xFF)
-      thereIsSize = 1;
-    unpackSize += (UInt64)b &lt;&lt; (i * 8);
-  }
-
-  LzmaDec_Construct(&amp;state);
-  res = LzmaDec_Allocate(&amp;state, header, LZMA_PROPS_SIZE, &amp;g_Alloc);
-  if (res != SZ_OK)
-    return res;
-  {
-    Byte inBuf[IN_BUF_SIZE];
-    Byte outBuf[OUT_BUF_SIZE];
-    size_t inPos = 0, inSize = 0, outPos = 0;
-    LzmaDec_Init(&amp;state);
-    for (;;)
-    {
-      if (inPos == inSize)
-      {
-        inSize = MyReadFile(inFile, inBuf, IN_BUF_SIZE);
-        inPos = 0;
-      }
-      {
-        SizeT inProcessed = inSize - inPos;
-        SizeT outProcessed = OUT_BUF_SIZE - outPos;
-        ELzmaFinishMode finishMode = LZMA_FINISH_ANY;
-        ELzmaStatus status;
-        if (thereIsSize &amp;&amp; outProcessed &gt; unpackSize)
-        {
-          outProcessed = (SizeT)unpackSize;
-          finishMode = LZMA_FINISH_END;
-        }
-
-        res = LzmaDec_DecodeToBuf(&amp;state, outBuf + outPos, &amp;outProcessed,
-            inBuf + inPos, &amp;inProcessed, finishMode, &amp;status);
-        inPos += (UInt32)inProcessed;
-        outPos += outProcessed;
-        unpackSize -= outProcessed;
-
-        if (outFile != 0)
-          MyWriteFile(outFile, outBuf, outPos);
-        outPos = 0;
-
-        if (res != SZ_OK || thereIsSize &amp;&amp; unpackSize == 0)
-          break;
-
-        if (inProcessed == 0 &amp;&amp; outProcessed == 0)
-        {
-          if (thereIsSize || status != LZMA_STATUS_FINISHED_WITH_MARK)
-            res = SZ_ERROR_DATA;
-          break;
-        }
-      }
-    }
-  }
-
-  LzmaDec_Free(&amp;state, &amp;g_Alloc);
-  return res;
-}
-
-typedef struct _CFileSeqInStream
-{
-  ISeqInStream funcTable;
-  FILE *file;
-} CFileSeqInStream;
-
-static SRes MyRead(void *p, void *buf, size_t *size)
-{
-  if (*size == 0)
-    return SZ_OK;
-  *size = MyReadFile(((CFileSeqInStream*)p)-&gt;file, buf, *size);
-  /*
-  if (*size == 0)
-    return SZE_FAIL;
-  */
-  return SZ_OK;
-}
-
-typedef struct _CFileSeqOutStream
-{
-  ISeqOutStream funcTable;
-  FILE *file;
-} CFileSeqOutStream;
-
-static size_t MyWrite(void *pp, const void *buf, size_t size)
-{
-  return MyWriteFile(((CFileSeqOutStream *)pp)-&gt;file, buf, size);
-}
-
-static SRes Encode(FILE *inFile, FILE *outFile, char *rs)
-{
-  CLzmaEncHandle enc;
-  SRes res;
-  CFileSeqInStream inStream;
-  CFileSeqOutStream outStream;
-  CLzmaEncProps props;
-
-  enc = LzmaEnc_Create(&amp;g_Alloc);
-  if (enc == 0)
-    return SZ_ERROR_MEM;
-
-  inStream.funcTable.Read = MyRead;
-  inStream.file = inFile;
-  outStream.funcTable.Write = MyWrite;
-  outStream.file = outFile;
-
-  LzmaEncProps_Init(&amp;props);
-  res = LzmaEnc_SetProps(enc, &amp;props);
-
-  if (res == SZ_OK)
-  {
-    Byte header[LZMA_PROPS_SIZE + 8];
-    size_t headerSize = LZMA_PROPS_SIZE;
-    UInt64 fileSize;
-    int i;
-
-    res = LzmaEnc_WriteProperties(enc, header, &amp;headerSize);
-    fileSize = MyGetFileLength(inFile);
-    for (i = 0; i &lt; 8; i++)
-      header[headerSize++] = (Byte)(fileSize &gt;&gt; (8 * i));
-    if (!MyWriteFileAndCheck(outFile, header, headerSize))
-      return PrintError(rs, &quot;writing error&quot;);
-
-    if (res == SZ_OK)
-      res = LzmaEnc_Encode(enc, &amp;outStream.funcTable, &amp;inStream.funcTable,
-        NULL, &amp;g_Alloc, &amp;g_Alloc);
-  }
-  LzmaEnc_Destroy(enc, &amp;g_Alloc, &amp;g_Alloc);
-  return res;
-}
-
-int main2(int numArgs, const char *args[], char *rs)
-{
-  FILE *inFile = 0;
-  FILE *outFile = 0;
-  char c;
-  int res;
-  int encodeMode;
-
-  if (numArgs == 1)
-  {
-    PrintHelp(rs);
-    return 0;
-  }
-
-  if (numArgs &lt; 3 || numArgs &gt; 4 || strlen(args[1]) != 1)
-    return PrintUserError(rs);
-
-  c = args[1][0];
-  encodeMode = (c == 'e' || c == 'E');
-  if (!encodeMode &amp;&amp; c != 'd' &amp;&amp; c != 'D')
-    return PrintUserError(rs);
-
-  {
-    size_t t4 = sizeof(UInt32);
-    size_t t8 = sizeof(UInt64);
-    if (t4 != 4 || t8 != 8)
-      return PrintError(rs, &quot;LZMA UTil needs correct UInt32 and UInt64&quot;);
-  }
-
-  inFile = fopen(args[2], &quot;rb&quot;);
-  if (inFile == 0)
-    return PrintError(rs, &quot;Can not open input file&quot;);
-
-  if (numArgs &gt; 3)
-  {
-    outFile = fopen(args[3], &quot;wb+&quot;);
-    if (outFile == 0)
-      return PrintError(rs, &quot;Can not open output file&quot;);
-  }
-  else if (encodeMode)
-    PrintUserError(rs);
-
-  if (encodeMode)
-  {
-    res = Encode(inFile, outFile, rs);
-  }
-  else
-  {
-    res = Decode(inFile, outFile, rs);
-  }
-
-  if (outFile != 0)
-    fclose(outFile);
-  fclose(inFile);
-
-  if (res != SZ_OK)
-  {
-    if (res == SZ_ERROR_MEM)
-      return PrintError(rs, kCantAllocateMessage);
-    else if (res == SZ_ERROR_DATA)
-      return PrintError(rs, kDataErrorMessage);
-    else
-      return PrintErrorNumber(rs, res);
-  }
-  return 0;
-}
-
-int MY_CDECL main(int numArgs, const char *args[])
-{
-  char rs[800] = { 0 };
-  int res = main2(numArgs, args, rs);
-  printf(rs);
-  return res;
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,311 @@
+/* LzmaUtil.c -- Test application for LZMA compression
+2008-08-05
+Igor Pavlov
+public domain */
+
+#define _CRT_SECURE_NO_WARNINGS
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;../LzmaDec.h&quot;
+#include &quot;../LzmaEnc.h&quot;
+#include &quot;../Alloc.h&quot;
+
+const char *kCantReadMessage = &quot;Can not read input file&quot;;
+const char *kCantWriteMessage = &quot;Can not write output file&quot;;
+const char *kCantAllocateMessage = &quot;Can not allocate memory&quot;;
+const char *kDataErrorMessage = &quot;Data error&quot;;
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) {  p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+#define kInBufferSize (1 &lt;&lt; 15)
+#define kOutBufferSize (1 &lt;&lt; 15)
+
+unsigned char g_InBuffer[kInBufferSize];
+unsigned char g_OutBuffer[kOutBufferSize];
+
+size_t MyReadFile(FILE *file, void *data, size_t size)
+  { return fread(data, 1, size, file); }
+
+int MyReadFileAndCheck(FILE *file, void *data, size_t size)
+  { return (MyReadFile(file, data, size) == size); }
+
+size_t MyWriteFile(FILE *file, const void *data, size_t size)
+{
+  if (size == 0)
+    return 0;
+  return fwrite(data, 1, size, file);
+}
+
+int MyWriteFileAndCheck(FILE *file, const void *data, size_t size)
+  { return (MyWriteFile(file, data, size) == size); }
+
+long MyGetFileLength(FILE *file)
+{
+  long length;
+  fseek(file, 0, SEEK_END);
+  length = ftell(file);
+  fseek(file, 0, SEEK_SET);
+  return length;
+}
+
+void PrintHelp(char *buffer)
+{
+  strcat(buffer, &quot;\nLZMA Utility 4.58 Copyright (c) 1999-2008 Igor Pavlov  2008-04-11\n&quot;
+      &quot;\nUsage:  lzma &lt;e|d&gt; inputFile outputFile\n&quot;
+             &quot;  e: encode file\n&quot;
+             &quot;  d: decode file\n&quot;);
+}
+
+int PrintError(char *buffer, const char *message)
+{
+  strcat(buffer, &quot;\nError: &quot;);
+  strcat(buffer, message);
+  strcat(buffer, &quot;\n&quot;);
+  return 1;
+}
+
+int PrintErrorNumber(char *buffer, SRes val)
+{
+  sprintf(buffer + strlen(buffer), &quot;\nError code: %x\n&quot;, (unsigned)val);
+  return 1;
+}
+
+int PrintUserError(char *buffer)
+{
+  return PrintError(buffer, &quot;Incorrect command&quot;);
+}
+
+#define IN_BUF_SIZE (1 &lt;&lt; 16)
+#define OUT_BUF_SIZE (1 &lt;&lt; 16)
+
+static int Decode(FILE *inFile, FILE *outFile, char *rs)
+{
+  UInt64 unpackSize;
+  int thereIsSize; /* = 1, if there is uncompressed size in headers */
+  int i;
+  int res = 0;
+  
+  CLzmaDec state;
+
+  /* header: 5 bytes of LZMA properties and 8 bytes of uncompressed size */
+  unsigned char header[LZMA_PROPS_SIZE + 8];
+
+  /* Read and parse header */
+
+  if (!MyReadFileAndCheck(inFile, header, sizeof(header)))
+    return PrintError(rs, kCantReadMessage);
+
+  unpackSize = 0;
+  thereIsSize = 0;
+  for (i = 0; i &lt; 8; i++)
+  {
+    unsigned char b = header[LZMA_PROPS_SIZE + i];
+    if (b != 0xFF)
+      thereIsSize = 1;
+    unpackSize += (UInt64)b &lt;&lt; (i * 8);
+  }
+
+  LzmaDec_Construct(&amp;state);
+  res = LzmaDec_Allocate(&amp;state, header, LZMA_PROPS_SIZE, &amp;g_Alloc);
+  if (res != SZ_OK)
+    return res;
+  {
+    Byte inBuf[IN_BUF_SIZE];
+    Byte outBuf[OUT_BUF_SIZE];
+    size_t inPos = 0, inSize = 0, outPos = 0;
+    LzmaDec_Init(&amp;state);
+    for (;;)
+    {
+      if (inPos == inSize)
+      {
+        inSize = MyReadFile(inFile, inBuf, IN_BUF_SIZE);
+        inPos = 0;
+      }
+      {
+        SizeT inProcessed = inSize - inPos;
+        SizeT outProcessed = OUT_BUF_SIZE - outPos;
+        ELzmaFinishMode finishMode = LZMA_FINISH_ANY;
+        ELzmaStatus status;
+        if (thereIsSize &amp;&amp; outProcessed &gt; unpackSize)
+        {
+          outProcessed = (SizeT)unpackSize;
+          finishMode = LZMA_FINISH_END;
+        }
+
+        res = LzmaDec_DecodeToBuf(&amp;state, outBuf + outPos, &amp;outProcessed,
+            inBuf + inPos, &amp;inProcessed, finishMode, &amp;status);
+        inPos += (UInt32)inProcessed;
+        outPos += outProcessed;
+        unpackSize -= outProcessed;
+
+        if (outFile != 0)
+          MyWriteFile(outFile, outBuf, outPos);
+        outPos = 0;
+
+        if (res != SZ_OK || thereIsSize &amp;&amp; unpackSize == 0)
+          break;
+
+        if (inProcessed == 0 &amp;&amp; outProcessed == 0)
+        {
+          if (thereIsSize || status != LZMA_STATUS_FINISHED_WITH_MARK)
+            res = SZ_ERROR_DATA;
+          break;
+        }
+      }
+    }
+  }
+
+  LzmaDec_Free(&amp;state, &amp;g_Alloc);
+  return res;
+}
+
+typedef struct _CFileSeqInStream
+{
+  ISeqInStream funcTable;
+  FILE *file;
+} CFileSeqInStream;
+
+static SRes MyRead(void *p, void *buf, size_t *size)
+{
+  if (*size == 0)
+    return SZ_OK;
+  *size = MyReadFile(((CFileSeqInStream*)p)-&gt;file, buf, *size);
+  /*
+  if (*size == 0)
+    return SZE_FAIL;
+  */
+  return SZ_OK;
+}
+
+typedef struct _CFileSeqOutStream
+{
+  ISeqOutStream funcTable;
+  FILE *file;
+} CFileSeqOutStream;
+
+static size_t MyWrite(void *pp, const void *buf, size_t size)
+{
+  return MyWriteFile(((CFileSeqOutStream *)pp)-&gt;file, buf, size);
+}
+
+static SRes Encode(FILE *inFile, FILE *outFile, char *rs)
+{
+  CLzmaEncHandle enc;
+  SRes res;
+  CFileSeqInStream inStream;
+  CFileSeqOutStream outStream;
+  CLzmaEncProps props;
+
+  enc = LzmaEnc_Create(&amp;g_Alloc);
+  if (enc == 0)
+    return SZ_ERROR_MEM;
+
+  inStream.funcTable.Read = MyRead;
+  inStream.file = inFile;
+  outStream.funcTable.Write = MyWrite;
+  outStream.file = outFile;
+
+  LzmaEncProps_Init(&amp;props);
+  res = LzmaEnc_SetProps(enc, &amp;props);
+
+  if (res == SZ_OK)
+  {
+    Byte header[LZMA_PROPS_SIZE + 8];
+    size_t headerSize = LZMA_PROPS_SIZE;
+    UInt64 fileSize;
+    int i;
+
+    res = LzmaEnc_WriteProperties(enc, header, &amp;headerSize);
+    fileSize = MyGetFileLength(inFile);
+    for (i = 0; i &lt; 8; i++)
+      header[headerSize++] = (Byte)(fileSize &gt;&gt; (8 * i));
+    if (!MyWriteFileAndCheck(outFile, header, headerSize))
+      return PrintError(rs, &quot;writing error&quot;);
+
+    if (res == SZ_OK)
+      res = LzmaEnc_Encode(enc, &amp;outStream.funcTable, &amp;inStream.funcTable,
+        NULL, &amp;g_Alloc, &amp;g_Alloc);
+  }
+  LzmaEnc_Destroy(enc, &amp;g_Alloc, &amp;g_Alloc);
+  return res;
+}
+
+int main2(int numArgs, const char *args[], char *rs)
+{
+  FILE *inFile = 0;
+  FILE *outFile = 0;
+  char c;
+  int res;
+  int encodeMode;
+
+  if (numArgs == 1)
+  {
+    PrintHelp(rs);
+    return 0;
+  }
+
+  if (numArgs &lt; 3 || numArgs &gt; 4 || strlen(args[1]) != 1)
+    return PrintUserError(rs);
+
+  c = args[1][0];
+  encodeMode = (c == 'e' || c == 'E');
+  if (!encodeMode &amp;&amp; c != 'd' &amp;&amp; c != 'D')
+    return PrintUserError(rs);
+
+  {
+    size_t t4 = sizeof(UInt32);
+    size_t t8 = sizeof(UInt64);
+    if (t4 != 4 || t8 != 8)
+      return PrintError(rs, &quot;LZMA UTil needs correct UInt32 and UInt64&quot;);
+  }
+
+  inFile = fopen(args[2], &quot;rb&quot;);
+  if (inFile == 0)
+    return PrintError(rs, &quot;Can not open input file&quot;);
+
+  if (numArgs &gt; 3)
+  {
+    outFile = fopen(args[3], &quot;wb+&quot;);
+    if (outFile == 0)
+      return PrintError(rs, &quot;Can not open output file&quot;);
+  }
+  else if (encodeMode)
+    PrintUserError(rs);
+
+  if (encodeMode)
+  {
+    res = Encode(inFile, outFile, rs);
+  }
+  else
+  {
+    res = Decode(inFile, outFile, rs);
+  }
+
+  if (outFile != 0)
+    fclose(outFile);
+  fclose(inFile);
+
+  if (res != SZ_OK)
+  {
+    if (res == SZ_ERROR_MEM)
+      return PrintError(rs, kCantAllocateMessage);
+    else if (res == SZ_ERROR_DATA)
+      return PrintError(rs, kDataErrorMessage);
+    else
+      return PrintErrorNumber(rs, res);
+  }
+  return 0;
+}
+
+int MY_CDECL main(int numArgs, const char *args[])
+{
+  char rs[800] = { 0 };
+  int res = main2(numArgs, args, rs);
+  printf(rs);
+  return res;
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,152 +0,0 @@
-# Microsoft Developer Studio Project File - Name=&quot;LzmaUtil&quot; - Package Owner=&lt;4&gt;
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
-
-CFG=LzmaUtil - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;LzmaUtil.mak&quot;.
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;LzmaUtil.mak&quot; CFG=&quot;LzmaUtil - Win32 Debug&quot;
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE &quot;LzmaUtil - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
-!MESSAGE &quot;LzmaUtil - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName &quot;&quot;
-# PROP Scc_LocalPath &quot;&quot;
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  &quot;$(CFG)&quot; == &quot;LzmaUtil - Win32 Release&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir &quot;Release&quot;
-# PROP BASE Intermediate_Dir &quot;Release&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir &quot;Release&quot;
-# PROP Intermediate_Dir &quot;Release&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
-# ADD CPP /nologo /MT /W3 /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;c:\util\lzmac.exe&quot;
-
-!ELSEIF  &quot;$(CFG)&quot; == &quot;LzmaUtil - Win32 Debug&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir &quot;Debug&quot;
-# PROP BASE Intermediate_Dir &quot;Debug&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir &quot;Debug&quot;
-# PROP Intermediate_Dir &quot;Debug&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;c:\util\lzmac.exe&quot; /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name &quot;LzmaUtil - Win32 Release&quot;
-# Name &quot;LzmaUtil - Win32 Debug&quot;
-# Begin Source File
-
-SOURCE=..\Alloc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Alloc.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\CpuArch.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFind.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFind.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFindMt.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFindMt.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzHash.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaDec.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaDec.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaEnc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaEnc.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\LzmaUtil.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Threads.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Threads.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\Types.h
-# End Source File
-# End Target
-# End Project

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,152 @@
+# Microsoft Developer Studio Project File - Name=&quot;LzmaUtil&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
+
+CFG=LzmaUtil - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;LzmaUtil.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;LzmaUtil.mak&quot; CFG=&quot;LzmaUtil - Win32 Debug&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;LzmaUtil - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE &quot;LzmaUtil - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;LzmaUtil - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD CPP /nologo /MT /W3 /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;c:\util\lzmac.exe&quot;
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;LzmaUtil - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;c:\util\lzmac.exe&quot; /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;LzmaUtil - Win32 Release&quot;
+# Name &quot;LzmaUtil - Win32 Debug&quot;
+# Begin Source File
+
+SOURCE=..\Alloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Alloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\CpuArch.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzHash.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaUtil.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\Types.h
+# End Source File
+# End Target
+# End Project

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,29 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: &quot;LzmaUtil&quot;=.\LzmaUtil.dsp - Package Owner=&lt;4&gt;
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;4&gt;
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;3&gt;
-{{{
-}}}
-
-###############################################################################
-

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;LzmaUtil&quot;=.\LzmaUtil.dsp - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,27 +0,0 @@
-MY_STATIC_LINK=1
-PROG = LZMAc.exe
-
-CFLAGS = $(CFLAGS) \
-  -DCOMPRESS_MF_MT \
-
-LIB_OBJS = \
-  $O\LzmaUtil.obj \
-
-C_OBJS = \
-  $O\Alloc.obj \
-  $O\LzFind.obj \
-  $O\LzFindMt.obj \
-  $O\LzmaDec.obj \
-  $O\LzmaEnc.obj \
-  $O\Threads.obj \
-
-OBJS = \
-  $(LIB_OBJS) \
-  $(C_OBJS) \
-
-!include &quot;../../CPP/Build.mak&quot;
-
-$(LIB_OBJS): $(*B).c
-	$(COMPL_O2)
-$(C_OBJS): ../$(*B).c
-	$(COMPL_O2)

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,27 @@
+MY_STATIC_LINK=1
+PROG = LZMAc.exe
+
+CFLAGS = $(CFLAGS) \
+  -DCOMPRESS_MF_MT \
+
+LIB_OBJS = \
+  $O\LzmaUtil.obj \
+
+C_OBJS = \
+  $O\Alloc.obj \
+  $O\LzFind.obj \
+  $O\LzFindMt.obj \
+  $O\LzmaDec.obj \
+  $O\LzmaEnc.obj \
+  $O\Threads.obj \
+
+OBJS = \
+  $(LIB_OBJS) \
+  $(C_OBJS) \
+
+!include &quot;../../CPP/Build.mak&quot;
+
+$(LIB_OBJS): $(*B).c
+	$(COMPL_O2)
+$(C_OBJS): ../$(*B).c
+	$(COMPL_O2)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,36 +0,0 @@
-PROG = lzma
-CXX = g++
-LIB =
-RM = rm -f
-CFLAGS = -c -O2 -Wall
-
-OBJS = \
-  LzmaUtil.o \
-  Alloc.o \
-  LzFind.o \
-  LzmaDec.o \
-  LzmaEnc.o \
-
-
-all: $(PROG)
-
-$(PROG): $(OBJS)
-	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB) $(LIB2)
-
-LzmaUtil.o: LzmaUtil.c
-	$(CXX) $(CFLAGS) LzmaUtil.c
-
-Alloc.o: ../Alloc.c
-	$(CXX) $(CFLAGS) ../Alloc.c
-
-LzFind.o: ../LzFind.c
-	$(CXX) $(CFLAGS) ../LzFind.c
-
-LzmaDec.o: ../LzmaDec.c
-	$(CXX) $(CFLAGS) ../LzmaDec.c
-
-LzmaEnc.o: ../LzmaEnc.c
-	$(CXX) $(CFLAGS) ../LzmaEnc.c
-
-clean:
-	-$(RM) $(PROG) $(OBJS)

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,36 @@
+PROG = lzma
+CXX = g++
+LIB =
+RM = rm -f
+CFLAGS = -c -O2 -Wall
+
+OBJS = \
+  LzmaUtil.o \
+  Alloc.o \
+  LzFind.o \
+  LzmaDec.o \
+  LzmaEnc.o \
+
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB) $(LIB2)
+
+LzmaUtil.o: LzmaUtil.c
+	$(CXX) $(CFLAGS) LzmaUtil.c
+
+Alloc.o: ../Alloc.c
+	$(CXX) $(CFLAGS) ../Alloc.c
+
+LzFind.o: ../LzFind.c
+	$(CXX) $(CFLAGS) ../LzFind.c
+
+LzmaDec.o: ../LzmaDec.c
+	$(CXX) $(CFLAGS) ../LzmaDec.c
+
+LzmaEnc.o: ../LzmaEnc.c
+	$(CXX) $(CFLAGS) ../LzmaEnc.c
+
+clean:
+	-$(RM) $(PROG) $(OBJS)

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,109 +0,0 @@
-/* Threads.c -- multithreading library
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#include &quot;Threads.h&quot;
-#include &lt;process.h&gt;
-
-static WRes GetError()
-{
-  DWORD res = GetLastError();
-  return (res) ? (WRes)(res) : 1;
-}
-
-WRes HandleToWRes(HANDLE h) { return (h != 0) ? 0 : GetError(); }
-WRes BOOLToWRes(BOOL v) { return v ? 0 : GetError(); }
-
-static WRes MyCloseHandle(HANDLE *h)
-{
-  if (*h != NULL)
-    if (!CloseHandle(*h))
-      return GetError();
-  *h = NULL;
-  return 0;
-}
-
-WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter)
-{
-  unsigned threadId; /* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
-  thread-&gt;handle =
-    /* CreateThread(0, 0, startAddress, parameter, 0, &amp;threadId); */
-    (HANDLE)_beginthreadex(NULL, 0, startAddress, parameter, 0, &amp;threadId);
-    /* maybe we must use errno here, but probably GetLastError() is also OK. */
-  return HandleToWRes(thread-&gt;handle);
-}
-
-WRes WaitObject(HANDLE h)
-{
-  return (WRes)WaitForSingleObject(h, INFINITE);
-}
-
-WRes Thread_Wait(CThread *thread)
-{
-  if (thread-&gt;handle == NULL)
-    return 1;
-  return WaitObject(thread-&gt;handle);
-}
-
-WRes Thread_Close(CThread *thread)
-{
-  return MyCloseHandle(&amp;thread-&gt;handle);
-}
-
-WRes Event_Create(CEvent *p, BOOL manualReset, int initialSignaled)
-{
-  p-&gt;handle = CreateEvent(NULL, manualReset, (initialSignaled ? TRUE : FALSE), NULL);
-  return HandleToWRes(p-&gt;handle);
-}
-
-WRes ManualResetEvent_Create(CManualResetEvent *p, int initialSignaled)
-  { return Event_Create(p, TRUE, initialSignaled); }
-WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p)
-  { return ManualResetEvent_Create(p, 0); }
-
-WRes AutoResetEvent_Create(CAutoResetEvent *p, int initialSignaled)
-  { return Event_Create(p, FALSE, initialSignaled); }
-WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p)
-  { return AutoResetEvent_Create(p, 0); }
-
-WRes Event_Set(CEvent *p) { return BOOLToWRes(SetEvent(p-&gt;handle)); }
-WRes Event_Reset(CEvent *p) { return BOOLToWRes(ResetEvent(p-&gt;handle)); }
-WRes Event_Wait(CEvent *p) { return WaitObject(p-&gt;handle); }
-WRes Event_Close(CEvent *p) { return MyCloseHandle(&amp;p-&gt;handle); }
-
-
-WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount)
-{
-  p-&gt;handle = CreateSemaphore(NULL, (LONG)initiallyCount, (LONG)maxCount, NULL);
-  return HandleToWRes(p-&gt;handle);
-}
-
-WRes Semaphore_Release(CSemaphore *p, LONG releaseCount, LONG *previousCount)
-{
-  return BOOLToWRes(ReleaseSemaphore(p-&gt;handle, releaseCount, previousCount));
-}
-WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 releaseCount)
-{
-  return Semaphore_Release(p, (LONG)releaseCount, NULL);
-}
-WRes Semaphore_Release1(CSemaphore *p)
-{
-  return Semaphore_ReleaseN(p, 1);
-}
-
-WRes Semaphore_Wait(CSemaphore *p) { return WaitObject(p-&gt;handle); }
-WRes Semaphore_Close(CSemaphore *p) { return MyCloseHandle(&amp;p-&gt;handle); }
-
-WRes CriticalSection_Init(CCriticalSection *p)
-{
-  /* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
-  __try
-  {
-    InitializeCriticalSection(p);
-    /* InitializeCriticalSectionAndSpinCount(p, 0); */
-  }
-  __except (EXCEPTION_EXECUTE_HANDLER) { return 1; }
-  return 0;
-}
-

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,109 @@
+/* Threads.c -- multithreading library
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include &quot;Threads.h&quot;
+#include &lt;process.h&gt;
+
+static WRes GetError()
+{
+  DWORD res = GetLastError();
+  return (res) ? (WRes)(res) : 1;
+}
+
+WRes HandleToWRes(HANDLE h) { return (h != 0) ? 0 : GetError(); }
+WRes BOOLToWRes(BOOL v) { return v ? 0 : GetError(); }
+
+static WRes MyCloseHandle(HANDLE *h)
+{
+  if (*h != NULL)
+    if (!CloseHandle(*h))
+      return GetError();
+  *h = NULL;
+  return 0;
+}
+
+WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter)
+{
+  unsigned threadId; /* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
+  thread-&gt;handle =
+    /* CreateThread(0, 0, startAddress, parameter, 0, &amp;threadId); */
+    (HANDLE)_beginthreadex(NULL, 0, startAddress, parameter, 0, &amp;threadId);
+    /* maybe we must use errno here, but probably GetLastError() is also OK. */
+  return HandleToWRes(thread-&gt;handle);
+}
+
+WRes WaitObject(HANDLE h)
+{
+  return (WRes)WaitForSingleObject(h, INFINITE);
+}
+
+WRes Thread_Wait(CThread *thread)
+{
+  if (thread-&gt;handle == NULL)
+    return 1;
+  return WaitObject(thread-&gt;handle);
+}
+
+WRes Thread_Close(CThread *thread)
+{
+  return MyCloseHandle(&amp;thread-&gt;handle);
+}
+
+WRes Event_Create(CEvent *p, BOOL manualReset, int initialSignaled)
+{
+  p-&gt;handle = CreateEvent(NULL, manualReset, (initialSignaled ? TRUE : FALSE), NULL);
+  return HandleToWRes(p-&gt;handle);
+}
+
+WRes ManualResetEvent_Create(CManualResetEvent *p, int initialSignaled)
+  { return Event_Create(p, TRUE, initialSignaled); }
+WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p)
+  { return ManualResetEvent_Create(p, 0); }
+
+WRes AutoResetEvent_Create(CAutoResetEvent *p, int initialSignaled)
+  { return Event_Create(p, FALSE, initialSignaled); }
+WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p)
+  { return AutoResetEvent_Create(p, 0); }
+
+WRes Event_Set(CEvent *p) { return BOOLToWRes(SetEvent(p-&gt;handle)); }
+WRes Event_Reset(CEvent *p) { return BOOLToWRes(ResetEvent(p-&gt;handle)); }
+WRes Event_Wait(CEvent *p) { return WaitObject(p-&gt;handle); }
+WRes Event_Close(CEvent *p) { return MyCloseHandle(&amp;p-&gt;handle); }
+
+
+WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount)
+{
+  p-&gt;handle = CreateSemaphore(NULL, (LONG)initiallyCount, (LONG)maxCount, NULL);
+  return HandleToWRes(p-&gt;handle);
+}
+
+WRes Semaphore_Release(CSemaphore *p, LONG releaseCount, LONG *previousCount)
+{
+  return BOOLToWRes(ReleaseSemaphore(p-&gt;handle, releaseCount, previousCount));
+}
+WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 releaseCount)
+{
+  return Semaphore_Release(p, (LONG)releaseCount, NULL);
+}
+WRes Semaphore_Release1(CSemaphore *p)
+{
+  return Semaphore_ReleaseN(p, 1);
+}
+
+WRes Semaphore_Wait(CSemaphore *p) { return WaitObject(p-&gt;handle); }
+WRes Semaphore_Close(CSemaphore *p) { return MyCloseHandle(&amp;p-&gt;handle); }
+
+WRes CriticalSection_Init(CCriticalSection *p)
+{
+  /* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
+  __try
+  {
+    InitializeCriticalSection(p);
+    /* InitializeCriticalSectionAndSpinCount(p, 0); */
+  }
+  __except (EXCEPTION_EXECUTE_HANDLER) { return 1; }
+  return 0;
+}
+

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,74 +0,0 @@
-/* Threads.h -- multithreading library
-2008-04-11
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_THRESDS_H
-#define __7Z_THRESDS_H
-
-#include &lt;windows.h&gt;
-
-#include &quot;Types.h&quot;
-
-typedef struct _CThread
-{
-  HANDLE handle;
-} CThread;
-
-#define Thread_Construct(thread) (thread)-&gt;handle = NULL
-#define Thread_WasCreated(thread) ((thread)-&gt;handle != NULL)
- 
-typedef unsigned THREAD_FUNC_RET_TYPE;
-#define THREAD_FUNC_CALL_TYPE MY_STD_CALL
-#define THREAD_FUNC_DECL THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPE
-
-typedef DWORD WRes;
-
-WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter);
-WRes Thread_Wait(CThread *thread);
-WRes Thread_Close(CThread *thread);
-
-typedef struct _CEvent
-{
-  HANDLE handle;
-} CEvent;
-
-typedef CEvent CAutoResetEvent;
-typedef CEvent CManualResetEvent;
-
-#define Event_Construct(event) (event)-&gt;handle = NULL
-#define Event_IsCreated(event) ((event)-&gt;handle != NULL)
-
-WRes ManualResetEvent_Create(CManualResetEvent *event, int initialSignaled);
-WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *event);
-WRes AutoResetEvent_Create(CAutoResetEvent *event, int initialSignaled);
-WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *event);
-WRes Event_Set(CEvent *event);
-WRes Event_Reset(CEvent *event);
-WRes Event_Wait(CEvent *event);
-WRes Event_Close(CEvent *event);
-
-
-typedef struct _CSemaphore
-{
-  HANDLE handle;
-} CSemaphore;
-
-#define Semaphore_Construct(p) (p)-&gt;handle = NULL
-
-WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount);
-WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 num);
-WRes Semaphore_Release1(CSemaphore *p);
-WRes Semaphore_Wait(CSemaphore *p);
-WRes Semaphore_Close(CSemaphore *p);
-
-
-typedef CRITICAL_SECTION CCriticalSection;
-
-WRes CriticalSection_Init(CCriticalSection *p);
-#define CriticalSection_Delete(p) DeleteCriticalSection(p)
-#define CriticalSection_Enter(p) EnterCriticalSection(p)
-#define CriticalSection_Leave(p) LeaveCriticalSection(p)
-
-#endif
-

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Threads.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,74 @@
+/* Threads.h -- multithreading library
+2008-04-11
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_THRESDS_H
+#define __7Z_THRESDS_H
+
+#include &lt;windows.h&gt;
+
+#include &quot;Types.h&quot;
+
+typedef struct _CThread
+{
+  HANDLE handle;
+} CThread;
+
+#define Thread_Construct(thread) (thread)-&gt;handle = NULL
+#define Thread_WasCreated(thread) ((thread)-&gt;handle != NULL)
+ 
+typedef unsigned THREAD_FUNC_RET_TYPE;
+#define THREAD_FUNC_CALL_TYPE MY_STD_CALL
+#define THREAD_FUNC_DECL THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPE
+
+typedef DWORD WRes;
+
+WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter);
+WRes Thread_Wait(CThread *thread);
+WRes Thread_Close(CThread *thread);
+
+typedef struct _CEvent
+{
+  HANDLE handle;
+} CEvent;
+
+typedef CEvent CAutoResetEvent;
+typedef CEvent CManualResetEvent;
+
+#define Event_Construct(event) (event)-&gt;handle = NULL
+#define Event_IsCreated(event) ((event)-&gt;handle != NULL)
+
+WRes ManualResetEvent_Create(CManualResetEvent *event, int initialSignaled);
+WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *event);
+WRes AutoResetEvent_Create(CAutoResetEvent *event, int initialSignaled);
+WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *event);
+WRes Event_Set(CEvent *event);
+WRes Event_Reset(CEvent *event);
+WRes Event_Wait(CEvent *event);
+WRes Event_Close(CEvent *event);
+
+
+typedef struct _CSemaphore
+{
+  HANDLE handle;
+} CSemaphore;
+
+#define Semaphore_Construct(p) (p)-&gt;handle = NULL
+
+WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount);
+WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 num);
+WRes Semaphore_Release1(CSemaphore *p);
+WRes Semaphore_Wait(CSemaphore *p);
+WRes Semaphore_Close(CSemaphore *p);
+
+
+typedef CRITICAL_SECTION CCriticalSection;
+
+WRes CriticalSection_Init(CCriticalSection *p);
+#define CriticalSection_Delete(p) DeleteCriticalSection(p)
+#define CriticalSection_Enter(p) EnterCriticalSection(p)
+#define CriticalSection_Leave(p) LeaveCriticalSection(p)
+
+#endif
+

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,130 +0,0 @@
-/* Types.h -- Basic types
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_TYPES_H
-#define __7Z_TYPES_H
-
-#define SZ_OK 0
-
-#define SZ_ERROR_DATA 1
-#define SZ_ERROR_MEM 2
-#define SZ_ERROR_CRC 3
-#define SZ_ERROR_UNSUPPORTED 4
-#define SZ_ERROR_PARAM 5
-#define SZ_ERROR_INPUT_EOF 6
-#define SZ_ERROR_OUTPUT_EOF 7
-#define SZ_ERROR_READ 8
-#define SZ_ERROR_WRITE 9
-#define SZ_ERROR_PROGRESS 10
-#define SZ_ERROR_FAIL 11
-#define SZ_ERROR_THREAD 12
-
-#define SZ_ERROR_ARCHIVE 16
-#define SZ_ERROR_NO_ARCHIVE 17
-
-typedef int SRes;
-
-#ifndef RINOK
-#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
-#endif
-
-typedef unsigned char Byte;
-typedef short Int16;
-typedef unsigned short UInt16;
-
-#ifdef _LZMA_UINT32_IS_ULONG
-typedef long Int32;
-typedef unsigned long UInt32;
-#else
-typedef int Int32;
-typedef unsigned int UInt32;
-#endif
-
-/* #define _SZ_NO_INT_64 */
-/* define it if your compiler doesn't support 64-bit integers */
-
-#ifdef _SZ_NO_INT_64
-
-typedef long Int64;
-typedef unsigned long UInt64;
-
-#else
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-typedef __int64 Int64;
-typedef unsigned __int64 UInt64;
-#else
-typedef long long int Int64;
-typedef unsigned long long int UInt64;
-#endif
-
-#endif
-
-#ifdef _LZMA_NO_SYSTEM_SIZE_T
-typedef UInt32 SizeT;
-#else
-#include &lt;stddef.h&gt;
-typedef size_t SizeT;
-#endif
-
-typedef int Bool;
-#define True 1
-#define False 0
-
-
-#ifdef _MSC_VER
-
-#if _MSC_VER &gt;= 1300
-#define MY_NO_INLINE __declspec(noinline)
-#else
-#define MY_NO_INLINE
-#endif
-
-#define MY_CDECL __cdecl
-#define MY_STD_CALL __stdcall
-#define MY_FAST_CALL MY_NO_INLINE __fastcall
-
-#else
-
-#define MY_CDECL
-#define MY_STD_CALL
-#define MY_FAST_CALL
-
-#endif
-
-
-/* The following interfaces use first parameter as pointer to structure */
-
-typedef struct
-{
-  SRes (*Read)(void *p, void *buf, size_t *size);
-    /* if (input(*size) != 0 &amp;&amp; output(*size) == 0) means end_of_stream.
-       (output(*size) &lt; input(*size)) is allowed */
-} ISeqInStream;
-
-typedef struct
-{
-  size_t (*Write)(void *p, const void *buf, size_t size);
-    /* Returns: result - the number of actually written bytes.
-      (result &lt; size) means error */
-} ISeqOutStream;
-
-typedef struct
-{
-  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
-    /* Returns: result. (result != SZ_OK) means break.
-       Value (UInt64)(Int64)-1 for size means unknown value. */
-} ICompressProgress;
-
-typedef struct
-{
-  void *(*Alloc)(void *p, size_t size);
-  void (*Free)(void *p, void *address); /* address can be 0 */
-} ISzAlloc;
-
-#define IAlloc_Alloc(p, size) (p)-&gt;Alloc((p), size)
-#define IAlloc_Free(p, a) (p)-&gt;Free((p), a)
-
-#endif

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/libsevenzip/Types.h	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,130 @@
+/* Types.h -- Basic types
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_TYPES_H
+#define __7Z_TYPES_H
+
+#define SZ_OK 0
+
+#define SZ_ERROR_DATA 1
+#define SZ_ERROR_MEM 2
+#define SZ_ERROR_CRC 3
+#define SZ_ERROR_UNSUPPORTED 4
+#define SZ_ERROR_PARAM 5
+#define SZ_ERROR_INPUT_EOF 6
+#define SZ_ERROR_OUTPUT_EOF 7
+#define SZ_ERROR_READ 8
+#define SZ_ERROR_WRITE 9
+#define SZ_ERROR_PROGRESS 10
+#define SZ_ERROR_FAIL 11
+#define SZ_ERROR_THREAD 12
+
+#define SZ_ERROR_ARCHIVE 16
+#define SZ_ERROR_NO_ARCHIVE 17
+
+typedef int SRes;
+
+#ifndef RINOK
+#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
+#endif
+
+typedef unsigned char Byte;
+typedef short Int16;
+typedef unsigned short UInt16;
+
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef long Int32;
+typedef unsigned long UInt32;
+#else
+typedef int Int32;
+typedef unsigned int UInt32;
+#endif
+
+/* #define _SZ_NO_INT_64 */
+/* define it if your compiler doesn't support 64-bit integers */
+
+#ifdef _SZ_NO_INT_64
+
+typedef long Int64;
+typedef unsigned long UInt64;
+
+#else
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+typedef __int64 Int64;
+typedef unsigned __int64 UInt64;
+#else
+typedef long long int Int64;
+typedef unsigned long long int UInt64;
+#endif
+
+#endif
+
+#ifdef _LZMA_NO_SYSTEM_SIZE_T
+typedef UInt32 SizeT;
+#else
+#include &lt;stddef.h&gt;
+typedef size_t SizeT;
+#endif
+
+typedef int Bool;
+#define True 1
+#define False 0
+
+
+#ifdef _MSC_VER
+
+#if _MSC_VER &gt;= 1300
+#define MY_NO_INLINE __declspec(noinline)
+#else
+#define MY_NO_INLINE
+#endif
+
+#define MY_CDECL __cdecl
+#define MY_STD_CALL __stdcall
+#define MY_FAST_CALL MY_NO_INLINE __fastcall
+
+#else
+
+#define MY_CDECL
+#define MY_STD_CALL
+#define MY_FAST_CALL
+
+#endif
+
+
+/* The following interfaces use first parameter as pointer to structure */
+
+typedef struct
+{
+  SRes (*Read)(void *p, void *buf, size_t *size);
+    /* if (input(*size) != 0 &amp;&amp; output(*size) == 0) means end_of_stream.
+       (output(*size) &lt; input(*size)) is allowed */
+} ISeqInStream;
+
+typedef struct
+{
+  size_t (*Write)(void *p, const void *buf, size_t size);
+    /* Returns: result - the number of actually written bytes.
+      (result &lt; size) means error */
+} ISeqOutStream;
+
+typedef struct
+{
+  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
+    /* Returns: result. (result != SZ_OK) means break.
+       Value (UInt64)(Int64)-1 for size means unknown value. */
+} ICompressProgress;
+
+typedef struct
+{
+  void *(*Alloc)(void *p, size_t size);
+  void (*Free)(void *p, void *address); /* address can be 0 */
+} ISzAlloc;
+
+#define IAlloc_Alloc(p, size) (p)-&gt;Alloc((p), size)
+#define IAlloc_Free(p, a) (p)-&gt;Free((p), a)
+
+#endif

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,178 +0,0 @@
-#include &lt;stdio.h&gt;
-
-#include &lt;caml/mlvalues.h&gt;
-#include &lt;caml/fail.h&gt;
-#include &lt;caml/alloc.h&gt;
-#include &lt;caml/memory.h&gt;
-#include &lt;caml/callback.h&gt;
-#include &lt;caml/custom.h&gt;
-
-#include &quot;libsevenzip/Archive/7z/7zIn.h&quot;
-#include &quot;libsevenzip/Archive/7z/7zAlloc.h&quot;
-#include &quot;libsevenzip/7zCrc.h&quot;
-
-
-static ISzAlloc allocImp;
-static ISzAlloc allocTempImp;
-
-/* Sevenzip.in_file */
-
-#define sevenzip_in_file_val(v) (*((CSzArEx *) Data_custom_val(v)))
-
-static void finalize_sevenzip_in_file(value sevenzip)
-{
-  CSzArEx db = sevenzip_in_file_val(sevenzip);
-  SzArEx_Free(&amp;db, &amp;allocImp);
-}
-
-static struct custom_operations sevenzip_in_file_ops = {
-  &quot;org.detrino.sevenzip&quot;,
-  finalize_sevenzip_in_file,
-  custom_compare_default,
-  custom_hash_default,
-  custom_serialize_default,
-  custom_deserialize_default
-};
-
-static value alloc_sevenzip_in_file(CSzArEx db)
-{
-  CAMLparam0 ();
-  CAMLlocal1 (sevenzip);
-  sevenzip = alloc_custom(&amp;sevenzip_in_file_ops, sizeof(CSzArEx), 0, 1);
-  sevenzip_in_file_val(sevenzip) = db;
-  CAMLreturn (sevenzip);
-}
-
-/* Sevenzip.entry */
-
-static value alloc_sevenzip_entry(CSzArEx db, int i)
-{
-
-  CSzFileItem *f = db.db.Files + i;
-  CAMLparam0 ();
-  CAMLlocal5 (entry, index, name, size, is_directory);
-
-  entry = caml_alloc (4, 0);
-  index = Val_int(i);
-  name = caml_copy_string(f-&gt;Name);
-  size = Val_int(f-&gt;Size);
-  is_directory = Val_bool(f-&gt;IsDir);
-
-  Store_field (entry, 0, index);
-  Store_field (entry, 1, name);
-  Store_field (entry, 2, size);
-  Store_field (entry, 3, is_directory);
-
-  CAMLreturn (entry);
-}
-
-/* Sevenzip.init */
-
-value ml_sevenzip_init(value unit)
-{
-  CAMLparam1 (unit);
-
-  CrcGenerateTable();
-
-  allocImp.Alloc = SzAlloc;
-  allocImp.Free = SzFree;
-  allocTempImp.Alloc = SzAllocTemp;
-  allocTempImp.Free = SzFreeTemp;
-
-  CAMLreturn (Val_unit);
-}
-
-/* Sevenzip.readable */
-
-typedef struct _CFileInStream {
-  ISzInStream funcs;
-  value readable;
-} CFileInStream;
-
-SRes ml_sevenzip_read(void *object, void **buffer, size_t *size)
-{
-  value readable = ((CFileInStream *)object)-&gt;readable;
-  value read = Field(readable, 0);
-  value tuple = caml_callback(read, Val_int(*size));
-  value ml_string = Field(tuple, 0);
-  value ml_size = Field(tuple, 1);
-  *buffer = String_val(ml_string);
-  *size = Int_val(ml_size);
-
-  return SZ_OK;
-}
-
-SRes ml_sevenzip_seek(void *object, CFileSize pos, ESzSeek origin)
-{
-  value readable = ((CFileInStream *)object)-&gt;readable;
-  value seek = Field(readable, 1);
-  value term;
-
-  switch (origin) {
-
-  case SZ_SEEK_SET: term = Val_int(0); break;
-  case SZ_SEEK_CUR: term = Val_int(1); break;
-  case SZ_SEEK_END: term = Val_int(2); break;
-
-  }
-
-  caml_callback2(seek, Val_int(pos), term);
-
-  return SZ_OK;
-}
-
-/* Sevenzip.open_readable */
-
-value ml_sevenzip_open_readable (value readable)
-{
-  CAMLparam1 (readable);
-
-  CFileInStream archiveStream;
-  CSzArEx db;
-  SRes res;
-  value sevenzip;
-
-  archiveStream.funcs.Read = ml_sevenzip_read;
-  archiveStream.funcs.Seek = ml_sevenzip_seek;
-  archiveStream.readable = readable;
-
-  SzArEx_Init(&amp;db);
-  res = SzArEx_Open(&amp;db, &amp;archiveStream.funcs, &amp;allocImp, &amp;allocTempImp);
-
-  switch (res) {
-
-  case SZ_OK: break;
-  case SZ_ERROR_NO_ARCHIVE: caml_failwith(&quot;NO ARCHIVE&quot;);
-  case SZ_ERROR_ARCHIVE: caml_failwith(&quot;ARCHIVE&quot;);
-  case SZ_ERROR_UNSUPPORTED: caml_failwith(&quot;UNSUPPORTED&quot;);
-  case SZ_ERROR_MEM: caml_failwith(&quot;MEM&quot;);
-  case SZ_ERROR_CRC: caml_failwith(&quot;CRC&quot;);
-  case SZ_ERROR_INPUT_EOF: caml_failwith(&quot;INPUT_EOF&quot;);
-  case SZ_ERROR_FAIL:
-  default: caml_failwith(&quot;FAIL&quot;);
-
-  }
-
-  sevenzip = alloc_sevenzip_in_file(db);
-  CAMLreturn (sevenzip);
-}
-
-/* Sevenzip.entries */
-
-value ml_sevenzip_entries(value sevenzip)
-{
-  CAMLparam1 (sevenzip);
-  CAMLlocal1 (entries);
-  CSzArEx db = sevenzip_in_file_val(sevenzip);
-
-  entries = caml_alloc (db.db.NumFiles, 0);
-
-  UInt32 i;
-  for (i = 0; i &lt; db.db.NumFiles; i++)
-    {
-      value entry = alloc_sevenzip_entry(db, i);
-      Store_field (entries, i, entry);
-    }
-
-  CAMLreturn (entries);
-}

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/ml_sevenzip.c	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,178 @@
+#include &lt;stdio.h&gt;
+
+#include &lt;caml/mlvalues.h&gt;
+#include &lt;caml/fail.h&gt;
+#include &lt;caml/alloc.h&gt;
+#include &lt;caml/memory.h&gt;
+#include &lt;caml/callback.h&gt;
+#include &lt;caml/custom.h&gt;
+
+#include &quot;libsevenzip/Archive/7z/7zIn.h&quot;
+#include &quot;libsevenzip/Archive/7z/7zAlloc.h&quot;
+#include &quot;libsevenzip/7zCrc.h&quot;
+
+
+static ISzAlloc allocImp;
+static ISzAlloc allocTempImp;
+
+/* Sevenzip.in_file */
+
+#define sevenzip_in_file_val(v) (*((CSzArEx *) Data_custom_val(v)))
+
+static void finalize_sevenzip_in_file(value sevenzip)
+{
+  CSzArEx db = sevenzip_in_file_val(sevenzip);
+  SzArEx_Free(&amp;db, &amp;allocImp);
+}
+
+static struct custom_operations sevenzip_in_file_ops = {
+  &quot;org.detrino.sevenzip&quot;,
+  finalize_sevenzip_in_file,
+  custom_compare_default,
+  custom_hash_default,
+  custom_serialize_default,
+  custom_deserialize_default
+};
+
+static value alloc_sevenzip_in_file(CSzArEx db)
+{
+  CAMLparam0 ();
+  CAMLlocal1 (sevenzip);
+  sevenzip = alloc_custom(&amp;sevenzip_in_file_ops, sizeof(CSzArEx), 0, 1);
+  sevenzip_in_file_val(sevenzip) = db;
+  CAMLreturn (sevenzip);
+}
+
+/* Sevenzip.entry */
+
+static value alloc_sevenzip_entry(CSzArEx db, int i)
+{
+
+  CSzFileItem *f = db.db.Files + i;
+  CAMLparam0 ();
+  CAMLlocal5 (entry, index, name, size, is_directory);
+
+  entry = caml_alloc (4, 0);
+  index = Val_int(i);
+  name = caml_copy_string(f-&gt;Name);
+  size = Val_int(f-&gt;Size);
+  is_directory = Val_bool(f-&gt;IsDir);
+
+  Store_field (entry, 0, index);
+  Store_field (entry, 1, name);
+  Store_field (entry, 2, size);
+  Store_field (entry, 3, is_directory);
+
+  CAMLreturn (entry);
+}
+
+/* Sevenzip.init */
+
+value ml_sevenzip_init(value unit)
+{
+  CAMLparam1 (unit);
+
+  CrcGenerateTable();
+
+  allocImp.Alloc = SzAlloc;
+  allocImp.Free = SzFree;
+  allocTempImp.Alloc = SzAllocTemp;
+  allocTempImp.Free = SzFreeTemp;
+
+  CAMLreturn (Val_unit);
+}
+
+/* Sevenzip.readable */
+
+typedef struct _CFileInStream {
+  ISzInStream funcs;
+  value readable;
+} CFileInStream;
+
+SRes ml_sevenzip_read(void *object, void **buffer, size_t *size)
+{
+  value readable = ((CFileInStream *)object)-&gt;readable;
+  value read = Field(readable, 0);
+  value tuple = caml_callback(read, Val_int(*size));
+  value ml_string = Field(tuple, 0);
+  value ml_size = Field(tuple, 1);
+  *buffer = String_val(ml_string);
+  *size = Int_val(ml_size);
+
+  return SZ_OK;
+}
+
+SRes ml_sevenzip_seek(void *object, CFileSize pos, ESzSeek origin)
+{
+  value readable = ((CFileInStream *)object)-&gt;readable;
+  value seek = Field(readable, 1);
+  value term;
+
+  switch (origin) {
+
+  case SZ_SEEK_SET: term = Val_int(0); break;
+  case SZ_SEEK_CUR: term = Val_int(1); break;
+  case SZ_SEEK_END: term = Val_int(2); break;
+
+  }
+
+  caml_callback2(seek, Val_int(pos), term);
+
+  return SZ_OK;
+}
+
+/* Sevenzip.open_readable */
+
+value ml_sevenzip_open_readable (value readable)
+{
+  CAMLparam1 (readable);
+
+  CFileInStream archiveStream;
+  CSzArEx db;
+  SRes res;
+  value sevenzip;
+
+  archiveStream.funcs.Read = ml_sevenzip_read;
+  archiveStream.funcs.Seek = ml_sevenzip_seek;
+  archiveStream.readable = readable;
+
+  SzArEx_Init(&amp;db);
+  res = SzArEx_Open(&amp;db, &amp;archiveStream.funcs, &amp;allocImp, &amp;allocTempImp);
+
+  switch (res) {
+
+  case SZ_OK: break;
+  case SZ_ERROR_NO_ARCHIVE: caml_failwith(&quot;NO ARCHIVE&quot;);
+  case SZ_ERROR_ARCHIVE: caml_failwith(&quot;ARCHIVE&quot;);
+  case SZ_ERROR_UNSUPPORTED: caml_failwith(&quot;UNSUPPORTED&quot;);
+  case SZ_ERROR_MEM: caml_failwith(&quot;MEM&quot;);
+  case SZ_ERROR_CRC: caml_failwith(&quot;CRC&quot;);
+  case SZ_ERROR_INPUT_EOF: caml_failwith(&quot;INPUT_EOF&quot;);
+  case SZ_ERROR_FAIL:
+  default: caml_failwith(&quot;FAIL&quot;);
+
+  }
+
+  sevenzip = alloc_sevenzip_in_file(db);
+  CAMLreturn (sevenzip);
+}
+
+/* Sevenzip.entries */
+
+value ml_sevenzip_entries(value sevenzip)
+{
+  CAMLparam1 (sevenzip);
+  CAMLlocal1 (entries);
+  CSzArEx db = sevenzip_in_file_val(sevenzip);
+
+  entries = caml_alloc (db.db.NumFiles, 0);
+
+  UInt32 i;
+  for (i = 0; i &lt; db.db.NumFiles; i++)
+    {
+      value entry = alloc_sevenzip_entry(db, i);
+      Store_field (entries, i, entry);
+    }
+
+  CAMLreturn (entries);
+}

Deleted: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml
===================================================================
--- trunk/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml	2008-09-02 19:11:44 UTC (rev 6351)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,52 +0,0 @@
-exception Error of string
-
-external init: unit -&gt; unit = &quot;ml_sevenzip_init&quot;
-let () = init ()
-
-type in_file
-
-type origin = SeekSet | SeekCur | SeekEnd
-
-type readable = {
-  read: int -&gt; (string * int);
-  seek: int -&gt; origin -&gt; unit
-}
-
-type entry = {
-  index: int;
-  filename: string;
-  uncompressed_size: int;
-  is_directory: bool
-}
-
-external _open_readable: readable -&gt; in_file = &quot;ml_sevenzip_open_readable&quot;
-let open_readable readable =
-  try
-    _open_readable readable
-  with
-      Failure s -&gt; raise (Error s)
-
-external entries: in_file -&gt; entry array = &quot;ml_sevenzip_entries&quot;
-
-let open_in path =
-  let file = open_in path in
-  let buffer = String.create 65536 in
-    
-  let read n =
-    let length = String.length buffer in
-    let n = if n &gt; length then length else n in
-    let n = input file buffer 0 n in
-      (buffer, n) in
-    
-  let seek pos origin =
-    let pos =
-      match origin with
-          SeekSet -&gt; pos
-        | SeekCur -&gt; (pos_in file) + pos
-        | SeekEnd -&gt; (in_channel_length file) + pos in
-      seek_in file pos in
-
-    open_readable {read=read; seek=seek}
-
-
-let close_in t = ()

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml (from rev 6351, trunk/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/libmlsevenzip/sevenzip.ml	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,52 @@
+exception Error of string
+
+external init: unit -&gt; unit = &quot;ml_sevenzip_init&quot;
+let () = init ()
+
+type in_file
+
+type origin = SeekSet | SeekCur | SeekEnd
+
+type readable = {
+  read: int -&gt; (string * int);
+  seek: int -&gt; origin -&gt; unit
+}
+
+type entry = {
+  index: int;
+  filename: string;
+  uncompressed_size: int;
+  is_directory: bool
+}
+
+external _open_readable: readable -&gt; in_file = &quot;ml_sevenzip_open_readable&quot;
+let open_readable readable =
+  try
+    _open_readable readable
+  with
+      Failure s -&gt; raise (Error s)
+
+external entries: in_file -&gt; entry array = &quot;ml_sevenzip_entries&quot;
+
+let open_in path =
+  let file = open_in path in
+  let buffer = String.create 65536 in
+    
+  let read n =
+    let length = String.length buffer in
+    let n = if n &gt; length then length else n in
+    let n = input file buffer 0 n in
+      (buffer, n) in
+    
+  let seek pos origin =
+    let pos =
+      match origin with
+          SeekSet -&gt; pos
+        | SeekCur -&gt; (pos_in file) + pos
+        | SeekEnd -&gt; (in_channel_length file) + pos in
+      seek_in file pos in
+
+    open_readable {read=read; seek=seek}
+
+
+let close_in t = ()

Modified: branches/0.77-branch/tools/ArchiveMoverLinux/mover.ml
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/mover.ml	2008-09-03 18:21:08 UTC (rev 6355)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/mover.ml	2008-09-04 08:12:47 UTC (rev 6356)
@@ -1,283 +1,175 @@
-open ExtString
+let die message = 
+  GToolbox.message_box ~title:&quot;Spring Archive Mover&quot; ~ok:&quot;Exit&quot; message;
+  GMain.Main.quit ()
 
-module Archive = struct
-  type t = Mod | Map | Unknown
+let warn message = 
+  GToolbox.message_box ~title:&quot;Spring Archive Mover&quot; ~ok:&quot;Ok&quot; message
 
-  let from_int int =
-    match int with
-        0 -&gt; Map
-      | 1 -&gt; Mod
-      | _ -&gt; Unknown
+let archive_mover path kind datadir =
+  (* Window *)
 
-  let to_int t =
-    match t with
-        Map -&gt; 0
-      | Mod -&gt; 1
-      | Unknown -&gt; -1
+  let window = GWindow.window
+    ~title:&quot;Spring Archive Mover&quot;
+    ~width:512
+    ~height:160
+    ~position:`CENTER
+    () in
+    
+  let _ = window#connect#destroy ~callback:GMain.Main.quit in
 
-  let from_zip path =
-    try
-      let in_zip = Zip.open_in path in
-      let entries = Zip.entries in_zip in
-      let test_files func =
-        let test entry = func (String.lowercase entry.Zip.filename) in
-          List.exists test entries
-      in
-      let is_map path =
-        let dirname = Filename.dirname path in
-        let basename = Filename.basename path in
-          if dirname = &quot;maps&quot; then
-            if String.ends_with basename &quot;.smf&quot; then
-              true
-            else if String.ends_with basename &quot;.sm3&quot; then
-              true
-            else
-              false
-          else
-            false
-      in
-        Zip.close_in in_zip;
-        if test_files is_map then Map
-        else if test_files (fun filename -&gt; filename = &quot;modinfo.tdf&quot;) then Mod
-        else if test_files (fun filename -&gt; filename = &quot;modinfo.lua&quot;) then Mod
-        else Unknown
-    with Zip.Error _ -&gt; Unknown
+  (* VBox *)
 
-  let from_path path  =
-    if String.ends_with path &quot;.sdz&quot; then
-      from_zip path
-    else if String.ends_with path &quot;.sd7&quot; then
-      Unknown
-    else
-      Unknown
-end
+  let vbox = GPack.vbox
+    ~packing:window#add
+    () in
+    
+  (* Table *)
 
-module FileSystem = struct
-  let copy src dst =
-    let string = String.create 4096 in
-    let in_chan = open_in_bin src in
-    let out_chan = open_out_bin dst in
-      
-    let rec f () =
-      let n = input in_chan string 0 (String.length string) in
-        if n = 0 then
-          ()
-        else
-          begin
-            output out_chan string 0 n;
-            f ()
-          end in
-      
-      f ();
-      close_in in_chan;
-      close_out out_chan
-        
-  let move src dst =
-    if src != dst then
-      try
-        Sys.rename src dst
-      with Sys_error _ -&gt;
-        copy src dst;
-        Sys.remove src
-    else
-      ()
-end
+  let table = GPack.table
+    ~col_spacings:5
+    ~packing:vbox#add
+    () in
+    
+  (* Spring Directory *)
 
+  let _ = GMisc.label
+    ~text:&quot;Spring directory&quot;
+    ~packing:(table#attach ~left:0 ~top:0)
+    () in
+    
+  let spring_dir_entry = GEdit.entry
+    ~packing:(table#attach ~left:1 ~top:0 ~expand:`X)
+    () in
+  let spring_dir_entry_defaults () = spring_dir_entry#set_text datadir in
+  let spring_dir_entry_get () = spring_dir_entry#text in
 
-module GUI = struct
-  exception InvalidOption of string
+  (* Filename *)
 
-  let install path dest =
-    try
-      let message = Printf.sprintf &quot;%s was successfully installed&quot; dest in
-        FileSystem.move path dest;
-        GToolbox.message_box ~title:&quot;Success&quot; ~ok:&quot;Exit&quot; message
-    with Sys_error (error_string) -&gt;
-      let message = Printf.sprintf &quot;Error: %s&quot; error_string in
-        GToolbox.message_box ~title:&quot;Error&quot; ~ok:&quot;Exit&quot; message
-              
-  let get_archive_dir combo_box =
-    let int = combo_box#active in
-    let archive = Archive.from_int int in
-      match archive with
-          Archive.Mod -&gt; &quot;mods&quot;
-        | Archive.Map -&gt; &quot;maps&quot;
-        | Archive.Unknown -&gt; raise (InvalidOption &quot;Please select an archive type&quot;)
+  let _ = GMisc.label
+    ~text:&quot;Filename&quot;
+    ~packing:(table#attach ~left:0 ~top:1)
+    () in
+    
+  let basename_entry = GEdit.entry
+    ~packing:(table#attach ~left:1 ~top:1 ~expand:`X)
+    () in
 
-  let get_springdir springdir_entry archive_dir =
-      let springdir = springdir_entry#text in
-      let datadir = Filename.concat springdir archive_dir in
-        if Sys.file_exists datadir then
-          if Sys.is_directory datadir then
-            datadir
-          else
-            raise (InvalidOption (Printf.sprintf &quot;%s isn't a directory&quot; datadir))
-        else
-          raise (InvalidOption (Printf.sprintf &quot;Install directory %s doesn't exist&quot; datadir))
+  let basename_entry_defaults () = basename_entry#set_text (Filename.basename path) in
+  let basename_entry_get () = basename_entry#text in
 
-  let get_basename_dir basename_entry =
-    let basename = basename_entry#text in
-      if basename = &quot;&quot; then
-        raise (InvalidOption &quot;Please enter a filename&quot;)
-      else
-        basename
+  (* Archive Kind *)
 
-  let install_archive path combo_box springdir_entry basename_entry =
-    try
-      let archive_dir = get_archive_dir combo_box in
-      let datadir = get_springdir springdir_entry archive_dir in
-      let basename = get_basename_dir basename_entry in
-      let dest = (Filename.concat datadir basename) in
-        install path dest;
-        GMain.Main.quit ()
-    with InvalidOption message -&gt; GToolbox.message_box ~title:&quot;Error&quot; message
-              
-  let detect_home_dir () =
-    try
-      let home_dir = Sys.getenv &quot;HOME&quot; in
-        Some home_dir
-    with Not_found -&gt; None
+  let _ = GMisc.label
+    ~text:&quot;Archive kind&quot;
+    ~packing:(table#attach ~left:0 ~top:2)
+    () in
 
-  let detect_springrc home_dir =
-    try
-      let springrc = Filename.concat home_dir &quot;.springrc&quot; in
-      let in_file = open_in springrc in
-      let input = IO.input_channel in_file in
-      let rec loop option =
-        try 
-          let line = IO.read_line input in
-            try
-              let (key, value) = String.split line &quot;=&quot; in
-                if key = &quot;SpringData&quot; then
-                  loop (Some value)
-                else
-                  loop option
-            with Invalid_string -&gt; loop option
-        with IO.No_more_input -&gt; option in
-      let option = loop None in
-        close_in in_file;
-        option
-    with Sys_error _ -&gt; None
+  let (kind_combobox, _) = GEdit.combo_box_text
+    ~strings:[&quot;Map&quot;; &quot;Mod&quot;]
+    ~packing:(table#attach ~left:1 ~top:2 ~expand:`X)
+    () in
 
-  let detect_datadir home_dir =
+  let kind_combobox_defaults () =
     try
-      let in_file = open_in &quot;/etc/spring/datadir&quot; in
-      let input = IO.input_channel in_file in
-      let format = IO.read_line input in
-      let (_, dir) = String.replace format &quot;$HOME&quot; home_dir in
-        close_in in_file;
-        Some dir
-    with Sys_error _ -&gt; None
+      let int = match kind with
+          Archive.Map -&gt; 0
+        | Archive.Mod -&gt; 1
+        | Archive.Unknown -&gt; -1 in
+        kind_combobox#set_active int
+    with
+        Archive.Error s -&gt; warn s in
 
-  let detect_spring_dir springdir_entry =
-    let dir = 
-      match detect_home_dir () with
-          Some home_dir -&gt;
-            (match detect_springrc home_dir with
-                Some springdir -&gt; springdir
-              | None -&gt;
-                  (match detect_datadir home_dir with
-                       Some springdir -&gt; springdir
-                     | None -&gt; Filename.concat home_dir &quot;.spring&quot;))
-        | None -&gt; &quot;&quot; in
-      springdir_entry#set_text dir
-        
-  let detect_basename path basename_entry =
-    let basename = Filename.basename path in
-      basename_entry#set_text basename
-        
-  let detect_archive_type path combo_box =
-    let archive = Archive.from_path path in
-      combo_box#set_active (Archive.to_int archive)
+  let kind_combobox_get () =
+    let int = kind_combobox#active in
+      match int with
+          0 -&gt; Archive.Map
+        | 1 -&gt; Archive.Mod
+        | _ -&gt; Archive.Unknown in
 
-  let detect_all path combo_box springdir_entry basename_entry =
-    detect_spring_dir springdir_entry;
-    detect_basename path basename_entry;
-    detect_archive_type path combo_box
-        
-  let main path =
-    let window = GWindow.window
-      ~title:&quot;ArchiveMover&quot;
-      ~width:512
-      ~height:192
-      ~position:`CENTER
-      () in
-      
-    let vbox = GPack.vbox
-      ~packing:window#add
-      () in
+  let button_box = GPack.button_box `HORIZONTAL
+    ~packing:(vbox#pack ~fill:false ~expand:false)
+    () in
+    
+  (* Exit *)
 
-    let table = GPack.table
-      ~col_spacings:5
-      ~packing:vbox#add
-      () in
+  let exit_button = GButton.button
+    ~label:&quot;Exit&quot;
+    ~packing:button_box#pack
+    () in
 
-    let _ = GMisc.label
-      ~text:&quot;Spring directory&quot;
-      ~packing:(table#attach ~left:0 ~top:0)
-      () in
+  let _ = exit_button#connect#clicked ~callback:GMain.Main.quit in
 
-    let springdir_entry = GEdit.entry
-      ~packing:(table#attach ~left:1 ~top:0 ~expand:`X)
-      () in
-      
-    let _ = GMisc.label
-      ~text:&quot;Filename&quot;
-      ~packing:(table#attach ~left:0 ~top:1)
-      () in
+  (* Defaults *)
+    
+  let defaults ()=
+    spring_dir_entry_defaults ();
+    basename_entry_defaults ();
+    kind_combobox_defaults () in
+    
+  let defaults_button = GButton.button
+    ~label:&quot;Defaults&quot;
+    ~packing:button_box#pack
+    () in
 
-    let basename_entry = GEdit.entry
-      ~packing:(table#attach ~left:1 ~top:1 ~expand:`X)
-      () in
-      
-    let _ = GMisc.label
-      ~text:&quot;Archive type&quot;
-      ~packing:(table#attach ~left:0 ~top:2)
-      () in
+  let _ = defaults_button#connect#clicked ~callback:defaults in
 
-    let (combo_box, _) = GEdit.combo_box_text
-      ~strings:[&quot;Map&quot;; &quot;Mod&quot;]
-      ~packing:(table#attach ~left:1 ~top:2 ~expand:`X)
-      () in
-      
-    let button_box = GPack.button_box `HORIZONTAL
-      ~packing:(vbox#pack ~fill:false ~expand:false)
-      () in
-      
-    let exit_button = GButton.button
-      ~label:&quot;Exit&quot;
-      ~packing:button_box#pack
-      () in
-    
-    let detect_button = GButton.button
-      ~label:&quot;Defaults&quot;
-      ~packing:button_box#pack
-      () in
+  (* Install *)
 
-    let install_button = GButton.button
-      ~label:&quot;Install&quot;
-      ~packing:button_box#pack
-      () in
+  let install () =
+    let spring_dir = spring_dir_entry_get () in
+    let basename = basename_entry_get () in
+    let kind = kind_combobox_get () in
 
-    let install () = install_archive path combo_box springdir_entry basename_entry in
-    let detect () = detect_all path combo_box springdir_entry basename_entry in
-    let _ = window#connect#destroy ~callback:GMain.Main.quit in
-    let _ = exit_button#connect#clicked ~callback:GMain.Main.quit in
-    let _ = detect_button#connect#clicked ~callback:detect in
-    let _ = install_button#connect#clicked ~callback:install in
-      window#show ();
-      detect ();
-      GtkMain.Main.main ()
-end
+    let install_dir sub_dir =
+      let dest_dir = Filename.concat spring_dir sub_dir in
+      let dest = Filename.concat dest_dir basename in
+        try
+          FileSystem.move path dest;
+          die (Printf.sprintf &quot;%s was successfully installed&quot; dest)
+        with
+            Sys_error s -&gt; die s in
+          
+      if spring_dir = &quot;&quot; then
+        warn &quot;You must specify the Spring directory&quot;
+      else
+        match kind with
+            Archive.Map -&gt; install_dir &quot;maps&quot;
+          | Archive.Mod -&gt; install_dir &quot;mods&quot;
+          | Archive.Unknown -&gt; warn &quot;You must specify the Archive kind&quot; in
 
-let usage () =
-  Printf.printf &quot;Usage: %s &lt;/path/to/archive.sdz&gt;\n&quot; Sys.argv.(0)
+  let install_button = GButton.button
+    ~label:&quot;Install&quot;
+    ~packing:button_box#pack
+    () in
 
-let main () =
-  if Array.length (Sys.argv) != 2 then
-    (usage ();
-     exit 1)
+  let _ = install_button#connect#clicked ~callback:install in
+  let () = window#focus#set (Some install_button#coerce) in
+
+    (* Body *)
+
+    defaults ();
+    window#show ()
+
+let fail message =
+  GToolbox.message_box
+    ~title:&quot;Spring Archive Mover&quot;
+    ~ok:&quot;Exit&quot;
+    message
+
+let usage () = fail (Printf.sprintf &quot;Usage: %s &lt;archive&gt;&quot; Sys.argv.(0))
+
+let parse_argv () =
+  if Array.length (Sys.argv) = 2 then
+    try
+      let path = Sys.argv.(1) in
+      let kind = Archive.detect_kind path in
+      let datadir = Datadir.detect () in
+        archive_mover path kind datadir;
+        GMain.Main.main ()
+    with
+        Archive.Error s -&gt; fail s
   else
-    GUI.main Sys.argv.(1)
-      
-let _ = main ()
+    usage ()
+
+let () = parse_argv ()
+

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/sd7.ml (from rev 6351, trunk/tools/ArchiveMoverLinux/sd7.ml)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/sd7.ml	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/sd7.ml	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,56 @@
+module Entry = struct
+  let make zip entry = object (self)
+    val zip = zip
+    val entry = entry
+
+    method name = entry.Sevenzip.filename
+    method size = entry.Sevenzip.uncompressed_size
+    (* method read = Sevenzip.read_entry zip entry *)
+    method read = &quot;STUB&quot;
+    method digest = Digest.string self#read
+  end
+end  
+
+module In = struct
+
+  let make zip path = object
+    val zip = zip
+    val path: string = path
+      
+    method unload = Sevenzip.close_in zip
+      
+    method entries =
+      let combine entries entry =
+        if entry.Sevenzip.is_directory then
+          entries
+        else
+          (Entry.make zip entry) :: entries
+      in
+        Array.fold_left combine [] (Sevenzip.entries zip)
+          
+    method path = path
+  end
+    
+  let load path =
+    let zip = Sevenzip.open_in path in
+      make zip path
+end
+
+(* module Out = struct *)
+
+(*   let make zip = object *)
+(*     val zip = zip *)
+      
+(*     method unload = Sevenzip.close_out zip *)
+      
+(*     method add_entry entry = *)
+(*       let filename = entry#name in *)
+(*       let data = entry#read in *)
+(*         Sevenzip.add_entry data zip filename *)
+(*   end *)
+          
+(*   let load path = *)
+(*     let zip = Sevenzip.open_out path in *)
+(*       make zip *)
+      
+(* end *)

Copied: branches/0.77-branch/tools/ArchiveMoverLinux/sdz.ml (from rev 6351, trunk/tools/ArchiveMoverLinux/sdz.ml)
===================================================================
--- branches/0.77-branch/tools/ArchiveMoverLinux/sdz.ml	                        (rev 0)
+++ branches/0.77-branch/tools/ArchiveMoverLinux/sdz.ml	2008-09-04 08:12:47 UTC (rev 6356)
@@ -0,0 +1,55 @@
+module Entry = struct
+  let make zip entry = object (self)
+    val zip = zip
+    val entry = entry
+
+    method name = entry.Zip.filename
+    method size = entry.Zip.uncompressed_size
+    method read = Zip.read_entry zip entry
+    method digest = Digest.string self#read
+  end
+end  
+
+module In = struct
+
+  let make zip path = object
+    val zip = zip
+    val path: string = path
+      
+    method unload = Zip.close_in zip
+      
+    method entries =
+      let combine entries entry =
+        if entry.Zip.is_directory then
+          entries
+        else
+          (Entry.make zip entry) :: entries
+      in
+        List.fold_left combine [] (Zip.entries zip)
+          
+    method path = path
+  end
+    
+  let load path =
+    let zip = Zip.open_in path in
+      make zip path
+end
+
+module Out = struct
+
+  let make zip = object
+    val zip = zip
+      
+    method unload = Zip.close_out zip
+      
+    method add_entry entry =
+      let filename = entry#name in
+      let data = entry#read in
+        Zip.add_entry data zip filename
+  end
+          
+  let load path =
+    let zip = Zip.open_out path in
+      make zip
+      
+end


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001125.html">[Taspring-linux-commit] r6355 - trunk/Lobby/TASClient
</A></li>
	<LI>Next message: <A HREF="001127.html">[Taspring-linux-commit] r6357 - in trunk/rts: Rendering/Env Sim/Path
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1126">[ date ]</a>
              <a href="thread.html#1126">[ thread ]</a>
              <a href="subject.html#1126">[ subject ]</a>
              <a href="author.html#1126">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
