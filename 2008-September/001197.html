<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6427 - in branches/0.77-branch: .	Lobby/TASClient Lobby/TASClient/Graphics	Lobby/TASClient/Python Lobby/TASClient/Python/engine	Lobby/TASClient/lobby/var	installer/builddata/springcontent/shaders installer/sections	rts rts/Game rts/Game/UI rts/Lua rts/Map/SMF	rts/Rendering/Env rts/Rendering/GL rts/Rendering/UnitModels	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Weapons rts/System rts/System/FileSystem	rts/System/Net rts/System/Platform/Win rts/System/Sync	rts/build/scons rts/build/vstudio8 rts/lib/gml tools	tools/MapDesigner tools/SpringInstaller tools/SpringInstaller/debian	tools/SpringInstaller/libmlsevenzip	tools/SpringInstaller/libmlsevenzip/libsevenzip	tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive	tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z	tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib	tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil	tools/unitsync
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6427%20-%20in%20branches/0.77-branch%3A%20.%0A%09Lobby/TASClient%20Lobby/TASClient/Graphics%0A%09Lobby/TASClient/Python%20Lobby/TASClient/Python/engine%0A%09Lobby/TASClient/lobby/var%0A%09installer/builddata/springcontent/shaders%20installer/sections%0A%09rts%20rts/Game%20rts/Game/UI%20rts/Lua%20rts/Map/SMF%0A%09rts/Rendering/Env%20rts/Rendering/GL%20rts/Rendering/UnitModels%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Units%0A%09rts/Sim/Weapons%20rts/System%20rts/System/FileSystem%0A%09rts/System/Net%20rts/System/Platform/Win%20rts/System/Sync%0A%09rts/build/scons%20rts/build/vstudio8%20rts/lib/gml%20tools%0A%09tools/MapDesigner%20tools/SpringInstaller%20tools/SpringInstaller/debian%0A%09tools/SpringInstaller/libmlsevenzip%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil%0A%09tools/unitsync&In-Reply-To=%3C20080915184442.046244A43%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001196.html">
   <LINK REL="Next"  HREF="001198.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6427 - in branches/0.77-branch: .	Lobby/TASClient Lobby/TASClient/Graphics	Lobby/TASClient/Python Lobby/TASClient/Python/engine	Lobby/TASClient/lobby/var	installer/builddata/springcontent/shaders installer/sections	rts rts/Game rts/Game/UI rts/Lua rts/Map/SMF	rts/Rendering/Env rts/Rendering/GL rts/Rendering/UnitModels	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Weapons rts/System rts/System/FileSystem	rts/System/Net rts/System/Platform/Win rts/System/Sync	rts/build/scons rts/build/vstudio8 rts/lib/gml tools	tools/MapDesigner tools/SpringInstaller tools/SpringInstaller/debian	tools/SpringInstaller/libmlsevenzip	tools/SpringInstaller/libmlsevenzip/libsevenzip	tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive	tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z	tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib	tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil	tools/unitsync</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6427%20-%20in%20branches/0.77-branch%3A%20.%0A%09Lobby/TASClient%20Lobby/TASClient/Graphics%0A%09Lobby/TASClient/Python%20Lobby/TASClient/Python/engine%0A%09Lobby/TASClient/lobby/var%0A%09installer/builddata/springcontent/shaders%20installer/sections%0A%09rts%20rts/Game%20rts/Game/UI%20rts/Lua%20rts/Map/SMF%0A%09rts/Rendering/Env%20rts/Rendering/GL%20rts/Rendering/UnitModels%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Units%0A%09rts/Sim/Weapons%20rts/System%20rts/System/FileSystem%0A%09rts/System/Net%20rts/System/Platform/Win%20rts/System/Sync%0A%09rts/build/scons%20rts/build/vstudio8%20rts/lib/gml%20tools%0A%09tools/MapDesigner%20tools/SpringInstaller%20tools/SpringInstaller/debian%0A%09tools/SpringInstaller/libmlsevenzip%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib%0A%09tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil%0A%09tools/unitsync&In-Reply-To=%3C20080915184442.046244A43%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6427 - in branches/0.77-branch: .	Lobby/TASClient Lobby/TASClient/Graphics	Lobby/TASClient/Python Lobby/TASClient/Python/engine	Lobby/TASClient/lobby/var	installer/builddata/springcontent/shaders installer/sections	rts rts/Game rts/Game/UI rts/Lua rts/Map/SMF	rts/Rendering/Env rts/Rendering/GL rts/Rendering/UnitModels	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Weapons rts/System rts/System/FileSystem	rts/System/Net rts/System/Platform/Win rts/System/Sync	rts/build/scons rts/build/vstudio8 rts/lib/gml tools	tools/MapDesigner tools/SpringInstaller tools/SpringInstaller/debian	tools/SpringInstaller/libmlsevenzip	tools/SpringInstaller/libmlsevenzip/libsevenzip	tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive	tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z	tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib	tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil	tools/unitsync">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Mon Sep 15 20:44:40 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001196.html">[Taspring-linux-commit] r6426 - trunk/rts/Rendering/UnitModels
</A></li>
        <LI>Next message: <A HREF="001198.html">[Taspring-linux-commit] r6428 - in trunk/rts: Game Game/UI Map/SMF	Rendering/GL System/Platform/Win lib/gml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1197">[ date ]</a>
              <a href="thread.html#1197">[ thread ]</a>
              <a href="subject.html#1197">[ subject ]</a>
              <a href="author.html#1197">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: Auswaschbar
Date: 2008-09-15 20:44:36 +0200 (Mon, 15 Sep 2008)
New Revision: 6427

Added:
   branches/0.77-branch/Lobby/TASClient/TipsFormUnit.ddp
   branches/0.77-branch/Lobby/TASClient/TipsFormUnit.dfm
   branches/0.77-branch/Lobby/TASClient/TipsFormUnit.pas
   branches/0.77-branch/Lobby/TASClient/lobby/var/tips.txt
   branches/0.77-branch/rts/System/Platform/Win/WinVersion.cpp
   branches/0.77-branch/rts/System/Platform/Win/WinVersion.h
   branches/0.77-branch/rts/System/Sync/SyncedPrimitiveBase.h
   branches/0.77-branch/rts/lib/gml/speedy-tls.cpp
   branches/0.77-branch/rts/lib/gml/speedy-tls.h
   branches/0.77-branch/tools/SpringInstaller/
   branches/0.77-branch/tools/SpringInstaller/Makefile
   branches/0.77-branch/tools/SpringInstaller/archive.ml
   branches/0.77-branch/tools/SpringInstaller/datadir.ml
   branches/0.77-branch/tools/SpringInstaller/debian/
   branches/0.77-branch/tools/SpringInstaller/debian/changelog
   branches/0.77-branch/tools/SpringInstaller/debian/compat
   branches/0.77-branch/tools/SpringInstaller/debian/control
   branches/0.77-branch/tools/SpringInstaller/debian/copyright
   branches/0.77-branch/tools/SpringInstaller/debian/dirs
   branches/0.77-branch/tools/SpringInstaller/debian/rules
   branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.desktop
   branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.mime
   branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo
   branches/0.77-branch/tools/SpringInstaller/fileSystem.ml
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/Makefile
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/sevenzip.ml
   branches/0.77-branch/tools/SpringInstaller/release.sh
   branches/0.77-branch/tools/SpringInstaller/sd7.ml
   branches/0.77-branch/tools/SpringInstaller/sdz.ml
   branches/0.77-branch/tools/SpringInstaller/spring_installer.ml
Removed:
   branches/0.77-branch/tools/ArchiveMoverLinux/
   branches/0.77-branch/tools/MapDesigner/Libraries/
   branches/0.77-branch/tools/SpringInstaller/Makefile
   branches/0.77-branch/tools/SpringInstaller/archive.ml
   branches/0.77-branch/tools/SpringInstaller/datadir.ml
   branches/0.77-branch/tools/SpringInstaller/debian/
   branches/0.77-branch/tools/SpringInstaller/debian/changelog
   branches/0.77-branch/tools/SpringInstaller/debian/compat
   branches/0.77-branch/tools/SpringInstaller/debian/control
   branches/0.77-branch/tools/SpringInstaller/debian/copyright
   branches/0.77-branch/tools/SpringInstaller/debian/dirs
   branches/0.77-branch/tools/SpringInstaller/debian/rules
   branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.desktop
   branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.mime
   branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo
   branches/0.77-branch/tools/SpringInstaller/fileSystem.ml
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/Makefile
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c
   branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/sevenzip.ml
   branches/0.77-branch/tools/SpringInstaller/release.sh
   branches/0.77-branch/tools/SpringInstaller/sd7.ml
   branches/0.77-branch/tools/SpringInstaller/sdz.ml
   branches/0.77-branch/tools/SpringInstaller/spring_installer.ml
Modified:
   branches/0.77-branch/CMakeLists.txt
   branches/0.77-branch/Lobby/TASClient/! readme !.txt
   branches/0.77-branch/Lobby/TASClient/BattleFormUnit.dfm
   branches/0.77-branch/Lobby/TASClient/BattleFormUnit.pas
   branches/0.77-branch/Lobby/TASClient/ColorsPreferenceUnit.dfm
   branches/0.77-branch/Lobby/TASClient/ColorsPreferenceUnit.pas
   branches/0.77-branch/Lobby/TASClient/ExceptionUnit.dfm
   branches/0.77-branch/Lobby/TASClient/Graphics/connect1.bmp
   branches/0.77-branch/Lobby/TASClient/Graphics/connect2.bmp
   branches/0.77-branch/Lobby/TASClient/Graphics/connect3.bmp
   branches/0.77-branch/Lobby/TASClient/HelpUnit.dfm
   branches/0.77-branch/Lobby/TASClient/HelpUnit.pas
   branches/0.77-branch/Lobby/TASClient/HighlightingUnit.pas
   branches/0.77-branch/Lobby/TASClient/HttpGetUnit.pas
   branches/0.77-branch/Lobby/TASClient/LobbyScriptUnit.pas
   branches/0.77-branch/Lobby/TASClient/LogonFormUnit.pas
   branches/0.77-branch/Lobby/TASClient/MainUnit.dfm
   branches/0.77-branch/Lobby/TASClient/MainUnit.pas
   branches/0.77-branch/Lobby/TASClient/ManageGroups.dfm
   branches/0.77-branch/Lobby/TASClient/ManageGroups.pas
   branches/0.77-branch/Lobby/TASClient/MapListFormUnit.pas
   branches/0.77-branch/Lobby/TASClient/Misc.pas
   branches/0.77-branch/Lobby/TASClient/PreferencesFormUnit.dfm
   branches/0.77-branch/Lobby/TASClient/PreferencesFormUnit.pas
   branches/0.77-branch/Lobby/TASClient/Python/api.txt
   branches/0.77-branch/Lobby/TASClient/Python/engine/handlers.py
   branches/0.77-branch/Lobby/TASClient/ReplaysUnit.dfm
   branches/0.77-branch/Lobby/TASClient/ReplaysUnit.pas
   branches/0.77-branch/Lobby/TASClient/SplashScreenUnit.dfm
   branches/0.77-branch/Lobby/TASClient/TASClient.dof
   branches/0.77-branch/Lobby/TASClient/TASClient.dpr
   branches/0.77-branch/Lobby/TASClient/TASClient.res
   branches/0.77-branch/Lobby/TASClient/UploadReplayUnit.dfm
   branches/0.77-branch/Lobby/TASClient/UploadReplayUnit.pas
   branches/0.77-branch/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
   branches/0.77-branch/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
   branches/0.77-branch/installer/sections/main.nsh
   branches/0.77-branch/rts/CMakeLists.txt
   branches/0.77-branch/rts/Game/Game.cpp
   branches/0.77-branch/rts/Game/GameHelper.h
   branches/0.77-branch/rts/Game/GameServer.cpp
   branches/0.77-branch/rts/Game/GameSetup.cpp
   branches/0.77-branch/rts/Game/PreGame.cpp
   branches/0.77-branch/rts/Game/UI/MiniMap.cpp
   branches/0.77-branch/rts/Lua/LuaMaterial.cpp
   branches/0.77-branch/rts/Lua/LuaUnitMaterial.h
   branches/0.77-branch/rts/Lua/LuaUnsyncedCtrl.cpp
   branches/0.77-branch/rts/Lua/LuaUnsyncedCtrl.h
   branches/0.77-branch/rts/Lua/LuaWeaponDefs.cpp
   branches/0.77-branch/rts/Map/SMF/BFGroundDrawer.cpp
   branches/0.77-branch/rts/Map/SMF/BFGroundDrawer.h
   branches/0.77-branch/rts/Map/SMF/BFGroundTextures.cpp
   branches/0.77-branch/rts/Map/SMF/BFGroundTextures.h
   branches/0.77-branch/rts/Rendering/Env/BumpWater.cpp
   branches/0.77-branch/rts/Rendering/Env/BumpWater.h
   branches/0.77-branch/rts/Rendering/GL/myGL.cpp
   branches/0.77-branch/rts/Rendering/UnitModels/UnitDrawer.cpp
   branches/0.77-branch/rts/Rendering/UnitModels/UnitDrawer.h
   branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp
   branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.cpp
   branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp
   branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp
   branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
   branches/0.77-branch/rts/Sim/Units/UnitDefHandler.cpp
   branches/0.77-branch/rts/Sim/Units/UnitDefHandler.h
   branches/0.77-branch/rts/Sim/Units/UnitLoader.cpp
   branches/0.77-branch/rts/Sim/Weapons/EmgCannon.cpp
   branches/0.77-branch/rts/Sim/Weapons/Weapon.cpp
   branches/0.77-branch/rts/Sim/Weapons/Weapon.h
   branches/0.77-branch/rts/Sim/Weapons/WeaponDefHandler.cpp
   branches/0.77-branch/rts/Sim/Weapons/WeaponDefHandler.h
   branches/0.77-branch/rts/System/BaseNetProtocol.cpp
   branches/0.77-branch/rts/System/BaseNetProtocol.h
   branches/0.77-branch/rts/System/FileSystem/ArchiveScanner.cpp
   branches/0.77-branch/rts/System/GlobalStuff.cpp
   branches/0.77-branch/rts/System/Net/UDPConnection.h
   branches/0.77-branch/rts/System/SpringApp.cpp
   branches/0.77-branch/rts/System/Sync/Logger.h
   branches/0.77-branch/rts/System/Sync/SyncChecker.h
   branches/0.77-branch/rts/System/Sync/SyncDebugger.cpp
   branches/0.77-branch/rts/System/Sync/SyncDebugger.h
   branches/0.77-branch/rts/System/Sync/SyncTracer.cpp
   branches/0.77-branch/rts/System/Sync/SyncTracer.h
   branches/0.77-branch/rts/System/Sync/SyncedPrimitive.h
   branches/0.77-branch/rts/build/scons/rts.py
   branches/0.77-branch/rts/build/vstudio8/rts.vcproj
   branches/0.77-branch/rts/lib/gml/gml.cpp
   branches/0.77-branch/rts/lib/gml/gmlcls.h
   branches/0.77-branch/rts/lib/gml/gmlsrv.h
   branches/0.77-branch/tools/unitsync/unitsync.cpp
Log:
* update to 6422


Modified: branches/0.77-branch/CMakeLists.txt
===================================================================
--- branches/0.77-branch/CMakeLists.txt	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/CMakeLists.txt	2008-09-15 18:44:36 UTC (rev 6427)
@@ -8,9 +8,11 @@
 set (BINDIR &quot;bin&quot; CACHE STRING &quot;Where to install binaries&quot;)
 set (LIBDIR &quot;lib&quot; CACHE STRING &quot;Where to install libraries&quot;)
 set (DATADIR &quot;share/games/spring&quot; CACHE STRING &quot;Where to install game content&quot;)
-set (APPLICATIONS_DIR &quot;share/applications&quot; CACHE STRING &quot;Where to install desktop files&quot;)
-set (PIXMAPS_DIR &quot;share/pixmaps&quot; CACHE STRING &quot;Where to install icons&quot;)
-set (MIME_DIR &quot;share/mime&quot;CACHE STRING &quot;Where MIME definitions are located&quot;)
+if (UNIX AND NOT MINGW)
+	set (APPLICATIONS_DIR &quot;share/applications&quot; CACHE STRING &quot;Where to install desktop files&quot;)
+	set (PIXMAPS_DIR &quot;share/pixmaps&quot; CACHE STRING &quot;Where to install icons&quot;)
+	set (MIME_DIR &quot;share/mime&quot;CACHE STRING &quot;Where MIME definitions are located&quot;)
+endif (UNIX AND NOT MINGW)
 
 ### Usr-definable build options
 SET(SYNCCHECK TRUE CACHE BOOL &quot;Check sync during gameplay (Required for online play!)&quot;)
@@ -28,6 +30,11 @@
 	ADD_DEFINITIONS(-DSPRING_DATADIR=&quot;${SPRING_DATADIR}&quot;)
 endif (SPRING_DATADIR)
 
+set (CUSTOM_COMPILER_DEFINITIONS &quot;&quot; CACHE STRING &quot;Custom flags can be defined here&quot;)
+if (CUSTOM_COMPILER_DEFINITIONS)
+	ADD_DEFINITIONS(${CUSTOM_COMPILER_DEFINITIONS})
+endif (CUSTOM_COMPILER_DEFINITIONS)
+
 ### mingwlibs
 if (MINGW)
 	SET(MINGWLIBS ${CMAKE_SOURCE_DIR}/mingwlibs CACHE PATH &quot;Location of the mingwlibs (you can't build windows executables without them)&quot;)

Modified: branches/0.77-branch/Lobby/TASClient/! readme !.txt
===================================================================
--- branches/0.77-branch/Lobby/TASClient/! readme !.txt	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/! readme !.txt	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,8 +1,8 @@
-UPDATED: 12 Aug 2008
+UPDATED: 8 Sep 2008
 
 *** In order to compile the sources, you'll have to install some free 3rd-party components: ***
 
-*** This archive should contains everything you need to compile the lobby : <A HREF="http://tasclient.it-l.eu/TASClient_SDK.7z">http://tasclient.it-l.eu/TASClient_SDK.7z</A>
+*** The following archive should contains everything you need to compile the lobby : <A HREF="http://tasclient.it-l.eu/TASClient_SDK.7z">http://tasclient.it-l.eu/TASClient_SDK.7z</A> ***
 
 - TjanTracker (Included with these sources - just install janTracker.pas)
 - Virtual TreeView component: <A HREF="http://www.lischke-online.de/VirtualTreeview/">http://www.lischke-online.de/VirtualTreeview/</A>
@@ -11,6 +11,7 @@
 - RichEditURL (Included with these sources - just install RichEditURL.pas)
 - TExImage (Included with these sources - just install ImageEx.pas)
 - JVCL (<A HREF="http://homepages.borland.com/jedi/jvcl/">http://homepages.borland.com/jedi/jvcl/</A>) - download JVCL+JCL bundle
+- 7zipJCL (autoupdate feature) <A HREF="http://www.rg-software.de/rg/index.php?option=com_content&amp;task=view&amp;id=29&amp;Itemid=51">http://www.rg-software.de/rg/index.php?option=com_content&amp;task=view&amp;id=29&amp;Itemid=51</A>
 - Python For Delphi (<A HREF="http://mmm-experts.com/Products.aspx?ProductID=3">http://mmm-experts.com/Products.aspx?ProductID=3</A>)
 
 Note: All components that are included with the sources are located
@@ -47,7 +48,6 @@
 - SpTBXLib 1.8.1 (<A HREF="http://club.telepolis.com/silverpointdev/sptbxlib/index.htm">http://club.telepolis.com/silverpointdev/sptbxlib/index.htm</A>)
 - Additional TBX themes (<A HREF="http://www.rmklever.com/zipfiles/TBXThemes21.zip">http://www.rmklever.com/zipfiles/TBXThemes21.zip</A>)
 - PngImage (for the macosx theme only)
-- 7zipJCL (autoupdate feature) <A HREF="http://www.rg-software.de/rg/index.php?option=com_content&amp;task=view&amp;id=29&amp;Itemid=51">http://www.rg-software.de/rg/index.php?option=com_content&amp;task=view&amp;id=29&amp;Itemid=51</A>
 
 To install these components, you should use Silverpoint MultiInstaller
 (<A HREF="http://club.telepolis.com/silverpointdev/multiinstaller/index.htm">http://club.telepolis.com/silverpointdev/multiinstaller/index.htm</A>),
@@ -70,12 +70,22 @@
   no tick here - it should be disabled)).
 
 *** Command line arguments ***
-- -wine: use to force Wine compatibility mode
 
+-wine
+	use to force Wine compatibility mode
+-server address:port
+	change the default server and port
+-menu
+	show the SP menu first
+-menudev
+	use the Spring\Interface dir to get the skin files instead of the skin archive
+	
+
 *** Credits for various graphics: ***
 
-- Neuralize (most buttons, client status symbols and battle icons)
-- RuneCrafter (splash screen and other stuff) 
+- Yatta (new status icons)
+- Neuralize (most buttons, old client status symbols and old battle icons)
+- RuneCrafter (old splash screen and other stuff) 
 - Maelstrom (NAT warning icon, &quot;bot mode&quot; icon)
 - IceXuick (map grade icons, some popup menu icons)
 - Some icons are taken from the TBX components (demo app)
\ No newline at end of file

Modified: branches/0.77-branch/Lobby/TASClient/BattleFormUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/BattleFormUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/BattleFormUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,7 +1,7 @@
 object BattleForm: TBattleForm
-  Left = 684
-  Top = 169
-  Width = 783
+  Left = 687
+  Top = 50
+  Width = 830
   Height = 586
   Caption = 'Battle window'
   Color = clBtnFace
@@ -24,33 +24,13 @@
   object SpTBXTitleBar1: TSpTBXTitleBar
     Left = 0
     Top = 0
-    Width = 775
+    Width = 822
     Height = 559
     Caption = 'Battle window'
-    object Splitter1: TSplitter
-      Left = 4
-      Top = 413
-      Width = 767
-      Height = 3
-      Cursor = crVSplit
-      Align = alTop
-      AutoSnap = False
-      ResizeStyle = rsUpdate
-    end
-    object Splitter2: TSplitter
-      Left = 4
-      Top = 305
-      Width = 767
-      Height = 3
-      Cursor = crVSplit
-      Align = alTop
-      AutoSnap = False
-      ResizeStyle = rsUpdate
-    end
     object Panel3: TSpTBXPanel
       Left = 4
       Top = 514
-      Width = 767
+      Width = 814
       Height = 41
       Align = alBottom
       Color = clNone
@@ -59,7 +39,7 @@
       BorderType = pbrRaised
       TBXStyleBackground = True
       DesignSize = (
-        767
+        814
         41)
       object StartButton: TSpTBXButton
         Left = 104
@@ -153,7 +133,7 @@
         LinkFont.Style = [fsUnderline]
       end
       object LadderRulesButton: TSpTBXButton
-        Left = 681
+        Left = 728
         Top = 8
         Width = 75
         Height = 25
@@ -187,9 +167,9 @@
     end
     object Panel2: TPanel
       Left = 4
-      Top = 416
-      Width = 767
-      Height = 98
+      Top = 426
+      Width = 814
+      Height = 88
       Align = alClient
       TabOrder = 2
       object NoMapImage: TImage
@@ -4041,6 +4021,7 @@
         TabOrder = 0
         URLColor = clBlue
         URLCursor = crHandPoint
+        OnDblClick = ChatExRichEditDblClick
         OnMouseDown = ChaTRichEditMouseDown
         OnURLClick = ChaTExRichEditURLClick
         InputFormat = ifText
@@ -4057,6 +4038,7 @@
         Width = 225
         Height = 21
         TabOrder = 1
+        WordWrap = False
         OnKeyDown = InputEditKeyDown
         OnKeyPress = InputEditKeyPress
       end
@@ -4064,12 +4046,12 @@
     object Panel1: TPanel
       Left = 4
       Top = 30
-      Width = 767
+      Width = 814
       Height = 275
       Align = alTop
       TabOrder = 3
       object Panel5: TPanel
-        Left = 347
+        Left = 394
         Top = 1
         Width = 419
         Height = 273
@@ -4083,13 +4065,14 @@
           Height = 273
           Align = alClient
           Color = clBtnFace
-          ActiveTabIndex = 2
+          ActiveTabIndex = 0
           TabAutofit = True
           ThemeType = tttNone
           OnActiveTabChange = SpTBXTabControl1ActiveTabChange
           HiddenItems = &lt;&gt;
           object GameOptionsTab: TSpTBXTabItem
             Caption = 'Game options'
+            Checked = True
             CustomWidth = 103
             CustomHeight = 30
             ThemeType = tttNone
@@ -4103,7 +4086,6 @@
           object MapTab: TSpTBXTabItem
             Caption = 'Map options'
             Wrapping = twWrap
-            Checked = True
             CustomWidth = 103
             ThemeType = tttNone
           end
@@ -4262,6 +4244,86 @@
               end
             end
           end
+          object MapTabSheet: TSpTBXTabSheet
+            Left = 0
+            Top = 34
+            Width = 419
+            Height = 239
+            Caption = 'Map options'
+            ImageIndex = -1
+            DesignSize = (
+              419
+              239)
+            TabItem = 'MapTab'
+            object MapOptionsScrollBox: TTntScrollBox
+              Left = 8
+              Top = 48
+              Width = 402
+              Height = 189
+              VertScrollBar.Smooth = True
+              VertScrollBar.Tracking = True
+              Anchors = [akLeft, akTop, akRight, akBottom]
+              BiDiMode = bdLeftToRight
+              BorderStyle = bsNone
+              Color = clBtnFace
+              Ctl3D = False
+              ParentBiDiMode = False
+              ParentBackground = True
+              ParentColor = False
+              ParentCtl3D = False
+              TabOrder = 0
+            end
+            object panelMapOptionsDefault: TSpTBXPanel
+              Left = 8
+              Top = 4
+              Width = 402
+              Height = 41
+              Align = alCustom
+              TabOrder = 1
+              object btLoadDefaultMPO: TSpTBXButton
+                Left = 149
+                Top = 8
+                Width = 113
+                Height = 25
+                Caption = 'Load default'
+                TabOrder = 0
+                OnClick = btLoadDefaultMPOClick
+                LinkFont.Charset = DEFAULT_CHARSET
+                LinkFont.Color = clBlue
+                LinkFont.Height = -11
+                LinkFont.Name = 'MS Sans Serif'
+                LinkFont.Style = [fsUnderline]
+              end
+              object btSetAsDefaultMPO: TSpTBXButton
+                Left = 269
+                Top = 8
+                Width = 113
+                Height = 25
+                Caption = 'Set as default'
+                TabOrder = 1
+                OnClick = btSetAsDefaultMPOClick
+                LinkFont.Charset = DEFAULT_CHARSET
+                LinkFont.Color = clBlue
+                LinkFont.Height = -11
+                LinkFont.Name = 'MS Sans Serif'
+                LinkFont.Style = [fsUnderline]
+              end
+              object btLoadMapsDefaultMPO: TSpTBXButton
+                Left = 29
+                Top = 8
+                Width = 113
+                Height = 25
+                Caption = 'Load map'#39's default'
+                TabOrder = 2
+                OnClick = btLoadMapsDefaultMPOClick
+                LinkFont.Charset = DEFAULT_CHARSET
+                LinkFont.Color = clBlue
+                LinkFont.Height = -11
+                LinkFont.Name = 'MS Sans Serif'
+                LinkFont.Style = [fsUnderline]
+              end
+            end
+          end
           object SpTBXTabSheet2: TSpTBXTabSheet
             Left = 0
             Top = 34
@@ -4476,9 +4538,15 @@
               Top = 80
               Width = 225
               Height = 65
+              Hint = 
+                'Lineage mode = Every units or building you made will explode if ' +
+                'your commander dies (You can'#39't share your units just before your' +
+                ' commander dies)'
               Caption = 'Game end condition'
               Color = clNone
               ParentColor = False
+              ParentShowHint = False
+              ShowHint = True
               TabOrder = 6
               OnClick = GameEndRadioGroupClick
               ItemIndex = 0
@@ -4532,92 +4600,12 @@
               LinkFont.Style = [fsUnderline]
             end
           end
-          object MapTabSheet: TSpTBXTabSheet
-            Left = 0
-            Top = 34
-            Width = 419
-            Height = 239
-            Caption = 'Map options'
-            ImageIndex = -1
-            DesignSize = (
-              419
-              239)
-            TabItem = 'MapTab'
-            object MapOptionsScrollBox: TTntScrollBox
-              Left = 8
-              Top = 48
-              Width = 402
-              Height = 189
-              VertScrollBar.Smooth = True
-              VertScrollBar.Tracking = True
-              Anchors = [akLeft, akTop, akRight, akBottom]
-              BiDiMode = bdLeftToRight
-              BorderStyle = bsNone
-              Color = clBtnFace
-              Ctl3D = False
-              ParentBiDiMode = False
-              ParentBackground = True
-              ParentColor = False
-              ParentCtl3D = False
-              TabOrder = 0
-            end
-            object panelMapOptionsDefault: TSpTBXPanel
-              Left = 8
-              Top = 4
-              Width = 402
-              Height = 41
-              Align = alCustom
-              TabOrder = 1
-              object btLoadDefaultMPO: TSpTBXButton
-                Left = 149
-                Top = 8
-                Width = 113
-                Height = 25
-                Caption = 'Load default'
-                TabOrder = 0
-                OnClick = btLoadDefaultMPOClick
-                LinkFont.Charset = DEFAULT_CHARSET
-                LinkFont.Color = clBlue
-                LinkFont.Height = -11
-                LinkFont.Name = 'MS Sans Serif'
-                LinkFont.Style = [fsUnderline]
-              end
-              object btSetAsDefaultMPO: TSpTBXButton
-                Left = 269
-                Top = 8
-                Width = 113
-                Height = 25
-                Caption = 'Set as default'
-                TabOrder = 1
-                OnClick = btSetAsDefaultMPOClick
-                LinkFont.Charset = DEFAULT_CHARSET
-                LinkFont.Color = clBlue
-                LinkFont.Height = -11
-                LinkFont.Name = 'MS Sans Serif'
-                LinkFont.Style = [fsUnderline]
-              end
-              object btLoadMapsDefaultMPO: TSpTBXButton
-                Left = 29
-                Top = 8
-                Width = 113
-                Height = 25
-                Caption = 'Load map'#39's default'
-                TabOrder = 2
-                OnClick = btLoadMapsDefaultMPOClick
-                LinkFont.Charset = DEFAULT_CHARSET
-                LinkFont.Color = clBlue
-                LinkFont.Height = -11
-                LinkFont.Name = 'MS Sans Serif'
-                LinkFont.Style = [fsUnderline]
-              end
-            end
-          end
         end
       end
       object Panel6: TPanel
         Left = 1
         Top = 1
-        Width = 346
+        Width = 393
         Height = 273
         Align = alClient
         BevelOuter = bvNone
@@ -4626,7 +4614,7 @@
         object MapPanel: TSpTBXPanel
           Left = 0
           Top = 0
-          Width = 346
+          Width = 393
           Height = 273
           Align = alClient
           Color = clNone
@@ -4636,12 +4624,12 @@
           OnResize = MapPanelResize
           TBXStyleBackground = True
           DesignSize = (
-            346
+            393
             273)
           object Bevel2: TBevel
             Left = 0
             Top = 219
-            Width = 346
+            Width = 393
             Height = 46
             Anchors = [akLeft, akRight, akBottom]
             Shape = bsTopLine
@@ -4649,7 +4637,7 @@
           object MapImage: TImageEx
             Left = 5
             Top = 5
-            Width = 217
+            Width = 264
             Height = 216
             Cursor = crHandPoint
             Hint = 'No map'
@@ -4665,7 +4653,7 @@
           object MapDescLabel: TSpTBXLabel
             Left = 8
             Top = 224
-            Width = 330
+            Width = 377
             Height = 41
             Caption = 'MapDescLabel'
             Anchors = [akLeft, akRight, akBottom]
@@ -4681,7 +4669,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object TidalStrengthLabel: TSpTBXLabel
-            Left = 233
+            Left = 280
             Top = 143
             Width = 76
             Height = 13
@@ -4694,7 +4682,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object GravityLabel: TSpTBXLabel
-            Left = 233
+            Left = 280
             Top = 158
             Width = 45
             Height = 13
@@ -4707,7 +4695,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object MaxMetalLabel: TSpTBXLabel
-            Left = 233
+            Left = 280
             Top = 173
             Width = 63
             Height = 13
@@ -4720,7 +4708,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object ExtRadiusLabel: TSpTBXLabel
-            Left = 233
+            Left = 280
             Top = 188
             Width = 85
             Height = 13
@@ -4733,7 +4721,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object WindLabel: TSpTBXLabel
-            Left = 233
+            Left = 280
             Top = 203
             Width = 86
             Height = 13
@@ -4746,7 +4734,7 @@
             LinkFont.Style = [fsUnderline]
           end
           object SpTBXPanel1: TSpTBXPanel
-            Left = 225
+            Left = 272
             Top = 4
             Width = 113
             Height = 122
@@ -4769,7 +4757,7 @@
               Width = 81
               Height = 17
               BorderSize = 2
-              Caption = 'More maps ...'
+              Caption = 'Map list ...'
               SmartFocus = False
               TabOrder = 0
               OnClick = MapsButtonClick
@@ -4826,10 +4814,11 @@
               LinkFont.Height = -11
               LinkFont.Name = 'MS Sans Serif'
               LinkFont.Style = [fsUnderline]
+              ThemeType = thtTBX
             end
           end
           object MapSizeLabel: TSpTBXLabel
-            Left = 233
+            Left = 280
             Top = 128
             Width = 54
             Height = 13
@@ -4844,21 +4833,24 @@
         end
       end
     end
-    object Panel4: TPanel
+    object Panel4: TSpTBXPanel
       Left = 4
-      Top = 308
-      Width = 767
-      Height = 105
+      Top = 311
+      Width = 814
+      Height = 109
+      Caption = 'Panel4'
       Align = alTop
       TabOrder = 4
+      BorderType = pbrRaised
+      TBXStyleBackground = True
       DesignSize = (
-        767
-        105)
+        814
+        109)
       object VDTBattleClients: TVirtualDrawTree
         Left = 8
         Top = 8
-        Width = 457
-        Height = 89
+        Width = 504
+        Height = 94
         Anchors = [akLeft, akTop, akRight, akBottom]
         Font.Charset = DEFAULT_CHARSET
         Font.Color = clWindowText
@@ -4922,7 +4914,7 @@
           end
           item
             Position = 6
-            Width = 10
+            Width = 35
             WideText = 'Player Bonus'
           end
           item
@@ -4943,8 +4935,25 @@
             WideText = 'Order'
           end&gt;
       end
+      object lblTeamNbr: TSpTBXLabel
+        Left = 517
+        Top = 8
+        Width = 44
+        Height = 13
+        Hint = 'Team counters'
+        Caption = '0/0'
+        Anchors = [akTop, akRight]
+        ParentShowHint = False
+        ShowHint = True
+        Wrapping = twWrap
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
       object MyOptionsGroupBox: TSpTBXGroupBox
-        Left = 517
+        Left = 564
         Top = 5
         Width = 242
         Height = 92
@@ -4952,8 +4961,7 @@
         Anchors = [akTop, akRight]
         Color = clNone
         ParentColor = False
-        TabOrder = 1
-        TBXStyleBackground = True
+        TabOrder = 2
         object Label11: TSpTBXLabel
           Left = 16
           Top = 20
@@ -5055,24 +5063,25 @@
           LinkFont.Style = [fsUnderline]
         end
       end
-      object lblTeamNbr: TSpTBXLabel
-        Left = 470
-        Top = 8
-        Width = 44
-        Height = 13
-        Hint = 'Team counters'
-        Caption = '0/0'
-        Anchors = [akTop, akRight]
-        ParentShowHint = False
-        ShowHint = True
-        Wrapping = twWrap
-        LinkFont.Charset = DEFAULT_CHARSET
-        LinkFont.Color = clBlue
-        LinkFont.Height = -11
-        LinkFont.Name = 'MS Sans Serif'
-        LinkFont.Style = [fsUnderline]
-      end
     end
+    object Splitter2: TSpTBXSplitter
+      Left = 4
+      Top = 305
+      Width = 814
+      Height = 6
+      Cursor = crSizeNS
+      Caption = 'Splitter1'
+      Align = alTop
+    end
+    object SpTBXSplitter2: TSpTBXSplitter
+      Left = 4
+      Top = 420
+      Width = 814
+      Height = 6
+      Cursor = crSizeNS
+      Caption = 'SpTBXSplitter2'
+      Align = alTop
+    end
   end
   object GameTimer: TTimer
     Enabled = False
@@ -5122,12 +5131,12 @@
   end
   object ChooseSidePopupMenu: TSpTBXPopupMenu
     Left = 672
-    Top = 292
+    Top = 300
   end
   object PlayerControlPopupMenu: TSpTBXPopupMenu
     OnInitPopup = PlayerControlPopupMenuInitPopup
     Left = 304
-    Top = 360
+    Top = 352
     object SetTeamItem: TSpTBXSubmenuItem
       Caption = 'Set id'
       OnClick = SetTeamItemClick

Modified: branches/0.77-branch/Lobby/TASClient/BattleFormUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/BattleFormUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/BattleFormUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -189,7 +189,6 @@
     LockedCheckBox: TSpTBXCheckBox;
     Panel2: TPanel;
     NoMapImage: TImage;
-    Splitter1: TSplitter;
     Panel1: TPanel;
     BalanceTeamsPopupMenu: TSpTBXPopupMenu;
     SpTBXItem8: TSpTBXItem;
@@ -231,18 +230,6 @@
     mnuAddToGroup: TSpTBXSubmenuItem;
     mnuNewGroup: TSpTBXItem;
     SpTBXSeparatorItem6: TSpTBXSeparatorItem;
-    Panel4: TPanel;
-    Splitter2: TSplitter;
-    VDTBattleClients: TVirtualDrawTree;
-    MyOptionsGroupBox: TSpTBXGroupBox;
-    Label11: TSpTBXLabel;
-    Label12: TSpTBXLabel;
-    TeamColorSpeedButton: TSpTBXSpeedButton;
-    SpectateCheckBox: TSpTBXCheckBox;
-    MyTeamNoButton: TTBXButton;
-    MyAllyNoButton: TTBXButton;
-    MySideButton: TSpTBXSpeedButton;
-    lblTeamNbr: TSpTBXLabel;
     Panel5: TPanel;
     SpTBXTabControl1: TSpTBXTabControl;
     GameOptionsTab: TSpTBXTabItem;
@@ -311,6 +298,19 @@
     MapsPopupMenu: TSpTBXFormPopupMenu;
     DropDownMapSelectionButton: TSpTBXButton;
     InputEdit: TTntMemo;
+    Panel4: TSpTBXPanel;
+    VDTBattleClients: TVirtualDrawTree;
+    lblTeamNbr: TSpTBXLabel;
+    MyOptionsGroupBox: TSpTBXGroupBox;
+    Label11: TSpTBXLabel;
+    Label12: TSpTBXLabel;
+    TeamColorSpeedButton: TSpTBXSpeedButton;
+    SpectateCheckBox: TSpTBXCheckBox;
+    MyTeamNoButton: TTBXButton;
+    MyAllyNoButton: TTBXButton;
+    MySideButton: TSpTBXSpeedButton;
+    Splitter2: TSpTBXSplitter;
+    SpTBXSplitter2: TSpTBXSplitter;
 
     procedure CreateParams(var Params: TCreateParams); override;
 
@@ -388,7 +388,7 @@
     procedure UnitsTrackerMouseUpAfterChange(Sender: TObject);
     procedure StartPosRadioGroupClick(Sender: TObject);
     procedure GameTimerTimer(Sender: TObject);
-    procedure UploadReplay;
+    procedure UploadReplayAndLadderReport;
     procedure InputEditKeyPress(Sender: TObject; var Key: Char);
     procedure InputEditKeyDown(Sender: TObject; var Key: Word;
       Shift: TShiftState);
@@ -672,7 +672,7 @@
   CustomColorUnit, StringParser, MapListFormUnit, AutoTeamsUnit,
   AutoStartRectsUnit, ColorPicker, UploadReplayUnit, ProgressBarWindow,
   TntWideStrings, LobbyScriptUnit, SpringDownloaderFormUnit,
-  MapSelectionFormUnit;
+  MapSelectionFormUnit, TipsFormUnit;
 
 {$R *.dfm}
 
@@ -1456,7 +1456,7 @@
     VDTBattleClients.Header.Columns[8].MaxWidth := 0;
   end;
 
-  AddTextToChat('Joined battle', Colors.Info, 1);
+  AddTextToChat('Joined battle'+EOL, Colors.Info, 1);
 
   ResetStartRects;
   BattleForm.Caption := 'Battle window (' + BattleState.Battle.ModName + ')'; // this has no effect since battle form was skinned using TSpTBXTitleBar!
@@ -1470,6 +1470,8 @@
 
   if not Preferences.DisableAllSounds then PlayResSound('battle');
 
+  TipsForm.ShowTips(2);
+
 //*** anything else?
 end;
 
@@ -1562,6 +1564,8 @@
 
   if not Preferences.DisableAllSounds then PlayResSound('battle');
 
+  TipsForm.ShowTips(2);
+
 //*** anything else?
 end;
 
@@ -1674,6 +1678,8 @@
 
   AddTextToChat('Battle opened', Colors.Info, 1);
 
+  TipsForm.ShowTips(1);
+
 //*** anything else?
 end;
 
@@ -2413,7 +2419,6 @@
 
   InputEdit.Align := alBottom;
   ChatRichEdit.Align := alClient;
-  ChatRichEdit.OnDblClick := ChatExRichEditDblClick;
 
   mask := SendMessage(ChatRichEdit.Handle, EM_GETEVENTMASK, 0, 0);
   SendMessage(ChatRichEdit.Handle, EM_SETEVENTMASK, 0, mask or ENM_LINK);
@@ -3126,7 +3131,7 @@
       MainForm.TryToSendCommand('MYSTATUS', '0'); // let's tell the server we returned from the game
 
       CloseHandle(BattleState.Process.proc_info.hProcess);
-      UploadReplay;
+      UploadReplayAndLadderReport;
     end
   else
   begin
@@ -3136,11 +3141,11 @@
 
     TerminateProcess(BattleState.Process.proc_info.hProcess, 0);
     CloseHandle(BattleState.Process.proc_info.hProcess);
-    UploadReplay;
+    UploadReplayAndLadderReport;
   end;
 end;
 
-procedure TBattleForm.UploadReplay;
+procedure TBattleForm.UploadReplayAndLadderReport;
 var
   sr: TSearchRec;
   FileAttrs: Integer;
@@ -3148,7 +3153,6 @@
   s,su: string;
   FileName : string;
   i,j:integer;
-  teamCount : array[0..15] of integer;
   LadderUpThread : TUploadLadderDataThread;
 begin
   if (not Preferences.UploadReplay and ((BattleState.LadderIndex = -1) or (BattleState.Status = Joined))) or (BattleState.Battle.BattleType=1) then begin
@@ -3159,8 +3163,7 @@
     end;
     Exit;
   end;
-  {Replay upload disabled while the Replay site is down
-  
+
   FileAttrs := faAnyFile;
 
   if FindFirst(ExtractFilePath(Application.ExeName) + 'demos\*.sdf', FileAttrs, sr) = 0 then
@@ -3179,56 +3182,22 @@
     FindClose(sr);
   end;
 
-  ReplaysForm.ReadScriptFromDemo(FileName,s);
-  su := UpperCase(s);
-
   UploadReplayForm.FileName := FileName;
 
-  i := Pos('MAPNAME=', su);
-  i := i + 8;
-  j := PosEx(';', su, i);
-  if (i&lt;&gt;0) and (j&lt;&gt;0) then UploadReplayForm.MapName := Copy(s, i, j-i-4)
-  else Exit; // corrupt script file
-
-  i := Pos('GAMETYPE=', su);
-  i := i + 9;
-  j := PosEx(';', su, i);
-  if (i&lt;&gt;0) and (j&lt;&gt;0) then UploadReplayForm.ModName := Copy(s, i, j-i-4)
-  else Exit; // corrupt script file
-
-  for i:=0 to 15 do
-    teamCount[i] := 0;
-
-  i := Pos('AllyTeam=',s);
-  while i &gt; 0 do begin
-    i := i+9;
-    j := PosEx(';',s,i);
-    Inc(teamCount[StrToInt(Copy(s,i,j-i))]);
-    i := PosEx('AllyTeam=',s,i);
-  end;
-  UploadReplayForm.NbPlayers := '';
-  for i:= 0 to 15 do
-    if teamCount[i] &gt; 0 then
-      if UploadReplayForm.NbPlayers = '' then
-        UploadReplayForm.NbPlayers := IntToStr(teamCount[i])
-      else
-        UploadReplayForm.NbPlayers := UploadReplayForm.NbPlayers + 'v' + IntToStr(teamCount[i]);
-
-
   if BattleState.LadderIndex &gt;= 0 then
-    UploadReplayForm.Title := 'Ladder battle : ' + TLadder(LadderList[BattleState.LadderIndex]).Name;
-  }
+    UploadReplayForm.Description := 'Ladder battle : ' + TLadder(LadderList[BattleState.LadderIndex]).Name;
+
   UploadReplayForm.UploadedReplayId := '';
-  //UploadReplayForm.ShowModal;
+  UploadReplayForm.AutoUpload := True;
 
+  UploadReplayForm.ShowModal;
+
   if (BattleState.LadderIndex &gt;= 0) and (Status.Me.GetMode &lt;&gt; 0) then begin
     ProgressBarForm.Close;
     ProgressBarForm.TakeAction := 2;
     ProgressBarForm.ShowModal;
   end;
 
-  //MessageDlg(FileName,mtInformation,[mbOk],0);
-
 end;
 
 
@@ -5480,8 +5449,11 @@
 
   j:=0;
   for i:=0 to BattleState.Battle.Clients.Count -1 do
-    if TClient(BattleState.Battle.Clients[i]).GetMode &lt;&gt; 0 then begin
+    if TClient(BattleState.Battle.Clients[i]).GetMode &lt;&gt; 0 then
+    begin
       MainForm.TryToSendCommand('FORCETEAMNO', TClient(BattleState.Battle.Clients[i]).Name + ' ' + IntToStr(j));
+      if mnuBlockTeams.Checked then
+        TClient(BattleState.Battle.Clients[i]).SetTeamNo(j);
       j := j+1;
     end;
 end;
@@ -6705,43 +6677,8 @@
 end;
 
 procedure TBattleForm.ChatExRichEditDblClick(Sender: TObject);
-var
-   ci, //Character Index
-   lix, //Line Index
-   co, //Character Offset
-   k, j: Integer;
-   Pt: TPoint;
-   s: string;
-   SelectedNick: string;
-   SelectedClient: TClient;
 begin
-   with TExRichEdit(Sender) do
-   begin
-     GetCursorPos(pt);
-     pt := TExRichEdit(Sender).ScreenToClient(pt);
-     //Pt := Point(X, Y) ;
-     ci := Perform(Messages.EM_CHARFROMPOS, 0, Integer(@Pt)) ;
-     if ci &lt; 0 then Exit;
-     lix := Perform(EM_EXLINEFROMCHAR, 0, ci) ;
-     co := ci - Perform(EM_LINEINDEX, lix, 0) ;
-     if -1 + Lines.Count &lt; lix then Exit;
-     s := Lines[lix];
-     Inc(co) ;
-     k := co;
-     while (k &gt; 0) and (s[k] &lt;&gt; ' ') and (s[k] &lt;&gt; '&lt;') do k:=k-1;
-     Inc(k);
-     Inc(co) ;
-     j := co;
-     while (j &lt;= Length(s)) and (s[j] &lt;&gt; ' ') and (s[j] &lt;&gt; '&gt;') do Inc(j) ;
-     SelectedNick := Copy(s, k, j - k) ;
-
-     SelectedClient := MainForm.GetClient(SelectedNick);
-
-     if SelectedClient &lt;&gt; nil then
-     begin
-       MainForm.OpenPrivateChat(SelectedNick);
-     end;
-   end;
+   MainForm.RichEditDblClick(Sender);
 end;
 
 procedure TBattleForm.ChatRichEditMouseDown(Sender: TObject;

Modified: branches/0.77-branch/Lobby/TASClient/ColorsPreferenceUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/ColorsPreferenceUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/ColorsPreferenceUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,9 +1,9 @@
 object ColorsPreference: TColorsPreference
-  Left = 496
-  Top = 203
+  Left = 311
+  Top = 144
   BorderStyle = bsDialog
   Caption = 'Color Preferences'
-  ClientHeight = 462
+  ClientHeight = 480
   ClientWidth = 490
   Color = clBtnFace
   Constraints.MaxHeight = 1000
@@ -23,13 +23,13 @@
     Left = 0
     Top = 0
     Width = 490
-    Height = 462
+    Height = 480
     Caption = 'Colors and Font Preference'
     FixedSize = True
     Options.Maximize = False
     object btOk: TSpTBXButton
       Left = 311
-      Top = 424
+      Top = 440
       Width = 73
       Height = 25
       Caption = 'Ok'
@@ -43,7 +43,7 @@
     end
     object btRest: TSpTBXButton
       Left = 22
-      Top = 424
+      Top = 440
       Width = 88
       Height = 25
       Caption = 'Reset'
@@ -63,7 +63,7 @@
     end
     object btCancel: TSpTBXButton
       Left = 397
-      Top = 424
+      Top = 440
       Width = 70
       Height = 25
       Caption = 'Cancel'
@@ -79,7 +79,7 @@
       Left = 24
       Top = 40
       Width = 193
-      Height = 313
+      Height = 337
       Caption = 'Chat colors'
       Font.Charset = DEFAULT_CHARSET
       Font.Color = clWindowText
@@ -532,6 +532,43 @@
         LinkFont.Style = [fsUnderline]
         ThemeType = thtTBX
       end
+      object SpTBXLabel16: TSpTBXLabel
+        Left = 16
+        Top = 308
+        Width = 72
+        Height = 13
+        Caption = 'Old messages :'
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
+      object Panel15: TPanel
+        Left = 101
+        Top = 307
+        Width = 57
+        Height = 21
+        BevelOuter = bvNone
+        BorderStyle = bsSingle
+        Color = clBlack
+        TabOrder = 37
+      end
+      object SpTBXButton16: TSpTBXButton
+        Left = 160
+        Top = 307
+        Width = 25
+        Height = 20
+        Caption = '...'
+        TabOrder = 38
+        OnClick = SpTBXButton16Click
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+        ThemeType = thtTBX
+      end
     end
     object SpTBXGroupBox2: TSpTBXGroupBox
       Left = 224
@@ -654,7 +691,7 @@
     end
     object SpTBXGroupBox3: TSpTBXGroupBox
       Left = 24
-      Top = 360
+      Top = 384
       Width = 193
       Height = 49
       Caption = 'Chat font'
@@ -694,6 +731,6 @@
     Font.Name = 'MS Sans Serif'
     Font.Style = []
     Left = 136
-    Top = 376
+    Top = 400
   end
 end

Modified: branches/0.77-branch/Lobby/TASClient/ColorsPreferenceUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/ColorsPreferenceUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/ColorsPreferenceUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -5,7 +5,7 @@
 uses
   Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
   Dialogs, SpTBXItem, SpTBXControls, ExtCtrls, TBXDkPanels,Misc,MainUnit,
-  TntComCtrls,SpTBXEditors,RichEdit2, ExRichEdit;
+  TntComCtrls,SpTBXEditors,RichEdit2, ExRichEdit,TntStdCtrls;
 
 type
   TColorsPreference = class(TForm)
@@ -64,6 +64,9 @@
     lblFontName: TSpTBXLabel;
     SpTBXButton15: TSpTBXButton;
     FontDialog1: TFontDialog;
+    SpTBXLabel16: TSpTBXLabel;
+    Panel15: TPanel;
+    SpTBXButton16: TSpTBXButton;
     procedure FormCreate(Sender: TObject);
     procedure SpTBXButton0Click(Sender: TObject);
     procedure SpTBXButton1Click(Sender: TObject);
@@ -85,6 +88,7 @@
     procedure SpTBXButton15Click(Sender: TObject);
     procedure FormShow(Sender: TObject);
     procedure SpTBXButton14Click(Sender: TObject);
+    procedure SpTBXButton16Click(Sender: TObject);
   private
     { Private declarations }
   public
@@ -173,6 +177,7 @@
   Colors.BotText := Panel12.Color;
   Colors.MyText := Panel13.Color;
   Colors.AdminText := Panel14.Color;
+  Colors.OldMsgs := Panel15.Color;
   ApplyFont;
 
   ModalResult := mrOk;
@@ -200,6 +205,7 @@
   Panel12.Color := clGray;
   Panel13.Color := $0092726e;
   Panel14.Color := $000366A3;
+  Panel15.Color := $00c3c3c3;
 
   CommonFont.Name := 'Fixedsys';
   CommonFont.Size := 8;
@@ -241,11 +247,14 @@
   i : integer;
 begin
   BattleForm.ChatRichEdit.Font.Assign(CommonFont);
+  BattleForm.InputEdit.Font.Assign(CommonFont);
+  BattleForm.InputEdit.Height := CommonFont.Size*2+5;
 
   for i:=0 to MainForm.PageControl1.PageCount-1 do
   begin
     ((MainForm.PageControl1.Pages[i] as TMyTabSheet).Controls[1] as TExRichEdit).Font.Assign(CommonFont);
-    ((MainForm.PageControl1.Pages[i] as TMyTabSheet).Controls[0] as TSpTBXEdit).Font.Assign(CommonFont);
+    ((MainForm.PageControl1.Pages[i] as TMyTabSheet).Controls[0] as TTntMemo).Font.Assign(CommonFont);
+    ((MainForm.PageControl1.Pages[i] as TMyTabSheet).Controls[0] as TTntMemo).Height := CommonFont.Size*2+5;
   end;
 
   MainForm.ClientsListBox.Font.Assign(CommonFont);
@@ -269,6 +278,7 @@
   Panel12.Color := Colors.BotText;
   Panel13.Color := Colors.MyText;
   Panel14.Color := Colors.AdminText;
+  Panel15.Color := Colors.OldMsgs;
   lblFontName.Caption := CommonFont.Name+'@'+IntToStr(CommonFont.Size);
 end;
 
@@ -277,4 +287,9 @@
   Panel14.Color := InputColor('Choose a color ...',Panel14.Color);
 end;
 
+procedure TColorsPreference.SpTBXButton16Click(Sender: TObject);
+begin
+  Panel15.Color := InputColor('Choose a color ...',Panel15.Color);
+end;
+
 end.

Modified: branches/0.77-branch/Lobby/TASClient/ExceptionUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/ExceptionUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/ExceptionUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,4 +1,5 @@
 object ExceptionDialog: TExceptionDialog
+  Tag = 1
   Left = 951
   Top = 289
   ActiveControl = OkBtn

Modified: branches/0.77-branch/Lobby/TASClient/Graphics/connect1.bmp
===================================================================
(Binary files differ)

Modified: branches/0.77-branch/Lobby/TASClient/Graphics/connect2.bmp
===================================================================
(Binary files differ)

Modified: branches/0.77-branch/Lobby/TASClient/Graphics/connect3.bmp
===================================================================
(Binary files differ)

Modified: branches/0.77-branch/Lobby/TASClient/HelpUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/HelpUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/HelpUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,6 +1,6 @@
 object HelpForm: THelpForm
-  Left = 384
-  Top = 403
+  Left = 902
+  Top = 193
   BorderStyle = bsDialog
   Caption = 'Help'
   ClientHeight = 474
@@ -58,252 +58,537 @@
         Caption = 'Page 3'
         ImageIndex = -1
         TabItem = 'SpTBXTabItem1'
-        object Label18: TSpTBXLabel
-          Left = 32
-          Top = 24
-          Width = 52
-          Height = 13
-          Caption = 'Useful tips:'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
+        object ScrollBox1: TScrollBox
+          Left = 8
+          Top = 4
+          Width = 585
+          Height = 365
+          BorderStyle = bsNone
+          TabOrder = 0
+          object Label52: TLabel
+            Left = 0
+            Top = 341
+            Width = 408
+            Height = 13
+            Caption = 
+              '* /forceupdate /forcebetaupdate will force the lobby update even' +
+              ' if it seems up to date'
+          end
+          object Label53: TLabel
+            Left = 0
+            Top = 357
+            Width = 122
+            Height = 13
+            Caption = '* /help  will show this help'
+          end
+          object Label54: TLabel
+            Left = 0
+            Top = 373
+            Width = 180
+            Height = 13
+            Caption = '* /uptime will tell you the server uptime'
+          end
+          object Label55: TLabel
+            Left = 0
+            Top = 387
+            Width = 292
+            Height = 13
+            Caption = 
+              '* /version will tell you the TASClient lobby version and revisio' +
+              'n'
+          end
+          object Label18: TSpTBXLabel
+            Left = 0
+            Top = 0
+            Width = 52
+            Height = 13
+            Caption = 'Useful tips:'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label19: TSpTBXLabel
+            Left = 0
+            Top = 16
+            Width = 259
+            Height = 13
+            Caption = '* Right-click on a channel or private chat tab to close it'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label20: TSpTBXLabel
+            Left = 0
+            Top = 32
+            Width = 318
+            Height = 13
+            Caption = 
+              '* Double on the player to open private chat (in the list or in t' +
+              'he chat)'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label21: TSpTBXLabel
+            Left = 0
+            Top = 48
+            Width = 233
+            Height = 13
+            Caption = '* Double-click or click on Join button to join battle'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label34: TSpTBXLabel
+            Left = 0
+            Top = 64
+            Width = 203
+            Height = 13
+            Caption = '* Double-click on bot to change his options'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label22: TSpTBXLabel
+            Left = 0
+            Top = 80
+            Width = 215
+            Height = 13
+            Caption = '* Click on minimap to view fixed start positions'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label23: TSpTBXLabel
+            Left = 0
+            Top = 96
+            Width = 334
+            Height = 13
+            Caption = 
+              '* Right click on the minimap to get options like auto boxes or k' +
+              'eep ratio'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label24: TSpTBXLabel
+            Left = 0
+            Top = 128
+            Width = 87
+            Height = 13
+            Caption = 'Useful commands:'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label25: TSpTBXLabel
+            Left = 0
+            Top = 152
+            Width = 154
+            Height = 13
+            Caption = '* /me to talk in &quot;/me&quot; mIRC style'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label26: TSpTBXLabel
+            Left = 0
+            Top = 168
+            Width = 211
+            Height = 13
+            Caption = '* /join or /j (+channel'#39's name) to join channel'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label27: TSpTBXLabel
+            Left = 0
+            Top = 184
+            Width = 283
+            Height = 13
+            Caption = '* /part or /p to close current channel or private chat window'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label28: TSpTBXLabel
+            Left = 0
+            Top = 200
+            Width = 246
+            Height = 13
+            Caption = '* /channels or /list to receive a list of open channels'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label67: TSpTBXLabel
+            Left = 0
+            Top = 216
+            Width = 283
+            Height = 13
+            Caption = '* /rename &lt;new name&gt; to change your account'#39's username'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object SpTBXLabel1: TSpTBXLabel
+            Left = 0
+            Top = 232
+            Width = 334
+            Height = 13
+            Caption = 
+              '* /password &lt;oldpass&gt; &lt;newpass&gt; will change your account passwor' +
+              'd'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label68: TSpTBXLabel
+            Left = 0
+            Top = 248
+            Width = 202
+            Height = 13
+            Caption = '* /ring while hosting a battle to call a player'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label44: TSpTBXLabel
+            Left = 0
+            Top = 264
+            Width = 283
+            Height = 13
+            Caption = '* /ping will tell you the lag between you and the lobby server'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label69: TSpTBXLabel
+            Left = 0
+            Top = 280
+            Width = 242
+            Height = 13
+            Caption = '* /msg &lt;user&gt; {message} will send message to user'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label70: TSpTBXLabel
+            Left = 0
+            Top = 296
+            Width = 295
+            Height = 13
+            Caption = 
+              '* /ignore [&lt;user&gt;] will add &lt;user&gt; to ignore list and open the l' +
+              'ist'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label72: TSpTBXLabel
+            Left = 0
+            Top = 312
+            Width = 236
+            Height = 13
+            Caption = '* /mutelist &lt;channel&gt; will return channel'#39's mute list'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object SpTBXLabel4: TSpTBXLabel
+            Left = 0
+            Top = 325
+            Width = 265
+            Height = 13
+            Caption = '* /ingame will return your total amount of ingame minutes'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
         end
-        object Label19: TSpTBXLabel
-          Left = 32
-          Top = 40
-          Width = 183
-          Height = 13
-          Caption = '* Right-click on chat window to close it'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object Label20: TSpTBXLabel
-          Left = 32
+      end
+      object SpTBXTabSheet4: TSpTBXTabSheet
+        Left = 0
+        Top = 23
+        Width = 601
+        Height = 378
+        Caption = 'Page 4'
+        ImageIndex = -1
+        TabItem = 'SpTBXTabItem4'
+        object Image12: TImage
+          Left = 56
           Top = 56
-          Width = 203
-          Height = 13
-          Caption = '* Double on the player to open private chat'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
+          Width = 17
+          Height = 17
+          Picture.Data = {
+            07544269746D617036050000424D360500000000000036040000280000001000
+            000010000000010008000000000000010000130B0000130B0000000100000001
+            00000793AC0000D2FE0000E0FE008EFEFE0000E1FE000098A70000F3FE0000E9
+            DC000490CA0000D7FE00E1FCEC0000C5FB0000A0A6000492AB0076EBDA000091
+            CC00029EE900009CD200A0E9F100D1ECFE00DDFEE10000ECFE009EFEFE0000CE
+            FE0001F3FE0000ACA80001DEF00047E6F30001ECE00000E2F00090FBFE000084
+            CA0000E7FE0000B1A4000AE1FE0000A9AA0001DEE80000DEF60000D0CE00B2FE
+            F5000085BE0000CFFE0085EDFE0000E3DE00FFFFFF0000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            00002C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C0000000000002C2C2C
+            2C2C2C2C2C2C2C001C032421002C2C2C2C2C2C2C2C2C2C2C000000002C2C2C2C
+            2C2C2C2C2C2C2C2C2C00002C2C2C2C2C2C2C2C2C2C2C2C2C2C00002C2C2C2C2C
+            2C2C2C2C2C2C2C2C00190D002C2C2C2C2C2C2C2C2C2C2C0002010F05002C2C2C
+            2C2C2C2C2C2C00042B1626101F002C2C2C2C2C2C2C0000201E0E18010800002C
+            2C2C2C2C002C00221B271D250C002C002C2C2C002C2C000B03141A0911002C2C
+            002C2C002C2C00062A0A172928002C2C002C2C2C000000071312150223000000
+            2C2C2C2C2C2C00000000000000002C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C
+            2C2C}
+          Transparent = True
         end
-        object Label21: TSpTBXLabel
-          Left = 32
-          Top = 72
-          Width = 233
-          Height = 13
-          Caption = '* Double-click or click on Join button to join battle'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
+        object Image13: TImage
+          Left = 56
+          Top = 80
+          Width = 17
+          Height = 17
+          Picture.Data = {
+            07544269746D617036050000424D360500000000000036040000280000001000
+            000010000000010008000000000000010000130B0000130B0000000100000001
+            0000FFFFFF00898A8A007070710097979800A2A2A30071727200B0B1B1007778
+            78008B8B8C009E9F9F009F9FA000A5A5A600959696007C7C7D00676767009A9A
+            9A0060606000F2F3F40062626300909091008B8C8C0084858500A8A9AA00696A
+            6A00AEAEAF007B7B7C0092929300ADAEAE008989890068686900A0A1A1008383
+            84006F7070008B8B8B009B9C9C009C9D9D00A9A9AA00C9C9CA00888888006A6A
+            6B00747575007A7B7B009C9C9D00ADADAE008A8A8B0074747500A2A2A2007D7D
+            7D00949495007576760087888800ACADAE00AAABAB0065656500838383007373
+            730080808000A6A7A700C5C5C6009FA0A0009A9B9B0070707000818182006969
+            6A00767676007D7E7E007B7C7C00787979007A7A7B006A6B6B00EEEFEF007D7D
+            7E0078787900525252008E8F8F006B6C6C00FFFFFF0000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            00004C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4527171D0E354C4C4C
+            4C4C4C4C4C4C4C02072531493F4C4C4C4C4C4C4C4C4C4C4C2D3705204C4C4C4C
+            4C4C4C4C4C4C4C4C4C07404C4C4C4C4C4C4C4C4C4C4C4C4C4C0D444C4C4C4C4C
+            4C4C4C4C4C4C4C4C3610430D4C4C4C4C4C4C4C4C4C4C4C0101323D4B474C4C4C
+            4C4C4C4C4C4C130F1C00283005414C4C4C4C4C4C4C030C0C00112E2C083E2F4C
+            4C4C4C4C094C3C3A4600210812154C194C4C4C394C4C3B090000042242264C4C
+            484C4C334C4C0B1B0000242338144C4C294C4C4C0618340A00000A04024A011F
+            4C4C4C4C4C4C062B160B1E2A031A4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C
+            4C4C}
+          Transparent = True
         end
-        object Label34: TSpTBXLabel
-          Left = 32
-          Top = 88
-          Width = 203
-          Height = 13
-          Caption = '* Double-click on bot to change his options'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object Label22: TSpTBXLabel
-          Left = 32
+        object Image14: TImage
+          Left = 56
           Top = 104
-          Width = 225
-          Height = 13
-          Caption = '* Click on minimap to view default start positions'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
+          Width = 17
+          Height = 17
+          Picture.Data = {
+            07544269746D617036050000424D360500000000000036040000280000001000
+            000010000000010008000000000000010000130B0000130B0000000100000001
+            00000159A8000095DE0063C3DE0000B7DE0000A3DE0000ADC80000AFCB0000AF
+            DE000075A2007CC3D800004CB4000070A40000A2D50000A4DE005DB1DE0099C3
+            CB0092AFDE0053AEC7000061C2009CC0D200009ADE00006DA6000056BC0002A4
+            DE0064BFDE000091DE0000ABDE000092DE000058A7000088DC0000A2D0006FC3
+            DE00005DA30000A5D5000057BE000093BF000064A30000A2D90000A7CA0030A9
+            D7000062D100004BBC0070ADD600FFFFFF000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            0000000000000000000000000000000000000000000000000000000000000000
+            00002B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B0000000000002B2B2B
+            2B2B2B2B2B2B2B0006021E08002B2B2B2B2B2B2B2B2B2B2B000000002B2B2B2B
+            2B2B2B2B2B2B2B2B2B00002B2B2B2B2B2B2B2B2B2B2B2B2B2B00002B2B2B2B2B
+            2B2B2B2B2B2B2B2B000B1C002B2B2B2B2B2B2B2B2B2B2B0004012220002B2B2B
+            2B2B2B2B2B2B000D261F232829002B2B2B2B2B2B2B00001A181103011600002B
+            2B2B2B2B002B00172709212524002B002B2B2B002B2B001D020F0C1412002B2B
+            002B2B002B2B00030E13191B0A002B2B002B2B2B00000005102A070415000000
+            2B2B2B2B2B2B00000000000000002B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B
+            2B2B}
+          Transparent = True
         end
-        object Label23: TSpTBXLabel
-          Left = 32
-          Top = 120
-          Width = 279
-          Height = 13
+        object Label51: TLabel
+          Left = 24
+          Top = 224
+          Width = 521
+          Height = 52
           Caption = 
-            '* Right click on map list to reload it (no need to rejoin battle' +
-            ')'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
+            'You can only play ladder battles if you have an account. To make' +
+            ' an account go to the Options -&gt; Account. If  you have been forc' +
+            'ed to spectator mode because you didn'#39't have an account, ask the' +
+            ' hoster to refresh the ranks using the &quot;Ladder -&gt; Refresh ranks ' +
+            'and cups&quot; button (bottom right of the battle window) and then un' +
+            'spec. You can also refresh ranks after a ladder battle end to se' +
+            'e the rating and ranks changes.'
+          Transparent = True
+          WordWrap = True
         end
-        object Label24: TSpTBXLabel
+        object SpTBXLabel10: TSpTBXLabel
           Left = 32
-          Top = 152
-          Width = 87
+          Top = 32
+          Width = 79
           Height = 13
-          Caption = 'Useful commands:'
+          Caption = 'Ladder rewards :'
           LinkFont.Charset = DEFAULT_CHARSET
           LinkFont.Color = clBlue
           LinkFont.Height = -11
           LinkFont.Name = 'MS Sans Serif'
           LinkFont.Style = [fsUnderline]
         end
-        object Label25: TSpTBXLabel
-          Left = 32
-          Top = 176
-          Width = 154
+        object SpTBXLabel11: TSpTBXLabel
+          Left = 88
+          Top = 56
+          Width = 165
           Height = 13
-          Caption = '* /me to talk in &quot;/me&quot; mIRC style'
+          Caption = 'Gold cup for the best ladder player.'
           LinkFont.Charset = DEFAULT_CHARSET
           LinkFont.Color = clBlue
           LinkFont.Height = -11
           LinkFont.Name = 'MS Sans Serif'
           LinkFont.Style = [fsUnderline]
         end
-        object Label26: TSpTBXLabel
-          Left = 32
-          Top = 192
-          Width = 211
+        object SpTBXLabel12: TSpTBXLabel
+          Left = 88
+          Top = 80
+          Width = 104
           Height = 13
-          Caption = '* /join or /j (+channel'#39's name) to join channel'
+          Caption = 'Silver cup for the 2nd.'
           LinkFont.Charset = DEFAULT_CHARSET
           LinkFont.Color = clBlue
           LinkFont.Height = -11
           LinkFont.Name = 'MS Sans Serif'
           LinkFont.Style = [fsUnderline]
         end
-        object Label27: TSpTBXLabel
-          Left = 32
-          Top = 208
-          Width = 283
+        object SpTBXLabel13: TSpTBXLabel
+          Left = 88
+          Top = 104
+          Width = 108
           Height = 13
-          Caption = '* /part or /p to close current channel or private chat window'
+          Caption = 'Bronze cup for the 3rd.'
           LinkFont.Charset = DEFAULT_CHARSET
           LinkFont.Color = clBlue
           LinkFont.Height = -11
           LinkFont.Name = 'MS Sans Serif'
           LinkFont.Style = [fsUnderline]
         end
-        object Label28: TSpTBXLabel
+        object SpTBXLabel14: TSpTBXLabel
           Left = 32
-          Top = 224
-          Width = 246
-          Height = 13
-          Caption = '* /channels or /list to receive a list of open channels'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object Label67: TSpTBXLabel
-          Left = 32
-          Top = 240
-          Width = 283
-          Height = 13
-          Caption = '* /rename &lt;new name&gt; to change your account'#39's username'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object Label68: TSpTBXLabel
-          Left = 32
-          Top = 272
-          Width = 202
-          Height = 13
-          Caption = '* /ring while hosting a battle to call a player'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object Label44: TSpTBXLabel
-          Left = 32
-          Top = 288
-          Width = 283
-          Height = 13
-          Caption = '* /ping will tell you the lag between you and the lobby server'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object Label69: TSpTBXLabel
-          Left = 32
-          Top = 304
-          Width = 242
-          Height = 13
-          Caption = '* /msg &lt;user&gt; {message} will send message to user'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object Label70: TSpTBXLabel
-          Left = 32
-          Top = 320
-          Width = 295
-          Height = 13
+          Top = 136
+          Width = 233
+          Height = 49
           Caption = 
-            '* /ignore [&lt;user&gt;] will add &lt;user&gt; to ignore list and open the l' +
-            'ist'
+            'Players can have 1 cup per active ladder. To see  the rules, the' +
+            ' maps and the ranking page of each ladder, visit the ladder web ' +
+            'site.'
+          AutoSize = False
+          Wrapping = twWrap
           LinkFont.Charset = DEFAULT_CHARSET
           LinkFont.Color = clBlue
           LinkFont.Height = -11
           LinkFont.Name = 'MS Sans Serif'
           LinkFont.Style = [fsUnderline]
         end
-        object SpTBXLabel1: TSpTBXLabel
-          Left = 32
-          Top = 256
-          Width = 334
-          Height = 13
-          Caption = 
-            '* /password &lt;oldpass&gt; &lt;newpass&gt; will change your account passwor' +
-            'd'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object Label72: TSpTBXLabel
-          Left = 32
-          Top = 336
-          Width = 236
-          Height = 13
-          Caption = '* /mutelist &lt;channel&gt; will return channel'#39's mute list'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object SpTBXLabel4: TSpTBXLabel
-          Left = 32
-          Top = 352
-          Width = 265
-          Height = 13
-          Caption = '* /ingame will return your total amount of ingame minutes'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
       end
       object SpTBXTabSheet2: TSpTBXTabSheet
         Left = 0
@@ -873,249 +1158,6 @@
           LinkFont.Style = [fsUnderline]
         end
       end
-      object SpTBXTabSheet4: TSpTBXTabSheet
-        Left = 0
-        Top = 23
-        Width = 601
-        Height = 378
-        Caption = 'Page 4'
-        ImageIndex = -1
-        TabItem = 'SpTBXTabItem4'
-        object Image12: TImage
-          Left = 56
-          Top = 56
-          Width = 17
-          Height = 17
-          Picture.Data = {
-            07544269746D617036050000424D360500000000000036040000280000001000
-            000010000000010008000000000000010000130B0000130B0000000100000001
-            00000793AC0000D2FE0000E0FE008EFEFE0000E1FE000098A70000F3FE0000E9
-            DC000490CA0000D7FE00E1FCEC0000C5FB0000A0A6000492AB0076EBDA000091
-            CC00029EE900009CD200A0E9F100D1ECFE00DDFEE10000ECFE009EFEFE0000CE
-            FE0001F3FE0000ACA80001DEF00047E6F30001ECE00000E2F00090FBFE000084
-            CA0000E7FE0000B1A4000AE1FE0000A9AA0001DEE80000DEF60000D0CE00B2FE
-            F5000085BE0000CFFE0085EDFE0000E3DE00FFFFFF0000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            00002C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C0000000000002C2C2C
-            2C2C2C2C2C2C2C001C032421002C2C2C2C2C2C2C2C2C2C2C000000002C2C2C2C
-            2C2C2C2C2C2C2C2C2C00002C2C2C2C2C2C2C2C2C2C2C2C2C2C00002C2C2C2C2C
-            2C2C2C2C2C2C2C2C00190D002C2C2C2C2C2C2C2C2C2C2C0002010F05002C2C2C
-            2C2C2C2C2C2C00042B1626101F002C2C2C2C2C2C2C0000201E0E18010800002C
-            2C2C2C2C002C00221B271D250C002C002C2C2C002C2C000B03141A0911002C2C
-            002C2C002C2C00062A0A172928002C2C002C2C2C000000071312150223000000
-            2C2C2C2C2C2C00000000000000002C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C
-            2C2C}
-          Transparent = True
-        end
-        object Image13: TImage
-          Left = 56
-          Top = 80
-          Width = 17
-          Height = 17
-          Picture.Data = {
-            07544269746D617036050000424D360500000000000036040000280000001000
-            000010000000010008000000000000010000130B0000130B0000000100000001
-            0000FFFFFF00898A8A007070710097979800A2A2A30071727200B0B1B1007778
-            78008B8B8C009E9F9F009F9FA000A5A5A600959696007C7C7D00676767009A9A
-            9A0060606000F2F3F40062626300909091008B8C8C0084858500A8A9AA00696A
-            6A00AEAEAF007B7B7C0092929300ADAEAE008989890068686900A0A1A1008383
-            84006F7070008B8B8B009B9C9C009C9D9D00A9A9AA00C9C9CA00888888006A6A
-            6B00747575007A7B7B009C9C9D00ADADAE008A8A8B0074747500A2A2A2007D7D
-            7D00949495007576760087888800ACADAE00AAABAB0065656500838383007373
-            730080808000A6A7A700C5C5C6009FA0A0009A9B9B0070707000818182006969
-            6A00767676007D7E7E007B7C7C00787979007A7A7B006A6B6B00EEEFEF007D7D
-            7E0078787900525252008E8F8F006B6C6C00FFFFFF0000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            00004C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4527171D0E354C4C4C
-            4C4C4C4C4C4C4C02072531493F4C4C4C4C4C4C4C4C4C4C4C2D3705204C4C4C4C
-            4C4C4C4C4C4C4C4C4C07404C4C4C4C4C4C4C4C4C4C4C4C4C4C0D444C4C4C4C4C
-            4C4C4C4C4C4C4C4C3610430D4C4C4C4C4C4C4C4C4C4C4C0101323D4B474C4C4C
-            4C4C4C4C4C4C130F1C00283005414C4C4C4C4C4C4C030C0C00112E2C083E2F4C
-            4C4C4C4C094C3C3A4600210812154C194C4C4C394C4C3B090000042242264C4C
-            484C4C334C4C0B1B0000242338144C4C294C4C4C0618340A00000A04024A011F
-            4C4C4C4C4C4C062B160B1E2A031A4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C
-            4C4C}
-          Transparent = True
-        end
-        object Image14: TImage
-          Left = 56
-          Top = 104
-          Width = 17
-          Height = 17
-          Picture.Data = {
-            07544269746D617036050000424D360500000000000036040000280000001000
-            000010000000010008000000000000010000130B0000130B0000000100000001
-            00000159A8000095DE0063C3DE0000B7DE0000A3DE0000ADC80000AFCB0000AF
-            DE000075A2007CC3D800004CB4000070A40000A2D50000A4DE005DB1DE0099C3
-            CB0092AFDE0053AEC7000061C2009CC0D200009ADE00006DA6000056BC0002A4
-            DE0064BFDE000091DE0000ABDE000092DE000058A7000088DC0000A2D0006FC3
-            DE00005DA30000A5D5000057BE000093BF000064A30000A2D90000A7CA0030A9
-            D7000062D100004BBC0070ADD600FFFFFF000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            0000000000000000000000000000000000000000000000000000000000000000
-            00002B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B0000000000002B2B2B
-            2B2B2B2B2B2B2B0006021E08002B2B2B2B2B2B2B2B2B2B2B000000002B2B2B2B
-            2B2B2B2B2B2B2B2B2B00002B2B2B2B2B2B2B2B2B2B2B2B2B2B00002B2B2B2B2B
-            2B2B2B2B2B2B2B2B000B1C002B2B2B2B2B2B2B2B2B2B2B0004012220002B2B2B
-            2B2B2B2B2B2B000D261F232829002B2B2B2B2B2B2B00001A181103011600002B
-            2B2B2B2B002B00172709212524002B002B2B2B002B2B001D020F0C1412002B2B
-            002B2B002B2B00030E13191B0A002B2B002B2B2B00000005102A070415000000
-            2B2B2B2B2B2B00000000000000002B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B2B
-            2B2B}
-          Transparent = True
-        end
-        object Label51: TLabel
-          Left = 24
-          Top = 224
-          Width = 521
-          Height = 52
-          Caption = 
-            'You can only play ladder battles if you have an account. To make' +
-            ' an account go to the Options -&gt; Account. If  you have been forc' +
-            'ed to spectator mode because you didn'#39't have an account, ask the' +
-            ' hoster to refresh the ranks using the &quot;Ladder -&gt; Refresh ranks ' +
-            'and cups&quot; button (bottom right of the battle window) and then un' +
-            'spec. You can also refresh ranks after a ladder battle end to se' +
-            'e the rating and ranks changes.'
-          Transparent = True
-          WordWrap = True
-        end
-        object SpTBXLabel10: TSpTBXLabel
-          Left = 32
-          Top = 32
-          Width = 79
-          Height = 13
-          Caption = 'Ladder rewards :'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object SpTBXLabel11: TSpTBXLabel
-          Left = 88
-          Top = 56
-          Width = 165
-          Height = 13
-          Caption = 'Gold cup for the best ladder player.'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object SpTBXLabel12: TSpTBXLabel
-          Left = 88
-          Top = 80
-          Width = 104
-          Height = 13
-          Caption = 'Silver cup for the 2nd.'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object SpTBXLabel13: TSpTBXLabel
-          Left = 88
-          Top = 104
-          Width = 108
-          Height = 13
-          Caption = 'Bronze cup for the 3rd.'
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object SpTBXLabel14: TSpTBXLabel
-          Left = 32
-          Top = 136
-          Width = 233
-          Height = 49
-          Caption = 
-            'Players can have 1 cup per active ladder. To see  the rules, the' +
-            ' maps and the ranking page of each ladder, visit the ladder web ' +
-            'site.'
-          AutoSize = False
-          Wrapping = twWrap
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-      end
       object SpTBXTabSheet3: TSpTBXTabSheet
         Left = 0
         Top = 23

Modified: branches/0.77-branch/Lobby/TASClient/HelpUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/HelpUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/HelpUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -54,23 +54,6 @@
     Label57: TSpTBXLabel;
     Label17: TSpTBXLabel;
     SpTBXTabSheet1: TSpTBXTabSheet;
-    Label18: TSpTBXLabel;
-    Label19: TSpTBXLabel;
-    Label20: TSpTBXLabel;
-    Label21: TSpTBXLabel;
-    Label34: TSpTBXLabel;
-    Label22: TSpTBXLabel;
-    Label23: TSpTBXLabel;
-    Label24: TSpTBXLabel;
-    Label25: TSpTBXLabel;
-    Label26: TSpTBXLabel;
-    Label27: TSpTBXLabel;
-    Label28: TSpTBXLabel;
-    Label67: TSpTBXLabel;
-    Label68: TSpTBXLabel;
-    Label44: TSpTBXLabel;
-    Label69: TSpTBXLabel;
-    Label70: TSpTBXLabel;
     SpTBXTabSheet2: TSpTBXTabSheet;
     Image5: TImage;
     Label30: TSpTBXLabel;
@@ -95,14 +78,11 @@
     Button3: TSpTBXButton;
     Button1: TSpTBXButton;
     Button2: TSpTBXButton;
-    SpTBXLabel1: TSpTBXLabel;
-    Label72: TSpTBXLabel;
     Image10: TImage;
     Label43: TSpTBXLabel;
     SpTBXLabel2: TSpTBXLabel;
     Image11: TImage;
     SpTBXLabel3: TSpTBXLabel;
-    SpTBXLabel4: TSpTBXLabel;
     SpTBXLabel5: TSpTBXLabel;
     SpTBXLabel6: TSpTBXLabel;
     SpTBXLabel7: TSpTBXLabel;
@@ -121,6 +101,31 @@
     Label51: TLabel;
     Image15: TImage;
     Image16: TImage;
+    ScrollBox1: TScrollBox;
+    Label18: TSpTBXLabel;
+    Label19: TSpTBXLabel;
+    Label20: TSpTBXLabel;
+    Label21: TSpTBXLabel;
+    Label34: TSpTBXLabel;
+    Label22: TSpTBXLabel;
+    Label23: TSpTBXLabel;
+    Label24: TSpTBXLabel;
+    Label25: TSpTBXLabel;
+    Label26: TSpTBXLabel;
+    Label27: TSpTBXLabel;
+    Label28: TSpTBXLabel;
+    Label67: TSpTBXLabel;
+    SpTBXLabel1: TSpTBXLabel;
+    Label68: TSpTBXLabel;
+    Label44: TSpTBXLabel;
+    Label69: TSpTBXLabel;
+    Label70: TSpTBXLabel;
+    Label72: TSpTBXLabel;
+    SpTBXLabel4: TSpTBXLabel;
+    Label52: TLabel;
+    Label53: TLabel;
+    Label54: TLabel;
+    Label55: TLabel;
     procedure Button1Click(Sender: TObject);
     procedure FormCreate(Sender: TObject);
     procedure Button3Click(Sender: TObject);

Modified: branches/0.77-branch/Lobby/TASClient/HighlightingUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/HighlightingUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/HighlightingUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -231,7 +231,7 @@
 
     for i := 0 to High(Highlights) do
     begin
-      RichEdit.SelStart := Length(RichEdit.Text) - (Length(sn) - Highlights[i].X) - 1;
+      RichEdit.SelStart := Length(RichEdit.Text) - (Length(sn) - Highlights[i].X) - 2;
       RichEdit.SelLength := Highlights[i].Y - Highlights[i].X;
       RichEdit.SelAttributes.Color := HighlightingForm.JvColorComboBox1.Colors[Max(0, Misc.MapColorNameToIndex(Preferences.HighlightColor, HighlightingForm.JvColorComboBox1))];
       RichEdit.SelAttributes.Style := [fsUnderLine];

Modified: branches/0.77-branch/Lobby/TASClient/HttpGetUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/HttpGetUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/HttpGetUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -176,6 +176,10 @@
         DeleteFile(DownloadFile.FileName);
         if e=0 then
         begin
+          // delete tasclient.exe.old
+          if FileExists(Application.ExeName+'.old') then
+            DeleteFile(Application.ExeName+'.old');
+
           // renames tasclient.exe
           if not RenameFile(Application.ExeName,Application.ExeName+'.old') then
           begin

Modified: branches/0.77-branch/Lobby/TASClient/LobbyScriptUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/LobbyScriptUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/LobbyScriptUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -149,6 +149,7 @@
       function GetColors: Variant;
       function GetServers: Variant;
       procedure SetServers(sV : Variant);
+      function ChangeMap(mapName: string): Boolean;
 
       constructor Create;
       destructor Destroy;
@@ -198,7 +199,9 @@
   procedure PyDict_SetItemIncRef(dp: PPyObject; Key: PPyObject; o : PPyObject);
   procedure SafeDecRef(o : PPyObject);
   procedure PostMsgs;
+  procedure HostBattle;
   procedure JoinBattle;
+  procedure ChangeMap;
   function GetComponentFromString(component: string): TComponent;
   function GetStringFromComponent(component : TComponent): string;
 
@@ -218,6 +221,7 @@
   JoinBattlePassword: string;
   NotificationTempList: TList;
   ScriptsInitialized: Boolean = False;
+  ChangeMapIndex: integer;
 
 implementation
 
@@ -528,6 +532,7 @@
 var
   i: integer;
   pyO: PPyObject;
+
 begin
   LockCallback;
   with GetPythonEngine do
@@ -557,6 +562,18 @@
     PyDict_SetItemString(pyCurrentBattle,'DisabledUnits',pyO);
     Py_XDECREF(pyO);
 
+    pyO := PyDict_New();
+    for i:=0 to BattleForm.ModOptionsList.Count-1 do
+      PyDict_SetItemStringDecRef(pyO,PChar(TLuaOption(BattleForm.ModOptionsList[i]).Key),TLuaOption(BattleForm.ModOptionsList[i]).toString);
+    PyDict_SetItemString(pyCurrentBattle,'ModOptions',pyO);
+    Py_XDECREF(pyO);
+
+    pyO := PyDict_New();
+    for i:=0 to BattleForm.MapOptionsList.Count-1 do
+      PyDict_SetItemStringDecRef(pyO,PChar(TLuaOption(BattleForm.MapOptionsList[i]).Key),TLuaOption(BattleForm.MapOptionsList[i]).toString);
+    PyDict_SetItemString(pyCurrentBattle,'MapOptions',pyO);
+    Py_XDECREF(pyO);
+
     Result := PyObjectAsVariant(pyCurrentBattle);
   end;
   UnlockCallback;
@@ -1037,6 +1054,21 @@
   ScriptJoining := False;
 end;
 
+procedure HostBattle;
+begin
+  HostBattleForm.HostButtonClick(HostBattleForm.HostButton);
+  BattleForm.Show;
+  ScriptHostingRunning := False;
+  ScriptHostingReplayRunning := False;
+end;
+
+procedure ChangeMap;
+begin
+  BattleForm.ChangeMap(ChangeMapIndex);
+  if BattleState.Status = Hosting then
+    BattleForm.SendBattleInfoToServer;
+end;
+
 function TCallback.JoinBattle(battleId: integer; Password: String) : Boolean;
 var
   b : TBattle;
@@ -1058,7 +1090,7 @@
   begin
     JoinBattleId := battleId;
     JoinBattlePassword := Password;
-    PostMessage(MainForm.Handle,WM_SCRIPT,2,0);
+    SendMessage(MainForm.Handle,WM_SCRIPT,2,0);
     Result := True;
   end
   else
@@ -1104,13 +1136,8 @@
       PortEdit.Text := IntToStr(UDPHostPort);
       NATRadioGroup.ItemIndex := NatTraversal;
 
-      HostButtonClick(HostButton);
-
-      BattleForm.Show;
-
-      Result := BattleState.Status = Hosting;
-      ScriptHostingRunning := False;
-      ScriptHostingReplayRunning := False;
+      Result := True;
+      SendMessage(MainForm.Handle,WM_SCRIPT,4,0);
     except
       Result := false;
     end;
@@ -1144,12 +1171,8 @@
       PortEdit.Text := IntToStr(UDPHostPort);
       NATRadioGroup.ItemIndex := NatTraversal;
 
-      HostButtonClick(HostButton);
-
-      BattleForm.Show;
-
-      Result := BattleState.Status = Hosting;
-      ScriptHostingRunning := False;
+      Result := True;
+      SendMessage(MainForm.Handle,WM_SCRIPT,4,0);
     except
       Result := false;
     end;
@@ -1164,6 +1187,21 @@
     PostMessage(MainForm.Handle,WM_SCRIPT,1,0);
   end;
 end;
+
+function TCallback.ChangeMap(mapName: string): Boolean;
+begin
+  if BattleState.Status &lt;&gt; Joined then
+  begin
+    ChangeMapIndex := MapList.IndexOf(mapName);
+    Result := ChangeMapIndex &gt; -1;
+    if Result then
+      SendMessage(MainForm.Handle,WM_SCRIPT,3,0);
+  end
+  else
+    Result := False;
+end;
+
+
 function TCallback.StartBattle: Boolean;
 begin
   Result := False;

Modified: branches/0.77-branch/Lobby/TASClient/LogonFormUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/LogonFormUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/LogonFormUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -114,6 +114,7 @@
 
 procedure TLogonForm.beLadderPasswordSubEditButton0Click(Sender: TObject);
 begin
+  PreferencesForm.UsernameEdit.Text := txtLogin.Text;
   PreferencesForm.ChangeLadderPasswordButtonClick(nil);
 end;
 
@@ -143,6 +144,7 @@
 
 procedure TLogonForm.btRegisterLadderClick(Sender: TObject);
 begin
+  PreferencesForm.UsernameEdit.Text := txtLogin.Text;
   PreferencesForm.RegisterLadderAccountButtonClick(nil);
 end;
 

Modified: branches/0.77-branch/Lobby/TASClient/MainUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/MainUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/MainUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,8 +1,8 @@
 object MainForm: TMainForm
-  Left = 735
-  Top = 114
-  Width = 729
-  Height = 543
+  Left = 430
+  Top = 367
+  Width = 773
+  Height = 535
   Caption = '.'
   Color = clBtnFace
   Constraints.MaxHeight = 1000
@@ -24,14 +24,15 @@
   object MainTitleBar: TSpTBXTitleBar
     Left = 0
     Top = 0
-    Width = 721
-    Height = 516
+    Width = 765
+    Height = 508
     Caption = 'TASClient'
+    TBXStyleBackground = True
     object Panel2: TSpTBXPanel
-      Left = 564
+      Left = 608
       Top = 30
       Width = 153
-      Height = 482
+      Height = 474
       Align = alRight
       Color = clNone
       Constraints.MinWidth = 1
@@ -41,7 +42,7 @@
       BorderType = pbrFramed
       DesignSize = (
         153
-        482)
+        474)
       object Bevel1: TBevel
         Left = 2
         Top = 2
@@ -82,12 +83,30 @@
         LinkFont.Name = 'MS Sans Serif'
         LinkFont.Style = [fsUnderline]
       end
-      object ClientsListBox: TListBox
+      object btSearchPlayer: TSpTBXSpeedButton
+        Left = 4
+        Top = 4
+        Width = 22
+        Height = 20
+        Hint = 'Search for a player in the list. Hit F3 to get the next result.'
+        ParentShowHint = False
+        ShowHint = True
+        DropDownArrow = False
+        DropDownMenu = SearchPlayerFormPopupMenu
+        Images = BattleStatusImageList
+        ImageIndex = 6
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
+      object ClientsListBox: TTntListBox
         Tag = -1
         Left = 2
         Top = 26
         Width = 149
-        Height = 454
+        Height = 446
         Style = lbOwnerDrawFixed
         Align = alClient
         Font.Charset = DEFAULT_CHARSET
@@ -99,7 +118,7 @@
         ParentFont = False
         ParentShowHint = False
         ShowHint = True
-        TabOrder = 0
+        TabOrder = 2
         OnClick = ClientsListBoxClick
         OnDblClick = ClientsListBoxDblClick
         OnDrawItem = ClientsListBoxDrawItem
@@ -109,39 +128,31 @@
         OnMouseMove = ClientsListBoxMouseMove
         OnMouseUp = ClientsListBoxMouseUp
       end
-      object btSearchPlayer: TSpTBXSpeedButton
-        Left = 4
-        Top = 4
-        Width = 22
-        Height = 20
-        Hint = 'Search for a player in the list. Hit F3 to get the next result.'
-        ParentShowHint = False
-        ShowHint = True
-        DropDownArrow = False
-        DropDownMenu = SearchPlayerFormPopupMenu
-        Images = BattleStatusImageList
-        ImageIndex = 6
-        LinkFont.Charset = DEFAULT_CHARSET
-        LinkFont.Color = clBlue
-        LinkFont.Height = -11
-        LinkFont.Name = 'MS Sans Serif'
-        LinkFont.Style = [fsUnderline]
-      end
     end
+    object Splitter1: TSpTBXSplitter
+      Left = 598
+      Top = 30
+      Width = 10
+      Height = 474
+      Cursor = crSizeWE
+      Caption = 'Splitter1'
+      Align = alRight
+      GripSize = 100
+    end
     object Panel1: TSpTBXPanel
       Left = 4
       Top = 30
-      Width = 550
-      Height = 482
+      Width = 594
+      Height = 474
       Caption = 'Panel1'
       Align = alClient
-      TabOrder = 2
+      TabOrder = 3
       Borders = False
-      BorderType = pbrBumped
+      TBXStyleBackground = True
       object Bevel2: TBevel
         Left = 2
         Top = 43
-        Width = 546
+        Width = 590
         Height = 4
         Align = alTop
         Shape = bsSpacer
@@ -265,8 +276,8 @@
       end
       object Panel3: TPanel
         Left = 2
-        Top = 210
-        Width = 546
+        Top = 202
+        Width = 590
         Height = 270
         Align = alBottom
         BevelOuter = bvNone
@@ -274,15 +285,16 @@
         object BattlesPanel: TSpTBXPanel
           Left = 0
           Top = 0
-          Width = 546
+          Width = 590
           Height = 270
           Align = alClient
           TabOrder = 0
           Borders = False
+          TBXStyleBackground = True
           object QuickJoinPanel: TSpTBXPanel
             Left = 2
             Top = 2
-            Width = 542
+            Width = 586
             Height = 25
             Hint = 'Quick join panel'
             Caption = 'QuickJoinPanel'
@@ -290,7 +302,7 @@
             TabOrder = 1
             Borders = False
             DesignSize = (
-              542
+              586
               25)
             object SpTBXLabel1: TSpTBXLabel
               Left = 0
@@ -314,7 +326,7 @@
               LinkFont.Style = [fsUnderline]
             end
             object btSpecatateNow: TSpTBXButton
-              Left = 445
+              Left = 375
               Top = 0
               Width = 97
               Height = 22
@@ -340,7 +352,7 @@
               LinkFont.Style = [fsUnderline]
             end
             object btPlayNow: TSpTBXButton
-              Left = 339
+              Left = 269
               Top = 0
               Width = 97
               Height = 22
@@ -381,7 +393,7 @@
           object VDTBattles: TVirtualDrawTree
             Left = 2
             Top = 27
-            Width = 542
+            Width = 586
             Height = 56
             Align = alClient
             BevelInner = bvNone
@@ -494,7 +506,7 @@
           object FilterGroup: TSpTBXPanel
             Left = 2
             Top = 95
-            Width = 542
+            Width = 586
             Height = 173
             Caption = 'FilterGroup'
             Align = alBottom
@@ -502,12 +514,12 @@
             OnResize = FilterGroupResize
             Borders = False
             DesignSize = (
-              542
+              586
               173)
             object FiltersTabs: TSpTBXTabControl
               Left = 2
               Top = 2
-              Width = 538
+              Width = 582
               Height = 169
               Align = alClient
               Color = clBtnFace
@@ -529,18 +541,18 @@
               object SpTBXTabSheet1: TSpTBXTabSheet
                 Left = 0
                 Top = 0
-                Width = 538
+                Width = 582
                 Height = 146
                 Caption = 'Filters'
                 ImageIndex = -1
                 DesignSize = (
-                  538
+                  582
                   146)
                 TabItem = 'SpTBXTabItem1'
                 object FilterList: TVirtualStringTree
                   Left = 424
                   Top = 8
-                  Width = 98
+                  Width = 145
                   Height = 129
                   Anchors = [akLeft, akTop, akRight]
                   CheckImageKind = ckSystem
@@ -685,6 +697,7 @@
                   ThemeType = thtWindows
                   TabOrder = 8
                   BorderType = pbrRaised
+                  TBXStyleBackground = True
                   object FullFilter: TSpTBXCheckBox
                     Left = 8
                     Top = 8
@@ -849,18 +862,18 @@
               object SpTBXTabSheet2: TSpTBXTabSheet
                 Left = 0
                 Top = 0
-                Width = 538
+                Width = 582
                 Height = 146
                 Caption = 'Presets'
                 ImageIndex = -1
                 DesignSize = (
-                  538
+                  582
                   146)
                 TabItem = 'SpTBXTabItem2'
                 object PresetListbox: TSpTBXListBox
                   Left = 152
                   Top = 26
-                  Width = 378
+                  Width = 417
                   Height = 113
                   Anchors = [akLeft, akTop, akRight]
                   ItemHeight = 16
@@ -894,6 +907,7 @@
                   Height = 129
                   Caption = 'Options'
                   TabOrder = 2
+                  TBXStyleBackground = True
                   object btDeletePreset: TSpTBXButton
                     Left = 8
                     Top = 72
@@ -948,7 +962,7 @@
               end
             end
             object EnableFilters: TSpTBXCheckBox
-              Left = 430
+              Left = 360
               Top = 154
               Width = 110
               Height = 18
@@ -967,7 +981,7 @@
           object FiltersButton: TSpTBXButton
             Left = 2
             Top = 83
-            Width = 542
+            Width = 586
             Height = 12
             Align = alBottom
             TabOrder = 3
@@ -982,15 +996,41 @@
           end
         end
       end
+      object Splitter2: TSpTBXSplitter
+        Left = 2
+        Top = 196
+        Width = 590
+        Height = 6
+        Cursor = crSizeNS
+        Caption = 'Splitter2'
+        Align = alBottom
+        Color = clBtnFace
+        ParentColor = False
+        GripSize = 100
+        OnMoving = Splitter2Moving
+      end
+      object PageControl1: TPageControl
+        Left = 2
+        Top = 47
+        Width = 590
+        Height = 149
+        Align = alClient
+        Constraints.MinHeight = 1
+        Style = tsButtons
+        TabOrder = 2
+        TabStop = False
+        OnChange = PageControl1Change
+        OnMouseDown = PageControl1MouseDown
+      end
       object Panel4: TSpTBXPanel
         Left = 2
         Top = 2
-        Width = 546
+        Width = 590
         Height = 41
         Align = alTop
         Color = clNone
         ParentColor = False
-        TabOrder = 1
+        TabOrder = 3
         BorderType = pbrRaised
         TBXStyleBackground = True
         object OptionsSpeedButton: TSpTBXSpeedButton
@@ -1099,43 +1139,7 @@
           LinkFont.Style = [fsUnderline]
         end
       end
-      object PageControl1: TPageControl
-        Left = 2
-        Top = 47
-        Width = 546
-        Height = 153
-        Align = alClient
-        Constraints.MinHeight = 1
-        Style = tsButtons
-        TabOrder = 2
-        TabStop = False
-        OnChange = PageControl1Change
-        OnMouseDown = PageControl1MouseDown
-      end
-      object Splitter2: TSpTBXSplitter
-        Left = 2
-        Top = 200
-        Width = 546
-        Height = 10
-        Cursor = crSizeNS
-        Caption = 'Splitter2'
-        Align = alBottom
-        Color = clBtnFace
-        ParentColor = False
-        GripSize = 100
-        OnMoving = Splitter2Moving
-      end
     end
-    object Splitter1: TSpTBXSplitter
-      Left = 554
-      Top = 30
-      Width = 10
-      Height = 482
-      Cursor = crSizeWE
-      Caption = 'Splitter1'
-      Align = alRight
-      GripSize = 100
-    end
   end
   object ButtonImageList: TImageList
     Left = 176
@@ -2637,480 +2641,480 @@
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000BCA7E4009078D1006C56C1005A48BA005946B8006550BD008469CA00AD95
-      DD00000000000000000000000000000000000000000000000000000000000000
+      0000000000004F3790002B1580001907790018057700240F7C00432889006C54
+      9C00000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000C1C3C300A7AEAF009AA3A60098A2A400A2A9AA00B8BBBB00D3D2
-      D200000000000000000000000000000000000000000000000000000000000000
+      00000000000080828200666D6E00596265005761630061686900777A7A009291
+      9100000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000A3DA500081CD2B0072C500006EC400007AC92B0098D53D000000
+      00000000000070A71D004E9A00003F9200003B9100004796000065A20A000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000D0C0EC00745EC6001E2B
-      A7000028A7000032B300003DBA000041BC000041BC00003BB8000030B0000021
-      A200001E99005641B400B59CDF00000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000000000000331D85000000
+      66000014870000199300001F9A0000219C0000219C00001E9800001890000011
+      82000000580015007300745B9E00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000ACB3B5005A88
-      90000085910000919D00009BA600009EAA00009DA9000098A300008F9A00007E
-      8A0035798000969D9F00D7D6D600000000000000000000000000000000000000
+      00000000000000000000000000000000000000000000000000006B7274001947
+      4F000044500000717D00007B8600007E8A00007D890000788300006F7A00005E
+      6A0000383F00555C5E0096959500000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000000000000089CF35002BB1
-      000000AF000000B7000000BF000000C12B0000C1000000BD000000B6000000AA
-      000000A600006DC1000000000000000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000000000000569C0200007E
+      0000007C0000009E000000A6000000A8160000A8000000A40000009D00000077
+      0000007300003A8E000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000006E59C3000021A300003BB8000053
-      C700155ACB00155DCD00155FCF000E61D0000E61D000155ECE00155ACB001555
-      C8000E4DC2000039B500001E9C004532AB00C4AEE60000000000000000000000
+      0000000000000000000000000000000000002D18820000118300001E98000033
+      A700155ACB00155DCD00155FCF000E61D0000E61D000155ECE00155ACB001555
+      C800072DA200001D9500000F7C0004006A00836DA50000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000A9AFB10000808B000098A3003DAB
-      B6004CB1BC004CB2BF004CB4C10048B5C20048B5C2004CB3BF004CB1BC004CAC
-      B80048A7B1000097A10000798300869194000000000000000000000000000000
+      000000000000000000000000000000000000686E7000003F4A00007883001F8B
+      96002C919C004CB2BF004CB4C10048B5C20048B5C2004CB3BF004CB1BC004CAC
+      B800288791000077810000596300455053000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000084CD2B0000AB000000BD000000CA
-      350000CE430000CF480000D0480000D14C0000D14C0000CF480000CE430000CB
-      3D0000C82B0000BC000000A600005AB700000000000000000000000000000000
+      000000000000000000000000000000000000519A00000078000000A4000000B1
+      1C0000B52A0000CF480000D0480000D14C0000D14C0000CF480000CE430000B2
+      240000AF160000A3000000730000278400000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000C4B3E8002828A2000032B2000E50C4001553C7001556
+      000000000000000000000000000000006100001992000E50C4001553C7001556
       C900155ACB00155DCD00155FCF000E63D2001567D4000E68D5000E68D5001566
-      D300155FCF001556CA001550C400003BB60000159000977AD200000000000000
+      D300155FCF001556CA001550C400001E9600000B700056399100000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000069848A0000919C0048AAB30050ACB70050AE
+      00000000000000000000000000002843490000717C00288A930050ACB70050AE
       B90050B0BC004CB2BF004CB4C10048B7C4004CB9C60048BAC80048BAC8004CB8
-      C6004CB4C10050AEB90050A9B3000098A200006D7500C4C4C400000000000000
+      C6004CB4C10050AEB90050A9B30000788200002C340083838300000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000003DAE000000B7000000C9350000CB350000CD
+      00000000000000000000000000000A7B0000009E000000B01C0000CB350000CD
       3D0000CE430000CF480000D04C0000D2500000D3530000D4570000D4570000D3
-      530000D0480000CD3D0000C9350000BD0000009B0000A9DB5000000000000000
+      530000D0480000CD3D0000B01C0000A400000068000076A81D00000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000B6A0E100001A95000041BB001A4DC2001A4DC1001A4DC1001A4B
+      00000000000000000000000D750000219B001A4DC2001A4DC1001A4DC1001A4B
       C1001A4DC3001A55C8001A5ECD001A68D3001A70D8001A77DB001578DC001573
-      DA00156CD7001567D400155ECE001A53C700154AC000001A98007F61C6000000
+      DA00156CD7001567D400155ECE001A53C700154AC000000D78003E2085000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000D8D8D8002B747C003D9EA80057A7B00053A6AF0053A6AF0053A6
+      0000000000009797970000333B001F7E880057A7B00053A6AF0053A6AF0053A6
       AF0053A7B10053ACB70053B3BF0053B9C60053BFCC0053C2D0004CC3D1004CC0
-      CF004CBCCA004CB9C60050B3BF0053ACB6004CA5AE0000747E00B5B5B5000000
+      CF004CBCCA004CB9C60050B3BF0053ACB6002C858E0000545E00747474000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000A2000000C100002BC82B002BC72B002BC72B002BC7
+      00000000000000000000006F000000A800002BC82B002BC72B002BC72B002BC7
       2B002BC82B002BCB3D002BD048002BD453002BD85F002BDA6B0000DA6D0000D8
-      660000D65D0000D3530000D048002BCB350000C62B0000A2000094D135000000
+      660000D65D0000D3530000D048002BCB350000AD160000890000619E02000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000C1ABE500001A94000E45BC001E4ABE001A46BD001A45BC001A46BD001E56
+      000000000000000D74000E45BC001E4ABE001A46BD001A45BC001A46BD001E56
       C7002162CF00216CD3002170D6002175D800217CDC002184E1001E8FE6001E97
-      EA001A94E900157FDF00156CD6001563D2001A57CA001A4FC300001E9C008868
-      CA00000000000000000000000000000000000000000000000000000000000000
-      00000000000035727A0048A0A9005AA4AC0057A2AA0057A1A90057A2AA005DAE
+      EA001A94E900157FDF00156CD6001563D2001A57CA001A4FC300000F7C004727
+      8900000000000000000000000000000000000000000000000000000000000000
+      00000000000000313900288089005AA4AC0057A2AA0057A1A90057A2AA005DAE
       B7005FB6C00062BCC60062BFC90062C1CD0062C5D1005FCAD7005DCFDF005AD4
-      E40053D2E20050C7D6004CBCC90050B7C40053AFB90053A8B100007A8400BBBA
-      BB00000000000000000000000000000000000000000000000000000000000000
-      00000000000000A0000000C300002BC62B002BC42B002BC300002BC42B002BCD
+      E40053D2E20050C7D6004CBCC90050B7C40053AFB90053A8B100005A64007A79
+      7A00000000000000000000000000000000000000000000000000000000000000
+      000000000000006D000000AA00002BC62B002BC42B002BC300002BC42B002BCD
       35002BD2480035D6530035D85A0035D9620035DC6B002BDF7A002BE28D002BE5
-      9C002BE4970000DD750000D65A0000D250002BCD3D002BC82B0000A600009BD4
-      3D00000000000000000000000000000000000000000000000000000000000000
+      9C002BE4970000DD750000D65A0000D250002BCD3D002BC82B00008D000068A1
+      0A00000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00002B219A000E41BA001E4ABE001E46BC001E45BB001E4DC0002565CF00256F
+      00000000590007219A001E4ABE001E46BC001E45BB001E4DC0002565CF00256F
       D500256ED400256ED400286ED400286FD5002870D5002574D700257BDB002188
-      E2002199EB001EA7F1001A96E9001573D9001A67D2001A59CA001A50C300001A
-      9500B499DF000000000000000000000000000000000000000000000000000000
-      00006B7D8100439DA6005DA4AC005AA2AA005AA1A7005DA6AF0064B7C10064BE
+      E2002199EB001EA7F1001A96E9001573D9001A67D2001A59CA001A50C300000D
+      750073589E000000000000000000000000000000000000000000000000000000
+      00002A3C4000237D86005DA4AC005AA2AA005AA1A7005DA6AF0064B7C10064BE
       C80064BDC70064BDC70066BDC70066BEC80066BFC90064C1CB0064C4D00062CB
-      D8005FD5E4005DDCEC0057D3E20050C0CE0053B9C50057AFBB0057A9B1000072
-      7C00D7D5D5000000000000000000000000000000000000000000000000000000
-      00003DA9000000C100002BC62B002BC42B002BC300002BC72B0035D24C0035D7
+      D8005FD5E4005DDCEC0057D3E20050C0CE0053B9C50057AFBB0057A9B1000052
+      5C00969494000000000000000000000000000000000000000000000000000000
+      00000A76000000A800002BC62B002BC42B002BC300002BC72B0035D24C0035D7
       570035D6570035D6530035D6570035D7570035D85A0035D85D0035DB690035DF
-      7D002BE69E002BE9B7002BE4970000D864002BD350002BCD3D002BC92B0000A0
+      7D002BE69E002BE9B7002BE4970000D864002BD350002BCD3D0016B01600006D
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000000000000000000000785A
-      C2000030AD00214DC0001E48BE001E46BC002153C400286ED4002871D6002870
+      0000000000000000000000000000000000000000000000000000000000003719
+      810000188D00214DC0001E48BE001E46BC002153C400286ED4002871D6002870
       D5002871D500286BD2002562CE00215ECB00215DCB00255ECB002868D0002875
-      D8002883DF002195E80021ADF2001EA1ED001A75DA001A67D2001E59CA000E48
-      BF003228A200000000000000000000000000000000000000000000000000B0B0
-      B100008F98005FA6AE005DA3AB005DA2A9005FABB30066BDC70069BFC90069BF
+      D8002883DF002195E80021ADF2001EA1ED001A75DA001A67D2001E59CA000728
+      9F00000061000000000000000000000000000000000000000000000000006F6F
+      7000006F78005FA6AE005DA3AB005DA2A9005FABB30066BDC70069BFC90069BF
       C90069BFC90066BBC50064B6BF0062B3BC0062B2BB0064B3BC0066B9C20066C1
-      CC0066C9D50062D2E1005FDEEE005AD8E70053C1CF0053B9C4005AAFB90048A3
-      AC0074868A000000000000000000000000000000000000000000000000008DCE
-      2B0000B600002BC72B002BC52B002BC400002BCA350035D653003DD85A003DD8
+      CC0066C9D50062D2E1005FDEEE005AD8E70053C1CF0053B9C4005AAFB9002883
+      8C00334549000000000000000000000000000000000000000000000000005A9B
+      0000009D00002BC72B002BC52B002BC400002BCA350035D653003DD85A003DD8
       5A003DD85A0035D5500035D2480035CF430035CF3D0035D0430035D44C0035D9
-      5F0035DE750035E495002BEBBC002BE8A7002BD966002BD350002BCD3D0000C5
-      2B0048B000000000000000000000000000000000000000000000000000000000
+      5F0035DE750035E495002BEBBC002BE8A7002BD966002BD350002BCD3D0000AC
+      1600157D00000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000CDBAEA00001E
-      9C001E4FC100214BC000214ABE002152C4002B70D5002B75D7002B76D8002B6F
+      000000000000000000000000000000000000000000000000000000000000000F
+      7C001E4FC100214BC000214ABE002152C4002B70D5002B75D7002B76D8002B6F
       D400255AC900214DC000214ABE002148BE002148BE00214ABE00214ABE002150
       C3002867D0002882DF002896E90021AFF2001EA2EC001A73D9001E65D1002159
-      C900002DAB008F71CE0000000000000000000000000000000000000000002B7C
-      83005DA8AF005FA6AD005FA4AC0062AAB3006BBFC9006BC1CB006BC2CB006BBE
+      C90000178B004E308D000000000000000000000000000000000000000000003B
+      42003D888F005FA6AD005FA4AC0062AAB3006BBFC9006BC1CB006BC2CB006BBE
       C70064B0B9005FA6AF005FA4AC005FA3AB005FA3AB005FA4AB005FA4AC0062AA
       B10066B9C20069C9D50066D3E10062DFEE005DD9E70053C0CD005AB7C3005FAF
-      B900008B9500C0BFBF00000000000000000000000000000000000000000000A8
-      00002BC82B002BC72B002BC62B0035CA35003DD85A003DD95D003DD95F003DD7
+      B900006B75007F7E7E0000000000000000000000000000000000000000000075
+      000016AF16002BC72B002BC62B0035CA35003DD85A003DD95D003DD95F003DD7
       570035CE3D002BC72B002BC62B002BC52B002BC52B002BC62B002BC62B0035C9
       2B0035D34C003DDE740035E4960035ECBF002BE8A6002BD862002BD24C002BCD
-      3D0000B30000A2D8480000000000000000000000000000000000000000000000
+      3D00009A00006FA5150000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000745AC200003B
-      B5002150C200214DC000214DC0002B6FD4002D7ADA002D7AD9002B6FD5002552
+      000000000000000000000000000000000000000000000000000033198100001E
+      95002150C200214DC000214DC0002B6FD4002D7ADA002D7AD9002B6FD5002552
       C300214ABF00214DC000214DC000214DC000214DC000214DC000214DC000214D
       C000214ABE00285FCC002B86E000289CEA0025B5F3001E97E7001A6ED6001E61
-      CE001A52C4002D2BA50000000000000000000000000000000000ADB0B1000098
-      A00062A9B00062A6AE0062A7AF006DBEC7006EC4CE006EC4CE006DBEC80064AA
+      CE000D32A40000006400000000000000000000000000000000006C6F70000078
+      800062A9B00062A6AE0062A7AF006DBEC7006EC4CE006EC4CE006DBEC80064AA
       B10062A5AC0062A7AF0062A7AF0062A7AF0062A7AF0062A7AF0062A7AF0062A6
       AD0062A5AC0066B4BD006BCBD70066D6E40064E1F0005DD4E00057BDC9005DB5
-      BF0057AAB3006E898D00000000000000000000000000000000008ACE2B0000BD
+      BF00378A93002D484C0000000000000000000000000000000000579B000000A4
       000035C92B0035C72B0035C82B003DD7570043DB640043DB64003DD7570035CA
       2B0035C62B0035C82B0035C82B0035C82B0035C82B0035C82B0035C82B0035C7
       2B0035C62B0035D043003DDF790035E69D0035EDC6002BE592002BD65A002BD1
-      48002BCA350043B2000000000000000000000000000000000000000000000000
+      480016B11C00107F000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000000000002B2DA7001E50
-      C3002550C200254DC0002B61CC00307DDB00307CDB003078D8002855C600254F
+      0000000000000000000000000000000000000000000000000000000066000F30
+      A3002550C200254DC0002B61CC00307DDB00307CDB003078D8002855C600254F
       C0002550C2002850C2002550C2002850C2002850C2002550C2002550C2002550
       C2002550C200254DC0002B66CF002D8FE40028A6EE0025B5F2001E7FDE001E69
-      D400255ECB00002DAA00B49CDF000000000000000000000000006B8B90005DAA
-      B10064AAB10064A7AF006BB5BD0072C6D00072C6CF0072C3CD0066ACB50064A8
+      D400255ECB0000178A00735B9E000000000000000000000000002A4A4F003D8A
+      910064AAB10064A7AF006BB5BD0072C6D00072C6CF0072C3CD0066ACB50064A8
       AF0064AAB10066AAB10064AAB10066AAB10066AAB10064AAB10064AAB10064AA
       B10064A9B10064A7AE006BB8C1006ECFDC0069DBE90064E1EE005AC7D4005DBB
-      C60064B3BC00008B9300D7D6D5000000000000000000000000003DB300002BC9
-      2B0035C92B0035C82B003DD1430043DC6B0043DC690043DA620035CB350035C8
+      C60064B3BC00006B7300969594000000000000000000000000000A80000016B0
+      160035C92B0035C82B003DD1430043DC6B0043DC690043DA620035CB350035C8
       2B0035C92B0035C92B0035C92B0035C92B0035C92B0035C92B0035C92B0035C9
       2B0035C92B0035C82B003DD34C0043E285003DE9AD0035EDBF002BDD72002BD5
-      530035CF430000B3000000000000000000000000000000000000000000000000
+      53001CB62A000080000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000BDA7E300002DAA002856
+      000000000000000000000000000000000000000000000000000000178A002856
       C6002853C4002853C4003077D8003581DD003581DD002B62CD002850C2002853
       C4002853C4002853C4002853C4002853C4002853C4002853C4002853C4002853
       C4002853C4002853C4002850C2003078D900309AE90028B5F3002199E8001E6F
-      D7002563CF000045BC007A61C600000000000000000000000000008B930069AE
-      B50069ABB30069ABB20072C2CB0075C8D20075C8D2006DB6BF0066A9B00069AB
+      D7002563CF0000259C0039208500000000000000000000000000004A5200498E
+      950069ABB30069ABB20072C2CB0075C8D20075C8D2006DB6BF0066A9B00069AB
       B30069ABB30069ABB30069ABB30069ABB30069ABB30069ABB30069ABB30069AB
       B30069ABB30069ABB20066AAB10070C3CD0070D5E20069E1EF005FD5E1005DBE
-      CA0064B7C10035A0A900B1B5B50000000000000000000000000000B300003DCD
-      35003DCA35003DCA350043DA5F0048DE6D0048DE6D003DD2480035C92B003DCA
+      CA0064B7C1001B808900707474000000000000000000000000000080000024B4
+      1C003DCA35003DCA350043DA5F0048DE6D0048DE6D003DD2480035C92B003DCA
       35003DCA35003DCA35003DCA35003DCA35003DCA35003DCA35003DCA35003DCA
       35003DCA35003DCA350035C92B0043DA620043E699003DEDC3002BE694002BD7
-      5D0035D2480000C300008FD13500000000000000000000000000000000000000
+      5D0035D2480000AA00005C9E0200000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000009177D000003DB6002B57
+      0000000000000000000000000000000000000000000050368F00001F96002B57
       C7002B53C4002B5ECB003583DE003585DE00357CDA002B56C6002B55C5002B56
       C6002B56C6002B56C6002B56C6002B56C6002B56C6002B56C6002B56C6002B56
       C6002B56C6002B56C6002B53C4002B62CD003591E50030ABF00028AAEE002177
-      DA002569D2001E56C7004A3FB3000000000000000000C1C2C200009AA2006BAF
+      DA002569D2000F36A70009007200000000000000000080818100007A82006BAF
       B6006BACB3006DB3BB0077C9D30077CAD40075C5CF006BADB5006BACB4006BAD
       B5006BADB5006BADB5006BADB5006BADB5006BADB5006BADB5006BADB5006BAD
       B5006BADB5006BADB5006BACB3006DB6BE0075D0DC0070DDEB0066DCE9005FC2
-      CF0064BBC5005AAEB7008B9B9E000000000000000000A4DA4C0000BE00003DCD
+      CF0064BBC5003A8E97004A5A5D00000000000000000071A7190000A500003DCD
       35003DCB35003DCF3D0048DE700048DF720048DC66003DCC35003DCB35003DCC
       35003DCC35003DCC35003DCC35003DCC35003DCC35003DCC35003DCC35003DCC
       35003DCC35003DCC35003DCB35003DD2430048E3880043EAB20035EAAD002BDA
-      660035D550002BCD35005FBF0000000000000000000000000000000000000000
+      660035D5500016B41C002C8C0000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000006F59C2000E4ABF002B5A
+      000000000000000000000000000000000000000000002E188100072A9F002B5A
       C8002B56C6003069D100378AE000378AE1003273D6002B56C6002B59C7002B59
       C8002B59C7002B59C7002B59C7002B57C7002B56C6002B59C7002B59C7002B59
       C7002B57C7002B57C7002B57C7002D5AC9003589E00035A3EC002DAFF100217E
-      DD00286ED5002561CD002B32AC000000000000000000AAAFB10048A4AC006DB0
+      DD00286ED5001341AD0000006B000000000000000000696E700028848C006DB0
       B7006DADB50072BBC30079CDD70079CDD70074C0C9006DADB5006DAFB7006DAF
       B7006DAFB7006DAFB7006DAFB7006DAFB6006DAEB5006DAFB7006DAFB7006DAF
       B7006DAFB7006DAFB7006DAFB6006EB1B90077CCD70075D9E6006EDFEC0062C7
-      D20066BDC80064B5BE006D919600000000000000000085CD2B0000C62B003DCE
+      D20066BDC80044959E002C5055000000000000000000529A000000AD16003DCE
       3D003DCC350043D550004CE179004CE17A0048D85A003DCC35003DCD35003DCD
       3D003DCD35003DCD35003DCD35003DCD35003DCD35003DCD35003DCD35003DCD
       35003DCD35003DCD35003DCD350043CE3D0048E0790048E8A50043ECB70035DC
-      6E0035D6570035D143003DB70000000000000000000000000000000000000000
+      6E0035D657001CB82A000A840000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000005F4DBB001A50C3002D5C
+      000000000000000000000000000000000000000000001E0C7A000D30A3002D5C
       C9002B57C7003574D6003B8FE3003990E3003270D4002D5AC8002D5ECA002D5E
       CA002D5ECA002D5DCA002D5AC900305ECB00305ECB002D5AC8002D5AC9002D5A
       C9002D5AC9002D5AC9002D5AC8002D5AC8003784DE00379EEA0032AEF0002883
-      DF002870D7002867D0001E32AC0000000000000000009DA6A80057AAB1006EB1
+      DF002870D7001447B00000006B0000000000000000005C656700378A91006EB1
       B9006DAFB60075C1C9007DCFDA007CD0DA0074BFC7006EB0B8006EB3BB006EB3
       BB006EB3BB006EB2BA006EB1B90070B3BB0070B3BB006EB0B7006EB1B9006EB1
       B9006EB1B9006EB1B9006EB1B8006EB1B80079CAD40079D7E30074DFEC0066C9
-      D50066BFCA0069B9C2005D909600000000000000000075C700002BC92B0043CF
+      D50066BFCA004999A2001C4F550000000000000000004294000016B0160043CF
       3D003DCD350048D85A0050E2800050E2810048D8570043CE3D0043CF3D0043CF
       3D0043CF3D0043CF3D0043CE3D0043CF3D0043D03D0043CE3D0043CE3D0043CE
       3D0043CE3D0043CE3D0043CE3D0043CE3D004CDF72004CE79B0048EBB60035DE
-      740035D85D003DD34C002BB70000000000000000000000000000000000000000
+      740035D85D0024BA330000840000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000005D4DBB001E53C500305E
+      000000000000000000000000000000000000000000001C0C7A000F33A500305E
       CA00305AC800377AD9003D96E5003D97E6003576D7003061CC003065CF003065
       CF003065CE003062CC00326CD2003B8EE2003D8EE200326BD100305CC900305E
       CA00305ECA00305ECA00305ECA00305ECA003986DF003B9CE90035ABEF002882
-      DE002873D7002B6BD2001E32AD0000000000000000009BA6A8005DACB40070B3
+      DE002873D700164BB20000006C0000000000000000005A6567003D8C940070B3
       BB0070B1B80079C4CD0080D3DD007ED3DE0075C2CB0070B5BD0072B7C00072B7
       C00072B7BF0070B5BD0074BCC4007DCFD9007ECFD90074BBC30070B1B90070B3
       BB0070B3BB0070B3BB0070B3BB0070B3BA007CCBD5007DD6E20077DDEA0069C9
-      D40069C0CB006DBBC4005D919800000000000000000074C700002BCB350043D0
+      D40069C0CB004D9BA4001C50570000000000000000004194000016B21C0043D0
       3D0043CE3D004CDB620053E48A0053E48C0048D95D0043D1430043D2480043D2
       480043D2480043D1430048D6500050E2800053E2800048D5500043CF3D0043CF
       3D0043CF3D0043CF3D0043CF3D0043CF3D0050DF750050E6970048EAB0003DDE
-      72003DD85D003DD550002BB70000000000000000000000000000000000000000
+      72003DD85D0024BC370000840000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000006955C0001E53C4003262
+      0000000000000000000000000000000000000000000028147F000F33A4003262
       CC00305ECA00397BD900419DE80043A1EA003984DE003269D100356FD400356F
       D400356ED4003268D0003985DE0043A0EA00419CE8003B80DC00305ECA003261
       CB003261CB003261CB00325FCB003262CC003D8DE2003D9DE90039A6ED002B7D
-      DC002B75D8002D6BD2002B37B0000000000000000000A6ACAE005AABB30074B5
+      DC002B75D800174BB20000006F000000000000000000656B6D003A8B930074B5
       BD0072B3BB007AC4CE0083D7E10084D8E4007CCAD40074BBC30075BEC70075BE
       C70075BDC60074B9C2007CCAD40084D8E30083D6E1007DC8D10072B3BA0074B5
       BC0074B5BC0074B5BC0074B4BC0074B5BD0080CFD80080D7E2007ADBE7006BC6
-      D1006DC1CB006EBBC4006B949A00000000000000000080CB2B002BCA350048D1
+      D1006DC1CB004E9BA4002A53590000000000000000004D98000016B11C0048D1
       430043CF3D004CDB640057E6950057E89C0050DF720048D54C0048D7530048D7
       530048D6530048D44C0050DF720057E89B0057E6940050DD6D0043CF3D0048D1
       430048D1430048D1430048D0430048D1430053E17D0053E697004CE9A7003DDC
-      6D003DD95F0043D550003DBA0000000000000000000000000000000000000000
+      6D003DD95F002ABC37000A870000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000876DCC00154DC0003566
+      00000000000000000000000000000000000000000000462C8B000B2DA0003566
       CE003562CC003978D80043A6EC0045ADEF003D9DE9003575D700357CDA00357C
       DA00357ADA003573D6003D91E30043AAEE0043A3EB003D86DF003261CB003562
       CD003562CD003562CD003561CC00356BD1004397E60043A0EA0039A0EA002D79
-      DA002D75D7002B68D100413DB4000000000000000000BABCBD0050A6AF0077B8
+      DA002D75D7001648B100000073000000000000000000797B7C0030868F0077B8
       BF0075B5BD007AC3CC0084DBE60086DEEA0080D7E20077C1CB0077C5CF0077C5
       CF0077C4CE0075C0C9007ED0DB0085DCE80085D9E4007ECBD50074B5BC0075B6
       BE0075B6BE0075B6BE0075B5BD0077BBC30084D3DE0084D8E3007CD8E4006EC3
-      CE006EC1CB006BBAC300839B9F0000000000000000009BD6430000C72B0048D3
+      CE006EC1CB004B9AA300425A5E00000000000000000068A3100000AE160048D3
       480048D143004CDA5F0057E9A2005AEBB10053E6970048D95D0048DC660048DC
       660048DB640048D85A0053E384005AEAAA005AE89E0053DF740048D1430048D2
       430048D2430048D2430048D1430048D54C0057E48B0057E89A0050E89C0043DA
-      640043D95D003DD44C0057BF0000000000000000000000000000000000000000
+      640043D95D0024BB3300248C0000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000B097DE000E3FB800376B
+      000000000000000000000000000000000000000000006F569D0007209800376B
       D1003567CF003771D50045ABEE0046BCF30046C0F200398DE2003988E000398A
       E1003988E000377EDC003F9DE80046B7F20045ADEE003D8CE1003565CD003566
       CF003566CE003566CE003562CC003D80DB00459FE90043A4EB003B95E5003075
-      D7003076D8001E5ECB006C57C2000000000000000000D4D3D300439CA40079BB
+      D7003076D8000F3EAB002B168100000000000000000093929200237C840079BB
       C30077B9C10079BFC80086DDE90088E4EF0088E6EE007CCFD8007ACBD7007ACD
       D8007ACBD70079C7D10081D7E10088E2EE0086DEE90080CED80075B7BF0077B8
       C00077B8BF0077B8BF0075B5BD007EC8D00086D8E20085DAE5007DD2DD0070C1
-      CB0072C2CB005DB3BC00A7AFB00000000000000000000000000000C000004CD5
-      4C0048D34C004CD857005AEAAC005DEFC2005DF0BF0050E17D004CDF79004CE1
+      CB0072C2CB003D939C00666E6F00000000000000000000000000008D000033BC
+      330048D34C004CD857005AEAAC005DEFC2005DF0BF0050E17D004CDF79004CE1
       7C004CDF79004CDC6B0053E695005DEEBE005AEBAD0053E17C0048D2480048D3
       480048D3480048D3480048D1430053DD6B005AE797005AE8A00050E48A0043D9
-      5D0043D95F002BCF430081CD2B00000000000000000000000000000000000000
+      5D0043D95F0016B62A004E9A0000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000000000002137B000376E
-      D200376DD200376FD40043A4EA004ACAF5004BD4F60043B9EF003991E5003B97
+      000000000000000000000000000000000000000000000000000000006F001C4E
+      B200376DD200376FD40043A4EA004ACAF5004BD4F60043B9EF003991E5003B97
       E7003B95E600398AE10043AAEB0048C3F40048B6F2004191E3003568CF003768
       D0003768CF003768CF00396DD200459AE70046A2EA0045A6EC003981DC003075
-      D7003578D8000E4ABF00A289D80000000000000000000000000062949A0079BD
-      C50079BCC40079BEC60085DAE4008BEBF2008CEFF30085E3EA007CD1DD007DD3
+      D7003578D800072A9F006148970000000000000000000000000021535900599D
+      A50079BCC40079BEC60085DAE4008BEBF2008CEFF30085E3EA007CD1DD007DD3
       DF007DD2DE007CCDD80084DCE4008AE8F1008AE2EE0083D1DB0077B9C10079BA
       C20079BAC10079B9C1007ABCC40086D5DF0088D9E30086DBE6007AC8D10072C1
-      CB0075C3CC0048A4AC00CCCCCC0000000000000000000000000035BA00004CD6
-      50004CD650004CD753005AE89D005FF3CB0062F5CF005AEEB00050E38A0050E4
+      CB0075C3CC0028848C008B8B8B000000000000000000000000000287000033BD
+      37004CD650004CD753005AE89D005FF3CB0062F5CF005AEEB00050E38A0050E4
       8F0050E48B0050E17C0057EA9E005FF1C8005FEEBC0057E3840048D44C004CD4
       4C004CD44C004CD448004CD650005AE68F005DE89B005AE9A2004CDE6D0043D9
-      5D0048DA5F0000C62B00B3E05F00000000000000000000000000000000000000
+      5D0048DA5F0000AD160080AD2C00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000000000005E4BBB002862
-      CD003971D4003973D6003D8DE1004BD0F5004DD6F6004DD7F70041ABED003D9E
+      00000000000000000000000000000000000000000000000000001D0A7A001442
+      AD003971D4003973D6003D8DE1004BD0F5004DD6F6004DD7F70041ABED003D9E
       EA003D9EEA003B92E50045B2ED004BCDF5004BBDF3004397E600396BD100396C
       D100396BD1003967CF003F83DD0048A7EC0048A7EC004399E6003573D5003577
-      D8003577D8002137B000000000000000000000000000000000009CA6A70069B5
-      BE007CBFC7007CC0C90080CFD8008CEDF2008FEFF3008FF0F40083DDE8007ED7
+      D8001B57B80000006F00000000000000000000000000000000005B6566004995
+      9E007CBFC7007CC0C90080CFD8008CEDF2008FEFF3008FF0F40083DDE8007ED7
       E40080D7E3007DD1DD0086E0E7008CECF2008CE5F00085D4DE007ABBC3007ABC
       C3007ABBC3007AB9C10081C9D2008ADCE6008ADCE60085D5DF0077C0C90075C2
-      CB0077C2CB0062949B000000000000000000000000000000000074C700003DD1
-      430050D8570050D85A0053E17A0062F4CB0064F6D10064F6D50057EAA80053E7
+      CB0057A2AB0021535A00000000000000000000000000000000004194000024B8
+      2A0050D8570050D85A0053E17A0062F4CB0064F6D10064F6D50057EAA80053E7
       9C0053E79A0050E38A005AEDA70062F3CB0062EFC4005AE58C004CD54C004CD6
       50004CD54C004CD3480053DE6E005FE9A3005FE9A3005AE68D0048D85A0048DA
-      5F0048DA5F0035BA000000000000000000000000000000000000000000000000
+      5F002FC146000287000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000B59ADF000E3D
-      B7003D7AD8003D7AD8003D7FDC0048B2ED0050DBF80053DEF90045B9F1003DA4
+      000000000000000000000000000000000000000000000000000074599E00071F
+      97003D7AD8003D7AD8003D7FDC0048B2ED0050DBF80053DEF90045B9F1003DA4
       ED003FA4EC003D98E80046B6EE004FD2F5004DC5F400459CE700396ED2003B6F
       D2003B6ED200396BD0004182DC004BABED0048A4EA003B7BD9003773D500397A
-      D9001E5DCA007359C20000000000000000000000000000000000D7D5D500489A
-      A2007EC4CD007EC4CD007EC7D10089E0E70091F1F60093F3F70086E3ED0080DA
+      D9000F3DAA00321881000000000000000000000000000000000096949400287A
+      82007EC4CD007EC4CD007EC7D10089E0E70091F1F60093F3F70086E3ED0080DA
       E70081DAE60080D4E10088E2E90090EEF2008FE8F10086D6E0007CBDC4007DBE
       C5007DBDC4007CBBC20083C9D1008CDDE8008ADAE4007DC4CD0079C0C9007AC4
-      CD005DB2BB00ACAFB100000000000000000000000000000000000000000000BE
-      000053DB620053DB620053DD6D005DEDA70066F7D90069F8DF005AEEBA0053E8
+      CD003D929B006B6E70000000000000000000000000000000000000000000008B
+      00003AC2490053DB620053DD6D005DEDA70066F7D90069F8DF005AEEBA0053E8
       A70053E8A30053E594005DEEAD0066F5CE0064F1C8005AE6920050D6500050D7
       500050D6500050D54C0057DE6D0062EBA8005FE89D0050DB62004CD85A004CDB
-      62002BCF3D0088CD2B0000000000000000000000000000000000000000000000
+      620016B62400559A000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000005645
-      B8002870D5003D85DE003B8BE1003B97E60045BCF10048C6F5003FB3F1003DB1
+      0000000000000000000000000000000000000000000000000000000000001504
+      77001450B5003D85DE003B8BE1003B97E60045BCF10048C6F5003FB3F1003DB1
       F1003DAEF0003DA4EC0045BCF1004DD7F6004BD0F50043A7EA003976D7003977
       D7003976D7003976D7003976D7003D84DD003B7EDA003978D700377CDA003581
-      DC001E37B100D4C0EC00000000000000000000000000000000000000000096A1
-      A30069BFC8007ECAD3007DCED8007DD4DF0086E5ED0089E9F10081E1ED0080E0
+      DC000F1C91000000000000000000000000000000000000000000000000005560
+      6200499FA8007ECAD3007DCED8007DD4DF0086E5ED0089E9F10081E1ED0080E0
       ED0080DFEB007EDAE60086E5EC008DF0F3008CEDF20085DCE3007AC2CA007CC2
-      CA007CC2CA007CC2CA007CC2CA007ECAD3007DC7CF007AC3CB0079C6CF0077C8
-      D1005A949B000000000000000000000000000000000000000000000000006DC3
-      00003DD8570053DF700050E17A0050E58D005AEFBB005DF2C90053EDBA0053EC
+      CA007CC2CA007CC2CA007CC2CA007ECAD3007DC7CF007AC3CB0079C6CF0057A8
+      B10019535A000000000000000000000000000000000000000000000000003A90
+      000024BF3E0053DF700050E17A0050E58D005AEFBB005DF2C90053EDBA0053EC
       BA0053EBB30053E8A3005AEFB70064F6D10062F4CE005AE99B004CD95D0050DA
-      5D0050D95D0050D95D0050D95D0053DF6E0050DC66004CDA5D004CDC660048DE
-      6B002BBA00000000000000000000000000000000000000000000000000000000
+      5D0050D95D0050D95D0050D95D0053DF6E0050DC66004CDA5D004CDC66002FC5
+      5200008700000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000000000000000000000C8B0
-      E700003BB5003596E5003798E50039A3E90039ABEC0039B4EF0039BCF10039BE
+      000000000000000000000000000000000000000000000000000000000000876F
+      A600001E95003596E5003798E50039A3E90039ABEC0039B4EF0039BCF10039BE
       F20039BAF10039AFEE0041C4F20048DBF70048D8F6003FB5EC003582DD003584
-      DD003583DD003583DD003583DD003581DC003582DD003586DE003790E200005A
-      CA008E71CF000000000000000000000000000000000000000000000000000000
-      00003D99A10077D3DC0079D4DD007AD9E2007ADDE6007AE1EA007CE5ED007CE6
+      DD003583DD003583DD003583DD003581DC003582DD003586DE003790E200003A
+      AA004D308E000000000000000000000000000000000000000000000000000000
+      00000058600057B3BC0079D4DD007AD9E2007ADDE6007AE1EA007CE5ED007CE6
       EE007CE4EC007ADFE80083E8EE0089F1F50089F0F30081E1E70075C9D20077CA
-      D30077C9D20077C9D20077C9D20077C8D10077C9D20075CBD40079D0D9002BB0
-      BA00BFBFC0000000000000000000000000000000000000000000000000000000
-      000000BE000048E486004CE589004CE897004CEBA3004CEDB10050EFBB0050F0
+      D30077C9D20077C9D20077C9D20077C8D10077C9D20075CBD40079D0D9001690
+      9A007E7E7F000000000000000000000000000000000000000000000000000000
+      0000008B00002FCB6D004CE589004CE897004CEBA3004CEDB10050EFBB0050F0
       BC0050EFB7004CECAA0057F1BC005DF7D7005DF6D10053EDA60048DE6E0048DF
-      6E0048DE6E0048DE6E0048DE6E0048DE6B0048DE6D0048DF72004CE2800000CE
-      3D00A2D848000000000000000000000000000000000000000000000000000000
+      6E0048DE6E0048DE6E0048DE6E0048DE6B0048DE6D0048DF72004CE2800000B5
+      24006FA515000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000997BD2000057C80030ABEC0032ABEB0032B2EE0032BAF00035BEF10035BF
+      0000583A91000037A80030ABEC0032ABEB0032B2EE0032BAF00035BEF10035BF
       F10032BCF00030B3EE0039C8F2003FDEF8003FDCF70039BDF0003091E3003092
-      E4003092E3003092E3003092E3003092E3003092E400309CE7000E79D900574A
-      BA00000000000000000000000000000000000000000000000000000000000000
-      0000C6C4C40000AFB70072DDE60074DDE50074E0E80074E4EB0075E6EC0075E6
+      E4003092E3003092E3003092E3003092E3003092E400309CE7000759B9001609
+      7900000000000000000000000000000000000000000000000000000000000000
+      000085838300008F970072DDE60074DDE50074E0E80074E4EB0075E6EC0075E6
       ED0074E5EB0072E1E8007CEAEF0081F3F60081F2F5007AE5EB0072D0DB0072D1
-      DC0072D1DB0072D1DB0072D1DB0072D1DB0072D1DC0072D6E00043C3CE0097A4
-      A600000000000000000000000000000000000000000000000000000000000000
-      0000ABDB500000CD3D0043EAA30048EAA00048EDAA0048EEB20048F0B70048F0
+      DC0072D1DB0072D1DB0072D1DB0072D1DB0072D1DC0072D6E00023A3AE005663
+      6500000000000000000000000000000000000000000000000000000000000000
+      000078A81D0000B4240043EAA30048EAA00048EDAA0048EEB20048F0B70048F0
       B90048EFB50043EDAA0050F2C10053F8D90053F7D8004CEFB30043E3830043E3
-      850043E3840043E3840043E3840043E3840043E3850043E6920000DA64006EC6
+      850043E3840043E3840043E3840043E3840043E3850043E6920000C14B003B93
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000008768CA000062CF0028B9F1002BB7F0002BB9F0002BBCF1002BBC
+      000000000000462789000042AF0028B9F1002BB7F0002BB9F0002BBCF1002BBC
       F1002BBAF1002BB5EF002DC1F20035E0F90035DFF9002DBAF0002BA0EA002BA2
-      EA002BA2EA0028A2EA0028A2EA002BA2EA002BADEE000083DF004841B6000000
+      EA002BA2EA0028A2EA0028A2EA002BA2EA002BADEE000063BF00070075000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000BAB9B90000B6C00069E3ED006BE2EB006BE3EB006DE5ED006DE5
+      000000000000797878000096A00069E3ED006BE2EB006BE3EB006DE5ED006DE5
       ED006DE4EC006BE1EA006EE7EE0077F3F70075F3F7006EE4EC006BD8E3006BD9
-      E4006BD9E40069D9E40069D9E4006BD9E4006DDEE9002BC9D500899EA2000000
+      E4006BD9E40069D9E40069D9E4006BD9E4006DDEE90016A9B500485D61000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000009BD43D0000D248003DEEBA003DEEB3003DEEB5003DEFB9003DEF
+      00000000000068A10A0000B92F0024D5A1003DEEB3003DEEB5003DEFB9003DEF
       BA003DEFB7003DEDB10043F1BE0048F8DF0048F8DF0043EFB6003DE89B003DE8
-      9D003DE89D003DE89D003DE89D003DE89D003DEBAD0000DE74005DC100000000
+      9D003DE89D003DE89D003DE89D003DE89D003DEBAD0000C55B002A8E00000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000009275CF00005CCB000EB9F20021C6F60021BFF30021BE
+      0000000000000000000051348E00003CAB000799D20021C6F60021BFF30021BE
       F30021BDF30021BCF20021B8F10021C3F40025C3F30021B2F00021B1F00021B1
-      F00021B1F00021B1F00021B6F2001ABAF300007ADB005A4DBC00000000000000
+      F00021B1F00021B1F00021B6F2001ABAF300005ABB00190C7B00000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000C2C1C10000B1BB0048E3EE005FE9F3005FE6EF005FE6
+      000000000000000000008180800000919B0028C3CE005FE9F3005FE6EF005FE6
       EF005FE5EF005FE4EE005FE3ED0062E8F10064E8F0005FE0EB005FE0EB005FE0
-      EB005FE0EB005FE0EB005FE2EE0057E4F00000C4CF009AA7AA00000000000000
+      EB005FE0EB005FE0EB005FE2EE0037C4D00000A4AF0059666900000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000A6D94C0000CF3D0000EEBE002BF2CF002BF0C3002BF0
+      0000000000000000000073A61900009C0A0000D5A5002BF2CF002BF0C3002BF0
       C2002BEFC2002BEFBF002BEEBB0035F1C70035F1C6002BEDB5002BECB5002BEC
-      B5002BECB5002BECB5002BEEBC002BEFC40000DB690072C82B00000000000000
+      B5002BECB5002BECB5002BEEBC0016D6AB0000C250003F950000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000B99CDF00324FC000008EE30000C6F70015CF
+      0000000000000000000000000000785B9E00000E7F00006EC30000A6D70015CF
       F90015C8F70015C4F60015C2F50015BEF50015BDF50015BFF50015BFF50015C1
-      F60015C6F8000EC8F80000A1EB000E59CA008D71CE0000000000000000000000
+      F60015C6F80007A8D8000081CB000739AA004C308D0000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000DAD6D60074A8AE0000CFDA0035E9F40050ED
+      00000000000000000000000000009995950033676D0000AFBA001BC9D40050ED
       F80050EAF50050E8F30050E7F20050E6F20050E5F10050E6F20050E6F20050E7
-      F30050E9F60048E9F60000D8E50043AFB900BFBFBF0000000000000000000000
+      F30050E9F60028C9D60000B8C500026E78007E7E7E0000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000048C82B0000E2810000F2D50000F4
-      E30000F2D70000F1D00000F1CE0000F0CB0000EFC90000F0CB0000F0CC0000F1
-      D00000F2D90000F2DB0000E8A00000CD3D00A1D8480000000000000000000000
+      0000000000000000000000000000000000001595000000C9680000D9BC0000DB
+      CA0000F2D70000F1D00000F1CE0000F0CB0000EFC90000F0CB0000F0CC0000F1
+      D00000F2D90000D9C20000CF8700009A0A006EA5150000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000009A7DD4003056C400007F
-      DD0000AEF00000C8F80000D0FB0000D2FB0000D2FB0000D0FB0000CAF90000B7
-      F300008FE500155DCB007663C800DAC3ED000000000000000000000000000000
+      00000000000000000000000000000000000000000000593C930000158300005F
+      BD00008ED00000A8D80000B0DB0000B2DB0000B2DB0000B0DB0000AAD9000097
+      D300006FC500001C8A0035228700000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000C7C6C60072ADB30000C7
-      D20000DFEB0000E9F60000EDFA0000EEFB0000EEFB0000EDFA0000EBF80000E2
-      EF0000CFDC004CB2BB00AFB7B800000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000086858500316C720000A7
+      B20000BFCB0000C9D60000CDDA0000CEDB0000CEDB0000CDDA0000CBD80000C2
+      CF0000AFBC000B717A006E767700000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000000000000000000000000ACDC530043CC350000DD
-      6E0000EBB20000F2DC0000F4EB0000F5EF0000F5EF0000F4ED0000F3E10000EE
-      C20000E2860000CF3D008BD23D00000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000079A920001099020000AA
+      3B0000D2990000D9C30000DBD20000DCD60000DCD60000DBD40000DAC80000D5
+      A90000C96D00009C0A00589F0A00000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000000000000000000000BC9F
-      E000816FCF004D61CA002862CD00156BD2000E6BD2001E66CF003F5FCA006E68
-      CB00A78BD9000000000000000000000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000000000000000000007B5E
+      9F00402E8E000C20890000218C00002A9100002A910000258E00001E89002D27
+      8A00664A98000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000000000000000000000000000000000000000DBD8
-      D700B6BEC0008FB5BA0066B6BF004CBBC40048BBC5005DB8C10081B4BB00A9B9
-      BC00CFCECE000000000000000000000000000000000000000000000000000000
+      0000000000000000000000000000000000000000000000000000000000009A97
+      9600757D7F004E74790025757E000B7A8300077A84001C77800040737A006878
+      7B008E8D8D000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
-      000095D7480064D13D0035D2480000D5500000D550002BD34C0053D03D0084D4
-      4300B7E164000000000000000000000000000000000000000000000000000000
+      000062A41500319E0A00029F150000A21D0000A21D0000A01900209D0A0051A1
+      100084AE31000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
       0000000000000000000000000000000000000000000000000000000000000000
@@ -3134,21 +3138,21 @@
       000000000000000000000000000000000000424D3E000000000000003E000000
       2800000080000000200000000100010000000000000200000000000000000000
       000000000000000000000000FFFFFF00FFFFFFFFFFFFFFFFFFFFFFFF00000000
-      FFF00FFFFFF80FFFFFF81FFF00000000FF8001FFFFC001FFFFC003FF00000000
-      FF00007FFF0000FFFF0000FF00000000FC00003FFE00003FFE00003F00000000
-      F800001FF800001FFC00001F00000000F000000FF800000FF800000F00000000
+      FFF80FFFFFF80FFFFFF81FFF00000000FFC001FFFFC001FFFFC003FF00000000
+      FF00007FFF0000FFFF0000FF00000000FE00003FFE00003FFE00003F00000000
+      FC00001FF800001FFC00001F00000000F800000FF800000FF800000F00000000
       F0000007F0000007F000000F00000000E0000007E0000007E000000700000000
-      C0000003E0000003E000000300000000C0000003C0000003C000000300000000
-      C0000001C0000001C00000030000000080000001C0000001C000000100000000
+      E0000003E0000003E000000300000000C0000003C0000003C000000300000000
+      C0000001C0000001C000000300000000C0000001C0000001C000000100000000
       8000000180000001800000010000000080000001800000018000000100000000
       8000000180000001800000010000000080000001800000018000000100000000
       8000000180000001800000010000000080000001800000018000000100000000
       8000000180000001C000000100000000C0000001C0000001C000000100000000
       C0000003C0000003C000000300000000C0000003C0000003E000000300000000
-      E0000003E0000007E000000700000000E0000007F0000007F000000700000000
+      E0000007E0000007E000000700000000E0000007F0000007F000000700000000
       F000000FF000000FF000000F00000000F800001FF800001FF800001F00000000
       FC00003FFC00003FFC00003F00000000FE00007FFE00007FFF00007F00000000
-      FF8000FFFF8001FFFF8001FF00000000FFE007FFFFE007FFFFF007FF00000000
+      FF8001FFFF8001FFFF8001FF00000000FFE007FFFFE007FFFFF007FF00000000
       FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000
       000000000000}
   end
@@ -3187,6 +3191,7 @@
     Top = 168
   end
   object KeepAliveTimer: TTimer
+    Enabled = False
     OnTimer = KeepAliveTimerTimer
     Left = 256
     Top = 168
@@ -6531,6 +6536,10 @@
       FontSettings.Bold = tsTrue
       OnClick = mnuHelpClick
     end
+    object mnuTips: TSpTBXItem
+      Caption = 'Tips'
+      OnClick = mnuTipsClick
+    end
     object mnuForceLobbyUpdateCheck: TSpTBXItem
       Caption = 'Check for Lobby Update'
       OnClick = mnuForceLobbyUpdateCheckClick
@@ -6865,6 +6874,7 @@
       000000000000}
   end
   object HighlighBattlesTimer: TTimer
+    Enabled = False
     OnTimer = HighlighBattlesTimerTimer
     Left = 148
     Top = 166
@@ -7067,8 +7077,10 @@
   end
   object PyEngine: TAtomPythonEngine
     AutoLoad = False
+    AutoUnload = False
     FatalAbort = False
     FatalMsgDlg = False
+    AutoFinalize = False
     IO = PyInOut
     PyFlags = [pfDebug]
     Left = 452

Modified: branches/0.77-branch/Lobby/TASClient/MainUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/MainUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/MainUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -206,7 +206,8 @@
   TBX, SpTBXControls, TBXDkPanels, SpTBXFormPopupMenu,IniFiles,StrUtils,
   TntStdCtrls, SpTBXEditors, Mask, JvExMask, JvSpin,TntComCtrls,JclUnicode,
   GR32_Image, SpTBXTabs, PythonEngine, AtomPythonEngine,VarPyth, PythonGUIInputOutput,
-  WrapDelphi,RichEdit2, ExRichEdit, JvComponentBase, JvMTComponents, class_TIntegerList;
+  WrapDelphi,RichEdit2, ExRichEdit, JvComponentBase, JvMTComponents, class_TIntegerList,
+  TntGraphics;
 
 const
   CountryNames: array[0..240] of string = (
@@ -489,6 +490,7 @@
     BotText: TColor; // bot text color in battle client list
     MyText: TColor; // my chat text color
     AdminText: TColor;
+    OldMsgs: TColor;
   end;
 
   TTeamColors = array[0..19] of TColor;
@@ -522,7 +524,7 @@
 const
   VERSION_NUMBER = '0.38'; // Must be float value! (with a period as a decimal seperator)
   CHECK_BETA_LOBBY_URL = '<A HREF="http://tasclient.no-ip.org/TASClient_update_v2.txt">http://tasclient.no-ip.org/TASClient_update_v2.txt</A>';
-  PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER + ' RC13';
+  PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER + ' RC24';
   KEEP_ALIVE_INTERVAL = 10000; // in milliseconds. Tells us what should be the maximum &quot;silence&quot; time before we send a ping to the server.
   ASSUME_TIMEOUT_INTERVAL = 30000; // in milliseconds. Must be greater than KEEP_ALIVE_INTERVAL! If server hasn't send any data to us within this interval, then we assume timeout occured. It's us who must make sure we get constant replies from server by pinging it.
   LOCAL_TAB = '$Local'; // caption of main (command) tab window. Must be special so that is different from channel names or user names, that is why there is a &quot;$&quot; in front of it.
@@ -640,14 +642,12 @@
     LogFile: TFileStream;
     constructor Create(AOwner: TComponent); override;
     destructor Destroy; override;
-  protected
-    procedure WndProc(var Msg: TMessage); override;
   end;
 
   TClient = class
   public
 
-    Name: string; // client's username
+    Name: WideString; // client's username
     RecentNames: string; // use for modos with FINDIP
     FStatus: Integer; // client's status (normal, in game)
     FBattleStatus: Integer; // only used for clients participating in the same battle as the player
@@ -669,7 +669,7 @@
     AutoKickMsgSent : integer;
     AutoSpecMsgSent : integer;
 
-    constructor Create(Name: string; Status: Integer; Country: string; CPU: Integer);
+    constructor Create(Name: WideString; Status: Integer; Country: string; CPU: Integer);
 
     function GetChatTextColor: TColor;
 
@@ -770,13 +770,14 @@
   private
     dlBeta: boolean;
     autoUpdt: boolean;
-    delay: integer; 
+    delay: integer;
+    forceUpt: boolean; 
 
   protected
     procedure Execute; override;
 
   public
-    constructor Create(Suspended: Boolean;downloadBeta: boolean; autoUpdate: boolean; delayed : integer = 0);
+    constructor Create(Suspended: Boolean;downloadBeta: boolean; autoUpdate: boolean; delayed : integer = 0; forceUpdate: boolean = False);
   end;
 
   TLadder = class
@@ -968,6 +969,10 @@
     NotifyOnBattleEnd : boolean;
     NotifyOnConnect : boolean;
     HighlightBattles : boolean;
+    EnableChatColor : boolean;
+    ChatColor : integer;
+    ReplaceRank: boolean;
+    Rank: integer;
 
     constructor Create(Name: string; Color: Integer);
     destructor Destroy;
@@ -1020,17 +1025,6 @@
     Clearwindow1: TSpTBXItem;
     Copy1: TSpTBXItem;
     SpTBXSeparatorItem9: TSpTBXSeparatorItem;
-    Panel1: TSpTBXPanel;
-    Panel3: TPanel;
-    Panel4: TSpTBXPanel;
-    OptionsSpeedButton: TSpTBXSpeedButton;
-    BattleScreenSpeedButton: TSpTBXSpeedButton;
-    HelpButton: TSpTBXSpeedButton;
-    ReplaysButton: TSpTBXSpeedButton;
-    SearchButton: TSpTBXSpeedButton;
-    ConnectButton: TTBXButton;
-    PageControl1: TPageControl;
-    Bevel2: TBevel;
     SpTBXSeparatorItem11: TSpTBXSeparatorItem;
     mnuIgnore: TSpTBXItem;
     ArrowList: TImageList;
@@ -1081,21 +1075,36 @@
     btSearchPlayer: TSpTBXSpeedButton;
     SearchPlayerFormPopupMenu: TSpTBXFormPopupMenu;
     mnuQuickJoinPanel: TSpTBXItem;
+    Splitter1: TSpTBXSplitter;
+    SpTBXItem4: TSpTBXItem;
+    HttpCli3: THttpCli;
+    PyEngine: TAtomPythonEngine;
+    lobbyScriptModule: TPythonModule;
+    PyInOut: TPythonInputOutput;
+    SpTBXSeparatorItem15: TSpTBXSeparatorItem;
+    SpTBXSeparatorItem16: TSpTBXSeparatorItem;
+    SpTBXSeparatorItem17: TSpTBXSeparatorItem;
+    SpTBXSeparatorItem18: TSpTBXSeparatorItem;
+    SpTBXSeparatorItem19: TSpTBXSeparatorItem;
+    SpTBXSeparatorItem20: TSpTBXSeparatorItem;
+    SpTBXSeparatorItem21: TSpTBXSeparatorItem;
+    lobbyscriptWrapper: TPyDelphiWrapper;
+    mnuDisableNotifications: TSpTBXItem;
+    mnuTips: TSpTBXItem;
+    ClientsListBox: TTntListBox;
+    Panel1: TSpTBXPanel;
+    Panel3: TPanel;
     BattlesPanel: TSpTBXPanel;
     QuickJoinPanel: TSpTBXPanel;
     SpTBXLabel1: TSpTBXLabel;
     btSpecatateNow: TSpTBXButton;
     btPlayNow: TSpTBXButton;
+    SpTBXLabel2: TSpTBXLabel;
     VDTBattles: TVirtualDrawTree;
-    SpTBXLabel2: TSpTBXLabel;
-    Splitter2: TSpTBXSplitter;
-    Splitter1: TSpTBXSplitter;
-    SpTBXItem4: TSpTBXItem;
     FilterGroup: TSpTBXPanel;
     FiltersTabs: TSpTBXTabControl;
     SpTBXTabItem1: TSpTBXTabItem;
     SpTBXTabItem2: TSpTBXTabItem;
-    SpTBXTabSheet2: TSpTBXTabSheet;
     SpTBXTabSheet1: TSpTBXTabSheet;
     FilterList: TVirtualStringTree;
     ClearFilterListButton: TSpTBXButton;
@@ -1122,40 +1131,39 @@
     MaxPlayersValueTextBox: TJvSpinEdit;
     MaxPlayersFilter: TSpTBXCheckBox;
     PlayersFilter: TSpTBXCheckBox;
-    EnableFilters: TSpTBXCheckBox;
-    FiltersButton: TSpTBXButton;
+    SpTBXTabSheet2: TSpTBXTabSheet;
     PresetListbox: TSpTBXListBox;
     SpTBXLabel3: TSpTBXLabel;
     SpTBXGroupBox1: TSpTBXGroupBox;
-    btClearPreset: TSpTBXButton;
     btDeletePreset: TSpTBXButton;
     btSavePreset: TSpTBXButton;
     PresetNameTextbox: TSpTBXEdit;
+    btClearPreset: TSpTBXButton;
+    EnableFilters: TSpTBXCheckBox;
+    FiltersButton: TSpTBXButton;
+    Splitter2: TSpTBXSplitter;
+    PageControl1: TPageControl;
+    Panel4: TSpTBXPanel;
+    OptionsSpeedButton: TSpTBXSpeedButton;
+    BattleScreenSpeedButton: TSpTBXSpeedButton;
+    HelpButton: TSpTBXSpeedButton;
+    ReplaysButton: TSpTBXSpeedButton;
+    SearchButton: TSpTBXSpeedButton;
+    ConnectButton: TTBXButton;
     SinglePlayerButton: TSpTBXButton;
-    HttpCli3: THttpCli;
-    PyEngine: TAtomPythonEngine;
-    lobbyScriptModule: TPythonModule;
-    PyInOut: TPythonInputOutput;
-    SpTBXSeparatorItem15: TSpTBXSeparatorItem;
-    SpTBXSeparatorItem16: TSpTBXSeparatorItem;
-    SpTBXSeparatorItem17: TSpTBXSeparatorItem;
-    SpTBXSeparatorItem18: TSpTBXSeparatorItem;
-    SpTBXSeparatorItem19: TSpTBXSeparatorItem;
-    SpTBXSeparatorItem20: TSpTBXSeparatorItem;
-    SpTBXSeparatorItem21: TSpTBXSeparatorItem;
-    lobbyscriptWrapper: TPyDelphiWrapper;
+    Bevel2: TBevel;
     BotImage: TImage;
     DefaultArmImage: TImage;
     DefaultSideImage: TImage;
     DefaultCoreImage: TImage;
-    mnuDisableNotifications: TSpTBXItem;
     procedure mnuOpenPrivateChatClick(Sender: TObject);
     procedure mnuSelectBattleClick(Sender: TObject);
     procedure SpTBXItem1Click(Sender: TObject);
     procedure mnuManageGroupsClick(Sender: TObject);
     procedure mnuNewGroupClick(Sender: TObject);
     procedure AddToGroupItemClick(Sender: TObject);
-    procedure RefreshClientSort;
+    procedure ResortClientsLists;
+    procedure SortClientInLists(client: TClient);
     procedure ClientsListBoxClick(Sender: TObject);
     procedure mnuRemoveFromGroupClick(Sender: TObject);
     procedure mnuHelpClick(Sender: TObject);
@@ -1278,13 +1286,13 @@
     procedure lobbyscriptWrapperInitialization(Sender: TObject);
     procedure Button1Click(Sender: TObject);
     procedure RichEditURLClick(Sender: TObject; URL: String);
+    procedure mnuTipsClick(Sender: TObject);
   published
     MainTitleBar: TSpTBXTitleBar;
     Panel2: TSpTBXPanel;
     Bevel1: TBevel;
     PlayersLabel: TSpTBXLabel;
     SortLabel: TLabel;
-    ClientsListBox: TListBox;
     ButtonImageList: TImageList;
     PlayerStateImageList: TImageList;
     ConnectionStateImageList: TImageList;
@@ -1354,10 +1362,10 @@
     procedure ProcessCommand(s: WideString; CameFromBattleScreen: Boolean);
     procedure ProcessRemoteCommand(s: WideString); // processes command received from server
     procedure TryToCloseTab(TabSheet: TMyTabSheet);
-    procedure OpenPrivateChat(ClientName: string);
+    procedure OpenPrivateChat(ClientName: WideString);
 
-    function AddClientToTab(ClientList: TList; ClientName: string): Boolean;
-    function RemoveClientFromTab(Tab: TMyTabSheet; ClientName: string): Boolean;
+    function AddClientToTab(ClientList: TList; ClientName: WideString): Boolean;
+    function RemoveClientFromTab(Tab: TMyTabSheet; ClientName: WideString): Boolean;
     procedure RemoveAllClientsFromTab(Tab: TMyTabSheet);
     procedure UpdateClientsListBox;
 
@@ -1371,11 +1379,11 @@
 
     procedure ClearAllClientsList;
     procedure ClearClientsLists; // clears all clients list (in channels, private chats, battle, local tab, ...)
-    procedure AddClientToAllClientsList(Name: string; Status2: Integer; Country: string; CPU: Integer);
+    procedure AddClientToAllClientsList(Name: WideString; Status2: Integer; Country: string; CPU: Integer);
     function RemoveClientFromAllClientsList(Name: string): Boolean;
-    function GetClient(Name: string): TClient; // returns nil if not found
+    function GetClient(Name: WideString): TClient; // returns nil if not found
     function GetClientByIP(IP: string): TClient; // returns nil if not found
-    function GetClientIndexEx(Name: string; ClientList: TList): Integer;
+    function GetClientIndexEx(Name: WideString; ClientList: TList): Integer;
 
     function GetGroup(Name: string): TClientGroup; // returns nil if not found
 
@@ -1506,7 +1514,7 @@
     Key: Word; // unique ping packet ID (we use it to identify the packet so we don't mingle it with other ping packets if more were sent at the same time)
   end;
 var
-  Colors: TColors = (Normal:clBlack; Data: clGreen; Error:clRed; Info:clBlue; MinorInfo: clNavy; ChanJoin: clGreen; ChanLeft: clNavy; MOTD: clMaroon; SayEx: clPurple; Topic: clMaroon; ClientAway: $009F9F9F; MapModUnavailable: $00ed00d5;BotText:clGray; MyText: $0092726e;AdminText: $000366A3 );
+  Colors: TColors = (Normal:clBlack; Data: clGreen; Error:clRed; Info:clBlue; MinorInfo: clNavy; ChanJoin: clGreen; ChanLeft: clNavy; MOTD: clMaroon; SayEx: clPurple; Topic: clMaroon; ClientAway: $009F9F9F; MapModUnavailable: $00ed00d5;BotText:clGray; MyText: $0092726e;AdminText: $000366A3; OldMsgs: $00c3c3c3 );
   Debug:
   record
     Enabled: Boolean; // show some debugging information
@@ -1544,7 +1552,7 @@
     MyRank: Byte;
     TimeOfLastDataSent: LongWord; // the time when we sent last string to the server. We need to know this so that we know if we must ping server if time of last data sent was some time ago (otherwise server will disconnect us due to timeout!)
     TimeOfLastDataReceived: LongWord; // the time when we received last data from server. If this time get's too high, we assume that connection to server has been lost. Nevertheless, it's us who must keep constant connection to server by pinging it!
-    Username: string; // my username
+    Username: WideString; // my username
     Me: TClient; // reference to myself in TClient from AllClients list. Note: This reference will only become valid once we received ADDUSER command containing our username, not before! - Status.Username property gets assigned earlier (when we received ACCEPTED command from the server)
     AwayTime: Cardinal; // not a &quot;period&quot; of time, but the GetTickCount value (taken when application lost focus the last time)
     CurrentAwayItem: integer; // current away message : -1 = default away, -2 = available
@@ -1627,7 +1635,7 @@
   CommandQueueTail: Integer = 0;
 
   SelectedBattle: TBattle;
-  SelectedUserName: string;
+  SelectedUserName: WideString;
   RichEditSelectedClient: TClient;
 
   LastBoundTo: integer;
@@ -1664,7 +1672,8 @@
   LoginProgressFormUnit, GpIFF, SearchFormUnit, ManageGroups, ColorPicker,
   AwayMessageFormUnit,JclStrings, SearchPlayerFormUnit, MenuFormUnit, Utility,
   PythonScriptDebugFormUnit,LobbyScriptUnit, SpringDownloaderFormUnit,
-  SyncObjs, LogonFormUnit, MapSelectionFormUnit;
+  SyncObjs, LogonFormUnit, MapSelectionFormUnit, TipsFormUnit,
+  ColorsPreferenceUnit;
 
 {$R *.dfm}
 
@@ -2027,7 +2036,7 @@
       FileClose(fh);
     end;
 
-    Result := TFileStream.Create(FileName, fmOpenWrite or fmShareDenyWrite);
+    Result := TFileStream.Create(FileName, fmOpenReadWrite or fmShareDenyWrite);
     Result.Position := Result.Size;
     TryToAddLog(Result, '');
     TryToAddLog(Result, 'Logging started on ' + FormatDateTime('ddd mmm dd hh:nn:ss yyyy', Now));
@@ -2205,7 +2214,7 @@
   UpdateClientsListBox;
 end;
 
-procedure TMainForm.AddClientToAllClientsList(Name: string; Status2: Integer; Country: string; CPU: Integer);
+procedure TMainForm.AddClientToAllClientsList(Name: WideString; Status2: Integer; Country: string; CPU: Integer);
 var
   Client: TClient;
   i: integer;
@@ -2251,7 +2260,7 @@
     end;
 end;
 
-function TMainForm.GetClient(Name: string): TClient;
+function TMainForm.GetClient(Name: WideString): TClient;
 var
   i: Integer;
 begin
@@ -2291,7 +2300,7 @@
   Result := nil;
 end;
 
-function TMainForm.GetClientIndexEx(Name: string; ClientList: TList): Integer;
+function TMainForm.GetClientIndexEx(Name: WideString; ClientList: TList): Integer;
 var
   i: Integer;
 begin
@@ -2378,7 +2387,7 @@
 
 { TClient }
 
-constructor TClient.Create(Name: string; Status: Integer; Country: string; CPU: Integer);
+constructor TClient.Create(Name: WideString; Status: Integer; Country: string; CPU: Integer);
 begin
   Self.Name := Name;
   Self.Status := Status;
@@ -2395,14 +2404,21 @@
 end;
 
 function TClient.GetChatTextColor: TColor;
+var
+  g : integer;
 begin
   if Self.Name = MainUnit.Status.Username then
     Result := Colors.MyText
   else
-    if Self.GetAccess then
+  begin
+    g := Self.GetGroup;
+    if (g &gt; -1) and TClientGroup(ClientGroups[g]).EnableChatColor then
+      Result := TClientGroup(ClientGroups[g]).ChatColor
+    else if Self.GetAccess then
       Result := Colors.AdminText
     else
       Result := Colors.Normal;
+  end;
 end;
 
 function TClient.isComSharing: Boolean;
@@ -2558,8 +2574,14 @@
 end;
 
 function TClient.GetRank: Integer;
+var
+  g: integer;
 begin
   Result := (Status and $1C) shr 2;
+  g := Self.GetGroup;
+  if g &gt; -1 then
+    if TClientGroup(ClientGroups[g]).ReplaceRank then
+      Result := TClientGroup(ClientGroups[g]).Rank;
 end;
 
 function TClient.GetAccess: Boolean;
@@ -2756,7 +2778,7 @@
 function TBattle.AreAllBotsSet: Boolean;
 var
   i: Integer;
-  TeamNo: array[0..9] of Boolean;
+  TeamNo: array[0..15] of Boolean;
 begin
   Result := False;
 
@@ -3376,33 +3398,6 @@
   inherited Destroy;
 end;
 
-procedure TMyTabSheet.WndProc(var Msg: TMessage);
-var
-  p: TENLink;
-  sURL: string;
-  CE : TExRichEdit;
-begin
-  if (Msg.Msg = WM_NOTIFY) then
-  begin
-    if (PNMHDR(Msg.lParam).code = EN_LINK) then
-    begin
-      p := TENLink(Pointer(TWMNotify(Msg).NMHdr)^);
-      if (p.Msg = WM_LBUTTONDOWN) then
-      begin
-        try
-          CE := TExRichEdit(Self.Controls[1] as TExRichEdit);
-          SendMessage(CE.Handle, EM_EXSETSEL, 0, Longint(@(p.chrg)));
-          sURL := CE.SelText;
-          Misc.OpenURLInDefaultBrowser(sURL);
-        except
-        end;
-      end;
-    end;
-  end;
-
-  inherited;
-end;
-
 { TMainForm }
 
 procedure TMainForm.ChangeActivePageAndUpdate(PageControl: TPageControl; PageIndex: Integer); // never change ActivePageIndex manually, since it doesn't trigger OnChange event!
@@ -3564,10 +3559,7 @@
     PreferencesForm.ApplyCurrentThemeType;
     PreferencesForm.ApplyCurrentTheme;
 
-    ClientsListBox.Font.Assign(CommonFont);
-    ClientsListBox.ItemHeight := 2*CommonFont.Size ;
-    BattleForm.ChatRichEdit.Font.Assign(CommonFont);
-    BattleForm.InputEdit.Font.Assign(CommonFont);
+    ColorsPreference.ApplyFont;
 
     LoadGroups;
     LoadAwayMessages;
@@ -3721,6 +3713,9 @@
 
     initLobbyScript;
 
+    KeepAliveTimer.Enabled := True;
+    HighlighBattlesTimer.Enabled := True;
+
     // finally:
     if RunningWithMainMenu then
       MenuForm.Show
@@ -3732,6 +3727,8 @@
     if Preferences.EnableSpringDownloader then
       StartSpringDownloader;
    end;
+
+   TipsForm.ShowTips;
 end;
 
 procedure TMainForm.UpdateColorImageList;
@@ -3837,6 +3834,7 @@
   tmped: TTntMemo;
   mask: Word;
   FileName: string;
+  logsLastLines : string;
 begin
   Result := -1;
 
@@ -3848,13 +3846,15 @@
   tmped.Parent := tmpts;
   tmped.Name := 'InputEdit'; // don't change this name! (there are some references to it in the code)
   tmped.Text := '';
-  tmped.Height := 21;
+  tmped.Height := CommonFont.Size*2+5;
+  tmped.HideSelection := False;
   tmped.ScrollBars := ssNone;
   tmped.OnKeyPress := InputEditKeyPress;
   tmped.OnKeyDown := InputEditKeyDown;
   tmped.OnClick := InputEditClick;
   tmped.Font.Assign(CommonFont);
   tmped.Align := alBottom;
+  tmped.WordWrap := False;
 
   tmpts.PageControl := PageControl1;
 
@@ -3887,7 +3887,14 @@
   begin
     FileName := ExtractFilePath(Application.ExeName) + LOG_FOLDER + '\' + tmpts.Caption + '.log';
     tmpts.LogFile := OpenLog(FileName);
-    if tmpts.LogFile = nil then AddMainLog('Error: unable to access file: ' + FileName, Colors.Error);
+    if tmpts.LogFile = nil then
+      AddMainLog('Error: unable to access file: ' + FileName, Colors.Error)
+    else
+    begin
+      logsLastLines := ReadLastLogFileLines(tmpts.LogFile,30);
+      if logsLastLines &lt;&gt; '' then
+        AddTextToRichEdit(tmpre,logsLastLines,Colors.OldMsgs,True,0);
+    end;
   end;
 
   // finally:
@@ -3912,7 +3919,7 @@
     end;
 end;
 
-function TMainForm.AddClientToTab(ClientList: TList; ClientName: string): Boolean; // does not update ClientsListBox!
+function TMainForm.AddClientToTab(ClientList: TList; ClientName: WideString): Boolean; // does not update ClientsListBox!
 var
   c: TClient;
   i: Integer;
@@ -3943,7 +3950,7 @@
   Result := True;
 end;
 
-function TMainForm.RemoveClientFromTab(Tab: TMyTabSheet; ClientName: string): Boolean; // does not update ClientsListBox!
+function TMainForm.RemoveClientFromTab(Tab: TMyTabSheet; ClientName: WideString): Boolean; // does not update ClientsListBox!
 var
   i: Integer;
 begin
@@ -3981,7 +3988,7 @@
     c := AllClients.count;
     if c = 0 then PlayersLabel.Caption := 'Players:' else
       PlayersLabel.Caption := 'Players (' + IntToStr(c) + '):';
-    ClientsListBox.Items.SetText(PChar(CreateStrings(c)));
+    ClientsListBox.Items.SetTextW(PWideChar(WideString(CreateStrings(c))));
   end
   else
   if PageControl1.ActivePage.Caption[1] = '#' then // a channel tab
@@ -3989,14 +3996,14 @@
     c := (PageControl1.ActivePage as TMyTabSheet).Clients.Count;
     if c = 0 then PlayersLabel.Caption := 'Players:' else
       PlayersLabel.Caption := 'Players (' + IntToStr(c) + '):';
-    ClientsListBox.Items.SetText(PChar(CreateStrings(c)));
+    ClientsListBox.Items.SetTextW(PWideChar(WideString(CreateStrings(c))));
   end
   else
   begin // a private chat tab
     c := (PageControl1.ActivePage as TMyTabSheet).Clients.Count;
     if c = 0 then PlayersLabel.Caption := 'Players:' else
       PlayersLabel.Caption := 'Players (' + IntToStr(c) + '):';
-    ClientsListBox.Items.SetText(PChar(CreateStrings(c)));
+    ClientsListBox.Items.SetTextW(PWideChar(WideString(CreateStrings(c))));
   end;
 
 
@@ -4354,6 +4361,14 @@
     begin
       AddNotification('Test', 'This is only a test.', 2000);
     end
+    else if (sl[0] = 'FORCEUPDATE') then
+    begin
+      TLobbyUpdateThread.Create(False,False,True,0,True);
+    end
+    else if (sl[0] = 'FORCEBETAUPDATE') then
+    begin
+      TLobbyUpdateThread.Create(False,True,True,0,True);
+    end
     else if (sl[0] = 'TESTUDP') then
     begin
       i := 5000;
@@ -6684,9 +6699,11 @@
    co, //Character Offset
    k, j: Integer;
    Pt: TPoint;
-   s: string;
-   SelectedNick: string;
+   s: WideString;
+   SelectedWord: WideString;
    SelectedClient: TClient;
+   mapIndex: integer;
+   r: boolean;
 begin
    with TExRichEdit(Sender) do
    begin
@@ -6706,13 +6723,30 @@
      Inc(co) ;
      j := co;
      while (j &lt;= Length(s)) and (s[j] &lt;&gt; ' ') and (s[j] &lt;&gt; '&gt;') do Inc(j) ;
-     SelectedNick := Copy(s, k, j - k) ;
+     SelectedWord := Copy(s, k, j - k) ;
 
-     SelectedClient := GetClient(SelectedNick);
+     AcquireMainThread;
+     try if not Preferences.DisableScripts then r := handlers.onChatDblClick(SelectedWord,Lines[lix]); except end;
+     ReleaseMainThread;
 
+     if r then Exit;
+
+     SelectedClient := GetClient(SelectedWord);
+
      if SelectedClient &lt;&gt; nil then
      begin
-       OpenPrivateChat(SelectedNick);
+       OpenPrivateChat(SelectedWord);
+     end
+     else if RightStr(LowerCase(SelectedWord),4) = '.smf' then
+     begin
+        mapIndex := MapList.IndexOf(SelectedWord);
+        if mapIndex &gt; -1 then
+          if BattleState.Status &lt;&gt; Joined then
+          begin
+            BattleForm.ChangeMap(mapIndex);
+            if BattleState.Status = Hosting then
+              BattleForm.SendBattleInfoToServer;
+          end;
      end;
    end;
 end;
@@ -6826,7 +6860,7 @@
           if ((Sender as TTntMemo).Parent as TMyTabSheet).Caption[1] = '#' then
             TryToSendCommand('SAY',Copy(((Sender as TTntMemo).Parent as TMyTabSheet).Caption, 2, Length(((Sender as TTntMemo).Parent as TMyTabSheet).Caption))+' '+msgLines[i])
           else
-            TryToSendCommand('SAYPRIVATE',((Sender as TTntMemo).Parent as TMyTabSheet).Caption+' '+msgLines[i]);
+            TryToSendCommand('SAYPRIVATE',TClient(((Sender as TTntMemo).Parent as TMyTabSheet).Clients[0]).Name+' '+msgLines[i]);
     end;
   end
   else if Key = VK_UP then
@@ -6885,38 +6919,37 @@
 
     group := TClient(AllClients[Index]).GetGroup;
     if (group &gt; -1) and (ClientsListBox.ItemIndex &lt;&gt; Index) then
-      (Control as TListBox).Canvas.Brush.Color := TClientGroup(ClientGroups[group]).Color;
+      (Control as TTntListBox).Canvas.Brush.Color := TClientGroup(ClientGroups[group]).Color;
       
     // this ensures the correct highlite color is used
-    (Control as TListBox).Canvas.FillRect(Rect);
+    (Control as TTntListBox).Canvas.FillRect(Rect);
 
     xpos := Rect.Left;
-    if odSelected in State then (Control as TListBox).Canvas.Font.Color := clWhite
-    else (Control as TListBox).Canvas.Font.Color := clBlack;
+    if odSelected in State then (Control as TTntListBox).Canvas.Font.Color := clWhite
+    else (Control as TTntListBox).Canvas.Font.Color := clBlack;
 
-    PlayerStateImageList.Draw((Control as TListBox).Canvas, xpos, Rect.Top, TClient(AllClients[Index]).GetStateImageIndex);
+    PlayerStateImageList.Draw((Control as TTntListBox).Canvas, xpos, Rect.Top, TClient(AllClients[Index]).GetStateImageIndex);
     Inc(xpos,PlayerStateImageList.Width+5);
 
     if Preferences.ShowFlags then
     begin
       FlagBitmap := GetFlagBitmap(TClient(AllClients[Index]).Country);
-      (Control as TListBox).Canvas.Draw(xpos, Rect.Top + 16 div 2 - FlagBitmap.Height div 2, FlagBitmap);
+      (Control as TTntListBox).Canvas.Draw(xpos, Rect.Top + 16 div 2 - FlagBitmap.Height div 2, FlagBitmap);
       Inc(xpos, FlagBitmap.Width + 5);
     end;
 
-    (Control as TListBox).Canvas.TextOut(xpos, Rect.Top, TClient(AllClients[Index]).Name);
+    WideCanvasTextOut((Control as TTntListBox).Canvas, xpos, Rect.Top, TClient(AllClients[Index]).Name);
+    Inc(xpos, WideCanvasTextWidth((Control as TTntListBox).Canvas,TClient(AllClients[Index]).Name));
 
-    Inc(xpos, (Control as TListBox).Canvas.TextWidth(TClient(AllClients[Index]).Name));
-
     if TClient(AllClients[Index]).GetAccess then
-      PlayerStateImageList.Draw((Control as TListBox).Canvas, xpos, Rect.Top, 4);
+      PlayerStateImageList.Draw((Control as TTntListBox).Canvas, xpos, Rect.Top, 4);
   end
   else
   begin
     if (Index = 0) and ((PageControl1.ActivePage as TMyTabSheet).Clients.Count = 0) then
     begin // a special case when we must paint first &quot;item&quot; in empty list box:
       // this ensures the correct highlite color is used
-      (Control as TListBox).Canvas.FillRect(Rect);
+      (Control as TTntListBox).Canvas.FillRect(Rect);
       Exit;
     end
     else
@@ -6924,30 +6957,30 @@
 
     group := TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetGroup;
     if (group &gt; -1) and (ClientsListBox.ItemIndex &lt;&gt; Index) then
-      (Control as TListBox).Canvas.Brush.Color := TClientGroup(ClientGroups[group]).Color;
+      (Control as TTntListBox).Canvas.Brush.Color := TClientGroup(ClientGroups[group]).Color;
 
     // this ensures the correct highlite color is used
-    (Control as TListBox).Canvas.FillRect(Rect);
+    (Control as TTntListBox).Canvas.FillRect(Rect);
 
     xpos := Rect.Left;
-    PlayerStateImageList.Draw((Control as TListBox).Canvas, xpos, Rect.Top, TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetStateImageIndex);
+    PlayerStateImageList.Draw((Control as TTntListBox).Canvas, xpos, Rect.Top, TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetStateImageIndex);
     Inc(xpos, PlayerStateImageList.Width + 5);
 
     if Preferences.ShowFlags then
     begin
       FlagBitmap := GetFlagBitmap(TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).Country);
-      (Control as TListBox).Canvas.Draw(xpos, Rect.Top + 16 div 2 - FlagBitmap.Height div 2, FlagBitmap);
+      (Control as TTntListBox).Canvas.Draw(xpos, Rect.Top + 16 div 2 - FlagBitmap.Height div 2, FlagBitmap);
       Inc(xpos, FlagBitmap.Width + 5);
     end;
 
     if TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetAwayStatus and not TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetInGameStatus then
-      (Control as TListBox).Canvas.Font.Color := Colors.ClientAway
-    else (Control as TListBox).Canvas.Font.Color := clWindowText;
-    if odSelected in State then (Control as TListBox).Canvas.Font.Color := clWhite;
+      (Control as TTntListBox).Canvas.Font.Color := Colors.ClientAway
+    else (Control as TTntListBox).Canvas.Font.Color := clWindowText;
+    if odSelected in State then (Control as TTntListBox).Canvas.Font.Color := clWhite;
 
     if TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetBotMode then
     begin
-      (Control as TListBox).Canvas.Draw(xpos, Rect.Top, BotImage.Picture.Bitmap);
+      (Control as TTntListBox).Canvas.Draw(xpos, Rect.Top, BotImage.Picture.Bitmap);
       Inc(xpos, BotImage.Picture.Bitmap.Width + 4{leave some space between username and the icon});
     end;
 
@@ -6956,19 +6989,19 @@
     begin
       for i:=0 to CupList.Count-1 do
       begin
-        LadderCups.Draw((Control as TListBox).Canvas, xpos, Rect.Top, Integer(CupList[i]^));
+        LadderCups.Draw((Control as TTntListBox).Canvas, xpos, Rect.Top, Integer(CupList[i]^));
         Inc(xpos, LadderCups.Width + 1);
       end;
     end;
 
-    (Control as TListBox).Canvas.TextOut(xpos, Rect.Top, TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).Name);
-    Inc(xpos, (Control as TListBox).Canvas.TextWidth(TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).Name));
+    WideCanvasTextOut((Control as TTntListBox).Canvas, xpos, Rect.Top, TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).Name);
+    Inc(xpos, WideCanvasTextWidth((Control as TTntListBox).Canvas,TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).Name));
 
-    RanksImageList.Draw((Control as TListBox).Canvas, xpos, Rect.Top, TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetRank);
+    RanksImageList.Draw((Control as TTntListBox).Canvas, xpos, Rect.Top, TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetRank);
     Inc(xpos, RanksImageList.Width + 1);
 
     if TClient((PageControl1.ActivePage as TMyTabSheet).Clients[Index]).GetAccess then
-      PlayerStateImageList.Draw((Control as TListBox).Canvas, xpos, Rect.Top, 4);
+      PlayerStateImageList.Draw((Control as TTntListBox).Canvas, xpos, Rect.Top, 4);
 
   end;
 end;
@@ -7067,6 +7100,14 @@
     begin
       LobbyScriptUnit.JoinBattle;
     end;
+    3: // ChangeMap
+    begin
+      LobbyScriptUnit.ChangeMap;
+    end;
+    4: // HostBattle
+    begin
+      LobbyScriptUnit.HostBattle;
+    end;
   end;
 end;
 
@@ -7393,6 +7434,8 @@
   Utility.DeInitLib;
   ReplayList.Free;
   DeinitializeFlagBitmaps;
+  PyEngine.Finalize;
+  PyEngine.UnloadDll;
 end;
 
 procedure TMainForm.KeepAliveTimerTimer(Sender: TObject);
@@ -7521,7 +7564,7 @@
 
 { opens a private chat with ClientName if it doesn't already exist.
   If it does, it just focuses it. }
-procedure TMainForm.OpenPrivateChat(ClientName: string);
+procedure TMainForm.OpenPrivateChat(ClientName: WideString);
 var
   i: Integer;
   tmpEd : TTntMemo;
@@ -7548,7 +7591,7 @@
 
 procedure TMainForm.ClientsListBoxDblClick(Sender: TObject);
 var
-  ClientName: string;
+  ClientName: WideString;
 begin
   if ClientsListBox.ItemIndex = -1 then Exit; // I don't think this can actually happen, since we must click in ListBox and so select an item
   if PageControl1.ActivePage.Caption = LOCAL_TAB then ClientName := TClient(AllClients[ClientsListBox.ItemIndex]).Name
@@ -7854,6 +7897,11 @@
   try if not Preferences.DisableScripts then handlers.onClose; except end;
   //ReleaseMainThread;
 
+  HighlighBattlesTimer.Enabled := False;
+  KeepAliveTimer.Enabled := False;
+  LadderCupsRefresh.Enabled := False;
+  TryToDisconnect;
+
   if Debug.Log then ((PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Lines.SaveToFile(ExtractFilePath(Application.ExeName) + LOG_FILENAME);
   if FiltersButton.ImageIndex = 1 then
   begin
@@ -7874,7 +7922,8 @@
     MenuForm.SaveSettings;
   SaveGroups;
 
-  CloseSpringDownloader;
+  if Preferences.EnableSpringDownloader then
+    CloseSpringDownloader;
 end;
 
 function TMainForm.LoadImagesDynamically: Boolean; // used for debugging purposes only
@@ -8001,6 +8050,7 @@
 procedure TMainForm.ReplaysButtonClick(Sender: TObject);
 begin
   ReplaysForm.Show;
+  TipsForm.ShowTips(4);
 end;
 
 procedure TMainForm.SortLabelClick(Sender: TObject);
@@ -8382,7 +8432,7 @@
   (Sender as TMenuItem).Checked := True;
   Preferences.SortStyle := (Sender as TMenuItem).Tag;
   SortLabel.Caption := (Sender as TMenuItem).Caption;
-  RefreshClientSort;
+  ResortClientsLists;
 end;
 
 procedure TMainForm.VDTBattlesGetHintSize(Sender: TBaseVirtualTree;
@@ -8546,10 +8596,10 @@
   groupStr: String;
 begin
 
-  tmp := (Sender as TlistBox).ItemAtPos(Point(X, Y), True);
+  tmp := (Sender as TTntListBox).ItemAtPos(Point(X, Y), True);
   if tmp = -1 then
   begin
-    (Sender as TlistBox).Hint := '';
+    (Sender as TTntListBox).Hint := '';
     Exit;
   end;
 
@@ -8559,19 +8609,20 @@
       groupStr := '';
       if TClient(AllClients[tmp]).GetGroup &gt; -1 then
         groupStr := ', '+TClientGroup(ClientGroups[TClient(AllClients[tmp]).GetGroup]).Name;
-      (Sender as TlistBox).Hint := TClient(AllClients[tmp]).Name + ', ' + GetCountryName(TClient(AllClients[tmp]).Country)+groupStr;
+      (Sender as TTntListBox).Hint := TClient(AllClients[tmp]).Name + ', ' + GetCountryName(TClient(AllClients[tmp]).Country)+groupStr;
     end
     else
     begin
       groupStr := '';
       if TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).GetGroup &gt; -1 then
         groupStr := ', '+TClientGroup(ClientGroups[TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).GetGroup]).Name;
-      (Sender as TlistBox).Hint := TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).Name + ', ' + GetCountryName(TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).Country)+groupStr;
+      (Sender as TTntListBox).Hint := TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).Name + ', ' + GetCountryName(TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).Country)+groupStr;
       if TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).CupLadderList.Count &gt; 0 then
-        (Sender as TlistBox).Hint := (Sender as TlistBox).Hint + ', '+Misc.JoinStringList(TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).CupLadderList,', ')
+        (Sender as TTntListBox).Hint := (Sender as TTntListBox).Hint + ', '+Misc.JoinStringList(TClient((PageControl1.ActivePage as TMyTabSheet).Clients[tmp]).CupLadderList,', ')
     end;
   except
   end;
+  (Sender as TTntListBox).Refresh;
 end;
 
 procedure TMainForm.RichEditPopupMenuPopup(Sender: TObject);
@@ -8582,7 +8633,7 @@
   begin
     (Items[Items.IndexOf(AutoScroll1)] as TSpTBXItem).Visible := RunningUnderWine;
     (Items[Items.IndexOf(AutoScroll1)] as TSpTBXItem).Checked := (PageControl1.ActivePage as TMyTabSheet).AutoScroll;
-    (Items[Items.IndexOf(AutoJoin1)] as TSpTBXItem).Visible := (PageControl1.ActivePage.Caption &lt;&gt; '$Local') and (PageControl1.ActivePage.Caption &lt;&gt; '#main') and (LeftStr(PageControl1.ActivePage.Caption,1) = '#');
+    (Items[Items.IndexOf(AutoJoin1)] as TSpTBXItem).Visible := (PageControl1.ActivePage.Caption &lt;&gt; LOCAL_TAB) and (PageControl1.ActivePage.Caption &lt;&gt; '#main') and (LeftStr(PageControl1.ActivePage.Caption,1) = '#');
     (Items[Items.IndexOf(AutoJoin1)] as TSpTBXItem).Checked := True;
     for i:=0 to PerformForm.CommandsListBox.Count-1 do
       if (AnsiUpperCase(PerformForm.CommandsListBox.Items[i]) = '/J '+AnsiUpperCase(PageControl1.ActivePage.Caption)) or (AnsiUpperCase(PerformForm.CommandsListBox.Items[i]) = '/JOIN '+AnsiUpperCase(PageControl1.ActivePage.Caption)) then
@@ -8833,6 +8884,8 @@
   Self.NotifyOnJoin := False;
   Self.NotifyOnBattleEnd := False;
   Self.NotifyOnConnect := False;
+  Self.EnableChatColor := False;
+  Self.ChatColor := Color;
 end;
 
 destructor TClientGroup.Destroy;
@@ -8871,7 +8924,7 @@
     group := TClientGroup.Create(InputString,InputColor('Choose a group highlight color ...',clWhite));
     group.Clients.Add(SelectedUserName);
     ClientGroups.Add(group);
-    RefreshClientSort;
+    SortClientInLists(Client);
     group.GroupUpdated;
   end;
 end;
@@ -8889,11 +8942,11 @@
     TClientGroup(ClientGroups[Client.GetGroup]).Clients.Delete(TClientGroup(ClientGroups[Client.GetGroup]).Clients.IndexOf(Client.Name));
 
   TClientGroup(ClientGroups[(Sender as TSpTBXItem).Tag]).Clients.Add(SelectedUserName);
-  RefreshClientSort;
+  SortClientInLists(Client);;
   TClientGroup(ClientGroups[(Sender as TSpTBXItem).Tag]).GroupUpdated;
 end;
 
-procedure TMainForm.RefreshClientSort;
+procedure TMainForm.ResortClientsLists;
 var
   i:integer;
 begin
@@ -8904,6 +8957,17 @@
   UpdateClientsListBox;
 end;
 
+procedure TMainForm.SortClientInLists(client: TClient);
+var
+  i:integer;
+begin
+  if Preferences.SortLocal then
+    SortClientInList(client,AllClients, Preferences.SortStyle);
+  for i := 1 {start from 1 to skip LOCAL_TAB} to PageControl1.PageCount-1 do
+    SortClientInList(client,(PageControl1.Pages[i] as TMyTabSheet).Clients, Preferences.SortStyle);
+  UpdateClientsListBox;
+end;
+
 procedure TMainForm.ClientsListBoxClick(Sender: TObject);
 begin
   ClientsListBox.Refresh;
@@ -8919,7 +8983,7 @@
   Client := GetClient(SelectedUserName);
   g := TClientGroup(ClientGroups[Client.GetGroup]);
   g.Clients.Delete(TClientGroup(ClientGroups[Client.GetGroup]).Clients.IndexOf(Client.Name));
-  RefreshClientSort;
+  SortClientInLists(Client);
   MainForm.ClientsListBox.Refresh;
   g.GroupUpdated;
 end;
@@ -8945,6 +9009,10 @@
       Ini.WriteString(IntToStr(i), 'NotifyOnBattleEnd', BoolToStr(TClientGroup(ClientGroups[i]).NotifyOnBattleEnd));
       Ini.WriteString(IntToStr(i), 'NotifyOnConnect', BoolToStr(TClientGroup(ClientGroups[i]).NotifyOnConnect));
       Ini.WriteString(IntToStr(i), 'HighlightBattles', BoolToStr(TClientGroup(ClientGroups[i]).HighlightBattles));
+      Ini.WriteString(IntToStr(i), 'EnableChatColor', BoolToStr(TClientGroup(ClientGroups[i]).EnableChatColor));
+      Ini.WriteString(IntToStr(i), 'ChatColor', IntToStr(TClientGroup(ClientGroups[i]).ChatColor));
+      Ini.WriteString(IntToStr(i), 'ReplaceRank', BoolToStr(TClientGroup(ClientGroups[i]).ReplaceRank));
+      Ini.WriteString(IntToStr(i), 'Rank', IntToStr(TClientGroup(ClientGroups[i]).Rank));
       Ini.WriteString(IntToStr(i), 'Clients', Misc.JoinStringList(TClientGroup(ClientGroups[i]).Clients,' '));
     end;
     Ini.Free;
@@ -8976,6 +9044,10 @@
     cg.NotifyOnBattleEnd := StrToBool(Ini.ReadString(IntToStr(i), 'NotifyOnBattleEnd', '0'));
     cg.NotifyOnConnect := StrToBool(Ini.ReadString(IntToStr(i), 'NotifyOnConnect', '0'));
     cg.HighlightBattles := StrToBool(Ini.ReadString(IntToStr(i), 'HighlightBattles', '0'));
+    cg.EnableChatColor := StrToBool(Ini.ReadString(IntToStr(i), 'EnableChatColor', '0'));
+    cg.ChatColor := StrToInt(Ini.ReadString(IntToStr(i), 'ChatColor', '0'));
+    cg.ReplaceRank := StrToBool(Ini.ReadString(IntToStr(i), 'ReplaceRank', '0'));
+    cg.Rank := StrToInt(Ini.ReadString(IntToStr(i), 'Rank', '0'));
     Misc.ParseDelimited(cg.Clients,Ini.ReadString(IntToStr(i), 'Clients', 'Empty'),' ','');
     ClientGroups.Add(cg);
     i := i+1;
@@ -10336,13 +10408,14 @@
     BattleListPopupMenuInitPopup(nil,nil);
 end;
 
-constructor TLobbyUpdateThread.Create(Suspended: Boolean;downloadBeta: boolean; autoUpdate: boolean; delayed : integer = 0);
+constructor TLobbyUpdateThread.Create(Suspended: Boolean;downloadBeta: boolean; autoUpdate: boolean; delayed : integer = 0; forceUpdate: boolean = False);
 begin
    FreeOnTerminate := True;
    inherited Create(Suspended);
    dlBeta := downloadBeta;
    autoUpdt := autoUpdate;
    delay := delayed;
+   forceUpt := forceUpdate;
 end;
 
 procedure TLobbyUpdateThread.Execute;
@@ -10390,9 +10463,9 @@
       else
         Misc.ParseDelimited(parsedHtml,parsedHtml[1],' ','');
 
-      if StrToInt(parsedHtml[0]) &gt; Misc.GetLobbyRevision then
+      if forceUpt or (StrToInt(parsedHtml[0]) &gt; Misc.GetLobbyRevision) then
       begin
-        if (autoUpdt and dlBeta) or (MessageDlgThread(StringReplace(MakeSentence(parsedHtml,2),'\n',EOL,[rfReplaceAll]),mtInformation,[mbYes,mbNo],0) = mrYes) then
+        if forceUpt or (autoUpdt and dlBeta) or (MessageDlgThread(StringReplace(MakeSentence(parsedHtml,2),'\n',EOL,[rfReplaceAll]),mtInformation,[mbYes,mbNo],0) = mrYes) then
         begin
             DownloadFile.URL := parsedHtml[1];
             DownloadFile.FileName := '_AutoUpdateTempFile.7z';
@@ -10692,7 +10765,7 @@
   PythonScriptDebugFormUnit.printList.BeginUpdate;
   PythonScriptDebugFormUnit.printList.Add(Data);
   PythonScriptDebugFormUnit.printList.EndUpdate;
-  PostMessage(PythonScriptDebugForm.Handle, WM_REFRESHOUTPUT, 0, 0);
+  SendMessage(PythonScriptDebugForm.Handle, WM_REFRESHOUTPUT, 0, 0);
 end;
 
 procedure TMainForm.SpTBXItem5Click(Sender: TObject);
@@ -10740,4 +10813,9 @@
   if not r then Misc.OpenURLInDefaultBrowser(URL);
 end;
 
+procedure TMainForm.mnuTipsClick(Sender: TObject);
+begin
+  TipsForm.ShowTips(0,True);
+end;
+
 end.

Modified: branches/0.77-branch/Lobby/TASClient/ManageGroups.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/ManageGroups.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/ManageGroups.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,10 +1,10 @@
 object ManageGroupsForm: TManageGroupsForm
-  Left = 871
-  Top = 171
+  Left = 730
+  Top = 100
   BorderStyle = bsDialog
-  Caption = 'ManageGroupsForm'
-  ClientHeight = 374
-  ClientWidth = 473
+  Caption = 'Manage groups'
+  ClientHeight = 384
+  ClientWidth = 516
   Color = clBtnFace
   Constraints.MaxHeight = 1000
   Constraints.MaxWidth = 1680
@@ -24,8 +24,8 @@
   object SpTBXTitleBar1: TSpTBXTitleBar
     Left = 0
     Top = 0
-    Width = 473
-    Height = 374
+    Width = 516
+    Height = 384
     Caption = 'Manage groups'
     FixedSize = True
     Options.Maximize = False
@@ -33,7 +33,7 @@
       Left = 8
       Top = 72
       Width = 225
-      Height = 241
+      Height = 248
       ItemHeight = 16
       TabOrder = 1
     end
@@ -49,13 +49,13 @@
     end
     object SpTBXPanel1: TSpTBXPanel
       Left = 8
-      Top = 325
-      Width = 456
+      Top = 332
+      Width = 497
       Height = 41
       Caption = 'SpTBXPanel1'
       TabOrder = 3
       DesignSize = (
-        456
+        497
         41)
       object btRemove: TSpTBXButton
         Left = 104
@@ -90,7 +90,7 @@
         LinkFont.Style = [fsUnderline]
       end
       object btClose: TSpTBXButton
-        Left = 376
+        Left = 417
         Top = 8
         Width = 73
         Height = 25
@@ -122,19 +122,22 @@
     object SpTBXPanel2: TSpTBXPanel
       Left = 240
       Top = 40
-      Width = 225
-      Height = 273
+      Width = 265
+      Height = 280
       Caption = 'SpTBXPanel2'
       TabOrder = 4
-      DesignSize = (
-        225
-        273)
+      object Label1: TLabel
+        Left = 8
+        Top = 248
+        Width = 70
+        Height = 13
+        Caption = 'Replace rank :'
+      end
       object ColorPanel: TPanel
-        Left = 120
+        Left = 128
         Top = 32
-        Width = 57
+        Width = 97
         Height = 21
-        Anchors = [akTop, akRight]
         BevelOuter = bvNone
         BorderStyle = bsSingle
         Color = clBlack
@@ -189,12 +192,11 @@
         LinkFont.Style = [fsUnderline]
       end
       object btChooseColor: TSpTBXButton
-        Left = 184
+        Left = 232
         Top = 32
         Width = 25
         Height = 20
         Caption = '...'
-        Anchors = [akTop, akRight]
         TabOrder = 5
         OnClick = btChooseColorClick
         LinkFont.Charset = DEFAULT_CHARSET
@@ -205,7 +207,7 @@
         ThemeType = thtTBX
       end
       object AutoSpecCheckBox: TSpTBXCheckBox
-        Left = 120
+        Left = 128
         Top = 80
         Width = 14
         Height = 15
@@ -213,7 +215,7 @@
         OnClick = AutoSpecCheckBoxClick
       end
       object AutoKickCheckBox: TSpTBXCheckBox
-        Left = 120
+        Left = 128
         Top = 58
         Width = 14
         Height = 15
@@ -221,7 +223,7 @@
         OnClick = AutoKickCheckBoxClick
       end
       object NotifyOnHostCheckBox: TSpTBXCheckBox
-        Left = 120
+        Left = 128
         Top = 104
         Width = 14
         Height = 15
@@ -253,7 +255,7 @@
         LinkFont.Style = [fsUnderline]
       end
       object NotifyOnJoinCheckBox: TSpTBXCheckBox
-        Left = 120
+        Left = 128
         Top = 128
         Width = 14
         Height = 15
@@ -261,7 +263,7 @@
         OnClick = NotifyOnJoinCheckBoxClick
       end
       object NotifyOnBattlEndCheckBox: TSpTBXCheckBox
-        Left = 120
+        Left = 128
         Top = 152
         Width = 14
         Height = 15
@@ -293,7 +295,7 @@
         LinkFont.Style = [fsUnderline]
       end
       object NotifyOnConnectCheckBox: TSpTBXCheckBox
-        Left = 120
+        Left = 128
         Top = 176
         Width = 14
         Height = 15
@@ -301,9 +303,9 @@
         OnClick = NotifyOnConnectCheckBoxClick
       end
       object txtName: TSpTBXEdit
-        Left = 120
+        Left = 128
         Top = 10
-        Width = 89
+        Width = 129
         Height = 21
         TabOrder = 16
         OnChange = txtNameChange
@@ -321,13 +323,77 @@
         LinkFont.Style = [fsUnderline]
       end
       object HighlightBattlesCheckbox: TSpTBXCheckBox
-        Left = 120
+        Left = 128
         Top = 200
         Width = 14
         Height = 15
         TabOrder = 18
         OnClick = HighlightBattlesCheckboxClick
       end
+      object SpTBXLabel10: TSpTBXLabel
+        Left = 8
+        Top = 224
+        Width = 54
+        Height = 13
+        Caption = 'Chat color :'
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
+      object ChatColorPanel: TPanel
+        Left = 152
+        Top = 222
+        Width = 73
+        Height = 21
+        BevelOuter = bvNone
+        BorderStyle = bsSingle
+        Color = clBlack
+        TabOrder = 20
+      end
+      object btChooseChatColor: TSpTBXButton
+        Left = 232
+        Top = 222
+        Width = 25
+        Height = 20
+        Caption = '...'
+        TabOrder = 21
+        OnClick = btChooseChatColorClick
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+        ThemeType = thtTBX
+      end
+      object ChatColorCheckBox: TSpTBXCheckBox
+        Left = 128
+        Top = 224
+        Width = 14
+        Height = 15
+        TabOrder = 22
+        OnClick = ChatColorCheckBoxClick
+      end
+      object ReplaceRankCheckBox: TSpTBXCheckBox
+        Left = 128
+        Top = 248
+        Width = 14
+        Height = 15
+        TabOrder = 23
+        OnClick = ReplaceRankCheckBoxClick
+      end
+      object ReplaceRankCmb: TSpTBXComboBox
+        Left = 152
+        Top = 245
+        Width = 105
+        Height = 22
+        Style = csOwnerDrawFixed
+        ItemHeight = 16
+        TabOrder = 24
+        OnChange = ReplaceRankCmbChange
+        OnDrawItem = ReplaceRankCmbDrawItem
+      end
     end
   end
 end

Modified: branches/0.77-branch/Lobby/TASClient/ManageGroups.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/ManageGroups.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/ManageGroups.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -37,6 +37,13 @@
     SpTBXLabel9: TSpTBXLabel;
     HighlightBattlesCheckbox: TSpTBXCheckBox;
     btAddPlayer: TSpTBXButton;
+    SpTBXLabel10: TSpTBXLabel;
+    ChatColorPanel: TPanel;
+    btChooseChatColor: TSpTBXButton;
+    ChatColorCheckBox: TSpTBXCheckBox;
+    Label1: TLabel;
+    ReplaceRankCheckBox: TSpTBXCheckBox;
+    ReplaceRankCmb: TSpTBXComboBox;
     procedure FormShow(Sender: TObject);
     procedure cmbGroupsChange(Sender: TObject);
     procedure btRemoveClick(Sender: TObject);
@@ -55,6 +62,12 @@
     procedure HighlightBattlesCheckboxClick(Sender: TObject);
     procedure btAddPlayerClick(Sender: TObject);
     procedure FormClose(Sender: TObject; var Action: TCloseAction);
+    procedure ChatColorCheckBoxClick(Sender: TObject);
+    procedure btChooseChatColorClick(Sender: TObject);
+    procedure ReplaceRankCmbDrawItem(Control: TWinControl; Index: Integer;
+      Rect: TRect; State: TOwnerDrawState);
+    procedure ReplaceRankCheckBoxClick(Sender: TObject);
+    procedure ReplaceRankCmbChange(Sender: TObject);
   private
     { Private declarations }
   public
@@ -73,10 +86,25 @@
 procedure TManageGroupsForm.FormShow(Sender: TObject);
 var
   i:Integer;
+  client: TClient;
+  g : integer;
 begin
   cmbGroups.Clear;
   for i:=0 to ClientGroups.Count-1 do
     cmbGroups.Items.Add(TClientGroup(ClientGroups[i]).Name);
+
+  client := MainForm.GetClient(SelectedUserName);
+  if client &lt;&gt; nil then
+  begin
+    g := client.GetGroup;
+    if g &gt; -1 then
+    begin
+      cmbGroups.ItemIndex := g;
+      cmbGroupsChange(Sender);
+      Exit
+    end;
+  end;
+
   if cmbGroups.Items.Count &gt; 0 then
     cmbGroups.ItemIndex := 0;
   cmbGroupsChange(Sender);
@@ -98,6 +126,10 @@
   NotifyOnBattlEndCheckBox.Checked := TClientGroup(ClientGroups[cmbGroups.ItemIndex]).NotifyOnBattleEnd;
   NotifyOnConnectCheckBox.Checked := TClientGroup(ClientGroups[cmbGroups.ItemIndex]).NotifyOnConnect;
   HighlightBattlesCheckbox.Checked := TClientGroup(ClientGroups[cmbGroups.ItemIndex]).HighlightBattles;
+  ChatColorCheckBox.Checked := TClientGroup(ClientGroups[cmbGroups.ItemIndex]).EnableChatColor;
+  ChatColorPanel.Color := TClientGroup(ClientGroups[cmbGroups.ItemIndex]).ChatColor;
+  ReplaceRankCheckBox.Checked := TClientGroup(ClientGroups[cmbGroups.ItemIndex]).ReplaceRank;
+  ReplaceRankCmb.ItemIndex := TClientGroup(ClientGroups[cmbGroups.ItemIndex]).Rank;
 end;
 
 procedure TManageGroupsForm.btRemoveClick(Sender: TObject);
@@ -111,7 +143,7 @@
     lstClients.Items.Delete(i);
   end;
   MainForm.SaveGroups;
-  MainForm.ClientsListBox.Refresh;
+  MainForm.ResortClientsLists;
 end;
 
 procedure TManageGroupsForm.btRenameClick(Sender: TObject);
@@ -134,7 +166,7 @@
 begin
   ColorPanel.Color := InputColor('Choose a group color ...',ColorPanel.Color);
   TClientGroup(ClientGroups[cmbGroups.ItemIndex]).Color := ColorPanel.Color;
-  MainForm.ClientsListBox.Refresh;
+  MainForm.UpdateClientsListBox;
 end;
 
 procedure TManageGroupsForm.btRemoveGroupClick(Sender: TObject);
@@ -152,6 +184,7 @@
   end;
   cmbGroups.ItemIndex := 0;
   cmbGroupsChange(Sender);
+  MainForm.ResortClientsLists;
 end;
 
 procedure TManageGroupsForm.txtNameChange(Sender: TObject);
@@ -201,9 +234,14 @@
 end;
 
 procedure TManageGroupsForm.FormCreate(Sender: TObject);
+var
+  i: integer;
 begin
   if not SpTBXTitleBar1.Active then
     RemoveSpTBXTitleBarMarges(self);
+
+  for i := 1 to High(Ranks) do ReplaceRankCmb.Items.Add(Ranks[i]);
+  ReplaceRankCmb.ItemIndex := 0;
 end;
 
 procedure TManageGroupsForm.HighlightBattlesCheckboxClick(Sender: TObject);
@@ -214,6 +252,7 @@
 procedure TManageGroupsForm.btAddPlayerClick(Sender: TObject);
 var
   InputString: string;
+  client: TClient;
 begin
   InputString := '';
   if InputQuery('New group ...', 'Enter the group name :', InputString) and (InputString &lt;&gt; '') then
@@ -221,6 +260,10 @@
     TClientGroup(ClientGroups[cmbGroups.ItemIndex]).Clients.Add(InputString);
     lstClients.Items.Add(InputString);
     lstClients.Refresh;
+
+    client := MainForm.GetClient(InputString);
+    if client &lt;&gt; nil then
+      MainForm.SortClientInLists(client);
   end;
 end;
 
@@ -232,4 +275,35 @@
   ReleaseMainThread;
 end;
 
+procedure TManageGroupsForm.ChatColorCheckBoxClick(Sender: TObject);
+begin
+  TClientGroup(ClientGroups[cmbGroups.ItemIndex]).EnableChatColor := ChatColorCheckBox.Checked;
+end;
+
+procedure TManageGroupsForm.btChooseChatColorClick(Sender: TObject);
+begin
+  ChatColorPanel.Color := InputColor('Choose a group color ...',ChatColorPanel.Color);
+  TClientGroup(ClientGroups[cmbGroups.ItemIndex]).ChatColor := ChatColorPanel.Color;
+end;
+
+procedure TManageGroupsForm.ReplaceRankCmbDrawItem(Control: TWinControl;
+  Index: Integer; Rect: TRect; State: TOwnerDrawState);
+begin
+  // this ensures the correct highlite color is used
+  (Control as TSpTBXComboBox).Canvas.FillRect(Rect);
+
+  MainForm.RanksImageList.Draw((Control as TSpTBXComboBox).Canvas, Rect.Left, Rect.Top, Index);
+  (Control as TSpTBxComboBox).Canvas.TextOut(Rect.Left + MainForm.RanksImageList.Width + 3, Rect.Top, (Control as TSpTBxComboBox).Items[Index])
+end;
+
+procedure TManageGroupsForm.ReplaceRankCheckBoxClick(Sender: TObject);
+begin
+  TClientGroup(ClientGroups[cmbGroups.ItemIndex]).ReplaceRank := ReplaceRankCheckBox.Checked;
+end;
+
+procedure TManageGroupsForm.ReplaceRankCmbChange(Sender: TObject);
+begin
+  TClientGroup(ClientGroups[cmbGroups.ItemIndex]).Rank := ReplaceRankCmb.ItemIndex;
+end;
+
 end.

Modified: branches/0.77-branch/Lobby/TASClient/MapListFormUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/MapListFormUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/MapListFormUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1005,7 +1005,8 @@
   for i := 0 to SortedMaps.Count - 1 do begin
     sl := TStringList.Create;
 
-    TMapItem(SortedMaps[i]).MainPanel.Visible := (not BattleForm.IsBattleActive) or (MapSelectionForm.MapListBox.Items.IndexOf(TMapItem(SortedMaps[i]).MapName) &gt;= 0);
+    TMapItem(SortedMaps[i]).MainPanel.Visible := ((Utility.ModValidMaps = nil) or (Utility.ModValidMaps.Count = 0) or (Utility.MapList.IndexOf(Utility.ModValidMaps[i]) &gt;= 0)) and
+                                                 ((BattleState.LadderIndex = -1) or (TLadder(LadderList[BattleState.LadderIndex]).Maps.IndexOf(Utility.MapList[i]) &gt;= 0));
 
     Misc.ParseDelimited(sl,s,' ','');
     for k:=0 to sl.Count -1 do

Modified: branches/0.77-branch/Lobby/TASClient/Misc.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/Misc.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/Misc.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -56,6 +56,7 @@
 function VersionStringToFloat(Version: string): Single;
 function GetFileSize(FileName: string): Integer;
 function ReadFile2(FileName: string): string;
+function ReadLastLogFileLines(FileStream: TFileStream; nbLines : integer ): String;
 procedure SaveFile(FileName: string;content: string);
 function VerifyName(Name: string): Boolean;
 function GetRegistryData(RootKey: HKEY; Key, Value: string): Variant;
@@ -397,15 +398,8 @@
   pMax: TPoint;
   mask : Word;
 begin
-  // enable auto URL detection each time because sometimes the links disapears
-  //mask := SendMessage(RichEdit.Handle, EM_GETEVENTMASK, 0, 0);
-  //SendMessage(RichEdit.Handle, EM_SETEVENTMASK, 0, mask or ENM_LINK);
-  //SendMessage(RichEdit.Handle, EM_AUTOURLDETECT, Integer(True), 0);
-
   Text := Tnt_WideStringReplace(Text,#$0B,' ',[rfReplaceAll]);
 
-
-
   // save the scroll pos
   SelStart := RichEdit.SelStart;
   SelLength := RichEdit.SelLength;
@@ -428,10 +422,10 @@
     RichEdit.SelAttributes.Style := [];
     RichEdit.SelAttributes.Color := TextColor;
     
-    if RichEdit.SelStart = 0 then // to avoid the first empty line
-      RichEdit.WideSelText := Text
-    else
-      RichEdit.WideSelText :=  EOL + Text;
+    //if RichEdit.SelStart = 0 then // to avoid the first empty line
+    //  RichEdit.WideSelText := Text
+    //else
+    RichEdit.WideSelText :=  Text+EOL;
 
     // this will automatically highlight any keywords and pop-up notification windows (if set so):
     HighlightingForm.CheckLastLineForHighlights(RichEdit, ChatTextPos);
@@ -444,7 +438,7 @@
     else
     begin
       RichEdit.ScrollToBottom;
-      RichEdit.ScrollPageDown;
+      RichEdit.ScrollToBottom;
     end;
 
   except
@@ -557,7 +551,7 @@
   if IOResult &lt;&gt; 0 then Result := -1;
 end;
 
-function ReadFile2(FileName: string): string;
+function ReadFile2(FileName: string): String;
 var
   FileStream: TFileStream;
 begin
@@ -567,6 +561,46 @@
   FileStream.Free;
 end;
 
+function ReadLastLogFileLines(FileStream: TFileStream; nbLines : integer ): String;
+var
+  i: integer;
+  c: string;
+  readSize: integer;
+  line : string;
+  previousEOL: integer;
+begin
+  FileStream.Seek(-1,soFromEnd);
+  if FileStream.Size &lt; 2 then Exit;
+  SetLength(c,1);
+
+  previousEOL := FileStream.Size;
+  i := 0;
+  repeat
+    FileStream.Seek(-2,soFromCurrent);
+    FileStream.ReadBuffer(Pointer(c)^,1);
+    if c = #13 then
+    begin
+      readSize := previousEOL-FileStream.Position-1;
+      if readSize &gt; 0 then
+      begin
+        SetLength(line,readSize);
+        FileStream.ReadBuffer(Pointer(line)^,readSize);
+        FileStream.Seek(-readSize,soFromCurrent);
+        if (LeftStr(LowerCase(line),16) &lt;&gt; #10+'logging started') and (line &lt;&gt; #10) then // not counting the logging started msgs
+        begin
+          Result := line + Result;
+          Inc(i);
+        end;
+      end;
+      previousEOL := FileStream.Position;
+    end;
+  until (i &gt;= nbLines) or (FileStream.Position &lt;= 2);
+
+  Result := TrimLeft(Result);
+
+  FileStream.Seek(-1,soFromEnd);
+end;
+
 procedure SaveFile(FileName: string;content: string);
 var
   FileStream: TFileStream;

Modified: branches/0.77-branch/Lobby/TASClient/PreferencesFormUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/PreferencesFormUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/PreferencesFormUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,9 +1,9 @@
 object PreferencesForm: TPreferencesForm
-  Left = 1006
-  Top = 225
+  Left = 861
+  Top = 106
   BorderStyle = bsDialog
   Caption = 'Preferences'
-  ClientHeight = 392
+  ClientHeight = 413
   ClientWidth = 415
   Color = clBtnFace
   Constraints.MaxHeight = 1000
@@ -25,7 +25,7 @@
     Left = 0
     Top = 0
     Width = 415
-    Height = 392
+    Height = 413
     Caption = 'Preferences'
     FixedSize = True
     Options.Minimize = False
@@ -35,9 +35,9 @@
       Left = 8
       Top = 32
       Width = 401
-      Height = 305
+      Height = 329
       Color = clBtnFace
-      ActiveTabIndex = 2
+      ActiveTabIndex = 1
       TabAutofit = True
       HiddenItems = &lt;&gt;
       object SpTBXTabItem6: TSpTBXTabItem
@@ -46,11 +46,11 @@
       end
       object SpTBXTabItem5: TSpTBXTabItem
         Caption = 'Account'
+        Checked = True
         CustomWidth = 56
       end
       object SpTBXTabItem4: TSpTBXTabItem
         Caption = 'Program'
-        Checked = True
         CustomWidth = 56
       end
       object SpTBXTabItem3: TSpTBXTabItem
@@ -73,7 +73,7 @@
         Left = 0
         Top = 23
         Width = 401
-        Height = 282
+        Height = 306
         Caption = 'HTTP'
         ImageIndex = -1
         TabItem = 'SpTBXTabItem2'
@@ -81,7 +81,7 @@
           Left = 16
           Top = 8
           Width = 369
-          Height = 257
+          Height = 281
           Caption = 'Proxy settings'
           Color = clNone
           ParentColor = False
@@ -189,11 +189,122 @@
           end
         end
       end
+      object SpTBXTabSheet6: TSpTBXTabSheet
+        Left = 0
+        Top = 23
+        Width = 401
+        Height = 306
+        Caption = 'Server'
+        ImageIndex = -1
+        TabItem = 'SpTBXTabItem6'
+        object GroupBox1: TSpTBXGroupBox
+          Left = 16
+          Top = 8
+          Width = 369
+          Height = 281
+          Caption = 'Server settings'
+          Color = clNone
+          ParentColor = False
+          TabOrder = 0
+          object Label1: TSpTBXLabel
+            Left = 16
+            Top = 32
+            Width = 74
+            Height = 13
+            Caption = 'Server address:'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label2: TSpTBXLabel
+            Left = 16
+            Top = 56
+            Width = 55
+            Height = 13
+            Caption = 'Server port:'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object ServerPortEdit: TSpTBXEdit
+            Left = 96
+            Top = 56
+            Width = 41
+            Height = 21
+            TabOrder = 1
+            Text = '8200'
+          end
+          object CheckBox10: TSpTBXCheckBox
+            Left = 16
+            Top = 128
+            Width = 197
+            Height = 15
+            Caption = 'Connect to backup host if primary fails'
+            TabOrder = 2
+            Checked = True
+            State = cbChecked
+          end
+          object CheckBox2: TSpTBXCheckBox
+            Left = 16
+            Top = 144
+            Width = 108
+            Height = 15
+            Caption = 'Connect on startup'
+            TabOrder = 3
+          end
+          object CheckBox7: TSpTBXCheckBox
+            Left = 16
+            Top = 160
+            Width = 226
+            Height = 15
+            Caption = 'Join #main once connected (recommended)'
+            TabOrder = 4
+          end
+          object ServerAddressEdit: TSpTBXButtonEdit
+            Left = 96
+            Top = 32
+            Width = 249
+            Height = 21
+            TabOrder = 0
+            EditButton.Left = 225
+            EditButton.Top = 0
+            EditButton.Width = 20
+            EditButton.Height = 17
+            EditButton.Caption = '...'
+            EditButton.Align = alRight
+            EditButton.DropDownArrow = False
+            EditButton.DropDownMenu = AddressPopupMenu
+            EditButton.LinkFont.Charset = DEFAULT_CHARSET
+            EditButton.LinkFont.Color = clBlue
+            EditButton.LinkFont.Height = -11
+            EditButton.LinkFont.Name = 'MS Sans Serif'
+            EditButton.LinkFont.Style = [fsUnderline]
+          end
+          object JvXPButton1: TSpTBXButton
+            Left = 272
+            Top = 56
+            Width = 73
+            Height = 21
+            Caption = 'Perform ...'
+            TabOrder = 7
+            OnClick = JvXPButton1Click
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+        end
+      end
       object SpTBXTabSheet1: TSpTBXTabSheet
         Left = 0
         Top = 23
         Width = 401
-        Height = 282
+        Height = 306
         Caption = 'Skins'
         ImageIndex = -1
         TabItem = 'SpTBXTabItem1'
@@ -201,7 +312,7 @@
           Left = 16
           Top = 8
           Width = 361
-          Height = 257
+          Height = 281
           Caption = 'Skin manager'
           Color = clNone
           ParentColor = False
@@ -271,11 +382,310 @@
           end
         end
       end
+      object SpTBXTabSheet7: TSpTBXTabSheet
+        Left = 0
+        Top = 23
+        Width = 401
+        Height = 306
+        Caption = 'Scripts'
+        ImageIndex = -1
+        TabItem = 'SpTBXTabItem7'
+        object ScriptsDebugWindowBt: TSpTBXButton
+          Left = 132
+          Top = 56
+          Width = 137
+          Height = 25
+          Caption = 'Debug Window'
+          TabOrder = 0
+          OnClick = ScriptsDebugWindowBtClick
+          LinkFont.Charset = DEFAULT_CHARSET
+          LinkFont.Color = clBlue
+          LinkFont.Height = -11
+          LinkFont.Name = 'MS Sans Serif'
+          LinkFont.Style = [fsUnderline]
+        end
+        object ScriptsReloadBt: TSpTBXButton
+          Left = 132
+          Top = 88
+          Width = 137
+          Height = 25
+          Caption = 'Reload scripts'
+          TabOrder = 1
+          OnClick = ScriptsReloadBtClick
+          LinkFont.Charset = DEFAULT_CHARSET
+          LinkFont.Color = clBlue
+          LinkFont.Height = -11
+          LinkFont.Name = 'MS Sans Serif'
+          LinkFont.Style = [fsUnderline]
+        end
+        object ScriptsLoadNewBt: TSpTBXButton
+          Left = 132
+          Top = 120
+          Width = 137
+          Height = 25
+          Caption = 'Load new scripts'
+          TabOrder = 2
+          OnClick = ScriptsLoadNewBtClick
+          LinkFont.Charset = DEFAULT_CHARSET
+          LinkFont.Color = clBlue
+          LinkFont.Height = -11
+          LinkFont.Name = 'MS Sans Serif'
+          LinkFont.Style = [fsUnderline]
+        end
+        object ScriptsAdvancedOptionsBt: TSpTBXButton
+          Left = 132
+          Top = 152
+          Width = 137
+          Height = 25
+          Caption = 'Advanced options'
+          TabOrder = 3
+          Visible = False
+          OnClick = ScriptsAdvancedOptionsBtClick
+          LinkFont.Charset = DEFAULT_CHARSET
+          LinkFont.Color = clBlue
+          LinkFont.Height = -11
+          LinkFont.Name = 'MS Sans Serif'
+          LinkFont.Style = [fsUnderline]
+        end
+        object EnableScriptsCheckBox: TSpTBXCheckBox
+          Left = 104
+          Top = 24
+          Width = 193
+          Height = 15
+          Caption = 'Enable scripts BETA (requires restart)'
+          TabOrder = 4
+        end
+      end
+      object SpTBXTabSheet4: TSpTBXTabSheet
+        Left = 0
+        Top = 23
+        Width = 401
+        Height = 306
+        Caption = 'Program'
+        ImageIndex = -1
+        TabItem = 'SpTBXTabItem4'
+        object GroupBox3: TSpTBXGroupBox
+          Left = 16
+          Top = 8
+          Width = 369
+          Height = 281
+          Caption = 'Program settings'
+          Color = clNone
+          ParentColor = False
+          TabOrder = 0
+          object ResetRegistryButton: TSpTBXSpeedButton
+            Left = 240
+            Top = 248
+            Width = 113
+            Height = 22
+            Caption = 'Reset registry data'
+            OnClick = ResetRegistryButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object GameSettingsButton: TSpTBXSpeedButton
+            Left = 240
+            Top = 96
+            Width = 113
+            Height = 22
+            Caption = 'Game settings'
+            OnClick = GameSettingsButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object NotificationsButton: TSpTBXSpeedButton
+            Left = 240
+            Top = 48
+            Width = 113
+            Height = 22
+            Caption = 'Notifications ...'
+            OnClick = NotificationsButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object HighlightingButton: TSpTBXSpeedButton
+            Left = 240
+            Top = 24
+            Width = 113
+            Height = 22
+            Caption = 'Highlighting ...'
+            OnClick = HighlightingButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object IgnoreListButton: TSpTBXSpeedButton
+            Left = 240
+            Top = 72
+            Width = 113
+            Height = 22
+            Caption = 'Ignore list ...'
+            OnClick = IgnoreListButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object Label6: TSpTBXLabel
+            Left = 16
+            Top = 32
+            Width = 46
+            Height = 13
+            Caption = 'Tab style:'
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object RadioButton4: TSpTBXRadioButton
+            Left = 16
+            Top = 56
+            Width = 38
+            Height = 15
+            Caption = 'tabs'
+            TabOrder = 0
+            TabStop = True
+            Checked = True
+          end
+          object RadioButton5: TSpTBXRadioButton
+            Left = 16
+            Top = 72
+            Width = 53
+            Height = 15
+            Caption = 'buttons'
+            TabOrder = 1
+          end
+          object RadioButton6: TSpTBXRadioButton
+            Left = 16
+            Top = 88
+            Width = 70
+            Height = 15
+            Caption = 'flat buttons'
+            TabOrder = 2
+          end
+          object CheckBox8: TSpTBXCheckBox
+            Left = 16
+            Top = 256
+            Width = 88
+            Height = 15
+            Caption = 'Enable logging'
+            TabOrder = 3
+            Checked = True
+            State = cbChecked
+          end
+          object CheckBox9: TSpTBXCheckBox
+            Left = 16
+            Top = 240
+            Width = 128
+            Height = 15
+            Caption = 'Use sound notifications'
+            TabOrder = 4
+            Checked = True
+            State = cbChecked
+          end
+          object KeyEditorButton: TSpTBXSpeedButton
+            Left = 240
+            Top = 120
+            Width = 113
+            Height = 22
+            Caption = 'Selection key editor'
+            OnClick = KeyEditorButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object CheckForNewVersionCheckBox: TSpTBXCheckBox
+            Left = 16
+            Top = 224
+            Width = 168
+            Height = 15
+            Caption = 'Auto update lobby to latest beta'
+            TabOrder = 12
+          end
+          object ColorsButton: TSpTBXButton
+            Left = 240
+            Top = 144
+            Width = 113
+            Height = 22
+            Caption = 'Colors and font ...'
+            TabOrder = 13
+            OnClick = ColorsButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object ManageGroupsButton: TSpTBXButton
+            Left = 240
+            Top = 168
+            Width = 113
+            Height = 22
+            Caption = 'Manage groups ...'
+            TabOrder = 14
+            OnClick = ManageGroupsButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object EnableSpringDownloaderCheckBox: TSpTBXCheckBox
+            Left = 16
+            Top = 208
+            Width = 144
+            Height = 15
+            Caption = 'Enable Spring Downloader'
+            TabOrder = 15
+            Checked = True
+            State = cbChecked
+          end
+          object UseLogonFormCheckBox: TSpTBXCheckBox
+            Left = 16
+            Top = 192
+            Width = 89
+            Height = 15
+            Caption = 'Use logon form'
+            TabOrder = 16
+            Checked = True
+            State = cbChecked
+          end
+          object TipsButton: TSpTBXButton
+            Left = 240
+            Top = 192
+            Width = 113
+            Height = 22
+            Caption = 'Tips ...'
+            TabOrder = 17
+            OnClick = TipsButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+        end
+      end
       object SpTBXTabSheet3: TSpTBXTabSheet
         Left = 0
         Top = 23
         Width = 401
-        Height = 282
+        Height = 306
         Caption = 'Interface'
         ImageIndex = -1
         TabItem = 'SpTBXTabItem3'
@@ -283,7 +693,7 @@
           Left = 16
           Top = 8
           Width = 369
-          Height = 257
+          Height = 281
           Caption = 'Interface preferences'
           Color = clNone
           ParentColor = False
@@ -363,13 +773,12 @@
             TabOrder = 7
           end
           object UploadReplayCheckBox: TSpTBXCheckBox
-            Left = 312
-            Top = 232
-            Width = 245
+            Left = 24
+            Top = 248
+            Width = 227
             Height = 15
-            Caption = 'Ask to upload replay after the end of each battle'
+            Caption = 'Ask what to do with replays after each battle'
             TabOrder = 8
-            Visible = False
           end
           object SortLocalCheckBox: TSpTBXCheckBox
             Left = 24
@@ -434,196 +843,11 @@
           end
         end
       end
-      object SpTBXTabSheet7: TSpTBXTabSheet
-        Left = 0
-        Top = 23
-        Width = 401
-        Height = 282
-        Caption = 'Scripts'
-        ImageIndex = -1
-        TabItem = 'SpTBXTabItem7'
-        object ScriptsDebugWindowBt: TSpTBXButton
-          Left = 132
-          Top = 56
-          Width = 137
-          Height = 25
-          Caption = 'Debug Window'
-          TabOrder = 0
-          OnClick = ScriptsDebugWindowBtClick
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object ScriptsReloadBt: TSpTBXButton
-          Left = 132
-          Top = 88
-          Width = 137
-          Height = 25
-          Caption = 'Reload scripts'
-          TabOrder = 1
-          OnClick = ScriptsReloadBtClick
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object ScriptsLoadNewBt: TSpTBXButton
-          Left = 132
-          Top = 120
-          Width = 137
-          Height = 25
-          Caption = 'Load new scripts'
-          TabOrder = 2
-          OnClick = ScriptsLoadNewBtClick
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object ScriptsAdvancedOptionsBt: TSpTBXButton
-          Left = 132
-          Top = 152
-          Width = 137
-          Height = 25
-          Caption = 'Advanced options'
-          TabOrder = 3
-          Visible = False
-          OnClick = ScriptsAdvancedOptionsBtClick
-          LinkFont.Charset = DEFAULT_CHARSET
-          LinkFont.Color = clBlue
-          LinkFont.Height = -11
-          LinkFont.Name = 'MS Sans Serif'
-          LinkFont.Style = [fsUnderline]
-        end
-        object EnableScriptsCheckBox: TSpTBXCheckBox
-          Left = 104
-          Top = 24
-          Width = 193
-          Height = 15
-          Caption = 'Enable scripts BETA (requires restart)'
-          TabOrder = 4
-        end
-      end
-      object SpTBXTabSheet6: TSpTBXTabSheet
-        Left = 0
-        Top = 23
-        Width = 401
-        Height = 282
-        Caption = 'Server'
-        ImageIndex = -1
-        TabItem = 'SpTBXTabItem6'
-        object GroupBox1: TSpTBXGroupBox
-          Left = 16
-          Top = 8
-          Width = 369
-          Height = 257
-          Caption = 'Server settings'
-          Color = clNone
-          ParentColor = False
-          TabOrder = 0
-          object Label1: TSpTBXLabel
-            Left = 16
-            Top = 32
-            Width = 74
-            Height = 13
-            Caption = 'Server address:'
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object Label2: TSpTBXLabel
-            Left = 16
-            Top = 56
-            Width = 55
-            Height = 13
-            Caption = 'Server port:'
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object ServerPortEdit: TSpTBXEdit
-            Left = 96
-            Top = 56
-            Width = 41
-            Height = 21
-            TabOrder = 1
-            Text = '8200'
-          end
-          object CheckBox10: TSpTBXCheckBox
-            Left = 16
-            Top = 128
-            Width = 197
-            Height = 15
-            Caption = 'Connect to backup host if primary fails'
-            TabOrder = 2
-            Checked = True
-            State = cbChecked
-          end
-          object CheckBox2: TSpTBXCheckBox
-            Left = 16
-            Top = 144
-            Width = 108
-            Height = 15
-            Caption = 'Connect on startup'
-            TabOrder = 3
-          end
-          object CheckBox7: TSpTBXCheckBox
-            Left = 16
-            Top = 160
-            Width = 226
-            Height = 15
-            Caption = 'Join #main once connected (recommended)'
-            TabOrder = 4
-          end
-          object ServerAddressEdit: TSpTBXButtonEdit
-            Left = 96
-            Top = 32
-            Width = 249
-            Height = 21
-            TabOrder = 0
-            EditButton.Left = 225
-            EditButton.Top = 0
-            EditButton.Width = 20
-            EditButton.Height = 17
-            EditButton.Caption = '...'
-            EditButton.Align = alRight
-            EditButton.DropDownArrow = False
-            EditButton.DropDownMenu = AddressPopupMenu
-            EditButton.LinkFont.Charset = DEFAULT_CHARSET
-            EditButton.LinkFont.Color = clBlue
-            EditButton.LinkFont.Height = -11
-            EditButton.LinkFont.Name = 'MS Sans Serif'
-            EditButton.LinkFont.Style = [fsUnderline]
-          end
-          object JvXPButton1: TSpTBXButton
-            Left = 272
-            Top = 56
-            Width = 73
-            Height = 21
-            Caption = 'Perform ...'
-            TabOrder = 7
-            OnClick = JvXPButton1Click
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-        end
-      end
       object SpTBXTabSheet5: TSpTBXTabSheet
         Left = 0
         Top = 23
         Width = 401
-        Height = 282
+        Height = 306
         Caption = 'Account'
         ImageIndex = -1
         TabItem = 'SpTBXTabItem5'
@@ -631,7 +855,7 @@
           Left = 16
           Top = 8
           Width = 369
-          Height = 257
+          Height = 281
           Caption = 'Account details'
           Color = clNone
           ParentColor = False
@@ -749,221 +973,10 @@
           end
         end
       end
-      object SpTBXTabSheet4: TSpTBXTabSheet
-        Left = 0
-        Top = 23
-        Width = 401
-        Height = 282
-        Caption = 'Program'
-        ImageIndex = -1
-        TabItem = 'SpTBXTabItem4'
-        object GroupBox3: TSpTBXGroupBox
-          Left = 16
-          Top = 8
-          Width = 369
-          Height = 257
-          Caption = 'Program settings'
-          Color = clNone
-          ParentColor = False
-          TabOrder = 0
-          object ResetRegistryButton: TSpTBXSpeedButton
-            Left = 240
-            Top = 224
-            Width = 113
-            Height = 22
-            Caption = 'Reset registry data'
-            OnClick = ResetRegistryButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object GameSettingsButton: TSpTBXSpeedButton
-            Left = 240
-            Top = 96
-            Width = 113
-            Height = 22
-            Caption = 'Game settings'
-            OnClick = GameSettingsButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object NotificationsButton: TSpTBXSpeedButton
-            Left = 240
-            Top = 48
-            Width = 113
-            Height = 22
-            Caption = 'Notifications ...'
-            OnClick = NotificationsButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object HighlightingButton: TSpTBXSpeedButton
-            Left = 240
-            Top = 24
-            Width = 113
-            Height = 22
-            Caption = 'Highlighting ...'
-            OnClick = HighlightingButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object IgnoreListButton: TSpTBXSpeedButton
-            Left = 240
-            Top = 72
-            Width = 113
-            Height = 22
-            Caption = 'Ignore list ...'
-            OnClick = IgnoreListButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object Label6: TSpTBXLabel
-            Left = 16
-            Top = 32
-            Width = 46
-            Height = 13
-            Caption = 'Tab style:'
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object RadioButton4: TSpTBXRadioButton
-            Left = 16
-            Top = 56
-            Width = 38
-            Height = 15
-            Caption = 'tabs'
-            TabOrder = 0
-            TabStop = True
-            Checked = True
-          end
-          object RadioButton5: TSpTBXRadioButton
-            Left = 16
-            Top = 72
-            Width = 53
-            Height = 15
-            Caption = 'buttons'
-            TabOrder = 1
-          end
-          object RadioButton6: TSpTBXRadioButton
-            Left = 16
-            Top = 88
-            Width = 70
-            Height = 15
-            Caption = 'flat buttons'
-            TabOrder = 2
-          end
-          object CheckBox8: TSpTBXCheckBox
-            Left = 16
-            Top = 232
-            Width = 88
-            Height = 15
-            Caption = 'Enable logging'
-            TabOrder = 3
-            Checked = True
-            State = cbChecked
-          end
-          object CheckBox9: TSpTBXCheckBox
-            Left = 16
-            Top = 216
-            Width = 128
-            Height = 15
-            Caption = 'Use sound notifications'
-            TabOrder = 4
-            Checked = True
-            State = cbChecked
-          end
-          object KeyEditorButton: TSpTBXSpeedButton
-            Left = 240
-            Top = 120
-            Width = 113
-            Height = 22
-            Caption = 'Selection key editor'
-            OnClick = KeyEditorButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object CheckForNewVersionCheckBox: TSpTBXCheckBox
-            Left = 16
-            Top = 200
-            Width = 168
-            Height = 15
-            Caption = 'Auto update lobby to latest beta'
-            TabOrder = 12
-          end
-          object ColorsButton: TSpTBXButton
-            Left = 240
-            Top = 144
-            Width = 113
-            Height = 22
-            Caption = 'Colors and font ...'
-            TabOrder = 13
-            OnClick = ColorsButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object ManageGroupsButton: TSpTBXButton
-            Left = 240
-            Top = 168
-            Width = 113
-            Height = 22
-            Caption = 'Manage groups ...'
-            TabOrder = 14
-            OnClick = ManageGroupsButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object EnableSpringDownloaderCheckBox: TSpTBXCheckBox
-            Left = 16
-            Top = 184
-            Width = 144
-            Height = 15
-            Caption = 'Enable Spring Downloader'
-            TabOrder = 15
-            Checked = True
-            State = cbChecked
-          end
-          object UseLogonFormCheckBox: TSpTBXCheckBox
-            Left = 16
-            Top = 168
-            Width = 89
-            Height = 15
-            Caption = 'Use logon form'
-            TabOrder = 16
-            Checked = True
-            State = cbChecked
-          end
-        end
-      end
     end
     object ApplyAndCloseButton: TSpTBXButton
       Left = 43
-      Top = 352
+      Top = 376
       Width = 145
       Height = 25
       Caption = 'Apply and close'
@@ -977,7 +990,7 @@
     end
     object CancelAndCloseButton: TSpTBXButton
       Left = 227
-      Top = 352
+      Top = 376
       Width = 145
       Height = 25
       Caption = 'Cancel and close'

Modified: branches/0.77-branch/Lobby/TASClient/PreferencesFormUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/PreferencesFormUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/PreferencesFormUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -187,6 +187,7 @@
     EnableSpringDownloaderCheckBox: TSpTBXCheckBox;
     RememberPasswordsCheckBox: TSpTBXCheckBox;
     UseLogonFormCheckBox: TSpTBXCheckBox;
+    TipsButton: TSpTBXButton;
 
     function BattleSortStyleToColumn(SortStyle: Integer): Integer;
     function ColumnToBattleSortStyle(Column: Integer): Integer;
@@ -235,6 +236,7 @@
     procedure ScriptsLoadNewBtClick(Sender: TObject);
     procedure ScriptsDebugWindowBtClick(Sender: TObject);
     procedure ScriptsAdvancedOptionsBtClick(Sender: TObject);
+    procedure TipsButtonClick(Sender: TObject);
   private
     { Private declarations }
   public
@@ -320,7 +322,7 @@
   OnlineMapsUnit, NotificationsUnit, PerformFormUnit, HighlightingUnit,
   NewAccountUnit, IgnoreListUnit, MapListFormUnit, ColorsPreferenceUnit,
   ManageGroups, ReplaysUnit, PythonScriptDebugFormUnit, LobbyScriptUnit,
-  SpringDownloaderFormUnit, LogonFormUnit;
+  SpringDownloaderFormUnit, LogonFormUnit, TipsFormUnit;
 
 {$R *.dfm}
 
@@ -388,7 +390,7 @@
 
     try CommonFont.Name := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences', 'FontName'); except end;
     try CommonFont.Size := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences', 'FontSize'); except end;
-    ((MainForm.PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Font.Assign(CommonFont);
+    try ((MainForm.PageControl1.Pages[0] as TMyTabSheet).Controls[1] as TExRichEdit).Font.Assign(CommonFont); except end;
     try Colors.Normal := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'Normal'); except end;
     try Colors.MyText := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'MyText'); except end;
     try Colors.AdminText := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'AdminText'); except end;
@@ -401,6 +403,7 @@
     try Colors.MOTD := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'MOTD'); except end;
     try Colors.SayEx := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'SayEx'); except end;
     try Colors.Topic := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'Topic'); except end;
+    try Colors.OldMsgs := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'OldMsgs'); except end;
     try Colors.ClientAway := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\OtherColors', 'ClientAway'); except end;
     try Colors.MapModUnavailable := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\OtherColors', 'MapModUnavailable'); except end;
     try Colors.BotText := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\OtherColors', 'BotText'); except end;
@@ -498,6 +501,8 @@
     try ReplaysForm.chkEnableFilters.Checked := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Forms\ReplaysForm', 'FiltersEnabled'); except end;
     try ReplaysForm.BottomPanel.Height := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Forms\ReplaysForm', 'Spliter1'); except end;
 
+    try TipsForm.chkShowTips.Checked := Misc.GetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Forms\TipsForm', 'ShowTips'); except end;
+
     ReadPreferencesRecordFromRegistry(Preferences);
   except
   end;
@@ -605,6 +610,8 @@
     Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Forms\ReplaysForm', 'FiltersEnabled', rdInteger, ReplaysForm.chkEnableFilters.Checked);
     Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Forms\ReplaysForm', 'Spliter1', rdInteger, ReplaysForm.BottomPanel.Height);
 
+    Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Forms\TipsForm', 'ShowTips', rdInteger, Misc.BoolToInt(TipsForm.chkShowTips.Checked));
+
     // write custom team colors to registry:
     for i := 0 to High(TeamColors) do
       Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\TeamColors', 'Color' + IntToStr(i), rdInteger, TeamColors[i]);
@@ -683,6 +690,7 @@
     Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'MOTD', rdInteger, Colors.MOTD);
     Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'SayEx', rdInteger, Colors.SayEx);
     Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'Topic', rdInteger, Colors.Topic);
+    Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\ChatColors', 'OldMsgs', rdInteger, Colors.OldMsgs);
     Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\OtherColors', 'ClientAway', rdInteger, Colors.ClientAway);
     Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\OtherColors', 'MapModUnavailable', rdInteger, Colors.MapModUnavailable);
     Misc.SetRegistryData(HKEY_CURRENT_USER, '\Software\TASClient\Preferences\OtherColors', 'BotText', rdInteger, Colors.BotText);
@@ -1044,7 +1052,7 @@
     UpdatePreferencesTo(Preferences); // save changes to p
     UpdatePreferencesFrom(Preferences); // update changes from p
     if Preferences.SortLocal then
-      MainForm.RefreshClientSort;
+      MainForm.ResortClientsLists;
     if Preferences.EnableSpringDownloader &lt;&gt; oldPref.EnableSpringDownloader then
       if Preferences.EnableSpringDownloader then
         StartSpringDownloader
@@ -1515,13 +1523,11 @@
 
 procedure TPreferencesForm.RegisterLadderAccountButtonClick(
   Sender: TObject);
-var
-  CreateAccountThread : TLadderCreateAccountThread;
 begin
-  if Status.ConnectionState &lt;&gt; Connected then
-    MessageDlg('You must be logged in to register a new ladder account !',mtWarning,[mbOK],0)
-  else
-    CreateAccountThread := TLadderCreateAccountThread.Create(False);
+  //if Status.ConnectionState &lt;&gt; Connected then
+  //  MessageDlg('You must be logged in to register a new ladder account !',mtWarning,[mbOK],0)
+  //else
+  TLadderCreateAccountThread.Create(False);
 end;
 
 procedure TPreferencesForm.ColorsButtonClick(Sender: TObject);
@@ -1576,4 +1582,9 @@
   ReleaseMainThread;
 end;
 
+procedure TPreferencesForm.TipsButtonClick(Sender: TObject);
+begin
+  TipsForm.ShowTips(0,True);
+end;
+
 end.

Modified: branches/0.77-branch/Lobby/TASClient/Python/api.txt
===================================================================
--- branches/0.77-branch/Lobby/TASClient/Python/api.txt	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/Python/api.txt	2008-09-15 18:44:36 UTC (rev 6427)
@@ -31,14 +31,15 @@
 - GetCurrentBattle
 - GetServers
 - SetServers(dict)
+- ChangeMap(mapName)
 
 Callin :
 
 - handleCommand(s)
-- handleIn(s)
+- handleIn(s) return dontLetLobbyHandleIt : boolean
 - onLoggedIn
 - onDisconnect
-- HandleOut(s)
+- HandleOut(s) return dontLetLobbyHandleIt : boolean
 - onLogin
 - onConnected
 - onClose
@@ -47,7 +48,8 @@
 - onMapsReloaded
 - onReplaysReloaded
 - onModsReloaded
-- onURLClick(url)
+- onURLClick(url) return dontLetLobbyHandleIt : boolean
+- onChatDblClick(word,line) return dontLetLobbyHandleIt : boolean
 
 
 
@@ -58,7 +60,6 @@
 
 - onSettingsChanged
 - onGroupsChanged
-- onMenuPopup(menuName)
 
 callout :
 
@@ -80,6 +81,7 @@
 - AddSplitter(name, parent)
 - AddTabsPanel(name, parent)
 - AddTab(caption, name, TabsPanelName)
+- AddForm(name, caption, borderStyle (1-&gt;5))
 
 
 
@@ -112,3 +114,5 @@
 
 
 callin :
+
+- onMenuPopup(menuName)
\ No newline at end of file

Modified: branches/0.77-branch/Lobby/TASClient/Python/engine/handlers.py
===================================================================
--- branches/0.77-branch/Lobby/TASClient/Python/engine/handlers.py	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/Python/engine/handlers.py	2008-09-15 18:44:36 UTC (rev 6427)
@@ -191,35 +191,38 @@
 				print ' %s has an attribute %s but it is not a function' % (s, funcname)
 
 def onDisconnect():
-	_handle_callin('onDisconnect')
+	return _handle_callin('onDisconnect')
 
 def onConnected():
-	_handle_callin('onConnected')
+	return _handle_callin('onConnected')
 
 def onLogin():
-	_handle_callin('onLogin')
+	return _handle_callin('onLogin')
 
 def onLoggedIn():
-	_handle_callin('onLoggedIn')
+	return _handle_callin('onLoggedIn')
 	
 def onSettingsChanged():
-	_handle_callin('onSettingsChanged')
+	return _handle_callin('onSettingsChanged')
 	
 def onGroupsChanged():
-	_handle_callin('onGroupsChanged')
+	return _handle_callin('onGroupsChanged')
 	
 def onMapsReloaded():
-	_handle_callin('onMapsReloaded')
+	return _handle_callin('onMapsReloaded')
 	
 def onReplaysReloaded():
-	_handle_callin('onReplaysReloaded')
+	return _handle_callin('onReplaysReloaded')
 	
 def onModsReloaded():
-	_handle_callin('onModsReloaded')
+	return _handle_callin('onModsReloaded')
 	
 def onURLClick(url):
-	_handle_callin('onURLClick',url)
+	return _handle_callin('onURLClick',url)
 	
+def onChatDblClick(word,line):
+	return _handle_callin('onChatDblClick',word+' '+line)
+	
 def handleCommand(cmd):
 	spaces = cmd.count(' ')
 	if spaces &gt;= 1:

Modified: branches/0.77-branch/Lobby/TASClient/ReplaysUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/ReplaysUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/ReplaysUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,6 +1,6 @@
 object ReplaysForm: TReplaysForm
-  Left = 609
-  Top = 235
+  Left = 875
+  Top = 194
   Width = 809
   Height = 640
   Caption = 'Replays'
@@ -133,7 +133,7 @@
         231)
       object SpTBXLabel1: TSpTBXLabel
         Left = 0
-        Top = 152
+        Top = 176
         Width = 32
         Height = 13
         Caption = 'Grade:'
@@ -145,7 +145,7 @@
       end
       object GradeComboBox: TSpTBXComboBox
         Left = 0
-        Top = 168
+        Top = 192
         Width = 97
         Height = 21
         Style = csDropDownList
@@ -543,7 +543,7 @@
       end
       object DownloadButton: TSpTBXButton
         Left = 0
-        Top = 126
+        Top = 150
         Width = 97
         Height = 22
         Caption = 'Dowload replays'
@@ -557,13 +557,12 @@
       end
       object UploadButton: TSpTBXButton
         Left = 0
-        Top = 203
+        Top = 126
         Width = 97
         Height = 22
         Caption = 'Upload'
         Enabled = False
         TabOrder = 7
-        Visible = False
         OnClick = UploadButtonClick
         LinkFont.Charset = DEFAULT_CHARSET
         LinkFont.Color = clBlue

Modified: branches/0.77-branch/Lobby/TASClient/ReplaysUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/ReplaysUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/ReplaysUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -305,7 +305,7 @@
 
 uses  StrUtils, ShellAPI, BattleFormUnit, Misc, PreferencesFormUnit,
   InitWaitFormUnit,MsMultiPartFormData, ProgressBarWindow,
-  UploadReplayUnit, LobbyScriptUnit;
+  UploadReplayUnit, LobbyScriptUnit, TipsFormUnit;
 
 {$R *.dfm}
 
@@ -1162,32 +1162,14 @@
 procedure TReplaysForm.UploadButtonClick(Sender: TObject);
 var
   i,j:integer;
-  teamCount : array[0..15] of integer;
   Replay: TReplay;
 begin
-  { disable while the replay site is down
   Replay := GetReplayFromNode(VDTReplays.FocusedNode);
-  for i:=0 to 15 do
-    teamCount[i] := 0;
+  UploadReplayForm.AutoUpload := False;
   UploadReplayForm.FileName := Replay.FullFileName;
   UploadReplayForm.MapName := Copy(Replay.Script.ReadKeyValue('GAME/mapname'),0,Length(Replay.Script.ReadKeyValue('GAME/mapname'))-4);
   UploadReplayForm.ModName := Copy(Replay.Script.ReadKeyValue('GAME/gametype'),0,Length(Replay.Script.ReadKeyValue('GAME/mapname'))-4);
-  i := Pos('AllyTeam=',ScriptRichEdit.Text);
-  while i &gt; 0 do begin
-    i := i+9;
-    j := PosEx(';',ScriptRichEdit.Text,i);
-    Inc(teamCount[StrToInt(Copy(ScriptRichEdit.Text,i,j-i))]);
-    i := PosEx('AllyTeam=',ScriptRichEdit.Text,i);
-  end;
-  UploadReplayForm.NbPlayers := '';
-  for i:= 0 to 15 do
-    if teamCount[i] &gt; 0 then
-      if UploadReplayForm.NbPlayers = '' then
-        UploadReplayForm.NbPlayers := IntToStr(teamCount[i])
-      else
-        UploadReplayForm.NbPlayers := UploadReplayForm.NbPlayers + 'v' + IntToStr(teamCount[i]);
   UploadReplayForm.ShowModal;
-  }
 end;
 
 function TReplaysForm.GetReplayFromNode(Node: PVirtualNode): TReplay;
@@ -1397,8 +1379,9 @@
   VDTReplays.SortTree(VDTReplays.Header.SortColumn,VDTReplays.Header.SortDirection);
 
   RenameButton.Enabled := ReplayList.Count &gt; 0;
-  DeleteButton.Enabled := ReplayList.Count &gt; 0;
-  GradeComboBox.Enabled := ReplayList.Count &gt; 0;
+  DeleteButton.Enabled := RenameButton.Enabled;
+  GradeComboBox.Enabled := RenameButton.Enabled;
+  UploadButton.Enabled := RenameButton.Enabled;
 
   ReplaysForm.VDTReplays.FocusedNode := ReplaysForm.VDTReplays.GetFirst;
   ReplaysForm.VDTReplays.Selected[ReplaysForm.VDTReplays.FocusedNode] := true;
@@ -1420,7 +1403,9 @@
     SaveButton.Enabled := False;
   end
   else
-    SaveButton.Enabled := true;
+  begin
+    SaveButton.Enabled := True;
+  end;
 end;
 
 procedure TReplaysForm.VDTReplaysClick(Sender: TObject);

Modified: branches/0.77-branch/Lobby/TASClient/SplashScreenUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/SplashScreenUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/SplashScreenUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -3,7 +3,6 @@
   Top = 368
   AlphaBlend = True
   AlphaBlendValue = 0
-  AutoSize = True
   BorderIcons = []
   BorderStyle = bsNone
   Caption = 'TASClient Loading ...'
@@ -17,6 +16,7 @@
   Font.Style = []
   OldCreateOrder = False
   Position = poScreenCenter
+  Scaled = False
   PixelsPerInch = 96
   TextHeight = 13
   object Image1: TImage

Modified: branches/0.77-branch/Lobby/TASClient/TASClient.dof
===================================================================
--- branches/0.77-branch/Lobby/TASClient/TASClient.dof	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/TASClient.dof	2008-09-15 18:44:36 UTC (rev 6427)
@@ -115,7 +115,7 @@
 MajorVer=0
 MinorVer=3
 Release=0
-Build=442
+Build=467
 Debug=0
 PreRelease=0
 Special=0
@@ -126,7 +126,7 @@
 [Version Info Keys]
 CompanyName=
 FileDescription=TA Spring lobby client
-FileVersion=0.3.0.442
+FileVersion=0.3.0.467
 InternalName=
 LegalCopyright=
 LegalTrademarks=

Modified: branches/0.77-branch/Lobby/TASClient/TASClient.dpr
===================================================================
--- branches/0.77-branch/Lobby/TASClient/TASClient.dpr	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/TASClient.dpr	2008-09-15 18:44:36 UTC (rev 6427)
@@ -112,7 +112,9 @@
   LobbyScriptUnit in 'LobbyScriptUnit.pas',
   SpringDownloaderFormUnit in 'SpringDownloaderFormUnit.pas' {SpringDownloaderForm},
   LogonFormUnit in 'LogonFormUnit.pas' {LogonForm},
-  MapSelectionFormUnit in 'MapSelectionFormUnit.pas' {MapSelectionForm};
+  MapSelectionFormUnit in 'MapSelectionFormUnit.pas' {MapSelectionForm},
+  OKCANCL1 in 'C:\Program Files\Borland\Delphi7\ObjRepos\OKCANCL1.pas' {OKBottomDlg},
+  TipsFormUnit in 'TipsFormUnit.pas' {TipsForm};
 
 var
   i: Integer;
@@ -223,6 +225,7 @@
   Application.CreateForm(TColorsPreference, ColorsPreference);
   Application.CreateForm(TSearchPlayerForm, SearchPlayerForm);
   Application.CreateForm(TPythonScriptDebugForm, PythonScriptDebugForm);
+  Application.CreateForm(TTipsForm, TipsForm);
   //Application.CreateForm(TSpringDownloaderForm, SpringDownloaderForm);
   if not MainUnit.RunningUnderWine then
     Application.CreateForm(TMenuForm, MenuForm);

Modified: branches/0.77-branch/Lobby/TASClient/TASClient.res
===================================================================
(Binary files differ)

Copied: branches/0.77-branch/Lobby/TASClient/TipsFormUnit.ddp (from rev 6422, trunk/Lobby/TASClient/TipsFormUnit.ddp)
===================================================================
(Binary files differ)

Copied: branches/0.77-branch/Lobby/TASClient/TipsFormUnit.dfm (from rev 6422, trunk/Lobby/TASClient/TipsFormUnit.dfm)
===================================================================
--- branches/0.77-branch/Lobby/TASClient/TipsFormUnit.dfm	                        (rev 0)
+++ branches/0.77-branch/Lobby/TASClient/TipsFormUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,173 @@
+object TipsForm: TTipsForm
+  Left = 512
+  Top = 149
+  BorderStyle = bsDialog
+  Caption = 'Tips'
+  ClientHeight = 317
+  ClientWidth = 370
+  Color = clBtnFace
+  Constraints.MaxHeight = 1000
+  Constraints.MaxWidth = 1680
+  Font.Charset = DEFAULT_CHARSET
+  Font.Color = clWindowText
+  Font.Height = -11
+  Font.Name = 'MS Sans Serif'
+  Font.Style = []
+  FormStyle = fsStayOnTop
+  OldCreateOrder = False
+  Position = poScreenCenter
+  Scaled = False
+  OnCreate = FormCreate
+  PixelsPerInch = 96
+  TextHeight = 13
+  object SpTBXTitleBar1: TSpTBXTitleBar
+    Left = 0
+    Top = 0
+    Width = 370
+    Height = 317
+    Caption = 'Tips'
+    FixedSize = True
+    Options.Maximize = False
+    object Panel2: TPanel
+      Left = 16
+      Top = 40
+      Width = 337
+      Height = 232
+      BevelInner = bvRaised
+      BevelOuter = bvLowered
+      Caption = 'Panel2'
+      TabOrder = 1
+      DesignSize = (
+        337
+        232)
+      object Panel1: TPanel
+        Left = 8
+        Top = 8
+        Width = 321
+        Height = 216
+        Anchors = [akLeft, akTop, akRight, akBottom]
+        BevelOuter = bvNone
+        Color = clInfoBk
+        TabOrder = 0
+        DesignSize = (
+          321
+          216)
+        object Label1: TLabel
+          Left = 72
+          Top = 24
+          Width = 170
+          Height = 28
+          Caption = 'Did you know ...'
+          Font.Charset = DEFAULT_CHARSET
+          Font.Color = clWindowText
+          Font.Height = -24
+          Font.Name = 'Arial'
+          Font.Style = [fsItalic]
+          ParentFont = False
+        end
+        object Image1: TImage
+          Left = 16
+          Top = 8
+          Width = 49
+          Height = 49
+          Picture.Data = {
+            0B544A76474946496D616765330700004749463839612D002D00F70100798956
+            FFFFFFCBD5A38C9576C1CA9BD9DCCCBDC894F0F0F1B5C284D1D5C2667741B9C3
+            92FCFCFAA0B15DA5B660D6D9CCD7D7D79AA4729AAA5AEAEAEAC9D39FCACAC6DF
+            DFDEA1AD6FAAAD9DD4DCB3C5CCABFAFAFA98A664DCE2C59FA48AE0E0E0C7CABB
+            F4F4F494A162DADADAB2B6A6D4D4D5AABB69FCFCFCA8B66CC2CD92D0D4BEF8F8
+            F8CBD1B4768B66E6EBD3CDD2BAEAEEDAD8D8D8919B6CA0AB74A9BA64C5C6BEA7
+            B865ADBC6DDEE2DBD1D9ADA0AE6AA3A989BAC58BAEBD71BCC989EDEEEAD6DDB8
+            F9FAF5B3C179CAD2ABF4F6EDEDF1E19BA965B7C18CB0BC82E6E6E8232F15A8B8
+            65CCD1BCDADAD89AA56ECDCEC997A65ADDDEDC959C7BB8BAB0D8DAD1F0F3E59D
+            A86FDCDCDCE5E5E7ADBA79EEEEEDB1BE7EBBBBBCA2B06D97A55FA1A886EAEBE5
+            E8EDD7919D65A0A979DDDEDADBDCD9A7B666C3CE94A9B189B6B9ADA8B966A6B5
+            6CA1A981AFBB7DA9B8709AA27BF1F1F2A5B567E3E3E5E0E1DCDADBD5D6D7D4C4
+            CF98B8BDA6B0B798ABB876A7AD92E7E9E29DA96B9DAD5BC3C4BEADB09CA6B664
+            A2B06AA7B863A6B762A6B761A7B862A6B763A8B963E9E9E9EDEDEDECECECEFEF
+            EFE7E7E7E2E2E2D0D0D0BFC2B3EEEEEEE3E3E3A6B862E8E8E8E4E4E4E5E5E4E6
+            E6E6A5B662D5D5D6A7B763EFEFF0A4B561CECECCE5E5E5D3D3D4A2AC7BD2D2D3
+            D7D8D5E7E7E6E2E2E1B1C076BBBDB2A4B269F3F3F3A5B565B4C37BFBFCF993A3
+            57D0D0CFA6B271D5DBC0C1C8A3C3CCA2EFEFEEE3E2E3E3E4E2C8CFADD0D7B5A4
+            B36DA8AB9BB3B5AAA8AC94A1A58FE4E9D0DFE5C88BAD71BEC0B99FAC6EEAEAE8
+            C6CEA8D3D4D19FAB70E1E1E1C4C4C3A2A692FBFBF892A96CA7B964F1F1F1ADBB
+            74BDC698828F4FBBBDB5BDBFB5A5AA8E809D6AD8E0BBE0E1DBE4E7DAE3E6DBE0
+            E5DDC0C2BA334020C1C2BC465B30CED8A99EAE5CB5BF8C9FAD69A5AF7E878D82
+            989E81F7F7F7DDDFD4A2B35FDFE2D4AFBC78A6B8639FA77DC7C8C3C3CAA7C4CC
+            A39BA182A6B564CBCBCBD0D6BAB5C37C7A8570B9C683939B72E9E9E8E4E4E5E0
+            E4D1A9B772EEEEEF9FA87CD4D7C8CBCCC7E7ECD5A4B65FF2F5E9FFFFFF21F904
+            010000FF002C000000002D002D000008FF00FF091C48B020C159632EE4E214C2
+            A0C387101F9EDA71E890A140F948D45911B1A3C77F27FED810344890201A8202
+            A1235166C3C797044BC521699266321A3674B04963E1044C8F4FBA1C2A59B366
+            C94328757C9932CAE74F831666D0205AB4EA511A862E7C7956E9E9402D6C5056
+            2544681055A3829002FAB5E31ABD9F2BF4A81164A8E8A0543E7A087270162DD2
+            76C3A0D598F09184199A466FF03B56A5438A1B65ABFAA511C78A473FA6861695
+            44C80E11550102300873464D5FC9E7D875AC73616AD542847AC0F3B18D1F8300
+            418098386DD2D021274D228A1AE35A3249420E1C98101024C0891C367817B281
+            21E2C443C68D0F5AB22B341121848C13FF42520C22039188B31B351126B42A1F
+            0EAA1A2A840244098832D3AB1FE4404D8EDB017C175E550E30E3CE240F05A5D9
+            7EC899E0032F0032B04D74451942C83DE370E1125452F1661421A408E04273A2
+            15418169AF5DA201165C38049658FBA9214015A13150843429F410D95848CC41
+            07060D1114D75C756537881A190008C31937F06796558598A1821CC144104B41
+            86E927D9203DB8705B1142F0E5E15E0B50F2401E5314544366631E47C80D76EC
+            62477CEA1922891B541043C01B410AC45A71D91532480A6798D08F0928669749
+            2197A88345025D5440D0708066076215A3D941A17A9910D2C61C64F0E0010303
+            29B34332EA7D9843680100A1A55D51AAFF500F0B7C0437D02DCDACC20D9D46DE
+            95813F5580972A999550B14575040180CD00DF782101398598948964650921CF
+            AB35D9E9460172AC1301220529A00438AC3C8206075034E0E12064B5C9A83A49
+            E8734F9AE162130F04253852031E5640C1CD26C36667E1A71F18C0A7410068D3
+            C208234080092815DCF189B3E4105564AA831482CA0B58BC10A9430328D00219
+            8D5830420C9878C289B9E8AA1BB0490E1CD14919088CEA9033004483C3049644
+            F2C115236092EFBEFDF601F07E92A0F0403DB4F031C243CA0CD08B359A283201
+            23941063B2C3104B4CB1C504BEC20815E620FB5036C8BC03CC018B2432C1249D
+            947C72CA2B9F9BEE591666318D9EDF46FFB4812E1C20F1CE1E076892882288F4
+            FC73D043F30B85D12669FC421209A0406F44E2A4138E08590C51CD2207406235
+            D65A37FC70C4133FEB40379544C1C3C11F9D208C0762B4024B395A1C808FDB70
+            CB8DB2CA2C7BF300162CE820E95316DC22830E0614F003DB8727EE33D042EBAB
+            0F2374D44CAA57FF20828B0C461CE10A18858B7E75D65B43C04823C1D4CA3D41
+            CAF82285175BD44278E8BCC76DC115913CB08CD9EF1BC80AF6C10E11E46108D4
+            3800F41067894644C10011784B000D72825018430CB6B0833D62018745402211
+            B260C21A2E3741878C020332F086013AF003381C800C08805D0921A28834CC83
+            03080002188A77BC197624047E9002E7107A60331F7E640315908218EAF09380
+            00003B}
+          Transparent = True
+        end
+        object mmTip: TTntMemo
+          Left = 16
+          Top = 64
+          Width = 289
+          Height = 136
+          Anchors = [akLeft, akTop, akRight, akBottom]
+          BorderStyle = bsNone
+          Color = clInfoBk
+          ReadOnly = True
+          TabOrder = 0
+        end
+      end
+    end
+    object btNextTip: TSpTBXButton
+      Left = 240
+      Top = 279
+      Width = 113
+      Height = 25
+      Caption = 'Next tip'
+      TabOrder = 2
+      OnClick = btNextTipClick
+      LinkFont.Charset = DEFAULT_CHARSET
+      LinkFont.Color = clBlue
+      LinkFont.Height = -11
+      LinkFont.Name = 'MS Sans Serif'
+      LinkFont.Style = [fsUnderline]
+    end
+    object chkShowTips: TSpTBXCheckBox
+      Left = 16
+      Top = 279
+      Width = 64
+      Height = 15
+      Caption = 'Show tips'
+      TabOrder = 3
+      Checked = True
+      State = cbChecked
+    end
+  end
+end

Copied: branches/0.77-branch/Lobby/TASClient/TipsFormUnit.pas (from rev 6422, trunk/Lobby/TASClient/TipsFormUnit.pas)
===================================================================
--- branches/0.77-branch/Lobby/TASClient/TipsFormUnit.pas	                        (rev 0)
+++ branches/0.77-branch/Lobby/TASClient/TipsFormUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,130 @@
+unit TipsFormUnit;
+
+interface
+
+uses
+  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
+  Dialogs, SpTBXItem, JvGIF, ExtCtrls, StdCtrls, SpTBXControls, TBXDkPanels,
+  TntStdCtrls,JclUnicode, Math;
+
+type
+  TTip = record
+    Msg: string;
+    Form: integer;
+  end;
+  PTip = ^TTip;
+
+  TTipsForm = class(TForm)
+    SpTBXTitleBar1: TSpTBXTitleBar;
+    Panel2: TPanel;
+    Panel1: TPanel;
+    Label1: TLabel;
+    Image1: TImage;
+    btNextTip: TSpTBXButton;
+    chkShowTips: TSpTBXCheckBox;
+    mmTip: TTntMemo;
+    procedure FormCreate(Sender: TObject);
+    procedure btNextTipClick(Sender: TObject);
+  protected
+    TipList: TList;
+    CurrentFormTipList: TList;
+    currentForm: integer;
+    currentTip: integer;
+  private
+    { Private declarations }
+  public
+    property Tips : TList read TipList;
+    procedure LoadTips;
+    procedure ShowTips(tipType: integer = 0; forceShow: boolean = false);
+  end;
+
+var
+  TipsForm: TTipsForm;
+
+implementation
+
+uses Misc,MainUnit, StrUtils, BattleFormUnit, ReplaysUnit, PreferencesFormUnit;
+
+{$R *.dfm}
+
+procedure TTipsForm.LoadTips;
+var
+  rawTips : string;
+  rawTipsList: TStringList;
+  rawTip: string;
+  t : PTip;
+  i,j: integer;
+  tipAdded: boolean;
+begin
+  try
+    rawTips := ReadFile2(VAR_FOLDER+'\tips.txt');
+  except
+    MessageDlg(VAR_FOLDER+'\tips.txt not found.',mtError,[mbOK],0);
+    Exit;
+  end;
+
+  rawTipsList := TStringList.Create;
+  ParseDelimited(rawTipsList,rawTips,EOL+'##','');
+
+  for i:=0 to rawTipsList.Count-1 do
+  begin
+    rawTip := rawTipsList[i];
+    if rawTip = '' then
+      Continue;
+
+    New(t);
+    t.Msg := MidStr(rawTip,3,High(Integer));
+    t.Form := StrToInt(rawTip[1]);
+
+    TipList.Add(t);
+
+  end;
+end;
+
+procedure TTipsForm.ShowTips(tipType: integer = 0; forceShow: boolean = false);
+var
+  i: integer;
+begin
+  if not chkShowTips.Checked and not forceShow then Exit;
+
+  currentForm := tipType;
+
+  CurrentFormTipList.Clear;
+  for i := 0 to TipList.Count-1 do
+    if PTip(TipList[i]).Form = currentForm then
+      CurrentFormTipList.Add(TipList[i]);
+
+  if CurrentFormTipList.Count &gt; 0 then
+  begin
+    currentTip := -1;
+    btNextTipClick(nil);
+    Show;
+  end;
+end;
+
+procedure TTipsForm.FormCreate(Sender: TObject);
+begin
+  TipList := TList.Create;
+  CurrentFormTipList := TList.Create;
+
+  if not SpTBXTitleBar1.Active then
+    RemoveSpTBXTitleBarMarges(self);
+
+  LoadTips;
+end;
+
+procedure TTipsForm.btNextTipClick(Sender: TObject);
+var
+  i: integer;
+  firstPrio0 : integer;
+  rnd : integer;
+begin
+  rnd := RandomRange(0,CurrentFormTipList.Count-1);;
+  while (rnd = currentTip) and (CurrentFormTipList.Count &gt; 1) do
+    rnd := RandomRange(0,CurrentFormTipList.Count-1);
+  currentTip := rnd;
+
+  mmTip.Text := PTip(CurrentFormTipList[currentTip]).Msg;
+end;
+
+end.

Modified: branches/0.77-branch/Lobby/TASClient/UploadReplayUnit.dfm
===================================================================
--- branches/0.77-branch/Lobby/TASClient/UploadReplayUnit.dfm	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/UploadReplayUnit.dfm	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,9 +1,10 @@
 object UploadReplayForm: TUploadReplayForm
-  Left = 586
-  Top = 410
-  Width = 410
-  Height = 307
-  Caption = 'UploadReplayForm'
+  Left = 1115
+  Top = 234
+  BorderStyle = bsDialog
+  Caption = 'Upload replay'
+  ClientHeight = 345
+  ClientWidth = 407
   Color = clBtnFace
   Constraints.MaxHeight = 1000
   Constraints.MaxWidth = 1680
@@ -16,64 +17,107 @@
   Position = poScreenCenter
   Scaled = False
   OnActivate = FormActivate
+  OnCreate = FormCreate
   PixelsPerInch = 96
   TextHeight = 13
   object SpTBXTitleBar1: TSpTBXTitleBar
     Left = 0
     Top = 0
-    Width = 402
-    Height = 280
+    Width = 407
+    Height = 345
     Caption = 'Upload replay'
     Options.Maximize = False
-    object SpTBXLabel2: TSpTBXLabel
+    object SpTBXGroupBox1: TSpTBXGroupBox
       Left = 16
       Top = 40
-      Width = 59
-      Height = 13
-      Caption = 'Description :'
-      LinkFont.Charset = DEFAULT_CHARSET
-      LinkFont.Color = clBlue
-      LinkFont.Height = -11
-      LinkFont.Name = 'MS Sans Serif'
-      LinkFont.Style = [fsUnderline]
+      Width = 377
+      Height = 233
+      Caption = 'Upload Description'
+      TabOrder = 1
+      object DescriptionRtBox: TRichEdit
+        Left = 8
+        Top = 24
+        Width = 361
+        Height = 201
+        Lines.Strings = (
+          'DescriptionRtBox')
+        TabOrder = 0
+      end
     end
-    object CancelButton: TSpTBXButton
-      Left = 213
-      Top = 240
-      Width = 73
-      Height = 25
-      Caption = 'Cancel'
+    object SpTBXGroupBox2: TSpTBXGroupBox
+      Left = 16
+      Top = 280
+      Width = 377
+      Height = 49
+      Caption = 'Action'
+      Font.Charset = DEFAULT_CHARSET
+      Font.Color = clWindowText
+      Font.Height = -11
+      Font.Name = 'MS Sans Serif'
+      Font.Style = [fsBold]
+      ParentFont = False
       TabOrder = 2
-      OnClick = CancelButtonClick
-      LinkFont.Charset = DEFAULT_CHARSET
-      LinkFont.Color = clBlue
-      LinkFont.Height = -11
-      LinkFont.Name = 'MS Sans Serif'
-      LinkFont.Style = [fsUnderline]
+      object UploadButton: TSpTBXButton
+        Left = 40
+        Top = 16
+        Width = 89
+        Height = 25
+        Caption = 'Upload &amp;&amp; Keep'
+        Font.Charset = DEFAULT_CHARSET
+        Font.Color = clWindowText
+        Font.Height = -11
+        Font.Name = 'MS Sans Serif'
+        Font.Style = []
+        ParentFont = False
+        TabOrder = 0
+        OnClick = UploadButtonClick
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
+      object CancelButton: TSpTBXButton
+        Left = 144
+        Top = 16
+        Width = 89
+        Height = 25
+        Caption = 'Keep'
+        Font.Charset = DEFAULT_CHARSET
+        Font.Color = clWindowText
+        Font.Height = -11
+        Font.Name = 'MS Sans Serif'
+        Font.Style = [fsBold]
+        ParentFont = False
+        TabOrder = 1
+        OnClick = CancelButtonClick
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
+      object DeleteButton: TSpTBXButton
+        Left = 248
+        Top = 16
+        Width = 89
+        Height = 25
+        Caption = 'Delete'
+        Font.Charset = DEFAULT_CHARSET
+        Font.Color = clWindowText
+        Font.Height = -11
+        Font.Name = 'MS Sans Serif'
+        Font.Style = []
+        ParentFont = False
+        TabOrder = 2
+        OnClick = DeleteButtonClick
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
     end
-    object UploadButton: TSpTBXButton
-      Left = 117
-      Top = 240
-      Width = 73
-      Height = 25
-      Caption = 'Upload'
-      TabOrder = 3
-      OnClick = UploadButtonClick
-      LinkFont.Charset = DEFAULT_CHARSET
-      LinkFont.Color = clBlue
-      LinkFont.Height = -11
-      LinkFont.Name = 'MS Sans Serif'
-      LinkFont.Style = [fsUnderline]
-    end
-    object DescriptionRtBox: TRichEdit
-      Left = 88
-      Top = 40
-      Width = 305
-      Height = 193
-      Lines.Strings = (
-        'DescriptionRtBox')
-      TabOrder = 4
-    end
   end
   object IdHTTP1: TIdHTTP
     MaxLineAction = maException

Modified: branches/0.77-branch/Lobby/TASClient/UploadReplayUnit.pas
===================================================================
--- branches/0.77-branch/Lobby/TASClient/UploadReplayUnit.pas	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/Lobby/TASClient/UploadReplayUnit.pas	2008-09-15 18:44:36 UTC (rev 6427)
@@ -11,17 +11,21 @@
 type
   TUploadReplayForm = class(TForm)
     SpTBXTitleBar1: TSpTBXTitleBar;
-    SpTBXLabel2: TSpTBXLabel;
-    CancelButton: TSpTBXButton;
-    UploadButton: TSpTBXButton;
-    DescriptionRtBox: TRichEdit;
     IdHTTP1: TIdHTTP;
     IdAntiFreeze1: TIdAntiFreeze;
+    SpTBXGroupBox1: TSpTBXGroupBox;
+    DescriptionRtBox: TRichEdit;
+    SpTBXGroupBox2: TSpTBXGroupBox;
+    UploadButton: TSpTBXButton;
+    CancelButton: TSpTBXButton;
+    DeleteButton: TSpTBXButton;
     procedure UploadButtonClick(Sender: TObject);
     procedure IdHTTP1Work(Sender: TObject; AWorkMode: TWorkMode;
       const AWorkCount: Integer);
     procedure FormActivate(Sender: TObject);
     procedure CancelButtonClick(Sender: TObject);
+    procedure FormCreate(Sender: TObject);
+    procedure DeleteButtonClick(Sender: TObject);
   private
     { Private declarations }
   public
@@ -31,6 +35,7 @@
     ModName : string;
     NbPlayers : string;
     UploadedReplayId : string;
+    AutoUpload: boolean;
   end;
   TUploadThread = class(TTASClientThread)
   private
@@ -53,6 +58,11 @@
 
 procedure TUploadReplayForm.UploadButtonClick(Sender: TObject);
 begin
+  if not (Status.LoggedIn and (MainForm.Socket.Addr = 'taspringmaster.clan-sy.com')) then
+  begin
+    MessageDlg('You need to be logged into the official server to be able to upload replays using the lobby.',mtWarning,[mbOk],0);
+    Exit;
+  end;
   ProgressBarForm.TakeAction := 1;
   ProgressBarForm.ShowModal;
 end;
@@ -89,8 +99,8 @@
     MultiPartFormDataStream.Free;
     ResponseStream.Free;
     PostMessage(ProgressBarForm.Handle, WM_CLOSE, 0, 0); // close form
-    MainForm.AddMainLog('Replays server unavailable !',Colors.Error);
-    MessageDlgThread('Replays server unavailable !',mtError,[mbOK],0);
+    MainForm.AddMainLog('Replays server unavailable or upload cancelled !',Colors.Error);
+    MessageDlgThread('Replays server unavailable or upload cancelled !',mtError,[mbOK],0);
     PostMessage(Handle, WM_CLOSE, 0, 0); // close form
   end;
   MultiPartFormDataStream.Free;
@@ -99,13 +109,13 @@
   Misc.ParseDelimited(ResponseStrList,ResponseStr,' ','');
   if (ResponseStrList.Count &gt; 0) and (ResponseStrList[0] = 'SUCCESS') then begin
     MessageDlgThread('Your replay has been successfully uploaded. Its link has been added to your clipboard.', mtInformation,[mbOk], 0);
-    //Clipboard.Open;
-    //Clipboard.SetTextBuf(PChar('<A HREF="http://replays.unknown-files.net/?">http://replays.unknown-files.net/?</A>'+ResponseStrList[1]));
-    //Clipboard.Close;
+    Clipboard.Open;
+    Clipboard.SetTextBuf(PChar(ResponseStrList[1]));
+    Clipboard.Close;
     UploadedReplayId := ResponseStrList[1];
   end
   else
-    MessageDlgThread(ResponseStr, mtError,[mbOk], 0);
+    MessageDlgThread('The upload failed. Contact TradeMark in the lobby to get help.', mtError,[mbOk], 0);
   PostMessage(Handle, WM_CLOSE, 0, 0); // close form
   end;
 end;
@@ -142,7 +152,21 @@
 
 procedure TUploadReplayForm.CancelButtonClick(Sender: TObject);
 begin
-  PostMessage(Handle, WM_CLOSE, 0, 0); // close form
+  Close;
 end;
 
+procedure TUploadReplayForm.FormCreate(Sender: TObject);
+begin
+  if not SpTBXTitleBar1.Active then
+    RemoveSpTBXTitleBarMarges(self);
+end;
+
+procedure TUploadReplayForm.DeleteButtonClick(Sender: TObject);
+begin
+  DeleteFile(FileName);
+  if not AutoUpload then
+    ReplaysForm.ReloadButtonClick(nil);
+  Close;
+end;
+
 end.

Copied: branches/0.77-branch/Lobby/TASClient/lobby/var/tips.txt (from rev 6422, trunk/Lobby/TASClient/lobby/var/tips.txt)
===================================================================
--- branches/0.77-branch/Lobby/TASClient/lobby/var/tips.txt	                        (rev 0)
+++ branches/0.77-branch/Lobby/TASClient/lobby/var/tips.txt	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,41 @@
+
+##1#To make new boxes when you are hosting, you can use the Auto-boxing options (right click on the minimap), or draw them yourself. To draw a box, simply hold SHIFT and then draw it on the minimap. You can also move it with CTRL + Drag.
+##2#The 'Lineage' Game end condition is an improved 'Game ends if commander dies'. If your commander dies, every units you've made will explode. So you can't share units just before your commander dies.
+##1#To kick, change the color, change the team or change every players parameters when you are hosting a battle, use the Players context menu : right click on someone in the Battle Window players list.
+##1#To make your hosting experience easier, you can use the Admin menu. You can save the boxes for the current map, they will be reloaded each time you will load the map. You can fix the colors to have different colors for every players. You can balance the teams ...
+##2#Pick a team, an id, a color and a side, or check the Spectator option, then click on 'Im ready'.
+##1#To delete a box, move your mouse cursor over a box and then hit the &quot;Delete&quot; key. You can also change the number of a box by moving your mouse cursor over a box and hit one of the number key : 1 2 ...
+##1#You can pick your map using the 'More maps' button next to the minimap or using the down arrow button next to 'More maps'. The map list window display more informations like the minimap or the size.
+##0#If you want to see the whole server player list, switch to the $local tab.
+##0#If you want to join a new channel type : /j #channel_name
+##0#If you want to rename your account, type : /rename new_name
+##0#If you want to play competitive games, you can join or host Ladder battles. Each game you win increase your rating points,and each game you loose decrease it. The three best players of each ladder (with at least 15 players and 45 battles) have a cup before their name in the lobby. You can have more than one cup.
+##0#You can make groups of players. Players in a group are highlighted in the player list with the group's color. You can sort the players by group. Few options are available per groups (highlight battles, auto-kick, notify when hosting ...) . To add someone to a group, right click on his nick and use the 'Add to group' menu. You can manage the groups (enable or disable an option, delete a group etc) with the Manage Group Window (right click on any player nick then 'Manage group'). The manage goup window is also available in the Options -&gt; Programs -&gt; Manage groups.
+##0#You can right click on a player name in the chat to display the Player context menu. You can also double-click on it to open a private chat tab.
+##0#In a ladder battle, you can use the bottom right button of the Battle Window to read the ladder rules, refresh the ranks and cups or refresh the available maps.
+##0#You can filter the battles to only see the battles you like. To display the filter panel, use bottom up arrow in the Main Window. You can save your filters in a preset and switch from one preset to another by selecting it in the preset list.
+##0#You can change the font name and colors in the Options -&gt; Programs -&gt; Colors and Font.
+##0#You can mark the unknown map and mods with a special colors in the battle list : Options -&gt; Interface -&gt; Mark unknown maps/mods
+##0#You can hide the 'Quick join panel' between the chat and the battle list: Options -&gt; Interface -&gt; Display Quickjoin panel
+##0#You can disable SpringDownloader in Options -&gt; Program -&gt; Enable Spring Downloader
+##0#You can add notifications (Options -&gt; Program -&gt; Notifications) when a player join a channel, a player join the battle you are participating in, a player join a battle you are hosting, a player changes his status to in-battle, a player host a battle with a specified mod.
+##0#You can switch between the Main Window and the Battle Window with the F2 key.
+##2#You can see units names and icons in the disable tab of the Battle Window (but loading will be a bit slower) : Options -&gt; Interface -&gt; Load units icons and names when joining
+##0#You can auto complete name with the TAB key, by default it will auto complete the name using the complete list of players, but you can check the Program -&gt; Interface -&gt; Auto-completion from current channel's players list option.
+##0#You can add commands te be executed when logging in : Options -&gt; Server -&gt; Performs
+##0#Every battle you play is recorded in Spring\Demos\ . Open the Replays Window to list them.
+##4#You can filter the displayed replays with the top down arrow. You can rate the replay, add comments or delete it.
+##0#You can move the column of the Main Window's Battle list, the Battle Window's Player list or the Replay List by dragging them to left or right.
+##0#You can rate your maps and add comments to it in the Map List Window : 'More maps' in the Battle Window next to the minimap.
+##0#You can disable all notifications in the state menu : Down arrow next to the top left login button of the Main Window.
+##0#You can highlight specific words and get notifications when they are found : Options -&gt; Program -&gt; Highlighting
+##0#You can host replays to share your battle experiences or make a battle debriefing with your friends : Host battle -&gt; Host replay.
+##0#If the chat logging is enabled (Options -&gt; Program -&gt; Enable logging), every message in every channel or private chat will be saved in Spring\lobby\logs.
+##0#You can resize the top panel in the Battle Window to get a bigger minimap. You can also respect or not the minimap ratio : right click on it and enable/disable the 'Keep Ratio'.
+##4#To delete multiple replays, you can use the filters to only display the ones you want to remove (eg: replays with file size &lt; 20kB) and then use the 'Delete all visible' button.
+##4#To change the replay's grade and/or comment, use the 'Save' button after the changes are made.
+##4#The green players in the list are the winners.
+
+The winning team is only stored in the replay if you got the battle end statistics page. The players statistics are only stored if the player didn't leave before the end of the game.
+##0#To choose if you want to keep the replay, delete it or upload it after each battle, you can enable the Options -&gt; Interface -&gt; 'Ask what to do with replays after each battle'.
+##0#You can double click on a map name (eg: double click on the map_name.smf when someone suggests a map) in the chat to load it if you are hosting or not in a battle.
\ No newline at end of file

Modified: branches/0.77-branch/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
===================================================================
--- branches/0.77-branch/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-09-15 18:44:36 UTC (rev 6427)
@@ -116,10 +116,10 @@
 }
 
 
-float waveIntensity(const float x, const float step) {
-  float front = 1.0-(abs(x-step))/(1.0-step);
-  //float front = smoothstep(1.0-step,0.0,abs(x-step));
-  if (x&lt;step)
+float waveIntensity(const float x) {
+  //float front = smoothstep(1.0-0.85,0.0,abs(x-0.85));
+  float front = 1.0-(abs(x-0.85))/(1.0-0.85);
+  if (x&lt;0.85)
     return max(front,x*0.5);
   else
     return front;
@@ -232,33 +232,34 @@
 #ifdef use_shorewaves
     vec3 shorewavesColor = vec3(0.0);
     float inwaterdepth = 1.0-waterdepth;
-    //if (waterdepth&lt;1.0) {
-      float coastdist = texture2D(coastmap, gl_TexCoord[0].st ).r + octave3.x*0.1; //FIXME
-      //if (coastdist&gt;0.0 &amp;&amp; coastdist&lt;0.25) {
-        vec3 wavefoam  = texture2D(foam, gl_TexCoord[0].st*160.0+frame ).rgb;
-        wavefoam += texture2D(foam, gl_TexCoord[0].st*90.0+frame ).rgb;
+    if (waterdepth&lt;1.0) {
+      float coastdist = texture2D(coastmap, gl_TexCoord[0].st ).r + octave3.x*0.1;
+      if (coastdist&gt;0.0) {
+
+        vec3 wavefoam  = texture2D(foam, gl_TexCoord[3].st ).rgb;
+        wavefoam += texture2D(foam, gl_TexCoord[3].pq ).rgb;
         wavefoam *= 0.5;
 
-        vec2 wrcoord = gl_TexCoord[0].st*2.0;
+        vec2 wrcoord = gl_TexCoord[4].st;
 
         float fframe = fract(frame);
         for (float i=0.0; i&lt;1.0; i+=0.25) {
-          float wave  = i+fframe*50.0;
+          float wave  = i + fframe * 50.0;
           float wavef = fract(wave);
                 wave -= wavef;
-          float frac  = wavef*1.4-0.2;
-          float f = frac-coastdist;
+          float frac  = wavef * 1.4 - 0.2;
+          float f = frac - coastdist;
           if (abs(f)&gt;WavesLength) continue;
-          float rand = texture2D(waverand, wrcoord+wave*0.37+i ).r;
-          float f2   = waveIntensity( min(1.0,(WavesLength-f)*InvWavesLength) ,0.85);
-          shorewavesColor += wavefoam*f2*rand;
+          float rand = texture2D(waverand, wrcoord + wave * 0.37 + i ).r;
+          float f2   = waveIntensity( min(1.0, (WavesLength - f) * InvWavesLength));
+          shorewavesColor += wavefoam * f2 * rand;
         }
 
         shorewavesColor *= coastdist;
-      //}
-    //}
+      }
+    }
     float iwd = smoothlimit(inwaterdepth, 0.8);
-    gl_FragColor.rgb += shorewavesColor*iwd*1.5;
+    gl_FragColor.rgb += shorewavesColor * iwd * 1.5;
 #endif
 
 

Modified: branches/0.77-branch/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
===================================================================
--- branches/0.77-branch/installer/builddata/springcontent/shaders/bumpWaterVS.glsl	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/installer/builddata/springcontent/shaders/bumpWaterVS.glsl	2008-09-15 18:44:36 UTC (rev 6427)
@@ -35,6 +35,7 @@
 // #define PerlinStartFreq  float
 // #define PerlinLacunarity float
 // #define PerlinAmp        float
+// #define TexGenPlane      vec4
 
 //////////////////////////////////////////////////
 // possible flags are:
@@ -58,17 +59,15 @@
 	gl_Position = ftransform();
 
 	// COMPUTE TEXCOORDS
-	vec4 planes        = vec4(gl_ObjectPlaneS[0].x,gl_ObjectPlaneT[0].z,
-	                          gl_ObjectPlaneR[0].x,gl_ObjectPlaneQ[0].z);
-	gl_TexCoord[0]     = planes*gl_Vertex.xzxz;
+	gl_TexCoord[0]     = TexGenPlane*gl_Vertex.xzxz;
 
 	// COMPUTE WAVE TEXTURE COORDS
 	const float fstart = PerlinStartFreq;
 	const float f      = PerlinLacunarity;
-	gl_TexCoord[1].st = (vec2(-1.0,-1.0)+gl_TexCoord[0].st+0.75)*fstart      +frame*Speed;
-	gl_TexCoord[1].pq = (vec2(-1.0, 1.0)+gl_TexCoord[0].st+0.50)*fstart*f    -frame*Speed;
-	gl_TexCoord[2].st = (vec2( 1.0,-1.0)+gl_TexCoord[0].st+0.25)*fstart*f*f  +frame*Speed*vec2(1.0,-1.0);
-	gl_TexCoord[2].pq = (vec2( 1.0, 1.0)+gl_TexCoord[0].st+0.00)*fstart*f*f*f+frame*Speed*vec2(-1.0,1.0);
+	gl_TexCoord[1].st = (vec2(-1.0,-1.0) + gl_TexCoord[0].st + 0.75) * fstart       + frame * Speed;
+	gl_TexCoord[1].pq = (vec2(-1.0, 1.0) + gl_TexCoord[0].st + 0.50) * fstart*f     - frame * Speed;
+	gl_TexCoord[2].st = (vec2( 1.0,-1.0) + gl_TexCoord[0].st + 0.25) * fstart*f*f   + frame * Speed * vec2(1.0,-1.0);
+	gl_TexCoord[2].pq = (vec2( 1.0, 1.0) + gl_TexCoord[0].st + 0.00) * fstart*f*f*f + frame * Speed * vec2(-1.0,1.0);
 
 	// COMPUTE LIGHT VECTORS
 	eyeVec = eyePos - gl_Vertex.xyz;
@@ -77,4 +76,8 @@
 	// FOG
 	gl_FogFragCoord = (gl_ModelViewMatrix*gl_Vertex).z;
 
+
+	gl_TexCoord[3].st = gl_TexCoord[0].st * 160.0 + frame;
+	gl_TexCoord[3].pq = gl_TexCoord[0].st * 90.0  + frame;
+	gl_TexCoord[4].st = gl_TexCoord[0].st * 2.0;
 }

Modified: branches/0.77-branch/installer/sections/main.nsh
===================================================================
--- branches/0.77-branch/installer/sections/main.nsh	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/installer/sections/main.nsh	2008-09-15 18:44:36 UTC (rev 6427)
@@ -32,7 +32,7 @@
 ;New Settings Program
 
   inetc::get \
-  &quot;<A HREF="http://installer.clan-sy.com/springsettings.exe">http://installer.clan-sy.com/springsettings.exe</A>&quot; &quot;$INSTDIR\springsettings.exe&quot; 
+  &quot;<A HREF="http://www.springlobby.info/installer/springsettings.exe">http://www.springlobby.info/installer/springsettings.exe</A>&quot; &quot;$INSTDIR\springsettings.exe&quot; 
 
   File &quot;..\external\mingwm10.dll&quot;
   File &quot;..\external\wxbase28u_gcc_custom.dll&quot;

Modified: branches/0.77-branch/rts/CMakeLists.txt
===================================================================
--- branches/0.77-branch/rts/CMakeLists.txt	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/CMakeLists.txt	2008-09-15 18:44:36 UTC (rev 6427)
@@ -9,6 +9,16 @@
 	ADD_DEFINITIONS(-DUSE_GML)
 endif (USE_GML)
 
+SET(TRACE_SYNC FALSE CACHE BOOL &quot;Enable sync tracker&quot;)
+if (TRACE_SYNC)
+	ADD_DEFINITIONS(-DTRACE_SYNC)
+endif (TRACE_SYNC)
+
+SET(SYNCDEBUG FALSE CACHE BOOL &quot;Enable sync debugger (needs SYNCCHECK=true)&quot;)
+if (SYNCDEBUG)
+	ADD_DEFINITIONS(-DSYNCDEBUG)
+endif (SYNCDEBUG)
+
 IF (UNIX)
 	ADD_DEFINITIONS(-DNO_AVI)
 ELSEIF (UNIX)

Modified: branches/0.77-branch/rts/Game/Game.cpp
===================================================================
--- branches/0.77-branch/rts/Game/Game.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Game/Game.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -3064,8 +3064,8 @@
 	ASSERT_SYNCED_MODE;
 
 #ifdef TRACE_SYNC
-	uh-&gt;CreateChecksum();
-	tracefile &lt;&lt; &quot;New frame:&quot; &lt;&lt; gs-&gt;frameNum &lt;&lt; &quot; &quot; &lt;&lt; gs-&gt;randSeed &lt;&lt; &quot;\n&quot;;
+	//uh-&gt;CreateChecksum();
+	tracefile &lt;&lt; &quot;New frame:&quot; &lt;&lt; gs-&gt;frameNum &lt;&lt; &quot; &quot; &lt;&lt; gs-&gt;GetRandSeed() &lt;&lt; &quot;\n&quot;;
 #endif
 
 #ifdef USE_MMGR
@@ -3971,8 +3971,7 @@
 			}
 			default: {
 #ifdef SYNCDEBUG
-				lastLength = CSyncDebugger::GetInstance()-&gt;ClientReceived(&amp;inbuf[inbufpos]);
-				if (!lastLength)
+				if (!CSyncDebugger::GetInstance()-&gt;ClientReceived(inbuf))
 #endif
 				{
 					logOutput.Print(&quot;Unknown net msg in client %d&quot;, (int) inbuf[0]);

Modified: branches/0.77-branch/rts/Game/GameHelper.h
===================================================================
--- branches/0.77-branch/rts/Game/GameHelper.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Game/GameHelper.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -27,7 +27,7 @@
 {
 public:
 	CGameHelper(CGame* game);
-	virtual ~CGameHelper();
+	~CGameHelper();
 	bool TestAllyCone(const float3&amp; from, const float3&amp; dir, float length, float spread, int allyteam, CUnit* owner);
 	bool TestNeutralCone(const float3&amp; from, const float3&amp; dir, float length, float spread, CUnit* owner);
 	bool TestTrajectoryAllyCone(const float3 &amp;from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, int allyteam, CUnit* owner);

Modified: branches/0.77-branch/rts/Game/GameServer.cpp
===================================================================
--- branches/0.77-branch/rts/Game/GameServer.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Game/GameServer.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -215,7 +215,7 @@
 		CommandMessage msg(str( boost::format(&quot;skip start %d&quot;) %targetframe ), SERVER_PLAYER);
 		Broadcast(boost::shared_ptr&lt;const netcode::RawPacket&gt;(msg.Pack()));
 		// fast-read and send demo data
-		while (serverframenum &lt; targetframe)
+		while (serverframenum &lt; targetframe &amp;&amp; demoReader)
 		{
 			modGameTime = demoReader-&gt;GetNextReadTime()+0.1f; // skip time
 			SendDemoData(true);
@@ -360,7 +360,12 @@
 
 				// TODO enable this when we have resync
 				//serverNet-&gt;SendPause(SERVER_PLAYER, true);
-
+#ifdef SYNCDEBUG
+				CSyncDebugger::GetInstance()-&gt;ServerTriggerSyncErrorHandling(serverframenum);
+				Broadcast(CBaseNetProtocol::Get().SendPause(gu-&gt;myPlayerNum, true));
+				IsPaused = true;
+				Broadcast(CBaseNetProtocol::Get().SendSdCheckrequest(serverframenum));
+#endif
 				//For each group, output a message with list of playernames in it.
 				// TODO this should be linked to the resync system so it can roundrobin
 				// the resync checksum request packets to multiple clients in the same group.
@@ -868,6 +873,17 @@
 			Warning(str(format(UnknownNetmsg) %(unsigned)inbuf[0] %a));
 #endif
 			break;
+#ifdef SYNCDEBUG
+		case NETMSG_SD_CHKRESPONSE:
+		case NETMSG_SD_BLKRESPONSE:
+			CSyncDebugger::GetInstance()-&gt;ServerReceived(inbuf);
+			break;
+		case NETMSG_SD_CHKREQUEST:
+		case NETMSG_SD_BLKREQUEST:
+		case NETMSG_SD_RESET:
+			Broadcast(packet);
+			break;
+#endif
 		default:
 		{
 			Warning(str(format(UnknownNetmsg) %(unsigned)inbuf[0] %a));
@@ -979,7 +995,7 @@
 			if (!players[a] || !players[a]-&gt;readyToStart) {
 				allReady = false;
 				break;
-			} else if (!teams[players[a]-&gt;team]-&gt;readyToStart &amp;&amp; !demoReader)
+			} else if (teams[players[a]-&gt;team] &amp;&amp; !teams[players[a]-&gt;team]-&gt;readyToStart &amp;&amp; !demoReader)
 			{
 				allReady = false;
 				break;

Modified: branches/0.77-branch/rts/Game/GameSetup.cpp
===================================================================
--- branches/0.77-branch/rts/Game/GameSetup.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Game/GameSetup.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -187,7 +187,7 @@
 			data.countryCode = it-&gt;second;
 		if ((it = setup.find(&quot;spectator&quot;)) != setup.end())
 			data.spectator = static_cast&lt;bool&gt;(atoi(it-&gt;second.c_str()));
-		if ((it = setup.find(&quot;IsFromDemo&quot;)) != setup.end())
+		if ((it = setup.find(&quot;isfromdemo&quot;)) != setup.end())
 			data.isFromDemo = static_cast&lt;bool&gt;(atoi(it-&gt;second.c_str()));
 
 		if (data.isFromDemo)

Modified: branches/0.77-branch/rts/Game/PreGame.cpp
===================================================================
--- branches/0.77-branch/rts/Game/PreGame.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Game/PreGame.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -88,7 +88,12 @@
 
 	if(server){
 		net-&gt;InitLocalClient(gameSetup ? gameSetup-&gt;myPlayerNum : 0);
-		if(gameSetup){
+		if (!demoFile.empty())
+		{
+			ReadDataFromDemo(demoFile);
+			state = WAIT_CONNECTING;
+		}
+		else if(gameSetup){
 			StartServer(gameSetup-&gt;mapName, gameSetup-&gt;baseMod, gameSetup-&gt;scriptName);
 			state = WAIT_CONNECTING;
 		} else if (hasSave) {
@@ -234,9 +239,9 @@
 				break;
 			case WAIT_CONNECTING:
 				if ( ((SDL_GetTicks()/1000) % 2) == 0 )
-					PrintLoadMsg(&quot;Connecting to server .&quot;);
+					PrintLoadMsg(&quot;Connecting to server .&quot;, false);
 				else
-					PrintLoadMsg(&quot;Connecting to server  &quot;);
+					PrintLoadMsg(&quot;Connecting to server  &quot;, false);
 				break;
 			case UNKNOWN:
 			case WAIT_ON_ADDRESS:
@@ -473,6 +478,7 @@
 
 void CPreGame::ReadDataFromDemo(const std::string&amp; demoName)
 {
+	assert(!gameServer);
 	logOutput.Print(&quot;Pre-scanning demo file for game data...&quot;);
 	bool hasSetup = static_cast&lt;bool&gt;(gameSetup);
 	CDemoReader scanner(demoName, 0);
@@ -484,7 +490,8 @@
 		gu-&gt;LoadFromSetup(gameSetup);
 	}
 
-	gu-&gt;myPlayerNum = scanner.GetFileHeader().maxPlayerNum + 1;
+	if (!hasSetup)
+		gu-&gt;myPlayerNum = scanner.GetFileHeader().maxPlayerNum + 1;
 
 	boost::shared_ptr&lt;const RawPacket&gt; buf(scanner.GetData(static_cast&lt;float&gt;(INT_MAX)));
 	while ( buf )
@@ -493,7 +500,7 @@
 		{
 			GameData *data = new GameData(boost::shared_ptr&lt;const RawPacket&gt;(buf));
 			good_fpu_control_registers(&quot;before CGameServer creation&quot;);
-			gameServer = new CGameServer(springDefaultPort, false, data, gameSetup, demoName);
+			gameServer = new CGameServer(hasSetup ? gameSetup-&gt;hostport : springDefaultPort, false, data, gameSetup, demoName);
 			gameServer-&gt;AddLocalClient(gameSetup ? gameSetup-&gt;myPlayerNum : 0);
 			good_fpu_control_registers(&quot;after CGameServer creation&quot;);
 			break;
@@ -505,6 +512,7 @@
 		}
 		buf.reset(scanner.GetData(static_cast&lt;float&gt;(INT_MAX)));
 	}
+	assert(gameServer);
 }
 
 

Modified: branches/0.77-branch/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/0.77-branch/rts/Game/UI/MiniMap.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Game/UI/MiniMap.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -969,14 +969,12 @@
 
 void CMiniMap::DrawSquare(const float3&amp; pos, float xsize, float zsize)
 {
-	glPushMatrix();
 	glBegin(GL_LINE_LOOP);
 		glVertex3f(pos.x + xsize, 0.0f, pos.z + zsize);
 		glVertex3f(pos.x - xsize, 0.0f, pos.z + zsize);
 		glVertex3f(pos.x - xsize, 0.0f, pos.z - zsize);
 		glVertex3f(pos.x + xsize, 0.0f, pos.z - zsize);
 	glEnd();
-	glPopMatrix();
 }
 
 
@@ -1002,14 +1000,13 @@
 {
 	SCOPED_TIMER(&quot;Draw minimap&quot;);
 
-	glEnable(GL_BLEND);
-	glDepthFunc(GL_LEQUAL);
 	setSurfaceCircleFunc(DrawSurfaceCircle);
 	setSurfaceSquareFunc(DrawSurfaceSquare);
 	cursorIcons.Enable(false);
 
-	glEnable(GL_BLEND);
+	//glEnable(GL_BLEND);
 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	glDepthFunc(GL_LEQUAL);
 
 	if (minimized) {
 		if (!slaveDrawMode) {

Modified: branches/0.77-branch/rts/Lua/LuaMaterial.cpp
===================================================================
--- branches/0.77-branch/rts/Lua/LuaMaterial.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Lua/LuaMaterial.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -41,22 +41,23 @@
 
 void LuaUnitUniforms::Execute(CUnit* unit) const
 {
+	//FIXME use vertex attributes
 	if (!haveUniforms) {
 		return;
 	}
-	if (speedLoc != 0) {
+	if (speedLoc &gt;= 0) {
 		glUniformf3(speedLoc, unit-&gt;speed);
 	}
-	if (healthLoc != 0) {
+	if (healthLoc &gt;= 0) {
 		glUniform1f(healthLoc, unit-&gt;health / unit-&gt;maxHealth);
 	}
-	if (unitIDLoc != 0) {
+	if (unitIDLoc &gt;= 0) {
 		glUniform1i(unitIDLoc, unit-&gt;id);
 	}
-	if (teamIDLoc != 0) {
+	if (teamIDLoc &gt;= 0) {
 		glUniform1i(teamIDLoc, unit-&gt;id);
 	}
-	if (customLoc != 0) {
+	if (customLoc &gt;= 0) {
 		if (customCount &gt; 0) {
 			glUniform1fv(customLoc, customCount, customData);
 		}

Modified: branches/0.77-branch/rts/Lua/LuaUnitMaterial.h
===================================================================
--- branches/0.77-branch/rts/Lua/LuaUnitMaterial.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Lua/LuaUnitMaterial.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -64,11 +64,11 @@
 	public:
 		LuaUnitUniforms()
 		: haveUniforms(false),
-		  speedLoc(0),
-		  healthLoc(0),
-		  unitIDLoc(0),
-		  teamIDLoc(0),
-		  customLoc(0),
+		  speedLoc(-1),
+		  healthLoc(-1),
+		  unitIDLoc(-1),
+		  teamIDLoc(-1),
+		  customLoc(-1),
 		  customCount(0),
 		  customData(NULL)
 		{}
@@ -83,9 +83,9 @@
 	public:
 		bool haveUniforms;
 		GLint speedLoc;	
-		GLint healthLoc;	
-		GLint unitIDLoc;	
-		GLint teamIDLoc;	
+		GLint healthLoc;
+		GLint unitIDLoc;
+		GLint teamIDLoc;
 		GLint customLoc;
 		int customCount;
 		GLfloat* customData;

Modified: branches/0.77-branch/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- branches/0.77-branch/rts/Lua/LuaUnsyncedCtrl.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Lua/LuaUnsyncedCtrl.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -178,6 +178,8 @@
 	REGISTER_LUA_CFUNC(SetShareLevel);
 	REGISTER_LUA_CFUNC(ShareResources);
 
+	REGISTER_LUA_CFUNC(SetLastMessagePosition);
+
 	REGISTER_LUA_CFUNC(MarkerAddPoint);
 	REGISTER_LUA_CFUNC(MarkerAddLine);
 	REGISTER_LUA_CFUNC(MarkerErasePosition);
@@ -1988,6 +1990,26 @@
 /******************************************************************************/
 /******************************************************************************/
 
+
+int LuaUnsyncedCtrl::SetLastMessagePosition(lua_State* L)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 3) ||
+	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
+		luaL_error(L, &quot;Incorrect arguments to SetLastMessagePosition(x, y, z)&quot;);
+	}
+	const float3 pos(lua_tofloat(L, 1),
+	                 lua_tofloat(L, 2),
+	                 lua_tofloat(L, 3));
+
+	logOutput.SetLastMsgPos(pos);
+
+	return 0;
+}
+
+/******************************************************************************/
+/******************************************************************************/
+
 int LuaUnsyncedCtrl::MarkerAddPoint(lua_State* L)
 {
 	if (!CheckModUICtrl()) {

Modified: branches/0.77-branch/rts/Lua/LuaUnsyncedCtrl.h
===================================================================
--- branches/0.77-branch/rts/Lua/LuaUnsyncedCtrl.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Lua/LuaUnsyncedCtrl.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -115,6 +115,8 @@
 		static int SendLuaGaiaMsg(lua_State* L);
 		static int SendLuaRulesMsg(lua_State* L);
 
+		static int SetLastMessagePosition(lua_State* L);
+
 		static int MarkerAddPoint(lua_State* L);
 		static int MarkerAddLine(lua_State* L);
 		static int MarkerErasePosition(lua_State* L);

Modified: branches/0.77-branch/rts/Lua/LuaWeaponDefs.cpp
===================================================================
--- branches/0.77-branch/rts/Lua/LuaWeaponDefs.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Lua/LuaWeaponDefs.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -494,6 +494,8 @@
 	ADD_INT(&quot;interceptor&quot;,     wd.interceptor);
 	ADD_FLOAT(&quot;coverageRange&quot;, wd.coverageRange);
 
+	ADD_FLOAT(&quot;stockpileTime&quot;, wd.stockpileTime);
+
 	ADD_FLOAT(&quot;intensity&quot;, wd.intensity);
 	ADD_FLOAT(&quot;thickness&quot;, wd.thickness);
 	ADD_FLOAT(&quot;laserFlareSize&quot;, wd.laserflaresize);

Modified: branches/0.77-branch/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- branches/0.77-branch/rts/Map/SMF/BFGroundDrawer.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Map/SMF/BFGroundDrawer.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -30,6 +30,9 @@
 	heightDataX(gs-&gt;mapx + 1),
 	maxIdx(((gs-&gt;mapx + 1) * (gs-&gt;mapy + 1)) - 1)
 {
+	mapWidth = (gs-&gt;mapx &lt;&lt; 3);
+	bigTexH = (gs-&gt;mapy &lt;&lt; 3) / numBigTexY;
+
 	map = rm;
 
 	heightData = map-&gt;heightmap;
@@ -49,6 +52,21 @@
 	viewRadius += (viewRadius &amp; 1);
 
 	waterDrawn = false;
+
+	waterPlaneCamInDispList  = 0;
+	waterPlaneCamOutDispList = 0;
+
+	if (mapInfo-&gt;hasWaterPlane) {
+		waterPlaneCamInDispList = glGenLists(1);
+		glNewList(waterPlaneCamInDispList,GL_COMPILE);
+		CreateWaterPlanes(false);
+		glEndList();
+
+		waterPlaneCamOutDispList = glGenLists(1);
+		glNewList(waterPlaneCamOutDispList,GL_COMPILE);
+		CreateWaterPlanes(true);
+		glEndList();
+	}
 }
 
 CBFGroundDrawer::~CBFGroundDrawer(void)
@@ -65,64 +83,75 @@
 	}
 
 	configHandler.SetInt(&quot;GroundDetail&quot;, viewRadius);
+
+	if (waterPlaneCamInDispList) {
+		glDeleteLists(waterPlaneCamInDispList,1);
+		glDeleteLists(waterPlaneCamOutDispList,1);
+	}
 }
 
+void CBFGroundDrawer::CreateWaterPlanes(const bool &amp;camOufOfMap) {
+	glDisable(GL_TEXTURE_2D);
 
-inline void CBFGroundDrawer::DrawWaterPlane(bool drawWaterReflection) {
-	if (!drawWaterReflection) {
-		glDisable(GL_TEXTURE_2D);
+	const float xsize = (gs-&gt;mapx * SQUARE_SIZE) &gt;&gt; 2;
+	const float ysize = (gs-&gt;mapy * SQUARE_SIZE) &gt;&gt; 2;
 
-		const float xsize = (gs-&gt;mapx * SQUARE_SIZE) &gt;&gt; 2;
-		const float ysize = (gs-&gt;mapy * SQUARE_SIZE) &gt;&gt; 2;
-		const bool  camOutMap = (camera-&gt;pos.x &lt; 0 || camera-&gt;pos.z &lt; 0 || camera-&gt;pos.x &gt; float3::maxxpos || camera-&gt;pos.z &gt; float3::maxzpos);
+	CVertexArray *va = GetVertexArray();
+	va-&gt;Initialize();
 
-		CVertexArray *va = GetVertexArray();
-		va-&gt;Initialize();
+	unsigned char fogColor[4] = {
+	  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[0]),
+	  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[1]),
+	  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[2]),
+	  255
+	};
 
-		unsigned char fogColor[4] = {
-		  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[0]),
-		  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[1]),
-		  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[2]),
-		  255
-		};
+	unsigned char planeColor[4] = {
+	  (unsigned char)(255 * mapInfo-&gt;water.planeColor[0]),
+	  (unsigned char)(255 * mapInfo-&gt;water.planeColor[1]),
+	  (unsigned char)(255 * mapInfo-&gt;water.planeColor[2]),
+	   255
+	};
 
-		unsigned char planeColor[4] = {
-		  (unsigned char)(255 * mapInfo-&gt;water.planeColor[0]),
-		  (unsigned char)(255 * mapInfo-&gt;water.planeColor[1]),
-		  (unsigned char)(255 * mapInfo-&gt;water.planeColor[2]),
-		   255
-		};
+	const float alphainc = fastmath::PI2 / 32;
+	float alpha,r1,r2;
+	float3 p(0.0f,-200.0f,0.0f);
+	const float size = std::min(xsize,ysize);
+	for (int n = (camOufOfMap) ? 0 : 1; n &lt; 4 ; ++n) {
 
-		const float alphainc = fastmath::PI2 / 32;
-		float alpha,r1,r2;
-		float3 p(0.0f,-200.0f,0.0f);
-		const float size = std::min(xsize,ysize);
-		for (int n = (camOutMap) ? 0 : 1; n &lt; 4 ; ++n) {
-			if ((n==1) &amp;&amp; !camOutMap) {
-				r1 = 2 * size;
-			}else{
-				r1 = n*n * size;
-			}
-			if (n==3) {
-				r2 = (n+0.5)*(n+0.5) * size;
-			}else{
-				r2 = (n+1)*(n+1) * size;
-			}
-			for (alpha = 0.0f; (alpha - fastmath::PI2) &lt; alphainc ; alpha+=alphainc) {
-				p.x = r1 * fastmath::sin(alpha) + 2 * xsize;
-				p.z = r1 * fastmath::cos(alpha) + 2 * ysize;
-				va-&gt;AddVertexC(p, planeColor );
-				p.x = r2 * fastmath::sin(alpha) + 2 * xsize;
-				p.z = r2 * fastmath::cos(alpha) + 2 * ysize;
-				va-&gt;AddVertexC(p, (n==3) ? fogColor : planeColor);
-			}
+		if ((n==1) &amp;&amp; !camOufOfMap) {
+			//! don't render vertices under the map
+			r1 = 2 * size;
+		}else{
+			r1 = n*n * size;
 		}
 
-		va-&gt;DrawArrayC(GL_TRIANGLE_STRIP);
+		if (n==3) {
+			//! last stripe: make it thinner (looks better with fog)
+			r2 = (n+0.5)*(n+0.5) * size;
+		}else{
+			r2 = (n+1)*(n+1) * size;
+		}
+		for (alpha = 0.0f; (alpha - fastmath::PI2) &lt; alphainc ; alpha+=alphainc) {
+			p.x = r1 * fastmath::sin(alpha) + 2 * xsize;
+			p.z = r1 * fastmath::cos(alpha) + 2 * ysize;
+			va-&gt;AddVertexC(p, planeColor );
+			p.x = r2 * fastmath::sin(alpha) + 2 * xsize;
+			p.z = r2 * fastmath::cos(alpha) + 2 * ysize;
+			va-&gt;AddVertexC(p, (n==3) ? fogColor : planeColor);
+		}
 	}
+	va-&gt;DrawArrayC(GL_TRIANGLE_STRIP);
 }
 
+inline void CBFGroundDrawer::DrawWaterPlane(bool drawWaterReflection) {
+	if (!drawWaterReflection) {
+		const bool camOutOfMap = (camera-&gt;pos.x &lt; 0 || camera-&gt;pos.z &lt; 0 || camera-&gt;pos.x &gt; float3::maxxpos || camera-&gt;pos.z &gt; float3::maxzpos);
+		glCallList(camOutOfMap ? waterPlaneCamOutDispList : waterPlaneCamInDispList);
+	}
+}
 
+
 inline void CBFGroundDrawer::DrawVertexAQ(CVertexArray *ma, int x, int y)
 {
 	float height = heightData[y * heightDataX + x];
@@ -148,9 +177,6 @@
 
 
 inline bool CBFGroundDrawer::BigTexSquareRowVisible(int bty) {
-	static int mapWidth = (gs-&gt;mapx &lt;&lt; 3);
-	static int bigTexH = (gs-&gt;mapy &lt;&lt; 3) / numBigTexY;
-
 	const int minx =             0;
 	const int maxx =      mapWidth;
 	const int minz = bty * bigTexH;
@@ -175,7 +201,7 @@
 
 inline void CBFGroundDrawer::DoDrawGroundRow(int bty, unsigned int overrideVP) {
 	if (!BigTexSquareRowVisible(bty)) {
-		// skip this entire row of squares if we can't see it
+		//! skip this entire row of squares if we can't see it
 		return;
 	}
 
@@ -188,7 +214,7 @@
 	int ex = numBigTexX;
 	std::vector&lt;fline&gt;::iterator fli;
 
-	// only process the necessary big squares in the x direction
+	//! only process the necessary big squares in the x direction
 	for (fli = left.begin(); fli != left.end(); fli++) {
 		x0 = ((fli-&gt;base / SQUARE_SIZE + fli-&gt;dir *  (bty * bigSquareSize)                 ));
 		x1 = ((fli-&gt;base / SQUARE_SIZE + fli-&gt;dir * ((bty * bigSquareSize) + bigSquareSize)));
@@ -216,7 +242,7 @@
 
 
 	for (int btx = sx; btx &lt; ex; ++btx) {
-		// must be in drawLos mode or shadows must be off
+		//! must be in drawLos mode or shadows must be off
 		if (DrawExtraTex() || !shadowHandler-&gt;drawShadows) {
 			textures-&gt;SetTexture(btx, bty);
 			SetTexGen(1.0f / 1024, 1.0f / 1024, -btx, -bty);
@@ -299,24 +325,26 @@
 				}
 
 				int nloop=(xe-xs)/lod+1;
-				ma-&gt;EnlargeArrays(52*nloop, 14*nloop+1); // includes one extra for final endstrip
+				ma-&gt;EnlargeArrays(52*nloop, 14*nloop+1); //! includes one extra for final endstrip
 
 				for (x = xs; x &lt; xe; x += lod) {
+					//! info: all triangle quads start in the top left corner
 					if ((lod == 1) ||
 						(x &gt; (cx) + viewRadius * hlod) || (x &lt; (cx) - viewRadius * hlod) ||
 						(y &gt; (cy) + viewRadius * hlod) || (y &lt; (cy) - viewRadius * hlod)) {
-							// normal terrain
-							if (!inStrip) {
-								DrawVertexAQ(ma, x, y      );
-								DrawVertexAQ(ma, x, y + lod);
-								inStrip = true;
-							}
+						//! normal terrain (all vertices in one LOD)
+						if (!inStrip) {
+							DrawVertexAQ(ma, x, y      );
+							DrawVertexAQ(ma, x, y + lod);
+							inStrip = true;
+						}
 
-							DrawVertexAQ(ma, x + lod, y      );
-							DrawVertexAQ(ma, x + lod, y + lod);
+						DrawVertexAQ(ma, x + lod, y      );
+						DrawVertexAQ(ma, x + lod, y + lod);
 					} else {
-						// inre begr?sning mot f?eg?nde lod
+						//! border between 2 different LODs
 						if ((x &gt;= (cx) + viewRadius * hlod)) {
+							//! lower LOD to the right
 							int idx1 = CLAMP((y       ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod), idx1HLOD = CLAMP(idx1 + hlod);
 							int idx2 = CLAMP((y +  lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod), idx2HLOD = CLAMP(idx2 + hlod);
 							int idx3 = CLAMP((y + hlod) * heightDataX + x),                              idx3HLOD = CLAMP(idx3 + hlod);
@@ -346,8 +374,10 @@
 							DrawVertexAQ(ma, x +  lod, y           );
 							DrawVertexAQ(ma, x + hlod, y,        h2);
 							EndStripQ(ma);
-						}
+						}else
+
 						if ((x &lt;= (cx) - viewRadius * hlod)) {
+							//! lower LOD to the left
 							int idx1 = CLAMP((y       ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod), idx1HLOD = CLAMP(idx1 + hlod);
 							int idx2 = CLAMP((y +  lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod), idx2HLOD = CLAMP(idx2 + hlod);
 							int idx3 = CLAMP((y + hlod) * heightDataX + x), idx3LOD = CLAMP(idx3 + lod), idx3HLOD = CLAMP(idx3 + hlod);
@@ -378,7 +408,9 @@
 							DrawVertexAQ(ma, x + hlod, y +  lod, h4);
 							EndStripQ(ma);
 						}
+
 						if ((y &gt;= (cy) + viewRadius * hlod)) {
+							//! lower LOD above
 							int idx1 = (y       ) * heightDataX + x, idx1LOD = CLAMP(idx1 + lod), idx1HLOD = CLAMP(idx1 + hlod);
 							int idx2 = (y +  lod) * heightDataX + x, idx2LOD = CLAMP(idx2 + lod);
 							int idx3 = (y + hlod) * heightDataX + x, idx3LOD = CLAMP(idx3 + lod), idx3HLOD = CLAMP(idx3 + hlod);
@@ -405,8 +437,10 @@
 							DrawVertexAQ(ma, x +  lod, y +  lod    );
 							DrawVertexAQ(ma, x +  lod, y + hlod, h4);
 							EndStripQ(ma);
-						}
+						}else
+
 						if ((y &lt;= (cy) - viewRadius * hlod)) {
+							//! lower LOD beneath
 							int idx1 = CLAMP((y       ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod);
 							int idx2 = CLAMP((y +  lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod), idx2HLOD = CLAMP(idx2 + hlod);
 							int idx3 = CLAMP((y + hlod) * heightDataX + x), idx3LOD = CLAMP(idx3 + lod), idx3HLOD = CLAMP(idx3 + hlod);

Modified: branches/0.77-branch/rts/Map/SMF/BFGroundDrawer.h
===================================================================
--- branches/0.77-branch/rts/Map/SMF/BFGroundDrawer.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Map/SMF/BFGroundDrawer.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -38,6 +38,9 @@
 	const int numBigTexY;
 	const int maxIdx;
 
+	int mapWidth;
+	int bigTexH;
+
 	int neededLod;
 
 	float* heightData;
@@ -58,6 +61,13 @@
 
 	volatile unsigned int mt_overrideVP;
 
+	GLuint waterPlaneCamOutDispList;
+	GLuint waterPlaneCamInDispList;
+
+protected:
+	void CreateWaterPlanes(const bool &amp;camOufOfMap);
+	inline void DrawWaterPlane(bool);
+
 	void DoDrawGroundRow(int bty, unsigned int overrideVP);
 	static void DoDrawGroundRowMT(void *c,int bty) {((CBFGroundDrawer *)c)-&gt;DoDrawGroundRow(bty,((CBFGroundDrawer *)c)-&gt;mt_overrideVP);}
 	void DrawVertexAQ(CVertexArray *ma, int x, int y);
@@ -67,7 +77,6 @@
 	void DoDrawGroundShadowLOD(int nlod);
 	static void DoDrawGroundShadowLODMT(void *c,int nlod) {((CBFGroundDrawer *)c)-&gt;DoDrawGroundShadowLOD(nlod);}
 
-	inline void DrawWaterPlane(bool);
 	inline bool BigTexSquareRowVisible(int);
 	void SetupTextureUnits(bool drawReflection, unsigned int overrideVP);
 	void ResetTextureUnits(bool drawReflection, unsigned int overrideVP);

Modified: branches/0.77-branch/rts/Map/SMF/BFGroundTextures.cpp
===================================================================
--- branches/0.77-branch/rts/Map/SMF/BFGroundTextures.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Map/SMF/BFGroundTextures.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -14,7 +14,10 @@
 using std::string;
 using std::max;
 
-CBFGroundTextures::CBFGroundTextures(CSmfReadMap* rm)
+CBFGroundTextures::CBFGroundTextures(CSmfReadMap* rm) :
+	bigSquareSize(128),
+	numBigTexX(gs-&gt;mapx / bigSquareSize),
+	numBigTexY(gs-&gt;mapy / bigSquareSize)
 {
 	usePBO = false;
 	if (GLEW_EXT_pixel_buffer_object &amp;&amp; rm-&gt;usePBO) {
@@ -26,10 +29,6 @@
 	CFileHandler* ifs = rm-&gt;ifs;
 	map = rm;
 
-	bigSquareSize = 128;
-	numBigTexX = gs-&gt;mapx / bigSquareSize;
-	numBigTexY = gs-&gt;mapy / bigSquareSize;
-
 	SMFHeader* header = &amp;map-&gt;header;
 	ifs-&gt;Seek(header-&gt;tilesPtr);
 

Modified: branches/0.77-branch/rts/Map/SMF/BFGroundTextures.h
===================================================================
--- branches/0.77-branch/rts/Map/SMF/BFGroundTextures.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Map/SMF/BFGroundTextures.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -21,9 +21,9 @@
 protected:
 	CSmfReadMap* map;
 
-	int bigSquareSize;
-	int numBigTexX;
-	int numBigTexY;
+	const int bigSquareSize;
+	const int numBigTexX;
+	const int numBigTexY;
 
 	int* textureOffsets;
 
@@ -41,7 +41,7 @@
 	int tileMapXSize;
 	int tileMapYSize;
 
-	//! use Pixel Buffer Objects for async. uploading (DMA)?
+	//! use Pixel Buffer Objects for async. uploading (DMA)
 	bool usePBO;
 	GLuint pboIDs[10];
 	int currentPBO;

Modified: branches/0.77-branch/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- branches/0.77-branch/rts/Rendering/Env/BumpWater.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Rendering/Env/BumpWater.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -125,6 +125,12 @@
 }
 
 
+static void GLSLDefineConst4f(string&amp; str, const string&amp; name, const float x, const float y, const float z, const float w)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec4(%1$.12f,%2$.12f,%3$.12f,%4$.12f)\n&quot;) % (x) % (y) % (z) % (w));
+}
+
+
 static void GLSLDefineConstf4(string&amp; str, const string&amp; name, const float3&amp; v, const float&amp; alpha)
 {
 	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec4(%1$.12f,%2$.12f,%3$.12f,%4$.12f)\n&quot;) % (v.x) % (v.y) % (v.z) % (alpha));
@@ -174,6 +180,41 @@
 	return texID;
 }
 
+
+static void DrawRadialDisc()
+{
+	//! SAME ALGORITHM AS FOR WATERPLANE IN BFGroundDrawer.cpp!
+	const float xsize = (gs-&gt;mapx * SQUARE_SIZE) &gt;&gt; 2;
+	const float ysize = (gs-&gt;mapy * SQUARE_SIZE) &gt;&gt; 2;
+
+	CVertexArray *va = GetVertexArray();
+	va-&gt;Initialize();
+
+	const float alphainc = fastmath::PI2 / 32;
+	float alpha,r1,r2;
+	float3 p(0.0f,0.0f,0.0f);
+	const float size = std::min(xsize,ysize);
+	for (int n = 0; n &lt; 4 ; ++n) {
+		r1 = n*n * size;
+		if (n==3) {
+			r2 = (n+0.5)*(n+0.5) * size;
+		}else{
+			r2 = (n+1)*(n+1) * size;
+		}
+		for (alpha = 0.0f; (alpha - fastmath::PI2) &lt; alphainc ; alpha+=alphainc) {
+			p.x = r1 * fastmath::sin(alpha) + 2 * xsize;
+			p.z = r1 * fastmath::cos(alpha) + 2 * ysize;
+			va-&gt;AddVertex0(p);
+			p.x = r2 * fastmath::sin(alpha) + 2 * xsize;
+			p.z = r2 * fastmath::cos(alpha) + 2 * ysize;
+			va-&gt;AddVertex0(p);
+		}
+	}
+
+	va-&gt;DrawArray0(GL_TRIANGLE_STRIP);
+}
+
+
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /// (DE-)CONSTRUCTOR
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -238,8 +279,10 @@
 		glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F_ARB, gs-&gt;mapx, gs-&gt;mapy, 0, GL_RGBA, GL_FLOAT, NULL);
 		glGenerateMipmapEXT(GL_TEXTURE_2D);
 
@@ -453,6 +496,15 @@
 	GLSLDefineConstf1(definitions, &quot;PerlinLacunarity&quot;, mapInfo-&gt;water.perlinLacunarity);
 	GLSLDefineConstf1(definitions, &quot;PerlinAmp&quot;,        mapInfo-&gt;water.perlinAmplitude);
 
+	{
+		const int mapX = readmap-&gt;width  * SQUARE_SIZE;
+		const int mapZ = readmap-&gt;height * SQUARE_SIZE;
+		const float shadingX = (float)gs-&gt;mapx / gs-&gt;pwr2mapx;
+		const float shadingZ = (float)gs-&gt;mapy / gs-&gt;pwr2mapy;
+
+		GLSLDefineConst4f(definitions, &quot;TexGenPlane&quot;, 1.0f/mapX, 1.0f/mapZ, shadingX/mapX, shadingZ/mapZ);
+	}
+
 	/** LOAD SHADERS **/
 	string vsSource = LoadShaderSource(&quot;shaders/bumpWaterVS.glsl&quot;);
 	string fsSource = LoadShaderSource(&quot;shaders/bumpWaterFS.glsl&quot;);
@@ -508,6 +560,24 @@
 		glUniform1i(depthmapLoc, 7);
 		glUniform1i(waverandLoc, 8);
 	glUseProgram(0);
+
+
+	/** CREATE DISPLAYLIST **/
+	displayList = glGenLists(1);
+	glNewList(displayList,GL_COMPILE);
+	if (endlessOcean) {
+		DrawRadialDisc();
+	}else{
+		const int mapX = readmap-&gt;width  * SQUARE_SIZE;
+		const int mapZ = readmap-&gt;height * SQUARE_SIZE;
+		glBegin(GL_QUADS);
+		glVertex3i(   0, 0, 0);
+		glVertex3i(   0, 0, mapZ);
+		glVertex3i(mapX, 0, mapZ);
+		glVertex3i(mapX, 0, 0);
+		glEnd();
+	}
+	glEndList();
 }
 
 
@@ -540,6 +610,8 @@
 	glDeleteShader(waterFP);
 	glDeleteProgram(waterShader);
 
+	glDeleteLists(displayList,1);
+
 	if (shoreWaves) {
 		glDeleteTextures(2, coastTexture);
 		glDeleteTextures(1, &amp;waveRandTexture);
@@ -872,39 +944,6 @@
 ///  DRAW FUNCTIONS
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
-static void DrawRadialDisc()
-{
-	//! SAME ALGORITHM AS FOR WATERPLANE IN BFGroundDrawer.cpp!
-	const float xsize = (gs-&gt;mapx * SQUARE_SIZE) &gt;&gt; 2;
-	const float ysize = (gs-&gt;mapy * SQUARE_SIZE) &gt;&gt; 2;
-
-	CVertexArray *va = GetVertexArray();
-	va-&gt;Initialize();
-
-	const float alphainc = fastmath::PI2 / 32;
-	float alpha,r1,r2;
-	float3 p(0.0f,0.0f,0.0f);
-	const float size = std::min(xsize,ysize);
-	for (int n = 0; n &lt; 4 ; ++n) {
-		r1 = n*n * size;
-		if (n==3) {
-			r2 = (n+0.5)*(n+0.5) * size;
-		}else{
-			r2 = (n+1)*(n+1) * size;
-		}
-		for (alpha = 0.0f; (alpha - fastmath::PI2) &lt; alphainc ; alpha+=alphainc) {
-			p.x = r1 * fastmath::sin(alpha) + 2 * xsize;
-			p.z = r1 * fastmath::cos(alpha) + 2 * ysize;
-			va-&gt;AddVertex0(p);
-			p.x = r2 * fastmath::sin(alpha) + 2 * xsize;
-			p.z = r2 * fastmath::cos(alpha) + 2 * ysize;
-			va-&gt;AddVertex0(p);
-		}
-	}
-
-	va-&gt;DrawArray0(GL_TRIANGLE_STRIP);
-}
-
 void CBumpWater::Draw()
 {
 	if (readmap-&gt;currMinHeight &gt; 1.0f)
@@ -944,36 +983,11 @@
 	glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, normalTexture);
 
 	glUseProgram(waterShader);
-	glUniform1f(frameLoc, gs-&gt;frameNum / 15000.0f);
+	glUniform1f(frameLoc,  gs-&gt;frameNum / 15000.0f);
 	glUniformf3(eyePosLoc, camera-&gt;pos);
 
+	glCallList(displayList);
 
-	const int mapX = readmap-&gt;width *SQUARE_SIZE;
-	const int mapZ = readmap-&gt;height*SQUARE_SIZE;
-	const float shadingX = (float)gs-&gt;mapx/gs-&gt;pwr2mapx;
-	const float shadingZ = (float)gs-&gt;mapy/gs-&gt;pwr2mapy;
-
-	const GLfloat planeS[4] = {1.0f/mapX,0,0,0};
-	const GLfloat planeT[4] = {0,0,1.0f/mapZ,0};
-	const GLfloat planeR[4] = {shadingX/mapX,0,0,0};
-	const GLfloat planeQ[4] = {0,0,shadingZ/mapZ,0};
-	glTexGenfv(GL_S,GL_OBJECT_PLANE,planeS);
-	glTexGenfv(GL_T,GL_OBJECT_PLANE,planeT);
-	glTexGenfv(GL_R,GL_OBJECT_PLANE,planeR);
-	glTexGenfv(GL_Q,GL_OBJECT_PLANE,planeQ);
-
-	
-	if (endlessOcean) {
-		DrawRadialDisc();
-	}else{
-		glBegin(GL_QUADS);
-		glVertex3i(   0, 0, 0);
-		glVertex3i(   0, 0, mapZ);
-		glVertex3i(mapX, 0, mapZ);
-		glVertex3i(mapX, 0, 0);
-		glEnd();
-	}
-
 	glUseProgram(0);
 
 	if (refraction&lt;2)

Modified: branches/0.77-branch/rts/Rendering/Env/BumpWater.h
===================================================================
--- branches/0.77-branch/rts/Rendering/Env/BumpWater.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Rendering/Env/BumpWater.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -53,6 +53,8 @@
 	GLuint coastFBO;
 	GLuint dynWavesFBO;
 
+	GLuint displayList;
+
 	//! coastmap
 	bool coastmapNeedUpload;
 	bool coastmapNeedUpdate;

Modified: branches/0.77-branch/rts/Rendering/GL/myGL.cpp
===================================================================
--- branches/0.77-branch/rts/Rendering/GL/myGL.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Rendering/GL/myGL.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -145,7 +145,7 @@
 
 	// create mipmapped texture
 
-/*	if (configHandler.GetInt(&quot;AtiHacks&quot;, 0) == 0 &amp;&amp; glGenerateMipmapEXT) { // broken on ATIs and NVs (wait for their OpenGL3.0 drivers :/)
+/*	if (!gu-&gt;atiHacks &amp;&amp; glGenerateMipmapEXT) { // broken on ATIs and NVs (wait for their OpenGL3.0 drivers :/)
 		// newest method
 		glTexImage2D(target, 0, internalFormat, width, height, 0, format, type, data);
 		glGenerateMipmapEXT(target);
@@ -235,7 +235,6 @@
 void PrintLoadMsg(const char* text, bool swapbuffers)
 {
 	static char prevText[100];
-	static unsigned startTicks;
 
 	PUSH_CODE_MODE;
 
@@ -246,13 +245,9 @@
 	// Check to prevent infolog spam by CPreGame which uses this function
 	// to render the screen background each frame.
 	if (strcmp(prevText, text)) {
-		unsigned ticks = SDL_GetTicks();
-//		if (prevText[0])
-//			logOutput.Print(&quot;Loading step `%s' took %g seconds&quot;, prevText, (ticks - startTicks) / 1000.0f);
 		logOutput.Print(&quot;%s&quot;,text);
 		strncpy(prevText, text, sizeof(prevText));
 		prevText[sizeof(prevText) - 1] = 0;
-		startTicks = ticks;
 	}
 
 	good_fpu_control_registers(text);

Modified: branches/0.77-branch/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- branches/0.77-branch/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -86,9 +86,6 @@
 	LODScaleReflection = GetLODFloat(&quot;LODScaleReflection&quot;, 1.0f);
 	LODScaleRefraction = GetLODFloat(&quot;LODScaleRefraction&quot;, 1.0f);
 
-	// Some Ati mobility cards dont like clipping wireframes...
-	usingAtiHacks = !!configHandler.GetInt(&quot;AtiHacks&quot;, 0);
-
 	CBitmap white;
 	white.Alloc(1, 1);
 	for (int a = 0; a &lt; 4; ++a) {
@@ -401,22 +398,22 @@
 	CUnit* excludeUnit = drawReflection ? NULL : gu-&gt;directControl;
 #endif
 
-#if GML_ENABLE_DRAWUNIT
+#ifdef GML_ENABLE_DRAWUNIT
 	mt_drawReflection=drawReflection; // these member vars will be accessed by DoDrawUnitMT
 	mt_drawRefraction=drawRefraction;
-#ifdef DIRECT_CONTROL_ALLOWED
+  #ifdef DIRECT_CONTROL_ALLOWED
 	mt_excludeUnit=excludeUnit;
-#endif
+  #endif
 	gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DoDrawUnitMT,this,gmlThreadCount,FALSE,&amp;uh-&gt;activeUnits,uh-&gt;activeUnits.size(),50,100,TRUE);
 #else
 	for (std::list&lt;CUnit*&gt;::iterator usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
 		CUnit* unit = *usi;
 		DoDrawUnit(unit,drawReflection,drawRefraction,
-#ifdef DIRECT_CONTROL_ALLOWED
+  #ifdef DIRECT_CONTROL_ALLOWED
 								excludeUnit
-#else
+  #else
 								NULL
-#endif
+  #endif
 							);
 	}
 #endif
@@ -486,6 +483,15 @@
 	luaDrawing = true;
 
 	glPushAttrib(GL_TEXTURE_BIT | GL_ENABLE_BIT | GL_TRANSFORM_BIT);
+	if (type==LUAMAT_ALPHA || type==LUAMAT_ALPHA_REFLECT) {
+		glEnable(GL_ALPHA_TEST);
+		glAlphaFunc(GL_GREATER, 0.1f);
+		glEnable(GL_BLEND);
+		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	}else{
+		glEnable(GL_ALPHA_TEST);
+		glAlphaFunc(GL_GREATER, 0.5f);
+	}
 
 	const LuaMaterial* currMat = &amp;LuaMaterial::defMat;
 
@@ -659,8 +665,9 @@
 
 	CUnit::SetLODFactor(LODScale * LODScaleShadow);
 
-#if GML_ENABLE_DRAWUNITSHADOW
-	gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DoDrawUnitShadowMT,this,gmlThreadCount,FALSE,&amp;uh-&gt;activeUnits,uh-&gt;activeUnits.size(),50,100,TRUE);
+#ifdef GML_ENABLE_DRAWUNITSHADOW
+	gmlProcessor.Work(NULL, NULL, &amp;CUnitDrawer::DoDrawUnitShadowMT, this, gmlThreadCount, FALSE,
+	  &amp;uh-&gt;activeUnits, uh-&gt;activeUnits.size(),50,100,TRUE);
 #else
 	std::list&lt;CUnit*&gt;::iterator usi;
 	for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
@@ -1502,7 +1509,7 @@
 
 void CUnitDrawer::QueS3ODraw(CWorldObject* object, int textureType)
 {
-#if GML_ENABLE
+#ifdef GML_ENABLE
 	quedS3Os.acquire(textureType).push_back(object);
 	quedS3Os.release();
 #else
@@ -1535,9 +1542,11 @@
 	for(int tex=0; tex&lt;sz;++tex) {
 		if(quedS3Os[tex].size()&gt;0) {
 			texturehandler-&gt;SetS3oTexture(tex);
+
 			for(GML_VECTOR&lt;CWorldObject*&gt;::iterator ui = quedS3Os[tex].begin(); ui != quedS3Os[tex].end(); ++ui){
 				DrawWorldObjectS3O(*ui);
 			}
+
 			quedS3Os[tex].clear();
 		}
 	}
@@ -1834,12 +1843,12 @@
 	const double plane1[4] = {0, 1, 0, -start - height * (unit-&gt;buildProgress * 10 - 9)};
 	glClipPlane(GL_CLIP_PLANE1, plane1);
 
-	if (!usingAtiHacks) {
+	if (!gu-&gt;atiHacks) {
 		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 		DrawUnitModel(unit);
 		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-	}
-	else {
+	} else {
+		//! some ATi mobility cards/drivers dont like clipping wireframes...
 		glDisable(GL_CLIP_PLANE0);
 		glDisable(GL_CLIP_PLANE1);
 
@@ -1868,16 +1877,12 @@
 		const double plane0[4] = {0, -1, 0 , start + height * (unit-&gt;buildProgress * 3 - 2)};
 		glClipPlane(GL_CLIP_PLANE0, plane0);
 
-		//if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
-			glPolygonOffset(1.0f, 1.0f);
-			glEnable(GL_POLYGON_OFFSET_FILL);
-		//}
+		glPolygonOffset(1.0f, 1.0f);
+		glEnable(GL_POLYGON_OFFSET_FILL);
 
 		DrawUnitModel(unit);
 
-		//if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
-			glDisable(GL_POLYGON_OFFSET_FILL);
-		//}
+		glDisable(GL_POLYGON_OFFSET_FILL);
 	}
 
 	glDisable(GL_CLIP_PLANE0);
@@ -1886,7 +1891,8 @@
 
 void CUnitDrawer::ApplyUnitTransformMatrix(CUnit* unit)
 {
-	CMatrix44f m;
+	static CMatrix44f m;
+	m.LoadIdentity();
 	unit-&gt;GetTransformMatrix(m);
 	glMultMatrixf(&amp;m[0]);
 }
@@ -2092,7 +2098,7 @@
 }
 
 
-void CUnitDrawer::DrawWorldObjectS3O(CWorldObject* S3OObj)
+inline void CUnitDrawer::DrawWorldObjectS3O(CWorldObject* S3OObj)
 {
 	if (S3OObj) {
 		// calls back to DrawUnitS3O() for units and

Modified: branches/0.77-branch/rts/Rendering/UnitModels/UnitDrawer.h
===================================================================
--- branches/0.77-branch/rts/Rendering/UnitModels/UnitDrawer.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Rendering/UnitModels/UnitDrawer.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -26,20 +26,14 @@
 
 	void Update(void);
 
-	volatile bool mt_drawReflection;
-	volatile bool mt_drawRefraction;
-	CUnit * volatile mt_excludeUnit;
-
 	void Draw(bool drawReflection, bool drawRefraction = false);
 	void DrawUnit(CUnit* unit);
 	void DoDrawUnit(CUnit *unit, bool drawReflection, bool drawRefraction, CUnit *excludeUnit);
-	static void DoDrawUnitMT(void *c,CUnit *unit) {((CUnitDrawer *)c)-&gt;DoDrawUnit(unit,((CUnitDrawer *)c)-&gt;mt_drawReflection,((CUnitDrawer *)c)-&gt;mt_drawRefraction,((CUnitDrawer *)c)-&gt;mt_excludeUnit);}
 	void DrawUnitLOD(CUnit* unit);
 
-	void DrawCloakedUnits(void);									// cloaked units must be drawn after all others
+	void DrawCloakedUnits(void);     // cloaked units must be drawn after all others
 	void DrawShadowPass(void);
 	void DoDrawUnitShadow(CUnit *unit);
-	static void DoDrawUnitShadowMT(void *c,CUnit *unit) {((CUnitDrawer *)c)-&gt;DoDrawUnitShadow(unit);}
 	void SetupForUnitDrawing(void);
 	void CleanUpUnitDrawing(void);
 	void SetupForS3ODrawing(void);
@@ -48,6 +42,23 @@
 	void SetupForGhostDrawing();
 	void SetupForGhostDrawingS3O();
 
+
+#ifdef GML_ENABLE_DRAWUNIT
+	volatile bool mt_drawReflection;
+	volatile bool mt_drawRefraction;
+  #ifdef DIRECT_CONTROL_ALLOWED
+	CUnit * volatile mt_excludeUnit;
+  #endif
+	static void DoDrawUnitMT(void *c,CUnit *unit) {
+		CUnitDrawer* const ud = (CUnitDrawer*)c;
+		ud-&gt;DoDrawUnit(unit, ud-&gt;mt_drawReflection, ud-&gt;mt_drawRefraction, ud-&gt;mt_excludeUnit);
+	}
+#endif
+
+#ifdef GML_ENABLE_DRAWUNITSHADOW
+	static void DoDrawUnitShadowMT(void *c,CUnit *unit) {((CUnitDrawer *)c)-&gt;DoDrawUnitShadow(unit);}
+#endif
+
 	void DrawOpaqueShaderUnits();
 	void DrawCloakedShaderUnits();
 	void DrawShadowShaderUnits();
@@ -55,19 +66,19 @@
 	inline void DrawFar(CUnit* unit);
 
 	// note: make these static?
-	inline void DrawUnitDebug(CUnit*);								// was CUnit::DrawDebug()
-	void DrawUnitBeingBuilt(CUnit*);								// was CUnit::DrawBeingBuilt()
-	void ApplyUnitTransformMatrix(CUnit*);							// was CUnit::ApplyTransformMatrix()
-	inline void DrawUnitModel(CUnit*);								// was CUnit::DrawModel()
-	void DrawUnitNow(CUnit*);										// was CUnit::Draw()
-	void DrawUnitWithLists(CUnit*, unsigned int, unsigned int);		// was CUnit::DrawWithLists() [CUnitDrawer]
-	void DrawUnitRaw(CUnit*);										// was CUnit::DrawRaw()
-	void DrawUnitRawModel(CUnit*);									// was CUnit::DrawRawModel() [CLuaOpenGL]
-	void DrawUnitRawWithLists(CUnit*, unsigned int, unsigned int);	// was CUnit::DrawRawWithLists()
-	void DrawUnitStats(CUnit*);										// was CUnit::DrawStats()
-	void DrawUnitS3O(CUnit*);										// was CUnit::DrawS3O()
-	void DrawFeatureS3O(CFeature*);									// was CFeature::DrawS3O()
-	void DrawWorldObjectS3O(CWorldObject*);
+	inline void DrawUnitDebug(CUnit*);                              // was CUnit::DrawDebug()
+	void DrawUnitBeingBuilt(CUnit*);                                // was CUnit::DrawBeingBuilt()
+	void ApplyUnitTransformMatrix(CUnit*);                          // was CUnit::ApplyTransformMatrix()
+	inline void DrawUnitModel(CUnit*);                              // was CUnit::DrawModel()
+	void DrawUnitNow(CUnit*);                                       // was CUnit::Draw()
+	void DrawUnitWithLists(CUnit*, unsigned int, unsigned int);     // was CUnit::DrawWithLists() [CUnitDrawer]
+	void DrawUnitRaw(CUnit*);                                       // was CUnit::DrawRaw()
+	void DrawUnitRawModel(CUnit*);                                  // was CUnit::DrawRawModel() [CLuaOpenGL]
+	void DrawUnitRawWithLists(CUnit*, unsigned int, unsigned int);  // was CUnit::DrawRawWithLists()
+	void DrawUnitStats(CUnit*);                                     // was CUnit::DrawStats()
+	void DrawUnitS3O(CUnit*);                                       // was CUnit::DrawS3O()
+	void DrawFeatureS3O(CFeature*);                                 // was CFeature::DrawS3O()
+	inline void DrawWorldObjectS3O(CWorldObject*);
 
 	void SetUnitDrawDist(float dist);
 	void SetUnitIconDist(float dist);
@@ -160,11 +171,11 @@
 	void DrawBuildingSample(const UnitDef* unitdef, int side, float3 pos, int facing=0);
 	void DrawUnitDef(const UnitDef* unitDef, int team);
 
-	/* CUnit::Draw */
+	/** CUnit::Draw **/
 	void UnitDrawingTexturesOff(S3DOModel *model);
 	void UnitDrawingTexturesOn(S3DOModel *model);
 
-	/* CGame::DrawDirectControlHud,  */
+	/** CGame::DrawDirectControlHud,  **/
 	void DrawIndividual(CUnit * unit);
 
 private:

Modified: branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -15,6 +15,10 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 
+#ifdef TRACE_SYNC
+	#include &quot;Sync/SyncTracer.h&quot;
+#endif
+
 CR_BIND_DERIVED(CExplosiveProjectile, CWeaponProjectile, (float3(0,0,0),float3(0,0,0),NULL,NULL,1,0));
 
 CR_REG_METADATA(CExplosiveProjectile, (

Modified: branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -10,6 +10,10 @@
 #include &quot;Sim/Projectiles/Unsynced/SimpleParticleSystem.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 
+#ifdef TRACE_SYNC
+	#include &quot;Sync/SyncTracer.h&quot;
+#endif
+
 CR_BIND_DERIVED(CLaserProjectile, CWeaponProjectile, (float3(0,0,0),float3(0,0,0),NULL,0,float3(0,0,0),float3(0,0,0),0,NULL,0));
 
 CR_REG_METADATA(CLaserProjectile,(

Modified: branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -8,6 +8,10 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 
+#ifdef TRACE_SYNC
+	#include &quot;Sync/SyncTracer.h&quot;
+#endif
+
 CR_BIND_DERIVED(CLightingProjectile, CWeaponProjectile, (float3(0,0,0),float3(0,0,0),NULL,float3(0,0,0),NULL,0,NULL));
 
 CR_REG_METADATA(CLightingProjectile,(

Modified: branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -14,6 +14,10 @@
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;TorpedoProjectile.h&quot;
 
+#ifdef TRACE_SYNC
+	#include &quot;Sync/SyncTracer.h&quot;
+#endif
+
 CR_BIND_DERIVED(CTorpedoProjectile, CTorpedoProjectile, (float3(0,0,0),float3(0,0,0),NULL,0,0,0,0,NULL,NULL));
 
 CR_REG_METADATA(CTorpedoProjectile,(

Modified: branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -19,7 +19,11 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Misc/InterceptHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
+#ifdef TRACE_SYNC
+	#include &quot;Sync/SyncTracer.h&quot;
+#endif
 
+
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 
 CR_BIND_DERIVED(CWeaponProjectile, CProjectile, );

Modified: branches/0.77-branch/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Units/UnitDefHandler.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Units/UnitDefHandler.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -854,9 +854,15 @@
 
 
 void CUnitDefHandler::LoadSound(GuiSoundSet&amp; gsound,
-                                const string&amp; fileName, float volume)
+                                const string&amp; fileName, const float volume)
 {
-	const string soundFile = &quot;sounds/&quot; + fileName + &quot;.wav&quot;;
+	string soundFile = &quot;sounds/&quot; + fileName;
+
+	if (soundFile.find(&quot;.wav&quot;) == -1) {
+	 	// .wav extension missing, add it
+		soundFile += &quot;.wav&quot;;
+	}
+
 	CFileHandler fh(soundFile);
 
 	if (fh.FileExists()) {

Modified: branches/0.77-branch/rts/Sim/Units/UnitDefHandler.h
===================================================================
--- branches/0.77-branch/rts/Sim/Units/UnitDefHandler.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Units/UnitDefHandler.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -47,7 +47,7 @@
 	void ParseTAUnit(const LuaTable&amp;, const std::string&amp; name, int id);
 
 	void LoadSounds(const LuaTable&amp;, GuiSoundSet&amp;, const std::string&amp; soundName);
-	void LoadSound(GuiSoundSet&amp;, const std::string&amp; fileName, float volume);
+	void LoadSound(GuiSoundSet&amp;, const std::string&amp; fileName, const float volume);
 
 	void CleanBuildOptions();
 

Modified: branches/0.77-branch/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Units/UnitLoader.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Units/UnitLoader.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -458,6 +458,8 @@
 	weapon-&gt;accuracy = weapondef-&gt;accuracy;
 	weapon-&gt;sprayAngle = weapondef-&gt;sprayAngle;
 
+	weapon-&gt;stockpileTime = (int) (weapondef-&gt;stockpileTime * GAME_SPEED);
+
 	weapon-&gt;salvoSize = weapondef-&gt;salvosize;
 	weapon-&gt;salvoDelay = (int) (weapondef-&gt;salvodelay * GAME_SPEED);
 	weapon-&gt;projectilesPerShot = weapondef-&gt;projectilespershot;

Modified: branches/0.77-branch/rts/Sim/Weapons/EmgCannon.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Weapons/EmgCannon.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Weapons/EmgCannon.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -90,7 +90,7 @@
 {
 #ifdef TRACE_SYNC
 	tracefile &lt;&lt; &quot;Emg fire: &quot;;
-	tracefile &lt;&lt; sprayAngle &lt;&lt; &quot; &quot; &lt;&lt; gs-&gt;randSeed &lt;&lt; &quot; &quot; &lt;&lt; salvoError.x &lt;&lt; &quot; &quot; &lt;&lt; salvoError.z &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;limExperience &lt;&lt; &quot; &quot; &lt;&lt; projectileSpeed &lt;&lt; &quot;\n&quot;;
+	tracefile &lt;&lt; sprayAngle &lt;&lt; &quot; &quot; &lt;&lt; gs-&gt;GetRandSeed() &lt;&lt; &quot; &quot; &lt;&lt; salvoError.x &lt;&lt; &quot; &quot; &lt;&lt; salvoError.z &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;limExperience &lt;&lt; &quot; &quot; &lt;&lt; projectileSpeed &lt;&lt; &quot;\n&quot;;
 #endif
 	float3 dir;
 	if(onlyForward &amp;&amp; dynamic_cast&lt;CAirMoveType*&gt;(owner-&gt;moveType)){		//the taairmovetype cant align itself properly, change back when that is fixed

Modified: branches/0.77-branch/rts/Sim/Weapons/Weapon.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Weapons/Weapon.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Weapons/Weapon.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -74,6 +74,7 @@
 	CR_MEMBER(onlyTargetCategory),
 	CR_MEMBER(incoming),
 //	CR_MEMBER(weaponDef),
+	CR_MEMBER(stockpileTime),
 	CR_MEMBER(buildPercent),
 	CR_MEMBER(numStockpiled),
 	CR_MEMBER(numStockpileQued),
@@ -155,6 +156,7 @@
 	badTargetCategory(0),
 	onlyTargetCategory(0xffffffff),
 	weaponDef(0),
+	stockpileTime(1),
 	buildPercent(0),
 	numStockpiled(0),
 	numStockpileQued(0),
@@ -299,7 +301,7 @@
 		}
 	}
 	if(weaponDef-&gt;stockpile &amp;&amp; numStockpileQued){
-		float p=1.0f/reloadTime;
+		float p=1.0f/stockpileTime;
 		if(gs-&gt;Team(owner-&gt;team)-&gt;metal&gt;=metalFireCost*p &amp;&amp; gs-&gt;Team(owner-&gt;team)-&gt;energy&gt;=energyFireCost*p){
 			owner-&gt;UseEnergy(energyFireCost*p);
 			owner-&gt;UseMetal(metalFireCost*p);

Modified: branches/0.77-branch/rts/Sim/Weapons/Weapon.h
===================================================================
--- branches/0.77-branch/rts/Sim/Weapons/Weapon.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Weapons/Weapon.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -125,6 +125,7 @@
 	std::list&lt;CWeaponProjectile*&gt; incoming;	// nukes that are on the way to our area
 	CWeaponProjectile* interceptTarget;		// nuke that we currently targets
 
+	int stockpileTime;						// how long it takes to stockpile 1 missile
 	float buildPercent;						// how far we have come on building current missile if stockpiling
 	int numStockpiled;						// how many missiles we have stockpiled
 	int numStockpileQued;					// how many weapons the user have added to our que

Modified: branches/0.77-branch/rts/Sim/Weapons/WeaponDefHandler.cpp
===================================================================
--- branches/0.77-branch/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -308,6 +308,7 @@
 
 	//sunparser-&gt;GetDef(wd.highTrajectory, &quot;0&quot;, weaponname + &quot;minbarrelangle&quot;);
 	wd.stockpile     = wdTable.GetBool(&quot;stockpile&quot;, false);
+	wd.stockpileTime = wdTable.GetFloat(&quot;stockpileTime&quot;, wd.reload);
 	wd.interceptor   = wdTable.GetInt(&quot;interceptor&quot;, 0);
 	wd.targetable    = wdTable.GetInt(&quot;targetable&quot;,  0);
 	wd.manualfire    = wdTable.GetBool(&quot;commandfire&quot;, false);

Modified: branches/0.77-branch/rts/Sim/Weapons/WeaponDefHandler.h
===================================================================
--- branches/0.77-branch/rts/Sim/Weapons/WeaponDefHandler.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/Sim/Weapons/WeaponDefHandler.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -111,6 +111,8 @@
 	bool stockpile;
 	float coverageRange;						// range of anti nuke
 
+	float stockpileTime;						// builtime of a missile
+
 	float intensity;
 	float thickness;
 	float laserflaresize;

Modified: branches/0.77-branch/rts/System/BaseNetProtocol.cpp
===================================================================
--- branches/0.77-branch/rts/System/BaseNetProtocol.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/BaseNetProtocol.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,6 +1,8 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;BaseNetProtocol.h&quot;
 
+#include &lt;boost/cstdint.hpp&gt;
+using boost::uint16_t;
 #include &quot;mmgr.h&quot;
 
 #include &quot;Net/RawPacket.h&quot;
@@ -265,7 +267,7 @@
 PacketType CBaseNetProtocol::SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode,
                                   const std::string&amp; msg)
 {
-	unsigned short size = 6 + msg.size()+1;
+	uint16_t size = 6 + msg.size()+1;
 	PackPacket* packet = new PackPacket(size, NETMSG_LUAMSG);
 	*packet &lt;&lt; size &lt;&lt; myPlayerNum &lt;&lt; script &lt;&lt; mode &lt;&lt; msg;
 	return PacketType(packet);
@@ -313,16 +315,49 @@
 	return PacketType(packet);
 }
 
+#ifdef SYNCDEBUG
+PacketType CBaseNetProtocol::SendSdCheckrequest(int frameNum)
+{
+	PackPacket* packet = new PackPacket(5, NETMSG_SD_CHKREQUEST);
+	*packet &lt;&lt; frameNum;
+	return PacketType(packet);
+}
+
+PacketType CBaseNetProtocol::SendSdCheckresponse(uchar myPlayerNum, Uint64 flop, std::vector&lt;unsigned&gt; checksums)
+{
+	unsigned size = 1 + 2 + 1 + 8 + checksums.size() * 4;
+	PackPacket* packet = new PackPacket(size, NETMSG_SD_CHKRESPONSE);
+	*packet &lt;&lt; static_cast&lt;uint16_t&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; flop &lt;&lt; checksums;
+	return PacketType(packet);
+}
+
+PacketType CBaseNetProtocol::SendSdReset()
+{
+	return PacketType(new PackPacket(1, NETMSG_SD_RESET));
+}
+
+PacketType CBaseNetProtocol::SendSdBlockrequest(unsigned short begin, unsigned short length, unsigned short requestSize)
+{
+	PackPacket* packet = new PackPacket(7, NETMSG_SD_BLKREQUEST);
+	*packet &lt;&lt; begin &lt;&lt; length &lt;&lt; requestSize;
+	return PacketType(packet);
+	
+}
+
+PacketType CBaseNetProtocol::SendSdBlockresponse(uchar myPlayerNum, std::vector&lt;unsigned&gt; checksums)
+{
+	unsigned size = 1 + 2 + 1 + checksums.size() * 4;
+	PackPacket* packet = new PackPacket(size, NETMSG_SD_BLKRESPONSE);
+	*packet &lt;&lt; static_cast&lt;uint16_t&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; checksums;
+	return PacketType(packet);
+}
+#endif
 /* FIXME: add these:
-
-#ifdef SYNCDEBUG
  NETMSG_SD_CHKREQUEST    = 41,
  NETMSG_SD_CHKRESPONSE   = 42,
  NETMSG_SD_BLKREQUEST    = 43,
  NETMSG_SD_BLKRESPONSE   = 44,
  NETMSG_SD_RESET         = 45,
-#endif // SYNCDEBUG
-
 */
 
 CBaseNetProtocol::CBaseNetProtocol()
@@ -372,6 +407,14 @@
 	proto-&gt;AddType(NETMSG_GAMEDATA, -2);
 	proto-&gt;AddType(NETMSG_ALLIANCE, 4);
 	proto-&gt;AddType(NETMSG_CCOMMAND, -2);
+	
+#ifdef SYNCDEBUG
+	proto-&gt;AddType(NETMSG_SD_CHKREQUEST, 5);
+	proto-&gt;AddType(NETMSG_SD_CHKRESPONSE, -2);
+	proto-&gt;AddType(NETMSG_SD_RESET, 1);
+	proto-&gt;AddType(NETMSG_SD_BLKREQUEST, 7);
+	proto-&gt;AddType(NETMSG_SD_BLKRESPONSE, -2);
+#endif
 }
 
 CBaseNetProtocol::~CBaseNetProtocol()

Modified: branches/0.77-branch/rts/System/BaseNetProtocol.h
===================================================================
--- branches/0.77-branch/rts/System/BaseNetProtocol.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/BaseNetProtocol.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -155,6 +155,13 @@
 
 	PacketType SendSetAllied(uchar myPlayerNum, uchar whichAllyTeam, uchar state);
 	
+#ifdef SYNCDEBUG
+	PacketType SendSdCheckrequest(int frameNum);
+	PacketType SendSdCheckresponse(uchar myPlayerNum, Uint64 flop, std::vector&lt;unsigned&gt; checksums);
+	PacketType SendSdReset();
+	PacketType SendSdBlockrequest(unsigned short begin, unsigned short length, unsigned short requestSize);
+	PacketType SendSdBlockresponse(uchar myPlayerNum, std::vector&lt;unsigned&gt; checksums);
+#endif
 private:
 	CBaseNetProtocol();
 	~CBaseNetProtocol();

Modified: branches/0.77-branch/rts/System/FileSystem/ArchiveScanner.cpp
===================================================================
--- branches/0.77-branch/rts/System/FileSystem/ArchiveScanner.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/FileSystem/ArchiveScanner.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -431,7 +431,7 @@
 	char* buf = SAFE_NEW char[fsize];
 	ar-&gt;ReadFile(fh, buf, fsize);
 	ar-&gt;CloseFile(fh);
-	
+
 	const string cleanbuf(buf, fsize);
 	delete [] buf;
 	LuaParser p(cleanbuf, SPRING_VFS_MOD);
@@ -463,7 +463,7 @@
 	const string luaCode =
 			parse_tdf_code + &quot;\n\n&quot;
 		+ scanutils_code + &quot;\n\n&quot;
-		+ &quot;local tdfModinfo, err = TDFparser.ParseText([[\n&quot; 
+		+ &quot;local tdfModinfo, err = TDFparser.ParseText([[\n&quot;
 		+ cleanbuf + &quot;]])\n\n&quot;
 		+ &quot;if (tdfModinfo == nil) then\n&quot;
 		+ &quot;    error('Error parsing modinfo.tdf: ' .. err)\n&quot;
@@ -559,13 +559,13 @@
 void CArchiveScanner::ReadCacheData(const string&amp; filename)
 {
   LuaParser p(filename, SPRING_VFS_RAW, SPRING_VFS_BASE);
-	
+
 	if (!p.Execute()) {
 		logOutput.Print(&quot;ERROR in &quot; + filename + &quot;: &quot; + p.GetErrorLog());
 	}
 	const LuaTable archiveCache = p.GetRoot();
 	const LuaTable archives = archiveCache.SubTable(&quot;archives&quot;);
-	
+
 	// Do not load old version caches
 	const int ver = archiveCache.GetInt(&quot;internalVer&quot;, (INTERNAL_VER + 1));
 	if (ver != INTERNAL_VER) {
@@ -653,7 +653,7 @@
 
 		fprintf(out, &quot;\t\t{\n&quot;);
 		SafeStr(out, &quot;\t\t\tname = &quot;,              arcInfo.origName);
-		SafeStr(out, &quot;\t\t\tpath = &quot;,              arcInfo.path); 
+		SafeStr(out, &quot;\t\t\tpath = &quot;,              arcInfo.path);
 		fprintf(out, &quot;\t\t\tmodified = \&quot;%u\&quot;,\n&quot;, arcInfo.modified);
 		fprintf(out, &quot;\t\t\tchecksum = \&quot;%u\&quot;,\n&quot;, arcInfo.checksum);
 		SafeStr(out, &quot;\t\t\treplaced = &quot;,          arcInfo.replaced);
@@ -703,7 +703,7 @@
 				}
 				fprintf(out, &quot;\t\t\t\t},\n&quot;);
 			}
-			
+
 			const vector&lt;string&gt;&amp; modReps = modData.replaces;
 			const int repCount = (int)modReps.size();
 			if (repCount &gt; 0)  {
@@ -886,7 +886,7 @@
 
 	std::map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end()) {
-		return 0;
+		return &quot;&quot;;
 	}
 
 	return aii-&gt;second.path;

Modified: branches/0.77-branch/rts/System/GlobalStuff.cpp
===================================================================
--- branches/0.77-branch/rts/System/GlobalStuff.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/GlobalStuff.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -147,7 +147,7 @@
 	for(int a = 0; a &lt; MAX_TEAMS; a++) {
 		delete teams[a];
 	}
-	for(int a = 0; a &lt; gs-&gt;activePlayers; a++) {
+	for(int a = 0; a &lt; MAX_PLAYERS; a++) {
 		delete players[a];
 	}
 }
@@ -160,13 +160,14 @@
 	useLuaGaia  = CLuaGaia::SetConfigString(setup-&gt;luaGaiaStr);
 	useLuaRules = CLuaRules::SetConfigString(setup-&gt;luaRulesStr);
 
+	activePlayers = setup-&gt;numPlayers;
 	activeTeams = setup-&gt;numTeams;
 	activeAllyTeams = setup-&gt;numAllyTeams;
 	
 	assert(activeTeams &lt;= MAX_TEAMS);
 	assert(activeAllyTeams &lt;= MAX_TEAMS);
 	
-	for (unsigned i = 0; i &lt; static_cast&lt;unsigned&gt;(setup-&gt;numPlayers); ++i)
+	for (unsigned i = 0; i &lt; static_cast&lt;unsigned&gt;(activePlayers); ++i)
 	{
 		*static_cast&lt;PlayerBase*&gt;(players[i]) = setup-&gt;playerStartingData[i];
 	}

Modified: branches/0.77-branch/rts/System/Net/UDPConnection.h
===================================================================
--- branches/0.77-branch/rts/System/Net/UDPConnection.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/Net/UDPConnection.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -10,7 +10,11 @@
 #include &quot;UDPSocket.h&quot;
 
 namespace netcode {
+#ifndef SYNCDEBUG
 const unsigned UDPBufferSize = 8192;
+#else
+const unsigned UDPBufferSize = 40000;
+#endif
 
 /**
 How Spring protocolheader looks like (size in bytes):

Copied: branches/0.77-branch/rts/System/Platform/Win/WinVersion.cpp (from rev 6422, trunk/rts/System/Platform/Win/WinVersion.cpp)
===================================================================
--- branches/0.77-branch/rts/System/Platform/Win/WinVersion.cpp	                        (rev 0)
+++ branches/0.77-branch/rts/System/Platform/Win/WinVersion.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,303 @@
+#include &lt;sstream&gt;
+#include &lt;string&gt;
+
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x500
+#endif
+
+#include &lt;windows.h&gt;
+
+#ifndef PRODUCT_BUSINESS
+
+#define PRODUCT_BUSINESS 0x00000006
+#define PRODUCT_BUSINESS_N 0x00000010
+#define PRODUCT_CLUSTER_SERVER 0x00000012
+#define PRODUCT_DATACENTER_SERVER 0x00000008
+#define PRODUCT_DATACENTER_SERVER_CORE 0x0000000C
+#define PRODUCT_DATACENTER_SERVER_CORE_V 0x00000027
+#define PRODUCT_DATACENTER_SERVER_V 0x00000025
+#define PRODUCT_ENTERPRISE 0x00000004
+#define PRODUCT_ENTERPRISE_N 0x0000001B
+#define PRODUCT_ENTERPRISE_SERVER 0x0000000A
+#define PRODUCT_ENTERPRISE_SERVER_CORE 0x0000000E
+#define PRODUCT_ENTERPRISE_SERVER_CORE_V 0x00000029
+#define PRODUCT_ENTERPRISE_SERVER_IA64 0x0000000F
+#define PRODUCT_ENTERPRISE_SERVER_V 0x00000026
+#define PRODUCT_HOME_BASIC 0x00000002
+#define PRODUCT_HOME_BASIC_N 0x00000005
+#define PRODUCT_HOME_PREMIUM 0x00000003
+#define PRODUCT_HOME_PREMIUM_N 0x0000001A
+#define PRODUCT_HOME_SERVER 0x00000013
+#define PRODUCT_HYPERV 0x0000002A
+#define PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT 0x0000001E
+#define PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING 0x00000020
+#define PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY 0x0000001F
+#define PRODUCT_SERVER_FOR_SMALLBUSINESS 0x00000018
+#define PRODUCT_SERVER_FOR_SMALLBUSINESS_V 0x00000023
+#define PRODUCT_SMALLBUSINESS_SERVER 0x00000009
+#define PRODUCT_STANDARD_SERVER 0x00000007
+#define PRODUCT_STANDARD_SERVER_CORE 0x0000000D
+#define PRODUCT_STANDARD_SERVER_CORE_V 0x00000028
+#define PRODUCT_STANDARD_SERVER_V 0x00000024
+#define PRODUCT_STARTER 0x0000000B
+#define PRODUCT_STORAGE_ENTERPRISE_SERVER 0x00000017
+#define PRODUCT_STORAGE_EXPRESS_SERVER 0x00000014
+#define PRODUCT_STORAGE_STANDARD_SERVER 0x00000015
+#define PRODUCT_STORAGE_WORKGROUP_SERVER 0x00000016
+#define PRODUCT_UNDEFINED 0x00000000
+#define PRODUCT_ULTIMATE 0x00000001
+#define PRODUCT_ULTIMATE_N 0x0000001C
+#define PRODUCT_WEB_SERVER 0x00000011
+#define PRODUCT_WEB_SERVER_CORE 0x0000001D
+
+#endif
+
+using namespace std;
+
+typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
+typedef BOOL (WINAPI *PGPI)(DWORD, DWORD, DWORD, DWORD, PDWORD);
+
+#ifndef SM_SERVERR2
+#define SM_SERVERR2 89
+#endif
+
+// this is a modified version of <A HREF="http://msdn.microsoft.com/en-us/library/ms724429(VS.85">http://msdn.microsoft.com/en-us/library/ms724429(VS.85</A>).aspx
+// always provide a long enough buffer
+std::string GetOSDisplayString()
+{
+    ostringstream oss;
+    OSVERSIONINFOEX osvi;
+    SYSTEM_INFO si;
+    PGNSI pGNSI;
+    PGPI pGPI;
+    BOOL bOsVersionInfoEx;
+    DWORD dwType;
+
+    ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
+    ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
+
+    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
+
+    if ( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &amp;osvi)) )
+        return string(&quot;error getting Windows version&quot;);
+
+    // Call GetNativeSystemInfo if supported or GetSystemInfo otherwise.
+
+    pGNSI = (PGNSI) GetProcAddress(
+                GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)),
+                &quot;GetNativeSystemInfo&quot;);
+    if (NULL != pGNSI)
+        pGNSI(&amp;si);
+    else GetSystemInfo(&amp;si);
+
+    if ( VER_PLATFORM_WIN32_NT==osvi.dwPlatformId &amp;&amp;
+            osvi.dwMajorVersion &gt; 4 )
+    {
+        oss &lt;&lt; &quot;Microsoft &quot;;
+
+        // Test for the specific product.
+
+        if ( osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 0 )
+        {
+            if ( osvi.wProductType == VER_NT_WORKSTATION )
+                oss &lt;&lt; &quot;Windows Vista &quot;;
+            else oss &lt;&lt; &quot;Windows Server 2008 &quot;;
+
+            pGPI = (PGPI) GetProcAddress(
+                       GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)),
+                       &quot;GetProductInfo&quot;);
+
+            pGPI( 6, 0, 0, 0, &amp;dwType);
+
+            switch ( dwType )
+            {
+            case PRODUCT_ULTIMATE:
+                oss &lt;&lt; &quot;Ultimate Edition&quot;;
+                break;
+            case PRODUCT_HOME_PREMIUM:
+                oss &lt;&lt; &quot;Home Premium Edition&quot;;
+                break;
+            case PRODUCT_HOME_BASIC:
+                oss &lt;&lt; &quot;Home Basic Edition&quot;;
+                break;
+            case PRODUCT_ENTERPRISE:
+                oss &lt;&lt; &quot;Enterprise Edition&quot;;
+                break;
+            case PRODUCT_BUSINESS:
+                oss &lt;&lt; &quot;Business Edition&quot;;
+                break;
+            case PRODUCT_STARTER:
+                oss &lt;&lt; &quot;Starter Edition&quot;;
+                break;
+            case PRODUCT_CLUSTER_SERVER:
+                oss &lt;&lt; &quot;Cluster Server Edition&quot;;
+                break;
+            case PRODUCT_DATACENTER_SERVER:
+                oss &lt;&lt; &quot;Datacenter Edition&quot;;
+                break;
+            case PRODUCT_DATACENTER_SERVER_CORE:
+                oss &lt;&lt; &quot;Datacenter Edition (core installation)&quot;;
+                break;
+            case PRODUCT_ENTERPRISE_SERVER:
+                oss &lt;&lt; &quot;Enterprise Edition&quot;;
+                break;
+            case PRODUCT_ENTERPRISE_SERVER_CORE:
+                oss &lt;&lt; &quot;Enterprise Edition (core installation)&quot;;
+                break;
+            case PRODUCT_ENTERPRISE_SERVER_IA64:
+                oss &lt;&lt; &quot;Enterprise Edition for Itanium-based Systems&quot;;
+                break;
+            case PRODUCT_SMALLBUSINESS_SERVER:
+                oss &lt;&lt; &quot;Small Business Server&quot;;
+                break;
+                /* 	undocumented?
+                case PRODUCT_SMALLBUSINESS_SERVER_PREMIUM:
+                oss &lt;&lt; &quot;Small Business Server Premium Edition&quot;;
+                break; */
+            case PRODUCT_STANDARD_SERVER:
+                oss &lt;&lt; &quot;Standard Edition&quot;;
+                break;
+            case PRODUCT_STANDARD_SERVER_CORE:
+                oss &lt;&lt; &quot;Standard Edition (core installation)&quot;;
+                break;
+            case PRODUCT_WEB_SERVER:
+                oss &lt;&lt; &quot;Web Server Edition&quot;;
+                break;
+            }
+            if ( si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64 )
+                oss &lt;&lt;  &quot;, 64-bit&quot;;
+            else if (si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_INTEL )
+                oss &lt;&lt; &quot;, 32-bit&quot;;
+        }
+
+        if ( osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 2 )
+        {
+            if ( GetSystemMetrics(SM_SERVERR2) )
+                oss &lt;&lt;  &quot;Windows Server 2003 R2, &quot;;
+            else if ( osvi.wSuiteMask==VER_SUITE_STORAGE_SERVER )
+                oss &lt;&lt;  &quot;Windows Storage Server 2003&quot;;
+            else if ( osvi.wProductType == VER_NT_WORKSTATION &amp;&amp;
+                      si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
+            {
+                oss &lt;&lt;  &quot;Windows XP Professional x64 Edition&quot;;
+            }
+            else oss &lt;&lt; &quot;Windows Server 2003, &quot;;
+
+            // Test for the server type.
+            if ( osvi.wProductType != VER_NT_WORKSTATION )
+            {
+                if ( si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_IA64 )
+                {
+                    if ( osvi.wSuiteMask &amp; VER_SUITE_DATACENTER )
+                        oss &lt;&lt;  &quot;Datacenter Edition for Itanium-based Systems&quot;;
+                    else if ( osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE )
+                        oss &lt;&lt;  &quot;Enterprise Edition for Itanium-based Systems&quot;;
+                }
+
+                else if ( si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64 )
+                {
+                    if ( osvi.wSuiteMask &amp; VER_SUITE_DATACENTER )
+                        oss &lt;&lt;  &quot;Datacenter x64 Edition&quot;;
+                    else if ( osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE )
+                        oss &lt;&lt;  &quot;Enterprise x64 Edition&quot;;
+                    else oss &lt;&lt;  &quot;Standard x64 Edition&quot;;
+                }
+
+                else
+                {
+                    if ( osvi.wSuiteMask &amp; VER_SUITE_COMPUTE_SERVER )
+                        oss &lt;&lt;  &quot;Compute Cluster Edition&quot;;
+                    else if ( osvi.wSuiteMask &amp; VER_SUITE_DATACENTER )
+                        oss &lt;&lt;  &quot;Datacenter Edition&quot;;
+                    else if ( osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE )
+                        oss &lt;&lt;  &quot;Enterprise Edition&quot; ;
+                    else if ( osvi.wSuiteMask &amp; VER_SUITE_BLADE )
+                        oss &lt;&lt;  &quot;Web Edition&quot;;
+                    else oss &lt;&lt;  &quot;Standard Edition&quot;;
+                }
+            }
+        }
+
+        if ( osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 1 )
+        {
+            oss &lt;&lt; &quot;Windows XP &quot;;
+            if ( osvi.wSuiteMask &amp; VER_SUITE_PERSONAL )
+                oss &lt;&lt;  &quot;Home Edition&quot;;
+            else oss &lt;&lt;  &quot;Professional&quot;;
+        }
+
+        if ( osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 0 )
+        {
+            oss &lt;&lt; &quot;Windows 2000 &quot;;
+
+            if ( osvi.wProductType == VER_NT_WORKSTATION )
+            {
+                oss &lt;&lt;  &quot;Professional&quot;;
+            }
+            else
+            {
+                if ( osvi.wSuiteMask &amp; VER_SUITE_DATACENTER )
+                    oss &lt;&lt;  &quot;Datacenter Server&quot;;
+                else if ( osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE )
+                    oss &lt;&lt;  &quot;Advanced Server&quot;;
+                else oss &lt;&lt;  &quot;Server&quot;;
+            }
+        }
+
+        // Include service pack (if any) and build number.
+
+        if (strlen(osvi.szCSDVersion) &gt; 0 )
+        {
+            oss &lt;&lt; &quot; &quot; &lt;&lt; osvi.szCSDVersion;
+        }
+
+        oss &lt;&lt; &quot; (build &quot; &lt;&lt; osvi.dwBuildNumber &lt;&lt; &quot;)&quot;;
+
+        return oss.str();
+    }
+
+    else
+    {
+        return string(&quot;unsupported version of Windows&quot;);
+    }
+}
+
+
+// this tries to read info about the CPU and available memory
+std::string GetHardwareInfoString()
+{
+    ostringstream oss;
+
+    unsigned char regbuf[200];
+    DWORD regLength=sizeof(regbuf);
+    DWORD regType=REG_SZ;
+    HKEY regkey;
+    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
+                     &quot;Hardware\\Description\\System\\CentralProcessor\\0&quot;,
+                     0, KEY_READ, &amp;regkey)==ERROR_SUCCESS)
+    {
+        if (RegQueryValueEx(regkey,&quot;ProcessorNameString&quot;,0,&amp;regType,regbuf,&amp;regLength)==ERROR_SUCCESS)
+        {
+            oss &lt;&lt; regbuf &lt;&lt; &quot;; &quot;;
+        }
+        else
+        {
+            oss &lt;&lt; &quot;cannot read processor data; &quot;;
+        }
+        RegCloseKey(regkey);
+    }
+    else
+    {
+        oss &lt;&lt; &quot;cannot open key with processor data; &quot;;
+    }
+
+    MEMORYSTATUSEX statex;
+    const int div = 1024*1024;
+    statex.dwLength = sizeof (statex);
+
+    GlobalMemoryStatusEx (&amp;statex);
+
+    oss &lt;&lt; (statex.ullTotalPhys/div) &lt;&lt; &quot;MB RAM, &quot;
+    &lt;&lt; (statex.ullTotalPageFile/div) &lt;&lt; &quot;MB pagefile&quot;;
+    return oss.str();
+}

Copied: branches/0.77-branch/rts/System/Platform/Win/WinVersion.h (from rev 6422, trunk/rts/System/Platform/Win/WinVersion.h)
===================================================================
--- branches/0.77-branch/rts/System/Platform/Win/WinVersion.h	                        (rev 0)
+++ branches/0.77-branch/rts/System/Platform/Win/WinVersion.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,7 @@
+#ifndef WINVERSION_H
+#define WINVERSION_H
+
+std::string GetOSDisplayString();
+std::string GetHardwareInfoString();
+
+#endif

Modified: branches/0.77-branch/rts/System/SpringApp.cpp
===================================================================
--- branches/0.77-branch/rts/System/SpringApp.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/SpringApp.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -50,6 +50,7 @@
 	#include &lt;winreg.h&gt;
 	#include &lt;direct.h&gt;
 	#include &quot;Platform/Win/seh.h&quot;
+	#include &quot;Platform/Win/WinVersion.h&quot;
 #endif // WIN32
 
 using std::string;
@@ -142,6 +143,34 @@
 }
 #endif
 
+#ifdef WIN32
+typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
+
+LPFN_ISWOW64PROCESS fnIsWow64Process;
+
+/** @brief checks if the current process is running in 32bit emulation mode
+    @return FALSE, TRUE, -1 on error (usually no permissions) */
+static int GetWow64Status()
+{
+	BOOL bIsWow64 = FALSE;
+
+	fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
+		GetModuleHandle(TEXT(&quot;kernel32&quot;)),&quot;IsWow64Process&quot;);
+
+	if (NULL != fnIsWow64Process)
+	{
+		if (!fnIsWow64Process(GetCurrentProcess(),&amp;bIsWow64))
+		{
+			return -1;
+		}
+	}
+	return bIsWow64;
+}
+
+
+#endif
+
+
 /**
  * @brief Initializes the SpringApp instance
  * @return whether initialization was successful
@@ -170,6 +199,25 @@
 
 	logOutput.SetMirrorToStdout(!!configHandler.GetInt(&quot;StdoutDebug&quot;,0));
 
+	// log OS version
+	// TODO: improve version logging of non-Windows OSes
+#if defined(WIN32)
+	logOutput.Print(&quot;OS: %s\n&quot;, GetOSDisplayString().c_str());
+	if (GetWow64Status() == TRUE) {
+		logOutput.Print(&quot;OS: WOW64 detected\n&quot;);
+	}
+	logOutput.Print(&quot;Hardware: %s\n&quot;, GetHardwareInfoString().c_str());
+#elif defined(__linux__)
+	logOutput.Print(&quot;OS: Linux\n&quot;);
+#elif defined(__FreeBSD__)
+	logOutput.Print(&quot;OS: FreeBSD\n&quot;);
+#elif defined(MACOS_X)
+	logOutput.Print(&quot;OS: MacOS X\n&quot;);
+#else
+	logOutput.Print(&quot;OS: unknown\n&quot;);
+#endif
+
+
 	FileSystemHandler::Initialize(true);
 
 	if (!InitWindow((&quot;Spring &quot; + std::string(VERSION_STRING)).c_str())) {
@@ -244,7 +292,7 @@
 	}
 
 	// use some ATI bugfixes?
-	gu-&gt;atiHacks = !!configHandler.GetInt(&quot;AtiHacks&quot;, 0);
+	gu-&gt;atiHacks = !!configHandler.GetInt(&quot;AtiHacks&quot;, (GLEW_ATI_envmap_bumpmap)?1:0 );
 
 	// Initialize named texture handler
 	CNamedTextures::Init();
@@ -340,7 +388,7 @@
 	sdlflags |= fullscreen ? SDL_FULLSCREEN : 0;
 
 	int bitsPerPixel = configHandler.GetInt(&quot;BitsPerPixel&quot;, 0);
-	
+
 	if (bitsPerPixel == 32)
 	{
 		SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
@@ -634,13 +682,13 @@
 	} else {
 		screenWidth = std::max(screenWidth, 1);
 	}
-	
+
 	if (!cmdline-&gt;result(&quot;yresolution&quot;, screenHeight)) {
 		screenHeight = configHandler.GetInt(&quot;YResolution&quot;, YRES_DEFAULT);
 	} else {
 		screenHeight = std::max(screenHeight, 1);
 	}
-	
+
 }
 
 /**

Modified: branches/0.77-branch/rts/System/Sync/Logger.h
===================================================================
--- branches/0.77-branch/rts/System/Sync/Logger.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/Sync/Logger.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -32,6 +32,7 @@
 		void CloseSession();
 
 		void SetFilename(const char* fn) { filename = fn; }
+		void FlushBuffer();
 
 	private:
 
@@ -39,7 +40,6 @@
 		CLogger(const CLogger&amp;);
 		CLogger&amp; operator=(const CLogger&amp;);
 
-		void FlushBuffer();
 		void CppFilt(char* sym, int size);
 
 		boost::mutex logmutex;

Modified: branches/0.77-branch/rts/System/Sync/SyncChecker.h
===================================================================
--- branches/0.77-branch/rts/System/Sync/SyncChecker.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/Sync/SyncChecker.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -10,6 +10,26 @@
 #include &lt;vector&gt;
 #include &lt;SDL_types.h&gt;
 
+#ifdef TRACE_SYNC
+#include &quot;Sync/SyncTracer.h&quot;
+#endif
+
+#include &lt;boost/cstdint.hpp&gt; /* Replace with &lt;stdint.h&gt; if appropriate */
+using boost::uint32_t;
+using boost::uint16_t;
+
+#undef get16bits
+#if (defined(__GNUC__) &amp;&amp; defined(__i386__)) || defined(__WATCOMC__) \
+  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)
+#define get16bits(d) (*((const uint16_t *) (d)))
+#endif
+
+#if !defined (get16bits)
+#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) &lt;&lt; 8)\
+                       +(uint32_t)(((const uint8_t *)(d))[0]) )
+#endif
+
+
 /**
  * @brief sync checker class
  *
@@ -21,49 +41,105 @@
 	public:
 
 		static unsigned GetChecksum() { return g_checksum; }
-		static void NewFrame() { g_checksum = 0; }
+		static void NewFrame() { g_checksum = 0xfade1eaf; }
 
+                /** @brief a fast hash function
+                 *
+                 * This hash function is roughly 4x as fast as CRC32, but even that is too slow.
+                 * We use a very simplistic add/xor feedback scheme when not debugging. */
+                static inline uint32_t HsiehHash (const char * data, int len, uint32_t hash) {
+                        uint32_t tmp;
+                        int rem;
+
+                        if (len &lt;= 0 || data == NULL) return 0;
+
+                        rem = len &amp; 3;
+                        len &gt;&gt;= 2;
+
+                        /* Main loop */
+                        for (;len &gt; 0; len--) {
+                                hash  += get16bits (data);
+                                tmp    = (get16bits (data+2) &lt;&lt; 11) ^ hash;
+                                hash   = (hash &lt;&lt; 16) ^ tmp;
+                                data  += 2*sizeof (uint16_t);
+                                hash  += hash &gt;&gt; 11;
+                        }
+
+                        /* Handle end cases */
+                        switch (rem) {
+                        case 3: hash += get16bits (data);
+                                hash ^= hash &lt;&lt; 16;
+                                hash ^= data[sizeof (uint16_t)] &lt;&lt; 18;
+                                hash += hash &gt;&gt; 11;
+                                break;
+                        case 2: hash += get16bits (data);
+                                hash ^= hash &lt;&lt; 11;
+                                hash += hash &gt;&gt; 17;
+                                break;
+                        case 1: hash += *data;
+                                hash ^= hash &lt;&lt; 10;
+                                hash += hash &gt;&gt; 1;
+                        }
+
+                        /* Force &quot;avalanching&quot; of final 127 bits */
+                        hash ^= hash &lt;&lt; 3;
+                        hash += hash &gt;&gt; 5;
+                        hash ^= hash &lt;&lt; 4;
+                        hash += hash &gt;&gt; 17;
+                        hash ^= hash &lt;&lt; 25;
+                        hash += hash &gt;&gt; 6;
+
+                        return hash;
+                }
+
 	private:
 
 		static unsigned g_checksum;
 
 		static inline void Sync(void* p, unsigned size) {
 			// most common cases first, make it easy for compiler to optimize for it
-			if (size == 1) {
-				g_checksum ^= *(unsigned char*)p;
-			} else if (size == 2) {
-				g_checksum ^= *(unsigned short*)(char*)p;
-			} else if (size == 4) {
-				g_checksum ^= *(unsigned int*)(char*)p;
-			} else {
-				// generic case
+			// simple xor is not enough to detect multiple zeroes, e.g.
+#ifdef TRACE_SYNC_HEAVY
+			g_checksum = HsiehHash((char*)p, size, g_checksum);
+#else
+			switch(size) {
+			case 1:
+				g_checksum += *(unsigned char*)p;
+				g_checksum ^= g_checksum &lt;&lt; 10;
+				g_checksum += g_checksum &gt;&gt; 1;
+				break;
+			case 2:
+				g_checksum += *(unsigned short*)(char*)p;
+				g_checksum ^= g_checksum &lt;&lt; 11;
+				g_checksum += g_checksum &gt;&gt; 17;
+				break;
+			case 4:
+				g_checksum += *(unsigned int*)(char*)p;
+				g_checksum ^= g_checksum &lt;&lt; 16;
+				g_checksum += g_checksum &gt;&gt; 11;
+				break;
+			default:
+			{
 				unsigned i = 0;
-				for (; i &lt; (size &amp; ~3); i += 4)
-					g_checksum ^= *(unsigned*) ((char*) p + i);
-				for (; i &lt; size; ++i)
-					g_checksum ^= *((unsigned char*) p + i);
+				for (; i &lt; (size &amp; ~3); i += 4) {
+					g_checksum += *(unsigned int*)(char*)p + i;
+					g_checksum ^= g_checksum &lt;&lt; 16;
+					g_checksum += g_checksum &gt;&gt; 11;
+				}
+				for (; i &lt; size; ++i) {
+					g_checksum += *(unsigned char*)p + i;
+					g_checksum ^= g_checksum &lt;&lt; 10;
+					g_checksum += g_checksum &gt;&gt; 1;
+				}
+				break;
 			}
+			}
+#endif
 		}
 
 		friend class CSyncedPrimitiveBase;
 };
 
-
-/**
- * @brief base class to use for synced classes
- */
-class CSyncedPrimitiveBase {
-
-	protected:
-
-		/**
-		 * @brief wrapper to call the private CSyncChecker::Sync()
-		 */
-		inline void Sync(void* p, unsigned size, const char*) {
-			CSyncChecker::Sync(p, size);
-		}
-};
-
 #endif // SYNCDEBUG
 
 #endif // SYNCDEBUGGER_H

Modified: branches/0.77-branch/rts/System/Sync/SyncDebugger.cpp
===================================================================
--- branches/0.77-branch/rts/System/Sync/SyncDebugger.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/Sync/SyncDebugger.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -6,7 +6,8 @@
 
 #include &quot;LogOutput.h&quot;
 #include &quot;System/GlobalStuff.h&quot;
-#include &quot;System/Net.h&quot;
+#include &quot;System/BaseNetProtocol.h&quot;
+#include &quot;System/NetProtocol.h&quot;
 #include &quot;SyncDebugger.h&quot;
 #include &quot;Logger.h&quot;
 
@@ -121,6 +122,8 @@
 
 	// init logger
 	logger.SetFilename(useBacktrace ? LOGFILE_SERVER : LOGFILE_CLIENT);
+	logger.AddLine(&quot;Syncdebugger initialised&quot;);
+	logger.FlushBuffer();
 }
 
 
@@ -174,7 +177,10 @@
 		for (unsigned i = 0; i &lt; historybt[index].bt_size; ++i) {
 			// the &quot;{%p}&quot; part is resolved to &quot;functionname [filename:lineno]&quot;
 			// by the CLogger class.
-			logger.AddLine(&quot;%s#%u {%p}&quot;, prefix, i, historybt[index].bt[i]);
+			if (sizeof(void*) == 8)
+				logger.AddLine(&quot;%s#%u {%llx}&quot;, prefix, i, (uint64_t)historybt[index].bt[i]);
+			else
+				logger.AddLine(&quot;%s#%u {%x}&quot;, prefix, i, (uint32_t)historybt[index].bt[i]);
 		}
 	}
 }
@@ -201,39 +207,41 @@
  * Plugin for the CGameServer network code in GameServer.cpp.
  * @return the number of bytes read from the network stream
  */
-int CSyncDebugger::ServerReceived(const unsigned char* inbuf)
+bool CSyncDebugger::ServerReceived(const unsigned char* inbuf)
 {
-	int length = 0;
+	bool syncDebugPacket = false;
 	switch (inbuf[0]) {
 		case NETMSG_SD_CHKRESPONSE:
 			if (*(short*)&amp;inbuf[1] != HISTORY_SIZE * sizeof(unsigned) + 12) {
 				logger.AddLine(&quot;Server: received checksum response of %d instead of %d bytes&quot;, *(short*)&amp;inbuf[1], HISTORY_SIZE * 4 + 12);
 			} else {
 				int player = inbuf[3];
-				if(player &gt;= gs-&gt;activeTeams || player &lt; 0) {
+				if(player &gt;= gs-&gt;activePlayers || player &lt; 0) {
 					logger.AddLine(&quot;Server: got invalid playernum %d in checksum response&quot;, player);
 				} else {
+					logger.AddLine(&quot;Server: got checksum response from %d&quot;, player);
 					const unsigned* begin = (unsigned*)&amp;inbuf[12];
 					const unsigned* end = begin + HISTORY_SIZE;
 					checksumResponses[player].resize(HISTORY_SIZE);
 					std::copy(begin, end, checksumResponses[player].begin());
 					remoteFlop[player] = *(Uint64*)&amp;inbuf[4];
+					assert(!checksumResponses[player].empty());
 					int i = 0;
-					while (i &lt; gs-&gt;activeTeams &amp;&amp; !checksumResponses[i].empty()) ++i;
-					if (i == gs-&gt;activeTeams) {
+					while (i &lt; gs-&gt;activePlayers &amp;&amp; !checksumResponses[i].empty()) ++i;
+					if (i == gs-&gt;activePlayers) {
 						ServerQueueBlockRequests();
 						logger.AddLine(&quot;Server: checksum responses received; %d block requests queued&quot;, pendingBlocksToRequest.size());
 					}
 				}
 			}
-			length = *(short*)&amp;inbuf[1];
+			syncDebugPacket = true;
 			break;
 		case NETMSG_SD_BLKRESPONSE:
 			if (*(short*)&amp;inbuf[1] != BLOCK_SIZE * sizeof(unsigned) + 4) {
 				logger.AddLine(&quot;Server: received block response of %d instead of %d bytes&quot;, *(short*)&amp;inbuf[1], BLOCK_SIZE * 4 + 4);
 			} else {
 				int player = inbuf[3];
-				if(player &gt;= gs-&gt;activeTeams || player &lt; 0) {
+				if(player &gt;= gs-&gt;activePlayers || player &lt; 0) {
 					logger.AddLine(&quot;Server: got invalid playernum %d in block response&quot;, player);
 				} else {
 					const unsigned* begin = (unsigned*)&amp;inbuf[4];
@@ -243,21 +251,21 @@
 					std::copy(begin, end, remoteHistory[player].begin() + size);
 					int i = 0;
 					size += BLOCK_SIZE;
-					while (i &lt; gs-&gt;activeTeams &amp;&amp; size == remoteHistory[i].size()) ++i;
-					if (i == gs-&gt;activeTeams) {
+					while (i &lt; gs-&gt;activePlayers &amp;&amp; size == remoteHistory[i].size()) ++i;
+					if (i == gs-&gt;activePlayers) {
 						logger.AddLine(&quot;Server: block responses received&quot;);
 						ServerReceivedBlockResponses();
 					}
 				}
 			}
-			length = *(short*)&amp;inbuf[1];
+			syncDebugPacket = true;
 			break;
 		default:
-			logger.AddLine(&quot;Server: invalid msg&quot;);
-			length = 0;
+			logger.AddLine(&quot;Server: unknown packet&quot;);
 			break;
 	}
-	return length;
+	logger.FlushBuffer();
+	return syncDebugPacket;
 }
 
 
@@ -267,9 +275,9 @@
  * Plugin for the CGame network code in Game.cpp.
  * @return the number of bytes read from the network stream
  */
-int CSyncDebugger::ClientReceived(const unsigned char* inbuf)
+bool CSyncDebugger::ClientReceived(const unsigned char* inbuf)
 {
-	int length = 0;
+	bool syncDebugPacket = false;
 	switch (inbuf[0]) {
 		case NETMSG_SD_CHKREQUEST:
 			if (gs-&gt;frameNum != *(int*)&amp;inbuf[1]) {
@@ -280,7 +288,7 @@
 				ClientSendChecksumResponse();
 				logger.AddLine(&quot;Client: checksum response sent&quot;);
 			}
-			length = 5;
+			syncDebugPacket = true;
 			break;
 		case NETMSG_SD_BLKREQUEST:
 			if (*(unsigned short*)&amp;inbuf[1] &gt;= HISTORY_SIZE) {
@@ -291,7 +299,7 @@
 				// simple progress indication
 				logOutput.Print(&quot;[SD] Client: %d / %d&quot;, *(unsigned short*)&amp;inbuf[3], *(unsigned short*)&amp;inbuf[5]);
 			}
-			length = 7;
+			syncDebugPacket = true;
 			break;
 		case NETMSG_SD_RESET:
 			logger.CloseSession();
@@ -302,29 +310,23 @@
 				logOutput.Print(&quot;[SD] Client: Automatical quit enforced from commandline&quot;);
 				globalQuit = true;
 			}
-			length = 1;
+			syncDebugPacket = true;
 			break;
-		default:
-			logOutput.Print(&quot;[SD] Client: invalid msg&quot;);
-			length = 0;
-			break;
 	}
-	return length;
+	logger.FlushBuffer();
+	return syncDebugPacket;
 }
 
 
 /**
  * @brief first step after desync
  *
- * Called by server to trigger sync error handling.
- * It pauses the game and sends a checksum request to all clients.
+ * Does nothing
  */
 void CSyncDebugger::ServerTriggerSyncErrorHandling(int serverframenum)
 {
 	if (!disable_history) {
 		//this will set disable_history = true once received so only one sync errors is handled at a time.
-		serverNet-&gt;SendPause(gu-&gt;myPlayerNum, true);
-		serverNet-&gt;SendData&lt; int &gt;(NETMSG_SD_CHKREQUEST, serverframenum);
 	}
 }
 
@@ -346,7 +348,7 @@
 		}
 		checksums.push_back(checksum);
 	}
-	net-&gt;SendSTLData&lt; unsigned char, Uint64, std::vector&lt;unsigned&gt; &gt;(NETMSG_SD_CHKRESPONSE, gu-&gt;myPlayerNum, flop, checksums);
+	net-&gt;Send(CBaseNetProtocol::Get().SendSdCheckresponse(gu-&gt;myPlayerNum, flop, checksums));
 }
 
 
@@ -361,8 +363,9 @@
  */
 void CSyncDebugger::ServerQueueBlockRequests()
 {
+	logger.AddLine(&quot;Server: queuing block requests&quot;);
 	Uint64 correctFlop = 0;
-	for (int j = 0; j &lt; gs-&gt;activeTeams; ++j) {
+	for (int j = 0; j &lt; gs-&gt;activePlayers; ++j) {
 		if (correctFlop) {
 			if (remoteFlop[j] != correctFlop)
 				logger.AddLine(&quot;Server: bad flop# %llu instead of %llu for player %d&quot;, remoteFlop[j], correctFlop, j);
@@ -374,7 +377,7 @@
 	for (; c &lt; HISTORY_SIZE; ++i, ++c) {
 		unsigned correctChecksum = 0;
 		if (i == HISTORY_SIZE) i = 0;
-		for (int j = 0; j &lt; gs-&gt;activeTeams; ++j) {
+		for (int j = 0; j &lt; gs-&gt;activePlayers; ++j) {
 			if (correctChecksum &amp;&amp; checksumResponses[j][i] != correctChecksum) {
 				pendingBlocksToRequest.push_back(i);
 				break;
@@ -389,7 +392,7 @@
 // 		serverNet-&gt;SendData&lt;unsigned&gt; (NETMSG_SD_BLKREQUEST, ii);
 	} else {
 		logger.AddLine(&quot;Server: huh, all blocks equal?!?&quot;);
-		serverNet-&gt;SendData(NETMSG_SD_RESET);
+		net-&gt;Send(CBaseNetProtocol::Get().SendSdReset());
 	}
 	//cleanup
 	for (int j = 0; j &lt; MAX_PLAYERS; ++j)
@@ -407,7 +410,7 @@
 {
 	if (!pendingBlocksToRequest.empty() &amp;&amp; !waitingForBlockResponse) {
 		// last two shorts are for progress indication
-		serverNet-&gt;SendData&lt;unsigned short, unsigned short, unsigned short&gt; (NETMSG_SD_BLKREQUEST, pendingBlocksToRequest.front(), requestedBlocks.size() - pendingBlocksToRequest.size() + 1, requestedBlocks.size());
+		net-&gt;Send(CBaseNetProtocol::Get().SendSdBlockrequest(pendingBlocksToRequest.front(), requestedBlocks.size() - pendingBlocksToRequest.size() + 1, requestedBlocks.size()));
 		waitingForBlockResponse = true;
 	}
 }
@@ -426,7 +429,7 @@
 			checksums.push_back(historybt[BLOCK_SIZE * block + i].chk);
 		else  checksums.push_back(history[BLOCK_SIZE * block + i].chk);
 	}
-	net-&gt;SendSTLData&lt; unsigned char, std::vector&lt;unsigned&gt; &gt;(NETMSG_SD_BLKRESPONSE, gu-&gt;myPlayerNum, checksums);
+	net-&gt;Send(CBaseNetProtocol::Get().SendSdBlockresponse(gu-&gt;myPlayerNum, checksums));
 }
 
 
@@ -481,7 +484,7 @@
 		unsigned correctChecksum = 0;
 		if (i == virtualHistorySize) i = 0;
 		bool err = false;
-		for (int j = 0; j &lt; gs-&gt;activeTeams; ++j) {
+		for (int j = 0; j &lt; gs-&gt;activePlayers; ++j) {
 			if (correctChecksum &amp;&amp; remoteHistory[j][i] != correctChecksum) {
 				if (historybt) {
 					virtualBlockNr = i / BLOCK_SIZE;
@@ -527,38 +530,13 @@
 	}
 
 	// and reset
-	serverNet-&gt;SendData(NETMSG_SD_RESET);
+	net-&gt;Send(CBaseNetProtocol::Get().SendSdReset());
 	logger.AddLine(&quot;Server: Done!&quot;);
 	logger.CloseSession();
 	logOutput.Print(&quot;[SD] Server: Done!&quot;);
 }
 
-
 /**
- * @brief helper network plugin function
- *
- * @return the size of the sync debugger related net message in inbuf
- * at index 0 (if any), zero otherwise.
- */
-int CSyncDebugger::GetMessageLength(const unsigned char* inbuf) const
-{
-	switch (inbuf[0]) {
-		case NETMSG_SD_CHKREQUEST:
-			return 5;
-		case NETMSG_SD_BLKREQUEST:
-			return 7;
-		case NETMSG_SD_CHKRESPONSE:
-		case NETMSG_SD_BLKRESPONSE:
-			return *(short*)&amp;inbuf[1];
-		case NETMSG_SD_RESET:
-			return 1;
-		default:
-			return 0;
-	}
-}
-
-
-/**
  * @brief re-enable the history
  *
  * Restart the sync debugger lifecycle, so it can be used again (if the sync

Modified: branches/0.77-branch/rts/System/Sync/SyncDebugger.h
===================================================================
--- branches/0.77-branch/rts/System/Sync/SyncDebugger.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/Sync/SyncDebugger.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -127,31 +127,14 @@
 
 		void Initialize(bool useBacktrace);
 		void ServerTriggerSyncErrorHandling(int serverframenum);
-		int ServerReceived(const unsigned char* inbuf);
+		bool ServerReceived(const unsigned char* inbuf);
 		void ServerHandlePendingBlockRequests();
-		int ClientReceived(const unsigned char* inbuf);
-		int GetMessageLength(const unsigned char* inbuf) const;
+		bool ClientReceived(const unsigned char* inbuf);
 		void Reset();
 
 		friend class CSyncedPrimitiveBase;
 };
 
-
-/**
- * @brief base class to use for synced classes
- */
-class CSyncedPrimitiveBase {
-
-	protected:
-
-		/**
-		 * @brief wrapper to call the private CSyncDebugger::Sync()
-		 */
-		void Sync(void* p, unsigned size, const char* op) {
-			CSyncDebugger::GetInstance()-&gt;Sync(p, size, op);
-		}
-};
-
 #endif // SYNCDEBUG
 
 #endif // SYNCDEBUGGER_H

Modified: branches/0.77-branch/rts/System/Sync/SyncTracer.cpp
===================================================================
--- branches/0.77-branch/rts/System/Sync/SyncTracer.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/Sync/SyncTracer.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -19,8 +19,12 @@
 #ifdef TRACE_SYNC
 	if (logfile == 0) {
 		char c[100];
-		sprintf(c, &quot;trace%i.log&quot;, gu-&gt;myTeam);
+		if (gu)
+			sprintf(c, &quot;trace%i.log&quot;, gu-&gt;myTeam);
+		else
+			sprintf(c, &quot;trace_early.log&quot;);
 		logfile = SAFE_NEW std::ofstream(c);
+		logOutput.Print(&quot;Sync trace log: %s\n&quot;, c);
 	}
 #endif
 	return logfile != 0;
@@ -47,7 +51,10 @@
 #ifdef TRACE_SYNC
 	if(file == 0){
 		char c[100];
-		sprintf(c, &quot;trace%i.txt&quot;, gu-&gt;myTeam);
+		if (gu)
+			sprintf(c, &quot;trace%i.log&quot;, gu-&gt;myTeam);
+		else
+			sprintf(c, &quot;trace_early.log&quot;);
 		file = SAFE_NEW std::ofstream(c);
 	}
 #endif
@@ -97,6 +104,15 @@
 	return *this;
 }
 
+CSyncTracer&amp; CSyncTracer::operator&lt;&lt;(const unsigned i)
+{
+	char t[20];
+	sprintf(t,&quot;%d&quot;,i);
+	traces[nowActive]+=t;
+	if (init()) (*logfile) &lt;&lt; i;
+	return *this;
+}
+
 CSyncTracer&amp; CSyncTracer::operator&lt;&lt;(const float f)
 {
 	char t[50];

Modified: branches/0.77-branch/rts/System/Sync/SyncTracer.h
===================================================================
--- branches/0.77-branch/rts/System/Sync/SyncTracer.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/Sync/SyncTracer.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -22,6 +22,7 @@
 
 	CSyncTracer&amp; operator&lt;&lt;(const char* c);
 	CSyncTracer&amp; operator&lt;&lt;(const int i);
+	CSyncTracer&amp; operator&lt;&lt;(const unsigned i);
 	CSyncTracer&amp; operator&lt;&lt;(const float f);
 
 	std::ofstream* file;

Modified: branches/0.77-branch/rts/System/Sync/SyncedPrimitive.h
===================================================================
--- branches/0.77-branch/rts/System/Sync/SyncedPrimitive.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/System/Sync/SyncedPrimitive.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -7,6 +7,7 @@
 
 #include &quot;SyncChecker.h&quot;  // for CSyncedPrimitiveBase (if SYNCCHECK is defined)
 #include &quot;SyncDebugger.h&quot; // for CSyncedPrimitiveBase (if SYNCDEBUG is defined)
+#include &quot;SyncedPrimitiveBase.h&quot;
 #include &quot;Upcast.h&quot;       // for UPCAST macro
 
 /*

Copied: branches/0.77-branch/rts/System/Sync/SyncedPrimitiveBase.h (from rev 6422, trunk/rts/System/Sync/SyncedPrimitiveBase.h)
===================================================================
--- branches/0.77-branch/rts/System/Sync/SyncedPrimitiveBase.h	                        (rev 0)
+++ branches/0.77-branch/rts/System/Sync/SyncedPrimitiveBase.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,28 @@
+#ifndef SYNCED_PRIMITIVE_BASSE_H
+#define SYNCED_PRIMITIVE_BASSE_H
+
+
+/**
+ * @brief base class to use for synced classes
+ */
+class CSyncedPrimitiveBase {
+
+	protected:
+
+		/**
+	 * @brief wrapper to call the private CSyncDebugger::Sync()
+		 */
+		void Sync(void* p, unsigned size, const char* op) {
+#ifdef SYNCDEBUG
+			CSyncDebugger::GetInstance()-&gt;Sync(p, size, op);
+#endif
+#ifdef SYNCCHECK
+			CSyncChecker::Sync(p, size);
+	#ifdef TRACE_SYNC_HEAVY
+			tracefile &lt;&lt; &quot;Sync &quot; &lt;&lt; op &lt;&lt; &quot; &quot; &lt;&lt; CSyncChecker::GetChecksum() &lt;&lt; &quot;\n&quot;;
+	#endif
+#endif
+		}
+};
+
+#endif

Modified: branches/0.77-branch/rts/build/scons/rts.py
===================================================================
--- branches/0.77-branch/rts/build/scons/rts.py	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/build/scons/rts.py	2008-09-15 18:44:36 UTC (rev 6427)
@@ -91,6 +91,7 @@
 		('debugdefines',      'Set to no to suppress DEBUG and _DEBUG preprocessor #defines (use to add symbols to release build)', True),
 		('syncdebug',         'Set to yes to enable the sync debugger', False),
 		('synccheck',         'Set to yes to enable sync checker &amp; resyncer', True),
+		('synctrace',         'Enable sync tracing', False),
 		('optimize',          'Enable processor optimizations during compilation', 1),
 		('profile',           'Set to yes to produce a binary with profiling information', False),
 		('profile_generate',  'Set to yes to compile with -fprofile-generate to generate profiling information', False),
@@ -308,9 +309,7 @@
 		# Must come before the '-fvisibility=hidden' code.
 		bool_opt('syncdebug', False)
 		bool_opt('synccheck', True)
-		if env['syncdebug'] and env['synccheck']:
-			print &quot;syncdebug and synccheck are mutually exclusive. Please choose one.&quot;
-			env.Exit(1)
+		bool_opt('synctrace', False)
 		string_opt('fpmath', '387')
 
 		# If sync debugger is on, disable inlining, as it makes it much harder to follow backtraces.
@@ -383,6 +382,8 @@
 			spring_defines += ['SYNCDEBUG']
 		if env['synccheck']:
 			spring_defines += ['SYNCCHECK']
+		if env['synctrace']:
+			spring_defines += ['TRACE_SYNC']
 
 		# Don't define this: it causes a full recompile when you change it, even though it is only used in Main.cpp,
 		# and some AIs maybe.  Just make exceptions in SConstruct.

Modified: branches/0.77-branch/rts/build/vstudio8/rts.vcproj
===================================================================
--- branches/0.77-branch/rts/build/vstudio8/rts.vcproj	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/build/vstudio8/rts.vcproj	2008-09-15 18:44:36 UTC (rev 6427)
@@ -5028,6 +5028,14 @@
 						RelativePath=&quot;..\..\System\Platform\Win\WinFileSystemHandler.h&quot;
 						&gt;
 					&lt;/File&gt;
+					&lt;File
+						RelativePath=&quot;..\..\System\Platform\Win\WinVersion.cpp&quot;
+						&gt;
+					&lt;/File&gt;
+					&lt;File
+						RelativePath=&quot;..\..\System\Platform\Win\WinVersion.h&quot;
+						&gt;
+					&lt;/File&gt;
 				&lt;/Filter&gt;
 			&lt;/Filter&gt;
 			&lt;Filter
@@ -12578,13 +12586,6 @@
 				&lt;File
 					RelativePath=&quot;..\..\lib\gml\gml.cpp&quot;
 					&gt;
-					&lt;FileConfiguration
-						Name=&quot;Release+MT with error catching|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
 				&lt;/File&gt;
 				&lt;File
 					RelativePath=&quot;..\..\lib\gml\gml.h&quot;

Modified: branches/0.77-branch/rts/lib/gml/gml.cpp
===================================================================
--- branches/0.77-branch/rts/lib/gml/gml.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/lib/gml/gml.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -41,11 +41,15 @@
 
 // TLS (thread local storage) thread identifier
 #if GML_ENABLE
-#ifdef _MSC_VER
+#	ifdef _MSC_VER
+#		if !GML_MSC_TLS_OPT
 __declspec(thread) int gmlThreadNumber=0;
-#else
+#		endif
+#	else
+#		if !GML_GCC_TLS_FIX &amp;&amp; !GML_USE_SPEEDY_TLS
 __thread int gmlThreadNumber=0;
-#endif
+#		endif
+#	endif
 #else
 int gmlThreadNumber=0;
 #endif

Modified: branches/0.77-branch/rts/lib/gml/gmlcls.h
===================================================================
--- branches/0.77-branch/rts/lib/gml/gmlcls.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/lib/gml/gmlcls.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -12,13 +12,13 @@
 #include &lt;GL/glew.h&gt;
 
 #ifndef GML_COMPATIBLE_ATOMIC_COUNT
-# ifdef BOOST_DETAIL_ATOMIC_COUNT_HPP_INCLUDED
-#  error &quot;Please make sure StdAfx.h is included before anything that includes boost&quot;
-# endif
-# define GML_COMPATIBLE_ATOMIC_COUNT
-# define private public
-# include &lt;boost/detail/atomic_count.hpp&gt;
-# undef private
+#	ifdef BOOST_DETAIL_ATOMIC_COUNT_HPP_INCLUDED
+#		error &quot;Please make sure StdAfx.h is included before anything that includes boost&quot;
+#	endif
+#	define GML_COMPATIBLE_ATOMIC_COUNT
+#	define private public
+#	include &lt;boost/detail/atomic_count.hpp&gt;
+#	undef private
 #endif
 
 #include &lt;boost/thread/mutex.hpp&gt;
@@ -48,46 +48,145 @@
 #define GML_UPDSRV_INTERVAL 10
 #define GML_ALTERNATE_SYNCMODE 1 // mutex-protected synced execution, slower but more portable
 #define GML_ENABLE_TLS_CHECK 1 // check if Thread Local Storage appears to be working
+#define GML_GCC_TLS_FIX 1 // fix buggy TLS in GCC by using the Win32 TIB (faster also!)
+#define GML_MSC_TLS_OPT 1 // use the Win32 TIB for TLS in MSVC (possibly faster)
+#define GML_64BIT_USE_GS 1 // 64-bit OS will use the GS register for TLS (untested feature)
+#define GML_LOCKED_GMLCOUNT_ASSIGNMENT 0 // experimental feature, probably not needed
+//#define BOOST_AC_USE_PTHREADS
 
-//#define BOOST_AC_USE_PTHREADS
-#ifdef _MSC_VER
-#define GML_ORDERED_VOLATILE (_MSC_VER &gt;= 1400) 
+// memory barriers for different platforms
+#if defined(__APPLE__) || defined(__FreeBSD__)
+#	include &lt;libkern/OSAtomic.h&gt;
+#	define GML_MEMBAR OSMemoryBarrier()
+#elif defined(__GNUC__)
+#	if (__GNUC__ &gt; 4) || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 1)
+#		define GML_MEMBAR __sync_synchronize()
+#	elif defined( __ppc__ ) || defined( __powerpc__) || defined( __PPC__ )
+#		define GML_MEMBAR asm volatile(&quot;sync&quot;:::&quot;memory&quot;)
+#	elif defined( __i386__ ) || defined( __i486__ ) || defined( __i586__ ) || defined( __i686__ ) || defined( __x86_64__ )
+#		define GML_MEMBAR asm volatile(&quot;mfence&quot;:::&quot;memory&quot;)
+#	endif
+#elif defined(_MSC_VER)
+#	if (_MSC_VER &gt;= 1400) 
+#		define GML_MEMBAR // no barrier needed for MSVS 2005
+#	else
+#		define GML_MEMBAR MemoryBarrier() // _asm {lock add [esp], 0}
+#	endif
+#elif defined(__BORLANDC__)
+#	define GML_MEMBAR _asm {lock add [esp], 0}
+#endif
+
+#ifdef GML_MEMBAR
+#	define GML_ORDERED_VOLATILE 1
 #else
-#define GML_ORDERED_VOLATILE 0
+#	define GML_ORDERED_VOLATILE 0
+#	define GML_MEMBAR
 #endif
+
 // optimize by assuming volatile accesses are
-// guaranteed not to be reordered (MSVS 2005 ONLY)
+// guaranteed not to be reordered (MSVS 2005 or memory barrier needed)
 // <A HREF="http://msdn.microsoft.com/en-us/library/12a04hfd(VS.80">http://msdn.microsoft.com/en-us/library/12a04hfd(VS.80</A>).aspx
 // <A HREF="http://msdn.microsoft.com/en-us/library/ms686355(VS.85">http://msdn.microsoft.com/en-us/library/ms686355(VS.85</A>).aspx
 // <A HREF="http://msdn.microsoft.com/en-us/library/bb310595(VS.85">http://msdn.microsoft.com/en-us/library/bb310595(VS.85</A>).aspx
 
 #if GML_ORDERED_VOLATILE
-#define GML_VOLATILE(x) *(x volatile *)&amp;
-#define GML_MUTEX
-#define GML_MUTEX_LOCK()
-#define GML_MUTEX_UNLOCK()
+#	define GML_VOLATILE(x) *(x volatile *)&amp;
+#	define GML_MUTEX
+#	define GML_MUTEX_LOCK()
+#	define GML_MUTEX_UNLOCK()
 #else
-#define GML_VOLATILE(x)
-#define GML_MUTEX gmlMutex mutex
-#define GML_MUTEX_LOCK() mutex.Lock()
-#define GML_MUTEX_UNLOCK() mutex.Unlock()
+#	define GML_VOLATILE(x)
+#	define GML_MUTEX gmlMutex mutex
+#	define GML_MUTEX_LOCK() mutex.Lock()
+#	define GML_MUTEX_UNLOCK() mutex.Unlock()
 #endif
 
 #ifdef _MSC_VER
-#define GML_TYPENAME typename
+#	define GML_TYPENAME typename
 #else
-#define GML_TYPENAME
+#	define GML_TYPENAME
 #endif
 
+#if !defined(WIN32) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(__WIN32__) //defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)
+#define GML_USE_SPEEDY_TLS 1
+#else
+#define GML_USE_SPEEDY_TLS 0
+#endif
+#if GML_USE_SPEEDY_TLS
+#	include &quot;speedy-tls.h&quot;
+#endif
+
+#define set_threadnum(val) gmlThreadNumber=val
+
 #if GML_ENABLE
-#ifdef _MSC_VER
-extern __declspec(thread) int gmlThreadNumber;
+#	ifdef _MSC_VER
+#		if GML_MSC_TLS_OPT
+static inline unsigned long get_threadnum(void) {
+	unsigned long val;
+	__asm {
+#if !defined(_WIN64) || !GML_64BIT_USE_GS
+		mov EAX, FS:[14h]
 #else
-extern __thread int gmlThreadNumber;
+		mov EAX, GS:[28h]
 #endif
+		mov [val], EAX
+	}
+	return val;
+}
+#			define gmlThreadNumber get_threadnum()
+#			undef set_threadnum
+static inline void set_threadnum(unsigned long val) {
+	__asm {
+		mov EAX, [val]
+#if !defined(_WIN64) || !GML_64BIT_USE_GS
+		mov FS:[14h], EAX
 #else
+		mov GS:[28h], EAX
+#endif
+	}
+}
+#		else
+extern __declspec(thread) int gmlThreadNumber;
+#		endif
+#	else
+#		if GML_GCC_TLS_FIX || GML_USE_SPEEDY_TLS
+static inline unsigned long get_threadnum(void) {
+	unsigned long val;
+#			if GML_GCC_TLS_FIX
+#				if !defined(_WIN64) || !GML_64BIT_USE_GS
+	__asm__(&quot;mov %%fs:0x14, %0&quot; : &quot;=r&quot; (val) : : );
+#				else
+	__asm__(&quot;mov %%gs:0x28, %0&quot; : &quot;=r&quot; (val) : : );
+#				endif
+#			else
+	speedy_tls_get_int32(0, 0, sizeof(unsigned long), val);
+#			endif
+	return val;
+}
+#			define gmlThreadNumber get_threadnum()
+#			undef set_threadnum
+static inline void set_threadnum(unsigned long val) {
+#			if GML_GCC_TLS_FIX
+#				if !defined(_WIN64) || !GML_64BIT_USE_GS
+	__asm__ __volatile__(&quot;mov %0,%%fs:0x14&quot; : : &quot;r&quot; (val));
+#				else
+	__asm__ __volatile__(&quot;mov %0,%%gs:0x28&quot; : : &quot;r&quot; (val));
+#				endif
+#			else
+	if (speedy_tls_init(sizeof(unsigned long))&lt;0) { // this works because we only set the thread number once per thread
+		handleerror(NULL, &quot;Failed to initialize Thread Local Storage&quot;, &quot;GML error:&quot;, MBF_OK | MBF_EXCL);
+	}
+	speedy_tls_put_int32(0, 0, sizeof(unsigned long), val);
+#			endif
+}
+#		else
+extern __thread int gmlThreadNumber;
+#		endif
+#	endif
+#else
 extern int gmlThreadNumber;
 #endif
+
 extern int gmlThreadCount;
 extern int gmlThreadCountOverride;
 extern unsigned gmlCPUCount();
@@ -225,9 +324,32 @@
 };
 #endif
 
-// this hack will assign the counter of a boost atomic_count object
+// this will assign the counter of a boost atomic_count object
 inline void operator%=(gmlCount&amp; a, long val) {
+#if GML_LOCKED_GMLCOUNT_ASSIGNMENT
+	#if defined(BOOST_AC_USE_PTHREADS)
+		boost::mutex::scoped_lock lock(a.mutex_);
+		a.value_=val;
+	#elif (BOOST_VERSION&gt;=103500) &amp;&amp; (defined(__GNUC__) &amp;&amp; (defined(__i386__) || defined(__x86_64__)))
+		__asm__ __volatile__(&quot;lock\n\txchgl %0,%1\n\t&quot; : &quot;=r&quot; (val) : &quot;m&quot; (a.value_), &quot;0&quot; (val) : &quot;memory&quot;);
+	#elif defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
+		return BOOST_INTERLOCKED_EXCHANGE(&amp;a.value_,val);
+	#elif (BOOST_VERSION&gt;=103500) &amp;&amp; (defined(__GNUC__) &amp;&amp; (__GNUC__*100+__GNUC_MINOR__&gt;=401))
+		__sync_exchange_FIXME(&amp;a.value_, val);
+	#elif defined(__GLIBCXX__)
+		__gnu_cxx::__exchange_FIXME(&amp;a.value_, val);
+	#elif defined(__GLIBCPP__)
+		__exchange_FIXME(&amp;a.value_, val);
+	#elif defined(BOOST_HAS_PTHREADS)
+		#define BOOST_AC_USE_PTHREADS
+		boost::mutex::scoped_lock lock(a.mutex_);
+		a.value_=val;
+	#else
+		#error Unrecognized threading platform
+	#endif
+#else
 	a.value_=val;
+#endif
 /*#ifdef BOOST_AC_USE_PTHREADS
 	a.~gmlCount();
 #endif
@@ -334,7 +456,8 @@
 							int ms;
 							if(sz==(ms=GML_VOLATILE(int) maxsize))
 								Expand(da,ms);
-							new (da+sz-1) T();
+							new ((void *)(volatile T *)(da+sz-1)) T();
+							GML_MEMBAR;
 							++added;
 						}
 						else {
@@ -387,7 +510,8 @@
 				int ms;
 				if(sz==(ms=GML_VOLATILE(int) maxsize))
 					Expand(da,ms);
-				new (da+sz-1) T(d);
+				new ((void *)(volatile T *)(da+sz-1)) T(d);
+				GML_MEMBAR;
 				++added;
 				return;
 			}
@@ -425,6 +549,7 @@
 		int ms2=ms&lt;&lt;1;
 		da=(T *)volatile_realloc((BYTE *)da,ms*sizeof(T),ms2*sizeof(T));
 		GML_VOLATILE(T *) data=da; 
+		GML_MEMBAR;
 		GML_VOLATILE(int) maxsize=ms2;
 	}
 	
@@ -535,6 +660,7 @@
 		if(sz==(ms=GML_VOLATILE(int) maxsize))
 			Expand(da,ms);
 		*(volatile T *)(da+sz-1)=d;
+		GML_MEMBAR;
 		++added;
 #else
 		mutex.Lock();
@@ -563,7 +689,8 @@
 		shrinksize=ms;
 		int ms2=ms&lt;&lt;1;
 		da=(T *)volatile_realloc((BYTE *)da,ms*sizeof(T),ms2*sizeof(T));
-		GML_VOLATILE(T *) data=da; 
+		GML_VOLATILE(T *) data=da;
+		GML_MEMBAR;
 		GML_VOLATILE(int) maxsize=ms2;
 	}
 	
@@ -685,6 +812,7 @@
 };
 
 
+
 template&lt;class T,class S, class C&gt;
 class gmlItemSequenceServer {
 	typedef void (*delitemseqfun)(T, S);
@@ -733,6 +861,7 @@
 		while(avail&lt;req+pregen &amp;&amp; item_arr[i=(avail%arr_size)]==0) {
 			GML_MUTEX_LOCK();
 			*(volatile T *)(item_arr+i)=(*genfun)(1);
+			GML_MEMBAR; // perhaps not needed, because ++avail acts as a barrier
 			GML_MUTEX_UNLOCK();
 			++avail;
 		}
@@ -741,7 +870,9 @@
 			int gensize=size_large;
 			GML_MUTEX_LOCK();
 			*(volatile T *)(large_item_arr+i)=(*genfun)(gensize);
+			GML_MEMBAR;
 			*(volatile T *)(large_size_arr+i)=gensize;
+			GML_MEMBAR; // perhaps not needed, because ++avail_large acts as a barrier
 			GML_MUTEX_UNLOCK();
 			++avail_large;
 		}
@@ -776,6 +907,7 @@
 			T ip=*(volatile T *)(large_item_arr+idx);
 			T *sz=large_size_arr+idx;
 			T szv=*(volatile T *)sz;
+			GML_MEMBAR;
 			*(volatile T *)sz=0;
 			GML_MUTEX_UNLOCK();
 			if(szv&gt;static_cast&lt;T&gt;(n))
@@ -817,6 +949,7 @@
 		while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
 			GML_MUTEX_LOCK();
 			*(volatile T *)(arr+i)=(*genfun)();
+			GML_MEMBAR; // perhaps not needed, because ++avail acts as a barrier
 			GML_MUTEX_UNLOCK();
 			++avail;
 		}
@@ -833,6 +966,7 @@
 		T *ip=arr+(num-1)%arr_size;
 		GML_MUTEX_LOCK();
 		T ret=*(volatile T *)ip;
+		GML_MEMBAR; // probably not needed, becase reordering is not possible
 		*(volatile T *)ip=0;
 		GML_MUTEX_UNLOCK();
 		return ret;
@@ -870,6 +1004,7 @@
 			(*genfun)(1,&amp;val);
 			GML_MUTEX_LOCK();
 			*(volatile T *)(arr+i)=val;
+			GML_MEMBAR; // perhaps not needed, because ++avail acts as a barrier
 			GML_MUTEX_UNLOCK();
 			++avail;
 		}
@@ -888,6 +1023,7 @@
 			T *ip=arr+(num-1)%arr_size;
 			GML_MUTEX_LOCK();
 			data[i]=*(volatile T *)ip;
+			GML_MEMBAR; // probably not needed, becase reordering is not possible
 			*(volatile T *)ip=0;
 			GML_MUTEX_UNLOCK();
 		}

Modified: branches/0.77-branch/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/0.77-branch/rts/lib/gml/gmlsrv.h	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/rts/lib/gml/gmlsrv.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -167,6 +167,7 @@
 					if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
 						gmlUpdateServers();
 					BOOL_ processed=FALSE;
+
 					for(int i=1; i&lt;gmlThreadCount; ++i) {
 						gmlQueue *qd=&amp;gmlQueues[i];
 						if(qd-&gt;Reloc)
@@ -186,6 +187,7 @@
 							//						++nproc;
 						}
 					}
+
 					if(ClientsReady&gt;=gmlThreadCount-1)
 						++ClientsReady;
 				}
@@ -204,31 +206,30 @@
 	}
 
 	void WorkInit() {
-		if(!inited) {
-			gmlInit();
+		set_threadnum(0);
+		gmlInit();
 
-			for(int i=1; i&lt;gmlThreadCount; ++i)
-				threads[i]=new boost::thread(boost::bind&lt;void, gmlClientServer, gmlClientServer*&gt;(&amp;gmlClientServer::gmlClient, this));
+		for(int i=1; i&lt;gmlThreadCount; ++i)
+			threads[i]=new boost::thread(boost::bind&lt;void, gmlClientServer, gmlClientServer*&gt;(&amp;gmlClientServer::gmlClient, this));
 #if GML_ENABLE_TLS_CHECK
-			for(int i=0; i&lt;GML_MAX_NUM_THREADS; ++i)
-				boost::thread::yield();
-			if(gmlThreadNumber!=0) {
-				handleerror(NULL, &quot;Thread Local Storage test failed&quot;, &quot;GML error:&quot;, MBF_OK | MBF_EXCL);
-			}
+		for(int i=0; i&lt;GML_MAX_NUM_THREADS; ++i)
+			boost::thread::yield();
+		if(gmlThreadNumber!=0) {
+			handleerror(NULL, &quot;Thread Local Storage test failed&quot;, &quot;GML error:&quot;, MBF_OK | MBF_EXCL);
+		}
 #endif
-			inited=TRUE;
-		}
+		inited=TRUE;
 	}
 
 	void Work(R (*wrk)(void *),R (*wrka)(void *,A), R (*wrkit)(void *,U),void *cls,int mt,BOOL_ sm, GML_TYPENAME std::list&lt;U&gt; *it,int nu,int l1,int l2,BOOL_ sw,void (*swf)(void *)=NULL) {
+		if(!inited)
+			WorkInit();
 		if(gmlThreadNumber!=0) {
 			NewWork(wrk,wrka,wrkit,cls,mt,sm,it,nu,l1,l2,sw,swf);
 			return;
 		}
 		GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState;
 		new (ex) GML_TYPENAME gmlExecState&lt;R,A,U&gt;(wrk,wrka,wrkit,cls,mt,sm,nu,it,l1,l2,sw,swf);
-		if(!inited)
-			WorkInit();
 		gmlServer();
 	}
 
@@ -296,7 +297,7 @@
 	}
 
 	void gmlClient() {
-		gmlThreadNumber=++threadcnt;
+		set_threadnum(++threadcnt);
 		streflop_init&lt;streflop::Simple&gt;();
 		while(dorun) {
 			gmlClientSub();

Copied: branches/0.77-branch/rts/lib/gml/speedy-tls.cpp (from rev 6422, trunk/rts/lib/gml/speedy-tls.cpp)
===================================================================
--- branches/0.77-branch/rts/lib/gml/speedy-tls.cpp	                        (rev 0)
+++ branches/0.77-branch/rts/lib/gml/speedy-tls.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,438 @@
+//Copyright (C) 2008 Kevin Hoffman. See LICENSE for use and warranty disclaimer.
+//Speedy TLS 1.0. Latest version at <A HREF="http://www.kevinjhoffman.com/">http://www.kevinjhoffman.com/</A>
+//Contains macros that can be used to very quickly (one instruction) access thread-local memory.
+
+#ifdef USE_GML
+#if !defined(WIN32) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(__WIN32__)
+
+#include &quot;speedy-tls.h&quot;
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;sys/mman.h&gt;
+#include &lt;fcntl.h&gt;
+
+//============================================================================================================== INTEL =====================
+#ifdef __intel__
+
+//Useful reading:
+//  <A HREF="http://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_01.htm">http://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_01.htm</A>
+//  <A HREF="http://www.intel.com/products/processor/manuals/">http://www.intel.com/products/processor/manuals/</A> (especially volume 3A)
+//	Descriptor/Selector format for i386
+//
+//  <A HREF="http://en.wikipedia.org/wiki/X86_assembly_language#Segmented_addressing">http://en.wikipedia.org/wiki/X86_assembly_language#Segmented_addressing</A>
+//      More info on segmented addressing.
+//
+//  <A HREF="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s7">http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s7</A>
+//  <A HREF="http://asm.sourceforge.net/articles/rmiyagi-inline-asm.txt">http://asm.sourceforge.net/articles/rmiyagi-inline-asm.txt</A>  
+//      Intros to inline assembly in GCC
+//
+//  <A HREF="http://www.microsoft.com/msj/archive/S2CE.aspx">http://www.microsoft.com/msj/archive/S2CE.aspx</A>
+//  <A HREF="http://en.wikipedia.org/wiki/Win32_Thread_Information_Block">http://en.wikipedia.org/wiki/Win32_Thread_Information_Block</A>
+//  <A HREF="http://younsi.blogspot.com/2007/05/show-tib-under-hood-from-matt-pietrek.html">http://younsi.blogspot.com/2007/05/show-tib-under-hood-from-matt-pietrek.html</A>
+//  
+//      Might be able to port this to Windows or maybe use compiler TLS storage class and it does it for us (__declspec(thread)).
+
+//NOTE: I don't use arch_prctl(ARCH_SET_GS, base) and instead use 32-bit segment selector because
+//if you set a 64-bit segment selector it makes context switches more expensive!
+
+//Generic representation of an x86 segment descriptor (32-bit mode and 64-bit mode w/ 32-bit syscall)
+typedef struct i386_descriptor {
+	unsigned int limit_0_15:16;
+	unsigned int base_0_15:16;
+	unsigned int base_16_23:8;
+	unsigned int accessed:1;
+	unsigned int contents:3;
+	unsigned int is_normal:1;
+	unsigned int protection:2;
+	unsigned int present:1;
+	unsigned int limit_16_19:4;
+	unsigned int avl:1;
+	unsigned int unknown_o:1;
+	unsigned int seg_32bit:1;
+	unsigned int limit_in_pages:1;
+	unsigned int base_24_31:8;
+};
+
+#ifdef linux
+
+#include &lt;asm/ldt.h&gt;
+#include &lt;linux/unistd.h&gt;
+#include &lt;linux/version.h&gt;
+#include &lt;sys/syscall.h&gt;
+#include &lt;sys/types.h&gt;
+
+int modify_ldt(int func, void *ptr, unsigned long bytecount) {
+	return syscall(__NR_modify_ldt, func, ptr, bytecount);
+}
+
+#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 5, 66)
+#define modify_ldt_ldt_s user_desc
+#endif
+
+//Define the modify_ldt function that will call this particular syscall.
+//_syscall3(int, modify_ldt, int, func, void *, ptr, unsigned long, bytecount);
+
+#ifdef __x86_64__
+#include &lt;sys/prctl.h&gt;
+#include &lt;asm/prctl.h&gt;
+extern &quot;C&quot; {
+extern int arch_prctl(int code, unsigned long addr);
+};
+#endif
+
+#else
+
+#include &lt;architecture/i386/table.h&gt;
+#include &lt;i386/user_ldt.h&gt;
+
+//We still use this structure.
+typedef struct modify_ldt_ldt_s {
+	unsigned int  entry_number;
+	unsigned long base_addr;
+	unsigned int  limit;
+	unsigned int  seg_32bit:1;
+	unsigned int  contents:2;
+	unsigned int  read_exec_only:1;
+	unsigned int  limit_in_pages:1;
+	unsigned int  seg_not_present:1;
+	unsigned int  useable:1;
+} modify_ldt_t;
+
+#define MODIFY_LDT_CONTENTS_DATA	0
+#define MODIFY_LDT_CONTENTS_STACK	1
+#define MODIFY_LDT_CONTENTS_CODE	2
+
+#define LDT_ENTRIES			8192
+#define LDT_ENTRY_SIZE			8
+
+//Fake the Linux syscall by implementing use BSD-syscall
+int modify_ldt(int func, void *ptr, unsigned long bytecount)
+{
+	if (0 == func){
+		//reading LDT
+		int ret = i386_get_ldt(0, (union ldt_entry*)ptr, bytecount / LDT_ENTRY_SIZE);
+		if (ret &lt; 0){ return -1; }
+		int realRet = (bytecount/LDT_ENTRY_SIZE)*LDT_ENTRY_SIZE;
+		if (ret*LDT_ENTRY_SIZE &lt; realRet){ realRet = ret*LDT_ENTRY_SIZE; }
+		return realRet;
+	} else {
+		//writing one LDT
+		//have to form actual binary representation of LDT
+		modify_ldt_ldt_s* pLDT = (modify_ldt_ldt_s*)ptr;
+		union ldt_entry newLDT;
+		memset(&amp;newLDT, 0, sizeof(newLDT));
+
+		int ret=0;
+		if (pLDT-&gt;seg_not_present){
+			//Must use this other syntax to free the LDT entry.
+			ret = i386_set_ldt(pLDT-&gt;entry_number, NULL, 1);
+		} else {
+			newLDT.data.limit00 = pLDT-&gt;limit &amp; 0xFFFF;
+			newLDT.data.base00  = pLDT-&gt;base_addr &amp; 0xFFFF;
+			newLDT.data.base16  = (pLDT-&gt;base_addr &amp; 0xFF0000) &gt;&gt; 16;
+			newLDT.data.type    = (pLDT-&gt;read_exec_only ?  DESC_DATA_RONLY : DESC_DATA_WRITE);
+			newLDT.data.dpl     = 0x3;
+			newLDT.data.present = (pLDT-&gt;seg_not_present ? 0 : 1);
+			newLDT.data.limit16 = (pLDT-&gt;limit &amp; 0x0F0000) &gt;&gt; 16;
+			newLDT.data.stksz   = (pLDT-&gt;seg_32bit ? DESC_DATA_32B : DESC_DATA_16B);
+			newLDT.data.granular= (pLDT-&gt;limit_in_pages ? 1 : 0);
+			newLDT.data.base24  = (pLDT-&gt;base_addr &amp; 0xFF000000) &gt;&gt; 24;
+			//now do syscall
+			ret = i386_set_ldt(pLDT-&gt;entry_number, &amp;newLDT, 1);
+		}
+		if (ret &lt; 0){ return -1; }
+		if (pLDT-&gt;entry_number == LDT_AUTO_ALLOC){
+			pLDT-&gt;entry_number = ret;
+		}
+		//printf(&quot;ALLOCATED LDT NUMBER %d\n&quot;, pLDT-&gt;entry_number);
+		return 0;
+	}
+}
+
+#endif //linux
+
+#ifndef MAP_ANON
+#define MAP_ANON MAP_ANONYMOUS
+#endif //MAP_ANON
+
+//-------------------------------------------------------------------------------
+
+//Worker function to search for the next available ldt
+int speedy_tls_get_next_avail_ldt(){
+#ifdef linux
+	char temp[LDT_ENTRIES*LDT_ENTRY_SIZE];
+	int ret = modify_ldt(0, temp, sizeof(temp));
+	if (ret &lt; 0){
+		perror(&quot;failed to read ldt to find next free spot&quot;);
+		exit(-1);
+	}
+	int num=1;
+	struct i386_descriptor* entries = (i386_descriptor*)temp;
+	for (; entries[num].present; num++){}
+	return num;
+#else
+	//Let the kernel choose the next free spot (may be more efficient)
+	return LDT_AUTO_ALLOC;
+#endif
+}
+
+//Determine how many LDT entries are still free.
+int speedy_tls_get_number_ldt_entries(){  
+	char temp[LDT_ENTRIES*LDT_ENTRY_SIZE];
+	int ret = modify_ldt(0, temp, sizeof(temp));
+	if (ret &lt; 0){
+		perror(&quot;failed to read ldt to get # of entries&quot;);
+		exit(-1);
+	}
+	int maxToScan=ret / LDT_ENTRY_SIZE;
+	int num=0;
+	struct i386_descriptor* entries = (i386_descriptor*)temp;
+	for (int i=0; i&lt;maxToScan; i++){
+		if (entries[i].present){ num++; }
+	}
+	return num;
+}
+
+void speedy_tls_onthread_ending(void* arg);
+//Used to install a global hook when a pthread ends.
+class speedy_tls_threadhook {
+public:
+	pthread_key_t m_ldt;
+	pthread_key_t m_tlsbase;
+	pthread_key_t m_tlslength;
+	pthread_mutex_t m_lock;
+
+	//We need to make sure we free the thread's LDT when the thread is done.
+	static void onthread_ending(void* arg){
+		speedy_tls_onthread_ending(arg);
+	}
+
+	speedy_tls_threadhook(){
+		if (pthread_mutex_init(&amp;m_lock, NULL) &lt; 0){
+			perror(&quot;speedy_tls failed to create global thread speedy_tls mutex&quot;);
+			exit(-1);
+		}
+		if (pthread_key_create(&amp;m_ldt, onthread_ending) &lt; 0){
+			perror(&quot;speedy_tls failed to create global thread termination hook&quot;);
+			exit(-1);
+		}
+		if (pthread_key_create(&amp;m_tlsbase, NULL) &lt; 0){
+			perror(&quot;speedy_tls failed to create TLS slot for private-TLS base address&quot;);
+			exit(-1);
+		}
+		if (pthread_key_create(&amp;m_tlslength, NULL) &lt; 0){
+			perror(&quot;speedy_tls failed to create TLS slot for private-TLS base address&quot;);
+			exit(-1);
+		}
+	}
+};
+static speedy_tls_threadhook __speedy_tls_threadhook;
+
+void speedy_tls_onthread_ending(void* arg){
+	int ldt = speedy_tls_ptr_to_int32(arg);
+	struct modify_ldt_ldt_s freeLDT;
+	memset(&amp;freeLDT, 0, sizeof(freeLDT));
+
+	//Make sure we get base pointer to unmap memory as well.
+	void* tlsBase = pthread_getspecific(__speedy_tls_threadhook.m_tlsbase);
+	size_t tlsLength = (size_t)pthread_getspecific(__speedy_tls_threadhook.m_tlslength);
+
+#ifdef __x86_64__
+#ifdef __linux__
+	if (ldt == -1){
+		//We are using a 64-bit base, so reset it.
+		arch_prctl(ARCH_SET_GS, (unsigned long)0);
+	} else {
+#endif
+#endif
+	//Make sure that we clear the segment register before freeing the LDT entry!
+	__asm__ __volatile__
+	(
+		&quot;movl %0,%%eax\n\t&quot;
+		&quot;movw %%ax, &quot; __speedy_tls_reg__ &quot;\n\t&quot;
+		  : : &quot;r&quot;(0) : &quot;%eax&quot;
+	);
+#ifdef __x86_64__
+#ifdef __linux__
+	}
+#endif
+#endif
+
+	if (ldt != -1){
+		freeLDT.entry_number=ldt;
+		freeLDT.base_addr = 0;
+		freeLDT.limit = 0;
+		freeLDT.seg_32bit = 1;
+		freeLDT.contents = MODIFY_LDT_CONTENTS_DATA;
+		freeLDT.read_exec_only=0;
+		freeLDT.limit_in_pages=0;
+		freeLDT.seg_not_present=1;
+		freeLDT.useable = 0;
+		int ret = modify_ldt(1, &amp;freeLDT, sizeof(freeLDT));
+		if (ret &lt; 0){
+			perror(&quot;WARNING: speedy_tls_cleanup_ldt failed to free ldt&quot;);
+		}
+	}
+
+	//Finally, free the memory we used for the private TLS area.
+	if (NULL != tlsBase){
+		munmap(tlsBase, tlsLength);
+	}
+}
+
+//-------------------------------------------------------------------------------
+
+//Allocates specified amount of memory (rounded up to nearest page).
+//Results are undefined if you call this more than once on a thread.
+//Returns system error or 0 on success.
+int speedy_tls_init(int numBytes)
+{
+	//Round up to nearest page size if neccessary.
+	int pageSize = getpagesize();
+	int realNumBytes = (numBytes + (pageSize-1)) &amp; (~(pageSize-1)); 
+
+#ifdef __x86_64__
+  #ifdef __linux__
+	void* mmapBase=NULL;
+	int otherFlags = MAP_32BIT;
+  #else
+	//Have to try to allocate from lower 32-bits or TLS won't work.
+	void* mmapBase=(void*)0x100000;
+	int otherFlags = 0;
+  #endif
+#else
+	void* mmapBase=NULL;
+	int otherFlags = 0;
+#endif
+	void* tls=mmap(mmapBase, numBytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | otherFlags, -1, 0);
+#ifdef __x86_64__
+	//Retry malloc obtaining non-32bit address if we have to go that route (results in slower context switches)
+	if(tls==MAP_FAILED){
+		tls=mmap(NULL, numBytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
+	}
+#endif
+	if (tls==MAP_FAILED){
+		int err = errno;
+		perror(&quot;ERROR: fast-tls couldn't allocate memory for private-TLS segment&quot;);
+		printf(&quot;       fast-tls failed to allocate %d bytes with mmap (errno=%d)\n&quot;, numBytes, err);
+		return -1;
+	}
+
+	return speedy_tls_init_foraddr(tls, realNumBytes);
+}
+
+//Initializes the thread-local storage area to the memory region indicated. Size must be a multiple of the page size.
+//Results are undefined if you call this more than once on a thread.
+//Returns system error or 0 on success.
+int speedy_tls_init_foraddr(void* addr, int numBytes)
+{
+	unsigned char* base = (unsigned char*)addr;
+	struct modify_ldt_ldt_s newLDT;
+	memset(&amp;newLDT, 0, sizeof(newLDT));
+
+#ifdef __x86_64__
+	//if base address is not 32-bit, then have to use arch_prctl instead.
+	if (addr &gt; (void*)0xFFFFFFFF){
+  #ifdef __linux__
+		int ret = arch_prctl(ARCH_SET_GS, (unsigned long)addr);
+		if (0 != ret){
+			perror(&quot;speedy_tls_init_foraddr: failed to set 64-bit base address in GS register!&quot;);
+			return -1;
+		}
+		pthread_setspecific(__speedy_tls_threadhook.m_ldt, speedy_tls_int32_to_ptr(-1));
+		pthread_setspecific(__speedy_tls_threadhook.m_tlsbase, addr);
+		pthread_setspecific(__speedy_tls_threadhook.m_tlslength, speedy_tls_int32_to_ptr(numBytes));
+		return 0;
+  #else
+		printf(&quot;speedy_tls_init_foraddr: base address is 64-bit. Non-Linux OSes do not support this. Out of 32-bit TLS memory. Must fail!!!\n&quot;);
+		errno = EFAULT;
+		return -1;
+  #endif
+	}
+#endif
+
+	pthread_mutex_lock(&amp;__speedy_tls_threadhook.m_lock);
+
+	int newEntryNumber = speedy_tls_get_next_avail_ldt();
+	newLDT.entry_number=newEntryNumber;
+	newLDT.base_addr = (speedy_tls_ptr_to_int32(base) + (getpagesize()-1)) &amp; (~(getpagesize()-1));
+	newLDT.limit = numBytes / getpagesize();
+	newLDT.seg_32bit = 1;
+	newLDT.contents = MODIFY_LDT_CONTENTS_DATA;
+	newLDT.read_exec_only=0;
+	newLDT.limit_in_pages=1;
+	newLDT.seg_not_present=0;
+	newLDT.useable = 1;
+	int ret = modify_ldt(1, &amp;newLDT, sizeof(newLDT));
+	pthread_mutex_unlock(&amp;__speedy_tls_threadhook.m_lock);
+	if (ret &lt; 0){
+		perror(&quot;speedy_tls_init_foraddr failed to set ldt&quot;);
+		return -1;
+	}
+
+	__asm__ __volatile__
+	(
+		&quot;movl %0,%%eax\n\t&quot;
+		&quot;movw %%ax, &quot; __speedy_tls_reg__ &quot;\n\t&quot;
+		  : : &quot;r&quot;((newLDT.entry_number&lt;&lt;3) | (1 &lt;&lt; 2) | 0x3) : &quot;%eax&quot;
+	);
+
+	//Make sure that we will deallocate this LDT when the thread ends
+	pthread_setspecific(__speedy_tls_threadhook.m_ldt, speedy_tls_int32_to_ptr(newLDT.entry_number));
+	//Remember the base address for our private TLS for this thread.
+	pthread_setspecific(__speedy_tls_threadhook.m_tlsbase, speedy_tls_int32_to_ptr(newLDT.base_addr));
+	pthread_setspecific(__speedy_tls_threadhook.m_tlslength, speedy_tls_int32_to_ptr(numBytes));
+
+	return 0;
+}
+
+//Returns the base address of the thread-local storage area or NULL if not initialized.
+void* speedy_tls_get_base()
+{
+	void* baseAddr=NULL;
+	baseAddr = pthread_getspecific(__speedy_tls_threadhook.m_tlsbase);
+	return baseAddr;
+/**************************************** the old way was to get the selector, but doesn't work if we have a 64-bit base.
+	//Get the current selector.
+	unsigned int curSelector=0;
+	__asm__ __volatile__
+	(
+		&quot;xor %%eax,%%eax\n\t&quot;
+		&quot;movw &quot; __speedy_tls_reg__ &quot;, %%ax\n\t&quot;
+		&quot;movl %%eax, %0\n\t&quot;
+		  : &quot;=r&quot;(curSelector) : : &quot;%eax&quot;
+	);
+	//Make sure it's not into the GDT instead of the LDT.
+	//(if it is, that means we didn't set it, so don't use it)
+	if (!(curSelector &amp; (1&lt;&lt;2))){
+		return NULL;
+	}
+	//Get the index into the LDT.
+	int idx = (curSelector &gt;&gt; 3);
+	if (idx &lt; 0 || idx &gt;= LDT_ENTRIES){ return NULL; }
+	
+	char temp[LDT_ENTRIES*LDT_ENTRY_SIZE];
+	int ret = modify_ldt(0, temp, sizeof(temp));
+	if (ret &lt; 0){
+		perror(&quot;speedy_tls_get_base: failed to read ldt&quot;);
+		return NULL;
+	}
+	struct i386_descriptor* entries = (i386_descriptor*)temp;
+	if (!entries[idx].present){ return NULL; }
+	unsigned int realBase = entries[idx].base_0_15 | (entries[idx].base_16_23 &lt;&lt; 16) | (entries[idx].base_24_31 &lt;&lt; 24);
+	return (void*)realBase;	
+*****************************************/
+}
+
+#else //__intel__
+
+#error Implementation is not defined for non-Intel architecture right now.
+
+#endif
+
+#endif
+#endif

Copied: branches/0.77-branch/rts/lib/gml/speedy-tls.h (from rev 6422, trunk/rts/lib/gml/speedy-tls.h)
===================================================================
--- branches/0.77-branch/rts/lib/gml/speedy-tls.h	                        (rev 0)
+++ branches/0.77-branch/rts/lib/gml/speedy-tls.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,151 @@
+//Copyright (C) 2008 Kevin Hoffman. See LICENSE for use and warranty disclaimer.
+//Speedy TLS 1.0. Latest version at <A HREF="http://www.kevinjhoffman.com/">http://www.kevinjhoffman.com/</A>
+//Contains macros that can be used to very quickly (one instruction) access thread-local memory.
+
+#ifndef __SPEEDY_TLS_H__
+#define __SPEEDY_TLS_H__
+
+//Allocates specified amount of memory (rounded up to nearest page).
+//Results are undefined if you call this more than once on a thread.
+//Returns system error or 0 on success.
+int speedy_tls_init(int numBytes);
+
+//Initializes the thread-local storage area to the memory region indicated. Size must be a multiple of the page size.
+//Results are undefined if you call this more than once on a thread.
+//Returns system error or 0 on success.
+int speedy_tls_init_foraddr(void* addr, int numBytes);
+
+//Returns the base address of the thread-local storage area or NULL if not initialized.
+void* speedy_tls_get_base();
+
+#if defined(__i386__)
+
+#define __intel__
+#define __speedy_tls_reg__ &quot;%%fs&quot;
+
+#define speedy_tls_ptr_to_int32(x) ((int)(x))
+#define speedy_tls_int32_to_ptr(x) ((void*)(x))
+
+#elif defined(__x86_64__)
+
+#define __intel__
+#define __speedy_tls_reg__ &quot;%%gs&quot;
+
+#define speedy_tls_ptr_to_int32(x) ((int)(long long int)(x))
+#define speedy_tls_int32_to_ptr(x) ((void*)(long long int)(x))
+
+#else
+#error Fast TLS operations have not yet been implemented for this architecture. Please contribute.
+#endif
+
+//We can have a common assembly implementation for x86 architecture (uses fs on x86 and gs on x64).
+#ifdef __intel__
+
+//Use for information only on Intel only.
+int speedy_tls_get_number_ldt_entries();
+
+//-------------------------------------------------------------------------------------------------------------------------------------
+//MACROS TO GET AND SET TLS VALUES (SAFE FOR SMP)
+//-------------------------------------------------------------------------------------------------------------------------------------
+
+#define speedy_tls_get_int8(base, index, scale, output) \
+	__asm__ __volatile__ ( &quot;movb &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;), %0&quot; : &quot;=r&quot;(output) : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_get_int16(base, index, scale, output) \
+	__asm__ __volatile__ ( &quot;movw &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;), %0&quot; : &quot;=r&quot;(output) : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_get_int32(base, index, scale, output) \
+	__asm__ __volatile__ ( &quot;movl &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;), %0&quot; : &quot;=r&quot;(output) : &quot;r&quot;(base), &quot;r&quot;(index) );
+
+#define speedy_tls_put_int8(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;movb %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_put_int16(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;movw %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_put_int32(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;movl %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+
+//-------------------------------------------------------------------------------------------------------------------------------------
+//MACROS THAT USE TLS VALUES (NOT SAFE FOR SMP)
+//-------------------------------------------------------------------------------------------------------------------------------------
+
+#define speedy_tls_add_int8(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;addb %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_add_int16(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;addw %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_add_int32(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;addl %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+
+#define speedy_tls_inc_int8(base, index, scale) \
+	__asm__ __volatile__ ( &quot;incb &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_inc_int16(base, index, scale) \
+	__asm__ __volatile__ ( &quot;incw &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_inc_int32(base, index, scale) \
+	__asm__ __volatile__ ( &quot;incl &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+
+#define speedy_tls_dec_int8(base, index, scale) \
+	__asm__ __volatile__ ( &quot;decb &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_dec_int16(base, index, scale) \
+	__asm__ __volatile__ ( &quot;decw &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_dec_int32(base, index, scale) \
+	__asm__ __volatile__ ( &quot;decl &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+
+//-------------------------------------------------------------------------------------------------------------------------------------
+//MACROS THAT USE TLS VALUES (SAFE FOR SMP)
+//-------------------------------------------------------------------------------------------------------------------------------------
+
+#define speedy_tls_atomic_add_int8(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;lock; addb %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_atomic_add_int16(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;lock; addw %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_atomic_add_int32(base, index, scale, input) \
+	__asm__ __volatile__ ( &quot;lock; addl %0, &quot; __speedy_tls_reg__ &quot;:(%1,%2,&quot; #scale &quot;)&quot; : : &quot;r&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+
+#define speedy_tls_atomic_inc_int8(base, index, scale) \
+	__asm__ __volatile__ ( &quot;lock; incb &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_atomic_inc_int16(base, index, scale) \
+	__asm__ __volatile__ ( &quot;lock; incw &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_atomic_inc_int32(base, index, scale) \
+	__asm__ __volatile__ ( &quot;lock; incl &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+
+#define speedy_tls_atomic_dec_int8(base, index, scale) \
+	__asm__ __volatile__ ( &quot;lock; decb &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_atomic_dec_int16(base, index, scale) \
+	__asm__ __volatile__ ( &quot;lock; decw &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_atomic_dec_int32(base, index, scale) \
+	__asm__ __volatile__ ( &quot;lock; decl &quot; __speedy_tls_reg__ &quot;:(%0,%1,&quot; #scale &quot;)&quot; : : &quot;r&quot;(base), &quot;r&quot;(index) );
+
+//Gets value of TLS integer and saves in original_value, and then adds input to the TLS integer.
+#define speedy_tls_atomic_get_and_add_int8(base, index, scale, input, original_value) \
+	__asm__ __volatile__ ( &quot;lock; xaddb %0, &quot; __speedy_tls_reg__ &quot;:(%2,%3,&quot; #scale &quot;)&quot; : &quot;=r&quot;(original_value) : &quot;0&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_atomic_get_and_add_int16(base, index, scale, input, original_value) \
+	__asm__ __volatile__ ( &quot;lock; xaddw %0, &quot; __speedy_tls_reg__ &quot;:(%2,%3,&quot; #scale &quot;)&quot; : &quot;=r&quot;(original_value) : &quot;0&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+#define speedy_tls_atomic_get_and_add_int32(base, index, scale, input, original_value) \
+	__asm__ __volatile__ ( &quot;lock; xaddl %0, &quot; __speedy_tls_reg__ &quot;:(%2,%3,&quot; #scale &quot;)&quot; : &quot;=r&quot;(original_value) : &quot;0&quot;(input), &quot;r&quot;(base), &quot;r&quot;(index) );
+
+//-------------------------------------------------------------------------------------------------------------------------------------
+//MACROS THAT USE LOCAL VARIABLES INSTEAD OF TLS (NOT SMP SAFE)
+//-------------------------------------------------------------------------------------------------------------------------------------
+
+//Saves value of var in original_value and then adds num to var and saves in var.
+#define speedy_local_get_and_add_int8(var, num, original_value) \
+        __asm__ __volatile__ ( &quot;xaddb %0,%1&quot; : &quot;=r&quot; (original_value), &quot;+m&quot; (var) : &quot;0&quot; (num) : &quot;memory&quot; );
+#define speedy_local_get_and_add_int16(var, num, original_value) \
+        __asm__ __volatile__ ( &quot;xaddw %0,%1&quot; : &quot;=r&quot; (original_value), &quot;+m&quot; (var) : &quot;0&quot; (num) : &quot;memory&quot; );
+#define speedy_local_get_and_add_int32(var, num, original_value) \
+        __asm__ __volatile__ ( &quot;xaddl %0,%1&quot; : &quot;=r&quot; (original_value), &quot;+m&quot; (var) : &quot;0&quot; (num) : &quot;memory&quot; );
+
+//-------------------------------------------------------------------------------------------------------------------------------------
+//MACROS THAT USE LOCAL VARIABLES INSTEAD OF TLS (SMP SAFE)
+//-------------------------------------------------------------------------------------------------------------------------------------
+
+//Saves value of var in original_value and then adds num to var and saves in var.
+#define speedy_local_atomic_get_and_add_int8(var, num, original_value) \
+        __asm__ __volatile__ ( &quot;lock; xaddb %0,%1&quot; : &quot;=r&quot; (original_value), &quot;+m&quot; (var) : &quot;0&quot; (num) : &quot;memory&quot; );
+#define speedy_local_atomic_get_and_add_int16(var, num, original_value) \
+        __asm__ __volatile__ ( &quot;lock; xaddw %0,%1&quot; : &quot;=r&quot; (original_value), &quot;+m&quot; (var) : &quot;0&quot; (num) : &quot;memory&quot; );
+#define speedy_local_atomic_get_and_add_int32(var, num, original_value) \
+        __asm__ __volatile__ ( &quot;lock; xaddl %0,%1&quot; : &quot;=r&quot; (original_value), &quot;+m&quot; (var) : &quot;0&quot; (num) : &quot;memory&quot; );
+
+
+#endif //__intel__
+
+#endif //__SPEEDY_TLS_H__
+

Copied: branches/0.77-branch/tools/SpringInstaller (from rev 6422, trunk/tools/SpringInstaller)

Deleted: branches/0.77-branch/tools/SpringInstaller/Makefile
===================================================================
--- trunk/tools/SpringInstaller/Makefile	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/Makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,21 +0,0 @@
-ML_SOURCES = fileSystem.ml sdz.ml sd7.ml archive.ml datadir.ml spring_installer.ml
-ML_SEARCH = -I +lablgtk2  -I +zip -I +extlib -I libmlsevenzip
-ML_LIBS = unix.cmxa sevenzip.cmxa zip.cmxa extLib.cmxa lablgtk.cmxa gtkInit.cmx
-
-all: spring-installer
-
-spring-installer: libmlsevenzip $(ML_SOURCES)
-	ocamlopt -o spring-installer $(ML_SEARCH) $(ML_LIBS) $(ML_SOURCES)
-
-libmlsevenzip:
-	$(MAKE) -C libmlsevenzip
-
-clean:
-	$(MAKE) -C libmlsevenzip clean
-	rm -f *.cmi  *.cmo  *.cmx  *.o spring-installer
-
-install:
-	install -m 755 spring-installer $(DESTDIR)/usr/bin/spring-installer
-	install -m 644 debian/spring-installer.desktop $(DESTDIR)/usr/share/applications/spring-installer.desktop
-
-.PHONY: all clean libmlsevenzip

Copied: branches/0.77-branch/tools/SpringInstaller/Makefile (from rev 6422, trunk/tools/SpringInstaller/Makefile)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/Makefile	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/Makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,21 @@
+ML_SOURCES = fileSystem.ml sdz.ml sd7.ml archive.ml datadir.ml spring_installer.ml
+ML_SEARCH = -I +lablgtk2  -I +zip -I +extlib -I libmlsevenzip
+ML_LIBS = unix.cmxa sevenzip.cmxa zip.cmxa extLib.cmxa lablgtk.cmxa gtkInit.cmx
+
+all: spring-installer
+
+spring-installer: libmlsevenzip $(ML_SOURCES)
+	ocamlopt -o spring-installer $(ML_SEARCH) $(ML_LIBS) $(ML_SOURCES)
+
+libmlsevenzip:
+	$(MAKE) -C libmlsevenzip
+
+clean:
+	$(MAKE) -C libmlsevenzip clean
+	rm -f *.cmi  *.cmo  *.cmx  *.o spring-installer
+
+install:
+	install -m 755 spring-installer $(DESTDIR)/usr/bin/spring-installer
+	install -m 644 debian/spring-installer.desktop $(DESTDIR)/usr/share/applications/spring-installer.desktop
+
+.PHONY: all clean libmlsevenzip

Deleted: branches/0.77-branch/tools/SpringInstaller/archive.ml
===================================================================
--- trunk/tools/SpringInstaller/archive.ml	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/archive.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,45 +0,0 @@
-open ExtString
-exception Error of string
-  
-type kind = Mod | Map | Unknown
-    
-let load path =
-  try
-    if String.ends_with path &quot;.sdz&quot; then
-      Sdz.In.load path
-    else if String.ends_with path &quot;.sd7&quot; then
-      Sd7.In.load path
-    else
-      raise (Error (Printf.sprintf &quot;Unknown archive type: %s&quot; path))
-  with
-      Zip.Error (path, _, s) -&gt; raise (Error (Printf.sprintf &quot;%s: %s&quot; path s))
-    | Sevenzip.Error s -&gt; raise (Error (Printf.sprintf &quot;%s: %s&quot; path s))
-    | Sys_error s -&gt; raise (Error s)      
-      
-let detect_kind path =
-  let archive = load path in
-  let entries = archive#entries in
-
-  let test_files func =
-    let f entry = func (String.lowercase entry#name) in
-      List.exists f entries in
-
-  let is_map path =
-    let dirname = Filename.dirname path in
-    let basename = Filename.basename path in
-      if dirname = &quot;maps&quot; then
-        if String.ends_with basename &quot;.smf&quot; then
-          true
-        else if String.ends_with basename &quot;.sm3&quot; then
-          true
-        else
-          false
-      else
-        false in
-    
-    archive#unload;
-    if test_files is_map then Map
-    else if test_files (fun filename -&gt; filename = &quot;modinfo.tdf&quot;) then Mod
-    else if test_files (fun filename -&gt; filename = &quot;modinfo.lua&quot;) then Mod
-    else Unknown
-

Copied: branches/0.77-branch/tools/SpringInstaller/archive.ml (from rev 6422, trunk/tools/SpringInstaller/archive.ml)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/archive.ml	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/archive.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,45 @@
+open ExtString
+exception Error of string
+  
+type kind = Mod | Map | Unknown
+    
+let load path =
+  try
+    if String.ends_with path &quot;.sdz&quot; then
+      Sdz.In.load path
+    else if String.ends_with path &quot;.sd7&quot; then
+      Sd7.In.load path
+    else
+      raise (Error (Printf.sprintf &quot;Unknown archive type: %s&quot; path))
+  with
+      Zip.Error (path, _, s) -&gt; raise (Error (Printf.sprintf &quot;%s: %s&quot; path s))
+    | Sevenzip.Error s -&gt; raise (Error (Printf.sprintf &quot;%s: %s&quot; path s))
+    | Sys_error s -&gt; raise (Error s)      
+      
+let detect_kind path =
+  let archive = load path in
+  let entries = archive#entries in
+
+  let test_files func =
+    let f entry = func (String.lowercase entry#name) in
+      List.exists f entries in
+
+  let is_map path =
+    let dirname = Filename.dirname path in
+    let basename = Filename.basename path in
+      if dirname = &quot;maps&quot; then
+        if String.ends_with basename &quot;.smf&quot; then
+          true
+        else if String.ends_with basename &quot;.sm3&quot; then
+          true
+        else
+          false
+      else
+        false in
+    
+    archive#unload;
+    if test_files is_map then Map
+    else if test_files (fun filename -&gt; filename = &quot;modinfo.tdf&quot;) then Mod
+    else if test_files (fun filename -&gt; filename = &quot;modinfo.lua&quot;) then Mod
+    else Unknown
+

Deleted: branches/0.77-branch/tools/SpringInstaller/datadir.ml
===================================================================
--- trunk/tools/SpringInstaller/datadir.ml	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/datadir.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,47 +0,0 @@
-open ExtString
-let detect_home_dir () =
-  try
-    let home_dir = Sys.getenv &quot;HOME&quot; in
-      Some home_dir
-  with Not_found -&gt; None
-    
-let detect_springrc home_dir =
-  try
-    let springrc = Filename.concat home_dir &quot;.springrc&quot; in
-    let in_file = open_in springrc in
-    let rec loop option =
-      try 
-        let line = input_line in_file in
-          try
-            let (key, value) = String.split line &quot;=&quot; in
-              if key = &quot;SpringData&quot; then
-                loop (Some value)
-              else
-                loop option
-          with Invalid_string -&gt; loop option
-      with End_of_file -&gt; option in
-    let option = loop None in
-      close_in in_file;
-      option
-  with Sys_error _ -&gt; None
-    
-let detect_etc home_dir =
-  try
-    let in_file = open_in &quot;/etc/spring/datadir&quot; in
-    let input = IO.input_channel in_file in
-    let format = IO.read_line input in
-    let (_, dir) = String.replace format &quot;$HOME&quot; home_dir in
-      close_in in_file;
-      Some dir
-  with Sys_error _ -&gt; None
-    
-let detect () =
-  match detect_home_dir () with
-      Some home_dir -&gt;
-        (match detect_springrc home_dir with
-             Some spring_dir -&gt; spring_dir
-           | None -&gt;
-               (match detect_etc home_dir with
-                    Some etc_dir -&gt; etc_dir
-                  | None -&gt; Filename.concat home_dir &quot;.spring&quot;))
-    | None -&gt; &quot;&quot;

Copied: branches/0.77-branch/tools/SpringInstaller/datadir.ml (from rev 6422, trunk/tools/SpringInstaller/datadir.ml)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/datadir.ml	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/datadir.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,47 @@
+open ExtString
+let detect_home_dir () =
+  try
+    let home_dir = Sys.getenv &quot;HOME&quot; in
+      Some home_dir
+  with Not_found -&gt; None
+    
+let detect_springrc home_dir =
+  try
+    let springrc = Filename.concat home_dir &quot;.springrc&quot; in
+    let in_file = open_in springrc in
+    let rec loop option =
+      try 
+        let line = input_line in_file in
+          try
+            let (key, value) = String.split line &quot;=&quot; in
+              if key = &quot;SpringData&quot; then
+                loop (Some value)
+              else
+                loop option
+          with Invalid_string -&gt; loop option
+      with End_of_file -&gt; option in
+    let option = loop None in
+      close_in in_file;
+      option
+  with Sys_error _ -&gt; None
+    
+let detect_etc home_dir =
+  try
+    let in_file = open_in &quot;/etc/spring/datadir&quot; in
+    let input = IO.input_channel in_file in
+    let format = IO.read_line input in
+    let (_, dir) = String.replace format &quot;$HOME&quot; home_dir in
+      close_in in_file;
+      Some dir
+  with Sys_error _ -&gt; None
+    
+let detect () =
+  match detect_home_dir () with
+      Some home_dir -&gt;
+        (match detect_springrc home_dir with
+             Some spring_dir -&gt; spring_dir
+           | None -&gt;
+               (match detect_etc home_dir with
+                    Some etc_dir -&gt; etc_dir
+                  | None -&gt; Filename.concat home_dir &quot;.spring&quot;))
+    | None -&gt; &quot;&quot;

Copied: branches/0.77-branch/tools/SpringInstaller/debian (from rev 6422, trunk/tools/SpringInstaller/debian)

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/changelog
===================================================================
--- trunk/tools/SpringInstaller/debian/changelog	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/changelog	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,5 +0,0 @@
-spring-installer (20080908-1) hardy; urgency=low
-
-  * Initial release
-
- -- Chris Clearwater &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">chris at detrino.org</A>&gt;  Mon, 08 Sep 2008 02:59:24 -0700

Copied: branches/0.77-branch/tools/SpringInstaller/debian/changelog (from rev 6422, trunk/tools/SpringInstaller/debian/changelog)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/changelog	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/changelog	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,5 @@
+spring-installer (20080908-1) hardy; urgency=low
+
+  * Initial release
+
+ -- Chris Clearwater &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">chris at detrino.org</A>&gt;  Mon, 08 Sep 2008 02:59:24 -0700

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/compat
===================================================================
--- trunk/tools/SpringInstaller/debian/compat	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/compat	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1 +0,0 @@
-5

Copied: branches/0.77-branch/tools/SpringInstaller/debian/compat (from rev 6422, trunk/tools/SpringInstaller/debian/compat)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/compat	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/compat	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1 @@
+5

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/control
===================================================================
--- trunk/tools/SpringInstaller/debian/control	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/control	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,12 +0,0 @@
-Source: spring-installer
-Section: games
-Priority: optional
-Maintainer: Chris Clearwater &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">chris at detrino.org</A>&gt;
-Build-Depends: debhelper, ocaml, libzip-ocaml-dev, libextlib-ocaml-dev, liblablgtk2-ocaml-dev
-Standards-Version: 3.7.2
-
-Package: spring-installer
-Architecture: any
-Depends: ${shlibs:Depends}
-Description: Spring Archive Installer
- Spring Installer is a GTK program that will install your Spring mods and maps for you.

Copied: branches/0.77-branch/tools/SpringInstaller/debian/control (from rev 6422, trunk/tools/SpringInstaller/debian/control)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/control	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/control	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,12 @@
+Source: spring-installer
+Section: games
+Priority: optional
+Maintainer: Chris Clearwater &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">chris at detrino.org</A>&gt;
+Build-Depends: debhelper, ocaml, libzip-ocaml-dev, libextlib-ocaml-dev, liblablgtk2-ocaml-dev
+Standards-Version: 3.7.2
+
+Package: spring-installer
+Architecture: any
+Depends: ${shlibs:Depends}
+Description: Spring Archive Installer
+ Spring Installer is a GTK program that will install your Spring mods and maps for you.

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/copyright
===================================================================
--- trunk/tools/SpringInstaller/debian/copyright	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/copyright	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,29 +0,0 @@
-Upstream Author(s): 
-
-    Chris Clearwater &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">chris at detrino.org</A>&gt;
-
-Copyright: 
-
-    &lt;Copyright (C) 2008 Chris Clearwater&gt;
-
-License:
-
-    This package is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
- 
-    This package is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
- 
-    You should have received a copy of the GNU General Public License
-    along with this package; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-
-On Debian systems, the complete text of the GNU General
-Public License can be found in `/usr/share/common-licenses/GPL'.
-
-The Debian packaging is (C) 2008, Chris Clearwater &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">chris at detrino.org</A>&gt; and
-is licensed under the GPL, see above.

Copied: branches/0.77-branch/tools/SpringInstaller/debian/copyright (from rev 6422, trunk/tools/SpringInstaller/debian/copyright)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/copyright	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/copyright	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,29 @@
+Upstream Author(s): 
+
+    Chris Clearwater &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">chris at detrino.org</A>&gt;
+
+Copyright: 
+
+    &lt;Copyright (C) 2008 Chris Clearwater&gt;
+
+License:
+
+    This package is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+ 
+    This package is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with this package; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+
+On Debian systems, the complete text of the GNU General
+Public License can be found in `/usr/share/common-licenses/GPL'.
+
+The Debian packaging is (C) 2008, Chris Clearwater &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">chris at detrino.org</A>&gt; and
+is licensed under the GPL, see above.

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/dirs
===================================================================
--- trunk/tools/SpringInstaller/debian/dirs	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/dirs	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,2 +0,0 @@
-usr/bin
-usr/share/applications

Copied: branches/0.77-branch/tools/SpringInstaller/debian/dirs (from rev 6422, trunk/tools/SpringInstaller/debian/dirs)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/dirs	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/dirs	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,2 @@
+usr/bin
+usr/share/applications

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/rules
===================================================================
--- trunk/tools/SpringInstaller/debian/rules	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/rules	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,91 +0,0 @@
-#!/usr/bin/make -f
-# -*- makefile -*-
-# Sample debian/rules that uses debhelper.
-# This file was originally written by Joey Hess and Craig Small.
-# As a special exception, when this file is copied by dh-make into a
-# dh-make output file, you may use that output file without restriction.
-# This special exception was added by Craig Small in version 0.37 of dh-make.
-
-# Uncomment this to turn on verbose mode.
-#export DH_VERBOSE=1
-
-
-
-
-configure: configure-stamp
-configure-stamp:
-	dh_testdir
-	# Add here commands to configure the package.
-
-	touch configure-stamp
-
-
-build: build-stamp
-
-build-stamp: configure-stamp 
-	dh_testdir
-
-	# Add here commands to compile the package.
-	$(MAKE)
-	#docbook-to-man debian/spring-installer.sgml &gt; spring-installer.1
-
-	touch $@
-
-clean:
-	dh_testdir
-	dh_testroot
-	rm -f build-stamp configure-stamp
-
-	# Add here commands to clean up after the build process.
-	-$(MAKE) clean
-
-	dh_clean 
-
-install: build
-	dh_testdir
-	dh_testroot
-	dh_clean -k 
-	dh_installdirs
-
-	# Add here commands to install the package into debian/spring-installer.
-	$(MAKE) DESTDIR=$(CURDIR)/debian/spring-installer install
-
-
-# Build architecture-independent files here.
-binary-indep: build install
-# We have nothing to do by default.
-
-# Build architecture-dependent files here.
-binary-arch: build install
-	dh_testdir
-	dh_testroot
-	dh_installchangelogs 
-	dh_installdocs
-	dh_installexamples
-#	dh_install
-#	dh_installmenu
-#	dh_installdebconf	
-#	dh_installlogrotate
-#	dh_installemacsen
-#	dh_installpam
-	dh_installmime
-	dh_desktop
-#	dh_python
-#	dh_installinit
-#	dh_installcron
-#	dh_installinfo
-#	dh_installman
-	dh_link
-	dh_strip
-	dh_compress
-	dh_fixperms
-#	dh_perl
-#	dh_makeshlibs
-	dh_installdeb
-	dh_shlibdeps
-	dh_gencontrol
-	dh_md5sums
-	dh_builddeb
-
-binary: binary-indep binary-arch
-.PHONY: build clean binary-indep binary-arch binary install configure

Copied: branches/0.77-branch/tools/SpringInstaller/debian/rules (from rev 6422, trunk/tools/SpringInstaller/debian/rules)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/rules	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/rules	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,91 @@
+#!/usr/bin/make -f
+# -*- makefile -*-
+# Sample debian/rules that uses debhelper.
+# This file was originally written by Joey Hess and Craig Small.
+# As a special exception, when this file is copied by dh-make into a
+# dh-make output file, you may use that output file without restriction.
+# This special exception was added by Craig Small in version 0.37 of dh-make.
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+
+
+
+
+configure: configure-stamp
+configure-stamp:
+	dh_testdir
+	# Add here commands to configure the package.
+
+	touch configure-stamp
+
+
+build: build-stamp
+
+build-stamp: configure-stamp 
+	dh_testdir
+
+	# Add here commands to compile the package.
+	$(MAKE)
+	#docbook-to-man debian/spring-installer.sgml &gt; spring-installer.1
+
+	touch $@
+
+clean:
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp configure-stamp
+
+	# Add here commands to clean up after the build process.
+	-$(MAKE) clean
+
+	dh_clean 
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_clean -k 
+	dh_installdirs
+
+	# Add here commands to install the package into debian/spring-installer.
+	$(MAKE) DESTDIR=$(CURDIR)/debian/spring-installer install
+
+
+# Build architecture-independent files here.
+binary-indep: build install
+# We have nothing to do by default.
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+	dh_installchangelogs 
+	dh_installdocs
+	dh_installexamples
+#	dh_install
+#	dh_installmenu
+#	dh_installdebconf	
+#	dh_installlogrotate
+#	dh_installemacsen
+#	dh_installpam
+	dh_installmime
+	dh_desktop
+#	dh_python
+#	dh_installinit
+#	dh_installcron
+#	dh_installinfo
+#	dh_installman
+	dh_link
+	dh_strip
+	dh_compress
+	dh_fixperms
+#	dh_perl
+#	dh_makeshlibs
+	dh_installdeb
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.desktop
===================================================================
--- trunk/tools/SpringInstaller/debian/spring-installer.desktop	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.desktop	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,8 +0,0 @@
-[Desktop Entry]
-Name=Spring Installer
-Comment=Installs Spring Archives
-Exec=spring-installer %f
-Terminal=false
-Type=Application
-MimeType=application/x-spring-sdz;application/x-spring-sd7;
-NoDisplay=true

Copied: branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.desktop (from rev 6422, trunk/tools/SpringInstaller/debian/spring-installer.desktop)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.desktop	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.desktop	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,8 @@
+[Desktop Entry]
+Name=Spring Installer
+Comment=Installs Spring Archives
+Exec=spring-installer %f
+Terminal=false
+Type=Application
+MimeType=application/x-spring-sdz;application/x-spring-sd7;
+NoDisplay=true

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.mime
===================================================================
--- trunk/tools/SpringInstaller/debian/spring-installer.mime	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.mime	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,2 +0,0 @@
-application/x-spring-sdz; /usr/bin/spring-installer '%s'; description=Spring Archive
-application/x-spring-sd7; /usr/bin/spring-installer '%s'; description=Spring Archive

Copied: branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.mime (from rev 6422, trunk/tools/SpringInstaller/debian/spring-installer.mime)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.mime	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.mime	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,2 @@
+application/x-spring-sdz; /usr/bin/spring-installer '%s'; description=Spring Archive
+application/x-spring-sd7; /usr/bin/spring-installer '%s'; description=Spring Archive

Deleted: branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo
===================================================================
--- trunk/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,16 +0,0 @@
-&lt;?xml version=&quot;1.0&quot;?&gt;
-&lt;mime-info xmlns='<A HREF="http://www.freedesktop.org/standards/shared-mime-info">http://www.freedesktop.org/standards/shared-mime-info</A>'&gt;
-  
-  &lt;mime-type type=&quot;application/x-spring-sdz&quot;&gt;
-    &lt;sub-class-of type=&quot;application/zip&quot;/&gt;
-    &lt;comment&gt;Spring Archive&lt;/comment&gt;
-    &lt;glob pattern=&quot;*.sdz&quot;/&gt;
-  &lt;/mime-type&gt;
-
-  &lt;mime-type type=&quot;application/x-spring-sd7&quot;&gt;
-    &lt;sub-class-of type=&quot;application/x-7z-compressed&quot;/&gt;
-    &lt;comment&gt;Spring Archive&lt;/comment&gt;
-    &lt;glob pattern=&quot;*.sd7&quot;/&gt;
-  &lt;/mime-type&gt;
-
-&lt;/mime-info&gt;

Copied: branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo (from rev 6422, trunk/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/debian/spring-installer.sharedmimeinfo	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,16 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;mime-info xmlns='<A HREF="http://www.freedesktop.org/standards/shared-mime-info">http://www.freedesktop.org/standards/shared-mime-info</A>'&gt;
+  
+  &lt;mime-type type=&quot;application/x-spring-sdz&quot;&gt;
+    &lt;sub-class-of type=&quot;application/zip&quot;/&gt;
+    &lt;comment&gt;Spring Archive&lt;/comment&gt;
+    &lt;glob pattern=&quot;*.sdz&quot;/&gt;
+  &lt;/mime-type&gt;
+
+  &lt;mime-type type=&quot;application/x-spring-sd7&quot;&gt;
+    &lt;sub-class-of type=&quot;application/x-7z-compressed&quot;/&gt;
+    &lt;comment&gt;Spring Archive&lt;/comment&gt;
+    &lt;glob pattern=&quot;*.sd7&quot;/&gt;
+  &lt;/mime-type&gt;
+
+&lt;/mime-info&gt;

Deleted: branches/0.77-branch/tools/SpringInstaller/fileSystem.ml
===================================================================
--- trunk/tools/SpringInstaller/fileSystem.ml	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/fileSystem.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,28 +0,0 @@
-let copy src dst =
-  let string = String.create 4096 in
-  let in_chan = open_in_bin src in
-  let out_chan = open_out_bin dst in
-    
-  let rec f () =
-    let n = input in_chan string 0 (String.length string) in
-      if n = 0 then
-        ()
-      else
-        begin
-          output out_chan string 0 n;
-          f ()
-        end in
-    
-    f ();
-    close_in in_chan;
-    close_out out_chan
-      
-let move src dst =
-  if src != dst then
-    try
-      Sys.rename src dst
-    with Sys_error _ -&gt;
-      copy src dst;
-      Sys.remove src
-  else
-    ()

Copied: branches/0.77-branch/tools/SpringInstaller/fileSystem.ml (from rev 6422, trunk/tools/SpringInstaller/fileSystem.ml)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/fileSystem.ml	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/fileSystem.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,28 @@
+let copy src dst =
+  let string = String.create 4096 in
+  let in_chan = open_in_bin src in
+  let out_chan = open_out_bin dst in
+    
+  let rec f () =
+    let n = input in_chan string 0 (String.length string) in
+      if n = 0 then
+        ()
+      else
+        begin
+          output out_chan string 0 n;
+          f ()
+        end in
+    
+    f ();
+    close_in in_chan;
+    close_out out_chan
+      
+let move src dst =
+  if src != dst then
+    try
+      Sys.rename src dst
+    with Sys_error _ -&gt;
+      copy src dst;
+      Sys.remove src
+  else
+    ()

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/Makefile
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/Makefile	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/Makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,30 +0,0 @@
-LD_FLAGS = -Llibmlsevenzip
-LIBS = -lml_sevenzip
-
-all: libml_sevenzip.a sevenzip.cmxa
-
-sevenzip.cmxa: sevenzip.cmx
-	ocamlopt -cclib &quot;$(LD_FLAGS) $(LIBS)&quot; -a -o sevenzip.cmxa sevenzip.cmx
-
-sevenzip.cmx: sevenzip.ml
-	ocamlopt -o sevenzip.cmx -c sevenzip.ml
-
-libsevenzip:
-	$(MAKE) -C libsevenzip/Archive/7z -f makefile.gcc
-
-libml_sevenzip.a: libsevenzip ml_sevenzip.o
-	ar rc libml_sevenzip.a ml_sevenzip.o libsevenzip/Archive/7z/*.o
-	ranlib libml_sevenzip.a
-
-ml_sevenzip.o: ml_sevenzip.c
-	ocamlopt -o ml_sevenzip.o ml_sevenzip.c
-
-clean:
-	$(MAKE) -C libsevenzip/Archive/7z -f makefile.gcc clean
-	rm -rf *.cmx
-	rm -rf *.cmi
-	rm -rf *.o
-	rm -rf *.a
-	rm -rf *.cmxa
-
-.PHONY: all clean libsevenzip

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/Makefile (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/Makefile)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/Makefile	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/Makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,30 @@
+LD_FLAGS = -Llibmlsevenzip
+LIBS = -lml_sevenzip
+
+all: libml_sevenzip.a sevenzip.cmxa
+
+sevenzip.cmxa: sevenzip.cmx
+	ocamlopt -cclib &quot;$(LD_FLAGS) $(LIBS)&quot; -a -o sevenzip.cmxa sevenzip.cmx
+
+sevenzip.cmx: sevenzip.ml
+	ocamlopt -o sevenzip.cmx -c sevenzip.ml
+
+libsevenzip:
+	$(MAKE) -C libsevenzip/Archive/7z -f makefile.gcc
+
+libml_sevenzip.a: libsevenzip ml_sevenzip.o
+	ar rc libml_sevenzip.a ml_sevenzip.o libsevenzip/Archive/7z/*.o
+	ranlib libml_sevenzip.a
+
+ml_sevenzip.o: ml_sevenzip.c
+	ocamlopt -o ml_sevenzip.o ml_sevenzip.c
+
+clean:
+	$(MAKE) -C libsevenzip/Archive/7z -f makefile.gcc clean
+	rm -rf *.cmx
+	rm -rf *.cmi
+	rm -rf *.o
+	rm -rf *.a
+	rm -rf *.cmxa
+
+.PHONY: all clean libsevenzip

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,36 +0,0 @@
-/* 7zBuf.c -- Byte Buffer
-2008-03-28
-Igor Pavlov
-Public domain */
-
-#include &quot;7zBuf.h&quot;
-
-void Buf_Init(CBuf *p)
-{
-  p-&gt;data = 0;
-  p-&gt;size = 0;
-}
-
-int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc)
-{
-  p-&gt;size = 0;
-  if (size == 0)
-  {
-    p-&gt;data = 0;
-    return 1;
-  }
-  p-&gt;data = (Byte *)alloc-&gt;Alloc(alloc, size);
-  if (p-&gt;data != 0)
-  {
-    p-&gt;size = size;
-    return 1;
-  }
-  return 0;
-}
-
-void Buf_Free(CBuf *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;data);
-  p-&gt;data = 0;
-  p-&gt;size = 0;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,36 @@
+/* 7zBuf.c -- Byte Buffer
+2008-03-28
+Igor Pavlov
+Public domain */
+
+#include &quot;7zBuf.h&quot;
+
+void Buf_Init(CBuf *p)
+{
+  p-&gt;data = 0;
+  p-&gt;size = 0;
+}
+
+int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc)
+{
+  p-&gt;size = 0;
+  if (size == 0)
+  {
+    p-&gt;data = 0;
+    return 1;
+  }
+  p-&gt;data = (Byte *)alloc-&gt;Alloc(alloc, size);
+  if (p-&gt;data != 0)
+  {
+    p-&gt;size = size;
+    return 1;
+  }
+  return 0;
+}
+
+void Buf_Free(CBuf *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;data);
+  p-&gt;data = 0;
+  p-&gt;size = 0;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,21 +0,0 @@
-/* 7zBuf.h -- Byte Buffer
-2008-05-01
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_BUF_H
-#define __7Z_BUF_H
-
-#include &quot;Types.h&quot;
-
-typedef struct
-{
-  Byte *data;
-  size_t size;
-} CBuf;
-
-void Buf_Init(CBuf *p);
-int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc);
-void Buf_Free(CBuf *p, ISzAlloc *alloc);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zBuf.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,21 @@
+/* 7zBuf.h -- Byte Buffer
+2008-05-01
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_BUF_H
+#define __7Z_BUF_H
+
+#include &quot;Types.h&quot;
+
+typedef struct
+{
+  Byte *data;
+  size_t size;
+} CBuf;
+
+void Buf_Init(CBuf *p);
+int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc);
+void Buf_Free(CBuf *p, ISzAlloc *alloc);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,35 +0,0 @@
-/* 7zCrc.c -- CRC32 calculation
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#include &quot;7zCrc.h&quot;
-
-#define kCrcPoly 0xEDB88320
-UInt32 g_CrcTable[256];
-
-void MY_FAST_CALL CrcGenerateTable(void)
-{
-  UInt32 i;
-  for (i = 0; i &lt; 256; i++)
-  {
-    UInt32 r = i;
-    int j;
-    for (j = 0; j &lt; 8; j++)
-      r = (r &gt;&gt; 1) ^ (kCrcPoly &amp; ~((r &amp; 1) - 1));
-    g_CrcTable[i] = r;
-  }
-}
-
-UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
-{
-  const Byte *p = (const Byte *)data;
-  for (; size &gt; 0 ; size--, p++)
-    v = CRC_UPDATE_BYTE(v, *p);
-  return v;
-}
-
-UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size)
-{
-  return CrcUpdate(CRC_INIT_VAL, data, size) ^ 0xFFFFFFFF;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,35 @@
+/* 7zCrc.c -- CRC32 calculation
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include &quot;7zCrc.h&quot;
+
+#define kCrcPoly 0xEDB88320
+UInt32 g_CrcTable[256];
+
+void MY_FAST_CALL CrcGenerateTable(void)
+{
+  UInt32 i;
+  for (i = 0; i &lt; 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j &lt; 8; j++)
+      r = (r &gt;&gt; 1) ^ (kCrcPoly &amp; ~((r &amp; 1) - 1));
+    g_CrcTable[i] = r;
+  }
+}
+
+UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
+{
+  const Byte *p = (const Byte *)data;
+  for (; size &gt; 0 ; size--, p++)
+    v = CRC_UPDATE_BYTE(v, *p);
+  return v;
+}
+
+UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size)
+{
+  return CrcUpdate(CRC_INIT_VAL, data, size) ^ 0xFFFFFFFF;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,24 +0,0 @@
-/* 7zCrc.h -- CRC32 calculation
-2008-03-13
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_CRC_H
-#define __7Z_CRC_H
-
-#include &lt;stddef.h&gt;
-
-#include &quot;Types.h&quot;
-
-extern UInt32 g_CrcTable[];
-
-void MY_FAST_CALL CrcGenerateTable(void);
-
-#define CRC_INIT_VAL 0xFFFFFFFF
-#define CRC_GET_DIGEST(crc) ((crc) ^ 0xFFFFFFFF)
-#define CRC_UPDATE_BYTE(crc, b) (g_CrcTable[((crc) ^ (b)) &amp; 0xFF] ^ ((crc) &gt;&gt; 8))
-
-UInt32 MY_FAST_CALL CrcUpdate(UInt32 crc, const void *data, size_t size);
-UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/7zCrc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,24 @@
+/* 7zCrc.h -- CRC32 calculation
+2008-03-13
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_CRC_H
+#define __7Z_CRC_H
+
+#include &lt;stddef.h&gt;
+
+#include &quot;Types.h&quot;
+
+extern UInt32 g_CrcTable[];
+
+void MY_FAST_CALL CrcGenerateTable(void);
+
+#define CRC_INIT_VAL 0xFFFFFFFF
+#define CRC_GET_DIGEST(crc) ((crc) ^ 0xFFFFFFFF)
+#define CRC_UPDATE_BYTE(crc, b) (g_CrcTable[((crc) ^ (b)) &amp; 0xFF] ^ ((crc) &gt;&gt; 8))
+
+UInt32 MY_FAST_CALL CrcUpdate(UInt32 crc, const void *data, size_t size);
+UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,122 +0,0 @@
-/* Alloc.c -- Memory allocation functions
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifdef _WIN32
-#include &lt;windows.h&gt;
-#endif
-#include &lt;stdlib.h&gt;
-
-#include &quot;Alloc.h&quot;
-
-/* #define _SZ_ALLOC_DEBUG */
-
-/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
-#ifdef _SZ_ALLOC_DEBUG
-#include &lt;stdio.h&gt;
-int g_allocCount = 0;
-int g_allocCountMid = 0;
-int g_allocCountBig = 0;
-#endif
-
-void *MyAlloc(size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount++);
-  #endif
-  return malloc(size);
-}
-
-void MyFree(void *address)
-{
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-    fprintf(stderr, &quot;\nFree; count = %10d&quot;, --g_allocCount);
-  #endif
-  free(address);
-}
-
-#ifdef _WIN32
-
-void *MidAlloc(size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc_Mid %10d bytes;  count = %10d&quot;, size, g_allocCountMid++);
-  #endif
-  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
-}
-
-void MidFree(void *address)
-{
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-    fprintf(stderr, &quot;\nFree_Mid; count = %10d&quot;, --g_allocCountMid);
-  #endif
-  if (address == 0)
-    return;
-  VirtualFree(address, 0, MEM_RELEASE);
-}
-
-#ifndef MEM_LARGE_PAGES
-#undef _7ZIP_LARGE_PAGES
-#endif
-
-#ifdef _7ZIP_LARGE_PAGES
-SIZE_T g_LargePageSize = 0;
-typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
-#endif
-
-void SetLargePageSize()
-{
-  #ifdef _7ZIP_LARGE_PAGES
-  SIZE_T size = 0;
-  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
-        GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;GetLargePageMinimum&quot;);
-  if (largePageMinimum == 0)
-    return;
-  size = largePageMinimum();
-  if (size == 0 || (size &amp; (size - 1)) != 0)
-    return;
-  g_LargePageSize = size;
-  #endif
-}
-
-
-void *BigAlloc(size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc_Big %10d bytes;  count = %10d&quot;, size, g_allocCountBig++);
-  #endif
-  
-  #ifdef _7ZIP_LARGE_PAGES
-  if (g_LargePageSize != 0 &amp;&amp; g_LargePageSize &lt;= (1 &lt;&lt; 30) &amp;&amp; size &gt;= (1 &lt;&lt; 18))
-  {
-    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) &amp; (~(g_LargePageSize - 1)),
-        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
-    if (res != 0)
-      return res;
-  }
-  #endif
-  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
-}
-
-void BigFree(void *address)
-{
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-    fprintf(stderr, &quot;\nFree_Big; count = %10d&quot;, --g_allocCountBig);
-  #endif
-  
-  if (address == 0)
-    return;
-  VirtualFree(address, 0, MEM_RELEASE);
-}
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,122 @@
+/* Alloc.c -- Memory allocation functions
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifdef _WIN32
+#include &lt;windows.h&gt;
+#endif
+#include &lt;stdlib.h&gt;
+
+#include &quot;Alloc.h&quot;
+
+/* #define _SZ_ALLOC_DEBUG */
+
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+#ifdef _SZ_ALLOC_DEBUG
+#include &lt;stdio.h&gt;
+int g_allocCount = 0;
+int g_allocCountMid = 0;
+int g_allocCountBig = 0;
+#endif
+
+void *MyAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount++);
+  #endif
+  return malloc(size);
+}
+
+void MyFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree; count = %10d&quot;, --g_allocCount);
+  #endif
+  free(address);
+}
+
+#ifdef _WIN32
+
+void *MidAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_Mid %10d bytes;  count = %10d&quot;, size, g_allocCountMid++);
+  #endif
+  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void MidFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree_Mid; count = %10d&quot;, --g_allocCountMid);
+  #endif
+  if (address == 0)
+    return;
+  VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#ifndef MEM_LARGE_PAGES
+#undef _7ZIP_LARGE_PAGES
+#endif
+
+#ifdef _7ZIP_LARGE_PAGES
+SIZE_T g_LargePageSize = 0;
+typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
+#endif
+
+void SetLargePageSize()
+{
+  #ifdef _7ZIP_LARGE_PAGES
+  SIZE_T size = 0;
+  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
+        GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;GetLargePageMinimum&quot;);
+  if (largePageMinimum == 0)
+    return;
+  size = largePageMinimum();
+  if (size == 0 || (size &amp; (size - 1)) != 0)
+    return;
+  g_LargePageSize = size;
+  #endif
+}
+
+
+void *BigAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_Big %10d bytes;  count = %10d&quot;, size, g_allocCountBig++);
+  #endif
+  
+  #ifdef _7ZIP_LARGE_PAGES
+  if (g_LargePageSize != 0 &amp;&amp; g_LargePageSize &lt;= (1 &lt;&lt; 30) &amp;&amp; size &gt;= (1 &lt;&lt; 18))
+  {
+    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) &amp; (~(g_LargePageSize - 1)),
+        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
+    if (res != 0)
+      return res;
+  }
+  #endif
+  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void BigFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree_Big; count = %10d&quot;, --g_allocCountBig);
+  #endif
+  
+  if (address == 0)
+    return;
+  VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,32 +0,0 @@
-/* Alloc.h -- Memory allocation functions
-2008-03-13
-Igor Pavlov
-Public domain */
-
-#ifndef __COMMON_ALLOC_H
-#define __COMMON_ALLOC_H
-
-#include &lt;stddef.h&gt;
-
-void *MyAlloc(size_t size);
-void MyFree(void *address);
-
-#ifdef _WIN32
-
-void SetLargePageSize();
-
-void *MidAlloc(size_t size);
-void MidFree(void *address);
-void *BigAlloc(size_t size);
-void BigFree(void *address);
-
-#else
-
-#define MidAlloc(size) MyAlloc(size)
-#define MidFree(address) MyFree(address)
-#define BigAlloc(size) MyAlloc(size)
-#define BigFree(address) MyFree(address)
-
-#endif
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Alloc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,32 @@
+/* Alloc.h -- Memory allocation functions
+2008-03-13
+Igor Pavlov
+Public domain */
+
+#ifndef __COMMON_ALLOC_H
+#define __COMMON_ALLOC_H
+
+#include &lt;stddef.h&gt;
+
+void *MyAlloc(size_t size);
+void MyFree(void *address);
+
+#ifdef _WIN32
+
+void SetLargePageSize();
+
+void *MidAlloc(size_t size);
+void MidFree(void *address);
+void *BigAlloc(size_t size);
+void BigFree(void *address);
+
+#else
+
+#define MidAlloc(size) MyAlloc(size)
+#define MidFree(address) MyFree(address)
+#define BigAlloc(size) MyAlloc(size)
+#define BigFree(address) MyFree(address)
+
+#endif
+
+#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive)

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,187 +0,0 @@
-# Microsoft Developer Studio Project File - Name=&quot;7z&quot; - Package Owner=&lt;4&gt;
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
-
-CFG=7z - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;7z.mak&quot;.
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;7z.mak&quot; CFG=&quot;7z - Win32 Debug&quot;
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE &quot;7z - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
-!MESSAGE &quot;7z - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName &quot;&quot;
-# PROP Scc_LocalPath &quot;&quot;
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  &quot;$(CFG)&quot; == &quot;7z - Win32 Release&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir &quot;Release&quot;
-# PROP BASE Intermediate_Dir &quot;Release&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir &quot;Release&quot;
-# PROP Intermediate_Dir &quot;Release&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
-# ADD CPP /nologo /MD /W3 /GX /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
-# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;Release/7zDec.exe&quot; /opt:NOWIN98
-# SUBTRACT LINK32 /pdb:none
-
-!ELSEIF  &quot;$(CFG)&quot; == &quot;7z - Win32 Debug&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir &quot;Debug&quot;
-# PROP BASE Intermediate_Dir &quot;Debug&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir &quot;Debug&quot;
-# PROP Intermediate_Dir &quot;Debug&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
-# ADD CPP /nologo /W4 /Gm /GX /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
-# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;Debug/7zDec.exe&quot; /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name &quot;7z - Win32 Release&quot;
-# Name &quot;7z - Win32 Debug&quot;
-# Begin Group &quot;Common&quot;
-
-# PROP Default_Filter &quot;&quot;
-# Begin Source File
-
-SOURCE=..\..\7zBuf.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\7zBuf.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\7zCrc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\7zCrc.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Bcj2.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Bcj2.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Bra.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Bra86.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\LzmaDec.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\LzmaDec.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\Types.h
-# End Source File
-# End Group
-# Begin Source File
-
-SOURCE=.\7zAlloc.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zAlloc.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zDecode.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zDecode.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zExtract.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zExtract.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zHeader.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zHeader.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zIn.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zIn.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zItem.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zItem.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\7zMain.c
-# End Source File
-# End Target
-# End Project

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,187 @@
+# Microsoft Developer Studio Project File - Name=&quot;7z&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
+
+CFG=7z - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;7z.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;7z.mak&quot; CFG=&quot;7z - Win32 Debug&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;7z - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE &quot;7z - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;7z - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;Release/7zDec.exe&quot; /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;7z - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /W4 /Gm /GX /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;Debug/7zDec.exe&quot; /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;7z - Win32 Release&quot;
+# Name &quot;7z - Win32 Debug&quot;
+# Begin Group &quot;Common&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\..\7zBuf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zBuf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zCrc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zCrc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bcj2.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bcj2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bra.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bra86.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Types.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\7zAlloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zAlloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMain.c
+# End Source File
+# End Target
+# End Project

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,29 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: &quot;7z&quot;=.\7z.dsp - Package Owner=&lt;4&gt;
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;4&gt;
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;3&gt;
-{{{
-}}}
-
-###############################################################################
-

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7z.dsw	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;7z&quot;=.\7z.dsp - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,79 +0,0 @@
-/* 7zAlloc.c -- Allocation functions
-2008-03-28
-Igor Pavlov
-Public domain */
-
-#include &lt;stdlib.h&gt;
-#include &quot;7zAlloc.h&quot;
-
-/* #define _SZ_ALLOC_DEBUG */
-/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
-
-#ifdef _SZ_ALLOC_DEBUG
-
-#ifdef _WIN32
-#include &lt;windows.h&gt;
-#endif
-
-#include &lt;stdio.h&gt;
-int g_allocCount = 0;
-int g_allocCountTemp = 0;
-
-#endif
-
-void *SzAlloc(void *p, size_t size)
-{
-  p = p;
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount);
-  g_allocCount++;
-  #endif
-  return malloc(size);
-}
-
-void SzFree(void *p, void *address)
-{
-  p = p;
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-  {
-    g_allocCount--;
-    fprintf(stderr, &quot;\nFree; count = %10d&quot;, g_allocCount);
-  }
-  #endif
-  free(address);
-}
-
-void *SzAllocTemp(void *p, size_t size)
-{
-  p = p;
-  if (size == 0)
-    return 0;
-  #ifdef _SZ_ALLOC_DEBUG
-  fprintf(stderr, &quot;\nAlloc_temp %10d bytes;  count = %10d&quot;, size, g_allocCountTemp);
-  g_allocCountTemp++;
-  #ifdef _WIN32
-  return HeapAlloc(GetProcessHeap(), 0, size);
-  #endif
-  #endif
-  return malloc(size);
-}
-
-void SzFreeTemp(void *p, void *address)
-{
-  p = p;
-  #ifdef _SZ_ALLOC_DEBUG
-  if (address != 0)
-  {
-    g_allocCountTemp--;
-    fprintf(stderr, &quot;\nFree_temp; count = %10d&quot;, g_allocCountTemp);
-  }
-  #ifdef _WIN32
-  HeapFree(GetProcessHeap(), 0, address);
-  return;
-  #endif
-  #endif
-  free(address);
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,79 @@
+/* 7zAlloc.c -- Allocation functions
+2008-03-28
+Igor Pavlov
+Public domain */
+
+#include &lt;stdlib.h&gt;
+#include &quot;7zAlloc.h&quot;
+
+/* #define _SZ_ALLOC_DEBUG */
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+
+#ifdef _SZ_ALLOC_DEBUG
+
+#ifdef _WIN32
+#include &lt;windows.h&gt;
+#endif
+
+#include &lt;stdio.h&gt;
+int g_allocCount = 0;
+int g_allocCountTemp = 0;
+
+#endif
+
+void *SzAlloc(void *p, size_t size)
+{
+  p = p;
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount);
+  g_allocCount++;
+  #endif
+  return malloc(size);
+}
+
+void SzFree(void *p, void *address)
+{
+  p = p;
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCount--;
+    fprintf(stderr, &quot;\nFree; count = %10d&quot;, g_allocCount);
+  }
+  #endif
+  free(address);
+}
+
+void *SzAllocTemp(void *p, size_t size)
+{
+  p = p;
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_temp %10d bytes;  count = %10d&quot;, size, g_allocCountTemp);
+  g_allocCountTemp++;
+  #ifdef _WIN32
+  return HeapAlloc(GetProcessHeap(), 0, size);
+  #endif
+  #endif
+  return malloc(size);
+}
+
+void SzFreeTemp(void *p, void *address)
+{
+  p = p;
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCountTemp--;
+    fprintf(stderr, &quot;\nFree_temp; count = %10d&quot;, g_allocCountTemp);
+  }
+  #ifdef _WIN32
+  HeapFree(GetProcessHeap(), 0, address);
+  return;
+  #endif
+  #endif
+  free(address);
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,17 +0,0 @@
-/* 7zAlloc.h -- Allocation functions
-2008-03-28
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_ALLOC_H
-#define __7Z_ALLOC_H
-
-#include &lt;stddef.h&gt;
-
-void *SzAlloc(void *p, size_t size);
-void SzFree(void *p, void *address);
-
-void *SzAllocTemp(void *p, size_t size);
-void SzFreeTemp(void *p, void *address);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zAlloc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,17 @@
+/* 7zAlloc.h -- Allocation functions
+2008-03-28
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_ALLOC_H
+#define __7Z_ALLOC_H
+
+#include &lt;stddef.h&gt;
+
+void *SzAlloc(void *p, size_t size);
+void SzFree(void *p, void *address);
+
+void *SzAllocTemp(void *p, size_t size);
+void SzFreeTemp(void *p, void *address);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,339 +0,0 @@
-/* 7zDecode.c  Decoding from 7z folder
-2008-08-05
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zDecode.h for license options */
-
-#include &lt;string.h&gt;
-
-#include &quot;7zDecode.h&quot;
-#include &quot;../../LzmaDec.h&quot;
-#include &quot;../../Bra.h&quot;
-#include &quot;../../Bcj2.h&quot;
-
-#define k_Copy 0
-#define k_LZMA 0x30101
-#define k_BCJ 0x03030103
-#define k_BCJ2 0x0303011B
-
-/*
-#ifdef _LZMA_IN_CB
-*/
-
-static SRes SzDecodeLzma(CSzCoderInfo *coder, CFileSize inSize, ISzInStream *inStream,
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
-{
-  CLzmaDec state;
-  int res = SZ_OK;
-  size_t _inSize;
-  Byte *inBuf = NULL;
-
-  LzmaDec_Construct(&amp;state);
-  RINOK(LzmaDec_AllocateProbs(&amp;state, coder-&gt;Props.data, (unsigned)coder-&gt;Props.size, allocMain));
-  state.dic = outBuffer;
-  state.dicBufSize = outSize;
-  LzmaDec_Init(&amp;state);
-
-  _inSize = 0;
-
-  for (;;)
-  {
-    if (_inSize == 0)
-    {
-      _inSize = (1 &lt;&lt; 18);
-      if (_inSize &gt; inSize)
-        _inSize = (size_t)(inSize);
-      res = inStream-&gt;Read((void *)inStream, (void **)&amp;inBuf, &amp;_inSize);
-      if (res != SZ_OK)
-        break;
-      inSize -= _inSize;
-    }
-
-    {
-      SizeT inProcessed = _inSize, dicPos = state.dicPos;
-      ELzmaStatus status;
-      res = LzmaDec_DecodeToDic(&amp;state, outSize, inBuf, &amp;inProcessed, LZMA_FINISH_END, &amp;status);
-      _inSize -= inProcessed;
-      inBuf = (Byte *)inBuf + inProcessed;
-      if (res != SZ_OK)
-        break;
-      if (state.dicPos == state.dicBufSize || (inProcessed == 0 &amp;&amp; dicPos == state.dicPos))
-      {
-        if (state.dicBufSize != outSize || _inSize != 0 ||
-            (status != LZMA_STATUS_FINISHED_WITH_MARK &amp;&amp;
-             status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK))
-          res = SZ_ERROR_DATA;
-        break;
-      }
-    }
-  }
-
-  LzmaDec_FreeProbs(&amp;state, allocMain);
-
-  return res;
-}
-
-static SRes SzDecodeCopy(CFileSize inSize, ISzInStream *inStream, Byte *outBuffer)
-{
-  while (inSize &gt; 0)
-  {
-    void *inBuffer;
-    size_t curSize = (1 &lt;&lt; 18);
-    if (curSize &gt; inSize)
-      curSize = (size_t)(inSize);
-    RINOK(inStream-&gt;Read((void *)inStream, (void **)&amp;inBuffer, &amp;curSize));
-    if (curSize == 0)
-      return SZ_ERROR_INPUT_EOF;
-    memcpy(outBuffer, inBuffer, curSize);
-    outBuffer += curSize;
-    inSize -= curSize;
-  }
-  return SZ_OK;
-}
-/*
-#endif
-*/
-
-#define IS_UNSUPPORTED_METHOD(m) ((m) != k_Copy &amp;&amp; (m) != k_LZMA)
-#define IS_UNSUPPORTED_CODER(c) (IS_UNSUPPORTED_METHOD(c.MethodID) || c.NumInStreams != 1 || c.NumOutStreams != 1)
-#define IS_NO_BCJ(c) (c.MethodID != k_BCJ || c.NumInStreams != 1 || c.NumOutStreams != 1)
-#define IS_NO_BCJ2(c) (c.MethodID != k_BCJ2 || c.NumInStreams != 4 || c.NumOutStreams != 1)
-
-SRes CheckSupportedFolder(const CSzFolder *f)
-{
-  if (f-&gt;NumCoders &lt; 1 || f-&gt;NumCoders &gt; 4)
-    return SZ_ERROR_UNSUPPORTED;
-  if (IS_UNSUPPORTED_CODER(f-&gt;Coders[0]))
-    return SZ_ERROR_UNSUPPORTED;
-  if (f-&gt;NumCoders == 1)
-  {
-    if (f-&gt;NumPackStreams != 1 || f-&gt;PackStreams[0] != 0 || f-&gt;NumBindPairs != 0)
-      return SZ_ERROR_UNSUPPORTED;
-    return SZ_OK;
-  }
-  if (f-&gt;NumCoders == 2)
-  {
-    if (IS_NO_BCJ(f-&gt;Coders[1]) ||
-        f-&gt;NumPackStreams != 1 || f-&gt;PackStreams[0] != 0 ||
-        f-&gt;NumBindPairs != 1 ||
-        f-&gt;BindPairs[0].InIndex != 1 || f-&gt;BindPairs[0].OutIndex != 0)
-      return SZ_ERROR_UNSUPPORTED;
-    return SZ_OK;
-  }
-  if (f-&gt;NumCoders == 4)
-  {
-    if (IS_UNSUPPORTED_CODER(f-&gt;Coders[1]) ||
-        IS_UNSUPPORTED_CODER(f-&gt;Coders[2]) ||
-        IS_NO_BCJ2(f-&gt;Coders[3]))
-      return SZ_ERROR_UNSUPPORTED;
-    if (f-&gt;NumPackStreams != 4 ||
-        f-&gt;PackStreams[0] != 2 ||
-        f-&gt;PackStreams[1] != 6 ||
-        f-&gt;PackStreams[2] != 1 ||
-        f-&gt;PackStreams[3] != 0 ||
-        f-&gt;NumBindPairs != 3 ||
-        f-&gt;BindPairs[0].InIndex != 5 || f-&gt;BindPairs[0].OutIndex != 0 ||
-        f-&gt;BindPairs[1].InIndex != 4 || f-&gt;BindPairs[1].OutIndex != 1 ||
-        f-&gt;BindPairs[2].InIndex != 3 || f-&gt;BindPairs[2].OutIndex != 2)
-      return SZ_ERROR_UNSUPPORTED;
-    return SZ_OK;
-  }
-  return SZ_ERROR_UNSUPPORTED;
-}
-
-CFileSize GetSum(const CFileSize *values, UInt32 index)
-{
-  CFileSize sum = 0;
-  UInt32 i;
-  for (i = 0; i &lt; index; i++)
-    sum += values[i];
-  return sum;
-}
-
-SRes SzDecode2(const CFileSize *packSizes, const CSzFolder *folder,
-    /*
-    #ifdef _LZMA_IN_CB
-    */
-    ISzInStream *inStream, CFileSize startPos,
-    /*
-    #else
-    const Byte *inBuffer,
-    #endif
-    */
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain,
-    Byte *tempBuf[])
-{
-  UInt32 ci;
-  size_t tempSizes[3] = { 0, 0, 0};
-  size_t tempSize3 = 0;
-  Byte *tempBuf3 = 0;
-
-  RINOK(CheckSupportedFolder(folder));
-
-  for (ci = 0; ci &lt; folder-&gt;NumCoders; ci++)
-  {
-    CSzCoderInfo *coder = &amp;folder-&gt;Coders[ci];
-
-    if (coder-&gt;MethodID == k_Copy || coder-&gt;MethodID == k_LZMA)
-    {
-      UInt32 si = 0;
-      CFileSize offset;
-      CFileSize inSize;
-      Byte *outBufCur = outBuffer;
-      size_t outSizeCur = outSize;
-      if (folder-&gt;NumCoders == 4)
-      {
-        UInt32 indices[] = { 3, 2, 0 };
-        CFileSize unpackSize = folder-&gt;UnpackSizes[ci];
-        si = indices[ci];
-        if (ci &lt; 2)
-        {
-          Byte *temp;
-          outSizeCur = (size_t)unpackSize;
-          if (outSizeCur != unpackSize)
-            return SZ_ERROR_MEM;
-          temp = (Byte *)IAlloc_Alloc(allocMain, outSizeCur);
-          if (temp == 0 &amp;&amp; outSizeCur != 0)
-            return SZ_ERROR_MEM;
-          outBufCur = tempBuf[1 - ci] = temp;
-          tempSizes[1 - ci] = outSizeCur;
-        }
-        else if (ci == 2)
-        {
-          if (unpackSize &gt; outSize) // check it
-            return SZ_ERROR_PARAM; // check it
-          tempBuf3 = outBufCur = outBuffer + (outSize - (size_t)unpackSize);
-          tempSize3 = outSizeCur = (size_t)unpackSize;
-        }
-        else
-          return SZ_ERROR_UNSUPPORTED;
-      }
-      offset = GetSum(packSizes, si);
-      inSize = packSizes[si];
-      /*
-      #ifdef _LZMA_IN_CB
-      */
-      RINOK(inStream-&gt;Seek(inStream, startPos + offset, SZ_SEEK_SET));
-      /*
-      #endif
-      */
-
-      if (coder-&gt;MethodID == k_Copy)
-      {
-        if (inSize != outSizeCur) // check it
-          return SZ_ERROR_DATA;
-        
-        /*
-        #ifdef _LZMA_IN_CB
-        */
-        RINOK(SzDecodeCopy(inSize, inStream, outBufCur));
-        /*
-        #else
-        memcpy(outBufCur, inBuffer + (size_t)offset, (size_t)inSize);
-        #endif
-        */
-      }
-      else
-      {
-        /*
-        #ifdef _LZMA_IN_CB
-        */
-        SRes res = SzDecodeLzma(coder, inSize,
-            inStream,
-            outBufCur, outSizeCur, allocMain);
-        /*
-        #else
-        SizeT lzmaOutSizeT = outSizeCur;
-        SizeT lzmaInSizeT = (SizeT)inSize;
-        SRes res = LzmaDecode(outBufCur, &amp;lzmaOutSizeT,
-            inBuffer + (size_t)offset, &amp;lzmaInSizeT,
-            coder-&gt;Props.Items, (unsigned)coder-&gt;Props.size, LZMA_FINISH_BYTE, allocMain);
-        #endif
-        */
-
-        RINOK(res);
-      }
-    }
-    else if (coder-&gt;MethodID == k_BCJ)
-    {
-      UInt32 state;
-      if (ci != 1)
-        return SZ_ERROR_UNSUPPORTED;
-      x86_Convert_Init(state);
-      x86_Convert(outBuffer, outSize, 0, &amp;state, 0);
-    }
-    else if (coder-&gt;MethodID == k_BCJ2)
-    {
-      CFileSize offset = GetSum(packSizes, 1);
-      CFileSize s3Size = packSizes[1];
-      SRes res;
-      if (ci != 3)
-        return SZ_ERROR_UNSUPPORTED;
-
-      /*
-      #ifdef _LZMA_IN_CB
-      */
-      RINOK(inStream-&gt;Seek(inStream, startPos + offset, SZ_SEEK_SET));
-      tempSizes[2] = (size_t)s3Size;
-      if (tempSizes[2] != s3Size)
-        return SZ_ERROR_MEM;
-      tempBuf[2] = (Byte *)IAlloc_Alloc(allocMain, tempSizes[2]);
-      if (tempBuf[2] == 0 &amp;&amp; tempSizes[2] != 0)
-        return SZ_ERROR_MEM;
-      res = SzDecodeCopy(s3Size, inStream, tempBuf[2]);
-      RINOK(res)
-      /*
-      #endif
-      */
-
-      res = Bcj2_Decode(
-          tempBuf3, tempSize3,
-          tempBuf[0], tempSizes[0],
-          tempBuf[1], tempSizes[1],
-          /*
-          #ifdef _LZMA_IN_CB
-          */
-          tempBuf[2], tempSizes[2],
-          /*
-          #else
-          inBuffer + (size_t)offset, (size_t)s3Size,
-          #endif
-          */
-          outBuffer, outSize);
-      RINOK(res)
-    }
-    else
-      return SZ_ERROR_UNSUPPORTED;
-  }
-  return SZ_OK;
-}
-
-SRes SzDecode(const CFileSize *packSizes, const CSzFolder *folder,
-    /*
-    #ifdef _LZMA_IN_CB
-    */
-    ISzInStream *inStream, CFileSize startPos,
-    /*
-    #else
-    const Byte *inBuffer,
-    #endif
-    */
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
-{
-  Byte *tempBuf[3] = { 0, 0, 0};
-  int i;
-  SRes res = SzDecode2(packSizes, folder,
-      /*
-      #ifdef _LZMA_IN_CB
-      */
-      inStream, startPos,
-      /*
-      #else
-      inBuffer,
-      #endif
-      */
-      outBuffer, outSize, allocMain, tempBuf);
-  for (i = 0; i &lt; 3; i++)
-    IAlloc_Free(allocMain, tempBuf[i]);
-  return res;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,339 @@
+/* 7zDecode.c  Decoding from 7z folder
+2008-08-05
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zDecode.h for license options */
+
+#include &lt;string.h&gt;
+
+#include &quot;7zDecode.h&quot;
+#include &quot;../../LzmaDec.h&quot;
+#include &quot;../../Bra.h&quot;
+#include &quot;../../Bcj2.h&quot;
+
+#define k_Copy 0
+#define k_LZMA 0x30101
+#define k_BCJ 0x03030103
+#define k_BCJ2 0x0303011B
+
+/*
+#ifdef _LZMA_IN_CB
+*/
+
+static SRes SzDecodeLzma(CSzCoderInfo *coder, CFileSize inSize, ISzInStream *inStream,
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
+{
+  CLzmaDec state;
+  int res = SZ_OK;
+  size_t _inSize;
+  Byte *inBuf = NULL;
+
+  LzmaDec_Construct(&amp;state);
+  RINOK(LzmaDec_AllocateProbs(&amp;state, coder-&gt;Props.data, (unsigned)coder-&gt;Props.size, allocMain));
+  state.dic = outBuffer;
+  state.dicBufSize = outSize;
+  LzmaDec_Init(&amp;state);
+
+  _inSize = 0;
+
+  for (;;)
+  {
+    if (_inSize == 0)
+    {
+      _inSize = (1 &lt;&lt; 18);
+      if (_inSize &gt; inSize)
+        _inSize = (size_t)(inSize);
+      res = inStream-&gt;Read((void *)inStream, (void **)&amp;inBuf, &amp;_inSize);
+      if (res != SZ_OK)
+        break;
+      inSize -= _inSize;
+    }
+
+    {
+      SizeT inProcessed = _inSize, dicPos = state.dicPos;
+      ELzmaStatus status;
+      res = LzmaDec_DecodeToDic(&amp;state, outSize, inBuf, &amp;inProcessed, LZMA_FINISH_END, &amp;status);
+      _inSize -= inProcessed;
+      inBuf = (Byte *)inBuf + inProcessed;
+      if (res != SZ_OK)
+        break;
+      if (state.dicPos == state.dicBufSize || (inProcessed == 0 &amp;&amp; dicPos == state.dicPos))
+      {
+        if (state.dicBufSize != outSize || _inSize != 0 ||
+            (status != LZMA_STATUS_FINISHED_WITH_MARK &amp;&amp;
+             status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK))
+          res = SZ_ERROR_DATA;
+        break;
+      }
+    }
+  }
+
+  LzmaDec_FreeProbs(&amp;state, allocMain);
+
+  return res;
+}
+
+static SRes SzDecodeCopy(CFileSize inSize, ISzInStream *inStream, Byte *outBuffer)
+{
+  while (inSize &gt; 0)
+  {
+    void *inBuffer;
+    size_t curSize = (1 &lt;&lt; 18);
+    if (curSize &gt; inSize)
+      curSize = (size_t)(inSize);
+    RINOK(inStream-&gt;Read((void *)inStream, (void **)&amp;inBuffer, &amp;curSize));
+    if (curSize == 0)
+      return SZ_ERROR_INPUT_EOF;
+    memcpy(outBuffer, inBuffer, curSize);
+    outBuffer += curSize;
+    inSize -= curSize;
+  }
+  return SZ_OK;
+}
+/*
+#endif
+*/
+
+#define IS_UNSUPPORTED_METHOD(m) ((m) != k_Copy &amp;&amp; (m) != k_LZMA)
+#define IS_UNSUPPORTED_CODER(c) (IS_UNSUPPORTED_METHOD(c.MethodID) || c.NumInStreams != 1 || c.NumOutStreams != 1)
+#define IS_NO_BCJ(c) (c.MethodID != k_BCJ || c.NumInStreams != 1 || c.NumOutStreams != 1)
+#define IS_NO_BCJ2(c) (c.MethodID != k_BCJ2 || c.NumInStreams != 4 || c.NumOutStreams != 1)
+
+SRes CheckSupportedFolder(const CSzFolder *f)
+{
+  if (f-&gt;NumCoders &lt; 1 || f-&gt;NumCoders &gt; 4)
+    return SZ_ERROR_UNSUPPORTED;
+  if (IS_UNSUPPORTED_CODER(f-&gt;Coders[0]))
+    return SZ_ERROR_UNSUPPORTED;
+  if (f-&gt;NumCoders == 1)
+  {
+    if (f-&gt;NumPackStreams != 1 || f-&gt;PackStreams[0] != 0 || f-&gt;NumBindPairs != 0)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  if (f-&gt;NumCoders == 2)
+  {
+    if (IS_NO_BCJ(f-&gt;Coders[1]) ||
+        f-&gt;NumPackStreams != 1 || f-&gt;PackStreams[0] != 0 ||
+        f-&gt;NumBindPairs != 1 ||
+        f-&gt;BindPairs[0].InIndex != 1 || f-&gt;BindPairs[0].OutIndex != 0)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  if (f-&gt;NumCoders == 4)
+  {
+    if (IS_UNSUPPORTED_CODER(f-&gt;Coders[1]) ||
+        IS_UNSUPPORTED_CODER(f-&gt;Coders[2]) ||
+        IS_NO_BCJ2(f-&gt;Coders[3]))
+      return SZ_ERROR_UNSUPPORTED;
+    if (f-&gt;NumPackStreams != 4 ||
+        f-&gt;PackStreams[0] != 2 ||
+        f-&gt;PackStreams[1] != 6 ||
+        f-&gt;PackStreams[2] != 1 ||
+        f-&gt;PackStreams[3] != 0 ||
+        f-&gt;NumBindPairs != 3 ||
+        f-&gt;BindPairs[0].InIndex != 5 || f-&gt;BindPairs[0].OutIndex != 0 ||
+        f-&gt;BindPairs[1].InIndex != 4 || f-&gt;BindPairs[1].OutIndex != 1 ||
+        f-&gt;BindPairs[2].InIndex != 3 || f-&gt;BindPairs[2].OutIndex != 2)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  return SZ_ERROR_UNSUPPORTED;
+}
+
+CFileSize GetSum(const CFileSize *values, UInt32 index)
+{
+  CFileSize sum = 0;
+  UInt32 i;
+  for (i = 0; i &lt; index; i++)
+    sum += values[i];
+  return sum;
+}
+
+SRes SzDecode2(const CFileSize *packSizes, const CSzFolder *folder,
+    /*
+    #ifdef _LZMA_IN_CB
+    */
+    ISzInStream *inStream, CFileSize startPos,
+    /*
+    #else
+    const Byte *inBuffer,
+    #endif
+    */
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain,
+    Byte *tempBuf[])
+{
+  UInt32 ci;
+  size_t tempSizes[3] = { 0, 0, 0};
+  size_t tempSize3 = 0;
+  Byte *tempBuf3 = 0;
+
+  RINOK(CheckSupportedFolder(folder));
+
+  for (ci = 0; ci &lt; folder-&gt;NumCoders; ci++)
+  {
+    CSzCoderInfo *coder = &amp;folder-&gt;Coders[ci];
+
+    if (coder-&gt;MethodID == k_Copy || coder-&gt;MethodID == k_LZMA)
+    {
+      UInt32 si = 0;
+      CFileSize offset;
+      CFileSize inSize;
+      Byte *outBufCur = outBuffer;
+      size_t outSizeCur = outSize;
+      if (folder-&gt;NumCoders == 4)
+      {
+        UInt32 indices[] = { 3, 2, 0 };
+        CFileSize unpackSize = folder-&gt;UnpackSizes[ci];
+        si = indices[ci];
+        if (ci &lt; 2)
+        {
+          Byte *temp;
+          outSizeCur = (size_t)unpackSize;
+          if (outSizeCur != unpackSize)
+            return SZ_ERROR_MEM;
+          temp = (Byte *)IAlloc_Alloc(allocMain, outSizeCur);
+          if (temp == 0 &amp;&amp; outSizeCur != 0)
+            return SZ_ERROR_MEM;
+          outBufCur = tempBuf[1 - ci] = temp;
+          tempSizes[1 - ci] = outSizeCur;
+        }
+        else if (ci == 2)
+        {
+          if (unpackSize &gt; outSize) // check it
+            return SZ_ERROR_PARAM; // check it
+          tempBuf3 = outBufCur = outBuffer + (outSize - (size_t)unpackSize);
+          tempSize3 = outSizeCur = (size_t)unpackSize;
+        }
+        else
+          return SZ_ERROR_UNSUPPORTED;
+      }
+      offset = GetSum(packSizes, si);
+      inSize = packSizes[si];
+      /*
+      #ifdef _LZMA_IN_CB
+      */
+      RINOK(inStream-&gt;Seek(inStream, startPos + offset, SZ_SEEK_SET));
+      /*
+      #endif
+      */
+
+      if (coder-&gt;MethodID == k_Copy)
+      {
+        if (inSize != outSizeCur) // check it
+          return SZ_ERROR_DATA;
+        
+        /*
+        #ifdef _LZMA_IN_CB
+        */
+        RINOK(SzDecodeCopy(inSize, inStream, outBufCur));
+        /*
+        #else
+        memcpy(outBufCur, inBuffer + (size_t)offset, (size_t)inSize);
+        #endif
+        */
+      }
+      else
+      {
+        /*
+        #ifdef _LZMA_IN_CB
+        */
+        SRes res = SzDecodeLzma(coder, inSize,
+            inStream,
+            outBufCur, outSizeCur, allocMain);
+        /*
+        #else
+        SizeT lzmaOutSizeT = outSizeCur;
+        SizeT lzmaInSizeT = (SizeT)inSize;
+        SRes res = LzmaDecode(outBufCur, &amp;lzmaOutSizeT,
+            inBuffer + (size_t)offset, &amp;lzmaInSizeT,
+            coder-&gt;Props.Items, (unsigned)coder-&gt;Props.size, LZMA_FINISH_BYTE, allocMain);
+        #endif
+        */
+
+        RINOK(res);
+      }
+    }
+    else if (coder-&gt;MethodID == k_BCJ)
+    {
+      UInt32 state;
+      if (ci != 1)
+        return SZ_ERROR_UNSUPPORTED;
+      x86_Convert_Init(state);
+      x86_Convert(outBuffer, outSize, 0, &amp;state, 0);
+    }
+    else if (coder-&gt;MethodID == k_BCJ2)
+    {
+      CFileSize offset = GetSum(packSizes, 1);
+      CFileSize s3Size = packSizes[1];
+      SRes res;
+      if (ci != 3)
+        return SZ_ERROR_UNSUPPORTED;
+
+      /*
+      #ifdef _LZMA_IN_CB
+      */
+      RINOK(inStream-&gt;Seek(inStream, startPos + offset, SZ_SEEK_SET));
+      tempSizes[2] = (size_t)s3Size;
+      if (tempSizes[2] != s3Size)
+        return SZ_ERROR_MEM;
+      tempBuf[2] = (Byte *)IAlloc_Alloc(allocMain, tempSizes[2]);
+      if (tempBuf[2] == 0 &amp;&amp; tempSizes[2] != 0)
+        return SZ_ERROR_MEM;
+      res = SzDecodeCopy(s3Size, inStream, tempBuf[2]);
+      RINOK(res)
+      /*
+      #endif
+      */
+
+      res = Bcj2_Decode(
+          tempBuf3, tempSize3,
+          tempBuf[0], tempSizes[0],
+          tempBuf[1], tempSizes[1],
+          /*
+          #ifdef _LZMA_IN_CB
+          */
+          tempBuf[2], tempSizes[2],
+          /*
+          #else
+          inBuffer + (size_t)offset, (size_t)s3Size,
+          #endif
+          */
+          outBuffer, outSize);
+      RINOK(res)
+    }
+    else
+      return SZ_ERROR_UNSUPPORTED;
+  }
+  return SZ_OK;
+}
+
+SRes SzDecode(const CFileSize *packSizes, const CSzFolder *folder,
+    /*
+    #ifdef _LZMA_IN_CB
+    */
+    ISzInStream *inStream, CFileSize startPos,
+    /*
+    #else
+    const Byte *inBuffer,
+    #endif
+    */
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
+{
+  Byte *tempBuf[3] = { 0, 0, 0};
+  int i;
+  SRes res = SzDecode2(packSizes, folder,
+      /*
+      #ifdef _LZMA_IN_CB
+      */
+      inStream, startPos,
+      /*
+      #else
+      inBuffer,
+      #endif
+      */
+      outBuffer, outSize, allocMain, tempBuf);
+  for (i = 0; i &lt; 3; i++)
+    IAlloc_Free(allocMain, tempBuf[i]);
+  return res;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,26 +0,0 @@
-/* 7zDecode.h -- Decoding from 7z folder
-2008-04-09
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zItem.h for license options */
-
-#ifndef __7Z_DECODE_H
-#define __7Z_DECODE_H
-
-#include &quot;7zItem.h&quot;
-
-#include &quot;7zIn.h&quot;
-
-SRes SzDecode(const CFileSize *packSizes, const CSzFolder *folder,
-    /*
-    #ifdef _LZMA_IN_CB
-    */
-    ISzInStream *stream, CFileSize startPos,
-    /*
-    #else
-    const Byte *inBuffer,
-    #endif
-    */
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zDecode.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,26 @@
+/* 7zDecode.h -- Decoding from 7z folder
+2008-04-09
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zItem.h for license options */
+
+#ifndef __7Z_DECODE_H
+#define __7Z_DECODE_H
+
+#include &quot;7zItem.h&quot;
+
+#include &quot;7zIn.h&quot;
+
+SRes SzDecode(const CFileSize *packSizes, const CSzFolder *folder,
+    /*
+    #ifdef _LZMA_IN_CB
+    */
+    ISzInStream *stream, CFileSize startPos,
+    /*
+    #else
+    const Byte *inBuffer,
+    #endif
+    */
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,96 +0,0 @@
-/* 7zExtract.c -- Extracting from 7z archive
-2008-08-17
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zExtract.h for license options */
-
-#include &quot;7zExtract.h&quot;
-#include &quot;7zDecode.h&quot;
-#include &quot;../../7zCrc.h&quot;
-
-SRes SzAr_Extract(
-    const CSzArEx *p,
-    ISzInStream *inStream,
-    UInt32 fileIndex,
-    UInt32 *blockIndex,
-    Byte **outBuffer,
-    size_t *outBufferSize,
-    size_t *offset,
-    size_t *outSizeProcessed,
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp)
-{
-  UInt32 folderIndex = p-&gt;FileIndexToFolderIndexMap[fileIndex];
-  SRes res = SZ_OK;
-  *offset = 0;
-  *outSizeProcessed = 0;
-  if (folderIndex == (UInt32)-1)
-  {
-    IAlloc_Free(allocMain, *outBuffer);
-    *blockIndex = folderIndex;
-    *outBuffer = 0;
-    *outBufferSize = 0;
-    return SZ_OK;
-  }
-
-  if (*outBuffer == 0 || *blockIndex != folderIndex)
-  {
-    CSzFolder *folder = p-&gt;db.Folders + folderIndex;
-    CFileSize unpackSizeSpec = SzFolder_GetUnpackSize(folder);
-    size_t unpackSize = (size_t)unpackSizeSpec;
-    CFileSize startOffset = SzArEx_GetFolderStreamPos(p, folderIndex, 0);
-
-    if (unpackSize != unpackSizeSpec)
-      return SZ_ERROR_MEM;
-    *blockIndex = folderIndex;
-    IAlloc_Free(allocMain, *outBuffer);
-    *outBuffer = 0;
-    
-    RINOK(inStream-&gt;Seek(inStream, startOffset, SZ_SEEK_SET));
-    
-    if (res == SZ_OK)
-    {
-      *outBufferSize = unpackSize;
-      if (unpackSize != 0)
-      {
-        *outBuffer = (Byte *)IAlloc_Alloc(allocMain, unpackSize);
-        if (*outBuffer == 0)
-          res = SZ_ERROR_MEM;
-      }
-      if (res == SZ_OK)
-      {
-        res = SzDecode(p-&gt;db.PackSizes +
-          p-&gt;FolderStartPackStreamIndex[folderIndex], folder,
-          inStream, startOffset,
-          *outBuffer, unpackSize, allocTemp);
-        if (res == SZ_OK)
-        {
-          if (folder-&gt;UnpackCRCDefined)
-          {
-            if (CrcCalc(*outBuffer, unpackSize) != folder-&gt;UnpackCRC)
-              res = SZ_ERROR_CRC;
-          }
-        }
-      }
-    }
-  }
-  if (res == SZ_OK)
-  {
-    UInt32 i;
-    CSzFileItem *fileItem = p-&gt;db.Files + fileIndex;
-    *offset = 0;
-    for (i = p-&gt;FolderStartFileIndex[folderIndex]; i &lt; fileIndex; i++)
-      *offset += (UInt32)p-&gt;db.Files[i].Size;
-    *outSizeProcessed = (size_t)fileItem-&gt;Size;
-    if (*offset + *outSizeProcessed &gt; *outBufferSize)
-      return SZ_ERROR_FAIL;
-    {
-      if (fileItem-&gt;FileCRCDefined)
-      {
-        if (CrcCalc(*outBuffer + *offset, *outSizeProcessed) != fileItem-&gt;FileCRC)
-          res = SZ_ERROR_CRC;
-      }
-    }
-  }
-  return res;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,96 @@
+/* 7zExtract.c -- Extracting from 7z archive
+2008-08-17
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zExtract.h for license options */
+
+#include &quot;7zExtract.h&quot;
+#include &quot;7zDecode.h&quot;
+#include &quot;../../7zCrc.h&quot;
+
+SRes SzAr_Extract(
+    const CSzArEx *p,
+    ISzInStream *inStream,
+    UInt32 fileIndex,
+    UInt32 *blockIndex,
+    Byte **outBuffer,
+    size_t *outBufferSize,
+    size_t *offset,
+    size_t *outSizeProcessed,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt32 folderIndex = p-&gt;FileIndexToFolderIndexMap[fileIndex];
+  SRes res = SZ_OK;
+  *offset = 0;
+  *outSizeProcessed = 0;
+  if (folderIndex == (UInt32)-1)
+  {
+    IAlloc_Free(allocMain, *outBuffer);
+    *blockIndex = folderIndex;
+    *outBuffer = 0;
+    *outBufferSize = 0;
+    return SZ_OK;
+  }
+
+  if (*outBuffer == 0 || *blockIndex != folderIndex)
+  {
+    CSzFolder *folder = p-&gt;db.Folders + folderIndex;
+    CFileSize unpackSizeSpec = SzFolder_GetUnpackSize(folder);
+    size_t unpackSize = (size_t)unpackSizeSpec;
+    CFileSize startOffset = SzArEx_GetFolderStreamPos(p, folderIndex, 0);
+
+    if (unpackSize != unpackSizeSpec)
+      return SZ_ERROR_MEM;
+    *blockIndex = folderIndex;
+    IAlloc_Free(allocMain, *outBuffer);
+    *outBuffer = 0;
+    
+    RINOK(inStream-&gt;Seek(inStream, startOffset, SZ_SEEK_SET));
+    
+    if (res == SZ_OK)
+    {
+      *outBufferSize = unpackSize;
+      if (unpackSize != 0)
+      {
+        *outBuffer = (Byte *)IAlloc_Alloc(allocMain, unpackSize);
+        if (*outBuffer == 0)
+          res = SZ_ERROR_MEM;
+      }
+      if (res == SZ_OK)
+      {
+        res = SzDecode(p-&gt;db.PackSizes +
+          p-&gt;FolderStartPackStreamIndex[folderIndex], folder,
+          inStream, startOffset,
+          *outBuffer, unpackSize, allocTemp);
+        if (res == SZ_OK)
+        {
+          if (folder-&gt;UnpackCRCDefined)
+          {
+            if (CrcCalc(*outBuffer, unpackSize) != folder-&gt;UnpackCRC)
+              res = SZ_ERROR_CRC;
+          }
+        }
+      }
+    }
+  }
+  if (res == SZ_OK)
+  {
+    UInt32 i;
+    CSzFileItem *fileItem = p-&gt;db.Files + fileIndex;
+    *offset = 0;
+    for (i = p-&gt;FolderStartFileIndex[folderIndex]; i &lt; fileIndex; i++)
+      *offset += (UInt32)p-&gt;db.Files[i].Size;
+    *outSizeProcessed = (size_t)fileItem-&gt;Size;
+    if (*offset + *outSizeProcessed &gt; *outBufferSize)
+      return SZ_ERROR_FAIL;
+    {
+      if (fileItem-&gt;FileCRCDefined)
+      {
+        if (CrcCalc(*outBuffer + *offset, *outSizeProcessed) != fileItem-&gt;FileCRC)
+          res = SZ_ERROR_CRC;
+      }
+    }
+  }
+  return res;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,44 +0,0 @@
-/* 7zExtract.h -- Extracting from 7z archive
-2008-08-05
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zItem.h for license options */
-
-#ifndef __7Z_EXTRACT_H
-#define __7Z_EXTRACT_H
-
-#include &quot;7zIn.h&quot;
-
-/*
-  SzExtract extracts file from archive
-
-  *outBuffer must be 0 before first call for each new archive.
-
-  Extracting cache:
-    If you need to decompress more than one file, you can send
-    these values from previous call:
-      *blockIndex,
-      *outBuffer,
-      *outBufferSize
-    You can consider &quot;*outBuffer&quot; as cache of solid block. If your archive is solid,
-    it will increase decompression speed.
-  
-    If you use external function, you can declare these 3 cache variables
-    (blockIndex, outBuffer, outBufferSize) as static in that external function.
-    
-    Free *outBuffer and set *outBuffer to 0, if you want to flush cache.
-*/
-
-SRes SzAr_Extract(
-    const CSzArEx *db,
-    ISzInStream *inStream,
-    UInt32 fileIndex,         /* index of file */
-    UInt32 *blockIndex,       /* index of solid block */
-    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
-    size_t *outBufferSize,    /* buffer size for output buffer */
-    size_t *offset,           /* offset of stream for required file in *outBuffer */
-    size_t *outSizeProcessed, /* size of file in *outBuffer */
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zExtract.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,44 @@
+/* 7zExtract.h -- Extracting from 7z archive
+2008-08-05
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zItem.h for license options */
+
+#ifndef __7Z_EXTRACT_H
+#define __7Z_EXTRACT_H
+
+#include &quot;7zIn.h&quot;
+
+/*
+  SzExtract extracts file from archive
+
+  *outBuffer must be 0 before first call for each new archive.
+
+  Extracting cache:
+    If you need to decompress more than one file, you can send
+    these values from previous call:
+      *blockIndex,
+      *outBuffer,
+      *outBufferSize
+    You can consider &quot;*outBuffer&quot; as cache of solid block. If your archive is solid,
+    it will increase decompression speed.
+  
+    If you use external function, you can declare these 3 cache variables
+    (blockIndex, outBuffer, outBufferSize) as static in that external function.
+    
+    Free *outBuffer and set *outBuffer to 0, if you want to flush cache.
+*/
+
+SRes SzAr_Extract(
+    const CSzArEx *db,
+    ISzInStream *inStream,
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,9 +0,0 @@
-/*  7zHeader.c -- 7z Headers
-2008-04-09
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zHeader.h for license options */
-
-#include &quot;7zHeader.h&quot;
-
-Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,9 @@
+/*  7zHeader.c -- 7z Headers
+2008-04-09
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zHeader.h for license options */
+
+#include &quot;7zHeader.h&quot;
+
+Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,59 +0,0 @@
-/* 7zHeader.h -- 7z Headers
-2008-07-14
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaDec.h for license options */
-
-#ifndef __7Z_HEADER_H
-#define __7Z_HEADER_H
-
-#include &quot;../../Types.h&quot;
-
-#define k7zSignatureSize 6
-extern Byte k7zSignature[k7zSignatureSize];
-
-#define k7zMajorVersion 0
-
-#define k7zStartHeaderSize 0x20
-
-enum EIdEnum
-{
-  k7zIdEnd,
-    
-  k7zIdHeader,
-    
-  k7zIdArchiveProperties,
-    
-  k7zIdAdditionalStreamsInfo,
-  k7zIdMainStreamsInfo,
-  k7zIdFilesInfo,
-  
-  k7zIdPackInfo,
-  k7zIdUnpackInfo,
-  k7zIdSubStreamsInfo,
-  
-  k7zIdSize,
-  k7zIdCRC,
-  
-  k7zIdFolder,
-  
-  k7zIdCodersUnpackSize,
-  k7zIdNumUnpackStream,
-  
-  k7zIdEmptyStream,
-  k7zIdEmptyFile,
-  k7zIdAnti,
-  
-  k7zIdName,
-  k7zIdCTime,
-  k7zIdATime,
-  k7zIdMTime,
-  k7zIdWinAttributes,
-  k7zIdComment,
-  
-  k7zIdEncodedHeader,
-  
-  k7zIdStartPos,
-  k7zIdDummy
-};
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zHeader.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,59 @@
+/* 7zHeader.h -- 7z Headers
+2008-07-14
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaDec.h for license options */
+
+#ifndef __7Z_HEADER_H
+#define __7Z_HEADER_H
+
+#include &quot;../../Types.h&quot;
+
+#define k7zSignatureSize 6
+extern Byte k7zSignature[k7zSignatureSize];
+
+#define k7zMajorVersion 0
+
+#define k7zStartHeaderSize 0x20
+
+enum EIdEnum
+{
+  k7zIdEnd,
+    
+  k7zIdHeader,
+    
+  k7zIdArchiveProperties,
+    
+  k7zIdAdditionalStreamsInfo,
+  k7zIdMainStreamsInfo,
+  k7zIdFilesInfo,
+  
+  k7zIdPackInfo,
+  k7zIdUnpackInfo,
+  k7zIdSubStreamsInfo,
+  
+  k7zIdSize,
+  k7zIdCRC,
+  
+  k7zIdFolder,
+  
+  k7zIdCodersUnpackSize,
+  k7zIdNumUnpackStream,
+  
+  k7zIdEmptyStream,
+  k7zIdEmptyFile,
+  k7zIdAnti,
+  
+  k7zIdName,
+  k7zIdCTime,
+  k7zIdATime,
+  k7zIdMTime,
+  k7zIdWinAttributes,
+  k7zIdComment,
+  
+  k7zIdEncodedHeader,
+  
+  k7zIdStartPos,
+  k7zIdDummy
+};
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,1265 +0,0 @@
-/* 7zIn.c -- 7z Input functions
-2008-08-17
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zIn.h for license options */
-
-#include &quot;7zIn.h&quot;
-#include &quot;7zDecode.h&quot;
-#include &quot;../../7zCrc.h&quot;
-
-#define RINOM(x) { if ((x) == 0) return SZ_ERROR_MEM; }
-
-void SzArEx_Init(CSzArEx *p)
-{
-  SzAr_Init(&amp;p-&gt;db);
-  p-&gt;FolderStartPackStreamIndex = 0;
-  p-&gt;PackStreamStartPositions = 0;
-  p-&gt;FolderStartFileIndex = 0;
-  p-&gt;FileIndexToFolderIndexMap = 0;
-}
-
-void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc)
-{
-  IAlloc_Free(alloc, p-&gt;FolderStartPackStreamIndex);
-  IAlloc_Free(alloc, p-&gt;PackStreamStartPositions);
-  IAlloc_Free(alloc, p-&gt;FolderStartFileIndex);
-  IAlloc_Free(alloc, p-&gt;FileIndexToFolderIndexMap);
-  SzAr_Free(&amp;p-&gt;db, alloc);
-  SzArEx_Init(p);
-}
-
-/*
-CFileSize GetFolderPackStreamSize(int folderIndex, int streamIndex) const
-{
-  return PackSizes[FolderStartPackStreamIndex[folderIndex] + streamIndex];
-}
-
-CFileSize GetFilePackSize(int fileIndex) const
-{
-  int folderIndex = FileIndexToFolderIndexMap[fileIndex];
-  if (folderIndex &gt;= 0)
-  {
-    const CSzFolder &amp;folderInfo = Folders[folderIndex];
-    if (FolderStartFileIndex[folderIndex] == fileIndex)
-    return GetFolderFullPackSize(folderIndex);
-  }
-  return 0;
-}
-*/
-
-#define MY_ALLOC(T, p, size, alloc) { if ((size) == 0) p = 0; else \
-  if ((p = (T *)IAlloc_Alloc(alloc, (size) * sizeof(T))) == 0) return SZ_ERROR_MEM; }
-
-static SRes SzArEx_Fill(CSzArEx *p, ISzAlloc *alloc)
-{
-  UInt32 startPos = 0;
-  CFileSize startPosSize = 0;
-  UInt32 i;
-  UInt32 folderIndex = 0;
-  UInt32 indexInFolder = 0;
-  MY_ALLOC(UInt32, p-&gt;FolderStartPackStreamIndex, p-&gt;db.NumFolders, alloc);
-  for (i = 0; i &lt; p-&gt;db.NumFolders; i++)
-  {
-    p-&gt;FolderStartPackStreamIndex[i] = startPos;
-    startPos += p-&gt;db.Folders[i].NumPackStreams;
-  }
-
-  MY_ALLOC(CFileSize, p-&gt;PackStreamStartPositions, p-&gt;db.NumPackStreams, alloc);
-
-  for (i = 0; i &lt; p-&gt;db.NumPackStreams; i++)
-  {
-    p-&gt;PackStreamStartPositions[i] = startPosSize;
-    startPosSize += p-&gt;db.PackSizes[i];
-  }
-
-  MY_ALLOC(UInt32, p-&gt;FolderStartFileIndex, p-&gt;db.NumFolders, alloc);
-  MY_ALLOC(UInt32, p-&gt;FileIndexToFolderIndexMap, p-&gt;db.NumFiles, alloc);
-
-  for (i = 0; i &lt; p-&gt;db.NumFiles; i++)
-  {
-    CSzFileItem *file = p-&gt;db.Files + i;
-    int emptyStream = !file-&gt;HasStream;
-    if (emptyStream &amp;&amp; indexInFolder == 0)
-    {
-      p-&gt;FileIndexToFolderIndexMap[i] = (UInt32)-1;
-      continue;
-    }
-    if (indexInFolder == 0)
-    {
-      /*
-      v3.13 incorrectly worked with empty folders
-      v4.07: Loop for skipping empty folders
-      */
-      for (;;)
-      {
-        if (folderIndex &gt;= p-&gt;db.NumFolders)
-          return SZ_ERROR_ARCHIVE;
-        p-&gt;FolderStartFileIndex[folderIndex] = i;
-        if (p-&gt;db.Folders[folderIndex].NumUnpackStreams != 0)
-          break;
-        folderIndex++;
-      }
-    }
-    p-&gt;FileIndexToFolderIndexMap[i] = folderIndex;
-    if (emptyStream)
-      continue;
-    indexInFolder++;
-    if (indexInFolder &gt;= p-&gt;db.Folders[folderIndex].NumUnpackStreams)
-    {
-      folderIndex++;
-      indexInFolder = 0;
-    }
-  }
-  return SZ_OK;
-}
-
-
-CFileSize SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder)
-{
-  return p-&gt;ArchiveInfo.DataStartPosition +
-    p-&gt;PackStreamStartPositions[p-&gt;FolderStartPackStreamIndex[folderIndex] + indexInFolder];
-}
-
-int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, CFileSize *resSize)
-{
-  UInt32 packStreamIndex = p-&gt;FolderStartPackStreamIndex[folderIndex];
-  CSzFolder *folder = p-&gt;db.Folders + folderIndex;
-  CFileSize size = 0;
-  UInt32 i;
-  for (i = 0; i &lt; folder-&gt;NumPackStreams; i++)
-  {
-    CFileSize t = size + p-&gt;db.PackSizes[packStreamIndex + i];
-    if (t &lt; size) // check it
-      return SZ_ERROR_FAIL;
-    size = t;
-  }
-  *resSize = size;
-  return SZ_OK;
-}
-
-
-/*
-SRes SzReadTime(const CObjectVector&lt;CBuf&gt; &amp;dataVector,
-    CObjectVector&lt;CSzFileItem&gt; &amp;files, UInt64 type)
-{
-  CBoolVector boolVector;
-  RINOK(ReadBoolVector2(files.Size(), boolVector))
-
-  CStreamSwitch streamSwitch;
-  RINOK(streamSwitch.Set(this, &amp;dataVector));
-
-  for (int i = 0; i &lt; files.Size(); i++)
-  {
-    CSzFileItem &amp;file = files[i];
-    CArchiveFileTime fileTime;
-    bool defined = boolVector[i];
-    if (defined)
-    {
-      UInt32 low, high;
-      RINOK(SzReadUInt32(low));
-      RINOK(SzReadUInt32(high));
-      fileTime.dwLowDateTime = low;
-      fileTime.dwHighDateTime = high;
-    }
-    switch(type)
-    {
-      case k7zIdCTime: file.IsCTimeDefined = defined; if (defined) file.CTime = fileTime; break;
-      case k7zIdATime: file.IsATimeDefined = defined; if (defined) file.ATime = fileTime; break;
-      case k7zIdMTime: file.IsMTimeDefined = defined; if (defined) file.MTime = fileTime; break;
-    }
-  }
-  return SZ_OK;
-}
-*/
-
-static SRes SafeReadDirect(ISzInStream *inStream, Byte *data, size_t size)
-{
-  while (size &gt; 0)
-  {
-    void *inBufferSpec;
-    size_t processedSize = size;
-    const Byte *inBuffer;
-    RINOK(inStream-&gt;Read(inStream, (void **)&amp;inBufferSpec, &amp;processedSize));
-    inBuffer = (const Byte *)inBufferSpec;
-    if (processedSize == 0)
-      return SZ_ERROR_INPUT_EOF;
-    size -= processedSize;
-    do
-      *data++ = *inBuffer++;
-    while (--processedSize != 0);
-  }
-  return SZ_OK;
-}
-
-static SRes SafeReadDirectByte(ISzInStream *inStream, Byte *data)
-{
-  return SafeReadDirect(inStream, data, 1);
-}
-
-static SRes SafeReadDirectUInt32(ISzInStream *inStream, UInt32 *value, UInt32 *crc)
-{
-  int i;
-  *value = 0;
-  for (i = 0; i &lt; 4; i++)
-  {
-    Byte b;
-    RINOK(SafeReadDirectByte(inStream, &amp;b));
-    *value |= ((UInt32)b &lt;&lt; (8 * i));
-    *crc = CRC_UPDATE_BYTE(*crc, b);
-  }
-  return SZ_OK;
-}
-
-static SRes SafeReadDirectUInt64(ISzInStream *inStream, UInt64 *value, UInt32 *crc)
-{
-  int i;
-  *value = 0;
-  for (i = 0; i &lt; 8; i++)
-  {
-    Byte b;
-    RINOK(SafeReadDirectByte(inStream, &amp;b));
-    *value |= ((UInt64)b &lt;&lt; (8 * i));
-    *crc = CRC_UPDATE_BYTE(*crc, b);
-  }
-  return SZ_OK;
-}
-
-static int TestSignatureCandidate(Byte *testBytes)
-{
-  size_t i;
-  for (i = 0; i &lt; k7zSignatureSize; i++)
-    if (testBytes[i] != k7zSignature[i])
-      return 0;
-  return 1;
-}
-
-typedef struct _CSzState
-{
-  Byte *Data;
-  size_t Size;
-}CSzData;
-
-static SRes SzReadByte(CSzData *sd, Byte *b)
-{
-  if (sd-&gt;Size == 0)
-    return SZ_ERROR_ARCHIVE;
-  sd-&gt;Size--;
-  *b = *sd-&gt;Data++;
-  return SZ_OK;
-}
-
-static SRes SzReadBytes(CSzData *sd, Byte *data, size_t size)
-{
-  size_t i;
-  for (i = 0; i &lt; size; i++)
-  {
-    RINOK(SzReadByte(sd, data + i));
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadUInt32(CSzData *sd, UInt32 *value)
-{
-  int i;
-  *value = 0;
-  for (i = 0; i &lt; 4; i++)
-  {
-    Byte b;
-    RINOK(SzReadByte(sd, &amp;b));
-    *value |= ((UInt32)(b) &lt;&lt; (8 * i));
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadNumber(CSzData *sd, UInt64 *value)
-{
-  Byte firstByte;
-  Byte mask = 0x80;
-  int i;
-  RINOK(SzReadByte(sd, &amp;firstByte));
-  *value = 0;
-  for (i = 0; i &lt; 8; i++)
-  {
-    Byte b;
-    if ((firstByte &amp; mask) == 0)
-    {
-      UInt64 highPart = firstByte &amp; (mask - 1);
-      *value += (highPart &lt;&lt; (8 * i));
-      return SZ_OK;
-    }
-    RINOK(SzReadByte(sd, &amp;b));
-    *value |= ((UInt64)b &lt;&lt; (8 * i));
-    mask &gt;&gt;= 1;
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadSize(CSzData *sd, CFileSize *value)
-{
-  UInt64 value64;
-  RINOK(SzReadNumber(sd, &amp;value64));
-  *value = (CFileSize)value64;
-  return SZ_OK;
-}
-
-static SRes SzReadNumber32(CSzData *sd, UInt32 *value)
-{
-  UInt64 value64;
-  RINOK(SzReadNumber(sd, &amp;value64));
-  if (value64 &gt;= 0x80000000)
-    return SZ_ERROR_UNSUPPORTED;
-  if (value64 &gt;= ((UInt64)(1) &lt;&lt; ((sizeof(size_t) - 1) * 8 + 2)))
-    return SZ_ERROR_UNSUPPORTED;
-  *value = (UInt32)value64;
-  return SZ_OK;
-}
-
-static SRes SzReadID(CSzData *sd, UInt64 *value)
-{
-  return SzReadNumber(sd, value);
-}
-
-static SRes SzSkeepDataSize(CSzData *sd, UInt64 size)
-{
-  if (size &gt; sd-&gt;Size)
-    return SZ_ERROR_ARCHIVE;
-  sd-&gt;Size -= (size_t)size;
-  sd-&gt;Data += (size_t)size;
-  return SZ_OK;
-}
-
-static SRes SzSkeepData(CSzData *sd)
-{
-  UInt64 size;
-  RINOK(SzReadNumber(sd, &amp;size));
-  return SzSkeepDataSize(sd, size);
-}
-
-static SRes SzReadArchiveProperties(CSzData *sd)
-{
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdEnd)
-      break;
-    SzSkeepData(sd);
-  }
-  return SZ_OK;
-}
-
-static SRes SzWaitAttribute(CSzData *sd, UInt64 attribute)
-{
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == attribute)
-      return SZ_OK;
-    if (type == k7zIdEnd)
-      return SZ_ERROR_ARCHIVE;
-    RINOK(SzSkeepData(sd));
-  }
-}
-
-static SRes SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
-{
-  Byte b = 0;
-  Byte mask = 0;
-  size_t i;
-  MY_ALLOC(Byte, *v, numItems, alloc);
-  for (i = 0; i &lt; numItems; i++)
-  {
-    if (mask == 0)
-    {
-      RINOK(SzReadByte(sd, &amp;b));
-      mask = 0x80;
-    }
-    (*v)[i] = (Byte)(((b &amp; mask) != 0) ? 1 : 0);
-    mask &gt;&gt;= 1;
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
-{
-  Byte allAreDefined;
-  size_t i;
-  RINOK(SzReadByte(sd, &amp;allAreDefined));
-  if (allAreDefined == 0)
-    return SzReadBoolVector(sd, numItems, v, alloc);
-  MY_ALLOC(Byte, *v, numItems, alloc);
-  for (i = 0; i &lt; numItems; i++)
-    (*v)[i] = 1;
-  return SZ_OK;
-}
-
-static SRes SzReadHashDigests(
-    CSzData *sd,
-    size_t numItems,
-    Byte **digestsDefined,
-    UInt32 **digests,
-    ISzAlloc *alloc)
-{
-  size_t i;
-  RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, alloc));
-  MY_ALLOC(UInt32, *digests, numItems, alloc);
-  for (i = 0; i &lt; numItems; i++)
-    if ((*digestsDefined)[i])
-    {
-      RINOK(SzReadUInt32(sd, (*digests) + i));
-    }
-  return SZ_OK;
-}
-
-static SRes SzReadPackInfo(
-    CSzData *sd,
-    CFileSize *dataOffset,
-    UInt32 *numPackStreams,
-    CFileSize **packSizes,
-    Byte **packCRCsDefined,
-    UInt32 **packCRCs,
-    ISzAlloc *alloc)
-{
-  UInt32 i;
-  RINOK(SzReadSize(sd, dataOffset));
-  RINOK(SzReadNumber32(sd, numPackStreams));
-
-  RINOK(SzWaitAttribute(sd, k7zIdSize));
-
-  MY_ALLOC(CFileSize, *packSizes, (size_t)*numPackStreams, alloc);
-
-  for (i = 0; i &lt; *numPackStreams; i++)
-  {
-    RINOK(SzReadSize(sd, (*packSizes) + i));
-  }
-
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdEnd)
-      break;
-    if (type == k7zIdCRC)
-    {
-      RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, alloc));
-      continue;
-    }
-    RINOK(SzSkeepData(sd));
-  }
-  if (*packCRCsDefined == 0)
-  {
-    MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, alloc);
-    MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);
-    for (i = 0; i &lt; *numPackStreams; i++)
-    {
-      (*packCRCsDefined)[i] = 0;
-      (*packCRCs)[i] = 0;
-    }
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadSwitch(CSzData *sd)
-{
-  Byte external;
-  RINOK(SzReadByte(sd, &amp;external));
-  return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;
-}
-
-static SRes SzGetNextFolderItem(CSzData *sd, CSzFolder *folder, ISzAlloc *alloc)
-{
-  UInt32 numCoders;
-  UInt32 numBindPairs;
-  UInt32 numPackedStreams;
-  UInt32 i;
-  UInt32 numInStreams = 0;
-  UInt32 numOutStreams = 0;
-  RINOK(SzReadNumber32(sd, &amp;numCoders));
-  folder-&gt;NumCoders = numCoders;
-
-  MY_ALLOC(CSzCoderInfo, folder-&gt;Coders, (size_t)numCoders, alloc);
-
-  for (i = 0; i &lt; numCoders; i++)
-    SzCoderInfo_Init(folder-&gt;Coders + i);
-
-  for (i = 0; i &lt; numCoders; i++)
-  {
-    Byte mainByte;
-    CSzCoderInfo *coder = folder-&gt;Coders + i;
-    {
-      unsigned idSize, j;
-      Byte longID[15];
-      RINOK(SzReadByte(sd, &amp;mainByte));
-      idSize = (unsigned)(mainByte &amp; 0xF);
-      RINOK(SzReadBytes(sd, longID, idSize));
-      if (idSize &gt; sizeof(coder-&gt;MethodID))
-        return SZ_ERROR_UNSUPPORTED;
-      coder-&gt;MethodID = 0;
-      for (j = 0; j &lt; idSize; j++)
-        coder-&gt;MethodID |= (CMethodID)longID[idSize - 1 - j] &lt;&lt; (8 * j);
-
-      if ((mainByte &amp; 0x10) != 0)
-      {
-        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumInStreams));
-        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumOutStreams));
-      }
-      else
-      {
-        coder-&gt;NumInStreams = 1;
-        coder-&gt;NumOutStreams = 1;
-      }
-      if ((mainByte &amp; 0x20) != 0)
-      {
-        UInt64 propertiesSize = 0;
-        RINOK(SzReadNumber(sd, &amp;propertiesSize));
-        if (!Buf_Create(&amp;coder-&gt;Props, (size_t)propertiesSize, alloc))
-          return SZ_ERROR_MEM;
-        RINOK(SzReadBytes(sd, coder-&gt;Props.data, (size_t)propertiesSize));
-      }
-    }
-    while ((mainByte &amp; 0x80) != 0)
-    {
-      RINOK(SzReadByte(sd, &amp;mainByte));
-      RINOK(SzSkeepDataSize(sd, (mainByte &amp; 0xF)));
-      if ((mainByte &amp; 0x10) != 0)
-      {
-        UInt32 n;
-        RINOK(SzReadNumber32(sd, &amp;n));
-        RINOK(SzReadNumber32(sd, &amp;n));
-      }
-      if ((mainByte &amp; 0x20) != 0)
-      {
-        UInt64 propertiesSize = 0;
-        RINOK(SzReadNumber(sd, &amp;propertiesSize));
-        RINOK(SzSkeepDataSize(sd, propertiesSize));
-      }
-    }
-    numInStreams += (UInt32)coder-&gt;NumInStreams;
-    numOutStreams += (UInt32)coder-&gt;NumOutStreams;
-  }
-
-  numBindPairs = numOutStreams - 1;
-  folder-&gt;NumBindPairs = numBindPairs;
-
-
-  MY_ALLOC(CBindPair, folder-&gt;BindPairs, (size_t)numBindPairs, alloc);
-
-  for (i = 0; i &lt; numBindPairs; i++)
-  {
-    CBindPair *bindPair = folder-&gt;BindPairs + i;;
-    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;InIndex));
-    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;OutIndex));
-  }
-
-  numPackedStreams = numInStreams - (UInt32)numBindPairs;
-
-  folder-&gt;NumPackStreams = numPackedStreams;
-  MY_ALLOC(UInt32, folder-&gt;PackStreams, (size_t)numPackedStreams, alloc);
-
-  if (numPackedStreams == 1)
-  {
-    UInt32 j;
-    UInt32 pi = 0;
-    for (j = 0; j &lt; numInStreams; j++)
-      if (SzFolder_FindBindPairForInStream(folder, j) &lt; 0)
-      {
-        folder-&gt;PackStreams[pi++] = j;
-        break;
-      }
-  }
-  else
-    for (i = 0; i &lt; numPackedStreams; i++)
-    {
-      RINOK(SzReadNumber32(sd, folder-&gt;PackStreams + i));
-    }
-  return SZ_OK;
-}
-
-static SRes SzReadUnpackInfo(
-    CSzData *sd,
-    UInt32 *numFolders,
-    CSzFolder **folders,  /* for alloc */
-    ISzAlloc *alloc,
-    ISzAlloc *allocTemp)
-{
-  UInt32 i;
-  RINOK(SzWaitAttribute(sd, k7zIdFolder));
-  RINOK(SzReadNumber32(sd, numFolders));
-  {
-    RINOK(SzReadSwitch(sd));
-
-    MY_ALLOC(CSzFolder, *folders, (size_t)*numFolders, alloc);
-
-    for (i = 0; i &lt; *numFolders; i++)
-      SzFolder_Init((*folders) + i);
-
-    for (i = 0; i &lt; *numFolders; i++)
-    {
-      RINOK(SzGetNextFolderItem(sd, (*folders) + i, alloc));
-    }
-  }
-
-  RINOK(SzWaitAttribute(sd, k7zIdCodersUnpackSize));
-
-  for (i = 0; i &lt; *numFolders; i++)
-  {
-    UInt32 j;
-    CSzFolder *folder = (*folders) + i;
-    UInt32 numOutStreams = SzFolder_GetNumOutStreams(folder);
-
-    MY_ALLOC(CFileSize, folder-&gt;UnpackSizes, (size_t)numOutStreams, alloc);
-
-    for (j = 0; j &lt; numOutStreams; j++)
-    {
-      RINOK(SzReadSize(sd, folder-&gt;UnpackSizes + j));
-    }
-  }
-
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdEnd)
-      return SZ_OK;
-    if (type == k7zIdCRC)
-    {
-      SRes res;
-      Byte *crcsDefined = 0;
-      UInt32 *crcs = 0;
-      res = SzReadHashDigests(sd, *numFolders, &amp;crcsDefined, &amp;crcs, allocTemp);
-      if (res == SZ_OK)
-      {
-        for (i = 0; i &lt; *numFolders; i++)
-        {
-          CSzFolder *folder = (*folders) + i;
-          folder-&gt;UnpackCRCDefined = crcsDefined[i];
-          folder-&gt;UnpackCRC = crcs[i];
-        }
-      }
-      IAlloc_Free(allocTemp, crcs);
-      IAlloc_Free(allocTemp, crcsDefined);
-      RINOK(res);
-      continue;
-    }
-    RINOK(SzSkeepData(sd));
-  }
-}
-
-static SRes SzReadSubStreamsInfo(
-    CSzData *sd,
-    UInt32 numFolders,
-    CSzFolder *folders,
-    UInt32 *numUnpackStreams,
-    CFileSize **unpackSizes,
-    Byte **digestsDefined,
-    UInt32 **digests,
-    ISzAlloc *allocTemp)
-{
-  UInt64 type = 0;
-  UInt32 i;
-  UInt32 si = 0;
-  UInt32 numDigests = 0;
-
-  for (i = 0; i &lt; numFolders; i++)
-    folders[i].NumUnpackStreams = 1;
-  *numUnpackStreams = numFolders;
-
-  for (;;)
-  {
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdNumUnpackStream)
-    {
-      *numUnpackStreams = 0;
-      for (i = 0; i &lt; numFolders; i++)
-      {
-        UInt32 numStreams;
-        RINOK(SzReadNumber32(sd, &amp;numStreams));
-        folders[i].NumUnpackStreams = numStreams;
-        *numUnpackStreams += numStreams;
-      }
-      continue;
-    }
-    if (type == k7zIdCRC || type == k7zIdSize)
-      break;
-    if (type == k7zIdEnd)
-      break;
-    RINOK(SzSkeepData(sd));
-  }
-
-  if (*numUnpackStreams == 0)
-  {
-    *unpackSizes = 0;
-    *digestsDefined = 0;
-    *digests = 0;
-  }
-  else
-  {
-    *unpackSizes = (CFileSize *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(CFileSize));
-    RINOM(*unpackSizes);
-    *digestsDefined = (Byte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(Byte));
-    RINOM(*digestsDefined);
-    *digests = (UInt32 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt32));
-    RINOM(*digests);
-  }
-
-  for (i = 0; i &lt; numFolders; i++)
-  {
-    /*
-    v3.13 incorrectly worked with empty folders
-    v4.07: we check that folder is empty
-    */
-    CFileSize sum = 0;
-    UInt32 j;
-    UInt32 numSubstreams = folders[i].NumUnpackStreams;
-    if (numSubstreams == 0)
-      continue;
-    if (type == k7zIdSize)
-    for (j = 1; j &lt; numSubstreams; j++)
-    {
-      CFileSize size;
-      RINOK(SzReadSize(sd, &amp;size));
-      (*unpackSizes)[si++] = size;
-      sum += size;
-    }
-    (*unpackSizes)[si++] = SzFolder_GetUnpackSize(folders + i) - sum;
-  }
-  if (type == k7zIdSize)
-  {
-    RINOK(SzReadID(sd, &amp;type));
-  }
-
-  for (i = 0; i &lt; *numUnpackStreams; i++)
-  {
-    (*digestsDefined)[i] = 0;
-    (*digests)[i] = 0;
-  }
-
-
-  for (i = 0; i &lt; numFolders; i++)
-  {
-    UInt32 numSubstreams = folders[i].NumUnpackStreams;
-    if (numSubstreams != 1 || !folders[i].UnpackCRCDefined)
-      numDigests += numSubstreams;
-  }
-
- 
-  si = 0;
-  for (;;)
-  {
-    if (type == k7zIdCRC)
-    {
-      int digestIndex = 0;
-      Byte *digestsDefined2 = 0;
-      UInt32 *digests2 = 0;
-      SRes res = SzReadHashDigests(sd, numDigests, &amp;digestsDefined2, &amp;digests2, allocTemp);
-      if (res == SZ_OK)
-      {
-        for (i = 0; i &lt; numFolders; i++)
-        {
-          CSzFolder *folder = folders + i;
-          UInt32 numSubstreams = folder-&gt;NumUnpackStreams;
-          if (numSubstreams == 1 &amp;&amp; folder-&gt;UnpackCRCDefined)
-          {
-            (*digestsDefined)[si] = 1;
-            (*digests)[si] = folder-&gt;UnpackCRC;
-            si++;
-          }
-          else
-          {
-            UInt32 j;
-            for (j = 0; j &lt; numSubstreams; j++, digestIndex++)
-            {
-              (*digestsDefined)[si] = digestsDefined2[digestIndex];
-              (*digests)[si] = digests2[digestIndex];
-              si++;
-            }
-          }
-        }
-      }
-      IAlloc_Free(allocTemp, digestsDefined2);
-      IAlloc_Free(allocTemp, digests2);
-      RINOK(res);
-    }
-    else if (type == k7zIdEnd)
-      return SZ_OK;
-    else
-    {
-      RINOK(SzSkeepData(sd));
-    }
-    RINOK(SzReadID(sd, &amp;type));
-  }
-}
-
-
-static SRes SzReadStreamsInfo(
-    CSzData *sd,
-    CFileSize *dataOffset,
-    CSzAr *p,
-    UInt32 *numUnpackStreams,
-    CFileSize **unpackSizes, /* allocTemp */
-    Byte **digestsDefined,   /* allocTemp */
-    UInt32 **digests,        /* allocTemp */
-    ISzAlloc *alloc,
-    ISzAlloc *allocTemp)
-{
-  for (;;)
-  {
-    UInt64 type;
-    RINOK(SzReadID(sd, &amp;type));
-    if ((UInt64)(int)type != type)
-      return SZ_ERROR_UNSUPPORTED;
-    switch((int)type)
-    {
-      case k7zIdEnd:
-        return SZ_OK;
-      case k7zIdPackInfo:
-      {
-        RINOK(SzReadPackInfo(sd, dataOffset, &amp;p-&gt;NumPackStreams,
-            &amp;p-&gt;PackSizes, &amp;p-&gt;PackCRCsDefined, &amp;p-&gt;PackCRCs, alloc));
-        break;
-      }
-      case k7zIdUnpackInfo:
-      {
-        RINOK(SzReadUnpackInfo(sd, &amp;p-&gt;NumFolders, &amp;p-&gt;Folders, alloc, allocTemp));
-        break;
-      }
-      case k7zIdSubStreamsInfo:
-      {
-        RINOK(SzReadSubStreamsInfo(sd, p-&gt;NumFolders, p-&gt;Folders,
-            numUnpackStreams, unpackSizes, digestsDefined, digests, allocTemp));
-        break;
-      }
-      default:
-        return SZ_ERROR_UNSUPPORTED;
-    }
-  }
-}
-
-Byte kUtf8Limits[5] = { 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
-
-static SRes SzReadFileNames(CSzData *sd, UInt32 numFiles, CSzFileItem *files, ISzAlloc *alloc)
-{
-  UInt32 i;
-  for (i = 0; i &lt; numFiles; i++)
-  {
-    UInt32 len = 0;
-    UInt32 pos = 0;
-    CSzFileItem *file = files + i;
-    while (pos + 2 &lt;= sd-&gt;Size)
-    {
-      int numAdds;
-      UInt32 value = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
-      pos += 2;
-      len++;
-      if (value == 0)
-        break;
-      if (value &lt; 0x80)
-        continue;
-      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
-      {
-        UInt32 c2;
-        if (value &gt;= 0xDC00)
-          return SZ_ERROR_ARCHIVE;
-        if (pos + 2 &gt; sd-&gt;Size)
-          return SZ_ERROR_ARCHIVE;
-        c2 = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
-        pos += 2;
-        if (c2 &lt; 0xDC00 || c2 &gt;= 0xE000)
-          return SZ_ERROR_ARCHIVE;
-        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
-      }
-      for (numAdds = 1; numAdds &lt; 5; numAdds++)
-        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
-          break;
-      len += numAdds;
-    }
-
-    MY_ALLOC(char, file-&gt;Name, (size_t)len, alloc);
-
-    len = 0;
-    while (2 &lt;= sd-&gt;Size)
-    {
-      int numAdds;
-      UInt32 value = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
-      SzSkeepDataSize(sd, 2);
-      if (value &lt; 0x80)
-      {
-        file-&gt;Name[len++] = (char)value;
-        if (value == 0)
-          break;
-        continue;
-      }
-      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
-      {
-        UInt32 c2 = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
-        SzSkeepDataSize(sd, 2);
-        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
-      }
-      for (numAdds = 1; numAdds &lt; 5; numAdds++)
-        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
-          break;
-      file-&gt;Name[len++] = (char)(kUtf8Limits[numAdds - 1] + (value &gt;&gt; (6 * numAdds)));
-      do
-      {
-        numAdds--;
-        file-&gt;Name[len++] = (char)(0x80 + ((value &gt;&gt; (6 * numAdds)) &amp; 0x3F));
-      }
-      while (numAdds &gt; 0);
-
-      len += numAdds;
-    }
-  }
-  return SZ_OK;
-}
-
-static SRes SzReadHeader2(
-    CSzArEx *p,   /* allocMain */
-    CSzData *sd,
-    CFileSize **unpackSizes,  /* allocTemp */
-    Byte **digestsDefined,    /* allocTemp */
-    UInt32 **digests,         /* allocTemp */
-    Byte **emptyStreamVector, /* allocTemp */
-    Byte **emptyFileVector,   /* allocTemp */
-    Byte **lwtVector,         /* allocTemp */
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp)
-{
-  UInt64 type;
-  UInt32 numUnpackStreams = 0;
-  UInt32 numFiles = 0;
-  CSzFileItem *files = 0;
-  UInt32 numEmptyStreams = 0;
-  UInt32 i;
-
-  RINOK(SzReadID(sd, &amp;type));
-
-  if (type == k7zIdArchiveProperties)
-  {
-    RINOK(SzReadArchiveProperties(sd));
-    RINOK(SzReadID(sd, &amp;type));
-  }
- 
- 
-  if (type == k7zIdMainStreamsInfo)
-  {
-    RINOK(SzReadStreamsInfo(sd,
-        &amp;p-&gt;ArchiveInfo.DataStartPosition,
-        &amp;p-&gt;db,
-        &amp;numUnpackStreams,
-        unpackSizes,
-        digestsDefined,
-        digests, allocMain, allocTemp));
-    p-&gt;ArchiveInfo.DataStartPosition += p-&gt;ArchiveInfo.StartPositionAfterHeader;
-    RINOK(SzReadID(sd, &amp;type));
-  }
-
-  if (type == k7zIdEnd)
-    return SZ_OK;
-  if (type != k7zIdFilesInfo)
-    return SZ_ERROR_ARCHIVE;
-  
-  RINOK(SzReadNumber32(sd, &amp;numFiles));
-  p-&gt;db.NumFiles = numFiles;
-
-  MY_ALLOC(CSzFileItem, files, (size_t)numFiles, allocMain);
-
-  p-&gt;db.Files = files;
-  for (i = 0; i &lt; numFiles; i++)
-    SzFile_Init(files + i);
-
-  for (;;)
-  {
-    UInt64 type;
-    UInt64 size;
-    RINOK(SzReadID(sd, &amp;type));
-    if (type == k7zIdEnd)
-      break;
-    RINOK(SzReadNumber(sd, &amp;size));
-
-    if ((UInt64)(int)type != type)
-    {
-      RINOK(SzSkeepDataSize(sd, size));
-    }
-    else
-    switch((int)type)
-    {
-      case k7zIdName:
-      {
-        RINOK(SzReadSwitch(sd));
-        RINOK(SzReadFileNames(sd, numFiles, files, allocMain))
-        break;
-      }
-      case k7zIdEmptyStream:
-      {
-        RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp));
-        numEmptyStreams = 0;
-        for (i = 0; i &lt; numFiles; i++)
-          if ((*emptyStreamVector)[i])
-            numEmptyStreams++;
-        break;
-      }
-      case k7zIdEmptyFile:
-      {
-        RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp));
-        break;
-      }
-      case k7zIdMTime:
-      {
-        RINOK(SzReadBoolVector2(sd, numFiles, lwtVector, allocTemp));
-        RINOK(SzReadSwitch(sd));
-        for (i = 0; i &lt; numFiles; i++)
-        {
-          CSzFileItem *f = &amp;files[i];
-          Byte defined = (*lwtVector)[i];
-          f-&gt;MTimeDefined = defined;
-          f-&gt;MTime.Low = f-&gt;MTime.High = 0;
-          if (defined)
-          {
-            RINOK(SzReadUInt32(sd, &amp;f-&gt;MTime.Low));
-            RINOK(SzReadUInt32(sd, &amp;f-&gt;MTime.High));
-          }
-        }
-        break;
-      }
-      default:
-      {
-        RINOK(SzSkeepDataSize(sd, size));
-      }
-    }
-  }
-
-  {
-    UInt32 emptyFileIndex = 0;
-    UInt32 sizeIndex = 0;
-    for (i = 0; i &lt; numFiles; i++)
-    {
-      CSzFileItem *file = files + i;
-      file-&gt;IsAnti = 0;
-      if (*emptyStreamVector == 0)
-        file-&gt;HasStream = 1;
-      else
-        file-&gt;HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
-      if (file-&gt;HasStream)
-      {
-        file-&gt;IsDir = 0;
-        file-&gt;Size = (*unpackSizes)[sizeIndex];
-        file-&gt;FileCRC = (*digests)[sizeIndex];
-        file-&gt;FileCRCDefined = (Byte)(*digestsDefined)[sizeIndex];
-        sizeIndex++;
-      }
-      else
-      {
-        if (*emptyFileVector == 0)
-          file-&gt;IsDir = 1;
-        else
-          file-&gt;IsDir = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
-        emptyFileIndex++;
-        file-&gt;Size = 0;
-        file-&gt;FileCRCDefined = 0;
-      }
-    }
-  }
-  return SzArEx_Fill(p, allocMain);
-}
-
-static SRes SzReadHeader(
-    CSzArEx *p,
-    CSzData *sd,
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp)
-{
-  CFileSize *unpackSizes = 0;
-  Byte *digestsDefined = 0;
-  UInt32 *digests = 0;
-  Byte *emptyStreamVector = 0;
-  Byte *emptyFileVector = 0;
-  Byte *lwtVector = 0;
-  SRes res = SzReadHeader2(p, sd,
-      &amp;unpackSizes, &amp;digestsDefined, &amp;digests,
-      &amp;emptyStreamVector, &amp;emptyFileVector, &amp;lwtVector,
-      allocMain, allocTemp);
-  IAlloc_Free(allocTemp, unpackSizes);
-  IAlloc_Free(allocTemp, digestsDefined);
-  IAlloc_Free(allocTemp, digests);
-  IAlloc_Free(allocTemp, emptyStreamVector);
-  IAlloc_Free(allocTemp, emptyFileVector);
-  IAlloc_Free(allocTemp, lwtVector);
-  return res;
-}
-
-static SRes SzReadAndDecodePackedStreams2(
-    ISzInStream *inStream,
-    CSzData *sd,
-    CBuf *outBuffer,
-    CFileSize baseOffset,
-    CSzAr *p,
-    CFileSize **unpackSizes,
-    Byte **digestsDefined,
-    UInt32 **digests,
-    ISzAlloc *allocTemp)
-{
-
-  UInt32 numUnpackStreams = 0;
-  CFileSize dataStartPos;
-  CSzFolder *folder;
-  CFileSize unpackSize;
-  SRes res;
-
-  RINOK(SzReadStreamsInfo(sd, &amp;dataStartPos, p,
-      &amp;numUnpackStreams,  unpackSizes, digestsDefined, digests,
-      allocTemp, allocTemp));
-  
-  dataStartPos += baseOffset;
-  if (p-&gt;NumFolders != 1)
-    return SZ_ERROR_ARCHIVE;
-
-  folder = p-&gt;Folders;
-  unpackSize = SzFolder_GetUnpackSize(folder);
-  
-  RINOK(inStream-&gt;Seek(inStream, dataStartPos, SZ_SEEK_SET));
-
-  if (!Buf_Create(outBuffer, (size_t)unpackSize, allocTemp))
-    return SZ_ERROR_MEM;
-  
-  res = SzDecode(p-&gt;PackSizes, folder,
-          inStream, dataStartPos,
-          outBuffer-&gt;data, (size_t)unpackSize, allocTemp);
-  RINOK(res);
-  if (folder-&gt;UnpackCRCDefined)
-    if (CrcCalc(outBuffer-&gt;data, (size_t)unpackSize) != folder-&gt;UnpackCRC)
-      return SZ_ERROR_CRC;
-  return SZ_OK;
-}
-
-static SRes SzReadAndDecodePackedStreams(
-    ISzInStream *inStream,
-    CSzData *sd,
-    CBuf *outBuffer,
-    CFileSize baseOffset,
-    ISzAlloc *allocTemp)
-{
-  CSzAr p;
-  CFileSize *unpackSizes = 0;
-  Byte *digestsDefined = 0;
-  UInt32 *digests = 0;
-  SRes res;
-  SzAr_Init(&amp;p);
-  res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset,
-    &amp;p, &amp;unpackSizes, &amp;digestsDefined, &amp;digests,
-    allocTemp);
-  SzAr_Free(&amp;p, allocTemp);
-  IAlloc_Free(allocTemp, unpackSizes);
-  IAlloc_Free(allocTemp, digestsDefined);
-  IAlloc_Free(allocTemp, digests);
-  return res;
-}
-
-static SRes SzArEx_Open2(
-    CSzArEx *p,
-    ISzInStream *inStream,
-    ISzAlloc *allocMain,
-    ISzAlloc *allocTemp)
-{
-  Byte signature[k7zSignatureSize];
-  Byte version;
-  UInt32 crcFromArchive;
-  UInt64 nextHeaderOffset;
-  UInt64 nextHeaderSize;
-  UInt32 nextHeaderCRC;
-  UInt32 crc = 0;
-  CFileSize pos = 0;
-  CBuf buffer;
-  CSzData sd;
-  SRes res;
-
-  if (SafeReadDirect(inStream, signature, k7zSignatureSize) != SZ_OK)
-    return SZ_ERROR_NO_ARCHIVE;
-
-  if (!TestSignatureCandidate(signature))
-    return SZ_ERROR_NO_ARCHIVE;
-
-  /*
-  p.Clear();
-  p.ArchiveInfo.StartPosition = _arhiveBeginStreamPosition;
-  */
-  RINOK(SafeReadDirectByte(inStream, &amp;version));
-  if (version != k7zMajorVersion)
-    return SZ_ERROR_UNSUPPORTED;
-  RINOK(SafeReadDirectByte(inStream, &amp;version));
-
-  RINOK(SafeReadDirectUInt32(inStream, &amp;crcFromArchive, &amp;crc));
-
-  crc = CRC_INIT_VAL;
-  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderOffset, &amp;crc));
-  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderSize, &amp;crc));
-  RINOK(SafeReadDirectUInt32(inStream, &amp;nextHeaderCRC, &amp;crc));
-
-  pos = k7zStartHeaderSize;
-  p-&gt;ArchiveInfo.StartPositionAfterHeader = pos;
-  
-  if (CRC_GET_DIGEST(crc) != crcFromArchive)
-    return SZ_ERROR_CRC;
-
-  if (nextHeaderSize == 0)
-    return SZ_OK;
-
-  RINOK(inStream-&gt;Seek(inStream, (CFileSize)(pos + nextHeaderOffset), SZ_SEEK_SET));
-
-  if (!Buf_Create(&amp;buffer, (size_t)nextHeaderSize, allocTemp))
-    return SZ_ERROR_MEM;
-
-  res = SafeReadDirect(inStream, buffer.data, (size_t)nextHeaderSize);
-  if (res == SZ_OK)
-  {
-    res = SZ_ERROR_ARCHIVE;
-    if (CrcCalc(buffer.data, (size_t)nextHeaderSize) == nextHeaderCRC)
-    {
-      for (;;)
-      {
-        UInt64 type;
-        sd.Data = buffer.data;
-        sd.Size = buffer.size;
-        res = SzReadID(&amp;sd, &amp;type);
-        if (res != SZ_OK)
-          break;
-        if (type == k7zIdHeader)
-        {
-          res = SzReadHeader(p, &amp;sd, allocMain, allocTemp);
-          break;
-        }
-        if (type != k7zIdEncodedHeader)
-        {
-          res = SZ_ERROR_UNSUPPORTED;
-          break;
-        }
-        {
-          CBuf outBuffer;
-          Buf_Init(&amp;outBuffer);
-          res = SzReadAndDecodePackedStreams(inStream, &amp;sd, &amp;outBuffer,
-              p-&gt;ArchiveInfo.StartPositionAfterHeader,
-              allocTemp);
-          if (res != SZ_OK)
-          {
-            Buf_Free(&amp;outBuffer, allocTemp);
-            break;
-          }
-          Buf_Free(&amp;buffer, allocTemp);
-          buffer.data = outBuffer.data;
-          buffer.size = outBuffer.size;
-        }
-      }
-    }
-  }
-  Buf_Free(&amp;buffer, allocTemp);
-  return res;
-}
-
-SRes SzArEx_Open(CSzArEx *p, ISzInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp)
-{
-  SRes res = SzArEx_Open2(p, inStream, allocMain, allocTemp);
-  if (res != SZ_OK)
-    SzArEx_Free(p, allocMain);
-  return res;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,1265 @@
+/* 7zIn.c -- 7z Input functions
+2008-08-17
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zIn.h for license options */
+
+#include &quot;7zIn.h&quot;
+#include &quot;7zDecode.h&quot;
+#include &quot;../../7zCrc.h&quot;
+
+#define RINOM(x) { if ((x) == 0) return SZ_ERROR_MEM; }
+
+void SzArEx_Init(CSzArEx *p)
+{
+  SzAr_Init(&amp;p-&gt;db);
+  p-&gt;FolderStartPackStreamIndex = 0;
+  p-&gt;PackStreamStartPositions = 0;
+  p-&gt;FolderStartFileIndex = 0;
+  p-&gt;FileIndexToFolderIndexMap = 0;
+}
+
+void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc)
+{
+  IAlloc_Free(alloc, p-&gt;FolderStartPackStreamIndex);
+  IAlloc_Free(alloc, p-&gt;PackStreamStartPositions);
+  IAlloc_Free(alloc, p-&gt;FolderStartFileIndex);
+  IAlloc_Free(alloc, p-&gt;FileIndexToFolderIndexMap);
+  SzAr_Free(&amp;p-&gt;db, alloc);
+  SzArEx_Init(p);
+}
+
+/*
+CFileSize GetFolderPackStreamSize(int folderIndex, int streamIndex) const
+{
+  return PackSizes[FolderStartPackStreamIndex[folderIndex] + streamIndex];
+}
+
+CFileSize GetFilePackSize(int fileIndex) const
+{
+  int folderIndex = FileIndexToFolderIndexMap[fileIndex];
+  if (folderIndex &gt;= 0)
+  {
+    const CSzFolder &amp;folderInfo = Folders[folderIndex];
+    if (FolderStartFileIndex[folderIndex] == fileIndex)
+    return GetFolderFullPackSize(folderIndex);
+  }
+  return 0;
+}
+*/
+
+#define MY_ALLOC(T, p, size, alloc) { if ((size) == 0) p = 0; else \
+  if ((p = (T *)IAlloc_Alloc(alloc, (size) * sizeof(T))) == 0) return SZ_ERROR_MEM; }
+
+static SRes SzArEx_Fill(CSzArEx *p, ISzAlloc *alloc)
+{
+  UInt32 startPos = 0;
+  CFileSize startPosSize = 0;
+  UInt32 i;
+  UInt32 folderIndex = 0;
+  UInt32 indexInFolder = 0;
+  MY_ALLOC(UInt32, p-&gt;FolderStartPackStreamIndex, p-&gt;db.NumFolders, alloc);
+  for (i = 0; i &lt; p-&gt;db.NumFolders; i++)
+  {
+    p-&gt;FolderStartPackStreamIndex[i] = startPos;
+    startPos += p-&gt;db.Folders[i].NumPackStreams;
+  }
+
+  MY_ALLOC(CFileSize, p-&gt;PackStreamStartPositions, p-&gt;db.NumPackStreams, alloc);
+
+  for (i = 0; i &lt; p-&gt;db.NumPackStreams; i++)
+  {
+    p-&gt;PackStreamStartPositions[i] = startPosSize;
+    startPosSize += p-&gt;db.PackSizes[i];
+  }
+
+  MY_ALLOC(UInt32, p-&gt;FolderStartFileIndex, p-&gt;db.NumFolders, alloc);
+  MY_ALLOC(UInt32, p-&gt;FileIndexToFolderIndexMap, p-&gt;db.NumFiles, alloc);
+
+  for (i = 0; i &lt; p-&gt;db.NumFiles; i++)
+  {
+    CSzFileItem *file = p-&gt;db.Files + i;
+    int emptyStream = !file-&gt;HasStream;
+    if (emptyStream &amp;&amp; indexInFolder == 0)
+    {
+      p-&gt;FileIndexToFolderIndexMap[i] = (UInt32)-1;
+      continue;
+    }
+    if (indexInFolder == 0)
+    {
+      /*
+      v3.13 incorrectly worked with empty folders
+      v4.07: Loop for skipping empty folders
+      */
+      for (;;)
+      {
+        if (folderIndex &gt;= p-&gt;db.NumFolders)
+          return SZ_ERROR_ARCHIVE;
+        p-&gt;FolderStartFileIndex[folderIndex] = i;
+        if (p-&gt;db.Folders[folderIndex].NumUnpackStreams != 0)
+          break;
+        folderIndex++;
+      }
+    }
+    p-&gt;FileIndexToFolderIndexMap[i] = folderIndex;
+    if (emptyStream)
+      continue;
+    indexInFolder++;
+    if (indexInFolder &gt;= p-&gt;db.Folders[folderIndex].NumUnpackStreams)
+    {
+      folderIndex++;
+      indexInFolder = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+
+CFileSize SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder)
+{
+  return p-&gt;ArchiveInfo.DataStartPosition +
+    p-&gt;PackStreamStartPositions[p-&gt;FolderStartPackStreamIndex[folderIndex] + indexInFolder];
+}
+
+int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, CFileSize *resSize)
+{
+  UInt32 packStreamIndex = p-&gt;FolderStartPackStreamIndex[folderIndex];
+  CSzFolder *folder = p-&gt;db.Folders + folderIndex;
+  CFileSize size = 0;
+  UInt32 i;
+  for (i = 0; i &lt; folder-&gt;NumPackStreams; i++)
+  {
+    CFileSize t = size + p-&gt;db.PackSizes[packStreamIndex + i];
+    if (t &lt; size) // check it
+      return SZ_ERROR_FAIL;
+    size = t;
+  }
+  *resSize = size;
+  return SZ_OK;
+}
+
+
+/*
+SRes SzReadTime(const CObjectVector&lt;CBuf&gt; &amp;dataVector,
+    CObjectVector&lt;CSzFileItem&gt; &amp;files, UInt64 type)
+{
+  CBoolVector boolVector;
+  RINOK(ReadBoolVector2(files.Size(), boolVector))
+
+  CStreamSwitch streamSwitch;
+  RINOK(streamSwitch.Set(this, &amp;dataVector));
+
+  for (int i = 0; i &lt; files.Size(); i++)
+  {
+    CSzFileItem &amp;file = files[i];
+    CArchiveFileTime fileTime;
+    bool defined = boolVector[i];
+    if (defined)
+    {
+      UInt32 low, high;
+      RINOK(SzReadUInt32(low));
+      RINOK(SzReadUInt32(high));
+      fileTime.dwLowDateTime = low;
+      fileTime.dwHighDateTime = high;
+    }
+    switch(type)
+    {
+      case k7zIdCTime: file.IsCTimeDefined = defined; if (defined) file.CTime = fileTime; break;
+      case k7zIdATime: file.IsATimeDefined = defined; if (defined) file.ATime = fileTime; break;
+      case k7zIdMTime: file.IsMTimeDefined = defined; if (defined) file.MTime = fileTime; break;
+    }
+  }
+  return SZ_OK;
+}
+*/
+
+static SRes SafeReadDirect(ISzInStream *inStream, Byte *data, size_t size)
+{
+  while (size &gt; 0)
+  {
+    void *inBufferSpec;
+    size_t processedSize = size;
+    const Byte *inBuffer;
+    RINOK(inStream-&gt;Read(inStream, (void **)&amp;inBufferSpec, &amp;processedSize));
+    inBuffer = (const Byte *)inBufferSpec;
+    if (processedSize == 0)
+      return SZ_ERROR_INPUT_EOF;
+    size -= processedSize;
+    do
+      *data++ = *inBuffer++;
+    while (--processedSize != 0);
+  }
+  return SZ_OK;
+}
+
+static SRes SafeReadDirectByte(ISzInStream *inStream, Byte *data)
+{
+  return SafeReadDirect(inStream, data, 1);
+}
+
+static SRes SafeReadDirectUInt32(ISzInStream *inStream, UInt32 *value, UInt32 *crc)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 4; i++)
+  {
+    Byte b;
+    RINOK(SafeReadDirectByte(inStream, &amp;b));
+    *value |= ((UInt32)b &lt;&lt; (8 * i));
+    *crc = CRC_UPDATE_BYTE(*crc, b);
+  }
+  return SZ_OK;
+}
+
+static SRes SafeReadDirectUInt64(ISzInStream *inStream, UInt64 *value, UInt32 *crc)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 8; i++)
+  {
+    Byte b;
+    RINOK(SafeReadDirectByte(inStream, &amp;b));
+    *value |= ((UInt64)b &lt;&lt; (8 * i));
+    *crc = CRC_UPDATE_BYTE(*crc, b);
+  }
+  return SZ_OK;
+}
+
+static int TestSignatureCandidate(Byte *testBytes)
+{
+  size_t i;
+  for (i = 0; i &lt; k7zSignatureSize; i++)
+    if (testBytes[i] != k7zSignature[i])
+      return 0;
+  return 1;
+}
+
+typedef struct _CSzState
+{
+  Byte *Data;
+  size_t Size;
+}CSzData;
+
+static SRes SzReadByte(CSzData *sd, Byte *b)
+{
+  if (sd-&gt;Size == 0)
+    return SZ_ERROR_ARCHIVE;
+  sd-&gt;Size--;
+  *b = *sd-&gt;Data++;
+  return SZ_OK;
+}
+
+static SRes SzReadBytes(CSzData *sd, Byte *data, size_t size)
+{
+  size_t i;
+  for (i = 0; i &lt; size; i++)
+  {
+    RINOK(SzReadByte(sd, data + i));
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadUInt32(CSzData *sd, UInt32 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 4; i++)
+  {
+    Byte b;
+    RINOK(SzReadByte(sd, &amp;b));
+    *value |= ((UInt32)(b) &lt;&lt; (8 * i));
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadNumber(CSzData *sd, UInt64 *value)
+{
+  Byte firstByte;
+  Byte mask = 0x80;
+  int i;
+  RINOK(SzReadByte(sd, &amp;firstByte));
+  *value = 0;
+  for (i = 0; i &lt; 8; i++)
+  {
+    Byte b;
+    if ((firstByte &amp; mask) == 0)
+    {
+      UInt64 highPart = firstByte &amp; (mask - 1);
+      *value += (highPart &lt;&lt; (8 * i));
+      return SZ_OK;
+    }
+    RINOK(SzReadByte(sd, &amp;b));
+    *value |= ((UInt64)b &lt;&lt; (8 * i));
+    mask &gt;&gt;= 1;
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadSize(CSzData *sd, CFileSize *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &amp;value64));
+  *value = (CFileSize)value64;
+  return SZ_OK;
+}
+
+static SRes SzReadNumber32(CSzData *sd, UInt32 *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &amp;value64));
+  if (value64 &gt;= 0x80000000)
+    return SZ_ERROR_UNSUPPORTED;
+  if (value64 &gt;= ((UInt64)(1) &lt;&lt; ((sizeof(size_t) - 1) * 8 + 2)))
+    return SZ_ERROR_UNSUPPORTED;
+  *value = (UInt32)value64;
+  return SZ_OK;
+}
+
+static SRes SzReadID(CSzData *sd, UInt64 *value)
+{
+  return SzReadNumber(sd, value);
+}
+
+static SRes SzSkeepDataSize(CSzData *sd, UInt64 size)
+{
+  if (size &gt; sd-&gt;Size)
+    return SZ_ERROR_ARCHIVE;
+  sd-&gt;Size -= (size_t)size;
+  sd-&gt;Data += (size_t)size;
+  return SZ_OK;
+}
+
+static SRes SzSkeepData(CSzData *sd)
+{
+  UInt64 size;
+  RINOK(SzReadNumber(sd, &amp;size));
+  return SzSkeepDataSize(sd, size);
+}
+
+static SRes SzReadArchiveProperties(CSzData *sd)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    SzSkeepData(sd);
+  }
+  return SZ_OK;
+}
+
+static SRes SzWaitAttribute(CSzData *sd, UInt64 attribute)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == attribute)
+      return SZ_OK;
+    if (type == k7zIdEnd)
+      return SZ_ERROR_ARCHIVE;
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+static SRes SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+{
+  Byte b = 0;
+  Byte mask = 0;
+  size_t i;
+  MY_ALLOC(Byte, *v, numItems, alloc);
+  for (i = 0; i &lt; numItems; i++)
+  {
+    if (mask == 0)
+    {
+      RINOK(SzReadByte(sd, &amp;b));
+      mask = 0x80;
+    }
+    (*v)[i] = (Byte)(((b &amp; mask) != 0) ? 1 : 0);
+    mask &gt;&gt;= 1;
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+{
+  Byte allAreDefined;
+  size_t i;
+  RINOK(SzReadByte(sd, &amp;allAreDefined));
+  if (allAreDefined == 0)
+    return SzReadBoolVector(sd, numItems, v, alloc);
+  MY_ALLOC(Byte, *v, numItems, alloc);
+  for (i = 0; i &lt; numItems; i++)
+    (*v)[i] = 1;
+  return SZ_OK;
+}
+
+static SRes SzReadHashDigests(
+    CSzData *sd,
+    size_t numItems,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *alloc)
+{
+  size_t i;
+  RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, alloc));
+  MY_ALLOC(UInt32, *digests, numItems, alloc);
+  for (i = 0; i &lt; numItems; i++)
+    if ((*digestsDefined)[i])
+    {
+      RINOK(SzReadUInt32(sd, (*digests) + i));
+    }
+  return SZ_OK;
+}
+
+static SRes SzReadPackInfo(
+    CSzData *sd,
+    CFileSize *dataOffset,
+    UInt32 *numPackStreams,
+    CFileSize **packSizes,
+    Byte **packCRCsDefined,
+    UInt32 **packCRCs,
+    ISzAlloc *alloc)
+{
+  UInt32 i;
+  RINOK(SzReadSize(sd, dataOffset));
+  RINOK(SzReadNumber32(sd, numPackStreams));
+
+  RINOK(SzWaitAttribute(sd, k7zIdSize));
+
+  MY_ALLOC(CFileSize, *packSizes, (size_t)*numPackStreams, alloc);
+
+  for (i = 0; i &lt; *numPackStreams; i++)
+  {
+    RINOK(SzReadSize(sd, (*packSizes) + i));
+  }
+
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    if (type == k7zIdCRC)
+    {
+      RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, alloc));
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+  if (*packCRCsDefined == 0)
+  {
+    MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, alloc);
+    MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);
+    for (i = 0; i &lt; *numPackStreams; i++)
+    {
+      (*packCRCsDefined)[i] = 0;
+      (*packCRCs)[i] = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadSwitch(CSzData *sd)
+{
+  Byte external;
+  RINOK(SzReadByte(sd, &amp;external));
+  return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;
+}
+
+static SRes SzGetNextFolderItem(CSzData *sd, CSzFolder *folder, ISzAlloc *alloc)
+{
+  UInt32 numCoders;
+  UInt32 numBindPairs;
+  UInt32 numPackedStreams;
+  UInt32 i;
+  UInt32 numInStreams = 0;
+  UInt32 numOutStreams = 0;
+  RINOK(SzReadNumber32(sd, &amp;numCoders));
+  folder-&gt;NumCoders = numCoders;
+
+  MY_ALLOC(CSzCoderInfo, folder-&gt;Coders, (size_t)numCoders, alloc);
+
+  for (i = 0; i &lt; numCoders; i++)
+    SzCoderInfo_Init(folder-&gt;Coders + i);
+
+  for (i = 0; i &lt; numCoders; i++)
+  {
+    Byte mainByte;
+    CSzCoderInfo *coder = folder-&gt;Coders + i;
+    {
+      unsigned idSize, j;
+      Byte longID[15];
+      RINOK(SzReadByte(sd, &amp;mainByte));
+      idSize = (unsigned)(mainByte &amp; 0xF);
+      RINOK(SzReadBytes(sd, longID, idSize));
+      if (idSize &gt; sizeof(coder-&gt;MethodID))
+        return SZ_ERROR_UNSUPPORTED;
+      coder-&gt;MethodID = 0;
+      for (j = 0; j &lt; idSize; j++)
+        coder-&gt;MethodID |= (CMethodID)longID[idSize - 1 - j] &lt;&lt; (8 * j);
+
+      if ((mainByte &amp; 0x10) != 0)
+      {
+        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumInStreams));
+        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumOutStreams));
+      }
+      else
+      {
+        coder-&gt;NumInStreams = 1;
+        coder-&gt;NumOutStreams = 1;
+      }
+      if ((mainByte &amp; 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &amp;propertiesSize));
+        if (!Buf_Create(&amp;coder-&gt;Props, (size_t)propertiesSize, alloc))
+          return SZ_ERROR_MEM;
+        RINOK(SzReadBytes(sd, coder-&gt;Props.data, (size_t)propertiesSize));
+      }
+    }
+    while ((mainByte &amp; 0x80) != 0)
+    {
+      RINOK(SzReadByte(sd, &amp;mainByte));
+      RINOK(SzSkeepDataSize(sd, (mainByte &amp; 0xF)));
+      if ((mainByte &amp; 0x10) != 0)
+      {
+        UInt32 n;
+        RINOK(SzReadNumber32(sd, &amp;n));
+        RINOK(SzReadNumber32(sd, &amp;n));
+      }
+      if ((mainByte &amp; 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &amp;propertiesSize));
+        RINOK(SzSkeepDataSize(sd, propertiesSize));
+      }
+    }
+    numInStreams += (UInt32)coder-&gt;NumInStreams;
+    numOutStreams += (UInt32)coder-&gt;NumOutStreams;
+  }
+
+  numBindPairs = numOutStreams - 1;
+  folder-&gt;NumBindPairs = numBindPairs;
+
+
+  MY_ALLOC(CBindPair, folder-&gt;BindPairs, (size_t)numBindPairs, alloc);
+
+  for (i = 0; i &lt; numBindPairs; i++)
+  {
+    CBindPair *bindPair = folder-&gt;BindPairs + i;;
+    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;InIndex));
+    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;OutIndex));
+  }
+
+  numPackedStreams = numInStreams - (UInt32)numBindPairs;
+
+  folder-&gt;NumPackStreams = numPackedStreams;
+  MY_ALLOC(UInt32, folder-&gt;PackStreams, (size_t)numPackedStreams, alloc);
+
+  if (numPackedStreams == 1)
+  {
+    UInt32 j;
+    UInt32 pi = 0;
+    for (j = 0; j &lt; numInStreams; j++)
+      if (SzFolder_FindBindPairForInStream(folder, j) &lt; 0)
+      {
+        folder-&gt;PackStreams[pi++] = j;
+        break;
+      }
+  }
+  else
+    for (i = 0; i &lt; numPackedStreams; i++)
+    {
+      RINOK(SzReadNumber32(sd, folder-&gt;PackStreams + i));
+    }
+  return SZ_OK;
+}
+
+static SRes SzReadUnpackInfo(
+    CSzData *sd,
+    UInt32 *numFolders,
+    CSzFolder **folders,  /* for alloc */
+    ISzAlloc *alloc,
+    ISzAlloc *allocTemp)
+{
+  UInt32 i;
+  RINOK(SzWaitAttribute(sd, k7zIdFolder));
+  RINOK(SzReadNumber32(sd, numFolders));
+  {
+    RINOK(SzReadSwitch(sd));
+
+    MY_ALLOC(CSzFolder, *folders, (size_t)*numFolders, alloc);
+
+    for (i = 0; i &lt; *numFolders; i++)
+      SzFolder_Init((*folders) + i);
+
+    for (i = 0; i &lt; *numFolders; i++)
+    {
+      RINOK(SzGetNextFolderItem(sd, (*folders) + i, alloc));
+    }
+  }
+
+  RINOK(SzWaitAttribute(sd, k7zIdCodersUnpackSize));
+
+  for (i = 0; i &lt; *numFolders; i++)
+  {
+    UInt32 j;
+    CSzFolder *folder = (*folders) + i;
+    UInt32 numOutStreams = SzFolder_GetNumOutStreams(folder);
+
+    MY_ALLOC(CFileSize, folder-&gt;UnpackSizes, (size_t)numOutStreams, alloc);
+
+    for (j = 0; j &lt; numOutStreams; j++)
+    {
+      RINOK(SzReadSize(sd, folder-&gt;UnpackSizes + j));
+    }
+  }
+
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      return SZ_OK;
+    if (type == k7zIdCRC)
+    {
+      SRes res;
+      Byte *crcsDefined = 0;
+      UInt32 *crcs = 0;
+      res = SzReadHashDigests(sd, *numFolders, &amp;crcsDefined, &amp;crcs, allocTemp);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i &lt; *numFolders; i++)
+        {
+          CSzFolder *folder = (*folders) + i;
+          folder-&gt;UnpackCRCDefined = crcsDefined[i];
+          folder-&gt;UnpackCRC = crcs[i];
+        }
+      }
+      IAlloc_Free(allocTemp, crcs);
+      IAlloc_Free(allocTemp, crcsDefined);
+      RINOK(res);
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+static SRes SzReadSubStreamsInfo(
+    CSzData *sd,
+    UInt32 numFolders,
+    CSzFolder *folders,
+    UInt32 *numUnpackStreams,
+    CFileSize **unpackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type = 0;
+  UInt32 i;
+  UInt32 si = 0;
+  UInt32 numDigests = 0;
+
+  for (i = 0; i &lt; numFolders; i++)
+    folders[i].NumUnpackStreams = 1;
+  *numUnpackStreams = numFolders;
+
+  for (;;)
+  {
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdNumUnpackStream)
+    {
+      *numUnpackStreams = 0;
+      for (i = 0; i &lt; numFolders; i++)
+      {
+        UInt32 numStreams;
+        RINOK(SzReadNumber32(sd, &amp;numStreams));
+        folders[i].NumUnpackStreams = numStreams;
+        *numUnpackStreams += numStreams;
+      }
+      continue;
+    }
+    if (type == k7zIdCRC || type == k7zIdSize)
+      break;
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzSkeepData(sd));
+  }
+
+  if (*numUnpackStreams == 0)
+  {
+    *unpackSizes = 0;
+    *digestsDefined = 0;
+    *digests = 0;
+  }
+  else
+  {
+    *unpackSizes = (CFileSize *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(CFileSize));
+    RINOM(*unpackSizes);
+    *digestsDefined = (Byte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(Byte));
+    RINOM(*digestsDefined);
+    *digests = (UInt32 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt32));
+    RINOM(*digests);
+  }
+
+  for (i = 0; i &lt; numFolders; i++)
+  {
+    /*
+    v3.13 incorrectly worked with empty folders
+    v4.07: we check that folder is empty
+    */
+    CFileSize sum = 0;
+    UInt32 j;
+    UInt32 numSubstreams = folders[i].NumUnpackStreams;
+    if (numSubstreams == 0)
+      continue;
+    if (type == k7zIdSize)
+    for (j = 1; j &lt; numSubstreams; j++)
+    {
+      CFileSize size;
+      RINOK(SzReadSize(sd, &amp;size));
+      (*unpackSizes)[si++] = size;
+      sum += size;
+    }
+    (*unpackSizes)[si++] = SzFolder_GetUnpackSize(folders + i) - sum;
+  }
+  if (type == k7zIdSize)
+  {
+    RINOK(SzReadID(sd, &amp;type));
+  }
+
+  for (i = 0; i &lt; *numUnpackStreams; i++)
+  {
+    (*digestsDefined)[i] = 0;
+    (*digests)[i] = 0;
+  }
+
+
+  for (i = 0; i &lt; numFolders; i++)
+  {
+    UInt32 numSubstreams = folders[i].NumUnpackStreams;
+    if (numSubstreams != 1 || !folders[i].UnpackCRCDefined)
+      numDigests += numSubstreams;
+  }
+
+ 
+  si = 0;
+  for (;;)
+  {
+    if (type == k7zIdCRC)
+    {
+      int digestIndex = 0;
+      Byte *digestsDefined2 = 0;
+      UInt32 *digests2 = 0;
+      SRes res = SzReadHashDigests(sd, numDigests, &amp;digestsDefined2, &amp;digests2, allocTemp);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i &lt; numFolders; i++)
+        {
+          CSzFolder *folder = folders + i;
+          UInt32 numSubstreams = folder-&gt;NumUnpackStreams;
+          if (numSubstreams == 1 &amp;&amp; folder-&gt;UnpackCRCDefined)
+          {
+            (*digestsDefined)[si] = 1;
+            (*digests)[si] = folder-&gt;UnpackCRC;
+            si++;
+          }
+          else
+          {
+            UInt32 j;
+            for (j = 0; j &lt; numSubstreams; j++, digestIndex++)
+            {
+              (*digestsDefined)[si] = digestsDefined2[digestIndex];
+              (*digests)[si] = digests2[digestIndex];
+              si++;
+            }
+          }
+        }
+      }
+      IAlloc_Free(allocTemp, digestsDefined2);
+      IAlloc_Free(allocTemp, digests2);
+      RINOK(res);
+    }
+    else if (type == k7zIdEnd)
+      return SZ_OK;
+    else
+    {
+      RINOK(SzSkeepData(sd));
+    }
+    RINOK(SzReadID(sd, &amp;type));
+  }
+}
+
+
+static SRes SzReadStreamsInfo(
+    CSzData *sd,
+    CFileSize *dataOffset,
+    CSzAr *p,
+    UInt32 *numUnpackStreams,
+    CFileSize **unpackSizes, /* allocTemp */
+    Byte **digestsDefined,   /* allocTemp */
+    UInt32 **digests,        /* allocTemp */
+    ISzAlloc *alloc,
+    ISzAlloc *allocTemp)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if ((UInt64)(int)type != type)
+      return SZ_ERROR_UNSUPPORTED;
+    switch((int)type)
+    {
+      case k7zIdEnd:
+        return SZ_OK;
+      case k7zIdPackInfo:
+      {
+        RINOK(SzReadPackInfo(sd, dataOffset, &amp;p-&gt;NumPackStreams,
+            &amp;p-&gt;PackSizes, &amp;p-&gt;PackCRCsDefined, &amp;p-&gt;PackCRCs, alloc));
+        break;
+      }
+      case k7zIdUnpackInfo:
+      {
+        RINOK(SzReadUnpackInfo(sd, &amp;p-&gt;NumFolders, &amp;p-&gt;Folders, alloc, allocTemp));
+        break;
+      }
+      case k7zIdSubStreamsInfo:
+      {
+        RINOK(SzReadSubStreamsInfo(sd, p-&gt;NumFolders, p-&gt;Folders,
+            numUnpackStreams, unpackSizes, digestsDefined, digests, allocTemp));
+        break;
+      }
+      default:
+        return SZ_ERROR_UNSUPPORTED;
+    }
+  }
+}
+
+Byte kUtf8Limits[5] = { 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+static SRes SzReadFileNames(CSzData *sd, UInt32 numFiles, CSzFileItem *files, ISzAlloc *alloc)
+{
+  UInt32 i;
+  for (i = 0; i &lt; numFiles; i++)
+  {
+    UInt32 len = 0;
+    UInt32 pos = 0;
+    CSzFileItem *file = files + i;
+    while (pos + 2 &lt;= sd-&gt;Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
+      pos += 2;
+      len++;
+      if (value == 0)
+        break;
+      if (value &lt; 0x80)
+        continue;
+      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
+      {
+        UInt32 c2;
+        if (value &gt;= 0xDC00)
+          return SZ_ERROR_ARCHIVE;
+        if (pos + 2 &gt; sd-&gt;Size)
+          return SZ_ERROR_ARCHIVE;
+        c2 = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
+        pos += 2;
+        if (c2 &lt; 0xDC00 || c2 &gt;= 0xE000)
+          return SZ_ERROR_ARCHIVE;
+        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds &lt; 5; numAdds++)
+        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
+          break;
+      len += numAdds;
+    }
+
+    MY_ALLOC(char, file-&gt;Name, (size_t)len, alloc);
+
+    len = 0;
+    while (2 &lt;= sd-&gt;Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
+      SzSkeepDataSize(sd, 2);
+      if (value &lt; 0x80)
+      {
+        file-&gt;Name[len++] = (char)value;
+        if (value == 0)
+          break;
+        continue;
+      }
+      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
+      {
+        UInt32 c2 = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
+        SzSkeepDataSize(sd, 2);
+        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds &lt; 5; numAdds++)
+        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
+          break;
+      file-&gt;Name[len++] = (char)(kUtf8Limits[numAdds - 1] + (value &gt;&gt; (6 * numAdds)));
+      do
+      {
+        numAdds--;
+        file-&gt;Name[len++] = (char)(0x80 + ((value &gt;&gt; (6 * numAdds)) &amp; 0x3F));
+      }
+      while (numAdds &gt; 0);
+
+      len += numAdds;
+    }
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadHeader2(
+    CSzArEx *p,   /* allocMain */
+    CSzData *sd,
+    CFileSize **unpackSizes,  /* allocTemp */
+    Byte **digestsDefined,    /* allocTemp */
+    UInt32 **digests,         /* allocTemp */
+    Byte **emptyStreamVector, /* allocTemp */
+    Byte **emptyFileVector,   /* allocTemp */
+    Byte **lwtVector,         /* allocTemp */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type;
+  UInt32 numUnpackStreams = 0;
+  UInt32 numFiles = 0;
+  CSzFileItem *files = 0;
+  UInt32 numEmptyStreams = 0;
+  UInt32 i;
+
+  RINOK(SzReadID(sd, &amp;type));
+
+  if (type == k7zIdArchiveProperties)
+  {
+    RINOK(SzReadArchiveProperties(sd));
+    RINOK(SzReadID(sd, &amp;type));
+  }
+ 
+ 
+  if (type == k7zIdMainStreamsInfo)
+  {
+    RINOK(SzReadStreamsInfo(sd,
+        &amp;p-&gt;ArchiveInfo.DataStartPosition,
+        &amp;p-&gt;db,
+        &amp;numUnpackStreams,
+        unpackSizes,
+        digestsDefined,
+        digests, allocMain, allocTemp));
+    p-&gt;ArchiveInfo.DataStartPosition += p-&gt;ArchiveInfo.StartPositionAfterHeader;
+    RINOK(SzReadID(sd, &amp;type));
+  }
+
+  if (type == k7zIdEnd)
+    return SZ_OK;
+  if (type != k7zIdFilesInfo)
+    return SZ_ERROR_ARCHIVE;
+  
+  RINOK(SzReadNumber32(sd, &amp;numFiles));
+  p-&gt;db.NumFiles = numFiles;
+
+  MY_ALLOC(CSzFileItem, files, (size_t)numFiles, allocMain);
+
+  p-&gt;db.Files = files;
+  for (i = 0; i &lt; numFiles; i++)
+    SzFile_Init(files + i);
+
+  for (;;)
+  {
+    UInt64 type;
+    UInt64 size;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzReadNumber(sd, &amp;size));
+
+    if ((UInt64)(int)type != type)
+    {
+      RINOK(SzSkeepDataSize(sd, size));
+    }
+    else
+    switch((int)type)
+    {
+      case k7zIdName:
+      {
+        RINOK(SzReadSwitch(sd));
+        RINOK(SzReadFileNames(sd, numFiles, files, allocMain))
+        break;
+      }
+      case k7zIdEmptyStream:
+      {
+        RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp));
+        numEmptyStreams = 0;
+        for (i = 0; i &lt; numFiles; i++)
+          if ((*emptyStreamVector)[i])
+            numEmptyStreams++;
+        break;
+      }
+      case k7zIdEmptyFile:
+      {
+        RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp));
+        break;
+      }
+      case k7zIdMTime:
+      {
+        RINOK(SzReadBoolVector2(sd, numFiles, lwtVector, allocTemp));
+        RINOK(SzReadSwitch(sd));
+        for (i = 0; i &lt; numFiles; i++)
+        {
+          CSzFileItem *f = &amp;files[i];
+          Byte defined = (*lwtVector)[i];
+          f-&gt;MTimeDefined = defined;
+          f-&gt;MTime.Low = f-&gt;MTime.High = 0;
+          if (defined)
+          {
+            RINOK(SzReadUInt32(sd, &amp;f-&gt;MTime.Low));
+            RINOK(SzReadUInt32(sd, &amp;f-&gt;MTime.High));
+          }
+        }
+        break;
+      }
+      default:
+      {
+        RINOK(SzSkeepDataSize(sd, size));
+      }
+    }
+  }
+
+  {
+    UInt32 emptyFileIndex = 0;
+    UInt32 sizeIndex = 0;
+    for (i = 0; i &lt; numFiles; i++)
+    {
+      CSzFileItem *file = files + i;
+      file-&gt;IsAnti = 0;
+      if (*emptyStreamVector == 0)
+        file-&gt;HasStream = 1;
+      else
+        file-&gt;HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
+      if (file-&gt;HasStream)
+      {
+        file-&gt;IsDir = 0;
+        file-&gt;Size = (*unpackSizes)[sizeIndex];
+        file-&gt;FileCRC = (*digests)[sizeIndex];
+        file-&gt;FileCRCDefined = (Byte)(*digestsDefined)[sizeIndex];
+        sizeIndex++;
+      }
+      else
+      {
+        if (*emptyFileVector == 0)
+          file-&gt;IsDir = 1;
+        else
+          file-&gt;IsDir = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
+        emptyFileIndex++;
+        file-&gt;Size = 0;
+        file-&gt;FileCRCDefined = 0;
+      }
+    }
+  }
+  return SzArEx_Fill(p, allocMain);
+}
+
+static SRes SzReadHeader(
+    CSzArEx *p,
+    CSzData *sd,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  CFileSize *unpackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  Byte *emptyStreamVector = 0;
+  Byte *emptyFileVector = 0;
+  Byte *lwtVector = 0;
+  SRes res = SzReadHeader2(p, sd,
+      &amp;unpackSizes, &amp;digestsDefined, &amp;digests,
+      &amp;emptyStreamVector, &amp;emptyFileVector, &amp;lwtVector,
+      allocMain, allocTemp);
+  IAlloc_Free(allocTemp, unpackSizes);
+  IAlloc_Free(allocTemp, digestsDefined);
+  IAlloc_Free(allocTemp, digests);
+  IAlloc_Free(allocTemp, emptyStreamVector);
+  IAlloc_Free(allocTemp, emptyFileVector);
+  IAlloc_Free(allocTemp, lwtVector);
+  return res;
+}
+
+static SRes SzReadAndDecodePackedStreams2(
+    ISzInStream *inStream,
+    CSzData *sd,
+    CBuf *outBuffer,
+    CFileSize baseOffset,
+    CSzAr *p,
+    CFileSize **unpackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+
+  UInt32 numUnpackStreams = 0;
+  CFileSize dataStartPos;
+  CSzFolder *folder;
+  CFileSize unpackSize;
+  SRes res;
+
+  RINOK(SzReadStreamsInfo(sd, &amp;dataStartPos, p,
+      &amp;numUnpackStreams,  unpackSizes, digestsDefined, digests,
+      allocTemp, allocTemp));
+  
+  dataStartPos += baseOffset;
+  if (p-&gt;NumFolders != 1)
+    return SZ_ERROR_ARCHIVE;
+
+  folder = p-&gt;Folders;
+  unpackSize = SzFolder_GetUnpackSize(folder);
+  
+  RINOK(inStream-&gt;Seek(inStream, dataStartPos, SZ_SEEK_SET));
+
+  if (!Buf_Create(outBuffer, (size_t)unpackSize, allocTemp))
+    return SZ_ERROR_MEM;
+  
+  res = SzDecode(p-&gt;PackSizes, folder,
+          inStream, dataStartPos,
+          outBuffer-&gt;data, (size_t)unpackSize, allocTemp);
+  RINOK(res);
+  if (folder-&gt;UnpackCRCDefined)
+    if (CrcCalc(outBuffer-&gt;data, (size_t)unpackSize) != folder-&gt;UnpackCRC)
+      return SZ_ERROR_CRC;
+  return SZ_OK;
+}
+
+static SRes SzReadAndDecodePackedStreams(
+    ISzInStream *inStream,
+    CSzData *sd,
+    CBuf *outBuffer,
+    CFileSize baseOffset,
+    ISzAlloc *allocTemp)
+{
+  CSzAr p;
+  CFileSize *unpackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  SRes res;
+  SzAr_Init(&amp;p);
+  res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset,
+    &amp;p, &amp;unpackSizes, &amp;digestsDefined, &amp;digests,
+    allocTemp);
+  SzAr_Free(&amp;p, allocTemp);
+  IAlloc_Free(allocTemp, unpackSizes);
+  IAlloc_Free(allocTemp, digestsDefined);
+  IAlloc_Free(allocTemp, digests);
+  return res;
+}
+
+static SRes SzArEx_Open2(
+    CSzArEx *p,
+    ISzInStream *inStream,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  Byte signature[k7zSignatureSize];
+  Byte version;
+  UInt32 crcFromArchive;
+  UInt64 nextHeaderOffset;
+  UInt64 nextHeaderSize;
+  UInt32 nextHeaderCRC;
+  UInt32 crc = 0;
+  CFileSize pos = 0;
+  CBuf buffer;
+  CSzData sd;
+  SRes res;
+
+  if (SafeReadDirect(inStream, signature, k7zSignatureSize) != SZ_OK)
+    return SZ_ERROR_NO_ARCHIVE;
+
+  if (!TestSignatureCandidate(signature))
+    return SZ_ERROR_NO_ARCHIVE;
+
+  /*
+  p.Clear();
+  p.ArchiveInfo.StartPosition = _arhiveBeginStreamPosition;
+  */
+  RINOK(SafeReadDirectByte(inStream, &amp;version));
+  if (version != k7zMajorVersion)
+    return SZ_ERROR_UNSUPPORTED;
+  RINOK(SafeReadDirectByte(inStream, &amp;version));
+
+  RINOK(SafeReadDirectUInt32(inStream, &amp;crcFromArchive, &amp;crc));
+
+  crc = CRC_INIT_VAL;
+  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderOffset, &amp;crc));
+  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderSize, &amp;crc));
+  RINOK(SafeReadDirectUInt32(inStream, &amp;nextHeaderCRC, &amp;crc));
+
+  pos = k7zStartHeaderSize;
+  p-&gt;ArchiveInfo.StartPositionAfterHeader = pos;
+  
+  if (CRC_GET_DIGEST(crc) != crcFromArchive)
+    return SZ_ERROR_CRC;
+
+  if (nextHeaderSize == 0)
+    return SZ_OK;
+
+  RINOK(inStream-&gt;Seek(inStream, (CFileSize)(pos + nextHeaderOffset), SZ_SEEK_SET));
+
+  if (!Buf_Create(&amp;buffer, (size_t)nextHeaderSize, allocTemp))
+    return SZ_ERROR_MEM;
+
+  res = SafeReadDirect(inStream, buffer.data, (size_t)nextHeaderSize);
+  if (res == SZ_OK)
+  {
+    res = SZ_ERROR_ARCHIVE;
+    if (CrcCalc(buffer.data, (size_t)nextHeaderSize) == nextHeaderCRC)
+    {
+      for (;;)
+      {
+        UInt64 type;
+        sd.Data = buffer.data;
+        sd.Size = buffer.size;
+        res = SzReadID(&amp;sd, &amp;type);
+        if (res != SZ_OK)
+          break;
+        if (type == k7zIdHeader)
+        {
+          res = SzReadHeader(p, &amp;sd, allocMain, allocTemp);
+          break;
+        }
+        if (type != k7zIdEncodedHeader)
+        {
+          res = SZ_ERROR_UNSUPPORTED;
+          break;
+        }
+        {
+          CBuf outBuffer;
+          Buf_Init(&amp;outBuffer);
+          res = SzReadAndDecodePackedStreams(inStream, &amp;sd, &amp;outBuffer,
+              p-&gt;ArchiveInfo.StartPositionAfterHeader,
+              allocTemp);
+          if (res != SZ_OK)
+          {
+            Buf_Free(&amp;outBuffer, allocTemp);
+            break;
+          }
+          Buf_Free(&amp;buffer, allocTemp);
+          buffer.data = outBuffer.data;
+          buffer.size = outBuffer.size;
+        }
+      }
+    }
+  }
+  Buf_Free(&amp;buffer, allocTemp);
+  return res;
+}
+
+SRes SzArEx_Open(CSzArEx *p, ISzInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp)
+{
+  SRes res = SzArEx_Open2(p, inStream, allocMain, allocTemp);
+  if (res != SZ_OK)
+    SzArEx_Free(p, allocMain);
+  return res;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,63 +0,0 @@
-/* 7zIn.h -- 7z Input functions
-2008-08-05
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zItem.h for license options */
-
-#ifndef __7Z_IN_H
-#define __7Z_IN_H
-
-#include &quot;7zHeader.h&quot;
-#include &quot;7zItem.h&quot;
-
-typedef struct
-{
-  CFileSize StartPositionAfterHeader;
-  CFileSize DataStartPosition;
-} CInArchiveInfo;
-
-typedef struct
-{
-  CSzAr db;
-  CInArchiveInfo ArchiveInfo;
-  UInt32 *FolderStartPackStreamIndex;
-  CFileSize *PackStreamStartPositions;
-  UInt32 *FolderStartFileIndex;
-  UInt32 *FileIndexToFolderIndexMap;
-} CSzArEx;
-
-void SzArEx_Init(CSzArEx *p);
-void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc);
-CFileSize SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder);
-int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, CFileSize *resSize);
-
-typedef enum
-{
-  SZ_SEEK_SET = 0,
-  SZ_SEEK_CUR = 1,
-  SZ_SEEK_END = 2
-} ESzSeek;
-
-typedef struct
-{
-  SRes (*Read)(void *object, void **buf, size_t *size);
-    /* if (input(*size) != 0 &amp;&amp; output(*size) == 0) means end_of_stream.
-       (output(*size) &lt; input(*size)) is allowed */
-  SRes (*Seek)(void *object, CFileSize pos, ESzSeek origin);
-} ISzInStream;
-
- 
-/*
-Errors:
-SZ_ERROR_NO_ARCHIVE
-SZ_ERROR_ARCHIVE
-SZ_ERROR_UNSUPPORTED
-SZ_ERROR_MEM
-SZ_ERROR_CRC
-SZ_ERROR_INPUT_EOF
-SZ_ERROR_FAIL
-*/
-
-SRes SzArEx_Open(CSzArEx *p, ISzInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp);
- 
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zIn.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,63 @@
+/* 7zIn.h -- 7z Input functions
+2008-08-05
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zItem.h for license options */
+
+#ifndef __7Z_IN_H
+#define __7Z_IN_H
+
+#include &quot;7zHeader.h&quot;
+#include &quot;7zItem.h&quot;
+
+typedef struct
+{
+  CFileSize StartPositionAfterHeader;
+  CFileSize DataStartPosition;
+} CInArchiveInfo;
+
+typedef struct
+{
+  CSzAr db;
+  CInArchiveInfo ArchiveInfo;
+  UInt32 *FolderStartPackStreamIndex;
+  CFileSize *PackStreamStartPositions;
+  UInt32 *FolderStartFileIndex;
+  UInt32 *FileIndexToFolderIndexMap;
+} CSzArEx;
+
+void SzArEx_Init(CSzArEx *p);
+void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc);
+CFileSize SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder);
+int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, CFileSize *resSize);
+
+typedef enum
+{
+  SZ_SEEK_SET = 0,
+  SZ_SEEK_CUR = 1,
+  SZ_SEEK_END = 2
+} ESzSeek;
+
+typedef struct
+{
+  SRes (*Read)(void *object, void **buf, size_t *size);
+    /* if (input(*size) != 0 &amp;&amp; output(*size) == 0) means end_of_stream.
+       (output(*size) &lt; input(*size)) is allowed */
+  SRes (*Seek)(void *object, CFileSize pos, ESzSeek origin);
+} ISzInStream;
+
+ 
+/*
+Errors:
+SZ_ERROR_NO_ARCHIVE
+SZ_ERROR_ARCHIVE
+SZ_ERROR_UNSUPPORTED
+SZ_ERROR_MEM
+SZ_ERROR_CRC
+SZ_ERROR_INPUT_EOF
+SZ_ERROR_FAIL
+*/
+
+SRes SzArEx_Open(CSzArEx *p, ISzInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp);
+ 
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,130 +0,0 @@
-/* 7zItem.c -- 7z Items
-2008-08-05
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read 7zItem.h for license options */
-
-#include &quot;7zItem.h&quot;
-
-void SzCoderInfo_Init(CSzCoderInfo *p)
-{
-  Buf_Init(&amp;p-&gt;Props);
-}
-
-void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc)
-{
-  Buf_Free(&amp;p-&gt;Props, alloc);
-  SzCoderInfo_Init(p);
-}
-
-void SzFolder_Init(CSzFolder *p)
-{
-  p-&gt;Coders = 0;
-  p-&gt;BindPairs = 0;
-  p-&gt;PackStreams = 0;
-  p-&gt;UnpackSizes = 0;
-  p-&gt;NumCoders = 0;
-  p-&gt;NumBindPairs = 0;
-  p-&gt;NumPackStreams = 0;
-  p-&gt;UnpackCRCDefined = 0;
-  p-&gt;UnpackCRC = 0;
-  p-&gt;NumUnpackStreams = 0;
-}
-
-void SzFolder_Free(CSzFolder *p, ISzAlloc *alloc)
-{
-  UInt32 i;
-  if (p-&gt;Coders)
-    for (i = 0; i &lt; p-&gt;NumCoders; i++)
-      SzCoderInfo_Free(&amp;p-&gt;Coders[i], alloc);
-  IAlloc_Free(alloc, p-&gt;Coders);
-  IAlloc_Free(alloc, p-&gt;BindPairs);
-  IAlloc_Free(alloc, p-&gt;PackStreams);
-  IAlloc_Free(alloc, p-&gt;UnpackSizes);
-  SzFolder_Init(p);
-}
-
-UInt32 SzFolder_GetNumOutStreams(CSzFolder *p)
-{
-  UInt32 result = 0;
-  UInt32 i;
-  for (i = 0; i &lt; p-&gt;NumCoders; i++)
-    result += p-&gt;Coders[i].NumOutStreams;
-  return result;
-}
-
-int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex)
-{
-  UInt32 i;
-  for (i = 0; i &lt; p-&gt;NumBindPairs; i++)
-    if (p-&gt;BindPairs[i].InIndex == inStreamIndex)
-      return i;
-  return -1;
-}
-
-
-int SzFolder_FindBindPairForOutStream(CSzFolder *p, UInt32 outStreamIndex)
-{
-  UInt32 i;
-  for (i = 0; i &lt; p-&gt;NumBindPairs; i++)
-    if (p-&gt;BindPairs[i].OutIndex == outStreamIndex)
-      return i;
-  return -1;
-}
-
-CFileSize SzFolder_GetUnpackSize(CSzFolder *p)
-{
-  int i = (int)SzFolder_GetNumOutStreams(p);
-  if (i == 0)
-    return 0;
-  for (i--; i &gt;= 0; i--)
-    if (SzFolder_FindBindPairForOutStream(p, i) &lt; 0)
-      return p-&gt;UnpackSizes[i];
-  /* throw 1; */
-  return 0;
-}
-
-void SzFile_Init(CSzFileItem *p)
-{
-  p-&gt;HasStream = 1;
-  p-&gt;IsDir = 0;
-  p-&gt;IsAnti = 0;
-  p-&gt;FileCRCDefined = 0;
-  p-&gt;MTimeDefined = 0;
-  p-&gt;Name = 0;
-}
-
-static void SzFile_Free(CSzFileItem *p, ISzAlloc *alloc)
-{
-  IAlloc_Free(alloc, p-&gt;Name);
-  SzFile_Init(p);
-}
-
-void SzAr_Init(CSzAr *p)
-{
-  p-&gt;PackSizes = 0;
-  p-&gt;PackCRCsDefined = 0;
-  p-&gt;PackCRCs = 0;
-  p-&gt;Folders = 0;
-  p-&gt;Files = 0;
-  p-&gt;NumPackStreams = 0;
-  p-&gt;NumFolders = 0;
-  p-&gt;NumFiles = 0;
-}
-
-void SzAr_Free(CSzAr *p, ISzAlloc *alloc)
-{
-  UInt32 i;
-  if (p-&gt;Folders)
-    for (i = 0; i &lt; p-&gt;NumFolders; i++)
-      SzFolder_Free(&amp;p-&gt;Folders[i], alloc);
-  if (p-&gt;Files)
-    for (i = 0; i &lt; p-&gt;NumFiles; i++)
-      SzFile_Free(&amp;p-&gt;Files[i], alloc);
-  IAlloc_Free(alloc, p-&gt;PackSizes);
-  IAlloc_Free(alloc, p-&gt;PackCRCsDefined);
-  IAlloc_Free(alloc, p-&gt;PackCRCs);
-  IAlloc_Free(alloc, p-&gt;Folders);
-  IAlloc_Free(alloc, p-&gt;Files);
-  SzAr_Init(p);
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,130 @@
+/* 7zItem.c -- 7z Items
+2008-08-05
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read 7zItem.h for license options */
+
+#include &quot;7zItem.h&quot;
+
+void SzCoderInfo_Init(CSzCoderInfo *p)
+{
+  Buf_Init(&amp;p-&gt;Props);
+}
+
+void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc)
+{
+  Buf_Free(&amp;p-&gt;Props, alloc);
+  SzCoderInfo_Init(p);
+}
+
+void SzFolder_Init(CSzFolder *p)
+{
+  p-&gt;Coders = 0;
+  p-&gt;BindPairs = 0;
+  p-&gt;PackStreams = 0;
+  p-&gt;UnpackSizes = 0;
+  p-&gt;NumCoders = 0;
+  p-&gt;NumBindPairs = 0;
+  p-&gt;NumPackStreams = 0;
+  p-&gt;UnpackCRCDefined = 0;
+  p-&gt;UnpackCRC = 0;
+  p-&gt;NumUnpackStreams = 0;
+}
+
+void SzFolder_Free(CSzFolder *p, ISzAlloc *alloc)
+{
+  UInt32 i;
+  if (p-&gt;Coders)
+    for (i = 0; i &lt; p-&gt;NumCoders; i++)
+      SzCoderInfo_Free(&amp;p-&gt;Coders[i], alloc);
+  IAlloc_Free(alloc, p-&gt;Coders);
+  IAlloc_Free(alloc, p-&gt;BindPairs);
+  IAlloc_Free(alloc, p-&gt;PackStreams);
+  IAlloc_Free(alloc, p-&gt;UnpackSizes);
+  SzFolder_Init(p);
+}
+
+UInt32 SzFolder_GetNumOutStreams(CSzFolder *p)
+{
+  UInt32 result = 0;
+  UInt32 i;
+  for (i = 0; i &lt; p-&gt;NumCoders; i++)
+    result += p-&gt;Coders[i].NumOutStreams;
+  return result;
+}
+
+int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex)
+{
+  UInt32 i;
+  for (i = 0; i &lt; p-&gt;NumBindPairs; i++)
+    if (p-&gt;BindPairs[i].InIndex == inStreamIndex)
+      return i;
+  return -1;
+}
+
+
+int SzFolder_FindBindPairForOutStream(CSzFolder *p, UInt32 outStreamIndex)
+{
+  UInt32 i;
+  for (i = 0; i &lt; p-&gt;NumBindPairs; i++)
+    if (p-&gt;BindPairs[i].OutIndex == outStreamIndex)
+      return i;
+  return -1;
+}
+
+CFileSize SzFolder_GetUnpackSize(CSzFolder *p)
+{
+  int i = (int)SzFolder_GetNumOutStreams(p);
+  if (i == 0)
+    return 0;
+  for (i--; i &gt;= 0; i--)
+    if (SzFolder_FindBindPairForOutStream(p, i) &lt; 0)
+      return p-&gt;UnpackSizes[i];
+  /* throw 1; */
+  return 0;
+}
+
+void SzFile_Init(CSzFileItem *p)
+{
+  p-&gt;HasStream = 1;
+  p-&gt;IsDir = 0;
+  p-&gt;IsAnti = 0;
+  p-&gt;FileCRCDefined = 0;
+  p-&gt;MTimeDefined = 0;
+  p-&gt;Name = 0;
+}
+
+static void SzFile_Free(CSzFileItem *p, ISzAlloc *alloc)
+{
+  IAlloc_Free(alloc, p-&gt;Name);
+  SzFile_Init(p);
+}
+
+void SzAr_Init(CSzAr *p)
+{
+  p-&gt;PackSizes = 0;
+  p-&gt;PackCRCsDefined = 0;
+  p-&gt;PackCRCs = 0;
+  p-&gt;Folders = 0;
+  p-&gt;Files = 0;
+  p-&gt;NumPackStreams = 0;
+  p-&gt;NumFolders = 0;
+  p-&gt;NumFiles = 0;
+}
+
+void SzAr_Free(CSzAr *p, ISzAlloc *alloc)
+{
+  UInt32 i;
+  if (p-&gt;Folders)
+    for (i = 0; i &lt; p-&gt;NumFolders; i++)
+      SzFolder_Free(&amp;p-&gt;Folders[i], alloc);
+  if (p-&gt;Files)
+    for (i = 0; i &lt; p-&gt;NumFiles; i++)
+      SzFile_Free(&amp;p-&gt;Files[i], alloc);
+  IAlloc_Free(alloc, p-&gt;PackSizes);
+  IAlloc_Free(alloc, p-&gt;PackCRCsDefined);
+  IAlloc_Free(alloc, p-&gt;PackCRCs);
+  IAlloc_Free(alloc, p-&gt;Folders);
+  IAlloc_Free(alloc, p-&gt;Files);
+  SzAr_Init(p);
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,98 +0,0 @@
-/* 7zItem.h -- 7z Items
-2008-07-09
-Igor Pavlov
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaDec.h for license options */
-
-#ifndef __7Z_ITEM_H
-#define __7Z_ITEM_H
-
-#include &quot;../../7zBuf.h&quot;
-
-/* #define _SZ_FILE_SIZE_32 */
-/* You can define _SZ_FILE_SIZE_32, if you don't need support for files larger than 4 GB*/
-
-#ifdef _SZ_FILE_SIZE_32
-typedef UInt32 CFileSize;
-#else
-typedef UInt64 CFileSize;
-#endif
-
-typedef UInt64 CMethodID;
-
-typedef struct
-{
-  UInt32 NumInStreams;
-  UInt32 NumOutStreams;
-  CMethodID MethodID;
-  CBuf Props;
-} CSzCoderInfo;
-
-void SzCoderInfo_Init(CSzCoderInfo *p);
-void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc);
-
-typedef struct
-{
-  UInt32 InIndex;
-  UInt32 OutIndex;
-} CBindPair;
-
-typedef struct
-{
-  CSzCoderInfo *Coders;
-  CBindPair *BindPairs;
-  UInt32 *PackStreams;
-  CFileSize *UnpackSizes;
-  UInt32 NumCoders;
-  UInt32 NumBindPairs;
-  UInt32 NumPackStreams;
-  int UnpackCRCDefined;
-  UInt32 UnpackCRC;
-
-  UInt32 NumUnpackStreams;
-} CSzFolder;
-
-void SzFolder_Init(CSzFolder *p);
-CFileSize SzFolder_GetUnpackSize(CSzFolder *p);
-int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex);
-UInt32 SzFolder_GetNumOutStreams(CSzFolder *p);
-CFileSize SzFolder_GetUnpackSize(CSzFolder *p);
-
-typedef struct
-{
-  UInt32 Low;
-  UInt32 High;
-} CNtfsFileTime;
-
-typedef struct
-{
-  CNtfsFileTime MTime;
-  CFileSize Size;
-  char *Name;
-  UInt32 FileCRC;
-
-  Byte HasStream;
-  Byte IsDir;
-  Byte IsAnti;
-  Byte FileCRCDefined;
-  Byte MTimeDefined;
-} CSzFileItem;
-
-void SzFile_Init(CSzFileItem *p);
-
-typedef struct
-{
-  CFileSize *PackSizes;
-  Byte *PackCRCsDefined;
-  UInt32 *PackCRCs;
-  CSzFolder *Folders;
-  CSzFileItem *Files;
-  UInt32 NumPackStreams;
-  UInt32 NumFolders;
-  UInt32 NumFiles;
-} CSzAr;
-
-void SzAr_Init(CSzAr *p);
-void SzAr_Free(CSzAr *p, ISzAlloc *alloc);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zItem.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,98 @@
+/* 7zItem.h -- 7z Items
+2008-07-09
+Igor Pavlov
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaDec.h for license options */
+
+#ifndef __7Z_ITEM_H
+#define __7Z_ITEM_H
+
+#include &quot;../../7zBuf.h&quot;
+
+/* #define _SZ_FILE_SIZE_32 */
+/* You can define _SZ_FILE_SIZE_32, if you don't need support for files larger than 4 GB*/
+
+#ifdef _SZ_FILE_SIZE_32
+typedef UInt32 CFileSize;
+#else
+typedef UInt64 CFileSize;
+#endif
+
+typedef UInt64 CMethodID;
+
+typedef struct
+{
+  UInt32 NumInStreams;
+  UInt32 NumOutStreams;
+  CMethodID MethodID;
+  CBuf Props;
+} CSzCoderInfo;
+
+void SzCoderInfo_Init(CSzCoderInfo *p);
+void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc);
+
+typedef struct
+{
+  UInt32 InIndex;
+  UInt32 OutIndex;
+} CBindPair;
+
+typedef struct
+{
+  CSzCoderInfo *Coders;
+  CBindPair *BindPairs;
+  UInt32 *PackStreams;
+  CFileSize *UnpackSizes;
+  UInt32 NumCoders;
+  UInt32 NumBindPairs;
+  UInt32 NumPackStreams;
+  int UnpackCRCDefined;
+  UInt32 UnpackCRC;
+
+  UInt32 NumUnpackStreams;
+} CSzFolder;
+
+void SzFolder_Init(CSzFolder *p);
+CFileSize SzFolder_GetUnpackSize(CSzFolder *p);
+int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex);
+UInt32 SzFolder_GetNumOutStreams(CSzFolder *p);
+CFileSize SzFolder_GetUnpackSize(CSzFolder *p);
+
+typedef struct
+{
+  UInt32 Low;
+  UInt32 High;
+} CNtfsFileTime;
+
+typedef struct
+{
+  CNtfsFileTime MTime;
+  CFileSize Size;
+  char *Name;
+  UInt32 FileCRC;
+
+  Byte HasStream;
+  Byte IsDir;
+  Byte IsAnti;
+  Byte FileCRCDefined;
+  Byte MTimeDefined;
+} CSzFileItem;
+
+void SzFile_Init(CSzFileItem *p);
+
+typedef struct
+{
+  CFileSize *PackSizes;
+  Byte *PackCRCsDefined;
+  UInt32 *PackCRCs;
+  CSzFolder *Folders;
+  CSzFileItem *Files;
+  UInt32 NumPackStreams;
+  UInt32 NumFolders;
+  UInt32 NumFiles;
+} CSzAr;
+
+void SzAr_Init(CSzAr *p);
+void SzAr_Free(CSzAr *p, ISzAlloc *alloc);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,426 +0,0 @@
-/* 7zMain.c - Test application for 7z Decoder
-2008-08-17
-Igor Pavlov
-Public domain */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#ifdef _WIN32
-#define USE_WINDOWS_FUNCTIONS
-#endif
-
-#ifdef USE_WINDOWS_FUNCTIONS
-#include &lt;windows.h&gt;
-#endif
-
-#include &quot;7zIn.h&quot;
-#include &quot;7zExtract.h&quot;
-#include &quot;7zAlloc.h&quot;
-
-#include &quot;../../7zCrc.h&quot;
-
-
-#ifdef USE_WINDOWS_FUNCTIONS
-typedef HANDLE MY_FILE_HANDLE;
-#else
-typedef FILE *MY_FILE_HANDLE;
-#endif
-
-void ConvertNumberToString(CFileSize value, char *s)
-{
-  char temp[32];
-  int pos = 0;
-  do
-  {
-    temp[pos++] = (char)('0' + (int)(value % 10));
-    value /= 10;
-  }
-  while (value != 0);
-  do
-    *s++ = temp[--pos];
-  while (pos &gt; 0);
-  *s = '\0';
-}
-
-#define PERIOD_4 (4 * 365 + 1)
-#define PERIOD_100 (PERIOD_4 * 25 - 1)
-#define PERIOD_400 (PERIOD_100 * 4 + 1)
-
-void ConvertFileTimeToString(CNtfsFileTime *ft, char *s)
-{
-  unsigned year, mon, day, hour, min, sec;
-  UInt64 v64 = ft-&gt;Low | ((UInt64)ft-&gt;High &lt;&lt; 32);
-  Byte ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-  unsigned temp;
-  UInt32 v;
-  v64 /= 10000000;
-  sec = (unsigned)(v64 % 60);
-  v64 /= 60;
-  min = (unsigned)(v64 % 60);
-  v64 /= 60;
-  hour = (unsigned)(v64 % 24);
-  v64 /= 24;
-
-  v = (UInt32)v64;
-
-  year = (unsigned)(1601 + v / PERIOD_400 * 400);
-  v %= PERIOD_400;
-
-  temp = (unsigned)(v / PERIOD_100);
-  if (temp == 4)
-    temp = 3;
-  year += temp * 100;
-  v -= temp * PERIOD_100;
-
-  temp = v / PERIOD_4;
-  if (temp == 25)
-    temp = 24;
-  year += temp * 4;
-  v -= temp * PERIOD_4;
-
-  temp = v / 365;
-  if (temp == 4)
-    temp = 3;
-  year += temp;
-  v -= temp * 365;
-
-  if (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0))
-    ms[1] = 29;
-  for (mon = 1; mon &lt;= 12; mon++)
-  {
-    unsigned s = ms[mon - 1];
-    if (v &lt; s)
-      break;
-    v -= s;
-  }
-  day = (unsigned)v + 1;
-  sprintf(s, &quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, year, mon, day, hour, min, sec);
-}
-
-
-#ifdef USE_WINDOWS_FUNCTIONS
-/*
-   ReadFile and WriteFile functions in Windows have BUG:
-   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
-   from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES
-   (Insufficient system resources exist to complete the requested service).
-*/
-#define kChunkSizeMax (1 &lt;&lt; 24)
-#endif
-
-size_t MyReadFile(MY_FILE_HANDLE file, void *data, size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef USE_WINDOWS_FUNCTIONS
-  {
-    size_t processedSize = 0;
-    do
-    {
-      DWORD curSize = (size &gt; kChunkSizeMax) ? kChunkSizeMax : (DWORD)size;
-      DWORD processedLoc = 0;
-      BOOL res = ReadFile(file, data, curSize, &amp;processedLoc, NULL);
-      data = (void *)((unsigned char *)data + processedLoc);
-      size -= processedLoc;
-      processedSize += processedLoc;
-      if (!res || processedLoc == 0)
-        break;
-    }
-    while (size &gt; 0);
-    return processedSize;
-  }
-  #else
-  return fread(data, 1, size, file);
-  #endif
-}
-
-size_t MyWriteFile(MY_FILE_HANDLE file, void *data, size_t size)
-{
-  if (size == 0)
-    return 0;
-  #ifdef USE_WINDOWS_FUNCTIONS
-  {
-    size_t processedSize = 0;
-    do
-    {
-      DWORD curSize = (size &gt; kChunkSizeMax) ? kChunkSizeMax : (DWORD)size;
-      DWORD processedLoc = 0;
-      BOOL res = WriteFile(file, data, curSize, &amp;processedLoc, NULL);
-      data = (void *)((unsigned char *)data + processedLoc);
-      size -= processedLoc;
-      processedSize += processedLoc;
-      if (!res)
-        break;
-    }
-    while (size &gt; 0);
-    return processedSize;
-  }
-  #else
-  return fwrite(data, 1, size, file);
-  #endif
-}
-
-int MyCloseFile(MY_FILE_HANDLE file)
-{
-  #ifdef USE_WINDOWS_FUNCTIONS
-  return (CloseHandle(file) != FALSE) ? 0 : 1;
-  #else
-  return fclose(file);
-  #endif
-}
-
-typedef struct _CFileInStream
-{
-  ISzInStream InStream;
-  MY_FILE_HANDLE File;
-} CFileInStream;
-
-
-#define kBufferSize (1 &lt;&lt; 12)
-Byte g_Buffer[kBufferSize];
-
-SRes SzFileReadImp(void *object, void **buffer, size_t *size)
-{
-  CFileInStream *s = (CFileInStream *)object;
-  if (*size &gt; kBufferSize)
-    *size = kBufferSize;
-  *size = MyReadFile(s-&gt;File, g_Buffer, *size);
-  *buffer = g_Buffer;
-  return SZ_OK;
-}
-
-SRes SzFileSeekImp(void *object, CFileSize pos, ESzSeek origin)
-{
-  CFileInStream *s = (CFileInStream *)object;
-
-  #ifdef USE_WINDOWS_FUNCTIONS
-  {
-    LARGE_INTEGER value;
-    DWORD moveMethod;
-    value.LowPart = (DWORD)pos;
-    value.HighPart = (LONG)((UInt64)pos &gt;&gt; 32);
-    #ifdef _SZ_FILE_SIZE_32
-    /* VC 6.0 has bug with &gt;&gt; 32 shifts. */
-    value.HighPart = 0;
-    #endif
-    switch (origin)
-    {
-      case SZ_SEEK_SET: moveMethod = FILE_BEGIN; break;
-      case SZ_SEEK_CUR: moveMethod = FILE_CURRENT; break;
-      case SZ_SEEK_END: moveMethod = FILE_END; break;
-      default: return SZ_ERROR_PARAM;
-    }
-    value.LowPart = SetFilePointer(s-&gt;File, value.LowPart, &amp;value.HighPart, moveMethod);
-    if (value.LowPart == 0xFFFFFFFF)
-      if (GetLastError() != NO_ERROR)
-        return SZ_ERROR_FAIL;
-    return SZ_OK;
-  }
-  #else
-  int moveMethod;
-  int res;
-  switch (origin)
-  {
-    case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
-    case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
-    case SZ_SEEK_END: moveMethod = SEEK_END; break;
-    default: return SZ_ERROR_PARAM;
-  }
-  res = fseek(s-&gt;File, (long)pos, moveMethod );
-  return (res == 0) ? SZ_OK : SZ_ERROR_FAIL;
-  #endif
-}
-
-void PrintError(char *sz)
-{
-  printf(&quot;\nERROR: %s\n&quot;, sz);
-}
-
-int MY_CDECL main(int numargs, char *args[])
-{
-  CFileInStream archiveStream;
-  CSzArEx db;
-  SRes res;
-  ISzAlloc allocImp;
-  ISzAlloc allocTempImp;
-
-  printf(&quot;\n7z ANSI-C Decoder 4.59  Copyright (c) 1999-2008 Igor Pavlov  2008-07-09\n&quot;);
-  if (numargs == 1)
-  {
-    printf(
-      &quot;\nUsage: 7zDec &lt;command&gt; &lt;archive_name&gt;\n\n&quot;
-      &quot;&lt;Commands&gt;\n&quot;
-      &quot;  e: Extract files from archive\n&quot;
-      &quot;  l: List contents of archive\n&quot;
-      &quot;  t: Test integrity of archive\n&quot;);
-    return 0;
-  }
-  if (numargs &lt; 3)
-  {
-    PrintError(&quot;incorrect command&quot;);
-    return 1;
-  }
-
-  archiveStream.File =
-  #ifdef USE_WINDOWS_FUNCTIONS
-  CreateFileA(args[2], GENERIC_READ, FILE_SHARE_READ,
-      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-  if (archiveStream.File == INVALID_HANDLE_VALUE)
-  #else
-  archiveStream.File = fopen(args[2], &quot;rb&quot;);
-  if (archiveStream.File == 0)
-  #endif
-  {
-    PrintError(&quot;can not open input file&quot;);
-    return 1;
-  }
-
-  archiveStream.InStream.Read = SzFileReadImp;
-  archiveStream.InStream.Seek = SzFileSeekImp;
-
-  allocImp.Alloc = SzAlloc;
-  allocImp.Free = SzFree;
-
-  allocTempImp.Alloc = SzAllocTemp;
-  allocTempImp.Free = SzFreeTemp;
-
-  CrcGenerateTable();
-
-  SzArEx_Init(&amp;db);
-  res = SzArEx_Open(&amp;db, &amp;archiveStream.InStream, &amp;allocImp, &amp;allocTempImp);
-  if (res == SZ_OK)
-  {
-    char *command = args[1];
-    int listCommand = 0;
-    int testCommand = 0;
-    int extractCommand = 0;
-    if (strcmp(command, &quot;l&quot;) == 0)
-      listCommand = 1;
-    if (strcmp(command, &quot;t&quot;) == 0)
-      testCommand = 1;
-    else if (strcmp(command, &quot;e&quot;) == 0)
-      extractCommand = 1;
-
-    if (listCommand)
-    {
-      UInt32 i;
-      for (i = 0; i &lt; db.db.NumFiles; i++)
-      {
-        CSzFileItem *f = db.db.Files + i;
-        char s[32], t[32];
-        ConvertNumberToString(f-&gt;Size, s);
-        if (f-&gt;MTimeDefined)
-          ConvertFileTimeToString(&amp;f-&gt;MTime, t);
-        else
-          strcpy(t, &quot;                   &quot;);
-
-        printf(&quot;%10s %s  %s\n&quot;, s, t, f-&gt;Name);
-      }
-    }
-    else if (testCommand || extractCommand)
-    {
-      UInt32 i;
-
-      /*
-      if you need cache, use these 3 variables.
-      if you use external function, you can make these variable as static.
-      */
-      UInt32 blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */
-      Byte *outBuffer = 0; /* it must be 0 before first call for each new archive. */
-      size_t outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */
-
-      printf(&quot;\n&quot;);
-      for (i = 0; i &lt; db.db.NumFiles; i++)
-      {
-        size_t offset;
-        size_t outSizeProcessed;
-        CSzFileItem *f = db.db.Files + i;
-        if (f-&gt;IsDir)
-          printf(&quot;Directory &quot;);
-        else
-          printf(testCommand ?
-            &quot;Testing   &quot;:
-            &quot;Extracting&quot;);
-        printf(&quot; %s&quot;, f-&gt;Name);
-        if (f-&gt;IsDir)
-        {
-          printf(&quot;\n&quot;);
-          continue;
-        }
-        res = SzAr_Extract(&amp;db, &amp;archiveStream.InStream, i,
-            &amp;blockIndex, &amp;outBuffer, &amp;outBufferSize,
-            &amp;offset, &amp;outSizeProcessed,
-            &amp;allocImp, &amp;allocTempImp);
-        if (res != SZ_OK)
-          break;
-        if (!testCommand)
-        {
-          MY_FILE_HANDLE outputHandle;
-          size_t processedSize;
-          char *fileName = f-&gt;Name;
-          size_t nameLen = strlen(f-&gt;Name);
-          for (; nameLen &gt; 0; nameLen--)
-            if (f-&gt;Name[nameLen - 1] == '/')
-            {
-              fileName = f-&gt;Name + nameLen;
-              break;
-            }
-            
-          outputHandle =
-          #ifdef USE_WINDOWS_FUNCTIONS
-            CreateFileA(fileName, GENERIC_WRITE, FILE_SHARE_READ,
-                NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
-          if (outputHandle == INVALID_HANDLE_VALUE)
-          #else
-          fopen(fileName, &quot;wb+&quot;);
-          if (outputHandle == 0)
-          #endif
-          {
-            PrintError(&quot;can not open output file&quot;);
-            res = SZ_ERROR_FAIL;
-            break;
-          }
-          processedSize = MyWriteFile(outputHandle, outBuffer + offset, outSizeProcessed);
-          if (processedSize != outSizeProcessed)
-          {
-            PrintError(&quot;can not write output file&quot;);
-            res = SZ_ERROR_FAIL;
-            break;
-          }
-          if (MyCloseFile(outputHandle))
-          {
-            PrintError(&quot;can not close output file&quot;);
-            res = SZ_ERROR_FAIL;
-            break;
-          }
-        }
-        printf(&quot;\n&quot;);
-      }
-      IAlloc_Free(&amp;allocImp, outBuffer);
-    }
-    else
-    {
-      PrintError(&quot;incorrect command&quot;);
-      res = SZ_ERROR_FAIL;
-    }
-  }
-  SzArEx_Free(&amp;db, &amp;allocImp);
-
-  MyCloseFile(archiveStream.File);
-  if (res == SZ_OK)
-  {
-    printf(&quot;\nEverything is Ok\n&quot;);
-    return 0;
-  }
-  if (res == SZ_ERROR_UNSUPPORTED)
-    PrintError(&quot;decoder doesn't support this archive&quot;);
-  else if (res == SZ_ERROR_MEM)
-    PrintError(&quot;can not allocate memory&quot;);
-  else if (res == SZ_ERROR_CRC)
-    PrintError(&quot;CRC error&quot;);
-  else
-    printf(&quot;\nERROR #%d\n&quot;, res);
-  return 1;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/7zMain.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,426 @@
+/* 7zMain.c - Test application for 7z Decoder
+2008-08-17
+Igor Pavlov
+Public domain */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#ifdef _WIN32
+#define USE_WINDOWS_FUNCTIONS
+#endif
+
+#ifdef USE_WINDOWS_FUNCTIONS
+#include &lt;windows.h&gt;
+#endif
+
+#include &quot;7zIn.h&quot;
+#include &quot;7zExtract.h&quot;
+#include &quot;7zAlloc.h&quot;
+
+#include &quot;../../7zCrc.h&quot;
+
+
+#ifdef USE_WINDOWS_FUNCTIONS
+typedef HANDLE MY_FILE_HANDLE;
+#else
+typedef FILE *MY_FILE_HANDLE;
+#endif
+
+void ConvertNumberToString(CFileSize value, char *s)
+{
+  char temp[32];
+  int pos = 0;
+  do
+  {
+    temp[pos++] = (char)('0' + (int)(value % 10));
+    value /= 10;
+  }
+  while (value != 0);
+  do
+    *s++ = temp[--pos];
+  while (pos &gt; 0);
+  *s = '\0';
+}
+
+#define PERIOD_4 (4 * 365 + 1)
+#define PERIOD_100 (PERIOD_4 * 25 - 1)
+#define PERIOD_400 (PERIOD_100 * 4 + 1)
+
+void ConvertFileTimeToString(CNtfsFileTime *ft, char *s)
+{
+  unsigned year, mon, day, hour, min, sec;
+  UInt64 v64 = ft-&gt;Low | ((UInt64)ft-&gt;High &lt;&lt; 32);
+  Byte ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+  unsigned temp;
+  UInt32 v;
+  v64 /= 10000000;
+  sec = (unsigned)(v64 % 60);
+  v64 /= 60;
+  min = (unsigned)(v64 % 60);
+  v64 /= 60;
+  hour = (unsigned)(v64 % 24);
+  v64 /= 24;
+
+  v = (UInt32)v64;
+
+  year = (unsigned)(1601 + v / PERIOD_400 * 400);
+  v %= PERIOD_400;
+
+  temp = (unsigned)(v / PERIOD_100);
+  if (temp == 4)
+    temp = 3;
+  year += temp * 100;
+  v -= temp * PERIOD_100;
+
+  temp = v / PERIOD_4;
+  if (temp == 25)
+    temp = 24;
+  year += temp * 4;
+  v -= temp * PERIOD_4;
+
+  temp = v / 365;
+  if (temp == 4)
+    temp = 3;
+  year += temp;
+  v -= temp * 365;
+
+  if (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0))
+    ms[1] = 29;
+  for (mon = 1; mon &lt;= 12; mon++)
+  {
+    unsigned s = ms[mon - 1];
+    if (v &lt; s)
+      break;
+    v -= s;
+  }
+  day = (unsigned)v + 1;
+  sprintf(s, &quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, year, mon, day, hour, min, sec);
+}
+
+
+#ifdef USE_WINDOWS_FUNCTIONS
+/*
+   ReadFile and WriteFile functions in Windows have BUG:
+   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
+   from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES
+   (Insufficient system resources exist to complete the requested service).
+*/
+#define kChunkSizeMax (1 &lt;&lt; 24)
+#endif
+
+size_t MyReadFile(MY_FILE_HANDLE file, void *data, size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef USE_WINDOWS_FUNCTIONS
+  {
+    size_t processedSize = 0;
+    do
+    {
+      DWORD curSize = (size &gt; kChunkSizeMax) ? kChunkSizeMax : (DWORD)size;
+      DWORD processedLoc = 0;
+      BOOL res = ReadFile(file, data, curSize, &amp;processedLoc, NULL);
+      data = (void *)((unsigned char *)data + processedLoc);
+      size -= processedLoc;
+      processedSize += processedLoc;
+      if (!res || processedLoc == 0)
+        break;
+    }
+    while (size &gt; 0);
+    return processedSize;
+  }
+  #else
+  return fread(data, 1, size, file);
+  #endif
+}
+
+size_t MyWriteFile(MY_FILE_HANDLE file, void *data, size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef USE_WINDOWS_FUNCTIONS
+  {
+    size_t processedSize = 0;
+    do
+    {
+      DWORD curSize = (size &gt; kChunkSizeMax) ? kChunkSizeMax : (DWORD)size;
+      DWORD processedLoc = 0;
+      BOOL res = WriteFile(file, data, curSize, &amp;processedLoc, NULL);
+      data = (void *)((unsigned char *)data + processedLoc);
+      size -= processedLoc;
+      processedSize += processedLoc;
+      if (!res)
+        break;
+    }
+    while (size &gt; 0);
+    return processedSize;
+  }
+  #else
+  return fwrite(data, 1, size, file);
+  #endif
+}
+
+int MyCloseFile(MY_FILE_HANDLE file)
+{
+  #ifdef USE_WINDOWS_FUNCTIONS
+  return (CloseHandle(file) != FALSE) ? 0 : 1;
+  #else
+  return fclose(file);
+  #endif
+}
+
+typedef struct _CFileInStream
+{
+  ISzInStream InStream;
+  MY_FILE_HANDLE File;
+} CFileInStream;
+
+
+#define kBufferSize (1 &lt;&lt; 12)
+Byte g_Buffer[kBufferSize];
+
+SRes SzFileReadImp(void *object, void **buffer, size_t *size)
+{
+  CFileInStream *s = (CFileInStream *)object;
+  if (*size &gt; kBufferSize)
+    *size = kBufferSize;
+  *size = MyReadFile(s-&gt;File, g_Buffer, *size);
+  *buffer = g_Buffer;
+  return SZ_OK;
+}
+
+SRes SzFileSeekImp(void *object, CFileSize pos, ESzSeek origin)
+{
+  CFileInStream *s = (CFileInStream *)object;
+
+  #ifdef USE_WINDOWS_FUNCTIONS
+  {
+    LARGE_INTEGER value;
+    DWORD moveMethod;
+    value.LowPart = (DWORD)pos;
+    value.HighPart = (LONG)((UInt64)pos &gt;&gt; 32);
+    #ifdef _SZ_FILE_SIZE_32
+    /* VC 6.0 has bug with &gt;&gt; 32 shifts. */
+    value.HighPart = 0;
+    #endif
+    switch (origin)
+    {
+      case SZ_SEEK_SET: moveMethod = FILE_BEGIN; break;
+      case SZ_SEEK_CUR: moveMethod = FILE_CURRENT; break;
+      case SZ_SEEK_END: moveMethod = FILE_END; break;
+      default: return SZ_ERROR_PARAM;
+    }
+    value.LowPart = SetFilePointer(s-&gt;File, value.LowPart, &amp;value.HighPart, moveMethod);
+    if (value.LowPart == 0xFFFFFFFF)
+      if (GetLastError() != NO_ERROR)
+        return SZ_ERROR_FAIL;
+    return SZ_OK;
+  }
+  #else
+  int moveMethod;
+  int res;
+  switch (origin)
+  {
+    case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
+    case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
+    case SZ_SEEK_END: moveMethod = SEEK_END; break;
+    default: return SZ_ERROR_PARAM;
+  }
+  res = fseek(s-&gt;File, (long)pos, moveMethod );
+  return (res == 0) ? SZ_OK : SZ_ERROR_FAIL;
+  #endif
+}
+
+void PrintError(char *sz)
+{
+  printf(&quot;\nERROR: %s\n&quot;, sz);
+}
+
+int MY_CDECL main(int numargs, char *args[])
+{
+  CFileInStream archiveStream;
+  CSzArEx db;
+  SRes res;
+  ISzAlloc allocImp;
+  ISzAlloc allocTempImp;
+
+  printf(&quot;\n7z ANSI-C Decoder 4.59  Copyright (c) 1999-2008 Igor Pavlov  2008-07-09\n&quot;);
+  if (numargs == 1)
+  {
+    printf(
+      &quot;\nUsage: 7zDec &lt;command&gt; &lt;archive_name&gt;\n\n&quot;
+      &quot;&lt;Commands&gt;\n&quot;
+      &quot;  e: Extract files from archive\n&quot;
+      &quot;  l: List contents of archive\n&quot;
+      &quot;  t: Test integrity of archive\n&quot;);
+    return 0;
+  }
+  if (numargs &lt; 3)
+  {
+    PrintError(&quot;incorrect command&quot;);
+    return 1;
+  }
+
+  archiveStream.File =
+  #ifdef USE_WINDOWS_FUNCTIONS
+  CreateFileA(args[2], GENERIC_READ, FILE_SHARE_READ,
+      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+  if (archiveStream.File == INVALID_HANDLE_VALUE)
+  #else
+  archiveStream.File = fopen(args[2], &quot;rb&quot;);
+  if (archiveStream.File == 0)
+  #endif
+  {
+    PrintError(&quot;can not open input file&quot;);
+    return 1;
+  }
+
+  archiveStream.InStream.Read = SzFileReadImp;
+  archiveStream.InStream.Seek = SzFileSeekImp;
+
+  allocImp.Alloc = SzAlloc;
+  allocImp.Free = SzFree;
+
+  allocTempImp.Alloc = SzAllocTemp;
+  allocTempImp.Free = SzFreeTemp;
+
+  CrcGenerateTable();
+
+  SzArEx_Init(&amp;db);
+  res = SzArEx_Open(&amp;db, &amp;archiveStream.InStream, &amp;allocImp, &amp;allocTempImp);
+  if (res == SZ_OK)
+  {
+    char *command = args[1];
+    int listCommand = 0;
+    int testCommand = 0;
+    int extractCommand = 0;
+    if (strcmp(command, &quot;l&quot;) == 0)
+      listCommand = 1;
+    if (strcmp(command, &quot;t&quot;) == 0)
+      testCommand = 1;
+    else if (strcmp(command, &quot;e&quot;) == 0)
+      extractCommand = 1;
+
+    if (listCommand)
+    {
+      UInt32 i;
+      for (i = 0; i &lt; db.db.NumFiles; i++)
+      {
+        CSzFileItem *f = db.db.Files + i;
+        char s[32], t[32];
+        ConvertNumberToString(f-&gt;Size, s);
+        if (f-&gt;MTimeDefined)
+          ConvertFileTimeToString(&amp;f-&gt;MTime, t);
+        else
+          strcpy(t, &quot;                   &quot;);
+
+        printf(&quot;%10s %s  %s\n&quot;, s, t, f-&gt;Name);
+      }
+    }
+    else if (testCommand || extractCommand)
+    {
+      UInt32 i;
+
+      /*
+      if you need cache, use these 3 variables.
+      if you use external function, you can make these variable as static.
+      */
+      UInt32 blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */
+      Byte *outBuffer = 0; /* it must be 0 before first call for each new archive. */
+      size_t outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */
+
+      printf(&quot;\n&quot;);
+      for (i = 0; i &lt; db.db.NumFiles; i++)
+      {
+        size_t offset;
+        size_t outSizeProcessed;
+        CSzFileItem *f = db.db.Files + i;
+        if (f-&gt;IsDir)
+          printf(&quot;Directory &quot;);
+        else
+          printf(testCommand ?
+            &quot;Testing   &quot;:
+            &quot;Extracting&quot;);
+        printf(&quot; %s&quot;, f-&gt;Name);
+        if (f-&gt;IsDir)
+        {
+          printf(&quot;\n&quot;);
+          continue;
+        }
+        res = SzAr_Extract(&amp;db, &amp;archiveStream.InStream, i,
+            &amp;blockIndex, &amp;outBuffer, &amp;outBufferSize,
+            &amp;offset, &amp;outSizeProcessed,
+            &amp;allocImp, &amp;allocTempImp);
+        if (res != SZ_OK)
+          break;
+        if (!testCommand)
+        {
+          MY_FILE_HANDLE outputHandle;
+          size_t processedSize;
+          char *fileName = f-&gt;Name;
+          size_t nameLen = strlen(f-&gt;Name);
+          for (; nameLen &gt; 0; nameLen--)
+            if (f-&gt;Name[nameLen - 1] == '/')
+            {
+              fileName = f-&gt;Name + nameLen;
+              break;
+            }
+            
+          outputHandle =
+          #ifdef USE_WINDOWS_FUNCTIONS
+            CreateFileA(fileName, GENERIC_WRITE, FILE_SHARE_READ,
+                NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+          if (outputHandle == INVALID_HANDLE_VALUE)
+          #else
+          fopen(fileName, &quot;wb+&quot;);
+          if (outputHandle == 0)
+          #endif
+          {
+            PrintError(&quot;can not open output file&quot;);
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+          processedSize = MyWriteFile(outputHandle, outBuffer + offset, outSizeProcessed);
+          if (processedSize != outSizeProcessed)
+          {
+            PrintError(&quot;can not write output file&quot;);
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+          if (MyCloseFile(outputHandle))
+          {
+            PrintError(&quot;can not close output file&quot;);
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+        }
+        printf(&quot;\n&quot;);
+      }
+      IAlloc_Free(&amp;allocImp, outBuffer);
+    }
+    else
+    {
+      PrintError(&quot;incorrect command&quot;);
+      res = SZ_ERROR_FAIL;
+    }
+  }
+  SzArEx_Free(&amp;db, &amp;allocImp);
+
+  MyCloseFile(archiveStream.File);
+  if (res == SZ_OK)
+  {
+    printf(&quot;\nEverything is Ok\n&quot;);
+    return 0;
+  }
+  if (res == SZ_ERROR_UNSUPPORTED)
+    PrintError(&quot;decoder doesn't support this archive&quot;);
+  else if (res == SZ_ERROR_MEM)
+    PrintError(&quot;can not allocate memory&quot;);
+  else if (res == SZ_ERROR_CRC)
+    PrintError(&quot;CRC error&quot;);
+  else
+    printf(&quot;\nERROR #%d\n&quot;, res);
+  return 1;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,30 +0,0 @@
-MY_STATIC_LINK=1
-
-PROG = 7zDec.exe
-
-C_OBJS = \
-  $O\7zBuf.obj \
-  $O\7zCrc.obj \
-  $O\LzmaDec.obj \
-  $O\Bra86.obj \
-  $O\Bcj2.obj \
-
-7Z_OBJS = \
-  $O\7zAlloc.obj \
-  $O\7zDecode.obj \
-  $O\7zExtract.obj \
-  $O\7zHeader.obj \
-  $O\7zIn.obj \
-  $O\7zItem.obj \
-  $O\7zMain.obj \
-
-OBJS = \
-  $(7Z_OBJS) \
-  $(C_OBJS) \
-
-!include &quot;../../../CPP/Build.mak&quot;
-
-$(7Z_OBJS): $(*B).c
-	$(COMPL_O1)
-$(C_OBJS): ../../$(*B).c
-	$(COMPL_O2)

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,30 @@
+MY_STATIC_LINK=1
+
+PROG = 7zDec.exe
+
+C_OBJS = \
+  $O\7zBuf.obj \
+  $O\7zCrc.obj \
+  $O\LzmaDec.obj \
+  $O\Bra86.obj \
+  $O\Bcj2.obj \
+
+7Z_OBJS = \
+  $O\7zAlloc.obj \
+  $O\7zDecode.obj \
+  $O\7zExtract.obj \
+  $O\7zHeader.obj \
+  $O\7zIn.obj \
+  $O\7zItem.obj \
+  $O\7zMain.obj \
+
+OBJS = \
+  $(7Z_OBJS) \
+  $(C_OBJS) \
+
+!include &quot;../../../CPP/Build.mak&quot;
+
+$(7Z_OBJS): $(*B).c
+	$(COMPL_O1)
+$(C_OBJS): ../../$(*B).c
+	$(COMPL_O2)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,50 +0,0 @@
-PROG = 7zDec
-CXX = g++
-CC = gcc
-LIB =
-RM = rm -f
-CFLAGS = -c -O2 -Wall
-
-OBJS = 7zAlloc.o 7zBuf.o 7zCrc.o 7zDecode.o 7zExtract.o 7zHeader.o 7zIn.o 7zItem.o LzmaDec.o Bra86.o Bcj2.o
-
-all: $(OBJS)
-
-7zAlloc.o: 7zAlloc.c
-	$(CC) $(CFLAGS) 7zAlloc.c
-
-7zBuf.o: ../../7zBuf.c
-	$(CC) $(CFLAGS) ../../7zBuf.c
-
-7zCrc.o: ../../7zCrc.c
-	$(CC) $(CFLAGS) ../../7zCrc.c
-
-7zDecode.o: 7zDecode.c
-	$(CC) $(CFLAGS) 7zDecode.c
-
-7zExtract.o: 7zExtract.c
-	$(CC) $(CFLAGS) 7zExtract.c
-
-7zHeader.o: 7zHeader.c
-	$(CC) $(CFLAGS) 7zHeader.c
-
-7zIn.o: 7zIn.c
-	$(CC) $(CFLAGS) 7zIn.c
-
-7zItem.o: 7zItem.c
-	$(CC) $(CFLAGS) 7zItem.c
-
-7zMain.o: 7zMain.c
-	$(CC) $(CFLAGS) 7zMain.c
-
-LzmaDec.o: ../../LzmaDec.c
-	$(CC) $(CFLAGS) ../../LzmaDec.c
-
-Bra86.o: ../../Bra86.c
-	$(CC) $(CFLAGS) ../../Bra86.c
-
-Bcj2.o: ../../Bcj2.c
-	$(CC) $(CFLAGS) ../../Bcj2.c
-
-clean:
-	-$(RM) $(PROG) $(OBJS)
-

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Archive/7z/makefile.gcc	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,50 @@
+PROG = 7zDec
+CXX = g++
+CC = gcc
+LIB =
+RM = rm -f
+CFLAGS = -c -O2 -Wall
+
+OBJS = 7zAlloc.o 7zBuf.o 7zCrc.o 7zDecode.o 7zExtract.o 7zHeader.o 7zIn.o 7zItem.o LzmaDec.o Bra86.o Bcj2.o
+
+all: $(OBJS)
+
+7zAlloc.o: 7zAlloc.c
+	$(CC) $(CFLAGS) 7zAlloc.c
+
+7zBuf.o: ../../7zBuf.c
+	$(CC) $(CFLAGS) ../../7zBuf.c
+
+7zCrc.o: ../../7zCrc.c
+	$(CC) $(CFLAGS) ../../7zCrc.c
+
+7zDecode.o: 7zDecode.c
+	$(CC) $(CFLAGS) 7zDecode.c
+
+7zExtract.o: 7zExtract.c
+	$(CC) $(CFLAGS) 7zExtract.c
+
+7zHeader.o: 7zHeader.c
+	$(CC) $(CFLAGS) 7zHeader.c
+
+7zIn.o: 7zIn.c
+	$(CC) $(CFLAGS) 7zIn.c
+
+7zItem.o: 7zItem.c
+	$(CC) $(CFLAGS) 7zItem.c
+
+7zMain.o: 7zMain.c
+	$(CC) $(CFLAGS) 7zMain.c
+
+LzmaDec.o: ../../LzmaDec.c
+	$(CC) $(CFLAGS) ../../LzmaDec.c
+
+Bra86.o: ../../Bra86.c
+	$(CC) $(CFLAGS) ../../Bra86.c
+
+Bcj2.o: ../../Bcj2.c
+	$(CC) $(CFLAGS) ../../Bcj2.c
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,134 +0,0 @@
-/* Bcj2.c -- Converter for x86 code (BCJ2)
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#include &quot;Bcj2.h&quot;
-
-#ifdef _LZMA_PROB32
-#define CProb UInt32
-#else
-#define CProb UInt16
-#endif
-
-#define IsJcc(b0, b1) ((b0) == 0x0F &amp;&amp; ((b1) &amp; 0xF0) == 0x80)
-#define IsJ(b0, b1) ((b1 &amp; 0xFE) == 0xE8 || IsJcc(b0, b1))
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
-#define kNumMoveBits 5
-
-#define RC_READ_BYTE (*buffer++)
-#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }
-#define RC_INIT2 code = 0; range = 0xFFFFFFFF; \
-  { int i; for (i = 0; i &lt; 5; i++) { RC_TEST; code = (code &lt;&lt; 8) | RC_READ_BYTE; }}
-
-#define NORMALIZE if (range &lt; kTopValue) { RC_TEST; range &lt;&lt;= 8; code = (code &lt;&lt; 8) | RC_READ_BYTE; }
-
-#define IF_BIT_0(p) ttt = *(p); bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
-#define UPDATE_0(p) range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) &gt;&gt; kNumMoveBits)); NORMALIZE;
-#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt &gt;&gt; kNumMoveBits)); NORMALIZE;
-
-int Bcj2_Decode(
-    const Byte *buf0, SizeT size0,
-    const Byte *buf1, SizeT size1,
-    const Byte *buf2, SizeT size2,
-    const Byte *buf3, SizeT size3,
-    Byte *outBuf, SizeT outSize)
-{
-  CProb p[256 + 2];
-  SizeT inPos = 0, outPos = 0;
-
-  const Byte *buffer, *bufferLim;
-  UInt32 range, code;
-  Byte prevByte = 0;
-
-  unsigned int i;
-  for (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++)
-    p[i] = kBitModelTotal &gt;&gt; 1;
-
-  buffer = buf3;
-  bufferLim = buffer + size3;
-  RC_INIT2
-
-  if (outSize == 0)
-    return SZ_OK;
-
-  for (;;)
-  {
-    Byte b;
-    CProb *prob;
-    UInt32 bound;
-    UInt32 ttt;
-
-    SizeT limit = size0 - inPos;
-    if (outSize - outPos &lt; limit)
-      limit = outSize - outPos;
-    while (limit != 0)
-    {
-      Byte b = buf0[inPos];
-      outBuf[outPos++] = b;
-      if (IsJ(prevByte, b))
-        break;
-      inPos++;
-      prevByte = b;
-      limit--;
-    }
-
-    if (limit == 0 || outPos == outSize)
-      break;
-
-    b = buf0[inPos++];
-
-    if (b == 0xE8)
-      prob = p + prevByte;
-    else if (b == 0xE9)
-      prob = p + 256;
-    else
-      prob = p + 257;
-
-    IF_BIT_0(prob)
-    {
-      UPDATE_0(prob)
-      prevByte = b;
-    }
-    else
-    {
-      UInt32 dest;
-      const Byte *v;
-      UPDATE_1(prob)
-      if (b == 0xE8)
-      {
-        v = buf1;
-        if (size1 &lt; 4)
-          return SZ_ERROR_DATA;
-        buf1 += 4;
-        size1 -= 4;
-      }
-      else
-      {
-        v = buf2;
-        if (size2 &lt; 4)
-          return SZ_ERROR_DATA;
-        buf2 += 4;
-        size2 -= 4;
-      }
-      dest = (((UInt32)v[0] &lt;&lt; 24) | ((UInt32)v[1] &lt;&lt; 16) |
-          ((UInt32)v[2] &lt;&lt; 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
-      outBuf[outPos++] = (Byte)dest;
-      if (outPos == outSize)
-        break;
-      outBuf[outPos++] = (Byte)(dest &gt;&gt; 8);
-      if (outPos == outSize)
-        break;
-      outBuf[outPos++] = (Byte)(dest &gt;&gt; 16);
-      if (outPos == outSize)
-        break;
-      outBuf[outPos++] = prevByte = (Byte)(dest &gt;&gt; 24);
-    }
-  }
-  return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,134 @@
+/* Bcj2.c -- Converter for x86 code (BCJ2)
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#include &quot;Bcj2.h&quot;
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define IsJcc(b0, b1) ((b0) == 0x0F &amp;&amp; ((b1) &amp; 0xF0) == 0x80)
+#define IsJ(b0, b1) ((b1 &amp; 0xFE) == 0xE8 || IsJcc(b0, b1))
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*buffer++)
+#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }
+#define RC_INIT2 code = 0; range = 0xFFFFFFFF; \
+  { int i; for (i = 0; i &lt; 5; i++) { RC_TEST; code = (code &lt;&lt; 8) | RC_READ_BYTE; }}
+
+#define NORMALIZE if (range &lt; kTopValue) { RC_TEST; range &lt;&lt;= 8; code = (code &lt;&lt; 8) | RC_READ_BYTE; }
+
+#define IF_BIT_0(p) ttt = *(p); bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
+#define UPDATE_0(p) range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) &gt;&gt; kNumMoveBits)); NORMALIZE;
+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt &gt;&gt; kNumMoveBits)); NORMALIZE;
+
+int Bcj2_Decode(
+    const Byte *buf0, SizeT size0,
+    const Byte *buf1, SizeT size1,
+    const Byte *buf2, SizeT size2,
+    const Byte *buf3, SizeT size3,
+    Byte *outBuf, SizeT outSize)
+{
+  CProb p[256 + 2];
+  SizeT inPos = 0, outPos = 0;
+
+  const Byte *buffer, *bufferLim;
+  UInt32 range, code;
+  Byte prevByte = 0;
+
+  unsigned int i;
+  for (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++)
+    p[i] = kBitModelTotal &gt;&gt; 1;
+
+  buffer = buf3;
+  bufferLim = buffer + size3;
+  RC_INIT2
+
+  if (outSize == 0)
+    return SZ_OK;
+
+  for (;;)
+  {
+    Byte b;
+    CProb *prob;
+    UInt32 bound;
+    UInt32 ttt;
+
+    SizeT limit = size0 - inPos;
+    if (outSize - outPos &lt; limit)
+      limit = outSize - outPos;
+    while (limit != 0)
+    {
+      Byte b = buf0[inPos];
+      outBuf[outPos++] = b;
+      if (IsJ(prevByte, b))
+        break;
+      inPos++;
+      prevByte = b;
+      limit--;
+    }
+
+    if (limit == 0 || outPos == outSize)
+      break;
+
+    b = buf0[inPos++];
+
+    if (b == 0xE8)
+      prob = p + prevByte;
+    else if (b == 0xE9)
+      prob = p + 256;
+    else
+      prob = p + 257;
+
+    IF_BIT_0(prob)
+    {
+      UPDATE_0(prob)
+      prevByte = b;
+    }
+    else
+    {
+      UInt32 dest;
+      const Byte *v;
+      UPDATE_1(prob)
+      if (b == 0xE8)
+      {
+        v = buf1;
+        if (size1 &lt; 4)
+          return SZ_ERROR_DATA;
+        buf1 += 4;
+        size1 -= 4;
+      }
+      else
+      {
+        v = buf2;
+        if (size2 &lt; 4)
+          return SZ_ERROR_DATA;
+        buf2 += 4;
+        size2 -= 4;
+      }
+      dest = (((UInt32)v[0] &lt;&lt; 24) | ((UInt32)v[1] &lt;&lt; 16) |
+          ((UInt32)v[2] &lt;&lt; 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
+      outBuf[outPos++] = (Byte)dest;
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = (Byte)(dest &gt;&gt; 8);
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = (Byte)(dest &gt;&gt; 16);
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = prevByte = (Byte)(dest &gt;&gt; 24);
+    }
+  }
+  return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,32 +0,0 @@
-/* Bcj2.h -- Converter for x86 code (BCJ2)
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#ifndef __BCJ2_H
-#define __BCJ2_H
-
-#include &quot;Types.h&quot;
-
-/*
-Conditions:
-  outSize &lt;= FullOutputSize,
-  where FullOutputSize is full size of output stream of x86_2 filter.
-
-If buf0 overlaps outBuf, there are two required conditions:
-  1) (buf0 &gt;= outBuf)
-  2) (buf0 + size0 &gt;= outBuf + FullOutputSize).
-
-Returns:
-  SZ_OK
-  SZ_ERROR_DATA - Data error
-*/
-
-int Bcj2_Decode(
-    const Byte *buf0, SizeT size0,
-    const Byte *buf1, SizeT size1,
-    const Byte *buf2, SizeT size2,
-    const Byte *buf3, SizeT size3,
-    Byte *outBuf, SizeT outSize);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bcj2.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,32 @@
+/* Bcj2.h -- Converter for x86 code (BCJ2)
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#ifndef __BCJ2_H
+#define __BCJ2_H
+
+#include &quot;Types.h&quot;
+
+/*
+Conditions:
+  outSize &lt;= FullOutputSize,
+  where FullOutputSize is full size of output stream of x86_2 filter.
+
+If buf0 overlaps outBuf, there are two required conditions:
+  1) (buf0 &gt;= outBuf)
+  2) (buf0 + size0 &gt;= outBuf + FullOutputSize).
+
+Returns:
+  SZ_OK
+  SZ_ERROR_DATA - Data error
+*/
+
+int Bcj2_Decode(
+    const Byte *buf0, SizeT size0,
+    const Byte *buf1, SizeT size1,
+    const Byte *buf2, SizeT size2,
+    const Byte *buf3, SizeT size3,
+    Byte *outBuf, SizeT outSize);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,135 +0,0 @@
-/* Bra.c -- converters for RISC  code
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#include &quot;Bra.h&quot;
-
-SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  SizeT i;
-  if (size &lt; 4)
-    return 0;
-  size -= 4;
-  ip += 8;
-  for (i = 0; i &lt;= size; i += 4)
-  {
-    if (data[i + 3] == 0xEB)
-    {
-      UInt32 dest;
-      UInt32 src = ((UInt32)data[i + 2] &lt;&lt; 16) | ((UInt32)data[i + 1] &lt;&lt; 8) | (data[i + 0]);
-      src &lt;&lt;= 2;
-      if (encoding)
-        dest = ip + (UInt32)i + src;
-      else
-        dest = src - (ip + (UInt32)i);
-      dest &gt;&gt;= 2;
-      data[i + 2] = (Byte)(dest &gt;&gt; 16);
-      data[i + 1] = (Byte)(dest &gt;&gt; 8);
-      data[i + 0] = (Byte)dest;
-    }
-  }
-  return i;
-}
-
-SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  SizeT i;
-  if (size &lt; 4)
-    return 0;
-  size -= 4;
-  ip += 4;
-  for (i = 0; i &lt;= size; i += 2)
-  {
-    if ((data[i + 1] &amp; 0xF8) == 0xF0 &amp;&amp;
-        (data[i + 3] &amp; 0xF8) == 0xF8)
-    {
-      UInt32 dest;
-      UInt32 src =
-        (((UInt32)data[i + 1] &amp; 0x7) &lt;&lt; 19) |
-        ((UInt32)data[i + 0] &lt;&lt; 11) |
-        (((UInt32)data[i + 3] &amp; 0x7) &lt;&lt; 8) |
-        (data[i + 2]);
-      
-      src &lt;&lt;= 1;
-      if (encoding)
-        dest = ip + (UInt32)i + src;
-      else
-        dest = src - (ip + (UInt32)i);
-      dest &gt;&gt;= 1;
-      
-      data[i + 1] = (Byte)(0xF0 | ((dest &gt;&gt; 19) &amp; 0x7));
-      data[i + 0] = (Byte)(dest &gt;&gt; 11);
-      data[i + 3] = (Byte)(0xF8 | ((dest &gt;&gt; 8) &amp; 0x7));
-      data[i + 2] = (Byte)dest;
-      i += 2;
-    }
-  }
-  return i;
-}
-
-SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  SizeT i;
-  if (size &lt; 4)
-    return 0;
-  size -= 4;
-  for (i = 0; i &lt;= size; i += 4)
-  {
-    if ((data[i] &gt;&gt; 2) == 0x12 &amp;&amp; (data[i + 3] &amp; 3) == 1)
-    {
-      UInt32 src = ((UInt32)(data[i + 0] &amp; 3) &lt;&lt; 24) |
-        ((UInt32)data[i + 1] &lt;&lt; 16) |
-        ((UInt32)data[i + 2] &lt;&lt; 8) |
-        ((UInt32)data[i + 3] &amp; (~3));
-      
-      UInt32 dest;
-      if (encoding)
-        dest = ip + (UInt32)i + src;
-      else
-        dest = src - (ip + (UInt32)i);
-      data[i + 0] = (Byte)(0x48 | ((dest &gt;&gt; 24) &amp;  0x3));
-      data[i + 1] = (Byte)(dest &gt;&gt; 16);
-      data[i + 2] = (Byte)(dest &gt;&gt; 8);
-      data[i + 3] &amp;= 0x3;
-      data[i + 3] |= dest;
-    }
-  }
-  return i;
-}
-
-SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  UInt32 i;
-  if (size &lt; 4)
-    return 0;
-  size -= 4;
-  for (i = 0; i &lt;= size; i += 4)
-  {
-    if (data[i] == 0x40 &amp;&amp; (data[i + 1] &amp; 0xC0) == 0x00 ||
-        data[i] == 0x7F &amp;&amp; (data[i + 1] &amp; 0xC0) == 0xC0)
-    {
-      UInt32 src =
-        ((UInt32)data[i + 0] &lt;&lt; 24) |
-        ((UInt32)data[i + 1] &lt;&lt; 16) |
-        ((UInt32)data[i + 2] &lt;&lt; 8) |
-        ((UInt32)data[i + 3]);
-      UInt32 dest;
-      
-      src &lt;&lt;= 2;
-      if (encoding)
-        dest = ip + i + src;
-      else
-        dest = src - (ip + i);
-      dest &gt;&gt;= 2;
-      
-      dest = (((0 - ((dest &gt;&gt; 22) &amp; 1)) &lt;&lt; 22) &amp; 0x3FFFFFFF) | (dest &amp; 0x3FFFFF) | 0x40000000;
-
-      data[i + 0] = (Byte)(dest &gt;&gt; 24);
-      data[i + 1] = (Byte)(dest &gt;&gt; 16);
-      data[i + 2] = (Byte)(dest &gt;&gt; 8);
-      data[i + 3] = (Byte)dest;
-    }
-  }
-  return i;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,135 @@
+/* Bra.c -- converters for RISC  code
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#include &quot;Bra.h&quot;
+
+SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size &lt; 4)
+    return 0;
+  size -= 4;
+  ip += 8;
+  for (i = 0; i &lt;= size; i += 4)
+  {
+    if (data[i + 3] == 0xEB)
+    {
+      UInt32 dest;
+      UInt32 src = ((UInt32)data[i + 2] &lt;&lt; 16) | ((UInt32)data[i + 1] &lt;&lt; 8) | (data[i + 0]);
+      src &lt;&lt;= 2;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      dest &gt;&gt;= 2;
+      data[i + 2] = (Byte)(dest &gt;&gt; 16);
+      data[i + 1] = (Byte)(dest &gt;&gt; 8);
+      data[i + 0] = (Byte)dest;
+    }
+  }
+  return i;
+}
+
+SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size &lt; 4)
+    return 0;
+  size -= 4;
+  ip += 4;
+  for (i = 0; i &lt;= size; i += 2)
+  {
+    if ((data[i + 1] &amp; 0xF8) == 0xF0 &amp;&amp;
+        (data[i + 3] &amp; 0xF8) == 0xF8)
+    {
+      UInt32 dest;
+      UInt32 src =
+        (((UInt32)data[i + 1] &amp; 0x7) &lt;&lt; 19) |
+        ((UInt32)data[i + 0] &lt;&lt; 11) |
+        (((UInt32)data[i + 3] &amp; 0x7) &lt;&lt; 8) |
+        (data[i + 2]);
+      
+      src &lt;&lt;= 1;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      dest &gt;&gt;= 1;
+      
+      data[i + 1] = (Byte)(0xF0 | ((dest &gt;&gt; 19) &amp; 0x7));
+      data[i + 0] = (Byte)(dest &gt;&gt; 11);
+      data[i + 3] = (Byte)(0xF8 | ((dest &gt;&gt; 8) &amp; 0x7));
+      data[i + 2] = (Byte)dest;
+      i += 2;
+    }
+  }
+  return i;
+}
+
+SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size &lt; 4)
+    return 0;
+  size -= 4;
+  for (i = 0; i &lt;= size; i += 4)
+  {
+    if ((data[i] &gt;&gt; 2) == 0x12 &amp;&amp; (data[i + 3] &amp; 3) == 1)
+    {
+      UInt32 src = ((UInt32)(data[i + 0] &amp; 3) &lt;&lt; 24) |
+        ((UInt32)data[i + 1] &lt;&lt; 16) |
+        ((UInt32)data[i + 2] &lt;&lt; 8) |
+        ((UInt32)data[i + 3] &amp; (~3));
+      
+      UInt32 dest;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      data[i + 0] = (Byte)(0x48 | ((dest &gt;&gt; 24) &amp;  0x3));
+      data[i + 1] = (Byte)(dest &gt;&gt; 16);
+      data[i + 2] = (Byte)(dest &gt;&gt; 8);
+      data[i + 3] &amp;= 0x3;
+      data[i + 3] |= dest;
+    }
+  }
+  return i;
+}
+
+SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  UInt32 i;
+  if (size &lt; 4)
+    return 0;
+  size -= 4;
+  for (i = 0; i &lt;= size; i += 4)
+  {
+    if (data[i] == 0x40 &amp;&amp; (data[i + 1] &amp; 0xC0) == 0x00 ||
+        data[i] == 0x7F &amp;&amp; (data[i + 1] &amp; 0xC0) == 0xC0)
+    {
+      UInt32 src =
+        ((UInt32)data[i + 0] &lt;&lt; 24) |
+        ((UInt32)data[i + 1] &lt;&lt; 16) |
+        ((UInt32)data[i + 2] &lt;&lt; 8) |
+        ((UInt32)data[i + 3]);
+      UInt32 dest;
+      
+      src &lt;&lt;= 2;
+      if (encoding)
+        dest = ip + i + src;
+      else
+        dest = src - (ip + i);
+      dest &gt;&gt;= 2;
+      
+      dest = (((0 - ((dest &gt;&gt; 22) &amp; 1)) &lt;&lt; 22) &amp; 0x3FFFFFFF) | (dest &amp; 0x3FFFFF) | 0x40000000;
+
+      data[i + 0] = (Byte)(dest &gt;&gt; 24);
+      data[i + 1] = (Byte)(dest &gt;&gt; 16);
+      data[i + 2] = (Byte)(dest &gt;&gt; 8);
+      data[i + 3] = (Byte)dest;
+    }
+  }
+  return i;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,62 +0,0 @@
-/* Bra.h -- Branch converters for executables
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaDec.h for license options */
-
-#ifndef __BRA_H
-#define __BRA_H
-
-#include &quot;Types.h&quot;
-
-/*
-These functions convert relative addresses to absolute addresses
-in CALL instructions to increase the compression ratio.
-  
-  In:
-    data     - data buffer
-    size     - size of data
-    ip       - current virtual Instruction Pinter (IP) value
-    state    - state variable for x86 converter
-    encoding - 0 (for decoding), 1 (for encoding)
-  
-  Out:
-    state    - state variable for x86 converter
-
-  Returns:
-    The number of processed bytes. If you call these functions with multiple calls,
-    you must start next call with first byte after block of processed bytes.
-  
-  Type   Endian  Alignment  LookAhead
-  
-  x86    little      1          4
-  ARMT   little      2          2
-  ARM    little      4          0
-  PPC     big        4          0
-  SPARC   big        4          0
-  IA64   little     16          0
-
-  size must be &gt;= Alignment + LookAhead, if it's not last block.
-  If (size &lt; Alignment + LookAhead), converter returns 0.
-
-  Example:
-
-    UInt32 ip = 0;
-    for ()
-    {
-      // size must be &gt;= Alignment + LookAhead, if it's not last block
-      SizeT processed = Convert(data, size, ip, 1);
-      data += processed;
-      size -= processed;
-      ip += processed;
-    }
-*/
-
-#define x86_Convert_Init(state) { state = 0; }
-SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
-SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,62 @@
+/* Bra.h -- Branch converters for executables
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaDec.h for license options */
+
+#ifndef __BRA_H
+#define __BRA_H
+
+#include &quot;Types.h&quot;
+
+/*
+These functions convert relative addresses to absolute addresses
+in CALL instructions to increase the compression ratio.
+  
+  In:
+    data     - data buffer
+    size     - size of data
+    ip       - current virtual Instruction Pinter (IP) value
+    state    - state variable for x86 converter
+    encoding - 0 (for decoding), 1 (for encoding)
+  
+  Out:
+    state    - state variable for x86 converter
+
+  Returns:
+    The number of processed bytes. If you call these functions with multiple calls,
+    you must start next call with first byte after block of processed bytes.
+  
+  Type   Endian  Alignment  LookAhead
+  
+  x86    little      1          4
+  ARMT   little      2          2
+  ARM    little      4          0
+  PPC     big        4          0
+  SPARC   big        4          0
+  IA64   little     16          0
+
+  size must be &gt;= Alignment + LookAhead, if it's not last block.
+  If (size &lt; Alignment + LookAhead), converter returns 0.
+
+  Example:
+
+    UInt32 ip = 0;
+    for ()
+    {
+      // size must be &gt;= Alignment + LookAhead, if it's not last block
+      SizeT processed = Convert(data, size, ip, 1);
+      data += processed;
+      size -= processed;
+      ip += processed;
+    }
+*/
+
+#define x86_Convert_Init(state) { state = 0; }
+SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
+SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,87 +0,0 @@
-/* Bra86.c -- converter for x86 code (BCJ)
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#include &quot;Bra.h&quot;
-
-#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
-
-const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
-const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
-
-SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
-{
-  SizeT bufferPos = 0, prevPosT;
-  UInt32 prevMask = *state &amp; 0x7;
-  if (size &lt; 5)
-    return 0;
-  ip += 5;
-  prevPosT = (SizeT)0 - 1;
-
-  for (;;)
-  {
-    Byte *p = data + bufferPos;
-    Byte *limit = data + size - 4;
-    for (; p &lt; limit; p++)
-      if ((*p &amp; 0xFE) == 0xE8)
-        break;
-    bufferPos = (SizeT)(p - data);
-    if (p &gt;= limit)
-      break;
-    prevPosT = bufferPos - prevPosT;
-    if (prevPosT &gt; 3)
-      prevMask = 0;
-    else
-    {
-      prevMask = (prevMask &lt;&lt; ((int)prevPosT - 1)) &amp; 0x7;
-      if (prevMask != 0)
-      {
-        Byte b = p[4 - kMaskToBitNumber[prevMask]];
-        if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
-        {
-          prevPosT = bufferPos;
-          prevMask = ((prevMask &lt;&lt; 1) &amp; 0x7) | 1;
-          bufferPos++;
-          continue;
-        }
-      }
-    }
-    prevPosT = bufferPos;
-
-    if (Test86MSByte(p[4]))
-    {
-      UInt32 src = ((UInt32)p[4] &lt;&lt; 24) | ((UInt32)p[3] &lt;&lt; 16) | ((UInt32)p[2] &lt;&lt; 8) | ((UInt32)p[1]);
-      UInt32 dest;
-      for (;;)
-      {
-        Byte b;
-        int index;
-        if (encoding)
-          dest = (ip + (UInt32)bufferPos) + src;
-        else
-          dest = src - (ip + (UInt32)bufferPos);
-        if (prevMask == 0)
-          break;
-        index = kMaskToBitNumber[prevMask] * 8;
-        b = (Byte)(dest &gt;&gt; (24 - index));
-        if (!Test86MSByte(b))
-          break;
-        src = dest ^ ((1 &lt;&lt; (32 - index)) - 1);
-      }
-      p[4] = (Byte)(~(((dest &gt;&gt; 24) &amp; 1) - 1));
-      p[3] = (Byte)(dest &gt;&gt; 16);
-      p[2] = (Byte)(dest &gt;&gt; 8);
-      p[1] = (Byte)dest;
-      bufferPos += 5;
-    }
-    else
-    {
-      prevMask = ((prevMask &lt;&lt; 1) &amp; 0x7) | 1;
-      bufferPos++;
-    }
-  }
-  prevPosT = bufferPos - prevPosT;
-  *state = ((prevPosT &gt; 3) ? 0 : ((prevMask &lt;&lt; ((int)prevPosT - 1)) &amp; 0x7));
-  return bufferPos;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Bra86.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,87 @@
+/* Bra86.c -- converter for x86 code (BCJ)
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#include &quot;Bra.h&quot;
+
+#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
+
+const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
+const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
+
+SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
+{
+  SizeT bufferPos = 0, prevPosT;
+  UInt32 prevMask = *state &amp; 0x7;
+  if (size &lt; 5)
+    return 0;
+  ip += 5;
+  prevPosT = (SizeT)0 - 1;
+
+  for (;;)
+  {
+    Byte *p = data + bufferPos;
+    Byte *limit = data + size - 4;
+    for (; p &lt; limit; p++)
+      if ((*p &amp; 0xFE) == 0xE8)
+        break;
+    bufferPos = (SizeT)(p - data);
+    if (p &gt;= limit)
+      break;
+    prevPosT = bufferPos - prevPosT;
+    if (prevPosT &gt; 3)
+      prevMask = 0;
+    else
+    {
+      prevMask = (prevMask &lt;&lt; ((int)prevPosT - 1)) &amp; 0x7;
+      if (prevMask != 0)
+      {
+        Byte b = p[4 - kMaskToBitNumber[prevMask]];
+        if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
+        {
+          prevPosT = bufferPos;
+          prevMask = ((prevMask &lt;&lt; 1) &amp; 0x7) | 1;
+          bufferPos++;
+          continue;
+        }
+      }
+    }
+    prevPosT = bufferPos;
+
+    if (Test86MSByte(p[4]))
+    {
+      UInt32 src = ((UInt32)p[4] &lt;&lt; 24) | ((UInt32)p[3] &lt;&lt; 16) | ((UInt32)p[2] &lt;&lt; 8) | ((UInt32)p[1]);
+      UInt32 dest;
+      for (;;)
+      {
+        Byte b;
+        int index;
+        if (encoding)
+          dest = (ip + (UInt32)bufferPos) + src;
+        else
+          dest = src - (ip + (UInt32)bufferPos);
+        if (prevMask == 0)
+          break;
+        index = kMaskToBitNumber[prevMask] * 8;
+        b = (Byte)(dest &gt;&gt; (24 - index));
+        if (!Test86MSByte(b))
+          break;
+        src = dest ^ ((1 &lt;&lt; (32 - index)) - 1);
+      }
+      p[4] = (Byte)(~(((dest &gt;&gt; 24) &amp; 1) - 1));
+      p[3] = (Byte)(dest &gt;&gt; 16);
+      p[2] = (Byte)(dest &gt;&gt; 8);
+      p[1] = (Byte)dest;
+      bufferPos += 5;
+    }
+    else
+    {
+      prevMask = ((prevMask &lt;&lt; 1) &amp; 0x7) | 1;
+      bufferPos++;
+    }
+  }
+  prevPosT = bufferPos - prevPosT;
+  *state = ((prevPosT &gt; 3) ? 0 : ((prevMask &lt;&lt; ((int)prevPosT - 1)) &amp; 0x7));
+  return bufferPos;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,69 +0,0 @@
-/* BraIA64.c -- converter for IA-64 code
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read Bra.h for license options */
-
-#include &quot;Bra.h&quot;
-
-static const Byte kBranchTable[32] =
-{
-  0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0,
-  4, 4, 6, 6, 0, 0, 7, 7,
-  4, 4, 0, 0, 4, 4, 0, 0
-};
-
-SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
-{
-  SizeT i;
-  if (size &lt; 16)
-    return 0;
-  size -= 16;
-  for (i = 0; i &lt;= size; i += 16)
-  {
-    UInt32 instrTemplate = data[i] &amp; 0x1F;
-    UInt32 mask = kBranchTable[instrTemplate];
-    UInt32 bitPos = 5;
-    int slot;
-    for (slot = 0; slot &lt; 3; slot++, bitPos += 41)
-    {
-      UInt32 bytePos, bitRes;
-      UInt64 instruction, instNorm;
-      int j;
-      if (((mask &gt;&gt; slot) &amp; 1) == 0)
-        continue;
-      bytePos = (bitPos &gt;&gt; 3);
-      bitRes = bitPos &amp; 0x7;
-      instruction = 0;
-      for (j = 0; j &lt; 6; j++)
-        instruction += (UInt64)data[i + j + bytePos] &lt;&lt; (8 * j);
-
-      instNorm = instruction &gt;&gt; bitRes;
-      if (((instNorm &gt;&gt; 37) &amp; 0xF) == 0x5 &amp;&amp; ((instNorm &gt;&gt; 9) &amp; 0x7) == 0)
-      {
-        UInt32 src = (UInt32)((instNorm &gt;&gt; 13) &amp; 0xFFFFF);
-        UInt32 dest;
-        src |= ((UInt32)(instNorm &gt;&gt; 36) &amp; 1) &lt;&lt; 20;
-        
-        src &lt;&lt;= 4;
-        
-        if (encoding)
-          dest = ip + (UInt32)i + src;
-        else
-          dest = src - (ip + (UInt32)i);
-        
-        dest &gt;&gt;= 4;
-        
-        instNorm &amp;= ~((UInt64)(0x8FFFFF) &lt;&lt; 13);
-        instNorm |= ((UInt64)(dest &amp; 0xFFFFF) &lt;&lt; 13);
-        instNorm |= ((UInt64)(dest &amp; 0x100000) &lt;&lt; (36 - 20));
-        
-        instruction &amp;= (1 &lt;&lt; bitRes) - 1;
-        instruction |= (instNorm &lt;&lt; bitRes);
-        for (j = 0; j &lt; 6; j++)
-          data[i + j + bytePos] = (Byte)(instruction &gt;&gt; (8 * j));
-      }
-    }
-  }
-  return i;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/BraIA64.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,69 @@
+/* BraIA64.c -- converter for IA-64 code
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read Bra.h for license options */
+
+#include &quot;Bra.h&quot;
+
+static const Byte kBranchTable[32] =
+{
+  0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  4, 4, 6, 6, 0, 0, 7, 7,
+  4, 4, 0, 0, 4, 4, 0, 0
+};
+
+SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size &lt; 16)
+    return 0;
+  size -= 16;
+  for (i = 0; i &lt;= size; i += 16)
+  {
+    UInt32 instrTemplate = data[i] &amp; 0x1F;
+    UInt32 mask = kBranchTable[instrTemplate];
+    UInt32 bitPos = 5;
+    int slot;
+    for (slot = 0; slot &lt; 3; slot++, bitPos += 41)
+    {
+      UInt32 bytePos, bitRes;
+      UInt64 instruction, instNorm;
+      int j;
+      if (((mask &gt;&gt; slot) &amp; 1) == 0)
+        continue;
+      bytePos = (bitPos &gt;&gt; 3);
+      bitRes = bitPos &amp; 0x7;
+      instruction = 0;
+      for (j = 0; j &lt; 6; j++)
+        instruction += (UInt64)data[i + j + bytePos] &lt;&lt; (8 * j);
+
+      instNorm = instruction &gt;&gt; bitRes;
+      if (((instNorm &gt;&gt; 37) &amp; 0xF) == 0x5 &amp;&amp; ((instNorm &gt;&gt; 9) &amp; 0x7) == 0)
+      {
+        UInt32 src = (UInt32)((instNorm &gt;&gt; 13) &amp; 0xFFFFF);
+        UInt32 dest;
+        src |= ((UInt32)(instNorm &gt;&gt; 36) &amp; 1) &lt;&lt; 20;
+        
+        src &lt;&lt;= 4;
+        
+        if (encoding)
+          dest = ip + (UInt32)i + src;
+        else
+          dest = src - (ip + (UInt32)i);
+        
+        dest &gt;&gt;= 4;
+        
+        instNorm &amp;= ~((UInt64)(0x8FFFFF) &lt;&lt; 13);
+        instNorm |= ((UInt64)(dest &amp; 0xFFFFF) &lt;&lt; 13);
+        instNorm |= ((UInt64)(dest &amp; 0x100000) &lt;&lt; (36 - 20));
+        
+        instruction &amp;= (1 &lt;&lt; bitRes) - 1;
+        instruction |= (instNorm &lt;&lt; bitRes);
+        for (j = 0; j &lt; 6; j++)
+          data[i + j + bytePos] = (Byte)(instruction &gt;&gt; (8 * j));
+      }
+    }
+  }
+  return i;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,69 +0,0 @@
-/* CpuArch.h
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __CPUARCH_H
-#define __CPUARCH_H
-
-/*
-LITTLE_ENDIAN_UNALIGN means:
-  1) CPU is LITTLE_ENDIAN
-  2) it's allowed to make unaligned memory accesses
-if LITTLE_ENDIAN_UNALIGN is not defined, it means that we don't know
-about these properties of platform.
-*/
-
-#if defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) || defined(__i386__) || defined(__x86_64__)
-#define LITTLE_ENDIAN_UNALIGN
-#endif
-
-#ifdef LITTLE_ENDIAN_UNALIGN
-
-#define GetUi16(p) (*(const UInt16 *)(p))
-#define GetUi32(p) (*(const UInt32 *)(p))
-#define GetUi64(p) (*(const UInt64 *)(p))
-#define SetUi32(p, d) *(UInt32 *)(p) = (d);
-
-#else
-
-#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] &lt;&lt; 8))
-
-#define GetUi32(p) ( \
-             ((const Byte *)(p))[0]        | \
-    ((UInt32)((const Byte *)(p))[1] &lt;&lt;  8) | \
-    ((UInt32)((const Byte *)(p))[2] &lt;&lt; 16) | \
-    ((UInt32)((const Byte *)(p))[3] &lt;&lt; 24))
-
-#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) &lt;&lt; 32))
-
-#define SetUi32(p, d) { UInt32 _x_ = (d); \
-    ((Byte *)(p))[0] = (Byte)_x_; \
-    ((Byte *)(p))[1] = (Byte)(_x_ &gt;&gt; 8); \
-    ((Byte *)(p))[2] = (Byte)(_x_ &gt;&gt; 16); \
-    ((Byte *)(p))[3] = (Byte)(_x_ &gt;&gt; 24); }
-
-#endif
-
-#if defined(LITTLE_ENDIAN_UNALIGN) &amp;&amp; defined(_WIN64) &amp;&amp; (_MSC_VER &gt;= 1300)
-
-#pragma intrinsic(_byteswap_ulong)
-#pragma intrinsic(_byteswap_uint64)
-#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
-#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))
-
-#else
-
-#define GetBe32(p) ( \
-    ((UInt32)((const Byte *)(p))[0] &lt;&lt; 24) | \
-    ((UInt32)((const Byte *)(p))[1] &lt;&lt; 16) | \
-    ((UInt32)((const Byte *)(p))[2] &lt;&lt;  8) | \
-             ((const Byte *)(p))[3] )
-
-#define GetBe64(p) (((UInt64)GetBe32(p) &lt;&lt; 32) | GetBe32(((const Byte *)(p)) + 4))
-
-#endif
-
-#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] &lt;&lt; 8) | ((const Byte *)(p))[1])
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/CpuArch.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,69 @@
+/* CpuArch.h
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __CPUARCH_H
+#define __CPUARCH_H
+
+/*
+LITTLE_ENDIAN_UNALIGN means:
+  1) CPU is LITTLE_ENDIAN
+  2) it's allowed to make unaligned memory accesses
+if LITTLE_ENDIAN_UNALIGN is not defined, it means that we don't know
+about these properties of platform.
+*/
+
+#if defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) || defined(__i386__) || defined(__x86_64__)
+#define LITTLE_ENDIAN_UNALIGN
+#endif
+
+#ifdef LITTLE_ENDIAN_UNALIGN
+
+#define GetUi16(p) (*(const UInt16 *)(p))
+#define GetUi32(p) (*(const UInt32 *)(p))
+#define GetUi64(p) (*(const UInt64 *)(p))
+#define SetUi32(p, d) *(UInt32 *)(p) = (d);
+
+#else
+
+#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] &lt;&lt; 8))
+
+#define GetUi32(p) ( \
+             ((const Byte *)(p))[0]        | \
+    ((UInt32)((const Byte *)(p))[1] &lt;&lt;  8) | \
+    ((UInt32)((const Byte *)(p))[2] &lt;&lt; 16) | \
+    ((UInt32)((const Byte *)(p))[3] &lt;&lt; 24))
+
+#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) &lt;&lt; 32))
+
+#define SetUi32(p, d) { UInt32 _x_ = (d); \
+    ((Byte *)(p))[0] = (Byte)_x_; \
+    ((Byte *)(p))[1] = (Byte)(_x_ &gt;&gt; 8); \
+    ((Byte *)(p))[2] = (Byte)(_x_ &gt;&gt; 16); \
+    ((Byte *)(p))[3] = (Byte)(_x_ &gt;&gt; 24); }
+
+#endif
+
+#if defined(LITTLE_ENDIAN_UNALIGN) &amp;&amp; defined(_WIN64) &amp;&amp; (_MSC_VER &gt;= 1300)
+
+#pragma intrinsic(_byteswap_ulong)
+#pragma intrinsic(_byteswap_uint64)
+#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
+#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))
+
+#else
+
+#define GetBe32(p) ( \
+    ((UInt32)((const Byte *)(p))[0] &lt;&lt; 24) | \
+    ((UInt32)((const Byte *)(p))[1] &lt;&lt; 16) | \
+    ((UInt32)((const Byte *)(p))[2] &lt;&lt;  8) | \
+             ((const Byte *)(p))[3] )
+
+#define GetBe64(p) (((UInt64)GetBe32(p) &lt;&lt; 32) | GetBe32(((const Byte *)(p)) + 4))
+
+#endif
+
+#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] &lt;&lt; 8) | ((const Byte *)(p))[1])
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,753 +0,0 @@
-/* LzFind.c  -- Match finder for LZ algorithms
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#include &lt;string.h&gt;
-
-#include &quot;LzFind.h&quot;
-#include &quot;LzHash.h&quot;
-
-#define kEmptyHashValue 0
-#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
-#define kNormalizeStepMin (1 &lt;&lt; 10) /* it must be power of 2 */
-#define kNormalizeMask (~(kNormalizeStepMin - 1))
-#define kMaxHistorySize ((UInt32)3 &lt;&lt; 30)
-
-#define kStartMaxLen 3
-
-static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
-{
-  if (!p-&gt;directInput)
-  {
-    alloc-&gt;Free(alloc, p-&gt;bufferBase);
-    p-&gt;bufferBase = 0;
-  }
-}
-
-/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be &lt; 4G) */
-
-static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
-{
-  UInt32 blockSize = p-&gt;keepSizeBefore + p-&gt;keepSizeAfter + keepSizeReserv;
-  if (p-&gt;directInput)
-  {
-    p-&gt;blockSize = blockSize;
-    return 1;
-  }
-  if (p-&gt;bufferBase == 0 || p-&gt;blockSize != blockSize)
-  {
-    LzInWindow_Free(p, alloc);
-    p-&gt;blockSize = blockSize;
-    p-&gt;bufferBase = (Byte *)alloc-&gt;Alloc(alloc, (size_t)blockSize);
-  }
-  return (p-&gt;bufferBase != 0);
-}
-
-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p-&gt;buffer; }
-Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p-&gt;buffer[index]; }
-
-UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p-&gt;streamPos - p-&gt;pos; }
-
-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-{
-  p-&gt;posLimit -= subValue;
-  p-&gt;pos -= subValue;
-  p-&gt;streamPos -= subValue;
-}
-
-static void MatchFinder_ReadBlock(CMatchFinder *p)
-{
-  if (p-&gt;streamEndWasReached || p-&gt;result != SZ_OK)
-    return;
-  for (;;)
-  {
-    Byte *dest = p-&gt;buffer + (p-&gt;streamPos - p-&gt;pos);
-    size_t size = (p-&gt;bufferBase + p-&gt;blockSize - dest);
-    if (size == 0)
-      return;
-    p-&gt;result = p-&gt;stream-&gt;Read(p-&gt;stream, dest, &amp;size);
-    if (p-&gt;result != SZ_OK)
-      return;
-    if (size == 0)
-    {
-      p-&gt;streamEndWasReached = 1;
-      return;
-    }
-    p-&gt;streamPos += (UInt32)size;
-    if (p-&gt;streamPos - p-&gt;pos &gt; p-&gt;keepSizeAfter)
-      return;
-  }
-}
-
-void MatchFinder_MoveBlock(CMatchFinder *p)
-{
-  memmove(p-&gt;bufferBase,
-    p-&gt;buffer - p-&gt;keepSizeBefore,
-    (size_t)(p-&gt;streamPos - p-&gt;pos + p-&gt;keepSizeBefore));
-  p-&gt;buffer = p-&gt;bufferBase + p-&gt;keepSizeBefore;
-}
-
-int MatchFinder_NeedMove(CMatchFinder *p)
-{
-  /* if (p-&gt;streamEndWasReached) return 0; */
-  return ((size_t)(p-&gt;bufferBase + p-&gt;blockSize - p-&gt;buffer) &lt;= p-&gt;keepSizeAfter);
-}
-
-void MatchFinder_ReadIfRequired(CMatchFinder *p)
-{
-  if (p-&gt;streamEndWasReached)
-    return;
-  if (p-&gt;keepSizeAfter &gt;= p-&gt;streamPos - p-&gt;pos)
-    MatchFinder_ReadBlock(p);
-}
-
-static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
-{
-  if (MatchFinder_NeedMove(p))
-    MatchFinder_MoveBlock(p);
-  MatchFinder_ReadBlock(p);
-}
-
-static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
-{
-  p-&gt;cutValue = 32;
-  p-&gt;btMode = 1;
-  p-&gt;numHashBytes = 4;
-  /* p-&gt;skipModeBits = 0; */
-  p-&gt;directInput = 0;
-  p-&gt;bigHash = 0;
-}
-
-#define kCrcPoly 0xEDB88320
-
-void MatchFinder_Construct(CMatchFinder *p)
-{
-  UInt32 i;
-  p-&gt;bufferBase = 0;
-  p-&gt;directInput = 0;
-  p-&gt;hash = 0;
-  MatchFinder_SetDefaultSettings(p);
-
-  for (i = 0; i &lt; 256; i++)
-  {
-    UInt32 r = i;
-    int j;
-    for (j = 0; j &lt; 8; j++)
-      r = (r &gt;&gt; 1) ^ (kCrcPoly &amp; ~((r &amp; 1) - 1));
-    p-&gt;crc[i] = r;
-  }
-}
-
-static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;hash);
-  p-&gt;hash = 0;
-}
-
-void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
-{
-  MatchFinder_FreeThisClassMemory(p, alloc);
-  LzInWindow_Free(p, alloc);
-}
-
-static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
-{
-  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
-  if (sizeInBytes / sizeof(CLzRef) != num)
-    return 0;
-  return (CLzRef *)alloc-&gt;Alloc(alloc, sizeInBytes);
-}
-
-int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-    ISzAlloc *alloc)
-{
-  UInt32 sizeReserv;
-  if (historySize &gt; kMaxHistorySize)
-  {
-    MatchFinder_Free(p, alloc);
-    return 0;
-  }
-  sizeReserv = historySize &gt;&gt; 1;
-  if (historySize &gt; ((UInt32)2 &lt;&lt; 30))
-    sizeReserv = historySize &gt;&gt; 2;
-  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 &lt;&lt; 19);
-
-  p-&gt;keepSizeBefore = historySize + keepAddBufferBefore + 1;
-  p-&gt;keepSizeAfter = matchMaxLen + keepAddBufferAfter;
-  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
-  if (LzInWindow_Create(p, sizeReserv, alloc))
-  {
-    UInt32 newCyclicBufferSize = (historySize /* &gt;&gt; p-&gt;skipModeBits */) + 1;
-    UInt32 hs;
-    p-&gt;matchMaxLen = matchMaxLen;
-    {
-      p-&gt;fixedHashSize = 0;
-      if (p-&gt;numHashBytes == 2)
-        hs = (1 &lt;&lt; 16) - 1;
-      else
-      {
-        hs = historySize - 1;
-        hs |= (hs &gt;&gt; 1);
-        hs |= (hs &gt;&gt; 2);
-        hs |= (hs &gt;&gt; 4);
-        hs |= (hs &gt;&gt; 8);
-        hs &gt;&gt;= 1;
-        /* hs &gt;&gt;= p-&gt;skipModeBits; */
-        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
-        if (hs &gt; (1 &lt;&lt; 24))
-        {
-          if (p-&gt;numHashBytes == 3)
-            hs = (1 &lt;&lt; 24) - 1;
-          else
-            hs &gt;&gt;= 1;
-        }
-      }
-      p-&gt;hashMask = hs;
-      hs++;
-      if (p-&gt;numHashBytes &gt; 2) p-&gt;fixedHashSize += kHash2Size;
-      if (p-&gt;numHashBytes &gt; 3) p-&gt;fixedHashSize += kHash3Size;
-      if (p-&gt;numHashBytes &gt; 4) p-&gt;fixedHashSize += kHash4Size;
-      hs += p-&gt;fixedHashSize;
-    }
-
-    {
-      UInt32 prevSize = p-&gt;hashSizeSum + p-&gt;numSons;
-      UInt32 newSize;
-      p-&gt;historySize = historySize;
-      p-&gt;hashSizeSum = hs;
-      p-&gt;cyclicBufferSize = newCyclicBufferSize;
-      p-&gt;numSons = (p-&gt;btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
-      newSize = p-&gt;hashSizeSum + p-&gt;numSons;
-      if (p-&gt;hash != 0 &amp;&amp; prevSize == newSize)
-        return 1;
-      MatchFinder_FreeThisClassMemory(p, alloc);
-      p-&gt;hash = AllocRefs(newSize, alloc);
-      if (p-&gt;hash != 0)
-      {
-        p-&gt;son = p-&gt;hash + p-&gt;hashSizeSum;
-        return 1;
-      }
-    }
-  }
-  MatchFinder_Free(p, alloc);
-  return 0;
-}
-
-static void MatchFinder_SetLimits(CMatchFinder *p)
-{
-  UInt32 limit = kMaxValForNormalize - p-&gt;pos;
-  UInt32 limit2 = p-&gt;cyclicBufferSize - p-&gt;cyclicBufferPos;
-  if (limit2 &lt; limit)
-    limit = limit2;
-  limit2 = p-&gt;streamPos - p-&gt;pos;
-  if (limit2 &lt;= p-&gt;keepSizeAfter)
-  {
-    if (limit2 &gt; 0)
-      limit2 = 1;
-  }
-  else
-    limit2 -= p-&gt;keepSizeAfter;
-  if (limit2 &lt; limit)
-    limit = limit2;
-  {
-    UInt32 lenLimit = p-&gt;streamPos - p-&gt;pos;
-    if (lenLimit &gt; p-&gt;matchMaxLen)
-      lenLimit = p-&gt;matchMaxLen;
-    p-&gt;lenLimit = lenLimit;
-  }
-  p-&gt;posLimit = p-&gt;pos + limit;
-}
-
-void MatchFinder_Init(CMatchFinder *p)
-{
-  UInt32 i;
-  for (i = 0; i &lt; p-&gt;hashSizeSum; i++)
-    p-&gt;hash[i] = kEmptyHashValue;
-  p-&gt;cyclicBufferPos = 0;
-  p-&gt;buffer = p-&gt;bufferBase;
-  p-&gt;pos = p-&gt;streamPos = p-&gt;cyclicBufferSize;
-  p-&gt;result = SZ_OK;
-  p-&gt;streamEndWasReached = 0;
-  MatchFinder_ReadBlock(p);
-  MatchFinder_SetLimits(p);
-}
-
-static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
-{
-  return (p-&gt;pos - p-&gt;historySize - 1) &amp; kNormalizeMask;
-}
-
-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
-{
-  UInt32 i;
-  for (i = 0; i &lt; numItems; i++)
-  {
-    UInt32 value = items[i];
-    if (value &lt;= subValue)
-      value = kEmptyHashValue;
-    else
-      value -= subValue;
-    items[i] = value;
-  }
-}
-
-static void MatchFinder_Normalize(CMatchFinder *p)
-{
-  UInt32 subValue = MatchFinder_GetSubValue(p);
-  MatchFinder_Normalize3(subValue, p-&gt;hash, p-&gt;hashSizeSum + p-&gt;numSons);
-  MatchFinder_ReduceOffsets(p, subValue);
-}
-
-static void MatchFinder_CheckLimits(CMatchFinder *p)
-{
-  if (p-&gt;pos == kMaxValForNormalize)
-    MatchFinder_Normalize(p);
-  if (!p-&gt;streamEndWasReached &amp;&amp; p-&gt;keepSizeAfter == p-&gt;streamPos - p-&gt;pos)
-    MatchFinder_CheckAndMoveAndRead(p);
-  if (p-&gt;cyclicBufferPos == p-&gt;cyclicBufferSize)
-    p-&gt;cyclicBufferPos = 0;
-  MatchFinder_SetLimits(p);
-}
-
-static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-    UInt32 *distances, UInt32 maxLen)
-{
-  son[_cyclicBufferPos] = curMatch;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
-      return distances;
-    {
-      const Byte *pb = cur - delta;
-      curMatch = son[_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)];
-      if (pb[maxLen] == cur[maxLen] &amp;&amp; *pb == *cur)
-      {
-        UInt32 len = 0;
-        while (++len != lenLimit)
-          if (pb[len] != cur[len])
-            break;
-        if (maxLen &lt; len)
-        {
-          *distances++ = maxLen = len;
-          *distances++ = delta - 1;
-          if (len == lenLimit)
-            return distances;
-        }
-      }
-    }
-  }
-}
-
-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-    UInt32 *distances, UInt32 maxLen)
-{
-  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
-  UInt32 len0 = 0, len1 = 0;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
-    {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      return distances;
-    }
-    {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
-      const Byte *pb = cur - delta;
-      UInt32 len = (len0 &lt; len1 ? len0 : len1);
-      if (pb[len] == cur[len])
-      {
-        if (++len != lenLimit &amp;&amp; pb[len] == cur[len])
-          while (++len != lenLimit)
-            if (pb[len] != cur[len])
-              break;
-        if (maxLen &lt; len)
-        {
-          *distances++ = maxLen = len;
-          *distances++ = delta - 1;
-          if (len == lenLimit)
-          {
-            *ptr1 = pair[0];
-            *ptr0 = pair[1];
-            return distances;
-          }
-        }
-      }
-      if (pb[len] &lt; cur[len])
-      {
-        *ptr1 = curMatch;
-        ptr1 = pair + 1;
-        curMatch = *ptr1;
-        len1 = len;
-      }
-      else
-      {
-        *ptr0 = curMatch;
-        ptr0 = pair;
-        curMatch = *ptr0;
-        len0 = len;
-      }
-    }
-  }
-}
-
-static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
-{
-  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
-  UInt32 len0 = 0, len1 = 0;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
-    {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      return;
-    }
-    {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
-      const Byte *pb = cur - delta;
-      UInt32 len = (len0 &lt; len1 ? len0 : len1);
-      if (pb[len] == cur[len])
-      {
-        while (++len != lenLimit)
-          if (pb[len] != cur[len])
-            break;
-        {
-          if (len == lenLimit)
-          {
-            *ptr1 = pair[0];
-            *ptr0 = pair[1];
-            return;
-          }
-        }
-      }
-      if (pb[len] &lt; cur[len])
-      {
-        *ptr1 = curMatch;
-        ptr1 = pair + 1;
-        curMatch = *ptr1;
-        len1 = len;
-      }
-      else
-      {
-        *ptr0 = curMatch;
-        ptr0 = pair;
-        curMatch = *ptr0;
-        len0 = len;
-      }
-    }
-  }
-}
-
-#define MOVE_POS \
-  ++p-&gt;cyclicBufferPos; \
-  p-&gt;buffer++; \
-  if (++p-&gt;pos == p-&gt;posLimit) MatchFinder_CheckLimits(p);
-
-#define MOVE_POS_RET MOVE_POS return offset;
-
-static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
-
-#define GET_MATCHES_HEADER2(minLen, ret_op) \
-  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
-  lenLimit = p-&gt;lenLimit; { if (lenLimit &lt; minLen) { MatchFinder_MovePos(p); ret_op; }} \
-  cur = p-&gt;buffer;
-
-#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
-#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
-
-#define MF_PARAMS(p) p-&gt;pos, p-&gt;buffer, p-&gt;son, p-&gt;cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue
-
-#define GET_MATCHES_FOOTER(offset, maxLen) \
-  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
-  distances + offset, maxLen) - distances); MOVE_POS_RET;
-
-#define SKIP_FOOTER \
-  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
-
-static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(2)
-  HASH2_CALC;
-  curMatch = p-&gt;hash[hashValue];
-  p-&gt;hash[hashValue] = p-&gt;pos;
-  offset = 0;
-  GET_MATCHES_FOOTER(offset, 1)
-}
-
-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(3)
-  HASH_ZIP_CALC;
-  curMatch = p-&gt;hash[hashValue];
-  p-&gt;hash[hashValue] = p-&gt;pos;
-  offset = 0;
-  GET_MATCHES_FOOTER(offset, 2)
-}
-
-static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 hash2Value, delta2, maxLen, offset;
-  GET_MATCHES_HEADER(3)
-
-  HASH3_CALC;
-
-  delta2 = p-&gt;pos - p-&gt;hash[hash2Value];
-  curMatch = p-&gt;hash[kFix3HashSize + hashValue];
-  
-  p-&gt;hash[hash2Value] =
-  p-&gt;hash[kFix3HashSize + hashValue] = p-&gt;pos;
-
-
-  maxLen = 2;
-  offset = 0;
-  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
-  {
-    for (; maxLen != lenLimit; maxLen++)
-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-        break;
-    distances[0] = maxLen;
-    distances[1] = delta2 - 1;
-    offset = 2;
-    if (maxLen == lenLimit)
-    {
-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-      MOVE_POS_RET;
-    }
-  }
-  GET_MATCHES_FOOTER(offset, maxLen)
-}
-
-static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-  GET_MATCHES_HEADER(4)
-
-  HASH4_CALC;
-
-  delta2 = p-&gt;pos - p-&gt;hash[                hash2Value];
-  delta3 = p-&gt;pos - p-&gt;hash[kFix3HashSize + hash3Value];
-  curMatch = p-&gt;hash[kFix4HashSize + hashValue];
-  
-  p-&gt;hash[                hash2Value] =
-  p-&gt;hash[kFix3HashSize + hash3Value] =
-  p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
-
-  maxLen = 1;
-  offset = 0;
-  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
-  {
-    distances[0] = maxLen = 2;
-    distances[1] = delta2 - 1;
-    offset = 2;
-  }
-  if (delta2 != delta3 &amp;&amp; delta3 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta3) == *cur)
-  {
-    maxLen = 3;
-    distances[offset + 1] = delta3 - 1;
-    offset += 2;
-    delta2 = delta3;
-  }
-  if (offset != 0)
-  {
-    for (; maxLen != lenLimit; maxLen++)
-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-        break;
-    distances[offset - 2] = maxLen;
-    if (maxLen == lenLimit)
-    {
-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-      MOVE_POS_RET;
-    }
-  }
-  if (maxLen &lt; 3)
-    maxLen = 3;
-  GET_MATCHES_FOOTER(offset, maxLen)
-}
-
-static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-  GET_MATCHES_HEADER(4)
-
-  HASH4_CALC;
-
-  delta2 = p-&gt;pos - p-&gt;hash[                hash2Value];
-  delta3 = p-&gt;pos - p-&gt;hash[kFix3HashSize + hash3Value];
-  curMatch = p-&gt;hash[kFix4HashSize + hashValue];
-
-  p-&gt;hash[                hash2Value] =
-  p-&gt;hash[kFix3HashSize + hash3Value] =
-  p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
-
-  maxLen = 1;
-  offset = 0;
-  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
-  {
-    distances[0] = maxLen = 2;
-    distances[1] = delta2 - 1;
-    offset = 2;
-  }
-  if (delta2 != delta3 &amp;&amp; delta3 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta3) == *cur)
-  {
-    maxLen = 3;
-    distances[offset + 1] = delta3 - 1;
-    offset += 2;
-    delta2 = delta3;
-  }
-  if (offset != 0)
-  {
-    for (; maxLen != lenLimit; maxLen++)
-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-        break;
-    distances[offset - 2] = maxLen;
-    if (maxLen == lenLimit)
-    {
-      p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
-      MOVE_POS_RET;
-    }
-  }
-  if (maxLen &lt; 3)
-    maxLen = 3;
-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-    distances + offset, maxLen) - (distances));
-  MOVE_POS_RET
-}
-
-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(3)
-  HASH_ZIP_CALC;
-  curMatch = p-&gt;hash[hashValue];
-  p-&gt;hash[hashValue] = p-&gt;pos;
-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-    distances, 2) - (distances));
-  MOVE_POS_RET
-}
-
-static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(2)
-    HASH2_CALC;
-    curMatch = p-&gt;hash[hashValue];
-    p-&gt;hash[hashValue] = p-&gt;pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(3)
-    HASH_ZIP_CALC;
-    curMatch = p-&gt;hash[hashValue];
-    p-&gt;hash[hashValue] = p-&gt;pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 hash2Value;
-    SKIP_HEADER(3)
-    HASH3_CALC;
-    curMatch = p-&gt;hash[kFix3HashSize + hashValue];
-    p-&gt;hash[hash2Value] =
-    p-&gt;hash[kFix3HashSize + hashValue] = p-&gt;pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 hash2Value, hash3Value;
-    SKIP_HEADER(4)
-    HASH4_CALC;
-    curMatch = p-&gt;hash[kFix4HashSize + hashValue];
-    p-&gt;hash[                hash2Value] =
-    p-&gt;hash[kFix3HashSize + hash3Value] = p-&gt;pos;
-    p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 hash2Value, hash3Value;
-    SKIP_HEADER(4)
-    HASH4_CALC;
-    curMatch = p-&gt;hash[kFix4HashSize + hashValue];
-    p-&gt;hash[                hash2Value] =
-    p-&gt;hash[kFix3HashSize + hash3Value] =
-    p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
-    p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
-    MOVE_POS
-  }
-  while (--num != 0);
-}
-
-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(3)
-    HASH_ZIP_CALC;
-    curMatch = p-&gt;hash[hashValue];
-    p-&gt;hash[hashValue] = p-&gt;pos;
-    p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
-    MOVE_POS
-  }
-  while (--num != 0);
-}
-
-void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
-{
-  vTable-&gt;Init = (Mf_Init_Func)MatchFinder_Init;
-  vTable-&gt;GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
-  vTable-&gt;GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-  vTable-&gt;GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
-  if (!p-&gt;btMode)
-  {
-    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
-    vTable-&gt;Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
-  }
-  else if (p-&gt;numHashBytes == 2)
-  {
-    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
-    vTable-&gt;Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
-  }
-  else if (p-&gt;numHashBytes == 3)
-  {
-    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
-    vTable-&gt;Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
-  }
-  else
-  {
-    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-    vTable-&gt;Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
-  }
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,753 @@
+/* LzFind.c  -- Match finder for LZ algorithms
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#include &lt;string.h&gt;
+
+#include &quot;LzFind.h&quot;
+#include &quot;LzHash.h&quot;
+
+#define kEmptyHashValue 0
+#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
+#define kNormalizeStepMin (1 &lt;&lt; 10) /* it must be power of 2 */
+#define kNormalizeMask (~(kNormalizeStepMin - 1))
+#define kMaxHistorySize ((UInt32)3 &lt;&lt; 30)
+
+#define kStartMaxLen 3
+
+static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
+{
+  if (!p-&gt;directInput)
+  {
+    alloc-&gt;Free(alloc, p-&gt;bufferBase);
+    p-&gt;bufferBase = 0;
+  }
+}
+
+/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be &lt; 4G) */
+
+static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
+{
+  UInt32 blockSize = p-&gt;keepSizeBefore + p-&gt;keepSizeAfter + keepSizeReserv;
+  if (p-&gt;directInput)
+  {
+    p-&gt;blockSize = blockSize;
+    return 1;
+  }
+  if (p-&gt;bufferBase == 0 || p-&gt;blockSize != blockSize)
+  {
+    LzInWindow_Free(p, alloc);
+    p-&gt;blockSize = blockSize;
+    p-&gt;bufferBase = (Byte *)alloc-&gt;Alloc(alloc, (size_t)blockSize);
+  }
+  return (p-&gt;bufferBase != 0);
+}
+
+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p-&gt;buffer; }
+Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p-&gt;buffer[index]; }
+
+UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p-&gt;streamPos - p-&gt;pos; }
+
+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
+{
+  p-&gt;posLimit -= subValue;
+  p-&gt;pos -= subValue;
+  p-&gt;streamPos -= subValue;
+}
+
+static void MatchFinder_ReadBlock(CMatchFinder *p)
+{
+  if (p-&gt;streamEndWasReached || p-&gt;result != SZ_OK)
+    return;
+  for (;;)
+  {
+    Byte *dest = p-&gt;buffer + (p-&gt;streamPos - p-&gt;pos);
+    size_t size = (p-&gt;bufferBase + p-&gt;blockSize - dest);
+    if (size == 0)
+      return;
+    p-&gt;result = p-&gt;stream-&gt;Read(p-&gt;stream, dest, &amp;size);
+    if (p-&gt;result != SZ_OK)
+      return;
+    if (size == 0)
+    {
+      p-&gt;streamEndWasReached = 1;
+      return;
+    }
+    p-&gt;streamPos += (UInt32)size;
+    if (p-&gt;streamPos - p-&gt;pos &gt; p-&gt;keepSizeAfter)
+      return;
+  }
+}
+
+void MatchFinder_MoveBlock(CMatchFinder *p)
+{
+  memmove(p-&gt;bufferBase,
+    p-&gt;buffer - p-&gt;keepSizeBefore,
+    (size_t)(p-&gt;streamPos - p-&gt;pos + p-&gt;keepSizeBefore));
+  p-&gt;buffer = p-&gt;bufferBase + p-&gt;keepSizeBefore;
+}
+
+int MatchFinder_NeedMove(CMatchFinder *p)
+{
+  /* if (p-&gt;streamEndWasReached) return 0; */
+  return ((size_t)(p-&gt;bufferBase + p-&gt;blockSize - p-&gt;buffer) &lt;= p-&gt;keepSizeAfter);
+}
+
+void MatchFinder_ReadIfRequired(CMatchFinder *p)
+{
+  if (p-&gt;streamEndWasReached)
+    return;
+  if (p-&gt;keepSizeAfter &gt;= p-&gt;streamPos - p-&gt;pos)
+    MatchFinder_ReadBlock(p);
+}
+
+static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
+{
+  if (MatchFinder_NeedMove(p))
+    MatchFinder_MoveBlock(p);
+  MatchFinder_ReadBlock(p);
+}
+
+static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
+{
+  p-&gt;cutValue = 32;
+  p-&gt;btMode = 1;
+  p-&gt;numHashBytes = 4;
+  /* p-&gt;skipModeBits = 0; */
+  p-&gt;directInput = 0;
+  p-&gt;bigHash = 0;
+}
+
+#define kCrcPoly 0xEDB88320
+
+void MatchFinder_Construct(CMatchFinder *p)
+{
+  UInt32 i;
+  p-&gt;bufferBase = 0;
+  p-&gt;directInput = 0;
+  p-&gt;hash = 0;
+  MatchFinder_SetDefaultSettings(p);
+
+  for (i = 0; i &lt; 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j &lt; 8; j++)
+      r = (r &gt;&gt; 1) ^ (kCrcPoly &amp; ~((r &amp; 1) - 1));
+    p-&gt;crc[i] = r;
+  }
+}
+
+static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;hash);
+  p-&gt;hash = 0;
+}
+
+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
+{
+  MatchFinder_FreeThisClassMemory(p, alloc);
+  LzInWindow_Free(p, alloc);
+}
+
+static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
+{
+  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
+  if (sizeInBytes / sizeof(CLzRef) != num)
+    return 0;
+  return (CLzRef *)alloc-&gt;Alloc(alloc, sizeInBytes);
+}
+
+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+    ISzAlloc *alloc)
+{
+  UInt32 sizeReserv;
+  if (historySize &gt; kMaxHistorySize)
+  {
+    MatchFinder_Free(p, alloc);
+    return 0;
+  }
+  sizeReserv = historySize &gt;&gt; 1;
+  if (historySize &gt; ((UInt32)2 &lt;&lt; 30))
+    sizeReserv = historySize &gt;&gt; 2;
+  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 &lt;&lt; 19);
+
+  p-&gt;keepSizeBefore = historySize + keepAddBufferBefore + 1;
+  p-&gt;keepSizeAfter = matchMaxLen + keepAddBufferAfter;
+  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
+  if (LzInWindow_Create(p, sizeReserv, alloc))
+  {
+    UInt32 newCyclicBufferSize = (historySize /* &gt;&gt; p-&gt;skipModeBits */) + 1;
+    UInt32 hs;
+    p-&gt;matchMaxLen = matchMaxLen;
+    {
+      p-&gt;fixedHashSize = 0;
+      if (p-&gt;numHashBytes == 2)
+        hs = (1 &lt;&lt; 16) - 1;
+      else
+      {
+        hs = historySize - 1;
+        hs |= (hs &gt;&gt; 1);
+        hs |= (hs &gt;&gt; 2);
+        hs |= (hs &gt;&gt; 4);
+        hs |= (hs &gt;&gt; 8);
+        hs &gt;&gt;= 1;
+        /* hs &gt;&gt;= p-&gt;skipModeBits; */
+        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
+        if (hs &gt; (1 &lt;&lt; 24))
+        {
+          if (p-&gt;numHashBytes == 3)
+            hs = (1 &lt;&lt; 24) - 1;
+          else
+            hs &gt;&gt;= 1;
+        }
+      }
+      p-&gt;hashMask = hs;
+      hs++;
+      if (p-&gt;numHashBytes &gt; 2) p-&gt;fixedHashSize += kHash2Size;
+      if (p-&gt;numHashBytes &gt; 3) p-&gt;fixedHashSize += kHash3Size;
+      if (p-&gt;numHashBytes &gt; 4) p-&gt;fixedHashSize += kHash4Size;
+      hs += p-&gt;fixedHashSize;
+    }
+
+    {
+      UInt32 prevSize = p-&gt;hashSizeSum + p-&gt;numSons;
+      UInt32 newSize;
+      p-&gt;historySize = historySize;
+      p-&gt;hashSizeSum = hs;
+      p-&gt;cyclicBufferSize = newCyclicBufferSize;
+      p-&gt;numSons = (p-&gt;btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
+      newSize = p-&gt;hashSizeSum + p-&gt;numSons;
+      if (p-&gt;hash != 0 &amp;&amp; prevSize == newSize)
+        return 1;
+      MatchFinder_FreeThisClassMemory(p, alloc);
+      p-&gt;hash = AllocRefs(newSize, alloc);
+      if (p-&gt;hash != 0)
+      {
+        p-&gt;son = p-&gt;hash + p-&gt;hashSizeSum;
+        return 1;
+      }
+    }
+  }
+  MatchFinder_Free(p, alloc);
+  return 0;
+}
+
+static void MatchFinder_SetLimits(CMatchFinder *p)
+{
+  UInt32 limit = kMaxValForNormalize - p-&gt;pos;
+  UInt32 limit2 = p-&gt;cyclicBufferSize - p-&gt;cyclicBufferPos;
+  if (limit2 &lt; limit)
+    limit = limit2;
+  limit2 = p-&gt;streamPos - p-&gt;pos;
+  if (limit2 &lt;= p-&gt;keepSizeAfter)
+  {
+    if (limit2 &gt; 0)
+      limit2 = 1;
+  }
+  else
+    limit2 -= p-&gt;keepSizeAfter;
+  if (limit2 &lt; limit)
+    limit = limit2;
+  {
+    UInt32 lenLimit = p-&gt;streamPos - p-&gt;pos;
+    if (lenLimit &gt; p-&gt;matchMaxLen)
+      lenLimit = p-&gt;matchMaxLen;
+    p-&gt;lenLimit = lenLimit;
+  }
+  p-&gt;posLimit = p-&gt;pos + limit;
+}
+
+void MatchFinder_Init(CMatchFinder *p)
+{
+  UInt32 i;
+  for (i = 0; i &lt; p-&gt;hashSizeSum; i++)
+    p-&gt;hash[i] = kEmptyHashValue;
+  p-&gt;cyclicBufferPos = 0;
+  p-&gt;buffer = p-&gt;bufferBase;
+  p-&gt;pos = p-&gt;streamPos = p-&gt;cyclicBufferSize;
+  p-&gt;result = SZ_OK;
+  p-&gt;streamEndWasReached = 0;
+  MatchFinder_ReadBlock(p);
+  MatchFinder_SetLimits(p);
+}
+
+static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
+{
+  return (p-&gt;pos - p-&gt;historySize - 1) &amp; kNormalizeMask;
+}
+
+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
+{
+  UInt32 i;
+  for (i = 0; i &lt; numItems; i++)
+  {
+    UInt32 value = items[i];
+    if (value &lt;= subValue)
+      value = kEmptyHashValue;
+    else
+      value -= subValue;
+    items[i] = value;
+  }
+}
+
+static void MatchFinder_Normalize(CMatchFinder *p)
+{
+  UInt32 subValue = MatchFinder_GetSubValue(p);
+  MatchFinder_Normalize3(subValue, p-&gt;hash, p-&gt;hashSizeSum + p-&gt;numSons);
+  MatchFinder_ReduceOffsets(p, subValue);
+}
+
+static void MatchFinder_CheckLimits(CMatchFinder *p)
+{
+  if (p-&gt;pos == kMaxValForNormalize)
+    MatchFinder_Normalize(p);
+  if (!p-&gt;streamEndWasReached &amp;&amp; p-&gt;keepSizeAfter == p-&gt;streamPos - p-&gt;pos)
+    MatchFinder_CheckAndMoveAndRead(p);
+  if (p-&gt;cyclicBufferPos == p-&gt;cyclicBufferSize)
+    p-&gt;cyclicBufferPos = 0;
+  MatchFinder_SetLimits(p);
+}
+
+static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+    UInt32 *distances, UInt32 maxLen)
+{
+  son[_cyclicBufferPos] = curMatch;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
+      return distances;
+    {
+      const Byte *pb = cur - delta;
+      curMatch = son[_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)];
+      if (pb[maxLen] == cur[maxLen] &amp;&amp; *pb == *cur)
+      {
+        UInt32 len = 0;
+        while (++len != lenLimit)
+          if (pb[len] != cur[len])
+            break;
+        if (maxLen &lt; len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+            return distances;
+        }
+      }
+    }
+  }
+}
+
+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+    UInt32 *distances, UInt32 maxLen)
+{
+  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
+  UInt32 len0 = 0, len1 = 0;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      return distances;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 &lt; len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        if (++len != lenLimit &amp;&amp; pb[len] == cur[len])
+          while (++len != lenLimit)
+            if (pb[len] != cur[len])
+              break;
+        if (maxLen &lt; len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            return distances;
+          }
+        }
+      }
+      if (pb[len] &lt; cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+}
+
+static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
+{
+  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
+  UInt32 len0 = 0, len1 = 0;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      return;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 &lt; len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        while (++len != lenLimit)
+          if (pb[len] != cur[len])
+            break;
+        {
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            return;
+          }
+        }
+      }
+      if (pb[len] &lt; cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+}
+
+#define MOVE_POS \
+  ++p-&gt;cyclicBufferPos; \
+  p-&gt;buffer++; \
+  if (++p-&gt;pos == p-&gt;posLimit) MatchFinder_CheckLimits(p);
+
+#define MOVE_POS_RET MOVE_POS return offset;
+
+static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
+
+#define GET_MATCHES_HEADER2(minLen, ret_op) \
+  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
+  lenLimit = p-&gt;lenLimit; { if (lenLimit &lt; minLen) { MatchFinder_MovePos(p); ret_op; }} \
+  cur = p-&gt;buffer;
+
+#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
+#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
+
+#define MF_PARAMS(p) p-&gt;pos, p-&gt;buffer, p-&gt;son, p-&gt;cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue
+
+#define GET_MATCHES_FOOTER(offset, maxLen) \
+  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
+  distances + offset, maxLen) - distances); MOVE_POS_RET;
+
+#define SKIP_FOOTER \
+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
+
+static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(2)
+  HASH2_CALC;
+  curMatch = p-&gt;hash[hashValue];
+  p-&gt;hash[hashValue] = p-&gt;pos;
+  offset = 0;
+  GET_MATCHES_FOOTER(offset, 1)
+}
+
+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(3)
+  HASH_ZIP_CALC;
+  curMatch = p-&gt;hash[hashValue];
+  p-&gt;hash[hashValue] = p-&gt;pos;
+  offset = 0;
+  GET_MATCHES_FOOTER(offset, 2)
+}
+
+static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, delta2, maxLen, offset;
+  GET_MATCHES_HEADER(3)
+
+  HASH3_CALC;
+
+  delta2 = p-&gt;pos - p-&gt;hash[hash2Value];
+  curMatch = p-&gt;hash[kFix3HashSize + hashValue];
+  
+  p-&gt;hash[hash2Value] =
+  p-&gt;hash[kFix3HashSize + hashValue] = p-&gt;pos;
+
+
+  maxLen = 2;
+  offset = 0;
+  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[0] = maxLen;
+    distances[1] = delta2 - 1;
+    offset = 2;
+    if (maxLen == lenLimit)
+    {
+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+      MOVE_POS_RET;
+    }
+  }
+  GET_MATCHES_FOOTER(offset, maxLen)
+}
+
+static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+  GET_MATCHES_HEADER(4)
+
+  HASH4_CALC;
+
+  delta2 = p-&gt;pos - p-&gt;hash[                hash2Value];
+  delta3 = p-&gt;pos - p-&gt;hash[kFix3HashSize + hash3Value];
+  curMatch = p-&gt;hash[kFix4HashSize + hashValue];
+  
+  p-&gt;hash[                hash2Value] =
+  p-&gt;hash[kFix3HashSize + hash3Value] =
+  p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
+
+  maxLen = 1;
+  offset = 0;
+  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
+  {
+    distances[0] = maxLen = 2;
+    distances[1] = delta2 - 1;
+    offset = 2;
+  }
+  if (delta2 != delta3 &amp;&amp; delta3 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta3) == *cur)
+  {
+    maxLen = 3;
+    distances[offset + 1] = delta3 - 1;
+    offset += 2;
+    delta2 = delta3;
+  }
+  if (offset != 0)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[offset - 2] = maxLen;
+    if (maxLen == lenLimit)
+    {
+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+      MOVE_POS_RET;
+    }
+  }
+  if (maxLen &lt; 3)
+    maxLen = 3;
+  GET_MATCHES_FOOTER(offset, maxLen)
+}
+
+static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+  GET_MATCHES_HEADER(4)
+
+  HASH4_CALC;
+
+  delta2 = p-&gt;pos - p-&gt;hash[                hash2Value];
+  delta3 = p-&gt;pos - p-&gt;hash[kFix3HashSize + hash3Value];
+  curMatch = p-&gt;hash[kFix4HashSize + hashValue];
+
+  p-&gt;hash[                hash2Value] =
+  p-&gt;hash[kFix3HashSize + hash3Value] =
+  p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
+
+  maxLen = 1;
+  offset = 0;
+  if (delta2 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta2) == *cur)
+  {
+    distances[0] = maxLen = 2;
+    distances[1] = delta2 - 1;
+    offset = 2;
+  }
+  if (delta2 != delta3 &amp;&amp; delta3 &lt; p-&gt;cyclicBufferSize &amp;&amp; *(cur - delta3) == *cur)
+  {
+    maxLen = 3;
+    distances[offset + 1] = delta3 - 1;
+    offset += 2;
+    delta2 = delta3;
+  }
+  if (offset != 0)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[offset - 2] = maxLen;
+    if (maxLen == lenLimit)
+    {
+      p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
+      MOVE_POS_RET;
+    }
+  }
+  if (maxLen &lt; 3)
+    maxLen = 3;
+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+    distances + offset, maxLen) - (distances));
+  MOVE_POS_RET
+}
+
+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(3)
+  HASH_ZIP_CALC;
+  curMatch = p-&gt;hash[hashValue];
+  p-&gt;hash[hashValue] = p-&gt;pos;
+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+    distances, 2) - (distances));
+  MOVE_POS_RET
+}
+
+static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(2)
+    HASH2_CALC;
+    curMatch = p-&gt;hash[hashValue];
+    p-&gt;hash[hashValue] = p-&gt;pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(3)
+    HASH_ZIP_CALC;
+    curMatch = p-&gt;hash[hashValue];
+    p-&gt;hash[hashValue] = p-&gt;pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value;
+    SKIP_HEADER(3)
+    HASH3_CALC;
+    curMatch = p-&gt;hash[kFix3HashSize + hashValue];
+    p-&gt;hash[hash2Value] =
+    p-&gt;hash[kFix3HashSize + hashValue] = p-&gt;pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value, hash3Value;
+    SKIP_HEADER(4)
+    HASH4_CALC;
+    curMatch = p-&gt;hash[kFix4HashSize + hashValue];
+    p-&gt;hash[                hash2Value] =
+    p-&gt;hash[kFix3HashSize + hash3Value] = p-&gt;pos;
+    p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value, hash3Value;
+    SKIP_HEADER(4)
+    HASH4_CALC;
+    curMatch = p-&gt;hash[kFix4HashSize + hashValue];
+    p-&gt;hash[                hash2Value] =
+    p-&gt;hash[kFix3HashSize + hash3Value] =
+    p-&gt;hash[kFix4HashSize + hashValue] = p-&gt;pos;
+    p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
+    MOVE_POS
+  }
+  while (--num != 0);
+}
+
+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(3)
+    HASH_ZIP_CALC;
+    curMatch = p-&gt;hash[hashValue];
+    p-&gt;hash[hashValue] = p-&gt;pos;
+    p-&gt;son[p-&gt;cyclicBufferPos] = curMatch;
+    MOVE_POS
+  }
+  while (--num != 0);
+}
+
+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
+{
+  vTable-&gt;Init = (Mf_Init_Func)MatchFinder_Init;
+  vTable-&gt;GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
+  vTable-&gt;GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
+  vTable-&gt;GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
+  if (!p-&gt;btMode)
+  {
+    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
+    vTable-&gt;Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
+  }
+  else if (p-&gt;numHashBytes == 2)
+  {
+    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
+    vTable-&gt;Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
+  }
+  else if (p-&gt;numHashBytes == 3)
+  {
+    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
+    vTable-&gt;Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
+  }
+  else
+  {
+    vTable-&gt;GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
+    vTable-&gt;Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+  }
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,116 +0,0 @@
-/* LzFind.h  -- Match finder for LZ algorithms
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-You can use any of the following license options:
-  1) GNU Lesser General Public License (GNU LGPL)
-  2) Common Public License (CPL)
-  3) Common Development and Distribution License (CDDL) Version 1.0
-  4) Igor Pavlov, as the author of this code, expressly permits you to
-     statically or dynamically link your code (or bind by name) to this file,
-     while you keep this file unmodified.
-*/
-
-#ifndef __LZFIND_H
-#define __LZFIND_H
-
-#include &quot;Types.h&quot;
-
-typedef UInt32 CLzRef;
-
-typedef struct _CMatchFinder
-{
-  Byte *buffer;
-  UInt32 pos;
-  UInt32 posLimit;
-  UInt32 streamPos;
-  UInt32 lenLimit;
-
-  UInt32 cyclicBufferPos;
-  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
-
-  UInt32 matchMaxLen;
-  CLzRef *hash;
-  CLzRef *son;
-  UInt32 hashMask;
-  UInt32 cutValue;
-
-  Byte *bufferBase;
-  ISeqInStream *stream;
-  int streamEndWasReached;
-
-  UInt32 blockSize;
-  UInt32 keepSizeBefore;
-  UInt32 keepSizeAfter;
-
-  UInt32 numHashBytes;
-  int directInput;
-  int btMode;
-  /* int skipModeBits; */
-  int bigHash;
-  UInt32 historySize;
-  UInt32 fixedHashSize;
-  UInt32 hashSizeSum;
-  UInt32 numSons;
-  SRes result;
-  UInt32 crc[256];
-} CMatchFinder;
-
-#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)-&gt;buffer)
-#define Inline_MatchFinder_GetIndexByte(p, index) ((p)-&gt;buffer[(Int32)(index)])
-
-#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)-&gt;streamPos - (p)-&gt;pos)
-
-int MatchFinder_NeedMove(CMatchFinder *p);
-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
-void MatchFinder_MoveBlock(CMatchFinder *p);
-void MatchFinder_ReadIfRequired(CMatchFinder *p);
-
-void MatchFinder_Construct(CMatchFinder *p);
-
-/* Conditions:
-     historySize &lt;= 3 GB
-     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter &lt; 511MB
-*/
-int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-    ISzAlloc *alloc);
-void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
-
-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-    UInt32 *distances, UInt32 maxLen);
-
-/*
-Conditions:
-  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
-  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
-*/
-
-typedef void (*Mf_Init_Func)(void *object);
-typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
-typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
-typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
-typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
-typedef void (*Mf_Skip_Func)(void *object, UInt32);
-
-typedef struct _IMatchFinder
-{
-  Mf_Init_Func Init;
-  Mf_GetIndexByte_Func GetIndexByte;
-  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
-  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
-  Mf_GetMatches_Func GetMatches;
-  Mf_Skip_Func Skip;
-} IMatchFinder;
-
-void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
-
-void MatchFinder_Init(CMatchFinder *p);
-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFind.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,116 @@
+/* LzFind.h  -- Match finder for LZ algorithms
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+You can use any of the following license options:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  3) Common Development and Distribution License (CDDL) Version 1.0
+  4) Igor Pavlov, as the author of this code, expressly permits you to
+     statically or dynamically link your code (or bind by name) to this file,
+     while you keep this file unmodified.
+*/
+
+#ifndef __LZFIND_H
+#define __LZFIND_H
+
+#include &quot;Types.h&quot;
+
+typedef UInt32 CLzRef;
+
+typedef struct _CMatchFinder
+{
+  Byte *buffer;
+  UInt32 pos;
+  UInt32 posLimit;
+  UInt32 streamPos;
+  UInt32 lenLimit;
+
+  UInt32 cyclicBufferPos;
+  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
+
+  UInt32 matchMaxLen;
+  CLzRef *hash;
+  CLzRef *son;
+  UInt32 hashMask;
+  UInt32 cutValue;
+
+  Byte *bufferBase;
+  ISeqInStream *stream;
+  int streamEndWasReached;
+
+  UInt32 blockSize;
+  UInt32 keepSizeBefore;
+  UInt32 keepSizeAfter;
+
+  UInt32 numHashBytes;
+  int directInput;
+  int btMode;
+  /* int skipModeBits; */
+  int bigHash;
+  UInt32 historySize;
+  UInt32 fixedHashSize;
+  UInt32 hashSizeSum;
+  UInt32 numSons;
+  SRes result;
+  UInt32 crc[256];
+} CMatchFinder;
+
+#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)-&gt;buffer)
+#define Inline_MatchFinder_GetIndexByte(p, index) ((p)-&gt;buffer[(Int32)(index)])
+
+#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)-&gt;streamPos - (p)-&gt;pos)
+
+int MatchFinder_NeedMove(CMatchFinder *p);
+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
+void MatchFinder_MoveBlock(CMatchFinder *p);
+void MatchFinder_ReadIfRequired(CMatchFinder *p);
+
+void MatchFinder_Construct(CMatchFinder *p);
+
+/* Conditions:
+     historySize &lt;= 3 GB
+     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter &lt; 511MB
+*/
+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+    ISzAlloc *alloc);
+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
+
+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *distances, UInt32 maxLen);
+
+/*
+Conditions:
+  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
+  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
+*/
+
+typedef void (*Mf_Init_Func)(void *object);
+typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
+typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
+typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
+typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
+typedef void (*Mf_Skip_Func)(void *object, UInt32);
+
+typedef struct _IMatchFinder
+{
+  Mf_Init_Func Init;
+  Mf_GetIndexByte_Func GetIndexByte;
+  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
+  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
+  Mf_GetMatches_Func GetMatches;
+  Mf_Skip_Func Skip;
+} IMatchFinder;
+
+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
+
+void MatchFinder_Init(CMatchFinder *p);
+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,795 +0,0 @@
-/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#include &quot;LzHash.h&quot;
-
-#include &quot;LzFindMt.h&quot;
-
-void MtSync_Construct(CMtSync *p)
-{
-  p-&gt;wasCreated = False;
-  p-&gt;csWasInitialized = False;
-  p-&gt;csWasEntered = False;
-  Thread_Construct(&amp;p-&gt;thread);
-  Event_Construct(&amp;p-&gt;canStart);
-  Event_Construct(&amp;p-&gt;wasStarted);
-  Event_Construct(&amp;p-&gt;wasStopped);
-  Semaphore_Construct(&amp;p-&gt;freeSemaphore);
-  Semaphore_Construct(&amp;p-&gt;filledSemaphore);
-}
-
-void MtSync_GetNextBlock(CMtSync *p)
-{
-  if (p-&gt;needStart)
-  {
-    p-&gt;numProcessedBlocks = 1;
-    p-&gt;needStart = False;
-    p-&gt;stopWriting = False;
-    p-&gt;exit = False;
-    Event_Reset(&amp;p-&gt;wasStarted);
-    Event_Reset(&amp;p-&gt;wasStopped);
-
-    Event_Set(&amp;p-&gt;canStart);
-    Event_Wait(&amp;p-&gt;wasStarted);
-  }
-  else
-  {
-    CriticalSection_Leave(&amp;p-&gt;cs);
-    p-&gt;csWasEntered = False;
-    p-&gt;numProcessedBlocks++;
-    Semaphore_Release1(&amp;p-&gt;freeSemaphore);
-  }
-  Semaphore_Wait(&amp;p-&gt;filledSemaphore);
-  CriticalSection_Enter(&amp;p-&gt;cs);
-  p-&gt;csWasEntered = True;
-}
-
-/* MtSync_StopWriting must be called if Writing was started */
-
-void MtSync_StopWriting(CMtSync *p)
-{
-  UInt32 myNumBlocks = p-&gt;numProcessedBlocks;
-  if (!Thread_WasCreated(&amp;p-&gt;thread) || p-&gt;needStart)
-    return;
-  p-&gt;stopWriting = True;
-  if (p-&gt;csWasEntered)
-  {
-    CriticalSection_Leave(&amp;p-&gt;cs);
-    p-&gt;csWasEntered = False;
-  }
-  Semaphore_Release1(&amp;p-&gt;freeSemaphore);
- 
-  Event_Wait(&amp;p-&gt;wasStopped);
-
-  while (myNumBlocks++ != p-&gt;numProcessedBlocks)
-  {
-    Semaphore_Wait(&amp;p-&gt;filledSemaphore);
-    Semaphore_Release1(&amp;p-&gt;freeSemaphore);
-  }
-  p-&gt;needStart = True;
-}
-
-void MtSync_Destruct(CMtSync *p)
-{
-  if (Thread_WasCreated(&amp;p-&gt;thread))
-  {
-    MtSync_StopWriting(p);
-    p-&gt;exit = True;
-    if (p-&gt;needStart)
-      Event_Set(&amp;p-&gt;canStart);
-    Thread_Wait(&amp;p-&gt;thread);
-    Thread_Close(&amp;p-&gt;thread);
-  }
-  if (p-&gt;csWasInitialized)
-  {
-    CriticalSection_Delete(&amp;p-&gt;cs);
-    p-&gt;csWasInitialized = False;
-  }
-
-  Event_Close(&amp;p-&gt;canStart);
-  Event_Close(&amp;p-&gt;wasStarted);
-  Event_Close(&amp;p-&gt;wasStopped);
-  Semaphore_Close(&amp;p-&gt;freeSemaphore);
-  Semaphore_Close(&amp;p-&gt;filledSemaphore);
-
-  p-&gt;wasCreated = False;
-}
-
-#define RINOK_THREAD(x) { if ((x) != 0) return SZ_ERROR_THREAD; }
-
-static SRes MtSync_Create2(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
-{
-  if (p-&gt;wasCreated)
-    return SZ_OK;
-
-  RINOK_THREAD(CriticalSection_Init(&amp;p-&gt;cs));
-  p-&gt;csWasInitialized = True;
-
-  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;canStart));
-  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;wasStarted));
-  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;wasStopped));
-  
-  RINOK_THREAD(Semaphore_Create(&amp;p-&gt;freeSemaphore, numBlocks, numBlocks));
-  RINOK_THREAD(Semaphore_Create(&amp;p-&gt;filledSemaphore, 0, numBlocks));
-
-  p-&gt;needStart = True;
-  
-  RINOK_THREAD(Thread_Create(&amp;p-&gt;thread, startAddress, obj));
-  p-&gt;wasCreated = True;
-  return SZ_OK;
-}
-
-static SRes MtSync_Create(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
-{
-  SRes res = MtSync_Create2(p, startAddress, obj, numBlocks);
-  if (res != SZ_OK)
-    MtSync_Destruct(p);
-  return res;
-}
-
-void MtSync_Init(CMtSync *p) { p-&gt;needStart = True; }
-
-#define kMtMaxValForNormalize 0xFFFFFFFF
-
-#define DEF_GetHeads2(name, v, action) \
-static void GetHeads ## name(const Byte *p, UInt32 pos, \
-UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc) \
-{ action; for (; numHeads != 0; numHeads--) { \
-const UInt32 value = (v); p++; *heads++ = pos - hash[value]; hash[value] = pos++;  } }
-
-#define DEF_GetHeads(name, v) DEF_GetHeads2(name, v, ;)
-
-DEF_GetHeads2(2,  (p[0] | ((UInt32)p[1] &lt;&lt; 8)), hashMask = hashMask; crc = crc; )
-DEF_GetHeads(3,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8)) &amp; hashMask)
-DEF_GetHeads(4,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ (crc[p[3]] &lt;&lt; 5)) &amp; hashMask)
-DEF_GetHeads(4b, (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ ((UInt32)p[3] &lt;&lt; 16)) &amp; hashMask)
-DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ (crc[p[3]] &lt;&lt; 5) ^ (crc[p[4]] &lt;&lt; 3)) &amp; hashMask)
-
-void HashThreadFunc(CMatchFinderMt *mt)
-{
-  CMtSync *p = &amp;mt-&gt;hashSync;
-  for (;;)
-  {
-    UInt32 numProcessedBlocks = 0;
-    Event_Wait(&amp;p-&gt;canStart);
-    Event_Set(&amp;p-&gt;wasStarted);
-    for (;;)
-    {
-      if (p-&gt;exit)
-        return;
-      if (p-&gt;stopWriting)
-      {
-        p-&gt;numProcessedBlocks = numProcessedBlocks;
-        Event_Set(&amp;p-&gt;wasStopped);
-        break;
-      }
-
-      {
-        CMatchFinder *mf = mt-&gt;MatchFinder;
-        if (MatchFinder_NeedMove(mf))
-        {
-          CriticalSection_Enter(&amp;mt-&gt;btSync.cs);
-          CriticalSection_Enter(&amp;mt-&gt;hashSync.cs);
-          {
-            const Byte *beforePtr = MatchFinder_GetPointerToCurrentPos(mf);
-            const Byte *afterPtr;
-            MatchFinder_MoveBlock(mf);
-            afterPtr = MatchFinder_GetPointerToCurrentPos(mf);
-            mt-&gt;pointerToCurPos -= beforePtr - afterPtr;
-            mt-&gt;buffer -= beforePtr - afterPtr;
-          }
-          CriticalSection_Leave(&amp;mt-&gt;btSync.cs);
-          CriticalSection_Leave(&amp;mt-&gt;hashSync.cs);
-          continue;
-        }
-
-        Semaphore_Wait(&amp;p-&gt;freeSemaphore);
-
-        MatchFinder_ReadIfRequired(mf);
-        if (mf-&gt;pos &gt; (kMtMaxValForNormalize - kMtHashBlockSize))
-        {
-          UInt32 subValue = (mf-&gt;pos - mf-&gt;historySize - 1);
-          MatchFinder_ReduceOffsets(mf, subValue);
-          MatchFinder_Normalize3(subValue, mf-&gt;hash + mf-&gt;fixedHashSize, mf-&gt;hashMask + 1);
-        }
-        {
-          UInt32 *heads = mt-&gt;hashBuf + ((numProcessedBlocks++) &amp; kMtHashNumBlocksMask) * kMtHashBlockSize;
-          UInt32 num = mf-&gt;streamPos - mf-&gt;pos;
-          heads[0] = 2;
-          heads[1] = num;
-          if (num &gt;= mf-&gt;numHashBytes)
-          {
-            num = num - mf-&gt;numHashBytes + 1;
-            if (num &gt; kMtHashBlockSize - 2)
-              num = kMtHashBlockSize - 2;
-            mt-&gt;GetHeadsFunc(mf-&gt;buffer, mf-&gt;pos, mf-&gt;hash + mf-&gt;fixedHashSize, mf-&gt;hashMask, heads + 2, num, mf-&gt;crc);
-            heads[0] += num;
-          }
-          mf-&gt;pos += num;
-          mf-&gt;buffer += num;
-        }
-      }
-
-      Semaphore_Release1(&amp;p-&gt;filledSemaphore);
-    }
-  }
-}
-
-void MatchFinderMt_GetNextBlock_Hash(CMatchFinderMt *p)
-{
-  MtSync_GetNextBlock(&amp;p-&gt;hashSync);
-  p-&gt;hashBufPosLimit = p-&gt;hashBufPos = ((p-&gt;hashSync.numProcessedBlocks - 1) &amp; kMtHashNumBlocksMask) * kMtHashBlockSize;
-  p-&gt;hashBufPosLimit += p-&gt;hashBuf[p-&gt;hashBufPos++];
-  p-&gt;hashNumAvail = p-&gt;hashBuf[p-&gt;hashBufPos++];
-}
-
-#define kEmptyHashValue 0
-
-/* #define MFMT_GM_INLINE */
-
-#ifdef MFMT_GM_INLINE
-
-#define NO_INLINE MY_FAST_CALL
-
-Int32 NO_INLINE GetMatchesSpecN(UInt32 lenLimit, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-    UInt32 *_distances, UInt32 _maxLen, const UInt32 *hash, Int32 limit, UInt32 size, UInt32 *posRes)
-{
-  do
-  {
-  UInt32 *distances = _distances + 1;
-  UInt32 curMatch = pos - *hash++;
-
-  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
-  UInt32 len0 = 0, len1 = 0;
-  UInt32 cutValue = _cutValue;
-  UInt32 maxLen = _maxLen;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
-    {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      break;
-    }
-    {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
-      const Byte *pb = cur - delta;
-      UInt32 len = (len0 &lt; len1 ? len0 : len1);
-      if (pb[len] == cur[len])
-      {
-        if (++len != lenLimit &amp;&amp; pb[len] == cur[len])
-          while (++len != lenLimit)
-            if (pb[len] != cur[len])
-              break;
-        if (maxLen &lt; len)
-        {
-          *distances++ = maxLen = len;
-          *distances++ = delta - 1;
-          if (len == lenLimit)
-          {
-            *ptr1 = pair[0];
-            *ptr0 = pair[1];
-            break;
-          }
-        }
-      }
-      if (pb[len] &lt; cur[len])
-      {
-        *ptr1 = curMatch;
-        ptr1 = pair + 1;
-        curMatch = *ptr1;
-        len1 = len;
-      }
-      else
-      {
-        *ptr0 = curMatch;
-        ptr0 = pair;
-        curMatch = *ptr0;
-        len0 = len;
-      }
-    }
-  }
-  pos++;
-  _cyclicBufferPos++;
-  cur++;
-  {
-    UInt32 num = (UInt32)(distances - _distances);
-    *_distances = num - 1;
-    _distances += num;
-    limit -= num;
-  }
-  }
-  while (limit &gt; 0 &amp;&amp; --size != 0);
-  *posRes = pos;
-  return limit;
-}
-
-#endif
-
-void BtGetMatches(CMatchFinderMt *p, UInt32 *distances)
-{
-  UInt32 numProcessed = 0;
-  UInt32 curPos = 2;
-  UInt32 limit = kMtBtBlockSize - (p-&gt;matchMaxLen * 2);
-  distances[1] = p-&gt;hashNumAvail;
-  while (curPos &lt; limit)
-  {
-    if (p-&gt;hashBufPos == p-&gt;hashBufPosLimit)
-    {
-      MatchFinderMt_GetNextBlock_Hash(p);
-      distances[1] = numProcessed + p-&gt;hashNumAvail;
-      if (p-&gt;hashNumAvail &gt;= p-&gt;numHashBytes)
-        continue;
-      for (; p-&gt;hashNumAvail != 0; p-&gt;hashNumAvail--)
-        distances[curPos++] = 0;
-      break;
-    }
-    {
-      UInt32 size = p-&gt;hashBufPosLimit - p-&gt;hashBufPos;
-      UInt32 lenLimit = p-&gt;matchMaxLen;
-      UInt32 pos = p-&gt;pos;
-      UInt32 cyclicBufferPos = p-&gt;cyclicBufferPos;
-      if (lenLimit &gt;= p-&gt;hashNumAvail)
-        lenLimit = p-&gt;hashNumAvail;
-      {
-        UInt32 size2 = p-&gt;hashNumAvail - lenLimit + 1;
-        if (size2 &lt; size)
-          size = size2;
-        size2 = p-&gt;cyclicBufferSize - cyclicBufferPos;
-        if (size2 &lt; size)
-          size = size2;
-      }
-      #ifndef MFMT_GM_INLINE
-      while (curPos &lt; limit &amp;&amp; size-- != 0)
-      {
-        UInt32 *startDistances = distances + curPos;
-        UInt32 num = (UInt32)(GetMatchesSpec1(lenLimit, pos - p-&gt;hashBuf[p-&gt;hashBufPos++],
-          pos, p-&gt;buffer, p-&gt;son, cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue,
-          startDistances + 1, p-&gt;numHashBytes - 1) - startDistances);
-        *startDistances = num - 1;
-        curPos += num;
-        cyclicBufferPos++;
-        pos++;
-        p-&gt;buffer++;
-      }
-      #else
-      {
-        UInt32 posRes;
-        curPos = limit - GetMatchesSpecN(lenLimit, pos, p-&gt;buffer, p-&gt;son, cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue,
-          distances + curPos, p-&gt;numHashBytes - 1, p-&gt;hashBuf + p-&gt;hashBufPos, (Int32)(limit - curPos) , size, &amp;posRes);
-        p-&gt;hashBufPos += posRes - pos;
-        cyclicBufferPos += posRes - pos;
-        p-&gt;buffer += posRes - pos;
-        pos = posRes;
-      }
-      #endif
-
-      numProcessed += pos - p-&gt;pos;
-      p-&gt;hashNumAvail -= pos - p-&gt;pos;
-      p-&gt;pos = pos;
-      if (cyclicBufferPos == p-&gt;cyclicBufferSize)
-        cyclicBufferPos = 0;
-      p-&gt;cyclicBufferPos = cyclicBufferPos;
-    }
-  }
-  distances[0] = curPos;
-}
-
-void BtFillBlock(CMatchFinderMt *p, UInt32 globalBlockIndex)
-{
-  CMtSync *sync = &amp;p-&gt;hashSync;
-  if (!sync-&gt;needStart)
-  {
-    CriticalSection_Enter(&amp;sync-&gt;cs);
-    sync-&gt;csWasEntered = True;
-  }
-  
-  BtGetMatches(p, p-&gt;btBuf + (globalBlockIndex &amp; kMtBtNumBlocksMask) * kMtBtBlockSize);
-
-  if (p-&gt;pos &gt; kMtMaxValForNormalize - kMtBtBlockSize)
-  {
-    UInt32 subValue = p-&gt;pos - p-&gt;cyclicBufferSize;
-    MatchFinder_Normalize3(subValue, p-&gt;son, p-&gt;cyclicBufferSize * 2);
-    p-&gt;pos -= subValue;
-  }
-
-  if (!sync-&gt;needStart)
-  {
-    CriticalSection_Leave(&amp;sync-&gt;cs);
-    sync-&gt;csWasEntered = False;
-  }
-}
-
-void BtThreadFunc(CMatchFinderMt *mt)
-{
-  CMtSync *p = &amp;mt-&gt;btSync;
-  for (;;)
-  {
-    UInt32 blockIndex = 0;
-    Event_Wait(&amp;p-&gt;canStart);
-    Event_Set(&amp;p-&gt;wasStarted);
-    for (;;)
-    {
-      if (p-&gt;exit)
-        return;
-      if (p-&gt;stopWriting)
-      {
-        p-&gt;numProcessedBlocks = blockIndex;
-        MtSync_StopWriting(&amp;mt-&gt;hashSync);
-        Event_Set(&amp;p-&gt;wasStopped);
-        break;
-      }
-      Semaphore_Wait(&amp;p-&gt;freeSemaphore);
-      BtFillBlock(mt, blockIndex++);
-      Semaphore_Release1(&amp;p-&gt;filledSemaphore);
-    }
-  }
-}
-
-void MatchFinderMt_Construct(CMatchFinderMt *p)
-{
-  p-&gt;hashBuf = 0;
-  MtSync_Construct(&amp;p-&gt;hashSync);
-  MtSync_Construct(&amp;p-&gt;btSync);
-}
-
-void MatchFinderMt_FreeMem(CMatchFinderMt *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;hashBuf);
-  p-&gt;hashBuf = 0;
-}
-
-void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc)
-{
-  MtSync_Destruct(&amp;p-&gt;hashSync);
-  MtSync_Destruct(&amp;p-&gt;btSync);
-  MatchFinderMt_FreeMem(p, alloc);
-}
-
-#define kHashBufferSize (kMtHashBlockSize * kMtHashNumBlocks)
-#define kBtBufferSize (kMtBtBlockSize * kMtBtNumBlocks)
-
-static unsigned MY_STD_CALL HashThreadFunc2(void *p) { HashThreadFunc((CMatchFinderMt *)p);  return 0; }
-static unsigned MY_STD_CALL BtThreadFunc2(void *p)
-{
-  Byte allocaDummy[0x180];
-  int i = 0;
-  for (i = 0; i &lt; 16; i++)
-    allocaDummy[i] = (Byte)i;
-  BtThreadFunc((CMatchFinderMt *)p);
-  return 0;
-}
-
-SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
-    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc)
-{
-  CMatchFinder *mf = p-&gt;MatchFinder;
-  p-&gt;historySize = historySize;
-  if (kMtBtBlockSize &lt;= matchMaxLen * 4)
-    return SZ_ERROR_PARAM;
-  if (p-&gt;hashBuf == 0)
-  {
-    p-&gt;hashBuf = (UInt32 *)alloc-&gt;Alloc(alloc, (kHashBufferSize + kBtBufferSize) * sizeof(UInt32));
-    if (p-&gt;hashBuf == 0)
-      return SZ_ERROR_MEM;
-    p-&gt;btBuf = p-&gt;hashBuf + kHashBufferSize;
-  }
-  keepAddBufferBefore += (kHashBufferSize + kBtBufferSize);
-  keepAddBufferAfter += kMtHashBlockSize;
-  if (!MatchFinder_Create(mf, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter, alloc))
-    return SZ_ERROR_MEM;
-
-  RINOK(MtSync_Create(&amp;p-&gt;hashSync, HashThreadFunc2, p, kMtHashNumBlocks));
-  RINOK(MtSync_Create(&amp;p-&gt;btSync, BtThreadFunc2, p, kMtBtNumBlocks));
-  return SZ_OK;
-}
-
-/* Call it after ReleaseStream / SetStream */
-void MatchFinderMt_Init(CMatchFinderMt *p)
-{
-  CMatchFinder *mf = p-&gt;MatchFinder;
-  p-&gt;btBufPos = p-&gt;btBufPosLimit = 0;
-  p-&gt;hashBufPos = p-&gt;hashBufPosLimit = 0;
-  MatchFinder_Init(mf);
-  p-&gt;pointerToCurPos = MatchFinder_GetPointerToCurrentPos(mf);
-  p-&gt;btNumAvailBytes = 0;
-  p-&gt;lzPos = p-&gt;historySize + 1;
-
-  p-&gt;hash = mf-&gt;hash;
-  p-&gt;fixedHashSize = mf-&gt;fixedHashSize;
-  p-&gt;crc = mf-&gt;crc;
-
-  p-&gt;son = mf-&gt;son;
-  p-&gt;matchMaxLen = mf-&gt;matchMaxLen;
-  p-&gt;numHashBytes = mf-&gt;numHashBytes;
-  p-&gt;pos = mf-&gt;pos;
-  p-&gt;buffer = mf-&gt;buffer;
-  p-&gt;cyclicBufferPos = mf-&gt;cyclicBufferPos;
-  p-&gt;cyclicBufferSize = mf-&gt;cyclicBufferSize;
-  p-&gt;cutValue = mf-&gt;cutValue;
-}
-
-/* ReleaseStream is required to finish multithreading */
-void MatchFinderMt_ReleaseStream(CMatchFinderMt *p)
-{
-  MtSync_StopWriting(&amp;p-&gt;btSync);
-  /* p-&gt;MatchFinder-&gt;ReleaseStream(); */
-}
-
-void MatchFinderMt_Normalize(CMatchFinderMt *p)
-{
-  MatchFinder_Normalize3(p-&gt;lzPos - p-&gt;historySize - 1, p-&gt;hash, p-&gt;fixedHashSize);
-  p-&gt;lzPos = p-&gt;historySize + 1;
-}
-
-void MatchFinderMt_GetNextBlock_Bt(CMatchFinderMt *p)
-{
-  UInt32 blockIndex;
-  MtSync_GetNextBlock(&amp;p-&gt;btSync);
-  blockIndex = ((p-&gt;btSync.numProcessedBlocks - 1) &amp; kMtBtNumBlocksMask);
-  p-&gt;btBufPosLimit = p-&gt;btBufPos = blockIndex * kMtBtBlockSize;
-  p-&gt;btBufPosLimit += p-&gt;btBuf[p-&gt;btBufPos++];
-  p-&gt;btNumAvailBytes = p-&gt;btBuf[p-&gt;btBufPos++];
-  if (p-&gt;lzPos &gt;= kMtMaxValForNormalize - kMtBtBlockSize)
-    MatchFinderMt_Normalize(p);
-}
-
-const Byte * MatchFinderMt_GetPointerToCurrentPos(CMatchFinderMt *p)
-{
-  return p-&gt;pointerToCurPos;
-}
-
-#define GET_NEXT_BLOCK_IF_REQUIRED if (p-&gt;btBufPos == p-&gt;btBufPosLimit) MatchFinderMt_GetNextBlock_Bt(p);
-
-UInt32 MatchFinderMt_GetNumAvailableBytes(CMatchFinderMt *p)
-{
-  GET_NEXT_BLOCK_IF_REQUIRED;
-  return p-&gt;btNumAvailBytes;
-}
-
-Byte MatchFinderMt_GetIndexByte(CMatchFinderMt *p, Int32 index)
-{
-  return p-&gt;pointerToCurPos[index];
-}
-
-UInt32 * MixMatches2(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
-{
-  UInt32 hash2Value, curMatch2;
-  UInt32 *hash = p-&gt;hash;
-  const Byte *cur = p-&gt;pointerToCurPos;
-  UInt32 lzPos = p-&gt;lzPos;
-  MT_HASH2_CALC
-      
-  curMatch2 = hash[hash2Value];
-  hash[hash2Value] = lzPos;
-
-  if (curMatch2 &gt;= matchMinPos)
-    if (cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
-    {
-      *distances++ = 2;
-      *distances++ = lzPos - curMatch2 - 1;
-    }
-  return distances;
-}
-
-UInt32 * MixMatches3(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
-{
-  UInt32 hash2Value, hash3Value, curMatch2, curMatch3;
-  UInt32 *hash = p-&gt;hash;
-  const Byte *cur = p-&gt;pointerToCurPos;
-  UInt32 lzPos = p-&gt;lzPos;
-  MT_HASH3_CALC
-
-  curMatch2 = hash[                hash2Value];
-  curMatch3 = hash[kFix3HashSize + hash3Value];
-  
-  hash[                hash2Value] =
-  hash[kFix3HashSize + hash3Value] =
-    lzPos;
-
-  if (curMatch2 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
-  {
-    distances[1] = lzPos - curMatch2 - 1;
-    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
-    {
-      distances[0] = 3;
-      return distances + 2;
-    }
-    distances[0] = 2;
-    distances += 2;
-  }
-  if (curMatch3 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
-  {
-    *distances++ = 3;
-    *distances++ = lzPos - curMatch3 - 1;
-  }
-  return distances;
-}
-
-/*
-UInt32 *MixMatches4(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
-{
-  UInt32 hash2Value, hash3Value, hash4Value, curMatch2, curMatch3, curMatch4;
-  UInt32 *hash = p-&gt;hash;
-  const Byte *cur = p-&gt;pointerToCurPos;
-  UInt32 lzPos = p-&gt;lzPos;
-  MT_HASH4_CALC
-      
-  curMatch2 = hash[                hash2Value];
-  curMatch3 = hash[kFix3HashSize + hash3Value];
-  curMatch4 = hash[kFix4HashSize + hash4Value];
-  
-  hash[                hash2Value] =
-  hash[kFix3HashSize + hash3Value] =
-  hash[kFix4HashSize + hash4Value] =
-    lzPos;
-
-  if (curMatch2 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
-  {
-    distances[1] = lzPos - curMatch2 - 1;
-    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
-    {
-      distances[0] =  (cur[(ptrdiff_t)curMatch2 - lzPos + 3] == cur[3]) ? 4 : 3;
-      return distances + 2;
-    }
-    distances[0] = 2;
-    distances += 2;
-  }
-  if (curMatch3 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
-  {
-    distances[1] = lzPos - curMatch3 - 1;
-    if (cur[(ptrdiff_t)curMatch3 - lzPos + 3] == cur[3])
-    {
-      distances[0] = 4;
-      return distances + 2;
-    }
-    distances[0] = 3;
-    distances += 2;
-  }
-
-  if (curMatch4 &gt;= matchMinPos)
-    if (
-      cur[(ptrdiff_t)curMatch4 - lzPos] == cur[0] &amp;&amp;
-      cur[(ptrdiff_t)curMatch4 - lzPos + 3] == cur[3]
-      )
-    {
-      *distances++ = 4;
-      *distances++ = lzPos - curMatch4 - 1;
-    }
-  return distances;
-}
-*/
-
-#define INCREASE_LZ_POS p-&gt;lzPos++; p-&gt;pointerToCurPos++;
-
-UInt32 MatchFinderMt2_GetMatches(CMatchFinderMt *p, UInt32 *distances)
-{
-  const UInt32 *btBuf = p-&gt;btBuf + p-&gt;btBufPos;
-  UInt32 len = *btBuf++;
-  p-&gt;btBufPos += 1 + len;
-  p-&gt;btNumAvailBytes--;
-  {
-    UInt32 i;
-    for (i = 0; i &lt; len; i += 2)
-    {
-      *distances++ = *btBuf++;
-      *distances++ = *btBuf++;
-    }
-  }
-  INCREASE_LZ_POS
-  return len;
-}
-
-UInt32 MatchFinderMt_GetMatches(CMatchFinderMt *p, UInt32 *distances)
-{
-  const UInt32 *btBuf = p-&gt;btBuf + p-&gt;btBufPos;
-  UInt32 len = *btBuf++;
-  p-&gt;btBufPos += 1 + len;
-
-  if (len == 0)
-  {
-    if (p-&gt;btNumAvailBytes-- &gt;= 4)
-      len = (UInt32)(p-&gt;MixMatchesFunc(p, p-&gt;lzPos - p-&gt;historySize, distances) - (distances));
-  }
-  else
-  {
-    /* Condition: there are matches in btBuf with length &lt; p-&gt;numHashBytes */
-    UInt32 *distances2;
-    p-&gt;btNumAvailBytes--;
-    distances2 = p-&gt;MixMatchesFunc(p, p-&gt;lzPos - btBuf[1], distances);
-    do
-    {
-      *distances2++ = *btBuf++;
-      *distances2++ = *btBuf++;
-    }
-    while ((len -= 2) != 0);
-    len  = (UInt32)(distances2 - (distances));
-  }
-  INCREASE_LZ_POS
-  return len;
-}
-
-#define SKIP_HEADER2  do { GET_NEXT_BLOCK_IF_REQUIRED
-#define SKIP_HEADER(n) SKIP_HEADER2 if (p-&gt;btNumAvailBytes-- &gt;= (n)) { const Byte *cur = p-&gt;pointerToCurPos; UInt32 *hash = p-&gt;hash;
-#define SKIP_FOOTER } INCREASE_LZ_POS p-&gt;btBufPos += p-&gt;btBuf[p-&gt;btBufPos] + 1; } while (--num != 0);
-
-void MatchFinderMt0_Skip(CMatchFinderMt *p, UInt32 num)
-{
-  SKIP_HEADER2 { p-&gt;btNumAvailBytes--;
-  SKIP_FOOTER
-}
-
-void MatchFinderMt2_Skip(CMatchFinderMt *p, UInt32 num)
-{
-  SKIP_HEADER(2)
-      UInt32 hash2Value;
-      MT_HASH2_CALC
-      hash[hash2Value] = p-&gt;lzPos;
-  SKIP_FOOTER
-}
-
-void MatchFinderMt3_Skip(CMatchFinderMt *p, UInt32 num)
-{
-  SKIP_HEADER(3)
-      UInt32 hash2Value, hash3Value;
-      MT_HASH3_CALC
-      hash[kFix3HashSize + hash3Value] =
-      hash[                hash2Value] =
-        p-&gt;lzPos;
-  SKIP_FOOTER
-}
-
-/*
-void MatchFinderMt4_Skip(CMatchFinderMt *p, UInt32 num)
-{
-  SKIP_HEADER(4)
-      UInt32 hash2Value, hash3Value, hash4Value;
-      MT_HASH4_CALC
-      hash[kFix4HashSize + hash4Value] =
-      hash[kFix3HashSize + hash3Value] =
-      hash[                hash2Value] =
-        p-&gt;lzPos;
-  SKIP_FOOTER
-}
-*/
-
-void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable)
-{
-  vTable-&gt;Init = (Mf_Init_Func)MatchFinderMt_Init;
-  vTable-&gt;GetIndexByte = (Mf_GetIndexByte_Func)MatchFinderMt_GetIndexByte;
-  vTable-&gt;GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinderMt_GetNumAvailableBytes;
-  vTable-&gt;GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinderMt_GetPointerToCurrentPos;
-  vTable-&gt;GetMatches = (Mf_GetMatches_Func)MatchFinderMt_GetMatches;
-  switch(p-&gt;MatchFinder-&gt;numHashBytes)
-  {
-    case 2:
-      p-&gt;GetHeadsFunc = GetHeads2;
-      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)0;
-      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt0_Skip;
-      vTable-&gt;GetMatches = (Mf_GetMatches_Func)MatchFinderMt2_GetMatches;
-      break;
-    case 3:
-      p-&gt;GetHeadsFunc = GetHeads3;
-      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches2;
-      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt2_Skip;
-      break;
-    default:
-    /* case 4: */
-      p-&gt;GetHeadsFunc = p-&gt;MatchFinder-&gt;bigHash ? GetHeads4b : GetHeads4;
-      /* p-&gt;GetHeadsFunc = GetHeads4; */
-      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches3;
-      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt3_Skip;
-      break;
-    /*
-    default:
-      p-&gt;GetHeadsFunc = GetHeads5;
-      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches4;
-      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt4_Skip;
-      break;
-    */
-  }
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,795 @@
+/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#include &quot;LzHash.h&quot;
+
+#include &quot;LzFindMt.h&quot;
+
+void MtSync_Construct(CMtSync *p)
+{
+  p-&gt;wasCreated = False;
+  p-&gt;csWasInitialized = False;
+  p-&gt;csWasEntered = False;
+  Thread_Construct(&amp;p-&gt;thread);
+  Event_Construct(&amp;p-&gt;canStart);
+  Event_Construct(&amp;p-&gt;wasStarted);
+  Event_Construct(&amp;p-&gt;wasStopped);
+  Semaphore_Construct(&amp;p-&gt;freeSemaphore);
+  Semaphore_Construct(&amp;p-&gt;filledSemaphore);
+}
+
+void MtSync_GetNextBlock(CMtSync *p)
+{
+  if (p-&gt;needStart)
+  {
+    p-&gt;numProcessedBlocks = 1;
+    p-&gt;needStart = False;
+    p-&gt;stopWriting = False;
+    p-&gt;exit = False;
+    Event_Reset(&amp;p-&gt;wasStarted);
+    Event_Reset(&amp;p-&gt;wasStopped);
+
+    Event_Set(&amp;p-&gt;canStart);
+    Event_Wait(&amp;p-&gt;wasStarted);
+  }
+  else
+  {
+    CriticalSection_Leave(&amp;p-&gt;cs);
+    p-&gt;csWasEntered = False;
+    p-&gt;numProcessedBlocks++;
+    Semaphore_Release1(&amp;p-&gt;freeSemaphore);
+  }
+  Semaphore_Wait(&amp;p-&gt;filledSemaphore);
+  CriticalSection_Enter(&amp;p-&gt;cs);
+  p-&gt;csWasEntered = True;
+}
+
+/* MtSync_StopWriting must be called if Writing was started */
+
+void MtSync_StopWriting(CMtSync *p)
+{
+  UInt32 myNumBlocks = p-&gt;numProcessedBlocks;
+  if (!Thread_WasCreated(&amp;p-&gt;thread) || p-&gt;needStart)
+    return;
+  p-&gt;stopWriting = True;
+  if (p-&gt;csWasEntered)
+  {
+    CriticalSection_Leave(&amp;p-&gt;cs);
+    p-&gt;csWasEntered = False;
+  }
+  Semaphore_Release1(&amp;p-&gt;freeSemaphore);
+ 
+  Event_Wait(&amp;p-&gt;wasStopped);
+
+  while (myNumBlocks++ != p-&gt;numProcessedBlocks)
+  {
+    Semaphore_Wait(&amp;p-&gt;filledSemaphore);
+    Semaphore_Release1(&amp;p-&gt;freeSemaphore);
+  }
+  p-&gt;needStart = True;
+}
+
+void MtSync_Destruct(CMtSync *p)
+{
+  if (Thread_WasCreated(&amp;p-&gt;thread))
+  {
+    MtSync_StopWriting(p);
+    p-&gt;exit = True;
+    if (p-&gt;needStart)
+      Event_Set(&amp;p-&gt;canStart);
+    Thread_Wait(&amp;p-&gt;thread);
+    Thread_Close(&amp;p-&gt;thread);
+  }
+  if (p-&gt;csWasInitialized)
+  {
+    CriticalSection_Delete(&amp;p-&gt;cs);
+    p-&gt;csWasInitialized = False;
+  }
+
+  Event_Close(&amp;p-&gt;canStart);
+  Event_Close(&amp;p-&gt;wasStarted);
+  Event_Close(&amp;p-&gt;wasStopped);
+  Semaphore_Close(&amp;p-&gt;freeSemaphore);
+  Semaphore_Close(&amp;p-&gt;filledSemaphore);
+
+  p-&gt;wasCreated = False;
+}
+
+#define RINOK_THREAD(x) { if ((x) != 0) return SZ_ERROR_THREAD; }
+
+static SRes MtSync_Create2(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
+{
+  if (p-&gt;wasCreated)
+    return SZ_OK;
+
+  RINOK_THREAD(CriticalSection_Init(&amp;p-&gt;cs));
+  p-&gt;csWasInitialized = True;
+
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;canStart));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;wasStarted));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&amp;p-&gt;wasStopped));
+  
+  RINOK_THREAD(Semaphore_Create(&amp;p-&gt;freeSemaphore, numBlocks, numBlocks));
+  RINOK_THREAD(Semaphore_Create(&amp;p-&gt;filledSemaphore, 0, numBlocks));
+
+  p-&gt;needStart = True;
+  
+  RINOK_THREAD(Thread_Create(&amp;p-&gt;thread, startAddress, obj));
+  p-&gt;wasCreated = True;
+  return SZ_OK;
+}
+
+static SRes MtSync_Create(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
+{
+  SRes res = MtSync_Create2(p, startAddress, obj, numBlocks);
+  if (res != SZ_OK)
+    MtSync_Destruct(p);
+  return res;
+}
+
+void MtSync_Init(CMtSync *p) { p-&gt;needStart = True; }
+
+#define kMtMaxValForNormalize 0xFFFFFFFF
+
+#define DEF_GetHeads2(name, v, action) \
+static void GetHeads ## name(const Byte *p, UInt32 pos, \
+UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc) \
+{ action; for (; numHeads != 0; numHeads--) { \
+const UInt32 value = (v); p++; *heads++ = pos - hash[value]; hash[value] = pos++;  } }
+
+#define DEF_GetHeads(name, v) DEF_GetHeads2(name, v, ;)
+
+DEF_GetHeads2(2,  (p[0] | ((UInt32)p[1] &lt;&lt; 8)), hashMask = hashMask; crc = crc; )
+DEF_GetHeads(3,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8)) &amp; hashMask)
+DEF_GetHeads(4,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ (crc[p[3]] &lt;&lt; 5)) &amp; hashMask)
+DEF_GetHeads(4b, (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ ((UInt32)p[3] &lt;&lt; 16)) &amp; hashMask)
+DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] &lt;&lt; 8) ^ (crc[p[3]] &lt;&lt; 5) ^ (crc[p[4]] &lt;&lt; 3)) &amp; hashMask)
+
+void HashThreadFunc(CMatchFinderMt *mt)
+{
+  CMtSync *p = &amp;mt-&gt;hashSync;
+  for (;;)
+  {
+    UInt32 numProcessedBlocks = 0;
+    Event_Wait(&amp;p-&gt;canStart);
+    Event_Set(&amp;p-&gt;wasStarted);
+    for (;;)
+    {
+      if (p-&gt;exit)
+        return;
+      if (p-&gt;stopWriting)
+      {
+        p-&gt;numProcessedBlocks = numProcessedBlocks;
+        Event_Set(&amp;p-&gt;wasStopped);
+        break;
+      }
+
+      {
+        CMatchFinder *mf = mt-&gt;MatchFinder;
+        if (MatchFinder_NeedMove(mf))
+        {
+          CriticalSection_Enter(&amp;mt-&gt;btSync.cs);
+          CriticalSection_Enter(&amp;mt-&gt;hashSync.cs);
+          {
+            const Byte *beforePtr = MatchFinder_GetPointerToCurrentPos(mf);
+            const Byte *afterPtr;
+            MatchFinder_MoveBlock(mf);
+            afterPtr = MatchFinder_GetPointerToCurrentPos(mf);
+            mt-&gt;pointerToCurPos -= beforePtr - afterPtr;
+            mt-&gt;buffer -= beforePtr - afterPtr;
+          }
+          CriticalSection_Leave(&amp;mt-&gt;btSync.cs);
+          CriticalSection_Leave(&amp;mt-&gt;hashSync.cs);
+          continue;
+        }
+
+        Semaphore_Wait(&amp;p-&gt;freeSemaphore);
+
+        MatchFinder_ReadIfRequired(mf);
+        if (mf-&gt;pos &gt; (kMtMaxValForNormalize - kMtHashBlockSize))
+        {
+          UInt32 subValue = (mf-&gt;pos - mf-&gt;historySize - 1);
+          MatchFinder_ReduceOffsets(mf, subValue);
+          MatchFinder_Normalize3(subValue, mf-&gt;hash + mf-&gt;fixedHashSize, mf-&gt;hashMask + 1);
+        }
+        {
+          UInt32 *heads = mt-&gt;hashBuf + ((numProcessedBlocks++) &amp; kMtHashNumBlocksMask) * kMtHashBlockSize;
+          UInt32 num = mf-&gt;streamPos - mf-&gt;pos;
+          heads[0] = 2;
+          heads[1] = num;
+          if (num &gt;= mf-&gt;numHashBytes)
+          {
+            num = num - mf-&gt;numHashBytes + 1;
+            if (num &gt; kMtHashBlockSize - 2)
+              num = kMtHashBlockSize - 2;
+            mt-&gt;GetHeadsFunc(mf-&gt;buffer, mf-&gt;pos, mf-&gt;hash + mf-&gt;fixedHashSize, mf-&gt;hashMask, heads + 2, num, mf-&gt;crc);
+            heads[0] += num;
+          }
+          mf-&gt;pos += num;
+          mf-&gt;buffer += num;
+        }
+      }
+
+      Semaphore_Release1(&amp;p-&gt;filledSemaphore);
+    }
+  }
+}
+
+void MatchFinderMt_GetNextBlock_Hash(CMatchFinderMt *p)
+{
+  MtSync_GetNextBlock(&amp;p-&gt;hashSync);
+  p-&gt;hashBufPosLimit = p-&gt;hashBufPos = ((p-&gt;hashSync.numProcessedBlocks - 1) &amp; kMtHashNumBlocksMask) * kMtHashBlockSize;
+  p-&gt;hashBufPosLimit += p-&gt;hashBuf[p-&gt;hashBufPos++];
+  p-&gt;hashNumAvail = p-&gt;hashBuf[p-&gt;hashBufPos++];
+}
+
+#define kEmptyHashValue 0
+
+/* #define MFMT_GM_INLINE */
+
+#ifdef MFMT_GM_INLINE
+
+#define NO_INLINE MY_FAST_CALL
+
+Int32 NO_INLINE GetMatchesSpecN(UInt32 lenLimit, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *_distances, UInt32 _maxLen, const UInt32 *hash, Int32 limit, UInt32 size, UInt32 *posRes)
+{
+  do
+  {
+  UInt32 *distances = _distances + 1;
+  UInt32 curMatch = pos - *hash++;
+
+  CLzRef *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
+  UInt32 len0 = 0, len1 = 0;
+  UInt32 cutValue = _cutValue;
+  UInt32 maxLen = _maxLen;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta &gt;= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      break;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta &gt; _cyclicBufferPos) ? _cyclicBufferSize : 0)) &lt;&lt; 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 &lt; len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        if (++len != lenLimit &amp;&amp; pb[len] == cur[len])
+          while (++len != lenLimit)
+            if (pb[len] != cur[len])
+              break;
+        if (maxLen &lt; len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            break;
+          }
+        }
+      }
+      if (pb[len] &lt; cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+  pos++;
+  _cyclicBufferPos++;
+  cur++;
+  {
+    UInt32 num = (UInt32)(distances - _distances);
+    *_distances = num - 1;
+    _distances += num;
+    limit -= num;
+  }
+  }
+  while (limit &gt; 0 &amp;&amp; --size != 0);
+  *posRes = pos;
+  return limit;
+}
+
+#endif
+
+void BtGetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  UInt32 numProcessed = 0;
+  UInt32 curPos = 2;
+  UInt32 limit = kMtBtBlockSize - (p-&gt;matchMaxLen * 2);
+  distances[1] = p-&gt;hashNumAvail;
+  while (curPos &lt; limit)
+  {
+    if (p-&gt;hashBufPos == p-&gt;hashBufPosLimit)
+    {
+      MatchFinderMt_GetNextBlock_Hash(p);
+      distances[1] = numProcessed + p-&gt;hashNumAvail;
+      if (p-&gt;hashNumAvail &gt;= p-&gt;numHashBytes)
+        continue;
+      for (; p-&gt;hashNumAvail != 0; p-&gt;hashNumAvail--)
+        distances[curPos++] = 0;
+      break;
+    }
+    {
+      UInt32 size = p-&gt;hashBufPosLimit - p-&gt;hashBufPos;
+      UInt32 lenLimit = p-&gt;matchMaxLen;
+      UInt32 pos = p-&gt;pos;
+      UInt32 cyclicBufferPos = p-&gt;cyclicBufferPos;
+      if (lenLimit &gt;= p-&gt;hashNumAvail)
+        lenLimit = p-&gt;hashNumAvail;
+      {
+        UInt32 size2 = p-&gt;hashNumAvail - lenLimit + 1;
+        if (size2 &lt; size)
+          size = size2;
+        size2 = p-&gt;cyclicBufferSize - cyclicBufferPos;
+        if (size2 &lt; size)
+          size = size2;
+      }
+      #ifndef MFMT_GM_INLINE
+      while (curPos &lt; limit &amp;&amp; size-- != 0)
+      {
+        UInt32 *startDistances = distances + curPos;
+        UInt32 num = (UInt32)(GetMatchesSpec1(lenLimit, pos - p-&gt;hashBuf[p-&gt;hashBufPos++],
+          pos, p-&gt;buffer, p-&gt;son, cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue,
+          startDistances + 1, p-&gt;numHashBytes - 1) - startDistances);
+        *startDistances = num - 1;
+        curPos += num;
+        cyclicBufferPos++;
+        pos++;
+        p-&gt;buffer++;
+      }
+      #else
+      {
+        UInt32 posRes;
+        curPos = limit - GetMatchesSpecN(lenLimit, pos, p-&gt;buffer, p-&gt;son, cyclicBufferPos, p-&gt;cyclicBufferSize, p-&gt;cutValue,
+          distances + curPos, p-&gt;numHashBytes - 1, p-&gt;hashBuf + p-&gt;hashBufPos, (Int32)(limit - curPos) , size, &amp;posRes);
+        p-&gt;hashBufPos += posRes - pos;
+        cyclicBufferPos += posRes - pos;
+        p-&gt;buffer += posRes - pos;
+        pos = posRes;
+      }
+      #endif
+
+      numProcessed += pos - p-&gt;pos;
+      p-&gt;hashNumAvail -= pos - p-&gt;pos;
+      p-&gt;pos = pos;
+      if (cyclicBufferPos == p-&gt;cyclicBufferSize)
+        cyclicBufferPos = 0;
+      p-&gt;cyclicBufferPos = cyclicBufferPos;
+    }
+  }
+  distances[0] = curPos;
+}
+
+void BtFillBlock(CMatchFinderMt *p, UInt32 globalBlockIndex)
+{
+  CMtSync *sync = &amp;p-&gt;hashSync;
+  if (!sync-&gt;needStart)
+  {
+    CriticalSection_Enter(&amp;sync-&gt;cs);
+    sync-&gt;csWasEntered = True;
+  }
+  
+  BtGetMatches(p, p-&gt;btBuf + (globalBlockIndex &amp; kMtBtNumBlocksMask) * kMtBtBlockSize);
+
+  if (p-&gt;pos &gt; kMtMaxValForNormalize - kMtBtBlockSize)
+  {
+    UInt32 subValue = p-&gt;pos - p-&gt;cyclicBufferSize;
+    MatchFinder_Normalize3(subValue, p-&gt;son, p-&gt;cyclicBufferSize * 2);
+    p-&gt;pos -= subValue;
+  }
+
+  if (!sync-&gt;needStart)
+  {
+    CriticalSection_Leave(&amp;sync-&gt;cs);
+    sync-&gt;csWasEntered = False;
+  }
+}
+
+void BtThreadFunc(CMatchFinderMt *mt)
+{
+  CMtSync *p = &amp;mt-&gt;btSync;
+  for (;;)
+  {
+    UInt32 blockIndex = 0;
+    Event_Wait(&amp;p-&gt;canStart);
+    Event_Set(&amp;p-&gt;wasStarted);
+    for (;;)
+    {
+      if (p-&gt;exit)
+        return;
+      if (p-&gt;stopWriting)
+      {
+        p-&gt;numProcessedBlocks = blockIndex;
+        MtSync_StopWriting(&amp;mt-&gt;hashSync);
+        Event_Set(&amp;p-&gt;wasStopped);
+        break;
+      }
+      Semaphore_Wait(&amp;p-&gt;freeSemaphore);
+      BtFillBlock(mt, blockIndex++);
+      Semaphore_Release1(&amp;p-&gt;filledSemaphore);
+    }
+  }
+}
+
+void MatchFinderMt_Construct(CMatchFinderMt *p)
+{
+  p-&gt;hashBuf = 0;
+  MtSync_Construct(&amp;p-&gt;hashSync);
+  MtSync_Construct(&amp;p-&gt;btSync);
+}
+
+void MatchFinderMt_FreeMem(CMatchFinderMt *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;hashBuf);
+  p-&gt;hashBuf = 0;
+}
+
+void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc)
+{
+  MtSync_Destruct(&amp;p-&gt;hashSync);
+  MtSync_Destruct(&amp;p-&gt;btSync);
+  MatchFinderMt_FreeMem(p, alloc);
+}
+
+#define kHashBufferSize (kMtHashBlockSize * kMtHashNumBlocks)
+#define kBtBufferSize (kMtBtBlockSize * kMtBtNumBlocks)
+
+static unsigned MY_STD_CALL HashThreadFunc2(void *p) { HashThreadFunc((CMatchFinderMt *)p);  return 0; }
+static unsigned MY_STD_CALL BtThreadFunc2(void *p)
+{
+  Byte allocaDummy[0x180];
+  int i = 0;
+  for (i = 0; i &lt; 16; i++)
+    allocaDummy[i] = (Byte)i;
+  BtThreadFunc((CMatchFinderMt *)p);
+  return 0;
+}
+
+SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc)
+{
+  CMatchFinder *mf = p-&gt;MatchFinder;
+  p-&gt;historySize = historySize;
+  if (kMtBtBlockSize &lt;= matchMaxLen * 4)
+    return SZ_ERROR_PARAM;
+  if (p-&gt;hashBuf == 0)
+  {
+    p-&gt;hashBuf = (UInt32 *)alloc-&gt;Alloc(alloc, (kHashBufferSize + kBtBufferSize) * sizeof(UInt32));
+    if (p-&gt;hashBuf == 0)
+      return SZ_ERROR_MEM;
+    p-&gt;btBuf = p-&gt;hashBuf + kHashBufferSize;
+  }
+  keepAddBufferBefore += (kHashBufferSize + kBtBufferSize);
+  keepAddBufferAfter += kMtHashBlockSize;
+  if (!MatchFinder_Create(mf, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter, alloc))
+    return SZ_ERROR_MEM;
+
+  RINOK(MtSync_Create(&amp;p-&gt;hashSync, HashThreadFunc2, p, kMtHashNumBlocks));
+  RINOK(MtSync_Create(&amp;p-&gt;btSync, BtThreadFunc2, p, kMtBtNumBlocks));
+  return SZ_OK;
+}
+
+/* Call it after ReleaseStream / SetStream */
+void MatchFinderMt_Init(CMatchFinderMt *p)
+{
+  CMatchFinder *mf = p-&gt;MatchFinder;
+  p-&gt;btBufPos = p-&gt;btBufPosLimit = 0;
+  p-&gt;hashBufPos = p-&gt;hashBufPosLimit = 0;
+  MatchFinder_Init(mf);
+  p-&gt;pointerToCurPos = MatchFinder_GetPointerToCurrentPos(mf);
+  p-&gt;btNumAvailBytes = 0;
+  p-&gt;lzPos = p-&gt;historySize + 1;
+
+  p-&gt;hash = mf-&gt;hash;
+  p-&gt;fixedHashSize = mf-&gt;fixedHashSize;
+  p-&gt;crc = mf-&gt;crc;
+
+  p-&gt;son = mf-&gt;son;
+  p-&gt;matchMaxLen = mf-&gt;matchMaxLen;
+  p-&gt;numHashBytes = mf-&gt;numHashBytes;
+  p-&gt;pos = mf-&gt;pos;
+  p-&gt;buffer = mf-&gt;buffer;
+  p-&gt;cyclicBufferPos = mf-&gt;cyclicBufferPos;
+  p-&gt;cyclicBufferSize = mf-&gt;cyclicBufferSize;
+  p-&gt;cutValue = mf-&gt;cutValue;
+}
+
+/* ReleaseStream is required to finish multithreading */
+void MatchFinderMt_ReleaseStream(CMatchFinderMt *p)
+{
+  MtSync_StopWriting(&amp;p-&gt;btSync);
+  /* p-&gt;MatchFinder-&gt;ReleaseStream(); */
+}
+
+void MatchFinderMt_Normalize(CMatchFinderMt *p)
+{
+  MatchFinder_Normalize3(p-&gt;lzPos - p-&gt;historySize - 1, p-&gt;hash, p-&gt;fixedHashSize);
+  p-&gt;lzPos = p-&gt;historySize + 1;
+}
+
+void MatchFinderMt_GetNextBlock_Bt(CMatchFinderMt *p)
+{
+  UInt32 blockIndex;
+  MtSync_GetNextBlock(&amp;p-&gt;btSync);
+  blockIndex = ((p-&gt;btSync.numProcessedBlocks - 1) &amp; kMtBtNumBlocksMask);
+  p-&gt;btBufPosLimit = p-&gt;btBufPos = blockIndex * kMtBtBlockSize;
+  p-&gt;btBufPosLimit += p-&gt;btBuf[p-&gt;btBufPos++];
+  p-&gt;btNumAvailBytes = p-&gt;btBuf[p-&gt;btBufPos++];
+  if (p-&gt;lzPos &gt;= kMtMaxValForNormalize - kMtBtBlockSize)
+    MatchFinderMt_Normalize(p);
+}
+
+const Byte * MatchFinderMt_GetPointerToCurrentPos(CMatchFinderMt *p)
+{
+  return p-&gt;pointerToCurPos;
+}
+
+#define GET_NEXT_BLOCK_IF_REQUIRED if (p-&gt;btBufPos == p-&gt;btBufPosLimit) MatchFinderMt_GetNextBlock_Bt(p);
+
+UInt32 MatchFinderMt_GetNumAvailableBytes(CMatchFinderMt *p)
+{
+  GET_NEXT_BLOCK_IF_REQUIRED;
+  return p-&gt;btNumAvailBytes;
+}
+
+Byte MatchFinderMt_GetIndexByte(CMatchFinderMt *p, Int32 index)
+{
+  return p-&gt;pointerToCurPos[index];
+}
+
+UInt32 * MixMatches2(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, curMatch2;
+  UInt32 *hash = p-&gt;hash;
+  const Byte *cur = p-&gt;pointerToCurPos;
+  UInt32 lzPos = p-&gt;lzPos;
+  MT_HASH2_CALC
+      
+  curMatch2 = hash[hash2Value];
+  hash[hash2Value] = lzPos;
+
+  if (curMatch2 &gt;= matchMinPos)
+    if (cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+    {
+      *distances++ = 2;
+      *distances++ = lzPos - curMatch2 - 1;
+    }
+  return distances;
+}
+
+UInt32 * MixMatches3(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, curMatch2, curMatch3;
+  UInt32 *hash = p-&gt;hash;
+  const Byte *cur = p-&gt;pointerToCurPos;
+  UInt32 lzPos = p-&gt;lzPos;
+  MT_HASH3_CALC
+
+  curMatch2 = hash[                hash2Value];
+  curMatch3 = hash[kFix3HashSize + hash3Value];
+  
+  hash[                hash2Value] =
+  hash[kFix3HashSize + hash3Value] =
+    lzPos;
+
+  if (curMatch2 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch2 - 1;
+    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
+    {
+      distances[0] = 3;
+      return distances + 2;
+    }
+    distances[0] = 2;
+    distances += 2;
+  }
+  if (curMatch3 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
+  {
+    *distances++ = 3;
+    *distances++ = lzPos - curMatch3 - 1;
+  }
+  return distances;
+}
+
+/*
+UInt32 *MixMatches4(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, hash4Value, curMatch2, curMatch3, curMatch4;
+  UInt32 *hash = p-&gt;hash;
+  const Byte *cur = p-&gt;pointerToCurPos;
+  UInt32 lzPos = p-&gt;lzPos;
+  MT_HASH4_CALC
+      
+  curMatch2 = hash[                hash2Value];
+  curMatch3 = hash[kFix3HashSize + hash3Value];
+  curMatch4 = hash[kFix4HashSize + hash4Value];
+  
+  hash[                hash2Value] =
+  hash[kFix3HashSize + hash3Value] =
+  hash[kFix4HashSize + hash4Value] =
+    lzPos;
+
+  if (curMatch2 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch2 - 1;
+    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
+    {
+      distances[0] =  (cur[(ptrdiff_t)curMatch2 - lzPos + 3] == cur[3]) ? 4 : 3;
+      return distances + 2;
+    }
+    distances[0] = 2;
+    distances += 2;
+  }
+  if (curMatch3 &gt;= matchMinPos &amp;&amp; cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch3 - 1;
+    if (cur[(ptrdiff_t)curMatch3 - lzPos + 3] == cur[3])
+    {
+      distances[0] = 4;
+      return distances + 2;
+    }
+    distances[0] = 3;
+    distances += 2;
+  }
+
+  if (curMatch4 &gt;= matchMinPos)
+    if (
+      cur[(ptrdiff_t)curMatch4 - lzPos] == cur[0] &amp;&amp;
+      cur[(ptrdiff_t)curMatch4 - lzPos + 3] == cur[3]
+      )
+    {
+      *distances++ = 4;
+      *distances++ = lzPos - curMatch4 - 1;
+    }
+  return distances;
+}
+*/
+
+#define INCREASE_LZ_POS p-&gt;lzPos++; p-&gt;pointerToCurPos++;
+
+UInt32 MatchFinderMt2_GetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  const UInt32 *btBuf = p-&gt;btBuf + p-&gt;btBufPos;
+  UInt32 len = *btBuf++;
+  p-&gt;btBufPos += 1 + len;
+  p-&gt;btNumAvailBytes--;
+  {
+    UInt32 i;
+    for (i = 0; i &lt; len; i += 2)
+    {
+      *distances++ = *btBuf++;
+      *distances++ = *btBuf++;
+    }
+  }
+  INCREASE_LZ_POS
+  return len;
+}
+
+UInt32 MatchFinderMt_GetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  const UInt32 *btBuf = p-&gt;btBuf + p-&gt;btBufPos;
+  UInt32 len = *btBuf++;
+  p-&gt;btBufPos += 1 + len;
+
+  if (len == 0)
+  {
+    if (p-&gt;btNumAvailBytes-- &gt;= 4)
+      len = (UInt32)(p-&gt;MixMatchesFunc(p, p-&gt;lzPos - p-&gt;historySize, distances) - (distances));
+  }
+  else
+  {
+    /* Condition: there are matches in btBuf with length &lt; p-&gt;numHashBytes */
+    UInt32 *distances2;
+    p-&gt;btNumAvailBytes--;
+    distances2 = p-&gt;MixMatchesFunc(p, p-&gt;lzPos - btBuf[1], distances);
+    do
+    {
+      *distances2++ = *btBuf++;
+      *distances2++ = *btBuf++;
+    }
+    while ((len -= 2) != 0);
+    len  = (UInt32)(distances2 - (distances));
+  }
+  INCREASE_LZ_POS
+  return len;
+}
+
+#define SKIP_HEADER2  do { GET_NEXT_BLOCK_IF_REQUIRED
+#define SKIP_HEADER(n) SKIP_HEADER2 if (p-&gt;btNumAvailBytes-- &gt;= (n)) { const Byte *cur = p-&gt;pointerToCurPos; UInt32 *hash = p-&gt;hash;
+#define SKIP_FOOTER } INCREASE_LZ_POS p-&gt;btBufPos += p-&gt;btBuf[p-&gt;btBufPos] + 1; } while (--num != 0);
+
+void MatchFinderMt0_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER2 { p-&gt;btNumAvailBytes--;
+  SKIP_FOOTER
+}
+
+void MatchFinderMt2_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(2)
+      UInt32 hash2Value;
+      MT_HASH2_CALC
+      hash[hash2Value] = p-&gt;lzPos;
+  SKIP_FOOTER
+}
+
+void MatchFinderMt3_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(3)
+      UInt32 hash2Value, hash3Value;
+      MT_HASH3_CALC
+      hash[kFix3HashSize + hash3Value] =
+      hash[                hash2Value] =
+        p-&gt;lzPos;
+  SKIP_FOOTER
+}
+
+/*
+void MatchFinderMt4_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(4)
+      UInt32 hash2Value, hash3Value, hash4Value;
+      MT_HASH4_CALC
+      hash[kFix4HashSize + hash4Value] =
+      hash[kFix3HashSize + hash3Value] =
+      hash[                hash2Value] =
+        p-&gt;lzPos;
+  SKIP_FOOTER
+}
+*/
+
+void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable)
+{
+  vTable-&gt;Init = (Mf_Init_Func)MatchFinderMt_Init;
+  vTable-&gt;GetIndexByte = (Mf_GetIndexByte_Func)MatchFinderMt_GetIndexByte;
+  vTable-&gt;GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinderMt_GetNumAvailableBytes;
+  vTable-&gt;GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinderMt_GetPointerToCurrentPos;
+  vTable-&gt;GetMatches = (Mf_GetMatches_Func)MatchFinderMt_GetMatches;
+  switch(p-&gt;MatchFinder-&gt;numHashBytes)
+  {
+    case 2:
+      p-&gt;GetHeadsFunc = GetHeads2;
+      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)0;
+      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt0_Skip;
+      vTable-&gt;GetMatches = (Mf_GetMatches_Func)MatchFinderMt2_GetMatches;
+      break;
+    case 3:
+      p-&gt;GetHeadsFunc = GetHeads3;
+      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches2;
+      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt2_Skip;
+      break;
+    default:
+    /* case 4: */
+      p-&gt;GetHeadsFunc = p-&gt;MatchFinder-&gt;bigHash ? GetHeads4b : GetHeads4;
+      /* p-&gt;GetHeadsFunc = GetHeads4; */
+      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches3;
+      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt3_Skip;
+      break;
+    /*
+    default:
+      p-&gt;GetHeadsFunc = GetHeads5;
+      p-&gt;MixMatchesFunc = (Mf_Mix_Matches)MixMatches4;
+      vTable-&gt;Skip = (Mf_Skip_Func)MatchFinderMt4_Skip;
+      break;
+    */
+  }
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,99 +0,0 @@
-/* LzFindMt.h  -- multithreaded Match finder for LZ algorithms
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#ifndef __LZFINDMT_H
-#define __LZFINDMT_H
-
-#include &quot;Threads.h&quot;
-#include &quot;LzFind.h&quot;
-
-#define kMtHashBlockSize (1 &lt;&lt; 13)
-#define kMtHashNumBlocks (1 &lt;&lt; 3)
-#define kMtHashNumBlocksMask (kMtHashNumBlocks - 1)
-
-#define kMtBtBlockSize (1 &lt;&lt; 14)
-#define kMtBtNumBlocks (1 &lt;&lt; 6)
-#define kMtBtNumBlocksMask (kMtBtNumBlocks - 1)
-
-typedef struct _CMtSync
-{
-  Bool wasCreated;
-  Bool needStart;
-  Bool exit;
-  Bool stopWriting;
-
-  CThread thread;
-  CAutoResetEvent canStart;
-  CAutoResetEvent wasStarted;
-  CAutoResetEvent wasStopped;
-  CSemaphore freeSemaphore;
-  CSemaphore filledSemaphore;
-  Bool csWasInitialized;
-  Bool csWasEntered;
-  CCriticalSection cs;
-  UInt32 numProcessedBlocks;
-} CMtSync;
-
-typedef UInt32 * (*Mf_Mix_Matches)(void *p, UInt32 matchMinPos, UInt32 *distances);
-
-/* kMtCacheLineDummy must be &gt;= size_of_CPU_cache_line */
-#define kMtCacheLineDummy 128
-
-typedef void (*Mf_GetHeads)(const Byte *buffer, UInt32 pos,
-  UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc);
-
-typedef struct _CMatchFinderMt
-{
-  /* LZ */
-  const Byte *pointerToCurPos;
-  UInt32 *btBuf;
-  UInt32 btBufPos;
-  UInt32 btBufPosLimit;
-  UInt32 lzPos;
-  UInt32 btNumAvailBytes;
-
-  UInt32 *hash;
-  UInt32 fixedHashSize;
-  UInt32 historySize;
-  const UInt32 *crc;
-
-  Mf_Mix_Matches MixMatchesFunc;
-  
-  /* LZ + BT */
-  CMtSync btSync;
-  Byte btDummy[kMtCacheLineDummy];
-
-  /* BT */
-  UInt32 *hashBuf;
-  UInt32 hashBufPos;
-  UInt32 hashBufPosLimit;
-  UInt32 hashNumAvail;
-
-  CLzRef *son;
-  UInt32 matchMaxLen;
-  UInt32 numHashBytes;
-  UInt32 pos;
-  Byte *buffer;
-  UInt32 cyclicBufferPos;
-  UInt32 cyclicBufferSize; /* it must be historySize + 1 */
-  UInt32 cutValue;
-
-  /* BT + Hash */
-  CMtSync hashSync;
-  /* Byte hashDummy[kMtCacheLineDummy]; */
-  
-  /* Hash */
-  Mf_GetHeads GetHeadsFunc;
-  CMatchFinder *MatchFinder;
-} CMatchFinderMt;
-
-void MatchFinderMt_Construct(CMatchFinderMt *p);
-void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc);
-SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
-    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc);
-void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable);
-void MatchFinderMt_ReleaseStream(CMatchFinderMt *p);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzFindMt.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,99 @@
+/* LzFindMt.h  -- multithreaded Match finder for LZ algorithms
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#ifndef __LZFINDMT_H
+#define __LZFINDMT_H
+
+#include &quot;Threads.h&quot;
+#include &quot;LzFind.h&quot;
+
+#define kMtHashBlockSize (1 &lt;&lt; 13)
+#define kMtHashNumBlocks (1 &lt;&lt; 3)
+#define kMtHashNumBlocksMask (kMtHashNumBlocks - 1)
+
+#define kMtBtBlockSize (1 &lt;&lt; 14)
+#define kMtBtNumBlocks (1 &lt;&lt; 6)
+#define kMtBtNumBlocksMask (kMtBtNumBlocks - 1)
+
+typedef struct _CMtSync
+{
+  Bool wasCreated;
+  Bool needStart;
+  Bool exit;
+  Bool stopWriting;
+
+  CThread thread;
+  CAutoResetEvent canStart;
+  CAutoResetEvent wasStarted;
+  CAutoResetEvent wasStopped;
+  CSemaphore freeSemaphore;
+  CSemaphore filledSemaphore;
+  Bool csWasInitialized;
+  Bool csWasEntered;
+  CCriticalSection cs;
+  UInt32 numProcessedBlocks;
+} CMtSync;
+
+typedef UInt32 * (*Mf_Mix_Matches)(void *p, UInt32 matchMinPos, UInt32 *distances);
+
+/* kMtCacheLineDummy must be &gt;= size_of_CPU_cache_line */
+#define kMtCacheLineDummy 128
+
+typedef void (*Mf_GetHeads)(const Byte *buffer, UInt32 pos,
+  UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc);
+
+typedef struct _CMatchFinderMt
+{
+  /* LZ */
+  const Byte *pointerToCurPos;
+  UInt32 *btBuf;
+  UInt32 btBufPos;
+  UInt32 btBufPosLimit;
+  UInt32 lzPos;
+  UInt32 btNumAvailBytes;
+
+  UInt32 *hash;
+  UInt32 fixedHashSize;
+  UInt32 historySize;
+  const UInt32 *crc;
+
+  Mf_Mix_Matches MixMatchesFunc;
+  
+  /* LZ + BT */
+  CMtSync btSync;
+  Byte btDummy[kMtCacheLineDummy];
+
+  /* BT */
+  UInt32 *hashBuf;
+  UInt32 hashBufPos;
+  UInt32 hashBufPosLimit;
+  UInt32 hashNumAvail;
+
+  CLzRef *son;
+  UInt32 matchMaxLen;
+  UInt32 numHashBytes;
+  UInt32 pos;
+  Byte *buffer;
+  UInt32 cyclicBufferPos;
+  UInt32 cyclicBufferSize; /* it must be historySize + 1 */
+  UInt32 cutValue;
+
+  /* BT + Hash */
+  CMtSync hashSync;
+  /* Byte hashDummy[kMtCacheLineDummy]; */
+  
+  /* Hash */
+  Mf_GetHeads GetHeadsFunc;
+  CMatchFinder *MatchFinder;
+} CMatchFinderMt;
+
+void MatchFinderMt_Construct(CMatchFinderMt *p);
+void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc);
+SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc);
+void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable);
+void MatchFinderMt_ReleaseStream(CMatchFinderMt *p);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,56 +0,0 @@
-/* LzHash.h  -- HASH functions for LZ algorithms
-2008-03-26
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#ifndef __LZHASH_H
-#define __LZHASH_H
-
-#define kHash2Size (1 &lt;&lt; 10)
-#define kHash3Size (1 &lt;&lt; 16)
-#define kHash4Size (1 &lt;&lt; 20)
-
-#define kFix3HashSize (kHash2Size)
-#define kFix4HashSize (kHash2Size + kHash3Size)
-#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
-
-#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] &lt;&lt; 8);
-
-#define HASH3_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hashValue = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; p-&gt;hashMask; }
-
-#define HASH4_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
-  hashValue = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)) &amp; p-&gt;hashMask; }
-
-#define HASH5_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
-  hash4Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)); \
-  hashValue = (hash4Value ^ (p-&gt;crc[cur[4]] &lt;&lt; 3)) &amp; p-&gt;hashMask; \
-  hash4Value &amp;= (kHash4Size - 1); }
-
-/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] &lt;&lt; 8)) ^ p-&gt;crc[cur[2]]) &amp; 0xFFFF; */
-#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] &lt;&lt; 8)) ^ p-&gt;crc[cur[1]]) &amp; 0xFFFF;
-
-
-#define MT_HASH2_CALC \
-  hash2Value = (p-&gt;crc[cur[0]] ^ cur[1]) &amp; (kHash2Size - 1);
-
-#define MT_HASH3_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); }
-
-#define MT_HASH4_CALC { \
-  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp &amp; (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
-  hash4Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)) &amp; (kHash4Size - 1); }
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzHash.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,56 @@
+/* LzHash.h  -- HASH functions for LZ algorithms
+2008-03-26
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#ifndef __LZHASH_H
+#define __LZHASH_H
+
+#define kHash2Size (1 &lt;&lt; 10)
+#define kHash3Size (1 &lt;&lt; 16)
+#define kHash4Size (1 &lt;&lt; 20)
+
+#define kFix3HashSize (kHash2Size)
+#define kFix4HashSize (kHash2Size + kHash3Size)
+#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
+
+#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] &lt;&lt; 8);
+
+#define HASH3_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hashValue = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; p-&gt;hashMask; }
+
+#define HASH4_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
+  hashValue = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)) &amp; p-&gt;hashMask; }
+
+#define HASH5_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
+  hash4Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)); \
+  hashValue = (hash4Value ^ (p-&gt;crc[cur[4]] &lt;&lt; 3)) &amp; p-&gt;hashMask; \
+  hash4Value &amp;= (kHash4Size - 1); }
+
+/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] &lt;&lt; 8)) ^ p-&gt;crc[cur[2]]) &amp; 0xFFFF; */
+#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] &lt;&lt; 8)) ^ p-&gt;crc[cur[1]]) &amp; 0xFFFF;
+
+
+#define MT_HASH2_CALC \
+  hash2Value = (p-&gt;crc[cur[0]] ^ cur[1]) &amp; (kHash2Size - 1);
+
+#define MT_HASH3_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); }
+
+#define MT_HASH4_CALC { \
+  UInt32 temp = p-&gt;crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8)) &amp; (kHash3Size - 1); \
+  hash4Value = (temp ^ ((UInt32)cur[2] &lt;&lt; 8) ^ (p-&gt;crc[cur[3]] &lt;&lt; 5)) &amp; (kHash4Size - 1); }
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,1014 +0,0 @@
-/* LzmaDec.c -- LZMA Decoder
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaDec.h for license options */
-
-#include &quot;LzmaDec.h&quot;
-
-#include &lt;string.h&gt;
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
-#define kNumMoveBits 5
-
-#define RC_INIT_SIZE 5
-
-#define NORMALIZE if (range &lt; kTopValue) { range &lt;&lt;= 8; code = (code &lt;&lt; 8) | (*buf++); }
-
-#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
-#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) &gt;&gt; kNumMoveBits));
-#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt &gt;&gt; kNumMoveBits));
-#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
-  { UPDATE_0(p); i = (i + i); A0; } else \
-  { UPDATE_1(p); i = (i + i) + 1; A1; }
-#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
-
-#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
-#define TREE_DECODE(probs, limit, i) \
-  { i = 1; do { TREE_GET_BIT(probs, i); } while (i &lt; limit); i -= limit; }
-
-/* #define _LZMA_SIZE_OPT */
-
-#ifdef _LZMA_SIZE_OPT
-#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 &lt;&lt; 6), i)
-#else
-#define TREE_6_DECODE(probs, i) \
-  { i = 1; \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  i -= 0x40; }
-#endif
-
-#define NORMALIZE_CHECK if (range &lt; kTopValue) { if (buf &gt;= bufLimit) return DUMMY_ERROR; range &lt;&lt;= 8; code = (code &lt;&lt; 8) | (*buf++); }
-
-#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
-#define UPDATE_0_CHECK range = bound;
-#define UPDATE_1_CHECK range -= bound; code -= bound;
-#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
-  { UPDATE_0_CHECK; i = (i + i); A0; } else \
-  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
-#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
-#define TREE_DECODE_CHECK(probs, limit, i) \
-  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i &lt; limit); i -= limit; }
-
-
-#define kNumPosBitsMax 4
-#define kNumPosStatesMax (1 &lt;&lt; kNumPosBitsMax)
-
-#define kLenNumLowBits 3
-#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
-#define kLenNumMidBits 3
-#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
-#define kLenNumHighBits 8
-#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
-
-#define LenChoice 0
-#define LenChoice2 (LenChoice + 1)
-#define LenLow (LenChoice2 + 1)
-#define LenMid (LenLow + (kNumPosStatesMax &lt;&lt; kLenNumLowBits))
-#define LenHigh (LenMid + (kNumPosStatesMax &lt;&lt; kLenNumMidBits))
-#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
-
-
-#define kNumStates 12
-#define kNumLitStates 7
-
-#define kStartPosModelIndex 4
-#define kEndPosModelIndex 14
-#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex &gt;&gt; 1))
-
-#define kNumPosSlotBits 6
-#define kNumLenToPosStates 4
-
-#define kNumAlignBits 4
-#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
-
-#define kMatchMinLen 2
-#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-
-#define IsMatch 0
-#define IsRep (IsMatch + (kNumStates &lt;&lt; kNumPosBitsMax))
-#define IsRepG0 (IsRep + kNumStates)
-#define IsRepG1 (IsRepG0 + kNumStates)
-#define IsRepG2 (IsRepG1 + kNumStates)
-#define IsRep0Long (IsRepG2 + kNumStates)
-#define PosSlot (IsRep0Long + (kNumStates &lt;&lt; kNumPosBitsMax))
-#define SpecPos (PosSlot + (kNumLenToPosStates &lt;&lt; kNumPosSlotBits))
-#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
-#define LenCoder (Align + kAlignTableSize)
-#define RepLenCoder (LenCoder + kNumLenProbs)
-#define Literal (RepLenCoder + kNumLenProbs)
-
-#define LZMA_BASE_SIZE 1846
-#define LZMA_LIT_SIZE 768
-
-#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE &lt;&lt; ((p)-&gt;lc + (p)-&gt;lp)))
-
-#if Literal != LZMA_BASE_SIZE
-StopCompilingDueBUG
-#endif
-
-/*
-#define LZMA_STREAM_WAS_FINISHED_ID (-1)
-#define LZMA_SPEC_LEN_OFFSET (-3)
-*/
-
-const Byte kLiteralNextStates[kNumStates * 2] =
-{
-  0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
-  7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10
-};
-
-#define LZMA_DIC_MIN (1 &lt;&lt; 12)
-
-/* First LZMA-symbol is always decoded.
-And it decodes new LZMA-symbols while (buf &lt; bufLimit), but &quot;buf&quot; is without last normalization
-Out:
-  Result:
-    0 - OK
-    1 - Error
-  p-&gt;remainLen:
-    &lt; kMatchSpecLenStart : normal remain
-    = kMatchSpecLenStart : finished
-    = kMatchSpecLenStart + 1 : Flush marker
-    = kMatchSpecLenStart + 2 : State Init Marker
-*/
-
-static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-{
-  CLzmaProb *probs = p-&gt;probs;
-
-  unsigned state = p-&gt;state;
-  UInt32 rep0 = p-&gt;reps[0], rep1 = p-&gt;reps[1], rep2 = p-&gt;reps[2], rep3 = p-&gt;reps[3];
-  unsigned pbMask = ((unsigned)1 &lt;&lt; (p-&gt;prop.pb)) - 1;
-  unsigned lpMask = ((unsigned)1 &lt;&lt; (p-&gt;prop.lp)) - 1;
-  unsigned lc = p-&gt;prop.lc;
-
-  Byte *dic = p-&gt;dic;
-  SizeT dicBufSize = p-&gt;dicBufSize;
-  SizeT dicPos = p-&gt;dicPos;
-  
-  UInt32 processedPos = p-&gt;processedPos;
-  UInt32 checkDicSize = p-&gt;checkDicSize;
-  unsigned len = 0;
-
-  const Byte *buf = p-&gt;buf;
-  UInt32 range = p-&gt;range;
-  UInt32 code = p-&gt;code;
-
-  do
-  {
-    CLzmaProb *prob;
-    UInt32 bound;
-    unsigned ttt;
-    unsigned posState = processedPos &amp; pbMask;
-
-    prob = probs + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
-    IF_BIT_0(prob)
-    {
-      unsigned symbol;
-      UPDATE_0(prob);
-      prob = probs + Literal;
-      if (checkDicSize != 0 || processedPos != 0)
-        prob += (LZMA_LIT_SIZE * (((processedPos &amp; lpMask) &lt;&lt; lc) +
-        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] &gt;&gt; (8 - lc))));
-
-      if (state &lt; kNumLitStates)
-      {
-        symbol = 1;
-        do { GET_BIT(prob + symbol, symbol) } while (symbol &lt; 0x100);
-      }
-      else
-      {
-        unsigned matchByte = p-&gt;dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
-        unsigned offs = 0x100;
-        symbol = 1;
-        do
-        {
-          unsigned bit;
-          CLzmaProb *probLit;
-          matchByte &lt;&lt;= 1;
-          bit = (matchByte &amp; offs);
-          probLit = prob + offs + bit + symbol;
-          GET_BIT2(probLit, symbol, offs &amp;= ~bit, offs &amp;= bit)
-        }
-        while (symbol &lt; 0x100);
-      }
-      dic[dicPos++] = (Byte)symbol;
-      processedPos++;
-
-      state = kLiteralNextStates[state];
-      /* if (state &lt; 4) state = 0; else if (state &lt; 10) state -= 3; else state -= 6; */
-      continue;
-    }
-    else
-    {
-      UPDATE_1(prob);
-      prob = probs + IsRep + state;
-      IF_BIT_0(prob)
-      {
-        UPDATE_0(prob);
-        state += kNumStates;
-        prob = probs + LenCoder;
-      }
-      else
-      {
-        UPDATE_1(prob);
-        if (checkDicSize == 0 &amp;&amp; processedPos == 0)
-          return SZ_ERROR_DATA;
-        prob = probs + IsRepG0 + state;
-        IF_BIT_0(prob)
-        {
-          UPDATE_0(prob);
-          prob = probs + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
-          IF_BIT_0(prob)
-          {
-            UPDATE_0(prob);
-            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
-            dicPos++;
-            processedPos++;
-            state = state &lt; kNumLitStates ? 9 : 11;
-            continue;
-          }
-          UPDATE_1(prob);
-        }
-        else
-        {
-          UInt32 distance;
-          UPDATE_1(prob);
-          prob = probs + IsRepG1 + state;
-          IF_BIT_0(prob)
-          {
-            UPDATE_0(prob);
-            distance = rep1;
-          }
-          else
-          {
-            UPDATE_1(prob);
-            prob = probs + IsRepG2 + state;
-            IF_BIT_0(prob)
-            {
-              UPDATE_0(prob);
-              distance = rep2;
-            }
-            else
-            {
-              UPDATE_1(prob);
-              distance = rep3;
-              rep3 = rep2;
-            }
-            rep2 = rep1;
-          }
-          rep1 = rep0;
-          rep0 = distance;
-        }
-        state = state &lt; kNumLitStates ? 8 : 11;
-        prob = probs + RepLenCoder;
-      }
-      {
-        unsigned limit, offset;
-        CLzmaProb *probLen = prob + LenChoice;
-        IF_BIT_0(probLen)
-        {
-          UPDATE_0(probLen);
-          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
-          offset = 0;
-          limit = (1 &lt;&lt; kLenNumLowBits);
-        }
-        else
-        {
-          UPDATE_1(probLen);
-          probLen = prob + LenChoice2;
-          IF_BIT_0(probLen)
-          {
-            UPDATE_0(probLen);
-            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
-            offset = kLenNumLowSymbols;
-            limit = (1 &lt;&lt; kLenNumMidBits);
-          }
-          else
-          {
-            UPDATE_1(probLen);
-            probLen = prob + LenHigh;
-            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-            limit = (1 &lt;&lt; kLenNumHighBits);
-          }
-        }
-        TREE_DECODE(probLen, limit, len);
-        len += offset;
-      }
-
-      if (state &gt;= kNumStates)
-      {
-        UInt32 distance;
-        prob = probs + PosSlot +
-            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt; kNumPosSlotBits);
-        TREE_6_DECODE(prob, distance);
-        if (distance &gt;= kStartPosModelIndex)
-        {
-          unsigned posSlot = (unsigned)distance;
-          int numDirectBits = (int)(((distance &gt;&gt; 1) - 1));
-          distance = (2 | (distance &amp; 1));
-          if (posSlot &lt; kEndPosModelIndex)
-          {
-            distance &lt;&lt;= numDirectBits;
-            prob = probs + SpecPos + distance - posSlot - 1;
-            {
-              UInt32 mask = 1;
-              unsigned i = 1;
-              do
-              {
-                GET_BIT2(prob + i, i, ; , distance |= mask);
-                mask &lt;&lt;= 1;
-              }
-              while (--numDirectBits != 0);
-            }
-          }
-          else
-          {
-            numDirectBits -= kNumAlignBits;
-            do
-            {
-              NORMALIZE
-              range &gt;&gt;= 1;
-              
-              {
-                UInt32 t;
-                code -= range;
-                t = (0 - ((UInt32)code &gt;&gt; 31)); /* (UInt32)((Int32)code &gt;&gt; 31) */
-                distance = (distance &lt;&lt; 1) + (t + 1);
-                code += range &amp; t;
-              }
-              /*
-              distance &lt;&lt;= 1;
-              if (code &gt;= range)
-              {
-                code -= range;
-                distance |= 1;
-              }
-              */
-            }
-            while (--numDirectBits != 0);
-            prob = probs + Align;
-            distance &lt;&lt;= kNumAlignBits;
-            {
-              unsigned i = 1;
-              GET_BIT2(prob + i, i, ; , distance |= 1);
-              GET_BIT2(prob + i, i, ; , distance |= 2);
-              GET_BIT2(prob + i, i, ; , distance |= 4);
-              GET_BIT2(prob + i, i, ; , distance |= 8);
-            }
-            if (distance == (UInt32)0xFFFFFFFF)
-            {
-              len += kMatchSpecLenStart;
-              state -= kNumStates;
-              break;
-            }
-          }
-        }
-        rep3 = rep2;
-        rep2 = rep1;
-        rep1 = rep0;
-        rep0 = distance + 1;
-        if (checkDicSize == 0)
-        {
-          if (distance &gt;= processedPos)
-            return SZ_ERROR_DATA;
-        }
-        else if (distance &gt;= checkDicSize)
-          return SZ_ERROR_DATA;
-        state = (state &lt; kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
-        /* state = kLiteralNextStates[state]; */
-      }
-
-      len += kMatchMinLen;
-
-      {
-        SizeT rem = limit - dicPos;
-        unsigned curLen = ((rem &lt; len) ? (unsigned)rem : len);
-        SizeT pos = (dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0);
-
-        processedPos += curLen;
-
-        len -= curLen;
-        if (pos + curLen &lt;= dicBufSize)
-        {
-          Byte *dest = dic + dicPos;
-          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
-          const Byte *lim = dest + curLen;
-          dicPos += curLen;
-          do
-            *(dest) = (Byte)*(dest + src);
-          while (++dest != lim);
-        }
-        else
-        {
-          do
-          {
-            dic[dicPos++] = dic[pos];
-            if (++pos == dicBufSize)
-              pos = 0;
-          }
-          while (--curLen != 0);
-        }
-      }
-    }
-  }
-  while (dicPos &lt; limit &amp;&amp; buf &lt; bufLimit);
-  NORMALIZE;
-  p-&gt;buf = buf;
-  p-&gt;range = range;
-  p-&gt;code = code;
-  p-&gt;remainLen = len;
-  p-&gt;dicPos = dicPos;
-  p-&gt;processedPos = processedPos;
-  p-&gt;reps[0] = rep0;
-  p-&gt;reps[1] = rep1;
-  p-&gt;reps[2] = rep2;
-  p-&gt;reps[3] = rep3;
-  p-&gt;state = state;
-
-  return SZ_OK;
-}
-
-static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
-{
-  if (p-&gt;remainLen != 0 &amp;&amp; p-&gt;remainLen &lt; kMatchSpecLenStart)
-  {
-    Byte *dic = p-&gt;dic;
-    SizeT dicPos = p-&gt;dicPos;
-    SizeT dicBufSize = p-&gt;dicBufSize;
-    unsigned len = p-&gt;remainLen;
-    UInt32 rep0 = p-&gt;reps[0];
-    if (limit - dicPos &lt; len)
-      len = (unsigned)(limit - dicPos);
-
-    if (p-&gt;checkDicSize == 0 &amp;&amp; p-&gt;prop.dicSize - p-&gt;processedPos &lt;= len)
-      p-&gt;checkDicSize = p-&gt;prop.dicSize;
-
-    p-&gt;processedPos += len;
-    p-&gt;remainLen -= len;
-    while (len-- != 0)
-    {
-      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
-      dicPos++;
-    }
-    p-&gt;dicPos = dicPos;
-  }
-}
-
-/* LzmaDec_DecodeReal2 decodes LZMA-symbols and sets p-&gt;needFlush and p-&gt;needInit, if required. */
-
-static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-{
-  do
-  {
-    SizeT limit2 = limit;
-    if (p-&gt;checkDicSize == 0)
-    {
-      UInt32 rem = p-&gt;prop.dicSize - p-&gt;processedPos;
-      if (limit - p-&gt;dicPos &gt; rem)
-        limit2 = p-&gt;dicPos + rem;
-    }
-    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
-    if (p-&gt;processedPos &gt;= p-&gt;prop.dicSize)
-      p-&gt;checkDicSize = p-&gt;prop.dicSize;
-    LzmaDec_WriteRem(p, limit);
-  }
-  while (p-&gt;dicPos &lt; limit &amp;&amp; p-&gt;buf &lt; bufLimit &amp;&amp; p-&gt;remainLen &lt; kMatchSpecLenStart);
-
-  if (p-&gt;remainLen &gt; kMatchSpecLenStart)
-  {
-    p-&gt;remainLen = kMatchSpecLenStart;
-  }
-  return 0;
-}
-
-typedef enum
-{
-  DUMMY_ERROR, /* unexpected end of input stream */
-  DUMMY_LIT,
-  DUMMY_MATCH,
-  DUMMY_REP
-} ELzmaDummy;
-
-static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
-{
-  UInt32 range = p-&gt;range;
-  UInt32 code = p-&gt;code;
-  const Byte *bufLimit = buf + inSize;
-  CLzmaProb *probs = p-&gt;probs;
-  unsigned state = p-&gt;state;
-  ELzmaDummy res;
-
-  {
-    CLzmaProb *prob;
-    UInt32 bound;
-    unsigned ttt;
-    unsigned posState = (p-&gt;processedPos) &amp; ((1 &lt;&lt; p-&gt;prop.pb) - 1);
-
-    prob = probs + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
-    IF_BIT_0_CHECK(prob)
-    {
-      UPDATE_0_CHECK
-
-      /* if (bufLimit - buf &gt;= 7) return DUMMY_LIT; */
-
-      prob = probs + Literal;
-      if (p-&gt;checkDicSize != 0 || p-&gt;processedPos != 0)
-        prob += (LZMA_LIT_SIZE *
-          ((((p-&gt;processedPos) &amp; ((1 &lt;&lt; (p-&gt;prop.lp)) - 1)) &lt;&lt; p-&gt;prop.lc) +
-          (p-&gt;dic[(p-&gt;dicPos == 0 ? p-&gt;dicBufSize : p-&gt;dicPos) - 1] &gt;&gt; (8 - p-&gt;prop.lc))));
-
-      if (state &lt; kNumLitStates)
-      {
-        unsigned symbol = 1;
-        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol &lt; 0x100);
-      }
-      else
-      {
-        unsigned matchByte = p-&gt;dic[p-&gt;dicPos - p-&gt;reps[0] +
-            ((p-&gt;dicPos &lt; p-&gt;reps[0]) ? p-&gt;dicBufSize : 0)];
-        unsigned offs = 0x100;
-        unsigned symbol = 1;
-        do
-        {
-          unsigned bit;
-          CLzmaProb *probLit;
-          matchByte &lt;&lt;= 1;
-          bit = (matchByte &amp; offs);
-          probLit = prob + offs + bit + symbol;
-          GET_BIT2_CHECK(probLit, symbol, offs &amp;= ~bit, offs &amp;= bit)
-        }
-        while (symbol &lt; 0x100);
-      }
-      res = DUMMY_LIT;
-    }
-    else
-    {
-      unsigned len;
-      UPDATE_1_CHECK;
-
-      prob = probs + IsRep + state;
-      IF_BIT_0_CHECK(prob)
-      {
-        UPDATE_0_CHECK;
-        state = 0;
-        prob = probs + LenCoder;
-        res = DUMMY_MATCH;
-      }
-      else
-      {
-        UPDATE_1_CHECK;
-        res = DUMMY_REP;
-        prob = probs + IsRepG0 + state;
-        IF_BIT_0_CHECK(prob)
-        {
-          UPDATE_0_CHECK;
-          prob = probs + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
-          IF_BIT_0_CHECK(prob)
-          {
-            UPDATE_0_CHECK;
-            NORMALIZE_CHECK;
-            return DUMMY_REP;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-          }
-        }
-        else
-        {
-          UPDATE_1_CHECK;
-          prob = probs + IsRepG1 + state;
-          IF_BIT_0_CHECK(prob)
-          {
-            UPDATE_0_CHECK;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-            prob = probs + IsRepG2 + state;
-            IF_BIT_0_CHECK(prob)
-            {
-              UPDATE_0_CHECK;
-            }
-            else
-            {
-              UPDATE_1_CHECK;
-            }
-          }
-        }
-        state = kNumStates;
-        prob = probs + RepLenCoder;
-      }
-      {
-        unsigned limit, offset;
-        CLzmaProb *probLen = prob + LenChoice;
-        IF_BIT_0_CHECK(probLen)
-        {
-          UPDATE_0_CHECK;
-          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
-          offset = 0;
-          limit = 1 &lt;&lt; kLenNumLowBits;
-        }
-        else
-        {
-          UPDATE_1_CHECK;
-          probLen = prob + LenChoice2;
-          IF_BIT_0_CHECK(probLen)
-          {
-            UPDATE_0_CHECK;
-            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
-            offset = kLenNumLowSymbols;
-            limit = 1 &lt;&lt; kLenNumMidBits;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-            probLen = prob + LenHigh;
-            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-            limit = 1 &lt;&lt; kLenNumHighBits;
-          }
-        }
-        TREE_DECODE_CHECK(probLen, limit, len);
-        len += offset;
-      }
-
-      if (state &lt; 4)
-      {
-        unsigned posSlot;
-        prob = probs + PosSlot +
-            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt;
-            kNumPosSlotBits);
-        TREE_DECODE_CHECK(prob, 1 &lt;&lt; kNumPosSlotBits, posSlot);
-        if (posSlot &gt;= kStartPosModelIndex)
-        {
-          int numDirectBits = ((posSlot &gt;&gt; 1) - 1);
-
-          /* if (bufLimit - buf &gt;= 8) return DUMMY_MATCH; */
-
-          if (posSlot &lt; kEndPosModelIndex)
-          {
-            prob = probs + SpecPos + ((2 | (posSlot &amp; 1)) &lt;&lt; numDirectBits) - posSlot - 1;
-          }
-          else
-          {
-            numDirectBits -= kNumAlignBits;
-            do
-            {
-              NORMALIZE_CHECK
-              range &gt;&gt;= 1;
-              code -= range &amp; (((code - range) &gt;&gt; 31) - 1);
-              /* if (code &gt;= range) code -= range; */
-            }
-            while (--numDirectBits != 0);
-            prob = probs + Align;
-            numDirectBits = kNumAlignBits;
-          }
-          {
-            unsigned i = 1;
-            do
-            {
-              GET_BIT_CHECK(prob + i, i);
-            }
-            while (--numDirectBits != 0);
-          }
-        }
-      }
-    }
-  }
-  NORMALIZE_CHECK;
-  return res;
-}
-
-
-static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
-{
-  p-&gt;code = ((UInt32)data[1] &lt;&lt; 24) | ((UInt32)data[2] &lt;&lt; 16) | ((UInt32)data[3] &lt;&lt; 8) | ((UInt32)data[4]);
-  p-&gt;range = 0xFFFFFFFF;
-  p-&gt;needFlush = 0;
-}
-
-void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-{
-  p-&gt;needFlush = 1;
-  p-&gt;remainLen = 0;
-  p-&gt;tempBufSize = 0;
-
-  if (initDic)
-  {
-    p-&gt;processedPos = 0;
-    p-&gt;checkDicSize = 0;
-    p-&gt;needInitState = 1;
-  }
-  if (initState)
-    p-&gt;needInitState = 1;
-}
-
-void LzmaDec_Init(CLzmaDec *p)
-{
-  p-&gt;dicPos = 0;
-  LzmaDec_InitDicAndState(p, True, True);
-}
-
-static void LzmaDec_InitStateReal(CLzmaDec *p)
-{
-  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (p-&gt;prop.lc + p-&gt;prop.lp));
-  UInt32 i;
-  CLzmaProb *probs = p-&gt;probs;
-  for (i = 0; i &lt; numProbs; i++)
-    probs[i] = kBitModelTotal &gt;&gt; 1;
-  p-&gt;reps[0] = p-&gt;reps[1] = p-&gt;reps[2] = p-&gt;reps[3] = 1;
-  p-&gt;state = 0;
-  p-&gt;needInitState = 0;
-}
-
-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-    ELzmaFinishMode finishMode, ELzmaStatus *status)
-{
-  SizeT inSize = *srcLen;
-  (*srcLen) = 0;
-  LzmaDec_WriteRem(p, dicLimit);
-  
-  *status = LZMA_STATUS_NOT_SPECIFIED;
-
-  while (p-&gt;remainLen != kMatchSpecLenStart)
-  {
-      int checkEndMarkNow;
-
-      if (p-&gt;needFlush != 0)
-      {
-        for (; inSize &gt; 0 &amp;&amp; p-&gt;tempBufSize &lt; RC_INIT_SIZE; (*srcLen)++, inSize--)
-          p-&gt;tempBuf[p-&gt;tempBufSize++] = *src++;
-        if (p-&gt;tempBufSize &lt; RC_INIT_SIZE)
-        {
-          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-          return SZ_OK;
-        }
-        if (p-&gt;tempBuf[0] != 0)
-          return SZ_ERROR_DATA;
-
-        LzmaDec_InitRc(p, p-&gt;tempBuf);
-        p-&gt;tempBufSize = 0;
-      }
-
-      checkEndMarkNow = 0;
-      if (p-&gt;dicPos &gt;= dicLimit)
-      {
-        if (p-&gt;remainLen == 0 &amp;&amp; p-&gt;code == 0)
-        {
-          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
-          return SZ_OK;
-        }
-        if (finishMode == LZMA_FINISH_ANY)
-        {
-          *status = LZMA_STATUS_NOT_FINISHED;
-          return SZ_OK;
-        }
-        if (p-&gt;remainLen != 0)
-        {
-          *status = LZMA_STATUS_NOT_FINISHED;
-          return SZ_ERROR_DATA;
-        }
-        checkEndMarkNow = 1;
-      }
-
-      if (p-&gt;needInitState)
-        LzmaDec_InitStateReal(p);
-  
-      if (p-&gt;tempBufSize == 0)
-      {
-        SizeT processed;
-        const Byte *bufLimit;
-        if (inSize &lt; LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-        {
-          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
-          if (dummyRes == DUMMY_ERROR)
-          {
-            memcpy(p-&gt;tempBuf, src, inSize);
-            p-&gt;tempBufSize = (unsigned)inSize;
-            (*srcLen) += inSize;
-            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-            return SZ_OK;
-          }
-          if (checkEndMarkNow &amp;&amp; dummyRes != DUMMY_MATCH)
-          {
-            *status = LZMA_STATUS_NOT_FINISHED;
-            return SZ_ERROR_DATA;
-          }
-          bufLimit = src;
-        }
-        else
-          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
-        p-&gt;buf = src;
-        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
-          return SZ_ERROR_DATA;
-        processed = p-&gt;buf - src;
-        (*srcLen) += processed;
-        src += processed;
-        inSize -= processed;
-      }
-      else
-      {
-        unsigned rem = p-&gt;tempBufSize, lookAhead = 0;
-        while (rem &lt; LZMA_REQUIRED_INPUT_MAX &amp;&amp; lookAhead &lt; inSize)
-          p-&gt;tempBuf[rem++] = src[lookAhead++];
-        p-&gt;tempBufSize = rem;
-        if (rem &lt; LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-        {
-          int dummyRes = LzmaDec_TryDummy(p, p-&gt;tempBuf, rem);
-          if (dummyRes == DUMMY_ERROR)
-          {
-            (*srcLen) += lookAhead;
-            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-            return SZ_OK;
-          }
-          if (checkEndMarkNow &amp;&amp; dummyRes != DUMMY_MATCH)
-          {
-            *status = LZMA_STATUS_NOT_FINISHED;
-            return SZ_ERROR_DATA;
-          }
-        }
-        p-&gt;buf = p-&gt;tempBuf;
-        if (LzmaDec_DecodeReal2(p, dicLimit, p-&gt;buf) != 0)
-          return SZ_ERROR_DATA;
-        lookAhead -= (rem - (unsigned)(p-&gt;buf - p-&gt;tempBuf));
-        (*srcLen) += lookAhead;
-        src += lookAhead;
-        inSize -= lookAhead;
-        p-&gt;tempBufSize = 0;
-      }
-  }
-  if (p-&gt;code == 0)
-    *status = LZMA_STATUS_FINISHED_WITH_MARK;
-  return (p-&gt;code == 0) ? SZ_OK : SZ_ERROR_DATA;
-}
-
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
-{
-  SizeT outSize = *destLen;
-  SizeT inSize = *srcLen;
-  *srcLen = *destLen = 0;
-  for (;;)
-  {
-    SizeT inSizeCur = inSize, outSizeCur, dicPos;
-    ELzmaFinishMode curFinishMode;
-    SRes res;
-    if (p-&gt;dicPos == p-&gt;dicBufSize)
-      p-&gt;dicPos = 0;
-    dicPos = p-&gt;dicPos;
-    if (outSize &gt; p-&gt;dicBufSize - dicPos)
-    {
-      outSizeCur = p-&gt;dicBufSize;
-      curFinishMode = LZMA_FINISH_ANY;
-    }
-    else
-    {
-      outSizeCur = dicPos + outSize;
-      curFinishMode = finishMode;
-    }
-
-    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &amp;inSizeCur, curFinishMode, status);
-    src += inSizeCur;
-    inSize -= inSizeCur;
-    *srcLen += inSizeCur;
-    outSizeCur = p-&gt;dicPos - dicPos;
-    memcpy(dest, p-&gt;dic + dicPos, outSizeCur);
-    dest += outSizeCur;
-    outSize -= outSizeCur;
-    *destLen += outSizeCur;
-    if (res != 0)
-      return res;
-    if (outSizeCur == 0 || outSize == 0)
-      return SZ_OK;
-  }
-}
-
-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;probs);
-  p-&gt;probs = 0;
-}
-
-static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;dic);
-  p-&gt;dic = 0;
-}
-
-void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
-{
-  LzmaDec_FreeProbs(p, alloc);
-  LzmaDec_FreeDict(p, alloc);
-}
-
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-{
-  UInt32 dicSize;
-  Byte d;
-  
-  if (size &lt; LZMA_PROPS_SIZE)
-    return SZ_ERROR_UNSUPPORTED;
-  else
-    dicSize = data[1] | ((UInt32)data[2] &lt;&lt; 8) | ((UInt32)data[3] &lt;&lt; 16) | ((UInt32)data[4] &lt;&lt; 24);
- 
-  if (dicSize &lt; LZMA_DIC_MIN)
-    dicSize = LZMA_DIC_MIN;
-  p-&gt;dicSize = dicSize;
-
-  d = data[0];
-  if (d &gt;= (9 * 5 * 5))
-    return SZ_ERROR_UNSUPPORTED;
-
-  p-&gt;lc = d % 9;
-  d /= 9;
-  p-&gt;pb = d / 5;
-  p-&gt;lp = d % 5;
-
-  return SZ_OK;
-}
-
-static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
-{
-  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
-  if (p-&gt;probs == 0 || numProbs != p-&gt;numProbs)
-  {
-    LzmaDec_FreeProbs(p, alloc);
-    p-&gt;probs = (CLzmaProb *)alloc-&gt;Alloc(alloc, numProbs * sizeof(CLzmaProb));
-    p-&gt;numProbs = numProbs;
-    if (p-&gt;probs == 0)
-      return SZ_ERROR_MEM;
-  }
-  return SZ_OK;
-}
-
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-{
-  CLzmaProps propNew;
-  RINOK(LzmaProps_Decode(&amp;propNew, props, propsSize));
-  RINOK(LzmaDec_AllocateProbs2(p, &amp;propNew, alloc));
-  p-&gt;prop = propNew;
-  return SZ_OK;
-}
-
-SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-{
-  CLzmaProps propNew;
-  SizeT dicBufSize;
-  RINOK(LzmaProps_Decode(&amp;propNew, props, propsSize));
-  RINOK(LzmaDec_AllocateProbs2(p, &amp;propNew, alloc));
-  dicBufSize = propNew.dicSize;
-  if (p-&gt;dic == 0 || dicBufSize != p-&gt;dicBufSize)
-  {
-    LzmaDec_FreeDict(p, alloc);
-    p-&gt;dic = (Byte *)alloc-&gt;Alloc(alloc, dicBufSize);
-    if (p-&gt;dic == 0)
-    {
-      LzmaDec_FreeProbs(p, alloc);
-      return SZ_ERROR_MEM;
-    }
-  }
-  p-&gt;dicBufSize = dicBufSize;
-  p-&gt;prop = propNew;
-  return SZ_OK;
-}
-
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-    ELzmaStatus *status, ISzAlloc *alloc)
-{
-  CLzmaDec p;
-  SRes res;
-  SizeT inSize = *srcLen;
-  SizeT outSize = *destLen;
-  *srcLen = *destLen = 0;
-  if (inSize &lt; RC_INIT_SIZE)
-    return SZ_ERROR_INPUT_EOF;
-
-  LzmaDec_Construct(&amp;p);
-  res = LzmaDec_AllocateProbs(&amp;p, propData, propSize, alloc);
-  if (res != 0)
-    return res;
-  p.dic = dest;
-  p.dicBufSize = outSize;
-
-  LzmaDec_Init(&amp;p);
-  
-  *srcLen = inSize;
-  res = LzmaDec_DecodeToDic(&amp;p, outSize, src, srcLen, finishMode, status);
-
-  if (res == SZ_OK &amp;&amp; *status == LZMA_STATUS_NEEDS_MORE_INPUT)
-    res = SZ_ERROR_INPUT_EOF;
-
-  (*destLen) = p.dicPos;
-  LzmaDec_FreeProbs(&amp;p, alloc);
-  return res;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,1014 @@
+/* LzmaDec.c -- LZMA Decoder
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaDec.h for license options */
+
+#include &quot;LzmaDec.h&quot;
+
+#include &lt;string.h&gt;
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_INIT_SIZE 5
+
+#define NORMALIZE if (range &lt; kTopValue) { range &lt;&lt;= 8; code = (code &lt;&lt; 8) | (*buf++); }
+
+#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
+#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) &gt;&gt; kNumMoveBits));
+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt &gt;&gt; kNumMoveBits));
+#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
+  { UPDATE_0(p); i = (i + i); A0; } else \
+  { UPDATE_1(p); i = (i + i) + 1; A1; }
+#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
+
+#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
+#define TREE_DECODE(probs, limit, i) \
+  { i = 1; do { TREE_GET_BIT(probs, i); } while (i &lt; limit); i -= limit; }
+
+/* #define _LZMA_SIZE_OPT */
+
+#ifdef _LZMA_SIZE_OPT
+#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 &lt;&lt; 6), i)
+#else
+#define TREE_6_DECODE(probs, i) \
+  { i = 1; \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  i -= 0x40; }
+#endif
+
+#define NORMALIZE_CHECK if (range &lt; kTopValue) { if (buf &gt;= bufLimit) return DUMMY_ERROR; range &lt;&lt;= 8; code = (code &lt;&lt; 8) | (*buf++); }
+
+#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range &gt;&gt; kNumBitModelTotalBits) * ttt; if (code &lt; bound)
+#define UPDATE_0_CHECK range = bound;
+#define UPDATE_1_CHECK range -= bound; code -= bound;
+#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
+  { UPDATE_0_CHECK; i = (i + i); A0; } else \
+  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
+#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
+#define TREE_DECODE_CHECK(probs, limit, i) \
+  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i &lt; limit); i -= limit; }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 &lt;&lt; kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax &lt;&lt; kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax &lt;&lt; kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex &gt;&gt; 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
+
+#define kMatchMinLen 2
+#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates &lt;&lt; kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE &lt;&lt; ((p)-&gt;lc + (p)-&gt;lp)))
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+/*
+#define LZMA_STREAM_WAS_FINISHED_ID (-1)
+#define LZMA_SPEC_LEN_OFFSET (-3)
+*/
+
+const Byte kLiteralNextStates[kNumStates * 2] =
+{
+  0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
+  7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10
+};
+
+#define LZMA_DIC_MIN (1 &lt;&lt; 12)
+
+/* First LZMA-symbol is always decoded.
+And it decodes new LZMA-symbols while (buf &lt; bufLimit), but &quot;buf&quot; is without last normalization
+Out:
+  Result:
+    0 - OK
+    1 - Error
+  p-&gt;remainLen:
+    &lt; kMatchSpecLenStart : normal remain
+    = kMatchSpecLenStart : finished
+    = kMatchSpecLenStart + 1 : Flush marker
+    = kMatchSpecLenStart + 2 : State Init Marker
+*/
+
+static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+{
+  CLzmaProb *probs = p-&gt;probs;
+
+  unsigned state = p-&gt;state;
+  UInt32 rep0 = p-&gt;reps[0], rep1 = p-&gt;reps[1], rep2 = p-&gt;reps[2], rep3 = p-&gt;reps[3];
+  unsigned pbMask = ((unsigned)1 &lt;&lt; (p-&gt;prop.pb)) - 1;
+  unsigned lpMask = ((unsigned)1 &lt;&lt; (p-&gt;prop.lp)) - 1;
+  unsigned lc = p-&gt;prop.lc;
+
+  Byte *dic = p-&gt;dic;
+  SizeT dicBufSize = p-&gt;dicBufSize;
+  SizeT dicPos = p-&gt;dicPos;
+  
+  UInt32 processedPos = p-&gt;processedPos;
+  UInt32 checkDicSize = p-&gt;checkDicSize;
+  unsigned len = 0;
+
+  const Byte *buf = p-&gt;buf;
+  UInt32 range = p-&gt;range;
+  UInt32 code = p-&gt;code;
+
+  do
+  {
+    CLzmaProb *prob;
+    UInt32 bound;
+    unsigned ttt;
+    unsigned posState = processedPos &amp; pbMask;
+
+    prob = probs + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
+    IF_BIT_0(prob)
+    {
+      unsigned symbol;
+      UPDATE_0(prob);
+      prob = probs + Literal;
+      if (checkDicSize != 0 || processedPos != 0)
+        prob += (LZMA_LIT_SIZE * (((processedPos &amp; lpMask) &lt;&lt; lc) +
+        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] &gt;&gt; (8 - lc))));
+
+      if (state &lt; kNumLitStates)
+      {
+        symbol = 1;
+        do { GET_BIT(prob + symbol, symbol) } while (symbol &lt; 0x100);
+      }
+      else
+      {
+        unsigned matchByte = p-&gt;dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
+        unsigned offs = 0x100;
+        symbol = 1;
+        do
+        {
+          unsigned bit;
+          CLzmaProb *probLit;
+          matchByte &lt;&lt;= 1;
+          bit = (matchByte &amp; offs);
+          probLit = prob + offs + bit + symbol;
+          GET_BIT2(probLit, symbol, offs &amp;= ~bit, offs &amp;= bit)
+        }
+        while (symbol &lt; 0x100);
+      }
+      dic[dicPos++] = (Byte)symbol;
+      processedPos++;
+
+      state = kLiteralNextStates[state];
+      /* if (state &lt; 4) state = 0; else if (state &lt; 10) state -= 3; else state -= 6; */
+      continue;
+    }
+    else
+    {
+      UPDATE_1(prob);
+      prob = probs + IsRep + state;
+      IF_BIT_0(prob)
+      {
+        UPDATE_0(prob);
+        state += kNumStates;
+        prob = probs + LenCoder;
+      }
+      else
+      {
+        UPDATE_1(prob);
+        if (checkDicSize == 0 &amp;&amp; processedPos == 0)
+          return SZ_ERROR_DATA;
+        prob = probs + IsRepG0 + state;
+        IF_BIT_0(prob)
+        {
+          UPDATE_0(prob);
+          prob = probs + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
+          IF_BIT_0(prob)
+          {
+            UPDATE_0(prob);
+            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
+            dicPos++;
+            processedPos++;
+            state = state &lt; kNumLitStates ? 9 : 11;
+            continue;
+          }
+          UPDATE_1(prob);
+        }
+        else
+        {
+          UInt32 distance;
+          UPDATE_1(prob);
+          prob = probs + IsRepG1 + state;
+          IF_BIT_0(prob)
+          {
+            UPDATE_0(prob);
+            distance = rep1;
+          }
+          else
+          {
+            UPDATE_1(prob);
+            prob = probs + IsRepG2 + state;
+            IF_BIT_0(prob)
+            {
+              UPDATE_0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UPDATE_1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state &lt; kNumLitStates ? 8 : 11;
+        prob = probs + RepLenCoder;
+      }
+      {
+        unsigned limit, offset;
+        CLzmaProb *probLen = prob + LenChoice;
+        IF_BIT_0(probLen)
+        {
+          UPDATE_0(probLen);
+          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
+          offset = 0;
+          limit = (1 &lt;&lt; kLenNumLowBits);
+        }
+        else
+        {
+          UPDATE_1(probLen);
+          probLen = prob + LenChoice2;
+          IF_BIT_0(probLen)
+          {
+            UPDATE_0(probLen);
+            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            limit = (1 &lt;&lt; kLenNumMidBits);
+          }
+          else
+          {
+            UPDATE_1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            limit = (1 &lt;&lt; kLenNumHighBits);
+          }
+        }
+        TREE_DECODE(probLen, limit, len);
+        len += offset;
+      }
+
+      if (state &gt;= kNumStates)
+      {
+        UInt32 distance;
+        prob = probs + PosSlot +
+            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt; kNumPosSlotBits);
+        TREE_6_DECODE(prob, distance);
+        if (distance &gt;= kStartPosModelIndex)
+        {
+          unsigned posSlot = (unsigned)distance;
+          int numDirectBits = (int)(((distance &gt;&gt; 1) - 1));
+          distance = (2 | (distance &amp; 1));
+          if (posSlot &lt; kEndPosModelIndex)
+          {
+            distance &lt;&lt;= numDirectBits;
+            prob = probs + SpecPos + distance - posSlot - 1;
+            {
+              UInt32 mask = 1;
+              unsigned i = 1;
+              do
+              {
+                GET_BIT2(prob + i, i, ; , distance |= mask);
+                mask &lt;&lt;= 1;
+              }
+              while (--numDirectBits != 0);
+            }
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              NORMALIZE
+              range &gt;&gt;= 1;
+              
+              {
+                UInt32 t;
+                code -= range;
+                t = (0 - ((UInt32)code &gt;&gt; 31)); /* (UInt32)((Int32)code &gt;&gt; 31) */
+                distance = (distance &lt;&lt; 1) + (t + 1);
+                code += range &amp; t;
+              }
+              /*
+              distance &lt;&lt;= 1;
+              if (code &gt;= range)
+              {
+                code -= range;
+                distance |= 1;
+              }
+              */
+            }
+            while (--numDirectBits != 0);
+            prob = probs + Align;
+            distance &lt;&lt;= kNumAlignBits;
+            {
+              unsigned i = 1;
+              GET_BIT2(prob + i, i, ; , distance |= 1);
+              GET_BIT2(prob + i, i, ; , distance |= 2);
+              GET_BIT2(prob + i, i, ; , distance |= 4);
+              GET_BIT2(prob + i, i, ; , distance |= 8);
+            }
+            if (distance == (UInt32)0xFFFFFFFF)
+            {
+              len += kMatchSpecLenStart;
+              state -= kNumStates;
+              break;
+            }
+          }
+        }
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        rep0 = distance + 1;
+        if (checkDicSize == 0)
+        {
+          if (distance &gt;= processedPos)
+            return SZ_ERROR_DATA;
+        }
+        else if (distance &gt;= checkDicSize)
+          return SZ_ERROR_DATA;
+        state = (state &lt; kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
+        /* state = kLiteralNextStates[state]; */
+      }
+
+      len += kMatchMinLen;
+
+      {
+        SizeT rem = limit - dicPos;
+        unsigned curLen = ((rem &lt; len) ? (unsigned)rem : len);
+        SizeT pos = (dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0);
+
+        processedPos += curLen;
+
+        len -= curLen;
+        if (pos + curLen &lt;= dicBufSize)
+        {
+          Byte *dest = dic + dicPos;
+          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
+          const Byte *lim = dest + curLen;
+          dicPos += curLen;
+          do
+            *(dest) = (Byte)*(dest + src);
+          while (++dest != lim);
+        }
+        else
+        {
+          do
+          {
+            dic[dicPos++] = dic[pos];
+            if (++pos == dicBufSize)
+              pos = 0;
+          }
+          while (--curLen != 0);
+        }
+      }
+    }
+  }
+  while (dicPos &lt; limit &amp;&amp; buf &lt; bufLimit);
+  NORMALIZE;
+  p-&gt;buf = buf;
+  p-&gt;range = range;
+  p-&gt;code = code;
+  p-&gt;remainLen = len;
+  p-&gt;dicPos = dicPos;
+  p-&gt;processedPos = processedPos;
+  p-&gt;reps[0] = rep0;
+  p-&gt;reps[1] = rep1;
+  p-&gt;reps[2] = rep2;
+  p-&gt;reps[3] = rep3;
+  p-&gt;state = state;
+
+  return SZ_OK;
+}
+
+static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
+{
+  if (p-&gt;remainLen != 0 &amp;&amp; p-&gt;remainLen &lt; kMatchSpecLenStart)
+  {
+    Byte *dic = p-&gt;dic;
+    SizeT dicPos = p-&gt;dicPos;
+    SizeT dicBufSize = p-&gt;dicBufSize;
+    unsigned len = p-&gt;remainLen;
+    UInt32 rep0 = p-&gt;reps[0];
+    if (limit - dicPos &lt; len)
+      len = (unsigned)(limit - dicPos);
+
+    if (p-&gt;checkDicSize == 0 &amp;&amp; p-&gt;prop.dicSize - p-&gt;processedPos &lt;= len)
+      p-&gt;checkDicSize = p-&gt;prop.dicSize;
+
+    p-&gt;processedPos += len;
+    p-&gt;remainLen -= len;
+    while (len-- != 0)
+    {
+      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos &lt; rep0) ? dicBufSize : 0)];
+      dicPos++;
+    }
+    p-&gt;dicPos = dicPos;
+  }
+}
+
+/* LzmaDec_DecodeReal2 decodes LZMA-symbols and sets p-&gt;needFlush and p-&gt;needInit, if required. */
+
+static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+{
+  do
+  {
+    SizeT limit2 = limit;
+    if (p-&gt;checkDicSize == 0)
+    {
+      UInt32 rem = p-&gt;prop.dicSize - p-&gt;processedPos;
+      if (limit - p-&gt;dicPos &gt; rem)
+        limit2 = p-&gt;dicPos + rem;
+    }
+    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
+    if (p-&gt;processedPos &gt;= p-&gt;prop.dicSize)
+      p-&gt;checkDicSize = p-&gt;prop.dicSize;
+    LzmaDec_WriteRem(p, limit);
+  }
+  while (p-&gt;dicPos &lt; limit &amp;&amp; p-&gt;buf &lt; bufLimit &amp;&amp; p-&gt;remainLen &lt; kMatchSpecLenStart);
+
+  if (p-&gt;remainLen &gt; kMatchSpecLenStart)
+  {
+    p-&gt;remainLen = kMatchSpecLenStart;
+  }
+  return 0;
+}
+
+typedef enum
+{
+  DUMMY_ERROR, /* unexpected end of input stream */
+  DUMMY_LIT,
+  DUMMY_MATCH,
+  DUMMY_REP
+} ELzmaDummy;
+
+static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
+{
+  UInt32 range = p-&gt;range;
+  UInt32 code = p-&gt;code;
+  const Byte *bufLimit = buf + inSize;
+  CLzmaProb *probs = p-&gt;probs;
+  unsigned state = p-&gt;state;
+  ELzmaDummy res;
+
+  {
+    CLzmaProb *prob;
+    UInt32 bound;
+    unsigned ttt;
+    unsigned posState = (p-&gt;processedPos) &amp; ((1 &lt;&lt; p-&gt;prop.pb) - 1);
+
+    prob = probs + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
+    IF_BIT_0_CHECK(prob)
+    {
+      UPDATE_0_CHECK
+
+      /* if (bufLimit - buf &gt;= 7) return DUMMY_LIT; */
+
+      prob = probs + Literal;
+      if (p-&gt;checkDicSize != 0 || p-&gt;processedPos != 0)
+        prob += (LZMA_LIT_SIZE *
+          ((((p-&gt;processedPos) &amp; ((1 &lt;&lt; (p-&gt;prop.lp)) - 1)) &lt;&lt; p-&gt;prop.lc) +
+          (p-&gt;dic[(p-&gt;dicPos == 0 ? p-&gt;dicBufSize : p-&gt;dicPos) - 1] &gt;&gt; (8 - p-&gt;prop.lc))));
+
+      if (state &lt; kNumLitStates)
+      {
+        unsigned symbol = 1;
+        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol &lt; 0x100);
+      }
+      else
+      {
+        unsigned matchByte = p-&gt;dic[p-&gt;dicPos - p-&gt;reps[0] +
+            ((p-&gt;dicPos &lt; p-&gt;reps[0]) ? p-&gt;dicBufSize : 0)];
+        unsigned offs = 0x100;
+        unsigned symbol = 1;
+        do
+        {
+          unsigned bit;
+          CLzmaProb *probLit;
+          matchByte &lt;&lt;= 1;
+          bit = (matchByte &amp; offs);
+          probLit = prob + offs + bit + symbol;
+          GET_BIT2_CHECK(probLit, symbol, offs &amp;= ~bit, offs &amp;= bit)
+        }
+        while (symbol &lt; 0x100);
+      }
+      res = DUMMY_LIT;
+    }
+    else
+    {
+      unsigned len;
+      UPDATE_1_CHECK;
+
+      prob = probs + IsRep + state;
+      IF_BIT_0_CHECK(prob)
+      {
+        UPDATE_0_CHECK;
+        state = 0;
+        prob = probs + LenCoder;
+        res = DUMMY_MATCH;
+      }
+      else
+      {
+        UPDATE_1_CHECK;
+        res = DUMMY_REP;
+        prob = probs + IsRepG0 + state;
+        IF_BIT_0_CHECK(prob)
+        {
+          UPDATE_0_CHECK;
+          prob = probs + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
+          IF_BIT_0_CHECK(prob)
+          {
+            UPDATE_0_CHECK;
+            NORMALIZE_CHECK;
+            return DUMMY_REP;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+          }
+        }
+        else
+        {
+          UPDATE_1_CHECK;
+          prob = probs + IsRepG1 + state;
+          IF_BIT_0_CHECK(prob)
+          {
+            UPDATE_0_CHECK;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+            prob = probs + IsRepG2 + state;
+            IF_BIT_0_CHECK(prob)
+            {
+              UPDATE_0_CHECK;
+            }
+            else
+            {
+              UPDATE_1_CHECK;
+            }
+          }
+        }
+        state = kNumStates;
+        prob = probs + RepLenCoder;
+      }
+      {
+        unsigned limit, offset;
+        CLzmaProb *probLen = prob + LenChoice;
+        IF_BIT_0_CHECK(probLen)
+        {
+          UPDATE_0_CHECK;
+          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
+          offset = 0;
+          limit = 1 &lt;&lt; kLenNumLowBits;
+        }
+        else
+        {
+          UPDATE_1_CHECK;
+          probLen = prob + LenChoice2;
+          IF_BIT_0_CHECK(probLen)
+          {
+            UPDATE_0_CHECK;
+            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            limit = 1 &lt;&lt; kLenNumMidBits;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            limit = 1 &lt;&lt; kLenNumHighBits;
+          }
+        }
+        TREE_DECODE_CHECK(probLen, limit, len);
+        len += offset;
+      }
+
+      if (state &lt; 4)
+      {
+        unsigned posSlot;
+        prob = probs + PosSlot +
+            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt;
+            kNumPosSlotBits);
+        TREE_DECODE_CHECK(prob, 1 &lt;&lt; kNumPosSlotBits, posSlot);
+        if (posSlot &gt;= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot &gt;&gt; 1) - 1);
+
+          /* if (bufLimit - buf &gt;= 8) return DUMMY_MATCH; */
+
+          if (posSlot &lt; kEndPosModelIndex)
+          {
+            prob = probs + SpecPos + ((2 | (posSlot &amp; 1)) &lt;&lt; numDirectBits) - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              NORMALIZE_CHECK
+              range &gt;&gt;= 1;
+              code -= range &amp; (((code - range) &gt;&gt; 31) - 1);
+              /* if (code &gt;= range) code -= range; */
+            }
+            while (--numDirectBits != 0);
+            prob = probs + Align;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            unsigned i = 1;
+            do
+            {
+              GET_BIT_CHECK(prob + i, i);
+            }
+            while (--numDirectBits != 0);
+          }
+        }
+      }
+    }
+  }
+  NORMALIZE_CHECK;
+  return res;
+}
+
+
+static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
+{
+  p-&gt;code = ((UInt32)data[1] &lt;&lt; 24) | ((UInt32)data[2] &lt;&lt; 16) | ((UInt32)data[3] &lt;&lt; 8) | ((UInt32)data[4]);
+  p-&gt;range = 0xFFFFFFFF;
+  p-&gt;needFlush = 0;
+}
+
+void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
+{
+  p-&gt;needFlush = 1;
+  p-&gt;remainLen = 0;
+  p-&gt;tempBufSize = 0;
+
+  if (initDic)
+  {
+    p-&gt;processedPos = 0;
+    p-&gt;checkDicSize = 0;
+    p-&gt;needInitState = 1;
+  }
+  if (initState)
+    p-&gt;needInitState = 1;
+}
+
+void LzmaDec_Init(CLzmaDec *p)
+{
+  p-&gt;dicPos = 0;
+  LzmaDec_InitDicAndState(p, True, True);
+}
+
+static void LzmaDec_InitStateReal(CLzmaDec *p)
+{
+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (p-&gt;prop.lc + p-&gt;prop.lp));
+  UInt32 i;
+  CLzmaProb *probs = p-&gt;probs;
+  for (i = 0; i &lt; numProbs; i++)
+    probs[i] = kBitModelTotal &gt;&gt; 1;
+  p-&gt;reps[0] = p-&gt;reps[1] = p-&gt;reps[2] = p-&gt;reps[3] = 1;
+  p-&gt;state = 0;
+  p-&gt;needInitState = 0;
+}
+
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
+    ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT inSize = *srcLen;
+  (*srcLen) = 0;
+  LzmaDec_WriteRem(p, dicLimit);
+  
+  *status = LZMA_STATUS_NOT_SPECIFIED;
+
+  while (p-&gt;remainLen != kMatchSpecLenStart)
+  {
+      int checkEndMarkNow;
+
+      if (p-&gt;needFlush != 0)
+      {
+        for (; inSize &gt; 0 &amp;&amp; p-&gt;tempBufSize &lt; RC_INIT_SIZE; (*srcLen)++, inSize--)
+          p-&gt;tempBuf[p-&gt;tempBufSize++] = *src++;
+        if (p-&gt;tempBufSize &lt; RC_INIT_SIZE)
+        {
+          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+          return SZ_OK;
+        }
+        if (p-&gt;tempBuf[0] != 0)
+          return SZ_ERROR_DATA;
+
+        LzmaDec_InitRc(p, p-&gt;tempBuf);
+        p-&gt;tempBufSize = 0;
+      }
+
+      checkEndMarkNow = 0;
+      if (p-&gt;dicPos &gt;= dicLimit)
+      {
+        if (p-&gt;remainLen == 0 &amp;&amp; p-&gt;code == 0)
+        {
+          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
+          return SZ_OK;
+        }
+        if (finishMode == LZMA_FINISH_ANY)
+        {
+          *status = LZMA_STATUS_NOT_FINISHED;
+          return SZ_OK;
+        }
+        if (p-&gt;remainLen != 0)
+        {
+          *status = LZMA_STATUS_NOT_FINISHED;
+          return SZ_ERROR_DATA;
+        }
+        checkEndMarkNow = 1;
+      }
+
+      if (p-&gt;needInitState)
+        LzmaDec_InitStateReal(p);
+  
+      if (p-&gt;tempBufSize == 0)
+      {
+        SizeT processed;
+        const Byte *bufLimit;
+        if (inSize &lt; LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
+        {
+          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
+          if (dummyRes == DUMMY_ERROR)
+          {
+            memcpy(p-&gt;tempBuf, src, inSize);
+            p-&gt;tempBufSize = (unsigned)inSize;
+            (*srcLen) += inSize;
+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+            return SZ_OK;
+          }
+          if (checkEndMarkNow &amp;&amp; dummyRes != DUMMY_MATCH)
+          {
+            *status = LZMA_STATUS_NOT_FINISHED;
+            return SZ_ERROR_DATA;
+          }
+          bufLimit = src;
+        }
+        else
+          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
+        p-&gt;buf = src;
+        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
+          return SZ_ERROR_DATA;
+        processed = p-&gt;buf - src;
+        (*srcLen) += processed;
+        src += processed;
+        inSize -= processed;
+      }
+      else
+      {
+        unsigned rem = p-&gt;tempBufSize, lookAhead = 0;
+        while (rem &lt; LZMA_REQUIRED_INPUT_MAX &amp;&amp; lookAhead &lt; inSize)
+          p-&gt;tempBuf[rem++] = src[lookAhead++];
+        p-&gt;tempBufSize = rem;
+        if (rem &lt; LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
+        {
+          int dummyRes = LzmaDec_TryDummy(p, p-&gt;tempBuf, rem);
+          if (dummyRes == DUMMY_ERROR)
+          {
+            (*srcLen) += lookAhead;
+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+            return SZ_OK;
+          }
+          if (checkEndMarkNow &amp;&amp; dummyRes != DUMMY_MATCH)
+          {
+            *status = LZMA_STATUS_NOT_FINISHED;
+            return SZ_ERROR_DATA;
+          }
+        }
+        p-&gt;buf = p-&gt;tempBuf;
+        if (LzmaDec_DecodeReal2(p, dicLimit, p-&gt;buf) != 0)
+          return SZ_ERROR_DATA;
+        lookAhead -= (rem - (unsigned)(p-&gt;buf - p-&gt;tempBuf));
+        (*srcLen) += lookAhead;
+        src += lookAhead;
+        inSize -= lookAhead;
+        p-&gt;tempBufSize = 0;
+      }
+  }
+  if (p-&gt;code == 0)
+    *status = LZMA_STATUS_FINISHED_WITH_MARK;
+  return (p-&gt;code == 0) ? SZ_OK : SZ_ERROR_DATA;
+}
+
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT outSize = *destLen;
+  SizeT inSize = *srcLen;
+  *srcLen = *destLen = 0;
+  for (;;)
+  {
+    SizeT inSizeCur = inSize, outSizeCur, dicPos;
+    ELzmaFinishMode curFinishMode;
+    SRes res;
+    if (p-&gt;dicPos == p-&gt;dicBufSize)
+      p-&gt;dicPos = 0;
+    dicPos = p-&gt;dicPos;
+    if (outSize &gt; p-&gt;dicBufSize - dicPos)
+    {
+      outSizeCur = p-&gt;dicBufSize;
+      curFinishMode = LZMA_FINISH_ANY;
+    }
+    else
+    {
+      outSizeCur = dicPos + outSize;
+      curFinishMode = finishMode;
+    }
+
+    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &amp;inSizeCur, curFinishMode, status);
+    src += inSizeCur;
+    inSize -= inSizeCur;
+    *srcLen += inSizeCur;
+    outSizeCur = p-&gt;dicPos - dicPos;
+    memcpy(dest, p-&gt;dic + dicPos, outSizeCur);
+    dest += outSizeCur;
+    outSize -= outSizeCur;
+    *destLen += outSizeCur;
+    if (res != 0)
+      return res;
+    if (outSizeCur == 0 || outSize == 0)
+      return SZ_OK;
+  }
+}
+
+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;probs);
+  p-&gt;probs = 0;
+}
+
+static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;dic);
+  p-&gt;dic = 0;
+}
+
+void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
+{
+  LzmaDec_FreeProbs(p, alloc);
+  LzmaDec_FreeDict(p, alloc);
+}
+
+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
+{
+  UInt32 dicSize;
+  Byte d;
+  
+  if (size &lt; LZMA_PROPS_SIZE)
+    return SZ_ERROR_UNSUPPORTED;
+  else
+    dicSize = data[1] | ((UInt32)data[2] &lt;&lt; 8) | ((UInt32)data[3] &lt;&lt; 16) | ((UInt32)data[4] &lt;&lt; 24);
+ 
+  if (dicSize &lt; LZMA_DIC_MIN)
+    dicSize = LZMA_DIC_MIN;
+  p-&gt;dicSize = dicSize;
+
+  d = data[0];
+  if (d &gt;= (9 * 5 * 5))
+    return SZ_ERROR_UNSUPPORTED;
+
+  p-&gt;lc = d % 9;
+  d /= 9;
+  p-&gt;pb = d / 5;
+  p-&gt;lp = d % 5;
+
+  return SZ_OK;
+}
+
+static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
+{
+  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
+  if (p-&gt;probs == 0 || numProbs != p-&gt;numProbs)
+  {
+    LzmaDec_FreeProbs(p, alloc);
+    p-&gt;probs = (CLzmaProb *)alloc-&gt;Alloc(alloc, numProbs * sizeof(CLzmaProb));
+    p-&gt;numProbs = numProbs;
+    if (p-&gt;probs == 0)
+      return SZ_ERROR_MEM;
+  }
+  return SZ_OK;
+}
+
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+{
+  CLzmaProps propNew;
+  RINOK(LzmaProps_Decode(&amp;propNew, props, propsSize));
+  RINOK(LzmaDec_AllocateProbs2(p, &amp;propNew, alloc));
+  p-&gt;prop = propNew;
+  return SZ_OK;
+}
+
+SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+{
+  CLzmaProps propNew;
+  SizeT dicBufSize;
+  RINOK(LzmaProps_Decode(&amp;propNew, props, propsSize));
+  RINOK(LzmaDec_AllocateProbs2(p, &amp;propNew, alloc));
+  dicBufSize = propNew.dicSize;
+  if (p-&gt;dic == 0 || dicBufSize != p-&gt;dicBufSize)
+  {
+    LzmaDec_FreeDict(p, alloc);
+    p-&gt;dic = (Byte *)alloc-&gt;Alloc(alloc, dicBufSize);
+    if (p-&gt;dic == 0)
+    {
+      LzmaDec_FreeProbs(p, alloc);
+      return SZ_ERROR_MEM;
+    }
+  }
+  p-&gt;dicBufSize = dicBufSize;
+  p-&gt;prop = propNew;
+  return SZ_OK;
+}
+
+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+    ELzmaStatus *status, ISzAlloc *alloc)
+{
+  CLzmaDec p;
+  SRes res;
+  SizeT inSize = *srcLen;
+  SizeT outSize = *destLen;
+  *srcLen = *destLen = 0;
+  if (inSize &lt; RC_INIT_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+
+  LzmaDec_Construct(&amp;p);
+  res = LzmaDec_AllocateProbs(&amp;p, propData, propSize, alloc);
+  if (res != 0)
+    return res;
+  p.dic = dest;
+  p.dicBufSize = outSize;
+
+  LzmaDec_Init(&amp;p);
+  
+  *srcLen = inSize;
+  res = LzmaDec_DecodeToDic(&amp;p, outSize, src, srcLen, finishMode, status);
+
+  if (res == SZ_OK &amp;&amp; *status == LZMA_STATUS_NEEDS_MORE_INPUT)
+    res = SZ_ERROR_INPUT_EOF;
+
+  (*destLen) = p.dicPos;
+  LzmaDec_FreeProbs(&amp;p, alloc);
+  return res;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,232 +0,0 @@
-/* LzmaDec.h -- LZMA Decoder
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-You can use any of the following license options:
-  1) GNU Lesser General Public License (GNU LGPL)
-  2) Common Public License (CPL)
-  3) Common Development and Distribution License (CDDL) Version 1.0
-  4) Igor Pavlov, as the author of this code, expressly permits you to
-     statically or dynamically link your code (or bind by name) to this file,
-     while you keep this file unmodified.
-*/
-
-#ifndef __LZMADEC_H
-#define __LZMADEC_H
-
-#include &quot;Types.h&quot;
-
-/* #define _LZMA_PROB32 */
-/* _LZMA_PROB32 can increase the speed on some CPUs,
-   but memory usage for CLzmaDec::probs will be doubled in that case */
-
-#ifdef _LZMA_PROB32
-#define CLzmaProb UInt32
-#else
-#define CLzmaProb UInt16
-#endif
-
-
-/* ---------- LZMA Properties ---------- */
-
-#define LZMA_PROPS_SIZE 5
-
-typedef struct _CLzmaProps
-{
-  unsigned lc, lp, pb;
-  UInt32 dicSize;
-} CLzmaProps;
-
-/* LzmaProps_Decode - decodes properties
-Returns:
-  SZ_OK
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-*/
-
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
-
-
-/* ---------- LZMA Decoder state ---------- */
-
-/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
-   Num bits = log2((2^11 / 31) ^ 22) + 26 &lt; 134 + 26 = 160; */
-
-#define LZMA_REQUIRED_INPUT_MAX 20
-
-typedef struct
-{
-  CLzmaProps prop;
-  CLzmaProb *probs;
-  Byte *dic;
-  const Byte *buf;
-  UInt32 range, code;
-  SizeT dicPos;
-  SizeT dicBufSize;
-  UInt32 processedPos;
-  UInt32 checkDicSize;
-  unsigned state;
-  UInt32 reps[4];
-  unsigned remainLen;
-  int needFlush;
-  int needInitState;
-  UInt32 numProbs;
-  unsigned tempBufSize;
-  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
-} CLzmaDec;
-
-#define LzmaDec_Construct(p) { (p)-&gt;dic = 0; (p)-&gt;probs = 0; }
-
-void LzmaDec_Init(CLzmaDec *p);
-
-/* There are two types of LZMA streams:
-     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-
-typedef enum
-{
-  LZMA_FINISH_ANY,   /* finish at any point */
-  LZMA_FINISH_END    /* block must be finished at the end */
-} ELzmaFinishMode;
-
-/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
-
-   You must use LZMA_FINISH_END, when you know that current output buffer
-   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
-
-   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
-   and output value of destLen will be less than output buffer size limit.
-   You can check status result also.
-
-   You can use multiple checks to test data integrity after full decompression:
-     1) Check Result and &quot;status&quot; variable.
-     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
-     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
-        You must use correct finish mode in that case. */
-
-typedef enum
-{
-  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
-  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
-  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
-  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
-  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
-} ELzmaStatus;
-
-/* ELzmaStatus is used only as output value for function call */
-
-
-/* ---------- Interfaces ---------- */
-
-/* There are 3 levels of interfaces:
-     1) Dictionary Interface
-     2) Buffer Interface
-     3) One Call Interface
-   You can select any of these interfaces, but don't mix functions from different
-   groups for same object. */
-
-
-/* There are two variants to allocate state for Dictionary Interface:
-     1) LzmaDec_Allocate / LzmaDec_Free
-     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
-   You can use variant 2, if you set dictionary buffer manually.
-   For Buffer Interface you must always use variant 1.
-
-LzmaDec_Allocate* can return:
-  SZ_OK
-  SZ_ERROR_MEM         - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-*/
-   
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
-
-SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
-void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
-
-/* ---------- Dictionary Interface ---------- */
-
-/* You can use it, if you want to eliminate the overhead for data copying from
-   dictionary to some other external buffer.
-   You must work with CLzmaDec variables directly in this interface.
-
-   STEPS:
-     LzmaDec_Constr()
-     LzmaDec_Allocate()
-     for (each new stream)
-     {
-       LzmaDec_Init()
-       while (it needs more decompression)
-       {
-         LzmaDec_DecodeToDic()
-         use data from CLzmaDec::dic and update CLzmaDec::dicPos
-       }
-     }
-     LzmaDec_Free()
-*/
-
-/* LzmaDec_DecodeToDic
-   
-   The decoding to internal dictionary buffer (CLzmaDec::dic).
-   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (dicLimit).
-  LZMA_FINISH_ANY - Decode just dicLimit bytes.
-  LZMA_FINISH_END - Stream must be finished after dicLimit.
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_NEEDS_MORE_INPUT
-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-  SZ_ERROR_DATA - Data error
-*/
-
-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- Buffer Interface ---------- */
-
-/* It's zlib-like interface.
-   See LzmaDec_DecodeToDic description for information about STEPS and return results,
-   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
-   to work with CLzmaDec variables manually.
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - Decode just destLen bytes.
-  LZMA_FINISH_END - Stream must be finished after (*destLen).
-*/
-
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- One Call Interface ---------- */
-
-/* LzmaDecode
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - Decode just destLen bytes.
-  LZMA_FINISH_END - Stream must be finished after (*destLen).
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-  SZ_ERROR_DATA - Data error
-  SZ_ERROR_MEM  - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
-*/
-
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-    ELzmaStatus *status, ISzAlloc *alloc);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaDec.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,232 @@
+/* LzmaDec.h -- LZMA Decoder
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+You can use any of the following license options:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  3) Common Development and Distribution License (CDDL) Version 1.0
+  4) Igor Pavlov, as the author of this code, expressly permits you to
+     statically or dynamically link your code (or bind by name) to this file,
+     while you keep this file unmodified.
+*/
+
+#ifndef __LZMADEC_H
+#define __LZMADEC_H
+
+#include &quot;Types.h&quot;
+
+/* #define _LZMA_PROB32 */
+/* _LZMA_PROB32 can increase the speed on some CPUs,
+   but memory usage for CLzmaDec::probs will be doubled in that case */
+
+#ifdef _LZMA_PROB32
+#define CLzmaProb UInt32
+#else
+#define CLzmaProb UInt16
+#endif
+
+
+/* ---------- LZMA Properties ---------- */
+
+#define LZMA_PROPS_SIZE 5
+
+typedef struct _CLzmaProps
+{
+  unsigned lc, lp, pb;
+  UInt32 dicSize;
+} CLzmaProps;
+
+/* LzmaProps_Decode - decodes properties
+Returns:
+  SZ_OK
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+*/
+
+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
+
+
+/* ---------- LZMA Decoder state ---------- */
+
+/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
+   Num bits = log2((2^11 / 31) ^ 22) + 26 &lt; 134 + 26 = 160; */
+
+#define LZMA_REQUIRED_INPUT_MAX 20
+
+typedef struct
+{
+  CLzmaProps prop;
+  CLzmaProb *probs;
+  Byte *dic;
+  const Byte *buf;
+  UInt32 range, code;
+  SizeT dicPos;
+  SizeT dicBufSize;
+  UInt32 processedPos;
+  UInt32 checkDicSize;
+  unsigned state;
+  UInt32 reps[4];
+  unsigned remainLen;
+  int needFlush;
+  int needInitState;
+  UInt32 numProbs;
+  unsigned tempBufSize;
+  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
+} CLzmaDec;
+
+#define LzmaDec_Construct(p) { (p)-&gt;dic = 0; (p)-&gt;probs = 0; }
+
+void LzmaDec_Init(CLzmaDec *p);
+
+/* There are two types of LZMA streams:
+     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
+     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
+
+typedef enum
+{
+  LZMA_FINISH_ANY,   /* finish at any point */
+  LZMA_FINISH_END    /* block must be finished at the end */
+} ELzmaFinishMode;
+
+/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
+
+   You must use LZMA_FINISH_END, when you know that current output buffer
+   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
+
+   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
+   and output value of destLen will be less than output buffer size limit.
+   You can check status result also.
+
+   You can use multiple checks to test data integrity after full decompression:
+     1) Check Result and &quot;status&quot; variable.
+     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
+     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
+        You must use correct finish mode in that case. */
+
+typedef enum
+{
+  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
+  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
+  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
+  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
+  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
+} ELzmaStatus;
+
+/* ELzmaStatus is used only as output value for function call */
+
+
+/* ---------- Interfaces ---------- */
+
+/* There are 3 levels of interfaces:
+     1) Dictionary Interface
+     2) Buffer Interface
+     3) One Call Interface
+   You can select any of these interfaces, but don't mix functions from different
+   groups for same object. */
+
+
+/* There are two variants to allocate state for Dictionary Interface:
+     1) LzmaDec_Allocate / LzmaDec_Free
+     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
+   You can use variant 2, if you set dictionary buffer manually.
+   For Buffer Interface you must always use variant 1.
+
+LzmaDec_Allocate* can return:
+  SZ_OK
+  SZ_ERROR_MEM         - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+*/
+   
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
+
+SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
+void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
+
+/* ---------- Dictionary Interface ---------- */
+
+/* You can use it, if you want to eliminate the overhead for data copying from
+   dictionary to some other external buffer.
+   You must work with CLzmaDec variables directly in this interface.
+
+   STEPS:
+     LzmaDec_Constr()
+     LzmaDec_Allocate()
+     for (each new stream)
+     {
+       LzmaDec_Init()
+       while (it needs more decompression)
+       {
+         LzmaDec_DecodeToDic()
+         use data from CLzmaDec::dic and update CLzmaDec::dicPos
+       }
+     }
+     LzmaDec_Free()
+*/
+
+/* LzmaDec_DecodeToDic
+   
+   The decoding to internal dictionary buffer (CLzmaDec::dic).
+   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (dicLimit).
+  LZMA_FINISH_ANY - Decode just dicLimit bytes.
+  LZMA_FINISH_END - Stream must be finished after dicLimit.
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_NEEDS_MORE_INPUT
+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+  SZ_ERROR_DATA - Data error
+*/
+
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- Buffer Interface ---------- */
+
+/* It's zlib-like interface.
+   See LzmaDec_DecodeToDic description for information about STEPS and return results,
+   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
+   to work with CLzmaDec variables manually.
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - Decode just destLen bytes.
+  LZMA_FINISH_END - Stream must be finished after (*destLen).
+*/
+
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- One Call Interface ---------- */
+
+/* LzmaDecode
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - Decode just destLen bytes.
+  LZMA_FINISH_END - Stream must be finished after (*destLen).
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+  SZ_ERROR_DATA - Data error
+  SZ_ERROR_MEM  - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
+*/
+
+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+    ELzmaStatus *status, ISzAlloc *alloc);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,2275 +0,0 @@
-/* LzmaEnc.c -- LZMA Encoder
-2008-08-17
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzmaEnc.h for license options */
-
-#include &lt;string.h&gt;
-
-/* #define SHOW_STAT */
-/* #define SHOW_STAT2 */
-
-#if defined(SHOW_STAT) || defined(SHOW_STAT2)
-#include &lt;stdio.h&gt;
-#endif
-
-#include &quot;LzmaEnc.h&quot;
-
-#include &quot;LzFind.h&quot;
-#ifdef COMPRESS_MF_MT
-#include &quot;LzFindMt.h&quot;
-#endif
-
-#ifdef SHOW_STAT
-static int ttt = 0;
-#endif
-
-#define kBlockSizeMax ((1 &lt;&lt; LZMA_NUM_BLOCK_SIZE_BITS) - 1)
-
-#define kBlockSize (9 &lt;&lt; 10)
-#define kUnpackBlockSize (1 &lt;&lt; 18)
-#define kMatchArraySize (1 &lt;&lt; 21)
-#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
-
-#define kNumMaxDirectBits (31)
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
-#define kNumMoveBits 5
-#define kProbInitValue (kBitModelTotal &gt;&gt; 1)
-
-#define kNumMoveReducingBits 4
-#define kNumBitPriceShiftBits 4
-#define kBitPrice (1 &lt;&lt; kNumBitPriceShiftBits)
-
-void LzmaEncProps_Init(CLzmaEncProps *p)
-{
-  p-&gt;level = 5;
-  p-&gt;dictSize = p-&gt;mc = 0;
-  p-&gt;lc = p-&gt;lp = p-&gt;pb = p-&gt;algo = p-&gt;fb = p-&gt;btMode = p-&gt;numHashBytes = p-&gt;numThreads = -1;
-  p-&gt;writeEndMark = 0;
-}
-
-void LzmaEncProps_Normalize(CLzmaEncProps *p)
-{
-  int level = p-&gt;level;
-  if (level &lt; 0) level = 5;
-  p-&gt;level = level;
-  if (p-&gt;dictSize == 0) p-&gt;dictSize = (level &lt;= 5 ? (1 &lt;&lt; (level * 2 + 14)) : (level == 6 ? (1 &lt;&lt; 25) : (1 &lt;&lt; 26)));
-  if (p-&gt;lc &lt; 0) p-&gt;lc = 3;
-  if (p-&gt;lp &lt; 0) p-&gt;lp = 0;
-  if (p-&gt;pb &lt; 0) p-&gt;pb = 2;
-  if (p-&gt;algo &lt; 0) p-&gt;algo = (level &lt; 5 ? 0 : 1);
-  if (p-&gt;fb &lt; 0) p-&gt;fb = (level &lt; 7 ? 32 : 64);
-  if (p-&gt;btMode &lt; 0) p-&gt;btMode = (p-&gt;algo == 0 ? 0 : 1);
-  if (p-&gt;numHashBytes &lt; 0) p-&gt;numHashBytes = 4;
-  if (p-&gt;mc == 0)  p-&gt;mc = (16 + (p-&gt;fb &gt;&gt; 1)) &gt;&gt; (p-&gt;btMode ? 0 : 1);
-  if (p-&gt;numThreads &lt; 0) p-&gt;numThreads = ((p-&gt;btMode &amp;&amp; p-&gt;algo) ? 2 : 1);
-}
-
-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-{
-  CLzmaEncProps props = *props2;
-  LzmaEncProps_Normalize(&amp;props);
-  return props.dictSize;
-}
-
-/* #define LZMA_LOG_BSR */
-/* Define it for Intel's CPU */
-
-
-#ifdef LZMA_LOG_BSR
-
-#define kDicLogSizeMaxCompress 30
-
-#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&amp;i, (pos)); res = (i + i) + ((pos &gt;&gt; (i - 1)) &amp; 1); }
-
-UInt32 GetPosSlot1(UInt32 pos)
-{
-  UInt32 res;
-  BSR2_RET(pos, res);
-  return res;
-}
-#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-#define GetPosSlot(pos, res) { if (pos &lt; 2) res = pos; else BSR2_RET(pos, res); }
-
-#else
-
-#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
-#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
-
-void LzmaEnc_FastPosInit(Byte *g_FastPos)
-{
-  int c = 2, slotFast;
-  g_FastPos[0] = 0;
-  g_FastPos[1] = 1;
-  
-  for (slotFast = 2; slotFast &lt; kNumLogBits * 2; slotFast++)
-  {
-    UInt32 k = (1 &lt;&lt; ((slotFast &gt;&gt; 1) - 1));
-    UInt32 j;
-    for (j = 0; j &lt; k; j++, c++)
-      g_FastPos[c] = (Byte)slotFast;
-  }
-}
-
-#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) &amp; \
-  (0 - (((((UInt32)1 &lt;&lt; (kNumLogBits + 6)) - 1) - pos) &gt;&gt; 31))); \
-  res = p-&gt;g_FastPos[pos &gt;&gt; i] + (i * 2); }
-/*
-#define BSR2_RET(pos, res) { res = (pos &lt; (1 &lt;&lt; (kNumLogBits + 6))) ? \
-  p-&gt;g_FastPos[pos &gt;&gt; 6] + 12 : \
-  p-&gt;g_FastPos[pos &gt;&gt; (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
-*/
-
-#define GetPosSlot1(pos) p-&gt;g_FastPos[pos]
-#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-#define GetPosSlot(pos, res) { if (pos &lt; kNumFullDistances) res = p-&gt;g_FastPos[pos]; else BSR2_RET(pos, res); }
-
-#endif
-
-
-#define LZMA_NUM_REPS 4
-
-typedef unsigned CState;
-
-typedef struct _COptimal
-{
-  UInt32 price;
-
-  CState state;
-  int prev1IsChar;
-  int prev2;
-
-  UInt32 posPrev2;
-  UInt32 backPrev2;
-
-  UInt32 posPrev;
-  UInt32 backPrev;
-  UInt32 backs[LZMA_NUM_REPS];
-} COptimal;
-
-#define kNumOpts (1 &lt;&lt; 12)
-
-#define kNumLenToPosStates 4
-#define kNumPosSlotBits 6
-#define kDicLogSizeMin 0
-#define kDicLogSizeMax 32
-#define kDistTableSizeMax (kDicLogSizeMax * 2)
-
-
-#define kNumAlignBits 4
-#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
-#define kAlignMask (kAlignTableSize - 1)
-
-#define kStartPosModelIndex 4
-#define kEndPosModelIndex 14
-#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
-
-#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex / 2))
-
-#ifdef _LZMA_PROB32
-#define CLzmaProb UInt32
-#else
-#define CLzmaProb UInt16
-#endif
-
-#define LZMA_PB_MAX 4
-#define LZMA_LC_MAX 8
-#define LZMA_LP_MAX 4
-
-#define LZMA_NUM_PB_STATES_MAX (1 &lt;&lt; LZMA_PB_MAX)
-
-
-#define kLenNumLowBits 3
-#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
-#define kLenNumMidBits 3
-#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
-#define kLenNumHighBits 8
-#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
-
-#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-
-#define LZMA_MATCH_LEN_MIN 2
-#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
-
-#define kNumStates 12
-
-typedef struct
-{
-  CLzmaProb choice;
-  CLzmaProb choice2;
-  CLzmaProb low[LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumLowBits];
-  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumMidBits];
-  CLzmaProb high[kLenNumHighSymbols];
-} CLenEnc;
-
-typedef struct
-{
-  CLenEnc p;
-  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
-  UInt32 tableSize;
-  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
-} CLenPriceEnc;
-
-typedef struct _CRangeEnc
-{
-  UInt32 range;
-  Byte cache;
-  UInt64 low;
-  UInt64 cacheSize;
-  Byte *buf;
-  Byte *bufLim;
-  Byte *bufBase;
-  ISeqOutStream *outStream;
-  UInt64 processed;
-  SRes res;
-} CRangeEnc;
-
-typedef struct _CSeqInStreamBuf
-{
-  ISeqInStream funcTable;
-  const Byte *data;
-  SizeT rem;
-} CSeqInStreamBuf;
-
-static SRes MyRead(void *pp, void *data, size_t *size)
-{
-  size_t curSize = *size;
-  CSeqInStreamBuf *p = (CSeqInStreamBuf *)pp;
-  if (p-&gt;rem &lt; curSize)
-    curSize = p-&gt;rem;
-  memcpy(data, p-&gt;data, curSize);
-  p-&gt;rem -= curSize;
-  p-&gt;data += curSize;
-  *size = curSize;
-  return SZ_OK;
-}
-
-typedef struct
-{
-  CLzmaProb *litProbs;
-
-  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-  CLzmaProb isRep[kNumStates];
-  CLzmaProb isRepG0[kNumStates];
-  CLzmaProb isRepG1[kNumStates];
-  CLzmaProb isRepG2[kNumStates];
-  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-
-  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 &lt;&lt; kNumPosSlotBits];
-  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-  CLzmaProb posAlignEncoder[1 &lt;&lt; kNumAlignBits];
-  
-  CLenPriceEnc lenEnc;
-  CLenPriceEnc repLenEnc;
-
-  UInt32 reps[LZMA_NUM_REPS];
-  UInt32 state;
-} CSaveState;
-
-typedef struct _CLzmaEnc
-{
-  IMatchFinder matchFinder;
-  void *matchFinderObj;
-
-  #ifdef COMPRESS_MF_MT
-  Bool mtMode;
-  CMatchFinderMt matchFinderMt;
-  #endif
-
-  CMatchFinder matchFinderBase;
-
-  #ifdef COMPRESS_MF_MT
-  Byte pad[128];
-  #endif
-  
-  UInt32 optimumEndIndex;
-  UInt32 optimumCurrentIndex;
-
-  UInt32 longestMatchLength;
-  UInt32 numPairs;
-  UInt32 numAvail;
-  COptimal opt[kNumOpts];
-  
-  #ifndef LZMA_LOG_BSR
-  Byte g_FastPos[1 &lt;&lt; kNumLogBits];
-  #endif
-
-  UInt32 ProbPrices[kBitModelTotal &gt;&gt; kNumMoveReducingBits];
-  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
-  UInt32 numFastBytes;
-  UInt32 additionalOffset;
-  UInt32 reps[LZMA_NUM_REPS];
-  UInt32 state;
-
-  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
-  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
-  UInt32 alignPrices[kAlignTableSize];
-  UInt32 alignPriceCount;
-
-  UInt32 distTableSize;
-
-  unsigned lc, lp, pb;
-  unsigned lpMask, pbMask;
-
-  CLzmaProb *litProbs;
-
-  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-  CLzmaProb isRep[kNumStates];
-  CLzmaProb isRepG0[kNumStates];
-  CLzmaProb isRepG1[kNumStates];
-  CLzmaProb isRepG2[kNumStates];
-  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-
-  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 &lt;&lt; kNumPosSlotBits];
-  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-  CLzmaProb posAlignEncoder[1 &lt;&lt; kNumAlignBits];
-  
-  CLenPriceEnc lenEnc;
-  CLenPriceEnc repLenEnc;
-
-  unsigned lclp;
-
-  Bool fastMode;
-  
-  CRangeEnc rc;
-
-  Bool writeEndMark;
-  UInt64 nowPos64;
-  UInt32 matchPriceCount;
-  Bool finished;
-  Bool multiThread;
-
-  SRes result;
-  UInt32 dictSize;
-  UInt32 matchFinderCycles;
-
-  ISeqInStream *inStream;
-  CSeqInStreamBuf seqBufInStream;
-
-  CSaveState saveState;
-} CLzmaEnc;
-
-void LzmaEnc_SaveState(CLzmaEncHandle pp)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  CSaveState *dest = &amp;p-&gt;saveState;
-  int i;
-  dest-&gt;lenEnc = p-&gt;lenEnc;
-  dest-&gt;repLenEnc = p-&gt;repLenEnc;
-  dest-&gt;state = p-&gt;state;
-
-  for (i = 0; i &lt; kNumStates; i++)
-  {
-    memcpy(dest-&gt;isMatch[i], p-&gt;isMatch[i], sizeof(p-&gt;isMatch[i]));
-    memcpy(dest-&gt;isRep0Long[i], p-&gt;isRep0Long[i], sizeof(p-&gt;isRep0Long[i]));
-  }
-  for (i = 0; i &lt; kNumLenToPosStates; i++)
-    memcpy(dest-&gt;posSlotEncoder[i], p-&gt;posSlotEncoder[i], sizeof(p-&gt;posSlotEncoder[i]));
-  memcpy(dest-&gt;isRep, p-&gt;isRep, sizeof(p-&gt;isRep));
-  memcpy(dest-&gt;isRepG0, p-&gt;isRepG0, sizeof(p-&gt;isRepG0));
-  memcpy(dest-&gt;isRepG1, p-&gt;isRepG1, sizeof(p-&gt;isRepG1));
-  memcpy(dest-&gt;isRepG2, p-&gt;isRepG2, sizeof(p-&gt;isRepG2));
-  memcpy(dest-&gt;posEncoders, p-&gt;posEncoders, sizeof(p-&gt;posEncoders));
-  memcpy(dest-&gt;posAlignEncoder, p-&gt;posAlignEncoder, sizeof(p-&gt;posAlignEncoder));
-  memcpy(dest-&gt;reps, p-&gt;reps, sizeof(p-&gt;reps));
-  memcpy(dest-&gt;litProbs, p-&gt;litProbs, (0x300 &lt;&lt; p-&gt;lclp) * sizeof(CLzmaProb));
-}
-
-void LzmaEnc_RestoreState(CLzmaEncHandle pp)
-{
-  CLzmaEnc *dest = (CLzmaEnc *)pp;
-  const CSaveState *p = &amp;dest-&gt;saveState;
-  int i;
-  dest-&gt;lenEnc = p-&gt;lenEnc;
-  dest-&gt;repLenEnc = p-&gt;repLenEnc;
-  dest-&gt;state = p-&gt;state;
-
-  for (i = 0; i &lt; kNumStates; i++)
-  {
-    memcpy(dest-&gt;isMatch[i], p-&gt;isMatch[i], sizeof(p-&gt;isMatch[i]));
-    memcpy(dest-&gt;isRep0Long[i], p-&gt;isRep0Long[i], sizeof(p-&gt;isRep0Long[i]));
-  }
-  for (i = 0; i &lt; kNumLenToPosStates; i++)
-    memcpy(dest-&gt;posSlotEncoder[i], p-&gt;posSlotEncoder[i], sizeof(p-&gt;posSlotEncoder[i]));
-  memcpy(dest-&gt;isRep, p-&gt;isRep, sizeof(p-&gt;isRep));
-  memcpy(dest-&gt;isRepG0, p-&gt;isRepG0, sizeof(p-&gt;isRepG0));
-  memcpy(dest-&gt;isRepG1, p-&gt;isRepG1, sizeof(p-&gt;isRepG1));
-  memcpy(dest-&gt;isRepG2, p-&gt;isRepG2, sizeof(p-&gt;isRepG2));
-  memcpy(dest-&gt;posEncoders, p-&gt;posEncoders, sizeof(p-&gt;posEncoders));
-  memcpy(dest-&gt;posAlignEncoder, p-&gt;posAlignEncoder, sizeof(p-&gt;posAlignEncoder));
-  memcpy(dest-&gt;reps, p-&gt;reps, sizeof(p-&gt;reps));
-  memcpy(dest-&gt;litProbs, p-&gt;litProbs, (0x300 &lt;&lt; dest-&gt;lclp) * sizeof(CLzmaProb));
-}
-
-SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  CLzmaEncProps props = *props2;
-  LzmaEncProps_Normalize(&amp;props);
-
-  if (props.lc &gt; LZMA_LC_MAX || props.lp &gt; LZMA_LP_MAX || props.pb &gt; LZMA_PB_MAX ||
-      props.dictSize &gt; (1 &lt;&lt; kDicLogSizeMaxCompress) || props.dictSize &gt; (1 &lt;&lt; 30))
-    return SZ_ERROR_PARAM;
-  p-&gt;dictSize = props.dictSize;
-  p-&gt;matchFinderCycles = props.mc;
-  {
-    unsigned fb = props.fb;
-    if (fb &lt; 5)
-      fb = 5;
-    if (fb &gt; LZMA_MATCH_LEN_MAX)
-      fb = LZMA_MATCH_LEN_MAX;
-    p-&gt;numFastBytes = fb;
-  }
-  p-&gt;lc = props.lc;
-  p-&gt;lp = props.lp;
-  p-&gt;pb = props.pb;
-  p-&gt;fastMode = (props.algo == 0);
-  p-&gt;matchFinderBase.btMode = props.btMode;
-  {
-    UInt32 numHashBytes = 4;
-    if (props.btMode)
-    {
-      if (props.numHashBytes &lt; 2)
-        numHashBytes = 2;
-      else if (props.numHashBytes &lt; 4)
-        numHashBytes = props.numHashBytes;
-    }
-    p-&gt;matchFinderBase.numHashBytes = numHashBytes;
-  }
-
-  p-&gt;matchFinderBase.cutValue = props.mc;
-
-  p-&gt;writeEndMark = props.writeEndMark;
-
-  #ifdef COMPRESS_MF_MT
-  /*
-  if (newMultiThread != _multiThread)
-  {
-    ReleaseMatchFinder();
-    _multiThread = newMultiThread;
-  }
-  */
-  p-&gt;multiThread = (props.numThreads &gt; 1);
-  #endif
-
-  return SZ_OK;
-}
-
-static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
-static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
-static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
-static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
-
-#define IsCharState(s) ((s) &lt; 7)
-
-#define GetLenToPosState(len) (((len) &lt; kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
-
-#define kInfinityPrice (1 &lt;&lt; 30)
-
-static void RangeEnc_Construct(CRangeEnc *p)
-{
-  p-&gt;outStream = 0;
-  p-&gt;bufBase = 0;
-}
-
-#define RangeEnc_GetProcessed(p) ((p)-&gt;processed + ((p)-&gt;buf - (p)-&gt;bufBase) + (p)-&gt;cacheSize)
-
-#define RC_BUF_SIZE (1 &lt;&lt; 16)
-static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
-{
-  if (p-&gt;bufBase == 0)
-  {
-    p-&gt;bufBase = (Byte *)alloc-&gt;Alloc(alloc, RC_BUF_SIZE);
-    if (p-&gt;bufBase == 0)
-      return 0;
-    p-&gt;bufLim = p-&gt;bufBase + RC_BUF_SIZE;
-  }
-  return 1;
-}
-
-static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;bufBase);
-  p-&gt;bufBase = 0;
-}
-
-static void RangeEnc_Init(CRangeEnc *p)
-{
-  /* Stream.Init(); */
-  p-&gt;low = 0;
-  p-&gt;range = 0xFFFFFFFF;
-  p-&gt;cacheSize = 1;
-  p-&gt;cache = 0;
-
-  p-&gt;buf = p-&gt;bufBase;
-
-  p-&gt;processed = 0;
-  p-&gt;res = SZ_OK;
-}
-
-static void RangeEnc_FlushStream(CRangeEnc *p)
-{
-  size_t num;
-  if (p-&gt;res != SZ_OK)
-    return;
-  num = p-&gt;buf - p-&gt;bufBase;
-  if (num != p-&gt;outStream-&gt;Write(p-&gt;outStream, p-&gt;bufBase, num))
-    p-&gt;res = SZ_ERROR_WRITE;
-  p-&gt;processed += num;
-  p-&gt;buf = p-&gt;bufBase;
-}
-
-static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
-{
-  if ((UInt32)p-&gt;low &lt; (UInt32)0xFF000000 || (int)(p-&gt;low &gt;&gt; 32) != 0)
-  {
-    Byte temp = p-&gt;cache;
-    do
-    {
-      Byte *buf = p-&gt;buf;
-      *buf++ = (Byte)(temp + (Byte)(p-&gt;low &gt;&gt; 32));
-      p-&gt;buf = buf;
-      if (buf == p-&gt;bufLim)
-        RangeEnc_FlushStream(p);
-      temp = 0xFF;
-    }
-    while (--p-&gt;cacheSize != 0);
-    p-&gt;cache = (Byte)((UInt32)p-&gt;low &gt;&gt; 24);
-  }
-  p-&gt;cacheSize++;
-  p-&gt;low = (UInt32)p-&gt;low &lt;&lt; 8;
-}
-
-static void RangeEnc_FlushData(CRangeEnc *p)
-{
-  int i;
-  for (i = 0; i &lt; 5; i++)
-    RangeEnc_ShiftLow(p);
-}
-
-static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
-{
-  do
-  {
-    p-&gt;range &gt;&gt;= 1;
-    p-&gt;low += p-&gt;range &amp; (0 - ((value &gt;&gt; --numBits) &amp; 1));
-    if (p-&gt;range &lt; kTopValue)
-    {
-      p-&gt;range &lt;&lt;= 8;
-      RangeEnc_ShiftLow(p);
-    }
-  }
-  while (numBits != 0);
-}
-
-static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
-{
-  UInt32 ttt = *prob;
-  UInt32 newBound = (p-&gt;range &gt;&gt; kNumBitModelTotalBits) * ttt;
-  if (symbol == 0)
-  {
-    p-&gt;range = newBound;
-    ttt += (kBitModelTotal - ttt) &gt;&gt; kNumMoveBits;
-  }
-  else
-  {
-    p-&gt;low += newBound;
-    p-&gt;range -= newBound;
-    ttt -= ttt &gt;&gt; kNumMoveBits;
-  }
-  *prob = (CLzmaProb)ttt;
-  if (p-&gt;range &lt; kTopValue)
-  {
-    p-&gt;range &lt;&lt;= 8;
-    RangeEnc_ShiftLow(p);
-  }
-}
-
-static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
-{
-  symbol |= 0x100;
-  do
-  {
-    RangeEnc_EncodeBit(p, probs + (symbol &gt;&gt; 8), (symbol &gt;&gt; 7) &amp; 1);
-    symbol &lt;&lt;= 1;
-  }
-  while (symbol &lt; 0x10000);
-}
-
-static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
-{
-  UInt32 offs = 0x100;
-  symbol |= 0x100;
-  do
-  {
-    matchByte &lt;&lt;= 1;
-    RangeEnc_EncodeBit(p, probs + (offs + (matchByte &amp; offs) + (symbol &gt;&gt; 8)), (symbol &gt;&gt; 7) &amp; 1);
-    symbol &lt;&lt;= 1;
-    offs &amp;= ~(matchByte ^ symbol);
-  }
-  while (symbol &lt; 0x10000);
-}
-
-void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-{
-  UInt32 i;
-  for (i = (1 &lt;&lt; kNumMoveReducingBits) / 2; i &lt; kBitModelTotal; i += (1 &lt;&lt; kNumMoveReducingBits))
-  {
-    const int kCyclesBits = kNumBitPriceShiftBits;
-    UInt32 w = i;
-    UInt32 bitCount = 0;
-    int j;
-    for (j = 0; j &lt; kCyclesBits; j++)
-    {
-      w = w * w;
-      bitCount &lt;&lt;= 1;
-      while (w &gt;= ((UInt32)1 &lt;&lt; 16))
-      {
-        w &gt;&gt;= 1;
-        bitCount++;
-      }
-    }
-    ProbPrices[i &gt;&gt; kNumMoveReducingBits] = ((kNumBitModelTotalBits &lt;&lt; kCyclesBits) - 15 - bitCount);
-  }
-}
-
-
-#define GET_PRICE(prob, symbol) \
-  p-&gt;ProbPrices[((prob) ^ (((-(int)(symbol))) &amp; (kBitModelTotal - 1))) &gt;&gt; kNumMoveReducingBits];
-
-#define GET_PRICEa(prob, symbol) \
-  ProbPrices[((prob) ^ ((-((int)(symbol))) &amp; (kBitModelTotal - 1))) &gt;&gt; kNumMoveReducingBits];
-
-#define GET_PRICE_0(prob) p-&gt;ProbPrices[(prob) &gt;&gt; kNumMoveReducingBits]
-#define GET_PRICE_1(prob) p-&gt;ProbPrices[((prob) ^ (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits]
-
-#define GET_PRICE_0a(prob) ProbPrices[(prob) &gt;&gt; kNumMoveReducingBits]
-#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits]
-
-static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  symbol |= 0x100;
-  do
-  {
-    price += GET_PRICEa(probs[symbol &gt;&gt; 8], (symbol &gt;&gt; 7) &amp; 1);
-    symbol &lt;&lt;= 1;
-  }
-  while (symbol &lt; 0x10000);
-  return price;
-}
-
-static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  UInt32 offs = 0x100;
-  symbol |= 0x100;
-  do
-  {
-    matchByte &lt;&lt;= 1;
-    price += GET_PRICEa(probs[offs + (matchByte &amp; offs) + (symbol &gt;&gt; 8)], (symbol &gt;&gt; 7) &amp; 1);
-    symbol &lt;&lt;= 1;
-    offs &amp;= ~(matchByte ^ symbol);
-  }
-  while (symbol &lt; 0x10000);
-  return price;
-}
-
-
-static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-{
-  UInt32 m = 1;
-  int i;
-  for (i = numBitLevels; i != 0;)
-  {
-    UInt32 bit;
-    i--;
-    bit = (symbol &gt;&gt; i) &amp; 1;
-    RangeEnc_EncodeBit(rc, probs + m, bit);
-    m = (m &lt;&lt; 1) | bit;
-  }
-}
-
-static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-{
-  UInt32 m = 1;
-  int i;
-  for (i = 0; i &lt; numBitLevels; i++)
-  {
-    UInt32 bit = symbol &amp; 1;
-    RangeEnc_EncodeBit(rc, probs + m, bit);
-    m = (m &lt;&lt; 1) | bit;
-    symbol &gt;&gt;= 1;
-  }
-}
-
-static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  symbol |= (1 &lt;&lt; numBitLevels);
-  while (symbol != 1)
-  {
-    price += GET_PRICEa(probs[symbol &gt;&gt; 1], symbol &amp; 1);
-    symbol &gt;&gt;= 1;
-  }
-  return price;
-}
-
-static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  UInt32 m = 1;
-  int i;
-  for (i = numBitLevels; i != 0; i--)
-  {
-    UInt32 bit = symbol &amp; 1;
-    symbol &gt;&gt;= 1;
-    price += GET_PRICEa(probs[m], bit);
-    m = (m &lt;&lt; 1) | bit;
-  }
-  return price;
-}
-
-
-static void LenEnc_Init(CLenEnc *p)
-{
-  unsigned i;
-  p-&gt;choice = p-&gt;choice2 = kProbInitValue;
-  for (i = 0; i &lt; (LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumLowBits); i++)
-    p-&gt;low[i] = kProbInitValue;
-  for (i = 0; i &lt; (LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumMidBits); i++)
-    p-&gt;mid[i] = kProbInitValue;
-  for (i = 0; i &lt; kLenNumHighSymbols; i++)
-    p-&gt;high[i] = kProbInitValue;
-}
-
-static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
-{
-  if (symbol &lt; kLenNumLowSymbols)
-  {
-    RangeEnc_EncodeBit(rc, &amp;p-&gt;choice, 0);
-    RcTree_Encode(rc, p-&gt;low + (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, symbol);
-  }
-  else
-  {
-    RangeEnc_EncodeBit(rc, &amp;p-&gt;choice, 1);
-    if (symbol &lt; kLenNumLowSymbols + kLenNumMidSymbols)
-    {
-      RangeEnc_EncodeBit(rc, &amp;p-&gt;choice2, 0);
-      RcTree_Encode(rc, p-&gt;mid + (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
-    }
-    else
-    {
-      RangeEnc_EncodeBit(rc, &amp;p-&gt;choice2, 1);
-      RcTree_Encode(rc, p-&gt;high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
-    }
-  }
-}
-
-static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
-{
-  UInt32 a0 = GET_PRICE_0a(p-&gt;choice);
-  UInt32 a1 = GET_PRICE_1a(p-&gt;choice);
-  UInt32 b0 = a1 + GET_PRICE_0a(p-&gt;choice2);
-  UInt32 b1 = a1 + GET_PRICE_1a(p-&gt;choice2);
-  UInt32 i = 0;
-  for (i = 0; i &lt; kLenNumLowSymbols; i++)
-  {
-    if (i &gt;= numSymbols)
-      return;
-    prices[i] = a0 + RcTree_GetPrice(p-&gt;low + (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
-  }
-  for (; i &lt; kLenNumLowSymbols + kLenNumMidSymbols; i++)
-  {
-    if (i &gt;= numSymbols)
-      return;
-    prices[i] = b0 + RcTree_GetPrice(p-&gt;mid + (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
-  }
-  for (; i &lt; numSymbols; i++)
-    prices[i] = b1 + RcTree_GetPrice(p-&gt;high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
-}
-
-static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
-{
-  LenEnc_SetPrices(&amp;p-&gt;p, posState, p-&gt;tableSize, p-&gt;prices[posState], ProbPrices);
-  p-&gt;counters[posState] = p-&gt;tableSize;
-}
-
-static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
-{
-  UInt32 posState;
-  for (posState = 0; posState &lt; numPosStates; posState++)
-    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-}
-
-static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
-{
-  LenEnc_Encode(&amp;p-&gt;p, rc, symbol, posState);
-  if (updatePrice)
-    if (--p-&gt;counters[posState] == 0)
-      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-}
-
-
-
-
-static void MovePos(CLzmaEnc *p, UInt32 num)
-{
-  #ifdef SHOW_STAT
-  ttt += num;
-  printf(&quot;\n MovePos %d&quot;, num);
-  #endif
-  if (num != 0)
-  {
-    p-&gt;additionalOffset += num;
-    p-&gt;matchFinder.Skip(p-&gt;matchFinderObj, num);
-  }
-}
-
-static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
-{
-  UInt32 lenRes = 0, numPairs;
-  p-&gt;numAvail = p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj);
-  numPairs = p-&gt;matchFinder.GetMatches(p-&gt;matchFinderObj, p-&gt;matches);
-  #ifdef SHOW_STAT
-  printf(&quot;\n i = %d numPairs = %d    &quot;, ttt, numPairs / 2);
-  ttt++;
-  {
-    UInt32 i;
-    for (i = 0; i &lt; numPairs; i += 2)
-      printf(&quot;%2d %6d   | &quot;, p-&gt;matches[i], p-&gt;matches[i + 1]);
-  }
-  #endif
-  if (numPairs &gt; 0)
-  {
-    lenRes = p-&gt;matches[numPairs - 2];
-    if (lenRes == p-&gt;numFastBytes)
-    {
-      const Byte *pby = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-      UInt32 distance = p-&gt;matches[numPairs - 1] + 1;
-      UInt32 numAvail = p-&gt;numAvail;
-      if (numAvail &gt; LZMA_MATCH_LEN_MAX)
-        numAvail = LZMA_MATCH_LEN_MAX;
-      {
-        const Byte *pby2 = pby - distance;
-        for (; lenRes &lt; numAvail &amp;&amp; pby[lenRes] == pby2[lenRes]; lenRes++);
-      }
-    }
-  }
-  p-&gt;additionalOffset++;
-  *numDistancePairsRes = numPairs;
-  return lenRes;
-}
-
-
-#define MakeAsChar(p) (p)-&gt;backPrev = (UInt32)(-1); (p)-&gt;prev1IsChar = False;
-#define MakeAsShortRep(p) (p)-&gt;backPrev = 0; (p)-&gt;prev1IsChar = False;
-#define IsShortRep(p) ((p)-&gt;backPrev == 0)
-
-static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
-{
-  return
-    GET_PRICE_0(p-&gt;isRepG0[state]) +
-    GET_PRICE_0(p-&gt;isRep0Long[state][posState]);
-}
-
-static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
-{
-  UInt32 price;
-  if (repIndex == 0)
-  {
-    price = GET_PRICE_0(p-&gt;isRepG0[state]);
-    price += GET_PRICE_1(p-&gt;isRep0Long[state][posState]);
-  }
-  else
-  {
-    price = GET_PRICE_1(p-&gt;isRepG0[state]);
-    if (repIndex == 1)
-      price += GET_PRICE_0(p-&gt;isRepG1[state]);
-    else
-    {
-      price += GET_PRICE_1(p-&gt;isRepG1[state]);
-      price += GET_PRICE(p-&gt;isRepG2[state], repIndex - 2);
-    }
-  }
-  return price;
-}
-
-static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
-{
-  return p-&gt;repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
-    GetPureRepPrice(p, repIndex, state, posState);
-}
-
-static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
-{
-  UInt32 posMem = p-&gt;opt[cur].posPrev;
-  UInt32 backMem = p-&gt;opt[cur].backPrev;
-  p-&gt;optimumEndIndex = cur;
-  do
-  {
-    if (p-&gt;opt[cur].prev1IsChar)
-    {
-      MakeAsChar(&amp;p-&gt;opt[posMem])
-      p-&gt;opt[posMem].posPrev = posMem - 1;
-      if (p-&gt;opt[cur].prev2)
-      {
-        p-&gt;opt[posMem - 1].prev1IsChar = False;
-        p-&gt;opt[posMem - 1].posPrev = p-&gt;opt[cur].posPrev2;
-        p-&gt;opt[posMem - 1].backPrev = p-&gt;opt[cur].backPrev2;
-      }
-    }
-    {
-      UInt32 posPrev = posMem;
-      UInt32 backCur = backMem;
-      
-      backMem = p-&gt;opt[posPrev].backPrev;
-      posMem = p-&gt;opt[posPrev].posPrev;
-      
-      p-&gt;opt[posPrev].backPrev = backCur;
-      p-&gt;opt[posPrev].posPrev = cur;
-      cur = posPrev;
-    }
-  }
-  while (cur != 0);
-  *backRes = p-&gt;opt[0].backPrev;
-  p-&gt;optimumCurrentIndex  = p-&gt;opt[0].posPrev;
-  return p-&gt;optimumCurrentIndex;
-}
-
-#define LIT_PROBS(pos, prevByte) (p-&gt;litProbs + ((((pos) &amp; p-&gt;lpMask) &lt;&lt; p-&gt;lc) + ((prevByte) &gt;&gt; (8 - p-&gt;lc))) * 0x300)
-
-static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
-{
-  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
-  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
-  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
-  UInt32 *matches;
-  const Byte *data;
-  Byte curByte, matchByte;
-  if (p-&gt;optimumEndIndex != p-&gt;optimumCurrentIndex)
-  {
-    const COptimal *opt = &amp;p-&gt;opt[p-&gt;optimumCurrentIndex];
-    UInt32 lenRes = opt-&gt;posPrev - p-&gt;optimumCurrentIndex;
-    *backRes = opt-&gt;backPrev;
-    p-&gt;optimumCurrentIndex = opt-&gt;posPrev;
-    return lenRes;
-  }
-  p-&gt;optimumCurrentIndex = p-&gt;optimumEndIndex = 0;
-  
-  if (p-&gt;additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &amp;numPairs);
-  else
-  {
-    mainLen = p-&gt;longestMatchLength;
-    numPairs = p-&gt;numPairs;
-  }
-
-  numAvail = p-&gt;numAvail;
-  if (numAvail &lt; 2)
-  {
-    *backRes = (UInt32)(-1);
-    return 1;
-  }
-  if (numAvail &gt; LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
-
-  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-  repMaxIndex = 0;
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-  {
-    UInt32 lenTest;
-    const Byte *data2;
-    reps[i] = p-&gt;reps[i];
-    data2 = data - (reps[i] + 1);
-    if (data[0] != data2[0] || data[1] != data2[1])
-    {
-      repLens[i] = 0;
-      continue;
-    }
-    for (lenTest = 2; lenTest &lt; numAvail &amp;&amp; data[lenTest] == data2[lenTest]; lenTest++);
-    repLens[i] = lenTest;
-    if (lenTest &gt; repLens[repMaxIndex])
-      repMaxIndex = i;
-  }
-  if (repLens[repMaxIndex] &gt;= p-&gt;numFastBytes)
-  {
-    UInt32 lenRes;
-    *backRes = repMaxIndex;
-    lenRes = repLens[repMaxIndex];
-    MovePos(p, lenRes - 1);
-    return lenRes;
-  }
-
-  matches = p-&gt;matches;
-  if (mainLen &gt;= p-&gt;numFastBytes)
-  {
-    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
-  }
-  curByte = *data;
-  matchByte = *(data - (reps[0] + 1));
-
-  if (mainLen &lt; 2 &amp;&amp; curByte != matchByte &amp;&amp; repLens[repMaxIndex] &lt; 2)
-  {
-    *backRes = (UInt32)-1;
-    return 1;
-  }
-
-  p-&gt;opt[0].state = (CState)p-&gt;state;
-
-  posState = (position &amp; p-&gt;pbMask);
-
-  {
-    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-    p-&gt;opt[1].price = GET_PRICE_0(p-&gt;isMatch[p-&gt;state][posState]) +
-        (!IsCharState(p-&gt;state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p-&gt;ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p-&gt;ProbPrices));
-  }
-
-  MakeAsChar(&amp;p-&gt;opt[1]);
-
-  matchPrice = GET_PRICE_1(p-&gt;isMatch[p-&gt;state][posState]);
-  repMatchPrice = matchPrice + GET_PRICE_1(p-&gt;isRep[p-&gt;state]);
-
-  if (matchByte == curByte)
-  {
-    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p-&gt;state, posState);
-    if (shortRepPrice &lt; p-&gt;opt[1].price)
-    {
-      p-&gt;opt[1].price = shortRepPrice;
-      MakeAsShortRep(&amp;p-&gt;opt[1]);
-    }
-  }
-  lenEnd = ((mainLen &gt;= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
-
-  if (lenEnd &lt; 2)
-  {
-    *backRes = p-&gt;opt[1].backPrev;
-    return 1;
-  }
-
-  p-&gt;opt[1].posPrev = 0;
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-    p-&gt;opt[0].backs[i] = reps[i];
-
-  len = lenEnd;
-  do
-    p-&gt;opt[len--].price = kInfinityPrice;
-  while (len &gt;= 2);
-
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-  {
-    UInt32 repLen = repLens[i];
-    UInt32 price;
-    if (repLen &lt; 2)
-      continue;
-    price = repMatchPrice + GetPureRepPrice(p, i, p-&gt;state, posState);
-    do
-    {
-      UInt32 curAndLenPrice = price + p-&gt;repLenEnc.prices[posState][repLen - 2];
-      COptimal *opt = &amp;p-&gt;opt[repLen];
-      if (curAndLenPrice &lt; opt-&gt;price)
-      {
-        opt-&gt;price = curAndLenPrice;
-        opt-&gt;posPrev = 0;
-        opt-&gt;backPrev = i;
-        opt-&gt;prev1IsChar = False;
-      }
-    }
-    while (--repLen &gt;= 2);
-  }
-
-  normalMatchPrice = matchPrice + GET_PRICE_0(p-&gt;isRep[p-&gt;state]);
-
-  len = ((repLens[0] &gt;= 2) ? repLens[0] + 1 : 2);
-  if (len &lt;= mainLen)
-  {
-    UInt32 offs = 0;
-    while (len &gt; matches[offs])
-      offs += 2;
-    for (; ; len++)
-    {
-      COptimal *opt;
-      UInt32 distance = matches[offs + 1];
-
-      UInt32 curAndLenPrice = normalMatchPrice + p-&gt;lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
-      UInt32 lenToPosState = GetLenToPosState(len);
-      if (distance &lt; kNumFullDistances)
-        curAndLenPrice += p-&gt;distancesPrices[lenToPosState][distance];
-      else
-      {
-        UInt32 slot;
-        GetPosSlot2(distance, slot);
-        curAndLenPrice += p-&gt;alignPrices[distance &amp; kAlignMask] + p-&gt;posSlotPrices[lenToPosState][slot];
-      }
-      opt = &amp;p-&gt;opt[len];
-      if (curAndLenPrice &lt; opt-&gt;price)
-      {
-        opt-&gt;price = curAndLenPrice;
-        opt-&gt;posPrev = 0;
-        opt-&gt;backPrev = distance + LZMA_NUM_REPS;
-        opt-&gt;prev1IsChar = False;
-      }
-      if (len == matches[offs])
-      {
-        offs += 2;
-        if (offs == numPairs)
-          break;
-      }
-    }
-  }
-
-  cur = 0;
-
-    #ifdef SHOW_STAT2
-    if (position &gt;= 0)
-    {
-      unsigned i;
-      printf(&quot;\n pos = %4X&quot;, position);
-      for (i = cur; i &lt;= lenEnd; i++)
-      printf(&quot;\nprice[%4X] = %d&quot;, position - cur + i, p-&gt;opt[i].price);
-    }
-    #endif
-
-  for (;;)
-  {
-    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
-    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
-    Bool nextIsChar;
-    Byte curByte, matchByte;
-    const Byte *data;
-    COptimal *curOpt;
-    COptimal *nextOpt;
-
-    cur++;
-    if (cur == lenEnd)
-      return Backward(p, backRes, cur);
-
-    newLen = ReadMatchDistances(p, &amp;numPairs);
-    if (newLen &gt;= p-&gt;numFastBytes)
-    {
-      p-&gt;numPairs = numPairs;
-      p-&gt;longestMatchLength = newLen;
-      return Backward(p, backRes, cur);
-    }
-    position++;
-    curOpt = &amp;p-&gt;opt[cur];
-    posPrev = curOpt-&gt;posPrev;
-    if (curOpt-&gt;prev1IsChar)
-    {
-      posPrev--;
-      if (curOpt-&gt;prev2)
-      {
-        state = p-&gt;opt[curOpt-&gt;posPrev2].state;
-        if (curOpt-&gt;backPrev2 &lt; LZMA_NUM_REPS)
-          state = kRepNextStates[state];
-        else
-          state = kMatchNextStates[state];
-      }
-      else
-        state = p-&gt;opt[posPrev].state;
-      state = kLiteralNextStates[state];
-    }
-    else
-      state = p-&gt;opt[posPrev].state;
-    if (posPrev == cur - 1)
-    {
-      if (IsShortRep(curOpt))
-        state = kShortRepNextStates[state];
-      else
-        state = kLiteralNextStates[state];
-    }
-    else
-    {
-      UInt32 pos;
-      const COptimal *prevOpt;
-      if (curOpt-&gt;prev1IsChar &amp;&amp; curOpt-&gt;prev2)
-      {
-        posPrev = curOpt-&gt;posPrev2;
-        pos = curOpt-&gt;backPrev2;
-        state = kRepNextStates[state];
-      }
-      else
-      {
-        pos = curOpt-&gt;backPrev;
-        if (pos &lt; LZMA_NUM_REPS)
-          state = kRepNextStates[state];
-        else
-          state = kMatchNextStates[state];
-      }
-      prevOpt = &amp;p-&gt;opt[posPrev];
-      if (pos &lt; LZMA_NUM_REPS)
-      {
-        UInt32 i;
-        reps[0] = prevOpt-&gt;backs[pos];
-        for (i = 1; i &lt;= pos; i++)
-          reps[i] = prevOpt-&gt;backs[i - 1];
-        for (; i &lt; LZMA_NUM_REPS; i++)
-          reps[i] = prevOpt-&gt;backs[i];
-      }
-      else
-      {
-        UInt32 i;
-        reps[0] = (pos - LZMA_NUM_REPS);
-        for (i = 1; i &lt; LZMA_NUM_REPS; i++)
-          reps[i] = prevOpt-&gt;backs[i - 1];
-      }
-    }
-    curOpt-&gt;state = (CState)state;
-
-    curOpt-&gt;backs[0] = reps[0];
-    curOpt-&gt;backs[1] = reps[1];
-    curOpt-&gt;backs[2] = reps[2];
-    curOpt-&gt;backs[3] = reps[3];
-
-    curPrice = curOpt-&gt;price;
-    nextIsChar = False;
-    data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-    curByte = *data;
-    matchByte = *(data - (reps[0] + 1));
-
-    posState = (position &amp; p-&gt;pbMask);
-
-    curAnd1Price = curPrice + GET_PRICE_0(p-&gt;isMatch[state][posState]);
-    {
-      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-      curAnd1Price +=
-        (!IsCharState(state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p-&gt;ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p-&gt;ProbPrices));
-    }
-
-    nextOpt = &amp;p-&gt;opt[cur + 1];
-
-    if (curAnd1Price &lt; nextOpt-&gt;price)
-    {
-      nextOpt-&gt;price = curAnd1Price;
-      nextOpt-&gt;posPrev = cur;
-      MakeAsChar(nextOpt);
-      nextIsChar = True;
-    }
-
-    matchPrice = curPrice + GET_PRICE_1(p-&gt;isMatch[state][posState]);
-    repMatchPrice = matchPrice + GET_PRICE_1(p-&gt;isRep[state]);
-    
-    if (matchByte == curByte &amp;&amp; !(nextOpt-&gt;posPrev &lt; cur &amp;&amp; nextOpt-&gt;backPrev == 0))
-    {
-      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
-      if (shortRepPrice &lt;= nextOpt-&gt;price)
-      {
-        nextOpt-&gt;price = shortRepPrice;
-        nextOpt-&gt;posPrev = cur;
-        MakeAsShortRep(nextOpt);
-        nextIsChar = True;
-      }
-    }
-    numAvailFull = p-&gt;numAvail;
-    {
-      UInt32 temp = kNumOpts - 1 - cur;
-      if (temp &lt; numAvailFull)
-        numAvailFull = temp;
-    }
-
-    if (numAvailFull &lt; 2)
-      continue;
-    numAvail = (numAvailFull &lt;= p-&gt;numFastBytes ? numAvailFull : p-&gt;numFastBytes);
-
-    if (!nextIsChar &amp;&amp; matchByte != curByte) /* speed optimization */
-    {
-      /* try Literal + rep0 */
-      UInt32 temp;
-      UInt32 lenTest2;
-      const Byte *data2 = data - (reps[0] + 1);
-      UInt32 limit = p-&gt;numFastBytes + 1;
-      if (limit &gt; numAvailFull)
-        limit = numAvailFull;
-
-      for (temp = 1; temp &lt; limit &amp;&amp; data[temp] == data2[temp]; temp++);
-      lenTest2 = temp - 1;
-      if (lenTest2 &gt;= 2)
-      {
-        UInt32 state2 = kLiteralNextStates[state];
-        UInt32 posStateNext = (position + 1) &amp; p-&gt;pbMask;
-        UInt32 nextRepMatchPrice = curAnd1Price +
-            GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
-            GET_PRICE_1(p-&gt;isRep[state2]);
-        /* for (; lenTest2 &gt;= 2; lenTest2--) */
-        {
-          UInt32 curAndLenPrice;
-          COptimal *opt;
-          UInt32 offset = cur + 1 + lenTest2;
-          while (lenEnd &lt; offset)
-            p-&gt;opt[++lenEnd].price = kInfinityPrice;
-          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-          opt = &amp;p-&gt;opt[offset];
-          if (curAndLenPrice &lt; opt-&gt;price)
-          {
-            opt-&gt;price = curAndLenPrice;
-            opt-&gt;posPrev = cur + 1;
-            opt-&gt;backPrev = 0;
-            opt-&gt;prev1IsChar = True;
-            opt-&gt;prev2 = False;
-          }
-        }
-      }
-    }
-    
-    startLen = 2; /* speed optimization */
-    {
-    UInt32 repIndex;
-    for (repIndex = 0; repIndex &lt; LZMA_NUM_REPS; repIndex++)
-    {
-      UInt32 lenTest;
-      UInt32 lenTestTemp;
-      UInt32 price;
-      const Byte *data2 = data - (reps[repIndex] + 1);
-      if (data[0] != data2[0] || data[1] != data2[1])
-        continue;
-      for (lenTest = 2; lenTest &lt; numAvail &amp;&amp; data[lenTest] == data2[lenTest]; lenTest++);
-      while (lenEnd &lt; cur + lenTest)
-        p-&gt;opt[++lenEnd].price = kInfinityPrice;
-      lenTestTemp = lenTest;
-      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
-      do
-      {
-        UInt32 curAndLenPrice = price + p-&gt;repLenEnc.prices[posState][lenTest - 2];
-        COptimal *opt = &amp;p-&gt;opt[cur + lenTest];
-        if (curAndLenPrice &lt; opt-&gt;price)
-        {
-          opt-&gt;price = curAndLenPrice;
-          opt-&gt;posPrev = cur;
-          opt-&gt;backPrev = repIndex;
-          opt-&gt;prev1IsChar = False;
-        }
-      }
-      while (--lenTest &gt;= 2);
-      lenTest = lenTestTemp;
-      
-      if (repIndex == 0)
-        startLen = lenTest + 1;
-        
-      /* if (_maxMode) */
-        {
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p-&gt;numFastBytes;
-          UInt32 nextRepMatchPrice;
-          if (limit &gt; numAvailFull)
-            limit = numAvailFull;
-          for (; lenTest2 &lt; limit &amp;&amp; data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 &gt;= 2)
-          {
-            UInt32 state2 = kRepNextStates[state];
-            UInt32 posStateNext = (position + lenTest) &amp; p-&gt;pbMask;
-            UInt32 curAndLenCharPrice =
-                price + p-&gt;repLenEnc.prices[posState][lenTest - 2] +
-                GET_PRICE_0(p-&gt;isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-                    data[lenTest], data2[lenTest], p-&gt;ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (position + lenTest + 1) &amp; p-&gt;pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p-&gt;isRep[state2]);
-            
-            /* for (; lenTest2 &gt;= 2; lenTest2--) */
-            {
-              UInt32 curAndLenPrice;
-              COptimal *opt;
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              while (lenEnd &lt; offset)
-                p-&gt;opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-              opt = &amp;p-&gt;opt[offset];
-              if (curAndLenPrice &lt; opt-&gt;price)
-              {
-                opt-&gt;price = curAndLenPrice;
-                opt-&gt;posPrev = cur + lenTest + 1;
-                opt-&gt;backPrev = 0;
-                opt-&gt;prev1IsChar = True;
-                opt-&gt;prev2 = True;
-                opt-&gt;posPrev2 = cur;
-                opt-&gt;backPrev2 = repIndex;
-              }
-            }
-          }
-        }
-    }
-    }
-    /* for (UInt32 lenTest = 2; lenTest &lt;= newLen; lenTest++) */
-    if (newLen &gt; numAvail)
-    {
-      newLen = numAvail;
-      for (numPairs = 0; newLen &gt; matches[numPairs]; numPairs += 2);
-      matches[numPairs] = newLen;
-      numPairs += 2;
-    }
-    if (newLen &gt;= startLen)
-    {
-      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p-&gt;isRep[state]);
-      UInt32 offs, curBack, posSlot;
-      UInt32 lenTest;
-      while (lenEnd &lt; cur + newLen)
-        p-&gt;opt[++lenEnd].price = kInfinityPrice;
-
-      offs = 0;
-      while (startLen &gt; matches[offs])
-        offs += 2;
-      curBack = matches[offs + 1];
-      GetPosSlot2(curBack, posSlot);
-      for (lenTest = /*2*/ startLen; ; lenTest++)
-      {
-        UInt32 curAndLenPrice = normalMatchPrice + p-&gt;lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
-        UInt32 lenToPosState = GetLenToPosState(lenTest);
-        COptimal *opt;
-        if (curBack &lt; kNumFullDistances)
-          curAndLenPrice += p-&gt;distancesPrices[lenToPosState][curBack];
-        else
-          curAndLenPrice += p-&gt;posSlotPrices[lenToPosState][posSlot] + p-&gt;alignPrices[curBack &amp; kAlignMask];
-        
-        opt = &amp;p-&gt;opt[cur + lenTest];
-        if (curAndLenPrice &lt; opt-&gt;price)
-        {
-          opt-&gt;price = curAndLenPrice;
-          opt-&gt;posPrev = cur;
-          opt-&gt;backPrev = curBack + LZMA_NUM_REPS;
-          opt-&gt;prev1IsChar = False;
-        }
-
-        if (/*_maxMode &amp;&amp; */lenTest == matches[offs])
-        {
-          /* Try Match + Literal + Rep0 */
-          const Byte *data2 = data - (curBack + 1);
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p-&gt;numFastBytes;
-          UInt32 nextRepMatchPrice;
-          if (limit &gt; numAvailFull)
-            limit = numAvailFull;
-          for (; lenTest2 &lt; limit &amp;&amp; data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 &gt;= 2)
-          {
-            UInt32 state2 = kMatchNextStates[state];
-            UInt32 posStateNext = (position + lenTest) &amp; p-&gt;pbMask;
-            UInt32 curAndLenCharPrice = curAndLenPrice +
-                GET_PRICE_0(p-&gt;isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-                    data[lenTest], data2[lenTest], p-&gt;ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (posStateNext + 1) &amp; p-&gt;pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p-&gt;isRep[state2]);
-            
-            /* for (; lenTest2 &gt;= 2; lenTest2--) */
-            {
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              UInt32 curAndLenPrice;
-              COptimal *opt;
-              while (lenEnd &lt; offset)
-                p-&gt;opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-              opt = &amp;p-&gt;opt[offset];
-              if (curAndLenPrice &lt; opt-&gt;price)
-              {
-                opt-&gt;price = curAndLenPrice;
-                opt-&gt;posPrev = cur + lenTest + 1;
-                opt-&gt;backPrev = 0;
-                opt-&gt;prev1IsChar = True;
-                opt-&gt;prev2 = True;
-                opt-&gt;posPrev2 = cur;
-                opt-&gt;backPrev2 = curBack + LZMA_NUM_REPS;
-              }
-            }
-          }
-          offs += 2;
-          if (offs == numPairs)
-            break;
-          curBack = matches[offs + 1];
-          if (curBack &gt;= kNumFullDistances)
-            GetPosSlot2(curBack, posSlot);
-        }
-      }
-    }
-  }
-}
-
-#define ChangePair(smallDist, bigDist) (((bigDist) &gt;&gt; 7) &gt; (smallDist))
-
-static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
-{
-  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
-  const Byte *data;
-  const UInt32 *matches;
-
-  if (p-&gt;additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &amp;numPairs);
-  else
-  {
-    mainLen = p-&gt;longestMatchLength;
-    numPairs = p-&gt;numPairs;
-  }
-
-  numAvail = p-&gt;numAvail;
-  *backRes = (UInt32)-1;
-  if (numAvail &lt; 2)
-    return 1;
-  if (numAvail &gt; LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
-  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-
-  repLen = repIndex = 0;
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-  {
-    UInt32 len;
-    const Byte *data2 = data - (p-&gt;reps[i] + 1);
-    if (data[0] != data2[0] || data[1] != data2[1])
-      continue;
-    for (len = 2; len &lt; numAvail &amp;&amp; data[len] == data2[len]; len++);
-    if (len &gt;= p-&gt;numFastBytes)
-    {
-      *backRes = i;
-      MovePos(p, len - 1);
-      return len;
-    }
-    if (len &gt; repLen)
-    {
-      repIndex = i;
-      repLen = len;
-    }
-  }
-
-  matches = p-&gt;matches;
-  if (mainLen &gt;= p-&gt;numFastBytes)
-  {
-    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
-  }
-
-  mainDist = 0; /* for GCC */
-  if (mainLen &gt;= 2)
-  {
-    mainDist = matches[numPairs - 1];
-    while (numPairs &gt; 2 &amp;&amp; mainLen == matches[numPairs - 4] + 1)
-    {
-      if (!ChangePair(matches[numPairs - 3], mainDist))
-        break;
-      numPairs -= 2;
-      mainLen = matches[numPairs - 2];
-      mainDist = matches[numPairs - 1];
-    }
-    if (mainLen == 2 &amp;&amp; mainDist &gt;= 0x80)
-      mainLen = 1;
-  }
-
-  if (repLen &gt;= 2 &amp;&amp; (
-        (repLen + 1 &gt;= mainLen) ||
-        (repLen + 2 &gt;= mainLen &amp;&amp; mainDist &gt;= (1 &lt;&lt; 9)) ||
-        (repLen + 3 &gt;= mainLen &amp;&amp; mainDist &gt;= (1 &lt;&lt; 15))))
-  {
-    *backRes = repIndex;
-    MovePos(p, repLen - 1);
-    return repLen;
-  }
-  
-  if (mainLen &lt; 2 || numAvail &lt;= 2)
-    return 1;
-
-  p-&gt;longestMatchLength = ReadMatchDistances(p, &amp;p-&gt;numPairs);
-  if (p-&gt;longestMatchLength &gt;= 2)
-  {
-    UInt32 newDistance = matches[p-&gt;numPairs - 1];
-    if ((p-&gt;longestMatchLength &gt;= mainLen &amp;&amp; newDistance &lt; mainDist) ||
-        (p-&gt;longestMatchLength == mainLen + 1 &amp;&amp; !ChangePair(mainDist, newDistance)) ||
-        (p-&gt;longestMatchLength &gt; mainLen + 1) ||
-        (p-&gt;longestMatchLength + 1 &gt;= mainLen &amp;&amp; mainLen &gt;= 3 &amp;&amp; ChangePair(newDistance, mainDist)))
-      return 1;
-  }
-  
-  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
-  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
-  {
-    UInt32 len, limit;
-    const Byte *data2 = data - (p-&gt;reps[i] + 1);
-    if (data[0] != data2[0] || data[1] != data2[1])
-      continue;
-    limit = mainLen - 1;
-    for (len = 2; len &lt; limit &amp;&amp; data[len] == data2[len]; len++);
-    if (len &gt;= limit)
-      return 1;
-  }
-  *backRes = mainDist + LZMA_NUM_REPS;
-  MovePos(p, mainLen - 2);
-  return mainLen;
-}
-
-static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
-{
-  UInt32 len;
-  RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 1);
-  RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 0);
-  p-&gt;state = kMatchNextStates[p-&gt;state];
-  len = LZMA_MATCH_LEN_MIN;
-  LenEnc_Encode2(&amp;p-&gt;lenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
-  RcTree_Encode(&amp;p-&gt;rc, p-&gt;posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 &lt;&lt; kNumPosSlotBits) - 1);
-  RangeEnc_EncodeDirectBits(&amp;p-&gt;rc, (((UInt32)1 &lt;&lt; 30) - 1) &gt;&gt; kNumAlignBits, 30 - kNumAlignBits);
-  RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posAlignEncoder, kNumAlignBits, kAlignMask);
-}
-
-static SRes CheckErrors(CLzmaEnc *p)
-{
-  if (p-&gt;result != SZ_OK)
-    return p-&gt;result;
-  if (p-&gt;rc.res != SZ_OK)
-    p-&gt;result = SZ_ERROR_WRITE;
-  if (p-&gt;matchFinderBase.result != SZ_OK)
-    p-&gt;result = SZ_ERROR_READ;
-  if (p-&gt;result != SZ_OK)
-    p-&gt;finished = True;
-  return p-&gt;result;
-}
-
-static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
-{
-  /* ReleaseMFStream(); */
-  p-&gt;finished = True;
-  if (p-&gt;writeEndMark)
-    WriteEndMarker(p, nowPos &amp; p-&gt;pbMask);
-  RangeEnc_FlushData(&amp;p-&gt;rc);
-  RangeEnc_FlushStream(&amp;p-&gt;rc);
-  return CheckErrors(p);
-}
-
-static void FillAlignPrices(CLzmaEnc *p)
-{
-  UInt32 i;
-  for (i = 0; i &lt; kAlignTableSize; i++)
-    p-&gt;alignPrices[i] = RcTree_ReverseGetPrice(p-&gt;posAlignEncoder, kNumAlignBits, i, p-&gt;ProbPrices);
-  p-&gt;alignPriceCount = 0;
-}
-
-static void FillDistancesPrices(CLzmaEnc *p)
-{
-  UInt32 tempPrices[kNumFullDistances];
-  UInt32 i, lenToPosState;
-  for (i = kStartPosModelIndex; i &lt; kNumFullDistances; i++)
-  {
-    UInt32 posSlot = GetPosSlot1(i);
-    UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
-    UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
-    tempPrices[i] = RcTree_ReverseGetPrice(p-&gt;posEncoders + base - posSlot - 1, footerBits, i - base, p-&gt;ProbPrices);
-  }
-
-  for (lenToPosState = 0; lenToPosState &lt; kNumLenToPosStates; lenToPosState++)
-  {
-    UInt32 posSlot;
-    const CLzmaProb *encoder = p-&gt;posSlotEncoder[lenToPosState];
-    UInt32 *posSlotPrices = p-&gt;posSlotPrices[lenToPosState];
-    for (posSlot = 0; posSlot &lt; p-&gt;distTableSize; posSlot++)
-      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p-&gt;ProbPrices);
-    for (posSlot = kEndPosModelIndex; posSlot &lt; p-&gt;distTableSize; posSlot++)
-      posSlotPrices[posSlot] += ((((posSlot &gt;&gt; 1) - 1) - kNumAlignBits) &lt;&lt; kNumBitPriceShiftBits);
-
-    {
-      UInt32 *distancesPrices = p-&gt;distancesPrices[lenToPosState];
-      UInt32 i;
-      for (i = 0; i &lt; kStartPosModelIndex; i++)
-        distancesPrices[i] = posSlotPrices[i];
-      for (; i &lt; kNumFullDistances; i++)
-        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
-    }
-  }
-  p-&gt;matchPriceCount = 0;
-}
-
-void LzmaEnc_Construct(CLzmaEnc *p)
-{
-  RangeEnc_Construct(&amp;p-&gt;rc);
-  MatchFinder_Construct(&amp;p-&gt;matchFinderBase);
-  #ifdef COMPRESS_MF_MT
-  MatchFinderMt_Construct(&amp;p-&gt;matchFinderMt);
-  p-&gt;matchFinderMt.MatchFinder = &amp;p-&gt;matchFinderBase;
-  #endif
-
-  {
-    CLzmaEncProps props;
-    LzmaEncProps_Init(&amp;props);
-    LzmaEnc_SetProps(p, &amp;props);
-  }
-
-  #ifndef LZMA_LOG_BSR
-  LzmaEnc_FastPosInit(p-&gt;g_FastPos);
-  #endif
-
-  LzmaEnc_InitPriceTables(p-&gt;ProbPrices);
-  p-&gt;litProbs = 0;
-  p-&gt;saveState.litProbs = 0;
-}
-
-CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
-{
-  void *p;
-  p = alloc-&gt;Alloc(alloc, sizeof(CLzmaEnc));
-  if (p != 0)
-    LzmaEnc_Construct((CLzmaEnc *)p);
-  return p;
-}
-
-void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-{
-  alloc-&gt;Free(alloc, p-&gt;litProbs);
-  alloc-&gt;Free(alloc, p-&gt;saveState.litProbs);
-  p-&gt;litProbs = 0;
-  p-&gt;saveState.litProbs = 0;
-}
-
-void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  #ifdef COMPRESS_MF_MT
-  MatchFinderMt_Destruct(&amp;p-&gt;matchFinderMt, allocBig);
-  #endif
-  MatchFinder_Free(&amp;p-&gt;matchFinderBase, allocBig);
-  LzmaEnc_FreeLits(p, alloc);
-  RangeEnc_Free(&amp;p-&gt;rc, alloc);
-}
-
-void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
-  alloc-&gt;Free(alloc, p);
-}
-
-static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
-{
-  UInt32 nowPos32, startPos32;
-  if (p-&gt;inStream != 0)
-  {
-    p-&gt;matchFinderBase.stream = p-&gt;inStream;
-    p-&gt;matchFinder.Init(p-&gt;matchFinderObj);
-    p-&gt;inStream = 0;
-  }
-
-  if (p-&gt;finished)
-    return p-&gt;result;
-  RINOK(CheckErrors(p));
-
-  nowPos32 = (UInt32)p-&gt;nowPos64;
-  startPos32 = nowPos32;
-
-  if (p-&gt;nowPos64 == 0)
-  {
-    UInt32 numPairs;
-    Byte curByte;
-    if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) == 0)
-      return Flush(p, nowPos32);
-    ReadMatchDistances(p, &amp;numPairs);
-    RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][0], 0);
-    p-&gt;state = kLiteralNextStates[p-&gt;state];
-    curByte = p-&gt;matchFinder.GetIndexByte(p-&gt;matchFinderObj, 0 - p-&gt;additionalOffset);
-    LitEnc_Encode(&amp;p-&gt;rc, p-&gt;litProbs, curByte);
-    p-&gt;additionalOffset--;
-    nowPos32++;
-  }
-
-  if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) != 0)
-  for (;;)
-  {
-    UInt32 pos, len, posState;
-
-    if (p-&gt;fastMode)
-      len = GetOptimumFast(p, &amp;pos);
-    else
-      len = GetOptimum(p, nowPos32, &amp;pos);
-
-    #ifdef SHOW_STAT2
-    printf(&quot;\n pos = %4X,   len = %d   pos = %d&quot;, nowPos32, len, pos);
-    #endif
-
-    posState = nowPos32 &amp; p-&gt;pbMask;
-    if (len == 1 &amp;&amp; pos == (UInt32)-1)
-    {
-      Byte curByte;
-      CLzmaProb *probs;
-      const Byte *data;
-
-      RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 0);
-      data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - p-&gt;additionalOffset;
-      curByte = *data;
-      probs = LIT_PROBS(nowPos32, *(data - 1));
-      if (IsCharState(p-&gt;state))
-        LitEnc_Encode(&amp;p-&gt;rc, probs, curByte);
-      else
-        LitEnc_EncodeMatched(&amp;p-&gt;rc, probs, curByte, *(data - p-&gt;reps[0] - 1));
-      p-&gt;state = kLiteralNextStates[p-&gt;state];
-    }
-    else
-    {
-      RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 1);
-      if (pos &lt; LZMA_NUM_REPS)
-      {
-        RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 1);
-        if (pos == 0)
-        {
-          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG0[p-&gt;state], 0);
-          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep0Long[p-&gt;state][posState], ((len == 1) ? 0 : 1));
-        }
-        else
-        {
-          UInt32 distance = p-&gt;reps[pos];
-          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG0[p-&gt;state], 1);
-          if (pos == 1)
-            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG1[p-&gt;state], 0);
-          else
-          {
-            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG1[p-&gt;state], 1);
-            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG2[p-&gt;state], pos - 2);
-            if (pos == 3)
-              p-&gt;reps[3] = p-&gt;reps[2];
-            p-&gt;reps[2] = p-&gt;reps[1];
-          }
-          p-&gt;reps[1] = p-&gt;reps[0];
-          p-&gt;reps[0] = distance;
-        }
-        if (len == 1)
-          p-&gt;state = kShortRepNextStates[p-&gt;state];
-        else
-        {
-          LenEnc_Encode2(&amp;p-&gt;repLenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
-          p-&gt;state = kRepNextStates[p-&gt;state];
-        }
-      }
-      else
-      {
-        UInt32 posSlot;
-        RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 0);
-        p-&gt;state = kMatchNextStates[p-&gt;state];
-        LenEnc_Encode2(&amp;p-&gt;lenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
-        pos -= LZMA_NUM_REPS;
-        GetPosSlot(pos, posSlot);
-        RcTree_Encode(&amp;p-&gt;rc, p-&gt;posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
-        
-        if (posSlot &gt;= kStartPosModelIndex)
-        {
-          UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
-          UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
-          UInt32 posReduced = pos - base;
-
-          if (posSlot &lt; kEndPosModelIndex)
-            RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posEncoders + base - posSlot - 1, footerBits, posReduced);
-          else
-          {
-            RangeEnc_EncodeDirectBits(&amp;p-&gt;rc, posReduced &gt;&gt; kNumAlignBits, footerBits - kNumAlignBits);
-            RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posAlignEncoder, kNumAlignBits, posReduced &amp; kAlignMask);
-            p-&gt;alignPriceCount++;
-          }
-        }
-        p-&gt;reps[3] = p-&gt;reps[2];
-        p-&gt;reps[2] = p-&gt;reps[1];
-        p-&gt;reps[1] = p-&gt;reps[0];
-        p-&gt;reps[0] = pos;
-        p-&gt;matchPriceCount++;
-      }
-    }
-    p-&gt;additionalOffset -= len;
-    nowPos32 += len;
-    if (p-&gt;additionalOffset == 0)
-    {
-      UInt32 processed;
-      if (!p-&gt;fastMode)
-      {
-        if (p-&gt;matchPriceCount &gt;= (1 &lt;&lt; 7))
-          FillDistancesPrices(p);
-        if (p-&gt;alignPriceCount &gt;= kAlignTableSize)
-          FillAlignPrices(p);
-      }
-      if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) == 0)
-        break;
-      processed = nowPos32 - startPos32;
-      if (useLimits)
-      {
-        if (processed + kNumOpts + 300 &gt;= maxUnpackSize ||
-            RangeEnc_GetProcessed(&amp;p-&gt;rc) + kNumOpts * 2 &gt;= maxPackSize)
-          break;
-      }
-      else if (processed &gt;= (1 &lt;&lt; 15))
-      {
-        p-&gt;nowPos64 += nowPos32 - startPos32;
-        return CheckErrors(p);
-      }
-    }
-  }
-  p-&gt;nowPos64 += nowPos32 - startPos32;
-  return Flush(p, nowPos32);
-}
-
-#define kBigHashDicLimit ((UInt32)1 &lt;&lt; 24)
-
-static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  UInt32 beforeSize = kNumOpts;
-  Bool btMode;
-  if (!RangeEnc_Alloc(&amp;p-&gt;rc, alloc))
-    return SZ_ERROR_MEM;
-  btMode = (p-&gt;matchFinderBase.btMode != 0);
-  #ifdef COMPRESS_MF_MT
-  p-&gt;mtMode = (p-&gt;multiThread &amp;&amp; !p-&gt;fastMode &amp;&amp; btMode);
-  #endif
-
-  {
-    unsigned lclp = p-&gt;lc + p-&gt;lp;
-    if (p-&gt;litProbs == 0 || p-&gt;saveState.litProbs == 0 || p-&gt;lclp != lclp)
-    {
-      LzmaEnc_FreeLits(p, alloc);
-      p-&gt;litProbs = (CLzmaProb *)alloc-&gt;Alloc(alloc, (0x300 &lt;&lt; lclp) * sizeof(CLzmaProb));
-      p-&gt;saveState.litProbs = (CLzmaProb *)alloc-&gt;Alloc(alloc, (0x300 &lt;&lt; lclp) * sizeof(CLzmaProb));
-      if (p-&gt;litProbs == 0 || p-&gt;saveState.litProbs == 0)
-      {
-        LzmaEnc_FreeLits(p, alloc);
-        return SZ_ERROR_MEM;
-      }
-      p-&gt;lclp = lclp;
-    }
-  }
-
-  p-&gt;matchFinderBase.bigHash = (p-&gt;dictSize &gt; kBigHashDicLimit);
-
-  if (beforeSize + p-&gt;dictSize &lt; keepWindowSize)
-    beforeSize = keepWindowSize - p-&gt;dictSize;
-
-  #ifdef COMPRESS_MF_MT
-  if (p-&gt;mtMode)
-  {
-    RINOK(MatchFinderMt_Create(&amp;p-&gt;matchFinderMt, p-&gt;dictSize, beforeSize, p-&gt;numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
-    p-&gt;matchFinderObj = &amp;p-&gt;matchFinderMt;
-    MatchFinderMt_CreateVTable(&amp;p-&gt;matchFinderMt, &amp;p-&gt;matchFinder);
-  }
-  else
-  #endif
-  {
-    if (!MatchFinder_Create(&amp;p-&gt;matchFinderBase, p-&gt;dictSize, beforeSize, p-&gt;numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
-      return SZ_ERROR_MEM;
-    p-&gt;matchFinderObj = &amp;p-&gt;matchFinderBase;
-    MatchFinder_CreateVTable(&amp;p-&gt;matchFinderBase, &amp;p-&gt;matchFinder);
-  }
-  return SZ_OK;
-}
-
-void LzmaEnc_Init(CLzmaEnc *p)
-{
-  UInt32 i;
-  p-&gt;state = 0;
-  for (i = 0 ; i &lt; LZMA_NUM_REPS; i++)
-    p-&gt;reps[i] = 0;
-
-  RangeEnc_Init(&amp;p-&gt;rc);
-
-
-  for (i = 0; i &lt; kNumStates; i++)
-  {
-    UInt32 j;
-    for (j = 0; j &lt; LZMA_NUM_PB_STATES_MAX; j++)
-    {
-      p-&gt;isMatch[i][j] = kProbInitValue;
-      p-&gt;isRep0Long[i][j] = kProbInitValue;
-    }
-    p-&gt;isRep[i] = kProbInitValue;
-    p-&gt;isRepG0[i] = kProbInitValue;
-    p-&gt;isRepG1[i] = kProbInitValue;
-    p-&gt;isRepG2[i] = kProbInitValue;
-  }
-
-  {
-    UInt32 num = 0x300 &lt;&lt; (p-&gt;lp + p-&gt;lc);
-    for (i = 0; i &lt; num; i++)
-      p-&gt;litProbs[i] = kProbInitValue;
-  }
-
-  {
-    for (i = 0; i &lt; kNumLenToPosStates; i++)
-    {
-      CLzmaProb *probs = p-&gt;posSlotEncoder[i];
-      UInt32 j;
-      for (j = 0; j &lt; (1 &lt;&lt; kNumPosSlotBits); j++)
-        probs[j] = kProbInitValue;
-    }
-  }
-  {
-    for (i = 0; i &lt; kNumFullDistances - kEndPosModelIndex; i++)
-      p-&gt;posEncoders[i] = kProbInitValue;
-  }
-
-  LenEnc_Init(&amp;p-&gt;lenEnc.p);
-  LenEnc_Init(&amp;p-&gt;repLenEnc.p);
-
-  for (i = 0; i &lt; (1 &lt;&lt; kNumAlignBits); i++)
-    p-&gt;posAlignEncoder[i] = kProbInitValue;
-
-  p-&gt;optimumEndIndex = 0;
-  p-&gt;optimumCurrentIndex = 0;
-  p-&gt;additionalOffset = 0;
-
-  p-&gt;pbMask = (1 &lt;&lt; p-&gt;pb) - 1;
-  p-&gt;lpMask = (1 &lt;&lt; p-&gt;lp) - 1;
-}
-
-void LzmaEnc_InitPrices(CLzmaEnc *p)
-{
-  if (!p-&gt;fastMode)
-  {
-    FillDistancesPrices(p);
-    FillAlignPrices(p);
-  }
-
-  p-&gt;lenEnc.tableSize =
-  p-&gt;repLenEnc.tableSize =
-      p-&gt;numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
-  LenPriceEnc_UpdateTables(&amp;p-&gt;lenEnc, 1 &lt;&lt; p-&gt;pb, p-&gt;ProbPrices);
-  LenPriceEnc_UpdateTables(&amp;p-&gt;repLenEnc, 1 &lt;&lt; p-&gt;pb, p-&gt;ProbPrices);
-}
-
-static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  UInt32 i;
-  for (i = 0; i &lt; (UInt32)kDicLogSizeMaxCompress; i++)
-    if (p-&gt;dictSize &lt;= ((UInt32)1 &lt;&lt; i))
-      break;
-  p-&gt;distTableSize = i * 2;
-
-  p-&gt;finished = False;
-  p-&gt;result = SZ_OK;
-  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
-  LzmaEnc_Init(p);
-  LzmaEnc_InitPrices(p);
-  p-&gt;nowPos64 = 0;
-  return SZ_OK;
-}
-
-static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqInStream *inStream, ISeqOutStream *outStream,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  p-&gt;inStream = inStream;
-  p-&gt;rc.outStream = outStream;
-  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
-}
-
-SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
-    ISeqInStream *inStream, UInt32 keepWindowSize,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  p-&gt;inStream = inStream;
-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-}
-
-static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
-{
-  p-&gt;seqBufInStream.funcTable.Read = MyRead;
-  p-&gt;seqBufInStream.data = src;
-  p-&gt;seqBufInStream.rem = srcLen;
-}
-
-SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  LzmaEnc_SetInputBuf(p, src, srcLen);
-  p-&gt;inStream = &amp;p-&gt;seqBufInStream.funcTable;
-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-}
-
-void LzmaEnc_Finish(CLzmaEncHandle pp)
-{
-  #ifdef COMPRESS_MF_MT
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  if (p-&gt;mtMode)
-    MatchFinderMt_ReleaseStream(&amp;p-&gt;matchFinderMt);
-  #endif
-}
-
-typedef struct _CSeqOutStreamBuf
-{
-  ISeqOutStream funcTable;
-  Byte *data;
-  SizeT rem;
-  Bool overflow;
-} CSeqOutStreamBuf;
-
-static size_t MyWrite(void *pp, const void *data, size_t size)
-{
-  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
-  if (p-&gt;rem &lt; size)
-  {
-    size = p-&gt;rem;
-    p-&gt;overflow = True;
-  }
-  memcpy(p-&gt;data, data, size);
-  p-&gt;rem -= size;
-  p-&gt;data += size;
-  return size;
-}
-
-
-UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
-{
-  const CLzmaEnc *p = (CLzmaEnc *)pp;
-  return p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj);
-}
-
-const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
-{
-  const CLzmaEnc *p = (CLzmaEnc *)pp;
-  return p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - p-&gt;additionalOffset;
-}
-
-SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
-    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  UInt64 nowPos64;
-  SRes res;
-  CSeqOutStreamBuf outStream;
-
-  outStream.funcTable.Write = MyWrite;
-  outStream.data = dest;
-  outStream.rem = *destLen;
-  outStream.overflow = False;
-
-  p-&gt;writeEndMark = False;
-  p-&gt;finished = False;
-  p-&gt;result = SZ_OK;
-
-  if (reInit)
-    LzmaEnc_Init(p);
-  LzmaEnc_InitPrices(p);
-  nowPos64 = p-&gt;nowPos64;
-  RangeEnc_Init(&amp;p-&gt;rc);
-  p-&gt;rc.outStream = &amp;outStream.funcTable;
-
-  res = LzmaEnc_CodeOneBlock(pp, True, desiredPackSize, *unpackSize);
-  
-  *unpackSize = (UInt32)(p-&gt;nowPos64 - nowPos64);
-  *destLen -= outStream.rem;
-  if (outStream.overflow)
-    return SZ_ERROR_OUTPUT_EOF;
-
-  return res;
-}
-
-SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  SRes res = SZ_OK;
-
-  #ifdef COMPRESS_MF_MT
-  Byte allocaDummy[0x300];
-  int i = 0;
-  for (i = 0; i &lt; 16; i++)
-    allocaDummy[i] = (Byte)i;
-  #endif
-
-  RINOK(LzmaEnc_Prepare(pp, inStream, outStream, alloc, allocBig));
-
-  for (;;)
-  {
-    res = LzmaEnc_CodeOneBlock(pp, False, 0, 0);
-    if (res != SZ_OK || p-&gt;finished != 0)
-      break;
-    if (progress != 0)
-    {
-      res = progress-&gt;Progress(progress, p-&gt;nowPos64, RangeEnc_GetProcessed(&amp;p-&gt;rc));
-      if (res != SZ_OK)
-      {
-        res = SZ_ERROR_PROGRESS;
-        break;
-      }
-    }
-  }
-  LzmaEnc_Finish(pp);
-  return res;
-}
-
-SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  int i;
-  UInt32 dictSize = p-&gt;dictSize;
-  if (*size &lt; LZMA_PROPS_SIZE)
-    return SZ_ERROR_PARAM;
-  *size = LZMA_PROPS_SIZE;
-  props[0] = (Byte)((p-&gt;pb * 5 + p-&gt;lp) * 9 + p-&gt;lc);
-
-  for (i = 11; i &lt;= 30; i++)
-  {
-    if (dictSize &lt;= ((UInt32)2 &lt;&lt; i))
-    {
-      dictSize = (2 &lt;&lt; i);
-      break;
-    }
-    if (dictSize &lt;= ((UInt32)3 &lt;&lt; i))
-    {
-      dictSize = (3 &lt;&lt; i);
-      break;
-    }
-  }
-
-  for (i = 0; i &lt; 4; i++)
-    props[1 + i] = (Byte)(dictSize &gt;&gt; (8 * i));
-  return SZ_OK;
-}
-
-SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  SRes res;
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-
-  CSeqOutStreamBuf outStream;
-
-  LzmaEnc_SetInputBuf(p, src, srcLen);
-
-  outStream.funcTable.Write = MyWrite;
-  outStream.data = dest;
-  outStream.rem = *destLen;
-  outStream.overflow = False;
-
-  p-&gt;writeEndMark = writeEndMark;
-  res = LzmaEnc_Encode(pp, &amp;outStream.funcTable, &amp;p-&gt;seqBufInStream.funcTable,
-      progress, alloc, allocBig);
-
-  *destLen -= outStream.rem;
-  if (outStream.overflow)
-    return SZ_ERROR_OUTPUT_EOF;
-  return res;
-}
-
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
-  SRes res;
-  if (p == 0)
-    return SZ_ERROR_MEM;
-
-  res = LzmaEnc_SetProps(p, props);
-  if (res == SZ_OK)
-  {
-    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
-    if (res == SZ_OK)
-      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
-          writeEndMark, progress, alloc, allocBig);
-  }
-
-  LzmaEnc_Destroy(p, alloc, allocBig);
-  return res;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,2275 @@
+/* LzmaEnc.c -- LZMA Encoder
+2008-08-17
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzmaEnc.h for license options */
+
+#include &lt;string.h&gt;
+
+/* #define SHOW_STAT */
+/* #define SHOW_STAT2 */
+
+#if defined(SHOW_STAT) || defined(SHOW_STAT2)
+#include &lt;stdio.h&gt;
+#endif
+
+#include &quot;LzmaEnc.h&quot;
+
+#include &quot;LzFind.h&quot;
+#ifdef COMPRESS_MF_MT
+#include &quot;LzFindMt.h&quot;
+#endif
+
+#ifdef SHOW_STAT
+static int ttt = 0;
+#endif
+
+#define kBlockSizeMax ((1 &lt;&lt; LZMA_NUM_BLOCK_SIZE_BITS) - 1)
+
+#define kBlockSize (9 &lt;&lt; 10)
+#define kUnpackBlockSize (1 &lt;&lt; 18)
+#define kMatchArraySize (1 &lt;&lt; 21)
+#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
+
+#define kNumMaxDirectBits (31)
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+#define kProbInitValue (kBitModelTotal &gt;&gt; 1)
+
+#define kNumMoveReducingBits 4
+#define kNumBitPriceShiftBits 4
+#define kBitPrice (1 &lt;&lt; kNumBitPriceShiftBits)
+
+void LzmaEncProps_Init(CLzmaEncProps *p)
+{
+  p-&gt;level = 5;
+  p-&gt;dictSize = p-&gt;mc = 0;
+  p-&gt;lc = p-&gt;lp = p-&gt;pb = p-&gt;algo = p-&gt;fb = p-&gt;btMode = p-&gt;numHashBytes = p-&gt;numThreads = -1;
+  p-&gt;writeEndMark = 0;
+}
+
+void LzmaEncProps_Normalize(CLzmaEncProps *p)
+{
+  int level = p-&gt;level;
+  if (level &lt; 0) level = 5;
+  p-&gt;level = level;
+  if (p-&gt;dictSize == 0) p-&gt;dictSize = (level &lt;= 5 ? (1 &lt;&lt; (level * 2 + 14)) : (level == 6 ? (1 &lt;&lt; 25) : (1 &lt;&lt; 26)));
+  if (p-&gt;lc &lt; 0) p-&gt;lc = 3;
+  if (p-&gt;lp &lt; 0) p-&gt;lp = 0;
+  if (p-&gt;pb &lt; 0) p-&gt;pb = 2;
+  if (p-&gt;algo &lt; 0) p-&gt;algo = (level &lt; 5 ? 0 : 1);
+  if (p-&gt;fb &lt; 0) p-&gt;fb = (level &lt; 7 ? 32 : 64);
+  if (p-&gt;btMode &lt; 0) p-&gt;btMode = (p-&gt;algo == 0 ? 0 : 1);
+  if (p-&gt;numHashBytes &lt; 0) p-&gt;numHashBytes = 4;
+  if (p-&gt;mc == 0)  p-&gt;mc = (16 + (p-&gt;fb &gt;&gt; 1)) &gt;&gt; (p-&gt;btMode ? 0 : 1);
+  if (p-&gt;numThreads &lt; 0) p-&gt;numThreads = ((p-&gt;btMode &amp;&amp; p-&gt;algo) ? 2 : 1);
+}
+
+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
+{
+  CLzmaEncProps props = *props2;
+  LzmaEncProps_Normalize(&amp;props);
+  return props.dictSize;
+}
+
+/* #define LZMA_LOG_BSR */
+/* Define it for Intel's CPU */
+
+
+#ifdef LZMA_LOG_BSR
+
+#define kDicLogSizeMaxCompress 30
+
+#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&amp;i, (pos)); res = (i + i) + ((pos &gt;&gt; (i - 1)) &amp; 1); }
+
+UInt32 GetPosSlot1(UInt32 pos)
+{
+  UInt32 res;
+  BSR2_RET(pos, res);
+  return res;
+}
+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
+#define GetPosSlot(pos, res) { if (pos &lt; 2) res = pos; else BSR2_RET(pos, res); }
+
+#else
+
+#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
+#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
+
+void LzmaEnc_FastPosInit(Byte *g_FastPos)
+{
+  int c = 2, slotFast;
+  g_FastPos[0] = 0;
+  g_FastPos[1] = 1;
+  
+  for (slotFast = 2; slotFast &lt; kNumLogBits * 2; slotFast++)
+  {
+    UInt32 k = (1 &lt;&lt; ((slotFast &gt;&gt; 1) - 1));
+    UInt32 j;
+    for (j = 0; j &lt; k; j++, c++)
+      g_FastPos[c] = (Byte)slotFast;
+  }
+}
+
+#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) &amp; \
+  (0 - (((((UInt32)1 &lt;&lt; (kNumLogBits + 6)) - 1) - pos) &gt;&gt; 31))); \
+  res = p-&gt;g_FastPos[pos &gt;&gt; i] + (i * 2); }
+/*
+#define BSR2_RET(pos, res) { res = (pos &lt; (1 &lt;&lt; (kNumLogBits + 6))) ? \
+  p-&gt;g_FastPos[pos &gt;&gt; 6] + 12 : \
+  p-&gt;g_FastPos[pos &gt;&gt; (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
+*/
+
+#define GetPosSlot1(pos) p-&gt;g_FastPos[pos]
+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
+#define GetPosSlot(pos, res) { if (pos &lt; kNumFullDistances) res = p-&gt;g_FastPos[pos]; else BSR2_RET(pos, res); }
+
+#endif
+
+
+#define LZMA_NUM_REPS 4
+
+typedef unsigned CState;
+
+typedef struct _COptimal
+{
+  UInt32 price;
+
+  CState state;
+  int prev1IsChar;
+  int prev2;
+
+  UInt32 posPrev2;
+  UInt32 backPrev2;
+
+  UInt32 posPrev;
+  UInt32 backPrev;
+  UInt32 backs[LZMA_NUM_REPS];
+} COptimal;
+
+#define kNumOpts (1 &lt;&lt; 12)
+
+#define kNumLenToPosStates 4
+#define kNumPosSlotBits 6
+#define kDicLogSizeMin 0
+#define kDicLogSizeMax 32
+#define kDistTableSizeMax (kDicLogSizeMax * 2)
+
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
+#define kAlignMask (kAlignTableSize - 1)
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
+
+#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex / 2))
+
+#ifdef _LZMA_PROB32
+#define CLzmaProb UInt32
+#else
+#define CLzmaProb UInt16
+#endif
+
+#define LZMA_PB_MAX 4
+#define LZMA_LC_MAX 8
+#define LZMA_LP_MAX 4
+
+#define LZMA_NUM_PB_STATES_MAX (1 &lt;&lt; LZMA_PB_MAX)
+
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
+
+#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
+
+#define LZMA_MATCH_LEN_MIN 2
+#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
+
+#define kNumStates 12
+
+typedef struct
+{
+  CLzmaProb choice;
+  CLzmaProb choice2;
+  CLzmaProb low[LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumLowBits];
+  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumMidBits];
+  CLzmaProb high[kLenNumHighSymbols];
+} CLenEnc;
+
+typedef struct
+{
+  CLenEnc p;
+  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
+  UInt32 tableSize;
+  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
+} CLenPriceEnc;
+
+typedef struct _CRangeEnc
+{
+  UInt32 range;
+  Byte cache;
+  UInt64 low;
+  UInt64 cacheSize;
+  Byte *buf;
+  Byte *bufLim;
+  Byte *bufBase;
+  ISeqOutStream *outStream;
+  UInt64 processed;
+  SRes res;
+} CRangeEnc;
+
+typedef struct _CSeqInStreamBuf
+{
+  ISeqInStream funcTable;
+  const Byte *data;
+  SizeT rem;
+} CSeqInStreamBuf;
+
+static SRes MyRead(void *pp, void *data, size_t *size)
+{
+  size_t curSize = *size;
+  CSeqInStreamBuf *p = (CSeqInStreamBuf *)pp;
+  if (p-&gt;rem &lt; curSize)
+    curSize = p-&gt;rem;
+  memcpy(data, p-&gt;data, curSize);
+  p-&gt;rem -= curSize;
+  p-&gt;data += curSize;
+  *size = curSize;
+  return SZ_OK;
+}
+
+typedef struct
+{
+  CLzmaProb *litProbs;
+
+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
+  CLzmaProb isRep[kNumStates];
+  CLzmaProb isRepG0[kNumStates];
+  CLzmaProb isRepG1[kNumStates];
+  CLzmaProb isRepG2[kNumStates];
+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
+
+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 &lt;&lt; kNumPosSlotBits];
+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
+  CLzmaProb posAlignEncoder[1 &lt;&lt; kNumAlignBits];
+  
+  CLenPriceEnc lenEnc;
+  CLenPriceEnc repLenEnc;
+
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 state;
+} CSaveState;
+
+typedef struct _CLzmaEnc
+{
+  IMatchFinder matchFinder;
+  void *matchFinderObj;
+
+  #ifdef COMPRESS_MF_MT
+  Bool mtMode;
+  CMatchFinderMt matchFinderMt;
+  #endif
+
+  CMatchFinder matchFinderBase;
+
+  #ifdef COMPRESS_MF_MT
+  Byte pad[128];
+  #endif
+  
+  UInt32 optimumEndIndex;
+  UInt32 optimumCurrentIndex;
+
+  UInt32 longestMatchLength;
+  UInt32 numPairs;
+  UInt32 numAvail;
+  COptimal opt[kNumOpts];
+  
+  #ifndef LZMA_LOG_BSR
+  Byte g_FastPos[1 &lt;&lt; kNumLogBits];
+  #endif
+
+  UInt32 ProbPrices[kBitModelTotal &gt;&gt; kNumMoveReducingBits];
+  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
+  UInt32 numFastBytes;
+  UInt32 additionalOffset;
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 state;
+
+  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
+  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
+  UInt32 alignPrices[kAlignTableSize];
+  UInt32 alignPriceCount;
+
+  UInt32 distTableSize;
+
+  unsigned lc, lp, pb;
+  unsigned lpMask, pbMask;
+
+  CLzmaProb *litProbs;
+
+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
+  CLzmaProb isRep[kNumStates];
+  CLzmaProb isRepG0[kNumStates];
+  CLzmaProb isRepG1[kNumStates];
+  CLzmaProb isRepG2[kNumStates];
+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
+
+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 &lt;&lt; kNumPosSlotBits];
+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
+  CLzmaProb posAlignEncoder[1 &lt;&lt; kNumAlignBits];
+  
+  CLenPriceEnc lenEnc;
+  CLenPriceEnc repLenEnc;
+
+  unsigned lclp;
+
+  Bool fastMode;
+  
+  CRangeEnc rc;
+
+  Bool writeEndMark;
+  UInt64 nowPos64;
+  UInt32 matchPriceCount;
+  Bool finished;
+  Bool multiThread;
+
+  SRes result;
+  UInt32 dictSize;
+  UInt32 matchFinderCycles;
+
+  ISeqInStream *inStream;
+  CSeqInStreamBuf seqBufInStream;
+
+  CSaveState saveState;
+} CLzmaEnc;
+
+void LzmaEnc_SaveState(CLzmaEncHandle pp)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  CSaveState *dest = &amp;p-&gt;saveState;
+  int i;
+  dest-&gt;lenEnc = p-&gt;lenEnc;
+  dest-&gt;repLenEnc = p-&gt;repLenEnc;
+  dest-&gt;state = p-&gt;state;
+
+  for (i = 0; i &lt; kNumStates; i++)
+  {
+    memcpy(dest-&gt;isMatch[i], p-&gt;isMatch[i], sizeof(p-&gt;isMatch[i]));
+    memcpy(dest-&gt;isRep0Long[i], p-&gt;isRep0Long[i], sizeof(p-&gt;isRep0Long[i]));
+  }
+  for (i = 0; i &lt; kNumLenToPosStates; i++)
+    memcpy(dest-&gt;posSlotEncoder[i], p-&gt;posSlotEncoder[i], sizeof(p-&gt;posSlotEncoder[i]));
+  memcpy(dest-&gt;isRep, p-&gt;isRep, sizeof(p-&gt;isRep));
+  memcpy(dest-&gt;isRepG0, p-&gt;isRepG0, sizeof(p-&gt;isRepG0));
+  memcpy(dest-&gt;isRepG1, p-&gt;isRepG1, sizeof(p-&gt;isRepG1));
+  memcpy(dest-&gt;isRepG2, p-&gt;isRepG2, sizeof(p-&gt;isRepG2));
+  memcpy(dest-&gt;posEncoders, p-&gt;posEncoders, sizeof(p-&gt;posEncoders));
+  memcpy(dest-&gt;posAlignEncoder, p-&gt;posAlignEncoder, sizeof(p-&gt;posAlignEncoder));
+  memcpy(dest-&gt;reps, p-&gt;reps, sizeof(p-&gt;reps));
+  memcpy(dest-&gt;litProbs, p-&gt;litProbs, (0x300 &lt;&lt; p-&gt;lclp) * sizeof(CLzmaProb));
+}
+
+void LzmaEnc_RestoreState(CLzmaEncHandle pp)
+{
+  CLzmaEnc *dest = (CLzmaEnc *)pp;
+  const CSaveState *p = &amp;dest-&gt;saveState;
+  int i;
+  dest-&gt;lenEnc = p-&gt;lenEnc;
+  dest-&gt;repLenEnc = p-&gt;repLenEnc;
+  dest-&gt;state = p-&gt;state;
+
+  for (i = 0; i &lt; kNumStates; i++)
+  {
+    memcpy(dest-&gt;isMatch[i], p-&gt;isMatch[i], sizeof(p-&gt;isMatch[i]));
+    memcpy(dest-&gt;isRep0Long[i], p-&gt;isRep0Long[i], sizeof(p-&gt;isRep0Long[i]));
+  }
+  for (i = 0; i &lt; kNumLenToPosStates; i++)
+    memcpy(dest-&gt;posSlotEncoder[i], p-&gt;posSlotEncoder[i], sizeof(p-&gt;posSlotEncoder[i]));
+  memcpy(dest-&gt;isRep, p-&gt;isRep, sizeof(p-&gt;isRep));
+  memcpy(dest-&gt;isRepG0, p-&gt;isRepG0, sizeof(p-&gt;isRepG0));
+  memcpy(dest-&gt;isRepG1, p-&gt;isRepG1, sizeof(p-&gt;isRepG1));
+  memcpy(dest-&gt;isRepG2, p-&gt;isRepG2, sizeof(p-&gt;isRepG2));
+  memcpy(dest-&gt;posEncoders, p-&gt;posEncoders, sizeof(p-&gt;posEncoders));
+  memcpy(dest-&gt;posAlignEncoder, p-&gt;posAlignEncoder, sizeof(p-&gt;posAlignEncoder));
+  memcpy(dest-&gt;reps, p-&gt;reps, sizeof(p-&gt;reps));
+  memcpy(dest-&gt;litProbs, p-&gt;litProbs, (0x300 &lt;&lt; dest-&gt;lclp) * sizeof(CLzmaProb));
+}
+
+SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  CLzmaEncProps props = *props2;
+  LzmaEncProps_Normalize(&amp;props);
+
+  if (props.lc &gt; LZMA_LC_MAX || props.lp &gt; LZMA_LP_MAX || props.pb &gt; LZMA_PB_MAX ||
+      props.dictSize &gt; (1 &lt;&lt; kDicLogSizeMaxCompress) || props.dictSize &gt; (1 &lt;&lt; 30))
+    return SZ_ERROR_PARAM;
+  p-&gt;dictSize = props.dictSize;
+  p-&gt;matchFinderCycles = props.mc;
+  {
+    unsigned fb = props.fb;
+    if (fb &lt; 5)
+      fb = 5;
+    if (fb &gt; LZMA_MATCH_LEN_MAX)
+      fb = LZMA_MATCH_LEN_MAX;
+    p-&gt;numFastBytes = fb;
+  }
+  p-&gt;lc = props.lc;
+  p-&gt;lp = props.lp;
+  p-&gt;pb = props.pb;
+  p-&gt;fastMode = (props.algo == 0);
+  p-&gt;matchFinderBase.btMode = props.btMode;
+  {
+    UInt32 numHashBytes = 4;
+    if (props.btMode)
+    {
+      if (props.numHashBytes &lt; 2)
+        numHashBytes = 2;
+      else if (props.numHashBytes &lt; 4)
+        numHashBytes = props.numHashBytes;
+    }
+    p-&gt;matchFinderBase.numHashBytes = numHashBytes;
+  }
+
+  p-&gt;matchFinderBase.cutValue = props.mc;
+
+  p-&gt;writeEndMark = props.writeEndMark;
+
+  #ifdef COMPRESS_MF_MT
+  /*
+  if (newMultiThread != _multiThread)
+  {
+    ReleaseMatchFinder();
+    _multiThread = newMultiThread;
+  }
+  */
+  p-&gt;multiThread = (props.numThreads &gt; 1);
+  #endif
+
+  return SZ_OK;
+}
+
+static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
+static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
+static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
+static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
+
+#define IsCharState(s) ((s) &lt; 7)
+
+#define GetLenToPosState(len) (((len) &lt; kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
+
+#define kInfinityPrice (1 &lt;&lt; 30)
+
+static void RangeEnc_Construct(CRangeEnc *p)
+{
+  p-&gt;outStream = 0;
+  p-&gt;bufBase = 0;
+}
+
+#define RangeEnc_GetProcessed(p) ((p)-&gt;processed + ((p)-&gt;buf - (p)-&gt;bufBase) + (p)-&gt;cacheSize)
+
+#define RC_BUF_SIZE (1 &lt;&lt; 16)
+static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
+{
+  if (p-&gt;bufBase == 0)
+  {
+    p-&gt;bufBase = (Byte *)alloc-&gt;Alloc(alloc, RC_BUF_SIZE);
+    if (p-&gt;bufBase == 0)
+      return 0;
+    p-&gt;bufLim = p-&gt;bufBase + RC_BUF_SIZE;
+  }
+  return 1;
+}
+
+static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;bufBase);
+  p-&gt;bufBase = 0;
+}
+
+static void RangeEnc_Init(CRangeEnc *p)
+{
+  /* Stream.Init(); */
+  p-&gt;low = 0;
+  p-&gt;range = 0xFFFFFFFF;
+  p-&gt;cacheSize = 1;
+  p-&gt;cache = 0;
+
+  p-&gt;buf = p-&gt;bufBase;
+
+  p-&gt;processed = 0;
+  p-&gt;res = SZ_OK;
+}
+
+static void RangeEnc_FlushStream(CRangeEnc *p)
+{
+  size_t num;
+  if (p-&gt;res != SZ_OK)
+    return;
+  num = p-&gt;buf - p-&gt;bufBase;
+  if (num != p-&gt;outStream-&gt;Write(p-&gt;outStream, p-&gt;bufBase, num))
+    p-&gt;res = SZ_ERROR_WRITE;
+  p-&gt;processed += num;
+  p-&gt;buf = p-&gt;bufBase;
+}
+
+static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
+{
+  if ((UInt32)p-&gt;low &lt; (UInt32)0xFF000000 || (int)(p-&gt;low &gt;&gt; 32) != 0)
+  {
+    Byte temp = p-&gt;cache;
+    do
+    {
+      Byte *buf = p-&gt;buf;
+      *buf++ = (Byte)(temp + (Byte)(p-&gt;low &gt;&gt; 32));
+      p-&gt;buf = buf;
+      if (buf == p-&gt;bufLim)
+        RangeEnc_FlushStream(p);
+      temp = 0xFF;
+    }
+    while (--p-&gt;cacheSize != 0);
+    p-&gt;cache = (Byte)((UInt32)p-&gt;low &gt;&gt; 24);
+  }
+  p-&gt;cacheSize++;
+  p-&gt;low = (UInt32)p-&gt;low &lt;&lt; 8;
+}
+
+static void RangeEnc_FlushData(CRangeEnc *p)
+{
+  int i;
+  for (i = 0; i &lt; 5; i++)
+    RangeEnc_ShiftLow(p);
+}
+
+static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
+{
+  do
+  {
+    p-&gt;range &gt;&gt;= 1;
+    p-&gt;low += p-&gt;range &amp; (0 - ((value &gt;&gt; --numBits) &amp; 1));
+    if (p-&gt;range &lt; kTopValue)
+    {
+      p-&gt;range &lt;&lt;= 8;
+      RangeEnc_ShiftLow(p);
+    }
+  }
+  while (numBits != 0);
+}
+
+static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
+{
+  UInt32 ttt = *prob;
+  UInt32 newBound = (p-&gt;range &gt;&gt; kNumBitModelTotalBits) * ttt;
+  if (symbol == 0)
+  {
+    p-&gt;range = newBound;
+    ttt += (kBitModelTotal - ttt) &gt;&gt; kNumMoveBits;
+  }
+  else
+  {
+    p-&gt;low += newBound;
+    p-&gt;range -= newBound;
+    ttt -= ttt &gt;&gt; kNumMoveBits;
+  }
+  *prob = (CLzmaProb)ttt;
+  if (p-&gt;range &lt; kTopValue)
+  {
+    p-&gt;range &lt;&lt;= 8;
+    RangeEnc_ShiftLow(p);
+  }
+}
+
+static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
+{
+  symbol |= 0x100;
+  do
+  {
+    RangeEnc_EncodeBit(p, probs + (symbol &gt;&gt; 8), (symbol &gt;&gt; 7) &amp; 1);
+    symbol &lt;&lt;= 1;
+  }
+  while (symbol &lt; 0x10000);
+}
+
+static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
+{
+  UInt32 offs = 0x100;
+  symbol |= 0x100;
+  do
+  {
+    matchByte &lt;&lt;= 1;
+    RangeEnc_EncodeBit(p, probs + (offs + (matchByte &amp; offs) + (symbol &gt;&gt; 8)), (symbol &gt;&gt; 7) &amp; 1);
+    symbol &lt;&lt;= 1;
+    offs &amp;= ~(matchByte ^ symbol);
+  }
+  while (symbol &lt; 0x10000);
+}
+
+void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
+{
+  UInt32 i;
+  for (i = (1 &lt;&lt; kNumMoveReducingBits) / 2; i &lt; kBitModelTotal; i += (1 &lt;&lt; kNumMoveReducingBits))
+  {
+    const int kCyclesBits = kNumBitPriceShiftBits;
+    UInt32 w = i;
+    UInt32 bitCount = 0;
+    int j;
+    for (j = 0; j &lt; kCyclesBits; j++)
+    {
+      w = w * w;
+      bitCount &lt;&lt;= 1;
+      while (w &gt;= ((UInt32)1 &lt;&lt; 16))
+      {
+        w &gt;&gt;= 1;
+        bitCount++;
+      }
+    }
+    ProbPrices[i &gt;&gt; kNumMoveReducingBits] = ((kNumBitModelTotalBits &lt;&lt; kCyclesBits) - 15 - bitCount);
+  }
+}
+
+
+#define GET_PRICE(prob, symbol) \
+  p-&gt;ProbPrices[((prob) ^ (((-(int)(symbol))) &amp; (kBitModelTotal - 1))) &gt;&gt; kNumMoveReducingBits];
+
+#define GET_PRICEa(prob, symbol) \
+  ProbPrices[((prob) ^ ((-((int)(symbol))) &amp; (kBitModelTotal - 1))) &gt;&gt; kNumMoveReducingBits];
+
+#define GET_PRICE_0(prob) p-&gt;ProbPrices[(prob) &gt;&gt; kNumMoveReducingBits]
+#define GET_PRICE_1(prob) p-&gt;ProbPrices[((prob) ^ (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits]
+
+#define GET_PRICE_0a(prob) ProbPrices[(prob) &gt;&gt; kNumMoveReducingBits]
+#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits]
+
+static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  symbol |= 0x100;
+  do
+  {
+    price += GET_PRICEa(probs[symbol &gt;&gt; 8], (symbol &gt;&gt; 7) &amp; 1);
+    symbol &lt;&lt;= 1;
+  }
+  while (symbol &lt; 0x10000);
+  return price;
+}
+
+static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  UInt32 offs = 0x100;
+  symbol |= 0x100;
+  do
+  {
+    matchByte &lt;&lt;= 1;
+    price += GET_PRICEa(probs[offs + (matchByte &amp; offs) + (symbol &gt;&gt; 8)], (symbol &gt;&gt; 7) &amp; 1);
+    symbol &lt;&lt;= 1;
+    offs &amp;= ~(matchByte ^ symbol);
+  }
+  while (symbol &lt; 0x10000);
+  return price;
+}
+
+
+static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+{
+  UInt32 m = 1;
+  int i;
+  for (i = numBitLevels; i != 0;)
+  {
+    UInt32 bit;
+    i--;
+    bit = (symbol &gt;&gt; i) &amp; 1;
+    RangeEnc_EncodeBit(rc, probs + m, bit);
+    m = (m &lt;&lt; 1) | bit;
+  }
+}
+
+static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+{
+  UInt32 m = 1;
+  int i;
+  for (i = 0; i &lt; numBitLevels; i++)
+  {
+    UInt32 bit = symbol &amp; 1;
+    RangeEnc_EncodeBit(rc, probs + m, bit);
+    m = (m &lt;&lt; 1) | bit;
+    symbol &gt;&gt;= 1;
+  }
+}
+
+static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  symbol |= (1 &lt;&lt; numBitLevels);
+  while (symbol != 1)
+  {
+    price += GET_PRICEa(probs[symbol &gt;&gt; 1], symbol &amp; 1);
+    symbol &gt;&gt;= 1;
+  }
+  return price;
+}
+
+static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  UInt32 m = 1;
+  int i;
+  for (i = numBitLevels; i != 0; i--)
+  {
+    UInt32 bit = symbol &amp; 1;
+    symbol &gt;&gt;= 1;
+    price += GET_PRICEa(probs[m], bit);
+    m = (m &lt;&lt; 1) | bit;
+  }
+  return price;
+}
+
+
+static void LenEnc_Init(CLenEnc *p)
+{
+  unsigned i;
+  p-&gt;choice = p-&gt;choice2 = kProbInitValue;
+  for (i = 0; i &lt; (LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumLowBits); i++)
+    p-&gt;low[i] = kProbInitValue;
+  for (i = 0; i &lt; (LZMA_NUM_PB_STATES_MAX &lt;&lt; kLenNumMidBits); i++)
+    p-&gt;mid[i] = kProbInitValue;
+  for (i = 0; i &lt; kLenNumHighSymbols; i++)
+    p-&gt;high[i] = kProbInitValue;
+}
+
+static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
+{
+  if (symbol &lt; kLenNumLowSymbols)
+  {
+    RangeEnc_EncodeBit(rc, &amp;p-&gt;choice, 0);
+    RcTree_Encode(rc, p-&gt;low + (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, symbol);
+  }
+  else
+  {
+    RangeEnc_EncodeBit(rc, &amp;p-&gt;choice, 1);
+    if (symbol &lt; kLenNumLowSymbols + kLenNumMidSymbols)
+    {
+      RangeEnc_EncodeBit(rc, &amp;p-&gt;choice2, 0);
+      RcTree_Encode(rc, p-&gt;mid + (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
+    }
+    else
+    {
+      RangeEnc_EncodeBit(rc, &amp;p-&gt;choice2, 1);
+      RcTree_Encode(rc, p-&gt;high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
+    }
+  }
+}
+
+static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
+{
+  UInt32 a0 = GET_PRICE_0a(p-&gt;choice);
+  UInt32 a1 = GET_PRICE_1a(p-&gt;choice);
+  UInt32 b0 = a1 + GET_PRICE_0a(p-&gt;choice2);
+  UInt32 b1 = a1 + GET_PRICE_1a(p-&gt;choice2);
+  UInt32 i = 0;
+  for (i = 0; i &lt; kLenNumLowSymbols; i++)
+  {
+    if (i &gt;= numSymbols)
+      return;
+    prices[i] = a0 + RcTree_GetPrice(p-&gt;low + (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
+  }
+  for (; i &lt; kLenNumLowSymbols + kLenNumMidSymbols; i++)
+  {
+    if (i &gt;= numSymbols)
+      return;
+    prices[i] = b0 + RcTree_GetPrice(p-&gt;mid + (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
+  }
+  for (; i &lt; numSymbols; i++)
+    prices[i] = b1 + RcTree_GetPrice(p-&gt;high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
+}
+
+static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
+{
+  LenEnc_SetPrices(&amp;p-&gt;p, posState, p-&gt;tableSize, p-&gt;prices[posState], ProbPrices);
+  p-&gt;counters[posState] = p-&gt;tableSize;
+}
+
+static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
+{
+  UInt32 posState;
+  for (posState = 0; posState &lt; numPosStates; posState++)
+    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
+}
+
+static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
+{
+  LenEnc_Encode(&amp;p-&gt;p, rc, symbol, posState);
+  if (updatePrice)
+    if (--p-&gt;counters[posState] == 0)
+      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
+}
+
+
+
+
+static void MovePos(CLzmaEnc *p, UInt32 num)
+{
+  #ifdef SHOW_STAT
+  ttt += num;
+  printf(&quot;\n MovePos %d&quot;, num);
+  #endif
+  if (num != 0)
+  {
+    p-&gt;additionalOffset += num;
+    p-&gt;matchFinder.Skip(p-&gt;matchFinderObj, num);
+  }
+}
+
+static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
+{
+  UInt32 lenRes = 0, numPairs;
+  p-&gt;numAvail = p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj);
+  numPairs = p-&gt;matchFinder.GetMatches(p-&gt;matchFinderObj, p-&gt;matches);
+  #ifdef SHOW_STAT
+  printf(&quot;\n i = %d numPairs = %d    &quot;, ttt, numPairs / 2);
+  ttt++;
+  {
+    UInt32 i;
+    for (i = 0; i &lt; numPairs; i += 2)
+      printf(&quot;%2d %6d   | &quot;, p-&gt;matches[i], p-&gt;matches[i + 1]);
+  }
+  #endif
+  if (numPairs &gt; 0)
+  {
+    lenRes = p-&gt;matches[numPairs - 2];
+    if (lenRes == p-&gt;numFastBytes)
+    {
+      const Byte *pby = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+      UInt32 distance = p-&gt;matches[numPairs - 1] + 1;
+      UInt32 numAvail = p-&gt;numAvail;
+      if (numAvail &gt; LZMA_MATCH_LEN_MAX)
+        numAvail = LZMA_MATCH_LEN_MAX;
+      {
+        const Byte *pby2 = pby - distance;
+        for (; lenRes &lt; numAvail &amp;&amp; pby[lenRes] == pby2[lenRes]; lenRes++);
+      }
+    }
+  }
+  p-&gt;additionalOffset++;
+  *numDistancePairsRes = numPairs;
+  return lenRes;
+}
+
+
+#define MakeAsChar(p) (p)-&gt;backPrev = (UInt32)(-1); (p)-&gt;prev1IsChar = False;
+#define MakeAsShortRep(p) (p)-&gt;backPrev = 0; (p)-&gt;prev1IsChar = False;
+#define IsShortRep(p) ((p)-&gt;backPrev == 0)
+
+static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
+{
+  return
+    GET_PRICE_0(p-&gt;isRepG0[state]) +
+    GET_PRICE_0(p-&gt;isRep0Long[state][posState]);
+}
+
+static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
+{
+  UInt32 price;
+  if (repIndex == 0)
+  {
+    price = GET_PRICE_0(p-&gt;isRepG0[state]);
+    price += GET_PRICE_1(p-&gt;isRep0Long[state][posState]);
+  }
+  else
+  {
+    price = GET_PRICE_1(p-&gt;isRepG0[state]);
+    if (repIndex == 1)
+      price += GET_PRICE_0(p-&gt;isRepG1[state]);
+    else
+    {
+      price += GET_PRICE_1(p-&gt;isRepG1[state]);
+      price += GET_PRICE(p-&gt;isRepG2[state], repIndex - 2);
+    }
+  }
+  return price;
+}
+
+static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
+{
+  return p-&gt;repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
+    GetPureRepPrice(p, repIndex, state, posState);
+}
+
+static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
+{
+  UInt32 posMem = p-&gt;opt[cur].posPrev;
+  UInt32 backMem = p-&gt;opt[cur].backPrev;
+  p-&gt;optimumEndIndex = cur;
+  do
+  {
+    if (p-&gt;opt[cur].prev1IsChar)
+    {
+      MakeAsChar(&amp;p-&gt;opt[posMem])
+      p-&gt;opt[posMem].posPrev = posMem - 1;
+      if (p-&gt;opt[cur].prev2)
+      {
+        p-&gt;opt[posMem - 1].prev1IsChar = False;
+        p-&gt;opt[posMem - 1].posPrev = p-&gt;opt[cur].posPrev2;
+        p-&gt;opt[posMem - 1].backPrev = p-&gt;opt[cur].backPrev2;
+      }
+    }
+    {
+      UInt32 posPrev = posMem;
+      UInt32 backCur = backMem;
+      
+      backMem = p-&gt;opt[posPrev].backPrev;
+      posMem = p-&gt;opt[posPrev].posPrev;
+      
+      p-&gt;opt[posPrev].backPrev = backCur;
+      p-&gt;opt[posPrev].posPrev = cur;
+      cur = posPrev;
+    }
+  }
+  while (cur != 0);
+  *backRes = p-&gt;opt[0].backPrev;
+  p-&gt;optimumCurrentIndex  = p-&gt;opt[0].posPrev;
+  return p-&gt;optimumCurrentIndex;
+}
+
+#define LIT_PROBS(pos, prevByte) (p-&gt;litProbs + ((((pos) &amp; p-&gt;lpMask) &lt;&lt; p-&gt;lc) + ((prevByte) &gt;&gt; (8 - p-&gt;lc))) * 0x300)
+
+static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
+{
+  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
+  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
+  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
+  UInt32 *matches;
+  const Byte *data;
+  Byte curByte, matchByte;
+  if (p-&gt;optimumEndIndex != p-&gt;optimumCurrentIndex)
+  {
+    const COptimal *opt = &amp;p-&gt;opt[p-&gt;optimumCurrentIndex];
+    UInt32 lenRes = opt-&gt;posPrev - p-&gt;optimumCurrentIndex;
+    *backRes = opt-&gt;backPrev;
+    p-&gt;optimumCurrentIndex = opt-&gt;posPrev;
+    return lenRes;
+  }
+  p-&gt;optimumCurrentIndex = p-&gt;optimumEndIndex = 0;
+  
+  if (p-&gt;additionalOffset == 0)
+    mainLen = ReadMatchDistances(p, &amp;numPairs);
+  else
+  {
+    mainLen = p-&gt;longestMatchLength;
+    numPairs = p-&gt;numPairs;
+  }
+
+  numAvail = p-&gt;numAvail;
+  if (numAvail &lt; 2)
+  {
+    *backRes = (UInt32)(-1);
+    return 1;
+  }
+  if (numAvail &gt; LZMA_MATCH_LEN_MAX)
+    numAvail = LZMA_MATCH_LEN_MAX;
+
+  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+  repMaxIndex = 0;
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+  {
+    UInt32 lenTest;
+    const Byte *data2;
+    reps[i] = p-&gt;reps[i];
+    data2 = data - (reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+    {
+      repLens[i] = 0;
+      continue;
+    }
+    for (lenTest = 2; lenTest &lt; numAvail &amp;&amp; data[lenTest] == data2[lenTest]; lenTest++);
+    repLens[i] = lenTest;
+    if (lenTest &gt; repLens[repMaxIndex])
+      repMaxIndex = i;
+  }
+  if (repLens[repMaxIndex] &gt;= p-&gt;numFastBytes)
+  {
+    UInt32 lenRes;
+    *backRes = repMaxIndex;
+    lenRes = repLens[repMaxIndex];
+    MovePos(p, lenRes - 1);
+    return lenRes;
+  }
+
+  matches = p-&gt;matches;
+  if (mainLen &gt;= p-&gt;numFastBytes)
+  {
+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
+    MovePos(p, mainLen - 1);
+    return mainLen;
+  }
+  curByte = *data;
+  matchByte = *(data - (reps[0] + 1));
+
+  if (mainLen &lt; 2 &amp;&amp; curByte != matchByte &amp;&amp; repLens[repMaxIndex] &lt; 2)
+  {
+    *backRes = (UInt32)-1;
+    return 1;
+  }
+
+  p-&gt;opt[0].state = (CState)p-&gt;state;
+
+  posState = (position &amp; p-&gt;pbMask);
+
+  {
+    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+    p-&gt;opt[1].price = GET_PRICE_0(p-&gt;isMatch[p-&gt;state][posState]) +
+        (!IsCharState(p-&gt;state) ?
+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p-&gt;ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p-&gt;ProbPrices));
+  }
+
+  MakeAsChar(&amp;p-&gt;opt[1]);
+
+  matchPrice = GET_PRICE_1(p-&gt;isMatch[p-&gt;state][posState]);
+  repMatchPrice = matchPrice + GET_PRICE_1(p-&gt;isRep[p-&gt;state]);
+
+  if (matchByte == curByte)
+  {
+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p-&gt;state, posState);
+    if (shortRepPrice &lt; p-&gt;opt[1].price)
+    {
+      p-&gt;opt[1].price = shortRepPrice;
+      MakeAsShortRep(&amp;p-&gt;opt[1]);
+    }
+  }
+  lenEnd = ((mainLen &gt;= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
+
+  if (lenEnd &lt; 2)
+  {
+    *backRes = p-&gt;opt[1].backPrev;
+    return 1;
+  }
+
+  p-&gt;opt[1].posPrev = 0;
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+    p-&gt;opt[0].backs[i] = reps[i];
+
+  len = lenEnd;
+  do
+    p-&gt;opt[len--].price = kInfinityPrice;
+  while (len &gt;= 2);
+
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+  {
+    UInt32 repLen = repLens[i];
+    UInt32 price;
+    if (repLen &lt; 2)
+      continue;
+    price = repMatchPrice + GetPureRepPrice(p, i, p-&gt;state, posState);
+    do
+    {
+      UInt32 curAndLenPrice = price + p-&gt;repLenEnc.prices[posState][repLen - 2];
+      COptimal *opt = &amp;p-&gt;opt[repLen];
+      if (curAndLenPrice &lt; opt-&gt;price)
+      {
+        opt-&gt;price = curAndLenPrice;
+        opt-&gt;posPrev = 0;
+        opt-&gt;backPrev = i;
+        opt-&gt;prev1IsChar = False;
+      }
+    }
+    while (--repLen &gt;= 2);
+  }
+
+  normalMatchPrice = matchPrice + GET_PRICE_0(p-&gt;isRep[p-&gt;state]);
+
+  len = ((repLens[0] &gt;= 2) ? repLens[0] + 1 : 2);
+  if (len &lt;= mainLen)
+  {
+    UInt32 offs = 0;
+    while (len &gt; matches[offs])
+      offs += 2;
+    for (; ; len++)
+    {
+      COptimal *opt;
+      UInt32 distance = matches[offs + 1];
+
+      UInt32 curAndLenPrice = normalMatchPrice + p-&gt;lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
+      UInt32 lenToPosState = GetLenToPosState(len);
+      if (distance &lt; kNumFullDistances)
+        curAndLenPrice += p-&gt;distancesPrices[lenToPosState][distance];
+      else
+      {
+        UInt32 slot;
+        GetPosSlot2(distance, slot);
+        curAndLenPrice += p-&gt;alignPrices[distance &amp; kAlignMask] + p-&gt;posSlotPrices[lenToPosState][slot];
+      }
+      opt = &amp;p-&gt;opt[len];
+      if (curAndLenPrice &lt; opt-&gt;price)
+      {
+        opt-&gt;price = curAndLenPrice;
+        opt-&gt;posPrev = 0;
+        opt-&gt;backPrev = distance + LZMA_NUM_REPS;
+        opt-&gt;prev1IsChar = False;
+      }
+      if (len == matches[offs])
+      {
+        offs += 2;
+        if (offs == numPairs)
+          break;
+      }
+    }
+  }
+
+  cur = 0;
+
+    #ifdef SHOW_STAT2
+    if (position &gt;= 0)
+    {
+      unsigned i;
+      printf(&quot;\n pos = %4X&quot;, position);
+      for (i = cur; i &lt;= lenEnd; i++)
+      printf(&quot;\nprice[%4X] = %d&quot;, position - cur + i, p-&gt;opt[i].price);
+    }
+    #endif
+
+  for (;;)
+  {
+    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
+    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
+    Bool nextIsChar;
+    Byte curByte, matchByte;
+    const Byte *data;
+    COptimal *curOpt;
+    COptimal *nextOpt;
+
+    cur++;
+    if (cur == lenEnd)
+      return Backward(p, backRes, cur);
+
+    newLen = ReadMatchDistances(p, &amp;numPairs);
+    if (newLen &gt;= p-&gt;numFastBytes)
+    {
+      p-&gt;numPairs = numPairs;
+      p-&gt;longestMatchLength = newLen;
+      return Backward(p, backRes, cur);
+    }
+    position++;
+    curOpt = &amp;p-&gt;opt[cur];
+    posPrev = curOpt-&gt;posPrev;
+    if (curOpt-&gt;prev1IsChar)
+    {
+      posPrev--;
+      if (curOpt-&gt;prev2)
+      {
+        state = p-&gt;opt[curOpt-&gt;posPrev2].state;
+        if (curOpt-&gt;backPrev2 &lt; LZMA_NUM_REPS)
+          state = kRepNextStates[state];
+        else
+          state = kMatchNextStates[state];
+      }
+      else
+        state = p-&gt;opt[posPrev].state;
+      state = kLiteralNextStates[state];
+    }
+    else
+      state = p-&gt;opt[posPrev].state;
+    if (posPrev == cur - 1)
+    {
+      if (IsShortRep(curOpt))
+        state = kShortRepNextStates[state];
+      else
+        state = kLiteralNextStates[state];
+    }
+    else
+    {
+      UInt32 pos;
+      const COptimal *prevOpt;
+      if (curOpt-&gt;prev1IsChar &amp;&amp; curOpt-&gt;prev2)
+      {
+        posPrev = curOpt-&gt;posPrev2;
+        pos = curOpt-&gt;backPrev2;
+        state = kRepNextStates[state];
+      }
+      else
+      {
+        pos = curOpt-&gt;backPrev;
+        if (pos &lt; LZMA_NUM_REPS)
+          state = kRepNextStates[state];
+        else
+          state = kMatchNextStates[state];
+      }
+      prevOpt = &amp;p-&gt;opt[posPrev];
+      if (pos &lt; LZMA_NUM_REPS)
+      {
+        UInt32 i;
+        reps[0] = prevOpt-&gt;backs[pos];
+        for (i = 1; i &lt;= pos; i++)
+          reps[i] = prevOpt-&gt;backs[i - 1];
+        for (; i &lt; LZMA_NUM_REPS; i++)
+          reps[i] = prevOpt-&gt;backs[i];
+      }
+      else
+      {
+        UInt32 i;
+        reps[0] = (pos - LZMA_NUM_REPS);
+        for (i = 1; i &lt; LZMA_NUM_REPS; i++)
+          reps[i] = prevOpt-&gt;backs[i - 1];
+      }
+    }
+    curOpt-&gt;state = (CState)state;
+
+    curOpt-&gt;backs[0] = reps[0];
+    curOpt-&gt;backs[1] = reps[1];
+    curOpt-&gt;backs[2] = reps[2];
+    curOpt-&gt;backs[3] = reps[3];
+
+    curPrice = curOpt-&gt;price;
+    nextIsChar = False;
+    data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+    curByte = *data;
+    matchByte = *(data - (reps[0] + 1));
+
+    posState = (position &amp; p-&gt;pbMask);
+
+    curAnd1Price = curPrice + GET_PRICE_0(p-&gt;isMatch[state][posState]);
+    {
+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+      curAnd1Price +=
+        (!IsCharState(state) ?
+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p-&gt;ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p-&gt;ProbPrices));
+    }
+
+    nextOpt = &amp;p-&gt;opt[cur + 1];
+
+    if (curAnd1Price &lt; nextOpt-&gt;price)
+    {
+      nextOpt-&gt;price = curAnd1Price;
+      nextOpt-&gt;posPrev = cur;
+      MakeAsChar(nextOpt);
+      nextIsChar = True;
+    }
+
+    matchPrice = curPrice + GET_PRICE_1(p-&gt;isMatch[state][posState]);
+    repMatchPrice = matchPrice + GET_PRICE_1(p-&gt;isRep[state]);
+    
+    if (matchByte == curByte &amp;&amp; !(nextOpt-&gt;posPrev &lt; cur &amp;&amp; nextOpt-&gt;backPrev == 0))
+    {
+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
+      if (shortRepPrice &lt;= nextOpt-&gt;price)
+      {
+        nextOpt-&gt;price = shortRepPrice;
+        nextOpt-&gt;posPrev = cur;
+        MakeAsShortRep(nextOpt);
+        nextIsChar = True;
+      }
+    }
+    numAvailFull = p-&gt;numAvail;
+    {
+      UInt32 temp = kNumOpts - 1 - cur;
+      if (temp &lt; numAvailFull)
+        numAvailFull = temp;
+    }
+
+    if (numAvailFull &lt; 2)
+      continue;
+    numAvail = (numAvailFull &lt;= p-&gt;numFastBytes ? numAvailFull : p-&gt;numFastBytes);
+
+    if (!nextIsChar &amp;&amp; matchByte != curByte) /* speed optimization */
+    {
+      /* try Literal + rep0 */
+      UInt32 temp;
+      UInt32 lenTest2;
+      const Byte *data2 = data - (reps[0] + 1);
+      UInt32 limit = p-&gt;numFastBytes + 1;
+      if (limit &gt; numAvailFull)
+        limit = numAvailFull;
+
+      for (temp = 1; temp &lt; limit &amp;&amp; data[temp] == data2[temp]; temp++);
+      lenTest2 = temp - 1;
+      if (lenTest2 &gt;= 2)
+      {
+        UInt32 state2 = kLiteralNextStates[state];
+        UInt32 posStateNext = (position + 1) &amp; p-&gt;pbMask;
+        UInt32 nextRepMatchPrice = curAnd1Price +
+            GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
+            GET_PRICE_1(p-&gt;isRep[state2]);
+        /* for (; lenTest2 &gt;= 2; lenTest2--) */
+        {
+          UInt32 curAndLenPrice;
+          COptimal *opt;
+          UInt32 offset = cur + 1 + lenTest2;
+          while (lenEnd &lt; offset)
+            p-&gt;opt[++lenEnd].price = kInfinityPrice;
+          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+          opt = &amp;p-&gt;opt[offset];
+          if (curAndLenPrice &lt; opt-&gt;price)
+          {
+            opt-&gt;price = curAndLenPrice;
+            opt-&gt;posPrev = cur + 1;
+            opt-&gt;backPrev = 0;
+            opt-&gt;prev1IsChar = True;
+            opt-&gt;prev2 = False;
+          }
+        }
+      }
+    }
+    
+    startLen = 2; /* speed optimization */
+    {
+    UInt32 repIndex;
+    for (repIndex = 0; repIndex &lt; LZMA_NUM_REPS; repIndex++)
+    {
+      UInt32 lenTest;
+      UInt32 lenTestTemp;
+      UInt32 price;
+      const Byte *data2 = data - (reps[repIndex] + 1);
+      if (data[0] != data2[0] || data[1] != data2[1])
+        continue;
+      for (lenTest = 2; lenTest &lt; numAvail &amp;&amp; data[lenTest] == data2[lenTest]; lenTest++);
+      while (lenEnd &lt; cur + lenTest)
+        p-&gt;opt[++lenEnd].price = kInfinityPrice;
+      lenTestTemp = lenTest;
+      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
+      do
+      {
+        UInt32 curAndLenPrice = price + p-&gt;repLenEnc.prices[posState][lenTest - 2];
+        COptimal *opt = &amp;p-&gt;opt[cur + lenTest];
+        if (curAndLenPrice &lt; opt-&gt;price)
+        {
+          opt-&gt;price = curAndLenPrice;
+          opt-&gt;posPrev = cur;
+          opt-&gt;backPrev = repIndex;
+          opt-&gt;prev1IsChar = False;
+        }
+      }
+      while (--lenTest &gt;= 2);
+      lenTest = lenTestTemp;
+      
+      if (repIndex == 0)
+        startLen = lenTest + 1;
+        
+      /* if (_maxMode) */
+        {
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = lenTest2 + p-&gt;numFastBytes;
+          UInt32 nextRepMatchPrice;
+          if (limit &gt; numAvailFull)
+            limit = numAvailFull;
+          for (; lenTest2 &lt; limit &amp;&amp; data[lenTest2] == data2[lenTest2]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 &gt;= 2)
+          {
+            UInt32 state2 = kRepNextStates[state];
+            UInt32 posStateNext = (position + lenTest) &amp; p-&gt;pbMask;
+            UInt32 curAndLenCharPrice =
+                price + p-&gt;repLenEnc.prices[posState][lenTest - 2] +
+                GET_PRICE_0(p-&gt;isMatch[state2][posStateNext]) +
+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                    data[lenTest], data2[lenTest], p-&gt;ProbPrices);
+            state2 = kLiteralNextStates[state2];
+            posStateNext = (position + lenTest + 1) &amp; p-&gt;pbMask;
+            nextRepMatchPrice = curAndLenCharPrice +
+                GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
+                GET_PRICE_1(p-&gt;isRep[state2]);
+            
+            /* for (; lenTest2 &gt;= 2; lenTest2--) */
+            {
+              UInt32 curAndLenPrice;
+              COptimal *opt;
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              while (lenEnd &lt; offset)
+                p-&gt;opt[++lenEnd].price = kInfinityPrice;
+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              opt = &amp;p-&gt;opt[offset];
+              if (curAndLenPrice &lt; opt-&gt;price)
+              {
+                opt-&gt;price = curAndLenPrice;
+                opt-&gt;posPrev = cur + lenTest + 1;
+                opt-&gt;backPrev = 0;
+                opt-&gt;prev1IsChar = True;
+                opt-&gt;prev2 = True;
+                opt-&gt;posPrev2 = cur;
+                opt-&gt;backPrev2 = repIndex;
+              }
+            }
+          }
+        }
+    }
+    }
+    /* for (UInt32 lenTest = 2; lenTest &lt;= newLen; lenTest++) */
+    if (newLen &gt; numAvail)
+    {
+      newLen = numAvail;
+      for (numPairs = 0; newLen &gt; matches[numPairs]; numPairs += 2);
+      matches[numPairs] = newLen;
+      numPairs += 2;
+    }
+    if (newLen &gt;= startLen)
+    {
+      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p-&gt;isRep[state]);
+      UInt32 offs, curBack, posSlot;
+      UInt32 lenTest;
+      while (lenEnd &lt; cur + newLen)
+        p-&gt;opt[++lenEnd].price = kInfinityPrice;
+
+      offs = 0;
+      while (startLen &gt; matches[offs])
+        offs += 2;
+      curBack = matches[offs + 1];
+      GetPosSlot2(curBack, posSlot);
+      for (lenTest = /*2*/ startLen; ; lenTest++)
+      {
+        UInt32 curAndLenPrice = normalMatchPrice + p-&gt;lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
+        UInt32 lenToPosState = GetLenToPosState(lenTest);
+        COptimal *opt;
+        if (curBack &lt; kNumFullDistances)
+          curAndLenPrice += p-&gt;distancesPrices[lenToPosState][curBack];
+        else
+          curAndLenPrice += p-&gt;posSlotPrices[lenToPosState][posSlot] + p-&gt;alignPrices[curBack &amp; kAlignMask];
+        
+        opt = &amp;p-&gt;opt[cur + lenTest];
+        if (curAndLenPrice &lt; opt-&gt;price)
+        {
+          opt-&gt;price = curAndLenPrice;
+          opt-&gt;posPrev = cur;
+          opt-&gt;backPrev = curBack + LZMA_NUM_REPS;
+          opt-&gt;prev1IsChar = False;
+        }
+
+        if (/*_maxMode &amp;&amp; */lenTest == matches[offs])
+        {
+          /* Try Match + Literal + Rep0 */
+          const Byte *data2 = data - (curBack + 1);
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = lenTest2 + p-&gt;numFastBytes;
+          UInt32 nextRepMatchPrice;
+          if (limit &gt; numAvailFull)
+            limit = numAvailFull;
+          for (; lenTest2 &lt; limit &amp;&amp; data[lenTest2] == data2[lenTest2]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 &gt;= 2)
+          {
+            UInt32 state2 = kMatchNextStates[state];
+            UInt32 posStateNext = (position + lenTest) &amp; p-&gt;pbMask;
+            UInt32 curAndLenCharPrice = curAndLenPrice +
+                GET_PRICE_0(p-&gt;isMatch[state2][posStateNext]) +
+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                    data[lenTest], data2[lenTest], p-&gt;ProbPrices);
+            state2 = kLiteralNextStates[state2];
+            posStateNext = (posStateNext + 1) &amp; p-&gt;pbMask;
+            nextRepMatchPrice = curAndLenCharPrice +
+                GET_PRICE_1(p-&gt;isMatch[state2][posStateNext]) +
+                GET_PRICE_1(p-&gt;isRep[state2]);
+            
+            /* for (; lenTest2 &gt;= 2; lenTest2--) */
+            {
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              UInt32 curAndLenPrice;
+              COptimal *opt;
+              while (lenEnd &lt; offset)
+                p-&gt;opt[++lenEnd].price = kInfinityPrice;
+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              opt = &amp;p-&gt;opt[offset];
+              if (curAndLenPrice &lt; opt-&gt;price)
+              {
+                opt-&gt;price = curAndLenPrice;
+                opt-&gt;posPrev = cur + lenTest + 1;
+                opt-&gt;backPrev = 0;
+                opt-&gt;prev1IsChar = True;
+                opt-&gt;prev2 = True;
+                opt-&gt;posPrev2 = cur;
+                opt-&gt;backPrev2 = curBack + LZMA_NUM_REPS;
+              }
+            }
+          }
+          offs += 2;
+          if (offs == numPairs)
+            break;
+          curBack = matches[offs + 1];
+          if (curBack &gt;= kNumFullDistances)
+            GetPosSlot2(curBack, posSlot);
+        }
+      }
+    }
+  }
+}
+
+#define ChangePair(smallDist, bigDist) (((bigDist) &gt;&gt; 7) &gt; (smallDist))
+
+static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
+{
+  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
+  const Byte *data;
+  const UInt32 *matches;
+
+  if (p-&gt;additionalOffset == 0)
+    mainLen = ReadMatchDistances(p, &amp;numPairs);
+  else
+  {
+    mainLen = p-&gt;longestMatchLength;
+    numPairs = p-&gt;numPairs;
+  }
+
+  numAvail = p-&gt;numAvail;
+  *backRes = (UInt32)-1;
+  if (numAvail &lt; 2)
+    return 1;
+  if (numAvail &gt; LZMA_MATCH_LEN_MAX)
+    numAvail = LZMA_MATCH_LEN_MAX;
+  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+
+  repLen = repIndex = 0;
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+  {
+    UInt32 len;
+    const Byte *data2 = data - (p-&gt;reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+      continue;
+    for (len = 2; len &lt; numAvail &amp;&amp; data[len] == data2[len]; len++);
+    if (len &gt;= p-&gt;numFastBytes)
+    {
+      *backRes = i;
+      MovePos(p, len - 1);
+      return len;
+    }
+    if (len &gt; repLen)
+    {
+      repIndex = i;
+      repLen = len;
+    }
+  }
+
+  matches = p-&gt;matches;
+  if (mainLen &gt;= p-&gt;numFastBytes)
+  {
+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
+    MovePos(p, mainLen - 1);
+    return mainLen;
+  }
+
+  mainDist = 0; /* for GCC */
+  if (mainLen &gt;= 2)
+  {
+    mainDist = matches[numPairs - 1];
+    while (numPairs &gt; 2 &amp;&amp; mainLen == matches[numPairs - 4] + 1)
+    {
+      if (!ChangePair(matches[numPairs - 3], mainDist))
+        break;
+      numPairs -= 2;
+      mainLen = matches[numPairs - 2];
+      mainDist = matches[numPairs - 1];
+    }
+    if (mainLen == 2 &amp;&amp; mainDist &gt;= 0x80)
+      mainLen = 1;
+  }
+
+  if (repLen &gt;= 2 &amp;&amp; (
+        (repLen + 1 &gt;= mainLen) ||
+        (repLen + 2 &gt;= mainLen &amp;&amp; mainDist &gt;= (1 &lt;&lt; 9)) ||
+        (repLen + 3 &gt;= mainLen &amp;&amp; mainDist &gt;= (1 &lt;&lt; 15))))
+  {
+    *backRes = repIndex;
+    MovePos(p, repLen - 1);
+    return repLen;
+  }
+  
+  if (mainLen &lt; 2 || numAvail &lt;= 2)
+    return 1;
+
+  p-&gt;longestMatchLength = ReadMatchDistances(p, &amp;p-&gt;numPairs);
+  if (p-&gt;longestMatchLength &gt;= 2)
+  {
+    UInt32 newDistance = matches[p-&gt;numPairs - 1];
+    if ((p-&gt;longestMatchLength &gt;= mainLen &amp;&amp; newDistance &lt; mainDist) ||
+        (p-&gt;longestMatchLength == mainLen + 1 &amp;&amp; !ChangePair(mainDist, newDistance)) ||
+        (p-&gt;longestMatchLength &gt; mainLen + 1) ||
+        (p-&gt;longestMatchLength + 1 &gt;= mainLen &amp;&amp; mainLen &gt;= 3 &amp;&amp; ChangePair(newDistance, mainDist)))
+      return 1;
+  }
+  
+  data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - 1;
+  for (i = 0; i &lt; LZMA_NUM_REPS; i++)
+  {
+    UInt32 len, limit;
+    const Byte *data2 = data - (p-&gt;reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+      continue;
+    limit = mainLen - 1;
+    for (len = 2; len &lt; limit &amp;&amp; data[len] == data2[len]; len++);
+    if (len &gt;= limit)
+      return 1;
+  }
+  *backRes = mainDist + LZMA_NUM_REPS;
+  MovePos(p, mainLen - 2);
+  return mainLen;
+}
+
+static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
+{
+  UInt32 len;
+  RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 1);
+  RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 0);
+  p-&gt;state = kMatchNextStates[p-&gt;state];
+  len = LZMA_MATCH_LEN_MIN;
+  LenEnc_Encode2(&amp;p-&gt;lenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
+  RcTree_Encode(&amp;p-&gt;rc, p-&gt;posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 &lt;&lt; kNumPosSlotBits) - 1);
+  RangeEnc_EncodeDirectBits(&amp;p-&gt;rc, (((UInt32)1 &lt;&lt; 30) - 1) &gt;&gt; kNumAlignBits, 30 - kNumAlignBits);
+  RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posAlignEncoder, kNumAlignBits, kAlignMask);
+}
+
+static SRes CheckErrors(CLzmaEnc *p)
+{
+  if (p-&gt;result != SZ_OK)
+    return p-&gt;result;
+  if (p-&gt;rc.res != SZ_OK)
+    p-&gt;result = SZ_ERROR_WRITE;
+  if (p-&gt;matchFinderBase.result != SZ_OK)
+    p-&gt;result = SZ_ERROR_READ;
+  if (p-&gt;result != SZ_OK)
+    p-&gt;finished = True;
+  return p-&gt;result;
+}
+
+static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
+{
+  /* ReleaseMFStream(); */
+  p-&gt;finished = True;
+  if (p-&gt;writeEndMark)
+    WriteEndMarker(p, nowPos &amp; p-&gt;pbMask);
+  RangeEnc_FlushData(&amp;p-&gt;rc);
+  RangeEnc_FlushStream(&amp;p-&gt;rc);
+  return CheckErrors(p);
+}
+
+static void FillAlignPrices(CLzmaEnc *p)
+{
+  UInt32 i;
+  for (i = 0; i &lt; kAlignTableSize; i++)
+    p-&gt;alignPrices[i] = RcTree_ReverseGetPrice(p-&gt;posAlignEncoder, kNumAlignBits, i, p-&gt;ProbPrices);
+  p-&gt;alignPriceCount = 0;
+}
+
+static void FillDistancesPrices(CLzmaEnc *p)
+{
+  UInt32 tempPrices[kNumFullDistances];
+  UInt32 i, lenToPosState;
+  for (i = kStartPosModelIndex; i &lt; kNumFullDistances; i++)
+  {
+    UInt32 posSlot = GetPosSlot1(i);
+    UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
+    UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+    tempPrices[i] = RcTree_ReverseGetPrice(p-&gt;posEncoders + base - posSlot - 1, footerBits, i - base, p-&gt;ProbPrices);
+  }
+
+  for (lenToPosState = 0; lenToPosState &lt; kNumLenToPosStates; lenToPosState++)
+  {
+    UInt32 posSlot;
+    const CLzmaProb *encoder = p-&gt;posSlotEncoder[lenToPosState];
+    UInt32 *posSlotPrices = p-&gt;posSlotPrices[lenToPosState];
+    for (posSlot = 0; posSlot &lt; p-&gt;distTableSize; posSlot++)
+      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p-&gt;ProbPrices);
+    for (posSlot = kEndPosModelIndex; posSlot &lt; p-&gt;distTableSize; posSlot++)
+      posSlotPrices[posSlot] += ((((posSlot &gt;&gt; 1) - 1) - kNumAlignBits) &lt;&lt; kNumBitPriceShiftBits);
+
+    {
+      UInt32 *distancesPrices = p-&gt;distancesPrices[lenToPosState];
+      UInt32 i;
+      for (i = 0; i &lt; kStartPosModelIndex; i++)
+        distancesPrices[i] = posSlotPrices[i];
+      for (; i &lt; kNumFullDistances; i++)
+        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
+    }
+  }
+  p-&gt;matchPriceCount = 0;
+}
+
+void LzmaEnc_Construct(CLzmaEnc *p)
+{
+  RangeEnc_Construct(&amp;p-&gt;rc);
+  MatchFinder_Construct(&amp;p-&gt;matchFinderBase);
+  #ifdef COMPRESS_MF_MT
+  MatchFinderMt_Construct(&amp;p-&gt;matchFinderMt);
+  p-&gt;matchFinderMt.MatchFinder = &amp;p-&gt;matchFinderBase;
+  #endif
+
+  {
+    CLzmaEncProps props;
+    LzmaEncProps_Init(&amp;props);
+    LzmaEnc_SetProps(p, &amp;props);
+  }
+
+  #ifndef LZMA_LOG_BSR
+  LzmaEnc_FastPosInit(p-&gt;g_FastPos);
+  #endif
+
+  LzmaEnc_InitPriceTables(p-&gt;ProbPrices);
+  p-&gt;litProbs = 0;
+  p-&gt;saveState.litProbs = 0;
+}
+
+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
+{
+  void *p;
+  p = alloc-&gt;Alloc(alloc, sizeof(CLzmaEnc));
+  if (p != 0)
+    LzmaEnc_Construct((CLzmaEnc *)p);
+  return p;
+}
+
+void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
+{
+  alloc-&gt;Free(alloc, p-&gt;litProbs);
+  alloc-&gt;Free(alloc, p-&gt;saveState.litProbs);
+  p-&gt;litProbs = 0;
+  p-&gt;saveState.litProbs = 0;
+}
+
+void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  #ifdef COMPRESS_MF_MT
+  MatchFinderMt_Destruct(&amp;p-&gt;matchFinderMt, allocBig);
+  #endif
+  MatchFinder_Free(&amp;p-&gt;matchFinderBase, allocBig);
+  LzmaEnc_FreeLits(p, alloc);
+  RangeEnc_Free(&amp;p-&gt;rc, alloc);
+}
+
+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
+  alloc-&gt;Free(alloc, p);
+}
+
+static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
+{
+  UInt32 nowPos32, startPos32;
+  if (p-&gt;inStream != 0)
+  {
+    p-&gt;matchFinderBase.stream = p-&gt;inStream;
+    p-&gt;matchFinder.Init(p-&gt;matchFinderObj);
+    p-&gt;inStream = 0;
+  }
+
+  if (p-&gt;finished)
+    return p-&gt;result;
+  RINOK(CheckErrors(p));
+
+  nowPos32 = (UInt32)p-&gt;nowPos64;
+  startPos32 = nowPos32;
+
+  if (p-&gt;nowPos64 == 0)
+  {
+    UInt32 numPairs;
+    Byte curByte;
+    if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) == 0)
+      return Flush(p, nowPos32);
+    ReadMatchDistances(p, &amp;numPairs);
+    RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][0], 0);
+    p-&gt;state = kLiteralNextStates[p-&gt;state];
+    curByte = p-&gt;matchFinder.GetIndexByte(p-&gt;matchFinderObj, 0 - p-&gt;additionalOffset);
+    LitEnc_Encode(&amp;p-&gt;rc, p-&gt;litProbs, curByte);
+    p-&gt;additionalOffset--;
+    nowPos32++;
+  }
+
+  if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) != 0)
+  for (;;)
+  {
+    UInt32 pos, len, posState;
+
+    if (p-&gt;fastMode)
+      len = GetOptimumFast(p, &amp;pos);
+    else
+      len = GetOptimum(p, nowPos32, &amp;pos);
+
+    #ifdef SHOW_STAT2
+    printf(&quot;\n pos = %4X,   len = %d   pos = %d&quot;, nowPos32, len, pos);
+    #endif
+
+    posState = nowPos32 &amp; p-&gt;pbMask;
+    if (len == 1 &amp;&amp; pos == (UInt32)-1)
+    {
+      Byte curByte;
+      CLzmaProb *probs;
+      const Byte *data;
+
+      RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 0);
+      data = p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - p-&gt;additionalOffset;
+      curByte = *data;
+      probs = LIT_PROBS(nowPos32, *(data - 1));
+      if (IsCharState(p-&gt;state))
+        LitEnc_Encode(&amp;p-&gt;rc, probs, curByte);
+      else
+        LitEnc_EncodeMatched(&amp;p-&gt;rc, probs, curByte, *(data - p-&gt;reps[0] - 1));
+      p-&gt;state = kLiteralNextStates[p-&gt;state];
+    }
+    else
+    {
+      RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isMatch[p-&gt;state][posState], 1);
+      if (pos &lt; LZMA_NUM_REPS)
+      {
+        RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 1);
+        if (pos == 0)
+        {
+          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG0[p-&gt;state], 0);
+          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep0Long[p-&gt;state][posState], ((len == 1) ? 0 : 1));
+        }
+        else
+        {
+          UInt32 distance = p-&gt;reps[pos];
+          RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG0[p-&gt;state], 1);
+          if (pos == 1)
+            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG1[p-&gt;state], 0);
+          else
+          {
+            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG1[p-&gt;state], 1);
+            RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRepG2[p-&gt;state], pos - 2);
+            if (pos == 3)
+              p-&gt;reps[3] = p-&gt;reps[2];
+            p-&gt;reps[2] = p-&gt;reps[1];
+          }
+          p-&gt;reps[1] = p-&gt;reps[0];
+          p-&gt;reps[0] = distance;
+        }
+        if (len == 1)
+          p-&gt;state = kShortRepNextStates[p-&gt;state];
+        else
+        {
+          LenEnc_Encode2(&amp;p-&gt;repLenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
+          p-&gt;state = kRepNextStates[p-&gt;state];
+        }
+      }
+      else
+      {
+        UInt32 posSlot;
+        RangeEnc_EncodeBit(&amp;p-&gt;rc, &amp;p-&gt;isRep[p-&gt;state], 0);
+        p-&gt;state = kMatchNextStates[p-&gt;state];
+        LenEnc_Encode2(&amp;p-&gt;lenEnc, &amp;p-&gt;rc, len - LZMA_MATCH_LEN_MIN, posState, !p-&gt;fastMode, p-&gt;ProbPrices);
+        pos -= LZMA_NUM_REPS;
+        GetPosSlot(pos, posSlot);
+        RcTree_Encode(&amp;p-&gt;rc, p-&gt;posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
+        
+        if (posSlot &gt;= kStartPosModelIndex)
+        {
+          UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
+          UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+          UInt32 posReduced = pos - base;
+
+          if (posSlot &lt; kEndPosModelIndex)
+            RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posEncoders + base - posSlot - 1, footerBits, posReduced);
+          else
+          {
+            RangeEnc_EncodeDirectBits(&amp;p-&gt;rc, posReduced &gt;&gt; kNumAlignBits, footerBits - kNumAlignBits);
+            RcTree_ReverseEncode(&amp;p-&gt;rc, p-&gt;posAlignEncoder, kNumAlignBits, posReduced &amp; kAlignMask);
+            p-&gt;alignPriceCount++;
+          }
+        }
+        p-&gt;reps[3] = p-&gt;reps[2];
+        p-&gt;reps[2] = p-&gt;reps[1];
+        p-&gt;reps[1] = p-&gt;reps[0];
+        p-&gt;reps[0] = pos;
+        p-&gt;matchPriceCount++;
+      }
+    }
+    p-&gt;additionalOffset -= len;
+    nowPos32 += len;
+    if (p-&gt;additionalOffset == 0)
+    {
+      UInt32 processed;
+      if (!p-&gt;fastMode)
+      {
+        if (p-&gt;matchPriceCount &gt;= (1 &lt;&lt; 7))
+          FillDistancesPrices(p);
+        if (p-&gt;alignPriceCount &gt;= kAlignTableSize)
+          FillAlignPrices(p);
+      }
+      if (p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj) == 0)
+        break;
+      processed = nowPos32 - startPos32;
+      if (useLimits)
+      {
+        if (processed + kNumOpts + 300 &gt;= maxUnpackSize ||
+            RangeEnc_GetProcessed(&amp;p-&gt;rc) + kNumOpts * 2 &gt;= maxPackSize)
+          break;
+      }
+      else if (processed &gt;= (1 &lt;&lt; 15))
+      {
+        p-&gt;nowPos64 += nowPos32 - startPos32;
+        return CheckErrors(p);
+      }
+    }
+  }
+  p-&gt;nowPos64 += nowPos32 - startPos32;
+  return Flush(p, nowPos32);
+}
+
+#define kBigHashDicLimit ((UInt32)1 &lt;&lt; 24)
+
+static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  UInt32 beforeSize = kNumOpts;
+  Bool btMode;
+  if (!RangeEnc_Alloc(&amp;p-&gt;rc, alloc))
+    return SZ_ERROR_MEM;
+  btMode = (p-&gt;matchFinderBase.btMode != 0);
+  #ifdef COMPRESS_MF_MT
+  p-&gt;mtMode = (p-&gt;multiThread &amp;&amp; !p-&gt;fastMode &amp;&amp; btMode);
+  #endif
+
+  {
+    unsigned lclp = p-&gt;lc + p-&gt;lp;
+    if (p-&gt;litProbs == 0 || p-&gt;saveState.litProbs == 0 || p-&gt;lclp != lclp)
+    {
+      LzmaEnc_FreeLits(p, alloc);
+      p-&gt;litProbs = (CLzmaProb *)alloc-&gt;Alloc(alloc, (0x300 &lt;&lt; lclp) * sizeof(CLzmaProb));
+      p-&gt;saveState.litProbs = (CLzmaProb *)alloc-&gt;Alloc(alloc, (0x300 &lt;&lt; lclp) * sizeof(CLzmaProb));
+      if (p-&gt;litProbs == 0 || p-&gt;saveState.litProbs == 0)
+      {
+        LzmaEnc_FreeLits(p, alloc);
+        return SZ_ERROR_MEM;
+      }
+      p-&gt;lclp = lclp;
+    }
+  }
+
+  p-&gt;matchFinderBase.bigHash = (p-&gt;dictSize &gt; kBigHashDicLimit);
+
+  if (beforeSize + p-&gt;dictSize &lt; keepWindowSize)
+    beforeSize = keepWindowSize - p-&gt;dictSize;
+
+  #ifdef COMPRESS_MF_MT
+  if (p-&gt;mtMode)
+  {
+    RINOK(MatchFinderMt_Create(&amp;p-&gt;matchFinderMt, p-&gt;dictSize, beforeSize, p-&gt;numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
+    p-&gt;matchFinderObj = &amp;p-&gt;matchFinderMt;
+    MatchFinderMt_CreateVTable(&amp;p-&gt;matchFinderMt, &amp;p-&gt;matchFinder);
+  }
+  else
+  #endif
+  {
+    if (!MatchFinder_Create(&amp;p-&gt;matchFinderBase, p-&gt;dictSize, beforeSize, p-&gt;numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
+      return SZ_ERROR_MEM;
+    p-&gt;matchFinderObj = &amp;p-&gt;matchFinderBase;
+    MatchFinder_CreateVTable(&amp;p-&gt;matchFinderBase, &amp;p-&gt;matchFinder);
+  }
+  return SZ_OK;
+}
+
+void LzmaEnc_Init(CLzmaEnc *p)
+{
+  UInt32 i;
+  p-&gt;state = 0;
+  for (i = 0 ; i &lt; LZMA_NUM_REPS; i++)
+    p-&gt;reps[i] = 0;
+
+  RangeEnc_Init(&amp;p-&gt;rc);
+
+
+  for (i = 0; i &lt; kNumStates; i++)
+  {
+    UInt32 j;
+    for (j = 0; j &lt; LZMA_NUM_PB_STATES_MAX; j++)
+    {
+      p-&gt;isMatch[i][j] = kProbInitValue;
+      p-&gt;isRep0Long[i][j] = kProbInitValue;
+    }
+    p-&gt;isRep[i] = kProbInitValue;
+    p-&gt;isRepG0[i] = kProbInitValue;
+    p-&gt;isRepG1[i] = kProbInitValue;
+    p-&gt;isRepG2[i] = kProbInitValue;
+  }
+
+  {
+    UInt32 num = 0x300 &lt;&lt; (p-&gt;lp + p-&gt;lc);
+    for (i = 0; i &lt; num; i++)
+      p-&gt;litProbs[i] = kProbInitValue;
+  }
+
+  {
+    for (i = 0; i &lt; kNumLenToPosStates; i++)
+    {
+      CLzmaProb *probs = p-&gt;posSlotEncoder[i];
+      UInt32 j;
+      for (j = 0; j &lt; (1 &lt;&lt; kNumPosSlotBits); j++)
+        probs[j] = kProbInitValue;
+    }
+  }
+  {
+    for (i = 0; i &lt; kNumFullDistances - kEndPosModelIndex; i++)
+      p-&gt;posEncoders[i] = kProbInitValue;
+  }
+
+  LenEnc_Init(&amp;p-&gt;lenEnc.p);
+  LenEnc_Init(&amp;p-&gt;repLenEnc.p);
+
+  for (i = 0; i &lt; (1 &lt;&lt; kNumAlignBits); i++)
+    p-&gt;posAlignEncoder[i] = kProbInitValue;
+
+  p-&gt;optimumEndIndex = 0;
+  p-&gt;optimumCurrentIndex = 0;
+  p-&gt;additionalOffset = 0;
+
+  p-&gt;pbMask = (1 &lt;&lt; p-&gt;pb) - 1;
+  p-&gt;lpMask = (1 &lt;&lt; p-&gt;lp) - 1;
+}
+
+void LzmaEnc_InitPrices(CLzmaEnc *p)
+{
+  if (!p-&gt;fastMode)
+  {
+    FillDistancesPrices(p);
+    FillAlignPrices(p);
+  }
+
+  p-&gt;lenEnc.tableSize =
+  p-&gt;repLenEnc.tableSize =
+      p-&gt;numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
+  LenPriceEnc_UpdateTables(&amp;p-&gt;lenEnc, 1 &lt;&lt; p-&gt;pb, p-&gt;ProbPrices);
+  LenPriceEnc_UpdateTables(&amp;p-&gt;repLenEnc, 1 &lt;&lt; p-&gt;pb, p-&gt;ProbPrices);
+}
+
+static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  UInt32 i;
+  for (i = 0; i &lt; (UInt32)kDicLogSizeMaxCompress; i++)
+    if (p-&gt;dictSize &lt;= ((UInt32)1 &lt;&lt; i))
+      break;
+  p-&gt;distTableSize = i * 2;
+
+  p-&gt;finished = False;
+  p-&gt;result = SZ_OK;
+  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
+  LzmaEnc_Init(p);
+  LzmaEnc_InitPrices(p);
+  p-&gt;nowPos64 = 0;
+  return SZ_OK;
+}
+
+static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqInStream *inStream, ISeqOutStream *outStream,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  p-&gt;inStream = inStream;
+  p-&gt;rc.outStream = outStream;
+  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
+}
+
+SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
+    ISeqInStream *inStream, UInt32 keepWindowSize,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  p-&gt;inStream = inStream;
+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+}
+
+static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
+{
+  p-&gt;seqBufInStream.funcTable.Read = MyRead;
+  p-&gt;seqBufInStream.data = src;
+  p-&gt;seqBufInStream.rem = srcLen;
+}
+
+SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
+    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  LzmaEnc_SetInputBuf(p, src, srcLen);
+  p-&gt;inStream = &amp;p-&gt;seqBufInStream.funcTable;
+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+}
+
+void LzmaEnc_Finish(CLzmaEncHandle pp)
+{
+  #ifdef COMPRESS_MF_MT
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  if (p-&gt;mtMode)
+    MatchFinderMt_ReleaseStream(&amp;p-&gt;matchFinderMt);
+  #endif
+}
+
+typedef struct _CSeqOutStreamBuf
+{
+  ISeqOutStream funcTable;
+  Byte *data;
+  SizeT rem;
+  Bool overflow;
+} CSeqOutStreamBuf;
+
+static size_t MyWrite(void *pp, const void *data, size_t size)
+{
+  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
+  if (p-&gt;rem &lt; size)
+  {
+    size = p-&gt;rem;
+    p-&gt;overflow = True;
+  }
+  memcpy(p-&gt;data, data, size);
+  p-&gt;rem -= size;
+  p-&gt;data += size;
+  return size;
+}
+
+
+UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
+{
+  const CLzmaEnc *p = (CLzmaEnc *)pp;
+  return p-&gt;matchFinder.GetNumAvailableBytes(p-&gt;matchFinderObj);
+}
+
+const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
+{
+  const CLzmaEnc *p = (CLzmaEnc *)pp;
+  return p-&gt;matchFinder.GetPointerToCurrentPos(p-&gt;matchFinderObj) - p-&gt;additionalOffset;
+}
+
+SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
+    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  UInt64 nowPos64;
+  SRes res;
+  CSeqOutStreamBuf outStream;
+
+  outStream.funcTable.Write = MyWrite;
+  outStream.data = dest;
+  outStream.rem = *destLen;
+  outStream.overflow = False;
+
+  p-&gt;writeEndMark = False;
+  p-&gt;finished = False;
+  p-&gt;result = SZ_OK;
+
+  if (reInit)
+    LzmaEnc_Init(p);
+  LzmaEnc_InitPrices(p);
+  nowPos64 = p-&gt;nowPos64;
+  RangeEnc_Init(&amp;p-&gt;rc);
+  p-&gt;rc.outStream = &amp;outStream.funcTable;
+
+  res = LzmaEnc_CodeOneBlock(pp, True, desiredPackSize, *unpackSize);
+  
+  *unpackSize = (UInt32)(p-&gt;nowPos64 - nowPos64);
+  *destLen -= outStream.rem;
+  if (outStream.overflow)
+    return SZ_ERROR_OUTPUT_EOF;
+
+  return res;
+}
+
+SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  SRes res = SZ_OK;
+
+  #ifdef COMPRESS_MF_MT
+  Byte allocaDummy[0x300];
+  int i = 0;
+  for (i = 0; i &lt; 16; i++)
+    allocaDummy[i] = (Byte)i;
+  #endif
+
+  RINOK(LzmaEnc_Prepare(pp, inStream, outStream, alloc, allocBig));
+
+  for (;;)
+  {
+    res = LzmaEnc_CodeOneBlock(pp, False, 0, 0);
+    if (res != SZ_OK || p-&gt;finished != 0)
+      break;
+    if (progress != 0)
+    {
+      res = progress-&gt;Progress(progress, p-&gt;nowPos64, RangeEnc_GetProcessed(&amp;p-&gt;rc));
+      if (res != SZ_OK)
+      {
+        res = SZ_ERROR_PROGRESS;
+        break;
+      }
+    }
+  }
+  LzmaEnc_Finish(pp);
+  return res;
+}
+
+SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  int i;
+  UInt32 dictSize = p-&gt;dictSize;
+  if (*size &lt; LZMA_PROPS_SIZE)
+    return SZ_ERROR_PARAM;
+  *size = LZMA_PROPS_SIZE;
+  props[0] = (Byte)((p-&gt;pb * 5 + p-&gt;lp) * 9 + p-&gt;lc);
+
+  for (i = 11; i &lt;= 30; i++)
+  {
+    if (dictSize &lt;= ((UInt32)2 &lt;&lt; i))
+    {
+      dictSize = (2 &lt;&lt; i);
+      break;
+    }
+    if (dictSize &lt;= ((UInt32)3 &lt;&lt; i))
+    {
+      dictSize = (3 &lt;&lt; i);
+      break;
+    }
+  }
+
+  for (i = 0; i &lt; 4; i++)
+    props[1 + i] = (Byte)(dictSize &gt;&gt; (8 * i));
+  return SZ_OK;
+}
+
+SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  SRes res;
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+
+  CSeqOutStreamBuf outStream;
+
+  LzmaEnc_SetInputBuf(p, src, srcLen);
+
+  outStream.funcTable.Write = MyWrite;
+  outStream.data = dest;
+  outStream.rem = *destLen;
+  outStream.overflow = False;
+
+  p-&gt;writeEndMark = writeEndMark;
+  res = LzmaEnc_Encode(pp, &amp;outStream.funcTable, &amp;p-&gt;seqBufInStream.funcTable,
+      progress, alloc, allocBig);
+
+  *destLen -= outStream.rem;
+  if (outStream.overflow)
+    return SZ_ERROR_OUTPUT_EOF;
+  return res;
+}
+
+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
+  SRes res;
+  if (p == 0)
+    return SZ_ERROR_MEM;
+
+  res = LzmaEnc_SetProps(p, props);
+  if (res == SZ_OK)
+  {
+    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
+    if (res == SZ_OK)
+      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
+          writeEndMark, progress, alloc, allocBig);
+  }
+
+  LzmaEnc_Destroy(p, alloc, allocBig);
+  return res;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,74 +0,0 @@
-/*  LzmaEnc.h -- LZMA Encoder
-2008-08-05
-Copyright (c) 1999-2008 Igor Pavlov
-Read LzFind.h for license options */
-
-#ifndef __LZMAENC_H
-#define __LZMAENC_H
-
-#include &quot;Types.h&quot;
-
-#define LZMA_PROPS_SIZE 5
-
-typedef struct _CLzmaEncProps
-{
-  int level;       /*  0 &lt;= level &lt;= 9 */
-  UInt32 dictSize; /* (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 27) for 32-bit version
-                      (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 30) for 64-bit version
-                       default = (1 &lt;&lt; 24) */
-  int lc;          /* 0 &lt;= lc &lt;= 8, default = 3 */
-  int lp;          /* 0 &lt;= lp &lt;= 4, default = 0 */
-  int pb;          /* 0 &lt;= pb &lt;= 4, default = 2 */
-  int algo;        /* 0 - fast, 1 - normal, default = 1 */
-  int fb;          /* 5 &lt;= fb &lt;= 273, default = 32 */
-  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
-  int numHashBytes; /* 2, 3 or 4, default = 4 */
-  UInt32 mc;        /* 1 &lt;= mc &lt;= (1 &lt;&lt; 30), default = 32 */
-  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
-  int numThreads;  /* 1 or 2, default = 2 */
-} CLzmaEncProps;
-
-void LzmaEncProps_Init(CLzmaEncProps *p);
-void LzmaEncProps_Normalize(CLzmaEncProps *p);
-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
-
-
-/* ---------- CLzmaEncHandle Interface ---------- */
-
-/* LzmaEnc_* functions can return the following exit codes:
-Returns:
-  SZ_OK           - OK
-  SZ_ERROR_MEM    - Memory allocation error
-  SZ_ERROR_PARAM  - Incorrect paramater in props
-  SZ_ERROR_WRITE  - Write callback error.
-  SZ_ERROR_PROGRESS - some break from progress callback
-  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
-*/
-
-typedef void * CLzmaEncHandle;
-
-CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
-void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
-SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
-SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-
-/* ---------- One Call Interface ---------- */
-
-/* LzmaEncode
-Return code:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaEnc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,74 @@
+/*  LzmaEnc.h -- LZMA Encoder
+2008-08-05
+Copyright (c) 1999-2008 Igor Pavlov
+Read LzFind.h for license options */
+
+#ifndef __LZMAENC_H
+#define __LZMAENC_H
+
+#include &quot;Types.h&quot;
+
+#define LZMA_PROPS_SIZE 5
+
+typedef struct _CLzmaEncProps
+{
+  int level;       /*  0 &lt;= level &lt;= 9 */
+  UInt32 dictSize; /* (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 27) for 32-bit version
+                      (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 30) for 64-bit version
+                       default = (1 &lt;&lt; 24) */
+  int lc;          /* 0 &lt;= lc &lt;= 8, default = 3 */
+  int lp;          /* 0 &lt;= lp &lt;= 4, default = 0 */
+  int pb;          /* 0 &lt;= pb &lt;= 4, default = 2 */
+  int algo;        /* 0 - fast, 1 - normal, default = 1 */
+  int fb;          /* 5 &lt;= fb &lt;= 273, default = 32 */
+  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
+  int numHashBytes; /* 2, 3 or 4, default = 4 */
+  UInt32 mc;        /* 1 &lt;= mc &lt;= (1 &lt;&lt; 30), default = 32 */
+  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
+  int numThreads;  /* 1 or 2, default = 2 */
+} CLzmaEncProps;
+
+void LzmaEncProps_Init(CLzmaEncProps *p);
+void LzmaEncProps_Normalize(CLzmaEncProps *p);
+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
+
+
+/* ---------- CLzmaEncHandle Interface ---------- */
+
+/* LzmaEnc_* functions can return the following exit codes:
+Returns:
+  SZ_OK           - OK
+  SZ_ERROR_MEM    - Memory allocation error
+  SZ_ERROR_PARAM  - Incorrect paramater in props
+  SZ_ERROR_WRITE  - Write callback error.
+  SZ_ERROR_PROGRESS - some break from progress callback
+  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
+*/
+
+typedef void * CLzmaEncHandle;
+
+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
+SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
+SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+/* ---------- One Call Interface ---------- */
+
+/* LzmaEncode
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,4 +0,0 @@
-EXPORTS
-  LzmaCompress
-  LzmaUncompress
-

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.def	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,4 @@
+EXPORTS
+  LzmaCompress
+  LzmaUncompress
+

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,178 +0,0 @@
-# Microsoft Developer Studio Project File - Name=&quot;LzmaLib&quot; - Package Owner=&lt;4&gt;
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE &quot;Win32 (x86) Dynamic-Link Library&quot; 0x0102
-
-CFG=LzmaLib - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;LzmaLib.mak&quot;.
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;LzmaLib.mak&quot; CFG=&quot;LzmaLib - Win32 Debug&quot;
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE &quot;LzmaLib - Win32 Release&quot; (based on &quot;Win32 (x86) Dynamic-Link Library&quot;)
-!MESSAGE &quot;LzmaLib - Win32 Debug&quot; (based on &quot;Win32 (x86) Dynamic-Link Library&quot;)
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName &quot;&quot;
-# PROP Scc_LocalPath &quot;&quot;
-CPP=cl.exe
-MTL=midl.exe
-RSC=rc.exe
-
-!IF  &quot;$(CFG)&quot; == &quot;LzmaLib - Win32 Release&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir &quot;Release&quot;
-# PROP BASE Intermediate_Dir &quot;Release&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir &quot;Release&quot;
-# PROP Intermediate_Dir &quot;Release&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /YX /FD /c
-# ADD CPP /nologo /Gr /MT /W3 /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /D &quot;COMPRESS_MF_MT&quot; /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
-# ADD MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
-# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:&quot;C:\Util\LZMA.dll&quot; /opt:NOWIN98
-# SUBTRACT LINK32 /pdb:none
-
-!ELSEIF  &quot;$(CFG)&quot; == &quot;LzmaLib - Win32 Debug&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir &quot;Debug&quot;
-# PROP BASE Intermediate_Dir &quot;Debug&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir &quot;Debug&quot;
-# PROP Intermediate_Dir &quot;Debug&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /D &quot;COMPRESS_MF_MT&quot; /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
-# ADD MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
-# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:&quot;C:\Util\LZMA.dll&quot; /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name &quot;LzmaLib - Win32 Release&quot;
-# Name &quot;LzmaLib - Win32 Debug&quot;
-# Begin Group &quot;Spec&quot;
-
-# PROP Default_Filter &quot;&quot;
-# Begin Source File
-
-SOURCE=.\LzmaLib.def
-# End Source File
-# Begin Source File
-
-SOURCE=.\LzmaLibExports.c
-# End Source File
-# End Group
-# Begin Source File
-
-SOURCE=..\Alloc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Alloc.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\IStream.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFind.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFind.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFindMt.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFindMt.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzHash.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaDec.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaDec.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaEnc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaEnc.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaLib.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaLib.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\resource.rc
-# End Source File
-# Begin Source File
-
-SOURCE=..\Threads.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Threads.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\Types.h
-# End Source File
-# End Target
-# End Project

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,178 @@
+# Microsoft Developer Studio Project File - Name=&quot;LzmaLib&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Dynamic-Link Library&quot; 0x0102
+
+CFG=LzmaLib - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;LzmaLib.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;LzmaLib.mak&quot; CFG=&quot;LzmaLib - Win32 Debug&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;LzmaLib - Win32 Release&quot; (based on &quot;Win32 (x86) Dynamic-Link Library&quot;)
+!MESSAGE &quot;LzmaLib - Win32 Debug&quot; (based on &quot;Win32 (x86) Dynamic-Link Library&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;LzmaLib - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /YX /FD /c
+# ADD CPP /nologo /Gr /MT /W3 /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /D &quot;COMPRESS_MF_MT&quot; /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
+# ADD MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:&quot;C:\Util\LZMA.dll&quot; /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;LzmaLib - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;_USRDLL&quot; /D &quot;LZMALIB_EXPORTS&quot; /D &quot;COMPRESS_MF_MT&quot; /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
+# ADD MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:&quot;C:\Util\LZMA.dll&quot; /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;LzmaLib - Win32 Release&quot;
+# Name &quot;LzmaLib - Win32 Debug&quot;
+# Begin Group &quot;Spec&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=.\LzmaLib.def
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaLibExports.c
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\Alloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Alloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\IStream.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzHash.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaLib.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaLib.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\resource.rc
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\Types.h
+# End Source File
+# End Target
+# End Project

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,29 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: &quot;LzmaLib&quot;=.\LzmaLib.dsp - Package Owner=&lt;4&gt;
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;4&gt;
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;3&gt;
-{{{
-}}}
-
-###############################################################################
-

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLib.dsw	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;LzmaLib&quot;=.\LzmaLib.dsp - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,14 +0,0 @@
-/* LzmaLibExports.c  -- LZMA library DLL Entry point
-2008-03-26
-Igor Pavlov
-Public domain */
-
-#include &lt;windows.h&gt;
-
-BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
-{
-  hInstance = hInstance;
-  dwReason = dwReason;
-  lpReserved = lpReserved;
-  return TRUE;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/LzmaLibExports.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,14 @@
+/* LzmaLibExports.c  -- LZMA library DLL Entry point
+2008-03-26
+Igor Pavlov
+Public domain */
+
+#include &lt;windows.h&gt;
+
+BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
+{
+  hInstance = hInstance;
+  dwReason = dwReason;
+  lpReserved = lpReserved;
+  return TRUE;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,37 +0,0 @@
-MY_STATIC_LINK=1
-SLIB = sLZMA.lib
-PROG = LZMA.dll
-SLIBPATH = $O\$(SLIB)
-
-DEF_FILE = LzmaLib.def
-CFLAGS = $(CFLAGS) \
-  -DCOMPRESS_MF_MT \
-
-LIBS = $(LIBS) oleaut32.lib
-
-LIB_OBJS = \
-  $O\LzmaLibExports.obj \
-
-C_OBJS = \
-  $O\Alloc.obj \
-  $O\LzFind.obj \
-  $O\LzFindMt.obj \
-  $O\LzmaDec.obj \
-  $O\LzmaEnc.obj \
-  $O\LzmaLib.obj \
-  $O\Threads.obj \
-
-OBJS = \
-  $(LIB_OBJS) \
-  $(C_OBJS) \
-  $O\resource.res
-
-!include &quot;../../CPP/Build.mak&quot;
-
-$(SLIBPATH): $O $(OBJS)
-	lib -out:$(SLIBPATH) $(OBJS) $(LIBS)
-
-$(LIB_OBJS): $(*B).c
-	$(COMPL_O2)
-$(C_OBJS): ../$(*B).c
-	$(COMPL_O2)

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,37 @@
+MY_STATIC_LINK=1
+SLIB = sLZMA.lib
+PROG = LZMA.dll
+SLIBPATH = $O\$(SLIB)
+
+DEF_FILE = LzmaLib.def
+CFLAGS = $(CFLAGS) \
+  -DCOMPRESS_MF_MT \
+
+LIBS = $(LIBS) oleaut32.lib
+
+LIB_OBJS = \
+  $O\LzmaLibExports.obj \
+
+C_OBJS = \
+  $O\Alloc.obj \
+  $O\LzFind.obj \
+  $O\LzFindMt.obj \
+  $O\LzmaDec.obj \
+  $O\LzmaEnc.obj \
+  $O\LzmaLib.obj \
+  $O\Threads.obj \
+
+OBJS = \
+  $(LIB_OBJS) \
+  $(C_OBJS) \
+  $O\resource.res
+
+!include &quot;../../CPP/Build.mak&quot;
+
+$(SLIBPATH): $O $(OBJS)
+	lib -out:$(SLIBPATH) $(OBJS) $(LIBS)
+
+$(LIB_OBJS): $(*B).c
+	$(COMPL_O2)
+$(C_OBJS): ../$(*B).c
+	$(COMPL_O2)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,4 +0,0 @@
-#include &quot;../../CPP/7zip/MyVersionInfo.rc&quot;
-
-MY_VERSION_INFO_DLL(&quot;LZMA library&quot;, &quot;LZMA&quot;)
-

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib/resource.rc	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,4 @@
+#include &quot;../../CPP/7zip/MyVersionInfo.rc&quot;
+
+MY_VERSION_INFO_DLL(&quot;LZMA library&quot;, &quot;LZMA&quot;)
+

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,46 +0,0 @@
-/* LzmaLib.c -- LZMA library wrapper
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#include &quot;LzmaEnc.h&quot;
-#include &quot;LzmaDec.h&quot;
-#include &quot;Alloc.h&quot;
-#include &quot;LzmaLib.h&quot;
-
-static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
-static void SzFree(void *p, void *address) { p = p; MyFree(address); }
-static ISzAlloc g_Alloc = { SzAlloc, SzFree };
-
-MY_STDAPI LzmaCompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  srcLen,
-  unsigned char *outProps, size_t *outPropsSize,
-  int level, /* 0 &lt;= level &lt;= 9, default = 5 */
-  unsigned dictSize, /* use (1 &lt;&lt; N) or (3 &lt;&lt; N). 4 KB &lt; dictSize &lt;= 128 MB */
-  int lc, /* 0 &lt;= lc &lt;= 8, default = 3  */
-  int lp, /* 0 &lt;= lp &lt;= 4, default = 0  */
-  int pb, /* 0 &lt;= pb &lt;= 4, default = 2  */
-  int fb,  /* 5 &lt;= fb &lt;= 273, default = 32 */
-  int numThreads /* 1 or 2, default = 2 */
-)
-{
-  CLzmaEncProps props;
-  LzmaEncProps_Init(&amp;props);
-  props.level = level;
-  props.dictSize = dictSize;
-  props.lc = lc;
-  props.lp = lp;
-  props.pb = pb;
-  props.fb = fb;
-  props.numThreads = numThreads;
-
-  return LzmaEncode(dest, destLen, src, srcLen, &amp;props, outProps, outPropsSize, 0,
-      NULL, &amp;g_Alloc, &amp;g_Alloc);
-}
-
-
-MY_STDAPI LzmaUncompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  *srcLen,
-  const unsigned char *props, size_t propsSize)
-{
-  ELzmaStatus status;
-  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &amp;status, &amp;g_Alloc);
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,46 @@
+/* LzmaLib.c -- LZMA library wrapper
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include &quot;LzmaEnc.h&quot;
+#include &quot;LzmaDec.h&quot;
+#include &quot;Alloc.h&quot;
+#include &quot;LzmaLib.h&quot;
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+MY_STDAPI LzmaCompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  srcLen,
+  unsigned char *outProps, size_t *outPropsSize,
+  int level, /* 0 &lt;= level &lt;= 9, default = 5 */
+  unsigned dictSize, /* use (1 &lt;&lt; N) or (3 &lt;&lt; N). 4 KB &lt; dictSize &lt;= 128 MB */
+  int lc, /* 0 &lt;= lc &lt;= 8, default = 3  */
+  int lp, /* 0 &lt;= lp &lt;= 4, default = 0  */
+  int pb, /* 0 &lt;= pb &lt;= 4, default = 2  */
+  int fb,  /* 5 &lt;= fb &lt;= 273, default = 32 */
+  int numThreads /* 1 or 2, default = 2 */
+)
+{
+  CLzmaEncProps props;
+  LzmaEncProps_Init(&amp;props);
+  props.level = level;
+  props.dictSize = dictSize;
+  props.lc = lc;
+  props.lp = lp;
+  props.pb = pb;
+  props.fb = fb;
+  props.numThreads = numThreads;
+
+  return LzmaEncode(dest, destLen, src, srcLen, &amp;props, outProps, outPropsSize, 0,
+      NULL, &amp;g_Alloc, &amp;g_Alloc);
+}
+
+
+MY_STDAPI LzmaUncompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  *srcLen,
+  const unsigned char *props, size_t propsSize)
+{
+  ELzmaStatus status;
+  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &amp;status, &amp;g_Alloc);
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,135 +0,0 @@
-/* LzmaLib.h -- LZMA library interface
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __LZMALIB_H
-#define __LZMALIB_H
-
-#include &quot;Types.h&quot;
-
-#ifdef __cplusplus
-  #define MY_EXTERN_C extern &quot;C&quot;
-#else
-  #define MY_EXTERN_C extern
-#endif
-
-#define MY_STDAPI MY_EXTERN_C int MY_STD_CALL
-
-#define LZMA_PROPS_SIZE 5
-
-/*
-RAM requirements for LZMA:
-  for compression:   (dictSize * 11.5 + 6 MB) + state_size
-  for decompression: dictSize + state_size
-    state_size = (4 + (1.5 &lt;&lt; (lc + lp))) KB
-    by default (lc=3, lp=0), state_size = 16 KB.
-
-LZMA properties (5 bytes) format
-    Offset Size  Description
-      0     1    lc, lp and pb in encoded form.
-      1     4    dictSize (little endian).
-*/
-
-/*
-LzmaCompress
-------------
-
-outPropsSize -
-     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
-     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
-
-  LZMA Encoder will use defult values for any parameter, if it is
-  -1  for any from: level, loc, lp, pb, fb, numThreads
-   0  for dictSize
-  
-level - compression level: 0 &lt;= level &lt;= 9;
-
-  level dictSize algo  fb
-    0:    16 KB   0    32
-    1:    64 KB   0    32
-    2:   256 KB   0    32
-    3:     1 MB   0    32
-    4:     4 MB   0    32
-    5:    16 MB   1    32
-    6:    32 MB   1    32
-    7+:   64 MB   1    64
- 
-  The default value for &quot;level&quot; is 5.
-
-  algo = 0 means fast method
-  algo = 1 means normal method
-
-dictSize - The dictionary size in bytes. The maximum value is
-        128 MB = (1 &lt;&lt; 27) bytes for 32-bit version
-          1 GB = (1 &lt;&lt; 30) bytes for 64-bit version
-     The default value is 16 MB = (1 &lt;&lt; 24) bytes.
-     It's recommended to use the dictionary that is larger than 4 KB and
-     that can be calculated as (1 &lt;&lt; N) or (3 &lt;&lt; N) sizes.
-
-lc - The number of literal context bits (high bits of previous literal).
-     It can be in the range from 0 to 8. The default value is 3.
-     Sometimes lc=4 gives the gain for big files.
-
-lp - The number of literal pos bits (low bits of current position for literals).
-     It can be in the range from 0 to 4. The default value is 0.
-     The lp switch is intended for periodical data when the period is equal to 2^lp.
-     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
-     better to set lc=0, if you change lp switch.
-
-pb - The number of pos bits (low bits of current position).
-     It can be in the range from 0 to 4. The default value is 2.
-     The pb switch is intended for periodical data when the period is equal 2^pb.
-
-fb - Word size (the number of fast bytes).
-     It can be in the range from 5 to 273. The default value is 32.
-     Usually, a big number gives a little bit better compression ratio and
-     slower compression process.
-
-numThreads - The number of thereads. 1 or 2. The default value is 2.
-     Fast mode (algo = 0) can use only 1 thread.
-
-Out:
-  destLen  - processed output size
-Returns:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-MY_STDAPI LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,
-  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */
-  int level,      /* 0 &lt;= level &lt;= 9, default = 5 */
-  unsigned dictSize,  /* default = (1 &lt;&lt; 24) */
-  int lc,        /* 0 &lt;= lc &lt;= 8, default = 3  */
-  int lp,        /* 0 &lt;= lp &lt;= 4, default = 0  */
-  int pb,        /* 0 &lt;= pb &lt;= 4, default = 2  */
-  int fb,        /* 5 &lt;= fb &lt;= 273, default = 32 */
-  int numThreads /* 1 or 2, default = 2 */
-  );
-
-/*
-LzmaUncompress
---------------
-In:
-  dest     - output data
-  destLen  - output data size
-  src      - input data
-  srcLen   - input data size
-Out:
-  destLen  - processed output size
-  srcLen   - processed input size
-Returns:
-  SZ_OK                - OK
-  SZ_ERROR_DATA        - Data error
-  SZ_ERROR_MEM         - Memory allocation arror
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
-*/
-
-MY_STDAPI LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, SizeT *srcLen,
-  const unsigned char *props, size_t propsSize);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaLib.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,135 @@
+/* LzmaLib.h -- LZMA library interface
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMALIB_H
+#define __LZMALIB_H
+
+#include &quot;Types.h&quot;
+
+#ifdef __cplusplus
+  #define MY_EXTERN_C extern &quot;C&quot;
+#else
+  #define MY_EXTERN_C extern
+#endif
+
+#define MY_STDAPI MY_EXTERN_C int MY_STD_CALL
+
+#define LZMA_PROPS_SIZE 5
+
+/*
+RAM requirements for LZMA:
+  for compression:   (dictSize * 11.5 + 6 MB) + state_size
+  for decompression: dictSize + state_size
+    state_size = (4 + (1.5 &lt;&lt; (lc + lp))) KB
+    by default (lc=3, lp=0), state_size = 16 KB.
+
+LZMA properties (5 bytes) format
+    Offset Size  Description
+      0     1    lc, lp and pb in encoded form.
+      1     4    dictSize (little endian).
+*/
+
+/*
+LzmaCompress
+------------
+
+outPropsSize -
+     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
+     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
+
+  LZMA Encoder will use defult values for any parameter, if it is
+  -1  for any from: level, loc, lp, pb, fb, numThreads
+   0  for dictSize
+  
+level - compression level: 0 &lt;= level &lt;= 9;
+
+  level dictSize algo  fb
+    0:    16 KB   0    32
+    1:    64 KB   0    32
+    2:   256 KB   0    32
+    3:     1 MB   0    32
+    4:     4 MB   0    32
+    5:    16 MB   1    32
+    6:    32 MB   1    32
+    7+:   64 MB   1    64
+ 
+  The default value for &quot;level&quot; is 5.
+
+  algo = 0 means fast method
+  algo = 1 means normal method
+
+dictSize - The dictionary size in bytes. The maximum value is
+        128 MB = (1 &lt;&lt; 27) bytes for 32-bit version
+          1 GB = (1 &lt;&lt; 30) bytes for 64-bit version
+     The default value is 16 MB = (1 &lt;&lt; 24) bytes.
+     It's recommended to use the dictionary that is larger than 4 KB and
+     that can be calculated as (1 &lt;&lt; N) or (3 &lt;&lt; N) sizes.
+
+lc - The number of literal context bits (high bits of previous literal).
+     It can be in the range from 0 to 8. The default value is 3.
+     Sometimes lc=4 gives the gain for big files.
+
+lp - The number of literal pos bits (low bits of current position for literals).
+     It can be in the range from 0 to 4. The default value is 0.
+     The lp switch is intended for periodical data when the period is equal to 2^lp.
+     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
+     better to set lc=0, if you change lp switch.
+
+pb - The number of pos bits (low bits of current position).
+     It can be in the range from 0 to 4. The default value is 2.
+     The pb switch is intended for periodical data when the period is equal 2^pb.
+
+fb - Word size (the number of fast bytes).
+     It can be in the range from 5 to 273. The default value is 32.
+     Usually, a big number gives a little bit better compression ratio and
+     slower compression process.
+
+numThreads - The number of thereads. 1 or 2. The default value is 2.
+     Fast mode (algo = 0) can use only 1 thread.
+
+Out:
+  destLen  - processed output size
+Returns:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+MY_STDAPI LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,
+  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */
+  int level,      /* 0 &lt;= level &lt;= 9, default = 5 */
+  unsigned dictSize,  /* default = (1 &lt;&lt; 24) */
+  int lc,        /* 0 &lt;= lc &lt;= 8, default = 3  */
+  int lp,        /* 0 &lt;= lp &lt;= 4, default = 0  */
+  int pb,        /* 0 &lt;= pb &lt;= 4, default = 2  */
+  int fb,        /* 5 &lt;= fb &lt;= 273, default = 32 */
+  int numThreads /* 1 or 2, default = 2 */
+  );
+
+/*
+LzmaUncompress
+--------------
+In:
+  dest     - output data
+  destLen  - output data size
+  src      - input data
+  srcLen   - input data size
+Out:
+  destLen  - processed output size
+  srcLen   - processed input size
+Returns:
+  SZ_OK                - OK
+  SZ_ERROR_DATA        - Data error
+  SZ_ERROR_MEM         - Memory allocation arror
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
+*/
+
+MY_STDAPI LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, SizeT *srcLen,
+  const unsigned char *props, size_t propsSize);
+
+#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,61 +0,0 @@
-/* Lzma86Dec.c -- LZMA + x86 (BCJ) Filter Decoder
-2008-04-07
-Igor Pavlov
-Public domain */
-
-#include &quot;Lzma86Dec.h&quot;
-
-#include &quot;../Alloc.h&quot;
-#include &quot;../Bra.h&quot;
-#include &quot;../LzmaDec.h&quot;
-
-#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
-#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
-
-static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
-static void SzFree(void *p, void *address) { p = p; MyFree(address); }
-static ISzAlloc g_Alloc = { SzAlloc, SzFree };
-
-SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize)
-{
-  unsigned i;
-  if (srcLen &lt; LZMA86_HEADER_SIZE)
-    return SZ_ERROR_INPUT_EOF;
-  *unpackSize = 0;
-  for (i = 0; i &lt; sizeof(UInt64); i++)
-    *unpackSize += ((UInt64)src[LZMA86_SIZE_OFFSET + i]) &lt;&lt; (8 * i);
-  return SZ_OK;
-}
-
-SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen)
-{
-  SRes res;
-  int useFilter;
-  SizeT inSizePure;
-  ELzmaStatus status;
-
-  if (*srcLen &lt; LZMA86_HEADER_SIZE)
-    return SZ_ERROR_INPUT_EOF;
-
-  useFilter = src[0];
-
-  if (useFilter &gt; 1)
-  {
-    *destLen = 0;
-    return SZ_ERROR_UNSUPPORTED;
-  }
-
-  inSizePure = *srcLen - LZMA86_HEADER_SIZE;
-  res = LzmaDecode(dest, destLen, src + LZMA86_HEADER_SIZE, &amp;inSizePure,
-      src + 1, LZMA_PROPS_SIZE, LZMA_FINISH_ANY, &amp;status, &amp;g_Alloc);
-  *srcLen = inSizePure + LZMA86_HEADER_SIZE;
-  if (res != SZ_OK)
-    return res;
-  if (useFilter == 1)
-  {
-    UInt32 x86State;
-    x86_Convert_Init(x86State);
-    x86_Convert(dest, *destLen, 0, &amp;x86State, 0);
-  }
-  return SZ_OK;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,61 @@
+/* Lzma86Dec.c -- LZMA + x86 (BCJ) Filter Decoder
+2008-04-07
+Igor Pavlov
+Public domain */
+
+#include &quot;Lzma86Dec.h&quot;
+
+#include &quot;../Alloc.h&quot;
+#include &quot;../Bra.h&quot;
+#include &quot;../LzmaDec.h&quot;
+
+#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
+#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize)
+{
+  unsigned i;
+  if (srcLen &lt; LZMA86_HEADER_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+  *unpackSize = 0;
+  for (i = 0; i &lt; sizeof(UInt64); i++)
+    *unpackSize += ((UInt64)src[LZMA86_SIZE_OFFSET + i]) &lt;&lt; (8 * i);
+  return SZ_OK;
+}
+
+SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen)
+{
+  SRes res;
+  int useFilter;
+  SizeT inSizePure;
+  ELzmaStatus status;
+
+  if (*srcLen &lt; LZMA86_HEADER_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+
+  useFilter = src[0];
+
+  if (useFilter &gt; 1)
+  {
+    *destLen = 0;
+    return SZ_ERROR_UNSUPPORTED;
+  }
+
+  inSizePure = *srcLen - LZMA86_HEADER_SIZE;
+  res = LzmaDecode(dest, destLen, src + LZMA86_HEADER_SIZE, &amp;inSizePure,
+      src + 1, LZMA_PROPS_SIZE, LZMA_FINISH_ANY, &amp;status, &amp;g_Alloc);
+  *srcLen = inSizePure + LZMA86_HEADER_SIZE;
+  if (res != SZ_OK)
+    return res;
+  if (useFilter == 1)
+  {
+    UInt32 x86State;
+    x86_Convert_Init(x86State);
+    x86_Convert(dest, *destLen, 0, &amp;x86State, 0);
+  }
+  return SZ_OK;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,45 +0,0 @@
-/* Lzma86Dec.h -- LZMA + x86 (BCJ) Filter Decoder
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __LZMA86DEC_H
-#define __LZMA86DEC_H
-
-#include &quot;../Types.h&quot;
-
-/*
-Lzma86_GetUnpackSize:
-  In:
-    src      - input data
-    srcLen   - input data size
-  Out:
-    unpackSize - size of uncompressed stream
-  Return code:
-    SZ_OK               - OK
-    SZ_ERROR_INPUT_EOF  - Error in headers
-*/
-
-SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize);
-
-/*
-Lzma86_Decode:
-  In:
-    dest     - output data
-    destLen  - output data size
-    src      - input data
-    srcLen   - input data size
-  Out:
-    destLen  - processed output size
-    srcLen   - processed input size
-  Return code:
-    SZ_OK           - OK
-    SZ_ERROR_DATA  - Data error
-    SZ_ERROR_MEM   - Memory allocation error
-    SZ_ERROR_UNSUPPORTED - unsupported file
-    SZ_ERROR_INPUT_EOF - it needs more bytes in input buffer
-*/
-
-SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Dec.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,45 @@
+/* Lzma86Dec.h -- LZMA + x86 (BCJ) Filter Decoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMA86DEC_H
+#define __LZMA86DEC_H
+
+#include &quot;../Types.h&quot;
+
+/*
+Lzma86_GetUnpackSize:
+  In:
+    src      - input data
+    srcLen   - input data size
+  Out:
+    unpackSize - size of uncompressed stream
+  Return code:
+    SZ_OK               - OK
+    SZ_ERROR_INPUT_EOF  - Error in headers
+*/
+
+SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize);
+
+/*
+Lzma86_Decode:
+  In:
+    dest     - output data
+    destLen  - output data size
+    src      - input data
+    srcLen   - input data size
+  Out:
+    destLen  - processed output size
+    srcLen   - processed input size
+  Return code:
+    SZ_OK           - OK
+    SZ_ERROR_DATA  - Data error
+    SZ_ERROR_MEM   - Memory allocation error
+    SZ_ERROR_UNSUPPORTED - unsupported file
+    SZ_ERROR_INPUT_EOF - it needs more bytes in input buffer
+*/
+
+SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,113 +0,0 @@
-/* Lzma86Enc.c -- LZMA + x86 (BCJ) Filter Encoder
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#include &lt;string.h&gt;
-
-#include &quot;Lzma86Enc.h&quot;
-
-#include &quot;../Alloc.h&quot;
-#include &quot;../Bra.h&quot;
-#include &quot;../LzmaEnc.h&quot;
-
-#define SZE_OUT_OVERFLOW SZE_DATA_ERROR
-
-static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
-static void SzFree(void *p, void *address) { p = p; MyFree(address); }
-static ISzAlloc g_Alloc = { SzAlloc, SzFree };
-
-#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
-#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
-
-int Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
-    int level, UInt32 dictSize, int filterMode)
-{
-  size_t outSize2 = *destLen;
-  Byte *filteredStream;
-  Bool useFilter;
-  int mainResult = SZ_ERROR_OUTPUT_EOF;
-  CLzmaEncProps props;
-  LzmaEncProps_Init(&amp;props);
-  props.level = level;
-  props.dictSize = dictSize;
-  
-  *destLen = 0;
-  if (outSize2 &lt; LZMA86_HEADER_SIZE)
-    return SZ_ERROR_OUTPUT_EOF;
-
-  {
-    int i;
-    UInt64 t = srcLen;
-    for (i = 0; i &lt; 8; i++, t &gt;&gt;= 8)
-      dest[LZMA86_SIZE_OFFSET + i] = (Byte)t;
-  }
-
-  filteredStream = 0;
-  useFilter = (filterMode != SZ_FILTER_NO);
-  if (useFilter)
-  {
-    if (srcLen != 0)
-    {
-      filteredStream = (Byte *)MyAlloc(srcLen);
-      if (filteredStream == 0)
-        return SZ_ERROR_MEM;
-      memcpy(filteredStream, src, srcLen);
-    }
-    {
-      UInt32 x86State;
-      x86_Convert_Init(x86State);
-      x86_Convert(filteredStream, srcLen, 0, &amp;x86State, 1);
-    }
-  }
-
-  {
-    size_t minSize = 0;
-    Bool bestIsFiltered = False;
-
-    /* passes for SZ_FILTER_AUTO:
-        0 - BCJ + LZMA
-        1 - LZMA
-        2 - BCJ + LZMA agaian, if pass 0 (BCJ + LZMA) is better.
-    */
-    int numPasses = (filterMode == SZ_FILTER_AUTO) ? 3 : 1;
-
-    int i;
-    for (i = 0; i &lt; numPasses; i++)
-    {
-      size_t outSizeProcessed = outSize2 - LZMA86_HEADER_SIZE;
-      size_t outPropsSize = 5;
-      SRes curRes;
-      Bool curModeIsFiltered = (numPasses &gt; 1 &amp;&amp; i == numPasses - 1);
-      if (curModeIsFiltered &amp;&amp; !bestIsFiltered)
-        break;
-      if (useFilter &amp;&amp; i == 0)
-        curModeIsFiltered = True;
-      
-      curRes = LzmaEncode(dest + LZMA86_HEADER_SIZE, &amp;outSizeProcessed,
-          curModeIsFiltered ? filteredStream : src, srcLen,
-          &amp;props, dest + 1, &amp;outPropsSize, 0,
-          NULL, &amp;g_Alloc, &amp;g_Alloc);
-      
-      if (curRes != SZ_ERROR_OUTPUT_EOF)
-      {
-        if (curRes != SZ_OK)
-        {
-          mainResult = curRes;
-          break;
-        }
-        if (outSizeProcessed &lt;= minSize || mainResult != SZ_OK)
-        {
-          minSize = outSizeProcessed;
-          bestIsFiltered = curModeIsFiltered;
-          mainResult = SZ_OK;
-        }
-      }
-    }
-    dest[0] = (bestIsFiltered ? 1 : 0);
-    *destLen = LZMA86_HEADER_SIZE + minSize;
-  }
-  if (useFilter)
-    MyFree(filteredStream);
-  return mainResult;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,113 @@
+/* Lzma86Enc.c -- LZMA + x86 (BCJ) Filter Encoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include &lt;string.h&gt;
+
+#include &quot;Lzma86Enc.h&quot;
+
+#include &quot;../Alloc.h&quot;
+#include &quot;../Bra.h&quot;
+#include &quot;../LzmaEnc.h&quot;
+
+#define SZE_OUT_OVERFLOW SZE_DATA_ERROR
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
+#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
+
+int Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
+    int level, UInt32 dictSize, int filterMode)
+{
+  size_t outSize2 = *destLen;
+  Byte *filteredStream;
+  Bool useFilter;
+  int mainResult = SZ_ERROR_OUTPUT_EOF;
+  CLzmaEncProps props;
+  LzmaEncProps_Init(&amp;props);
+  props.level = level;
+  props.dictSize = dictSize;
+  
+  *destLen = 0;
+  if (outSize2 &lt; LZMA86_HEADER_SIZE)
+    return SZ_ERROR_OUTPUT_EOF;
+
+  {
+    int i;
+    UInt64 t = srcLen;
+    for (i = 0; i &lt; 8; i++, t &gt;&gt;= 8)
+      dest[LZMA86_SIZE_OFFSET + i] = (Byte)t;
+  }
+
+  filteredStream = 0;
+  useFilter = (filterMode != SZ_FILTER_NO);
+  if (useFilter)
+  {
+    if (srcLen != 0)
+    {
+      filteredStream = (Byte *)MyAlloc(srcLen);
+      if (filteredStream == 0)
+        return SZ_ERROR_MEM;
+      memcpy(filteredStream, src, srcLen);
+    }
+    {
+      UInt32 x86State;
+      x86_Convert_Init(x86State);
+      x86_Convert(filteredStream, srcLen, 0, &amp;x86State, 1);
+    }
+  }
+
+  {
+    size_t minSize = 0;
+    Bool bestIsFiltered = False;
+
+    /* passes for SZ_FILTER_AUTO:
+        0 - BCJ + LZMA
+        1 - LZMA
+        2 - BCJ + LZMA agaian, if pass 0 (BCJ + LZMA) is better.
+    */
+    int numPasses = (filterMode == SZ_FILTER_AUTO) ? 3 : 1;
+
+    int i;
+    for (i = 0; i &lt; numPasses; i++)
+    {
+      size_t outSizeProcessed = outSize2 - LZMA86_HEADER_SIZE;
+      size_t outPropsSize = 5;
+      SRes curRes;
+      Bool curModeIsFiltered = (numPasses &gt; 1 &amp;&amp; i == numPasses - 1);
+      if (curModeIsFiltered &amp;&amp; !bestIsFiltered)
+        break;
+      if (useFilter &amp;&amp; i == 0)
+        curModeIsFiltered = True;
+      
+      curRes = LzmaEncode(dest + LZMA86_HEADER_SIZE, &amp;outSizeProcessed,
+          curModeIsFiltered ? filteredStream : src, srcLen,
+          &amp;props, dest + 1, &amp;outPropsSize, 0,
+          NULL, &amp;g_Alloc, &amp;g_Alloc);
+      
+      if (curRes != SZ_ERROR_OUTPUT_EOF)
+      {
+        if (curRes != SZ_OK)
+        {
+          mainResult = curRes;
+          break;
+        }
+        if (outSizeProcessed &lt;= minSize || mainResult != SZ_OK)
+        {
+          minSize = outSizeProcessed;
+          bestIsFiltered = curModeIsFiltered;
+          mainResult = SZ_OK;
+        }
+      }
+    }
+    dest[0] = (bestIsFiltered ? 1 : 0);
+    *destLen = LZMA86_HEADER_SIZE + minSize;
+  }
+  if (useFilter)
+    MyFree(filteredStream);
+  return mainResult;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,72 +0,0 @@
-/* Lzma86Enc.h -- LZMA + x86 (BCJ) Filter Encoder
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __LZMA86ENC_H
-#define __LZMA86ENC_H
-
-#include &quot;../Types.h&quot;
-
-/*
-It's an example for LZMA + x86 Filter use.
-You can use .lzma86 extension, if you write that stream to file.
-.lzma86 header adds one additional byte to standard .lzma header.
-.lzma86 header (14 bytes):
-  Offset Size  Description
-    0     1    = 0 - no filter,
-               = 1 - x86 filter
-    1     1    lc, lp and pb in encoded form
-    2     4    dictSize (little endian)
-    6     8    uncompressed size (little endian)
-
-
-Lzma86_Encode
--------------
-level - compression level: 0 &lt;= level &lt;= 9, the default value for &quot;level&quot; is 5.
-
-
-dictSize - The dictionary size in bytes. The maximum value is
-        128 MB = (1 &lt;&lt; 27) bytes for 32-bit version
-          1 GB = (1 &lt;&lt; 30) bytes for 64-bit version
-     The default value is 16 MB = (1 &lt;&lt; 24) bytes, for level = 5.
-     It's recommended to use the dictionary that is larger than 4 KB and
-     that can be calculated as (1 &lt;&lt; N) or (3 &lt;&lt; N) sizes.
-     For better compression ratio dictSize must be &gt;= inSize.
-
-filterMode:
-    SZ_FILTER_NO   - no Filter
-    SZ_FILTER_YES  - x86 Filter
-    SZ_FILTER_AUTO - it tries both alternatives to select best.
-              Encoder will use 2 or 3 passes:
-              2 passes when FILTER_NO provides better compression.
-              3 passes when FILTER_YES provides better compression.
-
-Lzma86Encode allocates Data with MyAlloc functions.
-RAM Requirements for compressing:
-  RamSize = dictionarySize * 11.5 + 6MB + FilterBlockSize
-      filterMode     FilterBlockSize
-     SZ_FILTER_NO         0
-     SZ_FILTER_YES      inSize
-     SZ_FILTER_AUTO     inSize
-
-
-Return code:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-enum ESzFilterMode
-{
-  SZ_FILTER_NO,
-  SZ_FILTER_YES,
-  SZ_FILTER_AUTO
-};
-
-SRes Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
-    int level, UInt32 dictSize, int filterMode);
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/Lzma86Enc.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,72 @@
+/* Lzma86Enc.h -- LZMA + x86 (BCJ) Filter Encoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMA86ENC_H
+#define __LZMA86ENC_H
+
+#include &quot;../Types.h&quot;
+
+/*
+It's an example for LZMA + x86 Filter use.
+You can use .lzma86 extension, if you write that stream to file.
+.lzma86 header adds one additional byte to standard .lzma header.
+.lzma86 header (14 bytes):
+  Offset Size  Description
+    0     1    = 0 - no filter,
+               = 1 - x86 filter
+    1     1    lc, lp and pb in encoded form
+    2     4    dictSize (little endian)
+    6     8    uncompressed size (little endian)
+
+
+Lzma86_Encode
+-------------
+level - compression level: 0 &lt;= level &lt;= 9, the default value for &quot;level&quot; is 5.
+
+
+dictSize - The dictionary size in bytes. The maximum value is
+        128 MB = (1 &lt;&lt; 27) bytes for 32-bit version
+          1 GB = (1 &lt;&lt; 30) bytes for 64-bit version
+     The default value is 16 MB = (1 &lt;&lt; 24) bytes, for level = 5.
+     It's recommended to use the dictionary that is larger than 4 KB and
+     that can be calculated as (1 &lt;&lt; N) or (3 &lt;&lt; N) sizes.
+     For better compression ratio dictSize must be &gt;= inSize.
+
+filterMode:
+    SZ_FILTER_NO   - no Filter
+    SZ_FILTER_YES  - x86 Filter
+    SZ_FILTER_AUTO - it tries both alternatives to select best.
+              Encoder will use 2 or 3 passes:
+              2 passes when FILTER_NO provides better compression.
+              3 passes when FILTER_YES provides better compression.
+
+Lzma86Encode allocates Data with MyAlloc functions.
+RAM Requirements for compressing:
+  RamSize = dictionarySize * 11.5 + 6MB + FilterBlockSize
+      filterMode     FilterBlockSize
+     SZ_FILTER_NO         0
+     SZ_FILTER_YES      inSize
+     SZ_FILTER_AUTO     inSize
+
+
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+enum ESzFilterMode
+{
+  SZ_FILTER_NO,
+  SZ_FILTER_YES,
+  SZ_FILTER_AUTO
+};
+
+SRes Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
+    int level, UInt32 dictSize, int filterMode);
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,311 +0,0 @@
-/* LzmaUtil.c -- Test application for LZMA compression
-2008-08-05
-Igor Pavlov
-public domain */
-
-#define _CRT_SECURE_NO_WARNINGS
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;../LzmaDec.h&quot;
-#include &quot;../LzmaEnc.h&quot;
-#include &quot;../Alloc.h&quot;
-
-const char *kCantReadMessage = &quot;Can not read input file&quot;;
-const char *kCantWriteMessage = &quot;Can not write output file&quot;;
-const char *kCantAllocateMessage = &quot;Can not allocate memory&quot;;
-const char *kDataErrorMessage = &quot;Data error&quot;;
-
-static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
-static void SzFree(void *p, void *address) {  p = p; MyFree(address); }
-static ISzAlloc g_Alloc = { SzAlloc, SzFree };
-
-#define kInBufferSize (1 &lt;&lt; 15)
-#define kOutBufferSize (1 &lt;&lt; 15)
-
-unsigned char g_InBuffer[kInBufferSize];
-unsigned char g_OutBuffer[kOutBufferSize];
-
-size_t MyReadFile(FILE *file, void *data, size_t size)
-  { return fread(data, 1, size, file); }
-
-int MyReadFileAndCheck(FILE *file, void *data, size_t size)
-  { return (MyReadFile(file, data, size) == size); }
-
-size_t MyWriteFile(FILE *file, const void *data, size_t size)
-{
-  if (size == 0)
-    return 0;
-  return fwrite(data, 1, size, file);
-}
-
-int MyWriteFileAndCheck(FILE *file, const void *data, size_t size)
-  { return (MyWriteFile(file, data, size) == size); }
-
-long MyGetFileLength(FILE *file)
-{
-  long length;
-  fseek(file, 0, SEEK_END);
-  length = ftell(file);
-  fseek(file, 0, SEEK_SET);
-  return length;
-}
-
-void PrintHelp(char *buffer)
-{
-  strcat(buffer, &quot;\nLZMA Utility 4.58 Copyright (c) 1999-2008 Igor Pavlov  2008-04-11\n&quot;
-      &quot;\nUsage:  lzma &lt;e|d&gt; inputFile outputFile\n&quot;
-             &quot;  e: encode file\n&quot;
-             &quot;  d: decode file\n&quot;);
-}
-
-int PrintError(char *buffer, const char *message)
-{
-  strcat(buffer, &quot;\nError: &quot;);
-  strcat(buffer, message);
-  strcat(buffer, &quot;\n&quot;);
-  return 1;
-}
-
-int PrintErrorNumber(char *buffer, SRes val)
-{
-  sprintf(buffer + strlen(buffer), &quot;\nError code: %x\n&quot;, (unsigned)val);
-  return 1;
-}
-
-int PrintUserError(char *buffer)
-{
-  return PrintError(buffer, &quot;Incorrect command&quot;);
-}
-
-#define IN_BUF_SIZE (1 &lt;&lt; 16)
-#define OUT_BUF_SIZE (1 &lt;&lt; 16)
-
-static int Decode(FILE *inFile, FILE *outFile, char *rs)
-{
-  UInt64 unpackSize;
-  int thereIsSize; /* = 1, if there is uncompressed size in headers */
-  int i;
-  int res = 0;
-  
-  CLzmaDec state;
-
-  /* header: 5 bytes of LZMA properties and 8 bytes of uncompressed size */
-  unsigned char header[LZMA_PROPS_SIZE + 8];
-
-  /* Read and parse header */
-
-  if (!MyReadFileAndCheck(inFile, header, sizeof(header)))
-    return PrintError(rs, kCantReadMessage);
-
-  unpackSize = 0;
-  thereIsSize = 0;
-  for (i = 0; i &lt; 8; i++)
-  {
-    unsigned char b = header[LZMA_PROPS_SIZE + i];
-    if (b != 0xFF)
-      thereIsSize = 1;
-    unpackSize += (UInt64)b &lt;&lt; (i * 8);
-  }
-
-  LzmaDec_Construct(&amp;state);
-  res = LzmaDec_Allocate(&amp;state, header, LZMA_PROPS_SIZE, &amp;g_Alloc);
-  if (res != SZ_OK)
-    return res;
-  {
-    Byte inBuf[IN_BUF_SIZE];
-    Byte outBuf[OUT_BUF_SIZE];
-    size_t inPos = 0, inSize = 0, outPos = 0;
-    LzmaDec_Init(&amp;state);
-    for (;;)
-    {
-      if (inPos == inSize)
-      {
-        inSize = MyReadFile(inFile, inBuf, IN_BUF_SIZE);
-        inPos = 0;
-      }
-      {
-        SizeT inProcessed = inSize - inPos;
-        SizeT outProcessed = OUT_BUF_SIZE - outPos;
-        ELzmaFinishMode finishMode = LZMA_FINISH_ANY;
-        ELzmaStatus status;
-        if (thereIsSize &amp;&amp; outProcessed &gt; unpackSize)
-        {
-          outProcessed = (SizeT)unpackSize;
-          finishMode = LZMA_FINISH_END;
-        }
-
-        res = LzmaDec_DecodeToBuf(&amp;state, outBuf + outPos, &amp;outProcessed,
-            inBuf + inPos, &amp;inProcessed, finishMode, &amp;status);
-        inPos += (UInt32)inProcessed;
-        outPos += outProcessed;
-        unpackSize -= outProcessed;
-
-        if (outFile != 0)
-          MyWriteFile(outFile, outBuf, outPos);
-        outPos = 0;
-
-        if (res != SZ_OK || thereIsSize &amp;&amp; unpackSize == 0)
-          break;
-
-        if (inProcessed == 0 &amp;&amp; outProcessed == 0)
-        {
-          if (thereIsSize || status != LZMA_STATUS_FINISHED_WITH_MARK)
-            res = SZ_ERROR_DATA;
-          break;
-        }
-      }
-    }
-  }
-
-  LzmaDec_Free(&amp;state, &amp;g_Alloc);
-  return res;
-}
-
-typedef struct _CFileSeqInStream
-{
-  ISeqInStream funcTable;
-  FILE *file;
-} CFileSeqInStream;
-
-static SRes MyRead(void *p, void *buf, size_t *size)
-{
-  if (*size == 0)
-    return SZ_OK;
-  *size = MyReadFile(((CFileSeqInStream*)p)-&gt;file, buf, *size);
-  /*
-  if (*size == 0)
-    return SZE_FAIL;
-  */
-  return SZ_OK;
-}
-
-typedef struct _CFileSeqOutStream
-{
-  ISeqOutStream funcTable;
-  FILE *file;
-} CFileSeqOutStream;
-
-static size_t MyWrite(void *pp, const void *buf, size_t size)
-{
-  return MyWriteFile(((CFileSeqOutStream *)pp)-&gt;file, buf, size);
-}
-
-static SRes Encode(FILE *inFile, FILE *outFile, char *rs)
-{
-  CLzmaEncHandle enc;
-  SRes res;
-  CFileSeqInStream inStream;
-  CFileSeqOutStream outStream;
-  CLzmaEncProps props;
-
-  enc = LzmaEnc_Create(&amp;g_Alloc);
-  if (enc == 0)
-    return SZ_ERROR_MEM;
-
-  inStream.funcTable.Read = MyRead;
-  inStream.file = inFile;
-  outStream.funcTable.Write = MyWrite;
-  outStream.file = outFile;
-
-  LzmaEncProps_Init(&amp;props);
-  res = LzmaEnc_SetProps(enc, &amp;props);
-
-  if (res == SZ_OK)
-  {
-    Byte header[LZMA_PROPS_SIZE + 8];
-    size_t headerSize = LZMA_PROPS_SIZE;
-    UInt64 fileSize;
-    int i;
-
-    res = LzmaEnc_WriteProperties(enc, header, &amp;headerSize);
-    fileSize = MyGetFileLength(inFile);
-    for (i = 0; i &lt; 8; i++)
-      header[headerSize++] = (Byte)(fileSize &gt;&gt; (8 * i));
-    if (!MyWriteFileAndCheck(outFile, header, headerSize))
-      return PrintError(rs, &quot;writing error&quot;);
-
-    if (res == SZ_OK)
-      res = LzmaEnc_Encode(enc, &amp;outStream.funcTable, &amp;inStream.funcTable,
-        NULL, &amp;g_Alloc, &amp;g_Alloc);
-  }
-  LzmaEnc_Destroy(enc, &amp;g_Alloc, &amp;g_Alloc);
-  return res;
-}
-
-int main2(int numArgs, const char *args[], char *rs)
-{
-  FILE *inFile = 0;
-  FILE *outFile = 0;
-  char c;
-  int res;
-  int encodeMode;
-
-  if (numArgs == 1)
-  {
-    PrintHelp(rs);
-    return 0;
-  }
-
-  if (numArgs &lt; 3 || numArgs &gt; 4 || strlen(args[1]) != 1)
-    return PrintUserError(rs);
-
-  c = args[1][0];
-  encodeMode = (c == 'e' || c == 'E');
-  if (!encodeMode &amp;&amp; c != 'd' &amp;&amp; c != 'D')
-    return PrintUserError(rs);
-
-  {
-    size_t t4 = sizeof(UInt32);
-    size_t t8 = sizeof(UInt64);
-    if (t4 != 4 || t8 != 8)
-      return PrintError(rs, &quot;LZMA UTil needs correct UInt32 and UInt64&quot;);
-  }
-
-  inFile = fopen(args[2], &quot;rb&quot;);
-  if (inFile == 0)
-    return PrintError(rs, &quot;Can not open input file&quot;);
-
-  if (numArgs &gt; 3)
-  {
-    outFile = fopen(args[3], &quot;wb+&quot;);
-    if (outFile == 0)
-      return PrintError(rs, &quot;Can not open output file&quot;);
-  }
-  else if (encodeMode)
-    PrintUserError(rs);
-
-  if (encodeMode)
-  {
-    res = Encode(inFile, outFile, rs);
-  }
-  else
-  {
-    res = Decode(inFile, outFile, rs);
-  }
-
-  if (outFile != 0)
-    fclose(outFile);
-  fclose(inFile);
-
-  if (res != SZ_OK)
-  {
-    if (res == SZ_ERROR_MEM)
-      return PrintError(rs, kCantAllocateMessage);
-    else if (res == SZ_ERROR_DATA)
-      return PrintError(rs, kDataErrorMessage);
-    else
-      return PrintErrorNumber(rs, res);
-  }
-  return 0;
-}
-
-int MY_CDECL main(int numArgs, const char *args[])
-{
-  char rs[800] = { 0 };
-  int res = main2(numArgs, args, rs);
-  printf(rs);
-  return res;
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,311 @@
+/* LzmaUtil.c -- Test application for LZMA compression
+2008-08-05
+Igor Pavlov
+public domain */
+
+#define _CRT_SECURE_NO_WARNINGS
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;../LzmaDec.h&quot;
+#include &quot;../LzmaEnc.h&quot;
+#include &quot;../Alloc.h&quot;
+
+const char *kCantReadMessage = &quot;Can not read input file&quot;;
+const char *kCantWriteMessage = &quot;Can not write output file&quot;;
+const char *kCantAllocateMessage = &quot;Can not allocate memory&quot;;
+const char *kDataErrorMessage = &quot;Data error&quot;;
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) {  p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+#define kInBufferSize (1 &lt;&lt; 15)
+#define kOutBufferSize (1 &lt;&lt; 15)
+
+unsigned char g_InBuffer[kInBufferSize];
+unsigned char g_OutBuffer[kOutBufferSize];
+
+size_t MyReadFile(FILE *file, void *data, size_t size)
+  { return fread(data, 1, size, file); }
+
+int MyReadFileAndCheck(FILE *file, void *data, size_t size)
+  { return (MyReadFile(file, data, size) == size); }
+
+size_t MyWriteFile(FILE *file, const void *data, size_t size)
+{
+  if (size == 0)
+    return 0;
+  return fwrite(data, 1, size, file);
+}
+
+int MyWriteFileAndCheck(FILE *file, const void *data, size_t size)
+  { return (MyWriteFile(file, data, size) == size); }
+
+long MyGetFileLength(FILE *file)
+{
+  long length;
+  fseek(file, 0, SEEK_END);
+  length = ftell(file);
+  fseek(file, 0, SEEK_SET);
+  return length;
+}
+
+void PrintHelp(char *buffer)
+{
+  strcat(buffer, &quot;\nLZMA Utility 4.58 Copyright (c) 1999-2008 Igor Pavlov  2008-04-11\n&quot;
+      &quot;\nUsage:  lzma &lt;e|d&gt; inputFile outputFile\n&quot;
+             &quot;  e: encode file\n&quot;
+             &quot;  d: decode file\n&quot;);
+}
+
+int PrintError(char *buffer, const char *message)
+{
+  strcat(buffer, &quot;\nError: &quot;);
+  strcat(buffer, message);
+  strcat(buffer, &quot;\n&quot;);
+  return 1;
+}
+
+int PrintErrorNumber(char *buffer, SRes val)
+{
+  sprintf(buffer + strlen(buffer), &quot;\nError code: %x\n&quot;, (unsigned)val);
+  return 1;
+}
+
+int PrintUserError(char *buffer)
+{
+  return PrintError(buffer, &quot;Incorrect command&quot;);
+}
+
+#define IN_BUF_SIZE (1 &lt;&lt; 16)
+#define OUT_BUF_SIZE (1 &lt;&lt; 16)
+
+static int Decode(FILE *inFile, FILE *outFile, char *rs)
+{
+  UInt64 unpackSize;
+  int thereIsSize; /* = 1, if there is uncompressed size in headers */
+  int i;
+  int res = 0;
+  
+  CLzmaDec state;
+
+  /* header: 5 bytes of LZMA properties and 8 bytes of uncompressed size */
+  unsigned char header[LZMA_PROPS_SIZE + 8];
+
+  /* Read and parse header */
+
+  if (!MyReadFileAndCheck(inFile, header, sizeof(header)))
+    return PrintError(rs, kCantReadMessage);
+
+  unpackSize = 0;
+  thereIsSize = 0;
+  for (i = 0; i &lt; 8; i++)
+  {
+    unsigned char b = header[LZMA_PROPS_SIZE + i];
+    if (b != 0xFF)
+      thereIsSize = 1;
+    unpackSize += (UInt64)b &lt;&lt; (i * 8);
+  }
+
+  LzmaDec_Construct(&amp;state);
+  res = LzmaDec_Allocate(&amp;state, header, LZMA_PROPS_SIZE, &amp;g_Alloc);
+  if (res != SZ_OK)
+    return res;
+  {
+    Byte inBuf[IN_BUF_SIZE];
+    Byte outBuf[OUT_BUF_SIZE];
+    size_t inPos = 0, inSize = 0, outPos = 0;
+    LzmaDec_Init(&amp;state);
+    for (;;)
+    {
+      if (inPos == inSize)
+      {
+        inSize = MyReadFile(inFile, inBuf, IN_BUF_SIZE);
+        inPos = 0;
+      }
+      {
+        SizeT inProcessed = inSize - inPos;
+        SizeT outProcessed = OUT_BUF_SIZE - outPos;
+        ELzmaFinishMode finishMode = LZMA_FINISH_ANY;
+        ELzmaStatus status;
+        if (thereIsSize &amp;&amp; outProcessed &gt; unpackSize)
+        {
+          outProcessed = (SizeT)unpackSize;
+          finishMode = LZMA_FINISH_END;
+        }
+
+        res = LzmaDec_DecodeToBuf(&amp;state, outBuf + outPos, &amp;outProcessed,
+            inBuf + inPos, &amp;inProcessed, finishMode, &amp;status);
+        inPos += (UInt32)inProcessed;
+        outPos += outProcessed;
+        unpackSize -= outProcessed;
+
+        if (outFile != 0)
+          MyWriteFile(outFile, outBuf, outPos);
+        outPos = 0;
+
+        if (res != SZ_OK || thereIsSize &amp;&amp; unpackSize == 0)
+          break;
+
+        if (inProcessed == 0 &amp;&amp; outProcessed == 0)
+        {
+          if (thereIsSize || status != LZMA_STATUS_FINISHED_WITH_MARK)
+            res = SZ_ERROR_DATA;
+          break;
+        }
+      }
+    }
+  }
+
+  LzmaDec_Free(&amp;state, &amp;g_Alloc);
+  return res;
+}
+
+typedef struct _CFileSeqInStream
+{
+  ISeqInStream funcTable;
+  FILE *file;
+} CFileSeqInStream;
+
+static SRes MyRead(void *p, void *buf, size_t *size)
+{
+  if (*size == 0)
+    return SZ_OK;
+  *size = MyReadFile(((CFileSeqInStream*)p)-&gt;file, buf, *size);
+  /*
+  if (*size == 0)
+    return SZE_FAIL;
+  */
+  return SZ_OK;
+}
+
+typedef struct _CFileSeqOutStream
+{
+  ISeqOutStream funcTable;
+  FILE *file;
+} CFileSeqOutStream;
+
+static size_t MyWrite(void *pp, const void *buf, size_t size)
+{
+  return MyWriteFile(((CFileSeqOutStream *)pp)-&gt;file, buf, size);
+}
+
+static SRes Encode(FILE *inFile, FILE *outFile, char *rs)
+{
+  CLzmaEncHandle enc;
+  SRes res;
+  CFileSeqInStream inStream;
+  CFileSeqOutStream outStream;
+  CLzmaEncProps props;
+
+  enc = LzmaEnc_Create(&amp;g_Alloc);
+  if (enc == 0)
+    return SZ_ERROR_MEM;
+
+  inStream.funcTable.Read = MyRead;
+  inStream.file = inFile;
+  outStream.funcTable.Write = MyWrite;
+  outStream.file = outFile;
+
+  LzmaEncProps_Init(&amp;props);
+  res = LzmaEnc_SetProps(enc, &amp;props);
+
+  if (res == SZ_OK)
+  {
+    Byte header[LZMA_PROPS_SIZE + 8];
+    size_t headerSize = LZMA_PROPS_SIZE;
+    UInt64 fileSize;
+    int i;
+
+    res = LzmaEnc_WriteProperties(enc, header, &amp;headerSize);
+    fileSize = MyGetFileLength(inFile);
+    for (i = 0; i &lt; 8; i++)
+      header[headerSize++] = (Byte)(fileSize &gt;&gt; (8 * i));
+    if (!MyWriteFileAndCheck(outFile, header, headerSize))
+      return PrintError(rs, &quot;writing error&quot;);
+
+    if (res == SZ_OK)
+      res = LzmaEnc_Encode(enc, &amp;outStream.funcTable, &amp;inStream.funcTable,
+        NULL, &amp;g_Alloc, &amp;g_Alloc);
+  }
+  LzmaEnc_Destroy(enc, &amp;g_Alloc, &amp;g_Alloc);
+  return res;
+}
+
+int main2(int numArgs, const char *args[], char *rs)
+{
+  FILE *inFile = 0;
+  FILE *outFile = 0;
+  char c;
+  int res;
+  int encodeMode;
+
+  if (numArgs == 1)
+  {
+    PrintHelp(rs);
+    return 0;
+  }
+
+  if (numArgs &lt; 3 || numArgs &gt; 4 || strlen(args[1]) != 1)
+    return PrintUserError(rs);
+
+  c = args[1][0];
+  encodeMode = (c == 'e' || c == 'E');
+  if (!encodeMode &amp;&amp; c != 'd' &amp;&amp; c != 'D')
+    return PrintUserError(rs);
+
+  {
+    size_t t4 = sizeof(UInt32);
+    size_t t8 = sizeof(UInt64);
+    if (t4 != 4 || t8 != 8)
+      return PrintError(rs, &quot;LZMA UTil needs correct UInt32 and UInt64&quot;);
+  }
+
+  inFile = fopen(args[2], &quot;rb&quot;);
+  if (inFile == 0)
+    return PrintError(rs, &quot;Can not open input file&quot;);
+
+  if (numArgs &gt; 3)
+  {
+    outFile = fopen(args[3], &quot;wb+&quot;);
+    if (outFile == 0)
+      return PrintError(rs, &quot;Can not open output file&quot;);
+  }
+  else if (encodeMode)
+    PrintUserError(rs);
+
+  if (encodeMode)
+  {
+    res = Encode(inFile, outFile, rs);
+  }
+  else
+  {
+    res = Decode(inFile, outFile, rs);
+  }
+
+  if (outFile != 0)
+    fclose(outFile);
+  fclose(inFile);
+
+  if (res != SZ_OK)
+  {
+    if (res == SZ_ERROR_MEM)
+      return PrintError(rs, kCantAllocateMessage);
+    else if (res == SZ_ERROR_DATA)
+      return PrintError(rs, kDataErrorMessage);
+    else
+      return PrintErrorNumber(rs, res);
+  }
+  return 0;
+}
+
+int MY_CDECL main(int numArgs, const char *args[])
+{
+  char rs[800] = { 0 };
+  int res = main2(numArgs, args, rs);
+  printf(rs);
+  return res;
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,152 +0,0 @@
-# Microsoft Developer Studio Project File - Name=&quot;LzmaUtil&quot; - Package Owner=&lt;4&gt;
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
-
-CFG=LzmaUtil - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;LzmaUtil.mak&quot;.
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f &quot;LzmaUtil.mak&quot; CFG=&quot;LzmaUtil - Win32 Debug&quot;
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE &quot;LzmaUtil - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
-!MESSAGE &quot;LzmaUtil - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName &quot;&quot;
-# PROP Scc_LocalPath &quot;&quot;
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  &quot;$(CFG)&quot; == &quot;LzmaUtil - Win32 Release&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir &quot;Release&quot;
-# PROP BASE Intermediate_Dir &quot;Release&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir &quot;Release&quot;
-# PROP Intermediate_Dir &quot;Release&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
-# ADD CPP /nologo /MT /W3 /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;c:\util\lzmac.exe&quot;
-
-!ELSEIF  &quot;$(CFG)&quot; == &quot;LzmaUtil - Win32 Debug&quot;
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir &quot;Debug&quot;
-# PROP BASE Intermediate_Dir &quot;Debug&quot;
-# PROP BASE Target_Dir &quot;&quot;
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir &quot;Debug&quot;
-# PROP Intermediate_Dir &quot;Debug&quot;
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir &quot;&quot;
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
-# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;c:\util\lzmac.exe&quot; /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name &quot;LzmaUtil - Win32 Release&quot;
-# Name &quot;LzmaUtil - Win32 Debug&quot;
-# Begin Source File
-
-SOURCE=..\Alloc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Alloc.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\CpuArch.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFind.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFind.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFindMt.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzFindMt.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzHash.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaDec.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaDec.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaEnc.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\LzmaEnc.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\LzmaUtil.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Threads.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\Threads.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\Types.h
-# End Source File
-# End Target
-# End Project

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,152 @@
+# Microsoft Developer Studio Project File - Name=&quot;LzmaUtil&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
+
+CFG=LzmaUtil - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;LzmaUtil.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;LzmaUtil.mak&quot; CFG=&quot;LzmaUtil - Win32 Debug&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;LzmaUtil - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE &quot;LzmaUtil - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;LzmaUtil - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD CPP /nologo /MT /W3 /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;c:\util\lzmac.exe&quot;
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;LzmaUtil - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;c:\util\lzmac.exe&quot; /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;LzmaUtil - Win32 Release&quot;
+# Name &quot;LzmaUtil - Win32 Debug&quot;
+# Begin Source File
+
+SOURCE=..\Alloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Alloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\CpuArch.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzHash.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaUtil.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\Types.h
+# End Source File
+# End Target
+# End Project

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,29 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: &quot;LzmaUtil&quot;=.\LzmaUtil.dsp - Package Owner=&lt;4&gt;
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;4&gt;
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=&lt;5&gt;
-{{{
-}}}
-
-Package=&lt;3&gt;
-{{{
-}}}
-
-###############################################################################
-

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/LzmaUtil.dsw	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;LzmaUtil&quot;=.\LzmaUtil.dsp - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,27 +0,0 @@
-MY_STATIC_LINK=1
-PROG = LZMAc.exe
-
-CFLAGS = $(CFLAGS) \
-  -DCOMPRESS_MF_MT \
-
-LIB_OBJS = \
-  $O\LzmaUtil.obj \
-
-C_OBJS = \
-  $O\Alloc.obj \
-  $O\LzFind.obj \
-  $O\LzFindMt.obj \
-  $O\LzmaDec.obj \
-  $O\LzmaEnc.obj \
-  $O\Threads.obj \
-
-OBJS = \
-  $(LIB_OBJS) \
-  $(C_OBJS) \
-
-!include &quot;../../CPP/Build.mak&quot;
-
-$(LIB_OBJS): $(*B).c
-	$(COMPL_O2)
-$(C_OBJS): ../$(*B).c
-	$(COMPL_O2)

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,27 @@
+MY_STATIC_LINK=1
+PROG = LZMAc.exe
+
+CFLAGS = $(CFLAGS) \
+  -DCOMPRESS_MF_MT \
+
+LIB_OBJS = \
+  $O\LzmaUtil.obj \
+
+C_OBJS = \
+  $O\Alloc.obj \
+  $O\LzFind.obj \
+  $O\LzFindMt.obj \
+  $O\LzmaDec.obj \
+  $O\LzmaEnc.obj \
+  $O\Threads.obj \
+
+OBJS = \
+  $(LIB_OBJS) \
+  $(C_OBJS) \
+
+!include &quot;../../CPP/Build.mak&quot;
+
+$(LIB_OBJS): $(*B).c
+	$(COMPL_O2)
+$(C_OBJS): ../$(*B).c
+	$(COMPL_O2)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,36 +0,0 @@
-PROG = lzma
-CXX = g++
-LIB =
-RM = rm -f
-CFLAGS = -c -O2 -Wall
-
-OBJS = \
-  LzmaUtil.o \
-  Alloc.o \
-  LzFind.o \
-  LzmaDec.o \
-  LzmaEnc.o \
-
-
-all: $(PROG)
-
-$(PROG): $(OBJS)
-	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB) $(LIB2)
-
-LzmaUtil.o: LzmaUtil.c
-	$(CXX) $(CFLAGS) LzmaUtil.c
-
-Alloc.o: ../Alloc.c
-	$(CXX) $(CFLAGS) ../Alloc.c
-
-LzFind.o: ../LzFind.c
-	$(CXX) $(CFLAGS) ../LzFind.c
-
-LzmaDec.o: ../LzmaDec.c
-	$(CXX) $(CFLAGS) ../LzmaDec.c
-
-LzmaEnc.o: ../LzmaEnc.c
-	$(CXX) $(CFLAGS) ../LzmaEnc.c
-
-clean:
-	-$(RM) $(PROG) $(OBJS)

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/LzmaUtil/makefile.gcc	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,36 @@
+PROG = lzma
+CXX = g++
+LIB =
+RM = rm -f
+CFLAGS = -c -O2 -Wall
+
+OBJS = \
+  LzmaUtil.o \
+  Alloc.o \
+  LzFind.o \
+  LzmaDec.o \
+  LzmaEnc.o \
+
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB) $(LIB2)
+
+LzmaUtil.o: LzmaUtil.c
+	$(CXX) $(CFLAGS) LzmaUtil.c
+
+Alloc.o: ../Alloc.c
+	$(CXX) $(CFLAGS) ../Alloc.c
+
+LzFind.o: ../LzFind.c
+	$(CXX) $(CFLAGS) ../LzFind.c
+
+LzmaDec.o: ../LzmaDec.c
+	$(CXX) $(CFLAGS) ../LzmaDec.c
+
+LzmaEnc.o: ../LzmaEnc.c
+	$(CXX) $(CFLAGS) ../LzmaEnc.c
+
+clean:
+	-$(RM) $(PROG) $(OBJS)

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,109 +0,0 @@
-/* Threads.c -- multithreading library
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#include &quot;Threads.h&quot;
-#include &lt;process.h&gt;
-
-static WRes GetError()
-{
-  DWORD res = GetLastError();
-  return (res) ? (WRes)(res) : 1;
-}
-
-WRes HandleToWRes(HANDLE h) { return (h != 0) ? 0 : GetError(); }
-WRes BOOLToWRes(BOOL v) { return v ? 0 : GetError(); }
-
-static WRes MyCloseHandle(HANDLE *h)
-{
-  if (*h != NULL)
-    if (!CloseHandle(*h))
-      return GetError();
-  *h = NULL;
-  return 0;
-}
-
-WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter)
-{
-  unsigned threadId; /* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
-  thread-&gt;handle =
-    /* CreateThread(0, 0, startAddress, parameter, 0, &amp;threadId); */
-    (HANDLE)_beginthreadex(NULL, 0, startAddress, parameter, 0, &amp;threadId);
-    /* maybe we must use errno here, but probably GetLastError() is also OK. */
-  return HandleToWRes(thread-&gt;handle);
-}
-
-WRes WaitObject(HANDLE h)
-{
-  return (WRes)WaitForSingleObject(h, INFINITE);
-}
-
-WRes Thread_Wait(CThread *thread)
-{
-  if (thread-&gt;handle == NULL)
-    return 1;
-  return WaitObject(thread-&gt;handle);
-}
-
-WRes Thread_Close(CThread *thread)
-{
-  return MyCloseHandle(&amp;thread-&gt;handle);
-}
-
-WRes Event_Create(CEvent *p, BOOL manualReset, int initialSignaled)
-{
-  p-&gt;handle = CreateEvent(NULL, manualReset, (initialSignaled ? TRUE : FALSE), NULL);
-  return HandleToWRes(p-&gt;handle);
-}
-
-WRes ManualResetEvent_Create(CManualResetEvent *p, int initialSignaled)
-  { return Event_Create(p, TRUE, initialSignaled); }
-WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p)
-  { return ManualResetEvent_Create(p, 0); }
-
-WRes AutoResetEvent_Create(CAutoResetEvent *p, int initialSignaled)
-  { return Event_Create(p, FALSE, initialSignaled); }
-WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p)
-  { return AutoResetEvent_Create(p, 0); }
-
-WRes Event_Set(CEvent *p) { return BOOLToWRes(SetEvent(p-&gt;handle)); }
-WRes Event_Reset(CEvent *p) { return BOOLToWRes(ResetEvent(p-&gt;handle)); }
-WRes Event_Wait(CEvent *p) { return WaitObject(p-&gt;handle); }
-WRes Event_Close(CEvent *p) { return MyCloseHandle(&amp;p-&gt;handle); }
-
-
-WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount)
-{
-  p-&gt;handle = CreateSemaphore(NULL, (LONG)initiallyCount, (LONG)maxCount, NULL);
-  return HandleToWRes(p-&gt;handle);
-}
-
-WRes Semaphore_Release(CSemaphore *p, LONG releaseCount, LONG *previousCount)
-{
-  return BOOLToWRes(ReleaseSemaphore(p-&gt;handle, releaseCount, previousCount));
-}
-WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 releaseCount)
-{
-  return Semaphore_Release(p, (LONG)releaseCount, NULL);
-}
-WRes Semaphore_Release1(CSemaphore *p)
-{
-  return Semaphore_ReleaseN(p, 1);
-}
-
-WRes Semaphore_Wait(CSemaphore *p) { return WaitObject(p-&gt;handle); }
-WRes Semaphore_Close(CSemaphore *p) { return MyCloseHandle(&amp;p-&gt;handle); }
-
-WRes CriticalSection_Init(CCriticalSection *p)
-{
-  /* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
-  __try
-  {
-    InitializeCriticalSection(p);
-    /* InitializeCriticalSectionAndSpinCount(p, 0); */
-  }
-  __except (EXCEPTION_EXECUTE_HANDLER) { return 1; }
-  return 0;
-}
-

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,109 @@
+/* Threads.c -- multithreading library
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include &quot;Threads.h&quot;
+#include &lt;process.h&gt;
+
+static WRes GetError()
+{
+  DWORD res = GetLastError();
+  return (res) ? (WRes)(res) : 1;
+}
+
+WRes HandleToWRes(HANDLE h) { return (h != 0) ? 0 : GetError(); }
+WRes BOOLToWRes(BOOL v) { return v ? 0 : GetError(); }
+
+static WRes MyCloseHandle(HANDLE *h)
+{
+  if (*h != NULL)
+    if (!CloseHandle(*h))
+      return GetError();
+  *h = NULL;
+  return 0;
+}
+
+WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter)
+{
+  unsigned threadId; /* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
+  thread-&gt;handle =
+    /* CreateThread(0, 0, startAddress, parameter, 0, &amp;threadId); */
+    (HANDLE)_beginthreadex(NULL, 0, startAddress, parameter, 0, &amp;threadId);
+    /* maybe we must use errno here, but probably GetLastError() is also OK. */
+  return HandleToWRes(thread-&gt;handle);
+}
+
+WRes WaitObject(HANDLE h)
+{
+  return (WRes)WaitForSingleObject(h, INFINITE);
+}
+
+WRes Thread_Wait(CThread *thread)
+{
+  if (thread-&gt;handle == NULL)
+    return 1;
+  return WaitObject(thread-&gt;handle);
+}
+
+WRes Thread_Close(CThread *thread)
+{
+  return MyCloseHandle(&amp;thread-&gt;handle);
+}
+
+WRes Event_Create(CEvent *p, BOOL manualReset, int initialSignaled)
+{
+  p-&gt;handle = CreateEvent(NULL, manualReset, (initialSignaled ? TRUE : FALSE), NULL);
+  return HandleToWRes(p-&gt;handle);
+}
+
+WRes ManualResetEvent_Create(CManualResetEvent *p, int initialSignaled)
+  { return Event_Create(p, TRUE, initialSignaled); }
+WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p)
+  { return ManualResetEvent_Create(p, 0); }
+
+WRes AutoResetEvent_Create(CAutoResetEvent *p, int initialSignaled)
+  { return Event_Create(p, FALSE, initialSignaled); }
+WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p)
+  { return AutoResetEvent_Create(p, 0); }
+
+WRes Event_Set(CEvent *p) { return BOOLToWRes(SetEvent(p-&gt;handle)); }
+WRes Event_Reset(CEvent *p) { return BOOLToWRes(ResetEvent(p-&gt;handle)); }
+WRes Event_Wait(CEvent *p) { return WaitObject(p-&gt;handle); }
+WRes Event_Close(CEvent *p) { return MyCloseHandle(&amp;p-&gt;handle); }
+
+
+WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount)
+{
+  p-&gt;handle = CreateSemaphore(NULL, (LONG)initiallyCount, (LONG)maxCount, NULL);
+  return HandleToWRes(p-&gt;handle);
+}
+
+WRes Semaphore_Release(CSemaphore *p, LONG releaseCount, LONG *previousCount)
+{
+  return BOOLToWRes(ReleaseSemaphore(p-&gt;handle, releaseCount, previousCount));
+}
+WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 releaseCount)
+{
+  return Semaphore_Release(p, (LONG)releaseCount, NULL);
+}
+WRes Semaphore_Release1(CSemaphore *p)
+{
+  return Semaphore_ReleaseN(p, 1);
+}
+
+WRes Semaphore_Wait(CSemaphore *p) { return WaitObject(p-&gt;handle); }
+WRes Semaphore_Close(CSemaphore *p) { return MyCloseHandle(&amp;p-&gt;handle); }
+
+WRes CriticalSection_Init(CCriticalSection *p)
+{
+  /* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
+  __try
+  {
+    InitializeCriticalSection(p);
+    /* InitializeCriticalSectionAndSpinCount(p, 0); */
+  }
+  __except (EXCEPTION_EXECUTE_HANDLER) { return 1; }
+  return 0;
+}
+

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,74 +0,0 @@
-/* Threads.h -- multithreading library
-2008-04-11
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_THRESDS_H
-#define __7Z_THRESDS_H
-
-#include &lt;windows.h&gt;
-
-#include &quot;Types.h&quot;
-
-typedef struct _CThread
-{
-  HANDLE handle;
-} CThread;
-
-#define Thread_Construct(thread) (thread)-&gt;handle = NULL
-#define Thread_WasCreated(thread) ((thread)-&gt;handle != NULL)
- 
-typedef unsigned THREAD_FUNC_RET_TYPE;
-#define THREAD_FUNC_CALL_TYPE MY_STD_CALL
-#define THREAD_FUNC_DECL THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPE
-
-typedef DWORD WRes;
-
-WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter);
-WRes Thread_Wait(CThread *thread);
-WRes Thread_Close(CThread *thread);
-
-typedef struct _CEvent
-{
-  HANDLE handle;
-} CEvent;
-
-typedef CEvent CAutoResetEvent;
-typedef CEvent CManualResetEvent;
-
-#define Event_Construct(event) (event)-&gt;handle = NULL
-#define Event_IsCreated(event) ((event)-&gt;handle != NULL)
-
-WRes ManualResetEvent_Create(CManualResetEvent *event, int initialSignaled);
-WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *event);
-WRes AutoResetEvent_Create(CAutoResetEvent *event, int initialSignaled);
-WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *event);
-WRes Event_Set(CEvent *event);
-WRes Event_Reset(CEvent *event);
-WRes Event_Wait(CEvent *event);
-WRes Event_Close(CEvent *event);
-
-
-typedef struct _CSemaphore
-{
-  HANDLE handle;
-} CSemaphore;
-
-#define Semaphore_Construct(p) (p)-&gt;handle = NULL
-
-WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount);
-WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 num);
-WRes Semaphore_Release1(CSemaphore *p);
-WRes Semaphore_Wait(CSemaphore *p);
-WRes Semaphore_Close(CSemaphore *p);
-
-
-typedef CRITICAL_SECTION CCriticalSection;
-
-WRes CriticalSection_Init(CCriticalSection *p);
-#define CriticalSection_Delete(p) DeleteCriticalSection(p)
-#define CriticalSection_Enter(p) EnterCriticalSection(p)
-#define CriticalSection_Leave(p) LeaveCriticalSection(p)
-
-#endif
-

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Threads.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,74 @@
+/* Threads.h -- multithreading library
+2008-04-11
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_THRESDS_H
+#define __7Z_THRESDS_H
+
+#include &lt;windows.h&gt;
+
+#include &quot;Types.h&quot;
+
+typedef struct _CThread
+{
+  HANDLE handle;
+} CThread;
+
+#define Thread_Construct(thread) (thread)-&gt;handle = NULL
+#define Thread_WasCreated(thread) ((thread)-&gt;handle != NULL)
+ 
+typedef unsigned THREAD_FUNC_RET_TYPE;
+#define THREAD_FUNC_CALL_TYPE MY_STD_CALL
+#define THREAD_FUNC_DECL THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPE
+
+typedef DWORD WRes;
+
+WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter);
+WRes Thread_Wait(CThread *thread);
+WRes Thread_Close(CThread *thread);
+
+typedef struct _CEvent
+{
+  HANDLE handle;
+} CEvent;
+
+typedef CEvent CAutoResetEvent;
+typedef CEvent CManualResetEvent;
+
+#define Event_Construct(event) (event)-&gt;handle = NULL
+#define Event_IsCreated(event) ((event)-&gt;handle != NULL)
+
+WRes ManualResetEvent_Create(CManualResetEvent *event, int initialSignaled);
+WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *event);
+WRes AutoResetEvent_Create(CAutoResetEvent *event, int initialSignaled);
+WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *event);
+WRes Event_Set(CEvent *event);
+WRes Event_Reset(CEvent *event);
+WRes Event_Wait(CEvent *event);
+WRes Event_Close(CEvent *event);
+
+
+typedef struct _CSemaphore
+{
+  HANDLE handle;
+} CSemaphore;
+
+#define Semaphore_Construct(p) (p)-&gt;handle = NULL
+
+WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount);
+WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 num);
+WRes Semaphore_Release1(CSemaphore *p);
+WRes Semaphore_Wait(CSemaphore *p);
+WRes Semaphore_Close(CSemaphore *p);
+
+
+typedef CRITICAL_SECTION CCriticalSection;
+
+WRes CriticalSection_Init(CCriticalSection *p);
+#define CriticalSection_Delete(p) DeleteCriticalSection(p)
+#define CriticalSection_Enter(p) EnterCriticalSection(p)
+#define CriticalSection_Leave(p) LeaveCriticalSection(p)
+
+#endif
+

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,130 +0,0 @@
-/* Types.h -- Basic types
-2008-08-05
-Igor Pavlov
-Public domain */
-
-#ifndef __7Z_TYPES_H
-#define __7Z_TYPES_H
-
-#define SZ_OK 0
-
-#define SZ_ERROR_DATA 1
-#define SZ_ERROR_MEM 2
-#define SZ_ERROR_CRC 3
-#define SZ_ERROR_UNSUPPORTED 4
-#define SZ_ERROR_PARAM 5
-#define SZ_ERROR_INPUT_EOF 6
-#define SZ_ERROR_OUTPUT_EOF 7
-#define SZ_ERROR_READ 8
-#define SZ_ERROR_WRITE 9
-#define SZ_ERROR_PROGRESS 10
-#define SZ_ERROR_FAIL 11
-#define SZ_ERROR_THREAD 12
-
-#define SZ_ERROR_ARCHIVE 16
-#define SZ_ERROR_NO_ARCHIVE 17
-
-typedef int SRes;
-
-#ifndef RINOK
-#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
-#endif
-
-typedef unsigned char Byte;
-typedef short Int16;
-typedef unsigned short UInt16;
-
-#ifdef _LZMA_UINT32_IS_ULONG
-typedef long Int32;
-typedef unsigned long UInt32;
-#else
-typedef int Int32;
-typedef unsigned int UInt32;
-#endif
-
-/* #define _SZ_NO_INT_64 */
-/* define it if your compiler doesn't support 64-bit integers */
-
-#ifdef _SZ_NO_INT_64
-
-typedef long Int64;
-typedef unsigned long UInt64;
-
-#else
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-typedef __int64 Int64;
-typedef unsigned __int64 UInt64;
-#else
-typedef long long int Int64;
-typedef unsigned long long int UInt64;
-#endif
-
-#endif
-
-#ifdef _LZMA_NO_SYSTEM_SIZE_T
-typedef UInt32 SizeT;
-#else
-#include &lt;stddef.h&gt;
-typedef size_t SizeT;
-#endif
-
-typedef int Bool;
-#define True 1
-#define False 0
-
-
-#ifdef _MSC_VER
-
-#if _MSC_VER &gt;= 1300
-#define MY_NO_INLINE __declspec(noinline)
-#else
-#define MY_NO_INLINE
-#endif
-
-#define MY_CDECL __cdecl
-#define MY_STD_CALL __stdcall
-#define MY_FAST_CALL MY_NO_INLINE __fastcall
-
-#else
-
-#define MY_CDECL
-#define MY_STD_CALL
-#define MY_FAST_CALL
-
-#endif
-
-
-/* The following interfaces use first parameter as pointer to structure */
-
-typedef struct
-{
-  SRes (*Read)(void *p, void *buf, size_t *size);
-    /* if (input(*size) != 0 &amp;&amp; output(*size) == 0) means end_of_stream.
-       (output(*size) &lt; input(*size)) is allowed */
-} ISeqInStream;
-
-typedef struct
-{
-  size_t (*Write)(void *p, const void *buf, size_t size);
-    /* Returns: result - the number of actually written bytes.
-      (result &lt; size) means error */
-} ISeqOutStream;
-
-typedef struct
-{
-  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
-    /* Returns: result. (result != SZ_OK) means break.
-       Value (UInt64)(Int64)-1 for size means unknown value. */
-} ICompressProgress;
-
-typedef struct
-{
-  void *(*Alloc)(void *p, size_t size);
-  void (*Free)(void *p, void *address); /* address can be 0 */
-} ISzAlloc;
-
-#define IAlloc_Alloc(p, size) (p)-&gt;Alloc((p), size)
-#define IAlloc_Free(p, a) (p)-&gt;Free((p), a)
-
-#endif

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/libsevenzip/Types.h	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,130 @@
+/* Types.h -- Basic types
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_TYPES_H
+#define __7Z_TYPES_H
+
+#define SZ_OK 0
+
+#define SZ_ERROR_DATA 1
+#define SZ_ERROR_MEM 2
+#define SZ_ERROR_CRC 3
+#define SZ_ERROR_UNSUPPORTED 4
+#define SZ_ERROR_PARAM 5
+#define SZ_ERROR_INPUT_EOF 6
+#define SZ_ERROR_OUTPUT_EOF 7
+#define SZ_ERROR_READ 8
+#define SZ_ERROR_WRITE 9
+#define SZ_ERROR_PROGRESS 10
+#define SZ_ERROR_FAIL 11
+#define SZ_ERROR_THREAD 12
+
+#define SZ_ERROR_ARCHIVE 16
+#define SZ_ERROR_NO_ARCHIVE 17
+
+typedef int SRes;
+
+#ifndef RINOK
+#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
+#endif
+
+typedef unsigned char Byte;
+typedef short Int16;
+typedef unsigned short UInt16;
+
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef long Int32;
+typedef unsigned long UInt32;
+#else
+typedef int Int32;
+typedef unsigned int UInt32;
+#endif
+
+/* #define _SZ_NO_INT_64 */
+/* define it if your compiler doesn't support 64-bit integers */
+
+#ifdef _SZ_NO_INT_64
+
+typedef long Int64;
+typedef unsigned long UInt64;
+
+#else
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+typedef __int64 Int64;
+typedef unsigned __int64 UInt64;
+#else
+typedef long long int Int64;
+typedef unsigned long long int UInt64;
+#endif
+
+#endif
+
+#ifdef _LZMA_NO_SYSTEM_SIZE_T
+typedef UInt32 SizeT;
+#else
+#include &lt;stddef.h&gt;
+typedef size_t SizeT;
+#endif
+
+typedef int Bool;
+#define True 1
+#define False 0
+
+
+#ifdef _MSC_VER
+
+#if _MSC_VER &gt;= 1300
+#define MY_NO_INLINE __declspec(noinline)
+#else
+#define MY_NO_INLINE
+#endif
+
+#define MY_CDECL __cdecl
+#define MY_STD_CALL __stdcall
+#define MY_FAST_CALL MY_NO_INLINE __fastcall
+
+#else
+
+#define MY_CDECL
+#define MY_STD_CALL
+#define MY_FAST_CALL
+
+#endif
+
+
+/* The following interfaces use first parameter as pointer to structure */
+
+typedef struct
+{
+  SRes (*Read)(void *p, void *buf, size_t *size);
+    /* if (input(*size) != 0 &amp;&amp; output(*size) == 0) means end_of_stream.
+       (output(*size) &lt; input(*size)) is allowed */
+} ISeqInStream;
+
+typedef struct
+{
+  size_t (*Write)(void *p, const void *buf, size_t size);
+    /* Returns: result - the number of actually written bytes.
+      (result &lt; size) means error */
+} ISeqOutStream;
+
+typedef struct
+{
+  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
+    /* Returns: result. (result != SZ_OK) means break.
+       Value (UInt64)(Int64)-1 for size means unknown value. */
+} ICompressProgress;
+
+typedef struct
+{
+  void *(*Alloc)(void *p, size_t size);
+  void (*Free)(void *p, void *address); /* address can be 0 */
+} ISzAlloc;
+
+#define IAlloc_Alloc(p, size) (p)-&gt;Alloc((p), size)
+#define IAlloc_Free(p, a) (p)-&gt;Free((p), a)
+
+#endif

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,191 +0,0 @@
-#include &lt;stdio.h&gt;
-
-#include &lt;caml/mlvalues.h&gt;
-#include &lt;caml/fail.h&gt;
-#include &lt;caml/alloc.h&gt;
-#include &lt;caml/memory.h&gt;
-#include &lt;caml/callback.h&gt;
-#include &lt;caml/custom.h&gt;
-
-#include &quot;libsevenzip/Archive/7z/7zIn.h&quot;
-#include &quot;libsevenzip/Archive/7z/7zAlloc.h&quot;
-#include &quot;libsevenzip/7zCrc.h&quot;
-
-
-static ISzAlloc allocImp;
-static ISzAlloc allocTempImp;
-
-/* Sevenzip.in_file */
-
-#define sevenzip_in_file_val(v) (*((CSzArEx *) Data_custom_val(v)))
-
-static void finalize_sevenzip_in_file(value sevenzip)
-{
-  CSzArEx db = sevenzip_in_file_val(sevenzip);
-  SzArEx_Free(&amp;db, &amp;allocImp);
-}
-
-static struct custom_operations sevenzip_in_file_ops = {
-  &quot;org.detrino.sevenzip&quot;,
-  finalize_sevenzip_in_file,
-  custom_compare_default,
-  custom_hash_default,
-  custom_serialize_default,
-  custom_deserialize_default
-};
-
-static value alloc_sevenzip_in_file(CSzArEx db)
-{
-  CAMLparam0 ();
-  CAMLlocal1 (sevenzip);
-  sevenzip = alloc_custom(&amp;sevenzip_in_file_ops, sizeof(CSzArEx), 0, 1);
-  sevenzip_in_file_val(sevenzip) = db;
-  CAMLreturn (sevenzip);
-}
-
-/* Sevenzip.entry */
-
-static value alloc_sevenzip_entry(CSzArEx db, int i)
-{
-
-  CSzFileItem *f = db.db.Files + i;
-  CAMLparam0 ();
-  CAMLlocal5 (entry, index, name, size, is_directory);
-
-  entry = caml_alloc (4, 0);
-  index = Val_int(i);
-  name = caml_copy_string(f-&gt;Name);
-  size = Val_int(f-&gt;Size);
-  is_directory = Val_bool(f-&gt;IsDir);
-
-  Store_field (entry, 0, index);
-  Store_field (entry, 1, name);
-  Store_field (entry, 2, size);
-  Store_field (entry, 3, is_directory);
-
-  CAMLreturn (entry);
-}
-
-/* Sevenzip.init */
-
-value ml_sevenzip_init(value unit)
-{
-  CAMLparam1 (unit);
-
-  CrcGenerateTable();
-
-  allocImp.Alloc = SzAlloc;
-  allocImp.Free = SzFree;
-  allocTempImp.Alloc = SzAllocTemp;
-  allocTempImp.Free = SzFreeTemp;
-
-  CAMLreturn (Val_unit);
-}
-
-/* Sevenzip.readable */
-
-typedef struct _CFileInStream {
-  ISzInStream funcs;
-  value readable;
-} CFileInStream;
-
-SRes ml_sevenzip_read(void *object, void **buffer, size_t *size)
-{
-
-  CFileInStream *archive_in = (CFileInStream *) object;
-  CAMLparam0 ();
-  CAMLlocal5 (readable, read, tuple, ml_string, ml_size);
-
-  readable = archive_in-&gt;readable;
-  read = Field(readable, 0);
-  tuple = caml_callback(read, Val_int(*size));
-  ml_string = Field(tuple, 0);
-  ml_size = Field(tuple, 1);
-  *buffer = String_val(ml_string);
-  *size = Int_val(ml_size);
-
-  /* The GC might have moved the readable pointer */
-  archive_in-&gt;readable = readable;
-
-  CAMLreturnT(SRes, SZ_OK);
-}
-
-SRes ml_sevenzip_seek(void *object, CFileSize pos, ESzSeek origin)
-{
-  CFileInStream *archive_in = (CFileInStream *) object;
-  CAMLparam0 ();
-  CAMLlocal3 (readable, seek, term);
-
-  readable = archive_in-&gt;readable;
-  seek = Field(readable, 1);
-
-  switch (origin) {
-
-  case SZ_SEEK_SET: term = Val_int(0); break;
-  case SZ_SEEK_CUR: term = Val_int(1); break;
-  case SZ_SEEK_END: term = Val_int(2); break;
-
-  }
-
-  caml_callback2(seek, Val_int(pos), term);
-
-  /* The GC might have moved the readable pointer */
-  archive_in-&gt;readable = readable;
-
-  CAMLreturnT(SRes, SZ_OK);
-}
-
-/* Sevenzip.open_readable */
-
-value ml_sevenzip_open_readable (value readable)
-{
-  CAMLparam1 (readable);
-  CAMLlocal1 (sevenzip);
-
-  CFileInStream archive_in;
-  CSzArEx db;
-  SRes res;
-
-  archive_in.funcs.Read = ml_sevenzip_read;
-  archive_in.funcs.Seek = ml_sevenzip_seek;
-  archive_in.readable = readable;
-
-  SzArEx_Init(&amp;db);
-  res = SzArEx_Open(&amp;db, &amp;archive_in.funcs, &amp;allocImp, &amp;allocTempImp);
-
-  switch (res) {
-
-  case SZ_OK: break;
-  case SZ_ERROR_NO_ARCHIVE: caml_failwith(&quot;NO ARCHIVE&quot;);
-  case SZ_ERROR_ARCHIVE: caml_failwith(&quot;ARCHIVE&quot;);
-  case SZ_ERROR_UNSUPPORTED: caml_failwith(&quot;UNSUPPORTED&quot;);
-  case SZ_ERROR_MEM: caml_failwith(&quot;MEM&quot;);
-  case SZ_ERROR_CRC: caml_failwith(&quot;CRC&quot;);
-  case SZ_ERROR_INPUT_EOF: caml_failwith(&quot;INPUT_EOF&quot;);
-  case SZ_ERROR_FAIL:
-  default: caml_failwith(&quot;FAIL&quot;);
-
-  }
-
-  sevenzip = alloc_sevenzip_in_file(db);
-  CAMLreturn (sevenzip);
-}
-
-/* Sevenzip.entries */
-
-value ml_sevenzip_entries(value sevenzip)
-{
-  CAMLparam1 (sevenzip);
-  CAMLlocal2 (entries, entry);
-  CSzArEx db = sevenzip_in_file_val(sevenzip);
-
-  entries = caml_alloc (db.db.NumFiles, 0);
-
-  UInt32 i;
-  for (i = 0; i &lt; db.db.NumFiles; i++) {
-    entry = alloc_sevenzip_entry(db, i);
-    Store_field (entries, i, entry);
-  }
-
-  CAMLreturn (entries);
-}

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/ml_sevenzip.c	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,191 @@
+#include &lt;stdio.h&gt;
+
+#include &lt;caml/mlvalues.h&gt;
+#include &lt;caml/fail.h&gt;
+#include &lt;caml/alloc.h&gt;
+#include &lt;caml/memory.h&gt;
+#include &lt;caml/callback.h&gt;
+#include &lt;caml/custom.h&gt;
+
+#include &quot;libsevenzip/Archive/7z/7zIn.h&quot;
+#include &quot;libsevenzip/Archive/7z/7zAlloc.h&quot;
+#include &quot;libsevenzip/7zCrc.h&quot;
+
+
+static ISzAlloc allocImp;
+static ISzAlloc allocTempImp;
+
+/* Sevenzip.in_file */
+
+#define sevenzip_in_file_val(v) (*((CSzArEx *) Data_custom_val(v)))
+
+static void finalize_sevenzip_in_file(value sevenzip)
+{
+  CSzArEx db = sevenzip_in_file_val(sevenzip);
+  SzArEx_Free(&amp;db, &amp;allocImp);
+}
+
+static struct custom_operations sevenzip_in_file_ops = {
+  &quot;org.detrino.sevenzip&quot;,
+  finalize_sevenzip_in_file,
+  custom_compare_default,
+  custom_hash_default,
+  custom_serialize_default,
+  custom_deserialize_default
+};
+
+static value alloc_sevenzip_in_file(CSzArEx db)
+{
+  CAMLparam0 ();
+  CAMLlocal1 (sevenzip);
+  sevenzip = alloc_custom(&amp;sevenzip_in_file_ops, sizeof(CSzArEx), 0, 1);
+  sevenzip_in_file_val(sevenzip) = db;
+  CAMLreturn (sevenzip);
+}
+
+/* Sevenzip.entry */
+
+static value alloc_sevenzip_entry(CSzArEx db, int i)
+{
+
+  CSzFileItem *f = db.db.Files + i;
+  CAMLparam0 ();
+  CAMLlocal5 (entry, index, name, size, is_directory);
+
+  entry = caml_alloc (4, 0);
+  index = Val_int(i);
+  name = caml_copy_string(f-&gt;Name);
+  size = Val_int(f-&gt;Size);
+  is_directory = Val_bool(f-&gt;IsDir);
+
+  Store_field (entry, 0, index);
+  Store_field (entry, 1, name);
+  Store_field (entry, 2, size);
+  Store_field (entry, 3, is_directory);
+
+  CAMLreturn (entry);
+}
+
+/* Sevenzip.init */
+
+value ml_sevenzip_init(value unit)
+{
+  CAMLparam1 (unit);
+
+  CrcGenerateTable();
+
+  allocImp.Alloc = SzAlloc;
+  allocImp.Free = SzFree;
+  allocTempImp.Alloc = SzAllocTemp;
+  allocTempImp.Free = SzFreeTemp;
+
+  CAMLreturn (Val_unit);
+}
+
+/* Sevenzip.readable */
+
+typedef struct _CFileInStream {
+  ISzInStream funcs;
+  value readable;
+} CFileInStream;
+
+SRes ml_sevenzip_read(void *object, void **buffer, size_t *size)
+{
+
+  CFileInStream *archive_in = (CFileInStream *) object;
+  CAMLparam0 ();
+  CAMLlocal5 (readable, read, tuple, ml_string, ml_size);
+
+  readable = archive_in-&gt;readable;
+  read = Field(readable, 0);
+  tuple = caml_callback(read, Val_int(*size));
+  ml_string = Field(tuple, 0);
+  ml_size = Field(tuple, 1);
+  *buffer = String_val(ml_string);
+  *size = Int_val(ml_size);
+
+  /* The GC might have moved the readable pointer */
+  archive_in-&gt;readable = readable;
+
+  CAMLreturnT(SRes, SZ_OK);
+}
+
+SRes ml_sevenzip_seek(void *object, CFileSize pos, ESzSeek origin)
+{
+  CFileInStream *archive_in = (CFileInStream *) object;
+  CAMLparam0 ();
+  CAMLlocal3 (readable, seek, term);
+
+  readable = archive_in-&gt;readable;
+  seek = Field(readable, 1);
+
+  switch (origin) {
+
+  case SZ_SEEK_SET: term = Val_int(0); break;
+  case SZ_SEEK_CUR: term = Val_int(1); break;
+  case SZ_SEEK_END: term = Val_int(2); break;
+
+  }
+
+  caml_callback2(seek, Val_int(pos), term);
+
+  /* The GC might have moved the readable pointer */
+  archive_in-&gt;readable = readable;
+
+  CAMLreturnT(SRes, SZ_OK);
+}
+
+/* Sevenzip.open_readable */
+
+value ml_sevenzip_open_readable (value readable)
+{
+  CAMLparam1 (readable);
+  CAMLlocal1 (sevenzip);
+
+  CFileInStream archive_in;
+  CSzArEx db;
+  SRes res;
+
+  archive_in.funcs.Read = ml_sevenzip_read;
+  archive_in.funcs.Seek = ml_sevenzip_seek;
+  archive_in.readable = readable;
+
+  SzArEx_Init(&amp;db);
+  res = SzArEx_Open(&amp;db, &amp;archive_in.funcs, &amp;allocImp, &amp;allocTempImp);
+
+  switch (res) {
+
+  case SZ_OK: break;
+  case SZ_ERROR_NO_ARCHIVE: caml_failwith(&quot;NO ARCHIVE&quot;);
+  case SZ_ERROR_ARCHIVE: caml_failwith(&quot;ARCHIVE&quot;);
+  case SZ_ERROR_UNSUPPORTED: caml_failwith(&quot;UNSUPPORTED&quot;);
+  case SZ_ERROR_MEM: caml_failwith(&quot;MEM&quot;);
+  case SZ_ERROR_CRC: caml_failwith(&quot;CRC&quot;);
+  case SZ_ERROR_INPUT_EOF: caml_failwith(&quot;INPUT_EOF&quot;);
+  case SZ_ERROR_FAIL:
+  default: caml_failwith(&quot;FAIL&quot;);
+
+  }
+
+  sevenzip = alloc_sevenzip_in_file(db);
+  CAMLreturn (sevenzip);
+}
+
+/* Sevenzip.entries */
+
+value ml_sevenzip_entries(value sevenzip)
+{
+  CAMLparam1 (sevenzip);
+  CAMLlocal2 (entries, entry);
+  CSzArEx db = sevenzip_in_file_val(sevenzip);
+
+  entries = caml_alloc (db.db.NumFiles, 0);
+
+  UInt32 i;
+  for (i = 0; i &lt; db.db.NumFiles; i++) {
+    entry = alloc_sevenzip_entry(db, i);
+    Store_field (entries, i, entry);
+  }
+
+  CAMLreturn (entries);
+}

Deleted: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/sevenzip.ml
===================================================================
--- trunk/tools/SpringInstaller/libmlsevenzip/sevenzip.ml	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/sevenzip.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,54 +0,0 @@
-exception Error of string
-
-external init: unit -&gt; unit = &quot;ml_sevenzip_init&quot;
-let () = init ()
-
-type origin = SeekSet | SeekCur | SeekEnd
-
-type readable = {
-  read: int -&gt; (string * int);
-  seek: int -&gt; origin -&gt; unit
-}
-
-type db
-type in_file = readable * db
-
-type entry = {
-  index: int;
-  filename: string;
-  uncompressed_size: int;
-  is_directory: bool
-}
-
-external _open_readable: readable -&gt; db = &quot;ml_sevenzip_open_readable&quot;
-let open_readable readable =
-  try
-    (readable, _open_readable readable)
-  with
-      Failure s -&gt; raise (Error s)
-
-external _entries: db -&gt; entry array = &quot;ml_sevenzip_entries&quot;
-let entries (_, db) = _entries db
-
-let open_in path =
-  let file = open_in_bin path in
-  let buffer = String.create 65536 in
-    
-  let read n =
-    let length = String.length buffer in
-    let n = if n &gt; length then length else n in
-    let n = input file buffer 0 n in
-      (buffer, n) in
-    
-  let seek pos origin =
-    let pos =
-      match origin with
-          SeekSet -&gt; pos
-        | SeekCur -&gt; (pos_in file) + pos
-        | SeekEnd -&gt; (in_channel_length file) + pos in
-      seek_in file pos in
-
-    open_readable {read=read; seek=seek}
-
-
-let close_in t = ()

Copied: branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/sevenzip.ml (from rev 6422, trunk/tools/SpringInstaller/libmlsevenzip/sevenzip.ml)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/sevenzip.ml	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/libmlsevenzip/sevenzip.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,54 @@
+exception Error of string
+
+external init: unit -&gt; unit = &quot;ml_sevenzip_init&quot;
+let () = init ()
+
+type origin = SeekSet | SeekCur | SeekEnd
+
+type readable = {
+  read: int -&gt; (string * int);
+  seek: int -&gt; origin -&gt; unit
+}
+
+type db
+type in_file = readable * db
+
+type entry = {
+  index: int;
+  filename: string;
+  uncompressed_size: int;
+  is_directory: bool
+}
+
+external _open_readable: readable -&gt; db = &quot;ml_sevenzip_open_readable&quot;
+let open_readable readable =
+  try
+    (readable, _open_readable readable)
+  with
+      Failure s -&gt; raise (Error s)
+
+external _entries: db -&gt; entry array = &quot;ml_sevenzip_entries&quot;
+let entries (_, db) = _entries db
+
+let open_in path =
+  let file = open_in_bin path in
+  let buffer = String.create 65536 in
+    
+  let read n =
+    let length = String.length buffer in
+    let n = if n &gt; length then length else n in
+    let n = input file buffer 0 n in
+      (buffer, n) in
+    
+  let seek pos origin =
+    let pos =
+      match origin with
+          SeekSet -&gt; pos
+        | SeekCur -&gt; (pos_in file) + pos
+        | SeekEnd -&gt; (in_channel_length file) + pos in
+      seek_in file pos in
+
+    open_readable {read=read; seek=seek}
+
+
+let close_in t = ()

Deleted: branches/0.77-branch/tools/SpringInstaller/release.sh
===================================================================
--- trunk/tools/SpringInstaller/release.sh	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/release.sh	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,18 +0,0 @@
-#!/bin/bash
-PACKAGE=`dpkg-parsechangelog -c1 | sed -rn &quot;s/^Source: (.+)/\1/p&quot;`
-VERSION=`dpkg-parsechangelog -c1 | sed -rn &quot;s/^Version: (.+)-.+$/\1/p&quot;`
-TMPDIR=`mktemp -d`
-SOURCEDIR=&quot;$PACKAGE-$VERSION&quot;
-SOURCETARGZ=&quot;${PACKAGE}_$VERSION.orig.tar.gz&quot;
-TARGET=$PWD
-
-svn export . &quot;$TMPDIR/$SOURCEDIR&quot;
-cd &quot;$TMPDIR&quot;
-tar -zcvf &quot;$SOURCETARGZ&quot; &quot;$SOURCEDIR&quot;
-cd &quot;$SOURCEDIR&quot;
-dpkg-buildpackage
-cd &quot;$TMPDIR&quot;
-rm -rf &quot;$SOURCEDIR&quot;
-cd $TARGET
-rm -rf release
-mv $TMPDIR release

Copied: branches/0.77-branch/tools/SpringInstaller/release.sh (from rev 6422, trunk/tools/SpringInstaller/release.sh)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/release.sh	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/release.sh	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,18 @@
+#!/bin/bash
+PACKAGE=`dpkg-parsechangelog -c1 | sed -rn &quot;s/^Source: (.+)/\1/p&quot;`
+VERSION=`dpkg-parsechangelog -c1 | sed -rn &quot;s/^Version: (.+)-.+$/\1/p&quot;`
+TMPDIR=`mktemp -d`
+SOURCEDIR=&quot;$PACKAGE-$VERSION&quot;
+SOURCETARGZ=&quot;${PACKAGE}_$VERSION.orig.tar.gz&quot;
+TARGET=$PWD
+
+svn export . &quot;$TMPDIR/$SOURCEDIR&quot;
+cd &quot;$TMPDIR&quot;
+tar -zcvf &quot;$SOURCETARGZ&quot; &quot;$SOURCEDIR&quot;
+cd &quot;$SOURCEDIR&quot;
+dpkg-buildpackage
+cd &quot;$TMPDIR&quot;
+rm -rf &quot;$SOURCEDIR&quot;
+cd $TARGET
+rm -rf release
+mv $TMPDIR release

Deleted: branches/0.77-branch/tools/SpringInstaller/sd7.ml
===================================================================
--- trunk/tools/SpringInstaller/sd7.ml	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/sd7.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,56 +0,0 @@
-module Entry = struct
-  let make zip entry = object (self)
-    val zip = zip
-    val entry = entry
-
-    method name = entry.Sevenzip.filename
-    method size = entry.Sevenzip.uncompressed_size
-    (* method read = Sevenzip.read_entry zip entry *)
-    method read = &quot;STUB&quot;
-    method digest = Digest.string self#read
-  end
-end  
-
-module In = struct
-
-  let make zip path = object
-    val zip = zip
-    val path: string = path
-      
-    method unload = Sevenzip.close_in zip
-      
-    method entries =
-      let combine entries entry =
-        if entry.Sevenzip.is_directory then
-          entries
-        else
-          (Entry.make zip entry) :: entries
-      in
-        Array.fold_left combine [] (Sevenzip.entries zip)
-          
-    method path = path
-  end
-    
-  let load path =
-    let zip = Sevenzip.open_in path in
-      make zip path
-end
-
-(* module Out = struct *)
-
-(*   let make zip = object *)
-(*     val zip = zip *)
-      
-(*     method unload = Sevenzip.close_out zip *)
-      
-(*     method add_entry entry = *)
-(*       let filename = entry#name in *)
-(*       let data = entry#read in *)
-(*         Sevenzip.add_entry data zip filename *)
-(*   end *)
-          
-(*   let load path = *)
-(*     let zip = Sevenzip.open_out path in *)
-(*       make zip *)
-      
-(* end *)

Copied: branches/0.77-branch/tools/SpringInstaller/sd7.ml (from rev 6422, trunk/tools/SpringInstaller/sd7.ml)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/sd7.ml	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/sd7.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,56 @@
+module Entry = struct
+  let make zip entry = object (self)
+    val zip = zip
+    val entry = entry
+
+    method name = entry.Sevenzip.filename
+    method size = entry.Sevenzip.uncompressed_size
+    (* method read = Sevenzip.read_entry zip entry *)
+    method read = &quot;STUB&quot;
+    method digest = Digest.string self#read
+  end
+end  
+
+module In = struct
+
+  let make zip path = object
+    val zip = zip
+    val path: string = path
+      
+    method unload = Sevenzip.close_in zip
+      
+    method entries =
+      let combine entries entry =
+        if entry.Sevenzip.is_directory then
+          entries
+        else
+          (Entry.make zip entry) :: entries
+      in
+        Array.fold_left combine [] (Sevenzip.entries zip)
+          
+    method path = path
+  end
+    
+  let load path =
+    let zip = Sevenzip.open_in path in
+      make zip path
+end
+
+(* module Out = struct *)
+
+(*   let make zip = object *)
+(*     val zip = zip *)
+      
+(*     method unload = Sevenzip.close_out zip *)
+      
+(*     method add_entry entry = *)
+(*       let filename = entry#name in *)
+(*       let data = entry#read in *)
+(*         Sevenzip.add_entry data zip filename *)
+(*   end *)
+          
+(*   let load path = *)
+(*     let zip = Sevenzip.open_out path in *)
+(*       make zip *)
+      
+(* end *)

Deleted: branches/0.77-branch/tools/SpringInstaller/sdz.ml
===================================================================
--- trunk/tools/SpringInstaller/sdz.ml	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/sdz.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,55 +0,0 @@
-module Entry = struct
-  let make zip entry = object (self)
-    val zip = zip
-    val entry = entry
-
-    method name = entry.Zip.filename
-    method size = entry.Zip.uncompressed_size
-    method read = Zip.read_entry zip entry
-    method digest = Digest.string self#read
-  end
-end  
-
-module In = struct
-
-  let make zip path = object
-    val zip = zip
-    val path: string = path
-      
-    method unload = Zip.close_in zip
-      
-    method entries =
-      let combine entries entry =
-        if entry.Zip.is_directory then
-          entries
-        else
-          (Entry.make zip entry) :: entries
-      in
-        List.fold_left combine [] (Zip.entries zip)
-          
-    method path = path
-  end
-    
-  let load path =
-    let zip = Zip.open_in path in
-      make zip path
-end
-
-module Out = struct
-
-  let make zip = object
-    val zip = zip
-      
-    method unload = Zip.close_out zip
-      
-    method add_entry entry =
-      let filename = entry#name in
-      let data = entry#read in
-        Zip.add_entry data zip filename
-  end
-          
-  let load path =
-    let zip = Zip.open_out path in
-      make zip
-      
-end

Copied: branches/0.77-branch/tools/SpringInstaller/sdz.ml (from rev 6422, trunk/tools/SpringInstaller/sdz.ml)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/sdz.ml	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/sdz.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,55 @@
+module Entry = struct
+  let make zip entry = object (self)
+    val zip = zip
+    val entry = entry
+
+    method name = entry.Zip.filename
+    method size = entry.Zip.uncompressed_size
+    method read = Zip.read_entry zip entry
+    method digest = Digest.string self#read
+  end
+end  
+
+module In = struct
+
+  let make zip path = object
+    val zip = zip
+    val path: string = path
+      
+    method unload = Zip.close_in zip
+      
+    method entries =
+      let combine entries entry =
+        if entry.Zip.is_directory then
+          entries
+        else
+          (Entry.make zip entry) :: entries
+      in
+        List.fold_left combine [] (Zip.entries zip)
+          
+    method path = path
+  end
+    
+  let load path =
+    let zip = Zip.open_in path in
+      make zip path
+end
+
+module Out = struct
+
+  let make zip = object
+    val zip = zip
+      
+    method unload = Zip.close_out zip
+      
+    method add_entry entry =
+      let filename = entry#name in
+      let data = entry#read in
+        Zip.add_entry data zip filename
+  end
+          
+  let load path =
+    let zip = Zip.open_out path in
+      make zip
+      
+end

Deleted: branches/0.77-branch/tools/SpringInstaller/spring_installer.ml
===================================================================
--- trunk/tools/SpringInstaller/spring_installer.ml	2008-09-14 22:19:02 UTC (rev 6422)
+++ branches/0.77-branch/tools/SpringInstaller/spring_installer.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -1,177 +0,0 @@
-let title = &quot;Spring Installer&quot;
-
-let die message = 
-  GToolbox.message_box ~title:title ~ok:&quot;Exit&quot; message;
-  GMain.Main.quit ()
-
-let warn message = 
-  GToolbox.message_box ~title:title ~ok:&quot;Ok&quot; message
-
-let archive_mover path kind datadir =
-  (* Window *)
-
-  let window = GWindow.window
-    ~title:title
-    ~width:512
-    ~height:160
-    ~position:`CENTER
-    () in
-    
-  let _ = window#connect#destroy ~callback:GMain.Main.quit in
-
-  (* VBox *)
-
-  let vbox = GPack.vbox
-    ~packing:window#add
-    () in
-    
-  (* Table *)
-
-  let table = GPack.table
-    ~col_spacings:5
-    ~packing:vbox#add
-    () in
-    
-  (* Spring Directory *)
-
-  let _ = GMisc.label
-    ~text:&quot;Spring directory&quot;
-    ~packing:(table#attach ~left:0 ~top:0)
-    () in
-    
-  let spring_dir_entry = GEdit.entry
-    ~packing:(table#attach ~left:1 ~top:0 ~expand:`X)
-    () in
-  let spring_dir_entry_defaults () = spring_dir_entry#set_text datadir in
-  let spring_dir_entry_get () = spring_dir_entry#text in
-
-  (* Filename *)
-
-  let _ = GMisc.label
-    ~text:&quot;Filename&quot;
-    ~packing:(table#attach ~left:0 ~top:1)
-    () in
-    
-  let basename_entry = GEdit.entry
-    ~packing:(table#attach ~left:1 ~top:1 ~expand:`X)
-    () in
-
-  let basename_entry_defaults () = basename_entry#set_text (Filename.basename path) in
-  let basename_entry_get () = basename_entry#text in
-
-  (* Archive Kind *)
-
-  let _ = GMisc.label
-    ~text:&quot;Archive kind&quot;
-    ~packing:(table#attach ~left:0 ~top:2)
-    () in
-
-  let (kind_combobox, _) = GEdit.combo_box_text
-    ~strings:[&quot;Map&quot;; &quot;Mod&quot;]
-    ~packing:(table#attach ~left:1 ~top:2 ~expand:`X)
-    () in
-
-  let kind_combobox_defaults () =
-    try
-      let int = match kind with
-          Archive.Map -&gt; 0
-        | Archive.Mod -&gt; 1
-        | Archive.Unknown -&gt; -1 in
-        kind_combobox#set_active int
-    with
-        Archive.Error s -&gt; warn s in
-
-  let kind_combobox_get () =
-    let int = kind_combobox#active in
-      match int with
-          0 -&gt; Archive.Map
-        | 1 -&gt; Archive.Mod
-        | _ -&gt; Archive.Unknown in
-
-  let button_box = GPack.button_box `HORIZONTAL
-    ~packing:(vbox#pack ~fill:false ~expand:false)
-    () in
-    
-  (* Exit *)
-
-  let exit_button = GButton.button
-    ~label:&quot;Exit&quot;
-    ~packing:button_box#pack
-    () in
-
-  let _ = exit_button#connect#clicked ~callback:GMain.Main.quit in
-
-  (* Defaults *)
-    
-  let defaults ()=
-    spring_dir_entry_defaults ();
-    basename_entry_defaults ();
-    kind_combobox_defaults () in
-    
-  let defaults_button = GButton.button
-    ~label:&quot;Defaults&quot;
-    ~packing:button_box#pack
-    () in
-
-  let _ = defaults_button#connect#clicked ~callback:defaults in
-
-  (* Install *)
-
-  let install () =
-    let spring_dir = spring_dir_entry_get () in
-    let basename = basename_entry_get () in
-    let kind = kind_combobox_get () in
-
-    let install_dir sub_dir =
-      let dest_dir = Filename.concat spring_dir sub_dir in
-      let dest = Filename.concat dest_dir basename in
-        try
-          FileSystem.move path dest;
-          die (Printf.sprintf &quot;%s was successfully installed&quot; dest)
-        with
-            Sys_error s -&gt; die s in
-          
-      if spring_dir = &quot;&quot; then
-        warn &quot;You must specify the Spring directory&quot;
-      else
-        match kind with
-            Archive.Map -&gt; install_dir &quot;maps&quot;
-          | Archive.Mod -&gt; install_dir &quot;mods&quot;
-          | Archive.Unknown -&gt; warn &quot;You must specify the Archive kind&quot; in
-
-  let install_button = GButton.button
-    ~label:&quot;Install&quot;
-    ~packing:button_box#pack
-    () in
-
-  let _ = install_button#connect#clicked ~callback:install in
-  let () = window#focus#set (Some install_button#coerce) in
-
-    (* Body *)
-
-    defaults ();
-    window#show ()
-
-let fail message =
-  GToolbox.message_box
-    ~title:title
-    ~ok:&quot;Exit&quot;
-    message
-
-let usage () = fail (Printf.sprintf &quot;Usage: %s &lt;archive&gt;&quot; Sys.argv.(0))
-
-let parse_argv () =
-  if Array.length (Sys.argv) = 2 then
-    try
-      let path = Sys.argv.(1) in
-      let kind = Archive.detect_kind path in
-      let datadir = Datadir.detect () in
-        archive_mover path kind datadir;
-        GMain.Main.main ()
-    with
-        Archive.Error s -&gt; fail s
-  else
-    usage ()
-
-let () = parse_argv ()
-

Copied: branches/0.77-branch/tools/SpringInstaller/spring_installer.ml (from rev 6422, trunk/tools/SpringInstaller/spring_installer.ml)
===================================================================
--- branches/0.77-branch/tools/SpringInstaller/spring_installer.ml	                        (rev 0)
+++ branches/0.77-branch/tools/SpringInstaller/spring_installer.ml	2008-09-15 18:44:36 UTC (rev 6427)
@@ -0,0 +1,177 @@
+let title = &quot;Spring Installer&quot;
+
+let die message = 
+  GToolbox.message_box ~title:title ~ok:&quot;Exit&quot; message;
+  GMain.Main.quit ()
+
+let warn message = 
+  GToolbox.message_box ~title:title ~ok:&quot;Ok&quot; message
+
+let archive_mover path kind datadir =
+  (* Window *)
+
+  let window = GWindow.window
+    ~title:title
+    ~width:512
+    ~height:160
+    ~position:`CENTER
+    () in
+    
+  let _ = window#connect#destroy ~callback:GMain.Main.quit in
+
+  (* VBox *)
+
+  let vbox = GPack.vbox
+    ~packing:window#add
+    () in
+    
+  (* Table *)
+
+  let table = GPack.table
+    ~col_spacings:5
+    ~packing:vbox#add
+    () in
+    
+  (* Spring Directory *)
+
+  let _ = GMisc.label
+    ~text:&quot;Spring directory&quot;
+    ~packing:(table#attach ~left:0 ~top:0)
+    () in
+    
+  let spring_dir_entry = GEdit.entry
+    ~packing:(table#attach ~left:1 ~top:0 ~expand:`X)
+    () in
+  let spring_dir_entry_defaults () = spring_dir_entry#set_text datadir in
+  let spring_dir_entry_get () = spring_dir_entry#text in
+
+  (* Filename *)
+
+  let _ = GMisc.label
+    ~text:&quot;Filename&quot;
+    ~packing:(table#attach ~left:0 ~top:1)
+    () in
+    
+  let basename_entry = GEdit.entry
+    ~packing:(table#attach ~left:1 ~top:1 ~expand:`X)
+    () in
+
+  let basename_entry_defaults () = basename_entry#set_text (Filename.basename path) in
+  let basename_entry_get () = basename_entry#text in
+
+  (* Archive Kind *)
+
+  let _ = GMisc.label
+    ~text:&quot;Archive kind&quot;
+    ~packing:(table#attach ~left:0 ~top:2)
+    () in
+
+  let (kind_combobox, _) = GEdit.combo_box_text
+    ~strings:[&quot;Map&quot;; &quot;Mod&quot;]
+    ~packing:(table#attach ~left:1 ~top:2 ~expand:`X)
+    () in
+
+  let kind_combobox_defaults () =
+    try
+      let int = match kind with
+          Archive.Map -&gt; 0
+        | Archive.Mod -&gt; 1
+        | Archive.Unknown -&gt; -1 in
+        kind_combobox#set_active int
+    with
+        Archive.Error s -&gt; warn s in
+
+  let kind_combobox_get () =
+    let int = kind_combobox#active in
+      match int with
+          0 -&gt; Archive.Map
+        | 1 -&gt; Archive.Mod
+        | _ -&gt; Archive.Unknown in
+
+  let button_box = GPack.button_box `HORIZONTAL
+    ~packing:(vbox#pack ~fill:false ~expand:false)
+    () in
+    
+  (* Exit *)
+
+  let exit_button = GButton.button
+    ~label:&quot;Exit&quot;
+    ~packing:button_box#pack
+    () in
+
+  let _ = exit_button#connect#clicked ~callback:GMain.Main.quit in
+
+  (* Defaults *)
+    
+  let defaults ()=
+    spring_dir_entry_defaults ();
+    basename_entry_defaults ();
+    kind_combobox_defaults () in
+    
+  let defaults_button = GButton.button
+    ~label:&quot;Defaults&quot;
+    ~packing:button_box#pack
+    () in
+
+  let _ = defaults_button#connect#clicked ~callback:defaults in
+
+  (* Install *)
+
+  let install () =
+    let spring_dir = spring_dir_entry_get () in
+    let basename = basename_entry_get () in
+    let kind = kind_combobox_get () in
+
+    let install_dir sub_dir =
+      let dest_dir = Filename.concat spring_dir sub_dir in
+      let dest = Filename.concat dest_dir basename in
+        try
+          FileSystem.move path dest;
+          die (Printf.sprintf &quot;%s was successfully installed&quot; dest)
+        with
+            Sys_error s -&gt; die s in
+          
+      if spring_dir = &quot;&quot; then
+        warn &quot;You must specify the Spring directory&quot;
+      else
+        match kind with
+            Archive.Map -&gt; install_dir &quot;maps&quot;
+          | Archive.Mod -&gt; install_dir &quot;mods&quot;
+          | Archive.Unknown -&gt; warn &quot;You must specify the Archive kind&quot; in
+
+  let install_button = GButton.button
+    ~label:&quot;Install&quot;
+    ~packing:button_box#pack
+    () in
+
+  let _ = install_button#connect#clicked ~callback:install in
+  let () = window#focus#set (Some install_button#coerce) in
+
+    (* Body *)
+
+    defaults ();
+    window#show ()
+
+let fail message =
+  GToolbox.message_box
+    ~title:title
+    ~ok:&quot;Exit&quot;
+    message
+
+let usage () = fail (Printf.sprintf &quot;Usage: %s &lt;archive&gt;&quot; Sys.argv.(0))
+
+let parse_argv () =
+  if Array.length (Sys.argv) = 2 then
+    try
+      let path = Sys.argv.(1) in
+      let kind = Archive.detect_kind path in
+      let datadir = Datadir.detect () in
+        archive_mover path kind datadir;
+        GMain.Main.main ()
+    with
+        Archive.Error s -&gt; fail s
+  else
+    usage ()
+
+let () = parse_argv ()
+

Modified: branches/0.77-branch/tools/unitsync/unitsync.cpp
===================================================================
--- branches/0.77-branch/tools/unitsync/unitsync.cpp	2008-09-15 12:09:21 UTC (rev 6426)
+++ branches/0.77-branch/tools/unitsync/unitsync.cpp	2008-09-15 18:44:36 UTC (rev 6427)
@@ -331,14 +331,14 @@
 
 DLL_EXPORT void __stdcall AddArchive(const char* name)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before AddArchive.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before AddArchive.&quot;);
 	ASSERT(name &amp;&amp; *name, &quot;Don't pass a NULL pointer or an empty string to AddArchive.&quot;);
 	vfsHandler-&gt;AddArchive(name, false);
 }
 
 DLL_EXPORT void __stdcall AddAllArchives(const char* root)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before AddAllArchives.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before AddAllArchives.&quot;);
 	ASSERT(root &amp;&amp; *root, &quot;Don't pass a NULL pointer or an empty string to AddAllArchives.&quot;);
 	vector&lt;string&gt; ars = archiveScanner-&gt;GetArchives(root);
 //	Message(root);
@@ -350,7 +350,7 @@
 
 DLL_EXPORT unsigned int __stdcall GetArchiveChecksum(const char* arname)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetArchiveChecksum.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetArchiveChecksum.&quot;);
 	ASSERT(arname &amp;&amp; *arname, &quot;Don't pass a NULL pointer or an empty string to GetArchiveChecksum.&quot;);
 	logOutput.Print(&quot;archive checksum: %s\n&quot;, arname);
 	return archiveScanner-&gt;GetArchiveChecksum(arname);
@@ -358,7 +358,7 @@
 
 DLL_EXPORT const char* __stdcall GetArchivePath(const char* arname)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetArchivePath.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetArchivePath.&quot;);
 	ASSERT(arname &amp;&amp; *arname, &quot;Don't pass a NULL pointer or an empty string to GetArchivePath.&quot;);
 	logOutput.Print(&quot;archive path: %s\n&quot;, arname);
 	return GetStr(archiveScanner-&gt;GetArchivePath(arname));
@@ -369,7 +369,7 @@
 
 DLL_EXPORT int __stdcall GetMapCount()
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapCount.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetMapCount.&quot;);
 	//vector&lt;string&gt; files = CFileHandler::FindFiles(&quot;{maps/*.smf,maps/*.sm3}&quot;);
 	vector&lt;string&gt; files = CFileHandler::FindFiles(&quot;maps/&quot;, &quot;{*.smf,*.sm3}&quot;);
 	vector&lt;string&gt; ars = archiveScanner-&gt;GetMaps();
@@ -393,7 +393,7 @@
 
 DLL_EXPORT const char* __stdcall GetMapName(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapName.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetMapName.&quot;);
 	ASSERT((unsigned)index &lt; mapNames.size(), &quot;Array index out of bounds. Call GetMapCount before GetMapName.&quot;);
 	return GetStr(mapNames[index]);
 }
@@ -401,7 +401,7 @@
 
 DLL_EXPORT int __stdcall GetMapInfoEx(const char* name, MapInfo* outInfo, int version)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapInfo.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetMapInfo.&quot;);
 	ASSERT(name &amp;&amp; *name &amp;&amp; outInfo, &quot;Don't pass a NULL pointer or an empty string to GetMapInfo.&quot;);
 
 	const string mapName = name;
@@ -506,28 +506,28 @@
 
 DLL_EXPORT int __stdcall GetMapArchiveCount(const char* mapName)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapArchiveCount.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetMapArchiveCount.&quot;);
 	mapArchives = archiveScanner-&gt;GetArchivesForMap(mapName);
 	return mapArchives.size();
 }
 
 DLL_EXPORT const char* __stdcall GetMapArchiveName(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapArchiveName.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetMapArchiveName.&quot;);
 	ASSERT((unsigned)index &lt; mapArchives.size(), &quot;Array index out of bounds. Call GetMapArchiveCount before GetMapArchiveName.&quot;);
 	return GetStr(mapArchives[index]);
 }
 
 DLL_EXPORT unsigned int __stdcall GetMapChecksum(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapChecksum.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetMapChecksum.&quot;);
 	ASSERT((unsigned)index &lt; mapNames.size(), &quot;Array index out of bounds. Call GetMapCount before GetMapChecksum.&quot;);
 	return archiveScanner-&gt;GetMapChecksum(mapNames[index]);
 }
 
 DLL_EXPORT unsigned int __stdcall GetMapChecksumFromName(const char* mapName)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapChecksumFromName.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetMapChecksumFromName.&quot;);
 	return archiveScanner-&gt;GetMapChecksum(mapName);
 }
 
@@ -713,7 +713,7 @@
  */
 DLL_EXPORT void* __stdcall GetMinimap(const char* filename, int miplevel)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMinimap.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetMinimap.&quot;);
 	ASSERT(filename &amp;&amp; *filename, &quot;Don't pass a NULL pointer or an empty string to GetMinimap.&quot;);
 	ASSERT(miplevel &gt;= 0 &amp;&amp; miplevel &lt;= 8, &quot;Miplevel must be between 0 and 8 (inclusive) in GetMinimap.&quot;);
 
@@ -749,7 +749,7 @@
  */
 DLL_EXPORT int __stdcall GetPrimaryModCount()
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModCount.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModCount.&quot;);
 	modData = archiveScanner-&gt;GetPrimaryMods();
 	return modData.size();
 }
@@ -765,7 +765,7 @@
  */
 DLL_EXPORT const char* __stdcall GetPrimaryModName(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModName.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModName.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModName.&quot;);
 	string x = modData[index].name;
 	return GetStr(x);
@@ -782,7 +782,7 @@
  */
 DLL_EXPORT const char* __stdcall GetPrimaryModShortName(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModShortName.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModShortName.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModShortName.&quot;);
 	string x = modData[index].shortName;
 	return GetStr(x);
@@ -799,7 +799,7 @@
  */
 DLL_EXPORT const char* __stdcall GetPrimaryModVersion(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModVersion.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModVersion.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModMutator.&quot;);
 	string x = modData[index].version;
 	return GetStr(x);
@@ -816,7 +816,7 @@
  */
 DLL_EXPORT const char* __stdcall GetPrimaryModMutator(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModMutator.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModMutator.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModMutator.&quot;);
 	string x = modData[index].mutator;
 	return GetStr(x);
@@ -833,7 +833,7 @@
  */
 DLL_EXPORT const char* __stdcall GetPrimaryModGame(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModName.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModName.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModName.&quot;);
 	string x = modData[index].game;
 	return GetStr(x);
@@ -850,7 +850,7 @@
  */
 DLL_EXPORT const char* __stdcall GetPrimaryModShortGame(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModShortGame.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModShortGame.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModShortGame.&quot;);
 	string x = modData[index].shortGame;
 	return GetStr(x);
@@ -867,7 +867,7 @@
  */
 DLL_EXPORT const char* __stdcall GetPrimaryModDescription(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModDescription.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModDescription.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModDescription.&quot;);
 	string x = modData[index].description;
 	return GetStr(x);
@@ -876,7 +876,7 @@
 
 DLL_EXPORT const char* __stdcall GetPrimaryModArchive(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModArchive.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModArchive.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModArchive.&quot;);
 	return GetStr(modData[index].dependencies[0]);
 }
@@ -896,7 +896,7 @@
  */
 DLL_EXPORT int __stdcall GetPrimaryModArchiveCount(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModArchiveCount.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModArchiveCount.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModArchiveCount.&quot;);
 	primaryArchives = archiveScanner-&gt;GetArchives(modData[index].dependencies[0]);
 	return primaryArchives.size();
@@ -910,7 +910,7 @@
  */
 DLL_EXPORT const char* __stdcall GetPrimaryModArchiveList(int arnr)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModArchiveList.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModArchiveList.&quot;);
 	ASSERT((unsigned)arnr &lt; primaryArchives.size(), &quot;Array index out of bounds. Call GetPrimaryModArchiveCount before GetPrimaryModArchiveList.&quot;);
 	logOutput.Print(&quot;primary mod archive list: %s\n&quot;, primaryArchives[arnr].c_str());
 	return GetStr(primaryArchives[arnr]);
@@ -918,7 +918,7 @@
 
 DLL_EXPORT int __stdcall GetPrimaryModIndex(const char* name)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModIndex.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModIndex.&quot;);
 	string n(name);
 	for (unsigned i = 0; i &lt; modData.size(); ++i) {
 		if (modData[i].name == n)
@@ -930,14 +930,14 @@
 
 DLL_EXPORT unsigned int __stdcall GetPrimaryModChecksum(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModChecksum.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModChecksum.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModChecksum.&quot;);
 	return archiveScanner-&gt;GetModChecksum(GetPrimaryModArchive(index));
 }
 
 DLL_EXPORT unsigned int __stdcall GetPrimaryModChecksumFromName(const char* name)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModChecksumFromName.&quot;);
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init before GetPrimaryModChecksumFromName.&quot;);
 	return archiveScanner-&gt;GetModChecksum(archiveScanner-&gt;ModNameToModArchive(name));
 }
 
@@ -1117,7 +1117,7 @@
 		return false;
 	}
 	opt.desc = optTbl.GetString(&quot;desc&quot;, opt.name);
-	
+
 	opt.section = optTbl.GetString(&quot;section&quot;, &quot;&quot;);
 
 	opt.type = optTbl.GetString(&quot;type&quot;, &quot;&quot;);
@@ -1218,7 +1218,7 @@
 		luaParser.AddString(&quot;configFile&quot;, configName);
 		luaParser.EndTable();
 	}
-		
+
 	if (!luaParser.Execute()) {
 		printf(&quot;ParseOptions(%s) ERROR: %s\n&quot;,
 		       fileName.c_str(), luaParser.GetErrorLog().c_str());
@@ -1267,7 +1267,7 @@
 DLL_EXPORT int __stdcall GetMapOptionCount(const char* name)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler,
-	       &quot;Call InitArchiveScanner before GetMapOptionCount.&quot;);
+	       &quot;Call Init before GetMapOptionCount.&quot;);
 	ASSERT(name &amp;&amp; *name,
 				 &quot;Don't pass a NULL pointer or an empty string to GetMapOptionCount.&quot;);
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001196.html">[Taspring-linux-commit] r6426 - trunk/rts/Rendering/UnitModels
</A></li>
	<LI>Next message: <A HREF="001198.html">[Taspring-linux-commit] r6428 - in trunk/rts: Game Game/UI Map/SMF	Rendering/GL System/Platform/Win lib/gml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1197">[ date ]</a>
              <a href="thread.html#1197">[ thread ]</a>
              <a href="subject.html#1197">[ subject ]</a>
              <a href="author.html#1197">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
