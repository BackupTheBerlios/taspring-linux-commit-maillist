<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5923 - in trunk:	AI/Global/NTai/AI/NTai/Agents game game/LuaUI/Widgets	installer installer/builddata/springcontent/gamedata	installer/sections rts/ExternalAI rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua rts/Rendering	rts/Rendering/UnitModels rts/Sim rts/Sim/Units tools/unitsync
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5923%20-%20in%20trunk%3A%0A%09AI/Global/NTai/AI/NTai/Agents%20game%20game/LuaUI/Widgets%0A%09installer%20installer/builddata/springcontent/gamedata%0A%09installer/sections%20rts/ExternalAI%20rts/Game%0A%09rts/Game/StartScripts%20rts/Game/UI%20rts/Lua%20rts/Rendering%0A%09rts/Rendering/UnitModels%20rts/Sim%20rts/Sim/Units%20tools/unitsync&In-Reply-To=%3C20080524125556.76DB745CD%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000702.html">
   <LINK REL="Next"  HREF="000704.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5923 - in trunk:	AI/Global/NTai/AI/NTai/Agents game game/LuaUI/Widgets	installer installer/builddata/springcontent/gamedata	installer/sections rts/ExternalAI rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua rts/Rendering	rts/Rendering/UnitModels rts/Sim rts/Sim/Units tools/unitsync</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5923%20-%20in%20trunk%3A%0A%09AI/Global/NTai/AI/NTai/Agents%20game%20game/LuaUI/Widgets%0A%09installer%20installer/builddata/springcontent/gamedata%0A%09installer/sections%20rts/ExternalAI%20rts/Game%0A%09rts/Game/StartScripts%20rts/Game/UI%20rts/Lua%20rts/Rendering%0A%09rts/Rendering/UnitModels%20rts/Sim%20rts/Sim/Units%20tools/unitsync&In-Reply-To=%3C20080524125556.76DB745CD%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5923 - in trunk:	AI/Global/NTai/AI/NTai/Agents game game/LuaUI/Widgets	installer installer/builddata/springcontent/gamedata	installer/sections rts/ExternalAI rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua rts/Rendering	rts/Rendering/UnitModels rts/Sim rts/Sim/Units tools/unitsync">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat May 24 14:55:56 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000702.html">[Taspring-linux-commit] r5922 - in branches/springie/refactoring: .	Springie Springie/autohost/commands
</A></li>
        <LI>Next message: <A HREF="000704.html">[Taspring-linux-commit] r5924 - in trunk/rts: Game Rendering	Rendering/UnitModels
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#703">[ date ]</a>
              <a href="thread.html#703">[ thread ]</a>
              <a href="subject.html#703">[ subject ]</a>
              <a href="author.html#703">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: trepan
Date: 2008-05-24 14:55:54 +0200 (Sat, 24 May 2008)
New Revision: 5923

Added:
   trunk/installer/builddata/springcontent/gamedata/icontypes.lua
   trunk/rts/Rendering/Icon.h
Removed:
   trunk/game/usericons.tdf
Modified:
   trunk/AI/Global/NTai/AI/NTai/Agents/CManufacturer.cpp
   trunk/game/LuaUI/Widgets/ico_customicons.lua
   trunk/installer/builddata/springcontent/gamedata/parse_tdf.lua
   trunk/installer/builddata/springcontent/gamedata/sidedata.lua
   trunk/installer/make_luaui_nsh.py
   trunk/installer/sections/luaui.nsh
   trunk/rts/ExternalAI/AICallback.cpp
   trunk/rts/Game/Game.cpp
   trunk/rts/Game/StartScripts/CommanderScript.cpp
   trunk/rts/Game/StartScripts/CommanderScript2.cpp
   trunk/rts/Game/StartScripts/GlobalAITestScript.cpp
   trunk/rts/Game/StartScripts/SpawnScript.cpp
   trunk/rts/Game/UI/LuaUI.cpp
   trunk/rts/Game/UI/MiniMap.cpp
   trunk/rts/Game/UI/MiniMap.h
   trunk/rts/Lua/LuaHandle.cpp
   trunk/rts/Lua/LuaOpenGL.cpp
   trunk/rts/Lua/LuaParser.cpp
   trunk/rts/Lua/LuaParser.h
   trunk/rts/Lua/LuaUnitDefs.cpp
   trunk/rts/Lua/LuaUnsyncedCtrl.cpp
   trunk/rts/Lua/LuaUnsyncedCtrl.h
   trunk/rts/Lua/LuaUnsyncedRead.cpp
   trunk/rts/Lua/LuaWeaponDefs.cpp
   trunk/rts/Rendering/IconHandler.cpp
   trunk/rts/Rendering/IconHandler.h
   trunk/rts/Rendering/UnitModels/3DModelParser.h
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Sim/ModInfo.cpp
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/UnitDef.h
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/Sim/Units/UnitDefHandler.h
   trunk/tools/unitsync/unitsync.cpp
Log:

- updated IconHandler to load from 'gamedata/icontypes.lua'
- added the 'gamedata/icontypes.lua' file
- removed the 'usericons.tdf' file
- added the following LuaUnsyncedCtrl call-outs:
    AddUnitIcon(string name, string texture
                [, number size[, number distance[, bool radiusAdjust]]])
    FreeUnitIcon(string name)
- added 'distSqr' into CIconData to avoid (d * d) dynamic calcs
- replaced the UnitDef 'string iconType' with a refCounted
  pointer to a CIconData. This avoids the map search that
  was required to draw the icons
  NOTE: for even better performance, you'd probably want to
        generate a texture atlas, and change CIconData so   
        that it could use a raw texture or the texture atlas
        (icons known at startup would go into the atlas)
        The CIconData class is already setup with its
        Draw() calls...
- made UnitDef::iconType 'mutable'  (less of tvo's HACK HACK)
- updated ico_customicons.lua

- changed FLOZi's sideData LuaParser commit to avoid the side
  string numbering (legacy format based on a TDF deficiency)
- changed SideData 'commander' tag to 'startUnit'
  (and all related code uses startUnit now as well, less 
   confusion with respect to the unitDef isCommander tag)

- added a LuaParser constructor to load from a text chunk
- added a parse_tdf.lua call to load from a text chunk

- locked the reload and disable commands (for luaRules and luaGaia),
  to the host player (actually, player 0 -- be it man or machine)



Modified: trunk/AI/Global/NTai/AI/NTai/Agents/CManufacturer.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Agents/CManufacturer.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/AI/Global/NTai/AI/NTai/Agents/CManufacturer.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -1649,7 +1649,7 @@
 						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
 						break;
 					}
-				case '&#172;':// the lightning power symbol
+				case '&#172;':// the lightning power symbol  FIXME ???
 					{
 						Group = GS-&gt;CreateLineFigure(
 							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),

Modified: trunk/game/LuaUI/Widgets/ico_customicons.lua
===================================================================
--- trunk/game/LuaUI/Widgets/ico_customicons.lua	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/game/LuaUI/Widgets/ico_customicons.lua	2008-05-24 12:55:54 UTC (rev 5923)
@@ -32,6 +32,41 @@
 
 --------------------------------------------------------------------------------
 
+local iconDir = 'LuaUI/Icons/'
+
+local unitIcons = {
+--	{ name = 'default',
+		-- Missing parameters get evualeted to the following by Spring:
+		--   bitmap = &lt;standard radar dot&gt;
+		--   size = 1.0,
+		--   radiusadjust = false,
+		--   distance = 1.0,
+--	},
+	{ name = 'default',             size = 1.0, texture = ''                            },
+	{ name = 'star.user',           size = 1.5, texture = iconDir..'star.png'           },
+	{ name = 'star-dark.user',      size = 1.4, texture = iconDir..'star-dark.png'      },
+	{ name = 'tri-up.user',         size = 1.5, texture = iconDir..'tri-up.png'         },
+	{ name = 'tri-down.user',       size = 1.5, texture = iconDir..'tri-down.png'       },
+	{ name = 'diamond.user',        size = 1.0, texture = iconDir..'diamond.png'        },
+	{ name = 'square.user',         size = 1.0, texture = iconDir..'square.png'         },
+	{ name = 'square_+.user',       size = 1.0, texture = iconDir..'square_+.png'       },
+	{ name = 'square_x.user',       size = 1.0, texture = iconDir..'square_x.png'       },
+	{ name = 'm.user',              size = 1.0, texture = iconDir..'m.png'              },
+	{ name = 'e.user',              size = 1.0, texture = iconDir..'e.png'              },
+	{ name = 'hemi-up.user',        size = 1.2, texture = iconDir..'hemi-up.png'        },
+	{ name = 'hemi-down.user',      size = 1.2, texture = iconDir..'hemi-down.png'      },
+	{ name = 'cross.user',          size = 1.2, texture = iconDir..'cross.png'          },
+	{ name = 'hourglass.user',      size = 1.4, texture = iconDir..'hourglass.png'      },
+	{ name = 'hourglass-side.user', size = 1.4, texture = iconDir..'hourglass-side.png' },
+	{ name = 'sphere.user',         size = 1.0, texture = iconDir..'sphere.png'         },
+	{ name = 'triangle-down.user',  size = 1.0, texture = iconDir..'triangle-down.png'  },
+	{ name = 'triangle-up.user',    size = 1.0, texture = iconDir..'triangle-up.png'    },
+	{ name = 'x.user',              size = 1.4, texture = iconDir..'x.png'              },
+}
+
+
+--------------------------------------------------------------------------------
+
 function widget:Update(deltaTime)
   -- animated Commander(s) icon
   if (commanderUnitDefs) then
@@ -56,12 +91,19 @@
       Spring.SetUnitDefIcon(udid, ud.origIconType)
     end
   end
+  for _,icon in pairs(unitIcons) do
+    Spring.FreeUnitIcon(icon.name)
+  end
 end
 
 
 --------------------------------------------------------------------------------
+function widget:Initialize()
+  -- add the unit icons
+  for _,icon in pairs(unitIcons) do
+    Spring.AddUnitIcon(icon.name, icon.texture, icon.size)
+  end
 
-function widget:Initialize()
   -- Setup the unitdef icons
   for udid,ud in pairs(UnitDefs) do
     if (ud ~= nil) then

Deleted: trunk/game/usericons.tdf
===================================================================
--- trunk/game/usericons.tdf	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/game/usericons.tdf	2008-05-24 12:55:54 UTC (rev 5923)
@@ -1,31 +0,0 @@
-[icontypes]
-{
-	[default]
-	{
-		// Missing parameters get evualeted to the following by Spring:
-		// bitmap=standard radar dot
-		// size=1;
-		// radiusadjust=0;
-		// distance=1;
-	}
-	[star.user]           { size=1.5; bitmap=LuaUI/Icons/star.png; }
-	[star-dark.user]      { size=1.4; bitmap=LuaUI/Icons/star-dark.png; }
-	[tri-up.user]         { size=1.5; bitmap=LuaUI/Icons/tri-up.png; }
-	[tri-down.user]       { size=1.5; bitmap=LuaUI/Icons/tri-down.png; }
-	[diamond.user]        { size=1.0; bitmap=LuaUI/Icons/diamond.png; }
-	[square.user]         { size=1.0; bitmap=LuaUI/Icons/square.png; }
-	[square_+.user]       { size=1.0; bitmap=LuaUI/Icons/square_+.png; }
-	[square_x.user]       { size=1.0; bitmap=LuaUI/Icons/square_x.png; }
-	[m.user]              { size=1.0; bitmap=LuaUI/Icons/m.png; }
-	[e.user]              { size=1.0; bitmap=LuaUI/Icons/e.png; }
-
-	[hemi-up.user]        { size=1.2; bitmap=LuaUI/Icons/hemi-up.png; }
-	[hemi-down.user]      { size=1.2; bitmap=LuaUI/Icons/hemi-down.png; }
-	[cross.user]          { size=1.2; bitmap=LuaUI/Icons/cross.png; }
-	[hourglass.user]      { size=1.4; bitmap=LuaUI/Icons/hourglass.png; }
-	[hourglass-side.user] { size=1.4; bitmap=LuaUI/Icons/hourglass-side.png; }
-	[sphere.user]         { size=1.0; bitmap=LuaUI/Icons/sphere.png; }
-	[triangle-down.user]  { size=1.0; bitmap=LuaUI/Icons/triangle-down.png; }
-	[triangle-up.user]    { size=1.0; bitmap=LuaUI/Icons/triangle-up.png; }
-	[x.user]              { size=1.4; bitmap=LuaUI/Icons/x.png; }
-}

Added: trunk/installer/builddata/springcontent/gamedata/icontypes.lua
===================================================================
--- trunk/installer/builddata/springcontent/gamedata/icontypes.lua	                        (rev 0)
+++ trunk/installer/builddata/springcontent/gamedata/icontypes.lua	2008-05-24 12:55:54 UTC (rev 5923)
@@ -0,0 +1,34 @@
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  file:    icontypes.lua
+--  brief:   icontypes.tdf lua parser
+--  author:  Dave Rodgers
+--
+--  Copyright (C) 2007.
+--  Licensed under the terms of the GNU GPL, v2 or later.
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+
+local tdfFile = 'gamedata/icontypes.tdf'
+if (not VFS.FileExists(tdfFile)) then
+  return {}
+end
+
+
+local TDF = VFS.Include('gamedata/parse_tdf.lua')
+local iconTypes, err = TDF.Parse(tdfFile)
+if (iconTypes == nil) then
+  error('Error parsing icontypes.tdf: ' .. err)
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+return iconTypes.icontypes
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------

Modified: trunk/installer/builddata/springcontent/gamedata/parse_tdf.lua
===================================================================
--- trunk/installer/builddata/springcontent/gamedata/parse_tdf.lua	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/installer/builddata/springcontent/gamedata/parse_tdf.lua	2008-05-24 12:55:54 UTC (rev 5923)
@@ -156,16 +156,8 @@
 
 --------------------------------------------------------------------------------
 
-local function ParseTDF(filename)
-  if (debug) then
-    print('TDF.Parse: ' .. tostring(filename))
-  end
+local function Parse(text)
 
-  local text, err = VFS.LoadFile(filename)
-  if (text == nil) then
-    return nil, err
-  end
-
   text = DosToUnix(text)
   text = StripLineComments(text)
   text = StripBlockComments(text)
@@ -195,6 +187,18 @@
 end
 
 
+local function ParseFile(filename)
+  if (debug) then
+    print('TDF.Parse: ' .. tostring(filename))
+  end
+  local text, err = VFS.LoadFile(filename)
+  if (text == nil) then
+    return nil, err
+  end
+  return Parse(text)
+end
+
+
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 
@@ -223,7 +227,8 @@
 --------------------------------------------------------------------------------
 
 TDFparser = {
-  Parse           = ParseTDF,
+  Parse           = ParseFile,
+  ParseText       = Parse,
   GetKeyFilter    = GetKeyFilter,
   SetKeyFilter    = SetKeyFilter,
   AllowDuplicates = AllowDuplicates,

Modified: trunk/installer/builddata/springcontent/gamedata/sidedata.lua
===================================================================
--- trunk/installer/builddata/springcontent/gamedata/sidedata.lua	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/installer/builddata/springcontent/gamedata/sidedata.lua	2008-05-24 12:55:54 UTC (rev 5923)
@@ -20,14 +20,33 @@
   return false
 end
 
-local sidedata, err = TDF.Parse('gamedata/sidedata.tdf')
-if (sidedata == nil) then
+local sideData, err = TDF.Parse('gamedata/sidedata.tdf')
+if (sideData == nil) then
   error('Error parsing sidedata.tdf: ' .. err)
 end
 
+local luaSides = {}
+local index = 0
+while (true) do
+  local label = 'side' .. index -- tdf names start at 'side0'
+  local data = sideData[label]
+  if (type(data) ~= 'table') then
+    break
+  else
+    print(string.format('%s &quot;%s&quot; &quot;%s&quot;',
+                        label, tostring(data.name), tostring(data.commander)))
+    -- rename 'commander' to 'startunit'
+    data['startunit'] = data['commander']
+    data['commander'] = nil
+    index = index + 1
+    luaSides[index] = data -- lua indices start at 1
+  end
+end
+
+
 --------------------------------------------------------------------------------
 
-return sidedata
+return luaSides
 
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------

Modified: trunk/installer/make_luaui_nsh.py
===================================================================
--- trunk/installer/make_luaui_nsh.py	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/installer/make_luaui_nsh.py	2008-05-24 12:55:54 UTC (rev 5923)
@@ -6,7 +6,6 @@
 #
 #   SetOutPath &quot;$INSTDIR&quot;
 #   File &quot;..\game\gui.lua&quot;
-#   File &quot;..\game\usericons.tdf&quot;
 # 
 #   SetOutPath &quot;$INSTDIR\LuaUI&quot;
 #   File /r /x .svn /x Config\*.lua &quot;..\game\LuaUI\*.*&quot;
@@ -14,7 +13,6 @@
 # !else
 #
 #   Delete &quot;$INSTDIR\gui.lua&quot;
-#   Delete &quot;$INSTDIR\usericons.tdf&quot;
 #   RmDir /r &quot;$INSTDIR\LuaUI&quot;
 #
 # !endif
@@ -65,7 +63,6 @@
 print('')
 print('  SetOutPath &quot;$INSTDIR&quot;')
 print('  File &quot;..\\game\\gui.lua&quot;')
-print('  File &quot;..\\game\\usericons.tdf&quot;')
 print('')
 for d in dirs:
   print('  SetOutPath &quot;$INSTDIR\\' + osName(d) + '&quot;')
@@ -77,7 +74,6 @@
 
 print('')
 print('  Delete &quot;$INSTDIR\\gui.lua&quot;')
-print('  Delete &quot;$INSTDIR\\usericons.tdf&quot;')
 print('')
 for d in dirs:
   for f in dirs[d]:

Modified: trunk/installer/sections/luaui.nsh
===================================================================
--- trunk/installer/sections/luaui.nsh	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/installer/sections/luaui.nsh	2008-05-24 12:55:54 UTC (rev 5923)
@@ -5,7 +5,6 @@
 
   SetOutPath &quot;$INSTDIR&quot;
   File &quot;..\game\gui.lua&quot;
-  File &quot;..\game\usericons.tdf&quot;
 
   SetOutPath &quot;$INSTDIR\LuaUI\Images\&quot;
   File &quot;..\game\LuaUI\Images\players.png&quot;
@@ -112,7 +111,6 @@
 !else
 
   Delete &quot;$INSTDIR\gui.lua&quot;
-  Delete &quot;$INSTDIR\usericons.tdf&quot;
 
   Delete &quot;$INSTDIR\LuaUI\Images\players.png&quot;
   Delete &quot;$INSTDIR\LuaUI\Images\highlight_strip.png&quot;

Modified: trunk/rts/ExternalAI/AICallback.cpp
===================================================================
--- trunk/rts/ExternalAI/AICallback.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/ExternalAI/AICallback.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -514,7 +514,7 @@
 	verify ();
 	if (CHECK_UNITID(unitid)) {
 		CUnit* unit=uh-&gt;units[unitid];
-		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
+		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			return unit-&gt;experience;
 		}
 	}
@@ -672,7 +672,8 @@
 	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
-		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp;
+		    (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			if (!IsUnitNeutral(u-&gt;id)) {
 				units[a++] = u-&gt;id;
 			}

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Game/Game.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -158,6 +158,7 @@
 
 CGame* game = NULL;
 
+
 CR_BIND(CGame, (std::string(&quot;&quot;), std::string(&quot;&quot;), NULL, NULL));
 
 CR_REG_METADATA(CGame,(
@@ -289,6 +290,7 @@
 	camHandler = SAFE_NEW CCameraHandler();
 	selectionKeys = SAFE_NEW CSelectionKeyHandler();
 	tooltip = SAFE_NEW CTooltipConsole();
+	iconHandler = SAFE_NEW CIconHandler();
 
 	ENTER_MIXED;
 
@@ -382,7 +384,6 @@
 
 	ENTER_MIXED;
 	uh = SAFE_NEW CUnitHandler();
-	iconHandler = SAFE_NEW CIconHandler();
 	unitDrawer = SAFE_NEW CUnitDrawer();
 	fartextureHandler = SAFE_NEW CFartextureHandler();
 	modelParser = SAFE_NEW C3DModelParser();
@@ -560,6 +561,7 @@
 	delete hpiHandler;         hpiHandler         = NULL;
 	delete archiveScanner;     archiveScanner     = NULL;
 	delete modelParser;        modelParser        = NULL;
+	delete iconHandler;        iconHandler        = NULL;
 	delete fartextureHandler;  fartextureHandler  = NULL;
 	delete camera;             camera             = NULL;
 	delete cam2;               cam2               = NULL;
@@ -577,6 +579,7 @@
 	CColorMap::DeleteColormaps();
 }
 
+
 void CGame::PostLoad()
 {
 	if (gameServer) {
@@ -584,6 +587,7 @@
 	}
 }
 
+
 void CGame::ResizeEvent()
 {
 	if (minimap != NULL) {
@@ -794,8 +798,8 @@
 	// try the input receivers
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
-	for(ri=inputReceivers.begin();ri!=inputReceivers.end();++ri){
-		if((*ri) &amp;&amp; (*ri)-&gt;KeyPressed(k, isRepeat)) {
+	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
+		if ((*ri) &amp;&amp; (*ri)-&gt;KeyPressed(k, isRepeat)) {
 			return 0;
 		}
 	}
@@ -816,16 +820,17 @@
 {
 	//	keys[k] = false;
 
-	if ((userWriting) &amp;&amp; (((k&gt;=' ') &amp;&amp; (k&lt;='Z')) || (k==8) || (k==190) )){
+	if ((userWriting) &amp;&amp; (((k&gt;=' ') &amp;&amp; (k&lt;='Z')) || (k==8) || (k==190))) {
 		return 0;
 	}
 
 	// try the input receivers
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
-	for(ri=inputReceivers.begin();ri!=inputReceivers.end();++ri){
-		if((*ri) &amp;&amp; (*ri)-&gt;KeyReleased(k))
+	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
+		if ((*ri) &amp;&amp; (*ri)-&gt;KeyReleased(k)) {
 			return 0;
+		}
 	}
 
 	// try our list of actions
@@ -2170,9 +2175,9 @@
 		else
 			logOutput.Print(&quot;No definition Editing&quot;);
 	}
-	else if (action.command == &quot;luarules&quot; &amp;&amp; (gs-&gt;frameNum &gt; 1)) {
+	else if ((action.command == &quot;luarules&quot;) &amp;&amp; (gs-&gt;frameNum &gt; 1)) {
 		if (gs-&gt;useLuaRules) {
-			if (action.extra == &quot;reload&quot;) {
+			if ((action.extra == &quot;reload&quot;) &amp;&amp; (playernum == 0)) {
 				if (!gs-&gt;cheatEnabled) {
 					logOutput.Print(&quot;Cheating required to reload synced scripts&quot;);
 				} else {
@@ -2185,7 +2190,7 @@
 					}
 				}
 			}
-			else if (action.extra == &quot;disable&quot;) {
+			else if ((action.extra == &quot;disable&quot;) &amp;&amp; (playernum == 0)) {
 				if (!gs-&gt;cheatEnabled) {
 					logOutput.Print(&quot;Cheating required to disable synced scripts&quot;);
 				} else {
@@ -2201,9 +2206,9 @@
 			}
 		}
 	}
-	else if (action.command == &quot;luagaia&quot; &amp;&amp; (gs-&gt;frameNum &gt; 1)) {
+	else if ((action.command == &quot;luagaia&quot;) &amp;&amp; (gs-&gt;frameNum &gt; 1)) {
 		if (gs-&gt;useLuaGaia) {
-			if (action.extra == &quot;reload&quot;) {
+			if ((action.extra == &quot;reload&quot;) &amp;&amp; (playernum == 0)) {
 				if (!gs-&gt;cheatEnabled) {
 					logOutput.Print(&quot;Cheating required to reload synced scripts&quot;);
 				} else {
@@ -2216,7 +2221,7 @@
 					}
 				}
 			}
-			else if (action.extra == &quot;disable&quot;) {
+			else if ((action.extra == &quot;disable&quot;) &amp;&amp; (playernum == 0)) {
 				if (!gs-&gt;cheatEnabled) {
 					logOutput.Print(&quot;Cheating required to disable synced scripts&quot;);
 				} else {
@@ -3700,6 +3705,9 @@
 				const int whichAllyTeam = inbuf[2];
 				const bool allied = static_cast&lt;bool&gt;(inbuf[3]);
 				if (whichAllyTeam &lt; MAX_TEAMS &amp;&amp; whichAllyTeam &gt;= 0) {
+					// FIXME - need to reset unit allyTeams
+					//       - need to reset unit texture for 3do
+					//       - need a call-in for lua and AIs
 					gs-&gt;SetAlly(gs-&gt;AllyTeam(gs-&gt;players[player]-&gt;team), whichAllyTeam, allied);
 				} else {
 					logOutput.Print(&quot;Player %i sent out wrong allyTeam index in alliance message&quot;, player);

Modified: trunk/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/CommanderScript.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Game/StartScripts/CommanderScript.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -38,22 +38,24 @@
 void CCommanderScript::GameStart()
 {
 	if (gameSetup) {
-		LuaParser p(&quot;gamedata/sidedata.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
-		if (!p.Execute() || !p.IsValid())
-			logOutput.Print(p.GetErrorLog());
-			
-		const LuaTable sideTable = p.GetRoot();
+		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		if (!luaParser.Execute()) {
+			logOutput.Print(luaParser.GetErrorLog());
+		}
 
+		const LuaTable sideData = luaParser.GetRoot();
+
 		// make a map of all side names  (assumes contiguous sections)
 		std::map&lt;std::string, std::string&gt; sideMap;
-		char sideText[64];
-		for (int side = 0;
-				 SNPRINTF(sideText, sizeof(sideText), &quot;side%i&quot;, side),
-				 sideTable.KeyExists(sideText); // the test
-				 side++) {
-			const std::string sideName =
-				StringToLower(sideTable.SubTable(std::string(sideText)).GetString(&quot;name&quot;, &quot;No Name&quot;));
-			sideMap[sideName] = sideText;
+		for (int i = 1; true; i++) {
+			const LuaTable side = sideData.SubTable(i);
+			if (!side.IsValid()) {
+				break;
+			}
+			const std::string sideName = side.GetString(&quot;name&quot;, &quot;unknown&quot;);
+			const std::string startUnit = side.GetString(&quot;startUnit&quot;, &quot;&quot;);
+			sideMap[sideName] = StringToLower(startUnit);
 		}
 
 		// setup the teams
@@ -76,38 +78,46 @@
 				globalAI-&gt;CreateGlobalAI(a, gameSetup-&gt;aiDlls[a].c_str());
 			}
 
-			std::map&lt;std::string, std::string&gt;::const_iterator it = sideMap.find(team-&gt;side);
+			std::map&lt;std::string, std::string&gt;::const_iterator it =
+				sideMap.find(team-&gt;side);
 
 			if (it != sideMap.end()) {
-				const std::string&amp; sideSection = it-&gt;second;
-				const std::string cmdrType =
-					StringToLower(sideTable.SubTable(sideSection).GetString(&quot;commander&quot;,&quot;&quot;));
-				if (cmdrType.length() == 0)
-					throw content_error (&quot;Unable to load a commander for SIDE&quot; + sideSection);
-				CUnit* unit = unitLoader.LoadUnit(cmdrType, team-&gt;startPos, a, false, 0, NULL);
+				const std::string&amp; sideName = it-&gt;first;
+				const std::string&amp; startUnit = it-&gt;second;
+				if (startUnit.length() == 0) {
+					throw content_error (
+						&quot;Unable to load a commander for the first side: &quot; + sideName
+					);
+				}
+				CUnit* unit = unitLoader.LoadUnit(startUnit,
+				                                  team-&gt;startPos, a, false, 0, NULL);
 
 				team-&gt;lineageRoot = unit-&gt;id;
 
 				// FIXME this shouldn't be here, but no better place exists currently
 				if (a == gu-&gt;myTeam) {
 					minimap-&gt;AddNotification(team-&gt;startPos,
-							float3(1.0f, 1.0f, 1.0f), 1.0f);
+					                         float3(1.0f, 1.0f, 1.0f), 1.0f);
 					game-&gt;infoConsole-&gt;SetLastMsgPos(team-&gt;startPos);
 				}
 			}
 		}
 	}
 	else {
-		LuaParser p(&quot;gamedata/sidedata.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
-		if (!p.Execute() || !p.IsValid())
-			logOutput.Print(p.GetErrorLog());
-		
-		const LuaTable sideTable = p.GetRoot();
-		const std::string s0 = StringToLower(sideTable.SubTable(&quot;side0&quot;).GetString(&quot;commander&quot;, &quot;&quot;));
-		const std::string s1 = StringToLower(sideTable.SubTable(&quot;side1&quot;).GetString(&quot;commander&quot;, s0)); // default to side 0, in case mod has only 1 side
+		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		if (!luaParser.Execute()) {
+			logOutput.Print(luaParser.GetErrorLog());
+		}
+		const LuaTable sideData = luaParser.GetRoot();
+		const LuaTable side1 = sideData.SubTable(1);
+		const LuaTable side2 = sideData.SubTable(2);
+		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
 
-		if (s0.length() == 0)
-			throw content_error (&quot;Unable to load a commander for SIDE0&quot;);
+		if (su1.length() == 0) {
+			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
+		}
 		
 		TdfParser p2;
 		CMapInfo::OpenTDF(stupidGlobalMapname, p2);
@@ -118,8 +128,8 @@
 		p2.GetDef(x1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosX&quot;);
 		p2.GetDef(z1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosZ&quot;);
 
-		unitLoader.LoadUnit(s0, float3(x0, 80.0f, z0), 0, false, 0, NULL);
-		unitLoader.LoadUnit(s1, float3(x1, 80.0f, z1), 1, false, 0, NULL);
+		unitLoader.LoadUnit(su1, float3(x0, 80.0f, z0), 0, false, 0, NULL);
+		unitLoader.LoadUnit(su2, float3(x1, 80.0f, z1), 1, false, 0, NULL);
 
 		// FIXME this shouldn't be here, but no better place exists currently
 		minimap-&gt;AddNotification(float3(x0, 80.0f, z0),

Modified: trunk/rts/Game/StartScripts/CommanderScript2.cpp
===================================================================
--- trunk/rts/Game/StartScripts/CommanderScript2.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Game/StartScripts/CommanderScript2.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -39,16 +39,20 @@
 		gs-&gt;Team(1)-&gt;metalIncome=1000;
 		gs-&gt;Team(1)-&gt;metalStorage=1000;
 
-		LuaParser p(&quot;gamedata/sidedata.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
-		if (!p.Execute() || !p.IsValid())
-			logOutput.Print(p.GetErrorLog());
-		
-		const LuaTable sideTable = p.GetRoot();
-		const std::string s0 = StringToLower(sideTable.SubTable(&quot;side0&quot;).GetString(&quot;commander&quot;, &quot;&quot;));
-		const std::string s1 = StringToLower(sideTable.SubTable(&quot;side1&quot;).GetString(&quot;commander&quot;, s0)); // default to side 0, in case mod has only 1 side
+		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		if (!luaParser.Execute()) {
+			logOutput.Print(luaParser.GetErrorLog());
+		}
+		const LuaTable sideData = luaParser.GetRoot();
+		const LuaTable side1 = sideData.SubTable(1);
+		const LuaTable side2 = sideData.SubTable(2);
+		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
 
-		if (s0.length() == 0)
-			throw content_error (&quot;Unable to load a commander for SIDE0&quot;);
+		if (su1.length() == 0) {
+			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
+		}
 
 		TdfParser p2;
 		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
@@ -59,8 +63,8 @@
 		p2.GetDef(x1,&quot;1200&quot;,&quot;MAP\\TEAM1\\StartPosX&quot;);
 		p2.GetDef(z1,&quot;1200&quot;,&quot;MAP\\TEAM1\\StartPosZ&quot;);
 
-		unitLoader.LoadUnit(s0, float3(x0, 80, z0), 0, false, 0, NULL);
-		unitLoader.LoadUnit(s1, float3(x1, 80, z1), 1, false, 0, NULL);
+		unitLoader.LoadUnit(su1, float3(x0, 80, z0), 0, false, 0, NULL);
+		unitLoader.LoadUnit(su2, float3(x1, 80, z1), 1, false, 0, NULL);
 
 //		unitLoader.LoadUnit(&quot;armsam&quot;,float3(2650,10,2600),0,false);
 //		unitLoader.LoadUnit(&quot;armflash&quot;,float3(2450,10,2600),1,false);

Modified: trunk/rts/Game/StartScripts/GlobalAITestScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -15,44 +15,53 @@
 #include &quot;System/Platform/FileSystem.h&quot;
 #include &quot;mmgr.h&quot;
 
+
 extern std::string stupidGlobalMapname;
 
+
 CGlobalAITestScript::CGlobalAITestScript(std::string dll)
 	: CScript(std::string(&quot;GlobalAI test (&quot;) + filesystem.GetFilename(dll) + std::string(&quot;)&quot;)),
 	dllName(dll)
 {
 }
 
+
 CGlobalAITestScript::~CGlobalAITestScript(void)
 {
 }
 
+
 void CGlobalAITestScript::Update(void)
 {
 	switch (gs-&gt;frameNum) {
 		case 0: {
 			globalAI-&gt;CreateGlobalAI(1, dllName.c_str());
 
-			gs-&gt;Team(0)-&gt;energy = 1000;
+			gs-&gt;Team(0)-&gt;energy        = 1000;
 			gs-&gt;Team(0)-&gt;energyStorage = 1000;
-			gs-&gt;Team(0)-&gt;metal = 1000;
-			gs-&gt;Team(0)-&gt;metalStorage = 1000;
+			gs-&gt;Team(0)-&gt;metal         = 1000;
+			gs-&gt;Team(0)-&gt;metalStorage  = 1000;
 
-			gs-&gt;Team(1)-&gt;energy = 1000;
+			gs-&gt;Team(1)-&gt;energy        = 1000;
 			gs-&gt;Team(1)-&gt;energyStorage = 1000;
-			gs-&gt;Team(1)-&gt;metal = 1000;
-			gs-&gt;Team(1)-&gt;metalStorage = 1000;
+			gs-&gt;Team(1)-&gt;metal         = 1000;
+			gs-&gt;Team(1)-&gt;metalStorage  = 1000;
 
-			LuaParser p(&quot;gamedata/sidedata.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
-			if (!p.Execute() || !p.IsValid())
-				logOutput.Print(p.GetErrorLog());
-		
-			const LuaTable sideTable = p.GetRoot();
-			const std::string s0 = StringToLower(sideTable.SubTable(&quot;side0&quot;).GetString(&quot;commander&quot;, &quot;&quot;));
-			const std::string s1 = StringToLower(sideTable.SubTable(&quot;side1&quot;).GetString(&quot;commander&quot;, s0)); // default to side 0, in case mod has only 1 side
+			LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+													SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+			if (!luaParser.Execute()) {
+				logOutput.Print(luaParser.GetErrorLog());
+			}
+			const LuaTable sideData = luaParser.GetRoot();
+			const LuaTable side1 = sideData.SubTable(1);
+			const LuaTable side2 = sideData.SubTable(2);
+			const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+			const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
+			// default to side 1, in case mod has only 1 side
 
-			if (s0.length() == 0)
-				throw content_error (&quot;Unable to load a commander for SIDE0&quot;);
+			if (su1.length() == 0) {
+				throw content_error (&quot;Unable to load a commander for the first side&quot;);
+			}
 
 			TdfParser p2;
 			CMapInfo::OpenTDF(stupidGlobalMapname, p2);
@@ -63,11 +72,12 @@
 			p2.GetDef(x1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosX&quot;);
 			p2.GetDef(z1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosZ&quot;);
 
-			unitLoader.LoadUnit(s0, float3(x0, 80, z0), 0, false, 0, NULL);
-			unitLoader.LoadUnit(s1, float3(x1, 80, z1), 1, false, 0, NULL);
+			unitLoader.LoadUnit(su1, float3(x0, 80, z0), 0, false, 0, NULL);
+			unitLoader.LoadUnit(su2, float3(x1, 80, z1), 1, false, 0, NULL);
 			break;
 		}
-		default:
+		default: {
 			break;
+		}
 	}
 }

Modified: trunk/rts/Game/StartScripts/SpawnScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/SpawnScript.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Game/StartScripts/SpawnScript.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -35,17 +35,21 @@
 	case 0:
 		LoadSpawns();
 
-		LuaParser p(&quot;gamedata/sidedata.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
-		if (!p.Execute() || !p.IsValid())
-			logOutput.Print(p.GetErrorLog());
-		
-		const LuaTable sideTable = p.GetRoot();
-		const std::string s0 = StringToLower(sideTable.SubTable(&quot;side0&quot;).GetString(&quot;commander&quot;, &quot;&quot;));
-		const std::string s1 = StringToLower(sideTable.SubTable(&quot;side1&quot;).GetString(&quot;commander&quot;, s0)); // default to side 0, in case mod has only 1 side
-		
-		if (s0.length() == 0)
-			throw content_error (&quot;Unable to load a commander for SIDE0&quot;);
+		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		if (!luaParser.Execute()) {
+			logOutput.Print(luaParser.GetErrorLog());
+		}
+		const LuaTable sideData = luaParser.GetRoot();
+		const LuaTable side1 = sideData.SubTable(1);
+		const LuaTable side2 = sideData.SubTable(2);
+		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
 
+		if (su1.length() == 0) {
+			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
+		}
+
 		TdfParser p2;
 		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
 
@@ -56,7 +60,7 @@
 		// Set the TEAM0 startpos as spawnpos if we're supposed to be
 		// autonomous, load the commander for the player if not.
 		if (autonomous) spawnPos.push_back(float3(x0,80,z0));
-		else unitLoader.LoadUnit(s0,float3(x0,80,z0),0,false,0,NULL);
+		else unitLoader.LoadUnit(su1, float3(x0,80,z0),0,false,0,NULL);
 
 		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM1\\StartPosX&quot;);
 		p2.GetDef(z0,&quot;1000&quot;,&quot;MAP\\TEAM1\\StartPosZ&quot;);

Modified: trunk/rts/Game/UI/LuaUI.cpp
===================================================================
--- trunk/rts/Game/UI/LuaUI.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Game/UI/LuaUI.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -52,6 +52,7 @@
 #include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/InMapDraw.h&quot;
 #include &quot;Rendering/FontTexture.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -2347,21 +2348,18 @@
 			&quot;Incorrect arguments to SetUnitDefIcon(unitDefID, \&quot;icon\&quot;)&quot;);
 	}
 	const int unitDefID = (int)lua_tonumber(L, 1);
-	// HACK FIXME TODO remove the const_cast: factor iconType out of UnitDef
-	// so unitDef doesn't need to be modified by this code.
-	UnitDef* ud = const_cast&lt;UnitDef*&gt;(unitDefHandler-&gt;GetUnitByID(unitDefID));
+	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 	if (ud == NULL) {
 		return 0;
 	}
 
-	ud-&gt;iconType = lua_tostring(L, 2);
+	ud-&gt;iconType = iconHandler-&gt;GetIcon(lua_tostring(L, 2));
 
 	// set decoys to the same icon
 	map&lt;int, set&lt;int&gt; &gt;::const_iterator fit;
 
 	if (ud-&gt;decoyDef) {
-		// more HACK HACK (see above)
-		const_cast&lt;UnitDef*&gt;(ud-&gt;decoyDef)-&gt;iconType = ud-&gt;iconType;
+		ud-&gt;decoyDef-&gt;iconType = ud-&gt;iconType;
 		fit = unitDefHandler-&gt;decoyMap.find(ud-&gt;decoyDef-&gt;id);
 	} else {
 		fit = unitDefHandler-&gt;decoyMap.find(ud-&gt;id);
@@ -2370,9 +2368,8 @@
 		const set&lt;int&gt;&amp; decoySet = fit-&gt;second;
 		set&lt;int&gt;::const_iterator dit;
 		for (dit = decoySet.begin(); dit != decoySet.end(); ++dit) {
-  		// more HACK HACK (see above)
-  		const UnitDef* constDef = unitDefHandler-&gt;GetUnitByID(*dit);
-			const_cast&lt;UnitDef*&gt;(constDef)-&gt;iconType = ud-&gt;iconType;
+  		const UnitDef* decoyDef = unitDefHandler-&gt;GetUnitByID(*dit);
+			decoyDef-&gt;iconType = ud-&gt;iconType;
 		}
 	}
 

Modified: trunk/rts/Game/UI/MiniMap.cpp
===================================================================
--- trunk/rts/Game/UI/MiniMap.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Game/UI/MiniMap.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -1393,7 +1393,7 @@
 }
 
 
-inline CIcon* CMiniMap::GetUnitIcon(CUnit* unit, float&amp; scale) const
+inline const CIconData* CMiniMap::GetUnitIcon(CUnit* unit, float&amp; scale) const
 {
 	scale = 1.0f;
 
@@ -1403,16 +1403,16 @@
 		if ((losStatus &amp; LOS_INLOS) ||
 				((losStatus &amp; prevMask) == prevMask) ||
 				gu-&gt;spectatingFullView) {
-			CIcon* icon = iconHandler-&gt;GetIcon(unit-&gt;unitDef-&gt;iconType);
-			if (icon-&gt;radiusAdjust) {
+			const CIconData* iconData = unit-&gt;unitDef-&gt;iconType.GetIconData();
+			if (iconData-&gt;GetRadiusAdjust()) {
 				scale *= (unit-&gt;radius / 30.0f);
 			}
-			return icon;
+			return iconData;
 		}
 	}
 
 	if (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INRADAR) {
-		return iconHandler-&gt;GetIcon(&quot;default&quot;);
+		return iconHandler-&gt;GetDefaultIconData();
 	}
 
 	return NULL;
@@ -1433,8 +1433,8 @@
 
 	// includes the visibility check
 	float iconScale;
-	CIcon* icon = GetUnitIcon(unit, iconScale);
-	if (icon == NULL) {
+	const CIconData* iconData = GetUnitIcon(unit, iconScale);
+	if (iconData == NULL) {
 		return;
 	}
 
@@ -1452,7 +1452,7 @@
 	}
 	else {
 		if (simpleColors) {
-			if (unit-&gt;team==gu-&gt;myTeam) {
+			if (unit-&gt;team == gu-&gt;myTeam) {
 				glColor3ubv(myColor);
 			} else if (gs-&gt;Ally(gu-&gt;myAllyTeam, unit-&gt;allyteam)) {
 				glColor3ubv(allyColor);
@@ -1464,17 +1464,16 @@
 		}
 	}
 
-	iconScale *= icon-&gt;size;
+	iconScale *= iconData-&gt;GetSize();
 	const float sizeX = (iconScale * unitSizeX);
 	const float sizeY = (iconScale * unitSizeY);
 
-	glBindTexture(GL_TEXTURE_2D, icon-&gt;texture);
-	glBegin(GL_QUADS);
-		glTexCoord2f(1.0f, 1.0f); glVertex2f(pos.x + sizeX, pos.z + sizeY);
-		glTexCoord2f(1.0f, 0.0f); glVertex2f(pos.x + sizeX, pos.z - sizeY);
-		glTexCoord2f(0.0f, 0.0f); glVertex2f(pos.x - sizeX, pos.z - sizeY);
-		glTexCoord2f(0.0f, 1.0f); glVertex2f(pos.x - sizeX, pos.z + sizeY);
-	glEnd();
+	const float x0 = pos.x - sizeX;
+	const float x1 = pos.x + sizeX;
+	const float y0 = pos.z - sizeY;
+	const float y1 = pos.z + sizeY;
+
+	iconData-&gt;Draw(x0, y0, x1, y1);
 }
 
 

Modified: trunk/rts/Game/UI/MiniMap.h
===================================================================
--- trunk/rts/Game/UI/MiniMap.h	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Game/UI/MiniMap.h	2008-05-24 12:55:54 UTC (rev 5923)
@@ -10,7 +10,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 
 class CUnit;
-class CIcon;
+class CIconData;
 
 
 class CMiniMap : public CInputReceiver {
@@ -69,7 +69,7 @@
 		void DrawUnit(CUnit* unit);
 		void DrawUnitHighlight(CUnit* unit);
 		void DrawCircle(const float3&amp; pos, float radius);
-		CIcon* GetUnitIcon(CUnit* unit, float&amp; scale) const;
+		const CIconData* GetUnitIcon(CUnit* unit, float&amp; scale) const;
 		void GetFrustumSide(float3&amp; side);
 		
 	protected:

Modified: trunk/rts/Lua/LuaHandle.cpp
===================================================================
--- trunk/rts/Lua/LuaHandle.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaHandle.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -1,5 +1,5 @@
 #include &quot;StdAfx.h&quot;
-// LuaRules.cpp: implementation of the CLuaRules class.
+// LuaHandle.cpp: implementation of the CLuaHandle class.
 //
 //////////////////////////////////////////////////////////////////////
 

Modified: trunk/rts/Lua/LuaOpenGL.cpp
===================================================================
--- trunk/rts/Lua/LuaOpenGL.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaOpenGL.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -1614,9 +1614,8 @@
 	//if (sqDist &gt;= farLength) {
 	//	return NULL;
 	//}
-	const float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
-	const float realIconLength =
-		unitDrawer-&gt;iconLength * (iconDistMult * iconDistMult);
+	const float iconDistSqrMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistanceSqr();
+	const float realIconLength = unitDrawer-&gt;iconLength * iconDistSqrMult;
 	if (sqDist &gt;= realIconLength) {
 		return NULL;
 	}

Modified: trunk/rts/Lua/LuaParser.cpp
===================================================================
--- trunk/rts/Lua/LuaParser.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaParser.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -78,6 +78,7 @@
                      const string&amp; _accessModes)
 : fileName(_fileName),
   fileModes(_fileModes),
+  textChunk(&quot;&quot;),
   accessModes(_accessModes),
   valid(false),
   initDepth(0),
@@ -104,6 +105,37 @@
 }
 
 
+LuaParser::LuaParser(const string&amp; _textChunk,
+                     const string&amp; _accessModes)
+: fileName(&quot;&quot;),
+  fileModes(&quot;&quot;),
+  textChunk(_textChunk),
+  accessModes(_accessModes),
+  valid(false),
+  initDepth(0),
+  rootRef(LUA_NOREF),
+  currentRef(LUA_NOREF)
+{
+	L = lua_open();
+
+	if (L != NULL) {
+		SetupStdLibs(L);
+
+		GetTable(&quot;Spring&quot;);
+		AddFunc(&quot;Echo&quot;, Echo);
+		AddFunc(&quot;TimeCheck&quot;, TimeCheck);
+		EndTable();
+
+		GetTable(&quot;VFS&quot;);
+		AddFunc(&quot;DirList&quot;,    DirList);
+		AddFunc(&quot;Include&quot;,    Include);
+		AddFunc(&quot;LoadFile&quot;,   LoadFile);
+		AddFunc(&quot;FileExists&quot;, FileExists);
+		EndTable();
+	}
+}
+
+
 LuaParser::~LuaParser()
 {
 	if (L != NULL) {
@@ -297,20 +329,28 @@
 	initDepth = -1;
 
 	string code;
-	CFileHandler fh(fileName, fileModes);
-	if (!fh.LoadStringData(code)) {
-		errorLog = &quot;could not open file: &quot; + fileName;
-		lua_close(L);
-		L = NULL;
-		return false;
+	string codeLabel;
+	if (textChunk.size() &gt; 0) {
+		code = textChunk;
+		codeLabel = &quot;text chunk&quot;;
 	}
+	else {
+		codeLabel = fileName;
+		CFileHandler fh(fileName, fileModes);
+		if (!fh.LoadStringData(code)) {
+			errorLog = &quot;could not open file: &quot; + fileName;
+			lua_close(L);
+			L = NULL;
+			return false;
+		}
+	}
 
 	int error;
-	error = luaL_loadbuffer(L, code.c_str(), code.size(), fileName.c_str());
+	error = luaL_loadbuffer(L, code.c_str(), code.size(), codeLabel.c_str());
 	if (error != 0) {
 		errorLog = lua_tostring(L, -1);
 		logOutput.Print(&quot;error = %i, %s, %s\n&quot;,
-		                error, fileName.c_str(), errorLog.c_str());
+		                error, codeLabel.c_str(), errorLog.c_str());
 		lua_close(L);
 		L = NULL;
 		return false;

Modified: trunk/rts/Lua/LuaParser.h
===================================================================
--- trunk/rts/Lua/LuaParser.h	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaParser.h	2008-05-24 12:55:54 UTC (rev 5923)
@@ -93,6 +93,8 @@
 		LuaParser(const string&amp; fileName,
 		          const string&amp; fileModes,
 		          const string&amp; accessModes);
+		LuaParser(const string&amp; textChunk,
+		          const string&amp; accessModes);
 		~LuaParser();
 
 		bool Execute();
@@ -123,6 +125,7 @@
 	public:
 		const string fileName;
 		const string fileModes;
+		const string textChunk;
 		const string accessModes;
 
 	private:

Modified: trunk/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaUnitDefs.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaUnitDefs.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -23,6 +23,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
 #include &quot;Map/MapInfo.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
@@ -313,8 +314,8 @@
 {
 	// the iconType is unsynced because LuaUI has SetUnitDefIcon()
 	if (CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
-		const string&amp; iconType = *((const string*)data);
-		lua_pushstring(L, iconType.c_str());
+		const CIcon&amp; iconType = *((const CIcon*)data);
+		lua_pushstring(L, iconType-&gt;GetName().c_str());
 		return 1;
 	}
 	return 0;

Modified: trunk/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -28,6 +28,7 @@
 #include &quot;Game/UI/CursorIcons.h&quot;
 #include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
@@ -101,6 +102,9 @@
 	REGISTER_LUA_CFUNC(SetUnitNoMinimap);
 	REGISTER_LUA_CFUNC(SetUnitNoSelect);
 
+	REGISTER_LUA_CFUNC(AddUnitIcon);
+	REGISTER_LUA_CFUNC(FreeUnitIcon);
+
 	REGISTER_LUA_CFUNC(ExtractModArchiveFile);
 	return true;
 }
@@ -929,64 +933,86 @@
 }
 
 
+/******************************************************************************/
 
+int LuaUnsyncedCtrl::AddUnitIcon(lua_State* L)
+{
+	if (!CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
+		return 0;
+	}
+	const string iconName  = luaL_checkstring(L, 1);
+	const string texName   = luaL_checkstring(L, 2);
+	const float  size      = luaL_optnumber(L, 3, 1.0f);
+	const float  dist      = luaL_optnumber(L, 4, 1.0f);
+	const bool   radAdjust = (lua_isboolean(L, 5) &amp;&amp; lua_toboolean(L, 5));
+	lua_pushboolean(L, iconHandler-&gt;AddIcon(iconName, texName,
+	                                        size, dist, radAdjust));
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::FreeUnitIcon(lua_State* L)
+{
+	if (!CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
+		return 0;
+	}
+	const string iconName  = luaL_checkstring(L, 1);
+	lua_pushboolean(L, iconHandler-&gt;FreeIcon(iconName));
+	return 1;
+}
+
+
+/******************************************************************************/
+
 // TODO: move this to LuaVFS?
 int LuaUnsyncedCtrl::ExtractModArchiveFile(lua_State* L)
 {
-	bool ret = false;
-	const int args = lua_gettop(L);
+	const string path = luaL_checkstring(L, 1);
 
-	if (args == 1) {
-		if (lua_isstring(L, 1)) {
-			std::string path(lua_tostring(L, 1));
-			CFileHandler fh(path, SPRING_VFS_MOD);
+	CFileHandler fh(path, SPRING_VFS_MOD);
 
-			if (fh.FileExists()) {
-				std::string dname = filesystem.GetDirectory(path);
-				std::string fname = filesystem.GetFilename(path);
+	if (!fh.FileExists()) {
+		luaL_error(L, &quot;Path \&quot;%s\&quot; not found in mod archive&quot;, path.c_str());
+	}
 
-				#ifdef WIN32
-				const int s = dname.size();
-				// get rid of any trailing slashes (CreateDirectory()
-				// fails on at least XP and Vista if they are present,
-				// ie. it creates the dir but actually returns false)
-				if (s &gt; 0 &amp;&amp; (dname[s - 1] == '/' || dname[s - 1] == '\\')) {
-					dname = dname.substr(0, s - 1);
-				}
-				#endif
+	string dname = filesystem.GetDirectory(path);
+	string fname = filesystem.GetFilename(path);
 
-				if (dname.size() == 0 || filesystem.CreateDirectory(dname)) {
-					int numBytes = fh.FileSize();
-					char* buffer = SAFE_NEW char[numBytes];
+#ifdef WIN32
+	const int s = dname.size();
+	// get rid of any trailing slashes (CreateDirectory()
+	// fails on at least XP and Vista if they are present,
+	// ie. it creates the dir but actually returns false)
+	if ((s &gt; 0) &amp;&amp; ((dname[s - 1] == '/') || (dname[s - 1] == '\\'))) {
+		dname = dname.substr(0, s - 1);
+	}
+#endif
 
-					fh.Read(buffer, numBytes);
+	if (!dname.empty() &amp;&amp; !filesystem.CreateDirectory(dname)) {
+		luaL_error(L, &quot;Could not create directory \&quot;%s\&quot; for file \&quot;%s\&quot;&quot;,
+		           dname.c_str(), fname.c_str());
+	}
 
-					std::fstream fstr(path.c_str(), std::ios::out | std::ios::binary);
-					fstr.write((const char*) buffer, numBytes);
-					fstr.close();
+	const int numBytes = fh.FileSize();
+	char* buffer = SAFE_NEW char[numBytes];
 
-					if (dname.size() &gt; 0) {
-						logOutput.Print(&quot;Extracted file \&quot;%s\&quot; to directory \&quot;%s\&quot;&quot;, fname.c_str(), dname.c_str());
-					} else {
-						logOutput.Print(&quot;Extracted file \&quot;%s\&quot;&quot;, fname.c_str());
-					}
+	fh.Read(buffer, numBytes);
 
-					delete[] buffer;
-					ret = true;
-				} else {
-					luaL_error(L, &quot;Could not create directory \&quot;%s\&quot; for file \&quot;%s\&quot;&quot;, dname.c_str(), fname.c_str());
-				}
-			} else {
-				luaL_error(L, &quot;Path \&quot;%s\&quot; not found in mod archive&quot;, path.c_str());
-			}
-		} else {
-			luaL_error(L, &quot;Argument to ExtractModArchiveFile(s) not a string&quot;);
-		}
+	fstream fstr(path.c_str(), ios::out | ios::binary);
+	fstr.write((const char*) buffer, numBytes);
+	fstr.close();
+
+	if (!dname.empty()) {
+		logOutput.Print(&quot;Extracted file \&quot;%s\&quot; to directory \&quot;%s\&quot;&quot;,
+		                fname.c_str(), dname.c_str());
 	} else {
-		luaL_error(L, &quot;Incorrect number of arguments to ExtractModArchiveFile(s)&quot;);
+		logOutput.Print(&quot;Extracted file \&quot;%s\&quot;&quot;, fname.c_str());
 	}
 
-	lua_pushboolean(L, ret);
+	delete[] buffer;
+
+	lua_pushboolean(L, true);
+
 	return 1;
 }
 

Modified: trunk/rts/Lua/LuaUnsyncedCtrl.h
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCtrl.h	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaUnsyncedCtrl.h	2008-05-24 12:55:54 UTC (rev 5923)
@@ -62,6 +62,9 @@
 		static int SetUnitNoMinimap(lua_State* L);
 		static int SetUnitNoSelect(lua_State* L);
 
+		static int AddUnitIcon(lua_State* L);
+		static int FreeUnitIcon(lua_State* L);
+
 		static int ExtractModArchiveFile(lua_State* L);
 };
 

Modified: trunk/rts/Lua/LuaUnsyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedRead.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaUnsyncedRead.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -406,8 +406,8 @@
 
 		if (noIcons) {
 			const float sqDist = (unit-&gt;pos - camera-&gt;pos).SqLength();
-			const float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
-			const float realIconLength = iconLength * (iconDistMult * iconDistMult);
+			const float iconDistSqrMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistanceSqr();
+			const float realIconLength = iconLength * iconDistSqrMult;
 			if (sqDist &gt; realIconLength) {
 				continue;
 			}

Modified: trunk/rts/Lua/LuaWeaponDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaWeaponDefs.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Lua/LuaWeaponDefs.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -552,11 +552,11 @@
 	ADD_BOOL(&quot;avoidFeature&quot;,  wd.avoidFeature);
 	ADD_BOOL(&quot;avoidNeutral&quot;,  wd.avoidNeutral);
 
-	ADD_FLOAT(&quot;targetBorder&quot;, wd.targetBorder);
+	ADD_FLOAT(&quot;targetBorder&quot;,       wd.targetBorder);
 	ADD_FLOAT(&quot;cylinderTargetting&quot;, wd.cylinderTargetting);
-	ADD_FLOAT(&quot;minIntensity&quot;, wd.minIntensity);
-	ADD_FLOAT(&quot;heightBoostFactor&quot;, wd.heightBoostFactor);
-	ADD_FLOAT(&quot;proximityPriority&quot;, wd.proximityPriority);
+	ADD_FLOAT(&quot;minIntensity&quot;,       wd.minIntensity);
+	ADD_FLOAT(&quot;heightBoostFactor&quot;,  wd.heightBoostFactor);
+	ADD_FLOAT(&quot;proximityPriority&quot;,  wd.proximityPriority);
 
 //	CExplosionGenerator *explosionGenerator;
 

Added: trunk/rts/Rendering/Icon.h
===================================================================
--- trunk/rts/Rendering/Icon.h	                        (rev 0)
+++ trunk/rts/Rendering/Icon.h	2008-05-24 12:55:54 UTC (rev 5923)
@@ -0,0 +1,28 @@
+//
+//  Implemented in IconHandler.cpp
+//
+
+#ifndef ICON_H
+#define ICON_H
+
+
+class CIconData;
+
+
+class CIcon {
+	public:
+		CIcon();
+		CIcon(CIconData* data);
+		CIcon(const CIcon&amp; ic);
+		CIcon&amp; operator=(const CIcon&amp; ic);
+		~CIcon();
+
+		const CIconData* operator-&gt;()  const { return data; }
+		const CIconData* GetIconData() const { return data; }
+
+	private:
+		CIconData* data;
+};
+
+
+#endif // ICON_H

Modified: trunk/rts/Rendering/IconHandler.cpp
===================================================================
--- trunk/rts/Rendering/IconHandler.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Rendering/IconHandler.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -5,144 +5,336 @@
 #include &lt;assert.h&gt;
 #include &lt;locale&gt;
 #include &lt;cctype&gt;
+#include &lt;vector&gt;
+#include &lt;string&gt;
 #include &quot;GlobalStuff.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;IconHandler.h&quot;
-#include &quot;TdfParser.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
+using std::string;
 
 CIconHandler* iconHandler;
 
 
+/******************************************************************************/
+//
+//  CIconHandler
+//
+
 CIconHandler::CIconHandler()
 {
 	PrintLoadMsg(&quot;Parsing unit icons&quot;);
 
-	standardTextureGenerated = false;
+	defTexID = 0;
 
-	LoadTDFicons(&quot;usericons.tdf&quot;);
-	LoadTDFicons(&quot;gamedata/icontypes.tdf&quot;);
+	LoadIcons(&quot;gamedata/icontypes.lua&quot;);
 
-	// If the default icon doesn't exist we'll have to create one
-	// (as unitdef-&gt;iconType defaults to &quot;default&quot;).
-	if (icons.find(&quot;default&quot;) == icons.end()) {
-		icons[&quot;default&quot;] = SAFE_NEW CIcon(*GetStandardTexture(), 1, 1, false);
+	IconMap::iterator it = iconMap.find(&quot;default&quot;);
+	if (it != iconMap.end()) {
+		defIconData = it-&gt;second;
 	}
+	else {
+		defIconData = SAFE_NEW CIconData(&quot;default&quot;, GetDefaultTexture(),
+																		 1.0f, 1.0f, false, false);
+		defIconData-&gt;Ref();
+		iconMap[&quot;default&quot;] = defIconData;
+	}
+}
 
+
+
+CIconHandler::~CIconHandler()
+{
+	IconMap::iterator it;
+	for (it = iconMap.begin(); it != iconMap.end(); ++it) {
+		CIconData* iconData = it-&gt;second;
+		iconData-&gt;UnRef();
+	}
+	glDeleteTextures(1, &amp;defTexID);
 }
 
 
-bool CIconHandler::LoadTDFicons(const std::string&amp; filename)
+bool CIconHandler::AddIcon(const string&amp; iconName, const string&amp; textureName,
+                           float size, float distance, bool radAdj)
 {
+	unsigned int texID;
+
+	bool ownTexture = true;
+
 	try {
-		TdfParser tdfparser(filename);
-		std::vector&lt;std::string&gt; iconList = tdfparser.GetSectionList(&quot;icontypes&quot;);
 		CBitmap bitmap;
-
-		for (std::vector&lt;std::string&gt;::const_iterator it = iconList.begin(); it != iconList.end(); ++it) {
-			if (icons.find(*it) != icons.end()) {
-				continue; // first come, first served  (also avoids possible memory leaks)
-			}
-			//Parse the bitmap location, the size, and the unit radius adjustment.
-			float size=atof(tdfparser.SGetValueDef(&quot;1&quot;, &quot;icontypes\\&quot; + *it + &quot;\\size&quot;).c_str());
-			float distance=atof(tdfparser.SGetValueDef(&quot;1&quot;, &quot;icontypes\\&quot; + *it + &quot;\\distance&quot;).c_str());
-			bool radiusAdjust=!!atoi(tdfparser.SGetValueDef(&quot;0&quot;, &quot;icontypes\\&quot; + *it + &quot;\\radiusadjust&quot;).c_str());
-			// If we can't load the bitmap replace it with the default one.
-			std::string bitmapLocation=tdfparser.SGetValueDef(&quot;&quot;, &quot;icontypes\\&quot; + *it + &quot;\\bitmap&quot;);
-			unsigned int texture;
-			if(!bitmapLocation.empty () &amp;&amp; bitmap.Load(bitmapLocation)){
-				texture = bitmap.CreateTexture(true);
-				glBindTexture(GL_TEXTURE_2D, texture);
-				if (GLEW_EXT_texture_edge_clamp) {
-					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-				} else {
-					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-				}
+		if (!textureName.empty() &amp;&amp; bitmap.Load(textureName)) {
+			texID = bitmap.CreateTexture(true);
+			glBindTexture(GL_TEXTURE_2D, texID);
+			if (GLEW_EXT_texture_edge_clamp) {
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 			} else {
-				texture = *GetStandardTexture();
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 			}
-			icons[*it] = SAFE_NEW CIcon(texture,size,distance,radiusAdjust);
+		} else {
+			texID = GetDefaultTexture();
+			ownTexture = false;
 		}
 	}
-	catch (const TdfParser::parse_error&amp; e) {
-		// Show parse errors in the infolog.
-		logOutput.Print(&quot;%s:%d: %s&quot;, e.get_filename().c_str(), e.get_line(), e.what());
-	}
 	catch (const content_error&amp;) {
 		// Ignore non-existant file.
+		return false;
 	}
 
+	IconMap::iterator it = iconMap.find(iconName);
+	if (it != iconMap.end()) {
+		FreeIcon(iconName);
+	}
+
+	CIconData* iconData =
+		SAFE_NEW CIconData(iconName, texID,  size, distance, radAdj, ownTexture);
+	iconData-&gt;Ref();
+	iconMap[iconName] = iconData;
+
+	if (iconName == &quot;default&quot;) {
+		defIconData = iconData;
+	}
+
 	return true;
 }
 
 
-CIconHandler::~CIconHandler()
+bool CIconHandler::FreeIcon(const string&amp; iconName)
 {
-	std::map&lt;std::string, CIcon*&gt;::iterator it;
-	for (it = icons.begin(); it != icons.end(); ++it) {
-		delete it-&gt;second;
+	IconMap::iterator it = iconMap.find(iconName);
+	if (it == iconMap.end()) {
+		return false;
 	}
+
+	CIconData* iconData = it-&gt;second;
+	iconData-&gt;CopyData(defIconData);
+	iconData-&gt;UnRef();
+
+	iconMap.erase(iconName);
+
+	return true;
 }
 
 
-CIcon* CIconHandler::GetIcon(const std::string&amp; iconName)
+bool CIconHandler::LoadIcons(const string&amp; filename)
 {
-	std::map&lt;std::string, CIcon*&gt;::const_iterator it=icons.find(iconName);
-	if(it==icons.end()){
-		return icons[&quot;default&quot;];
-	} else {
-		return it-&gt;second;
+	LuaParser luaParser(filename, SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!luaParser.Execute()) {
+		logOutput.Print(&quot;%s: %s&quot;,
+		                filename.c_str(), luaParser.GetErrorLog().c_str());
 	}
+
+	const LuaTable iconTypes = luaParser.GetRoot();
+
+	std::vector&lt;string&gt; iconNames;
+	iconTypes.GetKeys(iconNames);
+
+	for (int i = 0; i &lt; iconNames.size(); i++) {
+		const string&amp; iconName = iconNames[i];
+		const LuaTable iconTable = iconTypes.SubTable(iconName);
+		const string texName = iconTable.GetString(&quot;bitmap&quot;,  &quot;&quot;);
+		const float size     = iconTable.GetFloat(&quot;size&quot;,     1.0f);
+		const float dist     = iconTable.GetFloat(&quot;distance&quot;, 1.0f);
+		const bool radiusAdjust = iconTable.GetBool(&quot;radiusAdjust&quot;, false);
+		AddIcon(iconName, texName, size, dist, radiusAdjust);
+	}
+
+	return true;
 }
 
 
-float CIconHandler::GetDistance(const std::string&amp; iconName)
+CIcon CIconHandler::GetIcon(const string&amp; iconName) const
 {
-	std::map&lt;std::string, CIcon*&gt;::const_iterator it=icons.find(iconName);
-	if(it==icons.end()){
-		return 1;
+	IconMap::const_iterator it = iconMap.find(iconName);
+	if (it == iconMap.end()) {
+		return CIcon(const_cast&lt;CIconData*&gt;(defIconData));
 	} else {
-		return it-&gt;second-&gt;distance;
+		return CIcon(it-&gt;second);
 	}
 }
 
 
-unsigned int* CIconHandler::GetStandardTexture()
+unsigned int CIconHandler::GetDefaultTexture()
 {
-	if(!standardTextureGenerated){
-		unsigned char si[128*128*4];
-		for(int y=0;y&lt;128;++y){
-			for(int x=0;x&lt;128;++x){
-				float r=sqrtf((y-64)*(y-64)+(x-64)*(x-64))/64.0f;
-				if(r&gt;1){
-					si[(y*128+x)*4+0]=0;
-					si[(y*128+x)*4+1]=0;
-					si[(y*128+x)*4+2]=0;
-					si[(y*128+x)*4+3]=0;
-				} else {
-					si[(y*128+x)*4+0]=(unsigned char)(255-r*r*r*255);
-					si[(y*128+x)*4+1]=(unsigned char)(255-r*r*r*255);
-					si[(y*128+x)*4+2]=(unsigned char)(255-r*r*r*255);
-					si[(y*128+x)*4+3]=255;
-				}
+	// FIXME: just use a PNG ?
+
+	if (defTexID != 0) {
+		return defTexID;
+	}
+
+	unsigned char si[128 * 128 * 4];
+	for (int y = 0; y &lt; 128; ++y) {
+		for (int x = 0; x &lt; 128; ++x) {
+			const int index = ((y * 128) + x) * 4;
+			const int dx = (x - 64);
+			const int dy = (y - 64);
+			const float r = sqrtf((dx * dx) + (dy * dy)) / 64.0f;
+			if (r &gt; 1.0f) {
+				si[index + 0] = 0;
+				si[index + 1] = 0;
+				si[index + 2] = 0;
+				si[index + 3] = 0;
+			} else {
+				const unsigned char val = (255 - (r * r * r * 255));
+				si[index + 0] = val;
+				si[index + 1] = val;
+				si[index + 2] = val;
+				si[index + 3] = 255;
 			}
 		}
-		CBitmap standardIcon(si,128,128);
-		standardTexture=standardIcon.CreateTexture(false);
-		standardTextureGenerated=true;
+	}
 
-		glBindTexture(GL_TEXTURE_2D, standardTexture);
-		if (GLEW_EXT_texture_edge_clamp) {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-		} else {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-		}
+	CBitmap bitmap(si, 128, 128);
+	defTexID = bitmap.CreateTexture(false);
+
+	glBindTexture(GL_TEXTURE_2D, defTexID);
+	if (GLEW_EXT_texture_edge_clamp) {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	} else {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 	}
-	return &standardTexture;
+
+	return defTexID;
 }
+
+
+/******************************************************************************/
+//
+//  CIcon
+//
+
+CIcon::CIcon()
+{
+	data = const_cast&lt;CIconData*&gt;(iconHandler-&gt;GetDefaultIconData());
+	data-&gt;Ref();
+}
+
+
+CIcon::CIcon(CIconData* d)
+{
+	data = d;
+	data-&gt;Ref();
+}
+
+
+CIcon::CIcon(const CIcon&amp; icon)
+{
+	data = icon.data;
+	data-&gt;Ref();
+}
+
+
+CIcon&amp; CIcon::operator=(const CIcon&amp; icon)
+{
+	if (data != icon.data) {
+		data-&gt;UnRef();
+		data = icon.data;
+		data-&gt;Ref();
+	}
+	return *this;
+}
+
+
+CIcon::~CIcon()
+{
+	data-&gt;UnRef();
+}
+
+
+/******************************************************************************/
+//
+//  CIconData
+//
+
+//CIconData::CIconData() FIXME
+//: ownTexture(true), refCount(0), texID(0)
+//{
+//}
+
+
+CIconData::CIconData(const std::string&amp; _name, unsigned int _texID,
+                     float _size, float _distance, bool radAdj, bool ownTex)
+: ownTexture(ownTex), refCount(0),
+  name(_name), texID(_texID),
+  size(_size), distance(_distance),
+  radiusAdjust(radAdj)
+{
+	distSqr = distance * distance;
+}
+
+
+CIconData::~CIconData()
+{
+	if (ownTexture) {
+		glDeleteTextures(1, &amp;texID);
+	}
+}
+
+
+void CIconData::Ref()
+{
+	refCount++;
+}
+
+
+void CIconData::UnRef()
+{
+	refCount--;
+	if (refCount &lt;= 0) {
+		delete this;
+	}
+}
+
+
+void CIconData::CopyData(const CIconData* iconData)
+{
+	name         = iconData-&gt;name;
+	texID        = iconData-&gt;texID;
+	size         = iconData-&gt;size;
+	distance     = iconData-&gt;distance;
+	distSqr      = iconData-&gt;distSqr;
+	radiusAdjust = iconData-&gt;radiusAdjust;
+	ownTexture   = false;
+}
+
+
+void CIconData::BindTexture() const
+{
+	glBindTexture(GL_TEXTURE_2D, texID);
+}
+
+
+void CIconData::Draw(float x0, float y0, float x1, float y1) const
+{
+	glBindTexture(GL_TEXTURE_2D, texID);
+	glBegin(GL_QUADS);
+	glTexCoord2f(0.0f, 0.0f); glVertex2f(x0, y0);
+	glTexCoord2f(1.0f, 0.0f); glVertex2f(x1, y0);
+	glTexCoord2f(1.0f, 1.0f); glVertex2f(x1, y1);
+	glTexCoord2f(0.0f, 1.0f); glVertex2f(x0, y1);
+	glEnd();
+}
+
+
+void CIconData::Draw(const float3&amp; botLeft, const float3&amp; botRight,
+                     const float3&amp; topLeft, const float3&amp; topRight) const
+{
+	glBindTexture(GL_TEXTURE_2D, texID);
+	glBegin(GL_QUADS);
+	glTexCoord2f(0.0f, 1.0f); glVertexf3(botLeft);
+	glTexCoord2f(1.0f, 1.0f); glVertexf3(botRight);
+	glTexCoord2f(1.0f, 0.0f); glVertexf3(topRight);
+	glTexCoord2f(0.0f, 0.0f); glVertexf3(topLeft);
+	glEnd();
+}
+
+
+/******************************************************************************/

Modified: trunk/rts/Rendering/IconHandler.h
===================================================================
--- trunk/rts/Rendering/IconHandler.h	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Rendering/IconHandler.h	2008-05-24 12:55:54 UTC (rev 5923)
@@ -1,43 +1,83 @@
 /* Author: Teake Nutma */
 
-#ifndef ICONHANDLER_H
-#define ICONHANDLER_H
+#ifndef ICON_HANDLER_H
+#define ICON_HANDLER_H
 
 #include &lt;map&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-class CIcon
-{
-public:
-	unsigned int texture;
-	float size;
-	float distance;
-	bool radiusAdjust;
-	CIcon(unsigned int tex, float siz, float dis, bool radius)
-	{
-		texture      = tex;
-		size         = siz;
-		distance     = dis;
-		radiusAdjust = radius;
-	};
+#include &quot;Icon.h&quot;
+#include &quot;float3.h&quot;
+
+
+class CIconData {
+	public:
+		CIconData(const std::string&amp; name, unsigned int texID,
+		          float size, float distance, bool radiusAdjust,
+		          bool ownTexture);
+		~CIconData();
+
+		void BindTexture() const;
+		void Draw(float x0, float y0, float x1, float y1) const;
+		void Draw(const float3&amp; botLeft, const float3&amp; botRight,
+		          const float3&amp; topLeft, const float3&amp; topRight) const;
+
+		inline const std::string&amp; GetName()         const { return name;         }
+		inline const float        GetSize()         const { return size;         }
+		inline const float        GetDistance()     const { return distance;     }
+		inline const float        GetDistanceSqr()  const { return distSqr;      }
+		inline const bool         GetRadiusAdjust() const { return radiusAdjust; }
+
+		void CopyData(const CIconData* iconData);
+
+		void Ref();
+		void UnRef();
+
+	private:
+		bool ownTexture;
+		int  refCount;
+
+		std::string name;
+		unsigned int texID;
+		float size;
+		float distance;
+		float distSqr;
+		bool  radiusAdjust;
 };
 
-class CIconHandler
-{
-public:
-	CIconHandler(void);
-	~CIconHandler(void);
-	CIcon* GetIcon(const std::string&amp; iconName);
-	float GetDistance(const std::string&amp; iconName);
-private:
-	bool LoadTDFicons(const std::string&amp; filename);
-	unsigned int* GetStandardTexture();
-	unsigned int standardTexture;
-	bool standardTextureGenerated;
-	std::map&lt;std::string, CIcon*&gt; icons;
+
+class CIconHandler {
+	public:
+		CIconHandler(void);
+		~CIconHandler(void);
+
+		bool AddIcon(const std::string&amp; iconName,
+								 const std::string&amp; textureName,
+								 float size, float distance,
+								 bool radiusAdjust);
+		bool FreeIcon(const std::string&amp; iconName);
+
+		CIcon GetIcon(const std::string&amp; iconName) const;
+		CIcon GetDefaultIcon() const {
+			return CIcon(const_cast&lt;CIconData*&gt;(defIconData));
+		}
+		const CIconData* GetDefaultIconData() const { return defIconData; }
+		
+	private:
+		bool LoadIcons(const std::string&amp; filename);
+		unsigned int GetDefaultTexture();
+
+	private:
+		unsigned int defTexID;
+		CIconData* defIconData;
+
+		typedef std::map&lt;std::string, CIconData*&gt; IconMap;
+		IconMap iconMap;
 };
 
+
 extern CIconHandler* iconHandler;
 
-#endif
+
+#endif // ICON_HANDLER_H

Modified: trunk/rts/Rendering/UnitModels/3DModelParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModelParser.h	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Rendering/UnitModels/3DModelParser.h	2008-05-24 12:55:54 UTC (rev 5923)
@@ -45,7 +45,6 @@
 	int textureType;		//0=3do, otherwise s3o
 
 	void DrawStatic();
-
 };
 
 

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -326,7 +326,7 @@
 				}
 
 				float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
-				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+				float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
 				float realIconLength = iconLength * (iconDistMult * iconDistMult);
 				if (sqDist&gt;realIconLength) {
 					drawIcon.push_back(unit);
@@ -342,7 +342,7 @@
 						DrawUnit(unit);
 					}
 
-					if ((sqDist &lt; (unitDrawDist * unitDrawDist * 500)) &amp;&amp; showHealthBars) {
+					if (showHealthBars &amp;&amp; (sqDist &lt; (unitDrawDist * unitDrawDist * 500))) {
 						drawStat.push_back(unit);
 					}
 				}
@@ -354,7 +354,7 @@
 					// it's a building we've had LOS on once,
 					// add it to the vector of cloaked units
 					float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
-					float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+					float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
 					float realIconLength = iconLength * (iconDistMult * iconDistMult);
 
 					if (sqDist &lt; realIconLength) {
@@ -595,7 +595,7 @@
 			float farLength = unit-&gt;sqRadius * (unitDrawDist * unitDrawDist);
 
 			if (sqDist &lt; farLength) {
-				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+				float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
 				float realIconLength = iconLength * (iconDistMult * iconDistMult);
 
 				if (sqDist &lt; realIconLength) {
@@ -656,19 +656,13 @@
 void CUnitDrawer::DrawIcon(CUnit * unit, bool asRadarBlip)
 {
 	// If the icon is to be drawn as a radar blip, we want to get the default icon.
-	std::string iconType;
-	if(asRadarBlip){
-		iconType=&quot;default&quot;;
+	const CIconData* iconData;
+	if (asRadarBlip) {
+		iconData = iconHandler-&gt;GetDefaultIconData();
 	} else {
-		iconType=unit-&gt;unitDef-&gt;iconType;
+		iconData = unit-&gt;unitDef-&gt;iconType.GetIconData();
 	}
 
-	// Fetch the icon information.
-	CIcon* icon=iconHandler-&gt;GetIcon(iconType);
-
-	unsigned char color[4];
-	color[3]=255;
-
 	// Calculate the icon size. It scales with:
 	//  * The square root of the camera distance.
 	//  * The mod defined 'iconSize' (which acts a multiplier).
@@ -677,25 +671,23 @@
 	if (gu-&gt;spectatingFullView) {
 		pos = unit-&gt;midPos;
 	} else {
-		pos = helper-&gt;GetUnitErrorPos(unit,gu-&gt;myAllyTeam);
+		pos = helper-&gt;GetUnitErrorPos(unit, gu-&gt;myAllyTeam);
 	}
-	float dist=sqrt((pos-camera-&gt;pos).Length());
-	float scale=0.4f*icon-&gt;size*dist;
-	if (icon-&gt;radiusAdjust &amp;&amp; !asRadarBlip) {
-		scale=scale*unit-&gt;radius/30; // I take the standard unit radius to be 30 ... call it an educated guess. (Teake Nutma)
+	float dist = sqrt((pos - camera-&gt;pos).Length());
+	float scale = 0.4f * iconData-&gt;GetSize() * dist;
+	if (iconData-&gt;GetRadiusAdjust() &amp;&amp; !asRadarBlip) {
+		// I take the standard unit radius to be 30
+		// ... call it an educated guess. (Teake Nutma)
+		scale *= (unit-&gt;radius / 30);
 	}
 
 	unit-&gt;iconRadius = scale; // store the icon size so that we don't have to calculate it again
 
 	// Is the unit selected? Then draw it white.
 	if (unit-&gt;commandAI-&gt;selected) {
-		color[0] = 255;
-		color[1] = 255;
-		color[2] = 255;
+		glColor3ub(255, 255, 255);
 	} else {
-		color[0] = gs-&gt;Team(unit-&gt;team)-&gt;color[0];
-		color[1] = gs-&gt;Team(unit-&gt;team)-&gt;color[1];
-		color[2] = gs-&gt;Team(unit-&gt;team)-&gt;color[2];
+		glColor3ubv(gs-&gt;Team(unit-&gt;team)-&gt;color);
 	}
 
 	// If the icon is partly under the ground, move it up.
@@ -704,15 +696,18 @@
 		pos.y = (h + scale);
 	}
 
+	// calculate the vertices
+	const float3 dy = camera-&gt;up    * scale;
+	const float3 dx = camera-&gt;right * scale;
+	const float3 vn = pos - dx;
+	const float3 vp = pos + dx;
+	const float3 vnn = vn - dy;
+	const float3 vpn = vp - dy;
+	const float3 vnp = vn + dy;
+	const float3 vpp = vp + dy;
+	
 	// Draw the icon.
-	glBindTexture(GL_TEXTURE_2D, icon-&gt;texture);
-	va = GetVertexArray();
-	va-&gt;Initialize();
-	va-&gt;AddVertexTC(pos + camera-&gt;up * scale + camera-&gt;right * scale, 1, 0, color);
-	va-&gt;AddVertexTC(pos - camera-&gt;up * scale + camera-&gt;right * scale, 1, 1, color);
-	va-&gt;AddVertexTC(pos - camera-&gt;up * scale - camera-&gt;right * scale, 0, 1, color);
-	va-&gt;AddVertexTC(pos + camera-&gt;up * scale - camera-&gt;right * scale, 0, 0, color);
-	va-&gt;DrawArrayTC(GL_QUADS);
+	iconData-&gt;Draw(vnn, vpn, vnp, vpp);
 }
 
 
@@ -1684,10 +1679,6 @@
 }
 
 
-
-
-
-
 inline void CUnitDrawer::DrawUnitDebug(CUnit* unit)
 {
 	// draw the collision volume
@@ -1749,6 +1740,7 @@
 	}
 }
 
+
 void CUnitDrawer::DrawUnitBeingBuilt(CUnit* unit)
 {
 	if (shadowHandler-&gt;inShadowPass) {
@@ -1821,7 +1813,6 @@
 }
 
 
-
 void CUnitDrawer::ApplyUnitTransformMatrix(CUnit* unit)
 {
 	CMatrix44f m;
@@ -1829,6 +1820,7 @@
 	glMultMatrixf(&amp;m[0]);
 }
 
+
 inline void CUnitDrawer::DrawUnitModel(CUnit* unit) {
 	if (unit-&gt;luaDraw &amp;&amp; luaRules &amp;&amp; luaRules-&gt;DrawUnit(unit-&gt;id)) {
 		return;
@@ -1841,6 +1833,7 @@
 	}
 }
 
+
 void CUnitDrawer::DrawUnitNow(CUnit* unit)
 {
 	glAlphaFunc(GL_GEQUAL, unit-&gt;alphaThreshold);
@@ -1858,6 +1851,7 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitWithLists(CUnit* unit, unsigned int preList, unsigned int postList)
 {
 	glPushMatrix();
@@ -1881,6 +1875,7 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitRaw(CUnit* unit)
 {
 	glPushMatrix();
@@ -1889,6 +1884,7 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitRawModel(CUnit* unit)
 {
 	if (unit-&gt;lodCount &lt;= 0) {
@@ -1898,6 +1894,7 @@
 	}
 }
 
+
 void CUnitDrawer::DrawUnitRawWithLists(CUnit* unit, unsigned int preList, unsigned int postList)
 {
 	glPushMatrix();
@@ -1916,6 +1913,7 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitStats(CUnit* unit)
 {
 	if ((gu-&gt;myAllyTeam != unit-&gt;allyteam) &amp;&amp;
@@ -2008,6 +2006,7 @@
 	DrawUnitNow(unit);
 }
 
+
 void CUnitDrawer::DrawFeatureS3O(CFeature* feature)
 {
 	glPushMatrix();

Modified: trunk/rts/Sim/ModInfo.cpp
===================================================================
--- trunk/rts/Sim/ModInfo.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Sim/ModInfo.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -89,21 +89,20 @@
 	const LuaTable sensors = root.SubTable(&quot;sensors&quot;);
 	/// LoS
 	const LuaTable los = sensors.SubTable(&quot;los&quot;);
-	losMipLevel = los.GetInt(&quot;losMipLevel&quot;, 1);
-	airMipLevel = los.GetInt(&quot;airMipLevel&quot;, 2);
-	
 	// losMipLevel is used as index to readmap-&gt;mipHeightmap,
 	// so the max value is CReadMap::numHeightMipMaps - 1
-	if (losMipLevel &lt; 0 || losMipLevel &gt;= 7)
+	losMipLevel = los.GetInt(&quot;losMipLevel&quot;, 1);
+	losMul = los.GetFloat(&quot;losMul&quot;, 1.0f);
+	if ((losMipLevel &lt; 0) || (losMipLevel &gt; 6)) {
 		throw content_error(&quot;Sensors\\Los\\LosMipLevel out of bounds. &quot;
-				&quot;The minimum value is 0. The maximum value is 6.&quot;);
-
+		                    &quot;The minimum value is 0. The maximum value is 6.&quot;);
+	}
 	// airLosMipLevel doesn't have such restrictions, it's just used in various
 	// bitshifts with signed integers
-	if (airMipLevel &lt; 0 || airMipLevel &gt; 30)
+	airMipLevel = los.GetInt(&quot;airMipLevel&quot;, 2);
+	if ((airMipLevel &lt; 0) || (airMipLevel &gt; 30)) {
 		throw content_error(&quot;Sensors\\Los\\AirLosMipLevel out of bounds. &quot;
-				&quot;The minimum value is 0. The maximum value is 30.&quot;);
-	
-	losMul = los.GetFloat(&quot;losMul&quot;, 1.0f);
+		                    &quot;The minimum value is 0. The maximum value is 30.&quot;);
+	}
 	airLosMul = los.GetFloat(&quot;airLosMul&quot;, 1.0f);
 }

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -578,13 +578,10 @@
 {
 	const unsigned short currStatus = losStatus[at];
 
-	const bool inLos = loshandler-&gt;InLos(this, at);
-	const bool inRadar = inLos || radarhandler-&gt;InRadar(this, at);
-
 	unsigned short newStatus = currStatus;
 	unsigned short mask = ~(currStatus &gt;&gt; 8);
 
-	if (inLos) {
+	if (loshandler-&gt;InLos(this, at)) {
 		if (!beingBuilt) {
 			newStatus |= (mask &amp; (LOS_INLOS   | LOS_INRADAR |
 			                      LOS_PREVLOS | LOS_CONTRADAR));
@@ -595,7 +592,7 @@
 			newStatus &amp;= ~(mask &amp; (LOS_PREVLOS | LOS_CONTRADAR));
 		}
 	}
-	else if (inRadar) {
+	else if (radarhandler-&gt;InRadar(this, at)) {
 		newStatus |=  (mask &amp; LOS_INRADAR);
 		newStatus &amp;= ~(mask &amp; LOS_INLOS);
 	}

Modified: trunk/rts/Sim/Units/UnitDef.h
===================================================================
--- trunk/rts/Sim/Units/UnitDef.h	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Sim/Units/UnitDef.h	2008-05-24 12:55:54 UTC (rev 5923)
@@ -8,6 +8,7 @@
 
 #include &quot;creg/creg.h&quot;
 #include &quot;float3.h&quot;
+#include &quot;Rendering/Icon.h&quot;
 
 struct MoveData;
 struct WeaponDef;
@@ -229,7 +230,7 @@
 	std::string TEDClassString;	//these might be changed later for something better
 	std::string categoryString;
 
-	std::string iconType;
+	mutable CIcon iconType;
 
 	bool canSelfD;
 	int selfDCountdown;

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -18,6 +18,7 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
@@ -138,7 +139,7 @@
 	numUnitDefs = (id - 1);
 
 	CleanBuildOptions();
-	FindCommanders();
+	FindStartUnits();
 	ProcessDecoys();
 	AssignTechLevels();
 }
@@ -219,35 +220,35 @@
 }
 
 
-void CUnitDefHandler::FindCommanders()
+void CUnitDefHandler::FindStartUnits()
 {
-	LuaParser p(&quot;gamedata/sidedata.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
-	if (!p.Execute() || !p.IsValid())
-		logOutput.Print(p.GetErrorLog());
+	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+	                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!luaParser.Execute()) {
+		logOutput.Print(luaParser.GetErrorLog());
+	}
 
-	const LuaTable sideTable = p.GetRoot();
-	// get the commander UnitDef IDs
-	commanderIDs.clear();
+	const LuaTable sideData = luaParser.GetRoot();
+	// get the startUnit UnitDef IDs
+	startUnitIDs.clear();
 	std::vector&lt;std::string&gt; sides;
-	sideTable.GetKeys(sides);
-	for (unsigned int i = 0; i &lt; sides.size(); i++){
-		const std::string&amp; section = sides[i];
-		if ((section.find(&quot;side&quot;) == 0) &amp;&amp;
-		    (section.find_first_not_of(&quot;0123456789&quot;, 4) == std::string::npos)) {
-			string commUnit = sideTable.SubTable(section).GetString(&quot;commander&quot;, &quot;&quot;);
-			StringToLowerInPlace(commUnit);
-			if (!commUnit.empty()) {
-				std::map&lt;std::string, int&gt;::iterator it = unitID.find(commUnit);
-				if (it != unitID.end()) {
-					commanderIDs.insert(it-&gt;second);
-				}
+	for (int i = 1; true; i++) {
+		const LuaTable side = sideData.SubTable(i);
+		if (!side.IsValid()) {
+			break;
+		}
+		std::string startUnit = side.GetString(&quot;startUnit&quot;, &quot;&quot;);
+		StringToLowerInPlace(startUnit);
+		if (!startUnit.empty()) {
+			std::map&lt;std::string, int&gt;::iterator it = unitID.find(startUnit);
+			if (it != unitID.end()) {
+				startUnitIDs.insert(it-&gt;second);
 			}
 		}
 	}
 }
 
 
-
 void CUnitDefHandler::ParseTAUnit(const LuaTable&amp; udTable, const string&amp; unitName, int id)
 {
 	UnitDef&amp; ud = unitDefs[id];
@@ -519,7 +520,8 @@
 	ud.noChaseCategory = CCategoryHandler::Instance()-&gt;GetCategories(udTable.GetString(&quot;noChaseCategory&quot;, &quot;&quot;));
 //	logOutput.Print(&quot;Unit %s has cat %i&quot;,ud.humanName.c_str(),ud.category);
 
-	ud.iconType = udTable.GetString(&quot;iconType&quot;, &quot;default&quot;);
+	const string iconName = udTable.GetString(&quot;iconType&quot;, &quot;default&quot;);
+	ud.iconType = iconHandler-&gt;GetIcon(iconName);
 
 	ud.shieldWeaponDef    = NULL;
 	ud.stockpileWeaponDef = NULL;
@@ -1022,7 +1024,7 @@
 void CUnitDefHandler::AssignTechLevels()
 {
 	set&lt;int&gt;::iterator it;
-	for (it = commanderIDs.begin(); it != commanderIDs.end(); ++it) {
+	for (it = startUnitIDs.begin(); it != startUnitIDs.end(); ++it) {
 		AssignTechLevel(unitDefs[*it], 0);
 	}
 }

Modified: trunk/rts/Sim/Units/UnitDefHandler.h
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.h	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/rts/Sim/Units/UnitDefHandler.h	2008-05-24 12:55:54 UTC (rev 5923)
@@ -28,7 +28,7 @@
 	int numUnitDefs;
 	std::map&lt;std::string, int&gt; unitID;
 	std::map&lt;int, std::set&lt;int&gt; &gt; decoyMap;
-	std::set&lt;int&gt; commanderIDs;
+	std::set&lt;int&gt; startUnitIDs;
 
 	CUnitDefHandler(void);
 	~CUnitDefHandler(void);
@@ -51,7 +51,7 @@
 
 	void CleanBuildOptions();
 
-	void FindCommanders();
+	void FindStartUnits();
 
 	void AssignTechLevel(UnitDef&amp; ud, int level);
 

Modified: trunk/tools/unitsync/unitsync.cpp
===================================================================
--- trunk/tools/unitsync/unitsync.cpp	2008-05-24 12:46:25 UTC (rev 5922)
+++ trunk/tools/unitsync/unitsync.cpp	2008-05-24 12:55:54 UTC (rev 5923)
@@ -989,24 +989,29 @@
 
 	logOutput.Print(&quot;get side count: &quot;);
 
-	try {
-		p.LoadFile(&quot;gamedata/sidedata.tdf&quot;);
-	} catch (const std::exception&amp; e) {
-		logOutput.Print(&quot;failed: %s\n&quot;, e.what());
+	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+	                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!luaParser.Execute()) {
+		logOutput.Print(&quot;failed: %s\n&quot;, luaParser.GetErrorLog().c_str());
 		return 0;
 	}
 
-	for(int b=0;;++b){					//loop over all sides
-		char sideText[50];
-		sprintf(sideText,&quot;side%i&quot;,b);
-		if(p.SectionExist(sideText)){
-			SideData sd;
-			sd.name = p.SGetValueDef(&quot;arm&quot;,string(sideText)+&quot;\\name&quot;);
-			sideData.push_back(sd);
-		} else break;
+	const LuaTable sideDataTbl = luaParser.GetRoot();
+	if (!sideDataTbl.IsValid()) {
+		logOutput.Print(&quot;failed: missing 'sideData' table\n&quot;);
+		return 0;
 	}
 
-	logOutput.Print(&quot;%d sides\n&quot;, sideData.size());
+	for (int i = 1; true; i++) {
+		const LuaTable sideTbl = sideDataTbl.SubTable(i);
+		if (!sideTbl.IsValid()) {
+			break;
+		}
+		SideData sd;
+		sd.name = sideTbl.GetString(&quot;name&quot;, &quot;unknown&quot;);
+		sideData.push_back(sd);
+	}
+
 	return sideData.size();
 }
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000702.html">[Taspring-linux-commit] r5922 - in branches/springie/refactoring: .	Springie Springie/autohost/commands
</A></li>
	<LI>Next message: <A HREF="000704.html">[Taspring-linux-commit] r5924 - in trunk/rts: Game Rendering	Rendering/UnitModels
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#703">[ date ]</a>
              <a href="thread.html#703">[ thread ]</a>
              <a href="subject.html#703">[ subject ]</a>
              <a href="author.html#703">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
