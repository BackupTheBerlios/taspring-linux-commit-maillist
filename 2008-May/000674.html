<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5894 - in branches/gml/rts: . ExternalAI	ExternalAI/GlobalAICInterface Game Game/Camera Game/Server	Game/StartScripts Game/UI Lua Map Map/SM3 Map/SM3/terrain	Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim/Features Sim/Misc	Sim/MoveTypes Sim/MoveTypes/MoveMath Sim/Objects Sim/Path	Sim/Projectiles Sim/Projectiles/Unsynced	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System	System/FileSystem System/Net System/Platform/Linux	System/Platform/Win System/Script build/scons build/vstudio8 lib/gml
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5894%20-%20in%20branches/gml/rts%3A%20.%20ExternalAI%0A%09ExternalAI/GlobalAICInterface%20Game%20Game/Camera%20Game/Server%0A%09Game/StartScripts%20Game/UI%20Lua%20Map%20Map/SM3%20Map/SM3/terrain%0A%09Map/SMF%20Rendering%20Rendering/Env%20Rendering/GL%0A%09Rendering/Textures%20Rendering/UnitModels%20Sim/Features%20Sim/Misc%0A%09Sim/MoveTypes%20Sim/MoveTypes/MoveMath%20Sim/Objects%20Sim/Path%0A%09Sim/Projectiles%20Sim/Projectiles/Unsynced%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%20Sim/Units/COB%0A%09Sim/Units/CommandAI%20Sim/Units/UnitTypes%20Sim/Weapons%20System%0A%09System/FileSystem%20System/Net%20System/Platform/Linux%0A%09System/Platform/Win%20System/Script%20build/scons%20build/vstudio8%20lib/gml&In-Reply-To=%3C20080516011713.C9D7A464F%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000673.html">
   <LINK REL="Next"  HREF="000675.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5894 - in branches/gml/rts: . ExternalAI	ExternalAI/GlobalAICInterface Game Game/Camera Game/Server	Game/StartScripts Game/UI Lua Map Map/SM3 Map/SM3/terrain	Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim/Features Sim/Misc	Sim/MoveTypes Sim/MoveTypes/MoveMath Sim/Objects Sim/Path	Sim/Projectiles Sim/Projectiles/Unsynced	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System	System/FileSystem System/Net System/Platform/Linux	System/Platform/Win System/Script build/scons build/vstudio8 lib/gml</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5894%20-%20in%20branches/gml/rts%3A%20.%20ExternalAI%0A%09ExternalAI/GlobalAICInterface%20Game%20Game/Camera%20Game/Server%0A%09Game/StartScripts%20Game/UI%20Lua%20Map%20Map/SM3%20Map/SM3/terrain%0A%09Map/SMF%20Rendering%20Rendering/Env%20Rendering/GL%0A%09Rendering/Textures%20Rendering/UnitModels%20Sim/Features%20Sim/Misc%0A%09Sim/MoveTypes%20Sim/MoveTypes/MoveMath%20Sim/Objects%20Sim/Path%0A%09Sim/Projectiles%20Sim/Projectiles/Unsynced%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%20Sim/Units/COB%0A%09Sim/Units/CommandAI%20Sim/Units/UnitTypes%20Sim/Weapons%20System%0A%09System/FileSystem%20System/Net%20System/Platform/Linux%0A%09System/Platform/Win%20System/Script%20build/scons%20build/vstudio8%20lib/gml&In-Reply-To=%3C20080516011713.C9D7A464F%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5894 - in branches/gml/rts: . ExternalAI	ExternalAI/GlobalAICInterface Game Game/Camera Game/Server	Game/StartScripts Game/UI Lua Map Map/SM3 Map/SM3/terrain	Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim/Features Sim/Misc	Sim/MoveTypes Sim/MoveTypes/MoveMath Sim/Objects Sim/Path	Sim/Projectiles Sim/Projectiles/Unsynced	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System	System/FileSystem System/Net System/Platform/Linux	System/Platform/Win System/Script build/scons build/vstudio8 lib/gml">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri May 16 03:17:13 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000673.html">[Taspring-linux-commit] r5893 - trunk/rts/Lua
</A></li>
        <LI>Next message: <A HREF="000675.html">[Taspring-linux-commit] r5895 - in trunk/rts: Game System	System/Net System/Net/Test
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#674">[ date ]</a>
              <a href="thread.html#674">[ thread ]</a>
              <a href="subject.html#674">[ subject ]</a>
              <a href="author.html#674">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zerver
Date: 2008-05-16 03:17:06 +0200 (Fri, 16 May 2008)
New Revision: 5894

Added:
   branches/gml/rts/Game/UI/HwMouseCursor.cpp
   branches/gml/rts/Game/UI/HwMouseCursor.h
   branches/gml/rts/Map/HeightLinePalette.cpp
   branches/gml/rts/Map/HeightLinePalette.h
   branches/gml/rts/Map/MapInfo.cpp
   branches/gml/rts/Map/MapInfo.h
   branches/gml/rts/Rendering/Env/BumpWater.cpp
   branches/gml/rts/Rendering/Env/BumpWater.h
   branches/gml/rts/Sim/Misc/CollisionHandler.cpp
   branches/gml/rts/Sim/Misc/CollisionHandler.h
   branches/gml/rts/Sim/Misc/CollisionVolume.h
   branches/gml/rts/Sim/Misc/GroundBlockingObjectMap.cpp
   branches/gml/rts/Sim/Misc/GroundBlockingObjectMap.h
   branches/gml/rts/System/FileSystem/FileFilter.cpp
   branches/gml/rts/System/FileSystem/FileFilter.h
Removed:
   branches/gml/rts/Game/Server/ServerLog.cpp
   branches/gml/rts/Game/Server/ServerLog.h
   branches/gml/rts/Game/Server/ServerLogHandler.cpp
   branches/gml/rts/Game/Server/ServerLogHandler.h
   branches/gml/rts/Sim/Misc/CollisionVolume.cpp
   branches/gml/rts/Sim/Misc/CollisionVolume.h
Modified:
   branches/gml/rts/ExternalAI/AICallback.cpp
   branches/gml/rts/ExternalAI/AICallback.h
   branches/gml/rts/ExternalAI/AICheats.cpp
   branches/gml/rts/ExternalAI/GlobalAI.cpp
   branches/gml/rts/ExternalAI/GlobalAI.h
   branches/gml/rts/ExternalAI/GlobalAICInterface/AbicProxy.h
   branches/gml/rts/ExternalAI/GlobalAIHandler.cpp
   branches/gml/rts/ExternalAI/Group.h
   branches/gml/rts/ExternalAI/GroupHandler.cpp
   branches/gml/rts/ExternalAI/GroupHandler.h
   branches/gml/rts/ExternalAI/IAICallback.h
   branches/gml/rts/ExternalAI/IGlobalAI.h
   branches/gml/rts/ExternalAI/aibase.h
   branches/gml/rts/Game/Action.cpp
   branches/gml/rts/Game/Action.h
   branches/gml/rts/Game/Camera.cpp
   branches/gml/rts/Game/Camera/FPSController.cpp
   branches/gml/rts/Game/Camera/OverheadController.cpp
   branches/gml/rts/Game/Camera/OverviewController.cpp
   branches/gml/rts/Game/Camera/SmoothController.cpp
   branches/gml/rts/Game/Camera/SmoothController.h
   branches/gml/rts/Game/ChatMessage.cpp
   branches/gml/rts/Game/ChatMessage.h
   branches/gml/rts/Game/CommandMessage.cpp
   branches/gml/rts/Game/CommandMessage.h
   branches/gml/rts/Game/Console.cpp
   branches/gml/rts/Game/Console.h
   branches/gml/rts/Game/ConsoleHistory.cpp
   branches/gml/rts/Game/ConsoleHistory.h
   branches/gml/rts/Game/Game.cpp
   branches/gml/rts/Game/Game.h
   branches/gml/rts/Game/GameData.cpp
   branches/gml/rts/Game/GameData.h
   branches/gml/rts/Game/GameHelper.cpp
   branches/gml/rts/Game/GameServer.cpp
   branches/gml/rts/Game/GameServer.h
   branches/gml/rts/Game/GameSetup.cpp
   branches/gml/rts/Game/GameSetupData.h
   branches/gml/rts/Game/PlayerRoster.cpp
   branches/gml/rts/Game/PreGame.cpp
   branches/gml/rts/Game/PreGame.h
   branches/gml/rts/Game/SelectedUnits.cpp
   branches/gml/rts/Game/SelectedUnits.h
   branches/gml/rts/Game/SelectedUnitsAI.cpp
   branches/gml/rts/Game/Server/MsgStrings.h
   branches/gml/rts/Game/StartScripts/AirScript.cpp
   branches/gml/rts/Game/StartScripts/CommanderScript.cpp
   branches/gml/rts/Game/StartScripts/CommanderScript2.cpp
   branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp
   branches/gml/rts/Game/StartScripts/ScriptHandler.cpp
   branches/gml/rts/Game/StartScripts/ScriptHandler.h
   branches/gml/rts/Game/StartScripts/SpawnScript.cpp
   branches/gml/rts/Game/StartScripts/SpawnScript.h
   branches/gml/rts/Game/Team.cpp
   branches/gml/rts/Game/Team.h
   branches/gml/rts/Game/UI/CursorIcons.cpp
   branches/gml/rts/Game/UI/EndGameBox.cpp
   branches/gml/rts/Game/UI/GameInfo.cpp
   branches/gml/rts/Game/UI/GuiHandler.cpp
   branches/gml/rts/Game/UI/GuiHandler.h
   branches/gml/rts/Game/UI/KeyAutoBinder.h
   branches/gml/rts/Game/UI/KeyBindings.h
   branches/gml/rts/Game/UI/KeyCodes.cpp
   branches/gml/rts/Game/UI/KeyCodes.h
   branches/gml/rts/Game/UI/KeySet.cpp
   branches/gml/rts/Game/UI/KeySet.h
   branches/gml/rts/Game/UI/LuaUI.cpp
   branches/gml/rts/Game/UI/LuaUI.h
   branches/gml/rts/Game/UI/MiniMap.cpp
   branches/gml/rts/Game/UI/MiniMap.h
   branches/gml/rts/Game/UI/MouseCursor.cpp
   branches/gml/rts/Game/UI/MouseCursor.h
   branches/gml/rts/Game/UI/MouseHandler.cpp
   branches/gml/rts/Game/UI/MouseHandler.h
   branches/gml/rts/Game/UI/ProfileDrawer.cpp
   branches/gml/rts/Game/UI/ProfileDrawer.h
   branches/gml/rts/Game/UI/QuitBox.cpp
   branches/gml/rts/Game/UI/ResourceBar.cpp
   branches/gml/rts/Game/UI/SelectionKeyHandler.cpp
   branches/gml/rts/Game/UI/SelectionKeyHandler.h
   branches/gml/rts/Game/UI/ShareBox.cpp
   branches/gml/rts/Game/UI/StartPosSelecter.cpp
   branches/gml/rts/Game/UI/TooltipConsole.cpp
   branches/gml/rts/Game/WaitCommandsAI.cpp
   branches/gml/rts/Game/WaitCommandsAI.h
   branches/gml/rts/Game/WordCompletion.cpp
   branches/gml/rts/Game/WordCompletion.h
   branches/gml/rts/Lua/LuaCallInCheck.cpp
   branches/gml/rts/Lua/LuaCallInCheck.h
   branches/gml/rts/Lua/LuaCallInHandler.cpp
   branches/gml/rts/Lua/LuaCallInHandler.h
   branches/gml/rts/Lua/LuaConstGame.cpp
   branches/gml/rts/Lua/LuaFeatureDefs.cpp
   branches/gml/rts/Lua/LuaHandle.cpp
   branches/gml/rts/Lua/LuaHandle.h
   branches/gml/rts/Lua/LuaHandleSynced.cpp
   branches/gml/rts/Lua/LuaMaterial.cpp
   branches/gml/rts/Lua/LuaOpenGL.cpp
   branches/gml/rts/Lua/LuaParser.cpp
   branches/gml/rts/Lua/LuaRules.cpp
   branches/gml/rts/Lua/LuaSyncedCtrl.cpp
   branches/gml/rts/Lua/LuaSyncedCtrl.h
   branches/gml/rts/Lua/LuaSyncedRead.cpp
   branches/gml/rts/Lua/LuaUnitDefs.cpp
   branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp
   branches/gml/rts/Lua/LuaUnsyncedCtrl.h
   branches/gml/rts/Lua/LuaUtils.cpp
   branches/gml/rts/Lua/LuaUtils.h
   branches/gml/rts/Lua/LuaWeaponDefs.cpp
   branches/gml/rts/Map/BaseGroundDrawer.cpp
   branches/gml/rts/Map/BaseGroundDrawer.h
   branches/gml/rts/Map/BasicMapDamage.cpp
   branches/gml/rts/Map/Ground.h
   branches/gml/rts/Map/HeightMapTexture.cpp
   branches/gml/rts/Map/HeightMapTexture.h
   branches/gml/rts/Map/MapDamage.cpp
   branches/gml/rts/Map/ReadMap.cpp
   branches/gml/rts/Map/ReadMap.h
   branches/gml/rts/Map/SM3/Sm3GroundDrawer.cpp
   branches/gml/rts/Map/SM3/Sm3Map.cpp
   branches/gml/rts/Map/SM3/Sm3Map.h
   branches/gml/rts/Map/SM3/terrain/Lightcalc.cpp
   branches/gml/rts/Map/SM3/terrain/Terrain.cpp
   branches/gml/rts/Map/SM3/terrain/Terrain.h
   branches/gml/rts/Map/SM3/terrain/TerrainTexture.cpp
   branches/gml/rts/Map/SM3/terrain/TerrainTexture.h
   branches/gml/rts/Map/SM3/terrain/Textures.cpp
   branches/gml/rts/Map/SM3/terrain/Textures.h
   branches/gml/rts/Map/SMF/BFGroundDrawer.cpp
   branches/gml/rts/Map/SMF/BFGroundTextures.cpp
   branches/gml/rts/Map/SMF/BFGroundTextures.h
   branches/gml/rts/Map/SMF/SmfReadMap.cpp
   branches/gml/rts/Map/SMF/SmfReadMap.h
   branches/gml/rts/Rendering/Env/AdvSky.cpp
   branches/gml/rts/Rendering/Env/AdvTreeDrawer.cpp
   branches/gml/rts/Rendering/Env/AdvTreeGenerator.cpp
   branches/gml/rts/Rendering/Env/AdvWater.cpp
   branches/gml/rts/Rendering/Env/BaseSky.cpp
   branches/gml/rts/Rendering/Env/BaseSky.h
   branches/gml/rts/Rendering/Env/BaseWater.cpp
   branches/gml/rts/Rendering/Env/BasicSky.cpp
   branches/gml/rts/Rendering/Env/BasicTreeDrawer.cpp
   branches/gml/rts/Rendering/Env/BasicWater.cpp
   branches/gml/rts/Rendering/Env/DynWater.cpp
   branches/gml/rts/Rendering/Env/GrassDrawer.cpp
   branches/gml/rts/Rendering/Env/SkyBox.cpp
   branches/gml/rts/Rendering/FartextureHandler.cpp
   branches/gml/rts/Rendering/GL/VertexArray.cpp
   branches/gml/rts/Rendering/GL/VertexArray.h
   branches/gml/rts/Rendering/GL/myGL.cpp
   branches/gml/rts/Rendering/GL/myGL.h
   branches/gml/rts/Rendering/GroundDecalHandler.cpp
   branches/gml/rts/Rendering/InMapDraw.cpp
   branches/gml/rts/Rendering/ShadowHandler.cpp
   branches/gml/rts/Rendering/Textures/Bitmap.cpp
   branches/gml/rts/Rendering/Textures/NamedTextures.cpp
   branches/gml/rts/Rendering/Textures/TextureAtlas.cpp
   branches/gml/rts/Rendering/Textures/TextureHandler.cpp
   branches/gml/rts/Rendering/UnitModels/3DModelParser.cpp
   branches/gml/rts/Rendering/UnitModels/3DModelParser.h
   branches/gml/rts/Rendering/UnitModels/3DOParser.h
   branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp
   branches/gml/rts/Rendering/UnitModels/s3oParser.cpp
   branches/gml/rts/Rendering/UnitModels/s3oParser.h
   branches/gml/rts/Rendering/glFont.cpp
   branches/gml/rts/Sim/Features/Feature.cpp
   branches/gml/rts/Sim/Features/Feature.h
   branches/gml/rts/Sim/Features/FeatureDef.h
   branches/gml/rts/Sim/Features/FeatureHandler.cpp
   branches/gml/rts/Sim/Features/FeatureHandler.h
   branches/gml/rts/Sim/Features/FeatureSet.cpp
   branches/gml/rts/Sim/Features/FeatureSet.h
   branches/gml/rts/Sim/Misc/LosHandler.h
   branches/gml/rts/Sim/Misc/QuadField.cpp
   branches/gml/rts/Sim/Misc/RadarHandler.cpp
   branches/gml/rts/Sim/Misc/RadarHandler.h
   branches/gml/rts/Sim/Misc/Wind.cpp
   branches/gml/rts/Sim/MoveTypes/AAirMoveType.cpp
   branches/gml/rts/Sim/MoveTypes/AAirMoveType.h
   branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp
   branches/gml/rts/Sim/MoveTypes/GroundMoveType.cpp
   branches/gml/rts/Sim/MoveTypes/GroundMoveType.h
   branches/gml/rts/Sim/MoveTypes/MoveInfo.cpp
   branches/gml/rts/Sim/MoveTypes/MoveMath/HoverMoveMath.cpp
   branches/gml/rts/Sim/MoveTypes/MoveMath/MoveMath.cpp
   branches/gml/rts/Sim/MoveTypes/ScriptMoveType.cpp
   branches/gml/rts/Sim/MoveTypes/ScriptMoveType.h
   branches/gml/rts/Sim/MoveTypes/TAAirMoveType.cpp
   branches/gml/rts/Sim/Objects/SolidObject.cpp
   branches/gml/rts/Sim/Objects/SolidObject.h
   branches/gml/rts/Sim/Objects/WorldObject.cpp
   branches/gml/rts/Sim/Objects/WorldObject.h
   branches/gml/rts/Sim/Path/PathEstimator.cpp
   branches/gml/rts/Sim/Path/PathEstimator.h
   branches/gml/rts/Sim/Path/PathFinder.cpp
   branches/gml/rts/Sim/Path/PathFinder.h
   branches/gml/rts/Sim/Path/PathManager.cpp
   branches/gml/rts/Sim/Path/PathManager.h
   branches/gml/rts/Sim/Projectiles/FlareProjectile.cpp
   branches/gml/rts/Sim/Projectiles/PieceProjectile.cpp
   branches/gml/rts/Sim/Projectiles/PieceProjectile.h
   branches/gml/rts/Sim/Projectiles/Projectile.cpp
   branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp
   branches/gml/rts/Sim/Projectiles/Unsynced/DirtProjectile.cpp
   branches/gml/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp
   branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp
   branches/gml/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp
   branches/gml/rts/Sim/Projectiles/Unsynced/WreckProjectile.cpp
   branches/gml/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp
   branches/gml/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.cpp
   branches/gml/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
   branches/gml/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
   branches/gml/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp
   branches/gml/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
   branches/gml/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h
   branches/gml/rts/Sim/Units/COB/CobEngine.cpp
   branches/gml/rts/Sim/Units/COB/CobEngine.h
   branches/gml/rts/Sim/Units/COB/CobFile.cpp
   branches/gml/rts/Sim/Units/COB/CobFile.h
   branches/gml/rts/Sim/Units/COB/CobInstance.cpp
   branches/gml/rts/Sim/Units/COB/CobInstance.h
   branches/gml/rts/Sim/Units/COB/CobThread.cpp
   branches/gml/rts/Sim/Units/COB/CobThread.h
   branches/gml/rts/Sim/Units/CommandAI/AirCAI.cpp
   branches/gml/rts/Sim/Units/CommandAI/BuilderCAI.cpp
   branches/gml/rts/Sim/Units/CommandAI/Command.h
   branches/gml/rts/Sim/Units/CommandAI/CommandAI.cpp
   branches/gml/rts/Sim/Units/CommandAI/CommandQueue.h
   branches/gml/rts/Sim/Units/CommandAI/FactoryCAI.h
   branches/gml/rts/Sim/Units/CommandAI/MobileCAI.cpp
   branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp
   branches/gml/rts/Sim/Units/Unit.cpp
   branches/gml/rts/Sim/Units/Unit.h
   branches/gml/rts/Sim/Units/UnitDef.h
   branches/gml/rts/Sim/Units/UnitDefHandler.cpp
   branches/gml/rts/Sim/Units/UnitHandler.cpp
   branches/gml/rts/Sim/Units/UnitHandler.h
   branches/gml/rts/Sim/Units/UnitImage.h
   branches/gml/rts/Sim/Units/UnitLoader.cpp
   branches/gml/rts/Sim/Units/UnitLoader.h
   branches/gml/rts/Sim/Units/UnitTracker.cpp
   branches/gml/rts/Sim/Units/UnitTracker.h
   branches/gml/rts/Sim/Units/UnitTypes/Builder.cpp
   branches/gml/rts/Sim/Units/UnitTypes/Builder.h
   branches/gml/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp
   branches/gml/rts/Sim/Units/UnitTypes/Factory.cpp
   branches/gml/rts/Sim/Units/UnitTypes/Factory.h
   branches/gml/rts/Sim/Units/UnitTypes/TransportUnit.cpp
   branches/gml/rts/Sim/Weapons/BeamLaser.cpp
   branches/gml/rts/Sim/Weapons/Cannon.cpp
   branches/gml/rts/Sim/Weapons/LightingCannon.cpp
   branches/gml/rts/Sim/Weapons/PlasmaRepulser.cpp
   branches/gml/rts/Sim/Weapons/Weapon.cpp
   branches/gml/rts/Sim/Weapons/WeaponDefHandler.h
   branches/gml/rts/Sim/Weapons/bombdropper.cpp
   branches/gml/rts/System/AutohostInterface.h
   branches/gml/rts/System/BaseNetProtocol.cpp
   branches/gml/rts/System/BaseNetProtocol.h
   branches/gml/rts/System/FastMath.h
   branches/gml/rts/System/FileSystem/Archive7Zip.cpp
   branches/gml/rts/System/FileSystem/Archive7Zip.h
   branches/gml/rts/System/FileSystem/ArchiveBase.cpp
   branches/gml/rts/System/FileSystem/ArchiveBase.h
   branches/gml/rts/System/FileSystem/ArchiveBuffered.cpp
   branches/gml/rts/System/FileSystem/ArchiveBuffered.h
   branches/gml/rts/System/FileSystem/ArchiveDir.cpp
   branches/gml/rts/System/FileSystem/ArchiveDir.h
   branches/gml/rts/System/FileSystem/ArchiveHPI.cpp
   branches/gml/rts/System/FileSystem/ArchiveHPI.h
   branches/gml/rts/System/FileSystem/ArchiveScanner.cpp
   branches/gml/rts/System/FileSystem/ArchiveScanner.h
   branches/gml/rts/System/FileSystem/ArchiveZip.cpp
   branches/gml/rts/System/FileSystem/ArchiveZip.h
   branches/gml/rts/System/FileSystem/CRC.cpp
   branches/gml/rts/System/FileSystem/CRC.h
   branches/gml/rts/System/FileSystem/VFSHandler.cpp
   branches/gml/rts/System/FileSystem/VFSHandler.h
   branches/gml/rts/System/GlobalStuff.cpp
   branches/gml/rts/System/GlobalStuff.h
   branches/gml/rts/System/LoadSaveHandler.cpp
   branches/gml/rts/System/Matrix44f.cpp
   branches/gml/rts/System/Matrix44f.h
   branches/gml/rts/System/MouseInput.cpp
   branches/gml/rts/System/MouseInput.h
   branches/gml/rts/System/Net/Connection.h
   branches/gml/rts/System/Net/LocalConnection.cpp
   branches/gml/rts/System/Net/LocalConnection.h
   branches/gml/rts/System/Net/Net.cpp
   branches/gml/rts/System/Net/Net.h
   branches/gml/rts/System/Net/PackPacket.cpp
   branches/gml/rts/System/Net/PackPacket.h
   branches/gml/rts/System/Net/Socket.cpp
   branches/gml/rts/System/Net/Socket.h
   branches/gml/rts/System/Net/UDPConnectedSocket.cpp
   branches/gml/rts/System/Net/UDPConnectedSocket.h
   branches/gml/rts/System/Net/UDPConnection.cpp
   branches/gml/rts/System/Net/UDPConnection.h
   branches/gml/rts/System/Net/UDPSocket.cpp
   branches/gml/rts/System/Net/UDPSocket.h
   branches/gml/rts/System/Net/UnpackPacket.cpp
   branches/gml/rts/System/Net/UnpackPacket.h
   branches/gml/rts/System/Object.cpp
   branches/gml/rts/System/Object.h
   branches/gml/rts/System/Platform/Linux/OpenALSound.cpp
   branches/gml/rts/System/Platform/Linux/OpenALSound.h
   branches/gml/rts/System/Platform/Win/DxSound.cpp
   branches/gml/rts/System/Platform/Win/DxSound.h
   branches/gml/rts/System/SFloat3.h
   branches/gml/rts/System/Script/LuaBinder.cpp
   branches/gml/rts/System/Script/LuaBinder.h
   branches/gml/rts/System/Script/LuaFunctions.cpp
   branches/gml/rts/System/Script/LuaFunctions.h
   branches/gml/rts/System/SpringApp.cpp
   branches/gml/rts/System/SpringApp.h
   branches/gml/rts/System/TdfParser.cpp
   branches/gml/rts/System/TdfParser.h
   branches/gml/rts/System/UnsyncedRNG.cpp
   branches/gml/rts/System/UnsyncedRNG.h
   branches/gml/rts/build/scons/config.py
   branches/gml/rts/build/scons/rts.py
   branches/gml/rts/build/vstudio8/rts.vcproj
   branches/gml/rts/lib/gml/gml.cpp
   branches/gml/rts/lib/gml/gml.h
   branches/gml/rts/lib/gml/gmlcls.h
   branches/gml/rts/lib/gml/gmldef.h
   branches/gml/rts/lib/gml/gmlfun.h
   branches/gml/rts/lib/gml/gmlsrv.h
   branches/gml/rts/spring.exe.manifest
Log:


Modified: branches/gml/rts/ExternalAI/AICallback.cpp
===================================================================
--- branches/gml/rts/ExternalAI/AICallback.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/AICallback.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,6 +12,8 @@
 #include &quot;Game/UI/MiniMap.h&quot;
 #include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MetalMap.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;NetProtocol.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
@@ -23,10 +25,10 @@
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Misc/DamageArrayHandler.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
-#include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
 #include &quot;Sim/Path/PathManager.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
@@ -65,19 +67,19 @@
 
 void CAICallback::SendStartPos(bool ready, float3 startPos)
 {
-	if(startPos.z&lt;gameSetup-&gt;startRectTop[GetMyAllyTeam()]*gs-&gt;mapy*8)
-		startPos.z=gameSetup-&gt;startRectTop[GetMyAllyTeam()]*gs-&gt;mapy*8;
+	if (startPos.z &lt; gameSetup-&gt;startRectTop[GetMyAllyTeam()] * gs-&gt;mapy * 8)
+		startPos.z = gameSetup-&gt;startRectTop[GetMyAllyTeam()] * gs-&gt;mapy * 8;
 
-	if(startPos.z&gt;gameSetup-&gt;startRectBottom[GetMyAllyTeam()]*gs-&gt;mapy*8)
-		startPos.z=gameSetup-&gt;startRectBottom[GetMyAllyTeam()]*gs-&gt;mapy*8;
+	if (startPos.z &gt; gameSetup-&gt;startRectBottom[GetMyAllyTeam()] * gs-&gt;mapy * 8)
+		startPos.z = gameSetup-&gt;startRectBottom[GetMyAllyTeam()] * gs-&gt;mapy * 8;
 
-	if(startPos.x&lt;gameSetup-&gt;startRectLeft[GetMyAllyTeam()]*gs-&gt;mapx*8)
-		startPos.x=gameSetup-&gt;startRectLeft[GetMyAllyTeam()]*gs-&gt;mapx*8;
+	if (startPos.x &lt; gameSetup-&gt;startRectLeft[GetMyAllyTeam()] * gs-&gt;mapx * 8)
+		startPos.x = gameSetup-&gt;startRectLeft[GetMyAllyTeam()] * gs-&gt;mapx * 8;
 
-	if(startPos.x&gt;gameSetup-&gt;startRectRight[GetMyAllyTeam()]*gs-&gt;mapx*8)
-		startPos.x=gameSetup-&gt;startRectRight[GetMyAllyTeam()]*gs-&gt;mapx*8;
+	if (startPos.x &gt; gameSetup-&gt;startRectRight[GetMyAllyTeam()] * gs-&gt;mapx * 8)
+		startPos.x = gameSetup-&gt;startRectRight[GetMyAllyTeam()] * gs-&gt;mapx * 8;
 
-	unsigned char readyness = ready ? 1 : 0;
+	unsigned char readyness = ready? 1: 0;
 	net-&gt;SendStartPos(gu-&gt;myPlayerNum, team, readyness, startPos.x, startPos.y, startPos.z);
 }
 
@@ -99,6 +101,84 @@
 	minimap-&gt;AddNotification(pos,color,alpha);
 }
 
+
+
+bool CAICallback::SendResources(float mAmount, float eAmount, int receivingTeam)
+{
+	typedef unsigned char ubyte;
+	bool ret = false;
+
+	if (team != receivingTeam) {
+		if (receivingTeam &gt;= 0 &amp;&amp; receivingTeam &lt; (MAX_TEAMS - 1)) {
+			if (gs-&gt;Team(receivingTeam) &amp;&amp; gs-&gt;Team(team)) {
+				if (!gs-&gt;Team(receivingTeam)-&gt;isDead &amp;&amp; !gs-&gt;Team(team)-&gt;isDead) {
+					// note: we can't use the existing SendShare()
+					// since its handler in CGame uses myPlayerNum
+					// (NETMSG_SHARE param) to determine which team
+					// the resources came from, which is not always
+					// our AI team
+					ret = true;
+
+					// cap the amounts to how much M and E we have
+					mAmount = std::max(0.0f, std::min(mAmount, GetMetal()));
+					eAmount = std::max(0.0f, std::min(eAmount, GetEnergy()));
+					std::vector&lt;short&gt; empty;
+
+					net-&gt;SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeam), mAmount, eAmount, empty);
+				}
+			}
+		}
+	}
+
+	return ret;
+}
+
+int CAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam)
+{
+	typedef unsigned char ubyte;
+	std::vector&lt;short&gt; sentUnitIDs;
+
+	if (team != receivingTeam) {
+		if (receivingTeam &gt;= 0 &amp;&amp; receivingTeam &lt; (MAX_TEAMS - 1)) {
+			if (gs-&gt;Team(receivingTeam) &amp;&amp; gs-&gt;Team(team)) {
+				if (!gs-&gt;Team(receivingTeam)-&gt;isDead &amp;&amp; !gs-&gt;Team(team)-&gt;isDead) {
+					// we must iterate over the ID's to check if
+					// all of them really belong to the AI's team
+					for (std::vector&lt;int&gt;::const_iterator it = unitIDs.begin(); it != unitIDs.end(); it++ ) {
+						const int unitID = *it;
+
+						if (unitID &gt; 0 &amp;&amp; unitID &lt; MAX_UNITS) {
+							CUnit* unit = uh-&gt;units[unitID];
+
+							if (unit &amp;&amp; unit-&gt;team == team) {
+								// we own this unit, save it (note: safe cast
+								// since MAX_UNITS currently fits in a short)
+								sentUnitIDs.push_back(short(unitID));
+
+								// stop whatever this unit is doing
+								Command c;
+								c.id = CMD_STOP;
+								GiveOrder(unitID, &amp;c);
+							}
+						}
+					}
+
+					if (sentUnitIDs.size() &gt; 0) {
+						// we can't use SendShare() here either, since
+						// AI's don't have a notion of &quot;selected units&quot;
+						net-&gt;SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeam), 0.0f, 0.0f, sentUnitIDs);
+					}
+				}
+			}
+		}
+	}
+
+	// return how many units were actually put up for transfer
+	return (sentUnitIDs.size());
+}
+
+
+
 bool CAICallback::PosInCamera(float3 pos, float radius)
 {
 	return camera-&gt;InView(pos,radius);
@@ -181,7 +261,7 @@
 	}
 }
 
-bool CAICallback::AddUnitToGroup(int unitid,int groupid)
+bool CAICallback::AddUnitToGroup(int unitid, int groupid)
 {
 	if (CHECK_UNITID(unitid) &amp;&amp; CHECK_GROUPID(groupid)) {
 		CUnit* u=uh-&gt;units[unitid];
@@ -532,14 +612,16 @@
 }
 
 bool CAICallback::IsUnitParalyzed(int unitid){
-	verify ();
+	verify();
+
 	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
-		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
+		CUnit* unit = uh-&gt;units[unitid];
+		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			return unit-&gt;stunned;
 		}
 	}
-	return 0;
+
+	return false;
 }
 
 bool CAICallback::IsUnitNeutral(int unitid) {
@@ -549,14 +631,12 @@
 		CUnit* unit = uh-&gt;units[unitid];
 
 		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
-			if ((gs-&gt;useLuaGaia &amp;&amp; unit-&gt;team == gs-&gt;gaiaTeamID) || (unit-&gt;team == MAX_TEAMS - 1))
+			if (unit-&gt;IsNeutral())
 				return true;
-			if (unit-&gt;neutral)
-				return true;
 		}
 	}
 
-	return 0;
+	return false;
 }
 
 int CAICallback::InitPath(float3 start,float3 end,int pathType)
@@ -586,10 +666,10 @@
 int CAICallback::GetEnemyUnits(int* units)
 {
 	verify();
-	list&lt;CUnit*&gt;::iterator ui;
+	std::list&lt;CUnit*&gt;::iterator ui;
 	int a = 0;
 
-	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
 		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
@@ -605,10 +685,10 @@
 int CAICallback::GetEnemyUnitsInRadarAndLos(int* units)
 {
 	verify();
-	list&lt;CUnit*&gt;::iterator ui;
+	std::list&lt;CUnit*&gt;::iterator ui;
 	int a = 0;
 
-	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
 		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INLOS | LOS_INRADAR))) {
@@ -648,7 +728,7 @@
 	verify();
 	int a = 0;
 
-	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
 		if (gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team))) {
@@ -692,7 +772,7 @@
 	verify();
 	int a = 0;
 
-	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
 		// IsUnitNeutral does the LOS check
@@ -750,32 +830,32 @@
 
 float CAICallback::GetMaxMetal()
 {
-	return readmap-&gt;maxMetal;
+	return mapInfo-&gt;map.maxMetal;
 }
 
 float CAICallback::GetExtractorRadius()
 {
-	return readmap-&gt;extractorRadius;
+	return mapInfo-&gt;map.extractorRadius;
 }
 
 float CAICallback::GetMinWind()
 {
-	return wind.GetMinWind();
+	return mapInfo-&gt;atmosphere.minWind;
 }
 
 float CAICallback::GetMaxWind()
 {
-	return wind.GetMaxWind();
+	return mapInfo-&gt;atmosphere.maxWind;
 }
 
 float CAICallback::GetTidalStrength()
 {
-	return readmap-&gt;tidalStrength;
+	return mapInfo-&gt;map.tidalStrength;
 }
 
 float CAICallback::GetGravity()
 {
-	return gs-&gt;gravity;
+	return mapInfo-&gt;map.gravity;
 }
 
 /*const unsigned char* CAICallback::GetSupplyMap()
@@ -977,9 +1057,9 @@
 			bool good=true;
 			int xsize=bi.GetXSize();
 			int ysize=bi.GetYSize();
-			for(int z2=max(0,zs-ysize/2-minDist);z2&lt;min(gs-&gt;mapy,zs+(ysize+1)/2+minDist);++z2){
-				for(int x2=max(0,xs-xsize/2-minDist);x2&lt;min(gs-&gt;mapx,xs+(xsize+1)/2+minDist);++x2){
-					CSolidObject* so=readmap-&gt;groundBlockingObjectMap[z2*gs-&gt;mapx+x2];
+			for(int z2=std::max(0,zs-ysize/2-minDist);z2&lt;std::min(gs-&gt;mapy,zs+(ysize+1)/2+minDist);++z2){
+				for(int x2=std::max(0,xs-xsize/2-minDist);x2&lt;std::min(gs-&gt;mapx,xs+(xsize+1)/2+minDist);++x2){
+					CSolidObject* so = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(z2 * gs-&gt;mapx + x2);
 					if(so &amp;&amp; so-&gt;immobile &amp;&amp; !dynamic_cast&lt;CFeature*&gt;(so)){
 						good=false;
 						break;
@@ -987,9 +1067,9 @@
 				}
 			}
 			//Checking factories near - factory can open yard for building
-			if (good) for(int z2=max(0,zs-ysize/2-minDist-2);z2&lt;min(gs-&gt;mapy,zs+(ysize+1)/2+minDist+2);++z2){
-				for(int x2=max(0,xs-xsize/2-minDist-2);x2&lt;min(gs-&gt;mapx,xs+(xsize+1)/2+minDist+2);++x2){
-					CSolidObject* so=readmap-&gt;groundBlockingObjectMap[z2*gs-&gt;mapx+x2];
+			if (good) for(int z2=std::max(0,zs-ysize/2-minDist-2);z2&lt;std::min(gs-&gt;mapy,zs+(ysize+1)/2+minDist+2);++z2){
+				for(int x2=std::max(0,xs-xsize/2-minDist-2);x2&lt;std::min(gs-&gt;mapx,xs+(xsize+1)/2+minDist+2);++x2){
+					CSolidObject* so = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(z2 * gs-&gt;mapx + x2);
 					if(so &amp;&amp; so-&gt;immobile &amp;&amp; dynamic_cast&lt;CFactory*&gt;(so) &amp;&amp; ((CFactory*)so)-&gt;opening){
 						good=false;
 						break;
@@ -1415,11 +1495,14 @@
 // Additions to the interface by Alik
 int CAICallback::GetSelectedUnits(int *units)
 {
-	verify ();
-	int a=0;
+	verify();
+	int a = 0;
+
+	// check if the allyteam of the player running
+	// the AI lib matches the AI's actual allyteam
 	if (gu-&gt;myAllyTeam == gs-&gt;AllyTeam(team)) {
-		for(CUnitSet::iterator ui=selectedUnits.selectedUnits.begin();ui!=selectedUnits.selectedUnits.end();++ui)
-			units[a++]=(*ui)-&gt;id;
+		for (CUnitSet::iterator ui = selectedUnits.selectedUnits.begin(); ui != selectedUnits.selectedUnits.end(); ++ui)
+			units[a++] = (*ui)-&gt;id;
 	}
 	return a;
 }
@@ -1444,7 +1527,7 @@
 
 	for (int i=0;i&lt;inMapDrawer-&gt;numQuads;i++){
 		if(!inMapDrawer-&gt;drawQuads[i].points.empty()){
-			for(list&lt;CInMapDraw::MapPoint&gt;::iterator mp=inMapDrawer-&gt;drawQuads[i].points.begin();mp!=inMapDrawer-&gt;drawQuads[i].points.end();++mp){
+			for(std::list&lt;CInMapDraw::MapPoint&gt;::iterator mp=inMapDrawer-&gt;drawQuads[i].points.begin();mp!=inMapDrawer-&gt;drawQuads[i].points.end();++mp){
 				if(mp-&gt;color==gs-&gt;Team(team)-&gt;color) { //Maybe add so that markers of your ally team would be also found?
 					pm[a].pos=mp-&gt;pos;
 					pm[a].color=mp-&gt;color;
@@ -1468,7 +1551,7 @@
 
 	for (int i=0;i&lt;inMapDrawer-&gt;numQuads;i++){
 		if(!inMapDrawer-&gt;drawQuads[i].points.empty()){
-			for(list&lt;CInMapDraw::MapLine&gt;::iterator ml=inMapDrawer-&gt;drawQuads[i].lines.begin();ml!=inMapDrawer-&gt;drawQuads[i].lines.end();++ml){
+			for(std::list&lt;CInMapDraw::MapLine&gt;::iterator ml=inMapDrawer-&gt;drawQuads[i].lines.begin();ml!=inMapDrawer-&gt;drawQuads[i].lines.end();++ml){
 				if(ml-&gt;color==gs-&gt;Team(team)-&gt;color){ //Maybe add so that markers of your ally team would be also found?
 					lm[a].pos=ml-&gt;pos;
 					lm[a].color=ml-&gt;color;

Modified: branches/gml/rts/ExternalAI/AICallback.h
===================================================================
--- branches/gml/rts/ExternalAI/AICallback.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/AICallback.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -23,6 +23,10 @@
 	void SendTextMsg(const char* text, int zone);
 	void SetLastMsgPos(float3 pos);
 	void AddNotification(float3 pos, float3 color, float alpha);
+
+	bool SendResources(float mAmount, float eAmount, int receivingTeam);
+	int SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam);
+
 	bool PosInCamera(float3 pos, float radius);
 
 	int GetCurrentFrame();

Modified: branches/gml/rts/ExternalAI/AICheats.cpp
===================================================================
--- branches/gml/rts/ExternalAI/AICheats.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/AICheats.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -294,13 +294,16 @@
 	return false;
 }
 
-bool CAICheats::IsUnitParalyzed(int unitid){
-	if (!CHECK_UNITID(unitid)) return false;
+bool CAICheats::IsUnitParalyzed(int unitid) {
+	if (!CHECK_UNITID(unitid))
+		return false;
+
 	CUnit* unit = uh-&gt;units[unitid];
 	if (unit) {
 		return unit-&gt;stunned;
 	}
-	return 0;
+
+	return false;
 }
 
 
@@ -310,13 +313,10 @@
 
 	CUnit* unit = uh-&gt;units[unitid];
 	if (unit) {
-		if ((gs-&gt;useLuaGaia &amp;&amp; unit-&gt;team == gs-&gt;gaiaTeamID) || (unit-&gt;team == MAX_TEAMS - 1))
-			return true;
-		if (unit-&gt;neutral)
-			return true;
+		return (unit-&gt;IsNeutral());
 	}
 
-	return 0;
+	return false;
 }
 
 

Modified: branches/gml/rts/ExternalAI/GlobalAI.cpp
===================================================================
--- branches/gml/rts/ExternalAI/GlobalAI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/GlobalAI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -15,99 +15,42 @@
 
 #include &lt;sstream&gt;
 
-CR_BIND_DERIVED(CGlobalAI,CObject,(0,NULL))
-
+CR_BIND_DERIVED(CGlobalAI, CObject, (0, NULL))
 CR_REG_METADATA(CGlobalAI, (
-				CR_MEMBER(team),
-				CR_MEMBER(cheatevents),
-				CR_MEMBER(dllName),
-//				CR_MEMBER(gh),
-				CR_SERIALIZER(Serialize),
-				CR_POSTLOAD(PostLoad)
-				));
+	CR_MEMBER(team),
+	CR_MEMBER(cheatevents),
+	CR_MEMBER(libName),
+	CR_MEMBER(IsCInterface),
+	CR_MEMBER(IsLoadSupported),
+	CR_SERIALIZER(Serialize),
+	CR_POSTLOAD(PostLoad)
+));
 
 void AIException(const char *what);
 
-#define HANDLE_EXCEPTION  \
-	catch (const std::exception&amp; e) {	\
-		if (globalAI-&gt;CatchException ()) {		\
-			AIException(e.what());		\
-			throw;						\
-		} else throw;					\
-	}									\
+#define HANDLE_EXCEPTION					\
+	catch (const std::exception&amp; e) {		\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(e.what());			\
+			throw;							\
+		} else throw;						\
+	}										\
 	catch (const char *s) {	\
-		if (globalAI-&gt;CatchException ()) {		\
-			AIException(s);				\
-			throw;						\
-		} else throw;					\
-	}									\
-	catch (...) {						\
-		if (globalAI-&gt;CatchException ()) {		\
-			AIException(0);				\
-			throw;						\
-		}else throw;					\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(s);					\
+			throw;							\
+		} else throw;						\
+	}										\
+	catch (...) {							\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(0);					\
+			throw;							\
+		} else throw;						\
 	}
 
-CGlobalAI::CGlobalAI(int team, const char* dll): team(team), cheatevents(false),dllName(dll?dll:&quot;&quot;)
+CGlobalAI::CGlobalAI(int team, const char* botLibName): team(team), cheatevents(false), libName(botLibName? botLibName: &quot;&quot;)
 {
-	ai = 0;
-	if (!dll) return;
-	if (!filesystem.GetFilesize(dll)) {
-		handleerror(NULL, dll, &quot;Could not find AI lib&quot;, MBF_OK | MBF_EXCL);
-		return;
-	}
-
-	lib = SharedLib::Instantiate(dll);
-	_IsCInterface = (ISCINTERFACE) lib -&gt; FindAddress(&quot;IsCInterface&quot;);
-
-	// check if IsCInterface function exported and return value true
-	if ( _IsCInterface != 0 &amp;&amp; _IsCInterface() == 1) {
-		// presents C interface
-		logOutput &lt;&lt; dll &lt;&lt;  &quot; has C interface\n&quot;;
-		IsCInterface = true;
-
-		// keep as AbicProxy, so InitAI works ok
-		AbicProxy* ai = SAFE_NEW AbicProxy;
-		this-&gt;ai = ai;
-
-//		gh = SAFE_NEW CGroupHandler(team);
-		callback = SAFE_NEW CGlobalAICallback(this);
-		try {
-			ai-&gt;InitAI(dll, callback, team);
-		} HANDLE_EXCEPTION;
-	} else {
-		// presents C++ interface
-		logOutput &lt;&lt; dll &lt;&lt;  &quot; has C++ interface\n&quot;;
-		IsCInterface = false;
-
-		GetGlobalAiVersion = (GETGLOBALAIVERSION) lib-&gt;FindAddress(&quot;GetGlobalAiVersion&quot;);
-
-		if (GetGlobalAiVersion == 0) {
-			handleerror(NULL, dll, &quot;Incorrect Global AI dll&quot;, MBF_OK|MBF_EXCL);
-			return;
-		}
-
-		int i = GetGlobalAiVersion();
-
-		if (i != GLOBAL_AI_INTERFACE_VERSION) {
-			std::ostringstream tmp;
-			tmp &lt;&lt; &quot;Incorrect Global AI dll version &quot; &lt;&lt; i &lt;&lt; &quot;, expected &quot;
-					&lt;&lt; GLOBAL_AI_INTERFACE_VERSION;
-			handleerror(NULL, dll, tmp.str().c_str(), MBF_OK | MBF_EXCL);
-			return;
-		}
-
-		GetNewAI = (GETNEWAI) lib-&gt;FindAddress(&quot;GetNewAI&quot;);
-		ReleaseAI = (RELEASEAI) lib-&gt;FindAddress(&quot;ReleaseAI&quot;);
-
-		ai = GetNewAI();
-//		gh = SAFE_NEW CGroupHandler(team);
-		callback = SAFE_NEW CGlobalAICallback(this);
-		try {
-			ai-&gt;InitAI(callback, team);
-		} HANDLE_EXCEPTION;
-
-	}
+	LoadAILib(team, botLibName, false);
 }
 
 void CGlobalAI::PreDestroy()
@@ -120,99 +63,91 @@
 	if (ai) {
 		if (!IsCInterface) {
 			try {
-				ReleaseAI(ai);
+				_ReleaseAIFunc(ai);
 			} HANDLE_EXCEPTION;
 		}
 
 		delete lib;
 		delete callback;
-//		delete gh;
 	}
 }
 
-void CGlobalAI::Serialize(creg::ISerializer *s)
+void CGlobalAI::Serialize(creg::ISerializer* s)
 {
-
 }
 
-void CGlobalAI::Load(std::istream *s)
+
+
+void CGlobalAI::Load(std::istream* s)
 {
 	try {
-		ai-&gt;Load(callback,s);
+		ai-&gt;Load(callback, s);
 	} HANDLE_EXCEPTION;
 }
 
-void CGlobalAI::Save(std::ostream *s)
+void CGlobalAI::Save(std::ostream* s)
 {
 	try {
 		ai-&gt;Save(s);
 	} HANDLE_EXCEPTION;
 }
 
+
+
 void CGlobalAI::PostLoad()
 {
-	if (!filesystem.GetFilesize(dllName.c_str())) {
-		handleerror(NULL, dllName.c_str(), &quot;Could not find AI lib&quot;, MBF_OK | MBF_EXCL);
+	LoadAILib(team, libName.c_str(), true);
+}
+
+
+
+void CGlobalAI::LoadAILib(int team, const char* botLibName, bool postLoad)
+{
+	ai = 0;
+
+	if (!botLibName) {
+		// no AI for this team
 		return;
 	}
-	typedef bool (* ISLOADSUPPORTED)();
-	ISLOADSUPPORTED _IsLoadSupported;
 
-	lib = SharedLib::Instantiate(dllName.c_str());
-	_IsCInterface = (ISCINTERFACE) lib -&gt; FindAddress(&quot;IsCInterface&quot;);
-	_IsLoadSupported = (ISLOADSUPPORTED) lib -&gt; FindAddress(&quot;IsLoadSupported&quot;);
-	bool IsLoadSupported = _IsLoadSupported &amp;&amp; _IsLoadSupported();
+	if (!filesystem.GetFilesize(botLibName)) {
+		char msg[512];
+		SNPRINTF(msg, 511, &quot;Could not find GlobalAI library \&quot;%s\&quot;&quot;, botLibName);
+		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+		return;
+	}
 
-	// check if IsCInterface function exported and return value true
-	if ( _IsCInterface != 0 &amp;&amp; _IsCInterface() == 1) {
-		// presents C interface
-		logOutput &lt;&lt; dllName.c_str() &lt;&lt;  &quot; has C interface\n&quot;;
-		IsCInterface = true;
+	bool isJavaAI = (strstr(botLibName, &quot;.jar&quot;) == (botLibName + strlen(botLibName) - 4));
 
-		// keep as AbicProxy, so InitAI works ok
-		AbicProxy* ai = SAFE_NEW AbicProxy;
-		this-&gt;ai = ai;
-
-		callback = SAFE_NEW CGlobalAICallback(this);
-		if (!IsLoadSupported) {
-			try {
-				ai-&gt;InitAI(dllName.c_str(), callback, team);
-			} HANDLE_EXCEPTION;
-		}
+	if (isJavaAI) {
+		// Java AI, need to load the JAI proxy first
+		LoadJavaProxyAI();
 	} else {
-		// presents C++ interface
-		logOutput &lt;&lt; dllName.c_str() &lt;&lt;  &quot; has C++ interface\n&quot;;
-		IsCInterface = false;
+		lib = SharedLib::Instantiate(botLibName);
+	}
 
-		GetGlobalAiVersion = (GETGLOBALAIVERSION) lib-&gt;FindAddress(&quot;GetGlobalAiVersion&quot;);
+	// the JAI proxy is C++ anyway
+	_IsCInterfaceFunc = (isJavaAI)? 0: (ISCINTERFACE) lib-&gt;FindAddress(&quot;IsCInterface&quot;);
+	_IsLoadSupportedFunc = (ISLOADSUPPORTED) lib-&gt;FindAddress(&quot;IsLoadSupported&quot;);
 
-		if (GetGlobalAiVersion == 0) {
-			handleerror(NULL, dllName.c_str(), &quot;Incorrect Global AI dll&quot;, MBF_OK|MBF_EXCL);
-			return;
-		}
+	IsCInterface = (_IsCInterfaceFunc != 0 &amp;&amp; _IsCInterfaceFunc() == 1);
+	IsLoadSupported = (_IsLoadSupportedFunc != 0 &amp;&amp; _IsLoadSupportedFunc());
 
-		int i = GetGlobalAiVersion();
+	if (IsCInterface) {
+		LoadABICAI(team, botLibName, postLoad, IsLoadSupported);
+	} else {
+		LoadCPPAI(team, botLibName, postLoad, IsLoadSupported, isJavaAI);
+	}
 
-		if (i != GLOBAL_AI_INTERFACE_VERSION) {
-			handleerror(NULL, dllName.c_str(), &quot;Incorrect Global AI dll version&quot;, MBF_OK | MBF_EXCL);
-			return;
-		}
 
-		GetNewAI = (GETNEWAI) lib-&gt;FindAddress(&quot;GetNewAI&quot;);
-		ReleaseAI = (RELEASEAI) lib-&gt;FindAddress(&quot;ReleaseAI&quot;);
+	if (postLoad &amp;&amp; !IsLoadSupported) {
+		// fallback code to help the AI if it
+		// doesn't implement load/save support
+		for (int a = 0; a &lt; MAX_UNITS; a++) {
+			if (!uh-&gt;units[a])
+				continue;
 
-		ai = GetNewAI();
-		callback = SAFE_NEW CGlobalAICallback(this);
-		if (!IsLoadSupported) {
-			try {
-				ai-&gt;InitAI(callback, team);
-			} HANDLE_EXCEPTION;
-		}
-	}
-	if (!IsLoadSupported) {
-		for (int a = 0; a &lt; MAX_UNITS; a++) {
-			if (!uh-&gt;units[a]) continue;
-			if (uh-&gt;units[a]-&gt;team==team) {
+			if (uh-&gt;units[a]-&gt;team == team) {
 				try {
 					ai-&gt;UnitCreated(a);
 				} HANDLE_EXCEPTION;
@@ -221,10 +156,10 @@
 						ai-&gt;UnitFinished(a);
 					} HANDLE_EXCEPTION;
 			} else {
-				if ((uh-&gt;units[a]-&gt;allyteam==gs-&gt;AllyTeam(team))||gs-&gt;Ally(gs-&gt;AllyTeam(team),uh-&gt;units[a]-&gt;allyteam)) {
-
+				if ((uh-&gt;units[a]-&gt;allyteam == gs-&gt;AllyTeam(team)) || gs-&gt;Ally(gs-&gt;AllyTeam(team), uh-&gt;units[a]-&gt;allyteam)) {
+					/* do nothing */
 				} else {
-					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INRADAR|LOS_INLOS)) {
+					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INRADAR | LOS_INLOS)) {
 						try {
 							ai-&gt;EnemyEnterRadar(a);
 						} HANDLE_EXCEPTION;
@@ -240,9 +175,115 @@
 	}
 }
 
+
+
+void CGlobalAI::LoadABICAI(int team, const char* botLibName, bool postLoad, bool loadSupported)
+{
+	logOutput &lt;&lt; botLibName &lt;&lt; &quot; has a C interface (ABIC)\n&quot;;
+
+	// keep as AbicProxy, so InitAI works ok
+	AbicProxy* ai = SAFE_NEW AbicProxy;
+	this-&gt;ai = ai;
+
+	callback = SAFE_NEW CGlobalAICallback(this);
+
+	if (!postLoad || (postLoad &amp;&amp; !loadSupported)) {
+		try {
+			ai-&gt;InitAI(botLibName, callback, team);
+		} HANDLE_EXCEPTION;
+	}
+}
+
+
+void CGlobalAI::LoadCPPAI(int team, const char* botLibName, bool postLoad, bool loadSupported, bool isJavaAI)
+{
+	if (isJavaAI) {
+		logOutput &lt;&lt; botLibName &lt;&lt; &quot; is a Java archive\n&quot;;
+	} else {
+		logOutput &lt;&lt; botLibName &lt;&lt; &quot; has a C++ interface\n&quot;;
+	}
+
+	_GetGlobalAiVersionFunc = (GETGLOBALAIVERSION) lib-&gt;FindAddress(&quot;GetGlobalAiVersion&quot;);
+
+	if (_GetGlobalAiVersionFunc == 0) {
+		char msg[512];
+		SNPRINTF(msg, 511, &quot;Incorrect GlobalAI library \&quot;%s\&quot; (no \&quot;GetGlobalAiVersion\&quot; function exported)&quot;, botLibName);
+		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+		return;
+	}
+
+	const int botInterfaceVersion = _GetGlobalAiVersionFunc();
+
+	if (botInterfaceVersion != GLOBAL_AI_INTERFACE_VERSION) {
+		char msg[1024];
+		SNPRINTF(msg, 1023,
+			&quot;Incorrect GlobalAI library \&quot;%s\&quot;\n&quot;
+			&quot;(lib interface version %d, engine interface version %d)&quot;,
+			botLibName, botInterfaceVersion, GLOBAL_AI_INTERFACE_VERSION);
+		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+		return;
+	}
+
+
+	if (isJavaAI) {
+		// we want to load a Java AI inside a jar,
+		// pass the name of the actual .jar to the
+		// proxy library so it can spawn a JVM for
+		// that AI
+		_GetNewAIByNameFunc = (GETNEWAIBYNAME) lib-&gt;FindAddress(&quot;GetNewAIByName&quot;);
+
+		if (_GetNewAIByNameFunc == 0) {
+			throw std::runtime_error(&quot;JAI proxy does not export \&quot;GetNewAIByName\&quot;&quot;);
+		}
+
+		// note: team parameter is unnecessary
+		ai = _GetNewAIByNameFunc(botLibName, team);
+	} else {
+		_GetNewAIFunc = (GETNEWAI) lib-&gt;FindAddress(&quot;GetNewAI&quot;);
+
+		if (_GetNewAIFunc == 0) {
+			char msg[512];
+			SNPRINTF(msg, 511, &quot;GlobalAI library \&quot;%s\&quot; does not export \&quot;GetNewAI\&quot;&quot;, botLibName);
+			throw std::runtime_error(msg);
+		}
+
+		ai = _GetNewAIFunc();
+	}
+
+	// note: verify that this is really exported too?
+	_ReleaseAIFunc = (RELEASEAI) lib-&gt;FindAddress(&quot;ReleaseAI&quot;);
+	callback = SAFE_NEW CGlobalAICallback(this);
+
+	if (!postLoad || (postLoad &amp;&amp; !loadSupported)) {
+		try {
+			ai-&gt;InitAI(callback, team);
+		} HANDLE_EXCEPTION;
+	}
+}
+
+
+void CGlobalAI::LoadJavaProxyAI()
+{
+	// TODO: Mac support? non-hardcoded proxy?
+	#ifdef WIN32
+	const char* javaProxyAI = &quot;AI\\Bot-libs\\JAI\\JAI.dll&quot;;
+	#else
+	const char* javaProxyAI = &quot;AI/Bot-libs/JAI/JAI.so&quot;;
+	#endif
+
+	if (!filesystem.GetFilesize(javaProxyAI)) {
+		char msg[512];
+		SNPRINTF(msg, 511, &quot;Could not find Java GlobalAI proxy library \&quot;%s\&quot;&quot;, javaProxyAI);
+		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+		return;
+	}
+
+	lib = SharedLib::Instantiate(javaProxyAI);
+}
+
+
 void CGlobalAI::Update(void)
 {
-//	gh-&gt;Update();
 	ai-&gt;Update();
 }
 

Modified: branches/gml/rts/ExternalAI/GlobalAI.h
===================================================================
--- branches/gml/rts/ExternalAI/GlobalAI.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/GlobalAI.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -8,42 +8,53 @@
 class CGlobalAICallback;
 class CGroupHandler;
 
-class CGlobalAI :
-	public CObject
+class CGlobalAI: public CObject
 {
 public:
 	CR_DECLARE(CGlobalAI);
 	CGlobalAI(int team, const char* dll);
 	~CGlobalAI(void);
+
+	void LoadAILib(int, const char*, bool);
+
 	void Serialize(creg::ISerializer *s);
 	void PostLoad();
 	void Load(std::istream *s);
 	void Save(std::ostream *s);
 
 	void Update(void);
-	void PreDestroy (); // called just before all the units are destroyed
+	void PreDestroy(); // called just before all the units are destroyed
 
 	int team;
 	bool cheatevents;
 
 	bool IsCInterface;
+	bool IsLoadSupported;
 
 	IGlobalAI* ai;
 	CGlobalAICallback* callback;
-//	CGroupHandler* gh;
 
-	SharedLib *lib;
-	std::string dllName;
+	SharedLib* lib;
+	std::string libName;
 
-	typedef bool (* ISCINTERFACE)();
-	typedef int (* GETGLOBALAIVERSION)();
-	typedef IGlobalAI* (* GETNEWAI)();
-	typedef void (* RELEASEAI)(IGlobalAI* i);
+	typedef bool (*ISCINTERFACE)();
+	typedef int (*GETGLOBALAIVERSION)();
+	typedef IGlobalAI* (*GETNEWAI)();
+	typedef IGlobalAI* (*GETNEWAIBYNAME)(const char*, int);
+	typedef void (*RELEASEAI)(IGlobalAI* i);
+	typedef bool (*ISLOADSUPPORTED)();
 	
-	ISCINTERFACE _IsCInterface;
-	GETGLOBALAIVERSION GetGlobalAiVersion;
-	GETNEWAI GetNewAI;
-	RELEASEAI ReleaseAI;
+	ISCINTERFACE _IsCInterfaceFunc;
+	GETGLOBALAIVERSION _GetGlobalAiVersionFunc;
+	GETNEWAI _GetNewAIFunc;
+	GETNEWAIBYNAME _GetNewAIByNameFunc;
+	RELEASEAI _ReleaseAIFunc;
+	ISLOADSUPPORTED _IsLoadSupportedFunc;
+
+private:
+	void LoadABICAI(int, const char*, bool, bool);
+	void LoadCPPAI(int, const char*, bool, bool, bool);
+	void LoadJavaProxyAI();
 };
 
 #endif

Modified: branches/gml/rts/ExternalAI/GlobalAICInterface/AbicProxy.h
===================================================================
--- branches/gml/rts/ExternalAI/GlobalAICInterface/AbicProxy.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/GlobalAICInterface/AbicProxy.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -44,8 +44,6 @@
 
 const char AI_NAME[]=&quot;ABIC&quot;; // probably should read this from config file or something
 
-using namespace std;
-
 #ifdef WIN32
 	#define AILOG_PATH &quot;AI\\Bot-libs\\&quot;
 #else
@@ -92,8 +90,8 @@
 	::IGlobalAICallback* globalaicallback;
 	::IAICallback* aicallback;
 
-	set&lt;int&gt; myUnits;
-	set&lt;int&gt; enemies;
+	std::set&lt;int&gt; myUnits;
+	std::set&lt;int&gt; enemies;
     
 private:
   //  FILE *logfile;

Modified: branches/gml/rts/ExternalAI/GlobalAIHandler.cpp
===================================================================
--- branches/gml/rts/ExternalAI/GlobalAIHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/GlobalAIHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -222,9 +222,13 @@
 		return false;
 	}
 
+	if (net-&gt;localDemoPlayback) {
+		return false;
+	}
+
 	if (strncmp(dll, &quot;LuaAI:&quot;, 6) == 0) {
 		CTeam* team = gs-&gt;Team(teamID);
-		if (team != NULL) { 
+		if (team != NULL) {
 			team-&gt;luaAI = (dll + 6);
 			return true;
 		}
@@ -232,23 +236,20 @@
 	}
 
 	try {
-		if (net-&gt;localDemoPlayback) {
-			return false;
-		}
-
-		if(ais[teamID]){
+		if (ais[teamID]) {
 			delete ais[teamID];
-			ais[teamID]=0;
+			ais[teamID] = 0;
 		}
 
-		ais[teamID]=SAFE_NEW CGlobalAI(teamID,dll);
+		ais[teamID] = SAFE_NEW CGlobalAI(teamID, dll);
 
-		if(!ais[teamID]-&gt;ai){
+		if (!ais[teamID]-&gt;ai) {
 			delete ais[teamID];
-			ais[teamID]=0;
+			ais[teamID] = 0;
 			return false;
 		}
-		hasAI=true;
+
+		hasAI = true;
 		return true;
 	} HANDLE_EXCEPTION;
 	return false;

Modified: branches/gml/rts/ExternalAI/Group.h
===================================================================
--- branches/gml/rts/ExternalAI/Group.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/Group.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -18,8 +18,6 @@
 class CGroupAICallback;
 class CGroupHandler;
 
-using namespace std;
-
 class CGroup : public CObject
 {
 public:

Modified: branches/gml/rts/ExternalAI/GroupHandler.cpp
===================================================================
--- branches/gml/rts/ExternalAI/GroupHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/GroupHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -92,7 +92,7 @@
 			(*ai)-&gt;DrawCommands();
 }
 
-void CGroupHandler::TestDll(string name)
+void CGroupHandler::TestDll(std::string name)
 {
 	typedef int (* GETGROUPAIVERSION)();
 	typedef const char ** (* GETAINAMELIST)();
@@ -144,7 +144,7 @@
 		AIKey key;
 		key.dllName=name;
 		key.aiNumber=i;
-		availableAI[key]=string(aiNameList[i]);
+		availableAI[key] = std::string(aiNameList[i]);
 	}
 //	logOutput &lt;&lt; name.c_str() &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; &quot;\n&quot;;
 	delete lib;
@@ -196,7 +196,7 @@
 	selectedUnits.SelectGroup(num);
 }
 
-void CGroupHandler::GroupCommand(int num, const string&amp; cmd)
+void CGroupHandler::GroupCommand(int num, const std::string&amp; cmd)
 {
 	if ((cmd == &quot;set&quot;) || (cmd == &quot;add&quot;)) {
 		if (cmd == &quot;set&quot;) {
@@ -291,15 +291,15 @@
 	delete group;
 }
 
-map&lt;AIKey,string&gt; CGroupHandler::GetSuitedAis(const CUnitSet&amp; units)
+std::map&lt;AIKey, std::string&gt; CGroupHandler::GetSuitedAis(const CUnitSet&amp; units)
 {
 	typedef bool (* ISUNITSUITED)(unsigned aiNumber,const UnitDef* unitDef);
 	ISUNITSUITED IsUnitSuited;
 
-	map&lt;AIKey,string&gt; suitedAis;
+	std::map&lt;AIKey, std::string&gt; suitedAis;
 	suitedAis[defaultKey]=&quot;default&quot;;
 
-	map&lt;AIKey,string&gt;::iterator aai;
+	std::map&lt;AIKey, std::string&gt;::iterator aai;
 	for(aai=availableAI.begin();aai!=availableAI.end();++aai)
 	{
 		SharedLib *lib;

Modified: branches/gml/rts/ExternalAI/GroupHandler.h
===================================================================
--- branches/gml/rts/ExternalAI/GroupHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/GroupHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,8 +13,6 @@
 class CGroup;
 class CUnitSet;
 
-using namespace std;
-
 class CGroupHandler
 {
 public:
@@ -26,24 +24,24 @@
 	void Update();
 	void DrawCommands();
 	void GroupCommand(int num);
-	void GroupCommand(int num, const string&amp; cmd);
+	void GroupCommand(int num, const std::string&amp; cmd);
 	CGroup* CreateNewGroup(AIKey aiKey);
 	void RemoveGroup(CGroup* group);
 	void Load(std::istream *s);
 	void Save(std::ostream *s);
 
-	vector&lt;CGroup*&gt; groups;
-	map&lt;AIKey,string&gt; availableAI;
+	std::vector&lt;CGroup*&gt; groups;
+	std::map&lt;AIKey, std::string&gt; availableAI;
 
-	map&lt;AIKey,string&gt; GetSuitedAis(const CUnitSet&amp; units);
-	map&lt;AIKey,string&gt; lastSuitedAis;
+	std::map&lt;AIKey, std::string&gt; GetSuitedAis(const CUnitSet&amp; units);
+	std::map&lt;AIKey, std::string&gt; lastSuitedAis;
 
 	int team;
 protected:
 	void FindDlls(void);
-	void TestDll(string name);
+	void TestDll(std::string name);
 
-	vector&lt;int&gt; freeGroups;
+	std::vector&lt;int&gt; freeGroups;
 	int firstUnusedGroup;
 private:
 	AIKey defaultKey;

Modified: branches/gml/rts/ExternalAI/IAICallback.h
===================================================================
--- branches/gml/rts/ExternalAI/IAICallback.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/IAICallback.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -49,7 +49,9 @@
 {
 	float3 pos;
 	unsigned char* color;
-	const char* label; // don't store this pointer anywhere, it may become invalid at any time after GetMapPoints()
+	// don't store this pointer anywhere, it may become
+	// invalid at any time after GetMapPoints()
+	const char* label;
 };
 
 struct LineMarker {
@@ -96,15 +98,34 @@
 	virtual void SendTextMsg(const char* text, int zone) = 0;
 	virtual void SetLastMsgPos(float3 pos) = 0;
 	virtual void AddNotification(float3 pos, float3 color, float alpha) = 0;
+
+	// give &lt;mAmount&gt; of metal and &lt;eAmount&gt; of energy to &lt;receivingTeam&gt;
+	// * the amounts are capped to the AI team's resource levels
+	// * does not check for alliance with &lt;receivingTeam&gt;
+	// * LuaRules might not allow resource transfers, AI's must verify the deduction
+	virtual bool SendResources(float mAmount, float eAmount, int receivingTeam) = 0;
+	// give units to &lt;receivingTeam&gt;, the return value represents how many
+	// actually were transferred (make sure this always matches the size of
+	// the vector you pass in, if not then some unitID's were filtered out)
+	// * does not check for alliance with &lt;receivingTeam&gt;
+	// * AI's should check each unit if it is still under control of their
+	//   team after the transaction via UnitTaken() and UnitGiven(), since
+	//   LuaRules might block part of it
+	virtual int SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam) = 0;
+
 	// checks if pos is within view of the current camera, using radius as a margin
 	virtual bool PosInCamera(float3 pos, float radius) = 0;
 
-	// get the current game time, there are 30 frames per second at normal speed
+	// get the current game time measured in frames (the
+	// simulation runs at 30 frames per second at normal
+	// speed)
 	virtual int GetCurrentFrame() = 0;
+
 	virtual int GetMyTeam() = 0;
 	virtual int GetMyAllyTeam() = 0;
 	virtual int GetPlayerTeam(int player) = 0;
 	virtual const char* GetTeamSide(int team) = 0;
+
 	// returns the size of the created area, this is initialized to all 0 if not previously created
 	// set something to !0 to tell other AI's that the area is already initialized when they try to
 	// create it (the exact internal format of the memory areas is up to the AI's to keep consistent)

Modified: branches/gml/rts/ExternalAI/IGlobalAI.h
===================================================================
--- branches/gml/rts/ExternalAI/IGlobalAI.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/IGlobalAI.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,6 +1,9 @@
 #ifndef IGLOBALAI_H
 #define IGLOBALAI_H
 
+#include &lt;cstdlib&gt;
+#include &lt;cstring&gt;
+
 #include &quot;aibase.h&quot;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 #include &quot;float3.h&quot;

Modified: branches/gml/rts/ExternalAI/aibase.h
===================================================================
--- branches/gml/rts/ExternalAI/aibase.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/ExternalAI/aibase.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,16 +6,6 @@
 #ifndef AIBASE_H
 #define AIBASE_H
 
-#ifdef _WIN32
-
-#include &lt;windows.h&gt;
-
-#else
-
-#define WINAPI
-
-#endif
-
 // Shared library support
 #ifdef _WIN32
 	#define DLL_EXPORT extern &quot;C&quot; __declspec(dllexport)


Property changes on: branches/gml/rts/Game/Action.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Game/Action.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Game/Camera/FPSController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/FPSController.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Camera/FPSController.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -44,19 +44,19 @@
 
 float3 CFPSController::GetPos()
 {
-	const float margin = 0.01f;
-	const float xMin = margin;
-	const float zMin = margin;
-	const float xMax = (float)(gs-&gt;mapx * SQUARE_SIZE) - margin;
-	const float zMax = (float)(gs-&gt;mapy * SQUARE_SIZE) - margin;
-
-	pos.x = max(xMin, min(xMax, pos.x));
-	pos.z = max(zMin, min(zMax, pos.z));
-
 #ifdef DIRECT_CONTROL_ALLOWED
 	if (!gu-&gt;directControl)
 #endif
 	{
+		const float margin = 0.01f;
+		const float xMin = margin;
+		const float zMin = margin;
+		const float xMax = (float)(gs-&gt;mapx * SQUARE_SIZE) - margin;
+		const float zMax = (float)(gs-&gt;mapy * SQUARE_SIZE) - margin;
+
+		pos.x = max(xMin, min(xMax, pos.x));
+		pos.z = max(zMin, min(zMax, pos.z));
+
 		const float gndHeight = ground-&gt;GetHeight(pos.x, pos.z);
 		const float yMin = gndHeight + 5.0f;
 		const float yMax = 9000.0f;

Modified: branches/gml/rts/Game/Camera/OverheadController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/OverheadController.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Camera/OverheadController.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -110,7 +110,7 @@
 
 float3 COverheadController::GetPos()
 {
-	maxHeight=9.5f*max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
+	maxHeight = 9.5f * std::max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
 
 	if (pos.x &lt; 0.01f) { pos.x = 0.01f; }
 	if (pos.z &lt; 0.01f) { pos.z = 0.01f; }

Modified: branches/gml/rts/Game/Camera/OverviewController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/OverviewController.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Camera/OverviewController.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -32,7 +32,7 @@
 	pos.x = gs-&gt;mapx * 4.0f;
 	pos.z = gs-&gt;mapy * 4.0f;
 	const float aspect = (gu-&gt;viewSizeX / gu-&gt;viewSizeY);
-	const float height = max(pos.x / aspect, pos.z);
+	const float height = std::max(pos.x / aspect, pos.z);
 	pos.y = ground-&gt;GetHeight(pos.x, pos.z) + (2.5f * height);
 	return pos;
 }

Modified: branches/gml/rts/Game/Camera/SmoothController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/SmoothController.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Camera/SmoothController.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -155,7 +155,7 @@
 
 float3 SmoothController::GetPos()
 {
-	maxHeight=9.5f*max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
+	maxHeight = 9.5f * std::max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
 
 	if (pos.x &lt; 0.01f) { pos.x = 0.01f; }
 	if (pos.z &lt; 0.01f) { pos.z = 0.01f; }


Property changes on: branches/gml/rts/Game/Camera/SmoothController.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Game/Camera/SmoothController.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Game/Camera.cpp
===================================================================
--- branches/gml/rts/Game/Camera.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Camera.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -169,7 +169,7 @@
 	}
 
 	const float gndHeight = ground-&gt;GetHeight(pos.x, pos.z);
-	const float rangemod = 1.0f + max(0.0f, pos.y - gndHeight - 500.0f) * 0.0003f;
+	const float rangemod = 1.0f + std::max(0.0f, pos.y - gndHeight - 500.0f) * 0.0003f;
 	const float zNear = (NEAR_PLANE * rangemod);
 	gu-&gt;viewRange = MAX_VIEW_RANGE * rangemod;
 


Property changes on: branches/gml/rts/Game/ChatMessage.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Game/ChatMessage.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Game/CommandMessage.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Game/CommandMessage.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Game/Console.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Game/Console.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Game/ConsoleHistory.cpp
===================================================================
--- branches/gml/rts/Game/ConsoleHistory.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/ConsoleHistory.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -30,9 +30,9 @@
 }
 
 
-bool CConsoleHistory::AddLine(const string&amp; msg)
+bool CConsoleHistory::AddLine(const std::string&amp; msg)
 {
-	string message;
+	std::string message;
 	if ((msg.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (msg[1] == ':')) {
 		message = msg.substr(2);
 	} else {
@@ -42,7 +42,7 @@
 }
 
 	
-bool CConsoleHistory::AddLineRaw(const string&amp; msg)
+bool CConsoleHistory::AddLineRaw(const std::string&amp; msg)
 {
 	if (msg.empty()) {
 		return false; // do not save blank lines
@@ -66,9 +66,9 @@
 }
 
 
-string CConsoleHistory::NextLine(const string&amp; current)
+std::string CConsoleHistory::NextLine(const std::string&amp; current)
 {
-	string prefix, message;
+	std::string prefix, message;
 	if ((current.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (current[1] == ':')) {
 		prefix  = current.substr(0, 2);
 		message = current.substr(2);
@@ -103,9 +103,9 @@
 }
 
 
-string CConsoleHistory::PrevLine(const string&amp; current)
+std::string CConsoleHistory::PrevLine(const std::string&amp; current)
 {
-	string prefix, message;
+	std::string prefix, message;
 	if ((current.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (current[1] == ':')) {
 		prefix  = current.substr(0, 2);
 		message = current.substr(2);

Modified: branches/gml/rts/Game/ConsoleHistory.h
===================================================================
--- branches/gml/rts/Game/ConsoleHistory.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/ConsoleHistory.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,24 +7,22 @@
 #include &lt;string&gt;
 #include &lt;list&gt;
 
-using namespace std;
-
 class CConsoleHistory
 {
 public:
 	CConsoleHistory();
 	~CConsoleHistory();
 	void ResetPosition();
-	bool AddLine(const string&amp; msg);
-	string NextLine(const string&amp; current);
-	string PrevLine(const string&amp; current);
+	bool AddLine(const std::string&amp; msg);
+	std::string NextLine(const std::string&amp; current);
+	std::string PrevLine(const std::string&amp; current);
 
 protected:
-	bool AddLineRaw(const string&amp; msg);
+	bool AddLineRaw(const std::string&amp; msg);
 
 protected:
-	list&lt;string&gt; lines;
-	list&lt;string&gt;::const_iterator pos;
+	std::list&lt;std::string&gt; lines;
+	std::list&lt;std::string&gt;::const_iterator pos;
 	static unsigned int MaxLines;
 };
 

Modified: branches/gml/rts/Game/Game.cpp
===================================================================
--- branches/gml/rts/Game/Game.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Game.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -54,6 +54,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/HeightMapTexture.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/MetalMap.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;NetProtocol.h&quot;
@@ -85,6 +86,7 @@
 #include &quot;Sim/Misc/DamageArrayHandler.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
@@ -152,12 +154,6 @@
 #include &quot;lib/gml/gmlsrv.h&quot;
 gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 
-GLfloat LightDiffuseLand[] = { 0.8f, 0.8f, 0.8f, 1.0f };
-GLfloat LightAmbientLand[] = { 0.2f, 0.2f, 0.2f, 1.0f };
-GLfloat FogLand[] =          { 0.7f, 0.7f, 0.8f, 0.0f };
-GLfloat FogWhite[] =         { 1.0f, 1.0f, 1.0f, 0.0f };
-GLfloat FogBlack[] =         { 0.0f, 0.0f, 0.0f, 0.0f };
-
 extern Uint8 *keys;
 extern bool globalQuit;
 extern bool fullscreen;
@@ -165,7 +161,7 @@
 
 CGame* game = NULL;
 
-CR_BIND(CGame, (std::string(&quot;&quot;), std::string(&quot;&quot;), NULL));
+CR_BIND(CGame, (std::string(&quot;&quot;), std::string(&quot;&quot;), NULL, NULL));
 
 CR_REG_METADATA(CGame,(
 	CR_RESERVED(4),//r3927
@@ -194,6 +190,7 @@
 
 	CR_MEMBER(soundEnabled),
 	CR_MEMBER(gameSoundVolume),
+	CR_MEMBER(unitReplyVolume),
 
 //	CR_MEMBER(script),
 	CR_RESERVED(64),
@@ -201,7 +198,7 @@
 ));
 
 
-CGame::CGame(std::string mapname, std::string modName, CInfoConsole *ic)
+CGame::CGame(std::string mapname, std::string modName, CInfoConsole *ic, CLoadSaveHandler *saveFile)
 : lastFrameTime(0),
   drawMode(notDrawing),
   drawSky(true),
@@ -284,9 +281,10 @@
 	ENTER_UNSYNCED;
 	sound = CSound::GetSoundSystem();
 	gameSoundVolume = configHandler.GetInt(&quot;SoundVolume&quot;, 60) * 0.01f;
+	unitReplyVolume = configHandler.GetInt(&quot;UnitReplyVolume&quot;, configHandler.GetInt(&quot;UnitReplySoundVolume&quot;, 80) ) * 0.01f;
 	soundEnabled = true;
 	sound-&gt;SetVolume(gameSoundVolume);
-	sound-&gt;SetUnitReplyVolume(configHandler.GetInt (&quot;UnitReplySoundVolume&quot;, 80) * 0.01f);
+	sound-&gt;SetUnitReplyVolume(unitReplyVolume);
 
 	camera = SAFE_NEW CCamera();
 	cam2 = SAFE_NEW CCamera();
@@ -342,7 +340,9 @@
 
 	ENTER_SYNCED;
 	ground = SAFE_NEW CGround();
+	mapInfo = SAFE_NEW CMapInfo(mapname); // must go before readmap
 	readmap = CReadMap::LoadMap (mapname);
+	groundBlockingObjectMap = SAFE_NEW CGroundBlockingObjectMap(gs-&gt;mapSquares);
 	wind.LoadWind();
 	moveinfo = SAFE_NEW CMoveInfo();
 	groundDecals = SAFE_NEW CGroundDecalHandler();
@@ -392,7 +392,7 @@
 	modelParser = SAFE_NEW C3DModelParser();
 
  	ENTER_SYNCED;
- 	featureHandler-&gt;LoadFeaturesFromMap(CScriptHandler::Instance().chosenScript-&gt;loadGame);
+ 	featureHandler-&gt;LoadFeaturesFromMap(saveFile || CScriptHandler::Instance().chosenScript-&gt;loadGame);
  	pathManager = SAFE_NEW CPathManager();
 
  	delete defsParser;
@@ -420,24 +420,21 @@
 		PrintLoadMsg(&quot;Loading LuaGaia&quot;);
 		CLuaGaia::LoadHandler();
 	}
-
+	if (!!configHandler.GetInt(&quot;LuaUI&quot;, 0)) {
+		PrintLoadMsg(&quot;Loading LuaUI&quot;);
+		CLuaUI::LoadHandler();
+	}
 	PrintLoadMsg(&quot;Finalizing...&quot;);
 
 	ENTER_MIXED;
 	if (true || !shadowHandler-&gt;drawShadows) { // FIXME ?
-		for(int a = 0; a &lt; 3; ++a) {
-			LightAmbientLand[a] = unitDrawer-&gt;unitAmbientColor[a];
-			LightDiffuseLand[a] = unitDrawer-&gt;unitSunColor[a];
-		}
-		glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbientLand);		// Setup The Ambient Light
-		glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuseLand);		// Setup The Diffuse Light
-		glLightfv(GL_LIGHT1, GL_SPECULAR, LightAmbientLand);		// Setup The Diffuse Light
-		glMaterialf(GL_FRONT_AND_BACK,GL_SHININESS,0);
-		glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,0);
+		glLightfv(GL_LIGHT1, GL_AMBIENT, mapInfo-&gt;light.unitAmbientColor);
+		glLightfv(GL_LIGHT1, GL_DIFFUSE, mapInfo-&gt;light.unitSunColor);
+		glLightfv(GL_LIGHT1, GL_SPECULAR, mapInfo-&gt;light.unitAmbientColor);
+		glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0);
+		glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);
 	}
 
-	logOutput.Print(&quot;Spring %s&quot;,VERSION_STRING);
-
 	CPlayer* p = gs-&gt;players[gu-&gt;myPlayerNum];
 	if(!gameSetup || net-&gt;localDemoPlayback) {
 		p-&gt;playerName = configHandler.GetString(&quot;name&quot;, &quot;&quot;);
@@ -455,14 +452,15 @@
 	updateDeltaSeconds = 0.0f;
 	script = CScriptHandler::Instance().chosenScript;
 	assert(script);
+	luaCallIns.GamePreload();
 
-	glFogfv(GL_FOG_COLOR,FogLand);
+	glFogfv(GL_FOG_COLOR, mapInfo-&gt;atmosphere.fogColor);
 	glFogf(GL_FOG_START, 0.0f);
 	glFogf(GL_FOG_END, gu-&gt;viewRange * 0.98f);
 	glFogf(GL_FOG_DENSITY, 1.0f);
 	glFogi(GL_FOG_MODE,GL_LINEAR);
 	glEnable(GL_FOG);
-	glClearColor(FogLand[0], FogLand[1], FogLand[2], 0.0f);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0], mapInfo-&gt;atmosphere.fogColor[1], mapInfo-&gt;atmosphere.fogColor[2], 0.0f);
 #ifdef TRACE_SYNC
 	tracefile.NewInterval();
 	tracefile.NewInterval();
@@ -474,14 +472,15 @@
 	tracefile.NewInterval();
 #endif
 
-	net-&gt;loading = false;
-	thread.join();
-
 	activeController = this;
 
 	chatSound = sound-&gt;GetWaveId(&quot;sounds/beep4.wav&quot;);
 
-	UnloadStartPicture();
+	if (!saveFile) UnloadStartPicture();
+	
+	net-&gt;loading = false;
+		thread.join();
+	logOutput.Print(&quot;Spring %s&quot;,VERSION_STRING);
 	//sending your playername to the server indicates that you are finished loading
 	net-&gt;SendPlayerName(gu-&gt;myPlayerNum, p-&gt;playerName);
 
@@ -489,6 +488,8 @@
 		net-&gt;SendStartPlaying(0);
 
 	lastCpuUsageTime = gu-&gt;gameTime + 10;
+
+	mouse-&gt;ShowMouse();
 }
 
 
@@ -524,9 +525,10 @@
 
 	globalAI-&gt;PreDestroy ();
 	delete globalAI;           globalAI           = NULL;
-//	delete grouphandler;       grouphandler       = NULL;
+
 	for(int a=0;a&lt;MAX_TEAMS;a++) {
-		delete grouphandlers[a];grouphandlers[a]   = NULL;}
+		delete grouphandlers[a]; grouphandlers[a] = NULL;
+	}
 
 	delete water;              water              = NULL;
 	delete sky;                sky                = NULL;
@@ -569,6 +571,12 @@
 	delete consoleHistory;     consoleHistory     = NULL;
 	delete wordCompletion;     wordCompletion     = NULL;
 	delete explGenHandler;     explGenHandler     = NULL;
+
+	delete const_cast&lt;CMapInfo*&gt;(mapInfo);
+	mapInfo = NULL;
+	delete groundBlockingObjectMap;
+	groundBlockingObjectMap = NULL;
+
 	CCategoryHandler::RemoveInstance();
 	CColorMap::DeleteColormaps();
 }
@@ -683,7 +691,7 @@
 			else if (action.command == &quot;chatswitchall&quot;) {
 				if ((userInput.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (userInput[1] == ':')) {
 					userInput = userInput.substr(2);
-					writingPos = max(0, writingPos - 2);
+					writingPos = std::max(0, writingPos - 2);
 				}
 				userInputPrefix = &quot;&quot;;
 				break;
@@ -743,11 +751,11 @@
 				break;
 			}
 			else if (action.command == &quot;edit_prev_char&quot;) {
-				writingPos = max(0, min((int)userInput.length(), writingPos - 1));
+				writingPos = std::max(0, std::min((int)userInput.length(), writingPos - 1));
 				break;
 			}
 			else if (action.command == &quot;edit_next_char&quot;) {
-				writingPos = max(0, min((int)userInput.length(), writingPos + 1));
+				writingPos = std::max(0, std::min((int)userInput.length(), writingPos + 1));
 				break;
 			}
 			else if (action.command == &quot;edit_prev_word&quot;) {
@@ -891,15 +899,18 @@
 	}
 	else if (cmd == &quot;water&quot;) {
 		delete water;
+
+		static char rmodes[5][32] = {&quot;basic&quot;, &quot;reflective&quot;, &quot;dynamic&quot;, &quot;reflective&amp;refractive&quot;, &quot;bumpmapped&quot;};
 		int next = 0;
+
 		if (!action.extra.empty()) {
-			next = atoi(action.extra.c_str());
+			next = std::max(0, atoi(action.extra.c_str()) % 5);
 		} else {
 			const int current = configHandler.GetInt(&quot;ReflectiveWater&quot;, 1);
-			next = (max(0, current) + 1) % 4;
+			next = (std::max(0, current) + 1) % 5;
 		}
 		configHandler.SetInt(&quot;ReflectiveWater&quot;, next);
-		logOutput.Print(&quot;Set ReflectiveWater to %i&quot;, next);
+		logOutput.Print(&quot;Set water rendering mode to %i (%s)&quot;, next, rmodes[next]);
 		water = CBaseWater::GetWater();
 	}
 	else if (cmd == &quot;advshading&quot;) {
@@ -1184,11 +1195,21 @@
 		const char* startPtr = action.extra.c_str();
 		float volume = (float)strtod(startPtr, &amp;endPtr);
 		if (endPtr != startPtr) {
-			gameSoundVolume = max(0.0f, min(1.0f, volume));
+			gameSoundVolume = std::max(0.0f, std::min(1.0f, volume));
 			sound-&gt;SetVolume(gameSoundVolume);
 			configHandler.SetInt(&quot;SoundVolume&quot;, (int)(gameSoundVolume * 100.0f));
 		}
 	}
+	else if (cmd == &quot;unitreplyvolume&quot;) {
+		char* endPtr;
+		const char* startPtr = action.extra.c_str();
+		float volume = (float)strtod(startPtr, &amp;endPtr);
+		if (endPtr != startPtr) {
+			unitReplyVolume = std::max(0.0f, std::min(1.0f, volume));
+			sound-&gt;SetUnitReplyVolume(unitReplyVolume);
+			configHandler.SetInt(&quot;UnitReplyVolume&quot;,(int)(unitReplyVolume * 100.0f));
+		}
+	}
 	else if (cmd == &quot;savegame&quot;){
 		if (filesystem.CreateDirectory(&quot;Saves&quot;)) {
 			CLoadSaveHandler ls;
@@ -1275,6 +1296,15 @@
 			hideInterface = !!atoi(action.extra.c_str());
 		}
 	}
+	else if (cmd == &quot;hardwarecursor&quot;) {
+		if (action.extra.empty()) {
+			mouse-&gt;hardwareCursor = !mouse-&gt;hardwareCursor;
+		} else {
+			mouse-&gt;hardwareCursor = !!atoi(action.extra.c_str());
+		}
+		mouse-&gt;UpdateHwCursor();
+		configHandler.SetInt(&quot;HardwareCursor&quot;, (int)mouse-&gt;hardwareCursor);
+	}
 	else if (cmd == &quot;increaseviewradius&quot;) {
 		gd-&gt;IncreaseDetail();
 	}
@@ -1298,8 +1328,12 @@
 		logOutput &lt;&lt; &quot;Cloud density &quot; &lt;&lt; 1/sky-&gt;cloudDensity &lt;&lt; &quot;\n&quot;;
 	}
 
+	// Break up the if/else chain to workaround MSVC compiler limit
+	// &quot;fatal error C1061: compiler limit : blocks nested too deeply&quot;
+	else notfound1=true;
+	if (notfound1)
 
-	else if (cmd == &quot;speedup&quot;) {
+	if (cmd == &quot;speedup&quot;) {
 		float speed = gs-&gt;userSpeedFactor;
 		if (speed &lt; 1) {
 			speed /= 0.8f;
@@ -1334,11 +1368,7 @@
 	}
 #endif
 
-	// Break up the if/else chain to workaround MSVC compiler limit
-	// &quot;fatal error C1061: compiler limit : blocks nested too deeply&quot;
-	else notfound1=true;
-	if (notfound1)
-	if (cmd == &quot;showshadowmap&quot;) {
+	else if (cmd == &quot;showshadowmap&quot;) {
 		shadowHandler-&gt;showShadowMap = !shadowHandler-&gt;showShadowMap;
 	}
 	else if (cmd == &quot;showstandard&quot;) {
@@ -1425,10 +1455,10 @@
 		}
 	}
 	else if (cmd == &quot;incguiopacity&quot;) {
-		CInputReceiver::guiAlpha = min(CInputReceiver::guiAlpha+0.1f,1.0f);
+		CInputReceiver::guiAlpha = std::min(CInputReceiver::guiAlpha+0.1f,1.0f);
 	}
 	else if (cmd == &quot;decguiopacity&quot;) {
-		CInputReceiver::guiAlpha = max(CInputReceiver::guiAlpha-0.1f,0.0f);
+		CInputReceiver::guiAlpha = std::max(CInputReceiver::guiAlpha-0.1f,0.0f);
 	}
 
 	else if (cmd == &quot;screenshot&quot;) {
@@ -1495,7 +1525,7 @@
 			if (crossSize &gt; 0.0f) {
 				crossSize = -crossSize;
 			} else {
-				crossSize = max(1.0f, -crossSize);
+				crossSize = std::max(1.0f, -crossSize);
 			}
 		} else {
 			crossSize = atof(action.extra.c_str());
@@ -1677,7 +1707,7 @@
 	}
 	else if (cmd == &quot;maxparticles&quot;) {
 		if (ph &amp;&amp; !action.extra.empty()) {
-			const int value = max(1, atoi(action.extra.c_str()));
+			const int value = std::max(1, atoi(action.extra.c_str()));
 			ph-&gt;SetMaxParticles(value);
 			logOutput.Print(&quot;Set maximum particles to: %i&quot;, value);
 		}
@@ -1736,9 +1766,11 @@
 	}
 	else if (cmd == &quot;wiremap&quot;) {
 		if (action.extra.empty()) {
-			gd-&gt;wireframe = !gd-&gt;wireframe;
+			gd-&gt;wireframe  = !gd-&gt;wireframe;
+			sky-&gt;wireframe = gd-&gt;wireframe;
 		} else {
-			gd-&gt;wireframe = !atoi(action.extra.c_str());
+			gd-&gt;wireframe  = !atoi(action.extra.c_str());
+			sky-&gt;wireframe = gd-&gt;wireframe;
 		}
 	}
 	else if (cmd == &quot;setgamma&quot;) {
@@ -1798,8 +1830,23 @@
 		CommandMessage pckt(Action(action.extra), gu-&gt;myPlayerNum);
 		net-&gt;SendData(pckt.Pack());
 	}
+	else if (cmd == &quot;save&quot;) {// /save [-y ]&lt;savename&gt;
+		if (filesystem.CreateDirectory(&quot;Saves&quot;)) {
+			bool saveoverride = action.extra.find(&quot;-y &quot;) == 0;
+			std::string savename(action.extra.c_str()+(saveoverride?3:0));
+			savename=&quot;Saves/&quot;+savename+&quot;.ssf&quot;;
+			if (filesystem.GetFilesize(savename)==0 || saveoverride) {
+				logOutput.Print(&quot;Saving game to %s\n&quot;,savename.c_str());
+				CLoadSaveHandler ls;
+				ls.mapName = stupidGlobalMapname;
+				ls.modName = modInfo.filename;
+				ls.SaveGame(savename);
+			} else {
+				logOutput.Print(&quot;File %s already exists(use /save -y to override)\n&quot;,savename.c_str());
+			}
+		}
+	}
 	else if (cmd == &quot;atm&quot; ||
-			cmd == &quot;save&quot; ||
 #ifdef DEBUG
 			cmd == &quot;desync&quot; ||
 #endif
@@ -1983,7 +2030,7 @@
 			if ((amount &lt; 0) || (amountStr.find_first_not_of(&quot;0123456789&quot;) != string::npos)) {
 				logOutput.Print(&quot;Bad give amount: %s&quot;, amountStr.c_str());
 				return;
-								}
+			}
 		}
 
 		if (teamArg &gt;= 0) {
@@ -1998,16 +2045,21 @@
 		const string unitName = (amountArg &gt;= 0) ? args[2] : args[1];
 
 		if (unitName == &quot;all&quot;) {
-		// player entered &quot;.give all&quot;
+			// player entered &quot;.give all&quot;
 			int sqSize = (int) streflop::ceil(streflop::sqrt((float) unitDefHandler-&gt;numUnitDefs));
 			int currentNumUnits = gs-&gt;Team(team)-&gt;units.size();
 			int numRequestedUnits = unitDefHandler-&gt;numUnitDefs;
 
-		// make sure team unit-limit not exceeded
+			// make sure team unit-limit not exceeded
 			if ((currentNumUnits + numRequestedUnits) &gt; uh-&gt;maxUnits) {
 				numRequestedUnits = uh-&gt;maxUnits - currentNumUnits;
 			}
 
+			// make sure square is entirely on the map
+			float sqHalfMapSize = sqSize / 2 * 10 * SQUARE_SIZE;
+			pos.x = std::max(sqHalfMapSize, std::min(pos.x, float3::maxxpos - sqHalfMapSize - 1));
+			pos.z = std::max(sqHalfMapSize, std::min(pos.z, float3::maxzpos - sqHalfMapSize - 1));
+
 			for (int a = 1; a &lt;= numRequestedUnits; ++a) {
 				float posx = pos.x + (a % sqSize - sqSize / 2) * 10 * SQUARE_SIZE;
 				float posz = pos.z + (a / sqSize - sqSize / 2) * 10 * SQUARE_SIZE;
@@ -2102,7 +2154,7 @@
 	}
 	else if (action.command == &quot;nospectatorchat&quot;) {
 		SetBoolArg(noSpectatorChat, action.extra);
-		logOutput.Print(&quot;Spectators %s chat&quot;, noSpectatorChat ? &quot;can&quot; : &quot;can not&quot;);
+		logOutput.Print(&quot;Spectators %s chat&quot;, noSpectatorChat ? &quot;can not&quot; : &quot;can&quot;);
 	}
 	else if (action.command == &quot;reloadcob&quot; &amp;&amp; gs-&gt;cheatEnabled) {
 		ReloadCOB(action.extra, playernum);
@@ -2186,7 +2238,7 @@
 		}
 	}
 #ifdef DEBUG
-	if (action.command == &quot;desync&quot; &amp;&amp; gs-&gt;cheatEnabled) {
+	else if (action.command == &quot;desync&quot; &amp;&amp; gs-&gt;cheatEnabled) {
 		for (int i = MAX_UNITS - 1; i &gt;= 0; --i) {
 			if (uh-&gt;units[i]) {
 				if (playernum == gu-&gt;myPlayerNum) {
@@ -2203,16 +2255,6 @@
 		logOutput.Print(&quot;Desyncing in frame %d.&quot;, gs-&gt;frameNum);
 	}
 #endif
-	if (action.command == &quot;resync&quot; &amp;&amp; gs-&gt;cheatEnabled) {
-		CObject* o = CObject::GetSyncedObjects();
-		for (; o; o = o-&gt;GetNext()) {
-			creg::Class* c = o-&gt;GetClass();
-			logOutput.Print(&quot;%s\n&quot;, c-&gt;name.c_str());
-			for (std::vector&lt;creg::Class::Member*&gt;::const_iterator m = c-&gt;members.begin(); m != c-&gt;members.end(); ++m) {
-				logOutput.Print(&quot;  %s\n&quot;, (*m)-&gt;name);
-			}
-		}
-	}
 	else if (action.command == &quot;atm&quot; &amp;&amp; gs-&gt;cheatEnabled) {
 		int team = gs-&gt;players[playernum]-&gt;team;
 		gs-&gt;Team(team)-&gt;AddMetal(1000);
@@ -2239,22 +2281,6 @@
 			}
 		}
 	}
-	else if (action.command == &quot;save &quot;) {//.save [-y ]&lt;savename&gt;
-		if (filesystem.CreateDirectory(&quot;Saves&quot;)) {
-			bool saveoverride = action.extra.find(&quot;-y &quot;) == 0;
-			std::string savename(action.extra.c_str()+(saveoverride?3:0));
-			savename=&quot;Saves/&quot;+savename+&quot;.ssf&quot;;
-			if (filesystem.GetFilesize(savename)==0 || saveoverride) {
-				logOutput.Print(&quot;Saving game to %s\n&quot;,savename.c_str());
-				CLoadSaveHandler ls;
-				ls.mapName = stupidGlobalMapname;
-				ls.modName = modInfo.filename;
-				ls.SaveGame(savename);
-			} else {
-				logOutput.Print(&quot;File %s allready exists(use /save -y to override)\n&quot;,savename.c_str());
-			}
-		}
-	}
 	else if (action.command == &quot;skip&quot;) {
 		if (action.extra.find_first_of(&quot;start&quot;) == 0) {
 			std::istringstream buf(action.extra.substr(6));
@@ -2373,7 +2399,7 @@
 	SCOPED_TIMER(&quot;Draw world&quot;);
 
 	CBaseGroundDrawer* gd = readmap-&gt;GetGroundDrawer();
-
+	
 	if (drawSky) {
 		sky-&gt;Draw();
 	}
@@ -2382,7 +2408,7 @@
 		gd-&gt;Draw();
 	}
 	if (drawWater) {
-		if (!readmap-&gt;voidWater &amp;&amp; water-&gt;drawSolid) {
+		if (!mapInfo-&gt;map.voidWater &amp;&amp; water-&gt;drawSolid) {
 			water-&gt;Draw();
 		}
 	}
@@ -2406,10 +2432,11 @@
 		}
 	}
 	if (drawWater) {
-		if (!readmap-&gt;voidWater &amp;&amp; !water-&gt;drawSolid) {
+		if (!mapInfo-&gt;map.voidWater &amp;&amp; !water-&gt;drawSolid) {
 			water-&gt;Draw();
 		}
 	}
+
 	unitDrawer-&gt;DrawCloakedUnits();
 	ph-&gt;Draw(false);
 
@@ -2560,7 +2587,7 @@
 	ph-&gt;UpdateTextures();
 	fartextureHandler-&gt;CreateFarTextures();
 
-	glClearColor(FogLand[0], FogLand[1], FogLand[2], 0);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0], mapInfo-&gt;atmosphere.fogColor[1], mapInfo-&gt;atmosphere.fogColor[2], 0);
 
 	sky-&gt;Update();
 
@@ -2897,6 +2924,7 @@
 	CLuaUI::UpdateTeams();
 	ENTER_SYNCED;
 	script-&gt;GameStart();
+	luaCallIns.GameStart();
 
 }
 
@@ -2981,7 +3009,7 @@
 				net-&gt;SendDirectControlUpdate(gu-&gt;myPlayerNum, status, hp.x, hp.y);
 			}
 		}
-#endif	
+#endif
 		water-&gt;Update();
 	}
 
@@ -3432,37 +3460,42 @@
 				break;
 			}
 
-			case NETMSG_AICOMMAND:{
-				Command c;
-				int player=inbuf[3];
-				if(player&gt;=MAX_PLAYERS || player&lt;0){
-					logOutput.Print(&quot;Got invalid player num %i in aicommand msg&quot;,player);
+
+
+			case NETMSG_AICOMMAND: {
+				const int player = inbuf[3];
+				if (player &gt;= MAX_PLAYERS || player &lt; 0) {
+					logOutput.Print(&quot;Got invalid player number (%i) in NETMSG_AICOMMAND&quot;, player);
 					break;
 				}
-				int unitid=*((short int*)&amp;inbuf[4]);
-				if(unitid&gt;=MAX_UNITS || unitid&lt;0){
-					logOutput.Print(&quot;Got invalid unitid %i in aicommand msg&quot;,unitid);
+
+				int unitid = *((short int*) &amp;inbuf[4]);
+				if (unitid &gt;= MAX_UNITS || unitid &lt; 0) {
+					logOutput.Print(&quot;Got invalid unitID (%i) in NETMSG_AICOMMAND&quot;, unitid);
 					break;
 				}
-				//if(uh-&gt;units[unitid] &amp;&amp; uh-&gt;units[unitid]-&gt;team!=gs-&gt;players[player]-&gt;team)		//msgs from global ais can be for other teams
-				//	logOutput.Print(&quot;Warning player %i of team %i tried to send aiorder to unit from team %i&quot;,a,gs-&gt;players[player]-&gt;team,uh-&gt;units[unitid]-&gt;team);
-				c.id=*((int*)&amp;inbuf[6]);
-				c.options=inbuf[10];
-				for(int a=0;a&lt;((*((short int*)&amp;inbuf[1])-11)/4);++a)
-					c.params.push_back(*((float*)&amp;inbuf[11+a*4]));
+
+				Command c;
+				c.id = *((int*) &amp;inbuf[6]);
+				c.options = inbuf[10];
+
+				// insert the command parameters
+				for (int a = 0; a &lt; ((*((short int*) &amp;inbuf[1]) - 11) / 4); ++a)
+					c.params.push_back(*((float*) &amp;inbuf[11 + a * 4]));
+
 				selectedUnits.AiOrder(unitid,c);
 				AddTraffic(player, packetCode, dataLength);
 				break;
 			}
 
-			case NETMSG_AICOMMANDS:{
-				int u, c;
+			case NETMSG_AICOMMANDS: {
 				const int player = inbuf[3];
-				if (player&gt;=MAX_PLAYERS || player&lt;0) {
-					logOutput.Print(&quot;Got invalid player num %i in aicommands msg&quot;,player);
+				if (player &gt;= MAX_PLAYERS || player &lt; 0) {
+					logOutput.Print(&quot;Got invalid player number (%i) in NETMSG_AICOMMANDS&quot;, player);
 					break;
 				}
 
+				int u, c;
 				const unsigned char* ptr = &amp;inbuf[4];
 
 				// FIXME -- hackish
@@ -3499,6 +3532,49 @@
 				break;
 			}
 
+			case NETMSG_AISHARE: {
+				const int player = inbuf[3];
+				if (player &gt;= MAX_PLAYERS || player &lt; 0) {
+					logOutput.Print(&quot;Got invalid player number (%i) in NETMSG_AISHARE&quot;, player);
+					break;
+				}
+
+				// total message length
+				const short numBytes = *(short*) &amp;inbuf[1];
+				const int fixedLen = (1 + sizeof(short) + 3 + (2 * sizeof(float)));
+				const int variableLen = numBytes - fixedLen;
+				const int numUnitIDs = variableLen / sizeof(short); // each unitID is two bytes
+				const int srcTeam = *(int*) &amp;inbuf[4];
+				const int dstTeam = *(int*) &amp;inbuf[8];
+				const float metalShare = *(float*) &amp;inbuf[12];
+				const float energyShare = *(float*) &amp;inbuf[16];
+
+				if (metalShare &gt; 0.0f) {
+					if (!luaRules || luaRules-&gt;AllowResourceTransfer(srcTeam, dstTeam, &quot;m&quot;, metalShare)) {
+						gs-&gt;Team(srcTeam)-&gt;metal -= metalShare;
+						gs-&gt;Team(dstTeam)-&gt;metal += metalShare;
+					}
+				}
+				if (energyShare &gt; 0.0f) {
+					if (!luaRules || luaRules-&gt;AllowResourceTransfer(srcTeam, dstTeam, &quot;e&quot;, energyShare)) {
+						gs-&gt;Team(srcTeam)-&gt;energy -= energyShare;
+						gs-&gt;Team(dstTeam)-&gt;energy += energyShare;
+					}
+				}
+
+				for (int i = 0, j = fixedLen;  i &lt; numUnitIDs;  i++, j += sizeof(short)) {
+					short int unitID = *(short int*) &amp;inbuf[j];
+					CUnit* u = uh-&gt;units[unitID];
+
+					// ChangeTeam() handles the AllowUnitTransfer() LuaRule
+					if (u &amp;&amp; u-&gt;team == srcTeam &amp;&amp; !u-&gt;beingBuilt) {
+						u-&gt;ChangeTeam(dstTeam, CUnit::ChangeGiven);
+					}
+				}
+			} break;
+
+
+
 			case NETMSG_LUAMSG: {
 				const int player = inbuf[3];
 				if ((player &lt; 0) || (player &gt;= MAX_PLAYERS)) {
@@ -3535,8 +3611,8 @@
 				int team1=gs-&gt;players[player]-&gt;team;
 				int team2=inbuf[2];
 				bool shareUnits=!!inbuf[3];
-				float metalShare=min(*(float*)&amp;inbuf[4],(float)gs-&gt;Team(team1)-&gt;metal);
-				float energyShare=min(*(float*)&amp;inbuf[8],(float)gs-&gt;Team(team1)-&gt;energy);
+				float metalShare=std::min(*(float*)&amp;inbuf[4],(float)gs-&gt;Team(team1)-&gt;metal);
+				float energyShare=std::min(*(float*)&amp;inbuf[8],(float)gs-&gt;Team(team1)-&gt;energy);
 
 				if (metalShare != 0.0f) {
 					if (!luaRules || luaRules-&gt;AllowResourceTransfer(team1, team2, &quot;m&quot;, metalShare)) {
@@ -3641,10 +3717,12 @@
 							gu-&gt;myTeam = newTeam;
 							gu-&gt;myAllyTeam = gs-&gt;AllyTeam(gu-&gt;myTeam);
 							gu-&gt;spectating = false;
+							gu-&gt;spectatingFullView   = false;
+							gu-&gt;spectatingFullSelect = false;
 							selectedUnits.ClearSelected();
 							unitTracker.Disable();
 							CLuaUI::UpdateTeams();
-						}						
+						}
 						if (gs-&gt;Team(newTeam)-&gt;leader == -1)
 							gs-&gt;Team(newTeam)-&gt;leader = player;
 						break;
@@ -3903,8 +3981,8 @@
 		return;
 
 	file &lt;&lt; &quot;Frame &quot; &lt;&lt; gs-&gt;frameNum &lt;&lt;&quot;\n&quot;;
-	list&lt;CUnit*&gt;::iterator usi;
-	for(usi=uh-&gt;activeUnits.begin();usi!=uh-&gt;activeUnits.end();usi++){
+	std::list&lt;CUnit*&gt;::iterator usi;
+	for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); usi++) {
 		CUnit* u=*usi;
 		file &lt;&lt; &quot;Unit &quot; &lt;&lt; u-&gt;id &lt;&lt; &quot;\n&quot;;
 		file &lt;&lt; &quot;  xpos &quot; &lt;&lt; u-&gt;pos.x &lt;&lt; &quot; ypos &quot; &lt;&lt; u-&gt;pos.y &lt;&lt; &quot; zpos &quot; &lt;&lt; u-&gt;pos.z &lt;&lt; &quot;\n&quot;;
@@ -3952,14 +4030,14 @@
 			glPushMatrix();
 			glRotatef(unit-&gt;heading*180.0f/32768+180,0,0,1);
 
-			glColor4d(0.3f,0.9f,0.3f,0.4f);
+			glColor4f(0.3f, 0.9f, 0.3f, 0.4f);
 			glBegin(GL_TRIANGLE_FAN);
-			glVertex2d(-0.2f,-0.3f);
-			glVertex2d(-0.2f,0.3f);
-			glVertex2d(0,0.4f);
-			glVertex2d(0.2f,0.3f);
-			glVertex2d(0.2f,-0.3f);
-			glVertex2d(-0.2f,-0.3f);
+			glVertex2f(-0.2f, -0.3f);
+			glVertex2f(-0.2f,  0.3f);
+			glVertex2f( 0.0f,  0.4f);
+			glVertex2f( 0.2f,  0.3f);
+			glVertex2f( 0.2f, -0.3f);
+			glVertex2f(-0.2f, -0.3f);
 			glEnd();
 			glPopMatrix();
 		}
@@ -3990,14 +4068,14 @@
 			glRotatef(GetHeadingFromVector(camera-&gt;forward.x,camera-&gt;forward.z)*180.0f/32768+180,0,0,1);
 			glScalef(0.4f,0.4f,0.3f);
 
-			glColor4d(0.4f,0.4f,1.0f,0.6f);
+			glColor4f(0.4f, 0.4f, 1.0f, 0.6f);
 			glBegin(GL_TRIANGLE_FAN);
-			glVertex2d(-0.2f,-0.3f);
-			glVertex2d(-0.2f,0.3f);
-			glVertex2d(0,0.5f);
-			glVertex2d(0.2f,0.3f);
-			glVertex2d(0.2f,-0.3f);
-			glVertex2d(-0.2f,-0.3f);
+			glVertex2f(-0.2f, -0.3f);
+			glVertex2f(-0.2f,  0.3f);
+			glVertex2f( 0.0f,  0.5f);
+			glVertex2f( 0.2f,  0.3f);
+			glVertex2f( 0.2f, -0.3f);
+			glVertex2f(-0.2f, -0.3f);
 			glEnd();
 			glPopMatrix();
 		}
@@ -4005,25 +4083,57 @@
 
 		glEnable(GL_TEXTURE_2D);
 
-		glColor4d(0.2f,0.8f,0.2f,0.8f);
-		font-&gt;glFormatAt(0.02f, 0.65f, 1.0f, &quot;Health %.0f&quot;,unit-&gt;health);
+		glColor4f(0.2f, 0.8f, 0.2f, 0.8f);
+		font-&gt;glFormatAt(0.02f, 0.65f, 1.0f, &quot;Health %.0f / %.0f&quot;, unit-&gt;health, unit-&gt;maxHealth);
 
 		if(gs-&gt;players[gu-&gt;myPlayerNum]-&gt;myControl.mouse2){
 			font-&gt;glPrintAt(0.02f, 0.7f, 1.0f, &quot;Free fire mode&quot;);
 		}
-		for(int a=0;a&lt;unit-&gt;weapons.size();++a){
-			CWeapon* w=unit-&gt;weapons[a];
-			const WeaponDef* wd = w-&gt;weaponDef;
-			if(!wd-&gt;isShield){
-				if(w-&gt;reloadStatus&gt;gs-&gt;frameNum){
-					glColor4d(0.8f,0.2f,0.2f,0.8f);
-					font-&gt;glFormatAt(0.02f, 0.32f - a * 0.04f, 0.8f, &quot;%s: Reloading&quot;, wd-&gt;description.c_str());
-				} else if(!w-&gt;angleGood){
-					glColor4d(0.6f,0.6f,0.2f,0.8f);
-					font-&gt;glFormatAt(0.02f, 0.32f - a * 0.04f, 0.8f, &quot;%s: Aiming&quot;,wd-&gt;description.c_str());
-				} else {
-					glColor4d(0.2f,0.8f,0.2f,0.8f);
-					font-&gt;glFormatAt(0.02f, 0.32f - a * 0.04f, 0.8f, &quot;%s: Ready&quot;,wd-&gt;description.c_str());
+
+		int numWeaponsToPrint = 0;
+		for (int a = 0; a &lt; unit-&gt;weapons.size(); ++a) {
+			const WeaponDef* wd = unit-&gt;weapons[a]-&gt;weaponDef;
+			if (!wd-&gt;isShield) {
+				++numWeaponsToPrint;
+			}
+		}
+
+		if (numWeaponsToPrint) {
+			// we have limited space to draw whole list of weapons
+			const float yTop = 0.35f;
+			const float yBottom = 0.11f;
+			const float maxLineHeight = 0.045f;
+			const float lineHeight = std::min((yTop - yBottom) / numWeaponsToPrint, maxLineHeight);
+			const float fontSize = 1.2f * (lineHeight / maxLineHeight);
+			float yPos = yTop;
+
+			for (int a = 0; a &lt; unit-&gt;weapons.size(); ++a) {
+				const CWeapon* w = unit-&gt;weapons[a];
+				const WeaponDef* wd = w-&gt;weaponDef;
+				if (!wd-&gt;isShield) {
+					yPos -= lineHeight;
+					if (wd-&gt;stockpile &amp;&amp; !w-&gt;numStockpiled) {
+						if (w-&gt;numStockpileQued) {
+							glColor4f(0.8f, 0.2f, 0.2f, 0.8f);
+							font-&gt;glFormatAt(0.02f, yPos, fontSize, &quot;%s:  Stockpiling %i%%&quot;, wd-&gt;description.c_str(), int(100.0f * w-&gt;buildPercent + 0.5f));
+						}
+						else {
+							glColor4f(0.8f, 0.2f, 0.2f, 0.8f);
+							font-&gt;glFormatAt(0.02f, yPos, fontSize, &quot;%s:  No ammo&quot;, wd-&gt;description.c_str());
+						}
+					}
+					else if (w-&gt;reloadStatus &gt; gs-&gt;frameNum) {
+						glColor4f(0.8f, 0.2f, 0.2f, 0.8f);
+						font-&gt;glFormatAt(0.02f, yPos, fontSize, &quot;%s:  Reloading %i%%&quot;, wd-&gt;description.c_str(), 100 - int(100.0f * (w-&gt;reloadStatus - gs-&gt;frameNum) / int(w-&gt;reloadTime / unit-&gt;reloadSpeed) + 0.5f));
+					}
+					else if (!w-&gt;angleGood) {
+						glColor4f(0.6f, 0.6f, 0.2f, 0.8f);
+						font-&gt;glFormatAt(0.02f, yPos, fontSize, &quot;%s:  Aiming&quot;, wd-&gt;description.c_str());
+					}
+					else {
+						glColor4f(0.2f, 0.8f, 0.2f, 0.8f);
+						font-&gt;glFormatAt(0.02f, yPos, fontSize, &quot;%s:  Ready&quot;, wd-&gt;description.c_str());
+					}
 				}
 			}
 		}
@@ -4038,20 +4148,20 @@
 	glDisable(GL_TEXTURE_2D);
 
 	for(int a=0;a&lt;unit-&gt;weapons.size();++a){
-		CWeapon* w=unit-&gt;weapons[a];
+		const CWeapon* w = unit-&gt;weapons[a];
 		if(!w){
 			logOutput.Print(&quot;Null weapon in vector?&quot;);
 			return;
 		}
 		switch(a){
 		case 0:
-			glColor4d(0,1,0,0.7f);
+			glColor4f(0.0f, 1.0f, 0.0f, 0.7f);
 			break;
 		case 1:
-			glColor4d(1,0,0,0.7f);
+			glColor4f(1.0f, 0.0f, 0.0f, 0.7f);
 			break;
 		default:
-			glColor4d(0,0,1,0.7f);
+			glColor4f(0.0f, 0.0f, 1.0f, 0.7f);
 		}
 		if(w-&gt;targetType!=Target_None){
 			float3 pos=w-&gt;targetPos;
@@ -4069,7 +4179,7 @@
 			glEnd();
 
 			if(!w-&gt;onlyForward){
-				float dist=min(w-&gt;owner-&gt;directControl-&gt;targetDist,w-&gt;range*0.9f);
+				float dist=std::min(w-&gt;owner-&gt;directControl-&gt;targetDist,w-&gt;range*0.9f);
 				pos=w-&gt;weaponPos+w-&gt;wantedDir*dist;
 				v1=(pos-camera-&gt;pos).Normalize();
 				v2=(v1.cross(UpVector)).Normalize();
@@ -4165,7 +4275,7 @@
 				message = message.substr(2);
 			}
 		}
-	}	
+	}
 	if (message.size() &gt; 128) {
 		message.resize(128); // safety
 	}
@@ -4179,14 +4289,13 @@
 	if (msg.fromPlayer &lt; 0 || (msg.fromPlayer &gt;= MAX_PLAYERS &amp;&amp; msg.fromPlayer != SERVER_PLAYER))
 		return;
 
-	globalAI-&gt;GotChatMsg(msg.msg.c_str(), msg.fromPlayer);
 	CScriptHandler::Instance().chosenScript-&gt;GotChatMsg(msg.msg, msg.fromPlayer);
 	string s = msg.msg;
 
 	if (!s.empty()) {
 		CPlayer* player = (msg.fromPlayer == SERVER_PLAYER) ? 0 : gs-&gt;players[msg.fromPlayer];
 		const bool myMsg = (msg.fromPlayer == gu-&gt;myPlayerNum);
-	
+
 		string label;
 		if (!player) {
 			label = &quot;&gt; &quot;;
@@ -4195,7 +4304,7 @@
 		} else {
 			label = &quot;&lt;&quot; + player-&gt;playerName + &quot;&gt; &quot;;
 		}
-	
+
 		/*
 		- If you're spectating you always see all chat messages.
 		- If you're playing you see:
@@ -4205,7 +4314,7 @@
 		- TO_EVERYONE-messages from spectators only if noSpectatorChat is off!
 		- private messages if they are for you ;)
 		*/
-	
+
 		if (msg.destination == ChatMessage::TO_ALLIES &amp;&amp; player) {
 			const int msgAllyTeam = gs-&gt;AllyTeam(player-&gt;team);
 			const bool allied = gs-&gt;Ally(msgAllyTeam, gu-&gt;myAllyTeam);
@@ -4231,6 +4340,8 @@
 			sound-&gt;PlaySample(chatSound, 5);
 		}
 	}
+
+	globalAI-&gt;GotChatMsg(msg.msg.c_str(), msg.fromPlayer);
 }
 
 
@@ -4456,7 +4567,7 @@
 {
 	const float fOrig = (float)orig / 255.0f;
 	float luaVal = tbl.GetFloat(channel, fOrig);
-	luaVal = max(0.0f, min(1.0f, luaVal));
+	luaVal = std::max(0.0f, std::min(1.0f, luaVal));
 	return (unsigned char)(luaVal * 255.0f);
 }
 
@@ -4487,8 +4598,8 @@
 	luaParser.AddParam(&quot;modShortName&quot;, modInfo.shortName);
 	luaParser.AddParam(&quot;modVersion&quot;,   modInfo.version);
 
-	luaParser.AddParam(&quot;mapName&quot;,      readmap-&gt;mapName);
-	luaParser.AddParam(&quot;mapHumanName&quot;, readmap-&gt;mapHumanName);
+	luaParser.AddParam(&quot;mapName&quot;,      mapInfo-&gt;map.name);
+	luaParser.AddParam(&quot;mapHumanName&quot;, mapInfo-&gt;map.humanName);
 
 	luaParser.AddParam(&quot;gameMode&quot;,     gs-&gt;gameMode);
 

Modified: branches/gml/rts/Game/Game.h
===================================================================
--- branches/gml/rts/Game/Game.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Game.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -20,6 +20,7 @@
 class CKeySet;
 class CInfoConsole;
 class LuaParser;
+class CLoadSaveHandler;
 class Action;
 class ChatMessage;
 
@@ -42,7 +43,7 @@
 	bool Update();
 	int KeyReleased(unsigned short k);
 	int KeyPressed(unsigned short k,bool isRepeat);
-	CGame(std::string mapname, std::string modName, CInfoConsole *infoConsole);
+	CGame(std::string mapname, std::string modName, CInfoConsole *infoConsole, CLoadSaveHandler *saveFile);
 	void ResizeEvent();
 	virtual ~CGame();
 
@@ -104,6 +105,7 @@
 
 	bool soundEnabled;
 	float gameSoundVolume;
+	float unitReplyVolume;
 
 	CScript* script;
 

Modified: branches/gml/rts/Game/GameData.cpp
===================================================================
--- branches/gml/rts/Game/GameData.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/GameData.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -27,11 +27,12 @@
 	packet &gt;&gt; mapChecksum;
 	packet &gt;&gt; mod;
 	packet &gt;&gt; modChecksum;
+	packet &gt;&gt; randomSeed;
 }
 
 const netcode::RawPacket* GameData::Pack() const
 {
-	unsigned short size = 3 + 2*sizeof(unsigned) + map.size() + mod.size() + script.size() + 3;
+	unsigned short size = 3 + 2*sizeof(unsigned) + map.size() + mod.size() + script.size() + 4 + 3;
 	PackPacket* buffer = new PackPacket(size);
 	*buffer &lt;&lt; (unsigned char)NETMSG_GAMEDATA;
 	*buffer &lt;&lt; size;
@@ -40,6 +41,7 @@
 	*buffer &lt;&lt; mapChecksum;
 	*buffer &lt;&lt; mod;
 	*buffer &lt;&lt; modChecksum;
+	*buffer &lt;&lt; randomSeed;
 	return buffer;
 }
 
@@ -59,3 +61,8 @@
 	mod = newMod;
 	modChecksum = checksum;
 }
+
+void GameData::SetRandomSeed(const unsigned seed)
+{
+	randomSeed = seed;
+}


Property changes on: branches/gml/rts/Game/GameData.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Game/GameData.h
===================================================================
--- branches/gml/rts/Game/GameData.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/GameData.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -18,12 +18,14 @@
 	void SetScript(const std::string&amp; newScript);
 	void SetMap(const std::string&amp; newMap, const unsigned checksum);
 	void SetMod(const std::string&amp; newMod, const unsigned checksum);
+	void SetRandomSeed(const unsigned seed);
 	
 	const std::string&amp; GetScript() const {return script;};
 	const std::string&amp; GetMap() const {return map;};
 	unsigned GetMapChecksum() const {return mapChecksum;};
 	const std::string&amp; GetMod() const {return mod;};
 	unsigned GetModChecksum() const {return modChecksum;};
+	unsigned GetRandomSeed() const {return randomSeed;};
 
 private:
 	std::string script;
@@ -31,6 +33,7 @@
 	unsigned mapChecksum;
 	std::string mod;
 	unsigned modChecksum;
+	unsigned randomSeed;
 };
 
 #endif


Property changes on: branches/gml/rts/Game/GameData.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Game/GameHelper.cpp
===================================================================
--- branches/gml/rts/Game/GameHelper.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/GameHelper.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -215,7 +215,7 @@
 		for (int* qi = quads; qi != endQuad; ++qi) {
 			const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 
-			for (list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
+			for (std::list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
 				if (!(*ui)-&gt;blocking)
 					continue;
 
@@ -241,16 +241,15 @@
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
 				continue;
 			if (ignoreAllies &amp;&amp; u-&gt;allyteam == owner-&gt;allyteam)
 				continue;
-			if (ignoreNeutrals) {
-				if ((gs-&gt;useLuaGaia &amp;&amp; u-&gt;team == gs-&gt;gaiaTeamID) || (u-&gt;team == MAX_TEAMS - 1)) continue;
-				if (u-&gt;neutral) continue;
+			if (ignoreNeutrals &amp;&amp; u-&gt;IsNeutral()) {
+				continue;
 			}
 
 			float3 dif = u-&gt;midPos - start;
@@ -278,13 +277,11 @@
 {
 	const float groundLength = ground-&gt;LineGroundCol(start, start + dir * length);
 
-//	logOutput.Print(&quot;gl %f&quot;,groundLength);
 	if ((length &gt; (groundLength + 200.0f)) &amp;&amp; (groundLength &gt; 0.0f)) {
 		//need to add some cause we take the backside of the unit sphere;
 		length = groundLength + 200.0f;
 	}
 
-//	float minLength = length;
 	hit = 0;
 
 	vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
@@ -292,17 +289,16 @@
 
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			CUnit* unit = *ui;
 			if (unit == exclude) {
 				continue;
 			}
 
-			if((unit-&gt;allyteam == gu-&gt;myAllyTeam) ||
+			if ((unit-&gt;allyteam == gu-&gt;myAllyTeam) || gu-&gt;spectatingFullView ||
 			   (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; (LOS_INLOS | LOS_CONTRADAR)) ||
-			   (useRadar &amp;&amp; radarhandler-&gt;InRadar(*ui, gu-&gt;myAllyTeam)) ||
-				 gu-&gt;spectatingFullView){
+			   (useRadar &amp;&amp; radarhandler-&gt;InRadar(*ui, gu-&gt;myAllyTeam))) {
 				float3 pos;
 
 				if (gu-&gt;spectatingFullView) {
@@ -365,11 +361,11 @@
 	vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
-			if((*ui)==exclude)
+			if ((*ui)==exclude)
 				continue;
-			if(gs-&gt;Ally((*ui)-&gt;allyteam,allyteam) || ((*ui)-&gt;losStatus[allyteam] &amp; LOS_INLOS)){
+			if (gs-&gt;Ally((*ui)-&gt;allyteam,allyteam) || ((*ui)-&gt;losStatus[allyteam] &amp; LOS_INLOS)){
 				float3 dif=(*ui)-&gt;midPos-start;
 				float closeLength=dif.dot(dir);
 				if(closeLength&lt;0)
@@ -381,7 +377,7 @@
 					length=closeLength;
 					hit=*ui;
 				}
-			} else if(useRadar &amp;&amp; radarhandler-&gt;InRadar(*ui,allyteam)){
+			} else if (useRadar &amp;&amp; radarhandler-&gt;InRadar(*ui,allyteam)){
 				float3 dif=(*ui)-&gt;midPos+(*ui)-&gt;posErrorVector*radarhandler-&gt;radarErrorSize[allyteam]-start;
 				float closeLength=dif.dot(dir);
 				if(closeLength&lt;0)
@@ -410,16 +406,16 @@
 	float secDamage = weapon-&gt;weaponDef-&gt;damages[0]*weapon-&gt;salvoSize/weapon-&gt;reloadTime*30;			//how much damage the weapon deal over 1 seconds
 	bool paralyzer = !!weapon-&gt;weaponDef-&gt;damages.paralyzeDamageTime;
 
-	vector&lt;int&gt; quads = qf-&gt;GetQuads(pos,radius+(aHeight-max(0.f,readmap-&gt;minheight))*heightMod);
+	std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos,radius+(aHeight - std::max(0.f,readmap-&gt;minheight))*heightMod);
 
 	int tempNum = gs-&gt;tempNum++;
-	vector&lt;int&gt;::iterator qi;
-	for(qi = quads.begin(); qi != quads.end(); ++qi) {
-		for(int t = 0; t &lt; gs-&gt;activeAllyTeams; ++t) {
+	std::vector&lt;int&gt;::iterator qi;
+	for (qi = quads.begin(); qi != quads.end(); ++qi) {
+		for (int t = 0; t &lt; gs-&gt;activeAllyTeams; ++t) {
 			if (gs-&gt;Ally(attacker-&gt;allyteam, t)) {
 				continue;
 			}
-			list&lt;CUnit*&gt;::const_iterator ui;
+			std::list&lt;CUnit*&gt;::const_iterator ui;
 			const std::list&lt;CUnit*&gt;&amp; allyTeamUnits = qf-&gt;GetQuad(*qi).teamUnits[t];
 			for (ui = allyTeamUnits.begin(); ui != allyTeamUnits.end(); ++ui) {
 				CUnit* unit = *ui;
@@ -466,7 +462,7 @@
 						if (weapon-&gt;hasTargetWeight) {
 							value *= weapon-&gt;TargetWeight(unit);
 						}
-						targets.insert(pair&lt;float, CUnit*&gt;(value, unit));
+						targets.insert(std::pair&lt;float, CUnit*&gt;(value, unit));
 					}
 				}
 			}
@@ -492,8 +488,8 @@
 	int tempNum = gs-&gt;tempNum++;
 	vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
-		const list&lt;CUnit*&gt;&amp; units = qf-&gt;GetQuad(*qi).units;
-		list&lt;CUnit*&gt;::const_iterator ui;
+		const std::list&lt;CUnit*&gt;&amp; units = qf-&gt;GetQuad(*qi).units;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = units.begin(); ui != units.end(); ++ui) {
 			CUnit* unit = *ui;
 			if (unit-&gt;tempNum != tempNum) {
@@ -529,7 +525,7 @@
 	vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam) &amp;&amp; (((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))){
 				(*ui)-&gt;tempNum=tempNum;
@@ -553,11 +549,11 @@
 
 	if (sphere) {  // includes target radius
 		float closeDist = radius;
-		vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius + uh-&gt;maxUnitRadius);
-		vector&lt;int&gt;::const_iterator qi;
+		std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius + uh-&gt;maxUnitRadius);
+		std::vector&lt;int&gt;::const_iterator qi;
 		for (qi = quads.begin(); qi != quads.end(); ++qi) {
-			const list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
-			list&lt;CUnit*&gt;::const_iterator ui;
+			const std::list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
+			std::list&lt;CUnit*&gt;::const_iterator ui;
 			for (ui = quadUnits.begin(); ui!= quadUnits.end(); ++ui) {
 				CUnit* unit = *ui;
 				if (unit-&gt;tempNum != tempNum &amp;&amp;
@@ -574,11 +570,11 @@
 	}
 	else { // cylinder  (doesn't included target radius)
 		float closeDistSq = radius * radius;
-		vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
-		vector&lt;int&gt;::const_iterator qi;
+		std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
+		std::vector&lt;int&gt;::const_iterator qi;
 		for (qi = quads.begin(); qi != quads.end(); ++qi) {
-			const list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
-			list&lt;CUnit*&gt;::const_iterator ui;
+			const std::list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
+			std::list&lt;CUnit*&gt;::const_iterator ui;
 			for (ui = quadUnits.begin(); ui!= quadUnits.end(); ++ui) {
 				CUnit* unit = *ui;
 				if (unit-&gt;tempNum != tempNum &amp;&amp;
@@ -600,13 +596,13 @@
 {
 	float closeDist=radius*radius;
 	CUnit* closeUnit=0;
-	vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
+	std::vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
 
 	int tempNum=gs-&gt;tempNum++;
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam)){
 				(*ui)-&gt;tempNum=tempNum;
@@ -628,10 +624,10 @@
 	vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
 
 	int tempNum=gs-&gt;tempNum++;
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;unitDef-&gt;canfly &amp;&amp; (*ui)-&gt;tempNum!=tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam) &amp;&amp; !(*ui)-&gt;crashing &amp;&amp; (((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))){
 				(*ui)-&gt;tempNum=tempNum;
@@ -649,13 +645,13 @@
 void CGameHelper::GetEnemyUnits(const float3 &amp;pos, float radius, int searchAllyteam, vector&lt;int&gt; &amp;found)
 {
 	float sqRadius=radius*radius;
-	vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
+	std::vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
 
 	int tempNum=gs-&gt;tempNum++;
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam) &amp;&amp; (((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))){
 				(*ui)-&gt;tempNum=tempNum;
@@ -677,7 +673,7 @@
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
+		for (std::list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
 			if (!(*ui)-&gt;blocking)
 				continue;
 
@@ -702,19 +698,19 @@
 float CGameHelper::GuiTraceRayFeature(const float3&amp; start, const float3&amp; dir, float length, CFeature*&amp; feature)
 {
 	float nearHit = length;
-	vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
+	std::vector&lt;int&gt;::iterator qi;
 
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CFeature*&gt;::const_iterator ui;
+		std::list&lt;CFeature*&gt;::const_iterator ui;
 
 		for (ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
 			CFeature* f = *ui;
 
 			if ((f-&gt;allyteam &gt;= 0) &amp;&amp; !gu-&gt;spectatingFullView &amp;&amp;
-			    (f-&gt;allyteam != gu-&gt;myAllyTeam) &amp;&amp;
-			    !loshandler-&gt;InLos(f-&gt;pos, gu-&gt;myAllyTeam)) {
+				(f-&gt;allyteam != gu-&gt;myAllyTeam) &amp;&amp;
+				!loshandler-&gt;InLos(f-&gt;pos, gu-&gt;myAllyTeam)) {
 				continue;
 			}
 			if (f-&gt;noSelect) {
@@ -825,7 +821,7 @@
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
@@ -850,13 +846,13 @@
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
 				continue;
 
-			if (u-&gt;neutral || (gs-&gt;useLuaGaia &amp;&amp; u-&gt;team == gs-&gt;gaiaTeamID) || (u-&gt;team == MAX_TEAMS - 1)) {
+			if (u-&gt;IsNeutral()) {
 				if (TestConeHelper(from, dir, length, spread, u))
 					return true;
 			}
@@ -900,7 +896,7 @@
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
@@ -924,13 +920,13 @@
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
 				continue;
 
-			if (u-&gt;neutral || (gs-&gt;useLuaGaia &amp;&amp; u-&gt;team == gs-&gt;gaiaTeamID) || (u-&gt;team == MAX_TEAMS - 1)) {
+			if (u-&gt;IsNeutral()) {
 				if (TestTrajectoryConeHelper(from, flatdir, length, linear, quadratic, spread, baseSize, u))
 					return true;
 			}
@@ -942,7 +938,7 @@
 
 
 /** helper for TestTrajectoryAllyCone and TestTrajectoryNeutralCone
-    @return true if the unit u is in the firing cone, false otherwise */
+    @return true if the unit u is in the firing trajectory, false otherwise */
 bool CGameHelper::TestTrajectoryConeHelper(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, const CUnit* u)
 {
 	float3 dif = u-&gt;midPos - from;

Modified: branches/gml/rts/Game/GameServer.cpp
===================================================================
--- branches/gml/rts/Game/GameServer.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/GameServer.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,7 +7,9 @@
 #include &lt;boost/version.hpp&gt;
 #include &lt;SDL_timer.h&gt;
 #include &lt;cmath&gt;
-
+#ifdef DEDICATED
+#include &lt;iostream&gt;
+#endif
 #ifndef NO_AVI
 #include &quot;Game.h&quot;
 #endif
@@ -112,8 +114,7 @@
 	serverNet = new CBaseNetProtocol();
 	serverNet-&gt;InitServer(port);
 	rng.Seed(SDL_GetTicks());
-	log.Subscribe(this);
-	log.Message(format(ServerStart) %port);
+	Message(str( format(ServerStart) %port) );
 
 	lastTick = SDL_GetTicks();
 
@@ -131,7 +132,7 @@
 	gameData.reset(newGameData);
 	if (!demoName.empty())
 	{
-		log.Message(format(PlayingDemo) %demoName);
+		Message(str( format(PlayingDemo) %demoName ));
 		demoReader = new CDemoReader(demoName, modGameTime+0.1f);
 	}
 
@@ -176,7 +177,6 @@
 	if (hostif)
 	{
 		hostif-&gt;SendQuit();
-		log.Unsubscribe(hostif);
 		delete hostif;
 	}
 }
@@ -194,8 +194,7 @@
 		boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex);
 		hostif = new AutohostInterface(remotePort);
 		hostif-&gt;SendStart();
-		log.Subscribe(hostif);
-		log.Message(format(ConnectAutohost) %remotePort);
+		Message(str(format(ConnectAutohost) %remotePort));
 	}
 }
 
@@ -274,19 +273,24 @@
 	if (demoReader-&gt;ReachedEnd()) {
 		delete demoReader;
 		demoReader = 0;
-		log.Message(DemoEnd);
+		Message(DemoEnd);
 		gameEndTime = SDL_GetTicks();
 	}
 }
 
 void CGameServer::Message(const std::string&amp; message)
 {
-	serverNet-&gt;SendSystemMessage(SERVER_PLAYER, message);
+	Warning(message);
 }
 
 void CGameServer::Warning(const std::string&amp; message)
 {
 	serverNet-&gt;SendSystemMessage(SERVER_PLAYER, message);
+	if (hostif)
+		hostif-&gt;Message(message);
+#ifdef DEDICATED
+	std::cout &lt;&lt; message &lt;&lt; std::endl;
+#endif
 }
 
 void CGameServer::CheckSync()
@@ -325,7 +329,7 @@
 				syncWarningFrame = *f;
 
 				std::string players = GetPlayerNames(noSyncResponse);
-				log.Warning(format(NoSyncResponse) %players %(*f));
+				Warning(str(format(NoSyncResponse) %players %(*f)));
 			}
 		}
 
@@ -345,7 +349,7 @@
 				std::map&lt;unsigned, std::vector&lt;int&gt; &gt;::const_iterator g = desyncGroups.begin();
 				for (; g != desyncGroups.end(); ++g) {
 					std::string players = GetPlayerNames(g-&gt;second);
-					log.Warning(format(SyncError) %players %(*f) %(g-&gt;first ^ correctChecksum));
+					Warning(str(format(SyncError) %players %(*f) %(g-&gt;first ^ correctChecksum)));
 				}
 			}
 		}
@@ -366,7 +370,7 @@
 	// Make it clear this build isn't suitable for release.
 	if (!syncErrorFrame || (serverframenum - syncErrorFrame &gt; SYNCCHECK_MSG_TIMEOUT)) {
 		syncErrorFrame = serverframenum;
-		log.Warning(NoSyncCheck);
+		Warning(NoSyncCheck);
 	}
 #endif
 }
@@ -436,12 +440,26 @@
 		std::string msg = hostif-&gt;GetChatMessage();
 
 		if (!msg.empty())
-			GotChatMessage(ChatMessage(SERVER_PLAYER, ChatMessage::TO_EVERYONE, msg));
+		{
+			if (msg.at(0) != '/') // normal chat message
+			{
+				GotChatMessage(ChatMessage(SERVER_PLAYER, ChatMessage::TO_EVERYONE, msg));
+			}
+			else if (msg.at(0) == '/' &amp;&amp; msg.size() &gt; 1 &amp;&amp; msg.at(1) == '/') // chatmessage with prefixed '/'
+			{
+				GotChatMessage(ChatMessage(SERVER_PLAYER, ChatMessage::TO_EVERYONE, msg.substr(1)));
+			}
+			else if (msg.size() &gt; 1) // command
+			{
+				Action buf(msg.substr(1));
+				PushAction(buf);
+			}
+		}
 	}
 	
 	if ((SDL_GetTicks() - serverStartTime) &gt; serverTimeout &amp;&amp; serverNet-&gt;MaxConnectionID() == -1)
 	{
-		log.Message(NoClientsExit);
+		Message(NoClientsExit);
 		quitServer = true;
 	}
 }
@@ -462,10 +480,10 @@
 		else
 		{
 			if (packet-&gt;length &gt;= 3) {
-				log.Warning(format(ConnectionReject) %inbuf[0] %inbuf[2] %packet-&gt;length);
+				Warning(str(format(ConnectionReject) %inbuf[0] %inbuf[2] %packet-&gt;length));
 			}
 			else {
-				log.Warning(&quot;Connection attempt rejected: Packet too short&quot;);
+				Warning(&quot;Connection attempt rejected: Packet too short&quot;);
 			}
 			serverNet-&gt;RejectIncomingConnection();
 		}
@@ -488,7 +506,7 @@
 
 					case NETMSG_PAUSE:
 						if(inbuf[1]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						} else {
 							if (!inbuf[2])  // reset sync checker
 								syncErrorFrame = 0;
@@ -530,7 +548,7 @@
 						break;
 
 					case NETMSG_QUIT: {
-						log.Message(format(PlayerLeft) %players[a]-&gt;name %&quot; normal quit&quot;);
+						Message(str(format(PlayerLeft) %players[a]-&gt;name %&quot; normal quit&quot;));
 						serverNet-&gt;SendPlayerLeft(a, 1);
 						serverNet-&gt;Kill(a);
 						quit = true;
@@ -545,11 +563,11 @@
 					case NETMSG_PLAYERNAME: {
 						unsigned playerNum = inbuf[2];
 						if(playerNum!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %playerNum);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %playerNum));
 						} else {
 							players[playerNum]-&gt;name = (std::string)((char*)inbuf+3);
 							players[playerNum]-&gt;readyToStart = true;
-							log.Message(format(PlayerJoined) %players[playerNum]-&gt;name %playerNum);
+							Message(str(format(PlayerJoined) %players[playerNum]-&gt;name %playerNum));
 							serverNet-&gt;SendPlayerName(playerNum, players[playerNum]-&gt;name);
 							if (hostif)
 							{
@@ -562,7 +580,7 @@
 					case NETMSG_CHAT: {
 						ChatMessage msg(*packet);
 						if (static_cast&lt;unsigned&gt;(msg.fromPlayer) != a ) {
-							log.Warning(format(WrongPlayer) %(unsigned)NETMSG_CHAT %a %(unsigned)msg.fromPlayer);
+							Warning(str(format(WrongPlayer) %(unsigned)NETMSG_CHAT %a %(unsigned)msg.fromPlayer));
 						} else {
 							GotChatMessage(msg);
 						}
@@ -570,7 +588,7 @@
 					}
 					case NETMSG_SYSTEMMSG:
 						if(inbuf[2]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[2]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[2]));
 						} else {
 							serverNet-&gt;SendSystemMessage(inbuf[2], (char*)(&amp;inbuf[3]));
 						}
@@ -578,7 +596,7 @@
 
 					case NETMSG_STARTPOS:
 						if(inbuf[1] != a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						}
 						else if (setup &amp;&amp; setup-&gt;startPosType == CGameSetupData::StartPos_ChooseInGame)
 						{
@@ -586,6 +604,7 @@
 							if (teams[team])
 							{
 								teams[team]-&gt;startpos = SFloat3(*((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8]), *((float*)&amp;inbuf[12]));
+								teams[team]-&gt;readyToStart = static_cast&lt;bool&gt;(inbuf[3]);
 							}
 							serverNet-&gt;SendStartPos(inbuf[1],team, inbuf[3], *((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8]), *((float*)&amp;inbuf[12])); //forward data
 							if (hostif)
@@ -595,13 +614,13 @@
 						}
 						else
 						{
-							log.Warning(format(NoStartposChange) %a);
+							Warning(str(format(NoStartposChange) %a));
 						}
 						break;
 
 					case NETMSG_COMMAND:
 						if(inbuf[3]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
 						} else {
 							if (!demoReader)
 								serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1])); //forward data
@@ -610,40 +629,56 @@
 
 					case NETMSG_SELECT:
 						if(inbuf[3]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
 						} else {
 							if (!demoReader)
-								serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1])); //forward data
+								// forward data
+								serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1]));
 						}
 						break;
 
-					case NETMSG_AICOMMAND:
-						if(inbuf[3]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]);
+
+					case NETMSG_AICOMMAND: {
+						if (inbuf[3] != a) {
+							Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
 						}
 						else if (noHelperAIs) {
-							log.Warning(format(NoHelperAI) %players[a]-&gt;name %a);
+							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
 						}
 						else if (!demoReader) {
-							serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1])); //forward data
+							// forward data
+							serverNet-&gt;RawSend(inbuf, *((short int*) &amp;inbuf[1]));
 						}
-						break;
+					} break;
 
-					case NETMSG_AICOMMANDS:
-						if(inbuf[3]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]);
+					case NETMSG_AICOMMANDS: {
+						if (inbuf[3] != a) {
+							Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
 						}
 						else if (noHelperAIs) {
-							log.Warning(format(NoHelperAI) %players[a]-&gt;name %a);
+							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
 						}
 						else if (!demoReader) {
-							serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1])); //forward data
+							// forward data
+							serverNet-&gt;RawSend(inbuf, *((short int*) &amp;inbuf[1]));
 						}
-						break;
+					} break;
 
+					case NETMSG_AISHARE: {
+						if (inbuf[3] != a) {
+							Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
+						} else if (noHelperAIs) {
+							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
+						} else if (!demoReader) {
+							// forward data
+							serverNet-&gt;RawSend(inbuf, *((short int*) &amp;inbuf[1]));
+						}
+					} break;
+
+
 					case NETMSG_LUAMSG:
 						if(inbuf[3]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
 						}
 						else if (!demoReader) {
 							serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1])); //forward data
@@ -653,14 +688,14 @@
 					case NETMSG_SYNCRESPONSE:
 #ifdef SYNCCHECK
 						if(inbuf[1]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						} else {
 							int frameNum = *(int*)&amp;inbuf[2];
 							if (outstandingSyncFrames.empty() || frameNum &gt;= outstandingSyncFrames.front())
 								players[a]-&gt;syncResponse[frameNum] = *(unsigned*)&amp;inbuf[6];
 							else if (serverframenum - delayedSyncResponseFrame &gt; SYNCCHECK_MSG_TIMEOUT) {
 								delayedSyncResponseFrame = serverframenum;
-								log.Warning(format(DelayedSyncResponse) %players[a]-&gt;name %frameNum %serverframenum);
+								Warning(str(format(DelayedSyncResponse) %players[a]-&gt;name %frameNum %serverframenum));
 							}
 							// update players' ping (if !defined(SYNCCHECK) this is done in NETMSG_KEYFRAME)
 							players[a]-&gt;ping = serverframenum - frameNum;
@@ -670,7 +705,7 @@
 
 					case NETMSG_SHARE:
 						if(inbuf[1]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						} else {
 							if (!demoReader)
 								serverNet-&gt;SendShare(inbuf[1], inbuf[2], inbuf[3], *((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8]));
@@ -679,7 +714,7 @@
 
 					case NETMSG_SETSHARE:
 						if(inbuf[1]!= a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						} else {
 							if (!demoReader)
 								serverNet-&gt;SendSetShare(inbuf[1], inbuf[2], *((float*)&amp;inbuf[3]), *((float*)&amp;inbuf[7]));
@@ -688,7 +723,7 @@
 
 					case NETMSG_PLAYERSTAT:
 						if(inbuf[1]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						} else {
 							serverNet-&gt;RawSend(inbuf,sizeof(CPlayer::Statistics)+2); //forward data
 						}
@@ -701,7 +736,7 @@
 #ifdef DIRECT_CONTROL_ALLOWED
 					case NETMSG_DIRECT_CONTROL:
 						if(inbuf[1]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						} else {
 							if (!demoReader)
 								serverNet-&gt;SendDirectControl(inbuf[1]);
@@ -710,7 +745,7 @@
 
 					case NETMSG_DC_UPDATE:
 						if(inbuf[1]!=a){
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						} else {
 							if (!demoReader)
 								serverNet-&gt;SendDirectControlUpdate(inbuf[1], inbuf[2], *((short*)&amp;inbuf[3]), *((short*)&amp;inbuf[5]));
@@ -730,7 +765,7 @@
 						const unsigned player = (unsigned)inbuf[1];
 						if (player != a)
 						{
-							log.Warning(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)player);
+							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)player));
 						}
 						else
 						{
@@ -778,7 +813,7 @@
 									}
 									else
 									{
-										log.Warning(format(NoTeamChange) %players[player]-&gt;name %player);
+										Warning(str(format(NoTeamChange) %players[player]-&gt;name %player));
 									}
 									break;
 								}
@@ -799,7 +834,7 @@
 									break;
 								}
 								default: {
-									log.Warning(format(UnknownTeammsg) %action %player);
+									Warning(str(format(UnknownTeammsg) %action %player));
 								}
 							}
 							break;
@@ -835,7 +870,7 @@
 							else
 							{
 								// hack!
-								log.Warning(boost::format(CommandNotAllowed) %msg.player %msg.action.command.c_str());
+								Warning(str(boost::format(CommandNotAllowed) %msg.player %msg.action.command.c_str()));
 							}
 						}
 						break;
@@ -850,7 +885,7 @@
 						break;
 					default:
 						{
-							log.Warning(format(UnknownNetmsg) %(unsigned)inbuf[0] %a);
+							Warning(str(format(UnknownNetmsg) %(unsigned)inbuf[0] %a));
 						}
 						break;
 				}
@@ -859,7 +894,7 @@
 		}
 		else if (players[a])
 		{
-			log.Message(format(PlayerLeft) %players[a]-&gt;name %&quot; timeout&quot;); //this must happen BEFORE the reset!
+			Message(str(format(PlayerLeft) %players[a]-&gt;name %&quot; timeout&quot;)); //this must happen BEFORE the reset!
 			players[a].reset();
 			serverNet-&gt;SendPlayerLeft(a, 0);
 			if (hostif)
@@ -874,7 +909,7 @@
 		//HACK check if we lost connection to the last player(s)
 		if (players[a])
 		{
-			log.Message(format(PlayerLeft) %players[a]-&gt;name %&quot; timeout&quot;); //this must happen BEFORE the reset!
+			Message(str(format(PlayerLeft) %players[a]-&gt;name %&quot; timeout&quot;)); //this must happen BEFORE the reset!
 			players[a].reset();
 			serverNet-&gt;SendPlayerLeft(a, 0);
 			if (hostif)
@@ -907,13 +942,13 @@
 	// or pseudo random bytes (if there is no setup)
 	if (setup != NULL) {
 		CRC crc;
-		crc.UpdateData((const unsigned char*)setup-&gt;gameSetupText, setup-&gt;gameSetupTextLength);
-		gameID.intArray[2] = crc.GetCRC();
+		crc.Update(setup-&gt;gameSetupText, setup-&gt;gameSetupTextLength);
+		gameID.intArray[2] = crc.GetDigest();
 	}
 
 	CRC entropy;
-	entropy.UpdateData((const unsigned char*)&amp;lastTick, sizeof(lastTick));
-	gameID.intArray[3] = entropy.GetCRC();
+	entropy.Update(lastTick);
+	gameID.intArray[3] = entropy.GetDigest();
 
 	serverNet-&gt;SendGameID(gameID.charArray);
 }
@@ -922,10 +957,10 @@
 {
 	assert(!gameStartTime);
 	bool allReady = true;
-	unsigned numDemoPlayers = demoReader ? demoReader-&gt;GetFileHeader().maxPlayerNum+1 : 0;
 	
 	if (setup)
 	{
+		unsigned numDemoPlayers = demoReader ? demoReader-&gt;GetFileHeader().maxPlayerNum+1 : 0;
 		unsigned start = numDemoPlayers;
 #ifdef DEDICATED
 		// Lobby-protocol doesn't support creating games without players inside
@@ -998,7 +1033,7 @@
 	if (demoReader) {
 		// the client told us to start a demo
 		// no need to send startpos and startplaying since its in the demo
-		log.Message(DemoStart);
+		Message(DemoStart);
 		return;
 	}
 
@@ -1145,7 +1180,7 @@
 {
 	if (gameEndTime &gt; 0) {
 		if (gameEndTime &lt; SDL_GetTicks() - 2000) {
-			log.Message(GameEnd);
+			Message(GameEnd);
 			serverNet-&gt;SendGameOver();
 			if (hostif) {
 				hostif-&gt;SendGameOver();
@@ -1155,11 +1190,11 @@
 		return;
 	}
 
-#ifndef DEDICATED
 	unsigned numActiveTeams[MAX_TEAMS]; // active teams per ally team
 	memset(numActiveTeams, 0, sizeof(numActiveTeams));
 	unsigned numActiveAllyTeams = 0;
 
+#ifndef DEDICATED
 	for (unsigned a = 0; (int)a &lt; gs-&gt;activeTeams; ++a)
 	{
 		bool hasPlayer = false;
@@ -1178,13 +1213,27 @@
 	for (unsigned a = 0; (int)a &lt; gs-&gt;activeAllyTeams; ++a)
 		if (numActiveTeams[a] != 0)
 			++numActiveAllyTeams;
-
+#else
+	int lastAllyTeam = -1;
+	for (unsigned i = 0; i &lt; MAX_PLAYERS; ++i)
+	{
+		if (players[i])
+		{
+			if (lastAllyTeam &lt; 0)
+				lastAllyTeam = i;
+			else if (lastAllyTeam != teams[players[i]-&gt;team]-&gt;allyTeam)
+			{
+				numActiveAllyTeams = 1;
+				break;
+			}
+		}
+	}
+#endif
 	if (numActiveAllyTeams &lt;= 1)
 	{
 		gameEndTime=SDL_GetTicks();
 		serverNet-&gt;SendSendPlayerStat();
 	}
-#endif
 }
 
 void CGameServer::CreateNewFrame(bool fromServerThread, bool fixedFrameTime)
@@ -1213,9 +1262,9 @@
 		}
 #endif
 
-		timeLeft+=GAME_SPEED*internalSpeed*float(timeElapsed)/1000.0f;
+		timeLeft += GAME_SPEED * internalSpeed * float(timeElapsed) / 1000.0f;
 		lastTick=currentTick;
-		newFrames = (timeLeft &gt; 0) ? std::ceil(timeLeft) : 0;
+		newFrames = (timeLeft &gt; 0)? int(std::ceil(timeLeft)): 0;
 		timeLeft -= newFrames;
 	}
 
@@ -1267,7 +1316,7 @@
 void CGameServer::KickPlayer(const int playerNum)
 {
 	if (players[playerNum]) {
-		log.Message(format(PlayerLeft) %playerNum %&quot;kicked&quot;);
+		Message(str(format(PlayerLeft) %playerNum %&quot;kicked&quot;));
 		serverNet-&gt;SendPlayerLeft(playerNum, 2);
 		serverNet-&gt;SendQuit(playerNum);
 		serverNet-&gt;Kill(playerNum);
@@ -1288,8 +1337,6 @@
 	hisNewNumber = serverNet-&gt;AcceptIncomingConnection(hisNewNumber);
 
 	serverNet-&gt;SendSetPlayerNum((unsigned char)hisNewNumber, (unsigned char)hisNewNumber);
-	static const int pregameRandomSeed = rng();
-	serverNet-&gt;SendRandSeed(pregameRandomSeed);
 	serverNet-&gt;SendData(gameData-&gt;Pack(), hisNewNumber);
 
 	for (int a = 0; a &lt; MAX_PLAYERS; ++a) {
@@ -1300,7 +1347,7 @@
 	// is this is the local player (== host) then he can kick, set options etc.
 	bool grantRights = setup ? (hisNewNumber == (unsigned)setup-&gt;myPlayerNum) : (wantedNumber == 0);
 	players[hisNewNumber].reset(new GameParticipant(grantRights)); // give him rights to change speed, kick players etc
-	if (setup &amp;&amp; hisNewNumber &lt; (unsigned)setup-&gt;numPlayers/* needed for non-hosted demo playback */)
+	if (setup)
 	{
 		unsigned hisTeam = setup-&gt;playerStartingTeam[hisNewNumber];
 		if (!teams[hisTeam]) // create new team
@@ -1308,6 +1355,7 @@
 			teams[hisTeam].reset(new GameTeam());
 			teams[hisTeam]-&gt;startpos = setup-&gt;startPos[hisTeam];
 			teams[hisTeam]-&gt;readyToStart = (setup-&gt;startPosType != CGameSetupData::StartPos_ChooseInGame);
+			teams[hisTeam]-&gt;allyTeam = setup-&gt;teamAllyteam[hisTeam];
 		}
 		players[hisNewNumber]-&gt;team = hisTeam;
 		serverNet-&gt;SendJoinTeam(hisNewNumber, hisTeam);
@@ -1320,18 +1368,21 @@
 	else
 	{
 		unsigned hisTeam = hisNewNumber;
-		teams[hisTeam].reset(new GameTeam());
-		players[hisNewNumber]-&gt;team = hisTeam;
-		serverNet-&gt;SendJoinTeam(hisNewNumber, hisTeam);
-		for (int a = 0; a &lt; MAX_TEAMS; ++a)
+		if (!demoReader)
 		{
-			if (teams[a] &amp;&amp; a != (int)hisNewNumber)
-				serverNet-&gt;SendJoinTeam(a, players[a]-&gt;team);
+			teams[hisTeam].reset(new GameTeam());
+			players[hisNewNumber]-&gt;team = hisTeam;
+			serverNet-&gt;SendJoinTeam(hisNewNumber, hisTeam);
+			for (int a = 0; a &lt; MAX_TEAMS; ++a)
+			{
+				if (teams[a] &amp;&amp; a != (int)hisNewNumber)
+					serverNet-&gt;SendJoinTeam(a, players[a]-&gt;team);
+			}
 		}
 	}
-	log.Message(format(NewConnection) %hisNewNumber %wantedNumber);
+	Message(str(format(NewConnection) %hisNewNumber %wantedNumber));
 
-	serverNet-&gt;FlushNet();
+	serverNet-&gt;FlushNet(hisNewNumber);
 }
 
 void CGameServer::GotChatMessage(const ChatMessage&amp; msg)

Modified: branches/gml/rts/Game/GameServer.h
===================================================================
--- branches/gml/rts/Game/GameServer.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/GameServer.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -14,8 +14,6 @@
 #include &quot;System/GlobalStuff.h&quot;
 #include &quot;System/UnsyncedRNG.h&quot;
 #include &quot;SFloat3.h&quot;
-#include &quot;Server/ServerLogHandler.h&quot;
-#include &quot;Server/ServerLog.h&quot;
 
 class CBaseNetProtocol;
 class CDemoReader;
@@ -49,13 +47,14 @@
 public:
 	SFloat3 startpos;
 	bool readyToStart;
+	int allyTeam;
 };
 
 /**
 @brief Server class for game handling
 This class represents a gameserver. It is responsible for recieving, checking and forwarding gamedata to the clients. It keeps track of the sync, cpu and other stats and informs all clients about events.
 */
-class CGameServer : private ServerLog, public CommandReciever
+class CGameServer : public CommandReciever
 {
 	friend class CLoadSaveHandler;     //For initialize server state after load
 public:
@@ -88,8 +87,6 @@
 	bool gameClientUpdated;			//used to prevent the server part to update to fast when the client is mega slow (running some sort of debug mode)
 #endif
 	
-	ServerLogHandler log; //TODO make private and add public interface
-
 private:
 	/**
 	@brief catch commands from chat messages and handle them

Modified: branches/gml/rts/Game/GameSetup.cpp
===================================================================
--- branches/gml/rts/Game/GameSetup.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/GameSetup.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,6 +13,7 @@
 #include &quot;Lua/LuaGaia.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/Textures/TAPalette.h&quot;
 #include &quot;System/UnsyncedRNG.h&quot;
@@ -78,7 +79,7 @@
 void CGameSetup::LoadStartPositionsFromMap()
 {
 	TdfParser p2;
-	CReadMap::OpenTDF (mapName, p2);
+	CMapInfo::OpenTDF (mapName, p2);
 
 	for(int a=0;a&lt;numTeams;++a){
 		float x,z;
@@ -143,7 +144,7 @@
 			if (!zpos.empty())
 			{
 				gs-&gt;Team(a)-&gt;startPos.z = atoi(zpos.c_str());
-				startPos[a].y = gs-&gt;Team(a)-&gt;startPos.y;
+				startPos[a].z = gs-&gt;Team(a)-&gt;startPos.z;
 			}
 		}
 	}
@@ -165,8 +166,11 @@
 		sprintf(section, &quot;GAME\\PLAYER%i\\&quot;, a);
 		string s(section);
 
-		if (!file.SectionExist(s.substr(0, s.length() - 1)))
+		if (!file.SectionExist(s.substr(0, s.length() - 1))) {
+			// don't leave this uninitialized
+			playerStartingTeam[i] = 0;
 			continue;
+		}
 
 		// expects lines of form team=x rather than team=TEAMx
 		// team field is relocated in RemapTeams
@@ -226,6 +230,7 @@
 		gs-&gt;Team(i)-&gt;side = StringToLower(file.SGetValueDef(&quot;arm&quot;, s + &quot;side&quot;).c_str());
 		// allyteam field is relocated in RemapAllyteams
 		gs-&gt;SetAllyTeam(i, atoi(file.SGetValueDef(&quot;0&quot;, s + &quot;allyteam&quot;).c_str()));
+		teamAllyteam[i] = atoi(file.SGetValueDef(&quot;0&quot;, s + &quot;allyteam&quot;).c_str());
 
 		// Is this team (Lua) AI controlled?
 		// If this is a demo replay, non-Lua AIs aren't loaded.
@@ -324,6 +329,7 @@
 		if (allyteamRemap.find(gs-&gt;AllyTeam(a)) == allyteamRemap.end())
 			throw content_error(&quot;invalid Team.Allyteam in GameSetup script&quot;);
 		gs-&gt;SetAllyTeam(a, allyteamRemap[gs-&gt;AllyTeam(a)]);
+		teamAllyteam[a] = allyteamRemap[teamAllyteam[a]];
 	}
 
 	// relocate gs-&gt;allies matrix

Modified: branches/gml/rts/Game/GameSetupData.h
===================================================================
--- branches/gml/rts/Game/GameSetupData.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/GameSetupData.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -52,6 +52,7 @@
 	SFloat3 startPos[MAX_TEAMS];
 	bool readyTeams[MAX_TEAMS];
 	int teamStartNum[MAX_TEAMS];
+	int teamAllyteam[MAX_TEAMS];
 	float startRectTop[MAX_TEAMS];
 	float startRectBottom[MAX_TEAMS];
 	float startRectLeft[MAX_TEAMS];

Modified: branches/gml/rts/Game/PlayerRoster.cpp
===================================================================
--- branches/gml/rts/Game/PlayerRoster.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/PlayerRoster.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -238,8 +238,8 @@
 	}
 
 	// sort by player name
-	const string aName = StringToLower(aP-&gt;playerName);
-	const string bName = StringToLower(bP-&gt;playerName);
+	const std::string aName = StringToLower(aP-&gt;playerName);
+	const std::string bName = StringToLower(bP-&gt;playerName);
 	return strcmp(aName.c_str(), bName.c_str());
 }
 

Modified: branches/gml/rts/Game/PreGame.cpp
===================================================================
--- branches/gml/rts/Game/PreGame.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/PreGame.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -31,6 +31,7 @@
 #include &quot;StartScripts/ScriptHandler.h&quot;
 #include &quot;UI/InfoConsole.h&quot;
 #include &quot;UI/MouseHandler.h&quot;
+#include &quot;TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 
 // msvc behaves really strange
@@ -41,6 +42,8 @@
 }
 #endif
 
+const int springDefaultPort = 8452;
+
 CPreGame* pregame=0;
 
 extern Uint8 *keys;
@@ -48,6 +51,8 @@
 std::string stupidGlobalMapname;
 
 CglList* CPreGame::showList = 0;
+std::string CPreGame::userScript;
+std::string CPreGame::userMap;
 
 CPreGame::CPreGame(bool server, const string&amp; demo, const std::string&amp; save)
 : server(server),
@@ -55,8 +60,7 @@
   hasDemo(!demo.empty()),
   hasSave(!save.empty()),
   savefile(NULL),
-  gameData(0),
-  serverStartupData(0)
+  gameData(0)
 {
 	demoFile = gameSetup? gameSetup-&gt;demoName : demo;
 
@@ -79,27 +83,16 @@
 
 	if(server){
 		net-&gt;InitLocalClient(gameSetup ? gameSetup-&gt;myPlayerNum : 0);
-		serverStartupData = new GameData();
 		if(gameSetup){
-			CScriptHandler::SelectScript(gameSetup-&gt;scriptName);
-			SelectScript(gameSetup-&gt;scriptName);
-			if (!gameSetup-&gt;saveName.empty()) {
-				savefile = new CLoadSaveHandler();
-				savefile-&gt;LoadGameStartInfo(savefile-&gt;FindSaveFile(gameSetup-&gt;saveName.c_str()));
-			}
-			SelectMap(gameSetup-&gt;mapName);
-			SelectMod(gameSetup-&gt;baseMod);
+			StartServer(gameSetup-&gt;mapName, gameSetup-&gt;baseMod, gameSetup-&gt;scriptName);
 			state = WAIT_CONNECTING;
 		} else if (hasSave) {
 			savefile = new CLoadSaveHandler();
 			savefile-&gt;LoadGameStartInfo(savefile-&gt;FindSaveFile(save.c_str()));
-			CScriptHandler::SelectScript(&quot;Commanders&quot;);
-			SelectScript(&quot;Commanders&quot;);
-			SelectMap(gameSetup-&gt;mapName);
-			SelectMod(gameSetup-&gt;baseMod);
+			StartServer(gameSetup-&gt;mapName, gameSetup-&gt;baseMod, gameSetup-&gt;scriptName);
 			state = WAIT_CONNECTING;
 		} else {
-			ShowScriptList();
+			ShowMapList();
 			state = WAIT_ON_USERINPUT;
 		}
 	} else {
@@ -196,10 +189,10 @@
 			return 0;
 		}
 		else if(k==SDLK_LEFT) {
-			writingPos = max(0, min((int)userInput.length(), writingPos - 1));
+			writingPos = std::max(0, std::min((int)userInput.length(), writingPos - 1));
 		}
 		else if(k==SDLK_RIGHT) {
-			writingPos = max(0, min((int)userInput.length(), writingPos + 1));
+			writingPos = std::max(0, std::min((int)userInput.length(), writingPos + 1));
 		}
 		else if(k==SDLK_HOME) {
 			writingPos = 0;
@@ -297,7 +290,7 @@
 				break;
 
 			configHandler.SetString(&quot;address&quot;,userInput);
-			net-&gt;InitClient(userInput.c_str(),8452,0, 0);
+			net-&gt;InitClient(userInput.c_str(),springDefaultPort,0, 0);
 			state = WAIT_CONNECTING;
 			// fall trough
 		}
@@ -307,16 +300,6 @@
 		}
 
 		case WAIT_CONNECTING:
-			if ((server || hasDemo) &amp;&amp; !gameServer) {
-				good_fpu_control_registers(&quot;before CGameServer creation&quot;);
-				int myPort = gameSetup? gameSetup-&gt;hostport : 8452;
-				gameServer = new CGameServer(myPort, serverStartupData, gameSetup, demoFile);
-				if (gameSetup &amp;&amp; gameSetup-&gt;autohostport &gt; 0)
-					gameServer-&gt;AddAutohostInterface(gameSetup-&gt;autohostport);
-				gameServer-&gt;AddLocalClient();
-				good_fpu_control_registers(&quot;after CGameServer creation&quot;);
-			}
-
 			if (net-&gt;Connected())
 				state = WAIT_ON_GAMEDATA; // fall through
 			else
@@ -338,7 +321,7 @@
 				gs-&gt;players[gu-&gt;myPlayerNum]-&gt;StartSpectating();
 			LoadStartPicture(team-&gt;side);
 
-			game = SAFE_NEW CGame(gameData-&gt;GetMap(), modArchive, infoConsole);
+			game = SAFE_NEW CGame(gameData-&gt;GetMap(), modArchive, infoConsole, savefile);
 
 			if (savefile) {
 				savefile-&gt;LoadGame();
@@ -364,8 +347,90 @@
 	return true;
 }
 
+void CPreGame::StartServer(std::string map, std::string mod, std::string script)
+{
+	assert(!gameServer);
+	GameData* startupData = new GameData();
+	startupData-&gt;SetRandomSeed(static_cast&lt;unsigned&gt;(gu-&gt;usRandInt()));
+	bool mapHasStartscript = false;
+	if (!map.empty())
+	{
+		// would be better to use MapInfo here, but this doesn't work
+		LoadMap(map); // map into VFS
+		std::string mapDefFile;
+		const std::string extension = map.substr(map.length()-3);
+		if (extension == &quot;smf&quot;)
+			mapDefFile = std::string(&quot;maps/&quot;)+map.substr(0,map.find_last_of('.'))+&quot;.smd&quot;;
+		else if(extension == &quot;sm3&quot;)
+			mapDefFile = string(&quot;maps/&quot;)+map;
+		else
+			throw std::runtime_error(&quot;CPreGame::StartServer(): Unknown extension: &quot; + extension);
+
+		TdfParser mapDefParser(mapDefFile);
+		std::string mapWantedScript, scriptFile;
+		mapDefParser.GetDef(mapWantedScript, &quot;&quot;, &quot;MAP\\Script&quot;);
+		mapDefParser.GetDef(scriptFile, &quot;&quot;, &quot;MAP\\Scriptfile&quot;);
+		if (!scriptFile.empty())
+			CScriptHandler::Instance().LoadScriptFile(scriptFile);
+		if (!mapWantedScript.empty())
+		{
+			script = mapWantedScript;
+			mapHasStartscript = true;
+		}
+	}
+	startupData-&gt;SetScript(script);
+	// here we now the name of the script to use
+
+	try // to load the script 
+	{
+		CScriptHandler::SelectScript(script);
+		std::string scriptWantedMod;
+		scriptWantedMod = CScriptHandler::Instance().chosenScript-&gt;GetModName();
+		if (!scriptWantedMod.empty())
+			mod = scriptWantedMod;
+
+		LoadMod(mod);
+	}
+	catch (const std::runtime_error&amp; err) // script not found, so it may be in the modarchive?
+	{
+		LoadMod(mod); // new map into VFS
+		CScriptHandler::SelectScript(script);
+	}
+	// make sure s is a modname (because the same mod can be in different archives on different computers)
+	mod = archiveScanner-&gt;ModArchiveToModName(mod);
+	std::string modArchive = archiveScanner-&gt;ModNameToModArchive(mod);
+	startupData-&gt;SetMod(mod, archiveScanner-&gt;GetModChecksum(modArchive));
+	
+	if (!mapHasStartscript)
+	{
+		std::string mapFromScript = CScriptHandler::Instance().chosenScript-&gt;GetMapName();
+		if (!mapFromScript.empty() &amp;&amp; map != mapFromScript)
+		{
+			//TODO unload old map
+			LoadMap(mapFromScript, true);
+		}
+	}
+	startupData-&gt;SetMap(map, archiveScanner-&gt;GetMapChecksum(map));
+
+	if (gameSetup)
+		gameSetup-&gt;LoadStartPositions(); // only host needs to do this, because client will recieve startpos msg from server
+	
+	good_fpu_control_registers(&quot;before CGameServer creation&quot;);
+	int myPort = gameSetup? gameSetup-&gt;hostport : springDefaultPort;
+	gameServer = new CGameServer(myPort, startupData, gameSetup, demoFile);
+	if (gameSetup &amp;&amp; gameSetup-&gt;autohostport &gt; 0)
+		gameServer-&gt;AddAutohostInterface(gameSetup-&gt;autohostport);
+	gameServer-&gt;AddLocalClient();
+	good_fpu_control_registers(&quot;after CGameServer creation&quot;);
+}
+
 void CPreGame::UpdateClientNet()
 {
+	if (gameData)
+	{
+		logOutput.Print(&quot;Warning: game should have started before&quot;);
+		return;
+	}
 	if (!net-&gt;IsActiveConnection())
 	{
 		logOutput.Print(&quot;Server not reachable&quot;);
@@ -378,109 +443,16 @@
 	{
 		const unsigned char* inbuf = packet-&gt;data;
 		switch (inbuf[0]) {
-
-			case NETMSG_GAMEDATA: {
-				GameDataRecieved(packet);
-				break;
-			}
-
-			case NETMSG_MAPDRAW: {
-			} break;
-
-			case NETMSG_RANDSEED: {
-				gs-&gt;SetRandSeed(*((unsigned int*)&amp;inbuf[1]));
-				break;
-			}
-
-			case NETMSG_SYSTEMMSG:
-			case NETMSG_CHAT: {
-				// int player = inbuf[inbufpos + 2];
-				string s = (char*) (inbuf + 3);
-				logOutput.Print(s);
-			} break;
-
-			case NETMSG_STARTPOS: {
-				// copied from CGame
-				// unsigned player = inbuf[1];
-				int team = inbuf[2];
-				if(team&gt;=gs-&gt;activeTeams || team&lt;0 || !gameSetup){
-					logOutput.Print(&quot;Got invalid team num %i in startpos msg&quot;,team);
-				} else {
-					if(inbuf[3]!=2)
-						gameSetup-&gt;readyTeams[team]=!!inbuf[3];
-					gs-&gt;Team(team)-&gt;startPos.x=*(float*)&amp;inbuf[4];
-					gs-&gt;Team(team)-&gt;startPos.y=*(float*)&amp;inbuf[8];
-					gs-&gt;Team(team)-&gt;startPos.z=*(float*)&amp;inbuf[12];
-				}
-				break;
-			}
-
 			case NETMSG_SETPLAYERNUM: {
 				gu-&gt;myPlayerNum = inbuf[1];
 				logOutput.Print(&quot;Became player %i&quot;, gu-&gt;myPlayerNum);
 			} break;
-
-			case NETMSG_PLAYERNAME: {
-				gs-&gt;players[inbuf[2]]-&gt;playerName = (char*) (inbuf + 3);
-				gs-&gt;players[inbuf[2]]-&gt;readyToStart = true;
-				gs-&gt;players[inbuf[2]]-&gt;active = true;
-				if (net-&gt;GetDemoRecorder())
-					net-&gt;GetDemoRecorder()-&gt;SetMaxPlayerNum(inbuf[2]);
-			} break;
-
-			case NETMSG_QUIT: {
-				globalQuit = true;
+			case NETMSG_GAMEDATA: {
+				GameDataRecieved(packet);
+				delete packet;
+				return;
 				break;
 			}
-
-			case NETMSG_USER_SPEED: {
-			} break;
-			case NETMSG_INTERNAL_SPEED: {
-			} break;
-
-			case NETMSG_SENDPLAYERSTAT: {
-			} break;
-			
-			case NETMSG_TEAM: {
-				const int player = (int)inbuf[1];
-				const unsigned char action = inbuf[2];
-
-				switch (action)
-				{
-					case TEAMMSG_SELFD: {
-						break;
-					}
-					case TEAMMSG_GIVEAWAY: {
-						break;
-					}
-					case TEAMMSG_RESIGN: {
-						break;
-					}
-					case TEAMMSG_JOIN_TEAM: {
-						//TODO is this enought?
-						int newTeam = int(inbuf[3]);
-						gs-&gt;players[player]-&gt;team = newTeam;
-						if (gs-&gt;Team(newTeam)-&gt;leader == -1)
-							gs-&gt;Team(newTeam)-&gt;leader = player;
-						break;
-					}
-					default: {
-						logOutput.Print(&quot;Unknown action in NETMSG_TEAM (%i) from player %i&quot;, action, player);
-					}
-				}
-				break;
-			}
-
-			case NETMSG_PAUSE: {
-				// these can get into the network stream here -- Kloot
-				int playerNum = (int) inbuf[1];
-				bool paused = !!inbuf[2];
-				logOutput.Print(paused? &quot;player %i paused the game&quot;: &quot;player %i unpaused the game&quot;, playerNum);
-			} break;
-
-			case NETMSG_PLAYERINFO:
-				break;
-
 			default: {
 				logOutput.Print(&quot;Unknown net-msg recieved from CPreGame: %i&quot;, int(inbuf[0]));
 				break;
@@ -501,7 +473,11 @@
 	while ( (buf = scanner.GetData(static_cast&lt;float&gt;(INT_MAX))) ) {
 		if (buf-&gt;data[0] == NETMSG_GAMEDATA)
 		{
-			serverStartupData = new GameData(*buf);
+			GameData *data = new GameData(*buf);
+			good_fpu_control_registers(&quot;before CGameServer creation&quot;);
+			gameServer = new CGameServer(springDefaultPort, data, gameSetup, demoName);
+			gameServer-&gt;AddLocalClient();
+			good_fpu_control_registers(&quot;after CGameServer creation&quot;);
 			delete buf;
 			break;
 		}
@@ -513,13 +489,6 @@
 	}
 }
 
-/** Create a CglList for selecting the script. */
-void CPreGame::ShowScriptList()
-{
-	CglList* list = CScriptHandler::Instance().GenList(SelectScript);
-	showList = list;
-}
-
 /** Create a CglList for selecting the map. */
 void CPreGame::ShowMapList()
 {
@@ -547,6 +516,13 @@
 	showList = list;
 }
 
+/** Create a CglList for selecting the script. */
+void CPreGame::ShowScriptList()
+{
+	CglList* list = CScriptHandler::Instance().GenList(SelectScript);
+	showList = list;
+}
+
 /** Create a CglList for selecting the mod. */
 void CPreGame::ShowModList()
 {
@@ -570,38 +546,23 @@
 	showList = list;
 }
 
-void CPreGame::SelectScript(std::string s)
+void CPreGame::SelectMap(std::string s)
 {
+	if (s == &quot;Random map&quot;) {
+		s = pregame-&gt;showList-&gt;items[1 + gu-&gt;usRandInt() % (showList-&gt;items.size() - 1)];
+	}
 	delete showList;
 	showList = 0;
-	assert(pregame-&gt;serverStartupData);
-	pregame-&gt;serverStartupData-&gt;SetScript(s);
-	
-	// if the script specify a map, use this and don't ask the user
-	std::string map = CScriptHandler::Instance().chosenScript-&gt;GetMapName();
-	if (map == &quot;&quot;)
-		pregame-&gt;ShowMapList();
-	else
-		SelectMap(map);
+	userMap = s;
+	pregame-&gt;ShowScriptList();
 }
 
-void CPreGame::SelectMap(std::string s)
+void CPreGame::SelectScript(std::string s)
 {
-	if (s == &quot;Random map&quot;) {
-		s = pregame-&gt;showList-&gt;items[1 + gu-&gt;usRandInt() % (showList-&gt;items.size() - 1)];
-	}
 	delete showList;
 	showList = 0;
-	LoadMap(s);
-	if (gameSetup)
-		gameSetup-&gt;LoadStartPositions(); // only host needs to do this, because client will recieve startpos msg from server
-	pregame-&gt;serverStartupData-&gt;SetMap(s, archiveScanner-&gt;GetMapChecksum(s));
-	
-	std::string mod = CScriptHandler::Instance().chosenScript-&gt;GetModName();
-	if (mod == &quot;&quot;)
-		pregame-&gt;ShowModList();
-	else
-		SelectMod(mod);
+	userScript = s;
+	pregame-&gt;ShowModList();
 }
 
 void CPreGame::SelectMod(std::string s)
@@ -612,19 +573,15 @@
 	}
 	delete showList;
 	showList = 0;
-	LoadMod(s);
-	// make sure s is a modname (because the same mod can be in different archives on different computers)
-	s = archiveScanner-&gt;ModArchiveToModName(s);
-	std::string modArchive = archiveScanner-&gt;ModNameToModArchive(s);
-	pregame-&gt;serverStartupData-&gt;SetMod(s, archiveScanner-&gt;GetModChecksum(modArchive));
-	pregame-&gt;state = WAIT_CONNECTING; // last thing to set, so start server now
+	pregame-&gt;StartServer(userMap, s, userScript);
+	pregame-&gt;state = WAIT_CONNECTING;
 }
 
-void CPreGame::LoadMap(const std::string&amp; mapName)
+void CPreGame::LoadMap(const std::string&amp; mapName, const bool forceReload)
 {
 	static bool alreadyLoaded = false;
 	
-	if (!alreadyLoaded)
+	if (!alreadyLoaded || forceReload)
 	{
 		CFileHandler* f = SAFE_NEW CFileHandler(&quot;maps/&quot; + mapName);
 		if (!f-&gt;FileExists()) {
@@ -653,8 +610,10 @@
 		if (ars.empty())
 			throw content_error(&quot;Couldn't find any archives for mod '&quot; + modName + &quot;'&quot;);
 		for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
+		{
 			if (!hpiHandler-&gt;AddArchive(*i, false))
 				throw content_error(&quot;Couldn't load archive '&quot; + *i + &quot;' for mod '&quot; + modName + &quot;'.&quot;);
+		}
 	
 		// always load springcontent.sdz
 		hpiHandler-&gt;AddArchive(&quot;base/springcontent.sdz&quot;, false);
@@ -665,9 +624,8 @@
 void CPreGame::GameDataRecieved(RawPacket* packet)
 {
 	gameData = new GameData(*packet);
-	logOutput &lt;&lt; &quot;Using script &quot; &lt;&lt; gameData-&gt;GetScript() &lt;&lt; &quot;\n&quot;;
-	CScriptHandler::SelectScript(gameData-&gt;GetScript());
 	
+	gs-&gt;SetRandSeed(gameData-&gt;GetRandomSeed());
 	logOutput &lt;&lt; &quot;Using map &quot; &lt;&lt; gameData-&gt;GetMap() &lt;&lt; &quot;\n&quot;;
 	stupidGlobalMapname = gameData-&gt;GetMap();
 	
@@ -675,6 +633,9 @@
 		net-&gt;GetDemoRecorder()-&gt;SetName(gameData-&gt;GetMap());
 	LoadMap(gameData-&gt;GetMap());
 	archiveScanner-&gt;CheckMap(gameData-&gt;GetMap(), gameData-&gt;GetMapChecksum());
+
+	logOutput &lt;&lt; &quot;Using script &quot; &lt;&lt; gameData-&gt;GetScript() &lt;&lt; &quot;\n&quot;;
+	CScriptHandler::SelectScript(gameData-&gt;GetScript());
 	
 	logOutput &lt;&lt; &quot;Using mod &quot; &lt;&lt; gameData-&gt;GetMod() &lt;&lt; &quot;\n&quot;;
 	LoadMod(gameData-&gt;GetMod());

Modified: branches/gml/rts/Game/PreGame.h
===================================================================
--- branches/gml/rts/Game/PreGame.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/PreGame.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,6 +13,21 @@
 	class RawPacket;
 }
 
+/**
+ * @brief This controlls the game start
+ * 
+ * Before a game starts, this class does everything that needs to be done before.
+ * It basically goes like this:
+ * For servers:
+ * 1. Find out which map, script and mod to use
+ * 2. Start the server with this settings
+ * 3. continue with &quot;For clients&quot;
+ * 
+ * ForClients:
+ * 1. Connect to the server
+ * 2. Recieve GameData from server
+ * 3. Start the CGame with the information provided by server
+ * */
 class CPreGame : public CGameController
 {
 public:
@@ -24,6 +39,8 @@
 	bool Update();
 
 private:
+	void StartServer(std::string map, std::string mod, std::string script);
+	
 	/// reads out map, mod and script from demos (with or without a gameSetupScript)
 	void ReadDataFromDemo(const std::string&amp; demoName);
 
@@ -32,8 +49,8 @@
 
 	CInfoConsole* infoConsole;
 
+	void ShowMapList();
 	void ShowScriptList();
-	void ShowMapList();
 	void ShowModList();
 	static CglList* showList;
 	
@@ -41,9 +58,9 @@
 	static void SelectScript(std::string s);
 	static void SelectMap(std::string s);
 	static void SelectMod(std::string s);
-	
+	static std::string userScript, userMap;
 	/// Load map and dependend archives into archive scanner
-	static void LoadMap(const std::string&amp; mapName);
+	static void LoadMap(const std::string&amp; mapName, const bool forceReload = false);
 	
 	/// Map all required archives depending on selected mod(s)
 	static void LoadMod(const std::string&amp; modName);
@@ -69,9 +86,7 @@
 	We won't start until we recieved this
 	*/
 	const GameData* gameData;
-	
-	/// all the GameData (script, map, mod and checksums) needed to start the server
-	GameData* serverStartupData;
+
 	std::string modArchive;
 	std::string demoFile;
 	CLoadSaveHandler *savefile;

Modified: branches/gml/rts/Game/SelectedUnits.cpp
===================================================================
--- branches/gml/rts/Game/SelectedUnits.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/SelectedUnits.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -463,7 +463,7 @@
 					(guihandler-&gt;commands[guihandler-&gt;inCommand].id &lt; 0)))) {
 			bool myColor = true;
 			glColor4fv(cmdColors.buildBox);
-			list&lt;CBuilderCAI*&gt;::const_iterator bi;
+			std::list&lt;CBuilderCAI*&gt;::const_iterator bi;
 			for (bi = uh-&gt;builderCAIs.begin(); bi != uh-&gt;builderCAIs.end(); ++bi) {
 				CBuilderCAI* builder = *bi;
 				if (builder-&gt;owner-&gt;team == gu-&gt;myTeam) {

Modified: branches/gml/rts/Game/SelectedUnits.h
===================================================================
--- branches/gml/rts/Game/SelectedUnits.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/SelectedUnits.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -11,8 +11,6 @@
 #include &quot;Sim/Units/UnitSet.h&quot;
 class CFeature;
 
-using namespace std;
-
 class CSelectedUnits : public CObject
 {
 public:

Modified: branches/gml/rts/Game/SelectedUnitsAI.cpp
===================================================================
--- branches/gml/rts/Game/SelectedUnitsAI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/SelectedUnitsAI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -356,7 +356,7 @@
 	std::multimap&lt;float,int&gt; orderedUnits;
 	CreateUnitOrder(orderedUnits,player);
 
-	for(multimap&lt;float,int&gt;::iterator oi=orderedUnits.begin();oi!=orderedUnits.end();++oi){
+	for (std::multimap&lt;float,int&gt;::iterator oi=orderedUnits.begin();oi!=orderedUnits.end();++oi){
 		nextPos = MoveToPos(oi-&gt;second, nextPos, sd, c);
 	}
 }
@@ -373,7 +373,7 @@
 			if(range&lt;1)
 				range=2000;		//give weaponless units a long range to make them go to the back
 			float value=(ud-&gt;metalCost*60+ud-&gt;energyCost)/unit-&gt;maxHealth*range;
-			out.insert(pair&lt;float,int&gt;(value,*ui));
+			out.insert(std::pair&lt;float,int&gt;(value,*ui));
 		}
 	}
 }
@@ -573,8 +573,8 @@
 	}
 	const int allyTeam = gs-&gt;AllyTeam(p-&gt;team);
 
-	const float3 mins(min(pos0.x, pos1.x), 0.0f, min(pos0.z, pos1.z));
-	const float3 maxs(max(pos0.x, pos1.x), 0.0f, max(pos0.z, pos1.z));
+	const float3 mins(std::min(pos0.x, pos1.x), 0.0f, std::min(pos0.z, pos1.z));
+	const float3 maxs(std::max(pos0.x, pos1.x), 0.0f, std::max(pos0.z, pos1.z));
 
 	vector&lt;CUnit*&gt; tmpUnits = qf-&gt;GetUnitsExact(mins, maxs);
 


Property changes on: branches/gml/rts/Game/Server/MsgStrings.h
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: branches/gml/rts/Game/Server/ServerLog.cpp
===================================================================
--- branches/gml/rts/Game/Server/ServerLog.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Server/ServerLog.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,2 +0,0 @@
-#include &quot;ServerLog.h&quot;
-

Deleted: branches/gml/rts/Game/Server/ServerLog.h
===================================================================
--- branches/gml/rts/Game/Server/ServerLog.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Server/ServerLog.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,17 +0,0 @@
-#ifndef SERVERLOG_H_
-#define SERVERLOG_H_
-
-#include &lt;string&gt;
-
-/** @brief Interface for recieving server log messages
- * 
- * Subscibe with this class to ServerLogHandler
- * */
-class ServerLog
-{
-public:	
-	virtual void Message(const std::string&amp; message) {};
-	virtual void Warning(const std::string&amp; message) {};
-};
-
-#endif /*SERVERLOG_H_*/

Deleted: branches/gml/rts/Game/Server/ServerLogHandler.cpp
===================================================================
--- branches/gml/rts/Game/Server/ServerLogHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Server/ServerLogHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,56 +0,0 @@
-#include &quot;ServerLogHandler.h&quot;
-
-#include &quot;ServerLog.h&quot;
-
-ServerLogHandler::ServerLogHandler()
-{
-}
-
-ServerLogHandler::~ServerLogHandler()
-{
-}
-
-void ServerLogHandler::Subscribe(ServerLog* subscriber)
-{
-	subscribers.push_back(subscriber);
-}
-
-void ServerLogHandler::Unsubscribe(ServerLog* subscriber)
-{
-	for (logList::iterator it = subscribers.begin(); it != subscribers.end(); ++it)
-	{
-		if ((*it) == subscriber)
-		{
-			subscribers.erase(it);
-			return;
-		}
-	}
-	// silently ignore when not found
-}
-
-void ServerLogHandler::Message(const std::string&amp; text)
-{
-	for (logList::iterator it = subscribers.begin(); it != subscribers.end(); ++it)
-	{
-		(*it)-&gt;Message(text);
-	}
-}
-
-void ServerLogHandler::Message(const boost::format&amp; form)
-{
-	Message(str(form));
-}
-
-void ServerLogHandler::Warning(const std::string&amp; text)
-{
-	for (logList::iterator it = subscribers.begin(); it != subscribers.end(); ++it)
-	{
-		(*it)-&gt;Warning(text);
-	}
-}
-
-void ServerLogHandler::Warning(const boost::format&amp; form)
-{
-	Warning(str(form));
-}
-

Deleted: branches/gml/rts/Game/Server/ServerLogHandler.h
===================================================================
--- branches/gml/rts/Game/Server/ServerLogHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Server/ServerLogHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,33 +0,0 @@
-#ifndef SERVERLOGHANDLER_H_
-#define SERVERLOGHANDLER_H_
-
-#include &lt;string&gt;
-#include &lt;list&gt;
-
-#include &lt;boost/format.hpp&gt;
-
-class ServerLog;
-
-/** @brief Class for multicasting server messages
- * 
- * */
-class ServerLogHandler
-{
-public:
-	ServerLogHandler();
-	~ServerLogHandler();
-	
-	void Subscribe(ServerLog* subscriber);
-	void Unsubscribe(ServerLog* subscriber);
-	
-	void Message(const std::string&amp; text);
-	void Message(const boost::format&amp; form);
-	void Warning(const std::string&amp; text);
-	void Warning(const boost::format&amp; form);
-	
-private:
-	typedef std::list&lt;ServerLog*&gt; logList;
-	logList subscribers;
-};
-
-#endif /*SERVERLOGHANDLER_H_*/

Modified: branches/gml/rts/Game/StartScripts/AirScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/AirScript.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/StartScripts/AirScript.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -141,7 +141,7 @@
 				break;
 			}
 		}
-		timeOut=min(1,timeOut+1);
+		timeOut=std::min(1,timeOut+1);
 	}
 	if(timeOut&gt;0){
 		timeOut++;

Modified: branches/gml/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/StartScripts/CommanderScript.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -8,6 +8,7 @@
 #include &quot;Game/Team.h&quot;
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/Game.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
@@ -38,14 +39,14 @@
 		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
 
 		// make a map of all side names  (assumes contiguous sections)
-		std::map&lt;string, string&gt; sideMap;
+		std::map&lt;std::string, std::string&gt; sideMap;
 		char sideText[64];
 		for (int side = 0;
 				 SNPRINTF(sideText, sizeof(sideText), &quot;side%i&quot;, side),
 				 p.SectionExist(sideText); // the test
 				 side++) {
-			const string sideName =
-				StringToLower(p.SGetValueDef(&quot;arm&quot;, string(sideText) + &quot;\\name&quot;));
+			const std::string sideName =
+				StringToLower(p.SGetValueDef(&quot;arm&quot;, std::string(sideText) + &quot;\\name&quot;));
 			sideMap[sideName] = sideText;
 		}
 
@@ -69,11 +70,11 @@
 				globalAI-&gt;CreateGlobalAI(a, gameSetup-&gt;aiDlls[a].c_str());
 			}
 
-			std::map&lt;string, string&gt;::const_iterator it = sideMap.find(team-&gt;side);
+			std::map&lt;std::string, std::string&gt;::const_iterator it = sideMap.find(team-&gt;side);
 
 			if (it != sideMap.end()) {
-				const string&amp; sideSection = it-&gt;second;
-				const string cmdrType =
+				const std::string&amp; sideSection = it-&gt;second;
+				const std::string cmdrType =
 					StringToLower(p.SGetValueDef(&quot;armcom&quot;, sideSection + &quot;\\commander&quot;));
 
 				CUnit* unit = unitLoader.LoadUnit(cmdrType, team-&gt;startPos, a, false, 0, NULL);
@@ -91,13 +92,11 @@
 	}
 	else {
 		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
-		const string s0 =
-			StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
-		const string s1 =
-			StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
+		const std::string s0 = StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
+		const std::string s1 = StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
 
 		TdfParser p2;
-		CReadMap::OpenTDF(stupidGlobalMapname, p2);
+		CMapInfo::OpenTDF(stupidGlobalMapname, p2);
 
 		float x0, x1, z0, z1;
 		p2.GetDef(x0, &quot;1000&quot;, &quot;MAP\\TEAM0\\StartPosX&quot;);

Modified: branches/gml/rts/Game/StartScripts/CommanderScript2.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript2.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/StartScripts/CommanderScript2.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,8 +3,8 @@
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;TdfParser.h&quot;
 #include &quot;Game/Team.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
-
 #include &quot;mmgr.h&quot;
 
 extern std::string stupidGlobalMapname;
@@ -37,11 +37,11 @@
 		gs-&gt;Team(1)-&gt;metalStorage=1000;
 
 		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
-		string s0 = StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
-		string s1 = StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
+		std::string s0 = StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
+		std::string s1 = StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
 
 		TdfParser p2;
-		CReadMap::OpenTDF (stupidGlobalMapname, p2);
+		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
 
 		float x0,x1,z0,z1;
 		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM0\\StartPosX&quot;);

Modified: branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,6 +9,7 @@
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -41,11 +42,11 @@
 			gs-&gt;Team(1)-&gt;metalStorage = 1000;
 
 			TdfParser p(&quot;gamedata/sidedata.tdf&quot;);
-			string s0 = p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;);
-			string s1 = p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;);
+			std::string s0 = p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;);
+			std::string s1 = p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;);
 
 			TdfParser p2;
-			CReadMap::OpenTDF(stupidGlobalMapname, p2);
+			CMapInfo::OpenTDF(stupidGlobalMapname, p2);
 
 			float x0, x1, z0, z1;
 			p2.GetDef(x0, &quot;1000&quot;, &quot;MAP\\TEAM0\\StartPosX&quot;);

Modified: branches/gml/rts/Game/StartScripts/ScriptHandler.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/ScriptHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/StartScripts/ScriptHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,6 +6,7 @@
 #include &quot;ScriptHandler.h&quot;
 #include &quot;Game/Game.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;FileSystem/VFSHandler.h&quot;
 #include &quot;LoadScript.h&quot;
 #include &quot;CommanderScript.h&quot;
 #include &quot;CommanderScript2.h&quot;
@@ -58,10 +59,12 @@
 void CScriptHandler::StartLua()
 {
 #ifndef NO_LUA
-	std::vector&lt;string&gt; files = CFileHandler::FindFiles(&quot;startscripts/&quot;, &quot;*.lua&quot;);
-	for (std::vector&lt;string&gt;::iterator i = files.begin(); i != files.end(); ++i) {
+	std::vector&lt;std::string&gt; files = hpiHandler-&gt;GetFilesInDir(&quot;startscripts&quot;);
+	for (std::vector&lt;std::string&gt;::iterator i = files.begin(); i != files.end(); ++i) {
+		char buffer[16000];
+		const int returned = hpiHandler-&gt;LoadFile(std::string(&quot;startscripts/&quot;+*i), buffer);
 		CLuaBinder* lua = SAFE_NEW CLuaBinder();
-		if (!lua-&gt;LoadScript(*i))
+		if (!lua-&gt;LoadScript(*i, buffer, returned))
 			handleerror(NULL, lua-&gt;lastError.c_str(), &quot;Lua&quot;, MBF_OK|MBF_EXCL);
 		lua_binders.push_back(lua);
 	}
@@ -75,6 +78,7 @@
 	static CScriptHandler instance;
 	if( !created ) {
 		created = true;
+		instance.StartLua();
 		instance.LoadScripts();
 	}
 	return instance;
@@ -96,11 +100,26 @@
 }
 
 /** Called by the CScript constructors to add themselves to the CScriptHandler. */
-void CScriptHandler::AddScript(string name, CScript *s)
+void CScriptHandler::AddScript(std::string name, CScript *s)
 {
 	scripts[name] = s;
 }
 
+void CScriptHandler::LoadScriptFile(const std::string&amp; file)
+{
+	char buffer[16000];
+	const int returned = hpiHandler-&gt;LoadFile(std::string(&quot;startscripts/&quot;+file), buffer);
+	if (returned &gt; 0)
+	{
+		CLuaBinder* lua = SAFE_NEW CLuaBinder();
+		if (!lua-&gt;LoadScript(file, buffer, returned))
+			handleerror(NULL, lua-&gt;lastError.c_str(), &quot;Lua&quot;, MBF_OK|MBF_EXCL);
+		lua_binders.push_back(lua);
+	}
+	else
+		throw std::runtime_error(&quot;scriptfile not found: &quot; + file);
+}
+
 /** Called by the CglList generated by CScriptHandler::GenList on selection of a script. */
 void CScriptHandler::SelectScript(std::string s)
 {

Modified: branches/gml/rts/Game/StartScripts/ScriptHandler.h
===================================================================
--- branches/gml/rts/Game/StartScripts/ScriptHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/StartScripts/ScriptHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -21,7 +21,7 @@
 	CglList* GenList(ListSelectCallback callb);
 
 	void AddScript(std::string name,CScript* s);
-	void StartLua();
+	void LoadScriptFile(const std::string&amp; file);
 
 	static CScriptHandler&amp; Instance();
 
@@ -31,6 +31,7 @@
 #ifndef NO_LUA
 	std::list&lt;CLuaBinder*&gt; lua_binders;
 #endif
+	void StartLua();
 	std::map&lt;std::string,CScript*&gt; scripts; ///&lt; Maps script names to CScript pointers.
 	std::list&lt;CScript*&gt; loaded_scripts;     ///&lt; Scripts loaded and owned by CScriptHandler
 	static ListSelectCallback callback;

Modified: branches/gml/rts/Game/StartScripts/SpawnScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/SpawnScript.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/StartScripts/SpawnScript.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,6 +9,7 @@
 #include &lt;set&gt;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -32,11 +33,11 @@
 		LoadSpawns();
 
 		TdfParser p(&quot;gamedata/sidedata.tdf&quot;);
-		string s0=p.SGetValueDef(&quot;armcom&quot;,&quot;side0\\commander&quot;);
-		string s1=p.SGetValueDef(&quot;corcom&quot;,&quot;side1\\commander&quot;);
+		std::string s0=p.SGetValueDef(&quot;armcom&quot;,&quot;side0\\commander&quot;);
+		std::string s1=p.SGetValueDef(&quot;corcom&quot;,&quot;side1\\commander&quot;);
 
 		TdfParser p2;
-		CReadMap::OpenTDF (stupidGlobalMapname, p2);
+		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
 
 		float x0,z0;
 		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM0\\StartPosX&quot;);
@@ -152,7 +153,7 @@
 
 std::string CSpawnScript::LoadToken(CFileHandler&amp; file)
 {
-	string s;
+	std::string s;
 	char c;
 
 	while (!file.Eof()) {

Modified: branches/gml/rts/Game/StartScripts/SpawnScript.h
===================================================================
--- branches/gml/rts/Game/StartScripts/SpawnScript.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/StartScripts/SpawnScript.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,7 +7,6 @@
 #include &lt;vector&gt;
 #include &quot;FileSystem/FileHandler.h&quot;
 
-using namespace std;
 class CSpawnScript :
 	public CScript
 {
@@ -23,7 +22,7 @@
 
 	struct Spawn {
 		int frame;
-		string name;
+		std::string name;
 	};
 
 	std::list&lt;Spawn&gt; spawns;

Modified: branches/gml/rts/Game/Team.cpp
===================================================================
--- branches/gml/rts/Game/Team.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Team.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -255,9 +255,9 @@
 void CTeam::Died()
 {
 	if (leader &gt;= 0)
-		logOutput.Print(CMessages::Tr(&quot;Team%i(%s) is no more&quot;).c_str(), teamNum, gs-&gt;players[leader]-&gt;playerName.c_str());
+		logOutput.Print(CMessages::Tr(&quot;Team %i (%s) is no more&quot;).c_str(), teamNum, gs-&gt;players[leader]-&gt;playerName.c_str());
 	else
-		logOutput.Print(CMessages::Tr(&quot;Team%i is no more&quot;).c_str(), teamNum);
+		logOutput.Print(CMessages::Tr(&quot;Team %i is no more&quot;).c_str(), teamNum);
 	isDead = true;
 	luaCallIns.TeamDied(teamNum);
 	net-&gt;SendTeamDied(gu-&gt;myPlayerNum, teamNum);
@@ -307,8 +307,8 @@
 	for(int a=0; a &lt; gs-&gt;activeTeams; ++a){
 		if((a != teamNum) &amp;&amp; gs-&gt;AlliedTeams(teamNum,a)){
 			CTeam* team = gs-&gt;Team(a);
-			eShare += max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy);
-			mShare += max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal);
+			eShare += std::max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy);
+			mShare += std::max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal);
 		}
 	}
 
@@ -317,20 +317,20 @@
 	delayedMetalShare = 0;
 	delayedEnergyShare = 0;
 
-	const float eExcess = max(0.0f, energy - (energyStorage * energyShare));
-	const float mExcess = max(0.0f, metal  - (metalStorage  * metalShare));
+	const float eExcess = std::max(0.0f, energy - (energyStorage * energyShare));
+	const float mExcess = std::max(0.0f, metal  - (metalStorage  * metalShare));
 
 	float de=0,dm=0;
-	if(eShare&gt;0)
-		de=min(1.0f,eExcess/eShare);
-	if(mShare&gt;0)
-		dm=min(1.0f,mExcess/mShare);
+	if (eShare &gt; 0)
+		de = std::min(1.0f,eExcess/eShare);
+	if (mShare &gt; 0)
+		dm = std::min(1.0f,mExcess/mShare);
 
 	for(int a=0; a &lt; gs-&gt;activeTeams; ++a){
 		if((a != teamNum) &amp;&amp; gs-&gt;AlliedTeams(teamNum,a)){
 			CTeam* team = gs-&gt;Team(a);
 
-			const float edif = max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy) * de;
+			const float edif = std::max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy) * de;
 			energy -= edif;
 			energySent += edif;
 			currentStats.energySent += edif;
@@ -338,7 +338,7 @@
 			team-&gt;energyReceived += edif;
 			team-&gt;currentStats.energyReceived += edif;
 
-			const float mdif = max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal) * dm;
+			const float mdif = std::max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal) * dm;
 			metal -= mdif;
 			metalSent += mdif;
 			currentStats.metalSent += mdif;
@@ -368,9 +368,9 @@
 	CUnit::ChangeTeam(), hence it'd cause a random amount of the shared units
 	to be killed if the commander is among them. Also, &quot;.take&quot; would kill all
 	units once it transfered the commander. */
-	if(gs-&gt;gameMode==1 &amp;&amp; numCommanders&lt;=0 &amp;&amp; !gaia){
-		for(list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();++ui){
-			if((*ui)-&gt;team==teamNum &amp;&amp; !(*ui)-&gt;unitDef-&gt;isCommander)
+	if (gs-&gt;gameMode==1 &amp;&amp; numCommanders&lt;=0 &amp;&amp; !gaia){
+		for(std::list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();++ui){
+			if ((*ui)-&gt;team==teamNum &amp;&amp; !(*ui)-&gt;unitDef-&gt;isCommander)
 				(*ui)-&gt;KillUnit(true,false,0);
 		}
 		// Set to 1 to prevent above loop from being done every update.
@@ -433,7 +433,7 @@
 void CTeam::LeftLineage(CUnit* unit)
 {
 	if (gs-&gt;gameMode == 2 &amp;&amp; unit-&gt;id == this-&gt;lineageRoot) {
-		for(list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 			if ((*ui)-&gt;lineage == this-&gt;teamNum)
 				(*ui)-&gt;KillUnit(true, false, 0);
 		}

Modified: branches/gml/rts/Game/Team.h
===================================================================
--- branches/gml/rts/Game/Team.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/Team.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -28,6 +28,9 @@
 	bool UseEnergyUpkeep(float amount);
 	bool UseMetalUpkeep(float amount);
 	
+	void SetBaseMetalStorage(float storage) {metalStorage = storage;};
+	void SetBaseEnergyStorage(float storage) {energyStorage = storage;};
+	
 	void SelfDestruct();
 	void GiveEverythingTo(const unsigned toTeam);
 	

Modified: branches/gml/rts/Game/UI/CursorIcons.cpp
===================================================================
--- branches/gml/rts/Game/UI/CursorIcons.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/CursorIcons.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -212,7 +212,7 @@
 		case CMD_AUTOREPAIRLEVEL:
 */
 		default: {
-			map&lt;int, string&gt;::const_iterator it = customTypes.find(cmd);
+			std::map&lt;int, std::string&gt;::const_iterator it = customTypes.find(cmd);
 			if (it == customTypes.end()) {
 				return NULL;
 			}
@@ -220,7 +220,7 @@
 		}
 	}
 
-	map&lt;std::string, CMouseCursor *&gt;::const_iterator it;
+	std::map&lt;std::string, CMouseCursor *&gt;::const_iterator it;
 	it = mouse-&gt;cursorCommandMap.find(cursorName);
 	if (it != mouse-&gt;cursorCommandMap.end()) {
 		return it-&gt;second;
@@ -228,8 +228,3 @@
 	
 	return NULL;
 }
-
-
-
-
-

Modified: branches/gml/rts/Game/UI/EndGameBox.cpp
===================================================================
--- branches/gml/rts/Game/UI/EndGameBox.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/EndGameBox.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -306,8 +306,8 @@
 			maxy=std::max(stats[stat1].maxdif,stat2!=-1?stats[stat2].maxdif:0)/CTeam::statsPeriod;
 
 		int numPoints=stats[0].values[0].size();
-		float scalex=0.54f/max(1.0f,numPoints-1.0f);
-		float scaley=0.54f/maxy;
+		float scalex=0.54f / std::max(1.0f,numPoints-1.0f);
+		float scaley=0.54f / maxy;
 
 		for (int a = 0; a &lt; 5; ++a) {
 			font-&gt;glPrintAt(box.x1 + 0.12f, box.y1 + 0.07f + (a * 0.135f), 0.8f,

Modified: branches/gml/rts/Game/UI/GameInfo.cpp
===================================================================
--- branches/gml/rts/Game/UI/GameInfo.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/GameInfo.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,6 +9,7 @@
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/GameVersion.h&quot;
 #include &quot;Game/Team.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
@@ -170,10 +171,10 @@
 	values.push_back(gs-&gt;gameMode &gt; 0 ? true : false);
 
 	labels.push_back(&quot;Gravity:&quot;);
-	values.push_back(-(gs-&gt;gravity * GAME_SPEED * GAME_SPEED));
+	values.push_back(-(mapInfo-&gt;map.gravity * GAME_SPEED * GAME_SPEED));
 
 	labels.push_back(&quot;Tidal:&quot;);
-	values.push_back(readmap-&gt;tidalStrength);
+	values.push_back(mapInfo-&gt;map.tidalStrength);
 
 	labels.push_back(&quot;Min Wind:&quot;);
 	values.push_back(wind.GetMinWind());
@@ -194,7 +195,7 @@
 	values.push_back(buf);
 	
 	labels.push_back(&quot;Map Name:&quot;);
-	values.push_back(readmap-&gt;mapName.c_str());
+	values.push_back(mapInfo-&gt;map.name.c_str());
 
 	labels.push_back(&quot;Mod Name:&quot;);
 	values.push_back(modInfo.filename.c_str());

Modified: branches/gml/rts/Game/UI/GuiHandler.cpp
===================================================================
--- branches/gml/rts/Game/UI/GuiHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/GuiHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -22,6 +22,9 @@
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MetalMap.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/glFont.h&quot;
 #include &quot;Rendering/GL/glExtra.h&quot;
 #include &quot;Rendering/GL/glList.h&quot;
@@ -61,8 +64,7 @@
 
 
 CGuiHandler::CGuiHandler()
-: firstLayout(true),
-  inCommand(-1),
+: inCommand(-1),
   activeMousePress(false),
 	forceLayoutUpdate(false),
   defaultCmdMemory(-1),
@@ -82,12 +84,11 @@
 
 	LoadConfig(&quot;ctrlpanel.txt&quot;);
 
-  miniMapMarker = !!configHandler.GetInt(&quot;MiniMapMarker&quot;, 1);
+	miniMapMarker = !!configHandler.GetInt(&quot;MiniMapMarker&quot;, 1);
+	invertQueueKey = !!configHandler.GetInt(&quot;InvertQueueKey&quot;, 0);
 
-  invertQueueKey = !!configHandler.GetInt(&quot;InvertQueueKey&quot;, 0);
+	autoShowMetal = mapInfo-&gt;gui.autoShowMetal;
 
-	readmap-&gt;mapDefParser.GetDef(autoShowMetal, &quot;1&quot;, &quot;MAP\\autoShowMetal&quot;);
-
 	useStencil = false;
 	if (GLEW_NV_depth_clamp &amp;&amp; !!configHandler.GetInt(&quot;StencilBufferBits&quot;, 1)) {
 		GLint stencilBits;
@@ -154,7 +155,7 @@
 }
 
 
-static bool SafeAtoF(float&amp; var, const string&amp; value)
+static bool SafeAtoF(float&amp; var, const std::string&amp; value)
 {
 	char* endPtr;
 	const char* startPtr = value.c_str();
@@ -174,20 +175,20 @@
 	CFileHandler ifs(filename);
 	CSimpleParser parser(ifs);
 
-	string deadStr = &quot;&quot;;
-	string prevStr = &quot;&quot;;
-	string nextStr = &quot;&quot;;
-	string fillOrderStr = &quot;&quot;;
+	std::string deadStr = &quot;&quot;;
+	std::string prevStr = &quot;&quot;;
+	std::string nextStr = &quot;&quot;;
+	std::string fillOrderStr = &quot;&quot;;
 
 	while (true) {
-		const string line = parser.GetCleanLine();
+		const std::string line = parser.GetCleanLine();
 		if (line.empty()) {
 			break;
 		}
 
-		vector&lt;string&gt; words = parser.Tokenize(line, 1);
+		std::vector&lt;std::string&gt; words = parser.Tokenize(line, 1);
 
-		const string command = StringToLower(words[0]);
+		const std::string command = StringToLower(words[0]);
 
 		if ((command == &quot;dropshadows&quot;) &amp;&amp; (words.size() &gt; 1)) {
 			dropShadows = !!atoi(words[1].c_str());
@@ -270,12 +271,12 @@
 	}
 
 	// sane clamps
-	xIcons      = max(2,      xIcons);
-	yIcons      = max(2,      yIcons);
-	xIconSize   = max(0.010f, xIconSize);
-	yIconSize   = max(0.010f, yIconSize);
-	iconBorder  = max(0.0f,   iconBorder);
-	frameBorder = max(0.0f,   frameBorder);
+	xIcons      = std::max(2,      xIcons);
+	yIcons      = std::max(2,      yIcons);
+	xIconSize   = std::max(0.010f, xIconSize);
+	yIconSize   = std::max(0.010f, yIconSize);
+	iconBorder  = std::max(0.0f,   iconBorder);
+	frameBorder = std::max(0.0f,   frameBorder);
 
 	xIconStep = xIconSize + (iconBorder * 2.0f);
 	yIconStep = yIconSize + (iconBorder * 2.0f);
@@ -356,7 +357,7 @@
 		fillOrder.push_back(i);
 	}
 
-	// split the string into slot names
+	// split the std::string into slot names
 	std::vector&lt;std::string&gt; slotNames = CSimpleParser::Tokenize(text, 0);
 	if ((int)slotNames.size() != iconsPerPage) {
 		return;
@@ -400,7 +401,7 @@
 }
 
 
-bool CGuiHandler::ReloadConfig(const string&amp; filename)
+bool CGuiHandler::ReloadConfig(const std::string&amp; filename)
 {
 	LoadConfig(filename);
 	activePage = 0;
@@ -424,7 +425,7 @@
 }
 
 
-void CGuiHandler::AppendPrevAndNext(vector&lt;CommandDescription&gt;&amp; cmds)
+void CGuiHandler::AppendPrevAndNext(std::vector&lt;CommandDescription&gt;&amp; cmds)
 {
 	CommandDescription cd;
 
@@ -478,7 +479,7 @@
 			if (samePage) {
 				for (int ii = 0; ii &lt; iconsCount; ii++) {
 					if (inCommand == icons[ii].commandsID) {
-						activePage = min(maxPage, (ii / iconsPerPage));;
+						activePage = std::min(maxPage, (ii / iconsPerPage));;
 						selectedUnits.SetCommandPage(activePage);
 					}
 				}
@@ -513,13 +514,6 @@
 	commands.clear();
 	forceLayoutUpdate = false;
 
-	// try using the custom layout handler
-	if (firstLayout) {
-		firstLayout = false;
-		if (!!configHandler.GetInt(&quot;LuaUI&quot;, 0)) {
-			CLuaUI::LoadHandler();
-		}
-	}
 	if ((luaUI != NULL) &amp;&amp; luaUI-&gt;HasLayoutButtons()) {
 		if (LayoutCustomIcons(useSelectionPage)) {
 			if (validInCommand) {
@@ -538,8 +532,8 @@
 	ac = selectedUnits.GetAvailableCommands();
 	ConvertCommands(ac.commands);
 
-	vector&lt;CommandDescription&gt; hidden;
-	vector&lt;CommandDescription&gt;::const_iterator cdi;
+	std::vector&lt;CommandDescription&gt; hidden;
+	std::vector&lt;CommandDescription&gt;::const_iterator cdi;
 
 	// separate the visible/hidden icons
 	for (cdi = ac.commands.begin(); cdi != ac.commands.end(); ++cdi){
@@ -565,7 +559,7 @@
 	const int prevPageCmd = cmdCount + 0;
 	const int nextPageCmd = cmdCount + 1;
 
-	maxPage    = max(0, pageCount - 1);
+	maxPage    = std::max(0, pageCount - 1);
 	iconsCount = pageCount * iconsPerPage;
 
 	// resize the icon array if required
@@ -638,9 +632,9 @@
 	if (validInCommand) {
 		RevertToCmdDesc(cmdDesc, defCmd, samePage);
 	} else if (useSelectionPage) {
-		activePage = min(maxPage, ac.commandPage);
+		activePage = std::min(maxPage, ac.commandPage);
 	}
-	activePage = min(maxPage, activePage);
+	activePage = std::min(maxPage, activePage);
 }
 
 
@@ -653,7 +647,7 @@
 	// get the commands to process
 	CSelectedUnits::AvailableCommandsStruct ac;
 	ac = selectedUnits.GetAvailableCommands();
-	vector&lt;CommandDescription&gt; cmds = ac.commands;
+	std::vector&lt;CommandDescription&gt; cmds = ac.commands;
 	if (cmds.size() &gt; 0) {
 		ConvertCommands(cmds);
 		AppendPrevAndNext(cmds);
@@ -662,14 +656,14 @@
 	// call for a custom layout
 	int tmpXicons = xIcons;
 	int tmpYicons = yIcons;
-	vector&lt;int&gt; removeCmds;
-	vector&lt;CommandDescription&gt; customCmds;
-	vector&lt;int&gt; onlyTextureCmds;
-	vector&lt;CLuaUI::ReStringPair&gt; reTextureCmds;
-	vector&lt;CLuaUI::ReStringPair&gt; reNamedCmds;
-	vector&lt;CLuaUI::ReStringPair&gt; reTooltipCmds;
-	vector&lt;CLuaUI::ReParamsPair&gt; reParamsCmds;
-	map&lt;int, int&gt; iconMap;
+	std::vector&lt;int&gt; removeCmds;
+	std::vector&lt;CommandDescription&gt; customCmds;
+	std::vector&lt;int&gt; onlyTextureCmds;
+	std::vector&lt;CLuaUI::ReStringPair&gt; reTextureCmds;
+	std::vector&lt;CLuaUI::ReStringPair&gt; reNamedCmds;
+	std::vector&lt;CLuaUI::ReStringPair&gt; reTooltipCmds;
+	std::vector&lt;CLuaUI::ReParamsPair&gt; reParamsCmds;
+	std::map&lt;int, int&gt; iconMap;
 
 	if (!luaUI-&gt;LayoutButtons(tmpXicons, tmpYicons, cmds,
 	                          removeCmds, customCmds,
@@ -700,7 +694,7 @@
 		}
 	}
 	// remove unwanted commands  (and mark all as onlyKey)
-	vector&lt;CommandDescription&gt; tmpCmds;
+	std::vector&lt;CommandDescription&gt; tmpCmds;
 	for (i = 0; i &lt; cmds.size(); i++) {
 		if (removeIDs.find(i) == removeIDs.end()) {
 			cmds[i].onlyKey = true;
@@ -764,8 +758,8 @@
 	for (i = 0; i &lt; reParamsCmds.size(); i++) {
 		const int index = reParamsCmds[i].cmdIndex;
 		if ((index &gt;= 0) &amp;&amp; (index &lt; cmdCount)) {
-			const map&lt;int, string&gt;&amp; params = reParamsCmds[i].params;
-			map&lt;int, string&gt;::const_iterator pit;
+			const map&lt;int, std::string&gt;&amp; params = reParamsCmds[i].params;
+			map&lt;int, std::string&gt;::const_iterator pit;
 			for (pit = params.begin(); pit != params.end(); ++pit) {
 				const int p = pit-&gt;first;
 				if ((p &gt;= 0) &amp;&amp; (p &lt; (int)cmds[index].params.size())) {
@@ -779,7 +773,7 @@
 	}
 
 	// build the iconList from the map
-	vector&lt;int&gt; iconList;
+	std::vector&lt;int&gt; iconList;
 	int nextPos = 0;
 	map&lt;int, int&gt;::iterator mit;
 	for (mit = iconMap.begin(); mit != iconMap.end(); ++mit) {
@@ -846,11 +840,11 @@
 	iconsCount   = tmpIconsCount;
 	iconsPerPage = tmpIconsPerPage;
 
-	maxPage = max(0, pageCount - 1);
+	maxPage = std::max(0, pageCount - 1);
 	if (useSelectionPage) {
-		activePage = min(maxPage, ac.commandPage);
+		activePage = std::min(maxPage, ac.commandPage);
 	} else {
-		activePage = min(maxPage, activePage);
+		activePage = std::min(maxPage, activePage);
 	}
 
 	buttonBox.x1 = xPos;
@@ -882,7 +876,7 @@
 }
 
 
-void CGuiHandler::ConvertCommands(vector&lt;CommandDescription&gt;&amp; cmds)
+void CGuiHandler::ConvertCommands(std::vector&lt;CommandDescription&gt;&amp; cmds)
 {
 	if (newAttackMode) {
 		const int count = (int)cmds.size();
@@ -964,32 +958,30 @@
 
 void CGuiHandler::SetCursorIcon() const
 {
-	mouse-&gt;cursorText = &quot;&quot;;
+	string newCursor = &quot;cursornormal&quot;;
 	mouse-&gt;cursorScale = 1.0f;
 
 	CInputReceiver* ir = NULL;
-	if (!game-&gt;hideInterface) {
+	if (!game-&gt;hideInterface)
 		ir = GetReceiverAt(mouse-&gt;lastx, mouse-&gt;lasty);
-	}
 
 	if ((ir != NULL) &amp;&amp; (ir != minimap)) {
+		mouse-&gt;SetCursor(newCursor);
 		return;
 	}
 
-	if (ir == minimap) {
+	if (ir == minimap)
 		mouse-&gt;cursorScale = minimap-&gt;CursorScale();
-	}
 
-	const bool useMinimap =
-		(minimap-&gt;ProxyMode() || ((activeReceiver != this) &amp;&amp; (ir == minimap)));
+	const bool useMinimap = (minimap-&gt;ProxyMode() || ((activeReceiver != this) &amp;&amp; (ir == minimap)));
 
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand&lt;commands.size())) {
 		const CommandDescription&amp; cmdDesc = commands[inCommand];
 
 		if (!cmdDesc.mouseicon.empty()) {
-			mouse-&gt;cursorText = cmdDesc.mouseicon;
+			newCursor=cmdDesc.mouseicon;
 		} else {
-			mouse-&gt;cursorText = cmdDesc.name;
+			newCursor=cmdDesc.name;
 		}
 
 		if (useMinimap &amp;&amp; (cmdDesc.id &lt; 0)) {
@@ -1002,9 +994,9 @@
 			// does not consider it when checking for position blocking
 			CFeature* feature;
 			if(!uh-&gt;TestUnitBuildSquare(bi, feature, gu-&gt;myAllyTeam)) {
-				mouse-&gt;cursorText = &quot;BuildBad&quot;;
+				newCursor=&quot;BuildBad&quot;;
 			} else {
-				mouse-&gt;cursorText = &quot;BuildGood&quot;;
+				newCursor=&quot;BuildGood&quot;;
 			}
 		}
 	}
@@ -1019,16 +1011,17 @@
 		if ((defcmd &gt;= 0) &amp;&amp; (defcmd &lt; commands.size())) {
 			const CommandDescription&amp; cmdDesc = commands[defcmd];
 			if (!cmdDesc.mouseicon.empty()) {
-				mouse-&gt;cursorText = cmdDesc.mouseicon;
+				newCursor=cmdDesc.mouseicon;
 			} else {
-				mouse-&gt;cursorText = cmdDesc.name;
+				newCursor=cmdDesc.name;
 			}
 		}
 	}
 
-	if (gatherMode &amp;&amp; (mouse-&gt;cursorText == &quot;Move&quot;)) {
-		mouse-&gt;cursorText = &quot;GatherWait&quot;;
-	}
+	if (gatherMode &amp;&amp; (mouse-&gt;cursorText == &quot;Move&quot;))
+		newCursor = &quot;GatherWait&quot;;
+	
+	mouse-&gt;SetCursor(newCursor);
 }
 
 
@@ -1239,7 +1232,7 @@
 					&quot;Choose the AI you want to assign to this group.\n&quot;
 					&quot;Select \&quot;None\&quot; to cancel or \&quot;default\&quot; to create a group without an AI\n&quot;
 					&quot;assigned.&quot;;
-				vector&lt;string&gt;::const_iterator pi;
+				std::vector&lt;std::string&gt;::const_iterator pi;
 				for (pi = ++cd.params.begin(); pi != cd.params.end(); ++pi) {
 					list-&gt;AddItem(pi-&gt;c_str(),&quot;&quot;);
 				}
@@ -1327,8 +1320,8 @@
 
 	int xSlot = int((fx - (buttonBox.x1 + frameBorder)) / xIconStep);
 	int ySlot = int(((buttonBox.y2 - frameBorder) - fy) / yIconStep);
-	xSlot = min(max(xSlot, 0), xIcons - 1);
-	ySlot = min(max(ySlot, 0), yIcons - 1);
+	xSlot = std::min(std::max(xSlot, 0), xIcons - 1);
+	ySlot = std::min(std::max(ySlot, 0), yIcons - 1);
   const int ii = (activePage * iconsPerPage) + (ySlot * xIcons) + xSlot;
   if ((ii &gt;= 0) &amp;&amp; (ii &lt; iconsCount)) {
 		if ((fx &gt; icons[ii].selection.x1) &amp;&amp; (fx &lt; icons[ii].selection.x2) &amp;&amp;
@@ -1358,7 +1351,7 @@
 };
 
 
-static bool ParseCustomCmdMods(string&amp; cmd, ModGroup&amp; in, ModGroup&amp; out)
+static bool ParseCustomCmdMods(std::string&amp; cmd, ModGroup&amp; in, ModGroup&amp; out)
 {
 	const char* c = cmd.c_str();
 	if (*c != '@') {
@@ -1415,7 +1408,7 @@
 }
 
 
-void CGuiHandler::RunCustomCommands(const vector&lt;string&gt;&amp; cmds, bool rmb)
+void CGuiHandler::RunCustomCommands(const std::vector&lt;std::string&gt;&amp; cmds, bool rmb)
 {
 	static int depth = 0;
 	if (depth &gt; 8) {
@@ -1424,7 +1417,7 @@
 	depth++;
 
 	for (int p = 0; p &lt; (int)cmds.size(); p++) {
-		string copy = cmds[p];
+		std::string copy = cmds[p];
 		ModGroup inMods;  // must match for the action to execute
 		ModGroup outMods; // controls the state of the modifiers  (ex: &quot;group1&quot;)
 		if (ParseCustomCmdMods(copy, inMods, outMods)) {
@@ -1509,7 +1502,7 @@
 	if (cd.params.size() &gt;= 2) { maxV = atof(cd.params[1].c_str()); }
 	const int minX = (gu-&gt;viewSizeX * 1) / 4;
 	const int maxX = (gu-&gt;viewSizeX * 3) / 4;
-	const int effX = max(min(mouse-&gt;lastx, maxX), minX);
+	const int effX = std::max(std::min(mouse-&gt;lastx, maxX), minX);
 	const float factor = float(effX - minX) / float(maxX - minX);
 
 	return (minV + (factor * (maxV - minV)));
@@ -1608,7 +1601,7 @@
 		const int iconPos = IconAtPos(mouse-&gt;lastx, mouse-&gt;lasty);
 		const int iconCmd = (iconPos &gt;= 0) ? icons[iconPos].commandsID : -1;
 		if ((iconCmd &gt;= 0) &amp;&amp; (iconCmd &lt; commands.size())) {
-			string cmd = &quot;unbindaction &quot; + commands[iconCmd].action;
+			std::string cmd = &quot;unbindaction &quot; + commands[iconCmd].action;
 			keyBindings-&gt;Command(cmd);
 			logOutput.Print(&quot;%s&quot;, cmd.c_str());
 		}
@@ -1653,7 +1646,7 @@
 }
 
 
-void CGuiHandler::RunLayoutCommand(const string&amp; command)
+void CGuiHandler::RunLayoutCommand(const std::string&amp; command)
 {
 	if (command.find(&quot;reload&quot;) == 0) {
 		if (CLuaHandle::GetActiveHandle() != NULL) {
@@ -1706,7 +1699,7 @@
 
 bool CGuiHandler::ProcessBuildActions(const Action&amp; action)
 {
-	const string arg = StringToLower(action.extra);
+	const std::string arg = StringToLower(action.extra);
 	if (action.command == &quot;buildspacing&quot;) {
 		if (arg == &quot;inc&quot;) {
 			buildSpacing++;
@@ -1865,7 +1858,7 @@
 				 (cmdType == CMDTYPE_ICON_BUILDING))) {
 			for (int ii = 0; ii &lt; iconsCount; ii++) {
 				if (icons[ii].commandsID == a) {
-					activePage = min(maxPage, (ii / iconsPerPage));
+					activePage = std::min(maxPage, (ii / iconsPerPage));
 					selectedUnits.SetCommandPage(activePage);
 				}
 			}
@@ -1893,7 +1886,7 @@
 						c.options = RIGHT_MOUSE_KEY | SHIFT_KEY | CONTROL_KEY;
 					}
 				}
-				else if (action.extra.find(&quot;queued&quot;) != string::npos) {
+				else if (action.extra.find(&quot;queued&quot;) != std::string::npos) {
 					c.options |= SHIFT_KEY;
 				}
 				GiveCommand(c);
@@ -1933,10 +1926,10 @@
 					float maxV = 100.0f;
 					if (cd.params.size() &gt;= 1) { minV = atof(cd.params[0].c_str()); }
 					if (cd.params.size() &gt;= 2) { maxV = atof(cd.params[1].c_str()); }
-					value = max(min(value, maxV), minV);
+					value = std::max(std::min(value, maxV), minV);
 					Command c;
 					c.options = 0;
-					if (action.extra.find(&quot;queued&quot;) != string::npos) {
+					if (action.extra.find(&quot;queued&quot;) != std::string::npos) {
 						c.options = SHIFT_KEY;
 					}
 					c.id = cd.id;
@@ -1973,7 +1966,7 @@
 			case CMDTYPE_COMBO_BOX:
 			if (GetInputReceivers().empty() || dynamic_cast&lt;CglList*&gt;(GetInputReceivers().front()) == NULL) {
 				CommandDescription&amp; cd = cmdDesc;
-				vector&lt;string&gt;::iterator pi;
+				std::vector&lt;std::string&gt;::iterator pi;
 				// check for an action bound to a specific entry
 				if (!action.extra.empty() &amp;&amp; (iconCmd &lt; 0)) {
 					int p = 0;
@@ -2049,7 +2042,7 @@
 }
 
 
-void CGuiHandler::MenuChoice(string s)
+void CGuiHandler::MenuChoice(std::string s)
 {
 	if (activeReceiver == list) {
 		activeReceiver = NULL;
@@ -2062,7 +2055,7 @@
 		switch (cd.type) {
 			case CMDTYPE_COMBO_BOX: {
 				inCommand = -1;
-				vector&lt;string&gt;::iterator pi;
+				std::vector&lt;std::string&gt;::iterator pi;
 				int a = 0;
 				for (pi = ++cd.params.begin(); pi != cd.params.end(); ++pi) {
 					if (*pi == s) {
@@ -2108,7 +2101,7 @@
 
 std::string CGuiHandler::GetTooltip(int x, int y)
 {
-	string s;
+	std::string s;
 	if (luaUI != NULL) {
 		s = luaUI-&gt;GetTooltip(x, y);
 		if (!s.empty()) {
@@ -2377,7 +2370,7 @@
 					return defaultRet;
 				}
 				float3 pos2=camera-&gt;pos+mouse-&gt;dir*dist;
-				c.params.push_back(min(maxRadius,pos.distance2D(pos2)));
+				c.params.push_back(std::min(maxRadius,pos.distance2D(pos2)));
 			}
 			CreateOptions(c,(button==SDL_BUTTON_LEFT?0:1));
 			return c;}
@@ -2600,7 +2593,7 @@
 }
 
 
-static string StripColorCodes(const string&amp; text)
+static std::string StripColorCodes(const std::string&amp; text)
 {
 	std::string nocolor;
 	const int len = (int)text.size();
@@ -2615,14 +2608,14 @@
 }
 
 
-static string FindCornerText(const string&amp; corner, const vector&lt;string&gt;&amp; params)
+static std::string FindCornerText(const std::string&amp; corner, const vector&lt;std::string&gt;&amp; params)
 {
 	for (int p = 0; p &lt; (int)params.size(); p++) {
 		if (params[p].find(corner) == 0) {
 			return params[p].substr(corner.length());
 		}
 	}
-	return string(&quot;&quot;);
+	return std::string(&quot;&quot;);
 }
 
 
@@ -2684,8 +2677,8 @@
 }
 
 
-static inline bool ParseTextures(const string&amp; texString,
-                                 string&amp; tex1, string&amp; tex2,
+static inline bool ParseTextures(const std::string&amp; texString,
+                                 std::string&amp; tex1, std::string&amp; tex2,
                                  float&amp; xscale, float&amp; yscale)
 {
 	// format:  &quot;&amp;&lt;xscale&gt;x&lt;yscale&gt;&amp;&lt;tex&gt;1&amp;&lt;tex2&gt;&quot;  --  &lt;&gt;'s are not included
@@ -2705,13 +2698,13 @@
 	const int tex1Len = c - tex1Start;
 	c++;
 	tex1 = c; // draw 'tex2' first
-	tex2 = string(tex1Start, tex1Len);
+	tex2 = std::string(tex1Start, tex1Len);
 
 	return true;
 }
 
 
-static inline bool BindUnitTexByString(const string&amp; str)
+static inline bool BindUnitTexByString(const std::string&amp; str)
 {
 	char* endPtr;
 	const char* startPtr = str.c_str() + 1; // skip the '#'
@@ -2734,7 +2727,7 @@
 }
 
 
-static bool BindTextureString(const string&amp; str)
+static bool BindTextureString(const std::string&amp; str)
 {
 	if (str[0] == '#') {
 		return BindUnitTexByString(str);
@@ -2750,8 +2743,8 @@
 		return false;
 	}
 
-	string tex1;
-	string tex2;
+	std::string tex1;
+	std::string tex2;
 	float xscale = 1.0f;
 	float yscale = 1.0f;
 
@@ -2845,7 +2838,7 @@
 	const float textBorder2 = (2.0f * textBorder);
 	float xScale = (xIconSize - textBorder2) / tWidth;
 	float yScale = (yIconSize - textBorder2 - yShrink) / tHeight;
-	const float fontScale = min(xScale, yScale);
+	const float fontScale = std::min(xScale, yScale);
 
 	const float xCenter = 0.5f * (b.x1 + b.x2);
 	const float yCenter = 0.5f * (b.y1 + (b.y2 + yShrink));
@@ -2903,7 +2896,7 @@
 	const float fontScale = (yIconSize * 0.2f) / tHeight;
 	const float xPos = b.x2 - textBorder - (fontScale * tWidth) - 0.002f;
 	const float yPos = b.y1 - textBorder - (fontScale * tHeight) - 0.006f;
-	
+
 	font-&gt;glPrintColorAt(xPos, yPos, fontScale, text.c_str());
 }
 
@@ -2965,8 +2958,8 @@
 	}
 
 	const int mouseIcon   = IconAtPos(mouse-&gt;lastx, mouse-&gt;lasty);
-	const int buttonStart = min(iconsCount, activePage * iconsPerPage);
-	const int buttonEnd   = min(iconsCount, buttonStart + iconsPerPage);
+	const int buttonStart = std::min(iconsCount, activePage * iconsPerPage);
+	const int buttonEnd   = std::min(iconsCount, buttonStart + iconsPerPage);
 
 	for (int ii = buttonStart; ii &lt; buttonEnd; ii++) {
 
@@ -3046,8 +3039,9 @@
 			// draw the text
 			if (!usedTexture || !onlyTexture) {
 				// command name (or parameter)
-				string toPrint = cmdDesc.name;
-				if (cmdDesc.type == CMDTYPE_ICON_MODE) {
+				std::string toPrint = cmdDesc.name;
+				if (cmdDesc.type == CMDTYPE_ICON_MODE
+						&amp;&amp; cmdDesc.params.size() &gt;= 1) {
 					const int opt = atoi(cmdDesc.params[0].c_str()) + 1;
 					if (opt &lt; cmdDesc.params.size()) {
 						toPrint = cmdDesc.params[opt];
@@ -3190,7 +3184,7 @@
 			glDisable(GL_TEXTURE_2D);
 			glColor4f(1.0f, 1.0f, 1.0f, 0.8f);
 			const float mouseX = (float)mouse-&gt;lastx / (float)gu-&gt;viewSizeX;
-			const float slideX = min(max(mouseX, 0.25f), 0.75f);
+			const float slideX = std::min(std::max(mouseX, 0.25f), 0.75f);
 			//const float mouseY = 1.0f - (float)(mouse-&gt;lasty - 16) / (float)gu-&gt;viewSizeY;
 			glColor4f(1.0f, 1.0f, 0.0f, 0.8f);
 			glRectf(0.235f, 0.45f, 0.25f, 0.55f);
@@ -3496,7 +3490,7 @@
 								color = grey;
 							}
 						}
-						const float radius = min(maxRadius, pos.distance2D(pos2));
+						const float radius = std::min(maxRadius, pos.distance2D(pos2));
 						if (!onMinimap) {
 							DrawArea(pos, radius, color);
 						}
@@ -3995,7 +3989,7 @@
 	pos1 += (pos1 - pos2);
 	const int maxSteps = 256;
 	const float frontLen = (pos1 - pos2).Length2D();
-	const int steps = min(maxSteps, max(1, int(frontLen / 16.0f)));
+	const int steps = std::min(maxSteps, std::max(1, int(frontLen / 16.0f)));
 
 	glDisable(GL_FOG);
 	glBegin(GL_QUAD_STRIP);
@@ -4011,11 +4005,6 @@
 	}
 	glEnd();
 
-	if(sizeDiv!=0){
-		char c[40];
-		SNPRINTF(c, 40, &quot;%d&quot;, (int)(frontLen / sizeDiv) );
-		mouse-&gt;cursorTextRight=c;
-	}
 	glEnable(GL_FOG);
 }
 
@@ -4089,10 +4078,10 @@
                                  bool invColorSelect)
 {
 	BoxData boxData;
-	boxData.mins = float3(min(pos0.x, pos1.x), readmap-&gt;minheight - 250.0f,
-                        min(pos0.z, pos1.z));
-	boxData.maxs = float3(max(pos0.x, pos1.x), readmap-&gt;maxheight + 10000.0f,
-	                      max(pos0.z, pos1.z));
+	boxData.mins = float3(std::min(pos0.x, pos1.x), readmap-&gt;minheight - 250.0f,
+                        std::min(pos0.z, pos1.z));
+	boxData.maxs = float3(std::max(pos0.x, pos1.x), readmap-&gt;maxheight + 10000.0f,
+	                      std::max(pos0.z, pos1.z));
 
 	glDisable(GL_TEXTURE_2D);
 	glDisable(GL_FOG);
@@ -4164,10 +4153,10 @@
 		return;
 	}
 
-	const float3 mins(min(pos0.x, pos1.x), readmap-&gt;minheight - 250.0f,
-	                  min(pos0.z, pos1.z));
-	const float3 maxs(max(pos0.x, pos1.x), readmap-&gt;maxheight + 10000.0f,
-	                  max(pos0.z, pos1.z));
+	const float3 mins(std::min(pos0.x, pos1.x), readmap-&gt;minheight - 250.0f,
+	                  std::min(pos0.z, pos1.z));
+	const float3 maxs(std::max(pos0.x, pos1.x), readmap-&gt;maxheight + 10000.0f,
+	                  std::max(pos0.z, pos1.z));
 
 	glDisable(GL_TEXTURE_2D);
 	glDisable(GL_FOG);

Modified: branches/gml/rts/Game/UI/GuiHandler.h
===================================================================
--- branches/gml/rts/Game/UI/GuiHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/GuiHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -45,15 +45,15 @@
 		                                   const BuildInfo&amp; endInfo);
 		                                   // start.def has to be end.def
 
-		bool ReloadConfig(const string&amp; filename);
+		bool ReloadConfig(const std::string&amp; filename);
 
 		void ForceLayoutUpdate() { forceLayoutUpdate = true; }
 
 		int GetMaxPage()    const { return maxPage; }
 		int GetActivePage() const { return activePage; }
 
-		void RunLayoutCommand(const string&amp; command);
-		void RunCustomCommands(const vector&lt;string&gt;&amp; cmds, bool rmb);
+		void RunLayoutCommand(const std::string&amp; command);
+		void RunCustomCommands(const std::vector&lt;std::string&gt;&amp; cmds, bool rmb);
 
  		bool GetInvertQueueKey() const { return invertQueueKey; }
  		void SetInvertQueueKey(bool value) { invertQueueKey = value; }
@@ -71,7 +71,7 @@
 		bool SetActiveCommand(const Action&amp; action, const CKeySet&amp; ks, int actionIndex);
 
 	public:
-		vector&lt;CommandDescription&gt; commands;
+		std::vector&lt;CommandDescription&gt; commands;
 		int inCommand;
 		int buildFacing;
 		int buildSpacing;
@@ -79,14 +79,14 @@
 	private:
 		void GiveCommand(const Command&amp; cmd, bool fromUser = true) const;
 
-		void MenuChoice(string s);
+		void MenuChoice(std::string s);
 		static void MenuSelection(std::string s);
 
 		void LayoutIcons(bool useSelectionPage);
 		bool LayoutCustomIcons(bool useSelectionPage);
 		void ResizeIconArray(unsigned int size);
-		void AppendPrevAndNext(vector&lt;CommandDescription&gt;&amp; cmds);
- 		void ConvertCommands(vector&lt;CommandDescription&gt;&amp;);
+		void AppendPrevAndNext(std::vector&lt;CommandDescription&gt;&amp; cmds);
+ 		void ConvertCommands(std::vector&lt;CommandDescription&gt;&amp;);
 
 		int  FindInCommandPage();
 		void RevertToCmdDesc(const CommandDescription&amp; cmdDesc,
@@ -144,7 +144,6 @@
 		int  ParseIconSlot(const std::string&amp; text) const;
 
 	private:
-		bool firstLayout;
 		bool needShift;
 		bool showingMetal;
 		bool autoShowMetal;

Copied: branches/gml/rts/Game/UI/HwMouseCursor.cpp (from rev 5882, trunk/rts/Game/UI/HwMouseCursor.cpp)
===================================================================
--- branches/gml/rts/Game/UI/HwMouseCursor.cpp	                        (rev 0)
+++ branches/gml/rts/Game/UI/HwMouseCursor.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,543 @@
+#include &quot;StdAfx.h&quot;
+#include &quot;bitops.h&quot;
+#include &quot;CommandColors.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;FileSystem/SimpleParser.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;MouseCursor.h&quot;
+#include &quot;HwMouseCursor.h&quot;
+#include &quot;myMath.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;mmgr.h&quot;
+#include &lt;SDL_syswm.h&gt;
+
+#ifdef WIN32
+	#include &quot;windows.h&quot;
+	#include &quot;MouseInput.h&quot;
+#elif defined(__APPLE__)
+	/*do nothing (duno how to create cursors on runtime on macs)*/
+#else
+	#include &lt;X11/Xcursor/Xcursor.h&gt;
+#endif
+
+//int savedcount=0;
+
+//////////////////////////////////////////////////////////////////////
+// Platform dependent classes
+//////////////////////////////////////////////////////////////////////
+
+#ifdef __APPLE__
+// no hardware cursor support for mac's
+class CHwDummyCursor : public IHwCursor {
+	public:
+		void PushImage(int xsize, int ysize, void* mem){};
+		void SetDelay(float delay){};
+		void PushFrame(int index, float delay){};
+		void Finish(){};
+
+		bool needsYFlip() {return false;};
+
+		bool IsValid(){return false;};
+		void Bind(){};
+};
+#elif defined(WIN32)
+class CHwWinCursor : public IHwCursor {
+	public:
+		CHwWinCursor(void);
+		~CHwWinCursor(void);
+
+		void PushImage(int xsize, int ysize, void* mem);
+		void SetDelay(float delay);
+		void PushFrame(int index, float delay);
+		void Finish();
+
+		bool needsYFlip() {return true;};
+
+		void Bind();
+
+		bool IsValid() {return (cursor!=NULL);};
+	protected:
+		HCURSOR cursor;
+
+		struct CursorDirectoryHeader {
+			byte  xsize,ysize,ncolors,reserved1;
+			short hotx,hoty;
+			DWORD size,offset;
+		};
+
+		struct CursorInfoHeader {
+			DWORD size,width,height;
+			WORD  planes, bpp;
+			DWORD res1,res2,res3,res4,res5,res6;
+		};
+
+		struct AnihStructure {
+			DWORD size,images,frames,width,height,bpp,planes,rate,flags;
+		};
+
+	protected:
+		struct ImageData {
+			unsigned char* data;
+			int width,height;
+		};
+
+		void buildIco(unsigned char* dst, ImageData &amp;image);
+		void resizeImage(ImageData *image, int new_x, int new_y);
+
+		int xmaxsize, ymaxsize;
+		short hotx, hoty;
+
+		byte image_count;
+
+		std::vector&lt;ImageData&gt; icons;
+		std::vector&lt;byte&gt;  frames;
+		std::vector&lt;int&gt;   framerates;
+};
+#else
+class CHwX11Cursor : public IHwCursor {
+	public:
+		CHwX11Cursor(void);
+		~CHwX11Cursor(void);
+
+		void PushImage(int xsize, int ysize, void* mem);
+		void SetDelay(float delay);
+		void PushFrame(int index, float delay);
+		void Finish();
+
+		bool needsYFlip() {return false;};
+
+		bool IsValid() {return (cursor!=0);};
+		void Bind();
+	protected:
+		int xmaxsize, ymaxsize;
+
+		void resizeImage(XcursorImage*&amp; image, const int new_x, const int new_y);
+
+		Cursor cursor;
+		std::vector&lt;XcursorImage*&gt; cimages;
+};
+#endif
+
+//////////////////////////////////////////////////////////////////////
+// GetHwCursor()
+//////////////////////////////////////////////////////////////////////
+
+IHwCursor* GetNewHwCursor()
+{
+#ifdef WIN32
+	return SAFE_NEW CHwWinCursor();
+#elif defined(__APPLE__)
+	return SAFE_NEW CHwDummyCursor();
+#else
+	return SAFE_NEW CHwX11Cursor();
+#endif
+}
+
+
+//////////////////////////////////////////////////////////////////////
+// Implementation 
+//////////////////////////////////////////////////////////////////////
+
+
+#ifdef __APPLE__
+	// no hardware cursor support for mac's
+#elif defined(WIN32)
+
+void CHwWinCursor::PushImage(int xsize, int ysize, void* mem)
+{
+	xmaxsize=std::max(xmaxsize,xsize);
+	ymaxsize=std::max(ymaxsize,ysize);
+
+	ImageData icon;
+	icon.data = new unsigned char[xsize*ysize*4];
+	icon.width = xsize;
+	icon.height = ysize;
+	memcpy(icon.data,mem,xsize*ysize*4);
+
+	icons.push_back(icon);
+
+	frames.push_back(image_count);
+	framerates.push_back(std::max((int)(defFrameLength*60.0f),1));
+	image_count++;
+}
+
+void CHwWinCursor::SetDelay(float delay)
+{
+	int &amp;last_item = framerates.back();
+	last_item = std::max((int)(delay*60.0f),1);
+}
+
+void CHwWinCursor::PushFrame(int index, float delay)
+{
+	if (index&gt;=image_count)
+		return;
+
+	frames.push_back((byte)index);
+	framerates.push_back(std::max((int)(delay*60.0f),1));
+}
+
+void CHwWinCursor::resizeImage(ImageData *image, int new_x, int new_y)
+{
+	if (image-&gt;width==new_x &amp;&amp; image-&gt;height==new_y)
+		return;
+
+	unsigned char* newdata = new unsigned char[new_x*new_y*4];
+	memset(newdata, 0, new_x*new_y*4);
+
+	for (int y = 0; y &lt; image-&gt;height; ++y)
+		for (int x = 0; x &lt; image-&gt;width; ++x)
+			for (int v = 0; v &lt; 4; ++v)
+				newdata[((y + (new_y-image-&gt;height))*new_x+x)*4+v] = image-&gt;data[(y*image-&gt;width+x)*4+v];
+
+	delete[] image-&gt;data;
+
+	image-&gt;data = newdata;
+
+	image-&gt;width  = new_x;
+	image-&gt;height = new_y;
+}
+
+void CHwWinCursor::buildIco(unsigned char* dst, ImageData &amp;image)
+{
+	const int xsize = image.width;
+	const int ysize = image.height;
+
+	//small header needed in .ani
+	strcpy((char*)dst,&quot;icon&quot;);
+	dst += 4;
+	DWORD* cursize = (DWORD*)&amp;dst[0];
+	cursize[0] = 3*sizeof(WORD)+sizeof(CursorDirectoryHeader)+sizeof(CursorInfoHeader)+xsize*ysize*4+xsize*ysize/8;
+	dst += 4;
+
+	////////////////////////////////////////////////////////////////////////////////////////////////
+	// the following code writes a full working .cur file in the memory (in a .ani container)
+
+	//file header
+	WORD* header = (WORD*)&amp;dst[0]; int i=0;
+	header[i++] = 0;		//reserved
+	header[i++] = 2;		//is cursor
+	header[i++] = 1;		//number of cursor in this file
+	dst += 3*sizeof(WORD);
+
+	CursorDirectoryHeader curHeader;
+	memset(&amp;curHeader,0,sizeof(CursorDirectoryHeader));
+	curHeader.xsize  = (byte)xsize;		//width
+	curHeader.ysize  = (byte)ysize;		//height
+	curHeader.hotx   = hotx;
+	curHeader.hoty   = hoty;
+	curHeader.size   = 40+xsize*ysize*4+xsize*ysize/8;	//size of the bmp data (infoheader 40byte, 32bit color, 1bit mask)
+	curHeader.offset = 22;			//offset, where the infoHeader starts
+	memcpy(dst, &amp;curHeader, sizeof(CursorDirectoryHeader));
+	dst += sizeof(CursorDirectoryHeader);
+
+	CursorInfoHeader infoHeader;
+	memset(&amp;infoHeader,0,sizeof(CursorInfoHeader));
+	infoHeader.size   = 40;		//size of the infoHeader
+	infoHeader.width  = xsize;		//cursor width
+	infoHeader.height = ysize*2;		//cursor height + mask height
+	infoHeader.planes = 1;		//number of color planes
+	infoHeader.bpp    = 32;		//bits per pixel
+	memcpy(dst, &amp;infoHeader, sizeof(CursorInfoHeader));
+	dst += sizeof(CursorInfoHeader);
+
+	//copy colormap
+	unsigned char* src = image.data;
+	unsigned char* end = src+xsize*ysize*4;
+	do{
+		if (src[3]==0) {
+			dst[0] = dst[1] = dst[2] = dst[3] = 0;
+		}else{
+			dst[0]=src[2];      // B
+			dst[1]=src[1];      // G
+			dst[2]=src[0];      // R
+			dst[3]=src[3];      // A
+		}
+		dst+=4;
+		src+=4;
+	}while(src&lt;end);
+
+	//create mask
+	src -= xsize*ysize*4;
+	int b = 0;
+	do{
+		dst[0] = 0x00;
+		for (b=0; b&lt;8; b++) {
+			if (src[3]==0) //alpha greater zero?
+				dst[0] |= 128&gt;&gt;b;
+			src+=4;
+		}
+		dst++;
+	}while(src&lt;end);
+
+/*	char fname[256];
+	SNPRINTF(fname, sizeof(fname), &quot;mycursor%d.cur&quot;, ++savedcount);
+	FILE * pFile = fopen( fname , &quot;wb&quot; );
+	fwrite(curs.back(), 1 , curmem-curs.back(), pFile );
+	fclose(pFile); */
+}
+
+void CHwWinCursor::Finish()
+{
+	if (frames.size()&lt;1)
+		return;
+
+	hotx = (hotSpot==CMouseCursor::TopLeft) ? 0 : (short)xmaxsize/2;
+	hoty = (hotSpot==CMouseCursor::TopLeft) ? 0 : (short)ymaxsize/2;
+
+	//note: windows only except 16x16,32x32,64x64,etc. (and some more not 2^n ones)
+	int squaresize =  next_power_of_2( std::max(xmaxsize,ymaxsize) );
+
+	//resize images
+	for (std::vector&lt;ImageData&gt;::iterator it=icons.begin(); it&lt;icons.end(); it++)
+		resizeImage(&amp;*it,squaresize,squaresize);
+
+	const int riffsize  = 32 + sizeof(AnihStructure) + (frames.size()+2) * 2 * sizeof(DWORD);
+	const int iconssize = icons.size() * (2*sizeof(DWORD) + 3*sizeof(WORD) +
+					       sizeof(CursorDirectoryHeader) +
+					       sizeof(CursorInfoHeader) +
+					       squaresize*squaresize*4 +
+					       squaresize*squaresize/8);
+	const int totalsize = riffsize + iconssize;
+	unsigned char* mem = SAFE_NEW unsigned char[ totalsize ];
+
+	unsigned char* curmem = mem;
+	DWORD* dwmem;
+
+	//write RIFF header
+		strcpy((char*)curmem,&quot;RIFF&quot;);	curmem+=4;
+		dwmem = (DWORD*)&amp;curmem[0];
+		dwmem[0] = totalsize-8;		curmem+=4; //filesize
+		strcpy((char*)curmem,&quot;ACON&quot;);	curmem+=4;
+
+	//Anih header
+		strcpy((char*)curmem,&quot;anih&quot;);
+		curmem += 4;
+		curmem[0] = 36;
+		curmem[1] = curmem[2] = curmem[3] = 0;
+		curmem += 4;
+
+		AnihStructure anih;
+		memset(&amp;anih,0,sizeof(AnihStructure));
+		anih.size   = 36;		//anih structure size
+		anih.images = image_count;		//number of images
+		anih.frames = framerates.size();	//number of frames
+		anih.flags  = 0x3L;		//using seq structure and .cur format for saving bmp data
+		memcpy(curmem, &amp;anih, sizeof(AnihStructure));
+		curmem += sizeof(AnihStructure);
+
+	//LIST + icons
+		strcpy((char*)curmem,&quot;LIST&quot;);	curmem+=4;
+		dwmem = (DWORD*)&amp;curmem[0];
+		dwmem[0] = iconssize+4;		curmem+=4;
+		strcpy((char*)curmem,&quot;fram&quot;);	curmem+=4;
+
+		for (std::vector&lt;ImageData&gt;::iterator it=icons.begin(); it&lt;icons.end(); it++) {
+			buildIco(curmem,*it);
+			curmem += 2*sizeof(DWORD) + 3*sizeof(WORD)+sizeof(CursorDirectoryHeader)+sizeof(CursorInfoHeader)+squaresize*squaresize*4+squaresize*squaresize/8;
+		}
+
+	//SEQ header
+		strcpy((char*)curmem,&quot;seq &quot;);
+		curmem += 4;
+		DWORD* seq = (DWORD*)&amp;curmem[0];
+		seq[0] = frames.size()*sizeof(DWORD);
+		seq++;
+		for (int i=0; i&lt;frames.size(); i++)
+			seq[i] = frames.at(i);
+		curmem += (frames.size()+1)*sizeof(DWORD);
+
+	//RATE header
+		strcpy((char*)curmem,&quot;rate&quot;);
+		curmem += 4;
+		DWORD* rate = (DWORD*)&amp;curmem[0];
+		rate[0] = framerates.size()*sizeof(DWORD);
+		rate++;
+		for (int i=0; i&lt;framerates.size(); i++)
+			rate[i] = framerates.at(i);
+		curmem += (framerates.size()+1)*sizeof(DWORD);
+
+	/*char fname[256];
+	SNPRINTF(fname, sizeof(fname), &quot;cursors/mycursor%d.ani&quot;, ++savedcount);
+	FILE * pFile = fopen( fname , &quot;wb&quot; );
+	fwrite(mem , 1 , curmem-mem, pFile );
+	fclose(pFile);*/
+
+	cursor = (HCURSOR)CreateIconFromResourceEx((PBYTE)mem,totalsize,FALSE,0x00030000,squaresize,squaresize,0);
+
+	delete[] mem;
+	for (std::vector&lt;ImageData&gt;::iterator it=icons.begin(); it&lt;icons.end(); it++)
+		delete[] (*it).data;
+	icons.clear();
+
+	//if (cursor==NULL) logOutput.Print(&quot;hw cursor failed: x%d y%d&quot;,squaresize,squaresize);
+}
+
+void CHwWinCursor::Bind()
+{
+	/*SDL_SysWMinfo info;
+	SDL_VERSION(&amp;info.version);
+	if (!SDL_GetWMInfo(&amp;info)) {
+		logOutput.Print(&quot;SDL error: can't get window handle&quot;);
+		return;
+	}
+	SetClassLong(info.window,GCL_HCURSOR,(LONG)cursor);*/ //SDL doesn't let us use it :&lt;
+
+	SetCursor(cursor);
+	mouseInput-&gt;SetWMMouseCursor(cursor);
+}
+
+CHwWinCursor::CHwWinCursor(void)
+{
+	cursor = NULL;
+	hotSpot= CMouseCursor::Center;
+	image_count = 0;
+	xmaxsize = ymaxsize = 0;
+}
+
+CHwWinCursor::~CHwWinCursor(void)
+{
+	if (cursor!=NULL)
+		DestroyCursor(cursor);
+
+	for (std::vector&lt;ImageData&gt;::iterator it=icons.begin(); it&lt;icons.end(); it++)
+		delete[] (*it).data;
+	icons.clear();
+}
+
+#else
+
+void CHwX11Cursor::resizeImage(XcursorImage*&amp; image, const int new_x, const int new_y)
+{
+	if (image-&gt;width==new_x &amp;&amp; image-&gt;height==new_y)
+		return;
+
+	const int old_x = image-&gt;width;
+	const int old_y = image-&gt;height;
+
+	XcursorImage* new_image = XcursorImageCreate(new_x, new_y);
+	new_image-&gt;delay = image-&gt;delay;
+
+	unsigned char* src = (unsigned char*)image-&gt;pixels;
+	unsigned char* dst = (unsigned char*)new_image-&gt;pixels;
+	memset(dst, 0, new_x*new_y*4);
+
+	for (int y = 0; y &lt; old_y; ++y)
+		for (int x = 0; x &lt; old_x; ++x)
+			for (int v = 0; v &lt; 4; ++v)
+				dst[(y*new_x+x)*4+v] = src[(y*old_x+x)*4+v];
+
+	XcursorImageDestroy(image);
+	image = new_image;
+}
+
+void CHwX11Cursor::PushImage(int xsize, int ysize, void* mem)
+{
+	xmaxsize=std::max(xmaxsize,xsize);
+	ymaxsize=std::max(ymaxsize,ysize);
+
+	XcursorImage* image = XcursorImageCreate(xsize,ysize);
+	image-&gt;delay = (XcursorUInt)(defFrameLength*1000.0f);
+	char* dst=(char*)image-&gt;pixels;
+	char* src=(char*)mem;
+	char* end=src+xsize*ysize*4;
+	do{
+		dst[0]=src[2];      // B
+		dst[1]=src[1];      // G
+		dst[2]=src[0];      // R
+		dst[3]=src[3];      // A
+		dst+=4;
+		src+=4;
+	}while(src&lt;end);
+
+	cimages.push_back(image);
+}
+
+void CHwX11Cursor::SetDelay(float delay)
+{
+	cimages.back()-&gt;delay = (XcursorUInt)(delay*1000.0f); //in millseconds
+}
+
+void CHwX11Cursor::PushFrame(int index, float delay)
+{
+	if (index&gt;=cimages.size())
+		return;
+
+	if (cimages[index]-&gt;delay!=delay) {
+		// make a copy of the existing one
+		XcursorImage* ci = cimages[index];
+		PushImage( ci-&gt;width, ci-&gt;height, ci-&gt;pixels );
+		SetDelay(delay);
+	}else{
+		cimages.push_back( cimages[index] );
+	}
+}
+
+void CHwX11Cursor::Finish()
+{
+	if (cimages.size()&lt;1)
+		return;
+
+	//resize images
+	for (std::vector&lt;XcursorImage*&gt;::iterator it=cimages.begin(); it&lt;cimages.end(); it++)
+		resizeImage(*it,xmaxsize,ymaxsize);
+
+	XcursorImages *cis = XcursorImagesCreate(cimages.size());
+	cis-&gt;nimage = cimages.size();
+	for (int i=0; i &lt; cimages.size(); i++ ) {
+		XcursorImage* ci = cimages[i];
+		ci-&gt;xhot = (hotSpot==CMouseCursor::TopLeft) ? 0 : ci-&gt;width/2;
+		ci-&gt;yhot = (hotSpot==CMouseCursor::TopLeft) ? 0 : ci-&gt;height/2;
+		cis-&gt;images[i] = ci;
+	}
+
+	SDL_SysWMinfo info;
+	SDL_VERSION(&amp;info.version);
+	if (!SDL_GetWMInfo(&amp;info)) {
+		XcursorImagesDestroy(cis);
+		cimages.clear();
+		logOutput.Print(&quot;SDL error: can't get X11 window info&quot;);
+		return;
+	}
+
+	cursor = XcursorImagesLoadCursor(info.info.x11.display,cis);
+	XcursorImagesDestroy(cis);
+	cimages.clear();
+}
+
+void CHwX11Cursor::Bind()
+{
+	SDL_SysWMinfo info;
+	SDL_VERSION(&amp;info.version);
+	if (!SDL_GetWMInfo(&amp;info)) {
+		logOutput.Print(&quot;SDL error: can't get X11 window info&quot;);
+		return;
+	}
+	XDefineCursor(info.info.x11.display,info.info.x11.window,cursor);
+}
+
+CHwX11Cursor::CHwX11Cursor(void)
+{
+	cursor = 0;
+	hotSpot=CMouseCursor::Center;
+	xmaxsize = ymaxsize = 0;
+}
+
+CHwX11Cursor::~CHwX11Cursor(void)
+{
+	for (std::vector&lt;XcursorImage*&gt;::iterator it=cimages.begin() ; it &lt; cimages.end(); it++ )
+		XcursorImageDestroy(*it);
+	cimages.clear();
+
+	if (cursor!=0) {
+		SDL_SysWMinfo info;
+		SDL_VERSION(&amp;info.version);
+		if (!SDL_GetWMInfo(&amp;info)) {
+			logOutput.Print(&quot;SDL error: can't get X11 window info&quot;);
+			return;
+		}
+		XFreeCursor(info.info.x11.display,cursor);
+	}
+}
+
+#endif

Copied: branches/gml/rts/Game/UI/HwMouseCursor.h (from rev 5882, trunk/rts/Game/UI/HwMouseCursor.h)
===================================================================
--- branches/gml/rts/Game/UI/HwMouseCursor.h	                        (rev 0)
+++ branches/gml/rts/Game/UI/HwMouseCursor.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,27 @@
+#ifndef HWMOUSECURSOR_H
+#define HWMOUSECURSOR_H
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &quot;MouseCursor.h&quot;
+
+class CMouseCursor;
+
+class IHwCursor {
+	public:
+		virtual void PushImage(int xsize, int ysize, void* mem) = 0;
+		virtual void SetDelay(float delay) = 0;
+		virtual void PushFrame(int index, float delay) = 0;
+		virtual void Finish() = 0;
+
+		virtual bool needsYFlip() = 0; //windows needs flipped Y axis
+
+		virtual bool IsValid() = 0;
+		virtual void Bind() = 0;
+
+		CMouseCursor::HotSpot hotSpot;
+};
+
+IHwCursor* GetNewHwCursor();
+
+#endif /* HWMOUSECURSOR_H */

Modified: branches/gml/rts/Game/UI/KeyAutoBinder.h
===================================================================
--- branches/gml/rts/Game/UI/KeyAutoBinder.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/KeyAutoBinder.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,7 +7,6 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &lt;set&gt;
-using namespace std;
 
 #include &quot;Lua/LuaHandle.h&quot;
 

Modified: branches/gml/rts/Game/UI/KeyBindings.h
===================================================================
--- branches/gml/rts/Game/UI/KeyBindings.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/KeyBindings.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -14,8 +14,6 @@
 #include &quot;Game/Console.h&quot;
 #include &quot;Game/Action.h&quot;
 
-using namespace std;
-
 class CUnit;
 class CFileHandler;
 class CSimpleParser;
@@ -27,18 +25,18 @@
 		CKeyBindings();
 		~CKeyBindings();
 
-		bool Load(const string&amp; filename);
-		bool Save(const string&amp; filename) const;
+		bool Load(const std::string&amp; filename);
+		bool Save(const std::string&amp; filename) const;
 		void Print() const;
 
-		typedef vector&lt;Action&gt; ActionList;
-		typedef vector&lt;string&gt; HotkeyList;
+		typedef std::vector&lt;Action&gt; ActionList;
+		typedef std::vector&lt;std::string&gt; HotkeyList;
 
 		const ActionList&amp; GetActionList(const CKeySet&amp; ks) const;
-		const HotkeyList&amp; GetHotkeys(const string&amp; action) const;
+		const HotkeyList&amp; GetHotkeys(const std::string&amp; action) const;
 
 		virtual void PushAction(const Action&amp;);
-		bool Command(const string&amp; line);
+		bool Command(const std::string&amp; line);
 
 		int GetFakeMetaKey() const { return fakeMetaKey; }
 
@@ -52,40 +50,40 @@
 		void Sanitize();
 		void BuildHotkeyMap();
 
-		bool Bind(const string&amp; keystring, const string&amp; action);
-		bool UnBind(const string&amp; keystring, const string&amp; action);
-		bool UnBindKeyset(const string&amp; keystr);
-		bool UnBindAction(const string&amp; action);
-		bool SetFakeMetaKey(const string&amp; keystring);
-		bool AddKeySymbol(const string&amp; keysym, const string&amp; code);
-		bool AddNamedKeySet(const string&amp; name, const string&amp; keyset);
-		bool ParseTypeBind(CSimpleParser&amp; parser, const string&amp; line);
+		bool Bind(const std::string&amp; keystring, const std::string&amp; action);
+		bool UnBind(const std::string&amp; keystring, const std::string&amp; action);
+		bool UnBindKeyset(const std::string&amp; keystr);
+		bool UnBindAction(const std::string&amp; action);
+		bool SetFakeMetaKey(const std::string&amp; keystring);
+		bool AddKeySymbol(const std::string&amp; keysym, const std::string&amp; code);
+		bool AddNamedKeySet(const std::string&amp; name, const std::string&amp; keyset);
+		bool ParseTypeBind(CSimpleParser&amp; parser, const std::string&amp; line);
 
-		bool ParseKeySet(const string&amp; keystr, CKeySet&amp; ks) const;
-		bool RemoveCommandFromList(ActionList&amp; al, const string&amp; command);
+		bool ParseKeySet(const std::string&amp; keystr, CKeySet&amp; ks) const;
+		bool RemoveCommandFromList(ActionList&amp; al, const std::string&amp; command);
 
 		bool FileSave(FILE* file) const;
 
 	protected:
-		typedef map&lt;CKeySet, ActionList&gt; KeyMap; // keyset to action
+		typedef std::map&lt;CKeySet, ActionList&gt; KeyMap; // keyset to action
 		KeyMap bindings;
 
-		typedef map&lt;string, HotkeyList&gt; ActionMap; // action to keyset
+		typedef std::map&lt;std::string, HotkeyList&gt; ActionMap; // action to keyset
 		ActionMap hotkeys;
 
-		typedef map&lt;string, CKeySet&gt; NamedKeySetMap; // user defined keysets
+		typedef std::map&lt;std::string, CKeySet&gt; NamedKeySetMap; // user defined keysets
 		NamedKeySetMap namedKeySets;
 
 		struct BuildTypeBinding {
-			string keystr;         // principal keyset
-			vector&lt;string&gt; reqs;   // requirements
-			vector&lt;string&gt; sorts;  // sorting criteria
-			vector&lt;string&gt; chords; // enumerated keyset chords
+			std::string keystr;         // principal keyset
+			std::vector&lt;std::string&gt; reqs;   // requirements
+			std::vector&lt;std::string&gt; sorts;  // sorting criteria
+			std::vector&lt;std::string&gt; chords; // enumerated keyset chords
 		};
-		vector&lt;BuildTypeBinding&gt; typeBindings;
+		std::vector&lt;BuildTypeBinding&gt; typeBindings;
 
 		// commands that use both Up and Down key presses
-		set&lt;string&gt; statefulCommands;
+		std::set&lt;std::string&gt; statefulCommands;
 
 		int debug;
 		int fakeMetaKey;

Modified: branches/gml/rts/Game/UI/KeyCodes.cpp
===================================================================
--- branches/gml/rts/Game/UI/KeyCodes.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/KeyCodes.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,9 +13,9 @@
 CKeyCodes* keyCodes = NULL;
 
 
-int CKeyCodes::GetCode(const string&amp; name) const
+int CKeyCodes::GetCode(const std::string&amp; name) const
 {
-	map&lt;string, int&gt;::const_iterator it = nameToCode.find(name);
+	std::map&lt;std::string, int&gt;::const_iterator it = nameToCode.find(name);
 	if (it == nameToCode.end()) {
 		return -1;
 	}
@@ -23,9 +23,9 @@
 }
 
 
-string CKeyCodes::GetName(int code) const
+std::string CKeyCodes::GetName(int code) const
 {
-	map&lt;int, string&gt;::const_iterator it = codeToName.find(code);
+	std::map&lt;int, std::string&gt;::const_iterator it = codeToName.find(code);
 	if (it == codeToName.end()) {
 		char buf[64];
 		SNPRINTF(buf, sizeof(buf), &quot;0x%03X&quot;, code);
@@ -35,9 +35,9 @@
 }
 
 
-string CKeyCodes::GetDefaultName(int code) const
+std::string CKeyCodes::GetDefaultName(int code) const
 {
-	map&lt;int, string&gt;::const_iterator it = defaultCodeToName.find(code);
+	std::map&lt;int, std::string&gt;::const_iterator it = defaultCodeToName.find(code);
 	if (it == defaultCodeToName.end()) {
 		char buf[64];
 		SNPRINTF(buf, sizeof(buf), &quot;0x%03X&quot;, code);
@@ -47,16 +47,16 @@
 }
 
 
-bool CKeyCodes::AddKeySymbol(const string&amp; name, int code)
+bool CKeyCodes::AddKeySymbol(const std::string&amp; name, int code)
 {
 	if ((code &lt; 0) || !IsValidLabel(name)) {
 		return false;
 	}
 	
-	const string keysym = StringToLower(name);
+	const std::string keysym = StringToLower(name);
 
 	// do not allow existing keysyms to be renamed
-	map&lt;string, int&gt;::const_iterator name_it = nameToCode.find(keysym);
+	std::map&lt;std::string, int&gt;::const_iterator name_it = nameToCode.find(keysym);
 	if (name_it != nameToCode.end()) {
 		return false;
 	}
@@ -68,7 +68,7 @@
 }
 
 
-bool CKeyCodes::IsValidLabel(const string&amp; label)
+bool CKeyCodes::IsValidLabel(const std::string&amp; label)
 {
 	if (label.empty()) {
 		return false;
@@ -99,7 +99,7 @@
 }
 
 
-void CKeyCodes::AddPair(const string&amp; name, int code)
+void CKeyCodes::AddPair(const std::string&amp; name, int code)
 {
 	if (nameToCode.find(name) == nameToCode.end()) {
 		nameToCode[name] = code;
@@ -135,7 +135,7 @@
 	// ASCII mapped keysyms
 	for (unsigned char i = ' '; i &lt;= '~'; ++i) {
 		if (!isupper(i)) {
-			AddPair(string(1, i), i);
+			AddPair(std::string(1, i), i);
 		}
 	}
 
@@ -242,7 +242,7 @@
 
 void CKeyCodes::PrintNameToCode() const
 {
-	map&lt;string, int&gt;::const_iterator it;
+	std::map&lt;std::string, int&gt;::const_iterator it;
 	for (it = nameToCode.begin(); it != nameToCode.end(); ++it) {
 		logOutput.Print(&quot;KEYNAME: %13s = 0x%03X\n&quot;, it-&gt;first.c_str(), it-&gt;second);
 	}
@@ -251,7 +251,7 @@
 
 void CKeyCodes::PrintCodeToName() const
 {
-	map&lt;int, string&gt;::const_iterator it;
+	std::map&lt;int, std::string&gt;::const_iterator it;
 	for (it = codeToName.begin(); it != codeToName.end(); ++it) {
 		logOutput.Print(&quot;KEYCODE: 0x%03X = '%s'\n&quot;, it-&gt;first, it-&gt;second.c_str());
 	}
@@ -261,15 +261,15 @@
 void CKeyCodes::SaveUserKeySymbols(FILE* file) const
 {
 	bool output = false;
-	map&lt;string, int&gt;::const_iterator user_it;
+	std::map&lt;std::string, int&gt;::const_iterator user_it;
 	for (user_it = nameToCode.begin(); user_it != nameToCode.end(); ++user_it) {
-		map&lt;string, int&gt;::const_iterator def_it;
-		const string&amp; keysym = user_it-&gt;first;
+		std::map&lt;std::string, int&gt;::const_iterator def_it;
+		const std::string&amp; keysym = user_it-&gt;first;
 		def_it = defaultNameToCode.find(keysym);
 		if (def_it == defaultNameToCode.end()) {
 			// this keysym is not standard
 			const int code = user_it-&gt;second;
-			string name = GetDefaultName(code);
+			std::string name = GetDefaultName(code);
 			if (name.empty()) {
 				char buf[16];
 				SNPRINTF(buf, 16, &quot;0x%03X&quot;, code);

Modified: branches/gml/rts/Game/UI/KeyCodes.h
===================================================================
--- branches/gml/rts/Game/UI/KeyCodes.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/KeyCodes.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -8,20 +8,17 @@
 #include &lt;string&gt;
 #include &lt;map&gt;
 
-using namespace std;
-
-
 class CKeyCodes {
 	public:
 		CKeyCodes();
 		void Reset();
 
-		int GetCode(const string&amp; name) const;
+		int GetCode(const std::string&amp; name) const;
 
-		string GetName(int code) const;
-		string GetDefaultName(int code) const;
+		std::string GetName(int code) const;
+		std::string GetDefaultName(int code) const;
 
-		bool AddKeySymbol(const string&amp; name, int code);
+		bool AddKeySymbol(const std::string&amp; name, int code);
 
 		bool IsModifier(int code) const;
 
@@ -31,16 +28,16 @@
 		void SaveUserKeySymbols(FILE* file) const;
 
 	public:
-		static bool IsValidLabel(const string&amp; label);
+		static bool IsValidLabel(const std::string&amp; label);
 
 	protected:
-		void AddPair(const string&amp; name, int code);
+		void AddPair(const std::string&amp; name, int code);
 
 	protected:
-		map&lt;string, int&gt; nameToCode;
-		map&lt;int, string&gt; codeToName;
-		map&lt;string, int&gt; defaultNameToCode;
-		map&lt;int, string&gt; defaultCodeToName;
+		std::map&lt;std::string, int&gt; nameToCode;
+		std::map&lt;int, std::string&gt; codeToName;
+		std::map&lt;std::string, int&gt; defaultNameToCode;
+		std::map&lt;int, std::string&gt; defaultCodeToName;
 };
 
 extern CKeyCodes* keyCodes;

Modified: branches/gml/rts/Game/UI/KeySet.cpp
===================================================================
--- branches/gml/rts/Game/UI/KeySet.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/KeySet.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -56,16 +56,16 @@
 }
 
 
-string CKeySet::GetString(bool useDefaultKeysym) const
+std::string CKeySet::GetString(bool useDefaultKeysym) const
 {
-	string name;
+	std::string name;
 	if (useDefaultKeysym) {
 		name = keyCodes-&gt;GetDefaultName(key);
 	} else {
 		name = keyCodes-&gt;GetName(key);
 	}
 	
-	string modstr;
+	std::string modstr;
 #ifndef DISALLOW_RELEASE_BINDINGS
 	if (modifiers &amp; KS_RELEASE) { modstr += &quot;Up+&quot;; }
 #endif
@@ -79,7 +79,7 @@
 }
 
 
-bool CKeySet::ParseModifier(string&amp; s, const string&amp; token, const string&amp; abbr)
+bool CKeySet::ParseModifier(std::string&amp; s, const std::string&amp; token, const std::string&amp; abbr)
 {
 	if (s.find(token) == 0) {
 		s.erase(0, token.size());
@@ -94,11 +94,11 @@
 }
 
 
-bool CKeySet::Parse(const string&amp; token)
+bool CKeySet::Parse(const std::string&amp; token)
 {
 	Reset();
 
-	string s = StringToLower(token);
+	std::string s = StringToLower(token);
 
 	// parse the modifiers
 	while (!s.empty()) {

Modified: branches/gml/rts/Game/UI/KeySet.h
===================================================================
--- branches/gml/rts/Game/UI/KeySet.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/KeySet.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,9 +7,7 @@
 #include &lt;string&gt;
 #include &lt;map&gt;
 
-using namespace std;
 
-
 class CKeySet {
 	public:
 		CKeySet() { Reset(); }
@@ -18,9 +16,9 @@
 		void Reset();
 		void SetAnyBit();
 		void ClearModifiers();
-		bool Parse(const string&amp; token);
+		bool Parse(const std::string&amp; token);
 
-		string GetString(bool useDefaultKeysym) const;
+		std::string GetString(bool useDefaultKeysym) const;
 
 		enum CKeySetModifiers {
 			KS_ALT     = (1 &lt;&lt; 0),
@@ -59,7 +57,7 @@
 		}
 
 	protected:
-		bool ParseModifier(string&amp; s, const string&amp; token, const string&amp; abbr);
+		bool ParseModifier(std::string&amp; s, const std::string&amp; token, const std::string&amp; abbr);
 
 	protected:
 		int key;

Modified: branches/gml/rts/Game/UI/LuaUI.cpp
===================================================================
--- branches/gml/rts/Game/UI/LuaUI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/LuaUI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -61,6 +61,7 @@
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/NetProtocol.h&quot;
+#include &quot;System/SpringApp.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;System/FileSystem/VFSHandler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
@@ -77,8 +78,6 @@
 
 
 extern Uint8 *keys;
-extern GLfloat LightDiffuseLand[];
-extern GLfloat LightAmbientLand[];
 
 
 CLuaUI* luaUI = NULL;
@@ -595,7 +594,7 @@
 		return; // the call is not defined
 	}
 
-	if (!loshandler-&gt;InLos(pos, gu-&gt;myAllyTeam) &amp;&amp; !gu-&gt;spectatingFullView) {
+	if (!gu-&gt;spectatingFullView &amp;&amp; !loshandler-&gt;InLos(pos, gu-&gt;myAllyTeam)) {
 		const float fuzz = 0.25f;
 		gap.x *= fuzzRand(fuzz);
 		gap.y *= fuzzRand(fuzz);
@@ -806,8 +805,10 @@
 	CKeySet ks(key, false);
 	lua_pushstring(L, ks.GetString(true).c_str());
 
+	lua_pushnumber(L, currentUnicode);
+
 	// call the function
-	if (!RunCallIn(cmdStr, 4, 1)) {
+	if (!RunCallIn(cmdStr, 5, 1)) {
 		return false;
 	}
 
@@ -842,8 +843,10 @@
 	CKeySet ks(key, false);
 	lua_pushstring(L, ks.GetString(true).c_str());
 
+	lua_pushnumber(L, currentUnicode);
+
 	// call the function
-	if (!RunCallIn(cmdStr, 3, 1)) {
+	if (!RunCallIn(cmdStr, 4, 1)) {
 		return false;
 	}
 
@@ -2654,123 +2657,7 @@
 /******************************************************************************/
 /******************************************************************************/
 
-static void ParseCommandOptions(lua_State* L, const char* caller,
-                                int index, Command&amp; cmd)
-{
-	if (lua_isnumber(L, index)) {
-		cmd.options = (unsigned char)lua_tonumber(L, index);
-	}
-	else if (lua_istable(L, index)) {
-		const int optionTable = index;
-		for (lua_pushnil(L); lua_next(L, optionTable) != 0; lua_pop(L, 1)) {
-			if (lua_israwnumber(L, -2)) { // avoid 'n'
-				if (!lua_isstring(L, -1)) {
-					luaL_error(L, &quot;%s(): bad option table entry&quot;, caller);
-				}
-				const string value = lua_tostring(L, -1);
-				if (value == &quot;right&quot;) {
-					cmd.options |= RIGHT_MOUSE_KEY;
-				} else if (value == &quot;alt&quot;) {
-					cmd.options |= ALT_KEY;
-				} else if (value == &quot;ctrl&quot;) {
-					cmd.options |= CONTROL_KEY;
-				} else if (value == &quot;shift&quot;) {
-					cmd.options |= SHIFT_KEY;
-				}
-			}
-		}
-	}
-	else {
-		luaL_error(L, &quot;%s(): bad options&quot;, caller);
-	}
-}
 
-
-static void ParseCommand(lua_State* L, const char* caller,
-                         int idIndex, Command&amp; cmd)
-{
-	// cmdID
-	if (!lua_isnumber(L, idIndex)) {
-		luaL_error(L, &quot;%s(): bad command ID&quot;, caller);
-	}
-	cmd.id = (int)lua_tonumber(L, idIndex);
-
-	// params
-	const int paramTable = (idIndex + 1);
-	if (!lua_istable(L, paramTable)) {
-		luaL_error(L, &quot;%s(): bad param table&quot;, caller);
-	}
-	for (lua_pushnil(L); lua_next(L, paramTable) != 0; lua_pop(L, 1)) {
-		if (lua_israwnumber(L, -2)) { // avoid 'n'
-			if (!lua_isnumber(L, -1)) {
-				luaL_error(L, &quot;%s(): bad param table entry&quot;, caller);
-			}
-			const float value = (float)lua_tonumber(L, -1);
-			cmd.params.push_back(value);
-		}
-	}
-
-	// options
-	ParseCommandOptions(L, caller, (idIndex + 2), cmd);
-
-	// NOTE: should do some sanity checking?
-}
-
-
-static void ParseCommandTable(lua_State* L, const char* caller,
-                              int table, Command&amp; cmd)
-{
-	// cmdID
-	lua_rawgeti(L, table, 1);
-	if (!lua_isnumber(L, -1)) {
-		luaL_error(L, &quot;%s(): bad command ID&quot;, caller);
-	}
-	cmd.id = (int)lua_tonumber(L, -1);
-	lua_pop(L, 1);
-
-	// params
-	lua_rawgeti(L, table, 2);
-	if (!lua_istable(L, -1)) {
-		luaL_error(L, &quot;%s(): bad param table&quot;, caller);
-	}
-	const int paramTable = lua_gettop(L);
-	for (lua_pushnil(L); lua_next(L, paramTable) != 0; lua_pop(L, 1)) {
-		if (lua_israwnumber(L, -2)) { // avoid 'n'
-			if (!lua_isnumber(L, -1)) {
-				luaL_error(L, &quot;%s(): bad param table entry&quot;, caller);
-			}
-			const float value = (float)lua_tonumber(L, -1);
-			cmd.params.push_back(value);
-		}
-	}
-	lua_pop(L, 1);
-
-	// options
-	lua_rawgeti(L, table, 3);
-	ParseCommandOptions(L, caller, lua_gettop(L), cmd);
-	lua_pop(L, 1);
-
-	// NOTE: should do some sanity checking?
-}
-
-
-static void ParseCommandArray(lua_State* L, const char* caller,
-                              int table, vector&lt;Command&gt;&amp; commands)
-{
-	if (!lua_istable(L, table)) {
-		luaL_error(L, &quot;%s(): error parsing command array&quot;, caller);
-	}
-	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
-		if (!lua_istable(L, -1)) {
-			continue;
-		}
-		Command cmd;
-		ParseCommandTable(L, caller, lua_gettop(L), cmd);
-		commands.push_back(cmd);
-	}
-}
-
-
 static void ParseUnitMap(lua_State* L, const char* caller,
                          int table, vector&lt;int&gt;&amp; unitIDs)
 {
@@ -2830,7 +2717,7 @@
 	}
 
 	Command cmd;
-	ParseCommand(L, __FUNCTION__, 1, cmd);
+	LuaUtils::ParseCommand(L, __FUNCTION__, 1, cmd);
 
 	selectedUnits.GiveCommand(cmd);
 
@@ -2854,7 +2741,7 @@
 	}
 
 	Command cmd;
-	ParseCommand(L, __FUNCTION__, 2, cmd);
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
 
 	net-&gt;SendAICommand(gu-&gt;myPlayerNum,
 	                   unit-&gt;id, cmd.id, cmd.options, cmd.params);
@@ -2882,7 +2769,7 @@
 	}
 
 	Command cmd;
-	ParseCommand(L, __FUNCTION__, 2, cmd);
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
 
 	vector&lt;Command&gt; commands;
 	commands.push_back(cmd);
@@ -2911,7 +2798,7 @@
 	}
 
 	Command cmd;
-	ParseCommand(L, __FUNCTION__, 2, cmd);
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
 
 	vector&lt;Command&gt; commands;
 	commands.push_back(cmd);
@@ -2935,7 +2822,7 @@
 
 	// commands
 	vector&lt;Command&gt; commands;
-	ParseCommandArray(L, __FUNCTION__, 2, commands);
+	LuaUtils::ParseCommandArray(L, __FUNCTION__, 2, commands);
 
 	if ((unitIDs.size() &lt;= 0) || (commands.size() &lt;= 0)) {
 		lua_pushboolean(L, false);
@@ -2962,7 +2849,7 @@
 
 	// commands
 	vector&lt;Command&gt; commands;
-	ParseCommandArray(L, __FUNCTION__, 2, commands);
+	LuaUtils::ParseCommandArray(L, __FUNCTION__, 2, commands);
 
 	if ((unitIDs.size() &lt;= 0) || (commands.size() &lt;= 0)) {
 		lua_pushboolean(L, false);

Modified: branches/gml/rts/Game/UI/LuaUI.h
===================================================================
--- branches/gml/rts/Game/UI/LuaUI.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/LuaUI.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -8,7 +8,6 @@
 #include &lt;vector&gt;
 #include &lt;map&gt;
 #include &quot;SDL_types.h&quot;
-using namespace std;
 
 #include &quot;Lua/LuaHandle.h&quot;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;

Modified: branches/gml/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/gml/rts/Game/UI/MiniMap.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/MiniMap.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -103,7 +103,7 @@
 
 	unitBaseSize =
 		atof(configHandler.GetString(&quot;MiniMapUnitSize&quot;, &quot;2.5&quot;).c_str());
-	unitBaseSize = max(0.0f, unitBaseSize);
+	unitBaseSize = std::max(0.0f, unitBaseSize);
 
 	unitExponent =
 		atof(configHandler.GetString(&quot;MiniMapUnitExp&quot;, &quot;0.25&quot;).c_str());
@@ -113,8 +113,10 @@
 
 	useIcons = !!configHandler.GetInt(&quot;MiniMapIcons&quot;, 1);
 
-	drawCommands = max(0, configHandler.GetInt(&quot;MiniMapDrawCommands&quot;, 1));
+	drawCommands = std::max(0, configHandler.GetInt(&quot;MiniMapDrawCommands&quot;, 1));
 
+	drawProjectiles = !!configHandler.GetInt(&quot;MiniMapDrawProjectiles&quot;, 1);
+
 	simpleColors = !!configHandler.GetInt(&quot;SimpleMiniMapColors&quot;, 0);
 
 	myColor[0]    = (unsigned char)(0.2f * 255);
@@ -341,17 +343,25 @@
 		if (words.size() &gt;= 2) {
 			unitBaseSize = atof(words[1].c_str());
 		}
-		unitBaseSize = max(0.0f, unitBaseSize);
+		unitBaseSize = std::max(0.0f, unitBaseSize);
 		UpdateGeometry();
 	}
 	else if (command == &quot;drawcommands&quot;) {
 		if (words.size() &gt;= 2) {
-			drawCommands = max(0, atoi(words[1].c_str()));
+			drawCommands = std::max(0, atoi(words[1].c_str()));
 
 		} else {
 			drawCommands = (drawCommands &gt; 0) ? 0 : 1;
 		}
 	}
+	else if (command == &quot;drawprojectiles&quot;) {
+		if (words.size() &gt;= 2) {
+			drawProjectiles = !!atoi(words[1].c_str());
+
+		} else {
+			drawProjectiles = !drawProjectiles;
+		}
+	}
 	else if (command == &quot;simplecolors&quot;) {
 		if (words.size() &gt;= 2) {
 			simpleColors = !!atoi(words[1].c_str());
@@ -462,13 +472,13 @@
 	if (mouseMove) {
 		xpos += dx;
 		ypos -= dy;
-		xpos = max(0, xpos);
+		xpos = std::max(0, xpos);
 		if (gu-&gt;dualScreenMode) {
-			xpos = min((2 * gu-&gt;viewSizeX) - width, xpos);
+			xpos = std::min((2 * gu-&gt;viewSizeX) - width, xpos);
 		} else {
-			xpos = min(gu-&gt;viewSizeX - width, xpos);
+			xpos = std::min(gu-&gt;viewSizeX - width, xpos);
 		}
-		ypos = max(5, min(gu-&gt;viewSizeY - height, ypos));
+		ypos = std::max(5, std::min(gu-&gt;viewSizeY - height, ypos));
 		UpdateGeometry();
 		return;
 	}
@@ -477,18 +487,18 @@
 		ypos   -= dy;
 		width  += dx;
 		height += dy;
-		height = min(gu-&gt;viewSizeY, height);
+		height = std::min(gu-&gt;viewSizeY, height);
 		if (gu-&gt;dualScreenMode) {
-			width = min(2 * gu-&gt;viewSizeX, width);
+			width = std::min(2 * gu-&gt;viewSizeX, width);
 		} else {
-			width = min(gu-&gt;viewSizeX, width);
+			width = std::min(gu-&gt;viewSizeX, width);
 		}
 		if (keys[SDLK_LSHIFT]) {
 			width = (height * gs-&gt;mapx) / gs-&gt;mapy;
 		}
-		width = max(5, width);
-		height = max(5, height);
-		ypos = min(gu-&gt;viewSizeY - height, ypos);
+		width = std::max(5, width);
+		height = std::max(5, height);
+		ypos = std::min(gu-&gt;viewSizeY - height, ypos);
 		UpdateGeometry();
 		return;
 	}
@@ -560,11 +570,11 @@
 		SetMaximizedGeometry();
 	}
 	else {
-		width = max(1, min(width, gu-&gt;viewSizeX));
-		height = max(1, min(height, gu-&gt;viewSizeY));
-		ypos = max(slaveDrawMode ? 0 : buttonSize, ypos);
-		ypos = min(gu-&gt;viewSizeY - height, ypos);
-		xpos = max(0, min(gu-&gt;viewSizeX - width, xpos));
+		width = std::max(1, std::min(width, gu-&gt;viewSizeX));
+		height = std::max(1, std::min(height, gu-&gt;viewSizeY));
+		ypos = std::max(slaveDrawMode ? 0 : buttonSize, ypos);
+		ypos = std::min(gu-&gt;viewSizeY - height, ypos);
+		xpos = std::max(0, std::min(gu-&gt;viewSizeX - width, xpos));
 	}
 	lastWindowSizeX = gu-&gt;viewSizeX;
 	lastWindowSizeY = gu-&gt;viewSizeY;
@@ -657,10 +667,10 @@
 		// use a selection box
 		const float3 newPos = GetMapPosition(x, y);
 		const float3 oldPos = GetMapPosition(bp.x, bp.y);
-		const float xmin = min(oldPos.x, newPos.x);
-		const float xmax = max(oldPos.x, newPos.x);
-		const float zmin = min(oldPos.z, newPos.z);
-		const float zmax = max(oldPos.z, newPos.z);
+		const float xmin = std::min(oldPos.x, newPos.x);
+		const float xmax = std::max(oldPos.x, newPos.x);
+		const float zmin = std::min(oldPos.z, newPos.z);
+		const float zmax = std::max(oldPos.z, newPos.z);
 
 		CUnitSet::iterator ui;
 		CUnitSet&amp; selection = selectedUnits.selectedUnits;
@@ -945,7 +955,7 @@
 	const float xPixels = radius * float(width) / float(gs-&gt;mapx * SQUARE_SIZE);
 	const float yPixels = radius * float(height) / float(gs-&gt;mapy * SQUARE_SIZE);
 	const int lod = (int)(0.25 * log2(1.0f + (xPixels * yPixels)));
-	const int lodClamp = max(0, min(circleListsCount - 1, lod));
+	const int lodClamp = std::max(0, std::min(circleListsCount - 1, lod));
 	glCallList(circleLists + lodClamp);
 
 	glPopMatrix();
@@ -1006,8 +1016,8 @@
 	glScalef(+1.0f / (gs-&gt;mapx * SQUARE_SIZE), -1.0f / (gs-&gt;mapy * SQUARE_SIZE), 1.0);
 
 	// draw the units
-	list&lt;CUnit*&gt;::iterator ui;
-	for(ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();ui++){
+	std::list&lt;CUnit*&gt;::iterator ui;
+	for (ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ui++) {
 		DrawUnit(*ui);
 	}
 
@@ -1060,55 +1070,59 @@
 	// draw the projectiles
 	glRotatef(-90.0f, +1.0f, 0.0f, 0.0f); // real 'world' coordinates
 
-	Projectile_List::iterator psi;
-	for(psi = ph-&gt;ps.begin(); psi != ph-&gt;ps.end(); ++psi) {
-		CProjectile* p=*psi;
-		if((p-&gt;owner &amp;&amp; (p-&gt;owner-&gt;allyteam == gu-&gt;myAllyTeam)) ||
-		loshandler-&gt;InLos(p, gu-&gt;myAllyTeam) || gu-&gt;spectatingFullView) {
-			if (dynamic_cast&lt;CGeoThermSmokeProjectile*&gt;(p)) {
-			} else if (dynamic_cast&lt;CGfxProjectile*&gt;(p)) {//Nano-piece
-				glBegin(GL_POINTS);
-				glColor4f(0,1,0,0.1);
-				glVertexf3(p-&gt;pos);
-				glEnd();
-			} else if (dynamic_cast&lt;CBeamLaserProjectile*&gt;(p)) {
-				glBegin(GL_LINES);
-				glColor4f(((CBeamLaserProjectile*)p)-&gt;kocolstart[0]/255.0,((CBeamLaserProjectile*)p)-&gt;kocolstart[1]/255.0,((CBeamLaserProjectile*)p)-&gt;kocolstart[2]/255.0,1);
-				glVertexf3(((CBeamLaserProjectile*)p)-&gt;startPos);
-				glVertexf3(((CBeamLaserProjectile*)p)-&gt;endPos);
-				glEnd();
-			} else if (dynamic_cast&lt;CLargeBeamLaserProjectile*&gt;(p)) {
-				glBegin(GL_LINES);
-				glColor4f(((CLargeBeamLaserProjectile*)p)-&gt;kocolstart[0]/255.0,((CLargeBeamLaserProjectile*)p)-&gt;kocolstart[1]/255.0,((CLargeBeamLaserProjectile*)p)-&gt;kocolstart[2]/255.0,1);
-				glVertexf3(((CLargeBeamLaserProjectile*)p)-&gt;startPos);
-				glVertexf3(((CLargeBeamLaserProjectile*)p)-&gt;endPos);
-				glEnd();
-			} else if (dynamic_cast&lt;CLightingProjectile*&gt;(p)) {
-				glBegin(GL_LINES);
-				glColor4f(((CLightingProjectile*)p)-&gt;color[0],((CLightingProjectile*)p)-&gt;color[1],((CLightingProjectile*)p)-&gt;color[2],1);
-				glVertexf3(((CLightingProjectile*)p)-&gt;pos);
-				glVertexf3(((CLightingProjectile*)p)-&gt;endPos);
-				glEnd();
-			} else if (dynamic_cast&lt;CPieceProjectile*&gt;(p)) {
-				glBegin(GL_POINTS);
-				glColor4f(1,0,0,1);
-				glVertexf3(p-&gt;pos);
-				glEnd();
-			} else if (dynamic_cast&lt;CWreckProjectile*&gt;(p)) {
-				glBegin(GL_POINTS);
-				glColor4f(1,0,0,0.5);
-				glVertexf3(p-&gt;pos);
-				glEnd();
-			} else if (dynamic_cast&lt;CWeaponProjectile*&gt;(p)) {
-				glBegin(GL_POINTS);
-				glColor4f(1,1,0,1);
-				glVertexf3(p-&gt;pos);
-				glEnd();
-			} else {
-				glBegin(GL_POINTS);
-				glColor4f(1,1,1,0.1/*0.0002f*(width+height)*/);
-				glVertexf3(p-&gt;pos);
-				glEnd();
+	if (drawProjectiles) {
+		Projectile_List::iterator psi;
+		for(psi = ph-&gt;ps.begin(); psi != ph-&gt;ps.end(); ++psi) {
+			CProjectile* p = *psi;
+
+			if ((p-&gt;owner &amp;&amp; (p-&gt;owner-&gt;allyteam == gu-&gt;myAllyTeam)) ||
+				gu-&gt;spectatingFullView || loshandler-&gt;InLos(p, gu-&gt;myAllyTeam)) {
+
+				if (dynamic_cast&lt;CGeoThermSmokeProjectile*&gt;(p)) {
+				} else if (dynamic_cast&lt;CGfxProjectile*&gt;(p)) {//Nano-piece
+					glBegin(GL_POINTS);
+					glColor4f(0,1,0,0.1);
+					glVertexf3(p-&gt;pos);
+					glEnd();
+				} else if (dynamic_cast&lt;CBeamLaserProjectile*&gt;(p)) {
+					glBegin(GL_LINES);
+					glColor4f(((CBeamLaserProjectile*)p)-&gt;kocolstart[0]/255.0,((CBeamLaserProjectile*)p)-&gt;kocolstart[1]/255.0,((CBeamLaserProjectile*)p)-&gt;kocolstart[2]/255.0,1);
+					glVertexf3(((CBeamLaserProjectile*)p)-&gt;startPos);
+					glVertexf3(((CBeamLaserProjectile*)p)-&gt;endPos);
+					glEnd();
+				} else if (dynamic_cast&lt;CLargeBeamLaserProjectile*&gt;(p)) {
+					glBegin(GL_LINES);
+					glColor4f(((CLargeBeamLaserProjectile*)p)-&gt;kocolstart[0]/255.0,((CLargeBeamLaserProjectile*)p)-&gt;kocolstart[1]/255.0,((CLargeBeamLaserProjectile*)p)-&gt;kocolstart[2]/255.0,1);
+					glVertexf3(((CLargeBeamLaserProjectile*)p)-&gt;startPos);
+					glVertexf3(((CLargeBeamLaserProjectile*)p)-&gt;endPos);
+					glEnd();
+				} else if (dynamic_cast&lt;CLightingProjectile*&gt;(p)) {
+					glBegin(GL_LINES);
+					glColor4f(((CLightingProjectile*)p)-&gt;color[0],((CLightingProjectile*)p)-&gt;color[1],((CLightingProjectile*)p)-&gt;color[2],1);
+					glVertexf3(((CLightingProjectile*)p)-&gt;pos);
+					glVertexf3(((CLightingProjectile*)p)-&gt;endPos);
+					glEnd();
+				} else if (dynamic_cast&lt;CPieceProjectile*&gt;(p)) {
+					glBegin(GL_POINTS);
+					glColor4f(1,0,0,1);
+					glVertexf3(p-&gt;pos);
+					glEnd();
+				} else if (dynamic_cast&lt;CWreckProjectile*&gt;(p)) {
+					glBegin(GL_POINTS);
+					glColor4f(1,0,0,0.5);
+					glVertexf3(p-&gt;pos);
+					glEnd();
+				} else if (dynamic_cast&lt;CWeaponProjectile*&gt;(p)) {
+					glBegin(GL_POINTS);
+					glColor4f(1,1,0,1);
+					glVertexf3(p-&gt;pos);
+					glEnd();
+				} else {
+					glBegin(GL_POINTS);
+					glColor4f(1,1,1,0.1/*0.0002f*(width+height)*/);
+					glVertexf3(p-&gt;pos);
+					glEnd();
+				}
 			}
 		}
 	}
@@ -1118,7 +1132,7 @@
 	// NOTE: this needlessly adds to the CursorIcons list, but at least
 	//       they are not drawn  (because the input receivers are drawn
 	//       after the command queues)
-  LuaUnsyncedCtrl::DrawUnitCommandQueues();
+	LuaUnsyncedCtrl::DrawUnitCommandQueues();
 	if ((drawCommands &gt; 0) &amp;&amp; guihandler-&gt;GetQueueKeystate()) {
 	  selectedUnits.DrawCommands();
 	}
@@ -1494,7 +1508,7 @@
 {
 	const float baseSize = gs-&gt;mapx * SQUARE_SIZE;
 	glBegin(GL_LINES);
-	list&lt;Notification&gt;::iterator ni = notes.begin();
+	std::list&lt;Notification&gt;::iterator ni = notes.begin();
 	while (ni != notes.end()) {
 		const float age = gu-&gt;gameTime - ni-&gt;creationTime;
 		if (age &gt; 2) {

Modified: branches/gml/rts/Game/UI/MiniMap.h
===================================================================
--- branches/gml/rts/Game/UI/MiniMap.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/MiniMap.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -122,6 +122,7 @@
 		int lastWindowSizeX;
 		int lastWindowSizeY;
 		
+		bool drawProjectiles;
 		bool useIcons;
 		int drawCommands;
 		float cursorScale;

Modified: branches/gml/rts/Game/UI/MouseCursor.cpp
===================================================================
--- branches/gml/rts/Game/UI/MouseCursor.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/MouseCursor.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,16 +5,16 @@
 #include &quot;FileSystem/SimpleParser.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;MouseCursor.h&quot;
+#include &quot;HwMouseCursor.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;mmgr.h&quot;
 
+//////////////////////////////////////////////////////////////////////
+// CMouseCursor Class
+//////////////////////////////////////////////////////////////////////
 
-static const float minFrameLength = 0.010f;  // seconds
-static const float defFrameLength = 0.100f;  // seconds
-
-
 CMouseCursor* CMouseCursor::New(const string &amp;name, HotSpot hs)
 {
 	CMouseCursor* c = SAFE_NEW CMouseCursor(name, hs);
@@ -25,20 +25,21 @@
 	return c;
 }
 
-
-//Would be nice if these were read from a gaf-file instead.
 CMouseCursor::CMouseCursor(const string &amp;name, HotSpot hs)
 {
+	hwCursor = GetNewHwCursor();
+	hwCursor-&gt;hotSpot = hs;
 	hotSpot = hs;
 
-	if (!BuildFromSpecFile(name)) {
+	if (!BuildFromSpecFile(name))
 		BuildFromFileNames(name, 123456);
-	}
 
-	if (frames.size() &lt;= 0) {
+	if (frames.size() &lt;= 0)
 		return;
-	}
 
+	animated = (frames.size() &gt; 1);
+	hwValid  = hwCursor-&gt;IsValid();
+
 	animTime = 0.0f;
 	animPeriod = 0.0f;
 	currentFrame = 0;
@@ -50,8 +51,8 @@
 		frame.startTime = animPeriod;
 		animPeriod += frame.length;
 		frame.endTime = animPeriod;
-		xmaxsize = max(frame.image.xOrigSize, xmaxsize);
-		ymaxsize = max(frame.image.yOrigSize, ymaxsize);
+		xmaxsize = std::max(frame.image.xOrigSize, xmaxsize);
+		ymaxsize = std::max(frame.image.yOrigSize, ymaxsize);
 	}
 
 	if (hotSpot == TopLeft) {
@@ -66,10 +67,11 @@
 
 CMouseCursor::~CMouseCursor(void)
 {
-	vector&lt;ImageData&gt;::iterator it;
-	for (it = images.begin(); it != images.end(); ++it) {
+	delete hwCursor;
+
+	std::vector&lt;ImageData&gt;::iterator it;
+	for (it = images.begin(); it != images.end(); ++it)
 		glDeleteTextures(1, &amp;it-&gt;texture);
-	}
 }
 
 
@@ -83,27 +85,29 @@
 
 	CSimpleParser parser(specFH);
 	int lastFrame = 123456789;
-	map&lt;string, int&gt; imageIndexMap;
+	std::map&lt;std::string, int&gt; imageIndexMap;
 
 	while (true) {
 		const string line = parser.GetCleanLine();
 		if (line.empty()) {
 			break;
 		}
-		const vector&lt;string&gt; words = parser.Tokenize(line, 2);
-		const string command = StringToLower(words[0]);
+		const std::vector&lt;std::string&gt; words = parser.Tokenize(line, 2);
+		const std::string command = StringToLower(words[0]);
 
 		if ((command == &quot;frame&quot;) &amp;&amp; (words.size() &gt;= 2)) {
-			const string imageName = words[1];
-			const float length = max(minFrameLength, (float)atof(words[2].c_str()));
-			map&lt;string, int&gt;::iterator iit = imageIndexMap.find(imageName);
+			const std::string imageName = words[1];
+			const float length = std::max(minFrameLength, (float)atof(words[2].c_str()));
+			std::map&lt;std::string, int&gt;::iterator iit = imageIndexMap.find(imageName);
 			if (iit != imageIndexMap.end()) {
 				FrameData frame(images[iit-&gt;second], length);
 				frames.push_back(frame);
+				hwCursor-&gt;PushFrame(iit-&gt;second,length);
 			}
 			else {
 				ImageData image;
 				if (LoadCursorImage(imageName, image)) {
+					hwCursor-&gt;SetDelay(length);
 					imageIndexMap[imageName] = images.size();
 					images.push_back(image);
 					FrameData frame(image, length);
@@ -114,13 +118,15 @@
 		else if ((command == &quot;hotspot&quot;) &amp;&amp; (words.size() &gt;= 1)) {
 			if (words[1] == &quot;topleft&quot;) {
 				hotSpot = TopLeft;
+				hwCursor-&gt;hotSpot = TopLeft;
 			}
 			else if (words[1] == &quot;center&quot;) {
 				hotSpot = Center;
+				hwCursor-&gt;hotSpot = Center;
 			}
 			else {
 				logOutput.Print(&quot;%s: unknown hotspot  (%s)\n&quot;,
-												specFile.c_str(), words[1].c_str());
+							specFile.c_str(), words[1].c_str());
 			}
 		}
 		else if ((command == &quot;lastframe&quot;) &amp;&amp; (words.size() &gt;= 1)) {
@@ -136,6 +142,8 @@
 		return BuildFromFileNames(name, lastFrame);
 	}
 
+	hwCursor-&gt;Finish();
+
 	return true;
 }
 
@@ -168,14 +176,15 @@
 		SNPRINTF(namebuf, sizeof(namebuf), &quot;anims/%s_%d.%s&quot;,
 		         name.c_str(), frames.size(), ext);
 		ImageData image;
-		if (!LoadCursorImage(namebuf, image)) {
+		if (!LoadCursorImage(namebuf, image))
 			break;
-		}
 		images.push_back(image);
 		FrameData frame(image, defFrameLength);
 		frames.push_back(frame);
 	}
 
+	hwCursor-&gt;Finish();
+
 	return true;
 }
 
@@ -193,16 +202,24 @@
 		return false;
 	}
 
-	b.ReverseYAxis();
-
-	CBitmap* final = getAlignedBitmap(b);
-
-	// coded bmp transparency mask
+	// hardcoded bmp transparency mask
 	if ((name.size() &gt;= 3) &amp;&amp;
 	    (StringToLower(name.substr(name.size() - 3)) == &quot;bmp&quot;)) {
-		setBitmapTransparency(*final, 84, 84, 252);
+		setBitmapTransparency(b, 84, 84, 252);
 	}
 
+	if (hwCursor-&gt;needsYFlip()) {
+		//WINDOWS
+		b.ReverseYAxis();
+		hwCursor-&gt;PushImage(b.xsize,b.ysize,b.mem);
+	}else{
+		//X11
+		hwCursor-&gt;PushImage(b.xsize,b.ysize,b.mem);
+		b.ReverseYAxis();
+	}
+
+	CBitmap* final = getAlignedBitmap(b);
+
 	GLuint texID = 0;
 	glGenTextures(1, &amp;texID);
 	glBindTexture(GL_TEXTURE_2D, texID);
@@ -267,6 +284,8 @@
 
 void CMouseCursor::Draw(int x, int y, float scale)
 {
+	if (scale&lt;0) scale=-scale;
+
 	const FrameData&amp; frame = frames[currentFrame];
 	const int xs = int(float(frame.image.xAlignedSize) * scale);
 	const int ys = int(float(frame.image.yAlignedSize) * scale);
@@ -346,3 +365,8 @@
 	const FrameData&amp; frame = frames[currentFrame];
 	glBindTexture(GL_TEXTURE_2D, frame.image.texture);
 }
+
+void CMouseCursor::BindHwCursor()
+{
+	hwCursor-&gt;Bind();	
+}

Modified: branches/gml/rts/Game/UI/MouseCursor.h
===================================================================
--- branches/gml/rts/Game/UI/MouseCursor.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/MouseCursor.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,24 +4,27 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &quot;Rendering/GL/myGL.h&quot;
+//#include &quot;HwMouseCursor.h&quot;
 
-using namespace std;
-
 class CBitmap;
+class IHwCursor;
 
-
 class CMouseCursor {
 	public:
 		enum HotSpot {TopLeft, Center};
 
-		static CMouseCursor* New(const string &amp;name, HotSpot hs);
+		bool animated;
+		bool hwValid; //if hardware cursor is valid
 
+		static CMouseCursor* New(const std::string &amp;name, HotSpot hs);
+
 		~CMouseCursor(void);
 
 		void Update();
-		void Draw(int x, int y, float scale);
-		void DrawQuad(int x, int y);
-		void BindTexture();
+		void Draw(int x, int y, float scale);	// software cursor draw
+		void DrawQuad(int x, int y);		// draw command queue icon
+		void BindTexture(); 			// software mouse cursor
+		void BindHwCursor(); 			// hardware mouse cursor
 
 		int GetMaxSizeX() const { return xmaxsize; }
 		int GetMaxSizeY() const { return ymaxsize; }
@@ -44,19 +47,21 @@
 		};
 
 	protected:	
-		CMouseCursor(const string &amp;name, HotSpot hs);
-		bool LoadCursorImage(const string&amp; name, struct ImageData&amp; image);
-		bool BuildFromSpecFile(const string&amp; name);
-		bool BuildFromFileNames(const string&amp; name, int lastFrame);
+		CMouseCursor(const std::string &amp;name, HotSpot hs);
+		bool LoadCursorImage(const std::string&amp; name, struct ImageData&amp; image);
+		bool BuildFromSpecFile(const std::string&amp; name);
+		bool BuildFromFileNames(const std::string&amp; name, int lastFrame);
 		CBitmap* getAlignedBitmap(const CBitmap &amp;orig);
 		void setBitmapTransparency(CBitmap &amp;bm, int r, int g, int b);
 
 	protected:	
 		HotSpot hotSpot;
 
-		vector&lt;ImageData&gt; images;
-		vector&lt;FrameData&gt; frames;
+		std::vector&lt;ImageData&gt; images;
+		std::vector&lt;FrameData&gt; frames;
 
+		IHwCursor* hwCursor; // hardware cursor
+
 		float animTime;
 		float animPeriod;
 		int currentFrame;
@@ -69,4 +74,8 @@
 };
 
 
+static const float minFrameLength = 0.010f;  // seconds
+static const float defFrameLength = 0.100f;  // seconds
+
+
 #endif /* MOUSECURSOR_H */

Modified: branches/gml/rts/Game/UI/MouseHandler.cpp
===================================================================
--- branches/gml/rts/Game/UI/MouseHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/MouseHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -59,34 +59,44 @@
 CMouseHandler::CMouseHandler()
 : locked(false)
 {
-	lastx=300;
-	lasty=200;
-	hide=false;
+	lastx = 300;
+	lasty = 200;
+	hide = true;
+	hwHide = true;
+	currentCursor = NULL;
 
-	for(int a=1;a&lt;=NUM_BUTTONS;a++){
-		buttons[a].pressed=false;
-		buttons[a].lastRelease=-20;
-		buttons[a].movement=0;
+	for (int a = 1; a &lt;= NUM_BUTTONS; a++) {
+		buttons[a].pressed = false;
+		buttons[a].lastRelease = -20;
+		buttons[a].movement = 0;
 	}
 
 	cursorScale = 1.0f;
 
 	LoadCursors();
 
+	// hide the cursor until we are ingame (not in loading screen etc.)
 	SDL_ShowCursor(SDL_DISABLE);
 
+#ifndef __APPLE__
+	hardwareCursor = !!configHandler.GetInt(&quot;HardwareCursor&quot;, 0);
+#else
+	hardwareCursor = false;
+#endif
+
 	soundMultiselID = sound-&gt;GetWaveId(&quot;sounds/button9.wav&quot;);
 
-	invertMouse=!!configHandler.GetInt(&quot;InvertMouse&quot;,1);
+	invertMouse = !!configHandler.GetInt(&quot;InvertMouse&quot;,1);
 	doubleClickTime = (float)configHandler.GetInt(&quot;DoubleClickTime&quot;, 200) / 1000.0f;
 
 	scrollWheelSpeed = (float)configHandler.GetInt(&quot;ScrollWheelSpeed&quot;, 25);
-	scrollWheelSpeed = max(-255.0f, min(255.0f, scrollWheelSpeed));
+	scrollWheelSpeed = std::max(-255.0f, std::min(255.0f, scrollWheelSpeed));
 }
 
 CMouseHandler::~CMouseHandler()
 {
-	SDL_ShowCursor(SDL_ENABLE);
+	if (hwHide)
+		SDL_ShowCursor(SDL_ENABLE);
 
 	std::map&lt;std::string, CMouseCursor*&gt;::iterator ci;
 	for (ci = cursorFileMap.begin(); ci != cursorFileMap.end(); ++ci) {
@@ -533,37 +543,7 @@
 	}
 }
 
-void CMouseHandler::ShowMouse()
-{
-	if(hide){
-		SDL_ShowCursor(SDL_DISABLE);
-		hide=false;
-	}
-}
 
-
-void CMouseHandler::HideMouse()
-{
-	if (!hide) {
-		lastx = gu-&gt;viewSizeX / 2 + gu-&gt;viewPosX;
-		lasty = gu-&gt;viewSizeY / 2 + gu-&gt;viewPosY;
-    	SDL_ShowCursor(SDL_DISABLE);
-		mouseInput-&gt;SetPos(int2(lastx, lasty));
-		hide = true;
-	}
-}
-
-void CMouseHandler::ToggleState()
-{
-	if(locked){
-		locked=false;
-		ShowMouse();
-	} else {
-		locked=true;
-		HideMouse();
-}
-}
-
 void CMouseHandler::WarpMouse(int x, int y)
 {
 	if (!locked) {
@@ -631,6 +611,7 @@
 	return &quot;&quot;;
 }
 
+
 void CMouseHandler::EmptyMsgQueUpdate(void)
 {
 	if (!hide) {
@@ -653,54 +634,129 @@
 	}
 }
 
+
+void CMouseHandler::ShowMouse()
+{
+	if(hide){
+		// I don't use SDL_ShowCursor here 'cos it would cause a flicker (with hwCursor)
+		// instead update state and cursor at the same time
+		if (hardwareCursor){
+			hwHide=true; //call SDL_ShowCursor(SDL_ENABLE) later!
+		}else{
+			SDL_ShowCursor(SDL_DISABLE);
+		}
+		cursorText=&quot;&quot;; //force hardware cursor rebinding (else we have standard b&amp;w cursor)
+		hide=false;
+	}
+}
+
+
+void CMouseHandler::HideMouse()
+{
+	if (!hide) {
+		hwHide = true;
+		SDL_ShowCursor(SDL_DISABLE);
+		mouseInput-&gt;SetWMMouseCursor(NULL);
+		lastx = gu-&gt;viewSizeX / 2 + gu-&gt;viewPosX;
+		lasty = gu-&gt;viewSizeY / 2 + gu-&gt;viewPosY;
+		mouseInput-&gt;SetPos(int2(lastx, lasty));
+		hide = true;
+	}
+}
+
+
+void CMouseHandler::ToggleState()
+{
+	if(locked){
+		locked=false;
+		ShowMouse();
+	} else {
+		locked=true;
+		HideMouse();
+	}
+}
+
+
+void CMouseHandler::UpdateHwCursor()
+{
+	if (hardwareCursor){
+		hwHide=true; //call SDL_ShowCursor(SDL_ENABLE) later!
+	}else{
+		mouseInput-&gt;SetWMMouseCursor(NULL);
+		SDL_ShowCursor(SDL_DISABLE);
+	}
+	cursorText = &quot;&quot;;
+}
+
+
 /******************************************************************************/
 
+void CMouseHandler::SetCursor(const std::string&amp; cmdName)
+{
+	if (cursorText.compare(cmdName)==0)
+		return;
+
+	cursorText = cmdName;
+	map&lt;string, CMouseCursor*&gt;::iterator it = cursorCommandMap.find(cmdName);
+	if (it != cursorCommandMap.end()) {
+		currentCursor = it-&gt;second;
+	} else {
+		currentCursor = cursorFileMap[&quot;cursornormal&quot;];
+	}
+
+	if (hardwareCursor &amp;&amp; !hide &amp;&amp; currentCursor) {
+		if (currentCursor-&gt;hwValid) {
+			if (hwHide) {
+				SDL_ShowCursor(SDL_ENABLE);
+				hwHide = false;
+			}
+			currentCursor-&gt;BindHwCursor();
+		} else {
+			hwHide = true;
+			SDL_ShowCursor(SDL_DISABLE);
+			mouseInput-&gt;SetWMMouseCursor(NULL);
+		}
+	}
+}
+
+
 void CMouseHandler::UpdateCursors()
 {
+	//we update all cursors, 'cos of the command queue icons
 	map&lt;string, CMouseCursor *&gt;::iterator it;
 	for (it = cursorFileMap.begin(); it != cursorFileMap.end(); ++it) {
-		if (it-&gt;second != NULL) {
+		if (it-&gt;second != NULL)
 			it-&gt;second-&gt;Update();
-		}
 	}
 }
 
 
 void CMouseHandler::DrawCursor(void)
 {
-	if (guihandler) {
+	if (guihandler)
 		guihandler-&gt;DrawCentroidCursor();
-	}
 
-	if (hide || (cursorText == &quot;none&quot;)) {
+	if (hide || (cursorText == &quot;none&quot;))
 		return;
-	}
 
-	CMouseCursor* mc;
-	map&lt;string, CMouseCursor*&gt;::iterator it = cursorCommandMap.find(cursorText);
-	if (it != cursorCommandMap.end()) {
-		mc = it-&gt;second;
-	} else {
-		mc = cursorFileMap[&quot;cursornormal&quot;];
-	}
-
-	if (mc == NULL) {
+	if (!currentCursor || (hardwareCursor &amp;&amp; currentCursor-&gt;hwValid)) {
 		return;
 	}
 
+	// draw the 'software' cursor
 	if (cursorScale &gt;= 0.0f) {
-		mc-&gt;Draw(lastx, lasty, cursorScale);
+		currentCursor-&gt;Draw(lastx, lasty, cursorScale);
 	}
 	else {
 		CMouseCursor* nc = cursorFileMap[&quot;cursornormal&quot;];
 		if (nc == NULL) {
-			mc-&gt;Draw(lastx, lasty, -cursorScale);
+			currentCursor-&gt;Draw(lastx, lasty, -cursorScale);
 		}
 		else {
 			nc-&gt;Draw(lastx, lasty, 1.0f);
-			if (mc != nc) {
-				mc-&gt;Draw(lastx + nc-&gt;GetMaxSizeX(),
-								 lasty + nc-&gt;GetMaxSizeY(), -cursorScale);
+			if (currentCursor != nc) {
+				currentCursor-&gt;Draw(lastx + nc-&gt;GetMaxSizeX(),
+				                    lasty + nc-&gt;GetMaxSizeY(), -cursorScale);
 			}
 		}
 	}

Modified: branches/gml/rts/Game/UI/MouseHandler.h
===================================================================
--- branches/gml/rts/Game/UI/MouseHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/MouseHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -16,15 +16,20 @@
 class CCameraController;
 
 
-class CMouseHandler  
+class CMouseHandler
 {
 public:
+	void SetCursor(const std::string&amp; cmdName);
+
+	bool hardwareCursor;
+	void UpdateHwCursor(); //calls SDL_ShowCursor, used for ingame hwcursor enabling
+
 	void UpdateCursors();
 	void HideMouse();
 	void ShowMouse();
-	void ToggleState();
+	void ToggleState(); // lock+hide (used by fps camera and middle click scrolling)
 	void WarpMouse(int x, int y);
-	void Draw();
+	void Draw(); // draw mousebox (selection box)
 	void MouseRelease(int x,int y,int button);
 	void MousePress(int x,int y,int button);
 	void MouseMove(int x,int y);
@@ -32,9 +37,10 @@
 	CMouseHandler();
 	virtual ~CMouseHandler();
 
-	int lastx;  
-	int lasty;  
+	int lastx;
+	int lasty;
 	bool hide;
+	bool hwHide;
 	bool locked;
 	bool invertMouse;
 	float doubleClickTime;
@@ -53,29 +59,25 @@
 	};
 
 	ButtonPress buttons[NUM_BUTTONS + 1]; /* One-bottomed. */
+	int activeButton;
 	float3 dir;
 
-	int activeButton;
+	int soundMultiselID;
 
-	unsigned int cursorTex;
-	std::string cursorText;
-	std::string cursorTextRight;
-	float cursorScale;	
+	float cursorScale;
 	void DrawCursor(void);
 	std::string GetCurrentTooltip(void);
 
+	std::string cursorText; //current cursor name
+	CMouseCursor *currentCursor;
 	std::map&lt;std::string, CMouseCursor*&gt; cursorFileMap;
 	std::map&lt;std::string, CMouseCursor*&gt; cursorCommandMap;
-	//CMouseCursor *mc;
-
-	int soundMultiselID;
-
 	bool AssignMouseCursor(const std::string&amp; cmdName,
 	                       const std::string&amp; fileName,
 	                       CMouseCursor::HotSpot hotSpot,
 	                       bool overwrite);
-	bool ReplaceMouseCursor(const string&amp; oldName,
-	                        const string&amp; newName,
+	bool ReplaceMouseCursor(const std::string&amp; oldName,
+	                        const std::string&amp; newName,
 	                        CMouseCursor::HotSpot hotSpot);
 	void SafeDeleteCursor(CMouseCursor* cursor);
 


Property changes on: branches/gml/rts/Game/UI/ProfileDrawer.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Game/UI/ProfileDrawer.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Game/UI/QuitBox.cpp
===================================================================
--- branches/gml/rts/Game/UI/QuitBox.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/QuitBox.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -138,7 +138,7 @@
 		else
 			teamName = &quot;uncontrolled&quot;;
 
-		string ally, dead;
+		std::string ally, dead;
 		if (gs-&gt;Ally(gu-&gt;myAllyTeam, gs-&gt;AllyTeam(actualTeam))) {
 			ally = &quot; &lt;Ally&gt;)&quot;;
 		} else {

Modified: branches/gml/rts/Game/UI/ResourceBar.cpp
===================================================================
--- branches/gml/rts/Game/UI/ResourceBar.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/ResourceBar.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -36,7 +36,7 @@
 }
 
 
-static string FloatToSmallString(float num,float mul=1){
+static std::string FloatToSmallString(float num, float mul = 1) {
 	char c[50];
 
 	if(num==0)
@@ -243,13 +243,13 @@
 		moveBox=true;
 		if(!gu-&gt;spectating){
 			if(InBox(mx,my,box+metalBox)){
-				moveBox=false;
-				float metalShare=max(0.f,min(1.f,(mx-(box.x1+metalBox.x1))/(metalBox.x2-metalBox.x1)));
+				moveBox = false;
+				float metalShare = std::max(0.f, std::min(1.f,(mx-(box.x1+metalBox.x1))/(metalBox.x2-metalBox.x1)));
 				net-&gt;SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, metalShare, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare);
 			}
 			if(InBox(mx,my,box+energyBox)){
-				moveBox=false;
-				float energyShare=max(0.f,min(1.f,(mx-(box.x1+energyBox.x1))/(energyBox.x2-energyBox.x1)));
+				moveBox = false;
+				float energyShare = std::max(0.f, std::min(1.f,(mx-(box.x1+energyBox.x1))/(energyBox.x2-energyBox.x1)));
 				net-&gt;SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, gs-&gt;Team(gu-&gt;myTeam)-&gt;metalShare, energyShare);
 			}
 		}

Modified: branches/gml/rts/Game/UI/SelectionKeyHandler.cpp
===================================================================
--- branches/gml/rts/Game/UI/SelectionKeyHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/SelectionKeyHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -34,13 +34,13 @@
 
 	while(ifs.peek()!=EOF &amp;&amp; !ifs.eof()){
 		ifs &gt;&gt; buf;
-		string key(buf);
+		std::string key(buf);
 
 		if(ifs.peek()==EOF || ifs.eof())
 			break;
 
 		ifs &gt;&gt; buf;
-		string sel(buf);
+		std::string sel(buf);
 
 		HotKey hk;
 
@@ -50,7 +50,7 @@
 		hk.alt=false;
 
 		while(true){
-			string s=ReadToken(key);
+			std::string s=ReadToken(key);
 
 			if(s==&quot;Shift&quot;){
 				hk.shift=true;
@@ -96,9 +96,9 @@
 	return false;
 }
 
-string CSelectionKeyHandler::ReadToken(string&amp; s)
+std::string CSelectionKeyHandler::ReadToken(std::string&amp; s)
 {
-	string ret;
+	std::string ret;
 	// change made.  avoiding repeated substr calls...
 /*	int index = 0;
 	//char c=s[index];
@@ -109,14 +109,14 @@
 	if ( index == s.length() )
 		s.clear();
 	else
-		s = s.substr(index, string::npos);
+		s = s.substr(index, std::string::npos);
 */
 	if (s.empty())
-		return string();
+		return std::string();
 
 	char c=s[0];
 	while(c &amp;&amp; c!='_' &amp;&amp; c!='+'){
-		s=s.substr(1,string::npos);
+		s=s.substr(1,std::string::npos);
 		ret+=c;
 		c=s[0];
 	}
@@ -125,11 +125,11 @@
 }
 
 
-string CSelectionKeyHandler::ReadDelimiter(string&amp; s)
+std::string CSelectionKeyHandler::ReadDelimiter(std::string&amp; s)
 {
-	string ret = s.substr(0, 1);
+	std::string ret = s.substr(0, 1);
 	if (s.size() &gt;= 1) {
-		s = s.substr(1, string::npos);
+		s = s.substr(1, std::string::npos);
 	} else {
 		s = &quot;&quot;;
 	}
@@ -137,12 +137,12 @@
 }
 
 
-void CSelectionKeyHandler::DoSelection(string selectString)
+void CSelectionKeyHandler::DoSelection(std::string selectString)
 {
-	list&lt;CUnit*&gt; selection;
+	std::list&lt;CUnit*&gt; selection;
 
 //	guicontroller-&gt;AddText(selectString.c_str());
-	string s=ReadToken(selectString);
+	std::string s=ReadToken(selectString);
 
 	if(s==&quot;AllMap&quot;){
 		if (!gu-&gt;spectatingFullSelect) {
@@ -153,8 +153,8 @@
 			}
 		} else {
 			// all units
-			list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
-			for(list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
+			std::list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
+			for (std::list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
 				selection.push_back(*ui);
 			}
 		}
@@ -162,16 +162,16 @@
 		if (!gu-&gt;spectatingFullSelect) {
 			// team units in viewport
 			CUnitSet* tu=&amp;gs-&gt;Team(gu-&gt;myTeam)-&gt;units;
-			for(CUnitSet::iterator ui=tu-&gt;begin();ui!=tu-&gt;end();++ui){
-				if(camera-&gt;InView((*ui)-&gt;midPos,(*ui)-&gt;radius)){
+			for (CUnitSet::iterator ui=tu-&gt;begin();ui!=tu-&gt;end();++ui){
+				if (camera-&gt;InView((*ui)-&gt;midPos,(*ui)-&gt;radius)){
 					selection.push_back(*ui);
 				}
 			}
 		} else {
 		  // all units in viewport
-			list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
-			for(list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
-				if(camera-&gt;InView((*ui)-&gt;midPos,(*ui)-&gt;radius)){
+			std::list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
+			for (std::list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
+				if (camera-&gt;InView((*ui)-&gt;midPos,(*ui)-&gt;radius)){
 					selection.push_back(*ui);
 				}
 			}
@@ -193,8 +193,8 @@
 			}
 		} else {
 		  // all units in mouse range
-			list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
-			for(list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
+			std::list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
+			for(std::list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
 				if(mp.distance((*ui)-&gt;pos)&lt;maxDist){
 					selection.push_back(*ui);
 				}
@@ -213,7 +213,7 @@
 	ReadDelimiter(selectString);
 
 	while(true){
-		string s=ReadDelimiter(selectString);
+		std::string s=ReadDelimiter(selectString);
 		if(s==&quot;+&quot;)
 			break;
 
@@ -228,7 +228,7 @@
 		}
 
 		if(s==&quot;Builder&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if((*ui)-&gt;unitDef-&gt;buildSpeed&gt;0){
@@ -237,12 +237,12 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Building&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if(dynamic_cast&lt;CBuilding*&gt;(*ui)){
@@ -251,58 +251,58 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Commander&quot;){
 			unsigned int comCat=CCategoryHandler::Instance()-&gt;GetCategory(&quot;COMMANDER&quot;);
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui!=selection.end()) {
 				bool filterTrue=false;
-				if((*ui)-&gt;category &amp; comCat){	//fix with better test for commander
+				if ((*ui)-&gt;category &amp; comCat){	//fix with better test for commander
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not) {
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Transport&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if((*ui)-&gt;unitDef-&gt;transportCapacity&gt;0){
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not) {
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Aircraft&quot;){
 			unsigned int acCat=CCategoryHandler::Instance()-&gt;GetCategory(&quot;VTOL&quot;);
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
-				if((*ui)-&gt;category &amp; acCat){
+				if ((*ui)-&gt;category &amp; acCat){
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not) {
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Weapons&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if(!(*ui)-&gt;weapons.empty()){
@@ -311,7 +311,7 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
@@ -319,16 +319,16 @@
 			ReadDelimiter(selectString);
 			float minRange=atof(ReadToken(selectString).c_str());
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
-				if((*ui)-&gt;maxRange&gt;minRange){
+				if ((*ui)-&gt;maxRange&gt;minRange) {
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not) {
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
@@ -336,16 +336,16 @@
 			ReadDelimiter(selectString);
 			float minHealth=atof(ReadToken(selectString).c_str());
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
-				if((*ui)-&gt;health&gt;minHealth){
+				if ((*ui)-&gt;health&gt;minHealth){
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
@@ -353,7 +353,7 @@
 			ReadDelimiter(selectString);
 			float minHealth=atof(ReadToken(selectString).c_str())*0.01f;//convert from percent
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if((*ui)-&gt;health/(*ui)-&gt;maxHealth &gt; minHealth){
@@ -362,18 +362,18 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;InPrevSel&quot;){
-			set&lt;int&gt; prevTypes;
+			std::set&lt;int&gt; prevTypes;
 			CUnitSet* tu=&amp;selectedUnits.selectedUnits;
-			for(CUnitSet::iterator si=tu-&gt;begin();si!=tu-&gt;end();++si){
+			for (CUnitSet::iterator si=tu-&gt;begin();si!=tu-&gt;end();++si){
 				prevTypes.insert((*si)-&gt;aihint);
 			}
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if(prevTypes.find((*ui)-&gt;aihint)!=prevTypes.end()){		//should move away from aihint
 					filterTrue=true;
@@ -381,30 +381,30 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;NameContain&quot;){
 			ReadDelimiter(selectString);
-			string name=ReadToken(selectString);
+			std::string name=ReadToken(selectString);
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
-				if((*ui)-&gt;unitDef-&gt;humanName.find(name)!=string::npos){
+				if ((*ui)-&gt;unitDef-&gt;humanName.find(name)!=std::string::npos){
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Idle&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if((*ui)-&gt;commandAI-&gt;commandQue.empty()){
 					filterTrue=true;
@@ -412,13 +412,13 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Waiting&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if(!(*ui)-&gt;commandAI-&gt;commandQue.empty() &amp;&amp;
 				   ((*ui)-&gt;commandAI-&gt;commandQue.front().id == CMD_WAIT)){
@@ -427,13 +427,13 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;InHotkeyGroup&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if((*ui)-&gt;group){
 					filterTrue=true;
@@ -441,13 +441,13 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
-		} else if(s==&quot;Radar&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+		} else if (s == &quot;Radar&quot;) {
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if((*ui)-&gt;radarRadius || (*ui)-&gt;sonarRadius || (*ui)-&gt;jammerRadius){
 					filterTrue=true;
@@ -455,16 +455,16 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Category&quot;){
 			ReadDelimiter(selectString);
-			string catname=ReadToken(selectString);
+			std::string catname=ReadToken(selectString);
 			unsigned int cat=CCategoryHandler::Instance()-&gt;GetCategory(catname);
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if((*ui)-&gt;category==cat){
@@ -473,7 +473,7 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
@@ -495,7 +495,7 @@
 	}
 
 	if(s==&quot;SelectAll&quot;){
-		for(list&lt;CUnit*&gt;::iterator ui=selection.begin();ui!=selection.end();++ui)
+		for (std::list&lt;CUnit*&gt;::iterator ui=selection.begin();ui!=selection.end();++ui)
 			selectedUnits.AddUnit(*ui);
 	} else if(s==&quot;SelectOne&quot;){
 		if(selection.empty())
@@ -505,7 +505,7 @@
 
 		CUnit* sel = NULL;
 		int a=0;
-		for(list&lt;CUnit*&gt;::iterator ui=selection.begin();ui!=selection.end() &amp;&amp; a&lt;=selectNumber;++ui,++a)
+		for (std::list&lt;CUnit*&gt;::iterator ui=selection.begin();ui!=selection.end() &amp;&amp; a&lt;=selectNumber;++ui,++a)
 			sel=*ui;
 
 		if (sel == NULL)
@@ -538,10 +538,10 @@
 		if(selectNumber&gt;=selection.size())
 			selectNumber=0;
 
-		list&lt;CUnit*&gt;::iterator ui=selection.begin();
-		for(int a=0;a&lt;selectNumber;++a)
+		std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+		for (int a=0;a&lt;selectNumber;++a)
 			++ui;
-		for(int a=0;a&lt;num;++ui,++a){
+		for (int a=0;a&lt;num;++ui,++a){
 			if(ui==selection.end())
 				ui=selection.begin();
 			selectedUnits.AddUnit(*ui);
@@ -559,8 +559,8 @@
 		if(selectNumber&gt;=selection.size())
 			selectNumber=0;
 
-		list&lt;CUnit*&gt;::iterator ui=selection.begin();
-		for(int a=0;a&lt;selectNumber;++a)
+		std::list&lt;CUnit*&gt;::iterator ui = selection.begin();
+		for (int a = 0; a &lt; selectNumber; ++a)
 			++ui;
 		for(int a=0;a&lt;num;++ui,++a){
 			if(ui==selection.end())

Modified: branches/gml/rts/Game/UI/SelectionKeyHandler.h
===================================================================
--- branches/gml/rts/Game/UI/SelectionKeyHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/SelectionKeyHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,8 +4,6 @@
 #include &quot;InputReceiver.h&quot;
 #include &lt;vector&gt;
 
-using namespace std;
-
 class CSelectionKeyHandler :
 	public CInputReceiver
 {
@@ -14,8 +12,8 @@
 	~CSelectionKeyHandler(void);
 	bool KeyPressed(unsigned short key, bool isRepeat);
 	bool KeyReleased(unsigned short key);
-	string ReadToken(string&amp; s);
-	string ReadDelimiter(string&amp; s);
+	std::string ReadToken(std::string&amp; s);
+	std::string ReadDelimiter(std::string&amp; s);
 
 	struct HotKey {
 		unsigned char key;
@@ -23,10 +21,10 @@
 		bool control;
 		bool alt;
 
-		string select;
+		std::string select;
 	};
-	vector&lt;HotKey&gt; hotkeys;
-	void DoSelection(string selectString);
+	std::vector&lt;HotKey&gt; hotkeys;
+	void DoSelection(std::string selectString);
 
 	int selectNumber;	//used to go through all possible units when selecting only a few
 };

Modified: branches/gml/rts/Game/UI/ShareBox.cpp
===================================================================
--- branches/gml/rts/Game/UI/ShareBox.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/ShareBox.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -184,7 +184,7 @@
 		//if (gs-&gt;Team(actualTeam)-&gt;gaia) continue;
 
 		const float alpha = (shareTeam == actualTeam) ? 0.8f : 0.4f;
-		string teamName;
+		std::string teamName;
 
 		if (gs-&gt;Team(actualTeam)-&gt;leader &gt;= 0) {
 			teamName = gs-&gt;players[gs-&gt;Team(actualTeam)-&gt;leader]-&gt;playerName;
@@ -192,7 +192,7 @@
 			teamName = &quot;Uncontrolled&quot;;
 		}
 
-		string ally, dead;
+		std::string ally, dead;
 		if (gs-&gt;Ally(gu-&gt;myAllyTeam, gs-&gt;AllyTeam(actualTeam))) {
 			glColor4f(0.5f, 1.0f, 0.5f, alpha);
 			ally = &quot; &lt;Ally&gt;&quot;;
@@ -259,12 +259,12 @@
 		if(InBox(mx,my,box+okBox) || InBox(mx,my,box+applyBox) || InBox(mx,my,box+cancelBox) || InBox(mx,my,box+unitBox) || InBox(mx,my,box+metalBox) || InBox(mx,my,box+energyBox) || InBox(mx,my,box+teamBox))
 			moveBox=false;
 		if(InBox(mx,my,box+metalBox)){
-			metalMove=true;
-			metalShare=max(0.f,min(1.f,(mx-box.x1-metalBox.x1)/(metalBox.x2-metalBox.x1)));
+			metalMove = true;
+			metalShare = std::max(0.f, std::min(1.f,(mx-box.x1-metalBox.x1)/(metalBox.x2-metalBox.x1)));
 		}
 		if(InBox(mx,my,box+energyBox)){
-			energyMove=true;
-			energyShare=max(0.f,min(1.f,(mx-box.x1-energyBox.x1)/(energyBox.x2-energyBox.x1)));
+			energyMove = true;
+			energyShare = std::max(0.f, std::min(1.f,(mx-box.x1-energyBox.x1)/(energyBox.x2-energyBox.x1)));
 		}
 		if(InBox(mx,my,box+teamBox)){
 			int team=(int)((box.y1+teamBox.y2-my)/0.025f);
@@ -320,10 +320,10 @@
 		box.y2+=MouseMoveY(dy);
 	}
 	if(metalMove){
-		metalShare=max(0.f,min(1.f,(mx-box.x1-metalBox.x1)/(metalBox.x2-metalBox.x1)));
+		metalShare = std::max(0.f, std::min(1.f,(mx-box.x1-metalBox.x1)/(metalBox.x2-metalBox.x1)));
 	}
 	if(energyMove){
-		energyShare=max(0.f,min(1.f,(mx-box.x1-energyBox.x1)/(energyBox.x2-energyBox.x1)));
+		energyShare = std::max(0.f, std::min(1.f,(mx-box.x1-energyBox.x1)/(energyBox.x2-energyBox.x1)));
 	}
 	if(InBox(mx,my,box+teamBox)){
 		int team=(int)((box.y1+teamBox.y2-my)/0.025f);

Modified: branches/gml/rts/Game/UI/StartPosSelecter.cpp
===================================================================
--- branches/gml/rts/Game/UI/StartPosSelecter.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/StartPosSelecter.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -188,7 +188,7 @@
 	const float ySize = (readyBox.y2 - readyBox.y1);
 	const float xSize = (readyBox.x2 - readyBox.x1);
 
-	const float fontScale = 0.9f * min(xSize/unitWidth, ySize/unitHeight);
+	const float fontScale = 0.9f * std::min(xSize/unitWidth, ySize/unitHeight);
 	const float yPos = readyBox.y1 + (0.1f * ySize);
 	const float xPos = 0.5f * (readyBox.x1 + readyBox.x2);
 

Modified: branches/gml/rts/Game/UI/TooltipConsole.cpp
===================================================================
--- branches/gml/rts/Game/UI/TooltipConsole.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/UI/TooltipConsole.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,6 +9,9 @@
 #include &quot;Game/Team.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MetalMap.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -141,7 +144,7 @@
 	mMake += ud-&gt;metalMake;
 	eMake += ud-&gt;energyMake;
 	if (ud-&gt;tidalGenerator &gt; 0.0f) {
-		eMake += (ud-&gt;tidalGenerator * readmap-&gt;tidalStrength);
+		eMake += (ud-&gt;tidalGenerator * mapInfo-&gt;map.tidalStrength);
 	}
 
 	bool active;
@@ -333,7 +336,7 @@
 	}
 
 	char tmp[512];
-	CReadMap::TerrainType* tt = &amp;readmap-&gt;terrainTypes[readmap-&gt;typemap[min(gs-&gt;hmapx*gs-&gt;hmapy-1,max(0,((int)pos.z/16)*gs-&gt;hmapx+((int)pos.x/16)))]];
+	const CMapInfo::TerrainType* tt = &amp;mapInfo-&gt;terrainTypes[readmap-&gt;typemap[std::min(gs-&gt;hmapx*gs-&gt;hmapy-1, std::max(0,((int)pos.z/16)*gs-&gt;hmapx+((int)pos.x/16)))]];
 	string ttype = tt-&gt;name;
 	sprintf(tmp, &quot;Pos %.0f %.0f Elevation %.0f\nTerrain type: %s\n&quot;
 	             &quot;Speeds T/K/H/S %.2f %.2f %.2f %.2f\nHardness %.0f Metal %.1f&quot;,

Modified: branches/gml/rts/Game/WaitCommandsAI.cpp
===================================================================
--- branches/gml/rts/Game/WaitCommandsAI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/WaitCommandsAI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -653,7 +653,7 @@
 	static char buf[32];
 	if (enabled) {
 		const int remaining =
-			1 + (max(0, (endFrame - gs-&gt;frameNum - 1)) / GAME_SPEED);
+			1 + (std::max(0, (endFrame - gs-&gt;frameNum - 1)) / GAME_SPEED);
 		SNPRINTF(buf, sizeof(buf), &quot;%i&quot;, remaining);
 	} else {
 		SNPRINTF(buf, sizeof(buf), &quot;%i&quot;, duration / GAME_SPEED);
@@ -879,10 +879,10 @@
 {
 	units.clear();
 
-	const float3 mins(min(pos0.x, pos1.x), 0.0f, min(pos0.z, pos1.z));
-	const float3 maxs(max(pos0.x, pos1.x), 0.0f, max(pos0.z, pos1.z));
+	const float3 mins(std::min(pos0.x, pos1.x), 0.0f, std::min(pos0.z, pos1.z));
+	const float3 maxs(std::max(pos0.x, pos1.x), 0.0f, std::max(pos0.z, pos1.z));
 
-	vector&lt;CUnit*&gt; tmpUnits = qf-&gt;GetUnitsExact(mins, maxs);
+	std::vector&lt;CUnit*&gt; tmpUnits = qf-&gt;GetUnitsExact(mins, maxs);
 
 	const int count = (int)tmpUnits.size();
 	for (int i = 0; i &lt; count; i++) {

Modified: branches/gml/rts/Game/WaitCommandsAI.h
===================================================================
--- branches/gml/rts/Game/WaitCommandsAI.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/WaitCommandsAI.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -72,7 +72,7 @@
 				virtual void Update() = 0;
 				virtual void Draw() const { return; }
 				virtual void AddUnitPosition(const float3&amp; pos) const { return; }
-				virtual const string&amp; GetStateText() const { return noText; }
+				virtual const std::string&amp; GetStateText() const { return noText; }
 			public:
 				time_t GetDeadTime() const { return deadTime; }
 				float GetCode() const { return code; }
@@ -99,7 +99,7 @@
 				static KeyType GetNewKey();
 			private:
 				static KeyType keySource;
-				static const string noText;
+				static const std::string noText;
 				void PostLoad();
 		};
 
@@ -115,7 +115,7 @@
 				void RemoveUnit(CUnit* unit);
 				void Update();
 				void Draw() const;
-				const string&amp; GetStateText() const;
+				const std::string&amp; GetStateText() const;
 				int GetDuration() const { return duration; }
 			private:
 				TimeWait(const Command&amp; cmd, CUnit* unit);

Modified: branches/gml/rts/Game/WordCompletion.cpp
===================================================================
--- branches/gml/rts/Game/WordCompletion.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/WordCompletion.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -30,12 +30,14 @@
 
 	// local commands
 	words[&quot;/advshading &quot;] = sl;
+	words[&quot;/hardwarecursor &quot;] = sl;
 	words[&quot;/clock&quot;] = sl;
 	words[&quot;/cmdcolors &quot;] = sl;
 	words[&quot;/ctrlpanel &quot;] = sl;
 	words[&quot;/echo &quot;] = sl;
 	words[&quot;/font &quot;] = sl;
 	words[&quot;/gameinfo&quot;] = sl;
+	words[&quot;/grounddecals &quot;] = sl;
 	words[&quot;/info &quot;] = sl;
 	words[&quot;/luaui &quot;] = sl;
 	words[&quot;/maxparticles &quot;] = sl;
@@ -58,12 +60,15 @@
 	words[&quot;/keydebug&quot;] = sl;
 	words[&quot;/fakemeta &quot;] = sl;
 	words[&quot;/volume &quot;] = sl;
+	words[&quot;/unitreplyvolume &quot;] = sl;
 	words[&quot;/vsync &quot;] = sl;
+	words[&quot;/wiremap &quot;] = sl;
 
 	// minimap sub-commands
 	WordProperties mm(false, false, true);
 	words[&quot;fullproxy &quot;] = mm;
 	words[&quot;drawcommands &quot;] = mm;
+	words[&quot;drawprojectiles &quot;] = mm;
 	words[&quot;icons &quot;] = mm;
 	words[&quot;unitexp &quot;] = mm;
 	words[&quot;unitsize &quot;] = mm;
@@ -102,7 +107,7 @@
 }
 
 
-void CWordCompletion::AddWord(const string&amp; word,
+void CWordCompletion::AddWord(const std::string&amp; word,
                               bool startOfLine, bool unitName, bool minimap)
 {
 	if (!word.empty()) {
@@ -112,15 +117,15 @@
 }
 
 
-vector&lt;string&gt; CWordCompletion::Complete(string&amp; msg) const
+std::vector&lt;std::string&gt; CWordCompletion::Complete(std::string&amp; msg) const
 {
-	vector&lt;string&gt; partials;
+	std::vector&lt;std::string&gt; partials;
 
 	const bool unitName = (msg.find(&quot;/give &quot;) == 0);
 	const bool minimap = (msg.find(&quot;/minimap &quot;) == 0);
 	  
 	// strip &quot;a:&quot; and &quot;s:&quot; prefixes
-	string prefix, rawmsg;
+	std::string prefix, rawmsg;
 	if ((msg.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (msg[1] == ':')) {
 		prefix = msg.substr(0, 2);
 		rawmsg = msg.substr(2);
@@ -129,21 +134,21 @@
 	}
 
 	// the word fragment
-	string::size_type startPos = rawmsg.find_last_of(' ');
-	const bool startOfLine = (startPos == string::npos);
+	std::string::size_type startPos = rawmsg.find_last_of(' ');
+	const bool startOfLine = (startPos == std::string::npos);
 	startPos = startOfLine ? 0 : startPos + 1;
-	const string fragment(rawmsg, startPos, string::npos);
+	const std::string fragment(rawmsg, startPos, std::string::npos);
 	if (fragment.empty()) {
 		return partials;
 	}
-	const string::size_type fragLen = fragment.size();
+	const std::string::size_type fragLen = fragment.size();
 
 	// pick a decent spot to start scanning
-	map&lt;string,WordProperties&gt;::const_iterator start;
+	std::map&lt;std::string, WordProperties&gt;::const_iterator start;
 	start = words.lower_bound(fragment);
 
 	// make a list of valid possible matches
-	map&lt;string,WordProperties&gt;::const_iterator it;
+	std::map&lt;std::string, WordProperties&gt;::const_iterator it;
 	for (it = start; it != words.end(); it++) {
 		const int cmp = it-&gt;first.compare(0, fragLen, fragment);
 		if (cmp &lt; 0) continue;
@@ -154,28 +159,28 @@
 			partials.push_back(it-&gt;first);
 		}
 	}
-	  
+
 	if (partials.empty()) {
 		return partials; // no possible matches
 	}
-	  
+
 	if (partials.size() == 1) {
 		msg = prefix + rawmsg.substr(0, startPos) + partials[0];
 		partials.clear();
 		return partials; // single match
 	}
-	  
+
 	// add as much of the match as possible
-	const string&amp; firstStr = partials[0];
-	const string&amp; lastStr = partials[partials.size() - 1];
+	const std::string&amp; firstStr = partials[0];
+	const std::string&amp; lastStr = partials[partials.size() - 1];
 	unsigned int i = 0;
-	unsigned int least = min(firstStr.size(), lastStr.size());
+	unsigned int least = std::min(firstStr.size(), lastStr.size());
 	for (i = 0; i &lt; least; i++) {
 		if (firstStr[i] != lastStr[i]) {
 			break;
 		}
 	}
 	msg = prefix + rawmsg.substr(0, startPos) + partials[0].substr(0, i);
-	  
+
 	return partials;
 }

Modified: branches/gml/rts/Game/WordCompletion.h
===================================================================
--- branches/gml/rts/Game/WordCompletion.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Game/WordCompletion.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -8,17 +8,15 @@
 #include &lt;vector&gt;
 #include &lt;map&gt;
 
-using namespace std;
-
 class CWordCompletion
 {
 	public:
 		CWordCompletion();
 		~CWordCompletion();
 		void Reset();
-		void AddWord(const string&amp; word,
+		void AddWord(const std::string&amp; word,
 		             bool startOfLine, bool unitName, bool minimap);
-		vector&lt;string&gt; Complete(string&amp; msg) const; // returns partial matches
+		std::vector&lt;std::string&gt; Complete(std::string&amp; msg) const; // returns partial matches
 
 	protected:
 		class WordProperties {
@@ -32,7 +30,7 @@
 				bool unitName;
 				bool minimap;
 		};
-		map&lt;string, WordProperties&gt; words;
+		std::map&lt;std::string, WordProperties&gt; words;
 };
 
 #endif /* WORD_COMPLETION_H */


Property changes on: branches/gml/rts/Lua/LuaCallInCheck.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Lua/LuaCallInCheck.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Lua/LuaCallInHandler.cpp
===================================================================
--- branches/gml/rts/Lua/LuaCallInHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaCallInHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -19,6 +19,8 @@
 
 CLuaCallInHandler::CLuaCallInHandler()
 {
+	callInMap[&quot;GamePreload&quot;]         = &listGamePreload;
+	callInMap[&quot;GameStart&quot;]    = &listGameStart;
 	callInMap[&quot;GameOver&quot;]            = &listGameOver;
 	callInMap[&quot;TeamDied&quot;]            = &listTeamDied;
 
@@ -83,6 +85,8 @@
 #define ADDHANDLE(name) \
   if (lh-&gt;HasCallIn(#name)) { ListInsert(list ## name, lh); }
   
+	ADDHANDLE(GamePreload);
+	ADDHANDLE(GameStart);
 	ADDHANDLE(GameOver);
 	ADDHANDLE(TeamDied);
 
@@ -137,6 +141,8 @@
 {
 	ListRemove(handles, lh);
 
+	ListRemove(listGamePreload, lh);
+	ListRemove(listGameStart, lh);
 	ListRemove(listGameOver, lh);
 	ListRemove(listTeamDied, lh);
 
@@ -276,6 +282,24 @@
 /******************************************************************************/
 /******************************************************************************/
 
+void CLuaCallInHandler::GamePreload()
+{
+	const int count = listGamePreload.size();
+	for (int i = 0; i &lt; count; i++) {
+		CLuaHandle* lh = listGamePreload[i];
+		lh-&gt;GamePreload();
+	}	
+}
+
+void CLuaCallInHandler::GameStart()
+{
+	const int count = listGameStart.size();
+	for (int i = 0; i &lt; count; i++) {
+		CLuaHandle* lh = listGameStart[i];
+		lh-&gt;GameStart();
+	}	
+}
+
 void CLuaCallInHandler::GameOver()
 {
 	const int count = listGameOver.size();

Modified: branches/gml/rts/Lua/LuaCallInHandler.h
===================================================================
--- branches/gml/rts/Lua/LuaCallInHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaCallInHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -40,6 +40,8 @@
 
 	public:
 		// Synced
+		void GamePreload();
+		void GameStart();
 		void GameOver();
 		void TeamDied(int teamID);
 
@@ -107,6 +109,8 @@
 
 		CallInList handles;
 
+		CallInList listGamePreload;
+		CallInList listGameStart;
 		CallInList listGameOver;
 		CallInList listTeamDied;
 

Modified: branches/gml/rts/Lua/LuaConstGame.cpp
===================================================================
--- branches/gml/rts/Lua/LuaConstGame.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaConstGame.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,6 +12,7 @@
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/GameVersion.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
@@ -22,9 +23,6 @@
 #include &quot;System/FileSystem/ArchiveScanner.h&quot;
 
 
-extern GLfloat FogLand[];
-
-
 /******************************************************************************/
 /******************************************************************************/
 
@@ -42,12 +40,11 @@
 
 bool LuaConstGame::PushEntries(lua_State* L)
 {
-	const float gravity = -(gs-&gt;gravity * GAME_SPEED * GAME_SPEED);
+	const float gravity = -(mapInfo-&gt;map.gravity * GAME_SPEED * GAME_SPEED);
 	const bool limitDGun        = gameSetup ? gameSetup-&gt;limitDgun        : false;
 	const bool diminishingMMs   = gameSetup ? gameSetup-&gt;diminishingMMs   : false;
 	const bool ghostedBuildings = gameSetup ? gameSetup-&gt;ghostedBuildings : false;
 	const int  startPosType     = gameSetup ? gameSetup-&gt;startPosType     : 0;
-	const float3 fogColor(FogLand[0], FogLand[1], FogLand[2]);
 
 	LuaPushNamedString(L, &quot;version&quot;,       VERSION_STRING);
 
@@ -69,23 +66,29 @@
 	LuaPushNamedNumber(L, &quot;gravity&quot;,           gravity);
 	LuaPushNamedNumber(L, &quot;windMin&quot;,           wind.GetMinWind());
 	LuaPushNamedNumber(L, &quot;windMax&quot;,           wind.GetMaxWind());
-	LuaPushNamedString(L, &quot;mapName&quot;,           readmap-&gt;mapName);
-	LuaPushNamedString(L, &quot;mapHumanName&quot;,      readmap-&gt;mapHumanName);
+	LuaPushNamedString(L, &quot;mapName&quot;,           mapInfo-&gt;map.name);
+	LuaPushNamedString(L, &quot;mapHumanName&quot;,      mapInfo-&gt;map.humanName);
 	LuaPushNamedNumber(L, &quot;mapX&quot;,              readmap-&gt;width  / 64);
 	LuaPushNamedNumber(L, &quot;mapY&quot;,              readmap-&gt;height / 64);
 	LuaPushNamedNumber(L, &quot;mapSizeX&quot;,          readmap-&gt;width  * SQUARE_SIZE);
 	LuaPushNamedNumber(L, &quot;mapSizeZ&quot;,          readmap-&gt;height * SQUARE_SIZE);
-	LuaPushNamedNumber(L, &quot;extractorRadius&quot;,   readmap-&gt;extractorRadius);
-	LuaPushNamedNumber(L, &quot;tidal&quot;,             readmap-&gt;tidalStrength);
-	LuaPushNamedString(L, &quot;waterTexture&quot;,      readmap-&gt;waterTexture);
-	LuaPushNamedBool(L,   &quot;waterVoid&quot;,         readmap-&gt;voidWater);
-	LuaPushNamedBool(L,   &quot;waterPlane&quot;,        readmap-&gt;hasWaterPlane);
-	LuaPushNamedColor(L,  &quot;waterAbsorb&quot;,       readmap-&gt;waterAbsorb);
-	LuaPushNamedColor(L,  &quot;waterBaseColor&quot;,    readmap-&gt;waterBaseColor);
-	LuaPushNamedColor(L,  &quot;waterMinColor&quot;,     readmap-&gt;waterMinColor);
-	LuaPushNamedColor(L,  &quot;waterSurfaceColor&quot;, readmap-&gt;waterSurfaceColor);
-	LuaPushNamedColor(L,  &quot;waterPlaneColor&quot;,   readmap-&gt;waterPlaneColor);
-	LuaPushNamedColor(L,  &quot;fogColor&quot;,          fogColor);
+	LuaPushNamedNumber(L, &quot;extractorRadius&quot;,   mapInfo-&gt;map.extractorRadius);
+	LuaPushNamedNumber(L, &quot;tidal&quot;,             mapInfo-&gt;map.tidalStrength);
+	LuaPushNamedString(L, &quot;waterTexture&quot;,      mapInfo-&gt;water.texture);
+	LuaPushNamedBool(L,   &quot;waterVoid&quot;,         mapInfo-&gt;map.voidWater);
+	LuaPushNamedBool(L,   &quot;waterPlane&quot;,        mapInfo-&gt;hasWaterPlane);
+	LuaPushNamedColor(L,  &quot;waterAbsorb&quot;,       mapInfo-&gt;water.absorb);
+	LuaPushNamedColor(L,  &quot;waterBaseColor&quot;,    mapInfo-&gt;water.baseColor);
+	LuaPushNamedColor(L,  &quot;waterMinColor&quot;,     mapInfo-&gt;water.minColor);
+	LuaPushNamedColor(L,  &quot;waterSurfaceColor&quot;, mapInfo-&gt;water.surfaceColor);
+	LuaPushNamedNumber(L, &quot;waterSurfaceAlpha&quot;, mapInfo-&gt;water.surfaceAlpha);
+	LuaPushNamedColor(L,  &quot;waterSpecularColor&quot;,  mapInfo-&gt;water.specularColor);
+	LuaPushNamedNumber(L, &quot;waterSpecularFactor&quot;, mapInfo-&gt;water.specularFactor);
+	LuaPushNamedColor(L,  &quot;waterPlaneColor&quot;,   mapInfo-&gt;water.planeColor);
+	LuaPushNamedColor(L,  &quot;fogColor&quot;,          mapInfo-&gt;atmosphere.fogColor);
+	LuaPushNamedColor(L,  &quot;groundAmbientColor&quot;,      mapInfo-&gt;light.groundAmbientColor);
+	LuaPushNamedColor(L,  &quot;groundSpecularColor&quot;,     mapInfo-&gt;light.groundSpecularColor);
+	LuaPushNamedColor(L,  &quot;groundSunColor&quot;,          mapInfo-&gt;light.groundSunColor);
 
 	LuaPushNamedString(L, &quot;modName&quot;,         modInfo.humanName);
 	LuaPushNamedString(L, &quot;modShortName&quot;,    modInfo.shortName);
@@ -105,7 +108,7 @@
 
 	char buf[64];
 	SNPRINTF(buf, sizeof(buf), &quot;0x%08X&quot;,
-	         archiveScanner-&gt;GetMapChecksum(readmap-&gt;mapName));
+	         archiveScanner-&gt;GetMapChecksum(mapInfo-&gt;map.name));
 	LuaPushNamedString(L, &quot;mapChecksum&quot;, buf);
 	SNPRINTF(buf, sizeof(buf), &quot;0x%08X&quot;,
 	         archiveScanner-&gt;GetModChecksum(modInfo.filename));

Modified: branches/gml/rts/Lua/LuaFeatureDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaFeatureDefs.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaFeatureDefs.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -283,51 +283,7 @@
 
 static int Next(lua_State* L)
 {
-	luaL_checktype(L, 1, LUA_TTABLE);
-	lua_settop(L, 2); // create a 2nd argument if there isn't one
-
-	// internal parameters first
-	if (lua_isnil(L, 2)) {
-		const string&amp; nextKey = paramMap.begin()-&gt;first;
-		lua_pushstring(L, nextKey.c_str()); // push the key
-		lua_pushvalue(L, 3);                // copy the key
-		lua_gettable(L, 1);                 // get the value
-		return 2;
-	}
-
-	// all internal parameters use strings as keys
-	if (lua_isstring(L, 2)) {
-		const char* key = lua_tostring(L, 2);
-		ParamMap::const_iterator it = paramMap.find(key);
-		if ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type != READONLY_TYPE)) {
-			// last key was an internal parameter
-			it++;
-			while ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type == READONLY_TYPE)) {
-				it++; // skip read-only parameters
-			}
-			if ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type != READONLY_TYPE)) {
-				// next key is an internal parameter
-				const string&amp; nextKey = it-&gt;first;
-				lua_pushstring(L, nextKey.c_str()); // push the key
-				lua_pushvalue(L, 3);                // copy the key
-				lua_gettable(L, 1);                 // get the value (proxied)
-				return 2;
-			}
-			// start the user parameters,
-			// remove the internal key and push a nil
-			lua_settop(L, 1);
-			lua_pushnil(L);
-		}
-	}
-
-	// user parameter
-	if (lua_next(L, 1)) {
-		return 2;
-	}
-
-	// end of the line
-	lua_pushnil(L);
-	return 1;
+	return LuaUtils::Next(paramMap, L);
 }
 
 

Modified: branches/gml/rts/Lua/LuaHandle.cpp
===================================================================
--- branches/gml/rts/Lua/LuaHandle.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaHandle.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -202,7 +202,34 @@
 	return;
 }
 
+void CLuaHandle::GamePreload()
+{
+	LUA_CALL_IN_CHECK(L);	
+	lua_checkstack(L, 2);
+	static const LuaHashString cmdStr(&quot;GamePreload&quot;);
+	if (!cmdStr.GetGlobalFunc(L)) {
+		return; // the call is not defined
+	}
 
+	// call the routine
+	RunCallIn(cmdStr, 0, 0);
+	return;
+}
+
+void CLuaHandle::GameStart()
+{
+	LUA_CALL_IN_CHECK(L);	
+	lua_checkstack(L, 2);
+	static const LuaHashString cmdStr(&quot;GameStart&quot;);
+	if (!cmdStr.GetGlobalFunc(L)) {
+		return; // the call is not defined
+	}
+
+	// call the routine
+	RunCallIn(cmdStr, 0, 0);
+	return;
+}
+
 void CLuaHandle::GameOver()
 {
 	LUA_CALL_IN_CHECK(L);	

Modified: branches/gml/rts/Lua/LuaHandle.h
===================================================================
--- branches/gml/rts/Lua/LuaHandle.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaHandle.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -100,6 +100,8 @@
 
 		void Shutdown();
 
+		void GamePreload();
+		void GameStart();
 		void GameOver();
 		void TeamDied(int teamID);
 

Modified: branches/gml/rts/Lua/LuaHandleSynced.cpp
===================================================================
--- branches/gml/rts/Lua/LuaHandleSynced.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaHandleSynced.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -651,7 +651,6 @@
 	}
 
 	// get the result
-	const int args = lua_gettop(L);
 	if (!lua_isstring(L, -1)) {
 		lua_pop(L, 1);
 		return syncData;
@@ -914,7 +913,7 @@
 	else if ((args == 1) &amp;&amp; lua_isnumber(L, 1)) {
 		const int maxn = (int)lua_tonumber(L, 1);
 		if (maxn &lt; 1) {
-			luaL_error(L, &quot;small integer(%i) given to math.random() {synced}&quot;, maxn);
+			luaL_error(L, &quot;error: too small upper limit (%d) given to math.random(), should be &gt;= 1 {synced}&quot;, maxn);
 		}
 		lua_pushnumber(L, 1 + (gs-&gt;randInt() % maxn));
 	}
@@ -927,7 +926,7 @@
 		const float diff  = (upper - lower);
 		const float r = gs-&gt;randFloat(); // [0,1], not [0,1) ?
 		int value = lower + (int)(r * (diff + 1));
-		value = max(lower, min(upper, value));
+		value = std::max(lower, std::min(upper, value));
 		lua_pushnumber(L, value);
 	}
 	else {
@@ -972,7 +971,7 @@
 		    !lua_isnumber(L, i) &amp;&amp;
 		    !lua_isstring(L, i) &amp;&amp;
 		    !lua_isboolean(L, i)) {
-			luaL_error(L, &quot;Incorrect data type for SendToUnsynced(), arg %i&quot;, i);
+			luaL_error(L, &quot;Incorrect data type for SendToUnsynced(), arg %d&quot;, i);
 		}
 	}
 	CLuaHandleSynced* lhs = GetActiveHandle();

Modified: branches/gml/rts/Lua/LuaMaterial.cpp
===================================================================
--- branches/gml/rts/Lua/LuaMaterial.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaMaterial.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -121,7 +121,7 @@
 
 bool LuaUnitMaterial::SetLastLOD(unsigned int lod)
 {
-	lastLOD = min(lod, lodCount - 1);
+	lastLOD = std::min(lod, lodCount - 1);
 	return true;
 }
 
@@ -331,7 +331,7 @@
 		glUniformMatrix4fv(cameraLoc, 1, GL_FALSE, array);
 	}
 
-	const int maxTex = max(texCount, prev.texCount);
+	const int maxTex = std::max(texCount, prev.texCount);
 	for (int t = 0; t &lt; maxTex; t++) {
 		glActiveTexture(GL_TEXTURE0 + t);
 		textures[t].Execute(prev.textures[t]);
@@ -367,7 +367,7 @@
 		return cmp;
 	}
 
-	const int maxTex = min(a.texCount, b.texCount);
+	const int maxTex = std::min(a.texCount, b.texCount);
 	for (int t = 0; t &lt; maxTex; t++) {
 		cmp = LuaMatTexture::Compare(a.textures[t], b.textures[t]);
 		if (cmp != 0) {

Modified: branches/gml/rts/Lua/LuaOpenGL.cpp
===================================================================
--- branches/gml/rts/Lua/LuaOpenGL.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaOpenGL.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -32,6 +32,7 @@
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/UI/CommandColors.h&quot;
 #include &quot;Game/UI/MiniMap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Map/HeightMapTexture.h&quot;
 #include &quot;Rendering/glFont.h&quot;
@@ -68,11 +69,6 @@
 static const int MAX_TEXTURE_UNITS = 32;
 
 
-// from Game.cpp
-extern GLfloat LightDiffuseLand[];
-extern GLfloat LightAmbientLand[];
-
-
 /******************************************************************************/
 /******************************************************************************/
 
@@ -796,7 +792,7 @@
 void LuaOpenGL::SetupWorldLighting()
 {
 	glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
-	glLightfv(GL_LIGHT1, GL_POSITION, gs-&gt;sunVector4);
+	glLightfv(GL_LIGHT1, GL_POSITION, mapInfo-&gt;light.sunDir);
 	glEnable(GL_LIGHT1);
 }
 
@@ -876,12 +872,12 @@
 	// sun light -- needs the camera transformation
 	glPushMatrix();
 	glLoadMatrixd(camera-&gt;GetModelview());
-	glLightfv(GL_LIGHT1, GL_POSITION, gs-&gt;sunVector4);
+	glLightfv(GL_LIGHT1, GL_POSITION, mapInfo-&gt;light.sunDir);
 
 	const float sunFactor = 1.0f;
 	const float sf = sunFactor;
-	const float* la = LightAmbientLand;
-	const float* ld = LightDiffuseLand;
+	const float* la = mapInfo-&gt;light.unitAmbientColor;
+	const float* ld = mapInfo-&gt;light.unitSunColor;
 
 	const float sunLightAmbt[4] = { la[0]*sf, la[1]*sf, la[2]*sf, la[3]*sf };
 	const float sunLightDiff[4] = { ld[0]*sf, ld[1]*sf, ld[2]*sf, ld[3]*sf };
@@ -1292,7 +1288,7 @@
 			if (tmpLod &lt; 0) {
 				useLOD = false;
 			} else {
-				lod = min(unit-&gt;lodCount - 1, (unsigned int)tmpLod);
+				lod = std::min(unit-&gt;lodCount - 1, (unsigned int)tmpLod);
 			}
 		}
 		unit-&gt;currentLOD = lod;
@@ -1353,7 +1349,7 @@
 			if (tmpLod &lt; 0) {
 				useLOD = false;
 			} else {
-				lod = min(unit-&gt;lodCount - 1, (unsigned int)tmpLod);
+				lod = std::min(unit-&gt;lodCount - 1, (unsigned int)tmpLod);
 			}
 		}
 		unit-&gt;currentLOD = lod;
@@ -1746,7 +1742,7 @@
 	const int divs =   (int)lua_tonumber(L, 5);
 
 	if ((args &gt;= 6) &amp;&amp; lua_isnumber(L, 6)) {
-		const float slope = (float)lua_tonumber(L, 6);
+		// const float slope = (float) lua_tonumber(L, 6);
 		glBallisticCircle(pos, r, NULL, divs);
 	} else {
 		glSurfaceCircle(pos, r, divs);
@@ -1796,14 +1792,14 @@
 	const int mapzi = (gs-&gt;mapy + 1);
 	const float* heightmap = readmap-&gt;GetHeightmap();
 
-	const float xs = max(0.0f, min(float3::maxxpos, x0)); // x start
-	const float xe = max(0.0f, min(float3::maxxpos, x1)); // x end
-	const float zs = max(0.0f, min(float3::maxzpos, z0)); // z start
-	const float ze = max(0.0f, min(float3::maxzpos, z1)); // z end
-	const int xis = max(0, min(mapxi, int((xs + 0.5f) / SQUARE_SIZE)));
-	const int xie = max(0, min(mapxi, int((xe + 0.5f) / SQUARE_SIZE)));
-	const int zis = max(0, min(mapzi, int((zs + 0.5f) / SQUARE_SIZE)));
-	const int zie = max(0, min(mapzi, int((ze + 0.5f) / SQUARE_SIZE)));
+	const float xs = std::max(0.0f, std::min(float3::maxxpos, x0)); // x start
+	const float xe = std::max(0.0f, std::min(float3::maxxpos, x1)); // x end
+	const float zs = std::max(0.0f, std::min(float3::maxzpos, z0)); // z start
+	const float ze = std::max(0.0f, std::min(float3::maxzpos, z1)); // z end
+	const int xis = std::max(0, std::min(mapxi, int((xs + 0.5f) / SQUARE_SIZE)));
+	const int xie = std::max(0, std::min(mapxi, int((xe + 0.5f) / SQUARE_SIZE)));
+	const int zis = std::max(0, std::min(mapzi, int((zs + 0.5f) / SQUARE_SIZE)));
+	const int zie = std::max(0, std::min(mapzi, int((ze + 0.5f) / SQUARE_SIZE)));
 	if ((xis &gt;= xie) || (zis &gt;= zie)) {
 		return 0;
 	}
@@ -4807,17 +4803,17 @@
 {
 	const int args = lua_gettop(L); // number of arguments
 	if (args == 0) {
-		lua_pushnumber(L, gs-&gt;sunVector4[0]);
-		lua_pushnumber(L, gs-&gt;sunVector4[1]);
-		lua_pushnumber(L, gs-&gt;sunVector4[2]);
+		lua_pushnumber(L, mapInfo-&gt;light.sunDir[0]);
+		lua_pushnumber(L, mapInfo-&gt;light.sunDir[1]);
+		lua_pushnumber(L, mapInfo-&gt;light.sunDir[2]);
 		return 3;
 	}
 
 	const string param = luaL_checkstring(L, 1);
 	if (param == &quot;pos&quot;) {
-		lua_pushnumber(L, gs-&gt;sunVector4[0]);
-		lua_pushnumber(L, gs-&gt;sunVector4[1]);
-		lua_pushnumber(L, gs-&gt;sunVector4[2]);
+		lua_pushnumber(L, mapInfo-&gt;light.sunDir[0]);
+		lua_pushnumber(L, mapInfo-&gt;light.sunDir[1]);
+		lua_pushnumber(L, mapInfo-&gt;light.sunDir[2]);
 		return 3;
 	}
 
@@ -4828,7 +4824,7 @@
 
 	if (param == &quot;shadowDensity&quot;) {
 		if (!unitMode) {
-			lua_pushnumber(L, readmap-&gt;shadowDensity);
+			lua_pushnumber(L, mapInfo-&gt;light.groundShadowDensity);
 		} else {
 			lua_pushnumber(L, unitDrawer-&gt;unitShadowDensity);
 		}
@@ -4836,21 +4832,21 @@
 	}
 	else if (param == &quot;diffuse&quot;) {
 		if (!unitMode) {
-			data = &amp;readmap-&gt;sunColor;
+			data = &amp;mapInfo-&gt;light.groundSunColor;
 		} else {
 			data = &amp;unitDrawer-&gt;unitSunColor;
 		}
 	}
 	else if (param == &quot;ambient&quot;) {
 		if (!unitMode) {
-			data = &amp;readmap-&gt;sunColor;
+			data = &amp;mapInfo-&gt;light.groundSunColor;
 		} else {
 			data = &amp;unitDrawer-&gt;unitAmbientColor;
 		}
 	}
 	else if (param == &quot;specular&quot;) {
 		if (!unitMode) {
-			data = &amp;readmap-&gt;specularColor;
+			data = &amp;mapInfo-&gt;light.groundSpecularColor;
 		}
 	}
 

Modified: branches/gml/rts/Lua/LuaParser.cpp
===================================================================
--- branches/gml/rts/Lua/LuaParser.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaParser.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -375,58 +375,7 @@
 
 int LuaParser::Echo(lua_State* L)
 {
-	// copied from lua/src/lib/lbaselib.c
-	string msg = &quot;&quot;;
-	const int args = lua_gettop(L); // number of arguments
-
-	lua_getglobal(L, &quot;tostring&quot;);
-
-	for (int i = 1; i &lt;= args; i++) {
-		const char *s;
-		lua_pushvalue(L, -1);     // function to be called
-		lua_pushvalue(L, i);      // value to print
-		lua_call(L, 1, 1);
-		s = lua_tostring(L, -1);  // get result
-		if (s == NULL) {
-			return luaL_error(L, &quot;`tostring' must return a string to `print'&quot;);
-		}
-		if (i &gt; 1) {
-			msg += &quot;, &quot;;
-		}
-		msg += s;
-		lua_pop(L, 1);            // pop result
-	}
-	logOutput.Print(msg);
-
-	if ((args != 1) || !lua_istable(L, 1)) {
-		return 0;
-	}
-
-	// print solo tables (array style)
-	msg = &quot;TABLE: &quot;;
-	bool first = true;
-	const int table = 1;
-	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
-		if (lua_israwnumber(L, -2)) {  // only numeric keys
-			const char *s;
-			lua_pushvalue(L, -3);     // function to be called
-			lua_pushvalue(L, -2	);    // value to print
-			lua_call(L, 1, 1);
-			s = lua_tostring(L, -1);  // get result
-			if (s == NULL) {
-				return luaL_error(L, &quot;`tostring' must return a string to `print'&quot;);
-			}
-			if (!first) {
-				msg += &quot;, &quot;;
-			}
-			msg += s;
-			first = false;
-			lua_pop(L, 1);            // pop result
-		}
-	}
-	logOutput.Print(msg);
-
-	return 0;
+	return LuaUtils::Echo(L);
 }
 
 

Modified: branches/gml/rts/Lua/LuaRules.cpp
===================================================================
--- branches/gml/rts/Lua/LuaRules.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaRules.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -946,7 +946,7 @@
 	}
 
 	// get the results
-	const int retArgs = min(lua_gettop(L) - top, (MAX_LUA_COB_ARGS - 1));
+	const int retArgs = std::min(lua_gettop(L) - top, (MAX_LUA_COB_ARGS - 1));
 	for (int a = 1; a &lt;= retArgs; a++) {
 		const int index = (a + top);
 		if (lua_isnumber(L, index)) {

Modified: branches/gml/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- branches/gml/rts/Lua/LuaSyncedCtrl.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaSyncedCtrl.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -25,11 +25,13 @@
 #include &quot;Game/Team.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Rendering/Env/BaseTreeDrawer.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Misc/DamageArray.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
@@ -127,6 +129,8 @@
 	REGISTER_LUA_CFUNC(SetUnitLineage);
 	REGISTER_LUA_CFUNC(SetUnitNeutral);
 	REGISTER_LUA_CFUNC(SetUnitTarget);
+	REGISTER_LUA_CFUNC(SetUnitCollisionVolumeData);
+
 	REGISTER_LUA_CFUNC(SetUnitPhysics);
 	REGISTER_LUA_CFUNC(SetUnitPosition);
 	REGISTER_LUA_CFUNC(SetUnitVelocity);
@@ -146,6 +150,7 @@
 	REGISTER_LUA_CFUNC(SetFeaturePosition);
 	REGISTER_LUA_CFUNC(SetFeatureDirection);
 	REGISTER_LUA_CFUNC(SetFeatureNoSelect);
+	REGISTER_LUA_CFUNC(SetFeatureCollisionVolumeData);
 
 	REGISTER_LUA_CFUNC(CallCOBScript);
 	REGISTER_LUA_CFUNC(CallCOBScriptCB);
@@ -260,7 +265,7 @@
 	}
 	const int unitID = (int)lua_tonumber(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
-		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
+		luaL_error(L, &quot;%s(): Bad unitID: %d\n&quot;, caller, unitID);
 	}
 	CUnit* unit = uh-&gt;units[unitID];
 	if (unit == NULL) {
@@ -311,7 +316,7 @@
 	}
 	const int teamID = (int)lua_tonumber(L, index);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
-		luaL_error(L, &quot;%s(): Bad teamID: %i&quot;, caller, teamID);
+		luaL_error(L, &quot;%s(): Bad teamID: %d&quot;, caller, teamID);
 	}
 	CTeam* team = gs-&gt;Team(teamID);
 	if (team == NULL) {
@@ -326,11 +331,11 @@
 	luaL_checknumber(L, index);
 	const int unitID = (int)lua_tonumber(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
-		luaL_error(L, &quot;Bad unitID: %i\n&quot;, unitID);
+		luaL_error(L, &quot;Bad unitID: %d\n&quot;, unitID);
 	}
 	CUnit* unit = uh-&gt;units[unitID];
 	if (unit == NULL) {
-		luaL_error(L, &quot;Bad unitID: %i\n&quot;, unitID);
+		luaL_error(L, &quot;Bad unitID: %d\n&quot;, unitID);
 	}
 	return unit;
 }
@@ -341,11 +346,11 @@
 	luaL_checknumber(L, index);
 	const int playerID = (int)lua_tonumber(L, index);
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
-		luaL_error(L, &quot;Bad playerID: %i\n&quot;, playerID);
+		luaL_error(L, &quot;Bad playerID: %d\n&quot;, playerID);
 	}
 	CPlayer* player = gs-&gt;players[playerID];
 	if (player == NULL) {
-		luaL_error(L, &quot;Bad playerID: %i\n&quot;, playerID);
+		luaL_error(L, &quot;Bad playerID: %d\n&quot;, playerID);
 	}
 	return player;
 }
@@ -735,7 +740,6 @@
 	if ((unit == NULL) || (unit-&gt;cob == NULL)) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
 
 	int arg = 2;
 	bool splitData = false;
@@ -822,18 +826,18 @@
 		teamID = (int)lua_tonumber(L, 6);
 	}
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
-		luaL_error(L, &quot;CreateUnit(): bad team number: %i&quot;, teamID);
+		luaL_error(L, &quot;CreateUnit(): bad team number: %d&quot;, teamID);
 	}
 
 	if (gs-&gt;AllyTeam(teamID) &gt;= gs-&gt;activeAllyTeams) {
 		// FIXME: there's a segv in CLosHandler::LosAddAir,
 		//        this is a dirty hack to avoid it
-		luaL_error(L, &quot;CreateUnit(): inactive team: %i&quot;, teamID);
+		luaL_error(L, &quot;CreateUnit(): inactive team: %d&quot;, teamID);
 	}
 
 
 	if (!FullCtrl() &amp;&amp; (CtrlTeam() != teamID)) {
-		luaL_error(L, &quot;Error in CreateUnit(), bad team %i&quot;, teamID);
+		luaL_error(L, &quot;Error in CreateUnit(), bad team %d&quot;, teamID);
 		return 0;
 	}
 
@@ -1446,6 +1450,42 @@
 }
 
 
+int LuaSyncedCtrl::SetUnitCollisionVolumeData(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+
+	if (unit == NULL) {
+		return 0;
+	}
+	if (unit-&gt;collisionVolume == NULL) {
+		return 0;
+	}
+
+	const int args = lua_gettop(L);
+	if (args == 10) {
+		const float xs = float(lua_tonumber(L, 2));
+		const float ys = float(lua_tonumber(L, 3));
+		const float zs = float(lua_tonumber(L, 4));
+		const float xo = float(lua_tonumber(L, 5));
+		const float yo = float(lua_tonumber(L, 6));
+		const float zo = float(lua_tonumber(L, 7));
+		const int vType = int(lua_tonumber(L,  8));
+		const int tType = int(lua_tonumber(L,  9));
+		const int pAxis = int(lua_tonumber(L, 10));
+
+		const float3 scales(xs, ys, zs);
+		const float3 offsets(xo, yo, zo);
+
+		unit-&gt;collisionVolume-&gt;Init(scales, offsets, vType, tType, pAxis);
+	} else {
+		luaL_error(L, &quot;Incorrect arguments to SetUnitCollisionVolumeData()&quot;);
+	}
+
+	return 0;
+}
+
+
+
 int LuaSyncedCtrl::SetUnitMoveGoal(lua_State* L)
 {
 	CheckAllowGameChanges(L);
@@ -1814,7 +1854,7 @@
 
 	const int allyTeam = (team &lt; 0) ? -1 : gs-&gt;AllyTeam(team);
 	if (!CanControlFeatureAllyTeam(allyTeam)) {
-		luaL_error(L, &quot;CreateFeature() bad team permission %i&quot;, team);
+		luaL_error(L, &quot;CreateFeature() bad team permission %d&quot;, team);
 	}
 
 	if (inCreateFeature) {
@@ -1974,123 +2014,44 @@
 }
 
 
-/******************************************************************************/
-/******************************************************************************/
-
-static void ParseCommandOptions(lua_State* L, const char* caller,
-                                int index, Command&amp; cmd)
+int LuaSyncedCtrl::SetFeatureCollisionVolumeData(lua_State* L)
 {
-	if (lua_isnumber(L, index)) {
-		cmd.options = (unsigned char)lua_tonumber(L, index);
+	CFeature* feature = ParseFeature(L, __FUNCTION__, 1);
+	if (feature == NULL) {
+		return 0;
 	}
-	else if (lua_istable(L, index)) {
-		const int optionTable = index;
-		for (lua_pushnil(L); lua_next(L, optionTable) != 0; lua_pop(L, 1)) {
-			if (lua_israwnumber(L, -2)) { // avoid 'n'
-				if (!lua_isstring(L, -1)) {
-					luaL_error(L, &quot;%s(): bad option table entry&quot;, caller);
-				}
-				const string value = lua_tostring(L, -1);
-				if (value == &quot;right&quot;) {
-					cmd.options |= RIGHT_MOUSE_KEY;
-				} else if (value == &quot;alt&quot;) {
-					cmd.options |= ALT_KEY;
-				} else if (value == &quot;ctrl&quot;) {
-					cmd.options |= CONTROL_KEY;
-				} else if (value == &quot;shift&quot;) {
-					cmd.options |= SHIFT_KEY;
-				}
-			}
-		}
+	if (feature-&gt;collisionVolume == NULL) {
+		return 0;
 	}
-	else {
-		luaL_error(L, &quot;%s(): bad options&quot;, caller);
-	}
-}
 
+	const int args = lua_gettop(L);
+	if (args == 10) {
+		const float xs = float(lua_tonumber(L, 2));
+		const float ys = float(lua_tonumber(L, 3));
+		const float zs = float(lua_tonumber(L, 4));
+		const float xo = float(lua_tonumber(L, 5));
+		const float yo = float(lua_tonumber(L, 6));
+		const float zo = float(lua_tonumber(L, 7));
+		const int vType = int(lua_tonumber(L,  8));
+		const int tType = int(lua_tonumber(L,  9));
+		const int pAxis = int(lua_tonumber(L, 10));
 
-static void ParseCommand(lua_State* L, const char* caller,
-                         int idIndex, Command&amp; cmd)
-{
-	// cmdID
-	if (!lua_isnumber(L, idIndex)) {
-		luaL_error(L, &quot;%s(): bad command ID&quot;, caller);
-	}
-	cmd.id = (int)lua_tonumber(L, idIndex);
+		const float3 scales(xs, ys, zs);
+		const float3 offsets(xo, yo, zo);
 
-	// params
-	const int paramTable = (idIndex + 1);
-	if (!lua_istable(L, paramTable)) {
-		luaL_error(L, &quot;%s(): bad param table&quot;, caller);
+		feature-&gt;collisionVolume-&gt;Init(scales, offsets, vType, tType, pAxis);
+	} else {
+		luaL_error(L, &quot;Incorrect arguments to SetFeatureCollisionVolumeData()&quot;);
 	}
-	for (lua_pushnil(L); lua_next(L, paramTable) != 0; lua_pop(L, 1)) {
-		if (lua_israwnumber(L, -2)) { // avoid 'n'
-			if (!lua_isnumber(L, -1)) {
-				luaL_error(L, &quot;%s(): bad param table entry&quot;, caller);
-			}
-			const float value = (float)lua_tonumber(L, -1);
-			cmd.params.push_back(value);
-		}
-	}
 
-	// options
-	ParseCommandOptions(L, caller, (idIndex + 2), cmd);
-
-	// NOTE: should do some sanity checking?
+	return 0;
 }
 
 
-static void ParseCommandTable(lua_State* L, const char* caller,
-                              int table, Command&amp; cmd)
-{
-	// cmdID
-	lua_rawgeti(L, table, 1);
-	if (!lua_isnumber(L, -1)) {
-		luaL_error(L, &quot;%s(): bad command ID&quot;, caller);
-	}
-	cmd.id = (int)lua_tonumber(L, -1);
-	lua_pop(L, 1);
+/******************************************************************************/
+/******************************************************************************/
 
-	// params
-	lua_rawgeti(L, table, 2);
-	if (!lua_istable(L, -1)) {
-		luaL_error(L, &quot;%s(): bad param table&quot;, caller);
-	}
-	const int paramTable = lua_gettop(L);
-	for (lua_pushnil(L); lua_next(L, paramTable) != 0; lua_pop(L, 1)) {
-		if (lua_israwnumber(L, -2)) { // avoid 'n'
-			if (!lua_isnumber(L, -1)) {
-				luaL_error(L, &quot;%s(): bad param table entry&quot;, caller);
-			}
-			const float value = (float)lua_tonumber(L, -1);
-			cmd.params.push_back(value);
-		}
-	}
-	lua_pop(L, 1);
 
-	// options
-	lua_rawgeti(L, table, 3);
-	ParseCommandOptions(L, caller, lua_gettop(L), cmd);
-	lua_pop(L, 1);
-
-	// NOTE: should do some sanity checking?
-}
-
-
-static void ParseCommandArray(lua_State* L, const char* caller,
-                              int table, vector&lt;Command&gt;&amp; commands)
-{
-	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
-		if (!lua_istable(L, -1)) {
-			continue;
-		}
-		Command cmd;
-		ParseCommandTable(L, caller, lua_gettop(L), cmd);
-		commands.push_back(cmd);
-	}
-}
-
-
 static void ParseUnitMap(lua_State* L, const char* caller,
                          int table, vector&lt;CUnit*&gt;&amp; unitIDs)
 {
@@ -2139,7 +2100,7 @@
 	}
 
 	Command cmd;
-	ParseCommand(L, __FUNCTION__, 2, cmd);
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
 
 	if (!CanControlUnit(unit)) {
 		lua_pushboolean(L, false);
@@ -2174,7 +2135,7 @@
 	}
 
 	Command cmd;
-	ParseCommand(L, __FUNCTION__, 2, cmd);
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
 
 	if (inGiveOrder) {
 		luaL_error(L, &quot;GiveOrderToUnitMap() recursion is not permitted&quot;);
@@ -2211,7 +2172,7 @@
 	}
 
 	Command cmd;
-	ParseCommand(L, __FUNCTION__, 2, cmd);
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
 
 	if (inGiveOrder) {
 		luaL_error(L, &quot;GiveOrderToUnitArray() recursion is not permitted&quot;);
@@ -2245,7 +2206,7 @@
 
 	// commands
 	vector&lt;Command&gt; commands;
-	ParseCommandArray(L, __FUNCTION__, 2, commands);
+	LuaUtils::ParseCommandArray(L, __FUNCTION__, 2, commands);
 	const int commandCount = (int)commands.size();
 
 	if ((unitCount &lt;= 0) || (commandCount &lt;= 0)) {
@@ -2286,7 +2247,7 @@
 
 	// commands
 	vector&lt;Command&gt; commands;
-	ParseCommandArray(L, __FUNCTION__, 2, commands);
+	LuaUtils::ParseCommandArray(L, __FUNCTION__, 2, commands);
 	const int commandCount = (int)commands.size();
 
 	if ((unitCount &lt;= 0) || (commandCount &lt;= 0)) {

Modified: branches/gml/rts/Lua/LuaSyncedCtrl.h
===================================================================
--- branches/gml/rts/Lua/LuaSyncedCtrl.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaSyncedCtrl.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -68,6 +68,7 @@
 		static int SetUnitLineage(lua_State* L);
 		static int SetUnitNeutral(lua_State* L);
 		static int SetUnitTarget(lua_State* L);
+		static int SetUnitCollisionVolumeData(lua_State* L);
 
 		static int SetUnitPhysics(lua_State* L);
 		static int SetUnitPosition(lua_State* L);
@@ -88,6 +89,7 @@
 		static int SetFeaturePosition(lua_State* L);
 		static int SetFeatureDirection(lua_State* L);
 		static int SetFeatureNoSelect(lua_State* L);
+		static int SetFeatureCollisionVolumeData(lua_State* L);
 
 		static int LevelHeightMap(lua_State* L);
 		static int AdjustHeightMap(lua_State* L);

Modified: branches/gml/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- branches/gml/rts/Lua/LuaSyncedRead.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaSyncedRead.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -26,11 +26,15 @@
 #include &quot;Game/Player.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MetalMap.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
@@ -2139,11 +2143,7 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	float range = 1.0e9f;
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &gt;= 2) &amp;&amp; lua_isnumber(L, 2)) {
-		range = (float)lua_tonumber(L, 2);
-	}
+	const float range = luaL_optnumber(L, 2, 1.0e9f);
 	CUnit* target =
 		helper-&gt;GetClosestFriendlyUnit(unit-&gt;pos, range, unit-&gt;allyteam);
 	if (target) {
@@ -2160,13 +2160,16 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	float range = 1.0e9f;
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &gt;= 2) &amp;&amp; lua_isnumber(L, 2)) {
-		range = (float)lua_tonumber(L, 2);
+	const float range = luaL_optnumber(L, 2, 1.0e9f);
+	const bool useLos =
+		!fullRead || !lua_isboolean(L, 3) || lua_toboolean(L, 3);
+	CUnit* target = NULL;
+	if (useLos) {
+		target = helper-&gt;GetClosestEnemyUnit(unit-&gt;pos, range, unit-&gt;allyteam);
+	} else {
+		target = helper-&gt;GetClosestEnemyUnitNoLosTest(unit-&gt;pos, range,
+		                                              unit-&gt;allyteam, false);
 	}
-	CUnit* target =
-		helper-&gt;GetClosestEnemyUnit(unit-&gt;pos, range, unit-&gt;allyteam);
 	if (target) {
 		lua_pushnumber(L, target-&gt;id);
 		return 1;
@@ -3633,7 +3636,7 @@
 	const int maxIndex = (gs-&gt;hmapx * gs-&gt;hmapy) - 1;
 	const int index = min(maxIndex, (gs-&gt;hmapx * iz) + ix);
 	const int typeIndex = readmap-&gt;typemap[index];
-	const CReadMap::TerrainType&amp; tt = readmap-&gt;terrainTypes[typeIndex];
+	const CMapInfo::TerrainType&amp; tt = mapInfo-&gt;terrainTypes[typeIndex];
 
 	lua_pushstring(L, tt.name.c_str());
 	lua_pushnumber(L, metal);
@@ -3642,7 +3645,7 @@
 	lua_pushnumber(L, tt.kbotSpeed);
 	lua_pushnumber(L, tt.hoverSpeed);
 	lua_pushnumber(L, tt.shipSpeed);
-	lua_pushboolean(L, !!tt.receiveTracks);
+	lua_pushboolean(L, tt.receiveTracks);
 	return 8;
 }
 
@@ -3689,7 +3692,7 @@
 
 	for(int z = tz1; z &lt;= tz2; z++){
 		for(int x = tx1; x &lt;= tx2; x++){
-			const CSolidObject* s = readmap-&gt;GroundBlocked((z * gs-&gt;mapx) + x);
+			const CSolidObject* s = groundBlockingObjectMap-&gt;GroundBlocked((z * gs-&gt;mapx) + x);
 
 			const CFeature* feature = dynamic_cast&lt;const CFeature*&gt;(s);
 			if (feature) {
@@ -4024,6 +4027,53 @@
 }
 
 
+template&lt;class ModelType&gt;
+static int GetUnitPieceInfo(lua_State* L, const ModelType&amp; op)
+{
+	lua_newtable(L);
+	HSTR_PUSH_STRING(L, &quot;name&quot;, op.name.c_str());
+
+	HSTR_PUSH(L, &quot;children&quot;);
+	lua_newtable(L);
+	for (int c = 0; c &lt; (int)op.childs.size(); c++) {
+		lua_pushnumber(L, c + 1);
+		lua_pushstring(L, op.childs[c]-&gt;name.c_str());
+		lua_rawset(L, -3);
+	}
+	HSTR_PUSH_NUMBER(L, &quot;n&quot;, op.childs.size());
+	lua_rawset(L, -3);
+
+	HSTR_PUSH(L, &quot;isEmpty&quot;);
+	lua_pushboolean(L, op.isEmpty);
+	lua_rawset(L, -3);
+
+	HSTR_PUSH(L, &quot;min&quot;);
+	lua_newtable(L); {
+		lua_pushnumber(L, 1); lua_pushnumber(L, op.minx); lua_rawset(L, -3);
+		lua_pushnumber(L, 2); lua_pushnumber(L, op.miny); lua_rawset(L, -3);
+		lua_pushnumber(L, 3); lua_pushnumber(L, op.minz); lua_rawset(L, -3);
+	}
+	lua_rawset(L, -3);
+
+	HSTR_PUSH(L, &quot;max&quot;);
+	lua_newtable(L); {
+		lua_pushnumber(L, 1); lua_pushnumber(L, op.maxx); lua_rawset(L, -3);
+		lua_pushnumber(L, 2); lua_pushnumber(L, op.maxy); lua_rawset(L, -3);
+		lua_pushnumber(L, 3); lua_pushnumber(L, op.maxz); lua_rawset(L, -3);
+	}
+	lua_rawset(L, -3);
+
+	HSTR_PUSH(L, &quot;offset&quot;);
+	lua_newtable(L); {
+		lua_pushnumber(L, 1); lua_pushnumber(L, op.offset.x); lua_rawset(L, -3);
+		lua_pushnumber(L, 2); lua_pushnumber(L, op.offset.y); lua_rawset(L, -3);
+		lua_pushnumber(L, 3); lua_pushnumber(L, op.offset.z); lua_rawset(L, -3);
+	}
+	lua_rawset(L, -3);
+	return 1;
+}
+
+
 int LuaSyncedRead::GetUnitPieceInfo(lua_State* L)
 {
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
@@ -4038,97 +4088,13 @@
 	}
 	LocalS3DO&amp; lp = localModel-&gt;pieces[piece];
 
-	float3 mins, maxs, offset;
-
 	if (lp.originals3o) {
 		const SS3O&amp; op = *lp.originals3o;
-		lua_newtable(L); {
-			HSTR_PUSH_STRING(L, &quot;name&quot;, op.name.c_str());
-
-			HSTR_PUSH(L, &quot;children&quot;);
-			lua_newtable(L);
-			for (int c = 0; c &lt; (int)op.childs.size(); c++) {
-				lua_pushnumber(L, c + 1);
-				lua_pushstring(L, op.childs[c]-&gt;name.c_str());
-				lua_rawset(L, -3);
-			}
-			HSTR_PUSH_NUMBER(L, &quot;n&quot;, op.childs.size());
-			lua_rawset(L, -3);
-
-			HSTR_PUSH(L, &quot;isEmpty&quot;);
-			lua_pushboolean(L, op.isEmpty);
-			lua_rawset(L, -3);
-
-			HSTR_PUSH(L, &quot;min&quot;);
-			lua_newtable(L); {
-				lua_pushnumber(L, 1); lua_pushnumber(L, op.minx); lua_rawset(L, -3);
-				lua_pushnumber(L, 2); lua_pushnumber(L, op.miny); lua_rawset(L, -3);
-				lua_pushnumber(L, 3); lua_pushnumber(L, op.minz); lua_rawset(L, -3);
-			}
-			lua_rawset(L, -3);
-
-			HSTR_PUSH(L, &quot;max&quot;);
-			lua_newtable(L); {
-				lua_pushnumber(L, 1); lua_pushnumber(L, op.maxx); lua_rawset(L, -3);
-				lua_pushnumber(L, 2); lua_pushnumber(L, op.maxy); lua_rawset(L, -3);
-				lua_pushnumber(L, 3); lua_pushnumber(L, op.maxz); lua_rawset(L, -3);
-			}
-			lua_rawset(L, -3);
-
-			HSTR_PUSH(L, &quot;offset&quot;);
-			lua_newtable(L); {
-				lua_pushnumber(L, 1); lua_pushnumber(L, op.offset.x); lua_rawset(L, -3);
-				lua_pushnumber(L, 2); lua_pushnumber(L, op.offset.y); lua_rawset(L, -3);
-				lua_pushnumber(L, 3); lua_pushnumber(L, op.offset.z); lua_rawset(L, -3);
-			}
-			lua_rawset(L, -3);
-		}
-		return 1;
+		return ::GetUnitPieceInfo(L, op);
 	}
 	else if (lp.original3do) {
 		const S3DO&amp; op = *lp.original3do;
-		lua_newtable(L); {
-			HSTR_PUSH_STRING(L, &quot;name&quot;, op.name.c_str());
-
-			HSTR_PUSH(L, &quot;children&quot;);
-			lua_newtable(L);
-			for (int c = 0; c &lt; (int)op.childs.size(); c++) {
-				lua_pushnumber(L, c + 1);
-				lua_pushstring(L, op.childs[c]-&gt;name.c_str());
-				lua_rawset(L, -3);
-			}
-			HSTR_PUSH_NUMBER(L, &quot;n&quot;, op.childs.size());
-			lua_rawset(L, -3);
-
-			HSTR_PUSH(L, &quot;isEmpty&quot;);
-			lua_pushboolean(L, op.isEmpty);
-			lua_rawset(L, -3);
-
-			HSTR_PUSH(L, &quot;min&quot;);
-			lua_newtable(L); {
-				lua_pushnumber(L, 1); lua_pushnumber(L, op.minx); lua_rawset(L, -3);
-				lua_pushnumber(L, 2); lua_pushnumber(L, op.miny); lua_rawset(L, -3);
-				lua_pushnumber(L, 3); lua_pushnumber(L, op.minz); lua_rawset(L, -3);
-			}
-			lua_rawset(L, -3);
-
-			HSTR_PUSH(L, &quot;max&quot;);
-			lua_newtable(L); {
-				lua_pushnumber(L, 1); lua_pushnumber(L, op.maxx); lua_rawset(L, -3);
-				lua_pushnumber(L, 2); lua_pushnumber(L, op.maxy); lua_rawset(L, -3);
-				lua_pushnumber(L, 3); lua_pushnumber(L, op.maxz); lua_rawset(L, -3);
-			}
-			lua_rawset(L, -3);
-
-			HSTR_PUSH(L, &quot;offset&quot;);
-			lua_newtable(L); {
-				lua_pushnumber(L, 1); lua_pushnumber(L, op.offset.x); lua_rawset(L, -3);
-				lua_pushnumber(L, 2); lua_pushnumber(L, op.offset.y); lua_rawset(L, -3);
-				lua_pushnumber(L, 3); lua_pushnumber(L, op.offset.z); lua_rawset(L, -3);
-			}
-			lua_rawset(L, -3);
-		}
-		return 1;
+		return ::GetUnitPieceInfo(L, op);
 	}
 
 	return 0;

Modified: branches/gml/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnitDefs.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaUnitDefs.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -22,6 +22,7 @@
 #include &quot;Game/Team.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
@@ -269,51 +270,7 @@
 
 static int Next(lua_State* L)
 {
-	luaL_checktype(L, 1, LUA_TTABLE);
-	lua_settop(L, 2); // create a 2nd argument if there isn't one
-
-	// internal parameters first
-	if (lua_isnil(L, 2)) {
-		const string&amp; nextKey = paramMap.begin()-&gt;first;
-		lua_pushstring(L, nextKey.c_str()); // push the key
-		lua_pushvalue(L, 3);                // copy the key
-		lua_gettable(L, 1);                 // get the value
-		return 2;
-	}
-
-	// all internal parameters use strings as keys
-	if (lua_isstring(L, 2)) {
-		const char* key = lua_tostring(L, 2);
-		ParamMap::const_iterator it = paramMap.find(key);
-		if ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type != READONLY_TYPE)) {
-			// last key was an internal parameter
-			it++;
-			while ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type == READONLY_TYPE)) {
-				it++; // skip read-only parameters
-			}
-			if ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type != READONLY_TYPE)) {
-				// next key is an internal parameter
-				const string&amp; nextKey = it-&gt;first;
-				lua_pushstring(L, nextKey.c_str()); // push the key
-				lua_pushvalue(L, 3);                // copy the key
-				lua_gettable(L, 1);                 // get the value (proxied)
-				return 2;
-			}
-			// start the user parameters,
-			// remove the internal key and push a nil
-			lua_settop(L, 1);
-			lua_pushnil(L);
-		}
-	}
-
-	// user parameter
-	if (lua_next(L, 1)) {
-		return 2;
-	}
-
-	// end of the line
-	lua_pushnil(L);
-	return 1;
+	return LuaUtils::Next(paramMap, L);
 }
 
 
@@ -581,7 +538,7 @@
 {
 	const UnitDef&amp; ud = *((const UnitDef*)data);
 	const float basicEnergy = (ud.energyMake - ud.energyUpkeep);
-	const float tidalEnergy = (ud.tidalGenerator * readmap-&gt;tidalStrength);
+	const float tidalEnergy = (ud.tidalGenerator * mapInfo-&gt;map.tidalStrength);
 	float windEnergy = 0.0f;
 	if (ud.windGenerator &gt; 0.0f) {
 		windEnergy = (0.25f * (wind.GetMinWind() + wind.GetMaxWind()));
@@ -842,6 +799,7 @@
 	ADD_BOOL(&quot;canCrash&quot;,              ud.canCrash);
 	ADD_BOOL(&quot;canFireControl&quot;,        ud.canFireControl);
 	ADD_INT( &quot;fireState&quot;,             ud.fireState);
+	ADD_INT( &quot;moveState&quot;,             ud.moveState);
 	ADD_BOOL(&quot;fullHealthFactory&quot;,     ud.fullHealthFactory);
 	ADD_BOOL(&quot;factoryHeadingTakeoff&quot;, ud.factoryHeadingTakeoff);
 

Modified: branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,12 +7,15 @@
 #include &lt;set&gt;
 #include &lt;list&gt;
 #include &lt;cctype&gt;
+
+#include &lt;fstream&gt;
 using namespace std;
 
 #include &quot;LuaInclude.h&quot;
 
 #include &quot;LuaHandle.h&quot;
 #include &quot;LuaHashString.h&quot;
+#include &quot;LuaUtils.h&quot;
 
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/Camera/CameraController.h&quot;
@@ -33,7 +36,10 @@
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Sound.h&quot;
 
+#include &quot;System/FileSystem/FileHandler.h&quot;
+#include &quot;System/Platform/FileSystem.h&quot;
 
+
 /******************************************************************************/
 /******************************************************************************/
 
@@ -94,7 +100,8 @@
 	REGISTER_LUA_CFUNC(SetUnitNoDraw);
 	REGISTER_LUA_CFUNC(SetUnitNoMinimap);
 	REGISTER_LUA_CFUNC(SetUnitNoSelect);
-            
+
+	REGISTER_LUA_CFUNC(ExtractModArchiveFile);
 	return true;
 }
 
@@ -269,58 +276,7 @@
 
 int LuaUnsyncedCtrl::Echo(lua_State* L)
 {
-	// copied from lua/src/lib/lbaselib.c
-	string msg = &quot;&quot;;
-	const int args = lua_gettop(L); // number of arguments
-
-	lua_getglobal(L, &quot;tostring&quot;);
-
-	for (int i = 1; i &lt;= args; i++) {
-		const char *s;
-		lua_pushvalue(L, -1);     // function to be called
-		lua_pushvalue(L, i);      // value to print
-		lua_call(L, 1, 1);
-		s = lua_tostring(L, -1);  // get result
-		if (s == NULL) {
-			return luaL_error(L, &quot;`tostring' must return a string to `print'&quot;);
-		}
-		if (i &gt; 1) {
-			msg += &quot;, &quot;;
-		}
-		msg += s;
-		lua_pop(L, 1);            // pop result
-	}
-	logOutput.Print(msg);
-
-	if ((args != 1) || !lua_istable(L, 1)) {
-		return 0;
-	}
-
-	// print solo tables (array style)
-	msg = &quot;TABLE: &quot;;
-	bool first = true;
-	const int table = 1;
-	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
-		if (lua_israwnumber(L, -2)) {  // only numeric keys
-			const char *s;
-			lua_pushvalue(L, -3);     // function to be called
-			lua_pushvalue(L, -2	);    // value to print
-			lua_call(L, 1, 1);
-			s = lua_tostring(L, -1);  // get result
-			if (s == NULL) {
-				return luaL_error(L, &quot;`tostring' must return a string to `print'&quot;);
-			}
-			if (!first) {
-				msg += &quot;, &quot;;
-			}
-			msg += s;
-			first = false;
-			lua_pop(L, 1);            // pop result
-		}
-	}
-	logOutput.Print(msg);
-
-	return 0;
+	return LuaUtils::Echo(L);
 }
 
 
@@ -467,15 +423,15 @@
 	const int args = lua_gettop(L);
 
 	const string soundFile = luaL_checkstring(L, 1);
-	const float volume     =   luaL_optnumber(L, 2, 1.0f);
+	const float volume = luaL_optnumber(L, 2, 1.0f);
 
 	if (args &lt; 5) {
 		sound-&gt;PlayStream(soundFile, volume);
 	}
 	else {
 		const float3 pos((float) lua_tonumber(L, 3),
-		                 (float) lua_tonumber(L, 4),
-		                 (float) lua_tonumber(L, 5));
+						 (float) lua_tonumber(L, 4),
+						 (float) lua_tonumber(L, 5));
 		sound-&gt;PlayStream(soundFile, volume, pos);
 	}
 
@@ -973,5 +929,66 @@
 }
 
 
+
+// TODO: move this to LuaVFS?
+int LuaUnsyncedCtrl::ExtractModArchiveFile(lua_State* L)
+{
+	bool ret = false;
+	const int args = lua_gettop(L);
+
+	if (args == 1) {
+		if (lua_isstring(L, 1)) {
+			std::string path(lua_tostring(L, 1));
+			CFileHandler fh(path, SPRING_VFS_MOD);
+
+			if (fh.FileExists()) {
+				std::string dname = filesystem.GetDirectory(path);
+				std::string fname = filesystem.GetFilename(path);
+
+				#ifdef WIN32
+				const int s = dname.size();
+				// get rid of any trailing slashes (CreateDirectory()
+				// fails on at least XP and Vista if they are present,
+				// ie. it creates the dir but actually returns false)
+				if (s &gt; 0 &amp;&amp; (dname[s - 1] == '/' || dname[s - 1] == '\\')) {
+					dname = dname.substr(0, s - 1);
+				}
+				#endif
+
+				if (dname.size() == 0 || filesystem.CreateDirectory(dname)) {
+					int numBytes = fh.FileSize();
+					char* buffer = SAFE_NEW char[numBytes];
+
+					fh.Read(buffer, numBytes);
+
+					std::fstream fstr(path.c_str(), std::ios::out | std::ios::binary);
+					fstr.write((const char*) buffer, numBytes);
+					fstr.close();
+
+					if (dname.size() &gt; 0) {
+						logOutput.Print(&quot;Extracted file \&quot;%s\&quot; to directory \&quot;%s\&quot;&quot;, fname.c_str(), dname.c_str());
+					} else {
+						logOutput.Print(&quot;Extracted file \&quot;%s\&quot;&quot;, fname.c_str());
+					}
+
+					delete[] buffer;
+					ret = true;
+				} else {
+					luaL_error(L, &quot;Could not create directory \&quot;%s\&quot; for file \&quot;%s\&quot;&quot;, dname.c_str(), fname.c_str());
+				}
+			} else {
+				luaL_error(L, &quot;Path \&quot;%s\&quot; not found in mod archive&quot;, path.c_str());
+			}
+		} else {
+			luaL_error(L, &quot;Argument to ExtractModArchiveFile(s) not a string&quot;);
+		}
+	} else {
+		luaL_error(L, &quot;Incorrect number of arguments to ExtractModArchiveFile(s)&quot;);
+	}
+
+	lua_pushboolean(L, ret);
+	return 1;
+}
+
 /******************************************************************************/
 /******************************************************************************/

Modified: branches/gml/rts/Lua/LuaUnsyncedCtrl.h
===================================================================
--- branches/gml/rts/Lua/LuaUnsyncedCtrl.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaUnsyncedCtrl.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -61,6 +61,8 @@
 		static int SetUnitNoDraw(lua_State* L);
 		static int SetUnitNoMinimap(lua_State* L);
 		static int SetUnitNoSelect(lua_State* L);
+
+		static int ExtractModArchiveFile(lua_State* L);
 };
 
 

Modified: branches/gml/rts/Lua/LuaUtils.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUtils.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaUtils.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,7 +7,7 @@
 #include &lt;set&gt;
 #include &lt;cctype&gt;
 
-#include &quot;LuaInclude.h&quot;
+#include &quot;LogOutput.h&quot;
 
 
 static       int depth = 0;
@@ -186,3 +186,239 @@
 
 /******************************************************************************/
 /******************************************************************************/
+
+
+void LuaUtils::ParseCommandOptions(lua_State* L, const char* caller,
+                                   int index, Command&amp; cmd)
+{
+	if (lua_isnumber(L, index)) {
+		cmd.options = (unsigned char)lua_tonumber(L, index);
+	}
+	else if (lua_istable(L, index)) {
+		const int optionTable = index;
+		for (lua_pushnil(L); lua_next(L, optionTable) != 0; lua_pop(L, 1)) {
+			if (lua_israwnumber(L, -2)) { // avoid 'n'
+				if (!lua_isstring(L, -1)) {
+					luaL_error(L, &quot;%s(): bad option table entry&quot;, caller);
+				}
+				const string value = lua_tostring(L, -1);
+				if (value == &quot;right&quot;) {
+					cmd.options |= RIGHT_MOUSE_KEY;
+				} else if (value == &quot;alt&quot;) {
+					cmd.options |= ALT_KEY;
+				} else if (value == &quot;ctrl&quot;) {
+					cmd.options |= CONTROL_KEY;
+				} else if (value == &quot;shift&quot;) {
+					cmd.options |= SHIFT_KEY;
+				}
+			}
+		}
+	}
+	else {
+		luaL_error(L, &quot;%s(): bad options&quot;, caller);
+	}
+}
+
+
+void LuaUtils::ParseCommand(lua_State* L, const char* caller,
+                            int idIndex, Command&amp; cmd)
+{
+	// cmdID
+	if (!lua_isnumber(L, idIndex)) {
+		luaL_error(L, &quot;%s(): bad command ID&quot;, caller);
+	}
+	cmd.id = (int)lua_tonumber(L, idIndex);
+
+	// params
+	const int paramTable = (idIndex + 1);
+	if (!lua_istable(L, paramTable)) {
+		luaL_error(L, &quot;%s(): bad param table&quot;, caller);
+	}
+	for (lua_pushnil(L); lua_next(L, paramTable) != 0; lua_pop(L, 1)) {
+		if (lua_israwnumber(L, -2)) { // avoid 'n'
+			if (!lua_isnumber(L, -1)) {
+				luaL_error(L, &quot;%s(): bad param table entry&quot;, caller);
+			}
+			const float value = (float)lua_tonumber(L, -1);
+			cmd.params.push_back(value);
+		}
+	}
+
+	// options
+	ParseCommandOptions(L, caller, (idIndex + 2), cmd);
+
+	// NOTE: should do some sanity checking?
+}
+
+
+void LuaUtils::ParseCommandTable(lua_State* L, const char* caller,
+                                 int table, Command&amp; cmd)
+{
+	// cmdID
+	lua_rawgeti(L, table, 1);
+	if (!lua_isnumber(L, -1)) {
+		luaL_error(L, &quot;%s(): bad command ID&quot;, caller);
+	}
+	cmd.id = (int)lua_tonumber(L, -1);
+	lua_pop(L, 1);
+
+	// params
+	lua_rawgeti(L, table, 2);
+	if (!lua_istable(L, -1)) {
+		luaL_error(L, &quot;%s(): bad param table&quot;, caller);
+	}
+	const int paramTable = lua_gettop(L);
+	for (lua_pushnil(L); lua_next(L, paramTable) != 0; lua_pop(L, 1)) {
+		if (lua_israwnumber(L, -2)) { // avoid 'n'
+			if (!lua_isnumber(L, -1)) {
+				luaL_error(L, &quot;%s(): bad param table entry&quot;, caller);
+			}
+			const float value = (float)lua_tonumber(L, -1);
+			cmd.params.push_back(value);
+		}
+	}
+	lua_pop(L, 1);
+
+	// options
+	lua_rawgeti(L, table, 3);
+	ParseCommandOptions(L, caller, lua_gettop(L), cmd);
+	lua_pop(L, 1);
+
+	// NOTE: should do some sanity checking?
+}
+
+
+void LuaUtils::ParseCommandArray(lua_State* L, const char* caller,
+                                 int table, vector&lt;Command&gt;&amp; commands)
+{
+	if (!lua_istable(L, table)) {
+		luaL_error(L, &quot;%s(): error parsing command array&quot;, caller);
+	}
+	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
+		if (!lua_istable(L, -1)) {
+			continue;
+		}
+		Command cmd;
+		ParseCommandTable(L, caller, lua_gettop(L), cmd);
+		commands.push_back(cmd);
+	}
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+
+int LuaUtils::Next(const ParamMap&amp; paramMap, lua_State* L)
+{
+	luaL_checktype(L, 1, LUA_TTABLE);
+	lua_settop(L, 2); // create a 2nd argument if there isn't one
+
+	// internal parameters first
+	if (lua_isnil(L, 2)) {
+		const string&amp; nextKey = paramMap.begin()-&gt;first;
+		lua_pushstring(L, nextKey.c_str()); // push the key
+		lua_pushvalue(L, 3);                // copy the key
+		lua_gettable(L, 1);                 // get the value
+		return 2;
+	}
+
+	// all internal parameters use strings as keys
+	if (lua_isstring(L, 2)) {
+		const char* key = lua_tostring(L, 2);
+		ParamMap::const_iterator it = paramMap.find(key);
+		if ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type != READONLY_TYPE)) {
+			// last key was an internal parameter
+			it++;
+			while ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type == READONLY_TYPE)) {
+				it++; // skip read-only parameters
+			}
+			if ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type != READONLY_TYPE)) {
+				// next key is an internal parameter
+				const string&amp; nextKey = it-&gt;first;
+				lua_pushstring(L, nextKey.c_str()); // push the key
+				lua_pushvalue(L, 3);                // copy the key
+				lua_gettable(L, 1);                 // get the value (proxied)
+				return 2;
+			}
+			// start the user parameters,
+			// remove the internal key and push a nil
+			lua_settop(L, 1);
+			lua_pushnil(L);
+		}
+	}
+
+	// user parameter
+	if (lua_next(L, 1)) {
+		return 2;
+	}
+
+	// end of the line
+	lua_pushnil(L);
+	return 1;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+
+int LuaUtils::Echo(lua_State* L)
+{
+	// copied from lua/src/lib/lbaselib.c
+	string msg = &quot;&quot;;
+	const int args = lua_gettop(L); // number of arguments
+
+	lua_getglobal(L, &quot;tostring&quot;);
+
+	for (int i = 1; i &lt;= args; i++) {
+		const char *s;
+		lua_pushvalue(L, -1);     // function to be called
+		lua_pushvalue(L, i);      // value to print
+		lua_call(L, 1, 1);
+		s = lua_tostring(L, -1);  // get result
+		if (s == NULL) {
+			return luaL_error(L, &quot;`tostring' must return a string to `print'&quot;);
+		}
+		if (i &gt; 1) {
+			msg += &quot;, &quot;;
+		}
+		msg += s;
+		lua_pop(L, 1);            // pop result
+	}
+	logOutput.Print(msg);
+
+	if ((args != 1) || !lua_istable(L, 1)) {
+		return 0;
+	}
+
+	// print solo tables (array style)
+	msg = &quot;TABLE: &quot;;
+	bool first = true;
+	const int table = 1;
+	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
+		if (lua_israwnumber(L, -2)) {  // only numeric keys
+			const char *s;
+			lua_pushvalue(L, -3);     // function to be called
+			lua_pushvalue(L, -2	);    // value to print
+			lua_call(L, 1, 1);
+			s = lua_tostring(L, -1);  // get result
+			if (s == NULL) {
+				return luaL_error(L, &quot;`tostring' must return a string to `print'&quot;);
+			}
+			if (!first) {
+				msg += &quot;, &quot;;
+			}
+			msg += s;
+			first = false;
+			lua_pop(L, 1);            // pop result
+		}
+	}
+	logOutput.Print(msg);
+
+	return 0;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/

Modified: branches/gml/rts/Lua/LuaUtils.h
===================================================================
--- branches/gml/rts/Lua/LuaUtils.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaUtils.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -10,8 +10,9 @@
 using std::vector;
 
 #include &quot;LuaHashString.h&quot;
-
 #include &quot;LuaInclude.h&quot;
+#include &quot;LuaDefs.h&quot;
+#include &quot;Sim/Units/CommandAI/Command.h&quot;
 
 class LuaUtils {
 	public:
@@ -37,6 +38,24 @@
 		static void* GetUserData(lua_State* L, int index, const string&amp; type);
 
 		static void PrintStack(lua_State* L);
+
+		// from LuaUI.cpp / LuaSyncedCtrl.cpp (used to be duplicated)
+		static void ParseCommandOptions(lua_State* L, const char* caller,
+		                                int index, Command&amp; cmd);
+		static void ParseCommand(lua_State* L, const char* caller,
+		                         int idIndex, Command&amp; cmd);
+		static void ParseCommandTable(lua_State* L, const char* caller,
+		                              int table, Command&amp; cmd);
+		static void ParseCommandArray(lua_State* L, const char* caller,
+		                              int table, vector&lt;Command&gt;&amp; commands);
+
+		// from LuaFeatureDefs.cpp / LuaUnitDefs.cpp / LuaWeaponDefs.cpp
+		// (helper for the Next() iteration routine)
+		static int Next(const ParamMap&amp; paramMap, lua_State* L);
+
+		// from LuaParser.cpp / LuaUnsyncedCtrl.cpp
+		// (implementation copied from lua/src/lib/lbaselib.c)
+		static int Echo(lua_State* L);
 };
 
 

Modified: branches/gml/rts/Lua/LuaWeaponDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaWeaponDefs.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Lua/LuaWeaponDefs.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -236,51 +236,7 @@
 
 static int Next(lua_State* L)
 {
-	luaL_checktype(L, 1, LUA_TTABLE);
-	lua_settop(L, 2); // create a 2nd argument if there isn't one
-
-	// internal parameters first
-	if (lua_isnil(L, 2)) {
-		const string&amp; nextKey = paramMap.begin()-&gt;first;
-		lua_pushstring(L, nextKey.c_str()); // push the key
-		lua_pushvalue(L, 3);                // copy the key
-		lua_gettable(L, 1);                 // get the value
-		return 2;
-	}
-
-	// all internal parameters use strings as keys
-	if (lua_isstring(L, 2)) {
-		const char* key = lua_tostring(L, 2);
-		ParamMap::const_iterator it = paramMap.find(key);
-		if ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type != READONLY_TYPE)) {
-			// last key was an internal parameter
-			it++;
-			while ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type == READONLY_TYPE)) {
-				it++; // skip read-only parameters
-			}
-			if ((it != paramMap.end()) &amp;&amp; (it-&gt;second.type != READONLY_TYPE)) {
-				// next key is an internal parameter
-				const string&amp; nextKey = it-&gt;first;
-				lua_pushstring(L, nextKey.c_str()); // push the key
-				lua_pushvalue(L, 3);                // copy the key
-				lua_gettable(L, 1);                 // get the value (proxied)
-				return 2;
-			}
-			// start the user parameters,
-			// remove the internal key and push a nil
-			lua_settop(L, 1);
-			lua_pushnil(L);
-		}
-	}
-
-	// user parameter
-	if (lua_next(L, 1)) {
-		return 2;
-	}
-
-	// end of the line
-	lua_pushnil(L);
-	return 1;
+	return LuaUtils::Next(paramMap, L);
 }
 
 

Modified: branches/gml/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- branches/gml/rts/Map/BaseGroundDrawer.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/BaseGroundDrawer.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,6 +4,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Map/HeightLinePalette.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
@@ -43,21 +44,23 @@
 	highResLosTex = !!configHandler.GetInt(&quot;HighResLos&quot;, 0);
 // 	smoothLosTex = !!configHandler.GetInt(&quot;SmoothLos&quot;, 1);
 
-  jamColor[0] = (int)(losColorScale * 0.25f);
-  jamColor[1] = (int)(losColorScale * 0.0f);
-  jamColor[2] = (int)(losColorScale * 0.0f);
+	jamColor[0] = (int)(losColorScale * 0.25f);
+	jamColor[1] = (int)(losColorScale * 0.0f);
+	jamColor[2] = (int)(losColorScale * 0.0f);
 
-  losColor[0] = (int)(losColorScale * 0.15f);
-  losColor[1] = (int)(losColorScale * 0.05f);
-  losColor[2] = (int)(losColorScale * 0.40f);
+	losColor[0] = (int)(losColorScale * 0.15f);
+	losColor[1] = (int)(losColorScale * 0.05f);
+	losColor[2] = (int)(losColorScale * 0.40f);
 
-  radarColor[0] = (int)(losColorScale *  0.05f);
-  radarColor[1] = (int)(losColorScale *  0.15f);
-  radarColor[2] = (int)(losColorScale * -0.20f);
+	radarColor[0] = (int)(losColorScale *  0.05f);
+	radarColor[1] = (int)(losColorScale *  0.15f);
+	radarColor[2] = (int)(losColorScale * -0.20f);
 
-  alwaysColor[0] = (int)(losColorScale * 0.25f);
-  alwaysColor[1] = (int)(losColorScale * 0.25f);
-  alwaysColor[2] = (int)(losColorScale * 0.25f);
+	alwaysColor[0] = (int)(losColorScale * 0.25f);
+	alwaysColor[1] = (int)(losColorScale * 0.25f);
+	alwaysColor[2] = (int)(losColorScale * 0.25f);
+
+	heightLinePal = SAFE_NEW CHeightLinePalette();
 }
 
 CBaseGroundDrawer::~CBaseGroundDrawer(void)
@@ -66,6 +69,8 @@
 	if (infoTex!=0) {
 		glDeleteTextures(1, &amp;infoTex);
 	}
+
+	delete heightLinePal;
 }
 
 void CBaseGroundDrawer::DrawShadowPass(void)
@@ -248,7 +253,7 @@
 							if (gs-&gt;cheatEnabled &amp;&amp; md-&gt;moveMath-&gt;IsBlocked2(*md, x*2+1, y*2+1) &amp; (CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN)) {
 								m = 0.0f;
 							}
-							m = min(1.0f, (float)sqrt(m));
+							m = std::min(1.0f, (float)sqrt(m));
 							const int a=y*gs-&gt;pwr2mapx/2+x;
 							infoTexMem[a*4+0]=255-int(m*255.0f);
 							infoTexMem[a*4+1]=int(m*255.0f);
@@ -267,7 +272,7 @@
 						if (myAirLos[alx + (aly * loshandler-&gt;airSizeX)]) {
 							float extractDepth = extractDepthMap[(y * gs-&gt;hmapx) + x];
 							// a single pow(x, 0.25) call would be faster?
-							infoTexMem[a*4]=(unsigned char)min(255.0f,(float)sqrt(sqrt(extractDepth))*900);
+							infoTexMem[a*4]=(unsigned char)std::min(255.0f,(float)sqrt(sqrt(extractDepth))*900);
 						} else {
 							infoTexMem[a*4]=0;
 						}
@@ -278,7 +283,7 @@
 				break;
 			}
 			case drawHeight: {
-				extraTexPal = readmap-&gt;heightLinePal;
+				extraTexPal = heightLinePal-&gt;GetData();
 				for (int y = starty; y &lt; endy; ++y) {
 					for (int x = 0; x  &lt; gs-&gt;mapx; ++x){
 						const float height = readmap-&gt;centerheightmap[(y * gs-&gt;mapx) + x];

Modified: branches/gml/rts/Map/BaseGroundDrawer.h
===================================================================
--- branches/gml/rts/Map/BaseGroundDrawer.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/BaseGroundDrawer.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,6 +9,8 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;float3.h&quot;
 
+class CHeightLinePalette;
+
 class CBaseGroundDrawer
 {
 public:
@@ -58,8 +60,8 @@
 	bool highResInfoTex;
 	bool highResInfoTexWanted;
 
-	unsigned char* extraTex;
-	unsigned char* extraTexPal;
+	const unsigned char* extraTex;
+	const unsigned char* extraTexPal;
 	float* extractDepthMap;
 
 	int updateTextureState;
@@ -76,6 +78,8 @@
 	
 	bool highResLosTex;
 // 	bool smoothLosTex;
+
+	CHeightLinePalette* heightLinePal;
 };
 
 #endif // __BASE_GROUND_DRAWER__

Modified: branches/gml/rts/Map/BasicMapDamage.cpp
===================================================================
--- branches/gml/rts/Map/BasicMapDamage.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/BasicMapDamage.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,13 +1,15 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;BasicMapDamage.h&quot;
 #include &quot;ReadMap.h&quot;
+#include &quot;MapInfo.h&quot;
 #include &quot;BaseGroundDrawer.h&quot;
 #include &quot;HeightMapTexture.h&quot;
 #include &quot;Rendering/Env/BaseTreeDrawer.h&quot;
 #include &quot;TimeProfiler.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
+#include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
-#include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Sim/Path/PathManager.h&quot;
@@ -28,16 +30,16 @@
 
 	for(int a=0;a&lt;=200;++a){
 		float r=a/200.0f;
-		float d=cos((r-0.1f)*(PI+0.3f))*(1-r)*(0.5f+0.5f*cos(max(0.0f,r*3-2)*PI));
+		float d=cos((r-0.1f)*(PI+0.3f))*(1-r)*(0.5f+0.5f*cos(std::max(0.0f,r*3-2)*PI));
 		craterTable[a]=d;
 	}
 	for(int a=201;a&lt;10000;++a){
 		craterTable[a]=0;
 	}
 	for(int a=0;a&lt;256;++a)
-		invHardness[a]=1.0f/readmap-&gt;terrainTypes[a].hardness;
+		invHardness[a]=1.0f/mapInfo-&gt;terrainTypes[a].hardness;
 
-	mapHardness=atof(readmap-&gt;mapDefParser.SGetValueDef(&quot;100&quot;,&quot;MAP\\MapHardness&quot;).c_str());
+	mapHardness = mapInfo-&gt;map.hardness;
 
 	disabled = false;
 }
@@ -66,17 +68,19 @@
 	e-&gt;pos=pos;
 	e-&gt;strength=strength;
 	e-&gt;ttl=10;
-	e-&gt;x1=max((int)(pos.x-radius)/SQUARE_SIZE,2);
-	e-&gt;x2=min((int)(pos.x+radius)/SQUARE_SIZE,gs-&gt;mapx-3);
-	e-&gt;y1=max((int)(pos.z-radius)/SQUARE_SIZE,2);
-	e-&gt;y2=min((int)(pos.z+radius)/SQUARE_SIZE,gs-&gt;mapy-3);
+	e-&gt;x1=std::max((int)(pos.x-radius)/SQUARE_SIZE,2);
+	e-&gt;x2=std::min((int)(pos.x+radius)/SQUARE_SIZE,gs-&gt;mapx-3);
+	e-&gt;y1=std::max((int)(pos.z-radius)/SQUARE_SIZE,2);
+	e-&gt;y2=std::min((int)(pos.z+radius)/SQUARE_SIZE,gs-&gt;mapy-3);
 
 	float* heightmap = readmap-&gt;GetHeightmap();
 	float baseStrength=-pow(strength,0.6f)*3/mapHardness;
 	float invRadius=1.0f/radius;
 	for(int y=e-&gt;y1;y&lt;=e-&gt;y2;++y){
 		for(int x=e-&gt;x1;x&lt;=e-&gt;x2;++x){
-			if(readmap-&gt;groundBlockingObjectMap[y*gs-&gt;mapx+x] &amp;&amp; readmap-&gt;groundBlockingObjectMap[y*gs-&gt;mapx+x]-&gt;blockHeightChanges){			//dont change squares with building on them here
+			CSolidObject* so = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y * gs-&gt;mapx + x);
+			// don't change squares with building on them here
+			if (so &amp;&amp; so-&gt;blockHeightChanges) {
 				e-&gt;squares.push_back(0);
 				continue;
 			}
@@ -165,10 +169,10 @@
 	}
 
 	float3 n1,n2,n3,n4;
-	int decy=max(0,y1-1);
-	int incy=min(gs-&gt;mapy-1,y2+1);
-	int decx=max(0,x1-1);
-	int incx=min(gs-&gt;mapx-1,x2+1);
+	int decy=std::max(0,y1-1);
+	int incy=std::min(gs-&gt;mapy-1,y2+1);
+	int decx=std::max(0,x1-1);
+	int incx=std::min(gs-&gt;mapx-1,x2+1);
 
 	for(int y=decy;y&lt;=incy;y++) {
 		for(int x=decx;x&lt;=incx;x++)
@@ -191,9 +195,9 @@
 		}
 	}
 
-	for(int y=max(2,(y1&amp;0xfffffe));y&lt;=min(gs-&gt;mapy-3,y2);y+=2)
+	for(int y=std::max(2,(y1&amp;0xfffffe));y&lt;=std::min(gs-&gt;mapy-3,y2);y+=2)
 	{
-		for(int x=max(2,(x1&amp;0xfffffe));x&lt;=min(gs-&gt;mapx-3,x2);x+=2)
+		for(int x=std::max(2,(x1&amp;0xfffffe));x&lt;=std::min(gs-&gt;mapx-3,x2);x+=2)
 		{
 			float3 e1(-SQUARE_SIZE*4,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],0);
 			float3 e2( 0,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y+3)*(gs-&gt;mapx+1)+x-1],-SQUARE_SIZE*4);
@@ -214,10 +218,10 @@
 	featureHandler-&gt;TerrainChanged(x1,y1,x2,y2);
 	readmap-&gt;HeightmapUpdated(x1,x2,y1,y2);
 
-	decy=max(0,(y1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
-	incy=min(qf-&gt;GetNumQuadsZ()-1,(y2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
-	decx=max(0,(x1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
-	incx=min(qf-&gt;GetNumQuadsX()-1,(x2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
+	decy=std::max(0,(y1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
+	incy=std::min(qf-&gt;GetNumQuadsZ()-1,(y2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
+	decx=std::max(0,(x1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
+	incx=std::min(qf-&gt;GetNumQuadsX()-1,(x2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
 
 	for(int y=decy;y&lt;=incy;y++){
 		for(int x=decx;x&lt;=incx;x++){

Modified: branches/gml/rts/Map/Ground.h
===================================================================
--- branches/gml/rts/Map/Ground.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/Ground.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,16 +4,12 @@
 //
 //////////////////////////////////////////////////////////////////////
 
-class CGround;
+#include &quot;GlobalStuff.h&quot;
 
-
-#include &lt;vector&gt;
-	// Added by ClassView
-#include &quot;ReadMap.h&quot;
 class CProjectileHandler;
 class CProjectile;
 
-using namespace std;
+
 class CGround
 {
 public:
@@ -31,13 +27,17 @@
 	void CheckCol(CProjectileHandler* ph);
 	float TrajectoryGroundCol(float3 from, float3 flatdir, float length, float linear, float quadratic);
 
-	inline int GetSquare(const float3&amp; pos){return max(0,min(gs-&gt;mapx-1,(int(pos.x)/SQUARE_SIZE)))+max(0,min(gs-&gt;mapy-1,(int(pos.z)/SQUARE_SIZE)))*gs-&gt;mapx;};
+	inline int GetSquare(const float3&amp; pos) {
+		return std::max(0, std::min(gs-&gt;mapx - 1, (int(pos.x) / SQUARE_SIZE))) +
+			std::max(0, std::min(gs-&gt;mapy - 1, (int(pos.z) / SQUARE_SIZE))) * gs-&gt;mapx;
+	};
 private:
 
 	void CheckColSquare(CProjectile* p,int x,int y);
 
 	float LineGroundSquareCol(const float3 &amp;from,const float3 &amp;to,int xs,int ys);
 };
+
 extern CGround* ground;
 
 #endif /* GROUND_H */

Copied: branches/gml/rts/Map/HeightLinePalette.cpp (from rev 5882, trunk/rts/Map/HeightLinePalette.cpp)
===================================================================
--- branches/gml/rts/Map/HeightLinePalette.cpp	                        (rev 0)
+++ branches/gml/rts/Map/HeightLinePalette.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,40 @@
+#include &quot;HeightLinePalette.h&quot;
+
+#include &quot;Platform/ConfigHandler.h&quot;
+
+
+/** @brief Generates the height line palette.
+Based on the configuration variable &quot;ColorElev&quot; (default: 1), it either
+generates a colored palette or a grayscale palette. */
+
+CHeightLinePalette::CHeightLinePalette()
+{
+	if(configHandler.GetInt(&quot;ColorElev&quot;,1)){
+		for(int a=0;a&lt;86;++a){
+			heightLinePal[a*3+0]=255-a*3;
+			heightLinePal[a*3+1]=a*3;
+			heightLinePal[a*3+2]=0;
+		}
+		for(int a=86;a&lt;172;++a){
+			heightLinePal[a*3+0]=0;
+			heightLinePal[a*3+1]=255-(a-86)*3;
+			heightLinePal[a*3+2]=(a-86)*3;
+		}
+		for(int a=172;a&lt;256;++a){
+			heightLinePal[a*3+0]=(a-172)*3;
+			heightLinePal[a*3+1]=0;
+			heightLinePal[a*3+2]=255-(a-172)*3;
+		}
+	} else {
+		for(int a=0;a&lt;29;++a){
+			heightLinePal[a*3+0]=255-a*8;
+			heightLinePal[a*3+1]=255-a*8;
+			heightLinePal[a*3+2]=255-a*8;
+		}
+		for(int a=29;a&lt;256;++a){
+			heightLinePal[a*3+0]=a;
+			heightLinePal[a*3+1]=a;
+			heightLinePal[a*3+2]=a;
+		}
+	}
+}

Copied: branches/gml/rts/Map/HeightLinePalette.h (from rev 5882, trunk/rts/Map/HeightLinePalette.h)
===================================================================
--- branches/gml/rts/Map/HeightLinePalette.h	                        (rev 0)
+++ branches/gml/rts/Map/HeightLinePalette.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,18 @@
+#ifndef HEIGHTLINEPALETTE_H
+#define HEIGHTLINEPALETTE_H
+
+/** @brief The palette used in heightmap rendering mode (F1). */
+class CHeightLinePalette
+{
+public:
+	CHeightLinePalette();
+
+	/** @brief Gets the palette.
+	The palette data consists of 256 RGB triplets with range 0-255. */
+	const unsigned char* GetData() const { return heightLinePal; }
+
+private:
+	unsigned char heightLinePal[3*256];
+};
+
+#endif


Property changes on: branches/gml/rts/Map/HeightMapTexture.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Map/HeightMapTexture.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Map/MapDamage.cpp
===================================================================
--- branches/gml/rts/Map/MapDamage.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/MapDamage.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,6 +3,7 @@
 #include &quot;BasicMapDamage.h&quot;
 #include &quot;NoMapDamage.h&quot;
 #include &quot;ReadMap.h&quot;
+#include &quot;MapInfo.h&quot;
 #include &quot;Game/GameSetup.h&quot;
 
 IMapDamage* mapDamage;
@@ -20,7 +21,7 @@
 {
 	bool disable = false;
 	
-	if (readmap-&gt;mapDefParser.SGetValueDef(&quot;0&quot;, &quot;MAP\\NotDeformable&quot;) != &quot;0&quot;)
+	if (mapInfo-&gt;map.notDeformable)
 		disable = true;
 	else if (gameSetup &amp;&amp; gameSetup-&gt;disableMapDamage)
 		disable = true;

Copied: branches/gml/rts/Map/MapInfo.cpp (from rev 5882, trunk/rts/Map/MapInfo.cpp)
===================================================================
--- branches/gml/rts/Map/MapInfo.cpp	                        (rev 0)
+++ branches/gml/rts/Map/MapInfo.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,230 @@
+#include &quot;MapInfo.h&quot;
+
+#include &quot;TdfParser.h&quot;
+
+
+float4::float4()
+{
+	float tmp[4];
+
+	// ensure alignment is correct to use it as array of floats
+	(void) tmp;
+	assert(&amp;y - &amp;x == &amp;tmp[1] - &amp;tmp[0]);
+	assert(&amp;z - &amp;x == &amp;tmp[2] - &amp;tmp[0]);
+	assert(&amp;w - &amp;x == &amp;tmp[3] - &amp;tmp[0]);
+
+	x = 0.0f;
+	y = 0.0f;
+	z = 0.0f;
+	w = 0.0f;
+}
+
+
+// before delete, the const is const_cast'ed away.
+// there are no (other) situations where mapInfo may be modified
+const CMapInfo* mapInfo;
+
+
+CMapInfo::CMapInfo(const std::string&amp; mapname)
+{
+	map.name = mapname;
+	mapDefParser = new TdfParser(GetTDFName(mapname));
+	resources = new TdfParser(&quot;gamedata/resources.tdf&quot;);
+
+	ReadGlobal();
+	ReadAtmosphere();
+	ReadGui();
+	ReadLight();
+	ReadWater();
+	ReadSmf();
+	ReadSm3();
+	ReadTerrainTypes();
+
+	delete resources;
+	resources = NULL;
+}
+
+
+CMapInfo::~CMapInfo()
+{
+	delete mapDefParser;
+	mapDefParser = NULL;
+}
+
+
+/** @brief Opens the TDF file from the given map in parser.
+	FIXME: This is mostly a hack to supply CGameSetup with start positions,
+	when no CMapInfo object has yet been created.
+ */
+void CMapInfo::OpenTDF(const std::string&amp; mapname, TdfParser&amp; parser)
+{
+	parser.LoadFile(GetTDFName(mapname));
+}
+
+
+/** @brief Get the name of the TDF file with map settings.
+	@return &quot;maps/%.smd&quot; for &quot;%.smf&quot; and &quot;maps/%.sm3&quot; for &quot;%.sm3&quot;
+ */
+std::string CMapInfo::GetTDFName(const std::string&amp; mapname)
+{
+	if (mapname.length() &lt; 3)
+		throw std::runtime_error(&quot;CMapInfo::GetTDFName(): mapname '&quot; + mapname + &quot;' too short&quot;);
+
+	std::string extension = mapname.substr(mapname.length() - 3);
+	if (extension == &quot;smf&quot;)
+		return std::string(&quot;maps/&quot;) + mapname.substr(0, mapname.find_last_of('.')) + &quot;.smd&quot;;
+	else if(extension == &quot;sm3&quot;)
+		return std::string(&quot;maps/&quot;) + mapname;
+	else
+		throw std::runtime_error(&quot;CMapInfo::GetTDFName(): Unknown extension: &quot; + extension);
+}
+
+
+void CMapInfo::ReadGlobal()
+{
+	map.humanName = mapDefParser-&gt;SGetValueDef(map.name, &quot;MAP\\Description&quot;);
+	map.wantedScript = mapDefParser-&gt;SGetValueDef(map.wantedScript, &quot;MAP\\Script&quot;);
+
+	mapDefParser-&gt;GetTDef(map.hardness, 100.0f, &quot;MAP\\MapHardness&quot;);
+	map.notDeformable = mapDefParser-&gt;SGetValueDef(&quot;0&quot;, &quot;MAP\\NotDeformable&quot;) != &quot;0&quot;;
+
+	mapDefParser-&gt;GetTDef(map.gravity, 130.0f, &quot;MAP\\Gravity&quot;);
+	map.gravity = -map.gravity / (GAME_SPEED * GAME_SPEED);
+
+	mapDefParser-&gt;GetTDef(map.tidalStrength, 0.0f, &quot;MAP\\TidalStrength&quot;);
+	mapDefParser-&gt;GetTDef(map.maxMetal, 0.02f, &quot;MAP\\MaxMetal&quot;);
+	mapDefParser-&gt;GetTDef(map.extractorRadius, 500.0f, &quot;MAP\\ExtractorRadius&quot;);
+
+	mapDefParser-&gt;GetDef(map.voidWater, &quot;0&quot;, &quot;MAP\\voidWater&quot;);
+}
+
+
+void CMapInfo::ReadGui()
+{
+	// GUI
+	mapDefParser-&gt;GetTDef(gui.autoShowMetal, true, &quot;MAP\\autoShowMetal&quot;);
+}
+
+
+void CMapInfo::ReadAtmosphere()
+{
+	// MAP\ATMOSPHERE
+	mapDefParser-&gt;GetTDef(atmosphere.cloudDensity, 0.5f, &quot;MAP\\ATMOSPHERE\\CloudDensity&quot;);
+	mapDefParser-&gt;GetTDef(atmosphere.fogStart, 0.1f, &quot;MAP\\ATMOSPHERE\\FogStart&quot;);
+	atmosphere.fogColor = mapDefParser-&gt;GetFloat3(float3(0.7f, 0.7f, 0.8f), &quot;MAP\\ATMOSPHERE\\FogColor&quot;);
+	atmosphere.skyColor = mapDefParser-&gt;GetFloat3(float3(0.1f, 0.15f, 0.7f), &quot;MAP\\ATMOSPHERE\\SkyColor&quot;);
+	atmosphere.sunColor = mapDefParser-&gt;GetFloat3(float3(1.0f, 1.0f, 1.0f), &quot;MAP\\ATMOSPHERE\\SunColor&quot;);
+	atmosphere.cloudColor = mapDefParser-&gt;GetFloat3(float3(1.0f, 1.0f, 1.0f), &quot;MAP\\ATMOSPHERE\\CloudColor&quot;);
+	mapDefParser-&gt;GetTDef(atmosphere.minWind, 5.0f, &quot;MAP\\ATMOSPHERE\\MinWind&quot;);
+	mapDefParser-&gt;GetTDef(atmosphere.maxWind, 25.0f, &quot;MAP\\ATMOSPHERE\\MaxWind&quot;);
+	mapDefParser-&gt;GetDef(atmosphere.skyBox, &quot;&quot;, &quot;MAP\\ATMOSPHERE\\SkyBox&quot;);
+}
+
+
+void CMapInfo::ReadLight()
+{
+	// MAP\LIGHT
+	light.sunDir = mapDefParser-&gt;GetFloat3(float3(0.0f, 1.0f, 2.0f), &quot;MAP\\LIGHT\\SunDir&quot;);
+	light.sunDir.Normalize();
+
+	light.groundAmbientColor = mapDefParser-&gt;GetFloat3(float3(0.5f, 0.5f, 0.5f), &quot;MAP\\LIGHT\\GroundAmbientColor&quot;);
+	light.groundSunColor = mapDefParser-&gt;GetFloat3(float3(0.5f, 0.5f, 0.5f), &quot;MAP\\LIGHT\\GroundSunColor&quot;);
+	light.groundSpecularColor = mapDefParser-&gt;GetFloat3(float3(0.1f, 0.1f, 0.1f), &quot;MAP\\LIGHT\\GroundSpecularColor&quot;);
+	mapDefParser-&gt;GetTDef(light.groundShadowDensity, 0.8f, &quot;MAP\\LIGHT\\GroundShadowDensity&quot;);
+
+	light.unitAmbientColor = float4(mapDefParser-&gt;GetFloat3(float3(0.4f, 0.4f, 0.4f), &quot;MAP\\LIGHT\\UnitAmbientColor&quot;), 1.0f);
+	light.unitSunColor = float4(mapDefParser-&gt;GetFloat3(float3(0.7f, 0.7f, 0.7f), &quot;MAP\\LIGHT\\UnitSunColor&quot;), 1.0f);
+	light.specularSunColor = mapDefParser-&gt;GetFloat3(light.unitSunColor, &quot;MAP\\LIGHT\\SpecularSunColor&quot;);
+	mapDefParser-&gt;GetTDef(light.unitShadowDensity, 0.8f, &quot;MAP\\LIGHT\\UnitShadowDensity&quot;);
+}
+
+
+void CMapInfo::ReadWater()
+{
+	// MAP\WATER
+	mapDefParser-&gt;GetTDef(water.repeatX, 0.0f, &quot;MAP\\WATER\\WaterRepeatX&quot;);
+	mapDefParser-&gt;GetTDef(water.repeatY, 0.0f, &quot;MAP\\WATER\\WaterRepeatY&quot;);
+	mapDefParser-&gt;GetTDef(water.damage, 0.0f, &quot;MAP\\WATER\\WaterDamage&quot;);
+	water.damage *= 16.0f / 30.0f;
+	
+	std::string tmp;
+	mapDefParser-&gt;GetDef(tmp, &quot;&quot;, &quot;MAP\\WATER\\WaterPlaneColor&quot;);
+	hasWaterPlane = !tmp.empty();
+	water.planeColor = mapDefParser-&gt;GetFloat3(float3(0.0f, 0.4f, 0.0f), &quot;MAP\\WATER\\WaterPlaneColor&quot;);
+
+	mapDefParser-&gt;GetDef(water.fresnelMin,&quot;0.2&quot;,&quot;MAP\\WATER\\FresnelMin&quot;);
+	mapDefParser-&gt;GetDef(water.fresnelMax,&quot;0.3&quot;,&quot;MAP\\WATER\\FresnelMax&quot;);
+	mapDefParser-&gt;GetDef(water.fresnelPower,&quot;4.0&quot;,&quot;MAP\\WATER\\FresnelPower&quot;);
+
+	mapDefParser-&gt;GetDef(water.specularFactor,&quot;20.0&quot;,&quot;MAP\\WATER\\WaterSpecularFactor&quot;);
+
+	water.specularColor = mapDefParser-&gt;GetFloat3(light.groundSunColor,&quot;MAP\\WATER\\WaterSpecularColor&quot;);
+	water.surfaceColor = mapDefParser-&gt;GetFloat3(float3(0.75f, 0.8f, 0.85f), &quot;MAP\\WATER\\WaterSurfaceColor&quot;);
+	mapDefParser-&gt;GetDef(water.surfaceAlpha,&quot;0.55&quot;,&quot;MAP\\WATER\\WaterSurfaceAlpha&quot;);
+	water.absorb = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterAbsorb&quot;);
+	water.baseColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterBaseColor&quot;);
+	water.minColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterMinColor&quot;);
+
+	mapDefParser-&gt;GetDef(water.texture, &quot;&quot;, &quot;MAP\\WATER\\WaterTexture&quot;);
+	mapDefParser-&gt;GetDef(water.foamTexture, &quot;&quot;, &quot;MAP\\WATER\\WaterFoamTexture&quot;);
+	mapDefParser-&gt;GetDef(water.normalTexture, &quot;&quot;, &quot;MAP\\WATER\\WaterNormalTexture&quot;);
+
+	//default water is ocean.jpg in bitmaps, map specific water textures is saved in the map dir
+	if(water.texture.empty())
+		water.texture = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;ocean.jpg&quot;, &quot;resources\\graphics\\maps\\watertex&quot;);
+	else
+		water.texture = &quot;maps/&quot; + water.texture;
+
+	
+	if(water.foamTexture.empty())
+		water.foamTexture = &quot;bitmaps/&quot;+resources-&gt;SGetValueDef(&quot;foam.jpg&quot;,&quot;resources\\graphics\\maps\\waterfoamtex&quot;);
+	else
+		water.foamTexture = &quot;maps/&quot; + water.foamTexture;
+
+	if(water.normalTexture.empty())
+		water.normalTexture = &quot;bitmaps/&quot;+resources-&gt;SGetValueDef(&quot;waterbump.png&quot;,&quot;resources\\graphics\\maps\\waternormaltex&quot;);
+	else
+		water.normalTexture = &quot;maps/&quot; + water.normalTexture;
+
+	char num[10];
+	for (int i = 0; i &lt; 32; i++) {
+		sprintf(num, &quot;%02i&quot;, i);
+		water.causticTextures[i] = std::string(&quot;bitmaps/&quot;) + resources-&gt;SGetValueDef(std::string(&quot;caustics/caustic&quot;)+num+&quot;.jpg&quot;,
+								std::string(&quot;resources\\graphics\\caustics\\caustic&quot;)+num);
+	}
+}
+
+
+void CMapInfo::ReadSmf()
+{
+	// SMF specific settings
+	mapDefParser-&gt;GetDef(smf.detailTexName, &quot;&quot;, &quot;MAP\\DetailTex&quot;);
+	if (smf.detailTexName.empty())
+		smf.detailTexName = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;detailtex2.bmp&quot;, &quot;resources\\graphics\\maps\\detailtex&quot;);
+	else
+		smf.detailTexName = &quot;maps/&quot; + smf.detailTexName;
+}
+
+
+void CMapInfo::ReadSm3()
+{
+	// SM3 specific settings
+	sm3.minimap = mapDefParser-&gt;SGetValueDef(&quot;&quot;, &quot;MAP\\minimap&quot;);
+}
+
+
+void CMapInfo::ReadTerrainTypes()
+{
+	for (int a = 0; a &lt; 256; ++a) {
+		char tname[200];
+		sprintf(tname, &quot;MAP\\TerrainType%i\\&quot;, a);
+		std::string section = tname;
+		mapDefParser-&gt;GetDef (terrainTypes[a].name,  &quot;Default&quot;, section + &quot;name&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].hardness,   1.0f, section + &quot;hardness&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].tankSpeed,  1.0f, section + &quot;tankmovespeed&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].kbotSpeed,  1.0f, section + &quot;kbotmovespeed&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].hoverSpeed, 1.0f, section + &quot;hovermovespeed&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].shipSpeed,  1.0f, section + &quot;shipmovespeed&quot;);
+		mapDefParser-&gt;GetDef(terrainTypes[a].receiveTracks, &quot;1&quot;, section + &quot;receivetracks&quot;);
+	}
+}

Copied: branches/gml/rts/Map/MapInfo.h (from rev 5882, trunk/rts/Map/MapInfo.h)
===================================================================
--- branches/gml/rts/Map/MapInfo.h	                        (rev 0)
+++ branches/gml/rts/Map/MapInfo.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,179 @@
+#ifndef MAPINFO_H
+#define MAPINFO_H
+
+#include &lt;string&gt;
+#include &quot;float3.h&quot;
+
+class TdfParser;
+
+
+/** Float3 with a fourth data member, which is basically unused but required
+    to be able to pass the float3 into e.g. OpenGL functions that expect
+    an array of 4 floats. */
+struct float4 : public float3
+{
+	float w;
+
+	float4();
+	float4(const float3&amp; f, float w = 0.0f) : float3(f), w(w) {}
+
+	/// Allows implicit conversion to const float* (for passing to gl functions)
+	operator const float* () const { return &x; }
+};
+
+
+class CMapInfo
+{
+public:
+
+	static void OpenTDF(const std::string&amp; mapname, TdfParser&amp; parser);
+	static std::string GetTDFName(const std::string&amp; mapname);
+
+	CMapInfo(const std::string&amp; mapname);
+	~CMapInfo();
+
+	/** @brief Get a readonly reference to the TDF parser.
+	    This is needed by SM3 code to load feature and layer data. */
+	const TdfParser&amp; GetMapDefParser() const { return *mapDefParser; }
+
+	/* The settings are just public members because:
+
+	   1) it's quite some work to encapsulate all of them, and
+	   2) nothing too bad happens if you modify them, there are no complex
+	      pointer members that really beg for encapsulation.
+
+	   Instead of encapsulation it is as effective and much easier make the
+	   global mapInfo const, ie. const CMapInfo* mapInfo;
+	 */
+
+	/* Note: this could (should) have been anonymous structures if only MSVC 8
+	   didn't crap out on it.  Specifically, it craps out on any class with at
+	   least 1 user defined non-inline constructor and at least 2 anonymous
+	   structures, each with at least 1 object with a constructor in it.
+	   In other words, it probably assigns the same name to each anonymous
+	   structure, and later gets confused by that.
+
+	   This sample code triggers the problem in MSVC:
+
+		class A {
+			A::A();
+			struct { std::string s1; } a1;
+			struct { std::string s2; } a2;
+		};
+		A::A() {}
+	 */
+
+	/** Global settings, ie. from &quot;MAP&quot; section. */
+	struct map_t {
+		std::string name;      ///&lt; The filename as passed to the constructor.
+		std::string wantedScript;
+		std::string humanName; ///&lt; &quot;MAP\\Description&quot;
+		float hardness;        ///&lt; &quot;MAP\\MapHardness&quot;
+		bool  notDeformable;
+		/** Stores the gravity as a negative number in units/frame^2
+		    (NOT positive units/second^2 as in the mapfile) */
+		float gravity;
+		float tidalStrength;
+		float maxMetal;
+		float extractorRadius; ///&lt; extraction radius for mines
+		bool  voidWater;
+	} map;
+
+	/** GUI settings (used by CGuiHandler) */
+	struct gui_t {
+		bool autoShowMetal;
+	} gui;
+
+	/** settings read from &quot;MAP\ATMOSPHERE&quot; section */
+	struct atmosphere_t {
+		float  cloudDensity;
+		float  fogStart;
+		float4 fogColor;
+		float3 skyColor;
+		float3 sunColor;
+		float3 cloudColor;
+		float  minWind;
+		float  maxWind;
+		std::string skyBox;
+	} atmosphere;
+
+	/** settings read from &quot;MAP\LIGHT&quot; section */
+	struct light_t {
+		float4 sunDir;     ///&lt; Holds vector for the direction of the sun
+		float3 groundAmbientColor;
+		float3 groundSunColor;
+		float3 groundSpecularColor;
+		float  groundShadowDensity;
+		float4 unitAmbientColor;
+		float4 unitSunColor;
+		float3 specularSunColor;
+		float  unitShadowDensity;
+	} light;
+
+	/** settings read from &quot;MAP\WATER&quot; section
+	    prefix their name with &quot;Water&quot; to get the TDF variable */
+	struct water_t {
+		float  repeatX; ///&lt; (calculated default is in CBaseWater)
+		float  repeatY; ///&lt; (calculated default is in CBaseWater)
+		float  damage;
+		float3 absorb;
+		float3 baseColor;
+		float3 minColor;
+		float3 surfaceColor;
+		float surfaceAlpha;
+		float3 planeColor;
+		float3 specularColor;
+		float specularFactor;
+		float fresnelMin;
+		float fresnelMax;
+		float fresnelPower;
+		std::string texture;
+		std::string foamTexture;
+		std::string normalTexture;
+		std::string causticTextures[32];
+	} water;
+	bool hasWaterPlane; ///&lt; true if &quot;MAP\WATER\WaterPlaneColor&quot; is set
+
+	/** SMF specific settings */
+	struct smf_t {
+		std::string detailTexName; ///&lt; &quot;MAP\DetailTex&quot;
+	} smf;
+
+	/** SM3 specific settings
+	    This is NOT complete, SM3 stores so much in the map settings
+	    that it really isn't a good idea to put them here. */
+	struct sm3_t {
+		std::string minimap; ///&lt; &quot;MAP\minimap&quot;
+	} sm3;
+
+	/** Terrain type, there can be 256 of these:
+	    &quot;MAP\TerrainType0&quot; up to &quot;MAP\TerrainType255&quot; */
+	struct TerrainType {
+		std::string name;
+		float hardness;
+		float tankSpeed;   ///&lt; &quot;TankMoveSpeed&quot;
+		float kbotSpeed;   ///&lt; &quot;KbotMoveSpeed&quot;
+		float hoverSpeed;  ///&lt; &quot;HoverMoveSpeed&quot;
+		float shipSpeed;   ///&lt; &quot;ShipMoveSpeed&quot;
+		bool receiveTracks;
+	};
+	TerrainType terrainTypes[256];
+
+private:
+
+	void ReadGlobal();
+	void ReadGui();
+	void ReadAtmosphere();
+	void ReadLight();
+	void ReadWater();
+	void ReadSmf();
+	void ReadSm3();
+	void ReadTerrainTypes();
+
+	TdfParser* resources;
+	TdfParser* mapDefParser;
+};
+
+extern const CMapInfo* mapInfo;
+
+#endif // MAPINFO_H

Modified: branches/gml/rts/Map/ReadMap.cpp
===================================================================
--- branches/gml/rts/Map/ReadMap.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/ReadMap.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,14 +7,11 @@
 #include &quot;ReadMap.h&quot;
 #include &lt;stdlib.h&gt;
 #include &lt;string&gt;
-//#include &lt;ostream&gt;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Ground.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
-#ifdef _WIN32
-#include &lt;process.h&gt;
-#endif
 #include &quot;MapDamage.h&quot;
+#include &quot;MapInfo.h&quot;
 #include &quot;MetalMap.h&quot;
 #include &quot;Sim/Path/PathManager.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
@@ -38,29 +35,10 @@
 
 CR_BIND_INTERFACE(CReadMap)
 CR_REG_METADATA(CReadMap, (
-				CR_MEMBER(groundBlockingObjectMap),
 				CR_SERIALIZER(Serialize)
 				));
 
-void CReadMap::OpenTDF (const std::string&amp; mapname, TdfParser&amp; parser)
-{
-	parser.LoadFile(GetTDFName(mapname));
-}
 
-std::string CReadMap::GetTDFName(const std::string&amp; mapname)
-{
-	if (mapname.length() &lt; 3)
-		throw std::runtime_error(&quot;CReadMap::GetTDFName(): mapname '&quot; + mapname + &quot;' too short&quot;);
-
-	string extension = mapname.substr(mapname.length()-3);
-	if (extension == &quot;smf&quot;)
-		return string(&quot;maps/&quot;)+mapname.substr(0,mapname.find_last_of('.'))+&quot;.smd&quot;;
-	else if(extension == &quot;sm3&quot;)
-		return string(&quot;maps/&quot;)+mapname;
-	else
-		throw std::runtime_error(&quot;CReadMap::GetTDFName(): Unknown extension: &quot; + extension);
-}
-
 CReadMap* CReadMap::LoadMap (const std::string&amp; mapname)
 {
 	if (mapname.length() &lt; 3)
@@ -78,8 +56,6 @@
 	if (!rm)
 		return 0;
 
-	rm-&gt;mapName = mapname;
-
 	/* Read metal map */
 	MapBitmapInfo mbi;
 	unsigned char  *metalmap = rm-&gt;GetInfoMap (&quot;metal&quot;, &amp;mbi);
@@ -88,7 +64,7 @@
 		int size = mbi.width*mbi.height;
 		unsigned char *map = SAFE_NEW unsigned char[size];
 		memcpy(map, metalmap, size);
-		rm-&gt;metalMap = SAFE_NEW CMetalMap(map, mbi.width, mbi.height, rm-&gt;maxMetal);
+		rm-&gt;metalMap = SAFE_NEW CMetalMap(map, mbi.width, mbi.height, mapInfo-&gt;map.maxMetal);
 	}
 	if (metalmap) rm-&gt;FreeInfoMap (&quot;metal&quot;, metalmap);
 
@@ -106,28 +82,10 @@
 		assert (gs-&gt;hmapx == tbi.width &amp;&amp; gs-&gt;hmapy == tbi.height);
 		rm-&gt;typemap = SAFE_NEW unsigned char[tbi.width*tbi.height];
 		memcpy(rm-&gt;typemap, typemap, tbi.width*tbi.height);
-
-		rm-&gt;terrainTypes.resize(256);
-		for(int a=0;a&lt;256;++a){
-			char tname[200];
-			sprintf(tname,&quot;TerrainType%i\\&quot;,a);
-			string section=&quot;map\\&quot;;
-			section+=tname;
-			rm-&gt;mapDefParser.GetDef(rm-&gt;terrainTypes[a].name,&quot;Default&quot;,section+&quot;name&quot;);
-			rm-&gt;mapDefParser.GetDef(rm-&gt;terrainTypes[a].hardness,&quot;1&quot;,section+&quot;hardness&quot;);
-			rm-&gt;mapDefParser.GetDef(rm-&gt;terrainTypes[a].tankSpeed,&quot;1&quot;,section+&quot;tankmovespeed&quot;);
-			rm-&gt;mapDefParser.GetDef(rm-&gt;terrainTypes[a].kbotSpeed,&quot;1&quot;,section+&quot;kbotmovespeed&quot;);
-			rm-&gt;mapDefParser.GetDef(rm-&gt;terrainTypes[a].hoverSpeed,&quot;1&quot;,section+&quot;hovermovespeed&quot;);
-			rm-&gt;mapDefParser.GetDef(rm-&gt;terrainTypes[a].shipSpeed,&quot;1&quot;,section+&quot;shipmovespeed&quot;);
-			rm-&gt;mapDefParser.GetDef(rm-&gt;terrainTypes[a].receiveTracks,&quot;1&quot;,section+&quot;receivetracks&quot;);
-		}
 	} else
 		throw content_error(&quot;Bad/no terrain type map.&quot;);
 	if (typemap) rm-&gt;FreeInfoMap (&quot;type&quot;, typemap);
 
-	rm-&gt;groundBlockingObjectMap.resize(gs-&gt;mapSquares,0);
-//	memset(rm-&gt;groundBlockingObjectMap, 0, gs-&gt;mapSquares*sizeof(CSolidObject*));
-
 	return rm;
 }
 
@@ -137,8 +95,6 @@
 		slopemap(NULL),
 		facenormals(NULL),
 		typemap(NULL),
-		heightLinePal(NULL),
-//		groundBlockingObjectMap(NULL),
 		metalMap(NULL)
 {
 	memset(mipHeightmap, 0, sizeof(mipHeightmap));
@@ -156,8 +112,6 @@
 		delete[] mipHeightmap[i];
 
 	delete[] orgheightmap;
-//	delete[] groundBlockingObjectMap;
-	delete[] heightLinePal;
 }
 
 void CReadMap::Serialize(creg::ISerializer&amp; s)
@@ -172,11 +126,8 @@
 void CReadMap::Initialize()
 {
 	PrintLoadMsg(&quot;Loading Map&quot;);
-	float* heightmap = GetHeightmap();
 
 	orgheightmap=SAFE_NEW float[(gs-&gt;mapx+1)*(gs-&gt;mapy+1)];
-	for(int y=0;y&lt;(gs-&gt;mapy+1)*(gs-&gt;mapx+1);++y)
-		orgheightmap[y]=heightmap[y];
 
 	//	normals=SAFE_NEW float3[(gs-&gt;mapx+1)*(gs-&gt;mapy+1)];
 	facenormals=SAFE_NEW float3[gs-&gt;mapx*gs-&gt;mapy*2];
@@ -188,36 +139,6 @@
 
 	slopemap=SAFE_NEW float[gs-&gt;hmapx*gs-&gt;hmapy];
 
-	heightLinePal=SAFE_NEW unsigned char[3*256];
-	if(configHandler.GetInt(&quot;ColorElev&quot;,1)){
-		for(int a=0;a&lt;86;++a){
-			heightLinePal[a*3+0]=255-a*3;
-			heightLinePal[a*3+1]=a*3;
-			heightLinePal[a*3+2]=0;
-		}
-		for(int a=86;a&lt;172;++a){
-			heightLinePal[a*3+0]=0;
-			heightLinePal[a*3+1]=255-(a-86)*3;
-			heightLinePal[a*3+2]=(a-86)*3;
-		}
-		for(int a=172;a&lt;256;++a){
-			heightLinePal[a*3+0]=(a-172)*3;
-			heightLinePal[a*3+1]=0;
-			heightLinePal[a*3+2]=255-(a-172)*3;
-		}
-	} else {
-		for(int a=0;a&lt;29;++a){
-			heightLinePal[a*3+0]=255-a*8;
-			heightLinePal[a*3+1]=255-a*8;
-			heightLinePal[a*3+2]=255-a*8;
-		}
-		for(int a=29;a&lt;256;++a){
-			heightLinePal[a*3+0]=a;
-			heightLinePal[a*3+1]=a;
-			heightLinePal[a*3+2]=a;
-		}
-	}
-
 	CalcHeightfieldData();
 }
 
@@ -311,216 +232,5 @@
 }
 
 
-extern GLfloat FogLand[];
-
-void CReadMap::ParseSettings(TdfParser&amp; resources)
-{
-	mapHumanName = mapDefParser.SGetValueDef(mapName, &quot;MAP\\Description&quot;);
-
-	gs-&gt;sunVector=mapDefParser.GetFloat3(float3(0,1,2),&quot;MAP\\LIGHT\\SunDir&quot;);
-	gs-&gt;sunVector.Normalize();
-	gs-&gt;sunVector4[0]=gs-&gt;sunVector[0];
-	gs-&gt;sunVector4[1]=gs-&gt;sunVector[1];
-	gs-&gt;sunVector4[2]=gs-&gt;sunVector[2];
-	gs-&gt;sunVector4[3]=0;
-
-	gs-&gt;gravity=-atof(mapDefParser.SGetValueDef(&quot;130&quot;,&quot;MAP\\Gravity&quot;).c_str())/(GAME_SPEED*GAME_SPEED);
-
-	float3 fogColor=mapDefParser.GetFloat3(float3(0.7f,0.7f,0.8f),&quot;MAP\\ATMOSPHERE\\FogColor&quot;);
-	FogLand[0]=fogColor[0];
-	FogLand[1]=fogColor[1];
-	FogLand[2]=fogColor[2];
-
-	mapDefParser.GetDef(skyBox, &quot;&quot;, &quot;MAP\\ATMOSPHERE\\SkyBox&quot;);
-	std::string tmp;
-	mapDefParser.GetDef(tmp, &quot;&quot;, &quot;MAP\\WATER\\WaterPlaneColor&quot;);
-	if(tmp.empty())
-		hasWaterPlane=0;
-	else
-	{
-		hasWaterPlane = 1;
-		waterPlaneColor = mapDefParser.GetFloat3(float3(0.0f,0.4f,0.0f),&quot;MAP\\WATER\\WaterPlaneColor&quot;);
-	}
-	mapDefParser.GetDef(tidalStrength, &quot;0&quot;, &quot;MAP\\TidalStrength&quot;);
-
-	waterSurfaceColor=mapDefParser.GetFloat3(float3(0.75f,0.8f,0.85f),&quot;MAP\\WATER\\WaterSurfaceColor&quot;);
-	waterAbsorb=mapDefParser.GetFloat3(float3(0,0,0),&quot;MAP\\WATER\\WaterAbsorb&quot;);
-	waterBaseColor=mapDefParser.GetFloat3(float3(0,0,0),&quot;MAP\\WATER\\WaterBaseColor&quot;);
-	waterMinColor=mapDefParser.GetFloat3(float3(0,0,0),&quot;MAP\\WATER\\WaterMinColor&quot;);
-	mapDefParser.GetDef(waterTexture, &quot;&quot;, &quot;MAP\\WATER\\WaterTexture&quot;);
-	if(waterTexture.empty())	//default water is ocean.jpg in bitmaps, map specific water textures is saved in the map dir
-		waterTexture = &quot;bitmaps/&quot;+resources.SGetValueDef(&quot;ocean.jpg&quot;,&quot;resources\\graphics\\maps\\watertex&quot;);
-	else
-		waterTexture = &quot;maps/&quot; + waterTexture;
-
-	ambientColor=mapDefParser.GetFloat3(float3(0.5f,0.5f,0.5f),&quot;MAP\\LIGHT\\GroundAmbientColor&quot;);
-	sunColor=mapDefParser.GetFloat3(float3(0.5f,0.5f,0.5f),&quot;MAP\\LIGHT\\GroundSunColor&quot;);
-	specularColor=mapDefParser.GetFloat3(float3(0.1f,0.1f,0.1f),&quot;MAP\\LIGHT\\GroundSpecularColor&quot;);
-	mapDefParser.GetDef(shadowDensity, &quot;0.8&quot;, &quot;MAP\\LIGHT\\GroundShadowDensity&quot;);
-
-	mapDefParser.GetDef(maxMetal,&quot;0.02&quot;,&quot;MAP\\MaxMetal&quot;);
-	mapDefParser.GetDef(extractorRadius,&quot;500&quot;,&quot;MAP\\ExtractorRadius&quot;);
-
-	mapDefParser.GetDef(voidWater, &quot;0&quot;, &quot;MAP\\voidWater&quot;);
-}
-
-void CReadMap::AddGroundBlockingObject(CSolidObject *object)
-{
-	object-&gt;isMarkedOnBlockingMap=true;
-	object-&gt;mapPos=object-&gt;GetMapPos();
-	if(object-&gt;immobile){
-		object-&gt;mapPos.x&amp;=0xfffffe;
-		object-&gt;mapPos.y&amp;=0xfffffe;
-	}
-	int bx=object-&gt;mapPos.x;
-	int bz=object-&gt;mapPos.y;
-
-	int minXSqr = bx;
-	int minZSqr = bz;
-	int maxXSqr = bx + object-&gt;xsize;
-	int maxZSqr = bz + object-&gt;ysize;
-
-	for(int zSqr = minZSqr; zSqr &lt; maxZSqr; zSqr++)
-		for(int xSqr = minXSqr; xSqr &lt; maxXSqr; xSqr++)
-			if(!groundBlockingObjectMap[xSqr + zSqr*gs-&gt;mapx])
-				groundBlockingObjectMap[xSqr + zSqr*gs-&gt;mapx] = object;
-	if(!object-&gt;mobility &amp;&amp; pathManager)
-		pathManager-&gt;TerrainChange(minXSqr, minZSqr, maxXSqr, maxZSqr);
-}
-
-void CReadMap::AddGroundBlockingObject(CSolidObject *object, unsigned char *yardMap, unsigned char mask)
-{
-	object-&gt;isMarkedOnBlockingMap=true;
-	object-&gt;mapPos=object-&gt;GetMapPos();
-	if(object-&gt;immobile){
-		object-&gt;mapPos.x&amp;=0xfffffe;
-		object-&gt;mapPos.y&amp;=0xfffffe;
-	}
-	int bx=object-&gt;mapPos.x;
-	int bz=object-&gt;mapPos.y;
-
-	int minXSqr = bx;
-	int minZSqr = bz;
-	int maxXSqr = bx + object-&gt;xsize;
-	int maxZSqr = bz + object-&gt;ysize;
-
-	for(int z = 0; minZSqr + z &lt; maxZSqr; z++) {
-		for(int x = 0; minXSqr + x &lt; maxXSqr; x++) {
-			if(!groundBlockingObjectMap[minXSqr + x + (minZSqr + z)*gs-&gt;mapx]){
-				if(yardMap[x + z*object-&gt;xsize] &amp; mask) {
-					groundBlockingObjectMap[minXSqr + x + (minZSqr + z)*gs-&gt;mapx] = object;
-				}
-			}
-		}
-	}
-	if(!object-&gt;mobility &amp;&amp; pathManager)
-		pathManager-&gt;TerrainChange(minXSqr, minZSqr, maxXSqr, maxZSqr);
-}
-
-void CReadMap::RemoveGroundBlockingObject(CSolidObject *object)
-{
-	object-&gt;isMarkedOnBlockingMap=false;
-	int bx=object-&gt;mapPos.x;
-	int bz=object-&gt;mapPos.y;
-	int sx=object-&gt;xsize;
-	int sz=object-&gt;ysize;
-	for(int z = bz; z &lt; bz+sz; ++z)
-		for(int x = bx; x &lt; bx+sx; ++x)
-			if(groundBlockingObjectMap[x + z*gs-&gt;mapx]==object)
-				groundBlockingObjectMap[x + z*gs-&gt;mapx] = 0;
-
-	if(!object-&gt;mobility)
-		pathManager-&gt;TerrainChange(bx, bz, bx+sx, bz+sz);
-}
-
-
-/*
-Moves a ground blocking object from old position to the current on map.
-*/
-void CReadMap::MoveGroundBlockingObject(CSolidObject *object, float3 oldPos) {
-	RemoveGroundBlockingObject(object);
-	AddGroundBlockingObject(object);
-}
-
-
-/*
-Checks if a ground-square is blocked.
-If it's not blocked, then 0 is returned.
-If it's blocked, then a pointer to the blocking object is returned.
-*/
-CSolidObject* CReadMap::GroundBlocked(int mapSquare) {
-	if(mapSquare &lt; 0 || mapSquare &gt;= gs-&gt;mapSquares)
-		return 0;
-	return groundBlockingObjectMap[mapSquare];
-}
-
-
-/*
-Checks if a ground-square is blocked.
-If it's not blocked, then 0 is returned.
-If it's blocked, then a pointer to the blocking object is returned.
-*/
-CSolidObject* CReadMap::GroundBlocked(float3 pos) {
-	int xSqr = int(pos.x / SQUARE_SIZE) % gs-&gt;mapx;
-	int zSqr = int(pos.z / SQUARE_SIZE) / gs-&gt;mapx;
-	return GroundBlocked(xSqr + zSqr*gs-&gt;mapx);
-}
-
-
-/*
-Opens up a yard in a blocked area.
-When a factory opens up, for example.
-*/
-void CReadMap::OpenBlockingYard(CSolidObject *yard, unsigned char *blockingMap) {
-	RemoveGroundBlockingObject(yard);
-	AddGroundBlockingObject(yard, blockingMap, 2);
-}
-
-
-/*
-Closes a yard, blocking the area.
-When a factory closes, for example.
-*/
-void CReadMap::CloseBlockingYard(CSolidObject *yard, unsigned char *blockingMap) {
-	RemoveGroundBlockingObject(yard);
-	AddGroundBlockingObject(yard, blockingMap, 1);
-}
-
-
-/*
-Used to look for dead references in the groundBlockingMap.
-*/
-void CReadMap::CleanBlockingMap(CSolidObject* object) {
-	int i, counter = 0;
-	for(i = 0; i &lt; gs-&gt;mapSquares; i++)
-		if(groundBlockingObjectMap[i] == object) {
-			groundBlockingObjectMap[i] = 0;
-			counter++;
-		}
-
-	if(counter &gt; 0) {
-		logOutput &lt;&lt; &quot;Dead references: &quot; &lt;&lt; counter &lt;&lt; &quot;\n&quot;;
-		if(dynamic_cast&lt;CUnit*&gt;(object)){
-			logOutput.Print(&quot;From %s&quot;,((CUnit*)object)-&gt;unitDef-&gt;humanName.c_str());
-		}
-	}
-}
-
-//this function assumes that the correct map has been loaded and only load/saves new height values
-void CReadMap::LoadSaveMap(CLoadSaveInterface* file,bool loading)
-{
-	float* heightmap=readmap-&gt;GetHeightmap();
-	//load/save heightmap
-	for(int y=0;y&lt;gs-&gt;mapy+1;++y){
-		for(int x=0;x&lt;gs-&gt;mapx+1;++x){
-			file-&gt;lsFloat(heightmap[y*(gs-&gt;mapx+1)+x]);
-		}
-	}
-	//recalculate dependent values if loading
-	if(loading){
-		mapDamage-&gt;RecalcArea(0,gs-&gt;mapx,0,gs-&gt;mapy);
-	}
-}
-
 CReadMap::IQuadDrawer::~IQuadDrawer() {
 }

Modified: branches/gml/rts/Map/ReadMap.h
===================================================================
--- branches/gml/rts/Map/ReadMap.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/ReadMap.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,13 +4,11 @@
 //
 //////////////////////////////////////////////////////////////////////
 
-#include &lt;string&gt;
-#include &lt;vector&gt;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;creg/creg.h&quot;
 #include &quot;float3.h&quot;
-#include &quot;MetalMap.h&quot;
-#include &quot;TdfParser.h&quot;
 
+class CMetalMap;
 class CCamera;
 class CFileHandler;
 class CUnit;
@@ -31,6 +29,7 @@
 	int width,height;
 };
 
+
 class CReadMap
 {
 public:
@@ -40,30 +39,13 @@
 
 	void Serialize(creg::ISerializer&amp; s); // creg serialize callback
 
-	void AddGroundBlockingObject(CSolidObject *object);
-	void AddGroundBlockingObject(CSolidObject *object, unsigned char *blockingMap, unsigned char mask = 255);
-	void RemoveGroundBlockingObject(CSolidObject *object);
-	void MoveGroundBlockingObject(CSolidObject *object, float3 oldPos);
-	void OpenBlockingYard(CSolidObject *yard, unsigned char *blockingMap);
-	void CloseBlockingYard(CSolidObject *yard, unsigned char *blockingMap);
-	CSolidObject* GroundBlocked(float3 pos);
-	CSolidObject* GroundBlocked(int mapSquare);
-	inline CSolidObject* GroundBlockedUnsafe(int mapSquare){return groundBlockingObjectMap[mapSquare];} //simple version of GroundBlocked without error checking
-	void CleanBlockingMap(CSolidObject* object);	//Debug
-
-	static std::string GetTDFName (const std::string&amp; mapname);
-	static void OpenTDF (const std::string&amp; mapname, TdfParser&amp; parser);
 	static CReadMap* LoadMap (const std::string&amp; mapname);
 
 protected:
 	void Initialize(); // called by implementations of CReadMap
 public:
 	void CalcHeightfieldData(); /// Calculates derived heightmap information such as normals, centerheightmap and slopemap
-	void ParseSettings(TdfParser&amp; resources);
 
-	std::string mapName;
-	std::string mapHumanName;
-
 	virtual float* GetHeightmap() = 0; // if you modify the heightmap, call HeightmapUpdated
 	float* orgheightmap;
 	float* centerheightmap;
@@ -73,36 +55,10 @@
 	float3* facenormals;
 	unsigned char* typemap;
 
-	unsigned char* heightLinePal;
-
-	struct TerrainType{
-		std::string name;
-		float hardness;
-		float tankSpeed;
-		float kbotSpeed;
-		float hoverSpeed;
-		float shipSpeed;
-		int receiveTracks;
-	};
-
-	std::vector&lt;TerrainType&gt; terrainTypes;
-
-	std::vector&lt;CSolidObject*&gt; groundBlockingObjectMap;
 	CMetalMap *metalMap;					//Metal-density/height-map
 
-	float tidalStrength;
-	float3 waterAbsorb;
-	float3 waterBaseColor;
-	float3 waterMinColor;
-	float3 waterSurfaceColor;
-	float maxMetal;
-
 	int width, height;
 
-	float3 waterPlaneColor;
-	bool hasWaterPlane;
-	std::string waterTexture;
-
 	unsigned int mapChecksum;
 protected:
 	CReadMap(); // use LoadMap
@@ -140,19 +96,7 @@
 	};
 	virtual void GridVisibility(CCamera *cam, int quadSize, float maxdist, IQuadDrawer *cb, int extraSize=0) = 0;
 
-	TdfParser mapDefParser;
-
-	float3 ambientColor;
-	float3 sunColor;
-	float3 specularColor; // ground specular color
-	float shadowDensity;
-	float extractorRadius;			//extraction radius for mines
-	bool voidWater;
-
 	float minheight,maxheight;
-	void LoadSaveMap(CLoadSaveInterface* file,bool loading);
-
-	std::string skyBox;
 };
 
 extern CReadMap* readmap;

Modified: branches/gml/rts/Map/SM3/Sm3GroundDrawer.cpp
===================================================================
--- branches/gml/rts/Map/SM3/Sm3GroundDrawer.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/Sm3GroundDrawer.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,6 +9,7 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 
 #include &lt;SDL_keysym.h&gt;
@@ -73,7 +74,7 @@
 
 	terrain::RenderContext *currc = rc;
 
-	tr-&gt;SetShaderParams(gs-&gt;sunVector, currc-&gt;cam-&gt;pos);
+	tr-&gt;SetShaderParams(mapInfo-&gt;light.sunDir, currc-&gt;cam-&gt;pos);
 
 	if (shadowHandler-&gt;drawShadows)
 	{
@@ -96,16 +97,16 @@
 
 	glColor4f(1.0f,1.0f,1.0f,1.0f);
 	glEnable(GL_LIGHTING);
-	glLightfv(GL_LIGHT0, GL_POSITION,gs-&gt;sunVector4);
+	glLightfv(GL_LIGHT0, GL_POSITION, mapInfo-&gt;light.sunDir);
 	float d[4]={0.0f,0.0f,0.0f,1.0f};
 	for (int a=0;a&lt;3;a++)
-		d[a]=map-&gt;sunColor[a];
+		d[a]=mapInfo-&gt;light.groundSunColor[a];
 	glLightfv(GL_LIGHT0, GL_DIFFUSE, d);
 	for (int a=0;a&lt;3;a++)
-		d[a]=map-&gt;ambientColor[a];
+		d[a]=mapInfo-&gt;light.groundAmbientColor[a];
 	glLightfv(GL_LIGHT0, GL_AMBIENT, d);
 	for (int a=0;a&lt;3;a++)
-		d[a]=map-&gt;specularColor[a];
+		d[a]=mapInfo-&gt;light.groundSpecularColor[a];
 	glLightfv (GL_LIGHT0, GL_SPECULAR, d);
 	for (int a=0;a&lt;4;a++)
 		d[a]=0.0f;

Modified: branches/gml/rts/Map/SM3/Sm3Map.cpp
===================================================================
--- branches/gml/rts/Map/SM3/Sm3Map.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/Sm3Map.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,11 +7,13 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;IL/il.h&gt;
 #include &lt;SDL_types.h&gt;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Platform/byteorder.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;TdfParser.h&quot;
 
 #include &quot;terrain/TerrainNode.h&quot;
 #include &quot;Game/Camera.h&quot;
@@ -76,16 +78,9 @@
 		if (shadowHandler-&gt;drawShadows)
 			renderer-&gt;config.useShadowMaps = true;
 
-		// Load map info from TDF
-		std::string fn = std::string(&quot;maps/&quot;) + mapname;
-		mapDefParser.LoadFile (fn);
-		TdfParser resources(&quot;gamedata/resources.tdf&quot;);
-		ParseSettings(resources);
-
-		string minimap = mapDefParser.SGetValueDef(string(),&quot;map\\minimap&quot;);
-		if (!minimap.empty()) {
+		if (!mapInfo-&gt;sm3.minimap.empty()) {
 			CBitmap bmp;
-			if(bmp.Load(minimap))
+			if(bmp.Load(mapInfo-&gt;sm3.minimap))
 				minimapTexture=bmp.CreateTexture(true);
 		}
 
@@ -99,13 +94,13 @@
 */
 		Sm3LoadCB loadcb;
 		terrain::LightingInfo lightInfo;
-		lightInfo.ambient = ambientColor;
+		lightInfo.ambient = mapInfo-&gt;light.groundAmbientColor;
 		terrain::StaticLight light;
-		light.color = sunColor;
+		light.color = mapInfo-&gt;light.groundSunColor;
 		light.directional = false;
-		light.position = gs-&gt;sunVector *1000000;
+		light.position = mapInfo-&gt;light.sunDir *1000000;
 		lightInfo.staticLights.push_back (light);
-		renderer-&gt;Load (mapDefParser, &amp;lightInfo, &amp;loadcb);
+		renderer-&gt;Load (mapInfo-&gt;GetMapDefParser(), &amp;lightInfo, &amp;loadcb);
 
 		height = width = renderer-&gt;GetHeightmapWidth ()-1;
 
@@ -123,6 +118,7 @@
 
 		CReadMap::Initialize();
 
+		const TdfParser&amp; mapDefParser = mapInfo-&gt;GetMapDefParser();
 		if (mapDefParser.SectionExist(&quot;map\\featuretypes&quot;)) {
 			int numTypes = atoi(mapDefParser.SGetValueDef(&quot;0&quot;, &quot;map\\featuretypes\\numtypes&quot;).c_str());
 			for (int a=0;a&lt;numTypes;a++) {
@@ -254,7 +250,7 @@
 void CSm3ReadMap::LoadFeatureData()
 {
 		// returns MapFeatureInfo[GetNumFeatures()]
-	std::string fd = mapDefParser.SGetValueDef(std::string(),&quot;map\\featuredata&quot;);
+	std::string fd = mapInfo-&gt;GetMapDefParser().SGetValueDef(std::string(),&quot;map\\featuredata&quot;);
 	if (!fd.empty()) {
 		CFileHandler fh(fd);
 		if (!fh.FileExists())
@@ -315,7 +311,7 @@
 unsigned char *CSm3ReadMap::GetInfoMap (const std::string&amp; name, MapBitmapInfo* bm)
 {
 	std::string map;
-	if (!mapDefParser.SGetValue(map, &quot;MAP\\INFOMAPS\\&quot; + name))
+	if (!mapInfo-&gt;GetMapDefParser().SGetValue(map, &quot;MAP\\INFOMAPS\\&quot; + name))
 		return 0;
 
 	CBitmap img;

Modified: branches/gml/rts/Map/SM3/Sm3Map.h
===================================================================
--- branches/gml/rts/Map/SM3/Sm3Map.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/Sm3Map.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,7 +1,7 @@
-
 #ifndef SM3_MAP_H
 #define SM3_MAP_H
 
+#include &lt;map&gt;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;terrain/TerrainBase.h&quot;
 #include &quot;terrain/Terrain.h&quot;

Modified: branches/gml/rts/Map/SM3/terrain/Lightcalc.cpp
===================================================================
--- branches/gml/rts/Map/SM3/terrain/Lightcalc.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/terrain/Lightcalc.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -33,6 +33,7 @@
 #include &quot;Textures.h&quot;
 #include &quot;Lightcalc.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 
 #include &lt;SDL.h&gt;
 #include &lt;IL/il.h&gt;
@@ -171,7 +172,7 @@
 
 	SaveImage (&quot;lightmap.png&quot;, 4, IL_UNSIGNED_BYTE, w,w, shadingTexData);
 
-	gluBuild2DMipmaps(GL_TEXTURE_2D, 4, w,w, GL_RGBA, GL_UNSIGNED_BYTE, shadingTexData);
+	glBuildMipmaps(GL_TEXTURE_2D, 4, w,w, GL_RGBA, GL_UNSIGNED_BYTE, shadingTexData);
 	delete[] shadingTexData;
 
 	id = shadingTex;

Modified: branches/gml/rts/Map/SM3/terrain/Terrain.cpp
===================================================================
--- branches/gml/rts/Map/SM3/terrain/Terrain.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/terrain/Terrain.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -860,7 +860,7 @@
 		texturing-&gt;DebugEvent (event);
 	}
 
-	void Terrain::Load(TdfParser&amp; tdf, LightingInfo *li, ILoadCallback *cb)
+	void Terrain::Load(const TdfParser&amp; tdf, LightingInfo *li, ILoadCallback *cb)
 	{
 		string basepath = &quot;MAP\\TERRAIN\\&quot;;
 

Modified: branches/gml/rts/Map/SM3/terrain/Terrain.h
===================================================================
--- branches/gml/rts/Map/SM3/terrain/Terrain.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/terrain/Terrain.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -132,7 +132,7 @@
 		void RemoveRenderContext (RenderContext *ctx);
 		void SetActiveContext (RenderContext *ctx);   // set active rendering context / camera viewpoint
 
-		void Load (TdfParser&amp; tdf, LightingInfo* li, ILoadCallback *cb);
+		void Load (const TdfParser&amp; tdf, LightingInfo* li, ILoadCallback *cb);
 		void Draw ();
 		void DrawAll (); // draw all terrain nodes, regardless of visibility or lod
 		void Update (); // update lod+visibility, should be called when camera position has changed

Modified: branches/gml/rts/Map/SM3/terrain/TerrainTexture.cpp
===================================================================
--- branches/gml/rts/Map/SM3/terrain/TerrainTexture.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/terrain/TerrainTexture.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -176,7 +176,7 @@
 		return btex;
 	}
 
-	void TerrainTexture::Load (TdfParser *tdf, Heightmap *heightmap, TQuad *quadtree, const vector&lt;QuadMap*&gt;&amp; qmaps, Config *cfg, ILoadCallback *cb, LightingInfo *li)
+	void TerrainTexture::Load (const TdfParser *tdf, Heightmap *heightmap, TQuad *quadtree, const vector&lt;QuadMap*&gt;&amp; qmaps, Config *cfg, ILoadCallback *cb, LightingInfo *li)
 	{
 		string basepath=&quot;MAP\\TERRAIN\\&quot;;
 
@@ -594,7 +594,7 @@
 	}
 #endif
 
-	void ShaderDef::LoadStages(int numStages,const char *stagename, TdfParser&amp; tdf, std::vector&lt;ShaderDef::Stage&gt;&amp; stages)
+	void ShaderDef::LoadStages(int numStages,const char *stagename, const TdfParser&amp; tdf, std::vector&lt;ShaderDef::Stage&gt;&amp; stages)
 	{
 		for (int a=0;a&lt;numStages;a++)
 		{
@@ -639,7 +639,7 @@
 		}
 	}
 
-	void ShaderDef::Parse(TdfParser&amp; tdf, bool needNormalMap)
+	void ShaderDef::Parse(const TdfParser&amp; tdf, bool needNormalMap)
 	{
 		string path = &quot;map\\terrain\\&quot;;
 

Modified: branches/gml/rts/Map/SM3/terrain/TerrainTexture.h
===================================================================
--- branches/gml/rts/Map/SM3/terrain/TerrainTexture.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/terrain/TerrainTexture.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -76,7 +76,7 @@
 	{
 	public:
 		ShaderDef() { hasLighting=useShadowMapping=false; specularExponent = 16.0f; }
-		void Parse(TdfParser&amp; tdf, bool needNormalMap);
+		void Parse(const TdfParser&amp; tdf, bool needNormalMap);
 		void Optimize(ShaderDef* dst);
 		void Output();
 		void GetTextureUsage(TextureUsage* tu);
@@ -103,7 +103,7 @@
 		float specularExponent;
 
 		static void OptimizeStages(std::vector&lt;Stage&gt;&amp; src, std::vector&lt;Stage&gt;&amp; dst);
-		static void LoadStages(int numStages, const char *stagename, TdfParser&amp; tdf, std::vector&lt;Stage&gt;&amp; stages);
+		static void LoadStages(int numStages, const char *stagename, const TdfParser&amp; tdf, std::vector&lt;Stage&gt;&amp; stages);
 	};
 
 	struct NodeSetupParams
@@ -192,7 +192,7 @@
 		TerrainTexture();
 		~TerrainTexture();
 
-		void Load (TdfParser *parser, Heightmap *heightmap, TQuad *quadTree, const std::vector&lt;QuadMap*&gt;&amp; qmaps, Config *cfg, ILoadCallback *cb, LightingInfo* li);
+		void Load (const TdfParser *parser, Heightmap *heightmap, TQuad *quadTree, const std::vector&lt;QuadMap*&gt;&amp; qmaps, Config *cfg, ILoadCallback *cb, LightingInfo* li);
 
 		int NumPasses ();
 
@@ -258,7 +258,7 @@
 		int maxPasses; // the highest number of passes a RenderSetupCollection requires (some nodes might need less passes than this)
 
 		//only valid during loading
-		TdfParser *tdfParser;
+		const TdfParser *tdfParser;
 
 		Lightmap *lightmap;
 		ShaderDef shaderDef;

Modified: branches/gml/rts/Map/SM3/terrain/Textures.cpp
===================================================================
--- branches/gml/rts/Map/SM3/terrain/Textures.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/terrain/Textures.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -100,7 +100,7 @@
 	TiledTexture::~TiledTexture()
 	{}
 
-	void TiledTexture::Load(const std::string&amp; name, const std::string&amp; section, ILoadCallback *cb, TdfParser *tdf, bool isBumpmap)
+	void TiledTexture::Load(const std::string&amp; name, const std::string&amp; section, ILoadCallback *cb, const TdfParser *tdf, bool isBumpmap)
 	{
 		this-&gt;name = name;
 
@@ -146,7 +146,7 @@
 			delete generatorInfo;
 	}
 
-	void Blendmap::Load(const std::string&amp; name, const std::string&amp; section, Heightmap *heightmap, ILoadCallback *cb, TdfParser *tdf)
+	void Blendmap::Load(const std::string&amp; name, const std::string&amp; section, Heightmap *heightmap, ILoadCallback *cb, const TdfParser *tdf)
 	{
 		// Create blendmap
 		this-&gt;name = name;

Modified: branches/gml/rts/Map/SM3/terrain/Textures.h
===================================================================
--- branches/gml/rts/Map/SM3/terrain/Textures.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SM3/terrain/Textures.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -103,7 +103,7 @@
 		TiledTexture ();
 		~TiledTexture ();
 
-		void Load(const std::string&amp; name, const std::string&amp; section, ILoadCallback *cb, TdfParser *tdf, bool isBumpmap);
+		void Load(const std::string&amp; name, const std::string&amp; section, ILoadCallback *cb, const TdfParser *tdf, bool isBumpmap);
 		static TiledTexture* CreateFlatBumpmap();
 	};
 
@@ -113,7 +113,7 @@
 		~Blendmap ();
 
 		void Generate (Heightmap *rootHm, int lodLevel, float hmscale, float hmoffset);
-		void Load(const std::string&amp; name, const std::string&amp; section, Heightmap *heightmap, ILoadCallback *cb, TdfParser *tdf);
+		void Load(const std::string&amp; name, const std::string&amp; section, Heightmap *heightmap, ILoadCallback *cb, const TdfParser *tdf);
 
 		struct GeneratorInfo {
 			float coverage, noise;

Modified: branches/gml/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundDrawer.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SMF/BFGroundDrawer.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,6 +4,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Game/Camera.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;LogOutput.h&quot;
@@ -14,8 +15,6 @@
 #include &quot;mmgr.h&quot;
 
 #include &quot;lib/gml/gmlsrv.h&quot;
-#define GML_ENABLE_DRAWGROUND 1
-#define GML_ENABLE_DRAWGROUNDSHADOW 1
 extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 
 using std::min;
@@ -136,7 +135,7 @@
 inline void CBFGroundDrawer::DrawWaterPlane(bool drawWaterReflection) {
 	if (!drawWaterReflection) {
 		glDisable(GL_TEXTURE_2D);
-		glColor3f(map-&gt;waterPlaneColor.x, map-&gt;waterPlaneColor.y, map-&gt;waterPlaneColor.z);
+		glColor3f(mapInfo-&gt;water.planeColor.x, mapInfo-&gt;water.planeColor.y, mapInfo-&gt;water.planeColor.z);
 		glBegin(GL_QUADS);
 
 		static const float xsize = (gs-&gt;mapx * SQUARE_SIZE) &gt;&gt; 2;
@@ -684,7 +683,7 @@
 	SetupTextureUnits(drawWaterReflection, overrideVP);
 	bool inStrip = false;
 
-	if (map-&gt;voidWater &amp;&amp; !waterDrawn) {
+	if (mapInfo-&gt;map.voidWater &amp;&amp; !waterDrawn) {
 		glEnable(GL_ALPHA_TEST);
 		glAlphaFunc(GL_GREATER, 0.9f);
 	}
@@ -1144,11 +1143,11 @@
 		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
 	}
 
-	if (map-&gt;voidWater &amp;&amp; !waterDrawn) {
+	if (mapInfo-&gt;map.voidWater &amp;&amp; !waterDrawn) {
 		glDisable(GL_ALPHA_TEST);
 	}
 
-	if (map-&gt;hasWaterPlane) {
+	if (mapInfo-&gt;hasWaterPlane) {
 		DrawWaterPlane(drawWaterReflection);
 	}
 
@@ -1813,9 +1812,9 @@
 	else if (shadowHandler-&gt;drawShadows) {
 		glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, groundFPShadow);
 		glEnable(GL_FRAGMENT_PROGRAM_ARB);
-		float3 ac = map-&gt;ambientColor * (210.0f / 255.0f);
+		float3 ac = mapInfo-&gt;light.groundAmbientColor * (210.0f / 255.0f);
 		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 10, ac.x, ac.y, ac.z, 1);
-		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 11, 0, 0, 0, map-&gt;shadowDensity);
+		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 11, 0, 0, 0, mapInfo-&gt;light.groundShadowDensity);
 
 		glActiveTextureARB(GL_TEXTURE0_ARB);
 		glActiveTextureARB(GL_TEXTURE1_ARB);

Modified: branches/gml/rts/Map/SMF/BFGroundTextures.cpp
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundTextures.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SMF/BFGroundTextures.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,11 +9,19 @@
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;SmfReadMap.h&quot;
 #include &quot;mmgr.h&quot;
+#include &quot;FastMath.h&quot;
 
 using namespace std;
 
 CBFGroundTextures::CBFGroundTextures(CSmfReadMap* rm)
 {
+	usePBO = false;
+	if (GLEW_EXT_pixel_buffer_object &amp;&amp; rm-&gt;usePBO) {
+		glGenBuffers(30, pboIDs);
+		currentPBO=0;
+		usePBO = true;
+	}
+
 	CFileHandler* ifs = rm-&gt;ifs;
 	map = rm;
 
@@ -98,7 +106,6 @@
 			GroundSquare* square = &amp;squares[y * numBigTexX + x];
 			square-&gt;texLevel = 1;
 			square-&gt;lastUsed = -100;
-
 			LoadSquare(x, y, 2);
 		}
 	}
@@ -111,6 +118,9 @@
 	delete[] squares;
 	delete[] tileMap;
 	delete[] tiles;
+	if (usePBO) {
+		glDeleteBuffers(30,pboIDs);
+	}
 }
 
 
@@ -126,7 +136,7 @@
 	static const int heightDataX = gs-&gt;mapx + 1;
 	static const int bigTexW = (gs-&gt;mapx &lt;&lt; 3) / numBigTexX;
 	static const int bigTexH = (gs-&gt;mapy &lt;&lt; 3) / numBigTexY;
-	static const float bigTexSquareRadius = sqrt(float(bigTexW * bigTexW + bigTexH * bigTexH));
+	static const float bigTexSquareRadius = fastmath::sqrt(float(bigTexW * bigTexW + bigTexH * bigTexH));
 
 	const int x = btx * bigTexW + (bigTexW &gt;&gt; 1);
 	const int y = bty * bigTexH + (bigTexH &gt;&gt; 1);
@@ -160,7 +170,7 @@
 
 			float dx = cam2-&gt;pos.x - x * bigSquareSize * SQUARE_SIZE - 64 * SQUARE_SIZE;
 			dx = max(0.0f, float(fabs(dx) - 64.0f * SQUARE_SIZE));
-			float dist = sqrt(dx * dx + dy * dy);
+			float dist = fastmath::sqrt(dx * dx + dy * dy);
 
 			if (square-&gt;lastUsed &lt; gs-&gt;frameNum - 60)
 				dist = 8000;
@@ -204,11 +214,29 @@
 
 void CBFGroundTextures::LoadSquare(int x, int y, int level)
 {
+	int size = 1024 &gt;&gt; level;
+
+	GLubyte* buf=NULL; bool usedPBO=false;
+
+	if (usePBO) {
+		if (currentPBO &gt; 29) currentPBO=0;
+		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboIDs[currentPBO++]);
+
+		glBufferData(GL_PIXEL_UNPACK_BUFFER, size * size / 2, 0, GL_STREAM_DRAW);
+
+		//map the buffer object into client's memory
+		buf = (GLubyte*)glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
+		usedPBO = true;
+	}
+
+	if(buf==NULL) {
+		buf = SAFE_NEW GLubyte[size * size / 2];
+		usedPBO = false;
+	}
+
 	GroundSquare* square = &amp;squares[y * numBigTexX + x];
 	square-&gt;texLevel = level;
 
-	int size = 1024 &gt;&gt; level;
-	char* buf = SAFE_NEW char[size * size / 2];
 	int numblocks = 8 / (1 &lt;&lt; level);
 
 	for (int y1 = 0; y1 &lt; 32; y1++) {
@@ -217,10 +245,11 @@
 
 			for (int yt = 0; yt &lt; numblocks; yt++) {
 				for (int xt = 0; xt &lt; numblocks; xt++) {
-					char* sbuf = &amp;tile[(xt + yt * numblocks) * 8];
-					char* dbuf = &amp;buf[(x1 * numblocks+xt + (y1 * numblocks + yt) * (numblocks * 32)) * 8];
+					GLfloat* sbuf = (GLfloat*)&amp;tile[(xt + yt * numblocks) * 8];
+					GLfloat* dbuf = (GLfloat*)&amp;buf[(x1 * numblocks + xt + (y1 * numblocks + yt) * (numblocks * 32)) * 8];
 
-					for (int i = 0; i &lt; 8; i++) {
+					//copy 4 bytes at once
+					for (int i = 0; i &lt; 2; i++) {
 						dbuf[i] = sbuf[i];
 					}
 				}
@@ -234,12 +263,16 @@
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	if (map-&gt;anisotropy != 0.0f)
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, map-&gt;anisotropy);
 
-	if (map-&gt;anisotropy != 0.0f) {
-		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, map-&gt;anisotropy);
+	if (usedPBO) {
+		glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
+		glCompressedTexImage2D(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, size, size, 0, size * size / 2, 0);
+		glBufferData(GL_PIXEL_UNPACK_BUFFER, 0, 0, GL_STREAM_DRAW); //free it
+		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+	}else{
+		glCompressedTexImage2D(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, size, size, 0, size * size / 2, buf);
+		delete[] buf;
 	}
-
-	glCompressedTexImage2DARB(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, size, size, 0, size * size / 2, buf);
-
-	delete[] buf;
 }

Modified: branches/gml/rts/Map/SMF/BFGroundTextures.h
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundTextures.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SMF/BFGroundTextures.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -51,6 +51,11 @@
 	int tileMapXSize;
 	int tileMapYSize;
 
+	// use Pixel Buffer Objects for async. uploading (DMA)?
+	bool usePBO;
+	GLuint pboIDs[30];
+	int currentPBO;
+
 	float anisotropy;
 
 	inline bool TexSquareInView(int, int);

Modified: branches/gml/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- branches/gml/rts/Map/SMF/SmfReadMap.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SMF/SmfReadMap.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,6 +1,7 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;SmfReadMap.h&quot;
 #include &quot;mapfile.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
@@ -36,21 +37,11 @@
 	PrintLoadMsg(&quot;Opening map file&quot;);
 
 	ConfigureAnisotropy();
+	usePBO = !!configHandler.GetInt(&quot;UsePBO&quot;, 1);
 
-	string smdfile = string(&quot;maps/&quot;)+mapname.substr(0,mapname.find_last_of('.'))+&quot;.smd&quot;;
-	mapDefParser.LoadFile(smdfile);
-	TdfParser resources(&quot;gamedata/resources.tdf&quot;);
-	ParseSettings(resources);
-
-	mapDefParser.GetDef(detailTexName, &quot;&quot;, &quot;MAP\\DetailTex&quot;);
-	if(detailTexName.empty())
-		detailTexName = &quot;bitmaps/&quot;+resources.SGetValueDef(&quot;detailtex2.bmp&quot;,&quot;resources\\graphics\\maps\\detailtex&quot;);
-	else
-		detailTexName = &quot;maps/&quot; + detailTexName;
-
 	for(int a=0;a&lt;1024;++a){
 		for(int b=0;b&lt;3;++b){
-			float c=max(waterMinColor[b],waterBaseColor[b]-waterAbsorb[b]*a);
+			float c=max(mapInfo-&gt;water.minColor[b],mapInfo-&gt;water.baseColor[b]-mapInfo-&gt;water.absorb[b]*a);
 			waterHeightColors[a*4+b]=(unsigned char)(c*210);
 		}
 		waterHeightColors[a*4+3]=1;
@@ -108,6 +99,8 @@
 
 	PrintLoadMsg(&quot;Loading detail textures&quot;);
 
+	detailTexName = mapInfo-&gt;smf.detailTexName;
+
 	CBitmap bm;
 	if (!bm.Load(detailTexName))
 		throw content_error(&quot;Could not load detail texture from file &quot; + detailTexName);
@@ -115,7 +108,7 @@
 	glBindTexture(GL_TEXTURE_2D, detailTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
 	if (anisotropy != 0.0f) {
 		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
 	}
@@ -234,12 +227,12 @@
 	float3 n1=facenormals[(y*gs-&gt;mapx+x)*2]+facenormals[(y*gs-&gt;mapx+x)*2+1];
 	n1.Normalize();
 
-	float3 light=sunColor*gs-&gt;sunVector.dot(n1);
+	float3 light=mapInfo-&gt;light.groundSunColor*mapInfo-&gt;light.sunDir.dot(n1);
 	for(int a=0;a&lt;3;++a)
 		if(light[a]&lt;0)
 			light[a]=0;
 
-	light+=ambientColor;
+	light+=mapInfo-&gt;light.groundAmbientColor;
 	for(int a=0;a&lt;3;++a)
 		if(light[a]&gt;1)
 			light[a]=1;
@@ -307,42 +300,6 @@
 	glActiveTextureARB(GL_TEXTURE0_ARB);
 }
 
-#if GML_EXPERIMENTAL
-#include &quot;system/timeprofiler.h&quot;
-void CSmfReadMap::GridVisMT(int yy) {
-	int y=yy+mt_sy;
-	int quadSize=mt_quadSize;
-	int extraSize=mt_extraSize;
-	CReadMap::IQuadDrawer *qd=mt_qd;
-
-	int sx=mt_sxi;
-	int ex=mt_exi;
-	float xtest,xtest2;
-	std::vector&lt;CBFGroundDrawer::fline&gt;::iterator fli;
-	for(fli=groundDrawer-&gt;left.begin();fli!=groundDrawer-&gt;left.end();fli++){
-		xtest=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*(y*quadSize)));
-		xtest2=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*((y*quadSize)+quadSize)));
-		if(xtest&gt;xtest2)
-			xtest=xtest2;
-		xtest=xtest/quadSize;
-		if(xtest-extraSize&gt;sx)
-			sx=((int)xtest)-extraSize;
-	}
-	for(fli=groundDrawer-&gt;right.begin();fli!=groundDrawer-&gt;right.end();fli++){
-		xtest=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*(y*quadSize)));
-		xtest2=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*((y*quadSize)+quadSize)));
-		if(xtest&lt;xtest2)
-			xtest=xtest2;
-		xtest=xtest/quadSize;
-		if(xtest+extraSize&lt;ex)
-			ex=((int)xtest)+extraSize;
-	}
-
-	for(int x=sx;x&lt;=ex;x++)
-		qd-&gt;DrawQuad (x,y);
-}
-#endif
-
 void CSmfReadMap::GridVisibility (CCamera *cam, int quadSize, float maxdist, CReadMap::IQuadDrawer *qd, int extraSize)
 {
 	int cx=(int)(cam-&gt;pos.x/(SQUARE_SIZE*quadSize));
@@ -366,22 +323,6 @@
 	if(exi&gt;drawQuadsX-1)
 		exi=drawQuadsX-1;
  
-#if GML_EXPERIMENTAL // it appears this does not improve performance
-	int domt=GetTickCount()&amp;(1&lt;&lt;14);
-	SCOPED_TIMER(domt?&quot;TestMT&quot;:&quot;Test&quot;);
-
-	if(GML_EXP_MODE() &amp;&amp; domt) { // requires 1+ey-sy&lt;32
-		mt_quadSize=quadSize;
-		mt_extraSize=extraSize;
-		mt_qd=qd;
-		mt_sy=sy;
-		mt_exi=exi;
-		mt_sxi=sxi;
-		gmlProcessor.Work(NULL,&amp;CSmfReadMap::GridVisMTcb,NULL,this,gmlThreadCount,FALSE,NULL,1+ey-sy,50,100,TRUE,NULL);
-		return;
-	}
-#endif
-
 	for(int y=sy;y&lt;=ey;y++){
 		int sx=sxi;
 		int ex=exi;

Modified: branches/gml/rts/Map/SMF/SmfReadMap.h
===================================================================
--- branches/gml/rts/Map/SMF/SmfReadMap.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Map/SMF/SmfReadMap.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -22,17 +22,6 @@
 	void GridVisibility(CCamera *cam, int quadSize, float maxdist, IQuadDrawer *cb, int extraSize);
 	CBaseGroundDrawer* GetGroundDrawer();
 	float* GetHeightmap() { return heightmap; }
-
-#if GML_EXPERIMENTAL
-	volatile int mt_sy;
-	volatile int mt_quadSize;
-	volatile int mt_extraSize;
-	CReadMap::IQuadDrawer * volatile mt_qd;
-	volatile int mt_sxi;
-	volatile int mt_exi;
-	void GridVisMT(int yy);
-	static void GridVisMTcb(void *c, int yy) {((CSmfReadMap *)c)-&gt;GridVisMT(yy);}
-#endif
 	
 	int GetNumFeatureTypes ();
 	int GetNumFeatures ();
@@ -47,6 +36,7 @@
 	MapHeader header;
 	CFileHandler *ifs;
 
+	bool usePBO;
 	float anisotropy;
 
 	unsigned char waterHeightColors[1024*4];

Modified: branches/gml/rts/Rendering/Env/AdvSky.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/AdvSky.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/AdvSky.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,6 +7,7 @@
 
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Game/Camera.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
@@ -15,9 +16,6 @@
 #include &quot;Matrix44f.h&quot;
 #include &quot;mmgr.h&quot;
 
-extern GLfloat FogBlack[];
-extern GLfloat FogLand[];
-
 #define Y_PART 10.0
 #define X_PART 10.0
 
@@ -35,16 +33,16 @@
 	domeheight=cos(PI/16)*1.01f;
 	domeWidth=sin(2*PI/32)*400*1.7f;
 
-	sundir2=gs-&gt;sunVector;
+	sundir2=mapInfo-&gt;light.sunDir;
 	sundir2.y=0;
 	if(sundir2.Length()==0)
 		sundir2.x=1;
 	sundir2.Normalize();
 	sundir1=sundir2.cross(UpVector);
 
-	modSunDir.y=gs-&gt;sunVector.y;
+	modSunDir.y=mapInfo-&gt;light.sunDir.y;
 	modSunDir.x=0;
-	modSunDir.z=sqrt(gs-&gt;sunVector.x*gs-&gt;sunVector.x+gs-&gt;sunVector.z*gs-&gt;sunVector.z);
+	modSunDir.z=sqrt(mapInfo-&gt;light.sunDir.x*mapInfo-&gt;light.sunDir.x+mapInfo-&gt;light.sunDir.z*mapInfo-&gt;light.sunDir.z);
 
 	sunTexCoordX=0.5f;
 	sunTexCoordY=GetTexCoordFromDir(modSunDir);
@@ -57,12 +55,13 @@
 //	dynamicSky=!!regHandler.GetInt(&quot;DynamicSky&quot;,0);
 	dynamicSky=false;
 	lastCloudUpdate=-30;
-	readmap-&gt;mapDefParser.GetDef(cloudDensity,&quot;0.5&quot;,&quot;MAP\\ATMOSPHERE\\CloudDensity&quot;);
-	readmap-&gt;mapDefParser.GetDef(fogStart,&quot;0.1&quot;,&quot;MAP\\ATMOSPHERE\\FogStart&quot;);
+
+	cloudDensity = mapInfo-&gt;atmosphere.cloudDensity;
+	cloudColor = mapInfo-&gt;atmosphere.cloudColor;
+	skyColor = mapInfo-&gt;atmosphere.skyColor;
+	sunColor = mapInfo-&gt;atmosphere.sunColor;
+	fogStart = mapInfo-&gt;atmosphere.fogStart;
 	if (fogStart&gt;0.99f) gu-&gt;drawFog = false;
-	skyColor=readmap-&gt;mapDefParser.GetFloat3(float3(0.1f,0.15f,0.7f),&quot;MAP\\ATMOSPHERE\\SkyColor&quot;);
-	sunColor=readmap-&gt;mapDefParser.GetFloat3(float3(1,1,1),&quot;MAP\\ATMOSPHERE\\SunColor&quot;);
-	cloudColor=readmap-&gt;mapDefParser.GetFloat3(float3(1,1,1),&quot;MAP\\ATMOSPHERE\\CloudColor&quot;);
 
 	CreateClouds();
 	InitSun();
@@ -189,7 +188,7 @@
 
 	if (gu-&gt;drawFog) {
 		glEnable(GL_FOG);
-		glFogfv(GL_FOG_COLOR,FogLand);
+		glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
 		glFogf(GL_FOG_START,gu-&gt;viewRange*fogStart);
 		glFogf(GL_FOG_END,gu-&gt;viewRange);
 		glFogf(GL_FOG_DENSITY,1.0f);
@@ -244,7 +243,7 @@
 	glBindTexture(GL_TEXTURE_2D, cdtex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR/*_MIPMAP_NEAREST*/);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_LUMINANCE ,256, 256, GL_LUMINANCE, GL_UNSIGNED_BYTE, mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_LUMINANCE ,256, 256, GL_LUMINANCE, GL_UNSIGNED_BYTE, mem);
 
 	unsigned char randDetailMatrix[32*32];
 	glGenTextures(12, detailTextures);
@@ -288,7 +287,7 @@
 	glBindTexture(GL_TEXTURE_2D, skyTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, skytex[0][0]);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, skytex[0][0]);
 	delete[] skytex;
 
 	unsigned char skytex2[256][256][4];
@@ -309,7 +308,7 @@
 	glBindTexture(GL_TEXTURE_2D, skyDot3Tex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 256, GL_RGBA, GL_UNSIGNED_BYTE, skytex2[0][0]);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 256, GL_RGBA, GL_UNSIGNED_BYTE, skytex2[0][0]);
 
 	for(int a=0;a&lt;CLOUD_DETAIL;a++){
 		CreateRandMatrix(randMatrix[a],1-a*0.03f);
@@ -658,7 +657,7 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,128, 128, GL_RGBA, GL_UNSIGNED_BYTE, mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,128, 128, GL_RGBA, GL_UNSIGNED_BYTE, mem);
 
 	for(int y=0;y&lt;4;++y){
 		for(int x=0;x&lt;32;++x){

Modified: branches/gml/rts/Rendering/Env/AdvTreeDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,6 +6,7 @@
 #include &quot;AdvTreeDrawer.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Map/ReadMap.h&quot;
@@ -157,7 +158,7 @@
 				SetArray(TEX_LEAF_END_X1+xdif  ,TEX_LEAF_END_Y4+ydif  ,base-side*width+float3(0,height,0));
 				SetArray(TEX_LEAF_END_X1+xdif  ,TEX_LEAF_START_Y4+ydif,base-side*width);
 			}
-			glNewList(td-&gt;trees[y*treesX+x].farDisplist,GL_COMPILE);
+			glNewList(tss-&gt;farDisplist,GL_COMPILE);
 			va-&gt;DrawArrayT(GL_QUADS);
 			glEndList();
 		}
@@ -250,16 +251,16 @@
 		if(shadowHandler-&gt;useFPShadows){
 			glBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, treeGen-&gt;treeFPShadow );
 			glEnable( GL_FRAGMENT_PROGRAM_ARB );
-			glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,10, readmap-&gt;ambientColor.x,readmap-&gt;ambientColor.y,readmap-&gt;ambientColor.z,1);
-			glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,11, 0,0,0,1-readmap-&gt;shadowDensity*0.5f);
+			glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,10, mapInfo-&gt;light.groundAmbientColor.x,mapInfo-&gt;light.groundAmbientColor.y,mapInfo-&gt;light.groundAmbientColor.z,1);
+			glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,11, 0,0,0,1-mapInfo-&gt;light.groundShadowDensity*0.5f);
 
 			glActiveTextureARB(GL_TEXTURE1_ARB);
 			glBindTexture(GL_TEXTURE_2D, activeFarTex);
 		} else {
 			glEnable(GL_TEXTURE_2D);
-			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1-readmap-&gt;shadowDensity*0.5f);
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1-mapInfo-&gt;light.groundShadowDensity*0.5f);
 
-			float texConstant[]={readmap-&gt;ambientColor.x,readmap-&gt;ambientColor.y,readmap-&gt;ambientColor.z,0.0f};
+			float texConstant[]={mapInfo-&gt;light.groundAmbientColor.x,mapInfo-&gt;light.groundAmbientColor.y,mapInfo-&gt;light.groundAmbientColor.z,0.0f};
 			glTexEnvfv(GL_TEXTURE_ENV,GL_TEXTURE_ENV_COLOR,texConstant);
 			glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_PREVIOUS_ARB);
 			glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_CONSTANT);
@@ -318,8 +319,8 @@
 		glEnable( GL_VERTEX_PROGRAM_ARB );
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,13,  camera-&gt;right.x,camera-&gt;right.y,camera-&gt;right.z,0);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,9,  camera-&gt;up.x,camera-&gt;up.y,camera-&gt;up.z,0);
-		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,11, readmap-&gt;sunColor.x,readmap-&gt;sunColor.y,readmap-&gt;sunColor.z,0.85f);
-		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,14, readmap-&gt;ambientColor.x,readmap-&gt;ambientColor.y,readmap-&gt;ambientColor.z,0.85f);
+		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,11, mapInfo-&gt;light.groundSunColor.x,mapInfo-&gt;light.groundSunColor.y,mapInfo-&gt;light.groundSunColor.z,0.85f);
+		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,14, mapInfo-&gt;light.groundAmbientColor.x,mapInfo-&gt;light.groundAmbientColor.y,mapInfo-&gt;light.groundAmbientColor.z,0.85f);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,12, 0,0,0,0.20f*(1.0f/MAX_TREE_HEIGHT));	//w=alpha/height modifier
 		glAlphaFunc(GL_GREATER,0.5f);
 		glDisable(GL_BLEND);
@@ -336,8 +337,8 @@
 		static FadeTree fadeTrees[3000];
 		int curFade=0;
 
-		for(int y=max(0,cy-2);y&lt;=min(gs-&gt;mapy/TREE_SQUARE_SIZE-1,cy+2);++y){	//close trees
-			for(int x=max(0,cx-2);x&lt;=min(gs-&gt;mapx/TREE_SQUARE_SIZE-1,cx+2);++x){
+		for(int y=std::max(0,cy-2);y&lt;=std::min(gs-&gt;mapy/TREE_SQUARE_SIZE-1,cy+2);++y){	//close trees
+			for(int x=std::max(0,cx-2);x&lt;=std::min(gs-&gt;mapx/TREE_SQUARE_SIZE-1,cx+2);++x){
 				TreeSquareStruct* tss=&amp;trees[y*treesX+x];
 				tss-&gt;lastSeen=gs-&gt;frameNum;
 				for(std::map&lt;int,TreeStruct&gt;::iterator ti=tss-&gt;trees.begin();ti!=tss-&gt;trees.end();++ti){
@@ -534,7 +535,8 @@
 
 void CAdvTreeSquareDrawer_SP::DrawQuad (int x,int y)
 {
-	CAdvTreeDrawer::TreeSquareStruct* tss=&amp;td-&gt;trees[y*td-&gt;treesX+x];
+	int treesX = td-&gt;treesX;
+	CAdvTreeDrawer::TreeSquareStruct* tss=&amp;td-&gt;trees[y*treesX+x];
 	if(abs(cy-y)&lt;=2 &amp;&amp; abs(cx-x)&lt;=2 &amp;&amp; drawDetailed)	//skip the closest squares
 		return;
 
@@ -579,7 +581,7 @@
 				SetArray(TEX_LEAF_END_X1+xdif  ,TEX_LEAF_END_Y4+ydif  ,base-side*width+float3(0,height,0));
 				SetArray(TEX_LEAF_END_X1+xdif  ,TEX_LEAF_START_Y4+ydif,base-side*width);
 			}
-			glNewList(td-&gt;trees[y*td-&gt;treesX+x].farDisplist,GL_COMPILE);
+			glNewList(td-&gt;trees[y*treesX+x].farDisplist,GL_COMPILE);
 			va-&gt;DrawArrayT(GL_QUADS);
 			glEndList();
 		}
@@ -873,7 +875,7 @@
 	if(s&gt;500)
 		return 0;
 	ft.dir=dir/s;
-	ft.speed=max(0.01f,s*0.0004f);
+	ft.speed=std::max(0.01f,s*0.0004f);
 	ft.type=type;
 	ft.fallPos=0;
 

Modified: branches/gml/rts/Rendering/Env/AdvTreeGenerator.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/AdvTreeGenerator.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/AdvTreeGenerator.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -8,8 +8,10 @@
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
+#include &quot;TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 
 using namespace std;
@@ -56,7 +58,7 @@
 	glBindTexture(GL_TEXTURE_2D, leafTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
 
 	CreateLeafTex(leafTex,256,0,tree);
 	CreateLeafTex(leafTex,512,0,tree);
@@ -160,7 +162,7 @@
 
 void CAdvTreeGenerator::DrawTrunk(const float3 &amp;start, const float3 &amp;end,const float3&amp; orto1,const float3&amp; orto2, float size)
 {
-	float3 flatSun=gs-&gt;sunVector;
+	float3 flatSun=mapInfo-&gt;light.sunDir;
 	flatSun.y=0;
 
 	int numIter=(int)max(3.0f,size*10);
@@ -237,7 +239,7 @@
 	float baseRot=fRand(2*PI);
 	int numLeaves=(int)length*10/MAX_TREE_HEIGHT;
 
-	float3 flatSun=gs-&gt;sunVector;
+	float3 flatSun=mapInfo-&gt;light.sunDir;
 	flatSun.y=0;
 
 	for(int a=0;a&lt;numLeaves+1;a++){
@@ -299,8 +301,8 @@
 	glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,13, 1,0,0,0);	//camera side
 	glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,9, 0,1,0,0);	//camera up
 	glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,10,0,0,0,0);	//position delta
-	glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,11, readmap-&gt;sunColor.x,readmap-&gt;sunColor.y,readmap-&gt;sunColor.z,0.85f);
-	glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,14, readmap-&gt;ambientColor.x,readmap-&gt;ambientColor.y,readmap-&gt;ambientColor.z,0.85f);
+	glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,11, mapInfo-&gt;light.groundSunColor.x,mapInfo-&gt;light.groundSunColor.y,mapInfo-&gt;light.groundSunColor.z,0.85f);
+	glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,14, mapInfo-&gt;light.groundAmbientColor.x,mapInfo-&gt;light.groundAmbientColor.y,mapInfo-&gt;light.groundAmbientColor.z,0.85f);
 	glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,12,0,0,0,0.02f);	//w=alpha/height modifier
 	glAlphaFunc(GL_GREATER,0.5f);
 	glDisable(GL_FOG);
@@ -681,7 +683,7 @@
 {
 	float3 orto1(1,0,0);
 	float3 orto2(0,0,1);
-	float3 flatSun=gs-&gt;sunVector;
+	float3 flatSun=mapInfo-&gt;light.sunDir;
 	flatSun.y=0;
 
 	int numIter=8;
@@ -703,7 +705,7 @@
 
 void CAdvTreeGenerator::DrawPineBranch(const float3 &amp;start, const float3 &amp;dir, float size)
 {
-	float3 flatSun=gs-&gt;sunVector;
+	float3 flatSun=mapInfo-&gt;light.sunDir;
 	flatSun.y=0;
 
 	float3 orto1=dir.cross(UpVector);

Modified: branches/gml/rts/Rendering/Env/AdvWater.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/AdvWater.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/AdvWater.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -16,15 +16,13 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Lua/LuaCallInHandler.h&quot;
-
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;mmgr.h&quot;
 
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-extern GLfloat FogLand[]; 
-
 CAdvWater::CAdvWater(bool loadShader)
 {
 	glGenTextures(1, &amp;reflectTexture);
@@ -103,7 +101,7 @@
 	if (loadShader)
 		waterFP=LoadFragmentProgram(&quot;water.fp&quot;);
 
-	waterSurfaceColor = readmap-&gt;waterSurfaceColor;
+	waterSurfaceColor = mapInfo-&gt;water.surfaceColor;
 }
 
 CAdvWater::~CAdvWater()
@@ -228,7 +226,7 @@
 
 void CAdvWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;minheight &gt; 10 || readmap-&gt;voidWater)
+	if (readmap-&gt;minheight &gt; 10 || mapInfo-&gt;map.voidWater)
 		return;
 
 	glViewport(0,0,128,128);
@@ -358,7 +356,7 @@
 	glCopyTexSubImage2D(GL_TEXTURE_2D,0,0,0,0,0,512,512);
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
-	glClearColor(FogLand[0],FogLand[1],FogLand[2],1);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 
 	delete camera;
 	camera = realCam;

Modified: branches/gml/rts/Rendering/Env/BaseSky.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/BaseSky.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/BaseSky.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,6 +5,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;SkyBox.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -12,6 +13,7 @@
 
 CBaseSky::CBaseSky(void)
 {
+	wireframe = false;
 }
 
 CBaseSky::~CBaseSky(void)
@@ -20,9 +22,8 @@
 
 CBaseSky* CBaseSky::GetSky()
 {
-
-	if(!readmap-&gt;skyBox.empty())
-		return SAFE_NEW CSkyBox(&quot;maps/&quot; + readmap-&gt;skyBox);
+	if(!mapInfo-&gt;atmosphere.skyBox.empty())
+		return SAFE_NEW CSkyBox(&quot;maps/&quot; + mapInfo-&gt;atmosphere.skyBox);
 	else if(GLEW_ARB_fragment_program &amp;&amp; configHandler.GetInt(&quot;AdvSky&quot;,1) &amp;&amp; ProgramStringIsNative(GL_FRAGMENT_PROGRAM_ARB,&quot;clouds.fp&quot;))
 		return SAFE_NEW CAdvSky();
 	else

Modified: branches/gml/rts/Rendering/Env/BaseSky.h
===================================================================
--- branches/gml/rts/Rendering/Env/BaseSky.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/BaseSky.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -21,6 +21,8 @@
 	bool dynamicSky;
 	float cloudDensity;
 
+	bool wireframe;
+
 	float fogStart;
 	float3 skyColor;
 	float3 sunColor;

Modified: branches/gml/rts/Rendering/Env/BaseWater.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/BaseWater.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/BaseWater.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -2,6 +2,7 @@
 #include &quot;BaseWater.h&quot;
 #include &quot;BasicWater.h&quot;
 #include &quot;AdvWater.h&quot;
+#include &quot;BumpWater.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;LogOutput.h&quot;
@@ -42,6 +43,20 @@
 			return water;
 		}
 	}
+
+	if(configValue==4 &amp;&amp; GLEW_ARB_shading_language_100) {
+		try {
+			water = SAFE_NEW CBumpWater;
+		} catch (content_error&amp; e) {
+			delete water;
+			water = NULL;
+			logOutput.Print(&quot;Loading Bumpmapped Water failed&quot;);
+			logOutput.Print(&quot;Error: %s&quot;, e.what());
+		}
+		if (water) {
+			return water;
+		}
+	}
 	
 	if(configValue==3 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_rectangle){
 		try {

Modified: branches/gml/rts/Rendering/Env/BasicSky.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/BasicSky.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/BasicSky.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -10,6 +10,7 @@
 
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Game/Camera.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;TimeProfiler.h&quot;
@@ -23,8 +24,6 @@
 #include &lt;assert.h&gt;
 
 //////////////////////////////////////////////////////////////////////
-extern GLfloat FogBlack[];
-extern GLfloat FogLand[];
 
 #define Y_PART 10.0
 #define X_PART 10.0
@@ -40,27 +39,26 @@
 	domeheight=cos(PI/16)*1.01f;
 	domeWidth=sin(2*PI/32)*400*1.7f;
 
-	sundir2=gs-&gt;sunVector;
+	sundir2=mapInfo-&gt;light.sunDir;
 	sundir2.y=0;
 	if(sundir2.Length()==0)
 		sundir2.x=1;
 	sundir2.Normalize();
 	sundir1=sundir2.cross(UpVector);
 
-	modSunDir.y=gs-&gt;sunVector.y;
+	modSunDir.y=mapInfo-&gt;light.sunDir.y;
 	modSunDir.x=0;
-	modSunDir.z=sqrt(gs-&gt;sunVector.x*gs-&gt;sunVector.x+gs-&gt;sunVector.z*gs-&gt;sunVector.z);
+	modSunDir.z=sqrt(mapInfo-&gt;light.sunDir.x*mapInfo-&gt;light.sunDir.x+mapInfo-&gt;light.sunDir.z*mapInfo-&gt;light.sunDir.z);
 
 	sunTexCoordX=0.5f;
 	sunTexCoordY=GetTexCoordFromDir(modSunDir);
 
-	readmap-&gt;mapDefParser.GetDef(cloudDensity,&quot;0.5&quot;,&quot;MAP\\ATMOSPHERE\\CloudDensity&quot;);
-	cloudDensity=0.25f+cloudDensity*0.5f;
-	readmap-&gt;mapDefParser.GetDef(fogStart,&quot;0.1&quot;,&quot;MAP\\ATMOSPHERE\\FogStart&quot;);
+	cloudDensity = 0.25f + mapInfo-&gt;atmosphere.cloudDensity * 0.5f;
+	cloudColor = mapInfo-&gt;atmosphere.cloudColor;
+	skyColor = mapInfo-&gt;atmosphere.skyColor;
+	sunColor = mapInfo-&gt;atmosphere.sunColor;
+	fogStart = mapInfo-&gt;atmosphere.fogStart;
 	if (fogStart&gt;0.99f) gu-&gt;drawFog = false;
-	skyColor=readmap-&gt;mapDefParser.GetFloat3(float3(0.1f,0.15f,0.7f),&quot;MAP\\ATMOSPHERE\\SkyColor&quot;);
-	sunColor=readmap-&gt;mapDefParser.GetFloat3(float3(1,1,1),&quot;MAP\\ATMOSPHERE\\SunColor&quot;);
-	cloudColor=readmap-&gt;mapDefParser.GetFloat3(float3(1,1,1),&quot;MAP\\ATMOSPHERE\\CloudColor&quot;);
 
 	for(int a=0;a&lt;CLOUD_DETAIL;a++)
 		cloudDown[a]=false;
@@ -75,6 +73,7 @@
 	glGetError();
 	displist=glGenLists(1);
 	glNewList(displist, GL_COMPILE);
+
 	glDisable(GL_TEXTURE_2D);
 	glDisable(GL_LIGHTING);
 	glDisable(GL_ALPHA_TEST);
@@ -245,6 +244,8 @@
 	glDisable(GL_DEPTH_TEST);
 	glEnable(GL_BLEND);
 
+	if (wireframe) glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+
 	glPushMatrix();
 //	glTranslatef(camera-&gt;pos.x,camera-&gt;pos.y,camera-&gt;pos.z);
 	CMatrix44f m(camera-&gt;pos,sundir1,UpVector,sundir2);
@@ -257,8 +258,6 @@
 		glTranslatef((gs-&gt;frameNum%20000)*0.00005f+modCamera.x*0.000025f,modCamera.z*0.000025f,0);
 	glMatrixMode(GL_MODELVIEW);
 
-
-
 	glCallList(displist);
 
 	glMatrixMode(GL_TEXTURE);						// Select The Projection Matrix
@@ -267,11 +266,13 @@
 
 	glPopMatrix();
 
+	if (wireframe) glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+
 	glEnable(GL_DEPTH_TEST);
 	glDisable(GL_BLEND);
 	if (gu-&gt;drawFog) {
 		glEnable(GL_FOG);
-		glFogfv(GL_FOG_COLOR,FogLand);
+		glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
 		glFogi(GL_FOG_MODE,GL_LINEAR);
 		glFogf(GL_FOG_START,gu-&gt;viewRange*fogStart);
 		glFogf(GL_FOG_END,gu-&gt;viewRange);
@@ -338,7 +339,7 @@
 	glBindTexture(GL_TEXTURE_2D, skyTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, skytex[0][0]);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, skytex[0][0]);
 //	delete[] skytex;
 
 	for(y=0;y&lt;256;y++){
@@ -359,7 +360,7 @@
 	glBindTexture(GL_TEXTURE_2D, skyDot3Tex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 256, GL_RGBA, GL_UNSIGNED_BYTE, skytex2[0][0]);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 256, GL_RGBA, GL_UNSIGNED_BYTE, skytex2[0][0]);
 
 	for(int a=0;a&lt;CLOUD_DETAIL;a++){
 		CreateRandMatrix(randMatrix[a],1-a*0.03f);
@@ -685,7 +686,7 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,128, 128, GL_RGBA, GL_UNSIGNED_BYTE, mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,128, 128, GL_RGBA, GL_UNSIGNED_BYTE, mem);
 
 	for(int y=0;y&lt;2;++y){
 		for(int x=0;x&lt;32;++x){

Modified: branches/gml/rts/Rendering/Env/BasicTreeDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -10,6 +10,7 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 
 //////////////////////////////////////////////////////////////////////
@@ -245,7 +246,7 @@
 		glCallList(tss-&gt;farDisplist);
 	}
 
-	if(dist&lt;SQUARE_SIZE*TREE_SQUARE_SIZE*treeDistance){	//midle distance trees
+	if(dist&lt;SQUARE_SIZE*TREE_SQUARE_SIZE*treeDistance){	//middle distance trees
 		tss-&gt;lastSeen=gs-&gt;frameNum;
 		if(!tss-&gt;displist){
 			va=GetVertexArray();
@@ -375,52 +376,7 @@
 	glBindTexture(GL_TEXTURE_2D, texnum);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	int mipnum=0;
-	glTexImage2D(GL_TEXTURE_2D,mipnum,GL_RGBA8 ,xsize, ysize,0, GL_RGBA, GL_UNSIGNED_BYTE, data);
-	while(xsize!=1 || ysize!=1){
-		mipnum++;
-		if(xsize!=1)
-			xsize/=2;
-		if(ysize!=1)
-			ysize/=2;
-		for(int y=0;y&lt;ysize;++y){
-			for(int x=0;x&lt;xsize;++x){
-/*				for(int a=0;a&lt;3;a++){
-					int temp=0;
-					int num=0;
-					if(data[(y*2*xsize*2+x*2)*4+3]){
-						temp+=data[(y*2*xsize*2+x*2)*4+a];
-						num++;
-					}
-					if(data[((y*2+1)*xsize*2+x*2)*4+3]){
-						temp+=data[((y*2+1)*xsize*2+x*2)*4+a];
-						num++;
-					}
-					if(data[((y*2)*xsize*2+x*2+1)*4+3]){
-						temp+=data[((y*2)*xsize*2+x*2+1)*4+a];
-						num++;
-					}
-					if(data[((y*2+1)*xsize*2+x*2+1)*4+3]){
-						temp+=data[((y*2+1)*xsize*2+x*2+1)*4+a];
-						num++;
-					}
-					if(num&gt;1)
-						temp/=num;
-					data[(y*xsize+x)*4+a]=temp;
-				}
-*/			data[(y*xsize+x)*4+0]=(data[(y*2*xsize*2+x*2)*4+0]+data[((y*2+1)*xsize*2+x*2)*4+0]+data[(y*2*xsize*2+x*2+1)*4+0]+data[((y*2+1)*xsize*2+x*2+1)*4+0])/4;
-				data[(y*xsize+x)*4+1]=(data[(y*2*xsize*2+x*2)*4+1]+data[((y*2+1)*xsize*2+x*2)*4+1]+data[(y*2*xsize*2+x*2+1)*4+1]+data[((y*2+1)*xsize*2+x*2+1)*4+1])/4;
-				data[(y*xsize+x)*4+2]=(data[(y*2*xsize*2+x*2)*4+2]+data[((y*2+1)*xsize*2+x*2)*4+2]+data[(y*2*xsize*2+x*2+1)*4+2]+data[((y*2+1)*xsize*2+x*2+1)*4+2])/4;
-				data[(y*xsize+x)*4+3]=(data[(y*2*xsize*2+x*2)*4+3]+data[((y*2+1)*xsize*2+x*2)*4+3]+data[(y*2*xsize*2+x*2+1)*4+3]+data[((y*2+1)*xsize*2+x*2+1)*4+3])/4;
-				if(data[(y*xsize+x)*4+3]&gt;=127){
-					data[(y*xsize+x)*4+3]=255;
-				} else {
-					data[(y*xsize+x)*4+3]=0;
-				}
-			}
-		}
-		glTexImage2D(GL_TEXTURE_2D,mipnum,GL_RGBA8 ,xsize, ysize,0, GL_RGBA, GL_UNSIGNED_BYTE, data);
-	}
+	glBuildMipmaps(GL_TEXTURE_2D, GL_RGBA8, xsize, ysize, GL_RGBA, GL_UNSIGNED_BYTE, data);
 }
 
 void CBasicTreeDrawer::ResetPos(const float3&amp; pos)

Modified: branches/gml/rts/Rendering/Env/BasicWater.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/BasicWater.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/BasicWater.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,6 +7,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 
 #include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -18,14 +19,14 @@
 {
 	glGenTextures(1, &amp;texture);
 	CBitmap pic;
-	if (!pic.Load(readmap-&gt;waterTexture))
-		throw content_error(&quot;Could not read water texture from file &quot; + readmap-&gt;waterTexture);
+	if (!pic.Load(mapInfo-&gt;water.texture))
+		throw content_error(&quot;Could not read water texture from file &quot; + mapInfo-&gt;water.texture);
 
 	// create mipmapped texture
 	glBindTexture(GL_TEXTURE_2D, texture);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,pic.xsize, pic.ysize, GL_RGBA, GL_UNSIGNED_BYTE, pic.mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,pic.xsize, pic.ysize, GL_RGBA, GL_UNSIGNED_BYTE, pic.mem);
 
 	displist=0;
 
@@ -64,15 +65,13 @@
 		// Use better repeat setting of 1 repeat per 4096 mapx/mapy for the new
 		// ocean.jpg while retaining backward compatibility with old maps relying
 		// on 1 repeat per 1024 mapx/mapy. (changed 16/05/2007)
-		if (readmap-&gt;waterTexture == &quot;bitmaps/ocean.jpg&quot;) {
+		if (mapInfo-&gt;water.texture == &quot;bitmaps/ocean.jpg&quot;) {
 			repeatX /= 4;
 			repeatY /= 4;
 		}
 
-		readmap-&gt;mapDefParser.GetTDef(repeatX, repeatX, &quot;MAP\\WATER\\WaterRepeatX&quot;);
-		readmap-&gt;mapDefParser.GetTDef(repeatY, repeatY, &quot;MAP\\WATER\\WaterRepeatY&quot;);
-		repeatX /= 16;
-		repeatY /= 16;
+		repeatX = (mapInfo-&gt;water.repeatX != 0 ? mapInfo-&gt;water.repeatX : repeatX) / 16;
+		repeatY = (mapInfo-&gt;water.repeatY != 0 ? mapInfo-&gt;water.repeatY : repeatY) / 16;
 
 		for(int y=0;y&lt;16;y++){
 			for(int x=0;x&lt;16;x++){

Copied: branches/gml/rts/Rendering/Env/BumpWater.cpp (from rev 5882, trunk/rts/Rendering/Env/BumpWater.cpp)
===================================================================
--- branches/gml/rts/Rendering/Env/BumpWater.cpp	                        (rev 0)
+++ branches/gml/rts/Rendering/Env/BumpWater.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,470 @@
+/**
+ * @file BumpWater.cpp
+ * @brief extended bumpmapping water shader
+ * @author jK
+ *
+ * Copyright (C) 2008.  Licensed under the terms of the
+ * GNU GPL, v2 or later.
+ */
+
+#include &quot;StdAfx.h&quot;
+#include &quot;bitops.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;BumpWater.h&quot;
+#include &quot;Game/Game.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Game/Camera.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/ReadMap.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Map/BaseGroundDrawer.h&quot;
+#include &quot;BaseSky.h&quot;
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
+#include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
+#include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;System/Platform/ConfigHandler.h&quot;
+#include &lt;boost/format.hpp&gt;
+
+using std::string;
+
+//////////////////////////////////////////////////////////////////////
+// Construction/Destruction
+//////////////////////////////////////////////////////////////////////
+
+static void PrintLog(GLuint obj)
+{
+	int infologLength = 0;
+	int maxLength;
+
+	if(glIsShader(obj))
+		glGetShaderiv(obj,GL_INFO_LOG_LENGTH,&amp;maxLength);
+	else
+		glGetProgramiv(obj,GL_INFO_LOG_LENGTH,&amp;maxLength);
+
+	char* infoLog = SAFE_NEW char[maxLength];
+
+	if (glIsShader(obj))
+		glGetShaderInfoLog(obj, maxLength, &amp;infologLength, infoLog);
+	else
+		glGetProgramInfoLog(obj, maxLength, &amp;infologLength, infoLog);
+
+	if (infologLength &gt; 0) {
+		string str(infoLog, infologLength);
+		delete[] infoLog;
+		throw content_error(string(&quot;BumpWater shader error: &quot; + str));
+	}
+
+	delete[] infoLog;
+}
+
+
+void PrintFboError(GLenum error)
+{
+	switch(error) {
+		case GL_FRAMEBUFFER_COMPLETE_EXT:
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: missing a required image/buffer attachment!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: has no images/buffers attached!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: has mismatched image/buffer dimensions!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: colorbuffer attachments have different types!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: trying to draw to non-attached color buffer!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: trying to read from a non-attached color buffer!&quot;);
+			break;
+		case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: format is not supported by current graphics card/driver!&quot;);
+			break;
+		default:
+			logOutput.Print(&quot;BumpWater-FBO: *UNKNOWN ERROR*&quot;);
+			break;
+	}
+}
+
+static string LoadShaderSource(const string&amp; file)
+{
+	CFileHandler fh(file);
+	if (!fh.FileExists())
+		throw content_error(&quot;Can't load shader &quot; + file);
+
+	string text;
+	text.resize(fh.FileSize());
+	//char* cstr = SAFE_NEW char[fh.FileSize()+1];
+
+	fh.Read(&amp;text[0], text.length());
+	//fh.Read(cstr,fh.FileSize());
+	//cstr[fh.FileSize()] = 0;
+
+	return text;
+}
+
+static void GLSLDefineConstf4(string&amp; str, const string&amp; name, const float3&amp; v, const float&amp; alpha)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec4(%1$.12f,%2$.12f,%3$.12f,%4$.12f)\n&quot;) % (v.x) % (v.y) % (v.z) % (alpha));
+}
+
+static void GLSLDefineConstf3(string&amp; str, const string&amp; name, const float3&amp; v)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec3(%1$.12f,%2$.12f,%3$.12f)\n&quot;) % (v.x) % (v.y) % (v.z));
+}
+
+static void GLSLDefineConstf2(string&amp; str, const string&amp; name, const float&amp; x, const float&amp; y)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec2(%1$.12f,%2$.12f)\n&quot;) % x % y);
+}
+
+static void GLSLDefineConstf1(string&amp; str, const string&amp; name, const float&amp; x)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; %1$.12f\n&quot;) % x);
+}
+
+static GLuint LoadTexture(const string&amp; filename)
+{
+	GLuint texID;
+	CBitmap bm;
+	if (!bm.Load(filename))
+		throw content_error(&quot;Could not load texture from file &quot;+filename);
+
+	glGenTextures(1, &amp;texID);
+	glBindTexture(GL_TEXTURE_2D, texID);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+	//glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 3.0f);
+	glBuildMipmaps(GL_TEXTURE_2D, GLEW_ARB_texture_compression?GL_COMPRESSED_RGB_ARB:GL_RGB8, bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+	return texID;
+}
+
+CBumpWater::CBumpWater()
+{
+	reflTexSize = next_power_of_2(configHandler.GetInt(&quot;BumpWaterTexSizeReflection&quot;, 256));
+	reflection = !!configHandler.GetInt(&quot;BumpWaterReflection&quot;, 1);
+	refraction = configHandler.GetInt(&quot;BumpWaterRefraction&quot;, 1);  //0:=off, 1:=screencopy, 2:=own rendering cycle
+	waves = !!configHandler.GetInt(&quot;BumpBeachWaves&quot;, 1);
+
+	if (!GLEW_EXT_framebuffer_object) {
+		reflection = false;
+	}
+
+	if (refraction&gt;0) {
+		// CREATE REFRACTION TEXTURE
+		glGenTextures(1, &amp;refractTexture);
+		//if(GLEW_ARB_texture_non_power_of_two || GLEW_EXT_texture_non_power_of_two)
+		//	target = GL_TEXTURE_2D;
+		//else //if(GLEW_ARB_texture_rectangle || GLEW_EXT_texture_rectangle)
+			target = GL_TEXTURE_RECTANGLE_ARB;
+		glBindTexture(target, refractTexture);
+		glTexParameteri(target,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+		glTexParameteri(target,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+		if (GLEW_EXT_texture_edge_clamp) {
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		} else {
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+		}
+		if(target == GL_TEXTURE_RECTANGLE_ARB) {
+			refrSizeX = gu-&gt;viewSizeX;
+			refrSizeY = gu-&gt;viewSizeY;
+		} else{
+			refrSizeX = next_power_of_2(gu-&gt;viewSizeX);
+			refrSizeY = next_power_of_2(gu-&gt;viewSizeY);
+		}
+		glTexImage2D(target, 0, GL_RGB8, refrSizeX, refrSizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
+	}
+
+	if (reflection) {
+		// CREATE REFLECTION TEXTURE
+		glGenTextures(1, &amp;reflectTexture);
+		glBindTexture(GL_TEXTURE_2D, reflectTexture);
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+		if (GLEW_EXT_texture_edge_clamp) {
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		} else {
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+		}
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, reflTexSize, reflTexSize, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+
+		// CREATE DEPTH RBO FOR REFLECTION FBO
+		glGenRenderbuffersEXT(1, &amp;rbo);
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbo);
+		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT32, reflTexSize, reflTexSize);
+
+		// CREATE REFLECTION FBO AND BIND TEXTURE&amp;RBO
+		glGenFramebuffersEXT(1,&amp;fbo);
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo);
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, reflectTexture, 0);
+		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, rbo);
+		GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+		if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
+			PrintFboError(status);
+			//logOutput.Print(&quot;BumpWater: FBO not ready&quot;);
+		}
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	}
+
+
+	foamTexture = LoadTexture( mapInfo-&gt;water.foamTexture );
+	normalTexture = LoadTexture( mapInfo-&gt;water.normalTexture );
+	for (int i = 0; i &lt; 32; i++) {
+		caustTextures[i] = LoadTexture( mapInfo-&gt;water.causticTextures[i] );
+	}
+
+	//heightTexture = readmap-&gt;GetShadingTexture();
+	/*
+
+	*/
+
+	/* DEFINE SOME RUNTIME CONSTANTS (I don't use Uniforms for that, 'cos the glsl compiler can't optimize those!) */
+	string definitions;
+	if (reflection)   definitions += &quot;#define use_reflection\n&quot;;
+	if (refraction&gt;0) definitions += &quot;#define use_refraction\n\n&quot;;
+	GLSLDefineConstf4(definitions, &quot;SurfaceColor&quot;, mapInfo-&gt;water.surfaceColor*0.4, mapInfo-&gt;water.surfaceAlpha );
+	GLSLDefineConstf3(definitions, &quot;SpecularColor&quot;, mapInfo-&gt;water.specularColor );
+	GLSLDefineConstf1(definitions, &quot;SpecularFactor&quot;, mapInfo-&gt;water.specularFactor);
+	GLSLDefineConstf3(definitions, &quot;SunDir&quot;, mapInfo-&gt;light.sunDir );
+	GLSLDefineConstf3(definitions, &quot;MapMid&quot;, float3(readmap-&gt;width*SQUARE_SIZE*0.5f,0.0f,readmap-&gt;height*SQUARE_SIZE*0.5f) );
+	GLSLDefineConstf2(definitions, &quot;ScreenInverse&quot;, -1.0f/gu-&gt;viewSizeX, 1.0f/gu-&gt;viewSizeY );
+	GLSLDefineConstf2(definitions, &quot;ViewPos&quot;, gu-&gt;viewPosX,gu-&gt;viewPosY );
+	GLSLDefineConstf1(definitions, &quot;FresnelMin&quot;,  mapInfo-&gt;water.fresnelMin);
+	GLSLDefineConstf1(definitions, &quot;FresnelMax&quot;,  mapInfo-&gt;water.fresnelMax);
+	GLSLDefineConstf1(definitions, &quot;FresnelPower&quot;, mapInfo-&gt;water.fresnelPower);
+
+	/* LOAD SHADERS */
+	string vsSource = LoadShaderSource(&quot;shaders/bumpWaterVS.glsl&quot;);
+	string fsSource = LoadShaderSource(&quot;shaders/bumpWaterFS.glsl&quot;);
+
+	vector&lt;GLint&gt; lengths(2);
+	vector&lt;const GLchar*&gt; strings(2);
+	lengths[0]=definitions.length();
+	strings[0]=definitions.c_str();
+
+	waterVP = glCreateShader(GL_VERTEX_SHADER);
+	lengths[1]=vsSource.length();
+	strings[1]=vsSource.c_str();
+	glShaderSource(waterVP, strings.size(), &amp;strings.front(), &amp;lengths.front());
+	glCompileShader(waterVP);
+	PrintLog(waterVP);
+
+	waterFP = glCreateShader(GL_FRAGMENT_SHADER);
+	lengths[1]= fsSource.length();
+	strings[1] = fsSource.c_str();
+	glShaderSource(waterFP, strings.size(), &amp;strings.front(), &amp;lengths.front());
+	glCompileShader(waterFP);
+	PrintLog(waterFP);
+
+	//delete vsSource; delete fsSource;
+
+	waterShader = glCreateProgram();
+	glAttachShader(waterShader, waterVP);
+	glAttachShader(waterShader, waterFP);
+	glLinkProgram(waterShader);
+	PrintLog(waterShader);
+
+	/* BIND TEXTURE UNIFORMS */
+	glUseProgram(waterShader);
+		eyePosLoc     = glGetUniformLocation(waterShader, &quot;eyePos&quot;);
+		frameLoc      = glGetUniformLocation(waterShader, &quot;frame&quot;);
+		normalmapLoc  = glGetUniformLocation(waterShader, &quot;normalmap&quot;);
+		heightmapLoc  = glGetUniformLocation(waterShader, &quot;heightmap&quot;);
+		causticLoc    = glGetUniformLocation(waterShader, &quot;caustic&quot;);
+		foamLoc       = glGetUniformLocation(waterShader, &quot;foam&quot;);
+		reflectionLoc = glGetUniformLocation(waterShader, &quot;reflection&quot;);
+		refractionLoc = glGetUniformLocation(waterShader, &quot;refraction&quot;);
+
+		glUniform1i(normalmapLoc, 0);
+		glUniform1i(heightmapLoc, 1);
+		glUniform1i(causticLoc, 2);
+		glUniform1i(foamLoc, 3);
+		glUniform1i(reflectionLoc, 4);
+		glUniform1i(refractionLoc, 5);
+	glUseProgram(0);
+}
+
+CBumpWater::~CBumpWater()
+{
+	if (reflection) {
+		glDeleteTextures(1, &amp;reflectTexture);
+		glDeleteRenderbuffersEXT(1, &amp;rbo);
+		glDeleteFramebuffersEXT(1, &amp;fbo);
+	}
+	if (refraction&gt;0)
+		glDeleteTextures(1, &amp;refractTexture);
+
+	glDeleteTextures(1, &amp;foamTexture);
+	glDeleteTextures(32, caustTextures);
+	glDeleteTextures(1, &amp;normalTexture);
+
+	glDeleteShader(waterVP);
+	glDeleteShader(waterFP);
+	glDeleteProgram(waterShader);
+}
+
+void CBumpWater::Draw()
+{
+	if(readmap-&gt;minheight&gt;10)
+		return;
+
+	if (refraction == 1) {
+		// _SCREENCOPY_ REFRACT TEXTURE
+		glBindTexture(target, refractTexture);
+		glEnable(target);
+		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
+		glDisable(target);
+	}
+
+	glDisable(GL_ALPHA_TEST);
+	if (refraction&gt;0)
+		glDisable(GL_BLEND);
+	if (refraction&lt;2)
+		glDepthMask(0);
+
+	glActiveTexture(GL_TEXTURE1);
+		glBindTexture(GL_TEXTURE_2D, readmap-&gt;GetShadingTexture());
+	glActiveTexture(GL_TEXTURE2);
+		glBindTexture(GL_TEXTURE_2D, caustTextures[gs-&gt;frameNum%32]);
+	glActiveTexture(GL_TEXTURE3);
+		glBindTexture(GL_TEXTURE_2D, foamTexture);
+	glActiveTexture(GL_TEXTURE4);
+		glBindTexture(GL_TEXTURE_2D, reflectTexture);
+	glActiveTexture(GL_TEXTURE5);
+		glBindTexture(target, refractTexture);
+	glActiveTexture(GL_TEXTURE0);
+		glBindTexture(GL_TEXTURE_2D, normalTexture);
+
+	glUseProgram(waterShader);
+	glUniform1f(frameLoc,gs-&gt;frameNum/15000.0f);
+	glUniformf3(eyePosLoc,camera-&gt;pos);
+
+	glBegin(GL_QUADS);
+		glTexCoord4f(0.0f,0.0f,0.0f,0.0f);
+			glVertex3i(0,0,0);
+		glTexCoord4f(0.0f,1.0f,0.0f,(float)gs-&gt;mapy/gs-&gt;pwr2mapy);
+			glVertex3i(0,0,readmap-&gt;height*SQUARE_SIZE);
+		glTexCoord4f(1.0f,1.0f,(float)gs-&gt;mapx/gs-&gt;pwr2mapx,(float)gs-&gt;mapy/gs-&gt;pwr2mapy);
+			glVertex3i(readmap-&gt;width*SQUARE_SIZE,0,readmap-&gt;height*SQUARE_SIZE);
+		glTexCoord4f(1.0f,0.0f,(float)gs-&gt;mapx/gs-&gt;pwr2mapx,0.0f);
+			glVertex3i(readmap-&gt;width*SQUARE_SIZE,0,0);
+	glEnd();
+
+	glUseProgram(0);
+
+	if (refraction&lt;2)
+		glDepthMask(1);
+}
+
+void CBumpWater::UpdateWater(CGame* game)
+{
+	if (readmap-&gt;minheight &gt; 10 || mapInfo-&gt;map.voidWater)
+		return;
+
+	if (refraction&gt;1) DrawRefraction(game);
+	if (reflection)   DrawReflection(game);
+}
+
+void CBumpWater::DrawRefraction(CGame* game)
+{
+	// _RENDER_ REFRACTION TEXTURE
+	drawRefraction=true;
+	camera-&gt;Update(false);
+	glViewport(0,0,refrSizeX,refrSizeY);
+
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+	float3 oldsun=unitDrawer-&gt;unitSunColor;
+	float3 oldambient=unitDrawer-&gt;unitAmbientColor;
+
+	unitDrawer-&gt;unitSunColor*=float3(0.5f,0.7f,0.9f);
+	unitDrawer-&gt;unitAmbientColor*=float3(0.6f,0.8f,1.0f);
+
+	game-&gt;SetDrawMode(CGame::refractionDraw);
+
+	glEnable(GL_CLIP_PLANE2);
+	double plane[4]={0,-1,0,2};
+	glClipPlane(GL_CLIP_PLANE2 ,plane);
+	drawReflection=true;
+
+	readmap-&gt;GetGroundDrawer()-&gt;Draw();
+	unitDrawer-&gt;Draw(false,true);
+	featureHandler-&gt;Draw();
+	drawReflection=false;
+	ph-&gt;Draw(false,true);
+	luaCallIns.DrawWorldRefraction();
+
+	glDisable(GL_CLIP_PLANE2);
+	game-&gt;SetDrawMode(CGame::normalDraw);
+	drawRefraction=false;
+
+	glBindTexture(target, refractTexture);
+	glEnable(target);
+	glCopyTexSubImage2D(target,0,0,0,0,0,refrSizeX,refrSizeY);
+	glDisable(target);
+
+	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
+
+	unitDrawer-&gt;unitSunColor=oldsun;
+	unitDrawer-&gt;unitAmbientColor=oldambient;
+}
+
+void CBumpWater::DrawReflection(CGame* game)
+{
+	// CREATE REFLECTION TEXTURE
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo);
+
+	CCamera *realCam = camera;
+	camera = new CCamera(*realCam);
+	camera-&gt;up.x=0;
+	camera-&gt;up.y=1;
+	camera-&gt;up.z=0;
+	camera-&gt;forward.y*=-1;
+	camera-&gt;pos.y*=-1;
+	camera-&gt;Update(false);
+
+	glViewport(0,0,reflTexSize,reflTexSize);
+
+	glClearColor(0.2f,0.4f,0.2f,1);
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+	game-&gt;SetDrawMode(CGame::reflectionDraw);
+
+	sky-&gt;Draw();
+
+	glEnable(GL_CLIP_PLANE2);
+	double plane[4]={0,1,0,0}; // make angle dependent?
+	glClipPlane(GL_CLIP_PLANE2 ,plane);
+	drawReflection=true;
+
+	readmap-&gt;GetGroundDrawer()-&gt;Draw(true);
+	unitDrawer-&gt;Draw(true);
+	featureHandler-&gt;Draw();
+	ph-&gt;Draw(true);
+	luaCallIns.DrawWorldReflection();
+
+	game-&gt;SetDrawMode(CGame::normalDraw);
+	drawReflection=false;
+	glDisable(GL_CLIP_PLANE2);
+
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
+
+	delete camera;
+	camera = realCam;
+	camera-&gt;Update(false);
+}

Copied: branches/gml/rts/Rendering/Env/BumpWater.h (from rev 5882, trunk/rts/Rendering/Env/BumpWater.h)
===================================================================
--- branches/gml/rts/Rendering/Env/BumpWater.h	                        (rev 0)
+++ branches/gml/rts/Rendering/Env/BumpWater.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,69 @@
+// BumpWater.h: interface for the CBumpWater class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#ifndef __BUMP_WATER_H__
+#define __BUMP_WATER_H__
+
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;BaseWater.h&quot;
+
+class CBumpWater : public CBaseWater
+{
+public:
+	void UpdateWater(CGame* game);
+	void DrawReflection(CGame* game);
+	void DrawRefraction(CGame* game);
+	void Draw();
+	CBumpWater();
+	virtual ~CBumpWater();
+	virtual int GetID() const { return 4; }
+
+private:
+	// user options
+	bool reflection;
+	char refraction; //0:=off, 1:=screencopy, 2:=own rendering cycle
+	int  reflTexSize;
+	bool waves;
+
+	// map options
+	float3 surfaceColor;
+	float3 specularColor;
+
+	int  refrSizeX;
+	int  refrSizeY;
+
+	unsigned int target; // of the refract texture
+	GLuint refractTexture;
+	GLuint reflectTexture;
+	GLuint rbo;
+	GLuint fbo;
+
+	GLuint foamTexture;
+	GLuint normalTexture;
+	GLuint caustTextures[32];
+	GLuint* heightTexture;
+
+	GLuint waterFP;
+	GLuint waterVP;
+	GLuint waterShader;
+	
+	GLuint midPosLoc;
+	GLuint eyePosLoc;
+	GLuint lightDirLoc;
+	GLuint fresnelMinLoc;
+	GLuint fresnelMaxLoc;
+	GLuint fresnelPowerLoc;
+	GLuint frameLoc;
+	GLuint screenInverseLoc;
+	GLuint viewPosLoc;
+	GLuint normalmapLoc;
+	GLuint heightmapLoc;
+	GLuint causticLoc;
+	GLuint foamLoc;
+	GLuint reflectionLoc;
+	GLuint refractionLoc;
+};
+
+#endif // __BUMP_WATER_H__
+

Modified: branches/gml/rts/Rendering/Env/DynWater.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/DynWater.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/DynWater.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,8 +5,10 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;bitops.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Rendering/Env/BaseSky.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
@@ -21,8 +23,6 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 
-extern GLfloat FogLand[];
-
 #define W_SIZE 5
 #define WF_SIZE 5120
 #define WH_SIZE 2560
@@ -79,18 +79,20 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
 	glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA16F_ARB ,64, 64, 0,GL_RGBA, GL_FLOAT, temp);
 
-	unsigned char* scrap=SAFE_NEW unsigned char[256*256*4];
 	CBitmap foam;
-	if (!foam.Load(&quot;bitmaps/foam.jpg&quot;) || foam.xsize != 256 || foam.ysize != 256)
-		throw content_error(&quot;Could not load foam from file bitmaps/foam.jpg&quot;);
-	for(int a=0;a&lt;256*256;++a)
+	if (!foam.Load(mapInfo-&gt;water.foamTexture))
+		throw content_error(&quot;Could not load foam from file &quot; + mapInfo-&gt;water.foamTexture);
+	if (count_bits_set(foam.xsize)!=1 || count_bits_set(foam.ysize)!=1)
+		throw content_error(&quot;Foam texture not power of two!&quot;);
+	unsigned char* scrap=SAFE_NEW unsigned char[foam.xsize*foam.ysize*4];
+	for(int a=0;a&lt;foam.xsize*foam.ysize;++a)
 		scrap[a]=foam.mem[a*4];
 
 	glGenTextures(1, &amp;foamTex);
 	glBindTexture(GL_TEXTURE_2D, foamTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D, GL_LUMINANCE,256, 256, GL_LUMINANCE, GL_UNSIGNED_BYTE, scrap);
+	glBuildMipmaps(GL_TEXTURE_2D, GL_LUMINANCE,foam.xsize,foam.ysize, GL_LUMINANCE, GL_UNSIGNED_BYTE, scrap);
 
 	delete[] scrap;
 
@@ -115,7 +117,7 @@
 	dwAddSplashFP=LoadFragmentProgram(&quot;dwAddSplash.fp&quot;);
 	dwAddSplashVP=LoadVertexProgram(&quot;dwAddSplash.vp&quot;);
 
-	waterSurfaceColor = readmap-&gt;waterSurfaceColor;
+	waterSurfaceColor = mapInfo-&gt;water.surfaceColor;
 
 	for(int y=0;y&lt;1024;++y){
 		for(int x=0;x&lt;1024;++x){
@@ -173,9 +175,9 @@
 		for(int x=0;x&lt;64;++x){
 			float dx=x-31.5f;
 			float dist=sqrt(dx*dx+dy*dy);
-			temp[(y*64+x)*4+0]=max(0.0f,1-dist/30.f)*max(0.0f,1-dist/30.f);
-			temp[(y*64+x)*4+1]=max(0.0f,1-dist/30.f);
-			temp[(y*64+x)*4+2]=max(0.0f,1-dist/30.f)*max(0.0f,1-dist/30.f);
+			temp[(y*64+x)*4+0]=std::max(0.0f,1-dist/30.f)*std::max(0.0f,1-dist/30.f);
+			temp[(y*64+x)*4+1]=std::max(0.0f,1-dist/30.f);
+			temp[(y*64+x)*4+2]=std::max(0.0f,1-dist/30.f)*std::max(0.0f,1-dist/30.f);
 			temp[(y*64+x)*4+3]=0;
 		}
 	}
@@ -314,9 +316,9 @@
 	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,6, 0.05f, 1-0.05f, 0, 0);
 	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,7, 0.2f, 0, 0, 0);
 	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,8, 0.5f, 0.6f, 0.8f, 0);
-	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,9, gs-&gt;sunVector.x, gs-&gt;sunVector.y, gs-&gt;sunVector.z, 0);
-	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,10, readmap-&gt;sunColor.x, readmap-&gt;sunColor.y, readmap-&gt;sunColor.z, 0);
-	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,11, readmap-&gt;ambientColor.x, readmap-&gt;ambientColor.y, readmap-&gt;ambientColor.z, 0);
+	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,9, mapInfo-&gt;light.sunDir.x, mapInfo-&gt;light.sunDir.y, mapInfo-&gt;light.sunDir.z, 0);
+	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,10, mapInfo-&gt;light.groundSunColor.x, mapInfo-&gt;light.groundSunColor.y, mapInfo-&gt;light.groundSunColor.z, 0);
+	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,11, mapInfo-&gt;light.groundAmbientColor.x, mapInfo-&gt;light.groundAmbientColor.y, mapInfo-&gt;light.groundAmbientColor.z, 0);
 	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,12, refractRight.x,refractRight.y,refractRight.z,0);
 	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,13, refractUp.x,refractUp.y,refractUp.z,0);
 	glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,14, 0.5f/dx,0.5f/dy,1,1);
@@ -330,7 +332,7 @@
 
 	glDisable( GL_FRAGMENT_PROGRAM_ARB );
 	glDisable( GL_VERTEX_PROGRAM_ARB );
-
+/*
 	glBindTexture(GL_TEXTURE_2D, 0);
 	glActiveTextureARB(GL_TEXTURE1_ARB);
 	glBindTexture(GL_TEXTURE_2D,0);
@@ -347,11 +349,12 @@
 	glActiveTextureARB(GL_TEXTURE7_ARB);
 	glBindTexture(GL_TEXTURE_2D,0);
 	glActiveTextureARB(GL_TEXTURE0_ARB);
+	*/
 }
 
 void CDynWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;minheight &gt; 10 || readmap-&gt;voidWater)
+	if (readmap-&gt;minheight &gt; 10 || mapInfo-&gt;map.voidWater)
 		return;
 
 	glDisable(GL_DEPTH_TEST);
@@ -379,8 +382,8 @@
 
 	oldCamPosBig=camPosBig;
 
-	camPosBig.x=floor(max((float)WH_SIZE, min((float)gs-&gt;mapx*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.x))/(W_SIZE*16))*(W_SIZE*16);
-	camPosBig.z=floor(max((float)WH_SIZE, min((float)gs-&gt;mapy*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.z))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig.x=floor(std::max((float)WH_SIZE, std::min((float)gs-&gt;mapx*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.x))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig.z=floor(std::max((float)WH_SIZE, std::min((float)gs-&gt;mapy*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.z))/(W_SIZE*16))*(W_SIZE*16);
 
 	glDisable(GL_DEPTH_TEST);
 	glDepthMask(0);
@@ -459,7 +462,7 @@
 	glCopyTexSubImage2D(GL_TEXTURE_2D,0,0,0,0,0,512,512);
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
-	glClearColor(FogLand[0],FogLand[1],FogLand[2],1);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 
 	delete camera;
 	camera = realCam;
@@ -477,7 +480,7 @@
 
 	glViewport(0,0,refractSize,refractSize);
 
-	glClearColor(FogLand[0],FogLand[1],FogLand[2],1);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
 	float3 oldsun=unitDrawer-&gt;unitSunColor;
@@ -510,7 +513,7 @@
 	glCopyTexSubImage2D(GL_TEXTURE_2D,0,0,0,0,0,refractSize,refractSize);
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
-	glClearColor(FogLand[0],FogLand[1],FogLand[2],1);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 
 	unitDrawer-&gt;unitSunColor=oldsun;
 	unitDrawer-&gt;unitAmbientColor=oldambient;
@@ -841,8 +844,8 @@
 	va=GetVertexArray();
 	va-&gt;Initialize();
 
-	camPosBig2.x=floor(max((float)WH_SIZE, min((float)gs-&gt;mapx*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.x))/(W_SIZE*16))*(W_SIZE*16);
-	camPosBig2.z=floor(max((float)WH_SIZE, min((float)gs-&gt;mapy*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.z))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig2.x=floor(std::max((float)WH_SIZE, std::min((float)gs-&gt;mapx*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.x))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig2.z=floor(std::max((float)WH_SIZE, std::min((float)gs-&gt;mapy*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.z))/(W_SIZE*16))*(W_SIZE*16);
 
 	for(int lod=1;lod&lt;(2&lt;&lt;5);lod*=2){
 		int cx=(int)(cam2-&gt;pos.x/(WSQUARE_SIZE));
@@ -864,10 +867,10 @@
 		int minlx=cx+(-viewRadius+2-xsquaremod)*lod;
 		int maxlx=cx+(viewRadius-xsquaremod)*lod;
 
-		int xstart=max(minlx,mintx);
-		int xend=min(maxlx,maxtx);
-		int ystart=max(minly,minty);
-		int yend=min(maxly,maxty);
+		int xstart=std::max(minlx,mintx);
+		int xend=std::min(maxlx,maxtx);
+		int ystart=std::max(minly,minty);
+		int yend=std::min(maxly,maxty);
 
 		for(int y=ystart;y&lt;yend;y+=lod){
 			int xs=xstart;
@@ -1232,15 +1235,15 @@
 {
 	if(pos.y&gt;size || size &lt; 8)
 		return;
-	explosions.push_back(Explosion(pos,min(size*20,strength),size));
+	explosions.push_back(Explosion(pos,std::min(size*20,strength),size));
 }
 
 void CDynWater::DrawUpdateSquare(float dx,float dy, int* resetTexs)
 {
-	float startx=max(0.f, -dx/WF_SIZE);
-	float starty=max(0.f, -dy/WF_SIZE);
-	float endx=min(1.f, 1-dx/WF_SIZE);
-	float endy=min(1.f, 1-dy/WF_SIZE);
+	float startx=std::max(0.f, -dx/WF_SIZE);
+	float starty=std::max(0.f, -dy/WF_SIZE);
+	float endx=std::min(1.f, 1-dx/WF_SIZE);
+	float endy=std::min(1.f, 1-dy/WF_SIZE);
 
 	DrawSingleUpdateSquare(startx,starty,endx,endy);
 

Modified: branches/gml/rts/Rendering/Env/GrassDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/GrassDrawer.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/GrassDrawer.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,6 +13,7 @@
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &lt;algorithm&gt;
 #include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
 //#include &quot;TimeProfiler.h&quot;
@@ -22,8 +23,6 @@
 static const int grassSquareSize=4;		//mapsquares per grass square
 static const int grassBlockSize=4;		//grass squares per grass block
 
-extern GLfloat FogLand[]; 
-
 static float fRand(float size)
 {
 	return float(rand())/RAND_MAX*size;
@@ -101,7 +100,7 @@
 	glBindTexture(GL_TEXTURE_2D, grassBladeTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 64, GL_RGBA, GL_UNSIGNED_BYTE, gbt);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 64, GL_RGBA, GL_UNSIGNED_BYTE, gbt);
 
 	CreateFarTex();
 
@@ -146,20 +145,20 @@
 	float dist;
 };
 
-static const bool GrassSort(const InviewGrass* a,const InviewGrass* b){
-	return a-&gt;dist &gt; b-&gt;dist;
+static const bool GrassSort(const InviewGrass&amp; a, const InviewGrass&amp; b){
+	return a.dist &gt; b.dist;
 }
 
-static const bool GrassSortNear(const InviewNearGrass* a,const InviewNearGrass* b){
-	return a-&gt;dist &gt; b-&gt;dist;
+static const bool GrassSortNear(const InviewNearGrass&amp; a, const InviewNearGrass&amp; b){
+	return a.dist &gt; b.dist;
 }
 
 class CGrassBlockDrawer : public CReadMap::IQuadDrawer
 {
 public:
-	GML_VECTOR_EXP&lt;InviewGrass*&gt; inviewGrass;
-	GML_VECTOR_EXP&lt;InviewNearGrass*&gt; inviewNearGrass;
-//	CVertexArray* va;
+	std::vector&lt;InviewGrass&gt; inviewGrass;
+	std::vector&lt;InviewNearGrass&gt; inviewNearGrass;
+	CVertexArray* va;
 	int cx,cy;
 	CGrassDrawer *gd;
 
@@ -207,10 +206,10 @@
 								}
 							}
 						} else {//near but not close, save for later drawing
-							InviewNearGrass* iv=SAFE_NEW InviewNearGrass;
-							iv-&gt;dist=sqdist;
-							iv-&gt;x=x*grassBlockSize+x2;
-							iv-&gt;y=y*grassBlockSize+y2;
+							InviewNearGrass iv;
+							iv.dist=sqdist;
+							iv.x=x*grassBlockSize+x2;
+							iv.y=y*grassBlockSize+y2;
 							inviewNearGrass.push_back(iv);
 							nearGrass[((y*grassBlockSize+y2)&amp;31)*32+((x*grassBlockSize+x2)&amp;31)].square=-1;
 						}
@@ -243,7 +242,7 @@
 		if(!grass[curModSquare].va){
 			grass[curModSquare].va=SAFE_NEW CVertexArray;;
 			grass[curModSquare].pos=float3((x+0.5f)*SQUARE_SIZE*blockMapSize,ground-&gt;GetHeight2((x+0.5f)*SQUARE_SIZE*blockMapSize,(y+0.5f)*SQUARE_SIZE*blockMapSize),(y+0.5f)*SQUARE_SIZE*blockMapSize);
-			CVertexArray* va=grass[curModSquare].va;
+			va=grass[curModSquare].va;
 			va-&gt;Initialize();
 			for(int y2=0;y2&lt;grassBlockSize;y2++){
 				for(int x2=0;x2&lt;grassBlockSize;x2++){
@@ -268,9 +267,9 @@
 				}
 			}
 		}
-		InviewGrass* ig=SAFE_NEW InviewGrass;
-		ig-&gt;num=curModSquare;
-		ig-&gt;dist=dist;
+		InviewGrass ig;
+		ig.num=curModSquare;
+		ig.dist=dist;
 		inviewGrass.push_back(ig);	
 	}
 }
@@ -312,9 +311,9 @@
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL);
 		glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_ALPHA);
-		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1-readmap-&gt;shadowDensity);
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1-mapInfo-&gt;light.groundShadowDensity);
 		
-		float texConstant[]={readmap-&gt;ambientColor.x*1.24f,readmap-&gt;ambientColor.y*1.24f,readmap-&gt;ambientColor.z*1.24f,1};
+		float texConstant[]={mapInfo-&gt;light.groundAmbientColor.x*1.24f,mapInfo-&gt;light.groundAmbientColor.y*1.24f,mapInfo-&gt;light.groundAmbientColor.z*1.24f,1};
 		glTexEnvfv(GL_TEXTURE_ENV,GL_TEXTURE_ENV_COLOR,texConstant); 
 		glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_PREVIOUS_ARB);
 		glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_CONSTANT);
@@ -393,7 +392,7 @@
 	glDisable(GL_BLEND);
 	glDisable(GL_ALPHA_TEST);
 	glEnable(GL_FOG);
-	glFogfv(GL_FOG_COLOR,FogLand);
+	glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
 
 	const int blockMapSize=grassSquareSize*grassBlockSize;
 
@@ -403,10 +402,8 @@
 	drawer.cy=(int)(camera-&gt;pos.z/(SQUARE_SIZE*blockMapSize));
 	drawer.gd = this;
 
-	GML_EXP_MODE_ENABLE()
 	readmap-&gt;GridVisibility (camera, blockMapSize, maxGrassDist, &amp;drawer);
-	GML_EXP_MODE_DISABLE()
-	//CVertexArray *va = drawer.va;
+	CVertexArray *va = drawer.va;
 	
 	float grassDistance=maxGrassDist;
 
@@ -452,13 +449,13 @@
 		glActiveTextureARB(GL_TEXTURE0_ARB);
 	}
 
-	for(GML_VECTOR_EXP&lt;InviewGrass*&gt;::iterator gi=drawer.inviewGrass.begin();gi!=drawer.inviewGrass.end();++gi){
-		if((*gi)-&gt;dist+128&lt;grassDistance)
+	for (std::vector&lt;InviewGrass&gt;::iterator gi = drawer.inviewGrass.begin(); gi != drawer.inviewGrass.end(); ++gi) {
+		if((*gi).dist+128&lt;grassDistance)
 			glColor4f(0.62f,0.62f,0.62f,1);			
 		else
-			glColor4f(0.62f,0.62f,0.62f,1-((*gi)-&gt;dist+128-grassDistance)/128.0f);			
+			glColor4f(0.62f,0.62f,0.62f,1-((*gi).dist+128-grassDistance)/128.0f);			
 
-		float3 v=grass[(*gi)-&gt;num].pos-camera-&gt;pos;
+		float3 v=grass[(*gi).num].pos-camera-&gt;pos;
 		v.Normalize();
 		float3 side(v.cross(UpVector));
 		side.Normalize();
@@ -466,19 +463,15 @@
 		float3 up(side.cross(v));
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,9,  up.x,up.y,up.z,0);
 		float ang=acos(v.y);
-		int texPart=min(15,(int)max(0,(int)((ang+PI/16-PI/2)/PI*30)));
+		int texPart=std::min(15,(int)std::max(0,(int)((ang+PI/16-PI/2)/PI*30)));
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,10, texPart/16.0f,0,0,0.0f);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,11,  -v.x,-v.y,-v.z,0);
-
-		grass[(*gi)-&gt;num].va-&gt;DrawArrayTN(GL_QUADS);
-
-		delete *gi;	
+		grass[(*gi).num].va-&gt;DrawArrayTN(GL_QUADS);
 	}
-
 	glColor4f(0.62f,0.62f,0.62f,1);			
-	for(GML_VECTOR_EXP&lt;InviewNearGrass*&gt;::iterator gi=drawer.inviewNearGrass.begin();gi!=drawer.inviewNearGrass.end();++gi){
-		int x=(*gi)-&gt;x;
-		int y=(*gi)-&gt;y;
+	for(std::vector&lt;InviewNearGrass&gt;::iterator gi = drawer.inviewNearGrass.begin(); gi != drawer.inviewNearGrass.end(); ++gi) {
+		int x = (*gi).x;
+		int y = (*gi).y;
 		if(grassMap[(y)*gs-&gt;mapx/grassSquareSize+(x)]){
 
 			float3 squarePos((x+0.5f)*SQUARE_SIZE*grassSquareSize, 0, (y+0.5f)*SQUARE_SIZE*grassSquareSize);
@@ -491,7 +484,7 @@
 			float3 up(side.cross(v));
 			glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,9,  up.x,up.y,up.z,0);
 			float ang=acos(v.y);
-			int texPart=min(15,int(max(0,int((ang+PI/16-PI/2)/PI*30))));
+			int texPart=std::min(15,int(std::max(0,int((ang+PI/16-PI/2)/PI*30))));
 			glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,10, texPart/16.0f,0,0,0.0f);
 			glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,11,  -v.x,-v.y,-v.z,0);
 
@@ -499,7 +492,7 @@
 			rand();
 			rand();
 			int numGrass=numTurfs;
-			CVertexArray *va=GetVertexArray();
+			va=GetVertexArray();
 			va-&gt;Initialize();
 			for(int a=0;a&lt;numGrass;a++){
 				float dx=(x+fRand(1))*SQUARE_SIZE*grassSquareSize;
@@ -516,7 +509,6 @@
 			}
 			va-&gt;DrawArrayTN(GL_QUADS);
 		}
-		delete *gi;	
 	}
 
 	//cleanup stuff
@@ -744,7 +736,7 @@
 					buf[((y)*1024*sizeMod+x+dx)*4+0]=(unsigned char) (r/a);
 					buf[((y)*1024*sizeMod+x+dx)*4+1]=(unsigned char) (g/a);
 					buf[((y)*1024*sizeMod+x+dx)*4+2]=(unsigned char) (b/a);
-					buf[((y)*1024*sizeMod+x+dx)*4+3]=(unsigned char) (min((float)255,a*16));
+					buf[((y)*1024*sizeMod+x+dx)*4+3]=(unsigned char) (std::min((float)255,a*16));
 				}
 			}
 		}
@@ -764,7 +756,7 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,1024*sizeMod, 64*sizeMod, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,1024*sizeMod, 64*sizeMod, GL_RGBA, GL_UNSIGNED_BYTE, buf);
 
 	delete[] buf;
 	delete[] buf2;

Modified: branches/gml/rts/Rendering/Env/SkyBox.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/SkyBox.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Env/SkyBox.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,13 +5,11 @@
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;GlobalStuff.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;mmgr.h&quot;
 
-extern GLfloat FogBlack[]; 
-extern GLfloat FogLand[]; 
-
 CSkyBox::CSkyBox(std::string texture)
 {
 	CBitmap btex;
@@ -19,11 +17,12 @@
 		throw content_error(&quot;Could not load skybox texture from file &quot; + texture);
 	tex = btex.CreateTexture(0);
 
-	readmap-&gt;mapDefParser.GetDef(fogStart,&quot;0.1&quot;,&quot;MAP\\ATMOSPHERE\\FogStart&quot;);
+	cloudDensity = mapInfo-&gt;atmosphere.cloudDensity;
+	cloudColor = mapInfo-&gt;atmosphere.cloudColor;
+	skyColor = mapInfo-&gt;atmosphere.skyColor;
+	sunColor = mapInfo-&gt;atmosphere.sunColor;
+	fogStart = mapInfo-&gt;atmosphere.fogStart;
 	if (fogStart&gt;0.99f) gu-&gt;drawFog = false;
-	skyColor=readmap-&gt;mapDefParser.GetFloat3(float3(0.1f,0.15f,0.7f),&quot;MAP\\ATMOSPHERE\\SkyColor&quot;);
-	sunColor=readmap-&gt;mapDefParser.GetFloat3(float3(1,1,1),&quot;MAP\\ATMOSPHERE\\SunColor&quot;);
-	cloudColor=readmap-&gt;mapDefParser.GetFloat3(float3(1,1,1),&quot;MAP\\ATMOSPHERE\\CloudColor&quot;);
 }
 
 CSkyBox::~CSkyBox(void)
@@ -82,7 +81,7 @@
 	glEnable(GL_DEPTH_TEST);
 	glDisable(GL_BLEND);
 	if (gu-&gt;drawFog) {
-		glFogfv(GL_FOG_COLOR,FogLand);
+		glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
 		glFogi(GL_FOG_MODE,GL_LINEAR);
 		glFogf(GL_FOG_START,gu-&gt;viewRange*fogStart);
 		glFogf(GL_FOG_END,gu-&gt;viewRange);

Modified: branches/gml/rts/Rendering/FartextureHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/FartextureHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/FartextureHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,13 +5,12 @@
 #include &quot;GlobalStuff.h&quot;
 #include &quot;UnitModels/UnitDrawer.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;mmgr.h&quot;
 
+
 CFartextureHandler* fartextureHandler = NULL;
 
-extern GLfloat LightDiffuseLand[];
-extern GLfloat LightAmbientLand[];
-extern GLfloat FogLand[];
 
 CFartextureHandler::CFartextureHandler(void)
 {
@@ -25,6 +24,7 @@
 	farTexture=0;
 }
 
+
 CFartextureHandler::~CFartextureHandler(void)
 {
 	delete[] farTextureMem;
@@ -34,6 +34,7 @@
 	texturehandler=0;
 }
 
+
 /**
  * @brief Add the model to the queue of units waiting for their fartexture.
  * On the next CreateFarTextures() call the fartexture for this model will be
@@ -44,6 +45,7 @@
 	pending.push_back(model);
 }
 
+
 /**
  * @brief Process the queue of pending fartexture creation requests.
  * This loops through the queue calling ReallyCreateFarTexture() on each entry,
@@ -57,6 +59,7 @@
 	pending.clear();
 }
 
+
 /**
  * @brief Really create the far texture for the given model.
  */
@@ -76,7 +79,7 @@
 	GLfloat LightDiffuseLand2[]=	{ 0.0f, 0.0f, 0.0f, 1.0f };
 	GLfloat LightAmbientLand2[]=	{ 0.6f, 0.6f, 0.6f, 1.0f };
 	for(int a=0;a&lt;3;++a)
-		LightAmbientLand2[a]=min(1.f,unitDrawer-&gt;unitAmbientColor[a]+unitDrawer-&gt;unitSunColor[a]*0.2f);
+		LightAmbientLand2[a] = std::min(1.f,unitDrawer-&gt;unitAmbientColor[a]+unitDrawer-&gt;unitSunColor[a]*0.2f);
 	glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbientLand2);
 	glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuseLand2);
 	glLightfv(GL_LIGHT1, GL_SPECULAR, LightAmbientLand2);
@@ -102,7 +105,7 @@
 	glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,cols2);
 	glColor3f(1,1,1);
 	glRotatef(10,1,0,0);
-	glLightfv(GL_LIGHT1, GL_POSITION,gs-&gt;sunVector4);
+	glLightfv(GL_LIGHT1, GL_POSITION,mapInfo-&gt;light.sunDir);
 	glEnable(GL_LIGHT1);
 
 	int baseX=0;
@@ -127,7 +130,7 @@
 			}
 		baseX+=16;
 		glRotatef(45,0,1,0);
-		glLightfv(GL_LIGHT1, GL_POSITION,gs-&gt;sunVector4);
+		glLightfv(GL_LIGHT1, GL_POSITION,mapInfo-&gt;light.sunDir);
 	}
 
 	glCullFace(GL_BACK);
@@ -135,11 +138,11 @@
 	glDisable(GL_LIGHTING);
 	glDisable(GL_TEXTURE_2D);
 
-	glClearColor(FogLand[0],FogLand[1],FogLand[2],0);
+	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],0);
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
-	glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbientLand);		// Setup The Ambient Light
-	glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuseLand);		// Setup The Diffuse Light
-	glLightfv(GL_LIGHT1, GL_SPECULAR, LightAmbientLand);		// Setup The Diffuse Light
+	glLightfv(GL_LIGHT1, GL_AMBIENT, mapInfo-&gt;light.unitAmbientColor);
+	glLightfv(GL_LIGHT1, GL_DIFFUSE, mapInfo-&gt;light.unitSunColor);
+	glLightfv(GL_LIGHT1, GL_SPECULAR, mapInfo-&gt;light.unitAmbientColor);
 
 	if(farTexture==0){
 		glGenTextures(1, &amp;farTexture);
@@ -156,5 +159,3 @@
 	usedFarTextures++;
 	POP_CODE_MODE;
 }
-
-

Modified: branches/gml/rts/Rendering/GL/VertexArray.cpp
===================================================================
--- branches/gml/rts/Rendering/GL/VertexArray.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/GL/VertexArray.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -44,16 +44,10 @@
 	*stripArrayPos++=((char *)drawArrayPos-(char *)drawArray);
 }
 
-inline void CVertexArray::CheckEnlargeDrawArray() {
-	if((char *)drawArrayPos&gt;(char *)drawArraySize-10*sizeof(float))
+void CVertexArray::EnlargeArrays(int vertexes, int strips, int stripsize) {
+	while((char *)drawArrayPos&gt;(char *)drawArraySize-stripsize*sizeof(float)*vertexes)
 		EnlargeDrawArray();
-}
 
-
-void CVertexArray::EnlargeArrays(int vertexes, int strips) {
-	while((char *)drawArrayPos&gt;(char *)drawArraySize-3*sizeof(float)*vertexes)
-		EnlargeDrawArray();
-
 	while((char *)stripArrayPos&gt;(char *)stripArraySize-sizeof(int)*strips)
 		EnlargeStripArray();
 }
@@ -62,24 +56,6 @@
 	*stripArrayPos++=((char *)drawArrayPos-(char *)drawArray);
 }
 
-
-void CVertexArray::AddVertexQ0(float x, float y, float z) {
-	*drawArrayPos++=x;
-	*drawArrayPos++=y;
-	*drawArrayPos++=z;
-}
-
-
-void CVertexArray::AddVertex0(const float3&amp; pos) {
-	if(drawArrayPos&gt;drawArraySize-10)
-		EnlargeDrawArray();
-
-	*drawArrayPos++=pos.x;
-	*drawArrayPos++=pos.y;
-	*drawArrayPos++=pos.z;
-}
-
-
 inline void CVertexArray::DrawArrays(int drawType, int stride) {
 	int newIndex,oldIndex=0;
 	int *stripArrayPtr=stripArray;
@@ -95,72 +71,42 @@
 		EndStrip();
 }
 
-
-
 void CVertexArray::DrawArray0(int drawType,int stride) {
 	CheckEndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,drawArray);
 	glEnableClientState(GL_VERTEX_ARRAY);
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
 	DrawArrays(drawType, stride);
 	glDisableClientState(GL_VERTEX_ARRAY);                                          
 }
 
-void CVertexArray::AddVertexC(const float3&amp; pos,unsigned char* color) {
-	CheckEnlargeDrawArray();
-	*drawArrayPos++=pos.x;
-	*drawArrayPos++=pos.y;
-	*drawArrayPos++=pos.z;
-	*drawArrayPos++=*((float*)(color));
-}
-
 void CVertexArray::DrawArrayC(int drawType,int stride) {
 	CheckEndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,drawArray);
-	glColorPointer(4,GL_UNSIGNED_BYTE,stride,drawArray+3);
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_COLOR_ARRAY);
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glColorPointer(4,GL_UNSIGNED_BYTE,stride,drawArray+3);
 	DrawArrays(drawType, stride);
 	glDisableClientState(GL_VERTEX_ARRAY);                                          
 	glDisableClientState(GL_COLOR_ARRAY);
 }
 
-void CVertexArray::AddVertexT(const float3&amp; pos,float tx,float ty) {
-	CheckEnlargeDrawArray();
-	*drawArrayPos++=pos.x;
-	*drawArrayPos++=pos.y;
-	*drawArrayPos++=pos.z;
-	*drawArrayPos++=tx;
-	*drawArrayPos++=ty;
-}
-
 void CVertexArray::DrawArrayT(int drawType,int stride) {
 	CheckEndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,drawArray);
-	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
 	DrawArrays(drawType, stride);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glDisableClientState(GL_VERTEX_ARRAY);                                          
 }
 
-void CVertexArray::AddVertexT2(const float3&amp; pos,float tx,float ty,float t2x,float t2y) {
-	CheckEnlargeDrawArray();
-	*drawArrayPos++=pos.x;
-	*drawArrayPos++=pos.y;
-	*drawArrayPos++=pos.z;
-	*drawArrayPos++=tx;
-	*drawArrayPos++=ty;
-	*drawArrayPos++=t2x;
-	*drawArrayPos++=t2y;
-}
-
 void CVertexArray::DrawArrayT2(int drawType,int stride) {
 	CheckEndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,drawArray);
-	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
 
 	glClientActiveTextureARB(GL_TEXTURE1_ARB);
 	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+5);
@@ -175,50 +121,28 @@
 	glDisableClientState(GL_VERTEX_ARRAY);                                          
 }
 
-void CVertexArray::AddVertexTN(const float3&amp; pos,float tx,float ty,const float3&amp; norm) {
-	CheckEnlargeDrawArray();
-	*drawArrayPos++=pos.x;
-	*drawArrayPos++=pos.y;
-	*drawArrayPos++=pos.z;
-	*drawArrayPos++=tx;
-	*drawArrayPos++=ty;
-	*drawArrayPos++=norm.x;
-	*drawArrayPos++=norm.y;
-	*drawArrayPos++=norm.z;
-}
-
 void CVertexArray::DrawArrayTN(int drawType, int stride) {
 	CheckEndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,drawArray);
-	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
-	glNormalPointer(GL_FLOAT,stride,drawArray+5);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_NORMAL_ARRAY);
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
+	glNormalPointer(GL_FLOAT,stride,drawArray+5);
 	DrawArrays(drawType, stride);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glDisableClientState(GL_VERTEX_ARRAY);                                          
 	glDisableClientState(GL_NORMAL_ARRAY);
 }
 
-void CVertexArray::AddVertexTC(const float3&amp; pos,float tx,float ty,unsigned char* col) {
-	CheckEnlargeDrawArray();
-	*drawArrayPos++=pos.x;
-	*drawArrayPos++=pos.y;
-	*drawArrayPos++=pos.z;
-	*drawArrayPos++=tx;
-	*drawArrayPos++=ty;
-	*drawArrayPos++=*((float*)(col));
-}
-
 void CVertexArray::DrawArrayTC(int drawType, int stride) {
 	CheckEndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,drawArray);
-	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
-	glColorPointer(4,GL_UNSIGNED_BYTE,stride,drawArray+5);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_COLOR_ARRAY);
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
+	glColorPointer(4,GL_UNSIGNED_BYTE,stride,drawArray+5);
 	DrawArrays(drawType, stride);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glDisableClientState(GL_VERTEX_ARRAY);                                          

Modified: branches/gml/rts/Rendering/GL/VertexArray.h
===================================================================
--- branches/gml/rts/Rendering/GL/VertexArray.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/GL/VertexArray.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -11,28 +11,28 @@
 	~CVertexArray();
 	void Initialize();
 
-	void AddVertexTC(const float3 &amp;pos,float tx,float ty,unsigned char* color);
+	inline void AddVertexTC(const float3 &amp;pos,float tx,float ty,unsigned char* color);
 	void DrawArrayTC(int drawType,int stride=24);
-	void AddVertexTN(const float3 &amp;pos,float tx,float ty,const float3&amp; norm);
+	inline void AddVertexTN(const float3 &amp;pos,float tx,float ty,const float3&amp; norm);
 	void DrawArrayTN(int drawType,int stride=32);
-	void AddVertexT2(const float3&amp; pos,float t1x,float t1y,float t2x,float t2y);
+	inline void AddVertexT2(const float3&amp; pos,float t1x,float t1y,float t2x,float t2y);
 	void DrawArrayT2(int drawType,int stride=28);
-	void AddVertexT(const float3&amp; pos,float tx,float ty);
+	inline void AddVertexT(const float3&amp; pos,float tx,float ty);
 	void DrawArrayT(int drawType,int stride=20);
-	void AddVertex0(const float3&amp; pos);
+	inline void AddVertex0(const float3&amp; pos);
 	void DrawArray0(int drawType,int stride=12);
-	void AddVertexC(const float3&amp; pos,unsigned char* color);
+	inline void AddVertexC(const float3&amp; pos,unsigned char* color);
 	void DrawArrayC(int drawType,int stride=16);
 	void EnlargeStripArray();
 	void EnlargeDrawArray();
 	void EndStrip();
 	bool IsReady();
-  void CheckEnlargeDrawArray();
+  inline void CheckEnlargeDrawArray();
 	void CheckEndStrip();
   void DrawArrays(int drawType, int stride);
-  void EnlargeArrays(int vertexes, int strips);
+  void EnlargeArrays(int vertexes, int strips, int stripsize=3);
 	void EndStripQ();
-	void AddVertexQ0(float x, float y, float z);
+	inline void AddVertexQ0(float x, float y, float z);
 
 	int drawIndex();
 
@@ -45,4 +45,74 @@
 	int* stripArraySize;
 };
 
+inline void CVertexArray::CheckEnlargeDrawArray() {
+	if((char *)drawArrayPos&gt;(char *)drawArraySize-10*sizeof(float))
+		EnlargeDrawArray();
+}
+
+inline void CVertexArray::AddVertexQ0(float x, float y, float z) {
+	*drawArrayPos++=x;
+	*drawArrayPos++=y;
+	*drawArrayPos++=z;
+}
+
+inline void CVertexArray::AddVertex0(const float3&amp; pos) {
+	if(drawArrayPos&gt;drawArraySize-10)
+		EnlargeDrawArray();
+
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+}
+
+inline void CVertexArray::AddVertexC(const float3&amp; pos,unsigned char* color) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=*((float*)(color));
+}
+
+inline void CVertexArray::AddVertexT(const float3&amp; pos,float tx,float ty) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=tx;
+	*drawArrayPos++=ty;
+}
+
+inline void CVertexArray::AddVertexT2(const float3&amp; pos,float tx,float ty,float t2x,float t2y) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=tx;
+	*drawArrayPos++=ty;
+	*drawArrayPos++=t2x;
+	*drawArrayPos++=t2y;
+}
+
+inline void CVertexArray::AddVertexTN(const float3&amp; pos,float tx,float ty,const float3&amp; norm) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=tx;
+	*drawArrayPos++=ty;
+	*drawArrayPos++=norm.x;
+	*drawArrayPos++=norm.y;
+	*drawArrayPos++=norm.z;
+}
+
+inline void CVertexArray::AddVertexTC(const float3&amp; pos,float tx,float ty,unsigned char* col) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=tx;
+	*drawArrayPos++=ty;
+	*drawArrayPos++=*((float*)(col));
+}
+
 #endif /* VERTEXARRAY_H */

Modified: branches/gml/rts/Rendering/GL/myGL.cpp
===================================================================
--- branches/gml/rts/Rendering/GL/myGL.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/GL/myGL.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,15 +13,16 @@
 #include &quot;FPUCheck.h&quot;
 #include &lt;SDL.h&gt;
 #include &quot;mmgr.h&quot;
+#include &quot;System/GlobalStuff.h&quot;
 
 #include &quot;IFramebuffer.h&quot;
 
 using namespace std;
 
 
-static CVertexArray* vertexArray1 = 0;
-static CVertexArray* vertexArray2 = 0;
-static CVertexArray* currentVertexArray = 0;
+static CVertexArray* vertexArray1 = NULL;
+static CVertexArray* vertexArray2 = NULL;
+static CVertexArray* currentVertexArray = NULL;
 
 static GLuint startupTexture = 0;
 
@@ -73,6 +74,24 @@
 	logOutput.Print(&quot;GL:   %s\n&quot;, glGetString(GL_RENDERER));
 	logOutput.Print(&quot;GLEW: %s\n&quot;, glewGetString(GLEW_VERSION));
 
+	/* Get available fullscreen/hardware modes */
+/*
+	SDL_Rect **modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_OPENGL|SDL_RESIZABLE);
+
+	if (modes == (SDL_Rect **)0) {
+		logOutput.Print(&quot;SDL_ListModes: No modes available!\n&quot;);
+	}else if (modes == (SDL_Rect **)-1) {
+		logOutput.Print(&quot;SDL_ListModes: Resolution is restricted.\n&quot;);
+	}else{
+		char buffer[512];
+		unsigned char n = 0;
+		for(int i=0;modes[i];++i) {
+			n += SNPRINTF(&amp;buffer[n], 512-n, &quot;%dx%d, &quot;, modes[i]-&gt;w, modes[i]-&gt;h);
+		}
+		logOutput.Print(&quot;SDL_ListModes: %s\n&quot;,buffer);
+	}
+*/
+
 	if(!GLEW_ARB_multitexture || !GLEW_ARB_texture_env_combine){
 		handleerror(0,&quot;Needed extension GL_ARB_texture_env_combine not found&quot;,&quot;Update drivers&quot;,0);
 		exit(0);
@@ -100,10 +119,41 @@
 {
 	delete vertexArray1;
 	delete vertexArray2;
+}
 
+/******************************************************************************/
+
+void glBuildMipmaps(const GLenum target,GLint internalFormat,const GLsizei width,const GLsizei height,const GLenum format,const GLenum type,const void *data)
+{
+	if (gu-&gt;compressTextures) {
+		switch ( internalFormat ) {
+			case 3:
+			case GL_RGB8 :
+			case GL_RGB :   internalFormat = GL_COMPRESSED_RGB_ARB; break;
+			
+			case 4:
+			case GL_RGBA8 :
+			case GL_RGBA : internalFormat = GL_COMPRESSED_RGBA_ARB; break;
+			
+			case GL_LUMINANCE: internalFormat = GL_COMPRESSED_LUMINANCE_ARB; break;
+		}
+	}
+	
+	// create mipmapped texture
+	if (glGenerateMipmapEXT) {
+	//if (GLEW_EXT_framebuffer_object) { // Hurray (again), ATi only supports half of the extension
+		// newest method
+		glTexImage2D(target, 0, internalFormat, width, height, 0, format, type, data);
+		glGenerateMipmapEXT(GL_TEXTURE_2D);
+	}else if (GLEW_VERSION_1_4) {
+		// This required GL-1.4
+		// instead of using glu, we rely on glTexImage2D to create the Mipmaps.
+		glTexParameteri(GL_TEXTURE_2D,GL_GENERATE_MIPMAP,true);
+		glTexImage2D(target, 0, internalFormat, width, height, 0, format, type, data);
+	} else
+		gluBuild2DMipmaps(target, internalFormat, width, height, format, type, data);
 }
 
-
 /******************************************************************************/
 
 static void AppendStringVec(vector&lt;string&gt;&amp; dst, const vector&lt;string&gt;&amp; src)
@@ -137,6 +187,8 @@
 
 void LoadStartPicture(const std::string&amp; sidePref)
 {
+	if (startupTexture) 
+		return;
 	const string picDir = &quot;bitmaps/loadpictures/&quot;;
 
 	string name = &quot;&quot;;

Modified: branches/gml/rts/Rendering/GL/myGL.h
===================================================================
--- branches/gml/rts/Rendering/GL/myGL.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/GL/myGL.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -28,9 +28,28 @@
 	glTranslatef(v.x,v.y,v.z);
 }
 
+inline void glSecondaryColorf3(const float3&amp; v)
+{
+	glSecondaryColor3f(v.x,v.y,v.z);
+}
+
+inline void glColorf4(const float3&amp; v, const float&amp; alpha)
+{
+	glColor4f(v.x,v.y,v.z,alpha);
+}
+
+inline void glUniformf3(const GLint&amp; location, const float3 &amp;v)
+{
+	glUniform3f(location, v.x,v.y,v.z);
+}
+
+
+void glBuildMipmaps(const GLenum target,GLint internalFormat,const GLsizei width,const GLsizei height,const GLenum format,const GLenum type,const void *data);
+
 void LoadStartPicture(const std::string&amp; sidePref);
 void PrintLoadMsg(const char* text, bool swapbuffers = true);
 void UnloadStartPicture();
+
 bool ProgramStringIsNative(GLenum target, const char* filename);
 unsigned int LoadVertexProgram(const char* filename);
 unsigned int LoadFragmentProgram(const char* filename);

Modified: branches/gml/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/GroundDecalHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/GroundDecalHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,6 +6,7 @@
 #include &quot;GL/VertexArray.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
@@ -13,7 +14,9 @@
 #include &quot;Game/Camera.h&quot;
 #include &quot;Sim/Units/UnitTypes/Building.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;ShadowHandler.h&quot;
+#include &quot;TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 
 CGroundDecalHandler* groundDecals = 0;
@@ -40,18 +43,18 @@
 	LoadScar((char*)(&quot;bitmaps/&quot;+tdfparser.SGetValueDef(&quot;scars/scar1.bmp&quot;,&quot;resources\\graphics\\scars\\scar1&quot;)).c_str(),buf,0,256);
 	LoadScar((char*)(&quot;bitmaps/&quot;+tdfparser.SGetValueDef(&quot;scars/scar4.bmp&quot;,&quot;resources\\graphics\\scars\\scar4&quot;)).c_str(),buf,256,256);
 
-	glGenTextures(1, &amp;scarTex);			
+	glGenTextures(1, &amp;scarTex);
 	glBindTexture(GL_TEXTURE_2D, scarTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
 //	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 //	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, buf);
 
 	scarFieldX=gs-&gt;mapx/32;
 	scarFieldY=gs-&gt;mapy/32;
 	scarField=SAFE_NEW std::set&lt;Scar*&gt;[scarFieldX*scarFieldY];
-	
+
 	lastTest=0;
 	maxOverlap=decalLevel+1;
 
@@ -143,9 +146,9 @@
 		glBindProgramARB(GL_VERTEX_PROGRAM_ARB, decalVP);
 		glEnable(GL_VERTEX_PROGRAM_ARB );
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 10, 1.0f / (gs-&gt;pwr2mapx * SQUARE_SIZE), 1.0f / (gs-&gt;pwr2mapy * SQUARE_SIZE), 0, 1);
-		float3 ac = readmap-&gt;ambientColor * (210.0f / 255.0f);
+		float3 ac = mapInfo-&gt;light.groundAmbientColor * (210.0f / 255.0f);
 		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 10, ac.x, ac.y, ac.z, 1);
-		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 11, 0, 0, 0, readmap-&gt;shadowDensity);
+		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 11, 0, 0, 0, mapInfo-&gt;light.groundShadowDensity);
 		glMatrixMode(GL_MATRIX0_ARB);
 		glLoadMatrixf(shadowHandler-&gt;shadowMatrix.m);
 		glMatrixMode(GL_MODELVIEW);
@@ -167,6 +170,10 @@
 					decal-&gt;alpha -= decal-&gt;AlphaFalloff * gu-&gt;lastFrameTime * gs-&gt;speedFactor;
 				}
 				if (decal-&gt;alpha &lt; 0) {
+					// make sure RemoveBuilding() won't try to modify this decal
+					if (decal-&gt;owner) {
+						decal-&gt;owner-&gt;buildingDecal = 0;
+					}
 					delete decal;
 					(*bdi)-&gt;buildingDecals.erase(bi++);
 					continue;
@@ -390,7 +397,7 @@
 						float pz1 = z * 16;
 						float px2 = px1 + 16;
 						float pz2 = pz1 + 16;
-	
+
 						float tx1 = min(0.5f, (pos.x - px1) / (radius * 4.0f) + 0.25f);
 						float tx2 = max(0.0f, (pos.x - px2) / (radius * 4.0f) + 0.25f);
 						float tz1 = min(0.5f, (pos.z - pz1) / (radius * 4.0f) + 0.25f);
@@ -460,7 +467,7 @@
 		mp=0;
 	if(mp&gt;=gs-&gt;mapSquares/4)
 		mp=gs-&gt;mapSquares/4-1;
-	if(!readmap-&gt;terrainTypes[readmap-&gt;typemap[mp]].receiveTracks)
+	if(!mapInfo-&gt;terrainTypes[readmap-&gt;typemap[mp]].receiveTracks)
 		return;
 
 	TrackType* type=trackTypes[unit-&gt;unitDef-&gt;trackType];
@@ -556,7 +563,7 @@
 			bm.mem[(y*bm.xsize+x)*4+2]=(brighness*30)/255;
 		}
 	}
-	
+
 	return bm.CreateTexture(true);
 }
 

Modified: branches/gml/rts/Rendering/InMapDraw.cpp
===================================================================
--- branches/gml/rts/Rendering/InMapDraw.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/InMapDraw.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,6 +12,7 @@
 #include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;NetProtocol.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Sound.h&quot;
@@ -123,7 +124,7 @@
 	glBindTexture(GL_TEXTURE_2D, texture);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, 128, 64, GL_RGBA, GL_UNSIGNED_BYTE, tex[0]);
+	glBuildMipmaps(GL_TEXTURE_2D, GL_RGBA8, 128, 64, GL_RGBA, GL_UNSIGNED_BYTE, tex[0]);
 
 	blippSound=sound-&gt;GetWaveId(&quot;sounds/beep6.wav&quot;);
 }
@@ -434,10 +435,10 @@
 			const float radius = 100.0f;
 			const int maxY = drawQuadsY - 1;
 			const int maxX = drawQuadsX - 1;
-			const int yStart = (int) max(0,    int((pos.z - radius) * quadScale));
-			const int xStart = (int) max(0,    int((pos.x - radius) * quadScale));
-			const int yEnd   = (int) min(maxY, int((pos.z + radius) * quadScale));
-			const int xEnd   = (int) min(maxX, int((pos.x + radius) * quadScale));
+			const int yStart = (int) std::max(0,    int((pos.z - radius) * quadScale));
+			const int xStart = (int) std::max(0,    int((pos.x - radius) * quadScale));
+			const int yEnd   = (int) std::min(maxY, int((pos.z + radius) * quadScale));
+			const int xEnd   = (int) std::min(maxX, int((pos.x + radius) * quadScale));
 
 			for (int y = yStart; y &lt;= yEnd; ++y) {
 				for (int x = xStart; x &lt;= xEnd; ++x) {

Modified: branches/gml/rts/Rendering/ShadowHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/ShadowHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/ShadowHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,6 +5,8 @@
 #include &quot;Game/Camera.h&quot;
 #include &quot;UnitModels/UnitDrawer.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Matrix44f.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
@@ -199,7 +201,7 @@
 	glMatrixMode(GL_MODELVIEW);
 	glLoadIdentity();
 
-	float3 sundir=gs-&gt;sunVector;
+	float3 sundir=mapInfo-&gt;light.sunDir;
 	cross1=(sundir.cross(UpVector)).Normalize();
 	cross2=cross1.cross(sundir);
 	centerPos=camera-&gt;pos;

Modified: branches/gml/rts/Rendering/Textures/Bitmap.cpp
===================================================================
--- branches/gml/rts/Rendering/Textures/Bitmap.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Textures/Bitmap.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -343,14 +343,7 @@
 	{
 		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
 
-		// create mipmapped texture
-		if (GLEW_VERSION_1_4) {
-			// This required GL-1.4
-			// instead of using glu, we rely on glTexImage2D to create the Mipmaps.
-			glTexParameteri(GL_TEXTURE_2D,GL_GENERATE_MIPMAP,true);
-			glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8 ,xsize, ysize, 0,GL_RGBA, GL_UNSIGNED_BYTE, mem);
-		} else
-			gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,xsize, ysize,GL_RGBA, GL_UNSIGNED_BYTE, mem);
+		glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,xsize, ysize,GL_RGBA, GL_UNSIGNED_BYTE, mem);
 	}
 	else
 	{
@@ -380,6 +373,7 @@
 	case nv_dds::TextureFlat:    // 1D, 2D, and rectangle textures
 		glEnable(GL_TEXTURE_2D);
 		glBindTexture(GL_TEXTURE_2D, texobj);
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
 		if(!ddsimage-&gt;upload_texture2D()) {
 			glDeleteTextures(1, &amp;texobj);
 			texobj = 0;

Modified: branches/gml/rts/Rendering/Textures/NamedTextures.cpp
===================================================================
--- branches/gml/rts/Rendering/Textures/NamedTextures.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Textures/NamedTextures.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -138,7 +138,7 @@
 			             GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
 		} else {
 			gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, bitmap.xsize, bitmap.ysize,
-			                  GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
+			                  GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem); // make power of two!
 		}
 	} else {
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
@@ -147,8 +147,9 @@
 		} else {
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 		}
-		gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, bitmap.xsize, bitmap.ysize,
-											GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
+
+		glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bitmap.xsize, bitmap.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
+		
 	}
 
 	if (aniso &amp;&amp; GLEW_EXT_texture_filter_anisotropic) {

Modified: branches/gml/rts/Rendering/Textures/TextureAtlas.cpp
===================================================================
--- branches/gml/rts/Rendering/Textures/TextureAtlas.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Textures/TextureAtlas.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,6 +9,9 @@
 CR_BIND(AtlasedTexture, );
 CR_BIND_DERIVED(GroundFXTexture, AtlasedTexture, );
 
+//texture spacing in the atlas (in pixels)
+#define TEXMARGIN 1
+
 bool CTextureAtlas::debug;
 
 CTextureAtlas::CTextureAtlas(int maxxsize, int maxysize)
@@ -99,7 +102,7 @@
 					if(maxy&gt;ysize){
 						if(IncreaseSize())
 						{
-                            nextSub.clear();
+ 							nextSub.clear();
 							thisSub.clear();
 							cury=maxy=curx=0;
 							recalc=true;
@@ -131,11 +134,11 @@
 
 			done=true;
 
-			if(thisSub.front().y+curtex-&gt;ysize&lt;maxy){
-				nextSub.push_back(int2(thisSub.front().x,thisSub.front().y+curtex-&gt;ysize));
+			if(thisSub.front().y+curtex-&gt;ysize+TEXMARGIN&lt;maxy){
+				nextSub.push_back(int2(thisSub.front().x+TEXMARGIN,thisSub.front().y+curtex-&gt;ysize+TEXMARGIN));
 			}
 
-			thisSub.front().x+=curtex-&gt;xsize;
+			thisSub.front().x+=curtex-&gt;xsize+TEXMARGIN;
 			while(thisSub.size()&gt;1 &amp;&amp; thisSub.front().x &gt;= (++thisSub.begin())-&gt;x){
 				(++thisSub.begin())-&gt;x=thisSub.front().x;
 				thisSub.erase(thisSub.begin());
@@ -179,54 +182,17 @@
 {
 
 	unsigned char *data;
-	//for(int i=0,xmip=0,ymip=0; (xsize&gt;&gt;i) || (ysize&gt;&gt;i); i++)
-	//{
-	//	data[i] = SAFE_NEW unsigned char[(xsize&gt;&gt;xmip)*(ysize&gt;&gt;ymip)*4];
-
-	//	xmip = (xsize&gt;&gt;i)&gt;1 ? xmip+=1 : xmip;
-	//	ymip = (ysize&gt;&gt;i)&gt;1 ? ymip+=1 : ymip;
-	//}
-
-	//for(int i=0; i&lt;memtextures.size(); i++)
-	//{
-	//	MemTex *tex = memtextures[i];
-	//	for(int mip=0,xmip=0,ymip=0; (tex-&gt;xsize&gt;&gt;mip) || (tex-&gt;ysize&gt;&gt;mip); mip++)
-	//	{
-	//		unsigned char *mipcell;
-
-	//		if(mip==0)
-	//			mipcell = (unsigned char*)tex-&gt;data;
-	//		else
-	//		{
-	//			mipcell = SAFE_NEW unsigned char[(tex-&gt;xsize&gt;&gt;xmip)*(tex-&gt;ysize&gt;&gt;ymip)*4];
-	//			gluScaleImage(GL_RGBA, tex-&gt;xsize, tex-&gt;ysize, GL_UNSIGNED_BYTE, tex-&gt;data, (tex-&gt;xsize&gt;&gt;xmip), (tex-&gt;ysize&gt;&gt;ymip), GL_UNSIGNED_BYTE, mipcell);
-	//		}
-
-	//		for(int x=0; x&lt;tex-&gt;xsize&gt;&gt;xmip; x++)
-	//		{
-	//			for(int y=0; y&lt;tex-&gt;ysize&gt;&gt;ymip; y++)
-	//			{
-	//				((int*)data[mip])[(tex-&gt;xpos&gt;&gt;xmip)+x+((tex-&gt;ypos&gt;&gt;ymip)+y)*(xsize&gt;&gt;mip)] = ((int*)mipcell)[x+y*(tex-&gt;xsize&gt;&gt;xmip)];
-	//			}
-	//		}
-
-	//		if(mip)
-	//			delete [] mipcell;
-	//		xmip = (xsize&gt;&gt;mip)&gt;1 ? xmip+=1 : xmip;
-	//		ymip = (ysize&gt;&gt;mip)&gt;1 ? ymip+=1 : ymip;
-	//	}
-	//}
-
 	data = SAFE_NEW unsigned char[xsize*ysize*4];
+	memset(data,0,xsize*ysize*4); // make spacing between textures black transparent to avoid ugly lines with linear filtering
 
 	for(int i=0; i&lt;memtextures.size(); i++)
 	{
 		MemTex *tex = memtextures[i];
-        for(int x=0; x&lt;tex-&gt;xsize; x++)
-			for(int y=0; y&lt;tex-&gt;ysize; y++)
-			{
+		for(int x=0; x&lt;tex-&gt;xsize; x++) {
+			for(int y=0; y&lt;tex-&gt;ysize; y++) {
 				((int*)data)[tex-&gt;xpos+x+(tex-&gt;ypos+y)*xsize] = ((int*)tex-&gt;data)[x+y*tex-&gt;xsize];
 			}
+		}			
 	}
 
 	if (debug) {
@@ -248,20 +214,18 @@
 	glBindTexture(GL_TEXTURE_2D, gltex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,/*GL_NEAREST_MIPMAP_LINEAR*/GL_NEAREST);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
+	if (GLEW_EXT_texture_edge_clamp) {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	} else {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+	}
 
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,xsize, ysize, GL_RGBA, GL_UNSIGNED_BYTE, data);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,xsize, ysize, GL_RGBA, GL_UNSIGNED_BYTE, data);
 
 	delete [] data;
 
-	//for(int i=0; (xsize&gt;&gt;i) || (ysize&gt;&gt;i); i++)
-	//{
-	//	glTexImage2D(GL_TEXTURE_2D, i, GL_RGBA, xsize&gt;&gt;i, ysize&gt;&gt;i, 0, GL_RGBA, GL_UNSIGNED_BYTE, data[i]);
-	//	delete [] data[i];
-	//}
-	
-
 	initialized=true;
 }
 

Modified: branches/gml/rts/Rendering/Textures/TextureHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/Textures/TextureHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/Textures/TextureHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -64,7 +64,7 @@
 		files.push_back(*fi);
 	}
 
-	set&lt;string&gt; usedNames;
+	std::set&lt;string&gt; usedNames;
 
 	for(std::vector&lt;std::string&gt;::iterator fi = files.begin(); fi != files.end(); ++fi) {
 		std::string s = std::string(*fi);
@@ -210,7 +210,8 @@
 	glBindTexture(GL_TEXTURE_2D, globalTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR/*_MIPMAP_NEAREST*/);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bigTexX, bigTexY, GL_RGBA, GL_UNSIGNED_BYTE, tex);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8 ,bigTexX, bigTexY, 0, GL_RGBA, GL_UNSIGNED_BYTE, tex);
+	//glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bigTexX, bigTexY, GL_RGBA, GL_UNSIGNED_BYTE, tex);
 //	CBitmap save(tex,bigTexX,bigTexY);
 	//save.Save(&quot;unittex-1x.jpg&quot;);
 
@@ -230,7 +231,7 @@
 
 CTextureHandler::~CTextureHandler()
 {
-	map&lt;string,UnitTexture*&gt;::iterator tti;
+	std::map&lt;string,UnitTexture*&gt;::iterator tti;
 	for(tti=textures.begin();tti!=textures.end();++tti){
 		delete tti-&gt;second;
 	}
@@ -342,9 +343,9 @@
 	for(int a=0;a&lt;bm-&gt;ysize*bm-&gt;xsize;++a){
 		if(bm-&gt;mem[a*4]==bm-&gt;mem[a*4+2] &amp;&amp; bm-&gt;mem[a*4+1]==0){
 			float lum=bm-&gt;mem[a*4]/255.0f;
-			bm-&gt;mem[a*4+0]=(unsigned char)(min(255,int(teamCol[0]*lum*1.5f)));
-			bm-&gt;mem[a*4+1]=(unsigned char)(min(255,int(teamCol[1]*lum*1.5f)));
-			bm-&gt;mem[a*4+2]=(unsigned char)(min(255,int(teamCol[2]*lum*1.5f)));
+			bm-&gt;mem[a*4+0]=(unsigned char)(std::min(255,int(teamCol[0]*lum*1.5f)));
+			bm-&gt;mem[a*4+1]=(unsigned char)(std::min(255,int(teamCol[1]*lum*1.5f)));
+			bm-&gt;mem[a*4+2]=(unsigned char)(std::min(255,int(teamCol[2]*lum*1.5f)));
 		}
 	}
 	return tex;

Modified: branches/gml/rts/Rendering/UnitModels/3DModelParser.cpp
===================================================================
--- branches/gml/rts/Rendering/UnitModels/3DModelParser.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/UnitModels/3DModelParser.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -20,11 +20,11 @@
 	delete units3oparser;
 }
 
-S3DOModel* C3DModelParser::Load3DModel(string name, float scale, int side)
+S3DOModel* C3DModelParser::Load3DModel(std::string name, float scale, int side)
 {
 	// TODO: abstract this
 	StringToLowerInPlace(name);
-	if (name.find(&quot;.s3o&quot;) != string::npos)
+	if (name.find(&quot;.s3o&quot;) != std::string::npos)
 		return units3oparser-&gt;LoadS3O(name, scale, side);
 	else
 		return unit3doparser-&gt;Load3DO(name, scale, side);
@@ -41,7 +41,7 @@
 }
 */
 
-LocalS3DOModel *C3DModelParser::CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces)
+LocalS3DOModel *C3DModelParser::CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces)
 {
 	LocalS3DOModel* lm;
 	if (model-&gt;rootobject3do) {
@@ -352,9 +352,9 @@
 	glTranslatef(offset.x, offset.y, offset.z);
 
 	if (anim) {
-		glTranslatef(-anim-&gt;coords[0] / CORDDIV,
-									anim-&gt;coords[1] / CORDDIV,
-									anim-&gt;coords[2] / CORDDIV);
+		glTranslatef(anim-&gt;coords[0] / CORDDIV,
+				 anim-&gt;coords[1] / CORDDIV,
+				 anim-&gt;coords[2] / CORDDIV);
 		if (anim-&gt;rot[1]) { glRotatef( anim-&gt;rot[1] / ANGDIV, 0.0f, 1.0f, 0.0f); }
 		if (anim-&gt;rot[0]) { glRotatef( anim-&gt;rot[0] / ANGDIV, 1.0f, 0.0f, 0.0f); }
 		if (anim-&gt;rot[2]) { glRotatef(-anim-&gt;rot[2] / ANGDIV, 0.0f, 0.0f, 1.0f); }

Modified: branches/gml/rts/Rendering/UnitModels/3DModelParser.h
===================================================================
--- branches/gml/rts/Rendering/UnitModels/3DModelParser.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/UnitModels/3DModelParser.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,13 +5,10 @@
 #include &lt;string&gt;
 #include &quot;Matrix44f.h&quot;
 
-using namespace std;
-
-
 struct S3DO;
 struct SS3O;
-class	C3DOParser;
-class	CS3OParser;
+class C3DOParser;
+class CS3OParser;
 struct S3DOModel;
 struct LocalS3DOModel;
 
@@ -22,9 +19,9 @@
 	C3DModelParser(void);
 	~C3DModelParser(void);
 
-	S3DOModel* Load3DModel(string name, float scale = 1.0f, int side = 1);
+	S3DOModel* Load3DModel(std::string name, float scale = 1.0f, int side = 1);
 	// S3DOModel* Load3DO(string name,float scale,int side,const float3&amp; offsets);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces);
+	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
 
 	C3DOParser* unit3doparser;
 	CS3OParser* units3oparser;
@@ -40,7 +37,7 @@
 	int numobjects;
 	float radius;
 	float height;
-	string name;
+	std::string name;
 	int farTextureNum;
 	float maxx,maxy,maxz;
 	float minx,miny,minz;
@@ -58,8 +55,8 @@
 {
 	float3 offset;
 	unsigned int displist;
-	vector&lt;unsigned int&gt; lodDispLists;
-	string name;
+	std::vector&lt;unsigned int&gt; lodDispLists;
+	std::string name;
 	std::vector&lt;LocalS3DO*&gt; childs;
 	LocalS3DO *parent;
 	S3DO *original3do;

Modified: branches/gml/rts/Rendering/UnitModels/3DOParser.h
===================================================================
--- branches/gml/rts/Rendering/UnitModels/3DOParser.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/UnitModels/3DOParser.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,9 +12,7 @@
 #include &lt;set&gt;
 #include &quot;3DModelParser.h&quot;
 
-using namespace std;
 class CMatrix44f;
-
 class CFileHandler;
 
 struct S3DOVertex {
@@ -91,9 +89,9 @@
 public:
 	C3DOParser();
 	virtual ~C3DOParser();
-	S3DOModel* Load3DO(string name,float scale=1,int side=1);
-	// S3DOModel* Load3DO(string name,float scale,int side,const float3&amp; offsets);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces);
+	S3DOModel* Load3DO(std::string name, float scale = 1, int side = 1);
+	// S3DOModel* Load3DO(std::string name,float scale,int side,const float3&amp; offsets);
+	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
 
 private:
 	void FindCenter(S3DO* object);
@@ -110,10 +108,10 @@
 	std::string GetText(int pos);
 	bool ReadChild(int pos,S3DO* root,int side, int *numobj);
 	void DrawSub(S3DO* o);
-	void CreateLocalModel(S3DO *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	void CreateLocalModel(S3DO *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
 
-	map&lt;string,S3DOModel*&gt; units;
-	set&lt;string&gt; teamtex;
+	std::map&lt;std::string, S3DOModel*&gt; units;
+	std::set&lt;std::string&gt; teamtex;
 
 	int curOffset;
 	unsigned char* fileBuf;

Modified: branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,6 +13,7 @@
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Rendering/Env/BaseSky.h&quot;
@@ -90,13 +91,13 @@
 
 	whiteTex=white.CreateTexture(false);
 
-	unitAmbientColor=readmap-&gt;mapDefParser.GetFloat3(float3(0.4f,0.4f,0.4f),&quot;MAP\\LIGHT\\UnitAmbientColor&quot;);
-	unitSunColor=readmap-&gt;mapDefParser.GetFloat3(float3(0.7f,0.7f,0.7f),&quot;MAP\\LIGHT\\UnitSunColor&quot;);
+	unitAmbientColor = mapInfo-&gt;light.unitAmbientColor;
+	unitSunColor = mapInfo-&gt;light.unitSunColor;
+	unitShadowDensity = mapInfo-&gt;light.unitShadowDensity;
 
-	float3 specularSunColor=readmap-&gt;mapDefParser.GetFloat3(unitSunColor,&quot;MAP\\LIGHT\\SpecularSunColor&quot;);
-	readmap-&gt;mapDefParser.GetDef(unitShadowDensity,&quot;0.8&quot;,&quot;MAP\\LIGHT\\UnitShadowDensity&quot;);
+	float3 specularSunColor = mapInfo-&gt;light.specularSunColor;
+	advShading = !!configHandler.GetInt(&quot;AdvUnitShading&quot;, GLEW_ARB_fragment_program? 1: 0);
 
-	advShading=!!configHandler.GetInt(&quot;AdvUnitShading&quot;, GLEW_ARB_fragment_program ? 1 : 0);
 	if (advShading &amp;&amp; !GLEW_ARB_fragment_program) {
 		logOutput.Print(&quot;You are missing an OpenGL extension needed to use advanced unit shading (GL_ARB_fragment_program)&quot;);
 		advShading = false;
@@ -139,12 +140,12 @@
 		glTexParameteri(GL_TEXTURE_CUBE_MAP_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 		glTexParameteri(GL_TEXTURE_CUBE_MAP_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
-		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB,specTexSize,float3( 1, 1, 1),float3( 0, 0,-2),float3(0,-2, 0),gs-&gt;sunVector,100,specularSunColor);
-		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB,specTexSize,float3(-1, 1,-1),float3( 0, 0, 2),float3(0,-2, 0),gs-&gt;sunVector,100,specularSunColor);
-		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB,specTexSize,float3(-1 ,1,-1),float3( 2, 0, 0),float3(0, 0, 2),gs-&gt;sunVector,100,specularSunColor);
-		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB,specTexSize,float3(-1,-1, 1),float3( 2, 0, 0),float3(0, 0,-2),gs-&gt;sunVector,100,specularSunColor);
-		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB,specTexSize,float3(-1, 1, 1),float3( 2, 0, 0),float3(0,-2, 0),gs-&gt;sunVector,100,specularSunColor);
-		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB,specTexSize,float3( 1, 1,-1),float3(-2, 0, 0),float3(0,-2, 0),gs-&gt;sunVector,100,specularSunColor);
+		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB,specTexSize,float3( 1, 1, 1),float3( 0, 0,-2),float3(0,-2, 0),mapInfo-&gt;light.sunDir,100,specularSunColor);
+		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB,specTexSize,float3(-1, 1,-1),float3( 0, 0, 2),float3(0,-2, 0),mapInfo-&gt;light.sunDir,100,specularSunColor);
+		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB,specTexSize,float3(-1 ,1,-1),float3( 2, 0, 0),float3(0, 0, 2),mapInfo-&gt;light.sunDir,100,specularSunColor);
+		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB,specTexSize,float3(-1,-1, 1),float3( 2, 0, 0),float3(0, 0,-2),mapInfo-&gt;light.sunDir,100,specularSunColor);
+		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB,specTexSize,float3(-1, 1, 1),float3( 2, 0, 0),float3(0,-2, 0),mapInfo-&gt;light.sunDir,100,specularSunColor);
+		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB,specTexSize,float3( 1, 1,-1),float3(-2, 0, 0),float3(0,-2, 0),mapInfo-&gt;light.sunDir,100,specularSunColor);
 	}
 }
 
@@ -198,9 +199,6 @@
 }
 
 
-extern GLfloat FogLand[];
-
-
 inline void CUnitDrawer::DrawUnitLOD(CUnit* unit)
 {
 	if (unit-&gt;isCloaked) {
@@ -370,7 +368,7 @@
 	drawCloakedS3O.clear();
 
 	glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
-	glFogfv(GL_FOG_COLOR, FogLand);
+	glFogfv(GL_FOG_COLOR, mapInfo-&gt;atmosphere.fogColor);
 
 	drawIcon.clear();
 	drawRadarIcon.clear();
@@ -395,7 +393,7 @@
 	mt_excludeUnit=excludeUnit;
 	gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DrawUnitMTcb,this,gmlThreadCount,FALSE,&amp;uh-&gt;activeUnits,uh-&gt;activeUnits.size(),50,100,TRUE);
 #else
-	for (list&lt;CUnit*&gt;::iterator usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
+	for (std::list&lt;CUnit*&gt;::iterator usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
 		CUnit* unit = *usi;
 #ifdef DIRECT_CONTROL_ALLOWED
 		if (unit == excludeUnit) {
@@ -511,7 +509,7 @@
 	camNorm.Normalize();
 	glColor3f(1, 1, 1);
 	glEnable(GL_FOG);
-	glFogfv(GL_FOG_COLOR, FogLand);
+	glFogfv(GL_FOG_COLOR, mapInfo-&gt;atmosphere.fogColor);
 
 	for (GML_VECTOR&lt;CUnit*&gt;::iterator usi = drawFar.begin(); usi != drawFar.end(); usi++) {
 		DrawFar(*usi);
@@ -726,10 +724,10 @@
 
 	CUnit::SetLODFactor(LODScale * LODScaleShadow);
 
-#if GML_ENABLE_DRAWUNIT
+#if GML_ENABLE_DRAWUNITSHADOW
 	gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DrawUnitShadowMTcb,this,gmlThreadCount,FALSE,&amp;uh-&gt;activeUnits,uh-&gt;activeUnits.size(),50,100,TRUE);
 #else
-	list&lt;CUnit*&gt;::iterator usi;
+	std::list&lt;CUnit*&gt;::iterator usi;
 	for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
 		CUnit* unit = *usi;
 
@@ -1068,7 +1066,7 @@
 		}
 		glEnable(GL_FRAGMENT_PROGRAM_ARB);
 
-		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 10, gs-&gt;sunVector.x, gs-&gt;sunVector.y, gs-&gt;sunVector.z, 0);
+		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 10, mapInfo-&gt;light.sunDir.x, mapInfo-&gt;light.sunDir.y, mapInfo-&gt;light.sunDir.z, 0);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 12, unitAmbientColor.x, unitAmbientColor.y, unitAmbientColor.z, 1);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 11, unitSunColor.x, unitSunColor.y, unitSunColor.z, 0);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 13, camera-&gt;pos.x, camera-&gt;pos.y, camera-&gt;pos.z, 0);
@@ -1112,8 +1110,8 @@
 		glLoadIdentity();
 	} else {
 		glEnable(GL_LIGHTING);
-		glLightfv(GL_LIGHT1, GL_POSITION,gs-&gt;sunVector4);	// Position The Light
-		glEnable(GL_LIGHT1);								// Enable Light One
+		glLightfv(GL_LIGHT1, GL_POSITION, mapInfo-&gt;light.sunDir);
+		glEnable(GL_LIGHT1);
 	//	glDisable(GL_CULL_FACE);
 	//	glCullFace(GL_BACK);
 		glEnable(GL_TEXTURE_2D);
@@ -1260,7 +1258,7 @@
 		}
 		glEnable( GL_FRAGMENT_PROGRAM_ARB );
 
-		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,10, gs-&gt;sunVector.x,gs-&gt;sunVector.y,gs-&gt;sunVector.z,0);
+		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,10, mapInfo-&gt;light.sunDir.x,mapInfo-&gt;light.sunDir.y,mapInfo-&gt;light.sunDir.z,0);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,12, unitAmbientColor.x,unitAmbientColor.y,unitAmbientColor.z,1);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,11, unitSunColor.x,unitSunColor.y,unitSunColor.z,0);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,13, camera-&gt;pos.x, camera-&gt;pos.y, camera-&gt;pos.z, 0);
@@ -1311,8 +1309,8 @@
 		glLoadIdentity();
 	} else {
 		glEnable(GL_LIGHTING);
-		glLightfv(GL_LIGHT1, GL_POSITION,gs-&gt;sunVector4);	// Position The Light
-		glEnable(GL_LIGHT1);								// Enable Light One
+		glLightfv(GL_LIGHT1, GL_POSITION, mapInfo-&gt;light.sunDir);
+		glEnable(GL_LIGHT1);
 
 		SetupBasicS3OTexture0();
 
@@ -1532,7 +1530,7 @@
 			if (dot &lt; 0)
 				dot = 0;
 
-			float exp = min(1.f, powf(dot, exponent) + powf(dot, 3) * 0.25f);
+			float exp = std::min(1.f, powf(dot, exponent) + powf(dot, 3) * 0.25f);
 			buf[(y * size + x) * 4 + 0] = (unsigned char) (suncolor.x * exp * 255);
 			buf[(y * size + x) * 4 + 1] = (unsigned char) (suncolor.y * exp * 255);
 			buf[(y * size + x) * 4 + 2] = (unsigned char) (suncolor.z * exp * 255);
@@ -1613,12 +1611,13 @@
 
 void CUnitDrawer::QueS3ODraw(CWorldObject* object, int textureType)
 {
-#if !GML_ENABLE
+#if GML_ENABLE
+	quedS3Os.acquire(textureType).push_back(object);
+	quedS3Os.release();
+#else
 	while (quedS3Os.size() &lt;= textureType)
 		quedS3Os.push_back(GML_VECTOR&lt;CWorldObject*&gt;());
-#endif
 	quedS3Os[textureType].push_back(object);
-#if !GML_ENABLE
 	usedS3OTextures.insert(textureType);
 #endif
 }
@@ -1862,7 +1861,7 @@
 		GLUquadricObj* q = gluNewQuadric();
 		gluQuadricDrawStyle(q, GLU_LINE);
 
-		CCollisionVolume* vol = unit-&gt;unitDef-&gt;collisionVolume;
+		CollisionVolume* vol = unit-&gt;collisionVolume;
 
 		switch (vol-&gt;GetVolumeType()) {
 			case COLVOL_TYPE_ELLIPSOID: {
@@ -1968,16 +1967,16 @@
 		const double plane0[4] = {0, -1, 0 , start + height * (unit-&gt;buildProgress * 3 - 2)};
 		glClipPlane(GL_CLIP_PLANE0, plane0);
 
-		if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
+		//if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
 			glPolygonOffset(1.0f, 1.0f);
 			glEnable(GL_POLYGON_OFFSET_FILL);
-		}
+		//}
 
 		DrawUnitModel(unit);
 
-		if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
+		//if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
 			glDisable(GL_POLYGON_OFFSET_FILL);
-		}
+		//}
 	}
 
 	glDisable(GL_CLIP_PLANE0);
@@ -2107,7 +2106,7 @@
 	glRectf(-5.0f, 4.0f, +5.0f, 6.0f);
 
 	// healthbar
-	const float hpp = max(0.0f, unit-&gt;health / unit-&gt;maxHealth);
+	const float hpp = std::max(0.0f, unit-&gt;health / unit-&gt;maxHealth);
 	const float hEnd = hpp * 10.0f;
 
 	if (unit-&gt;stunned) {
@@ -2164,13 +2163,13 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitS3O(CUnit* unit)
 {
 	SetS3OTeamColour(unit-&gt;team);
 	DrawUnitNow(unit);
 }
 
-
 void CUnitDrawer::DrawFeatureS3O(CFeature* feature)
 {
 	glPushMatrix();
@@ -2184,21 +2183,13 @@
 	glPopMatrix();
 }
 
-void CUnitDrawer::DrawWorldObjectS3O(CWorldObject* obj)
+
+void CUnitDrawer::DrawWorldObjectS3O(CWorldObject* S3OObj)
 {
-	// not as neat as the previous solution (ie. a virtual DrawS3O()
-	// function in CWorldObject implemented by CUnit and CFeature),
-	// but this way the sim-code does not need to be polluted with
-	// OGL stuff
-	if (obj) {
-		if (dynamic_cast&lt;CUnit*&gt;(obj)) {
-			// S3O unit
-			DrawUnitS3O((CUnit*) obj);
-		} else {
-			if (dynamic_cast&lt;CFeature*&gt;(obj)) {
-				// S3O feature
-				DrawFeatureS3O((CFeature*) obj);
-			}
-		}
+	if (S3OObj) {
+		// calls back to DrawUnitS3O() for units and
+		// DrawFeatureS3O() for features, projectiles
+		// and weapons with S3O models do not
+		S3OObj-&gt;DrawS3O();
 	}
 }

Modified: branches/gml/rts/Rendering/UnitModels/s3oParser.cpp
===================================================================
--- branches/gml/rts/Rendering/UnitModels/s3oParser.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/UnitModels/s3oParser.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -41,7 +41,7 @@
 
 CS3OParser::~CS3OParser()
 {
-	map&lt;string,S3DOModel*&gt;::iterator ui;
+	std::map&lt;std::string,S3DOModel*&gt;::iterator ui;
 	for(ui=units.begin();ui!=units.end();++ui){
 		DeleteSS3O(ui-&gt;second-&gt;rootobjects3o);
 		delete ui-&gt;second;
@@ -56,14 +56,14 @@
 	delete o;
 }
 
-S3DOModel* CS3OParser::LoadS3O(string name,float scale,int side)
+S3DOModel* CS3OParser::LoadS3O(std::string name,float scale,int side)
 {
-	if(name.find(&quot;.&quot;)==string::npos)
+	if(name.find(&quot;.&quot;)==std::string::npos)
 		name+=&quot;.s3o&quot;;
 
 	StringToLowerInPlace(name);
 
-	map&lt;string,S3DOModel*&gt;::iterator ui;
+	std::map&lt;std::string,S3DOModel*&gt;::iterator ui;
 	if((ui=units.find(name))!=units.end()){
 		return ui-&gt;second;
 	}
@@ -123,7 +123,7 @@
 	return model;
 }
 
-LocalS3DOModel* CS3OParser::CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces)
+LocalS3DOModel* CS3OParser::CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces)
 {
 	LocalS3DOModel *lmodel = SAFE_NEW LocalS3DOModel;
 	lmodel-&gt;numpieces = model-&gt;numobjects;
@@ -141,7 +141,7 @@
 	return lmodel;
 }
 
-void CS3OParser::CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum)
+void CS3OParser::CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum)
 {
 	PUSH_CODE_MODE;
 	ENTER_SYNCED;
@@ -163,10 +163,10 @@
 
 	//Not found? Try again with partial matching
 	if (cur == pieces-&gt;size()) {
-		string &amp;s1 = lmodel-&gt;pieces[*piecenum].name;
+		std::string &amp;s1 = lmodel-&gt;pieces[*piecenum].name;
 		for (cur = 0; cur &lt; pieces-&gt;size(); ++cur) {
-			string &amp;s2 = (*pieces)[cur].name;
-			int maxcompare = min(s1.size(), s2.size());
+			std::string &amp;s2 = (*pieces)[cur].name;
+			int maxcompare = std::min(s1.size(), s2.size());
 			int j;
 			for (j = 0; j &lt; maxcompare; ++j) {
 				if (s1[j] != s2[j]) {
@@ -259,22 +259,22 @@
 
 	std::vector&lt;SS3OVertex&gt;::iterator vi;
 	for(vi=object-&gt;vertices.begin();vi!=object-&gt;vertices.end();++vi){
-		maxx=max(maxx,vi-&gt;pos.x);
-		maxy=max(maxy,vi-&gt;pos.y);
-		maxz=max(maxz,vi-&gt;pos.z);
+		maxx=std::max(maxx,vi-&gt;pos.x);
+		maxy=std::max(maxy,vi-&gt;pos.y);
+		maxz=std::max(maxz,vi-&gt;pos.z);
 
-		minx=min(minx,vi-&gt;pos.x);
-		miny=min(miny,vi-&gt;pos.y);
-		minz=min(minz,vi-&gt;pos.z);
+		minx=std::min(minx,vi-&gt;pos.x);
+		miny=std::min(miny,vi-&gt;pos.y);
+		minz=std::min(minz,vi-&gt;pos.z);
 	}
 	for(si=object-&gt;childs.begin();si!=object-&gt;childs.end();++si){
-		maxx=max(maxx,(*si)-&gt;offset.x+(*si)-&gt;maxx);
-		maxy=max(maxy,(*si)-&gt;offset.y+(*si)-&gt;maxy);
-		maxz=max(maxz,(*si)-&gt;offset.z+(*si)-&gt;maxz);
+		maxx=std::max(maxx,(*si)-&gt;offset.x+(*si)-&gt;maxx);
+		maxy=std::max(maxy,(*si)-&gt;offset.y+(*si)-&gt;maxy);
+		maxz=std::max(maxz,(*si)-&gt;offset.z+(*si)-&gt;maxz);
 
-		minx=min(minx,(*si)-&gt;offset.x+(*si)-&gt;minx);
-		miny=min(miny,(*si)-&gt;offset.y+(*si)-&gt;miny);
-		minz=min(minz,(*si)-&gt;offset.z+(*si)-&gt;minz);
+		minx=std::min(minx,(*si)-&gt;offset.x+(*si)-&gt;minx);
+		miny=std::min(miny,(*si)-&gt;offset.y+(*si)-&gt;miny);
+		minz=std::min(minz,(*si)-&gt;offset.z+(*si)-&gt;minz);
 	}
 	object-&gt;maxx=maxx;
 	object-&gt;maxy=maxy;

Modified: branches/gml/rts/Rendering/UnitModels/s3oParser.h
===================================================================
--- branches/gml/rts/Rendering/UnitModels/s3oParser.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/UnitModels/s3oParser.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -38,8 +38,8 @@
 	CS3OParser();
 	virtual ~CS3OParser();
 
-	S3DOModel* LoadS3O(string name,float scale=1,int side=1);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces);
+	S3DOModel* LoadS3O(std::string name, float scale = 1, int side = 1);
+	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
 
 private:
 	SS3O* LoadPiece(unsigned char* buf, int offset,S3DOModel* model);
@@ -47,9 +47,9 @@
 	void FindMinMax(SS3O *object);
 	void DrawSub(SS3O* o);
 	void CreateLists(SS3O *o);
-	void CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	void CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
 
-	map&lt;string,S3DOModel*&gt; units;
+	std::map&lt;std::string,S3DOModel*&gt; units;
 };
 
 #endif /* S3OPARSER_H */

Modified: branches/gml/rts/Rendering/glFont.cpp
===================================================================
--- branches/gml/rts/Rendering/glFont.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Rendering/glFont.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -14,16 +14,20 @@
 
 using namespace std;
 
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
+/*******************************************************************************/
+/*******************************************************************************/
 
 CglFont *font, *smallFont;
 
+#define GLYPH_MARGIN 3 // margin between glyphs in texture-atlas
+
 class texture_size_exception : public std::exception
 {
 };
 
+/*******************************************************************************/
+/*******************************************************************************/
+
 /**
  * A utility class for CglFont which collects all glyphs of
  * a font into one square luminance/alpha texture.
@@ -82,15 +86,15 @@
 	}
 	outX = curX; outY = curY;
 
-	curX += bmp.width + 1;		// leave one pixel space between each glyph
-	cur += 2*(bmp.width + 1);
+	curX += bmp.width + GLYPH_MARGIN;	// leave one pixel space between each glyph
+	cur  += 2*(bmp.width + GLYPH_MARGIN); 	// 2channels (luminance and alpha))
 	curHeight = max(curHeight, bmp.rows);
 }
 
 void CFontTextureRenderer::BreakLine()
 {
 	curX = 0;
-	curY += curHeight;
+	curY += curHeight + GLYPH_MARGIN;
 	curHeight = 0;
 
 	if (curY &gt;= height)

Modified: branches/gml/rts/Sim/Features/Feature.cpp
===================================================================
--- branches/gml/rts/Sim/Features/Feature.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Features/Feature.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,6 +6,7 @@
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Sim/Misc/DamageArray.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
@@ -52,8 +53,9 @@
 				));
 
 
-CFeature::CFeature()
-:	def(0),
+CFeature::CFeature():
+	def(0),
+	collisionVolume(0),
 	inUpdateQue(false),
 	reclaimLeft(1),
 	fireTime(0),
@@ -70,6 +72,7 @@
 	health(0),
 	id(0),
 	finalHeight(0),
+	reachedFinalPos(false),
 	solidOnTop(0),
 	model(NULL)
 {
@@ -80,21 +83,25 @@
 
 CFeature::~CFeature(void)
 {
-	if(blocking){
+	if (blocking) {
 		UnBlock();
 	}
+
 	qf-&gt;RemoveFeature(this);
-	if(def-&gt;drawType==DRAWTYPE_TREE)
+
+	if (def-&gt;drawType == DRAWTYPE_TREE)
 		treeDrawer-&gt;DeleteTree(pos);
 
-	if(myFire){
+	if (myFire) {
 		myFire-&gt;StopFire();
-		myFire=0;
+		myFire = 0;
 	}
 
 	if (def-&gt;geoThermal) {
 		CGeoThermSmokeProjectile::GeoThermDestroyed(this);
 	}
+
+	delete collisionVolume; collisionVolume = NULL;
 }
 
 void CFeature::PostLoad()
@@ -135,7 +142,7 @@
 
 
 void CFeature::Initialize(const float3&amp; _pos, const FeatureDef* _def, short int _heading,
-                          int facing, int _team, std::string fromUnit)
+	int facing, int _team, std::string fromUnit, const float3&amp; speed)
 {
 	pos = _pos;
 	def = _def;
@@ -162,31 +169,36 @@
 		SetRadius(model-&gt;radius);
 		midPos = pos + model-&gt;relMidPos;
 
+		// copy the FeatureDef volume archetype data
+		collisionVolume = SAFE_NEW CollisionVolume(def-&gt;collisionVolume);
+
 		// CFeatureHandler left this volume's axis-scales uninitialized
-		if (def-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_X) &lt; 0.01f &amp;&amp;
-			def-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Y) &lt; 0.01f &amp;&amp;
-			def-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Z) &lt; 0.01f) {
-			def-&gt;collisionVolume-&gt;SetDefaultScale(model-&gt;radius);
+		// (ie. no &quot;collisionVolumeScales&quot; tag was defined in FeatureDef)
+		if (collisionVolume-&gt;GetScale(COLVOL_AXIS_X) &lt;= 1.0f &amp;&amp;
+			collisionVolume-&gt;GetScale(COLVOL_AXIS_Y) &lt;= 1.0f &amp;&amp;
+			collisionVolume-&gt;GetScale(COLVOL_AXIS_Z) &lt;= 1.0f) {
+			collisionVolume-&gt;SetDefaultScale(model-&gt;radius);
 		}
 	}
 	else if (def-&gt;drawType == DRAWTYPE_TREE) {
 		SetRadius(TREE_RADIUS);
 		midPos = pos + (UpVector * TREE_RADIUS);
 		height = 2 * TREE_RADIUS;
-		def-&gt;collisionVolume-&gt;SetDefaultScale(TREE_RADIUS);
+
+		// copy the FeatureDef volume archetype data
+		collisionVolume = SAFE_NEW CollisionVolume(def-&gt;collisionVolume);
+		collisionVolume-&gt;SetDefaultScale(TREE_RADIUS);
 	}
 	else {
-		// geothermal
+		// geothermal (no collision volume)
 		SetRadius(0.0f);
 		midPos = pos;
 	}
 
 	featureHandler-&gt;AddFeature(this);
-
 	qf-&gt;AddFeature(this);
 
-	CalculateTransform ();
-//	this-&gt;pos.y=ground-&gt;GetHeight(pos.x,pos.z);
+	CalculateTransform();
 
 	if (blocking) {
 		Block();
@@ -201,23 +213,28 @@
 	if (def-&gt;drawType == DRAWTYPE_TREE) {
 		treeDrawer-&gt;AddTree(def-&gt;modelType, pos, 1);
 	}
+
+
+	if (speed != ZeroVector) {
+		deathSpeed = speed;
+	}
 }
 
 
 void CFeature::CalculateTransform()
 {
-	float3 frontDir=GetVectorFromHeading(heading);
+	float3 frontDir = GetVectorFromHeading(heading);
 	float3 upDir;
 
-	if (def-&gt;upright) upDir = float3(0.0f,1.0f,0.0f);
-	else upDir = ground-&gt;GetNormal(pos.x,pos.z);
+	if (def-&gt;upright) upDir = float3(0.0f, 1.0f, 0.0f);
+	else upDir = ground-&gt;GetNormal(pos.x, pos.z);
 
-	float3 rightDir=frontDir.cross(upDir);
+	float3 rightDir = frontDir.cross(upDir);
 	rightDir.Normalize();
-	frontDir=upDir.cross(rightDir);
+	frontDir = upDir.cross(rightDir);
 	frontDir.Normalize ();
 
-	transMatrix = CMatrix44f (pos,-rightDir,upDir,frontDir);
+	transMatrix = CMatrix44f(pos, -rightDir, upDir, frontDir);
 }
 
 
@@ -243,7 +260,7 @@
 		}
 
 		// Work out how much to try to put back, based on the speed this unit would reclaim at.
-		const float part = (100 - amount) * 0.02f / max(10.0f, (def-&gt;metal + def-&gt;energy));
+		const float part = (100 - amount) * 0.02f / std::max(10.0f, (def-&gt;metal + def-&gt;energy));
 
 		// Work out how much that will cost
 		const float metalUse  = part * def-&gt;metal;
@@ -283,7 +300,7 @@
 			return true;
 		}
 
-		const float part = ((100 - amount) * 0.02f / max(10.0f, (def-&gt;reclaimTime)));
+		const float part = ((100 - amount) * 0.02f / std::max(10.0f, (def-&gt;reclaimTime)));
 
 		if (luaRules &amp;&amp; !luaRules-&gt;AllowFeatureBuildStep(builder, this, part)) {
 			return false;
@@ -372,7 +389,7 @@
 
 void CFeature::Kill(float3&amp; impulse) {
 	DamageArray damage;
-	DoDamage(damage*(health+1), 0, impulse);
+	DoDamage(damage * (health + 1), 0, impulse);
 }
 
 
@@ -408,7 +425,7 @@
 	// setup midPos
 	if (def-&gt;drawType == DRAWTYPE_3DO) {
 		midPos = pos + model-&gt;relMidPos;
-	} else if (def-&gt;drawType == DRAWTYPE_TREE){
+	} else if (def-&gt;drawType == DRAWTYPE_TREE) {
 		midPos = pos + (UpVector * TREE_RADIUS);
 	} else {
 		midPos = pos;
@@ -441,70 +458,143 @@
 	tmp.Translate(pos);
 	transMatrix = tmp;
 
-//	const float clamped = fmod(newDir.y, PI * 2.0);
-//	heading = (short int)(clamped * 65536);
+	// const float clamped = fmod(newDir.y, PI * 2.0);
+	// heading = (short int)(clamped * 65536);
 }
 
 
-bool CFeature::Update(void)
+bool CFeature::UpdatePosition()
 {
-	bool retValue=false;
+	if (createdFromUnit.size() &gt; 0) {
+		// we are a wreck of a dead unit
+		if (!reachedFinalPos) {
+			bool haveForwardSpeed = false;
+			bool haveVerticalSpeed = false;
+			bool inBounds = false;
 
-	if(pos.y&gt;finalHeight){
-		const float3 oldPos = pos;
-		if(pos.y&gt;0){	//fall faster when above water
-			pos.y-=0.8f;
-			midPos.y-=0.8f;
-			transMatrix[13]-=0.8f;
-		} else {
-			pos.y-=0.4f;
-			midPos.y-=0.4f;
-			transMatrix[13]-=0.4f;
+			if (deathSpeed.SqLength2D() &gt; 0.01f) {
+				UnBlock();
+				qf-&gt;RemoveFeature(this);
+
+				// update our forward speed (and quadfield
+				// position) if it's still greater than 0
+				pos += deathSpeed;
+				midPos += deathSpeed;
+				deathSpeed *= 0.95f;
+
+				haveForwardSpeed = true;
+
+				qf-&gt;AddFeature(this);
+				Block();
+			}
+
+			// def-&gt;floating is unreliable (true for land unit wrecks),
+			// just assume wrecks always sink even if their &quot;owner&quot; was
+			// a floating object (as is the case for ships anyway)
+			float realGroundHeight = ground-&gt;GetHeight2(pos.x, pos.z);
+			bool reachedGround = (pos.y &lt;= realGroundHeight);
+
+			if (!reachedGround) {
+				if (pos.y &gt; 0.0f) {
+					// quadratic acceleration if not in water
+					deathSpeed.y += mapInfo-&gt;map.gravity * 0.25f;
+				} else {
+					// constant downward speed otherwise
+					deathSpeed.y = mapInfo-&gt;map.gravity;
+				}
+
+				pos.y += deathSpeed.y;
+				midPos.y += deathSpeed.y;
+				haveVerticalSpeed = true;
+			} else {
+				// last Update() may have sunk us into
+				// ground if pos.y was only marginally
+				// larger than ground height, correct
+				pos.y = realGroundHeight;
+				midPos.y = pos.y + model-&gt;relMidPos.y;
+			}
+
+			inBounds = pos.CheckInBounds();
+			reachedFinalPos = (!haveForwardSpeed &amp;&amp; !haveVerticalSpeed);
+			// reachedFinalPos = ((!haveForwardSpeed &amp;&amp; !haveVerticalSpeed) || !inBounds);
+
+			if (!inBounds) {
+				// ensure that no more forward-speed updates are done
+				// (prevents wrecks floating in mid-air at edge of map
+				// due to gravity no longer being applied either)
+				deathSpeed = ZeroVector;
+			}
+
+			featureHandler-&gt;UpdateDrawQuad(this, pos);
+			CalculateTransform();
 		}
-//		logOutput.Print(&quot;feature sinking&quot;);
-		if (def-&gt;drawType == DRAWTYPE_TREE) {
-			treeDrawer-&gt;DeleteTree(oldPos);
-			treeDrawer-&gt;AddTree(def-&gt;modelType, pos, 1.0f);
+	} else {
+		if (pos.y &gt; finalHeight) {
+			const float3 oldPos = pos;
+
+			if (pos.y &gt; 0) {
+				// fall faster when above water
+				pos.y -= 0.8f;
+				midPos.y -= 0.8f;
+				transMatrix[13] -= 0.8f;
+			} else {
+				pos.y -= 0.4f;
+				midPos.y -= 0.4f;
+				transMatrix[13] -= 0.4f;
+			}
+
+			if (def-&gt;drawType == DRAWTYPE_TREE) {
+				treeDrawer-&gt;DeleteTree(oldPos);
+				treeDrawer-&gt;AddTree(def-&gt;modelType, pos, 1.0f);
+			}
 		}
-		retValue=true;
 	}
-	if(emitSmokeTime!=0){
+
+	return true;
+}
+
+bool CFeature::Update(void)
+{
+	bool retValue = UpdatePosition();
+
+	if (emitSmokeTime != 0) {
 		--emitSmokeTime;
 		PUSH_CODE_MODE;
 		ENTER_MIXED;
-		if(!(gs-&gt;frameNum+id &amp; 3) &amp;&amp; ph-&gt;particleSaturation&lt;0.7f){
-			SAFE_NEW CSmokeProjectile(midPos+gu-&gt;usRandVector()*radius*0.3f,gu-&gt;usRandVector()*0.3f+UpVector,emitSmokeTime/6+20,6,0.4f,0,0.5f);
+		if (!(gs-&gt;frameNum + id &amp; 3) &amp;&amp; ph-&gt;particleSaturation &lt; 0.7f) {
+			SAFE_NEW CSmokeProjectile(midPos + gu-&gt;usRandVector() * radius * 0.3f,
+				gu-&gt;usRandVector() * 0.3f + UpVector, emitSmokeTime / 6 + 20, 6, 0.4f, 0, 0.5f);
 		}
 		POP_CODE_MODE;
-		retValue=true;
+		retValue = true;
 	}
 
-	if(fireTime&gt;0){
+	if (fireTime &gt; 0) {
 		fireTime--;
-		if(fireTime==1)
+		if (fireTime == 1)
 			featureHandler-&gt;DeleteFeature(this);
-		retValue=true;
+		retValue = true;
 	}
 
-	if(def-&gt;geoThermal){
+	if (def-&gt;geoThermal) {
 		PUSH_CODE_MODE;
 		ENTER_MIXED;
 
-		if ((gs-&gt;frameNum+id % 5) % 5 == 0)
-		{
+		if ((gs-&gt;frameNum + id % 5) % 5 == 0) {
 			// Find the unit closest to the geothermal
 			vector&lt;CSolidObject*&gt; objs = qf-&gt;GetSolidsExact(pos, 0.0f);
 			float bestDist2 = 0;
-			CSolidObject *so = NULL;
-			for (vector&lt;CSolidObject*&gt;::iterator oi=objs.begin();oi!=objs.end();++oi) {
-				float dist2 = ((*oi)-&gt;pos-pos).SqLength();
+			CSolidObject* so = NULL;
+
+			for (vector&lt;CSolidObject*&gt;::iterator oi = objs.begin(); oi != objs.end(); ++oi) {
+				float dist2 = ((*oi)-&gt;pos - pos).SqLength();
 				if (!so || dist2 &lt; bestDist2)  {
 					bestDist2 = dist2;
 					so = *oi;
 				}
 			}
 
-			if (so!=solidOnTop) {
+			if (so != solidOnTop) {
 				if (solidOnTop)
 					DeleteDeathDependence(solidOnTop);
 				if (so)
@@ -516,22 +606,19 @@
 		// Hide the smoke if there is a geothermal unit on the vent
 		CUnit *u = dynamic_cast&lt;CUnit*&gt;(solidOnTop);
 		if (!u || !u-&gt;unitDef-&gt;needGeo) {
-			if((ph-&gt;particleSaturation&lt;0.7f) || (ph-&gt;particleSaturation&lt;1 &amp;&amp; !(gs-&gt;frameNum&amp;3))){
-				float3 speed=gu-&gt;usRandVector()*0.5f;
-				speed.y+=2.0f;
+			if ((ph-&gt;particleSaturation &lt; 0.7f) || (ph-&gt;particleSaturation &lt; 1 &amp;&amp; !(gs-&gt;frameNum &amp; 3))) {
+				float3 speed = gu-&gt;usRandVector() * 0.5f;
+				speed.y += 2.0f;
 
 				SAFE_NEW CGeoThermSmokeProjectile(gu-&gt;usRandVector() * 10 +
-				                                  float3(pos.x, pos.y-10, pos.z),
-				                                  speed, int(50+gu-&gt;usRandFloat()*7),
-				                                  this);
+					float3(pos.x, pos.y-10, pos.z), speed, int(50 + gu-&gt;usRandFloat() * 7), this);
 			}
 		}
 
 		POP_CODE_MODE;
-		retValue=true;
+		retValue = true;
 	}
 
-
 	return retValue;
 }
 
@@ -582,3 +669,10 @@
 {
 	return RemainingResource(def-&gt;energy);
 }
+
+
+
+void CFeature::DrawS3O()
+{
+	unitDrawer-&gt;DrawFeatureS3O(this);
+}


Property changes on: branches/gml/rts/Sim/Features/Feature.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Sim/Features/Feature.h
===================================================================
--- branches/gml/rts/Sim/Features/Feature.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Features/Feature.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -15,8 +15,9 @@
 class CUnit;
 struct DamageArray;
 class CFireProjectile;
+struct CollisionVolume;
 
-class CFeature : public CSolidObject, public boost::noncopyable
+class CFeature: public CSolidObject, public boost::noncopyable
 {
 	CR_DECLARE(CFeature);
 
@@ -25,7 +26,9 @@
 	~CFeature();
 
 	/** Pos of quad must not change after this. */
-	void Initialize(const float3&amp; pos, const FeatureDef* def, short int heading, int facing, int allyteam, std::string fromUnit);
+	void Initialize(const float3&amp; pos, const FeatureDef* def, short int heading, int facing,
+		int allyteam, std::string fromUnit, const float3&amp; speed = ZeroVector);
+
 	/** Negative amount = reclaim
 	    @return true if reclaimed */
 	bool AddBuildPower(float amount, CUnit* builder);
@@ -34,6 +37,7 @@
 	void ForcedMove(const float3&amp; newPos);
 	void ForcedSpin(const float3&amp; newDir);
 	virtual bool Update(void);
+	bool UpdatePosition(void);
 	void StartFire(void);
 	float RemainingResource(float res) const;
 	float RemainingMetal(void) const;
@@ -43,6 +47,9 @@
 	void DependentDied(CObject *o);
 	void ChangeTeam(int newTeam);
 
+	// should not be here
+	void DrawS3O();
+
 	S3DOModel* model;
 
 	std::string createdFromUnit;
@@ -66,23 +73,27 @@
 
 	const FeatureDef* def;
 	std::string defName;
+	CollisionVolume* collisionVolume;
 
 	CMatrix44f transMatrix;
-//	float3 residualImpulse;	//impulse energy that havent been acted on
 
 	bool inUpdateQue;
 	/// which drawQuad we are part of
 	int drawQuad;
 
 	float finalHeight;
+	bool reachedFinalPos;
 
 	CFireProjectile* myFire;
 	int fireTime;
 	int emitSmokeTime;
 
 	/// the solid object that is on top of the geothermal
-	CSolidObject *solidOnTop;
+	CSolidObject* solidOnTop;
 
+	// initially a copy of CUnit::speed
+	float3 deathSpeed;
+
 private:
 	void PostLoad();
 };


Property changes on: branches/gml/rts/Sim/Features/Feature.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Sim/Features/FeatureDef.h
===================================================================
--- branches/gml/rts/Sim/Features/FeatureDef.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Features/FeatureDef.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,7 +6,7 @@
 #define DRAWTYPE_NONE -1
 
 struct S3DOModel;
-class CCollisionVolume;
+struct CollisionVolume;
 
 struct FeatureDef
 {
@@ -20,7 +20,7 @@
 		xsize(0), ysize(0), reclaimTime(0) {}
 
 	S3DOModel* LoadModel(int team) const;
-	CCollisionVolume* collisionVolume;
+	CollisionVolume* collisionVolume;
 
 	std::string myName;
 	std::string description;


Property changes on: branches/gml/rts/Sim/Features/FeatureDef.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Features/FeatureHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Features/FeatureHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,6 +12,7 @@
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/Env/BaseTreeDrawer.h&quot;
 #include &quot;Rendering/Env/BaseWater.h&quot;
@@ -129,6 +130,7 @@
 	for (CFeatureSet::iterator fi = activeFeatures.begin(); fi != activeFeatures.end(); ++fi) {
 		// unsavory, but better than a memleak
 		FeatureDef* fd = (FeatureDef*) (*fi)-&gt;def;
+
 		if (fd-&gt;collisionVolume) {
 			delete fd-&gt;collisionVolume;
 			fd-&gt;collisionVolume = 0;
@@ -143,6 +145,7 @@
 		std::map&lt;std::string, const FeatureDef*&gt;::iterator fi = featureDefs.begin();
 
 		FeatureDef* fd = (FeatureDef*) fi-&gt;second;
+
 		if (fd-&gt;collisionVolume) {
 			delete fd-&gt;collisionVolume;
 			fd-&gt;collisionVolume = 0;
@@ -243,8 +246,9 @@
 	fd-&gt;collisionVolumeOffsets = fdTable.GetFloat3(&quot;collisionVolumeOffsets&quot;, ZeroVector);
 	fd-&gt;collisionVolumeTest = fdTable.GetInt(&quot;collisionVolumeTest&quot;, COLVOL_TEST_CONT);
 
-	// initialize the (per-featuredef) collision-volume
-	fd-&gt;collisionVolume = SAFE_NEW CCollisionVolume(fd-&gt;collisionVolumeType,
+	// initialize the (per-featuredef) collision-volume,
+	// all CFeature instances hold a copy of this object
+	fd-&gt;collisionVolume = SAFE_NEW CollisionVolume(fd-&gt;collisionVolumeType,
 		fd-&gt;collisionVolumeScales, fd-&gt;collisionVolumeOffsets, fd-&gt;collisionVolumeTest);
 
 
@@ -316,8 +320,8 @@
 			fd-&gt;myName = name;
 			fd-&gt;description = &quot;Tree&quot;;
 			fd-&gt;mass = 20;
-			// trees by default have spheres of fixed radius (TREE_RADIUS)
-			fd-&gt;collisionVolume = SAFE_NEW CCollisionVolume(&quot;&quot;, ZeroVector, ZeroVector, COLVOL_TEST_DISC);
+			// trees by default have spherical collision volumes of fixed radius &lt;TREE_RADIUS&gt;
+			fd-&gt;collisionVolume = SAFE_NEW CollisionVolume(&quot;&quot;, ZeroVector, ZeroVector, COLVOL_TEST_DISC);
 			AddFeatureDef(name, fd);
 		}
 		else if (name.find(&quot;geovent&quot;) != string::npos) {
@@ -386,12 +390,12 @@
 	activeFeatures.insert(feature);
 	SetFeatureUpdateable(feature);
 
-	if(feature-&gt;def-&gt;drawType==DRAWTYPE_3DO){
+	if (feature-&gt;def-&gt;drawType == DRAWTYPE_3DO) {
 		int quad = int(feature-&gt;pos.z / DRAW_QUAD_SIZE / SQUARE_SIZE) * drawQuadsX +
-		           int(feature-&gt;pos.x / DRAW_QUAD_SIZE / SQUARE_SIZE);
-		DrawQuad* dq=&amp;drawQuads[quad];
+				   int(feature-&gt;pos.x / DRAW_QUAD_SIZE / SQUARE_SIZE);
+		DrawQuad* dq = &amp;drawQuads[quad];
 		dq-&gt;features.insert(feature);
-		feature-&gt;drawQuad=quad;
+		feature-&gt;drawQuad = quad;
 	}
 
 	luaCallIns.FeatureCreated(feature);
@@ -410,8 +414,8 @@
 
 
 CFeature* CFeatureHandler::CreateWreckage(const float3&amp; pos, const std::string&amp; name,
-                                          float rot, int facing, int iter, int team,
-                                          int allyteam, bool emitSmoke,std::string fromUnit)
+	float rot, int facing, int iter, int team, int allyteam, bool emitSmoke, std::string fromUnit,
+	const float3&amp; speed)
 {
 	ASSERT_SYNCED_MODE;
 	if (name.empty()) {
@@ -424,19 +428,19 @@
 	}
 
 	if (iter &gt; 1) {
-		return CreateWreckage(pos, fd-&gt;deathFeature, rot, facing, iter - 1, team, allyteam, emitSmoke, &quot;&quot;);
+		return CreateWreckage(pos, fd-&gt;deathFeature, rot, facing, iter - 1, team, allyteam, emitSmoke, &quot;&quot;, speed);
 	}
 	else {
 		if (luaRules &amp;&amp; !luaRules-&gt;AllowFeatureCreation(fd, team, pos)) {
 			return NULL;
 		}
-		if(!fd-&gt;modelname.empty()){
-			CFeature* f=SAFE_NEW CFeature;
-			f-&gt;Initialize (pos, fd, (short int)rot, facing, team, fromUnit);
+		if (!fd-&gt;modelname.empty()) {
+			CFeature* f = SAFE_NEW CFeature;
+			f-&gt;Initialize(pos, fd, (short int) rot, facing, team, fromUnit, speed);
 			// allow area-reclaiming wrecks of all units, including your own (they set allyteam = -1)
 			f-&gt;allyteam = allyteam;
-			if(emitSmoke &amp;&amp; f-&gt;blocking)
-				f-&gt;emitSmokeTime=300;
+			if (emitSmoke &amp;&amp; f-&gt;blocking)
+				f-&gt;emitSmokeTime = 300;
 			return f;
 		}
 	}
@@ -450,9 +454,10 @@
 	ASSERT_SYNCED_MODE;
 	SCOPED_TIMER(&quot;Feature::Update&quot;);
 
-	if ((gs-&gt;frameNum &amp; 31) == 0) {	// let all areareclaimers choose a target with a different id
+	if ((gs-&gt;frameNum &amp; 31) == 0) {
+		// let all areareclaimers choose a target with a different id
 		bool dontClear = false;
-		for (list&lt;int&gt;::iterator it = toBeFreedIDs.begin(); it != toBeFreedIDs.end(); ++it) {
+		for (std::list&lt;int&gt;::iterator it = toBeFreedIDs.begin(); it != toBeFreedIDs.end(); ++it) {
 			if (CBuilderCAI::IsFeatureBeingReclaimed(*it)) {
 				// postpone recycling
 				dontClear = true;
@@ -484,7 +489,7 @@
 		}
 	}
 
-	CFeatureSet::iterator fi=updateFeatures.begin();
+	CFeatureSet::iterator fi = updateFeatures.begin();
 	while (fi != updateFeatures.end()) {
 		CFeature* feature = *fi;
 		++fi;
@@ -529,14 +534,14 @@
 void CFeatureHandler::TerrainChanged(int x1, int y1, int x2, int y2)
 {
 	ASSERT_SYNCED_MODE;
-	vector&lt;int&gt; quads=qf-&gt;GetQuadsRectangle(float3(x1*SQUARE_SIZE,0,y1*SQUARE_SIZE),
-	                                        float3(x2*SQUARE_SIZE,0,y2*SQUARE_SIZE));
-//	logOutput.Print(&quot;Checking feature pos %i&quot;,quads.size());
+	std::vector&lt;int&gt; quads = qf-&gt;GetQuadsRectangle(float3(x1 * SQUARE_SIZE, 0, y1 * SQUARE_SIZE),
+		float3(x2 * SQUARE_SIZE, 0, y2 * SQUARE_SIZE));
 
-	for(vector&lt;int&gt;::iterator qi=quads.begin();qi!=quads.end();++qi){
-		list&lt;CFeature*&gt;::const_iterator fi;
+	for (std::vector&lt;int&gt;::iterator qi = quads.begin(); qi != quads.end(); ++qi) {
+		std::list&lt;CFeature*&gt;::const_iterator fi;
 		const list&lt;CFeature*&gt;&amp; features = qf-&gt;GetQuad(*qi).features;
-		for(fi = features.begin(); fi != features.end(); ++fi) {
+
+		for (fi = features.begin(); fi != features.end(); ++fi) {
 			CFeature* feature = *fi;
 			float3&amp; fpos = feature-&gt;pos;
 			if (fpos.y &gt; ground-&gt;GetHeight(fpos.x, fpos.z)) {
@@ -562,19 +567,19 @@
 
 	unitDrawer-&gt;SetupForUnitDrawing();
 	DrawRaw(0, &amp;drawFar);
+
 	unitDrawer-&gt;CleanUpUnitDrawing();
-
 	unitDrawer-&gt;DrawQuedS3O();
 
-	CVertexArray* va=GetVertexArray();
+	CVertexArray* va = GetVertexArray();
 	va-&gt;Initialize();
 	glAlphaFunc(GL_GREATER, 0.8f);
 	glEnable(GL_ALPHA_TEST);
 	glBindTexture(GL_TEXTURE_2D, fartextureHandler-&gt;GetTextureID());
 	glColor3f(1.0f, 1.0f, 1.0f);
 	glEnable(GL_FOG);
-	for(vector&lt;CFeature*&gt;::iterator usi=drawFar.begin();usi!=drawFar.end();usi++){
-		DrawFar(*usi,va);
+	for (vector&lt;CFeature*&gt;::iterator usi = drawFar.begin(); usi != drawFar.end(); usi++) {
+		DrawFar(*usi, va);
 	}
 	va-&gt;DrawArrayTN(GL_QUADS);
 }
@@ -601,11 +606,10 @@
 class CFeatureDrawer : public CReadMap::IQuadDrawer
 {
 public:
-	void DrawQuad (int x,int y);
+	void DrawQuad(int x,int y);
 
-	CFeatureHandler *fh;
-//	CFeatureHandler::DrawQuad *drawQuads;
-	std::vector&lt;CFeatureHandler::DrawQuad&gt; *drawQuads;
+	CFeatureHandler* fh;
+	std::vector&lt;CFeatureHandler::DrawQuad&gt;* drawQuads;
 	int drawQuadsX;
 	bool drawReflection, drawRefraction;
 	float unitDrawDist;
@@ -613,26 +617,26 @@
 };
 
 
-void CFeatureDrawer::DrawQuad (int x,int y)
+void CFeatureDrawer::DrawQuad(int x, int y)
 {
-	CFeatureHandler::DrawQuad* dq=&amp;(*drawQuads)[y*drawQuadsX+x];
+	CFeatureHandler::DrawQuad* dq = &amp;(*drawQuads)[y * drawQuadsX + x];
 
 	for (CFeatureSet::iterator fi = dq-&gt;features.begin(); fi != dq-&gt;features.end(); ++fi) {
 		CFeature* f = (*fi);
 		const FeatureDef* def = f-&gt;def;
 
-		if((f-&gt;allyteam==-1 || f-&gt;allyteam==gu-&gt;myAllyTeam ||
-		    loshandler-&gt;InLos(f-&gt;pos,gu-&gt;myAllyTeam) || gu-&gt;spectatingFullView)
-		   &amp;&amp; def-&gt;drawType==DRAWTYPE_3DO){
-			if(drawReflection){
+		if ((f-&gt;allyteam == -1 || f-&gt;allyteam == gu-&gt;myAllyTeam || gu-&gt;spectatingFullView ||
+			loshandler-&gt;InLos(f-&gt;pos, gu-&gt;myAllyTeam)) &amp;&amp; def-&gt;drawType == DRAWTYPE_3DO) {
+
+			if (drawReflection) {
 				float3 zeroPos;
-				if(f-&gt;midPos.y&lt;0){
-					zeroPos=f-&gt;midPos;
-				}else{
-					float dif=f-&gt;midPos.y-camera-&gt;pos.y;
-					zeroPos=camera-&gt;pos*(f-&gt;midPos.y/dif) + f-&gt;midPos*(-camera-&gt;pos.y/dif);
+				if (f-&gt;midPos.y &lt; 0) {
+					zeroPos = f-&gt;midPos;
+				} else {
+					float dif = f-&gt;midPos.y - camera-&gt;pos.y;
+					zeroPos = camera-&gt;pos * (f-&gt;midPos.y / dif) + f-&gt;midPos * (-camera-&gt;pos.y / dif);
 				}
-				if(ground-&gt;GetApproximateHeight(zeroPos.x,zeroPos.z)&gt;f-&gt;radius){
+				if (ground-&gt;GetApproximateHeight(zeroPos.x, zeroPos.z) &gt; f-&gt;radius) {
 					continue;
 				}
 			}
@@ -641,7 +645,7 @@
 					continue;
 			}
 
-			float sqDist = (f-&gt;pos-camera-&gt;pos).SqLength2D();
+			float sqDist = (f-&gt;pos - camera-&gt;pos).SqLength2D();
 			float farLength = f-&gt;sqRadius * unitDrawDist * unitDrawDist;
 
 			if (sqDist&lt;farLength) {
@@ -661,9 +665,9 @@
 
 void CFeatureHandler::DrawRaw(int extraSize, std::vector&lt;CFeature*&gt;* farFeatures)
 {
-	float featureDist=3000;
+	float featureDist = 3000;
 	if (!extraSize) {
-		featureDist=6000; //farfeatures wont be drawn for shadowpass anyway
+		featureDist = 6000; //farfeatures wont be drawn for shadowpass anyway
 	}
 	CFeatureDrawer drawer;
 	drawer.drawQuads = &drawQuads;


Property changes on: branches/gml/rts/Sim/Features/FeatureHandler.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Sim/Features/FeatureHandler.h
===================================================================
--- branches/gml/rts/Sim/Features/FeatureHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Features/FeatureHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -28,8 +28,8 @@
 	~CFeatureHandler();
 
 	CFeature* CreateWreckage(const float3&amp; pos, const std::string&amp; name,
-	                         float rot, int facing, int iter, int team, int allyteam,
-	                         bool emitSmoke, std::string fromUnit);
+		float rot, int facing, int iter, int team, int allyteam, bool emitSmoke,
+		std::string fromUnit, const float3&amp; speed = ZeroVector);
 
 	void Update();
 
@@ -53,7 +53,7 @@
 
 private:
 	void AddFeatureDef(const std::string&amp; name, FeatureDef* feature);
-	const FeatureDef* CreateFeatureDef(const LuaTable&amp; luaTable, const string&amp; name);	
+	const FeatureDef* CreateFeatureDef(const LuaTable&amp; luaTable, const std::string&amp; name);
 
 private:
 	std::map&lt;std::string, const FeatureDef*&gt; featureDefs;


Property changes on: branches/gml/rts/Sim/Features/FeatureHandler.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Sim/Features/FeatureSet.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/Sim/Features/FeatureSet.h
___________________________________________________________________
Name: svn:eol-style
   + native

Copied: branches/gml/rts/Sim/Misc/CollisionHandler.cpp (from rev 5882, trunk/rts/Sim/Misc/CollisionHandler.cpp)
===================================================================
--- branches/gml/rts/Sim/Misc/CollisionHandler.cpp	                        (rev 0)
+++ branches/gml/rts/Sim/Misc/CollisionHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,612 @@
+#include &lt;iostream&gt;
+
+#include &quot;System/FastMath.h&quot;
+#include &quot;System/float3.h&quot;
+#include &quot;System/Matrix44f.h&quot;
+
+#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sim/Features/Feature.h&quot;
+
+#include &quot;CollisionHandler.h&quot;
+#include &quot;CollisionVolume.h&quot;
+
+#define ZVec ZeroVector
+
+CR_BIND(CCollisionHandler, );
+CR_BIND(CollisionVolume, );
+	CR_REG_METADATA(CollisionVolume, (
+		CR_MEMBER(axisScales),
+		CR_MEMBER(axisHScales),
+		CR_MEMBER(axisHScalesSq),
+		CR_MEMBER(axisHIScales),
+		CR_MEMBER(axisOffsets),
+		CR_MEMBER(volumeBoundingRadius),
+		CR_MEMBER(volumeBoundingRadiusSq),
+		CR_MEMBER(volumeType),
+		CR_MEMBER(testType),
+		CR_MEMBER(primaryAxis),
+		CR_MEMBER(secondaryAxes),
+		CR_MEMBER(spherical)
+	));
+
+unsigned int CCollisionHandler::numCollisionTests = 0;
+unsigned int CCollisionHandler::numIntersectionTests = 0;
+
+
+
+bool CCollisionHandler::DetectHit(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	bool r = false;
+
+	switch (u-&gt;collisionVolume-&gt;testType) {
+		// Collision(CUnit*) does not need p1 or q
+		case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(u, p0       ); numCollisionTests    += 1; } break;
+		case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(u, p0, p1, q); numIntersectionTests += 1; } break;
+	}
+
+	return r;
+}
+
+bool CCollisionHandler::DetectHit(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	bool r = false;
+
+	switch (f-&gt;collisionVolume-&gt;testType) {
+		// Collision(CFeature*) does not need p1 or q
+		case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(f, p0       ); numCollisionTests    += 1; } break;
+		case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(f, p0, p1, q); numIntersectionTests += 1; } break;
+	}
+
+	return r;
+}
+
+
+
+
+
+
+bool CCollisionHandler::Collision(const CUnit* u, const float3&amp; p)
+{
+	const CollisionVolume* v = u-&gt;collisionVolume;
+
+	if ((u-&gt;midPos - p).SqLength() &gt; v-&gt;volumeBoundingRadiusSq) {
+		return false;
+	} else {
+		if (v-&gt;spherical) {
+			return true;
+		} else {
+			// NOTE: we have to translate by relMidPos (which is where
+			// collision volume gets drawn) since GetTransformMatrix()
+			// does not
+			CMatrix44f m;
+			u-&gt;GetTransformMatrix(m, true);
+			m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
+			m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
+
+			return CCollisionHandler::Collision(v, m, p);
+		}
+	}
+}
+
+bool CCollisionHandler::Collision(const CFeature* f, const float3&amp; p)
+{
+	const CollisionVolume* v = f-&gt;collisionVolume;
+
+	if ((f-&gt;midPos - p).SqLength() &gt; v-&gt;volumeBoundingRadiusSq) {
+		return false;
+	} else {
+		if (v-&gt;spherical) {
+			return true;
+		} else {
+			// NOTE: CFeature does not have a relMidPos member
+			CMatrix44f m(f-&gt;transMatrix);
+			m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
+
+			return CCollisionHandler::Collision(v, m, p);
+		}
+	}
+}
+
+
+
+// test if point &lt;p&gt; (in world-coors) lies inside the
+// volume whose transformation matrix is given by &lt;m&gt;
+bool CCollisionHandler::Collision(const CollisionVolume* v, const CMatrix44f&amp; m, const float3&amp; p)
+{
+	// get the inverse volume transformation matrix and
+	// apply it to the projectile's position, then test
+	// if the transformed position lies within the axis-
+	// aligned collision volume
+	CMatrix44f mInv = m.Invert();
+	float3 pi = mInv.Mul(p);
+	bool hit = false;
+
+	switch (v-&gt;volumeType) {
+		case COLVOL_TYPE_ELLIPSOID: {
+			if (v-&gt;spherical) {
+				hit = (pi.dot(pi) &lt;= v-&gt;axisHScalesSq.x);
+			} else {
+				const float f1 = (pi.x * pi.x) / v-&gt;axisHScalesSq.x;
+				const float f2 = (pi.y * pi.y) / v-&gt;axisHScalesSq.y;
+				const float f3 = (pi.z * pi.z) / v-&gt;axisHScalesSq.z;
+				hit = ((f1 + f2 + f3) &lt;= 1.0f);
+			}
+		} break;
+		case COLVOL_TYPE_CYLINDER: {
+			switch (v-&gt;primaryAxis) {
+				case COLVOL_AXIS_X: {
+					const bool xPass = (pi.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi.x &lt; v-&gt;axisHScales.x);
+					const float yRat = (pi.y * pi.y) / v-&gt;axisHScalesSq.y;
+					const float zRat = (pi.z * pi.z) / v-&gt;axisHScalesSq.z;
+					hit = (xPass &amp;&amp; (yRat + zRat &lt;= 1.0f));
+				} break;
+				case COLVOL_AXIS_Y: {
+					const bool yPass = (pi.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi.y &lt; v-&gt;axisHScales.y);
+					const float xRat = (pi.x * pi.x) / v-&gt;axisHScalesSq.x;
+					const float zRat = (pi.z * pi.z) / v-&gt;axisHScalesSq.z;
+					hit = (yPass &amp;&amp; (xRat + zRat &lt;= 1.0f));
+				} break;
+				case COLVOL_AXIS_Z: {
+					const bool zPass = (pi.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi.z &lt; v-&gt;axisHScales.z);
+					const float xRat = (pi.x * pi.x) / v-&gt;axisHScalesSq.x;
+					const float yRat = (pi.y * pi.y) / v-&gt;axisHScalesSq.y;
+					hit = (zPass &amp;&amp; (xRat + yRat &lt;= 1.0f));
+				} break;
+			}
+		} break;
+		case COLVOL_TYPE_BOX: {
+			const bool b1 = (pi.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi.x &lt; v-&gt;axisHScales.x);
+			const bool b2 = (pi.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi.y &lt; v-&gt;axisHScales.y);
+			const bool b3 = (pi.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi.z &lt; v-&gt;axisHScales.z);
+			hit = (b1 &amp;&amp; b2 &amp;&amp; b3);
+		} break;
+	}
+
+	return hit;
+}
+
+
+
+
+
+
+bool CCollisionHandler::Intersect(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	const CollisionVolume* v = u-&gt;collisionVolume;
+
+	CMatrix44f m;
+	u-&gt;GetTransformMatrix(m, true);
+	m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
+	m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
+
+	return CCollisionHandler::Intersect(v, m, p0, p1, q);
+}
+
+bool CCollisionHandler::Intersect(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	const CollisionVolume* v = f-&gt;collisionVolume;
+
+	CMatrix44f m(f-&gt;transMatrix);
+	m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
+
+	return CCollisionHandler::Intersect(v, m, p0, p1, q);
+}
+
+/*
+bool CCollisionHandler::IntersectAlt(const collisionVolume* d, const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery*)
+{
+	// alternative numerical integration method (unused)
+	const float delta = 1.0f;
+	const float length = (p1 - p0).Length();
+	const float3 dir = (p1 - p0).Normalize();
+
+	for (float t = 0.0f; t &lt;= length; t += delta) {
+		if (::Collision(d, m, p0 + dir * t)) return true;
+	}
+
+	return false;
+}
+*/
+
+
+
+// test if ray from &lt;p0&gt; to &lt;p1&gt; (in world-coors) intersects
+// the volume whose transformation matrix is given by &lt;m&gt;
+bool CCollisionHandler::Intersect(const CollisionVolume* v, const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	CMatrix44f mInv = m.Invert();
+	const float3 pi0 = mInv.Mul(p0);
+	const float3 pi1 = mInv.Mul(p1);
+	bool intersect = false;
+
+	// minimum and maximum (x, y, z) coordinates of transformed ray
+	const float rminx = MIN(pi0.x, pi1.x), rminy = MIN(pi0.y, pi1.y), rminz = MIN(pi0.z, pi1.z);
+	const float rmaxx = MAX(pi0.x, pi1.x), rmaxy = MAX(pi0.y, pi1.y), rmaxz = MAX(pi0.z, pi1.z);
+
+	// minimum and maximum (x, y, z) coordinates of (bounding box around) volume
+	const float vminx = -v-&gt;axisHScales.x, vminy = -v-&gt;axisHScales.y, vminz = -v-&gt;axisHScales.z;
+	const float vmaxx =  v-&gt;axisHScales.x, vmaxy =  v-&gt;axisHScales.y, vmaxz =  v-&gt;axisHScales.z;
+
+	// check if ray segment misses (bounding box around) volume
+	// (if so, then no further intersection tests are necessary)
+	if (rmaxx &lt; vminx || rminx &gt; vmaxx) { return false; }
+	if (rmaxy &lt; vminy || rminy &gt; vmaxy) { return false; }
+	if (rmaxz &lt; vminz || rminz &gt; vmaxz) { return false; }
+
+	switch (v-&gt;volumeType) {
+		case COLVOL_TYPE_ELLIPSOID: {
+			intersect = CCollisionHandler::IntersectEllipsoid(v, pi0, pi1, q);
+		} break;
+		case COLVOL_TYPE_CYLINDER: {
+			intersect = CCollisionHandler::IntersectCylinder(v, pi0, pi1, q);
+		} break;
+		case COLVOL_TYPE_BOX: {
+			intersect = CCollisionHandler::IntersectBox(v, pi0, pi1, q);
+		} break;
+	}
+
+	return intersect;
+}
+
+bool CCollisionHandler::IntersectEllipsoid(const CollisionVolume* v, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+{
+	// transform the volume-space points into (unit) sphere-space (requires fewer
+	// float-ops than solving the surface equation for arbitrary ellipsoid volumes)
+	const float3 pii0 = float3(pi0.x * v-&gt;axisHIScales.x, pi0.y * v-&gt;axisHIScales.y, pi0.z * v-&gt;axisHIScales.z);
+	const float3 pii1 = float3(pi1.x * v-&gt;axisHIScales.x, pi1.y * v-&gt;axisHIScales.y, pi1.z * v-&gt;axisHIScales.z);
+	const float rSq = 1.0f;
+
+	if (pii0.dot(pii0) &lt;= rSq /* &amp;&amp; pii1.dot(pii1) &lt;= rSq */) {
+		// terminate early in the special case
+		// that shot originated within volume
+		if (q) {
+			q-&gt;b0 = true; q-&gt;b1 = true;
+			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
+			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
+		}
+		return true;
+	}
+
+	// get the ray direction in unit-sphere space
+	const float3 dir = (pii1 - pii0).Normalize();
+
+	// solves [ x^2 + y^2 + z^2 == r^2 ] for t
+	// (&lt;A&gt; represents dir.dot(dir), equal to 1
+	// since ray direction already normalized)
+	const float A = 1.0f;
+	const float B = (pii0 * 2.0f).dot(dir);
+	const float C = pii0.dot(pii0) - rSq;
+	const float D = (B * B) - (4.0f * A * C);
+
+	if (D &lt; -EPS) {
+		return false;
+	} else {
+		// get the length of the ray segment in volume-space
+		const float segLenSq = (pi1 - pi0).SqLength();
+
+		if (D &lt; EPS) {
+			// one solution for t
+			const float t0 = -B * 0.5f;
+			// const float t0 = -B / (2.0f * A);
+			// get the intersection point in sphere-space
+			const float3 pTmp = pii0 + (dir * t0);
+			// get the intersection point in volume-space
+			const float3 p0(pTmp.x * v-&gt;axisHScales.x, pTmp.y * v-&gt;axisHScales.y, pTmp.z * v-&gt;axisHScales.z);
+			// get the distance from the start of the segment
+			// to the intersection point in volume-space
+			const float dSq0 = (p0 - pi0).SqLength();
+			// if the intersection point is closer to p0 than
+			// the end of the ray segment, the hit is valid
+			const bool b0 = (t0 &gt; 0.0f &amp;&amp; dSq0 &lt;= segLenSq);
+
+			if (q) {
+				q-&gt;b0 = b0; q-&gt;b1 = false;
+				q-&gt;t0 = t0; q-&gt;t1 = 0.0f;
+				q-&gt;p0 = p0; q-&gt;p1 = ZVec;
+			}
+
+			return b0;
+		} else {
+			// two solutions for t
+			const float rD = fastmath::sqrt(D);
+			const float t0 = (-B + rD) * 0.5f;
+			const float t1 = (-B - rD) * 0.5f;
+			// const float t0 = (-B + rD) / (2.0f * A);
+			// const float t1 = (-B - rD) / (2.0f * A);
+			// get the intersection points in sphere-space
+			const float3 pTmp0 = pii0 + (dir * t0);
+			const float3 pTmp1 = pii0 + (dir * t1);
+			// get the intersection points in volume-space
+			const float3 p0(pTmp0.x * v-&gt;axisHScales.x, pTmp0.y * v-&gt;axisHScales.y, pTmp0.z * v-&gt;axisHScales.z);
+			const float3 p1(pTmp1.x * v-&gt;axisHScales.x, pTmp1.y * v-&gt;axisHScales.y, pTmp1.z * v-&gt;axisHScales.z);
+			// get the distances from the start of the ray
+			// to the intersection points in volume-space
+			const float dSq0 = (p0 - pi0).SqLength();
+			const float dSq1 = (p1 - pi0).SqLength();
+			// if one of the intersection points is closer to p0
+			// than the end of the ray segment, the hit is valid
+			const bool b0 = (t0 &gt; 0.0f &amp;&amp; dSq0 &lt;= segLenSq);
+			const bool b1 = (t1 &gt; 0.0f &amp;&amp; dSq1 &lt;= segLenSq);
+
+			if (q) {
+				q-&gt;b0 = b0; q-&gt;b1 = b1;
+				q-&gt;t0 = t0; q-&gt;t1 = t1;
+				q-&gt;p0 = p0; q-&gt;p1 = p1;
+			}
+
+			return (b0 || b1);
+		}
+	}
+}
+
+bool CCollisionHandler::IntersectCylinder(const CollisionVolume* v, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+{
+	// get the ray direction in volume space
+	const float3 dir = (pi1 - pi0).Normalize();
+
+	// end-cap plane normals
+	float3 n0;
+	float3 n1;
+
+	// pi0 transformed to unit-cylinder space
+	float3 pii0;
+	bool pass = false;
+
+	// pi0.dot(pi0), pi0.dot(dir), dir.dot(dir)
+	const float pxSq = pi0.x * pi0.x, pxdx = pi0.x * dir.x, dxSq = dir.x * dir.x;
+	const float pySq = pi0.y * pi0.y, pydy = pi0.y * dir.y, dySq = dir.y * dir.y;
+	const float pzSq = pi0.z * pi0.z, pzdz = pi0.z * dir.z, dzSq = dir.z * dir.z;
+	const float saSq = v-&gt;axisHScalesSq.x;
+	const float sbSq = v-&gt;axisHScalesSq.y;
+	const float scSq = v-&gt;axisHScalesSq.z;
+
+	float A = 0.0f, B = 0.0f, C = 0.0f;
+
+	switch (v-&gt;primaryAxis) {
+		case COLVOL_AXIS_X: {
+			// see if start of ray lies between end-caps
+			pass = (pi0.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; v-&gt;axisHScales.x);
+			pii0 = float3(pi0.x, pi0.y * v-&gt;axisHIScales.y, pi0.z * v-&gt;axisHIScales.z);
+
+			n0 = float3( 1.0f, 0.0f, 0.0f);
+			n1 = float3(-1.0f, 0.0f, 0.0f);
+
+			// get the parameters for the (2D)
+			// yz-plane ellipse surface equation
+			A = (dySq / sbSq) + (dzSq / scSq);
+			B = ((2.0f * pydy) / sbSq) + ((2.0f * pzdz) / scSq);
+			C = (pySq / sbSq) + (pzSq / scSq) - 1.0f;
+		} break;
+		case COLVOL_AXIS_Y: {
+			// see if start of ray lies between end-caps
+			pass = (pi0.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; v-&gt;axisHScales.y);
+			pii0 = float3(pi0.x * v-&gt;axisHIScales.x, pi0.y, pi0.z * v-&gt;axisHIScales.z);
+
+			n0 = float3(0.0f,  1.0f, 0.0f);
+			n1 = float3(0.0f, -1.0f, 0.0f);
+
+			// get the parameters for the (2D)
+			// xz-plane ellipse surface equation
+			A = (dxSq / saSq) + (dzSq / scSq);
+			B = ((2.0f * pxdx) / saSq) + ((2.0f * pzdz) / scSq);
+			C = (pxSq / saSq) + (pzSq / scSq) - 1.0f;
+		} break;
+		case COLVOL_AXIS_Z: {
+			// see if start of ray lies between end-caps
+			pass = (pi0.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; v-&gt;axisHScales.z);
+			pii0 = float3(pi0.x * v-&gt;axisHIScales.x, pi0.y * v-&gt;axisHIScales.y, pi0.z);
+
+			n0 = float3(0.0f, 0.0f,  1.0f);
+			n1 = float3(0.0f, 0.0f, -1.0f);
+
+			// get the parameters for the (2D)
+			// xy-plane ellipse surface equation
+			A = (dxSq / saSq) + (dySq / sbSq);
+			B = ((2.0f * pxdx) / saSq) + ((2.0f * pydy) / sbSq);
+			C = (pxSq / saSq) + (pySq / sbSq) - 1.0f;
+		} break;
+	}
+
+	if (pass &amp;&amp; pii0.dot(pii0) &lt;= 1.0f) {
+		// terminate early in the special case
+		// that shot originated within volume
+		if (q) {
+			q-&gt;b0 = true; q-&gt;b1 = true;
+			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
+			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
+		}
+		return true;
+	}
+
+	const int pAx = v-&gt;primaryAxis;
+	const int sAx0 = v-&gt;secondaryAxes[0];
+	const int sAx1 = v-&gt;secondaryAxes[1];
+	const float D = (B * B) - (4.0f * A * C);
+
+	if (D &lt; -EPS) {
+		return false;
+	} else {
+		// get the length of the ray segment in volume-space
+		const float segLenSq = (pi1 - pi0).SqLength();
+
+		float3 p0; float t0 = 0.0f, r0 = 0.0f, dSq0 = 0.0f; bool b0 = false;
+		float3 p1; float t1 = 0.0f, r1 = 0.0f, dSq1 = 0.0f; bool b1 = false;
+
+		if (D &lt; EPS) {
+			// one solution for t
+			t0 = -D / (2.0f * A); p0 = pi0 + (dir * t0);
+
+			if (p0[pAx] &gt; -v-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; v-&gt;axisHScales[pAx]) {
+				// intersection point &lt;p0&gt; falls between cylinder
+				// caps, check if it also lies on our ray segment
+				dSq0 = (p0 - pi0).SqLength();
+				b0 = (/* t0 &gt; 0.0f &amp;&amp; */ dSq0 &lt;= segLenSq);
+			} else {
+				// &lt;p&gt; does not fall between end-caps but ray
+				// segment might still intersect one, so test
+				// for intersection against the cap planes
+				t0 = -(n0.dot(pi0) + v-&gt;axisHScales[pAx]) / n0.dot(dir); p0 = pi0 + (dir * t0);
+				t1 = -(n1.dot(pi0) - v-&gt;axisHScales[pAx]) / n1.dot(dir); p1 = pi0 + (dir * t1);
+				r0 = (((p0[sAx0] * p0[sAx0]) / v-&gt;axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / v-&gt;axisHScalesSq[sAx1]));
+				r1 = (((p1[sAx0] * p1[sAx0]) / v-&gt;axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / v-&gt;axisHScalesSq[sAx1]));
+				b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f);
+				b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f);
+			}
+		} else {
+			// two solutions for t
+			const float rD = fastmath::sqrt(D);
+			t0 = (-B + rD) / (2.0f * A); p0 = pi0 + (dir * t0);
+			t1 = (-B - rD) / (2.0f * A); p1 = pi0 + (dir * t1);
+
+			// test the 1st intersection point
+			// along the cylinder's major axis
+			if (p0[pAx] &gt; -v-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; v-&gt;axisHScales[pAx]) {
+				// intersection point &lt;p0&gt; falls between cylinder
+				// caps, check if it also lies on our ray segment
+				dSq0 = (p0 - pi0).SqLength();
+				b0 = (/* t0 &gt; 0.0f &amp;&amp; */ dSq0 &lt;= segLenSq);
+			}
+
+			// test the 2nd intersection point
+			// along the cylinder's major axis
+			if (p1[pAx] &gt; -v-&gt;axisHScales[pAx]  &amp;&amp;  p1[pAx] &lt; v-&gt;axisHScales[pAx]) {
+				// intersection point &lt;p1&gt; falls between cylinder
+				// caps, check if it also lies on our ray segment
+				dSq1 = (p1 - pi0).SqLength();
+				b1 = (/* t1 &gt; 0.0f &amp;&amp; */ dSq1 &lt;= segLenSq);
+			}
+		}
+
+		if (!b0 &amp;&amp; !b1) {
+			// neither p0 nor p1 lies on ray segment (or falls between
+			// the cylinder end-caps) but segment might still intersect
+			// a cap, so do extra test for intersection against the cap
+			// planes
+			// NOTE: DIV0 if normal and dir are orthogonal?
+			t0 = -(n0.dot(pi0) + v-&gt;axisHScales[pAx]) / n0.dot(dir);
+			t1 = -(n1.dot(pi0) - v-&gt;axisHScales[pAx]) / n1.dot(dir);
+			p0 = pi0 + (dir * t0); dSq0 = (p0 - pi0).SqLength();
+			p1 = pi0 + (dir * t1); dSq1 = (p1 - pi0).SqLength();
+			r0 = (((p0[sAx0] * p0[sAx0]) / v-&gt;axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / v-&gt;axisHScalesSq[sAx1]));
+			r1 = (((p1[sAx0] * p1[sAx0]) / v-&gt;axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / v-&gt;axisHScalesSq[sAx1]));
+			b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f &amp;&amp; dSq0 &lt;= segLenSq);
+			b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f &amp;&amp; dSq1 &lt;= segLenSq);
+		}
+
+		if (q) {
+			q-&gt;b0 = b0; q-&gt;b1 = b1;
+			q-&gt;t0 = t0; q-&gt;t1 = t1;
+			q-&gt;p0 = p0; q-&gt;p1 = p1;
+		}
+
+		return (b0 || b1);
+	}
+}
+
+bool CCollisionHandler::IntersectBox(const CollisionVolume* v, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+{
+	const bool ba = (pi0.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; v-&gt;axisHScales.x);
+	const bool bb = (pi0.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; v-&gt;axisHScales.y);
+	const bool bc = (pi0.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; v-&gt;axisHScales.z);
+
+	if ((ba &amp;&amp; bb &amp;&amp; bc) /* &amp;&amp; (bd &amp;&amp; be &amp;&amp; bf) */) {
+		// terminate early in the special case
+		// that shot originated within volume
+		if (q) {
+			q-&gt;b0 = true; q-&gt;b1 = true;
+			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
+			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
+		}
+		return true;
+	}
+
+	float tn = -9999999.9f;
+	float tf =  9999999.9f;
+	float t0 =  0.0f;
+	float t1 =  0.0f;
+	float t2 =  0.0f;
+
+	const float3 dir = (pi1 - pi0).Normalize();
+
+	if (dir.x &gt; -EPS &amp;&amp; dir.x &lt; EPS) {
+		if (pi0.x &lt; -v-&gt;axisHScales.x  ||  pi0.x &gt; v-&gt;axisHScales.x) {
+			return false;
+		}
+	} else {
+		if (dir.x &gt; 0.0f) {
+			t0 = (-v-&gt;axisHScales.x - pi0.x) / dir.x;
+			t1 = ( v-&gt;axisHScales.x - pi0.x) / dir.x;
+		} else {
+			t1 = (-v-&gt;axisHScales.x - pi0.x) / dir.x;
+			t0 = ( v-&gt;axisHScales.x - pi0.x) / dir.x;
+		}
+
+		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
+		if (t0 &gt; tn) { tn = t0; }
+		if (t1 &lt; tf) { tf = t1; }
+		if (tn &gt; tf) { return false; }
+		if (tf &lt; 0.0f) { return false; }
+	}
+
+	if (dir.y &gt; -EPS &amp;&amp; dir.y &lt; EPS) {
+		if (pi0.y &lt; -v-&gt;axisHScales.y  ||  pi0.y &gt; v-&gt;axisHScales.y) {
+			return false;
+		}
+	} else {
+		if (dir.y &gt; 0.0f) {
+			t0 = (-v-&gt;axisHScales.y - pi0.y) / dir.y;
+			t1 = ( v-&gt;axisHScales.y - pi0.y) / dir.y;
+		} else {
+			t1 = (-v-&gt;axisHScales.y - pi0.y) / dir.y;
+			t0 = ( v-&gt;axisHScales.y - pi0.y) / dir.y;
+		}
+
+		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
+		if (t0 &gt; tn) { tn = t0; }
+		if (t1 &lt; tf) { tf = t1; }
+		if (tn &gt; tf) { return false; }
+		if (tf &lt; 0.0f) { return false; }
+	}
+
+	if (dir.z &gt; -EPS &amp;&amp; dir.z &lt; EPS) {
+		if (pi0.z &lt; -v-&gt;axisHScales.z  ||  pi0.z &gt; v-&gt;axisHScales.z) {
+			return false;
+		}
+	} else {
+		if (dir.z &gt; 0.0f) {
+			t0 = (-v-&gt;axisHScales.z - pi0.z) / dir.z;
+			t1 = ( v-&gt;axisHScales.z - pi0.z) / dir.z;
+		} else {
+			t1 = (-v-&gt;axisHScales.z - pi0.z) / dir.z;
+			t0 = ( v-&gt;axisHScales.z - pi0.z) / dir.z;
+		}
+
+		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
+		if (t0 &gt; tn) { tn = t0; }
+		if (t1 &lt; tf) { tf = t1; }
+		if (tn &gt; tf) { return false; }
+		if (tf &lt; 0.0f) { return false; }
+	}
+
+	// get the intersection points in volume-space
+	const float3 p0 = pi0 + (dir * tn);
+	const float3 p1 = pi0 + (dir * tf);
+	// get the length of the ray segment in volume-space
+	const float segLenSq = (pi1 - pi0).SqLength();
+	// get the distances from the start of the ray
+	// to the intersection points in volume-space
+	const float dSq0 = (p0 - pi0).SqLength();
+	const float dSq1 = (p1 - pi0).SqLength();
+	// if one of the intersection points is closer to p0
+	// than the end of the ray segment, the hit is valid
+	const bool b0 = (dSq0 &lt;= segLenSq);
+	const bool b1 = (dSq1 &lt;= segLenSq);
+
+	if (q) {
+		q-&gt;b0 = b0; q-&gt;b1 = b1;
+		q-&gt;t0 = tn; q-&gt;t1 = tf;
+		q-&gt;p0 = p0; q-&gt;p1 = p1;
+	}
+
+	return (b0 || b1);
+}

Copied: branches/gml/rts/Sim/Misc/CollisionHandler.h (from rev 5882, trunk/rts/Sim/Misc/CollisionHandler.h)
===================================================================
--- branches/gml/rts/Sim/Misc/CollisionHandler.h	                        (rev 0)
+++ branches/gml/rts/Sim/Misc/CollisionHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,55 @@
+#ifndef COLLISION_HANDLER_H
+#define COLLISION_HANDLER_H
+
+#include &quot;StdAfx.h&quot;
+#include &quot;creg/creg.h&quot;
+
+struct CollisionVolume;
+class CUnit;
+class CFeature;
+
+struct CollisionQuery {
+	CollisionQuery() {
+		// (0, 0, 0) is volume-space center, so
+		// impossible to obtain as actual points
+		// except in the special cases
+		b0 = false; t0 = 0.0f; p0 = ZeroVector;
+		b1 = false; t1 = 0.0f; p1 = ZeroVector;
+	}
+
+	bool b0, b1;
+	float t0, t1;
+	float3 p0, p1;
+};
+
+// responsible for detecting hits between projectiles
+// and world objects (units, features), each WO has a
+// collision volume
+class CCollisionHandler {
+	public:
+		CR_DECLARE(CCollisionHandler)
+
+		CCollisionHandler() {}
+		~CCollisionHandler() {}
+
+		static bool DetectHit(const CUnit*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0);
+		static bool DetectHit(const CFeature*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0);
+
+	private:
+		static bool Collision(const CUnit*, const float3&amp;);
+		static bool Collision(const CFeature*, const float3&amp;);
+		static bool Collision(const CollisionVolume*, const CMatrix44f&amp;, const float3&amp;);
+
+		static bool Intersect(const CUnit*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
+		static bool Intersect(const CFeature*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
+		static bool Intersect(const CollisionVolume*, const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q);
+
+		static bool IntersectEllipsoid(const CollisionVolume*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+		static bool IntersectCylinder(const CollisionVolume*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+		static bool IntersectBox(const CollisionVolume*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+
+		static unsigned int numCollisionTests;
+		static unsigned int numIntersectionTests;
+};
+
+#endif

Deleted: branches/gml/rts/Sim/Misc/CollisionVolume.cpp
===================================================================
--- branches/gml/rts/Sim/Misc/CollisionVolume.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Misc/CollisionVolume.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,729 +0,0 @@
-#include &lt;iostream&gt;
-
-#include &quot;System/float3.h&quot;
-#include &quot;System/Matrix44f.h&quot;
-
-#include &quot;Sim/Units/Unit.h&quot;
-#include &quot;Sim/Features/Feature.h&quot;
-
-#include &quot;CollisionVolume.h&quot;
-
-
-#define MIN(a, b) std::min((a), (b))
-#define MAX(a, b) std::max((a), (b))
-// #define MIN (((a) &lt; (b))? (a): (b))
-// #define MAX (((a) &gt; (b))? (a): (b))
-#define EPS 0.001f
-
-
-CR_BIND(CCollisionVolume, );
-CR_REG_METADATA(CCollisionVolume, (
-	CR_MEMBER(axisScales),
-	CR_MEMBER(axisHScales),
-	CR_MEMBER(axisHScalesSq),
-	CR_MEMBER(axisHIScales),
-	CR_MEMBER(axisOffsets),
-	CR_MEMBER(volumeBoundingRadius),
-	CR_MEMBER(volumeBoundingRadiusSq),
-	CR_MEMBER(volumeType),
-	CR_MEMBER(testType),
-	CR_MEMBER(primaryAxis),
-	CR_MEMBER(secondaryAxes),
-	CR_MEMBER(spherical)
-));
-
-
-CCollisionVolume::CCollisionVolume(const std::string&amp; volTypeStr, const float3&amp; volScales, const float3&amp; volOffsets, int tstType)
-{
-	// note: primaryAxis is only relevant for cylinders
-	primaryAxis = COLVOL_AXIS_Z;
-	volumeType = COLVOL_TYPE_ELLIPSOID;
-	testType = tstType;
-
-	if (volTypeStr.size() &gt; 0) {
-		// note: case-sensitivity?
-		if (volTypeStr.find(&quot;Ell&quot;) != std::string::npos) {
-			volumeType = COLVOL_TYPE_ELLIPSOID;
-		}
-
-		if (volTypeStr.find(&quot;Cyl&quot;) != std::string::npos) {
-			volumeType = COLVOL_TYPE_CYLINDER;
-
-			if (volTypeStr.size() == 4) {
-				if (volTypeStr[3] == 'X') { primaryAxis = COLVOL_AXIS_X; }
-				if (volTypeStr[3] == 'Y') { primaryAxis = COLVOL_AXIS_Y; }
-				if (volTypeStr[3] == 'Z') { primaryAxis = COLVOL_AXIS_Z; }
-			}
-		}
-
-		if (volTypeStr.find(&quot;Box&quot;) != std::string::npos) {
-			volumeType = COLVOL_TYPE_BOX;
-		}
-	}
-
-	// set the full-axis lengths
-	axisScales.x = volScales.x;
-	axisScales.y = volScales.y;
-	axisScales.z = volScales.z;
-
-	// set the half-axis lengths and squared lengths
-	axisHScales.x = axisScales.x * 0.5f; axisHScalesSq.x = axisHScales.x * axisHScales.x;
-	axisHScales.y = axisScales.y * 0.5f; axisHScalesSq.y = axisHScales.y * axisHScales.y;
-	axisHScales.z = axisScales.z * 0.5f; axisHScalesSq.z = axisHScales.z * axisHScales.z;
-
-	// set the inverted half-axis lengths
-	axisHIScales.x = 1.0f / axisHScales.x;
-	axisHIScales.y = 1.0f / axisHScales.y;
-	axisHIScales.z = 1.0f / axisHScales.z;
-
-	// set the axis offsets
-	axisOffsets.x = volOffsets.x;
-	axisOffsets.y = volOffsets.y;
-	axisOffsets.z = volOffsets.z;
-
-	// if all axes (or half-axes) are equal in scale, volume is a sphere
-	spherical = ((volumeType == COLVOL_TYPE_ELLIPSOID) &amp;&amp;
-				 (fabsf(axisHScales.x - axisHScales.y) &lt; EPS) &amp;&amp;
-				 (fabsf(axisHScales.y - axisHScales.z) &lt; EPS));
-
-	switch (primaryAxis) {
-		case COLVOL_AXIS_X: {
-			secondaryAxes[0] = COLVOL_AXIS_Y; // (pAx + 1) % 3;
-			secondaryAxes[1] = COLVOL_AXIS_Z; // (pAx + 2) % 3;
-		} break;
-		case COLVOL_AXIS_Y: {
-			secondaryAxes[0] = COLVOL_AXIS_X; // (pAx + 1) % 3;
-			secondaryAxes[1] = COLVOL_AXIS_Z; // (pAx + 2) % 3;
-		} break;
-		case COLVOL_AXIS_Z: {
-			secondaryAxes[0] = COLVOL_AXIS_X; // (pAx + 1) % 3;
-			secondaryAxes[1] = COLVOL_AXIS_Y; // (pAx + 2) % 3;
-		} break;
-	}
-
-	// set the radius of the minimum bounding sphere
-	// that encompasses this custom collision volume
-	// (for early-out testing)
-	switch (volumeType) {
-		case COLVOL_TYPE_BOX: {
-			// would be an over-estimation for cylinders
-			volumeBoundingRadiusSq = axisHScalesSq.x + axisHScalesSq.y + axisHScalesSq.z;
-			volumeBoundingRadius = sqrt(volumeBoundingRadiusSq);
-		} break;
-		case COLVOL_TYPE_CYLINDER: {
-			const float prhs = axisHScales[primaryAxis     ];	// primary axis half-scale
-			const float sahs = axisHScales[secondaryAxes[0]];	// 1st secondary axis half-scale
-			const float sbhs = axisHScales[secondaryAxes[1]];	// 2nd secondary axis half-scale
-			const float mshs = MAX(sahs, sbhs);					// max. secondary axis half-scale
-
-			volumeBoundingRadiusSq = prhs * prhs + mshs * mshs;
-			volumeBoundingRadius = sqrt(volumeBoundingRadiusSq);
-		} break;
-		case COLVOL_TYPE_ELLIPSOID: {
-			if (spherical) {
-				// MAX(x, y, z) would suffice here too
-				volumeBoundingRadius = axisHScales.x;
-			} else {
-				volumeBoundingRadius = MAX(axisHScales.x, MAX(axisHScales.y, axisHScales.z));
-			}
-
-			volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
-		} break;
-	}
-}
-
-// called iif unit or feature defines no custom volume
-void CCollisionVolume::SetDefaultScale(const float s)
-{
-	// &lt;s&gt; is the object's default radius (not its diameter)
-	// so we need to double it to get the full-length scales
-	axisScales.x = s * 2.0f;
-	axisScales.y = s * 2.0f;
-	axisScales.z = s * 2.0f;
-
-	axisHScales.x = s; axisHScalesSq.x = axisHScales.x * axisHScales.x;
-	axisHScales.y = s; axisHScalesSq.y = axisHScales.y * axisHScales.y;
-	axisHScales.z = s; axisHScalesSq.z = axisHScales.z * axisHScales.z;
-
-	axisHIScales.x = 1.0f / axisHScales.x;
-	axisHIScales.y = 1.0f / axisHScales.y;
-	axisHIScales.z = 1.0f / axisHScales.z;
-
-	spherical = true;
-	volumeBoundingRadius = s;
-	volumeBoundingRadiusSq = s * s;
-}
-
-
-
-
-
-
-bool CCollisionVolume::DetectHit(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	bool r = false;
-
-	switch (testType) {
-		// Collision(CUnit*) does not need p1 or q
-		case COLVOL_TEST_DISC: { r = Collision(u, p0       ); } break;
-		case COLVOL_TEST_CONT: { r = Intersect(u, p0, p1, q); } break;
-	}
-
-	return r;
-}
-
-bool CCollisionVolume::DetectHit(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	bool r = false;
-
-	switch (testType) {
-		// Collision(CFeature*) does not need p1 or q
-		case COLVOL_TEST_DISC: { r = Collision(f, p0       ); } break;
-		case COLVOL_TEST_CONT: { r = Intersect(f, p0, p1, q); } break;
-	}
-
-	return r;
-}
-
-
-
-
-
-
-bool CCollisionVolume::Collision(const CUnit* u, const float3&amp; p) const
-{
-	if ((u-&gt;midPos - p).SqLength() &gt; volumeBoundingRadiusSq) {
-		return false;
-	} else {
-		if (spherical) {
-			return true;
-		} else {
-			// NOTE: we have to translate by relMidPos (which is where
-			// collision volume gets drawn) since GetTransformMatrix()
-			// does not
-			CMatrix44f m;
-			u-&gt;GetTransformMatrix(m);
-			m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
-			m.Translate(axisOffsets.x, axisOffsets.y, axisOffsets.z);
-
-			return Collision(m, p);
-		}
-	}
-}
-
-bool CCollisionVolume::Collision(const CFeature* f, const float3&amp; p) const
-{
-	if ((f-&gt;midPos - p).SqLength() &gt; volumeBoundingRadiusSq) {
-		return false;
-	} else {
-		if (spherical) {
-			return true;
-		} else {
-			// NOTE: CFeature does not have a relMidPos member
-			CMatrix44f m(f-&gt;transMatrix);
-			m.Translate(axisOffsets.x, axisOffsets.y, axisOffsets.z);
-
-			return Collision(m, p);
-		}
-	}
-}
-
-
-
-// test if point &lt;p&gt; (in world-coors) lies inside the
-// volume whose transformation matrix is given by &lt;m&gt;
-bool CCollisionVolume::Collision(const CMatrix44f&amp; m, const float3&amp; p) const
-{
-	// get the inverse volume transformation matrix and
-	// apply it to the projectile's position, then test
-	// if the transformed position lies within the axis-
-	// aligned collision volume
-	CMatrix44f mInv = m.Invert();
-	float3 pi = mInv.Mul(p);
-	bool hit = false;
-
-	switch (volumeType) {
-		case COLVOL_TYPE_ELLIPSOID: {
-			if (spherical) {
-				hit = (pi.dot(pi) &lt;= axisHScalesSq.x);
-			} else {
-				const float f1 = (pi.x * pi.x) / axisHScalesSq.x;
-				const float f2 = (pi.y * pi.y) / axisHScalesSq.y;
-				const float f3 = (pi.z * pi.z) / axisHScalesSq.z;
-				hit = ((f1 + f2 + f3) &lt;= 1.0f);
-			}
-		} break;
-		case COLVOL_TYPE_CYLINDER: {
-			switch (primaryAxis) {
-				case COLVOL_AXIS_X: {
-					const bool xPass = (pi.x &gt; -axisHScales.x &amp;&amp; pi.x &lt; axisHScales.x);
-					const float yRat = (pi.y * pi.y) / axisHScalesSq.y;
-					const float zRat = (pi.z * pi.z) / axisHScalesSq.z;
-					hit = (xPass &amp;&amp; (yRat + zRat &lt;= 1.0f));
-				} break;
-				case COLVOL_AXIS_Y: {
-					const bool yPass = (pi.y &gt; -axisHScales.y &amp;&amp; pi.y &lt; axisHScales.y);
-					const float xRat = (pi.x * pi.x) / axisHScalesSq.x;
-					const float zRat = (pi.z * pi.z) / axisHScalesSq.z;
-					hit = (yPass &amp;&amp; (xRat + zRat &lt;= 1.0f));
-				} break;
-				case COLVOL_AXIS_Z: {
-					const bool zPass = (pi.z &gt; -axisHScales.z &amp;&amp; pi.z &lt; axisHScales.z);
-					const float xRat = (pi.x * pi.x) / axisHScalesSq.x;
-					const float yRat = (pi.y * pi.y) / axisHScalesSq.y;
-					hit = (zPass &amp;&amp; (xRat + yRat &lt;= 1.0f));
-				} break;
-			}
-		} break;
-		case COLVOL_TYPE_BOX: {
-			const bool b1 = (pi.x &gt; -axisHScales.x &amp;&amp; pi.x &lt; axisHScales.x);
-			const bool b2 = (pi.y &gt; -axisHScales.y &amp;&amp; pi.y &lt; axisHScales.y);
-			const bool b3 = (pi.z &gt; -axisHScales.z &amp;&amp; pi.z &lt; axisHScales.z);
-			hit = (b1 &amp;&amp; b2 &amp;&amp; b3);
-		} break;
-	}
-
-	return hit;
-}
-
-
-
-
-
-
-bool CCollisionVolume::Intersect(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	CMatrix44f m;
-	u-&gt;GetTransformMatrix(m);
-	m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
-	m.Translate(axisOffsets.x, axisOffsets.y, axisOffsets.z);
-
-	return Intersect(m, p0, p1, q);
-}
-
-bool CCollisionVolume::Intersect(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	CMatrix44f m(f-&gt;transMatrix);
-	m.Translate(axisOffsets.x, axisOffsets.y, axisOffsets.z);
-
-	return Intersect(m, p0, p1, q);
-}
-
-/*
-bool CCollisionVolume::IntersectAlt(const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery*) const
-{
-	// alternative numerical integration method (unused)
-	const float delta = 1.0f;
-	const float length = (p1 - p0).Length();
-	const float3 dir = (p1 - p0).Normalize();
-
-	for (float t = 0.0f; t &lt;= length; t += delta) {
-		if (Collision(m, p0 + dir * t)) return true;
-	}
-
-	return false;
-}
-*/
-
-
-
-// test if ray from &lt;p0&gt; to &lt;p1&gt; (in world-coors) intersects
-// the volume whose transformation matrix is given by &lt;m&gt;
-bool CCollisionVolume::Intersect(const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	CMatrix44f mInv = m.Invert();
-	const float3 pi0 = mInv.Mul(p0);
-	const float3 pi1 = mInv.Mul(p1);
-	bool intersect = false;
-
-	// minimum and maximum (x, y, z) coordinates of transformed ray
-	const float rminx = MIN(pi0.x, pi1.x), rminy = MIN(pi0.y, pi1.y), rminz = MIN(pi0.z, pi1.z);
-	const float rmaxx = MAX(pi0.x, pi1.x), rmaxy = MAX(pi0.y, pi1.y), rmaxz = MAX(pi0.z, pi1.z);
-
-	// minimum and maximum (x, y, z) coordinates of (bounding box around) volume
-	const float vminx = -axisHScales.x, vminy = -axisHScales.y, vminz = -axisHScales.z;
-	const float vmaxx =  axisHScales.x, vmaxy =  axisHScales.y, vmaxz =  axisHScales.z;
-
-	// check if ray segment misses (bounding box around) volume
-	// (if so, then no further intersection tests are necessary)
-	if (rmaxx &lt; vminx || rminx &gt; vmaxx) { return false; }
-	if (rmaxy &lt; vminy || rminy &gt; vmaxy) { return false; }
-	if (rmaxz &lt; vminz || rminz &gt; vmaxz) { return false; }
-
-	switch (volumeType) {
-		case COLVOL_TYPE_ELLIPSOID: {
-			intersect = IntersectEllipsoid(pi0, pi1, q);
-		} break;
-		case COLVOL_TYPE_CYLINDER: {
-			intersect = IntersectCylinder(pi0, pi1, q);
-		} break;
-		case COLVOL_TYPE_BOX: {
-			intersect = IntersectBox(pi0, pi1, q);
-		} break;
-	}
-
-	return intersect;
-}
-
-bool CCollisionVolume::IntersectEllipsoid(const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q) const
-{
-	// transform the volume-space points into (unit) sphere-space (requires fewer
-	// float-ops than solving the surface equation for arbitrary ellipsoid volumes)
-	const float3 pii0 = float3(pi0.x * axisHIScales.x, pi0.y * axisHIScales.y, pi0.z * axisHIScales.z);
-	const float3 pii1 = float3(pi1.x * axisHIScales.x, pi1.y * axisHIScales.y, pi1.z * axisHIScales.z);
-	const float rSq = 1.0f;
-
-	if (pii0.dot(pii0) &lt;= rSq /* &amp;&amp; pii1.dot(pii1) &lt;= rSq */) {
-		// terminate early in the special case
-		// that shot originated within volume
-		if (q) {
-			q-&gt;b0 = true; q-&gt;b1 = true;
-			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
-			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
-		}
-		return true;
-	}
-
-	// get the ray direction in unit-sphere space
-	const float3 dir = (pii1 - pii0).Normalize();
-
-	// solves [ x^2 + y^2 + z^2 == r^2 ] for t
-	// (&lt;A&gt; represents dir.dot(dir), equal to 1
-	// since ray direction already normalized)
-	const float A = 1.0f;
-	const float B = (pii0 * 2.0f).dot(dir);
-	const float C = pii0.dot(pii0) - rSq;
-	const float D = (B * B) - (4.0f * A * C);
-
-	if (D &lt; -EPS) {
-		return false;
-	} else {
-		// get the length of the ray segment in volume-space
-		const float segLenSq = (pi1 - pi0).SqLength();
-
-		if (D &lt; EPS) {
-			// one solution for t
-			const float t0 = -B * 0.5f;
-			// const float t0 = -B / (2.0f * A);
-			// get the intersection point in sphere-space
-			const float3 pTmp = pii0 + (dir * t0);
-			// get the intersection point in volume-space
-			const float3 p0(pTmp.x * axisHScales.x, pTmp.y * axisHScales.y, pTmp.z * axisHScales.z);
-			// get the distance from the start of the segment
-			// to the intersection point in volume-space
-			const float dSq0 = (p0 - pi0).SqLength();
-			// if the intersection point is closer to p0 than
-			// the end of the ray segment, the hit is valid
-			const bool b0 = (t0 &gt; 0.0f &amp;&amp; dSq0 &lt;= segLenSq);
-
-			if (q) {
-				q-&gt;b0 = b0; q-&gt;b1 = false;
-				q-&gt;t0 = t0; q-&gt;t1 = 0.0f;
-				q-&gt;p0 = p0; q-&gt;p1 = ZVec;
-			}
-
-			return b0;
-		} else {
-			// two solutions for t
-			const float rD = sqrt(D);
-			const float t0 = (-B + rD) * 0.5f;
-			const float t1 = (-B - rD) * 0.5f;
-			// const float t0 = (-B + rD) / (2.0f * A);
-			// const float t1 = (-B - rD) / (2.0f * A);
-			// get the intersection points in sphere-space
-			const float3 pTmp0 = pii0 + (dir * t0);
-			const float3 pTmp1 = pii0 + (dir * t1);
-			// get the intersection points in volume-space
-			const float3 p0(pTmp0.x * axisHScales.x, pTmp0.y * axisHScales.y, pTmp0.z * axisHScales.z);
-			const float3 p1(pTmp1.x * axisHScales.x, pTmp1.y * axisHScales.y, pTmp1.z * axisHScales.z);
-			// get the distances from the start of the ray
-			// to the intersection points in volume-space
-			const float dSq0 = (p0 - pi0).SqLength();
-			const float dSq1 = (p1 - pi0).SqLength();
-			// if one of the intersection points is closer to p0
-			// than the end of the ray segment, the hit is valid
-			const bool b0 = (t0 &gt; 0.0f &amp;&amp; dSq0 &lt;= segLenSq);
-			const bool b1 = (t1 &gt; 0.0f &amp;&amp; dSq1 &lt;= segLenSq);
-
-			if (q) {
-				q-&gt;b0 = b0; q-&gt;b1 = b1;
-				q-&gt;t0 = t0; q-&gt;t1 = t1;
-				q-&gt;p0 = p0; q-&gt;p1 = p1;
-			}
-
-			return (b0 || b1);
-		}
-	}
-}
-
-bool CCollisionVolume::IntersectCylinder(const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q) const
-{
-	// get the ray direction in volume space
-	const float3 dir = (pi1 - pi0).Normalize();
-
-	// end-cap plane normals
-	float3 n0;
-	float3 n1;
-
-	// pi0 transformed to unit-cylinder space
-	float3 pii0;
-	bool pass;
-
-	// pi0.dot(pi0), pi0.dot(dir), dir.dot(dir)
-	const float pxSq = pi0.x * pi0.x, pxdx = pi0.x * dir.x, dxSq = dir.x * dir.x;
-	const float pySq = pi0.y * pi0.y, pydy = pi0.y * dir.y, dySq = dir.y * dir.y;
-	const float pzSq = pi0.z * pi0.z, pzdz = pi0.z * dir.z, dzSq = dir.z * dir.z;
-	const float saSq = axisHScalesSq.x;
-	const float sbSq = axisHScalesSq.y;
-	const float scSq = axisHScalesSq.z;
-
-	float A = 0.0f, B = 0.0f, C = 0.0f;
-
-	switch (primaryAxis) {
-		case COLVOL_AXIS_X: {
-			// see if start of ray lies between end-caps
-			pass = (pi0.x &gt; -axisHScales.x &amp;&amp; pi0.x &lt; axisHScales.x);
-			pii0 = float3(pi0.x, pi0.y * axisHIScales.y, pi0.z * axisHIScales.z);
-
-			n0 = float3( 1.0f, 0.0f, 0.0f);
-			n1 = float3(-1.0f, 0.0f, 0.0f);
-
-			// get the parameters for the (2D)
-			// yz-plane ellipse surface equation
-			A = (dySq / sbSq) + (dzSq / scSq);
-			B = ((2.0f * pydy) / sbSq) + ((2.0f * pzdz) / scSq);
-			C = (pySq / sbSq) + (pzSq / scSq) - 1.0f;
-		} break;
-		case COLVOL_AXIS_Y: {
-			// see if start of ray lies between end-caps
-			pass = (pi0.y &gt; -axisHScales.y &amp;&amp; pi0.y &lt; axisHScales.y);
-			pii0 = float3(pi0.x * axisHIScales.x, pi0.y, pi0.z * axisHIScales.z);
-
-			n0 = float3(0.0f,  1.0f, 0.0f);
-			n1 = float3(0.0f, -1.0f, 0.0f);
-
-			// get the parameters for the (2D)
-			// xz-plane ellipse surface equation
-			A = (dxSq / saSq) + (dzSq / scSq);
-			B = ((2.0f * pxdx) / saSq) + ((2.0f * pzdz) / scSq);
-			C = (pxSq / saSq) + (pzSq / scSq) - 1.0f;
-		} break;
-		case COLVOL_AXIS_Z: {
-			// see if start of ray lies between end-caps
-			pass = (pi0.z &gt; -axisHScales.z &amp;&amp; pi0.z &lt; axisHScales.z);
-			pii0 = float3(pi0.x * axisHIScales.x, pi0.y * axisHIScales.y, pi0.z);
-
-			n0 = float3(0.0f, 0.0f,  1.0f);
-			n1 = float3(0.0f, 0.0f, -1.0f);
-
-			// get the parameters for the (2D)
-			// xy-plane ellipse surface equation
-			A = (dxSq / saSq) + (dySq / sbSq);
-			B = ((2.0f * pxdx) / saSq) + ((2.0f * pydy) / sbSq);
-			C = (pxSq / saSq) + (pySq / sbSq) - 1.0f;
-		} break;
-	}
-
-	if (pass &amp;&amp; pii0.dot(pii0) &lt;= 1.0f) {
-		// terminate early in the special case
-		// that shot originated within volume
-		if (q) {
-			q-&gt;b0 = true; q-&gt;b1 = true;
-			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
-			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
-		}
-		return true;
-	}
-
-	const int pAx = primaryAxis;
-	const int sAx0 = secondaryAxes[0];
-	const int sAx1 = secondaryAxes[1];
-	const float D = (B * B) - (4.0f * A * C);
-
-	if (D &lt; -EPS) {
-		return false;
-	} else {
-		// get the length of the ray segment in volume-space
-		const float segLenSq = (pi1 - pi0).SqLength();
-
-		float3 p0; float t0 = 0.0f, r0 = 0.0f, dSq0 = 0.0f; bool b0 = false;
-		float3 p1; float t1 = 0.0f, r1 = 0.0f, dSq1 = 0.0f; bool b1 = false;
-
-		if (D &lt; EPS) {
-			// one solution for t
-			t0 = -D / (2.0f * A); p0 = pi0 + (dir * t0);
-
-			if (p0[pAx] &gt; -axisHScales[pAx] &amp;&amp; p0[pAx] &lt; axisHScales[pAx]) {
-				// intersection point &lt;p0&gt; falls between cylinder
-				// caps, check if it also lies on our ray segment
-				dSq0 = (p0 - pi0).SqLength();
-				b0 = (/* t0 &gt; 0.0f &amp;&amp; */ dSq0 &lt;= segLenSq);
-			} else {
-				// &lt;p&gt; does not fall between end-caps but ray
-				// segment might still intersect one, so test
-				// for intersection against the cap planes
-				t0 = -(n0.dot(pi0) + axisHScales[pAx]) / n0.dot(dir); p0 = pi0 + (dir * t0);
-				t1 = -(n1.dot(pi0) - axisHScales[pAx]) / n1.dot(dir); p1 = pi0 + (dir * t1);
-				r0 = (((p0[sAx0] * p0[sAx0]) / axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / axisHScalesSq[sAx1]));
-				r1 = (((p1[sAx0] * p1[sAx0]) / axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / axisHScalesSq[sAx1]));
-				b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f);
-				b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f);
-			}
-		} else {
-			// two solutions for t
-			const float rD = sqrt(D);
-			t0 = (-B + rD) / (2.0f * A); p0 = pi0 + (dir * t0);
-			t1 = (-B - rD) / (2.0f * A); p1 = pi0 + (dir * t1);
-
-			// test the 1st intersection point
-			// along the cylinder's major axis
-			if (p0[pAx] &gt; -axisHScales[pAx] &amp;&amp; p0[pAx] &lt; axisHScales[pAx]) {
-				// intersection point &lt;p0&gt; falls between cylinder
-				// caps, check if it also lies on our ray segment
-				dSq0 = (p0 - pi0).SqLength();
-				b0 = (/* t0 &gt; 0.0f &amp;&amp; */ dSq0 &lt;= segLenSq);
-			}
-
-			// test the 2nd intersection point
-			// along the cylinder's major axis
-			if (p1[pAx] &gt; -axisHScales[pAx] &amp;&amp; p1[pAx] &lt; axisHScales[pAx]) {
-				// intersection point &lt;p1&gt; falls between cylinder
-				// caps, check if it also lies on our ray segment
-				dSq1 = (p1 - pi0).SqLength();
-				b1 = (/* t1 &gt; 0.0f &amp;&amp; */ dSq1 &lt;= segLenSq);
-			}
-		}
-
-		if (!b0 &amp;&amp; !b1) {
-			// neither p0 nor p1 lies on ray segment (or falls between
-			// the cylinder end-caps) but segment might still intersect
-			// a cap, so do extra test for intersection against the cap
-			// planes
-			// NOTE: DIV0 if normal and dir are orthogonal?
-			t0 = -(n0.dot(pi0) + axisHScales[pAx]) / n0.dot(dir);
-			t1 = -(n1.dot(pi0) - axisHScales[pAx]) / n1.dot(dir);
-			p0 = pi0 + (dir * t0); dSq0 = (p0 - pi0).SqLength();
-			p1 = pi0 + (dir * t1); dSq1 = (p1 - pi0).SqLength();
-			r0 = (((p0[sAx0] * p0[sAx0]) / axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / axisHScalesSq[sAx1]));
-			r1 = (((p1[sAx0] * p1[sAx0]) / axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / axisHScalesSq[sAx1]));
-			b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f &amp;&amp; dSq0 &lt;= segLenSq);
-			b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f &amp;&amp; dSq1 &lt;= segLenSq);
-		}
-
-		if (q) {
-			q-&gt;b0 = b0; q-&gt;b1 = b1;
-			q-&gt;t0 = t0; q-&gt;t1 = t1;
-			q-&gt;p0 = p0; q-&gt;p1 = p1;
-		}
-
-		return (b0 || b1);
-	}
-}
-
-bool CCollisionVolume::IntersectBox(const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q) const
-{
-	const bool ba = (pi0.x &gt; -axisHScales.x &amp;&amp; pi0.x &lt; axisHScales.x);
-	const bool bb = (pi0.y &gt; -axisHScales.y &amp;&amp; pi0.y &lt; axisHScales.y);
-	const bool bc = (pi0.z &gt; -axisHScales.z &amp;&amp; pi0.z &lt; axisHScales.z);
-
-	if ((ba &amp;&amp; bb &amp;&amp; bc) /* &amp;&amp; (bd &amp;&amp; be &amp;&amp; bf) */) {
-		// terminate early in the special case
-		// that shot originated within volume
-		if (q) {
-			q-&gt;b0 = true; q-&gt;b1 = true;
-			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
-			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
-		}
-		return true;
-	}
-
-	float tn = -9999999.9f;
-	float tf =  9999999.9f;
-	float t0 =  0.0f;
-	float t1 =  0.0f;
-	float t2 =  0.0f;
-
-	const float3 dir = (pi1 - pi0).Normalize();
-
-	if (dir.x &gt; -EPS &amp;&amp; dir.x &lt; EPS) {
-		if (pi0.x &lt; -axisHScales.x || pi0.x &gt; axisHScales.x) {
-			return false;
-		}
-	} else {
-		if (dir.x &gt; 0.0f) {
-			t0 = (-axisHScales.x - pi0.x) / dir.x;
-			t1 = ( axisHScales.x - pi0.x) / dir.x;
-		} else {
-			t1 = (-axisHScales.x - pi0.x) / dir.x;
-			t0 = ( axisHScales.x - pi0.x) / dir.x;
-		}
-
-		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
-		if (t0 &gt; tn) { tn = t0; }
-		if (t1 &lt; tf) { tf = t1; }
-		if (tn &gt; tf) { return false; }
-		if (tf &lt; 0.0f) { return false; }
-	}
-
-	if (dir.y &gt; -EPS &amp;&amp; dir.y &lt; EPS) {
-		if (pi0.y &lt; -axisHScales.y || pi0.y &gt; axisHScales.y) {
-			return false;
-		}
-	} else {
-		if (dir.y &gt; 0.0f) {
-			t0 = (-axisHScales.y - pi0.y) / dir.y;
-			t1 = ( axisHScales.y - pi0.y) / dir.y;
-		} else {
-			t1 = (-axisHScales.y - pi0.y) / dir.y;
-			t0 = ( axisHScales.y - pi0.y) / dir.y;
-		}
-
-		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
-		if (t0 &gt; tn) { tn = t0; }
-		if (t1 &lt; tf) { tf = t1; }
-		if (tn &gt; tf) { return false; }
-		if (tf &lt; 0.0f) { return false; }
-	}
-
-	if (dir.z &gt; -EPS &amp;&amp; dir.z &lt; EPS) {
-		if (pi0.z &lt; -axisHScales.z || pi0.z &gt; axisHScales.z) {
-			return false;
-		}
-	} else {
-		if (dir.z &gt; 0.0f) {
-			t0 = (-axisHScales.z - pi0.z) / dir.z;
-			t1 = ( axisHScales.z - pi0.z) / dir.z;
-		} else {
-			t1 = (-axisHScales.z - pi0.z) / dir.z;
-			t0 = ( axisHScales.z - pi0.z) / dir.z;
-		}
-
-		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
-		if (t0 &gt; tn) { tn = t0; }
-		if (t1 &lt; tf) { tf = t1; }
-		if (tn &gt; tf) { return false; }
-		if (tf &lt; 0.0f) { return false; }
-	}
-
-	// get the intersection points in volume-space
-	const float3 p0 = pi0 + (dir * tn);
-	const float3 p1 = pi0 + (dir * tf);
-	// get the length of the ray segment in volume-space
-	const float segLenSq = (pi1 - pi0).SqLength();
-	// get the distances from the start of the ray
-	// to the intersection points in volume-space
-	const float dSq0 = (p0 - pi0).SqLength();
-	const float dSq1 = (p1 - pi0).SqLength();
-	// if one of the intersection points is closer to p0
-	// than the end of the ray segment, the hit is valid
-	const bool b0 = (dSq0 &lt;= segLenSq);
-	const bool b1 = (dSq1 &lt;= segLenSq);
-
-	if (q) {
-		q-&gt;b0 = b0; q-&gt;b1 = b1;
-		q-&gt;t0 = tn; q-&gt;t1 = tf;
-		q-&gt;p0 = p0; q-&gt;p1 = p1;
-	}
-
-	return (b0 || b1);
-}

Deleted: branches/gml/rts/Sim/Misc/CollisionVolume.h
===================================================================
--- branches/gml/rts/Sim/Misc/CollisionVolume.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Misc/CollisionVolume.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,83 +0,0 @@
-#ifndef COLLISION_VOLUME_H
-#define COLLISION_VOLUME_H
-
-#include &quot;StdAfx.h&quot;
-#include &quot;creg/creg.h&quot;
-
-#define ZVec ZeroVector
-
-enum COLVOL_TYPES {COLVOL_TYPE_ELLIPSOID, COLVOL_TYPE_CYLINDER, COLVOL_TYPE_BOX};
-enum COLVOL_AXES {COLVOL_AXIS_X, COLVOL_AXIS_Y, COLVOL_AXIS_Z};
-enum COLVOL_TESTS {COLVOL_TEST_DISC, COLVOL_TEST_CONT};
-
-class CUnit;
-class CFeature;
-
-struct CollisionQuery {
-	CollisionQuery() {
-		// (0, 0, 0) is volume-space center, so
-		// impossible to obtain as actual points
-		// except in the special cases
-		b0 = false; t0 = 0.0f; p0 = ZVec;
-		b1 = false; t1 = 0.0f; p1 = ZVec;
-	}
-
-	bool b0, b1;
-	float t0, t1;
-	float3 p0, p1;
-};
-
-class CCollisionVolume {
-	public:
-		CR_DECLARE(CCollisionVolume)
-
-		CCollisionVolume() {}
-		CCollisionVolume(const std::string&amp;, const float3&amp;, const float3&amp;, int);
-		~CCollisionVolume() {}
-
-		void SetDefaultScale(const float);
-
-		bool DetectHit(const CUnit*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0) const;
-		bool DetectHit(const CFeature*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0) const;
-
-		int GetVolumeType() const { return volumeType; }
-		int GetTestType() const { return testType; }
-		int GetPrimaryAxis() const { return primaryAxis; }
-		float GetBoundingRadius() const { return volumeBoundingRadius; }
-		float GetBoundingRadiusSq() const { return volumeBoundingRadiusSq; }
-		float GetScale(int axis) const { return axisScales[axis]; }
-		float GetHScale(int axis) const { return axisHScales[axis]; }
-		float GetHScaleSq(int axis) const { return axisHScalesSq[axis]; }
-		float GetOffset(int axis) const { return axisOffsets[axis]; }
-		bool IsSphere() const { return spherical; }
-
-	private:
-		bool Collision(const CUnit*, const float3&amp;) const;
-		bool Collision(const CFeature*, const float3&amp;) const;
-		bool Intersect(const CUnit*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q) const;
-		bool Intersect(const CFeature*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q) const;
-
-		bool Collision(const CMatrix44f&amp;, const float3&amp;) const;
-		bool Intersect(const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-		bool IntersectAlt(const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-
-		bool IntersectEllipsoid(const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-		bool IntersectCylinder(const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-		bool IntersectBox(const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-
-		float3 axisScales;					// full-length axis scales
-		float3 axisHScales;					// half-length axis scales
-		float3 axisHScalesSq;				// half-length axis scales (squared)
-		float3 axisHIScales;				// half-length axis scales (inverted)
-		float3 axisOffsets;
-
-		float volumeBoundingRadius;			// radius of minimally-bounding sphere around volume
-		float volumeBoundingRadiusSq;		// squared radius of minimally-bounding sphere
-		int volumeType;
-		int testType;
-		int primaryAxis;
-		int secondaryAxes[2];
-		bool spherical;
-};
-
-#endif

Copied: branches/gml/rts/Sim/Misc/CollisionVolume.h (from rev 5882, trunk/rts/Sim/Misc/CollisionVolume.h)
===================================================================
--- branches/gml/rts/Sim/Misc/CollisionVolume.h	                        (rev 0)
+++ branches/gml/rts/Sim/Misc/CollisionVolume.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,172 @@
+#ifndef COLLISION_VOLUME_H
+#define COLLISION_VOLUME_H
+
+#include &quot;StdAfx.h&quot;
+#include &quot;creg/creg.h&quot;
+
+#define EPS 0.001f
+#define MIN(a, b) std::min((a), (b))
+#define MAX(a, b) std::max((a), (b))
+
+enum COLVOL_TYPES {COLVOL_TYPE_ELLIPSOID, COLVOL_TYPE_CYLINDER, COLVOL_TYPE_BOX};
+enum COLVOL_AXES {COLVOL_AXIS_X, COLVOL_AXIS_Y, COLVOL_AXIS_Z};
+enum COLVOL_TESTS {COLVOL_TEST_DISC, COLVOL_TEST_CONT};
+
+struct CollisionVolume {
+	CR_DECLARE_STRUCT(CollisionVolume);
+
+	CollisionVolume() {}
+	CollisionVolume(const CollisionVolume* src) {
+		axisScales = src-&gt;axisScales;
+		axisHScales = src-&gt;axisHScales;
+		axisHScalesSq = src-&gt;axisHScalesSq;
+		axisHIScales = src-&gt;axisHIScales;
+		axisOffsets = src-&gt;axisOffsets;
+		volumeBoundingRadius = src-&gt;volumeBoundingRadius;
+		volumeBoundingRadiusSq = src-&gt;volumeBoundingRadiusSq;
+		volumeType = src-&gt;volumeType;
+		testType = src-&gt;testType;
+		primaryAxis = src-&gt;primaryAxis;
+		secondaryAxes[0] = src-&gt;secondaryAxes[0];
+		secondaryAxes[1] = src-&gt;secondaryAxes[1];
+		spherical = src-&gt;spherical;
+	}
+
+	CollisionVolume(const std::string&amp; volTypeStr, const float3&amp; volScales, const float3&amp; volOffsets, int tstType) {
+		// note: primaryAxis is only relevant for cylinders
+		primaryAxis = COLVOL_AXIS_Z;
+		volumeType = COLVOL_TYPE_ELLIPSOID;
+		testType = tstType;
+
+		if (volTypeStr.size() &gt; 0) {
+			// note: case-sensitivity?
+			if (volTypeStr.find(&quot;Ell&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_ELLIPSOID;
+			}
+
+			if (volTypeStr.find(&quot;Cyl&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_CYLINDER;
+
+				if (volTypeStr.size() == 4) {
+					if (volTypeStr[3] == 'X') { primaryAxis = COLVOL_AXIS_X; }
+					if (volTypeStr[3] == 'Y') { primaryAxis = COLVOL_AXIS_Y; }
+					if (volTypeStr[3] == 'Z') { primaryAxis = COLVOL_AXIS_Z; }
+				}
+			}
+
+			if (volTypeStr.find(&quot;Box&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_BOX;
+			}
+		}
+
+		Init(volScales, volOffsets, volumeType, testType, primaryAxis);
+	}
+
+
+	void SetDefaultScale(const float s) {
+		// called iif unit or feature defines no custom volume,
+		// &lt;s&gt; is the object's default RADIUS (not its diameter)
+		// so we need to double it to get the full-length scales
+		const float3 scales(s * 2.0f, s * 2.0f, s * 2.0f);
+
+		Init(scales, ZeroVector, COLVOL_TYPE_ELLIPSOID, COLVOL_TEST_DISC, COLVOL_AXIS_Z);
+	}
+
+
+	void Init(const float3&amp; scales, const float3&amp; offsets, int vType, int tType, int pAxis) {
+		// assign these here too, since SetData() can
+		// be called from outside of the constructor
+		primaryAxis = pAxis % 3;
+		volumeType = vType % 3;
+		testType = tType % 2;
+
+		axisScales.x = (scales.x &lt; 1.0f)? 1.0f: scales.x;  axisHScales.x = axisScales.x * 0.5f;  axisHScalesSq.x = axisHScales.x * axisHScales.x;
+		axisScales.y = (scales.y &lt; 1.0f)? 1.0f: scales.y;  axisHScales.y = axisScales.y * 0.5f;  axisHScalesSq.y = axisHScales.y * axisHScales.y;
+		axisScales.z = (scales.z &lt; 1.0f)? 1.0f: scales.z;  axisHScales.z = axisScales.z * 0.5f;  axisHScalesSq.z = axisHScales.z * axisHScales.z;
+
+		axisHIScales.x = 1.0f / axisHScales.x;  axisOffsets.x = offsets.x;
+		axisHIScales.y = 1.0f / axisHScales.y;  axisOffsets.y = offsets.y;
+		axisHIScales.z = 1.0f / axisHScales.z;  axisOffsets.z = offsets.z;
+
+		// if all axes (or half-axes) are equal in scale, volume is a sphere
+		spherical = ((volumeType == COLVOL_TYPE_ELLIPSOID) &amp;&amp;
+					(streflop::fabsf(axisHScales.x - axisHScales.y) &lt; EPS) &amp;&amp;
+					(streflop::fabsf(axisHScales.y - axisHScales.z) &lt; EPS));
+
+		// secondaryAxes[0] = (primaryAxis + 1) % 3;
+		// secondaryAxes[1] = (primaryAxis + 2) % 3;
+
+		switch (primaryAxis) {
+			case COLVOL_AXIS_X: {
+				secondaryAxes[0] = COLVOL_AXIS_Y;
+				secondaryAxes[1] = COLVOL_AXIS_Z;
+			} break;
+			case COLVOL_AXIS_Y: {
+				secondaryAxes[0] = COLVOL_AXIS_X;
+				secondaryAxes[1] = COLVOL_AXIS_Z;
+			} break;
+			case COLVOL_AXIS_Z: {
+				secondaryAxes[0] = COLVOL_AXIS_X;
+				secondaryAxes[1] = COLVOL_AXIS_Y;
+			} break;
+		}
+
+		// set the radius of the minimum bounding sphere
+		// that encompasses this custom collision volume
+		// (for early-out testing)
+		switch (volumeType) {
+			case COLVOL_TYPE_BOX: {
+				// would be an over-estimation for cylinders
+				volumeBoundingRadiusSq = axisHScalesSq.x + axisHScalesSq.y + axisHScalesSq.z;
+				volumeBoundingRadius = streflop::sqrt(volumeBoundingRadiusSq);
+			} break;
+			case COLVOL_TYPE_CYLINDER: {
+				const float prhs = axisHScales[primaryAxis     ];	// primary axis half-scale
+				const float sahs = axisHScales[secondaryAxes[0]];	// 1st secondary axis half-scale
+				const float sbhs = axisHScales[secondaryAxes[1]];	// 2nd secondary axis half-scale
+				const float mshs = MAX(sahs, sbhs);					// max. secondary axis half-scale
+
+				volumeBoundingRadiusSq = prhs * prhs + mshs * mshs;
+				volumeBoundingRadius = streflop::sqrtf(volumeBoundingRadiusSq);
+			} break;
+			case COLVOL_TYPE_ELLIPSOID: {
+				if (spherical) {
+					// MAX(x, y, z) would suffice here too
+					volumeBoundingRadius = axisHScales.x;
+				} else {
+					volumeBoundingRadius = MAX(axisHScales.x, MAX(axisHScales.y, axisHScales.z));
+				}
+
+				volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
+			} break;
+		}
+	}
+
+	int GetVolumeType() const { return volumeType; }
+	int GetTestType() const { return testType; }
+	int GetPrimaryAxis() const { return primaryAxis; }
+	float GetBoundingRadius() const { return volumeBoundingRadius; }
+	float GetBoundingRadiusSq() const { return volumeBoundingRadiusSq; }
+	float GetScale(int axis) const { return axisScales[axis]; }
+	float GetHScale(int axis) const { return axisHScales[axis]; }
+	float GetHScaleSq(int axis) const { return axisHScalesSq[axis]; }
+	float GetOffset(int axis) const { return axisOffsets[axis]; }
+	bool IsSphere() const { return spherical; }
+
+
+	float3 axisScales;					// full-length axis scales
+	float3 axisHScales;					// half-length axis scales
+	float3 axisHScalesSq;				// half-length axis scales (squared)
+	float3 axisHIScales;				// half-length axis scales (inverted)
+	float3 axisOffsets;
+
+	float volumeBoundingRadius;			// radius of minimally-bounding sphere around volume
+	float volumeBoundingRadiusSq;		// squared radius of minimally-bounding sphere
+	int volumeType;
+	int testType;
+	int primaryAxis;
+	int secondaryAxes[2];
+	bool spherical;
+};
+
+#endif

Copied: branches/gml/rts/Sim/Misc/GroundBlockingObjectMap.cpp (from rev 5882, trunk/rts/Sim/Misc/GroundBlockingObjectMap.cpp)
===================================================================
--- branches/gml/rts/Sim/Misc/GroundBlockingObjectMap.cpp	                        (rev 0)
+++ branches/gml/rts/Sim/Misc/GroundBlockingObjectMap.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,162 @@
+#include &quot;GroundBlockingObjectMap.h&quot;
+
+#include &quot;Sim/Objects/SolidObject.h&quot;
+#include &quot;Sim/Path/PathManager.h&quot;
+
+
+CR_BIND(CGroundBlockingObjectMap, (1))
+CR_REG_METADATA(CGroundBlockingObjectMap, (
+				CR_MEMBER(groundBlockingObjectMap)
+				));
+
+
+CGroundBlockingObjectMap* groundBlockingObjectMap;
+
+
+CGroundBlockingObjectMap::CGroundBlockingObjectMap(int numSquares)
+{
+	groundBlockingObjectMap.resize(numSquares, NULL);
+}
+
+
+void CGroundBlockingObjectMap::AddGroundBlockingObject(CSolidObject *object)
+{
+	object-&gt;isMarkedOnBlockingMap=true;
+	object-&gt;mapPos=object-&gt;GetMapPos();
+	if(object-&gt;immobile){
+		object-&gt;mapPos.x&amp;=0xfffffe;
+		object-&gt;mapPos.y&amp;=0xfffffe;
+	}
+	int bx=object-&gt;mapPos.x;
+	int bz=object-&gt;mapPos.y;
+
+	int minXSqr = bx;
+	int minZSqr = bz;
+	int maxXSqr = bx + object-&gt;xsize;
+	int maxZSqr = bz + object-&gt;ysize;
+
+	for(int zSqr = minZSqr; zSqr &lt; maxZSqr; zSqr++)
+		for(int xSqr = minXSqr; xSqr &lt; maxXSqr; xSqr++)
+			if(!groundBlockingObjectMap[xSqr + zSqr*gs-&gt;mapx])
+				groundBlockingObjectMap[xSqr + zSqr*gs-&gt;mapx] = object;
+
+	// FIXME: needs dependency injection (observer pattern?)
+	if(!object-&gt;mobility &amp;&amp; pathManager)
+		pathManager-&gt;TerrainChange(minXSqr, minZSqr, maxXSqr, maxZSqr);
+}
+
+
+void CGroundBlockingObjectMap::AddGroundBlockingObject(CSolidObject *object, unsigned char *yardMap, unsigned char mask)
+{
+	object-&gt;isMarkedOnBlockingMap=true;
+	object-&gt;mapPos=object-&gt;GetMapPos();
+	if(object-&gt;immobile){
+		object-&gt;mapPos.x&amp;=0xfffffe;
+		object-&gt;mapPos.y&amp;=0xfffffe;
+	}
+	int bx=object-&gt;mapPos.x;
+	int bz=object-&gt;mapPos.y;
+
+	int minXSqr = bx;
+	int minZSqr = bz;
+	int maxXSqr = bx + object-&gt;xsize;
+	int maxZSqr = bz + object-&gt;ysize;
+
+	for(int z = 0; minZSqr + z &lt; maxZSqr; z++) {
+		for(int x = 0; minXSqr + x &lt; maxXSqr; x++) {
+			if(!groundBlockingObjectMap[minXSqr + x + (minZSqr + z)*gs-&gt;mapx]){
+				if(yardMap[x + z*object-&gt;xsize] &amp; mask) {
+					groundBlockingObjectMap[minXSqr + x + (minZSqr + z)*gs-&gt;mapx] = object;
+				}
+			}
+		}
+	}
+
+	// FIXME: needs dependency injection (observer pattern?)
+	if(!object-&gt;mobility &amp;&amp; pathManager)
+		pathManager-&gt;TerrainChange(minXSqr, minZSqr, maxXSqr, maxZSqr);
+}
+
+
+void CGroundBlockingObjectMap::RemoveGroundBlockingObject(CSolidObject *object)
+{
+	object-&gt;isMarkedOnBlockingMap=false;
+	int bx=object-&gt;mapPos.x;
+	int bz=object-&gt;mapPos.y;
+	int sx=object-&gt;xsize;
+	int sz=object-&gt;ysize;
+	for(int z = bz; z &lt; bz+sz; ++z)
+		for(int x = bx; x &lt; bx+sx; ++x)
+			if(groundBlockingObjectMap[x + z*gs-&gt;mapx]==object)
+				groundBlockingObjectMap[x + z*gs-&gt;mapx] = 0;
+
+	// FIXME: needs dependency injection (observer pattern?)
+	if(!object-&gt;mobility)
+		pathManager-&gt;TerrainChange(bx, bz, bx+sx, bz+sz);
+}
+
+
+/**
+Moves a ground blocking object from old position to the current on map.
+*/
+void CGroundBlockingObjectMap::MoveGroundBlockingObject(CSolidObject *object, float3 oldPos) {
+	RemoveGroundBlockingObject(object);
+	AddGroundBlockingObject(object);
+}
+
+
+/**
+Checks if a ground-square is blocked.
+If it's not blocked, then NULL is returned.
+If it's blocked, then a pointer to the blocking object is returned.
+*/
+CSolidObject* CGroundBlockingObjectMap::GroundBlocked(int mapSquare) {
+	if(mapSquare &lt; 0 || mapSquare &gt;= gs-&gt;mapSquares)
+		return NULL;
+	return groundBlockingObjectMap[mapSquare];
+}
+
+
+/**
+Checks if a ground-square is blocked.
+If it's not blocked, then NULL is returned.
+If it's blocked, then a pointer to the blocking object is returned.
+*/
+CSolidObject* CGroundBlockingObjectMap::GroundBlocked(float3 pos) {
+	int xSqr = int(pos.x / SQUARE_SIZE) % gs-&gt;mapx;
+	int zSqr = int(pos.z / SQUARE_SIZE) / gs-&gt;mapx;
+	return GroundBlocked(xSqr + zSqr*gs-&gt;mapx);
+}
+
+
+/**
+Opens up a yard in a blocked area.
+When a factory opens up, for example.
+*/
+void CGroundBlockingObjectMap::OpenBlockingYard(CSolidObject *yard, unsigned char *blockingMap) {
+	RemoveGroundBlockingObject(yard);
+	AddGroundBlockingObject(yard, blockingMap, 2);
+}
+
+
+/**
+Closes a yard, blocking the area.
+When a factory closes, for example.
+*/
+void CGroundBlockingObjectMap::CloseBlockingYard(CSolidObject *yard, unsigned char *blockingMap) {
+	RemoveGroundBlockingObject(yard);
+	AddGroundBlockingObject(yard, blockingMap, 1);
+}
+
+
+bool CGroundBlockingObjectMap::CanCloseYard(CSolidObject* yard)
+{
+	for(int z = yard-&gt;mapPos.y; z &lt; yard-&gt;mapPos.y + yard-&gt;ysize; ++z) {
+		for(int x = yard-&gt;mapPos.x; x &lt; yard-&gt;mapPos.x + yard-&gt;xsize; ++x) {
+			CSolidObject* c = groundBlockingObjectMap[z * gs-&gt;mapx + x];
+			if (c != NULL &amp;&amp; c != yard)
+				return false;
+		}
+	}
+	return true;
+}

Copied: branches/gml/rts/Sim/Misc/GroundBlockingObjectMap.h (from rev 5882, trunk/rts/Sim/Misc/GroundBlockingObjectMap.h)
===================================================================
--- branches/gml/rts/Sim/Misc/GroundBlockingObjectMap.h	                        (rev 0)
+++ branches/gml/rts/Sim/Misc/GroundBlockingObjectMap.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,33 @@
+#ifndef GROUNDBLOCKINGOBJECTMAP_H
+#define GROUNDBLOCKINGOBJECTMAP_H
+
+#include &quot;creg/creg.h&quot;
+#include &quot;float3.h&quot;
+
+class CSolidObject;
+
+class CGroundBlockingObjectMap
+{
+	CR_DECLARE(CGroundBlockingObjectMap);
+
+public:
+	CGroundBlockingObjectMap(int numSquares);
+	void AddGroundBlockingObject(CSolidObject *object);
+	void AddGroundBlockingObject(CSolidObject *object, unsigned char *blockingMap, unsigned char mask = 255);
+	void RemoveGroundBlockingObject(CSolidObject *object);
+	void MoveGroundBlockingObject(CSolidObject *object, float3 oldPos);
+	void OpenBlockingYard(CSolidObject *yard, unsigned char *blockingMap);
+	void CloseBlockingYard(CSolidObject *yard, unsigned char *blockingMap);
+	bool CanCloseYard(CSolidObject* object);
+	CSolidObject* GroundBlocked(float3 pos);
+	CSolidObject* GroundBlocked(int mapSquare);
+	///simple version of GroundBlocked without error checking
+	CSolidObject* GroundBlockedUnsafe(int mapSquare){return groundBlockingObjectMap[mapSquare];}
+
+private:
+	std::vector&lt;CSolidObject*&gt; groundBlockingObjectMap;
+};
+
+extern CGroundBlockingObjectMap* groundBlockingObjectMap;
+
+#endif

Modified: branches/gml/rts/Sim/Misc/LosHandler.h
===================================================================
--- branches/gml/rts/Sim/Misc/LosHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Misc/LosHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -54,38 +54,72 @@
 	CR_DECLARE_SUB(DelayedInstance);
 
 public:
-	void MoveUnit(CUnit* unit,bool redoCurrent);
+	void MoveUnit(CUnit* unit, bool redoCurrent);
 	void FreeInstance(LosInstance* instance);
 
-	bool InLos(const CUnit* unit, int allyteam) {
-		if(unit-&gt;isCloaked)
+	bool InLos(const CUnit* unit, int allyTeam) {
+		if (unit-&gt;isCloaked)
 			return false;
-		if(unit-&gt;alwaysVisible)
+		if (unit-&gt;alwaysVisible)
 			return true;
-		if(unit-&gt;useAirLos){
-			return !!airLosMap[allyteam][(max(0,min(airSizeY-1,((int(unit-&gt;pos.z*invAirDiv)))))*airSizeX) + max(0,min(airSizeX-1,((int(unit-&gt;pos.x*invAirDiv)))))];
+		if (unit-&gt;useAirLos) {
+			const int rowIdx = std::max(0, std::min(airSizeY - 1, ((int(unit-&gt;pos.z * invAirDiv))))) * airSizeX;
+			const int colIdx = std::max(0, std::min(airSizeX - 1, ((int(unit-&gt;pos.x * invAirDiv)))));
+			const int square = rowIdx + colIdx;
+			#ifdef DEBUG
+			assert(square &lt; airLosMap[allyTeam].size());
+			#endif
+			return !!airLosMap[allyTeam][square];
 		} else {
-			if(unit-&gt;isUnderWater &amp;&amp; !radarhandler-&gt;InRadar(unit,allyteam))
+			if (unit-&gt;isUnderWater &amp;&amp; !radarhandler-&gt;InRadar(unit, allyTeam))
 				return false;
-			return !!losMap[allyteam][max(0,min(losSizeY-1,((int)(unit-&gt;pos.z*invLosDiv))))*losSizeX+ max(0,min(losSizeX-1,((int)(unit-&gt;pos.x*invLosDiv))))];
+
+			const int rowIdx = std::max(0, std::min(losSizeY - 1, ((int) (unit-&gt;pos.z * invLosDiv)))) * losSizeX;
+			const int colIdx = std::max(0, std::min(losSizeX - 1, ((int) (unit-&gt;pos.x * invLosDiv))));
+			const int square = rowIdx + colIdx;
+			#ifdef DEBUG
+			assert(square &lt; losMap[allyTeam].size());
+			#endif
+			return !!losMap[allyTeam][square];
 		}
 	}
 
-	bool InLos(const CWorldObject* object, int allyteam) {
-		if(object-&gt;useAirLos)
-			return !!airLosMap[allyteam][(max(0,min(airSizeY-1,((int(object-&gt;pos.z*invAirDiv)))))*airSizeX) + max(0,min(airSizeX-1,((int(object-&gt;pos.x*invAirDiv)))))] | object-&gt;alwaysVisible;
-		else
-			return !!losMap[allyteam][max(0,min(losSizeY-1,((int)(object-&gt;pos.z*invLosDiv))))*losSizeX+ max(0,min(losSizeX-1,((int)(object-&gt;pos.x*invLosDiv))))] | object-&gt;alwaysVisible;
+	bool InLos(const CWorldObject* object, int allyTeam) {
+		if (object-&gt;useAirLos) {
+			const int rowIdx = std::max(0, std::min(airSizeY - 1, ((int (object-&gt;pos.z * invAirDiv))))) * airSizeX;
+			const int colIdx = std::max(0, std::min(airSizeX - 1, ((int (object-&gt;pos.x * invAirDiv)))));
+			const int square = rowIdx + colIdx;
+			#ifdef DEBUG
+			assert(square &lt; airLosMap[allyTeam].size());
+			#endif
+			return !!airLosMap[allyTeam][square] | object-&gt;alwaysVisible;
+		} else {
+			const int rowIdx = std::max(0, std::min(losSizeY - 1, ((int) (object-&gt;pos.z * invLosDiv)))) * losSizeX;
+			const int colIdx = std::max(0, std::min(losSizeX - 1, ((int) (object-&gt;pos.x * invLosDiv))));
+			const int square = rowIdx + colIdx;
+			#ifdef DEBUG
+			assert(square &lt; losMap[allyTeam].size());
+			#endif
+			return !!losMap[allyTeam][square] | object-&gt;alwaysVisible;
+		}
 	}
 
-	bool InLos(float3 pos, int allyteam) {
+	bool InLos(float3 pos, int allyTeam) {
 		pos.CheckInBounds();
-		return !!losMap[allyteam][((int)(pos.z*invLosDiv))*losSizeX+((int)(pos.x*invLosDiv))];
+		const int square = ((int) (pos.z * invLosDiv)) * losSizeX + ((int) (pos.x * invLosDiv));
+		#ifdef DEBUG
+		assert(square &lt; losMap[allyTeam].size());
+		#endif
+		return !!losMap[allyTeam][square];
 	}
 
-	bool InAirLos(float3 pos, int allyteam) {
+	bool InAirLos(float3 pos, int allyTeam) {
 		pos.CheckInBounds();
-		return !!airLosMap[allyteam][((int)(pos.z*invAirDiv))*airSizeX+((int)(pos.x*invAirDiv))];
+		const int square = ((int) (pos.z * invAirDiv)) * airSizeX + ((int) (pos.x * invAirDiv));
+		#ifdef DEBUG
+		assert(square &lt; airLosMap[allyTeam].size());
+		#endif
+		return !!airLosMap[allyTeam][square];
 	}
 
 	CLosHandler();

Modified: branches/gml/rts/Sim/Misc/QuadField.cpp
===================================================================
--- branches/gml/rts/Sim/Misc/QuadField.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Misc/QuadField.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -67,11 +67,11 @@
 	pos.CheckInBounds();
 
 	vector&lt;int&gt; ret;
-	int maxx = min(((int)(pos.x + radius)) / QUAD_SIZE + 1, numQuadsX - 1);
-	int maxz = min(((int)(pos.z + radius)) / QUAD_SIZE + 1, numQuadsZ - 1);
+	int maxx = std::min(((int)(pos.x + radius)) / QUAD_SIZE + 1, numQuadsX - 1);
+	int maxz = std::min(((int)(pos.z + radius)) / QUAD_SIZE + 1, numQuadsZ - 1);
 
-	int minx = max(((int)(pos.x - radius)) / QUAD_SIZE, 0);
-	int minz = max(((int)(pos.z - radius)) / QUAD_SIZE, 0);
+	int minx = std::max(((int)(pos.x - radius)) / QUAD_SIZE, 0);
+	int minz = std::max(((int)(pos.z - radius)) / QUAD_SIZE, 0);
 
 	if (maxz &lt; minz || maxx &lt; minx)
 		return ret;
@@ -91,11 +91,11 @@
 {
 	pos.CheckInBounds();
 
-	int maxx = min(((int)(pos.x + radius)) / QUAD_SIZE + 1, numQuadsX - 1);
-	int maxz = min(((int)(pos.z + radius)) / QUAD_SIZE + 1, numQuadsZ - 1);
+	int maxx = std::min(((int)(pos.x + radius)) / QUAD_SIZE + 1, numQuadsX - 1);
+	int maxz = std::min(((int)(pos.z + radius)) / QUAD_SIZE + 1, numQuadsZ - 1);
 
-	int minx = max(((int)(pos.x - radius)) / QUAD_SIZE, 0);
-	int minz = max(((int)(pos.z - radius)) / QUAD_SIZE, 0);
+	int minx = std::max(((int)(pos.x - radius)) / QUAD_SIZE, 0);
+	int minz = std::max(((int)(pos.z - radius)) / QUAD_SIZE, 0);
 
 	if (maxz &lt; minz || maxx &lt; minx)
 		return;
@@ -124,10 +124,10 @@
 		if(qi2==newQuads.end())
 			return;
 	}
-	vector&lt;int&gt;::iterator qi;
-	for(qi=unit-&gt;quads.begin();qi!=unit-&gt;quads.end();++qi){
-		list&lt;CUnit*&gt;::iterator ui;
-		for(ui=baseQuads[*qi].units.begin();ui!=baseQuads[*qi].units.end();++ui){
+	std::vector&lt;int&gt;::iterator qi;
+	for (qi = unit-&gt;quads.begin(); qi != unit-&gt;quads.end(); ++qi) {
+		std::list&lt;CUnit*&gt;::iterator ui;
+		for (ui = baseQuads[*qi].units.begin(); ui != baseQuads[*qi].units.end(); ++ui) {
 			if(*ui==unit){
 				baseQuads[*qi].units.erase(ui);
 				break;
@@ -147,9 +147,9 @@
 	unit-&gt;quads=newQuads;
 }
 
-vector&lt;CUnit*&gt; CQuadField::GetUnits(const float3&amp; pos,float radius)
+std::vector&lt;CUnit*&gt; CQuadField::GetUnits(const float3&amp; pos,float radius)
 {
-	vector&lt;CUnit*&gt; units;
+	std::vector&lt;CUnit*&gt; units;
 
 	int* endQuad=tempQuads;
 	GetQuads(pos,radius,endQuad);
@@ -158,8 +158,8 @@
 
 	for(int* a=tempQuads;a!=endQuad;++a){
 		Quad&amp; quad = baseQuads[*a];
-		for(list&lt;CUnit*&gt;::iterator ui=quad.units.begin();ui!=quad.units.end();++ui){
-			if((*ui)-&gt;tempNum!=tempNum){
+		for (std::list&lt;CUnit*&gt;::iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+			if ((*ui)-&gt;tempNum!=tempNum){
 				(*ui)-&gt;tempNum=tempNum;
 				units.push_back(*ui);
 			}
@@ -169,22 +169,18 @@
 	return units;
 }
 
-vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; pos,float radius)
+std::vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; pos,float radius)
 {
-	vector&lt;CUnit*&gt; units;
-/*	if(pos.x&lt;0 || pos.z&lt;0 || pos.x&gt;gs-&gt;mapx*SQUARE_SIZE || pos.z&gt;gs-&gt;mapy*SQUARE_SIZE){
-		logOutput.Print(&quot;Trying to get units outside map %.0f %.0f&quot;,pos.x,pos.z);
-		return units;
-	}*/
+	std::vector&lt;CUnit*&gt; units;
 
 	int* endQuad=tempQuads;
 	GetQuads(pos,radius,endQuad);
 
 	int tempNum=gs-&gt;tempNum++;
 
-	for(int* a=tempQuads;a!=endQuad;++a){
+	for (int* a=tempQuads;a!=endQuad;++a){
 		Quad&amp; quad = baseQuads[*a];
-		for(list&lt;CUnit*&gt;::iterator ui=quad.units.begin();ui!=quad.units.end();++ui){
+		for (std::list&lt;CUnit*&gt;::iterator ui=quad.units.begin();ui!=quad.units.end();++ui){
 			float totRad=radius+(*ui)-&gt;radius;
 			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; (pos-(*ui)-&gt;midPos).SqLength()&lt;totRad*totRad){
 				(*ui)-&gt;tempNum=tempNum;
@@ -196,18 +192,17 @@
 	return units;
 }
 
-vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; mins, const float3&amp; maxs)
+std::vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; mins, const float3&amp; maxs)
 {
-	vector&lt;CUnit*&gt; units;
+	std::vector&lt;CUnit*&gt; units;
+	std::vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
 
-	vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
-
 	int tempNum = gs-&gt;tempNum++;
 
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
-		list&lt;CUnit*&gt;&amp; quadUnits = baseQuads[*qi].units;
-		list&lt;CUnit*&gt;::iterator ui;
+		std::list&lt;CUnit*&gt;&amp; quadUnits = baseQuads[*qi].units;
+		std::list&lt;CUnit*&gt;::iterator ui;
 		for (ui = quadUnits.begin(); ui != quadUnits.end(); ++ui) {
 			CUnit* unit = *ui;
 			const float3&amp; pos = unit-&gt;midPos;
@@ -223,12 +218,12 @@
 	return units;
 }
 
-vector&lt;int&gt; CQuadField::GetQuadsOnRay(const float3&amp; start, float3 dir, float length)
+std::vector&lt;int&gt; CQuadField::GetQuadsOnRay(const float3&amp; start, float3 dir, float length)
 {
 	int* end = tempQuads;
 	GetQuadsOnRay(start,dir,length,end);
 
-	return vector&lt;int&gt;(tempQuads,end);
+	return std::vector&lt;int&gt;(tempQuads, end);
 }
 
 void CQuadField::GetQuadsOnRay(float3 start, float3 dir,float length, int*&amp; dst)
@@ -366,9 +361,9 @@
 void CQuadField::RemoveUnit(CUnit* unit)
 {
 	std::vector&lt;int&gt;::iterator qi;
-	for(qi=unit-&gt;quads.begin();qi!=unit-&gt;quads.end();++qi){
-		list&lt;CUnit*&gt;::iterator ui;
-		for(ui=baseQuads[*qi].units.begin();ui!=baseQuads[*qi].units.end();++ui){
+	for (qi = unit-&gt;quads.begin(); qi != unit-&gt;quads.end(); ++qi) {
+		std::list&lt;CUnit*&gt;::iterator ui;
+		for (ui = baseQuads[*qi].units.begin(); ui != baseQuads[*qi].units.end(); ++ui) {
 			if(*ui==unit){
 				baseQuads[*qi].units.erase(ui);
 				break;
@@ -415,10 +410,10 @@
 
 	int tempNum=gs-&gt;tempNum++;
 
-	vector&lt;int&gt;::iterator qi;
-	for(qi=quads.begin();qi!=quads.end();++qi){
-		list&lt;CFeature*&gt;::iterator fi;
-		for(fi=baseQuads[*qi].features.begin();fi!=baseQuads[*qi].features.end();++fi){
+	std::vector&lt;int&gt;::iterator qi;
+	for (qi = quads.begin(); qi != quads.end(); ++qi) {
+		std::list&lt;CFeature*&gt;::iterator fi;
+		for (fi = baseQuads[*qi].features.begin(); fi != baseQuads[*qi].features.end(); ++fi) {
 			float totRad=radius+(*fi)-&gt;radius;
 			if((*fi)-&gt;tempNum!=tempNum &amp;&amp; (pos-(*fi)-&gt;midPos).SqLength()&lt;totRad*totRad){
 				(*fi)-&gt;tempNum=tempNum;
@@ -430,19 +425,18 @@
 	return features;
 }
 
-vector&lt;CFeature*&gt; CQuadField::GetFeaturesExact(const float3&amp; mins,
+std::vector&lt;CFeature*&gt; CQuadField::GetFeaturesExact(const float3&amp; mins,
                                                const float3&amp; maxs)
 {
-	vector&lt;CFeature*&gt; features;
+	std::vector&lt;CFeature*&gt; features;
+	std::vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
 
-	vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
-
 	int tempNum = gs-&gt;tempNum++;
 
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for(qi = quads.begin(); qi != quads.end(); ++qi) {
-		list&lt;CFeature*&gt;&amp; quadFeatures = baseQuads[*qi].features;
-		list&lt;CFeature*&gt;::iterator fi;
+		std::list&lt;CFeature*&gt;&amp; quadFeatures = baseQuads[*qi].features;
+		std::list&lt;CFeature*&gt;::iterator fi;
 		for (fi = quadFeatures.begin(); fi != quadFeatures.end(); ++fi) {
 			CFeature* feature = *fi;
 			const float3&amp; pos = feature-&gt;midPos;
@@ -458,22 +452,16 @@
 	return features;
 }
 
-vector&lt;CSolidObject*&gt; CQuadField::GetSolidsExact(const float3&amp; pos,float radius)
+std::vector&lt;CSolidObject*&gt; CQuadField::GetSolidsExact(const float3&amp; pos,float radius)
 {
-	vector&lt;CSolidObject*&gt; solids;
-/*	if(pos.x&lt;0 || pos.z&lt;0 || pos.x&gt;gs-&gt;mapx*SQUARE_SIZE || pos.z&gt;gs-&gt;mapy*SQUARE_SIZE){
-		logOutput.Print(&quot;Trying to get units outside map %.0f %.0f&quot;,pos.x,pos.z);
-		return units;
-	}*/
+	std::vector&lt;CSolidObject*&gt; solids;
+	std::vector&lt;int&gt; quads = GetQuads(pos,radius);
+	int tempNum = gs-&gt;tempNum++;
 
-	vector&lt;int&gt; quads=GetQuads(pos,radius);
-
-	int tempNum=gs-&gt;tempNum++;
-
-	vector&lt;int&gt;::iterator qi;
-	for(qi=quads.begin();qi!=quads.end();++qi){
-		list&lt;CUnit*&gt;::iterator ui;
-		for(ui=baseQuads[*qi].units.begin();ui!=baseQuads[*qi].units.end();++ui){
+	std::vector&lt;int&gt;::iterator qi;
+	for (qi = quads.begin(); qi != quads.end(); ++qi) {
+		std::list&lt;CUnit*&gt;::iterator ui;
+		for (ui = baseQuads[*qi].units.begin(); ui != baseQuads[*qi].units.end(); ++ui) {
 			if (!(*ui)-&gt;blocking)
 				continue;
 
@@ -484,7 +472,7 @@
 			}
 		}
 
-		list&lt;CFeature*&gt;::iterator fi;
+		std::list&lt;CFeature*&gt;::iterator fi;
 		for(fi=baseQuads[*qi].features.begin();fi!=baseQuads[*qi].features.end();++fi){
 			if (!(*fi)-&gt;blocking)
 				continue;
@@ -500,15 +488,15 @@
 	return solids;
 }
 
-vector&lt;int&gt; CQuadField::GetQuadsRectangle(const float3&amp; pos,const float3&amp; pos2)
+std::vector&lt;int&gt; CQuadField::GetQuadsRectangle(const float3&amp; pos,const float3&amp; pos2)
 {
-	vector&lt;int&gt; ret;
+	std::vector&lt;int&gt; ret;
 
-	int maxx = max(0, min(((int)(pos2.x)) / QUAD_SIZE + 1, numQuadsX - 1));
-	int maxz = max(0, min(((int)(pos2.z)) / QUAD_SIZE + 1, numQuadsZ - 1));
+	int maxx = std::max(0, std::min(((int)(pos2.x)) / QUAD_SIZE + 1, numQuadsX - 1));
+	int maxz = std::max(0, std::min(((int)(pos2.z)) / QUAD_SIZE + 1, numQuadsZ - 1));
 
-	int minx = max(0, min(((int)(pos.x)) / QUAD_SIZE, numQuadsX - 1));
-	int minz = max(0, min(((int)(pos.z)) / QUAD_SIZE, numQuadsZ - 1));
+	int minx = std::max(0, std::min(((int)(pos.x)) / QUAD_SIZE, numQuadsX - 1));
+	int minz = std::max(0, std::min(((int)(pos.z)) / QUAD_SIZE, numQuadsZ - 1));
 
 	if (maxz &lt; minz || maxx &lt; minx)
 		return ret;
@@ -531,7 +519,7 @@
 
 	for(int* a=tempQuads;a!=endQuad;++a){
 		Quad&amp; quad = baseQuads[*a];
-		for(list&lt;CUnit*&gt;::iterator ui=quad.units.begin();ui!=quad.units.end();++ui){
+		for (std::list&lt;CUnit*&gt;::iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;tempNum!=tempNum){
 				(*ui)-&gt;tempNum=tempNum;
 				*dstUnit=(*ui);
@@ -539,7 +527,7 @@
 			}
 		}
 
-		for(list&lt;CFeature*&gt;::iterator fi=quad.features.begin();fi!=quad.features.end();++fi){
+		for (std::list&lt;CFeature*&gt;::iterator fi = quad.features.begin(); fi != quad.features.end(); ++fi) {
 			float totRad=radius+(*fi)-&gt;radius;
 			if((*fi)-&gt;tempNum!=tempNum &amp;&amp; (pos-(*fi)-&gt;midPos).SqLength()&lt;totRad*totRad){
 				(*fi)-&gt;tempNum=tempNum;

Modified: branches/gml/rts/Sim/Misc/RadarHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Misc/RadarHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Misc/RadarHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,6 +3,7 @@
 #include &quot;TimeProfiler.h&quot;
 #include &quot;LosHandler.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND(CRadarHandler, (false));
@@ -130,17 +131,17 @@
 
 void CRadarHandler::AddMapArea(int2 pos, int radius, std::vector&lt;unsigned short&gt;&amp; map, int amount)
 {
-	int sx=max(0,pos.x-radius);
-	int ex=min(xsize-1,pos.x+radius);
-	int sy=max(0,pos.y-radius);
-	int ey=min(ysize-1,pos.y+radius);
+	int sx = std::max(0,pos.x-radius);
+	int ex = std::min(xsize-1,pos.x+radius);
+	int sy = std::max(0,pos.y-radius);
+	int ey = std::min(ysize-1,pos.y+radius);
 
-	int rr=radius*radius;
-	for(int y=sy;y&lt;=ey;++y){
-		int rrx=rr-(pos.y-y)*(pos.y-y);
-		for(int x=sx;x&lt;=ex;++x){
-			if((pos.x-x)*(pos.x-x)&lt;=rrx){
-				map[y*xsize+x]+=amount;
+	int rr = radius * radius;
+	for (int y = sy; y &lt;= ey; ++y) {
+		int rrx = rr - (pos.y - y) * (pos.y - y);
+		for (int x = sx; x &lt;= ex; ++x) {
+			if ((pos.x - x) * (pos.x - x) &lt;= rrx) {
+				map[y * xsize + x] += amount;
 			}
 		}
 	}

Modified: branches/gml/rts/Sim/Misc/RadarHandler.h
===================================================================
--- branches/gml/rts/Sim/Misc/RadarHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Misc/RadarHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -19,39 +19,67 @@
 	void MoveUnit(CUnit* unit);
 	void RemoveUnit(CUnit* unit);
 
-	bool InRadar(const float3&amp; pos, int allyteam) {
-		const int gx = (int)pos.x / (SQUARE_SIZE * RADAR_SIZE);
-		const int gz = (int)pos.z / (SQUARE_SIZE * RADAR_SIZE);
-		const int square = max(0, min(ysize - 1, gz)) * xsize +
-		                   max(0, min(xsize - 1, gx));
+	bool InRadar(const float3&amp; pos, int allyTeam) {
+		const int gx = (int) pos.x / (SQUARE_SIZE * RADAR_SIZE);
+		const int gz = (int) pos.z / (SQUARE_SIZE * RADAR_SIZE);
+		const int rowIdx = std::max(0, std::min(ysize - 1, gz)) * xsize;
+		const int colIdx = std::max(0, std::min(xsize - 1, gx));
+		const int square = rowIdx + colIdx;
 		if (pos.y &lt; -0.5f) {
-			return (sonarMaps[allyteam][square] &amp;&amp; !commonSonarJammerMap[square]);
+			#ifdef DEBUG
+			assert(square &lt; sonarMaps[allyTeam].size());
+			#endif
+			return (sonarMaps[allyTeam][square] &amp;&amp; !commonSonarJammerMap[square]);
 		}
-		else if (!circularRadar &amp;&amp; pos.y &gt; +0.5f) {
-			return (airRadarMaps[allyteam][square] &amp;&amp; !commonJammerMap[square]);
+		else if (!circularRadar &amp;&amp; pos.y &gt; 0.5f) {
+			#ifdef DEBUG
+			assert(square &lt; airRadarMaps[allyTeam].size());
+			#endif
+			return (airRadarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square]);
 		}
 		else {
-			return (radarMaps[allyteam][square] &amp;&amp; !commonJammerMap[square]);
+			#ifdef DEBUG
+			assert(square &lt; radarMaps[allyTeam].size());
+			#endif
+			return (radarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square]);
 		}
 	}
 
-	bool InRadar(const CUnit* unit, int allyteam) {
-		if(unit-&gt;stealth)
+	bool InRadar(const CUnit* unit, int allyTeam) {
+		if (unit-&gt;stealth)
 			return false;
-		int square=max(0,min(ysize-1,(int)unit-&gt;pos.z/(SQUARE_SIZE*RADAR_SIZE)))*xsize+max(0,min(xsize-1,(int)unit-&gt;pos.x/(SQUARE_SIZE*RADAR_SIZE)));
-		if(unit-&gt;isUnderWater){
-			return (!!sonarMaps[allyteam][square]) &amp;&amp; !commonSonarJammerMap[square];
+
+		const int rowIdx = std::max(0, std::min(ysize - 1, (int) unit-&gt;pos.z / (SQUARE_SIZE * RADAR_SIZE))) * xsize;
+		const int colIdx = std::max(0, std::min(xsize - 1, (int) unit-&gt;pos.x / (SQUARE_SIZE * RADAR_SIZE)));
+		const int square = rowIdx + colIdx;
+
+		if (unit-&gt;isUnderWater) {
+			#ifdef DEBUG
+			assert(square &lt; sonarMaps[allyTeam].size());
+			#endif
+			return (!!sonarMaps[allyTeam][square]) &amp;&amp; !commonSonarJammerMap[square];
 		}
-		if(!circularRadar &amp;&amp; unit-&gt;useAirLos){
-			return airRadarMaps[allyteam][square] &amp;&amp; !commonJammerMap[square];
+		if (!circularRadar &amp;&amp; unit-&gt;useAirLos) {
+			#ifdef DEBUG
+			assert(square &lt; airRadarMaps[allyTeam].size());
+			#endif
+			return airRadarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square];
 		} else {
-			return (radarMaps[allyteam][square] || (unit-&gt;pos.y&lt;=1 &amp;&amp; sonarMaps[allyteam][square])) &amp;&amp; !commonJammerMap[square];
+			#ifdef DEBUG
+			assert(square &lt; radarMaps[allyTeam].size() &amp;&amp; square &lt; sonarMaps[allyTeam].size());
+			#endif
+			return (radarMaps[allyTeam][square] || (unit-&gt;pos.y &lt;= 1 &amp;&amp; sonarMaps[allyTeam][square])) &amp;&amp; !commonJammerMap[square];
 		}
 	}
 
-	bool InSeismicDistance(const CUnit* unit, int allyteam) {
-		int square=max(0,min(ysize-1,(int)unit-&gt;pos.z/(SQUARE_SIZE*RADAR_SIZE)))*xsize+max(0,min(xsize-1,(int)unit-&gt;pos.x/(SQUARE_SIZE*RADAR_SIZE)));
-		return !!seismicMaps[allyteam][square];
+	bool InSeismicDistance(const CUnit* unit, int allyTeam) {
+		const int rowIdx = std::max(0, std::min(ysize - 1, (int) unit-&gt;pos.z / (SQUARE_SIZE * RADAR_SIZE))) * xsize;
+		const int colIdx = std::max(0, std::min(xsize - 1, (int) unit-&gt;pos.x / (SQUARE_SIZE * RADAR_SIZE)));
+		const int square = rowIdx + colIdx;
+		#ifdef DEBUG
+		assert(square &lt; seismicMaps[allyTeam].size());
+		#endif
+		return !!seismicMaps[allyTeam][square];
 	}
 
 	bool circularRadar;

Modified: branches/gml/rts/Sim/Misc/Wind.cpp
===================================================================
--- branches/gml/rts/Sim/Misc/Wind.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Misc/Wind.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,7 +1,7 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;Wind.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
-#include &quot;Map/ReadMap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND(CWind, );
@@ -46,8 +46,8 @@
 void CWind::LoadWind()
 {
 	// TODO: decouple
-	readmap-&gt;mapDefParser.GetDef(minWind,&quot;5&quot;,&quot;MAP\\ATMOSPHERE\\MinWind&quot;);
-	readmap-&gt;mapDefParser.GetDef(maxWind,&quot;25&quot;,&quot;MAP\\ATMOSPHERE\\MaxWind&quot;);
+	minWind = mapInfo-&gt;atmosphere.minWind;
+	maxWind = mapInfo-&gt;atmosphere.maxWind;
 }
 
 

Modified: branches/gml/rts/Sim/MoveTypes/AAirMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/AAirMoveType.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/AAirMoveType.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,58 +1,59 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;AAirMoveType.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
-
-
-CR_BIND_DERIVED_INTERFACE(AAirMoveType, AMoveType);
-
-CR_REG_METADATA(AAirMoveType, (
-		CR_MEMBER(oldGoalPos),
-		CR_MEMBER(oldpos),
-		CR_MEMBER(reservedLandingPos),
-		CR_MEMBER(wantedHeight),
-		
-		CR_MEMBER(lastColWarning),
-		CR_MEMBER(lastColWarningType),
-		CR_MEMBER(collide),
-		
-		CR_MEMBER(autoLand),
-		
-		CR_RESERVED(16)
-		));
-
-AAirMoveType::AAirMoveType(CUnit* unit) :
-	AMoveType(unit),
-	aircraftState(AIRCRAFT_LANDED),
-	autoLand(true),
-	collide(true),
-	lastColWarning(0),
-	lastColWarningType(0),
-	oldpos(0,0,0),
-	oldGoalPos(owner? owner-&gt;pos:float3(0, 0, 0)),
-	reservedLandingPos(-1,-1,-1),
-	wantedHeight(80)
-{
-}
-
-AAirMoveType::~AAirMoveType()
-{
-	if (reservedPad) {
-		airBaseHandler-&gt;LeaveLandingPad(reservedPad);
-		reservedPad = 0;
-	}
-}
-
-void AAirMoveType::ReservePad(CAirBaseHandler::LandingPad* lp) {
-	oldGoalPos = goalPos;
-	AMoveType::ReservePad(lp);
-	Takeoff();
-}
-
-void AAirMoveType::DependentDied(CObject* o)
-{
-	AMoveType::DependentDied(o);
-	if(o == reservedPad){
-		SetState(AIRCRAFT_FLYING);
-		goalPos=oldGoalPos;
-	}
-}
+#include &quot;StdAfx.h&quot;
+#include &quot;AAirMoveType.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+
+
+CR_BIND_DERIVED_INTERFACE(AAirMoveType, AMoveType);
+
+CR_REG_METADATA(AAirMoveType, (
+		CR_MEMBER(oldGoalPos),
+		CR_MEMBER(oldpos),
+		CR_MEMBER(reservedLandingPos),
+		CR_MEMBER(wantedHeight),
+		
+		CR_MEMBER(lastColWarning),
+		CR_MEMBER(lastColWarningType),
+		CR_MEMBER(collide),
+		
+		CR_MEMBER(autoLand),
+		
+		CR_RESERVED(16)
+		));
+
+AAirMoveType::AAirMoveType(CUnit* unit) :
+	AMoveType(unit),
+	aircraftState(AIRCRAFT_LANDED),
+	autoLand(true),
+	collide(true),
+	lastColWarning(0),
+	lastColWarningType(0),
+	oldpos(0,0,0),
+	oldGoalPos(owner? owner-&gt;pos:float3(0, 0, 0)),
+	reservedLandingPos(-1,-1,-1),
+	wantedHeight(80)
+{
+	useHeading = false;
+}
+
+AAirMoveType::~AAirMoveType()
+{
+	if (reservedPad) {
+		airBaseHandler-&gt;LeaveLandingPad(reservedPad);
+		reservedPad = 0;
+	}
+}
+
+void AAirMoveType::ReservePad(CAirBaseHandler::LandingPad* lp) {
+	oldGoalPos = goalPos;
+	AMoveType::ReservePad(lp);
+	Takeoff();
+}
+
+void AAirMoveType::DependentDied(CObject* o)
+{
+	AMoveType::DependentDied(o);
+	if(o == reservedPad){
+		SetState(AIRCRAFT_FLYING);
+		goalPos=oldGoalPos;
+	}
+}


Property changes on: branches/gml/rts/Sim/MoveTypes/AAirMoveType.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Sim/MoveTypes/AAirMoveType.h
===================================================================
--- branches/gml/rts/Sim/MoveTypes/AAirMoveType.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/AAirMoveType.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,47 +1,47 @@
-#ifndef AAIRMOVETYPE_H_
-#define AAIRMOVETYPE_H_
-
-#include &quot;MoveType.h&quot;
-#include &quot;Sim/Misc/AirBaseHandler.h&quot;
-
-// Supposed to be an abstract class. Do not create an instance of this class.
-// Use either CTAAirMoveType or CAirMoveType instead.
-class AAirMoveType : public AMoveType
-{
-	CR_DECLARE(AAirMoveType);
-public:
-	
-	enum AircraftState{
-		AIRCRAFT_LANDED,
-		AIRCRAFT_FLYING,
-		AIRCRAFT_LANDING,
-		AIRCRAFT_CRASHING,
-		AIRCRAFT_TAKEOFF,
-		AIRCRAFT_HOVERING       // this is what happens to aircraft with dontLand=1 in fbi
-	} aircraftState;
-	
-	AAirMoveType(CUnit* unit);
-	~AAirMoveType();
-	
-	float3 oldGoalPos;				//goalpos to resume flying to after landing
-	float3 oldpos;
-	float3 reservedLandingPos;
-	
-	float wantedHeight;
-	
-	bool collide;             //mods can use this to disable plane collisions
-	CUnit* lastColWarning;		//unit found to be dangerously close to our path
-	int lastColWarningType;		//1=generally forward of us,2=directly in path
-	
-	bool autoLand;
-
-	virtual bool IsFighter() = 0;
-	virtual void Takeoff() = 0;
-	void ReservePad(CAirBaseHandler::LandingPad* lp);
-	void DependentDied(CObject* o);
-	
-protected:
-	virtual void SetState(AircraftState state) = 0;
-};
-
-#endif /*AAIRMOVETYPE_H_*/
+#ifndef AAIRMOVETYPE_H_
+#define AAIRMOVETYPE_H_
+
+#include &quot;MoveType.h&quot;
+#include &quot;Sim/Misc/AirBaseHandler.h&quot;
+
+// Supposed to be an abstract class. Do not create an instance of this class.
+// Use either CTAAirMoveType or CAirMoveType instead.
+class AAirMoveType : public AMoveType
+{
+	CR_DECLARE(AAirMoveType);
+public:
+	
+	enum AircraftState{
+		AIRCRAFT_LANDED,
+		AIRCRAFT_FLYING,
+		AIRCRAFT_LANDING,
+		AIRCRAFT_CRASHING,
+		AIRCRAFT_TAKEOFF,
+		AIRCRAFT_HOVERING       // this is what happens to aircraft with dontLand=1 in fbi
+	} aircraftState;
+	
+	AAirMoveType(CUnit* unit);
+	~AAirMoveType();
+	
+	float3 oldGoalPos;				//goalpos to resume flying to after landing
+	float3 oldpos;
+	float3 reservedLandingPos;
+	
+	float wantedHeight;
+	
+	bool collide;             //mods can use this to disable plane collisions
+	CUnit* lastColWarning;		//unit found to be dangerously close to our path
+	int lastColWarningType;		//1=generally forward of us,2=directly in path
+	
+	bool autoLand;
+
+	virtual bool IsFighter() = 0;
+	virtual void Takeoff() = 0;
+	void ReservePad(CAirBaseHandler::LandingPad* lp);
+	void DependentDied(CObject* o);
+	
+protected:
+	virtual void SetState(AircraftState state) = 0;
+};
+
+#endif /*AAIRMOVETYPE_H_*/


Property changes on: branches/gml/rts/Sim/MoveTypes/AAirMoveType.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,10 +4,12 @@
 #include &quot;Game/Player.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Mobility.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
@@ -217,7 +219,7 @@
 			owner-&gt;pos = pos;
 
 			owner-&gt;AddBuildPower(unit-&gt;unitDef-&gt;buildSpeed/30,unit);
-			owner-&gt;currentFuel = min (owner-&gt;unitDef-&gt;maxFuel, owner-&gt;currentFuel + (owner-&gt;unitDef-&gt;maxFuel / (GAME_SPEED * owner-&gt;unitDef-&gt;refuelTime)));
+			owner-&gt;currentFuel = std::min (owner-&gt;unitDef-&gt;maxFuel, owner-&gt;currentFuel + (owner-&gt;unitDef-&gt;maxFuel / (GAME_SPEED * owner-&gt;unitDef-&gt;refuelTime)));
 
 			if (owner-&gt;health &gt;= owner-&gt;maxHealth - 1 &amp;&amp; owner-&gt;currentFuel &gt;= owner-&gt;unitDef-&gt;maxFuel) {
 				airBaseHandler-&gt;LeaveLandingPad(reservedPad);
@@ -239,7 +241,7 @@
 #endif
 		owner-&gt;restTime = 0;
 		if (owner-&gt;userTarget || owner-&gt;userAttackGround) {
-			inefficientAttackTime = min(inefficientAttackTime, (float)gs-&gt;frameNum - owner-&gt;lastFireWeapon);
+			inefficientAttackTime = std::min(inefficientAttackTime, (float)gs-&gt;frameNum - owner-&gt;lastFireWeapon);
 			if (owner-&gt;userTarget) {
 				goalPos = owner-&gt;userTarget-&gt;pos;
 			} else {
@@ -272,7 +274,7 @@
 		owner-&gt;crashing = true;
 		UpdateAirPhysics(crashRudder, crashAileron, crashElevator, 0, owner-&gt;frontdir);
 		SAFE_NEW CSmokeProjectile(owner-&gt;midPos, gs-&gt;randVector() * 0.08f, 100 + gs-&gt;randFloat() * 50, 5, 0.2f, owner, 0.4f);
-		if (!(gs-&gt;frameNum &amp; 3) &amp;&amp; max(0.f, ground-&gt;GetApproximateHeight(pos.x, pos.z)) + 5 + owner-&gt;radius &gt; pos.y)
+		if (!(gs-&gt;frameNum &amp; 3) &amp;&amp; std::max(0.f, ground-&gt;GetApproximateHeight(pos.x, pos.z)) + 5 + owner-&gt;radius &gt; pos.y)
 			owner-&gt;KillUnit(true, false, 0);
 		break;
 	case AIRCRAFT_TAKEOFF:
@@ -303,7 +305,7 @@
 
 					if ((*ui)-&gt;immobile) {
 						pos -= dif * (dist - totRad);
-						owner-&gt;midPos = pos + owner-&gt;frontdir * owner-&gt;relMidPos.z + owner-&gt;updir * owner-&gt;relMidPos.y + owner-&gt;rightdir * owner-&gt;relMidPos.x;
+						owner-&gt;UpdateMidPos();
 						owner-&gt;speed *= 0.99f;
 						float damage = (((*ui)-&gt;speed - owner-&gt;speed) * 0.1f).SqLength();
 						owner-&gt;DoDamage(DamageArray() * damage, 0, ZeroVector);
@@ -312,10 +314,10 @@
 					} else {
 						float part = owner-&gt;mass / (owner-&gt;mass + (*ui)-&gt;mass);
 						pos -= dif * (dist - totRad) * (1 - part);
-						owner-&gt;midPos = pos + owner-&gt;frontdir * owner-&gt;relMidPos.z + owner-&gt;updir * owner-&gt;relMidPos.y + owner-&gt;rightdir * owner-&gt;relMidPos.x;
+						owner-&gt;UpdateMidPos();
 						CUnit* u = (CUnit*)(*ui);
 						u-&gt;pos += dif * (dist - totRad) * (part);
-						u-&gt;midPos = u-&gt;pos + u-&gt;frontdir * u-&gt;relMidPos.z + u-&gt;updir * u-&gt;relMidPos.y + u-&gt;rightdir * u-&gt;relMidPos.x;
+						u-&gt;UpdateMidPos();
 						float damage = (((*ui)-&gt;speed - owner-&gt;speed) * 0.1f).SqLength();
 						owner-&gt;DoDamage(DamageArray() * damage, 0, ZeroVector);
 						(*ui)-&gt;DoDamage(DamageArray() * damage, 0, ZeroVector);
@@ -371,7 +373,7 @@
 void CAirMoveType::SlowUpdate(void)
 {
 	if (aircraftState != AIRCRAFT_LANDED &amp;&amp; owner-&gt;unitDef-&gt;maxFuel &gt; 0)
-		owner-&gt;currentFuel = max (0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
+		owner-&gt;currentFuel = std::max(0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
 
 	if (owner-&gt;pos != oldSlowUpdatePos) {
 		oldSlowUpdatePos = owner-&gt;pos;
@@ -514,7 +516,7 @@
 	}
 
 	//roll
-	if (speedf &gt; 0.45f &amp;&amp; pos.y + owner-&gt;speed.y * 60 * fabs(frontdir.y) + min(0.f, updir.y) * 150 &gt; gHeight + 60 + fabs(rightdir.y) * 150) {
+	if (speedf &gt; 0.45f &amp;&amp; pos.y + owner-&gt;speed.y * 60 * fabs(frontdir.y) + std::min(0.0f, float(updir.y)) * 150 &gt; gHeight + 60 + fabs(rightdir.y) * 150) {
 		float goalBankDif = goalDot + rightdir.y * 0.2f;
 		if (goalBankDif &gt; maxAileron * speedf * 4) {
 			aileron = 1;
@@ -561,7 +563,7 @@
 		}
 	} else {
 		float gHeight2 = ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40);
-		float hdif = max(gHeight, gHeight2) + 60 - pos.y - frontdir.y * speedf * 20;
+		float hdif = std::max(gHeight, gHeight2) + 60 - pos.y - frontdir.y * speedf * 20;
 		float minPitch;//=min(1.0f,hdif/(maxElevator*speedf*speedf*20));
 
 		if (hdif &lt; -(maxElevator * speedf * speedf * 20)) {
@@ -608,7 +610,7 @@
 	if(groundTarget)
 		engine = 1;
 	else
-		engine = min(1.f, (float)(goalLength / owner-&gt;maxRange + 1 - goalDir.dot(frontdir) * 0.7f));
+		engine = std::min(1.f, (float)(goalLength / owner-&gt;maxRange + 1 - goalDir.dot(frontdir) * 0.7f));
 
 	UpdateAirPhysics(rudder, aileron, elevator, engine, owner-&gt;frontdir);
 /*
@@ -678,7 +680,7 @@
 		float3 otherDif = lastColWarning-&gt;pos - pos;
 		float otherLength = otherDif.Length();
 		otherDir = otherDif / (otherLength + 0.01f);
-		otherThreat = max(1200.0f, goalLength) / otherLength * 0.036f;
+		otherThreat = std::max(1200.0f, goalLength) / otherLength * 0.036f;
 	}
 
 	float goalDot = rightdir.dot(adjustedGoalDir);
@@ -742,7 +744,7 @@
 		}
 		if (notColliding) {
 			float gHeight2 = ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40);
-			float hdif = max(gHeight, gHeight2) + wantedHeight - pos.y - frontdir.y * speedf * 20;
+			float hdif = std::max(gHeight, gHeight2) + wantedHeight - pos.y - frontdir.y * speedf * 20;
 			if (hdif &lt; -(maxElevator * speedf * speedf * 20) &amp;&amp; frontdir.y &gt; -maxPitch) {
 				elevator = -1;
 			} else if (hdif &gt; (maxElevator * speedf * speedf * 20) &amp;&amp; frontdir.y &lt; maxPitch) {
@@ -815,7 +817,7 @@
 	owner-&gt;updir = owner-&gt;rightdir.cross(owner-&gt;frontdir);
 
 	pos += speed;
-	owner-&gt;midPos = pos + (owner-&gt;frontdir * owner-&gt;relMidPos.z) + (owner-&gt;updir * owner-&gt;relMidPos.y) + (owner-&gt;rightdir * owner-&gt;relMidPos.x);
+	owner-&gt;UpdateMidPos();
 }
 
 
@@ -874,7 +876,7 @@
 	float dist = dif.Length();
 	dif /= dist;
 
-	float wsf = min(owner-&gt;maxSpeed, dist / speedf * 1.8f * maxAcc);
+	float wsf = std::min(owner-&gt;maxSpeed, dist / speedf * 1.8f * maxAcc);
 	float3 wantedSpeed = dif * wsf;
 
 	float3 delta = wantedSpeed - speed;
@@ -908,7 +910,7 @@
 	rightdir.Normalize();
 	updir = rightdir.cross(frontdir);
 
-	owner-&gt;midPos = pos + (frontdir * owner-&gt;relMidPos.z) + (updir * owner-&gt;relMidPos.y) + (rightdir * owner-&gt;relMidPos.x);
+	owner-&gt;UpdateMidPos();
 
 	// see if we are at the reserved (not user-clicked) landing spot
 	if (dist &lt; 1) {
@@ -956,7 +958,7 @@
 #ifdef DIRECT_CONTROL_ALLOWED
 	if (owner-&gt;directControl) {
 		if ((pos.y - gHeight) &gt; wantedHeight * 1.2f) {
-			engine = max(0.0f, min(engine, 1 - (pos.y - gHeight - wantedHeight * 1.2f) / wantedHeight));
+			engine = std::max(0.0f, std::min(engine, 1 - (pos.y - gHeight - wantedHeight * 1.2f) / wantedHeight));
 		}
 		// check next position given current (unadjusted) pos and speed
 		nextPosInBounds = (pos + speed).CheckInBounds();
@@ -965,7 +967,7 @@
 
 
 	speed += engineVector * maxAcc * engine;
-	speed.y += gs-&gt;gravity * myGravity;
+	speed.y += mapInfo-&gt;map.gravity * myGravity;
 	speed *= invDrag;
 
 	float3 wingDir = updir * (1 - wingAngle) - frontdir * wingAngle;
@@ -1010,7 +1012,7 @@
 	rightdir.Normalize();
 	updir = rightdir.cross(frontdir);
 
-	owner-&gt;midPos = pos + frontdir * owner-&gt;relMidPos.z + updir * owner-&gt;relMidPos.y + rightdir * owner-&gt;relMidPos.x;
+	owner-&gt;UpdateMidPos();
 
 #ifdef DEBUG_AIRCRAFT
 	if(selectedUnits.selectedUnits.find(this)!=selectedUnits.selectedUnits.end()){
@@ -1092,9 +1094,9 @@
 	int2 mp = owner-&gt;GetMapPos();
 	owner-&gt;pos = tpos;
 
-	for (int z = mp.y; z &lt; mp.y + owner -&gt; ysize; z++) {
-		for (int x = mp.x; x &lt; mp.x + owner -&gt; xsize; x++) {
-			if (readmap -&gt; groundBlockingObjectMap[z * gs-&gt;mapx + x]) {
+	for (int z = mp.y; z &lt; mp.y + owner-&gt;ysize; z++) {
+		for (int x = mp.x; x &lt; mp.x + owner-&gt;xsize; x++) {
+			if (groundBlockingObjectMap-&gt;GroundBlockedUnsafe(z * gs-&gt;mapx + x)) {
 				return ret;
 			}
 		}

Modified: branches/gml/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,6 +3,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;myMath.h&quot;
@@ -29,6 +30,7 @@
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND_DERIVED(CGroundMoveType, AMoveType, (NULL));
@@ -37,7 +39,8 @@
 		CR_MEMBER(baseTurnRate),
 		CR_MEMBER(turnRate),
 		CR_MEMBER(accRate),
-
+		CR_MEMBER(decRate),
+		
 		CR_MEMBER(wantedSpeed),
 		CR_MEMBER(currentSpeed),
 		CR_MEMBER(deltaSpeed),
@@ -120,6 +123,7 @@
 CGroundMoveType::CGroundMoveType(CUnit* owner)
 :	AMoveType(owner),
 	accRate(0.01f),
+	decRate(0.01f),
 	turnRate(0.1f),
 	baseTurnRate(0.1f),
 //	maxSpeed(0.2f),
@@ -307,7 +311,7 @@
 					currentDistanceToWaypoint &lt; BreakingDistance(currentSpeed) + SQUARE_SIZE) {
 					wantedSpeed = std::min((float) wantedSpeed, (float) (sqrt(currentDistanceToWaypoint * -owner-&gt;mobility-&gt;maxBreaking)));
 				}
-				wantedSpeed *= max(0.0f, std::min(1.0f, desiredVelocity.dot(owner-&gt;frontdir) + 0.1f));
+				wantedSpeed *= std::max(0.0f, std::min(1.0f, desiredVelocity.dot(owner-&gt;frontdir) + 0.1f));
 				SetDeltaSpeed();
 			}
 		} else {
@@ -354,7 +358,7 @@
 			owner-&gt;pos.y = wh;
 
 		owner-&gt;speed = owner-&gt;pos-oldPos;
-		owner-&gt;midPos = owner-&gt;pos + owner-&gt;frontdir * owner-&gt;relMidPos.z + owner-&gt;updir * owner-&gt;relMidPos.y + owner-&gt;rightdir * owner-&gt;relMidPos.x;
+		owner-&gt;UpdateMidPos();
 		oldPos = owner-&gt;pos;
 
 		if (groundDecals &amp;&amp; owner-&gt;unitDef-&gt;leaveTracks &amp;&amp; (lastTrackUpdate &lt; gs-&gt;frameNum - 7) &amp;&amp;
@@ -369,64 +373,71 @@
 
 void CGroundMoveType::SlowUpdate()
 {
-	if(owner-&gt;transporter){
-		if(progressState == Active)
+	if (owner-&gt;transporter) {
+		if (progressState == Active)
 			StopEngine();
 		return;
 	}
 
-	//If got too far away from path, then need to reconsider.
-	if(progressState == Active &amp;&amp; etaFailures&gt;8) {
-		if(owner-&gt;pos.distance2D(goalPos)&gt;200 || CheckGoalFeasability()){
-			if(DEBUG_CONTROLLER)
-				logOutput.Print(&quot;Unit eta failure %i&quot;,owner-&gt;id);
+	// if we've strayed too far away from path, then need to reconsider
+	if (progressState == Active &amp;&amp; etaFailures &gt; 8) {
+		if (owner-&gt;pos.distance2D(goalPos)&gt;200 || CheckGoalFeasability()) {
+			if (DEBUG_CONTROLLER)
+				logOutput.Print(&quot;Unit eta failure %i&quot;, owner-&gt;id);
 			StopEngine();
 			StartEngine();
 		} else {
-			if(DEBUG_CONTROLLER)
-				logOutput.Print(&quot;Goal clogged up %i&quot;,owner-&gt;id);
+			if (DEBUG_CONTROLLER)
+				logOutput.Print(&quot;Goal clogged up %i&quot;, owner-&gt;id);
 			Fail();
 		}
 	}
 
-	//If the action is active, but not the engine and the
-	//re-try-delay has passed, then start the engine.
-	if(progressState == Active &amp;&amp; !pathId &amp;&amp; gs-&gt;frameNum &gt; restartDelay) {
-		if(DEBUG_CONTROLLER)
-			logOutput.Print(&quot;Unit restart %i&quot;,owner-&gt;id);
+	// If the action is active, but not the engine and the
+	// re-try-delay has passed, then start the engine.
+	if (progressState == Active &amp;&amp; !pathId &amp;&amp; gs-&gt;frameNum &gt; restartDelay) {
+		if (DEBUG_CONTROLLER)
+			logOutput.Print(&quot;Unit restart %i&quot;, owner-&gt;id);
 		StartEngine();
 	}
 
-	owner-&gt;pos.CheckInBounds();		//just kindly move it into the map again instead of deleteing
+	if (!flying) {
+		// just kindly move it into the map again instead of deleteing
+		owner-&gt;pos.CheckInBounds();
+	}
 
-	float wh;		//need the following if the ground change height when unit stand still
-	if(floatOnWater){
-		wh = ground-&gt;GetHeight(owner-&gt;pos.x, owner-&gt;pos.z);
-		if(wh==0)
-			wh=-owner-&gt;unitDef-&gt;waterline;
-	} else {
-		wh = ground-&gt;GetHeight2(owner-&gt;pos.x, owner-&gt;pos.z);
+	if (!(owner-&gt;falling || flying)) {
+		float wh;
+
+		// need the following if the ground changes
+		// height while the unit is standing still
+		if (floatOnWater) {
+			wh = ground-&gt;GetHeight(owner-&gt;pos.x, owner-&gt;pos.z);
+			if (wh == 0.0f) {
+				wh = -owner-&gt;unitDef-&gt;waterline;
+			}
+		} else {
+			wh = ground-&gt;GetHeight2(owner-&gt;pos.x, owner-&gt;pos.z);
+		}
+		owner-&gt;pos.y = wh;
 	}
 
-	if (!(owner-&gt;falling || flying))
-		owner-&gt;pos.y=wh;
+	if (!(owner-&gt;pos == oldSlowUpdatePos)) {
+		oldSlowUpdatePos = owner-&gt;pos;
 
-	if(!(owner-&gt;pos==oldSlowUpdatePos)){
-		oldSlowUpdatePos=owner-&gt;pos;
+		int newmapSquare = ground-&gt;GetSquare(owner-&gt;pos);
+		if (newmapSquare != owner-&gt;mapSquare) {
+			owner-&gt;mapSquare = newmapSquare;
 
-		int newmapSquare=ground-&gt;GetSquare(owner-&gt;pos);
-		if(newmapSquare!=owner-&gt;mapSquare){
-			owner-&gt;mapSquare=newmapSquare;
-
 			loshandler-&gt;MoveUnit(owner,false);
-			if(owner-&gt;hasRadarCapacity)
+			if (owner-&gt;hasRadarCapacity)
 				radarhandler-&gt;MoveUnit(owner);
 
-//			owner-&gt;UnBlock();
-//			owner-&gt;Block();
+			// owner-&gt;UnBlock();
+			// owner-&gt;Block();
 		}
 		qf-&gt;MovedUnit(owner);
-		owner-&gt;isUnderWater=owner-&gt;pos.y+owner-&gt;height&lt;1;
+		owner-&gt;isUnderWater = owner-&gt;pos.y + owner-&gt;height &lt; 1;
 	}
 }
 
@@ -456,7 +467,7 @@
 	//Sets the new goal.
 	goalPos = moveGoalPos;
 	goalRadius = goalRadius;
-	requestedSpeed = min(speed, maxSpeed * 2);
+	requestedSpeed = std::min(speed, maxSpeed * 2);
 	requestedTurnRate = owner-&gt;mobility-&gt;maxTurnRate;
 	atGoal = false;
 	useMainHeading = false;
@@ -535,27 +546,28 @@
 		logOutput.Print(&quot;Acceleration is zero on unit %s\n&quot;,owner-&gt;unitDef-&gt;name.c_str());
 		accRate=0.01f;
 	}
-
-	if(fabs(dif)&lt;0.05f){		//good speed
-		deltaSpeed=dif/8;
-		nextDeltaSpeedUpdate=gs-&gt;frameNum+8;
-
-	} else if(dif&gt;0){				//accelerate
-		if(dif&lt;accRate){
+	if(fabs(dif) &lt; 0.05f) {		//good speed
+		deltaSpeed = dif / 8;
+		nextDeltaSpeedUpdate = gs-&gt;frameNum + 8;
+	}
+	else if(dif &gt; 0) {				//accelerate
+		if(dif &lt; accRate) {
 			deltaSpeed = dif;
-			nextDeltaSpeedUpdate=gs-&gt;frameNum;
+			nextDeltaSpeedUpdate = gs-&gt;frameNum;
 		} else {
-			deltaSpeed=accRate;
-			nextDeltaSpeedUpdate=(int)(gs-&gt;frameNum+min((float)8,dif/accRate));
+			deltaSpeed = accRate;
+			nextDeltaSpeedUpdate = (int)(gs-&gt;frameNum + std::min((float) 8, dif / accRate));
 		}
-	}else {		//break, Breakrate = -3*accRate
-		if(dif &gt; -3*accRate){
+	}
+	else {	// decRate = 0.1*brakeRate, I guess this is for aircraft
+		if(dif &gt; -10*decRate){
 			deltaSpeed = dif;
-			nextDeltaSpeedUpdate=gs-&gt;frameNum+1;
-		} else {
-			deltaSpeed = -3*accRate;
-			nextDeltaSpeedUpdate=(int)(gs-&gt;frameNum+min((float)8,dif/(-3*accRate)));
+			nextDeltaSpeedUpdate = gs-&gt;frameNum + 1;
 		}
+		else {
+			deltaSpeed = -10*decRate;
+			nextDeltaSpeedUpdate = (int)(gs-&gt;frameNum + std::min((float) 8, dif / (-10*decRate)));
+		}
 	}
 	//float3 temp=UpVector*wSpeed;
 	//temp.CheckInBounds();
@@ -576,9 +588,9 @@
 	deltaHeading = wantedHeading - heading;
 
 	if(deltaHeading&gt;0){
-		heading += min(deltaHeading,(short)turnRate);
+		heading += std::min(deltaHeading,(short)turnRate);
 	} else {
-		heading += max((short)-turnRate,deltaHeading);
+		heading += std::max((short)-turnRate,deltaHeading);
 	}
 
 	owner-&gt;frontdir = GetVectorFromHeading(heading);
@@ -647,7 +659,7 @@
 	SyncedFloat3&amp; midPos=owner-&gt;midPos;
 
 	if(flying){
-		speed.y+=gs-&gt;gravity;
+		speed.y+=mapInfo-&gt;map.gravity;
 		if(midPos.y &lt; 0)
 			speed*=0.95f;
 
@@ -693,8 +705,8 @@
 		} else {
 			if (onSlope) {
 				float3 dir = ground-&gt;GetNormal(midPos.x, midPos.z);
-				float3 normalForce = dir*dir.dot(UpVector*gs-&gt;gravity);
-				float3 newForce = UpVector*gs-&gt;gravity - normalForce;
+				float3 normalForce = dir*dir.dot(UpVector*mapInfo-&gt;map.gravity);
+				float3 newForce = UpVector*mapInfo-&gt;map.gravity - normalForce;
 				speed+=newForce;
 				speedf = speed.Length();
 				speed *= 1 - (.1*dir.y);
@@ -718,8 +730,8 @@
 		else
 			wh = ground-&gt;GetHeight2(pos.x, pos.z);
 
-		if(wh-pos.y &lt; speed.y + gs-&gt;gravity){
-			speed.y += gs-&gt;gravity;
+		if(wh-pos.y &lt; speed.y + mapInfo-&gt;map.gravity){
+			speed.y += mapInfo-&gt;map.gravity;
 			skidding = true; // flying requires skidding
 			flying = true;
 		} else if(wh-pos.y &gt; speed.y){
@@ -753,7 +765,7 @@
 		//set us upright
 		owner-&gt;cob-&gt;Call(&quot;Falling&quot;); //start/continue parachute animation
 
-		speed.y += gs-&gt;gravity*owner-&gt;fallSpeed;
+		speed.y += mapInfo-&gt;map.gravity*owner-&gt;fallSpeed;
 
 		if(owner-&gt;speed.y &gt; 0) //sometimes the dropped unit gets an upward force, still unsure where its coming from
 			owner-&gt;speed.y = 0;
@@ -1392,11 +1404,11 @@
 bool CGroundMoveType::CheckColH(int x, int y1, int y2, float xmove, int squareTestX)
 {
 	for (int y = y1; y &lt;= y2; ++y) {
-		CSolidObject* c = readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + x];
+		CSolidObject* c = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y * gs-&gt;mapx + x);
 
 		if (c) {
-			if (readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + squareTestX] != 0 &amp;&amp;
-				readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + squareTestX] != owner) {
+			if (groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y * gs-&gt;mapx + squareTestX) != NULL &amp;&amp;
+				groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y * gs-&gt;mapx + squareTestX) != owner) {
 				continue;
 			}
 			if (c-&gt;mobility) {
@@ -1422,7 +1434,7 @@
 					// push the blocking unit out of the way
 					// FIXME CAN PLACE OTHER PARTY IN BUILDING
 					u-&gt;pos += dif * (part);
-					u-&gt;midPos = u-&gt;pos + u-&gt;frontdir * u-&gt;relMidPos.z + u-&gt;updir * u-&gt;relMidPos.y + u-&gt;rightdir * u-&gt;relMidPos.x;
+					u-&gt;UpdateMidPos();
 				}
 
 				if (!(gs-&gt;frameNum + owner-&gt;id &amp; 31) &amp;&amp; !owner-&gt;commandAI-&gt;unimportantMove) {
@@ -1441,9 +1453,9 @@
 
 			// hack to make units find openings easier until the pathfinder can do it itself
 			// FIXME CAN PLACE US IN BUILDING
-			if (readmap-&gt;groundBlockingObjectMap[y1 * gs-&gt;mapx + x] == 0)
+			if (groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y1 * gs-&gt;mapx + x) == NULL)
 				owner-&gt;pos.z -= fabs(owner-&gt;pos.x - xmove) * 0.5f;
-			if (readmap-&gt;groundBlockingObjectMap[y2 * gs-&gt;mapx + x] == 0)
+			if (groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y2 * gs-&gt;mapx + x) == NULL)
 				owner-&gt;pos.z += fabs(owner-&gt;pos.x - xmove) * 0.5f;
 
 			owner-&gt;pos.x = xmove;
@@ -1458,11 +1470,11 @@
 bool CGroundMoveType::CheckColV(int y, int x1, int x2, float zmove, int squareTestY)
 {
 	for (int x = x1; x &lt;= x2; ++x) {
-		CSolidObject* c = readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + x];
+		CSolidObject* c = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y * gs-&gt;mapx + x);
 
 		if (c) {
-			if (readmap-&gt;groundBlockingObjectMap[squareTestY * gs-&gt;mapx + x] != 0 &amp;&amp;
-				readmap-&gt;groundBlockingObjectMap[squareTestY * gs-&gt;mapx + x] != owner) {
+			if (groundBlockingObjectMap-&gt;GroundBlockedUnsafe(squareTestY * gs-&gt;mapx + x) != NULL &amp;&amp;
+				groundBlockingObjectMap-&gt;GroundBlockedUnsafe(squareTestY * gs-&gt;mapx + x) != owner) {
 				continue;
 			}
 			if (c-&gt;mobility) {
@@ -1488,7 +1500,7 @@
 					// push the blocking unit out of the way
 					// FIXME CAN PLACE OTHER PARTY IN BUILDING
 					c-&gt;pos += dif * (part);
-					u-&gt;midPos = u-&gt;pos + u-&gt;frontdir * u-&gt;relMidPos.z + u-&gt;updir * u-&gt;relMidPos.y + u-&gt;rightdir * u-&gt;relMidPos.x;
+					u-&gt;UpdateMidPos();
 				}
 
 				if (!(gs-&gt;frameNum + owner-&gt;id &amp; 31) &amp;&amp; !owner-&gt;commandAI-&gt;unimportantMove) {
@@ -1507,9 +1519,9 @@
 
 			// hack to make units find openings easier until the pathfinder can do it itself
 			// FIXME CAN PLACE US IN BUILDING
-			if (readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + x1] == 0)
+			if (groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y * gs-&gt;mapx + x1) == NULL)
 				owner-&gt;pos.x -= fabs(owner-&gt;pos.z - zmove) * 0.5f;
-			if (readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + x2] == 0)
+			if (groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y * gs-&gt;mapx + x2) == NULL)
 				owner-&gt;pos.x += fabs(owner-&gt;pos.z - zmove) * 0.5f;
 
 			owner-&gt;pos.z = zmove;
@@ -1695,11 +1707,11 @@
 {
 	float goalDist=goalPos.distance2D(owner-&gt;pos);
 
-	int minx=(int)max(0.f,(goalPos.x-goalDist)/(SQUARE_SIZE*2));
-	int minz=(int)max(0.f,(goalPos.z-goalDist)/(SQUARE_SIZE*2));
+	int minx = (int) std::max(0.f,(goalPos.x-goalDist)/(SQUARE_SIZE*2));
+	int minz = (int) std::max(0.f,(goalPos.z-goalDist)/(SQUARE_SIZE*2));
 
-	int maxx=(int)min(float(gs-&gt;hmapx-1),(goalPos.x+goalDist)/(SQUARE_SIZE*2));
-	int maxz=(int)min(float(gs-&gt;hmapy-1),(goalPos.z+goalDist)/(SQUARE_SIZE*2));
+	int maxx = (int) std::min(float(gs-&gt;hmapx-1),(goalPos.x+goalDist)/(SQUARE_SIZE*2));
+	int maxz = (int) std::min(float(gs-&gt;hmapy-1),(goalPos.z+goalDist)/(SQUARE_SIZE*2));
 
 	MoveData* md=owner-&gt;unitDef-&gt;movedata;
 	CMoveMath* mm=md-&gt;moveMath;

Modified: branches/gml/rts/Sim/MoveTypes/GroundMoveType.h
===================================================================
--- branches/gml/rts/Sim/MoveTypes/GroundMoveType.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/GroundMoveType.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -38,6 +38,7 @@
 	float baseTurnRate;
 	float turnRate;
 	float accRate;
+	float decRate;
 
 	float wantedSpeed;
 	float currentSpeed;

Modified: branches/gml/rts/Sim/MoveTypes/MoveInfo.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/MoveInfo.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/MoveInfo.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,6 +5,7 @@
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;MoveMath/MoveMath.h&quot;
 #include &lt;boost/lexical_cast.hpp&gt;
 #include &quot;creg/STL_Deque.h&quot;
@@ -113,10 +114,10 @@
 	}
 
 	for (int a = 0; a &lt; 256; ++a) {
-		terrainType2MoveFamilySpeed[a][0] = readmap-&gt;terrainTypes[a].tankSpeed;
-		terrainType2MoveFamilySpeed[a][1] = readmap-&gt;terrainTypes[a].kbotSpeed;
-		terrainType2MoveFamilySpeed[a][2] = readmap-&gt;terrainTypes[a].hoverSpeed;
-		terrainType2MoveFamilySpeed[a][3] = readmap-&gt;terrainTypes[a].shipSpeed;
+		terrainType2MoveFamilySpeed[a][0] = mapInfo-&gt;terrainTypes[a].tankSpeed;
+		terrainType2MoveFamilySpeed[a][1] = mapInfo-&gt;terrainTypes[a].kbotSpeed;
+		terrainType2MoveFamilySpeed[a][2] = mapInfo-&gt;terrainTypes[a].hoverSpeed;
+		terrainType2MoveFamilySpeed[a][3] = mapInfo-&gt;terrainTypes[a].shipSpeed;
 	}
 }
 

Modified: branches/gml/rts/Sim/MoveTypes/MoveMath/HoverMoveMath.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/MoveMath/HoverMoveMath.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/MoveMath/HoverMoveMath.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -35,7 +35,7 @@
 	if(slope*moveSlope &gt; moveData.maxSlope)
 		return 0.0f;
 	//Slope-mod
-	return 1 / (1 + max(0.0f,slope*moveSlope) * moveData.slopeMod);
+	return 1 / (1 + std::max(0.0f,slope*moveSlope) * moveData.slopeMod);
 }
 
 /*

Modified: branches/gml/rts/Sim/MoveTypes/MoveMath/MoveMath.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/MoveMath/MoveMath.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/MoveMath/MoveMath.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -2,6 +2,7 @@
 #include &quot;MoveMath.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
 #include &quot;LogOutput.h&quot;
@@ -185,7 +186,7 @@
 	|| xSquare &gt;= gs-&gt;mapx || zSquare &gt;= gs-&gt;mapy)
 		return true;
 
-	CSolidObject* obstacle = readmap-&gt;GroundBlockedUnsafe(xSquare + zSquare * gs-&gt;mapx);
+	CSolidObject* obstacle = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(xSquare + zSquare * gs-&gt;mapx);
 	if(obstacle) {
 		if(obstacle-&gt;mobility) {
 			if(obstacle-&gt;isMoving){

Modified: branches/gml/rts/Sim/MoveTypes/ScriptMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,6 +3,7 @@
 #include &quot;ScriptMoveType.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Sim/Misc/AirBaseHandler.h&quot;
@@ -105,18 +106,6 @@
 	}
 }
 
-
-inline void CScriptMoveType::CalcMidPos()
-{
-	const float3&amp; pos = owner-&gt;pos;
-	const float3&amp; pr = owner-&gt;relMidPos;
-	const float3&amp; df = owner-&gt;frontdir;
-	const float3&amp; du = owner-&gt;updir;
-	const float3&amp; dr = owner-&gt;rightdir;
-	owner-&gt;midPos = pos + (df * pr.z) + (du * pr.y) + (dr * pr.x);
-}
-
-
 inline void CScriptMoveType::CalcDirections()
 {
 	CMatrix44f matrix;
@@ -195,7 +184,7 @@
 			                    (owner-&gt;rightdir * -relVel.x); // x is left
 			owner-&gt;speed += rVel;
 		}
-		vel.y        += gs-&gt;gravity * gravityFactor;
+		vel.y        += mapInfo-&gt;map.gravity * gravityFactor;
 		owner-&gt;speed += (wind.GetCurrentWind() * windFactor);
 		owner-&gt;pos   += owner-&gt;speed;
 	}
@@ -223,7 +212,7 @@
 		TrackSlope();
 	}
 
-	CalcMidPos();
+	owner-&gt;UpdateMidPos();
 
 	// don't need the rest if the pos hasn't changed
 	if (oldPos == owner-&gt;pos) {

Modified: branches/gml/rts/Sim/MoveTypes/ScriptMoveType.h
===================================================================
--- branches/gml/rts/Sim/MoveTypes/ScriptMoveType.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/ScriptMoveType.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -42,7 +42,6 @@
 		void LeaveTransport(void) {};
 
 	protected:
-		void CalcMidPos();
 		void CalcDirections();
 		void TrackSlope();
 		void CheckLimits();

Modified: branches/gml/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -16,7 +16,9 @@
 #include &quot;Mobility.h&quot;
 #include &quot;Sim/Units/UnitTypes/TransportUnit.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 
+
 CR_BIND_DERIVED(CTAAirMoveType, AAirMoveType, (NULL));
 
 CR_REG_METADATA(CTAAirMoveType, (
@@ -92,7 +94,7 @@
 {
 	// aircraft need some marginals to avoid uber stacking
 	// when lots of them are ordered to one place
-	maxDrift = max(16.0f, distance);
+	maxDrift = std::max(16.0f, distance);
 	goalPos = newPos;
 	oldGoalPos = newPos;
 	forceHeading = false;
@@ -560,7 +562,7 @@
 	float wantedBank = 0.0f;
 	if (!noBanking) wantedBank = rightdir.dot(deltaSpeed)/accRate*0.5f;
 
-	float limit=min(1.0f,goalPos.distance2D(owner-&gt;pos)*0.15f);
+	float limit = std::min(1.0f,goalPos.distance2D(owner-&gt;pos)*0.15f);
 	if(wantedBank&gt;limit)
 		wantedBank=limit;
 	else if(wantedBank&lt;-limit)
@@ -568,9 +570,9 @@
 
 	//Adjust our banking to the desired value
 	if (currentBank &gt; wantedBank)
-		currentBank -= min(0.03f, currentBank - wantedBank);
+		currentBank -= std::min(0.03f, currentBank - wantedBank);
 	else
-		currentBank += min(0.03f, wantedBank - currentBank);
+		currentBank += std::min(0.03f, wantedBank - currentBank);
 
 	// Calculate a suitable upvector
 	updir = rightdir.cross(frontdir);
@@ -611,8 +613,9 @@
 	}
 
 	speed.y = yspeed;
-	float h = pos.y - max(ground-&gt;GetHeight(pos.x, pos.z),
-						  ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40));
+	float h = pos.y - std::max(
+		ground-&gt;GetHeight(pos.x, pos.z),
+		ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40));
 
 	if (h &lt; 4) {
 		speed.x *= 0.95f;
@@ -646,10 +649,10 @@
 	}
 
 	if (speed.y &gt; ws) {
-		speed.y = max(ws, speed.y - accRate * 1.5f);
+		speed.y = std::max(ws, speed.y - accRate * 1.5f);
 	} else {
 		// let them accelerate upward faster if close to ground
-		speed.y = min(ws, speed.y + accRate * (h &lt; 20? 2.0f: 0.7f));
+		speed.y = std::min(ws, speed.y + accRate * (h &lt; 20? 2.0f: 0.7f));
 	}
 
 	pos += speed;
@@ -684,9 +687,6 @@
 void CTAAirMoveType::Update()
 {
 	float3&amp; pos = owner-&gt;pos;
-	SyncedFloat3&amp; rightdir = owner-&gt;rightdir;
-	SyncedFloat3&amp; frontdir = owner-&gt;frontdir;
-	SyncedFloat3&amp; updir = owner-&gt;updir;
 	float3&amp; speed = owner-&gt;speed;
 
 	// This is only set to false after the plane has finished constructing
@@ -772,7 +772,7 @@
 
 					owner-&gt;pos = pos;
 					owner-&gt;AddBuildPower(unit-&gt;unitDef-&gt;buildSpeed / 30, unit);
-					owner-&gt;currentFuel = min(owner-&gt;unitDef-&gt;maxFuel,
+					owner-&gt;currentFuel = std::min(owner-&gt;unitDef-&gt;maxFuel,
 							owner-&gt;currentFuel + (owner-&gt;unitDef-&gt;maxFuel
 									/ (GAME_SPEED * owner-&gt;unitDef-&gt;refuelTime)));
 
@@ -817,8 +817,7 @@
 	// Turn and bank and move
 	UpdateHeading();
 	UpdateBanking(aircraftState == AIRCRAFT_HOVERING);			// updates dirs
-	owner-&gt;midPos = pos + frontdir * owner-&gt;relMidPos.z + updir * owner-&gt;relMidPos.y
-			+ rightdir * owner-&gt;relMidPos.x;
+	owner-&gt;UpdateMidPos();
 
 	// Push other units out of the way
 	if (pos != oldpos &amp;&amp; aircraftState != AIRCRAFT_TAKEOFF &amp;&amp; padStatus == 0) {
@@ -841,20 +840,15 @@
 
 					if ((*ui)-&gt;mass &gt;= 100000 || (*ui)-&gt;immobile) {
 						pos -= dif * (dist - totRad);
-						owner-&gt;midPos = pos + owner-&gt;frontdir * owner-&gt;relMidPos.z
-								+ owner-&gt;updir * owner-&gt;relMidPos.y
-								+ owner-&gt;rightdir * owner-&gt;relMidPos.x;
+						owner-&gt;UpdateMidPos();
 						owner-&gt;speed *= 0.99f;
 					} else {
 						float part = owner-&gt;mass / (owner-&gt;mass + (*ui)-&gt;mass);
 						pos -= dif * (dist - totRad) * (1 - part);
-						owner-&gt;midPos = pos + owner-&gt;frontdir * owner-&gt;relMidPos.z
-								+ owner-&gt;updir * owner-&gt;relMidPos.y
-								+ owner-&gt;rightdir * owner-&gt;relMidPos.x;
+						owner-&gt;UpdateMidPos();
 						CUnit* u = (CUnit*) (*ui);
 						u-&gt;pos += dif * (dist - totRad) * (part);
-						u-&gt;midPos = u-&gt;pos + u-&gt;frontdir * u-&gt;relMidPos.z
-								+ u-&gt;updir * u-&gt;relMidPos.y + u-&gt;rightdir * u-&gt;relMidPos.x;
+						u-&gt;UpdateMidPos();
 						float colSpeed = -owner-&gt;speed.dot(dif) + u-&gt;speed.dot(dif);
 						owner-&gt;speed += dif * colSpeed * (1 - part);
 						u-&gt;speed -= dif * colSpeed * (part);
@@ -883,7 +877,7 @@
 void CTAAirMoveType::SlowUpdate(void)
 {
 	if (aircraftState != AIRCRAFT_LANDED &amp;&amp; owner-&gt;unitDef-&gt;maxFuel &gt; 0)
-		owner-&gt;currentFuel = max(0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
+		owner-&gt;currentFuel = std::max(0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
 
 	if (!reservedPad &amp;&amp; aircraftState == AIRCRAFT_FLYING 
 			&amp;&amp; owner-&gt;health &lt; owner-&gt;maxHealth * repairBelowHealth) {
@@ -942,7 +936,7 @@
 
 	for (int z = mp.y; z &lt; mp.y + owner-&gt;ysize; z++) {
 		for (int x = mp.x; x &lt; mp.x + owner-&gt;xsize; x++) {
-			CObject* o = readmap-&gt;groundBlockingObjectMap[z * gs-&gt;mapx + x];
+			CObject* o = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(z * gs-&gt;mapx + x);
 			if (o &amp;&amp; o != owner) {
 				return false;
 			}

Modified: branches/gml/rts/Sim/Objects/SolidObject.cpp
===================================================================
--- branches/gml/rts/Sim/Objects/SolidObject.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Objects/SolidObject.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,6 +3,7 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;myMath.h&quot;
 
 CR_BIND_DERIVED(CSolidObject, CWorldObject, );
@@ -31,8 +32,7 @@
 	CR_RESERVED(16))
 );
 
-CSolidObject::CSolidObject(EObjectType synced):
-	CWorldObject(synced),
+CSolidObject::CSolidObject() :
 	mass(100000),
 	blocking(false),
 	blockHeightChanges(false),
@@ -82,7 +82,7 @@
 */
 void CSolidObject::UnBlock() {
 	if (isMarkedOnBlockingMap) {
-		readmap-&gt;RemoveGroundBlockingObject(this);
+		groundBlockingObjectMap-&gt;RemoveGroundBlockingObject(this);
 	}
 }
 
@@ -97,9 +97,9 @@
 	if (blocking &amp;&amp; (physicalState == OnGround || physicalState == Floating || physicalState == Hovering || physicalState == Submarine)) {
 		// use the object's yardmap if available
 		if (yardMap) {
-			readmap-&gt;AddGroundBlockingObject(this, yardMap);
+			groundBlockingObjectMap-&gt;AddGroundBlockingObject(this, yardMap);
 		} else {
-			readmap-&gt;AddGroundBlockingObject(this);
+			groundBlockingObjectMap-&gt;AddGroundBlockingObject(this);
 		}
 	}
 }

Modified: branches/gml/rts/Sim/Objects/SolidObject.h
===================================================================
--- branches/gml/rts/Sim/Objects/SolidObject.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Objects/SolidObject.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -23,7 +23,7 @@
 		Submarine
 	};
 
-	CSolidObject(EObjectType synced = OT_Unknown);
+	CSolidObject();
 	virtual ~CSolidObject();
 
 	virtual bool AddBuildPower(float amount, CUnit* builder);

Modified: branches/gml/rts/Sim/Objects/WorldObject.cpp
===================================================================
--- branches/gml/rts/Sim/Objects/WorldObject.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Objects/WorldObject.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,33 +6,31 @@
 #include &quot;WorldObject.h&quot;
 #include &quot;mmgr.h&quot;
 
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
-
 CR_BIND_DERIVED(CWorldObject, CObject, )
-
 CR_REG_METADATA(CWorldObject, (
-				CR_MEMBER(radius),
-				CR_MEMBER_BEGINFLAG(CM_Config), // the projectile system needs to know that 'pos' is accessible by script
-					CR_MEMBER(pos),
-					CR_MEMBER(useAirLos),
-					CR_MEMBER(alwaysVisible),
-				CR_MEMBER_ENDFLAG(CM_Config),
-				CR_MEMBER(sqRadius),
-				CR_MEMBER(drawRadius),
-				CR_RESERVED(16))
+	CR_MEMBER(radius),
+	CR_MEMBER_BEGINFLAG(CM_Config), // the projectile system needs to know that 'pos' is accessible by script
+		CR_MEMBER(pos),
+		CR_MEMBER(useAirLos),
+		CR_MEMBER(alwaysVisible),
+	CR_MEMBER_ENDFLAG(CM_Config),
+	CR_MEMBER(sqRadius),
+	CR_MEMBER(drawRadius),
+	CR_RESERVED(16))
+);
 
-			);
-
 CWorldObject::~CWorldObject()
 {
+}
 
+void CWorldObject::DrawS3O()
+{
+	// implemented by CUnit, CFeature, CWeaponProjectile, CPieceProjectile
 }
 
 void CWorldObject::SetRadius(float r)
 {
-	radius=r;
-	sqRadius=r*r;
-	drawRadius=r;
+	radius = r;
+	sqRadius = r * r;
+	drawRadius = r;
 }

Modified: branches/gml/rts/Sim/Objects/WorldObject.h
===================================================================
--- branches/gml/rts/Sim/Objects/WorldObject.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Objects/WorldObject.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,13 +12,14 @@
 public:
 	CR_DECLARE(CWorldObject);
 
-	CWorldObject(EObjectType synced = OT_Unknown):
-		CObject(synced), useAirLos(false), alwaysVisible(false) {}
-	CWorldObject(const float3&amp; pos, EObjectType synced = OT_Unknown):
-		CObject(synced), pos(pos), useAirLos(false), alwaysVisible(false) {}
+	CWorldObject() :
+		useAirLos(false), alwaysVisible(false) {}
+	CWorldObject(const float3&amp; pos) :
+		pos(pos), useAirLos(false), alwaysVisible(false) {}
 
 	void SetRadius(float r);
 	virtual ~CWorldObject();
+	virtual void DrawS3O();
 
 	float3 pos;
 	float radius;     //used for collisions

Modified: branches/gml/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- branches/gml/rts/Sim/Path/PathEstimator.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Path/PathEstimator.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -41,13 +41,13 @@
 const float PATHCOST_INFINITY = 10000000;
 const int SQUARES_TO_UPDATE = 600;
 
-extern string stupidGlobalMapname;
+extern std::string stupidGlobalMapname;
 
 
 /*
  * constructor, loads precalculated data if it exists
  */
-CPathEstimator::CPathEstimator(CPathFinder* pf, unsigned int BSIZE, unsigned int mmOpt, string name):
+CPathEstimator::CPathEstimator(CPathFinder* pf, unsigned int BSIZE, unsigned int mmOpt, std::string name):
 	pathFinder(pf),
 	BLOCK_SIZE(BSIZE),
 	BLOCK_PIXEL_SIZE(BSIZE * SQUARE_SIZE),
@@ -174,7 +174,7 @@
 
 void CPathEstimator::InitEstimator(const std::string&amp; name) {
 	#if ((BOOST_VERSION / 100) % 1000 &lt;= 34)
-	int numThreads = configHandler.GetInt(&quot;HardwareThreadCount&quot;, 2);
+	int numThreads = GML_CPU_COUNT; //configHandler.GetInt(&quot;HardwareThreadCount&quot;, 2);
 	#else
 	int numThreads = boost::thread::hardware_concurrency();
 	#endif
@@ -185,12 +185,12 @@
 		JoinThreads(numThreads, 0);
 
 		char loadMsg[512];
-		sprintf(loadMsg, &quot;Reading estimate path costs (using %d threads)&quot;, numThreads);
+		sprintf(loadMsg, &quot;Reading estimate path costs (%d threads)&quot;, numThreads);
 		PrintLoadMsg(loadMsg);
 
 		if (!ReadFile(name)) {
 			char calcMsg[512];
-			sprintf(calcMsg, &quot;Analyzing map accessibility (block-size %d)&quot;, BLOCK_SIZE);
+			sprintf(calcMsg, &quot;Analyzing map accessibility [%d] (%d threads)&quot;, BLOCK_SIZE, numThreads);
 			PrintLoadMsg(calcMsg);
 
 			// re-spawn the threads for CalculateBlockOffsets()
@@ -207,11 +207,11 @@
 		InitVertices(0, nbrOfVertices);
 		InitBlocks(0, nbrOfBlocks);
 
-		PrintLoadMsg(&quot;Reading estimate path costs (using %d thread)&quot;, 1);
+		PrintLoadMsg(&quot;Reading estimate path costs (1 thread)&quot;);
 
 		if (!ReadFile(name)) {
 			char calcMsg[512];
-			sprintf(calcMsg, &quot;Analyzing map accessibility (block-size %d)&quot;, BLOCK_SIZE);
+			sprintf(calcMsg, &quot;Analyzing map accessibility [%d] (1 thread)&quot;, BLOCK_SIZE);
 			PrintLoadMsg(calcMsg);
 
 			CalcOffsetsAndPathCosts(0, nbrOfBlocks);
@@ -437,8 +437,8 @@
 	}
 
 	// error-check
-	upperX = min(upperX, nbrOfBlocksX - 1);
-	upperZ = min(upperZ, nbrOfBlocksZ - 1);
+	upperX = std::min(upperX, nbrOfBlocksX - 1);
+	upperZ = std::min(upperZ, nbrOfBlocksZ - 1);
 	if (lowerX &lt; 0) lowerX = 0;
 	if (lowerZ &lt; 0) lowerZ = 0;
 
@@ -784,13 +784,13 @@
  * try to read offset and vertices data from file, return false on failure
  * TODO: Read-error-check.
  */
-bool CPathEstimator::ReadFile(string name)
+bool CPathEstimator::ReadFile(std::string name)
 {
 	unsigned int hash = Hash();
 	char hashString[50];
 	sprintf(hashString, &quot;%u&quot;, hash);
 
-	string filename = string(&quot;maps/paths/&quot;) + stupidGlobalMapname.substr(0, stupidGlobalMapname.find_last_of('.') + 1) + hashString + &quot;.&quot; + name + &quot;.zip&quot;;
+	std::string filename = std::string(&quot;maps/paths/&quot;) + stupidGlobalMapname.substr(0, stupidGlobalMapname.find_last_of('.') + 1) + hashString + &quot;.&quot; + name + &quot;.zip&quot;;
 
 	// open file for reading from a suitable location (where the file exists)
 	CArchiveZip* pfile = SAFE_NEW CArchiveZip(filesystem.LocateFile(filename));
@@ -831,7 +831,7 @@
 /*
  * try to write offset and vertex data to file
  */
-void CPathEstimator::WriteFile(string name) {
+void CPathEstimator::WriteFile(std::string name) {
 	// We need this directory to exist
 	if (!filesystem.CreateDirectory(&quot;maps/paths&quot;))
 		return;
@@ -840,7 +840,7 @@
 	char hashString[50];
 	sprintf(hashString,&quot;%u&quot;,hash);
 
-	string filename = string(&quot;maps/paths/&quot;) + stupidGlobalMapname.substr(0, stupidGlobalMapname.find_last_of('.') + 1) + hashString + &quot;.&quot; + name + &quot;.zip&quot;;
+	std::string filename = std::string(&quot;maps/paths/&quot;) + stupidGlobalMapname.substr(0, stupidGlobalMapname.find_last_of('.') + 1) + hashString + &quot;.&quot; + name + &quot;.zip&quot;;
 	zipFile file;
 
 	// open file for writing in a suitable location
@@ -1037,8 +1037,8 @@
 	int xm = (int) (pos.x / (SQUARE_SIZE * BLOCK_SIZE));
 	int ym = (int) (pos.z / (SQUARE_SIZE * BLOCK_SIZE));
 
-	for (int y = max(0, ym - 1); y &lt;= min(nbrOfBlocksZ - 1, ym + 1); ++y) {
-		for (int x = max(0, xm - 1); x &lt;= min(nbrOfBlocksX - 1, xm + 1); ++x) {
+	for (int y = std::max(0, ym - 1); y &lt;= std::min(nbrOfBlocksZ - 1, ym + 1); ++y) {
+		for (int x = std::max(0, xm - 1); x &lt;= std::min(nbrOfBlocksX - 1, xm + 1); ++x) {
 			startPos.push_back(float3(blockState[y * nbrOfBlocksX + x].sqrCenter[pathType].x * SQUARE_SIZE, 0, blockState[y * nbrOfBlocksX+x].sqrCenter[pathType].y * SQUARE_SIZE));
 		}
 	}

Modified: branches/gml/rts/Sim/Path/PathEstimator.h
===================================================================
--- branches/gml/rts/Sim/Path/PathEstimator.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Path/PathEstimator.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -36,7 +36,7 @@
 		 *		name of the corresponding map.
 		 *		Ex. PE-name &quot;pe&quot; + Mapname &quot;Desert&quot; =&gt; &quot;Desert.pe&quot;
 		 */
-		CPathEstimator(CPathFinder* pathFinder, unsigned int BLOCK_SIZE, unsigned int moveMathOpt, string name);
+		CPathEstimator(CPathFinder* pathFinder, unsigned int BLOCK_SIZE, unsigned int moveMathOpt, std::string name);
 		~CPathEstimator();
 
 		// note: thread-safety (see PathFinder.cpp)?
@@ -125,7 +125,7 @@
 				inline bool operator==(const OpenBlock&amp; ob) { return blocknr == ob.blocknr; }
 		};
 
-		struct lessCost: public binary_function&lt;OpenBlock*, OpenBlock*, bool&gt; {
+		struct lessCost: public std::binary_function&lt;OpenBlock*, OpenBlock*, bool&gt; {
 			inline bool operator() (const OpenBlock* x, const OpenBlock* y) const {
 				return (x-&gt;cost &gt; y-&gt;cost);
 			}
@@ -155,19 +155,19 @@
 		void FinishSearch(const MoveData&amp; moveData, Path&amp; path);
 		void ResetSearch();
 
-		bool ReadFile(string name);
-		void WriteFile(string name);
+		bool ReadFile(std::string name);
+		void WriteFile(std::string name);
 		unsigned int Hash();
 
 		CPathFinder* pathFinder;
 
-		int nbrOfBlocksX, nbrOfBlocksZ, nbrOfBlocks;							// Number of blocks on map.
-		BlockInfo* blockState;													// Map over all blocks and there states.
-		OpenBlock openBlockBuffer[MAX_SEARCHED_BLOCKS];							// The buffer to be used in the priority-queue.
-		OpenBlock *openBlockBufferPointer;										// Pointer to the current position in the buffer.
-		priority_queue&lt;OpenBlock*, vector&lt;OpenBlock*&gt;, lessCost&gt; openBlocks;	// The priority-queue used to select next block to be searched.
-		list&lt;int&gt; dirtyBlocks;													// List of blocks changed in last search.
-		list&lt;SingleBlock&gt; needUpdate;											// Blocks that may need an update due to map changes.
+		int nbrOfBlocksX, nbrOfBlocksZ, nbrOfBlocks;									// Number of blocks on map.
+		BlockInfo* blockState;															// Map over all blocks and there states.
+		OpenBlock openBlockBuffer[MAX_SEARCHED_BLOCKS];									// The buffer to be used in the priority-queue.
+		OpenBlock *openBlockBufferPointer;												// Pointer to the current position in the buffer.
+		std::priority_queue&lt;OpenBlock*, std::vector&lt;OpenBlock*&gt;, lessCost&gt; openBlocks;	// The priority-queue used to select next block to be searched.
+		std::list&lt;int&gt; dirtyBlocks;														// List of blocks changed in last search.
+		std::list&lt;SingleBlock&gt; needUpdate;												// Blocks that may need an update due to map changes.
 
 		static const int PATH_DIRECTIONS = 8;
 		static const int PATH_DIRECTION_VERTICES = PATH_DIRECTIONS / 2;

Modified: branches/gml/rts/Sim/Path/PathFinder.cpp
===================================================================
--- branches/gml/rts/Sim/Path/PathFinder.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Path/PathFinder.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -198,7 +198,7 @@
 	path.pathCost = PATHCOST_INFINITY;
 
 	//Store som basic data.
-	maxNodesToBeSearched = min((unsigned int)MAX_SEARCHED_SQUARES, maxNodes);
+	maxNodesToBeSearched = std::min((unsigned int)MAX_SEARCHED_SQUARES, maxNodes);
 	this-&gt;testMobile=testMobile;
 	this-&gt;exactPath = exactPath;
 	this-&gt;needPath=needPath;

Modified: branches/gml/rts/Sim/Path/PathFinder.h
===================================================================
--- branches/gml/rts/Sim/Path/PathFinder.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Path/PathFinder.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,7 +6,6 @@
 #include &quot;Sim/MoveTypes/MoveMath/MoveMath.h&quot;
 #include &lt;queue&gt;
 #include &lt;list&gt;
-using namespace std;
 
 class CPathFinderDef;
 
@@ -160,9 +159,9 @@
 	unsigned int maxNodesToBeSearched;
 	myPQ openSquares;
 
-	SquareState* squareState;		//Map of all squares on map.
-	//list&lt;int&gt; dirtySquares;			//Squares tested by search.
-	vector&lt;int&gt; dirtySquares;
+	SquareState* squareState;			// Map of all squares on map.
+	// std::list&lt;int&gt; dirtySquares;		// Squares tested by search.
+	std::vector&lt;int&gt; dirtySquares;
 
 	int2 directionVector[16];		//Unit square-movement in given direction.
 	float moveCost[16];				//The cost of moving in given direction.

Modified: branches/gml/rts/Sim/Path/PathManager.cpp
===================================================================
--- branches/gml/rts/Sim/Path/PathManager.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Path/PathManager.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -11,6 +11,7 @@
 #include &quot;PathFinder.h&quot;
 #include &quot;PathEstimator.h&quot;
 #include &quot;SDL_timer.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;mmgr.h&quot;
 
 const float ESTIMATE_DISTANCE = 55;
@@ -34,7 +35,7 @@
 	hover = SAFE_NEW CHoverMoveMath();
 	sea = SAFE_NEW CShipMoveMath();
 
-	float waterDamage=atof(readmap-&gt;mapDefParser.SGetValueDef(&quot;0&quot;,&quot;MAP\\WATER\\WaterDamage&quot;).c_str());
+	float waterDamage = mapInfo-&gt;water.damage;
 	if(waterDamage&gt;=1000)
 		CGroundMoveMath::waterCost=0;
 	else
@@ -301,7 +302,7 @@
 		return float3(-1,-1,-1);
 
 	//Find corresponding multipath.
-	map&lt;unsigned int, MultiPath*&gt;::iterator pi = pathMap.find(pathId);
+	std::map&lt;unsigned int, MultiPath*&gt;::iterator pi = pathMap.find(pathId);
 	if(pi == pathMap.end())
 		return float3(-1,-1,-1);
 	MultiPath* multiPath = pi-&gt;second;
@@ -357,7 +358,7 @@
 		return;
 
 	//Find the multipath.
-	map&lt;unsigned int, MultiPath*&gt;::iterator pi = pathMap.find(pathId);
+	std::map&lt;unsigned int, MultiPath*&gt;::iterator pi = pathMap.find(pathId);
 	if(pi == pathMap.end())
 		return;
 	MultiPath* multiPath = pi-&gt;second;
@@ -404,10 +405,10 @@
 	glDisable(GL_TEXTURE_2D);
 	glDisable(GL_LIGHTING);
 	glLineWidth(3);
-	map&lt;unsigned int, MultiPath*&gt;::iterator pi;
+	std::map&lt;unsigned int, MultiPath*&gt;::iterator pi;
 	for(pi = pathMap.begin(); pi != pathMap.end(); pi++) {
 		MultiPath* path = pi-&gt;second;
-		list&lt;float3&gt;::iterator pvi;
+		std::list&lt;float3&gt;::iterator pvi;
 
 		//Start drawing a line.
 		glBegin(GL_LINE_STRIP);
@@ -450,34 +451,34 @@
 
 
 void CPathManager::GetEstimatedPath(unsigned int pathId,
-                                      vector&lt;float3&gt;&amp; points,
-                                      vector&lt;int&gt;&amp; starts) const
+	std::vector&lt;float3&gt;&amp; points,
+	std::vector&lt;int&gt;&amp; starts) const
 {
 	points.clear();
 	starts.clear();
 
-	map&lt;unsigned int, MultiPath*&gt;::const_iterator pi = pathMap.find(pathId);
+	std::map&lt;unsigned int, MultiPath*&gt;::const_iterator pi = pathMap.find(pathId);
 	if (pi == pathMap.end()) {
 		return;
 	}
 	const MultiPath* path = pi-&gt;second;
 
-	list&lt;float3&gt;::const_reverse_iterator pvi;
+	std::list&lt;float3&gt;::const_reverse_iterator pvi;
 
 	starts.push_back(points.size());
-	const list&lt;float3&gt;&amp; dtlPoints = path-&gt;detailedPath.path;
+	const std::list&lt;float3&gt;&amp; dtlPoints = path-&gt;detailedPath.path;
 	for (pvi = dtlPoints.rbegin(); pvi != dtlPoints.rend(); pvi++) {
 		points.push_back(*pvi);
 	}
 
 	starts.push_back(points.size());
-	const list&lt;float3&gt;&amp; estPoints = path-&gt;estimatedPath.path;
+	const std::list&lt;float3&gt;&amp; estPoints = path-&gt;estimatedPath.path;
 	for (pvi = estPoints.rbegin(); pvi != estPoints.rend(); pvi++) {
 		points.push_back(*pvi);
 	}
 
 	starts.push_back(points.size());
-	const list&lt;float3&gt;&amp; est2Points = path-&gt;estimatedPath2.path;
+	const std::list&lt;float3&gt;&amp; est2Points = path-&gt;estimatedPath2.path;
 	for (pvi = est2Points.rbegin(); pvi != est2Points.rend(); pvi++) {
 		points.push_back(*pvi);
 	}

Modified: branches/gml/rts/Sim/Path/PathManager.h
===================================================================
--- branches/gml/rts/Sim/Path/PathManager.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Path/PathManager.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,7 +3,6 @@
 
 #include &lt;map&gt;
 #include &quot;IPath.h&quot;
-using namespace std;
 
 class CSolidObject;
 class CPathFinder;
@@ -77,7 +76,7 @@
 			The list of starting indices for the different estimation levels
 	*/
 	void GetEstimatedPath(unsigned int pathId,
-	                        vector&lt;float3&gt;&amp; points, vector&lt;int&gt;&amp; starts) const;
+		std::vector&lt;float3&gt;&amp; points, std::vector&lt;int&gt;&amp; starts) const;
 
 
 	/*
@@ -148,7 +147,7 @@
 	CPathEstimator* pe;
 	CPathEstimator* pe2;
 
-	map&lt;unsigned int, MultiPath*&gt; pathMap;
+	std::map&lt;unsigned int, MultiPath*&gt; pathMap;
 	unsigned int nextPathId;
 
 	CMoveMath* ground;

Modified: branches/gml/rts/Sim/Projectiles/FlareProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/FlareProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/FlareProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -2,6 +2,7 @@
 #include &quot;FlareProjectile.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;ProjectileHandler.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
@@ -57,7 +58,7 @@
 	if(gs-&gt;frameNum&gt;=activateFrame){
 		pos+=speed;
 		speed*=0.95f;
-		speed.y+=gs-&gt;gravity*0.3f;
+		speed.y+=mapInfo-&gt;map.gravity*0.3f;
 
 		if(owner &amp;&amp; lastSub&lt;gs-&gt;frameNum-owner-&gt;unitDef-&gt;flareSalvoDelay &amp;&amp; numSub&lt;owner-&gt;unitDef-&gt;flareSalvoSize){
 			subPos.push_back(owner-&gt;pos);
@@ -80,7 +81,7 @@
 		for(int a=0;a&lt;numSub;++a){
 			subPos[a]+=subSpeed[a];
 			subSpeed[a]*=0.95f;
-			subSpeed[a].y+=gs-&gt;gravity*0.3f;
+			subSpeed[a].y+=mapInfo-&gt;map.gravity*0.3f;
 		}
 	}
 
@@ -95,7 +96,7 @@
 
 	inArray=true;
 	unsigned char col[4];
-	float alpha=max(0.0f,1-(gs-&gt;frameNum-activateFrame)*alphaFalloff);
+	float alpha=std::max(0.0f,1-(gs-&gt;frameNum-activateFrame)*alphaFalloff);
 	col[0]=(unsigned char)alpha*255;
 	col[1]=(unsigned char)(alpha*0.5f)*255;
 	col[2]=(unsigned char)(alpha*0.2f)*255;

Modified: branches/gml/rts/Sim/Projectiles/PieceProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/PieceProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/PieceProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,6 +4,7 @@
 #include &quot;GlobalStuff.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Matrix44f.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;PieceProjectile.h&quot;
@@ -263,7 +264,7 @@
 void CPieceProjectile::Update()
 {
 	if (flags &amp; PP_Fall) {
-		speed.y += gs-&gt;gravity;
+		speed.y += mapInfo-&gt;map.gravity;
 	}
 
 	speed *= 0.997f;
@@ -351,7 +352,7 @@
 				dir2.Normalize();
 
 				float a1 = ((1 - 0.0f / (Smoke_Time)) * 255) * (0.7f + fabs(dif.dot(dir)));
-				float alpha = min(255.0f, max(0.f, a1));
+				float alpha = std::min(255.0f, std::max(0.f, a1));
 				col[0] = (unsigned char) (color * alpha);
 				col[1] = (unsigned char) (color * alpha);
 				col[2] = (unsigned char) (color * alpha);
@@ -363,7 +364,7 @@
 				if (age &lt; 8)
 					a2 = 0;
 
-				alpha = min(255.0f, max(0.f, a2));
+				alpha = std::min(255.0f, std::max(0.f, a2));
 				col2[0] = (unsigned char) (color * alpha);
 				col2[1] = (unsigned char) (color * alpha);
 				col2[2] = (unsigned char) (color * alpha);
@@ -408,26 +409,6 @@
 	}
 }
 
-
-void CPieceProjectile::DrawUnitPart(void)
-{
-	glAlphaFunc(GL_GEQUAL, alphaThreshold);
-	glPushMatrix();
-	glTranslatef(pos.x, pos.y, pos.z);
-	glRotatef(spinPos,spinVec.x, spinVec.y, spinVec.z);
-	glCallList(dispList);
-	glPopMatrix();
-
-	*numCallback = 0;
-}
-
-void CPieceProjectile::DrawS3O(void)
-{
-	/* TODO Hmm, S3O nuclear missile... might want to copy this into WeaponProjectile? */
-	unitDrawer-&gt;SetS3OTeamColour(colorTeam);
-	DrawUnitPart();
-}
-
 void CPieceProjectile::DrawCallback(void)
 {
 	(*numCallback)++;
@@ -460,3 +441,23 @@
 		}
 	}
 }
+
+
+void CPieceProjectile::DrawUnitPart(void)
+{
+	glAlphaFunc(GL_GEQUAL, alphaThreshold);
+	glPushMatrix();
+	glTranslatef(pos.x, pos.y, pos.z);
+	glRotatef(spinPos, spinVec.x, spinVec.y, spinVec.z);
+	glCallList(dispList);
+	glPopMatrix();
+
+	*numCallback = 0;
+}
+
+void CPieceProjectile::DrawS3O(void)
+{
+	// copy of CWeaponProjectile::::DrawS3O()
+	unitDrawer-&gt;SetS3OTeamColour(colorTeam);
+	DrawUnitPart();
+}

Modified: branches/gml/rts/Sim/Projectiles/PieceProjectile.h
===================================================================
--- branches/gml/rts/Sim/Projectiles/PieceProjectile.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/PieceProjectile.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -55,7 +55,8 @@
 
 	void DrawUnitPart(void);
 	void DrawCallback(void);
-	
+
+	// should not be here
 	void DrawS3O(void);
 private:
 	bool HasVertices();

Modified: branches/gml/rts/Sim/Projectiles/Projectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Projectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/Projectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -11,6 +11,7 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND_DERIVED(CProjectile, CExpGenSpawnable, );
@@ -77,7 +78,7 @@
 
 void CProjectile::Update()
 {
-	speed.y+=gs-&gt;gravity;
+	speed.y+=mapInfo-&gt;map.gravity;
 
 	pos+=speed;
 }

Modified: branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -16,10 +16,11 @@
 #include &quot;Rendering/GroundFlash.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/Textures/TextureHandler.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
-#include &quot;Sim/Misc/CollisionVolume.h&quot;
+#include &quot;Sim/Misc/CollisionHandler.h&quot;
 #include &quot;Sim/Projectiles/Unsynced/ShieldPartProjectile.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
@@ -30,13 +31,12 @@
 #include &lt;algorithm&gt;
 #include &quot;Rendering/GL/IFramebuffer.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
+#include &quot;TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 #include &quot;creg/STL_List.h&quot;
 
 CProjectileHandler* ph;
 using namespace std;
-extern GLfloat FogBlack[];
-extern GLfloat FogLand[];
 
 CR_BIND(CProjectileHandler,);
 
@@ -91,7 +91,7 @@
 	for (int i = 0; i &lt; 12; i++) {
 		char num[10];
 		sprintf(num, &quot;%02i&quot;, i);
-		textureAtlas-&gt;AddTexFromFile(std::string(&quot;ismoke&quot;) + num, std::string(&quot;bitmaps/&quot;)+resources.SGetValueDef(std::string(&quot;smoke/smoke&quot;) + num +&quot;.tga&quot;,std::string(&quot;resources\\graphics\\smoke\\smoke&quot;)+num+&quot;alpha&quot;));
+		textureAtlas-&gt;AddTexFromFile(std::string(&quot;ismoke&quot;) + num, std::string(&quot;bitmaps/&quot;)+resources.SGetValueDef(std::string(&quot;smoke/smoke&quot;) + num +&quot;.tga&quot;,std::string(&quot;resources\\graphics\\smoke\\smoke&quot;)+num));
 		blockMapTexNames.insert(std::string(&quot;ismoke&quot;) + num);
 	}
 
@@ -238,7 +238,7 @@
 		glBindTexture(GL_TEXTURE_2D, perlinTex[a]);
 		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
-		gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8,16, 16, GL_RGBA, GL_UNSIGNED_BYTE, tempmem);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 16,16, 0, GL_RGBA, GL_UNSIGNED_BYTE, tempmem);
 	}
 
 	drawPerlinTex=false;
@@ -356,7 +356,7 @@
 		for(std::list&lt;FlyingPiece*&gt;::iterator pi=fpl-&gt;begin();pi!=fpl-&gt;end();){
 			(*pi)-&gt;pos+=(*pi)-&gt;speed;
 			(*pi)-&gt;speed*=0.996f;
-			(*pi)-&gt;speed.y+=gs-&gt;gravity;
+			(*pi)-&gt;speed.y+=mapInfo-&gt;map.gravity;
 			(*pi)-&gt;rot+=(*pi)-&gt;rotSpeed;
 			if((*pi)-&gt;pos.y&lt;ground-&gt;GetApproximateHeight((*pi)-&gt;pos.x,(*pi)-&gt;pos.z)-10){
 				delete *pi;
@@ -536,7 +536,7 @@
 	glColor4f(1,1,1,0.2f);
 	glAlphaFunc(GL_GREATER,0.0f);
 	glEnable(GL_ALPHA_TEST);
-//	glFogfv(GL_FOG_COLOR,FogLand);
+//	glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
 	glDisable(GL_FOG);
 
 	currentParticles=0;
@@ -553,7 +553,7 @@
 	currentParticles=(int)(ps.size()*0.8f+currentParticles*0.2f);
 	currentParticles+=(int)(0.2f*drawnPieces+0.3f*numFlyingPieces);
 	particleSaturation=(float)currentParticles/(float)maxParticles;
-//	glFogfv(GL_FOG_COLOR,FogLand);
+//	glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
 }
 
 void CProjectileHandler::DrawShadowPass(void)
@@ -563,12 +563,14 @@
 	glBindProgramARB( GL_VERTEX_PROGRAM_ARB, projectileShadowVP );
 	glEnable( GL_VERTEX_PROGRAM_ARB );
 	glDisable(GL_TEXTURE_2D);
-	for(psi=ps.begin();psi != ps.end();++psi){
-		if((loshandler-&gt;InLos(*psi,gu-&gt;myAllyTeam) || gu-&gt;spectatingFullView ||
-		   ((*psi)-&gt;owner &amp;&amp; gs-&gt;Ally((*psi)-&gt;owner-&gt;allyteam,gu-&gt;myAllyTeam)))){
-			if((*psi)-&gt;s3domodel)
+
+	for (psi = ps.begin(); psi != ps.end(); ++psi) {
+		if ((gu-&gt;spectatingFullView || loshandler-&gt;InLos(*psi, gu-&gt;myAllyTeam) ||
+			((*psi)-&gt;owner &amp;&amp; gs-&gt;Ally((*psi)-&gt;owner-&gt;allyteam, gu-&gt;myAllyTeam)))) {
+
+			if ((*psi)-&gt;s3domodel)
 				(*psi)-&gt;DrawUnitPart();
-			if((*psi)-&gt;castShadow){
+			if ((*psi)-&gt;castShadow){
 				struct projdist tmp;
 				tmp.proj = *psi;
 				distlist.push_back(tmp);
@@ -635,19 +637,12 @@
 					continue;
 
 				if (p-&gt;collisionFlags &amp; COLLISION_NONEUTRAL) {
-					if ((gs-&gt;useLuaGaia &amp;&amp; unit-&gt;team == gs-&gt;gaiaTeamID) || (unit-&gt;team == MAX_TEAMS - 1)) {
-						// Gaia-team unit, count it as neutral
+					if (unit-&gt;IsNeutral()) {
 						continue;
 					}
-					if (unit-&gt;neutral) {
-						// ordinary neutral unit
-						continue;
-					}
 				}
 
-				const CCollisionVolume* vol = unit-&gt;unitDef-&gt;collisionVolume;
-
-				if (vol-&gt;DetectHit(unit, p-&gt;pos, p-&gt;pos + p-&gt;speed)) {
+				if (CCollisionHandler::DetectHit(unit, p-&gt;pos, p-&gt;pos + p-&gt;speed)) {
 					p-&gt;Collision(unit);
 					break;
 				}
@@ -656,13 +651,11 @@
 			if (!(p-&gt;collisionFlags &amp; COLLISION_NOFEATURE)) {
 				for (CFeature** fi = tempFeatures; fi != endFeature; ++fi) {
 					CFeature* feature = *fi;
-					// geothermals do not have a collision volume
+					// geothermals do not have a collision volume, skip
 					if (!feature-&gt;blocking || feature-&gt;def-&gt;geoThermal)
 						continue;
 
-					const CCollisionVolume* vol = feature-&gt;def-&gt;collisionVolume;
-
-					if (vol-&gt;DetectHit(feature, p-&gt;pos, p-&gt;pos + p-&gt;speed)) {
+					if (CCollisionHandler::DetectHit(feature, p-&gt;pos, p-&gt;pos + p-&gt;speed)) {
 						p-&gt;Collision(feature);
 						break;
 					}
@@ -682,6 +675,8 @@
 
 void CProjectileHandler::DrawGroundFlashes(void)
 {
+	static GLfloat black[] = { 0.0f, 0.0f, 0.0f, 0.0f };
+
 	glEnable(GL_BLEND);
 	glBlendFunc(GL_SRC_ALPHA,GL_ONE);
 	glActiveTextureARB(GL_TEXTURE0_ARB);
@@ -691,7 +686,7 @@
 	glDepthMask(0);
 	glPolygonOffset(-20,-1000);
 	glEnable(GL_POLYGON_OFFSET_FILL);
-	glFogfv(GL_FOG_COLOR,FogBlack);
+	glFogfv(GL_FOG_COLOR, black);
 
 	CGroundFlash::va=GetVertexArray();
 	CGroundFlash::va-&gt;Initialize();
@@ -704,7 +699,7 @@
 	}
 	CGroundFlash::va-&gt;DrawArrayTC(GL_QUADS);
 
-	glFogfv(GL_FOG_COLOR,FogLand);
+	glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
 	glDepthMask(1);
 	glDisable(GL_POLYGON_OFFSET_FILL);
 	glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);

Modified: branches/gml/rts/Sim/Projectiles/Unsynced/DirtProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Unsynced/DirtProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/Unsynced/DirtProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,6 +6,7 @@
 #include &quot;DirtProjectile.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;mmgr.h&quot;
@@ -61,7 +62,7 @@
 void CDirtProjectile::Update()
 {
 	speed*=slowdown;
-	speed.y+=gs-&gt;gravity;
+	speed.y+=mapInfo-&gt;map.gravity;
 	pos+=speed;
 	alpha-=alphaFalloff;
 	size+=sizeExpansion;

Modified: branches/gml/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -76,7 +76,7 @@
 
 	inArray=true;
 	unsigned char col[4];
-	float alpha=min(255,age*10);
+	float alpha=std::min(255,age*10);
 	col[0]=(unsigned char)(color.x*alpha);
 	col[1]=(unsigned char)(color.y*alpha);
 	col[2]=(unsigned char)(color.z*alpha);
@@ -103,7 +103,7 @@
 		}
 	}
 	drawsize=7;
-	alpha=min(10,age/2);
+	alpha=std::min(10,age/2);
 	col[0]=(unsigned char)(color.x*alpha);
 	col[1]=(unsigned char)(color.y*alpha);
 	col[2]=(unsigned char)(color.z*alpha);

Modified: branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -104,18 +104,18 @@
 void CSmokeProjectile2::Draw()
 {
 	inArray=true;
-	float interAge=min(1.0f,age+ageSpeed*gu-&gt;timeOffset);
+	float interAge=std::min(1.0f,age+ageSpeed*gu-&gt;timeOffset);
 	unsigned char col[4];
 	unsigned char alpha;
 	if(interAge&lt;0.05f)
 		alpha=(unsigned char)(interAge*19*127);
 	else
 		alpha=(unsigned char)((1-interAge)*127);
-	float rglow=max(0.f,(1-interAge*glowFalloff)*127);
-	float gglow=max(0.f,(1-interAge*glowFalloff*2.5f)*127);
+	float rglow=std::max(0.f,(1-interAge*glowFalloff)*127);
+	float gglow=std::max(0.f,(1-interAge*glowFalloff*2.5f)*127);
 	col[0]=(unsigned char)(color*alpha+rglow);
 	col[1]=(unsigned char)(color*alpha+gglow);
-	col[2]=(unsigned char)max(0.f,color*alpha-gglow*0.5f);
+	col[2]=(unsigned char)std::max(0.f,color*alpha-gglow*0.5f);
 	col[3]=alpha/*-alphaFalloff*gu-&gt;timeOffset*/;
 	//int frame=textureNum;
 	//float xmod=0.125f+(float(int(frame%6)))/16.0f;

Modified: branches/gml/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -111,7 +111,7 @@
 		if(lastSegment)
 			a1=0;
 		a1*=0.7f+fabs(dif.dot(dir1));
-		float alpha=min(255.f,max(0.f,a1));
+		float alpha=std::min(255.f,std::max(0.f,a1));
 		col[0]=(unsigned char) (color*alpha);
 		col[1]=(unsigned char) (color*alpha);
 		col[2]=(unsigned char) (color*alpha);
@@ -122,7 +122,7 @@
 		if(firstSegment)
 			a2=0;
 		a2*=0.7f+fabs(dif2.dot(dir2));
-		alpha=min(255.f,max(0.f,a2));
+		alpha=std::min(255.f,std::max(0.f,a2));
 		col2[0]=(unsigned char) (color*alpha);
 		col2[1]=(unsigned char) (color*alpha);
 		col2[2]=(unsigned char) (color*alpha);
@@ -141,7 +141,7 @@
 			unsigned char col3[4];
 			float a2=(1-float(age+4)/(lifeTime))*255;
 			a2*=0.7f+fabs(dif3.dot(middir));
-			alpha=min(255.f,max(0.f,a2));
+			alpha=std::min(255.f,std::max(0.f,a2));
 			col3[0]=(unsigned char) (color*alpha);
 			col3[1]=(unsigned char) (color*alpha);
 			col3[2]=(unsigned char) (color*alpha);
@@ -168,7 +168,7 @@
 		unsigned char col[4];
 		for(int a=0;a&lt;8;++a){
 			float a1=1-float(age+a)/lifeTime;
-			float alpha=min(255.f,max(0.f,a1*255));
+			float alpha=std::min(255.f,std::max(0.f,a1*255));
 			col[0]=(unsigned char) (color*alpha);
 			col[1]=(unsigned char) (color*alpha);
 			col[2]=(unsigned char) (color*alpha);

Modified: branches/gml/rts/Sim/Projectiles/Unsynced/WreckProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Unsynced/WreckProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/Unsynced/WreckProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,6 +5,7 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
@@ -36,7 +37,7 @@
 
 void CWreckProjectile::Update()
 {
-	speed.y+=gs-&gt;gravity;
+	speed.y+=mapInfo-&gt;map.gravity;
 	speed.x*=0.994f;
 	speed.z*=0.994f;
 	if(speed.y&gt;0)

Modified: branches/gml/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -93,7 +93,7 @@
 		float h=ground-&gt;GetHeight2(pos.x,pos.z);
 		if(h&gt;pos.y){
 			float3 n=ground-&gt;GetNormal(pos.x,pos.z);
-			pos-=speed*max(0.0f,min(1.0f,float((h-pos.y)*n.y/n.dot(speed)+0.1f)));
+			pos-=speed*std::max(0.0f,std::min(1.0f,float((h-pos.y)*n.y/n.dot(speed)+0.1f)));
 		}
 		else if (weaponDef-&gt;waterweapon) {
 			return; //let waterweapons go underwater

Modified: branches/gml/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,6 +3,7 @@
 #include &quot;FireBallProjectile.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
@@ -87,7 +88,7 @@
 		pos += speed;
 
 		if (weaponDef-&gt;gravityAffected)
-			speed.y += gs-&gt;gravity;
+			speed.y += mapInfo-&gt;map.gravity;
 
 		// g&#65533;ra om till ttl sedan kanske
 		if (weaponDef-&gt;noExplode) {

Modified: branches/gml/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,6 +3,7 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Matrix44f.h&quot;
 #include &quot;MissileProjectile.h&quot;
 #include &quot;myMath.h&quot;
@@ -274,12 +275,16 @@
 			ceg.Explosion(pos, ttl, areaOfEffect, 0x0, 0.0f, 0x0, dir);
 		}
 	} else {
-		// only when TTL &lt;= 0 do projectiles
-		// get influenced by gravity and drag
-		speed *= 0.995f;
-		speed.y += gs-&gt;gravity;
-		dir = speed;
-		dir.Normalize();
+		if (weaponDef-&gt;selfExplode) {
+			Collision();
+		} else {
+			// only when TTL &lt;= 0 do projectiles
+			// get influenced by gravity and drag
+			speed *= 0.995f;
+			speed.y += mapInfo-&gt;map.gravity;
+			dir = speed;
+			dir.Normalize();
+		}
 	}
 
 	pos += speed;
@@ -342,7 +347,7 @@
 
 			float a1 = (1.0f / (Smoke_Time)) * 255;
 			a1 *= 0.7f + fabs(dif.dot(dir));
-			float alpha = min(255.0f, max(0.0f, a1));
+			float alpha = std::min(255.0f, std::max(0.0f, a1));
 			col[0] = (unsigned char) (color * alpha);
 			col[1] = (unsigned char) (color * alpha);
 			col[2] = (unsigned char) (color * alpha);
@@ -355,7 +360,7 @@
 				a2 = 0;
 
 			a2 *= 0.7f + fabs(dif2.dot(oldDir));
-			alpha = min(255.0f, max(0.0f, a2));
+			alpha = std::min(255.0f, std::max(0.0f, a2));
 			col2[0] = (unsigned char) (color * alpha);
 			col2[1] = (unsigned char) (color * alpha);
 			col2[2] = (unsigned char) (color * alpha);
@@ -465,7 +470,7 @@
 	if (ttl &gt; 0) {
 		// steer away twice as fast as we can steer toward target
 		float3 dif2 = sdir - dir;
-		float tracking = max(shieldForce * 0.05f, weaponDef-&gt;turnrate * 2);
+		float tracking = std::max(shieldForce * 0.05f, weaponDef-&gt;turnrate * 2);
 
 		if (dif2.Length() &lt; tracking) {
 			dir = sdir;

Modified: branches/gml/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,6 +3,7 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Matrix44f.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
@@ -72,7 +73,7 @@
 	this-&gt;uptime=uptime;
 	if (weaponDef) {
 		if (weaponDef-&gt;flighttime == 0) {
-			ttl=(int)min(3000.f,uptime+weaponDef-&gt;range/maxSpeed+100);
+			ttl = (int) std::min(3000.f,uptime+weaponDef-&gt;range/maxSpeed+100);
 		}
 		else {
 			ttl=weaponDef-&gt;flighttime;
@@ -206,9 +207,9 @@
 		if (distanceToTravel != MAX_WORLD_SIZE)
 			distanceToTravel -= speed.Length2D();
 	} else {
-		dir.y += gs-&gt;gravity;
+		dir.y += mapInfo-&gt;map.gravity;
 		dir.Normalize();
-		curSpeed += -gs-&gt;gravity;
+		curSpeed += -mapInfo-&gt;map.gravity;
 		speed = dir * curSpeed;
 	}
 
@@ -279,7 +280,7 @@
 
 			float a1=(1-float(0)/(Smoke_Time))*255;
 			a1*=0.7f+fabs(dif.dot(dir));
-			int alpha=min(255,(int)max(0.f,a1));
+			int alpha = std::min(255, (int) std::max(0.f,a1));
 			col[0]=(unsigned char) (color*alpha);
 			col[1]=(unsigned char) (color*alpha);
 			col[2]=(unsigned char) (color*alpha);
@@ -289,7 +290,7 @@
 			a2*=0.7f+fabs(dif2.dot(oldSmokeDir));
 			if(age&lt;8)
 				a2=0;
-			alpha=min(255,(int)max(0.f,a2));
+			alpha = std::min(255, (int) std::max(0.f,a2));
 			col2[0]=(unsigned char) (color*alpha);
 			col2[1]=(unsigned char) (color*alpha);
 			col2[2]=(unsigned char) (color*alpha);
@@ -349,8 +350,8 @@
 		for(float a=0;a&lt;ospeed+0.6f;a+=0.15f){
 			float ageMod;
 			if(createAgeMods){
-				if(missileAge&lt;20)
-					ageMod=1;
+				if (missileAge &lt; 20)
+					ageMod = 1;
 				else
 					ageMod=0.6f+rand()*0.8f/RAND_MAX;
 				oldInfos[age]-&gt;ageMods.push_back(ageMod);
@@ -361,13 +362,13 @@
 			float3 interPos=opos-odir*(age*0.5f+a);
 			float drawsize;
 			col[3]=1;
-			if(missileAge&lt;20){
-				float alpha=max(0.f,((1-age2)*(1-age2)));
+			if (missileAge &lt; 20) {
+				float alpha = std::max(0.f,((1-age2)*(1-age2)));
 				col[0]=(unsigned char) (255*alpha);
 				col[1]=(unsigned char) (200*alpha);
 				col[2]=(unsigned char) (150*alpha);
 			} else {
-				float alpha=max(0.f,((1-age2)*max(0.f,(1-age2))));
+				float alpha = std::max(0.f,((1-age2) * std::max(0.f,(1-age2))));
 				col[0]=(unsigned char) (255*alpha);
 				col[1]=(unsigned char) (200*alpha);
 				col[2]=(unsigned char) (150*alpha);
@@ -427,15 +428,16 @@
 {
 	float3 sdir=pos-shieldPos;
 	sdir.Normalize();
-	if(ttl &gt; 0){
-		float3 dif2=sdir-dir;
-		float tracking=max(shieldForce*0.05f,weaponDef-&gt;turnrate*2);		//steer away twice as fast as we can steer toward target
-		if(dif2.Length()&lt;tracking){
-			dir=sdir;
+	if (ttl &gt; 0) {
+		float3 dif2 = sdir - dir;
+		// steer away twice as fast as we can steer toward target
+		float tracking = std::max(shieldForce * 0.05f, weaponDef-&gt;turnrate * 2);
+		if (dif2.Length() &lt; tracking) {
+			dir = sdir;
 		} else {
-			dif2-=dir*(dif2.dot(dir));
+			dif2 -= dir * (dif2.dot(dir));
 			dif2.Normalize();
-			dir+=dif2*tracking;
+			dir += dif2 * tracking;
 			dir.Normalize();
 		}
 		return 2;

Modified: branches/gml/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -2,6 +2,7 @@
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
@@ -89,7 +90,7 @@
 {
 	if (!(weaponDef-&gt;submissile) &amp;&amp; pos.y &gt; -3) {
 		// tracking etc only works when we are underwater
-		speed.y += gs-&gt;gravity;
+		speed.y += mapInfo-&gt;map.gravity;
 		if (dir.y &gt; 0)
 			dir.y = 0;
 		dir = speed;
@@ -105,7 +106,7 @@
 
 		if (ttl &gt; 0) {
 			if (curSpeed &lt; maxSpeed)
-				curSpeed += max(0.2f, tracking);
+				curSpeed += std::max(0.2f, tracking);
 			if (target) {
 				float3 targPos;
 				if ((target-&gt;midPos - pos).SqLength() &lt; 150 * 150 || !owner)
@@ -137,7 +138,7 @@
 			}
 		} else {
 			speed *= 0.98f;
-			speed.y += gs-&gt;gravity;
+			speed.y += mapInfo-&gt;map.gravity;
 			dir = speed;
 			dir.Normalize();
 		}

Modified: branches/gml/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -231,7 +231,7 @@
 	//pos+=speed;
 
 	//if(weaponDef-&gt;gravityAffected)
-	//	speed.y+=gs-&gt;gravity;
+	//	speed.y+=mapInfo-&gt;map.gravity;
 
 
 	//if(weaponDef-&gt;noExplode)
@@ -294,39 +294,51 @@
 	return false;
 }
 
+
+
 void CWeaponProjectile::DrawUnitPart()
 {
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
+	float3 interPos = pos + speed * gu-&gt;timeOffset;
 	float3 dir(speed);
 	dir.Normalize();
 	glPushMatrix();
 	float3 rightdir;
-	if(dir.y!=1)
-		rightdir=dir.cross(UpVector);
+
+	if (dir.y != 1)
+		rightdir = dir.cross(UpVector);
 	else
-		rightdir=float3(1,0,0);
+		rightdir = float3(1, 0, 0);
+
 	rightdir.Normalize();
 	float3 updir(rightdir.cross(dir));
 
 	CMatrix44f transMatrix;
-	transMatrix[0]=-rightdir.x;
-	transMatrix[1]=-rightdir.y;
-	transMatrix[2]=-rightdir.z;
-	transMatrix[4]=updir.x;
-	transMatrix[5]=updir.y;
-	transMatrix[6]=updir.z;
-	transMatrix[8]=dir.x;
-	transMatrix[9]=dir.y;
-	transMatrix[10]=dir.z;
-	transMatrix[12]=interPos.x;
-	transMatrix[13]=interPos.y;
-	transMatrix[14]=interPos.z;
+	transMatrix[ 0] = -rightdir.x;
+	transMatrix[ 1] = -rightdir.y;
+	transMatrix[ 2] = -rightdir.z;
+	transMatrix[ 4] = updir.x;
+	transMatrix[ 5] = updir.y;
+	transMatrix[ 6] = updir.z;
+	transMatrix[ 8] = dir.x;
+	transMatrix[ 9] = dir.y;
+	transMatrix[10] = dir.z;
+	transMatrix[12] = interPos.x;
+	transMatrix[13] = interPos.y;
+	transMatrix[14] = interPos.z;
+
 	glMultMatrixf(&amp;transMatrix[0]);
-
 	glCallList(modelDispList);
 	glPopMatrix();
 }
 
+void CWeaponProjectile::DrawS3O(void)
+{
+	unitDrawer-&gt;SetS3OTeamColour(colorTeam);
+	DrawUnitPart();
+}
+
+
+
 void CWeaponProjectile::DependentDied(CObject* o)
 {
 	if(o==interceptTarget)
@@ -338,12 +350,6 @@
 	CProjectile::DependentDied(o);
 }
 
-void CWeaponProjectile::DrawS3O(void)
-{
-	unitDrawer-&gt;SetS3OTeamColour(colorTeam);
-	DrawUnitPart();
-}
-
 void CWeaponProjectile::PostLoad()
 {
 	weaponDef = weaponDefHandler-&gt;GetWeapon(weaponDefName);

Modified: branches/gml/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h
===================================================================
--- branches/gml/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -23,11 +23,13 @@
 	virtual void Collision(CFeature* feature);
 	virtual void Collision(CUnit* unit);
 	virtual void Update();
+	virtual int ShieldRepulse(CPlasmaRepulser* shield, float3 shieldPos, float shieldForce, float shieldMaxSpeed) { return 0; };	//return 0=unaffected,1=instant repulse,2=gradual repulse
+	static CWeaponProjectile* CreateWeaponProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, CUnit* target, const float3 &amp;targetPos, const WeaponDef *weaponDef);
+
 	virtual void DrawUnitPart();
+	// should not be here
 	void DrawS3O(void);
-	virtual int ShieldRepulse(CPlasmaRepulser* shield,float3 shieldPos, float shieldForce, float shieldMaxSpeed){return 0;};	//return 0=unaffected,1=instant repulse,2=gradual repulse
 
-	static CWeaponProjectile *CreateWeaponProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, CUnit *target, const float3 &amp;targetPos, const WeaponDef *weaponDef);
 	/// true if we are a nuke and a anti is on the way
 	bool targeted;
 	const WeaponDef* weaponDef;

Modified: branches/gml/rts/Sim/Units/COB/CobEngine.cpp
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobEngine.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/COB/CobEngine.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -29,10 +29,10 @@
 CCobEngine::~CCobEngine(void)
 {
 	//Should delete all things that the scheduler knows
-	for (list&lt;CCobThread *&gt;::iterator i = running.begin(); i != running.end(); ++i) {
+	for (std::list&lt;CCobThread *&gt;::iterator i = running.begin(); i != running.end(); ++i) {
 		delete *i;
 	}
-	for (list&lt;CCobThread *&gt;::iterator i = wantToRun.begin(); i != wantToRun.end(); ++i) {
+	for (std::list&lt;CCobThread *&gt;::iterator i = wantToRun.begin(); i != wantToRun.end(); ++i) {
 		delete *i;
 	}
 	while (sleeping.size() &gt; 0) {
@@ -43,7 +43,7 @@
 	}
 
 	//Free all cobfiles
-	for (map&lt;string, CCobFile *&gt;::iterator i = cobFiles.begin(); i != cobFiles.end(); ++i) {
+	for (std::map&lt;std::string, CCobFile *&gt;::iterator i = cobFiles.begin(); i != cobFiles.end(); ++i) {
 		delete i-&gt;second;
 	}
 }
@@ -105,8 +105,8 @@
 	logOutput.Print(&quot;----&quot;);
 #endif
 
-	//Advance all running threads
-	for (list&lt;CCobThread *&gt;::iterator i = running.begin(); i != running.end(); ++i) {
+	// Advance all running threads
+	for (std::list&lt;CCobThread *&gt;::iterator i = running.begin(); i != running.end(); ++i) {
 		//logOutput.Print(&quot;Now 1running %d: %s&quot;, GCurrentTime, (*i)-&gt;GetName().c_str());
 #ifdef _CONSOLE
 		printf(&quot;----\n&quot;);
@@ -119,13 +119,14 @@
 		}
 	}
 
-	//A thread can never go from running-&gt;running, so clear the list
-	//note: if preemption was to be added, this would no longer hold
-	//however, ta scripts can not run preemptively anyway since there isn't any synchronization methods available
+	// A thread can never go from running-&gt;running, so clear the list
+	// note: if preemption was to be added, this would no longer hold
+	// however, ta scripts can not run preemptively anyway since there
+	// isn't any synchronization methods available
 	running.clear();
 
-	//The threads that just ran may have added new threads that should run next tick
-	for (list&lt;CCobThread *&gt;::iterator i = wantToRun.begin(); i != wantToRun.end(); ++i) {
+	// The threads that just ran may have added new threads that should run next tick
+	for (std::list&lt;CCobThread *&gt;::iterator i = wantToRun.begin(); i != wantToRun.end(); ++i) {
 		running.push_front(*i);
 	}
 	wantToRun.clear();
@@ -162,13 +163,13 @@
 		}
 	}
 
-	//Tick all instances that have registered themselves as animating
-	list&lt;CCobInstance *&gt;::iterator it = animating.begin();
-	list&lt;CCobInstance *&gt;::iterator curit;
-	while (it != animating.end()) {			
-		curit = it++;		
+	// Tick all instances that have registered themselves as animating
+	std::list&lt;CCobInstance *&gt;::iterator it = animating.begin();
+	std::list&lt;CCobInstance *&gt;::iterator curit;
+	while (it != animating.end()) {
+		curit = it++;
 		if ((*curit)-&gt;Tick(deltaTime) == -1)
-			animating.erase(curit);		
+			animating.erase(curit);
 	}
 }
 

Modified: branches/gml/rts/Sim/Units/COB/CobEngine.h
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobEngine.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/COB/CobEngine.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -18,9 +18,7 @@
 class CCobInstance;
 class CCobFile;
 
-using namespace std;
-
-class CCobThreadPtr_less : public binary_function&lt;CCobThread *, CCobThread *, bool&gt; {
+class CCobThreadPtr_less : public std::binary_function&lt;CCobThread *, CCobThread *, bool&gt; {
 	CCobThread *a, *b;
 public:
 	bool operator() (const CCobThread *const &amp;a, const CCobThread *const &amp;b) const {return a-&gt;GetWakeTime() &gt; b-&gt;GetWakeTime();}
@@ -30,11 +28,11 @@
 class CCobEngine
 {
 protected:
-	list&lt;CCobThread *&gt; running;
-	list&lt;CCobThread *&gt; wantToRun;				//Threads are added here if they are in Running. And moved to real running after running is empty
-	priority_queue&lt;CCobThread *, vector&lt;CCobThread *&gt;, CCobThreadPtr_less&gt; sleeping;
-	list&lt;CCobInstance *&gt; animating;				//hash would be optimal. but not crucial.
-	map&lt;string, CCobFile *&gt; cobFiles;
+	std::list&lt;CCobThread *&gt; running;
+	std::list&lt;CCobThread *&gt; wantToRun;				//Threads are added here if they are in Running. And moved to real running after running is empty
+	std::priority_queue&lt;CCobThread *, vector&lt;CCobThread *&gt;, CCobThreadPtr_less&gt; sleeping;
+	std::list&lt;CCobInstance *&gt; animating;				//hash would be optimal. but not crucial.
+	std::map&lt;std::string, CCobFile *&gt; cobFiles;
 	CCobThread *curThread;
 public:
 	CCobEngine(void);
@@ -44,10 +42,10 @@
 	void RemoveInstance(CCobInstance *instance);
 	void Tick(int deltaTime);
 	void SetCurThread(CCobThread *cur);
-	void ShowScriptError(const string&amp; msg);
-	CCobFile&amp; GetCobFile(const string&amp; name);
-	CCobFile&amp; ReloadCobFile(const string&amp; name);
-	const CCobFile* GetScriptAddr(const string&amp; name) const;
+	void ShowScriptError(const std::string&amp; msg);
+	CCobFile&amp; GetCobFile(const std::string&amp; name);
+	CCobFile&amp; ReloadCobFile(const std::string&amp; name);
+	const CCobFile* GetScriptAddr(const std::string&amp; name) const;
 };
 
 extern CCobEngine GCobEngine;

Modified: branches/gml/rts/Sim/Units/COB/CobFile.cpp
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobFile.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/COB/CobFile.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -230,7 +230,7 @@
 
 int CCobFile::getFunctionId(const string &amp;name)
 {
-	map&lt;string, int&gt;::iterator i;
+	std::map&lt;std::string, int&gt;::iterator i;
 	if ((i = scriptMap.find(name)) != scriptMap.end()) {
 		return i-&gt;second;
 	}

Modified: branches/gml/rts/Sim/Units/COB/CobFile.h
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobFile.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/COB/CobFile.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -16,8 +16,6 @@
 // Should return true for scripts that should have debug output. 
 #define COB_DEBUG_FILTER (script.name == &quot;scripts/ARMJETH.cob&quot;)
 
-using namespace std;
-
 class CFileHandler;
 
 //These are mapped by the CCobFile at startup to make common function calls faster
@@ -54,21 +52,21 @@
 class CCobFile
 {
 public:
-	vector&lt;string&gt; scriptNames;
-	vector&lt;int&gt; scriptOffsets;
-	vector&lt;int&gt; scriptLengths;			//Assumes that the scripts are sorted by offset in the file
-	vector&lt;string&gt; pieceNames;
-	vector&lt;int&gt; scriptIndex;
-	vector&lt;int&gt; sounds;
-	map&lt;string, int&gt; scriptMap;
-	vector&lt;LuaHashString&gt; luaScripts;
+	std::vector&lt;std::string&gt; scriptNames;
+	std::vector&lt;int&gt; scriptOffsets;
+	std::vector&lt;int&gt; scriptLengths;			//Assumes that the scripts are sorted by offset in the file
+	std::vector&lt;std::string&gt; pieceNames;
+	std::vector&lt;int&gt; scriptIndex;
+	std::vector&lt;int&gt; sounds;
+	std::map&lt;std::string, int&gt; scriptMap;
+	std::vector&lt;LuaHashString&gt; luaScripts;
 	int* code;
 	int numStaticVars;
-	string name;
+	std::string name;
 public:
-	CCobFile(CFileHandler &amp;in, string name);
+	CCobFile(CFileHandler &amp;in, std::string name);
 	~CCobFile(void);
-	int getFunctionId(const string &amp;name);
+	int getFunctionId(const std::string &amp;name);
 };
 
 #endif // __COB_FILE_H__

Modified: branches/gml/rts/Sim/Units/COB/CobInstance.cpp
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobInstance.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/COB/CobInstance.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,6 +12,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
 #include &quot;Sim/MoveTypes/AirMoveType.h&quot;
@@ -171,7 +172,7 @@
 	//Can't delete the thread here because that would confuse the scheduler to no end
 	//Instead, mark it as dead. It is the function calling Tick that is responsible for delete.
 	//Also unregister all callbacks
-	for (list&lt;CCobThread *&gt;::iterator i = threads.begin(); i != threads.end(); ++i) {
+	for (std::list&lt;CCobThread *&gt;::iterator i = threads.begin(); i != threads.end(); ++i) {
 		(*i)-&gt;state = CCobThread::Dead;
 		(*i)-&gt;SetCallback(NULL, NULL, NULL);
 	}
@@ -179,11 +180,11 @@
 	// Remove us from possible animation ticking (should only be needed when anims.size() &gt; 0
 	GCobEngine.RemoveInstance(this);
 
-	for (list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
+	for (std::list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
 
 		//All threads blocking on animations can be killed safely from here since the scheduler does not
 		//know about them
-		for (list&lt;CCobThread *&gt;::iterator j = (*i)-&gt;listeners.begin(); j != (*i)-&gt;listeners.end(); ++j) {
+		for (std::list&lt;CCobThread *&gt;::iterator j = (*i)-&gt;listeners.begin(); j != (*i)-&gt;listeners.end(); ++j) {
 			delete *j;
 		}
 		delete *i;
@@ -191,7 +192,7 @@
 }
 int CCobInstance::Call(const string &amp;fname)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	return Call(fname, x, NULL, NULL, NULL);
 }
 
@@ -202,14 +203,14 @@
 
 int CCobInstance::Call(const string &amp;fname, int p1)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	x.push_back(p1);
 	return Call(fname, x, NULL, NULL, NULL);
 }
 
 int CCobInstance::Call(const string &amp;fname, CBCobThreadFinish cb, void *p1, void *p2)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	return Call(fname, x, cb, p1, p2);
 }
 
@@ -226,13 +227,13 @@
 
 int CCobInstance::Call(int id)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	return Call(id, x, NULL, NULL, NULL);
 }
 
 int CCobInstance::Call(int id, int p1)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	x.push_back(p1);
 	return Call(id, x, NULL, NULL, NULL);
 }
@@ -244,7 +245,7 @@
 
 int CCobInstance::Call(int id, CBCobThreadFinish cb, void *p1, void *p2)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	return Call(id, x, cb, p1, p2);
 }
 
@@ -397,7 +398,7 @@
 // Unblocks all threads waiting on this animation
 void CCobInstance::UnblockAll(struct AnimInfo * anim)
 {
-	list&lt;CCobThread *&gt;::iterator li;
+	std::list&lt;CCobThread *&gt;::iterator li;
 
 	for (li = anim-&gt;listeners.begin(); li != anim-&gt;listeners.end(); ++li) {
 		//Not sure how to do this more cleanly.. Will probably rewrite it
@@ -419,8 +420,8 @@
 int CCobInstance::Tick(int deltaTime)
 {
 	int done;
-	list&lt;struct AnimInfo *&gt;::iterator it = anims.begin();
-	list&lt;struct AnimInfo *&gt;::iterator cur;
+	std::list&lt;struct AnimInfo *&gt;::iterator it = anims.begin();
+	std::list&lt;struct AnimInfo *&gt;::iterator cur;
 
 	while (it != anims.end()) {
 		//Advance it, so we can erase cur safely
@@ -460,7 +461,7 @@
 //Returns anims list
 struct CCobInstance::AnimInfo *CCobInstance::FindAnim(AnimType type, int piece, int axis)
 {
-	for (list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
+	for (std::list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
 		if (((*i)-&gt;type == type) &amp;&amp; ((*i)-&gt;piece == piece) &amp;&amp; ((*i)-&gt;axis == axis))
 			return *i;
 	}
@@ -470,7 +471,7 @@
 // Returns true if an animation was found and deleted
 void CCobInstance::RemoveAnim(AnimType type, int piece, int axis)
 {
-	for (list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
+	for (std::list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
 		if (((*i)-&gt;type == type) &amp;&amp; ((*i)-&gt;piece == piece) &amp;&amp; ((*i)-&gt;axis == axis)) {
 
 			// We need to unblock threads waiting on this animation, otherwise they will be lost in the void
@@ -794,7 +795,7 @@
 
 void CCobInstance::Signal(int signal)
 {
-	for (list&lt;CCobThread *&gt;::iterator i = threads.begin(); i != threads.end(); ++i) {
+	for (std::list&lt;CCobThread *&gt;::iterator i = threads.begin(); i != threads.end(); ++i) {
 		if ((signal &amp; (*i)-&gt;signalMask) != 0) {
 			(*i)-&gt;state = CCobThread::Dead;
 			//logOutput.Print(&quot;Killing a thread %d %d&quot;, signal, (*i)-&gt;signalMask);
@@ -1255,9 +1256,9 @@
 		return weapon-&gt;AttackGround(pos, userTarget) ? 1 : 0;
 	}
 	case MIN:
-		return min(p1, p2);
+		return std::min(p1, p2);
 	case MAX:
-		return max(p1, p2);
+		return std::max(p1, p2);
 	case ABS:
 		return abs(p1);
 	case FLANK_B_MODE:
@@ -1499,7 +1500,7 @@
 		}
 		case YARD_OPEN: {
 			if (param == 0) {
-				if (uh-&gt;CanCloseYard(unit)) {
+				if (groundBlockingObjectMap-&gt;CanCloseYard(unit)) {
 					yardOpen = false;
 				}
 			}
@@ -1608,7 +1609,7 @@
 		case SHIELD_POWER: {
 			if (unit-&gt;shieldWeapon != NULL) {
 				CPlasmaRepulser* shield = (CPlasmaRepulser*)unit-&gt;shieldWeapon;
-				shield-&gt;curPower = max(0.0f, float(param) / float(COBSCALE));
+				shield-&gt;curPower = std::max(0.0f, float(param) / float(COBSCALE));
 			}
 			break;
 		}

Modified: branches/gml/rts/Sim/Units/COB/CobInstance.h
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobInstance.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/COB/CobInstance.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -24,14 +24,12 @@
 class CCobInstance;
 class CUnit;
 
-using namespace std;
-
 typedef void (*CBCobThreadFinish) (int retCode, void *p1, void *p2);
 
 struct PieceInfo {
 	int coords[3];
 	int rot[3];
-	string name;
+	std::string name;
 	bool updated;
 	bool visible;
 };
@@ -65,9 +63,9 @@
 		int dest;		//means final position when turning or moving, final speed when spinning
 		int accel;		//used for spinning, can be negative
 		bool interpolated;	//true if this animation is a result of interpolating a direct move/turn
-		list&lt;CCobThread *&gt; listeners;
+		std::list&lt;CCobThread *&gt; listeners;
 	};
-	list&lt;struct AnimInfo *&gt; anims;
+	std::list&lt;struct AnimInfo *&gt; anims;
 	CUnit *unit;
 	bool yardOpen;
 	void UnblockAll(struct AnimInfo * anim);
@@ -80,9 +78,9 @@
 
 public:
 	bool busy;
-	vector&lt;int&gt; staticVars;
-	list&lt;CCobThread *&gt; threads;
-	vector&lt;struct PieceInfo&gt; pieces;	
+	std::vector&lt;int&gt; staticVars;
+	std::list&lt;CCobThread *&gt; threads;
+	std::vector&lt;struct PieceInfo&gt; pieces;	
 	bool smoothAnim;
 	const CCobFile* GetScriptAddr() const { return &script; }
 
@@ -99,19 +97,19 @@
 	inline       CUnit* GetUnit()       { return unit; }
 	inline const CUnit* GetUnit() const { return unit; }
 	void InitVars();
-	int Call(const string &amp;fname);
-	int Call(const string &amp;fname, int p1);
-	int Call(const string &amp;fname, vector&lt;int&gt; &amp;args);
-	int Call(const string &amp;fname, CBCobThreadFinish cb, void *p1, void *p2);
-	int Call(const string &amp;fname, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
+	int Call(const std::string &amp;fname);
+	int Call(const std::string &amp;fname, int p1);
+	int Call(const std::string &amp;fname, std::vector&lt;int&gt; &amp;args);
+	int Call(const std::string &amp;fname, CBCobThreadFinish cb, void *p1, void *p2);
+	int Call(const std::string &amp;fname, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
 	int Call(int id);
-	int Call(int id, vector&lt;int&gt; &amp;args);
+	int Call(int id, std::vector&lt;int&gt; &amp;args);
 	int Call(int id, int p1);
 	int Call(int id, CBCobThreadFinish cb, void *p1, void *p2);
-	int Call(int id, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
-	int RawCall(int fn, vector&lt;int&gt; &amp;args);
-	int RawCall(int fn, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
-	int RealCall(int functionId, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
+	int Call(int id, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
+	int RawCall(int fn, std::vector&lt;int&gt; &amp;args);
+	int RawCall(int fn, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
+	int RealCall(int functionId, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
 	int Tick(int deltaTime);
 	int MoveToward(int &amp;cur, int dest, int speed);
 	int TurnToward(int &amp;cur, int dest, int speed);
@@ -141,7 +139,7 @@
 	void TurnSmooth(int piece, int axis, int destination, int delta, int deltaTime);
 	bool HasScriptFunction(int id);
 	bool FunctionExist(int id);
-	int GetFunctionId(const string&amp; funcName) const;
+	int GetFunctionId(const std::string&amp; funcName) const;
 };
 
 #endif // __COB_INSTANCE_H__

Modified: branches/gml/rts/Sim/Units/COB/CobThread.cpp
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobThread.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/COB/CobThread.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -923,10 +923,10 @@
 	const int r2 = GET_LONG_PC(); // arg count
 
 	// setup the parameter array
-	const int size = (int)stack.size();
-	const int argCount = min(r2, MAX_LUA_COB_ARGS);
-	const int start = max(0, size - r2);
-	const int end = min(size, start + argCount);
+	const int size = (int) stack.size();
+	const int argCount = std::min(r2, MAX_LUA_COB_ARGS);
+	const int start = std::max(0, size - r2);
+	const int end = std::min(size, start + argCount);
 	int a = 0;
 	for (int i = start; i &lt; end; i++) {
 		luaArgs[a] = stack[i];

Modified: branches/gml/rts/Sim/Units/COB/CobThread.h
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobThread.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/COB/CobThread.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -10,8 +10,6 @@
 class CCobFile;
 class CCobInstance;
 
-using namespace std;
-
 class CCobThread : public CObject
 {
 protected:

Modified: branches/gml/rts/Sim/Units/CommandAI/AirCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,7 +5,6 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/UI/CommandColors.h&quot;
-#include &quot;Game/UI/CursorIcons.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Rendering/GL/glExtra.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;

Modified: branches/gml/rts/Sim/Units/CommandAI/BuilderCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -18,6 +18,7 @@
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/MoveTypes/MoveType.h&quot;
 #include &quot;Sim/Units/UnitSet.h&quot;
@@ -310,7 +311,7 @@
 				int yardypos=int(bi.pos.z+4)/SQUARE_SIZE;
 				CSolidObject* s;
 				CUnit* u;
-				if((s=readmap-&gt;GroundBlocked(yardypos*gs-&gt;mapx+yardxpos)) &amp;&amp;
+				if((s=groundBlockingObjectMap-&gt;GroundBlocked(yardypos*gs-&gt;mapx+yardxpos)) &amp;&amp;
 				   (u=dynamic_cast&lt;CUnit*&gt;(s)) &amp;&amp;
 				   u-&gt;beingBuilt &amp;&amp; (u-&gt;buildProgress == 0.0f) &amp;&amp;
 				   (!u-&gt;soloBuilder || (u-&gt;soloBuilder == owner))) {
@@ -1101,7 +1102,7 @@
 		const CFeature* f = *fi;
 		if (f-&gt;def-&gt;reclaimable &amp;&amp;
 		    (recAnyTeam || (f-&gt;allyteam != owner-&gt;allyteam))) {
-			const float dist = f3Dist(f-&gt;pos, owner-&gt;pos);
+			const float dist = f3SqLen(f-&gt;pos - owner-&gt;pos);
 			if ((dist &lt; bestDist) &amp;&amp;
 			    (noResCheck ||
 			     ((f-&gt;def-&gt;metal  &gt; 0.0f) &amp;&amp; (team-&gt;metal  &lt; team-&gt;metalStorage)) ||
@@ -1145,7 +1146,7 @@
 	for (fi = features.begin(); fi != features.end(); ++fi) {
 		const CFeature* f = *fi;
 		if (f-&gt;def-&gt;destructable &amp;&amp; f-&gt;createdFromUnit != &quot;&quot;) {
-			const float dist = f3Dist(f-&gt;pos, owner-&gt;pos);
+			const float dist = f3SqLen(f-&gt;pos - owner-&gt;pos);
 			if (dist &lt; bestDist) {
 				// dont lock-on to units outside of our reach (for immobile builders)
 				if (!owner-&gt;unitDef-&gt;canmove &amp;&amp; !ObjInBuildRange(f)) {
@@ -1185,7 +1186,7 @@
 
 		if (!gs-&gt;Ally(myAllyteam, unit-&gt;allyteam) &amp;&amp; (unit != owner) &amp;&amp;
 			!unit-&gt;beingBuilt &amp;&amp; unit-&gt;unitDef-&gt;capturable) {
-			const float dist = f3Dist(unit-&gt;pos, owner-&gt;pos);
+			const float dist = f3SqLen(unit-&gt;pos - owner-&gt;pos);
 
 			if (dist &lt; bestDist) {
 				// dont lock-on to units outside of our reach (for immobile builders)
@@ -1250,7 +1251,7 @@
 					trySelfRepair = true;
 					continue;
 				}
-				const float dist = f3Dist(unit-&gt;pos, owner-&gt;pos);
+				const float dist = f3SqLen(unit-&gt;pos - owner-&gt;pos);
 				if (dist &lt; bestDist) {
 					bestDist = dist;
 					best = unit;
@@ -1259,7 +1260,7 @@
 		}
 		else {
 			if (attackEnemy &amp;&amp; owner-&gt;unitDef-&gt;canAttack &amp;&amp; (owner-&gt;maxRange &gt; 0)) {
-				const float dist = f3Dist(unit-&gt;pos, owner-&gt;pos);
+				const float dist = f3SqLen(unit-&gt;pos - owner-&gt;pos);
 				if ((dist &lt; bestDist) || !haveEnemy) {
 					if (!owner-&gt;unitDef-&gt;canmove &amp;&amp;
 					    ((dist - unit-&gt;radius) &gt; owner-&gt;maxRange)) {

Modified: branches/gml/rts/Sim/Units/CommandAI/Command.h
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/Command.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/CommandAI/Command.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,10 +6,6 @@
 #include &lt;limits.h&gt; // for INT_MAX
 #include &quot;creg/creg.h&quot;
 
-
-using namespace std; // FIXME -- should not have this in an external interface?
-
-
 // cmds lower than 0 is reserved for build options (cmd -x = unitdefs[x])
 #define CMD_STOP                   0
 #define CMD_INSERT                 1
@@ -113,13 +109,13 @@
 
 
 struct CommandDescription {
-	CR_DECLARE_STRUCT(CommandDescription)
+	CR_DECLARE_STRUCT(CommandDescription);
 
 	CommandDescription()
 	: showUnique(false),
 	  onlyKey(false),
 	  onlyTexture(false),
-	  disabled(false) {}
+	  disabled(false) {};
 
 	int id;    // CMD_xxx     code  (custom codes can also be used)
 	int type;  // CMDTYPE_xxx code 

Modified: branches/gml/rts/Sim/Units/CommandAI/CommandAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -219,7 +219,6 @@
 		c.params.push_back(&quot;Roam&quot;);
 		c.tooltip=&quot;Move State: Sets how far out of its way\n an unit will move to attack enemies&quot;;
 		possibleCommands.push_back(c);
-		owner-&gt;moveState=1;
 		nonQueingCommands.insert(CMD_MOVE_STATE);
 	} else {
 		owner-&gt;moveState=0;
@@ -958,8 +957,8 @@
 					BuildInfo bc(c);
 					BuildInfo bt(t);
 					if (bc.def &amp;&amp; bt.def
-					    &amp;&amp; fabs(bc.pos.x - bt.pos.x) * 2 &lt;= max(bc.GetXSize(), bt.GetXSize()) * SQUARE_SIZE
-					    &amp;&amp; fabs(bc.pos.z - bt.pos.z) * 2 &lt;= max(bc.GetYSize(), bt.GetYSize()) * SQUARE_SIZE) {
+					    &amp;&amp; fabs(bc.pos.x - bt.pos.x) * 2 &lt;= std::max(bc.GetXSize(), bt.GetXSize()) * SQUARE_SIZE
+					    &amp;&amp; fabs(bc.pos.z - bt.pos.z) * 2 &lt;= std::max(bc.GetYSize(), bt.GetYSize()) * SQUARE_SIZE) {
 						return ci;
 					}
 				} else {
@@ -1058,8 +1057,8 @@
 						const float dist2Z = 2.0f * fabs(cbi.pos.z - tbi.pos.z);
 						const float addSizeX = SQUARE_SIZE * (cbi.GetXSize() + tbi.GetXSize());
 						const float addSizeZ = SQUARE_SIZE * (cbi.GetYSize() + tbi.GetYSize());
-						const float maxSizeX = SQUARE_SIZE * max(cbi.GetXSize(), tbi.GetXSize());
-						const float maxSizeZ = SQUARE_SIZE * max(cbi.GetYSize(), tbi.GetYSize());
+						const float maxSizeX = SQUARE_SIZE * std::max(cbi.GetXSize(), tbi.GetXSize());
+						const float maxSizeZ = SQUARE_SIZE * std::max(cbi.GetYSize(), tbi.GetYSize());
 						if (cbi.def &amp;&amp; tbi.def &amp;&amp;
 						    ((dist2X &gt; maxSizeX) || (dist2Z &gt; maxSizeZ)) &amp;&amp;
 						    ((dist2X &lt; addSizeX) &amp;&amp; (dist2Z &lt; addSizeZ))) {

Modified: branches/gml/rts/Sim/Units/CommandAI/CommandQueue.h
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/CommandQueue.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/CommandAI/CommandQueue.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,14 +13,14 @@
 	friend class CCommandAI;
 	friend class CFactoryCAI;
 
-	enum QueueType {
-		CommandQueueType,
-		NewUnitQueueType,
-		BuildQueueType
-	};
-
 	CR_DECLARE(CCommandQueue);
 	public:
+		enum QueueType {
+			CommandQueueType,
+			NewUnitQueueType,
+			BuildQueueType
+		};
+
 		inline QueueType GetType() const { return queueType; }
 
 	public:
@@ -87,8 +87,8 @@
 
 	private:
 		std::deque&lt;Command&gt; queue;
+		QueueType queueType;
 		int tagCounter;
-		QueueType queueType;
 };
 
 

Modified: branches/gml/rts/Sim/Units/CommandAI/FactoryCAI.h
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/FactoryCAI.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/CommandAI/FactoryCAI.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,8 +5,6 @@
 #include &lt;string&gt;
 #include &lt;map&gt;
 
-using namespace std;
-
 class CFactoryCAI :
 	public CCommandAI
 {
@@ -15,8 +13,8 @@
 	CR_DECLARE_SUB(BuildOption);
 	struct BuildOption {
 		CR_DECLARE_STRUCT(BuildOption)
-		string name;
-		string fullName;
+		std::string name;
+		std::string fullName;
 		int numQued;
 	};
 
@@ -40,7 +38,7 @@
 
 	CCommandQueue newUnitCommands;
 
-	map&lt;int,BuildOption&gt; buildOptions;
+	std::map&lt;int, BuildOption&gt; buildOptions;
 
 	bool building;
 

Modified: branches/gml/rts/Sim/Units/CommandAI/MobileCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,7 +7,6 @@
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Game/UI/CommandColors.h&quot;
-#include &quot;Game/UI/CursorIcons.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Sim/Misc/AirBaseHandler.h&quot;
@@ -282,7 +281,7 @@
 					owner-&gt;moveType-&gt;StopMoving();
 				}
 			}
-		} else if(owner-&gt;currentFuel &lt; 
+		} else if(owner-&gt;currentFuel &lt;
 				(owner-&gt;moveType-&gt;repairBelowHealth * owner-&gt;unitDef-&gt;maxFuel)
 				&amp;&amp; commandQue.empty() || commandQue.front().id == CMD_PATROL
 				|| commandQue.front().id == CMD_FIGHT) {
@@ -335,7 +334,7 @@
 		const Command&amp; c = *it;
 		if ((c.id == CMD_SET_WANTED_MAX_SPEED) &amp;&amp; (c.params.size() &gt;= 1)) {
 			const float defMaxSpeed = owner-&gt;maxSpeed;
-			const float newMaxSpeed = min(c.params[0], defMaxSpeed);
+			const float newMaxSpeed = std::min(c.params[0], defMaxSpeed);
 			if (newMaxSpeed &gt; 0)
 				owner-&gt;moveType-&gt;SetMaxSpeed(newMaxSpeed);
 		}
@@ -714,14 +713,14 @@
 		}
 
 		double diffLength2d = diff.Length2D();
-		
+
 		// if w-&gt;AttackUnit() returned true then we are already
 		// in range with our biggest weapon so stop moving
 		// also make sure that we're not locked in close-in/in-range state loop
 		// due to rotates invoked by in-range or out-of-range states
 		if (b2) {
 			if (!(tempOrder &amp;&amp; owner-&gt;moveState == 0)
-				&amp;&amp; (diffLength2d * 1.4f &gt; owner-&gt;maxRange 
+				&amp;&amp; (diffLength2d * 1.4f &gt; owner-&gt;maxRange
 					- orderTarget-&gt;speed.SqLength()
 							/ owner-&gt;unitDef-&gt;maxAcc)
 				&amp;&amp; b4 &amp;&amp; diff.dot(orderTarget-&gt;speed) &lt; 0)
@@ -733,7 +732,7 @@
 				// FIXME kill magic frame number
 				if (gs-&gt;frameNum &gt; lastCloseInTry + MAX_CLOSE_IN_RETRY_TICKS) {
 					owner-&gt;moveType-&gt;KeepPointingTo(orderTarget,
-							min((float) (owner-&gt;losRadius * SQUARE_SIZE * 2),
+							std::min((float) (owner-&gt;losRadius * SQUARE_SIZE * 2),
 									owner-&gt;maxRange * 0.9f), true);
 				}
 			}
@@ -748,7 +747,7 @@
 			{
 				StopMove();
 				owner-&gt;moveType-&gt;KeepPointingTo(orderTarget,
-						min((float) (owner-&gt;losRadius * SQUARE_SIZE * 2),
+						std::min((float) (owner-&gt;losRadius * SQUARE_SIZE * 2),
 								owner-&gt;maxRange * 0.9f), true);
 			} else if(tempOrder &amp;&amp; owner-&gt;moveState == 0){
 				SetGoal(lastUserGoal, owner-&gt;pos);
@@ -778,9 +777,16 @@
 		// in on target more
 		else if ((orderTarget-&gt;pos + owner-&gt;posErrorVector * 128).distance2D(goalPos)
 				&gt; (10 + orderTarget-&gt;pos.distance2D(owner-&gt;pos) * 0.2f)) {
-			float3 fix = orderTarget-&gt;pos + owner-&gt;posErrorVector * 128;
+			// if the target isn't in LOS, go to its approximate position
+			// otherwise try to go precisely to the target
+			// this should fix issues with low range weapons (mainly melee)
+			float3 fix = orderTarget-&gt;pos +
+					(orderTarget-&gt;losStatus[owner-&gt;allyteam] &amp; LOS_INLOS ?
+						float3(0.f,0.f,0.f) :
+						owner-&gt;posErrorVector * 128);
 			float3 norm = float3(fix - owner-&gt;pos).Normalize();
-			SetGoal(fix - norm*(orderTarget-&gt;radius*edgeFactor*0.8f), owner-&gt;pos);
+			float3 goal = fix - norm*(orderTarget-&gt;radius*edgeFactor*0.8f);
+			SetGoal(goal, owner-&gt;pos);
 			if (lastCloseInTry &lt; gs-&gt;frameNum + MAX_CLOSE_IN_RETRY_TICKS)
 				lastCloseInTry = gs-&gt;frameNum;
 		}

Modified: branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,7 +9,6 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Game/UI/CommandColors.h&quot;
-#include &quot;Game/UI/CursorIcons.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/glExtra.h&quot;
@@ -344,7 +343,7 @@
 			return true;
 		}
 	} else {
-		for (float y = max(emptyRadius, center.z - radius); y &lt; min(float(gs-&gt;mapy * SQUARE_SIZE - emptyRadius), center.z + radius); y += SQUARE_SIZE) {
+		for (float y = std::max(emptyRadius, center.z - radius); y &lt; std::min(float(gs-&gt;mapy * SQUARE_SIZE - emptyRadius), center.z + radius); y += SQUARE_SIZE) {
 			float dy = y - center.z;
 			float rx = radius * radius - dy * dy;
 
@@ -353,7 +352,7 @@
 
 			rx = sqrt(rx);
 
-			for (float x = max(emptyRadius, center.x - rx); x &lt; min(float(gs-&gt;mapx * SQUARE_SIZE - emptyRadius), center.x + rx); x += SQUARE_SIZE) {
+			for (float x = std::max(emptyRadius, center.x - rx); x &lt; std::min(float(gs-&gt;mapx * SQUARE_SIZE - emptyRadius), center.x + rx); x += SQUARE_SIZE) {
 				float unloadPosHeight = ground-&gt;GetApproximateHeight(x, y);
 
 				if (unloadPosHeight &lt; (0 - unitToUnload-&gt;unitDef-&gt;maxWaterDepth))
@@ -396,7 +395,7 @@
 bool CTransportCAI::FindEmptyDropSpots(float3 startpos, float3 endpos, std::list&lt;float3&gt;&amp; dropSpots) {
 	//should only be used by air
 
-	CTransportUnit* transport=(CTransportUnit*)owner;
+	CTransportUnit* transport = (CTransportUnit*)owner;
 	//dropSpots.clear();
 	float gap = 25.5; //TODO - set tag for this?
 	float3 dir = endpos - startpos;
@@ -405,19 +404,16 @@
 	float3 nextPos = startpos;
 	float3 pos;
 
-	list&lt;CTransportUnit::TransportedUnit&gt;::iterator ti = transport-&gt;transported.begin();
+	std::list&lt;CTransportUnit::TransportedUnit&gt;::iterator ti = transport-&gt;transported.begin();
 	dropSpots.push_front(nextPos);
 
-	//first spot
+	// first spot
 	if (ti!=transport-&gt;transported.end()) {
-		//float3 p = nextPos; //test to make intended land spots visible
-		//inMapDrawer-&gt;CreatePoint(p,ti-&gt;unit-&gt;unitDef-&gt;name);
-		//p.z +=transport-&gt;transportCapacityUsed*5;
 		nextPos += dir*(gap + ti-&gt;unit-&gt;radius);
 		ti++;
 	}
 
-	//remaining spots
+	// remaining spots
 	if (dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType)) {
 		while (ti != transport-&gt;transported.end() &amp;&amp; startpos.distance(nextPos) &lt; startpos.distance(endpos)) {
 			nextPos += dir*(ti-&gt;unit-&gt;radius);
@@ -463,7 +459,7 @@
 	float spread = u-&gt;radius * ((CTransportUnit*) owner)-&gt;unitDef-&gt;unloadSpread;
 	float3 found;
 
-	bool canUnload = FindEmptySpot(pos, max(16.0f, radius), spread, found, u);
+	bool canUnload = FindEmptySpot(pos, std::max(16.0f, radius), spread, found, u);
 
 	if (canUnload) {
 		Command c2;
@@ -503,7 +499,7 @@
 
 			approachVector = startingDropPos-owner-&gt;pos;
 			approachVector.Normalize();
-			canUnload = FindEmptyDropSpots(pos, pos + approachVector*max(16.0f,radius), dropSpots);
+			canUnload = FindEmptyDropSpots(pos, pos + approachVector * std::max(16.0f,radius), dropSpots);
 
 		} else if (!dropSpots.empty() ) {
 			//make sure we check current spot infront of us each unload
@@ -553,7 +549,7 @@
 	float3 found;
 	//((CTransportUnit*)owner)-&gt;transported
 
-	bool canUnload=FindEmptySpot(pos,max(16.0f,radius),((CTransportUnit*)owner)-&gt;transported.front().unit-&gt;radius  * ((CTransportUnit*)owner)-&gt;unitDef-&gt;unloadSpread,
+	bool canUnload=FindEmptySpot(pos, std::max(16.0f,radius),((CTransportUnit*)owner)-&gt;transported.front().unit-&gt;radius  * ((CTransportUnit*)owner)-&gt;unitDef-&gt;unloadSpread,
 								found,((CTransportUnit*)owner)-&gt;transported.front().unit);
 	if(canUnload){
 
@@ -999,7 +995,7 @@
 			float radius = c.params[3];
 			float spread = u-&gt;radius * transport-&gt;unitDef-&gt;unloadSpread;
 			float3 found;
-			bool canUnload = FindEmptySpot(pos, max(16.0f, radius), spread, found, u);
+			bool canUnload = FindEmptySpot(pos, std::max(16.0f, radius), spread, found, u);
 			if(!canUnload) return false;
 			break;
 		}

Modified: branches/gml/rts/Sim/Units/Unit.cpp
===================================================================
--- branches/gml/rts/Sim/Units/Unit.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/Unit.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -21,14 +21,17 @@
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MetalMap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Rendering/GroundFlash.h&quot;
 
 #include &quot;Sim/Misc/AirBaseHandler.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
@@ -82,6 +85,7 @@
 
 CUnit::CUnit ()
 :	unitDef(0),
+	collisionVolume(0),
 	team(0),
 	maxHealth(100),
 	health(100),
@@ -232,11 +236,16 @@
 
 CUnit::~CUnit()
 {
-	if(delayedWreckLevel&gt;=0){
-		featureHandler-&gt;CreateWreckage(pos,wreckName, heading, buildFacing, delayedWreckLevel,team,-1,true,unitDef-&gt;name);
+	if (delayedWreckLevel &gt;= 0) {
+		// note: could also do this in Update() or even in CUnitKilledCB()
+		// where we wouldn't need deathSpeed, but not in KillUnit() since
+		// we have to wait for deathScriptFinished (but we want the delay
+		// in frames between CUnitKilledCB() and the CreateWreckage() call
+		// to be as short as possible to prevent visual position jumps)
+		featureHandler-&gt;CreateWreckage(pos, wreckName, heading, buildFacing, delayedWreckLevel, team, -1, true, unitDef-&gt;name,  deathSpeed);
 	}
 
-	if(unitDef-&gt;isAirBase){
+	if (unitDef-&gt;isAirBase) {
 		airBaseHandler-&gt;DeregisterAirBase(this);
 	}
 
@@ -252,18 +261,17 @@
 	}
 #endif
 
-	if(activated &amp;&amp; unitDef-&gt;targfac){
-		radarhandler-&gt;radarErrorSize[allyteam]*=radarhandler-&gt;targFacEffect;
+	if (activated &amp;&amp; unitDef-&gt;targfac) {
+		radarhandler-&gt;radarErrorSize[allyteam] *= radarhandler-&gt;targFacEffect;
 	}
 
-//	if(!beingBuilt){
 	SetMetalStorage(0);
 	SetEnergyStorage(0);
-//	}
 
-	delete commandAI;     commandAI    = NULL;
-	delete moveType;      moveType     = NULL;
-	delete prevMoveType;  prevMoveType = NULL;
+	delete commandAI;       commandAI       = NULL;
+	delete moveType;        moveType        = NULL;
+	delete prevMoveType;    prevMoveType    = NULL;
+	delete collisionVolume; collisionVolume = NULL;
 
 	if (group) {
 		group-&gt;RemoveUnit(this);
@@ -271,14 +279,14 @@
 	group = NULL;
 
 	std::vector&lt;CWeapon*&gt;::iterator wi;
-	for(wi=weapons.begin();wi!=weapons.end();++wi)
+	for (wi = weapons.begin(); wi != weapons.end(); ++wi)
 		delete *wi;
 
 	qf-&gt;RemoveUnit(this);
 	loshandler-&gt;DelayedFreeInstance(los);
-	los=0;
+	los = 0;
 
-	if(hasRadarCapacity)
+	if (hasRadarCapacity)
 		radarhandler-&gt;RemoveUnit(this);
 
 	delete cob;
@@ -302,7 +310,7 @@
 }
 
 
-void CUnit::UnitInit (const UnitDef* def, int Team, const float3&amp; position)
+void CUnit::UnitInit(const UnitDef* def, int Team, const float3&amp; position)
 {
 	pos = position;
 	team = Team;
@@ -347,9 +355,7 @@
 	}
 
 	pos = newPos;
-	midPos = pos + (frontdir * relMidPos.z) +
-	               (updir    * relMidPos.y) +
-	               (rightdir * relMidPos.x);
+	UpdateMidPos();
 
 	if (building &amp;&amp; unitDef-&gt;useBuildingGroundDecal) {
 		groundDecals-&gt;AddBuilding(building);
@@ -375,6 +381,48 @@
 }
 
 
+void CUnit::SetFront(const SyncedFloat3&amp; newDir)
+{
+	frontdir = newDir;
+	frontdir.Normalize();
+	rightdir = frontdir.cross(updir);
+	rightdir.Normalize();
+	updir = rightdir.cross(frontdir);
+	updir.Normalize();
+	heading = GetHeadingFromVector(frontdir.x, frontdir.z);
+	UpdateMidPos();
+}
+
+void CUnit::SetUp(const SyncedFloat3&amp; newDir)
+{
+	updir = newDir;
+	updir.Normalize();
+	frontdir = updir.cross(rightdir);
+	frontdir.Normalize();
+	rightdir = frontdir.cross(updir);
+	rightdir.Normalize();
+	heading = GetHeadingFromVector(frontdir.x, frontdir.z);
+	UpdateMidPos();
+}
+
+void CUnit::SetRight(const SyncedFloat3&amp; newDir)
+{
+	rightdir = newDir;
+	rightdir.Normalize();
+	updir = rightdir.cross(frontdir);
+	updir.Normalize();
+	frontdir = updir.cross(rightdir);
+	frontdir.Normalize();
+	heading = GetHeadingFromVector(frontdir.x, frontdir.z);
+	UpdateMidPos();
+}
+
+void CUnit::UpdateMidPos()
+{
+	midPos = pos + (frontdir * relMidPos.z) + (updir * relMidPos.y)
+		+ (rightdir * relMidPos.x);
+}
+
 void CUnit::Drop(float3 parentPos,float3 parentDir, CUnit* parent)
 {
 	//drop unit from position
@@ -425,18 +473,30 @@
 {
 	posErrorVector += posErrorDelta;
 
+	if (deathScriptFinished) {
+		// if our kill-script is already finished, don't
+		// wait for the deathCountdown to reach zero and
+		// just delete us ASAP (costs one extra frame)
+		uh-&gt;DeleteUnit(this);
+		return;
+	}
+
 	if (deathCountdown) {
 		--deathCountdown;
+
 		if (!deathCountdown) {
 			if (deathScriptFinished) {
+				// kill-script has terminated, remove unit now
 				uh-&gt;DeleteUnit(this);
 			} else {
+				// kill-script still running, delay one more frame
 				deathCountdown = 1;
 			}
 		}
 		return;
 	}
 
+
 	if (beingBuilt) {
 		return;
 	}
@@ -459,7 +519,7 @@
 
 	if (!dontUseWeapons) {
 		std::vector&lt;CWeapon*&gt;::iterator wi;
-		for (wi = weapons.begin();wi != weapons.end(); ++wi) {
+		for (wi = weapons.begin(); wi != weapons.end(); ++wi) {
 			(*wi)-&gt;Update();
 		}
 	}
@@ -491,8 +551,10 @@
 
 	if (loshandler-&gt;InLos(this, at)) {
 		if ((prevLosStatus &amp; LOS_INLOS) == 0) {
-
+			// we were not previously in LOS for this allyteam
 			if (beingBuilt) {
+				// we are being built, do not set LOS_PREVLOS
+				// since we do not want ghosts for nanoframes
 				losStatus[at] |= (LOS_INLOS | LOS_INRADAR);
 			} else {
 				losStatus[at] |= (LOS_INLOS | LOS_INRADAR | LOS_PREVLOS | LOS_CONTRADAR);
@@ -504,6 +566,13 @@
 			}
 			luaCallIns.UnitEnteredLos(this, at);
 			globalAI-&gt;UnitEnteredLos(this, at);
+		} else {
+			// if we were previously in LOS but still being built
+			// then LOS_PREVLOS and LOS_CONTRADAR weren't set for
+			// us yet, do so now
+			if (!beingBuilt) {
+				losStatus[at] |= (LOS_PREVLOS | LOS_CONTRADAR);
+			}
 		}
 	}
 	else if (radarhandler-&gt;InRadar(this, at)) {
@@ -872,7 +941,7 @@
 	if (paralyzeTime == 0) { // real damage
 		if (damage &gt; 0.0f) {
 			// Dont log overkill damage (so dguns/nukes etc dont inflate values)
-			const float statsdamage = max(0.0f, min(maxHealth - health, damage));
+			const float statsdamage = std::max(0.0f, std::min(maxHealth - health, damage));
 			if (attacker) {
 				gs-&gt;Team(attacker-&gt;team)-&gt;currentStats.damageDealt += statsdamage;
 			}
@@ -904,7 +973,7 @@
 				if (paralyzeDamage &gt; health) {
 					stunned = true;
 				}
-				paralyzeDamage = min(paralyzeDamage, maxParaDmg);
+				paralyzeDamage = std::min(paralyzeDamage, maxParaDmg);
 			}
 		}
 		else { // paralyzation healing
@@ -926,7 +995,7 @@
 		if ((attacker != NULL) &amp;&amp; !gs-&gt;Ally(allyteam, attacker-&gt;allyteam)) {
 			attacker-&gt;AddExperience(0.1f * experienceMod
 			                             * (power / attacker-&gt;power)
-			                             * (damage + min(0.0f, health)) / maxHealth);
+			                             * (damage + std::min(0.0f, health)) / maxHealth);
 			ENTER_UNSYNCED;
 			const int warnFrame = (gs-&gt;frameNum - 100);
 			if ((team == gu-&gt;myTeam)
@@ -987,13 +1056,13 @@
 /******************************************************************************/
 /******************************************************************************/
 
-void CUnit::GetTransformMatrix(CMatrix44f&amp; matrix) const
+void CUnit::GetTransformMatrix(CMatrix44f&amp; matrix, bool synced) const
 {
 	float3 interPos;
 	if (!transporter) {
-		interPos = pos + (speed * gu-&gt;timeOffset);
+		interPos = (synced? pos: pos + (speed * gu-&gt;timeOffset));
 	} else {
-		interPos = pos + (transporter-&gt;speed * gu-&gt;timeOffset);
+		interPos = (synced? pos: pos + (transporter-&gt;speed * gu-&gt;timeOffset));
 	}
 
 	if (usingScriptMoveType ||
@@ -1323,7 +1392,7 @@
 
 void CUnit::SetLastAttacker(CUnit* attacker)
 {
-	if(gs-&gt;Ally(team, attacker-&gt;team)){
+	if(gs-&gt;Ally(team, attacker-&gt;team) || gs-&gt;AlliedTeams(team, attacker-&gt;team)){
 		return;
 	}
 	if(lastAttacker &amp;&amp; lastAttacker!=userTarget)
@@ -1383,7 +1452,7 @@
 	//All units are set as ground-blocking.
 	blocking = true;
 
-	if(pos.y+model-&gt;height&lt;1)	//some torp launchers etc is exactly in the surface and should be considered uw anyway
+	if(pos.y+model-&gt;height&lt;1)	//some torp launchers etc are exactly in the surface and should be considered uw anyway
 		isUnderWater=true;
 
 	if(!unitDef-&gt;canKamikaze || unitDef-&gt;type==&quot;Building&quot; || unitDef-&gt;type==&quot;Factory&quot;)	//semi hack to make mines not block ground
@@ -1391,6 +1460,41 @@
 
 	UpdateTerrainType();
 
+	Command c;
+	if (unitDef-&gt;canmove || unitDef-&gt;builder) {
+		if (unitDef-&gt;moveState&lt;0) {
+			if (builder!=NULL) {
+				moveState = builder-&gt;moveState;
+			}else{
+				moveState = 1;
+			}
+		} else {
+			moveState = unitDef-&gt;moveState;
+		}
+
+		c.id = CMD_MOVE_STATE;
+		c.params.push_back(moveState);
+		commandAI-&gt;GiveCommand(c);
+		c.params.clear();
+	}
+
+	if (commandAI-&gt;CanChangeFireState()) {
+		if (unitDef-&gt;fireState&lt;0) {
+			if (builder!=NULL) {
+				fireState = builder-&gt;fireState;
+			}else{
+				fireState = 2;
+			}
+		} else {
+			fireState = unitDef-&gt;fireState;
+		}
+
+		c.id = CMD_FIRE_STATE;
+		c.params.push_back(fireState);
+		commandAI-&gt;GiveCommand(c);
+		c.params.clear();
+	}
+
 	luaCallIns.UnitCreated(this, builder);
 	globalAI-&gt;UnitCreated(this); // FIXME -- add builder?
 }
@@ -1593,7 +1697,7 @@
 		UnBlock();
 		CFeature* f =
 			featureHandler-&gt;CreateWreckage(pos, wreckName, heading, buildFacing,
-			                               0, team, allyteam, false, &quot;&quot;);
+										   0, team, allyteam, false, &quot;&quot;);
 		if (f) {
 			f-&gt;blockHeightChanges = true;
 		}
@@ -1601,10 +1705,12 @@
 	}
 }
 
+
+
 // Called when a unit's Killed script finishes executing
 static void CUnitKilledCB(int retCode, void* p1, void* p2)
 {
-	CUnit* self = (CUnit *)p1;
+	CUnit* self = (CUnit*) p1;
 	self-&gt;deathScriptFinished = true;
 	self-&gt;delayedWreckLevel = retCode;
 }
@@ -1615,15 +1721,16 @@
 		return;
 	}
 
-	if (dynamic_cast&lt;CAirMoveType*&gt;(moveType) &amp;&amp; !beingBuilt){
-		if (unitDef-&gt;canCrash &amp;&amp; !selfDestruct &amp;&amp; !reclaimed &amp;&amp; gs-&gt;randFloat()&gt;recentDamage*0.7f/maxHealth+0.2f) {
-			((CAirMoveType*)moveType)-&gt;SetState(AAirMoveType::AIRCRAFT_CRASHING);
+	if (dynamic_cast&lt;CAirMoveType*&gt;(moveType) &amp;&amp; !beingBuilt) {
+		if (unitDef-&gt;canCrash &amp;&amp; !selfDestruct &amp;&amp; !reclaimed &amp;&amp; gs-&gt;randFloat() &gt; recentDamage * 0.7f / maxHealth + 0.2f) {
+			((CAirMoveType*) moveType)-&gt;SetState(AAirMoveType::AIRCRAFT_CRASHING);
 			health = maxHealth * 0.5f;
 			return;
 		}
 	}
 
 	isDead = true;
+	deathSpeed = speed;
 
 	luaCallIns.UnitDestroyed(this, attacker);
 	globalAI-&gt;UnitDestroyed(this, attacker);
@@ -1668,21 +1775,22 @@
 		vector&lt;int&gt; args;
 		args.push_back((int) (recentDamage / maxHealth * 100));
 		args.push_back(0);
+		// start running the unit's kill-script
 		cob-&gt;Call(COBFN_Killed, args, &amp;CUnitKilledCB, this, NULL);
 
 		UnBlock();
 		delayedWreckLevel = args[1];
-//		featureHandler-&gt;CreateWreckage(pos,wreckName, heading, args[1],-1,true);
 	}
 	else {
-		deathScriptFinished=true;
+		deathScriptFinished = true;
 	}
 
 	if (beingBuilt || dynamic_cast&lt;CAirMoveType*&gt;(moveType) || reclaimed) {
 		uh-&gt;DeleteUnit(this);
-	}
-	else {
+	} else {
 		speed = ZeroVector;
+		// wait at least 5 more frames before
+		// permanently deleting this unit obj
 		deathCountdown = 5;
 		stunned = true;
 		paralyzeDamage = 1000000;
@@ -1692,22 +1800,24 @@
 	}
 }
 
+
+
 bool CUnit::UseMetal(float metal)
 {
-	if(metal&lt;0){
+	if (metal &lt; 0) {
 		AddMetal(-metal);
 		return true;
 	}
 	gs-&gt;Team(team)-&gt;metalPull += metal;
-	bool canUse=gs-&gt;Team(team)-&gt;UseMetal(metal);
-	if(canUse)
+	bool canUse = gs-&gt;Team(team)-&gt;UseMetal(metal);
+	if (canUse)
 		metalUseI += metal;
 	return canUse;
 }
 
 void CUnit::AddMetal(float metal)
 {
-	if(metal&lt;0){
+	if (metal &lt; 0) {
 		UseMetal(-metal);
 		return;
 	}
@@ -1717,20 +1827,20 @@
 
 bool CUnit::UseEnergy(float energy)
 {
-	if(energy&lt;0){
+	if (energy &lt; 0) {
 		AddEnergy(-energy);
 		return true;
 	}
 	gs-&gt;Team(team)-&gt;energyPull += energy;
-	bool canUse=gs-&gt;Team(team)-&gt;UseEnergy(energy);
-	if(canUse)
+	bool canUse = gs-&gt;Team(team)-&gt;UseEnergy(energy);
+	if (canUse)
 		energyUseI += energy;
 	return canUse;
 }
 
 void CUnit::AddEnergy(float energy)
 {
-	if(energy&lt;0){
+	if (energy &lt; 0) {
 		UseEnergy(-energy);
 		return;
 	}
@@ -1738,6 +1848,7 @@
 	gs-&gt;Team(team)-&gt;AddEnergy(energy);
 }
 
+
 void CUnit::Activate()
 {
 	//if(unitDef-&gt;tidalGenerator&gt;0)
@@ -1887,7 +1998,7 @@
 
 	const float3 diff = (pos - camera-&gt;pos);
 	const float dist = diff.dot(camera-&gt;forward);
-	const float lpp = max(0.0f, dist * lodFactor);
+	const float lpp = std::max(0.0f, dist * lodFactor);
 	for (/* no-op */; lastLOD != 0; lastLOD--) {
 		if (lpp &gt; lodLengths[lastLOD]) {
 			break;
@@ -1905,11 +2016,11 @@
 	if (lastLOD == 0) { return 0; }
 
 	// FIXME: fix it, cap it for shallow shadows?
-	const float3&amp; sun = gs-&gt;sunVector;
+	const float3&amp; sun = mapInfo-&gt;light.sunDir;
 	const float3 diff = (camera-&gt;pos - pos);
 	const float  dot  = diff.dot(sun);
 	const float3 gap  = diff - (sun * dot);
-	const float  lpp  = max(0.0f, gap.Length() * lodFactor);
+	const float  lpp  = std::max(0.0f, gap.Length() * lodFactor);
 
 	for (/* no-op */; lastLOD != 0; lastLOD--) {
 		if (lpp &gt; lodLengths[lastLOD]) {
@@ -1946,7 +2057,7 @@
 
 	// TA does some special handling depending on weapon count
 	if (weapons.size() &gt; 1)
-		relMax = max(relMax, 3000);
+		relMax = std::max(relMax, 3000);
 
 	// Call initializing script functions
 	cob-&gt;Call(COBFN_Create);
@@ -1971,6 +2082,15 @@
 	}
 }
 
+
+
+void CUnit::DrawS3O()
+{
+	unitDrawer-&gt;DrawUnitS3O(this);
+}
+
+
+
 // Member bindings
 CR_REG_METADATA(CUnit, (
 				//CR_MEMBER(unitDef),
@@ -2175,12 +2295,3 @@
 
 				CR_POSTLOAD(PostLoad)
 				));
-
-
-
-
-
-
-
-
-

Modified: branches/gml/rts/Sim/Units/Unit.h
===================================================================
--- branches/gml/rts/Sim/Units/Unit.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/Unit.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -27,13 +27,13 @@
 struct S3DOModel;
 struct UnitDef;
 struct UnitTrackStruct;
+struct CollisionVolume;
 
 #ifdef DIRECT_CONTROL_ALLOWED
 	struct DirectControlStruct;
 #endif
 
 class CTransportUnit;
-using namespace std;
 
 
 // LOS state bits
@@ -81,6 +81,9 @@
 
 	void ForcedMove(const float3&amp; newPos);
 	void ForcedSpin(const float3&amp; newDir);
+	void SetFront(const SyncedFloat3&amp; newDir);
+	void SetUp(const SyncedFloat3&amp; newDir);
+	void SetRight(const SyncedFloat3&amp; newDir);
 	void EnableScriptMoveType();
 	void DisableScriptMoveType();
 
@@ -92,7 +95,7 @@
 	void SetDirectionFromHeading();
 
 	void ApplyTransformMatrix() const;
-	void GetTransformMatrix(CMatrix44f&amp; matrix) const;
+	void GetTransformMatrix(CMatrix44f&amp; matrix, bool synced = false) const;
 
 	void SetLastAttacker(CUnit* attacker);
 	void DependentDied(CObject* o);
@@ -114,14 +117,24 @@
 
 	void CalculateTerrainType();
 	void UpdateTerrainType();
+	
+	void UpdateMidPos();
 
+	bool IsNeutral() const {
+		return ((gs-&gt;useLuaGaia &amp;&amp; team == gs-&gt;gaiaTeamID) || (team == MAX_TEAMS - 1) || neutral);
+	}
+
 	enum ChangeType{
 		ChangeGiven,
 		ChangeCaptured
 	};
 	virtual bool ChangeTeam(int team, ChangeType type);
 
-	const UnitDef *unitDef;
+	// should not be here
+	void DrawS3O();
+
+	const UnitDef* unitDef;
+	CollisionVolume* collisionVolume;
 	std::string unitDefName;
 
 	std::vector&lt;float&gt;         modParams;    // mod controlled parameters
@@ -135,17 +148,17 @@
 	//  it doesn't matter at all to which team the com/builder/factories were shared. Only capturing can break the chain.)
 	int aihint;							//tells the unit main function to the ai
 
-	SyncedFloat3 frontdir;				//the forward direction of the unit
+	SyncedFloat3 frontdir;				// the forward direction of the unit
 	SyncedFloat3 rightdir;
 	SyncedFloat3 updir;
-	bool upright;						//if the updir is straight up or align to the ground vector
-	SyncedFloat3 relMidPos;							//= (midPos - pos)
+	bool upright;						// if the updir is straight up or align to the ground vector
+	SyncedFloat3 relMidPos;				// = (midPos - pos)
 
+	float3 deathSpeed;
+
 	float travel; // total distance the unit has moved
 	float travelPeriod; // 0.0f disables travel accumulation
 
-//	float3 residualImpulse;	//impulse energy that havent been acted on
-
 	float power;						//indicate the relative power of the unit, used for experience calulations etc
 
 	float maxHealth;

Modified: branches/gml/rts/Sim/Units/UnitDef.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitDef.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitDef.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,6 +1,7 @@
 #ifndef UNITDEF_H
 #define UNITDEF_H
 
+#include &lt;cstdlib&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &lt;map&gt;
@@ -12,7 +13,7 @@
 struct WeaponDef;
 struct S3DOModel;
 struct UnitImage;
-class CCollisionVolume;
+struct CollisionVolume;
 class CExplosionGenerator;
 
 const int MAX_UNITS = 10000;
@@ -87,7 +88,6 @@
 
 struct UnitDef
 {
-	CR_DECLARE(UnitDef);
 	UnitDef() : valid(false) {}
 	~UnitDef();
 	S3DOModel* LoadModel(int team) const;
@@ -99,11 +99,11 @@
 	std::string filename;
 	int id;					// unique id for this type of unit
 
-	CCollisionVolume* collisionVolume;
+	CollisionVolume* collisionVolume;
 	const UnitDef* decoyDef;
 
 	int aihint;
-	int cobID;				// associated with the COB &lt;GET COB_ID unitID&gt; call 
+	int cobID;				// associated with the COB &lt;GET COB_ID unitID&gt; call
 
 	int techLevel;
 	std::string gaia;
@@ -199,20 +199,10 @@
 
 
 	struct UnitDefWeapon {
+		UnitDefWeapon();
 		UnitDefWeapon(std::string name, const WeaponDef* def, int slavedTo,
-		              float3 mainDir, float maxAngleDif,
-		              unsigned int badTargetCat, unsigned int onlyTargetCat,
-		              float fuelUse)
-		: name(name),
-		  def(def),
-		  slavedTo(slavedTo),
-		  mainDir(mainDir),
-		  maxAngleDif(maxAngleDif),
-		  badTargetCat(badTargetCat),
-		  onlyTargetCat(onlyTargetCat),
-		  fuelUsage(fuelUse)
-		{}
-
+		              float3 mainDir, float maxAngleDif, unsigned int badTargetCat,
+		              unsigned int onlyTargetCat, float fuelUse);
 		std::string name;
 		const WeaponDef* def;
 		int slavedTo;
@@ -271,8 +261,9 @@
 	bool canBeAssisted;
 	bool canRepeat;
 	bool canFireControl;
-	
+
 	int fireState;
+	int moveState;
 
 	//aircraft stuff
 	float wingDrag;
@@ -425,8 +416,8 @@
 	void FillCmd(Command&amp; c) const;
 
 	const UnitDef* def;
-	int buildFacing;
 	float3 pos;
+	int buildFacing;
 };
 
 

Modified: branches/gml/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitDefHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitDefHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -14,6 +14,7 @@
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
@@ -31,13 +32,39 @@
 #include &quot;System/TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 
-CR_BIND(UnitDef, );
-
 const char YARDMAP_CHAR = 'c';		//Need to be low case.
 
 
 CUnitDefHandler* unitDefHandler;
 
+
+UnitDef::UnitDefWeapon::UnitDefWeapon()
+: name(&quot;NOWEAPON&quot;)
+, def(NULL)
+, slavedTo(0)
+, mainDir(0, 0, 1)
+, maxAngleDif(-1)
+, fuelUsage(0)
+, badTargetCat(0)
+, onlyTargetCat(0)
+{
+}
+
+
+UnitDef::UnitDefWeapon::UnitDefWeapon(
+	std::string name, const WeaponDef* def, int slavedTo, float3 mainDir, float maxAngleDif,
+	unsigned int badTargetCat, unsigned int onlyTargetCat, float fuelUse)
+: name(name)
+, def(def)
+, slavedTo(slavedTo)
+, mainDir(mainDir)
+, maxAngleDif(maxAngleDif)
+, badTargetCat(badTargetCat)
+, onlyTargetCat(onlyTargetCat)
+, fuelUsage(fuelUse)
+{}
+
+
 CUnitDefHandler::CUnitDefHandler(void) : noCost(false)
 {
 	weaponDefHandler = SAFE_NEW CWeaponDefHandler();
@@ -132,6 +159,7 @@
 		}
 
 		delete unitDefs[i].collisionVolume;
+		unitDefs[i].collisionVolume = 0;
 	}
 	delete[] unitDefs;
 	delete weaponDefHandler;
@@ -313,9 +341,6 @@
 	ud.canPatrol   = udTable.GetBool(&quot;canPatrol&quot;,   true);
 	ud.canGuard    = udTable.GetBool(&quot;canGuard&quot;,    true);
 	ud.canRepeat   = udTable.GetBool(&quot;canRepeat&quot;,   true);
-	bool noAutoFire  = udTable.GetBool(&quot;noAutoFire&quot;,  false);
-	ud.canFireControl = udTable.GetBool(&quot;canFireControl&quot;, !noAutoFire);
-	ud.fireState = udTable.GetInt(&quot;fireState&quot;, ud.canFireControl ? -1 : 0);
 
 	ud.builder = udTable.GetBool(&quot;builder&quot;, true);
 
@@ -354,10 +379,17 @@
 	ud.selfDCountdown = udTable.GetInt(&quot;selfDestructCountdown&quot;, 5);
 
 	ud.speed    = udTable.GetFloat(&quot;maxVelocity&quot;,  0.0f) * 30.0f;
-	ud.maxAcc   = udTable.GetFloat(&quot;acceleration&quot;, 0.5f);
-	ud.maxDec   = udTable.GetFloat(&quot;brakeRate&quot;,    0.5f) * 0.1f;
+	ud.maxAcc   = fabs(udTable.GetFloat(&quot;acceleration&quot;, 0.5f)); // no negative values
+	ud.maxDec   = fabs(udTable.GetFloat(&quot;brakeRate&quot;,    3.0f*ud.maxAcc)) * (ud.canfly ? 0.1f : 1.f); // no negative values
 	ud.turnRate = udTable.GetFloat(&quot;turnRate&quot;,     0.0f);
 
+	bool noAutoFire  = udTable.GetBool(&quot;noAutoFire&quot;,  false);
+	ud.canFireControl = udTable.GetBool(&quot;canFireControl&quot;, !noAutoFire);
+	ud.fireState = udTable.GetInt(&quot;fireState&quot;, ud.canFireControl ? -1 : 2);
+	ud.fireState = std::min(ud.fireState,2);
+	ud.moveState = udTable.GetInt(&quot;moveState&quot;, (ud.canmove &amp;&amp; ud.speed&gt;0.0f)  ? -1 : 1);
+	ud.moveState = std::min(ud.moveState,2);
+
 	ud.buildRange3D = udTable.GetBool(&quot;buildRange3D&quot;, false);
 	ud.buildDistance = udTable.GetFloat(&quot;buildDistance&quot;, 128.0f);
 	ud.buildDistance = std::max(128.0f, ud.buildDistance);
@@ -476,7 +508,7 @@
 		string lname = StringToLower(ud.name);
 
 		if (gameSetup-&gt;restrictedUnits.find(lname) != gameSetup-&gt;restrictedUnits.end()) {
-			ud.maxThisUnit = min(ud.maxThisUnit, gameSetup-&gt;restrictedUnits.find(lname)-&gt;second);
+			ud.maxThisUnit = std::min(ud.maxThisUnit, gameSetup-&gt;restrictedUnits.find(lname)-&gt;second);
 		}
 	}
 
@@ -520,9 +552,8 @@
 				                &quot;to be present as a placeholder for missing weapons&quot;);
 				break;
 			} else {
-				ud.weapons.push_back(UnitDef::UnitDefWeapon(&quot;NOWEAPON&quot;, noWeaponDef,
-				                                            0, float3(0, 0, 1), -1,
-				                                            0, 0, 0));
+				ud.weapons.push_back(UnitDef::UnitDefWeapon());
+				ud.weapons.back().def = noWeaponDef;
 			}
 		}
 
@@ -575,7 +606,7 @@
 	ud.extractRange = 0;
 
 	if (ud.extractsMetal) {
-		ud.extractRange = readmap-&gt;extractorRadius;
+		ud.extractRange = mapInfo-&gt;map.extractorRadius;
 		ud.type = &quot;MetalExtractor&quot;;
 	}
 	else if (ud.transportCapacity) {
@@ -731,7 +762,8 @@
 	ud.collisionVolumeTest = udTable.GetInt(&quot;collisionVolumeTest&quot;, COLVOL_TEST_DISC);
 
 	// initialize the (per-unitdef) collision-volume
-	ud.collisionVolume = SAFE_NEW CCollisionVolume(ud.collisionVolumeType,
+	// all CUnit instances hold a copy of this object
+	ud.collisionVolume = SAFE_NEW CollisionVolume(ud.collisionVolumeType,
 		ud.collisionVolumeScales, ud.collisionVolumeOffsets, ud.collisionVolumeTest);
 
 
@@ -1028,7 +1060,7 @@
 	}
 
 	fprintf(f, &quot;\nTech Levels for \&quot;%s\&quot;\n&quot;, modname.c_str());
-	multimap&lt;int, string&gt; entries;
+	std::multimap&lt;int, std::string&gt; entries;
 	std::map&lt;std::string, int&gt;::const_iterator uit;
 	for (uit = unitID.begin(); uit != unitID.end(); uit++) {
 		const string&amp; unitName = uit-&gt;first;
@@ -1038,11 +1070,11 @@
 			SNPRINTF(buf, sizeof(buf), &quot; %3i:  %-15s  // %s :: %s\n&quot;,
 							 ud-&gt;techLevel, unitName.c_str(),
 							 ud-&gt;humanName.c_str(), ud-&gt;tooltip.c_str());
-			entries.insert(pair&lt;int, string&gt;(ud-&gt;techLevel, buf));
+			entries.insert(std::pair&lt;int, string&gt;(ud-&gt;techLevel, buf));
 		}
 	}
 	int prevLevel = -2;
-	multimap&lt;int, string&gt;::iterator eit;
+	std::multimap&lt;int, std::string&gt;::iterator eit;
 	for (eit = entries.begin(); eit != entries.end(); ++eit) {
 		if (eit-&gt;first != prevLevel) {
 			fprintf(f, &quot;\n&quot;);

Modified: branches/gml/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -10,6 +10,7 @@
 #include &quot;TimeProfiler.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Rendering/FartextureHandler.h&quot;
@@ -32,6 +33,7 @@
 #include &quot;creg/STL_List.h&quot;
 #include &quot;creg/STL_Deque.h&quot;
 #include &quot;creg/STL_Set.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;mmgr.h&quot;
 
 BuildInfo::BuildInfo(const std::string&amp; name, const float3&amp; p, int facing)
@@ -132,7 +134,7 @@
 
 	slowUpdateIterator = activeUnits.end();
 
-	waterDamage=atof(readmap-&gt;mapDefParser.SGetValueDef(&quot;0&quot;,&quot;MAP\\WATER\\WaterDamage&quot;).c_str())*(16.0f/30.0f);
+	waterDamage = mapInfo-&gt;water.damage;
 
 	if (gameSetup) {
 		maxUnits = gameSetup-&gt;maxUnits;
@@ -200,51 +202,54 @@
 	toBeRemoved.push_back(unit);
 }
 
+void CUnitHandler::DeleteUnitNow(CUnit* delUnit)
+{
+	int delTeam = 0;
+	int delType = 0;
+	std::list&lt;CUnit*&gt;::iterator usi;
+	for (usi = activeUnits.begin(); usi != activeUnits.end(); ++usi) {
+		if (*usi == delUnit) {
+			if (slowUpdateIterator != activeUnits.end() &amp;&amp; *usi == *slowUpdateIterator) {
+				slowUpdateIterator++;
+			}
+			delTeam = delUnit-&gt;team;
+			delType = delUnit-&gt;unitDef-&gt;id;
+
+			activeUnits.erase(usi);
+			units[delUnit-&gt;id] = 0;
+			freeIDs.push_back(delUnit-&gt;id);
+			gs-&gt;Team(delTeam)-&gt;RemoveUnit(delUnit, CTeam::RemoveDied);
+
+			unitsByDefs[delTeam][delType].erase(delUnit);
+
+			delete delUnit;
+			break;
+		}
+	}
+	//debug
+	for (usi = activeUnits.begin(); usi != activeUnits.end(); /* no post-op */) {
+		if (*usi == delUnit) {
+			logOutput.Print(&quot;Error: Duplicated unit found in active units on erase&quot;);
+			usi = activeUnits.erase(usi);
+		} else {
+			++usi;
+		}
+	}
+}
+
 void CUnitHandler::Update()
 {
 	ASSERT_SYNCED_MODE;
-
 	SCOPED_TIMER(&quot;Unit handler&quot;);
 
-	while(!toBeRemoved.empty()){
-		CUnit* delUnit=toBeRemoved.back();
+	while (!toBeRemoved.empty()) {
+		CUnit* delUnit = toBeRemoved.back();
 		toBeRemoved.pop_back();
 
-		int delTeam = 0;
-		int delType = 0;
-		list&lt;CUnit*&gt;::iterator usi;
-		for(usi=activeUnits.begin();usi!=activeUnits.end();++usi){
-			if(*usi==delUnit){
-				if (slowUpdateIterator!=activeUnits.end() &amp;&amp; *usi==*slowUpdateIterator) {
-					slowUpdateIterator++;
-				}
-				delTeam = delUnit-&gt;team;
-				delType = delUnit-&gt;unitDef-&gt;id;
-
-				activeUnits.erase(usi);
-				units[delUnit-&gt;id] = 0;
-				freeIDs.push_back(delUnit-&gt;id);
-				gs-&gt;Team(delTeam)-&gt;RemoveUnit(delUnit, CTeam::RemoveDied);
-
-				unitsByDefs[delTeam][delType].erase(delUnit);
-
-				delete delUnit;
-
-				break;
-			}
-		}
-		//debug
-		for (usi = activeUnits.begin(); usi != activeUnits.end(); /* no post-op */) {
-			if (*usi == delUnit){
-				logOutput.Print(&quot;Error: Duplicated unit found in active units on erase&quot;);
-				usi = activeUnits.erase(usi);
-			} else {
-				++usi;
-			}
-		}
+		DeleteUnitNow(delUnit);
 	}
 
-	list&lt;CUnit*&gt;::iterator usi;
+	std::list&lt;CUnit*&gt;::iterator usi;
 	for (usi = activeUnits.begin(); usi != activeUnits.end(); usi++) {
 		(*usi)-&gt;Update();
 	}
@@ -252,20 +257,20 @@
 	{
 		SCOPED_TIMER(&quot;Unit slow update&quot;);
 		if (!(gs-&gt;frameNum &amp; 15)) {
-			slowUpdateIterator=activeUnits.begin();
+			slowUpdateIterator = activeUnits.begin();
 		}
 
-		int numToUpdate=activeUnits.size()/16+1;
-		for(;slowUpdateIterator!=activeUnits.end() &amp;&amp; numToUpdate!=0;++slowUpdateIterator){
+		int numToUpdate = activeUnits.size() / 16 + 1;
+		for (; slowUpdateIterator != activeUnits.end() &amp;&amp; numToUpdate != 0; ++ slowUpdateIterator) {
 			(*slowUpdateIterator)-&gt;SlowUpdate();
 			numToUpdate--;
 		}
 	} // for timer destruction
 
-	if(!(gs-&gt;frameNum&amp;15)){
-		if(diminishingMetalMakers)
-			metalMakerEfficiency=8.0f/(8.0f+max(0.0f,sqrtf(metalMakerIncome/gs-&gt;activeTeams)-4));
-		metalMakerIncome=0;
+	if (!(gs-&gt;frameNum &amp; 15)) {
+		if (diminishingMetalMakers)
+			metalMakerEfficiency = 8.0f / (8.0f + max(0.0f, sqrtf(metalMakerIncome / gs-&gt;activeTeams) - 4));
+		metalMakerIncome = 0;
 	}
 }
 
@@ -363,7 +368,7 @@
 	int yardxpos=int(pos.x+4)/SQUARE_SIZE;
 	int yardypos=int(pos.z+4)/SQUARE_SIZE;
 	CSolidObject* s;
-	if ((s = readmap-&gt;GroundBlocked(yardypos*gs-&gt;mapx+yardxpos))) {
+	if ((s = groundBlockingObjectMap-&gt;GroundBlocked(yardypos*gs-&gt;mapx+yardxpos))) {
 		if (dynamic_cast&lt;CFeature*&gt;(s)) {
 			feature = (CFeature*)s;
 		}
@@ -586,17 +591,6 @@
 	overrideId=-1;*/
 }
 
-bool CUnitHandler::CanCloseYard(CUnit* unit)
-{
-	for(int z=unit-&gt;mapPos.y;z&lt;unit-&gt;mapPos.y+unit-&gt;ysize;++z){
-		for(int x=unit-&gt;mapPos.x;x&lt;unit-&gt;mapPos.x+unit-&gt;xsize;++x){
-			CSolidObject* c=readmap-&gt;groundBlockingObjectMap[z*gs-&gt;mapx+x];
-			if(c!=0 &amp;&amp; c!=unit)
-				return false;
-		}
-	}
-	return true;
-}
 
 /**
 * returns a build Command that intersects the ray described by pos and dir from the command queues of the

Modified: branches/gml/rts/Sim/Units/UnitHandler.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -26,6 +26,7 @@
 
 	void Update();
 	void DeleteUnit(CUnit* unit);
+	void DeleteUnitNow(CUnit* unit);
 	int AddUnit(CUnit* unit);
 	CUnitHandler(bool serializing=false);
 	void Serialize(creg::ISerializer&amp; s);
@@ -73,8 +74,6 @@
 	int lastDamageWarning;
 	int lastCmdDamageWarning;
 
-	bool CanCloseYard(CUnit* unit);
-
 	bool limitDgun;
 	float dgunRadius;
 


Property changes on: branches/gml/rts/Sim/Units/UnitImage.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitLoader.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitLoader.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -22,6 +22,8 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Misc/CollisionVolume.h&quot;
@@ -134,7 +136,7 @@
 	unit-&gt;buildTime = ud-&gt;buildTime;
 	unit-&gt;aihint = ud-&gt;aihint;
 	unit-&gt;tooltip = ud-&gt;humanName + &quot; - &quot; + ud-&gt;tooltip;
-	unit-&gt;armoredMultiple = max(0.0001f, ud-&gt;armoredMultiple);		//armored multiple of 0 will crash spring
+	unit-&gt;armoredMultiple = std::max(0.0001f, ud-&gt;armoredMultiple);		//armored multiple of 0 will crash spring
 	unit-&gt;wreckName = ud-&gt;wreckName;
 
 	unit-&gt;realLosRadius = (int) (ud-&gt;losRadius);
@@ -219,6 +221,7 @@
 			logOutput &lt;&lt; &quot;acceleration of &quot; &lt;&lt; ud-&gt;name.c_str() &lt;&lt; &quot; is zero!!\n&quot;;
 		mt-&gt;moveType=ud-&gt;moveType;
 		mt-&gt;accRate=ud-&gt;maxAcc;
+		mt-&gt;decRate=ud-&gt;maxDec;
 		mt-&gt;floatOnWater=ud-&gt;movedata-&gt;moveType==MoveData::Hover_Move || ud-&gt;movedata-&gt;moveType==MoveData::Ship_Move;
 		if(!unit-&gt;beingBuilt)
 			unit-&gt;mass=ud-&gt;mass;	//otherwise set this when finished building instead
@@ -298,27 +301,31 @@
 	unit-&gt;energyTickMake = ud-&gt;energyMake;
 
 	if (ud-&gt;tidalGenerator &gt; 0)
-		unit-&gt;energyTickMake += ud-&gt;tidalGenerator * readmap-&gt;tidalStrength;
+		unit-&gt;energyTickMake += ud-&gt;tidalGenerator * mapInfo-&gt;map.tidalStrength;
 
 
 	unit-&gt;model = ud-&gt;LoadModel(team);
 	unit-&gt;SetRadius(unit-&gt;model-&gt;radius);
 
-	// CUnitLoader left this volume's axis-scales uninitialized
-	if (ud-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_X) &lt; 0.01f &amp;&amp;
-		ud-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Y) &lt; 0.01f &amp;&amp;
-		ud-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Z) &lt; 0.01f) {
+	// copy the UnitDef volume archetype data
+	unit-&gt;collisionVolume = SAFE_NEW CollisionVolume(ud-&gt;collisionVolume);
+
+	// CUnitDefHandler left this volume's axis-scales uninitialized
+	// (ie. no &quot;collisionVolumeScales&quot; tag was defined in UnitDef)
+	if (unit-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_X) &lt;= 1.0f &amp;&amp;
+		unit-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Y) &lt;= 1.0f &amp;&amp;
+		unit-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Z) &lt;= 1.0f) {
 		// aircraft still get half-size spheres for coldet purposes
 		// if no custom volume is defined (unit-&gt;model-&gt;radius and
 		// unit-&gt;radius themselves are no longer altered)
 		const float scaleFactor = (ud-&gt;canfly)? 0.5f: 1.0f;
-		ud-&gt;collisionVolume-&gt;SetDefaultScale(unit-&gt;model-&gt;radius * scaleFactor);
+		unit-&gt;collisionVolume-&gt;SetDefaultScale(unit-&gt;model-&gt;radius * scaleFactor);
 	}
 
 
 
 	if (ud-&gt;floater)
-		unit-&gt;pos.y = max(-ud-&gt;waterline, ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z));
+		unit-&gt;pos.y = std::max(-ud-&gt;waterline, ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z));
 	else
 		unit-&gt;pos.y = ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z);
 
@@ -341,7 +348,7 @@
 
 	// TA does some special handling depending on weapon count
 	if (unit-&gt;weapons.size() &gt; 1)
-		relMax = max(relMax, 3000);
+		relMax = std::max(relMax, 3000);
 
 	// Call initializing script functions
 	unit-&gt;cob-&gt;Call(COBFN_Create);
@@ -495,10 +502,10 @@
 		BuildInfo bi(unitDef, unit-&gt;pos, unit-&gt;buildFacing);
 		bi.pos = helper-&gt;Pos2BuildPos(bi);
 		const float hss = 0.5f * SQUARE_SIZE;
-		const int tx1 = (int)max(0.0f ,(bi.pos.x - (bi.GetXSize() * hss)) / SQUARE_SIZE);
-		const int tz1 = (int)max(0.0f ,(bi.pos.z - (bi.GetYSize() * hss)) / SQUARE_SIZE);
-		const int tx2 = min(gs-&gt;mapx, tx1 + bi.GetXSize());
-		const int tz2 = min(gs-&gt;mapy, tz1 + bi.GetYSize());
+		const int tx1 = (int) std::max(0.0f ,(bi.pos.x - (bi.GetXSize() * hss)) / SQUARE_SIZE);
+		const int tz1 = (int) std::max(0.0f ,(bi.pos.z - (bi.GetYSize() * hss)) / SQUARE_SIZE);
+		const int tx2 = std::min(gs-&gt;mapx, tx1 + bi.GetXSize());
+		const int tz2 = std::min(gs-&gt;mapy, tz1 + bi.GetYSize());
 		float* heightmap = readmap-&gt;GetHeightmap();
 		for(int z = tz1; z &lt;= tz2; z++){
 			for(int x = tx1; x &lt;= tx2; x++){

Modified: branches/gml/rts/Sim/Units/UnitLoader.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitLoader.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitLoader.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -10,7 +10,6 @@
 
 #include &quot;UnitDef.h&quot;
 
-using namespace std;
 struct GuiSoundSet;
 
 class CUnitLoader
@@ -19,8 +18,8 @@
 	CUnitLoader();
 	virtual ~CUnitLoader();
 
-	CUnit* LoadUnit(const string&amp; name,float3 pos, int team,
-	                bool build, int facing, const CUnit* builder /* can be NULL */);
+	CUnit* LoadUnit(const std::string&amp; name, float3 pos, int team,
+		bool build, int facing, const CUnit* builder /* can be NULL */);
 	void FlattenGround(const CUnit* unit);
 
 	CWeapon* LoadWeapon(const WeaponDef* weapondef, CUnit* owner, const UnitDef::UnitDefWeapon* udw);

Modified: branches/gml/rts/Sim/Units/UnitTracker.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitTracker.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitTracker.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -128,14 +128,14 @@
 
 void CUnitTracker::CleanTrackGroup()
 {
-	set&lt;int&gt;::iterator it = trackGroup.begin();
+	std::set&lt;int&gt;::iterator it = trackGroup.begin();
 
 	while (it != trackGroup.end()) {
 		if (uh-&gt;units[*it] != NULL) {
 			it++;
 			continue;
 		}
-		set&lt;int&gt;::iterator it_next = it;
+		std::set&lt;int&gt;::iterator it_next = it;
 		it_next++;
 		if (trackUnit == *it) {
 			if (it_next == trackGroup.end()) {
@@ -163,7 +163,7 @@
 		return;
 	}
 
-	set&lt;int&gt;::iterator it = trackGroup.find(trackUnit);
+	std::set&lt;int&gt;::iterator it = trackGroup.find(trackUnit);
 	if (it == trackGroup.end()) {
 		trackUnit = *trackGroup.begin();
 	}
@@ -195,7 +195,7 @@
 float3 CUnitTracker::CalcAveragePos() const
 {
 	float3 p(0,0,0);
-	set&lt;int&gt;::const_iterator it;
+	std::set&lt;int&gt;::const_iterator it;
 	for (it = trackGroup.begin(); it != trackGroup.end(); ++it) {
 		p += uh-&gt;units[*it]-&gt;midPos;
 	}
@@ -208,7 +208,7 @@
 {
 	float3 minPos(+1e9f, +1e9f, +1e9f);
 	float3 maxPos(-1e9f, -1e9f, -1e9f);
-	set&lt;int&gt;::const_iterator it;
+	std::set&lt;int&gt;::const_iterator it;
 	for (it = trackGroup.begin(); it != trackGroup.end(); ++it) {
 		const float3&amp; p = uh-&gt;units[*it]-&gt;midPos;
 		if (p.x &lt; minPos.x) { minPos.x = p.x; }

Modified: branches/gml/rts/Sim/Units/UnitTracker.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitTracker.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitTracker.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,8 +4,6 @@
 #include &lt;set&gt;
 #include &quot;float.h&quot;
 
-using namespace std;
-
 class CUnit;
 
 class CUnitTracker
@@ -45,7 +43,7 @@
 
 		int trackMode;
 		int trackUnit;
-		set&lt;int&gt; trackGroup;
+		std::set&lt;int&gt; trackGroup;
 		
 		int timeOut;
 		int lastFollowUnit;

Modified: branches/gml/rts/Sim/Units/UnitTypes/Builder.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitTypes/Builder.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitTypes/Builder.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -14,6 +14,7 @@
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
@@ -326,7 +327,7 @@
 					curCapture-&gt;lineage = this-&gt;lineage;
 					gs-&gt;Team(oldLineage)-&gt;LeftLineage(curCapture);
 				}
-				curCapture-&gt;captureProgress=0.5f;	//make units somewhat easier to capture back after first capture
+				curCapture-&gt;captureProgress=0.0f;
 				StopBuild(true);
 			}
 		} else {

Modified: branches/gml/rts/Sim/Units/UnitTypes/Builder.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitTypes/Builder.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitTypes/Builder.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,7 +9,6 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 
-using namespace std;
 class CFeature;
 
 class CBuilder : public CUnit
@@ -81,7 +80,7 @@
 	float3 terraformCenter;
 	float terraformRadius;
 
-	string nextBuildType;
+	std::string nextBuildType;
 	float3 nextBuildPos;
 };
 

Modified: branches/gml/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -102,9 +102,9 @@
 
 	//Finding neighbours
 	std::vector&lt;CUnit*&gt; cu = qf-&gt;GetUnits(pos, extractionRange + maxExtractionRange);
-	maxExtractionRange = max(extractionRange, maxExtractionRange);
+	maxExtractionRange = std::max(extractionRange, maxExtractionRange);
 
-	for(std::vector&lt;CUnit*&gt;::iterator ui = cu.begin(); ui != cu.end(); ++ui) {
+	for (std::vector&lt;CUnit*&gt;::iterator ui = cu.begin(); ui != cu.end(); ++ui) {
 		if(typeid(**ui) == typeid(CExtractorBuilding) &amp;&amp; *ui != this) {
 			CExtractorBuilding *eb = (CExtractorBuilding*)*ui;
 			if(eb-&gt;pos.distance2D(this-&gt;pos) &lt; (eb-&gt;extractionRange + this-&gt;extractionRange)) {
@@ -119,12 +119,14 @@
 	//Calculating area of control and metalExtract.
 	//TODO: Improve this method.
 	metalExtract = 0;
-	int xBegin = max(0,           (int)((pos.x - extractionRange) / METAL_MAP_SQUARE_SIZE));
-	int xEnd   = min(gs-&gt;mapx/2-1,(int)((pos.x + extractionRange) / METAL_MAP_SQUARE_SIZE));
-	int zBegin = max(0,           (int)((pos.z - extractionRange) / METAL_MAP_SQUARE_SIZE));
-	int zEnd   = min(gs-&gt;mapy/2-1,(int)((pos.z + extractionRange) / METAL_MAP_SQUARE_SIZE));
-	for(int x = xBegin; x &lt;= xEnd; x++) {
-		for(int z = zBegin; z &lt;= zEnd; z++) {	//Going thru the whole (x,z)-square...
+	int xBegin = std::max(0,           (int)((pos.x - extractionRange) / METAL_MAP_SQUARE_SIZE));
+	int xEnd   = std::min(gs-&gt;mapx/2-1,(int)((pos.x + extractionRange) / METAL_MAP_SQUARE_SIZE));
+	int zBegin = std::max(0,           (int)((pos.z - extractionRange) / METAL_MAP_SQUARE_SIZE));
+	int zEnd   = std::min(gs-&gt;mapy/2-1,(int)((pos.z + extractionRange) / METAL_MAP_SQUARE_SIZE));
+
+	for (int x = xBegin; x &lt;= xEnd; x++) {
+		for (int z = zBegin; z &lt;= zEnd; z++) {
+			// go through the whole (x, z)-square
 			const float3 msqrPos((x + 0.5f) * METAL_MAP_SQUARE_SIZE, pos.y,
 			                     (z + 0.5f) * METAL_MAP_SQUARE_SIZE);	//Center of metalsquare.
 			const float sqrCenterDistance = msqrPos.distance2D(this-&gt;pos);

Modified: branches/gml/rts/Sim/Units/UnitTypes/Factory.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitTypes/Factory.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitTypes/Factory.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -14,6 +14,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Projectiles/Unsynced/GfxProjectile.h&quot;
@@ -108,7 +109,7 @@
 
 	if (quedBuild &amp;&amp; !opening &amp;&amp; !stunned) {
 		cob-&gt;Call(COBFN_Activate);
-		readmap-&gt;OpenBlockingYard(this, yardMap);
+		groundBlockingObjectMap-&gt;OpenBlockingYard(this, yardMap);
 		opening = true;
 	}
 
@@ -192,20 +193,6 @@
 				curBuild-&gt;SetGroup(group);
 			}
 
-			Command c;
-			c.options = 0;
-
-			c.id = CMD_MOVE_STATE;
-			c.params.push_back(moveState);
-			curBuild-&gt;commandAI-&gt;GiveCommand(c);
-			c.params.clear();
-
-			if(curBuild-&gt;unitDef-&gt;fireState &lt; 0) {
-				c.id = CMD_FIRE_STATE;
-				c.params.push_back(fireState);
-				curBuild-&gt;commandAI-&gt;GiveCommand(c);
-			}
-
 			bool userOrders = true;
 			if (curBuild-&gt;commandAI-&gt;commandQue.empty() ||
 					(dynamic_cast&lt;CMobileCAI*&gt;(curBuild-&gt;commandAI) &amp;&amp;
@@ -242,9 +229,9 @@
 	}
 
 	if (((lastBuild + 200) &lt; gs-&gt;frameNum) &amp;&amp; !stunned &amp;&amp;
-	    !quedBuild &amp;&amp; opening &amp;&amp; uh-&gt;CanCloseYard(this)) {
+	    !quedBuild &amp;&amp; opening &amp;&amp; groundBlockingObjectMap-&gt;CanCloseYard(this)) {
 		// close the factory after inactivity
-		readmap-&gt;CloseBlockingYard(this, yardMap);
+		groundBlockingObjectMap-&gt;CloseBlockingYard(this, yardMap);
 		opening = false;
 		cob-&gt;Call(COBFN_Deactivate);
 	}
@@ -271,7 +258,7 @@
 
 	if (!opening &amp;&amp; !stunned) {
 		cob-&gt;Call(COBFN_Activate);
-		readmap-&gt;OpenBlockingYard(this, yardMap);
+		groundBlockingObjectMap-&gt;OpenBlockingYard(this, yardMap);
 		opening = true;
 	}
 }

Modified: branches/gml/rts/Sim/Units/UnitTypes/Factory.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitTypes/Factory.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitTypes/Factory.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -8,8 +8,6 @@
 #include &quot;Building.h&quot;
 #include &lt;string&gt;
 
-using namespace std;
-
 class CFactory : public CBuilding
 {
 public:
@@ -19,7 +17,7 @@
 	virtual ~CFactory();
 	void PostLoad();
 	void StopBuild();
-	void StartBuild(string type);
+	void StartBuild(std::string type);
 	void Update();
 	void DependentDied(CObject* o);
 	void FinishedBuilding(void);
@@ -33,7 +31,7 @@
 	float buildSpeed;
 
 	bool quedBuild;						//if we have a unit that we want to start to nanolath when script is ready
-	string nextBuild;
+	std::string nextBuild;
 	CUnit* curBuild;					//unit that we are nanolathing
 	bool opening;
 

Modified: branches/gml/rts/Sim/Units/UnitTypes/TransportUnit.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitTypes/TransportUnit.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Units/UnitTypes/TransportUnit.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -52,11 +52,11 @@
 void CTransportUnit::Update()
 {
 	CUnit::Update();
-	list&lt;TransportedUnit&gt;::iterator ti;
+	std::list&lt;TransportedUnit&gt;::iterator ti;
 	for (ti = transported.begin(); ti != transported.end(); ++ti) {
 		float3 relPos;
 		if (ti-&gt;piece &gt;= 0) {
-			relPos = localmodel-&gt;GetPiecePos(max(0, ti-&gt;piece));
+			relPos = localmodel-&gt;GetPiecePos(std::max(0, ti-&gt;piece));
 		} else {
 			relPos = float3(0.0f, -1000.0f, 0.0f);
 		}
@@ -65,9 +65,7 @@
 		                         (rightdir * relPos.x);
 //		pos.y-=ti-&gt;unit-&gt;radius;
 		ti-&gt;unit-&gt;pos = pos;
-		ti-&gt;unit-&gt;midPos = ti-&gt;unit-&gt;pos + (ti-&gt;unit-&gt;frontdir * ti-&gt;unit-&gt;relMidPos.z) +
-		                                   (ti-&gt;unit-&gt;updir    * ti-&gt;unit-&gt;relMidPos.y) +
-		                                   (ti-&gt;unit-&gt;rightdir * ti-&gt;unit-&gt;relMidPos.x);
+		ti-&gt;unit-&gt;UpdateMidPos();
 		if (unitDef-&gt;holdSteady) {
 			ti-&gt;unit-&gt;heading  = heading;
 			ti-&gt;unit-&gt;updir    = updir;
@@ -80,8 +78,8 @@
 
 void CTransportUnit::DependentDied(CObject* o)
 {
-	for(list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
-		if(ti-&gt;unit==o){
+	for (std::list&lt;TransportedUnit&gt;::iterator ti = transported.begin(); ti != transported.end(); ++ti) {
+		if (ti-&gt;unit == o) {
 			transportCapacityUsed-=ti-&gt;size;
 			transportMassUsed-=ti-&gt;mass;
 			transported.erase(ti);
@@ -95,7 +93,7 @@
 
 void CTransportUnit::KillUnit(bool selfDestruct,bool reclaimed, CUnit *attacker)
 {
-	list&lt;TransportedUnit&gt;::iterator ti;
+	std::list&lt;TransportedUnit&gt;::iterator ti;
 	for (ti = transported.begin(); ti != transported.end(); ++ti) {
 		ti-&gt;unit-&gt;transporter = 0;
 		ti-&gt;unit-&gt;DeleteDeathDependence(this);
@@ -184,7 +182,7 @@
 		return;
 	}
 
-	list&lt;TransportedUnit&gt;::iterator ti;
+	std::list&lt;TransportedUnit&gt;::iterator ti;
 	for (ti = transported.begin(); ti != transported.end(); ++ti) {
 		if (ti-&gt;unit == unit) {
 			this-&gt;DeleteDeathDependence(unit);
@@ -219,10 +217,10 @@
 
 void CTransportUnit::DetachUnitFromAir(CUnit* unit, float3 pos) {
 
-	if(unit-&gt;transporter != this)
+	if (unit-&gt;transporter != this)
 		return;
 
-	for (list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
+	for (std::list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
 		if (ti-&gt;unit==unit) {
 			this-&gt;DeleteDeathDependence(unit);
 			unit-&gt;DeleteDeathDependence(this);
@@ -259,11 +257,11 @@
 
 void CTransportUnit::DetachUnitFromAir(CUnit* unit)
 {
-	if(unit-&gt;transporter != this)
+	if (unit-&gt;transporter != this)
 		return;
 
-	for(list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
-		if(ti-&gt;unit==unit){
+	for (std::list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
+		if (ti-&gt;unit == unit) {
 			this-&gt;DeleteDeathDependence(unit);
 			unit-&gt;DeleteDeathDependence(this);
 			unit-&gt;transporter=0;

Modified: branches/gml/rts/Sim/Weapons/BeamLaser.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/BeamLaser.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Weapons/BeamLaser.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -256,7 +256,7 @@
 		actualRange += hit-&gt;radius*targetBorder;
 	}
 	// make it possible to always hit with some minimal intensity (melee weapons have use for that)
-	float intensity=max(minIntensity, 1-(curLength)/(actualRange*2));
+	float intensity = std::max(minIntensity, 1-(curLength)/(actualRange*2));
 
 	if(curLength&lt;maxLength) {
 		// Dynamic Damage

Modified: branches/gml/rts/Sim/Weapons/Cannon.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/Cannon.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Weapons/Cannon.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,6 +7,7 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Rendering/Env/BaseWater.h&quot;
 #include &quot;Sim/Projectiles/Unsynced/HeatCloudProjectile.h&quot;
@@ -47,7 +48,7 @@
 
 void CCannon::Init(void)
 {
-	gravity = weaponDef-&gt;myGravity==0 ? gs-&gt;gravity : -(weaponDef-&gt;myGravity);
+	gravity = weaponDef-&gt;myGravity==0 ? mapInfo-&gt;map.gravity : -(weaponDef-&gt;myGravity);
 	highTrajectory = weaponDef-&gt;highTrajectory == 1;
 	if(highTrajectory){
 		maxPredict=projectileSpeed*2/-gravity;

Modified: branches/gml/rts/Sim/Weapons/LightingCannon.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/LightingCannon.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Weapons/LightingCannon.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -90,7 +90,7 @@
 	dir+=(gs-&gt;randVector()*sprayangle+salvoError)*(1-owner-&gt;limExperience*0.5f);
 	dir.Normalize();
 	CUnit* u=0;
-	float r=helper-&gt;TraceRay(weaponMuzzlePos,dir,range,0,owner,u);
+	float r=helper-&gt;TraceRay(weaponMuzzlePos,dir,range,0,owner,u,collisionFlags);
 
 	float3 newDir;
 	CPlasmaRepulser* shieldHit;

Modified: branches/gml/rts/Sim/Weapons/PlasmaRepulser.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -125,11 +125,11 @@
 		if (weaponDef-&gt;visibleShield) {
 			drawAlpha += 1.0f;
 		}
-		drawAlpha = min(1.0f, drawAlpha * weaponDef-&gt;shieldAlpha);
+		drawAlpha = std::min(1.0f, drawAlpha * weaponDef-&gt;shieldAlpha);
 		const bool drawMe = (drawAlpha &gt; 0.0f);
 
 		if (drawMe || wasDrawn) {
-			const float colorMix = min(1.0f, curPower / max(1.0f, weaponDef-&gt;shieldPower));
+			const float colorMix = std::min(1.0f, curPower / std::max(1.0f, weaponDef-&gt;shieldPower));
 			const float3 color = (weaponDef-&gt;shieldGoodColor * colorMix) +
 													 (weaponDef-&gt;shieldBadColor * (1.0f - colorMix));
 			std::list&lt;CShieldPartProjectile*&gt;::iterator si;
@@ -182,7 +182,7 @@
 								}
 							if (i == hasGfx.end()) {
 								hasGfx.insert(hasGfx.end(),*pi);
-								const float colorMix = min(1.0f, curPower / max(1.0f, weaponDef-&gt;shieldPower));
+								const float colorMix = std::min(1.0f, curPower / std::max(1.0f, weaponDef-&gt;shieldPower));
 								const float3 color = (weaponDef-&gt;shieldGoodColor * colorMix) +
 								                     (weaponDef-&gt;shieldBadColor * (1.0f - colorMix));
 								SAFE_NEW CRepulseGfx(owner, *pi, radius, color);

Modified: branches/gml/rts/Sim/Weapons/Weapon.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/Weapon.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Weapons/Weapon.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -358,7 +358,7 @@
 				} else {
 					owner-&gt;UseEnergy(energyFireCost);
 					owner-&gt;UseMetal(metalFireCost);
-					owner-&gt;currentFuel = max(0.0f, owner-&gt;currentFuel - fuelUsage);
+					owner-&gt;currentFuel = std::max(0.0f, owner-&gt;currentFuel - fuelUsage);
 				}
 				if(weaponDef-&gt;stockpile)
 					reloadStatus=gs-&gt;frameNum+60;
@@ -379,7 +379,7 @@
 			// FIXME  -- never reached?
 			if (TryTarget(targetPos,haveUserTarget,targetUnit) &amp;&amp; !weaponDef-&gt;stockpile) {
 				// update the energy and metal required counts
-				const int minPeriod = max(1, (int)(reloadTime / owner-&gt;reloadSpeed));
+				const int minPeriod = std::max(1, (int)(reloadTime / owner-&gt;reloadSpeed));
 				const float averageFactor = 1.0f / (float)minPeriod;
 				gs-&gt;Team(owner-&gt;team)-&gt;energyPull += averageFactor * energyFireCost;
 				gs-&gt;Team(owner-&gt;team)-&gt;metalPull += averageFactor * metalFireCost;
@@ -846,7 +846,7 @@
 		owner-&gt;maxRange = range;
 	}
 
-	muzzleFlareSize = min(areaOfEffect*0.2f,min(1500.f,weaponDef-&gt;damages[0])*0.003f);
+	muzzleFlareSize = std::min(areaOfEffect * 0.2f, std::min(1500.f, weaponDef-&gt;damages[0]) * 0.003f);
 
 	if (weaponDef-&gt;interceptor)
 		interceptHandler.AddInterceptorWeapon(this);

Modified: branches/gml/rts/Sim/Weapons/WeaponDefHandler.h
===================================================================
--- branches/gml/rts/Sim/Weapons/WeaponDefHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Weapons/WeaponDefHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -31,7 +31,7 @@
 
 struct WeaponDef
 {
-	CR_DECLARE(WeaponDef);
+	CR_DECLARE_STRUCT(WeaponDef);
 
 	~WeaponDef();
 

Modified: branches/gml/rts/Sim/Weapons/bombdropper.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/bombdropper.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/Sim/Weapons/bombdropper.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,6 +7,7 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Sim/MoveTypes/TAAirMoveType.h&quot;
 #include &quot;Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.h&quot;
 #include &quot;Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.h&quot;
@@ -56,14 +57,14 @@
 		if(weaponPos.y&gt;targetPos.y){
 			float d=targetPos.y-weaponPos.y;
 			float s=-owner-&gt;speed.y;
-			float sq=(s-2*d)/-(weaponDef-&gt;myGravity==0 ? gs-&gt;gravity : -(weaponDef-&gt;myGravity));
+			float sq=(s-2*d)/-(weaponDef-&gt;myGravity==0 ? mapInfo-&gt;map.gravity : -(weaponDef-&gt;myGravity));
 			if(sq&gt;0)
-				predict=s/(weaponDef-&gt;myGravity==0 ? gs-&gt;gravity : -(weaponDef-&gt;myGravity))+sqrt(sq);
+				predict=s/(weaponDef-&gt;myGravity==0 ? mapInfo-&gt;map.gravity : -(weaponDef-&gt;myGravity))+sqrt(sq);
 			else
 				predict=0;
 			float3 hitpos=owner-&gt;pos+owner-&gt;speed*predict;
 			float speedf=owner-&gt;speed.Length();
-			if(hitpos.distance2D(targetPos)&lt;max(1,(salvoSize-1))*speedf*salvoDelay*0.5f+bombMoveRange){
+			if(hitpos.distance2D(targetPos)&lt;std::max(1,(salvoSize-1))*speedf*salvoDelay*0.5f+bombMoveRange){
 				subClassReady=true;
 			}
 		}
@@ -110,10 +111,10 @@
 		float3 dir=owner-&gt;speed;
 		dir.Normalize();
 		dir+=(gs-&gt;randVector()*sprayangle+salvoError)*(1-owner-&gt;limExperience*0.9f); //add a random spray
-		dir.y=min(0.0f,dir.y);
+		dir.y=std::min(0.0f,dir.y);
 		dir.Normalize();
 		dif-=dir*dif.dot(dir);
-		dif/=max(0.01f,predict);
+		dif/=std::max(0.01f,predict);
 		float size=dif.Length();
 		if(size&gt;1.0f)
 			dif/=size*1.0f;
@@ -125,7 +126,7 @@
 		}
 		SAFE_NEW CExplosiveProjectile(weaponPos, owner-&gt;speed + dif, owner,
 				weaponDef, 1000, areaOfEffect,
-				weaponDef-&gt;myGravity==0 ? gs-&gt;gravity : -(weaponDef-&gt;myGravity));
+				weaponDef-&gt;myGravity==0 ? mapInfo-&gt;map.gravity : -(weaponDef-&gt;myGravity));
 	}
 	//CWeaponProjectile::CreateWeaponProjectile(owner-&gt;pos,owner-&gt;speed,owner, NULL, float3(0,0,0), damages, weaponDef);
 	if(fireSoundId &amp;&amp; (!weaponDef-&gt;soundTrigger || salvoLeft==salvoSize-1))

Modified: branches/gml/rts/System/AutohostInterface.h
===================================================================
--- branches/gml/rts/System/AutohostInterface.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/AutohostInterface.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,8 +3,6 @@
 
 #include &lt;string&gt;
 
-#include &quot;Game/Server/ServerLog.h&quot;
-
 namespace netcode {
 	class UDPConnectedSocket;
 }
@@ -13,7 +11,7 @@
 @brief Class to communicate with an autohost (or similar) using UDP over loopback
 @author Karl-Robert Ernst
 */
-class AutohostInterface : public ServerLog
+class AutohostInterface
 {
 public:
 	typedef unsigned char uchar;
@@ -37,8 +35,8 @@
 	void SendPlayerChat(uchar playerNum, const std::string&amp; msg) const;
 	void SendPlayerDefeated(uchar playerNum) const;
 	
-	virtual void Message(const std::string&amp; message);
-	virtual void Warning(const std::string&amp; message);
+	void Message(const std::string&amp; message);
+	void Warning(const std::string&amp; message);
 	
 	/**
 	@brief Recieve a chat message from the autohost

Modified: branches/gml/rts/System/BaseNetProtocol.cpp
===================================================================
--- branches/gml/rts/System/BaseNetProtocol.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/BaseNetProtocol.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -24,8 +24,11 @@
 	RegisterMessage(NETMSG_COMMAND, -2);
 	RegisterMessage(NETMSG_SELECT, -2);
 	RegisterMessage(NETMSG_PAUSE, 3);
+
 	RegisterMessage(NETMSG_AICOMMAND, -2);
 	RegisterMessage(NETMSG_AICOMMANDS, -2);
+	RegisterMessage(NETMSG_AISHARE, -2);
+
 	RegisterMessage(NETMSG_USER_SPEED, 6);
 	RegisterMessage(NETMSG_INTERNAL_SPEED, 5);
 	RegisterMessage(NETMSG_CPU_USAGE, 5);
@@ -56,20 +59,16 @@
 	SendQuit();
 }
 
-void CBaseNetProtocol::RawSend(const uchar* data,const unsigned length)
+void CBaseNetProtocol::RawSend(const uchar* data, const unsigned length)
 {
 	SendData(data, length);
 }
 
-//  NETMSG_KEYFRAME         = 1,  // int frameNum;
-
 void CBaseNetProtocol::SendKeyFrame(int frameNum)
 {
 	SendData&lt;int&gt;(NETMSG_KEYFRAME, frameNum);
 }
 
-//  NETMSG_NEWFRAME         = 2,  //
-
 void CBaseNetProtocol::SendNewFrame()
 {
 	unsigned char msg = NETMSG_NEWFRAME;
@@ -77,8 +76,6 @@
 }
 
 
-//  NETMSG_QUIT             = 3,  //
-
 void CBaseNetProtocol::SendQuit()
 {
 	SendData(NETMSG_QUIT);
@@ -90,33 +87,25 @@
 	SendData(&amp;a, 1, playerNum);
 }
 
-//  NETMSG_STARTPLAYING     = 4,  //
-
 void CBaseNetProtocol::SendStartPlaying(unsigned countdown)
 {
 	SendData&lt;unsigned&gt;(NETMSG_STARTPLAYING, countdown);
 }
 
-//  NETMSG_SETPLAYERNUM     = 5,  // uchar myPlayerNum;
-
 void CBaseNetProtocol::SendSetPlayerNum(uchar myPlayerNum, uchar connNumber)
 {
 	uchar msg[2] = {NETMSG_SETPLAYERNUM, myPlayerNum};
 	SendData(msg, 2, connNumber);
 }
 
-//  NETMSG_PLAYERNAME       = 6,  // uchar myPlayerNum; std::string playerName;
-
 void CBaseNetProtocol::SendPlayerName(uchar myPlayerNum, const std::string&amp; playerName)
 {
-	unsigned size = 3 + playerName.size() +1;
+	unsigned size = 3 + playerName.size() + 1;
 	PackPacket* packet = new PackPacket(size);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_PLAYERNAME) &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; playerName;
 	SendData(packet);
 }
 
-//  NETMSG_RANDSEED         = 8,  // uint randSeed;
-
 void CBaseNetProtocol::SendRandSeed(uint randSeed)
 {
 	SendData&lt;uint&gt;(NETMSG_RANDSEED, randSeed);
@@ -125,12 +114,11 @@
 void CBaseNetProtocol::SendRandSeed(uint randSeed, int toPlayer)
 {
 	uchar data[5] = {NETMSG_RANDSEED};
-	*(int*)(data+1) = randSeed;
+	*(int*)(data + 1) = randSeed;
 	SendData(data, 5, toPlayer);
 }
 
-//  NETMSG_GAMEID           = 9,  // char gameID[16];
-
+// NETMSG_GAMEID = 9, char gameID[16];
 void CBaseNetProtocol::SendGameID(const uchar* buf)
 {
 	uchar data[17];
@@ -139,211 +127,189 @@
 	SendData(data, 17);
 }
 
-//  NETMSG_COMMAND          = 11, // uchar myPlayerNum; int id; uchar options; std::vector&lt;float&gt; params;
 
 void CBaseNetProtocol::SendCommand(uchar myPlayerNum, int id, uchar options, const std::vector&lt;float&gt;&amp; params)
 {
-	unsigned size = 9 + params.size()*sizeof(float);
+	unsigned size = 9 + params.size() * sizeof(float);
 	PackPacket* packet = new PackPacket(size);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_COMMAND) &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; id &lt;&lt; options &lt;&lt; params;
 	SendData(packet);
 }
 
-//  NETMSG_SELECT           = 12, // uchar myPlayerNum; std::vector&lt;short&gt; selectedUnitIDs;
-
 void CBaseNetProtocol::SendSelect(uchar myPlayerNum, const std::vector&lt;short&gt;&amp; selectedUnitIDs)
 {
-	unsigned size = 4 + selectedUnitIDs.size()*sizeof(short);
+	unsigned size = 4 + selectedUnitIDs.size() * sizeof(short);
 	PackPacket* packet = new PackPacket(size);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_SELECT) &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; selectedUnitIDs;
 	SendData(packet);
 }
 
-//  NETMSG_PAUSE            = 13, // uchar playerNum, bPaused;
 
 void CBaseNetProtocol::SendPause(uchar myPlayerNum, uchar bPaused)
 {
 	SendData&lt;uchar, uchar&gt;(NETMSG_PAUSE, myPlayerNum, bPaused);
 }
 
-//  NETMSG_AICOMMAND        = 14, // uchar myPlayerNum; short unitID; int id; uchar options; std::vector&lt;float&gt; params;
 
+
 void CBaseNetProtocol::SendAICommand(uchar myPlayerNum, short unitID, int id, uchar options, const std::vector&lt;float&gt;&amp; params)
 {
-	unsigned size = 11 + params.size()*sizeof(float);
+	unsigned size = 11 + params.size() * sizeof(float);
 	PackPacket* packet = new PackPacket(size);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_AICOMMAND) &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; unitID &lt;&lt; id &lt;&lt; options &lt;&lt; params;
 	SendData(packet);
 }
 
-//  NETMSG_AICOMMANDS       = 15, // uchar myPlayerNum;
-	                              // short unitIDCount;  unitIDCount X short(unitID)
-	                              // short commandCount; commandCount X { int id; uchar options; std::vector&lt;float&gt; params }
-
 void CBaseNetProtocol::SendAICommands(uchar myPlayerNum, short unitIDCount, ...)
 {
-	//FIXME: needs special care; sits in CSelectedUnits::SendCommandsToUnits().
+	// FIXME: needs special care; sits in CSelectedUnits::SendCommandsToUnits().
 }
 
-//  NETMSG_USER_SPEED       = 19, // uchar myPlayerNum, float userSpeed;
+void CBaseNetProtocol::SendAIShare(uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, const std::vector&lt;short&gt;&amp; unitIDs)
+{
+	short totalNumBytes = (1 + sizeof(short)) + (3 + (2 * sizeof(float)) + (unitIDs.size() * sizeof(short)));
+
+	PackPacket* packet = new PackPacket(totalNumBytes);
+	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_AISHARE) &lt;&lt; totalNumBytes &lt;&lt; myPlayerNum &lt;&lt; sourceTeam &lt;&lt; destTeam &lt;&lt; metal &lt;&lt; energy &lt;&lt; unitIDs;
+	SendData(packet);
+}
+
+
+
 void CBaseNetProtocol::SendUserSpeed(uchar myPlayerNum, float userSpeed)
 {
 	SendData&lt;uchar, float&gt; (NETMSG_USER_SPEED, myPlayerNum, userSpeed);
 }
 
-//  NETMSG_INTERNAL_SPEED   = 20, // float internalSpeed;
-
 void CBaseNetProtocol::SendInternalSpeed(float internalSpeed)
 {
 	SendData&lt;float&gt; (NETMSG_INTERNAL_SPEED, internalSpeed);
 }
 
-//  NETMSG_CPU_USAGE        = 21, // float cpuUsage;
-
 void CBaseNetProtocol::SendCPUUsage(float cpuUsage)
 {
 	SendData&lt;float&gt; (NETMSG_CPU_USAGE, cpuUsage);
 }
 
-//  NETMSG_DIRECT_CONTROL   = 22, // uchar myPlayerNum;
 
 void CBaseNetProtocol::SendDirectControl(uchar myPlayerNum)
 {
 	SendData&lt;uchar&gt; (NETMSG_DIRECT_CONTROL, myPlayerNum);
 }
 
-//  NETMSG_DC_UPDATE        = 23, // uchar myPlayerNum, status; short heading, pitch;
-
 void CBaseNetProtocol::SendDirectControlUpdate(uchar myPlayerNum, uchar status, short heading, short pitch)
 {
 	SendData&lt;uchar, uchar, short, short&gt; (NETMSG_DC_UPDATE, myPlayerNum, status, heading, pitch);
 }
 
-//  NETMSG_ATTEMPTCONNECT   = 25, // uchar myPlayerNum, networkVersion;
 
 void CBaseNetProtocol::SendAttemptConnect(uchar myPlayerNum, uchar networkVersion)
 {
 	SendData&lt;uchar, uchar&gt; (NETMSG_ATTEMPTCONNECT, myPlayerNum, networkVersion);
 }
 
-//  NETMSG_SHARE            = 26, // uchar myPlayerNum, shareTeam, bShareUnits; float shareMetal, shareEnergy;
 
 void CBaseNetProtocol::SendShare(uchar myPlayerNum, uchar shareTeam, uchar bShareUnits, float shareMetal, float shareEnergy)
 {
 	SendData&lt;uchar, uchar, uchar, float, float&gt; (NETMSG_SHARE, myPlayerNum, shareTeam, bShareUnits, shareMetal, shareEnergy);
 }
 
-//  NETMSG_SETSHARE         = 27, // uchar myPlayerNum, uchar myTeam; float metalShareFraction, energyShareFraction;
-
 void CBaseNetProtocol::SendSetShare(uchar myPlayerNum, uchar myTeam, float metalShareFraction, float energyShareFraction)
 {
 	SendData&lt;uchar, uchar, float, float&gt;(NETMSG_SETSHARE, myPlayerNum, myTeam, metalShareFraction, energyShareFraction);
 }
 
-//  NETMSG_SENDPLAYERSTAT   = 28, //
 
 void CBaseNetProtocol::SendSendPlayerStat()
 {
 	SendData(NETMSG_SENDPLAYERSTAT);
 }
 
-//  NETMSG_PLAYERSTAT       = 29, // uchar myPlayerNum; CPlayer::Statistics currentStats;
-
 void CBaseNetProtocol::SendPlayerStat(uchar myPlayerNum, const CPlayer::Statistics&amp; currentStats)
 {
 	SendData&lt;uchar, CPlayer::Statistics&gt;(NETMSG_PLAYERSTAT, myPlayerNum, currentStats);
 }
 
-//  NETMSG_GAMEOVER         = 30, //
 
 void CBaseNetProtocol::SendGameOver()
 {
 	SendData(NETMSG_GAMEOVER);
 }
 
-//  NETMSG_MAPDRAW          = 31, // uchar messageSize =  8, myPlayerNum, command = CInMapDraw::NET_ERASE; short x, z;
- // uchar messageSize = 12, myPlayerNum, command = CInMapDraw::NET_LINE; short x1, z1, x2, z2;
- // /*messageSize*/   uchar myPlayerNum, command = CInMapDraw::NET_POINT; short x, z; std::string label;
 
+
+// NETMSG_MAPDRAW = 31, uchar messageSize =  8, myPlayerNum, command = CInMapDraw::NET_ERASE; short x, z;
 void CBaseNetProtocol::SendMapErase(uchar myPlayerNum, short x, short z)
 {
 	SendData&lt;uchar, uchar, uchar, short, short&gt;(NETMSG_MAPDRAW, 8, myPlayerNum, CInMapDraw::NET_ERASE, x, z);
 }
 
+// NETMSG_MAPDRAW = 31, uchar messageSize = 12, myPlayerNum, command = CInMapDraw::NET_LINE; short x1, z1, x2, z2;
 void CBaseNetProtocol::SendMapDrawLine(uchar myPlayerNum, short x1, short z1, short x2, short z2)
 {
 	SendData&lt;uchar, uchar, uchar, short, short, short, short&gt;(NETMSG_MAPDRAW, 12, myPlayerNum, CInMapDraw::NET_LINE, x1, z1, x2, z2);
 }
 
+// NETMSG_MAPDRAW = 31, uchar messageSize, uchar myPlayerNum, command = CInMapDraw::NET_POINT; short x, z; std::string label;
 void CBaseNetProtocol::SendMapDrawPoint(uchar myPlayerNum, short x, short z, const std::string&amp; label)
 {
-	unsigned size = 8 + label.size()+1;
+	unsigned size = 8 + label.size() + 1;
 	PackPacket* packet = new PackPacket(size);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_MAPDRAW) &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(CInMapDraw::NET_POINT) &lt;&lt; x &lt;&lt; z &lt;&lt; label;
 	SendData(packet);
 }
 
-//  NETMSG_SYNCREQUEST      = 32, // int frameNum;
 
+
 void CBaseNetProtocol::SendSyncRequest(int frameNum)
 {
 	SendData&lt;int&gt;(NETMSG_SYNCREQUEST, frameNum);
 }
 
-//  NETMSG_SYNCRESPONSE     = 33, // uchar myPlayerNum; int frameNum; uint checksum;
-
 void CBaseNetProtocol::SendSyncResponse(uchar myPlayerNum, int frameNum, uint checksum)
 {
 	SendData&lt;uchar, int, uint&gt;(NETMSG_SYNCRESPONSE, myPlayerNum, frameNum, checksum);
 }
 
-//  NETMSG_SYSTEMMSG        = 35, // uchar myPlayerNum; std::string message;
-
 void CBaseNetProtocol::SendSystemMessage(uchar myPlayerNum, const std::string&amp; message)
 {
-	unsigned size = 3 + message.size()+1;
+	unsigned size = 3 + message.size() + 1;
 	PackPacket* packet = new PackPacket(size);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_SYSTEMMSG) &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; message;
 	SendData(packet);
 }
 
-//  NETMSG_STARTPOS         = 36, // uchar myPlayerNum, uchar myTeam, ready /*0: not ready, 1: ready, 2: don't update readiness*/; float x, y, z;
-
 void CBaseNetProtocol::SendStartPos(uchar myPlayerNum, uchar teamNum, uchar ready, float x, float y, float z)
 {
 	SendData&lt;uchar, uchar, uchar, float, float, float&gt;(NETMSG_STARTPOS, myPlayerNum, teamNum, ready, x, y, z);
 }
 
-//  NETMSG_PLAYERINFO       = 38, // uchar myPlayerNum; float cpuUsage; int ping /*in frames*/;
 void CBaseNetProtocol::SendPlayerInfo(uchar myPlayerNum, float cpuUsage, int ping)
 {
 	SendData&lt;uchar, float, int&gt;(NETMSG_PLAYERINFO, myPlayerNum, cpuUsage, ping);
 }
 
-//  NETMSG_PLAYERLEFT       = 39, // uchar myPlayerNum, bIntended /*0: lost connection, 1: left*/;
-
 void CBaseNetProtocol::SendPlayerLeft(uchar myPlayerNum, uchar bIntended)
 {
 	SendData&lt;uchar, uchar&gt;(NETMSG_PLAYERLEFT, myPlayerNum, bIntended);
 }
 
-//  NETMSG_LUAMSG          = 50, // uchar myPlayerNum; std::string modName;   (e.g. `custom msg')
-
+// NETMSG_LUAMSG = 50, uchar myPlayerNum; std::string modName; (e.g. `custom msg')
 void CBaseNetProtocol::SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode,
                                   const std::string&amp; msg)
 {
-  // avoid the trailing '\0' processing
-  const unsigned short msgLen = msg.size() + 6;
-  const char* msgPtr = (char*)&msgLen;
-  std::string data;
-  data.push_back((char)NETMSG_LUAMSG);
-  data.push_back(msgPtr[0]);
-  data.push_back(msgPtr[1]);
-  data.push_back(myPlayerNum);
-  data.push_back(script);
-  data.push_back(mode);
-  data.append(msg);
-  SendData((const unsigned char*)data.data(), msgLen);    
+	// avoid the trailing '\0' processing
+	const unsigned short msgLen = msg.size() + 6;
+	const char* msgPtr = (char*) &msgLen;
+	std::string data;
+	data.push_back((char)NETMSG_LUAMSG);
+	data.push_back(msgPtr[0]);
+	data.push_back(msgPtr[1]);
+	data.push_back(myPlayerNum);
+	data.push_back(script);
+	data.push_back(mode);
+	data.append(msg);
+	SendData((const unsigned char*) data.data(), msgLen);
 }
 
 void CBaseNetProtocol::SendSelfD(uchar myPlayerNum)
@@ -393,4 +359,3 @@
 #endif // SYNCDEBUG
 
 */
- 

Modified: branches/gml/rts/System/BaseNetProtocol.h
===================================================================
--- branches/gml/rts/System/BaseNetProtocol.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/BaseNetProtocol.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -34,10 +34,13 @@
 	NETMSG_COMMAND          = 11, // uchar myPlayerNum; int id; uchar options; std::vector&lt;float&gt; params;
 	NETMSG_SELECT           = 12, // uchar myPlayerNum; std::vector&lt;short&gt; selectedUnitIDs;
 	NETMSG_PAUSE            = 13, // uchar playerNum, bPaused;
+
 	NETMSG_AICOMMAND        = 14, // uchar myPlayerNum; short unitID; int id; uchar options; std::vector&lt;float&gt; params;
 	NETMSG_AICOMMANDS       = 15, // uchar myPlayerNum;
 	                              // short unitIDCount;  unitIDCount X short(unitID)
 	                              // short commandCount; commandCount X { int id; uchar options; std::vector&lt;float&gt; params }
+	NETMSG_AISHARE          = 16, // uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, std::vector&lt;short&gt; unitIDs
+
 	NETMSG_MEMDUMP          = 17, // (NEVER SENT)
 	NETMSG_USER_SPEED       = 19, // uchar myPlayerNum, float userSpeed;
 	NETMSG_INTERNAL_SPEED   = 20, // float internalSpeed;
@@ -119,8 +122,11 @@
 	void SendCommand(uchar myPlayerNum, int id, uchar options, const std::vector&lt;float&gt;&amp; params);
 	void SendSelect(uchar myPlayerNum, const std::vector&lt;short&gt;&amp; selectedUnitIDs);
 	void SendPause(uchar myPlayerNum, uchar bPaused);
+
 	void SendAICommand(uchar myPlayerNum, short unitID, int id, uchar options, const std::vector&lt;float&gt;&amp; params);
 	void SendAICommands(uchar myPlayerNum, short unitIDCount, ...);
+	void SendAIShare(uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, const std::vector&lt;short&gt;&amp; unitIDs);
+
 	void SendUserSpeed(uchar myPlayerNum, float userSpeed);
 	void SendInternalSpeed(float internalSpeed);
 	void SendCPUUsage(float cpuUsage);

Modified: branches/gml/rts/System/FastMath.h
===================================================================
--- branches/gml/rts/System/FastMath.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FastMath.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,175 +1,177 @@
-#ifndef FASTMATH_H
-#define FASTMATH_H
-
-/**
- * @file FastMath.cpp
- * @brief Fast math routines
- *
- * Contains faster alternatives for the more time
- * consuming standard math routines. These functions
- * are not as accurate, however, but are generally
- * acceptable for most applications.
- *
- */
-
-namespace fastmath {
-	/****************** Square root functions ******************/
-
-	/**
-	* @brief Calculates 1/sqrt(x) with less accuracy
-	*
-	* Gets a very good first guess and then uses one
-	* iteration of newton's method for improved accuracy.
-	* Average relative error: 0.093%
-	* Highest relative error: 0.175%
-	*
-	* see &quot;The Math Behind The Fast Inverse Square Root Function Code&quot;
-	* by Charles McEniry [2007] for a mathematical derivation of this
-	* method (or Chris Lomont's 2003 &quot;Fast Inverse Square Root&quot; paper)
-	*
-	*/
-	inline float isqrt(float x) {
-		float xh = 0.5f * x;
-		int i = *(int*) &x;
-		// &quot;magic number&quot; which makes a very good first guess
-		i = 0x5f375a86 - (i &gt;&gt; 1);
-		x = *(float*) &i;
-		// Newton's method. One iteration for less accuracy but more speed.
-		x = x * (1.5f - xh * (x * x));
-		return x;
-	}
-
-	/**
-	* @brief Calculates 1/sqrt(x) with more accuracy
-	*
-	* Gets a very good first guess and then uses two
-	* iterations of newton's method for improved accuracy.
-	* Average relative error: 0.00017%
-	* Highest relative error: 0.00047%
-	*
-	*/
-	inline float isqrt2(float x) {
-		float xh = 0.5f * x;
-		int i = *(int*) &x;
-		// &quot;magic number&quot; which makes a very good first guess
-		i = 0x5f375a86 - (i &gt;&gt; 1);
-		x = *(float*) &i;
-		// Newton's method. Two iterations for more accuracy but less speed.
-		x = x * (1.5f - xh * (x * x));
-		x = x * (1.5f - xh * (x * x));
-		return x;
-	
-	}
-
-	/**
-	* @brief Calculates square root with less accuracy
-	*
-	* These square root functions use the inverse square
-	* root routines to obtain the answer. This one uses
-	* the less accurate, but faster isqrt().
-	*
-	*/
-	inline float sqrt(float x) {
-		return (isqrt(x) * x);
-	}
-
-	/**
-	* @brief Calculates square root with more accuracy
-	*
-	* These square root functions use the inverse square
-	* root routines to obtain the answer. This one uses
-	* the more accurate, but slower isqrt2().
-	*
-	*/
-	inline float sqrt2(float x) {
-		return (isqrt2(x) * x);
-	}
-
-
-	/****************** Trigonometric functions ******************/
-
-	/**
-	* @brief Pi
-	*
-	* Cherry flavored.
-	*/
-	static const float PI = 3.141592654f;
-
-	/**
-	* @brief Half of pi
-	*
-	* Pi divided by two
-	*/
-	static const float HALFPI = PI / 2.0f;
-
-	/**
-	* @brief Pi times two
-	*
-	* Pi times two
-	*/
-	static const float PI2 = PI * 2.0f;
-
-	/**
-	* @brief Four divided by pi
-	*
-	* Four over pi
-	*/
-	static const float PIU4 = 4.0 / PI;
-
-	/**
-	* @brief Negative four divided by pi squared
-	*
-	* Negative four over (pi squared)
-	*/
-	static const float PISUN4 = -4.0 / (PI * PI);
-
-	/**
-	* @brief reciprocal of pi
-	*
-	* One over (pi times two)
-	*/
-	static const float INVPI2 = 1.0f / PI2;
-
-	/**
-	* @brief negative half pi
-	*
-	* -pi / 2
-	*/
-	static const float NEGHALFPI = -HALFPI;
-
-	/**
-	* @brief calculates the sine of x
-	*
-	* Range reduces x to -PI ... PI, and then uses the
-	* sine approximation method as described at
-	* <A HREF="http://www.devmaster.net/forums/showthread.php?t=5784">http://www.devmaster.net/forums/showthread.php?t=5784</A>
-	*
-	* Average percentage error: 0.15281632393574715%
-	* Highest percentage error: 0.17455324009559584%
-	*/
-	inline float sin(float x) {
-		/* range reduce to -PI ... PI, as the approximation
-		method only works well for that range. */
-		x = x - ((int)(x * INVPI2)) * PI2;
-		if(x &gt; HALFPI) {
-			x = -x + PI;
-		} else if (x &lt; NEGHALFPI ) {
-			x = -x - PI;
-		}
-		/* approximation */
-		x = (PIU4) * x + (PISUN4) * x * fabs(x);
-		x = 0.225 * (x * fabs(x) - x) + x;
-		return x;
-	}
-
-	/**
-	* @brief calculates the cosine of x
-	*
-	* Adds half of pi to x and then uses the sine method.
-	*/
-	inline float cos(float x) {
-		return sin(x + HALFPI);
-	}
-}
-
-#endif
+#ifndef FASTMATH_H
+#define FASTMATH_H
+
+#include &quot;StdAfx.h&quot;
+
+/**
+ * @file FastMath.cpp
+ * @brief Fast math routines
+ *
+ * Contains faster alternatives for the more time
+ * consuming standard math routines. These functions
+ * are not as accurate, however, but are generally
+ * acceptable for most applications.
+ *
+ */
+
+namespace fastmath {
+	/****************** Square root functions ******************/
+
+	/**
+	* @brief Calculates 1/sqrt(x) with less accuracy
+	*
+	* Gets a very good first guess and then uses one
+	* iteration of newton's method for improved accuracy.
+	* Average relative error: 0.093%
+	* Highest relative error: 0.175%
+	*
+	* see &quot;The Math Behind The Fast Inverse Square Root Function Code&quot;
+	* by Charles McEniry [2007] for a mathematical derivation of this
+	* method (or Chris Lomont's 2003 &quot;Fast Inverse Square Root&quot; paper)
+	*
+	*/
+	inline float isqrt(float x) {
+		float xh = 0.5f * x;
+		int i = *(int*) &x;
+		// &quot;magic number&quot; which makes a very good first guess
+		i = 0x5f375a86 - (i &gt;&gt; 1);
+		x = *(float*) &i;
+		// Newton's method. One iteration for less accuracy but more speed.
+		x = x * (1.5f - xh * (x * x));
+		return x;
+	}
+
+	/**
+	* @brief Calculates 1/sqrt(x) with more accuracy
+	*
+	* Gets a very good first guess and then uses two
+	* iterations of newton's method for improved accuracy.
+	* Average relative error: 0.00017%
+	* Highest relative error: 0.00047%
+	*
+	*/
+	inline float isqrt2(float x) {
+		float xh = 0.5f * x;
+		int i = *(int*) &x;
+		// &quot;magic number&quot; which makes a very good first guess
+		i = 0x5f375a86 - (i &gt;&gt; 1);
+		x = *(float*) &i;
+		// Newton's method. Two iterations for more accuracy but less speed.
+		x = x * (1.5f - xh * (x * x));
+		x = x * (1.5f - xh * (x * x));
+		return x;
+	
+	}
+
+	/**
+	* @brief Calculates square root with less accuracy
+	*
+	* These square root functions use the inverse square
+	* root routines to obtain the answer. This one uses
+	* the less accurate, but faster isqrt().
+	*
+	*/
+	inline float sqrt(float x) {
+		return (isqrt(x) * x);
+	}
+
+	/**
+	* @brief Calculates square root with more accuracy
+	*
+	* These square root functions use the inverse square
+	* root routines to obtain the answer. This one uses
+	* the more accurate, but slower isqrt2().
+	*
+	*/
+	inline float sqrt2(float x) {
+		return (isqrt2(x) * x);
+	}
+
+
+	/****************** Trigonometric functions ******************/
+
+	/**
+	* @brief Pi
+	*
+	* Cherry flavored.
+	*/
+	static const float PI = 3.141592654f;
+
+	/**
+	* @brief Half of pi
+	*
+	* Pi divided by two
+	*/
+	static const float HALFPI = PI / 2.0f;
+
+	/**
+	* @brief Pi times two
+	*
+	* Pi times two
+	*/
+	static const float PI2 = PI * 2.0f;
+
+	/**
+	* @brief Four divided by pi
+	*
+	* Four over pi
+	*/
+	static const float PIU4 = 4.0 / PI;
+
+	/**
+	* @brief Negative four divided by pi squared
+	*
+	* Negative four over (pi squared)
+	*/
+	static const float PISUN4 = -4.0 / (PI * PI);
+
+	/**
+	* @brief reciprocal of pi
+	*
+	* One over (pi times two)
+	*/
+	static const float INVPI2 = 1.0f / PI2;
+
+	/**
+	* @brief negative half pi
+	*
+	* -pi / 2
+	*/
+	static const float NEGHALFPI = -HALFPI;
+
+	/**
+	* @brief calculates the sine of x
+	*
+	* Range reduces x to -PI ... PI, and then uses the
+	* sine approximation method as described at
+	* <A HREF="http://www.devmaster.net/forums/showthread.php?t=5784">http://www.devmaster.net/forums/showthread.php?t=5784</A>
+	*
+	* Average percentage error: 0.15281632393574715%
+	* Highest percentage error: 0.17455324009559584%
+	*/
+	inline float sin(float x) {
+		/* range reduce to -PI ... PI, as the approximation
+		method only works well for that range. */
+		x = x - ((int)(x * INVPI2)) * PI2;
+		if (x &gt; HALFPI) {
+			x = -x + PI;
+		} else if (x &lt; NEGHALFPI ) {
+			x = -x - PI;
+		}
+		/* approximation */
+		x = (PIU4) * x + (PISUN4) * x * fabsf(x);
+		x = 0.225 * (x * fabsf(x) - x) + x;
+		return x;
+	}
+
+	/**
+	* @brief calculates the cosine of x
+	*
+	* Adds half of pi to x and then uses the sine method.
+	*/
+	inline float cos(float x) {
+		return sin(x + HALFPI);
+	}
+}
+
+#endif


Property changes on: branches/gml/rts/System/FastMath.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/FileSystem/Archive7Zip.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/Archive7Zip.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/Archive7Zip.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -24,7 +24,7 @@
 	return SZE_FAIL;
 }
 
-CArchive7Zip::CArchive7Zip(const string&amp; name) :
+CArchive7Zip::CArchive7Zip(const std::string&amp; name):
 	CArchiveBuffered(name),
 	curSearchHandle(1),
 	isOpen(false)
@@ -55,8 +55,10 @@
 	// Get contents of archive and store name-&gt;int mapping
 	for (unsigned i = 0; i &lt; db.Database.NumFiles; ++i) {
 		CFileItem* fi = db.Database.Files + i;
+		// NOTE: fix this on next CArchiveScanner INTERNAL_VER bump.
+		// It should be `if (fi-&gt;Size &gt;= 0) {' because now zero-size files are ignored.
 		if (fi-&gt;Size &gt; 0) {
-			string name = fi-&gt;Name;
+			std::string name = fi-&gt;Name;
 			//SetSlashesForwardToBack(name);
 
 			FileData fd;
@@ -79,20 +81,20 @@
 	}
 }
 
-unsigned int CArchive7Zip::GetCrc32 (const string&amp; fileName)
+unsigned int CArchive7Zip::GetCrc32 (const std::string&amp; fileName)
 {
-	string lower = StringToLower(fileName);
+	std::string lower = StringToLower(fileName);
 	FileData fd = fileData[lower];
 	return fd.crc;
 }
 
-ABOpenFile_t* CArchive7Zip::GetEntireFile(const string&amp; fName)
+ABOpenFile_t* CArchive7Zip::GetEntireFile(const std::string&amp; fName)
 {
 	if (!isOpen)
 		return NULL;
 
 	// Figure out the file index
-	string fileName = StringToLower(fName);
+	std::string fileName = StringToLower(fName);
 	
 	if (fileData.find(fileName) == fileData.end())
 		return NULL;
@@ -133,7 +135,7 @@
 	return of;
 }
 
-void CArchive7Zip::SetSlashesForwardToBack(string&amp; name)
+void CArchive7Zip::SetSlashesForwardToBack(std::string&amp; name)
 {
 	for (unsigned int i = 0; i &lt; name.length(); ++i) {
 		if (name[i] == '/')
@@ -141,7 +143,7 @@
 	}
 }
 
-int CArchive7Zip::FindFiles(int cur, string* name, int* size)
+int CArchive7Zip::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {
 		curSearchHandle++;

Modified: branches/gml/rts/System/FileSystem/Archive7Zip.h
===================================================================
--- branches/gml/rts/System/FileSystem/Archive7Zip.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/Archive7Zip.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -22,13 +22,13 @@
 	struct FileData {
 		int fp;
 		int size;
-		string origName;
+		std::string origName;
 		unsigned int crc;
 	};
-	map&lt;string, FileData&gt; fileData;
+	std::map&lt;std::string, FileData&gt; fileData;
 
 	int curSearchHandle;
-	map&lt;int, map&lt;string, FileData&gt;::iterator&gt; searchHandles;
+	std::map&lt;int, std::map&lt;std::string, FileData&gt;::iterator&gt; searchHandles;
 
 	CFileInStream archiveStream;
 	CArchiveDatabaseEx db;
@@ -36,14 +36,14 @@
 	ISzAlloc allocTempImp;
 
 	bool isOpen;
-	virtual ABOpenFile_t* GetEntireFile(const string&amp; fName);
-	void SetSlashesForwardToBack(string&amp; name);
+	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fName);
+	void SetSlashesForwardToBack(std::string&amp; name);
 public:
-	CArchive7Zip(const string&amp; name);
+	CArchive7Zip(const std::string&amp; name);
 	virtual ~CArchive7Zip(void);
 	virtual bool IsOpen();
-	virtual int FindFiles(int cur, string* name, int* size);
-	virtual unsigned int GetCrc32 (const string&amp; fileName);
+	virtual int FindFiles(int cur, std::string* name, int* size);
+	virtual unsigned int GetCrc32 (const std::string&amp; fileName);
 };
 
 #endif

Modified: branches/gml/rts/System/FileSystem/ArchiveBase.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveBase.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveBase.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,24 +1,23 @@
 #include &quot;ArchiveBase.h&quot;
+#include &quot;CRC.h&quot;
 
-extern &quot;C&quot; {
-#include &quot;lib/7zip/7zCrc.h&quot;
-};
-
-unsigned int CArchiveBase::GetCrc32 (const string&amp; fileName)
+unsigned int CArchiveBase::GetCrc32(const std::string&amp; fileName)
 {
-	UInt32 crc;
+	CRC crc;
 	unsigned char buffer [65536];
 	int handle;
+	int maxRead;
+	int total = 0;
 
-	CrcInit(&amp;crc);
 	handle = this-&gt;OpenFile(fileName);
-	if (handle == 0) return CrcGetDigest(&amp;crc);
+	if (handle == 0) return crc.GetDigest();
 
-	while (!this-&gt;Eof(handle)) {
-		int maxRead = this-&gt;ReadFile(handle, &amp;buffer, sizeof(buffer));
-		CrcUpdate (&amp;crc, buffer, maxRead);
-	}
+	do {
+		maxRead = this-&gt;ReadFile(handle, &amp;buffer, sizeof(buffer));
+		crc.Update(buffer, maxRead);
+		total += maxRead;
+	} while (maxRead == sizeof(buffer));
 
 	this-&gt;CloseFile(handle);
-	return CrcGetDigest(&amp;crc);
+	return crc.GetDigest();
 };

Modified: branches/gml/rts/System/FileSystem/ArchiveBase.h
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveBase.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveBase.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,23 +5,21 @@
 
 #include &lt;string&gt;
 
-using namespace std;
-
 class CArchiveBase
 {
 public:
-	CArchiveBase(const string&amp; archiveName) {};
+	CArchiveBase(const std::string&amp; archiveName) {};
 	virtual ~CArchiveBase();
 	virtual bool IsOpen() = 0;
-	virtual int OpenFile(const string&amp; fileName) = 0;
+	virtual int OpenFile(const std::string&amp; fileName) = 0;
 	virtual int ReadFile(int handle, void* buffer, int numBytes) = 0;
 	virtual void CloseFile(int handle) = 0;
 	virtual void Seek(int handle, int pos) = 0;
 	virtual int Peek(int handle) = 0;
 	virtual bool Eof(int handle) = 0;
 	virtual int FileSize(int handle) = 0;
-	virtual int FindFiles(int cur, string* name, int* size) = 0;
-	virtual unsigned int GetCrc32 (const string&amp; fileName);
+	virtual int FindFiles(int cur, std::string* name, int* size) = 0;
+	virtual unsigned int GetCrc32 (const std::string&amp; fileName);
 };
 
 #endif

Modified: branches/gml/rts/System/FileSystem/ArchiveBuffered.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveBuffered.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveBuffered.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,7 +3,7 @@
 #include &quot;ArchiveBuffered.h&quot;
 #include &quot;mmgr.h&quot;
 
-CArchiveBuffered::CArchiveBuffered(const string&amp; name) :
+CArchiveBuffered::CArchiveBuffered(const std::string&amp; name):
 	CArchiveBase(name),
 	curFileHandle(1)
 {
@@ -11,13 +11,13 @@
 
 CArchiveBuffered::~CArchiveBuffered(void)
 {
-	for (map&lt;int, ABOpenFile_t*&gt;::iterator i = fileHandles.begin(); i != fileHandles.end(); ++i) {
+	for (std::map&lt;int, ABOpenFile_t*&gt;::iterator i = fileHandles.begin(); i != fileHandles.end(); ++i) {
 		free((i-&gt;second)-&gt;data);
 		delete i-&gt;second;
 	}
 }
 
-int CArchiveBuffered::OpenFile(const string&amp; fileName)
+int CArchiveBuffered::OpenFile(const std::string&amp; fileName)
 {
 	ABOpenFile_t* fh = GetEntireFile(fileName);
 	if (!fh)
@@ -33,7 +33,7 @@
 {
 	ABOpenFile_t* of = fileHandles[handle];
 
-	int maxRead = min(numBytes, of-&gt;size - of-&gt;pos);
+	int maxRead = std::min(numBytes, of-&gt;size - of-&gt;pos);
 	memcpy(buffer, of-&gt;data + of-&gt;pos, maxRead);
 	of-&gt;pos += maxRead;
 
@@ -50,7 +50,7 @@
 void CArchiveBuffered::Seek(int handle, int pos)
 {
 	ABOpenFile_t* of = fileHandles[handle];
-	of-&gt;pos = min(pos, of-&gt;size);
+	of-&gt;pos = std::min(pos, of-&gt;size);
 }
 
 int CArchiveBuffered::Peek(int handle)

Modified: branches/gml/rts/System/FileSystem/ArchiveBuffered.h
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveBuffered.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveBuffered.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -17,12 +17,12 @@
 {
 protected:
 	int curFileHandle;
-	map&lt;int, ABOpenFile_t*&gt; fileHandles;
-	virtual ABOpenFile_t* GetEntireFile(const string&amp; fileName) = 0;
+	std::map&lt;int, ABOpenFile_t*&gt; fileHandles;
+	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fileName) = 0;
 public:
-	CArchiveBuffered(const string&amp; name);
+	CArchiveBuffered(const std::string&amp; name);
 	virtual ~CArchiveBuffered(void);
-	virtual int OpenFile(const string&amp; fileName);
+	virtual int OpenFile(const std::string&amp; fileName);
 	virtual int ReadFile(int handle, void* buffer, int numBytes);
 	virtual void CloseFile(int handle);
 	virtual void Seek(int handle, int pos);

Modified: branches/gml/rts/System/FileSystem/ArchiveDir.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveDir.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveDir.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -18,7 +18,7 @@
 	return it-&gt;second;
 }
 
-CArchiveDir::CArchiveDir(const string&amp; archivename) :
+CArchiveDir::CArchiveDir(const std::string&amp; archivename) :
 		CArchiveBase(archivename),
 		archiveName(archivename + '/'),
 		curFileHandle(0),
@@ -92,7 +92,7 @@
 	return GetFileHandler(handle)-&gt;FileSize();
 }
 
-int CArchiveDir::FindFiles(int cur, string* name, int* size)
+int CArchiveDir::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {
 		cur = ++curSearchHandle;

Modified: branches/gml/rts/System/FileSystem/ArchiveDir.h
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveDir.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveDir.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -27,17 +27,17 @@
 
 public:
 
-	CArchiveDir(const string&amp; archiveName);
+	CArchiveDir(const std::string&amp; archiveName);
 	virtual ~CArchiveDir(void);
 	virtual bool IsOpen();
-	virtual int OpenFile(const string&amp; fileName);
+	virtual int OpenFile(const std::string&amp; fileName);
 	virtual int ReadFile(int handle, void* buffer, int numBytes);
 	virtual void CloseFile(int handle);
 	virtual void Seek(int handle, int pos);
 	virtual int Peek(int handle);
 	virtual bool Eof(int handle);
 	virtual int FileSize(int handle);
-	virtual int FindFiles(int cur, string* name, int* size);
+	virtual int FindFiles(int cur, std::string* name, int* size);
 };
 
 #endif

Modified: branches/gml/rts/System/FileSystem/ArchiveHPI.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveHPI.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveHPI.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,7 +5,7 @@
 
 using namespace hpiutil;
 
-CArchiveHPI::CArchiveHPI(const string&amp; name) :
+CArchiveHPI::CArchiveHPI(const std::string&amp; name):
 	CArchiveBuffered(name),
 	curSearchHandle(1)
 {
@@ -16,7 +16,7 @@
 	std::vector&lt;hpientry_ptr&gt; ret = HPIGetFiles(*hpi);
 	for (std::vector&lt;hpientry_ptr&gt;::iterator it = ret.begin(); it != ret.end(); it++) {
 		if (!(*it)-&gt;directory) {
-			string name = StringToLower((*it)-&gt;path());
+			std::string name = StringToLower((*it)-&gt;path());
 			fileSizes[name] = (*it)-&gt;size;
 		}
 	}
@@ -33,9 +33,9 @@
 	return (hpi != NULL);
 }
 
-ABOpenFile_t* CArchiveHPI::GetEntireFile(const string&amp; fileName)
+ABOpenFile_t* CArchiveHPI::GetEntireFile(const std::string&amp; fileName)
 {
-	string name = StringToLower(fileName);
+	std::string name = StringToLower(fileName);
 
 	hpientry_ptr f = HPIOpenFile(*hpi, (const char*)name.c_str());
 	if (!f.get())
@@ -57,7 +57,7 @@
 	return of;
 }
 
-int CArchiveHPI::FindFiles(int cur, string* name, int* size)
+int CArchiveHPI::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {
 		curSearchHandle++;

Modified: branches/gml/rts/System/FileSystem/ArchiveHPI.h
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveHPI.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveHPI.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -11,14 +11,15 @@
 protected:
 	hpiutil::hpifile *hpi;
 	int curSearchHandle;
-	map&lt;string, int&gt; fileSizes;			// hpiutil doesn't provide a way to determine this for a given file
-	map&lt;int, map&lt;string, int&gt;::iterator&gt; searchHandles;
-	virtual ABOpenFile_t* GetEntireFile(const string&amp; fileName);
+	// hpiutil doesn't provide a way to determine this for a given file
+	std::map&lt;std::string, int&gt; fileSizes;
+	std::map&lt;int, std::map&lt;std::string, int&gt;::iterator&gt; searchHandles;
+	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fileName);
 public:
-	CArchiveHPI(const string&amp; name);
+	CArchiveHPI(const std::string&amp; name);
 	virtual ~CArchiveHPI(void);
 	virtual bool IsOpen();
-	virtual int FindFiles(int cur, string* name, int* size);
+	virtual int FindFiles(int cur, std::string* name, int* size);
 };
 
 #endif

Modified: branches/gml/rts/System/FileSystem/ArchiveScanner.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveScanner.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveScanner.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -2,21 +2,20 @@
 
 #include &lt;list&gt;
 #include &lt;algorithm&gt;
+#include &lt;stdio.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
 
 #include &quot;ArchiveFactory.h&quot;
 #include &quot;ArchiveBuffered.h&quot;
 #include &quot;CRC.h&quot;
+#include &quot;FileFilter.h&quot;
 #include &quot;FileHandler.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;TdfParser.h&quot;
+#include &quot;LogOutput.h&quot;
 #include &quot;mmgr.h&quot;
 
-extern &quot;C&quot; {
-#include &quot;lib/7zip/7zCrc.h&quot;
-};
-
 // fix for windows
 #ifndef S_ISDIR
 #define S_ISDIR(x) (((x) &amp; 0170000) == 0040000) /* directory */
@@ -31,6 +30,8 @@
  * is not slow, but mapping them all every time to make the list is)
  */
 
+// NOTE: on the next version bump, be sure to fix the zero-file-size bug in
+// Archive7zip.cpp and ArchiveZip.cpp  (search for NOTE)
 #define INTERNAL_VER	6
 
 CArchiveScanner* archiveScanner = NULL;
@@ -50,10 +51,10 @@
 {
 	char buf[32];
 	sprintf(buf, &quot;ArchiveCacheV%i.txt&quot;, INTERNAL_VER);
-	return string(buf);
+	return std::string(buf);
 }
 
-CArchiveScanner::ModData CArchiveScanner::GetModData(TdfParser* p, const string&amp; section)
+CArchiveScanner::ModData CArchiveScanner::GetModData(TdfParser* p, const std::string&amp; section)
 {
 	ModData md;
 	md.name = &quot;&quot;;
@@ -95,23 +96,22 @@
 	// so make sure it doesn't keep adding stuff to the name everytime
 	// Spring/unitsync is loaded.
 
-	if (md.name.find(md.version) == string::npos) {
+	if (md.name.find(md.version) == std::string::npos) {
 		md.name += &quot; &quot; + md.version;
 	}
 
 	return md;
 }
 
-void CArchiveScanner::Scan(const string&amp; curPath, bool checksum)
+void CArchiveScanner::Scan(const std::string&amp; curPath, bool checksum)
 {
-	InitCrcTable();
 	isDirty = true;
 
 	const int flags = (FileSystem::INCLUDE_DIRS | FileSystem::RECURSE);
 	std::vector&lt;std::string&gt; found = filesystem.FindFiles(curPath, &quot;*&quot;, flags);
 
 	for (std::vector&lt;std::string&gt;::iterator it = found.begin(); it != found.end(); ++it) {
-		string fullName = *it;
+		std::string fullName = *it;
 
 		// Strip
 		const char lastFullChar = fullName[fullName.size() - 1];
@@ -119,19 +119,19 @@
 			fullName = fullName.substr(0, fullName.size() - 1);
 		}
 
-		const string fn    = filesystem.GetFilename(fullName);
-		const string fpath = filesystem.GetDirectory(fullName);
-		const string lcfn    = StringToLower(fn);
-		const string lcfpath = StringToLower(fpath);
+		const std::string fn    = filesystem.GetFilename(fullName);
+		const std::string fpath = filesystem.GetDirectory(fullName);
+		const std::string lcfn    = StringToLower(fn);
+		const std::string lcfpath = StringToLower(fpath);
 
 		// Exclude archivefiles found inside directory archives (.sdd)
-		if (lcfpath.find(&quot;.sdd&quot;) != string::npos) {
+		if (lcfpath.find(&quot;.sdd&quot;) != std::string::npos) {
 			continue;
 		}
 
 		// Exclude archivefiles found inside hidden directories
-		if ((lcfpath.find(&quot;/hidden/&quot;)   != string::npos) ||
-		    (lcfpath.find(&quot;\\hidden\\&quot;) != string::npos)) {
+		if ((lcfpath.find(&quot;/hidden/&quot;)   != std::string::npos) ||
+		    (lcfpath.find(&quot;\\hidden\\&quot;) != std::string::npos)) {
 			continue;
 		}
 
@@ -144,7 +144,7 @@
 			// Determine whether to rely on the cached info or not
 			bool cached = false;
 
-			map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcfn);
+			std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcfn);
 			if (aii != archiveInfo.end()) {
 
 				// This archive may have been obsoleted, do not process it if so
@@ -193,7 +193,7 @@
 				CArchiveBase* ar = CArchiveFactory::OpenArchive(fullName);
 				if (ar) {
 					int cur;
-					string name;
+					std::string name;
 					int size;
 					ArchiveInfo ai;
 
@@ -201,17 +201,17 @@
 					while (cur != 0) {
 						//printf(&quot;found %s %d\n&quot;, name.c_str(), size);
 
-						string ext = StringToLower(name.substr(name.find_last_of('.') + 1));
+						std::string ext = StringToLower(name.substr(name.find_last_of('.') + 1));
 
 						// only accept new format maps
 						if (ext == &quot;smf&quot; || ext == &quot;sm3&quot;) {
 							MapData md;
-							if (name.find_last_of('\\') == string::npos &amp;&amp; name.find_last_of('/') == string::npos) {
+							if (name.find_last_of('\\') == std::string::npos &amp;&amp; name.find_last_of('/') == std::string::npos) {
 								md.name = name;
 								md.virtualPath = &quot;/&quot;;
 							}
 							else {
-								if (name.find_last_of('\\') == string::npos) {
+								if (name.find_last_of('\\') == std::string::npos) {
 									md.name = name.substr(name.find_last_of('/') + 1);
 									md.virtualPath = name.substr(0, name.find_last_of('/') + 1);	// include the backslash
 								} else {
@@ -275,13 +275,12 @@
 	}
 
 	// Now we'll have to parse the replaces-stuff found in the mods
-	for (map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (vector&lt;string&gt;::iterator i = aii-&gt;second.modData.replaces.begin(); i != aii-&gt;second.modData.replaces.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (std::vector&lt;std::string&gt;::iterator i = aii-&gt;second.modData.replaces.begin(); i != aii-&gt;second.modData.replaces.end(); ++i) {
 
-			string lcname = StringToLower(*i);
+			std::string lcname = StringToLower(*i);
+			std::map&lt;std::string, ArchiveInfo&gt;::iterator ar = archiveInfo.find(lcname);
 
-			map&lt;string, ArchiveInfo&gt;::iterator ar = archiveInfo.find(lcname);
-
 			// If it's not there, we will create a new entry
 			if (ar == archiveInfo.end()) {
 				ArchiveInfo tmp;
@@ -302,44 +301,69 @@
 	}
 }
 
-/** Get CRC of the data in the specified file. Returns 0 if file could not be opened. */
 
-unsigned int CArchiveScanner::GetCRC(const string&amp; filename)
+IFileFilter* CArchiveScanner::CreateIgnoreFilter(CArchiveBase* ar)
 {
-	UInt32 crc;
-	UInt32 digest = 0;
+	IFileFilter* ignore = IFileFilter::Create();
+	int fh = ar-&gt;OpenFile(&quot;springignore.txt&quot;);
+
+	if (fh) {
+		int fsize = ar-&gt;FileSize(fh);
+		char* buf = SAFE_NEW char[fsize];
+
+		ar-&gt;ReadFile(fh, buf, fsize);
+		ar-&gt;CloseFile(fh);
+
+		// this automatically splits lines
+		ignore-&gt;AddRule(std::string(buf, fsize));
+
+		delete[] buf;
+	}
+	return ignore;
+}
+
+
+/** Get CRC of the data in the specified archive. Returns 0 if file could not be opened. */
+
+unsigned int CArchiveScanner::GetCRC(const std::string&amp; filename)
+{
+	CRC crc;
+	unsigned int digest;
 	CArchiveBase* ar;
-	list&lt;string&gt; files;
-	string innerName;
-	string lowerName;
+	std::list&lt;std::string&gt; files;
+	std::string innerName;
+	std::string lowerName;
 	int innerSize;
 	int cur = 0;
 
-	CrcInit(&amp;crc);
-
 	// Try to open an archive
 	ar = CArchiveFactory::OpenArchive(filename);
 	if (!ar)
 		return 0; // It wasn't an archive
 
+	// Load ignore list.
+	IFileFilter* ignore = CreateIgnoreFilter(ar);
+
 	// Sort all file paths for deterministic behaviour
 	while (true) {
 		cur = ar-&gt;FindFiles(cur, &amp;innerName, &amp;innerSize);
 		if (cur == 0) break;
+		if (ignore-&gt;Match(innerName)) continue;
 		lowerName = StringToLower(innerName); // case insensitive hash
 		files.push_back(lowerName);
 	}
 	files.sort();
 
 	// Add all files in sorted order
-	for (list&lt;string&gt;::iterator i = files.begin(); i != files.end(); i++ ) {
-		digest = CrcCalculateDigest(i-&gt;data(), i-&gt;size());
-		CrcUpdateUInt32(&amp;crc, digest);
-		CrcUpdateUInt32(&amp;crc, ar-&gt;GetCrc32(*i));
+	for (std::list&lt;std::string&gt;::iterator i = files.begin(); i != files.end(); i++ ) {
+		digest = CRC().Update(i-&gt;data(), i-&gt;size()).GetDigest();
+		crc.Update(digest);
+		crc.Update(ar-&gt;GetCrc32(*i));
 	}
+	delete ignore;
 	delete ar;
 
-	digest = CrcGetDigest(&amp;crc);
+	digest = crc.GetDigest();
 
 	// A value of 0 is used to indicate no crc.. so never return that
 	// Shouldn't happen all that often
@@ -369,7 +393,7 @@
 		ArchiveInfo ai;
 		char keyb[100];
 		sprintf(keyb, &quot;ArchiveCache\\Archive%d\\&quot;, i);
-		string key = keyb;
+		std::string key = keyb;
 
 		ai.origName = p.SGetValueDef(&quot;&quot;, key + &quot;Name&quot;);
 
@@ -382,7 +406,7 @@
 		for (int m = 0; m &lt; numMaps; ++m) {
 			char mapb[100];
 			sprintf(mapb, &quot;%sMap%d\\&quot;, key.c_str(), m);
-			string map = mapb;
+			std::string map = mapb;
 
 			MapData md;
 			md.name = p.SGetValueDef(&quot;&quot;, map + &quot;Name&quot;);
@@ -395,7 +419,7 @@
 			ai.modData = GetModData(&amp;p, key + &quot;Mod&quot;);
 		}
 
-		string lcname = StringToLower(ai.origName);
+		std::string lcname = StringToLower(ai.origName);
 
 		archiveInfo[lcname] = ai;
 	}
@@ -413,8 +437,8 @@
 		return;
 
 	// First delete all outdated information
-	for (map&lt;string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ) {
-		map&lt;string, ArchiveInfo&gt;::iterator next = i;
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ) {
+		std::map&lt;std::string, ArchiveInfo&gt;::iterator next = i;
 		next++;
 		if (!i-&gt;second.updated) {
 			archiveInfo.erase(i);
@@ -426,7 +450,7 @@
 	fprintf(out, &quot;\tNumArchives=%d;\n&quot;, archiveInfo.size());
 	fprintf(out, &quot;\tInternalVer=%d;\n&quot;, INTERNAL_VER);
 	int cur = 0;
-	for (map&lt;string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
 		fprintf(out, &quot;\t[ARCHIVE%d]\n\t{\n&quot;, cur);
 		fprintf(out, &quot;\t\tName=%s;\n&quot;, i-&gt;second.origName.c_str());
 		fprintf(out, &quot;\t\tPath=%s;\n&quot;, i-&gt;second.path.c_str());
@@ -436,7 +460,7 @@
 
 		fprintf(out, &quot;\t\tNumMaps=%d;\n&quot;, i-&gt;second.mapData.size());
 		int curmap = 0;
-		for (vector&lt;MapData&gt;::iterator mi = i-&gt;second.mapData.begin(); mi != i-&gt;second.mapData.end(); ++mi) {
+		for (std::vector&lt;MapData&gt;::iterator mi = i-&gt;second.mapData.begin(); mi != i-&gt;second.mapData.end(); ++mi) {
 			fprintf(out, &quot;\t\t[MAP%d]\n\t\t{\n&quot;, curmap);
 			//WriteData(out, *mi);
 			fprintf(out, &quot;\t\t\tName=%s;\n&quot;, (*mi).name.c_str());
@@ -475,14 +499,14 @@
 
 			fprintf(out, &quot;\t\t\tNumDependencies=%d;\n&quot;, i-&gt;second.modData.dependencies.size());
 			int curdep = 0;
-			for (vector&lt;string&gt;::iterator dep = i-&gt;second.modData.dependencies.begin(); dep != i-&gt;second.modData.dependencies.end(); ++dep) {
+			for (std::vector&lt;std::string&gt;::iterator dep = i-&gt;second.modData.dependencies.begin(); dep != i-&gt;second.modData.dependencies.end(); ++dep) {
 				fprintf(out, &quot;\t\t\tDepend%d=%s;\n&quot;, curdep, (*dep).c_str());
 				curdep++;
 			}
 
 			fprintf(out, &quot;\t\t\tNumReplaces=%d;\n&quot;, i-&gt;second.modData.replaces.size());
 			int currep = 0;
-			for (vector&lt;string&gt;::iterator rep = i-&gt;second.modData.replaces.begin(); rep != i-&gt;second.modData.replaces.end(); ++rep) {
+			for (std::vector&lt;std::string&gt;::iterator rep = i-&gt;second.modData.replaces.begin(); rep != i-&gt;second.modData.replaces.end(); ++rep) {
 				fprintf(out, &quot;\t\t\tReplace%d=%s;\n&quot;, currep++, (*rep).c_str());
 			}
 
@@ -498,11 +522,11 @@
 	isDirty = false;
 }
 
-vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetPrimaryMods() const
+std::vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetPrimaryMods() const
 {
-	vector&lt;ModData&gt; ret;
+	std::vector&lt;ModData&gt; ret;
 
-	for (map&lt;string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
 		if (i-&gt;second.modData.name != &quot;&quot;) {
 
 			if (i-&gt;second.modData.modType != 1)
@@ -518,19 +542,33 @@
 	return ret;
 }
 
-vector&lt;string&gt; CArchiveScanner::GetArchives(const string&amp; root, int depth)
+std::vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetAllMods() const
 {
+	std::vector&lt;ModData&gt; ret;
+
+	for (std::map&lt;std::string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
+		if (i-&gt;second.modData.name != &quot;&quot;) {
+			// Add the archive the mod is in as the first dependency
+			ModData md = i-&gt;second.modData;
+			md.dependencies.insert(md.dependencies.begin(), i-&gt;second.origName);
+			ret.push_back(md);
+		}
+	}
+
+	return ret;
+}
+
+std::vector&lt;std::string&gt; CArchiveScanner::GetArchives(const std::string&amp; root, int depth)
+{
 	// Protect against circular dependencies
 	// (worst case depth is if all archives form one huge dependency chain)
 	if ((unsigned)depth &gt; archiveInfo.size()) {
 		throw content_error(&quot;Circular dependency&quot;);
 	}
 
-	vector&lt;string&gt; ret;
-
-	string lcname = StringToLower(root);
-
-	map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	std::vector&lt;std::string&gt; ret;
+	std::string lcname = StringToLower(ModNameToModArchive(root));
+	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end())
 		return ret;
 
@@ -547,9 +585,9 @@
 		return ret;
 
 	// add depth-first
-	for (vector&lt;string&gt;::iterator i = aii-&gt;second.modData.dependencies.begin(); i != aii-&gt;second.modData.dependencies.end(); ++i) {
-		vector&lt;string&gt; dep = GetArchives(*i, depth + 1);
-		for (vector&lt;string&gt;::iterator j = dep.begin(); j != dep.end(); ++j) {
+	for (std::vector&lt;std::string&gt;::iterator i = aii-&gt;second.modData.dependencies.begin(); i != aii-&gt;second.modData.dependencies.end(); ++i) {
+		std::vector&lt;std::string&gt; dep = GetArchives(*i, depth + 1);
+		for (std::vector&lt;std::string&gt;::iterator j = dep.begin(); j != dep.end(); ++j) {
 			ret.push_back(*j);
 		}
 	}
@@ -557,12 +595,12 @@
 	return ret;
 }
 
-vector&lt;string&gt; CArchiveScanner::GetMaps()
+std::vector&lt;std::string&gt; CArchiveScanner::GetMaps()
 {
-	vector&lt;string&gt; ret;
+	std::vector&lt;std::string&gt; ret;
 
-	for (map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (std::vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
 			ret.push_back((*i).name);
 		}
 	}
@@ -570,12 +608,12 @@
 	return ret;
 }
 
-vector&lt;string&gt; CArchiveScanner::GetArchivesForMap(const string&amp; mapName)
+std::vector&lt;std::string&gt; CArchiveScanner::GetArchivesForMap(const std::string&amp; mapName)
 {
-	vector&lt;string&gt; ret;
+	std::vector&lt;std::string&gt; ret;
 
-	for (map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (std::vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
 			if (mapName == (*i).name) {
 				return GetArchives(aii-&gt;first);
 			}
@@ -585,19 +623,19 @@
 	return ret;
 }
 
-unsigned int CArchiveScanner::GetArchiveChecksum(const string&amp; name)
+unsigned int CArchiveScanner::GetArchiveChecksum(const std::string&amp; name)
 {
-	string lcname = name;
+	std::string lcname = name;
 
 	// Strip path-info if present
-	if (lcname.find_last_of('\\') != string::npos)
+	if (lcname.find_last_of('\\') != std::string::npos)
 		lcname = lcname.substr(lcname.find_last_of('\\') + 1);
-	if (lcname.find_last_of('/') != string::npos)
+	if (lcname.find_last_of('/') != std::string::npos)
 		lcname = lcname.substr(lcname.find_last_of('/') + 1);
 
 	StringToLowerInPlace(lcname);
 
-	map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end()) {
 		return 0;
 	}
@@ -605,19 +643,19 @@
 	return aii-&gt;second.checksum;
 }
 
-std::string CArchiveScanner::GetArchivePath(const string&amp; name)
+std::string CArchiveScanner::GetArchivePath(const std::string&amp; name)
 {
-	string lcname = name;
+	std::string lcname = name;
 
 	// Strip path-info if present
-	if (lcname.find_last_of('\\') != string::npos)
+	if (lcname.find_last_of('\\') != std::string::npos)
 		lcname = lcname.substr(lcname.find_last_of('\\') + 1);
-	if (lcname.find_last_of('/') != string::npos)
+	if (lcname.find_last_of('/') != std::string::npos)
 		lcname = lcname.substr(lcname.find_last_of('/') + 1);
 
 	StringToLowerInPlace(lcname);
 
-	map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end()) {
 		return 0;
 	}
@@ -626,54 +664,67 @@
 }
 
 /** Get checksum of all required archives depending on selected mod. */
-unsigned int CArchiveScanner::GetModChecksum(const string&amp; root)
+unsigned int CArchiveScanner::GetModChecksum(const std::string&amp; root)
 {
 	unsigned int checksum = 0;
-	vector&lt;string&gt; ars = GetArchives(root);
+	std::vector&lt;std::string&gt; ars = GetArchives(root);
 
-	for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
+	for (std::vector&lt;std::string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
 	{
-		checksum ^= GetArchiveChecksum(*i);
+		unsigned tmp = GetArchiveChecksum(*i);
+		logOutput.Print(&quot;mod checksum %s: %u/%d&quot;, i-&gt;c_str(), tmp, (int)tmp);
+		checksum ^= tmp;
 	}
 	return checksum;
 }
 
 /** Get checksum of all required archives depending on selected map. */
-unsigned int CArchiveScanner::GetMapChecksum(const string&amp; mapName)
+unsigned int CArchiveScanner::GetMapChecksum(const std::string&amp; mapName)
 {
 	unsigned int checksum = 0;
-	vector&lt;string&gt; ars = GetArchivesForMap(mapName);
+	std::vector&lt;std::string&gt; ars = GetArchivesForMap(mapName);
 
-	for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
-		checksum ^= GetArchiveChecksum(*i);
+	for (std::vector&lt;std::string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
+		unsigned tmp = GetArchiveChecksum(*i);
+		logOutput.Print(&quot;map checksum %s: %u/%d&quot;, i-&gt;c_str(), tmp, (int)tmp);
+		checksum ^= tmp;
+	}
 	return checksum;
 }
 
 /** Check if calculated mod checksum equals given checksum. Throws content_error if not equal. */
-void CArchiveScanner::CheckMod(const string&amp; root, unsigned checksum)
+void CArchiveScanner::CheckMod(const std::string&amp; root, unsigned checksum)
 {
-	unsigned local = GetModChecksum(root);
-	if (local != checksum) {
-		throw content_error(
-				&quot;Your mod differs from the host's mod. This may be caused by a\n&quot;
-				&quot;missing archive, a corrupted download, or there may even be\n&quot;
-				&quot;2 different versions in circulation. Make sure you and the host\n&quot;
-				&quot;have installed the chosen mod and it's dependencies and\n&quot;
-				&quot;consider redownloading the mod.&quot;);
+	unsigned localChecksum = GetModChecksum(root);
+	if (localChecksum != checksum) {
+		char msg[1024];
+		sprintf(
+			msg,
+			&quot;Your mod (checksum 0x%x) differs from the host's mod (checksum 0x%x).\n&quot;
+			&quot;This may be caused by a missing archive, a corrupted download, or there may even\n&quot;
+			&quot;be 2 different versions in circulation. Make sure you and the host have installed\n&quot;
+			&quot;the chosen mod and its dependencies and consider redownloading the mod.\n&quot;,
+			localChecksum, checksum);
+
+		throw content_error(msg);
 	}
 }
 
 /** Check if calculated map checksum equals given checksum. Throws content_error if not equal. */
-void CArchiveScanner::CheckMap(const string&amp; mapName, unsigned checksum)
+void CArchiveScanner::CheckMap(const std::string&amp; mapName, unsigned checksum)
 {
-	unsigned local = GetMapChecksum(mapName);
-	if (local != checksum) {
-		throw content_error(
-				&quot;Your map differs from the host's map. This may be caused by a\n&quot;
-				&quot;missing archive, a corrupted download, or there may even be\n&quot;
-				&quot;2 different versions in circulation. Make sure you and the host\n&quot;
-				&quot;have installed the chosen map and it's dependencies and\n&quot;
-				&quot;consider redownloading the map.&quot;);
+	unsigned localChecksum = GetMapChecksum(mapName);
+	if (localChecksum != checksum) {
+		char msg[1024];
+		sprintf(
+			msg,
+			&quot;Your map (checksum 0x%x) differs from the host's map (checksum 0x%x).\n&quot;
+			&quot;This may be caused by a missing archive, a corrupted download, or there may even\n&quot;
+			&quot;be 2 different versions in circulation. Make sure you and the host have installed\n&quot;
+			&quot;the chosen map and its dependencies and consider redownloading the mod.\n&quot;,
+			localChecksum, checksum);
+
+		throw content_error(msg);
 	}
 }
 
@@ -681,7 +732,7 @@
 std::string CArchiveScanner::ModNameToModArchive(const std::string&amp; s) const
 {
 	// Convert mod name to mod archive
-	std::vector&lt;ModData&gt; found = GetPrimaryMods();
+	std::vector&lt;ModData&gt; found = GetAllMods();
 	for (std::vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
 		if (it-&gt;name == s)
 			return it-&gt;dependencies.front();
@@ -693,7 +744,7 @@
 std::string CArchiveScanner::ModArchiveToModName(const std::string&amp; s) const
 {
 	// Convert mod archive to mod name
-	std::vector&lt;ModData&gt; found = GetPrimaryMods();
+	std::vector&lt;ModData&gt; found = GetAllMods();
 	for (std::vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
 		if (it-&gt;dependencies.front() == s) {
 			return it-&gt;name;
@@ -706,7 +757,7 @@
 CArchiveScanner::ModData CArchiveScanner::ModNameToModData(const std::string&amp; s) const
 {
 	// Convert mod name to mod archive
-	std::vector&lt;ModData&gt; found = GetPrimaryMods();
+	std::vector&lt;ModData&gt; found = GetAllMods();
 	for (std::vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
 		const ModData&amp; md = *it;
 		if (md.name == s) {
@@ -720,7 +771,7 @@
 CArchiveScanner::ModData CArchiveScanner::ModArchiveToModData(const std::string&amp; s) const
 {
 	// Convert mod archive to mod name
-	std::vector&lt;ModData&gt; found = GetPrimaryMods();
+	std::vector&lt;ModData&gt; found = GetAllMods();
 	for (std::vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
 		const ModData&amp; md = *it;
 		if (md.dependencies.front() == s) {

Modified: branches/gml/rts/System/FileSystem/ArchiveScanner.h
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveScanner.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveScanner.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -5,10 +5,10 @@
 #include &lt;vector&gt;
 #include &lt;map&gt;
 
-#include &lt;stdio.h&gt;
+class CArchiveBase;
+class IFileFilter;
+class TdfParser;
 
-using namespace std;
-
 /*
  * This class searches through a given directory and its subdirectories looking for archive files.
  * When it finds one, it figures out what kind of archive it is (i.e. if it is a map or a mod currently).
@@ -19,43 +19,42 @@
  * than one folder.
  */
 
-class TdfParser;
-
 class CArchiveScanner
 {
 public:
 	struct MapData {
-		string name;
-		string virtualPath;					// Where in the archive the map can be found
+		std::string name;
+		std::string virtualPath;					// Where in the archive the map can be found
 	};
 	struct ModData {
-		string name;        // ex:  Original Total Annihilation v2.3
-		string shortName;   // ex:  OTA
-		string version;     // ex:  v2.3
-		string mutator;     // ex:  deployment
-		string game;        // ex:  Total Annihilation
-		string shortGame;   // ex:  TA
-		string description; // ex:  Little units blowing up other little units
+		std::string name;							// ex:  Original Total Annihilation v2.3
+		std::string shortName;						// ex:  OTA
+		std::string version;						// ex:  v2.3
+		std::string mutator;						// ex:  deployment
+		std::string game;							// ex:  Total Annihilation
+		std::string shortGame;						// ex:  TA
+		std::string description;					// ex:  Little units blowing up other little units
 		int modType;
-		vector&lt;string&gt; dependencies;		// Archives it depends on
-		vector&lt;string&gt; replaces;			// This archive obsoletes these ones
+		std::vector&lt;std::string&gt; dependencies;		// Archives it depends on
+		std::vector&lt;std::string&gt; replaces;			// This archive obsoletes these ones
 	};
 	CArchiveScanner(void);
 	std::string GetFilename();
 	void ReadCacheData(const std::string&amp; filename);
 	void WriteCacheData(const std::string&amp; filename);
 	virtual ~CArchiveScanner(void);
-	void Scan(const string&amp; curPath, bool checksum = false);
-	vector&lt;ModData&gt; GetPrimaryMods() const;
-	vector&lt;string&gt; GetArchives(const string&amp; root, int depth = 0);
-	vector&lt;string&gt; GetMaps();
-	vector&lt;string&gt; GetArchivesForMap(const string&amp; mapName);
-	unsigned int GetArchiveChecksum(const string&amp; name);
-	std::string GetArchivePath(const string&amp; name);
-	unsigned int GetModChecksum(const string&amp; root);
-	unsigned int GetMapChecksum(const string&amp; mapName);
-	void CheckMod(const string&amp; root, unsigned checksum); // these throw a content_error if checksum doesn't match
-	void CheckMap(const string&amp; mapName, unsigned checksum);
+	void Scan(const std::string&amp; curPath, bool checksum = false);
+	std::vector&lt;ModData&gt; GetPrimaryMods() const;
+	std::vector&lt;ModData&gt; GetAllMods() const;
+	std::vector&lt;std::string&gt; GetArchives(const std::string&amp; root, int depth = 0);
+	std::vector&lt;std::string&gt; GetMaps();
+	std::vector&lt;std::string&gt; GetArchivesForMap(const std::string&amp; mapName);
+	unsigned int GetArchiveChecksum(const std::string&amp; name);
+	std::string GetArchivePath(const std::string&amp; name);
+	unsigned int GetModChecksum(const std::string&amp; root);
+	unsigned int GetMapChecksum(const std::string&amp; mapName);
+	void CheckMod(const std::string&amp; root, unsigned checksum); // these throw a content_error if checksum doesn't match
+	void CheckMap(const std::string&amp; mapName, unsigned checksum);
 	std::string ModNameToModArchive(const std::string&amp; s) const;
 	std::string ModArchiveToModName(const std::string&amp; s) const;
 	ModData ModNameToModData(const std::string&amp; s) const;
@@ -63,21 +62,20 @@
 
 protected:
 	struct ArchiveInfo {
-		string path;
-		string origName;					// Could be useful to have the non-lowercased name around
+		std::string path;
+		std::string origName;					// Could be useful to have the non-lowercased name around
 		unsigned int modified;
-		vector&lt;MapData&gt; mapData;
+		std::vector&lt;MapData&gt; mapData;
 		ModData modData;
 		unsigned int checksum;
 		bool updated;
-		string replaced;					// If not empty, use that archive instead
+		std::string replaced;					// If not empty, use that archive instead
 	};
-	map&lt;string, ArchiveInfo&gt; archiveInfo;
-	ModData GetModData(TdfParser* p, const string&amp; section);
-	unsigned int GetCRC(const string&amp; filename);
-	unsigned int GetDirectoryCRC(const string&amp; curPath);
+	std::map&lt;std::string, ArchiveInfo&gt; archiveInfo;
+	ModData GetModData(TdfParser* p, const std::string&amp; section);
+	IFileFilter* CreateIgnoreFilter(CArchiveBase* ar);
+	unsigned int GetCRC(const std::string&amp; filename);
 	bool isDirty;
-	//void WriteModData(FILE* out, const ModData&amp; data);	// Helper to write out dependencies
 };
 
 extern CArchiveScanner* archiveScanner;

Modified: branches/gml/rts/System/FileSystem/ArchiveZip.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveZip.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveZip.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,7 +3,7 @@
 #include &lt;algorithm&gt;
 #include &quot;mmgr.h&quot;
 
-CArchiveZip::CArchiveZip(const string&amp; name) :
+CArchiveZip::CArchiveZip(const std::string&amp; name):
 	CArchiveBuffered(name),
 	curSearchHandle(1)
 {
@@ -21,10 +21,13 @@
 	for (int ret = unzGoToFirstFile(zip); ret == UNZ_OK; ret = unzGoToNextFile(zip)) {
 		unz_file_info info;
 		char fname[512];
-		string name;
+		std::string name;
 
 		unzGetCurrentFileInfo(zip, &amp;info, fname, 512, NULL, 0, NULL, 0);
 
+		// NOTE: fix this on next CArchiveScanner INTERNAL_VER bump.
+		// It should be `if (info.uncompressed_size &gt;= 0) {' because now
+		// zero-size files are ignored.
 		if (info.uncompressed_size &gt; 0) {
 			name = StringToLower(fname);
 //			SetSlashesForwardToBack(name);
@@ -47,9 +50,9 @@
 		unzClose(zip);
 }
 
-unsigned int CArchiveZip::GetCrc32 (const string&amp; fileName)
+unsigned int CArchiveZip::GetCrc32 (const std::string&amp; fileName)
 {
-	string lower = StringToLower(fileName);
+	std::string lower = StringToLower(fileName);
 	FileData fd = fileData[lower];
 	return fd.crc;
 }
@@ -59,17 +62,17 @@
 	return (zip != NULL);
 }
 
-class zip_exception : public exception {};
+class zip_exception: public std::exception {};
 
 // To simplify things, files are always read completely into memory from the zipfile, since zlib does not
 // provide any way of reading more than one file at a time
-ABOpenFile_t* CArchiveZip::GetEntireFile(const string&amp; fName)
+ABOpenFile_t* CArchiveZip::GetEntireFile(const std::string&amp; fName)
 {
 	// Don't allow opening files on missing/invalid archives
 	if (!zip)
 		return NULL;
 
-	string fileName = StringToLower(fName);
+	std::string fileName = StringToLower(fName);
 
 	//if (unzLocateFile(zip, fileName.c_str(), 2) != UNZ_OK) 
 	//	return 0;
@@ -106,7 +109,7 @@
 	return of;
 }
 
-int CArchiveZip::FindFiles(int cur, string* name, int* size)
+int CArchiveZip::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {
 		curSearchHandle++;
@@ -126,7 +129,7 @@
 	return cur;
 }
 
-void CArchiveZip::SetSlashesForwardToBack(string&amp; name)
+void CArchiveZip::SetSlashesForwardToBack(std::string&amp; name)
 {
 	for (unsigned int i = 0; i &lt; name.length(); ++i) {
 		if (name[i] == '/')
@@ -134,7 +137,7 @@
 	}
 }
 
-void CArchiveZip::SetSlashesBackToForward(string&amp; name)
+void CArchiveZip::SetSlashesBackToForward(std::string&amp; name)
 {
 	for (unsigned int i = 0; i &lt; name.length(); ++i) {
 		if (name[i] == '\\')

Modified: branches/gml/rts/System/FileSystem/ArchiveZip.h
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveZip.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/ArchiveZip.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -18,22 +18,22 @@
 	struct FileData {
 		unz_file_pos fp;
 		int size;
-		string origName;
+		std::string origName;
 		unsigned int crc;
 	};
 	unzFile zip;
-	map&lt;string, FileData&gt; fileData;		// using unzLocateFile is quite slow
+	std::map&lt;std::string, FileData&gt; fileData;		// using unzLocateFile is quite slow
 	int curSearchHandle;
-	map&lt;int, map&lt;string, FileData&gt;::iterator&gt; searchHandles;
-	virtual ABOpenFile_t* GetEntireFile(const string&amp; fileName);
-	void SetSlashesForwardToBack(string&amp; name);
-	void SetSlashesBackToForward(string&amp; name);
+	std::map&lt;int, std::map&lt;std::string, FileData&gt;::iterator&gt; searchHandles;
+	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fileName);
+	void SetSlashesForwardToBack(std::string&amp; name);
+	void SetSlashesBackToForward(std::string&amp; name);
 public:
-	CArchiveZip(const string&amp; name);
+	CArchiveZip(const std::string&amp; name);
 	virtual ~CArchiveZip(void);
 	virtual bool IsOpen();
-	virtual int FindFiles(int cur, string* name, int* size);
-	virtual unsigned int GetCrc32 (const string&amp; fileName);
+	virtual int FindFiles(int cur, std::string* name, int* size);
+	virtual unsigned int GetCrc32 (const std::string&amp; fileName);
 };
 
 #endif

Modified: branches/gml/rts/System/FileSystem/CRC.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/CRC.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/CRC.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,73 +1,37 @@
 #include &quot;CRC.h&quot;
 
-#include &lt;stdio.h&gt;
+extern &quot;C&quot; {
+#include &quot;lib/7zip/7zCrc.h&quot;
+};
 
 
-unsigned int CRC::crcTable[256];
-
-
-/** @brief Generate the lookup table used for CRC calculation.
-    Code taken from <A HREF="http://paul.rutgers.edu/~rhoads/Code/crc-32b.c">http://paul.rutgers.edu/~rhoads/Code/crc-32b.c</A> */
-void CRC::GenerateCRCTable()
+/** @brief Construct a new CRC object. */
+CRC::CRC()
 {
-	unsigned int crc, poly;
-	int	i, j;
-
-	poly = 0xEDB88320L;
-	for (i = 0; i &lt; 256; i++) {
-		crc = i;
-		for (j = 8; j &gt; 0; j--) {
-			if (crc &amp; 1)
-				crc = (crc &gt;&gt; 1) ^ poly;
-			else
-				crc &gt;&gt;= 1;
-		}
-		crcTable[i] = crc;
-	}
+	CrcInit(&amp;crc);
 }
 
 
-/** @brief Construct a new CRC object.
-    This generates the CRC table if it is the first CRC object being
-	constructed. */
-CRC::CRC() : crc(0xFFFFFFFF)
+/** @brief Get the final CRC digest. */
+unsigned int CRC::GetDigest() const
 {
-	if (crcTable[1] == 0)
-		GenerateCRCTable();
+	// make a temporary copy to get away with the const
+	unsigned int temp = crc;
+	return CrcGetDigest(&amp;temp);
 }
 
 
-/** @brief Update CRC over the data in buf. */
-void CRC::UpdateData(const unsigned char* buf, unsigned bytes)
+/** @brief Update CRC over the data. */
+CRC&amp; CRC::Update(const void* data, unsigned int size)
 {
-	for (size_t i = 0; i &lt; bytes; ++i)
-		crc = (crc&gt;&gt;8) ^ crcTable[ (crc^(buf[i])) &amp; 0xFF ];
+	CrcUpdate(&amp;crc, data, size);
+	return *this;
 }
 
 
-/** @brief Update CRC over the data in buf. */
-void CRC::UpdateData(const std::string&amp; buf)
+/** @brief Update CRC over the 4 bytes of data. */
+CRC&amp; CRC::Update(unsigned int data)
 {
-	UpdateData((const unsigned char*) buf.c_str(), buf.size());
+	CrcUpdateUInt32(&amp;crc, data);
+	return *this;
 }
-
-
-/** @brief Update CRC over the data in the specified file.
-    @return true on success, false if file could not be opened. */
-bool CRC::UpdateFile(const std::string&amp; filename)
-{
-	FILE* fp = fopen(filename.c_str(), &quot;rb&quot;);
-	if (!fp)
-		return false;
-
-	unsigned char buf[100000];
-	size_t bytes;
-	do {
-		bytes = fread((void*)buf, 1, 100000, fp);
-		UpdateData(buf, bytes);
-	} while (bytes == 100000);
-
-	fclose(fp);
-
-	return true;
-}

Modified: branches/gml/rts/System/FileSystem/CRC.h
===================================================================
--- branches/gml/rts/System/FileSystem/CRC.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/CRC.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,16 +9,12 @@
 public:
 	CRC();
 
-	void UpdateData(const unsigned char* buf, unsigned bytes);
-	void UpdateData(const std::string&amp; buf);
-	bool UpdateFile(const std::string&amp; filename);
+	unsigned int GetDigest() const;
 
-	unsigned int GetCRC() const { return crc ^ 0xFFFFFFFF; }
+	CRC&amp; Update(const void* data, unsigned int size);
+	CRC&amp; Update(unsigned int data);
 
 private:
-	static unsigned int crcTable[256];
-	static void GenerateCRCTable();
-
 	unsigned int crc;
 };
 

Copied: branches/gml/rts/System/FileSystem/FileFilter.cpp (from rev 5882, trunk/rts/System/FileSystem/FileFilter.cpp)
===================================================================
--- branches/gml/rts/System/FileSystem/FileFilter.cpp	                        (rev 0)
+++ branches/gml/rts/System/FileSystem/FileFilter.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,173 @@
+#include &quot;FileFilter.h&quot;
+
+#include &lt;boost/regex.hpp&gt;
+#include &lt;ctype.h&gt;
+#include &lt;sstream&gt;
+#include &lt;vector&gt;
+
+
+using std::string;
+using std::vector;
+
+
+class CFileFilter : public IFileFilter
+{
+public:
+	void AddRule(const string&amp; rule);
+	bool Match(const string&amp; filename) const;
+
+private:
+	string glob_to_regex(const string&amp; glob);
+
+	struct Rule {
+		Rule() : negate(false) {}
+		string glob;
+		boost::regex regex;
+		bool negate;
+	};
+
+	vector&lt;Rule&gt; rules;
+};
+
+
+IFileFilter* IFileFilter::Create()
+{
+	return new CFileFilter();
+}
+
+
+/** @brief Add a filtering rule.
+
+A rule can be:
+ - An empty line, this is ignored,
+ - A line starting with a '#', this serves as a comment and is ignored,
+ - A path starting with a path separator ('/' or '\'): this is an absolute
+   path and matches only against the entire leading part of the filename
+   passed to Match(): '/foo' matches 'foo' and 'foo/bar', but not 'bar/foo'.
+ - Any other path is a relative path and is matched less strict: as long as
+   there is a consecutive set of path elements matching the rule, there is a
+   match: 'b/c/d' matches 'b/c/d', but also 'a/b/c/d/e'.
+
+Note that:
+ - Leading and trailing whitespace is ignored.
+ - Globbing characters '*' and '?' can be used, both do NOT match path
+   separators (like in shell, but unlike fnmatch(), or so I've been told.)
+   e.g. 'foo\*\baz' matches 'foo/bar/baz' but not 'foo/ba/r/baz'.
+ - Any path separator matches any other path separator, so there is no need to
+   worry about converting them: 'foo/bar' matches 'foo\bar' and 'foo:bar' too.
+ - A path can be prefixed with an exclamation mark '!', this negates the
+   pattern. Because the rules are matched in-order, one can use this to exclude
+   a file from a more generic pattern.
+ - By default, no file matches. This can be changed using AddRule(&quot;*&quot;) ofc.
+*/
+void CFileFilter::AddRule(const string&amp; rule)
+{
+	if (rule.empty())
+		return;
+
+	// Split lines if line endings are present.
+	if (rule.find('\n') != string::npos) {
+		int beg = 0, end = 0;
+		while ((end = rule.find('\n', beg)) != string::npos) {
+			//printf(&quot;line: %s\n&quot;, rule.substr(beg, end - beg).c_str());
+			AddRule(rule.substr(beg, end - beg));
+			beg = end + 1;
+		}
+		AddRule(rule.substr(beg));
+		return;
+	}
+
+	// Eat leading whitespace, return if we reach end of string.
+	int p = 0;
+	while (isspace(rule[p]))
+		if (++p &gt;= rule.length())
+			return;
+
+	// Nothing to do if the rule is a comment.
+	if (rule[p] == '#')
+		return;
+
+	// Eat trailing whitespace, return if we meet p.
+	int q = rule.length() - 1;
+	while (isspace(rule[q]))
+		if (--q &lt; p)
+			return;
+
+	// Build the rule.
+	Rule r;
+	if (rule[p] == '!') {
+		r.negate = true;
+		if (++p &gt; q)
+			return;
+	}
+	r.glob = rule.substr(p, 1 + q - p);
+	r.regex = boost::regex(glob_to_regex(r.glob)
+		, boost::regex::icase | boost::regex::no_escape_in_lists);
+	rules.push_back(r);
+	//printf(&quot;added %s%s: %s\n&quot;, r.negate ? &quot;!&quot; : &quot;&quot;, r.glob.c_str(), r.regex.expression());
+}
+
+
+/** @brief Checks whether filename matches this filter. */
+bool CFileFilter::Match(const string&amp; filename) const
+{
+	bool match = false;
+	for (vector&lt;Rule&gt;::const_iterator it = rules.begin(); it != rules.end(); ++it) {
+		if (boost::regex_search(filename, it-&gt;regex))
+			match = !it-&gt;negate;
+	}
+	return match;
+}
+
+
+string CFileFilter::glob_to_regex(const string&amp; glob)
+{
+#define PATH_SEPARATORS &quot;/\\:&quot;
+
+	std::stringstream regex;
+	string::const_iterator i = glob.begin();
+
+	// If the path starts with a path separator, we take it as an absolute path
+	// (relative to whatever is passed to Match() later on), so we insert the
+	// begin anchor.
+
+	// Otherwise we 'just' need to make sure the glob matches only full path
+	// elements, so we require either start of line OR path separator.
+
+	if (i != glob.end() &amp;&amp; *i == '/' || *i == '\\') {
+		regex &lt;&lt; '^';
+		++i;
+	}
+	else
+		regex &lt;&lt; &quot;(^|[&quot; PATH_SEPARATORS &quot;])&quot;;
+
+	for (; i != glob.end(); ++i) {
+		char c = *i;
+		switch (c) {
+			case '*':
+				// In (shell) globbing the wildcards match anything except path separators.
+				regex &lt;&lt; &quot;[^&quot; PATH_SEPARATORS &quot;]*&quot;;
+				break;
+			case '?':
+				regex &lt;&lt; &quot;[^&quot; PATH_SEPARATORS &quot;]&quot;;
+				break;
+			case '/':
+			case '\\':
+			case ':':
+				// Any path separator matches any other path separator.
+				// (So we don't have to manually convert slashes before search.)
+				regex &lt;&lt; &quot;[&quot; PATH_SEPARATORS &quot;]&quot;;
+				break;
+			default:
+				if (!(isalnum(c) || c == '_'))
+					regex &lt;&lt; '\\';
+				regex &lt;&lt; c;
+				break;
+		}
+	}
+
+	// Make sure we only match full path elements. (see above)
+	regex &lt;&lt; &quot;([&quot; PATH_SEPARATORS &quot;]|$)&quot;;
+
+	return regex.str();
+}

Copied: branches/gml/rts/System/FileSystem/FileFilter.h (from rev 5882, trunk/rts/System/FileSystem/FileFilter.h)
===================================================================
--- branches/gml/rts/System/FileSystem/FileFilter.h	                        (rev 0)
+++ branches/gml/rts/System/FileSystem/FileFilter.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -0,0 +1,17 @@
+#ifndef FILEFILTER_H
+#define FILEFILTER_H
+
+#include &lt;string&gt;
+
+/** @brief Provides a way to filter files using globbing. */
+class IFileFilter
+{
+public:
+	static IFileFilter* Create();
+
+	virtual ~IFileFilter() {}
+	virtual void AddRule(const std::string&amp; rule) = 0;
+	virtual bool Match(const std::string&amp; filename) const = 0;
+};
+
+#endif // !FILEFILTER_H

Modified: branches/gml/rts/System/FileSystem/VFSHandler.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/VFSHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/VFSHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -15,7 +15,7 @@
 }
 
 // Override determines whether if conflicts overwrites an existing entry in the virtual filesystem or not
-bool CVFSHandler::AddArchive(string arName, bool override)
+bool CVFSHandler::AddArchive(std::string arName, bool override)
 {
 	CArchiveBase* ar = archives[arName];
 	if (!ar) {
@@ -27,7 +27,7 @@
 	}
 
 	int cur;
-	string name;
+	std::string name;
 	int size;
 
 	for (cur = ar-&gt;FindFiles(0, &amp;name, &amp;size); cur != 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size)) {
@@ -47,17 +47,17 @@
 
 CVFSHandler::~CVFSHandler(void)
 {
-	for (map&lt;string, CArchiveBase*&gt;::iterator i = archives.begin(); i != archives.end(); ++i) {
+	for (std::map&lt;std::string, CArchiveBase*&gt;::iterator i = archives.begin(); i != archives.end(); ++i) {
 		delete i-&gt;second;
 	}
 }
 
-int CVFSHandler::LoadFile(string name, void* buffer)
+int CVFSHandler::LoadFile(std::string name, void* buffer)
 {
 	StringToLowerInPlace(name);
 	filesystem.ForwardSlashes(name);
 
-	map&lt;string, FileData&gt;::iterator fi = files.find(name);
+	std::map&lt;std::string, FileData&gt;::iterator fi = files.find(name);
 	if (fi == files.end()) {
 		return -1;
 	}
@@ -75,12 +75,12 @@
 	return fsize;
 }
 
-int CVFSHandler::GetFileSize(string name)
+int CVFSHandler::GetFileSize(std::string name)
 {
 	StringToLowerInPlace(name);
 	filesystem.ForwardSlashes(name);
 
-	map&lt;string, FileData&gt;::iterator fi = files.find(name);
+	std::map&lt;std::string, FileData&gt;::iterator fi = files.find(name);
 	if (fi == files.end()) {
 		return -1;
 	}
@@ -103,41 +103,41 @@
 }
 
 // Returns all the files in the given (virtual) directory without the preceeding pathname
-vector&lt;string&gt; CVFSHandler::GetFilesInDir(string dir)
+std::vector&lt;std::string&gt; CVFSHandler::GetFilesInDir(std::string dir)
 {
-	vector&lt;string&gt; ret;
+	std::vector&lt;std::string&gt; ret;
 	StringToLowerInPlace(dir);
 	filesystem.ForwardSlashes(dir);
 
-	map&lt;string, FileData&gt;::const_iterator filesStart = files.begin();
-	map&lt;string, FileData&gt;::const_iterator filesEnd   = files.end();
+	std::map&lt;std::string, FileData&gt;::const_iterator filesStart = files.begin();
+	std::map&lt;std::string, FileData&gt;::const_iterator filesEnd   = files.end();
 
 	// Non-empty directories to look in should have a trailing backslash
 	if (!dir.empty()) {
-		string::size_type dirLast = (dir.length() - 1);
+		std::string::size_type dirLast = (dir.length() - 1);
 		if (dir[dirLast] != '/') {
 			dir += &quot;/&quot;;
 			dirLast++;
 		}
 		// limit the iterator range
-		string dirEnd = dir;
+		std::string dirEnd = dir;
 		dirEnd[dirLast] = dirEnd[dirLast] + 1;
 		filesStart = files.lower_bound(dir);
 		filesEnd   = files.upper_bound(dirEnd);
 	}
 
 	while (filesStart != filesEnd) {
-		const string path = filesystem.GetDirectory(filesStart-&gt;first);
+		const std::string path = filesystem.GetDirectory(filesStart-&gt;first);
 
 		// Test to see if this file start with the dir path
 		if (path.compare(0, dir.length(), dir) == 0) {
 
 			// Strip pathname
-			const string name = filesStart-&gt;first.substr(dir.length());
+			const std::string name = filesStart-&gt;first.substr(dir.length());
 
 			// Do not return files in subfolders
-			if ((name.find('/') == string::npos) &amp;&amp;
-			    (name.find('\\') == string::npos)) {
+			if ((name.find('/') == std::string::npos) &amp;&amp;
+			    (name.find('\\') == std::string::npos)) {
 				ret.push_back(name);
 			}
 		}
@@ -149,46 +149,46 @@
 
 
 // Returns all the sub-directories in the given (virtual) directory without the preceeding pathname
-vector&lt;string&gt; CVFSHandler::GetDirsInDir(string dir)
+std::vector&lt;std::string&gt; CVFSHandler::GetDirsInDir(std::string dir)
 {
-	vector&lt;string&gt; ret;
+	std::vector&lt;std::string&gt; ret;
 	StringToLowerInPlace(dir);
 	filesystem.ForwardSlashes(dir);
 
-	map&lt;string, FileData&gt;::const_iterator filesStart = files.begin();
-	map&lt;string, FileData&gt;::const_iterator filesEnd   = files.end();
+	std::map&lt;std::string, FileData&gt;::const_iterator filesStart = files.begin();
+	std::map&lt;std::string, FileData&gt;::const_iterator filesEnd   = files.end();
 
 	// Non-empty directories to look in should have a trailing backslash
 	if (!dir.empty()) {
-		string::size_type dirLast = (dir.length() - 1);
+		std::string::size_type dirLast = (dir.length() - 1);
 		if (dir[dirLast] != '/') {
 			dir += &quot;/&quot;;
 			dirLast++;
 		}
 		// limit the iterator range
-		string dirEnd = dir;
+		std::string dirEnd = dir;
 		dirEnd[dirLast] = dirEnd[dirLast] + 1;
 		filesStart = files.lower_bound(dir);
 		filesEnd   = files.upper_bound(dirEnd);
 	}
 
-	set&lt;string&gt; dirs;
+	std::set&lt;std::string&gt; dirs;
 
 	while (filesStart != filesEnd) {
-		const string path = filesystem.GetDirectory(filesStart-&gt;first);
+		const std::string path = filesystem.GetDirectory(filesStart-&gt;first);
 		// Test to see if this file start with the dir path
 		if (path.compare(0, dir.length(), dir) == 0) {
 			// Strip pathname
-			const string name = filesStart-&gt;first.substr(dir.length());
-			const string::size_type slash = name.find_first_of(&quot;/\\&quot;);
-			if (slash != string::npos) {
+			const std::string name = filesStart-&gt;first.substr(dir.length());
+			const std::string::size_type slash = name.find_first_of(&quot;/\\&quot;);
+			if (slash != std::string::npos) {
 				dirs.insert(name.substr(0, slash + 1));
 			}
 		}
 		filesStart++;
 	}
 
-	for (set&lt;string&gt;::const_iterator it = dirs.begin(); it != dirs.end(); ++it) {
+	for (std::set&lt;std::string&gt;::const_iterator it = dirs.begin(); it != dirs.end(); ++it) {
 		ret.push_back(*it);
 	}
 

Modified: branches/gml/rts/System/FileSystem/VFSHandler.h
===================================================================
--- branches/gml/rts/System/FileSystem/VFSHandler.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/FileSystem/VFSHandler.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -7,8 +7,6 @@
 
 class CArchiveBase;
 
-using namespace std;
-
 class CVFSHandler
 {
 protected:
@@ -17,19 +15,19 @@
 		int size;
 		bool dynamic;
 	};
-	map&lt;string, FileData&gt; files; 
-	map&lt;string, CArchiveBase*&gt; archives;
+	std::map&lt;std::string, FileData&gt; files; 
+	std::map&lt;std::string, CArchiveBase*&gt; archives;
 public:
 	CVFSHandler();
 	virtual ~CVFSHandler();
 
-	int LoadFile(string name, void* buffer);
-	int GetFileSize(string name);
+	int LoadFile(std::string name, void* buffer);
+	int GetFileSize(std::string name);
 
-	vector&lt;string&gt; GetFilesInDir(string dir);
-	vector&lt;string&gt; GetDirsInDir(string dir);
+	std::vector&lt;std::string&gt; GetFilesInDir(std::string dir);
+	std::vector&lt;std::string&gt; GetDirsInDir(std::string dir);
 
-	bool AddArchive(string arName, bool override);
+	bool AddArchive(std::string arName, bool override);
 };
 
 extern CVFSHandler* hpiHandler;

Modified: branches/gml/rts/System/GlobalStuff.cpp
===================================================================
--- branches/gml/rts/System/GlobalStuff.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/GlobalStuff.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -109,12 +109,6 @@
 	gaiaAllyTeamID=-1;
 	useLuaRules=true;
 	
-	sunVector=float3(0,0,1);
-	sunVector4[0]=0;
-	sunVector4[1]=0;
-	sunVector4[2]=1;
-	sunVector4[3]=0;
-
 	for(int a=0; a &lt; MAX_TEAMS; ++a){
 		teams[a]=SAFE_NEW CTeam();
 		teams[a]-&gt;teamNum=a;
@@ -135,10 +129,6 @@
 	activeTeams=2;
 	activeAllyTeams=2;
 	activePlayers=MAX_PLAYERS;
-
-	sunVector=float3(0,1,2).Normalize();
-
-	gravity = -0.1f;
 }
 
 /**
@@ -228,6 +218,7 @@
 	viewRange=MAX_VIEW_RANGE;
 	timeOffset=0;
 	drawFog=true;
+	compressTextures=false;
 	teamNanospray=false;
 	autoQuit=false;
 	quitTime=0;

Modified: branches/gml/rts/System/GlobalStuff.h
===================================================================
--- branches/gml/rts/System/GlobalStuff.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/GlobalStuff.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -303,15 +303,6 @@
 	int gameMode;
 
 	/**
-	 * @brief gravity
-	 *
-	 * Stores the gravity as a negative number
-	 * and in units/frame^2
-	 * (NOT positive units/second^2 as in the mapfile)
-	 */
-	float gravity;
-
-	/**
 	 * @brief players
 	 *
 	 * Array of CPlayer pointers, for all the
@@ -343,20 +334,6 @@
 	int activePlayers;
 
 	/**
-	 * @brief sun vector
-	 *
-	 * Holds vector for the direction of the sun
-	 */
-	float3 sunVector;
-
-	/**
-	 * @brief sun vector4
-	 *
-	 * Holds vector for the sun as 4 components
-	 */
-	float sunVector4[4];
-
-	/**
 	 * @brief Player
 	 * @param name name of the player
 	 * @return his playernumber of -1 if not found
@@ -465,7 +442,7 @@
 public:
 	CR_DECLARE(CGlobalUnsyncedStuff);
 	CGlobalUnsyncedStuff(); 		//!&lt; Constructor
-	~CGlobalUnsyncedStuff(); 	//!&lt; Destructor
+	~CGlobalUnsyncedStuff();	 	//!&lt; Destructor
 
 	int usRandInt(); 			//!&lt; Unsynced random int
 	float usRandFloat(); 			//!&lt; Unsynced random float
@@ -609,6 +586,13 @@
 	 * Whether fog (of war) is drawn or not
 	 */
 	bool drawFog;
+	
+	/**
+	 * @brief compressTextures
+	 *
+	 * If set, many (not all) textures will compressed on run-time.
+	*/
+	bool compressTextures;
 
 	/**
 	 * @brief quit automatically?

Modified: branches/gml/rts/System/LoadSaveHandler.cpp
===================================================================
--- branches/gml/rts/System/LoadSaveHandler.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/LoadSaveHandler.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -66,16 +66,20 @@
 
 static void WriteString(std::ostream&amp; s, std::string&amp; str)
 {
-	for (int a=0;a&lt;str.length();a++)
-		s &lt;&lt; str[a];
-	s &lt;&lt; (char)0;
+	char c;
+	for (int a=0;a&lt;str.length();a++) {
+		c = str[a];
+		s.write(&amp;c,sizeof(char));
+	}
+	c = 0;
+	s.write(&amp;c,sizeof(char));
 }
 
 static void ReadString(std::istream&amp; s, std::string&amp; str)
 {
 	char c;
 	do {
-		s &gt;&gt; c;
+		s.read(&amp;c,sizeof(char));
 		if (c) str += c;
 	} while (c != 0);
 }
@@ -126,7 +130,7 @@
 			return;
 		}
 
-		string scriptText;
+		std::string scriptText;
 		if (gameSetup) {
 			scriptText = gameSetup-&gt;gameSetupText;
 		}

Modified: branches/gml/rts/System/Matrix44f.cpp
===================================================================
--- branches/gml/rts/System/Matrix44f.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Matrix44f.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -8,11 +8,6 @@
 CR_REG_METADATA(CMatrix44f, CR_MEMBER(m));
 
 
-/*
-float globalArf=15;
-extern void arfurf();
-extern void TestDenormal(float f);
-*/
 CMatrix44f::CMatrix44f(void)
 {
 	LoadIdentity();
@@ -28,6 +23,15 @@
 }
 
 
+CMatrix44f::CMatrix44f(const CMatrix44f&amp; n)
+{
+	m[0]  = n[0];   m[1]  = n[1];   m[2]  = n[2];   m[3]  = n[3];
+	m[4]  = n[4];   m[5]  = n[5];   m[6]  = n[6];   m[7]  = n[7];
+	m[8]  = n[8];   m[9]  = n[9];   m[10] = n[10];  m[11] = n[11];
+	m[12] = n[12];  m[13] = n[13];  m[14] = n[14];  m[15] = n[15];
+}
+
+
 CMatrix44f::~CMatrix44f(void)
 {
 }
@@ -48,6 +52,7 @@
 
 void CMatrix44f::RotateX(float rad)
 {
+/*
 	const float sr = sin(rad);
 	const float cr = cos(rad);
 
@@ -58,11 +63,31 @@
 	rm[6]  = -sr;
 
 	*this=Mul(rm);
+*/
+	const float sr = sin(rad);
+	const float cr = cos(rad);
+
+	float a=m[4];
+	m[4] = cr*a - sr*m[8];
+	m[8] = sr*a + cr*m[8];
+
+	a=m[5];
+	m[5] = cr*a - sr*m[9];
+	m[9] = sr*a + cr*m[9];
+
+	a=m[6];
+	m[6]  = cr*a - sr*m[10];
+	m[10] = sr*a + cr*m[10];
+
+	a=m[7];
+	m[7]  = cr*a - sr*m[11];
+	m[11] = sr*a + cr*m[11];
 }
 
 
 void CMatrix44f::RotateY(float rad)
 {
+/*
 	const float sr = sin(rad);
 	const float cr = cos(rad);
 
@@ -73,11 +98,31 @@
 	rm[8]  = -sr;
 
 	*this = Mul(rm);
+*/
+	const float sr = sin(rad);
+	const float cr = cos(rad);
+
+	float a=m[0];
+	m[0] =  cr*a + sr*m[8];
+	m[8] = -sr*a + cr*m[8];
+
+	a=m[1];
+	m[1] =  cr*a + sr*m[9];
+	m[9] = -sr*a + cr*m[9];
+
+	a=m[2];
+	m[2]  =  cr*a + sr*m[10];
+	m[10] = -sr*a + cr*m[10];
+
+	a=m[3];
+	m[3]  =  cr*a + sr*m[11];
+	m[11] = -sr*a + cr*m[11];
 }
 
 
 void CMatrix44f::RotateZ(float rad)
 {
+/*
 	const float sr = sin(rad);
 	const float cr = cos(rad);
 
@@ -88,11 +133,31 @@
 	rm[1] = -sr;
 
 	*this = Mul(rm);
+*/
+	const float sr = sin(rad);
+	const float cr = cos(rad);
+
+	float a=m[0];
+	m[0] = cr*a - sr*m[4];
+	m[4] = sr*a + cr*m[4];
+
+	a=m[1];
+	m[1] = cr*a - sr*m[5];
+	m[5] = sr*a + cr*m[5];
+
+	a=m[2];
+	m[2] = cr*a - sr*m[6];
+	m[6] = sr*a + cr*m[6];
+
+	a=m[3];
+	m[3] = cr*a - sr*m[7];
+	m[7] = sr*a + cr*m[7];
 }
 
 
 void CMatrix44f::Translate(float x, float y, float z)
 {
+/*
 	CMatrix44f tm;
 
 	tm[12] = x;
@@ -100,11 +165,18 @@
 	tm[14] = z;
 
 	*this = Mul(tm);
+*/
+
+	m[12] += x*m[0] + y*m[4] + z*m[8];
+	m[13] += x*m[1] + y*m[5] + z*m[9];
+	m[14] += x*m[2] + y*m[6] + z*m[10];
+	m[15] += x*m[3] + y*m[7] + z*m[11];
 }
 
 
 void CMatrix44f::Translate(const float3&amp; pos)
 {
+/*
 	CMatrix44f tm;
 
 	tm[12] = pos.x;
@@ -112,6 +184,15 @@
 	tm[14] = pos.z;
 
 	*this = Mul(tm);
+*/
+
+	const float x=pos.x;
+	const float y=pos.y;
+	const float z=pos.z;
+	m[12] += x*m[0] + y*m[4] + z*m[8];
+	m[13] += x*m[1] + y*m[5] + z*m[9];
+	m[14] += x*m[2] + y*m[6] + z*m[10];
+	m[15] += x*m[3] + y*m[7] + z*m[11];
 }
 
 
@@ -148,24 +229,10 @@
 
 float3 CMatrix44f::Mul(const float3&amp; vect) const
 {
-/*	float3 res;
-
-	for (int x = 0; x &lt; 3; ++x) {
-		res[x] = 0;
-		for (int y = 0; y &lt; 3; ++y) {
-			res[x] += vect[y] * m[x * 4 + y];
-		}
-	}
-
-	return res;
-/*/	const float v0(vect[0]), v1(vect[1]), v2(vect[2]);
-	//return float3(	v0*m[0] + v1*m[1] + v2*m[2] + m[3],
-	//				v0*m[4] + v1*m[5] + v2*m[6] + m[7],
-	//				v0*m[8] + v1*m[9] + v2*m[10] + m[11]);/**/
-
+	const float v0(vect[0]), v1(vect[1]), v2(vect[2]);
 	return float3(	v0*m[0] + v1*m[4] + v2*m[8] + m[12],
-					v0*m[1] + v1*m[5] + v2*m[9] + m[13],
-					v0*m[2] + v1*m[6] + v2*m[10] + m[14]);/**/
+				v0*m[1] + v1*m[5] + v2*m[9] + m[13],
+				v0*m[2] + v1*m[6] + v2*m[10] + m[14]);
 }
 
 
@@ -236,13 +303,8 @@
 // m.Mul(m.Invert()) is identity
 CMatrix44f CMatrix44f::Invert() const
 {
-	CMatrix44f mInv;
+	CMatrix44f mInv(*this);
 
-	// copy m
-	mInv[0] = m[0];  mInv[4] = m[4];  mInv[ 8] = m[ 8];  mInv[12] = m[12];
-	mInv[1] = m[1];  mInv[5] = m[5];  mInv[ 9] = m[ 9];  mInv[13] = m[13];
-	mInv[2] = m[2];  mInv[6] = m[6];  mInv[10] = m[10];  mInv[14] = m[14];
-
 	// transpose the rotation
 	mInv[1] = m[4]; mInv[4] = m[1];
 	mInv[2] = m[8]; mInv[8] = m[2];

Modified: branches/gml/rts/System/Matrix44f.h
===================================================================
--- branches/gml/rts/System/Matrix44f.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Matrix44f.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -10,6 +10,7 @@
 
 	CMatrix44f(void);
 	CMatrix44f(const float3&amp; pos, const float3&amp; x, const float3&amp; y, const float3&amp; z);
+	CMatrix44f(const CMatrix44f&amp; n);
 	~CMatrix44f(void);
 
 	void LoadIdentity();

Modified: branches/gml/rts/System/MouseInput.cpp
===================================================================
--- branches/gml/rts/System/MouseInput.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/MouseInput.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,12 +3,17 @@
 	The code hacks around the mouse input from DirectInput, which SDL uses in fullscreen mode.
 	Instead it installs a window message proc and reads input from WM_MOUSEMOVE.
 	On non-windows, the normal SDL events are used for mouse input
+
+	new:
+	It also workarounds a issue with SDL+windows and hardware cursors (-&gt;it has to block WM_SETCURSOR),
+	so it is used now always even in window mode!
 */
 
 #include &quot;StdAfx.h&quot;
 #include &quot;Platform/Win/win32.h&quot;
 #include &quot;MouseInput.h&quot;
 #include &quot;Game/UI/MouseHandler.h&quot;
+#include &quot;LogOutput.h&quot;
 
 #include &lt;SDL_events.h&gt;
 #include &lt;SDL_syswm.h&gt;
@@ -24,6 +29,7 @@
 //////////////////////////////////////////////////////////////////////
 
 #ifdef WIN32
+
 class CWin32MouseInput : public IMouseInput
 {
 public:
@@ -33,6 +39,7 @@
 	int2 mousepos;
 	bool mousemoved;
 	HWND wnd;
+	HCURSOR hCursor;
 
 	// SDL runs the window in a different thread, hence the indirectness of the mouse pos handling
 	static LRESULT CALLBACK SpringWndProc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam)
@@ -41,10 +48,23 @@
 			inst-&gt;mousepos = int2(LOWORD(lparam),HIWORD(lparam));
 			inst-&gt;mousemoved = true;
 			return FALSE;
+		}else if (msg==WM_SETCURSOR) {
+			if (inst-&gt;hCursor!=NULL) {
+				Uint16 hittest = LOWORD(lparam);
+				if ( hittest == HTCLIENT ) {
+					SetCursor(inst-&gt;hCursor);
+					return TRUE;
+				}
+			}
 		}
 		return CallWindowProc((WNDPROC)inst-&gt;sdl_wndproc, wnd, msg, wparam, lparam);
 	}
 
+	void SetWMMouseCursor(void* wmcursor)
+	{
+		hCursor = (HCURSOR)wmcursor;
+	}
+
 	void InstallWndCallback()
 	{
 		sdl_wndproc = GetWindowLongPtr(wnd, GWLP_WNDPROC);
@@ -55,6 +75,8 @@
 	{
 		inst = this;
 
+		hCursor = NULL;
+
 		mousemoved = false;
 		sdl_wndproc = 0;
 
@@ -65,9 +87,7 @@
 
 		wnd = info.window;
 
-		// In windowed mode, SDL uses straight Win32 API to handle mouse movement, which works ok.
-		if (fullscreen)
-			InstallWndCallback();
+		InstallWndCallback();
 	}
 	~CWin32MouseInput()
 	{
@@ -83,7 +103,7 @@
 	{
 		mousepos = pos;
 		if (fullscreen)
-			SetCursorPos (pos.x, pos.y);
+			SetCursorPos(pos.x, pos.y);
 		else
 			SDL_WarpMouse(pos.x, pos.y);
 	}
@@ -111,12 +131,12 @@
 					mouse-&gt;MousePress (mousepos.x, mousepos.y, 5);
 			}
 			break;}
-		case SDL_MOUSEMOTION: // the normal SDL method works fine in windowed mode 
+		/*case SDL_MOUSEMOTION: // the normal SDL method works fine in windowed mode 
 			if(!fullscreen) {
 				mousepos = int2(event.motion.x, event.motion.y);
 				mouse-&gt;MouseMove(mousepos.x, mousepos.y);
 			}
-			break;
+			break;*/
 		case SDL_MOUSEBUTTONDOWN:
 			if (event.button.button == SDL_BUTTON_WHEELUP)
 				mouse-&gt;MouseWheel(true);

Modified: branches/gml/rts/System/MouseInput.h
===================================================================
--- branches/gml/rts/System/MouseInput.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/MouseInput.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -17,6 +17,8 @@
 	virtual void Update () {}
 
 	virtual void HandleSDLMouseEvent (SDL_Event&amp; event) = 0;
+
+	virtual void SetWMMouseCursor (void* wmcursor) {}
 };
 
 

Modified: branches/gml/rts/System/Net/Connection.h
===================================================================
--- branches/gml/rts/System/Net/Connection.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/Connection.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,6 +9,13 @@
 {
 class RawPacket;
 
+struct NetAddress
+{
+	unsigned host;
+	unsigned short port;
+};
+
+
 /**
 @brief Base class for connecting to various recievers / senders
 */
@@ -41,6 +48,7 @@
 	unsigned GetDataRecieved() const;
 	
 	virtual std::string Statistics() const = 0;
+	virtual NetAddress GetPeerName() const = 0;
 
 protected:
 	unsigned dataSent;

Modified: branches/gml/rts/System/Net/LocalConnection.cpp
===================================================================
--- branches/gml/rts/System/Net/LocalConnection.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/LocalConnection.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -86,6 +86,14 @@
 	return msg;
 }
 
+NetAddress CLocalConnection::GetPeerName() const
+{
+	NetAddress addr;
+	addr.port = 0;
+	addr.host = 0;
+	return addr;
+}
+
 unsigned CLocalConnection::OtherInstance() const
 {
 	if (instance == 0)

Modified: branches/gml/rts/System/Net/LocalConnection.h
===================================================================
--- branches/gml/rts/System/Net/LocalConnection.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/LocalConnection.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -50,6 +50,7 @@
 	virtual bool CheckTimeout() const;
 	
 	virtual std::string Statistics() const;
+	virtual NetAddress GetPeerName() const;
 
 private:
 	typedef std::deque&lt;const RawPacket*&gt; MsgQueue;

Modified: branches/gml/rts/System/Net/Net.cpp
===================================================================
--- branches/gml/rts/System/Net/Net.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/Net.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -125,6 +125,11 @@
 	return connections[number]-&gt;Statistics();
 }
 
+NetAddress CNet::GetConnectedAddress(const unsigned number)
+{
+	return connections[number]-&gt;GetPeerName();
+}
+
 const RawPacket* CNet::Peek(const unsigned conNum, unsigned ahead) const
 {
 	if (int(conNum) &lt;= MaxConnectionID() &amp;&amp; (bool)connections[conNum])
@@ -229,6 +234,11 @@
 	}
 }
 
+void CNet::FlushNet(const unsigned connection)
+{
+	connections[connection]-&gt;Flush(true);
+}
+
 void CNet::Update()
 {
 	if (udplistener)

Modified: branches/gml/rts/System/Net/Net.h
===================================================================
--- branches/gml/rts/System/Net/Net.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/Net.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -11,8 +11,8 @@
 using netcode::RawPacket;
 
 namespace netcode {
-
 class CConnection;
+struct NetAddress;
 class UDPListener;
 
 /**
@@ -130,6 +130,7 @@
 	@return string with statistics
 	 */
 	std::string GetConnectionStatistics(const unsigned number) const;
+	NetAddress GetConnectedAddress(const unsigned number);
 
 	/**
 	@brief Take a look at the messages that will be returned by GetData().
@@ -175,6 +176,7 @@
 	@brief send all waiting data
 	*/
 	void FlushNet();
+	void FlushNet(const unsigned connection);
 	
 	/** 
 	@brief Do this from time to time


Property changes on: branches/gml/rts/System/Net/PackPacket.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/System/Net/PackPacket.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/Net/Socket.cpp
===================================================================
--- branches/gml/rts/System/Net/Socket.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/Socket.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,8 +6,9 @@
 #else
 #include &lt;fcntl.h&gt;
 #include &lt;errno.h&gt;
+#include &lt;arpa/inet.h&gt;
 #include &lt;netdb.h&gt;
-#include &lt;arpa/inet.h&gt;
+#include &lt;netinet/in.h&gt;
 #endif
 
 #include &quot;Exception.h&quot;
@@ -16,7 +17,6 @@
 {
 
 #ifdef _WIN32
-	inline int close(SOCKET mySocket) { return closesocket(mySocket); };
 	unsigned Socket::numSockets = 0;
 #else
 	typedef struct hostent* LPHOSTENT;
@@ -53,9 +53,9 @@
 	++numSockets;
 #endif
 	
-	if (type == UDP)
+	if (type == DATAGRAM)
 		mySocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); // create UDP socket
-	else if (type == TCP)
+	else if (type == STREAM)
 		mySocket = socket(AF_INET, SOCK_STREAM, 0); // create TCP socket
 
 	if (mySocket == INVALID_SOCKET)
@@ -64,14 +64,42 @@
 
 Socket::~Socket()
 {
+#ifndef _WIN32
 	close(mySocket);
-#ifdef _WIN32
+#else
+	closesocket(mySocket);
 	--numSockets;
 	if (numSockets == 0)
 		WSACleanup();
 #endif
 }
 
+void Socket::SetBlocking(const bool block) const
+{
+#ifdef _WIN32
+	u_long u = block ? 0 : 1;
+	if (ioctlsocket(mySocket,FIONBIO,&amp;u) == SOCKET_ERROR)
+#else
+	if (fcntl(mySocket, F_SETFL, block ? 0 : O_NONBLOCK) == -1)
+#endif
+	{
+		throw network_error(std::string(&quot;Error setting socket I/O mode: &quot;) + GetErrorMsg());
+	}
+}
+
+void Socket::Bind(unsigned short port) const
+{
+	sockaddr_in myAddr;
+	myAddr.sin_family = AF_INET;
+	myAddr.sin_addr.s_addr = htonl(INADDR_ANY); // Let the OS assign a address	
+	myAddr.sin_port = htons(port);	   // Use port passed from user
+
+	if (bind(mySocket,(struct sockaddr *)&amp;myAddr,sizeof(struct sockaddr_in)) == SOCKET_ERROR)
+	{
+		throw network_error(std::string(&quot;Error binding socket: &quot;) + GetErrorMsg());
+	}
+}
+
 sockaddr_in Socket::ResolveHost(const std::string&amp; address, const unsigned port) const
 {
 	sockaddr_in remoteAddr;
@@ -101,19 +129,6 @@
 	return remoteAddr;
 }
 
-void Socket::SetBlocking(const bool block) const
-{
-#ifdef _WIN32
-	u_long u = block ? 0 : 1;
-	if (ioctlsocket(mySocket,FIONBIO,&amp;u) == SOCKET_ERROR)
-#else
-	if (fcntl(mySocket, F_SETFL, block ? 0 : O_NONBLOCK) == -1)
-#endif
-	{
-		throw network_error(std::string(&quot;Error setting socket I/O mode: &quot;) + GetErrorMsg());
-	}
-}
-
 std::string Socket::GetErrorMsg() const
 {
 #ifdef _WIN32


Property changes on: branches/gml/rts/System/Net/Socket.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/Net/Socket.h
===================================================================
--- branches/gml/rts/System/Net/Socket.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/Socket.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -13,8 +13,6 @@
 namespace netcode
 {
 
-enum SocketType { TCP, UDP };
-
 /**
 	@author Karl-Robert Ernst &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">k-r.ernst at my-mail.ch</A>&gt;
 	@brief Base class for all Sockets
@@ -22,6 +20,7 @@
 class Socket : public boost::noncopyable
 {
 public:
+	enum SocketType { STREAM, DATAGRAM };
 	/**
 	@brief Create Socket, initialise winsock when needed
 	@param SocketType TCP or UDP?
@@ -34,6 +33,11 @@
 	*/
 	~Socket();
 	
+	/// Set the blocking state of the socket
+	void SetBlocking(const bool block) const;
+	
+	void Bind(unsigned short port /** in host byte order */) const;
+	
 	/**
 	@brief Resolves a host
 	@param address The host's address, can be an IP-Address or an Hostname
@@ -43,9 +47,6 @@
 	sockaddr_in ResolveHost(const std::string&amp; address, const unsigned port) const;
 	
 protected:
-	/// Set the blocking state of the socket
-	void SetBlocking(const bool block) const;
-	
 	/// return the last errormessage from the OS
 	std::string GetErrorMsg() const;
 	/// Check if last error is a real error (not EWOULDBLOCK etc.)


Property changes on: branches/gml/rts/System/Net/Socket.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/Net/UDPConnectedSocket.cpp
===================================================================
--- branches/gml/rts/System/Net/UDPConnectedSocket.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/UDPConnectedSocket.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -6,11 +6,11 @@
 {
 
 #ifndef _WIN32
-	const int SOCKET_ERROR = -1;
+const int SOCKET_ERROR = -1;
 #endif
 
 UDPConnectedSocket::UDPConnectedSocket(const std::string&amp; server, const unsigned remoteport)
-: Socket(UDP)
+: Socket(DATAGRAM)
 {
 	sockaddr_in remoteAddr = ResolveHost(server, remoteport);
 	if (connect(mySocket, (sockaddr*)&amp;remoteAddr, sizeof(remoteAddr)) == SOCKET_ERROR)


Property changes on: branches/gml/rts/System/Net/UDPConnectedSocket.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/System/Net/UDPConnectedSocket.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/Net/UDPConnection.cpp
===================================================================
--- branches/gml/rts/System/Net/UDPConnection.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/UDPConnection.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -9,7 +9,6 @@
 #else
  #include &lt;arpa/inet.h&gt;
  #include &lt;sys/socket.h&gt;
- #include &lt;netdb.h&gt;
 #endif
 
 #include &quot;ProtocolDef.h&quot;
@@ -18,13 +17,6 @@
 namespace netcode {
 
 
-#ifdef _WIN32
-#else
-	typedef struct hostent* LPHOSTENT;
-	typedef struct in_addr* LPIN_ADDR;
-	const int SOCKET_ERROR = -1;
-#endif
-
 const unsigned UDPConnection::hsize = 9;
 
 UDPConnection::UDPConnection(boost::shared_ptr&lt;UDPSocket&gt; NetSocket, const sockaddr_in&amp; MyAddr) : mySocket(NetSocket)
@@ -291,6 +283,14 @@
 	return msg;
 }
 
+NetAddress UDPConnection::GetPeerName() const
+{
+	NetAddress otherAddr;
+	otherAddr.port = ntohs(addr.sin_port);
+	otherAddr.host = ntohl(addr.sin_addr.s_addr);
+	return otherAddr;
+}
+
 bool UDPConnection::CheckAddress(const sockaddr_in&amp; from) const
 {
 	if(

Modified: branches/gml/rts/System/Net/UDPConnection.h
===================================================================
--- branches/gml/rts/System/Net/UDPConnection.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/UDPConnection.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,15 +1,15 @@
 #ifndef _REMOTE_CONNECTION
 #define _REMOTE_CONNECTION
 
-#include &quot;Connection.h&quot;
-#include &quot;UDPSocket.h&quot;
-#include &quot;RawPacket.h&quot;
-
 #include &lt;boost/ptr_container/ptr_deque.hpp&gt;
 #include &lt;boost/ptr_container/ptr_map.hpp&gt;
 #include &lt;boost/shared_ptr.hpp&gt;
 #include &lt;deque&gt;
 
+#include &quot;Connection.h&quot;
+#include &quot;UDPSocket.h&quot;
+#include &quot;RawPacket.h&quot;
+
 namespace netcode {
 
 const unsigned UDPBufferSize = 8192;
@@ -67,6 +67,7 @@
 	virtual bool CheckTimeout() const;
 	
 	virtual std::string Statistics() const;
+	virtual NetAddress GetPeerName() const;
 
 	/// do we have these address?
 	bool CheckAddress(const sockaddr_in&amp;) const;

Modified: branches/gml/rts/System/Net/UDPSocket.cpp
===================================================================
--- branches/gml/rts/System/Net/UDPSocket.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/UDPSocket.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,25 +3,15 @@
 #include &quot;Exception.h&quot;
 
 namespace netcode {
-
-
-#ifdef _WIN32
-	typedef int socklen_t;
+#ifndef _WIN32
+const int SOCKET_ERROR = -1;
 #else
-	const int SOCKET_ERROR = -1;
+typedef int socklen_t;
 #endif
 
-
-UDPSocket::UDPSocket(const int port) : Socket(UDP)
+UDPSocket::UDPSocket(const int port) : Socket(DATAGRAM)
 {
-	myAddr.sin_family = AF_INET;
-	myAddr.sin_addr.s_addr = htonl(INADDR_ANY); // Let the OS assign a address	
-	myAddr.sin_port = htons(port);	   // Use port passed from user
-
-	if (bind(mySocket,(struct sockaddr *)&amp;myAddr,sizeof(struct sockaddr_in)) == SOCKET_ERROR)
-	{
-		throw network_error(std::string(&quot;Error binding socket: &quot;) + GetErrorMsg());
-	}
+	Bind(port);
 	SetBlocking(false);
 }
 

Modified: branches/gml/rts/System/Net/UDPSocket.h
===================================================================
--- branches/gml/rts/System/Net/UDPSocket.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Net/UDPSocket.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,8 +1,6 @@
 #ifndef _UDPSOCKET
 #define _UDPSOCKET
 
-#include &lt;string&gt;
-
 #include &quot;Socket.h&quot;
 
 namespace netcode {
@@ -48,9 +46,6 @@
 	void SendTo(const unsigned char* const buf, const unsigned dataLength, const sockaddr_in* const destination) const;
 	
 protected:
-
-	/// our local address
-	sockaddr_in myAddr;
 };
 
 


Property changes on: branches/gml/rts/System/Net/UnpackPacket.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/System/Net/UnpackPacket.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/Object.cpp
===================================================================
--- branches/gml/rts/System/Object.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Object.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -17,21 +17,12 @@
 	CR_POSTLOAD(PostLoad)
 	));
 
-CObject* CObject::syncedObjects = 0;
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CObject::CObject(EObjectType synced) : prev(NULL), next(NULL)
+CObject::CObject()
 {
-	/*if (synced == OT_Synced)*/ {
-		// Push a synchronized object on front of the list.
-		next = syncedObjects;
-		syncedObjects = this;
-		if (next)
-			next-&gt;prev = this;
-	}
 }
 
 CObject::~CObject()
@@ -44,16 +35,6 @@
 	for(di=listening.begin();di!=listening.end();++di){
 		ListErase&lt;CObject*&gt;((*di)-&gt;listeners, this);
 	}
-
-	// remove from list of synced objects
-	if (IsSynchronized()) {
-		if (prev)
-			prev-&gt;next = next;
-		else
-			syncedObjects = next;
-		if (next)
-			next-&gt;prev = prev;
-	}
 }
 
 void CObject::Serialize(creg::ISerializer *s)

Modified: branches/gml/rts/System/Object.h
===================================================================
--- branches/gml/rts/System/Object.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Object.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -24,26 +24,17 @@
 public:
 	CR_DECLARE(CObject);
 
-	enum EObjectType { OT_Unknown, OT_Unsynced, OT_Synced };
-
-	CObject(EObjectType synced = OT_Unknown);
+	CObject();
 	virtual ~CObject();
 	void Serialize(creg::ISerializer *s);
 	void PostLoad();
-
-	static CObject* GetSyncedObjects() { return syncedObjects; }
-	CObject* GetNext()     const { return next; }
-	CObject* GetPrevious() const { return prev; }
-	bool IsSynchronized()  const { return prev || next; }
 	
 	void DeleteDeathDependence(CObject* o);
 	void AddDeathDependence(CObject* o);
 	virtual void DependentDied(CObject* o);
 
 private:
-	static CObject* syncedObjects;
-	CObject *prev, *next;
-	std::list&lt;CObject*&gt; listeners,listening;
+	std::list&lt;CObject*&gt; listeners, listening;
 };
 
 #endif /* OBJECT_H */

Modified: branches/gml/rts/System/Platform/Linux/OpenALSound.cpp
===================================================================
--- branches/gml/rts/System/Platform/Linux/OpenALSound.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Platform/Linux/OpenALSound.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -14,6 +14,7 @@
 #include &quot;SDL_types.h&quot;
 #include &quot;Platform/byteorder.h&quot;
 #include &quot;OpenALSound.h&quot;
+#include &quot;OggStream.h&quot;
 #include &quot;mmgr.h&quot;
 
 // Ogg-Vorbis audio stream object
@@ -71,7 +72,7 @@
 		alDeleteSources(1,&amp;Sources[i]);
 	}
 	delete[] Sources;
-	map&lt;string, ALuint&gt;::iterator it;
+	std::map&lt;std::string, ALuint&gt;::iterator it;
 	for (it = soundMap.begin(); it != soundMap.end(); ++it) {
 		alDeleteBuffers(1, &amp;it-&gt;second);
 	}
@@ -374,7 +375,7 @@
 }
 
 
-ALuint COpenALSound::LoadALBuffer(const string&amp; path)
+ALuint COpenALSound::LoadALBuffer(const std::string&amp; path)
 {
 	Uint8* buf = 0;
 	ALuint buffer;
@@ -408,9 +409,9 @@
 }
 
 
-ALuint COpenALSound::GetWaveId(const string&amp; path, bool _hardFail)
+ALuint COpenALSound::GetWaveId(const std::string&amp; path, bool _hardFail)
 {
-	map&lt;string, ALuint&gt;::const_iterator it = soundMap.find(path);
+	std::map&lt;std::string, ALuint&gt;::const_iterator it = soundMap.find(path);
 	if (it != soundMap.end()) {
 		return it-&gt;second;
 	}

Modified: branches/gml/rts/System/Platform/Linux/OpenALSound.h
===================================================================
--- branches/gml/rts/System/Platform/Linux/OpenALSound.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Platform/Linux/OpenALSound.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -10,15 +10,11 @@
 #include &lt;AL/alc.h&gt;
 #include &quot;SDL_types.h&quot;
 
-#include &quot;OggStream.h&quot;
 
-
-using namespace std;
-
-class COpenALSound : public CSound
+class COpenALSound: public CSound
 {
 public:
-	ALuint GetWaveId(const string&amp; path, bool hardFail);
+	ALuint GetWaveId(const std::string&amp; path, bool hardFail);
 	void Update();
 	void PlaySample(int id, float volume);
 	void PlaySample(int id, const float3&amp; p, float volume);
@@ -39,7 +35,7 @@
 	bool ReadWAV(const char* name, Uint8* buf, int size, ALuint albuffer);
 
 private:
-	ALuint LoadALBuffer(const string&amp; path);
+	ALuint LoadALBuffer(const std::string&amp; path);
 	void PlaySample(int id, const float3 &amp;p, float volume, bool relative);
 
 	int maxSounds;
@@ -50,7 +46,7 @@
 	void UpdateListener();
 	void Enqueue(ALuint src);
 	
-	map&lt;string, ALuint&gt; soundMap; // filename, index into Buffers
+	std::map&lt;std::string, ALuint&gt; soundMap; // filename, index into Buffers
 	float3 posScale;
 	ALuint* Sources;
 };

Modified: branches/gml/rts/System/Platform/Win/DxSound.cpp
===================================================================
--- branches/gml/rts/System/Platform/Win/DxSound.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Platform/Win/DxSound.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -25,8 +25,8 @@
 
 // Ogg-Vorbis audio stream object
 COggStream oggStream;
+using namespace std;
 
-
 CDxSound::CDxSound()
 {
 	maxSounds = ConfigHandler::GetInstance().GetInt(&quot;MaxSounds&quot;, 16);
@@ -113,7 +113,7 @@
 	}
 	SAFE_RELEASE(m_pDS);
 
-	for (vector&lt;SoundInfo*&gt;::iterator si = loadedSounds.begin(); si != loadedSounds.end(); ++si)
+	for (std::vector&lt;SoundInfo*&gt;::iterator si = loadedSounds.begin(); si != loadedSounds.end(); ++si)
 		delete *si;
 
 	// Release COM
@@ -162,7 +162,7 @@
 {
 	PUSH_CODE_MODE;
 	ENTER_MIXED;
-	map&lt;string, int&gt;::iterator si = waveid.find(name);
+	std::map&lt;string, int&gt;::iterator si = waveid.find(name);
 
 	if (si == waveid.end()) {
 		hardFail = _hardFail;

Modified: branches/gml/rts/System/Platform/Win/DxSound.h
===================================================================
--- branches/gml/rts/System/Platform/Win/DxSound.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Platform/Win/DxSound.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -3,7 +3,9 @@
 
 #include &quot;Sound.h&quot;
 
+#ifndef NOMINMAX
 #define NOMINMAX
+#endif
 
 #ifndef _WINSOCKAPI_
 	#define _WINSOCKAPI_
@@ -23,7 +25,6 @@
 #include &quot;OggStream.h&quot;
 
 class CWorldObject;
-using namespace std;
 
 class CDxSound: public CSound
 {
@@ -31,7 +32,7 @@
 	CDxSound();
 	virtual ~CDxSound();
 	void Update();
-	unsigned int GetWaveId(const string&amp; path, bool hardFail);
+	unsigned int GetWaveId(const std::string&amp; path, bool hardFail);
 	void PlaySample(int id, float volume = 1.0f);
 	void PlaySample(int id, const float3&amp; p, float volume = 1.0f);
 
@@ -52,10 +53,10 @@
 
 protected:
 	int GetBuf(int id, float volume);
-	int InitFile(const string&amp; name);
+	int InitFile(const std::string&amp; name);
 
 	struct SoundInfo {
-		vector&lt;int&gt; freebufs;
+	    std::vector&lt;int&gt; freebufs;
 		int firstBuf;
 	};
 	struct PlayingSound {
@@ -63,16 +64,16 @@
 		float volume;
 	};
 
-	map&lt;string, int&gt; waveid;
-	vector&lt;SoundInfo*&gt; loadedSounds;
-	list&lt;PlayingSound&gt; playingSounds;
-	vector&lt;int&gt; buf2id;
+	std::map&lt;std::string, int&gt; waveid;
+	std::vector&lt;SoundInfo*&gt; loadedSounds;
+	std::list&lt;PlayingSound&gt; playingSounds;
+	std::vector&lt;int&gt; buf2id;
 	float globalVolume;
 
 	std::vector&lt;LPDIRECTSOUNDBUFFER&gt; buffers;
 
 	HRESULT RestoreBuffers(int num);
-	bool CreateStaticBuffer(const string&amp; name);
+	bool CreateStaticBuffer(const std::string&amp; name);
 	HRESULT FillBuffer();
 	bool ReadWAV (const char* name, Uint8* buf, int fileSize, Uint8** soundData, Uint32* bufferSize, WAVEFORMATEX&amp; wf);
 


Property changes on: branches/gml/rts/System/SFloat3.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/Script/LuaBinder.cpp
===================================================================
--- branches/gml/rts/System/Script/LuaBinder.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Script/LuaBinder.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -4,6 +4,7 @@
 #include &quot;float3.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;GlobalStuff.h&quot;
+#include &quot;Game/Team.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitTypes/TransportUnit.h&quot;
 #include &quot;TdfParser.h&quot;
@@ -190,7 +191,8 @@
 			.def_readonly(&quot;frameNum&quot;, &amp;CGlobalSyncedStuff::frameNum)
 			.def_readonly(&quot;mapx&quot;, &amp;CGlobalSyncedStuff::mapx)
 			.def_readonly(&quot;activeTeams&quot;, &amp;CGlobalSyncedStuff::activeTeams)
-			.def_readonly(&quot;mapy&quot;, &amp;CGlobalSyncedStuff::mapy),
+			.def_readonly(&quot;mapy&quot;, &amp;CGlobalSyncedStuff::mapy)
+			.def(&quot;randInt&quot;, &amp;CGlobalSyncedStuff::randInt),
 			
 		class_&lt;SFloat3&gt;(&quot;sfloat3&quot;)
 			.def(constructor&lt;const float, const float, const float&gt;())
@@ -220,6 +222,12 @@
 			.def(&quot;GiveCommand&quot;, &amp;UnitGiveCommand)
 			.def(&quot;ChangeTeam&quot;, &amp;CUnit::ChangeTeam)
 			.def(&quot;IsValid&quot;, &amp;UnitPointerIsValid),
+			
+		class_&lt;CTeam&gt;(&quot;Team&quot;)
+			.def(&quot;setmetalstorage&quot;, &amp;CTeam::SetBaseMetalStorage)
+			.def(&quot;setenergystorage&quot;, &amp;CTeam::SetBaseEnergyStorage)
+			.def_readonly(&quot;metalstorage&quot;, &amp;CTeam::metalStorage)
+			.def_readonly(&quot;energystorage&quot;, &amp;CTeam::energyStorage),
 
 		class_&lt;CFeature, bases&lt;CWorldObject&gt;, CObject_pointer&lt;CFeature&gt; &gt;(&quot;Feature&quot;)
 		    .def_readonly(&quot;id&quot;, &amp;CFeature::id )
@@ -296,6 +304,12 @@
 			def(&quot;GetAt&quot;, &amp;GetFeaturesAt, raw(_1)),
 			def(&quot;Load&quot;, &amp;FeatureLoaderLoadFeature, adopt(result))
 		],
+		
+		namespace_(&quot;game&quot;)
+		[
+			def(&quot;End&quot;, &amp;EndGame),
+			def(&quot;GetTeam&quot;, &amp;GetTeam)
+		],
 
 		namespace_(&quot;map&quot;)
 		[
@@ -303,7 +317,6 @@
 			def(&quot;GetTDFName&quot;, &amp;MapGetTDFName)
 		],
 
-		def(&quot;EndGame&quot;, &amp;EndGame),
 
 		// File access should probably be limited to the virtual filesystem. Disabled for now
 		def(&quot;dofile&quot;, &amp;DisabledFunction),
@@ -327,9 +340,9 @@
 	lastError = &quot;&quot;;
 }
 
-bool CLuaBinder::LoadScript(const string&amp; name)
+bool CLuaBinder::LoadScript(const string&amp; name, char* buffer, int size)
 {
-	if (luaL_loadfile(luaState, name.c_str()) || lua_pcall(luaState, 0, 0, 0)) {
+	if (luaL_loadbuffer(luaState, buffer, size, name.c_str()) || lua_pcall(luaState, 0, 0, 0)) {
 		lastError = lua_tostring(luaState, -1);
 		return false;
 	}

Modified: branches/gml/rts/System/Script/LuaBinder.h
===================================================================
--- branches/gml/rts/System/Script/LuaBinder.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Script/LuaBinder.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,7 +12,7 @@
 public:
 	std::string lastError;
 	CLuaBinder(void);
-	bool LoadScript(const std::string&amp; name);
+	bool LoadScript(const std::string&amp; name, char* buffer, int size);
 	~CLuaBinder(void);
 };
 

Modified: branches/gml/rts/System/Script/LuaFunctions.cpp
===================================================================
--- branches/gml/rts/System/Script/LuaFunctions.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Script/LuaFunctions.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -15,7 +15,7 @@
 #include &quot;Game/StartScripts/Script.h&quot;
 #include &quot;Game/UI/EndGameBox.h&quot;
 #include &quot;Lua/LuaCallInHandler.h&quot;
-#include &quot;Map/ReadMap.h&quot;
+#include &quot;Map/MapInfo.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
@@ -171,9 +171,14 @@
 		if (selectedUnits.selectionChanged)
 			selectedUnits.SendSelection();
 	}
+	
+	CTeam* GetTeam(int num)
+	{
+		return gs-&gt;Team(num);
+	}
 
 	string MapGetTDFName()
 	{
-		return CReadMap::GetTDFName(stupidGlobalMapname);
+		return CMapInfo::GetTDFName(stupidGlobalMapname);
 	}
 }

Modified: branches/gml/rts/System/Script/LuaFunctions.h
===================================================================
--- branches/gml/rts/System/Script/LuaFunctions.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/Script/LuaFunctions.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -43,6 +43,7 @@
 	std::string MapGetTDFName();
 	luabind::object GetSelectedUnits(lua_State* L, int player);
 	void SendSelectedUnits();
+	CTeam* GetTeam(int num);
 };
 
 #endif

Modified: branches/gml/rts/System/SpringApp.cpp
===================================================================
--- branches/gml/rts/System/SpringApp.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/SpringApp.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -12,7 +12,6 @@
 #include &quot;Game/Game.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Game/UI/KeyBindings.h&quot;
-#include &quot;Game/StartScripts/ScriptHandler.h&quot;
 #include &quot;Lua/LuaGaia.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Lua/LuaOpenGL.h&quot;
@@ -50,6 +49,7 @@
 CGameController* activeController = 0;
 bool globalQuit = false;
 Uint8 *keys = 0;
+Uint16 currentUnicode = 0;
 bool fullscreen = true;
 char *win_lpCmdLine = 0;
 
@@ -225,15 +225,19 @@
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 	SDL_GL_SwapBuffers();
 
+	// Runtime compress textures?
+	if (GLEW_ARB_texture_compression) {
+		// we don't even need to check it, 'cos groundtextures must have that extension
+		// default to off because it reduces quality (smallest mipmap level is bigger)
+		gu-&gt;compressTextures = !!configHandler.GetInt(&quot;CompressTextures&quot;, 0);
+	}
+
 	// Initialize named texture handler
 	CNamedTextures::Init();
 
 	// Initialize Lua GL
 	LuaOpenGL::Init();
 
-	// Initialize ScriptHandler / LUA
-	CScriptHandler::Instance().StartLua();
-
 	// Create CGameSetup and CPreGame objects
 	CreateGameSetup ();
 
@@ -255,7 +259,7 @@
 	if (!fsaa)
 		return false;
 	SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS,1);
-	GLuint fsaalevel = max(min(configHandler.GetInt(&quot;FSAALevel&quot;, 2), 8), 0);
+	GLuint fsaalevel = std::max(std::min(configHandler.GetInt(&quot;FSAALevel&quot;, 2), 8), 0);
 
 	make_even_number(fsaalevel);
 
@@ -396,6 +400,12 @@
 		glHint(GL_POINT_SMOOTH_HINT, hint);
 	}
 
+	// setup LOD bias factor
+	const float lodBias = std::max(std::min( configHandler.GetFloat(&quot;TextureLODBias&quot;, 0.0f) , 4.0f), -4.0f);
+	if (fabs(lodBias)&gt;0.01f) {
+		glTexEnvf(GL_TEXTURE_FILTER_CONTROL,GL_TEXTURE_LOD_BIAS, lodBias );
+	}
+
 	// there must be a way to see if this is necessary, compare old/new context pointers?
 	if (!!configHandler.GetInt(&quot;FixAltTab&quot;, 0)) {
 		// free GL resources
@@ -549,6 +559,8 @@
 {
 	cmdline-&gt;addoption('f', &quot;fullscreen&quot;,     OPTPARM_NONE,   &quot;&quot;,  &quot;Run in fullscreen mode&quot;);
 	cmdline-&gt;addoption('w', &quot;window&quot;,         OPTPARM_NONE,   &quot;&quot;,  &quot;Run in windowed mode&quot;);
+	cmdline-&gt;addoption('x', &quot;xresolution&quot;,    OPTPARM_INT,    &quot;&quot;,  &quot;Set X resolution&quot;);
+	cmdline-&gt;addoption('y', &quot;yresolution&quot;,    OPTPARM_INT,    &quot;&quot;,  &quot;Set Y resolution&quot;);
 	cmdline-&gt;addoption('m', &quot;minimise&quot;,       OPTPARM_NONE,   &quot;&quot;,  &quot;Start minimised&quot;);
 	cmdline-&gt;addoption('s', &quot;server&quot;,         OPTPARM_NONE,   &quot;&quot;,  &quot;Run as a server&quot;);
 	cmdline-&gt;addoption('c', &quot;client&quot;,         OPTPARM_NONE,   &quot;&quot;,  &quot;Run as a client&quot;);
@@ -592,8 +604,19 @@
 		configHandler.SetString(&quot;name&quot;, name);
 	}
 
-	screenWidth = configHandler.GetInt(&quot;XResolution&quot;, XRES_DEFAULT);
-	screenHeight = configHandler.GetInt(&quot;YResolution&quot;, YRES_DEFAULT);
+
+	if (!cmdline-&gt;result(&quot;xresolution&quot;, screenWidth)) {
+		screenWidth = configHandler.GetInt(&quot;XResolution&quot;, XRES_DEFAULT);
+	} else {
+		screenWidth = std::max(screenWidth, 1);
+	}
+	
+	if (!cmdline-&gt;result(&quot;yresolution&quot;, screenHeight)) {
+		screenHeight = configHandler.GetInt(&quot;YResolution&quot;, YRES_DEFAULT);
+	} else {
+		screenHeight = std::max(screenHeight, 1);
+	}
+	
 }
 
 /**
@@ -863,6 +886,7 @@
 				}
 				case SDL_KEYDOWN: {
 					int i = event.key.keysym.sym;
+					currentUnicode = event.key.keysym.unicode;
 
 					const bool isRepeat = !!keys[i];
 
@@ -896,7 +920,7 @@
 								} else {
 									if (i &lt; SDLK_DELETE) {
 										const int len = (int)ac-&gt;userInput.length();
-										ac-&gt;writingPos = max(0, min(len, ac-&gt;writingPos));
+										ac-&gt;writingPos = std::max(0, std::min(len, ac-&gt;writingPos));
 										char str[2] = { char(i), 0 };
 										ac-&gt;userInput.insert(ac-&gt;writingPos, str);
 										ac-&gt;writingPos++;
@@ -910,6 +934,7 @@
 				}
 				case SDL_KEYUP: {
 					int i = event.key.keysym.sym;
+					currentUnicode = event.key.keysym.unicode;
 
 					UpdateSDLKeys();
 


Property changes on: branches/gml/rts/System/SpringApp.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/SpringApp.h
===================================================================
--- branches/gml/rts/System/SpringApp.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/SpringApp.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -112,6 +112,13 @@
 extern Uint8 *keys;
 
 /**
+ * @brief currentUnicode
+ *
+ * Unicode character for the current KeyPressed or KeyReleased
+ */
+extern Uint16 currentUnicode;
+
+/**
  * @brief fullscreen
  *
  * Whether or not the game is running in fullscreen


Property changes on: branches/gml/rts/System/SpringApp.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/System/TdfParser.cpp
===================================================================
--- branches/gml/rts/System/TdfParser.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/TdfParser.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -191,20 +191,6 @@
   LoadFile(filename);
 }
 
-//find value, display messagebox if no such value found
-std::string TdfParser::SGetValueMSG(std::string const&amp; location) const
-{
-	std::string lowerd = StringToLower(location);
-	std::string value;
-	bool found = SGetValue(value, lowerd);
-	if(!found)
-	{
-		std::string error = &quot;TDF parsing error: &quot;;
-		error += value;
-		throw content_error(error);
-	}
-	return value;
-}
 
 //find value, return default value if no such value found
 std::string TdfParser::SGetValueDef(std::string const&amp; defaultvalue, std::string const&amp; location) const

Modified: branches/gml/rts/System/TdfParser.h
===================================================================
--- branches/gml/rts/System/TdfParser.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/System/TdfParser.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -51,20 +51,6 @@
 
 
 	/**
-		*  @param value pointer to string to store the value in.
-		*  @param ... location of value, terminate with NULL.
-		*  @return true on success.
-
-	bool GetValue(std::string &amp;value, ...);*/
-
-	/**
-		*  Retreive a specific value from the file and returns it, gives an error messagebox if value not found.
-		*  @param location location of value in the form &quot;section\\section\\ ... \\name&quot;.
-		*  @return returns the value on success, undefined on failure.
-		*/
-	std::string SGetValueMSG(std::string const&amp; location) const;
-
-	/**
 		*  Retreive a specific value from the file and returns it, returns the specified default value if not found.
 		*  @param defaultvalue
 		*  @param location location of value.
@@ -126,18 +112,6 @@
 		}
 	}
 
-	//template funktion f&#246;r att h&#228;ta ett v&#228;rde, ger errormessagebox om v&#228;rdet inte fins
-	template&lt;typename T&gt;
-	void GetMsg(T&amp; value, const std::string&amp; key) const
-	{
-		std::string str;
-		str = SGetValueMSG(key);
-
-		std::stringstream stream;
-		stream &lt;&lt; str;
-		stream &gt;&gt; value;
-	}
-
 	//template funktion f&#246;r att h&#228;ta ett v&#228;rde, tar defaultv&#228;rde om v&#228;rdet inte fins
 	template&lt;typename T&gt;
 	void GetDef(T&amp; value, const std::string&amp; defvalue, const std::string&amp; key) const


Property changes on: branches/gml/rts/System/UnsyncedRNG.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/gml/rts/System/UnsyncedRNG.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/gml/rts/build/scons/config.py
===================================================================
--- branches/gml/rts/build/scons/config.py	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/build/scons/config.py	2008-05-16 01:17:06 UTC (rev 5894)
@@ -301,6 +301,8 @@
 		d += [Dependency(['SDLmain'],  [])]
 	else:
 		d += [Dependency(['openal', 'openal32'], ['AL/al.h'])]
+		d += [Dependency(['Xcursor'], ['X11/Xcursor/Xcursor.h'])]
+		d += [Dependency(['X11'], ['X11/X.h'])]
 
 	d += [Dependency(['vorbisfile'], ['vorbis/vorbisfile.h'])]
 	d += [Dependency(['vorbis'], [])]

Modified: branches/gml/rts/build/scons/rts.py
===================================================================
--- branches/gml/rts/build/scons/rts.py	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/build/scons/rts.py	2008-05-16 01:17:06 UTC (rev 5894)
@@ -282,6 +282,9 @@
 			# to break.
 			# Since those constructs are used in the netcode and MathTest code, we disable the optimization.
 			env.AppendUnique(CCFLAGS=['-O'+level, '-pipe', '-fno-strict-aliasing'])
+			# MinGW 4.2 compiled binaries insta crash with this on...
+			#if int(level) &lt;= 2:
+			#	env.AppendUnique(CCFLAGS=['-finline-functions','-funroll-loops'])
 		elif int(level) == 0:
 			print &quot;optimizing NOT enabled&quot;,
 			env['optimize'] = 0

Modified: branches/gml/rts/build/vstudio8/rts.vcproj
===================================================================
--- branches/gml/rts/build/vstudio8/rts.vcproj	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/build/vstudio8/rts.vcproj	2008-05-16 01:17:06 UTC (rev 5894)
@@ -254,7 +254,7 @@
 			&lt;Tool
 				Name=&quot;VCLinkerTool&quot;
 				AdditionalDependencies=&quot;dsound.lib freetype2110.lib zlibwapi.lib glew32s.lib opengl32.lib glu32.lib ogg.lib vorbis.lib vorbisfile.lib SDL.lib DevIL.lib winmm.lib wsock32.lib ilu.lib imagehlp.lib advapi32.lib ole32.lib&quot;
-				OutputFile=&quot;../../../game/spring.exe&quot;
+				OutputFile=&quot;d:/program files/spring/springdev.exe&quot;
 				LinkIncremental=&quot;1&quot;
 				SuppressStartupBanner=&quot;true&quot;
 				AdditionalLibraryDirectories=&quot;../../../vclibs/DevIL/lib;&quot;../../../vclibs/freetype-2.1.10/objs&quot;;../../../vclibs/OpenAL/libs;../../../vclibs/glew/lib;../../../vclibs/zlibwapi/lib;&quot;../../../vclibs/SDL-1.2.9/lib&quot;;../../../vclibs/boost/lib;../../../vclibs/libjpeg;../../../vclibs/ogg_vorbis/lib&quot;
@@ -951,6 +951,14 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;..\..\Game\UI\HwMouseCursor.cpp&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\Game\UI\HwMouseCursor.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\Game\Ui\InfoConsole.cpp&quot;
 					&gt;
 				&lt;/File&gt;
@@ -1582,86 +1590,6 @@
 					RelativePath=&quot;..\..\Game\Server\MsgStrings.h&quot;
 					&gt;
 				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;..\..\Game\Server\ServerLog.cpp&quot;
-					&gt;
-					&lt;FileConfiguration
-						Name=&quot;Debug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;No debug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;Release with error catching|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;Syncdebug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;..\..\Game\Server\ServerLog.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;..\..\Game\Server\ServerLogHandler.cpp&quot;
-					&gt;
-					&lt;FileConfiguration
-						Name=&quot;Debug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;No debug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;Release with error catching|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;Syncdebug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;..\..\Game\Server\ServerLogHandler.h&quot;
-					&gt;
-				&lt;/File&gt;
 			&lt;/Filter&gt;
 		&lt;/Filter&gt;
 		&lt;Filter
@@ -1871,6 +1799,14 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;..\..\Rendering\Env\BumpWater.cpp&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\Rendering\Env\BumpWater.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\Rendering\Env\DynWater.cpp&quot;
 					&gt;
 				&lt;/File&gt;
@@ -2780,7 +2716,7 @@
 				&lt;/Filter&gt;
 			&lt;/Filter&gt;
 			&lt;Filter
-				Name=&quot;Pathfinding&quot;
+				Name=&quot;Path&quot;
 				&gt;
 				&lt;File
 					RelativePath=&quot;..\..\Sim\Path\IPath.h&quot;
@@ -2967,7 +2903,7 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Sim\Misc\CollisionVolume.cpp&quot;
+					RelativePath=&quot;..\..\Sim\Misc\CollisionHandler.cpp&quot;
 					&gt;
 					&lt;FileConfiguration
 						Name=&quot;Debug|Win32&quot;
@@ -3003,6 +2939,10 @@
 					&lt;/FileConfiguration&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;..\..\Sim\Misc\CollisionHandler.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\Sim\Misc\CollisionVolume.h&quot;
 					&gt;
 				&lt;/File&gt;
@@ -3031,6 +2971,46 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;..\..\Sim\Misc\GroundBlockingObjectMap.cpp&quot;
+					&gt;
+					&lt;FileConfiguration
+						Name=&quot;Debug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;No debug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Release with error catching|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Syncdebug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\Sim\Misc\GroundBlockingObjectMap.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\Sim\Misc\InterceptHandler.cpp&quot;
 					&gt;
 				&lt;/File&gt;
@@ -3681,12 +3661,76 @@
 							UsePrecompiledHeader=&quot;0&quot;
 						/&gt;
 					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;No debug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Release with error catching|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Syncdebug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
 				&lt;/File&gt;
 				&lt;File
 					RelativePath=&quot;..\..\System\FileSystem\CRC.h&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;..\..\System\FileSystem\FileFilter.cpp&quot;
+					&gt;
+					&lt;FileConfiguration
+						Name=&quot;Debug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;No debug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Release with error catching|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Syncdebug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\System\FileSystem\FileFilter.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\System\FileSystem\FileHandler.cpp&quot;
 					&gt;
 				&lt;/File&gt;
@@ -5632,6 +5676,46 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;..\..\Map\HeightLinePalette.cpp&quot;
+				&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;
+					&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;0&quot;
+					/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;No debug|Win32&quot;
+					&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;0&quot;
+					/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release with error catching|Win32&quot;
+					&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;0&quot;
+					/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Syncdebug|Win32&quot;
+					&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;0&quot;
+					/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\..\Map\HeightLinePalette.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;..\..\Map\HeightMapTexture.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -5648,6 +5732,46 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;..\..\Map\MapInfo.cpp&quot;
+				&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;
+					&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;0&quot;
+					/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;No debug|Win32&quot;
+					&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;0&quot;
+					/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release with error catching|Win32&quot;
+					&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;0&quot;
+					/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Syncdebug|Win32&quot;
+					&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;0&quot;
+					/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\..\Map\MapInfo.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;..\..\Map\MetalMap.cpp&quot;
 				&gt;
 			&lt;/File&gt;

Modified: branches/gml/rts/lib/gml/gml.cpp
===================================================================
--- branches/gml/rts/lib/gml/gml.cpp	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/lib/gml/gml.cpp	2008-05-16 01:17:06 UTC (rev 5894)
@@ -36,6 +36,7 @@
 
 #define EXEC_RUN (BYTE *)NULL
 #define EXEC_SYNC (BYTE *)-1
+#define EXEC_RES (BYTE *)-2
 
 // TLS (thread local storage) thread identifier
 __declspec(thread) int gmlThreadNumber=0;
@@ -149,6 +150,7 @@
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENRENDERBUFFERSEXTPROC *__w64&gt; gmlRenderbuffersEXTServer(&amp;glGenRenderbuffersEXT, 2, 0);
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENFRAMEBUFFERSEXTPROC *__w64&gt; gmlFramebuffersEXTServer(&amp;glGenFramebuffersEXT, 2, 0);
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENQUERIESPROC *__w64&gt; gmlQueryServer(&amp;glGenQueries, 20, 5);
+gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSPROC *__w64&gt; gmlBufferServer(&amp;glGenBuffers, 2, 0);
 
 
 // GMLqueue implementation
@@ -210,11 +212,43 @@
 void gmlQueue::ReleaseWrite(BOOL final) {
 	if(Write==NULL)
 		return;
+#if GML_ALTERNATE_SYNCMODE
 	if(Write==Queue1) {
 		if(final) {
 			while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
 				boost::thread::yield();
 		}
+		Pos1=WritePos;
+		Locks1.Unlock();
+		Locked1=FALSE;
+		if(final &amp;&amp; WasSynced) {
+			Sync=WritePos;
+			while(Sync==WritePos)
+				boost::thread::yield();
+			WasSynced=FALSE;
+		}
+	}
+	else {
+		if(final) {
+			while(*(BYTE * volatile *)&amp;Pos1!=Queue1)
+				boost::thread::yield();
+		}
+		Pos2=WritePos;
+		Locks2.Unlock();
+		Locked2=FALSE;
+		if(final &amp;&amp; WasSynced) {
+			Sync=WritePos;
+			while(Sync==WritePos)
+				boost::thread::yield();
+			WasSynced=FALSE;
+		}
+	}
+#else
+	if(Write==Queue1) {
+		if(final) {
+			while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
+				boost::thread::yield();
+		}
 		if(WasSynced) {
 			Sync=WritePos;
 			while(Sync==WritePos)
@@ -240,13 +274,14 @@
 		Locks2.Unlock();
 		Locked2=FALSE;
 	}
+#endif
 	Write=NULL;
 	WritePos=NULL;
 	WriteSize=NULL;
 }
 
 BOOL gmlQueue::GetWrite(BOOL critical) {
-	do {
+	while(1) {
 		if(!Locked1 &amp;&amp; Pos1==Queue1) {
 			if(Locks1.Lock()) {
 				Locked1=TRUE;
@@ -265,9 +300,10 @@
 				return TRUE;
 			}
 		}
+		if(!critical)
+			return FALSE;
 		boost::thread::yield();
-	} while(critical);
-	return FALSE;
+	} 
 }
 
 void gmlQueue::ReleaseRead() {
@@ -287,32 +323,56 @@
 	ReadPos=NULL;
 }
 
-BOOL gmlQueue::GetRead() {
-	if(!Locked1 &amp;&amp; Pos1!=Queue1) {
-		if(Locks1.Lock()) {
-			Locked1=TRUE;
-			Read=Queue1;
-			ReadPos=Pos1;
-			return TRUE;
+BOOL gmlQueue::GetRead(BOOL critical) {
+	while(1) {
+		if(!Locked1 &amp;&amp; Pos1!=Queue1) {
+			if(Locks1.Lock()) {
+				Locked1=TRUE;
+				Read=Queue1;
+				ReadPos=Pos1;
+				return TRUE;
+			}
 		}
-	}
-	if(!Locked2 &amp;&amp; Pos2!=Queue2) {
-		if(Locks2.Lock()) {
-			Locked2=TRUE;
-			Read=Queue2;
-			ReadPos=Pos2;
-			return TRUE;
+		if(!Locked2 &amp;&amp; Pos2!=Queue2) {
+			if(Locks2.Lock()) {
+				Locked2=TRUE;
+				Read=Queue2;
+				ReadPos=Pos2;
+				return TRUE;
+			}
 		}
+		if(!critical)
+			return FALSE;
+		boost::thread::yield();
 	}
-	return FALSE;
 }
 
 
 void gmlQueue::SyncRequest() {
+#if GML_ALTERNATE_SYNCMODE
+        // make sure server is finished with other queue
 	if(Write==Queue1) {
 		while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
 			boost::thread::yield();
 	}
+	else {
+		while(*(BYTE * volatile *)&amp;Pos1!=Queue1)
+			boost::thread::yield();
+	}
+
+	WasSynced=TRUE;
+	Sync=EXEC_SYNC;
+	while(Sync==EXEC_SYNC) // wait for syncmode confirmation before release
+		boost::thread::yield();
+	GetWrite(TRUE); // get new queue so server can get the old one
+	while(Sync!=EXEC_RES) // waiting for result
+		boost::thread::yield();
+	Sync=EXEC_RUN; // server may proceed (avoid entering sync again)
+#else
+	if(Write==Queue1) {
+		while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
+			boost::thread::yield();
+	}
 	if(Write==Queue2) {
 		while(*(BYTE * volatile *)&amp;Pos1!=Queue1)
 			boost::thread::yield();
@@ -323,6 +383,7 @@
 	Sync=EXEC_SYNC;
 	while(Sync==EXEC_SYNC)
 		boost::thread::yield();
+#endif
 }
 
 
@@ -738,6 +799,15 @@
 				GML_MAKEHANDLER4(BlendFuncSeparate)
 				GML_MAKEHANDLER6(uCylinder)
 
+				GML_MAKEHANDLER2V(DeleteBuffers)
+				GML_MAKEHANDLER2(BindBuffer)
+				GML_MAKEHANDLER4VS(BufferData)
+				GML_MAKEHANDLER2R(MapBuffer)
+				GML_MAKEHANDLER1R(UnmapBuffer)
+				GML_MAKEHANDLER8V(CompressedTexImage2D)
+				GML_MAKEHANDLER1R(IsShader)
+				GML_MAKEHANDLER3(Vertex3i)
+
 				GML_MAKEHANDLER2(GetIntegerv)
 				GML_MAKEHANDLER1R(CheckFramebufferStatusEXT)
 				GML_MAKEHANDLER2(GetFloatv)
@@ -771,15 +841,15 @@
 // Execute - executes all GL commands in the current read queue.
 // Execution is non-synced
 void gmlQueue::Execute() {
+//	int procs=0;
   BYTE *p=Read;
   BYTE *e=ReadPos;
   BYTE *ptr=NULL;
-	int procs=0;
 
   while(p&lt;e) {
 //   	GML_DEBUG(&quot;Cmd &quot;,*(int *)p);
     QueueHandler(p,ptr);
-		++procs;
+//		++procs;
 	}
 //	GML_DEBUG(&quot;Execute &quot;,procs);
 }
@@ -790,12 +860,39 @@
 // Execution is synced (this means it will stop at certain points
 // to return values to the worker thread)
 void gmlQueue::ExecuteSynced() {
+//int procs=0;
+#if GML_ALTERNATE_SYNCMODE
+	BYTE *s;
+	while(1) {
+		while((s=(BYTE *)Sync)==EXEC_RUN) {
+			if(Reloc)
+				Realloc();
+			gmlUpdateServers();
+			boost::thread::yield();
+		}
+
+		if(s!=EXEC_SYNC) { // end addr
+			GetRead(TRUE);
+			Sync=EXEC_RUN; // cannot allow worker to continue before right queue acquired
+			Execute();
+			ReleaseRead();
+			break;
+		}
+
+		Sync=EXEC_RUN; // sync confirmed
+		GetRead(TRUE);
+		Execute();
+		Sync=EXEC_RES; // result available
+		ReleaseRead();
+		while(Sync==EXEC_RES) // waiting for worker to acquire result
+			boost::thread::yield();
+	}
+#else
   BYTE *p=Write;
   BYTE *e=WritePos;
   BYTE *ptr=NULL;
 	BOOL isq1=Write==Queue1;
 	BOOL end=FALSE;
-	int procs=0;
   int updserv=0;
 
   while(TRUE) {
@@ -826,9 +923,8 @@
 		}
 //   	GML_DEBUG(&quot;CmdSync &quot;,*(int *)p);
 		QueueHandler(p,ptr);
-		++procs;
+//		++procs;
 	}
-//  GML_DEBUG(&quot;ExecuteSync &quot;,procs);
 	if(isq1) {
 		while(Locked1)
 			boost::thread::yield();
@@ -839,4 +935,6 @@
 			boost::thread::yield();
 		Pos2=Queue2;
 	}
+#endif
+//  GML_DEBUG(&quot;ExecuteSync &quot;,procs);
 }

Modified: branches/gml/rts/lib/gml/gml.h
===================================================================
--- branches/gml/rts/lib/gml/gml.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/lib/gml/gml.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -69,6 +69,7 @@
 extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENRENDERBUFFERSEXTPROC *__w64&gt; gmlRenderbuffersEXTServer;
 extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENFRAMEBUFFERSEXTPROC *__w64&gt; gmlFramebuffersEXTServer;
 extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENQUERIESPROC *__w64&gt; gmlQueryServer;
+extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSPROC *__w64&gt; gmlBufferServer;
 
 EXTERN inline void gmlGenTextures(GLsizei n, GLuint *items) {
 	gmlTextureServer.GetItems(n, items);
@@ -91,6 +92,9 @@
 EXTERN inline void gmlGenQueries(GLsizei n, GLuint *items) {
 	gmlQueryServer.GetItems(n, items);
 }
+EXTERN inline void gmlGenBuffers(GLsizei n, GLuint *items) {
+	gmlBufferServer.GetItems(n, items);
+}
 
 
 
@@ -116,6 +120,7 @@
 	gmlRenderbuffersEXTServer.GenerateItems();
 	gmlFramebuffersEXTServer.GenerateItems();
 	gmlQueryServer.GenerateItems();
+	gmlBufferServer.GenerateItems();
 
 	gmlListServer.GenerateItems();
 }

Modified: branches/gml/rts/lib/gml/gmlcls.h
===================================================================
--- branches/gml/rts/lib/gml/gmlcls.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/lib/gml/gmlcls.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -18,6 +18,9 @@
 #define GML_ENABLE_SIM (GML_ENABLE &amp;&amp; 1) // runs the sim in a separate thread
 #define GML_ENABLE_DRAWALL (GML_ENABLE &amp;&amp; 0) // draws everything in a separate thread (for testing only, will degrade performance)
 #define GML_ENABLE_DRAWUNIT (GML_ENABLE &amp;&amp; 1) // draws units using multithreading
+#define GML_ENABLE_DRAWUNITSHADOW (GML_ENABLE &amp;&amp; 1) // draws unit shadows using multithreading
+#define GML_ENABLE_DRAWGROUND (GML_ENABLE &amp;&amp; 1) // draws ground using multithreading
+#define GML_ENABLE_DRAWGROUNDSHADOW (GML_ENABLE &amp;&amp; 1) // draws ground shadows using multithreading
 #define GML_SERVER_GLCALL 1 // allow the server thread (0) to make direct GL calls
 #define GML_INIT_QUEUE_SIZE 10 // initial queue size, will be reallocated, but must be &gt;= 1
 #define GML_USE_NO_ERROR 1 // glGetError always returns success (to improve performance)
@@ -26,7 +29,32 @@
 //#define GML_USE_QUADRIC_SERVER 1 // use server thread to create/delete quadrics
 #define GML_UPDSRV_INTERVAL 10
 #define GML_EXPERIMENTAL 0
+#define GML_ALTERNATE_SYNCMODE 1 // mutex-protected synced execution, slower but more portable
 
+#ifdef _MSC_VER
+#define GML_ORDERED_VOLATILE (_MSC_VER &gt;= 1400) 
+#else
+#define GML_ORDERED_VOLATILE 0
+#endif
+// optimize by assuming volatile accesses are
+// guaranteed not to be reordered (MSVS 2005 ONLY)
+// <A HREF="http://msdn.microsoft.com/en-us/library/12a04hfd(VS.80">http://msdn.microsoft.com/en-us/library/12a04hfd(VS.80</A>).aspx
+// <A HREF="http://msdn.microsoft.com/en-us/library/ms686355(VS.85">http://msdn.microsoft.com/en-us/library/ms686355(VS.85</A>).aspx
+// <A HREF="http://msdn.microsoft.com/en-us/library/bb310595(VS.85">http://msdn.microsoft.com/en-us/library/bb310595(VS.85</A>).aspx
+
+#if GML_ORDERED_VOLATILE
+#define GML_VOLATILE(x) *(x volatile *)&amp;
+#define GML_MUTEX
+#define GML_MUTEX_LOCK()
+#define GML_MUTEX_UNLOCK()
+#else
+#define GML_VOLATILE(x)
+#define GML_MUTEX gmlMutex mutex
+#define GML_MUTEX_LOCK() mutex.Lock()
+#define GML_MUTEX_UNLOCK() mutex.Unlock()
+#endif
+
+extern __declspec(thread) int gmlThreadNumber;
 extern int gmlThreadCount;
 extern int gmlThreadCountOverride;
 extern unsigned gmlCPUCount();
@@ -42,24 +70,41 @@
 #define EXTERN
 
 #define GML_ERROR(str,val)\
-FILE *f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
-if(f) {\
-	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
-	fclose(f);\
-}\
+  FILE *f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
+  if(f) {\
+    fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+    fclose(f);\
+  }\
 Sleep(1000);
 
 #define GML_DEBUG(str,val)\
-FILE *f=fopen(&quot;C:\\GMLDBG.TXT&quot;,&quot;a&quot;);\
-if(f) {\
-	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
-	fclose(f);\
-}
+  FILE *f=fopen(&quot;C:\\GMLDBG.TXT&quot;,&quot;a&quot;);\
+  if(f) {\
+    fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+    fclose(f);\
+  }
 
+// gmlMutex - exploits the boost mutex to get direct access to the Lock/Unlock methods
+class gmlMutex {
+  boost::mutex sl_mutex;
+  BYTE sl_lock[sizeof(boost::mutex::scoped_lock)*GML_MAX_NUM_THREADS];
+public:
+  gmlMutex() {
+  }
+  virtual ~gmlMutex() {
+  }
+  void Lock() {
+    new (((boost::mutex::scoped_lock *)sl_lock)+gmlThreadNumber) boost::mutex::scoped_lock(sl_mutex);
+  }
+  void Unlock() {
+    (((boost::mutex::scoped_lock *)sl_lock)+gmlThreadNumber)-&gt;~scoped_lock();
+  }
+};
 
+// this hack will assign the counter of a boost atomic_count object
 inline void operator%=(boost::detail::atomic_count&amp; a, long val) {
 #ifdef BOOST_AC_USE_PTHREADS
-	a.~boost::detail::atomic_count();
+  a.~boost::detail::atomic_count();
 #endif
   new (&amp;a) boost::detail::atomic_count(val);
 }
@@ -68,275 +113,376 @@
 
 template&lt;class T&gt;
 struct gmlVectorIter {
-	T *p; 
-	gmlVectorIter() {} 
-	gmlVectorIter(T *d) {p=d;} 
-	void operator=(const typename gmlVectorIter&lt;T&gt; &amp;i) {p=i.p;}
-	typename gmlVectorIter&lt;T&gt; &amp;operator++() {++p; return *this;} 
-	typename gmlVectorIter&lt;T&gt; operator++(int) {return typename gmlVectorIter&lt;T&gt;(p++);} 
-	int operator!=(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p!=i.p;}
-
-	int operator-(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p-i.p;}
-	int operator&lt;(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p&lt;i.p;}
-	typename gmlVectorIter&lt;T&gt; &amp;operator--() {--p; return *this;} 
-	typename gmlVectorIter&lt;T&gt; operator--(int) {return typename gmlVectorIter&lt;T&gt;(p--);} 
-//	typename gmlVectorIter&lt;T&gt; operator-(const typename gmlVectorIter&lt;T&gt; &amp;i) {return typename gmlVectorIter&lt;T&gt;(p-i.p);}
-	typename gmlVectorIter&lt;T&gt; operator+(int i) const {return typename gmlVectorIter&lt;T&gt;(p+i);}
-	typename gmlVectorIter&lt;T&gt; operator-(int i) const {return typename gmlVectorIter&lt;T&gt;(p-i);}
-	int operator==(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p==i.p;}
-	T &amp;operator*() {return *p;}
-
-	typedef std::random_access_iterator_tag iterator_category;
-	typedef T                          value_type;
-	typedef int/*ptrdiff_t*/                  difference_type;
-	typedef T*                         pointer;
-	typedef T&amp;                         reference;
+  T *p; 
+  gmlVectorIter() {} 
+  gmlVectorIter(T *d) {p=d;} 
+  void operator=(const typename gmlVectorIter&lt;T&gt; &amp;i) {p=i.p;}
+  typename gmlVectorIter&lt;T&gt; &amp;operator++() {++p; return *this;} 
+  typename gmlVectorIter&lt;T&gt; operator++(int) {return typename gmlVectorIter&lt;T&gt;(p++);} 
+  int operator!=(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p!=i.p;}
+  
+  ptrdiff_t operator-(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p-i.p;}
+  int operator&lt;(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p&lt;i.p;}
+  typename gmlVectorIter&lt;T&gt; &amp;operator--() {--p; return *this;} 
+  typename gmlVectorIter&lt;T&gt; operator--(int) {return typename gmlVectorIter&lt;T&gt;(p--);} 
+  typename gmlVectorIter&lt;T&gt; operator+(int i) const {return typename gmlVectorIter&lt;T&gt;(p+i);}
+  typename gmlVectorIter&lt;T&gt; operator-(int i) const {return typename gmlVectorIter&lt;T&gt;(p-i);}
+  int operator==(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p==i.p;}
+  T &amp;operator*() {return *p;}
+  
+  typedef std::random_access_iterator_tag iterator_category;
+  typedef T value_type;
+  typedef ptrdiff_t difference_type;
+  typedef T* pointer;
+  typedef T&amp; reference;
 };
 
-
+// gmlClassVector - partially thread safe vector class for storing advanced types (classes etc.)
+// The array will be resized automatically when using the functions acquire() and release()
+// using &quot;volatile&quot; optimizations result in about 300% performance gain under normal load
+// high load will make &quot;volatile&quot; optimizations run about 3 times slower compared to mutex
 template&lt;class T&gt;
 class gmlClassVector {
-	T *data;
-	boost::detail::atomic_count count;
-	boost::detail::atomic_count added;
-	int maxsize;
-	int doshrink;
-	int shrinksize;
-	int nalloc;
-
+  T *data;
+#if GML_ORDERED_VOLATILE
+  boost::detail::atomic_count count;
+  volatile long added;
+#else
+  gmlMutex mutex;
+  long added;
+#endif
+  int maxsize;
+  int doshrink;
+  int shrinksize;
+  int nalloc;
+  
 public:
-	gmlClassVector():doshrink(0),shrinksize(0),nalloc(0),count(0),added(0) {
-		data=(T *)malloc(1*sizeof(T));
-		*(volatile int *)&amp;maxsize=1;
-	}
+  gmlClassVector():doshrink(0),shrinksize(0),nalloc(0),
+#if GML_ORDERED_VOLATILE
+    count(0),
+#endif
+    added(0) {
+    data=(T *)malloc(1*sizeof(T));
+    maxsize=1;
+  }
+  
+  ~gmlClassVector() {
+    if(added&gt;nalloc)
+      nalloc=added;
+    for(int i=0; i&lt;nalloc; ++i)
+      data[i].~T();
+    free(data);
+  }
+  
+  typedef typename gmlVectorIter&lt;T&gt; iterator;
+  
+  iterator begin() {
+    return iterator(data);
+  }
+  
+  iterator end() {
+    return iterator(data+added);
+  }
+  
+  long size() const {
+    return added;
+  }
+  
+  const T &amp;operator[](int i) const {
+    return data[i];
+  }
+  
+  T &amp;operator[](int i) {
+    return data[i];
+  }
+  
+  T &amp;acquire(int i) { // thread safe
+#if GML_ORDERED_VOLATILE
+    long sz;
+    while(TRUE) {
+      if(added&lt;=i) {
+        if(count&lt;=i) {
+          if((sz=++count)&lt;=i+1) {
+            if(added==sz-1) {
+							T *da=GML_VOLATILE(T *) data;
+							int ms;
+							if(sz==(ms=GML_VOLATILE(int) maxsize))
+								Expand(da,ms);
+              new (da+sz-1) T();
+              ++added;
+            }
+            else {
+              --count;
+              while(count!=added)
+                boost::thread::yield();
+            }
+          }
+          else {
+            --count;
+          }
+        }
+      }
+      else {
+        long sz=++count;
+        if(added==sz-1) {
+          return (GML_VOLATILE(T *)data)[i];
+        }
+        --count;
+        while(count!=added)
+          boost::thread::yield();
+      }
+    }
+#else
+    mutex.Lock();
+    while(added&lt;=i) {
+      long sz=++added;
+      if(sz==maxsize)
+        Expand(data,maxsize);
+      new (data+sz-1) T();
+    }
+    return data[i];
+#endif
+  }
+  
+  void release() { // thread safe
+#if GML_ORDERED_VOLATILE
+    --count;
+#else
+    mutex.Unlock();
+#endif
+  }
+  
+  void push_back(const T &amp;d) { // thread safe
+#if GML_ORDERED_VOLATILE
+    while(TRUE) {
+      long sz=++count;
+      if(added==sz-1) {
+        T *da=GML_VOLATILE(T *) data;
+				int ms;
+        if(sz==(ms=GML_VOLATILE(int) maxsize))
+          Expand(da,ms);
+        new (da+sz-1) T(d);
+        ++added;
+        return;
+      }
+      else {
+        --count;
+        while(count!=added)
+          boost::thread::yield();
+      }
+    }
+#else
+    mutex.Lock();
+    long sz=++added;
+    if(sz==maxsize)
+      Expand(data,maxsize);
+    new (data+sz-1) T(d);
+    mutex.Unlock();
+#endif
+  }
+  
+  // this is probably overkill since realloced memory will never be cached in registers anyway
+  BYTE *volatile_realloc(BYTE *dt, const int osz, const int sz) {
+#if GML_ORDERED_VOLATILE 
+    BYTE *dtn=(BYTE *)malloc(sz);
+    for(int i=0; i&lt;osz; ++i)
+      *(volatile BYTE *)dtn++=*(volatile BYTE *)dt++;
+    free(dt-osz);
+    return dtn-osz;
+#else
+    return (BYTE *)realloc(dt,sz);
+#endif
+  }
 
-	~gmlClassVector() {
-		if(added&gt;nalloc)
-			nalloc=added;
-		for(int i=0; i&lt;nalloc; ++i)
-			data[i].~T();
-		free(data);
-	}
-
-	typedef typename gmlVectorIter&lt;T&gt; iterator;
-
-	iterator begin() {
-		return iterator(data);
-	}
-
-	iterator end() {
-		return iterator(data+added);
-	}
-
-	long size() const {
-		return added;
-	}
-
-	const T &amp;operator[](int i) const {
-		return data[i];
-	}
-
-	T &amp;operator[](int i) {
-		int sz;
-		while(TRUE) {
-			if(added&lt;=i) {
-				if(count&lt;=i) {
-					if((sz=++count)&lt;=i+1) {
-						if(added==sz-1) {
-							while(sz&gt;*(volatile int *)&amp;maxsize)
-								;
-							if(sz==maxsize)
-								Expand();
-							else
-								while(*(volatile int *)&amp;maxsize&lt;sz)
-									;
-							new (data+sz-1) T();
-          		++added;
-						}
-						else {
-							--count;
-							while(count!=added)
-								boost::thread::yield();
-						}
-					}
-					else {
-						--count;
-					}
-				}
-			}
-			else {
-				return data[i];
-			}
-		}
-	}
-
-	void push_back(T &amp;d) {
-		while(TRUE) {
-			int sz=++count;
-			if(added==sz-1) {
-				while(sz&gt;*(volatile int *)&amp;maxsize)
-					;
-				if(sz==maxsize)
-					Expand();
-				else
-					while(*(volatile int *)&amp;maxsize&lt;sz)
-						;
-				data[sz-1]=d;
-				++added;
-				return;
-			}
-			else {
-				--count;
-				while(count!=added)
-					boost::thread::yield();
-			}
-		}
-	}
-
-	void Expand() {
-		while(added&lt;maxsize-1)
-			;
-		shrinksize=maxsize;
-		int ms2=maxsize&lt;&lt;1;
-		data=(T *)realloc(data,ms2*sizeof(T));
-		*(volatile int *)&amp;maxsize=ms2; // dont reorder
-	}
-
-	void Shrink() {
-		int ms=maxsize&gt;&gt;1;
-		shrinksize=ms&gt;&gt;1;
-		doshrink=0;
-		for(int i=ms; i&lt;nalloc; ++i)
-			data[i].~T();
-		if(ms&lt;nalloc)
-			nalloc=ms;
-		data=(T *)realloc(data,ms*sizeof(T));
-		*(volatile int *)&amp;maxsize=ms;
-	}
-
-	void clear() { // not thread safe
-		if(added&gt;nalloc)
-			nalloc=added;
-		int sz=count;
-		count%=0;
-		added%=0;
-		if(sz&gt;=shrinksize)
-			doshrink=0;
-		else if(++doshrink&gt;=10)
- 			Shrink();
-	}
+  void Expand(T *&amp;da, const int ms) {
+    shrinksize=ms;
+    int ms2=ms&lt;&lt;1;
+    da=(T *)volatile_realloc((BYTE *)da,ms*sizeof(T),ms2*sizeof(T));
+    GML_VOLATILE(T *) data=da; 
+    GML_VOLATILE(int) maxsize=ms2;
+  }
+  
+  void Shrink() {
+    int ms=shrinksize;
+    shrinksize=ms&gt;&gt;1;
+    doshrink=0;
+    for(int i=ms; i&lt;nalloc; ++i)
+      data[i].~T();
+    if(ms&lt;nalloc)
+      nalloc=ms;
+    data=(T *)realloc(data,ms*sizeof(T));
+    maxsize=ms;
+  }
+  
+  void clear() {
+    if(added&gt;nalloc)
+      nalloc=added;
+    long sz=added;
+#if GML_ORDERED_VOLATILE
+    count%=0;
+#endif
+    added=0;
+    if(sz&gt;=shrinksize)
+      doshrink=0;
+    else if(++doshrink&gt;=10)
+      Shrink();
+  }
 };
 
+// gmlVector - partially thread safe vector class for storing simple types (int, pointer etc)
+// using &quot;volatile&quot; optimizations result in about 300% performance gain under normal load
+// high load will make &quot;volatile&quot; optimizations run about 3 times slower compared to mutex
 template&lt;class T&gt;
 class gmlVector {
-	T *data;
-	boost::detail::atomic_count count;
-	boost::detail::atomic_count added;
-	int maxsize;
-	int doshrink;
-	int shrinksize;
-
+  T *data;
+#if GML_ORDERED_VOLATILE
+  boost::detail::atomic_count count;
+  volatile long added;
+#else
+  gmlMutex mutex;
+  long added;
+#endif
+  int maxsize;
+  int doshrink;
+  int shrinksize;
+  
 public:
-	gmlVector():doshrink(0),shrinksize(0),count(0),added(0) {
-		data=(T *)malloc(1*sizeof(T));
-		*(volatile int *)&amp;maxsize=1;
-	}
-	gmlVector&lt;T&gt; &amp;operator=(const typename gmlVector&lt;T&gt; &amp;vec) {
-		free(data);
-		memcpy(this,&amp;vec,sizeof(typename gmlVector&lt;T&gt;));
-		data=(T *)malloc(vec.maxsize*sizeof(T));
-		memcpy(data,vec.data,vec.maxsize*sizeof(T));
-		return *this;
-	}
-
-	~gmlVector() {
-		free(data);
-	}
-
-	typedef typename gmlVectorIter&lt;T&gt; iterator;
-
-	iterator begin() {
-		return iterator(data);
-	}
-
-	iterator end() {
-		return iterator(data+added);
-	}
-
-	long size() const {
-		return added;
-	}
-
-	const T &amp;operator[](int i) const {
-		return data[i];
-	}
-
-	T &amp;operator[](int i) {
-		return data[i];
-	}
-
-	void push_back(T &amp;d) { // thread safe
-    int sz=++count;
-  	while(sz&gt;*(volatile int *)&amp;maxsize)
-			;
-		if(sz==maxsize)
-			Expand();
-		else
-  		while(*(volatile int *)&amp;maxsize&lt;sz)
-				;
-		data[sz-1]=d;
-		++added;
-	}
-
-	void Expand() {
-		while(added&lt;maxsize-1)
-			;
-		shrinksize=maxsize;
-		int ms2=maxsize&lt;&lt;1;
-		data=(T *)realloc(data,ms2*sizeof(T));
-		*(volatile int *)&amp;maxsize=ms2; // dont reorder
-	}
-
-	void Shrink() {
-		int ms=maxsize&gt;&gt;1;
-		shrinksize=ms&gt;&gt;1;
-		doshrink=0;
-		data=(T *)realloc(data,ms*sizeof(T));
-		*(volatile int *)&amp;maxsize=ms;
-	}
-
-	void clear() { // not thread safe
-		int sz=count;
-		count%=0;
-		added%=0;
-		if(sz&gt;=shrinksize)
-			doshrink=0;
-		else if(++doshrink&gt;=10)
- 			Shrink();
-	}
+  gmlVector():doshrink(0),shrinksize(0),
+#if GML_ORDERED_VOLATILE
+    count(0),
+#endif
+    added(0) {
+    data=(T *)malloc(1*sizeof(T));
+    maxsize=1;
+  }
+  gmlVector(const typename gmlVector&lt;T&gt; &amp;vec):
+#if GML_ORDERED_VOLATILE
+    count(0),
+#endif
+    added(0) {
+    memcpy(this,&amp;vec,sizeof(typename gmlVector&lt;T&gt;));
+    data=(T *)malloc(vec.maxsize*sizeof(T));
+    memcpy(data,vec.data,vec.maxsize*sizeof(T));
+  }
+  
+  gmlVector&lt;T&gt; &amp;operator=(const typename gmlVector&lt;T&gt; &amp;vec) {
+    free(data);
+    memcpy(this,&amp;vec,sizeof(typename gmlVector&lt;T&gt;));
+    data=(T *)malloc(vec.maxsize*sizeof(T));
+    memcpy(data,vec.data,vec.maxsize*sizeof(T));
+    return *this;
+  }
+  
+  ~gmlVector() {
+    free(data);
+  }
+  
+  typedef typename gmlVectorIter&lt;T&gt; iterator;
+  
+  iterator begin() const {
+    return iterator(data);
+  }
+  
+  iterator end() const {
+    return iterator(data+added);
+  }
+  
+  const long size() const {
+    return added;
+  }
+  
+  const T &amp;operator[](const int i) const {
+    return data[i];
+  }
+  
+  T &amp;operator[](const int i) {
+    return data[i];
+  }
+  
+  void push_back(const T &amp;d) { // thread safe
+#if GML_ORDERED_VOLATILE
+    long sz=++count;
+    while(added!=sz-1)
+      boost::thread::yield();
+    T *da=GML_VOLATILE(T *) data;
+		int ms;
+    if(sz==(ms=GML_VOLATILE(int) maxsize))
+      Expand(da,ms);
+    *(volatile T *)(da+sz-1)=d;
+    ++added;
+#else
+    mutex.Lock();
+    long sz=++added;
+    if(sz==maxsize)
+      Expand(data,maxsize);
+    data[sz-1]=d;
+    mutex.Unlock();
+#endif
+  }
+  
+  // this is probably overkill since realloced memory will never be cached in registers anyway
+  BYTE *volatile_realloc(BYTE *dt, const int osz, const int sz) {
+#if GML_ORDERED_VOLATILE 
+    BYTE *dtn=(BYTE *)malloc(sz);
+    for(int i=0; i&lt;osz; ++i)
+      *(volatile BYTE *)dtn++=*(volatile BYTE *)dt++;
+    free(dt-osz);
+    return dtn-osz;
+#else
+    return (BYTE *)realloc(dt,sz);
+#endif
+  }
+  
+  void Expand(T *&amp;da, const int ms) {
+    shrinksize=ms;
+    int ms2=ms&lt;&lt;1;
+    da=(T *)volatile_realloc((BYTE *)da,ms*sizeof(T),ms2*sizeof(T));
+    GML_VOLATILE(T *) data=da; 
+    GML_VOLATILE(int) maxsize=ms2;
+  }
+  
+  void Shrink() {
+    int ms=shrinksize;
+    shrinksize=ms&gt;&gt;1;
+    doshrink=0;
+    data=(T *)realloc(data,ms*sizeof(T));
+    maxsize=ms;
+  }
+  
+  void clear() {
+    long sz=added;
+#if GML_ORDERED_VOLATILE
+    count%=0;
+#endif
+    added=0;
+    if(sz&gt;=shrinksize)
+      doshrink=0;
+    else if(++doshrink&gt;=10)
+      Shrink();
+  }
 };
 
-
+// gmlLock - combines boost mutex+lock into one covenient package
 class gmlLock {
   boost::try_mutex sl_mutex;
-  boost::try_mutex::scoped_try_lock sl_lock;
-
+  BYTE sl_lock[sizeof(boost::try_mutex::scoped_try_lock)*GML_MAX_NUM_THREADS];
+  
 public:
-	gmlLock():sl_lock(sl_mutex,false) {
-	}
-	virtual ~gmlLock() {
-	}
-	bool Lock() {
-		try {
-			return sl_lock.try_lock();
-		} 
-		catch(boost::lock_error&amp;) {
-			return false;
-		}
-	}
-	void Unlock() {
-		sl_lock.unlock();
-	}
+  gmlLock() {
+  }
+  virtual ~gmlLock() {
+  }
+  bool Lock() {
+		boost::try_mutex::scoped_try_lock *lock=((boost::try_mutex::scoped_try_lock *)sl_lock)+gmlThreadNumber;
+    new (lock) boost::try_mutex::scoped_try_lock(sl_mutex);
+		if(lock-&gt;locked())
+			return true;
+	  lock-&gt;~scoped_try_lock();
+		return false;
+  }
+  void Unlock() {
+		(((boost::try_mutex::scoped_try_lock *)sl_lock)+gmlThreadNumber)-&gt;~scoped_try_lock();
+  }
 };
 
 
@@ -348,7 +494,7 @@
   void *pointer;
   VAdata(){}
   VAdata(GLint si, GLenum ty, GLboolean no, GLsizei st, void *po):
-    size(si),type(ty),normalized(no),stride(st),pointer(po) {}
+  size(si),type(ty),normalized(no),stride(st),pointer(po) {}
 };
 
 struct VAstruct {
@@ -362,259 +508,278 @@
 
 
 struct gmlQueue {
-	std::map&lt;GLuint,VAdata&gt; VAmap;
-	std::set&lt;GLuint&gt; VAset;
-
-	BYTE *ReadPos;
-	BYTE *WritePos;
-	BYTE *Pos1;
-	BYTE *Pos2;
-
-	BYTE *WriteSize;
-	BYTE *Size1;
-	BYTE *Size2;
-
-	BYTE *Read;
-	BYTE *Write;
-	BYTE *Queue1;
-	BYTE *Queue2;
-
-	gmlLock Locks1;
-	gmlLock Locks2;
-	volatile BOOL Locked1;
-	volatile BOOL Locked2;
-
-	volatile BOOL Reloc;
-	BYTE * volatile Sync;
-	BOOL WasSynced;
-
-	GLenum ClientState;
-    // VertexPointer
-	GLint VPsize;
-	GLenum VPtype;
-	GLsizei VPstride;
-	GLvoid *VPpointer;
-    // ColorPointer
-	GLint CPsize;
-	GLenum CPtype;
-	GLsizei CPstride;
-	GLvoid *CPpointer;
-    // EdgeFlagPointer
-	GLsizei EFPstride;
-	GLboolean *EFPpointer;
-    // IndexPointer
-	GLenum IPtype;
-	GLsizei IPstride;
-	GLvoid *IPpointer;
-    // NormalPointer
-	GLenum NPtype;
-	GLsizei NPstride;
-	GLvoid *NPpointer;
-    // TexCoordPointer
-	GLint TCPsize;
-	GLenum TCPtype;
-	GLsizei TCPstride;
-	GLvoid *TCPpointer;
-
-	gmlQueue();
-
-	BYTE *Realloc(BYTE **e=NULL);
+  std::map&lt;GLuint,VAdata&gt; VAmap;
+  std::set&lt;GLuint&gt; VAset;
+  
+  BYTE *ReadPos;
+  BYTE *WritePos;
+  BYTE *Pos1;
+  BYTE *Pos2;
+  
+  BYTE *WriteSize;
+  BYTE *Size1;
+  BYTE *Size2;
+  
+  BYTE *Read;
+  BYTE *Write;
+  BYTE *Queue1;
+  BYTE *Queue2;
+  
+  gmlLock Locks1;
+  gmlLock Locks2;
+  volatile BOOL Locked1;
+  volatile BOOL Locked2;
+  
+  volatile BOOL Reloc;
+  BYTE * volatile Sync;
+  BOOL WasSynced;
+  
+  GLenum ClientState;
+  // VertexPointer
+  GLint VPsize;
+  GLenum VPtype;
+  GLsizei VPstride;
+  GLvoid *VPpointer;
+  // ColorPointer
+  GLint CPsize;
+  GLenum CPtype;
+  GLsizei CPstride;
+  GLvoid *CPpointer;
+  // EdgeFlagPointer
+  GLsizei EFPstride;
+  GLboolean *EFPpointer;
+  // IndexPointer
+  GLenum IPtype;
+  GLsizei IPstride;
+  GLvoid *IPpointer;
+  // NormalPointer
+  GLenum NPtype;
+  GLsizei NPstride;
+  GLvoid *NPpointer;
+  // TexCoordPointer
+  GLint TCPsize;
+  GLenum TCPtype;
+  GLsizei TCPstride;
+  GLvoid *TCPpointer;
+  
+  gmlQueue();
+  
+  BYTE *Realloc(BYTE **e=NULL);
   BYTE *WaitRealloc(BYTE **e=NULL);
-	void ReleaseWrite(BOOL final=TRUE);
-	BOOL GetWrite(BOOL critical);
-	void ReleaseRead();
-	BOOL GetRead();
-	void SyncRequest();
-	void Execute();
-	void ExecuteSynced();
+  void ReleaseWrite(BOOL final=TRUE);
+  BOOL GetWrite(BOOL critical);
+  void ReleaseRead();
+  BOOL GetRead(BOOL critical=FALSE);
+  void SyncRequest();
+  void Execute();
+  void ExecuteSynced();
 };
 
 
 template&lt;class T,class S, class C&gt;
 class gmlItemSequenceServer {
-	typedef void (*delitemseqfun)(T, S);
-	C genfun;
-	delitemseqfun delfun;
-	boost::detail::atomic_count req;
-	boost::detail::atomic_count avail;
-	int pregen;
-	int arr_size;
-	T *item_arr;
-	boost::detail::atomic_count req_large;
-	boost::detail::atomic_count avail_large;
-	boost::detail::atomic_count size_large;
-	int pregen_large;	
-	int large_arr_size;
-	T *large_item_arr;
-	T *large_size_arr;
-
+  typedef void (*delitemseqfun)(T, S);
+  C genfun;
+  delitemseqfun delfun;
+  boost::detail::atomic_count req;
+  boost::detail::atomic_count avail;
+  int pregen;
+  int arr_size;
+  T *item_arr;
+  boost::detail::atomic_count req_large;
+  boost::detail::atomic_count avail_large;
+  boost::detail::atomic_count size_large;
+  int pregen_large;	
+  int large_arr_size;
+  T *large_item_arr;
+  T *large_size_arr;
+	GML_MUTEX;
+  
 public:
-	gmlItemSequenceServer(C gf, delitemseqfun df, int sz, int pg, int sz_l, int pg_l):
-			req(0),avail(0),req_large(0),avail_large(0),size_large(2) {
-		genfun=gf;
-		delfun=df;
-		pregen=pg;
-		arr_size=sz;
-		item_arr=new T[arr_size];
-		memset(item_arr,0,arr_size*sizeof(T));
-		pregen_large=pg_l;
-		large_arr_size=sz_l;
-		large_item_arr=new T[large_arr_size];
-		large_size_arr=new T[large_arr_size];
-		memset(large_item_arr,0,large_arr_size*sizeof(T));
-		memset(large_size_arr,0,large_arr_size*sizeof(T));
-	}
-
-	virtual ~gmlItemSequenceServer() {
-		delete [] item_arr;
-		delete [] large_item_arr;
-		delete [] large_size_arr;
-	}
-
-	inline void GenerateItems() {
-		// small
+  gmlItemSequenceServer(C gf, delitemseqfun df, int sz, int pg, int sz_l, int pg_l):
+    req(0),avail(0),req_large(0),avail_large(0),size_large(2) {
+    genfun=gf;
+    delfun=df;
+    pregen=pg;
+    arr_size=sz;
+    item_arr=new T[arr_size];
+    memset(item_arr,0,arr_size*sizeof(T));
+    pregen_large=pg_l;
+    large_arr_size=sz_l;
+    large_item_arr=new T[large_arr_size];
+    large_size_arr=new T[large_arr_size];
+    memset(large_item_arr,0,large_arr_size*sizeof(T));
+    memset(large_size_arr,0,large_arr_size*sizeof(T));
+  }
+  
+  virtual ~gmlItemSequenceServer() {
+    delete [] item_arr;
+    delete [] large_item_arr;
+    delete [] large_size_arr;
+  }
+  
+  inline void GenerateItems() {
+    // small
     int i;    
-		while(avail&lt;req+pregen &amp;&amp; item_arr[i=(avail%arr_size)]==0) {
-  		*(volatile T *)(item_arr+i)=(*genfun)(1);
+    while(avail&lt;req+pregen &amp;&amp; item_arr[i=(avail%arr_size)]==0) {
+			GML_MUTEX_LOCK();
+      *(volatile T *)(item_arr+i)=(*genfun)(1);
+			GML_MUTEX_UNLOCK();
       ++avail;
-		}
-		// large
-		while(avail_large&lt;req_large+pregen_large &amp;&amp; large_size_arr[i=(avail_large%large_arr_size)]==0) {
-			int gensize=size_large;
-  		*(volatile T *)(large_item_arr+i)=(*genfun)(gensize);
-  		*(volatile T *)(large_size_arr+i)=gensize;
+    }
+    // large
+    while(avail_large&lt;req_large+pregen_large &amp;&amp; large_size_arr[i=(avail_large%large_arr_size)]==0) {
+      int gensize=size_large;
+			GML_MUTEX_LOCK();
+      *(volatile T *)(large_item_arr+i)=(*genfun)(gensize);
+      *(volatile T *)(large_size_arr+i)=gensize;
+			GML_MUTEX_UNLOCK();
       ++avail_large;
-		}
-	}
-
-	inline T GetItems(S n) {
-		GML_IF_SERVER_THREAD() {
-			return (*genfun)(n);
-		}
-		if(n==1) {
-			long num=++req;
-			while(avail&lt;num) // waiting
-				boost::thread::yield();
-			T *ip=item_arr+(num-1)%arr_size;
-			T ipv=*ip;
-			*(volatile T *)ip=0;
-			return ipv;
-		}
-		if(n==0)
-			return 0;
-		while(size_large&lt;n)
-			++size_large;
-		while(TRUE) {
-			long num=++req_large;
-			while(avail_large&lt;num) // waiting
-				boost::thread::yield();
-			int idx=(num-1)%large_arr_size;
-			T ip=large_item_arr[idx];
-			T *sz=large_size_arr+idx;
-			T szv=*sz;
-			if(szv&gt;n)
-				(*delfun)(ip+szv,szv-n); // del excessive
-			if(szv&lt;n)
-				(*delfun)(ip,szv); // del all
-			*(volatile T *)sz=0;
-			if(szv&gt;=n)
-				return ip;
-		}
-	}
+    }
+  }
+  
+  inline T GetItems(S n) {
+    GML_IF_SERVER_THREAD() {
+      return (*genfun)(n);
+    }
+    if(n==1) {
+      long num=++req;
+      while(avail&lt;num) // waiting
+        boost::thread::yield();
+      T *ip=item_arr+(num-1)%arr_size;
+			GML_MUTEX_LOCK();
+      T ipv=*(volatile T *)ip;
+      *(volatile T *)ip=0;
+			GML_MUTEX_UNLOCK();
+      return ipv;
+    }
+    if(n==0)
+      return 0;
+    while(size_large&lt;n)
+      ++size_large;
+    while(TRUE) {
+      long num=++req_large;
+      while(avail_large&lt;num) // waiting
+        boost::thread::yield();
+      int idx=(num-1)%large_arr_size;
+			GML_MUTEX_LOCK();
+      T ip=*(volatile T *)(large_item_arr+idx);
+      T *sz=large_size_arr+idx;
+      T szv=*(volatile T *)sz;
+      *(volatile T *)sz=0;
+			GML_MUTEX_UNLOCK();
+      if(szv&gt;n)
+        (*delfun)(ip+szv,szv-n); // del excessive
+      if(szv&lt;n)
+        (*delfun)(ip,szv); // del all
+      if(szv&gt;=n)
+        return ip;
+    }
+  }
 };
 
 
 template&lt;class T, class C&gt;
 class gmlSingleItemServer {
-	C genfun;
-	boost::detail::atomic_count req;
-	boost::detail::atomic_count avail;
-	int pregen;
-	int arr_size;
-	T *arr;
-
+  C genfun;
+  boost::detail::atomic_count req;
+  boost::detail::atomic_count avail;
+  int pregen;
+  int arr_size;
+  T *arr;
+	GML_MUTEX;
+  
 public:
-	gmlSingleItemServer(C gf, int sz, int pg):req(0),avail(0) {
-		genfun=gf;
-		pregen=pg;
-		arr_size=sz;
-		arr=new T[arr_size];
-		memset(arr,0,arr_size*sizeof(T));
-	}
-
-	virtual ~gmlSingleItemServer() {
-		delete [] arr;
-	}
-
-	inline void GenerateItems() {
+  gmlSingleItemServer(C gf, int sz, int pg):req(0),avail(0) {
+    genfun=gf;
+    pregen=pg;
+    arr_size=sz;
+    arr=new T[arr_size];
+    memset(arr,0,arr_size*sizeof(T));
+  }
+  
+  virtual ~gmlSingleItemServer() {
+    delete [] arr;
+  }
+  
+  inline void GenerateItems() {
     int i;    
-		while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
-  		*(volatile T *)(arr+i)=(*genfun)();
+    while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
+			GML_MUTEX_LOCK();
+      *(volatile T *)(arr+i)=(*genfun)();
+			GML_MUTEX_UNLOCK();
       ++avail;
-		}
-	}
-
-	inline T GetItems() {
-		GML_IF_SERVER_THREAD() {
-			return (*genfun)();
-		}
-		long num=++req;
-		while(avail&lt;num) // waiting
-			boost::thread::yield();
-		T *ip=arr+(num-1)%arr_size;
-		T ret=*ip;
-		*(volatile T *)ip=0;
-		return ret;
-	}
+    }
+  }
+  
+  inline T GetItems() {
+    GML_IF_SERVER_THREAD() {
+      return (*genfun)();
+    }
+    long num=++req;
+    while(avail&lt;num) // waiting
+      boost::thread::yield();
+    T *ip=arr+(num-1)%arr_size;
+		GML_MUTEX_LOCK();
+    T ret=*(volatile T *)ip;
+    *(volatile T *)ip=0;
+		GML_MUTEX_UNLOCK();
+    return ret;
+  }
 };
 
 
 template&lt;class T, class S, class C&gt;
 class gmlMultiItemServer {
-	C genfun;
-	boost::detail::atomic_count req;
-	boost::detail::atomic_count avail;
-	int pregen;
-	int arr_size;
-	T *arr;
-
+  C genfun;
+  boost::detail::atomic_count req;
+  boost::detail::atomic_count avail;
+  int pregen;
+  int arr_size;
+  T *arr;
+	GML_MUTEX;
+  
 public:
-	gmlMultiItemServer(C gf, int sz, int pg):req(0),avail(0) {
-		genfun=gf;
-		pregen=pg;
-		arr_size=sz;
-		arr=new T[arr_size];
-		memset(arr,0,arr_size*sizeof(T));
-	}
-
-	virtual ~gmlMultiItemServer() {
-		delete [] arr;
-	}
-
-	inline void GenerateItems() {
+  gmlMultiItemServer(C gf, int sz, int pg):req(0),avail(0) {
+    genfun=gf;
+    pregen=pg;
+    arr_size=sz;
+    arr=new T[arr_size];
+    memset(arr,0,arr_size*sizeof(T));
+  }
+  
+  virtual ~gmlMultiItemServer() {
+    delete [] arr;
+  }
+  
+  inline void GenerateItems() {
     int i;    
-		while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
-			T val;
-  		(*genfun)(1,&amp;val);
-			*(volatile T *)(arr+i)=val;
+    while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
+      T val;
+      (*genfun)(1,&amp;val);
+			GML_MUTEX_LOCK();
+      *(volatile T *)(arr+i)=val;
+			GML_MUTEX_UNLOCK();
       ++avail;
-		}
-	}
-
-	inline void GetItems(S n, T *data) {
-		GML_IF_SERVER_THREAD() {
-			(*genfun)(n,data);
-			return;
-		}
-		for(int i=0; i&lt;n; ++i) {
-			long num=++req;
-			while(avail&lt;num) // waiting
-				boost::thread::yield();
-			T *ip=arr+(num-1)%arr_size;;
-			data[i]=*ip;
-			*(volatile T *)ip=0;
-		}
-	}
+    }
+  }
+  
+  inline void GetItems(S n, T *data) {
+    GML_IF_SERVER_THREAD() {
+      (*genfun)(n,data);
+      return;
+    }
+    for(int i=0; i&lt;n; ++i) {
+      long num=++req;
+      while(avail&lt;num) // waiting
+        boost::thread::yield();
+      T *ip=arr+(num-1)%arr_size;
+			GML_MUTEX_LOCK();
+      data[i]=*(volatile T *)ip;
+      *(volatile T *)ip=0;
+			GML_MUTEX_UNLOCK();
+    }
+  }
 };
 
 

Modified: branches/gml/rts/lib/gml/gmldef.h
===================================================================
--- branches/gml/rts/lib/gml/gmldef.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/lib/gml/gmldef.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -211,6 +211,16 @@
 #undef glBlendFuncSeparate
 #undef gluCylinder
 
+#undef glGenBuffers
+#undef glDeleteBuffers
+#undef glBindBuffer
+#undef glBufferData
+#undef glMapBuffer
+#undef glUnmapBuffer
+#undef glCompressedTexImage2D
+#undef glIsShader
+#undef glVertex3i
+
 #undef glGetIntegerv
 #undef glCheckFramebufferStatusEXT
 #undef glGetFloatv
@@ -464,6 +474,16 @@
 #define glBlendFuncSeparate gmlBlendFuncSeparate
 #define gluCylinder gmluCylinder
 
+#define glGenBuffers gmlGenBuffers
+#define glDeleteBuffers gmlDeleteBuffers
+#define glBindBuffer gmlBindBuffer
+#define glBufferData gmlBufferData
+#define glMapBuffer gmlMapBuffer
+#define glUnmapBuffer gmlUnmapBuffer
+#define glCompressedTexImage2D gmlCompressedTexImage2D
+#define glIsShader gmlIsShader
+#define glVertex3i gmlVertex3i
+
 #define glGetIntegerv gmlGetIntegerv
 #define glCheckFramebufferStatusEXT gmlCheckFramebufferStatusEXT
 #define glGetFloatv gmlGetFloatv

Modified: branches/gml/rts/lib/gml/gmlfun.h
===================================================================
--- branches/gml/rts/lib/gml/gmlfun.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/lib/gml/gmlfun.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -959,7 +959,7 @@
 GML_MAKEFUN2(Vertex2d,GLdouble,GLdouble,)
 GML_MAKEFUN4P(VertexPointer,GLint,GLenum,GLsizei,GLvoid *, VP)
 GML_MAKEFUN3VDA(DrawArrays,GLenum,GLint,GLsizei)
-GML_MAKEFUN2V(Fogfv,GLenum,GLfloat,gmlNumArgsFog(A),)
+GML_MAKEFUN2V(Fogfv,GLenum,GLfloat,gmlNumArgsFog(A),const)
 GML_MAKEFUN5(FramebufferTexture2DEXT,GLenum,GLenum,GLenum,GLuint,GLint)
 GML_MAKEFUN4P(TexCoordPointer,GLint,GLenum,GLsizei,GLvoid *, TCP)
 GML_MAKEFUN9S(TexSubImage2D,GLenum,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,const GLvoid *,E*F*gmlNumArgsTexImage(G)*gmlSizeOf(H),FALSE)
@@ -1105,6 +1105,15 @@
 GML_MAKEFUN4(BlendFuncSeparate,GLenum,GLenum,GLenum,GLenum)
 GML_MAKEFUN6(uCylinder,GLUquadric *,GLdouble,GLdouble,GLdouble,GLint,GLint)
 
+GML_MAKEFUN2V(DeleteBuffers,GLsizei,GLuint,A,const)
+GML_MAKEFUN2(BindBuffer,GLenum,GLuint,)
+GML_MAKEFUN4VS(BufferData,GLenum,GLsizeiptr,char,GLenum,B)
+GML_MAKEFUN2R(MapBuffer,GLenum, GLenum, void *)
+GML_MAKEFUN1R(UnmapBuffer,GLenum, GLboolean,)
+GML_MAKEFUN8V(CompressedTexImage2D,GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,GLsizei,char,G,)
+GML_MAKEFUN1R(IsShader,GLuint, GLboolean,)
+GML_MAKEFUN3(Vertex3i,GLint,GLint,GLint,)
+
 GML_MAKEFUN2(GetIntegerv,GLenum, GLint *,GML_CACHE(GLenum,GLint,gmlGetIntegervCache,A,B),GML_SYNC())
 GML_MAKEFUN1R(CheckFramebufferStatusEXT,GLenum, GLenum,GML_DEFAULT_RET(A==GL_FRAMEBUFFER_EXT,GL_FRAMEBUFFER_COMPLETE_EXT))
 GML_MAKEFUN2(GetFloatv,GLenum, GLfloat *,GML_CACHE(GLenum,GLfloat,gmlGetFloatvCache,A,B),GML_SYNC())

Modified: branches/gml/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/gml/rts/lib/gml/gmlsrv.h	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/lib/gml/gmlsrv.h	2008-05-16 01:17:06 UTC (rev 5894)
@@ -16,7 +16,6 @@
 
 template&lt;class R, class A, typename U&gt;
 struct gmlExecState {
-// 	void (*workfun)(int);
 	R (*worker)(void *);
 	R (*workerarg)(void *,A);
 	R (*workeriter)(void *,U);
@@ -81,18 +80,14 @@
 		else if(workerarg) {
 			(*workerarg)(workerclass,i);
 		}
-//					(*workfun)(i);
 		return TRUE;
 	}
 
 };
 
-
 template&lt;class R,class A, typename U&gt;
 class gmlClientServer {
 public:
-//	volatile bool barg1,barg2;
-//	void * volatile parg1;
 	int ExecDepth;
 	typename gmlExecState&lt;R,A,U&gt; ExecState[GML_MAX_EXEC_DEPTH];
   boost::barrier Barrier; 
@@ -101,21 +96,8 @@
 	boost::detail::atomic_count threadcnt;
 	boost::detail::atomic_count ClientsReady;
 	BOOL newwork;
-/*
-	void (*clientfun[GML_MAX_NUM_THREADS])(void *);
-	void* clientclass[GML_MAX_NUM_THREADS];
-	void ExecClientFun(int thread) {
-		void **c=clientclass+thread;
-		if(*c &amp;&amp; ExecDepth==0) {
-		  (*clientfun[thread])(*c);
-      *c=NULL;
-		}
-	}
-*/
 
 	gmlClientServer():threadcnt(0),ClientsReady(0),Barrier(GML_CPU_COUNT),ExecDepth(0),newwork(FALSE) {
-		//ExecState-&gt;workfun=wf;
-//			memset(clientclass,0,GML_MAX_NUM_THREADS*sizeof(void *));
 		inited=FALSE;
 	}
 
@@ -139,8 +121,6 @@
 			if(execswf)
 			  ex-&gt;ExecServerFun();
 
-//  		ExecClientFun(0);
-
 			typename std::list&lt;U&gt;::iterator it;
 			if(ex-&gt;workeriter)
 				it=ex-&gt;iter-&gt;begin();
@@ -175,8 +155,6 @@
 			}
 			else {
 				ex-&gt;ExecAll(pos,it);
-//				while(ex-&gt;Exec(pos,it,(void *)this))
-//					;
 			}
 //			GML_DEBUG(&quot;server &quot;,nproc)
 			if(ExecDepth&gt;0 &amp;&amp; !*(volatile int *)&amp;newwork) {
@@ -248,8 +226,6 @@
 
 		qd-&gt;GetWrite(TRUE); 
 
-//		ExecClientFun(thread);
-
 		if(ex-&gt;syncmode)
 			qd-&gt;SyncRequest();
 

Modified: branches/gml/rts/spring.exe.manifest
===================================================================
--- branches/gml/rts/spring.exe.manifest	2008-05-15 11:54:39 UTC (rev 5893)
+++ branches/gml/rts/spring.exe.manifest	2008-05-16 01:17:06 UTC (rev 5894)
@@ -1,11 +1,11 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
-&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt; 
-   &lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;X86&quot; name=&quot;spring&quot; type=&quot;win32&quot;/&gt;
-      &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
-      &lt;security&gt;
-         &lt;requestedPrivileges&gt;
-            &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot;/&gt; 
-         &lt;/requestedPrivileges&gt;
-      &lt;/security&gt;
-   &lt;/trustInfo&gt;
-&lt;/assembly&gt;
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
+&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt; 
+   &lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;X86&quot; name=&quot;spring&quot; type=&quot;win32&quot;/&gt;
+      &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
+      &lt;security&gt;
+         &lt;requestedPrivileges&gt;
+            &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot;/&gt; 
+         &lt;/requestedPrivileges&gt;
+      &lt;/security&gt;
+   &lt;/trustInfo&gt;
+&lt;/assembly&gt;


Property changes on: branches/gml/rts/spring.exe.manifest
___________________________________________________________________
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000673.html">[Taspring-linux-commit] r5893 - trunk/rts/Lua
</A></li>
	<LI>Next message: <A HREF="000675.html">[Taspring-linux-commit] r5895 - in trunk/rts: Game System	System/Net System/Net/Test
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#674">[ date ]</a>
              <a href="thread.html#674">[ thread ]</a>
              <a href="subject.html#674">[ subject ]</a>
              <a href="author.html#674">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
