<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5961 - in branches/gml/rts: . ExternalAI	Game Game/Camera Game/StartScripts Game/UI Lua Map	Map/SM3/terrain Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim Sim/Features	Sim/Misc Sim/Projectiles Sim/Units Sim/Units/COB Sim/Weapons	System System/FileSystem System/Net System/Net/Test build	build/cmake build/vstudio8 lib lib/gml lib/lua lib/lua/src	lib/streflop
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5961%20-%20in%20branches/gml/rts%3A%20.%20ExternalAI%0A%09Game%20Game/Camera%20Game/StartScripts%20Game/UI%20Lua%20Map%0A%09Map/SM3/terrain%20Map/SMF%20Rendering%20Rendering/Env%20Rendering/GL%0A%09Rendering/Textures%20Rendering/UnitModels%20Sim%20Sim/Features%0A%09Sim/Misc%20Sim/Projectiles%20Sim/Units%20Sim/Units/COB%20Sim/Weapons%0A%09System%20System/FileSystem%20System/Net%20System/Net/Test%20build%0A%09build/cmake%20build/vstudio8%20lib%20lib/gml%20lib/lua%20lib/lua/src%0A%09lib/streflop&In-Reply-To=%3C20080528211742.F118E4536%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000740.html">
   <LINK REL="Next"  HREF="000742.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5961 - in branches/gml/rts: . ExternalAI	Game Game/Camera Game/StartScripts Game/UI Lua Map	Map/SM3/terrain Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim Sim/Features	Sim/Misc Sim/Projectiles Sim/Units Sim/Units/COB Sim/Weapons	System System/FileSystem System/Net System/Net/Test build	build/cmake build/vstudio8 lib lib/gml lib/lua lib/lua/src	lib/streflop</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5961%20-%20in%20branches/gml/rts%3A%20.%20ExternalAI%0A%09Game%20Game/Camera%20Game/StartScripts%20Game/UI%20Lua%20Map%0A%09Map/SM3/terrain%20Map/SMF%20Rendering%20Rendering/Env%20Rendering/GL%0A%09Rendering/Textures%20Rendering/UnitModels%20Sim%20Sim/Features%0A%09Sim/Misc%20Sim/Projectiles%20Sim/Units%20Sim/Units/COB%20Sim/Weapons%0A%09System%20System/FileSystem%20System/Net%20System/Net/Test%20build%0A%09build/cmake%20build/vstudio8%20lib%20lib/gml%20lib/lua%20lib/lua/src%0A%09lib/streflop&In-Reply-To=%3C20080528211742.F118E4536%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5961 - in branches/gml/rts: . ExternalAI	Game Game/Camera Game/StartScripts Game/UI Lua Map	Map/SM3/terrain Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim Sim/Features	Sim/Misc Sim/Projectiles Sim/Units Sim/Units/COB Sim/Weapons	System System/FileSystem System/Net System/Net/Test build	build/cmake build/vstudio8 lib lib/gml lib/lua lib/lua/src	lib/streflop">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed May 28 23:17:42 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000740.html">[Taspring-linux-commit] r5960 - in trunk: game/LuaUI	game/LuaUI/Widgets installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Game	rts/Game/Camera rts/Game/StartScripts rts/Game/UI rts/Lua	rts/Map rts/Rendering rts/Rendering/Env rts/Rendering/GL	rts/Rendering/Textures rts/Sim/Projectiles
</A></li>
        <LI>Next message: <A HREF="000742.html">[Taspring-linux-commit] r5962 - in trunk/rts: . build/cmake lib	lib/streflop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#741">[ date ]</a>
              <a href="thread.html#741">[ thread ]</a>
              <a href="subject.html#741">[ subject ]</a>
              <a href="author.html#741">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zerver
Date: 2008-05-28 23:17:37 +0200 (Wed, 28 May 2008)
New Revision: 5961

Added:
   branches/gml/rts/CMakeLists.txt
   branches/gml/rts/Rendering/Icon.h
   branches/gml/rts/build/cmake/
   branches/gml/rts/build/cmake/COPYING-CMAKE-SCRIPTS
   branches/gml/rts/build/cmake/FindBoost.cmake
   branches/gml/rts/build/cmake/FindDevil.cmake
   branches/gml/rts/build/cmake/FindFreetype.cmake
   branches/gml/rts/build/cmake/FindGLEW.cmake
   branches/gml/rts/build/cmake/FindOggVorbis.cmake
   branches/gml/rts/build/cmake/FindWin32Libs.cmake
   branches/gml/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake
   branches/gml/rts/icon.rc
   branches/gml/rts/lib/CMakeLists.txt
   branches/gml/rts/lib/streflop/CMakeLists.txt
Removed:
   branches/gml/rts/ExternalAI/GlobalAICInterface/
   branches/gml/rts/ExternalAI/GlobalAIInterfaces/
   branches/gml/rts/Sim/Misc/SensorHandler.cpp
   branches/gml/rts/Sim/Misc/SensorHandler.h
   branches/gml/rts/build/cmake/COPYING-CMAKE-SCRIPTS
   branches/gml/rts/build/cmake/FindBoost.cmake
   branches/gml/rts/build/cmake/FindDevil.cmake
   branches/gml/rts/build/cmake/FindFreetype.cmake
   branches/gml/rts/build/cmake/FindGLEW.cmake
   branches/gml/rts/build/cmake/FindOggVorbis.cmake
   branches/gml/rts/build/cmake/FindWin32Libs.cmake
   branches/gml/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake
Modified:
   branches/gml/rts/ExternalAI/AICallback.cpp
   branches/gml/rts/ExternalAI/GlobalAI.cpp
   branches/gml/rts/ExternalAI/GlobalAI.h
   branches/gml/rts/Game/Camera/CameraController.cpp
   branches/gml/rts/Game/Camera/CameraController.h
   branches/gml/rts/Game/Camera/FPSController.cpp
   branches/gml/rts/Game/Camera/FPSController.h
   branches/gml/rts/Game/Camera/FreeController.cpp
   branches/gml/rts/Game/Camera/FreeController.h
   branches/gml/rts/Game/Camera/LuaCameraCtrl.h
   branches/gml/rts/Game/Camera/OverheadController.cpp
   branches/gml/rts/Game/Camera/OverheadController.h
   branches/gml/rts/Game/Camera/OverviewController.cpp
   branches/gml/rts/Game/Camera/OverviewController.h
   branches/gml/rts/Game/Camera/RotOverheadController.cpp
   branches/gml/rts/Game/Camera/RotOverheadController.h
   branches/gml/rts/Game/Camera/SmoothController.cpp
   branches/gml/rts/Game/Camera/SmoothController.h
   branches/gml/rts/Game/Camera/TWController.cpp
   branches/gml/rts/Game/Camera/TWController.h
   branches/gml/rts/Game/CameraHandler.cpp
   branches/gml/rts/Game/CameraHandler.h
   branches/gml/rts/Game/ChatMessage.cpp
   branches/gml/rts/Game/ChatMessage.h
   branches/gml/rts/Game/CommandMessage.cpp
   branches/gml/rts/Game/CommandMessage.h
   branches/gml/rts/Game/Console.cpp
   branches/gml/rts/Game/Console.h
   branches/gml/rts/Game/Game.cpp
   branches/gml/rts/Game/Game.h
   branches/gml/rts/Game/GameData.cpp
   branches/gml/rts/Game/GameData.h
   branches/gml/rts/Game/GameServer.cpp
   branches/gml/rts/Game/GameServer.h
   branches/gml/rts/Game/PreGame.cpp
   branches/gml/rts/Game/PreGame.h
   branches/gml/rts/Game/StartScripts/CommanderScript.cpp
   branches/gml/rts/Game/StartScripts/CommanderScript2.cpp
   branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp
   branches/gml/rts/Game/StartScripts/LoadScript.cpp
   branches/gml/rts/Game/StartScripts/SpawnScript.cpp
   branches/gml/rts/Game/Team.cpp
   branches/gml/rts/Game/UI/GameSetupDrawer.cpp
   branches/gml/rts/Game/UI/KeyAutoBinder.cpp
   branches/gml/rts/Game/UI/KeyBindings.h
   branches/gml/rts/Game/UI/LuaUI.cpp
   branches/gml/rts/Game/UI/MiniMap.cpp
   branches/gml/rts/Game/UI/MiniMap.h
   branches/gml/rts/Game/UI/MouseHandler.cpp
   branches/gml/rts/Game/UI/TooltipConsole.cpp
   branches/gml/rts/Game/WordCompletion.cpp
   branches/gml/rts/Lua/LuaConstGame.cpp
   branches/gml/rts/Lua/LuaFeatureDefs.cpp
   branches/gml/rts/Lua/LuaHandle.cpp
   branches/gml/rts/Lua/LuaOpenGL.cpp
   branches/gml/rts/Lua/LuaParser.cpp
   branches/gml/rts/Lua/LuaParser.h
   branches/gml/rts/Lua/LuaSyncedCtrl.cpp
   branches/gml/rts/Lua/LuaSyncedCtrl.h
   branches/gml/rts/Lua/LuaSyncedRead.cpp
   branches/gml/rts/Lua/LuaUnitDefs.cpp
   branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp
   branches/gml/rts/Lua/LuaUnsyncedCtrl.h
   branches/gml/rts/Lua/LuaUnsyncedRead.cpp
   branches/gml/rts/Lua/LuaUtils.cpp
   branches/gml/rts/Lua/LuaWeaponDefs.cpp
   branches/gml/rts/Map/MapInfo.cpp
   branches/gml/rts/Map/MapInfo.h
   branches/gml/rts/Map/ReadMap.cpp
   branches/gml/rts/Map/SM3/terrain/TerrainTexture.cpp
   branches/gml/rts/Map/SMF/SmfReadMap.cpp
   branches/gml/rts/Rendering/Env/AdvTreeGenerator.cpp
   branches/gml/rts/Rendering/Env/BasicTreeDrawer.cpp
   branches/gml/rts/Rendering/Env/BumpWater.cpp
   branches/gml/rts/Rendering/FontTexture.cpp
   branches/gml/rts/Rendering/GL/VertexArray.cpp
   branches/gml/rts/Rendering/GL/VertexArray.h
   branches/gml/rts/Rendering/GL/myGL.cpp
   branches/gml/rts/Rendering/GroundDecalHandler.cpp
   branches/gml/rts/Rendering/GroundDecalHandler.h
   branches/gml/rts/Rendering/IconHandler.cpp
   branches/gml/rts/Rendering/IconHandler.h
   branches/gml/rts/Rendering/Textures/NamedTextures.cpp
   branches/gml/rts/Rendering/UnitModels/3DModelParser.h
   branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp
   branches/gml/rts/Rendering/UnitModels/UnitDrawer.h
   branches/gml/rts/Sim/Features/FeatureDef.h
   branches/gml/rts/Sim/Features/FeatureHandler.cpp
   branches/gml/rts/Sim/Misc/LosHandler.cpp
   branches/gml/rts/Sim/Misc/LosHandler.h
   branches/gml/rts/Sim/ModInfo.cpp
   branches/gml/rts/Sim/ModInfo.h
   branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp
   branches/gml/rts/Sim/Units/COB/CobFile.h
   branches/gml/rts/Sim/Units/COB/CobInstance.cpp
   branches/gml/rts/Sim/Units/Unit.cpp
   branches/gml/rts/Sim/Units/Unit.h
   branches/gml/rts/Sim/Units/UnitDef.h
   branches/gml/rts/Sim/Units/UnitDefHandler.cpp
   branches/gml/rts/Sim/Units/UnitDefHandler.h
   branches/gml/rts/Sim/Weapons/WeaponDefHandler.cpp
   branches/gml/rts/Sim/Weapons/WeaponDefHandler.h
   branches/gml/rts/System/AutohostInterface.h
   branches/gml/rts/System/BaseNetProtocol.cpp
   branches/gml/rts/System/BaseNetProtocol.h
   branches/gml/rts/System/FileSystem/Archive7Zip.cpp
   branches/gml/rts/System/FileSystem/CRC.cpp
   branches/gml/rts/System/FileSystem/FileHandler.cpp
   branches/gml/rts/System/Messages.cpp
   branches/gml/rts/System/Messages.h
   branches/gml/rts/System/Net/Connection.cpp
   branches/gml/rts/System/Net/Connection.h
   branches/gml/rts/System/Net/LocalConnection.cpp
   branches/gml/rts/System/Net/LocalConnection.h
   branches/gml/rts/System/Net/Net.cpp
   branches/gml/rts/System/Net/Net.h
   branches/gml/rts/System/Net/PackPacket.cpp
   branches/gml/rts/System/Net/PackPacket.h
   branches/gml/rts/System/Net/Test/CMakeLists.txt
   branches/gml/rts/System/Net/Test/main.cpp
   branches/gml/rts/System/Net/UDPConnectedSocket.h
   branches/gml/rts/System/Net/UDPConnection.cpp
   branches/gml/rts/System/Net/UDPConnection.h
   branches/gml/rts/System/Net/UnpackPacket.cpp
   branches/gml/rts/System/Net/UnpackPacket.h
   branches/gml/rts/System/NetProtocol.cpp
   branches/gml/rts/System/NetProtocol.h
   branches/gml/rts/build/vstudio8/rts.vcproj
   branches/gml/rts/lib/gml/gml.cpp
   branches/gml/rts/lib/gml/gmlcls.h
   branches/gml/rts/lib/gml/gmlfun.h
   branches/gml/rts/lib/gml/gmlsrv.h
   branches/gml/rts/lib/lua/README_SPRING
   branches/gml/rts/lib/lua/src/lbaselib.cpp
   branches/gml/rts/lib/lua/src/lvm.cpp
   branches/gml/rts/lib/streflop/Makefile
Log:
Small Linux/GCC fix
RTS updated to trunk rev 5960

Copied: branches/gml/rts/CMakeLists.txt (from rev 5960, trunk/rts/CMakeLists.txt)
===================================================================
--- branches/gml/rts/CMakeLists.txt	                        (rev 0)
+++ branches/gml/rts/CMakeLists.txt	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,136 @@
+### Cmake 2.4 lacks some cross-compiling features and fails on windows
+cmake_minimum_required(VERSION 2.6)
+PROJECT(Spring)
+
+LIST(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_SOURCE_DIR}/build/cmake&quot;)
+
+### Compiler flags and defines based on build type
+INCLUDE(TestCXXAcceptsVisibilityFlag)
+SET(BASE_FLAGS &quot;-march=i686 -fsingle-precision-constant -frounding-math -fsignaling-nans -mieee-fp -mfpmath=387 -pipe -fno-strict-aliasing&quot;)
+IF (UNIX)
+	SET(BASE_FLAGS &quot;${BASE_FLAGS} -pthread&quot;)
+ENDIF (UNIX)
+SET(CMAKE_CXX_FLAGS_DEBUG1  &quot;${BASE_FLAGS} -ggdb1 -O1 -Wall -DDEBUG -D_DEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG2  &quot;${BASE_FLAGS} -ggdb2 -O0 -Wall -DDEBUG -D_DEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG3  &quot;${BASE_FLAGS} -ggdb3 -O0 -Wall -DDEBUG -D_DEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_RELEASE &quot;${BASE_FLAGS} ${VISIBILITY_HIDDEN} -O2 -DNDEBUG&quot;)
+
+### Spring defines
+ADD_DEFINITIONS( -D_SZ_ONE_DIRECTORY -DSYNCCHECK -DSTREFLOP_X87 -DDIRECT_CONTROL_ALLOWED)
+IF (UNIX)
+	ADD_DEFINITIONS(-DNO_AVI)
+ELSE(UNIX)
+ENDIF(UNIX)
+
+### Find include directories
+IF (MINGW)
+	SET(MINGWLIBS ${CMAKE_SOURCE_DIR}/mingwlibs CACHE PATH &quot;Location of the mingwlibs (you can't build windows executables without them)&quot;)
+	FIND_PACKAGE(Win32Libs REQUIRED)
+
+	### add mingwlibs to link- and include-directories
+	INCLUDE_DIRECTORIES(${MINGWLIBS}/include ${MINGWLIBS}/include/SDL)
+	LINK_DIRECTORIES(${MINGWLIBS}/lib ${MINGWLIBS}/dll)
+ELSE (MINGW)
+	FIND_PACKAGE(SDL REQUIRED)
+	INCLUDE_DIRECTORIES(${SDL_INCLUDE_DIR})
+
+	FIND_PACKAGE(Boost 1.34.0 COMPONENTS thread regex REQUIRED)
+	INCLUDE_DIRECTORIES(${BOOST_INCLUDE_DIR})
+
+	FIND_PACKAGE(X11 REQUIRED)
+	FIND_PACKAGE(OpenAL REQUIRED)
+	FIND_PACKAGE(OpenGL REQUIRED)
+	FIND_PACKAGE(GLU REQUIRED)
+	FIND_PACKAGE(GLUT REQUIRED)
+	FIND_PACKAGE(GLEW REQUIRED)
+	FIND_PACKAGE(Devil REQUIRED)
+	FIND_PACKAGE(OggVorbis REQUIRED)
+
+	FIND_PACKAGE(Freetype REQUIRED)
+	INCLUDE_DIRECTORIES(${FREETYPE_INCLUDE_DIR})
+ENDIF (MINGW)
+
+# build all libraries in lib (has its own CMakeLists.txt)
+ADD_SUBDIRECTORY(lib)
+
+### include directories needed for compiling spring
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR} System)
+INCLUDE_DIRECTORIES(lib/lua/include lib/luabind)
+
+### all spring source directories
+### each directorie which contains source has to be here
+AUX_SOURCE_DIRECTORY(Game gamefiles)
+AUX_SOURCE_DIRECTORY(Game/Camera gamefiles)
+AUX_SOURCE_DIRECTORY(Game/Server gamefiles)
+AUX_SOURCE_DIRECTORY(Game/StartScripts gamefiles)
+AUX_SOURCE_DIRECTORY(Game/UI gamefiles)
+
+AUX_SOURCE_DIRECTORY(Lua luafiles)
+
+AUX_SOURCE_DIRECTORY(ExternalAI aifiles)
+
+AUX_SOURCE_DIRECTORY(Map mapfiles)
+AUX_SOURCE_DIRECTORY(Map/SM3 mapfiles)
+AUX_SOURCE_DIRECTORY(Map/SM3/terrain mapfiles)
+AUX_SOURCE_DIRECTORY(Map/SMF mapfiles)
+
+AUX_SOURCE_DIRECTORY(Rendering renderfiles)
+AUX_SOURCE_DIRECTORY(Rendering/Env renderfiles)
+AUX_SOURCE_DIRECTORY(Rendering/GL renderfiles)
+AUX_SOURCE_DIRECTORY(Rendering/Textures renderfiles)
+AUX_SOURCE_DIRECTORY(Rendering/UnitModels renderfiles)
+
+AUX_SOURCE_DIRECTORY(Sim simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Features simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Misc simfiles)
+AUX_SOURCE_DIRECTORY(Sim/MoveTypes simfiles)
+AUX_SOURCE_DIRECTORY(Sim/MoveTypes/MoveMath simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Objects simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Path simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Projectiles simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Projectiles/WeaponProjectiles simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Projectiles/Unsynced simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Units simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Units/COB simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Units/CommandAI simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Units/UnitTypes simfiles)
+AUX_SOURCE_DIRECTORY(Sim/Weapons simfiles)
+
+AUX_SOURCE_DIRECTORY(System sysfiles)
+AUX_SOURCE_DIRECTORY(System/Platform sysfiles)
+### only use the directory for target platform
+IF (UNIX)
+	AUX_SOURCE_DIRECTORY(System/Platform/Linux sysfiles)
+ELSE (UNIX)
+	AUX_SOURCE_DIRECTORY(System/Platform/Win sysfiles)
+ENDIF (UNIX)
+AUX_SOURCE_DIRECTORY(System/FileSystem sysfiles)
+AUX_SOURCE_DIRECTORY(System/Net sysfiles)
+AUX_SOURCE_DIRECTORY(System/Script sysfiles)
+AUX_SOURCE_DIRECTORY(System/Sync sysfiles)
+AUX_SOURCE_DIRECTORY(System/creg sysfiles)
+
+### Add icon and manifest to exe using windres
+IF (MINGW)
+	FIND_PROGRAM(WINDRES NAMES windres i686-mingw32-windres DOC &quot;path to mingw's windres executable&quot;)
+	ADD_CUSTOM_COMMAND(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/icon.o COMMAND ${WINDRES} -I${CMAKE_CURRENT_SOURCE_DIR} -i${CMAKE_CURRENT_SOURCE_DIR}/icon.rc -o ${CMAKE_CURRENT_BINARY_DIR}/icon.o)
+	LIST(APPEND sysfiles icon.o)
+ENDIF (MINGW)
+
+
+ADD_EXECUTABLE(spring ${gamefiles} ${luafiles} ${mapfiles} ${fsfiles} ${renderfiles} ${simfiles} ${sysfiles} ${aifiles})
+
+### libraries in lib/
+SET(spring_libraries lua 7zip hpiutil2 minizip streflop luabind)
+### libraries needed on all platforms
+# ${BOOST_THREAD_LIBRARY} doesn't work
+LIST(APPEND spring_libraries SDL boost_thread-mt boost_regex-mt vorbisfile vorbis ogg freetype)
+
+### platform specific libraries
+IF (UNIX)
+	LIST(APPEND spring_libraries openal GL GLU IL ILU X11 Xcursor ${GLEW_LIBRARIES})
+ELSE (UNIX)
+	LIST(APPEND spring_libraries glu32 ilu opengl32 ${WIN32_LIBRARIES} glew32 mingw32 devil)
+ENDIF (UNIX)
+
+TARGET_LINK_LIBRARIES(spring ${spring_libraries})

Modified: branches/gml/rts/ExternalAI/AICallback.cpp
===================================================================
--- branches/gml/rts/ExternalAI/AICallback.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/ExternalAI/AICallback.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -514,7 +514,7 @@
 	verify ();
 	if (CHECK_UNITID(unitid)) {
 		CUnit* unit=uh-&gt;units[unitid];
-		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
+		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			return unit-&gt;experience;
 		}
 	}
@@ -556,8 +556,8 @@
 			if (gs-&gt;Ally(unit-&gt;allyteam, allyTeam)) {
 				return unitDef;
 			}
-			const int losStatus = unit-&gt;losStatus[allyTeam];
-			const int prevMask = (LOS_PREVLOS | LOS_CONTRADAR);
+			const unsigned short losStatus = unit-&gt;losStatus[allyTeam];
+			const unsigned short prevMask = (LOS_PREVLOS | LOS_CONTRADAR);
 			if (((losStatus &amp; LOS_INLOS) != 0) ||
 					((losStatus &amp; prevMask) == prevMask)) {
 				const UnitDef* decoyDef = unitDef-&gt;decoyDef;
@@ -672,7 +672,8 @@
 	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
-		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp;
+		    (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			if (!IsUnitNeutral(u-&gt;id)) {
 				units[a++] = u-&gt;id;
 			}

Modified: branches/gml/rts/ExternalAI/GlobalAI.cpp
===================================================================
--- branches/gml/rts/ExternalAI/GlobalAI.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/ExternalAI/GlobalAI.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -7,7 +7,6 @@
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Platform/SharedLib.h&quot;
-#include &quot;ExternalAI/GlobalAICInterface/AbicProxy.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;mmgr.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
@@ -133,11 +132,11 @@
 	IsCInterface = (_IsCInterfaceFunc != 0 &amp;&amp; _IsCInterfaceFunc() == 1);
 	IsLoadSupported = (_IsLoadSupportedFunc != 0 &amp;&amp; _IsLoadSupportedFunc());
 
-	if (IsCInterface) {
-		LoadABICAI(team, botLibName, postLoad, IsLoadSupported);
-	} else {
+	//if (IsCInterface) {
+	//	LoadABICAI(team, botLibName, postLoad, IsLoadSupported);
+	//} else {
 		LoadCPPAI(team, botLibName, postLoad, IsLoadSupported, isJavaAI);
-	}
+	//}
 
 
 	if (postLoad &amp;&amp; !IsLoadSupported) {
@@ -175,26 +174,6 @@
 	}
 }
 
-
-
-void CGlobalAI::LoadABICAI(int team, const char* botLibName, bool postLoad, bool loadSupported)
-{
-	logOutput &lt;&lt; botLibName &lt;&lt; &quot; has a C interface (ABIC)\n&quot;;
-
-	// keep as AbicProxy, so InitAI works ok
-	AbicProxy* ai = SAFE_NEW AbicProxy;
-	this-&gt;ai = ai;
-
-	callback = SAFE_NEW CGlobalAICallback(this);
-
-	if (!postLoad || (postLoad &amp;&amp; !loadSupported)) {
-		try {
-			ai-&gt;InitAI(botLibName, callback, team);
-		} HANDLE_EXCEPTION;
-	}
-}
-
-
 void CGlobalAI::LoadCPPAI(int team, const char* botLibName, bool postLoad, bool loadSupported, bool isJavaAI)
 {
 	if (isJavaAI) {

Modified: branches/gml/rts/ExternalAI/GlobalAI.h
===================================================================
--- branches/gml/rts/ExternalAI/GlobalAI.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/ExternalAI/GlobalAI.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -52,7 +52,6 @@
 	ISLOADSUPPORTED _IsLoadSupportedFunc;
 
 private:
-	void LoadABICAI(int, const char*, bool, bool);
 	void LoadCPPAI(int, const char*, bool, bool, bool);
 	void LoadJavaProxyAI();
 };

Modified: branches/gml/rts/Game/Camera/CameraController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/CameraController.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/CameraController.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -15,3 +15,29 @@
 CCameraController::~CCameraController(void)
 {
 }
+
+
+bool CCameraController::SetStateBool(const StateMap&amp; sm,
+                                     const std::string&amp; name, bool&amp; var)
+{
+	StateMap::const_iterator it = sm.find(name);
+	if (it != sm.end()) {
+		const float value = it-&gt;second;
+		var = (value &gt; 0.0f);
+		return true;
+	}
+	return false;
+}
+
+
+bool CCameraController::SetStateFloat(const StateMap&amp; sm,
+                                      const std::string&amp; name, float&amp; var)
+{
+	StateMap::const_iterator it = sm.find(name);
+	if (it != sm.end()) {
+		const float value = it-&gt;second;
+		var = value;
+		return true;
+	}
+	return false;
+}

Modified: branches/gml/rts/Game/Camera/CameraController.h
===================================================================
--- branches/gml/rts/Game/Camera/CameraController.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/CameraController.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -3,12 +3,17 @@
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
+#include &lt;map&gt;
 
 #include &quot;float3.h&quot;
 
+
 class CCameraController
 {
 public:
+	typedef std::map&lt;std::string, float&gt; StateMap;
+
+public:
 	CCameraController();
 	virtual ~CCameraController(void);
 
@@ -32,14 +37,18 @@
 	virtual float3 SwitchFrom() const =0;			//return pos that to send to new controllers SetPos
 	virtual void SwitchTo(bool showText=true)=0;
 	
-	virtual void GetState(std::vector&lt;float&gt;&amp; fv) const = 0;
-	virtual bool SetState(const std::vector&lt;float&gt;&amp; fv) = 0;
+	virtual void GetState(StateMap&amp; sm) const = 0;
+	virtual bool SetState(const StateMap&amp; sm) = 0;
 	virtual void SetTrackingInfo(const float3&amp; pos, float radius) { SetPos(pos); }
 
 	/// should this mode appear when we toggle the camera controller?
 	bool enabled;
 	
 protected:
+	bool SetStateBool(const StateMap&amp; sm, const std::string&amp; name, bool&amp; var);
+	bool SetStateFloat(const StateMap&amp; sm, const std::string&amp; name, float&amp; var);
+
+protected:
 	float fov;
 	float mouseScale;
 	float scrollSpeed;

Modified: branches/gml/rts/Game/Camera/FPSController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/FPSController.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/FPSController.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -7,6 +7,7 @@
 
 using namespace std;
 
+
 CFPSController::CFPSController()
 	: oldHeight(300)
 {
@@ -15,12 +16,14 @@
 	fov = configHandler.GetFloat(&quot;FPSFOV&quot;, 45.0f);
 }
 
+
 void CFPSController::KeyMove(float3 move)
 {
 	move*=move.z*400;
 	pos+=(camera-&gt;forward*move.y+camera-&gt;right*move.x)*scrollSpeed;
 }
 
+
 void CFPSController::MouseMove(float3 move)
 {
 	camera-&gt;rot.y -= mouseScale*move.x;
@@ -32,16 +35,19 @@
 		camera-&gt;rot.x=-PI*0.4999f;
 }
 
+
 void CFPSController::ScreenEdgeMove(float3 move)
 {
 	KeyMove(move);
 }
 
+
 void CFPSController::MouseWheelMove(float move)
 {
 	pos += camera-&gt;up * move;
 }
 
+
 float3 CFPSController::GetPos()
 {
 #ifdef DIRECT_CONTROL_ALLOWED
@@ -67,6 +73,7 @@
 	return pos;
 }
 
+
 float3 CFPSController::GetDir()
 {
 	dir.x = (float)(cos(camera-&gt;rot.x) * sin(camera-&gt;rot.y));
@@ -76,6 +83,7 @@
 	return dir;
 }
 
+
 void CFPSController::SetPos(const float3&amp; newPos)
 {
 	CCameraController::SetPos(newPos);
@@ -88,51 +96,61 @@
 	}
 }
 
+
 void CFPSController::SetDir(const float3&amp; newDir)
 {
 	dir = newDir;
 }
 
+
 float3 CFPSController::SwitchFrom() const
 {
 	return pos;
 }
 
+
 void CFPSController::SwitchTo(bool showText)
 {
-	if(showText)
+	if (showText) {
 		logOutput.Print(&quot;Switching to FPS style camera&quot;);
+  }
 }
 
-void CFPSController::GetState(std::vector&lt;float&gt;&amp; fv) const
+
+void CFPSController::GetState(StateMap&amp; sm) const
 {
-	fv.push_back(/*  1 */ pos.x);
-	fv.push_back(/*  2 */ pos.y);
-	fv.push_back(/*  3 */ pos.z);
-	fv.push_back(/*  4 */ dir.x);
-	fv.push_back(/*  5 */ dir.y);
-	fv.push_back(/*  6 */ dir.z);
-	fv.push_back(/*  7 */ camera-&gt;rot.x);
-	fv.push_back(/*  8 */ camera-&gt;rot.y);
-	fv.push_back(/*  9 */ camera-&gt;rot.z);
-	fv.push_back(/* 10 */ oldHeight);
+	sm[&quot;px&quot;] = pos.x;
+	sm[&quot;py&quot;] = pos.y;
+	sm[&quot;pz&quot;] = pos.z;
+
+	sm[&quot;dx&quot;] = dir.x;
+	sm[&quot;dy&quot;] = dir.y;
+	sm[&quot;dz&quot;] = dir.z;
+
+	sm[&quot;rx&quot;] = camera-&gt;rot.x;
+	sm[&quot;ry&quot;] = camera-&gt;rot.y;
+	sm[&quot;rz&quot;] = camera-&gt;rot.z;
+
+	sm[&quot;oldHeight&quot;] = oldHeight;
 }
 
-bool CFPSController::SetState(const std::vector&lt;float&gt;&amp; fv)
+
+bool CFPSController::SetState(const StateMap&amp; sm)
 {
-	if (fv.size() != 10) {
-		return false;
-	}
-	pos.x = fv[0];
-	pos.y = fv[1];
-	pos.z = fv[2];
-	dir.x = fv[3];
-	dir.y = fv[4];
-	dir.z = fv[5];
-	camera-&gt;rot.x = fv[6];
-	camera-&gt;rot.y = fv[7];
-	camera-&gt;rot.z = fv[8];
-	oldHeight = fv[9];
+	SetStateFloat(sm, &quot;px&quot;, pos.x);
+	SetStateFloat(sm, &quot;py&quot;, pos.y);
+	SetStateFloat(sm, &quot;pz&quot;, pos.z);
+
+	SetStateFloat(sm, &quot;dx&quot;, dir.x);
+	SetStateFloat(sm, &quot;dy&quot;, dir.y);
+	SetStateFloat(sm, &quot;dz&quot;, dir.z);
+
+	SetStateFloat(sm, &quot;rx&quot;, camera-&gt;rot.x);
+	SetStateFloat(sm, &quot;ry&quot;, camera-&gt;rot.y);
+	SetStateFloat(sm, &quot;rz&quot;, camera-&gt;rot.z);
+
+	SetStateFloat(sm, &quot;oldHeight&quot;, oldHeight);
+
 	return true;
 }
 

Modified: branches/gml/rts/Game/Camera/FPSController.h
===================================================================
--- branches/gml/rts/Game/Camera/FPSController.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/FPSController.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -25,8 +25,8 @@
 	float3 SwitchFrom() const;
 	void SwitchTo(bool showText);
 
-	void GetState(std::vector&lt;float&gt;&amp; fv) const;
-	bool SetState(const std::vector&lt;float&gt;&amp; fv);
+	void GetState(StateMap&amp; sm) const;
+	bool SetState(const StateMap&amp; sm);
 
 private:
 	float oldHeight;

Modified: branches/gml/rts/Game/Camera/FreeController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/FreeController.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/FreeController.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -20,32 +20,40 @@
 //
 
 CFreeController::CFreeController()
-	: dir(0.0f, 0.0f, 0.0f),
-	vel(0.0f, 0.0f, 0.0f),
-	avel(0.0f, 0.0f, 0.0f),
-	prevVel(0.0f, 0.0f, 0.0f),
-	prevAvel(0.0f, 0.0f, 0.0f),
-	tracking(false),
-	trackPos(0.0f, 0.0f, 0.0f),
-	trackRadius(0.0f),
-	gndLock(false)
+: vel(0.0f, 0.0f, 0.0f),
+  avel(0.0f, 0.0f, 0.0f),
+  prevVel(0.0f, 0.0f, 0.0f),
+  prevAvel(0.0f, 0.0f, 0.0f),
+  tracking(false),
+  trackPos(0.0f, 0.0f, 0.0f),
+  trackRadius(0.0f),
+  gndLock(false)
 {
-	enabled      = !!configHandler.GetInt(&quot;CamFreeEnabled&quot;,   0);
-	invertAlt    = !!configHandler.GetInt(&quot;CamFreeInvertAlt&quot;, 0);
-	goForward    = !!configHandler.GetInt(&quot;CamFreeGoForward&quot;, 0);
-	fov          = configHandler.GetFloat(&quot;CamFreeFOV&quot;,           45.0f);
-	scrollSpeed  = configHandler.GetFloat(&quot;CamFreeScrollSpeed&quot;,  500.0f);
-	gravity      = configHandler.GetFloat(&quot;CamFreeGravity&quot;,     -500.0f);
-	slide        = configHandler.GetFloat(&quot;CamFreeSlide&quot;,          0.5f);
-	gndOffset    = configHandler.GetFloat(&quot;CamFreeGroundOffset&quot;,  16.0f);
-	tiltSpeed    = configHandler.GetFloat(&quot;CamFreeTiltSpeed&quot;,    150.0f);
-	tiltSpeed    = tiltSpeed * (PI / 180.0);
-	autoTilt     = configHandler.GetFloat(&quot;CamFreeAutoTilt&quot;,     150.0f);
-	autoTilt     = autoTilt * (PI / 180.0);
-	velTime      = configHandler.GetFloat(&quot;CamFreeVelTime&quot;,        1.5f);
-	velTime      = max(0.1f, velTime);
-	avelTime     = configHandler.GetFloat(&quot;CamFreeAngVelTime&quot;,     1.0f);
-	avelTime     = max(0.1f, avelTime);
+	dir = float3(0.0f, -2.0f, -1.0f);
+	dir.Normalize();
+	if (camera) {
+		const float hDist = sqrtf((dir.x * dir.x) + (dir.z * dir.z));
+		camera-&gt;rot.y = atan2f(dir.x, dir.z);
+		camera-&gt;rot.x = atan2f(dir.y, hDist);
+	}
+	pos -= (dir * 1000.0f);
+
+	enabled     = !!configHandler.GetInt(&quot;CamFreeEnabled&quot;,   0);
+	invertAlt   = !!configHandler.GetInt(&quot;CamFreeInvertAlt&quot;, 0);
+	goForward   = !!configHandler.GetInt(&quot;CamFreeGoForward&quot;, 0);
+	fov         = configHandler.GetFloat(&quot;CamFreeFOV&quot;,           45.0f);
+	scrollSpeed = configHandler.GetFloat(&quot;CamFreeScrollSpeed&quot;,  500.0f);
+	gravity     = configHandler.GetFloat(&quot;CamFreeGravity&quot;,     -500.0f);
+	slide       = configHandler.GetFloat(&quot;CamFreeSlide&quot;,          0.5f);
+	gndOffset   = configHandler.GetFloat(&quot;CamFreeGroundOffset&quot;,  16.0f);
+	tiltSpeed   = configHandler.GetFloat(&quot;CamFreeTiltSpeed&quot;,    150.0f);
+	tiltSpeed   = tiltSpeed * (PI / 180.0);
+	autoTilt    = configHandler.GetFloat(&quot;CamFreeAutoTilt&quot;,     150.0f);
+	autoTilt    = autoTilt * (PI / 180.0);
+	velTime     = configHandler.GetFloat(&quot;CamFreeVelTime&quot;,        1.5f);
+	velTime     = max(0.1f, velTime);
+	avelTime    = configHandler.GetFloat(&quot;CamFreeAngVelTime&quot;,     1.0f);
+	avelTime    = max(0.1f, avelTime);
 }
 
 
@@ -392,73 +400,79 @@
 }
 
 
-void CFreeController::GetState(std::vector&lt;float&gt;&amp; fv) const
+void CFreeController::GetState(StateMap&amp; sm) const
 {
-	fv.push_back(/*  1 */ pos.x);
-	fv.push_back(/*  2 */ pos.y);
-	fv.push_back(/*  3 */ pos.z);
-	fv.push_back(/*  4 */ dir.x);
-	fv.push_back(/*  5 */ dir.y);
-	fv.push_back(/*  6 */ dir.z);
-	fv.push_back(/*  7 */ camera-&gt;rot.x);
-	fv.push_back(/*  8 */ camera-&gt;rot.y);
-	fv.push_back(/*  9 */ camera-&gt;rot.z);
+	sm[&quot;px&quot;] = pos.x;
+	sm[&quot;py&quot;] = pos.y;
+	sm[&quot;pz&quot;] = pos.z;
 
-	fv.push_back(/* 10 */ fov);
-	fv.push_back(/* 11 */ gndOffset);
-	fv.push_back(/* 12 */ gravity);
-	fv.push_back(/* 13 */ slide);
-	fv.push_back(/* 14 */ scrollSpeed);
-	fv.push_back(/* 15 */ tiltSpeed);
-	fv.push_back(/* 16 */ velTime);
-	fv.push_back(/* 17 */ avelTime);
-	fv.push_back(/* 18 */ autoTilt);
-	fv.push_back(/* 19 */ goForward ? 1.0f : -1.0f);
-	fv.push_back(/* 20 */ invertAlt ? 1.0f : -1.0f);
-	fv.push_back(/* 21 */ gndLock   ? 1.0f : -1.0f);
+	sm[&quot;dx&quot;] = dir.x;
+	sm[&quot;dy&quot;] = dir.y;
+	sm[&quot;dz&quot;] = dir.z;
 
-	fv.push_back(/* 22 */ prevVel.x);
-	fv.push_back(/* 23 */ prevVel.y);
-	fv.push_back(/* 24 */ prevVel.z);
-	fv.push_back(/* 25 */ prevAvel.x);
-	fv.push_back(/* 26 */ prevAvel.y);
-	fv.push_back(/* 27 */ prevAvel.z);
+	sm[&quot;rx&quot;] = camera-&gt;rot.x;
+	sm[&quot;ry&quot;] = camera-&gt;rot.y;
+	sm[&quot;rz&quot;] = camera-&gt;rot.z;
+
+	sm[&quot;fov&quot;]         = fov;
+	sm[&quot;gndOffset&quot;]   = gndOffset;
+	sm[&quot;gravity&quot;]     = gravity;
+	sm[&quot;slide&quot;]       = slide;
+	sm[&quot;scrollSpeed&quot;] = scrollSpeed;
+	sm[&quot;tiltSpeed&quot;]   = tiltSpeed;
+	sm[&quot;velTime&quot;]     = velTime;
+	sm[&quot;avelTime&quot;]    = avelTime;
+	sm[&quot;autoTilt&quot;]    = autoTilt;
+
+	sm[&quot;goForward&quot;]   = goForward ? +1.0f : -1.0f;
+	sm[&quot;invertAlt&quot;]   = invertAlt ? +1.0f : -1.0f;
+	sm[&quot;gndLock&quot;]     = gndLock   ? +1.0f : -1.0f;
+
+	sm[&quot;vx&quot;] = prevVel.x;
+	sm[&quot;vy&quot;] = prevVel.y;
+	sm[&quot;vz&quot;] = prevVel.z;
+
+	sm[&quot;avx&quot;] = prevAvel.x;
+	sm[&quot;avy&quot;] = prevAvel.y;
+	sm[&quot;avz&quot;] = prevAvel.z;
 }
 
 
-bool CFreeController::SetState(const std::vector&lt;float&gt;&amp; fv)
+bool CFreeController::SetState(const StateMap&amp; sm)
 {
-	if (fv.size() != 27) {
-		return false;
-	}
-	pos.x = fv[0];
-	pos.y = fv[1];
-	pos.z = fv[2];
-	dir.x = fv[3];
-	dir.y = fv[4];
-	dir.z = fv[5];
-	camera-&gt;rot.x = fv[6];
-	camera-&gt;rot.y = fv[7];
-	camera-&gt;rot.z = fv[8];
+	SetStateFloat(sm, &quot;px&quot;, pos.x);
+	SetStateFloat(sm, &quot;py&quot;, pos.y);
+	SetStateFloat(sm, &quot;pz&quot;, pos.z);
 
-	fov         =  fv[9];
-	gndOffset   =  fv[10];
-	gravity     =  fv[11];
-	slide       =  fv[12];
-	scrollSpeed =  fv[13];
-	tiltSpeed   =  fv[14];
-	velTime     =  fv[15];
-	avelTime    =  fv[16];
-	autoTilt    =  fv[17];
-	goForward   = (fv[18] &gt; 0.0f);
-	invertAlt   = (fv[19] &gt; 0.0f);
-	gndLock     = (fv[20] &gt; 0.0f);
-	prevVel.x   =  fv[21];
-	prevVel.y   =  fv[22];
-	prevVel.z   =  fv[23];
-	prevAvel.x  =  fv[24];
-	prevAvel.y  =  fv[25];
-	prevAvel.z  =  fv[26];
+	SetStateFloat(sm, &quot;dx&quot;, dir.x);
+	SetStateFloat(sm, &quot;dy&quot;, dir.y);
+	SetStateFloat(sm, &quot;dz&quot;, dir.z);
 
+	SetStateFloat(sm, &quot;rx&quot;, camera-&gt;rot.x);
+	SetStateFloat(sm, &quot;ry&quot;, camera-&gt;rot.y);
+	SetStateFloat(sm, &quot;rz&quot;, camera-&gt;rot.z);
+
+	SetStateFloat(sm, &quot;fov&quot;,         fov);
+	SetStateFloat(sm, &quot;gndOffset&quot;,   gndOffset);
+	SetStateFloat(sm, &quot;gravity&quot;,     gravity);
+	SetStateFloat(sm, &quot;slide&quot;,       slide);
+	SetStateFloat(sm, &quot;scrollSpeed&quot;, scrollSpeed);
+	SetStateFloat(sm, &quot;tiltSpeed&quot;,   tiltSpeed);
+	SetStateFloat(sm, &quot;velTime&quot;,     velTime);
+	SetStateFloat(sm, &quot;avelTime&quot;,    avelTime);
+	SetStateFloat(sm, &quot;autoTilt&quot;,    autoTilt);
+
+	SetStateBool (sm, &quot;goForward&quot;,   goForward);
+	SetStateBool (sm, &quot;invertAlt&quot;,   invertAlt);
+	SetStateBool (sm, &quot;gndLock&quot;,     gndLock);
+
+	SetStateFloat(sm, &quot;vx&quot;, prevVel.x);
+	SetStateFloat(sm, &quot;vy&quot;, prevVel.y);
+	SetStateFloat(sm, &quot;vz&quot;, prevVel.z);
+
+	SetStateFloat(sm, &quot;avx&quot;, prevAvel.x);
+	SetStateFloat(sm, &quot;avy&quot;, prevAvel.y);
+	SetStateFloat(sm, &quot;avz&quot;, prevAvel.z);
+
 	return true;
 }

Modified: branches/gml/rts/Game/Camera/FreeController.h
===================================================================
--- branches/gml/rts/Game/Camera/FreeController.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/FreeController.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -30,8 +30,8 @@
 	float3 SwitchFrom() const;
 	void SwitchTo(bool showText);
 
-	void GetState(std::vector&lt;float&gt;&amp; fv) const;
-	bool SetState(const std::vector&lt;float&gt;&amp; fv);
+	void GetState(StateMap&amp; sm) const;
+	bool SetState(const StateMap&amp; sm);
 
 private:
 	float3 dir;

Modified: branches/gml/rts/Game/Camera/LuaCameraCtrl.h
===================================================================
--- branches/gml/rts/Game/Camera/LuaCameraCtrl.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/LuaCameraCtrl.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -29,8 +29,8 @@
 	float3 SwitchFrom() const; // return pos that to send to new controllers SetPos
 	void SwitchTo(bool showText);
 
-	void GetState(std::vector&lt;float&gt;&amp; fv) const;
-	bool SetState(const std::vector&lt;float&gt;&amp; fv);
+	void GetState(StateMap&amp; sm) const;
+	bool SetState(const StateMap&amp; sm);
 
 private:
 	float3 dir;

Modified: branches/gml/rts/Game/Camera/OverheadController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/OverheadController.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/OverheadController.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -151,32 +151,34 @@
 		logOutput.Print(&quot;Switching to Overhead (TA) style camera&quot;);
 }
 
-void COverheadController::GetState(std::vector&lt;float&gt;&amp; fv) const
+void COverheadController::GetState(StateMap&amp; sm) const
 {
-	fv.push_back(/* 1 */ pos.x);
-	fv.push_back(/* 2 */ pos.y);
-	fv.push_back(/* 3 */ pos.z);
-	fv.push_back(/* 4 */ dir.x);
-	fv.push_back(/* 5 */ dir.y);
-	fv.push_back(/* 6 */ dir.z);
-	fv.push_back(/* 7 */ height);
-	fv.push_back(/* 8 */ zscale);
-	fv.push_back(/* 9 */ flipped ? +1.0f : -1.0f);
+	sm[&quot;px&quot;] = pos.x;
+	sm[&quot;py&quot;] = pos.y;
+	sm[&quot;pz&quot;] = pos.z;
+
+	sm[&quot;dx&quot;] = dir.x;
+	sm[&quot;dy&quot;] = dir.y;
+	sm[&quot;dz&quot;] = dir.z;
+
+	sm[&quot;height&quot;]  = height;
+	sm[&quot;zscale&quot;]  = zscale;
+	sm[&quot;flipped&quot;] = flipped ? +1.0f : -1.0f;
 }
 
-bool COverheadController::SetState(const std::vector&lt;float&gt;&amp; fv)
+bool COverheadController::SetState(const StateMap&amp; sm)
 {
-	if (fv.size() != 9) {
-		return false;
-	}
-	pos.x   =  fv[0];
-	pos.y   =  fv[1];
-	pos.z   =  fv[2];
-	dir.x   =  fv[3];
-	dir.y   =  fv[4];
-	dir.z   =  fv[5];
-	height  =  fv[6];
-	zscale  =  fv[7];
-	flipped = (fv[8] &gt; 0.0f);
+	SetStateFloat(sm, &quot;px&quot;, pos.x);
+	SetStateFloat(sm, &quot;py&quot;, pos.y);
+	SetStateFloat(sm, &quot;pz&quot;, pos.z);
+
+	SetStateFloat(sm, &quot;dx&quot;, dir.x);
+	SetStateFloat(sm, &quot;dy&quot;, dir.y);
+	SetStateFloat(sm, &quot;dz&quot;, dir.z);
+
+	SetStateFloat(sm, &quot;height&quot;, height);
+	SetStateFloat(sm, &quot;zscale&quot;, zscale);
+	SetStateBool (sm, &quot;flipped&quot;, flipped);
+
 	return true;
 }

Modified: branches/gml/rts/Game/Camera/OverheadController.h
===================================================================
--- branches/gml/rts/Game/Camera/OverheadController.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/OverheadController.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -22,8 +22,8 @@
 	float3 SwitchFrom() const;
 	void SwitchTo(bool showText);
 
-	void GetState(std::vector&lt;float&gt;&amp; fv) const;
-	bool SetState(const std::vector&lt;float&gt;&amp; fv);
+	void GetState(StateMap&amp; sm) const;
+	bool SetState(const StateMap&amp; sm);
 
 	bool flipped;
 

Modified: branches/gml/rts/Game/Camera/OverviewController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/OverviewController.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/OverviewController.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -71,20 +71,17 @@
 	}
 }
 
-void COverviewController::GetState(std::vector&lt;float&gt;&amp; fv) const
+void COverviewController::GetState(StateMap&amp; sm) const
 {
-	fv.push_back(/* 1 */ pos.x);
-	fv.push_back(/* 2 */ pos.y);
-	fv.push_back(/* 3 */ pos.z);
+	sm[&quot;px&quot;] = pos.x;
+	sm[&quot;py&quot;] = pos.y;
+	sm[&quot;pz&quot;] = pos.z;
 }
 
-bool COverviewController::SetState(const std::vector&lt;float&gt;&amp; fv)
+bool COverviewController::SetState(const StateMap&amp; sm)
 {
-	if (fv.size() != 3) {
-		return false;
-	}
-	pos.x = fv[0];
-	pos.y = fv[1];
-	pos.z = fv[2];
+	SetStateFloat(sm, &quot;px&quot;, pos.x);
+	SetStateFloat(sm, &quot;py&quot;, pos.y);
+	SetStateFloat(sm, &quot;pz&quot;, pos.z);
 	return true;
 }

Modified: branches/gml/rts/Game/Camera/OverviewController.h
===================================================================
--- branches/gml/rts/Game/Camera/OverviewController.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/OverviewController.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -24,8 +24,8 @@
 	float3 SwitchFrom() const;
 	void SwitchTo(bool showText);
 
-	void GetState(std::vector&lt;float&gt;&amp; fv) const;
-	bool SetState(const std::vector&lt;float&gt;&amp; fv);
+	void GetState(StateMap&amp; sm) const;
+	bool SetState(const StateMap&amp; sm);
 
 private:
 	bool minimizeMinimap;

Modified: branches/gml/rts/Game/Camera/RotOverheadController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/RotOverheadController.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/RotOverheadController.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -15,6 +15,7 @@
 	fov = configHandler.GetFloat(&quot;RotOverheadFOV&quot;, 45.0f);
 }
 
+
 void CRotOverheadController::KeyMove(float3 move)
 {
 	move*=sqrt(move.z)*400;
@@ -28,6 +29,7 @@
 	pos+=(flatForward*move.y+camera-&gt;right*move.x)*scrollSpeed;
 }
 
+
 void CRotOverheadController::MouseMove(float3 move)
 {
 	camera-&gt;rot.y -= mouseScale*move.x;
@@ -39,11 +41,13 @@
 		camera-&gt;rot.x=-PI*0.4999f;
 }
 
+
 void CRotOverheadController::ScreenEdgeMove(float3 move)
 {
 	KeyMove(move);
 }
 
+
 void CRotOverheadController::MouseWheelMove(float move)
 {
 	const float gheight = ground-&gt;GetHeight(pos.x,pos.z);
@@ -52,6 +56,7 @@
 	pos.y = height + gheight;
 }
 
+
 float3 CRotOverheadController::GetPos()
 {
 	if(pos.x&lt;0.01f)
@@ -72,6 +77,7 @@
 	return pos;
 }
 
+
 float3 CRotOverheadController::GetDir()
 {
 	dir.x=(float)(sin(camera-&gt;rot.y)*cos(camera-&gt;rot.x));
@@ -81,52 +87,61 @@
 	return dir;
 }
 
+
 void CRotOverheadController::SetPos(const float3&amp; newPos)
 {
 	CCameraController::SetPos(newPos);
 	pos.y = ground-&gt;GetHeight(pos.x, pos.z) + oldHeight;
 }
 
+
 float3 CRotOverheadController::SwitchFrom() const
 {
 	return pos;
 }
 
+
 void CRotOverheadController::SwitchTo(bool showText)
 {
 	if(showText)
 		logOutput.Print(&quot;Switching to Rotatable overhead camera&quot;);
 }
 
-void CRotOverheadController::GetState(std::vector&lt;float&gt;&amp; fv) const
+
+void CRotOverheadController::GetState(StateMap&amp; sm) const
 {
-	fv.push_back(/*  1 */ pos.x);
-	fv.push_back(/*  2 */ pos.y);
-	fv.push_back(/*  3 */ pos.z);
-	fv.push_back(/*  4 */ dir.x);
-	fv.push_back(/*  5 */ dir.y);
-	fv.push_back(/*  6 */ dir.z);
-	fv.push_back(/*  7 */ camera-&gt;rot.x);
-	fv.push_back(/*  8 */ camera-&gt;rot.y);
-	fv.push_back(/*  9 */ camera-&gt;rot.z);
-	fv.push_back(/* 10 */ oldHeight);
+	sm[&quot;px&quot;] = pos.x;
+	sm[&quot;py&quot;] = pos.y;
+	sm[&quot;pz&quot;] = pos.z;
+
+	sm[&quot;dx&quot;] = dir.x;
+	sm[&quot;dy&quot;] = dir.y;
+	sm[&quot;dz&quot;] = dir.z;
+
+	sm[&quot;rx&quot;] = camera-&gt;rot.x;
+	sm[&quot;ry&quot;] = camera-&gt;rot.y;
+	sm[&quot;rz&quot;] = camera-&gt;rot.z;
+
+	sm[&quot;oldHeight&quot;] = oldHeight;
 }
 
-bool CRotOverheadController::SetState(const std::vector&lt;float&gt;&amp; fv)
+
+bool CRotOverheadController::SetState(const StateMap&amp; sm)
 {
-	if (fv.size() != 10) {
-		return false;
-	}
-	pos.x = fv[0];
-	pos.y = fv[1];
-	pos.z = fv[2];
-	dir.x = fv[3];
-	dir.y = fv[4];
-	dir.z = fv[5];
-	camera-&gt;rot.x = fv[6];
-	camera-&gt;rot.y = fv[7];
-	camera-&gt;rot.z = fv[8];
-	oldHeight = fv[9];
+	SetStateFloat(sm, &quot;px&quot;, pos.x);
+	SetStateFloat(sm, &quot;py&quot;, pos.y);
+	SetStateFloat(sm, &quot;pz&quot;, pos.z);
+
+	SetStateFloat(sm, &quot;dx&quot;, dir.x);
+	SetStateFloat(sm, &quot;dy&quot;, dir.y);
+	SetStateFloat(sm, &quot;dz&quot;, dir.z);
+
+	SetStateFloat(sm, &quot;rx&quot;, camera-&gt;rot.x);
+	SetStateFloat(sm, &quot;ry&quot;, camera-&gt;rot.y);
+	SetStateFloat(sm, &quot;rz&quot;, camera-&gt;rot.z);
+
+	SetStateFloat(sm, &quot;oldHeight&quot;, oldHeight);
+
 	return true;
 }
 

Modified: branches/gml/rts/Game/Camera/RotOverheadController.h
===================================================================
--- branches/gml/rts/Game/Camera/RotOverheadController.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/RotOverheadController.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -24,8 +24,8 @@
 	float3 SwitchFrom() const;
 	void SwitchTo(bool showText);
 
-	void GetState(std::vector&lt;float&gt;&amp; fv) const;
-	bool SetState(const std::vector&lt;float&gt;&amp; fv);
+	void GetState(StateMap&amp; sm) const;
+	bool SetState(const StateMap&amp; sm);
 
 private:
 	float oldHeight;

Modified: branches/gml/rts/Game/Camera/SmoothController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/SmoothController.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/SmoothController.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -15,12 +15,13 @@
 
 extern Uint8 *keys;
 
+
 SmoothController::SmoothController()
-	: height(500),zscale(0.5f),
+	: flipped(false),zscale(0.5f),
+	height(500),
 	oldAltHeight(500),
+	changeAltHeight(true),
 	maxHeight(10000),
-	changeAltHeight(true),
-	flipped(false),
 	speedFactor(1)
 {
 	scrollSpeed = configHandler.GetInt(&quot;SmoothScrollSpeed&quot;,10)*0.1f;
@@ -35,6 +36,7 @@
 {
 }
 
+
 void SmoothController::KeyMove(float3 move)
 {
 	if (flipped) {
@@ -60,6 +62,7 @@
 	}
 }
 
+
 void SmoothController::MouseMove(float3 move)
 {
 	if (flipped) {
@@ -74,6 +77,7 @@
 	lastMove = (thisMove+lastMove)/2.0f;
 }
 
+
 void SmoothController::ScreenEdgeMove(float3 move)
 {
 	if (flipped) {
@@ -99,6 +103,7 @@
 	}
 }
 
+
 void SmoothController::MouseWheelMove(float move)
 {
 	// tilt the camera if LCTRL is pressed
@@ -153,6 +158,7 @@
 	}
 }
 
+
 float3 SmoothController::GetPos()
 {
 	maxHeight = 9.5f * std::max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
@@ -180,52 +186,59 @@
 	return cpos;
 }
 
+
 float3 SmoothController::GetDir()
 {
 	return dir;
 }
 
+
 float3 SmoothController::SwitchFrom() const
 {
 	return pos;
 }
 
+
 void SmoothController::SwitchTo(bool showText)
 {
 	if(showText)
 		logOutput.Print(&quot;Switching to smooth camera&quot;);
 }
 
-void SmoothController::GetState(std::vector&lt;float&gt;&amp; fv) const
+
+void SmoothController::GetState(StateMap&amp; sm) const
 {
-	fv.push_back(/* 1 */ pos.x);
-	fv.push_back(/* 2 */ pos.y);
-	fv.push_back(/* 3 */ pos.z);
-	fv.push_back(/* 4 */ dir.x);
-	fv.push_back(/* 5 */ dir.y);
-	fv.push_back(/* 6 */ dir.z);
-	fv.push_back(/* 7 */ height);
-	fv.push_back(/* 8 */ zscale);
-	fv.push_back(/* 9 */ flipped ? +1.0f : -1.0f);
+	sm[&quot;px&quot;] = pos.x;
+	sm[&quot;py&quot;] = pos.y;
+	sm[&quot;pz&quot;] = pos.z;
+
+	sm[&quot;dx&quot;] = dir.x;
+	sm[&quot;dy&quot;] = dir.y;
+	sm[&quot;dz&quot;] = dir.z;
+
+	sm[&quot;height&quot;]  = height;
+	sm[&quot;zscale&quot;]  = zscale;
+	sm[&quot;flipped&quot;] = flipped ? +1.0f : -1.0f;
 }
 
-bool SmoothController::SetState(const std::vector&lt;float&gt;&amp; fv)
+bool SmoothController::SetState(const StateMap&amp; sm)
 {
-	if (fv.size() != 9) {
-		return false;
-	}
-	pos.x   =  fv[0];
-	pos.y   =  fv[1];
-	pos.z   =  fv[2];
-	dir.x   =  fv[3];
-	dir.y   =  fv[4];
-	dir.z   =  fv[5];
-	height  =  fv[6];
-	zscale  =  fv[7];
-	flipped = (fv[8] &gt; 0.0f);
+	SetStateFloat(sm, &quot;px&quot;, pos.x);
+	SetStateFloat(sm, &quot;py&quot;, pos.y);
+	SetStateFloat(sm, &quot;pz&quot;, pos.z);
+
+	SetStateFloat(sm, &quot;dx&quot;, dir.x);
+	SetStateFloat(sm, &quot;dy&quot;, dir.y);
+	SetStateFloat(sm, &quot;dz&quot;, dir.z);
+
+	SetStateFloat(sm, &quot;height&quot;,  height);
+	SetStateFloat(sm, &quot;zscale&quot;,  zscale);
+	SetStateBool (sm, &quot;flipped&quot;, flipped);
+
 	return true;
 }
 
+
 void SmoothController::Move(const float3&amp; move, const unsigned timeDiff)
 {
 	if ((move.x != 0 || move.z != 0) &amp;&amp; speedFactor &lt; maxSpeedFactor)

Modified: branches/gml/rts/Game/Camera/SmoothController.h
===================================================================
--- branches/gml/rts/Game/Camera/SmoothController.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/SmoothController.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -27,8 +27,8 @@
 	float3 SwitchFrom() const;
 	void SwitchTo(bool showText);
 
-	void GetState(std::vector&lt;float&gt;&amp; fv) const;
-	bool SetState(const std::vector&lt;float&gt;&amp; fv);
+	void GetState(StateMap&amp; sm) const;
+	bool SetState(const StateMap&amp; sm);
 
 	bool flipped;
 

Modified: branches/gml/rts/Game/Camera/TWController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/TWController.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/TWController.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -10,6 +10,7 @@
 
 extern Uint8 *keys;
 
+
 CTWController::CTWController()
 {
 	scrollSpeed = configHandler.GetInt(&quot;TWScrollSpeed&quot;,10) * 0.1f;
@@ -17,6 +18,7 @@
 	fov = configHandler.GetFloat(&quot;TWFOV&quot;, 45.0f);
 }
 
+
 void CTWController::KeyMove(float3 move)
 {
 	float3 flatForward=camera-&gt;forward;
@@ -27,6 +29,7 @@
 	pos+=(flatForward*move.y+camera-&gt;right*move.x)*scrollSpeed;
 }
 
+
 void CTWController::MouseMove(float3 move)
 {
 	float dist=-camera-&gt;rot.x*1500;
@@ -39,6 +42,7 @@
 	pos+=-(flatForward*move.y-camera-&gt;right*move.x)*scrollSpeed;
 }
 
+
 void CTWController::ScreenEdgeMove(float3 move)
 {
 	if(mouse-&gt;lasty&lt;gu-&gt;viewSizeY/3){
@@ -48,11 +52,13 @@
 	KeyMove(move);
 }
 
+
 void CTWController::MouseWheelMove(float move)
 {
 	camera-&gt;rot.x-=move*0.001f;
 }
 
+
 float3 CTWController::GetPos()
 {
 	if(pos.x&lt;0.01f)
@@ -86,6 +92,7 @@
 	return cpos;
 }
 
+
 float3 CTWController::GetDir()
 {
 	float3 dir;
@@ -96,37 +103,39 @@
 	return dir;
 }
 
+
 float3 CTWController::SwitchFrom() const
 {
 	return pos;
 }
 
+
 void CTWController::SwitchTo(bool showText)
 {
-	if(showText)
+	if (showText) {
 		logOutput.Print(&quot;Switching to Total War style camera&quot;);
+	}
 }
 
-void CTWController::GetState(std::vector&lt;float&gt;&amp; fv) const
+
+void CTWController::GetState(StateMap&amp; sm) const
 {
-	fv.push_back(/* 1 */ pos.x);
-	fv.push_back(/* 2 */ pos.y);
-	fv.push_back(/* 3 */ pos.z);
-	fv.push_back(/* 4 */ camera-&gt;rot.x);
-	fv.push_back(/* 5 */ camera-&gt;rot.y);
-	fv.push_back(/* 6 */ camera-&gt;rot.z);
+	sm[&quot;px&quot;] = pos.x;
+	sm[&quot;py&quot;] = pos.y;
+	sm[&quot;pz&quot;] = pos.z;
+	sm[&quot;rx&quot;] = camera-&gt;rot.x;
+	sm[&quot;ry&quot;] = camera-&gt;rot.y;
+	sm[&quot;rz&quot;] = camera-&gt;rot.z;
 }
 
-bool CTWController::SetState(const std::vector&lt;float&gt;&amp; fv)
+
+bool CTWController::SetState(const StateMap&amp; sm)
 {
-	if (fv.size() != 6) {
-		return false;
-	}
-	pos.x = fv[0];
-	pos.y = fv[1];
-	pos.z = fv[2];
-	camera-&gt;rot.x = fv[3];
-	camera-&gt;rot.y = fv[4];
-	camera-&gt;rot.z = fv[5];
+	SetStateFloat(sm, &quot;px&quot;, pos.x);
+	SetStateFloat(sm, &quot;py&quot;, pos.y);
+	SetStateFloat(sm, &quot;pz&quot;, pos.z);
+	SetStateFloat(sm, &quot;rx&quot;, camera-&gt;rot.x);
+	SetStateFloat(sm, &quot;ry&quot;, camera-&gt;rot.y);
+	SetStateFloat(sm, &quot;rz&quot;, camera-&gt;rot.z);
 	return true;
 }

Modified: branches/gml/rts/Game/Camera/TWController.h
===================================================================
--- branches/gml/rts/Game/Camera/TWController.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Camera/TWController.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -22,8 +22,8 @@
 	float3 SwitchFrom() const;
 	void SwitchTo(bool showText);
 
-	void GetState(std::vector&lt;float&gt;&amp; fv) const;
-	bool SetState(const std::vector&lt;float&gt;&amp; fv);
+	void GetState(StateMap&amp; sm) const;
+	bool SetState(const StateMap&amp; sm);
 };
 
 

Modified: branches/gml/rts/Game/CameraHandler.cpp
===================================================================
--- branches/gml/rts/Game/CameraHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/CameraHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,5 +1,10 @@
+
+#include &quot;StdAfx.h&quot;
+
 #include &quot;CameraHandler.h&quot;
 
+#include &quot;Game/Action.h&quot;
+#include &quot;Game/Camera.h&quot;
 #include &quot;Game/Camera/CameraController.h&quot;
 #include &quot;Game/Camera/FPSController.h&quot;
 #include &quot;Game/Camera/OverheadController.h&quot;
@@ -8,8 +13,6 @@
 #include &quot;Game/Camera/FreeController.h&quot;
 #include &quot;Game/Camera/OverviewController.h&quot;
 #include &quot;Game/Camera/TWController.h&quot;
-#include &quot;Game/Camera.h&quot;
-#include &quot;Game/Action.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;GlobalStuff.h&quot;
@@ -23,31 +26,50 @@
 	cameraTime=0.0f;
 	cameraTimeLeft=0.0f;
 	
-	//fps camera must always be the first one in the list
+	// FPS camera must always be the first one in the list
 	std::vector&lt;CCameraController*&gt;&amp; camCtrls = camControllers;
-	camCtrls.push_back(new CFPSController()); // 0  (first)
-	camCtrls.push_back(new COverheadController()); // 1
-	camCtrls.push_back(new CTWController()); // 2
+	camCtrls.push_back(new CFPSController());         // 0
+	camCtrls.push_back(new COverheadController());    // 1
+	camCtrls.push_back(new CTWController());          // 2
 	camCtrls.push_back(new CRotOverheadController()); // 3
-	camCtrls.push_back(new CFreeController()); // 4
-	camCtrls.push_back(new SmoothController()); // 5
-	camCtrls.push_back(new COverviewController()); // 6
+	camCtrls.push_back(new CFreeController());        // 4
+	camCtrls.push_back(new SmoothController());       // 5
+	camCtrls.push_back(new COverviewController());    // 6
 
-	int mode = configHandler.GetInt(&quot;CamMode&quot;, 1);
-	mode = std::max(0, std::min(mode, (int)camControllers.size() - 1));
+	for (unsigned int i = 0; i &lt; camCtrls.size(); i++) {
+		nameMap[camCtrls[i]-&gt;GetName()] = i;
+	}
+
+	int modeIndex;
+	const std::string modeName = configHandler.GetString(&quot;CamModeName&quot;, &quot;&quot;);
+	if (!modeName.empty()) {
+		modeIndex = GetModeIndex(modeName);
+	} else {
+		modeIndex = configHandler.GetInt(&quot;CamMode&quot;, 1);
+	}
+	const unsigned int mode =
+		(unsigned int)std::max(0, std::min(modeIndex, (int)camCtrls.size() - 1));
 	currCamCtrlNum = mode;
 	currCamCtrl = camControllers[currCamCtrlNum];
 
 	const double z = 0.0; // casting problems...
-	cameraTimeFactor = std::max(z, atof(configHandler.GetString(&quot;CamTimeFactor&quot;, &quot;1.0&quot;).c_str()));
+	cameraTimeFactor   = std::max(z, atof(configHandler.GetString(&quot;CamTimeFactor&quot;,   &quot;1.0&quot;).c_str()));
 	cameraTimeExponent = std::max(z, atof(configHandler.GetString(&quot;CamTimeExponent&quot;, &quot;4.0&quot;).c_str()));
 
-	RegisterAction(&quot;viewfps&quot;);		RegisterAction(&quot;viewta&quot;);
-	RegisterAction(&quot;viewtw&quot;);		RegisterAction(&quot;viewrot&quot;);
-	RegisterAction(&quot;viewfree&quot;);		RegisterAction(&quot;viewov&quot;);
-	RegisterAction(&quot;viewlua&quot;);		RegisterAction(&quot;viewtaflip&quot;);
-	RegisterAction(&quot;viewsave&quot;);		RegisterAction(&quot;viewload&quot;);
+	RegisterAction(&quot;viewfps&quot;);
+	RegisterAction(&quot;viewta&quot;);
+	RegisterAction(&quot;viewtw&quot;);
+	RegisterAction(&quot;viewrot&quot;);
+	RegisterAction(&quot;viewfree&quot;);
+	RegisterAction(&quot;viewov&quot;);
+	RegisterAction(&quot;viewlua&quot;);
+
+	RegisterAction(&quot;viewtaflip&quot;);
+
 	RegisterAction(&quot;toggleoverview&quot;);
+
+	RegisterAction(&quot;viewsave&quot;);
+	RegisterAction(&quot;viewload&quot;);
 }
 
 
@@ -94,9 +116,9 @@
 }
 
 
-void CCameraHandler::SetCameraMode(unsigned mode)
+void CCameraHandler::SetCameraMode(unsigned int mode)
 {
-	if ((mode &gt;= camControllers.size()) || (mode == currCamCtrlNum)) {
+	if ((mode &gt;= camControllers.size()) || (mode == static_cast&lt;unsigned int&gt;(currCamCtrlNum))) {
 		return;
 	}
 
@@ -111,6 +133,26 @@
 }
 
 
+void CCameraHandler::SetCameraMode(const std::string&amp; modeName)
+{
+	const int modeNum = GetModeIndex(modeName);
+	if (modeNum &gt;= 0) {
+		SetCameraMode(modeNum);
+	}
+	// do nothing if the name is not matched
+}
+
+
+int CCameraHandler::GetModeIndex(const std::string&amp; name) const
+{
+	std::map&lt;std::string, unsigned int&gt;::const_iterator it = nameMap.find(name);
+	if (it != nameMap.end()) {
+		return it-&gt;second;
+	}
+	return -1;
+}
+
+
 void CCameraHandler::PushMode()
 {
 	controllerStack.push(GetCurrentControllerNum());
@@ -160,9 +202,9 @@
 }
 
 
-void CCameraHandler::ToggleOverviewCamera(void)
+void CCameraHandler::ToggleOverviewCamera()
 {
-	const int ovCamNum = (int)camControllers.size() - 1;
+	const unsigned int ovCamNum = camControllers.size() - 1;
 	if (controllerStack.empty()) {
 		PushMode();
 		SetCameraMode(ovCamNum);
@@ -176,14 +218,12 @@
 
 void CCameraHandler::SaveView(const std::string&amp; name)
 {
-	if (name.empty()) {
+	if (name.empty())
 		return;
-	}
 	ViewData vd;
-	vd.mode = currCamCtrlNum;
-	currCamCtrl-&gt;GetState(vd.state);
+	vd[&quot;mode&quot;] = currCamCtrlNum;
+	currCamCtrl-&gt;GetState(vd);
 	views[name] = vd;
-	logOutput.Print(&quot;Saved view: &quot; + name);
 	return;
 }
 
@@ -201,28 +241,56 @@
 	const ViewData&amp; saved = it-&gt;second;
 
 	ViewData current;
-	current.mode = currCamCtrlNum;
-	currCamCtrl-&gt;GetState(current.state);
-
-	for (it = views.begin(); it != views.end(); ++it) {
-		if (it-&gt;second == current) {
-			break;
+	GetState(current);
+	
+	if (saved == current) { // load a view twice to return to old settings
+		 if (name != &quot;__old_view&quot;) { // safety: should not happen, but who knows?
+			 return LoadView(&quot;__old_view&quot;);
+		 } else {
+			 return false;
+			}
+	}
+	else {
+		if (name != &quot;__old_view&quot;) {
+			SaveView(&quot;__old_view&quot;);
 		}
+		return LoadViewData(saved);
 	}
-	if (it == views.end()) {
-		tmpView = current;
-	}
+}
 
-	ViewData effective;
-	if (saved == current) {
-		effective = tmpView;
-	} else {
-		effective = saved;
+
+void CCameraHandler::GetState(CCameraController::StateMap&amp; sm) const
+{
+	sm.clear();
+	sm[&quot;mode&quot;] = (float)currCamCtrlNum;
+	currCamCtrl-&gt;GetState(sm);
+}
+
+
+bool CCameraHandler::SetState(const CCameraController::StateMap&amp; sm)
+{
+	CCameraController::StateMap::const_iterator it = sm.find(&quot;mode&quot;);
+	if (it != sm.end()) {
+		const unsigned int camMode = (unsigned int)it-&gt;second;
+		if (camMode &gt;= camControllers.size()) {
+			return false;
+		}
+		if (camMode != currCamCtrlNum) {
+			currCamCtrlNum = camMode;
+			currCamCtrl = camControllers[camMode];
+			currCamCtrl-&gt;SwitchTo();
+		}
 	}
+	return currCamCtrl-&gt;SetState(sm);
+}
 
-	return LoadViewData(effective);
+
+const std::string CCameraHandler::GetCurrentControllerName() const
+{
+	return currCamCtrl-&gt;GetName();
 }
 
+
 void CCameraHandler::PushAction(const Action&amp; action)
 {
 	const std::string cmd = action.command;
@@ -268,34 +336,42 @@
 		}
 	}
 	else if (cmd == &quot;viewsave&quot;) {
-		SaveView(action.extra);
+		if (!action.extra.empty()) {
+			SaveView(action.extra);
+			logOutput.Print(&quot;Saved view: &quot; + action.extra);
+		}
 	}
 	else if (cmd == &quot;viewload&quot;) {
-		LoadView(action.extra);
+		if (!LoadView(action.extra))
+			logOutput.Print(&quot;Loading view failed!&quot;);
 	}
 	else if (cmd == &quot;toggleoverview&quot;) {
 		ToggleOverviewCamera();
 	}
 }
 
+
 bool CCameraHandler::LoadViewData(const ViewData&amp; vd)
 {
-	if (vd.state.size() &lt;= 0) {
+	if (vd.empty()) {
 		return false;
 	}
 
-	int currentMode = currCamCtrlNum;
-
-	if ((vd.mode == -1) ||
-			((vd.mode &gt;= 0) &amp;&amp; (vd.mode &lt; camControllers.size()))) {
-		const float3 dummy = currCamCtrl-&gt;SwitchFrom();
-		currCamCtrlNum = vd.mode;
-		currCamCtrl = camControllers[currCamCtrlNum];
-		const bool showMode = (currentMode != vd.mode);
-		currCamCtrl-&gt;SwitchTo(showMode);
-		CameraTransition(1.0f);
+	ViewData::const_iterator it = vd.find(&quot;mode&quot;);
+	if (it != vd.end()) {
+		const unsigned int camMode = (unsigned int)it-&gt;second;
+		if (camMode &gt;= camControllers.size()) {
+			return false;
+		}
+		const unsigned int currentMode = currCamCtrlNum;
+		if (camMode != currCamCtrlNum) {
+			currCamCtrlNum = camMode;
+			currCamCtrl = camControllers[camMode];
+			const bool showMode = (camMode != currentMode);
+			currCamCtrl-&gt;SwitchTo(showMode);
+			CameraTransition(1.0f);
+		}
 	}
-
-	return currCamCtrl-&gt;SetState(vd.state);
+	return currCamCtrl-&gt;SetState(vd);
 }
 

Modified: branches/gml/rts/Game/CameraHandler.h
===================================================================
--- branches/gml/rts/Game/CameraHandler.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/CameraHandler.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -7,55 +7,66 @@
 #include &lt;stack&gt;
 
 #include &quot;Console.h&quot;
+#include &quot;Camera/CameraController.h&quot;
 
-class CCameraController;
 
-
-class CCameraHandler : public CommandReciever
+class CCameraHandler : public CommandReceiver
 {
 public:
+	typedef CCameraController::StateMap ViewData;
+
+public:
 	CCameraHandler();
 	~CCameraHandler();
 	
 	void UpdateCam();
-	void SetCameraMode(unsigned mode);
+	void SetCameraMode(unsigned int mode);
+	void SetCameraMode(const std::string&amp; mode);
 	void PushMode();
 	void PopMode();
 	void CameraTransition(float time);
-	
+
 	void ToggleState();
-	void ToggleOverviewCamera(void);
+	void ToggleOverviewCamera();
 	
 	void SaveView(const std::string&amp; name);
 	bool LoadView(const std::string&amp; name);
+
+	int GetModeIndex(const std::string&amp; modeName) const;
 	
+	/**
+	@brief write current camera settings in a vector
+	*/
+	void GetState(CCameraController::StateMap&amp; sm) const;
+	
+	/**
+	@brief restore a camera state
+	@param fv the state to set
+	@return false when vector has wrong size or garbage data, true when aplied without errors
+	*/
+	bool SetState(const CCameraController::StateMap&amp; sm);
+	
 	CCameraController&amp; GetCurrentController() {return *currCamCtrl;};
 	int GetCurrentControllerNum() const {return currCamCtrlNum;};
+	const std::string GetCurrentControllerName() const;
 	const std::vector&lt;CCameraController*&gt;&amp; GetAvailableControllers() const {return camControllers;};
 	
 	virtual void PushAction(const Action&amp;);
 	
 private:
 	std::vector&lt;CCameraController*&gt; camControllers;
-	std::stack&lt;unsigned&gt; controllerStack;
+	std::stack&lt;unsigned int&gt; controllerStack;
 	CCameraController* currCamCtrl;
-	int currCamCtrlNum;
+	unsigned int currCamCtrlNum;
 	
 	float cameraTime;
 	float cameraTimeLeft;
 	float cameraTimeFactor;
 	float cameraTimeExponent;
 	
-	struct ViewData {
-		bool operator==(const ViewData&amp; vd) const {
-			return (mode == vd.mode) &amp;&amp; (state == vd.state);
-		}
-		int mode;
-		std::vector&lt;float&gt; state;
-	};
-	bool LoadViewData(const ViewData&amp; vd);	
-	ViewData tmpView;
+	bool LoadViewData(const ViewData&amp; vd);
 	std::map&lt;std::string, ViewData&gt; views;
+	std::map&lt;std::string, unsigned int&gt; nameMap;
 };
 
 extern CCameraHandler* camHandler;

Modified: branches/gml/rts/Game/ChatMessage.cpp
===================================================================
--- branches/gml/rts/Game/ChatMessage.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/ChatMessage.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -10,7 +10,7 @@
 {
 }
 
-ChatMessage::ChatMessage(const netcode::RawPacket&amp; data)
+ChatMessage::ChatMessage(boost::shared_ptr&lt;const netcode::RawPacket&gt; data)
 {
 	UnpackPacket packet(data);
 	unsigned char ID;

Modified: branches/gml/rts/Game/ChatMessage.h
===================================================================
--- branches/gml/rts/Game/ChatMessage.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/ChatMessage.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,6 +1,8 @@
 #ifndef CHAT_MESSAGE_H
 #define CHAT_MESSAGE_H
 
+#include &lt;boost/shared_ptr.hpp&gt;
+
 #include &quot;Action.h&quot;
 
 namespace netcode {
@@ -11,7 +13,7 @@
 {
 public:
 	ChatMessage(int fromP, int dest, const std::string&amp; chat);
-	ChatMessage(const netcode::RawPacket&amp; packet);
+	ChatMessage(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet);
 
 	const netcode::RawPacket* Pack() const;
 

Modified: branches/gml/rts/Game/CommandMessage.cpp
===================================================================
--- branches/gml/rts/Game/CommandMessage.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/CommandMessage.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -20,7 +20,7 @@
 	player = playernum;
 }
 
-CommandMessage::CommandMessage(const netcode::RawPacket&amp; pckt)
+CommandMessage::CommandMessage(boost::shared_ptr&lt;const netcode::RawPacket&gt; pckt)
 {
 	UnpackPacket packet(pckt);
 	unsigned char ID;

Modified: branches/gml/rts/Game/CommandMessage.h
===================================================================
--- branches/gml/rts/Game/CommandMessage.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/CommandMessage.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -2,6 +2,7 @@
 #define COMMANDMESSAGE_H
 
 #include &lt;string&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
 
 #include &quot;Action.h&quot;
 
@@ -15,7 +16,7 @@
 public:
 	CommandMessage(const std::string&amp; cmd, int playernum);
 	CommandMessage(const Action&amp; action, int playernum);
-	CommandMessage(const netcode::RawPacket&amp; packet);
+	CommandMessage(boost::shared_ptr&lt;const netcode::RawPacket&gt;);
 
 	const netcode::RawPacket* Pack() const;
 

Modified: branches/gml/rts/Game/Console.cpp
===================================================================
--- branches/gml/rts/Game/Console.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Console.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -3,9 +3,9 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;Action.h&quot;
 
-void CommandReciever::RegisterAction(const std::string&amp; name)
+void CommandReceiver::RegisterAction(const std::string&amp; name)
 {
-	Console::Instance().AddCommandReciever(name, this);
+	Console::Instance().AddCommandReceiver(name, this);
 }
 
 Console&amp; Console::Instance()
@@ -14,7 +14,7 @@
 	return myInstance;
 }
 
-void Console::AddCommandReciever(const std::string&amp; name, CommandReciever* rec)
+void Console::AddCommandReceiver(const std::string&amp; name, CommandReceiver* rec)
 {
 	if (commandMap.find(name) != commandMap.end())
 		logOutput.Print(&quot;Overwriting command: %s&quot;, name.c_str());
@@ -26,14 +26,14 @@
 	if (action.command == &quot;commands&quot;)
 	{
 		logOutput.Print(&quot;Registered commands:&quot;);
-		for (std::map&lt;const std::string, CommandReciever*&gt;::iterator it = commandMap.begin(); it != commandMap.end(); ++it)
+		for (std::map&lt;const std::string, CommandReceiver*&gt;::iterator it = commandMap.begin(); it != commandMap.end(); ++it)
 		{
 			logOutput.Print(it-&gt;first);
 		}
 		return true;
 	}
 	
-	std::map&lt;const std::string, CommandReciever*&gt;::iterator it = commandMap.find(action.command);
+	std::map&lt;const std::string, CommandReceiver*&gt;::iterator it = commandMap.find(action.command);
 	if (it == commandMap.end())
 		return false;
 	else

Modified: branches/gml/rts/Game/Console.h
===================================================================
--- branches/gml/rts/Game/Console.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Console.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -9,11 +9,11 @@
 /**
 @brief this class can recieve commands (actions)
  */
-class CommandReciever
+class CommandReceiver
 {
 public:
-	CommandReciever() {};
-	virtual ~CommandReciever() {};
+	CommandReceiver() {};
+	virtual ~CommandReceiver() {};
 	
 	/**
 	@brief callback function for all registered commands
@@ -40,9 +40,9 @@
 	/**
 	@brief register a command
 	@param name the name of the command (e.g. &quot;cheat&quot;)
-	@param rec the CommandReciever who want to recieve the command
+	@param rec the CommandReceiver who want to recieve the command
 	*/
-	void AddCommandReciever(const std::string&amp; name, CommandReciever* rec);
+	void AddCommandReceiver(const std::string&amp; name, CommandReceiver* rec);
 	
 	/**
 	@brief Execute an action
@@ -52,7 +52,7 @@
 private:
 	Console();
 	~Console();
-	std::map&lt;const std::string, CommandReciever*&gt; commandMap;
+	std::map&lt;const std::string, CommandReceiver*&gt; commandMap;
 };
 
 #endif

Modified: branches/gml/rts/Game/Game.cpp
===================================================================
--- branches/gml/rts/Game/Game.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Game.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -90,7 +90,6 @@
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
-#include &quot;Sim/Misc/SensorHandler.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
@@ -161,6 +160,7 @@
 
 CGame* game = NULL;
 
+
 CR_BIND(CGame, (std::string(&quot;&quot;), std::string(&quot;&quot;), NULL, NULL));
 
 CR_REG_METADATA(CGame,(
@@ -212,6 +212,8 @@
 	timeLeft = 0.0f;
 	consumeSpeed = 1.0f;
 
+	memset(gameID, 0, sizeof(gameID));
+
 	infoConsole = ic;
 
 	script = NULL;
@@ -292,6 +294,7 @@
 	camHandler = SAFE_NEW CCameraHandler();
 	selectionKeys = SAFE_NEW CSelectionKeyHandler();
 	tooltip = SAFE_NEW CTooltipConsole();
+	iconHandler = SAFE_NEW CIconHandler();
 
 	ENTER_MIXED;
 
@@ -357,7 +360,6 @@
 	ph = SAFE_NEW CProjectileHandler();
 
 	ENTER_SYNCED;
-	sensorHandler = SAFE_NEW CSensorHandler();
 	damageArrayHandler = SAFE_NEW CDamageArrayHandler();
 	unitDefHandler = SAFE_NEW CUnitDefHandler();
 
@@ -386,7 +388,6 @@
 
 	ENTER_MIXED;
 	uh = SAFE_NEW CUnitHandler();
-	iconHandler = SAFE_NEW CIconHandler();
 	unitDrawer = SAFE_NEW CUnitDrawer();
 	fartextureHandler = SAFE_NEW CFartextureHandler();
 	modelParser = SAFE_NEW C3DModelParser();
@@ -399,7 +400,7 @@
 	defsParser = NULL;
 
 	ENTER_UNSYNCED;
-	sky=CBaseSky::GetSky();
+	sky = CBaseSky::GetSky();
 
 	resourceBar = SAFE_NEW CResourceBar();
 	keyCodes = SAFE_NEW CKeyCodes();
@@ -476,10 +477,12 @@
 
 	chatSound = sound-&gt;GetWaveId(&quot;sounds/beep4.wav&quot;);
 
-	if (!saveFile) UnloadStartPicture();
+	if (!saveFile) {
+		UnloadStartPicture();
+	}
 	
 	net-&gt;loading = false;
-		thread.join();
+	thread.join();
 	logOutput.Print(&quot;Spring %s&quot;,VERSION_STRING);
 	//sending your playername to the server indicates that you are finished loading
 	net-&gt;SendPlayerName(gu-&gt;myPlayerNum, p-&gt;playerName);
@@ -564,6 +567,7 @@
 	delete hpiHandler;         hpiHandler         = NULL;
 	delete archiveScanner;     archiveScanner     = NULL;
 	delete modelParser;        modelParser        = NULL;
+	delete iconHandler;        iconHandler        = NULL;
 	delete fartextureHandler;  fartextureHandler  = NULL;
 	delete camera;             camera             = NULL;
 	delete cam2;               cam2               = NULL;
@@ -581,6 +585,7 @@
 	CColorMap::DeleteColormaps();
 }
 
+
 void CGame::PostLoad()
 {
 	if (gameServer) {
@@ -588,6 +593,7 @@
 	}
 }
 
+
 void CGame::ResizeEvent()
 {
 	if (minimap != NULL) {
@@ -798,8 +804,8 @@
 	// try the input receivers
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
-	for(ri=inputReceivers.begin();ri!=inputReceivers.end();++ri){
-		if((*ri) &amp;&amp; (*ri)-&gt;KeyPressed(k, isRepeat)) {
+	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
+		if ((*ri) &amp;&amp; (*ri)-&gt;KeyPressed(k, isRepeat)) {
 			return 0;
 		}
 	}
@@ -820,16 +826,17 @@
 {
 	//	keys[k] = false;
 
-	if ((userWriting) &amp;&amp; (((k&gt;=' ') &amp;&amp; (k&lt;='Z')) || (k==8) || (k==190) )){
+	if ((userWriting) &amp;&amp; (((k&gt;=' ') &amp;&amp; (k&lt;='Z')) || (k==8) || (k==190))) {
 		return 0;
 	}
 
 	// try the input receivers
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
-	for(ri=inputReceivers.begin();ri!=inputReceivers.end();++ri){
-		if((*ri) &amp;&amp; (*ri)-&gt;KeyReleased(k))
+	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
+		if ((*ri) &amp;&amp; (*ri)-&gt;KeyReleased(k)) {
 			return 0;
+		}
 	}
 
 	// try our list of actions
@@ -930,13 +937,13 @@
 	}
 	else if (cmd == &quot;w&quot;) {
 		const int pos = action.extra.find_first_of(&quot; &quot;);
-		if (pos != std::string::npos)
-		{
+		if (pos != std::string::npos) {
 			const int playernum = gs-&gt;Player(action.extra.substr(0, pos));
-			if (playernum &gt;= 0)
+			if (playernum &gt;= 0) {
 				SendNetChat(action.extra.substr(pos+1), playernum);
-			else
+			} else {
 				logOutput.Print(&quot;Player not found: %s&quot;, action.extra.substr(0, pos).c_str());
+			}
 		}
 	}
 	else if (cmd == &quot;echo&quot;) {
@@ -944,24 +951,21 @@
 	}
 	else if (cmd == &quot;setf&quot;) {
 		const int pos = action.extra.find_first_of(&quot; &quot;);
-		if (pos != std::string::npos)
-		{
+		if (pos != std::string::npos) {
 			const std::string varName = action.extra.substr(0, pos);
 			configHandler.SetFloat(varName, atof(action.extra.substr(pos+1).c_str()));
 		}
 	}
 	else if (cmd == &quot;seti&quot;) {
 		const int pos = action.extra.find_first_of(&quot; &quot;);
-		if (pos != std::string::npos)
-		{
+		if (pos != std::string::npos) {
 			const std::string varName = action.extra.substr(0, pos);
 			configHandler.SetInt(varName, atoi(action.extra.substr(pos+1).c_str()));
 		}
 	}
 	else if (cmd == &quot;sets&quot;) {
 		const int pos = action.extra.find_first_of(&quot; &quot;);
-		if (pos != std::string::npos)
-		{
+		if (pos != std::string::npos) {
 			const std::string varName = action.extra.substr(0, pos);
 			configHandler.SetString(varName, action.extra.substr(pos+1));
 		}
@@ -1745,6 +1749,22 @@
 			ParseInputTextGeometry(action.extra);
 		}
 	}
+	else if (cmd == &quot;disticon&quot;) {
+		if (!action.extra.empty()) {
+			const int iconDist = atoi(action.extra.c_str());
+			unitDrawer-&gt;SetUnitIconDist((float)iconDist);
+			configHandler.SetInt(&quot;UnitIconDist&quot;, iconDist);
+			logOutput.Print(&quot;Set UnitIconDist to %i&quot;, iconDist);
+		}
+	}
+	else if (cmd == &quot;distdraw&quot;) {
+		if (!action.extra.empty()) {
+			const int drawDist = atoi(action.extra.c_str());
+			unitDrawer-&gt;SetUnitDrawDist((float)drawDist);
+			configHandler.SetInt(&quot;UnitLodDist&quot;, drawDist);
+			logOutput.Print(&quot;Set UnitLodDist to %i&quot;, drawDist);
+		}
+	}
 	else if (cmd == &quot;lodscale&quot;) {
 		if (!action.extra.empty()) {
 			vector&lt;string&gt; args = CSimpleParser::Tokenize(action.extra, 0);
@@ -1851,7 +1871,8 @@
 			cmd == &quot;desync&quot; ||
 #endif
 			cmd == &quot;resync&quot; ||
-			cmd == &quot;take&quot;) {
+			cmd == &quot;take&quot; ||
+			cmd == &quot;luarules&quot;) {
 		//these are synced commands, forward only
 		CommandMessage pckt(action, gu-&gt;myPlayerNum);
 		net-&gt;SendData(pckt.Pack());
@@ -1938,7 +1959,7 @@
 	}
 }
 
-void CGame::ActionRecieved(const Action&amp; action, int playernum)
+void CGame::ActionReceived(const Action&amp; action, int playernum)
 {
 	if (action.command == &quot;cheat&quot;) {
 		SetBoolArg(gs-&gt;cheatEnabled, action.extra);
@@ -2176,64 +2197,65 @@
 		else
 			logOutput.Print(&quot;No definition Editing&quot;);
 	}
-	else if (action.command == &quot;luarules&quot; &amp;&amp; (gs-&gt;frameNum &gt; 1)) {
+	else if ((action.command == &quot;luarules&quot;) &amp;&amp; (gs-&gt;frameNum &gt; 1)) {
 		if (gs-&gt;useLuaRules) {
-			if (action.extra == &quot;reload&quot;) {
+			if ((action.extra == &quot;reload&quot;) &amp;&amp; (playernum == 0)) {
 				if (!gs-&gt;cheatEnabled) {
-					logOutput.Print(&quot;Cheating required to reload synced scripts\n&quot;);
+					logOutput.Print(&quot;Cheating required to reload synced scripts&quot;);
 				} else {
 					CLuaRules::FreeHandler();
 					CLuaRules::LoadHandler();
-					if (luaRules)
-						logOutput.Print(&quot;LuaRules reloaded\n&quot;);
-					else
-						logOutput.Print(&quot;LuaRules reload failed\n&quot;);
+					if (luaRules) {
+						logOutput.Print(&quot;LuaRules reloaded&quot;);
+					} else {
+						logOutput.Print(&quot;LuaRules reload failed&quot;);
+					}
 				}
 			}
-			else if (action.extra == &quot;disable&quot;) {
+			else if ((action.extra == &quot;disable&quot;) &amp;&amp; (playernum == 0)) {
 				if (!gs-&gt;cheatEnabled) {
-					logOutput.Print(&quot;Cheating required to disable synced scripts\n&quot;);
+					logOutput.Print(&quot;Cheating required to disable synced scripts&quot;);
 				} else {
 					CLuaRules::FreeHandler();
-					logOutput.Print(&quot;LuaRules disabled\n&quot;);
+					logOutput.Print(&quot;LuaRules disabled&quot;);
 				}
 			}
 			else if (luaRules) {
 				luaRules-&gt;GotChatMsg(action.extra, playernum);
 			}
 			else {
-				logOutput.Print(&quot;LuaRules is not enabled\n&quot;);
+				logOutput.Print(&quot;LuaRules is not enabled&quot;);
 			}
 		}
 	}
-	else if (action.command == &quot;luagaia&quot; &amp;&amp; (gs-&gt;frameNum &gt; 1)) {
+	else if ((action.command == &quot;luagaia&quot;) &amp;&amp; (gs-&gt;frameNum &gt; 1)) {
 		if (gs-&gt;useLuaGaia) {
-			if (action.extra == &quot;reload&quot;) {
+			if ((action.extra == &quot;reload&quot;) &amp;&amp; (playernum == 0)) {
 				if (!gs-&gt;cheatEnabled) {
-					logOutput.Print(&quot;Cheating required to reload synced scripts\n&quot;);
+					logOutput.Print(&quot;Cheating required to reload synced scripts&quot;);
 				} else {
 					CLuaGaia::FreeHandler();
 					CLuaGaia::LoadHandler();
 					if (luaGaia) {
-						logOutput.Print(&quot;LuaGaia reloaded\n&quot;);
+						logOutput.Print(&quot;LuaGaia reloaded&quot;);
 					} else {
-						logOutput.Print(&quot;LuaGaia reload failed\n&quot;);
+						logOutput.Print(&quot;LuaGaia reload failed&quot;);
 					}
 				}
 			}
-			else if (action.extra == &quot;disable&quot;) {
+			else if ((action.extra == &quot;disable&quot;) &amp;&amp; (playernum == 0)) {
 				if (!gs-&gt;cheatEnabled) {
-					logOutput.Print(&quot;Cheating required to disable synced scripts\n&quot;);
+					logOutput.Print(&quot;Cheating required to disable synced scripts&quot;);
 				} else {
 					CLuaGaia::FreeHandler();
-					logOutput.Print(&quot;LuaGaia disabled\n&quot;);
+					logOutput.Print(&quot;LuaGaia disabled&quot;);
 				}
 			}
 			else if (luaGaia) {
 				luaGaia-&gt;GotChatMsg(action.extra, playernum);
 			}
 			else {
-				logOutput.Print(&quot;LuaGaia is not enabled\n&quot;);
+				logOutput.Print(&quot;LuaGaia is not enabled&quot;);
 			}
 		}
 	}
@@ -2327,11 +2349,11 @@
 	time(&amp;fpstimer);
 
 	if (difftime(fpstimer, starttime) != 0) {		//do once every second
-		fps=thisFps;
-		thisFps=0;
+		fps = thisFps;
+		thisFps = 0;
 
-		starttime=fpstimer;
-		oldframenum=gs-&gt;frameNum;
+		starttime = fpstimer;
+		oldframenum = gs-&gt;frameNum;
 
 		if (!gameServer) {
 			consumeSpeed = ((float)(GAME_SPEED * gs-&gt;speedFactor + leastQue - 2));
@@ -2346,18 +2368,22 @@
 		CInputReceiver::CollectGarbage();
 	}
 
-	if (!skipping)
+	if (!skipping) {
 		UpdateUI();
+	}
+
 	net-&gt;Update();
 
 #ifdef DEBUG
-	if(gameServer)
-		gameServer-&gt;gameClientUpdated=true;
+	if (gameServer) {
+		gameServer-&gt;gameClientUpdated = true;
+	}
 #endif
 
 #ifdef SYNCIFY		//syncify doesnt support multithreading ...
-	if (gameServer)
+	if (gameServer) {
 		gameServer-&gt;Update();
+	}
 #endif
 
 	if(creatingVideo &amp;&amp; playing &amp;&amp; gameServer){
@@ -2365,24 +2391,22 @@
 	}
 
 	ClientReadNet();
-	if(!net-&gt;IsActiveConnection() &amp;&amp; !gameOver){
+	if (!net-&gt;IsActiveConnection() &amp;&amp; !gameOver) {
 		logOutput.Print(&quot;Lost connection to gameserver&quot;);
-		gameOver=true;
+		gameOver = true;
 		luaCallIns.GameOver();
 		GameEnd();
 	}
 
-	if( gameServer &amp;&amp; !gameServer-&gt;GameHasStarted() &amp;&amp; !gameSetup)
-	{
+	if (gameServer &amp;&amp; !gameServer-&gt;GameHasStarted() &amp;&amp; !gameSetup) {
 		bool allReady = true;
-		for(int a=0;a&lt;gs-&gt;activePlayers;a++) {
+		for (int a = 0; a &lt; gs-&gt;activePlayers; a++) {
 			if(gs-&gt;players[a]-&gt;active &amp;&amp; !gs-&gt;players[a]-&gt;readyToStart) {
-				allReady=false;
+				allReady = false;
 				break;
 			}
 		}
-		if (allReady &amp;&amp; (keys[SDLK_RETURN] || script-&gt;onlySinglePlayer))
-		{
+		if (allReady &amp;&amp; (keys[SDLK_RETURN] || script-&gt;onlySinglePlayer)) {
 			chatting = false;
 			userWriting = false;
 			writingPos = 0;
@@ -2601,11 +2625,13 @@
 	camHandler-&gt;UpdateCam();
 	mouse-&gt;UpdateCursors();
 
-	if(unitTracker.Enabled())
+	if (unitTracker.Enabled()) {
 		unitTracker.SetCam();
+	}
 
-	if(playing &amp;&amp; (hideInterface || script-&gt;wantCameraControl))
+	if (playing &amp;&amp; (hideInterface || script-&gt;wantCameraControl)) {
 		script-&gt;SetCamera();
+	}
 
 	CBaseGroundDrawer* gd;
 	{
@@ -2677,7 +2703,7 @@
 	}
 
 #ifdef DIRECT_CONTROL_ALLOWED
-	if(gu-&gt;directControl){
+	if (gu-&gt;directControl) {
 		DrawDirectControlHud();
 	}
 #endif
@@ -2709,16 +2735,19 @@
 
 	glEnable(GL_TEXTURE_2D);
 
-	if(gu-&gt;drawdebug){
+	if (gu-&gt;drawdebug) {
 		//skriv ut fps etc
 		glColor4f(1,1,0.5f,0.8f);
-		font-&gt;glFormatAt(0.03f, 0.02f, 1.0f, &quot;FPS %d Frame %d Part %d(%d)&quot;,fps,gs-&gt;frameNum,ph-&gt;ps.size(),ph-&gt;currentParticles);
+		font-&gt;glFormatAt(0.03f, 0.02f, 1.0f, &quot;FPS %d Frame %d Part %d(%d)&quot;,
+		                 fps, gs-&gt;frameNum, ph-&gt;ps.size(), ph-&gt;currentParticles);
 
-		if(playing)
-			font-&gt;glFormatAt(0.03f, 0.07f, 0.7f, &quot;xpos: %5.0f ypos: %5.0f zpos: %5.0f speed %2.2f&quot;,camera-&gt;pos.x,camera-&gt;pos.y,camera-&gt;pos.z,gs-&gt;speedFactor);
+		if (playing) {
+			font-&gt;glFormatAt(0.03f, 0.07f, 0.7f, &quot;xpos: %5.0f ypos: %5.0f zpos: %5.0f speed %2.2f&quot;,
+			                 camera-&gt;pos.x, camera-&gt;pos.y, camera-&gt;pos.z, gs-&gt;speedFactor);
+		}
 	}
 
-	if( gameServer &amp;&amp; gameServer-&gt;WaitsOnCon() &amp;&amp;!gameSetup){
+	if (gameServer &amp;&amp; gameServer-&gt;WaitsOnCon() &amp;&amp; !gameSetup) {
 		glColor3f(1.0f, 1.0f, 1.0f);
 		font-&gt;glPrintCentered (0.5f, 0.5f, 1.5f, &quot;Waiting for connections. Press return to start&quot;);
 	}
@@ -2772,7 +2801,7 @@
 		}
 	}
 
-	if (playerRoster.GetSortType() != PlayerRoster::Disabled){
+	if (playerRoster.GetSortType() != PlayerRoster::Disabled) {
 		char buf[128];
 		const float fontScale = 1.0f;
 		int count;
@@ -2829,12 +2858,12 @@
 	lastMoveUpdate = start;
 
 #ifndef NO_AVI
-	if(creatingVideo){
-		gu-&gt;lastFrameTime=1.0f/GAME_SPEED;
+	if (creatingVideo) {
+		gu-&gt;lastFrameTime = 1.0f/GAME_SPEED;
 		if(!aviGenerator-&gt;readOpenglPixelDataThreaded()){
 			creatingVideo = false;
 			delete aviGenerator;
-			aviGenerator = 0;
+			aviGenerator = NULL;
 		}
 //		logOutput.Print(&quot;Saved avi frame size %i %i&quot;,ih-&gt;biWidth,ih-&gt;biHeight);
 	}
@@ -3126,7 +3155,7 @@
 	PUSH_CODE_MODE;
 	ENTER_SYNCED;
 
-	const RawPacket* packet = NULL;
+	boost::shared_ptr&lt;const netcode::RawPacket&gt; packet;
 
 	// compute new timeLeft to &quot;smooth&quot; out SimFrame() calls
 	if(!gameServer){
@@ -3143,7 +3172,7 @@
 		// we still have to process (in variable &quot;que&quot;)
 		int que = 0; // Number of NETMSG_NEWFRAMEs waiting to be processed.
 		unsigned ahead = 0;
-		while ((packet = net-&gt;Peek(ahead)) != NULL)
+		while ((packet = net-&gt;Peek(ahead)))
 		{
 			if (packet-&gt;data[0] == NETMSG_NEWFRAME || packet-&gt;data[0] == NETMSG_KEYFRAME)
 				++que;
@@ -3161,7 +3190,7 @@
 	}
 
 	// really process the messages
-	while (timeLeft &gt; 0.0f &amp;&amp; (packet = net-&gt;GetData()) != NULL)
+	while (timeLeft &gt; 0.0f &amp;&amp; (packet = net-&gt;GetData()))
 	{
 		const unsigned char* inbuf = packet-&gt;data;
 		const unsigned dataLength = packet-&gt;length;
@@ -3221,12 +3250,11 @@
 
 			case NETMSG_STARTPLAYING: {
 				unsigned timeToStart = *(unsigned*)(inbuf+1);
-				if (timeToStart &gt; 0)
-				{
+				if (timeToStart &gt; 0) {
 					GameSetupDrawer::StartCountdown(timeToStart);
+				} else {
+					StartPlaying();
 				}
-				else
-					StartPlaying();
 				AddTraffic(-1, packetCode, dataLength);
 				break;
 			}
@@ -3266,8 +3294,9 @@
 				*gs-&gt;players[player]-&gt;currentStats = *(CPlayer::Statistics*)&amp;inbuf[2];
 				if (gameOver) {
 					CDemoRecorder* record = net-&gt;GetDemoRecorder();
-					if (record != NULL)
+					if (record != NULL) {
 						record-&gt;SetPlayerStats(player, *gs-&gt;players[player]-&gt;currentStats);
+					}
 				}
 				AddTraffic(player, packetCode, dataLength);
 				break;
@@ -3332,15 +3361,16 @@
 				gs-&gt;players[player]-&gt;playerName=(char*)(&amp;inbuf[3]);
 				gs-&gt;players[player]-&gt;readyToStart=true;
 				gs-&gt;players[player]-&gt;active=true;
-				if (net-&gt;GetDemoRecorder())
+				if (net-&gt;GetDemoRecorder()) {
 					net-&gt;GetDemoRecorder()-&gt;SetMaxPlayerNum(inbuf[2]);
+				}
 				wordCompletion-&gt;AddWord(gs-&gt;players[player]-&gt;playerName, false, false, false); // required?
 				AddTraffic(player, packetCode, dataLength);
 				break;
 			}
 
 			case NETMSG_CHAT: {
-				ChatMessage msg(*packet);
+				ChatMessage msg(packet);
 				HandleChatMsg(msg);
 				AddTraffic(msg.fromPlayer, packetCode, dataLength);
 				break;
@@ -3356,14 +3386,15 @@
 			case NETMSG_STARTPOS:{
 				unsigned player = inbuf[1];
 				int team = inbuf[2];
-				if(team&gt;=gs-&gt;activeTeams || team&lt;0 || !gameSetup){
+				if ((team &gt;= gs-&gt;activeTeams) || (team &lt; 0) || !gameSetup) {
 					logOutput.Print(&quot;Got invalid team num %i in startpos msg&quot;,team);
 				} else {
-					if(inbuf[3]!=2)
-						gameSetup-&gt;readyTeams[team]=!!inbuf[3];
-					gs-&gt;Team(team)-&gt;startPos.x=*(float*)&amp;inbuf[4];
-					gs-&gt;Team(team)-&gt;startPos.y=*(float*)&amp;inbuf[8];
-					gs-&gt;Team(team)-&gt;startPos.z=*(float*)&amp;inbuf[12];
+					if (inbuf[3] != 2) {
+						gameSetup-&gt;readyTeams[team] = !!inbuf[3];
+					}
+					gs-&gt;Team(team)-&gt;startPos.x = *(float*)&amp;inbuf[4];
+					gs-&gt;Team(team)-&gt;startPos.y = *(float*)&amp;inbuf[8];
+					gs-&gt;Team(team)-&gt;startPos.z = *(float*)&amp;inbuf[12];
 				}
 				AddTraffic(player, packetCode, dataLength);
 				break;
@@ -3378,8 +3409,10 @@
 			case NETMSG_GAMEID: {
 				const unsigned char* p = &amp;inbuf[1];
 				CDemoRecorder* record = net-&gt;GetDemoRecorder();
-				if (record != NULL)
+				if (record != NULL) {
 					record-&gt;SetGameID(p);
+				}
+				memcpy(gameID, p, sizeof(gameID));
 				logOutput.Print(
 				  &quot;GameID: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&quot;,
 				  p[ 0], p[ 1], p[ 2], p[ 3], p[ 4], p[ 5], p[ 6], p[ 7],
@@ -3393,15 +3426,11 @@
 #ifndef SYNCCHECK
 				net-&gt;SendKeyFrame(serverframenum-1);
 #endif
-				if (gs-&gt;frameNum == (serverframenum - 1))
-				{
+				if (gs-&gt;frameNum == (serverframenum - 1)) {
 					// everything ok, fall through
+				} else {
+					break; // error
 				}
-				else
-				{
-					// error
-					break;
-				}
 			}
 			case NETMSG_NEWFRAME: {
 				timeLeft -= 1.0f;
@@ -3414,7 +3443,7 @@
 #endif
 				AddTraffic(-1, packetCode, dataLength);
 
-				if(creatingVideo &amp;&amp; net-&gt;localDemoPlayback){
+				if (creatingVideo &amp;&amp; net-&gt;localDemoPlayback) {
 					POP_CODE_MODE;
 					return;
 				}
@@ -3422,15 +3451,16 @@
 			}
 
 			case NETMSG_COMMAND: {
-				int player=inbuf[3];
-				if(player&gt;=MAX_PLAYERS || player&lt;0){
+				int player = inbuf[3];
+				if ((player &gt;= MAX_PLAYERS) || (player &lt; 0)) {
 					logOutput.Print(&quot;Got invalid player num %i in command msg&quot;,player);
 				} else {
 					Command c;
 					c.id=*((int*)&amp;inbuf[4]);
 					c.options=inbuf[8];
-					for(int a=0;a&lt;((*((short int*)&amp;inbuf[1])-9)/4);++a)
+					for(int a = 0; a &lt; ((*((short int*)&amp;inbuf[1])-9)/4); ++a) {
 						c.params.push_back(*((float*)&amp;inbuf[9+a*4]));
+					}
 					selectedUnits.NetOrder(c,player);
 				}
 				AddTraffic(player, packetCode, dataLength);
@@ -3439,20 +3469,21 @@
 
 			case NETMSG_SELECT: {
 				int player=inbuf[3];
-				if(player&gt;=MAX_PLAYERS || player&lt;0){
+				if ((player &gt;= MAX_PLAYERS) || (player &lt; 0)) {
 					logOutput.Print(&quot;Got invalid player num %i in netselect msg&quot;,player);
 				} else {
 					vector&lt;int&gt; selected;
-					for(int a=0;a&lt;((*((short int*)&amp;inbuf[1])-4)/2);++a){
+					for (int a = 0; a &lt; ((*((short int*)&amp;inbuf[1])-4)/2); ++a) {
 						int unitid=*((short int*)&amp;inbuf[4+a*2]);
 						if(unitid&gt;=MAX_UNITS || unitid&lt;0){
 							logOutput.Print(&quot;Got invalid unitid %i in netselect msg&quot;,unitid);
 							break;
 						}
 						if (uh-&gt;units[unitid] &amp;&amp;
-													(uh-&gt;units[unitid]-&gt;team == gs-&gt;players[player]-&gt;team) || gs-&gt;godMode) {
+						    (uh-&gt;units[unitid]-&gt;team == gs-&gt;players[player]-&gt;team) ||
+						    gs-&gt;godMode) {
 							selected.push_back(unitid);
-													}
+						}
 					}
 					selectedUnits.NetSelect(selected, player);
 				}
@@ -3460,8 +3491,6 @@
 				break;
 			}
 
-
-
 			case NETMSG_AICOMMAND: {
 				const int player = inbuf[3];
 				if (player &gt;= MAX_PLAYERS || player &lt; 0) {
@@ -3480,8 +3509,9 @@
 				c.options = inbuf[10];
 
 				// insert the command parameters
-				for (int a = 0; a &lt; ((*((short int*) &amp;inbuf[1]) - 11) / 4); ++a)
+				for (int a = 0; a &lt; ((*((short int*) &amp;inbuf[1]) - 11) / 4); ++a) {
 					c.params.push_back(*((float*) &amp;inbuf[11 + a * 4]));
+				}
 
 				selectedUnits.AiOrder(unitid,c);
 				AddTraffic(player, packetCode, dataLength);
@@ -3571,10 +3601,9 @@
 						u-&gt;ChangeTeam(dstTeam, CUnit::ChangeGiven);
 					}
 				}
-			} break;
+				break;
+			}
 
-
-
 			case NETMSG_LUAMSG: {
 				const int player = inbuf[3];
 				if ((player &lt; 0) || (player &gt;= MAX_PLAYERS)) {
@@ -3592,8 +3621,8 @@
 			case NETMSG_SYNCREQUEST: {
 				// TODO rename this net message, change error msg, etc.
 				ENTER_MIXED;
-				int frame=*((int*)&amp;inbuf[1]);
-				if(frame!=gs-&gt;frameNum){
+				int frame = *((int*)&amp;inbuf[1]);
+				if (frame != gs-&gt;frameNum) {
 					logOutput.Print(&quot;Sync request for wrong frame (%i instead of %i)&quot;, frame, gs-&gt;frameNum);
 				}
 				net-&gt;SendCPUUsage(profiler.profile[&quot;Sim time&quot;].percent);
@@ -3603,16 +3632,16 @@
 			}
 
 			case NETMSG_SHARE: {
-				int player=inbuf[1];
-				if(player&gt;=MAX_PLAYERS || player&lt;0){
+				int player = inbuf[1];
+				if ((player &gt;= MAX_PLAYERS) || (player &lt; 0)){
 					logOutput.Print(&quot;Got invalid player num %i in share msg&quot;,player);
 					break;
 				}
-				int team1=gs-&gt;players[player]-&gt;team;
-				int team2=inbuf[2];
-				bool shareUnits=!!inbuf[3];
-				float metalShare=std::min(*(float*)&amp;inbuf[4],(float)gs-&gt;Team(team1)-&gt;metal);
-				float energyShare=std::min(*(float*)&amp;inbuf[8],(float)gs-&gt;Team(team1)-&gt;energy);
+				int team1 = gs-&gt;players[player]-&gt;team;
+				int team2 = inbuf[2];
+				bool shareUnits = !!inbuf[3];
+				float metalShare = std::min(*(float*)&amp;inbuf[4], (float)gs-&gt;Team(team1)-&gt;metal);
+				float energyShare = std::min(*(float*)&amp;inbuf[8], (float)gs-&gt;Team(team1)-&gt;energy);
 
 				if (metalShare != 0.0f) {
 					if (!luaRules || luaRules-&gt;AllowResourceTransfer(team1, team2, &quot;m&quot;, metalShare)) {
@@ -3627,13 +3656,16 @@
 					}
 				}
 
-				if(shareUnits){
-					for(vector&lt;int&gt;::iterator ui=selectedUnits.netSelected[player].begin();ui!=selectedUnits.netSelected[player].end();++ui){
-						if(uh-&gt;units[*ui] &amp;&amp; uh-&gt;units[*ui]-&gt;team==team1 &amp;&amp; !uh-&gt;units[*ui]-&gt;beingBuilt){
-							uh-&gt;units[*ui]-&gt;ChangeTeam(team2,CUnit::ChangeGiven);
+				if (shareUnits) {
+					vector&lt;int&gt;&amp; netSelUnits = selectedUnits.netSelected[player];
+					vector&lt;int&gt;::const_iterator ui;
+					for (ui = netSelUnits.begin(); ui != netSelUnits.end(); ++ui){
+						CUnit* unit = uh-&gt;units[*ui];
+						if (unit &amp;&amp; unit-&gt;team==team1 &amp;&amp; !unit-&gt;beingBuilt) {
+							unit-&gt;ChangeTeam(team2, CUnit::ChangeGiven);
 						}
 					}
-					selectedUnits.netSelected[player].clear();
+					netSelUnits.clear();
 				}
 				AddTraffic(player, packetCode, dataLength);
 				break;
@@ -3642,14 +3674,14 @@
 			case NETMSG_SETSHARE: {
 				int player=inbuf[1];
 				int team=inbuf[2];
-				if(team&gt;=gs-&gt;activeTeams || team&lt;0){
+				if ((team &gt;= gs-&gt;activeTeams) || (team &lt; 0)) {
 					logOutput.Print(&quot;Got invalid team num %i in setshare msg&quot;,team);
 				} else {
 					float metalShare=*(float*)&amp;inbuf[3];
 					float energyShare=*(float*)&amp;inbuf[7];
 
 					if (!luaRules || luaRules-&gt;AllowResourceLevel(team, &quot;m&quot;, metalShare)) {
-						gs-&gt;Team(team)-&gt;metalShare  = metalShare;
+						gs-&gt;Team(team)-&gt;metalShare = metalShare;
 					}
 					if (!luaRules || luaRules-&gt;AllowResourceLevel(team, &quot;e&quot;, energyShare)) {
 						gs-&gt;Team(team)-&gt;energyShare = energyShare;
@@ -3669,31 +3701,31 @@
 				const int fromTeam = gs-&gt;players[player]-&gt;team;
 
 				unsigned numPlayersInTeam = 0;
-				for (int a=0;a&lt;MAX_PLAYERS;++a)
-					if (gs-&gt;players[a]-&gt;active &amp;&amp; gs-&gt;players[a]-&gt;team == fromTeam)
+				for (int a = 0; a &lt; MAX_PLAYERS; ++a) {
+					if (gs-&gt;players[a]-&gt;active &amp;&amp; (gs-&gt;players[a]-&gt;team == fromTeam)) {
 						++numPlayersInTeam;
+					}
+				}
 
 				switch (action)
 				{
 					case TEAMMSG_SELFD: {
-						if (numPlayersInTeam == 1)
-						{
+						if (numPlayersInTeam == 1) {
 							gs-&gt;Team(fromTeam)-&gt;SelfDestruct();
 							gs-&gt;Team(fromTeam)-&gt;leader = -1;
+						} else {
+							gs-&gt;players[player]-&gt;StartSpectating();
 						}
-						else
-							gs-&gt;players[player]-&gt;StartSpectating();
 						break;
 					}
 					case TEAMMSG_GIVEAWAY: {
 						const int toTeam = inbuf[3];
-						if (numPlayersInTeam == 1)
-						{
+						if (numPlayersInTeam == 1) {
 							gs-&gt;Team(fromTeam)-&gt;GiveEverythingTo(toTeam);
 							gs-&gt;Team(fromTeam)-&gt;leader = -1;
+						} else {
+							gs-&gt;players[player]-&gt;StartSpectating();
 						}
-						else
-							gs-&gt;players[player]-&gt;StartSpectating();
 						break;
 					}
 					case TEAMMSG_RESIGN: {
@@ -3703,8 +3735,9 @@
 							unitTracker.Disable();
 							CLuaUI::UpdateTeams();
 						}
-						if (numPlayersInTeam == 1)
+						if (numPlayersInTeam == 1) {
 							gs-&gt;Team(fromTeam)-&gt;leader = -1;
+						}
 						logOutput.Print(&quot;Player %i resigned and is now spectating!&quot;, player);
 						break;
 					}
@@ -3716,15 +3749,18 @@
 						if (player == gu-&gt;myPlayerNum) {
 							gu-&gt;myTeam = newTeam;
 							gu-&gt;myAllyTeam = gs-&gt;AllyTeam(gu-&gt;myTeam);
-							gu-&gt;spectating = false;
+							gu-&gt;spectating           = false;
 							gu-&gt;spectatingFullView   = false;
 							gu-&gt;spectatingFullSelect = false;
+							gu-&gt;spectatingFullView   = false;
+							gu-&gt;spectatingFullSelect = false;
 							selectedUnits.ClearSelected();
 							unitTracker.Disable();
 							CLuaUI::UpdateTeams();
 						}
-						if (gs-&gt;Team(newTeam)-&gt;leader == -1)
+						if (gs-&gt;Team(newTeam)-&gt;leader == -1) {
 							gs-&gt;Team(newTeam)-&gt;leader = player;
+						}
 						break;
 					}
 					default: {
@@ -3738,23 +3774,27 @@
 				const int player = inbuf[1];
 				const int whichAllyTeam = inbuf[2];
 				const bool allied = static_cast&lt;bool&gt;(inbuf[3]);
-				if (whichAllyTeam &lt; MAX_TEAMS &amp;&amp; whichAllyTeam &gt;= 0)
+				if (whichAllyTeam &lt; MAX_TEAMS &amp;&amp; whichAllyTeam &gt;= 0) {
+					// FIXME - need to reset unit allyTeams
+					//       - need to reset unit texture for 3do
+					//       - need a call-in for lua and AIs
 					gs-&gt;SetAlly(gs-&gt;AllyTeam(gs-&gt;players[player]-&gt;team), whichAllyTeam, allied);
-				else
+				} else {
 					logOutput.Print(&quot;Player %i sent out wrong allyTeam index in alliance message&quot;, player);
+				}
 				break;
 			}
 			case NETMSG_CCOMMAND: {
-				CommandMessage msg(*packet);
-				ActionRecieved(msg.action, msg.player);
+				CommandMessage msg(packet);
+				ActionReceived(msg.action, msg.player);
 				break;
 			}
 
 #ifdef DIRECT_CONTROL_ALLOWED
 			case NETMSG_DIRECT_CONTROL: {
-				int player=inbuf[1];
+				int player = inbuf[1];
 
-				if(player&gt;=MAX_PLAYERS || player&lt;0){
+				if ((player &gt;= MAX_PLAYERS) || (player &lt; 0)) {
 					logOutput.Print(&quot;Got invalid player num %i in direct control msg&quot;,player);
 					break;
 				}
@@ -3781,10 +3821,10 @@
 							unit-&gt;directControl=&amp;gs-&gt;players[player]-&gt;myControl;
 							gs-&gt;players[player]-&gt;playerControlledUnit=unit;
 							ENTER_UNSYNCED;
-							if(player==gu-&gt;myPlayerNum){
-								gu-&gt;directControl=unit;
+							if (player == gu-&gt;myPlayerNum) {
+								gu-&gt;directControl = unit;
 								mouse-&gt;wasLocked = mouse-&gt;locked;
-								if(!mouse-&gt;locked){
+								if (!mouse-&gt;locked) {
 									mouse-&gt;locked = true;
 									mouse-&gt;HideMouse();
 								}
@@ -3802,13 +3842,13 @@
 			}
 
 			case NETMSG_DC_UPDATE: {
-				int player=inbuf[1];
-				if(player&gt;=MAX_PLAYERS || player&lt;0){
+				int player = inbuf[1];
+				if ((player &gt;= MAX_PLAYERS) || (player &lt; 0)){
 					logOutput.Print(&quot;Got invalid player num %i in dc update msg&quot;,player);
 					break;
 				}
-				DirectControlStruct* dc=&amp;gs-&gt;players[player]-&gt;myControl;
-				CUnit* unit=gs-&gt;players[player]-&gt;playerControlledUnit;
+				DirectControlStruct* dc = &amp;gs-&gt;players[player]-&gt;myControl;
+				CUnit* unit = gs-&gt;players[player]-&gt;playerControlledUnit;
 
 				dc-&gt;forward    = !!(inbuf[2] &amp; (1 &lt;&lt; 0));
 				dc-&gt;back       = !!(inbuf[2] &amp; (1 &lt;&lt; 1));
@@ -3848,7 +3888,6 @@
 				break;
 			}
 		}
-		delete packet;
 	}
 
 	POP_CODE_MODE;
@@ -3861,15 +3900,17 @@
 	ASSERT_UNSYNCED_MODE;
 	//move camera if arrow keys pressed
 #ifdef DIRECT_CONTROL_ALLOWED
-	if(gu-&gt;directControl){
-		CUnit* owner=gu-&gt;directControl;
+	if (gu-&gt;directControl) {
+		CUnit* owner = gu-&gt;directControl;
 
 		std::vector&lt;int&gt; args;
 		args.push_back(0);
 		owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary/*/COBFN_QueryPrimary+weaponNum/**/,args);
-		float3 relPos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
-		float3 pos=owner-&gt;pos+owner-&gt;frontdir*relPos.z+owner-&gt;updir*relPos.y+owner-&gt;rightdir*relPos.x;
-		pos+=UpVector*7;
+		float3 relPos = owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
+		float3 pos = owner-&gt;pos + owner-&gt;frontdir * relPos.z
+		                        + owner-&gt;updir    * relPos.y
+		                        + owner-&gt;rightdir * relPos.x;
+		pos += UpVector * 7;
 
 		camHandler-&gt;GetCurrentController().SetPos(pos);
 	} else
@@ -3941,7 +3982,7 @@
 
 	camHandler-&gt;GetCurrentController().Update();
 
-	if(chatting &amp;&amp; !userWriting){
+	if (chatting &amp;&amp; !userWriting) {
 		consoleHistory-&gt;AddLine(userInput);
 		string msg = userInput;
 		string pfx = &quot;&quot;;
@@ -3959,16 +4000,16 @@
 		writingPos = 0;
 	}
 
-	if(inMapDrawer-&gt;wantLabel &amp;&amp; !userWriting){
-		if(userInput.size()&gt;200){	//avoid troubles with to long lines
-			userInput=userInput.substr(0,200);
+	if (inMapDrawer-&gt;wantLabel &amp;&amp; !userWriting) {
+		if (userInput.size() &gt; 200) {	//avoid troubles with to long lines
+			userInput = userInput.substr(0, 200);
 			writingPos = (int)userInput.length();
 		}
 		inMapDrawer-&gt;CreatePoint(inMapDrawer-&gt;waitingPoint,userInput);
-		inMapDrawer-&gt;wantLabel=false;
-		userInput=&quot;&quot;;
+		inMapDrawer-&gt;wantLabel = false;
+		userInput = &quot;&quot;;
 		writingPos = 0;
-		ignoreChar=0;
+		ignoreChar = 0;
 	}
 }
 
@@ -3977,8 +4018,9 @@
 {
 	std::ofstream file(gameServer ? &quot;memdump.txt&quot; : &quot;memdumpclient.txt&quot;);
 
-	if (file.bad() || !file.is_open())
+	if (file.bad() || !file.is_open()) {
 		return;
+	}
 
 	file &lt;&lt; &quot;Frame &quot; &lt;&lt; gs-&gt;frameNum &lt;&lt;&quot;\n&quot;;
 	std::list&lt;CUnit*&gt;::iterator usi;
@@ -3998,10 +4040,10 @@
 	}
 	for(int a=0;a&lt;gs-&gt;activeTeams;++a){
 		file &lt;&lt; &quot;Losmap for team &quot; &lt;&lt; a &lt;&lt; &quot;\n&quot;;
-		for(int y=0;y&lt;gs-&gt;mapy&gt;&gt;sensorHandler-&gt;losMipLevel;++y){
+		for(int y=0;y&lt;gs-&gt;mapy&gt;&gt;modInfo.losMipLevel;++y){
 			file &lt;&lt; &quot; &quot;;
-			for(int x=0;x&lt;gs-&gt;mapx&gt;&gt;sensorHandler-&gt;losMipLevel;++x){
-				file &lt;&lt; loshandler-&gt;losMap[a][y*(gs-&gt;mapx&gt;&gt;sensorHandler-&gt;losMipLevel)+x] &lt;&lt; &quot; &quot;;
+			for(int x=0;x&lt;gs-&gt;mapx&gt;&gt;modInfo.losMipLevel;++x){
+				file &lt;&lt; loshandler-&gt;losMap[a][y*(gs-&gt;mapx&gt;&gt;modInfo.losMipLevel)+x] &lt;&lt; &quot; &quot;;
 			}
 			file &lt;&lt; &quot;\n&quot;;
 		}
@@ -4225,9 +4267,9 @@
 	SAFE_NEW CEndGameBox();
 	CDemoRecorder* record = net-&gt;GetDemoRecorder();
 	if (record != NULL) {
-	// Write CPlayer::Statistics and CTeam::Statistics to demo
+		// Write CPlayer::Statistics and CTeam::Statistics to demo
 		int numPlayers;
-	// FIXME: ugh, there should be a better way to figure out number of players ...
+		// FIXME: ugh, there should be a better way to figure out number of players ...
 		if (gameSetup != NULL) {
 			numPlayers = gameSetup-&gt;numPlayers;
 		} else {
@@ -4236,9 +4278,10 @@
 				++numPlayers;
 		}
 		int numTeams = gs-&gt;activeAllyTeams;
-		if (gs-&gt;useLuaGaia)
+		if (gs-&gt;useLuaGaia) {
 			--numTeams;
-	// Figure out who won the game.
+		}
+		// Figure out who won the game.
 		int winner = -1;
 		for (int i = 0; i &lt; numTeams; ++i) {
 			if (!gs-&gt;Team(i)-&gt;isDead) {
@@ -4246,13 +4289,15 @@
 				break;
 			}
 		}
-	// Finally pass it on to the CDemoRecorder.
+		// Finally pass it on to the CDemoRecorder.
 		record-&gt;SetTime(gs-&gt;frameNum / 30, (int)gu-&gt;gameTime);
 		record-&gt;InitializeStats(numPlayers, numTeams, winner);
-		for (int i = 0; i &lt; numPlayers; ++i)
+		for (int i = 0; i &lt; numPlayers; ++i) {
 			record-&gt;SetPlayerStats(i, *gs-&gt;players[i]-&gt;currentStats);
-		for (int i = 0; i &lt; numTeams; ++i)
+		}
+		for (int i = 0; i &lt; numTeams; ++i) {
 			record-&gt;SetTeamStats(i, gs-&gt;Team(i)-&gt;statHistory);
+		}
 	}
 }
 
@@ -4286,8 +4331,10 @@
 
 void CGame::HandleChatMsg(const ChatMessage&amp; msg)
 {
-	if (msg.fromPlayer &lt; 0 || (msg.fromPlayer &gt;= MAX_PLAYERS &amp;&amp; msg.fromPlayer != SERVER_PLAYER))
+	if ((msg.fromPlayer &lt; 0) ||
+	    ((msg.fromPlayer &gt;= MAX_PLAYERS) &amp;&amp; (msg.fromPlayer != SERVER_PLAYER))) {
 		return;
+	}
 
 	CScriptHandler::Instance().chosenScript-&gt;GotChatMsg(msg.msg, msg.fromPlayer);
 	string s = msg.msg;
@@ -4661,12 +4708,9 @@
 bool CGame::HasLag() const
 {
 	unsigned timeNow = SDL_GetTicks();
-	if (!gs-&gt;paused &amp;&amp; timeNow &gt; lastFrameTime + 500.0f / gs-&gt;speedFactor)
-	{
+	if (!gs-&gt;paused &amp;&amp; (timeNow &gt; (lastFrameTime + (500.0f / gs-&gt;speedFactor)))) {
 		return true;
-	}
-	else
-	{
+	} else {
 		return false;
 	}
 }

Modified: branches/gml/rts/Game/Game.h
===================================================================
--- branches/gml/rts/Game/Game.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Game.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -107,6 +107,8 @@
 	float gameSoundVolume;
 	float unitReplyVolume;
 
+	unsigned char gameID[16];
+
 	CScript* script;
 
 	CInfoConsole *infoConsole;
@@ -136,7 +138,7 @@
 	void HandleChatMsg(const ChatMessage&amp; msg);
 	
 	/// synced actions (recieved from server) go in here
-	void ActionRecieved(const Action&amp;, int playernum);
+	void ActionReceived(const Action&amp;, int playernum);
 
 	void DrawInputText();
 	void ParseInputTextGeometry(const std::string&amp; geo);

Modified: branches/gml/rts/Game/GameData.cpp
===================================================================
--- branches/gml/rts/Game/GameData.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/GameData.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -14,7 +14,7 @@
 	modChecksum = 0;
 }
 
-GameData::GameData(const netcode::RawPacket&amp; pckt)
+GameData::GameData(boost::shared_ptr&lt;const RawPacket&gt; pckt)
 {
 	UnpackPacket packet(pckt);
 	unsigned char ID;

Modified: branches/gml/rts/Game/GameData.h
===================================================================
--- branches/gml/rts/Game/GameData.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/GameData.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -2,6 +2,7 @@
 #define GAMEDATA_H
 
 #include &lt;string&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
 
 namespace netcode {
 	class RawPacket;
@@ -11,7 +12,7 @@
 {
 public:
 	GameData();
-	GameData(const netcode::RawPacket&amp; packet);
+	GameData(boost::shared_ptr&lt;const netcode::RawPacket&gt;);
 	
 	const netcode::RawPacket* Pack() const;
 	

Modified: branches/gml/rts/Game/GameServer.cpp
===================================================================
--- branches/gml/rts/Game/GameServer.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/GameServer.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,4 +1,4 @@
-#include &quot;stdafx.h&quot;
+#include &quot;StdAfx.h&quot;
 #include &quot;GameServer.h&quot;
 
 #include &lt;stdarg.h&gt;
@@ -37,6 +37,7 @@
 namespace std { using ::ceil; }
 #endif
 
+
 /// frames until a syncchech will time out and a warning is given out
 const int SYNCCHECK_TIMEOUT = 300;
 
@@ -152,7 +153,6 @@
 	RestrictedAction(&quot;reloadcob&quot;);
 	RestrictedAction(&quot;devlua&quot;);
 	RestrictedAction(&quot;editdefs&quot;);
-	RestrictedAction(&quot;luarules&quot;);
 	RestrictedAction(&quot;luagaia&quot;);
 	RestrictedAction(&quot;singlestep&quot;);
 	thread = new boost::thread(boost::bind&lt;void, CGameServer, CGameServer*&gt;(&amp;CGameServer::UpdateLoop, this));
@@ -470,32 +470,30 @@
 	// handle new connections
 	while (serverNet-&gt;HasIncomingConnection())
 	{
-		RawPacket* packet = serverNet-&gt;GetData();
-		const unsigned char* inbuf = packet-&gt;data;
+		boost::shared_ptr&lt;const RawPacket&gt; packet = serverNet-&gt;GetData();
 		
-		if (packet-&gt;length &gt;= 3 &amp;&amp; inbuf[0] == NETMSG_ATTEMPTCONNECT &amp;&amp; inbuf[2] == NETWORK_VERSION)
+		if (packet-&gt;length &gt;= 3 &amp;&amp; packet-&gt;data[0] == NETMSG_ATTEMPTCONNECT &amp;&amp; packet-&gt;data[2] == NETWORK_VERSION)
 		{
-			const unsigned wantedNumber = inbuf[1];
+			const unsigned wantedNumber = packet-&gt;data[1];
 			BindConnection(wantedNumber);
 		}
 		else
 		{
 			if (packet-&gt;length &gt;= 3) {
-				Warning(str(format(ConnectionReject) %inbuf[0] %inbuf[2] %packet-&gt;length));
+				Warning(str(format(ConnectionReject) %packet-&gt;data[0] %packet-&gt;data[2] %packet-&gt;length));
 			}
 			else {
 				Warning(&quot;Connection attempt rejected: Packet too short&quot;);
 			}
 			serverNet-&gt;RejectIncomingConnection();
 		}
-		delete packet;
 	}
 
 	for(unsigned a=0; (int)a &lt;= serverNet-&gt;MaxConnectionID(); a++)
 	{
 		if (serverNet-&gt;IsActiveConnection(a))
 		{
-			RawPacket* packet = 0;
+			boost::shared_ptr&lt;const RawPacket&gt; packet;
 			bool quit = false;
 			while (!quit &amp;&amp; (packet = serverNet-&gt;GetData(a)))
 			{
@@ -579,7 +577,7 @@
 					}
 
 					case NETMSG_CHAT: {
-						ChatMessage msg(*packet);
+						ChatMessage msg(packet);
 						if (static_cast&lt;unsigned&gt;(msg.fromPlayer) != a ) {
 							Warning(str(format(WrongPlayer) %(unsigned)NETMSG_CHAT %a %(unsigned)msg.fromPlayer));
 						} else {
@@ -624,7 +622,7 @@
 							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
 						} else {
 							if (!demoReader)
-								serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1])); //forward data
+								serverNet-&gt;SendData(packet); //forward data
 						}
 						break;
 
@@ -633,8 +631,7 @@
 							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
 						} else {
 							if (!demoReader)
-								// forward data
-								serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1]));
+								serverNet-&gt;SendData(packet); //forward data
 						}
 						break;
 
@@ -647,8 +644,7 @@
 							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
 						}
 						else if (!demoReader) {
-							// forward data
-							serverNet-&gt;RawSend(inbuf, *((short int*) &amp;inbuf[1]));
+							serverNet-&gt;SendData(packet); //forward data
 						}
 					} break;
 
@@ -660,8 +656,7 @@
 							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
 						}
 						else if (!demoReader) {
-							// forward data
-							serverNet-&gt;RawSend(inbuf, *((short int*) &amp;inbuf[1]));
+							serverNet-&gt;SendData(packet); //forward data
 						}
 					} break;
 
@@ -671,8 +666,7 @@
 						} else if (noHelperAIs) {
 							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
 						} else if (!demoReader) {
-							// forward data
-							serverNet-&gt;RawSend(inbuf, *((short int*) &amp;inbuf[1]));
+							serverNet-&gt;SendData(packet); //forward data
 						}
 					} break;
 
@@ -682,7 +676,7 @@
 							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
 						}
 						else if (!demoReader) {
-							serverNet-&gt;RawSend(inbuf,*((short int*)&amp;inbuf[1])); //forward data
+							serverNet-&gt;SendData(packet); //forward data
 						}
 						break;
 
@@ -726,12 +720,12 @@
 						if(inbuf[1]!=a){
 							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
 						} else {
-							serverNet-&gt;RawSend(inbuf,sizeof(CPlayer::Statistics)+2); //forward data
+							serverNet-&gt;SendData(packet); //forward data
 						}
 						break;
 
 					case NETMSG_MAPDRAW:
-						serverNet-&gt;RawSend(inbuf,inbuf[1]); //forward data
+						serverNet-&gt;SendData(packet); //forward data
 						break;
 
 #ifdef DIRECT_CONTROL_ALLOWED
@@ -855,7 +849,7 @@
 						break;
 					}
 					case NETMSG_CCOMMAND: {
-						CommandMessage msg(*packet);
+						CommandMessage msg(packet);
 						if (static_cast&lt;unsigned&gt;(msg.player) == a)
 						{
 							if ((commandBlacklist.find(msg.action.command) != commandBlacklist.end()) &amp;&amp; players[a]-&gt;hasRights)
@@ -890,7 +884,6 @@
 						}
 						break;
 				}
-				delete packet;
 			}
 		}
 		else if (players[a])
@@ -1401,3 +1394,4 @@
 	commandBlacklist.insert(action);
 }
 
+

Modified: branches/gml/rts/Game/GameServer.h
===================================================================
--- branches/gml/rts/Game/GameServer.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/GameServer.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -54,12 +54,12 @@
 @brief Server class for game handling
 This class represents a gameserver. It is responsible for recieving, checking and forwarding gamedata to the clients. It keeps track of the sync, cpu and other stats and informs all clients about events.
 */
-class CGameServer : public CommandReciever
+class CGameServer : public CommandReceiver
 {
 	friend class CLoadSaveHandler;     //For initialize server state after load
 public:
 	CGameServer(int port, const GameData* const gameData, const CGameSetupData* const setup, const std::string&amp; demoName = &quot;&quot;);
-	~CGameServer();
+	virtual ~CGameServer();
 
 	void AddLocalClient();
 

Modified: branches/gml/rts/Game/PreGame.cpp
===================================================================
--- branches/gml/rts/Game/PreGame.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/PreGame.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -438,27 +438,24 @@
 		return;
 	}
 
-	RawPacket* packet = 0;
-	while ( (packet = net-&gt;GetData()) )
+	boost::shared_ptr&lt;const RawPacket&gt; packet;
+	while ((packet = net-&gt;GetData()))
 	{
 		const unsigned char* inbuf = packet-&gt;data;
 		switch (inbuf[0]) {
 			case NETMSG_SETPLAYERNUM: {
-				gu-&gt;myPlayerNum = inbuf[1];
+				gu-&gt;myPlayerNum = packet-&gt;data[1];
 				logOutput.Print(&quot;Became player %i&quot;, gu-&gt;myPlayerNum);
 			} break;
 			case NETMSG_GAMEDATA: {
-				GameDataRecieved(packet);
-				delete packet;
+				GameDataReceived(packet);
 				return;
-				break;
 			}
 			default: {
-				logOutput.Print(&quot;Unknown net-msg recieved from CPreGame: %i&quot;, int(inbuf[0]));
+				logOutput.Print(&quot;Unknown net-msg recieved from CPreGame: %i&quot;, int(packet-&gt;data[0]));
 				break;
 			}
 		}
-		delete packet;
 	}
 }
 
@@ -469,23 +466,24 @@
 
 	gu-&gt;myPlayerNum = scanner.GetFileHeader().maxPlayerNum + 1;
 
-	RawPacket* buf = 0;
-	while ( (buf = scanner.GetData(static_cast&lt;float&gt;(INT_MAX))) ) {
+	boost::shared_ptr&lt;const RawPacket&gt; buf(scanner.GetData(static_cast&lt;float&gt;(INT_MAX)));
+	while ( buf )
+	{
 		if (buf-&gt;data[0] == NETMSG_GAMEDATA)
 		{
-			GameData *data = new GameData(*buf);
+			GameData *data = new GameData(boost::shared_ptr&lt;const RawPacket&gt;(buf));
 			good_fpu_control_registers(&quot;before CGameServer creation&quot;);
 			gameServer = new CGameServer(springDefaultPort, data, gameSetup, demoName);
 			gameServer-&gt;AddLocalClient();
 			good_fpu_control_registers(&quot;after CGameServer creation&quot;);
-			delete buf;
 			break;
 		}
-		delete buf;
+		
 		if (scanner.ReachedEnd())
 		{
 			throw content_error(&quot;End of demo reached and no game data found&quot;);
 		}
+		buf.reset(scanner.GetData(static_cast&lt;float&gt;(INT_MAX)));
 	}
 }
 
@@ -621,9 +619,9 @@
 	}
 }
 
-void CPreGame::GameDataRecieved(RawPacket* packet)
+void CPreGame::GameDataReceived(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet)
 {
-	gameData = new GameData(*packet);
+	gameData = new GameData(packet);
 	
 	gs-&gt;SetRandSeed(gameData-&gt;GetRandomSeed());
 	logOutput &lt;&lt; &quot;Using map &quot; &lt;&lt; gameData-&gt;GetMap() &lt;&lt; &quot;\n&quot;;

Modified: branches/gml/rts/Game/PreGame.h
===================================================================
--- branches/gml/rts/Game/PreGame.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/PreGame.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -2,6 +2,7 @@
 #define PREGAME_H
 
 #include &lt;string&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
 
 #include &quot;GameController.h&quot;
 
@@ -25,7 +26,7 @@
  * 
  * ForClients:
  * 1. Connect to the server
- * 2. Recieve GameData from server
+ * 2. Receive GameData from server
  * 3. Start the CGame with the information provided by server
  * */
 class CPreGame : public CGameController
@@ -65,7 +66,7 @@
 	/// Map all required archives depending on selected mod(s)
 	static void LoadMod(const std::string&amp; modName);
 
-	void GameDataRecieved(netcode::RawPacket* packet);
+	void GameDataReceived(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet);
 	
 	const bool server;
 	enum State {

Modified: branches/gml/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/StartScripts/CommanderScript.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,24 +1,26 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;CommanderScript.h&quot;
-#include &quot;Sim/Units/UnitLoader.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &lt;algorithm&gt;
 #include &lt;cctype&gt;
 #include &lt;map&gt;
+#include &quot;StdAfx.h&quot;
+#include &quot;CommanderScript.h&quot;
+#include &quot;ExternalAI/GlobalAIHandler.h&quot;
+#include &quot;Game/Game.h&quot;
+#include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/Team.h&quot;
-#include &quot;Game/GameSetup.h&quot;
-#include &quot;Game/Game.h&quot;
+#include &quot;Game/UI/MiniMap.h&quot;
+#include &quot;Game/UI/InfoConsole.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
-#include &quot;ExternalAI/GlobalAIHandler.h&quot;
-#include &quot;Map/ReadMap.h&quot;
+#include &quot;Sim/Units/UnitLoader.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/TdfParser.h&quot; // still required for parsing map SMD for start positions
+#include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
-#include &quot;Game/UI/MiniMap.h&quot;
-#include &quot;Game/UI/InfoConsole.h&quot;
 
-
 extern std::string stupidGlobalMapname;
 
 
@@ -36,28 +38,36 @@
 void CCommanderScript::GameStart()
 {
 	if (gameSetup) {
-		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
+		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		if (!luaParser.Execute()) {
+			logOutput.Print(luaParser.GetErrorLog());
+		}
 
+		const LuaTable sideData = luaParser.GetRoot();
+
 		// make a map of all side names  (assumes contiguous sections)
 		std::map&lt;std::string, std::string&gt; sideMap;
-		char sideText[64];
-		for (int side = 0;
-				 SNPRINTF(sideText, sizeof(sideText), &quot;side%i&quot;, side),
-				 p.SectionExist(sideText); // the test
-				 side++) {
-			const std::string sideName =
-				StringToLower(p.SGetValueDef(&quot;arm&quot;, std::string(sideText) + &quot;\\name&quot;));
-			sideMap[sideName] = sideText;
+		for (int i = 1; true; i++) {
+			const LuaTable side = sideData.SubTable(i);
+			if (!side.IsValid()) {
+				break;
+			}
+			const std::string sideName  = side.GetString(&quot;name&quot;, &quot;unknown&quot;);
+			const std::string startUnit = side.GetString(&quot;startUnit&quot;, &quot;&quot;);
+			sideMap[StringToLower(sideName)] = StringToLower(startUnit);
 		}
 
 		// setup the teams
 		for (int a = 0; a &lt; gs-&gt;activeTeams; ++a) {
 
 			// don't spawn a commander for the gaia team
-			if (gs-&gt;useLuaGaia &amp;&amp; a == gs-&gt;gaiaTeamID)
+			if (gs-&gt;useLuaGaia &amp;&amp; (a == gs-&gt;gaiaTeamID)) {
 				continue;
+			}
 
 			CTeam* team = gs-&gt;Team(a);
+
 			if (team-&gt;gaia) continue;
 
 			// remove the pre-existing storage except for a small amount
@@ -70,31 +80,47 @@
 				globalAI-&gt;CreateGlobalAI(a, gameSetup-&gt;aiDlls[a].c_str());
 			}
 
-			std::map&lt;std::string, std::string&gt;::const_iterator it = sideMap.find(team-&gt;side);
+			std::map&lt;std::string, std::string&gt;::const_iterator it =
+				sideMap.find(team-&gt;side);
 
 			if (it != sideMap.end()) {
-				const std::string&amp; sideSection = it-&gt;second;
-				const std::string cmdrType =
-					StringToLower(p.SGetValueDef(&quot;armcom&quot;, sideSection + &quot;\\commander&quot;));
+				const std::string&amp; sideName  = it-&gt;first;
+				const std::string&amp; startUnit = it-&gt;second;
+				if (startUnit.length() == 0) {
+					throw content_error (
+						&quot;Unable to load a commander for side: &quot; + sideName
+					);
+				}
+				CUnit* unit = unitLoader.LoadUnit(startUnit,
+				                                  team-&gt;startPos, a, false, 0, NULL);
 
-				CUnit* unit = unitLoader.LoadUnit(cmdrType, team-&gt;startPos, a, false, 0, NULL);
-
 				team-&gt;lineageRoot = unit-&gt;id;
 
 				// FIXME this shouldn't be here, but no better place exists currently
 				if (a == gu-&gt;myTeam) {
 					minimap-&gt;AddNotification(team-&gt;startPos,
-							float3(1.0f, 1.0f, 1.0f), 1.0f);
+					                         float3(1.0f, 1.0f, 1.0f), 1.0f);
 					game-&gt;infoConsole-&gt;SetLastMsgPos(team-&gt;startPos);
 				}
 			}
 		}
 	}
 	else {
-		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
-		const std::string s0 = StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
-		const std::string s1 = StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
+		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		if (!luaParser.Execute()) {
+			logOutput.Print(luaParser.GetErrorLog());
+		}
+		const LuaTable sideData = luaParser.GetRoot();
+		const LuaTable side1 = sideData.SubTable(1);
+		const LuaTable side2 = sideData.SubTable(2);
+		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
 
+		if (su1.length() == 0) {
+			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
+		}
+		
 		TdfParser p2;
 		CMapInfo::OpenTDF(stupidGlobalMapname, p2);
 
@@ -104,8 +130,8 @@
 		p2.GetDef(x1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosX&quot;);
 		p2.GetDef(z1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosZ&quot;);
 
-		unitLoader.LoadUnit(s0, float3(x0, 80.0f, z0), 0, false, 0, NULL);
-		unitLoader.LoadUnit(s1, float3(x1, 80.0f, z1), 1, false, 0, NULL);
+		unitLoader.LoadUnit(su1, float3(x0, 80.0f, z0), 0, false, 0, NULL);
+		unitLoader.LoadUnit(su2, float3(x1, 80.0f, z1), 1, false, 0, NULL);
 
 		// FIXME this shouldn't be here, but no better place exists currently
 		minimap-&gt;AddNotification(float3(x0, 80.0f, z0),

Modified: branches/gml/rts/Game/StartScripts/CommanderScript2.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript2.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/StartScripts/CommanderScript2.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,23 +1,29 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;CommanderScript2.h&quot;
-#include &quot;Sim/Units/UnitLoader.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &quot;Game/Team.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Sim/Units/UnitLoader.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/TdfParser.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
 extern std::string stupidGlobalMapname;
 
+
 CCommanderScript2::CCommanderScript2()
 : CScript(std::string(&quot;Cmds 1000 res&quot;))
 {
 }
 
+
 CCommanderScript2::~CCommanderScript2(void)
 {
 }
 
+
 void CCommanderScript2::Update(void)
 {
 	switch(gs-&gt;frameNum){
@@ -36,10 +42,21 @@
 		gs-&gt;Team(1)-&gt;metalIncome=1000;
 		gs-&gt;Team(1)-&gt;metalStorage=1000;
 
-		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
-		std::string s0 = StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
-		std::string s1 = StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
+		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		if (!luaParser.Execute()) {
+			logOutput.Print(luaParser.GetErrorLog());
+		}
+		const LuaTable sideData = luaParser.GetRoot();
+		const LuaTable side1 = sideData.SubTable(1);
+		const LuaTable side2 = sideData.SubTable(2);
+		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
 
+		if (su1.length() == 0) {
+			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
+		}
+
 		TdfParser p2;
 		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
 
@@ -49,8 +66,8 @@
 		p2.GetDef(x1,&quot;1200&quot;,&quot;MAP\\TEAM1\\StartPosX&quot;);
 		p2.GetDef(z1,&quot;1200&quot;,&quot;MAP\\TEAM1\\StartPosZ&quot;);
 
-		unitLoader.LoadUnit(s0, float3(x0, 80, z0), 0, false, 0, NULL);
-		unitLoader.LoadUnit(s1, float3(x1, 80, z1), 1, false, 0, NULL);
+		unitLoader.LoadUnit(su1, float3(x0, 80, z0), 0, false, 0, NULL);
+		unitLoader.LoadUnit(su2, float3(x1, 80, z1), 1, false, 0, NULL);
 
 //		unitLoader.LoadUnit(&quot;armsam&quot;,float3(2650,10,2600),0,false);
 //		unitLoader.LoadUnit(&quot;armflash&quot;,float3(2450,10,2600),1,false);

Modified: branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,50 +1,68 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;GlobalAITestScript.h&quot;
-#include &quot;Sim/Units/UnitLoader.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &lt;algorithm&gt;
 #include &lt;cctype&gt;
+#include &quot;System/StdAfx.h&quot;
+#include &quot;GlobalAITestScript.h&quot;
+#include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;Game/Team.h&quot;
-#include &quot;Sim/Units/UnitDefHandler.h&quot;
-#include &quot;ExternalAI/GlobalAIHandler.h&quot;
-#include &quot;FileSystem/FileHandler.h&quot;
-#include &quot;Platform/FileSystem.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Sim/Units/UnitDefHandler.h&quot;
+#include &quot;Sim/Units/UnitLoader.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/TdfParser.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
+#include &quot;System/Platform/FileSystem.h&quot;
 #include &quot;mmgr.h&quot;
 
+
 extern std::string stupidGlobalMapname;
 
+
 CGlobalAITestScript::CGlobalAITestScript(std::string dll)
 	: CScript(std::string(&quot;GlobalAI test (&quot;) + filesystem.GetFilename(dll) + std::string(&quot;)&quot;)),
 	dllName(dll)
 {
 }
 
+
 CGlobalAITestScript::~CGlobalAITestScript(void)
 {
 }
 
+
 void CGlobalAITestScript::Update(void)
 {
 	switch (gs-&gt;frameNum) {
 		case 0: {
 			globalAI-&gt;CreateGlobalAI(1, dllName.c_str());
 
-			gs-&gt;Team(0)-&gt;energy = 1000;
+			gs-&gt;Team(0)-&gt;energy        = 1000;
 			gs-&gt;Team(0)-&gt;energyStorage = 1000;
-			gs-&gt;Team(0)-&gt;metal = 1000;
-			gs-&gt;Team(0)-&gt;metalStorage = 1000;
+			gs-&gt;Team(0)-&gt;metal         = 1000;
+			gs-&gt;Team(0)-&gt;metalStorage  = 1000;
 
-			gs-&gt;Team(1)-&gt;energy = 1000;
+			gs-&gt;Team(1)-&gt;energy        = 1000;
 			gs-&gt;Team(1)-&gt;energyStorage = 1000;
-			gs-&gt;Team(1)-&gt;metal = 1000;
-			gs-&gt;Team(1)-&gt;metalStorage = 1000;
+			gs-&gt;Team(1)-&gt;metal         = 1000;
+			gs-&gt;Team(1)-&gt;metalStorage  = 1000;
 
-			TdfParser p(&quot;gamedata/sidedata.tdf&quot;);
-			std::string s0 = p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;);
-			std::string s1 = p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;);
+			LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+													SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+			if (!luaParser.Execute()) {
+				logOutput.Print(luaParser.GetErrorLog());
+			}
+			const LuaTable sideData = luaParser.GetRoot();
+			const LuaTable side1 = sideData.SubTable(1);
+			const LuaTable side2 = sideData.SubTable(2);
+			const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+			const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
+			// default to side 1, in case mod has only 1 side
 
+			if (su1.length() == 0) {
+				throw content_error (&quot;Unable to load a commander for the first side&quot;);
+			}
+
 			TdfParser p2;
 			CMapInfo::OpenTDF(stupidGlobalMapname, p2);
 
@@ -54,11 +72,12 @@
 			p2.GetDef(x1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosX&quot;);
 			p2.GetDef(z1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosZ&quot;);
 
-			unitLoader.LoadUnit(s0, float3(x0, 80, z0), 0, false, 0, NULL);
-			unitLoader.LoadUnit(s1, float3(x1, 80, z1), 1, false, 0, NULL);
+			unitLoader.LoadUnit(su1, float3(x0, 80, z0), 0, false, 0, NULL);
+			unitLoader.LoadUnit(su2, float3(x1, 80, z1), 1, false, 0, NULL);
 			break;
 		}
-		default:
+		default: {
 			break;
+		}
 	}
 }

Modified: branches/gml/rts/Game/StartScripts/LoadScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/LoadScript.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/StartScripts/LoadScript.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,15 +1,14 @@
-#include &lt;vector&gt;
 #include &lt;iostream&gt;
-
+#include &lt;vector&gt;
 #include &quot;StdAfx.h&quot;
 #include &quot;LoadScript.h&quot;
-#include &quot;LoadSaveHandler.h&quot;
-#include &quot;FileSystem/FileHandler.h&quot;
-#include &quot;Platform/FileSystem.h&quot;
-#include &quot;Game/Team.h&quot;
-#include &quot;Game/GameSetup.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
+#include &quot;Game/GameSetup.h&quot;
+#include &quot;Game/Team.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
+#include &quot;System/LoadSaveHandler.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
+#include &quot;System/Platform/FileSystem.h&quot;
 
 extern std::string stupidGlobalMapname;
 

Modified: branches/gml/rts/Game/StartScripts/SpawnScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/SpawnScript.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/StartScripts/SpawnScript.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,16 +1,19 @@
+#include &lt;fstream&gt;
+#include &lt;set&gt;
 #include &quot;StdAfx.h&quot;
 #include &quot;SpawnScript.h&quot;
-#include &lt;fstream&gt;
-#include &quot;TdfParser.h&quot;
+#include &quot;Game/Team.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
-#include &quot;Game/Team.h&quot;
-#include &lt;set&gt;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
-#include &quot;Map/MapInfo.h&quot;
-#include &quot;Map/ReadMap.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/TdfParser.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
 extern std::string stupidGlobalMapname;
@@ -32,10 +35,21 @@
 	case 0:
 		LoadSpawns();
 
-		TdfParser p(&quot;gamedata/sidedata.tdf&quot;);
-		std::string s0=p.SGetValueDef(&quot;armcom&quot;,&quot;side0\\commander&quot;);
-		std::string s1=p.SGetValueDef(&quot;corcom&quot;,&quot;side1\\commander&quot;);
+		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		if (!luaParser.Execute()) {
+			logOutput.Print(luaParser.GetErrorLog());
+		}
+		const LuaTable sideData = luaParser.GetRoot();
+		const LuaTable side1 = sideData.SubTable(1);
+		const LuaTable side2 = sideData.SubTable(2);
+		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
 
+		if (su1.length() == 0) {
+			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
+		}
+
 		TdfParser p2;
 		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
 
@@ -46,7 +60,7 @@
 		// Set the TEAM0 startpos as spawnpos if we're supposed to be
 		// autonomous, load the commander for the player if not.
 		if (autonomous) spawnPos.push_back(float3(x0,80,z0));
-		else unitLoader.LoadUnit(s0,float3(x0,80,z0),0,false,0,NULL);
+		else unitLoader.LoadUnit(su1, float3(x0,80,z0),0,false,0,NULL);
 
 		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM1\\StartPosX&quot;);
 		p2.GetDef(z0,&quot;1000&quot;,&quot;MAP\\TEAM1\\StartPosZ&quot;);

Modified: branches/gml/rts/Game/Team.cpp
===================================================================
--- branches/gml/rts/Game/Team.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/Team.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -103,36 +103,36 @@
 //////////////////////////////////////////////////////////////////////
 
 CTeam::CTeam()
-: 	gaia(false),
-	metal(200000),
-	energy(900000),
-	metalPull(0),     prevMetalPull(0),
-	metalIncome(0),   prevMetalIncome(0),
-	metalExpense(0),  prevMetalExpense(0),
-	metalUpkeep(0),   prevMetalUpkeep(0),
-	energyPull(0),    prevEnergyPull(0),
-	energyIncome(0),  prevEnergyIncome(0),
-	energyExpense(0), prevEnergyExpense(0),
-	energyUpkeep(0),  prevEnergyUpkeep(0),
-	metalStorage(1000000),
-	energyStorage(1000000),
-	metalShare(0.99f),
-	energyShare(0.95f),
-	delayedMetalShare(0),
-	delayedEnergyShare(0),
-	metalSent(0),
-	metalReceived(0),
-	energySent(0),
-	energyReceived(0),
-	side(&quot;arm&quot;),
-	luaAI(&quot;&quot;),
-	startPos(100,100,100),
-	handicap(1),
-	leader(-1),
-	lineageRoot(-1),
-	isDead(false),
-	lastStatSave(0),
-	numCommanders(0)
+: gaia(false),
+  metal(200000),
+  energy(900000),
+  metalPull(0),     prevMetalPull(0),
+  metalIncome(0),   prevMetalIncome(0),
+  metalExpense(0),  prevMetalExpense(0),
+  metalUpkeep(0),   prevMetalUpkeep(0),
+  energyPull(0),    prevEnergyPull(0),
+  energyIncome(0),  prevEnergyIncome(0),
+  energyExpense(0), prevEnergyExpense(0),
+  energyUpkeep(0),  prevEnergyUpkeep(0),
+  metalStorage(1000000),
+  energyStorage(1000000),
+  metalShare(0.99f),
+  energyShare(0.95f),
+  delayedMetalShare(0),
+  delayedEnergyShare(0),
+  metalSent(0),
+  metalReceived(0),
+  energySent(0),
+  energyReceived(0),
+  side(&quot;arm&quot;),
+  luaAI(&quot;&quot;),
+  startPos(100,100,100),
+  handicap(1),
+  leader(-1),
+  lineageRoot(-1),
+  isDead(false),
+  lastStatSave(0),
+  numCommanders(0)
 {
 	memset(&amp;currentStats,0,sizeof(currentStats));
 	statHistory.push_back(currentStats);
@@ -209,16 +209,12 @@
 
 void CTeam::SelfDestruct()
 {
-	for(CUnitSet::iterator ui = units.begin(); ui != units.end(); ++ui)
-	{
-		if ((*ui) != NULL &amp;&amp; (*ui)-&gt;unitDef-&gt;canSelfD)
-		{
-			if ((*ui)-&gt;beingBuilt)
-			{
+	for(CUnitSet::iterator ui = units.begin(); ui != units.end(); ++ui) {
+		if ((*ui) != NULL &amp;&amp; (*ui)-&gt;unitDef-&gt;canSelfD) {
+			if ((*ui)-&gt;beingBuilt) {
 				(*ui)-&gt;KillUnit(false, true, NULL); // kill units under construction without explosion
 			}
-			else
-			{
+			else {
 				(*ui)-&gt;KillUnit(true, false, NULL);
 			}
 		}
@@ -254,10 +250,12 @@
 
 void CTeam::Died()
 {
-	if (leader &gt;= 0)
-		logOutput.Print(CMessages::Tr(&quot;Team %i (%s) is no more&quot;).c_str(), teamNum, gs-&gt;players[leader]-&gt;playerName.c_str());
-	else
-		logOutput.Print(CMessages::Tr(&quot;Team %i is no more&quot;).c_str(), teamNum);
+	if (leader &gt;= 0) {
+		logOutput.Print(CMessages::Tr(&quot;Team%i(%s) is no more&quot;).c_str(),
+		                teamNum, gs-&gt;players[leader]-&gt;playerName.c_str());
+	} else {
+		logOutput.Print(CMessages::Tr(&quot;Team%i is no more&quot;).c_str(), teamNum);
+	}
 	isDead = true;
 	luaCallIns.TeamDied(teamNum);
 	net-&gt;SendTeamDied(gu-&gt;myPlayerNum, teamNum);
@@ -418,8 +416,7 @@
 		}
 	}
 
-	if(units.empty() &amp;&amp; !gaia)
-	{
+	if(units.empty() &amp;&amp; !gaia) {
 		Died();
 	}
 }

Modified: branches/gml/rts/Game/UI/GameSetupDrawer.cpp
===================================================================
--- branches/gml/rts/Game/UI/GameSetupDrawer.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/UI/GameSetupDrawer.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -32,8 +32,7 @@
 
 void GameSetupDrawer::Disable()
 {
-	if (instance)
-	{
+	if (instance) {
 		delete instance;
 		instance = 0;
 	}
@@ -41,12 +40,16 @@
 
 void GameSetupDrawer::StartCountdown(unsigned time)
 {
-	if (instance)
-	{
+	if (instance) {
 		instance-&gt;lastTick = SDL_GetTicks();
 		instance-&gt;readyCountdown = (int)time;
-		int mode = configHandler.GetInt(&quot;CamMode&quot;, 1);
-		camHandler-&gt;SetCameraMode(mode);
+		const std::string modeName = configHandler.GetString(&quot;CamModeName&quot;, &quot;&quot;);
+		if (!modeName.empty()) {
+			camHandler-&gt;SetCameraMode(modeName);
+		} else {
+			const int modeIndex = configHandler.GetInt(&quot;CamMode&quot;, 1);
+			camHandler-&gt;SetCameraMode(modeIndex);
+		}
 	}
 }
 
@@ -68,13 +71,11 @@
 
 void GameSetupDrawer::Draw()
 {
-	if (readyCountdown &gt; 0)
-	{
+	if (readyCountdown &gt; 0) {
 		readyCountdown -= (SDL_GetTicks() - lastTick);
 		lastTick = SDL_GetTicks();
 	}
-	else if (readyCountdown &lt; 0)
-	{
+	else if (readyCountdown &lt; 0) {
 		GameSetupDrawer::Disable();
 	}
 
@@ -155,8 +156,7 @@
 
 bool GameSetupDrawer::KeyPressed(unsigned short key, bool isRepeat)
 {
-	if (keys[SDLK_LCTRL] &amp;&amp; (key == SDLK_RETURN))
-	{
+	if (keys[SDLK_LCTRL] &amp;&amp; (key == SDLK_RETURN)) {
 		// tell the server to force-start the game
 		net-&gt;SendStartPlaying(0);
 	}

Modified: branches/gml/rts/Game/UI/KeyAutoBinder.cpp
===================================================================
--- branches/gml/rts/Game/UI/KeyAutoBinder.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/UI/KeyAutoBinder.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -206,15 +206,17 @@
 
 	vector&lt;UnitDefHolder&gt; defs;
 
-	// find the unit definitions that meet the requirements
-	const std::map&lt;std::string, int&gt;&amp; unitMap = unitDefHandler-&gt;unitID;
-	std::map&lt;std::string, int&gt;::const_iterator uit;
-	for (uit = unitMap.begin(); uit != unitMap.end(); uit++) {
-		const UnitDef&amp; ud = unitDefHandler-&gt;unitDefs[uit-&gt;second];
-		if (HasRequirements(L, uit-&gt;second)) {
+	const std::map&lt;std::string, int&gt;&amp; udMap = unitDefHandler-&gt;unitID;
+	std::map&lt;std::string, int&gt;::const_iterator udIt;
+	for (udIt = udMap.begin(); udIt != udMap.end(); udIt++) {
+	  const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(udIt-&gt;second);
+		if (ud == NULL) {
+	  	continue;
+		}
+		if (HasRequirements(L, ud-&gt;id)) {
 			UnitDefHolder udh;
-			udh.ud = &ud;
-			udh.udID = uit-&gt;second;
+			udh.ud = ud;
+			udh.udID = ud-&gt;id;
 			defs.push_back(udh);
 		}
 	}

Modified: branches/gml/rts/Game/UI/KeyBindings.h
===================================================================
--- branches/gml/rts/Game/UI/KeyBindings.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/UI/KeyBindings.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -19,7 +19,7 @@
 class CSimpleParser;
 
 
-class CKeyBindings : public CommandReciever
+class CKeyBindings : public CommandReceiver
 {
 	public:
 		CKeyBindings();

Modified: branches/gml/rts/Game/UI/LuaUI.cpp
===================================================================
--- branches/gml/rts/Game/UI/LuaUI.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/UI/LuaUI.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -52,6 +52,7 @@
 #include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/InMapDraw.h&quot;
 #include &quot;Rendering/FontTexture.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -2332,8 +2333,8 @@
 			}
 		}
 	}
-	FontTexture::Execute();
-	return 0;
+	lua_pushboolean(L, FontTexture::Execute());
+	return 1;
 }
 
 
@@ -2347,21 +2348,18 @@
 			&quot;Incorrect arguments to SetUnitDefIcon(unitDefID, \&quot;icon\&quot;)&quot;);
 	}
 	const int unitDefID = (int)lua_tonumber(L, 1);
-	// HACK FIXME TODO remove the const_cast: factor iconType out of UnitDef
-	// so unitDef doesn't need to be modified by this code.
-	UnitDef* ud = const_cast&lt;UnitDef*&gt;(unitDefHandler-&gt;GetUnitByID(unitDefID));
+	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
 	if (ud == NULL) {
 		return 0;
 	}
 
-	ud-&gt;iconType = lua_tostring(L, 2);
+	ud-&gt;iconType = iconHandler-&gt;GetIcon(lua_tostring(L, 2));
 
 	// set decoys to the same icon
 	map&lt;int, set&lt;int&gt; &gt;::const_iterator fit;
 
 	if (ud-&gt;decoyDef) {
-		// more HACK HACK (see above)
-		const_cast&lt;UnitDef*&gt;(ud-&gt;decoyDef)-&gt;iconType = ud-&gt;iconType;
+		ud-&gt;decoyDef-&gt;iconType = ud-&gt;iconType;
 		fit = unitDefHandler-&gt;decoyMap.find(ud-&gt;decoyDef-&gt;id);
 	} else {
 		fit = unitDefHandler-&gt;decoyMap.find(ud-&gt;id);
@@ -2370,9 +2368,8 @@
 		const set&lt;int&gt;&amp; decoySet = fit-&gt;second;
 		set&lt;int&gt;::const_iterator dit;
 		for (dit = decoySet.begin(); dit != decoySet.end(); ++dit) {
-  		// more HACK HACK (see above)
-  		const UnitDef* constDef = unitDefHandler-&gt;GetUnitByID(*dit);
-			const_cast&lt;UnitDef*&gt;(constDef)-&gt;iconType = ud-&gt;iconType;
+  		const UnitDef* decoyDef = unitDefHandler-&gt;GetUnitByID(*dit);
+			decoyDef-&gt;iconType = ud-&gt;iconType;
 		}
 	}
 

Modified: branches/gml/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/gml/rts/Game/UI/MiniMap.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/UI/MiniMap.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -349,7 +349,6 @@
 	else if (command == &quot;drawcommands&quot;) {
 		if (words.size() &gt;= 2) {
 			drawCommands = std::max(0, atoi(words[1].c_str()));
-
 		} else {
 			drawCommands = (drawCommands &gt; 0) ? 0 : 1;
 		}
@@ -357,7 +356,6 @@
 	else if (command == &quot;drawprojectiles&quot;) {
 		if (words.size() &gt;= 2) {
 			drawProjectiles = !!atoi(words[1].c_str());
-
 		} else {
 			drawProjectiles = !drawProjectiles;
 		}
@@ -1393,26 +1391,26 @@
 }
 
 
-inline CIcon* CMiniMap::GetUnitIcon(CUnit* unit, float&amp; scale) const
+inline const CIconData* CMiniMap::GetUnitIcon(CUnit* unit, float&amp; scale) const
 {
 	scale = 1.0f;
 
 	if (useIcons) {
-		if ((unit-&gt;allyteam == gu-&gt;myAllyTeam) ||
-				(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) ||
-				((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_PREVLOS) &amp;&amp;
-				 (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_CONTRADAR)) ||
+		const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
+		const unsigned short prevMask = (LOS_PREVLOS | LOS_CONTRADAR);
+		if ((losStatus &amp; LOS_INLOS) ||
+				((losStatus &amp; prevMask) == prevMask) ||
 				gu-&gt;spectatingFullView) {
-			CIcon* icon = iconHandler-&gt;GetIcon(unit-&gt;unitDef-&gt;iconType);
-			if (icon-&gt;radiusAdjust) {
+			const CIconData* iconData = unit-&gt;unitDef-&gt;iconType.GetIconData();
+			if (iconData-&gt;GetRadiusAdjust()) {
 				scale *= (unit-&gt;radius / 30.0f);
 			}
-			return icon;
+			return iconData;
 		}
 	}
 
 	if (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INRADAR) {
-		return iconHandler-&gt;GetIcon(&quot;default&quot;);
+		return iconHandler-&gt;GetDefaultIconData();
 	}
 
 	return NULL;
@@ -1433,8 +1431,8 @@
 
 	// includes the visibility check
 	float iconScale;
-	CIcon* icon = GetUnitIcon(unit, iconScale);
-	if (icon == NULL) {
+	const CIconData* iconData = GetUnitIcon(unit, iconScale);
+	if (iconData == NULL) {
 		return;
 	}
 
@@ -1452,7 +1450,7 @@
 	}
 	else {
 		if (simpleColors) {
-			if (unit-&gt;team==gu-&gt;myTeam) {
+			if (unit-&gt;team == gu-&gt;myTeam) {
 				glColor3ubv(myColor);
 			} else if (gs-&gt;Ally(gu-&gt;myAllyTeam, unit-&gt;allyteam)) {
 				glColor3ubv(allyColor);
@@ -1464,17 +1462,16 @@
 		}
 	}
 
-	iconScale *= icon-&gt;size;
+	iconScale *= iconData-&gt;GetSize();
 	const float sizeX = (iconScale * unitSizeX);
 	const float sizeY = (iconScale * unitSizeY);
 
-	glBindTexture(GL_TEXTURE_2D, icon-&gt;texture);
-	glBegin(GL_QUADS);
-		glTexCoord2f(1.0f, 1.0f); glVertex2f(pos.x + sizeX, pos.z + sizeY);
-		glTexCoord2f(1.0f, 0.0f); glVertex2f(pos.x + sizeX, pos.z - sizeY);
-		glTexCoord2f(0.0f, 0.0f); glVertex2f(pos.x - sizeX, pos.z - sizeY);
-		glTexCoord2f(0.0f, 1.0f); glVertex2f(pos.x - sizeX, pos.z + sizeY);
-	glEnd();
+	const float x0 = pos.x - sizeX;
+	const float x1 = pos.x + sizeX;
+	const float y0 = pos.z - sizeY;
+	const float y1 = pos.z + sizeY;
+
+	iconData-&gt;Draw(x0, y0, x1, y1);
 }
 
 

Modified: branches/gml/rts/Game/UI/MiniMap.h
===================================================================
--- branches/gml/rts/Game/UI/MiniMap.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/UI/MiniMap.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -10,7 +10,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 
 class CUnit;
-class CIcon;
+class CIconData;
 
 
 class CMiniMap : public CInputReceiver {
@@ -69,7 +69,7 @@
 		void DrawUnit(CUnit* unit);
 		void DrawUnitHighlight(CUnit* unit);
 		void DrawCircle(const float3&amp; pos, float radius);
-		CIcon* GetUnitIcon(CUnit* unit, float&amp; scale) const;
+		const CIconData* GetUnitIcon(CUnit* unit, float&amp; scale) const;
 		void GetFrustumSide(float3&amp; side);
 		
 	protected:

Modified: branches/gml/rts/Game/UI/MouseHandler.cpp
===================================================================
--- branches/gml/rts/Game/UI/MouseHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/UI/MouseHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -693,8 +693,9 @@
 
 void CMouseHandler::SetCursor(const std::string&amp; cmdName)
 {
-	if (cursorText.compare(cmdName)==0)
+	if (cursorText.compare(cmdName) == 0) {
 		return;
+	}
 
 	cursorText = cmdName;
 	map&lt;string, CMouseCursor*&gt;::iterator it = cursorCommandMap.find(cmdName);
@@ -722,11 +723,12 @@
 
 void CMouseHandler::UpdateCursors()
 {
-	//we update all cursors, 'cos of the command queue icons
+	// we update all cursors (for the command queue icons)
 	map&lt;string, CMouseCursor *&gt;::iterator it;
 	for (it = cursorFileMap.begin(); it != cursorFileMap.end(); ++it) {
-		if (it-&gt;second != NULL)
+		if (it-&gt;second != NULL) {
 			it-&gt;second-&gt;Update();
+		}
 	}
 }
 
@@ -831,6 +833,10 @@
 
 	delete oldCursor;
 
+	if (currentCursor == oldCursor) {
+		currentCursor = newCursor;
+	}
+
 	return true;
 }
 
@@ -853,6 +859,10 @@
 		}
 	}
 
+	if (currentCursor == cursor) {
+		currentCursor = NULL;
+	}
+
 	delete cursor;
 }
 

Modified: branches/gml/rts/Game/UI/TooltipConsole.cpp
===================================================================
--- branches/gml/rts/Game/UI/TooltipConsole.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/UI/TooltipConsole.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -198,17 +198,22 @@
 	const UnitDef* effectiveDef =
 		!enemyUnit ? unitDef : (decoyDef ? decoyDef : unitDef);
 
-	// don't show the tooltip if it's a radar dot
-	if (enemyUnit &amp;&amp; !loshandler-&gt;InLos(unit, gu-&gt;myAllyTeam)) {
+	// don't show the unit type if it is not known
+	const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
+	const unsigned short prevMask = (LOS_PREVLOS | LOS_CONTRADAR);
+	if (enemyUnit &amp;&amp;
+	    !(losStatus &amp; LOS_INLOS) &amp;&amp;
+	    ((losStatus &amp; prevMask) != prevMask)) {
 		return &quot;Enemy unit&quot;;
 	}
 
 	// show the player name instead of unit name if it has FBI tag showPlayerName
 	if (effectiveDef-&gt;showPlayerName) {
-		if (gs-&gt;Team(unit-&gt;team)-&gt;leader &gt;= 0)
+		if (gs-&gt;Team(unit-&gt;team)-&gt;leader &gt;= 0) {
 			s = gs-&gt;players[gs-&gt;Team(unit-&gt;team)-&gt;leader]-&gt;playerName.c_str();
-		else
+		} else {
 			s = &quot;Uncontrolled&quot;;
+		}
 	} else {
 		if (!decoyDef) {
 			s = unit-&gt;tooltip;
@@ -218,8 +223,9 @@
 	}
 
 	// don't show the unit health and other info if it has
-	// the FBI tag hideDamage and is not on our ally team
-	if (!enemyUnit || !effectiveDef-&gt;hideDamage) {
+	// the FBI tag hideDamage and is not on our ally team or
+	// is not in LOS
+	if (!enemyUnit || (!effectiveDef-&gt;hideDamage &amp;&amp; (losStatus &amp; LOS_INLOS))) {
 		if (!decoyDef) {
 			const float cost = unit-&gt;metalCost + (unit-&gt;energyCost / 60.0f);
 			s += MakeUnitStatsString(

Modified: branches/gml/rts/Game/WordCompletion.cpp
===================================================================
--- branches/gml/rts/Game/WordCompletion.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Game/WordCompletion.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -34,6 +34,8 @@
 	words[&quot;/clock&quot;] = sl;
 	words[&quot;/cmdcolors &quot;] = sl;
 	words[&quot;/ctrlpanel &quot;] = sl;
+	words[&quot;/distdraw &quot;] = sl;
+	words[&quot;/disticon &quot;] = sl;
 	words[&quot;/echo &quot;] = sl;
 	words[&quot;/font &quot;] = sl;
 	words[&quot;/gameinfo&quot;] = sl;

Modified: branches/gml/rts/Lua/LuaConstGame.cpp
===================================================================
--- branches/gml/rts/Lua/LuaConstGame.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaConstGame.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -8,7 +8,7 @@
 #include &quot;LuaInclude.h&quot;
 
 #include &quot;LuaUtils.h&quot;
-#include &quot;Sim/Units/CommandAI/Command.h&quot;
+#include &quot;Game/Game.h&quot;
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/GameVersion.h&quot;
 #include &quot;Map/MapDamage.h&quot;
@@ -20,6 +20,7 @@
 #include &quot;Sim/Misc/DamageArrayHandler.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot; // MAX_UNITS
+#include &quot;Sim/Units/CommandAI/Command.h&quot;
 #include &quot;System/FileSystem/ArchiveScanner.h&quot;
 
 
@@ -40,12 +41,20 @@
 
 bool LuaConstGame::PushEntries(lua_State* L)
 {
+
+	// FIXME  --  this is getting silly, convert to userdata?
+
 	const float gravity = -(mapInfo-&gt;map.gravity * GAME_SPEED * GAME_SPEED);
 	const bool limitDGun        = gameSetup ? gameSetup-&gt;limitDgun        : false;
 	const bool diminishingMMs   = gameSetup ? gameSetup-&gt;diminishingMMs   : false;
 	const bool ghostedBuildings = gameSetup ? gameSetup-&gt;ghostedBuildings : false;
 	const int  startPosType     = gameSetup ? gameSetup-&gt;startPosType     : 0;
 
+	// FIXME -- loaded too early - not set yet  (another reason to use userdata)
+	lua_pushliteral(L, &quot;gameID&quot;);
+	lua_pushlstring(L, (const char*)game-&gt;gameID, sizeof(game-&gt;gameID));
+	lua_rawset(L, -3);
+
 	LuaPushNamedString(L, &quot;version&quot;,       VERSION_STRING);
 
 	LuaPushNamedNumber(L, &quot;maxUnits&quot;,      MAX_UNITS);
@@ -62,34 +71,54 @@
 	LuaPushNamedBool(L,   &quot;diminishingMetal&quot;, diminishingMMs);
 	LuaPushNamedBool(L,   &quot;ghostedBuildings&quot;, ghostedBuildings);
 
-	LuaPushNamedBool(L,   &quot;mapDamage&quot;,         !mapDamage-&gt;disabled);
-	LuaPushNamedNumber(L, &quot;gravity&quot;,           gravity);
-	LuaPushNamedNumber(L, &quot;windMin&quot;,           wind.GetMinWind());
-	LuaPushNamedNumber(L, &quot;windMax&quot;,           wind.GetMaxWind());
-	LuaPushNamedString(L, &quot;mapName&quot;,           mapInfo-&gt;map.name);
-	LuaPushNamedString(L, &quot;mapHumanName&quot;,      mapInfo-&gt;map.humanName);
-	LuaPushNamedNumber(L, &quot;mapX&quot;,              readmap-&gt;width  / 64);
-	LuaPushNamedNumber(L, &quot;mapY&quot;,              readmap-&gt;height / 64);
-	LuaPushNamedNumber(L, &quot;mapSizeX&quot;,          readmap-&gt;width  * SQUARE_SIZE);
-	LuaPushNamedNumber(L, &quot;mapSizeZ&quot;,          readmap-&gt;height * SQUARE_SIZE);
-	LuaPushNamedNumber(L, &quot;extractorRadius&quot;,   mapInfo-&gt;map.extractorRadius);
-	LuaPushNamedNumber(L, &quot;tidal&quot;,             mapInfo-&gt;map.tidalStrength);
-	LuaPushNamedString(L, &quot;waterTexture&quot;,      mapInfo-&gt;water.texture);
-	LuaPushNamedBool(L,   &quot;waterVoid&quot;,         mapInfo-&gt;map.voidWater);
-	LuaPushNamedBool(L,   &quot;waterPlane&quot;,        mapInfo-&gt;hasWaterPlane);
-	LuaPushNamedColor(L,  &quot;waterAbsorb&quot;,       mapInfo-&gt;water.absorb);
-	LuaPushNamedColor(L,  &quot;waterBaseColor&quot;,    mapInfo-&gt;water.baseColor);
-	LuaPushNamedColor(L,  &quot;waterMinColor&quot;,     mapInfo-&gt;water.minColor);
-	LuaPushNamedColor(L,  &quot;waterSurfaceColor&quot;, mapInfo-&gt;water.surfaceColor);
-	LuaPushNamedNumber(L, &quot;waterSurfaceAlpha&quot;, mapInfo-&gt;water.surfaceAlpha);
-	LuaPushNamedColor(L,  &quot;waterSpecularColor&quot;,  mapInfo-&gt;water.specularColor);
-	LuaPushNamedNumber(L, &quot;waterSpecularFactor&quot;, mapInfo-&gt;water.specularFactor);
-	LuaPushNamedColor(L,  &quot;waterPlaneColor&quot;,   mapInfo-&gt;water.planeColor);
-	LuaPushNamedColor(L,  &quot;fogColor&quot;,          mapInfo-&gt;atmosphere.fogColor);
-	LuaPushNamedColor(L,  &quot;groundAmbientColor&quot;,      mapInfo-&gt;light.groundAmbientColor);
-	LuaPushNamedColor(L,  &quot;groundSpecularColor&quot;,     mapInfo-&gt;light.groundSpecularColor);
-	LuaPushNamedColor(L,  &quot;groundSunColor&quot;,          mapInfo-&gt;light.groundSunColor);
+	const CMapInfo* mi = mapInfo;
 
+	LuaPushNamedBool(L,   &quot;mapDamage&quot;,           !mapDamage-&gt;disabled);
+	LuaPushNamedNumber(L, &quot;gravity&quot;,             gravity);
+	LuaPushNamedNumber(L, &quot;windMin&quot;,             wind.GetMinWind());
+	LuaPushNamedNumber(L, &quot;windMax&quot;,             wind.GetMaxWind());
+	LuaPushNamedString(L, &quot;mapName&quot;,             mi-&gt;map.name);
+	LuaPushNamedString(L, &quot;mapHumanName&quot;,        mi-&gt;map.humanName);
+	LuaPushNamedNumber(L, &quot;mapX&quot;,                readmap-&gt;width  / 64);
+	LuaPushNamedNumber(L, &quot;mapY&quot;,                readmap-&gt;height / 64);
+	LuaPushNamedNumber(L, &quot;mapSizeX&quot;,            readmap-&gt;width  * SQUARE_SIZE);
+	LuaPushNamedNumber(L, &quot;mapSizeZ&quot;,            readmap-&gt;height * SQUARE_SIZE);
+	LuaPushNamedNumber(L, &quot;extractorRadius&quot;,     mi-&gt;map.extractorRadius);
+	LuaPushNamedNumber(L, &quot;tidal&quot;,               mi-&gt;map.tidalStrength);
+	LuaPushNamedNumber(L, &quot;waterDamage&quot;,         mi-&gt;water.damage);
+	LuaPushNamedString(L, &quot;waterTexture&quot;,        mi-&gt;water.texture);
+	LuaPushNamedNumber(L, &quot;waterRepeatX&quot;,        mi-&gt;water.repeatX);
+	LuaPushNamedNumber(L, &quot;waterRepeatY&quot;,        mi-&gt;water.repeatY);
+	LuaPushNamedString(L, &quot;waterFoamTexture&quot;,    mi-&gt;water.foamTexture);
+	LuaPushNamedString(L, &quot;waterNormalTexture&quot;,  mi-&gt;water.normalTexture);
+	LuaPushNamedBool(L,   &quot;waterVoid&quot;,           mi-&gt;map.voidWater);
+	LuaPushNamedBool(L,   &quot;waterPlane&quot;,          mi-&gt;hasWaterPlane);
+	LuaPushNamedColor(L,  &quot;waterAbsorb&quot;,         mi-&gt;water.absorb);
+	LuaPushNamedColor(L,  &quot;waterBaseColor&quot;,      mi-&gt;water.baseColor);
+	LuaPushNamedColor(L,  &quot;waterMinColor&quot;,       mi-&gt;water.minColor);
+	LuaPushNamedColor(L,  &quot;waterSurfaceColor&quot;,   mi-&gt;water.surfaceColor);
+	LuaPushNamedNumber(L, &quot;waterSurfaceAlpha&quot;,   mi-&gt;water.surfaceAlpha);
+	LuaPushNamedColor(L,  &quot;waterSpecularColor&quot;,  mi-&gt;water.specularColor);
+	LuaPushNamedNumber(L, &quot;waterSpecularFactor&quot;, mi-&gt;water.specularFactor);
+	LuaPushNamedColor(L,  &quot;waterPlaneColor&quot;,     mi-&gt;water.planeColor);
+	LuaPushNamedNumber(L, &quot;waterFresnelMin&quot;,     mi-&gt;water.fresnelMin);
+	LuaPushNamedNumber(L, &quot;waterFresnelMax&quot;,     mi-&gt;water.fresnelMax);
+	LuaPushNamedNumber(L, &quot;waterFresnelPower&quot;,   mi-&gt;water.fresnelPower);
+	LuaPushNamedColor(L,  &quot;fogColor&quot;,            mi-&gt;atmosphere.fogColor);
+	LuaPushNamedColor(L,  &quot;groundAmbientColor&quot;,  mi-&gt;light.groundAmbientColor);
+	LuaPushNamedColor(L,  &quot;groundSpecularColor&quot;, mi-&gt;light.groundSpecularColor);
+	LuaPushNamedColor(L,  &quot;groundSunColor&quot;,      mi-&gt;light.groundSunColor);
+
+	const string* causticTexs = mi-&gt;water.causticTextures;
+	lua_pushstring(L, &quot;waterCausticTextures&quot;);
+	lua_newtable(L);
+	for (int i = 0; i &lt; CMapInfo::causticTextureCount; i++) {
+		lua_pushnumber(L, i + 1);
+		lua_pushstring(L, causticTexs[i].c_str());
+		lua_rawset(L, -3);
+	}
+	lua_rawset(L, -3);
+
 	LuaPushNamedString(L, &quot;modName&quot;,         modInfo.humanName);
 	LuaPushNamedString(L, &quot;modShortName&quot;,    modInfo.shortName);
 	LuaPushNamedString(L, &quot;modVersion&quot;,      modInfo.version);

Modified: branches/gml/rts/Lua/LuaFeatureDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaFeatureDefs.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaFeatureDefs.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -46,8 +46,8 @@
 static int FeatureDefMetatable(lua_State* L);
 
 // special access functions
-static int FeatureDefToID(lua_State* L, const void* data);
 static int DrawTypeString(lua_State* L, const void* data);
+static int CustomParamsTable(lua_State* L, const void* data);
 
 
 /******************************************************************************/
@@ -59,9 +59,9 @@
 	  InitParamMap();
 	}
 
-	const std::map&lt;std::string, const FeatureDef*&gt;&amp; featureDefs =
+	const map&lt;string, const FeatureDef*&gt;&amp; featureDefs =
 		featureHandler-&gt;GetFeatureDefs();
-	std::map&lt;std::string, const FeatureDef*&gt;::const_iterator fdIt;
+	map&lt;string, const FeatureDef*&gt;::const_iterator fdIt;
 	for (fdIt = featureDefs.begin(); fdIt != featureDefs.end(); fdIt++) {
 	  const FeatureDef* fd = fdIt-&gt;second;
 		if (fd == NULL) {
@@ -106,7 +106,7 @@
 }
 
 
-bool LuaFeatureDefs::IsDefaultParam(const std::string&amp; word)
+bool LuaFeatureDefs::IsDefaultParam(const string&amp; word)
 {
 	if (paramMap.empty()) {
 	  InitParamMap();
@@ -313,13 +313,16 @@
 }
 
 
-static int FeatureDefToID(lua_State* L, const void* data)
+static int CustomParamsTable(lua_State* L, const void* data)
 {
-	const FeatureDef* fd = *((const FeatureDef**)data);
-	if (fd == NULL) {
-		return 0;
+	const map&lt;string, string&gt;&amp; params = *((const map&lt;string, string&gt;*)data);
+	lua_newtable(L);
+	map&lt;string, string&gt;::const_iterator it;
+	for (it = params.begin(); it != params.end(); ++it) {
+		lua_pushstring(L, it-&gt;first.c_str());
+		lua_pushstring(L, it-&gt;second.c_str());
+		lua_rawset(L, -3);
 	}
-	lua_pushnumber(L, fd-&gt;id);
 	return 1;
 }
 
@@ -391,8 +394,10 @@
 	const FeatureDef fd;
 	const char* start = ADDRESS(fd);
 
-	ADD_FUNCTION(&quot;drawTypeString&quot;,  fd.drawType, DrawTypeString);
+	ADD_FUNCTION(&quot;drawTypeString&quot;, fd.drawType,     DrawTypeString);
 
+	ADD_FUNCTION(&quot;customParams&quot;,   fd.customParams, CustomParamsTable);
+
 	ADD_FUNCTION(&quot;height&quot;,  fd, ModelHeight);
 	ADD_FUNCTION(&quot;radius&quot;,  fd, ModelRadius);
 	ADD_FUNCTION(&quot;minx&quot;,    fd, ModelMinx);

Modified: branches/gml/rts/Lua/LuaHandle.cpp
===================================================================
--- branches/gml/rts/Lua/LuaHandle.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaHandle.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,5 +1,5 @@
 #include &quot;StdAfx.h&quot;
-// LuaRules.cpp: implementation of the CLuaRules class.
+// LuaHandle.cpp: implementation of the CLuaHandle class.
 //
 //////////////////////////////////////////////////////////////////////
 

Modified: branches/gml/rts/Lua/LuaOpenGL.cpp
===================================================================
--- branches/gml/rts/Lua/LuaOpenGL.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaOpenGL.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1616,9 +1616,8 @@
 	//if (sqDist &gt;= farLength) {
 	//	return NULL;
 	//}
-	const float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
-	const float realIconLength =
-		unitDrawer-&gt;iconLength * (iconDistMult * iconDistMult);
+	const float iconDistSqrMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistanceSqr();
+	const float realIconLength = unitDrawer-&gt;iconLength * iconDistSqrMult;
 	if (sqDist &gt;= realIconLength) {
 		return NULL;
 	}

Modified: branches/gml/rts/Lua/LuaParser.cpp
===================================================================
--- branches/gml/rts/Lua/LuaParser.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaParser.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -32,6 +32,9 @@
 #endif
 
 
+static const bool lowerKeys = true;
+
+
 /******************************************************************************/
 /******************************************************************************/
 
@@ -79,6 +82,7 @@
                      const string&amp; _accessModes)
 : fileName(_fileName),
   fileModes(_fileModes),
+  textChunk(&quot;&quot;),
   accessModes(_accessModes),
   valid(false),
   initDepth(0),
@@ -105,6 +109,37 @@
 }
 
 
+LuaParser::LuaParser(const string&amp; _textChunk,
+                     const string&amp; _accessModes)
+: fileName(&quot;&quot;),
+  fileModes(&quot;&quot;),
+  textChunk(_textChunk),
+  accessModes(_accessModes),
+  valid(false),
+  initDepth(0),
+  rootRef(LUA_NOREF),
+  currentRef(LUA_NOREF)
+{
+	L = lua_open();
+
+	if (L != NULL) {
+		SetupStdLibs(L);
+
+		GetTable(&quot;Spring&quot;);
+		AddFunc(&quot;Echo&quot;, Echo);
+		AddFunc(&quot;TimeCheck&quot;, TimeCheck);
+		EndTable();
+
+		GetTable(&quot;VFS&quot;);
+		AddFunc(&quot;DirList&quot;,    DirList);
+		AddFunc(&quot;Include&quot;,    Include);
+		AddFunc(&quot;LoadFile&quot;,   LoadFile);
+		AddFunc(&quot;FileExists&quot;, FileExists);
+		EndTable();
+	}
+}
+
+
 LuaParser::~LuaParser()
 {
 	if (L != NULL) {
@@ -298,20 +333,28 @@
 	initDepth = -1;
 
 	string code;
-	CFileHandler fh(fileName, fileModes);
-	if (!fh.LoadStringData(code)) {
-		errorLog = &quot;could not open file: &quot; + fileName;
-		lua_close(L);
-		L = NULL;
-		return false;
+	string codeLabel;
+	if (textChunk.size() &gt; 0) {
+		code = textChunk;
+		codeLabel = &quot;text chunk&quot;;
 	}
+	else {
+		codeLabel = fileName;
+		CFileHandler fh(fileName, fileModes);
+		if (!fh.LoadStringData(code)) {
+			errorLog = &quot;could not open file: &quot; + fileName;
+			lua_close(L);
+			L = NULL;
+			return false;
+		}
+	}
 
 	int error;
-	error = luaL_loadbuffer(L, code.c_str(), code.size(), fileName.c_str());
+	error = luaL_loadbuffer(L, code.c_str(), code.size(), codeLabel.c_str());
 	if (error != 0) {
 		errorLog = lua_tostring(L, -1);
 		logOutput.Print(&quot;error = %i, %s, %s\n&quot;,
-		                error, fileName.c_str(), errorLog.c_str());
+		                error, codeLabel.c_str(), errorLog.c_str());
 		lua_close(L);
 		L = NULL;
 		return false;
@@ -677,7 +720,8 @@
 
 LuaTable LuaTable::SubTable(const string&amp; mixedKey) const
 {
-	const string key = StringToLower(mixedKey);
+	
+	const string key = !lowerKeys ? mixedKey : StringToLower(mixedKey);
 
 	LuaTable subTable;
 	subTable.path = path + &quot;.&quot; + key;
@@ -771,7 +815,7 @@
 
 bool LuaTable::PushValue(const string&amp; mixedKey) const
 {
-	const string key = StringToLower(mixedKey);
+	const string key = !lowerKeys ? mixedKey : StringToLower(mixedKey);
 	if (!PushTable()) {
 		return false;
 	}

Modified: branches/gml/rts/Lua/LuaParser.h
===================================================================
--- branches/gml/rts/Lua/LuaParser.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaParser.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -67,6 +67,21 @@
 		float3 GetFloat3(const string&amp; key, const float3&amp; def) const;
 		string GetString(const string&amp; key, const string&amp; def) const;
 
+		/* not having these makes for better code, imo
+		LuaTable operator[](int key)           const { return SubTable(key); }
+		LuaTable operator[](const string&amp; key) const { return SubTable(key); }
+		int    operator()(int key, int def)           const { return GetInt(key, def);    }
+		bool   operator()(int key, bool def)          const { return GetBool(key, def);   }
+		float  operator()(int key, float def)         const { return GetFloat(key, def);  }
+		float3 operator()(int key, const float3&amp; def) const { return GetFloat3(key, def); }
+		string operator()(int key, const string&amp; def) const { return GetString(key, def); }
+		int    operator()(const string&amp; key, int def)           const { return GetInt(key, def);    }
+		bool   operator()(const string&amp; key, bool def)          const { return GetBool(key, def);   }
+		float  operator()(const string&amp; key, float def)         const { return GetFloat(key, def);  }
+		float3 operator()(const string&amp; key, const float3&amp; def) const { return GetFloat3(key, def); }
+		string operator()(const string&amp; key, const string&amp; def) const { return GetString(key, def); }
+		*/
+
 	private:
 		LuaTable(LuaParser* parser); // for LuaParser::GetRoot()
 
@@ -93,6 +108,8 @@
 		LuaParser(const string&amp; fileName,
 		          const string&amp; fileModes,
 		          const string&amp; accessModes);
+		LuaParser(const string&amp; textChunk,
+		          const string&amp; accessModes);
 		~LuaParser();
 
 		bool Execute();
@@ -123,6 +140,7 @@
 	public:
 		const string fileName;
 		const string fileModes;
+		const string textChunk;
 		const string accessModes;
 
 	private:

Modified: branches/gml/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- branches/gml/rts/Lua/LuaSyncedCtrl.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaSyncedCtrl.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -117,6 +117,8 @@
 	REGISTER_LUA_CFUNC(SetUnitStockpile);
 	REGISTER_LUA_CFUNC(SetUnitWeaponState);
 	REGISTER_LUA_CFUNC(SetUnitExperience);
+	REGISTER_LUA_CFUNC(SetUnitLosMask);
+	REGISTER_LUA_CFUNC(SetUnitLosState);
 	REGISTER_LUA_CFUNC(SetUnitCloak);
 	REGISTER_LUA_CFUNC(SetUnitStealth);
 	REGISTER_LUA_CFUNC(SetUnitAlwaysVisible);
@@ -1208,6 +1210,84 @@
 }
 
 
+static unsigned char ParseLosBits(lua_State* L, int index, unsigned char bits)
+{
+	if (lua_isnumber(L, index)) {
+		return (unsigned char)lua_tonumber(L, index);
+	}
+	else if (lua_istable(L, index)) {
+		for (lua_pushnil(L); lua_next(L, index) != 0; lua_pop(L, 1)) {
+			if (!lua_israwstring(L, -2)) { luaL_error(L, &quot;bad key type&quot;);   }
+			if (!lua_isboolean(L, -1))   { luaL_error(L, &quot;bad value type&quot;); }
+			const string key = lua_tostring(L, -2);
+			const bool set = lua_toboolean(L, -1);
+			if (key == &quot;los&quot;) {
+				if (set) { bits |=  LOS_INLOS; }
+				else     { bits &amp;= ~LOS_INLOS; }
+			}
+			else if (key == &quot;radar&quot;) {
+				if (set) { bits |=  LOS_INRADAR; }
+				else     { bits &amp;= ~LOS_INRADAR; }
+			}
+			else if (key == &quot;prevLos&quot;) {
+				if (set) { bits |=  LOS_PREVLOS; }
+				else     { bits &amp;= ~LOS_PREVLOS; }
+			}
+			else if (key == &quot;contRadar&quot;) {
+				if (set) { bits |=  LOS_CONTRADAR; }
+				else     { bits &amp;= ~LOS_CONTRADAR; }
+			}
+		}
+		return bits;
+	}
+ 	luaL_error(L, &quot;ERROR: expected number or table&quot;);
+	return 0;
+}
+
+
+int LuaSyncedCtrl::SetUnitLosMask(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	const int allyTeam = luaL_checkint(L, 2);
+	if ((allyTeam &lt; 0) || (allyTeam &gt;= MAX_TEAMS)) {
+		luaL_error(L, &quot;bad allyTeam&quot;);
+	}
+	const unsigned short losStatus = unit-&gt;losStatus[allyTeam];
+	const unsigned char  oldMask = losStatus &gt;&gt; 8;
+	const unsigned char  newMask = ParseLosBits(L, 3, oldMask);
+	const unsigned short state = (newMask &lt;&lt; 8) | (losStatus &amp; 0x00FF);
+
+	unit-&gt;losStatus[allyTeam] = state;
+	unit-&gt;SetLosStatus(allyTeam, unit-&gt;CalcLosStatus(allyTeam));
+
+	return 0;
+}
+
+
+int LuaSyncedCtrl::SetUnitLosState(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	const int allyTeam = luaL_checkint(L, 2);
+	if ((allyTeam &lt; 0) || (allyTeam &gt;= MAX_TEAMS)) {
+		luaL_error(L, &quot;bad allyTeam&quot;);
+	}
+	const unsigned short losStatus = unit-&gt;losStatus[allyTeam];
+	const unsigned char  oldState = losStatus &amp; 0xFF;
+	const unsigned char  newState = ParseLosBits(L, 3, oldState);
+	const unsigned short state = (losStatus &amp; 0xFF00) | newState;
+
+	unit-&gt;SetLosStatus(allyTeam, state);
+
+	return 0;
+}
+
+
 int LuaSyncedCtrl::SetUnitCloak(lua_State* L)
 {
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);

Modified: branches/gml/rts/Lua/LuaSyncedCtrl.h
===================================================================
--- branches/gml/rts/Lua/LuaSyncedCtrl.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaSyncedCtrl.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -56,6 +56,8 @@
 		static int SetUnitStockpile(lua_State* L);
 		static int SetUnitWeaponState(lua_State* L);
 		static int SetUnitExperience(lua_State* L);
+		static int SetUnitLosMask(lua_State* L);
+		static int SetUnitLosState(lua_State* L);
 		static int SetUnitCloak(lua_State* L);
 		static int SetUnitStealth(lua_State* L);
 		static int SetUnitAlwaysVisible(lua_State* L);

Modified: branches/gml/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- branches/gml/rts/Lua/LuaSyncedRead.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaSyncedRead.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -58,7 +58,6 @@
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;System/myMath.h&quot;
 #include &quot;System/LogOutput.h&quot;
-#include &quot;System/TdfParser.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;System/FileSystem/VFSHandler.h&quot;
 #include &quot;System/Platform/FileSystem.h&quot;
@@ -336,8 +335,8 @@
 	if (readAllyTeam &lt; 0) {
 		return fullRead;
 	}
-	const int losStatus = unit-&gt;losStatus[readAllyTeam];
-	const int prevMask = (LOS_PREVLOS | LOS_CONTRADAR);
+	const unsigned short losStatus = unit-&gt;losStatus[readAllyTeam];
+	const unsigned short prevMask = (LOS_PREVLOS | LOS_CONTRADAR);
 	if ((losStatus &amp; LOS_INLOS) ||
 	    ((losStatus &amp; prevMask) == prevMask)) {
 		return true;
@@ -2775,16 +2774,18 @@
 		if (!fullRead) {
 			return 0;
 		}
-		const int args = lua_gettop(L); // number of arguments
-		if ((args &lt; 2) || !lua_isnumber(L, 2)) {
-			return 0;
-		}
-		allyTeam = (int)lua_tonumber(L, 2);
+		allyTeam = luaL_checkint(L, 2);
 	}
 	if ((allyTeam &lt; 0) || (allyTeam &gt;= gs-&gt;activeAllyTeams)) {
 		return 0;
 	}
-	const int losStatus = unit-&gt;losStatus[allyTeam];
+	const unsigned short losStatus = unit-&gt;losStatus[allyTeam];
+
+	if (fullRead &amp;&amp; lua_isboolean(L, 3) &amp;&amp; lua_toboolean(L, 3)) {
+		lua_pushnumber(L, losStatus);
+		return 1;
+	}
+	
 	lua_newtable(L);
 	if (losStatus &amp; LOS_INLOS) {
 		HSTR_PUSH_BOOL(L, &quot;los&quot;, true);

Modified: branches/gml/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnitDefs.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaUnitDefs.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -23,6 +23,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
 #include &quot;Map/MapInfo.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
@@ -87,8 +88,8 @@
 	  InitParamMap();
 	}
 
-	const std::map &lt;std::string, int&gt;&amp; udMap = unitDefHandler-&gt;unitID;
-	std::map&lt; std::string, int&gt;::const_iterator udIt;
+	const map&lt;string, int&gt;&amp; udMap = unitDefHandler-&gt;unitID;
+	map&lt;string, int&gt;::const_iterator udIt;
 	for (udIt = udMap.begin(); udIt != udMap.end(); udIt++) {
 	  const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(udIt-&gt;second);
 		if (ud == NULL) {
@@ -133,7 +134,7 @@
 }
 
 
-bool LuaUnitDefs::IsDefaultParam(const std::string&amp; word)
+bool LuaUnitDefs::IsDefaultParam(const string&amp; word)
 {
 	if (paramMap.empty()) {
 	  InitParamMap();
@@ -313,8 +314,8 @@
 {
 	// the iconType is unsynced because LuaUI has SetUnitDefIcon()
 	if (CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
-		const string&amp; iconType = *((const string*)data);
-		lua_pushstring(L, iconType.c_str());
+		const CIcon&amp; iconType = *((const CIcon*)data);
+		lua_pushstring(L, iconType-&gt;GetName().c_str());
 		return 1;
 	}
 	return 0;
@@ -483,7 +484,7 @@
 	HSTR_PUSH_STRING(L, &quot;name&quot;, md.modelname);
 	HSTR_PUSH(L, &quot;textures&quot;);
 	lua_newtable(L);
-	std::map&lt;std::string, std::string&gt;::const_iterator it;
+	map&lt;string, string&gt;::const_iterator it;
 	for (it = md.textures.begin(); it != md.textures.end(); ++it) {
 		LuaPushNamedString(L, it-&gt;first, it-&gt;second);
 	}
@@ -744,14 +745,6 @@
 	ADD_INT(&quot;armorType&quot;,         ud.armorType);
 	ADD_FLOAT(&quot;armoredMultiple&quot;, ud.armoredMultiple);
 
-	/*
-	ADD_FLOAT(&quot;hitSphereScale&quot;,   ud.collisionSphereScale);
-	ADD_FLOAT(&quot;hitSphereOffsetX&quot;, ud.collisionSphereOffset.x);
-	ADD_FLOAT(&quot;hitSphereOffsetY&quot;, ud.collisionSphereOffset.y);
-	ADD_FLOAT(&quot;hitSphereOffsetZ&quot;, ud.collisionSphereOffset.z);
-	ADD_BOOL(&quot;useHitSphereOffset&quot;, ud.useCSOffset);
-	*/
-
 	ADD_FLOAT(&quot;minCollisionSpeed&quot;, ud.minCollisionSpeed);
 	ADD_FLOAT(&quot;slideTolerance&quot;,    ud.slideTolerance);
 
@@ -916,7 +909,7 @@
 	ADD_FLOAT(&quot;nanoColorG&quot;,   ud.nanoColor.y);
 	ADD_FLOAT(&quot;nanoColorB&quot;,   ud.nanoColor.z);
 
-//	std::vector&lt;CExplosionGenerator*&gt;  sfxExplGens;
+//	vector&lt;CExplosionGenerator*&gt;  sfxExplGens;
 	ADD_STRING(&quot;pieceTrailCEGTag&quot;,   ud.pieceTrailCEGTag);
 	ADD_INT(   &quot;pieceTrailCEGRange&quot;, ud.pieceTrailCEGRange);
 

Modified: branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -18,8 +18,8 @@
 #include &quot;LuaUtils.h&quot;
 
 #include &quot;Game/Camera.h&quot;
+#include &quot;Game/CameraHandler.h&quot;
 #include &quot;Game/Camera/CameraController.h&quot;
-#include &quot;Game/CameraHandler.h&quot;
 #include &quot;Game/Game.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/Team.h&quot;
@@ -28,6 +28,7 @@
 #include &quot;Game/UI/CursorIcons.h&quot;
 #include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
@@ -101,6 +102,9 @@
 	REGISTER_LUA_CFUNC(SetUnitNoMinimap);
 	REGISTER_LUA_CFUNC(SetUnitNoSelect);
 
+	REGISTER_LUA_CFUNC(AddUnitIcon);
+	REGISTER_LUA_CFUNC(FreeUnitIcon);
+
 	REGISTER_LUA_CFUNC(ExtractModArchiveFile);
 	return true;
 }
@@ -596,38 +600,28 @@
 		return 0;
 	}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_istable(L, 1) || !lua_isnumber(L, 2)) {
+	if (!lua_istable(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to SetCameraState(table, camTime)&quot;);
 	}
 
+	const float camTime = (float)luaL_checknumber(L, 2);
+	
+	CCameraController::StateMap camState;
+
 	const int table = 1;
-	const float camTime = (float)lua_tonumber(L, 2);
-
-	lua_pushstring(L, &quot;mode&quot;);
-	lua_gettable(L, table);
-	if (lua_isnumber(L, -1)) {
-		const int camNum = (int)lua_tonumber(L, -1);
-		camHandler-&gt;SetCameraMode(camNum);
-		camHandler-&gt;CameraTransition(camTime);
-	}
-
-	vector&lt;float&gt; camState;
-	int index = 1;
-	while (true) {
-		lua_rawgeti(L, table, index);
-		if (!lua_isnumber(L, -1)) {
-			lua_pop(L, 1);
-			break;
+	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
+		if (lua_israwstring(L, -2)) {
+			const string key = lua_tostring(L, -2);
+			if (lua_isnumber(L, -1)) {
+				camState[key] = (float)lua_tonumber(L, -1);
+			}
+			else if (lua_isboolean(L, -1)) {
+				camState[key] = lua_toboolean(L, -1) ? +1.0f : -1.0f;
+			}
 		}
-		else {
-			camState.push_back((float)lua_tonumber(L, -1));
-			lua_pop(L, 1);
-			index++;
-		}
 	}
 
-	lua_pushboolean(L, camHandler-&gt;GetCurrentController().SetState(camState));
+	lua_pushboolean(L, camHandler-&gt;SetState(camState));
 	camHandler-&gt;CameraTransition(camTime);
 
 	if (CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
@@ -929,64 +923,86 @@
 }
 
 
+/******************************************************************************/
 
+int LuaUnsyncedCtrl::AddUnitIcon(lua_State* L)
+{
+	if (!CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
+		return 0;
+	}
+	const string iconName  = luaL_checkstring(L, 1);
+	const string texName   = luaL_checkstring(L, 2);
+	const float  size      = luaL_optnumber(L, 3, 1.0f);
+	const float  dist      = luaL_optnumber(L, 4, 1.0f);
+	const bool   radAdjust = (lua_isboolean(L, 5) &amp;&amp; lua_toboolean(L, 5));
+	lua_pushboolean(L, iconHandler-&gt;AddIcon(iconName, texName,
+	                                        size, dist, radAdjust));
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::FreeUnitIcon(lua_State* L)
+{
+	if (!CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
+		return 0;
+	}
+	const string iconName  = luaL_checkstring(L, 1);
+	lua_pushboolean(L, iconHandler-&gt;FreeIcon(iconName));
+	return 1;
+}
+
+
+/******************************************************************************/
+
 // TODO: move this to LuaVFS?
 int LuaUnsyncedCtrl::ExtractModArchiveFile(lua_State* L)
 {
-	bool ret = false;
-	const int args = lua_gettop(L);
+	const string path = luaL_checkstring(L, 1);
 
-	if (args == 1) {
-		if (lua_isstring(L, 1)) {
-			std::string path(lua_tostring(L, 1));
-			CFileHandler fh(path, SPRING_VFS_MOD);
+	CFileHandler fh(path, SPRING_VFS_MOD);
 
-			if (fh.FileExists()) {
-				std::string dname = filesystem.GetDirectory(path);
-				std::string fname = filesystem.GetFilename(path);
+	if (!fh.FileExists()) {
+		luaL_error(L, &quot;Path \&quot;%s\&quot; not found in mod archive&quot;, path.c_str());
+	}
 
-				#ifdef WIN32
-				const int s = dname.size();
-				// get rid of any trailing slashes (CreateDirectory()
-				// fails on at least XP and Vista if they are present,
-				// ie. it creates the dir but actually returns false)
-				if (s &gt; 0 &amp;&amp; (dname[s - 1] == '/' || dname[s - 1] == '\\')) {
-					dname = dname.substr(0, s - 1);
-				}
-				#endif
+	string dname = filesystem.GetDirectory(path);
+	string fname = filesystem.GetFilename(path);
 
-				if (dname.size() == 0 || filesystem.CreateDirectory(dname)) {
-					int numBytes = fh.FileSize();
-					char* buffer = SAFE_NEW char[numBytes];
+#ifdef WIN32
+	const int s = dname.size();
+	// get rid of any trailing slashes (CreateDirectory()
+	// fails on at least XP and Vista if they are present,
+	// ie. it creates the dir but actually returns false)
+	if ((s &gt; 0) &amp;&amp; ((dname[s - 1] == '/') || (dname[s - 1] == '\\'))) {
+		dname = dname.substr(0, s - 1);
+	}
+#endif
 
-					fh.Read(buffer, numBytes);
+	if (!dname.empty() &amp;&amp; !filesystem.CreateDirectory(dname)) {
+		luaL_error(L, &quot;Could not create directory \&quot;%s\&quot; for file \&quot;%s\&quot;&quot;,
+		           dname.c_str(), fname.c_str());
+	}
 
-					std::fstream fstr(path.c_str(), std::ios::out | std::ios::binary);
-					fstr.write((const char*) buffer, numBytes);
-					fstr.close();
+	const int numBytes = fh.FileSize();
+	char* buffer = SAFE_NEW char[numBytes];
 
-					if (dname.size() &gt; 0) {
-						logOutput.Print(&quot;Extracted file \&quot;%s\&quot; to directory \&quot;%s\&quot;&quot;, fname.c_str(), dname.c_str());
-					} else {
-						logOutput.Print(&quot;Extracted file \&quot;%s\&quot;&quot;, fname.c_str());
-					}
+	fh.Read(buffer, numBytes);
 
-					delete[] buffer;
-					ret = true;
-				} else {
-					luaL_error(L, &quot;Could not create directory \&quot;%s\&quot; for file \&quot;%s\&quot;&quot;, dname.c_str(), fname.c_str());
-				}
-			} else {
-				luaL_error(L, &quot;Path \&quot;%s\&quot; not found in mod archive&quot;, path.c_str());
-			}
-		} else {
-			luaL_error(L, &quot;Argument to ExtractModArchiveFile(s) not a string&quot;);
-		}
+	fstream fstr(path.c_str(), ios::out | ios::binary);
+	fstr.write((const char*) buffer, numBytes);
+	fstr.close();
+
+	if (!dname.empty()) {
+		logOutput.Print(&quot;Extracted file \&quot;%s\&quot; to directory \&quot;%s\&quot;&quot;,
+		                fname.c_str(), dname.c_str());
 	} else {
-		luaL_error(L, &quot;Incorrect number of arguments to ExtractModArchiveFile(s)&quot;);
+		logOutput.Print(&quot;Extracted file \&quot;%s\&quot;&quot;, fname.c_str());
 	}
 
-	lua_pushboolean(L, ret);
+	delete[] buffer;
+
+	lua_pushboolean(L, true);
+
 	return 1;
 }
 

Modified: branches/gml/rts/Lua/LuaUnsyncedCtrl.h
===================================================================
--- branches/gml/rts/Lua/LuaUnsyncedCtrl.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaUnsyncedCtrl.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -62,6 +62,9 @@
 		static int SetUnitNoMinimap(lua_State* L);
 		static int SetUnitNoSelect(lua_State* L);
 
+		static int AddUnitIcon(lua_State* L);
+		static int FreeUnitIcon(lua_State* L);
+
 		static int ExtractModArchiveFile(lua_State* L);
 };
 

Modified: branches/gml/rts/Lua/LuaUnsyncedRead.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnsyncedRead.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaUnsyncedRead.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -406,8 +406,8 @@
 
 		if (noIcons) {
 			const float sqDist = (unit-&gt;pos - camera-&gt;pos).SqLength();
-			const float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
-			const float realIconLength = iconLength * (iconDistMult * iconDistMult);
+			const float iconDistSqrMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistanceSqr();
+			const float realIconLength = iconLength * iconDistSqrMult;
 			if (sqDist &gt; realIconLength) {
 				continue;
 			}
@@ -653,19 +653,16 @@
 
 	lua_newtable(L);
 
-	lua_pushstring(L, &quot;mode&quot;);
-	lua_pushnumber(L, camHandler-&gt;GetCurrentControllerNum());
-	lua_rawset(L, -3);
 	lua_pushstring(L, &quot;name&quot;);
-	lua_pushstring(L, camHandler-&gt;GetCurrentController().GetName().c_str());
+	lua_pushstring(L, camHandler-&gt;GetCurrentControllerName().c_str());
 	lua_rawset(L, -3);
 
-
-	vector&lt;float&gt; camState;
-	camHandler-&gt;GetCurrentController().GetState(camState);
-	for (int i = 0; i &lt; (int)camState.size(); i++) {
-		lua_pushnumber(L, i + 1);
-		lua_pushnumber(L, camState[i]);
+	CCameraController::StateMap camState;
+	CCameraController::StateMap::const_iterator it;
+	camHandler-&gt;GetState(camState);
+	for (it = camState.begin(); it != camState.end(); ++it) {
+		lua_pushstring(L, it-&gt;first.c_str());
+		lua_pushnumber(L, it-&gt;second);
 		lua_rawset(L, -3);
 	}
 

Modified: branches/gml/rts/Lua/LuaUtils.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUtils.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaUtils.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -34,22 +34,31 @@
 
 static bool CopyPushData(lua_State* dst, lua_State* src, int index)
 {
-	if (lua_isboolean(src, index)) {
-		lua_pushboolean(dst, lua_toboolean(src, index));
+	const int type = lua_type(src, index);
+	switch (type) {
+		case LUA_TBOOLEAN: {
+			lua_pushboolean(dst, lua_toboolean(src, index));
+			break;
+		}
+		case LUA_TNUMBER: {
+			lua_pushnumber(dst, lua_tonumber(src, index));
+			break;
+		}
+		case LUA_TSTRING: {
+			size_t len;
+			const char* data = lua_tolstring(src, index, &amp;len);
+			lua_pushlstring(dst, data, len);
+			break;
+		}
+		case LUA_TTABLE: {
+			CopyPushTable(dst, src, index);
+			break;
+		}
+		default: {
+			lua_pushnil(dst); // unhandled type
+			return false;
+		}
 	}
-	else if (lua_israwnumber(src, index)) {
-		lua_pushnumber(dst, lua_tonumber(src, index));
-	}
-	else if (lua_israwstring(src, index)) {
-		lua_pushstring(dst, lua_tostring(src, index));
-	}
-	else if (lua_istable(src, index)) {
-		CopyPushTable(dst, src, index);
-	}
-	else {
-		lua_pushnil(dst); // unhandled type
-		return false;
-	}
 	return true;
 }
 

Modified: branches/gml/rts/Lua/LuaWeaponDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaWeaponDefs.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Lua/LuaWeaponDefs.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -48,6 +48,7 @@
 
 static int VisualsTable(lua_State* L, const void* data);
 static int DamagesArray(lua_State* L, const void* data);
+static int CustomParamsTable(lua_State* L, const void* data);
 static int GuiSoundSetTable(lua_State* L, const void* data);
 static int CategorySetFromBits(lua_State* L, const void* data);
 static int CategorySetFromString(lua_State* L, const void* data);
@@ -62,8 +63,8 @@
 	  InitParamMap();
 	}
 
-	const std::map&lt;std::string, int&gt;&amp; weaponMap = weaponDefHandler-&gt;weaponID;
-	std::map&lt;std::string, int&gt;::const_iterator wit;
+	const map&lt;string, int&gt;&amp; weaponMap = weaponDefHandler-&gt;weaponID;
+	map&lt;string, int&gt;::const_iterator wit;
 	for (wit = weaponMap.begin(); wit != weaponMap.end(); wit++) {
 		const WeaponDef* wd = &amp;weaponDefHandler-&gt;weaponDefs[wit-&gt;second];
 		if (wd == NULL) {
@@ -366,6 +367,20 @@
 }
 
 
+static int CustomParamsTable(lua_State* L, const void* data)
+{
+	const map&lt;string, string&gt;&amp; params = *((const map&lt;string, string&gt;*)data);
+	lua_newtable(L);
+	map&lt;string, string&gt;::const_iterator it;
+	for (it = params.begin(); it != params.end(); ++it) {
+		lua_pushstring(L, it-&gt;first.c_str());
+		lua_pushstring(L, it-&gt;second.c_str());
+		lua_rawset(L, -3);
+	}
+	return 1;
+}
+
+
 static int GuiSoundSetTable(lua_State* L, const void* data)
 {
 	const GuiSoundSet&amp; soundSet = *((const GuiSoundSet*) data);
@@ -404,6 +419,7 @@
 	ADD_FUNCTION(&quot;hitSound&quot;,  wd.soundhit,  GuiSoundSetTable);
 	ADD_FUNCTION(&quot;fireSound&quot;, wd.firesound, GuiSoundSetTable);
 
+	ADD_FUNCTION(&quot;customParams&quot;,         wd.customParams,   CustomParamsTable);
 	ADD_FUNCTION(&quot;noFeatureCollide&quot;,     wd.collisionFlags, NoFeatureCollide);
 	ADD_FUNCTION(&quot;noFriendlyCollide&quot;,    wd.collisionFlags, NoFriendlyCollide);
 	ADD_FUNCTION(&quot;noNeutralCollide&quot;,     wd.collisionFlags, NoNeutralCollide);
@@ -536,11 +552,11 @@
 	ADD_BOOL(&quot;avoidFeature&quot;,  wd.avoidFeature);
 	ADD_BOOL(&quot;avoidNeutral&quot;,  wd.avoidNeutral);
 
-	ADD_FLOAT(&quot;targetBorder&quot;, wd.targetBorder);
+	ADD_FLOAT(&quot;targetBorder&quot;,       wd.targetBorder);
 	ADD_FLOAT(&quot;cylinderTargetting&quot;, wd.cylinderTargetting);
-	ADD_FLOAT(&quot;minIntensity&quot;, wd.minIntensity);
-	ADD_FLOAT(&quot;heightBoostFactor&quot;, wd.heightBoostFactor);
-	ADD_FLOAT(&quot;proximityPriority&quot;, wd.proximityPriority);
+	ADD_FLOAT(&quot;minIntensity&quot;,       wd.minIntensity);
+	ADD_FLOAT(&quot;heightBoostFactor&quot;,  wd.heightBoostFactor);
+	ADD_FLOAT(&quot;proximityPriority&quot;,  wd.proximityPriority);
 
 //	CExplosionGenerator *explosionGenerator;
 

Modified: branches/gml/rts/Map/MapInfo.cpp
===================================================================
--- branches/gml/rts/Map/MapInfo.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Map/MapInfo.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,8 +1,10 @@
 #include &quot;MapInfo.h&quot;
 
-#include &quot;TdfParser.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/TdfParser.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 
-
 float4::float4()
 {
 	float tmp[4];
@@ -29,8 +31,12 @@
 {
 	map.name = mapname;
 	mapDefParser = new TdfParser(GetTDFName(mapname));
-	resources = new TdfParser(&quot;gamedata/resources.tdf&quot;);
-
+	resourcesParser = new LuaParser (&quot;gamedata/resources.lua&quot;,
+	                                 SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
+	if (!resourcesParser-&gt;Execute()) {
+		logOutput.Print(resourcesParser-&gt;GetErrorLog());
+	}
+	
 	ReadGlobal();
 	ReadAtmosphere();
 	ReadGui();
@@ -40,8 +46,8 @@
 	ReadSm3();
 	ReadTerrainTypes();
 
-	delete resources;
-	resources = NULL;
+	delete resourcesParser;
+	resourcesParser = NULL;
 }
 
 
@@ -170,27 +176,29 @@
 	mapDefParser-&gt;GetDef(water.normalTexture, &quot;&quot;, &quot;MAP\\WATER\\WaterNormalTexture&quot;);
 
 	//default water is ocean.jpg in bitmaps, map specific water textures is saved in the map dir
+	const LuaTable mapsTable = resourcesParser-&gt;GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;maps&quot;);
+	const LuaTable causticsTable = resourcesParser-&gt;GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;caustics&quot;);
+	
 	if(water.texture.empty())
-		water.texture = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;ocean.jpg&quot;, &quot;resources\\graphics\\maps\\watertex&quot;);
+		water.texture = &quot;bitmaps/&quot; + mapsTable.GetString(&quot;watertex&quot;, &quot;ocean.jpg&quot;);
 	else
 		water.texture = &quot;maps/&quot; + water.texture;
 
-	
 	if(water.foamTexture.empty())
-		water.foamTexture = &quot;bitmaps/&quot;+resources-&gt;SGetValueDef(&quot;foam.jpg&quot;,&quot;resources\\graphics\\maps\\waterfoamtex&quot;);
+		water.foamTexture = &quot;bitmaps/&quot; + mapsTable.GetString(&quot;waterfoamtex&quot;, &quot;foam.jpg&quot;);
 	else
 		water.foamTexture = &quot;maps/&quot; + water.foamTexture;
 
 	if(water.normalTexture.empty())
-		water.normalTexture = &quot;bitmaps/&quot;+resources-&gt;SGetValueDef(&quot;waterbump.png&quot;,&quot;resources\\graphics\\maps\\waternormaltex&quot;);
+		water.normalTexture = &quot;bitmaps/&quot; + mapsTable.GetString(&quot;waternormaltex&quot;, &quot;waterbump.png&quot;);
 	else
 		water.normalTexture = &quot;maps/&quot; + water.normalTexture;
 
 	char num[10];
-	for (int i = 0; i &lt; 32; i++) {
+	for (int i = 0; i &lt; causticTextureCount; i++) {
 		sprintf(num, &quot;%02i&quot;, i);
-		water.causticTextures[i] = std::string(&quot;bitmaps/&quot;) + resources-&gt;SGetValueDef(std::string(&quot;caustics/caustic&quot;)+num+&quot;.jpg&quot;,
-								std::string(&quot;resources\\graphics\\caustics\\caustic&quot;)+num);
+		water.causticTextures[i] = std::string(&quot;bitmaps/&quot;) + causticsTable.GetString(std::string(&quot;caustic&quot;)+num, 
+															 std::string(&quot;caustic&quot;)+num+&quot;.jpg&quot;);
 	}
 }
 
@@ -199,8 +207,11 @@
 {
 	// SMF specific settings
 	mapDefParser-&gt;GetDef(smf.detailTexName, &quot;&quot;, &quot;MAP\\DetailTex&quot;);
+
+	const LuaTable mapsTable = resourcesParser-&gt;GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;maps&quot;);
+	
 	if (smf.detailTexName.empty())
-		smf.detailTexName = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;detailtex2.bmp&quot;, &quot;resources\\graphics\\maps\\detailtex&quot;);
+		smf.detailTexName = &quot;bitmaps/&quot; + mapsTable.GetString(&quot;detailtex&quot;,&quot;detailtex2.bmp&quot;);
 	else
 		smf.detailTexName = &quot;maps/&quot; + smf.detailTexName;
 }

Modified: branches/gml/rts/Map/MapInfo.h
===================================================================
--- branches/gml/rts/Map/MapInfo.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Map/MapInfo.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -5,6 +5,7 @@
 #include &quot;float3.h&quot;
 
 class TdfParser;
+class LuaParser;
 
 
 /** Float3 with a fourth data member, which is basically unused but required
@@ -112,6 +113,7 @@
 
 	/** settings read from &quot;MAP\WATER&quot; section
 	    prefix their name with &quot;Water&quot; to get the TDF variable */
+	static const int causticTextureCount = 32;
 	struct water_t {
 		float  repeatX; ///&lt; (calculated default is in CBaseWater)
 		float  repeatY; ///&lt; (calculated default is in CBaseWater)
@@ -130,7 +132,7 @@
 		std::string texture;
 		std::string foamTexture;
 		std::string normalTexture;
-		std::string causticTextures[32];
+		std::string causticTextures[causticTextureCount];
 	} water;
 	bool hasWaterPlane; ///&lt; true if &quot;MAP\WATER\WaterPlaneColor&quot; is set
 
@@ -170,7 +172,7 @@
 	void ReadSm3();
 	void ReadTerrainTypes();
 
-	TdfParser* resources;
+	LuaParser* resourcesParser;
 	TdfParser* mapDefParser;
 };
 

Modified: branches/gml/rts/Map/ReadMap.cpp
===================================================================
--- branches/gml/rts/Map/ReadMap.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Map/ReadMap.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -23,7 +23,6 @@
 #include &quot;System/LoadSaveInterface.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Platform/errorhandler.h&quot;
-#include &quot;System/TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 
 using namespace std;

Modified: branches/gml/rts/Map/SM3/terrain/TerrainTexture.cpp
===================================================================
--- branches/gml/rts/Map/SM3/terrain/TerrainTexture.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Map/SM3/terrain/TerrainTexture.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -249,10 +249,9 @@
 		GenerateInfo gi;
 		gi.bmMipmaps = bmMipmaps;
 
-		if (cb) cb-&gt;PrintMsg (&quot;  generating blendmap mipmaps...&quot;);
+		if (cb) { cb-&gt;PrintMsg (&quot;  generating blendmap mipmaps...&quot;); }
 
-		for (int a=0;a&lt;blendMaps.size();a++)
-		{
+		for (int a=0;a&lt;blendMaps.size();a++) {
 			Blendmap *bm = blendMaps[a];
 
 			AlphaImage *cur = bm-&gt;image;
@@ -273,13 +272,11 @@
 		if (cb) cb-&gt;PrintMsg (&quot;  loading blendmaps into OpenGL...&quot;);
 
 		// Convert to textures
-		for (int a=0;a&lt;blendMaps.size();a++)
-		{
+		for (int a=0;a&lt;blendMaps.size();a++) {
 			AlphaImage *bm = bmMipmaps[a].back();
 
 			// Save image
-			if (blendMaps[a]-&gt;generatorInfo)
-			{
+			if (blendMaps[a]-&gt;generatorInfo) {
 				char fn[32];
 				SNPRINTF (fn,32, &quot;blendmap%d.jpg&quot;, a);
 				remove(fn);
@@ -319,20 +316,20 @@
 		// see how lighting should be implemented, based on config and avaiable textures
 		InstantiateShaders(cfg, cb);
 
-        if (cb) cb-&gt;PrintMsg (&quot;  initializing terrain node shaders...&quot;);
+		if (cb) { cb-&gt;PrintMsg (&quot;  initializing terrain node shaders...&quot;); }
 
 		CreateTexProg (quadtree, &amp;gi);
 		shaderHandler-&gt;EndBuild();
 
 		// count passes
 		maxPasses = 0;
-		for (map&lt;uint, RenderSetupCollection*&gt;::iterator mi=gi.nodesetup.begin();mi!=gi.nodesetup.end();++mi)
-		{
+		for (map&lt;uint, RenderSetupCollection*&gt;::iterator mi=gi.nodesetup.begin();mi!=gi.nodesetup.end();++mi) {
 			for (int i = 0; i &lt; mi-&gt;second-&gt;renderSetup.size(); i++) {
 				RenderSetup *rs = mi-&gt;second-&gt;renderSetup[i];
 
-				if (rs-&gt;passes.size () &gt; maxPasses)
+				if (rs-&gt;passes.size () &gt; maxPasses) {
 					maxPasses = rs-&gt;passes.size();
+				}
 			}
 			texNodeSetup.push_back (mi-&gt;second);
 		}
@@ -341,14 +338,16 @@
 
 		// Free blendmap mipmap images
 		for (int a=0;a&lt;blendMaps.size();a++) {
-			for (deque&lt;AlphaImage*&gt;::iterator i=bmMipmaps[a].begin();i!=bmMipmaps[a].end();++i)
+			for (deque&lt;AlphaImage*&gt;::iterator i=bmMipmaps[a].begin();i!=bmMipmaps[a].end();++i) {
 				delete *i;
+			}
 		}
 
 		delete[] bmMipmaps;
 
-		if (cfg-&gt;useShadowMaps)
+		if (cfg-&gt;useShadowMaps) {
 			shadowMapParams = SAFE_NEW ShadowMapParams;
+		}
 	}
 
 	void TerrainTexture::CreateTexProg (TQuad *node, TerrainTexture::GenerateInfo *gi)

Modified: branches/gml/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- branches/gml/rts/Map/SMF/SmfReadMap.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Map/SMF/SmfReadMap.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -224,18 +224,23 @@
 
 float3 CSmfReadMap::GetLightValue(int x, int y)
 {
-	float3 n1=facenormals[(y*gs-&gt;mapx+x)*2]+facenormals[(y*gs-&gt;mapx+x)*2+1];
+	float3 n1 = facenormals[((y * gs-&gt;mapx) + x) * 2] +
+	            facenormals[((y * gs-&gt;mapx) + x) * 2 + 1];
 	n1.Normalize();
 
-	float3 light=mapInfo-&gt;light.groundSunColor*mapInfo-&gt;light.sunDir.dot(n1);
-	for(int a=0;a&lt;3;++a)
-		if(light[a]&lt;0)
-			light[a]=0;
+	float3 light = mapInfo-&gt;light.groundSunColor*mapInfo-&gt;light.sunDir.dot(n1);
+	for (int a = 0; a &lt; 3; ++a) {
+		if (light[a] &lt; 0.0f) {
+			light[a] = 0.0f;
+		}
+	}
 
 	light+=mapInfo-&gt;light.groundAmbientColor;
-	for(int a=0;a&lt;3;++a)
-		if(light[a]&gt;1)
-			light[a]=1;
+	for (int a = 0; a &lt; 3; ++a) {
+		if (light[a] &gt; 1.0f){
+			light[a] = 1.0f;
+		}
+	}
 
 	return light;
 }

Modified: branches/gml/rts/Rendering/Env/AdvTreeGenerator.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/AdvTreeGenerator.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/Env/AdvTreeGenerator.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -4,14 +4,16 @@
 
 #include &quot;StdAfx.h&quot;
 #include &quot;AdvTreeGenerator.h&quot;
-#include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Game/Camera.h&quot;
-#include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
-#include &quot;TdfParser.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/VertexArray.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
 using namespace std;
@@ -32,10 +34,15 @@
 	unsigned char(* tree)[2048][4]=SAFE_NEW unsigned char[256][2048][4];
 	memset(tree[0][0],128,256*2048*4);
 
-	TdfParser resources(&quot;gamedata/resources.tdf&quot;);
+	LuaParser resourcesParser(&quot;gamedata/resources.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
+	if (!resourcesParser.Execute()) {
+		logOutput.Print(resourcesParser.GetErrorLog());
+	}
 
+	const LuaTable treesTable = resourcesParser.GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;trees&quot;);
+
 	CBitmap bm;
-	std::string fn(&quot;bitmaps/&quot;+resources.SGetValueDef(&quot;Bark.bmp&quot;,&quot;resources\\graphics\\trees\\bark&quot;));
+	std::string fn(&quot;bitmaps/&quot;+treesTable.GetString(&quot;bark&quot;, &quot;Bark.bmp&quot;));
 	if (!bm.Load(fn) || bm.xsize != 256 || bm.ysize != 256)
 		throw content_error(&quot;Could not load tree texture from file &quot; + fn);
 	for(int y=0;y&lt;256;y++){
@@ -44,9 +51,13 @@
 			tree[y][x][1]=bm.mem[(y*256+x)*4+1];
 			tree[y][x][2]=bm.mem[(y*256+x)*4+2];
 			tree[y][x][3]=255;
+			tree[y][x+1024][0]=(unsigned char)(bm.mem[(y*256+x)*4]*0.6f);
+			tree[y][x+1024][1]=(unsigned char)(bm.mem[(y*256+x)*4+1]*0.6f);
+			tree[y][x+1024][2]=(unsigned char)(bm.mem[(y*256+x)*4+2]*0.6f);
+			tree[y][x+1024][3]=255;
 		}
 	}
-	fn = &quot;bitmaps/&quot;+resources.SGetValueDef(&quot;bleaf.bmp&quot;,&quot;resources\\graphics\\trees\\leaf&quot;);
+	fn = &quot;bitmaps/&quot;+treesTable.GetString(&quot;leaf&quot;, &quot;bleaf.bmp&quot;);
 	if (!bm.Load(fn))
 		throw content_error(&quot;Could not load tree texture from file &quot; + fn);
 	bm.CreateAlpha(0,0,0);
@@ -66,18 +77,6 @@
 
 	glDeleteTextures (1, &amp;leafTex);
 
-	fn = &quot;bitmaps/&quot;+resources.SGetValueDef(&quot;Bark.bmp&quot;,&quot;resources\\graphics\\trees\\bark&quot;);
-	if (!bm.Load(fn) || bm.xsize != 256 || bm.ysize != 256)
-		throw content_error(&quot;Could not load tree texture from file &quot; + fn);
-	for(int y=0;y&lt;256;y++){
-		for(int x=0;x&lt;256;x++){
-			tree[y][x+1024][0]=(unsigned char)(bm.mem[(y*256+x)*4]*0.6f);
-			tree[y][x+1024][1]=(unsigned char)(bm.mem[(y*256+x)*4+1]*0.6f);
-			tree[y][x+1024][2]=(unsigned char)(bm.mem[(y*256+x)*4+2]*0.6f);
-			tree[y][x+1024][3]=255;
-		}
-	}
-
 	unsigned char* data=tree[0][0];
 	CreateGranTex(data,1024+768,0,2048);
 	CreateGranTex(data,1280,0,2048);

Modified: branches/gml/rts/Rendering/Env/BasicTreeDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,16 +1,18 @@
-#include &quot;StdAfx.h&quot;
 // TreeDrawer.cpp: implementation of the CBasicTreeDrawer class.
 //
 //////////////////////////////////////////////////////////////////////
 
+#include &quot;StdAfx.h&quot;
 #include &quot;BasicTreeDrawer.h&quot;
+#include &quot;Game/Camera.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/Ground.h&quot;
-#include &quot;Game/Camera.h&quot;
-#include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
-#include &quot;TdfParser.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
 //////////////////////////////////////////////////////////////////////
@@ -21,10 +23,15 @@
 {
 	lastListClean=0;
 
-	TdfParser resources(&quot;gamedata/resources.tdf&quot;);
-
+	LuaParser resourcesParser(&quot;gamedata/resources.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
+	if (!resourcesParser.Execute()) {
+		logOutput.Print(resourcesParser.GetErrorLog());
+	}
+	
+	const LuaTable treesTable = resourcesParser.GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;trees&quot;);
+		
 	CBitmap TexImage;
-	std::string fn(&quot;bitmaps/&quot;+resources.SGetValueDef(&quot;gran.bmp&quot;,&quot;resources\\graphics\\trees\\gran1&quot;));
+	std::string fn(&quot;bitmaps/&quot;+treesTable.GetString(&quot;gran1&quot;, &quot;gran.bmp&quot;));
 	if (!TexImage.Load(fn))
 		throw content_error(&quot;Could not load tree texture from &quot; + fn);
 	TexImage.ReverseYAxis();
@@ -48,7 +55,7 @@
 		}
 	}
 
-	fn = &quot;bitmaps/&quot;+resources.SGetValueDef(&quot;gran2.bmp&quot;,&quot;resources\\graphics\\trees\\gran2&quot;);
+	fn = &quot;bitmaps/&quot;+treesTable.GetString(&quot;gran2&quot;, &quot;gran2.bmp&quot;);
 	if (!TexImage.Load(fn))
 		throw content_error(&quot;Could not load tree texture from file &quot; + fn);
 	TexImage.ReverseYAxis();
@@ -70,7 +77,7 @@
 		}
 	}
 
-	fn = &quot;bitmaps/&quot;+resources.SGetValueDef(&quot;birch1.bmp&quot;,&quot;resources\\graphics\\trees\\birch1&quot;);
+	fn = &quot;bitmaps/&quot;+treesTable.GetString(&quot;birch1&quot;, &quot;birch1.bmp&quot;);
 	if (!TexImage.Load(fn))
 		throw content_error(&quot;Could not load tree texture from file &quot; + fn);
 	TexImage.ReverseYAxis();
@@ -92,7 +99,7 @@
 		}
 	}
 
-	fn = &quot;bitmaps/&quot;+resources.SGetValueDef(&quot;birch2.bmp&quot;,&quot;resources\\graphics\\trees\\birch2&quot;);
+	fn = &quot;bitmaps/&quot;+treesTable.GetString(&quot;birch2&quot;, &quot;birch2.bmp&quot;);
 	if (!TexImage.Load(fn))
 		throw content_error(&quot;Could not load tree texture from file &quot; + fn);
 	TexImage.ReverseYAxis();
@@ -114,7 +121,7 @@
 		}
 	}
 
-	fn = &quot;bitmaps/&quot;+resources.SGetValueDef(&quot;birch3.bmp&quot;,&quot;resources\\graphics\\trees\\birch3&quot;);
+	fn = &quot;bitmaps/&quot;+treesTable.GetString(&quot;birch3&quot;, &quot;birch3.bmp&quot;);
 	if (!TexImage.Load(fn))
 		throw content_error(&quot;Could not load tree texture from file &quot; + fn);
 	TexImage.ReverseYAxis();

Modified: branches/gml/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/BumpWater.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/Env/BumpWater.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -219,7 +219,7 @@
 
 	foamTexture = LoadTexture( mapInfo-&gt;water.foamTexture );
 	normalTexture = LoadTexture( mapInfo-&gt;water.normalTexture );
-	for (int i = 0; i &lt; 32; i++) {
+	for (int i = 0; i &lt; CMapInfo::causticTextureCount; i++) {
 		caustTextures[i] = LoadTexture( mapInfo-&gt;water.causticTextures[i] );
 	}
 
@@ -305,7 +305,7 @@
 		glDeleteTextures(1, &amp;refractTexture);
 
 	glDeleteTextures(1, &amp;foamTexture);
-	glDeleteTextures(32, caustTextures);
+	glDeleteTextures(CMapInfo::causticTextureCount, caustTextures);
 	glDeleteTextures(1, &amp;normalTexture);
 
 	glDeleteShader(waterVP);
@@ -332,18 +332,13 @@
 	if (refraction&lt;2)
 		glDepthMask(0);
 
-	glActiveTexture(GL_TEXTURE1);
-		glBindTexture(GL_TEXTURE_2D, readmap-&gt;GetShadingTexture());
-	glActiveTexture(GL_TEXTURE2);
-		glBindTexture(GL_TEXTURE_2D, caustTextures[gs-&gt;frameNum%32]);
-	glActiveTexture(GL_TEXTURE3);
-		glBindTexture(GL_TEXTURE_2D, foamTexture);
-	glActiveTexture(GL_TEXTURE4);
-		glBindTexture(GL_TEXTURE_2D, reflectTexture);
-	glActiveTexture(GL_TEXTURE5);
-		glBindTexture(target, refractTexture);
-	glActiveTexture(GL_TEXTURE0);
-		glBindTexture(GL_TEXTURE_2D, normalTexture);
+	const int causticTexNum = (gs-&gt;frameNum % CMapInfo::causticTextureCount);
+	glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, readmap-&gt;GetShadingTexture());
+	glActiveTexture(GL_TEXTURE2); glBindTexture(GL_TEXTURE_2D, caustTextures[causticTexNum]);
+	glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, foamTexture);
+	glActiveTexture(GL_TEXTURE4); glBindTexture(GL_TEXTURE_2D, reflectTexture);
+	glActiveTexture(GL_TEXTURE5); glBindTexture(target,        refractTexture);
+	glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, normalTexture);
 
 	glUseProgram(waterShader);
 	glUniform1f(frameLoc,gs-&gt;frameNum/15000.0f);

Modified: branches/gml/rts/Rendering/FontTexture.cpp
===================================================================
--- branches/gml/rts/Rendering/FontTexture.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/FontTexture.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -233,7 +233,7 @@
 	error = FT_Init_FreeType(&amp;library);
 	if (error) {
 		logOutput.Print(&quot;freetype library init failed: %i\n&quot;, error);
-		return 1;
+		return false;
 	}
 
 	if (inputData.empty()) {
@@ -247,12 +247,12 @@
 	if (error == FT_Err_Unknown_File_Format) {
 		logOutput.Print(&quot;bad font file type\n&quot;);
 		FT_Done_FreeType(library);
-		return 1;
+		return false;
 	}
 	else if (error) {
 		logOutput.Print(&quot;unknown font file error: %i\n&quot;, error);
 		FT_Done_FreeType(library);
-		return 1;
+		return false;
 	}
 
 	if (face-&gt;num_fixed_sizes &lt;= 0) {
@@ -261,7 +261,7 @@
 			logOutput.Print(&quot;FT_Set_Pixel_Sizes() error: %i\n&quot;, error);
 			FT_Done_Face(face);
 			FT_Done_FreeType(library);
-			return 1;
+			return false;
 		}
 	} else {
 		height = face-&gt;available_sizes[0].height;

Modified: branches/gml/rts/Rendering/GL/VertexArray.cpp
===================================================================
--- branches/gml/rts/Rendering/GL/VertexArray.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/GL/VertexArray.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -56,7 +56,7 @@
 	*stripArrayPos++=((char *)drawArrayPos-(char *)drawArray);
 }
 
-inline void CVertexArray::DrawArrays(int drawType, int stride) {
+void CVertexArray::DrawArrays(int drawType, int stride) {
 	int newIndex,oldIndex=0;
 	int *stripArrayPtr=stripArray;
 	while(stripArrayPtr&lt;stripArrayPos) {
@@ -66,11 +66,6 @@
 	}
 }
 
-inline void CVertexArray::CheckEndStrip() {
-	if(stripArrayPos==stripArray || *(stripArrayPos-1)!=((char *)drawArrayPos-(char *)drawArray))
-		EndStrip();
-}
-
 void CVertexArray::DrawArray0(int drawType,int stride) {
 	CheckEndStrip();
 	glEnableClientState(GL_VERTEX_ARRAY);
@@ -174,4 +169,4 @@
 	stripArray=tempArray;
 	stripArraySize=stripArray+newsize;
 	stripArrayPos=stripArray+pos;
-}
\ No newline at end of file
+}

Modified: branches/gml/rts/Rendering/GL/VertexArray.h
===================================================================
--- branches/gml/rts/Rendering/GL/VertexArray.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/GL/VertexArray.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -115,4 +115,10 @@
 	*drawArrayPos++=*((float*)(col));
 }
 
+
+inline void CVertexArray::CheckEndStrip() {
+	if(stripArrayPos==stripArray || *(stripArrayPos-1)!=((char *)drawArrayPos-(char *)drawArray))
+		EndStrip();
+}
+
 #endif /* VERTEXARRAY_H */

Modified: branches/gml/rts/Rendering/GL/myGL.cpp
===================================================================
--- branches/gml/rts/Rendering/GL/myGL.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/GL/myGL.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -148,7 +148,7 @@
 	}else if (GLEW_VERSION_1_4) {
 		// This required GL-1.4
 		// instead of using glu, we rely on glTexImage2D to create the Mipmaps.
-		glTexParameteri(GL_TEXTURE_2D,GL_GENERATE_MIPMAP,true);
+		glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
 		glTexImage2D(target, 0, internalFormat, width, height, 0, format, type, data);
 	} else
 		gluBuild2DMipmaps(target, internalFormat, width, height, format, type, data);

Modified: branches/gml/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/GroundDecalHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/GroundDecalHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,27 +1,31 @@
+#include &lt;algorithm&gt;
+#include &lt;cctype&gt;
 #include &quot;StdAfx.h&quot;
 #include &quot;GroundDecalHandler.h&quot;
-#include &lt;algorithm&gt;
+#include &quot;Game/Camera.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;Map/BaseGroundDrawer.h&quot;
+#include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/ReadMap.h&quot;
+#include &quot;Platform/ConfigHandler.h&quot;
+#include &quot;Rendering/ShadowHandler.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
-#include &quot;GL/myGL.h&quot;
-#include &quot;GL/VertexArray.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
-#include &quot;Map/Ground.h&quot;
-#include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;LogOutput.h&quot;
-#include &quot;Platform/ConfigHandler.h&quot;
-#include &lt;cctype&gt;
-#include &quot;Game/Camera.h&quot;
 #include &quot;Sim/Units/UnitTypes/Building.h&quot;
-#include &quot;Map/BaseGroundDrawer.h&quot;
-#include &quot;Map/MapInfo.h&quot;
-#include &quot;ShadowHandler.h&quot;
-#include &quot;TdfParser.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
-CGroundDecalHandler* groundDecals = 0;
 using namespace std;
 
+
+CGroundDecalHandler* groundDecals = NULL;
+
+
 CGroundDecalHandler::CGroundDecalHandler(void)
 {
 	drawDecals = false;
@@ -37,12 +41,18 @@
 	unsigned char* buf=SAFE_NEW unsigned char[512*512*4];
 	memset(buf,0,512*512*4);
 
-	TdfParser tdfparser(&quot;gamedata/resources.tdf&quot;);
-	LoadScar((char*)(&quot;bitmaps/&quot;+tdfparser.SGetValueDef(&quot;scars/scar2.bmp&quot;,&quot;resources\\graphics\\scars\\scar2&quot;)).c_str(),buf,0,0);
-	LoadScar((char*)(&quot;bitmaps/&quot;+tdfparser.SGetValueDef(&quot;scars/scar3.bmp&quot;,&quot;resources\\graphics\\scars\\scar3&quot;)).c_str(),buf,256,0);
-	LoadScar((char*)(&quot;bitmaps/&quot;+tdfparser.SGetValueDef(&quot;scars/scar1.bmp&quot;,&quot;resources\\graphics\\scars\\scar1&quot;)).c_str(),buf,0,256);
-	LoadScar((char*)(&quot;bitmaps/&quot;+tdfparser.SGetValueDef(&quot;scars/scar4.bmp&quot;,&quot;resources\\graphics\\scars\\scar4&quot;)).c_str(),buf,256,256);
-
+	LuaParser resourcesParser(&quot;gamedata/resources.lua&quot;,
+	                          SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
+	if (!resourcesParser.Execute()) {
+		logOutput.Print(resourcesParser.GetErrorLog());
+	}
+	
+	const LuaTable scarsTable = resourcesParser.GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;scars&quot;);
+	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(&quot;scar2&quot;, &quot;scars/scar2.bmp&quot;), buf, 0,   0);
+	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(&quot;scar3&quot;, &quot;scars/scar3.bmp&quot;), buf, 256, 0);
+	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(&quot;scar1&quot;, &quot;scars/scar1.bmp&quot;), buf, 0,   256);
+	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(&quot;scar4&quot;, &quot;scars/scar4.bmp&quot;), buf, 256, 256);
+	
 	glGenTextures(1, &amp;scarTex);
 	glBindTexture(GL_TEXTURE_2D, scarTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
@@ -66,6 +76,7 @@
 	}
 }
 
+
 CGroundDecalHandler::~CGroundDecalHandler(void)
 {
 	for(std::vector&lt;TrackType*&gt;::iterator tti=trackTypes.begin();tti!=trackTypes.end();++tti){
@@ -100,6 +111,7 @@
 	}
 }
 
+
 void CGroundDecalHandler::Draw(void)
 {
 	if (!drawDecals) {
@@ -451,10 +463,12 @@
 	glActiveTextureARB(GL_TEXTURE0_ARB);
 }
 
+
 void CGroundDecalHandler::Update(void)
 {
 }
 
+
 void CGroundDecalHandler::UnitMoved(CUnit* unit)
 {
 	if(decalLevel==0)
@@ -512,6 +526,7 @@
 	unit-&gt;myTrack-&gt;parts.push_back(tp);
 }
 
+
 void CGroundDecalHandler::RemoveUnit(CUnit* unit)
 {
 	if(decalLevel==0)
@@ -523,44 +538,56 @@
 	}
 }
 
-int CGroundDecalHandler::GetTrackType(std::string name)
+
+int CGroundDecalHandler::GetTrackType(const std::string&amp; name)
 {
-	if(decalLevel==0)
+	if (decalLevel == 0) {
 		return 0;
+	}
 
-	StringToLowerInPlace(name);
+	const std::string lowerName = StringToLower(name);
 
-	int a=0;
-	for(std::vector&lt;TrackType*&gt;::iterator ti=trackTypes.begin();ti!=trackTypes.end();++ti){
-		if((*ti)-&gt;name==name){
+	int a = 0;
+	std::vector&lt;TrackType*&gt;::iterator ti;
+	for(ti = trackTypes.begin(); ti != trackTypes.end(); ++ti) {
+		if ((*ti)-&gt;name == lowerName) {
 			return a;
 		}
 		++a;
 	}
-	TrackType* tt=SAFE_NEW TrackType;
-	tt-&gt;name=name;
-	tt-&gt;texture=LoadTexture(name);
+
+	TrackType* tt = SAFE_NEW TrackType;
+	tt-&gt;name = lowerName;
+	tt-&gt;texture = LoadTexture(lowerName);
 	trackTypes.push_back(tt);
-	return trackTypes.size()-1;
+
+	return trackTypes.size() - 1;
 }
 
-unsigned int CGroundDecalHandler::LoadTexture(std::string name)
+
+unsigned int CGroundDecalHandler::LoadTexture(const std::string&amp; name)
 {
-	if(name.find_first_of('.')==string::npos)
-		name+=&quot;.bmp&quot;;
-	if(name.find_first_of('\\')==string::npos&amp;&amp;name.find_first_of('/')==string::npos)
-		name=string(&quot;bitmaps/tracks/&quot;)+name;
+	std::string fullName = name;
+	if (fullName.find_first_of('.') == string::npos) {
+		fullName += &quot;.bmp&quot;;
+	}
+	if ((fullName.find_first_of('\\') == string::npos) &amp;&amp;
+	    (fullName.find_first_of('/')  == string::npos)) {
+		fullName = string(&quot;bitmaps/tracks/&quot;) + fullName;
+	}
 
 	CBitmap bm;
-	if (!bm.Load(name))
-		throw content_error(&quot;Could not load ground decal from file &quot; + name);
-	for(int y=0;y&lt;bm.ysize;++y){
-		for(int x=0;x&lt;bm.xsize;++x){
-			bm.mem[(y*bm.xsize+x)*4+3]=bm.mem[(y*bm.xsize+x)*4+1];
-			int brighness=bm.mem[(y*bm.xsize+x)*4+0];
-			bm.mem[(y*bm.xsize+x)*4+0]=(brighness*90)/255;
-			bm.mem[(y*bm.xsize+x)*4+1]=(brighness*60)/255;
-			bm.mem[(y*bm.xsize+x)*4+2]=(brighness*30)/255;
+	if (!bm.Load(fullName)) {
+		throw content_error(&quot;Could not load ground decal from file &quot; + fullName);
+	}
+	for (int y = 0; y &lt; bm.ysize; ++y) {
+		for (int x = 0; x &lt; bm.xsize; ++x) {
+			const int index = ((y * bm.xsize) + x) * 4;
+			bm.mem[index + 3]    = bm.mem[index + 1];
+			const int brightness = bm.mem[index + 0];
+			bm.mem[index + 0] = (brightness * 90) / 255;
+			bm.mem[index + 1] = (brightness * 60) / 255;
+			bm.mem[index + 2] = (brightness * 30) / 255;
 		}
 	}
 
@@ -632,22 +659,28 @@
 	scars.push_back(s);
 }
 
-void CGroundDecalHandler::LoadScar(std::string file, unsigned char* buf, int xoffset, int yoffset)
+
+void CGroundDecalHandler::LoadScar(const std::string&amp; file, unsigned char* buf,
+                                   int xoffset, int yoffset)
 {
 	CBitmap bm;
-	if (!bm.Load(file))
+	if (!bm.Load(file)) {
 		throw content_error(&quot;Could not load scar from file &quot; + file);
-	for(int y=0;y&lt;bm.ysize;++y){
-		for(int x=0;x&lt;bm.xsize;++x){
-			buf[((y+yoffset)*512+x+xoffset)*4+3]=bm.mem[(y*bm.xsize+x)*4+1];
-			int brighness=bm.mem[(y*bm.xsize+x)*4+0];
-			buf[((y+yoffset)*512+x+xoffset)*4+0]=(brighness*90)/255;
-			buf[((y+yoffset)*512+x+xoffset)*4+1]=(brighness*60)/255;
-			buf[((y+yoffset)*512+x+xoffset)*4+2]=(brighness*30)/255;
+	}
+	for (int y = 0; y &lt; bm.ysize; ++y) {
+		for (int x = 0; x &lt; bm.xsize; ++x) {
+			const int memIndex = ((y * bm.xsize) + x) * 4;
+			const int bufIndex = (((y + yoffset) * 512) + x + xoffset) * 4;
+			buf[bufIndex + 3]    = bm.mem[memIndex + 1];
+			const int brightness = bm.mem[memIndex + 0];
+			buf[bufIndex + 0] = (brightness * 90) / 255;
+			buf[bufIndex + 1] = (brightness * 60) / 255;
+			buf[bufIndex + 2] = (brightness * 30) / 255;
 		}
 	}
 }
 
+
 int CGroundDecalHandler::OverlapSize(Scar* s1, Scar* s2)
 {
 	if(s1-&gt;x1&gt;=s2-&gt;x2 || s1-&gt;x2&lt;=s2-&gt;x1)
@@ -670,6 +703,7 @@
 	return xs*ys;
 }
 
+
 void CGroundDecalHandler::TestOverlaps(Scar* scar)
 {
 	int x1=scar-&gt;x1/16;
@@ -706,6 +740,7 @@
 	}
 }
 
+
 void CGroundDecalHandler::RemoveScar(Scar* scar,bool removeFromScars)
 {
 	int x1=scar-&gt;x1/16;
@@ -763,6 +798,7 @@
 	type-&gt;buildingDecals.insert(decal);
 }
 
+
 void CGroundDecalHandler::RemoveBuilding(CBuilding* building,CUnitDrawer::GhostBuilding* gb)
 {
 	BuildingGroundDecal* decal = building-&gt;buildingDecal;
@@ -774,26 +810,31 @@
 	building-&gt;buildingDecal = 0;
 }
 
-int CGroundDecalHandler::GetBuildingDecalType(std::string name)
+
+int CGroundDecalHandler::GetBuildingDecalType(const std::string&amp; name)
 {
-	if (decalLevel == 0)
+	if (decalLevel == 0) {
 		return 0;
+	}
 
-	StringToLowerInPlace(name);
+	const std::string lowerName = StringToLower(name);
 
 	int a = 0;
-	for (std::vector&lt;BuildingDecalType*&gt;::iterator bi = buildingDecalTypes.begin(); bi != buildingDecalTypes.end(); ++bi) {
-		if ((*bi)-&gt;name == name) {
+	std::vector&lt;BuildingDecalType*&gt;::iterator bi;
+	for (bi = buildingDecalTypes.begin(); bi != buildingDecalTypes.end(); ++bi) {
+		if ((*bi)-&gt;name == lowerName) {
 			return a;
 		}
 		++a;
 	}
 
 	BuildingDecalType* tt = SAFE_NEW BuildingDecalType;
-	tt-&gt;name = name;
+	tt-&gt;name = lowerName;
+	const std::string fullName = &quot;unittextures/&quot; + lowerName;
 	CBitmap bm;
-	if (!bm.Load(string(&quot;unittextures/&quot;) + name))
-		throw content_error(&quot;Could not load building decal from file unittextures/&quot; + name);
+	if (!bm.Load(fullName)) {
+		throw content_error(&quot;Could not load building decal from file &quot; + fullName);
+	}
 
 	tt-&gt;texture = bm.CreateTexture(true);
 	buildingDecalTypes.push_back(tt);

Modified: branches/gml/rts/Rendering/GroundDecalHandler.h
===================================================================
--- branches/gml/rts/Rendering/GroundDecalHandler.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/GroundDecalHandler.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -54,13 +54,13 @@
 
 	void UnitMoved(CUnit* unit);
 	void RemoveUnit(CUnit* unit);
-	int GetTrackType(std::string name);
+	int GetTrackType(const std::string&amp; name);
 
 	void AddExplosion(float3 pos, float damage, float radius);
 
 	void AddBuilding(CBuilding* building);
 	void RemoveBuilding(CBuilding* building,CUnitDrawer::GhostBuilding* gb);
-	int GetBuildingDecalType(std::string name);
+	int GetBuildingDecalType(const std::string&amp; name);
 
 	GLuint scarTex;
 	int decalLevel;
@@ -121,10 +121,11 @@
 
 	int OverlapSize(Scar* s1, Scar* s2);
 	void TestOverlaps(Scar* scar);
-	void RemoveScar(Scar* scar,bool removeFromScars);
-	unsigned int LoadTexture(std::string name);
-	void LoadScar(std::string file, unsigned char* buf, int xoffset, int yoffset);
-	void SetTexGen(float scalex,float scaley, float offsetx, float offsety);
+	void RemoveScar(Scar* scar, bool removeFromScars);
+	unsigned int LoadTexture(const std::string&amp; name);
+	void LoadScar(const std::string&amp; file, unsigned char* buf,
+	              int xoffset, int yoffset);
+	void SetTexGen(float scalex, float scaley, float offsetx, float offsety);
 };
 
 extern CGroundDecalHandler* groundDecals;

Copied: branches/gml/rts/Rendering/Icon.h (from rev 5960, trunk/rts/Rendering/Icon.h)
===================================================================
--- branches/gml/rts/Rendering/Icon.h	                        (rev 0)
+++ branches/gml/rts/Rendering/Icon.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,31 @@
+//
+//  Implemented in IconHandler.cpp
+//
+
+#ifndef ICON_H
+#define ICON_H
+
+
+class CIconData;
+
+
+class CIcon {
+
+	friend class CIconHandler;
+
+	public:
+		CIcon();
+		CIcon(CIconData* data);
+		CIcon(const CIcon&amp; ic);
+		CIcon&amp; operator=(const CIcon&amp; ic);
+		~CIcon();
+
+		const CIconData* operator-&gt;()  const { return data; }
+		const CIconData* GetIconData() const { return data; }
+
+	private:
+		CIconData* data;
+};
+
+
+#endif // ICON_H

Modified: branches/gml/rts/Rendering/IconHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/IconHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/IconHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -5,144 +5,334 @@
 #include &lt;assert.h&gt;
 #include &lt;locale&gt;
 #include &lt;cctype&gt;
+#include &lt;vector&gt;
+#include &lt;string&gt;
 #include &quot;GlobalStuff.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;IconHandler.h&quot;
-#include &quot;TdfParser.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
+using std::string;
 
-CIconHandler* iconHandler;
 
+CIconHandler* iconHandler = NULL;
 
+
+CIconData CIconHandler::safetyData;
+
+
+/******************************************************************************/
+//
+//  CIconHandler
+//
+
 CIconHandler::CIconHandler()
 {
 	PrintLoadMsg(&quot;Parsing unit icons&quot;);
 
-	standardTextureGenerated = false;
+	defTexID = 0;
+	defIconData = NULL;
 
-	LoadTDFicons(&quot;usericons.tdf&quot;);
-	LoadTDFicons(&quot;gamedata/icontypes.tdf&quot;);
+	LoadIcons(&quot;gamedata/icontypes.lua&quot;);
 
-	// If the default icon doesn't exist we'll have to create one
-	// (as unitdef-&gt;iconType defaults to &quot;default&quot;).
-	if (icons.find(&quot;default&quot;) == icons.end()) {
-		icons[&quot;default&quot;] = SAFE_NEW CIcon(*GetStandardTexture(), 1, 1, false);
+	IconMap::iterator it = iconMap.find(&quot;default&quot;);
+	if (it != iconMap.end()) {
+		defIconData = it-&gt;second.data;
 	}
+	else {
+		defIconData = SAFE_NEW CIconData(&quot;default&quot;, GetDefaultTexture(),
+																		 1.0f, 1.0f, false, false);
+		iconMap[&quot;default&quot;] = CIcon(defIconData);
+	}
+}
 
+
+CIconHandler::~CIconHandler()
+{
+	glDeleteTextures(1, &amp;defTexID);
 }
 
 
-bool CIconHandler::LoadTDFicons(const std::string&amp; filename)
+bool CIconHandler::LoadIcons(const string&amp; filename)
 {
+	LuaParser luaParser(filename, SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!luaParser.Execute()) {
+		logOutput.Print(&quot;%s: %s&quot;,
+		                filename.c_str(), luaParser.GetErrorLog().c_str());
+	}
+
+	const LuaTable iconTypes = luaParser.GetRoot();
+
+	std::vector&lt;string&gt; iconNames;
+	iconTypes.GetKeys(iconNames);
+
+	for (int i = 0; i &lt; iconNames.size(); i++) {
+		const string&amp; iconName = iconNames[i];
+		const LuaTable iconTable = iconTypes.SubTable(iconName);
+		AddIcon(
+			iconName,
+			iconTable.GetString(&quot;bitmap&quot;,       &quot;&quot;),
+			iconTable.GetFloat (&quot;size&quot;,         1.0f),
+			iconTable.GetFloat (&quot;distance&quot;,     1.0f),
+			iconTable.GetBool  (&quot;radiusAdjust&quot;, false)
+		);
+	}
+
+	return true;
+}
+
+
+bool CIconHandler::AddIcon(const string&amp; iconName, const string&amp; textureName,
+                           float size, float distance, bool radAdj)
+{
+	unsigned int texID;
+
+	bool ownTexture = true;
+
 	try {
-		TdfParser tdfparser(filename);
-		std::vector&lt;std::string&gt; iconList = tdfparser.GetSectionList(&quot;icontypes&quot;);
 		CBitmap bitmap;
-
-		for (std::vector&lt;std::string&gt;::const_iterator it = iconList.begin(); it != iconList.end(); ++it) {
-			if (icons.find(*it) != icons.end()) {
-				continue; // first come, first served  (also avoids possible memory leaks)
-			}
-			//Parse the bitmap location, the size, and the unit radius adjustment.
-			float size=atof(tdfparser.SGetValueDef(&quot;1&quot;, &quot;icontypes\\&quot; + *it + &quot;\\size&quot;).c_str());
-			float distance=atof(tdfparser.SGetValueDef(&quot;1&quot;, &quot;icontypes\\&quot; + *it + &quot;\\distance&quot;).c_str());
-			bool radiusAdjust=!!atoi(tdfparser.SGetValueDef(&quot;0&quot;, &quot;icontypes\\&quot; + *it + &quot;\\radiusadjust&quot;).c_str());
-			// If we can't load the bitmap replace it with the default one.
-			std::string bitmapLocation=tdfparser.SGetValueDef(&quot;&quot;, &quot;icontypes\\&quot; + *it + &quot;\\bitmap&quot;);
-			unsigned int texture;
-			if(!bitmapLocation.empty () &amp;&amp; bitmap.Load(bitmapLocation)){
-				texture = bitmap.CreateTexture(true);
-				glBindTexture(GL_TEXTURE_2D, texture);
-				if (GLEW_EXT_texture_edge_clamp) {
-					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-				} else {
-					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-				}
-			} else {
-				texture = *GetStandardTexture();
-			}
-			icons[*it] = SAFE_NEW CIcon(texture,size,distance,radiusAdjust);
+		if (!textureName.empty() &amp;&amp; bitmap.Load(textureName)) {
+			texID = bitmap.CreateTexture(true);
+			glBindTexture(GL_TEXTURE_2D, texID);
+			const GLenum wrapMode = GLEW_EXT_texture_edge_clamp ?
+			                        GL_CLAMP_TO_EDGE : GL_CLAMP;
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);
+		} else {
+			texID = GetDefaultTexture();
+			ownTexture = false;
 		}
 	}
-	catch (const TdfParser::parse_error&amp; e) {
-		// Show parse errors in the infolog.
-		logOutput.Print(&quot;%s:%d: %s&quot;, e.get_filename().c_str(), e.get_line(), e.what());
-	}
 	catch (const content_error&amp;) {
-		// Ignore non-existant file.
+		return false; // bail on non-existant file.
 	}
 
+	IconMap::iterator it = iconMap.find(iconName);
+	if (it != iconMap.end()) {
+		FreeIcon(iconName);
+	}
+
+	CIconData* iconData =
+		SAFE_NEW CIconData(iconName, texID,  size, distance, radAdj, ownTexture);
+
+	iconMap[iconName] = CIcon(iconData);
+
+	if (iconName == &quot;default&quot;) {
+		defIconData = iconData;
+	}
+
 	return true;
 }
 
 
-CIconHandler::~CIconHandler()
+bool CIconHandler::FreeIcon(const string&amp; iconName)
 {
-	std::map&lt;std::string, CIcon*&gt;::iterator it;
-	for (it = icons.begin(); it != icons.end(); ++it) {
-		delete it-&gt;second;
+	IconMap::iterator it = iconMap.find(iconName);
+	if (it == iconMap.end()) {
+		return false;
 	}
+
+	CIconData* iconData = it-&gt;second.data;
+	iconData-&gt;CopyData(defIconData);
+
+	iconMap.erase(iconName);
+
+	return true;
 }
 
 
-CIcon* CIconHandler::GetIcon(const std::string&amp; iconName)
+CIcon CIconHandler::GetIcon(const string&amp; iconName) const
 {
-	std::map&lt;std::string, CIcon*&gt;::const_iterator it=icons.find(iconName);
-	if(it==icons.end()){
-		return icons[&quot;default&quot;];
+	IconMap::const_iterator it = iconMap.find(iconName);
+	if (it == iconMap.end()) {
+		return CIcon(defIconData);
 	} else {
 		return it-&gt;second;
 	}
 }
 
 
-float CIconHandler::GetDistance(const std::string&amp; iconName)
+unsigned int CIconHandler::GetDefaultTexture()
 {
-	std::map&lt;std::string, CIcon*&gt;::const_iterator it=icons.find(iconName);
-	if(it==icons.end()){
-		return 1;
+	// FIXME: just use a PNG ?
+
+	if (defTexID != 0) {
+		return defTexID;
+	}
+
+	unsigned char si[128 * 128 * 4];
+	for (int y = 0; y &lt; 128; ++y) {
+		for (int x = 0; x &lt; 128; ++x) {
+			const int index = ((y * 128) + x) * 4;
+			const int dx = (x - 64);
+			const int dy = (y - 64);
+			const float r = sqrtf((dx * dx) + (dy * dy)) / 64.0f;
+			if (r &gt; 1.0f) {
+				si[index + 0] = 0;
+				si[index + 1] = 0;
+				si[index + 2] = 0;
+				si[index + 3] = 0;
+			} else {
+				const unsigned char val = (255 - (r * r * r * 255));
+				si[index + 0] = val;
+				si[index + 1] = val;
+				si[index + 2] = val;
+				si[index + 3] = 255;
+			}
+		}
+	}
+
+	CBitmap bitmap(si, 128, 128);
+	defTexID = bitmap.CreateTexture(false);
+
+	glBindTexture(GL_TEXTURE_2D, defTexID);
+
+	const GLenum wrapMode = GLEW_EXT_texture_edge_clamp ?
+													GL_CLAMP_TO_EDGE : GL_CLAMP;
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);
+
+	return defTexID;
+}
+
+
+/******************************************************************************/
+//
+//  CIcon
+//
+
+CIcon::CIcon() 
+{
+	if (iconHandler &amp;&amp; iconHandler-&gt;defIconData) {
+		data = iconHandler-&gt;defIconData;
 	} else {
-		return it-&gt;second-&gt;distance;
+		data = &amp;CIconHandler::safetyData;
 	}
+	data-&gt;Ref();
 }
 
 
-unsigned int* CIconHandler::GetStandardTexture()
+CIcon::CIcon(CIconData* d)
 {
-	if(!standardTextureGenerated){
-		unsigned char si[128*128*4];
-		for(int y=0;y&lt;128;++y){
-			for(int x=0;x&lt;128;++x){
-				float r=sqrtf((y-64)*(y-64)+(x-64)*(x-64))/64.0f;
-				if(r&gt;1){
-					si[(y*128+x)*4+0]=0;
-					si[(y*128+x)*4+1]=0;
-					si[(y*128+x)*4+2]=0;
-					si[(y*128+x)*4+3]=0;
-				} else {
-					si[(y*128+x)*4+0]=(unsigned char)(255-r*r*r*255);
-					si[(y*128+x)*4+1]=(unsigned char)(255-r*r*r*255);
-					si[(y*128+x)*4+2]=(unsigned char)(255-r*r*r*255);
-					si[(y*128+x)*4+3]=255;
-				}
-			}
-		}
-		CBitmap standardIcon(si,128,128);
-		standardTexture=standardIcon.CreateTexture(false);
-		standardTextureGenerated=true;
+	data = d ? d : &amp;CIconHandler::safetyData;
+	data-&gt;Ref();
+}
 
-		glBindTexture(GL_TEXTURE_2D, standardTexture);
-		if (GLEW_EXT_texture_edge_clamp) {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-		} else {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-		}
+
+CIcon::CIcon(const CIcon&amp; icon)
+{
+	data = icon.data;
+	data-&gt;Ref();
+}
+
+
+CIcon&amp; CIcon::operator=(const CIcon&amp; icon)
+{
+	if (data != icon.data) {
+		data-&gt;UnRef();
+		data = icon.data;
+		data-&gt;Ref();
 	}
-	return &standardTexture;
+	return *this;
 }
+
+
+CIcon::~CIcon()
+{
+	data-&gt;UnRef();
+}
+
+
+/******************************************************************************/
+//
+//  CIconData
+//
+
+CIconData::CIconData()
+: ownTexture(false), refCount(123456), name(&quot;safety&quot;), texID(0),
+  size(1.0f), distance(1.0f), distSqr(1.0f), radiusAdjust(false)
+{
+}
+
+
+CIconData::CIconData(const std::string&amp; _name, unsigned int _texID,
+                     float _size, float _distance, bool radAdj, bool ownTex)
+: ownTexture(ownTex), refCount(0),
+  name(_name), texID(_texID),
+  size(_size), distance(_distance),
+  radiusAdjust(radAdj)
+{
+	distSqr = distance * distance;
+}
+
+
+CIconData::~CIconData()
+{
+	if (ownTexture) {
+		glDeleteTextures(1, &amp;texID);
+	}
+}
+
+
+void CIconData::Ref()
+{
+	refCount++;
+}
+
+
+void CIconData::UnRef()
+{
+	refCount--;
+	if (refCount &lt;= 0) {
+		delete this;
+	}
+}
+
+
+void CIconData::CopyData(const CIconData* iconData)
+{
+	name         = iconData-&gt;name;
+	texID        = iconData-&gt;texID;
+	size         = iconData-&gt;size;
+	distance     = iconData-&gt;distance;
+	distSqr      = iconData-&gt;distSqr;
+	radiusAdjust = iconData-&gt;radiusAdjust;
+	ownTexture   = false;
+}
+
+
+void CIconData::BindTexture() const
+{
+	glBindTexture(GL_TEXTURE_2D, texID);
+}
+
+
+void CIconData::Draw(float x0, float y0, float x1, float y1) const
+{
+	glBindTexture(GL_TEXTURE_2D, texID);
+	glBegin(GL_QUADS);
+	glTexCoord2f(0.0f, 0.0f); glVertex2f(x0, y0);
+	glTexCoord2f(1.0f, 0.0f); glVertex2f(x1, y0);
+	glTexCoord2f(1.0f, 1.0f); glVertex2f(x1, y1);
+	glTexCoord2f(0.0f, 1.0f); glVertex2f(x0, y1);
+	glEnd();
+}
+
+
+void CIconData::Draw(const float3&amp; botLeft, const float3&amp; botRight,
+                     const float3&amp; topLeft, const float3&amp; topRight) const
+{
+	glBindTexture(GL_TEXTURE_2D, texID);
+	glBegin(GL_QUADS);
+	glTexCoord2f(0.0f, 1.0f); glVertexf3(botLeft);
+	glTexCoord2f(1.0f, 1.0f); glVertexf3(botRight);
+	glTexCoord2f(1.0f, 0.0f); glVertexf3(topRight);
+	glTexCoord2f(0.0f, 0.0f); glVertexf3(topLeft);
+	glEnd();
+}
+
+
+/******************************************************************************/

Modified: branches/gml/rts/Rendering/IconHandler.h
===================================================================
--- branches/gml/rts/Rendering/IconHandler.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/IconHandler.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,43 +1,91 @@
 /* Author: Teake Nutma */
 
-#ifndef ICONHANDLER_H
-#define ICONHANDLER_H
+#ifndef ICON_HANDLER_H
+#define ICON_HANDLER_H
 
 #include &lt;map&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-class CIcon
-{
-public:
-	unsigned int texture;
-	float size;
-	float distance;
-	bool radiusAdjust;
-	CIcon(unsigned int tex, float siz, float dis, bool radius)
-	{
-		texture      = tex;
-		size         = siz;
-		distance     = dis;
-		radiusAdjust = radius;
-	};
+#include &quot;Icon.h&quot;
+#include &quot;float3.h&quot;
+
+
+class CIconData {
+	public:
+		CIconData(); // for CIconHandler::safetyData
+		CIconData(const std::string&amp; name, unsigned int texID,
+		          float size, float distance, bool radiusAdjust,
+		          bool ownTexture);
+		~CIconData();
+
+		void Ref();
+		void UnRef();
+
+		void CopyData(const CIconData* iconData);
+
+		void BindTexture() const;
+		void Draw(float x0, float y0, float x1, float y1) const;
+		void Draw(const float3&amp; botLeft, const float3&amp; botRight,
+		          const float3&amp; topLeft, const float3&amp; topRight) const;
+
+		inline const std::string&amp; GetName()         const { return name;         }
+		inline const float        GetSize()         const { return size;         }
+		inline const float        GetDistance()     const { return distance;     }
+		inline const float        GetDistanceSqr()  const { return distSqr;      }
+		inline const bool         GetRadiusAdjust() const { return radiusAdjust; }
+
+	private:
+		bool ownTexture;
+		int  refCount;
+
+		std::string name;
+		unsigned int texID;
+		float size;
+		float distance;
+		float distSqr;
+		bool  radiusAdjust;
 };
 
-class CIconHandler
-{
-public:
-	CIconHandler(void);
-	~CIconHandler(void);
-	CIcon* GetIcon(const std::string&amp; iconName);
-	float GetDistance(const std::string&amp; iconName);
-private:
-	bool LoadTDFicons(const std::string&amp; filename);
-	unsigned int* GetStandardTexture();
-	unsigned int standardTexture;
-	bool standardTextureGenerated;
-	std::map&lt;std::string, CIcon*&gt; icons;
+
+class CIconHandler {
+
+	friend class CIcon;		
+
+	public:
+		CIconHandler(void);
+		~CIconHandler(void);
+
+		bool AddIcon(const std::string&amp; iconName,
+								 const std::string&amp; textureName,
+								 float size, float distance,
+								 bool radiusAdjust);
+
+		bool FreeIcon(const std::string&amp; iconName);
+
+		CIcon GetIcon(const std::string&amp; iconName) const;
+
+		CIcon GetDefaultIcon() const { return CIcon(defIconData); }
+
+		const CIconData* GetDefaultIconData() const { return defIconData; }
+
+	private:
+		bool LoadIcons(const std::string&amp; filename);
+		unsigned int GetDefaultTexture();
+
+	private:
+		unsigned int defTexID;
+		CIconData* defIconData;
+
+		typedef std::map&lt;std::string, CIcon&gt; IconMap;
+		IconMap iconMap;
+
+	private:
+		static CIconData safetyData;
 };
 
+
 extern CIconHandler* iconHandler;
 
-#endif
+
+#endif // ICON_HANDLER_H

Modified: branches/gml/rts/Rendering/Textures/NamedTextures.cpp
===================================================================
--- branches/gml/rts/Rendering/Textures/NamedTextures.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/Textures/NamedTextures.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -138,9 +138,10 @@
 			             GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
 		} else {
 			gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, bitmap.xsize, bitmap.ysize,
-			                  GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem); // make power of two!
+			                  GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
 		}
-	} else {
+	}
+	else {
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 		if (linear) {
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
@@ -148,8 +149,10 @@
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 		}
 
-		glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bitmap.xsize, bitmap.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
-		
+//		glBuildMipmaps(GL_TEXTURE_2D, GL_RGBA8, bitmap.xsize, bitmap.ysize,
+//									 GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
+		gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, bitmap.xsize, bitmap.ysize,
+		                  GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
 	}
 
 	if (aniso &amp;&amp; GLEW_EXT_texture_filter_anisotropic) {

Modified: branches/gml/rts/Rendering/UnitModels/3DModelParser.h
===================================================================
--- branches/gml/rts/Rendering/UnitModels/3DModelParser.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/UnitModels/3DModelParser.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -45,7 +45,6 @@
 	int textureType;		//0=3do, otherwise s3o
 
 	void DrawStatic();
-
 };
 
 

Modified: branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -71,9 +71,8 @@
 		texturehandler = SAFE_NEW CTextureHandler;
 	}
 
-	unitDrawDist = configHandler.GetInt(&quot;UnitLodDist&quot;,200);
-	unitIconDist = configHandler.GetInt(&quot;UnitIconDist&quot;,200);
-	iconLength = 750 * unitIconDist * unitIconDist;
+	SetUnitDrawDist((float)configHandler.GetInt(&quot;UnitLodDist&quot;,  200));
+	SetUnitIconDist((float)configHandler.GetInt(&quot;UnitIconDist&quot;, 200));
 
 	specTexSize = configHandler.GetInt(&quot;CubeTexSizeSpecular&quot;, 128);
 	reflTexSize = configHandler.GetInt(&quot;CubeTexSizeReflection&quot;, 128);
@@ -83,6 +82,9 @@
 	LODScaleReflection = GetLODFloat(&quot;LODScaleReflection&quot;, 1.0f);
 	LODScaleRefraction = GetLODFloat(&quot;LODScaleRefraction&quot;, 1.0f);
 
+	// Some Ati mobility cards dont like clipping wireframes...
+	usingAtiHacks = !!configHandler.GetInt(&quot;AtiHacks&quot;, 0);
+
 	CBitmap white;
 	white.Alloc(1, 1);
 	for (int a = 0; a &lt; 4; ++a) {
@@ -96,7 +98,7 @@
 	unitShadowDensity = mapInfo-&gt;light.unitShadowDensity;
 
 	float3 specularSunColor = mapInfo-&gt;light.specularSunColor;
-	advShading = !!configHandler.GetInt(&quot;AdvUnitShading&quot;, GLEW_ARB_fragment_program? 1: 0);
+	advShading = !!configHandler.GetInt(&quot;AdvUnitShading&quot;, GLEW_ARB_fragment_program ? 1: 0);
 
 	if (advShading &amp;&amp; !GLEW_ARB_fragment_program) {
 		logOutput.Print(&quot;You are missing an OpenGL extension needed to use advanced unit shading (GL_ARB_fragment_program)&quot;);
@@ -188,6 +190,20 @@
 }
 
 
+void CUnitDrawer::SetUnitDrawDist(float dist)
+{
+	unitDrawDist = dist;
+	unitDrawDistSqr = dist * dist;
+}
+
+
+void CUnitDrawer::SetUnitIconDist(float dist)
+{
+	unitIconDist = dist;
+	iconLength = 750 * unitIconDist * unitIconDist;
+}
+
+
 void CUnitDrawer::Update(void)
 {
 	while (!tempDrawUnits.empty() &amp;&amp; tempDrawUnits.begin()-&gt;first &lt; gs-&gt;frameNum - 1) {
@@ -269,67 +285,66 @@
 	CUnit *excludeUnit=mt_excludeUnit;
 #ifdef DIRECT_CONTROL_ALLOWED
 	if (unit == excludeUnit) {
-		return true;
+		return false;
 	}
 #endif
 	if (unit-&gt;noDraw) {
-		return true;
+		return false;
 	}
 	if (camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 30)) {
-		if (gs-&gt;Ally(unit-&gt;allyteam,gu-&gt;myAllyTeam) ||
-			(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) ||
-			gu-&gt;spectatingFullView) {
+		const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
+		if ((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) {
 
-				if (drawReflection) {
-					float3 zeroPos;
-					if (unit-&gt;midPos.y &lt; 0.0f) {
-						zeroPos = unit-&gt;midPos;
-					} else {
-						const float dif = unit-&gt;midPos.y - camera-&gt;pos.y;
-						zeroPos = camera-&gt;pos  * (unit-&gt;midPos.y / dif) +
-							unit-&gt;midPos * (-camera-&gt;pos.y / dif);
-					}
-					if (ground-&gt;GetApproximateHeight(zeroPos.x, zeroPos.z) &gt; unit-&gt;radius) {
-						return true;
-					}
+			if (drawReflection) {
+				float3 zeroPos;
+				if (unit-&gt;midPos.y &lt; 0.0f) {
+					zeroPos = unit-&gt;midPos;
+				} else {
+					const float dif = unit-&gt;midPos.y - camera-&gt;pos.y;
+					zeroPos = camera-&gt;pos  * (unit-&gt;midPos.y / dif) +
+						unit-&gt;midPos * (-camera-&gt;pos.y / dif);
 				}
-
-				if (drawRefraction) {
-					if (unit-&gt;pos.y &gt; 0.0f) {
-						return true;
-					}
+				if (ground-&gt;GetApproximateHeight(zeroPos.x, zeroPos.z) &gt; unit-&gt;radius) {
+					return false;
 				}
+			}
 
-				float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
-				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
-				float realIconLength = iconLength * (iconDistMult * iconDistMult);
-				if (sqDist&gt;realIconLength) {
-					drawIcon.push_back(unit);
-					unit-&gt;isIcon = true;
+			if (drawRefraction) {
+				if (unit-&gt;pos.y &gt; 0.0f) {
+					return false;
 				}
-				else {
-					unit-&gt;isIcon = false;
+			}
 
-					float farLength = unit-&gt;sqRadius * (unitDrawDist * unitDrawDist);
-					if (sqDist&gt;farLength) {
-						drawFar.push_back(unit);
-					} else {
-						DrawUnit(unit);
-					}
+			float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
+			float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
+			float realIconLength = iconLength * (iconDistMult * iconDistMult);
+			if (sqDist&gt;realIconLength) {
+				drawIcon.push_back(unit);
+				unit-&gt;isIcon = true;
+			}
+			else {
+				unit-&gt;isIcon = false;
 
-					if ((sqDist &lt; (unitDrawDist * unitDrawDist * 500)) &amp;&amp; showHealthBars) {
-						drawStat.push_back(unit);
-					}
+				float farLength = unit-&gt;sqRadius * unitDrawDistSqr;
+				if (sqDist &gt; farLength) {
+					drawFar.push_back(unit);
+				} else {
+					DrawUnit(unit);
 				}
+
+				if (showHealthBars &amp;&amp; (sqDist &lt; (unitDrawDistSqr * 500))) {
+					drawStat.push_back(unit);
+				}
+			}
 		}
-		else if (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_PREVLOS) {
+		else if (losStatus &amp; LOS_PREVLOS) {
 			unit-&gt;isIcon = true;
 
 			if ((!gameSetup || gameSetup-&gt;ghostedBuildings) &amp;&amp; !(unit-&gt;mobility)) {
 				// it's a building we've had LOS on once,
 				// add it to the vector of cloaked units
 				float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
-				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+				float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
 				float realIconLength = iconLength * (iconDistMult * iconDistMult);
 
 				if (sqDist &lt; realIconLength) {
@@ -341,15 +356,15 @@
 					unit-&gt;isIcon = false;
 				}
 			}
-			if ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INRADAR)) {
-				if (!(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_CONTRADAR)) {
+			if (losStatus &amp; LOS_INRADAR) {
+				if (!(losStatus &amp; LOS_CONTRADAR)) {
 					drawRadarIcon.push_back(unit);
 				} else if (unit-&gt;isIcon) {
 					// this prevents us from drawing icons on top of ghosted buildings
 					drawIcon.push_back(unit);
 				}
 			}
-		} else if ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INRADAR)) {
+		} else if (losStatus &amp; LOS_INRADAR) {
 			drawRadarIcon.push_back(unit);
 		}
 	}
@@ -404,9 +419,8 @@
 			continue;
 		}
 		if (camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 30)) {
-			if (gs-&gt;Ally(unit-&gt;allyteam,gu-&gt;myAllyTeam)       ||
-			    (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) ||
-			    gu-&gt;spectatingFullView) {
+			const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
+			if ((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) {
 
 				if (drawReflection) {
 					float3 zeroPos;
@@ -429,7 +443,7 @@
 				}
 
 				float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
-				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+				float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
 				float realIconLength = iconLength * (iconDistMult * iconDistMult);
 				if (sqDist&gt;realIconLength) {
 					drawIcon.push_back(unit);
@@ -438,26 +452,26 @@
 				else {
 					unit-&gt;isIcon = false;
 
-					float farLength = unit-&gt;sqRadius * (unitDrawDist * unitDrawDist);
-					if (sqDist&gt;farLength) {
+					float farLength = unit-&gt;sqRadius * unitDrawDistSqr;
+					if (sqDist &gt; farLength) {
 						drawFar.push_back(unit);
 					} else {
 						DrawUnit(unit);
 					}
 
-					if ((sqDist &lt; (unitDrawDist * unitDrawDist * 500)) &amp;&amp; showHealthBars) {
+					if (showHealthBars &amp;&amp; (sqDist &lt; (unitDrawDistSqr * 500))) {
 						drawStat.push_back(unit);
 					}
 				}
 			}
-			else if (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_PREVLOS) {
+			else if (losStatus &amp; LOS_PREVLOS) {
 				unit-&gt;isIcon = true;
 
 				if ((!gameSetup || gameSetup-&gt;ghostedBuildings) &amp;&amp; !(unit-&gt;mobility)) {
 					// it's a building we've had LOS on once,
 					// add it to the vector of cloaked units
 					float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
-					float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+					float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
 					float realIconLength = iconLength * (iconDistMult * iconDistMult);
 
 					if (sqDist &lt; realIconLength) {
@@ -469,15 +483,15 @@
 						unit-&gt;isIcon = false;
 					}
 				}
-				if ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INRADAR)) {
-					if (!(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_CONTRADAR)) {
+				if (losStatus &amp; LOS_INRADAR) {
+					if (!(losStatus &amp; LOS_CONTRADAR)) {
 						drawRadarIcon.push_back(unit);
 					} else if (unit-&gt;isIcon) {
 						// this prevents us from drawing icons on top of ghosted buildings
 						drawIcon.push_back(unit);
 					}
 				}
-			} else if ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INRADAR)) {
+			} else if (losStatus &amp; LOS_INRADAR) {
 				drawRadarIcon.push_back(unit);
 			}
 		}
@@ -674,38 +688,35 @@
 
 
 bool CUnitDrawer::DrawUnitShadowMT(CUnit *unit) {
-	if ((gs-&gt;Ally(unit-&gt;allyteam, gu-&gt;myAllyTeam)     ||
-		(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) ||
-		gu-&gt;spectatingFullView)
-		&amp;&amp; camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 700)) {
+	const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
+	if (((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) &amp;&amp; camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 700)) {
+		// FIXME: test against the shadow projection intersection
+		float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
+		float farLength = unit-&gt;sqRadius * unitDrawDistSqr;
 
-			// FIXME: test against the shadow projection intersection
-			float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
-			float farLength = unit-&gt;sqRadius * (unitDrawDist * unitDrawDist);
+		if (sqDist &lt; farLength) {
+			float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
+			float realIconLength = iconLength * (iconDistMult * iconDistMult);
 
-			if (sqDist &lt; farLength) {
-				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
-				float realIconLength = iconLength * (iconDistMult * iconDistMult);
+			if (sqDist &lt; realIconLength) {
+				if (!unit-&gt;isCloaked) {
+					if (unit-&gt;lodCount &lt;= 0) {
+						DrawUnitNow(unit);
+					} else {
+						LuaUnitMaterial&amp; unitMat = unit-&gt;luaMats[LUAMAT_SHADOW];
+						const unsigned lod = unit-&gt;CalcLOD(unitMat.GetLastLOD());
+						unit-&gt;currentLOD = lod;
+						LuaUnitLODMaterial* lodMat = unitMat.GetMaterial(lod);
 
-				if (sqDist &lt; realIconLength) {
-					if (!unit-&gt;isCloaked) {
-						if (unit-&gt;lodCount &lt;= 0) {
+						if ((lodMat != NULL) &amp;&amp; lodMat-&gt;IsActive()) {
+							lodMat-&gt;AddUnit(unit);
+						} else {
 							DrawUnitNow(unit);
-						} else {
-							LuaUnitMaterial&amp; unitMat = unit-&gt;luaMats[LUAMAT_SHADOW];
-							const unsigned lod = unit-&gt;CalcLOD(unitMat.GetLastLOD());
-							unit-&gt;currentLOD = lod;
-							LuaUnitLODMaterial* lodMat = unitMat.GetMaterial(lod);
-
-							if ((lodMat != NULL) &amp;&amp; lodMat-&gt;IsActive()) {
-								lodMat-&gt;AddUnit(unit);
-							} else {
-								DrawUnitNow(unit);
-							}
 						}
 					}
 				}
 			}
+		}
 	}
 	return true;
 }
@@ -731,17 +742,16 @@
 	for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
 		CUnit* unit = *usi;
 
-		if ((gs-&gt;Ally(unit-&gt;allyteam, gu-&gt;myAllyTeam)     ||
-			(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) ||
-			gu-&gt;spectatingFullView)
-		    &amp;&amp; camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 700)) {
+		const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
+		if (((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) &amp;&amp;
+		    camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 700)) {
 
 			// FIXME: test against the shadow projection intersection
 			float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
-			float farLength = unit-&gt;sqRadius * (unitDrawDist * unitDrawDist);
+			float farLength = unit-&gt;sqRadius * unitDrawDistSqr;
 
 			if (sqDist &lt; farLength) {
-				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+				float iconDistMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistance();
 				float realIconLength = iconLength * (iconDistMult * iconDistMult);
 
 				if (sqDist &lt; realIconLength) {
@@ -803,19 +813,13 @@
 void CUnitDrawer::DrawIcon(CUnit * unit, bool asRadarBlip)
 {
 	// If the icon is to be drawn as a radar blip, we want to get the default icon.
-	std::string iconType;
-	if(asRadarBlip){
-		iconType=&quot;default&quot;;
+	const CIconData* iconData;
+	if (asRadarBlip) {
+		iconData = iconHandler-&gt;GetDefaultIconData();
 	} else {
-		iconType=unit-&gt;unitDef-&gt;iconType;
+		iconData = unit-&gt;unitDef-&gt;iconType.GetIconData();
 	}
 
-	// Fetch the icon information.
-	CIcon* icon=iconHandler-&gt;GetIcon(iconType);
-
-	unsigned char color[4];
-	color[3]=255;
-
 	// Calculate the icon size. It scales with:
 	//  * The square root of the camera distance.
 	//  * The mod defined 'iconSize' (which acts a multiplier).
@@ -824,25 +828,23 @@
 	if (gu-&gt;spectatingFullView) {
 		pos = unit-&gt;midPos;
 	} else {
-		pos = helper-&gt;GetUnitErrorPos(unit,gu-&gt;myAllyTeam);
+		pos = helper-&gt;GetUnitErrorPos(unit, gu-&gt;myAllyTeam);
 	}
-	float dist=sqrt((pos-camera-&gt;pos).Length());
-	float scale=0.4f*icon-&gt;size*dist;
-	if (icon-&gt;radiusAdjust &amp;&amp; !asRadarBlip) {
-		scale=scale*unit-&gt;radius/30; // I take the standard unit radius to be 30 ... call it an educated guess. (Teake Nutma)
+	float dist = sqrt((pos - camera-&gt;pos).Length());
+	float scale = 0.4f * iconData-&gt;GetSize() * dist;
+	if (iconData-&gt;GetRadiusAdjust() &amp;&amp; !asRadarBlip) {
+		// I take the standard unit radius to be 30
+		// ... call it an educated guess. (Teake Nutma)
+		scale *= (unit-&gt;radius / 30);
 	}
 
 	unit-&gt;iconRadius = scale; // store the icon size so that we don't have to calculate it again
 
 	// Is the unit selected? Then draw it white.
 	if (unit-&gt;commandAI-&gt;selected) {
-		color[0] = 255;
-		color[1] = 255;
-		color[2] = 255;
+		glColor3ub(255, 255, 255);
 	} else {
-		color[0] = gs-&gt;Team(unit-&gt;team)-&gt;color[0];
-		color[1] = gs-&gt;Team(unit-&gt;team)-&gt;color[1];
-		color[2] = gs-&gt;Team(unit-&gt;team)-&gt;color[2];
+		glColor3ubv(gs-&gt;Team(unit-&gt;team)-&gt;color);
 	}
 
 	// If the icon is partly under the ground, move it up.
@@ -851,15 +853,18 @@
 		pos.y = (h + scale);
 	}
 
+	// calculate the vertices
+	const float3 dy = camera-&gt;up    * scale;
+	const float3 dx = camera-&gt;right * scale;
+	const float3 vn = pos - dx;
+	const float3 vp = pos + dx;
+	const float3 vnn = vn - dy;
+	const float3 vpn = vp - dy;
+	const float3 vnp = vn + dy;
+	const float3 vpp = vp + dy;
+	
 	// Draw the icon.
-	glBindTexture(GL_TEXTURE_2D, icon-&gt;texture);
-	va = GetVertexArray();
-	va-&gt;Initialize();
-	va-&gt;AddVertexTC(pos + camera-&gt;up * scale + camera-&gt;right * scale, 1, 0, color);
-	va-&gt;AddVertexTC(pos - camera-&gt;up * scale + camera-&gt;right * scale, 1, 1, color);
-	va-&gt;AddVertexTC(pos - camera-&gt;up * scale - camera-&gt;right * scale, 0, 1, color);
-	va-&gt;AddVertexTC(pos + camera-&gt;up * scale - camera-&gt;right * scale, 0, 0, color);
-	va-&gt;DrawArrayTC(GL_QUADS);
+	iconData-&gt;Draw(vnn, vpn, vnp, vpp);
 }
 
 
@@ -980,8 +985,8 @@
 	// cloaked units and living ghosted buildings (stored in same vector)
 	for (GML_VECTOR&lt;CUnit*&gt;::iterator ui = dC.begin(); ui != dC.end(); ++ui) {
 		CUnit* unit = *ui;
-
-		if ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) || gu-&gt;spectatingFullView) {
+		const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
+		if ((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) {
 			if (is_s3o) {
 				SetBasicS3OTeamColour(unit-&gt;team);
 				texturehandler-&gt;SetS3oTexture(unit-&gt;model-&gt;textureType);
@@ -989,11 +994,11 @@
 			DrawUnitNow(unit);
 		} else {
 			// ghosted enemy units
-			if (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_CONTRADAR)
+			if (losStatus &amp; LOS_CONTRADAR) {
 				glColor4f(0.9f, 0.9f, 0.9f, 0.5f);
-			else
+			} else {
 				glColor4f(0.6f, 0.6f, 0.6f, 0.4f);
-
+			}
 			glPushMatrix();
 			glTranslatef3(unit-&gt;pos);
 			glRotatef(unit-&gt;buildFacing * 90.0f, 0, 1, 0);
@@ -1846,10 +1851,6 @@
 }
 
 
-
-
-
-
 inline void CUnitDrawer::DrawUnitDebug(CUnit* unit)
 {
 	// draw the collision volume
@@ -1911,6 +1912,7 @@
 	}
 }
 
+
 void CUnitDrawer::DrawUnitBeingBuilt(CUnit* unit)
 {
 	if (shadowHandler-&gt;inShadowPass) {
@@ -1946,10 +1948,23 @@
 	const double plane1[4] = {0, 1, 0, -start - height * (unit-&gt;buildProgress * 10 - 9)};
 	glClipPlane(GL_CLIP_PLANE1, plane1);
 
-	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
-	DrawUnitModel(unit);
-	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+	if (!usingAtiHacks) {
+		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+		DrawUnitModel(unit);
+		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+	}
+	else {
+		glDisable(GL_CLIP_PLANE0);
+		glDisable(GL_CLIP_PLANE1);
 
+		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+		DrawUnitModel(unit);
+		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+
+		glEnable(GL_CLIP_PLANE0);
+		glEnable(GL_CLIP_PLANE1);
+	}
+
 	if (unit-&gt;buildProgress &gt; 0.33f) {
 		glColorf3(fc * (1.5f - col));
 		const double plane0[4] = {0, -1, 0, start + height * (unit-&gt;buildProgress * 3 - 1)};
@@ -1983,7 +1998,6 @@
 }
 
 
-
 void CUnitDrawer::ApplyUnitTransformMatrix(CUnit* unit)
 {
 	CMatrix44f m;
@@ -1991,6 +2005,7 @@
 	glMultMatrixf(&amp;m[0]);
 }
 
+
 inline void CUnitDrawer::DrawUnitModel(CUnit* unit) {
 	if (unit-&gt;luaDraw &amp;&amp; luaRules &amp;&amp; luaRules-&gt;DrawUnit(unit-&gt;id)) {
 		return;
@@ -2003,6 +2018,7 @@
 	}
 }
 
+
 void CUnitDrawer::DrawUnitNow(CUnit* unit)
 {
 	glAlphaFunc(GL_GEQUAL, unit-&gt;alphaThreshold);
@@ -2020,6 +2036,7 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitWithLists(CUnit* unit, unsigned int preList, unsigned int postList)
 {
 	glPushMatrix();
@@ -2043,6 +2060,7 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitRaw(CUnit* unit)
 {
 	glPushMatrix();
@@ -2051,6 +2069,7 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitRawModel(CUnit* unit)
 {
 	if (unit-&gt;lodCount &lt;= 0) {
@@ -2060,6 +2079,7 @@
 	}
 }
 
+
 void CUnitDrawer::DrawUnitRawWithLists(CUnit* unit, unsigned int preList, unsigned int postList)
 {
 	glPushMatrix();
@@ -2078,6 +2098,7 @@
 	glPopMatrix();
 }
 
+
 void CUnitDrawer::DrawUnitStats(CUnit* unit)
 {
 	if ((gu-&gt;myAllyTeam != unit-&gt;allyteam) &amp;&amp;
@@ -2170,6 +2191,7 @@
 	DrawUnitNow(unit);
 }
 
+
 void CUnitDrawer::DrawFeatureS3O(CFeature* feature)
 {
 	glPushMatrix();

Modified: branches/gml/rts/Rendering/UnitModels/UnitDrawer.h
===================================================================
--- branches/gml/rts/Rendering/UnitModels/UnitDrawer.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Rendering/UnitModels/UnitDrawer.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -69,6 +69,9 @@
 	void DrawFeatureS3O(CFeature*);									// was CFeature::DrawS3O()
 	void DrawWorldObjectS3O(CWorldObject*);
 
+	void SetUnitDrawDist(float dist);
+	void SetUnitIconDist(float dist);
+
 	GML_VECTOR&lt;CUnit*&gt; drawCloaked;
 	GML_VECTOR&lt;CUnit*&gt; drawCloakedS3O;
 
@@ -102,6 +105,7 @@
 	unsigned int specTexSize;
 
 	float unitDrawDist;
+	float unitDrawDistSqr;
 	float unitIconDist;
 	float iconLength;
 
@@ -136,6 +140,8 @@
 
 	bool showHealthBars;
 
+	bool usingAtiHacks;
+
 	float3 camNorm;		//used by drawfar
 
 #ifdef DIRECT_CONTROL_ALLOWED

Modified: branches/gml/rts/Sim/Features/FeatureDef.h
===================================================================
--- branches/gml/rts/Sim/Features/FeatureDef.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Features/FeatureDef.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,10 +1,15 @@
 #ifndef FEATURE_DEF_H
 #define FEATURE_DEF_H
 
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+
 #define DRAWTYPE_3DO 0
 #define DRAWTYPE_TREE 1
 #define DRAWTYPE_NONE -1
 
+
 struct S3DOModel;
 struct CollisionVolume;
 
@@ -69,6 +74,8 @@
 	int xsize;
 	/// each size is 8 units
 	int ysize;
+
+	std::map&lt;std::string, std::string&gt; customParams;
 };
 
 #endif

Modified: branches/gml/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Features/FeatureHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Features/FeatureHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -221,9 +221,9 @@
 
 	fd-&gt;deathFeature = fdTable.GetString(&quot;featureDead&quot;, &quot;&quot;);
 
-	fd-&gt;metal     = fdTable.GetFloat(&quot;metal&quot;,  0.0f);
-	fd-&gt;energy    = fdTable.GetFloat(&quot;energy&quot;, 0.0f);
-	fd-&gt;maxHealth = fdTable.GetFloat(&quot;damage&quot;, 0.0f);
+	fd-&gt;metal       = fdTable.GetFloat(&quot;metal&quot;,  0.0f);
+	fd-&gt;energy      = fdTable.GetFloat(&quot;energy&quot;, 0.0f);
+	fd-&gt;maxHealth   = fdTable.GetFloat(&quot;damage&quot;, 0.0f);
 	fd-&gt;reclaimTime = fdTable.GetFloat(&quot;reclaimTime&quot;, (fd-&gt;metal + fd-&gt;energy));
 
 	fd-&gt;drawType = DRAWTYPE_3DO;
@@ -241,17 +241,16 @@
 
 	// these take precedence over the old sphere tags as well as
 	// feature-&gt;radius (for feature &lt;--&gt; projectile interactions)
-	fd-&gt;collisionVolumeType = fdTable.GetString(&quot;collisionVolumeType&quot;, &quot;&quot;);
-	fd-&gt;collisionVolumeScales = fdTable.GetFloat3(&quot;collisionVolumeScales&quot;, ZeroVector);
+	fd-&gt;collisionVolumeType    = fdTable.GetString(&quot;collisionVolumeType&quot;, &quot;&quot;);
+	fd-&gt;collisionVolumeScales  = fdTable.GetFloat3(&quot;collisionVolumeScales&quot;, ZeroVector);
 	fd-&gt;collisionVolumeOffsets = fdTable.GetFloat3(&quot;collisionVolumeOffsets&quot;, ZeroVector);
-	fd-&gt;collisionVolumeTest = fdTable.GetInt(&quot;collisionVolumeTest&quot;, COLVOL_TEST_CONT);
+	fd-&gt;collisionVolumeTest    = fdTable.GetInt(&quot;collisionVolumeTest&quot;, COLVOL_TEST_CONT);
 
 	// initialize the (per-featuredef) collision-volume,
 	// all CFeature instances hold a copy of this object
 	fd-&gt;collisionVolume = SAFE_NEW CollisionVolume(fd-&gt;collisionVolumeType,
-		fd-&gt;collisionVolumeScales, fd-&gt;collisionVolumeOffsets, fd-&gt;collisionVolumeTest);
+	fd-&gt;collisionVolumeScales, fd-&gt;collisionVolumeOffsets, fd-&gt;collisionVolumeTest);
 
-
 	fd-&gt;upright = fdTable.GetBool(&quot;upright&quot;, false);
 
 	// our resolution is double TA's
@@ -262,6 +261,9 @@
 	fd-&gt;mass = fdTable.GetFloat(&quot;mass&quot;, defMass);
 	fd-&gt;mass = max(0.001f, fd-&gt;mass);
 
+	// custom parameters table
+	fdTable.SubTable(&quot;customParams&quot;).GetMap(fd-&gt;customParams);
+
 	AddFeatureDef(name, fd);
 
 	fi = featureDefs.find(name);

Modified: branches/gml/rts/Sim/Misc/LosHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Misc/LosHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Misc/LosHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -5,13 +5,13 @@
 
 #include &quot;LosHandler.h&quot;
 
+#include &quot;Sim/ModInfo.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &lt;list&gt;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;TimeProfiler.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
-#include &quot;Sim/Misc/SensorHandler.h&quot;
 #include &quot;creg/STL_Deque.h&quot;
 #include &quot;creg/STL_List.h&quot;
 #include &quot;mmgr.h&quot;
@@ -89,8 +89,8 @@
 
 CLosHandler::CLosHandler()
 {
-	losMipLevel = sensorHandler-&gt;losMipLevel;
-	airMipLevel = sensorHandler-&gt;airMipLevel;
+	losMipLevel = modInfo.losMipLevel;
+	airMipLevel = modInfo.airMipLevel;
 	airSizeX = std::max(1, gs-&gt;mapx &gt;&gt; airMipLevel);
 	airSizeY = std::max(1, gs-&gt;mapy &gt;&gt; airMipLevel);
 	losSizeX = std::max(1, gs-&gt;mapx &gt;&gt; losMipLevel);

Modified: branches/gml/rts/Sim/Misc/LosHandler.h
===================================================================
--- branches/gml/rts/Sim/Misc/LosHandler.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Misc/LosHandler.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -57,34 +57,9 @@
 	void MoveUnit(CUnit* unit, bool redoCurrent);
 	void FreeInstance(LosInstance* instance);
 
-	bool InLos(const CUnit* unit, int allyTeam) {
-		if (unit-&gt;isCloaked)
-			return false;
-		if (unit-&gt;alwaysVisible)
-			return true;
-		if (unit-&gt;useAirLos) {
-			const int rowIdx = std::max(0, std::min(airSizeY - 1, ((int(unit-&gt;pos.z * invAirDiv))))) * airSizeX;
-			const int colIdx = std::max(0, std::min(airSizeX - 1, ((int(unit-&gt;pos.x * invAirDiv)))));
-			const int square = rowIdx + colIdx;
-			#ifdef DEBUG
-			assert(square &lt; airLosMap[allyTeam].size());
-			#endif
-			return !!airLosMap[allyTeam][square];
-		} else {
-			if (unit-&gt;isUnderWater &amp;&amp; !radarhandler-&gt;InRadar(unit, allyTeam))
-				return false;
-
-			const int rowIdx = std::max(0, std::min(losSizeY - 1, ((int) (unit-&gt;pos.z * invLosDiv)))) * losSizeX;
-			const int colIdx = std::max(0, std::min(losSizeX - 1, ((int) (unit-&gt;pos.x * invLosDiv))));
-			const int square = rowIdx + colIdx;
-			#ifdef DEBUG
-			assert(square &lt; losMap[allyTeam].size());
-			#endif
-			return !!losMap[allyTeam][square];
-		}
-	}
-
 	bool InLos(const CWorldObject* object, int allyTeam) {
+		if (object-&gt;alwaysVisible)
+			return true;
 		if (object-&gt;useAirLos) {
 			const int rowIdx = std::max(0, std::min(airSizeY - 1, ((int (object-&gt;pos.z * invAirDiv))))) * airSizeX;
 			const int colIdx = std::max(0, std::min(airSizeX - 1, ((int (object-&gt;pos.x * invAirDiv)))));
@@ -92,7 +67,7 @@
 			#ifdef DEBUG
 			assert(square &lt; airLosMap[allyTeam].size());
 			#endif
-			return !!airLosMap[allyTeam][square] | object-&gt;alwaysVisible;
+			return !!airLosMap[allyTeam][square];
 		} else {
 			const int rowIdx = std::max(0, std::min(losSizeY - 1, ((int) (object-&gt;pos.z * invLosDiv)))) * losSizeX;
 			const int colIdx = std::max(0, std::min(losSizeX - 1, ((int) (object-&gt;pos.x * invLosDiv))));
@@ -100,10 +75,18 @@
 			#ifdef DEBUG
 			assert(square &lt; losMap[allyTeam].size());
 			#endif
-			return !!losMap[allyTeam][square] | object-&gt;alwaysVisible;
+			return !!losMap[allyTeam][square];
 		}
 	}
 
+	bool InLos(const CUnit* unit, int allyTeam) {
+		if (unit-&gt;alwaysVisible)
+			return true;
+		if (unit-&gt;isCloaked)
+			return false;
+		return InLos(static_cast&lt;const CWorldObject*&gt;(unit), allyTeam);
+	}
+
 	bool InLos(float3 pos, int allyTeam) {
 		pos.CheckInBounds();
 		const int square = ((int) (pos.z * invLosDiv)) * losSizeX + ((int) (pos.x * invLosDiv));

Deleted: branches/gml/rts/Sim/Misc/SensorHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Misc/SensorHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Misc/SensorHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,54 +0,0 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;SensorHandler.h&quot;
-#include &quot;TdfParser.h&quot;
-
-CR_BIND(CSensorHandler, );
-
-CR_REG_METADATA(CSensorHandler, (
-		CR_MEMBER(losMipLevel),
-		CR_MEMBER(airMipLevel),
-		CR_MEMBER(losMul),
-		CR_MEMBER(airLosMul),
-		CR_RESERVED(16)
-		));
-
-
-CSensorHandler* sensorHandler;
-
-
-CSensorHandler::CSensorHandler()
-{
-	TdfParser tdfparser;
-
-	try {
-		tdfparser.LoadFile(&quot;gamedata/sensors.tdf&quot;);
-	} catch (content_error) {
-		// No need to do anything here, we just continue
-		// getting default values from the empty tdfparser.
-	}
-
-	tdfparser.GetDef(losMipLevel, &quot;1&quot;, &quot;Sensors\\Los\\LosMipLevel&quot;);
-	//loshandler-&gt;losMipLevel = losMipLevel;
-	tdfparser.GetDef(airMipLevel, &quot;2&quot;, &quot;Sensors\\Los\\AirLosMipLevel&quot;);
-	//loshandler-&gt;airLosMipLevel = airLosMipLevel;
-
-	// losMipLevel is used as index to readmap-&gt;mipHeightmap,
-	// so the max value is CReadMap::numHeightMipMaps - 1
-	if (losMipLevel &lt; 0 || losMipLevel &gt;= 7)
-		throw content_error(&quot;Sensors\\Los\\LosMipLevel out of bounds. &quot;
-				&quot;The minimum value is 0. The maximum value is 6.&quot;);
-
-	// airLosMipLevel doesn't have such restrictions, it's just used in various
-	// bitshifts with signed integers
-	if (airMipLevel &lt; 0 || airMipLevel &gt; 30)
-		throw content_error(&quot;Sensors\\Los\\AirLosMipLevel out of bounds. &quot;
-				&quot;The minimum value is 0. The maximum value is 30.&quot;);
-
-	tdfparser.GetDef(losMul, &quot;1&quot;, &quot;Sensors\\Los\\LosMul&quot;);
-	tdfparser.GetDef(airLosMul, &quot;1&quot;, &quot;Sensors\\Los\\AirLosMul&quot;);
-}
-
-
-CSensorHandler::~CSensorHandler()
-{
-}

Deleted: branches/gml/rts/Sim/Misc/SensorHandler.h
===================================================================
--- branches/gml/rts/Sim/Misc/SensorHandler.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Misc/SensorHandler.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,28 +0,0 @@
-#ifndef SENSORHANDLER_H
-#define SENSORHANDLER_H
-
-#include &lt;boost/noncopyable.hpp&gt;
-
-/// This class is responsible for reading the gamedata/sensors.tdf file and parsing relevant data.
-class CSensorHandler : public boost::noncopyable
-{
-	CR_DECLARE(CSensorHandler);
-
-public:
-	CSensorHandler();
-	~CSensorHandler();
-
-	/// miplevel for los
-	int losMipLevel;
-	/// miplevel to use for airlos
-	int airMipLevel;
-
-	/// units sightdistance will be multiplied with this, for testing purposes
-	float losMul;
-	/// units airsightdistance will be multiplied with this, for testing purposes
-	float airLosMul;
-};
-
-extern CSensorHandler* sensorHandler;
-
-#endif

Modified: branches/gml/rts/Sim/ModInfo.cpp
===================================================================
--- branches/gml/rts/Sim/ModInfo.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/ModInfo.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -84,4 +84,25 @@
 	// flanking bonus
 	const LuaTable flankingBonusTbl = root.SubTable(&quot;flankingBonus&quot;);
 	flankingBonusModeDefault = flankingBonusTbl.GetInt(&quot;defaultMode&quot;, 1);
+	
+	// sensors
+	const LuaTable sensors = root.SubTable(&quot;sensors&quot;);
+	/// LoS
+	const LuaTable los = sensors.SubTable(&quot;los&quot;);
+	// losMipLevel is used as index to readmap-&gt;mipHeightmap,
+	// so the max value is CReadMap::numHeightMipMaps - 1
+	losMipLevel = los.GetInt(&quot;losMipLevel&quot;, 1);
+	losMul = los.GetFloat(&quot;losMul&quot;, 1.0f);
+	if ((losMipLevel &lt; 0) || (losMipLevel &gt; 6)) {
+		throw content_error(&quot;Sensors\\Los\\LosMipLevel out of bounds. &quot;
+		                    &quot;The minimum value is 0. The maximum value is 6.&quot;);
+	}
+	// airLosMipLevel doesn't have such restrictions, it's just used in various
+	// bitshifts with signed integers
+	airMipLevel = los.GetInt(&quot;airMipLevel&quot;, 2);
+	if ((airMipLevel &lt; 0) || (airMipLevel &gt; 30)) {
+		throw content_error(&quot;Sensors\\Los\\AirLosMipLevel out of bounds. &quot;
+		                    &quot;The minimum value is 0. The maximum value is 30.&quot;);
+	}
+	airLosMul = los.GetFloat(&quot;airLosMul&quot;, 1.0f);
 }

Modified: branches/gml/rts/Sim/ModInfo.h
===================================================================
--- branches/gml/rts/Sim/ModInfo.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/ModInfo.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -40,6 +40,16 @@
 	int fireAtCrashing;	//1 = units fire at crashing aircrafts, 0 = units ignore crashing aircrafts
 
 	int flankingBonusModeDefault;	//0=no flanking bonus;  1=global coords, mobile;  2=unit coords, mobile;  3=unit coords, locked
+	
+	//Sensors behaviour
+	/// miplevel for los
+	int losMipLevel;
+	/// miplevel to use for airlos
+	int airMipLevel;
+	/// units sightdistance will be multiplied with this, for testing purposes
+	float losMul;
+	/// units airsightdistance will be multiplied with this, for testing purposes
+	float airLosMul;
 };
 
 extern CModInfo modInfo;

Modified: branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,40 +1,42 @@
-#include &quot;StdAfx.h&quot;
+
 // ProjectileHandler.cpp: implementation of the CProjectileHandler class.
 //
 //////////////////////////////////////////////////////////////////////
 
+#include &lt;algorithm&gt;
+#include &quot;StdAfx.h&quot;
+#include &quot;Projectile.h&quot;
 #include &quot;ProjectileHandler.h&quot;
+#include &quot;Game/Camera.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;Map/Ground.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Platform/ConfigHandler.h&quot;
+#include &quot;Rendering/GroundFlash.h&quot;
+#include &quot;Rendering/ShadowHandler.h&quot;
+#include &quot;Rendering/GL/IFramebuffer.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;Projectile.h&quot;
-#include &quot;Game/Camera.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
-#include &quot;Sim/Misc/QuadField.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
-#include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;TimeProfiler.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
-#include &quot;Rendering/GroundFlash.h&quot;
-#include &quot;Sim/Misc/LosHandler.h&quot;
-#include &quot;Map/Ground.h&quot;
-#include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/Textures/TextureHandler.h&quot;
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
+#include &quot;Rendering/UnitModels/3DOParser.h&quot;
+#include &quot;Rendering/UnitModels/s3oParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Misc/CollisionHandler.h&quot;
+#include &quot;Sim/Misc/LosHandler.h&quot;
+#include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Projectiles/Unsynced/ShieldPartProjectile.h&quot;
-#include &quot;Platform/ConfigHandler.h&quot;
-#include &quot;Rendering/ShadowHandler.h&quot;
-#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
-#include &quot;Rendering/UnitModels/3DOParser.h&quot;
-#include &quot;Rendering/UnitModels/s3oParser.h&quot;
-#include &quot;LogOutput.h&quot;
-#include &lt;algorithm&gt;
-#include &quot;Rendering/GL/IFramebuffer.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/TimeProfiler.h&quot;
+#include &quot;System/creg/STL_List.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
-#include &quot;creg/STL_List.h&quot;
 
+
 CProjectileHandler* ph;
 using namespace std;
 
@@ -67,32 +69,45 @@
 	// used to block resources_map.tdf from loading textures
 	std::set&lt;std::string&gt; blockMapTexNames;
 
-	TdfParser resources(&quot;gamedata/resources.tdf&quot;);
+	LuaParser resourcesParser(&quot;gamedata/resources.lua&quot;,
+	                          SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
+	if (!resourcesParser.Execute()) {
+		logOutput.Print(resourcesParser.GetErrorLog());
+	}
+	const LuaTable rootTable = resourcesParser.GetRoot();
+	const LuaTable ptTable = rootTable.SubTable(&quot;graphics&quot;).SubTable(&quot;projectileTextures&quot;);
 	//add all textures in projectiletextures section
-	std::map&lt;std::string,std::string&gt; ptex = resources.GetAllValues(&quot;resources\\graphics\\projectiletextures&quot;);
+	std::map&lt;std::string, std::string&gt; ptex;
+	ptTable.GetMap(ptex);
+
 	for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex.begin(); pi!=ptex.end(); ++pi)
 	{
 		textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
-		blockMapTexNames.insert(pi-&gt;first);
+		blockMapTexNames.insert(StringToLower(pi-&gt;first));
 	}
 	//add all texture from sections within projectiletextures section
-	std::vector&lt;std::string&gt; seclist = resources.GetSectionList(&quot;resources\\graphics\\projectiletextures&quot;);
+	std::vector&lt;std::string&gt; seclist; 
+	ptTable.GetKeys(seclist);
 	for(int i=0; i&lt;seclist.size(); i++)
 	{
-		std::map&lt;std::string,std::string&gt; ptex2 = resources.GetAllValues(&quot;resources\\graphics\\projectiletextures\\&quot; + seclist[i]);
-		for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex2.begin(); pi!=ptex2.end(); ++pi)
-		{
-			textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
-			blockMapTexNames.insert(pi-&gt;first);
+		const LuaTable ptSubTable = ptTable.SubTable(seclist[i]);
+		if (ptSubTable.IsValid()) {
+			std::map&lt;std::string,std::string&gt; ptex2;
+			ptSubTable.GetMap(ptex2);
+			for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex2.begin(); pi!=ptex2.end(); ++pi)
+			{
+				textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
+				blockMapTexNames.insert(StringToLower(pi-&gt;first));
+			}
 		}
 	}
 
-
+	const LuaTable smokeTable = rootTable.SubTable(&quot;smoke&quot;);
 	for (int i = 0; i &lt; 12; i++) {
 		char num[10];
 		sprintf(num, &quot;%02i&quot;, i);
-		textureAtlas-&gt;AddTexFromFile(std::string(&quot;ismoke&quot;) + num, std::string(&quot;bitmaps/&quot;)+resources.SGetValueDef(std::string(&quot;smoke/smoke&quot;) + num +&quot;.tga&quot;,std::string(&quot;resources\\graphics\\smoke\\smoke&quot;)+num));
-		blockMapTexNames.insert(std::string(&quot;ismoke&quot;) + num);
+		textureAtlas-&gt;AddTexFromFile(std::string(&quot;ismoke&quot;) + num, std::string(&quot;bitmaps/&quot;)+smokeTable.GetString(std::string(&quot;smoke&quot;)+num, std::string(&quot;smoke/smoke&quot;) + num +&quot;.tga&quot;));
+		blockMapTexNames.insert(StringToLower(std::string(&quot;ismoke&quot;) + num));
 	}
 
 	char tex[128][128][4];
@@ -139,18 +154,36 @@
 	blockMapTexNames.insert(&quot;plasmatexture&quot;);
 
 	// allow map specified atlas textures for gaia unit projectiles
-	CFileHandler fh(&quot;gamedata/resources_map.tdf&quot;);
-	if (fh.FileExists()) {
-		TdfParser resources_map(&quot;gamedata/resources_map.tdf&quot;);
+	LuaParser mapResParser(&quot;gamedata/resources_map.lua&quot;,
+	                              SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
+	if (mapResParser.IsValid()) {
+		const LuaTable mapRoot = mapResParser.GetRoot();
+		const LuaTable mapTable = mapRoot.SubTable(&quot;projectileTextures&quot;);
 		//add all textures in projectiletextures section 
-		std::map&lt;std::string,std::string&gt; mptex =
-			resources_map.GetAllValues(&quot;resources\\graphics\\projectiletextures&quot;);
+		std::map&lt;std::string,std::string&gt; mptex;
+		mapTable.GetMap(mptex);
 		std::map&lt;std::string,std::string&gt;::iterator pi;
 		for (pi = mptex.begin(); pi != mptex.end(); ++pi) {
-			if (blockMapTexNames.find(pi-&gt;first) == blockMapTexNames.end()) {
+			if (blockMapTexNames.find(StringToLower(pi-&gt;first)) == blockMapTexNames.end()) {
 				textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
 			}
 		}
+		//add all texture from sections within projectiletextures section
+		mapTable.GetKeys(seclist);
+		for(int i=0; i&lt;seclist.size(); i++)
+		{
+			const LuaTable mapSubTable = mapTable.SubTable(seclist[i]);
+			if (mapSubTable.IsValid()) {
+				std::map&lt;std::string,std::string&gt; ptex2;
+				mapSubTable.GetMap(ptex2);
+				for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex2.begin(); pi!=ptex2.end(); ++pi)
+				{
+					if (blockMapTexNames.find(StringToLower(pi-&gt;first)) == blockMapTexNames.end()) {
+						textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
+					}
+				}
+			}
+		}
 	}
 
 	if (!textureAtlas-&gt;Finalize()) {
@@ -175,40 +208,47 @@
 		smoketex[i] = textureAtlas-&gt;GetTexture(std::string(&quot;ismoke&quot;) + num);
 	}
 
-	sbtrailtex        = textureAtlas-&gt;GetTextureWithBackup(&quot;sbtrailtexture&quot;,         &quot;smoketrail&quot;    );
-	missiletrailtex   = textureAtlas-&gt;GetTextureWithBackup(&quot;missiletrailtexture&quot;,    &quot;smoketrail&quot;    );
-	muzzleflametex    = textureAtlas-&gt;GetTextureWithBackup(&quot;muzzleflametexture&quot;,     &quot;explo&quot;         );
-	repulsetex        = textureAtlas-&gt;GetTextureWithBackup(&quot;repulsetexture&quot;,         &quot;explo&quot;         );
-	dguntex           = textureAtlas-&gt;GetTextureWithBackup(&quot;dguntexture&quot;,            &quot;flare&quot;         );
-	flareprojectiletex= textureAtlas-&gt;GetTextureWithBackup(&quot;flareprojectiletexture&quot;, &quot;flare&quot;         );
-	sbflaretex        = textureAtlas-&gt;GetTextureWithBackup(&quot;sbflaretexture&quot;,         &quot;flare&quot;         );
-	missileflaretex   = textureAtlas-&gt;GetTextureWithBackup(&quot;missileflaretexture&quot;,    &quot;flare&quot;         );
-	beamlaserflaretex = textureAtlas-&gt;GetTextureWithBackup(&quot;beamlaserflaretexture&quot;,  &quot;flare&quot;         );
-	bubbletex         = textureAtlas-&gt;GetTextureWithBackup(&quot;bubbletexture&quot;,          &quot;circularthingy&quot;);
-	geosquaretex      = textureAtlas-&gt;GetTextureWithBackup(&quot;geosquaretexture&quot;,       &quot;circularthingy&quot;);
-	gfxtex            = textureAtlas-&gt;GetTextureWithBackup(&quot;gfxtexture&quot;,             &quot;circularthingy&quot;);
-	projectiletex     = textureAtlas-&gt;GetTextureWithBackup(&quot;projectiletexture&quot;,      &quot;circularthingy&quot;);
-	repulsegfxtex     = textureAtlas-&gt;GetTextureWithBackup(&quot;repulsegfxtexture&quot;,      &quot;circularthingy&quot;);
-	sphereparttex     = textureAtlas-&gt;GetTextureWithBackup(&quot;sphereparttexture&quot;,      &quot;circularthingy&quot;);
-	torpedotex        = textureAtlas-&gt;GetTextureWithBackup(&quot;torpedotexture&quot;,         &quot;circularthingy&quot;);
-	wrecktex          = textureAtlas-&gt;GetTextureWithBackup(&quot;wrecktexture&quot;,           &quot;circularthingy&quot;);
-	plasmatex         = textureAtlas-&gt;GetTextureWithBackup(&quot;plasmatexture&quot;,          &quot;circularthingy&quot;);
+#define GETTEX(t, b) textureAtlas-&gt;GetTextureWithBackup((t), (b))
+	sbtrailtex         = GETTEX(&quot;sbtrailtexture&quot;,         &quot;smoketrail&quot;    );
+	missiletrailtex    = GETTEX(&quot;missiletrailtexture&quot;,    &quot;smoketrail&quot;    );
+	muzzleflametex     = GETTEX(&quot;muzzleflametexture&quot;,     &quot;explo&quot;         );
+	repulsetex         = GETTEX(&quot;repulsetexture&quot;,         &quot;explo&quot;         );
+	dguntex            = GETTEX(&quot;dguntexture&quot;,            &quot;flare&quot;         );
+	flareprojectiletex = GETTEX(&quot;flareprojectiletexture&quot;, &quot;flare&quot;         );
+	sbflaretex         = GETTEX(&quot;sbflaretexture&quot;,         &quot;flare&quot;         );
+	missileflaretex    = GETTEX(&quot;missileflaretexture&quot;,    &quot;flare&quot;         );
+	beamlaserflaretex  = GETTEX(&quot;beamlaserflaretexture&quot;,  &quot;flare&quot;         );
+	bubbletex          = GETTEX(&quot;bubbletexture&quot;,          &quot;circularthingy&quot;);
+	geosquaretex       = GETTEX(&quot;geosquaretexture&quot;,       &quot;circularthingy&quot;);
+	gfxtex             = GETTEX(&quot;gfxtexture&quot;,             &quot;circularthingy&quot;);
+	projectiletex      = GETTEX(&quot;projectiletexture&quot;,      &quot;circularthingy&quot;);
+	repulsegfxtex      = GETTEX(&quot;repulsegfxtexture&quot;,      &quot;circularthingy&quot;);
+	sphereparttex      = GETTEX(&quot;sphereparttexture&quot;,      &quot;circularthingy&quot;);
+	torpedotex         = GETTEX(&quot;torpedotexture&quot;,         &quot;circularthingy&quot;);
+	wrecktex           = GETTEX(&quot;wrecktexture&quot;,           &quot;circularthingy&quot;);
+	plasmatex          = GETTEX(&quot;plasmatexture&quot;,          &quot;circularthingy&quot;);
+#undef GETTEX
 
 	groundFXAtlas = SAFE_NEW CTextureAtlas(2048, 2048);
 	//add all textures in groundfx section
-	ptex = resources.GetAllValues(&quot;resources\\graphics\\groundfx&quot;);
+	const LuaTable groundfxTable = resourcesParser.GetRoot().SubTable(&quot;resources&quot;).SubTable(&quot;graphics&quot;).SubTable(&quot;groundfx&quot;);
+	groundfxTable.GetMap(ptex);
 	for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex.begin(); pi!=ptex.end(); ++pi)
 	{
 		groundFXAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
 	}
 	//add all texture from sections within groundfx section
-	seclist = resources.GetSectionList(&quot;resources\\graphics\\groundfx&quot;);
+	groundfxTable.GetKeys(seclist);
 	for(int i=0; i&lt;seclist.size(); i++)
 	{
-		std::map&lt;std::string,std::string&gt; ptex2 = resources.GetAllValues(&quot;resources\\graphics\\groundfx\\&quot; + seclist[i]);
-		for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex2.begin(); pi!=ptex2.end(); ++pi)
-		{
-			groundFXAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
+		const LuaTable gfxSubTable = groundfxTable.SubTable(seclist[i]);
+		if (gfxSubTable.IsValid()) {
+			std::map&lt;std::string,std::string&gt; ptex2;
+			gfxSubTable.GetMap(ptex2);
+			for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex2.begin(); pi!=ptex2.end(); ++pi)
+			{
+				groundFXAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
+			}
 		}
 	}
 

Modified: branches/gml/rts/Sim/Units/COB/CobFile.h
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobFile.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Units/COB/CobFile.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -38,7 +38,7 @@
 const int COBFN_Last = 16;					//Make sure to update this, so the array will be sized properly
 
 // These are special (they need space for MaxWeapons of each)
-const int COB_MaxWeapons = 16;
+const int COB_MaxWeapons = 32;
 const int COBFN_QueryPrimary   = COBFN_Last;
 const int COBFN_AimPrimary     = COBFN_QueryPrimary   + COB_MaxWeapons;
 const int COBFN_AimFromPrimary = COBFN_AimPrimary     + COB_MaxWeapons;

Modified: branches/gml/rts/Sim/Units/COB/CobInstance.cpp
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobInstance.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Units/COB/CobInstance.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -666,6 +666,7 @@
 			break;}
 		case 257:	//damaged unit smoke
 			SAFE_NEW CSmokeProjectile(pos,gu-&gt;usRandVector()*0.5f+UpVector*1.1f,60,4,0.5f,unit,0.5f);
+			// FIXME -- needs a 'break'?
 		case 258:		//damaged unit smoke
 			SAFE_NEW CSmokeProjectile(pos,gu-&gt;usRandVector()*0.5f+UpVector*1.1f,60,4,0.5f,unit,0.6f);
 			break;
@@ -1229,7 +1230,6 @@
 		const int weaponID = p1 - 1;
 		const int targetID = p2;
 		const bool userTarget = !!p3;
-		//logOutput.Print(&quot;SET_WEAPON_UNIT_TARGET: %i %i %i\n&quot;, weaponID, targetID, p3);		 // FIXME
 		if ((weaponID &lt; 0) || (weaponID &gt;= unit-&gt;weapons.size())) {
 			return 0;
 		}
@@ -1237,7 +1237,6 @@
 		if (weapon == NULL) { return 0; }
 		if ((targetID &lt; 0) || (targetID &gt;= MAX_UNITS)) { return 0; }
 		CUnit* target = (targetID == 0) ? NULL : uh-&gt;units[targetID];
-		//logOutput.Print(&quot;SET_WEAPON_UNIT_TARGET2\n&quot;);		 // FIXME
 		return weapon-&gt;AttackUnit(target, userTarget) ? 1 : 0;
 	}
 	case SET_WEAPON_GROUND_TARGET: {
@@ -1246,7 +1245,6 @@
 		                          float(p3) / float(COBSCALE),
 		                          float(UNPACKZ(p2)));
 		const bool userTarget = !!p4;
-		//logOutput.Print(&quot;SET_WEAPON_GROUND_TARGET: %i %f %f %f\n&quot;, weaponID, pos.x, pos.y, pos.z);//FIXME
 		if ((weaponID &lt; 0) || (weaponID &gt;= unit-&gt;weapons.size())) {
 			return 0;
 		}

Modified: branches/gml/rts/Sim/Units/Unit.cpp
===================================================================
--- branches/gml/rts/Sim/Units/Unit.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Units/Unit.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -330,7 +330,8 @@
 		losStatus[a] = 0;
 	}
 
-	losStatus[allyteam] = LOS_INTEAM | LOS_INLOS | LOS_INRADAR | LOS_PREVLOS | LOS_CONTRADAR;
+	losStatus[allyteam] = LOS_ALL_MASK_BITS |
+		LOS_INLOS | LOS_INRADAR | LOS_PREVLOS | LOS_CONTRADAR;
 
 	posErrorVector = gs-&gt;randVector();
 	posErrorVector.y *= 0.2f;
@@ -542,68 +543,77 @@
 }
 
 
-inline void CUnit::UpdateLosStatus(int at)
+void CUnit::SetLosStatus(int at, unsigned short newStatus)
 {
-	const int prevLosStatus = losStatus[at];
-	if ((prevLosStatus &amp; LOS_INTEAM) != 0) {
-		return; // allied -- no need to update
-	}
+	const unsigned short currStatus = losStatus[at];
+	const unsigned short diffBits = (currStatus ^ newStatus);
 
-	if (loshandler-&gt;InLos(this, at)) {
-		if ((prevLosStatus &amp; LOS_INLOS) == 0) {
-			// we were not previously in LOS for this allyteam
-			if (beingBuilt) {
-				// we are being built, do not set LOS_PREVLOS
-				// since we do not want ghosts for nanoframes
-				losStatus[at] |= (LOS_INLOS | LOS_INRADAR);
+	if (diffBits) {
+		if (diffBits &amp; LOS_INLOS) {
+			if (newStatus &amp; LOS_INLOS) {
+				luaCallIns.UnitEnteredLos(this, at);
+				globalAI-&gt;UnitEnteredLos(this, at);
 			} else {
-				losStatus[at] |= (LOS_INLOS | LOS_INRADAR | LOS_PREVLOS | LOS_CONTRADAR);
+				luaCallIns.UnitLeftLos(this, at);
+				globalAI-&gt;UnitLeftLos(this, at);
 			}
+		}	
 
-			if ((prevLosStatus &amp; LOS_INRADAR) == 0) {
+		if (diffBits &amp; LOS_INRADAR) {
+			if (newStatus &amp; LOS_INRADAR) {
 				luaCallIns.UnitEnteredRadar(this, at);
 				globalAI-&gt;UnitEnteredRadar(this, at);
+			} else {
+				luaCallIns.UnitLeftRadar(this, at);
+				globalAI-&gt;UnitLeftRadar(this, at);
 			}
-			luaCallIns.UnitEnteredLos(this, at);
-			globalAI-&gt;UnitEnteredLos(this, at);
+		}
+	}
+
+	losStatus[at] = newStatus;
+}
+
+
+unsigned short CUnit::CalcLosStatus(int at)
+{
+	const unsigned short currStatus = losStatus[at];
+
+	unsigned short newStatus = currStatus;
+	unsigned short mask = ~(currStatus &gt;&gt; 8);
+
+	if (loshandler-&gt;InLos(this, at)) {
+		if (!beingBuilt) {
+			newStatus |= (mask &amp; (LOS_INLOS   | LOS_INRADAR |
+			                      LOS_PREVLOS | LOS_CONTRADAR));
 		} else {
-			// if we were previously in LOS but still being built
-			// then LOS_PREVLOS and LOS_CONTRADAR weren't set for
-			// us yet, do so now
-			if (!beingBuilt) {
-				losStatus[at] |= (LOS_PREVLOS | LOS_CONTRADAR);
-			}
+			// we are being built, do not set LOS_PREVLOS
+			// since we do not want ghosts for nanoframes
+			newStatus |=  (mask &amp; (LOS_INLOS   | LOS_INRADAR));
+			newStatus &amp;= ~(mask &amp; (LOS_PREVLOS | LOS_CONTRADAR));
 		}
 	}
 	else if (radarhandler-&gt;InRadar(this, at)) {
-		if ((prevLosStatus &amp; LOS_INLOS) != 0) {
-			losStatus[at] &amp;= ~LOS_INLOS;
-			luaCallIns.UnitLeftLos(this, at);
-			globalAI-&gt;UnitLeftLos(this, at);
-		}
-		else if ((prevLosStatus &amp; LOS_INRADAR) == 0) {
-			losStatus[at] |= LOS_INRADAR;
-			luaCallIns.UnitEnteredRadar(this, at);
-			globalAI-&gt;UnitEnteredRadar(this, at);
-		}
+		newStatus |=  (mask &amp; LOS_INRADAR);
+		newStatus &amp;= ~(mask &amp; LOS_INLOS);
 	}
 	else {
-		if ((prevLosStatus &amp; LOS_INRADAR) != 0) {
-			losStatus[at] &amp;= ~(LOS_INLOS | LOS_INRADAR | LOS_CONTRADAR);
-			if ((prevLosStatus &amp; LOS_INLOS) != 0) {
-				luaCallIns.UnitLeftLos(this, at);
-				luaCallIns.UnitLeftRadar(this, at);
-				globalAI-&gt;UnitLeftLos(this, at);
-				globalAI-&gt;UnitLeftRadar(this, at);
-			} else {
-				luaCallIns.UnitLeftRadar(this, at);
-				globalAI-&gt;UnitLeftRadar(this, at);
-			}
-		}
+		newStatus &amp;= ~(mask &amp; (LOS_INLOS | LOS_INRADAR | LOS_CONTRADAR));
 	}
+
+	return newStatus;
 }
 
 
+inline void CUnit::UpdateLosStatus(int at)
+{
+	const unsigned short currStatus = losStatus[at];
+	if ((currStatus &amp; LOS_ALL_MASK_BITS) == LOS_ALL_MASK_BITS) {
+		return; // no need to update, all changes are masked
+	}
+	SetLosStatus(at, CalcLosStatus(at));
+}
+
+
 void CUnit::SlowUpdate()
 {
 	--nextPosErrorUpdate;
@@ -1173,13 +1183,14 @@
 	}
 }
 
-void CUnit::ChangeLos(int l,int airlos)
+
+void CUnit::ChangeLos(int l, int airlos)
 {
 	loshandler-&gt;FreeInstance(los);
 	los=0;
 	losRadius=l;
 	airLosRadius=airlos;
-	loshandler-&gt;MoveUnit(this,false);
+	loshandler-&gt;MoveUnit(this, false);
 }
 
 
@@ -1266,7 +1277,9 @@
 	neutral = false;
 
 	loshandler-&gt;MoveUnit(this,false);
-	losStatus[allyteam] = LOS_INTEAM | LOS_INLOS | LOS_INRADAR | LOS_PREVLOS | LOS_CONTRADAR;
+	losStatus[allyteam] = LOS_ALL_MASK_BITS |
+		LOS_INLOS | LOS_INRADAR | LOS_PREVLOS | LOS_CONTRADAR;
+
 	qf-&gt;MovedUnit(this);
 	if (hasRadarCapacity) {
 		radarhandler-&gt;MoveUnit(this);

Modified: branches/gml/rts/Sim/Units/Unit.h
===================================================================
--- branches/gml/rts/Sim/Units/Unit.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Units/Unit.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -41,10 +41,18 @@
 #define LOS_INRADAR    (1 &lt;&lt; 1)  // the unit is currently in radar from the allyteam
 #define LOS_PREVLOS    (1 &lt;&lt; 2)  // the unit has previously been in los from the allyteam
 #define LOS_CONTRADAR  (1 &lt;&lt; 3)  // the unit has continously been in radar since it was last inlos by the allyteam
-#define LOS_INTEAM     (1 &lt;&lt; 4)  // the unit is part of this allyteam
 
+// LOS mask bits  (masked bits are not automatically updated)
+#define LOS_INLOS_MASK     (1 &lt;&lt; 8)   // do not update LOS_INLOS
+#define LOS_INRADAR_MASK   (1 &lt;&lt; 9)   // do not update LOS_INRADAR
+#define LOS_PREVLOS_MASK   (1 &lt;&lt; 10)  // do not update LOS_PREVLOS
+#define LOS_CONTRADAR_MASK (1 &lt;&lt; 11)  // do not update LOS_CONTRADAR
 
-enum ScriptCloakBits {
+#define LOS_ALL_MASK_BITS \
+	(LOS_INLOS_MASK | LOS_INRADAR_MASK | LOS_PREVLOS_MASK | LOS_CONTRADAR_MASK)
+
+
+enum ScriptCloakBits { // FIXME -- not implemented
 	// always set to 0 if not enabled
 	SCRIPT_CLOAK_ENABLED          = (1 &lt;&lt; 0),
 	SCRIPT_CLOAK_IGNORE_ENERGY    = (1 &lt;&lt; 1),
@@ -74,7 +82,7 @@
 	                      const float3&amp; impulse, int weaponId = -1);
 	virtual void Kill(float3&amp; impulse);
 	virtual void FinishedBuilding(void);
-	void ChangeLos(int l,int airlos);
+	void ChangeLos(int l, int airlos);
 	bool AddBuildPower(float amount,CUnit* builder);		//negative amount=reclaim, return= true -&gt; build power was succesfully applied
 	void Activate();		//turn the unit on
 	void Deactivate();		//turn the unit off
@@ -124,6 +132,9 @@
 		return ((gs-&gt;useLuaGaia &amp;&amp; team == gs-&gt;gaiaTeamID) || (team == MAX_TEAMS - 1) || neutral);
 	}
 
+	void SetLosStatus(int allyTeam, unsigned short newStatus);
+	unsigned short CalcLosStatus(int allyTeam);
+
 	enum ChangeType{
 		ChangeGiven,
 		ChangeCaptured
@@ -183,7 +194,7 @@
 	int realLosRadius;				//set los to this when finished building
 	int realAirLosRadius;
 
-	int losStatus[MAX_TEAMS];	//indicate the los/radar status the allyteam has on this unit
+	unsigned short losStatus[MAX_TEAMS];	//indicate the los/radar status the allyteam has on this unit
 
 	bool inBuildStance;				//used by constructing unigs
 	bool stunned;							//if we are stunned by a weapon or for other reason

Modified: branches/gml/rts/Sim/Units/UnitDef.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitDef.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Units/UnitDef.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -8,6 +8,7 @@
 
 #include &quot;creg/creg.h&quot;
 #include &quot;float3.h&quot;
+#include &quot;Rendering/Icon.h&quot;
 
 struct MoveData;
 struct WeaponDef;
@@ -229,7 +230,7 @@
 	std::string TEDClassString;	//these might be changed later for something better
 	std::string categoryString;
 
-	std::string iconType;
+	mutable CIcon iconType;
 
 	bool canSelfD;
 	int selfDCountdown;

Modified: branches/gml/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitDefHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Units/UnitDefHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -18,18 +18,18 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
+#include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
 #include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Misc/DamageArrayHandler.h&quot;
-#include &quot;Sim/Misc/SensorHandler.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
 #include &quot;Sim/Projectiles/ExplosionGenerator.h&quot;
+#include &quot;Sim/Units/COB/CobFile.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Sound.h&quot;
-#include &quot;System/TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 
 const char YARDMAP_CHAR = 'c';		//Need to be low case.
@@ -139,7 +139,7 @@
 	numUnitDefs = (id - 1);
 
 	CleanBuildOptions();
-	FindCommanders();
+	FindStartUnits();
 	ProcessDecoys();
 	AssignTechLevels();
 }
@@ -220,32 +220,35 @@
 }
 
 
-void CUnitDefHandler::FindCommanders()
+void CUnitDefHandler::FindStartUnits()
 {
-	TdfParser tdfparser;
-	tdfparser.LoadFile(&quot;gamedata/SIDEDATA.TDF&quot;);
+	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+	                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!luaParser.Execute()) {
+		logOutput.Print(luaParser.GetErrorLog());
+	}
 
-	// get the commander UnitDef IDs
-	commanderIDs.clear();
-	std::vector&lt;std::string&gt; sides = tdfparser.GetSectionList(&quot;&quot;);
-	for (unsigned int i = 0; i &lt; sides.size(); i++){
-		const std::string&amp; section = sides[i];
-		if ((section.find(&quot;side&quot;) == 0) &amp;&amp;
-		    (section.find_first_not_of(&quot;0123456789&quot;, 4) == std::string::npos)) {
-			string commUnit = tdfparser.SGetValueDef(&quot;&quot;, section + &quot;\\COMMANDER&quot;);
-			StringToLowerInPlace(commUnit);
-			if (!commUnit.empty()) {
-				std::map&lt;std::string, int&gt;::iterator it = unitID.find(commUnit);
-				if (it != unitID.end()) {
-					commanderIDs.insert(it-&gt;second);
-				}
+	const LuaTable sideData = luaParser.GetRoot();
+	// get the startUnit UnitDef IDs
+	startUnitIDs.clear();
+	std::vector&lt;std::string&gt; sides;
+	for (int i = 1; true; i++) {
+		const LuaTable side = sideData.SubTable(i);
+		if (!side.IsValid()) {
+			break;
+		}
+		std::string startUnit = side.GetString(&quot;startUnit&quot;, &quot;&quot;);
+		StringToLowerInPlace(startUnit);
+		if (!startUnit.empty()) {
+			std::map&lt;std::string, int&gt;::iterator it = unitID.find(startUnit);
+			if (it != unitID.end()) {
+				startUnitIDs.insert(it-&gt;second);
 			}
 		}
 	}
 }
 
 
-
 void CUnitDefHandler::ParseTAUnit(const LuaTable&amp; udTable, const string&amp; unitName, int id)
 {
 	UnitDef&amp; ud = unitDefs[id];
@@ -321,12 +324,12 @@
 	ud.aihint = id; // FIXME? (as noted in SelectedUnits.cpp, aihint is ignored)
 	ud.cobID = udTable.GetInt(&quot;cobID&quot;, -1);
 
-	ud.losRadius = udTable.GetFloat(&quot;sightDistance&quot;, 0.0f) * sensorHandler-&gt;losMul / (SQUARE_SIZE * (1 &lt;&lt; sensorHandler-&gt;losMipLevel));
+	ud.losRadius = udTable.GetFloat(&quot;sightDistance&quot;, 0.0f) * modInfo.losMul / (SQUARE_SIZE * (1 &lt;&lt; modInfo.losMipLevel));
 	ud.airLosRadius = udTable.GetFloat(&quot;airSightDistance&quot;, -1.0f);
 	if (ud.airLosRadius == -1.0f) {
-		ud.airLosRadius=udTable.GetFloat(&quot;sightDistance&quot;, 0.0f) * sensorHandler-&gt;airLosMul * 1.5f / (SQUARE_SIZE * (1 &lt;&lt; sensorHandler-&gt;airMipLevel));
+		ud.airLosRadius=udTable.GetFloat(&quot;sightDistance&quot;, 0.0f) * modInfo.airLosMul * 1.5f / (SQUARE_SIZE * (1 &lt;&lt; modInfo.airMipLevel));
 	} else {
-		ud.airLosRadius = ud.airLosRadius * sensorHandler-&gt;airLosMul / (SQUARE_SIZE * (1 &lt;&lt; sensorHandler-&gt;airMipLevel));
+		ud.airLosRadius = ud.airLosRadius * modInfo.airLosMul / (SQUARE_SIZE * (1 &lt;&lt; modInfo.airMipLevel));
 	}
 
 	ud.moveType = 0;
@@ -517,7 +520,8 @@
 	ud.noChaseCategory = CCategoryHandler::Instance()-&gt;GetCategories(udTable.GetString(&quot;noChaseCategory&quot;, &quot;&quot;));
 //	logOutput.Print(&quot;Unit %s has cat %i&quot;,ud.humanName.c_str(),ud.category);
 
-	ud.iconType = udTable.GetString(&quot;iconType&quot;, &quot;default&quot;);
+	const string iconName = udTable.GetString(&quot;iconType&quot;, &quot;default&quot;);
+	ud.iconType = iconHandler-&gt;GetIcon(iconName);
 
 	ud.shieldWeaponDef    = NULL;
 	ud.stockpileWeaponDef = NULL;
@@ -527,7 +531,7 @@
 	const WeaponDef* noWeaponDef = weaponDefHandler-&gt;GetWeapon(&quot;NOWEAPON&quot;);
 
 	LuaTable weaponsTable = udTable.SubTable(&quot;weapons&quot;);
-	for (int w = 0; w &lt; 16; w++) {
+	for (int w = 0; w &lt; COB_MaxWeapons; w++) {
 		LuaTable wTable;
 		string name = weaponsTable.GetString(w + 1, &quot;&quot;);
 		if (name.empty()) {
@@ -1020,7 +1024,7 @@
 void CUnitDefHandler::AssignTechLevels()
 {
 	set&lt;int&gt;::iterator it;
-	for (it = commanderIDs.begin(); it != commanderIDs.end(); ++it) {
+	for (it = startUnitIDs.begin(); it != startUnitIDs.end(); ++it) {
 		AssignTechLevel(unitDefs[*it], 0);
 	}
 }

Modified: branches/gml/rts/Sim/Units/UnitDefHandler.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitDefHandler.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Units/UnitDefHandler.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -28,7 +28,7 @@
 	int numUnitDefs;
 	std::map&lt;std::string, int&gt; unitID;
 	std::map&lt;int, std::set&lt;int&gt; &gt; decoyMap;
-	std::set&lt;int&gt; commanderIDs;
+	std::set&lt;int&gt; startUnitIDs;
 
 	CUnitDefHandler(void);
 	~CUnitDefHandler(void);
@@ -51,7 +51,7 @@
 
 	void CleanBuildOptions();
 
-	void FindCommanders();
+	void FindStartUnits();
 
 	void AssignTechLevel(UnitDef&amp; ud, int level);
 

Modified: branches/gml/rts/Sim/Weapons/WeaponDefHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -605,6 +605,9 @@
 			}
 		}
 	}
+
+	// custom parameters table
+	wdTable.SubTable(&quot;customParams&quot;).GetMap(wd.customParams);
 }
 
 

Modified: branches/gml/rts/Sim/Weapons/WeaponDefHandler.h
===================================================================
--- branches/gml/rts/Sim/Weapons/WeaponDefHandler.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/Sim/Weapons/WeaponDefHandler.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -224,6 +224,8 @@
 	float dynDamageMin;
 	float dynDamageRange;
 	bool dynDamageInverted;
+
+	std::map&lt;std::string, std::string&gt; customParams;
 };
 
 

Modified: branches/gml/rts/System/AutohostInterface.h
===================================================================
--- branches/gml/rts/System/AutohostInterface.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/AutohostInterface.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -39,7 +39,7 @@
 	void Warning(const std::string&amp; message);
 	
 	/**
-	@brief Recieve a chat message from the autohost
+	@brief Receive a chat message from the autohost
 	There should be only 1 message per UDP-Packet, and it will use the hosts playernumber to inject this message
 	*/
 	std::string GetChatMessage() const;

Modified: branches/gml/rts/System/BaseNetProtocol.cpp
===================================================================
--- branches/gml/rts/System/BaseNetProtocol.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/BaseNetProtocol.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -59,95 +59,96 @@
 	SendQuit();
 }
 
-void CBaseNetProtocol::RawSend(const uchar* data, const unsigned length)
-{
-	SendData(data, length);
-}
-
 void CBaseNetProtocol::SendKeyFrame(int frameNum)
 {
-	SendData&lt;int&gt;(NETMSG_KEYFRAME, frameNum);
+	PackPacket* packet = new PackPacket(5, NETMSG_KEYFRAME);
+	*packet &lt;&lt; frameNum;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendNewFrame()
 {
-	unsigned char msg = NETMSG_NEWFRAME;
-	SendData(&amp;msg, 1);
+	SendData(new PackPacket(1, NETMSG_NEWFRAME));
 }
 
 
 void CBaseNetProtocol::SendQuit()
 {
-	SendData(NETMSG_QUIT);
+	SendData(new PackPacket(1, NETMSG_QUIT));
 }
 
 void CBaseNetProtocol::SendQuit(unsigned playerNum)
 {
-	unsigned char a = NETMSG_QUIT;
-	SendData(&amp;a, 1, playerNum);
+	SendData(new PackPacket(5, NETMSG_QUIT), playerNum);
 }
 
 void CBaseNetProtocol::SendStartPlaying(unsigned countdown)
 {
-	SendData&lt;unsigned&gt;(NETMSG_STARTPLAYING, countdown);
+	PackPacket* packet = new PackPacket(5, NETMSG_STARTPLAYING);
+	*packet &lt;&lt; countdown;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendSetPlayerNum(uchar myPlayerNum, uchar connNumber)
 {
-	uchar msg[2] = {NETMSG_SETPLAYERNUM, myPlayerNum};
-	SendData(msg, 2, connNumber);
+	PackPacket* packet = new PackPacket(2, NETMSG_SETPLAYERNUM);
+	*packet &lt;&lt; myPlayerNum;
+	SendData(packet, connNumber);
 }
 
 void CBaseNetProtocol::SendPlayerName(uchar myPlayerNum, const std::string&amp; playerName)
 {
 	unsigned size = 3 + playerName.size() + 1;
-	PackPacket* packet = new PackPacket(size);
-	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_PLAYERNAME) &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; playerName;
+	PackPacket* packet = new PackPacket(size, NETMSG_PLAYERNAME);
+	*packet &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; playerName;
 	SendData(packet);
 }
 
-void CBaseNetProtocol::SendRandSeed(uint randSeed)
+void CBaseNetProtocol::SendRandSeed(unsigned randSeed)
 {
-	SendData&lt;uint&gt;(NETMSG_RANDSEED, randSeed);
+	PackPacket* packet = new PackPacket(5, NETMSG_RANDSEED);
+	*packet &lt;&lt; randSeed;
+	SendData(packet);
 }
 
-void CBaseNetProtocol::SendRandSeed(uint randSeed, int toPlayer)
+void CBaseNetProtocol::SendRandSeed(unsigned randSeed, int toPlayer)
 {
-	uchar data[5] = {NETMSG_RANDSEED};
-	*(int*)(data + 1) = randSeed;
-	SendData(data, 5, toPlayer);
+	PackPacket* packet = new PackPacket(5, NETMSG_RANDSEED);
+	*packet &lt;&lt; randSeed;
+	SendData(packet, toPlayer);
 }
 
 // NETMSG_GAMEID = 9, char gameID[16];
 void CBaseNetProtocol::SendGameID(const uchar* buf)
 {
-	uchar data[17];
-	data[0] = NETMSG_GAMEID;
-	memcpy(&amp;data[1], buf, 16);
-	SendData(data, 17);
+	PackPacket* packet = new PackPacket(17, NETMSG_GAMEID);
+	memcpy(packet-&gt;GetWritingPos(), buf, 16);
+	SendData(packet);
 }
 
 
 void CBaseNetProtocol::SendCommand(uchar myPlayerNum, int id, uchar options, const std::vector&lt;float&gt;&amp; params)
 {
 	unsigned size = 9 + params.size() * sizeof(float);
-	PackPacket* packet = new PackPacket(size);
-	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_COMMAND) &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; id &lt;&lt; options &lt;&lt; params;
+	PackPacket* packet = new PackPacket(size, NETMSG_COMMAND);
+	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; id &lt;&lt; options &lt;&lt; params;
 	SendData(packet);
 }
 
 void CBaseNetProtocol::SendSelect(uchar myPlayerNum, const std::vector&lt;short&gt;&amp; selectedUnitIDs)
 {
 	unsigned size = 4 + selectedUnitIDs.size() * sizeof(short);
-	PackPacket* packet = new PackPacket(size);
-	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_SELECT) &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; selectedUnitIDs;
+	PackPacket* packet = new PackPacket(size, NETMSG_SELECT);
+	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; selectedUnitIDs;
 	SendData(packet);
 }
 
 
 void CBaseNetProtocol::SendPause(uchar myPlayerNum, uchar bPaused)
 {
-	SendData&lt;uchar, uchar&gt;(NETMSG_PAUSE, myPlayerNum, bPaused);
+	PackPacket* packet = new PackPacket(3, NETMSG_PAUSE);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; bPaused;
+	SendData(packet);
 }
 
 
@@ -155,197 +156,215 @@
 void CBaseNetProtocol::SendAICommand(uchar myPlayerNum, short unitID, int id, uchar options, const std::vector&lt;float&gt;&amp; params)
 {
 	unsigned size = 11 + params.size() * sizeof(float);
-	PackPacket* packet = new PackPacket(size);
-	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_AICOMMAND) &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; unitID &lt;&lt; id &lt;&lt; options &lt;&lt; params;
+	PackPacket* packet = new PackPacket(size, NETMSG_AICOMMAND);
+	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; unitID &lt;&lt; id &lt;&lt; options &lt;&lt; params;
 	SendData(packet);
 }
 
-void CBaseNetProtocol::SendAICommands(uchar myPlayerNum, short unitIDCount, ...)
-{
-	// FIXME: needs special care; sits in CSelectedUnits::SendCommandsToUnits().
-}
-
 void CBaseNetProtocol::SendAIShare(uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, const std::vector&lt;short&gt;&amp; unitIDs)
 {
 	short totalNumBytes = (1 + sizeof(short)) + (3 + (2 * sizeof(float)) + (unitIDs.size() * sizeof(short)));
 
-	PackPacket* packet = new PackPacket(totalNumBytes);
-	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_AISHARE) &lt;&lt; totalNumBytes &lt;&lt; myPlayerNum &lt;&lt; sourceTeam &lt;&lt; destTeam &lt;&lt; metal &lt;&lt; energy &lt;&lt; unitIDs;
+	PackPacket* packet = new PackPacket(totalNumBytes, NETMSG_AISHARE);
+	*packet &lt;&lt; totalNumBytes &lt;&lt; myPlayerNum &lt;&lt; sourceTeam &lt;&lt; destTeam &lt;&lt; metal &lt;&lt; energy &lt;&lt; unitIDs;
 	SendData(packet);
 }
 
-
-
 void CBaseNetProtocol::SendUserSpeed(uchar myPlayerNum, float userSpeed)
 {
-	SendData&lt;uchar, float&gt; (NETMSG_USER_SPEED, myPlayerNum, userSpeed);
+	PackPacket* packet = new PackPacket(6, NETMSG_USER_SPEED);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; userSpeed;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendInternalSpeed(float internalSpeed)
 {
-	SendData&lt;float&gt; (NETMSG_INTERNAL_SPEED, internalSpeed);
+	PackPacket* packet = new PackPacket(5, NETMSG_INTERNAL_SPEED);
+	*packet &lt;&lt; internalSpeed;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendCPUUsage(float cpuUsage)
 {
-	SendData&lt;float&gt; (NETMSG_CPU_USAGE, cpuUsage);
+	PackPacket* packet = new PackPacket(5, NETMSG_CPU_USAGE);
+	*packet &lt;&lt; cpuUsage;
+	SendData(packet);
 }
 
 
 void CBaseNetProtocol::SendDirectControl(uchar myPlayerNum)
 {
-	SendData&lt;uchar&gt; (NETMSG_DIRECT_CONTROL, myPlayerNum);
+	PackPacket* packet = new PackPacket(2, NETMSG_DIRECT_CONTROL);
+	*packet &lt;&lt; myPlayerNum;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendDirectControlUpdate(uchar myPlayerNum, uchar status, short heading, short pitch)
 {
-	SendData&lt;uchar, uchar, short, short&gt; (NETMSG_DC_UPDATE, myPlayerNum, status, heading, pitch);
+	PackPacket* packet = new PackPacket(7, NETMSG_DC_UPDATE);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; status &lt;&lt; heading &lt;&lt; pitch;
+	SendData(packet);
 }
 
 
 void CBaseNetProtocol::SendAttemptConnect(uchar myPlayerNum, uchar networkVersion)
 {
-	SendData&lt;uchar, uchar&gt; (NETMSG_ATTEMPTCONNECT, myPlayerNum, networkVersion);
+	PackPacket* packet = new PackPacket(3, NETMSG_ATTEMPTCONNECT);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; networkVersion;
+	SendData(packet);
 }
 
 
 void CBaseNetProtocol::SendShare(uchar myPlayerNum, uchar shareTeam, uchar bShareUnits, float shareMetal, float shareEnergy)
 {
-	SendData&lt;uchar, uchar, uchar, float, float&gt; (NETMSG_SHARE, myPlayerNum, shareTeam, bShareUnits, shareMetal, shareEnergy);
+	PackPacket* packet = new PackPacket(12, NETMSG_SHARE);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; shareTeam &lt;&lt; bShareUnits &lt;&lt; shareMetal &lt;&lt; shareEnergy;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendSetShare(uchar myPlayerNum, uchar myTeam, float metalShareFraction, float energyShareFraction)
 {
-	SendData&lt;uchar, uchar, float, float&gt;(NETMSG_SETSHARE, myPlayerNum, myTeam, metalShareFraction, energyShareFraction);
+	PackPacket* packet = new PackPacket(11, NETMSG_SETSHARE);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; myTeam &lt;&lt; metalShareFraction &lt;&lt; energyShareFraction;
+	SendData(packet);
 }
 
 
 void CBaseNetProtocol::SendSendPlayerStat()
 {
-	SendData(NETMSG_SENDPLAYERSTAT);
+	SendData(new PackPacket(1, NETMSG_SENDPLAYERSTAT));
 }
 
 void CBaseNetProtocol::SendPlayerStat(uchar myPlayerNum, const CPlayer::Statistics&amp; currentStats)
 {
-	SendData&lt;uchar, CPlayer::Statistics&gt;(NETMSG_PLAYERSTAT, myPlayerNum, currentStats);
+	PackPacket* packet = new PackPacket(2 + sizeof(CPlayer::Statistics), NETMSG_PLAYERSTAT);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; currentStats;
+	SendData(packet);
 }
 
-
 void CBaseNetProtocol::SendGameOver()
 {
-	SendData(NETMSG_GAMEOVER);
+	SendData(new PackPacket(1, NETMSG_GAMEOVER));
 }
 
-
-
 // NETMSG_MAPDRAW = 31, uchar messageSize =  8, myPlayerNum, command = CInMapDraw::NET_ERASE; short x, z;
 void CBaseNetProtocol::SendMapErase(uchar myPlayerNum, short x, short z)
 {
-	SendData&lt;uchar, uchar, uchar, short, short&gt;(NETMSG_MAPDRAW, 8, myPlayerNum, CInMapDraw::NET_ERASE, x, z);
+	PackPacket* packet = new PackPacket(8, NETMSG_MAPDRAW);
+	*packet &lt;&lt; static_cast&lt;uchar&gt;(8) &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(CInMapDraw::NET_ERASE) &lt;&lt; x &lt;&lt; z;
+	SendData(packet);
 }
 
 // NETMSG_MAPDRAW = 31, uchar messageSize = 12, myPlayerNum, command = CInMapDraw::NET_LINE; short x1, z1, x2, z2;
 void CBaseNetProtocol::SendMapDrawLine(uchar myPlayerNum, short x1, short z1, short x2, short z2)
 {
-	SendData&lt;uchar, uchar, uchar, short, short, short, short&gt;(NETMSG_MAPDRAW, 12, myPlayerNum, CInMapDraw::NET_LINE, x1, z1, x2, z2);
+	PackPacket* packet = new PackPacket(12, NETMSG_MAPDRAW);
+	*packet &lt;&lt; static_cast&lt;uchar&gt;(12) &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(CInMapDraw::NET_LINE) &lt;&lt; x1 &lt;&lt; z1 &lt;&lt; x2 &lt;&lt; z2;
+	SendData(packet);
 }
 
 // NETMSG_MAPDRAW = 31, uchar messageSize, uchar myPlayerNum, command = CInMapDraw::NET_POINT; short x, z; std::string label;
 void CBaseNetProtocol::SendMapDrawPoint(uchar myPlayerNum, short x, short z, const std::string&amp; label)
 {
 	unsigned size = 8 + label.size() + 1;
-	PackPacket* packet = new PackPacket(size);
-	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_MAPDRAW) &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(CInMapDraw::NET_POINT) &lt;&lt; x &lt;&lt; z &lt;&lt; label;
+	PackPacket* packet = new PackPacket(size, NETMSG_MAPDRAW);
+	*packet &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(CInMapDraw::NET_POINT) &lt;&lt; x &lt;&lt; z &lt;&lt; label;
 	SendData(packet);
 }
 
-
-
 void CBaseNetProtocol::SendSyncRequest(int frameNum)
 {
-	SendData&lt;int&gt;(NETMSG_SYNCREQUEST, frameNum);
+	PackPacket* packet = new PackPacket(5, NETMSG_SYNCREQUEST);
+	*packet &lt;&lt; frameNum;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendSyncResponse(uchar myPlayerNum, int frameNum, uint checksum)
 {
-	SendData&lt;uchar, int, uint&gt;(NETMSG_SYNCRESPONSE, myPlayerNum, frameNum, checksum);
+	PackPacket* packet = new PackPacket(10, NETMSG_SYNCRESPONSE);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; frameNum &lt;&lt; checksum;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendSystemMessage(uchar myPlayerNum, const std::string&amp; message)
 {
 	unsigned size = 3 + message.size() + 1;
-	PackPacket* packet = new PackPacket(size);
-	*packet &lt;&lt; static_cast&lt;uchar&gt;(NETMSG_SYSTEMMSG) &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; message;
+	PackPacket* packet = new PackPacket(size, NETMSG_SYSTEMMSG);
+	*packet &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; message;
 	SendData(packet);
 }
 
 void CBaseNetProtocol::SendStartPos(uchar myPlayerNum, uchar teamNum, uchar ready, float x, float y, float z)
 {
-	SendData&lt;uchar, uchar, uchar, float, float, float&gt;(NETMSG_STARTPOS, myPlayerNum, teamNum, ready, x, y, z);
+	PackPacket* packet = new PackPacket(16, NETMSG_STARTPOS);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; teamNum &lt;&lt; ready &lt;&lt; x &lt;&lt; y &lt;&lt; z;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendPlayerInfo(uchar myPlayerNum, float cpuUsage, int ping)
 {
-	SendData&lt;uchar, float, int&gt;(NETMSG_PLAYERINFO, myPlayerNum, cpuUsage, ping);
+	PackPacket* packet = new PackPacket(10, NETMSG_PLAYERINFO);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; cpuUsage &lt;&lt; ping;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendPlayerLeft(uchar myPlayerNum, uchar bIntended)
 {
-	SendData&lt;uchar, uchar&gt;(NETMSG_PLAYERLEFT, myPlayerNum, bIntended);
+	PackPacket* packet = new PackPacket(3, NETMSG_PLAYERLEFT);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; bIntended;
+	SendData(packet);
 }
 
 // NETMSG_LUAMSG = 50, uchar myPlayerNum; std::string modName; (e.g. `custom msg')
 void CBaseNetProtocol::SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode,
                                   const std::string&amp; msg)
 {
-	// avoid the trailing '\0' processing
-	const unsigned short msgLen = msg.size() + 6;
-	const char* msgPtr = (char*) &msgLen;
-	std::string data;
-	data.push_back((char)NETMSG_LUAMSG);
-	data.push_back(msgPtr[0]);
-	data.push_back(msgPtr[1]);
-	data.push_back(myPlayerNum);
-	data.push_back(script);
-	data.push_back(mode);
-	data.append(msg);
-	SendData((const unsigned char*) data.data(), msgLen);
+	unsigned short size = 6 + msg.size()+1;
+	PackPacket* packet = new PackPacket(size, NETMSG_LUAMSG);
+	*packet &lt;&lt; size &lt;&lt; myPlayerNum &lt;&lt; script &lt;&lt; mode &lt;&lt; msg;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendSelfD(uchar myPlayerNum)
 {
-	unsigned char msg[4] = {NETMSG_TEAM, myPlayerNum, TEAMMSG_SELFD, 0};
-	SendData(msg, 4);
+	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_SELFD) &lt;&lt; static_cast&lt;uchar&gt;(0);
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendGiveAwayEverything(uchar myPlayerNum, uchar giveTo)
 {
-	unsigned char msg[4] = {NETMSG_TEAM, myPlayerNum, TEAMMSG_GIVEAWAY, giveTo};
-	SendData(msg, 4);
+	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_GIVEAWAY) &lt;&lt; giveTo;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendResign(uchar myPlayerNum)
 {
-	unsigned char msg[4] = {NETMSG_TEAM, myPlayerNum, TEAMMSG_RESIGN, 0};
-	SendData(msg, 4);
+	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_RESIGN) &lt;&lt; static_cast&lt;uchar&gt;(0);
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendJoinTeam(uchar myPlayerNum, uchar wantedTeamNum)
 {
-	unsigned char msg[4] = {NETMSG_TEAM, myPlayerNum, TEAMMSG_JOIN_TEAM, wantedTeamNum};
-	SendData(msg, 4);
+	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_JOIN_TEAM) &lt;&lt; wantedTeamNum;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendTeamDied(uchar myPlayerNum, uchar whichTeam)
 {
-	unsigned char msg[4] = {NETMSG_TEAM, myPlayerNum, TEAMMSG_TEAM_DIED, whichTeam};
-	SendData(msg, 4);
+	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_TEAM_DIED) &lt;&lt; whichTeam;
+	SendData(packet);
 }
 
 void CBaseNetProtocol::SendSetAllied(uchar myPlayerNum, uchar whichAllyTeam, uchar state)
 {
-	unsigned char msg[4] = {NETMSG_ALLIANCE, myPlayerNum, whichAllyTeam, state};
-	SendData(msg, 4);
+	PackPacket* packet = new PackPacket(4, NETMSG_ALLIANCE);
+	*packet &lt;&lt; myPlayerNum &lt;&lt; whichAllyTeam &lt;&lt; state;
+	SendData(packet);
 }
 
 /* FIXME: add these:

Modified: branches/gml/rts/System/BaseNetProtocol.h
===================================================================
--- branches/gml/rts/System/BaseNetProtocol.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/BaseNetProtocol.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -102,13 +102,6 @@
 	CBaseNetProtocol();
 	~CBaseNetProtocol();
 
-	/**
-	@brief  Broadcast raw data to all clients
-	Should not be used. Use Send*(...) instead, only redirects to CNet::SendData(char*, int);
-	@todo make everything use the Send* functions
-	*/
-	void RawSend(const uchar* data,const unsigned length);
-
 	void SendKeyFrame(int frameNum);
 	void SendNewFrame();
 	void SendQuit();
@@ -124,7 +117,6 @@
 	void SendPause(uchar myPlayerNum, uchar bPaused);
 
 	void SendAICommand(uchar myPlayerNum, short unitID, int id, uchar options, const std::vector&lt;float&gt;&amp; params);
-	void SendAICommands(uchar myPlayerNum, short unitIDCount, ...);
 	void SendAIShare(uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, const std::vector&lt;short&gt;&amp; unitIDs);
 
 	void SendUserSpeed(uchar myPlayerNum, float userSpeed);

Modified: branches/gml/rts/System/FileSystem/Archive7Zip.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/Archive7Zip.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/FileSystem/Archive7Zip.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -102,21 +102,18 @@
 	FileData fd = fileData[fileName];
 
 	// Get 7zip to decompress it
-    size_t offset;
-    size_t outSizeProcessed;
+	size_t offset;
+	size_t outSizeProcessed;
 	
 	SZ_RESULT res;
 
 	// We don't really support solid archives anyway, so these can be reset for each file
-    UInt32 blockIndex = 0xFFFFFFFF; // it can have any value before first call (if outBuffer = 0) 
-    Byte *outBuffer = 0; // it must be 0 before first call for each new archive. 
-    size_t outBufferSize = 0;  // it can have any value before first call (if outBuffer = 0) 
+	UInt32 blockIndex = 0xFFFFFFFF; // it can have any value before first call (if outBuffer = 0) 
+	Byte *outBuffer = 0; // it must be 0 before first call for each new archive. 
+	size_t outBufferSize = 0;  // it can have any value before first call (if outBuffer = 0) 
 
-    res = SzExtract(&amp;archiveStream.InStream, &amp;db, fd.fp, 
-        &amp;blockIndex, &amp;outBuffer, &amp;outBufferSize, 
-        &amp;offset, &amp;outSizeProcessed, 
-        &amp;allocImp, &amp;allocTempImp);
-    	
+	res = SzExtract(&amp;archiveStream.InStream, &amp;db, fd.fp, &amp;blockIndex, &amp;outBuffer, &amp;outBufferSize, &amp;offset, &amp;outSizeProcessed, &amp;allocImp, &amp;allocTempImp);
+
 	ABOpenFile_t* of = NULL;
 	if (res == SZ_OK) {
 		of = SAFE_NEW ABOpenFile_t;

Modified: branches/gml/rts/System/FileSystem/CRC.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/CRC.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/FileSystem/CRC.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -5,9 +5,16 @@
 };
 
 
+static bool crcTableInitialized;
+
+
 /** @brief Construct a new CRC object. */
 CRC::CRC()
 {
+	if (!crcTableInitialized) {
+		crcTableInitialized = true;
+		InitCrcTable();
+	}
 	CrcInit(&amp;crc);
 }
 

Modified: branches/gml/rts/System/FileSystem/FileHandler.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/FileHandler.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/FileSystem/FileHandler.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -335,7 +335,7 @@
 	for (it = dirSet.begin(); it != dirSet.end(); ++it) {
 		dirVec.push_back(*it);
 	}
-	return dirVec;	
+	return dirVec;
 }
 
 

Modified: branches/gml/rts/System/Messages.cpp
===================================================================
--- branches/gml/rts/System/Messages.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Messages.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -5,14 +5,24 @@
 #include &lt;assert.h&gt;
 #include &lt;locale&gt;
 #include &lt;cctype&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;map&gt;
 #include &quot;GlobalStuff.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Messages.h&quot;
-#include &quot;TdfParser.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
+using std::string;
+using std::vector;
+using std::map;
+
+
 CMessages::CMessages(): loaded(false) {}
 
+
 /** Return a pointer to the single instance of CMessages. */
 CMessages* CMessages::GetInstance()
 {
@@ -20,46 +30,66 @@
 	return &instance;
 }
 
+
 /** Load the messages from gamedata/messages.tdf into memory. */
 void CMessages::Load()
 {
-	try {
-		TdfParser tdfparser(&quot;gamedata/messages.tdf&quot;);
-		// Grab a list of messages.  Each message is one section.
-		std::vector&lt;std::string&gt; section_list = tdfparser.GetSectionList(&quot;messages&quot;);
-		// Load the possible translations for every message.
-		for (std::vector&lt;std::string&gt;::const_iterator sit = section_list.begin(); sit != section_list.end(); ++sit) {
-			const std::map&lt;std::string, std::string&gt;&amp; allvalues = tdfparser.GetAllValues(&quot;messages\\&quot; + *sit);
-			for (std::map&lt;std::string, std::string&gt;::const_iterator it = allvalues.begin(); it != allvalues.end(); ++it) {
-				tr[*sit].push_back(it-&gt;second);
+	LuaParser luaParser(&quot;gamedata/messages.lua&quot;,
+	                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!luaParser.Execute()) {
+		// Show parse errors in the infolog.
+		logOutput.Print(string(&quot;ERROR: messages.lua: &quot;) + luaParser.GetErrorLog());
+		return;
+	}
+
+	const LuaTable root = luaParser.GetRoot();
+
+	vector&lt;string&gt; labels;
+	root.GetKeys(labels);
+
+	for (int i = 0; i &lt; labels.size(); i++) {
+		const string label = StringToLower(labels[i]);
+		const LuaTable msgTable = root.SubTable(label);
+		if (!msgTable.IsValid()) {
+			continue;
+		}
+		vector&lt;string&gt; msgs;
+		for (int i = 1; true; i++) {
+			const string msg = msgTable.GetString(i, &quot;&quot;);
+			if (msg.empty()) {
+				break;
 			}
+			msgs.push_back(msg);
 		}
-	} catch (const TdfParser::parse_error&amp; e) {
-		// Show parse errors in the infolog.
-		logOutput.Print(&quot;%s:%d: %s&quot;, e.get_filename().c_str(), e.get_line(), e.what());
-	} catch (const content_error&amp;) {
-		// Ignore non-existant file.
+		if (!msgs.empty()) {
+			tr[label] = msgs;
+		}
 	}
+		
 	loaded = true;
 }
 
+
 /** Translate \p msg. If multiple messages are available it picks one at random.
 Returns \p msg if no messages are available. */
-std::string CMessages::Translate(const std::string&amp; msg) const
+string CMessages::Translate(const string&amp; msg) const
 {
-	// TdfParser puts everything in lowercase.
-	std::string lowerd = StringToLower(msg);
-	message_map_t::const_iterator it = tr.find(lowerd);
-	if (it == tr.end())
+	// all keys are lowercase
+	const string lower = StringToLower(msg);
+	message_map_t::const_iterator it = tr.find(lower);
+	if (it == tr.end()) {
 		return msg;
+	}
 	return Pick(it-&gt;second);
 }
 
+
 /** Returns a message from \p vec at random. */
-std::string CMessages::Pick(const message_list_t&amp; vec) const
+string CMessages::Pick(const message_list_t&amp; vec) const
 {
 	assert(!vec.empty());
-	if (vec.size() == 1)
+	if (vec.size() == 1) {
 		return vec[0];
+	}
 	return vec[gu-&gt;usRandInt() % vec.size()];
 }

Modified: branches/gml/rts/System/Messages.h
===================================================================
--- branches/gml/rts/System/Messages.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Messages.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -28,8 +28,9 @@
 public:
 	static inline std::string Tr(const std::string&amp; msg) {
 		CMessages* inst = GetInstance();
-		if (!inst-&gt;loaded)
+		if (!inst-&gt;loaded) {
 			inst-&gt;Load();
+		}
 		return inst-&gt;Translate(msg);
 	}
 };

Modified: branches/gml/rts/System/Net/Connection.cpp
===================================================================
--- branches/gml/rts/System/Net/Connection.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/Connection.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -12,7 +12,7 @@
 {
 }
 
-unsigned CConnection::GetDataRecieved() const
+unsigned CConnection::GetDataReceived() const
 {
 	return dataRecv;
 }

Modified: branches/gml/rts/System/Net/Connection.h
===================================================================
--- branches/gml/rts/System/Net/Connection.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/Connection.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -2,6 +2,7 @@
 #define CONNECTION_H
 
 #include &lt;string&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
 
 #include &quot;RawPacket.h&quot;
 
@@ -25,27 +26,26 @@
 	CConnection();
 	virtual ~CConnection();
 	
-	virtual void SendData(const unsigned char *data, const unsigned length)=0;
-	virtual void SendData(const RawPacket* data)=0;
+	virtual void SendData(boost::shared_ptr&lt;const RawPacket&gt; data)=0;
 
 	/**
 	@brief Take a look at the messages that will be returned by GetData().
 	@return A RawPacket holding the data, or 0 if no data
 	@param ahead How many packets to look ahead. A typical usage would be:
-	for (int ahead = 0; (packet = conn-&gt;Peek(ahead)) != NULL; ++ahead) {}
+	for (int ahead = 0; (packet = conn-&gt;Peek(ahead)); ++ahead) {}
 	*/
-	virtual const RawPacket* Peek(unsigned ahead) const = 0;
+	virtual boost::shared_ptr&lt;const RawPacket&gt; Peek(unsigned ahead) const = 0;
 	
 	/**
 	@brief New method of data gathering
 	@return A RawPacket holding the data, or 0 if no data
 	*/
-	virtual RawPacket* GetData()=0;
+	virtual boost::shared_ptr&lt;const RawPacket&gt; GetData()=0;
 
 	virtual void Flush(const bool forced = false)=0;
 	virtual bool CheckTimeout() const = 0;
 	
-	unsigned GetDataRecieved() const;
+	unsigned GetDataReceived() const;
 	
 	virtual std::string Statistics() const = 0;
 	virtual NetAddress GetPeerName() const = 0;

Modified: branches/gml/rts/System/Net/LocalConnection.cpp
===================================================================
--- branches/gml/rts/System/Net/LocalConnection.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/LocalConnection.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -9,7 +9,7 @@
 
 // static stuff
 unsigned CLocalConnection::Instances = 0;
-CLocalConnection::MsgQueue CLocalConnection::Data[2];
+std::deque&lt; boost::shared_ptr&lt;const RawPacket&gt; &gt; CLocalConnection::Data[2];
 boost::mutex CLocalConnection::Mutex[2];
 
 CLocalConnection::CLocalConnection()
@@ -25,48 +25,44 @@
 CLocalConnection::~CLocalConnection()
 {
 	Instances--;
-	while (!Data[instance].empty())
-	{
-		delete Data[instance].front();
-		Data[instance].pop_front();
-	}
 }
 
-void CLocalConnection::SendData(const unsigned char *data, const unsigned length)
+void CLocalConnection::SendData(boost::shared_ptr&lt;const RawPacket&gt; data)
 {
-	SendData(new RawPacket(data, length));
-}
-
-void CLocalConnection::SendData(const RawPacket* data)
-{
 	dataSent += data-&gt;length;
 	boost::mutex::scoped_lock scoped_lock(Mutex[OtherInstance()]);
 	Data[OtherInstance()].push_back(data);
 }
 
-const RawPacket* CLocalConnection::Peek(unsigned ahead) const
+boost::shared_ptr&lt;const RawPacket&gt; CLocalConnection::Peek(unsigned ahead) const
 {
 	boost::mutex::scoped_lock scoped_lock(Mutex[instance]);
 
 	if (ahead &lt; Data[instance].size())
 		return Data[instance][ahead];
-
-	return NULL;
+	else
+	{
+		boost::shared_ptr&lt;const RawPacket&gt; empty;
+		return empty;
+	}
 }
 
-RawPacket* CLocalConnection::GetData()
+boost::shared_ptr&lt;const RawPacket&gt; CLocalConnection::GetData()
 {
 	boost::mutex::scoped_lock scoped_lock(Mutex[instance]);
 	
 	if (!Data[instance].empty())
 	{
-		const RawPacket* next = Data[instance].front();
+		boost::shared_ptr&lt;const RawPacket&gt; next = Data[instance].front();
 		Data[instance].pop_front();
 		dataRecv += next-&gt;length;
-		return const_cast&lt;RawPacket*&gt;(next);
+		return next;
 	}
 	else
-		return NULL;
+	{
+		boost::shared_ptr&lt;const RawPacket&gt; empty;
+		return empty;
+	}
 }
 
 void CLocalConnection::Flush(const bool forced)
@@ -81,7 +77,7 @@
 std::string CLocalConnection::Statistics() const
 {
 	std::string msg = &quot;Statistics for local connection:\n&quot;;
-	msg += str( boost::format(&quot;Recieved: %1% bytes\n&quot;) %dataRecv );
+	msg += str( boost::format(&quot;Received: %1% bytes\n&quot;) %dataRecv );
 	msg += str( boost::format(&quot;Sent: %1% bytes\n&quot;) %dataSent );
 	return msg;
 }

Modified: branches/gml/rts/System/Net/LocalConnection.h
===================================================================
--- branches/gml/rts/System/Net/LocalConnection.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/LocalConnection.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -25,23 +25,18 @@
 	virtual ~CLocalConnection();
 	
 	/**
-	@brief Send data to other instance
-	*/
-	virtual void SendData(const unsigned char *data, const unsigned length);
-	
-	/**
 	@brief Send packet to other instance
 	
 	Use this, since it doesn't need memcpy'ing
 	 */
-	virtual void SendData(const RawPacket* data);
+	virtual void SendData(boost::shared_ptr&lt;const RawPacket&gt; data);
 
-	virtual const RawPacket* Peek(unsigned ahead) const;
+	virtual boost::shared_ptr&lt;const RawPacket&gt; Peek(unsigned ahead) const;
 
 	/**
 	@brief Get data
 	*/
-	virtual RawPacket* GetData();
+	virtual boost::shared_ptr&lt;const RawPacket&gt; GetData();
 
 	/// does nothing
 	virtual void Flush(const bool forced = false);
@@ -53,9 +48,7 @@
 	virtual NetAddress GetPeerName() const;
 
 private:
-	typedef std::deque&lt;const RawPacket*&gt; MsgQueue;
-
-	static MsgQueue Data[2];
+	static std::deque&lt; boost::shared_ptr&lt;const RawPacket&gt; &gt; Data[2];
 	static boost::mutex Mutex[2];
 
 	unsigned OtherInstance() const;

Modified: branches/gml/rts/System/Net/Net.cpp
===================================================================
--- branches/gml/rts/System/Net/Net.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/Net.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -98,7 +98,7 @@
 {
 	for (connVec::const_iterator  i = connections.begin(); i &lt; connections.end(); ++i)
 	{
-		if ((*i) &amp;&amp; (*i)-&gt;GetDataRecieved() &gt; 0)
+		if ((*i) &amp;&amp; (*i)-&gt;GetDataReceived() &gt; 0)
 		{
 			return true;
 		}
@@ -130,7 +130,7 @@
 	return connections[number]-&gt;GetPeerName();
 }
 
-const RawPacket* CNet::Peek(const unsigned conNum, unsigned ahead) const
+boost::shared_ptr&lt;const RawPacket&gt; CNet::Peek(const unsigned conNum, unsigned ahead) const
 {
 	if (int(conNum) &lt;= MaxConnectionID() &amp;&amp; (bool)connections[conNum])
 	{
@@ -142,7 +142,7 @@
 	}
 }
 
-RawPacket* CNet::GetData(const unsigned conNum)
+boost::shared_ptr&lt;const RawPacket&gt; CNet::GetData(const unsigned conNum)
 {
 	if (int(conNum) &lt;= MaxConnectionID() &amp;&amp; (bool)connections[conNum])
 	{
@@ -154,12 +154,12 @@
 	}
 }
 
-void CNet::SendData(const unsigned char *data, const unsigned length)
+void CNet::SendData(boost::shared_ptr&lt;const RawPacket&gt; data)
 {
 #ifdef DEBUG
 	{
 		unsigned int msglength = 0;
-		unsigned char msgid = data[0];
+		unsigned char msgid = data-&gt;data[0];
 		ProtocolDef* proto = ProtocolDef::instance();
 		if (proto-&gt;HasFixedLength(msgid))
 		{
@@ -170,58 +170,33 @@
 			int length_t = proto-&gt;GetLength(msgid);
 			if (length_t == -1)
 			{
-				msglength = (unsigned int)data[1];
+				msglength = (unsigned int)(data-&gt;data[1]);
 			}
 			else if (length_t == -2)
 			{
-				msglength = *((short*)(data+1));
+				msglength = *((short*)(data-&gt;data+1));
 			}
 		}
 		
-		if (length != msglength || length == 0)
+		if (data-&gt;length != msglength || data-&gt;length == 0)
 		{
-			throw network_error( str( boost::format(&quot;Message length error (ID %1% with length %2% should be %3%) while sending (CNet::SendData(char*, unsigned))&quot;) % (unsigned int)data[0] % length % msglength ) );
+			throw network_error( str( boost::format(&quot;Message length error (ID %1% with length %2% should be %3%) while sending (CNet::SendData(char*, unsigned))&quot;) % (unsigned int)(data-&gt;data[0]) % data-&gt;length % msglength ) );
 		}
 	}
 #endif
-
 	for (connVec::iterator it = connections.begin(); it != connections.end(); ++it)
 	{
-		if(*it){
-			(*it)-&gt;SendData(data,length);
-		}
+		if(*it)
+			(*it)-&gt;SendData(data);
 	}
 }
 
-void CNet::SendData(const RawPacket* data)
+void CNet::SendData(boost::shared_ptr&lt;const RawPacket&gt; data, const unsigned playerNum)
 {
-	SendData(data-&gt;data, data-&gt;length);
-	delete data;
-}
-
-void CNet::SendData(const unsigned char* data,const unsigned length, const unsigned playerNum)
-{
 	if (int(playerNum) &lt;= MaxConnectionID() &amp;&amp; connections[playerNum])
-	{
-		connections[playerNum]-&gt;SendData(data,length);
-	}
-	else
-	{
-		throw network_error(&quot;Cant send data (wrong connection number)&quot;);
-	}
-}
-
-void CNet::SendData(const RawPacket* data, const unsigned playerNum)
-{
-	if (int(playerNum) &lt;= MaxConnectionID() &amp;&amp; connections[playerNum])
-	{
 		connections[playerNum]-&gt;SendData(data);
-	}
 	else
-	{
-		delete data;
-		throw network_error(&quot;Cant send data (wrong connection number)&quot;);
-	}
+		throw network_error(&quot;Can't send data (wrong connection number)&quot;);
 }
 
 void CNet::FlushNet()
@@ -296,23 +271,17 @@
 	return (localConnBuf || (udplistener &amp;&amp; udplistener-&gt;HasIncomingConnections()));
 }
 
-RawPacket* CNet::GetData()
+boost::shared_ptr&lt;const RawPacket&gt; CNet::GetData()
 {
 	if (localConnBuf)
-	{
-		RawPacket* data = localConnBuf-&gt;GetData();
-		return data;
-	}
+		return localConnBuf-&gt;GetData();
 	else if (udplistener &amp;&amp; udplistener-&gt;HasIncomingConnections())
 	{
 		boost::shared_ptr&lt;UDPConnection&gt; locked(udplistener-&gt;PreviewConnection());
-		RawPacket* data = locked-&gt;GetData();
-		return data;
+		return locked-&gt;GetData();
 	}
 	else
-	{
 		throw network_error(&quot;No Connection waiting (no data recieved)&quot;);
-	}
 }
 
 unsigned CNet::AcceptIncomingConnection(const unsigned wantedNumber)

Modified: branches/gml/rts/System/Net/Net.h
===================================================================
--- branches/gml/rts/System/Net/Net.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/Net.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -137,40 +137,39 @@
 	@return A RawPacket holding the data, or 0 if no data
 	@param conNum The number to recieve from
 	@param ahead How many packets to look ahead. A typical usage would be:
-	for (int ahead = 0; (packet = net-&gt;Peek(conNum, ahead)) != NULL; ++ahead) {}
+	for (int ahead = 0; (packet = net-&gt;Peek(conNum, ahead)); ++ahead) {}
 	*/
-	const RawPacket* Peek(const unsigned conNum, unsigned ahead) const;
+	boost::shared_ptr&lt;const RawPacket&gt; Peek(const unsigned conNum, unsigned ahead) const;
 
 	/**
-	@brief Recieve data from a client
+	@brief Receive data from a client
 	@param conNum The number to recieve from
-	@return a RawPacket* with the data inside (or 0 when there is no data) (YOU! need to delete it after using)
+	@return a smart RawPacket pointer with the data inside (or empty when no data)
 	@throw network_error When conNum is not a valid connection ID
 	*/
-	RawPacket* GetData(const unsigned conNum);
+	boost::shared_ptr&lt;const RawPacket&gt; GetData(const unsigned conNum);
 	
 	/**
 	@brief Broadcast data to all clients
-	@param data The data
-	@param length length of the data
+	@param data The smart packet pointer
 	@throw network_error Only when DEBUG is set: When the message identifier (data[0]) is not registered (through RegisterMessage())
 	*/
-	void SendData(const unsigned char* data,const unsigned length);
-	void SendData(const RawPacket* data);
-	
+	void SendData(boost::shared_ptr&lt;const RawPacket&gt; data);
+	void SendData(const RawPacket* const data)
+	{
+		SendData(boost::shared_ptr&lt;const RawPacket&gt;(data));
+	};
+
 	/**
 	@brief Send data to one client in particular
+	@param data The smart packet pointer
 	@throw network_error When playerNum is no valid connection ID
-	*/
-	void SendData(const unsigned char* data,const unsigned length, const unsigned playerNum);
-	
-	/**
-	@brief Send data to one client in particular
-	@param data the RawPacket I will take care of, DO NOT DELETE IT
-	@throw network_error When playerNum is no valid connection ID
-	@todo there are too much SendData functions here
 	 */
-	void SendData(const RawPacket* data, const unsigned playerNum);
+	void SendData(boost::shared_ptr&lt;const RawPacket&gt; data, const unsigned playerNum);
+	void SendData(const RawPacket* const data, const unsigned playerNum)
+	{
+		SendData(boost::shared_ptr&lt;const RawPacket&gt;(data), playerNum);
+	};
 	
 	/**
 	@brief send all waiting data
@@ -188,8 +187,8 @@
 	/// did someone tried to connect?
 	bool HasIncomingConnection() const;
 	
-	/// Recieve data from first unbound connection to check if we allow him in our game
-	RawPacket* GetData();
+	/// Receive data from first unbound connection to check if we allow him in our game
+	boost::shared_ptr&lt;const RawPacket&gt; GetData();
 	
 	/// everything seems fine, accept him
 	unsigned AcceptIncomingConnection(const unsigned wantedNumber=0);
@@ -197,97 +196,6 @@
 	/// we dont want you in our game
 	void RejectIncomingConnection();
 	
-protected:
-	/** Send a net message without any parameters. */
-	void SendData(const unsigned char msg) {
-		SendData(&amp;msg, sizeof(msg));
-	}
-
-	/** Send a net message with one parameter. */
-	template&lt;typename A&gt;
-	void SendData(const unsigned char msg, const A a) {
-		const int size = 1 + sizeof(A);
-		unsigned char buf[size];
-		buf[0] = msg;
-		*(A*)&amp;buf[1] = a;
-		SendData(buf, size);
-	}
-
-	template&lt;typename A, typename B&gt;
-	void SendData(const unsigned char msg, const A a, const B b) {
-		const int size = 1 + sizeof(A) + sizeof(B);
-		unsigned char buf[size];
-		buf[0] = msg;
-		*(A*)&amp;buf[1] = a;
-		*(B*)&amp;buf[1 + sizeof(A)] = b;
-		SendData(buf, size);
-	}
-
-	template&lt;typename A, typename B, typename C&gt;
-	void SendData(const unsigned char msg, const A a, const B b, const C c) {
-		const int size = 1 + sizeof(A) + sizeof(B) + sizeof(C);
-		unsigned char buf[size];
-		buf[0] = msg;
-		*(A*)&amp;buf[1] = a;
-		*(B*)&amp;buf[1 + sizeof(A)] = b;
-		*(C*)&amp;buf[1 + sizeof(A) + sizeof(B)] = c;
-		SendData(buf, size);
-	}
-
-	template&lt;typename A, typename B, typename C, typename D&gt;
-	void SendData(const unsigned char msg, const A a, const B b, const C c, const D d) {
-		const int size = 1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D);
-		unsigned char buf[size];
-		buf[0] = msg;
-		*(A*)&amp;buf[1] = a;
-		*(B*)&amp;buf[1 + sizeof(A)] = b;
-		*(C*)&amp;buf[1 + sizeof(A) + sizeof(B)] = c;
-		*(D*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C)] = d;
-		SendData(buf, size);
-	}
-
-	template&lt;typename A, typename B, typename C, typename D, typename E&gt;
-	void SendData(const unsigned char msg, A a, B b, C c, D d, E e) {
-		const int size = 1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D) + sizeof(E);
-		unsigned char buf[size];
-		buf[0] = msg;
-		*(A*)&amp;buf[1] = a;
-		*(B*)&amp;buf[1 + sizeof(A)] = b;
-		*(C*)&amp;buf[1 + sizeof(A) + sizeof(B)] = c;
-		*(D*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C)] = d;
-		*(E*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D)] = e;
-		SendData(buf, size);
-	}
-
-	template&lt;typename A, typename B, typename C, typename D, typename E, typename F&gt;
-	void SendData(const unsigned char msg, A a, B b, C c, D d, E e, F f) {
-		const int size = 1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D) + sizeof(E) + sizeof(F);
-		unsigned char buf[size];
-		buf[0] = msg;
-		*(A*)&amp;buf[1] = a;
-		*(B*)&amp;buf[1 + sizeof(A)] = b;
-		*(C*)&amp;buf[1 + sizeof(A) + sizeof(B)] = c;
-		*(D*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C)] = d;
-		*(E*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D)] = e;
-		*(F*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D) + sizeof(E)] = f;
-		SendData(buf, size);
-	}
-
-	template&lt;typename A, typename B, typename C, typename D, typename E, typename F, typename G&gt;
-	void SendData(const unsigned char msg, A a, B b, C c, D d, E e, F f, G g) {
-		const int size = 1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D) + sizeof(E) + sizeof(F) + sizeof(G);
-		unsigned char buf[size];
-		buf[0] = msg;
-		*(A*)&amp;buf[1] = a;
-		*(B*)&amp;buf[1 + sizeof(A)] = b;
-		*(C*)&amp;buf[1 + sizeof(A) + sizeof(B)] = c;
-		*(D*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C)] = d;
-		*(E*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D)] = e;
-		*(F*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D) + sizeof(E)] = f;
-		*(G*)&amp;buf[1 + sizeof(A) + sizeof(B) + sizeof(C) + sizeof(D) + sizeof(E) + sizeof(F)] = g;
-		SendData(buf, size);
-	}
-	
 private:
 	typedef boost::shared_ptr&lt;CConnection&gt; connPtr;
 	typedef std::vector&lt; connPtr &gt; connVec;

Modified: branches/gml/rts/System/Net/PackPacket.cpp
===================================================================
--- branches/gml/rts/System/Net/PackPacket.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/PackPacket.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -7,6 +7,11 @@
 {
 }
 
+PackPacket::PackPacket(const unsigned length, unsigned char msgID) : RawPacket(length), pos(0)
+{
+	*this &lt;&lt; msgID;
+}
+
 PackPacket&amp; PackPacket::operator&lt;&lt;(const std::string&amp; text)
 {
 	unsigned size = text.size()+1;

Modified: branches/gml/rts/System/Net/PackPacket.h
===================================================================
--- branches/gml/rts/System/Net/PackPacket.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/PackPacket.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -15,6 +15,7 @@
 {
 public:
 	PackPacket(const unsigned length);
+	PackPacket(const unsigned length, unsigned char msgID);
 	
 	template &lt;typename T&gt;
 	PackPacket&amp; operator&lt;&lt;(const T&amp; t) {
@@ -36,6 +37,8 @@
 		return *this;
 	};
 	
+	unsigned char* GetWritingPos() {return data+pos;};
+	
 private:
 	unsigned pos;
 };

Modified: branches/gml/rts/System/Net/Test/CMakeLists.txt
===================================================================
--- branches/gml/rts/System/Net/Test/CMakeLists.txt	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/Test/CMakeLists.txt	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,8 +1,8 @@
 PROJECT(UnitTester)
 SET(CMAKE_CXX_FLAGS &quot;-g -O1 -Wall&quot;)
 INCLUDE_DIRECTORIES(../ /usr/include/SDL)
-ADD_DEFINITIONS(-DDEBUG)
+ADD_DEFINITIONS(-DDEBUG -D_DEBUG)
 
-AUX_SOURCE_DIRECTORY(../ netfiles)
+AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/../ netfiles)
 ADD_EXECUTABLE(UnitTest main ${netfiles})
 TARGET_LINK_LIBRARIES(UnitTest SDL boost_thread)

Modified: branches/gml/rts/System/Net/Test/main.cpp
===================================================================
--- branches/gml/rts/System/Net/Test/main.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/Test/main.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -2,10 +2,11 @@
 #include &lt;string.h&gt;
 #include &lt;iostream&gt;
 #include &lt;assert.h&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
 
 const unsigned int serverportnum = 5000;
-RawPacket* data1 = 0;
-RawPacket* data2 = 0;
+boost::shared_ptr&lt;const netcode::RawPacket&gt; data1;
+boost::shared_ptr&lt;const netcode::RawPacket&gt; data2;
 
 bool TestLocal(netcode::CNet* server, unsigned freeNumber)
 {
@@ -22,26 +23,24 @@
 	localclient-&gt;Update();
 	
 	
-	localclient-&gt;SendData(data1-&gt;data, data1-&gt;length);
+	localclient-&gt;SendData(data1);
 	localclient-&gt;FlushNet();
 	server-&gt;Update();
 	localclient-&gt;Update();
-	RawPacket* ret = server-&gt;GetData(0);
+	boost::shared_ptr&lt;const netcode::RawPacket&gt; ret = server-&gt;GetData(0);
 	if (!ret || ret-&gt;length != 10 || (int)ret-&gt;data[1] != 6)
 	{
-		std::cout &lt;&lt; &quot;Server dont recieved message&quot; &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;Server dont recieved message&quot; &lt;&lt; ret-&gt;length &lt;&lt; std::endl;
 		return false;
 	}
-	delete ret; ret = 0;
-	
-	server-&gt;SendData(data1-&gt;data, data1-&gt;length);
+		
+	server-&gt;SendData(data1);
 	ret = localclient-&gt;GetData(0);
 	if (!ret || ret-&gt;length != 10 || (int)ret-&gt;data[1] != 6)
 	{
 		std::cout &lt;&lt; &quot;Client dont recieved message&quot; &lt;&lt; std::endl;
 		return false;
 	}
-	delete ret; ret = 0;
 	
 	std::cout &lt;&lt; localclient-&gt;GetConnectionStatistics(0);
 	delete localclient;
@@ -57,12 +56,12 @@
 	unsigned char buffer[10];
 	memset(buffer, 0, 10);
 	buffer[1] = 6;
-	data1 = new RawPacket(buffer, 10);
+	data1.reset(new RawPacket(buffer, 10));
 	
 	unsigned char bigbuffer[1000];
 	memset(bigbuffer, 0, 1000);
 	bigbuffer[0]=2;
-	data2 = new RawPacket(bigbuffer, 1000);
+	data2.reset(new RawPacket(bigbuffer, 1000));
 	
 	std::cout &lt;&lt; &quot;Starting Server and local Client&quot; &lt;&lt; std::endl;
 	netcode::CNet* server = new netcode::CNet();
@@ -73,7 +72,7 @@
 	server-&gt;RegisterMessage((unsigned char)0, 10);
 	server-&gt;RegisterMessage((unsigned char)1, 100);
 	server-&gt;RegisterMessage((unsigned char)2, 1000);
-	server-&gt;SendData(data1-&gt;data, data1-&gt;length);
+	server-&gt;SendData(data1);
 	
 	if (!TestLocal(server, 0))
 	{
@@ -90,21 +89,21 @@
 	client-&gt;RegisterMessage((unsigned char)2, 1000);
 	
 	{
-		client-&gt;SendData(data1-&gt;data, data1-&gt;length);
+		client-&gt;SendData(data1);
 		client-&gt;Update();
 		server-&gt;Update();
 		server-&gt;AcceptIncomingConnection(1);
 		server-&gt;Update();
-		RawPacket* ret  = server-&gt;GetData(1);
+		boost::shared_ptr&lt;const netcode::RawPacket&gt; ret  = server-&gt;GetData(1);
 		if (ret)
 		{
-			std::cout &lt;&lt; &quot;Recieved &quot; &lt;&lt; ret-&gt;length &lt;&lt; &quot; bytes UDP client message &quot; &lt;&lt; (int)ret-&gt;data[1] &lt;&lt; std::endl;
-			delete ret; ret = 0;
+			std::cout &lt;&lt; &quot;Received &quot; &lt;&lt; ret-&gt;length &lt;&lt; &quot; bytes UDP client message &quot; &lt;&lt; (int)ret-&gt;data[1] &lt;&lt; std::endl;
+			ret.reset();
 		}
 		else
 			return 1;
 		
-		server-&gt;SendData(data1-&gt;data, data1-&gt;length);
+		server-&gt;SendData(data1);
 		sleep(1);	// buffer wont be flushed without this
 		server-&gt;Update();
 		client-&gt;Update();
@@ -112,21 +111,21 @@
 		ret = client-&gt;GetData(1);
 		if (ret)
 		{
-			std::cout &lt;&lt; &quot;Recieved &quot; &lt;&lt; ret-&gt;length &lt;&lt; &quot; bytes UDP server message &quot; &lt;&lt; (int)ret-&gt;data[1] &lt;&lt; std::endl;
-			delete ret; ret = 0;
+			std::cout &lt;&lt; &quot;Received &quot; &lt;&lt; ret-&gt;length &lt;&lt; &quot; bytes UDP server message &quot; &lt;&lt; (int)ret-&gt;data[1] &lt;&lt; std::endl;
+			ret.reset();
 		}
 		else
 			return 1;
 		
-		client-&gt;SendData(data2-&gt;data, data2-&gt;length);
+		client-&gt;SendData(data2);
 		server-&gt;Update();
 		client-&gt;Update();
 		server-&gt;Update();
 		ret = server-&gt;GetData(1);
 		if (ret)
 		{
-			std::cout &lt;&lt; &quot;Recieved &quot; &lt;&lt; ret-&gt;length &lt;&lt; &quot; bytes UDP client message&quot; &lt;&lt; std::endl;
-			delete ret; ret = 0;
+			std::cout &lt;&lt; &quot;Received &quot; &lt;&lt; ret-&gt;length &lt;&lt; &quot; bytes UDP client message&quot; &lt;&lt; std::endl;
+			ret.reset();
 		}
 		else
 			return 1;
@@ -140,7 +139,5 @@
 	delete server;
 	std::cout &lt;&lt; client-&gt;GetConnectionStatistics(1);
 	delete client;
-	
-	delete data1; delete data2; // so valgrind doesn't complain
 	return 0;
 }

Modified: branches/gml/rts/System/Net/UDPConnectedSocket.h
===================================================================
--- branches/gml/rts/System/Net/UDPConnectedSocket.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/UDPConnectedSocket.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -27,7 +27,7 @@
 	void Send(const unsigned char* const buf, const unsigned dataLength) const;
 	
 	/**
-	@brief Recieve some data
+	@brief Receive some data
 	*/
 	unsigned Recv(unsigned char* buf, const unsigned bufLength) const;
 

Modified: branches/gml/rts/System/Net/UDPConnection.cpp
===================================================================
--- branches/gml/rts/System/Net/UDPConnection.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/UDPConnection.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -35,48 +35,41 @@
 {
 	if (fragmentBuffer)
 		delete fragmentBuffer;
-
-	while (!msgQueue.empty())
-	{
-		delete msgQueue.front();
-		msgQueue.pop_front();
-	}
 }
 
-void UDPConnection::SendData(const unsigned char *data, const unsigned length)
+void UDPConnection::SendData(boost::shared_ptr&lt;const RawPacket&gt; data)
 {
-	if(outgoingLength+length&gt;=UDPBufferSize){
+	if(outgoingLength + data-&gt;length &gt;= UDPBufferSize){
 		throw network_error(&quot;Buffer overflow in UDPConnection (SendData)&quot;);
 	}
-	memcpy(&amp;outgoingData[outgoingLength],data,length);
-	outgoingLength+=length;
+	memcpy(&amp;outgoingData[outgoingLength], data-&gt;data, data-&gt;length);
+	outgoingLength += data-&gt;length;
 }
 
-void UDPConnection::SendData(const RawPacket* data)
+boost::shared_ptr&lt;const RawPacket&gt; UDPConnection::Peek(unsigned ahead) const
 {
-	//TODO make UDPConnection completely packet-based
-	SendData(data-&gt;data, data-&gt;length);
-	delete data;
-}
-
-const RawPacket* UDPConnection::Peek(unsigned ahead) const
-{
 	if (ahead &lt; msgQueue.size())
 		return msgQueue[ahead];
-
-	return NULL;
+	else
+	{
+		boost::shared_ptr&lt;const RawPacket&gt; empty;
+		return empty;
+	}
 }
 
-RawPacket* UDPConnection::GetData()
+boost::shared_ptr&lt;const RawPacket&gt; UDPConnection::GetData()
 {
 	if (!msgQueue.empty())
 	{
-		RawPacket* msg = msgQueue.front();
+		boost::shared_ptr&lt;const RawPacket&gt; msg = msgQueue.front();
 		msgQueue.pop_front();
 		return msg;
 	}
 	else
-		return NULL;
+	{
+		boost::shared_ptr&lt;const RawPacket&gt; empty;
+		return empty;
+	}
 }
 
 void UDPConnection::Update()
@@ -214,7 +207,7 @@
 				if (bufLength &gt;= pos + msglength)
 				{
 					// yes =&gt; add to msgQueue and keep going
-					msgQueue.push_back(new RawPacket(buf + pos, msglength));
+					msgQueue.push_back(boost::shared_ptr&lt;const RawPacket&gt;(new RawPacket(buf + pos, msglength)));
 					pos += msglength;
 				}
 				else
@@ -275,7 +268,7 @@
 std::string UDPConnection::Statistics() const
 {
 	std::string msg = &quot;Statistics for UDP connection:\n&quot;;
-	msg += str( boost::format(&quot;Recieved: %1% bytes in %2% packets (%3% bytes/package)\n&quot;) %dataRecv %recvPackets %((float)dataRecv / (float)recvPackets));
+	msg += str( boost::format(&quot;Received: %1% bytes in %2% packets (%3% bytes/package)\n&quot;) %dataRecv %recvPackets %((float)dataRecv / (float)recvPackets));
 	msg += str( boost::format(&quot;Sent: %1% bytes in %2% packets (%3% bytes/package)\n&quot;) %dataSent %sentPackets %((float)dataSent / (float)sentPackets));
 	msg += str( boost::format(&quot;Relative protocol overhead: %1% up, %2% down\n&quot;) %((float)sentOverhead / (float)dataSent) %((float)recvOverhead / (float)dataRecv) );
 	msg += str( boost::format(&quot;%1% incoming packets had been dropped, %2% outgoing packets had to be resent\n&quot;) %droppedPackets %resentPackets);

Modified: branches/gml/rts/System/Net/UDPConnection.h
===================================================================
--- branches/gml/rts/System/Net/UDPConnection.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/UDPConnection.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -32,22 +32,19 @@
 	UDPConnection(boost::shared_ptr&lt;UDPSocket&gt; NetSocket, const std::string&amp; address, const unsigned port);
 	virtual ~UDPConnection();
 
-	/// use this if you want data to be sent
-	virtual void SendData(const unsigned char *data, const unsigned length);
-	
 	/**
 	@brief Send packet to other instance
 	*/
-	virtual void SendData(const RawPacket* data);
+	virtual void SendData(boost::shared_ptr&lt;const RawPacket&gt; data);
 
-	virtual const RawPacket* Peek(unsigned ahead) const;
+	virtual boost::shared_ptr&lt;const RawPacket&gt; Peek(unsigned ahead) const;
 
 	/**
 	@brief use this to recieve ready data
 	@return a network message encapsulated in a RawPacket,
 	or NULL if there are no more messages available.
 	*/
-	virtual RawPacket* GetData();
+	virtual boost::shared_ptr&lt;const RawPacket&gt; GetData();
 
 	/**
 	@brief update internals
@@ -76,8 +73,6 @@
 	static const unsigned hsize;
 
 private:
-	typedef std::deque&lt;RawPacket*&gt; MsgQueue;
-
 	void Init();
 	
 	unsigned lastSendTime;
@@ -105,7 +100,7 @@
 	int lastInOrder;
 	int lastNak;
 	unsigned lastNakTime;
-	MsgQueue msgQueue;
+	std::deque&lt; boost::shared_ptr&lt;const RawPacket&gt; &gt; msgQueue;
 
 	/** Our socket.
 	*/

Modified: branches/gml/rts/System/Net/UnpackPacket.cpp
===================================================================
--- branches/gml/rts/System/Net/UnpackPacket.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/UnpackPacket.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -3,7 +3,7 @@
 namespace netcode
 {
 
-UnpackPacket::UnpackPacket(const RawPacket&amp; packet) : pckt(packet), pos(0)
+UnpackPacket::UnpackPacket(boost::shared_ptr&lt;const RawPacket&gt; packet) : pckt(packet), pos(0)
 {
 }
 

Modified: branches/gml/rts/System/Net/UnpackPacket.h
===================================================================
--- branches/gml/rts/System/Net/UnpackPacket.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/Net/UnpackPacket.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -2,6 +2,7 @@
 #define UNPACK_PACKET_H
 
 #include &lt;string&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
 
 #include &quot;RawPacket.h&quot;
 
@@ -11,14 +12,14 @@
 class UnpackPacket
 {
 public:
-	UnpackPacket(const RawPacket&amp;);
+	UnpackPacket(boost::shared_ptr&lt;const RawPacket&gt;);
 	
 	template &lt;typename T&gt;
-	void operator&gt;&gt;(T&amp; t) {t = *(T*)(pckt.data+pos); pos += sizeof(T);};
-	void operator&gt;&gt;(std::string&amp; text) {text = std::string((char*)(pckt.data + pos)); pos += text.size()+1;};
+	void operator&gt;&gt;(T&amp; t) {t = *(T*)(pckt-&gt;data+pos); pos += sizeof(T);};
+	void operator&gt;&gt;(std::string&amp; text) {text = std::string((char*)(pckt-&gt;data + pos)); pos += text.size()+1;};
 	
 private:
-	const RawPacket&amp; pckt;
+	boost::shared_ptr&lt;const RawPacket&gt; pckt;
 	unsigned pos;
 };
 

Modified: branches/gml/rts/System/NetProtocol.cpp
===================================================================
--- branches/gml/rts/System/NetProtocol.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/NetProtocol.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -57,19 +57,17 @@
 	return CNet::IsActiveConnection(serverSlot);
 }
 
-const RawPacket* CNetProtocol::Peek(unsigned ahead) const
+boost::shared_ptr&lt;const netcode::RawPacket&gt; CNetProtocol::Peek(unsigned ahead) const
 {
 	return CNet::Peek(serverSlot, ahead);
 }
 
-RawPacket* CNetProtocol::GetData()
+boost::shared_ptr&lt;const netcode::RawPacket&gt; CNetProtocol::GetData()
 {
-	RawPacket* ret = CNet::GetData(serverSlot);
+	boost::shared_ptr&lt;const netcode::RawPacket&gt; ret = CNet::GetData(serverSlot);
 	
 	if (record &amp;&amp; ret)
-	{
 		record-&gt;SaveToDemo(ret-&gt;data, ret-&gt;length);
-	}
 	
 	return ret;
 }

Modified: branches/gml/rts/System/NetProtocol.h
===================================================================
--- branches/gml/rts/System/NetProtocol.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/System/NetProtocol.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -36,16 +36,16 @@
 	@param ahead How many packets to look ahead. A typical usage would be:
 	for (int ahead = 0; (packet = net-&gt;Peek(ahead)) != NULL; ++ahead) {}
 	*/
-	const RawPacket* Peek(unsigned ahead) const;
+	boost::shared_ptr&lt;const netcode::RawPacket&gt; Peek(unsigned ahead) const;
 
 	/**
-	@brief Recieve data from Client
+	@brief Receive data from Client
 	@return The data packet, or 0 if there is no data
 	@throw network_error If there is no such connection
 	
-	Recieves only one message (even if there are more in the recieve buffer), so call this until you get a 0 in return
+	Receives only one message (even if there are more in the recieve buffer), so call this until you get a 0 in return
 	 */
-	RawPacket* GetData();
+	boost::shared_ptr&lt;const netcode::RawPacket&gt; GetData();
 	
 	CDemoRecorder* GetDemoRecorder() const { return record; }
 

Copied: branches/gml/rts/build/cmake (from rev 5960, trunk/rts/build/cmake)

Deleted: branches/gml/rts/build/cmake/COPYING-CMAKE-SCRIPTS
===================================================================
--- trunk/rts/build/cmake/COPYING-CMAKE-SCRIPTS	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/cmake/COPYING-CMAKE-SCRIPTS	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,22 +0,0 @@
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-1. Redistributions of source code must retain the copyright
-   notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the copyright
-   notice, this list of conditions and the following disclaimer in the
-   documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products 
-   derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Copied: branches/gml/rts/build/cmake/COPYING-CMAKE-SCRIPTS (from rev 5960, trunk/rts/build/cmake/COPYING-CMAKE-SCRIPTS)
===================================================================
--- branches/gml/rts/build/cmake/COPYING-CMAKE-SCRIPTS	                        (rev 0)
+++ branches/gml/rts/build/cmake/COPYING-CMAKE-SCRIPTS	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,22 @@
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+1. Redistributions of source code must retain the copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products 
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Deleted: branches/gml/rts/build/cmake/FindBoost.cmake
===================================================================
--- trunk/rts/build/cmake/FindBoost.cmake	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/cmake/FindBoost.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,168 +0,0 @@
-# copied from KDE svn sources
-
-# - Find the Boost includes and libraries.
-# The following variables are set if Boost is found.  If Boost is not
-# found, Boost_FOUND is set to false.
-#  Boost_FOUND        - True when the Boost include directory is found.
-#  Boost_INCLUDE_DIRS - the path to where the boost include files are.
-#  Boost_LIBRARY_DIRS - The path to where the boost library files are.
-#  Boost_LIB_DIAGNOSTIC_DEFINITIONS - Only set if using Windows.
-
-# !!!!!!!!!!!!!!!!!!!
-# this is FindBoost.cmake from cmake 2.4.4 to 2.4.8
-# it is here because the one in 2.6.0RC9 is slightly broken
-# and will be removed again once 2.6.0 or 2.6.0RC10 is released
-# Alex
-# !!!!!!!!!!!!!!!!!!!!!!
-
-# ----------------------------------------------------------------------------
-# If you have installed Boost in a non-standard location or you have
-# just staged the boost files using bjam then you have three
-# options. In the following comments, it is assumed that &lt;Your Path&gt;
-# points to the root directory of the include directory of Boost. e.g
-# If you have put boost in C:\development\Boost then &lt;Your Path&gt; is
-# &quot;C:/development/Boost&quot; and in this directory there will be two
-# directories called &quot;include&quot; and &quot;lib&quot;.
-# 1) After CMake runs, set Boost_INCLUDE_DIR to &lt;Your Path&gt;/include/boost&lt;-version&gt;
-# 2) Use CMAKE_INCLUDE_PATH to set a path to &lt;Your Path&gt;/include. This will allow FIND_PATH()
-#    to locate Boost_INCLUDE_DIR by utilizing the PATH_SUFFIXES option. e.g.
-#    SET(CMAKE_INCLUDE_PATH ${CMAKE_INCLUDE_PATH} &quot;&lt;Your Path&gt;/include&quot;)
-# 3) Set an environment variable called ${BOOST_ROOT} that points to the root of where you have
-#    installed Boost, e.g. &lt;Your Path&gt;. It is assumed that there is at least a subdirectory called
-#    include in this path.
-#
-# Note:
-#  1) If you are just using the boost headers, then you do not need to use
-#     Boost_LIBRARY_DIRS in your CMakeLists.txt file.
-#  2) If Boost has not been installed, then when setting Boost_LIBRARY_DIRS
-#     the script will look for /lib first and, if this fails, then for /stage/lib.
-#
-# Usage:
-# In your CMakeLists.txt file do something like this:
-# ...
-# # Boost
-# FIND_PACKAGE(Boost)
-# ...
-# INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIRS})
-# LINK_DIRECTORIES(${Boost_LIBRARY_DIRS})
-#
-# In Windows, we make the assumption that, if the Boost files are installed, the default directory
-# will be C:\boost.
-
-#
-# TODO:
-#
-# 1) Automatically find the Boost library files and eliminate the need
-#    to use Link Directories.
-#
-
-IF(WIN32)
-  # In windows, automatic linking is performed, so you do not have to specify the libraries.
-  # If you are linking to a dynamic runtime, then you can choose to link to either a static or a
-  # dynamic Boost library, the default is to do a static link.  You can alter this for a specific
-  # library &quot;whatever&quot; by defining BOOST_WHATEVER_DYN_LINK to force Boost library &quot;whatever&quot; to
-  # be linked dynamically.  Alternatively you can force all Boost libraries to dynamic link by
-  # defining BOOST_ALL_DYN_LINK.
-
-  # This feature can be disabled for Boost library &quot;whatever&quot; by defining BOOST_WHATEVER_NO_LIB,
-  # or for all of Boost by defining BOOST_ALL_NO_LIB.
-
-  # If you want to observe which libraries are being linked against then defining
-  # BOOST_LIB_DIAGNOSTIC will cause the auto-linking code to emit a #pragma message each time
-  # a library is selected for linking.
-  SET(Boost_LIB_DIAGNOSTIC_DEFINITIONS &quot;-DBOOST_LIB_DIAGNOSTIC&quot;)
-ENDIF(WIN32)
-
-
-SET(BOOST_INCLUDE_PATH_DESCRIPTION &quot;directory containing the boost include files. E.g /usr/local/include/boost-1_33_1 or c:\\boost\\include\\boost-1_33_1&quot;)
-
-SET(BOOST_DIR_MESSAGE &quot;Set the Boost_INCLUDE_DIR cmake cache entry to the ${BOOST_INCLUDE_PATH_DESCRIPTION}&quot;)
-
-SET(BOOST_DIR_SEARCH $ENV{BOOST_ROOT})
-IF(BOOST_DIR_SEARCH)
-  FILE(TO_CMAKE_PATH ${BOOST_DIR_SEARCH} BOOST_DIR_SEARCH)
-  SET(BOOST_DIR_SEARCH ${BOOST_DIR_SEARCH}/include)
-ENDIF(BOOST_DIR_SEARCH)
-
-IF(WIN32)
-  SET(BOOST_DIR_SEARCH
-    ${BOOST_DIR_SEARCH}
-    C:/boost/include
-    D:/boost/include
-  )
-ENDIF(WIN32)
-
-# Add in some path suffixes. These will have to be updated whenever a new Boost version comes out.
-SET(SUFFIX_FOR_PATH
- boost-1_34_1
- boost-1_34_0
- boost-1_34
- boost-1_33_1
- boost-1_33_0
- boost-1_33
-)
-
-#
-# Look for an installation.
-#
-FIND_PATH(Boost_INCLUDE_DIR NAMES boost/config.hpp PATH_SUFFIXES ${SUFFIX_FOR_PATH} PATHS
-
-  # Look in other places.
-  ${BOOST_DIR_SEARCH}
-
-  # Help the user find it if we cannot.
-  DOC &quot;The ${BOOST_INCLUDE_PATH_DESCRIPTION}&quot;
-)
-
-# Assume we didn't find it.
-SET(Boost_FOUND 0)
-
-# Now try to get the include and library path.
-IF(Boost_INCLUDE_DIR)
-
-  # Look for the boost library path.
-  # Note that the user may not have installed any libraries
-  # so it is quite possible the Boost_LIBRARY_PATH may not exist.
-  SET(Boost_LIBRARY_DIR ${Boost_INCLUDE_DIR})
-
-  IF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;boost-[0-9]+&quot;)
-    GET_FILENAME_COMPONENT(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR} PATH)
-  ENDIF (&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;boost-[0-9]+&quot;)
-
-  IF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;/include$&quot;)
-    # Strip off the trailing &quot;/include&quot; in the path.
-    GET_FILENAME_COMPONENT(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR} PATH)
-  ENDIF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;/include$&quot;)
-
-  IF(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
-    SET (Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR}/lib)
-  ELSE(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
-    IF(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
-      SET(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR}/stage/lib)
-    ELSE(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
-      SET(Boost_LIBRARY_DIR &quot;&quot;)
-    ENDIF(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
-  ENDIF(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
-
-  IF(EXISTS &quot;${Boost_INCLUDE_DIR}&quot;)
-    SET(Boost_INCLUDE_DIRS ${Boost_INCLUDE_DIR})
-    # We have found boost. It is possible that the user has not
-    # compiled any libraries so we set Boost_FOUND to be true here.
-    SET(Boost_FOUND 1)
-  ENDIF(EXISTS &quot;${Boost_INCLUDE_DIR}&quot;)
-
-  IF(Boost_LIBRARY_DIR AND EXISTS &quot;${Boost_LIBRARY_DIR}&quot;)
-    SET(Boost_LIBRARY_DIRS ${Boost_LIBRARY_DIR})
-  ENDIF(Boost_LIBRARY_DIR AND EXISTS &quot;${Boost_LIBRARY_DIR}&quot;)
-ENDIF(Boost_INCLUDE_DIR)
-
-IF(NOT Boost_FOUND)
-  IF(NOT Boost_FIND_QUIETLY)
-    MESSAGE(STATUS &quot;Boost was not found. ${BOOST_DIR_MESSAGE}&quot;)
-  ELSE(NOT Boost_FIND_QUIETLY)
-    IF(Boost_FIND_REQUIRED)
-      MESSAGE(FATAL_ERROR &quot;Boost was not found. ${BOOST_DIR_MESSAGE}&quot;)
-    ENDIF(Boost_FIND_REQUIRED)
-  ENDIF(NOT Boost_FIND_QUIETLY)
-ENDIF(NOT Boost_FOUND)
-

Copied: branches/gml/rts/build/cmake/FindBoost.cmake (from rev 5960, trunk/rts/build/cmake/FindBoost.cmake)
===================================================================
--- branches/gml/rts/build/cmake/FindBoost.cmake	                        (rev 0)
+++ branches/gml/rts/build/cmake/FindBoost.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,168 @@
+# copied from KDE svn sources
+
+# - Find the Boost includes and libraries.
+# The following variables are set if Boost is found.  If Boost is not
+# found, Boost_FOUND is set to false.
+#  Boost_FOUND        - True when the Boost include directory is found.
+#  Boost_INCLUDE_DIRS - the path to where the boost include files are.
+#  Boost_LIBRARY_DIRS - The path to where the boost library files are.
+#  Boost_LIB_DIAGNOSTIC_DEFINITIONS - Only set if using Windows.
+
+# !!!!!!!!!!!!!!!!!!!
+# this is FindBoost.cmake from cmake 2.4.4 to 2.4.8
+# it is here because the one in 2.6.0RC9 is slightly broken
+# and will be removed again once 2.6.0 or 2.6.0RC10 is released
+# Alex
+# !!!!!!!!!!!!!!!!!!!!!!
+
+# ----------------------------------------------------------------------------
+# If you have installed Boost in a non-standard location or you have
+# just staged the boost files using bjam then you have three
+# options. In the following comments, it is assumed that &lt;Your Path&gt;
+# points to the root directory of the include directory of Boost. e.g
+# If you have put boost in C:\development\Boost then &lt;Your Path&gt; is
+# &quot;C:/development/Boost&quot; and in this directory there will be two
+# directories called &quot;include&quot; and &quot;lib&quot;.
+# 1) After CMake runs, set Boost_INCLUDE_DIR to &lt;Your Path&gt;/include/boost&lt;-version&gt;
+# 2) Use CMAKE_INCLUDE_PATH to set a path to &lt;Your Path&gt;/include. This will allow FIND_PATH()
+#    to locate Boost_INCLUDE_DIR by utilizing the PATH_SUFFIXES option. e.g.
+#    SET(CMAKE_INCLUDE_PATH ${CMAKE_INCLUDE_PATH} &quot;&lt;Your Path&gt;/include&quot;)
+# 3) Set an environment variable called ${BOOST_ROOT} that points to the root of where you have
+#    installed Boost, e.g. &lt;Your Path&gt;. It is assumed that there is at least a subdirectory called
+#    include in this path.
+#
+# Note:
+#  1) If you are just using the boost headers, then you do not need to use
+#     Boost_LIBRARY_DIRS in your CMakeLists.txt file.
+#  2) If Boost has not been installed, then when setting Boost_LIBRARY_DIRS
+#     the script will look for /lib first and, if this fails, then for /stage/lib.
+#
+# Usage:
+# In your CMakeLists.txt file do something like this:
+# ...
+# # Boost
+# FIND_PACKAGE(Boost)
+# ...
+# INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIRS})
+# LINK_DIRECTORIES(${Boost_LIBRARY_DIRS})
+#
+# In Windows, we make the assumption that, if the Boost files are installed, the default directory
+# will be C:\boost.
+
+#
+# TODO:
+#
+# 1) Automatically find the Boost library files and eliminate the need
+#    to use Link Directories.
+#
+
+IF(WIN32)
+  # In windows, automatic linking is performed, so you do not have to specify the libraries.
+  # If you are linking to a dynamic runtime, then you can choose to link to either a static or a
+  # dynamic Boost library, the default is to do a static link.  You can alter this for a specific
+  # library &quot;whatever&quot; by defining BOOST_WHATEVER_DYN_LINK to force Boost library &quot;whatever&quot; to
+  # be linked dynamically.  Alternatively you can force all Boost libraries to dynamic link by
+  # defining BOOST_ALL_DYN_LINK.
+
+  # This feature can be disabled for Boost library &quot;whatever&quot; by defining BOOST_WHATEVER_NO_LIB,
+  # or for all of Boost by defining BOOST_ALL_NO_LIB.
+
+  # If you want to observe which libraries are being linked against then defining
+  # BOOST_LIB_DIAGNOSTIC will cause the auto-linking code to emit a #pragma message each time
+  # a library is selected for linking.
+  SET(Boost_LIB_DIAGNOSTIC_DEFINITIONS &quot;-DBOOST_LIB_DIAGNOSTIC&quot;)
+ENDIF(WIN32)
+
+
+SET(BOOST_INCLUDE_PATH_DESCRIPTION &quot;directory containing the boost include files. E.g /usr/local/include/boost-1_33_1 or c:\\boost\\include\\boost-1_33_1&quot;)
+
+SET(BOOST_DIR_MESSAGE &quot;Set the Boost_INCLUDE_DIR cmake cache entry to the ${BOOST_INCLUDE_PATH_DESCRIPTION}&quot;)
+
+SET(BOOST_DIR_SEARCH $ENV{BOOST_ROOT})
+IF(BOOST_DIR_SEARCH)
+  FILE(TO_CMAKE_PATH ${BOOST_DIR_SEARCH} BOOST_DIR_SEARCH)
+  SET(BOOST_DIR_SEARCH ${BOOST_DIR_SEARCH}/include)
+ENDIF(BOOST_DIR_SEARCH)
+
+IF(WIN32)
+  SET(BOOST_DIR_SEARCH
+    ${BOOST_DIR_SEARCH}
+    C:/boost/include
+    D:/boost/include
+  )
+ENDIF(WIN32)
+
+# Add in some path suffixes. These will have to be updated whenever a new Boost version comes out.
+SET(SUFFIX_FOR_PATH
+ boost-1_34_1
+ boost-1_34_0
+ boost-1_34
+ boost-1_33_1
+ boost-1_33_0
+ boost-1_33
+)
+
+#
+# Look for an installation.
+#
+FIND_PATH(Boost_INCLUDE_DIR NAMES boost/config.hpp PATH_SUFFIXES ${SUFFIX_FOR_PATH} PATHS
+
+  # Look in other places.
+  ${BOOST_DIR_SEARCH}
+
+  # Help the user find it if we cannot.
+  DOC &quot;The ${BOOST_INCLUDE_PATH_DESCRIPTION}&quot;
+)
+
+# Assume we didn't find it.
+SET(Boost_FOUND 0)
+
+# Now try to get the include and library path.
+IF(Boost_INCLUDE_DIR)
+
+  # Look for the boost library path.
+  # Note that the user may not have installed any libraries
+  # so it is quite possible the Boost_LIBRARY_PATH may not exist.
+  SET(Boost_LIBRARY_DIR ${Boost_INCLUDE_DIR})
+
+  IF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;boost-[0-9]+&quot;)
+    GET_FILENAME_COMPONENT(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR} PATH)
+  ENDIF (&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;boost-[0-9]+&quot;)
+
+  IF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;/include$&quot;)
+    # Strip off the trailing &quot;/include&quot; in the path.
+    GET_FILENAME_COMPONENT(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR} PATH)
+  ENDIF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;/include$&quot;)
+
+  IF(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
+    SET (Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR}/lib)
+  ELSE(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
+    IF(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
+      SET(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR}/stage/lib)
+    ELSE(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
+      SET(Boost_LIBRARY_DIR &quot;&quot;)
+    ENDIF(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
+  ENDIF(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
+
+  IF(EXISTS &quot;${Boost_INCLUDE_DIR}&quot;)
+    SET(Boost_INCLUDE_DIRS ${Boost_INCLUDE_DIR})
+    # We have found boost. It is possible that the user has not
+    # compiled any libraries so we set Boost_FOUND to be true here.
+    SET(Boost_FOUND 1)
+  ENDIF(EXISTS &quot;${Boost_INCLUDE_DIR}&quot;)
+
+  IF(Boost_LIBRARY_DIR AND EXISTS &quot;${Boost_LIBRARY_DIR}&quot;)
+    SET(Boost_LIBRARY_DIRS ${Boost_LIBRARY_DIR})
+  ENDIF(Boost_LIBRARY_DIR AND EXISTS &quot;${Boost_LIBRARY_DIR}&quot;)
+ENDIF(Boost_INCLUDE_DIR)
+
+IF(NOT Boost_FOUND)
+  IF(NOT Boost_FIND_QUIETLY)
+    MESSAGE(STATUS &quot;Boost was not found. ${BOOST_DIR_MESSAGE}&quot;)
+  ELSE(NOT Boost_FIND_QUIETLY)
+    IF(Boost_FIND_REQUIRED)
+      MESSAGE(FATAL_ERROR &quot;Boost was not found. ${BOOST_DIR_MESSAGE}&quot;)
+    ENDIF(Boost_FIND_REQUIRED)
+  ENDIF(NOT Boost_FIND_QUIETLY)
+ENDIF(NOT Boost_FOUND)
+

Deleted: branches/gml/rts/build/cmake/FindDevil.cmake
===================================================================
--- trunk/rts/build/cmake/FindDevil.cmake	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/cmake/FindDevil.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,111 +0,0 @@
-# Downloaded from: <A HREF="http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/cmake/">http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/cmake/</A>
-# License: GPL v2, <A HREF="http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/COPYING">http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/COPYING</A>
-#
-# Modifications:
-# 2008.01.16 Tobi Vollebregt -- changed Devil-&gt;DEVIL for consistency
-#                            -- added devil, ilu, ilut alternative names for MinGW
-#                            -- removed &quot;looking for devil&quot; status message
-
-# - Find devil
-# Find the native DevIL includes and library
-#
-#  DEVIL_INCLUDE_DIR - where to find IL/il.h, etc.
-#  DEVIL_LIBRARIES   - List of libraries when using IL.
-#  DEVIL_FOUND       - True if IL found.
-
-IF (DEVIL_INCLUDE_DIR)
-  # Already in cache, be silent
-  SET(DEVIL_FIND_QUIETLY TRUE)
-ENDIF (DEVIL_INCLUDE_DIR)
-
-FIND_LIBRARY(DEVIL_IL_LIBRARY
-  NAMES IL devil
-  PATHS
-  ${PROJECT_BINARY_DIR}/lib64
-  ${PROJECT_BINARY_DIR}/lib
-  ${PROJECT_SOURCE_DIR}/lib64
-  ${PROJECT_SOURCE_DIR}/lib
-  ENV LD_LIBRARY_PATH
-  ENV LIBRARY_PATH
-  /usr/lib64
-  /usr/lib
-  /usr/local/lib64
-  /usr/local/lib
-  NO_DEFAULT_PATH
-)
-FIND_LIBRARY(DEVIL_IL_LIBRARY NAMES IL devil)
-
-FIND_LIBRARY(DEVIL_ILU_LIBRARY
-  NAMES ILU ilu
-  PATHS
-  ${PROJECT_BINARY_DIR}/lib64
-  ${PROJECT_BINARY_DIR}/lib
-  ${PROJECT_SOURCE_DIR}/lib64
-  ${PROJECT_SOURCE_DIR}/lib
-  ENV LD_LIBRARY_PATH
-  ENV LIBRARY_PATH
-  /usr/lib64
-  /usr/lib
-  /usr/local/lib64
-  /usr/local/lib
-  NO_DEFAULT_PATH
-)
-FIND_LIBRARY(DEVIL_ILU_LIBRARY NAMES ILU ilu)
-
-FIND_LIBRARY(DEVIL_ILUT_LIBRARY
-  NAMES ILUT ilut
-  PATHS
-  ${PROJECT_BINARY_DIR}/lib64
-  ${PROJECT_BINARY_DIR}/lib
-  ${PROJECT_SOURCE_DIR}/lib64
-  ${PROJECT_SOURCE_DIR}/lib
-  ENV LD_LIBRARY_PATH
-  ENV LIBRARY_PATH
-  /usr/lib64
-  /usr/lib
-  /usr/local/lib64
-  /usr/local/lib
-  NO_DEFAULT_PATH
-)
-FIND_LIBRARY(DEVIL_ILUT_LIBRARY NAMES ILUT ilut)
-
-GET_FILENAME_COMPONENT(DEVIL_LIBRARY_DIR &quot;${DEVIL_IL_LIBRARY}&quot; PATH)
-GET_FILENAME_COMPONENT(DEVIL_LIBRARY_SUPER_DIR &quot;${DEVIL_LIBRARY_DIR}&quot; PATH)
-
-FIND_PATH(DEVIL_INCLUDE_DIR IL/il.h
-  PATHS
-  ${PROJECT_BINARY_DIR}/include
-  ${PROJECT_SOURCE_DIR}/include
-  ${DEVIL_LIBRARY_SUPER_DIR}/include
-  ENV CPATH
-  /usr/local/include
-  /usr/include
-  NO_DEFAULT_PATH
-)
-FIND_PATH(DEVIL_INCLUDE_DIR IL/il.h)
-
-IF (DEVIL_INCLUDE_DIR AND DEVIL_IL_LIBRARY)
-   SET(DEVIL_FOUND TRUE)
-   SET(DEVIL_LIBRARIES ${DEVIL_IL_LIBRARY} ${DEVIL_ILU_LIBRARY} ${DEVIL_ILUT_LIBRARY})
-ELSE (DEVIL_INCLUDE_DIR AND DEVIL_IL_LIBRARY)
-   SET(DEVIL_FOUND FALSE)
-   SET(DEVIL_LIBRARIES)
-ENDIF (DEVIL_INCLUDE_DIR AND DEVIL_IL_LIBRARY)
-
-IF (DEVIL_FOUND)
-   IF (NOT DEVIL_FIND_QUIETLY)
-      MESSAGE(STATUS &quot;Found DEVIL: ${DEVIL_LIBRARIES}&quot;)
-   ENDIF (NOT DEVIL_FIND_QUIETLY)
-ELSE (DEVIL_FOUND)
-   IF (DEVIL_FIND_REQUIRED)
-      MESSAGE(FATAL_ERROR &quot;Could NOT find DEVIL library&quot;)
-   ENDIF (DEVIL_FIND_REQUIRED)
-ENDIF (DEVIL_FOUND)
-
-MARK_AS_ADVANCED(
-  DEVIL_LIBRARIES
-  DEVIL_INCLUDE_DIR
-  DEVIL_IL_LIBRARY
-  DEVIL_ILU_LIBRARY
-  DEVIL_ILUT_LIBRARY
-  ) 

Copied: branches/gml/rts/build/cmake/FindDevil.cmake (from rev 5960, trunk/rts/build/cmake/FindDevil.cmake)
===================================================================
--- branches/gml/rts/build/cmake/FindDevil.cmake	                        (rev 0)
+++ branches/gml/rts/build/cmake/FindDevil.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,111 @@
+# Downloaded from: <A HREF="http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/cmake/">http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/cmake/</A>
+# License: GPL v2, <A HREF="http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/COPYING">http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/COPYING</A>
+#
+# Modifications:
+# 2008.01.16 Tobi Vollebregt -- changed Devil-&gt;DEVIL for consistency
+#                            -- added devil, ilu, ilut alternative names for MinGW
+#                            -- removed &quot;looking for devil&quot; status message
+
+# - Find devil
+# Find the native DevIL includes and library
+#
+#  DEVIL_INCLUDE_DIR - where to find IL/il.h, etc.
+#  DEVIL_LIBRARIES   - List of libraries when using IL.
+#  DEVIL_FOUND       - True if IL found.
+
+IF (DEVIL_INCLUDE_DIR)
+  # Already in cache, be silent
+  SET(DEVIL_FIND_QUIETLY TRUE)
+ENDIF (DEVIL_INCLUDE_DIR)
+
+FIND_LIBRARY(DEVIL_IL_LIBRARY
+  NAMES IL devil
+  PATHS
+  ${PROJECT_BINARY_DIR}/lib64
+  ${PROJECT_BINARY_DIR}/lib
+  ${PROJECT_SOURCE_DIR}/lib64
+  ${PROJECT_SOURCE_DIR}/lib
+  ENV LD_LIBRARY_PATH
+  ENV LIBRARY_PATH
+  /usr/lib64
+  /usr/lib
+  /usr/local/lib64
+  /usr/local/lib
+  NO_DEFAULT_PATH
+)
+FIND_LIBRARY(DEVIL_IL_LIBRARY NAMES IL devil)
+
+FIND_LIBRARY(DEVIL_ILU_LIBRARY
+  NAMES ILU ilu
+  PATHS
+  ${PROJECT_BINARY_DIR}/lib64
+  ${PROJECT_BINARY_DIR}/lib
+  ${PROJECT_SOURCE_DIR}/lib64
+  ${PROJECT_SOURCE_DIR}/lib
+  ENV LD_LIBRARY_PATH
+  ENV LIBRARY_PATH
+  /usr/lib64
+  /usr/lib
+  /usr/local/lib64
+  /usr/local/lib
+  NO_DEFAULT_PATH
+)
+FIND_LIBRARY(DEVIL_ILU_LIBRARY NAMES ILU ilu)
+
+FIND_LIBRARY(DEVIL_ILUT_LIBRARY
+  NAMES ILUT ilut
+  PATHS
+  ${PROJECT_BINARY_DIR}/lib64
+  ${PROJECT_BINARY_DIR}/lib
+  ${PROJECT_SOURCE_DIR}/lib64
+  ${PROJECT_SOURCE_DIR}/lib
+  ENV LD_LIBRARY_PATH
+  ENV LIBRARY_PATH
+  /usr/lib64
+  /usr/lib
+  /usr/local/lib64
+  /usr/local/lib
+  NO_DEFAULT_PATH
+)
+FIND_LIBRARY(DEVIL_ILUT_LIBRARY NAMES ILUT ilut)
+
+GET_FILENAME_COMPONENT(DEVIL_LIBRARY_DIR &quot;${DEVIL_IL_LIBRARY}&quot; PATH)
+GET_FILENAME_COMPONENT(DEVIL_LIBRARY_SUPER_DIR &quot;${DEVIL_LIBRARY_DIR}&quot; PATH)
+
+FIND_PATH(DEVIL_INCLUDE_DIR IL/il.h
+  PATHS
+  ${PROJECT_BINARY_DIR}/include
+  ${PROJECT_SOURCE_DIR}/include
+  ${DEVIL_LIBRARY_SUPER_DIR}/include
+  ENV CPATH
+  /usr/local/include
+  /usr/include
+  NO_DEFAULT_PATH
+)
+FIND_PATH(DEVIL_INCLUDE_DIR IL/il.h)
+
+IF (DEVIL_INCLUDE_DIR AND DEVIL_IL_LIBRARY)
+   SET(DEVIL_FOUND TRUE)
+   SET(DEVIL_LIBRARIES ${DEVIL_IL_LIBRARY} ${DEVIL_ILU_LIBRARY} ${DEVIL_ILUT_LIBRARY})
+ELSE (DEVIL_INCLUDE_DIR AND DEVIL_IL_LIBRARY)
+   SET(DEVIL_FOUND FALSE)
+   SET(DEVIL_LIBRARIES)
+ENDIF (DEVIL_INCLUDE_DIR AND DEVIL_IL_LIBRARY)
+
+IF (DEVIL_FOUND)
+   IF (NOT DEVIL_FIND_QUIETLY)
+      MESSAGE(STATUS &quot;Found DEVIL: ${DEVIL_LIBRARIES}&quot;)
+   ENDIF (NOT DEVIL_FIND_QUIETLY)
+ELSE (DEVIL_FOUND)
+   IF (DEVIL_FIND_REQUIRED)
+      MESSAGE(FATAL_ERROR &quot;Could NOT find DEVIL library&quot;)
+   ENDIF (DEVIL_FIND_REQUIRED)
+ENDIF (DEVIL_FOUND)
+
+MARK_AS_ADVANCED(
+  DEVIL_LIBRARIES
+  DEVIL_INCLUDE_DIR
+  DEVIL_IL_LIBRARY
+  DEVIL_ILU_LIBRARY
+  DEVIL_ILUT_LIBRARY
+  ) 

Deleted: branches/gml/rts/build/cmake/FindFreetype.cmake
===================================================================
--- trunk/rts/build/cmake/FindFreetype.cmake	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/cmake/FindFreetype.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,84 +0,0 @@
-# Downloaded from: <A HREF="http://websvn.kde.org/trunk/KDE/kdelibs/cmake/modules/">http://websvn.kde.org/trunk/KDE/kdelibs/cmake/modules/</A>
-# License: see the accompanying COPYING-CMAKE-SCRIPTS file
-#
-# Modifications:
-# 2008.01.16 Tobi Vollebregt -- don't use freetype-config on MinGW
-#                            -- special case FREETYPE_INCLUDE_DIR for MinGW
-
-# - Try to find the freetype library
-# Once done this will define
-#
-#  FREETYPE_FOUND - system has Freetype
-#  FREETYPE_INCLUDE_DIRS - the FREETYPE include directories
-#  FREETYPE_LIBRARIES - Link these to use FREETYPE
-#  FREETYPE_INCLUDE_DIR - internal
-
-# Copyright (c) 2006, Laurent Montel, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">montel at kde.org</A>&gt;
-#
-# Redistribution and use is allowed according to the terms of the BSD license.
-# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
-
-if (FREETYPE_LIBRARIES AND FREETYPE_INCLUDE_DIR)
-
-  # in cache already
-  set(FREETYPE_FOUND TRUE)
-
-else (FREETYPE_LIBRARIES AND FREETYPE_INCLUDE_DIR)
-
-  find_program(FREETYPECONFIG_EXECUTABLE NAMES freetype-config PATHS
-     /opt/local/bin
-  )
-
-  #reset vars
-  set(FREETYPE_LIBRARIES)
-  set(FREETYPE_INCLUDE_DIR)
-
-  # if freetype-config has been found
-  if(FREETYPECONFIG_EXECUTABLE AND NOT MINGW)
-
-    exec_program(${FREETYPECONFIG_EXECUTABLE} ARGS --libs RETURN_VALUE _return_VALUE OUTPUT_VARIABLE FREETYPE_LIBRARIES)
-
-    exec_program(${FREETYPECONFIG_EXECUTABLE} ARGS --cflags RETURN_VALUE _return_VALUE OUTPUT_VARIABLE _freetype_pkgconfig_output)
-    if(FREETYPE_LIBRARIES AND _freetype_pkgconfig_output)
-      set(FREETYPE_FOUND TRUE)
-
-      # freetype-config can print out more than one -I, so we need to chop it up
-      # into a list and process each entry separately
-      separate_arguments(_freetype_pkgconfig_output)
-      foreach(value ${_freetype_pkgconfig_output})
-        string(REGEX REPLACE &quot;-I(.+)&quot; &quot;\\1&quot; value &quot;${value}&quot;)
-        set(FREETYPE_INCLUDE_DIR ${FREETYPE_INCLUDE_DIR} ${value})
-      endforeach(value)
-    endif(FREETYPE_LIBRARIES AND _freetype_pkgconfig_output)
-
-    set( FREETYPE_LIBRARIES ${FREETYPE_LIBRARIES} CACHE STRING &quot;The libraries for freetype&quot; )
-
-    mark_as_advanced(FREETYPE_LIBRARIES FREETYPE_INCLUDE_DIR)
-
-  else(FREETYPECONFIG_EXECUTABLE AND NOT MINGW)
-    if(MINGW)
-      find_path (FREETYPE_INCLUDE_DIR freetype/freetype.h)
-    else(MINGW)
-      find_path (FREETYPE_INCLUDE_DIR freetype2/freetype/freetype.h)
-      set (FREETYPE_INCLUDE_DIR ${FREETYPE_INCLUDE_DIR}/freetype2)
-    endif(MINGW)
-    find_library(FREETYPE_LIBRARIES freetype)
-    if(FREETYPE_INCLUDE_DIR AND FREETYPE_LIBRARIES)
-        set(FREETYPE_FOUND TRUE)
-    endif(FREETYPE_INCLUDE_DIR AND FREETYPE_LIBRARIES)
-  endif(FREETYPECONFIG_EXECUTABLE AND NOT MINGW)
-
-
-  if (FREETYPE_FOUND)
-    if (NOT Freetype_FIND_QUIETLY)
-       message(STATUS &quot;Found Freetype: ${FREETYPE_LIBRARIES}&quot;)
-    endif (NOT Freetype_FIND_QUIETLY)
-  else (FREETYPE_FOUND)
-    if (Freetype_FIND_REQUIRED)
-       message(FATAL_ERROR &quot;Could not find FreeType library&quot;)
-    endif (Freetype_FIND_REQUIRED)
-  endif (FREETYPE_FOUND)
-
-endif (FREETYPE_LIBRARIES AND FREETYPE_INCLUDE_DIR)
-
-set(FREETYPE_INCLUDE_DIRS &quot;${FREETYPE_INCLUDE_DIR}&quot;) 

Copied: branches/gml/rts/build/cmake/FindFreetype.cmake (from rev 5960, trunk/rts/build/cmake/FindFreetype.cmake)
===================================================================
--- branches/gml/rts/build/cmake/FindFreetype.cmake	                        (rev 0)
+++ branches/gml/rts/build/cmake/FindFreetype.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,84 @@
+# Downloaded from: <A HREF="http://websvn.kde.org/trunk/KDE/kdelibs/cmake/modules/">http://websvn.kde.org/trunk/KDE/kdelibs/cmake/modules/</A>
+# License: see the accompanying COPYING-CMAKE-SCRIPTS file
+#
+# Modifications:
+# 2008.01.16 Tobi Vollebregt -- don't use freetype-config on MinGW
+#                            -- special case FREETYPE_INCLUDE_DIR for MinGW
+
+# - Try to find the freetype library
+# Once done this will define
+#
+#  FREETYPE_FOUND - system has Freetype
+#  FREETYPE_INCLUDE_DIRS - the FREETYPE include directories
+#  FREETYPE_LIBRARIES - Link these to use FREETYPE
+#  FREETYPE_INCLUDE_DIR - internal
+
+# Copyright (c) 2006, Laurent Montel, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">montel at kde.org</A>&gt;
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+if (FREETYPE_LIBRARIES AND FREETYPE_INCLUDE_DIR)
+
+  # in cache already
+  set(FREETYPE_FOUND TRUE)
+
+else (FREETYPE_LIBRARIES AND FREETYPE_INCLUDE_DIR)
+
+  find_program(FREETYPECONFIG_EXECUTABLE NAMES freetype-config PATHS
+     /opt/local/bin
+  )
+
+  #reset vars
+  set(FREETYPE_LIBRARIES)
+  set(FREETYPE_INCLUDE_DIR)
+
+  # if freetype-config has been found
+  if(FREETYPECONFIG_EXECUTABLE AND NOT MINGW)
+
+    exec_program(${FREETYPECONFIG_EXECUTABLE} ARGS --libs RETURN_VALUE _return_VALUE OUTPUT_VARIABLE FREETYPE_LIBRARIES)
+
+    exec_program(${FREETYPECONFIG_EXECUTABLE} ARGS --cflags RETURN_VALUE _return_VALUE OUTPUT_VARIABLE _freetype_pkgconfig_output)
+    if(FREETYPE_LIBRARIES AND _freetype_pkgconfig_output)
+      set(FREETYPE_FOUND TRUE)
+
+      # freetype-config can print out more than one -I, so we need to chop it up
+      # into a list and process each entry separately
+      separate_arguments(_freetype_pkgconfig_output)
+      foreach(value ${_freetype_pkgconfig_output})
+        string(REGEX REPLACE &quot;-I(.+)&quot; &quot;\\1&quot; value &quot;${value}&quot;)
+        set(FREETYPE_INCLUDE_DIR ${FREETYPE_INCLUDE_DIR} ${value})
+      endforeach(value)
+    endif(FREETYPE_LIBRARIES AND _freetype_pkgconfig_output)
+
+    set( FREETYPE_LIBRARIES ${FREETYPE_LIBRARIES} CACHE STRING &quot;The libraries for freetype&quot; )
+
+    mark_as_advanced(FREETYPE_LIBRARIES FREETYPE_INCLUDE_DIR)
+
+  else(FREETYPECONFIG_EXECUTABLE AND NOT MINGW)
+    if(MINGW)
+      find_path (FREETYPE_INCLUDE_DIR freetype/freetype.h)
+    else(MINGW)
+      find_path (FREETYPE_INCLUDE_DIR freetype2/freetype/freetype.h)
+      set (FREETYPE_INCLUDE_DIR ${FREETYPE_INCLUDE_DIR}/freetype2)
+    endif(MINGW)
+    find_library(FREETYPE_LIBRARIES freetype)
+    if(FREETYPE_INCLUDE_DIR AND FREETYPE_LIBRARIES)
+        set(FREETYPE_FOUND TRUE)
+    endif(FREETYPE_INCLUDE_DIR AND FREETYPE_LIBRARIES)
+  endif(FREETYPECONFIG_EXECUTABLE AND NOT MINGW)
+
+
+  if (FREETYPE_FOUND)
+    if (NOT Freetype_FIND_QUIETLY)
+       message(STATUS &quot;Found Freetype: ${FREETYPE_LIBRARIES}&quot;)
+    endif (NOT Freetype_FIND_QUIETLY)
+  else (FREETYPE_FOUND)
+    if (Freetype_FIND_REQUIRED)
+       message(FATAL_ERROR &quot;Could not find FreeType library&quot;)
+    endif (Freetype_FIND_REQUIRED)
+  endif (FREETYPE_FOUND)
+
+endif (FREETYPE_LIBRARIES AND FREETYPE_INCLUDE_DIR)
+
+set(FREETYPE_INCLUDE_DIRS &quot;${FREETYPE_INCLUDE_DIR}&quot;) 

Deleted: branches/gml/rts/build/cmake/FindGLEW.cmake
===================================================================
--- trunk/rts/build/cmake/FindGLEW.cmake	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/cmake/FindGLEW.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,60 +0,0 @@
-# Downloaded from: <A HREF="http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/cmake/">http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/cmake/</A>
-# License: GPL v2, <A HREF="http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/COPYING">http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/COPYING</A>
-
-# - Try to find GLEW
-# Once done this will define
-#
-#  GLEW_FOUND - system has GLEW
-#  GLEW_INCLUDE_DIR - the GLEW include directory
-#  GLEW_LIBRARIES - Link these to use GLEW
-#  GLEW_DEFINITIONS - Compiler switches required for using GLEW
-#
-
-
-FIND_PATH(GLEW_INCLUDE_DIR NAMES GL/glew.h
-  PATHS
-  ${PROJECT_BINARY_DIR}/include
-  ${PROJECT_SOURCE_DIR}/include
-  ENV CPATH
-  /usr/include
-  /usr/local/include
-  NO_DEFAULT_PATH
-)
-FIND_PATH(GLEW_INCLUDE_DIR NAMES GL/glew.h)
-
-FIND_LIBRARY(GLEW_LIBRARIES NAMES GLEW
-  PATHS
-  ${PROJECT_BINARY_DIR}/lib64
-  ${PROJECT_BINARY_DIR}/lib
-  ${PROJECT_SOURCE_DIR}/lib64
-  ${PROJECT_SOURCE_DIR}/lib
-  ENV LD_LIBRARY_PATH
-  ENV LIBRARY_PATH
-  /usr/lib64
-  /usr/lib
-  /usr/local/lib64
-  /usr/local/lib
-  NO_DEFAULT_PATH
-)
-IF(WIN32)
-  FIND_LIBRARY(GLEW_LIBRARIES NAMES GLEW glew32)
-ELSE(WIN32)
-  FIND_LIBRARY(GLEW_LIBRARIES NAMES GLEW)
-ENDIF(WIN32)
-
-IF(GLEW_INCLUDE_DIR AND GLEW_LIBRARIES)
-   SET(GLEW_FOUND TRUE)
-ENDIF(GLEW_INCLUDE_DIR AND GLEW_LIBRARIES)
-
-IF(GLEW_FOUND)
-  IF(NOT GLEW_FIND_QUIETLY)
-    MESSAGE(STATUS &quot;Found GLEW: ${GLEW_LIBRARIES}&quot;)
-  ENDIF(NOT GLEW_FIND_QUIETLY)
-ELSE(GLEW_FOUND)
-  IF(GLEW_FIND_REQUIRED)
-    MESSAGE(FATAL_ERROR &quot;Could not find GLEW&quot;)
-  ENDIF(GLEW_FIND_REQUIRED)
-ENDIF(GLEW_FOUND)
-
-# show the GLEW_INCLUDE_DIR and GLEW_LIBRARIES variables only in the advanced view
-MARK_AS_ADVANCED(GLEW_INCLUDE_DIR GLEW_LIBRARIES )

Copied: branches/gml/rts/build/cmake/FindGLEW.cmake (from rev 5960, trunk/rts/build/cmake/FindGLEW.cmake)
===================================================================
--- branches/gml/rts/build/cmake/FindGLEW.cmake	                        (rev 0)
+++ branches/gml/rts/build/cmake/FindGLEW.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,60 @@
+# Downloaded from: <A HREF="http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/cmake/">http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/cmake/</A>
+# License: GPL v2, <A HREF="http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/COPYING">http://www-id.imag.fr/FLOWVR/manual/flowvr-suite-src/flowvr-render/COPYING</A>
+
+# - Try to find GLEW
+# Once done this will define
+#
+#  GLEW_FOUND - system has GLEW
+#  GLEW_INCLUDE_DIR - the GLEW include directory
+#  GLEW_LIBRARIES - Link these to use GLEW
+#  GLEW_DEFINITIONS - Compiler switches required for using GLEW
+#
+
+
+FIND_PATH(GLEW_INCLUDE_DIR NAMES GL/glew.h
+  PATHS
+  ${PROJECT_BINARY_DIR}/include
+  ${PROJECT_SOURCE_DIR}/include
+  ENV CPATH
+  /usr/include
+  /usr/local/include
+  NO_DEFAULT_PATH
+)
+FIND_PATH(GLEW_INCLUDE_DIR NAMES GL/glew.h)
+
+FIND_LIBRARY(GLEW_LIBRARIES NAMES GLEW
+  PATHS
+  ${PROJECT_BINARY_DIR}/lib64
+  ${PROJECT_BINARY_DIR}/lib
+  ${PROJECT_SOURCE_DIR}/lib64
+  ${PROJECT_SOURCE_DIR}/lib
+  ENV LD_LIBRARY_PATH
+  ENV LIBRARY_PATH
+  /usr/lib64
+  /usr/lib
+  /usr/local/lib64
+  /usr/local/lib
+  NO_DEFAULT_PATH
+)
+IF(WIN32)
+  FIND_LIBRARY(GLEW_LIBRARIES NAMES GLEW glew32)
+ELSE(WIN32)
+  FIND_LIBRARY(GLEW_LIBRARIES NAMES GLEW)
+ENDIF(WIN32)
+
+IF(GLEW_INCLUDE_DIR AND GLEW_LIBRARIES)
+   SET(GLEW_FOUND TRUE)
+ENDIF(GLEW_INCLUDE_DIR AND GLEW_LIBRARIES)
+
+IF(GLEW_FOUND)
+  IF(NOT GLEW_FIND_QUIETLY)
+    MESSAGE(STATUS &quot;Found GLEW: ${GLEW_LIBRARIES}&quot;)
+  ENDIF(NOT GLEW_FIND_QUIETLY)
+ELSE(GLEW_FOUND)
+  IF(GLEW_FIND_REQUIRED)
+    MESSAGE(FATAL_ERROR &quot;Could not find GLEW&quot;)
+  ENDIF(GLEW_FIND_REQUIRED)
+ENDIF(GLEW_FOUND)
+
+# show the GLEW_INCLUDE_DIR and GLEW_LIBRARIES variables only in the advanced view
+MARK_AS_ADVANCED(GLEW_INCLUDE_DIR GLEW_LIBRARIES )

Deleted: branches/gml/rts/build/cmake/FindOggVorbis.cmake
===================================================================
--- trunk/rts/build/cmake/FindOggVorbis.cmake	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/cmake/FindOggVorbis.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,95 +0,0 @@
-# Downloaded from: <A HREF="http://websvn.kde.org/trunk/KDE/kdelibs/cmake/modules/">http://websvn.kde.org/trunk/KDE/kdelibs/cmake/modules/</A>
-# License: see the accompanying COPYING-CMAKE-SCRIPTS file
-#
-# Modifications:
-# 2008.01.16 Tobi Vollebregt -- Moved ${OGG_LIBRARY} to the back of OGGVORBIS_LIBRARIES,
-#                               this allows vorbis to link to ogg on MinGW.
-#                            -- Moved ${VORBIS_LIBRARY} just before OGGVORBIS_LIBRARIES,
-#                               this allows vorbis{file,enc} to link to vorbis on MinGW.
-
-# - Try to find the OggVorbis libraries
-# Once done this will define
-#
-#  OGGVORBIS_FOUND - system has OggVorbis
-#  OGGVORBIS_VERSION - set either to 1 or 2
-#  OGGVORBIS_INCLUDE_DIR - the OggVorbis include directory
-#  OGGVORBIS_LIBRARIES - The libraries needed to use OggVorbis
-#  OGG_LIBRARY         - The Ogg library
-#  VORBIS_LIBRARY      - The Vorbis library
-#  VORBISFILE_LIBRARY  - The VorbisFile library
-#  VORBISENC_LIBRARY   - The VorbisEnc library
-
-# Copyright (c) 2006, Richard Laerkaeng, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">richard at goteborg.utfors.se</A>&gt;
-#
-# Redistribution and use is allowed according to the terms of the BSD license.
-# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
-
-
-include (CheckLibraryExists)
-
-find_path(VORBIS_INCLUDE_DIR vorbis/vorbisfile.h)
-find_path(OGG_INCLUDE_DIR ogg/ogg.h)
-
-find_library(OGG_LIBRARY NAMES ogg)
-find_library(VORBIS_LIBRARY NAMES vorbis)
-find_library(VORBISFILE_LIBRARY NAMES vorbisfile)
-find_library(VORBISENC_LIBRARY NAMES vorbisenc)
-
-
-if (VORBIS_INCLUDE_DIR AND VORBIS_LIBRARY AND VORBISFILE_LIBRARY AND VORBISENC_LIBRARY)
-   set(OGGVORBIS_FOUND TRUE)
-
-   set(OGGVORBIS_LIBRARIES ${OGG_LIBRARY} ${VORBIS_LIBRARY} ${VORBISFILE_LIBRARY} ${VORBISENC_LIBRARY})
-
-   set(_CMAKE_REQUIRED_LIBRARIES_TMP ${CMAKE_REQUIRED_LIBRARIES})
-   set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${OGGVORBIS_LIBRARIES})
-   check_library_exists(vorbis vorbis_bitrate_addblock &quot;&quot; HAVE_LIBVORBISENC2)
-   set(CMAKE_REQUIRED_LIBRARIES ${_CMAKE_REQUIRED_LIBRARIES_TMP})
-
-   if (HAVE_LIBVORBISENC2)
-      set (OGGVORBIS_VERSION 2)
-   else (HAVE_LIBVORBISENC2)
-      set (OGGVORBIS_VERSION 1)
-   endif (HAVE_LIBVORBISENC2)
-
-else (VORBIS_INCLUDE_DIR AND VORBIS_LIBRARY AND VORBISFILE_LIBRARY AND VORBISENC_LIBRARY)
-   set (OGGVORBIS_VERSION)
-   set(OGGVORBIS_FOUND FALSE)
-endif (VORBIS_INCLUDE_DIR AND VORBIS_LIBRARY AND VORBISFILE_LIBRARY AND VORBISENC_LIBRARY)
-
-
-if (OGGVORBIS_FOUND)
-   if (NOT OggVorbis_FIND_QUIETLY)
-      message(STATUS &quot;Found OggVorbis: ${OGGVORBIS_LIBRARIES}&quot;)
-   endif (NOT OggVorbis_FIND_QUIETLY)
-else (OGGVORBIS_FOUND)
-   if (OggVorbis_FIND_REQUIRED)
-      message(FATAL_ERROR &quot;Could NOT find OggVorbis libraries&quot;)
-   endif (OggVorbis_FIND_REQUIRED)
-   if (NOT OggVorbis_FIND_QUITELY)
-      message(STATUS &quot;Could NOT find OggVorbis libraries&quot;)
-   endif (NOT OggVorbis_FIND_QUITELY)
-endif (OGGVORBIS_FOUND)
-
-#check_include_files(vorbis/vorbisfile.h HAVE_VORBISFILE_H)
-#check_library_exists(ogg ogg_page_version &quot;&quot; HAVE_LIBOGG)
-#check_library_exists(vorbis vorbis_info_init &quot;&quot; HAVE_LIBVORBIS)
-#check_library_exists(vorbisfile ov_open &quot;&quot; HAVE_LIBVORBISFILE)
-#check_library_exists(vorbisenc vorbis_info_clear &quot;&quot; HAVE_LIBVORBISENC)
-#check_library_exists(vorbis vorbis_bitrate_addblock &quot;&quot; HAVE_LIBVORBISENC2)
-
-#if (HAVE_LIBOGG AND HAVE_VORBISFILE_H AND HAVE_LIBVORBIS AND HAVE_LIBVORBISFILE AND HAVE_LIBVORBISENC)
-#    message(STATUS &quot;Ogg/Vorbis found&quot;)
-#    set (VORBIS_LIBS &quot;-lvorbis -logg&quot;)
-#    set (VORBISFILE_LIBS &quot;-lvorbisfile&quot;)
-#    set (VORBISENC_LIBS &quot;-lvorbisenc&quot;)
-#    set (OGGVORBIS_FOUND TRUE)
-#    if (HAVE_LIBVORBISENC2)
-#        set (HAVE_VORBIS 2)
-#    else (HAVE_LIBVORBISENC2)
-#        set (HAVE_VORBIS 1)
-#    endif (HAVE_LIBVORBISENC2)
-#else (HAVE_LIBOGG AND HAVE_VORBISFILE_H AND HAVE_LIBVORBIS AND HAVE_LIBVORBISFILE AND HAVE_LIBVORBISENC)
-#    message(STATUS &quot;Ogg/Vorbis not found&quot;)
-#endif (HAVE_LIBOGG AND HAVE_VORBISFILE_H AND HAVE_LIBVORBIS AND HAVE_LIBVORBISFILE AND HAVE_LIBVORBISENC)
-

Copied: branches/gml/rts/build/cmake/FindOggVorbis.cmake (from rev 5960, trunk/rts/build/cmake/FindOggVorbis.cmake)
===================================================================
--- branches/gml/rts/build/cmake/FindOggVorbis.cmake	                        (rev 0)
+++ branches/gml/rts/build/cmake/FindOggVorbis.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,95 @@
+# Downloaded from: <A HREF="http://websvn.kde.org/trunk/KDE/kdelibs/cmake/modules/">http://websvn.kde.org/trunk/KDE/kdelibs/cmake/modules/</A>
+# License: see the accompanying COPYING-CMAKE-SCRIPTS file
+#
+# Modifications:
+# 2008.01.16 Tobi Vollebregt -- Moved ${OGG_LIBRARY} to the back of OGGVORBIS_LIBRARIES,
+#                               this allows vorbis to link to ogg on MinGW.
+#                            -- Moved ${VORBIS_LIBRARY} just before OGGVORBIS_LIBRARIES,
+#                               this allows vorbis{file,enc} to link to vorbis on MinGW.
+
+# - Try to find the OggVorbis libraries
+# Once done this will define
+#
+#  OGGVORBIS_FOUND - system has OggVorbis
+#  OGGVORBIS_VERSION - set either to 1 or 2
+#  OGGVORBIS_INCLUDE_DIR - the OggVorbis include directory
+#  OGGVORBIS_LIBRARIES - The libraries needed to use OggVorbis
+#  OGG_LIBRARY         - The Ogg library
+#  VORBIS_LIBRARY      - The Vorbis library
+#  VORBISFILE_LIBRARY  - The VorbisFile library
+#  VORBISENC_LIBRARY   - The VorbisEnc library
+
+# Copyright (c) 2006, Richard Laerkaeng, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">richard at goteborg.utfors.se</A>&gt;
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+include (CheckLibraryExists)
+
+find_path(VORBIS_INCLUDE_DIR vorbis/vorbisfile.h)
+find_path(OGG_INCLUDE_DIR ogg/ogg.h)
+
+find_library(OGG_LIBRARY NAMES ogg)
+find_library(VORBIS_LIBRARY NAMES vorbis)
+find_library(VORBISFILE_LIBRARY NAMES vorbisfile)
+find_library(VORBISENC_LIBRARY NAMES vorbisenc)
+
+
+if (VORBIS_INCLUDE_DIR AND VORBIS_LIBRARY AND VORBISFILE_LIBRARY AND VORBISENC_LIBRARY)
+   set(OGGVORBIS_FOUND TRUE)
+
+   set(OGGVORBIS_LIBRARIES ${OGG_LIBRARY} ${VORBIS_LIBRARY} ${VORBISFILE_LIBRARY} ${VORBISENC_LIBRARY})
+
+   set(_CMAKE_REQUIRED_LIBRARIES_TMP ${CMAKE_REQUIRED_LIBRARIES})
+   set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${OGGVORBIS_LIBRARIES})
+   check_library_exists(vorbis vorbis_bitrate_addblock &quot;&quot; HAVE_LIBVORBISENC2)
+   set(CMAKE_REQUIRED_LIBRARIES ${_CMAKE_REQUIRED_LIBRARIES_TMP})
+
+   if (HAVE_LIBVORBISENC2)
+      set (OGGVORBIS_VERSION 2)
+   else (HAVE_LIBVORBISENC2)
+      set (OGGVORBIS_VERSION 1)
+   endif (HAVE_LIBVORBISENC2)
+
+else (VORBIS_INCLUDE_DIR AND VORBIS_LIBRARY AND VORBISFILE_LIBRARY AND VORBISENC_LIBRARY)
+   set (OGGVORBIS_VERSION)
+   set(OGGVORBIS_FOUND FALSE)
+endif (VORBIS_INCLUDE_DIR AND VORBIS_LIBRARY AND VORBISFILE_LIBRARY AND VORBISENC_LIBRARY)
+
+
+if (OGGVORBIS_FOUND)
+   if (NOT OggVorbis_FIND_QUIETLY)
+      message(STATUS &quot;Found OggVorbis: ${OGGVORBIS_LIBRARIES}&quot;)
+   endif (NOT OggVorbis_FIND_QUIETLY)
+else (OGGVORBIS_FOUND)
+   if (OggVorbis_FIND_REQUIRED)
+      message(FATAL_ERROR &quot;Could NOT find OggVorbis libraries&quot;)
+   endif (OggVorbis_FIND_REQUIRED)
+   if (NOT OggVorbis_FIND_QUITELY)
+      message(STATUS &quot;Could NOT find OggVorbis libraries&quot;)
+   endif (NOT OggVorbis_FIND_QUITELY)
+endif (OGGVORBIS_FOUND)
+
+#check_include_files(vorbis/vorbisfile.h HAVE_VORBISFILE_H)
+#check_library_exists(ogg ogg_page_version &quot;&quot; HAVE_LIBOGG)
+#check_library_exists(vorbis vorbis_info_init &quot;&quot; HAVE_LIBVORBIS)
+#check_library_exists(vorbisfile ov_open &quot;&quot; HAVE_LIBVORBISFILE)
+#check_library_exists(vorbisenc vorbis_info_clear &quot;&quot; HAVE_LIBVORBISENC)
+#check_library_exists(vorbis vorbis_bitrate_addblock &quot;&quot; HAVE_LIBVORBISENC2)
+
+#if (HAVE_LIBOGG AND HAVE_VORBISFILE_H AND HAVE_LIBVORBIS AND HAVE_LIBVORBISFILE AND HAVE_LIBVORBISENC)
+#    message(STATUS &quot;Ogg/Vorbis found&quot;)
+#    set (VORBIS_LIBS &quot;-lvorbis -logg&quot;)
+#    set (VORBISFILE_LIBS &quot;-lvorbisfile&quot;)
+#    set (VORBISENC_LIBS &quot;-lvorbisenc&quot;)
+#    set (OGGVORBIS_FOUND TRUE)
+#    if (HAVE_LIBVORBISENC2)
+#        set (HAVE_VORBIS 2)
+#    else (HAVE_LIBVORBISENC2)
+#        set (HAVE_VORBIS 1)
+#    endif (HAVE_LIBVORBISENC2)
+#else (HAVE_LIBOGG AND HAVE_VORBISFILE_H AND HAVE_LIBVORBIS AND HAVE_LIBVORBISFILE AND HAVE_LIBVORBISENC)
+#    message(STATUS &quot;Ogg/Vorbis not found&quot;)
+#endif (HAVE_LIBOGG AND HAVE_VORBISFILE_H AND HAVE_LIBVORBIS AND HAVE_LIBVORBISFILE AND HAVE_LIBVORBISENC)
+

Deleted: branches/gml/rts/build/cmake/FindWin32Libs.cmake
===================================================================
--- trunk/rts/build/cmake/FindWin32Libs.cmake	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/cmake/FindWin32Libs.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,94 +0,0 @@
-# - Try to find some win32-only libraries needed to compile Spring
-# Once done this will define
-#
-# WIN32_FOUND - System has the required libraries
-# WIN32_LIBRARIES - Link these
-#
-
-SET(WIN32_FOUND TRUE)
-
-IF(MINGW)
-	SET(WIN32_LIBRARY_SEARCHPATHS
-		/
-		/usr/lib
-		/usr/local/lib
-		$ENV{MINGDIR}/lib
-		NO_DEFAULT_PATH)
-ELSEIF(MINGW)
-	SET(WIN32_LIBRARY_SEARCHPATHS
-		/
-		/usr/lib
-		/usr/local/lib
-		NO_DEFAULT_PATH)
-ENDIF(MINGW)
-
-
-IF(NOT IMAGEHLP_LIBRARY)
-	FIND_LIBRARY(IMAGEHLP_LIBRARY imagehlp PATHS ${WIN32_LIBRARY_SEARCHPATHS})
-	IF(NOT IMAGEHLP_LIBRARY)
-		MESSAGE(SEND_ERROR &quot;Could not find win32 IMAGEHLP library.&quot;)
-		SET(WIN32_FOUND FALSE)
-	ENDIF(NOT IMAGEHLP_LIBRARY)
-ENDIF(NOT IMAGEHLP_LIBRARY)
-
-IF(NOT DSOUND_LIBRARY)
-	FIND_LIBRARY(DSOUND_LIBRARY dsound PATHS ${WIN32_LIBRARY_SEARCHPATHS})
-	IF(NOT DSOUND_LIBRARY)
-		MESSAGE(SEND_ERROR &quot;Could not find win32 DSOUND library.&quot;)
-		SET(WIN32_FOUND FALSE)
-	ENDIF(NOT DSOUND_LIBRARY)
-ENDIF(NOT DSOUND_LIBRARY)
-
-IF(NOT OLE32_LIBRARY)
-	FIND_LIBRARY(OLE32_LIBRARY ole32 PATHS ${WIN32_LIBRARY_SEARCHPATHS})
-	IF(NOT OLE32_LIBRARY)
-		MESSAGE(SEND_ERROR &quot;Could not find win32 OLE32 library.&quot;)
-		SET(WIN32_FOUND FALSE)
-	ENDIF(NOT OLE32_LIBRARY)
-ENDIF(NOT OLE32_LIBRARY)
-
-IF(NOT WS2_32_LIBRARY)
-	FIND_LIBRARY(WS2_32_LIBRARY ws2_32 PATHS ${WIN32_LIBRARY_SEARCHPATHS})
-	IF(NOT WS2_32_LIBRARY)
-		MESSAGE(SEND_ERROR &quot;Could not find win32 WS2_32 library.&quot;)
-		SET(WIN32_FOUND FALSE)
-	ENDIF(NOT WS2_32_LIBRARY)
-ENDIF(NOT WS2_32_LIBRARY)
-
-IF(NOT GDI32_LIBRARY)
-	FIND_LIBRARY(GDI32_LIBRARY gdi32 PATHS ${WIN32_LIBRARY_SEARCHPATHS})
-	IF(NOT GDI32_LIBRARY)
-		MESSAGE(SEND_ERROR &quot;Could not find win32 GDI32 library.&quot;)
-		SET(WIN32_FOUND FALSE)
-	ENDIF(NOT GDI32_LIBRARY)
-ENDIF(NOT GDI32_LIBRARY)
-
-IF(NOT WINMM_LIBRARY)
-	FIND_LIBRARY(WINMM_LIBRARY winmm PATHS ${WIN32_LIBRARY_SEARCHPATHS})
-	IF(NOT WINMM_LIBRARY)
-		MESSAGE(SEND_ERROR &quot;Could not find win32 WINMM library.&quot;)
-		SET(WIN32_FOUND FALSE)
-	ENDIF(NOT WINMM_LIBRARY)
-ENDIF(NOT WINMM_LIBRARY)
-
-IF(WIN32_FOUND)
-	SET(WIN32_LIBRARIES
-		${IMAGEHLP_LIBRARY} # for System/Platform/Win/CrashHandler.cpp
-		${DSOUND_LIBRARY}   # for System/Platform/Win/DxSound.cpp
-		${OLE32_LIBRARY}    # for System/Platform/Win/DxSound.cpp
-		${WS2_32_LIBRARY}	  # for System/Net/
-		#${GDI32_LIBRARY}    # FIXME: possibly for AVI recording?
-		${WINMM_LIBRARY}
-	)
-
-	MESSAGE(STATUS &quot;Found win32 libraries: ${WIN32_LIBRARIES}&quot;)
-ENDIF(WIN32_FOUND)
-
-MARK_AS_ADVANCED(
-	IMAGEHLP_LIBRARY
-	DSOUND_LIBRARY
-	OLE32_LIBRARY
-	WS2_32_LIBRARY
-	GDI32_LIBRARY
-	WINMM_LIBRARY
-) 

Copied: branches/gml/rts/build/cmake/FindWin32Libs.cmake (from rev 5960, trunk/rts/build/cmake/FindWin32Libs.cmake)
===================================================================
--- branches/gml/rts/build/cmake/FindWin32Libs.cmake	                        (rev 0)
+++ branches/gml/rts/build/cmake/FindWin32Libs.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,94 @@
+# - Try to find some win32-only libraries needed to compile Spring
+# Once done this will define
+#
+# WIN32_FOUND - System has the required libraries
+# WIN32_LIBRARIES - Link these
+#
+
+SET(WIN32_FOUND TRUE)
+
+IF(MINGW)
+	SET(WIN32_LIBRARY_SEARCHPATHS
+		/
+		/usr/lib
+		/usr/local/lib
+		$ENV{MINGDIR}/lib
+		NO_DEFAULT_PATH)
+ELSEIF(MINGW)
+	SET(WIN32_LIBRARY_SEARCHPATHS
+		/
+		/usr/lib
+		/usr/local/lib
+		NO_DEFAULT_PATH)
+ENDIF(MINGW)
+
+
+IF(NOT IMAGEHLP_LIBRARY)
+	FIND_LIBRARY(IMAGEHLP_LIBRARY imagehlp PATHS ${WIN32_LIBRARY_SEARCHPATHS})
+	IF(NOT IMAGEHLP_LIBRARY)
+		MESSAGE(SEND_ERROR &quot;Could not find win32 IMAGEHLP library.&quot;)
+		SET(WIN32_FOUND FALSE)
+	ENDIF(NOT IMAGEHLP_LIBRARY)
+ENDIF(NOT IMAGEHLP_LIBRARY)
+
+IF(NOT DSOUND_LIBRARY)
+	FIND_LIBRARY(DSOUND_LIBRARY dsound PATHS ${WIN32_LIBRARY_SEARCHPATHS})
+	IF(NOT DSOUND_LIBRARY)
+		MESSAGE(SEND_ERROR &quot;Could not find win32 DSOUND library.&quot;)
+		SET(WIN32_FOUND FALSE)
+	ENDIF(NOT DSOUND_LIBRARY)
+ENDIF(NOT DSOUND_LIBRARY)
+
+IF(NOT OLE32_LIBRARY)
+	FIND_LIBRARY(OLE32_LIBRARY ole32 PATHS ${WIN32_LIBRARY_SEARCHPATHS})
+	IF(NOT OLE32_LIBRARY)
+		MESSAGE(SEND_ERROR &quot;Could not find win32 OLE32 library.&quot;)
+		SET(WIN32_FOUND FALSE)
+	ENDIF(NOT OLE32_LIBRARY)
+ENDIF(NOT OLE32_LIBRARY)
+
+IF(NOT WS2_32_LIBRARY)
+	FIND_LIBRARY(WS2_32_LIBRARY ws2_32 PATHS ${WIN32_LIBRARY_SEARCHPATHS})
+	IF(NOT WS2_32_LIBRARY)
+		MESSAGE(SEND_ERROR &quot;Could not find win32 WS2_32 library.&quot;)
+		SET(WIN32_FOUND FALSE)
+	ENDIF(NOT WS2_32_LIBRARY)
+ENDIF(NOT WS2_32_LIBRARY)
+
+IF(NOT GDI32_LIBRARY)
+	FIND_LIBRARY(GDI32_LIBRARY gdi32 PATHS ${WIN32_LIBRARY_SEARCHPATHS})
+	IF(NOT GDI32_LIBRARY)
+		MESSAGE(SEND_ERROR &quot;Could not find win32 GDI32 library.&quot;)
+		SET(WIN32_FOUND FALSE)
+	ENDIF(NOT GDI32_LIBRARY)
+ENDIF(NOT GDI32_LIBRARY)
+
+IF(NOT WINMM_LIBRARY)
+	FIND_LIBRARY(WINMM_LIBRARY winmm PATHS ${WIN32_LIBRARY_SEARCHPATHS})
+	IF(NOT WINMM_LIBRARY)
+		MESSAGE(SEND_ERROR &quot;Could not find win32 WINMM library.&quot;)
+		SET(WIN32_FOUND FALSE)
+	ENDIF(NOT WINMM_LIBRARY)
+ENDIF(NOT WINMM_LIBRARY)
+
+IF(WIN32_FOUND)
+	SET(WIN32_LIBRARIES
+		${IMAGEHLP_LIBRARY} # for System/Platform/Win/CrashHandler.cpp
+		${DSOUND_LIBRARY}   # for System/Platform/Win/DxSound.cpp
+		${OLE32_LIBRARY}    # for System/Platform/Win/DxSound.cpp
+		${WS2_32_LIBRARY}	  # for System/Net/
+		#${GDI32_LIBRARY}    # FIXME: possibly for AVI recording?
+		${WINMM_LIBRARY}
+	)
+
+	MESSAGE(STATUS &quot;Found win32 libraries: ${WIN32_LIBRARIES}&quot;)
+ENDIF(WIN32_FOUND)
+
+MARK_AS_ADVANCED(
+	IMAGEHLP_LIBRARY
+	DSOUND_LIBRARY
+	OLE32_LIBRARY
+	WS2_32_LIBRARY
+	GDI32_LIBRARY
+	WINMM_LIBRARY
+) 

Deleted: branches/gml/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake
===================================================================
--- trunk/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -1,17 +0,0 @@
-# - Test whether the C++ compiler supports &quot;-fvisibility=hidden&quot;
-# Once done this will define
-#
-# VISIBILITY_HIDDEN - -fvisibility=hidden if supported, an empty string otherwise.
-#
-# Copyright (C) 2008 Tobi Vollebregt
-#
-
-IF(NOT DEFINED CMAKE_CXX_FLAGS)
-	INCLUDE(TestCXXAcceptsFlag)
-	CHECK_CXX_ACCEPTS_FLAG(-fvisibility=hidden VISIBILITY_HIDDEN)
-	IF(VISIBILITY_HIDDEN)
-		SET(VISIBILITY_HIDDEN -fvisibility=hidden)
-	ELSE(VISIBILITY_HIDDEN)
-		SET(VISIBILITY_HIDDEN &quot;&quot;)
-	ENDIF(VISIBILITY_HIDDEN )
-ENDIF(NOT DEFINED CMAKE_CXX_FLAGS) 

Copied: branches/gml/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake (from rev 5960, trunk/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake)
===================================================================
--- branches/gml/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake	                        (rev 0)
+++ branches/gml/rts/build/cmake/TestCXXAcceptsVisibilityFlag.cmake	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,17 @@
+# - Test whether the C++ compiler supports &quot;-fvisibility=hidden&quot;
+# Once done this will define
+#
+# VISIBILITY_HIDDEN - -fvisibility=hidden if supported, an empty string otherwise.
+#
+# Copyright (C) 2008 Tobi Vollebregt
+#
+
+IF(NOT DEFINED CMAKE_CXX_FLAGS)
+	INCLUDE(TestCXXAcceptsFlag)
+	CHECK_CXX_ACCEPTS_FLAG(-fvisibility=hidden VISIBILITY_HIDDEN)
+	IF(VISIBILITY_HIDDEN)
+		SET(VISIBILITY_HIDDEN -fvisibility=hidden)
+	ELSE(VISIBILITY_HIDDEN)
+		SET(VISIBILITY_HIDDEN &quot;&quot;)
+	ENDIF(VISIBILITY_HIDDEN )
+ENDIF(NOT DEFINED CMAKE_CXX_FLAGS) 

Modified: branches/gml/rts/build/vstudio8/rts.vcproj
===================================================================
--- branches/gml/rts/build/vstudio8/rts.vcproj	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/build/vstudio8/rts.vcproj	2008-05-28 21:17:37 UTC (rev 5961)
@@ -396,14 +396,6 @@
 			Name=&quot;External AI&quot;
 			&gt;
 			&lt;File
-				RelativePath=&quot;..\..\ExternalAI\GlobalAICInterface\AbicProxy.cpp&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
-				RelativePath=&quot;..\..\ExternalAI\GlobalAICInterface\AbicProxy.h&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;..\..\ExternalAI\aibase.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -1173,6 +1165,38 @@
 				&lt;File
 					RelativePath=&quot;..\..\Game\StartScripts\GlobalAITestScript.cpp&quot;
 					&gt;
+					&lt;FileConfiguration
+						Name=&quot;Debug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;No debug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Release with error catching|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Syncdebug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							UsePrecompiledHeader=&quot;0&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
 				&lt;/File&gt;
 				&lt;File
 					RelativePath=&quot;..\..\Game\StartScripts\GlobalAITestScript.h&quot;

Copied: branches/gml/rts/icon.rc (from rev 5960, trunk/rts/icon.rc)
===================================================================
--- branches/gml/rts/icon.rc	                        (rev 0)
+++ branches/gml/rts/icon.rc	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,2 @@
+1 ICON &quot;spring.ico&quot;
+CREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST &quot;spring.exe.manifest&quot;

Copied: branches/gml/rts/lib/CMakeLists.txt (from rev 5960, trunk/rts/lib/CMakeLists.txt)
===================================================================
--- branches/gml/rts/lib/CMakeLists.txt	                        (rev 0)
+++ branches/gml/rts/lib/CMakeLists.txt	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,25 @@
+INCLUDE_DIRECTORIES(streflop lua/include luabind)
+
+AUX_SOURCE_DIRECTORY(lua/src lualibfiles)
+ADD_LIBRARY(lua STATIC ${lualibfiles})
+TARGET_LINK_LIBRARIES(lua streflop)
+
+AUX_SOURCE_DIRECTORY(luabind/src luabindfiles)
+ADD_LIBRARY(luabind STATIC ${luabindfiles})
+TARGET_LINK_LIBRARIES(luabind lua)
+
+AUX_SOURCE_DIRECTORY(7zip 7zipfiles)
+ADD_LIBRARY(7zip STATIC ${7zipfiles})
+
+AUX_SOURCE_DIRECTORY(hpiutil2 hpifiles)
+ADD_LIBRARY(hpiutil2 STATIC ${hpifiles})
+TARGET_LINK_LIBRARIES(hpiutil2 z)
+
+IF (NOT MINGW)
+	ADD_LIBRARY(minizip STATIC  minizip/unzip minizip/zip minizip/ioapi)
+ELSE (NOT MINGW)
+	ADD_LIBRARY(minizip STATIC  minizip/unzip minizip/zip minizip/iowin32 minizip/ioapi)
+ENDIF (NOT MINGW)
+TARGET_LINK_LIBRARIES(minizip z)
+
+ADD_SUBDIRECTORY(streflop)
\ No newline at end of file

Modified: branches/gml/rts/lib/gml/gml.cpp
===================================================================
--- branches/gml/rts/lib/gml/gml.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/lib/gml/gml.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -31,7 +31,7 @@
 // Please note: Some functions may require more advanced coding to implement
 // If a function is not yet supported by GML, a compile error pointing to 'GML_FUNCTION_NOT_IMPLEMENTED' will occur
 
-#include &quot;stdafx.h&quot;
+#include &quot;StdAfx.h&quot;
 #include &quot;gmlcls.h&quot;
 
 #define EXEC_RUN (BYTE *)NULL
@@ -47,7 +47,7 @@
 int gmlThreadCount=GML_CPU_COUNT; // number of threads to use
 int gmlThreadCountOverride=0; // number of threads to use (can be manually overridden here)
 
-bool gmlExperimentalMode=false;
+BOOL_ gmlExperimentalMode=false;
 
 // gmlCPUCount returns the number of CPU cores
 // it was taken from the latest version of boost
@@ -99,7 +99,7 @@
 
 // gmlInit caches certain glGet return values to
 // reduce the need for synced queue execution
-BOOL gmlInited=FALSE;
+BOOL_ gmlInited=FALSE;
 void gmlInit() {
 	if(gmlInited)
 		return;
@@ -213,7 +213,7 @@
 	return (BYTE *)*(BYTE * volatile *)&WritePos;
 }
 
-void gmlQueue::ReleaseWrite(BOOL final) {
+void gmlQueue::ReleaseWrite(BOOL_ final) {
 	if(Write==NULL)
 		return;
 #if GML_ALTERNATE_SYNCMODE
@@ -284,7 +284,7 @@
 	WriteSize=NULL;
 }
 
-BOOL gmlQueue::GetWrite(BOOL critical) {
+BOOL_ gmlQueue::GetWrite(BOOL_ critical) {
 	while(1) {
 		if(!Locked1 &amp;&amp; Pos1==Queue1) {
 			if(Locks1.Lock()) {
@@ -327,7 +327,7 @@
 	ReadPos=NULL;
 }
 
-BOOL gmlQueue::GetRead(BOOL critical) {
+BOOL_ gmlQueue::GetRead(BOOL_ critical) {
 	while(1) {
 		if(!Locked1 &amp;&amp; Pos1!=Queue1) {
 			if(Locks1.Lock()) {
@@ -895,8 +895,8 @@
   BYTE *p=Write;
   BYTE *e=WritePos;
   BYTE *ptr=NULL;
-	BOOL isq1=Write==Queue1;
-	BOOL end=FALSE;
+	BOOL_ isq1=Write==Queue1;
+	BOOL_ end=FALSE;
   int updserv=0;
 
   while(TRUE) {

Modified: branches/gml/rts/lib/gml/gmlcls.h
===================================================================
--- branches/gml/rts/lib/gml/gmlcls.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/lib/gml/gmlcls.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -74,7 +74,7 @@
 #define GML_IF_SERVER_THREAD() if(GML_SERVER_GLCALL &amp;&amp; (!GML_ENABLE || gmlThreadNumber==0))
 
 typedef unsigned char       BYTE;
-typedef int                 BOOL;
+typedef int                 BOOL_;
 
 #define TRUE 1
 #define FALSE 0
@@ -609,12 +609,12 @@
   
   gmlLock Locks1;
   gmlLock Locks2;
-  volatile BOOL Locked1;
-  volatile BOOL Locked2;
+  volatile BOOL_ Locked1;
+  volatile BOOL_ Locked2;
   
-  volatile BOOL Reloc;
+  volatile BOOL_ Reloc;
   BYTE * volatile Sync;
-  BOOL WasSynced;
+  BOOL_ WasSynced;
   
   GLenum ClientState;
   // VertexPointer
@@ -648,10 +648,10 @@
   
   BYTE *Realloc(BYTE **e=NULL);
   BYTE *WaitRealloc(BYTE **e=NULL);
-  void ReleaseWrite(BOOL final=TRUE);
-  BOOL GetWrite(BOOL critical);
+  void ReleaseWrite(BOOL_ final=TRUE);
+  BOOL_ GetWrite(BOOL_ critical);
   void ReleaseRead();
-  BOOL GetRead(BOOL critical=FALSE);
+  BOOL_ GetRead(BOOL_ critical=FALSE);
   void SyncRequest();
   void Execute();
   void ExecuteSynced();

Modified: branches/gml/rts/lib/gml/gmlfun.h
===================================================================
--- branches/gml/rts/lib/gml/gmlfun.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/lib/gml/gmlfun.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -620,7 +620,7 @@
   p-&gt;lensize=datasize;\
   BYTE *e=(BYTE *)p+datasize;\
   for(int i=0; i&lt;B; ++i) {\
-	  BOOL len=!D || D[i]&lt;0;\
+	  BOOL_ len=!D || D[i]&lt;0;\
 	  GLint sl=(len?strlen(C[i]):D[i])+1;\
 	  datasize+=sl;\
 	  ((GLint *)&amp;(p-&gt;C))[i]=sl;\

Modified: branches/gml/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/gml/rts/lib/gml/gmlsrv.h	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/lib/gml/gmlsrv.h	2008-05-28 21:17:37 UTC (rev 5961)
@@ -21,17 +21,17 @@
 	R (*workeriter)(void *,U);
 	void* workerclass;
 	int maxthreads;
-	BOOL syncmode;
+	BOOL_ syncmode;
 	int num_units;
 	GML_TYPENAME std::list&lt;U&gt; *iter;
 	int limit1;
 	int limit2;
-	BOOL serverwork;
+	BOOL_ serverwork;
 	void (*serverfun)(void *);
 
 	gmlCount UnitCounter;
 	gmlExecState(R (*wrk)(void *)=NULL,R (*wrka)(void *,A)=NULL,R (*wrki)(void *,U)=NULL,
-		void* cls=NULL,int mt=0,BOOL sm=FALSE,int nu=0,GML_TYPENAME std::list&lt;U&gt; *it=NULL,int l1=1,int l2=1,BOOL sw=FALSE,void (*swf)(void *)=NULL):
+		void* cls=NULL,int mt=0,BOOL_ sm=FALSE,int nu=0,GML_TYPENAME std::list&lt;U&gt; *it=NULL,int l1=1,int l2=1,BOOL_ sw=FALSE,void (*swf)(void *)=NULL):
 	worker(wrk),workerarg(wrka),workeriter(wrki),workerclass(cls),maxthreads(mt),
 		syncmode(sm),num_units(nu),iter(it),limit1(l1),limit2(l2),serverwork(sw),serverfun(swf),UnitCounter(-1) {
 	}
@@ -63,7 +63,7 @@
     UnitCounter%=num_units;
 	}
 
-	BOOL Exec(int &amp;pos, typename std::list&lt;U&gt;::iterator &amp;it) {
+	BOOL_ Exec(int &amp;pos, typename std::list&lt;U&gt;::iterator &amp;it) {
 		int i=++UnitCounter;
 		if(i&gt;=num_units)
 			return FALSE;
@@ -92,10 +92,10 @@
 	GML_TYPENAME gmlExecState&lt;R,A,U&gt; ExecState[GML_MAX_EXEC_DEPTH];
   boost::barrier Barrier; 
 	boost::thread *threads[GML_MAX_NUM_THREADS];
-	BOOL inited;
+	BOOL_ inited;
 	gmlCount threadcnt;
 	gmlCount ClientsReady;
-	BOOL newwork;
+	BOOL_ newwork;
 
 	gmlClientServer():threadcnt(0),ClientsReady(0),Barrier(GML_CPU_COUNT),ExecDepth(0),newwork(FALSE) {
 		inited=FALSE;
@@ -113,7 +113,7 @@
 			GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
 			if(newwork==0)
 				ex-&gt;UnitCounter%=-1;
-			BOOL execswf=newwork&gt;=0;
+			BOOL_ execswf=newwork&gt;=0;
 			newwork=0;
 
 			Barrier.wait();
@@ -129,7 +129,7 @@
 			if(gmlThreadCount&gt;1) {
 				while(ClientsReady&lt;=gmlThreadCount+1) {
 					gmlUpdateServers();
-					BOOL processed=FALSE;
+					BOOL_ processed=FALSE;
 					for(int i=1; i&lt;gmlThreadCount; ++i) {
 						gmlQueue *qd=&amp;gmlQueues[i];
 						if(qd-&gt;Reloc)
@@ -174,7 +174,7 @@
 		}
 	}
 
-	void Work(R (*wrk)(void *),R (*wrka)(void *,A), R (*wrkit)(void *,U),void *cls,int mt,BOOL sm, GML_TYPENAME std::list&lt;U&gt; *it,int nu,int l1,int l2,BOOL sw,void (*swf)(void *)=NULL) {
+	void Work(R (*wrk)(void *),R (*wrka)(void *,A), R (*wrkit)(void *,U),void *cls,int mt,BOOL_ sm, GML_TYPENAME std::list&lt;U&gt; *it,int nu,int l1,int l2,BOOL_ sw,void (*swf)(void *)=NULL) {
 		if(gmlThreadNumber!=0) {
 			NewWork(wrk,wrka,wrkit,cls,mt,sm,it,nu,l1,l2,sw,swf);
 			return;
@@ -186,7 +186,7 @@
 		gmlServer();
 	}
 
-	void NewWork(R (*wrk)(void *),R (*wrka)(void *,A), R (*wrkit)(void *,U),void *cls,int mt,BOOL sm, GML_TYPENAME std::list&lt;U&gt; *it,int nu,int l1,int l2,BOOL sw,void (*swf)(void *)=NULL) {
+	void NewWork(R (*wrk)(void *),R (*wrka)(void *,A), R (*wrkit)(void *,U),void *cls,int mt,BOOL_ sm, GML_TYPENAME std::list&lt;U&gt; *it,int nu,int l1,int l2,BOOL_ sw,void (*swf)(void *)=NULL) {
 		gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];
 		qd-&gt;ReleaseWrite();
 
@@ -254,4 +254,4 @@
 	}
 };
 
-#endif
\ No newline at end of file
+#endif

Modified: branches/gml/rts/lib/lua/README_SPRING
===================================================================
--- branches/gml/rts/lib/lua/README_SPRING	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/lib/lua/README_SPRING	2008-05-28 21:17:37 UTC (rev 5961)
@@ -35,3 +35,6 @@
 
   7. Changed the return type of lua_toboolean from int to bool to prevent
      compiler performance warnings on Visual Studio 2005.
+
+	8. Modified lbaselib.cpp:luaB_tostring() and lvm.cpp:luaV_tostring()
+     so that the tostring() lua function would be sync safe.

Modified: branches/gml/rts/lib/lua/src/lbaselib.cpp
===================================================================
--- branches/gml/rts/lib/lua/src/lbaselib.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/lib/lua/src/lbaselib.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -408,9 +408,21 @@
     case LUA_TNIL:
       lua_pushliteral(L, &quot;nil&quot;);
       break;
+    /*
+     * SPRING - synced safety change
+     */
+    case LUA_TNONE:          { lua_pushliteral(L, &quot;&lt;none&gt;&quot;);          break; }
+    case LUA_TTABLE:         { lua_pushliteral(L, &quot;&lt;table&gt;&quot;);         break; }
+    case LUA_TUSERDATA:      { lua_pushliteral(L, &quot;&lt;userdata&gt;&quot;);      break; }
+    case LUA_TLIGHTUSERDATA: { lua_pushliteral(L, &quot;&lt;lightuserdata&gt;&quot;); break; }
+    case LUA_TFUNCTION:      { lua_pushliteral(L, &quot;&lt;function&gt;&quot;);      break; }
+    case LUA_TTHREAD:        { lua_pushliteral(L, &quot;&lt;thread&gt;&quot;);        break; }
+    default:                 { lua_pushliteral(L, &quot;&lt;unknown_type&gt;&quot;);  break; }
+/*
     default:
       lua_pushfstring(L, &quot;%s: %p&quot;, luaL_typename(L, 1), lua_topointer(L, 1));
       break;
+*/
   }
   return 1;
 }

Modified: branches/gml/rts/lib/lua/src/lvm.cpp
===================================================================
--- branches/gml/rts/lib/lua/src/lvm.cpp	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/lib/lua/src/lvm.cpp	2008-05-28 21:17:37 UTC (rev 5961)
@@ -9,6 +9,8 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
+#include &quot;streflop_cond.h&quot; // SPRING -- for luaV_tostring
+
 #define lvm_c
 #define LUA_CORE
 
@@ -50,7 +52,26 @@
   else {
     char s[LUAI_MAXNUMBER2STR];
     lua_Number n = nvalue(obj);
-    lua_number2str(s, n);
+    // SPRING -- synced safety change
+    //        -- need a custom number formatter?
+    if (isfinite(n)) {
+      lua_number2str(s, n);
+    }
+    else {
+      if (isnan(n)) {
+        strcpy(s, &quot;nan&quot;);
+      }
+      else {
+        const int inf_type = isinf(n);
+        if (inf_type == 1) {
+          strcpy(s, &quot;+inf&quot;);
+        } else if (inf_type == -1) {
+          strcpy(s, &quot;-inf&quot;);
+        } else {
+          strcpy(s, &quot;weird_number&quot;);
+        }
+      }
+    } 
     setsvalue2s(L, obj, luaS_new(L, s));
     return 1;
   }

Copied: branches/gml/rts/lib/streflop/CMakeLists.txt (from rev 5960, trunk/rts/lib/streflop/CMakeLists.txt)
===================================================================
--- branches/gml/rts/lib/streflop/CMakeLists.txt	                        (rev 0)
+++ branches/gml/rts/lib/streflop/CMakeLists.txt	2008-05-28 21:17:37 UTC (rev 5961)
@@ -0,0 +1,31 @@
+AUX_SOURCE_DIRECTORY(libm/flt-32 libm_flt32_source)
+AUX_SOURCE_DIRECTORY(libm/dbl-64 libm_dbl64_source)
+AUX_SOURCE_DIRECTORY(libm/ldbl-96 libm_ldbl96_source)
+
+# FIXME: Random.cpp fails if it libm/headers is in include directory
+# th&lt;ts why it is set in cxxflags as a workaround
+#INCLUDE_DIRECTORIES(libm/headers)
+
+ADD_DEFINITIONS(-DSTREFLOP_X87=1)
+SET(cxxflags &quot;-w -O3 -frounding-math -fsignaling-nans -fno-strict-aliasing -mieee-fp -Wall -mfpmath=387 -I${CMAKE_CURRENT_SOURCE_DIR}/libm/headers&quot;)
+SET_SOURCE_FILES_PROPERTIES(${libm_flt32_source} PROPERTIES COMPILE_FLAGS &quot;-DLIBM_COMPILING_FLT32 ${cxxflags}&quot;)
+SET_SOURCE_FILES_PROPERTIES(${libm_dbl64_source} PROPERTIES COMPILE_FLAGS &quot;-DLIBM_COMPILING_DBL64 ${cxxflags}&quot;)
+SET_SOURCE_FILES_PROPERTIES(${libm_ldbl96_source} PROPERTIES COMPILE_FLAGS &quot;-DLIBM_COMPILING_LDBL96 ${cxxflags}&quot;)
+
+ADD_LIBRARY(streflop STATIC
+	SMath.cpp
+	Random.cpp
+	${libm_flt32_source}
+# not needed =&gt; safer (and faster) to not compile them at all
+#	${libm_dbl64_source}
+#	${libm_ldbl96_source}
+)
+
+
+### Old streflop buildcode - use streflops makefile
+### streflop has its own Makefile, but $(RM) seems to be rm even on windows, so overwrite it with windows &quot;del&quot;
+#IF (CMAKE_HOST_WIN32)
+#	SET(RM_OVERRIDE RM=del)
+#ENDIF(CMAKE_HOST_WIN32)
+
+#ADD_CUSTOM_TARGET(strefloplib COMMAND make STREFLOP_X87=1 CXX=${CMAKE_C_COMPILER} ${RM_OVERRIDE} AR=${CMAKE_AR} WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/streflop) 

Modified: branches/gml/rts/lib/streflop/Makefile
===================================================================
--- branches/gml/rts/lib/streflop/Makefile	2008-05-27 22:41:01 UTC (rev 5960)
+++ branches/gml/rts/lib/streflop/Makefile	2008-05-28 21:17:37 UTC (rev 5961)
@@ -52,8 +52,8 @@
 	i586-mingw32msvc-ar rs streflop.a $(LIBM_OBJECTS) SMath.o Random.o ${USE_SOFT_BINARY}
 	i586-mingw32msvc-ar rs libstreflop.a $(LIBM_OBJECTS) SMath.o Random.o ${USE_SOFT_BINARY}
 else
-	ar rs streflop.a $(LIBM_OBJECTS) SMath.o Random.o ${USE_SOFT_BINARY}
-	ar rs libstreflop.a $(LIBM_OBJECTS) SMath.o Random.o ${USE_SOFT_BINARY}
+	$(AR) rs streflop.a $(LIBM_OBJECTS) SMath.o Random.o ${USE_SOFT_BINARY}
+	$(AR) rs libstreflop.a $(LIBM_OBJECTS) SMath.o Random.o ${USE_SOFT_BINARY}
 endif
 
 arithmeticTest$(EXE_SUFFIX): arithmeticTest.cpp streflop.a


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000740.html">[Taspring-linux-commit] r5960 - in trunk: game/LuaUI	game/LuaUI/Widgets installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Game	rts/Game/Camera rts/Game/StartScripts rts/Game/UI rts/Lua	rts/Map rts/Rendering rts/Rendering/Env rts/Rendering/GL	rts/Rendering/Textures rts/Sim/Projectiles
</A></li>
	<LI>Next message: <A HREF="000742.html">[Taspring-linux-commit] r5962 - in trunk/rts: . build/cmake lib	lib/streflop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#741">[ date ]</a>
              <a href="thread.html#741">[ thread ]</a>
              <a href="subject.html#741">[ subject ]</a>
              <a href="author.html#741">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
