<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5879 - in trunk: Documentation	installer/builddata/bitmaps installer/builddata/bitmaps/bitmaps	installer/builddata/bitmaps/bitmaps/caustics	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SM3/terrain rts/Map/SMF rts/Rendering	rts/Rendering/Env rts/Rendering/GL rts/Rendering/Textures	rts/Rendering/UnitModels rts/Sim/Projectiles rts/System
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5879%20-%20in%20trunk%3A%20Documentation%0A%09installer/builddata/bitmaps%20installer/builddata/bitmaps/bitmaps%0A%09installer/builddata/bitmaps/bitmaps/caustics%0A%09installer/builddata/springcontent/shaders%20rts/Game%20rts/Lua%0A%09rts/Map%20rts/Map/SM3/terrain%20rts/Map/SMF%20rts/Rendering%0A%09rts/Rendering/Env%20rts/Rendering/GL%20rts/Rendering/Textures%0A%09rts/Rendering/UnitModels%20rts/Sim/Projectiles%20rts/System&In-Reply-To=%3C20080512150553.35AD147D9%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000658.html">
   <LINK REL="Next"  HREF="000660.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5879 - in trunk: Documentation	installer/builddata/bitmaps installer/builddata/bitmaps/bitmaps	installer/builddata/bitmaps/bitmaps/caustics	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SM3/terrain rts/Map/SMF rts/Rendering	rts/Rendering/Env rts/Rendering/GL rts/Rendering/Textures	rts/Rendering/UnitModels rts/Sim/Projectiles rts/System</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5879%20-%20in%20trunk%3A%20Documentation%0A%09installer/builddata/bitmaps%20installer/builddata/bitmaps/bitmaps%0A%09installer/builddata/bitmaps/bitmaps/caustics%0A%09installer/builddata/springcontent/shaders%20rts/Game%20rts/Lua%0A%09rts/Map%20rts/Map/SM3/terrain%20rts/Map/SMF%20rts/Rendering%0A%09rts/Rendering/Env%20rts/Rendering/GL%20rts/Rendering/Textures%0A%09rts/Rendering/UnitModels%20rts/Sim/Projectiles%20rts/System&In-Reply-To=%3C20080512150553.35AD147D9%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5879 - in trunk: Documentation	installer/builddata/bitmaps installer/builddata/bitmaps/bitmaps	installer/builddata/bitmaps/bitmaps/caustics	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SM3/terrain rts/Map/SMF rts/Rendering	rts/Rendering/Env rts/Rendering/GL rts/Rendering/Textures	rts/Rendering/UnitModels rts/Sim/Projectiles rts/System">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Mon May 12 17:05:52 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000658.html">[Taspring-linux-commit] r5878 - in trunk/rts: Lua Sim/Units	Sim/Units/CommandAI Sim/Units/UnitTypes
</A></li>
        <LI>Next message: <A HREF="000660.html">[Taspring-linux-commit] r5880 - in trunk/rts: Game/UI Rendering/Env	build/vstudio8
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#659">[ date ]</a>
              <a href="thread.html#659">[ thread ]</a>
              <a href="subject.html#659">[ subject ]</a>
              <a href="author.html#659">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tvo
Date: 2008-05-12 17:05:51 +0200 (Mon, 12 May 2008)
New Revision: 5879

Added:
   trunk/installer/builddata/bitmaps/bitmaps/caustics/
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic00.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic01.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic02.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic03.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic04.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic05.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic06.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic07.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic08.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic09.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic10.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic11.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic12.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic13.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic14.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic15.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic16.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic17.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic18.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic19.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic20.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic21.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic22.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic23.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic24.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic25.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic26.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic27.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic28.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic29.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic30.jpg
   trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic31.jpg
   trunk/installer/builddata/bitmaps/bitmaps/waterbump.png
   trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
   trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
   trunk/rts/Rendering/Env/BumpWater.cpp
   trunk/rts/Rendering/Env/BumpWater.h
Modified:
   trunk/Documentation/cmds.txt
   trunk/installer/builddata/bitmaps/README.txt
   trunk/rts/Game/Game.cpp
   trunk/rts/Lua/LuaConstGame.cpp
   trunk/rts/Map/MapInfo.cpp
   trunk/rts/Map/MapInfo.h
   trunk/rts/Map/SM3/terrain/Lightcalc.cpp
   trunk/rts/Map/SMF/BFGroundTextures.cpp
   trunk/rts/Map/SMF/BFGroundTextures.h
   trunk/rts/Map/SMF/SmfReadMap.cpp
   trunk/rts/Map/SMF/SmfReadMap.h
   trunk/rts/Rendering/Env/AdvSky.cpp
   trunk/rts/Rendering/Env/AdvTreeDrawer.cpp
   trunk/rts/Rendering/Env/AdvTreeGenerator.cpp
   trunk/rts/Rendering/Env/BaseSky.cpp
   trunk/rts/Rendering/Env/BaseSky.h
   trunk/rts/Rendering/Env/BaseWater.cpp
   trunk/rts/Rendering/Env/BasicSky.cpp
   trunk/rts/Rendering/Env/BasicTreeDrawer.cpp
   trunk/rts/Rendering/Env/BasicWater.cpp
   trunk/rts/Rendering/Env/DynWater.cpp
   trunk/rts/Rendering/Env/GrassDrawer.cpp
   trunk/rts/Rendering/GL/myGL.cpp
   trunk/rts/Rendering/GL/myGL.h
   trunk/rts/Rendering/GroundDecalHandler.cpp
   trunk/rts/Rendering/InMapDraw.cpp
   trunk/rts/Rendering/Textures/Bitmap.cpp
   trunk/rts/Rendering/Textures/NamedTextures.cpp
   trunk/rts/Rendering/Textures/TextureAtlas.cpp
   trunk/rts/Rendering/Textures/TextureHandler.cpp
   trunk/rts/Rendering/UnitModels/3DModelParser.cpp
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Rendering/glFont.cpp
   trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
   trunk/rts/System/GlobalStuff.cpp
   trunk/rts/System/GlobalStuff.h
   trunk/rts/System/SpringApp.cpp
Log:
* Applied rendering.patch and bumpwater.patch from jK's patch set (mantis #928),

  modifications before committing:
  - Bumpwater members made private
  - Bumpwater uses GL_DEPTH_COMPONENT32 instead of GL_DEPTH_COMPONENT16, this makes it work
    on more drivers/cards (same total number of bits per texture in the FBO.)
  - CompressTextures is off by default, because it decreases rendering quality.
    Probably because of the bigger smallest mipmap? (ie. 4x4 instead of 1x1)

  also this includes the parts of ui.patch that were left out earlier

* rendering.patch:
  - extended /wiremap to BasicSkybox
  - fixed smoke textures loading from resource.tdf (resources/graphics/smoke/smoke00 .. smoke11)
  - enabled polygon offset for all units begin built (fixs a clipping issue)
  - fixed a wrong rotation in ApplyTransform() (which is used by lua's gl.UnitPieceMultMatrix)
  - removed some redundant texture unbindings in dynWater and removed 256*256 foamTex limit
  - fixed glyph (vertical) spacing in fontatlas
  - fixed spacing in particle atlas
  - new TextureLODBias option (global mipmapping bias)
  - new CompressTextures option (It is only used by the new mygl.cpp::glBuildMipmaps() function,
    so the 3do texture atlas won't be compressed)
  - merged all mipmap creation functions into mygl.cpp::glBuildMipmaps()
  - fixed dds mipmapping filter setting. (yeah smoth was always true, there was something wrong with s3o textures ;)
  - added PBO (PixelBufferObject) support to smf groundtexture loader.
    info: PBO use DMA and are async (-&gt; 0% cpu usage). Under some conditions PBOs can be slower than the old mechanism,
    so you can turn them off with &quot;UsePBO&quot;.

* bumpwater.patch + bumpwater.zip:
  - yeah, a new water shader!
  - It is modular so, you can turn off reflections and refractions to get the same speed as /water 0 and still get
    a nice looking enviroment. Also it's the first water shader in spring that gives the water an ambient color,
    so the water doesn't look always like puddle.
 
  - Features:
    * normal map
    * ambient/diffuse lighting
    * specular lighting
    * fresnel (refraction)
    * caustics
 
  - new map water options (with defaults) are:
    * FresnelMin(0.2), FresnelMax(0.3), FresnelPower(4.0) (define the refraction)
    * WaterSpecularFactor(20.0)
    * WaterSpecularColor(groundSunColor)
    * WaterSurfaceAlpha(0.55)
    * WaterFoamTexture(DynWater uses this, too)
    * WaterNormalTexture(bumpmap)
 
  - new resource.tdf options:
    * resources\\graphics\\caustics\\caustic00 .. caustic32
 
  - new .springrc/registry settings:
    * BumpWaterTexSizeReflection(256)
    * BumpWaterReflection(1)
    * BumpWaterRefraction(1)



Modified: trunk/Documentation/cmds.txt
===================================================================
--- trunk/Documentation/cmds.txt	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/Documentation/cmds.txt	2008-05-12 15:05:51 UTC (rev 5879)
@@ -80,7 +80,7 @@
 pause
 
 shadows [&lt;0|1&gt; [mapsize]]
-water   [0|1|2|3]
+water   [0|1|2|3|4]
 vsync   [-1|0|1|2|...]  --  -1 will use default setting in windows,
                         --  numbers higher then 1 will result in
                         --  rendering every N frames.

Modified: trunk/installer/builddata/bitmaps/README.txt
===================================================================
--- trunk/installer/builddata/bitmaps/README.txt	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/installer/builddata/bitmaps/README.txt	2008-05-12 15:05:51 UTC (rev 5879)
@@ -65,3 +65,5 @@
 tracks/ComTrack.bmp	SJ
 tracks/StdTank.bmp	SJ
 wake.tga		Yeha
+waterbump.png		jK
+caustics/*		jK (with GPL app: <A HREF="http://www.lysator.liu.se/~kand/caustics/">http://www.lysator.liu.se/~kand/caustics/</A>)

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic00.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic00.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic01.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic01.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic02.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic02.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic03.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic03.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic04.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic04.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic05.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic05.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic06.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic06.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic07.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic07.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic08.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic08.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic09.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic09.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic10.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic10.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic11.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic11.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic12.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic12.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic13.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic13.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic14.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic14.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic15.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic15.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic16.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic16.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic17.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic17.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic18.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic18.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic19.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic19.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic20.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic20.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic21.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic21.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic22.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic22.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic23.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic23.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic24.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic24.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic25.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic25.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic26.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic26.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic27.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic27.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic28.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic28.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic29.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic29.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic30.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic30.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic31.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/caustics/caustic31.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/bitmaps/bitmaps/waterbump.png
===================================================================
(Binary files differ)


Property changes on: trunk/installer/builddata/bitmaps/bitmaps/waterbump.png
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
===================================================================
--- trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	                        (rev 0)
+++ trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-05-12 15:05:51 UTC (rev 5879)
@@ -0,0 +1,111 @@
+/**
+ * @project Spring RTS
+ * @file bumpWaterVS.glsl
+ * @brief An extended bumpmapping water shader
+ * @author jK
+ *
+ * Copyright (C) 2008.  Licensed under the terms of the
+ * GNU GPL, v2 or later.
+ */
+
+//////////////////////////////////////////////////
+// runtime defined constants are:
+// #define SurfaceColor   vec4
+// #define SpecularColor  vec3
+// #define SpecularFactor float
+// #define MapMid         vec3
+// #define SunDir         vec3
+// #define FresnelMin     float
+// #define FresnelMax     float
+// #define FresnelPower   float
+// #define ScreenInverse  vec2
+// #define ViewPos        vec2
+// #define SunDir         vec3
+
+#extension GL_ARB_texture_rectangle : enable
+//#extension GL_ARB_shader_texture_lod : enable
+
+  uniform sampler2D normalmap;
+  uniform sampler2D heightmap;
+  uniform sampler2D caustic;
+  uniform sampler2D foam;
+  uniform sampler2D reflection;
+  uniform sampler2DRect refraction;
+  uniform float frame;
+  uniform vec3 eyePos;
+
+  varying vec3 eyeVec;
+  varying vec3 ligVec;
+
+  void main(void) {
+#ifdef use_heightmap
+    float waterdepth = texture2D(heightmap,gl_TexCoord[0].st).r;
+    if (waterdepth&lt;0.0) {
+#else
+    float waterdepth = texture2D(heightmap,gl_TexCoord[0].pq).a; //heightmap in alpha channel
+    if (waterdepth&lt;1.0) {
+      float invwaterdepth = 1.0-waterdepth;
+#endif
+      gl_FragColor.a = 1.0;
+
+      vec3 eVec = normalize(eyeVec);
+
+      vec3 octave4 = texture2D(normalmap,(gl_TexCoord[0].st+frame*vec2(-1.0,1.0))*40.0).rgb;
+      vec3 octave3 = texture2D(normalmap,(gl_TexCoord[0].st+frame)*100.0,-1.0).rgb;
+      vec3 octave2 = texture2D(normalmap,(gl_TexCoord[0].st-frame)*20.0,-1.0).rgb;
+      vec3 octave1 = texture2D(normalmap,(gl_TexCoord[0].st+frame)*5.0).rgb;
+
+      vec3 normal = (octave1+octave2+octave3+octave4)*0.5;
+      normal = normalize( normal - 1.0).xzy;
+
+      float eyeNormalCos = dot(-eVec, normal);
+
+      vec3 reflectDir = reflect(normalize(-ligVec), normal);
+      float specular  = pow( max(dot(reflectDir,eVec), 0.0) , SpecularFactor);
+      float diffuse   = pow( dot(normal,SunDir) ,3.0)*0.1;
+      float ambient   = smoothstep(-1.3,0.0,eyeNormalCos);
+      vec3  waterSurface = SurfaceColor.rgb + vec3(diffuse+ambient);
+#ifdef use_heightmap
+      float maxWaterDepth= -30.0;
+      float surfaceMix   = (SurfaceColor.a + diffuse)*(waterdepth/maxWaterDepth);
+      float refractDistortion = 60.0*(1.0-pow(gl_FragCoord.z,80.0))*(waterdepth/maxWaterDepth);
+#else
+      float surfaceMix   = (SurfaceColor.a + diffuse)*(1.0-waterdepth);
+      float refractDistortion = 60.0*(1.0-pow(gl_FragCoord.z,80.0))*invwaterdepth;
+#endif
+
+#ifdef use_refraction
+      vec3 refrColor   = texture2DRect(refraction, gl_FragCoord.xy-ViewPos + normal.xz*refractDistortion ).rgb;
+      gl_FragColor.rgb = mix(waterSurface,refrColor, surfaceMix);
+#else
+      gl_FragColor.rgb = waterSurface;
+      gl_FragColor.a   = surfaceMix + specular;
+#endif
+
+#ifdef use_heightmap
+      if ((waterdepth/maxWaterDepth)&lt;1.0) {
+        vec3 caust = texture2D(caustic,gl_TexCoord[0].st*80.0).rgb;
+        gl_FragColor.rgb = mix(gl_FragColor.rgb,refrColor+(caust*(waterdepth/maxWaterDepth)*0.22),1.0-(waterdepth/maxWaterDepth));
+#else
+      if (waterdepth&gt;0.0) {
+        vec3 caust = texture2D(caustic,gl_TexCoord[0].st*75.0).rgb;
+  #ifdef use_refraction
+        gl_FragColor.rgb = mix(gl_FragColor.rgb,refrColor+(caust*invwaterdepth)*0.22,waterdepth);
+  #else
+        gl_FragColor.a *= min(invwaterdepth*4.0,1.0);
+        gl_FragColor.rgb += caust*waterdepth*0.6;
+  #endif
+#endif
+      }
+
+      float angle = (1.0-abs(eyeNormalCos));
+
+#ifdef use_reflection
+      float fresnel    = FresnelMin + FresnelMax * pow(angle,FresnelPower);
+      vec3 reflColor   = texture2D(reflection,vec2(0.0,1.0) - (gl_FragCoord.xy-ViewPos)*ScreenInverse + normal.xz*0.09).rgb;
+      gl_FragColor.rgb = mix(gl_FragColor.rgb, reflColor, fresnel);
+#endif
+
+      gl_FragColor.rgb += SpecularColor*specular*angle;
+    }else{ discard; }
+  }


Property changes on: trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
===================================================================
--- trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl	                        (rev 0)
+++ trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl	2008-05-12 15:05:51 UTC (rev 5879)
@@ -0,0 +1,29 @@
+/**
+ * @project Spring RTS
+ * @file bumpWaterVS.glsl
+ * @brief An extended bumpmapping water shader
+ * @author jK
+ *
+ * Copyright (C) 2008.  Licensed under the terms of the
+ * GNU GPL, v2 or later.
+ */
+
+//////////////////////////////////////////////////
+// runtime defined constants are:
+// #define MapMid vec3
+// #define SunDir vec3
+
+uniform vec3 eyePos;
+varying vec3 eyeVec;
+varying vec3 ligVec;
+
+void main(void)
+{
+	gl_Position = ftransform();
+	gl_TexCoord[0] = gl_MultiTexCoord0;
+	//gl_FrontColor  = gl_Color;
+	//gl_FrontSecondaryColor = gl_SecondaryColor;
+	eyeVec = eyePos - gl_Vertex.xyz;
+	//ligVec = normalize(lightDir*200.0 - gl_Vertex.xyz - gl_Vertex.xyz); //FIXME use map midpoint!!
+	ligVec = normalize(SunDir*20000.0 + MapMid - gl_Vertex.xyz);
+}


Property changes on: trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Game/Game.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -913,14 +913,14 @@
 	else if (cmd == &quot;water&quot;) {
 		delete water;
 
-		static char rmodes[4][32] = {&quot;basic&quot;, &quot;reflective&quot;, &quot;dynamic&quot;, &quot;reflective&amp;refractive&quot;};
+		static char rmodes[5][32] = {&quot;basic&quot;, &quot;reflective&quot;, &quot;dynamic&quot;, &quot;reflective&amp;refractive&quot;, &quot;bumpmapped&quot;};
 		int next = 0;
 
 		if (!action.extra.empty()) {
-			next = std::max(0, atoi(action.extra.c_str()) % 4);
+			next = std::max(0, atoi(action.extra.c_str()) % 5);
 		} else {
 			const int current = configHandler.GetInt(&quot;ReflectiveWater&quot;, 1);
-			next = (std::max(0, current) + 1) % 4;
+			next = (std::max(0, current) + 1) % 5;
 		}
 		configHandler.SetInt(&quot;ReflectiveWater&quot;, next);
 		logOutput.Print(&quot;Set water rendering mode to %i (%s)&quot;, next, rmodes[next]);
@@ -1779,9 +1779,11 @@
 	}
 	else if (cmd == &quot;wiremap&quot;) {
 		if (action.extra.empty()) {
-			gd-&gt;wireframe = !gd-&gt;wireframe;
+			gd-&gt;wireframe  = !gd-&gt;wireframe;
+			sky-&gt;wireframe = gd-&gt;wireframe;
 		} else {
-			gd-&gt;wireframe = !atoi(action.extra.c_str());
+			gd-&gt;wireframe  = !atoi(action.extra.c_str());
+			sky-&gt;wireframe = gd-&gt;wireframe;
 		}
 	}
 	else if (cmd == &quot;setgamma&quot;) {

Modified: trunk/rts/Lua/LuaConstGame.cpp
===================================================================
--- trunk/rts/Lua/LuaConstGame.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Lua/LuaConstGame.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -85,8 +85,14 @@
 	LuaPushNamedColor(L,  &quot;waterBaseColor&quot;,    mapInfo-&gt;water.baseColor);
 	LuaPushNamedColor(L,  &quot;waterMinColor&quot;,     mapInfo-&gt;water.minColor);
 	LuaPushNamedColor(L,  &quot;waterSurfaceColor&quot;, mapInfo-&gt;water.surfaceColor);
+	LuaPushNamedNumber(L, &quot;waterSurfaceAlpha&quot;, mapInfo-&gt;water.surfaceAlpha);
+	LuaPushNamedColor(L,  &quot;waterSpecularColor&quot;,  mapInfo-&gt;water.specularColor);
+	LuaPushNamedNumber(L, &quot;waterSpecularFactor&quot;, mapInfo-&gt;water.specularFactor);
 	LuaPushNamedColor(L,  &quot;waterPlaneColor&quot;,   mapInfo-&gt;water.planeColor);
 	LuaPushNamedColor(L,  &quot;fogColor&quot;,          fogColor);
+	LuaPushNamedColor(L,  &quot;groundAmbientColor&quot;,      mapInfo-&gt;light.groundAmbientColor);
+	LuaPushNamedColor(L,  &quot;groundSpecularColor&quot;,     mapInfo-&gt;light.groundSpecularColor);
+	LuaPushNamedColor(L,  &quot;groundSunColor&quot;,          mapInfo-&gt;light.groundSunColor);
 
 	LuaPushNamedString(L, &quot;modName&quot;,         modInfo.humanName);
 	LuaPushNamedString(L, &quot;modShortName&quot;,    modInfo.shortName);

Modified: trunk/rts/Map/MapInfo.cpp
===================================================================
--- trunk/rts/Map/MapInfo.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Map/MapInfo.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -139,17 +139,46 @@
 	hasWaterPlane = !tmp.empty();
 	water.planeColor = mapDefParser-&gt;GetFloat3(float3(0.0f, 0.4f, 0.0f), &quot;MAP\\WATER\\WaterPlaneColor&quot;);
 
+	mapDefParser-&gt;GetDef(water.fresnelMin,&quot;0.2&quot;,&quot;MAP\\WATER\\FresnelMin&quot;);
+	mapDefParser-&gt;GetDef(water.fresnelMax,&quot;0.3&quot;,&quot;MAP\\WATER\\FresnelMax&quot;);
+	mapDefParser-&gt;GetDef(water.fresnelPower,&quot;4.0&quot;,&quot;MAP\\WATER\\FresnelPower&quot;);
+
+	mapDefParser-&gt;GetDef(water.specularFactor,&quot;20.0&quot;,&quot;MAP\\WATER\\WaterSpecularFactor&quot;);
+
+	water.specularColor = mapDefParser-&gt;GetFloat3(light.groundSunColor,&quot;MAP\\WATER\\WaterSpecularColor&quot;);
 	water.surfaceColor = mapDefParser-&gt;GetFloat3(float3(0.75f, 0.8f, 0.85f), &quot;MAP\\WATER\\WaterSurfaceColor&quot;);
+	mapDefParser-&gt;GetDef(water.surfaceAlpha,&quot;0.55&quot;,&quot;MAP\\WATER\\WaterSurfaceAlpha&quot;);
 	water.absorb = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterAbsorb&quot;);
 	water.baseColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterBaseColor&quot;);
 	water.minColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterMinColor&quot;);
+
 	mapDefParser-&gt;GetDef(water.texture, &quot;&quot;, &quot;MAP\\WATER\\WaterTexture&quot;);
+	mapDefParser-&gt;GetDef(water.foamTexture, &quot;&quot;, &quot;MAP\\WATER\\WaterFoamTexture&quot;);
+	mapDefParser-&gt;GetDef(water.normalTexture, &quot;&quot;, &quot;MAP\\WATER\\WaterNormalTexture&quot;);
 
 	//default water is ocean.jpg in bitmaps, map specific water textures is saved in the map dir
 	if(water.texture.empty())
 		water.texture = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;ocean.jpg&quot;, &quot;resources\\graphics\\maps\\watertex&quot;);
 	else
 		water.texture = &quot;maps/&quot; + water.texture;
+
+	
+	if(water.foamTexture.empty())
+		water.foamTexture = &quot;bitmaps/&quot;+resources-&gt;SGetValueDef(&quot;foam.jpg&quot;,&quot;resources\\graphics\\maps\\waterfoamtex&quot;);
+	else
+		water.foamTexture = &quot;maps/&quot; + water.foamTexture;
+
+	if(water.normalTexture.empty())
+		water.normalTexture = &quot;bitmaps/&quot;+resources-&gt;SGetValueDef(&quot;waterbump.png&quot;,&quot;resources\\graphics\\maps\\waternormaltex&quot;);
+	else
+		water.normalTexture = &quot;maps/&quot; + water.normalTexture;
+
+	char num[10];
+	for (int i = 0; i &lt; 32; i++) {
+		sprintf(num, &quot;%02i&quot;, i);
+		water.causticTextures[i] = std::string(&quot;bitmaps/&quot;) + resources-&gt;SGetValueDef(std::string(&quot;caustics/caustic&quot;)+num+&quot;.jpg&quot;,
+								std::string(&quot;resources\\graphics\\caustics\\caustic&quot;)+num);
+	}
 }
 
 

Modified: trunk/rts/Map/MapInfo.h
===================================================================
--- trunk/rts/Map/MapInfo.h	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Map/MapInfo.h	2008-05-12 15:05:51 UTC (rev 5879)
@@ -106,8 +106,17 @@
 		float3 baseColor;
 		float3 minColor;
 		float3 surfaceColor;
+		float surfaceAlpha;
 		float3 planeColor;
+		float3 specularColor;
+		float specularFactor;
+		float fresnelMin;
+		float fresnelMax;
+		float fresnelPower;
 		std::string texture;
+		std::string foamTexture;
+		std::string normalTexture;
+		std::string causticTextures[32];
 	} water;
 	bool hasWaterPlane; ///&lt; true if &quot;MAP\WATER\WaterPlaneColor&quot; is set
 

Modified: trunk/rts/Map/SM3/terrain/Lightcalc.cpp
===================================================================
--- trunk/rts/Map/SM3/terrain/Lightcalc.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Map/SM3/terrain/Lightcalc.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -33,6 +33,7 @@
 #include &quot;Textures.h&quot;
 #include &quot;Lightcalc.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 
 #include &lt;SDL.h&gt;
 #include &lt;IL/il.h&gt;
@@ -171,7 +172,7 @@
 
 	SaveImage (&quot;lightmap.png&quot;, 4, IL_UNSIGNED_BYTE, w,w, shadingTexData);
 
-	gluBuild2DMipmaps(GL_TEXTURE_2D, 4, w,w, GL_RGBA, GL_UNSIGNED_BYTE, shadingTexData);
+	glBuildMipmaps(GL_TEXTURE_2D, 4, w,w, GL_RGBA, GL_UNSIGNED_BYTE, shadingTexData);
 	delete[] shadingTexData;
 
 	id = shadingTex;

Modified: trunk/rts/Map/SMF/BFGroundTextures.cpp
===================================================================
--- trunk/rts/Map/SMF/BFGroundTextures.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Map/SMF/BFGroundTextures.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -9,11 +9,19 @@
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;SmfReadMap.h&quot;
 #include &quot;mmgr.h&quot;
+#include &quot;FastMath.h&quot;
 
 using namespace std;
 
 CBFGroundTextures::CBFGroundTextures(CSmfReadMap* rm)
 {
+	usePBO = false;
+	if (GLEW_EXT_pixel_buffer_object &amp;&amp; rm-&gt;usePBO) {
+		glGenBuffers(30, pboIDs);
+		currentPBO=0;
+		usePBO = true;
+	}
+
 	CFileHandler* ifs = rm-&gt;ifs;
 	map = rm;
 
@@ -98,7 +106,6 @@
 			GroundSquare* square = &amp;squares[y * numBigTexX + x];
 			square-&gt;texLevel = 1;
 			square-&gt;lastUsed = -100;
-
 			LoadSquare(x, y, 2);
 		}
 	}
@@ -111,6 +118,9 @@
 	delete[] squares;
 	delete[] tileMap;
 	delete[] tiles;
+	if (usePBO) {
+		glDeleteBuffers(30,pboIDs);
+	}
 }
 
 
@@ -126,7 +136,7 @@
 	static const int heightDataX = gs-&gt;mapx + 1;
 	static const int bigTexW = (gs-&gt;mapx &lt;&lt; 3) / numBigTexX;
 	static const int bigTexH = (gs-&gt;mapy &lt;&lt; 3) / numBigTexY;
-	static const float bigTexSquareRadius = sqrt(float(bigTexW * bigTexW + bigTexH * bigTexH));
+	static const float bigTexSquareRadius = fastmath::sqrt(float(bigTexW * bigTexW + bigTexH * bigTexH));
 
 	const int x = btx * bigTexW + (bigTexW &gt;&gt; 1);
 	const int y = bty * bigTexH + (bigTexH &gt;&gt; 1);
@@ -160,7 +170,7 @@
 
 			float dx = cam2-&gt;pos.x - x * bigSquareSize * SQUARE_SIZE - 64 * SQUARE_SIZE;
 			dx = max(0.0f, float(fabs(dx) - 64.0f * SQUARE_SIZE));
-			float dist = sqrt(dx * dx + dy * dy);
+			float dist = fastmath::sqrt(dx * dx + dy * dy);
 
 			if (square-&gt;lastUsed &lt; gs-&gt;frameNum - 60)
 				dist = 8000;
@@ -204,11 +214,29 @@
 
 void CBFGroundTextures::LoadSquare(int x, int y, int level)
 {
+	int size = 1024 &gt;&gt; level;
+
+	GLubyte* buf=NULL; bool usedPBO=false;
+
+	if (usePBO) {
+		if (currentPBO &gt; 29) currentPBO=0;
+		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboIDs[currentPBO++]);
+
+		glBufferData(GL_PIXEL_UNPACK_BUFFER, size * size / 2, 0, GL_STREAM_DRAW);
+
+		//map the buffer object into client's memory
+		buf = (GLubyte*)glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
+		usedPBO = true;
+	}
+
+	if(buf==NULL) {
+		buf = SAFE_NEW GLubyte[size * size / 2];
+		usedPBO = false;
+	}
+
 	GroundSquare* square = &amp;squares[y * numBigTexX + x];
 	square-&gt;texLevel = level;
 
-	int size = 1024 &gt;&gt; level;
-	char* buf = SAFE_NEW char[size * size / 2];
 	int numblocks = 8 / (1 &lt;&lt; level);
 
 	for (int y1 = 0; y1 &lt; 32; y1++) {
@@ -217,10 +245,11 @@
 
 			for (int yt = 0; yt &lt; numblocks; yt++) {
 				for (int xt = 0; xt &lt; numblocks; xt++) {
-					char* sbuf = &amp;tile[(xt + yt * numblocks) * 8];
-					char* dbuf = &amp;buf[(x1 * numblocks+xt + (y1 * numblocks + yt) * (numblocks * 32)) * 8];
+					GLfloat* sbuf = (GLfloat*)&amp;tile[(xt + yt * numblocks) * 8];
+					GLfloat* dbuf = (GLfloat*)&amp;buf[(x1 * numblocks + xt + (y1 * numblocks + yt) * (numblocks * 32)) * 8];
 
-					for (int i = 0; i &lt; 8; i++) {
+					//copy 4 bytes at once
+					for (int i = 0; i &lt; 2; i++) {
 						dbuf[i] = sbuf[i];
 					}
 				}
@@ -234,12 +263,16 @@
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	if (map-&gt;anisotropy != 0.0f)
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, map-&gt;anisotropy);
 
-	if (map-&gt;anisotropy != 0.0f) {
-		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, map-&gt;anisotropy);
+	if (usedPBO) {
+		glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
+		glCompressedTexImage2D(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, size, size, 0, size * size / 2, 0);
+		glBufferData(GL_PIXEL_UNPACK_BUFFER, 0, 0, GL_STREAM_DRAW); //free it
+		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+	}else{
+		glCompressedTexImage2D(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, size, size, 0, size * size / 2, buf);
+		delete[] buf;
 	}
-
-	glCompressedTexImage2DARB(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, size, size, 0, size * size / 2, buf);
-
-	delete[] buf;
 }

Modified: trunk/rts/Map/SMF/BFGroundTextures.h
===================================================================
--- trunk/rts/Map/SMF/BFGroundTextures.h	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Map/SMF/BFGroundTextures.h	2008-05-12 15:05:51 UTC (rev 5879)
@@ -52,6 +52,11 @@
 	int tileMapXSize;
 	int tileMapYSize;
 
+	// use Pixel Buffer Objects for async. uploading (DMA)?
+	bool usePBO;
+	GLuint pboIDs[30];
+	int currentPBO;
+
 	float anisotropy;
 
 	inline bool TexSquareInView(int, int);

Modified: trunk/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- trunk/rts/Map/SMF/SmfReadMap.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Map/SMF/SmfReadMap.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -34,6 +34,7 @@
 	PrintLoadMsg(&quot;Opening map file&quot;);
 
 	ConfigureAnisotropy();
+	usePBO = !!configHandler.GetInt(&quot;UsePBO&quot;, 1);
 
 	for(int a=0;a&lt;1024;++a){
 		for(int b=0;b&lt;3;++b){
@@ -104,7 +105,7 @@
 	glBindTexture(GL_TEXTURE_2D, detailTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
 	if (anisotropy != 0.0f) {
 		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
 	}

Modified: trunk/rts/Map/SMF/SmfReadMap.h
===================================================================
--- trunk/rts/Map/SMF/SmfReadMap.h	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Map/SMF/SmfReadMap.h	2008-05-12 15:05:51 UTC (rev 5879)
@@ -36,6 +36,7 @@
 	MapHeader header;
 	CFileHandler *ifs;
 
+	bool usePBO;
 	float anisotropy;
 
 	unsigned char waterHeightColors[1024*4];

Modified: trunk/rts/Rendering/Env/AdvSky.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvSky.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/AdvSky.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -246,7 +246,7 @@
 	glBindTexture(GL_TEXTURE_2D, cdtex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR/*_MIPMAP_NEAREST*/);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_LUMINANCE ,256, 256, GL_LUMINANCE, GL_UNSIGNED_BYTE, mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_LUMINANCE ,256, 256, GL_LUMINANCE, GL_UNSIGNED_BYTE, mem);
 
 	unsigned char randDetailMatrix[32*32];
 	glGenTextures(12, detailTextures);
@@ -290,7 +290,7 @@
 	glBindTexture(GL_TEXTURE_2D, skyTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, skytex[0][0]);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, skytex[0][0]);
 	delete[] skytex;
 
 	unsigned char skytex2[256][256][4];
@@ -311,7 +311,7 @@
 	glBindTexture(GL_TEXTURE_2D, skyDot3Tex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 256, GL_RGBA, GL_UNSIGNED_BYTE, skytex2[0][0]);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 256, GL_RGBA, GL_UNSIGNED_BYTE, skytex2[0][0]);
 
 	for(int a=0;a&lt;CLOUD_DETAIL;a++){
 		CreateRandMatrix(randMatrix[a],1-a*0.03f);
@@ -660,7 +660,7 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,128, 128, GL_RGBA, GL_UNSIGNED_BYTE, mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,128, 128, GL_RGBA, GL_UNSIGNED_BYTE, mem);
 
 	for(int y=0;y&lt;4;++y){
 		for(int x=0;x&lt;32;++x){

Modified: trunk/rts/Rendering/Env/AdvTreeDrawer.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -158,7 +158,7 @@
 				SetArray(TEX_LEAF_END_X1+xdif  ,TEX_LEAF_END_Y4+ydif  ,base-side*width+float3(0,height,0));
 				SetArray(TEX_LEAF_END_X1+xdif  ,TEX_LEAF_START_Y4+ydif,base-side*width);
 			}
-			glNewList(td-&gt;trees[y*treesX+x].farDisplist,GL_COMPILE);
+			glNewList(tss-&gt;farDisplist,GL_COMPILE);
 			va-&gt;DrawArrayT(GL_QUADS);
 			glEndList();
 		}

Modified: trunk/rts/Rendering/Env/AdvTreeGenerator.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvTreeGenerator.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/AdvTreeGenerator.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -58,7 +58,7 @@
 	glBindTexture(GL_TEXTURE_2D, leafTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
 
 	CreateLeafTex(leafTex,256,0,tree);
 	CreateLeafTex(leafTex,512,0,tree);

Modified: trunk/rts/Rendering/Env/BaseSky.cpp
===================================================================
--- trunk/rts/Rendering/Env/BaseSky.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/BaseSky.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -13,6 +13,7 @@
 
 CBaseSky::CBaseSky(void)
 {
+	wireframe = false;
 }
 
 CBaseSky::~CBaseSky(void)

Modified: trunk/rts/Rendering/Env/BaseSky.h
===================================================================
--- trunk/rts/Rendering/Env/BaseSky.h	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/BaseSky.h	2008-05-12 15:05:51 UTC (rev 5879)
@@ -21,6 +21,8 @@
 	bool dynamicSky;
 	float cloudDensity;
 
+	bool wireframe;
+
 	float fogStart;
 	float3 skyColor;
 	float3 sunColor;

Modified: trunk/rts/Rendering/Env/BaseWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BaseWater.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/BaseWater.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -2,6 +2,7 @@
 #include &quot;BaseWater.h&quot;
 #include &quot;BasicWater.h&quot;
 #include &quot;AdvWater.h&quot;
+#include &quot;BumpWater.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;LogOutput.h&quot;
@@ -42,6 +43,20 @@
 			return water;
 		}
 	}
+
+	if(configValue==4 &amp;&amp; GLEW_ARB_shading_language_100) {
+		try {
+			water = SAFE_NEW CBumpWater;
+		} catch (content_error&amp; e) {
+			delete water;
+			water = NULL;
+			logOutput.Print(&quot;Loading Bumpmapped Water failed&quot;);
+			logOutput.Print(&quot;Error: %s&quot;, e.what());
+		}
+		if (water) {
+			return water;
+		}
+	}
 	
 	if(configValue==3 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_rectangle){
 		try {

Modified: trunk/rts/Rendering/Env/BasicSky.cpp
===================================================================
--- trunk/rts/Rendering/Env/BasicSky.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/BasicSky.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -75,6 +75,7 @@
 	glGetError();
 	displist=glGenLists(1);
 	glNewList(displist, GL_COMPILE);
+
 	glDisable(GL_TEXTURE_2D);
 	glDisable(GL_LIGHTING);
 	glDisable(GL_ALPHA_TEST);
@@ -245,6 +246,8 @@
 	glDisable(GL_DEPTH_TEST);
 	glEnable(GL_BLEND);
 
+	if (wireframe) glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+
 	glPushMatrix();
 //	glTranslatef(camera-&gt;pos.x,camera-&gt;pos.y,camera-&gt;pos.z);
 	CMatrix44f m(camera-&gt;pos,sundir1,UpVector,sundir2);
@@ -257,8 +260,6 @@
 		glTranslatef((gs-&gt;frameNum%20000)*0.00005f+modCamera.x*0.000025f,modCamera.z*0.000025f,0);
 	glMatrixMode(GL_MODELVIEW);
 
-
-
 	glCallList(displist);
 
 	glMatrixMode(GL_TEXTURE);						// Select The Projection Matrix
@@ -267,6 +268,8 @@
 
 	glPopMatrix();
 
+	if (wireframe) glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+
 	glEnable(GL_DEPTH_TEST);
 	glDisable(GL_BLEND);
 	if (gu-&gt;drawFog) {
@@ -338,7 +341,7 @@
 	glBindTexture(GL_TEXTURE_2D, skyTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, skytex[0][0]);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, skytex[0][0]);
 //	delete[] skytex;
 
 	for(y=0;y&lt;256;y++){
@@ -359,7 +362,7 @@
 	glBindTexture(GL_TEXTURE_2D, skyDot3Tex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 256, GL_RGBA, GL_UNSIGNED_BYTE, skytex2[0][0]);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 256, GL_RGBA, GL_UNSIGNED_BYTE, skytex2[0][0]);
 
 	for(int a=0;a&lt;CLOUD_DETAIL;a++){
 		CreateRandMatrix(randMatrix[a],1-a*0.03f);
@@ -685,7 +688,7 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,128, 128, GL_RGBA, GL_UNSIGNED_BYTE, mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,128, 128, GL_RGBA, GL_UNSIGNED_BYTE, mem);
 
 	for(int y=0;y&lt;2;++y){
 		for(int x=0;x&lt;32;++x){

Modified: trunk/rts/Rendering/Env/BasicTreeDrawer.cpp
===================================================================
--- trunk/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -246,7 +246,7 @@
 		glCallList(tss-&gt;farDisplist);
 	}
 
-	if(dist&lt;SQUARE_SIZE*TREE_SQUARE_SIZE*treeDistance){	//midle distance trees
+	if(dist&lt;SQUARE_SIZE*TREE_SQUARE_SIZE*treeDistance){	//middle distance trees
 		tss-&gt;lastSeen=gs-&gt;frameNum;
 		if(!tss-&gt;displist){
 			va=GetVertexArray();
@@ -376,52 +376,7 @@
 	glBindTexture(GL_TEXTURE_2D, texnum);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	int mipnum=0;
-	glTexImage2D(GL_TEXTURE_2D,mipnum,GL_RGBA8 ,xsize, ysize,0, GL_RGBA, GL_UNSIGNED_BYTE, data);
-	while(xsize!=1 || ysize!=1){
-		mipnum++;
-		if(xsize!=1)
-			xsize/=2;
-		if(ysize!=1)
-			ysize/=2;
-		for(int y=0;y&lt;ysize;++y){
-			for(int x=0;x&lt;xsize;++x){
-/*				for(int a=0;a&lt;3;a++){
-					int temp=0;
-					int num=0;
-					if(data[(y*2*xsize*2+x*2)*4+3]){
-						temp+=data[(y*2*xsize*2+x*2)*4+a];
-						num++;
-					}
-					if(data[((y*2+1)*xsize*2+x*2)*4+3]){
-						temp+=data[((y*2+1)*xsize*2+x*2)*4+a];
-						num++;
-					}
-					if(data[((y*2)*xsize*2+x*2+1)*4+3]){
-						temp+=data[((y*2)*xsize*2+x*2+1)*4+a];
-						num++;
-					}
-					if(data[((y*2+1)*xsize*2+x*2+1)*4+3]){
-						temp+=data[((y*2+1)*xsize*2+x*2+1)*4+a];
-						num++;
-					}
-					if(num&gt;1)
-						temp/=num;
-					data[(y*xsize+x)*4+a]=temp;
-				}
-*/			data[(y*xsize+x)*4+0]=(data[(y*2*xsize*2+x*2)*4+0]+data[((y*2+1)*xsize*2+x*2)*4+0]+data[(y*2*xsize*2+x*2+1)*4+0]+data[((y*2+1)*xsize*2+x*2+1)*4+0])/4;
-				data[(y*xsize+x)*4+1]=(data[(y*2*xsize*2+x*2)*4+1]+data[((y*2+1)*xsize*2+x*2)*4+1]+data[(y*2*xsize*2+x*2+1)*4+1]+data[((y*2+1)*xsize*2+x*2+1)*4+1])/4;
-				data[(y*xsize+x)*4+2]=(data[(y*2*xsize*2+x*2)*4+2]+data[((y*2+1)*xsize*2+x*2)*4+2]+data[(y*2*xsize*2+x*2+1)*4+2]+data[((y*2+1)*xsize*2+x*2+1)*4+2])/4;
-				data[(y*xsize+x)*4+3]=(data[(y*2*xsize*2+x*2)*4+3]+data[((y*2+1)*xsize*2+x*2)*4+3]+data[(y*2*xsize*2+x*2+1)*4+3]+data[((y*2+1)*xsize*2+x*2+1)*4+3])/4;
-				if(data[(y*xsize+x)*4+3]&gt;=127){
-					data[(y*xsize+x)*4+3]=255;
-				} else {
-					data[(y*xsize+x)*4+3]=0;
-				}
-			}
-		}
-		glTexImage2D(GL_TEXTURE_2D,mipnum,GL_RGBA8 ,xsize, ysize,0, GL_RGBA, GL_UNSIGNED_BYTE, data);
-	}
+	glBuildMipmaps(GL_TEXTURE_2D, GL_RGBA8, xsize, ysize, GL_RGBA, GL_UNSIGNED_BYTE, data);
 }
 
 void CBasicTreeDrawer::ResetPos(const float3&amp; pos)

Modified: trunk/rts/Rendering/Env/BasicWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BasicWater.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/BasicWater.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -26,7 +26,7 @@
 	glBindTexture(GL_TEXTURE_2D, texture);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,pic.xsize, pic.ysize, GL_RGBA, GL_UNSIGNED_BYTE, pic.mem);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,pic.xsize, pic.ysize, GL_RGBA, GL_UNSIGNED_BYTE, pic.mem);
 
 	displist=0;
 

Added: trunk/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.cpp	                        (rev 0)
+++ trunk/rts/Rendering/Env/BumpWater.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -0,0 +1,468 @@
+/**
+ * @file BumpWater.cpp
+ * @brief extended bumpmapping water shader
+ * @author jK
+ *
+ * Copyright (C) 2008.  Licensed under the terms of the
+ * GNU GPL, v2 or later.
+ */
+
+#include &quot;StdAfx.h&quot;
+#include &quot;bitops.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;BumpWater.h&quot;
+#include &quot;Game/Game.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Game/Camera.h&quot;
+#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/ReadMap.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Map/BaseGroundDrawer.h&quot;
+#include &quot;BaseSky.h&quot;
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
+#include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
+#include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;System/Platform/ConfigHandler.h&quot;
+#include &lt;boost/format.hpp&gt;
+
+using std::string;
+
+//////////////////////////////////////////////////////////////////////
+// Construction/Destruction
+//////////////////////////////////////////////////////////////////////
+
+extern GLfloat FogLand[];
+
+
+static void PrintLog(GLuint obj)
+{
+	int infologLength = 0;
+	int maxLength;
+
+	if(glIsShader(obj))
+		glGetShaderiv(obj,GL_INFO_LOG_LENGTH,&amp;maxLength);
+	else
+		glGetProgramiv(obj,GL_INFO_LOG_LENGTH,&amp;maxLength);
+
+	char infoLog[maxLength];
+
+	if (glIsShader(obj))
+		glGetShaderInfoLog(obj, maxLength, &amp;infologLength, infoLog);
+	else
+		glGetProgramInfoLog(obj, maxLength, &amp;infologLength, infoLog);
+
+	if (infologLength &gt; 0)
+		throw content_error(string(&quot;BumpWater shader error: &quot;+string(infoLog,infologLength)));
+}
+
+
+void PrintFboError(GLenum error)
+{
+	switch(error) {
+		case GL_FRAMEBUFFER_COMPLETE_EXT:
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: missing a required image/buffer attachment!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: has no images/buffers attached!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: has mismatched image/buffer dimensions!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: colorbuffer attachments have different types!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: trying to draw to non-attached color buffer!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: trying to read from a non-attached color buffer!&quot;);
+			break;
+		case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
+			logOutput.Print(&quot;BumpWater-FBO: format is not supported by current graphics card/driver!&quot;);
+			break;
+		default:
+			logOutput.Print(&quot;BumpWater-FBO: *UNKNOWN ERROR*&quot;);
+			break;
+	}
+}
+
+static string LoadShaderSource(const string&amp; file)
+{
+	CFileHandler fh(file);
+	if (!fh.FileExists())
+		throw content_error(&quot;Can't load shader &quot; + file);
+
+	string text;
+	text.resize(fh.FileSize());
+	//char* cstr = SAFE_NEW char[fh.FileSize()+1];
+
+	fh.Read(&amp;text[0], text.length());
+	//fh.Read(cstr,fh.FileSize());
+	//cstr[fh.FileSize()] = 0;
+
+	return text;
+}
+
+static void GLSLDefineConstf4(string&amp; str, const string&amp; name, const float3&amp; v, const float&amp; alpha)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec4(%1$.12f,%2$.12f,%3$.12f,%4$.12f)\n&quot;) % (v.x) % (v.y) % (v.z) % (alpha));
+}
+
+static void GLSLDefineConstf3(string&amp; str, const string&amp; name, const float3&amp; v)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec3(%1$.12f,%2$.12f,%3$.12f)\n&quot;) % (v.x) % (v.y) % (v.z));
+}
+
+static void GLSLDefineConstf2(string&amp; str, const string&amp; name, const float&amp; x, const float&amp; y)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec2(%1$.12f,%2$.12f)\n&quot;) % x % y);
+}
+
+static void GLSLDefineConstf1(string&amp; str, const string&amp; name, const float&amp; x)
+{
+	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; %1$.12f\n&quot;) % x);
+}
+
+static GLuint LoadTexture(const string&amp; filename)
+{
+	GLuint texID;
+	CBitmap bm;
+	if (!bm.Load(filename))
+		throw content_error(&quot;Could not load texture from file &quot;+filename);
+
+	glGenTextures(1, &amp;texID);
+	glBindTexture(GL_TEXTURE_2D, texID);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+	//glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 3.0f);
+	glBuildMipmaps(GL_TEXTURE_2D, GLEW_ARB_texture_compression?GL_COMPRESSED_RGB_ARB:GL_RGB8, bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+	return texID;
+}
+
+CBumpWater::CBumpWater()
+{
+	reflTexSize = next_power_of_2(configHandler.GetInt(&quot;BumpWaterTexSizeReflection&quot;, 256));
+	reflection = !!configHandler.GetInt(&quot;BumpWaterReflection&quot;, 1);
+	refraction = configHandler.GetInt(&quot;BumpWaterRefraction&quot;, 1);  //0:=off, 1:=screencopy, 2:=own rendering cycle
+	waves = !!configHandler.GetInt(&quot;BumpBeachWaves&quot;, 1);
+
+	if (!GLEW_EXT_framebuffer_object) {
+		reflection = false;
+	}
+
+	if (refraction&gt;0) {
+		// CREATE REFRACTION TEXTURE
+		glGenTextures(1, &amp;refractTexture);
+		//if(GLEW_ARB_texture_non_power_of_two || GLEW_EXT_texture_non_power_of_two)
+		//	target = GL_TEXTURE_2D;
+		//else //if(GLEW_ARB_texture_rectangle || GLEW_EXT_texture_rectangle)
+			target = GL_TEXTURE_RECTANGLE_ARB;
+		glBindTexture(target, refractTexture);
+		glTexParameteri(target,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+		glTexParameteri(target,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+		if (GLEW_EXT_texture_edge_clamp) {
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		} else {
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+		}
+		if(target == GL_TEXTURE_RECTANGLE_ARB) {
+			refrSizeX = gu-&gt;viewSizeX;
+			refrSizeY = gu-&gt;viewSizeY;
+		} else{
+			refrSizeX = next_power_of_2(gu-&gt;viewSizeX);
+			refrSizeY = next_power_of_2(gu-&gt;viewSizeY);
+		}
+		glTexImage2D(target, 0, GL_RGB8, refrSizeX, refrSizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
+	}
+
+	if (reflection) {
+		// CREATE REFLECTION TEXTURE
+		glGenTextures(1, &amp;reflectTexture);
+		glBindTexture(GL_TEXTURE_2D, reflectTexture);
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+		if (GLEW_EXT_texture_edge_clamp) {
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		} else {
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+		}
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, reflTexSize, reflTexSize, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+
+		// CREATE DEPTH RBO FOR REFLECTION FBO
+		glGenRenderbuffersEXT(1, &amp;rbo);
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbo);
+		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT32, reflTexSize, reflTexSize);
+
+		// CREATE REFLECTION FBO AND BIND TEXTURE&amp;RBO
+		glGenFramebuffersEXT(1,&amp;fbo);
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo);
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, reflectTexture, 0);
+		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, rbo);
+		GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+		if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
+			PrintFboError(status);
+			//logOutput.Print(&quot;BumpWater: FBO not ready&quot;);
+		}
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	}
+
+
+	foamTexture = LoadTexture( mapInfo-&gt;water.foamTexture );
+	normalTexture = LoadTexture( mapInfo-&gt;water.normalTexture );
+	for (int i = 0; i &lt; 32; i++) {
+		caustTextures[i] = LoadTexture( mapInfo-&gt;water.causticTextures[i] );
+	}
+
+	//heightTexture = readmap-&gt;GetShadingTexture();
+	/*
+
+	*/
+
+	/* DEFINE SOME RUNTIME CONSTANTS (I don't use Uniforms for that, 'cos the glsl compiler can't optimize those!) */
+	string definitions;
+	if (reflection)   definitions += &quot;#define use_reflection\n&quot;;
+	if (refraction&gt;0) definitions += &quot;#define use_refraction\n\n&quot;;
+	GLSLDefineConstf4(definitions, &quot;SurfaceColor&quot;, mapInfo-&gt;water.surfaceColor*0.4, mapInfo-&gt;water.surfaceAlpha );
+	GLSLDefineConstf3(definitions, &quot;SpecularColor&quot;, mapInfo-&gt;water.specularColor );
+	GLSLDefineConstf1(definitions, &quot;SpecularFactor&quot;, mapInfo-&gt;water.specularFactor);
+	GLSLDefineConstf3(definitions, &quot;SunDir&quot;, mapInfo-&gt;light.sunDir );
+	GLSLDefineConstf3(definitions, &quot;MapMid&quot;, float3(readmap-&gt;width*SQUARE_SIZE*0.5f,0.0f,readmap-&gt;height*SQUARE_SIZE*0.5f) );
+	GLSLDefineConstf2(definitions, &quot;ScreenInverse&quot;, -1.0f/gu-&gt;viewSizeX, 1.0f/gu-&gt;viewSizeY );
+	GLSLDefineConstf2(definitions, &quot;ViewPos&quot;, gu-&gt;viewPosX,gu-&gt;viewPosY );
+	GLSLDefineConstf1(definitions, &quot;FresnelMin&quot;,  mapInfo-&gt;water.fresnelMin);
+	GLSLDefineConstf1(definitions, &quot;FresnelMax&quot;,  mapInfo-&gt;water.fresnelMax);
+	GLSLDefineConstf1(definitions, &quot;FresnelPower&quot;, mapInfo-&gt;water.fresnelPower);
+
+	/* LOAD SHADERS */
+	string vsSource = LoadShaderSource(&quot;shaders/bumpWaterVS.glsl&quot;);
+	string fsSource = LoadShaderSource(&quot;shaders/bumpWaterFS.glsl&quot;);
+
+	vector&lt;GLint&gt; lengths(2);
+	vector&lt;const GLchar*&gt; strings(2);
+	lengths[0]=definitions.length();
+	strings[0]=definitions.c_str();
+
+	waterVP = glCreateShader(GL_VERTEX_SHADER);
+	lengths[1]=vsSource.length();
+	strings[1]=vsSource.c_str();
+	glShaderSource(waterVP, strings.size(), &amp;strings.front(), &amp;lengths.front());
+	glCompileShader(waterVP);
+	PrintLog(waterVP);
+
+	waterFP = glCreateShader(GL_FRAGMENT_SHADER);
+	lengths[1]= fsSource.length();
+	strings[1] = fsSource.c_str();
+	glShaderSource(waterFP, strings.size(), &amp;strings.front(), &amp;lengths.front());
+	glCompileShader(waterFP);
+	PrintLog(waterFP);
+
+	//delete vsSource; delete fsSource;
+
+	waterShader = glCreateProgram();
+	glAttachShader(waterShader, waterVP);
+	glAttachShader(waterShader, waterFP);
+	glLinkProgram(waterShader);
+	PrintLog(waterShader);
+
+	/* BIND TEXTURE UNIFORMS */
+	glUseProgram(waterShader);
+		eyePosLoc     = glGetUniformLocation(waterShader, &quot;eyePos&quot;);
+		frameLoc      = glGetUniformLocation(waterShader, &quot;frame&quot;);
+		normalmapLoc  = glGetUniformLocation(waterShader, &quot;normalmap&quot;);
+		heightmapLoc  = glGetUniformLocation(waterShader, &quot;heightmap&quot;);
+		causticLoc    = glGetUniformLocation(waterShader, &quot;caustic&quot;);
+		foamLoc       = glGetUniformLocation(waterShader, &quot;foam&quot;);
+		reflectionLoc = glGetUniformLocation(waterShader, &quot;reflection&quot;);
+		refractionLoc = glGetUniformLocation(waterShader, &quot;refraction&quot;);
+
+		glUniform1i(normalmapLoc, 0);
+		glUniform1i(heightmapLoc, 1);
+		glUniform1i(causticLoc, 2);
+		glUniform1i(foamLoc, 3);
+		glUniform1i(reflectionLoc, 4);
+		glUniform1i(refractionLoc, 5);
+	glUseProgram(0);
+}
+
+CBumpWater::~CBumpWater()
+{
+	if (reflection) {
+		glDeleteTextures(1, &amp;reflectTexture);
+		glDeleteRenderbuffersEXT(1, &amp;rbo);
+		glDeleteFramebuffersEXT(1, &amp;fbo);
+	}
+	if (refraction&gt;0)
+		glDeleteTextures(1, &amp;refractTexture);
+
+	glDeleteTextures(1, &amp;foamTexture);
+	glDeleteTextures(32, caustTextures);
+	glDeleteTextures(1, &amp;normalTexture);
+
+	glDeleteShader(waterVP);
+	glDeleteShader(waterFP);
+	glDeleteProgram(waterShader);
+}
+
+void CBumpWater::Draw()
+{
+	if(readmap-&gt;minheight&gt;10)
+		return;
+
+	if (refraction == 1) {
+		// _SCREENCOPY_ REFRACT TEXTURE
+		glBindTexture(target, refractTexture);
+		glEnable(target);
+		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
+		glDisable(target);
+	}
+
+	glDisable(GL_ALPHA_TEST);
+	if (refraction&gt;0)
+		glDisable(GL_BLEND);
+	if (refraction&lt;2)
+		glDepthMask(0);
+
+	glActiveTexture(GL_TEXTURE1);
+		glBindTexture(GL_TEXTURE_2D, readmap-&gt;GetShadingTexture());
+	glActiveTexture(GL_TEXTURE2);
+		glBindTexture(GL_TEXTURE_2D, caustTextures[gs-&gt;frameNum%32]);
+	glActiveTexture(GL_TEXTURE3);
+		glBindTexture(GL_TEXTURE_2D, foamTexture);
+	glActiveTexture(GL_TEXTURE4);
+		glBindTexture(GL_TEXTURE_2D, reflectTexture);
+	glActiveTexture(GL_TEXTURE5);
+		glBindTexture(target, refractTexture);
+	glActiveTexture(GL_TEXTURE0);
+		glBindTexture(GL_TEXTURE_2D, normalTexture);
+
+	glUseProgram(waterShader);
+	glUniform1f(frameLoc,gs-&gt;frameNum/15000.0f);
+	glUniformf3(eyePosLoc,camera-&gt;pos);
+
+	glBegin(GL_QUADS);
+		glTexCoord4f(0.0f,0.0f,0.0f,0.0f);
+			glVertex3i(0,0,0);
+		glTexCoord4f(0.0f,1.0f,0.0f,(float)gs-&gt;mapy/gs-&gt;pwr2mapy);
+			glVertex3i(0,0,readmap-&gt;height*SQUARE_SIZE);
+		glTexCoord4f(1.0f,1.0f,(float)gs-&gt;mapx/gs-&gt;pwr2mapx,(float)gs-&gt;mapy/gs-&gt;pwr2mapy);
+			glVertex3i(readmap-&gt;width*SQUARE_SIZE,0,readmap-&gt;height*SQUARE_SIZE);
+		glTexCoord4f(1.0f,0.0f,(float)gs-&gt;mapx/gs-&gt;pwr2mapx,0.0f);
+			glVertex3i(readmap-&gt;width*SQUARE_SIZE,0,0);
+	glEnd();
+
+	glUseProgram(0);
+
+	if (refraction&lt;2)
+		glDepthMask(1);
+}
+
+void CBumpWater::UpdateWater(CGame* game)
+{
+	if (readmap-&gt;minheight &gt; 10 || mapInfo-&gt;map.voidWater)
+		return;
+
+	if (refraction&gt;1) DrawRefraction(game);
+	if (reflection)   DrawReflection(game);
+}
+
+void CBumpWater::DrawRefraction(CGame* game)
+{
+	// _RENDER_ REFRACTION TEXTURE
+	drawRefraction=true;
+	camera-&gt;Update(false);
+	glViewport(0,0,refrSizeX,refrSizeY);
+
+	glClearColor(FogLand[0],FogLand[1],FogLand[2],1);
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+	float3 oldsun=unitDrawer-&gt;unitSunColor;
+	float3 oldambient=unitDrawer-&gt;unitAmbientColor;
+
+	unitDrawer-&gt;unitSunColor*=float3(0.5f,0.7f,0.9f);
+	unitDrawer-&gt;unitAmbientColor*=float3(0.6f,0.8f,1.0f);
+
+	game-&gt;SetDrawMode(CGame::refractionDraw);
+
+	glEnable(GL_CLIP_PLANE2);
+	double plane[4]={0,-1,0,2};
+	glClipPlane(GL_CLIP_PLANE2 ,plane);
+	drawReflection=true;
+
+	readmap-&gt;GetGroundDrawer()-&gt;Draw();
+	unitDrawer-&gt;Draw(false,true);
+	featureHandler-&gt;Draw();
+	drawReflection=false;
+	ph-&gt;Draw(false,true);
+	luaCallIns.DrawWorldRefraction();
+
+	glDisable(GL_CLIP_PLANE2);
+	game-&gt;SetDrawMode(CGame::normalDraw);
+	drawRefraction=false;
+
+	glBindTexture(target, refractTexture);
+	glEnable(target);
+	glCopyTexSubImage2D(target,0,0,0,0,0,refrSizeX,refrSizeY);
+	glDisable(target);
+
+	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
+	glClearColor(FogLand[0],FogLand[1],FogLand[2],1);
+
+	unitDrawer-&gt;unitSunColor=oldsun;
+	unitDrawer-&gt;unitAmbientColor=oldambient;
+}
+
+void CBumpWater::DrawReflection(CGame* game)
+{
+	// CREATE REFLECTION TEXTURE
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo);
+
+	CCamera *realCam = camera;
+	camera = new CCamera(*realCam);
+	camera-&gt;up.x=0;
+	camera-&gt;up.y=1;
+	camera-&gt;up.z=0;
+	camera-&gt;forward.y*=-1;
+	camera-&gt;pos.y*=-1;
+	camera-&gt;Update(false);
+
+	glViewport(0,0,reflTexSize,reflTexSize);
+
+	glClearColor(0.2f,0.4f,0.2f,1);
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+	game-&gt;SetDrawMode(CGame::reflectionDraw);
+
+	sky-&gt;Draw();
+
+	glEnable(GL_CLIP_PLANE2);
+	double plane[4]={0,1,0,0}; // make angle dependent?
+	glClipPlane(GL_CLIP_PLANE2 ,plane);
+	drawReflection=true;
+
+	readmap-&gt;GetGroundDrawer()-&gt;Draw(true);
+	unitDrawer-&gt;Draw(true);
+	featureHandler-&gt;Draw();
+	ph-&gt;Draw(true);
+	luaCallIns.DrawWorldReflection();
+
+	game-&gt;SetDrawMode(CGame::normalDraw);
+	drawReflection=false;
+	glDisable(GL_CLIP_PLANE2);
+
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
+	glClearColor(FogLand[0],FogLand[1],FogLand[2],1);
+
+	delete camera;
+	camera = realCam;
+	camera-&gt;Update(false);
+}


Property changes on: trunk/rts/Rendering/Env/BumpWater.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/rts/Rendering/Env/BumpWater.h
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.h	                        (rev 0)
+++ trunk/rts/Rendering/Env/BumpWater.h	2008-05-12 15:05:51 UTC (rev 5879)
@@ -0,0 +1,69 @@
+// BumpWater.h: interface for the CBumpWater class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#ifndef __BUMP_WATER_H__
+#define __BUMP_WATER_H__
+
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;BaseWater.h&quot;
+
+class CBumpWater : public CBaseWater
+{
+public:
+	void UpdateWater(CGame* game);
+	void DrawReflection(CGame* game);
+	void DrawRefraction(CGame* game);
+	void Draw();
+	CBumpWater();
+	virtual ~CBumpWater();
+	virtual int GetID() const { return 4; }
+
+private:
+	// user options
+	bool reflection;
+	char refraction; //0:=off, 1:=screencopy, 2:=own rendering cycle
+	int  reflTexSize;
+	bool waves;
+
+	// map options
+	float3 surfaceColor;
+	float3 specularColor;
+
+	int  refrSizeX;
+	int  refrSizeY;
+
+	unsigned int target; // of the refract texture
+	GLuint refractTexture;
+	GLuint reflectTexture;
+	GLuint rbo;
+	GLuint fbo;
+
+	GLuint foamTexture;
+	GLuint normalTexture;
+	GLuint caustTextures[32];
+	GLuint* heightTexture;
+
+	GLuint waterFP;
+	GLuint waterVP;
+	GLuint waterShader;
+	
+	GLuint midPosLoc;
+	GLuint eyePosLoc;
+	GLuint lightDirLoc;
+	GLuint fresnelMinLoc;
+	GLuint fresnelMaxLoc;
+	GLuint fresnelPowerLoc;
+	GLuint frameLoc;
+	GLuint screenInverseLoc;
+	GLuint viewPosLoc;
+	GLuint normalmapLoc;
+	GLuint heightmapLoc;
+	GLuint causticLoc;
+	GLuint foamLoc;
+	GLuint reflectionLoc;
+	GLuint refractionLoc;
+};
+
+#endif // __BUMP_WATER_H__
+


Property changes on: trunk/rts/Rendering/Env/BumpWater.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Rendering/Env/DynWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/DynWater.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/DynWater.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -8,6 +8,7 @@
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;bitops.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Rendering/Env/BaseSky.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
@@ -80,18 +81,20 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
 	glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA16F_ARB ,64, 64, 0,GL_RGBA, GL_FLOAT, temp);
 
-	unsigned char* scrap=SAFE_NEW unsigned char[256*256*4];
 	CBitmap foam;
-	if (!foam.Load(&quot;bitmaps/foam.jpg&quot;) || foam.xsize != 256 || foam.ysize != 256)
-		throw content_error(&quot;Could not load foam from file bitmaps/foam.jpg&quot;);
-	for(int a=0;a&lt;256*256;++a)
+	if (!foam.Load(mapInfo-&gt;water.foamTexture))
+		throw content_error(&quot;Could not load foam from file &quot; + mapInfo-&gt;water.foamTexture);
+	if (count_bits_set(foam.xsize)!=1 || count_bits_set(foam.ysize)!=1)
+		throw content_error(&quot;Foam texture not power of two!&quot;);
+	unsigned char* scrap=SAFE_NEW unsigned char[foam.xsize*foam.ysize*4];
+	for(int a=0;a&lt;foam.xsize*foam.ysize;++a)
 		scrap[a]=foam.mem[a*4];
 
 	glGenTextures(1, &amp;foamTex);
 	glBindTexture(GL_TEXTURE_2D, foamTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D, GL_LUMINANCE,256, 256, GL_LUMINANCE, GL_UNSIGNED_BYTE, scrap);
+	glBuildMipmaps(GL_TEXTURE_2D, GL_LUMINANCE,foam.xsize,foam.ysize, GL_LUMINANCE, GL_UNSIGNED_BYTE, scrap);
 
 	delete[] scrap;
 
@@ -331,7 +334,7 @@
 
 	glDisable( GL_FRAGMENT_PROGRAM_ARB );
 	glDisable( GL_VERTEX_PROGRAM_ARB );
-
+/*
 	glBindTexture(GL_TEXTURE_2D, 0);
 	glActiveTextureARB(GL_TEXTURE1_ARB);
 	glBindTexture(GL_TEXTURE_2D,0);
@@ -348,6 +351,7 @@
 	glActiveTextureARB(GL_TEXTURE7_ARB);
 	glBindTexture(GL_TEXTURE_2D,0);
 	glActiveTextureARB(GL_TEXTURE0_ARB);
+	*/
 }
 
 void CDynWater::UpdateWater(CGame* game)

Modified: trunk/rts/Rendering/Env/GrassDrawer.cpp
===================================================================
--- trunk/rts/Rendering/Env/GrassDrawer.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Env/GrassDrawer.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -103,7 +103,7 @@
 	glBindTexture(GL_TEXTURE_2D, grassBladeTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 64, GL_RGBA, GL_UNSIGNED_BYTE, gbt);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,256, 64, GL_RGBA, GL_UNSIGNED_BYTE, gbt);
 
 	CreateFarTex();
 
@@ -759,7 +759,7 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,1024*sizeMod, 64*sizeMod, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,1024*sizeMod, 64*sizeMod, GL_RGBA, GL_UNSIGNED_BYTE, buf);
 
 	delete[] buf;
 	delete[] buf2;

Modified: trunk/rts/Rendering/GL/myGL.cpp
===================================================================
--- trunk/rts/Rendering/GL/myGL.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/GL/myGL.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -13,15 +13,16 @@
 #include &quot;FPUCheck.h&quot;
 #include &lt;SDL.h&gt;
 #include &quot;mmgr.h&quot;
+#include &quot;System/GlobalStuff.h&quot;
 
 #include &quot;IFramebuffer.h&quot;
 
 using namespace std;
 
 
-static CVertexArray* vertexArray1 = 0;
-static CVertexArray* vertexArray2 = 0;
-static CVertexArray* currentVertexArray = 0;
+static CVertexArray* vertexArray1 = NULL;
+static CVertexArray* vertexArray2 = NULL;
+static CVertexArray* currentVertexArray = NULL;
 
 static GLuint startupTexture = 0;
 
@@ -56,6 +57,24 @@
 	logOutput.Print(&quot;GL:   %s\n&quot;, glGetString(GL_RENDERER));
 	logOutput.Print(&quot;GLEW: %s\n&quot;, glewGetString(GLEW_VERSION));
 
+	/* Get available fullscreen/hardware modes */
+/*
+	SDL_Rect **modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_OPENGL|SDL_RESIZABLE);
+
+	if (modes == (SDL_Rect **)0) {
+		logOutput.Print(&quot;SDL_ListModes: No modes available!\n&quot;);
+	}else if (modes == (SDL_Rect **)-1) {
+		logOutput.Print(&quot;SDL_ListModes: Resolution is restricted.\n&quot;);
+	}else{
+		char buffer[512];
+		unsigned char n = 0;
+		for(int i=0;modes[i];++i) {
+			n += SNPRINTF(&amp;buffer[n], 512-n, &quot;%dx%d, &quot;, modes[i]-&gt;w, modes[i]-&gt;h);
+		}
+		logOutput.Print(&quot;SDL_ListModes: %s\n&quot;,buffer);
+	}
+*/
+
 	if(!GLEW_ARB_multitexture || !GLEW_ARB_texture_env_combine){
 		handleerror(0,&quot;Needed extension GL_ARB_texture_env_combine not found&quot;,&quot;Update drivers&quot;,0);
 		exit(0);
@@ -83,10 +102,41 @@
 {
 	delete vertexArray1;
 	delete vertexArray2;
+}
 
+/******************************************************************************/
+
+void glBuildMipmaps(const GLenum target,GLint internalFormat,const GLsizei width,const GLsizei height,const GLenum format,const GLenum type,const void *data)
+{
+	if (gu-&gt;compressTextures) {
+		switch ( internalFormat ) {
+			case 3:
+			case GL_RGB8 :
+			case GL_RGB :   internalFormat = GL_COMPRESSED_RGB_ARB; break;
+			
+			case 4:
+			case GL_RGBA8 :
+			case GL_RGBA : internalFormat = GL_COMPRESSED_RGBA_ARB; break;
+			
+			case GL_LUMINANCE: internalFormat = GL_COMPRESSED_LUMINANCE_ARB; break;
+		}
+	}
+	
+	// create mipmapped texture
+	if (glGenerateMipmapEXT) {
+	//if (GLEW_EXT_framebuffer_object) { // Hurray (again), ATi only supports half of the extension
+		// newest method
+		glTexImage2D(target, 0, internalFormat, width, height, 0, format, type, data);
+		glGenerateMipmapEXT(GL_TEXTURE_2D);
+	}else if (GLEW_VERSION_1_4) {
+		// This required GL-1.4
+		// instead of using glu, we rely on glTexImage2D to create the Mipmaps.
+		glTexParameteri(GL_TEXTURE_2D,GL_GENERATE_MIPMAP,true);
+		glTexImage2D(target, 0, internalFormat, width, height, 0, format, type, data);
+	} else
+		gluBuild2DMipmaps(target, internalFormat, width, height, format, type, data);
 }
 
-
 /******************************************************************************/
 
 static void AppendStringVec(vector&lt;string&gt;&amp; dst, const vector&lt;string&gt;&amp; src)

Modified: trunk/rts/Rendering/GL/myGL.h
===================================================================
--- trunk/rts/Rendering/GL/myGL.h	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/GL/myGL.h	2008-05-12 15:05:51 UTC (rev 5879)
@@ -27,9 +27,28 @@
 	glTranslatef(v.x,v.y,v.z);
 }
 
+inline void glSecondaryColorf3(const float3&amp; v)
+{
+	glSecondaryColor3f(v.x,v.y,v.z);
+}
+
+inline void glColorf4(const float3&amp; v, const float&amp; alpha)
+{
+	glColor4f(v.x,v.y,v.z,alpha);
+}
+
+inline void glUniformf3(const GLint&amp; location, const float3 &amp;v)
+{
+	glUniform3f(location, v.x,v.y,v.z);
+}
+
+
+void glBuildMipmaps(const GLenum target,GLint internalFormat,const GLsizei width,const GLsizei height,const GLenum format,const GLenum type,const void *data);
+
 void LoadStartPicture(const std::string&amp; sidePref);
 void PrintLoadMsg(const char* text, bool swapbuffers = true);
 void UnloadStartPicture();
+
 bool ProgramStringIsNative(GLenum target, const char* filename);
 unsigned int LoadVertexProgram(const char* filename);
 unsigned int LoadFragmentProgram(const char* filename);

Modified: trunk/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- trunk/rts/Rendering/GroundDecalHandler.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/GroundDecalHandler.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -49,7 +49,7 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
 //	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 //	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,512, 512, GL_RGBA, GL_UNSIGNED_BYTE, buf);
 
 	scarFieldX=gs-&gt;mapx/32;
 	scarFieldY=gs-&gt;mapy/32;

Modified: trunk/rts/Rendering/InMapDraw.cpp
===================================================================
--- trunk/rts/Rendering/InMapDraw.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/InMapDraw.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -124,7 +124,7 @@
 	glBindTexture(GL_TEXTURE_2D, texture);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
-	gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, 128, 64, GL_RGBA, GL_UNSIGNED_BYTE, tex[0]);
+	glBuildMipmaps(GL_TEXTURE_2D, GL_RGBA8, 128, 64, GL_RGBA, GL_UNSIGNED_BYTE, tex[0]);
 
 	blippSound=sound-&gt;GetWaveId(&quot;sounds/beep6.wav&quot;);
 }

Modified: trunk/rts/Rendering/Textures/Bitmap.cpp
===================================================================
--- trunk/rts/Rendering/Textures/Bitmap.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Textures/Bitmap.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -343,14 +343,7 @@
 	{
 		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
 
-		// create mipmapped texture
-		if (GLEW_VERSION_1_4) {
-			// This required GL-1.4
-			// instead of using glu, we rely on glTexImage2D to create the Mipmaps.
-			glTexParameteri(GL_TEXTURE_2D,GL_GENERATE_MIPMAP,true);
-			glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8 ,xsize, ysize, 0,GL_RGBA, GL_UNSIGNED_BYTE, mem);
-		} else
-			gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,xsize, ysize,GL_RGBA, GL_UNSIGNED_BYTE, mem);
+		glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,xsize, ysize,GL_RGBA, GL_UNSIGNED_BYTE, mem);
 	}
 	else
 	{
@@ -380,6 +373,7 @@
 	case nv_dds::TextureFlat:    // 1D, 2D, and rectangle textures
 		glEnable(GL_TEXTURE_2D);
 		glBindTexture(GL_TEXTURE_2D, texobj);
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
 		if(!ddsimage-&gt;upload_texture2D()) {
 			glDeleteTextures(1, &amp;texobj);
 			texobj = 0;

Modified: trunk/rts/Rendering/Textures/NamedTextures.cpp
===================================================================
--- trunk/rts/Rendering/Textures/NamedTextures.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Textures/NamedTextures.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -138,7 +138,7 @@
 			             GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
 		} else {
 			gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, bitmap.xsize, bitmap.ysize,
-			                  GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
+			                  GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem); // make power of two!
 		}
 	} else {
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
@@ -147,8 +147,9 @@
 		} else {
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 		}
-		gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, bitmap.xsize, bitmap.ysize,
-											GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
+
+		glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bitmap.xsize, bitmap.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bitmap.mem);
+		
 	}
 
 	if (aniso &amp;&amp; GLEW_EXT_texture_filter_anisotropic) {

Modified: trunk/rts/Rendering/Textures/TextureAtlas.cpp
===================================================================
--- trunk/rts/Rendering/Textures/TextureAtlas.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Textures/TextureAtlas.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -9,6 +9,9 @@
 CR_BIND(AtlasedTexture, );
 CR_BIND_DERIVED(GroundFXTexture, AtlasedTexture, );
 
+//texture spacing in the atlas (in pixels)
+#define TEXMARGIN 1
+
 bool CTextureAtlas::debug;
 
 CTextureAtlas::CTextureAtlas(int maxxsize, int maxysize)
@@ -99,7 +102,7 @@
 					if(maxy&gt;ysize){
 						if(IncreaseSize())
 						{
-                            nextSub.clear();
+ 							nextSub.clear();
 							thisSub.clear();
 							cury=maxy=curx=0;
 							recalc=true;
@@ -131,11 +134,11 @@
 
 			done=true;
 
-			if(thisSub.front().y+curtex-&gt;ysize&lt;maxy){
-				nextSub.push_back(int2(thisSub.front().x,thisSub.front().y+curtex-&gt;ysize));
+			if(thisSub.front().y+curtex-&gt;ysize+TEXMARGIN&lt;maxy){
+				nextSub.push_back(int2(thisSub.front().x+TEXMARGIN,thisSub.front().y+curtex-&gt;ysize+TEXMARGIN));
 			}
 
-			thisSub.front().x+=curtex-&gt;xsize;
+			thisSub.front().x+=curtex-&gt;xsize+TEXMARGIN;
 			while(thisSub.size()&gt;1 &amp;&amp; thisSub.front().x &gt;= (++thisSub.begin())-&gt;x){
 				(++thisSub.begin())-&gt;x=thisSub.front().x;
 				thisSub.erase(thisSub.begin());
@@ -179,54 +182,17 @@
 {
 
 	unsigned char *data;
-	//for(int i=0,xmip=0,ymip=0; (xsize&gt;&gt;i) || (ysize&gt;&gt;i); i++)
-	//{
-	//	data[i] = SAFE_NEW unsigned char[(xsize&gt;&gt;xmip)*(ysize&gt;&gt;ymip)*4];
-
-	//	xmip = (xsize&gt;&gt;i)&gt;1 ? xmip+=1 : xmip;
-	//	ymip = (ysize&gt;&gt;i)&gt;1 ? ymip+=1 : ymip;
-	//}
-
-	//for(int i=0; i&lt;memtextures.size(); i++)
-	//{
-	//	MemTex *tex = memtextures[i];
-	//	for(int mip=0,xmip=0,ymip=0; (tex-&gt;xsize&gt;&gt;mip) || (tex-&gt;ysize&gt;&gt;mip); mip++)
-	//	{
-	//		unsigned char *mipcell;
-
-	//		if(mip==0)
-	//			mipcell = (unsigned char*)tex-&gt;data;
-	//		else
-	//		{
-	//			mipcell = SAFE_NEW unsigned char[(tex-&gt;xsize&gt;&gt;xmip)*(tex-&gt;ysize&gt;&gt;ymip)*4];
-	//			gluScaleImage(GL_RGBA, tex-&gt;xsize, tex-&gt;ysize, GL_UNSIGNED_BYTE, tex-&gt;data, (tex-&gt;xsize&gt;&gt;xmip), (tex-&gt;ysize&gt;&gt;ymip), GL_UNSIGNED_BYTE, mipcell);
-	//		}
-
-	//		for(int x=0; x&lt;tex-&gt;xsize&gt;&gt;xmip; x++)
-	//		{
-	//			for(int y=0; y&lt;tex-&gt;ysize&gt;&gt;ymip; y++)
-	//			{
-	//				((int*)data[mip])[(tex-&gt;xpos&gt;&gt;xmip)+x+((tex-&gt;ypos&gt;&gt;ymip)+y)*(xsize&gt;&gt;mip)] = ((int*)mipcell)[x+y*(tex-&gt;xsize&gt;&gt;xmip)];
-	//			}
-	//		}
-
-	//		if(mip)
-	//			delete [] mipcell;
-	//		xmip = (xsize&gt;&gt;mip)&gt;1 ? xmip+=1 : xmip;
-	//		ymip = (ysize&gt;&gt;mip)&gt;1 ? ymip+=1 : ymip;
-	//	}
-	//}
-
 	data = SAFE_NEW unsigned char[xsize*ysize*4];
+	memset(data,0,xsize*ysize*4); // make spacing between textures black transparent to avoid ugly lines with linear filtering
 
 	for(int i=0; i&lt;memtextures.size(); i++)
 	{
 		MemTex *tex = memtextures[i];
-        for(int x=0; x&lt;tex-&gt;xsize; x++)
-			for(int y=0; y&lt;tex-&gt;ysize; y++)
-			{
+		for(int x=0; x&lt;tex-&gt;xsize; x++) {
+			for(int y=0; y&lt;tex-&gt;ysize; y++) {
 				((int*)data)[tex-&gt;xpos+x+(tex-&gt;ypos+y)*xsize] = ((int*)tex-&gt;data)[x+y*tex-&gt;xsize];
 			}
+		}			
 	}
 
 	if (debug) {
@@ -248,20 +214,18 @@
 	glBindTexture(GL_TEXTURE_2D, gltex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,/*GL_NEAREST_MIPMAP_LINEAR*/GL_NEAREST);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
+	if (GLEW_EXT_texture_edge_clamp) {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	} else {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+	}
 
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,xsize, ysize, GL_RGBA, GL_UNSIGNED_BYTE, data);
+	glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,xsize, ysize, GL_RGBA, GL_UNSIGNED_BYTE, data);
 
 	delete [] data;
 
-	//for(int i=0; (xsize&gt;&gt;i) || (ysize&gt;&gt;i); i++)
-	//{
-	//	glTexImage2D(GL_TEXTURE_2D, i, GL_RGBA, xsize&gt;&gt;i, ysize&gt;&gt;i, 0, GL_RGBA, GL_UNSIGNED_BYTE, data[i]);
-	//	delete [] data[i];
-	//}
-	
-
 	initialized=true;
 }
 

Modified: trunk/rts/Rendering/Textures/TextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/Textures/TextureHandler.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/Textures/TextureHandler.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -210,7 +210,8 @@
 	glBindTexture(GL_TEXTURE_2D, globalTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR/*_MIPMAP_NEAREST*/);
-	gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bigTexX, bigTexY, GL_RGBA, GL_UNSIGNED_BYTE, tex);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8 ,bigTexX, bigTexY, 0, GL_RGBA, GL_UNSIGNED_BYTE, tex);
+	//glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bigTexX, bigTexY, GL_RGBA, GL_UNSIGNED_BYTE, tex);
 //	CBitmap save(tex,bigTexX,bigTexY);
 	//save.Save(&quot;unittex-1x.jpg&quot;);
 

Modified: trunk/rts/Rendering/UnitModels/3DModelParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModelParser.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/UnitModels/3DModelParser.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -352,9 +352,9 @@
 	glTranslatef(offset.x, offset.y, offset.z);
 
 	if (anim) {
-		glTranslatef(-anim-&gt;coords[0] / CORDDIV,
-									anim-&gt;coords[1] / CORDDIV,
-									anim-&gt;coords[2] / CORDDIV);
+		glTranslatef(anim-&gt;coords[0] / CORDDIV,
+				 anim-&gt;coords[1] / CORDDIV,
+				 anim-&gt;coords[2] / CORDDIV);
 		if (anim-&gt;rot[1]) { glRotatef( anim-&gt;rot[1] / ANGDIV, 0.0f, 1.0f, 0.0f); }
 		if (anim-&gt;rot[0]) { glRotatef( anim-&gt;rot[0] / ANGDIV, 1.0f, 0.0f, 0.0f); }
 		if (anim-&gt;rot[2]) { glRotatef(-anim-&gt;rot[2] / ANGDIV, 0.0f, 0.0f, 1.0f); }

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -1810,16 +1810,16 @@
 		const double plane0[4] = {0, -1, 0 , start + height * (unit-&gt;buildProgress * 3 - 2)};
 		glClipPlane(GL_CLIP_PLANE0, plane0);
 
-		if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
+		//if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
 			glPolygonOffset(1.0f, 1.0f);
 			glEnable(GL_POLYGON_OFFSET_FILL);
-		}
+		//}
 
 		DrawUnitModel(unit);
 
-		if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
+		//if (shadowHandler-&gt;drawShadows &amp;&amp; !water-&gt;drawReflection) {
 			glDisable(GL_POLYGON_OFFSET_FILL);
-		}
+		//}
 	}
 
 	glDisable(GL_CLIP_PLANE0);

Modified: trunk/rts/Rendering/glFont.cpp
===================================================================
--- trunk/rts/Rendering/glFont.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Rendering/glFont.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -14,16 +14,20 @@
 
 using namespace std;
 
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
+/*******************************************************************************/
+/*******************************************************************************/
 
 CglFont *font, *smallFont;
 
+#define GLYPH_MARGIN 3 // margin between glyphs in texture-atlas
+
 class texture_size_exception : public std::exception
 {
 };
 
+/*******************************************************************************/
+/*******************************************************************************/
+
 /**
  * A utility class for CglFont which collects all glyphs of
  * a font into one square luminance/alpha texture.
@@ -82,15 +86,15 @@
 	}
 	outX = curX; outY = curY;
 
-	curX += bmp.width + 1;		// leave one pixel space between each glyph
-	cur += 2*(bmp.width + 1);
+	curX += bmp.width + GLYPH_MARGIN;	// leave one pixel space between each glyph
+	cur  += 2*(bmp.width + GLYPH_MARGIN); 	// 2channels (luminance and alpha))
 	curHeight = max(curHeight, bmp.rows);
 }
 
 void CFontTextureRenderer::BreakLine()
 {
 	curX = 0;
-	curY += curHeight;
+	curY += curHeight + GLYPH_MARGIN;
 	curHeight = 0;
 
 	if (curY &gt;= height)

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -93,7 +93,7 @@
 	for (int i = 0; i &lt; 12; i++) {
 		char num[10];
 		sprintf(num, &quot;%02i&quot;, i);
-		textureAtlas-&gt;AddTexFromFile(std::string(&quot;ismoke&quot;) + num, std::string(&quot;bitmaps/&quot;)+resources.SGetValueDef(std::string(&quot;smoke/smoke&quot;) + num +&quot;.tga&quot;,std::string(&quot;resources\\graphics\\smoke\\smoke&quot;)+num+&quot;alpha&quot;));
+		textureAtlas-&gt;AddTexFromFile(std::string(&quot;ismoke&quot;) + num, std::string(&quot;bitmaps/&quot;)+resources.SGetValueDef(std::string(&quot;smoke/smoke&quot;) + num +&quot;.tga&quot;,std::string(&quot;resources\\graphics\\smoke\\smoke&quot;)+num));
 		blockMapTexNames.insert(std::string(&quot;ismoke&quot;) + num);
 	}
 
@@ -240,7 +240,7 @@
 		glBindTexture(GL_TEXTURE_2D, perlinTex[a]);
 		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
-		gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8,16, 16, GL_RGBA, GL_UNSIGNED_BYTE, tempmem);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 16,16, 0, GL_RGBA, GL_UNSIGNED_BYTE, tempmem);
 	}
 
 	drawPerlinTex=false;

Modified: trunk/rts/System/GlobalStuff.cpp
===================================================================
--- trunk/rts/System/GlobalStuff.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/System/GlobalStuff.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -218,6 +218,7 @@
 	viewRange=MAX_VIEW_RANGE;
 	timeOffset=0;
 	drawFog=true;
+	compressTextures=false;
 	teamNanospray=false;
 	autoQuit=false;
 	quitTime=0;

Modified: trunk/rts/System/GlobalStuff.h
===================================================================
--- trunk/rts/System/GlobalStuff.h	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/System/GlobalStuff.h	2008-05-12 15:05:51 UTC (rev 5879)
@@ -442,7 +442,7 @@
 public:
 	CR_DECLARE(CGlobalUnsyncedStuff);
 	CGlobalUnsyncedStuff(); 		//!&lt; Constructor
-	~CGlobalUnsyncedStuff(); 	//!&lt; Destructor
+	~CGlobalUnsyncedStuff();	 	//!&lt; Destructor
 
 	int usRandInt(); 			//!&lt; Unsynced random int
 	float usRandFloat(); 			//!&lt; Unsynced random float
@@ -586,6 +586,13 @@
 	 * Whether fog (of war) is drawn or not
 	 */
 	bool drawFog;
+	
+	/**
+	 * @brief compressTextures
+	 *
+	 * If set, many (not all) textures will compressed on run-time.
+	*/
+	bool compressTextures;
 
 	/**
 	 * @brief quit automatically?

Modified: trunk/rts/System/SpringApp.cpp
===================================================================
--- trunk/rts/System/SpringApp.cpp	2008-05-12 13:06:34 UTC (rev 5878)
+++ trunk/rts/System/SpringApp.cpp	2008-05-12 15:05:51 UTC (rev 5879)
@@ -224,6 +224,13 @@
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 	SDL_GL_SwapBuffers();
 
+	// Runtime compress textures?
+	if (GLEW_ARB_texture_compression) {
+		// we don't even need to check it, 'cos groundtextures must have that extension
+		// default to off because it reduces quality (smallest mipmap level is bigger)
+		gu-&gt;compressTextures = !!configHandler.GetInt(&quot;CompressTextures&quot;, 0);
+	}
+
 	// Initialize named texture handler
 	CNamedTextures::Init();
 
@@ -392,6 +399,12 @@
 		glHint(GL_POINT_SMOOTH_HINT, hint);
 	}
 
+	// setup LOD bias factor
+	const float lodBias = std::max(std::min( configHandler.GetFloat(&quot;TextureLODBias&quot;, 0.0f) , 4.0f), -4.0f);
+	if (fabs(lodBias)&gt;0.01f) {
+		glTexEnvf(GL_TEXTURE_FILTER_CONTROL,GL_TEXTURE_LOD_BIAS, lodBias );
+	}
+
 	// there must be a way to see if this is necessary, compare old/new context pointers?
 	if (!!configHandler.GetInt(&quot;FixAltTab&quot;, 0)) {
 		// free GL resources


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000658.html">[Taspring-linux-commit] r5878 - in trunk/rts: Lua Sim/Units	Sim/Units/CommandAI Sim/Units/UnitTypes
</A></li>
	<LI>Next message: <A HREF="000660.html">[Taspring-linux-commit] r5880 - in trunk/rts: Game/UI Rendering/Env	build/vstudio8
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#659">[ date ]</a>
              <a href="thread.html#659">[ thread ]</a>
              <a href="subject.html#659">[ subject ]</a>
              <a href="author.html#659">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
