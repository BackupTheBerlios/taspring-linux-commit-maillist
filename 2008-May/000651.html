<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5871 - in trunk:	installer/builddata/bitmaps rts rts/Game rts/Game/Camera	rts/Game/Server rts/Game/UI rts/Lua rts/Map rts/Sim/Features	rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Units rts/System	rts/System/FileSystem rts/System/Net
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5871%20-%20in%20trunk%3A%0A%09installer/builddata/bitmaps%20rts%20rts/Game%20rts/Game/Camera%0A%09rts/Game/Server%20rts/Game/UI%20rts/Lua%20rts/Map%20rts/Sim/Features%0A%09rts/Sim/Misc%20rts/Sim/MoveTypes%20rts/Sim/Units%20rts/System%0A%09rts/System/FileSystem%20rts/System/Net&In-Reply-To=%3C20080512095656.51CA047D9%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000650.html">
   <LINK REL="Next"  HREF="000652.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5871 - in trunk:	installer/builddata/bitmaps rts rts/Game rts/Game/Camera	rts/Game/Server rts/Game/UI rts/Lua rts/Map rts/Sim/Features	rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Units rts/System	rts/System/FileSystem rts/System/Net</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5871%20-%20in%20trunk%3A%0A%09installer/builddata/bitmaps%20rts%20rts/Game%20rts/Game/Camera%0A%09rts/Game/Server%20rts/Game/UI%20rts/Lua%20rts/Map%20rts/Sim/Features%0A%09rts/Sim/Misc%20rts/Sim/MoveTypes%20rts/Sim/Units%20rts/System%0A%09rts/System/FileSystem%20rts/System/Net&In-Reply-To=%3C20080512095656.51CA047D9%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5871 - in trunk:	installer/builddata/bitmaps rts rts/Game rts/Game/Camera	rts/Game/Server rts/Game/UI rts/Lua rts/Map rts/Sim/Features	rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Units rts/System	rts/System/FileSystem rts/System/Net">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Mon May 12 11:56:56 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000650.html">[Taspring-linux-commit] r5870 - trunk/rts/Sim/Weapons
</A></li>
        <LI>Next message: <A HREF="000652.html">[Taspring-linux-commit] r5872 - in trunk: game/LuaUI	installer/builddata/springcontent/LuaGadgets rts/Game	rts/Game/UI tools/DedicatedServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#651">[ date ]</a>
              <a href="thread.html#651">[ thread ]</a>
              <a href="subject.html#651">[ subject ]</a>
              <a href="author.html#651">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tvo
Date: 2008-05-12 11:56:55 +0200 (Mon, 12 May 2008)
New Revision: 5871

Modified:
   trunk/installer/builddata/bitmaps/README.txt
   trunk/rts/Game/Action.cpp
   trunk/rts/Game/Action.h
   trunk/rts/Game/Camera/SmoothController.cpp
   trunk/rts/Game/Camera/SmoothController.h
   trunk/rts/Game/ChatMessage.cpp
   trunk/rts/Game/ChatMessage.h
   trunk/rts/Game/CommandMessage.cpp
   trunk/rts/Game/CommandMessage.h
   trunk/rts/Game/Console.cpp
   trunk/rts/Game/Console.h
   trunk/rts/Game/GameData.cpp
   trunk/rts/Game/GameData.h
   trunk/rts/Game/Server/MsgStrings.h
   trunk/rts/Game/UI/ProfileDrawer.cpp
   trunk/rts/Game/UI/ProfileDrawer.h
   trunk/rts/Lua/LuaCallInCheck.cpp
   trunk/rts/Lua/LuaCallInCheck.h
   trunk/rts/Map/HeightLinePalette.cpp
   trunk/rts/Map/HeightLinePalette.h
   trunk/rts/Map/HeightMapTexture.cpp
   trunk/rts/Map/HeightMapTexture.h
   trunk/rts/Map/MapInfo.cpp
   trunk/rts/Map/MapInfo.h
   trunk/rts/Sim/Features/Feature.cpp
   trunk/rts/Sim/Features/Feature.h
   trunk/rts/Sim/Features/FeatureDef.h
   trunk/rts/Sim/Features/FeatureHandler.cpp
   trunk/rts/Sim/Features/FeatureHandler.h
   trunk/rts/Sim/Features/FeatureSet.cpp
   trunk/rts/Sim/Features/FeatureSet.h
   trunk/rts/Sim/Misc/CollisionHandler.cpp
   trunk/rts/Sim/Misc/CollisionHandler.h
   trunk/rts/Sim/Misc/CollisionVolume.h
   trunk/rts/Sim/Misc/GroundBlockingObjectMap.cpp
   trunk/rts/Sim/Misc/GroundBlockingObjectMap.h
   trunk/rts/Sim/MoveTypes/AAirMoveType.cpp
   trunk/rts/Sim/MoveTypes/AAirMoveType.h
   trunk/rts/Sim/Units/UnitImage.h
   trunk/rts/System/FastMath.h
   trunk/rts/System/FileSystem/FileFilter.cpp
   trunk/rts/System/FileSystem/FileFilter.h
   trunk/rts/System/Net/PackPacket.cpp
   trunk/rts/System/Net/PackPacket.h
   trunk/rts/System/Net/Socket.cpp
   trunk/rts/System/Net/Socket.h
   trunk/rts/System/Net/UDPConnectedSocket.cpp
   trunk/rts/System/Net/UDPConnectedSocket.h
   trunk/rts/System/Net/UnpackPacket.cpp
   trunk/rts/System/Net/UnpackPacket.h
   trunk/rts/System/SFloat3.h
   trunk/rts/System/SpringApp.cpp
   trunk/rts/System/SpringApp.h
   trunk/rts/System/UnsyncedRNG.cpp
   trunk/rts/System/UnsyncedRNG.h
   trunk/rts/spring.exe.manifest
Log:
* Set svn:eol-style to native, so patches apply with less problems.



Modified: trunk/installer/builddata/bitmaps/README.txt
===================================================================
--- trunk/installer/builddata/bitmaps/README.txt	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/installer/builddata/bitmaps/README.txt	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,67 +1,67 @@
-This is a list of authors (and licenses) of the various bitmap files,
-as I (tvo) figured out during december 2006 / january 2007.
-
-The tree files (birch*, gran*) were generated in some program.
-
-There are various files that are just resampled copies of each other,
-or files that are identical to another file apart from an alpha channel.
-
-The files marked with &quot;probably SJ/Yeha&quot; were part of the initial CVS import in 2005,
-no one really remembers who made them but SJ and Yeha are pretty sure they made them :-)
-
----
-
-Bark.bmp		Erom and aGorm (GNU FDL or CC-BY-SA: <A HREF="http://commons.wikimedia.org/wiki/Image:Red_Maple_Acer_rubrum_Bark_Detail_1842px.jpg">http://commons.wikimedia.org/wiki/Image:Red_Maple_Acer_rubrum_Bark_Detail_1842px.jpg</A>)
-arm1.gif		Neuralize
-armsilo1.bmp		Erom (public domain)
-birch1.bmp		Yeha
-birch2.bmp		Yeha
-birch3.bmp		Yeha
-bleaf.bmp		Erom (GNU FDL: <A HREF="http://commons.wikimedia.org/wiki/Image:Folla_Hortensia_013eue.jpg">http://commons.wikimedia.org/wiki/Image:Folla_Hortensia_013eue.jpg</A>)
-boatshape.bmp		SJ
-button.bmp		probably SJ/Yeha
-cdet.bmp		probably SJ/Yeha
-check.bmp		probably SJ/Yeha
-circles.tga		Yeha
-circularthingy.tga	Yeha
-clouddetail.bmp		probably SJ/Yeha
-core1.gif		Neuralize
-detailtex.bmp		probably SJ/Yeha
-detailtex2.bmp		probably SJ/Yeha
-emptyBuildPane.bmp	probably SJ/Yeha
-explo.bmp		ripped from some game
-explo.tga		ripped from some game
-explofade.tga		ripped from some game
-flame.tga		Argh
-flare.bmp		Yeha (source unknown, TODO: ask Yeha)
-flare.tga		Yeha (source unknown, TODO: ask Yeha)
-foam.jpg		Erom and aGorm (GNU FDL or CC-BY-SA: <A HREF="http://commons.wikimedia.org/wiki/Image:Gischt_schiff.jpg">http://commons.wikimedia.org/wiki/Image:Gischt_schiff.jpg</A>)
-gran.bmp		Yeha
-gran2.bmp		Yeha
-graphPaper.bmp		probably SJ/Yeha
-grass3.jpg		probably SJ/Yeha
-grassA.bmp		probably SJ/Yeha
-groundflash.tga		Yeha
-groundring.tga		Yeha
-guiicon_move.bmp	probably SJ/Yeha
-hovershape.bmp		SJ
-largelaserfalloff.tga	Yeha
-laserend.tga		Yeha
-laserfalloff.tga	Yeha
-muzzlefront.tga		Yeha
-muzzleside.tga		Yeha
-ocean.jpg		from the golgotha texture set (public domain)
-pane.bmp		probably SJ/Yeha
-randdots.tga		Yeha
-scars/*			people on the forum (TODO: figure out who?)
-scrollbar.bmp		probably SJ/Yeha
-sidebar.bmp		probably SJ/Yeha
-smoke/*			Yeha (source unknown, TODO: ask Yeha)
-smoketrail.tga		Yeha
-spacer.bmp		probably SJ/Yeha
-spectator.GIF		probably SJ/Yeha
-stateButton.bmp		probably SJ/Yeha
-tooltip.bmp		probably SJ/Yeha
-tracks/ComTrack.bmp	SJ
-tracks/StdTank.bmp	SJ
-wake.tga		Yeha
+This is a list of authors (and licenses) of the various bitmap files,
+as I (tvo) figured out during december 2006 / january 2007.
+
+The tree files (birch*, gran*) were generated in some program.
+
+There are various files that are just resampled copies of each other,
+or files that are identical to another file apart from an alpha channel.
+
+The files marked with &quot;probably SJ/Yeha&quot; were part of the initial CVS import in 2005,
+no one really remembers who made them but SJ and Yeha are pretty sure they made them :-)
+
+---
+
+Bark.bmp		Erom and aGorm (GNU FDL or CC-BY-SA: <A HREF="http://commons.wikimedia.org/wiki/Image:Red_Maple_Acer_rubrum_Bark_Detail_1842px.jpg">http://commons.wikimedia.org/wiki/Image:Red_Maple_Acer_rubrum_Bark_Detail_1842px.jpg</A>)
+arm1.gif		Neuralize
+armsilo1.bmp		Erom (public domain)
+birch1.bmp		Yeha
+birch2.bmp		Yeha
+birch3.bmp		Yeha
+bleaf.bmp		Erom (GNU FDL: <A HREF="http://commons.wikimedia.org/wiki/Image:Folla_Hortensia_013eue.jpg">http://commons.wikimedia.org/wiki/Image:Folla_Hortensia_013eue.jpg</A>)
+boatshape.bmp		SJ
+button.bmp		probably SJ/Yeha
+cdet.bmp		probably SJ/Yeha
+check.bmp		probably SJ/Yeha
+circles.tga		Yeha
+circularthingy.tga	Yeha
+clouddetail.bmp		probably SJ/Yeha
+core1.gif		Neuralize
+detailtex.bmp		probably SJ/Yeha
+detailtex2.bmp		probably SJ/Yeha
+emptyBuildPane.bmp	probably SJ/Yeha
+explo.bmp		ripped from some game
+explo.tga		ripped from some game
+explofade.tga		ripped from some game
+flame.tga		Argh
+flare.bmp		Yeha (source unknown, TODO: ask Yeha)
+flare.tga		Yeha (source unknown, TODO: ask Yeha)
+foam.jpg		Erom and aGorm (GNU FDL or CC-BY-SA: <A HREF="http://commons.wikimedia.org/wiki/Image:Gischt_schiff.jpg">http://commons.wikimedia.org/wiki/Image:Gischt_schiff.jpg</A>)
+gran.bmp		Yeha
+gran2.bmp		Yeha
+graphPaper.bmp		probably SJ/Yeha
+grass3.jpg		probably SJ/Yeha
+grassA.bmp		probably SJ/Yeha
+groundflash.tga		Yeha
+groundring.tga		Yeha
+guiicon_move.bmp	probably SJ/Yeha
+hovershape.bmp		SJ
+largelaserfalloff.tga	Yeha
+laserend.tga		Yeha
+laserfalloff.tga	Yeha
+muzzlefront.tga		Yeha
+muzzleside.tga		Yeha
+ocean.jpg		from the golgotha texture set (public domain)
+pane.bmp		probably SJ/Yeha
+randdots.tga		Yeha
+scars/*			people on the forum (TODO: figure out who?)
+scrollbar.bmp		probably SJ/Yeha
+sidebar.bmp		probably SJ/Yeha
+smoke/*			Yeha (source unknown, TODO: ask Yeha)
+smoketrail.tga		Yeha
+spacer.bmp		probably SJ/Yeha
+spectator.GIF		probably SJ/Yeha
+stateButton.bmp		probably SJ/Yeha
+tooltip.bmp		probably SJ/Yeha
+tracks/ComTrack.bmp	SJ
+tracks/StdTank.bmp	SJ
+wake.tga		Yeha


Property changes on: trunk/installer/builddata/bitmaps/README.txt
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/Action.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/Action.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/Camera/SmoothController.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/Camera/SmoothController.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/ChatMessage.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/ChatMessage.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/CommandMessage.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/CommandMessage.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/Console.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/Console.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/GameData.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/GameData.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/Server/MsgStrings.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/UI/ProfileDrawer.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Game/UI/ProfileDrawer.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Lua/LuaCallInCheck.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Lua/LuaCallInCheck.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Map/HeightLinePalette.cpp
===================================================================
--- trunk/rts/Map/HeightLinePalette.cpp	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/Map/HeightLinePalette.cpp	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,40 +1,40 @@
-#include &quot;HeightLinePalette.h&quot;
-
-#include &quot;Platform/ConfigHandler.h&quot;
-
-
-/** @brief Generates the height line palette.
-Based on the configuration variable &quot;ColorElev&quot; (default: 1), it either
-generates a colored palette or a grayscale palette. */
-
-CHeightLinePalette::CHeightLinePalette()
-{
-	if(configHandler.GetInt(&quot;ColorElev&quot;,1)){
-		for(int a=0;a&lt;86;++a){
-			heightLinePal[a*3+0]=255-a*3;
-			heightLinePal[a*3+1]=a*3;
-			heightLinePal[a*3+2]=0;
-		}
-		for(int a=86;a&lt;172;++a){
-			heightLinePal[a*3+0]=0;
-			heightLinePal[a*3+1]=255-(a-86)*3;
-			heightLinePal[a*3+2]=(a-86)*3;
-		}
-		for(int a=172;a&lt;256;++a){
-			heightLinePal[a*3+0]=(a-172)*3;
-			heightLinePal[a*3+1]=0;
-			heightLinePal[a*3+2]=255-(a-172)*3;
-		}
-	} else {
-		for(int a=0;a&lt;29;++a){
-			heightLinePal[a*3+0]=255-a*8;
-			heightLinePal[a*3+1]=255-a*8;
-			heightLinePal[a*3+2]=255-a*8;
-		}
-		for(int a=29;a&lt;256;++a){
-			heightLinePal[a*3+0]=a;
-			heightLinePal[a*3+1]=a;
-			heightLinePal[a*3+2]=a;
-		}
-	}
-}
+#include &quot;HeightLinePalette.h&quot;
+
+#include &quot;Platform/ConfigHandler.h&quot;
+
+
+/** @brief Generates the height line palette.
+Based on the configuration variable &quot;ColorElev&quot; (default: 1), it either
+generates a colored palette or a grayscale palette. */
+
+CHeightLinePalette::CHeightLinePalette()
+{
+	if(configHandler.GetInt(&quot;ColorElev&quot;,1)){
+		for(int a=0;a&lt;86;++a){
+			heightLinePal[a*3+0]=255-a*3;
+			heightLinePal[a*3+1]=a*3;
+			heightLinePal[a*3+2]=0;
+		}
+		for(int a=86;a&lt;172;++a){
+			heightLinePal[a*3+0]=0;
+			heightLinePal[a*3+1]=255-(a-86)*3;
+			heightLinePal[a*3+2]=(a-86)*3;
+		}
+		for(int a=172;a&lt;256;++a){
+			heightLinePal[a*3+0]=(a-172)*3;
+			heightLinePal[a*3+1]=0;
+			heightLinePal[a*3+2]=255-(a-172)*3;
+		}
+	} else {
+		for(int a=0;a&lt;29;++a){
+			heightLinePal[a*3+0]=255-a*8;
+			heightLinePal[a*3+1]=255-a*8;
+			heightLinePal[a*3+2]=255-a*8;
+		}
+		for(int a=29;a&lt;256;++a){
+			heightLinePal[a*3+0]=a;
+			heightLinePal[a*3+1]=a;
+			heightLinePal[a*3+2]=a;
+		}
+	}
+}


Property changes on: trunk/rts/Map/HeightLinePalette.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Map/HeightLinePalette.h
===================================================================
--- trunk/rts/Map/HeightLinePalette.h	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/Map/HeightLinePalette.h	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,18 +1,18 @@
-#ifndef HEIGHTLINEPALETTE_H
-#define HEIGHTLINEPALETTE_H
-
-/** @brief The palette used in heightmap rendering mode (F1). */
-class CHeightLinePalette
-{
-public:
-	CHeightLinePalette();
-
-	/** @brief Gets the palette.
-	The palette data consists of 256 RGB triplets with range 0-255. */
-	const unsigned char* GetData() const { return heightLinePal; }
-
-private:
-	unsigned char heightLinePal[3*256];
-};
-
-#endif
+#ifndef HEIGHTLINEPALETTE_H
+#define HEIGHTLINEPALETTE_H
+
+/** @brief The palette used in heightmap rendering mode (F1). */
+class CHeightLinePalette
+{
+public:
+	CHeightLinePalette();
+
+	/** @brief Gets the palette.
+	The palette data consists of 256 RGB triplets with range 0-255. */
+	const unsigned char* GetData() const { return heightLinePal; }
+
+private:
+	unsigned char heightLinePal[3*256];
+};
+
+#endif


Property changes on: trunk/rts/Map/HeightLinePalette.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Map/HeightMapTexture.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Map/HeightMapTexture.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Map/MapInfo.cpp
===================================================================
--- trunk/rts/Map/MapInfo.cpp	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/Map/MapInfo.cpp	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,188 +1,188 @@
-#include &quot;MapInfo.h&quot;
-
-#include &quot;TdfParser.h&quot;
-
-
-// before delete, the const is const_cast'ed away.
-// there are no (other) situations where mapInfo may be modified
-const CMapInfo* mapInfo;
-
-
-CMapInfo::CMapInfo(const std::string&amp; mapname)
-{
-	map.name = mapname;
-	mapDefParser = new TdfParser(GetTDFName(mapname));
-	resources = new TdfParser(&quot;gamedata/resources.tdf&quot;);
-
-	ReadGlobal();
-	ReadAtmosphere();
-	ReadGui();
-	ReadLight();
-	ReadWater();
-	ReadSmf();
-	ReadSm3();
-	ReadTerrainTypes();
-
-	delete resources;
-	resources = NULL;
-}
-
-
-CMapInfo::~CMapInfo()
-{
-	delete mapDefParser;
-	mapDefParser = NULL;
-}
-
-
-/** @brief Opens the TDF file from the given map in parser.
-	FIXME: This is mostly a hack to supply CGameSetup with start positions,
-	when no CMapInfo object has yet been created.
- */
-void CMapInfo::OpenTDF(const std::string&amp; mapname, TdfParser&amp; parser)
-{
-	parser.LoadFile(GetTDFName(mapname));
-}
-
-
-/** @brief Get the name of the TDF file with map settings.
-	@return &quot;maps/%.smd&quot; for &quot;%.smf&quot; and &quot;maps/%.sm3&quot; for &quot;%.sm3&quot;
- */
-std::string CMapInfo::GetTDFName(const std::string&amp; mapname)
-{
-	if (mapname.length() &lt; 3)
-		throw std::runtime_error(&quot;CMapInfo::GetTDFName(): mapname '&quot; + mapname + &quot;' too short&quot;);
-
-	std::string extension = mapname.substr(mapname.length() - 3);
-	if (extension == &quot;smf&quot;)
-		return std::string(&quot;maps/&quot;) + mapname.substr(0, mapname.find_last_of('.')) + &quot;.smd&quot;;
-	else if(extension == &quot;sm3&quot;)
-		return std::string(&quot;maps/&quot;) + mapname;
-	else
-		throw std::runtime_error(&quot;CMapInfo::GetTDFName(): Unknown extension: &quot; + extension);
-}
-
-
-void CMapInfo::ReadGlobal()
-{
-	map.humanName = mapDefParser-&gt;SGetValueDef(map.name, &quot;MAP\\Description&quot;);
-	map.wantedScript = mapDefParser-&gt;SGetValueDef(map.wantedScript, &quot;MAP\\Script&quot;);
-
-	mapDefParser-&gt;GetTDef(map.hardness, 100.0f, &quot;MAP\\MapHardness&quot;);
-	map.notDeformable = mapDefParser-&gt;SGetValueDef(&quot;0&quot;, &quot;MAP\\NotDeformable&quot;) != &quot;0&quot;;
-
-	mapDefParser-&gt;GetTDef(map.gravity, 130.0f, &quot;MAP\\Gravity&quot;);
-	map.gravity = -map.gravity / (GAME_SPEED * GAME_SPEED);
-
-	mapDefParser-&gt;GetTDef(map.tidalStrength, 0.0f, &quot;MAP\\TidalStrength&quot;);
-	mapDefParser-&gt;GetTDef(map.maxMetal, 0.02f, &quot;MAP\\MaxMetal&quot;);
-	mapDefParser-&gt;GetTDef(map.extractorRadius, 500.0f, &quot;MAP\\ExtractorRadius&quot;);
-
-	mapDefParser-&gt;GetDef(map.voidWater, &quot;0&quot;, &quot;MAP\\voidWater&quot;);
-}
-
-
-void CMapInfo::ReadGui()
-{
-	// GUI
-	mapDefParser-&gt;GetTDef(gui.autoShowMetal, true, &quot;MAP\\autoShowMetal&quot;);
-}
-
-
-void CMapInfo::ReadAtmosphere()
-{
-	// MAP\ATMOSPHERE
-	mapDefParser-&gt;GetTDef(atmosphere.cloudDensity, 0.5f, &quot;MAP\\ATMOSPHERE\\CloudDensity&quot;);
-	mapDefParser-&gt;GetTDef(atmosphere.fogStart, 0.1f, &quot;MAP\\ATMOSPHERE\\FogStart&quot;);
-	atmosphere.fogColor = mapDefParser-&gt;GetFloat3(float3(0.7f, 0.7f, 0.8f), &quot;MAP\\ATMOSPHERE\\FogColor&quot;);
-	atmosphere.skyColor = mapDefParser-&gt;GetFloat3(float3(0.1f, 0.15f, 0.7f), &quot;MAP\\ATMOSPHERE\\SkyColor&quot;);
-	atmosphere.sunColor = mapDefParser-&gt;GetFloat3(float3(1.0f, 1.0f, 1.0f), &quot;MAP\\ATMOSPHERE\\SunColor&quot;);
-	atmosphere.cloudColor = mapDefParser-&gt;GetFloat3(float3(1.0f, 1.0f, 1.0f), &quot;MAP\\ATMOSPHERE\\CloudColor&quot;);
-	mapDefParser-&gt;GetTDef(atmosphere.minWind, 5.0f, &quot;MAP\\ATMOSPHERE\\MinWind&quot;);
-	mapDefParser-&gt;GetTDef(atmosphere.maxWind, 25.0f, &quot;MAP\\ATMOSPHERE\\MaxWind&quot;);
-	mapDefParser-&gt;GetDef(atmosphere.skyBox, &quot;&quot;, &quot;MAP\\ATMOSPHERE\\SkyBox&quot;);
-}
-
-
-void CMapInfo::ReadLight()
-{
-	// MAP\LIGHT
-	light.sunDir = mapDefParser-&gt;GetFloat3(float3(0.0f, 1.0f, 2.0f), &quot;MAP\\LIGHT\\SunDir&quot;);
-	light.sunDir.Normalize();
-	light.sunDir4[0] = light.sunDir[0];
-	light.sunDir4[1] = light.sunDir[1];
-	light.sunDir4[2] = light.sunDir[2];
-	light.sunDir4[3] = 0.0f;
-
-	light.groundAmbientColor = mapDefParser-&gt;GetFloat3(float3(0.5f, 0.5f, 0.5f), &quot;MAP\\LIGHT\\GroundAmbientColor&quot;);
-	light.groundSunColor = mapDefParser-&gt;GetFloat3(float3(0.5f, 0.5f, 0.5f), &quot;MAP\\LIGHT\\GroundSunColor&quot;);
-	light.groundSpecularColor = mapDefParser-&gt;GetFloat3(float3(0.1f, 0.1f, 0.1f), &quot;MAP\\LIGHT\\GroundSpecularColor&quot;);
-	mapDefParser-&gt;GetTDef(light.groundShadowDensity, 0.8f, &quot;MAP\\LIGHT\\GroundShadowDensity&quot;);
-
-	light.unitAmbientColor = mapDefParser-&gt;GetFloat3(float3(0.4f, 0.4f, 0.4f), &quot;MAP\\LIGHT\\UnitAmbientColor&quot;);
-	light.unitSunColor = mapDefParser-&gt;GetFloat3(float3(0.7f, 0.7f, 0.7f), &quot;MAP\\LIGHT\\UnitSunColor&quot;);
-	light.specularSunColor = mapDefParser-&gt;GetFloat3(light.unitSunColor, &quot;MAP\\LIGHT\\SpecularSunColor&quot;);
-	mapDefParser-&gt;GetTDef(light.unitShadowDensity, 0.8f, &quot;MAP\\LIGHT\\UnitShadowDensity&quot;);
-}
-
-
-void CMapInfo::ReadWater()
-{
-	// MAP\WATER
-	mapDefParser-&gt;GetTDef(water.repeatX, 0.0f, &quot;MAP\\WATER\\WaterRepeatX&quot;);
-	mapDefParser-&gt;GetTDef(water.repeatY, 0.0f, &quot;MAP\\WATER\\WaterRepeatY&quot;);
-	mapDefParser-&gt;GetTDef(water.damage, 0.0f, &quot;MAP\\WATER\\WaterDamage&quot;);
-	water.damage *= 16.0f / 30.0f;
-	
-	std::string tmp;
-	mapDefParser-&gt;GetDef(tmp, &quot;&quot;, &quot;MAP\\WATER\\WaterPlaneColor&quot;);
-	hasWaterPlane = !tmp.empty();
-	water.planeColor = mapDefParser-&gt;GetFloat3(float3(0.0f, 0.4f, 0.0f), &quot;MAP\\WATER\\WaterPlaneColor&quot;);
-
-	water.surfaceColor = mapDefParser-&gt;GetFloat3(float3(0.75f, 0.8f, 0.85f), &quot;MAP\\WATER\\WaterSurfaceColor&quot;);
-	water.absorb = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterAbsorb&quot;);
-	water.baseColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterBaseColor&quot;);
-	water.minColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterMinColor&quot;);
-	mapDefParser-&gt;GetDef(water.texture, &quot;&quot;, &quot;MAP\\WATER\\WaterTexture&quot;);
-
-	//default water is ocean.jpg in bitmaps, map specific water textures is saved in the map dir
-	if(water.texture.empty())
-		water.texture = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;ocean.jpg&quot;, &quot;resources\\graphics\\maps\\watertex&quot;);
-	else
-		water.texture = &quot;maps/&quot; + water.texture;
-}
-
-
-void CMapInfo::ReadSmf()
-{
-	// SMF specific settings
-	mapDefParser-&gt;GetDef(smf.detailTexName, &quot;&quot;, &quot;MAP\\DetailTex&quot;);
-	if (smf.detailTexName.empty())
-		smf.detailTexName = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;detailtex2.bmp&quot;, &quot;resources\\graphics\\maps\\detailtex&quot;);
-	else
-		smf.detailTexName = &quot;maps/&quot; + smf.detailTexName;
-}
-
-
-void CMapInfo::ReadSm3()
-{
-	// SM3 specific settings
-	sm3.minimap = mapDefParser-&gt;SGetValueDef(&quot;&quot;, &quot;MAP\\minimap&quot;);
-}
-
-
-void CMapInfo::ReadTerrainTypes()
-{
-	for (int a = 0; a &lt; 256; ++a) {
-		char tname[200];
-		sprintf(tname, &quot;MAP\\TerrainType%i\\&quot;, a);
-		std::string section = tname;
-		mapDefParser-&gt;GetDef (terrainTypes[a].name,  &quot;Default&quot;, section + &quot;name&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].hardness,   1.0f, section + &quot;hardness&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].tankSpeed,  1.0f, section + &quot;tankmovespeed&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].kbotSpeed,  1.0f, section + &quot;kbotmovespeed&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].hoverSpeed, 1.0f, section + &quot;hovermovespeed&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].shipSpeed,  1.0f, section + &quot;shipmovespeed&quot;);
-		mapDefParser-&gt;GetDef(terrainTypes[a].receiveTracks, &quot;1&quot;, section + &quot;receivetracks&quot;);
-	}
-}
+#include &quot;MapInfo.h&quot;
+
+#include &quot;TdfParser.h&quot;
+
+
+// before delete, the const is const_cast'ed away.
+// there are no (other) situations where mapInfo may be modified
+const CMapInfo* mapInfo;
+
+
+CMapInfo::CMapInfo(const std::string&amp; mapname)
+{
+	map.name = mapname;
+	mapDefParser = new TdfParser(GetTDFName(mapname));
+	resources = new TdfParser(&quot;gamedata/resources.tdf&quot;);
+
+	ReadGlobal();
+	ReadAtmosphere();
+	ReadGui();
+	ReadLight();
+	ReadWater();
+	ReadSmf();
+	ReadSm3();
+	ReadTerrainTypes();
+
+	delete resources;
+	resources = NULL;
+}
+
+
+CMapInfo::~CMapInfo()
+{
+	delete mapDefParser;
+	mapDefParser = NULL;
+}
+
+
+/** @brief Opens the TDF file from the given map in parser.
+	FIXME: This is mostly a hack to supply CGameSetup with start positions,
+	when no CMapInfo object has yet been created.
+ */
+void CMapInfo::OpenTDF(const std::string&amp; mapname, TdfParser&amp; parser)
+{
+	parser.LoadFile(GetTDFName(mapname));
+}
+
+
+/** @brief Get the name of the TDF file with map settings.
+	@return &quot;maps/%.smd&quot; for &quot;%.smf&quot; and &quot;maps/%.sm3&quot; for &quot;%.sm3&quot;
+ */
+std::string CMapInfo::GetTDFName(const std::string&amp; mapname)
+{
+	if (mapname.length() &lt; 3)
+		throw std::runtime_error(&quot;CMapInfo::GetTDFName(): mapname '&quot; + mapname + &quot;' too short&quot;);
+
+	std::string extension = mapname.substr(mapname.length() - 3);
+	if (extension == &quot;smf&quot;)
+		return std::string(&quot;maps/&quot;) + mapname.substr(0, mapname.find_last_of('.')) + &quot;.smd&quot;;
+	else if(extension == &quot;sm3&quot;)
+		return std::string(&quot;maps/&quot;) + mapname;
+	else
+		throw std::runtime_error(&quot;CMapInfo::GetTDFName(): Unknown extension: &quot; + extension);
+}
+
+
+void CMapInfo::ReadGlobal()
+{
+	map.humanName = mapDefParser-&gt;SGetValueDef(map.name, &quot;MAP\\Description&quot;);
+	map.wantedScript = mapDefParser-&gt;SGetValueDef(map.wantedScript, &quot;MAP\\Script&quot;);
+
+	mapDefParser-&gt;GetTDef(map.hardness, 100.0f, &quot;MAP\\MapHardness&quot;);
+	map.notDeformable = mapDefParser-&gt;SGetValueDef(&quot;0&quot;, &quot;MAP\\NotDeformable&quot;) != &quot;0&quot;;
+
+	mapDefParser-&gt;GetTDef(map.gravity, 130.0f, &quot;MAP\\Gravity&quot;);
+	map.gravity = -map.gravity / (GAME_SPEED * GAME_SPEED);
+
+	mapDefParser-&gt;GetTDef(map.tidalStrength, 0.0f, &quot;MAP\\TidalStrength&quot;);
+	mapDefParser-&gt;GetTDef(map.maxMetal, 0.02f, &quot;MAP\\MaxMetal&quot;);
+	mapDefParser-&gt;GetTDef(map.extractorRadius, 500.0f, &quot;MAP\\ExtractorRadius&quot;);
+
+	mapDefParser-&gt;GetDef(map.voidWater, &quot;0&quot;, &quot;MAP\\voidWater&quot;);
+}
+
+
+void CMapInfo::ReadGui()
+{
+	// GUI
+	mapDefParser-&gt;GetTDef(gui.autoShowMetal, true, &quot;MAP\\autoShowMetal&quot;);
+}
+
+
+void CMapInfo::ReadAtmosphere()
+{
+	// MAP\ATMOSPHERE
+	mapDefParser-&gt;GetTDef(atmosphere.cloudDensity, 0.5f, &quot;MAP\\ATMOSPHERE\\CloudDensity&quot;);
+	mapDefParser-&gt;GetTDef(atmosphere.fogStart, 0.1f, &quot;MAP\\ATMOSPHERE\\FogStart&quot;);
+	atmosphere.fogColor = mapDefParser-&gt;GetFloat3(float3(0.7f, 0.7f, 0.8f), &quot;MAP\\ATMOSPHERE\\FogColor&quot;);
+	atmosphere.skyColor = mapDefParser-&gt;GetFloat3(float3(0.1f, 0.15f, 0.7f), &quot;MAP\\ATMOSPHERE\\SkyColor&quot;);
+	atmosphere.sunColor = mapDefParser-&gt;GetFloat3(float3(1.0f, 1.0f, 1.0f), &quot;MAP\\ATMOSPHERE\\SunColor&quot;);
+	atmosphere.cloudColor = mapDefParser-&gt;GetFloat3(float3(1.0f, 1.0f, 1.0f), &quot;MAP\\ATMOSPHERE\\CloudColor&quot;);
+	mapDefParser-&gt;GetTDef(atmosphere.minWind, 5.0f, &quot;MAP\\ATMOSPHERE\\MinWind&quot;);
+	mapDefParser-&gt;GetTDef(atmosphere.maxWind, 25.0f, &quot;MAP\\ATMOSPHERE\\MaxWind&quot;);
+	mapDefParser-&gt;GetDef(atmosphere.skyBox, &quot;&quot;, &quot;MAP\\ATMOSPHERE\\SkyBox&quot;);
+}
+
+
+void CMapInfo::ReadLight()
+{
+	// MAP\LIGHT
+	light.sunDir = mapDefParser-&gt;GetFloat3(float3(0.0f, 1.0f, 2.0f), &quot;MAP\\LIGHT\\SunDir&quot;);
+	light.sunDir.Normalize();
+	light.sunDir4[0] = light.sunDir[0];
+	light.sunDir4[1] = light.sunDir[1];
+	light.sunDir4[2] = light.sunDir[2];
+	light.sunDir4[3] = 0.0f;
+
+	light.groundAmbientColor = mapDefParser-&gt;GetFloat3(float3(0.5f, 0.5f, 0.5f), &quot;MAP\\LIGHT\\GroundAmbientColor&quot;);
+	light.groundSunColor = mapDefParser-&gt;GetFloat3(float3(0.5f, 0.5f, 0.5f), &quot;MAP\\LIGHT\\GroundSunColor&quot;);
+	light.groundSpecularColor = mapDefParser-&gt;GetFloat3(float3(0.1f, 0.1f, 0.1f), &quot;MAP\\LIGHT\\GroundSpecularColor&quot;);
+	mapDefParser-&gt;GetTDef(light.groundShadowDensity, 0.8f, &quot;MAP\\LIGHT\\GroundShadowDensity&quot;);
+
+	light.unitAmbientColor = mapDefParser-&gt;GetFloat3(float3(0.4f, 0.4f, 0.4f), &quot;MAP\\LIGHT\\UnitAmbientColor&quot;);
+	light.unitSunColor = mapDefParser-&gt;GetFloat3(float3(0.7f, 0.7f, 0.7f), &quot;MAP\\LIGHT\\UnitSunColor&quot;);
+	light.specularSunColor = mapDefParser-&gt;GetFloat3(light.unitSunColor, &quot;MAP\\LIGHT\\SpecularSunColor&quot;);
+	mapDefParser-&gt;GetTDef(light.unitShadowDensity, 0.8f, &quot;MAP\\LIGHT\\UnitShadowDensity&quot;);
+}
+
+
+void CMapInfo::ReadWater()
+{
+	// MAP\WATER
+	mapDefParser-&gt;GetTDef(water.repeatX, 0.0f, &quot;MAP\\WATER\\WaterRepeatX&quot;);
+	mapDefParser-&gt;GetTDef(water.repeatY, 0.0f, &quot;MAP\\WATER\\WaterRepeatY&quot;);
+	mapDefParser-&gt;GetTDef(water.damage, 0.0f, &quot;MAP\\WATER\\WaterDamage&quot;);
+	water.damage *= 16.0f / 30.0f;
+	
+	std::string tmp;
+	mapDefParser-&gt;GetDef(tmp, &quot;&quot;, &quot;MAP\\WATER\\WaterPlaneColor&quot;);
+	hasWaterPlane = !tmp.empty();
+	water.planeColor = mapDefParser-&gt;GetFloat3(float3(0.0f, 0.4f, 0.0f), &quot;MAP\\WATER\\WaterPlaneColor&quot;);
+
+	water.surfaceColor = mapDefParser-&gt;GetFloat3(float3(0.75f, 0.8f, 0.85f), &quot;MAP\\WATER\\WaterSurfaceColor&quot;);
+	water.absorb = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterAbsorb&quot;);
+	water.baseColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterBaseColor&quot;);
+	water.minColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterMinColor&quot;);
+	mapDefParser-&gt;GetDef(water.texture, &quot;&quot;, &quot;MAP\\WATER\\WaterTexture&quot;);
+
+	//default water is ocean.jpg in bitmaps, map specific water textures is saved in the map dir
+	if(water.texture.empty())
+		water.texture = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;ocean.jpg&quot;, &quot;resources\\graphics\\maps\\watertex&quot;);
+	else
+		water.texture = &quot;maps/&quot; + water.texture;
+}
+
+
+void CMapInfo::ReadSmf()
+{
+	// SMF specific settings
+	mapDefParser-&gt;GetDef(smf.detailTexName, &quot;&quot;, &quot;MAP\\DetailTex&quot;);
+	if (smf.detailTexName.empty())
+		smf.detailTexName = &quot;bitmaps/&quot; + resources-&gt;SGetValueDef(&quot;detailtex2.bmp&quot;, &quot;resources\\graphics\\maps\\detailtex&quot;);
+	else
+		smf.detailTexName = &quot;maps/&quot; + smf.detailTexName;
+}
+
+
+void CMapInfo::ReadSm3()
+{
+	// SM3 specific settings
+	sm3.minimap = mapDefParser-&gt;SGetValueDef(&quot;&quot;, &quot;MAP\\minimap&quot;);
+}
+
+
+void CMapInfo::ReadTerrainTypes()
+{
+	for (int a = 0; a &lt; 256; ++a) {
+		char tname[200];
+		sprintf(tname, &quot;MAP\\TerrainType%i\\&quot;, a);
+		std::string section = tname;
+		mapDefParser-&gt;GetDef (terrainTypes[a].name,  &quot;Default&quot;, section + &quot;name&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].hardness,   1.0f, section + &quot;hardness&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].tankSpeed,  1.0f, section + &quot;tankmovespeed&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].kbotSpeed,  1.0f, section + &quot;kbotmovespeed&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].hoverSpeed, 1.0f, section + &quot;hovermovespeed&quot;);
+		mapDefParser-&gt;GetTDef(terrainTypes[a].shipSpeed,  1.0f, section + &quot;shipmovespeed&quot;);
+		mapDefParser-&gt;GetDef(terrainTypes[a].receiveTracks, &quot;1&quot;, section + &quot;receivetracks&quot;);
+	}
+}


Property changes on: trunk/rts/Map/MapInfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Map/MapInfo.h
===================================================================
--- trunk/rts/Map/MapInfo.h	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/Map/MapInfo.h	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,156 +1,156 @@
-#ifndef MAPINFO_H
-#define MAPINFO_H
-
-#include &lt;string&gt;
-#include &quot;float3.h&quot;
-
-class TdfParser;
-
-
-class CMapInfo
-{
-public:
-
-	static void OpenTDF(const std::string&amp; mapname, TdfParser&amp; parser);
-	static std::string GetTDFName(const std::string&amp; mapname);
-
-	CMapInfo(const std::string&amp; mapname);
-	~CMapInfo();
-
-	/** @brief Get a readonly reference to the TDF parser.
-	    This is needed by SM3 code to load feature and layer data. */
-	const TdfParser&amp; GetMapDefParser() const { return *mapDefParser; }
-
-	/* The settings are just public members because:
-
-	   1) it's quite some work to encapsulate all of them, and
-	   2) nothing too bad happens if you modify them, there are no complex
-	      pointer members that really beg for encapsulation.
-
-	   Instead of encapsulation it is as effective and much easier make the
-	   global mapInfo const, ie. const CMapInfo* mapInfo;
-	 */
-
-	/* Note: this could (should) have been anonymous structures if only MSVC 8
-	   didn't crap out on it.  Specifically, it craps out on any class with at
-	   least 1 user defined non-inline constructor and at least 2 anonymous
-	   structures, each with at least 1 object with a constructor in it.
-	   In other words, it probably assigns the same name to each anonymous
-	   structure, and later gets confused by that.
-
-	   This sample code triggers the problem in MSVC:
-
-		class A {
-			A::A();
-			struct { std::string s1; } a1;
-			struct { std::string s2; } a2;
-		};
-		A::A() {}
-	 */
-
-	/** Global settings, ie. from &quot;MAP&quot; section. */
-	struct map_t {
-		std::string name;      ///&lt; The filename as passed to the constructor.
-		std::string wantedScript;
-		std::string humanName; ///&lt; &quot;MAP\\Description&quot;
-		float hardness;        ///&lt; &quot;MAP\\MapHardness&quot;
-		bool  notDeformable;
-		/** Stores the gravity as a negative number in units/frame^2
-		    (NOT positive units/second^2 as in the mapfile) */
-		float gravity;
-		float tidalStrength;
-		float maxMetal;
-		float extractorRadius; ///&lt; extraction radius for mines
-		bool  voidWater;
-	} map;
-
-	/** GUI settings (used by CGuiHandler) */
-	struct gui_t {
-		bool autoShowMetal;
-	} gui;
-
-	/** settings read from &quot;MAP\ATMOSPHERE&quot; section */
-	struct atmosphere_t {
-		float  cloudDensity;
-		float  fogStart;
-		float3 fogColor;
-		float3 skyColor;
-		float3 sunColor;
-		float3 cloudColor;
-		float  minWind;
-		float  maxWind;
-		std::string skyBox;
-	} atmosphere;
-
-	/** settings read from &quot;MAP\LIGHT&quot; section */
-	struct light_t {
-		float3 sunDir;     ///&lt; Holds vector for the direction of the sun
-		float  sunDir4[4]; ///&lt; sunDir as 4 component vector
-		float3 groundAmbientColor;
-		float3 groundSunColor;
-		float3 groundSpecularColor;
-		float  groundShadowDensity;
-		float3 unitAmbientColor;
-		float3 unitSunColor;
-		float3 specularSunColor;
-		float  unitShadowDensity;
-	} light;
-
-	/** settings read from &quot;MAP\WATER&quot; section
-	    prefix their name with &quot;Water&quot; to get the TDF variable */
-	struct water_t {
-		float  repeatX; ///&lt; (calculated default is in CBaseWater)
-		float  repeatY; ///&lt; (calculated default is in CBaseWater)
-		float  damage;
-		float3 absorb;
-		float3 baseColor;
-		float3 minColor;
-		float3 surfaceColor;
-		float3 planeColor;
-		std::string texture;
-	} water;
-	bool hasWaterPlane; ///&lt; true if &quot;MAP\WATER\WaterPlaneColor&quot; is set
-
-	/** SMF specific settings */
-	struct smf_t {
-		std::string detailTexName; ///&lt; &quot;MAP\DetailTex&quot;
-	} smf;
-
-	/** SM3 specific settings
-	    This is NOT complete, SM3 stores so much in the map settings
-	    that it really isn't a good idea to put them here. */
-	struct sm3_t {
-		std::string minimap; ///&lt; &quot;MAP\minimap&quot;
-	} sm3;
-
-	/** Terrain type, there can be 256 of these:
-	    &quot;MAP\TerrainType0&quot; up to &quot;MAP\TerrainType255&quot; */
-	struct TerrainType {
-		std::string name;
-		float hardness;
-		float tankSpeed;   ///&lt; &quot;TankMoveSpeed&quot;
-		float kbotSpeed;   ///&lt; &quot;KbotMoveSpeed&quot;
-		float hoverSpeed;  ///&lt; &quot;HoverMoveSpeed&quot;
-		float shipSpeed;   ///&lt; &quot;ShipMoveSpeed&quot;
-		bool receiveTracks;
-	};
-	TerrainType terrainTypes[256];
-
-private:
-
-	void ReadGlobal();
-	void ReadGui();
-	void ReadAtmosphere();
-	void ReadLight();
-	void ReadWater();
-	void ReadSmf();
-	void ReadSm3();
-	void ReadTerrainTypes();
-
-	TdfParser* resources;
-	TdfParser* mapDefParser;
-};
-
-extern const CMapInfo* mapInfo;
-
-#endif // MAPINFO_H
+#ifndef MAPINFO_H
+#define MAPINFO_H
+
+#include &lt;string&gt;
+#include &quot;float3.h&quot;
+
+class TdfParser;
+
+
+class CMapInfo
+{
+public:
+
+	static void OpenTDF(const std::string&amp; mapname, TdfParser&amp; parser);
+	static std::string GetTDFName(const std::string&amp; mapname);
+
+	CMapInfo(const std::string&amp; mapname);
+	~CMapInfo();
+
+	/** @brief Get a readonly reference to the TDF parser.
+	    This is needed by SM3 code to load feature and layer data. */
+	const TdfParser&amp; GetMapDefParser() const { return *mapDefParser; }
+
+	/* The settings are just public members because:
+
+	   1) it's quite some work to encapsulate all of them, and
+	   2) nothing too bad happens if you modify them, there are no complex
+	      pointer members that really beg for encapsulation.
+
+	   Instead of encapsulation it is as effective and much easier make the
+	   global mapInfo const, ie. const CMapInfo* mapInfo;
+	 */
+
+	/* Note: this could (should) have been anonymous structures if only MSVC 8
+	   didn't crap out on it.  Specifically, it craps out on any class with at
+	   least 1 user defined non-inline constructor and at least 2 anonymous
+	   structures, each with at least 1 object with a constructor in it.
+	   In other words, it probably assigns the same name to each anonymous
+	   structure, and later gets confused by that.
+
+	   This sample code triggers the problem in MSVC:
+
+		class A {
+			A::A();
+			struct { std::string s1; } a1;
+			struct { std::string s2; } a2;
+		};
+		A::A() {}
+	 */
+
+	/** Global settings, ie. from &quot;MAP&quot; section. */
+	struct map_t {
+		std::string name;      ///&lt; The filename as passed to the constructor.
+		std::string wantedScript;
+		std::string humanName; ///&lt; &quot;MAP\\Description&quot;
+		float hardness;        ///&lt; &quot;MAP\\MapHardness&quot;
+		bool  notDeformable;
+		/** Stores the gravity as a negative number in units/frame^2
+		    (NOT positive units/second^2 as in the mapfile) */
+		float gravity;
+		float tidalStrength;
+		float maxMetal;
+		float extractorRadius; ///&lt; extraction radius for mines
+		bool  voidWater;
+	} map;
+
+	/** GUI settings (used by CGuiHandler) */
+	struct gui_t {
+		bool autoShowMetal;
+	} gui;
+
+	/** settings read from &quot;MAP\ATMOSPHERE&quot; section */
+	struct atmosphere_t {
+		float  cloudDensity;
+		float  fogStart;
+		float3 fogColor;
+		float3 skyColor;
+		float3 sunColor;
+		float3 cloudColor;
+		float  minWind;
+		float  maxWind;
+		std::string skyBox;
+	} atmosphere;
+
+	/** settings read from &quot;MAP\LIGHT&quot; section */
+	struct light_t {
+		float3 sunDir;     ///&lt; Holds vector for the direction of the sun
+		float  sunDir4[4]; ///&lt; sunDir as 4 component vector
+		float3 groundAmbientColor;
+		float3 groundSunColor;
+		float3 groundSpecularColor;
+		float  groundShadowDensity;
+		float3 unitAmbientColor;
+		float3 unitSunColor;
+		float3 specularSunColor;
+		float  unitShadowDensity;
+	} light;
+
+	/** settings read from &quot;MAP\WATER&quot; section
+	    prefix their name with &quot;Water&quot; to get the TDF variable */
+	struct water_t {
+		float  repeatX; ///&lt; (calculated default is in CBaseWater)
+		float  repeatY; ///&lt; (calculated default is in CBaseWater)
+		float  damage;
+		float3 absorb;
+		float3 baseColor;
+		float3 minColor;
+		float3 surfaceColor;
+		float3 planeColor;
+		std::string texture;
+	} water;
+	bool hasWaterPlane; ///&lt; true if &quot;MAP\WATER\WaterPlaneColor&quot; is set
+
+	/** SMF specific settings */
+	struct smf_t {
+		std::string detailTexName; ///&lt; &quot;MAP\DetailTex&quot;
+	} smf;
+
+	/** SM3 specific settings
+	    This is NOT complete, SM3 stores so much in the map settings
+	    that it really isn't a good idea to put them here. */
+	struct sm3_t {
+		std::string minimap; ///&lt; &quot;MAP\minimap&quot;
+	} sm3;
+
+	/** Terrain type, there can be 256 of these:
+	    &quot;MAP\TerrainType0&quot; up to &quot;MAP\TerrainType255&quot; */
+	struct TerrainType {
+		std::string name;
+		float hardness;
+		float tankSpeed;   ///&lt; &quot;TankMoveSpeed&quot;
+		float kbotSpeed;   ///&lt; &quot;KbotMoveSpeed&quot;
+		float hoverSpeed;  ///&lt; &quot;HoverMoveSpeed&quot;
+		float shipSpeed;   ///&lt; &quot;ShipMoveSpeed&quot;
+		bool receiveTracks;
+	};
+	TerrainType terrainTypes[256];
+
+private:
+
+	void ReadGlobal();
+	void ReadGui();
+	void ReadAtmosphere();
+	void ReadLight();
+	void ReadWater();
+	void ReadSmf();
+	void ReadSm3();
+	void ReadTerrainTypes();
+
+	TdfParser* resources;
+	TdfParser* mapDefParser;
+};
+
+extern const CMapInfo* mapInfo;
+
+#endif // MAPINFO_H


Property changes on: trunk/rts/Map/MapInfo.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Features/Feature.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Features/Feature.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Features/FeatureDef.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Features/FeatureHandler.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Features/FeatureHandler.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Features/FeatureSet.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Features/FeatureSet.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Misc/CollisionHandler.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Misc/CollisionHandler.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Misc/CollisionVolume.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Sim/Misc/GroundBlockingObjectMap.cpp
===================================================================
--- trunk/rts/Sim/Misc/GroundBlockingObjectMap.cpp	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/Sim/Misc/GroundBlockingObjectMap.cpp	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,162 +1,162 @@
-#include &quot;GroundBlockingObjectMap.h&quot;
-
-#include &quot;Sim/Objects/SolidObject.h&quot;
-#include &quot;Sim/Path/PathManager.h&quot;
-
-
-CR_BIND(CGroundBlockingObjectMap, (1))
-CR_REG_METADATA(CGroundBlockingObjectMap, (
-				CR_MEMBER(groundBlockingObjectMap)
-				));
-
-
-CGroundBlockingObjectMap* groundBlockingObjectMap;
-
-
-CGroundBlockingObjectMap::CGroundBlockingObjectMap(int numSquares)
-{
-	groundBlockingObjectMap.resize(numSquares, NULL);
-}
-
-
-void CGroundBlockingObjectMap::AddGroundBlockingObject(CSolidObject *object)
-{
-	object-&gt;isMarkedOnBlockingMap=true;
-	object-&gt;mapPos=object-&gt;GetMapPos();
-	if(object-&gt;immobile){
-		object-&gt;mapPos.x&amp;=0xfffffe;
-		object-&gt;mapPos.y&amp;=0xfffffe;
-	}
-	int bx=object-&gt;mapPos.x;
-	int bz=object-&gt;mapPos.y;
-
-	int minXSqr = bx;
-	int minZSqr = bz;
-	int maxXSqr = bx + object-&gt;xsize;
-	int maxZSqr = bz + object-&gt;ysize;
-
-	for(int zSqr = minZSqr; zSqr &lt; maxZSqr; zSqr++)
-		for(int xSqr = minXSqr; xSqr &lt; maxXSqr; xSqr++)
-			if(!groundBlockingObjectMap[xSqr + zSqr*gs-&gt;mapx])
-				groundBlockingObjectMap[xSqr + zSqr*gs-&gt;mapx] = object;
-
-	// FIXME: needs dependency injection (observer pattern?)
-	if(!object-&gt;mobility &amp;&amp; pathManager)
-		pathManager-&gt;TerrainChange(minXSqr, minZSqr, maxXSqr, maxZSqr);
-}
-
-
-void CGroundBlockingObjectMap::AddGroundBlockingObject(CSolidObject *object, unsigned char *yardMap, unsigned char mask)
-{
-	object-&gt;isMarkedOnBlockingMap=true;
-	object-&gt;mapPos=object-&gt;GetMapPos();
-	if(object-&gt;immobile){
-		object-&gt;mapPos.x&amp;=0xfffffe;
-		object-&gt;mapPos.y&amp;=0xfffffe;
-	}
-	int bx=object-&gt;mapPos.x;
-	int bz=object-&gt;mapPos.y;
-
-	int minXSqr = bx;
-	int minZSqr = bz;
-	int maxXSqr = bx + object-&gt;xsize;
-	int maxZSqr = bz + object-&gt;ysize;
-
-	for(int z = 0; minZSqr + z &lt; maxZSqr; z++) {
-		for(int x = 0; minXSqr + x &lt; maxXSqr; x++) {
-			if(!groundBlockingObjectMap[minXSqr + x + (minZSqr + z)*gs-&gt;mapx]){
-				if(yardMap[x + z*object-&gt;xsize] &amp; mask) {
-					groundBlockingObjectMap[minXSqr + x + (minZSqr + z)*gs-&gt;mapx] = object;
-				}
-			}
-		}
-	}
-
-	// FIXME: needs dependency injection (observer pattern?)
-	if(!object-&gt;mobility &amp;&amp; pathManager)
-		pathManager-&gt;TerrainChange(minXSqr, minZSqr, maxXSqr, maxZSqr);
-}
-
-
-void CGroundBlockingObjectMap::RemoveGroundBlockingObject(CSolidObject *object)
-{
-	object-&gt;isMarkedOnBlockingMap=false;
-	int bx=object-&gt;mapPos.x;
-	int bz=object-&gt;mapPos.y;
-	int sx=object-&gt;xsize;
-	int sz=object-&gt;ysize;
-	for(int z = bz; z &lt; bz+sz; ++z)
-		for(int x = bx; x &lt; bx+sx; ++x)
-			if(groundBlockingObjectMap[x + z*gs-&gt;mapx]==object)
-				groundBlockingObjectMap[x + z*gs-&gt;mapx] = 0;
-
-	// FIXME: needs dependency injection (observer pattern?)
-	if(!object-&gt;mobility)
-		pathManager-&gt;TerrainChange(bx, bz, bx+sx, bz+sz);
-}
-
-
-/**
-Moves a ground blocking object from old position to the current on map.
-*/
-void CGroundBlockingObjectMap::MoveGroundBlockingObject(CSolidObject *object, float3 oldPos) {
-	RemoveGroundBlockingObject(object);
-	AddGroundBlockingObject(object);
-}
-
-
-/**
-Checks if a ground-square is blocked.
-If it's not blocked, then NULL is returned.
-If it's blocked, then a pointer to the blocking object is returned.
-*/
-CSolidObject* CGroundBlockingObjectMap::GroundBlocked(int mapSquare) {
-	if(mapSquare &lt; 0 || mapSquare &gt;= gs-&gt;mapSquares)
-		return NULL;
-	return groundBlockingObjectMap[mapSquare];
-}
-
-
-/**
-Checks if a ground-square is blocked.
-If it's not blocked, then NULL is returned.
-If it's blocked, then a pointer to the blocking object is returned.
-*/
-CSolidObject* CGroundBlockingObjectMap::GroundBlocked(float3 pos) {
-	int xSqr = int(pos.x / SQUARE_SIZE) % gs-&gt;mapx;
-	int zSqr = int(pos.z / SQUARE_SIZE) / gs-&gt;mapx;
-	return GroundBlocked(xSqr + zSqr*gs-&gt;mapx);
-}
-
-
-/**
-Opens up a yard in a blocked area.
-When a factory opens up, for example.
-*/
-void CGroundBlockingObjectMap::OpenBlockingYard(CSolidObject *yard, unsigned char *blockingMap) {
-	RemoveGroundBlockingObject(yard);
-	AddGroundBlockingObject(yard, blockingMap, 2);
-}
-
-
-/**
-Closes a yard, blocking the area.
-When a factory closes, for example.
-*/
-void CGroundBlockingObjectMap::CloseBlockingYard(CSolidObject *yard, unsigned char *blockingMap) {
-	RemoveGroundBlockingObject(yard);
-	AddGroundBlockingObject(yard, blockingMap, 1);
-}
-
-
-bool CGroundBlockingObjectMap::CanCloseYard(CSolidObject* yard)
-{
-	for(int z = yard-&gt;mapPos.y; z &lt; yard-&gt;mapPos.y + yard-&gt;ysize; ++z) {
-		for(int x = yard-&gt;mapPos.x; x &lt; yard-&gt;mapPos.x + yard-&gt;xsize; ++x) {
-			CSolidObject* c = groundBlockingObjectMap[z * gs-&gt;mapx + x];
-			if (c != NULL &amp;&amp; c != yard)
-				return false;
-		}
-	}
-	return true;
-}
+#include &quot;GroundBlockingObjectMap.h&quot;
+
+#include &quot;Sim/Objects/SolidObject.h&quot;
+#include &quot;Sim/Path/PathManager.h&quot;
+
+
+CR_BIND(CGroundBlockingObjectMap, (1))
+CR_REG_METADATA(CGroundBlockingObjectMap, (
+				CR_MEMBER(groundBlockingObjectMap)
+				));
+
+
+CGroundBlockingObjectMap* groundBlockingObjectMap;
+
+
+CGroundBlockingObjectMap::CGroundBlockingObjectMap(int numSquares)
+{
+	groundBlockingObjectMap.resize(numSquares, NULL);
+}
+
+
+void CGroundBlockingObjectMap::AddGroundBlockingObject(CSolidObject *object)
+{
+	object-&gt;isMarkedOnBlockingMap=true;
+	object-&gt;mapPos=object-&gt;GetMapPos();
+	if(object-&gt;immobile){
+		object-&gt;mapPos.x&amp;=0xfffffe;
+		object-&gt;mapPos.y&amp;=0xfffffe;
+	}
+	int bx=object-&gt;mapPos.x;
+	int bz=object-&gt;mapPos.y;
+
+	int minXSqr = bx;
+	int minZSqr = bz;
+	int maxXSqr = bx + object-&gt;xsize;
+	int maxZSqr = bz + object-&gt;ysize;
+
+	for(int zSqr = minZSqr; zSqr &lt; maxZSqr; zSqr++)
+		for(int xSqr = minXSqr; xSqr &lt; maxXSqr; xSqr++)
+			if(!groundBlockingObjectMap[xSqr + zSqr*gs-&gt;mapx])
+				groundBlockingObjectMap[xSqr + zSqr*gs-&gt;mapx] = object;
+
+	// FIXME: needs dependency injection (observer pattern?)
+	if(!object-&gt;mobility &amp;&amp; pathManager)
+		pathManager-&gt;TerrainChange(minXSqr, minZSqr, maxXSqr, maxZSqr);
+}
+
+
+void CGroundBlockingObjectMap::AddGroundBlockingObject(CSolidObject *object, unsigned char *yardMap, unsigned char mask)
+{
+	object-&gt;isMarkedOnBlockingMap=true;
+	object-&gt;mapPos=object-&gt;GetMapPos();
+	if(object-&gt;immobile){
+		object-&gt;mapPos.x&amp;=0xfffffe;
+		object-&gt;mapPos.y&amp;=0xfffffe;
+	}
+	int bx=object-&gt;mapPos.x;
+	int bz=object-&gt;mapPos.y;
+
+	int minXSqr = bx;
+	int minZSqr = bz;
+	int maxXSqr = bx + object-&gt;xsize;
+	int maxZSqr = bz + object-&gt;ysize;
+
+	for(int z = 0; minZSqr + z &lt; maxZSqr; z++) {
+		for(int x = 0; minXSqr + x &lt; maxXSqr; x++) {
+			if(!groundBlockingObjectMap[minXSqr + x + (minZSqr + z)*gs-&gt;mapx]){
+				if(yardMap[x + z*object-&gt;xsize] &amp; mask) {
+					groundBlockingObjectMap[minXSqr + x + (minZSqr + z)*gs-&gt;mapx] = object;
+				}
+			}
+		}
+	}
+
+	// FIXME: needs dependency injection (observer pattern?)
+	if(!object-&gt;mobility &amp;&amp; pathManager)
+		pathManager-&gt;TerrainChange(minXSqr, minZSqr, maxXSqr, maxZSqr);
+}
+
+
+void CGroundBlockingObjectMap::RemoveGroundBlockingObject(CSolidObject *object)
+{
+	object-&gt;isMarkedOnBlockingMap=false;
+	int bx=object-&gt;mapPos.x;
+	int bz=object-&gt;mapPos.y;
+	int sx=object-&gt;xsize;
+	int sz=object-&gt;ysize;
+	for(int z = bz; z &lt; bz+sz; ++z)
+		for(int x = bx; x &lt; bx+sx; ++x)
+			if(groundBlockingObjectMap[x + z*gs-&gt;mapx]==object)
+				groundBlockingObjectMap[x + z*gs-&gt;mapx] = 0;
+
+	// FIXME: needs dependency injection (observer pattern?)
+	if(!object-&gt;mobility)
+		pathManager-&gt;TerrainChange(bx, bz, bx+sx, bz+sz);
+}
+
+
+/**
+Moves a ground blocking object from old position to the current on map.
+*/
+void CGroundBlockingObjectMap::MoveGroundBlockingObject(CSolidObject *object, float3 oldPos) {
+	RemoveGroundBlockingObject(object);
+	AddGroundBlockingObject(object);
+}
+
+
+/**
+Checks if a ground-square is blocked.
+If it's not blocked, then NULL is returned.
+If it's blocked, then a pointer to the blocking object is returned.
+*/
+CSolidObject* CGroundBlockingObjectMap::GroundBlocked(int mapSquare) {
+	if(mapSquare &lt; 0 || mapSquare &gt;= gs-&gt;mapSquares)
+		return NULL;
+	return groundBlockingObjectMap[mapSquare];
+}
+
+
+/**
+Checks if a ground-square is blocked.
+If it's not blocked, then NULL is returned.
+If it's blocked, then a pointer to the blocking object is returned.
+*/
+CSolidObject* CGroundBlockingObjectMap::GroundBlocked(float3 pos) {
+	int xSqr = int(pos.x / SQUARE_SIZE) % gs-&gt;mapx;
+	int zSqr = int(pos.z / SQUARE_SIZE) / gs-&gt;mapx;
+	return GroundBlocked(xSqr + zSqr*gs-&gt;mapx);
+}
+
+
+/**
+Opens up a yard in a blocked area.
+When a factory opens up, for example.
+*/
+void CGroundBlockingObjectMap::OpenBlockingYard(CSolidObject *yard, unsigned char *blockingMap) {
+	RemoveGroundBlockingObject(yard);
+	AddGroundBlockingObject(yard, blockingMap, 2);
+}
+
+
+/**
+Closes a yard, blocking the area.
+When a factory closes, for example.
+*/
+void CGroundBlockingObjectMap::CloseBlockingYard(CSolidObject *yard, unsigned char *blockingMap) {
+	RemoveGroundBlockingObject(yard);
+	AddGroundBlockingObject(yard, blockingMap, 1);
+}
+
+
+bool CGroundBlockingObjectMap::CanCloseYard(CSolidObject* yard)
+{
+	for(int z = yard-&gt;mapPos.y; z &lt; yard-&gt;mapPos.y + yard-&gt;ysize; ++z) {
+		for(int x = yard-&gt;mapPos.x; x &lt; yard-&gt;mapPos.x + yard-&gt;xsize; ++x) {
+			CSolidObject* c = groundBlockingObjectMap[z * gs-&gt;mapx + x];
+			if (c != NULL &amp;&amp; c != yard)
+				return false;
+		}
+	}
+	return true;
+}


Property changes on: trunk/rts/Sim/Misc/GroundBlockingObjectMap.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Sim/Misc/GroundBlockingObjectMap.h
===================================================================
--- trunk/rts/Sim/Misc/GroundBlockingObjectMap.h	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/Sim/Misc/GroundBlockingObjectMap.h	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,33 +1,33 @@
-#ifndef GROUNDBLOCKINGOBJECTMAP_H
-#define GROUNDBLOCKINGOBJECTMAP_H
-
-#include &quot;creg/creg.h&quot;
-#include &quot;float3.h&quot;
-
-class CSolidObject;
-
-class CGroundBlockingObjectMap
-{
-	CR_DECLARE(CGroundBlockingObjectMap);
-
-public:
-	CGroundBlockingObjectMap(int numSquares);
-	void AddGroundBlockingObject(CSolidObject *object);
-	void AddGroundBlockingObject(CSolidObject *object, unsigned char *blockingMap, unsigned char mask = 255);
-	void RemoveGroundBlockingObject(CSolidObject *object);
-	void MoveGroundBlockingObject(CSolidObject *object, float3 oldPos);
-	void OpenBlockingYard(CSolidObject *yard, unsigned char *blockingMap);
-	void CloseBlockingYard(CSolidObject *yard, unsigned char *blockingMap);
-	bool CanCloseYard(CSolidObject* object);
-	CSolidObject* GroundBlocked(float3 pos);
-	CSolidObject* GroundBlocked(int mapSquare);
-	///simple version of GroundBlocked without error checking
-	CSolidObject* GroundBlockedUnsafe(int mapSquare){return groundBlockingObjectMap[mapSquare];}
-
-private:
-	std::vector&lt;CSolidObject*&gt; groundBlockingObjectMap;
-};
-
-extern CGroundBlockingObjectMap* groundBlockingObjectMap;
-
-#endif
+#ifndef GROUNDBLOCKINGOBJECTMAP_H
+#define GROUNDBLOCKINGOBJECTMAP_H
+
+#include &quot;creg/creg.h&quot;
+#include &quot;float3.h&quot;
+
+class CSolidObject;
+
+class CGroundBlockingObjectMap
+{
+	CR_DECLARE(CGroundBlockingObjectMap);
+
+public:
+	CGroundBlockingObjectMap(int numSquares);
+	void AddGroundBlockingObject(CSolidObject *object);
+	void AddGroundBlockingObject(CSolidObject *object, unsigned char *blockingMap, unsigned char mask = 255);
+	void RemoveGroundBlockingObject(CSolidObject *object);
+	void MoveGroundBlockingObject(CSolidObject *object, float3 oldPos);
+	void OpenBlockingYard(CSolidObject *yard, unsigned char *blockingMap);
+	void CloseBlockingYard(CSolidObject *yard, unsigned char *blockingMap);
+	bool CanCloseYard(CSolidObject* object);
+	CSolidObject* GroundBlocked(float3 pos);
+	CSolidObject* GroundBlocked(int mapSquare);
+	///simple version of GroundBlocked without error checking
+	CSolidObject* GroundBlockedUnsafe(int mapSquare){return groundBlockingObjectMap[mapSquare];}
+
+private:
+	std::vector&lt;CSolidObject*&gt; groundBlockingObjectMap;
+};
+
+extern CGroundBlockingObjectMap* groundBlockingObjectMap;
+
+#endif


Property changes on: trunk/rts/Sim/Misc/GroundBlockingObjectMap.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Sim/MoveTypes/AAirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/AAirMoveType.cpp	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/Sim/MoveTypes/AAirMoveType.cpp	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,59 +1,59 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;AAirMoveType.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
-
-
-CR_BIND_DERIVED_INTERFACE(AAirMoveType, AMoveType);
-
-CR_REG_METADATA(AAirMoveType, (
-		CR_MEMBER(oldGoalPos),
-		CR_MEMBER(oldpos),
-		CR_MEMBER(reservedLandingPos),
-		CR_MEMBER(wantedHeight),
-		
-		CR_MEMBER(lastColWarning),
-		CR_MEMBER(lastColWarningType),
-		CR_MEMBER(collide),
-		
-		CR_MEMBER(autoLand),
-		
-		CR_RESERVED(16)
-		));
-
-AAirMoveType::AAirMoveType(CUnit* unit) :
-	AMoveType(unit),
-	aircraftState(AIRCRAFT_LANDED),
-	autoLand(true),
-	collide(true),
-	lastColWarning(0),
-	lastColWarningType(0),
-	oldpos(0,0,0),
-	oldGoalPos(owner? owner-&gt;pos:float3(0, 0, 0)),
-	reservedLandingPos(-1,-1,-1),
-	wantedHeight(80)
-{
-	useHeading = false;
-}
-
-AAirMoveType::~AAirMoveType()
-{
-	if (reservedPad) {
-		airBaseHandler-&gt;LeaveLandingPad(reservedPad);
-		reservedPad = 0;
-	}
-}
-
-void AAirMoveType::ReservePad(CAirBaseHandler::LandingPad* lp) {
-	oldGoalPos = goalPos;
-	AMoveType::ReservePad(lp);
-	Takeoff();
-}
-
-void AAirMoveType::DependentDied(CObject* o)
-{
-	AMoveType::DependentDied(o);
-	if(o == reservedPad){
-		SetState(AIRCRAFT_FLYING);
-		goalPos=oldGoalPos;
-	}
-}
+#include &quot;StdAfx.h&quot;
+#include &quot;AAirMoveType.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+
+
+CR_BIND_DERIVED_INTERFACE(AAirMoveType, AMoveType);
+
+CR_REG_METADATA(AAirMoveType, (
+		CR_MEMBER(oldGoalPos),
+		CR_MEMBER(oldpos),
+		CR_MEMBER(reservedLandingPos),
+		CR_MEMBER(wantedHeight),
+		
+		CR_MEMBER(lastColWarning),
+		CR_MEMBER(lastColWarningType),
+		CR_MEMBER(collide),
+		
+		CR_MEMBER(autoLand),
+		
+		CR_RESERVED(16)
+		));
+
+AAirMoveType::AAirMoveType(CUnit* unit) :
+	AMoveType(unit),
+	aircraftState(AIRCRAFT_LANDED),
+	autoLand(true),
+	collide(true),
+	lastColWarning(0),
+	lastColWarningType(0),
+	oldpos(0,0,0),
+	oldGoalPos(owner? owner-&gt;pos:float3(0, 0, 0)),
+	reservedLandingPos(-1,-1,-1),
+	wantedHeight(80)
+{
+	useHeading = false;
+}
+
+AAirMoveType::~AAirMoveType()
+{
+	if (reservedPad) {
+		airBaseHandler-&gt;LeaveLandingPad(reservedPad);
+		reservedPad = 0;
+	}
+}
+
+void AAirMoveType::ReservePad(CAirBaseHandler::LandingPad* lp) {
+	oldGoalPos = goalPos;
+	AMoveType::ReservePad(lp);
+	Takeoff();
+}
+
+void AAirMoveType::DependentDied(CObject* o)
+{
+	AMoveType::DependentDied(o);
+	if(o == reservedPad){
+		SetState(AIRCRAFT_FLYING);
+		goalPos=oldGoalPos;
+	}
+}


Property changes on: trunk/rts/Sim/MoveTypes/AAirMoveType.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/Sim/MoveTypes/AAirMoveType.h
===================================================================
--- trunk/rts/Sim/MoveTypes/AAirMoveType.h	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/Sim/MoveTypes/AAirMoveType.h	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,47 +1,47 @@
-#ifndef AAIRMOVETYPE_H_
-#define AAIRMOVETYPE_H_
-
-#include &quot;MoveType.h&quot;
-#include &quot;Sim/Misc/AirBaseHandler.h&quot;
-
-// Supposed to be an abstract class. Do not create an instance of this class.
-// Use either CTAAirMoveType or CAirMoveType instead.
-class AAirMoveType : public AMoveType
-{
-	CR_DECLARE(AAirMoveType);
-public:
-	
-	enum AircraftState{
-		AIRCRAFT_LANDED,
-		AIRCRAFT_FLYING,
-		AIRCRAFT_LANDING,
-		AIRCRAFT_CRASHING,
-		AIRCRAFT_TAKEOFF,
-		AIRCRAFT_HOVERING       // this is what happens to aircraft with dontLand=1 in fbi
-	} aircraftState;
-	
-	AAirMoveType(CUnit* unit);
-	~AAirMoveType();
-	
-	float3 oldGoalPos;				//goalpos to resume flying to after landing
-	float3 oldpos;
-	float3 reservedLandingPos;
-	
-	float wantedHeight;
-	
-	bool collide;             //mods can use this to disable plane collisions
-	CUnit* lastColWarning;		//unit found to be dangerously close to our path
-	int lastColWarningType;		//1=generally forward of us,2=directly in path
-	
-	bool autoLand;
-
-	virtual bool IsFighter() = 0;
-	virtual void Takeoff() = 0;
-	void ReservePad(CAirBaseHandler::LandingPad* lp);
-	void DependentDied(CObject* o);
-	
-protected:
-	virtual void SetState(AircraftState state) = 0;
-};
-
-#endif /*AAIRMOVETYPE_H_*/
+#ifndef AAIRMOVETYPE_H_
+#define AAIRMOVETYPE_H_
+
+#include &quot;MoveType.h&quot;
+#include &quot;Sim/Misc/AirBaseHandler.h&quot;
+
+// Supposed to be an abstract class. Do not create an instance of this class.
+// Use either CTAAirMoveType or CAirMoveType instead.
+class AAirMoveType : public AMoveType
+{
+	CR_DECLARE(AAirMoveType);
+public:
+	
+	enum AircraftState{
+		AIRCRAFT_LANDED,
+		AIRCRAFT_FLYING,
+		AIRCRAFT_LANDING,
+		AIRCRAFT_CRASHING,
+		AIRCRAFT_TAKEOFF,
+		AIRCRAFT_HOVERING       // this is what happens to aircraft with dontLand=1 in fbi
+	} aircraftState;
+	
+	AAirMoveType(CUnit* unit);
+	~AAirMoveType();
+	
+	float3 oldGoalPos;				//goalpos to resume flying to after landing
+	float3 oldpos;
+	float3 reservedLandingPos;
+	
+	float wantedHeight;
+	
+	bool collide;             //mods can use this to disable plane collisions
+	CUnit* lastColWarning;		//unit found to be dangerously close to our path
+	int lastColWarningType;		//1=generally forward of us,2=directly in path
+	
+	bool autoLand;
+
+	virtual bool IsFighter() = 0;
+	virtual void Takeoff() = 0;
+	void ReservePad(CAirBaseHandler::LandingPad* lp);
+	void DependentDied(CObject* o);
+	
+protected:
+	virtual void SetState(AircraftState state) = 0;
+};
+
+#endif /*AAIRMOVETYPE_H_*/


Property changes on: trunk/rts/Sim/MoveTypes/AAirMoveType.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/Sim/Units/UnitImage.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/System/FastMath.h
===================================================================
--- trunk/rts/System/FastMath.h	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/System/FastMath.h	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,177 +1,177 @@
-#ifndef FASTMATH_H
-#define FASTMATH_H
-
-#include &quot;StdAfx.h&quot;
-
-/**
- * @file FastMath.cpp
- * @brief Fast math routines
- *
- * Contains faster alternatives for the more time
- * consuming standard math routines. These functions
- * are not as accurate, however, but are generally
- * acceptable for most applications.
- *
- */
-
-namespace fastmath {
-	/****************** Square root functions ******************/
-
-	/**
-	* @brief Calculates 1/sqrt(x) with less accuracy
-	*
-	* Gets a very good first guess and then uses one
-	* iteration of newton's method for improved accuracy.
-	* Average relative error: 0.093%
-	* Highest relative error: 0.175%
-	*
-	* see &quot;The Math Behind The Fast Inverse Square Root Function Code&quot;
-	* by Charles McEniry [2007] for a mathematical derivation of this
-	* method (or Chris Lomont's 2003 &quot;Fast Inverse Square Root&quot; paper)
-	*
-	*/
-	inline float isqrt(float x) {
-		float xh = 0.5f * x;
-		int i = *(int*) &x;
-		// &quot;magic number&quot; which makes a very good first guess
-		i = 0x5f375a86 - (i &gt;&gt; 1);
-		x = *(float*) &i;
-		// Newton's method. One iteration for less accuracy but more speed.
-		x = x * (1.5f - xh * (x * x));
-		return x;
-	}
-
-	/**
-	* @brief Calculates 1/sqrt(x) with more accuracy
-	*
-	* Gets a very good first guess and then uses two
-	* iterations of newton's method for improved accuracy.
-	* Average relative error: 0.00017%
-	* Highest relative error: 0.00047%
-	*
-	*/
-	inline float isqrt2(float x) {
-		float xh = 0.5f * x;
-		int i = *(int*) &x;
-		// &quot;magic number&quot; which makes a very good first guess
-		i = 0x5f375a86 - (i &gt;&gt; 1);
-		x = *(float*) &i;
-		// Newton's method. Two iterations for more accuracy but less speed.
-		x = x * (1.5f - xh * (x * x));
-		x = x * (1.5f - xh * (x * x));
-		return x;
-	
-	}
-
-	/**
-	* @brief Calculates square root with less accuracy
-	*
-	* These square root functions use the inverse square
-	* root routines to obtain the answer. This one uses
-	* the less accurate, but faster isqrt().
-	*
-	*/
-	inline float sqrt(float x) {
-		return (isqrt(x) * x);
-	}
-
-	/**
-	* @brief Calculates square root with more accuracy
-	*
-	* These square root functions use the inverse square
-	* root routines to obtain the answer. This one uses
-	* the more accurate, but slower isqrt2().
-	*
-	*/
-	inline float sqrt2(float x) {
-		return (isqrt2(x) * x);
-	}
-
-
-	/****************** Trigonometric functions ******************/
-
-	/**
-	* @brief Pi
-	*
-	* Cherry flavored.
-	*/
-	static const float PI = 3.141592654f;
-
-	/**
-	* @brief Half of pi
-	*
-	* Pi divided by two
-	*/
-	static const float HALFPI = PI / 2.0f;
-
-	/**
-	* @brief Pi times two
-	*
-	* Pi times two
-	*/
-	static const float PI2 = PI * 2.0f;
-
-	/**
-	* @brief Four divided by pi
-	*
-	* Four over pi
-	*/
-	static const float PIU4 = 4.0 / PI;
-
-	/**
-	* @brief Negative four divided by pi squared
-	*
-	* Negative four over (pi squared)
-	*/
-	static const float PISUN4 = -4.0 / (PI * PI);
-
-	/**
-	* @brief reciprocal of pi
-	*
-	* One over (pi times two)
-	*/
-	static const float INVPI2 = 1.0f / PI2;
-
-	/**
-	* @brief negative half pi
-	*
-	* -pi / 2
-	*/
-	static const float NEGHALFPI = -HALFPI;
-
-	/**
-	* @brief calculates the sine of x
-	*
-	* Range reduces x to -PI ... PI, and then uses the
-	* sine approximation method as described at
-	* <A HREF="http://www.devmaster.net/forums/showthread.php?t=5784">http://www.devmaster.net/forums/showthread.php?t=5784</A>
-	*
-	* Average percentage error: 0.15281632393574715%
-	* Highest percentage error: 0.17455324009559584%
-	*/
-	inline float sin(float x) {
-		/* range reduce to -PI ... PI, as the approximation
-		method only works well for that range. */
-		x = x - ((int)(x * INVPI2)) * PI2;
-		if (x &gt; HALFPI) {
-			x = -x + PI;
-		} else if (x &lt; NEGHALFPI ) {
-			x = -x - PI;
-		}
-		/* approximation */
-		x = (PIU4) * x + (PISUN4) * x * fabsf(x);
-		x = 0.225 * (x * fabsf(x) - x) + x;
-		return x;
-	}
-
-	/**
-	* @brief calculates the cosine of x
-	*
-	* Adds half of pi to x and then uses the sine method.
-	*/
-	inline float cos(float x) {
-		return sin(x + HALFPI);
-	}
-}
-
-#endif
+#ifndef FASTMATH_H
+#define FASTMATH_H
+
+#include &quot;StdAfx.h&quot;
+
+/**
+ * @file FastMath.cpp
+ * @brief Fast math routines
+ *
+ * Contains faster alternatives for the more time
+ * consuming standard math routines. These functions
+ * are not as accurate, however, but are generally
+ * acceptable for most applications.
+ *
+ */
+
+namespace fastmath {
+	/****************** Square root functions ******************/
+
+	/**
+	* @brief Calculates 1/sqrt(x) with less accuracy
+	*
+	* Gets a very good first guess and then uses one
+	* iteration of newton's method for improved accuracy.
+	* Average relative error: 0.093%
+	* Highest relative error: 0.175%
+	*
+	* see &quot;The Math Behind The Fast Inverse Square Root Function Code&quot;
+	* by Charles McEniry [2007] for a mathematical derivation of this
+	* method (or Chris Lomont's 2003 &quot;Fast Inverse Square Root&quot; paper)
+	*
+	*/
+	inline float isqrt(float x) {
+		float xh = 0.5f * x;
+		int i = *(int*) &x;
+		// &quot;magic number&quot; which makes a very good first guess
+		i = 0x5f375a86 - (i &gt;&gt; 1);
+		x = *(float*) &i;
+		// Newton's method. One iteration for less accuracy but more speed.
+		x = x * (1.5f - xh * (x * x));
+		return x;
+	}
+
+	/**
+	* @brief Calculates 1/sqrt(x) with more accuracy
+	*
+	* Gets a very good first guess and then uses two
+	* iterations of newton's method for improved accuracy.
+	* Average relative error: 0.00017%
+	* Highest relative error: 0.00047%
+	*
+	*/
+	inline float isqrt2(float x) {
+		float xh = 0.5f * x;
+		int i = *(int*) &x;
+		// &quot;magic number&quot; which makes a very good first guess
+		i = 0x5f375a86 - (i &gt;&gt; 1);
+		x = *(float*) &i;
+		// Newton's method. Two iterations for more accuracy but less speed.
+		x = x * (1.5f - xh * (x * x));
+		x = x * (1.5f - xh * (x * x));
+		return x;
+	
+	}
+
+	/**
+	* @brief Calculates square root with less accuracy
+	*
+	* These square root functions use the inverse square
+	* root routines to obtain the answer. This one uses
+	* the less accurate, but faster isqrt().
+	*
+	*/
+	inline float sqrt(float x) {
+		return (isqrt(x) * x);
+	}
+
+	/**
+	* @brief Calculates square root with more accuracy
+	*
+	* These square root functions use the inverse square
+	* root routines to obtain the answer. This one uses
+	* the more accurate, but slower isqrt2().
+	*
+	*/
+	inline float sqrt2(float x) {
+		return (isqrt2(x) * x);
+	}
+
+
+	/****************** Trigonometric functions ******************/
+
+	/**
+	* @brief Pi
+	*
+	* Cherry flavored.
+	*/
+	static const float PI = 3.141592654f;
+
+	/**
+	* @brief Half of pi
+	*
+	* Pi divided by two
+	*/
+	static const float HALFPI = PI / 2.0f;
+
+	/**
+	* @brief Pi times two
+	*
+	* Pi times two
+	*/
+	static const float PI2 = PI * 2.0f;
+
+	/**
+	* @brief Four divided by pi
+	*
+	* Four over pi
+	*/
+	static const float PIU4 = 4.0 / PI;
+
+	/**
+	* @brief Negative four divided by pi squared
+	*
+	* Negative four over (pi squared)
+	*/
+	static const float PISUN4 = -4.0 / (PI * PI);
+
+	/**
+	* @brief reciprocal of pi
+	*
+	* One over (pi times two)
+	*/
+	static const float INVPI2 = 1.0f / PI2;
+
+	/**
+	* @brief negative half pi
+	*
+	* -pi / 2
+	*/
+	static const float NEGHALFPI = -HALFPI;
+
+	/**
+	* @brief calculates the sine of x
+	*
+	* Range reduces x to -PI ... PI, and then uses the
+	* sine approximation method as described at
+	* <A HREF="http://www.devmaster.net/forums/showthread.php?t=5784">http://www.devmaster.net/forums/showthread.php?t=5784</A>
+	*
+	* Average percentage error: 0.15281632393574715%
+	* Highest percentage error: 0.17455324009559584%
+	*/
+	inline float sin(float x) {
+		/* range reduce to -PI ... PI, as the approximation
+		method only works well for that range. */
+		x = x - ((int)(x * INVPI2)) * PI2;
+		if (x &gt; HALFPI) {
+			x = -x + PI;
+		} else if (x &lt; NEGHALFPI ) {
+			x = -x - PI;
+		}
+		/* approximation */
+		x = (PIU4) * x + (PISUN4) * x * fabsf(x);
+		x = 0.225 * (x * fabsf(x) - x) + x;
+		return x;
+	}
+
+	/**
+	* @brief calculates the cosine of x
+	*
+	* Adds half of pi to x and then uses the sine method.
+	*/
+	inline float cos(float x) {
+		return sin(x + HALFPI);
+	}
+}
+
+#endif


Property changes on: trunk/rts/System/FastMath.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/System/FileSystem/FileFilter.cpp
===================================================================
--- trunk/rts/System/FileSystem/FileFilter.cpp	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/System/FileSystem/FileFilter.cpp	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,173 +1,173 @@
-#include &quot;FileFilter.h&quot;
-
-#include &lt;boost/regex.hpp&gt;
-#include &lt;ctype.h&gt;
-#include &lt;sstream&gt;
-#include &lt;vector&gt;
-
-
-using std::string;
-using std::vector;
-
-
-class CFileFilter : public IFileFilter
-{
-public:
-	void AddRule(const string&amp; rule);
-	bool Match(const string&amp; filename) const;
-
-private:
-	string glob_to_regex(const string&amp; glob);
-
-	struct Rule {
-		Rule() : negate(false) {}
-		string glob;
-		boost::regex regex;
-		bool negate;
-	};
-
-	vector&lt;Rule&gt; rules;
-};
-
-
-IFileFilter* IFileFilter::Create()
-{
-	return new CFileFilter();
-}
-
-
-/** @brief Add a filtering rule.
-
-A rule can be:
- - An empty line, this is ignored,
- - A line starting with a '#', this serves as a comment and is ignored,
- - A path starting with a path separator ('/' or '\'): this is an absolute
-   path and matches only against the entire leading part of the filename
-   passed to Match(): '/foo' matches 'foo' and 'foo/bar', but not 'bar/foo'.
- - Any other path is a relative path and is matched less strict: as long as
-   there is a consecutive set of path elements matching the rule, there is a
-   match: 'b/c/d' matches 'b/c/d', but also 'a/b/c/d/e'.
-
-Note that:
- - Leading and trailing whitespace is ignored.
- - Globbing characters '*' and '?' can be used, both do NOT match path
-   separators (like in shell, but unlike fnmatch(), or so I've been told.)
-   e.g. 'foo\*\baz' matches 'foo/bar/baz' but not 'foo/ba/r/baz'.
- - Any path separator matches any other path separator, so there is no need to
-   worry about converting them: 'foo/bar' matches 'foo\bar' and 'foo:bar' too.
- - A path can be prefixed with an exclamation mark '!', this negates the
-   pattern. Because the rules are matched in-order, one can use this to exclude
-   a file from a more generic pattern.
- - By default, no file matches. This can be changed using AddRule(&quot;*&quot;) ofc.
-*/
-void CFileFilter::AddRule(const string&amp; rule)
-{
-	if (rule.empty())
-		return;
-
-	// Split lines if line endings are present.
-	if (rule.find('\n') != string::npos) {
-		int beg = 0, end = 0;
-		while ((end = rule.find('\n', beg)) != string::npos) {
-			//printf(&quot;line: %s\n&quot;, rule.substr(beg, end - beg).c_str());
-			AddRule(rule.substr(beg, end - beg));
-			beg = end + 1;
-		}
-		AddRule(rule.substr(beg));
-		return;
-	}
-
-	// Eat leading whitespace, return if we reach end of string.
-	int p = 0;
-	while (isspace(rule[p]))
-		if (++p &gt;= rule.length())
-			return;
-
-	// Nothing to do if the rule is a comment.
-	if (rule[p] == '#')
-		return;
-
-	// Eat trailing whitespace, return if we meet p.
-	int q = rule.length() - 1;
-	while (isspace(rule[q]))
-		if (--q &lt; p)
-			return;
-
-	// Build the rule.
-	Rule r;
-	if (rule[p] == '!') {
-		r.negate = true;
-		if (++p &gt; q)
-			return;
-	}
-	r.glob = rule.substr(p, 1 + q - p);
-	r.regex = boost::regex(glob_to_regex(r.glob)
-		, boost::regex::icase | boost::regex::no_escape_in_lists);
-	rules.push_back(r);
-	//printf(&quot;added %s%s: %s\n&quot;, r.negate ? &quot;!&quot; : &quot;&quot;, r.glob.c_str(), r.regex.expression());
-}
-
-
-/** @brief Checks whether filename matches this filter. */
-bool CFileFilter::Match(const string&amp; filename) const
-{
-	bool match = false;
-	for (vector&lt;Rule&gt;::const_iterator it = rules.begin(); it != rules.end(); ++it) {
-		if (boost::regex_search(filename, it-&gt;regex))
-			match = !it-&gt;negate;
-	}
-	return match;
-}
-
-
-string CFileFilter::glob_to_regex(const string&amp; glob)
-{
-#define PATH_SEPARATORS &quot;/\\:&quot;
-
-	std::stringstream regex;
-	string::const_iterator i = glob.begin();
-
-	// If the path starts with a path separator, we take it as an absolute path
-	// (relative to whatever is passed to Match() later on), so we insert the
-	// begin anchor.
-
-	// Otherwise we 'just' need to make sure the glob matches only full path
-	// elements, so we require either start of line OR path separator.
-
-	if (i != glob.end() &amp;&amp; *i == '/' || *i == '\\') {
-		regex &lt;&lt; '^';
-		++i;
-	}
-	else
-		regex &lt;&lt; &quot;(^|[&quot; PATH_SEPARATORS &quot;])&quot;;
-
-	for (; i != glob.end(); ++i) {
-		char c = *i;
-		switch (c) {
-			case '*':
-				// In (shell) globbing the wildcards match anything except path separators.
-				regex &lt;&lt; &quot;[^&quot; PATH_SEPARATORS &quot;]*&quot;;
-				break;
-			case '?':
-				regex &lt;&lt; &quot;[^&quot; PATH_SEPARATORS &quot;]&quot;;
-				break;
-			case '/':
-			case '\\':
-			case ':':
-				// Any path separator matches any other path separator.
-				// (So we don't have to manually convert slashes before search.)
-				regex &lt;&lt; &quot;[&quot; PATH_SEPARATORS &quot;]&quot;;
-				break;
-			default:
-				if (!(isalnum(c) || c == '_'))
-					regex &lt;&lt; '\\';
-				regex &lt;&lt; c;
-				break;
-		}
-	}
-
-	// Make sure we only match full path elements. (see above)
-	regex &lt;&lt; &quot;([&quot; PATH_SEPARATORS &quot;]|$)&quot;;
-
-	return regex.str();
-}
+#include &quot;FileFilter.h&quot;
+
+#include &lt;boost/regex.hpp&gt;
+#include &lt;ctype.h&gt;
+#include &lt;sstream&gt;
+#include &lt;vector&gt;
+
+
+using std::string;
+using std::vector;
+
+
+class CFileFilter : public IFileFilter
+{
+public:
+	void AddRule(const string&amp; rule);
+	bool Match(const string&amp; filename) const;
+
+private:
+	string glob_to_regex(const string&amp; glob);
+
+	struct Rule {
+		Rule() : negate(false) {}
+		string glob;
+		boost::regex regex;
+		bool negate;
+	};
+
+	vector&lt;Rule&gt; rules;
+};
+
+
+IFileFilter* IFileFilter::Create()
+{
+	return new CFileFilter();
+}
+
+
+/** @brief Add a filtering rule.
+
+A rule can be:
+ - An empty line, this is ignored,
+ - A line starting with a '#', this serves as a comment and is ignored,
+ - A path starting with a path separator ('/' or '\'): this is an absolute
+   path and matches only against the entire leading part of the filename
+   passed to Match(): '/foo' matches 'foo' and 'foo/bar', but not 'bar/foo'.
+ - Any other path is a relative path and is matched less strict: as long as
+   there is a consecutive set of path elements matching the rule, there is a
+   match: 'b/c/d' matches 'b/c/d', but also 'a/b/c/d/e'.
+
+Note that:
+ - Leading and trailing whitespace is ignored.
+ - Globbing characters '*' and '?' can be used, both do NOT match path
+   separators (like in shell, but unlike fnmatch(), or so I've been told.)
+   e.g. 'foo\*\baz' matches 'foo/bar/baz' but not 'foo/ba/r/baz'.
+ - Any path separator matches any other path separator, so there is no need to
+   worry about converting them: 'foo/bar' matches 'foo\bar' and 'foo:bar' too.
+ - A path can be prefixed with an exclamation mark '!', this negates the
+   pattern. Because the rules are matched in-order, one can use this to exclude
+   a file from a more generic pattern.
+ - By default, no file matches. This can be changed using AddRule(&quot;*&quot;) ofc.
+*/
+void CFileFilter::AddRule(const string&amp; rule)
+{
+	if (rule.empty())
+		return;
+
+	// Split lines if line endings are present.
+	if (rule.find('\n') != string::npos) {
+		int beg = 0, end = 0;
+		while ((end = rule.find('\n', beg)) != string::npos) {
+			//printf(&quot;line: %s\n&quot;, rule.substr(beg, end - beg).c_str());
+			AddRule(rule.substr(beg, end - beg));
+			beg = end + 1;
+		}
+		AddRule(rule.substr(beg));
+		return;
+	}
+
+	// Eat leading whitespace, return if we reach end of string.
+	int p = 0;
+	while (isspace(rule[p]))
+		if (++p &gt;= rule.length())
+			return;
+
+	// Nothing to do if the rule is a comment.
+	if (rule[p] == '#')
+		return;
+
+	// Eat trailing whitespace, return if we meet p.
+	int q = rule.length() - 1;
+	while (isspace(rule[q]))
+		if (--q &lt; p)
+			return;
+
+	// Build the rule.
+	Rule r;
+	if (rule[p] == '!') {
+		r.negate = true;
+		if (++p &gt; q)
+			return;
+	}
+	r.glob = rule.substr(p, 1 + q - p);
+	r.regex = boost::regex(glob_to_regex(r.glob)
+		, boost::regex::icase | boost::regex::no_escape_in_lists);
+	rules.push_back(r);
+	//printf(&quot;added %s%s: %s\n&quot;, r.negate ? &quot;!&quot; : &quot;&quot;, r.glob.c_str(), r.regex.expression());
+}
+
+
+/** @brief Checks whether filename matches this filter. */
+bool CFileFilter::Match(const string&amp; filename) const
+{
+	bool match = false;
+	for (vector&lt;Rule&gt;::const_iterator it = rules.begin(); it != rules.end(); ++it) {
+		if (boost::regex_search(filename, it-&gt;regex))
+			match = !it-&gt;negate;
+	}
+	return match;
+}
+
+
+string CFileFilter::glob_to_regex(const string&amp; glob)
+{
+#define PATH_SEPARATORS &quot;/\\:&quot;
+
+	std::stringstream regex;
+	string::const_iterator i = glob.begin();
+
+	// If the path starts with a path separator, we take it as an absolute path
+	// (relative to whatever is passed to Match() later on), so we insert the
+	// begin anchor.
+
+	// Otherwise we 'just' need to make sure the glob matches only full path
+	// elements, so we require either start of line OR path separator.
+
+	if (i != glob.end() &amp;&amp; *i == '/' || *i == '\\') {
+		regex &lt;&lt; '^';
+		++i;
+	}
+	else
+		regex &lt;&lt; &quot;(^|[&quot; PATH_SEPARATORS &quot;])&quot;;
+
+	for (; i != glob.end(); ++i) {
+		char c = *i;
+		switch (c) {
+			case '*':
+				// In (shell) globbing the wildcards match anything except path separators.
+				regex &lt;&lt; &quot;[^&quot; PATH_SEPARATORS &quot;]*&quot;;
+				break;
+			case '?':
+				regex &lt;&lt; &quot;[^&quot; PATH_SEPARATORS &quot;]&quot;;
+				break;
+			case '/':
+			case '\\':
+			case ':':
+				// Any path separator matches any other path separator.
+				// (So we don't have to manually convert slashes before search.)
+				regex &lt;&lt; &quot;[&quot; PATH_SEPARATORS &quot;]&quot;;
+				break;
+			default:
+				if (!(isalnum(c) || c == '_'))
+					regex &lt;&lt; '\\';
+				regex &lt;&lt; c;
+				break;
+		}
+	}
+
+	// Make sure we only match full path elements. (see above)
+	regex &lt;&lt; &quot;([&quot; PATH_SEPARATORS &quot;]|$)&quot;;
+
+	return regex.str();
+}


Property changes on: trunk/rts/System/FileSystem/FileFilter.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/System/FileSystem/FileFilter.h
===================================================================
--- trunk/rts/System/FileSystem/FileFilter.h	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/System/FileSystem/FileFilter.h	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,17 +1,17 @@
-#ifndef FILEFILTER_H
-#define FILEFILTER_H
-
-#include &lt;string&gt;
-
-/** @brief Provides a way to filter files using globbing. */
-class IFileFilter
-{
-public:
-	static IFileFilter* Create();
-
-	virtual ~IFileFilter() {}
-	virtual void AddRule(const std::string&amp; rule) = 0;
-	virtual bool Match(const std::string&amp; filename) const = 0;
-};
-
-#endif // !FILEFILTER_H
+#ifndef FILEFILTER_H
+#define FILEFILTER_H
+
+#include &lt;string&gt;
+
+/** @brief Provides a way to filter files using globbing. */
+class IFileFilter
+{
+public:
+	static IFileFilter* Create();
+
+	virtual ~IFileFilter() {}
+	virtual void AddRule(const std::string&amp; rule) = 0;
+	virtual bool Match(const std::string&amp; filename) const = 0;
+};
+
+#endif // !FILEFILTER_H


Property changes on: trunk/rts/System/FileSystem/FileFilter.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/Net/PackPacket.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/Net/PackPacket.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/Net/Socket.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/Net/Socket.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/Net/UDPConnectedSocket.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/Net/UDPConnectedSocket.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/Net/UnpackPacket.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/Net/UnpackPacket.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/SFloat3.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/SpringApp.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/SpringApp.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/UnsyncedRNG.cpp
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/rts/System/UnsyncedRNG.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/rts/spring.exe.manifest
===================================================================
--- trunk/rts/spring.exe.manifest	2008-05-12 08:22:38 UTC (rev 5870)
+++ trunk/rts/spring.exe.manifest	2008-05-12 09:56:55 UTC (rev 5871)
@@ -1,11 +1,11 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
-&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt; 
-   &lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;X86&quot; name=&quot;spring&quot; type=&quot;win32&quot;/&gt;
-      &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
-      &lt;security&gt;
-         &lt;requestedPrivileges&gt;
-            &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot;/&gt; 
-         &lt;/requestedPrivileges&gt;
-      &lt;/security&gt;
-   &lt;/trustInfo&gt;
-&lt;/assembly&gt;
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
+&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt; 
+   &lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;X86&quot; name=&quot;spring&quot; type=&quot;win32&quot;/&gt;
+      &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
+      &lt;security&gt;
+         &lt;requestedPrivileges&gt;
+            &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot;/&gt; 
+         &lt;/requestedPrivileges&gt;
+      &lt;/security&gt;
+   &lt;/trustInfo&gt;
+&lt;/assembly&gt;


Property changes on: trunk/rts/spring.exe.manifest
___________________________________________________________________
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000650.html">[Taspring-linux-commit] r5870 - trunk/rts/Sim/Weapons
</A></li>
	<LI>Next message: <A HREF="000652.html">[Taspring-linux-commit] r5872 - in trunk: game/LuaUI	installer/builddata/springcontent/LuaGadgets rts/Game	rts/Game/UI tools/DedicatedServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#651">[ date ]</a>
              <a href="thread.html#651">[ thread ]</a>
              <a href="subject.html#651">[ subject ]</a>
              <a href="author.html#651">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
