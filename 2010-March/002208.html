<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7438 - in Lobby/TASClient: . Graphics	Themes
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2010-March/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7438%20-%20in%20Lobby/TASClient%3A%20.%20Graphics%0A%09Themes&In-Reply-To=%3C20100320164223.0A0052B4DD%40it-l.eu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002207.html">
   <LINK REL="Next"  HREF="002209.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7438 - in Lobby/TASClient: . Graphics	Themes</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7438%20-%20in%20Lobby/TASClient%3A%20.%20Graphics%0A%09Themes&In-Reply-To=%3C20100320164223.0A0052B4DD%40it-l.eu%3E"
       TITLE="[Taspring-linux-commit] r7438 - in Lobby/TASClient: . Graphics	Themes">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Mar 20 17:42:22 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002207.html">[Taspring-linux-commit] r7437 - Lobby/TASClient
</A></li>
        <LI>Next message: <A HREF="002209.html">[Taspring-linux-commit] r7439 - Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2208">[ date ]</a>
              <a href="thread.html#2208">[ thread ]</a>
              <a href="subject.html#2208">[ subject ]</a>
              <a href="author.html#2208">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: satirik
Date: 2010-03-20 17:42:21 +0100 (Sat, 20 Mar 2010)
New Revision: 7438

Added:
   Lobby/TASClient/Graphics/SplashScreen6.jpg
   Lobby/TASClient/Graphics/SplashScreen7.jpg
Removed:
   Lobby/TASClient/CustomColorUnit.ddp
   Lobby/TASClient/CustomColorUnit.dfm
   Lobby/TASClient/CustomColorUnit.pas
   Lobby/TASClient/Themes/TBXAthenTheme.pas
   Lobby/TASClient/Themes/TBXDreamTheme.pas
   Lobby/TASClient/Themes/TBXEosTheme.pas
   Lobby/TASClient/Themes/TBXMacOSXG32Theme.pas
   Lobby/TASClient/Themes/TBXMonaiTheme.pas
   Lobby/TASClient/Themes/TBXMonaiXPTheme.pas
   Lobby/TASClient/Themes/TBXNexos2Theme.pas
   Lobby/TASClient/Themes/TBXNexos3Theme.pas
   Lobby/TASClient/Themes/TBXNexos4Theme.pas
   Lobby/TASClient/Themes/TBXNexos5Theme.pas
   Lobby/TASClient/Themes/TBXNexosXTheme.pas
   Lobby/TASClient/Themes/TBXOffice11AdaptiveTheme.pas
   Lobby/TASClient/Themes/TBXOffice12Theme.pas
   Lobby/TASClient/Themes/TBXOfficeCTheme.pas
   Lobby/TASClient/Themes/TBXOfficeKTheme.pas
   Lobby/TASClient/Themes/TBXReliferTheme.pas
   Lobby/TASClient/Themes/TBXRomaTheme.pas
   Lobby/TASClient/Themes/TBXSentimoXTheme.pas
   Lobby/TASClient/Themes/TBXTristan2Theme.pas
   Lobby/TASClient/Themes/TBXTristanTheme.pas
   Lobby/TASClient/Themes/TBXWhidbeyTheme.pas
   Lobby/TASClient/Themes/TBXXitoTheme.pas
   Lobby/TASClient/Themes/TBXZezioTheme.pas
Modified:
   Lobby/TASClient/AddBotUnit.dfm
   Lobby/TASClient/AddBotUnit.pas
   Lobby/TASClient/BattleFormUnit.dfm
   Lobby/TASClient/BattleFormUnit.pas
   Lobby/TASClient/ColorPicker.dfm
   Lobby/TASClient/ColorPicker.pas
   Lobby/TASClient/MainUnit.dfm
   Lobby/TASClient/MainUnit.pas
   Lobby/TASClient/MapListFormUnit.dfm
   Lobby/TASClient/MapListFormUnit.pas
   Lobby/TASClient/PreferencesFormUnit.pas
   Lobby/TASClient/SplashScreenUnit.dfm
   Lobby/TASClient/TASClient.dpr
Log:
* removing all TBX code part 1

Modified: Lobby/TASClient/AddBotUnit.dfm
===================================================================
--- Lobby/TASClient/AddBotUnit.dfm	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/AddBotUnit.dfm	2010-03-20 16:42:21 UTC (rev 7438)
@@ -76,7 +76,6 @@
       Height = 21
       Caption = 'Team color'
       Anchors = [akLeft, akBottom]
-      OnClick = BotTeamColorButtonClick
       Images = MainForm.ColorImageList
       LinkFont.Charset = DEFAULT_CHARSET
       LinkFont.Color = clBlue

Modified: Lobby/TASClient/AddBotUnit.pas
===================================================================
--- Lobby/TASClient/AddBotUnit.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/AddBotUnit.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -43,7 +43,7 @@
     procedure FormCreate(Sender: TObject);
     procedure Button2Click(Sender: TObject);
     procedure AddBotButtonClick(Sender: TObject);
-    procedure BotTeamColorButtonClick(Sender: TObject);
+    //procedure BotTeamColorButtonClick(Sender: TObject);
     procedure BotTeamButtonClick(Sender: TObject);
     procedure BotAllyButtonClick(Sender: TObject);
     procedure BotSideButtonClick(Sender: TObject);
@@ -187,7 +187,7 @@
   BotSideButton.Tag := SideIndex;
 end;
 
-procedure TAddBotForm.BotTeamColorButtonClick(Sender: TObject);
+{procedure TAddBotForm.BotTeamColorButtonClick(Sender: TObject);
 var
   ColorIndex: Integer;
 begin
@@ -195,7 +195,7 @@
   if ColorIndex = -1 then Exit;
 
   ChangeTeamColor(ColorIndex);
-end;
+end;}
 
 procedure TAddBotForm.BotTeamButtonClick(Sender: TObject);
 var

Modified: Lobby/TASClient/BattleFormUnit.dfm
===================================================================
--- Lobby/TASClient/BattleFormUnit.dfm	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/BattleFormUnit.dfm	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,6 +1,6 @@
 object BattleForm: TBattleForm
-  Left = 777
-  Top = 319
+  Left = 612
+  Top = 246
   Width = 920
   Height = 612
   Caption = 'Battle window'
@@ -4950,7 +4950,6 @@
           Width = 113
           Height = 22
           Caption = 'Team color'
-          OnClick = TeamColorSpeedButtonClick
           Images = MainForm.ColorImageList
           LinkFont.Charset = DEFAULT_CHARSET
           LinkFont.Color = clBlue
@@ -4993,7 +4992,6 @@
           Height = 21
           PopupMenu = NumberSelection
           TabOrder = 5
-          OnContextPopup = MyTeamNoButtonContextPopup
           OnExit = MyTeamNoButtonExit
           MaxValue = 200.000000000000000000
           MinValue = 1.000000000000000000
@@ -5016,7 +5014,6 @@
           Height = 21
           PopupMenu = NumberSelection
           TabOrder = 6
-          OnContextPopup = MyAllyNoButtonContextPopup
           OnExit = MyAllyNoButtonExit
           MaxValue = 200.000000000000000000
           MinValue = 1.000000000000000000
@@ -12949,7 +12946,7 @@
         BiDiMode = bdLeftToRight
         Color = clBtnFace
         ParentBiDiMode = False
-        ActiveTabIndex = 2
+        ActiveTabIndex = 1
         ThemeType = tttTBX
         OnActiveTabChange = SpTBXTabControl1ActiveTabChange
         HiddenItems = &lt;
@@ -12992,6 +12989,7 @@
         object GameOptionsTab: TSpTBXTabItem
           Caption = 'Game options'
           Wrapping = twWrap
+          Checked = True
           CustomWidth = 80
           CustomHeight = 35
           ThemeType = tttTBX
@@ -12999,7 +12997,6 @@
         object DisabledUnitsTab: TSpTBXTabItem
           Caption = 'Disabled Units (0)'
           Wrapping = twWrap
-          Checked = True
           CustomWidth = 94
           ThemeType = tttTBX
         end
@@ -13040,243 +13037,6 @@
             OnMouseMove = QuickLookRichEditMouseMove
           end
         end
-        object SpTBXTabSheet2: TSpTBXTabSheet
-          Left = 0
-          Top = 39
-          Width = 413
-          Height = 230
-          Caption = 'Game options'
-          ImageIndex = -1
-          Item = GameOptionsTab
-          TabControl = MainForm.FiltersTabs
-          TabItem = 'GameOptionsTab'
-          object ResourcesGroupBox: TSpTBXGroupBox
-            Left = 248
-            Top = 8
-            Width = 161
-            Height = 225
-            Caption = 'Resources'
-            Color = clNone
-            ParentColor = False
-            TabOrder = 1
-            object lblEnergy: TSpTBXLabel
-              Left = 56
-              Top = 184
-              Width = 41
-              Height = 33
-              Cursor = crHandPoint
-              Caption = 'Energy'
-              AutoSize = False
-              Font.Charset = DEFAULT_CHARSET
-              Font.Color = clHotLight
-              Font.Height = -11
-              Font.Name = 'MS Sans Serif'
-              Font.Style = [fsUnderline]
-              ParentFont = False
-              Wrapping = twWrap
-              OnClick = lblEnergyClick
-              Alignment = taCenter
-              LinkFont.Charset = DEFAULT_CHARSET
-              LinkFont.Color = clBlue
-              LinkFont.Height = -11
-              LinkFont.Name = 'MS Sans Serif'
-              LinkFont.Style = [fsUnderline]
-            end
-            object lblMetal: TSpTBXLabel
-              Left = 8
-              Top = 184
-              Width = 41
-              Height = 33
-              Cursor = crHandPoint
-              Caption = 'Metal'
-              AutoSize = False
-              Font.Charset = DEFAULT_CHARSET
-              Font.Color = clHotLight
-              Font.Height = -11
-              Font.Name = 'MS Sans Serif'
-              Font.Style = [fsUnderline]
-              ParentFont = False
-              Wrapping = twWrap
-              OnClick = lblMetalClick
-              Alignment = taCenter
-              LinkFont.Charset = DEFAULT_CHARSET
-              LinkFont.Color = clBlue
-              LinkFont.Height = -11
-              LinkFont.Name = 'MS Sans Serif'
-              LinkFont.Style = [fsUnderline]
-            end
-            object lblUnits: TSpTBXLabel
-              Left = 104
-              Top = 184
-              Width = 49
-              Height = 33
-              Cursor = crHandPoint
-              Caption = 'Units'
-              AutoSize = False
-              Font.Charset = DEFAULT_CHARSET
-              Font.Color = clHotLight
-              Font.Height = -11
-              Font.Name = 'MS Sans Serif'
-              Font.Style = [fsUnderline]
-              ParentFont = False
-              Wrapping = twWrap
-              OnClick = lblUnitsClick
-              Alignment = taCenter
-              LinkFont.Charset = DEFAULT_CHARSET
-              LinkFont.Color = clBlue
-              LinkFont.Height = -11
-              LinkFont.Name = 'MS Sans Serif'
-              LinkFont.Style = [fsUnderline]
-            end
-            object MetalTracker: TSpTBXjanTracker
-              Left = 10
-              Top = 16
-              Width = 39
-              Height = 171
-              ThemeType = thtWindows
-              Minimum = 0
-              Maximum = 10000
-              Value = 1000
-              Orientation = jtbVertical
-              BackColor = clBtnFace
-              BackBorder = False
-              TrackColor = clGray
-              TrackPositionColor = False
-              TrackBorder = True
-              BorderColor = clBlack
-              ThumbColor = clSilver
-              ThumbBorder = False
-              ThumbWidth = 40
-              ThumbHeight = 16
-              TrackHeight = 6
-              ShowCaption = True
-              CaptionColor = clBlack
-              CaptionBold = False
-              OnMouseUpAfterChange = MetalTrackerMouseUpAfterChange
-            end
-            object EnergyTracker: TSpTBXjanTracker
-              Left = 58
-              Top = 16
-              Width = 39
-              Height = 171
-              ThemeType = thtWindows
-              Minimum = 0
-              Maximum = 10000
-              Value = 1000
-              Orientation = jtbVertical
-              BackColor = clBtnFace
-              BackBorder = False
-              TrackColor = clGray
-              TrackPositionColor = False
-              TrackBorder = True
-              BorderColor = clBlack
-              ThumbColor = clSilver
-              ThumbBorder = False
-              ThumbWidth = 40
-              ThumbHeight = 16
-              TrackHeight = 6
-              ShowCaption = True
-              CaptionColor = clBlack
-              CaptionBold = False
-              OnMouseUpAfterChange = EnergyTrackerMouseUpAfterChange
-            end
-            object UnitsTracker: TSpTBXjanTracker
-              Left = 106
-              Top = 16
-              Width = 39
-              Height = 171
-              ThemeType = thtWindows
-              Minimum = 10
-              Maximum = 5000
-              Value = 1000
-              Orientation = jtbVertical
-              BackColor = clBtnFace
-              BackBorder = False
-              TrackColor = clGray
-              TrackPositionColor = False
-              TrackBorder = True
-              BorderColor = clBlack
-              ThumbColor = clSilver
-              ThumbBorder = False
-              ThumbWidth = 40
-              ThumbHeight = 16
-              TrackHeight = 6
-              ShowCaption = True
-              CaptionColor = clBlack
-              CaptionBold = False
-              OnMouseUpAfterChange = UnitsTrackerMouseUpAfterChange
-            end
-          end
-          object GameEndRadioGroup: TSpTBXRadioGroup
-            Left = 16
-            Top = 120
-            Width = 225
-            Height = 65
-            Hint = 
-              'Lineage mode = Every units or building you made will explode if ' +
-              'your commander dies (You can'#39't share your units just before your' +
-              ' commander dies)'
-            Caption = 'Game end condition'
-            Color = clNone
-            ParentColor = False
-            ParentShowHint = False
-            ShowHint = True
-            TabOrder = 2
-            Visible = False
-            OnClick = GameEndRadioGroupClick
-          end
-          object StartPosRadioGroup: TSpTBXRadioGroup
-            Left = 16
-            Top = 40
-            Width = 225
-            Height = 72
-            Hint = 
-              'Where players will start on the map, using the fixed positions o' +
-              'f the map in the ascending order, using the fixed positions of t' +
-              'he map assigned randomly or using the start boxes.'
-            Caption = 'Start position'
-            Color = clNone
-            ParentColor = False
-            ParentShowHint = False
-            ShowHint = True
-            TabOrder = 3
-            OnClick = StartPosRadioGroupClick
-            ItemIndex = 2
-            Items.Strings = (
-              'Fixed'
-              'Random'
-              'Choose in game'
-              'Choose now')
-          end
-          object LoadDefaultButton: TSpTBXButton
-            Left = 16
-            Top = 8
-            Width = 110
-            Height = 25
-            Caption = 'Load default'
-            TabOrder = 0
-            OnClick = LoadDefaultButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-          object SetDefaultButton: TSpTBXButton
-            Left = 130
-            Top = 8
-            Width = 110
-            Height = 25
-            Caption = 'Set as default'
-            TabOrder = 4
-            OnClick = SetDefaultButtonClick
-            LinkFont.Charset = DEFAULT_CHARSET
-            LinkFont.Color = clBlue
-            LinkFont.Height = -11
-            LinkFont.Name = 'MS Sans Serif'
-            LinkFont.Style = [fsUnderline]
-          end
-        end
         object ModTabSheet: TSpTBXTabSheet
           Left = 0
           Top = 39
@@ -13520,6 +13280,243 @@
             end
           end
         end
+        object SpTBXTabSheet2: TSpTBXTabSheet
+          Left = 0
+          Top = 39
+          Width = 413
+          Height = 230
+          Caption = 'Game options'
+          ImageIndex = -1
+          Item = GameOptionsTab
+          TabControl = MainForm.FiltersTabs
+          TabItem = 'GameOptionsTab'
+          object ResourcesGroupBox: TSpTBXGroupBox
+            Left = 248
+            Top = 8
+            Width = 161
+            Height = 225
+            Caption = 'Resources'
+            Color = clNone
+            ParentColor = False
+            TabOrder = 1
+            object lblEnergy: TSpTBXLabel
+              Left = 56
+              Top = 184
+              Width = 41
+              Height = 33
+              Cursor = crHandPoint
+              Caption = 'Energy'
+              AutoSize = False
+              Font.Charset = DEFAULT_CHARSET
+              Font.Color = clHotLight
+              Font.Height = -11
+              Font.Name = 'MS Sans Serif'
+              Font.Style = [fsUnderline]
+              ParentFont = False
+              Wrapping = twWrap
+              OnClick = lblEnergyClick
+              Alignment = taCenter
+              LinkFont.Charset = DEFAULT_CHARSET
+              LinkFont.Color = clBlue
+              LinkFont.Height = -11
+              LinkFont.Name = 'MS Sans Serif'
+              LinkFont.Style = [fsUnderline]
+            end
+            object lblMetal: TSpTBXLabel
+              Left = 8
+              Top = 184
+              Width = 41
+              Height = 33
+              Cursor = crHandPoint
+              Caption = 'Metal'
+              AutoSize = False
+              Font.Charset = DEFAULT_CHARSET
+              Font.Color = clHotLight
+              Font.Height = -11
+              Font.Name = 'MS Sans Serif'
+              Font.Style = [fsUnderline]
+              ParentFont = False
+              Wrapping = twWrap
+              OnClick = lblMetalClick
+              Alignment = taCenter
+              LinkFont.Charset = DEFAULT_CHARSET
+              LinkFont.Color = clBlue
+              LinkFont.Height = -11
+              LinkFont.Name = 'MS Sans Serif'
+              LinkFont.Style = [fsUnderline]
+            end
+            object lblUnits: TSpTBXLabel
+              Left = 104
+              Top = 184
+              Width = 49
+              Height = 33
+              Cursor = crHandPoint
+              Caption = 'Units'
+              AutoSize = False
+              Font.Charset = DEFAULT_CHARSET
+              Font.Color = clHotLight
+              Font.Height = -11
+              Font.Name = 'MS Sans Serif'
+              Font.Style = [fsUnderline]
+              ParentFont = False
+              Wrapping = twWrap
+              OnClick = lblUnitsClick
+              Alignment = taCenter
+              LinkFont.Charset = DEFAULT_CHARSET
+              LinkFont.Color = clBlue
+              LinkFont.Height = -11
+              LinkFont.Name = 'MS Sans Serif'
+              LinkFont.Style = [fsUnderline]
+            end
+            object MetalTracker: TSpTBXjanTracker
+              Left = 10
+              Top = 16
+              Width = 39
+              Height = 171
+              ThemeType = thtWindows
+              Minimum = 0
+              Maximum = 10000
+              Value = 1000
+              Orientation = jtbVertical
+              BackColor = clBtnFace
+              BackBorder = False
+              TrackColor = clGray
+              TrackPositionColor = False
+              TrackBorder = True
+              BorderColor = clBlack
+              ThumbColor = clSilver
+              ThumbBorder = False
+              ThumbWidth = 40
+              ThumbHeight = 16
+              TrackHeight = 6
+              ShowCaption = True
+              CaptionColor = clBlack
+              CaptionBold = False
+              OnMouseUpAfterChange = MetalTrackerMouseUpAfterChange
+            end
+            object EnergyTracker: TSpTBXjanTracker
+              Left = 58
+              Top = 16
+              Width = 39
+              Height = 171
+              ThemeType = thtWindows
+              Minimum = 0
+              Maximum = 10000
+              Value = 1000
+              Orientation = jtbVertical
+              BackColor = clBtnFace
+              BackBorder = False
+              TrackColor = clGray
+              TrackPositionColor = False
+              TrackBorder = True
+              BorderColor = clBlack
+              ThumbColor = clSilver
+              ThumbBorder = False
+              ThumbWidth = 40
+              ThumbHeight = 16
+              TrackHeight = 6
+              ShowCaption = True
+              CaptionColor = clBlack
+              CaptionBold = False
+              OnMouseUpAfterChange = EnergyTrackerMouseUpAfterChange
+            end
+            object UnitsTracker: TSpTBXjanTracker
+              Left = 106
+              Top = 16
+              Width = 39
+              Height = 171
+              ThemeType = thtWindows
+              Minimum = 10
+              Maximum = 5000
+              Value = 1000
+              Orientation = jtbVertical
+              BackColor = clBtnFace
+              BackBorder = False
+              TrackColor = clGray
+              TrackPositionColor = False
+              TrackBorder = True
+              BorderColor = clBlack
+              ThumbColor = clSilver
+              ThumbBorder = False
+              ThumbWidth = 40
+              ThumbHeight = 16
+              TrackHeight = 6
+              ShowCaption = True
+              CaptionColor = clBlack
+              CaptionBold = False
+              OnMouseUpAfterChange = UnitsTrackerMouseUpAfterChange
+            end
+          end
+          object GameEndRadioGroup: TSpTBXRadioGroup
+            Left = 16
+            Top = 120
+            Width = 225
+            Height = 65
+            Hint = 
+              'Lineage mode = Every units or building you made will explode if ' +
+              'your commander dies (You can'#39't share your units just before your' +
+              ' commander dies)'
+            Caption = 'Game end condition'
+            Color = clNone
+            ParentColor = False
+            ParentShowHint = False
+            ShowHint = True
+            TabOrder = 2
+            Visible = False
+            OnClick = GameEndRadioGroupClick
+          end
+          object StartPosRadioGroup: TSpTBXRadioGroup
+            Left = 16
+            Top = 40
+            Width = 225
+            Height = 72
+            Hint = 
+              'Where players will start on the map, using the fixed positions o' +
+              'f the map in the ascending order, using the fixed positions of t' +
+              'he map assigned randomly or using the start boxes.'
+            Caption = 'Start position'
+            Color = clNone
+            ParentColor = False
+            ParentShowHint = False
+            ShowHint = True
+            TabOrder = 3
+            OnClick = StartPosRadioGroupClick
+            ItemIndex = 2
+            Items.Strings = (
+              'Fixed'
+              'Random'
+              'Choose in game'
+              'Choose now')
+          end
+          object LoadDefaultButton: TSpTBXButton
+            Left = 16
+            Top = 8
+            Width = 110
+            Height = 25
+            Caption = 'Load default'
+            TabOrder = 0
+            OnClick = LoadDefaultButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+          object SetDefaultButton: TSpTBXButton
+            Left = 130
+            Top = 8
+            Width = 110
+            Height = 25
+            Caption = 'Set as default'
+            TabOrder = 4
+            OnClick = SetDefaultButtonClick
+            LinkFont.Charset = DEFAULT_CHARSET
+            LinkFont.Color = clBlue
+            LinkFont.Height = -11
+            LinkFont.Name = 'MS Sans Serif'
+            LinkFont.Style = [fsUnderline]
+          end
+        end
       end
     end
   end
@@ -13534,11 +13531,6 @@
     AutoHotkeys = maManual
     Left = 280
     Top = 488
-    object TBXColorPalette1: TTBXColorPalette
-      ColorSet = TBXTeamColorSet
-      PaletteOptions = [tpoCustomImages]
-      OnCellClick = TBXColorPalette1CellClick
-    end
     object SpTBXItem4: TSpTBXItem
       Caption = 'Customize ...'
       OnClick = SpTBXItem4Click
@@ -13549,40 +13541,21 @@
       Caption = 'Cancel'
     end
   end
-  object TBXTeamColorSet: TTBXColorSet
-    ColCount = 5
-    RowCount = 4
-    OnGetColorInfo = TBXTeamColorSetGetColorInfo
-    Left = 248
-    Top = 488
-  end
   object PlayerControlPopupMenu: TSpTBXPopupMenu
     AutoHotkeys = maManual
     OnPopup = PlayerControlPopupMenuPopup
     Left = 304
     Top = 352
-    object ForceTeamSpin: TTBXSpinEditItem
-      Caption = 'Set id'
-      EditCaption = 'Set id'
-      EditWidth = 4
-      MaxLength = 3
-      OnValueChange = ForceTeamSpinValueChange
+    object ForceTeamSpin: TSpTBXEditItem
+      Caption = 'Set Id'
+      OnChange = ForceTeamSpinChange
     end
-    object ForceAllySpin: TTBXSpinEditItem
+    object ForceAllySpin: TSpTBXEditItem
       Caption = 'Set team'
-      EditCaption = 'Set team'
-      EditWidth = 4
-      MaxLength = 3
-      OnValueChange = ForceAllySpinValueChange
+      OnChange = ForceAllySpinChange
     end
     object SetTeamColorItem: TSpTBXSubmenuItem
       Caption = 'Set id color'
-      OnClick = SetTeamColorItemClick
-      object ForceTeamColorPalette: TTBXColorPalette
-        ColorSet = TBXTeamColorSet
-        PaletteOptions = [tpoCustomImages]
-        OnCellClick = ForceTeamColorPaletteCellClick
-      end
       object SpTBXItem7: TSpTBXItem
         Caption = 'Customize ...'
         OnClick = SpTBXItem7Click
@@ -13593,15 +13566,9 @@
         Caption = 'Cancel'
       end
     end
-    object HandicapSpinEditItem: TTBXSpinEditItem
-      AutoCheck = True
+    object HandicapSpinEditItem: TSpTBXEditItem
       Caption = 'Bonus'
-      EditCaption = 'Bonus'
-      EditWidth = 48
-      MaxLength = 3
-      Increment = 10.000000000000000000
-      MaxValue = 100.000000000000000000
-      OnValueChange = HandicapSpinEditItemValueChange
+      OnChange = HandicapSpinEditItemChange
     end
     object KickPlayerItem: TSpTBXItem
       Caption = 'Kick player (bot)'
@@ -13860,12 +13827,6 @@
     AutoHotkeys = maManual
     Left = 82
     Top = 466
-    object Numbers: TTBXToolPalette
-      ColCount = 4
-      Images = NumbersImgList
-      PaletteOptions = []
-      OnCellClick = NumbersCellClick
-    end
   end
   object NumbersImgList: TTBImageList
     Left = 114

Modified: Lobby/TASClient/BattleFormUnit.pas
===================================================================
--- Lobby/TASClient/BattleFormUnit.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/BattleFormUnit.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -30,9 +30,6 @@
 
 type
 
-  // we have to use this ugly hack to expose SelectedCell property in TTBXColorPallete class:
-  TTBXColorPaletteHack = class(TTBXColorPalette);
-
   TJvXPCustomButtonHack = class(TJvXPCustomButton); // another hack to expose Color property
 
   TClientNodeType = (NodeError, NormalClient, NormalBot, OriginalClient,Separator); // used to differentiate between &quot;types&quot; of nodes in the visual battle clients list, so for example we can decided what to paint on OnPaint event etc. NodeError is used to indicate that certain node has invalid position.
@@ -165,14 +162,10 @@
   TBattleForm = class(TForm)
     GameTimer: TTimer;
     ColorPopupMenu: TSpTBXPopupMenu;
-    TBXColorPalette1: TTBXColorPalette;
-    TBXTeamColorSet: TTBXColorSet;
     SpTBXItem1: TSpTBXItem;
     PlayerControlPopupMenu: TSpTBXPopupMenu;
-    HandicapSpinEditItem: TTBXSpinEditItem;
     KickPlayerItem: TSpTBXItem;
     SetTeamColorItem: TSpTBXSubmenuItem;
-    ForceTeamColorPalette: TTBXColorPalette;
     SpTBXItem3: TSpTBXItem;
     SetBotSideSubitem: TSpTBXSubmenuItem;
     SpTBXItem4: TSpTBXItem;
@@ -242,8 +235,6 @@
     SpTBXSeparatorItem14: TSpTBXSeparatorItem;
     mnuAutoLockOnStart: TSpTBXItem;
     ChooseSidePopupMenu: TSpTBXPopupMenu;
-    ForceAllySpin: TTBXSpinEditItem;
-    ForceTeamSpin: TTBXSpinEditItem;
     PlayerSubmenu: TSpTBXSubmenuItem;
     MyOptionsPanel: TSpTBXPanel;
     MyOptionsGroupBox: TSpTBXGroupBox;
@@ -326,7 +317,6 @@
     SpTBXTabSheet6: TSpTBXTabSheet;
     QuickLookRichEdit: TRichEdit;
     NumberSelection: TSpTBXPopupMenu;
-    Numbers: TTBXToolPalette;
     NumbersImgList: TTBImageList;
     AutoHostVotePanel: TSpTBXPanel;
     AutoHostVoteMsg: TSpTBXLabel;
@@ -436,6 +426,9 @@
     StartProgressBar: TSpTBXProgressBar;
     AddUnitsSpeedButton: TSpTBXButton;
     ZoomItem: TSpTBXItem;
+    ForceTeamSpin: TSpTBXEditItem;
+    ForceAllySpin: TSpTBXEditItem;
+    HandicapSpinEditItem: TSpTBXEditItem;
 
     procedure CreateParams(var Params: TCreateParams); override;
 
@@ -453,7 +446,7 @@
     function GenerateReplayHostScriptFile(FileName: string):TScript;
     procedure PunchThroughNAT; // only used when hosting using &quot;hole punching&quot; technique. See comments at method's implementation for more info.
 
-    function ChooseColorDialog(UnderControl: TControl; DefaultColorIndex: Integer): Integer;
+    //function ChooseColorDialog(UnderControl: TControl; DefaultColorIndex: Integer): Integer;
     function ChooseNumberDialog(UnderControl: TControl; DefaultIndex: Integer): Integer;
     function ChooseSideDialog(UnderControl: TControl; DefaultIndex: Integer): Integer;
 
@@ -521,7 +514,6 @@
       Shift: TShiftState);
     procedure SpectateCheckBoxClick(Sender: TObject);
     procedure GameEndRadioGroupClick(Sender: TObject);
-    procedure TeamColorSpeedButtonClick(Sender: TObject);
     procedure AddUnitsSpeedButtonClick(Sender: TObject);
     procedure AddBotButtonClick(Sender: TObject);
     procedure ChaTExRichEditURLClick(Sender: TObject; const URL: String);
@@ -533,12 +525,6 @@
     procedure FormShow(Sender: TObject);
     procedure SetDefaultButtonClick(Sender: TObject);
     procedure LoadDefaultButtonClick(Sender: TObject);
-    procedure TBXTeamColorSetGetColorInfo(Sender: TTBXCustomColorSet; Col,
-      Row: Integer; var Color: TColor; var Name: String);
-    procedure TBXColorPalette1CellClick(Sender: TTBXCustomToolPalette;
-      var ACol, ARow: Integer; var AllowChange: Boolean);
-    procedure TBXToolPalette1CellClick(Sender: TTBXCustomToolPalette;
-      var ACol, ARow: Integer; var AllowChange: Boolean);
     procedure VDTBattleClientsGetNodeWidth(Sender: TBaseVirtualTree;
       HintCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
       var NodeWidth: Integer);
@@ -551,14 +537,7 @@
       const PaintInfo: TVTPaintInfo);
     procedure VDTBattleClientsMouseUp(Sender: TObject;
       Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-    procedure ForceTeamToolPaletteCellClick(Sender: TTBXCustomToolPalette;
-      var ACol, ARow: Integer; var AllowChange: Boolean);
-    procedure ForceAllyToolPaletteCellClick(Sender: TTBXCustomToolPalette;
-      var ACol, ARow: Integer; var AllowChange: Boolean);
     procedure KickPlayerItemClick(Sender: TObject);
-    procedure ForceTeamColorPaletteCellClick(Sender: TTBXCustomToolPalette;
-      var ACol, ARow: Integer; var AllowChange: Boolean);
-    procedure SetTeamColorItemClick(Sender: TObject);
     procedure MySideButtonClick(Sender: TObject);
     procedure ReadyButtonClick(Sender: TObject);
     procedure SpTBXItem4Click(Sender: TObject);
@@ -652,21 +631,9 @@
       Shift: TShiftState; X, Y: Integer);
     procedure MyTeamNoButtonExit(Sender: TObject);
     procedure MyAllyNoButtonExit(Sender: TObject);
-    procedure ForceAllySpinValueChange(Sender: TTBXCustomSpinEditItem;
-      const AValue: Extended);
-    procedure ForceTeamSpinValueChange(Sender: TTBXCustomSpinEditItem;
-      const AValue: Extended);
     procedure VDTBattleClientsDragAllowed(Sender: TBaseVirtualTree;
       Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
     procedure Button1Click(Sender: TObject);
-    procedure HandicapSpinEditItemValueChange(
-      Sender: TTBXCustomSpinEditItem; const AValue: Extended);
-    procedure NumbersCellClick(Sender: TTBXCustomToolPalette; var ACol,
-      ARow: Integer; var AllowChange: Boolean);
-    procedure MyTeamNoButtonContextPopup(Sender: TObject; MousePos: TPoint;
-      var Handled: Boolean);
-    procedure MyAllyNoButtonContextPopup(Sender: TObject; MousePos: TPoint;
-      var Handled: Boolean);
     procedure AutoHostMsgFlashTimerTimer(Sender: TObject);
     procedure AutoHostInfoMsgsDrawItemBackground(Control: TWinControl;
       Index: Integer; Rect: TRect; State: TOwnerDrawState);
@@ -751,6 +718,10 @@
     procedure AutohostControlSplitterMoved(Sender: TObject);
     procedure PlayerControlPopupMenuPopup(Sender: TObject);
     procedure ZoomItemClick(Sender: TObject);
+    procedure ForceTeamSpinChange(Sender: TObject; const Text: WideString);
+    procedure ForceAllySpinChange(Sender: TObject; const Text: WideString);
+    procedure HandicapSpinEditItemChange(Sender: TObject;
+      const Text: WideString);
   private
     History: TWideStringList;
     HistoryIndex: Integer;
@@ -913,7 +884,7 @@
   Misc, HostBattleFormUnit, ShellAPI,
   MinimapZoomedFormUnit, PreferencesFormUnit, DisableUnitsFormUnit,
   InitWaitFormUnit, AddBotUnit, Math, ReplaysUnit, StrUtils,
-  CustomColorUnit, StringParser, MapListFormUnit, AutoTeamsUnit,
+  StringParser, MapListFormUnit, AutoTeamsUnit,
   AutoStartRectsUnit, ColorPicker, UploadReplayUnit, ProgressBarWindow,
   TntWideStrings, LobbyScriptUnit, SpringDownloaderFormUnit,
   MapSelectionFormUnit, TipsFormUnit, SpringSettingsProfileFormUnit,
@@ -2903,13 +2874,13 @@
   MyTeamNoButton.MaxValue := MAX_TEAMS;
   MyAllyNoButton.MinValue := 1;
   MyAllyNoButton.MaxValue := MAX_TEAMS;
-  ForceAllySpin.MinValue := 1;
+  {ForceAllySpin.MinValue := 1;
   ForceAllySpin.MaxValue := MAX_TEAMS;
   ForceTeamSpin.MinValue := 1;
-  ForceTeamSpin.MaxValue := MAX_TEAMS;
+  ForceTeamSpin.MaxValue := MAX_TEAMS;}
 
-  Numbers.RowCount := Floor(MAX_TEAMS/10)+1;
-  Numbers.ColCount := Min(10,MAX_TEAMS);
+  //Numbers.RowCount := Floor(MAX_TEAMS/10)+1;
+  //Numbers.ColCount := Min(10,MAX_TEAMS);
   for i:=1 to MAX_TEAMS do
   begin
     bmpNumber := TBitmap.Create;
@@ -4191,7 +4162,7 @@
   if UpdateServer then SendMyBattleStatusToServer;
 end;
 
-procedure TBattleForm.TeamColorSpeedButtonClick(Sender: TObject);
+{procedure TBattleForm.TeamColorSpeedButtonClick(Sender: TObject);
 var
   ColorIndex: Integer;
 begin
@@ -4199,7 +4170,7 @@
   if ColorIndex = -1 then Exit;
 
   ChangeTeamColor(ColorIndex, True);
-end;
+end;}
 
 procedure TBattleForm.AddUnitsSpeedButtonClick(Sender: TObject);
 var
@@ -4344,27 +4315,27 @@
     SendBattleDetailsToServer;
 end;
 
-procedure TBattleForm.TBXTeamColorSetGetColorInfo(Sender: TTBXCustomColorSet;
+{procedure TBattleForm.TBXTeamColorSetGetColorInfo(Sender: TTBXCustomColorSet;
   Col, Row: Integer; var Color: TColor; var Name: String);
 begin
   Color := TeamColors[Col + Row * Sender.ColCount];
   Name := 'Color ' + IntToStr(Col + Row * Sender.ColCount);
-end;
+end;}
 
-procedure TBattleForm.TBXColorPalette1CellClick(
+{procedure TBattleForm.TBXColorPalette1CellClick(
   Sender: TTBXCustomToolPalette; var ACol, ARow: Integer;
   var AllowChange: Boolean);
 begin
   // we keep selection information in Tag property:
   Sender.Tag := ACol + ARow * (Sender as TTBXColorPalette).ColorSet.ColCount;
-end;
+end;}
 
 { returns -1 if user cancels the dialog, otherwise returns color index.
   Specify DefaultColorIndex to indicate which color is &quot;default&quot;,
   that is currently selected color in choose color dialog (use -1 if you don't
   want any color to be selected). &quot;UnderControl&quot; is the control under which the
   choose color dialog should be displayed. }
-function TBattleForm.ChooseColorDialog(UnderControl: TControl; DefaultColorIndex: Integer): Integer;
+{function TBattleForm.ChooseColorDialog(UnderControl: TControl; DefaultColorIndex: Integer): Integer;
 var
   p: TPoint;
   Item: TTBCustomItem;
@@ -4390,7 +4361,7 @@
   end;
 
   Result := Item.Tag;
-end;
+end; }
 
 { returns -1 if user cancels the dialog, otherwise returns cell index
   (if user chooses 1, the returned index is 0!).
@@ -4432,13 +4403,13 @@
   Result := Item.Tag;
 end;
 
-procedure TBattleForm.TBXToolPalette1CellClick(
+{procedure TBattleForm.TBXToolPalette1CellClick(
   Sender: TTBXCustomToolPalette; var ACol, ARow: Integer;
   var AllowChange: Boolean);
 begin
   // we keep selection information in Tag property:
   Sender.Tag := ACol + ARow * (Sender as TTBXToolPalette).ColCount;
-end;
+end;}
 
 procedure TBattleForm.VDTBattleClientsGetNodeWidth(
   Sender: TBaseVirtualTree; HintCanvas: TCanvas; Node: PVirtualNode;
@@ -5169,11 +5140,11 @@
     ForceSpectatorModeItem.Enabled := (WhatToDraw = NormalClient) and (TClient(BattleState.Battle.Clients[RealIndex]).GetMode &lt;&gt; 0);
     if WhatToDraw = NormalClient then
     begin
-      HandicapSpinEditItem.Value := TClient(BattleState.Battle.Clients[RealIndex]).GetHandicap;
+      HandicapSpinEditItem.Text := IntToStr(TClient(BattleState.Battle.Clients[RealIndex]).GetHandicap);
     end
     else if WhatToDraw = NormalBot then
     begin
-      HandicapSpinEditItem.Value := TBot(BattleState.Battle.Bots[RealIndex]).GetHandicap;
+      HandicapSpinEditItem.Text := IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).GetHandicap);
     end;
 
     BanPlayerItem.Enabled := WhatToDraw = NormalClient;
@@ -5184,12 +5155,12 @@
     if VDTBattleClients.FocusedNode &lt;&gt; nil then
     begin
       if (WhatToDraw = NormalClient)
-      and (HandicapSpinEditItem.Value &lt;&gt; TClient(BattleState.Battle.Clients[RealIndex]).GetHandicap) then
-        MainForm.TryToSendCommand('HANDICAP', TClient(BattleState.Battle.Clients[RealIndex]).Name + ' ' + IntToStr(Round(HandicapSpinEditItem.Value)))
+      and (StrToInt(HandicapSpinEditItem.Text) &lt;&gt; TClient(BattleState.Battle.Clients[RealIndex]).GetHandicap) then
+        MainForm.TryToSendCommand('HANDICAP', TClient(BattleState.Battle.Clients[RealIndex]).Name + ' ' + IntToStr(StrToInt(HandicapSpinEditItem.Text)))
       else if (WhatToDraw = NormalBot)
-      and (HandicapSpinEditItem.Value &lt;&gt; TBot(BattleState.Battle.Bots[RealIndex]).GetHandicap) then
+      and (StrToInt(HandicapSpinEditItem.Text) &lt;&gt; TBot(BattleState.Battle.Bots[RealIndex]).GetHandicap) then
       begin
-        TBot(BattleState.Battle.Bots[RealIndex]).SetHandicap(Round(HandicapSpinEditItem.Value));
+        TBot(BattleState.Battle.Bots[RealIndex]).SetHandicap(StrToInt(HandicapSpinEditItem.Text));
         MainForm.TryToSendCommand('UPDATEBOT', TBot(BattleState.Battle.Bots[RealIndex]).Name + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).BattleStatus) + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).TeamColor));
       end;
     end;
@@ -5197,7 +5168,7 @@
   else if Button = mbLeft then ;
 end;
 
-procedure TBattleForm.ForceTeamToolPaletteCellClick(
+{procedure TBattleForm.ForceTeamToolPaletteCellClick(
   Sender: TTBXCustomToolPalette; var ACol, ARow: Integer;
   var AllowChange: Boolean);
 var
@@ -5272,7 +5243,7 @@
     end;
 
   end;
-end;
+end; }
 
 procedure TBattleForm.KickPlayerItemClick(Sender: TObject);
 var
@@ -5289,7 +5260,7 @@
   end;
 end;
 
-procedure TBattleForm.ForceTeamColorPaletteCellClick(
+{procedure TBattleForm.ForceTeamColorPaletteCellClick(
   Sender: TTBXCustomToolPalette; var ACol, ARow: Integer;
   var AllowChange: Boolean);
 var
@@ -5342,7 +5313,7 @@
   end
   else
     TTBXColorPaletteHack(ForceTeamColorPalette).SelectedCell := Point(-1, -1);
-end;
+end;}
 
 procedure TBattleForm.SetBotSideItemClick(Sender: TObject);
 var
@@ -7757,81 +7728,6 @@
   SendMyBattleStatusToServer;
 end;
 
-procedure TBattleForm.ForceAllySpinValueChange(
-  Sender: TTBXCustomSpinEditItem; const AValue: Extended);
-var
-  ally: Integer;
-  i:integer;
-  RealIndex: Integer;
-  WhatToDraw: TClientNodeType;
-begin
-  if (VDTBattleClients.FocusedNode &lt;&gt; nil) then
-  begin
-    GetNodeClient(VDTBattleClients.FocusedNode.Index,RealIndex,WhatToDraw);
-    ally := Round(AValue)-1;
-
-    if WhatToDraw = NormalClient then
-    begin
-      if mnuBlockTeams.Checked then
-        TClient(BattleState.Battle.Clients[RealIndex]).SetAllyNo(ally);
-      MainForm.TryToSendCommand('FORCEALLYNO', TClient(BattleState.Battle.Clients[RealIndex]).Name + ' ' + IntToStr(ally));
-      //AddTextToChat(_('Forcing ') + TClient(BattleState.Battle.Clients[RealIndex]).Name + _('''s ally number ...'), Colors.Info, 1);
-    end
-    else if WhatToDraw = NormalBot then
-    begin
-      TBot(BattleState.Battle.Bots[RealIndex]).SetAllyNo(Round(ally));
-      MainForm.TryToSendCommand('UPDATEBOT', TBot(BattleState.Battle.Bots[RealIndex]).Name + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).BattleStatus) + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).TeamColor));
-    end;
-
-  end;
-end;
-
-procedure TBattleForm.ForceTeamSpinValueChange(
-  Sender: TTBXCustomSpinEditItem; const AValue: Extended);
-var
-  team: Integer;
-  i:integer;
-  RealIndex: Integer;
-  WhatToDraw: TClientNodeType;
-begin
-  if (VDTBattleClients.FocusedNode &lt;&gt; nil) then
-  begin
-    GetNodeClient(VDTBattleClients.FocusedNode.Index,RealIndex,WhatToDraw);
-    team := Round(AValue)-1;
-
-    if WhatToDraw = NormalClient then
-    begin
-      if mnuBlockTeams.Checked then
-        TClient(BattleState.Battle.Clients[RealIndex]).SetTeamNo(team);
-      MainForm.TryToSendCommand('FORCETEAMNO', TClient(BattleState.Battle.Clients[RealIndex]).Name + ' ' + IntToStr(team));
-      //AddTextToChat(_('Forcing ') + TClient(BattleState.Battle.Clients[RealIndex]).Name + _('''s team number ...'), Colors.Info, 1);
-    end
-    else if WhatToDraw = NormalBot then
-    begin
-      with TBot(BattleState.Battle.Bots[RealIndex]) do begin
-        SetTeamNo(Round(team));
-        if isComSharing then begin
-          for i := 0 to BattleState.Battle.Clients.Count-1 do begin
-            if (TClient(BattleState.Battle.Clients[i]).GetTeamNo = GetTeamNo) then begin
-              TeamColor := TClient(BattleState.Battle.Clients[i]).TeamColor;
-              break;
-            end;
-          end;
-          if i &lt; BattleState.Battle.Clients.Count then begin
-            for i := 0 to BattleState.Battle.Bots.Count-1 do begin
-              if (TBot(BattleState.Battle.Bots[i]).GetTeamNo = GetTeamNo) and (TBot(BattleState.Battle.Bots[i]).Name &lt;&gt; Name) then begin
-                TeamColor := TBot(BattleState.Battle.Bots[i]).TeamColor;
-                break;
-              end;
-            end;
-          end;
-        end;
-      end;
-      MainForm.TryToSendCommand('UPDATEBOT', TBot(BattleState.Battle.Bots[RealIndex]).Name + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).BattleStatus) + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).TeamColor));
-    end;
-  end;
-end;
-
 procedure TBattleForm.VDTBattleClientsDragAllowed(Sender: TBaseVirtualTree;
   Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
 var
@@ -7847,31 +7743,14 @@
   ChatRichEdit.ScrollToBottom;
 end;
 
-procedure TBattleForm.HandicapSpinEditItemValueChange(
-  Sender: TTBXCustomSpinEditItem; const AValue: Extended);
-var
-  Value: Integer;
-begin
-  try
-    Value := StrToInt(Text);
-  except
-    Exit;
-  end;
-
-  if (Value &lt; 0) or (Value &gt; 100) then Exit;
-
-  // finally:
-  HandicapSpinEditItem.Value := Value;
-end;
-
-procedure TBattleForm.NumbersCellClick(Sender: TTBXCustomToolPalette;
+{procedure TBattleForm.NumbersCellClick(Sender: TTBXCustomToolPalette;
   var ACol, ARow: Integer; var AllowChange: Boolean);
 begin
   TSpTBXSpinEdit(NumberSelection.Tag).Value := 1+ACol+ARow*10;
   TSpTBXSpinEdit(NumberSelection.Tag).OnExit(nil);
-end;
+end;}
 
-procedure TBattleForm.MyTeamNoButtonContextPopup(Sender: TObject;
+{procedure TBattleForm.MyTeamNoButtonContextPopup(Sender: TObject;
   MousePos: TPoint; var Handled: Boolean);
 begin
   Handled := False;
@@ -7885,7 +7764,7 @@
   Handled := False;
   NumberSelection.Tag := Integer(MyAllyNoButton);
   Numbers.SelectedCell := Point((MyAllyNoButton.ValueAsInteger Mod 10)-1,Floor(MyAllyNoButton.ValueAsInteger/10));
-end;
+end; }
 
 procedure TBattleForm.AutoHostMsgFlashTimerTimer(Sender: TObject);
 begin
@@ -8463,13 +8342,13 @@
 
   if WhatToDraw = NormalClient then
   begin
-    ForceAllySpin.Value := TClient(BattleState.Battle.Clients[RealIndex]).GetAllyNo+1;
-    ForceTeamSpin.Value := TClient(BattleState.Battle.Clients[RealIndex]).GetTeamNo+1;
+    ForceAllySpin.Text := IntToStr(TClient(BattleState.Battle.Clients[RealIndex]).GetAllyNo+1);
+    ForceTeamSpin.Text := IntToStr(TClient(BattleState.Battle.Clients[RealIndex]).GetTeamNo+1);
   end
   else
   begin
-    ForceAllySpin.Value := TBot(BattleState.Battle.Bots[RealIndex]).GetAllyNo+1;
-    ForceTeamSpin.Value := TBot(BattleState.Battle.Bots[RealIndex]).GetTeamNo+1;
+    ForceAllySpin.Text := IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).GetAllyNo+1);
+    ForceTeamSpin.Text := IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).GetTeamNo+1);
   end;
 
   if WhatToDraw = NormalClient then
@@ -8492,5 +8371,97 @@
   MapImageMouseDown(MapImage,mbLeft,[ssLeft],-100,-100);
 end;
 
+procedure TBattleForm.ForceTeamSpinChange(Sender: TObject;
+  const Text: WideString);
+var
+  team: Integer;
+  i:integer;
+  RealIndex: Integer;
+  WhatToDraw: TClientNodeType;
+begin
+  if (VDTBattleClients.FocusedNode &lt;&gt; nil) then
+  begin
+    GetNodeClient(VDTBattleClients.FocusedNode.Index,RealIndex,WhatToDraw);
+    team := StrToInt(Text)-1;
+
+    if WhatToDraw = NormalClient then
+    begin
+      if mnuBlockTeams.Checked then
+        TClient(BattleState.Battle.Clients[RealIndex]).SetTeamNo(team);
+      MainForm.TryToSendCommand('FORCETEAMNO', TClient(BattleState.Battle.Clients[RealIndex]).Name + ' ' + IntToStr(team));
+      //AddTextToChat(_('Forcing ') + TClient(BattleState.Battle.Clients[RealIndex]).Name + _('''s team number ...'), Colors.Info, 1);
+    end
+    else if WhatToDraw = NormalBot then
+    begin
+      with TBot(BattleState.Battle.Bots[RealIndex]) do begin
+        SetTeamNo(Round(team));
+        if isComSharing then begin
+          for i := 0 to BattleState.Battle.Clients.Count-1 do begin
+            if (TClient(BattleState.Battle.Clients[i]).GetTeamNo = GetTeamNo) then begin
+              TeamColor := TClient(BattleState.Battle.Clients[i]).TeamColor;
+              break;
+            end;
+          end;
+          if i &lt; BattleState.Battle.Clients.Count then begin
+            for i := 0 to BattleState.Battle.Bots.Count-1 do begin
+              if (TBot(BattleState.Battle.Bots[i]).GetTeamNo = GetTeamNo) and (TBot(BattleState.Battle.Bots[i]).Name &lt;&gt; Name) then begin
+                TeamColor := TBot(BattleState.Battle.Bots[i]).TeamColor;
+                break;
+              end;
+            end;
+          end;
+        end;
+      end;
+      MainForm.TryToSendCommand('UPDATEBOT', TBot(BattleState.Battle.Bots[RealIndex]).Name + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).BattleStatus) + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).TeamColor));
+    end;
+  end;
+end;
+
+procedure TBattleForm.ForceAllySpinChange(Sender: TObject;
+  const Text: WideString);
+var
+  ally: Integer;
+  i:integer;
+  RealIndex: Integer;
+  WhatToDraw: TClientNodeType;
+begin
+  if (VDTBattleClients.FocusedNode &lt;&gt; nil) then
+  begin
+    GetNodeClient(VDTBattleClients.FocusedNode.Index,RealIndex,WhatToDraw);
+    ally := StrToInt(Text)-1;
+
+    if WhatToDraw = NormalClient then
+    begin
+      if mnuBlockTeams.Checked then
+        TClient(BattleState.Battle.Clients[RealIndex]).SetAllyNo(ally);
+      MainForm.TryToSendCommand('FORCEALLYNO', TClient(BattleState.Battle.Clients[RealIndex]).Name + ' ' + IntToStr(ally));
+      //AddTextToChat(_('Forcing ') + TClient(BattleState.Battle.Clients[RealIndex]).Name + _('''s ally number ...'), Colors.Info, 1);
+    end
+    else if WhatToDraw = NormalBot then
+    begin
+      TBot(BattleState.Battle.Bots[RealIndex]).SetAllyNo(Round(ally));
+      MainForm.TryToSendCommand('UPDATEBOT', TBot(BattleState.Battle.Bots[RealIndex]).Name + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).BattleStatus) + ' ' + IntToStr(TBot(BattleState.Battle.Bots[RealIndex]).TeamColor));
+    end;
+
+  end;
+end;
+
+procedure TBattleForm.HandicapSpinEditItemChange(Sender: TObject;
+  const Text: WideString);
+var
+  Value: Integer;
+begin
+  try
+    Value := StrToInt(Text);
+  except
+    Exit;
+  end;
+
+  if (Value &lt; 0) or (Value &gt; 100) then Exit;
+
+  // finally:
+  HandicapSpinEditItem.Text := IntToStr(Value);
+end;
+
 end.
 

Modified: Lobby/TASClient/ColorPicker.dfm
===================================================================
--- Lobby/TASClient/ColorPicker.dfm	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/ColorPicker.dfm	2010-03-20 16:42:21 UTC (rev 7438)
@@ -6,8 +6,8 @@
   ClientHeight = 409
   ClientWidth = 497
   Color = clBtnFace
-  Constraints.MaxHeight = 1000
-  Constraints.MaxWidth = 1680
+  Constraints.MaxHeight = 1150
+  Constraints.MaxWidth = 1920
   Font.Charset = DEFAULT_CHARSET
   Font.Color = clWindowText
   Font.Height = -11
@@ -326,19 +326,6 @@
         Color = clBlack
         TabOrder = 20
       end
-      object ColorToolbar: TSpTBXToolbar
-        Left = 384
-        Top = 264
-        Width = 90
-        Height = 72
-        Caption = 'ColorToolbar'
-        TabOrder = 21
-        object TBXColorPalette1: TTBXColorPalette
-          ColorSet = BattleForm.TBXTeamColorSet
-          PaletteOptions = []
-          OnCellClick = TBXColorPalette1CellClick
-        end
-      end
     end
   end
 end

Modified: Lobby/TASClient/ColorPicker.pas
===================================================================
--- Lobby/TASClient/ColorPicker.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/ColorPicker.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -36,8 +36,6 @@
     btCancel: TSpTBXButton;
     btDone: TSpTBXButton;
     ColorPanel: TPanel;
-    ColorToolbar: TSpTBXToolbar;
-    TBXColorPalette1: TTBXColorPalette;
     procedure FormCreate(Sender: TObject);
     procedure SndGradiantMouseDown(Sender: TObject; Button: TMouseButton;
       Shift: TShiftState; X, Y: Integer);
@@ -52,8 +50,6 @@
     procedure MainGradiantMouseUp(Sender: TObject; Button: TMouseButton;
       Shift: TShiftState; X, Y: Integer);
     procedure btResetClick(Sender: TObject);
-    procedure TBXColorPalette1CellClick(Sender: TTBXCustomToolPalette;
-      var ACol, ARow: Integer; var AllowChange: Boolean);
     procedure txtColorHexKeyDown(Sender: TObject; var Key: Word;
       Shift: TShiftState);
     procedure btDoneClick(Sender: TObject);
@@ -181,7 +177,7 @@
 
   TeamColors[FSelectedColorIndex] := ColorPanel.Color;
   MainForm.UpdateColorImageList;
-  ColorToolbar.Repaint;
+  //ColorToolbar.Repaint;
 end;
 
 procedure TColorPickerForm.DrawGradient2(s,e:integer);
@@ -281,10 +277,10 @@
 begin
   TeamColors := DefaultTeamColors;
   MainForm.UpdateColorImageList;
-  ColorToolbar.Repaint;
+  //ColorToolbar.Repaint;
 end;
 
-procedure TColorPickerForm.TBXColorPalette1CellClick(
+{procedure TColorPickerForm.TBXColorPalette1CellClick(
   Sender: TTBXCustomToolPalette; var ACol, ARow: Integer;
   var AllowChange: Boolean);
 begin
@@ -293,7 +289,7 @@
   txtG.Text := IntToStr(Misc.ColorToG(TBXColorPalette1.ColorSet.GetColor(ACol, ARow)));
   txtB.Text := IntToStr(Misc.ColorToB(TBXColorPalette1.ColorSet.GetColor(ACol, ARow)));
   RefreshRGBColor;
-end;
+end; *}
 
 procedure TColorPickerForm.RefreshHSLColor;
 var

Deleted: Lobby/TASClient/CustomColorUnit.ddp
===================================================================
(Binary files differ)

Deleted: Lobby/TASClient/CustomColorUnit.dfm
===================================================================
--- Lobby/TASClient/CustomColorUnit.dfm	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/CustomColorUnit.dfm	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,98 +0,0 @@
-object CustomColorForm: TCustomColorForm
-  Left = 352
-  Top = 311
-  BorderIcons = [biSystemMenu]
-  BorderStyle = bsDialog
-  Caption = 'Custom color dialog'
-  ClientHeight = 290
-  ClientWidth = 389
-  Color = clBtnFace
-  Constraints.MaxHeight = 1000
-  Constraints.MaxWidth = 1680
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  Position = poOwnerFormCenter
-  Scaled = False
-  OnCreate = FormCreate
-  PixelsPerInch = 96
-  TextHeight = 13
-  object SpTBXTitleBar1: TSpTBXTitleBar
-    Left = 0
-    Top = 0
-    Width = 389
-    Height = 290
-    Caption = 'Custom color dialog'
-    FixedSize = True
-    Options.Minimize = False
-    Options.Maximize = False
-    TBXStyleBackground = True
-    object JvGammaPanel1: TJvGammaPanel
-      Left = 320
-      Top = 32
-      OnChangeColor = JvGammaPanel1ChangeColor
-    end
-    object ColorToolbar: TSpTBXToolbar
-      Left = 8
-      Top = 40
-      Width = 90
-      Height = 72
-      Caption = 'ColorToolbar'
-      TabOrder = 2
-      object TBXColorPalette1: TTBXColorPalette
-        ColorSet = BattleForm.TBXTeamColorSet
-        PaletteOptions = []
-        OnCellClick = TBXColorPalette1CellClick
-      end
-    end
-    object SpTBXButton1: TSpTBXButton
-      Left = 120
-      Top = 256
-      Width = 83
-      Height = 25
-      Caption = 'Done'
-      TabOrder = 3
-      OnClick = SpTBXButton1Click
-      Cancel = True
-      Default = True
-      LinkFont.Charset = DEFAULT_CHARSET
-      LinkFont.Color = clBlue
-      LinkFont.Height = -11
-      LinkFont.Name = 'MS Sans Serif'
-      LinkFont.Style = [fsUnderline]
-    end
-    object SpTBXButton2: TSpTBXButton
-      Left = 8
-      Top = 104
-      Width = 153
-      Height = 25
-      Caption = 'Reset all colors to default'
-      TabOrder = 4
-      OnClick = SpTBXButton2Click
-      LinkFont.Charset = DEFAULT_CHARSET
-      LinkFont.Color = clBlue
-      LinkFont.Height = -11
-      LinkFont.Name = 'MS Sans Serif'
-      LinkFont.Style = [fsUnderline]
-    end
-    object SpTBXLabel4: TSpTBXLabel
-      Left = 112
-      Top = 32
-      Width = 201
-      Height = 49
-      Caption = 
-        'To adjust static color, select it in color grid and then choose ' +
-        'a new color in the color menu at the right'
-      AutoSize = False
-      Wrapping = twWrap
-      LinkFont.Charset = DEFAULT_CHARSET
-      LinkFont.Color = clBlue
-      LinkFont.Height = -11
-      LinkFont.Name = 'MS Sans Serif'
-      LinkFont.Style = [fsUnderline]
-    end
-  end
-end

Deleted: Lobby/TASClient/CustomColorUnit.pas
===================================================================
--- Lobby/TASClient/CustomColorUnit.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/CustomColorUnit.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,102 +0,0 @@
-unit CustomColorUnit;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, JvExControls, JvComponent, JvGammaPanel, StdCtrls, JvExStdCtrls,
-  JvButton, JvStartMenuButton, JvColorBox, JvColorButton, ExtCtrls,
-  JvExExtCtrls, JvOfficeColorButton, JvPanel, JvOfficeColorPanel, TB2Dock,
-  TB2Toolbar, TBX, SpTBXItem, TB2Item, TBXToolPals, TBXDkPanels,
-  SpTBXControls,Misc;
-
-type
-
-  TTBXColorPaletteHack = class(TTBXColorPalette)
-  end;
-
-  TCustomColorForm = class(TForm)
-    SpTBXTitleBar1: TSpTBXTitleBar;
-    JvGammaPanel1: TJvGammaPanel;
-    ColorToolbar: TSpTBXToolbar;
-    TBXColorPalette1: TTBXColorPalette;
-    SpTBXButton1: TSpTBXButton;
-    SpTBXButton2: TSpTBXButton;
-    SpTBXLabel4: TSpTBXLabel;
-
-    procedure CreateParams(var Params: TCreateParams); override;
-    procedure TBXColorPalette1CellClick(Sender: TTBXCustomToolPalette;
-      var ACol, ARow: Integer; var AllowChange: Boolean);
-    procedure FormCreate(Sender: TObject);
-    procedure JvGammaPanel1ChangeColor(Sender: TObject; Foreground,
-      Background: TColor);
-    procedure SpTBXButton2Click(Sender: TObject);
-    procedure SpTBXButton1Click(Sender: TObject);
-
-  private
-    FSelectedColorIndex: Integer;
-  public
-    { Public declarations }
-  end;
-
-var
-  CustomColorForm: TCustomColorForm;
-
-implementation
-
-uses BattleFormUnit, PreferencesFormUnit, MainUnit, gnugettext;
-
-{$R *.dfm}
-
-procedure TCustomColorForm.CreateParams(var Params: TCreateParams);
-begin
-  inherited CreateParams(Params);
-
-  if not Preferences.TaskbarButtons then Exit;
-
-  with Params do begin
-    ExStyle := ExStyle or WS_EX_APPWINDOW;
-    WndParent := GetDesktopWindow;
-  end;
-end;
-
-procedure TCustomColorForm.TBXColorPalette1CellClick(
-  Sender: TTBXCustomToolPalette; var ACol, ARow: Integer;
-  var AllowChange: Boolean);
-begin
-  FSelectedColorIndex := ACol + ARow * TBXColorPalette1.ColorSet.ColCount;
-  JVGammaPanel1.ForegroundColor := TBXColorPalette1.ColorSet.GetColor(ACol, ARow);
-end;
-
-procedure TCustomColorForm.FormCreate(Sender: TObject);
-begin
-  TranslateComponent(self);
-
-  if not SpTBXTitleBar1.Active then
-    RemoveSpTBXTitleBarMarges(self);
-  FSelectedColorIndex := -1;
-end;
-
-procedure TCustomColorForm.JvGammaPanel1ChangeColor(Sender: TObject;
-  Foreground, Background: TColor);
-begin
-  if FSelectedColorIndex = -1 then Exit; // we haven't selected a color yet
-
-  TeamColors[FSelectedColorIndex] := Foreground;
-  MainForm.UpdateColorImageList;
-  ColorToolbar.Repaint;
-end;
-
-procedure TCustomColorForm.SpTBXButton2Click(Sender: TObject);
-begin
-  TeamColors := DefaultTeamColors;
-  MainForm.UpdateColorImageList;
-  ColorToolbar.Repaint;
-end;
-
-procedure TCustomColorForm.SpTBXButton1Click(Sender: TObject);
-begin
-  Close;
-end;
-
-end.

Added: Lobby/TASClient/Graphics/SplashScreen6.jpg
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/Graphics/SplashScreen6.jpg
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/Graphics/SplashScreen7.jpg
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/Graphics/SplashScreen7.jpg
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: Lobby/TASClient/MainUnit.dfm
===================================================================
--- Lobby/TASClient/MainUnit.dfm	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/MainUnit.dfm	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,6 +1,6 @@
 object MainForm: TMainForm
-  Left = 671
-  Top = 411
+  Left = 569
+  Top = 127
   Width = 847
   Height = 521
   Caption = '.'
@@ -1225,22 +1225,6 @@
         LinkFont.Name = 'MS Sans Serif'
         LinkFont.Style = [fsUnderline]
       end
-      object ConnectButton: TTBXButton
-        Left = 8
-        Top = 2
-        Width = 49
-        Height = 36
-        Hint = 'Connection/Disconnection and Away message control'
-        BorderSize = 2
-        ButtonStyle = bsFlat
-        DropDownCombo = True
-        DropDownMenu = ConnectionPopupMenu
-        Images = ConnectionStateImageList
-        ParentShowHint = False
-        ShowHint = True
-        TabOrder = 4
-        OnClick = ConnectButtonClick
-      end
       object SinglePlayerButton: TSpTBXButton
         Left = 192
         Top = 8
@@ -1253,7 +1237,7 @@
         Caption = 'Single Player'
         ParentShowHint = False
         ShowHint = True
-        TabOrder = 6
+        TabOrder = 5
         OnClick = SinglePlayerButtonClick
         LinkFont.Charset = DEFAULT_CHARSET
         LinkFont.Color = clBlue
@@ -1281,6 +1265,39 @@
         LinkFont.Name = 'MS Sans Serif'
         LinkFont.Style = [fsUnderline]
       end
+      object ConnectButton: TSpTBXSpeedButton
+        Left = 2
+        Top = 2
+        Width = 36
+        Height = 36
+        Hint = 'Connection/Disconnection'
+        ParentShowHint = False
+        ShowHint = True
+        OnClick = ConnectButtonClick
+        Images = ConnectionStateImageList
+        ImageIndex = 0
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
+      object SpTBXButton1: TSpTBXButton
+        Left = 37
+        Top = 2
+        Width = 14
+        Height = 36
+        Hint = 'Away message control'
+        ParentShowHint = False
+        ShowHint = True
+        TabOrder = 7
+        DropDownMenu = ConnectionPopupMenu
+        LinkFont.Charset = DEFAULT_CHARSET
+        LinkFont.Color = clBlue
+        LinkFont.Height = -11
+        LinkFont.Name = 'MS Sans Serif'
+        LinkFont.Style = [fsUnderline]
+      end
     end
     object NewsMainPanel: TSpTBXPanel
       Left = 4

Modified: Lobby/TASClient/MainUnit.pas
===================================================================
--- Lobby/TASClient/MainUnit.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/MainUnit.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -405,9 +405,9 @@
   );
 
 const
-  VERSION_NUMBER = '0.70'; // Must be float value! (with a period as a decimal seperator)
+  VERSION_NUMBER = '0.71'; // Must be float value! (with a period as a decimal seperator)
   AUTOUPDATE_URL = '<A HREF="http://tasclient.no-ip.org/TASClient_update_v3.txt">http://tasclient.no-ip.org/TASClient_update_v3.txt</A>';
-  PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER;
+  PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER +' beta';
   KEEP_ALIVE_INTERVAL = 10000; // in milliseconds. Tells us what should be the maximum &quot;silence&quot; time before we send a ping to the server.
   ASSUME_TIMEOUT_INTERVAL = 30000; // in milliseconds. Must be greater than KEEP_ALIVE_INTERVAL! If server hasn't send any data to us within this interval, then we assume timeout occured. It's us who must make sure we get constant replies from server by pinging it.
   LOCAL_TAB = '$Local'; // caption of main (command) tab window. Must be special so that is different from channel names or user names, that is why there is a &quot;$&quot; in front of it.
@@ -1132,7 +1132,6 @@
     HelpButton: TSpTBXSpeedButton;
     ReplaysButton: TSpTBXSpeedButton;
     SearchButton: TSpTBXSpeedButton;
-    ConnectButton: TTBXButton;
     SinglePlayerButton: TSpTBXButton;
     ScrollingNewsTimer: TTimer;
     NewsMainPanel: TSpTBXPanel;
@@ -1241,6 +1240,8 @@
     RankSignButton: TSpTBXButton;
     RankValueTextBox: TJvSpinEdit;
     mnuRename: TSpTBXItem;
+    ConnectButton: TSpTBXSpeedButton;
+    SpTBXButton1: TSpTBXButton;
     procedure mnuOpenPrivateChatClick(Sender: TObject);
     procedure mnuSelectBattleClick(Sender: TObject);
     procedure mnuPlayWithClick(Sender: TObject);
@@ -7751,38 +7752,6 @@
           Break;
         end;
     end
-    else if sl[0] = 'MAPGRADES' then
-    begin
-      if (sl.Count-1) mod 3 &lt;&gt; 0 then
-      begin
-        AddMainLog(_('Error: Server sent ambiguous command!'), Colors.Error);
-        Exit;
-      end;
-
-      for i := 0 to (sl.Count-1) div 3 - 1 do
-      begin
-        hash := StrToInt(sl[1 + i*3]);
-        mapitem := FindMapItem(hash);
-        if mapitem = nil then Continue;
-
-        mapitem.GlobalGrade := StrToFloat(sl[1 +i*3+1]);
-        mapitem.TotalVotes := StrToInt(sl[1 +i*3+2]);
-        mapitem.PublicGradeLabel.Caption := Format('%2.1f (%d votes)', [mapitem.GlobalGrade, mapitem.TotalVotes]);
-        mapitem.Changed := True; // since global grade probably just changed
-      end;
-
-      if Preferences.MapSortStyle = 4 then MapListForm.SortMapList(Preferences.MapSortStyle);
-      MapListForm.StatusLabel.Caption := _('synchronization completed.');
-      SyncSentAt := 0;
-    end
-    else if sl[0] = 'MAPGRADESFAILED' then
-    begin
-      tmp := 'Unspecified error';
-      if sl.Count &gt; 1 then tmp := MakeSentenceWS(sl, 1);
-      MessageDlg('Unable to synchronize map grades (reason: ' + tmp + ')', mtWarning, [mbOK], 0);
-      MapListForm.StatusLabel.Caption := _('synchronization failed.');
-      SyncSentAt := 0;
-    end
     else if sl[0] = 'ACQUIREUSERID' then
     begin
       Misc.GenerateAndSaveLobbyUserID;

Modified: Lobby/TASClient/MapListFormUnit.dfm
===================================================================
--- Lobby/TASClient/MapListFormUnit.dfm	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/MapListFormUnit.dfm	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,8 +1,8 @@
 object MapListForm: TMapListForm
   Left = 694
   Top = 216
-  Width = 650
-  Height = 400
+  Width = 1139
+  Height = 800
   Caption = 'Map list'
   Color = clBtnFace
   Constraints.MinWidth = 650
@@ -24,19 +24,19 @@
   object TopPanel: TSpTBXPanel
     Left = 0
     Top = 0
-    Width = 642
-    Height = 65
+    Width = 1131
+    Height = 73
     Align = alTop
     Color = clNone
     ParentColor = False
     TabOrder = 0
     TBXStyleBackground = True
     DesignSize = (
-      642
-      65)
+      1131
+      73)
     object NoPreviewImage: TImage
       Left = 432
-      Top = 48
+      Top = 120
       Width = 100
       Height = 100
       AutoSize = True
@@ -996,7 +996,7 @@
       LinkFont.Style = [fsUnderline]
     end
     object CloseButton: TSpTBXButton
-      Left = 528
+      Left = 1017
       Top = 8
       Width = 105
       Height = 21
@@ -1012,37 +1012,6 @@
       LinkFont.Name = 'MS Sans Serif'
       LinkFont.Style = [fsUnderline]
     end
-    object SyncButton: TSpTBXButton
-      Left = 200
-      Top = 8
-      Width = 121
-      Height = 25
-      Caption = 'Synchronize grades'
-      TabOrder = 2
-      Visible = False
-      OnClick = SyncButtonClick
-      DropDownArrow = False
-      LinkFont.Charset = DEFAULT_CHARSET
-      LinkFont.Color = clBlue
-      LinkFont.Height = -11
-      LinkFont.Name = 'MS Sans Serif'
-      LinkFont.Style = [fsUnderline]
-    end
-    object SpTBXSpeedButton1: TSpTBXSpeedButton
-      Left = 320
-      Top = 8
-      Width = 23
-      Height = 25
-      Caption = '?'
-      Visible = False
-      OnClick = SpTBXSpeedButton1Click
-      DropDownArrow = False
-      LinkFont.Charset = DEFAULT_CHARSET
-      LinkFont.Color = clBlue
-      LinkFont.Height = -11
-      LinkFont.Name = 'MS Sans Serif'
-      LinkFont.Style = [fsUnderline]
-    end
     object SpTBXLabel1: TSpTBXLabel
       Left = 8
       Top = 24
@@ -1104,7 +1073,7 @@
       LinkFont.Style = [fsUnderline]
     end
     object SpTBXLabel3: TSpTBXLabel
-      Left = 352
+      Left = 841
       Top = 40
       Width = 277
       Height = 13
@@ -1127,17 +1096,17 @@
       LinkFont.Style = [fsUnderline]
     end
     object txtSearch: TEdit
-      Left = 416
+      Left = 905
       Top = 8
       Width = 101
       Height = 21
       Anchors = [akTop, akRight]
-      TabOrder = 10
+      TabOrder = 8
       OnChange = txtSearchChange
       OnKeyUp = txtSearchKeyUp
     end
     object lblSearch: TSpTBXLabel
-      Left = 320
+      Left = 809
       Top = 12
       Width = 89
       Height = 13
@@ -1154,9 +1123,9 @@
   end
   object ScrollBox1: TScrollBox
     Left = 0
-    Top = 65
-    Width = 642
-    Height = 308
+    Top = 73
+    Width = 1131
+    Height = 700
     HorzScrollBar.Increment = 57
     HorzScrollBar.Tracking = True
     VertScrollBar.Smooth = True
@@ -1173,29 +1142,6 @@
     ParentCtl3D = False
     TabOrder = 1
   end
-  object ChooseGradePopupMenu: TSpTBXPopupMenu
-    AutoHotkeys = maManual
-    Left = 384
-    Top = 52
-    object RemoveGradeItem: TSpTBXItem
-      Caption = 'Remove grade'
-    end
-    object SpTBXSeparatorItem2: TSpTBXSeparatorItem
-    end
-    object TBXToolPalette1: TTBXToolPalette
-      ColCount = 5
-      PaletteOptions = [tpoCustomImages]
-      RowCount = 2
-      OnCalcImageSize = TBXToolPalette1CalcImageSize
-      OnCellClick = TBXToolPalette1CellClick
-      OnDrawCellImage = TBXToolPalette1DrawCellImage
-    end
-    object SpTBXSeparatorItem1: TSpTBXSeparatorItem
-    end
-    object SpTBXItem1: TSpTBXItem
-      Caption = 'Cancel'
-    end
-  end
   object SyncTimeoutTimer: TTimer
     Enabled = False
     Interval = 100

Modified: Lobby/TASClient/MapListFormUnit.pas
===================================================================
--- Lobby/TASClient/MapListFormUnit.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/MapListFormUnit.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -5,8 +5,8 @@
 uses
   Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
   Dialogs, ExtCtrls, Buttons, StdCtrls, Menus, TB2Item, TBX, SpTBXItem,
-  TBXDkPanels, SpTBXControls, TBXToolPals, SpTBXTabs, ComCtrls,
-  JvExComCtrls, JvComCtrls, Utility,Misc, TntForms,Math,MainUnit;
+  SpTBXControls,SpTBXTabs, ComCtrls, JvExComCtrls, JvComCtrls, Utility,
+  Misc, TntForms,Math,MainUnit, TBXDkPanels;
 
 const
   MAP_ITEM_WIDTH = 355;
@@ -22,15 +22,7 @@
     TopPanel: TSpTBXPanel;
     TotalMapsLabel: TSpTBXLabel;
     NoPreviewImage: TImage;
-    ChooseGradePopupMenu: TSpTBXPopupMenu;
     CloseButton: TSpTBXButton;
-    SpTBXSeparatorItem1: TSpTBXSeparatorItem;
-    SpTBXItem1: TSpTBXItem;
-    TBXToolPalette1: TTBXToolPalette;
-    RemoveGradeItem: TSpTBXItem;
-    SpTBXSeparatorItem2: TSpTBXSeparatorItem;
-    SyncButton: TSpTBXButton;
-    SpTBXSpeedButton1: TSpTBXSpeedButton;
     SpTBXLabel1: TSpTBXLabel;
     StatusLabel: TSpTBXLabel;
     SyncTimeoutTimer: TTimer;
@@ -50,7 +42,6 @@
     procedure CreateParams(var Params: TCreateParams); override;
     procedure ClearMapList;
     procedure AddMap; // will automatically add next map from the utility.pas' MapList list
-    function ChooseGradeDialog(UnderControl: TControl; DefaultIndex: Integer): Integer;
 
     //function CompareMapItems(Map1: TMapItem; Map2: TMapItem; SortStyle: Byte): Integer;
     procedure SortMapList(SortStyle: Byte);
@@ -64,13 +55,6 @@
     procedure FormCreate(Sender: TObject);
     procedure FormDestroy(Sender: TObject);
     procedure CloseButtonClick(Sender: TObject);
-    procedure TBXToolPalette1CellClick(Sender: TTBXCustomToolPalette;
-      var ACol, ARow: Integer; var AllowChange: Boolean);
-    procedure TBXToolPalette1CalcImageSize(Sender: TTBXCustomToolPalette;
-      Canvas: TCanvas; var AWidth, AHeight: Integer);
-    procedure TBXToolPalette1DrawCellImage(Sender: TTBXCustomToolPalette;
-      Canvas: TCanvas; ARect: TRect; ACol, ARow: Integer; Selected, Hot,
-      Enabled: Boolean);
     procedure SpTBXSpeedButton1Click(Sender: TObject);
     procedure FormClose(Sender: TObject; var Action: TCloseAction);
     procedure SyncButtonClick(Sender: TObject);
@@ -127,9 +111,6 @@
     MainPanel: TMapItemPanel; // parent of all other controls of this map item
     NameLabel: TLabel;
     MapImage: TImage; // 200 x 200 pixels so that it fits battle screen as well
-    GradeButton: TTBXButton;
-    PublicGradeInfoLabel: TLabel;
-    PublicGradeLabel: TLabel;
 
     TidalStrengthLabel: TLabel;
     GravityLabel: TLabel;
@@ -149,7 +130,6 @@
     procedure LoadMapInfo; // will automatically attempt to load it from cache, or else it will read it from the map file itself
     function LoadMinimap(CacheOnly: Boolean; Bitmap: TBitmap = nil): Boolean; // will automatically attempt to load it from cache, or else it will read it from the map file itself. If CacheOnly is true, then it will attempt to read map from the cache only and not also from the map file itfself in case if reading from cache fails.
     procedure ApplyMapInfo(MapInfo: TMapInfo);
-    procedure GradeButtonClick(Sender: TObject);
     procedure MyCommentsRichEditChange(Sender: TObject);
 
     procedure OnMainPanelMouseEnter(Sender: TObject);
@@ -259,10 +239,6 @@
 
   HeightBoundsLoaded := False;
 
-  MyGrade := 0;
-  GlobalGrade := 0;
-  TotalVotes := 0;
-
   MapInfoLoaded := False;
   MapImageLoaded := False;
 
@@ -296,40 +272,6 @@
   NameLabel.Parent := MainPanel;
   NameLabel.ParentColor := true;
 
-  GradeButton := TTBXButton.Create(MainPanel);
-  GradeButton.Left := 114;
-  GradeButton.Top := 20;
-  GradeButton.Width := 77;
-  GradeButton.Height := 20;
-  GradeButton.Caption := _('my grade:');
-  GradeButton.Images := MainForm.GradesImageList;
-  GradeButton.ImageIndex := 0;
-  GradeButton.Layout := blGlyphRight;
-  GradeButton.OnClick := GradeButtonClick;
-  GradeButton.Enabled := False; // user is not allow to grade map before map info is loaded
-  GradeButton.Parent := MainPanel;
-  GradeButton.Visible := False;
-
-  PublicGradeInfoLabel := TLabel.Create(MainPanel);
-  PublicGradeInfoLabel.Caption := _('Global grade:');
-  PublicGradeInfoLabel.Left := 120;
-  PublicGradeInfoLabel.Top := 50;
-  PublicGradeInfoLabel.OnMouseDown := LabelMouseDown;
-  PublicGradeInfoLabel.OnMouseUp := LabelMouseUp;
-  PublicGradeInfoLabel.Parent := MainPanel;
-  PublicGradeInfoLabel.ParentColor := true;
-  PublicGradeInfoLabel.Visible := False;
-
-  PublicGradeLabel := TLabel.Create(MainPanel);
-  PublicGradeLabel.Caption := _('? (? votes)');
-  PublicGradeLabel.Left := 120;
-  PublicGradeLabel.Top := 65;
-  PublicGradeLabel.OnMouseDown := LabelMouseDown;
-  PublicGradeLabel.OnMouseUp := LabelMouseUp;
-  PublicGradeLabel.Parent := MainPanel;
-  PublicGradeLabel.ParentColor := true;
-  PublicGradeLabel.Visible := False;
-
   TabControl := TSpTBXTabControl.Create(MainPanel);
   TabControl.Left := 120;
   TabControl.Top := 20;
@@ -338,11 +280,11 @@
   TabControl.TabAutofit := True;
   TabControl.Parent := MainPanel;
   //*** this is a quick fix around black color problem that was introduced with SpTBX 1.8 (1.7?):
-  case Preferences.ThemeType of
+  {case Preferences.ThemeType of
     thtNone: TabControl.ThemeType := tttNone;
     thtWindows: TabControl.ThemeType := tttWindows;
     thtTBX: TabControl.ThemeType := tttTBX;
-  end; // of case
+  end; // of case}
 
   temp := TSpTBXTabItem.Create(MainPanel);
   temp.Caption := _('Details');
@@ -499,14 +441,9 @@
       MapInfo.Description := s;
       // read grade:
       Stream.ReadBuffer(i, SizeOf(i));
-      MyGrade := i;
-      if MainPanel &lt;&gt; nil then
-        GradeButton.ImageIndex := i;
       // read global (public) grade and number of votes:
       Stream.ReadBuffer(GlobalGrade, SizeOf(GlobalGrade));
       Stream.ReadBuffer(TotalVotes, SizeOf(TotalVotes));
-      if MainPanel &lt;&gt; nil then
-        PublicGradeLabel.Caption := Format('%2.1f (%d votes)', [GlobalGrade, TotalVotes]);
       // read comments:
       Stream.ReadBuffer(len, SizeOf(len));
       SetLength(s, len);
@@ -630,8 +567,6 @@
     ApplyMapInfo(MapInfo);
 
     NameLabel.Caption := Copy(MapName, 1, Length(MapName) - Length(ExtractFileExt(MapName))) + ' (Size: ' + IntToStr(MapInfo.Width div 64) + ' x ' + IntToStr(MapInfo.Height div 64) + ')';
-
-    GradeButton.Enabled := True; // user may now grade the map
   end;
 
   MapInfoLoaded := True;
@@ -833,28 +768,6 @@
   ((Sender as TImage).Parent as TMapItemPanel).OnMouseUp((Sender as TImage).Parent, Button, Shift, p.X, p.Y);
 end;
 
-procedure TMapItem.GradeButtonClick(Sender: TObject);
-var
-  res: Integer; // &quot;result&quot;
-begin
-  res := MapListForm.ChooseGradeDialog(GradeButton, MyGrade-1);
-  if res &gt; -1 then
-  begin
-    MyGrade := res + 1;
-    GradeButton.ImageIndex := res + 1;
-  end
-  else if res = -2 then
-  begin
-    MyGrade := 0;
-    GradeButton.ImageIndex := 0;
-  end;
-
-  MapListForm.SortMapInList(MapListForm.SortedMaps.IndexOf(Self), Preferences.MapSortStyle);
-
-  // indicates that we must save changes user has made at some point:
-  Self.Changed := True;
-end;
-
 procedure TMapListForm.FormCreate(Sender: TObject);
 begin
   TranslateComponent(self);
@@ -878,75 +791,11 @@
   SortedMaps.Free;
 end;
 
-{ returns -1 if user cancels the dialog, otherwise returns cell index
-  (if user chooses 1, the returned index is 0!).
-  Specify DefaultIndex to indicate which cell is &quot;default&quot;,
-  that is currently selected cell in &quot;choose grade dialog&quot; (use -1 if you don't
-  want any cell to be selected) - again, 0 means first cell is selected.
-  Returns -2 if &quot;Remove grade&quot; button is clicked.
-  &quot;UnderControl&quot; is the control under which the dialog should be displayed. }
-function TMapListForm.ChooseGradeDialog(UnderControl: TControl; DefaultIndex: Integer): Integer;
-var
-  p: TPoint;
-  Item: TTBCustomItem;
-begin
-  if DefaultIndex = -1 then
-    TBXToolPalette1.SelectedCell := Point(-1, -1)
-  else
-    TBXToolPalette1.SelectedCell := Point(DefaultIndex mod TBXToolPalette1.ColCount, DefaultIndex div TBXToolPalette1.ColCount);
-
-  p := UnderControl.ClientToScreen(Point(0, UnderControl.Height));
-  Item := ChooseGradePopupMenu.PopupEx(p.X, p.Y, nil, False);
-
-  if Item = nil then
-  begin
-    Result := -1;
-    Exit;
-  end;
-
-  if Item.ClassType = TSpTBXItem then if Item.Name = 'RemoveGradeItem' then
-  begin
-    Result := -2;
-    Exit;
-  end;
-
-  if Item.ClassType &lt;&gt; TTBXToolPalette then
-  begin
-    Result := -1;
-    Exit;
-  end;
-
-  Result := Item.Tag;
-end;
-
 procedure TMapListForm.CloseButtonClick(Sender: TObject);
 begin
   Close;
 end;
 
-procedure TMapListForm.TBXToolPalette1CellClick(
-  Sender: TTBXCustomToolPalette; var ACol, ARow: Integer;
-  var AllowChange: Boolean);
-begin
-  // we keep selection information in Tag property:
-  Sender.Tag := ACol + ARow * (Sender as TTBXToolPalette).ColCount;
-end;
-
-procedure TMapListForm.TBXToolPalette1CalcImageSize(
-  Sender: TTBXCustomToolPalette; Canvas: TCanvas; var AWidth,
-  AHeight: Integer);
-begin
-  AWidth := 16;
-  AHeight := 16;
-end;
-
-procedure TMapListForm.TBXToolPalette1DrawCellImage(
-  Sender: TTBXCustomToolPalette; Canvas: TCanvas; ARect: TRect; ACol,
-  ARow: Integer; Selected, Hot, Enabled: Boolean);
-begin
-  MainForm.GradesImageList.Draw(Canvas, ARect.Left, ARect.Top, ACol + ARow * (Sender as TTBXToolPalette).ColCount + 1);
-end;
-
 procedure TMapListForm.SpTBXSpeedButton1Click(Sender: TObject);
 begin
   MessageDlg(_('Syncing grades with the server means sending your local grades of all your maps to the server and at the same time retrieving global grades. Grades are accepted only from players with a rank above &quot;beginner&quot;.'), mtInformation, [mbOK], 0);

Modified: Lobby/TASClient/PreferencesFormUnit.pas
===================================================================
--- Lobby/TASClient/PreferencesFormUnit.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/PreferencesFormUnit.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1028,7 +1028,10 @@
   ProxyUserEdit.Text := p.ProxyUsername;
   ProxyPassEdit.Text := p.ProxyPassword;
 
-  HighlightingForm.JvColorComboBox1.ItemIndex := Max(0, HighlightingForm.JvColorComboBox1.Items.IndexOf(p.HighlightColor));
+  try
+    HighlightingForm.JvColorComboBox1.ItemIndex := Max(0, HighlightingForm.JvColorComboBox1.Items.IndexOf(p.HighlightColor));
+  except
+  end;
   HighlightingForm.UseNotificationsCheckBox.Checked := p.UseNotificationsForHighlights;
 
   IgnoreListForm.EnableIgnoresCheckBox.Checked := p.UseIgnoreList;

Modified: Lobby/TASClient/SplashScreenUnit.dfm
===================================================================
--- Lobby/TASClient/SplashScreenUnit.dfm	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/SplashScreenUnit.dfm	2010-03-20 16:42:21 UTC (rev 7438)
@@ -28,4049 +28,3152 @@
     Height = 243
     AutoSize = True
     Picture.Data = {
-      0A544A504547496D616765FEF70100FFD8FFE000104A46494600010201004800
-      480000FFE10FBE4578696600004D4D002A000000080007011200030000000100
-      010000011A00050000000100000062011B0005000000010000006A0128000300
-      00000100020000013100020000001C0000007201320002000000140000008E87
-      69000400000001000000A4000000D0000AFC8000002710000AFC800000271041
-      646F62652050686F746F73686F70204353322057696E646F777300323030383A
-      30353A30312031393A34333A31330000000003A001000300000001FFFF0000A0
-      02000400000001000001F2A003000400000001000000F3000000000000000601
-      0300030000000100060000011A0005000000010000011E011B00050000000100
-      00012601280003000000010002000002010004000000010000012E0202000400
-      00000100000E880000000000000048000000010000004800000001FFD8FFE000
-      104A46494600010200004800480000FFED000C41646F62655F434D0002FFEE00
-      0E41646F626500648000000001FFDB0084000C08080809080C09090C110B0A0B
-      11150F0C0C0F1518131315131318110C0C0C0C0C0C110C0C0C0C0C0C0C0C0C0C
-      0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C010D0B0B0D0E0D100E0E10140E0E
-      0E14140E0E0E0E14110C0C0C0C0C11110C0C0C0C0C0C110C0C0C0C0C0C0C0C0C
-      0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0CFFC0001108004E00A003012200
-      021101031101FFDD0004000AFFC4013F00000105010101010101000000000000
-      00030001020405060708090A0B01000105010101010101000000000000000100
-      02030405060708090A0B1000010401030204020507060805030C330100021103
-      04211231054151611322718132061491A1B14223241552C16233347282D14307
-      259253F0E1F163733516A2B283264493546445C2A3743617D255E265F2B384C3
-      D375E3F3462794A485B495C4D4E4F4A5B5C5D5E5F55666768696A6B6C6D6E6F6
-      37475767778797A7B7C7D7E7F711000202010204040304050607070605350100
-      021103213112044151617122130532819114A1B14223C152D1F0332462E17282
-      92435315637334F1250616A2B283072635C2D2449354A317644555367465E2F2
-      B384C3D375E3F34694A485B495C4D4E4F4A5B5C5D5E5F55666768696A6B6C6D6
-      E6F62737475767778797A7B7C7FFDA000C03010002110311003F00E2EAAE8F46
-      A9AAB24B19AED6FEE8F24FE9E3F7A99FE637FB946B314D43F90DFF00A90A75D5
-      7E4582BC7AACBEC7715D4C758F3DB4AEB0F7A859D1BAAA3B56CFF35BFDC9BD1A
-      BB54CFF35BFDCACE6E066F4FCA3899F43F1F21A1AE353E276B86E638161731CD
-      77F21FFF0007FCE311EAC1B4E1BB301AC56C6976CDE3D4706FBACD947D2DACAF
-      F4BFF9ED1412E77A557FA367F9ADFEE4BD2A7FD1B3FCD6FF0072B36D6D8940E1
-      250606BA87F8367F9ADFEE50736A1FE0D9FE68FEE45712816BA02494767A40FD
-      068FEC8FEE4273D9FBADFB828D8E739C1A04971000F12785A35F436B5DFAD5D0
-      09DA3D3207B889DBEF6BBC10328C47A8AE8C252F945F7737D46FEEB7EE09C58C
-      FDD6FF009A3FB95AC9E8F65740BE978B400E2F0083C13AD67F3FD8A86CB4004B
-      5C0188241D6784E898C86856C84E06A51AEAD81657FB8DFF00347F72931D5977
-      D061804905A2341BBB2AAE1630C3DA5A7C1C08FCAA78EE2E7960126C1B1A4980
-      1D21ECD4FF0051131D2D0262E886CBBD30D6135B402209DA20BA773BB7E6B1F5
-      A62FA870C69FEC8FEE5668C6C1B71996DD9ADC6BBDC1F4D8C2E0D2276FB636B5
-      F6307B16649035047C414C8D1B1AE9E059262A8E9EA1A6B13F6F0FCADA16D47F
-      319FE68FEE4563E9FF0046CFF35BFDCA83C58C203DAE693C6E047FD523514E5D
-      CDDF4D3658CFDE631CE1A79B4144C685DAC06CD56ADF68A0FF008367F98DFEE5
-      3B2BA0516FE8EB0763F69D8DFDD3E4815E2677D9BED86BFD5F6871B3734E84ED
-      FA3BB7FD2FE4A98334D93FE8DFFF0052532F5D0DD1AD179890358D58B17D9FFF
-      D0E26BFE66AFEA37FEA423D199998AC77D86C38F905ED78C8AC96D9B5A1EC38F
-      BDA5BFABDBEA6FB99F9FE9D4ABD47F435FF51BF9029778EC795133EE13D3D52A
-      CC65387983D36B038D4F93351712FB3D1D76FA375BFCE6359B19EAFF0084A2CF
-      D22B18D9F86ECBAD9D40B9F883F446CAC96BEA6B8B672E910CDEEA9ADDCCAEC6
-      FF00C6556FD059606452CA6C7D75BDB734D90C90747BE9FD2B4177BDCEAFF395
-      8E98D6750CF761060A22435E5AEB65FF00E09AE6B5D5FF003AEF6A76DAF659BE
-      9D4BAB6E26374CEA2E75D8EFEA1D31967A6D2D78690D3B2DFD232B6B7D7DD43B
-      F45557F67F57FC15DFA159596DC7AF3AFA71AC37D15B8B59696EC93F49CD6D6E
-      F7B7D2FE6FDEB669EA3894E6B6AEBD680DADAEA2CADB49DCC6B86DAAFABD1B5D
-      EA6454DFD1D6FF00F03FA2F65CB0FABE36563E7598F9555951B1E6C0DBD9B0B9
-      AF3F4F61FD257BFE97A6FF00D252F406AA36183FCF940B78247646634D99CDC4
-      AED6ECB61B5BEE22B634CB773AEB7FC1D4CAF7FE9159EB9D21FD1F2BEC391736
-      CCB6122F656D3B191B7D28B9FB7D5F5B77FA2A50228AE8C810E290E758D6B480
-      E2E01AE980093ED3BBF356E7DA7A8D5ECCAC4F51C080F752E049FE57A5EEFED2
-      C5B58A55F53CDA8001E1DB74697B439C00FCDF53E9EDFED21381981401AEFF00
-      C43263C82176642FF768FDB193B8EC0C3C8A4938EDA5CE69702581AE6900EAF8
-      FDD47B2FB198ED2D3B5C6B0EADE60B584068DC7D4737E832CFFCF8B9E6E6E665
-      3CE3BAC76CBDDEE656034B89D36177EEBBF94B6BAA566DE9E68AC07D8F754CAC
-      7F28B9B58DBBBFADB5579E3319404CDD9F3E16CE3CA251C92C7123847F74CC8F
-      EEA1CAC0BF2B0C5D942BA72AA25D61020168DD265BECFD2FB2CDFF00F935A59D
-      9F46336CB3DD65F8FEF34B6661FA07B896BB6336FF00845CDBEDEA8EA2BC10D2
-      CA4B016D6C006E69FD2FE91FF9DBBE9EC73D12DEA1D55F73AF35865BED2EB1AC
-      035AC39CD12EDECFA2FF007D69C709955CA24024800F0FA654B63CCC63C5C319
-      0948444A44711E28F17ABFBDF2BB3839D979543F22CA194D37FA8E6DAD21CE71
-      0CB3756C6BA6C77A7E9FA9FBFF00F5B51EAF9966358CB5B6586CADCC15FA826A
-      0E2D735EEEFEE631DFF06B22AEABD4E9C6FB236A6ECACBDD0EA412D2F9DEE6E9
-      ECDBBBDBB55BEA3D7F2B3F0DD87F64F4C6E682779741A88F6BEB735BB7E9B537
-      D990C80F0C7809AD0FE87F87FD55C39981C4419C8640011C51F9A7FBA383FAEE
-      E67B19D47A10BB20EE6BAA17BCB0986B9A3DEFAE773BF7FDAB2BAAF4FCE0C755
-      8DEBE43B7362B98ADB501EC6535D6E652F6E8CF6EC556DEBDD61D8670DF5B5B4
-      BDAEA4B8564B8348F4FD2FA67C7D9F9EAC539DD2863B6BAF3B3717688D8D739E
-      1BFBDE97E8FDACFF00313638F263F11C44800718FF009ABE79B166F03C204A52
-      3EDC891FBBC4DCCDA730F48C816B1B46DA98F7EC78717BA59EA6F6ED3E9D6DFE
-      458B21B58F42DFEA3FFEA5CB4B23AD62D988EC4A0DB6EE6069B1ED890390E739
-      CD7EEB63DF6EC545A08C6B279F49E27FB253B0890078857AAD8F99302470CB8A
-      A35FCB85FFD1E1EA3FA1AFFA8DFC811B1E8B327269C5A8B5B6645B5D35B9FA30
-      3AD736A63AC8FF0006D73FDE8357F335FF0051BFF5214839CC70B1BA39843DB1
-      E2D3B9BFF482899DD4FACF84EE9973F17A75C2DC5A6DF45D63835EE716EDB2A7
-      3ECD8D77B7D7D9E9D5FE16AB56361675BD38DB754D2CC97815BAE6B887D6D13E
-      B0ABF95639957E93E9D6CFE6FF009CDEAF757EA96D991731A2BB6CB6D394EB9D
-      3CB839F67A558DACD9B6CF7FFC5ACDB5AF04FACE6BBD46EEDCD83ED70DCD718F
-      66F4F88206AC72209D3B3AD8185D3FA6D183D41D6BFEDE1CEB5B8FA7A6EDA34D
-      967F3945DEFF00D5EDF7FE959EA23F5BCAABAC635590FC8758F6B7D3AACB21A2
-      1BFCEB183E8FA95EFADD755F4FFC37F32A917DD5368B58F6BCE4D218C1639AFD
-      8C78DBB1D58686D5B9BF9EE77A8A833D4639D5EB01C0BEA30439D59966F63A58
-      EDBFF51BEBFCF408BA37A8EAA048B1D0F4550EBDFA6EDB2035F601BFDA08FE6C
-      3BFC26D1FCD6E46CFEA1F6BCA6B9CD7328C7DB5E2B490F7D74D636574BACFA0F
-      B36FF3967E7D9FC8F4D448C5AA1F8E76D7735CEF46773AB783B7D2DDEDDD5EED
-      B656F77F82F67D34BD3AAD1BE209E639946E8DA80B14D703D46EBF4873E7FCA4
-      1B6ADA2568D58D122B6B9EE893024C012E3EDFCD626750D7F3A8299747464034
-      D5C805CD70737420C8215B19DD46F66C36CB41040DADE4196EBB5583D3D878EE
-      9D986EA4EE1C252944F4048DAC5AA11946EA4403BF09E16B97F5174973C99324
-      C3675FECA539A5A06E023B86893FC93A7D15AB4865804728E31DA674D7CD338B
-      C07D8BF86FA9FB5C5DB9AE83BE0EBAF89277CA66D190D0435F0492EEDC9E5CB6
-      8E283D940E301C0E12E2F2570B907ED947B83868081ED022416FE6C7D1DDEC6F
-      D0556A76DD0F0B76EA806190B35B89EA3CC27C65A1B0B48D4526A0B1C0472AFB
-      80FB2DBA7153FF00EA5CAB51842B7032AED8C1F64BC83FE0ACFF00A8728CD5AF
-      B34FFFD2E1EA1FA1AFFA8DFF00A90A5C26A87E86BEFEC6FF00D48525133B1787
-      91EC80E82350383F49BAAAEEAEC24820C9E4F3FF00495A4BB2368310DEE9B8D4
-      66BB2712D7369F5DACB987401B6319FA4782DF76DB2DF5555EA7D33330455764
-      56EAAD71F4EEADDCB2D680F635C7F76EA7F4957F516AFD5EC8C2A5998328B5B6
-      D949FB212E734CB45AF731BB36BBF4AEFD17F3B53FF9C542DEA763F032B1B31A
-      FB45AD60A65CF2DAEFADFBEAC86BF237BBDB47AD8BB7FC363FFC5EF4A37AF65B
-      2AD3BB45D536C01ECD1C44F914F434ED83DF503B8F14B1C835E9D8EBF951444A
-      04F45C075494BDD55ADB1A48730CB7692D3238F737DC9EBACFE739CF77773C92
-      7E6E77B93360A2B02693A2F005AFE90ECA3756EF4C8E61120C404C7E8969E535
-      7396CB5F53F4D15FA73E7470431821CF927447AF16B6A71A5A2D9FDAAB23548E
-      5523BEAAB64E347B99C2A70776D29000A492DACAC9DE21BC20E359B1FAF0AED3
-      8CC3549D6428BF041E394AC6C8A3BB65A18F683DBC535C1A31AF1C7E8AC8FF00
-      31C874B5CCD0990A57B87D9AEEE3D2B3FEA1C9ABBA3FFFD3E22AFE6ABFEA37FE
-      A4292854F3E957FA379F6375F6C71FF189F7FF00C1BFFE8FFE945133B2FE0928
-      FA9FF06FFF00A3FF00A512DE7FD1BFFE87FE94494CDEE3632BADC7DB4926B100
-      439DCBFF0094F54430378E7C55BDFF00F06FFF00A3FF00A5101E6B2F261E04EA
-      006FE1FA44E16B655F5678EE8B20F0ED3E7F9AAC8E65527B9BF98D791E61BCFC
-      9EAD07E83F4764FF0063FF004A205314A0C22B0E8AB8B0C7F3767FD0FF00D28A
-      6DB1D1AD567FD0FF00D2A985782D90E1DD3100910822D77FA2B3E7B3FF004AA9
-      36D74FF3367FD0FF00D2A8526D27D1F92716765175BA6B4D9E5FCDFF00E96433
-      69FF004567FD0FFD2A92ADB0D8708EC557BB101787354996BE74A6C3FE67FE95
-      53F59FDE9B3CFF009BFF00D2C96BD15A754AC6ED681E013E84C7E2842D77FA1B
-      7FF03FFD2C9C5CE8D29B7FF03FFD2C8526D93C089FC557C9D28BA3FD1BFF00EA
-      5C886D7CFF003367FE07FF00A590726D268B66AB01F4DFA9D9FBA7FE1511BA09
-      7FFFD9FFED147C50686F746F73686F7020332E30003842494D04250000000000
-      10000000000000000000000000000000003842494D03ED000000000010004800
-      000001000200480000000100023842494D042600000000000E00000000000000
-      0000003F8000003842494D040D0000000000040000001E3842494D0419000000
-      0000040000001E3842494D03F300000000000900000000000000000100384249
-      4D040A00000000000100003842494D271000000000000A000100000000000000
-      023842494D03F5000000000048002F66660001006C6666000600000000000100
-      2F6666000100A1999A0006000000000001003200000001005A00000006000000
-      000001003500000001002D000000060000000000013842494D03F80000000000
-      700000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF03E800000000FF
-      FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF03E800000000FFFFFFFFFF
-      FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF03E800000000FFFFFFFFFFFFFFFFFF
-      FFFFFFFFFFFFFFFFFFFFFFFFFF03E800003842494D0408000000000010000000
-      010000024000000240000000003842494D041E00000000000400000000384249
-      4D041A00000000035B000000060000000000000000000000F3000001F2000000
-      1300730070006C00610073006800730063007200650065006E00360073006900
-      6D0070006C006500000001000000000000000000000000000000000000000100
-      00000000000000000001F2000000F30000000000000000000000000000000001
-      0000000000000000000000000000000000000010000000010000000000006E75
-      6C6C0000000200000006626F756E64734F626A63000000010000000000005263
-      74310000000400000000546F70206C6F6E6700000000000000004C6566746C6F
-      6E67000000000000000042746F6D6C6F6E67000000F300000000526768746C6F
-      6E67000001F200000006736C69636573566C4C73000000014F626A6300000001
-      000000000005736C6963650000001200000007736C69636549446C6F6E670000
-      00000000000767726F757049446C6F6E6700000000000000066F726967696E65
-      6E756D0000000C45536C6963654F726967696E0000000D6175746F47656E6572
-      617465640000000054797065656E756D0000000A45536C696365547970650000
-      0000496D672000000006626F756E64734F626A63000000010000000000005263
-      74310000000400000000546F70206C6F6E6700000000000000004C6566746C6F
-      6E67000000000000000042746F6D6C6F6E67000000F300000000526768746C6F
-      6E67000001F20000000375726C54455854000000010000000000006E756C6C54
-      455854000000010000000000004D736765544558540000000100000000000661
-      6C74546167544558540000000100000000000E63656C6C54657874497348544D
-      4C626F6F6C010000000863656C6C546578745445585400000001000000000009
-      686F727A416C69676E656E756D0000000F45536C696365486F727A416C69676E
-      0000000764656661756C740000000976657274416C69676E656E756D0000000F
-      45536C69636556657274416C69676E0000000764656661756C740000000B6267
-      436F6C6F7254797065656E756D0000001145536C6963654247436F6C6F725479
-      7065000000004E6F6E6500000009746F704F75747365746C6F6E670000000000
-      00000A6C6566744F75747365746C6F6E67000000000000000C626F74746F6D4F
-      75747365746C6F6E67000000000000000B72696768744F75747365746C6F6E67
-      00000000003842494D042800000000000C000000013FF0000000000000384249
-      4D041100000000000101003842494D0414000000000004000000013842494D04
-      0C000000000EA400000001000000A00000004E000001E00000924000000E8800
-      180001FFD8FFE000104A46494600010200004800480000FFED000C41646F6265
-      5F434D0002FFEE000E41646F626500648000000001FFDB0084000C0808080908
-      0C09090C110B0A0B11150F0C0C0F1518131315131318110C0C0C0C0C0C110C0C
-      0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C010D0B0B0D0E
-      0D100E0E10140E0E0E14140E0E0E0E14110C0C0C0C0C11110C0C0C0C0C0C110C
-      0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0CFFC0001108
-      004E00A003012200021101031101FFDD0004000AFFC4013F0000010501010101
-      010100000000000000030001020405060708090A0B0100010501010101010100
-      000000000000010002030405060708090A0B1000010401030204020507060805
-      030C33010002110304211231054151611322718132061491A1B14223241552C1
-      6233347282D14307259253F0E1F163733516A2B283264493546445C2A3743617
-      D255E265F2B384C3D375E3F3462794A485B495C4D4E4F4A5B5C5D5E5F5566676
-      8696A6B6C6D6E6F637475767778797A7B7C7D7E7F71100020201020404030405
-      0607070605350100021103213112044151617122130532819114A1B14223C152
-      D1F0332462E1728292435315637334F1250616A2B283072635C2D2449354A317
-      644555367465E2F2B384C3D375E3F34694A485B495C4D4E4F4A5B5C5D5E5F556
-      66768696A6B6C6D6E6F62737475767778797A7B7C7FFDA000C03010002110311
-      003F00E2EAAE8F46A9AAB24B19AED6FEE8F24FE9E3F7A99FE637FB946B314D43
-      F90DFF00A90A75D57E4582BC7AACBEC7715D4C758F3DB4AEB0F7A859D1BAAA3B
-      56CFF35BFDC9BD1ABB54CFF35BFDCACE6E066F4FCA3899F43F1F21A1AE353E27
-      6B86E638161731CD77F21FFF0007FCE311EAC1B4E1BB301AC56C6976CDE3D470
-      6FBACD947D2DACAFF4BFF9ED1412E77A557FA367F9ADFEE4BD2A7FD1B3FCD6FF
-      0072B36D6D8940E1250606BA87F8367F9ADFEE50736A1FE0D9FE68FEE4571281
-      6BA02494767A40FD068FEC8FEE4273D9FBADFB828D8E739C1A04971000F12785
-      A35F436B5DFAD5D009DA3D3207B889DBEF6BBC10328C47A8AE8C252F945F7737
-      D46FEEB7EE09C58CFDD6FF009A3FB95AC9E8F65740BE978B400E2F0083C13AD6
-      7F3FD8A86CB4004B5C0188241D6784E898C86856C84E06A51AEAD81657FB8DFF
-      00347F72931D5977D061804905A2341BBB2AAE1630C3DA5A7C1C08FCAA78EE2E
-      7960126C1B1A49801D21ECD4FF0051131D2D0262E886CBBD30D6135B402209DA
-      20BA773BB7E6B1F5A62FA870C69FEC8FEE5668C6C1B71996DD9ADC6BBDC1F4D8
-      C2E0D2276FB636B5F6307B16649035047C414C8D1B1AE9E059262A8E9EA1A6B1
-      3F6F0FCADA16D47F319FE68FEE4563E9FF0046CFF35BFDCA83C58C203DAE693C
-      6E047FD523514E5DCDDF4D3658CFDE631CE1A79B4144C685DAC06CD56ADF68A0
-      FF008367F98DFEE53B2BA0516FE8EB0763F69D8DFDD3E4815E2677D9BED86BFD
-      5F6871B3734E84EDFA3BB7FD2FE4A98334D93FE8DFFF0052532F5D0DD1AD1798
-      90358D58B17D9FFFD0E26BFE66AFEA37FEA423D199998AC77D86C38F905ED78C
-      8AC96D9B5A1EC38FBDA5BFABDBEA6FB99F9FE9D4ABD47F435FF51BF9029778EC
-      795133EE13D3D52ACC65387983D36B038D4F93351712FB3D1D76FA375BFCE635
-      9B19EAFF0084A2CFD22B18D9F86ECBAD9D40B9F883F446CAC96BEA6B8B672E91
-      0CDEEA9ADDCCAEC6FF00C6556FD059606452CA6C7D75BDB734D90C90747BE9FD
-      2B4177BDCEAFF3958E98D6750CF761060A22435E5AEB65FF00E09AE6B5D5FF00
-      3AEF6A76DAF659BE9D4BAB6E26374CEA2E75D8EFEA1D31967A6D2D78690D3B2D
-      FD232B6B7D7DD43BF45557F67F57FC15DFA159596DC7AF3AFA71AC37D15B8B59
-      696EC93F49CD6D6EF7B7D2FE6FDEB669EA3894E6B6AEBD680DADAEA2CADB49DC
-      C6B86DAAFABD1B5DEA6454DFD1D6FF00F03FA2F65CB0FABE36563E7598F95559
-      51B1E6C0DBD9B0B9AF3F4F61FD257BFE97A6FF00D252F406AA36183FCF940B78
-      247646634D99CDC4AED6ECB61B5BEE22B634CB773AEB7FC1D4CAF7FE9159EB9D
-      21FD1F2BEC391736CCB6122F656D3B191B7D28B9FB7D5F5B77FA2A50228AE8C8
-      10E290E758D6B480E2E01AE980093ED3BBF356E7DA7A8D5ECCAC4F51C080F752
-      E049FE57A5EEFED2C5B58A55F53CDA8001E1DB74697B439C00FCDF53E9EDFED2
-      1381981401AEFF00C43263C82176642FF768FDB193B8EC0C3C8A4938EDA5CE69
-      702581AE6900EAF8FDD47B2FB198ED2D3B5C6B0EADE60B584068DC7D4737E832
-      CFFCF8B9E6E6E6653CE3BAC76CBDDEE656034B89D36177EEBBF94B6BAA566DE9
-      E68AC07D8F754CAC7F28B9B58DBBBFADB5579E3319404CDD9F3E16CE3CA251C9
-      2C7123847F74CC8FEEA1CAC0BF2B0C5D942BA72AA25D61020168DD265BECFD2F
-      B2CDFF00F935A59D9F46336CB3DD65F8FEF34B6661FA07B896BB6336FF00845C
-      DBEDEA8EA2BC10D2CA4B016D6C006E69FD2FE91FF9DBBE9EC73D12DEA1D55F73
-      AF35865BED2EB1AC035AC39CD12EDECFA2FF007D69C709955CA24024800F0FA6
-      54B63CCC63C5C3190948444A44711E28F17ABFBDF2BB3839D979543F22CA194D
-      37FA8E6DAD21CE710CB3756C6BA6C77A7E9FA9FBFF00F5B51EAF9966358CB5B6
-      586CADCC15FA826A0E2D735EEEFEE631DFF06B22AEABD4E9C6FB236A6ECACBDD
-      0EA412D2F9DEE6E9ECDBBBDBB55BEA3D7F2B3F0DD87F64F4C6E682779741A88F
-      6BEB735BB7E9B537D990C80F0C7809AD0FE87F87FD55C39981C4419C8640011C
-      51F9A7FBA383FAEEE67B19D47A10BB20EE6BAA17BCB0986B9A3DEFAE773BF7FD
-      AB2BAAF4FCE0C7558DEBE43B7362B98ADB501EC6535D6E652F6E8CF6EC556DEB
-      DD61D8670DF5B5B4BDAEA4B8564B8348F4FD2FA67C7D9F9EAC539DD2863B6BAF
-      3B3717688D8D739E1BFBDE97E8FDACFF00313638F263F11C44800718FF009ABE
-      79B166F03C204A523EDC891FBBC4DCCDA730F48C816B1B46DA98F7EC78717BA5
-      9EA6F6ED3E9D6DFE458B21B58F42DFEA3FFEA5CB4B23AD62D988EC4A0DB6EE60
-      69B1ED890390E739CD7EEB63DF6EC545A08C6B279F49E27FB253B0890078857A
-      AD8F99302470CB8AA35FCB85FFD1E1EA3FA1AFFA8DFC811B1E8B327269C5A8B5
-      B6645B5D35B9FA303AD736A63AC8FF0006D73FDE8357F335FF0051BFF5214839
-      CC70B1BA39843DB1E2D3B9BFF482899DD4FACF84EE9973F17A75C2DC5A6DF45D
-      63835EE716EDB2A73ECD8D77B7D7D9E9D5FE16AB56361675BD38DB754D2CC978
-      15BAE6B887D6D13EB0ABF95639957E93E9D6CFE6FF009CDEAF757EA96D991731
-      A2BB6CB6D394EB9D3CB839F67A558DACD9B6CF7FFC5ACDB5AF04FACE6BBD46EE
-      DCD83ED70DCD718F66F4F88206AC72209D3B3AD8185D3FA6D183D41D6BFEDE1C
-      EB5B8FA7A6EDA34D967F3945DEFF00D5EDF7FE959EA23F5BCAABAC635590FC87
-      58F6B7D3AACB21A21BFCEB183E8FA95EFADD755F4FFC37F32A917DD5368B58F6
-      BCE4D218C1639AFD8C78DBB1D58686D5B9BF9EE77A8A833D4639D5EB01C0BEA3
-      0439D59966F63A58EDBFF51BEBFCF408BA37A8EAA048B1D0F4550EBDFA6EDB20
-      35F601BFDA08FE6C3BFC26D1FCD6E46CFEA1F6BCA6B9CD7328C7DB5E2B490F7D
-      74D636574BACFA0FB36FF3967E7D9FC8F4D448C5AA1F8E76D7735CEF46773AB7
-      83B7D2DDEDDD5EEDB656F77F82F67D34BD3AAD1BE209E639946E8DA80B14D703
-      D46EBF4873E7FCA41B6ADA2568D58D122B6B9EE893024C012E3EDFCD626750D7
-      F3A8299747464034D5C805CD70737420C8215B19DD46F66C36CB41040DADE419
-      6EBB5583D3D878EE9D986EA4EE1C252944F4048DAC5AA11946EA4403BF09E16B
-      97F5174973C99324C3675FECA539A5A06E023B86893FC93A7D15AB4865804728
-      E31DA674D7CD338BC07D8BF86FA9FB5C5DB9AE83BE0EBAF89277CA66D190D043
-      5F0492EEDC9E5CB68E283D940E301C0E12E2F2570B907ED947B83868081ED022
-      416FE6C7D1DDEC6FD0556A76DD0F0B76EA806190B35B89EA3CC27C65A1B0B48D
-      4526A0B1C0472AFB80FB2DBA7153FF00EA5CAB51842B7032AED8C1F64BC83FE0
-      ACFF00A8728CD5AFB34FFFD2E1EA1FA1AFFA8DFF00A90A5C26A87E86BEFEC6FF
-      00D48525133B178791EC80E82350383F49BAAAEEAEC24820C9E4F3FF00495A4B
-      B2368310DEE9B8D466BB2712D7369F5DACB987401B6319FA4782DF76DB2DF555
-      5EA7D3333045576456EAAD71F4EEADDCB2D680F635C7F76EA7F4957F516AFD5E
-      C8C2A5998328B5B6D949FB212E734CB45AF731BB36BBF4AEFD17F3B53FF9C542
-      DEA763F032B1B31AFB45AD60A65CF2DAEFADFBEAC86BF237BBDB47AD8BB7FC36
-      3FFC5EF4A37AF65B2AD3BB45D536C01ECD1C44F914F434ED83DF503B8F14B1C8
-      35E9D8EBF951444A04F45C075494BDD55ADB1A48730CB7692D3238F737DC9EBA
-      CFE739CF77773C927E6E77B93360A2B02693A2F005AFE90ECA3756EF4C8E6112
-      0C404C7E8969E5357396CB5F53F4D15FA73E7470431821CF927447AF16B6A71A
-      5A2D9FDAAB23548E5523BEAAB64E347B99C2A70776D29000A492DACAC9DE21BC
-      20E359B1FAF0AED38CC3549D6428BF041E394AC6C8A3BB65A18F683DBC535C1A
-      31AF1C7E8AC8FF0031C874B5CCD0990A57B87D9AEEE3D2B3FEA1C9ABBA3FFFD3
-      E22AFE6ABFEA37FEA4292854F3E957FA379F6375F6C71FF189F7FF00C1BFFE8F
-      FE945133B2FE0928FA9FF06FFF00A3FF00A512DE7FD1BFFE87FE94494CDEE363
-      2BADC7DB4926B100439DCBFF0094F54430378E7C55BDFF00F06FFF00A3FF00A5
-      101E6B2F261E04EA006FE1FA44E16B655F5678EE8B20F0ED3E7F9AAC8E65527B
-      9BF98D791E61BCFC9EAD07E83F4764FF0063FF004A205314A0C22B0E8AB8B0C7
-      F3767FD0FF00D28A6DB1D1AD567FD0FF00D2A985782D90E1DD3100910822D77F
-      A2B3E7B3FF004AA936D74FF3367FD0FF00D2A8526D27D1F92716765175BA6B4D
-      9E5FCDFF00E9643369FF004567FD0FFD2A92ADB0D8708EC557BB101787354996
-      BE74A6C3FE67FE9553F59FDE9B3CFF009BFF00D2C96BD15A754AC6ED681E013E
-      84C7E2842D77FA1B7FF03FFD2C9C5CE8D29B7FF03FFD2C8526D93C089FC557C9
-      D28BA3FD1BFF00EA5C886D7CFF003367FE07FF00A590726D268B66AB01F4DFA9
-      D9FBA7FE1511BA097FFFD93842494D042100000000005500000001010000000F
-      00410064006F00620065002000500068006F0074006F00730068006F00700000
-      001300410064006F00620065002000500068006F0074006F00730068006F0070
-      002000430053003200000001003842494D040600000000000700080000000101
-      00FFE1391F687474703A2F2F6E732E61646F62652E636F6D2F7861702F312E30
-      2F003C3F787061636B657420626567696E3D22EFBBBF222069643D2257354D30
-      4D7043656869487A7265537A4E54637A6B633964223F3E0A3C783A786D706D65
-      746120786D6C6E733A783D2261646F62653A6E733A6D6574612F2220783A786D
-      70746B3D22332E312E312D313131223E0A2020203C7264663A52444620786D6C
-      6E733A7264663D22687474703A2F2F7777772E77332E6F72672F313939392F30
-      322F32322D7264662D73796E7461782D6E7323223E0A2020202020203C726466
-      3A4465736372697074696F6E207264663A61626F75743D22220A202020202020
-      202020202020786D6C6E733A7861704D4D3D22687474703A2F2F6E732E61646F
-      62652E636F6D2F7861702F312E302F6D6D2F223E0A2020202020202020203C78
-      61704D4D3A446F63756D656E7449443E757569643A3545394638364639413531
-      3744443131424430354444324636374232373131453C2F7861704D4D3A446F63
-      756D656E7449443E0A2020202020202020203C7861704D4D3A496E7374616E63
-      6549443E757569643A3546394638364639413531374444313142443035444432
-      4636374232373131453C2F7861704D4D3A496E7374616E636549443E0A202020
-      2020203C2F7264663A4465736372697074696F6E3E0A2020202020203C726466
-      3A4465736372697074696F6E207264663A61626F75743D22220A202020202020
-      202020202020786D6C6E733A7861703D22687474703A2F2F6E732E61646F6265
-      2E636F6D2F7861702F312E302F223E0A2020202020202020203C7861703A4372
-      65617465446174653E323030382D30332D31375432333A33353A34382B30313A
-      30303C2F7861703A437265617465446174653E0A2020202020202020203C7861
-      703A4D6F64696679446174653E323030382D30352D30315431393A34333A3133
-      2B30323A30303C2F7861703A4D6F64696679446174653E0A2020202020202020
-      203C7861703A4D65746164617461446174653E323030382D30352D3031543139
-      3A34333A31332B30323A30303C2F7861703A4D65746164617461446174653E0A
-      2020202020202020203C7861703A43726561746F72546F6F6C3E41646F626520
-      50686F746F73686F70204353322057696E646F77733C2F7861703A4372656174
-      6F72546F6F6C3E0A2020202020203C2F7264663A4465736372697074696F6E3E
-      0A2020202020203C7264663A4465736372697074696F6E207264663A61626F75
-      743D22220A202020202020202020202020786D6C6E733A64633D22687474703A
-      2F2F7075726C2E6F72672F64632F656C656D656E74732F312E312F223E0A2020
-      202020202020203C64633A666F726D61743E696D6167652F6A7065673C2F6463
-      3A666F726D61743E0A2020202020203C2F7264663A4465736372697074696F6E
-      3E0A2020202020203C7264663A4465736372697074696F6E207264663A61626F
-      75743D22220A202020202020202020202020786D6C6E733A70686F746F73686F
-      703D22687474703A2F2F6E732E61646F62652E636F6D2F70686F746F73686F70
-      2F312E302F223E0A2020202020202020203C70686F746F73686F703A436F6C6F
-      724D6F64653E333C2F70686F746F73686F703A436F6C6F724D6F64653E0A2020
-      202020202020203C70686F746F73686F703A486973746F72792F3E0A20202020
-      20203C2F7264663A4465736372697074696F6E3E0A2020202020203C7264663A
-      4465736372697074696F6E207264663A61626F75743D22220A20202020202020
-      2020202020786D6C6E733A746966663D22687474703A2F2F6E732E61646F6265
-      2E636F6D2F746966662F312E302F223E0A2020202020202020203C746966663A
-      4F7269656E746174696F6E3E313C2F746966663A4F7269656E746174696F6E3E
-      0A2020202020202020203C746966663A585265736F6C7574696F6E3E37323030
-      30302F31303030303C2F746966663A585265736F6C7574696F6E3E0A20202020
-      20202020203C746966663A595265736F6C7574696F6E3E3732303030302F3130
-      3030303C2F746966663A595265736F6C7574696F6E3E0A202020202020202020
-      3C746966663A5265736F6C7574696F6E556E69743E323C2F746966663A526573
-      6F6C7574696F6E556E69743E0A2020202020202020203C746966663A4E617469
-      76654469676573743E3235362C3235372C3235382C3235392C3236322C323734
-      2C3237372C3238342C3533302C3533312C3238322C3238332C3239362C333031
-      2C3331382C3331392C3532392C3533322C3330362C3237302C3237312C323732
-      2C3330352C3331352C33333433323B4641454543443632423638463644324130
-      3232423842323736434235344342423C2F746966663A4E617469766544696765
-      73743E0A2020202020203C2F7264663A4465736372697074696F6E3E0A202020
-      2020203C7264663A4465736372697074696F6E207264663A61626F75743D2222
-      0A202020202020202020202020786D6C6E733A657869663D22687474703A2F2F
-      6E732E61646F62652E636F6D2F657869662F312E302F223E0A20202020202020
-      20203C657869663A506978656C5844696D656E73696F6E3E3439383C2F657869
-      663A506978656C5844696D656E73696F6E3E0A2020202020202020203C657869
-      663A506978656C5944696D656E73696F6E3E3234333C2F657869663A50697865
-      6C5944696D656E73696F6E3E0A2020202020202020203C657869663A436F6C6F
-      7253706163653E2D313C2F657869663A436F6C6F7253706163653E0A20202020
-      20202020203C657869663A4E61746976654469676573743E33363836342C3430
-      3936302C34303936312C33373132312C33373132322C34303936322C34303936
-      332C33373531302C34303936342C33363836372C33363836382C33333433342C
-      33333433372C33343835302C33343835322C33343835352C33343835362C3337
-      3337372C33373337382C33373337392C33373338302C33373338312C33373338
-      322C33373338332C33373338342C33373338352C33373338362C33373339362C
-      34313438332C34313438342C34313438362C34313438372C34313438382C3431
-      3439322C34313439332C34313439352C34313732382C34313732392C34313733
-      302C34313938352C34313938362C34313938372C34313938382C34313938392C
-      34313939302C34313939312C34313939322C34313939332C34313939342C3431
-      3939352C34313939362C34323031362C302C322C342C352C362C372C382C392C
-      31302C31312C31322C31332C31342C31352C31362C31372C31382C32302C3232
-      2C32332C32342C32352C32362C32372C32382C33303B32304141373538344642
-      444631373538423741354236353231464341304236453C2F657869663A4E6174
-      6976654469676573743E0A2020202020203C2F7264663A446573637269707469
-      6F6E3E0A2020203C2F7264663A5244463E0A3C2F783A786D706D6574613E0A20
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020200A20202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020200A2020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020200A202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020200A20202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020200A2020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020202020200A202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      200A202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020200A20202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020200A2020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020200A202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020200A20202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020202020200A2020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020202020202020200A
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020200A202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020200A20202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020200A2020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020200A202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020200A20202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020202020202020200A2020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20200A2020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020200A202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020200A20202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020200A2020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020200A202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020200A20202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      0A20202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020200A2020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020200A202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020200A20202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020200A2020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020200A202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020200A20
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020200A20202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020200A2020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020200A202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020200A20202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020200A2020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020202020200A202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      200A202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020200A20202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020200A2020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020200A202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020200A20202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020202020200A2020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020202020202020200A
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020200A202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020200A20202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020200A2020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020200A202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020200A20202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020202020202020200A2020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20200A2020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020200A202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020200A20202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020200A2020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020200A202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020200A20202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      0A20202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020200A2020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020200A202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020200A20202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020200A2020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020200A202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020200A20
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020200A20202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020200A2020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020200A202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020200A20202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020200A2020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020202020200A202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      200A202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020200A20202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020200A2020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020200A202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020200A20202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020202020200A2020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020202020202020200A
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020200A202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020200A20202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020200A2020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020200A202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020200A20202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020202020202020200A2020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20200A2020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020200A202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020200A20202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020200A2020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020200A202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020200A20202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      0A20202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020200A2020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020200A202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020200A20202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020200A2020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020200A202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020200A20
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020200A20202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020200A2020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020200A202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020200A20202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020200A2020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020202020200A202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      200A202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020200A20202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020200A2020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020200A202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020200A20202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020202020200A2020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020202020202020202020202020200A
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020200A202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020200A20202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020200A2020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020202020202020202020202020200A202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020200A20202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020202020202020202020202020200A2020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20200A2020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      202020202020200A202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020200A20202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      2020202020202020202020202020202020202020202020202020202020202020
-      20202020202020202020202020202020200A2020202020202020202020202020
-      20202020202020202020202020200A3C3F787061636B657420656E643D227722
-      3F3EFFEE000E41646F626500644000000001FFDB008400010101010101010101
-      0101010101010101010101010101010101010101010101010101010101010101
-      0101020202020202020202020203030303030303030303010101010101010101
-      0101020201020203030303030303030303030303030303030303030303030303
-      030303030303030303030303030303030303030303030303FFC000110800F301
-      F203011100021101031101FFDD0004003FFFC401A20000000602030100000000
-      000000000000070806050409030A0201000B0100000603010101000000000000
-      000000060504030702080109000A0B1000020103040103030203030302060975
-      0102030411051206210713220008311441322315095142166124331752718118
-      62912543A1B1F02634720A19C1D13527E1533682F192A2445473454637476328
-      5556571AB2C2D2E2F2648374938465A3B3C3D3E3293866F3752A393A48494A58
-      595A6768696A767778797A85868788898A9495969798999AA4A5A6A7A8A9AAB4
-      B5B6B7B8B9BAC4C5C6C7C8C9CAD4D5D6D7D8D9DAE4E5E6E7E8E9EAF4F5F6F7F8
-      F9FA110002010302040403050404040606056D01020311042112053106002213
-      4151073261147108428123911552A162163309B124C1D14372F017E182342592
-      53186344F1A2B226351954364564270A7383934674C2D2E2F255657556378485
-      A3B3C3D3E3F3291A94A4B4C4D4E4F495A5B5C5D5E5F52847576638768696A6B6
-      C6D6E6F667778797A7B7C7D7E7F7485868788898A8B8C8D8E8F8394959697989
-      99A9B9C9D9E9F92A3A4A5A6A7A8A9AAABACADAEAFAFFDA000C03010002110311
-      003F00D44BA2FA43AB379757EDCDC5B8F6CB643315EF985ACAA19ADC144B28A5
-      CFE528E9C0829325052A94A6A754F422DF48BDC92482B7ADE770B3DC66820940
-      8869A0A2FE200F161D0F366D936CBBDB6DEE67B7ACA7554EA71C1C8F260BF0F4
-      2C3FC61E9560346CEA84D4A4D97706E9717BA69637CC585816F4B303ECABFAC5
-      BA7FCA5FFC613FCDD1B7F57365FF009451FEF6FF00F417519FE3174D5BD3B4A5
-      461A87AF3FBA34BDB80F66CBA3A827DA88B7CDD9F586B9FF008C27F9BAB2F2DE
-      CA7FE21FFC6DFF00E82EA137C6CE9A4FD7B4E402E5401B87727ABD4079349CCD
-      FEBF5B37E91EEFFBF773FF007F8FD89FF40F5EFEADEC83FE22FF00C6DFFE82EB
-      A6F8E1D2D752368B693E4217FBC3BA4392A2E17F732E8178FEBF5F75FDFDB97F
-      CA4FFC613AD7F57364231687FDEDFF00E82EB91F8D7D3655AFB4ECF65641FC7F
-      7493EAFD4250B9701747FB48FF005FDEFF007EEE7FEFF1FF0018FF00A07AF7F5
-      6B65FF009433FEF6FF00F4174D52FC75EA18B584DA92B9074EA39FDC4A2C41F5
-      20198D6EBFEC3DDD77CDC7F1DC0AFD89FE6E9B6E5BD9EB8B634FF4EFFF004175
-      0E4F8F5D462C0ED86524AB1299EDC4E40371E37BE574C641FD44FD3DE977BDCD
-      A42BF518FF004A9FE6EAADCBBB32A863063FD33FF9FAC351D01D46AEAA9B61D0
-      58EABE7B71B8173F51FEE54692BF806DAAFED48DDF72A66E3FE32BFF0040F49A
-      4D87690DDB6E34FF00A77FF3F51DBA17A9C7076B9550A796CF6E040FC055620E
-      5C9BB1F5587FB1F7BFDEDB87FCA47FC657FCDD53F716D9FF0028FF00CDFF00E8
-      2EB0B7417549FD3B6A425491C66B3FA581FD3ABFDC9B11CFE6FEFDFBDB70FF00
-      948FF8CAFF00D03D6BF716D9FF0028E7F6BFFD05D725E85EA50AC24DB2C1C302
-      7FDFC1B8350FF685B64C8E7F3A96E2DEF4777BF1C6E7FE32BFF40F5EFDC7B5FF
-      00CA39FDAFFF00417590F41754E8BFF75D85AF72737B8AFCDBF4FF00B9455600
-      7FB4DCFBDFEF6DC3FE523FE32BFE6EB7FB8B6CFF009473FB5FFE82EBDFE813A9
-      2C2DB6B5B68058FF001EDC36170DA4F197FF0053636FF61EFDFBDB70FF00948F
-      F8CAFF00D03D7BF716D7FF0028E7F6BFFD05D74BF1FF00AA3F4FF766567D1703
-      F8DE7813A555E4900FE2DEA4500FF4F7EFDEDB87FCA47FC657FE81EBDFB8B6BF
-      F9473FB5FF00E82EBA4E88EA0657036C4C645D45917379F934E9F495046582DB
-      5FFB55FF001EFDFBDB70FF00948FF8CAFF00D03D6FF70ED9FF0028DFF1B7FF00
-      3F5D7FA07EA66D36DAAE74A956B66F710BB03FAAFF00C5ADE91F5F7BFDF17FFE
-      FEFF008C8FF3755FDC5B67FCA39FDAFF00F4175DFF00A02EA73AD46D9F5D8103
-      F8F6E3161C5BFE5E2D7D441FF5BDB3FBDF73FF009491FB13FCDD3DFB8767FF00
-      947FF8DBF513FD03F56A162DB5CFA8B08C1CEE7DAEB6E1814CB1D4A3FDBFB73F
-      7B6E3E73FF0025FF00A07AA3EC7B4838B6C7FA77FF003F59E2E87EA87D2836BB
-      160CBAD9737B8C9BDAE021FE2A01BEA1EFC776DCA86931AFFA45FF00A07AF26C
-      7B416CDBE3FD33FF009FAF0E88EA43EAFEEBB83E56529FC7F3E4044245F58CB1
-      B936F50FAAFBA9DDF731FE8DFF00195FF374EFEE1D97FE51CFFBD3FF009FAC2F
-      D13D4CA87FDFBBEB4F532AE773CEC5031D5A1465ECCD61FEAADEF5FBE773FF00
-      7F7FC657FCDD59797F67201FA7CFFA77FF003F514747755B73FDD899355CAC6D
-      98DC224D2AD72E07F132594060B7FD37F7EFDF3B8FFCA40FF795FF00A07ABFF5
-      7367D5A7E9F3FE9DFF00E82EA3CDD1FD5AAA0AEDF60DA55C20CD675DE45D5201
-      753925B163A435BE963EFDFBE772FF007F7FC657FE81EB479776707FDC7FF8DB
-      FF00D05D445E92EB7925544DB8C2E88DC66335652069944EDFC5E4118690F160
-      5B4DBD3F53EF7FBE6FE9FEE467FD2AFF00D03D32360DA8B556D18A57D5FF00CF
-      D44A9E96EBB8BC7E3C11BB392CA73196D0637F4A888B65035E32C58DEC6CB7B1
-      F7A5DEB711FF00127F92FF00D03D3AFCBDB40CAD91A7FA77FF003F4C52754F5E
-      33398B08226B14FB56CAE65C865B488E24FE2492319917F415F483FD7DB9FBDB
-      70FF00948FF8CAFF009BA63F706D5FF28C7FDE9FFCFD374FD69D7B0EB61836B9
-      412787F89660B47AC5C4609C890CA14DEE796FC7BD7EF6DCBFDFE3F62FFD03D6
-      FF00716D5FF289FF001B7FFA0BAE23AD761110AFF000B278BC8C3F8C650ACD70
-      A135BB57698D7516F4A3076D3FD9F743BC6E2326E3FE32BFF40F4AD7977662B5
-      FA3FF8DBFF00D05D427EBAD861A41260DA02E643084C9E59A3454D2CD791EB5C
-      5957E81B920FD78BB6BF7C6E5FF2938FF4A9FF0040F5AFEAF6CD5FF70F1FE9DF
-      FE82EB1275F6C2F0AC830724AB2FA55BF8A64F5C7A65D0CCE82B90296078BF1F
-      9FA7BAB6F3B98E173DDFE953FE81EBC797B66E02CFFE36FF00F41758CF5FEC36
-      D03F86C28A438063CAE5247D6ADFDB06BFC6A481CFD02FE9B96F751BCEEBE739
-      FF00794FF375BFEAEECDFF002867FDEDFF00E82EB14FB1F61AABBA61CA00A232
-      F164F272C61D83286567C86A668DBF1FF05E3F3EECBBC6EB541F51DDFE953FCD
-      D6872EECA450D9FF00C6DFFCFD711B0364308665C607468DDCC4F94AF404B5CC
-      71F97EF146A5BFF648FF0011EF4779DD46A1E3E6BFC0BFF40F57FEAE6CB5FF00
-      7147FCE47FFA0BACD1EC2D88F2143878D6C35B87CB651FD5C318E254AE62CC0A
-      D89B9D57E3DE9B78DDA95FA9FF008C27F9A9D7A3E59D9C9A3599A7FA77FF003F
-      5CDFAFB62C6EA1715F74A19B507C8E542A292ABFBAF157462308DF8F51D3FDA3
-      6F7BFDF3BA104B5C53F24FFA07A77FAB5B17036743FE9DFF00E83EB2AEC6EB97
-      D0D1E1342FAE390364F2EEEAE8037996D911641723E87D6A07F6BDD7F7C6EEA2
-      A6E6BFED53FE80FF00375B1CB3B17E1B5AFF00B77FFA0BA90FD6BB0D18AAE23D
-      414B00F94CA588249059FEF2CA405B28D1FF0006F7A5DF3751C67CFF00A45FF3
-      75EFEAC6CBFF00285FF1B7FF00A0FA95FE8D7AED9F47F01914948D51972D9675
-      F319543A1FF2E27D10DFFE0CDA401CFB65F7DDDD462E73FE913FE81EAADCAFB3
-      69AA599A9FE9BFFD05D4A4EB1EB769103E15D84921559172799D175F53202722
-      9AC95F4A5BF57FAFE9F6DFEFEDEBFE5207FBCA7F9BAA8E5AD9B4D5ACCD7D75BF
-      F9FAC6DD61D752445A1C4B472178C2A1AFCD7917593E952D92656000E4E9363F
-      EDBDED3983780DFA972BA7FD2A7F9BAB0E59D918E6D31FE9DFFE82EBA7EB4EBC
-      8919DB071B00554EACA67E231EB67373235670C9A2D629AADEDD1BF6EAC7B6F7
-      BBEC4FFA07ADFF0056763AFF00B898FF004EFF00F41F599BAC3AE2EC5302F222
-      84763165334DA158FD1D1B22182D835FD448D3EEBFBF776A7FB982BFE913FCDD
-      7BFAB3B27FCA267FD3BFFD07D2966F8FBB7E2C3D6666B36ED0E162A4A1A0CBFD
-      8E6B7357E3F2D598FCB54474F8B6C261AA724991CAC75B2EA0AE8854047D4E34
-      FB2E5E759DEE62B58EEDE577774AC710744641A9C3BA8D0847A16AE476F47FFE
-      B6B6E96577B85CD8A410C71A49A2598C723A48688618D9F5C81F3A4814ED6A91
-      D763A0F677F70577E4B8DA2868EB32D1E1F154516573B5590A8AA33E423669FC
-      75E94F494FE1C5CF20327A9B401FDAD5EF639CAFDB781B3A33B4C23D6EDA1022
-      8A2F0C558D5C0F97577F6DF6C8F9753992458C5ABCA2344D7297672CE339A20D
-      31BB65B38C67A4B8EB1EBC8CB99B085A2FB7322F8B279759012E885DE36C9BB0
-      08E6C7F1F437FA2FB31FDFDBA6AA7D6777FA54FF00A07A21FEAA6CFF00F2807F
-      DEE4FF003F525FAA7AEA03199300ECBAE2F2B8CB65D6352EC1444C0E484ABAFE
-      B7FA8BFBA7F58373AFFB978FF489FF0040FF0093AF7F55765FF9443FEF6FFF00
-      41759D7A9FAF22B34FB7580D3A885CD6717493A8B35DEAEE881578D43EB6E4FB
-      DFF58374AD7EB7FE329FF40F4D9E59D9380B4FF8DBFF00D07D658FAB7AD25D25
-      B6B4ABFA88D398CDB4732A7EAF133E4A25084B2AEBE7FC07F4F36FFBA2F1BA34
-      FF004A9FF40F5BFEAC6C80D0D9FF00C6DFFE83EA6C5D4FD56F48B3B6DE52247A
-      8492A1B359FF00DA78CBA284863CA83231920707D205F8F6D3F306F41DFF00C6
-      7FE309FE6EAA796B630401679FF4EFFF0041F595BA83ABDF9876C95F1233B97C
-      E67D19C7FBAFD2D926589A460D6BB7F67E9EF71F306F341AEE0FFBC27FD03D58
-      72C6CA6A7E909FF6EFFF0041F58D3A7FAD196391F6D88A03A51E59735B81434A
-      6D758FFDC8580175B963617FF63EEFFBFF0074F3BE5FF794FF00375A3CB7B101
-      56B33FEF6FFF0041F5C8F4FF0058860176FC8F26AB340D9BCCB2C4851BC52122
-      BD183BBDB8E56D7F7BFDFF00B99F82F3F6A27FD03D51F96B6406A2CFFE36FF00
-      F4175923E9EEAB1394A8DBD2C4108B08B2F9E9439E14807F88071EBE07AAFF00
-      E1EF5FD60DD860DC1AFF00A44FF3755FEADECD5FF70F1FE9DFFE82E9FD7A33A9
-      DBC727F76D8AC8E34C699BCF93E32E175C80654B051F4E0DF9FEBEDB6E62DD85
-      34DD83FED17FCDD53FABBB3FFCA20FF7B7FF00A0FA78A6E87E9CA87655DAC5FC
-      7200562CFEE4292DA3B8504655A51AF50FAA820FFAFEEBFD64DDFF00DFFF00F1
-      94FF00374F0E5AD9695FA23FEF6FFF00417524F4174D2899C6D173184D485F71
-      6E18990BB2801C3665997C645B95E49FADBDEBFACBBBD69E3FFC613FCDD7BFAB
-      3B2FFCA27FC6DFFE82EB341D09D32CD3793664CC8A3FCE1DC3B920085D1182DD
-      F2E4BAA44F727FC3FDAADEEDFD62DDFF00E5247FBCA7F9BAAFF56B65040FA3FF
-      008DBFFD05D4A83E3D74BCB24606D299A328389B3DB954F01AF29299C4D51CA4
-      695B5B95B7BF7F58B77FF9491FEF29FF0040F5BFEAD6CBFF00289FF1B7FF00A0
-      BA969F1BBA835A8FEE6B49E49B4E84DCBB987843AEB8D54B65C972C83D5A97DE
-      BFAC9BBD69F51FF194FF00375EFEAD6CB4A9B4FF008DBFFD05D4E83E35F49C91
-      A8FEE7BB382CCF6DCFB95BE86C2CA32EA0072A47D6FF004F6CCBCCDBCA9C5CE3
-      FD227FD03D6FFAB3B2FF00CA21FF007B7FFA0BA701F18BA4D44E1F664CB2441D
-      EEB9FDD86231F883F0EB9D326AB9B0F4E93EDB5E66DE6B9BCC7FA44FFA03A723
-      E56D989D4D607453F8E4FF003F552DEE57EA26EBFFD0D583E334BA3A63672955
-      21E4DC5196E4B10774E5D9A3FC5B8E7DC77BFC4CDBADCB07E253FE383A94F969
-      756CB6941FC7FF001F6E8774C8280114E90C142F0A1901B9466B925C5BFD7F64
-      7E137C3E263FD5F3E8E8D0BD0F0EB0D5648E9BB388E34B840491233B35B4AA82
-      54A3B73CFB7503474038F562747CFA6DA813A94F3306D6B70E86E200A09F1B85
-      FC71A78F7E14EA841F88F5E57B0B4855B516E48560F7BD85D975597571FA58FB
-      F71EB4ADA7CBA945E3BBB9BA0FCD8C6E158D958247A96D1D97FB4CC7DFBAD960
-      4750A60A0C9767D56E58AE8FD27511E3B7A934B7D3DFABD57A60A9B4DE3D322A
-      5DA537D405D1A4F43FF8FF004D3F51A7DAC8E3D0CADA8F4DC8BAD680E7A6E92C
-      864BD800D7B58946E2FAEFA89D5F4FCFB5208201A748DA3086941FEACF50D258
-      BD3A897F21531905DEE1C71FF05517E07FBCFBDF5BFB7AE2D1EA52C19B527A4D
-      871A94AB2860A17905BDD95752920F4D3BD303AE0EC217768CACBE44F0BC7F5F
-      D2412DFDAE7F1EF4C9A07C7D5037757AC914E8CBA8B10E8A2F7D29CDB4FD08B1
-      B1FAFF00AFEF5D28EB89775D2486B92AB0AC5A7522B92D19019542071CFE7DEF
-      AF75E62EC9AB5AC72B12815C862157D4EDCE9B91FEF36F7AEBDD63560FA66B80
-      C9656BFEDDBC57F2148EEC4923F573EF7D7BA91A44B65297D6AC59C300C56C18
-      A6ABA8BF3FEABDEBAF75DC6A218F47905D47A895553C9D20B1B922E469FE9EFD
-      D7BAC1288D8353C8CD1170159635D5617361AF432DADFD9FD43DEFAF75899648
-      1DBC75454C6918913D2DFB62E9A7D1EA2181FC7F4F6E789FD1E93786FE9D4776
-      7BBB2D8794695D48AE10ADC35879003E4B03C9D42FEDB6EE3AA99E9475005478
-      9D8385B369919592CC5D6C163B465B57D6F653EAFEBEEA45450F4E2B15351D60
-      92A9E1576265D40E9FB88E541ABC96FDE68A62E025BEBF55217DD3C3FE974E78
-      BFD1E9BAA6A125919188014EA709248628F59BB28915B4DD745F481EAD36FA73
-      EECABA6B9EA8CE1E94E1D408AA0C4A55A58995A6018189D2448E43106257C814
-      BD383AED7FA7D3DB4FF11E940C2A7D9D3757574728084931283AA4678D2E9202
-      43B87883696D41432EA3AD7FC3DD720F5BE925575024B8705638DA22B24B10B3
-      A98D546B476114AC743817FD4CE79F4FB7D4514749A4F8CF4CF35653CB1B543C
-      CA25473768448EB259F42684658C09597F1A342FE09BFBD9A834A75B44D409AE
-      7A699728E09FDD1FBC4D54C48656548E32C63677FA4C86EDA57D1EFCB1D6A7CF
-      87FABE5D295ED14F953A6819574558A398BC8BA1BC9AE178F59FCC9AACB33B07
-      F53FF5FF007877C1FC4D1F6FFB6EB64A019E3D42391011272648E4F5EB56FEB6
-      62A2E1191C961AAD7FA8F6E782FACC6AB44FF57FD13D6BA6F9321A4128ABE711
-      025C28BB06FA1728ADE62355D8D87A7DA85B7A940CFF00A7ABFD5FE97A6DA60B
-      A80F8BA8F0E65E9CB155511B3EB5556217D402B4AA8C154339406C7D4ACBF5FA
-      FB71EC432A03F1FF002FF4BD326E0E09034F52BF8C49204B54CC3482197D3625
-      646B05D0A8648F4B9FAE953FF20FB6BE8C2EBD48BFEAFF009FBA744D1B6734EB
-      A6CBEA2248D21546297D2C4858ED6E0B5EEF7E0003E9FD7EBEFDF4856A0935FF
-      002F4E2DEA15E234FD9D4AA7C890C11E30D0CAF2B093579E68F825A18D493C4A
-      C4B32706FF00ED5EDA7B6C6A0FDE29F207E7FECF566943F7D7B7A986BBC93073
-      1BB4736B43A2366F09130B8F1992FA597FD7FA69F6CF83A405D791F3E3DBD391
-      53553CBA93166D55CC1347ACCD77568DD7F7106A7857901D497D3AAC6E08BF3E
-      EAD6A48D6BF87FD47FD8E94789A8E9D39EA747962F1FA563F142E9A3C5298AE5
-      4C2ADEA93487489118295D4C1803EDA30E96F3D47E5FE6FE2EAC9F08EA40CCAA
-      A14924D00922133933481ECCEE75CA18491A48C78D23529D57B9F6DF80598119
-      F5EAD4CF1CF596795A768CC73A539A78E1F0CCC8DE499A6B30275F3242EE8755
-      CDF4DFDB48A1077256ACD51FC34FF2F4C900706AF52FEED2591C9A9D214042A1
-      D1984BAF52DC3A3248D228B8E6C07D6DED931305AB2573FCBFD8E9F4B712296D
-      7D65C2475D96CF6276FE369BEFF259CCA5262E82189A2A6F2D5D7BA41470192A
-      664A48C3BB8D523A582AEABA8E3DD6E9E1B5B4B9BF9DF4C10C65C9CB60649A01
-      ABF207A7F6BB29B70BFB4DBADD35DCCF20441DA2ACE7481A9BB47DA7038F5377
-      3E7F725564A37DD1959B38D8893218383213D5BD5D22FF000EAB9EA2A6968B2E
-      15DEAE1A5AEC93B1642E544C9A7482BEF5B7DA582427F77DB08CCBA2428168DD
-      E0052C9F875041E9C0F9EAE966EF3EE72DC27EF3B833BC1AE10E5B58A23B1204
-      9E6A1DC9F88FC43CB4F4B696BEAE4E9BC7C93878923EC08E969031824F2D2D1E
-      D3ACAA827D113EA67926CAC9AC94D63FD51BFB29489139A6654CB7D154F11426
-      6029FEF28BD1FC9E24BC956FAF0BFBC9517FD225BB907E2F591AB5E900B938DE
-      2E4C9E60AADE5B466430B15966658C48A7F7C2FD47F679FCFB3868489057E1FF
-      009FBA0E46BA0683461D3CC7554C648A51218608D99E26599BC9E024984302A1
-      75EB520FAD9BDA531B7AD5FEDF2EA9245E276D749EA5FF0010568CCD78E4D21E
-      328CB21D4A48D6123217F701522CC09E47E2E3DD5558322B71E985B7D3F8CF4D
-      B555D242CFE099F4CB143AA09436948A31AF420921D31683723907FA9F6FFF00
-      6A486FE2E99B887484EFFC5D41977032B05856F3470C9A9E22C3C91AFA92368F
-      D572AC5B4FA757E9E7DA94B7206A2748E99115017F219EB98CD28B4AEE4B98D5
-      A689446914C247624B16532A335B547600E8F7EF089A02BDBFE0FF00579F5AF1
-      89CAA74E70EE38DBC892552D3C92848DE5337FBACAB33B279964910307D0AC05
-      ADE9FE964CF6CE7B829A7D9D35DAE40EA4C999A52CE5252B22DB5C8891C72079
-      9C4764D3601EEBC97E3DD2389A998F1D6B4AF01C7A95164638E522692C29CA47
-      A6611B0326A256A59E16608D3270B7FA7FBD5DD4E8D2981D5401E7C3A5252648
-      2B24E4F835BE8703C01D8DC9D21FF7350709FE0AC7DA554C851D3A5469A7974F
-      0993934978C48743A4DF6EC85911CCDE317B28E4C6ABE82E46AB73C5BDD4A824
-      3798EB75A74A286B98D9BC81C471BC53111FDC2812322A281ADCC92AB8D446A6
-      B007DE91C35719E9447119037A8E9DA16FBA55958C7098F55E312C8F1A425D0C
-      8CE924AD7926117E92D605469E3DDABD39F4DF875E7ECE9CE19649079E3903A4
-      D199008C07D0C8D1BB4B512894BA00556D706EFF005FF5418698A9228283AF7D
-      2B7F10AF4E4C6A3C0D118C8134A88EB148F1BEA0FA8B942AAE0BC6DCB7A5831D
-      5EF5F523F83AF0B46A8AB8A74F5455063AA4874E8F2C72491C5E9642A4044428
-      02B33C720F57EAD3FEB7BB05F1FBB850749E54589B4F1C74A09253E19E23A245
-      31BB88C5D34BB28564865F48D0DA2EFEAD3F9F6CF729AF983D2959891A02571D
-      50FF00B9D3A807AFFFD1D563E384D10E93DA092E93A65DC2ABC5ED7DCF9860B2
-      7F4B31D40FE3DC7DBD1FF76B79A8761D1FF1C1D4A7CB6C06CD68357F1FFC7DBA
-      191AC7521B5B4C60C91FEA60AD6D44EAB305D37078FA7B251D1B939AF58A0651
-      A5882EB259524790B3155E35692A4C4C7FB2ABFD9F7EFB3AB2904F7F58DD9F4C
-      9A9F4AB6A01B502DA6CBA5AD6D1AD4FB7D1199D35263FE2FA66563E1B046C74D
-      114D324935A469AC1B5A329647552DE240F2EB2591C6AF4FE7DABF0A3FE01D24
-      D6FF00EFDFE67FCFD6715A63455627546E6CFE55756049F2B5D8AC9214D47FB2
-      D6F6DF843FDF7FE0E942B81C64AF5DC95692C1A19CCB06968E28FF00CE6A4F21
-      50C41B38B30BFD1755FF00AFB6A489B5555314EAC254A0AB7FABF674D92D710B
-      2247E27602C86356F22A95B2801F511C7F40B63ED4229AA74D4920A00AF9E9B2
-      69E52744EA7487402C83F4844F111A18B1E7FC3DBDA0F0D3D25320AF7C99EBAD
-      43C68CE8752BDD8A8D255FFB297462547FA91CE9F7ED327F07F87FCDD6BC54AD
-      75E7D3A9305234AF76D41FD248B0074B02F6D4757057DBD129150C99E934AF9D
-      48F8EA5AE2CB31162C8C4DBD49C9B58111E961ABF1FAEDEDD2148A11D33E3900
-      90FD657C5C905CBAA8672DA848962AA08B10E3483A3DB6618FC901EB62763956
-      C74D0EC63755F1A92A412D15C97563AC3164202AEBFAFF00C47B6E4D1A714AF4
-      B750D54F13FD5FEAF975C7F5AEA561229D520B863A4966B850D620F3FAB57B6F
-      A714AB12CBC7AC5A0C6E920D0E4302B1E9503D7C330616D4B76E3FD7F7BEAFD7
-      6AE1079111946A6FA7E961AD90692352F1F5FAAFBF75EEBB546672522672DC11
-      1BAEB49038B2E96D3707EA7FA7E3DE8F5460CD4D27A906F66123D8A8245EC021
-      B7D00D3F5247D4FD6DEFDD78AAD2AE73D452E57548A2216BA6BE4B1553E900D9
-      7F5DEF65B0F7EF9F5BC7C5F2EA0CB1DE30EAA667692EAD135F96627C8F1EAF52
-      46C3D3A6FC7BD54569E7D5150B1D47874DF2066D4408C0465923FDFB242C55D3
-      537E9FDCD5C68D25BFDE3DEFA76A010BD36D401F6E637948959154C509282309
-      22822498AB24C08D5FED56D5EFDD7800B81C3A6A9AA6E8923A889957D7182082
-      A640CCACE4B0309279B2B5F8FC7BF75EC629D27CD6CBF70490B1A485BD5259E3
-      78D6CA117FCD6AB07616B6A6F7534CFF00153A750B5554B63A61C8B9F5F88957
-      591F931ABEA8CBC6AB6491C4BA05BFE4EFE9FA9B5D39AF4A25D7D9A3E1A7FABF
-      D43A60ADA910C513C46569256BB2BA005A552DE60D228640FA810D7FF523F48F
-      77009D43CBAD68561429DDD26E7CA3060AC413A90908638E755F510A86E5B41F
-      F0FECFB54905456B8FF8CF56A0E992A733E6FA8D550AC63768894091B3901550
-      9D161F437B86FCFD4FB5915A52B5F83E7EBD32665A10996E9A25AF05A4B84121
-      B08CA2EAD0FA4B370C174EAD1CDBFAF1ED4A41F069F87FD5FEAFF0F4964B8A01
-      5ED3E5FE9BA866B6F13AEAD31AB23B026E6E392C970093FF0006F6A1600A6BE7
-      D30D72BA1CA9C79F50C5670EDA8EB234B7A9F505BA9B1604AF36FA8F6E78429A
-      7F0F490DEA9573F8C2FCFF00E89EA33D533BDDE46550AC74DCF2875717E6FACB
-      7FBCFB70262A1493D3325E12C75BE95F4FE8FF00B3D796B79F484D26DACEA249
-      50A058DC693AF57BB184D2A6B5EB4B7E0BD51574EACFFABF3EB347541CD9B483
-      60DA941409A4593F4F0035C7E34FB6DA3D2683A7A3BB0EDA4D01F8BF87FD2F52
-      FEF18FF692E640D72CC8A96D647D08BA0F6D7823E7F0F4B3EA2A3CBE2FB3F8BA
-      ED723756321226D4ADE58D98313FD17F488C02CD63FE1EEBF4A0F6AFC1E87AD0
-      BF1A417C49EA2BFEAF3FF8CFD9D675AB56BF2B70752BB1048503977B861AE4FE
-      D1F756829E67A5B15E6B4EE7E07E26FF009FBEDEB3FF00102C556CC505C95470
-      819B48509FEA85947E3DB42D828C7C5D3FF5609F83B7F2FF00570EA6AD60054C
-      7AC84FD3E42F22A7372D036967B726FF00D073EDA683565FE26FF57774F09D41
-      AAD48FCFA9AD95011228DD514BB3C919553FBAA92F89D594B03A5A5623FD49F5
-      1FECFB4EB67E6E98A60FCBFD5FEC7566B85E0A3BBFD5FEAFF0F585F275059556
-      7BEA4F53B48103876FA90BA10E822C0A85F7616718D4C531ABABA5D105634931
-      D2C762BCB91DEDB623FE19FC7A56CE62A67C78A94A24AD820AB13D4455555E5A
-      4145422189DA799A68E38A0059DC0563ECAB78458368DC48B9F013C175AD2BA5
-      9968348A354F70A2D092D450B5E847B0C4B2EF9B4C62D1673E346745742B8075
-      1D4FA8684A025DEA004524B2E7AC190AD7AFDCD5B0D140CA2BB71550A1A2A791
-      9E99DEB726CB1411AA3D4C73ACF1BA247E3F25E3B58BF0CD782010EDF0BCCDF0
-      403516E3DA993E54A64B574F76AE1D26B875B8DCE58E0855924BA7D00657BE4C
-      01C7529A8D34AD469F8BA1446272DBAE7C774CED6A0AAADDEEDBDFCF2E3928E6
-      C3A63F391439EC5E5B1152F9091452D0E3E48E9B53A88228A1524A064BFB0F1B
-      8B6DB52E79AF72951367FA4D21F52C9AE3AC6E8EBA3892BAFD493F0B77742B7B
-      0BCDDCDB7246CB66F26FEDB854A0531E89A92A3C475FC089D99A200BE555E829
-      CD0ABC2E5F2787C8787EFB0B5F57415AF472D1E42916AA9277825482B29DE54A
-      9843AD8488E5580BDBD88AD162BBB6B7BAB7D5E0CA81C6A0C874915150D4D27E
-      54E823731CF613DCDA5D95FA8B791D1E8438AA3693471A8115FC40FC39EB12E6
-      1D8A2998C8E3C4AD207FD04D8B2B94919A78E3363A57FB5EF6D67402A98CFF00
-      ABE5ABAA2DCC59ABAD41EA536722133EB7914BBC605A572ADEA5941D5C042AE5
-      BEA750D217DB6B672E91A57B57AD8B8875C685C509EA2D46558AA192572E589F
-      5DE48AF1BE9124E896092589B6B63C7F8DBDDE3B6A970A98FF008D777A7FD0BD
-      24BA721C953D9D32357B2CAB340D3317915E2B3F2EBCF8E1BE81E20A0B7E91CB
-      71FE3ED7FD38D1A5F48A2D0FFD05F3E9199A89A83B1D5FCF57F83FD43AE5FC5F
-      D68575C4FA9885591DE3FD3EBD4B22D9CF3E9D438FEBEF5F4668476B2D3D3A4D
-      E3AD69AF3D4E8F24A13C825D4C63663AD1407123AC4BEB209BA8D5F437FF0069
-      D3ED31B77D54298AF4FC728217F87A73A2CAB47FA966F3EA66467915D265D6C1
-      82F92555091C26EA47FC83FED2CC96E0D74D34FF0083A520C22B4A753DB23124
-      AF3DFCC90A891999DEF4C592279599F549AA5119D2148FADADFD7DB420661E1D
-      3493C3E7FF0017D30FC1981C03D28A9F2151A75AD585855546A5650623AD1EFF
-      006E19989BAFF6CD81E3FD57B4A5147FA10AFF00ABF175B009E11F4F78DCB2BC
-      9321965779E55F209A48A6454035896CA4ABA33B72D7B295FF00835989A1089A
-      874A157B40A669D2E31B9478D9E48A4528155AA524BB4B13DDE38E4B38658D05
-      BE889761F51ED13AB0015788E944050062CC2BD39C59822478C552C7A1E336F1
-      822455B126191BC62421AF663C02DFABDA53E2D71AA9D291242F53AD41E9EE87
-      2732CB233895FEE561D4D209122645B928600495BC7F8D49E93AB9F74224A548
-      3D6BC5874D4482BD2D62AA8E448E21334BF6DE35BF975CCAACC5B418AC51F4AD
-      ADC28D478F7425B81E9C5514EDE0074EDE691047503C3FB6C006553E5745A942
-      EE1A493CC1AE2CDA6DFABFD4FB5507E3FB7A69E24726B1F77CFA94330B2ACACA
-      928768E6760C20956FE84B33959754A43FFB11EECEAA7E1E3ABA4287F51AA7C8
-      F5489EE6DEA07EBFFFD2D503E3B48F174F6D47437D32678E8B13ABFDFC999D4B
-      7E47FA9F4DB9F71F6FA6BB9DD0FF004BFF001C1FE7EA4DE5BFF9245B7DAFFF00
-      1F3D0DF35585D05BF53B8436B1F4C8CFC9893420B11C7A7D9688EA14EBE8EEBD
-      617775665D1249E40A968E54578F48D373EAD51C8C1FEA1AFEEC2DC1FC5D312C
-      9E1E851D7534FE3B426378C344CBA9A67014696259AFA9DA5503FDA54FB52140
-      A1F4E9A796AAE3474C5E58822586BD0E6FAB50774D408034B69BB13FABFD4FBB
-      E7A67F53FD54EA3DE3D20ADD85CB346B202E41FA59ADA756A5E7F56AF7BE9DEB
-      89989015B4868BF77D1A7D0AC5BD4A196C58FD3DEBAF75C242BA590BE924303A
-      55CB32FF0065CB281623FD4FF87BB45C507FAB874D48FA10107AC51C126A5404
-      E92AA101E402090B76219B558DFD4CC2FED581D2076D4D51D3BD3631DC2AB975
-      B90E7C4EABA9B4F17420A1B7FC85EF7D53ECE947498A74F1C7A5D05F436A9093
-      75624DD883CB104FFC85EF55F4EA8EDA5A857A52D3D1231025447B0D5131B48B
-      A4FD47E2C109B8FF006AF7AE93E29D72ADA285DA3545041B851A5825D400EC5C
-      8E0337D4717FF5BDEF874E2BE91A74F493C8E3225210FAAC4A8FF32976209BAA
-      ADD8005AFC0F69BC0AE43F4EC72D0E931823A4BD450C7101EA61EBB58AC9EA25
-      BD4550DDCA0FF55E91EEFE09F26E95A4FA069D14EA23EB5F4A08DCCACCC65B68
-      11A69B100EAF5316FA30FF0055EDB74282A4E3A7126D674D71D718BCBA6CC194
-      23AEA94B865957D24860487BDD3FA055F57BA74ABCBACB4B33A334D1AA1F2795
-      497742823D4143DEEEA1C8B69B7363EEA517D3AF2B08CEAEB36847BEAD11DD97
-      D0AACCA78B6A2ECFEA2E037E3D36F75D5A3B69C3ADE8F1497F84758AAE148A20
-      CA5493AC38D3A784BB29BF2154B9FE9EEF5AD71D7A540801E3D3779E181C2B14
-      42FE8540E6362A790C91D86B361FA473FEA7DD1978B79F5A576D3E1E8E9B6A51
-      42F0CAC6E25F1C91D8B3AAAC8048AEC1FC9EBB337E9B7FADA7DFBC41E87A7840
-      41AEB3D344C1E40E4C6C3C5A8AC654913CCC92DD4690AAD185242AFD0DEFE93C
-      FBD789F2EBCD1695AEBE98321524471C7AD2C550FA5847A50D811E4F4885E346
-      B270755BFD7F6EF4DE7D7A4A545646B3CA75BB30658960D2FCAD8A49E3620381
-      AD96EE3853FEB7BD11A853CBADA9D2411D33D6D5C32453B40DE392032854FD32
-      9D3A3CF6993F6D8242EC3503FEB7EAF740946527874AD1FC4607CEBD236AA760
-      35BC86D1312232EAE34D95DD9469FF0038427FC847DAB8E31A680FC5D6C0A0E9
-      2B5556CCE588F5DD4B053A564170C19EEDAA3B5FFB3C71ECCE18811FD1E91BC9
-      527D70DFC874C75352EA59D98F258EABAEA07536A0197D400D5C807493ED7451
-      8234AAF45B7171E1F7370FF557A6E9AA85DCDEE4DEDCFAB4D94A860140FAFE9F
-      6A23889D18C7459717A9DCC64D469FEAE1D44352DA94DD54497FF12CA3D5637E
-      473FEB7B784431EA3A2F7BF6668C97D28FFCFEDEB009086241B06FF1F4DC7376
-      1FD95007BBE956C370E91FD4488CE5294FF01EBB353705357F6947E39B7D08FC
-      9BDFDEC42412DA73D59EF8BA18BFD2F5884A6F7B1041B7A79247F5B8FD37F6E7
-      846BC7B7A4BF524B5402187A53AF79F55FF4865075701431E7E87F27FDB7BF78
-      54F3EDEADF585C96C0916BFEDBFD9FD9FE4EB9FDCB7F5FD5F53FA78FC303F4FF
-      0079FD3EEBE07C874E8DC095A1F3FCBFDB7FABF0F5904A5AC493FDA3E9B6A27E
-      BF420022E2FEE940314E940BA697492ED4F9533FEC7E2EA52CCAA6C09B35C822
-      D6BB7D49D43DB263639273D18C7751A1D2BF09FF0009E3FEAFCBB7ACE273ACF3
-      A2DA54B37E9039E16DC59ADFA7DB6D190B5231D28178353D5C280324F97D9F6D
-      3E1EA60AEB3288DB428556D02FC1B283A581046B23D5F8B7B67C2F36F8BA5E2F
-      9352E97A211FEAA7F2AF5CDAB3C6BAB532B5BC40DC0B023FAE9F206E78FAFBA8
-      84124790CF4F4B7A90C7A99CD4E3FD5F8BF937F2EBA6ABD566D4ACDF56FC9045
-      FD3F8E4FFAD65F7BF0FCBCBAAFD6290855C57CFE5F2FF4DFC8743075F5936177
-      367688CDFC4F1DB6F6E61CDA86AA5860C2EE7DCB4D4B9D9D3270412C78EAC992
-      8E1A6D123C6953475150973FA7D85B7BFF0092D72A594C57E9E49E47F8802648
-      616310D048D6054BD46A647119E873CB37309D839E6FA2D46EE1B48633D84811
-      CF38131F1002109A04D2DA55E2320AFC2BD26E38D2AE0CA6565CB3D3D4478FA3
-      CBD3642AE6811E5AE191A186AA2A58C5541340D1A09E4874473BBA40A891FAD5
-      C2F62636B6B75B6050B94640ADC341209C306FC21AA4282E58B76D3A40248E48
-      6EEF1AF8ABAC692091C8F8F5A02116A08C6B2940E4AA00133A945B83B0B77F4F
-      6F71BAB6FD7CF89ADA3C84154D9582BE2ACCC6E4C366D22DC74F0E6DEA5244C9
-      C3979AB5AA6AE09C977D0919E222EE187D8F6BE69DA3F76DEC2B244C8CBA0A69
-      48648CF864C74F80A05D08C3192465E805C79AB79E48DF23DE36CB9682E1260F
-      AC3D649E198098092B5D6B2B3F8922364D00384AB03D90A8C4E46872393A0A59
-      D6B69B2D5B5158F442314869333216C408D1E246822A0AD64A760D7F2793D1C0
-      F50AE18EEE09ADEDE775F05A350B5E3AA3F8FEDAAF70FE1D39E80B71B9585C5A
-      DDDDC309F1D2672E55801490FE9E9C70473E19AF1AE3FA4EBBF765C7B0A9B6BA
-      9DD18ECDE473D8FACC9D762A863293EDA8854A478EA2CBEAA879E2CB6429C99D
-      E031A08D0A6969353694BB36E9FBEA4DC9BF773C5042EA81CFC3363BD931A4A2
-      1C03A8D4EAAE9F35BCC5B3FF0057576843BA473CF7313C8E89C60EE01124EED4
-      2471A9CA50691A685AA681E255CDC286B70EDCB17253E92D98AB0E5FF1ECF1A1
-      4E34E8349732D634FC7DC7FE82EEEEFF00563ACA6A6505D52478C96D52B33AD8
-      96018070BA8FEA1C2FE9F75F090E9D48081C3A506EC93A564A3939AB7F17FAB1
-      D475AA6D2487079160D6B05B00D7D46C42EAE3FDABDDCC42A3B7A4C2E038662D
-      C7FD5FF19EB134DA4DEC8D21F5EA2B1C6AD6651EA1F4B5BF1EEE16BF674C93A3
-      38F178D7B57FD5FF003F7CFAE4F5A12CCABC9FA80791F51E96B0655016DC1BFB
-      D785ABE21D6E4BD11F72A1AFFABFD5DBD4A82B5B52812DD4B7AC10A1483F40FA
-      F9B6916E39F6CCB02D0D533D3F14A92B0A4D5FF57F4BA7586AC0665E1578632B
-      FA42105480415D0F16B53FA85D97DA57871ABFE334FF005777468B22B02BE54F
-      8BFD5F87A78A5CBBB44D1896D268690A2831C6F1AAEAF569B875607FC07F87B4
-      32DA697A953A357F3E9D8DD69DAEA715E9FA8F2F1B6A8A399C39314AC1517453
-      020874D3259DD3410A5EE3D3ED14F6CE16A5068EEFF6DFEAF4E9F32290DFC5D2
-      A61CD441E1D716832B0598ABC6266629E22FAE37959959D18F07D2C7F274FB2E
-      36A74B80D81FE9BFE85EBC150E40E9DA9F330D653F8D25F1C91132C684CA1C44
-      5134CA222AED3E94D4AFC8653FEB5BDB66D3477370E1D5C80788E94B4B90BC51
-      91278934146F3ABC86646934789CE92C5C2BF1C872A3DA764D2D919E99752BC3
-      874ACA4CDA46EC0348AEB1812B20F0A3451A2948044A64360C574EAD6C2FFD96
-      FA2530926BAFB7A57F558A7879E94AB5F5F2C31BC5E76920A6567158B0AC0AC1
-      16D0A346250C74B5CFE1AFC7B7224D0B9E3D55AEBD17A5445234B0EA611292A1
-      CC722B868C9834A289918222955D3F5F591EEDE20EC6071ABADAC341AF59F84F
-      F3EA9A3DCD5D403D7FFFD3D4FBE3C909D3FB55F4DC99B38B6B865D09B8B30D60
-      8A9A82B3359AF73CFB036F080EE573D99C7FC70752572F32AED36957FE3FF8F9
-      FF0057E7D0B8D26A603C964604B1575FA30E022EBBF912CB6FE9ED00514CAF4B
-      DDDF5B95634AF51D26351A98CB22BA8360AB26A2B6505883FB2EE8BF45F4FD3D
-      DB875EA3B9FE2D3D627694EBD72BB9D2CAAB27A756AE0B873EA5661FEA78B1F7
-      BEAFD42694C373378D3516E1598284D3F517BDF49FCFD3DEFAD75C00B5F42162
-      CAB6B2F8EC631FDAB90749BFFC923DFBAF75DF8CC818BA2303A5878C90C080AC
-      DCAAEA2BFEA47E7DFBAF7586768D50165D49AC01AB4AAC6A392501F57D7FDB37
-      BA9AD7E5D365574E927B7A73A2672DCB9548DF58663CE95161A6320AC80927DE
-      F5B014D79E91DC003411F0F4ABA1E2504A028C3D6481EA72036B73FD005FA0F5
-      5FDAD6048EDF8BA4ECC42353A7C9EBB1F8EA596B2BAA21A3A4A64F2544D34AC9
-      1468EFC2317366767FD36D4CE4F1EF5144F3111A23161D24B899204F1EE24A47
-      EA7A79C64D1E6B19066B15E5AAC0545736360CB434D50B8B97251538AB9F1B15
-      63C294CF9282974C93401CC889CB051EF6E1A1A78B83D555D248E3991AB1BF03
-      EBD3A2C4595491AE4BB092D1DB52FEE2AF8F4122E0D9B4FF00B1F752A468AE2A
-      2A3ABE0920F11D36CD8D04B3CD1A9376BFA751360C05DACAA79E3DEFAD83438E
-      3D2372D44B13C8E8A4AD9ACCA2454255B500CC973EA27FD8FBD83F3E9E5614CB
-      67A45D55368B4D1A333C8AA5E26289E36BF1EB00D974FD3D3F5F6D4CACC001D2
-      BB7FED7F23D4445E13D0EB6565176632066B8B3D908D28DEA3E9FF005BDA7228
-      34B74BFAC8AA785FF397E40D17360D6F5DFD2481EF7D6FAE243BFA034800B050
-      480A5C1D4EEA10BC8C1985BEA381C5BDEBF3EA95232B27F83A8B54266B3A3A94
-      6626488B931C85C81643A5D9749FA0D5EFC7875A663A7B864F4CD35445AC698D
-      C4BA403331D50AA12C4B2000B232B589B0FE9EFDD5D75E757500543F81E3A865
-      99B5178E5D2A92B8BFF642B287D2F6D57FED7BAE85F4EAF56AD751FDBD449258
-      638584CED2CE5CB278D42CE1A4056EA230A2665D4755AD65F57D07B6DAAADAA9
-      8E9E524A850FDF4E92B33434A81656521269503DD6556B210ECBA9DE32629187
-      17BDCFA7F1EEED5A0D3D7902867F17A4D56B404AFEAD559E8368C5BD2819D637
-      52495D6FFABEA3F530F741AFF674EFE8FF0043F9F489C8542534D1C108803AB4
-      EB2CCA2EA1F4A2C71328BCCB2AC2381A406B7B570465D6427E1E9992408C8B19
-      C7490ACAB9090E4862E8B776D43C8E7D28CEE06A6012C6DF51FDAFA7B3386251
-      DBD24699D4233498E9355950FA831956E5ACECBAB8D26DF4034B04FC0BFF00B6
-      F66114634D1531D21BAB921D1838AFF17FABF97F93A77C2EC8DEDBB31994CE61
-      36FE472182C3473C991CB470B478DA614F4951592446AE6D313CEB4D031F1A92
-      EBE9BDAEBA99BADDB69DB27B6B4BBBF44BC948D09C5DAAC0568B9D353C4E3D38
-      749EDB69E60DF6DEFB70B0DAE4976CB6D5AE402918A0248D6715A29C2E78569A
-      87438E27E3F6123FE2326633BB833D4B8DC156E5EAAA76B62FEDE8609E832BB5
-      D0D00A9A9A6CA54563566DFDCF0E420F1C22478B8282CC7D846EB9DAEFFC5D6D
-      2CE0865926081667D44ABA4DDD40500A49098DEA681B353D0DEC3DB8B126ECEE
-      1B8DD5C4315B348CD6F1D114A496FD9A8891CEB867132502B118A2FC5D1BB8FE
-      1D746BE35E5A78F71CD253E72AF6BB55CFB9649E0ABC94D4951163A58CD250D2
-      434B2A6466A7050DD35EA8D8EB3A3DC5CFEEAF392CE51840018566D221D25514
-      82FF00139AAE8D7F3F318EEEA6C1EC5FB726D03A8BB7905CBDB54DC12ACFA084
-      61A51429F10A76B63E246EE34E8B367FA1F69C5DCBB5F63D0ECFEC28B6AE72AF
-      6C53E43298CAC4AE971B1EE8C1D2D7D39A71263F23E638D9A491EAA794C70A88
-      DD4222AEAF7216DFCE9BABF296E3BC4DBA58B6E7124C511D681DA19190D7294D
-      629A00A9EE1935A75106E7EDC6C639FB66E5DB5D97741B2DC3DB87911F598D6E
-      61575A76495D0C5BC473A53B58695A57A497717C62CA75C67EAF1586C9D5E551
-      A0357818B318E18F9F725251D3AC99A9B015B04D3D06467C44ECA26A6D50D52A
-      EA7F1685D6E6DCABEE25AEFF00630DCDDDB244D5A49A1F588493FA6B22901D15
-      FC9F295D22BA8D011F3E7B457BCA7BA4BB7D85E3CC346B87C445469D00AC8D0B
-      A964731E3527648055A9A4549589E09A9E468678DA2956DA91C59BD40107FD49
-      041E2DEE47474906A46AAF50D48B246DA244A30EB07BBF4DF5D587BF756D4DEB
-      D7204A9B83FEFBFDE3DFBAB249A7E5D67F31161C35EC2C2E07FBC96E7DB7E12F
-      A9E950BA23B78FFABE7D77F707817E2D73AAF70437E91CFD0AFBAF85FD2EADF5
-      6C02286FF57FC57593CA4B28E6F7BF3F5FAF1A8FE9B1F74F0DFD3A7FEAC9283C
-      EBFEAF5EB90A990E904B13FD6E2F7FD46C35127EBEF7E02FCBF675617D330456
-      7623AEBCD721BE9617E74A937FAF3FD6EDEEAC8578F0EB66ED5DB57E21FED7ED
-      FF006D9E8C7FC7ADF987C11ECFD99B92B60C760FB2B6055E2DABEA290D55253E
-      5F6DD447B9315054D28961967832D1525450698DD26F254A1056D7F602E7AD92
-      EAF4F2F6EFB7C464BDDBEF83D0369631CC3C176072AA50B249DD8A21D5D4A5ED
-      9F34D95837376CBBB5C88EC377DB5A32E5094124044F182BA8332CA11E1C106A
-      E1BCBA0DA0CBE3E9B3F4B4F9B5C961D629B338CDCF251D0D051D52D1E4A5ACA6
-      A9FB6A45A3263FB3A2940103A96645288505994F9ED677B39A4B3F0E66608F16
-      A2EC2A8011535F365E2BE7DC6BD07EDB77B68B70861DD1E6834B4D1DC15440DA
-      1C95345D151A10E1185580A0D350DD1DFE96E835EFEEA3CC6DB827CA6D3DC3B6
-      F704589C9643ECA9B71622BF74627F88D4C795DC190A678B27414E98DCE494D0
-      52AF905E32E92BF10AC41CD9CEBFD48E67B4BF31C773633C0CE89A8C6E217D0B
-      A2353D8E75C6AECFF301907C7D6417247B78FEE5F24DDED30C935AEF16978B0C
-      8FA04F1BDC46AEFE24CEAC2445F0E62891E47692243DB1F59373FC0CDC1B6F1D
-      30C3C3BDF7C6564A5AE871D06DDC260E97192D60968E9A26DC39DC96E8A2A7C5
-      D2CD23BD550AA42F2BC11069D413A46B6FF7AAC3719D5AE9ACACED7529732492
-      17028C7F4E3484976FC126556A7B18F1E9BDCFEEE5BDED36CE36FB6DCF70BCD0
-      E1161861084D401E34CF3A08949FD4874A925157C451A8282F3DA1F19BB47AAB
-      0CBB977A623254295D97C9D3C147945A3A8C93D263E831795ACCC4F558FC8E4A
-      9AA040730219DE36785278E40247B5FD8E797BDC1E5DE65BCFA0DA6E63764891
-      98A5553517745401D1185745402AA48230BD473CCDED473872759AEEBCC5B74D
-      1C4F33A849A85E888933CC4A3B83A7C4547652C81830D47A2F0AEA2E0C4D662B
-      C86F56A37D249E1B41D5FEBFB1BB54E7567A0124C88CC8623A4D381CFF009319
-      EB96B45D1E9562881548FA1B3016D6086371EF5A49D5E9D3864850C3A9433AAD
-      07FD15FEAFB7AC32B5CEA00691EA3E9203017B6AFA9FE9EECA0E00E3D269E425
-      B5AFC03E54AF51DE5D2DCF06CC09BDF9FAAB0D21B4B5CFE7EBEDC58CB2D6BD23
-      96EA8F939A7FC515D35CFF00871ABA8E66258FA8D9869622D63C7AAEA78653CF
-      B514E8BDAE58B7639F4FF3F1E3E7FEAAF5C927B9F510A01BFD1BFD4DBFC47D7D
-      B6625A638F4F4378ACDDDDBA7FE81FCFA708AB0AFD5812008ECE6E6E7FD5D87E
-      E293F8FF005BDB2D093E551D1B43B9E9C337760777CFD7D7FD28F974E3157C86
-      E59431524C8EA34EA57D5A91156CAA187F87A7DA56B7518A67A348AF99969A6A
-      17E23FF40FFABB7A765A82143ADC80A845AE5946A692CD66545B06F55BF4FB46
-      E99D2DD1A78DD9519EDFF56AE9DA8ABB549FBA4D4F8D64119244922864D6E918
-      3AB5A866FED117BFD3DA29E0D22A9D95FF0079E9D59558855C81D29229B55FC4
-      CEB33B5A39639A3448995B5340558B6A88C7704FF5FD3F4F65C6BF8BE1FF000F
-      CFEDE9F56AB67A5763AB25792D2492095BF79BC93468753C7A15164B1B85857D
-      009BFABDA09E31D94E1D69B4EBCF4B5A2A99A51A2369342C88B528D68DD62891
-      5819413218649263F86FD23F57B40402287874E9864270A00E842C7BAB4BE7BB
-      5407575911F546D2AC91FA7485B4A5649220B666FED2FBAFFA27FB5FF2F4DF85
-      253E03D2D28A38A48DA085087F1B989E557D0ACC2579A3D3A55FD0C350B33A82
-      3F1FA7DB2EEB4ED6F3E8C68CC99E3A7AA6DF738758F1D7FFD4D4EFE3CC60750E
-      D595592397C99C08D20D573FDE3CB053194D255D2CDC1BFB03EEEDFEECEE81FE
-      87FC7075236C1187DAAD6BFD3FF8F9E8519CABD901BBD8D888FD4C52FF00D85B
-      288DCFFC87ED17F83A31228C1298EB82CD144640C486D3624801FC8179444F53
-      A9E41FF82FBD10187CBA7125118257A8FE467019D4A3A0D48A5ECBA083EB2C75
-      92C59AFC7BDF5400310F5F2EB8CA548667242D86A0AD62436AF41375F46ABE9B
-      7D4FF4F7E3D6DFE13D29F6E6C4DF7BD3218BC2EC5D8FBCF79EE0CC4B48984C16
-      DEC1D6D754E49EB65FB4A57A77004428E4A852BE62FE3B86D37B15F7BD08A03D
-      CDE410DBE9CBBB500FB7FE3BFE9BA452DD2ABA451C334B331E082B9FE1EDEAF5
-      BA27FE1371FCC5FB7FA677DF6A6F2C5ECAE8CDC745B62AB33D4DD23BFB2AD276
-      476EEE2A28A9EB136CE4511B1585E9CA3CAD0AD44549559D99EACE4A28E2ACA0
-      A2A290E463BC96EFFE271C468F2B305594989E4D3A8BF8686AC4A85041904684
-      B210FDC0F49D777B0491A39DDC00402534C88A0A82AEE5188D3A982D10BBAD1A
-      A3500AF435BA369EE5D979DCF6CFDE7B733BB3F79ED1CC64F6D6EDDA9B971559
-      85DCDB5F70E1EB1A8333B7B3D85AE48EBB1596C556D3B45514F222BA3A9047B4
-      C5E332C882B415D35041C1A10C0E548182287BB1D1AB2900AB020E90C4E0AB29
-      0086420D1D48C8230453CBA6EA360EF08D659A50B6F4903E8416F1B7E8E7FB3E
-      D42A6B5D40F48EE5949E1F87FCA3A5961A8A7ADAEA3C741A1AA6BEAE9E929E37
-      9A285567AC9560815AA673153C11791D754AC51516EC6CBED529119849D5A6A0
-      748DCD227614D54F3EADEFE2EFC67F8ADD958BA9AFEC6DEB45539DD9F3D1D50E
-      ADCCE3B2743B496AB133478BAFCBEE3DC4B0BE5B73D7D7E4652D0D2D040D4B04
-      722DDC22B6A2AE61DFB76B79E3B3DAAC6901C192BDDABF176D3D29E7D1A6C9CA
-      FB3DF5B3EE77FBA13B80E1153B347E1EFD7FC55FC3D0D1DD5D5BD71DF3D59DA3
-      D29D7B93AB5CD6C8DAD5BBEBA7282965C061B66EDFDE1D69F735736276AD16DD
-      C4E368A67CBE2A77A09E6446A9923A8F24920096F6D6DF797B6D716EF77DE8ED
-      42C7579F5BDCD2DA7B7BAB2829EA8AA34D193867AA38D89B8EAF39493E3F228E
-      B5F46A1CCB2288A6785999824EBA9AD530143F551A82DC92D7F629BEB444777B
-      5F87A06585ECA5FE96EFFB61E7D2EEA7415D4BA758B861701BC766B02DE9F55F
-      F50F65B41F1D3CBFD9E8E3E5D2332FA48605C2C6E4FA0823926F12C776FA123D
-      4DF8F76EABE58E83EAC527500E41B863C150E82402DC7D48636FF69F7B3C3A31
-      83E33F61E930C7C7E58DDCCAB19D160C8912A3E9292484851AD6FC7E7DA49077
-      1A1E95C55A1EB8CF3E943E76D292C76BC69FE68B1BA7F6831247E7E9ABDEBA7B
-      A911BABD30D018A2108C486324A2C3947D77B73EF5D7BAC2D2ABF914B0D29E3D
-      5761A9239155101B706E7FB3FE1FEC7DEBFC1D35FF0056FF00D5F9F1E99EBA12
-      4C6F19D481951D781CA0658CA0527D2028FF0063EFDC707ADA3F931E9AA4D3A0
-      C6CCEEBAB5089D9FCB1B0723D650893CA34EAD67D3FD7DEFA77ECE9A2B0C4AD2
-      4BE151144E849F23F9CBBFD0E974552B62CA1AE7EBA7F1EFDD6F8107CFA4CE42
-      4499154C44EB95A5F2A0D01881A16C8B72B200BF5FEDB7BAAAE91D59DCB81E5D
-      21F235B3C6851C4CA4B369934C74E9717B5D56E47A0FA56C4E93ABF57B723019
-      811D538F492AD5A89A25691DCB96B392A4F99A31FA9230598143E962DFE1ABF3
-      ED5C46347A1EAC8864AF753A46D69F131462EB1023C45BD44076329503C9A558
-      9E78BEAFF5BD9BC4752D6BDDD15DC6988C819E89EBFEA6E9CFAEF68BF606FDDA
-      9B32298D345B8B2F4B43354808A60A201E7C84E85BD1E58686290A6AFC817F6D
-      6F9BA8D8F65DC77764ABC10970BEA7822FD8588AF4D72FED0FCC9CC1B4EC114B
-      48AF274427F853B8BB7A6A08A69F3A7577906C8D9D4BB4A9763C782C3CFB4B19
-      02D1A61A68520A168E3D623942CD679EBA4998BC952C56592462F7D5EAF7882F
-      BCEEB26E736F06F245DD246AF88A751FB3FA234E02700B8EB3CD397B628B6587
-      97C6DD036C710D02123B34FF0017FA76E25F8B1666AF774E78CD9FB6F1552D53
-      8BC1418AAC91DA56ABC5CD3D2D48966C551E16D2544521672F89C7D2A69BDAF0
-      424FAD15BDB171BAEE1791787737E648C793AA95A2B993E16FE9973FEDDC706E
-      95D8ECFB4D84AF3DA6D6239D8D7546483DD188788FF85A463FDA21E201E9AF6B
-      6FCC067A5DC116D8193C85261F7064283215316064A6C5C995A5A94FE2B4D8BC
-      B55C3418BC9A43904D72F8DE59FC81DBD5E8F6A372D8EF6C56C1B7111C72CD02
-      103C4ABE823B19D033BA7676AEA0069A7F4BA6F64E68DAB779B714D9E19A68E1
-      BA747221223F154AF88B148E123928F96A317AD4FA7516A6836DC390C3CB81AC
-      53BAB174A98DA3C252EE7931829F058BA8A79331453D1D3B57CE684FDBC6B529
-      E0777D234320D6E1C8E7DC1EDEED2F57FDD748DADA430EBD523AB08886345AE4
-      E83AC01F8AB81D337969B4C7756236B9BFDDCC09E1A42B7263D10C6434C8C835
-      F6602B8D059B1A74AD582C77C6DFC0EFDC3D66D9CF24D362723A89A9A53153D7
-      E3E6951CA5662AB6A2312E3321096B8990FED720EA42C18AB68BEBDD92E61DC6
-      CDD45C47F85BB91D4793A86D2E87D0FC5C5722BD1E6F9B76DDCCF6373B2EE70B
-      359CD5EE0D47434C3C6F4AA38FC2EBFE95AA2B5201DF7F16F372EDEA9CCE016A
-      F7165F0B4EB254B6171D364329B9520A75868EB2AE844D15262F28618F4D6263
-      C4F1D41447440E5904DFC93EE4592DF436B7BA20B599B1E2384486A6A42BF733
-      A6AF80C9A0A6559B4E5B18FDCAF65F73FDDD36E1B623DDDDC09A8F828CF24E00
-      A23BA5408E5A624587587A070B5D4A2B3DD191991D4A3A16474752AE8EA6C558
-      1E4107EA3DE41AB06151C3AC47656466475A11D71F76EB5D7BDFBAF74E98DC26
-      6B34CF1E1F1195CB491A349226371F595CF1C6350323AD2C32148D48E58F1ED3
-      DC5E5A598D579771C41BF8DC27FC788E95DA6DF7F7ECCB63632CCEA2A4468CF8
-      F5ED07A8D55435D432BD3D75155514F13E8921ABA6969E689ED1B9478A544747
-      D3221D27F0E3FAFB72392194472432A3C6DF895837F83A6E7B6B9B5678EEAD9E
-      39060AB82ACBC0E41E1F10FDBD44F6E74CD4D6BE7D72D4DFD7FDE07FC53DFBAB
-      F88DD658D259A458218DE4966748E38634324924B210891C51A82CEECE748039
-      2DFA7DD18A2AB3BBD100D459BCBAB29791D62890B48C681573A98F0007F157FD
-      8EA6D15656E13274B5B10929ABB1F549388E4F2238921707C72A7EDBE8950598
-      7F6949FC7B6E6862BCB6785F4B432253FD5FF3EF4A6DEE67DBEEE29E32C9710B
-      6ACF1D43FCFC0FC8F4633B9360EC8A1C5EDAEC2DA5BC65CAE2B7E6C91BAA931B
-      B8EA0CF998B71C3B91307B936A79E379FEE2B76DFDD5E3695E23253D36BB485F
-      5100F2A6F3BCCF75B8EC7BAED623B9B2BCF04BC6B48CC661F1619A9DBA44D4CD
-      3551DE98A6912A73DF2EF2F5B596D1CCFB26F7E3D96E761F528939ACCB389D61
-      9EDAAB5ABC15C12C354695A396D44D0FC22F94DD77D23B477D6337DBE764CB6E
-      3DD10E7F1BF634149591568C4E0628AAA2A8CA65323450D2575536A30DFF005B
-      2D836A600C71EEF7B6DBEF376E9B2CFB2F802D2DAD8C6F562ACBAE4D40844425
-      82FE2F4E3C384D9F776F7AB95BDBED9B996CB997EA4DEDE5DACD1E80AEAE6380
-      060CF23A2A3BFE0AF1D34535655270333FCC1F626C2DD53D06E8DABBB323B573
-      506DEC96DDDC586C5E26A711363ABB038ACA549A4965ADC7B65EA23A5CAC133A
-      EA46856658CAAB27AE2DB3F6377ADEB6C4976DDC6D537284C8924323B870E257
-      45A8D2FA06A475F3AD2A3529ED9CF71FBD0F2DF2D6F335BEF1B35F4BB34E2278
-      27852330B23C11C8F425D1A420488FF85807D0429192AFF35BE5AECBEE6DA1B4
-      311D614FBAE2A3AAA3CCE43722EE4C46329A967C157D75050D20A56A5CD642A6
-      2CAE3B70605B57A21550A2FAD2460646F68BDB2DDB94B74DD6E3989ED4CC8E89
-      1F82EE596400B9AD6341A1E393D4FD8A403D43BEFE7BD9B173EEC9B05A729C37
-      AB6EE923CFE3C71806191D1068A492112473C3DD5D34A77551DBAAC69A3F188A
-      44991FCF1334BA0B9921911CC65264F1A6973A43AE9D63438F57EAF790C86BAC
-      156A06FF007AFB33FE6C86EB13A43A4EB128ABAE7E2A823D4505387CF057E7D7
-      1131176450A003C2A92C4FF537B0B1FF006AF7E31AD3B9BB8F4EADD32D5A340A
-      9A7C87F3FF00A2BAEE490E81ADEC10369D6C035D881661AADA5BFD8AFBF2200D
-      C7BBAF4F3B1893C56A46B5F89B35F4A7A37AE474DAF22DF871CFFA903FDEC703
-      DA94423F063F674433CEBA8959969F2EB01938F4FA6FF903FE35FA8FB7BC34F4
-      E91F8A6945C7FABFC3D721235EFAAC7D5C7A79BF3F83A78B7D4FBF684A70C757
-      133935D7DDFEAFF567AE4B31B90CC2C7E87D4012BCFD08B5B57BA18BF84F4EA5
-      C91DA5FB4F9F428607ABFB4F3F4AB90C175C6FACB511BB0AFC76D6CED4D13FA6
-      F74AB8E87EDCA00D72CA6C07B0D5E73072E594BE0DE6FB651CBFC2F344A7F656
-      BD0FF65E5AE70DCE3175B772D6E33C5F16A4826287FD2BE8D34F521BA7DCF759
-      7636CFA5157BC760EF0DB540E030AECE6DCCBD0D0962C0E9357514C94772A3FD
-      5F3ED05A6FFB16E92785B56F56B3CCBF8639118FEC06BFCBA15DF72AF33ED50F
-      8BBE72E5F59C07F1CB0C8A9F9B91A3FE359E86CF8BDF1FE3F919BBB716D3FEF5
-      D46D55C1ED33B912B29F0D165DEAE55CB62F19E0680D7D034680640C8D26A7D3
-      A7E8355FD83BDC3E743C8BB6D8EE7FBB96E3C5B9F0685CA695D0EFAB5683E94D
-      3FF1AE86BED97B7B1FB81BC5F6D23767B510DA78FAD62592A7C444D34D69FC7A
-      AB5FC863A3D78AFE5AB8B3308A5EDACD4622B342B36C3A346AA8E2D62A1D1BFB
-      C9E15F185F480E4B9FECFE7DC3573EFD5C6979072CC553FC372715E1FE875EEE
-      A6E8BEED56A4E86E709853D6D467D7FD1BA2EFF23FE3DD07C78CAED4C5D1EF59
-      B77CFB831D94AE7A5AAC2418A971F0E3AA6829600121CB572D50AE7AA6D2EDA0
-      2346FC13A881AF21F3C4FCEF6FB85C4DB42DAC703A2D5642E199D58B7E014A69
-      FE9715E1E714FBA1EDCDBFB7571B45AC3BD9BB92EA391CD63119408502F077A8
-      6D4D9C7C2467A05F0AD492A8810AD31AA8AA84DE7D6913CC83D32B49A19D7CBC
-      8F51FD5603F4FB1A4E4FC6C72B4EA3E1F0C7FE947421626A489742BEA863F182
-      ADAC8A511B165F029373181EBD26FF0053CFEAF694CCDE9D3DE0D7F17422D038
-      8E094CCEDA0157B86D3127EDBEA4401436B76165FADD7FB5E91ED9FF003F54FF
-      004B5A533D5357B9DFAC74EBFFD5D4FF00E39B69EA4DACCD2148DCE7D088D5DD
-      D4FF007933161A42BA052BF5B8BFE6FEC05BB7FC95AEFF00DA7FC717A92B977F
-      E49569FEDFFE3E7A13AA2225D9A385E48F5C8CE19B5106DA90AA695FD409D217
-      DA614A53A33647D4EC7E1EA0FEDA2142A34C71BDA2892F65B30D2BA7480493FA
-      473F5F7BEABD710433BAAC723BAAD800414D2C17D16E1540FF007AF7BEBDD0E5
-      D07F1E7B2FE496EBCFED2EB1DBD59B8323B2F606EBED5DD6D4914724787D99B3
-      63A35CA65AAA39BFCE24B95CA50D14510D4F2D4D6471857BFB4F24F1C011A570
-      159F48F9B7A749A4D6CBA62F8FE2EB60FF00875FCEB7A67AA37C6E3D8F96E82C
-      0CBBDB66EDD1D67B6BBAF684D48DBC772ECDDB783A5DBED1ECD96B58E3360D54
-      F9086AE4AA8B0BE27C824AB34635A8542FDFF92B73FA2927B3DD9A279D4EB5AE
-      A2A1CA9012B511B57F1A51C0240600F4BF97F987969AE23B1DD369A3432A328D
-      6A6295D0D499A365ACAA74D4C4CDE1934D48D420A73BEBF99CFC85DC5B9AA775
-      755EE39970F5F82A9C56D6A42EFD8D5DB6EB282282AF1BB8B198DDEAF90AAA9C
-      D636AB53EAA88209A0324C51D251E4043B5F2E4505BBC174CCF28C6A34355F9F
-      427DCB98CCB7925CED10C69685AA000A02BFA80A00FF00791E5D25FF0099A6E0
-      EAFF00E657B23A77BF7A2BE39EF0DBFF0026F6FE070FB2BBDFB1A83233E6715D
-      C94B86C2A6276563B3943454B92ABDCBBE851501A9A0DC1573AD625053C988A9
-      9B250D3504F423EB7DAEE6486192E27555D041A48CCF210C34BC808A062051CF
-      88E1AA0D053A8DEE373B4B3BAB982059642F3175531AC70C41B5968E321CEA1A
-      88D2BA515749A0EE6A6BB260ABC3652BB1592A59693218DAEA8C6D652540293D
-      1D652B9865A7991A35789D197D4AC3F490790DEF519D2645F307A572B2C82170
-      DDA47465FA4B6A60737949737B8371478B5DBD598E9A876F454AD3E437156169
-      E686259D82C34B8D8E488472CB69A4BC802A58EB0E6B9523F1E0A6B07E23D32B
-      676977030BA9A83D339E8E5E7B3BB57FBA518C5504B80920AFC5D14B523254B0
-      E2E971B93DBF3D364A5CFD54D1D4D6E4B295D9C9E9A480F9B5410F9AD1FACB7B
-      A46F737537EBD185757CBEDFB7AB148ADED9A1811921E14AFF00AB1D155D99BC
-      7706C56DC9D89B627DCB96A3EBE8D86E39B67475D4155B560CD4F49B7AAB262A
-      5665A34AED79BA667FDD8A199A4B300C84FB384B087C6856655667EE50DA78FF
-      0012FCC740F9B729E8F2C2EE24520541D34D5FE7E807DD7161E9E65ECCEB9CAB
-      65F12C524DD58CABA3931F92A1AAC8BCCF530E47153CCF50F4D3491791EAE3BC
-      10568041D7A2E6AD1785AE39569FD1E8AFC57795A663FAE789F3E9F1B2D15450
-      D265B5814D574DAA1963178E40AFE3922D3CAC72C536A474FAAFFC174921D9ED
-      1D26D4B5D3E9D0C2D2737706AD0A7BB8F5131D1E2B355F514D92A8C84135552A
-      52EDCA5C552CF92AFCBE7E5A88528E82931F4D13CF3BD424C4141E2B31FD60D8
-      168A3A46D23A76AF1E97204EC127C47E1EA2EFFEB2EC3EBF9A27DD5B57716DE8
-      2A66A9868A4CBE2EAF113D6B52C31544A129AA96391BC54B531C9230D6918916
-      EDCFB4CB7104803472823A551AB2B50AF97411C9086A8762A87C4A50AB794C8C
-      4B8744500AA7A49FED7D3DB72104B95E1D2FF2EB178D9A46D40BA280A911D524
-      43F530BA5EECE3F279B0F75208D15F315E9A562C6878759A94BA19DAC87D2A9A
-      749F2148CB2EB52C2D223B9F45B90BEF7D3DD479DD2F114D27F4EAB28E15CB15
-      0FA01FCEAFAFE3DD4F4C37C4DD27EB5E69990462D09621A2FD906EEBA09E6ECC
-      57D45AE8430F4FBF74EA7F1FE23D41999175206D13852C92390649B528250216
-      5529AC301FED2BA7DEFABF974CD5BCBBBA0664758C3C719BB2E95D7E52B7699A
-      4FAE955E07FAAFC7BF75EE92F52E4F9942BC72E8771199431F16A21B53166D6A
-      E1881E85D47DFBAF7495AAFB76F2C5290B343280CCEA9A2497C5A9911BD2C41F
-      181AB57FD13EE9DC723853A50863A212057A47D5F8D239AC235252E545D96F24
-      AAFE660DE250491A996D707EBED747ACB47F15357FCFBD6CE80AED1D357FABD3
-      A45D648843154E6C14A808412AA4190950BA5403C690A7D9C428CA727A2D9F40
-      572C9A8FFABB8F4ADE96DCB8CD99DB9B0F726566F062F1F9D8A3C84EA5105141
-      9082A31AD5B23FA808A97EF3C8FF00ED01BD97736585CEEFCADBD6DF6C95B892
-      1EC5FE22843D3FDB5283FA5D6F93F75B4D8B9E396B76BA9B4594372AB21E1A03
-      83197FF6B5A9FE8FCBABBB80B4B1C920BBC2A631799FD0DE57F233F96791D5D1
-      9753865D434E9B7BC42620350F1FF3759ED19055D94FE97F9FFA5E6BE7D38538
-      445F1C5A48E0BCA9AB5CD291A8EA62EA5AC17FB5702DC1F6D4A73A89EE3D3F1D
-      23A15D3F97AF4189EAADB58FC86E5AFDB7579FDB3FDE68EB1775E1F6E6727C5D
-      1E52BEA63F2D465A2A757F161B392AA71554B2D2F939F2313660201CCBB8DC5B
-      EDB0DFC305C7D315F05E68C39445F850B7178D7F81D5E9F874F4125E4DD9AD6F
-      376B9DB2E6EAC8DD873711413346923B2E6502BFA729FF007E4463AE75D7F096
-      EDCBF1A7B25F7764F7FEC3DE588C7E5A9F2F552E062CFD6EF06CA8C73D043046
-      1739FC5732EAD544CC6563E2D4EE413E3D09EE41DBFDC1E5F1B5DBEC9BDED333
-      DA989449E188346BD449FD3D11F0EDA71EDA371D47A8AB75F6979AFF007F5CF3
-      3F2CF315B477E9396844EF75E2786500FEDBC499BBFBF5FC352C57568D23A4A5
-      37577CBF292D3647B12BB0F86596696BEB719BAA4A97829B4ABFF93AC104598A
-      8A9A721DD93CEA2462A9743F53497993DACEC6836249AEB48011E1A54FCF5164
-      0A7E1AE8AAD3577744D1725FBEABAC5DF32C906DF562F24773AE829F87485909
-      196235D1B50151E60B645BB871A7350D0778EF0DCB5F8B86B25A04DBDB87754B
-      155882AC4757255574ED1D0E323A5A6A796A65F34D6D096D48F75F62CB6FEA9C
-      E2D1E6E4FB5821908AF8B1C351A971403B9EA484145FF6A467A005E3F3D5A1BE
-      4B6F71EFEEEE220C53C29EE74BE9346ABB51230803B9D6782FC4A6BD1B2F853B
-      5D31FB5B7DD3E7F1F4B515F51BB30994A2ABC9E3A9328F5B4395DB54191A6AB1
-      3D6C12A4B057C55249D24DA4623960DEE2FF0077F7369F73D99ACE62B12DA488
-      C11CA50A4C508D2A4770A7FBCFCBA9BFEEF5B30B6D9399E3DCED11EE1EF61910
-      C8AAE5D2481240EA5D4EAD60D7EDAF9F476A4C0E2A79CD6FF00DBBFB6FE28E8C
-      E2F1F1C66CBAD66D094A23923590B5812AA6EDABDC43F5F7606937D3E7F16B7F
-      F06AEB210ED7B712245DB2D2BFF34E3FF3740EE6FE3375DEEFECD93B3F7661A9
-      B29053603078CC2ECD3053526129E7A07A935794CDC74EF153E49EA0548F142C
-      DE2411B193C9E85025B5F7177FDAF96D39736DBB78A569E47927AB190ABD2891
-      93529A74E5973DD8D3DC5A3EDC7DA3E57DEF9C9F9BB7CB18A6856DA18E1B5D01
-      21564AEB9260282426B4456ECC55F5E028AF9CEBFA5C9E22B70B80929B6E5436
-      323C6E22BB1ADFC32968BECAB69F2F49A062853F84535552AA021033C3214B1B
-      FA83965BDC96F7915DDFA9B94121770FDE4D50A1F8F5575027EC22BD0FAF795E
-      DB71DAAE2C76D22CE768C471BC7FA613438993FB3A69A3A28C710C4533D105ED
-      7E95DE98DD85BA764E2608B70D4EE34DBB97C6656AA0783315F3EC2C5C143B8B
-      114F494D499158F2591A3C3D1D6D2C51D485AE4F2EA0D3C6804E1CB1CDDB45C6
-      F9B76EF72E608E0F191D01D488B72ECF13B12C9D88CEF1B929FA474F72A127AC
-      67E79F6F7986CF95F77E5EB28BEAA6BB10491C8C29239B28824F18408FA64912
-      28E68D430128AD4348802D6BD46DEC841A31D2504A99F19638D9310DE64CD24B
-      344829E9E4C3CB04754ACD3C4E3D3EB47E1C0D51EAC814BF8253E3A4C1AC7C3D
-      61F1E1D1789D75D3C34FF84360F588AFB5DDA05B56B661B909F418F3E2548C0F
-      0CAEAE20FCC1C328A8AD917C25E94EB2EC3EB6DDB5DBFB63E1F3995C76FB9F10
-      95B929AB22ACA5A3870988A83471C3064296DA2B263FA575DDD97FC3DE3F7BC3
-      CDFCC5B17306D716C9BD4D15AC9641E8946527C4715EE46F2F9E9EDEB2E3EEEB
-      EDEF27735728F305D733F2D4175B843B918C3C85D5C208A36D1A43AFC2E4F957
-      B8F47568BE2EF4251D72E4E93AB76FC3352149E99E1932D11A69A075912A215F
-      E22F5314D46634712597937D5EE2297DC7E77960FA697996731BE1B5787907C8
-      F669606A469EB2121F66BDB0B7992EA0E4CB4499082AD5930568CA47EA608A06
-      AD3A0DF2DF183A977AF672D4FF007224DA7B7F6041B7EB52B31B06D7A4DBFB9A
-      BAADA39E5DBB94C34F86C96572269E24479E7AA9046892204E18D84569EE3F33
-      6D1CB854EEE2EAFAF8CA94733196103B5645903A226A3DAA106A62198E57211B
-      EF65F92B98F9C90A72EFD0EDBB5A42FAE116C209DDCEAF0248CC2F2494142EF2
-      1D2AAC02EA53D1D3A0EA4EB28A5F053F59EC8495E4596A426D6C0491A031C31F
-      92B1A5C79891255A241E2013CDE34FF5007B892EB9A3986421DF7FBD64031FAD
-      20FD9A4D7153EBA7537AF590F63C87C9B1521FEA7EDCB26ACFF8BC07F85751EC
-      3C740EDC5740FE11D14AA1F8C181DF1DBBF21961C4EDAC1A41BE369E2E9E19B6
-      2631E969F6C647AE36ED6D5FF05A8A7A78E4A55CDD4CF5319869DE9D7CE84C8F
-      7765326CDEE2DDED1CAFC87AEEEE6626CE67256E5F534C975305F1031EEF0C2A
-      355D5F07B570088222F67B6DE60E77F748DAEDB696E8BB8DBC6A0DA46C82D9F6
-      F81DFC22AA1944C5A45A4653BC1676C904788BE1F6D17C16170594C56D2AEA1C
-      162E4A55DB3FC1B214D882F207CA524B3514BF7B4EF5D435B23A3CF246D34F4E
-      74137B05061F75773179797905C5D473CD26AF17C442FF00C0C2B86A30A30406
-      81F2BD4909EC76C676EB1DBAEEC6C66B582129E0782E21FF007E2164EF5D68F5
-      05C862D176B35780695DF1C7A4B01DAFD0B4B51D7BB4773C7BB6AFB2E82971F4
-      B8AC66DDC43AE1762D45650506EC87ED19B2B86A082398A4DF6C2ADA7035A384
-      7D6208B9FF009BAFF9679CE48B7DBAB66B54B47672EF33FEA5CA826035EC766A
-      6A5D7A346AD246A5A03AF3DABE41DAB9DBDB7824E5AB1BC4BE7BE444112411D2
-      1B46744B8142D2468BACAB04126BA5432A9057BBBB6AFC5AC05250C191E90E84
-      CDC955B965C3CF8BC6E7B094F36372105652615E4A886AB1B4F2C75548903248
-      B0C7AA78E9408FC8ECA3D936D9B8FB937D2CEF6FCE1BDC2A96DAD5DE390ABA10
-      64EDA39ED35522A7B19CB1D2B5E8FF007AD9FDA0DBEDADE3B8F6F796EE19EEFC
-      378D27855A374648751AA0208A10DA16AE91809ACD17A225DEDB4BAB3B2B6D51
-      E1FA8FAABAA764E672BBA28E5C96E1DA7B9682BEAB656231D579783314F99C3D
-      25252E472749519092E5F0F0643ED60A7F0C8DFE6E3499793373E64E5EBF96EB
-      9A399372BDB486D8E88E68CA09DDC21428ECC511827FBFCC7ACBEB45F889C7BF
-      70B68E53E6BDA61B1E48E4BD9F6EDC27BC42F3C13A39B58E3791641346811DD4
-      BFE2B649FC344D0E78203FFF001E7E2274275C54FDB47B0E2DE99D8A2A5A3937
-      3762EDFF00E295F2E7618205DCF5181A7AF9697193ED6A36F193347409263669
-      7C331790EB78439EFDD0E77DFA1F11F796B4B2624886D64D08232CDE0890A067
-      131CD14C844C175A506064A7B65EC9FB6FCB5388C72EAEE1B9AA0469EF61F11C
-      CC02F8E615722336E8D4258400C04F86FA9CEA27067EBBDA95905452BEDBC12E
-      88E38BEDCEDFC4A534F4AA4E84A545A5112CA55FD40FAD97FAFD7DC5916FDB9C
-      4CB20DC67A9FC5E2C950DFC473FF0042F5374BCB9B24F1F80DB2DAB01F85A08E
-      94F97674493E477C41F8F7BBB666E4DD15FB324DB198C7D1B54D2E77AC76DD53
-      6E3FBF1A69E2865DAF82A078771A4B54C11E334EF2D893E48C0320993903DD1E
-      78DAB75DBB6DB7DE3EA6D6592863BC98783A38D56690EA8748CAB6B03F0E93C3
-      AC74F75FD8EF6E77BDA777DDEE7974DA5C468CE936DF01F1B5705FD089293824
-      8AA3216D356D69A752EB8C985CB4D97A7C0C78EAA6CBD6D652D151E3E481A0AB
-      9EAABDE38E861114C5087AAF3268BFA595C7AB4FBCF56BBB78ED1AF9E64FA544
-      259F56A0AA9C723D28757FA5EB964B637AF7B0EDA96CFF00592B845422849720
-      20D27F8F50D3F6F56EDD65D77F1DBE266D3C2EF1EDBCE6DECB766E414D6482A2
-      969F7354D1AAA04928763EDF41531CB1524D208A4CA38479246243C318B2E2E7
-      316FDCF9EE66E777B572BDA4F172F46D4C3782A7FA77126388EE5847681F85CF
-      7759B3CA5CB1ED77B31B2D96F7CEBB95ACFCD922EBEE559CA63296B0E6AA0F69
-      9DA84BF0289DBD39637F995F5C45574CFF00DCCEC48809E663FE57B5E5869215
-      152B1341054D6C314B24D114D60BC76274AB39035A69FEEFDCC0636FF76D62C7
-      48F297BBE1F88A86A79FAFE55C19EDDF7B1E538E68C1E5DDC80AFF001C140057
-      4D0338AB30A7E25A570C69DC80CDFCF1F911BF3744345D41B261A7C1CF0C3411
-      E072DB3E9B77D4E6A4CAC9F658F9B2BF714EB4313551A94586284224ACFF00B8
-      66E349E59FB33C8BB36DEF37356ECC6F4163E224E601184EE609A4D71A49666E
-      14EDD1D16DF7DE3BDCBE68DD21B4E47D94476251504125A8BA793C43A119F551
-      16B50A00A54B675E3A329B0FA5E928F7757EF07E9EDCFB6F75D5EC8A6C76EFC1
-      EC4DD95387C1D7EE0973389AAA9CFE1AA3688DA8D81CE530593CD89A72B4AEAD
-      AF44650BCB1F6F5CD52CDB5C5B5AF33DB5C6D8976C6092E61579123D0EA23713
-      F8DE24671499FBC7C3A981A2C9DB5726436BBC3EF2DC937769BC3EDE12E63B59
-      DA385E6F1118CD135B2C1E0C833AED93B1B8D14AD49ECEB1A3A7A4C1E3B35E2D
-      E117F15C663207C06E0CF663751A4AC9E79DABEA10E467ABAA50D535AC8D3CB1
-      C0EB4D02F90204D090E731CAF35DDC5A87B46F0E47FD48E3486A005D0BD802F0
-      1F002575B1D3AAB5390FCA7B7DBC3B559DF18AEEB3C118F0E691E76472C751AB
-      B13C5E85C8421106BD34D2B58FFCC8B22A9D85D7B814A28F4E376DE62BE39DF2
-      58F95E6A0CB55D017A29696942498E3415746F24693EA799271203FD859F3D89
-      B70764DE6F75E5E744A682349407209F8EA1A8DA3E1A10DEAD8ABF79F2BFD61E
-      5AB286DC030DAC87502995774C301DC9A08246BD550F50DF85486E32B2228527
-      924F1091A3154639A49446825531A6967732A5EEF7D4BCFD059BDCC77111D544
-      0B52BC3B7FDEBECEB1AA312C6CAD2D74742A63AAFC6F0CAB1141E20F04E54991
-      8EA8A3D262BC24031A7F5F56A36D23D936935E3D2E52AEBA83EA03A12A0F2786
-      567867578CC8CAB7472E7C6A1E77D7211A6CB6F42F1FA7DB6644A7C62B5FF57F
-      AB874E2A6753F0A1EA9EFDCF7D63775FFFD6D507E3C9BF4DED555B96D59FE059
-      41FF007F16601BB38315E30FAADEA2DFD3D81B795A6E771F3D1FF1C1D495CBDF
-      F246B7FF006FFF001E6E854AA7291468E5C599505EF766520B9205F5320E2C7E
-      9ED08515AF466F2B1D6857A804ADDE48F492D76371750AC74A8170741BAFF67F
-      16F76EABD4595848AF192535A691285B17661FEEA7006A2D7BAAFEA03DFBAF74
-      6C3E227C9AC97C4FDC1DD7BD7034B3D66E8DF5F18FB6BA57646461BCC369EEFE
-      C59B6AC785EC1AC844ABF7ADB0D3113E568D42C8E32B4D4AC05D350A2DA43773
-      D9B4E408629437DB4C53FCDF3E92DC4CD05B5DB4516B95934801B491906BF61A
-      50FA824755CBB970D90C3E452971955F6742F554F261339415F33C52CB44C925
-      14D4F9181B55354097F7046796623496E57DC82D22DF1772944AF0F9797518CB
-      0CF0B2AB835FC47CFA1E7A6BE4857CD590E2F74D3D2556768DD66A4CA55D3A47
-      8DCECB25A38864A9F4AC74596676602453119DB98A44A9B7903DB8EDAB131788
-      F97A742CDB77D69161B7B86D2EA28BFC2DF327A36BB7FBCFB0766651D760EE4C
-      8E07155F54995AADA749BCFEFB1792FBFA27A69EBCE2A64928A96B7C4D25154B
-      B531394865F05523CCCFAD98E37531D2663F2E94DD4105DEAD71E0FA7433C999
-      EB6F9C50D4E065A4DBBD73F26B169B662DB7B9AA7F82ECFDB1D838FC6E326C7C
-      D83DCD411A51C71655E9A8A34A5C843033F9523494B898057E48A39F432F653D
-      3A26769F699A278C78966EFDF9C8FB079F459E2D98FD77BB7766C7EDFC36E6D9
-      1BDF030FDBE391A4968EA70D9C82AA3666ACFB68B2105763AAE05F4488B246D6
-      0E8F66D7ED3DA88E25F06E5A9ABA38D6F3A3BD8D19BFA58E9B33DBC370434B47
-      4DB86ADF2F8BCC51490BE4F1B5B4759434EF055B111E469F1ECB534625AB5D5E
-      46A7D6DE41C83FA56C56914CE6E2DE55A70CF4492EE536878A785C3D7D3AB36F
-      821DEFD6BD61D35BB7E3760309B1F797757CA6DDD1E0A8B1BDA38B09D1FB7E39
-      6828A1C6E3F7FE6AAA19F29BBF78EF9C949514389A6511E270B5B2475534E246
-      03DB37B6CBB86E56937D414B68149C7F12AF4D5A24C23B8FA6A19A56028DDBF8
-      A94E8EE7747F2325D93B6B315BB7BB67E30ED1CFE2B6657EE9DC5D69BCFB0B3D
-      84ECCC66131756D4B9BAFC0CF9DD9F87A0C9E2B135714D054C792862495E030A
-      4D1B4F19662DF9962BC812796398CFE2142ACA5082ADA48A30A1D06B505C3035
-      EDE153B6E559ACEED514A988AAC85C51D7C22A18C9546D5C0A94210A1072C334
-      D6B65DB355B00B487234D9FDA59AADACA16A3C349535591C1E428277577968AB
-      E286432E920A0F2113476FD4E3531C5CCD0CC7511A49E896DE19ECE4470C7C2A
-      FE5FECF5639F0CF797F2EDDB3D4FBB770776776766E27E44E4E29F05B6B66EDE
-      EA3C8478BDA9164F71E371953B89FB28C98B7A6AE8F6B99E48CC15F410D2486F
-      36BD2F1FB076E506F3753AB59C6BF4CBF167F662B8FD86BC3E7D0D21BCDA4A47
-      E2C84331EE22874FA301A483A8D0354AD067271D5A87C9AD89B9FBBFE13EE6E9
-      1F8D9D55B2365EC29F31B73756E0DC5B9B7F6E3EC1EEFDC74788C862F71E3128
-      6BEB3138CD93B6B6BEEDA6C6422A2B68AAF2C24A3720545A46621BB3BA86C773
-      D57ACCF78C851D74E98D6B4F3F5F31FEDBA125E6DB7135921450A8C350208350
-      BE7C2B5FCE9F2F3EB57DEC7EADAFD8980DC196DF1BB8ED1382AC9F1D474B8D8E
-      6AF9370E784F2C18AC5E33C14C686B292A923F24D3BD5A78503FA0E8F638B475
-      B8630DB42AEBA7A07DD3B5ADB3CD3B15395E83DDB3570D4E06965A748D63915C
-      CEB18BBABB3B4AC4B1FDC612EBD4FC9E5BDDB7A8522B9B758EA10253FC1D7B68
-      95E6B34965F8FA78981943B370193D6162572C392CAA81035CFB2DE8EFA6EAA9
-      02F0EE222E55FD680307003B03E34732388491FED47DEBAF750A529181E27177
-      D6E1FF00CE5D4EAD4626FF007581AB4F1F81EF5D36BDF5D7E5D34CC8559D8297
-      897D3114750E1C9BA2EB942F16B7D2C47BD336918E3D2840AEDA6B9E9A6AA821
-      5F24727959D6F27981789E411116524B33A2683A4A1D480FF81F7AD7DD4F2E9C
-      30F6D4367A45E40324CCE5CAAC62465170A123BEA790BA297935203EA4B10073
-      C7BBF4C748BAD9D99DAF7925BA3BA3C0433B82D19208D2950594A8FED103D5EE
-      CABDBFEAFF0050EBDD243233BC8432DD2CAE91056664555251E2FA078E12AC12
-      CCFF00D5AFFEA57C0814E9231ABFD5FE7E9B695935E8F8A9D242B6525CAE9550
-      F63E863F5525AC42802FA88E39B28F66F0A8007770E90DC48D88CAF61E93D541
-      4B30F573CD80F51F482C3F2393ECC2162AA081D0677040EED96A7A746DBA5FE5
-      D6E0EBEC751ED6DE98EA8DE5B568121A7C64A9511C3B8705471711D252CF5024
-      83258F8940F1C13B2B44059250960B1AF367B5B65BE4F36E7B4DCADA6E6F971A
-      7547216F360328EDF8996B5F88A16CF52B7217BDFBB72ADAC5B3EFB6A770D963
-      ED4CE99A141C114B543A2FE147A15E01E9DBD1DFDBDF2ABA473542D551EEF8F1
-      F5A3C264A1CFD15462320ED34D1208D9B53514E29BCDCF8A793D0A5BDC3B7DED
-      BF3759CDE1B6D4D244D5A18CABA6037FB71AB4F9A0FC3D642ED9EF2FB7DB8DBF
-      8E9BEF832822A93A346F934D3E68D4AFE176C77742A6D3DC98EDD9929F39866C
-      6D5C75D84C7D23D75166A972B5503D3E4B374ED475741475F594B1225D9D6605
-      5A4690A36AF18501DDCAC27DB2D63B2BCF114A4C4E9319406A919A862013E946
-      C2E907CCF42ED9372B4DEEF5F71DBBC396392DD03149925234C932E8744770A1
-      7B8EB193520FC1D2D8190C6F68D217D327A6762D1AB2B83C952A97541C1FC7F8
-      FB263A6A0F89507F87FD9E848BAF4062803FF83A72A678997C51AEAF244B1B49
-      2298E45A957F294055A2592494B853C7FB0BFB4CCA63EF7F26FE5D2E86759C24
-      030AC29ABF16A5CF48EDE9D6989DEFB7B2B435429B1D97AAA2A8A5A4CC474627
-      AFA699BC6918AC483EDEAEBE875AA34D4EF22C4E16DEA207B34D9F98AEB66BFB
-      6963065B5475263AD108FE8EAAA83F151C0A8E88798F91EC798B6EBBB499C437
-      B2465526D157074E35D285D357C684D197FD2F486F8E3519FA6D9D9DC1EEBA4A
-      6877AEC9DD155B4F39E2A9A7924C85361A186A301349F6B118E154C3E4C45026
-      98C78624F42D8FB3AE7F4B29376B4BCDB6663B4DE5B89E3AAB0D2656D320EEF8
-      BBD35371C96CF449ED3B6E49B16E3B76F50A0DFF006FBB7B5988218B88541819
-      A9C3F4DF4A768EC031D0FF00599E8286BB6CD1BE36AEAA0DC9947C2C55547015
-      8B1534989C8E66192B8CAC4227931CF08906A065A844D0D716044360F7115FCC
-      2E423C11AC94272E35A2103FDEC1A7A027575225E6E3F4973B4DB9B6778AEE6F
-      0F5A8C467C37914B7F086D0C95FE32A3F1749FECA5ECAA9DBB1E3FAAA1C0C3B8
-      32D253E3E4DCBB8EA216A0DB58E6150F3E67F85F82619AAE6781208A35475479
-      9A428563D05EE5E3CBC9B83CFCCAF336DF086711420EB99F148F5FFA1AF712CC
-      482D4A2915A82AE6DFEB6C9B5FD27262409BACCEA8D3CE468B78F4B6A93467C4
-      7D4150250E92759040D2D4DF9EEF5F93FD57BEB278ADD5BFB3A770E2AA7C393C
-      265EBA83706206972E882801A9A0A58E740AEBE110482328C34F1EF2D2CF92BD
-      B8E65D96DAEB6DD920FA1956A922218DFF00DEFB5CE9E06B515D5F1758257FEE
-      57BC5C93CC77965BB733DC8DCA17A490C8E9347FEF07522D7E21A341D3A694C7
-      565780EC9CE763ED8D97BC31949B971587DD984A2DCD2666917115188D9DBB36
-      C66A971992C6C7FC4245AF8F1D575B8E94CD2242F13D1D54AF71A26B63E5DF2F
-      5972FEE7BBED77135BCD736B298421D6249E19A32E8EDA7B0BA871A455595D14
-      6752572FACB9CB72E6CD8F97F7EB28AF60B0DC204B9328F05E1B5BAB69923923
-      1AFF005046C51F5B00418A4735147D244FE5DF5564A83BCB776E88A872126133
-      58DC4EE65AB34F57538AA8CE3D0523E5306F95A28A1681668A8EA2449AC87559
-      0E83A8A4D1ED7F32DB4DC99B5EDCD2A0BB8647869501C47ADB449A0B674EA405
-      7F3EE1A6B8D1EF9725DD5BFB8BBEEF315B4ADB74F0C73EBA33C6D3684F121F11
-      02D3505720F1F2343520F7FC14C56376B6D0ED3C4AC15D491E37B52A168B1B5E
-      905655E2659F6A6DE9AB31F2D7538686AA5A54768D678C98EA214120FD76F70D
-      7BCF7935F6EBCB578CC8EF26DA2AC9A807026934B8072BAB8E83946C7E1EB23F
-      EEE1676FB2EC3CE762B1489E0EF4691BD1DA3636D01285C76B94E1AD7B5C00EB
-      C7AB08C1E3696A60AA6A84A626595A380C6421D2354F21999849706240073A59
-      BD3A4FA7DC197374E8CBE103A40EEFF63ACA6DAEC62B8B6691C2D59FCBF6E7E2
-      FF0057E5D07795EB7C0FF195DD790A66AD95EA68A7A99CD756D3D39931F415F4
-      117F907DCAD252C03199299E65812269D823B9729C1E5BEFF79F4876C81D1235
-      05476027BDD1F8D2ACDAD174D5884C85A57A0DEEBCA7B5DB5F26F973099A42C8
-      4F7BA27647226AD15A28F0DDCB84505FB59AB45D200765FCD1E97E998E871541
-      24BB96B6AA548E4A2DB791A5A91498C8155674AF9DA7ADA982BA24688C7054A4
-      0B3249757E1FD8DF977DA4E6DE6BFA8B89A96D0A9399830AB9E14140AC1B3564
-      D5A4AE46475177377DE339139045BD85BC4D7531651A20903E845E3ACEA76054
-      69D2922A6B56AA9C1E824C67CC1DAFB777E765F6BD3CB9CACD9199DDDB21EA30
-      BB7315B732598A8A3A3D8D8DC351D565E2C9EE7A2ACA14A96D69249454952231
-      4FA0C82528EC26BAF6A771BFD97977965A38537986D6E544933CA8819AE1E421
-      192120D388123A54BEA51A352F51EDAFBF9B6ED9CCDCDBCE701B97E5EB9BEB42
-      F0C090BC8512D1234322BDC214D5DC098E3934E9D05B590FD18FCA76AC5DB3B8
-      B094D80EF8DBDD6D8ADA790397ACDBDB7A925DC5BBF72C298696A70867CA6469
-      63C1A617231E4E1AE78E583EEE9954230F294760041CB4795B6DBF92FB9227DC
-      6EAEA3D092C87C38216F100934A21F13C442863043E87C918A8EA51BBE7D7E77
-      DE36EB7DBBDC5B5D9ECAD27F11E18478D7338F0C98EB23A087C37591266429E2
-      250061AE87A5E6F9DBF9BCBF7AFC50C8E42BE9AABC794ED1A979E85A830B591F
-      87AEF2229ACEF939B275F055CA53C94B4F0B53858A490808DA509B65BFB2B5E4
-      AF73608212BAA3B45A1D520CDD26AFC0A8A47E17275E40D448A916732ED1B8DE
-      7B8FECC5DDD5D2B8597703AD3442F5162FA78B9770F8AC681930EE42A9A09FDB
-      DD41D9FBAF0999384DE10FF18C4CF435F85C4E572D91831B909292AA7C861D72
-      9352D152475945067E04AC964D2D3A7DA8A78DDA370119E56E6AE5EDB6F2D0DE
-      6D0DF49223A4AE8885D35284934292D4668D8A01C3BF591A854BFCEBC97CDFBC
-      6DF7DF41CC005E42E8F1C724922C6E41678C484220745942C8E7E35F0FC30741
-      A290CEDEE82C2D4746EEADCBBFBB2F61EE8C87576F2A7A6A0A6DB7BEB75623EE
-      ABDB273D66E6A1CEEDCDFD91DCF0E2B78E6DAB6733B782059A630C11A7F59A79
-      5F9E6ED39C36EDBF64E5CBDB68771B4624CB6D0BD1340584C725B244CF047A46
-      9EF341ADCB758E7CEFEDAD84BEDEEEFB9F31735ED97B71B3EE01504175709ADD
-      642D3A4B05DBCEB1DC4BADF5F626B25110745F717F317B830FB876B5775DED8E
-      B2C0E371F9EC5D652EDEC967A873F91CF64F1F5F5D82C7C998CBE4F7426568E3
-      ACA5CFC9421685E9297F85148C5E92042839B8F6B3956E6C771B7DF6FB70B89D
-      EDDC1912331A468E048FA1121D0DA4C6B27EA077F1AA7B6473AA37B4F7BF9DEC
-      771D9AE396F6EDAAD6D12747104932CCF33A3BC3178B2C93F888AEB3187F4592
-      3FA7D2835431AE9D817A0FB16A3BC7A9305BEF27B7B1FB772B2CEF8FDC5B7E93
-      338FDCB4D87C852C69347538ECD62EA27A4A9C66571F5B055D30675944530561
-      71ABDE11F3A72F2728733DE6CB6F7EF736AABAA391A3784B235574BC4E010E8E
-      191F4AE9D42A3B7AE917B71CD9273F726EDDCC177B74767B812527844893A472
-      01AB54722120C7223A491EAEF5470AEB5E9D771E11E1575A7983BA47E36D2D4E
-      D168D21E482154061479E9A5246A1A4DCF07EBED2585EAEA8D645A67E7FB4F96
-      0F46BBADBB456F73A1EA341F4A7FA5FF006C3FD47AAACEE3F8F1B7F74FCA1E9F
-      A85FB5876EC5B177CE529B078EA5829863A4D8D5584A7C752D35426B916861AA
-      DCF0C90C055569DE0758CE9701325795B9EAF6C3DBBE6745AB6E26F6D90C8E49
-      D7F52242EC47F1910905F57782350D43385FCF1ED7ED9BEFBBFC8D23684DAD76
-      EBB904288ABA0DA342234523F0069D0A253B341D0D4200093B1FE0E52EEBCF6F
-      0DC15191DC592C8E60D64FB5E77DC78FC760B014905563FF0084622A8D4E072B
-      91A863452544634268D4BA8F8EF7227D8BDE17DB2C76CB24B6823823D2B32F82
-      EF2484ABEB71491107750E4D7BB4F77C3D01F9AFEEF11EEFBAEFBB83DC5D4D73
-      36B36C7C7448610A57C389EB0CAE7B35AF68A6A156D15D4DCF7275B45F1EBA1F
-      776E25D87B3707B87178AA544C8E2EBF239FCB5465A1968F11B67395757954A5
-      8E9FFCA6BA496AA0A788248FA0EA21485F586FEDCF3CE9B56DFF00BE6F26B392
-      63D8E891A04A179A3554D55C00119DB0B5F3A1EB7B9F2B0F6C7DB9DF3761CB5B
-      7DB6E714283C44779A4690688E090BC9403B9CBC891AD18E93A88A8EAAADFB3B
-      B16A33EBBAA7DF9BC5B712F8513371EE2CB43918A38BD54F0D3D5C5531494F4F
-      4847EDC4A56345E1540F791E7977614B2FDDCBB2DAFD067F4BC3429DDC6A0AB6
-      A63E6789FC5D62247CDFCD2FBA26F337335F7EF30CBFACB3CAAEB4E146046909
-      E4BC00C050BD5D2FC46EF1AFC96C2DC3B8BBDB79E4F13BB705B8293093D7EF8C
-      BA6369B3188C8E2C1C3D5D36DFAF38C5FE2509A49219EA238E49A6108776BEB3
-      EF123DCEE4EB7B6DEEC6C792F698E4DB2780C8A2DD3598DD1FF50348BAFB0D41
-      0848035517CBACF6F677DC3BDDC397371DCBDC3DF658F7AB5B95859EEA4F0C4D
-      13C7AA37103E8D2E34947700B9D153E7D18DCB77D6C0DFFB82A7A8715BD0C877
-      2E06B71B90CA6D7CFE32837061EAB2147251A53ED9C8A4951365F31E1598B251
-      24F3D0A47771EB4F604B6E4CDEB64B34E68B9DAC8FA7943A24D1BB46EA86B599
-      30A895A65F48909ED6C1EA57BBF73797F982F5B92AD373D46EADDA3792099126
-      8D9C695581EA7C4929ACFE98678E9A88C8EAB77E6B751EC6E9FDC5D6F80DA145
-      B8A91EAF69D75765B2F96CCD6E724CBD353E4FED31482AEAE3128A8A67328910
-      35E38A4852C8800F73AFB51CCBBBF3458EF97DBA4D0384B9544448D6308C52AF
-      818A1EDA1F32A5B2D5EB1BBDE6E55D8B95370E5DB0D96DAE501B42CF24933CCD
-      280F44EF7CD53BEA3576A94E029D178C2D3D4CF05387924F29BB09BC244DE6D1
-      1B9814047BA807FB576D37FF006031BC648E590AA76FA7CBD7A884C3E2A1461C
-      7CFA17F0B878C408B31496A8304968E010AC3E222F0988D55A408B1EA450AE7F
-      D6F656F75A9EAB1F6FFAB8F5B8ED84284870D4A7429E2F12B31954537895A193
-      C8E916B7D61892F34B314D3A80F4A92CC02F03FAA76622B27957A7CAD4480495
-      EDEA94BDE43758CFD7FFD7D4D7E3CE96EA5DABAF5B08E4CE84443A0877DC5922
-      191D7836B723EBEC0FBC8FF76371F62FFC757A92B97A8DB45B2FE2EFFD9ACF42
-      E54C8CCF205705D99CB0327A0BBDA21A989002858D49F68470E8C1FE27FF004D
-      FE6E9A91B402FA1C80A1346970BEA7219C6BBEBBB7D2DEEDD6FAC6C5A4767501
-      3EAA40BBB060C012CD1ADD6C05BDFBAF7598C6A341D251B431490E9F10096620
-      B11C3AFEA0BFDAF7AC74D76FE3F8BA8D93DBAF99A3A5A17AC8F18D14E2A20AE9
-      A245A59A1A8D26A29322B1A1F153CC630D1CC14BD3BE973C6A1ECD2C7715B6AC
-      6CFF00A67CFF0087A26BFDA1EED649156A7E54CFF4BFE7EE8ABEE6C0D461373E
-      736C4506521A6C8D752A31F3015B149583EE696786685FEDEAE82AE7903A2681
-      1C8534FF0053EC4350F178B4AC7D031ADDD26681FE33D2931FBE72B8173B3F75
-      BCD2BB411C94F5D2868E0952689638CC532EB68DE5A744D6598AB32147FD3AFD
-      A7BAB785951E07AE3A3182F648878370E529FE4FF67A381F18BB6FA62BF76C9B
-      2BE44D1E7E9132AB918362F746D1AF6A5DD5B3F35571434F8F8B79C5554D918B
-      73EC54923FB79DC78AB31A26F2091E155B16C893889A581C2B28E07FD9E8CAD2
-      7B391E61748C6329DA7F3F87A30BDBFDFDB5773E0EAB606556ABB337D6CCCAE4
-      309B537DEDD9A06DAF5185A396344CE4F94AB8AA32D5FF007FFBA5A1A614B404
-      C68E41D6CC1B0D1CDFDA005B4F5E86DDEDAB24591E9FEAC74519F7656CEE617A
-      890472E98E4811C0826642441A910DE654238D6CEBAB9F772A05291E95FCFA72
-      4FA89DB5C8BA7B7E5FEAFCBA95FC5E660638E6911A26F3C4454AA146A67D0935
-      3BA32FEED3B9F4321B86FA7B7D1BBD0B701FF1AE90BA0ECD3DACAE1BF675B57F
-      C7DF9DD9AF967F19B69F61F6B6CE83B2BB6BA6F1995E87EE2DFB42301376CD4E
-      C3DDD82A8A2A4DC006E3862A4DC547D99B768EA286BB20249EB71797A433471E
-      A953512DCECA93BC9E1C84C6CE5D00A88E373F16B1C187A000E6BD1847BFCD65
-      73637234A05D48CAC01668981C44C2A57571352356357558992F89BB67BAFB86
-      BBE3F755D0E471990C1EDFDDDB9713B7A79E98EF5CCE228A0FEF2D33E4AA656C
-      4E224DC94BB76A28AA25829237815639024403108BE5BB8ACAD1E4BD7D520650
-      580C67F0D3A7E3B3BBDCAE960B14ED22AA0E9AE3EDEAAB771741EEB39FDE998A
-      DC0E4F3D80EB6A6FE23BCB3782A09D76E98269FC38CA6AECCD3D2D2D351D564E
-      54683C51A6B8592605D3C2D670DD21F0EAFA55C0FF006CBF87E1AF4925B278CD
-      DA140DE076BE2946FE1F9FE55EAC57E0DFCE9DCDD6183A4F8F5BF23CB673A724
-      6A5A8EA3DD199A6C8E76BFA2B7166D84B2ED5139D3266BAF659EAAF3D318649F
-      11547CF147E3F32129DD7614DC9669D57FC693E129DAB27F8339E27A13EC7CC0
-      FB71836CBDFEC59789CE8FE82FC5456FE118C755A3F327E406E6F991F21F3F4F
-      B2E8B1957D69D6B36531FB568F6A632A71F43B90D14F24355BAAAE95E491EBF2
-      B9B99668A96431C4E31F1EBD09793D88762DB5368B2642F5BA916A59BE21FD15
-      FF000D75740BE63DD4EE97F544536B192053E17F991FEC7492DA18ADD551051E
-      DEA1D8BBCF2394C763AAE7A9A1A4C2AC72C74D44F24B3544886B3CBE04572EE4
-      A8039F69B7A85AE258AE16648C68A777C3FF0017D2AD8AFF00C3885ABDBBBAA8
-      AE2A5BF3D3D3B4E992C6C543FC4367EF5C657E5CA8C761721B532D4791C87DCC
-      BE0A59B19054C5147594D553B684303CC4BB0FCFB2A8F6FB87EE1731953E82A3
-      FDEBA3C6BFB642C1EDA556FE96AC7586BE1B2DA654D51BB2B461AECAF0C852A8
-      2B432B4323A1465055994B0F6CB4722CA6264FD51D2A4952455915AAA7A619C6
-      B99C38792292CA155594248A1746B48CF8F52ADFD3FE3FEABDE88A5411D3E846
-      915F2EA03BF89A4903349ABF4A2A5A28D914156596DAB43116FED7A47FB6A32D
-      68471E9444E11AA7874D35D30D63C4D109A652EBA9CCA208D5544B244D246D18
-      470BF566BBFE3FAFB6F43569E7D3DAD34D75749F99A078E68D8C723C5AD5DC3F
-      8DC1757445749152DAA422C9A7D22F7F7AEE5F975E558D8D069AF41E66A744AA
-      89AA609D8D802D1BCC1237D4C922CAA0C46584DBF55BFC79F6AE256752A8074C
-      C9A56635F841E92D91A785E38E586391C4F268D5E2D3C8D3ADD1FD0BFAC9FA0B
-      1BF3F9F6AADDE45275BE157FD55E9BB8F08E8F0FCFA43D542468728E7F5105F9
-      22D6B9210DC5C0FF0054C7D9D44E1AA01E8AA58586991D2A17F11F4FCBFD5FE0
-      E854E81EB2DB3DB9BF8ECDDD19BC9E0A9EA70790C8632A715F606AAAF218E6A7
-      95E88C55F0CD1CE1F1E66900167BC7FD357B0F73B731EE3CB1B18DDB6EB38E67
-      1322387D7A423D457B08A77E91F9FE5D08FDBBE50D9F9DF993F70EF17D3DB472
-      5B3BC663D15778A8DA087535ECA9F5C747273BF01F60D263EBE4C46F1DEF5B91
-      FB0AB38C866870222A8CA0A795A8609C2D1C3E3A69AA5516462E9646BEA5FAFB
-      8A6CFDECDE9EE215BADAED12DB58D64789A826ACB2E4E55723073D4D9B87DD93
-      9692CEEDECB7CDC5EF7C37F0D1841469349D00F62D017D21B23ED1D03F17C428
-      136ECF2E631FD8985DD547511E367A5030595DBB515120C1443254197829A996
-      AA863A8CC387846A974D2CFA1DFC777163FBA4FF005EAB6D73B7CDB638D60FEA
-      24CABFA9D8E8C4D1E88B43F0F7A6A0B5C4783D8A5FDD4EF7369BB41BD46EA8C9
-      FA324049F07F5124541A92B236A4F8C7872509A64006EADDEDB132B9CA3CF506
-      E8C0E4E89A3A6DBD9CDBD4755554794C83D749494B252E5A9B278D56C05490ED
-      354409533C2E918F1AB315F6375E63D9F7BB6B39EC66B69EDDFBA48E46505129
-      56AA323D241E484A29D4D9614EA2F6E4EE63E5BBDDCADF72B6BBB5BD88810CD0
-      A928EFACA06491244FD139D4E8B2321541A01623A3ADD2195EE1FE391D347BD7
-      23B936C525496ADC6EEF153985A6C4ACC2812693211E2566C6553CE85E1B5502
-      EAB7309B3B7B8939C2DB95459BC87688EDF7075C3C144D4F4D54D1AFBD74F1EC
-      C70D791D4FDEDEDD73DAEE69026FF35D6D2AFDE97359A91D426A2E23AC658EA2
-      9FA9A8D2BE19D2DD1F673088699446F0BAAEBA600812C13A309277D50AAA4601
-      93F246A0785F7090AB3B568C3CFF00858797592380128A55FCA9E47CFA7AC603
-      2B4D5124FE4917F6E40C74C41752B3AAEB6776629C90DCAFF5F68AEB4AF87184
-      A2FF003E8DAC49746679753741DF5E0037DF7AA53263CC3FDF5DB7497A3A6586
-      ADEBA0D9387A7A97ADAB23557552491FAC227EDA681FE2C7DBF90364E4C3233E
-      AFA390E5AA28D3C8C283F08FCF39E82DCAC11F99BDC730A47A7F78C03B1686AB
-      69187A9FC6F5E3E98FF4CCAAEC7C0E5333D7FBB31D80929A9B3F0D0FF10DB191
-      A8891960DC9B76A21CD61EAD4B07590C591A08C2694FA35ACDFA58AF61BCB7B3
-      DF76C9EED19EC0BE89915BE286452922FF00BC31F3FD9D1D736D85D6E5CB1BCD
-      AEDECA9BA087C4B676CE89E161242F4D3FC483F0FE2F3E1D162EC7DBBBC7BC3A
-      E7A7F760DF557B7B1D3D652E5B7C64B6AE46B76F5253ED0CF514190A9DC15D8B
-      9E5FF277DAB5D8B4728EF222D3EB910DEFEE45E5FBEDAB93F7FE6BDACECCB3CC
-      A852D927412169E3250461C7C5E32B9CA8524E907A89F9BF6BDEFDC3E51E46DF
-      23E676B684B87BB7B5778105ACC8AE67746E06D9E30CCA49012AEA7A063B37E2
-      6ECBECEDB590EC2E82DE35BBDB70431B49968EBF29495B4DBC2B71864A7DC394
-      A6AE74866877065B207CFE33A28EED64D02446F62FD87DCFDDB97B718362E77D
-      9D2D36F3F0154653007CC68505418506357C7EB5607A8EB9B7D94E5FE6DD9A7E
-      67F6DB989F70DD87C68EE1C5D3C789E40F452B3C8FDFA711F92D0306E8FAFC7D
-      D81375AF506C4D8DB8E48E7ACC761E4A9C8C71CF094A5CB676AEB7355B4C9526
-      408CB42D5ED4EB62A1EC5BF4B7B8479E37D8F9839B379DE2C908824974A7CD23
-      023069FD3D1AF3C30BD64E7B63CBA394790F96B97373995EEA0899E41C556499
-      DE67407F12A1764F9F7379F423E671B4194A4FE1B534F3C0CEC6BA9B39245452
-      3EDEA88A094AD52540B0D34D1B3BBACDFB12433490B9D0EE090DA5D4D6D2FD4C
-      6CA42F618FBBF506A1DB4F9E3E1C82A1D7B806E85B7F696B7D6C6D242C325D27
-      A0FD1201EE07FA235575F63A39473A491D069F1B29F0B87A7ECBDBB808C9A3C2
-      F603FDD97F14922E4EB3018ACB575334C2928BCAD4D5158123D6804712242348
-      45F626E7F92EEEE5D82FEF8FEACD63DBFE904AE81A9534D4054E7258BF9B740C
-      F6963DBB6F879BB68DB135416FBA67CDBC4786391D49D09AA8CF415184013B69
-      D2D775FC8AD95D61BB313B6B74EE0C6E067AEC7BE6F2AB957AE852970626CA22
-      CCB531D34941254CDFC35DE2A591FEEA6485CC313B88D1CAB69E45DE398B6DB8
-      BFDB6CA49824BE1A6855CC9A53E7AE835A8670BA1495D6CABA980837EF75360E
-      4DDE6D365DDF748EDCBC5E33EB2E0243593B8151A2A741A465BC4750FA017D0A
-      E5FF00E5F77549BB3A8F0B88E91AF6DCF06FECC55C195DCFB6EA7250D0ED3C76
-      DAFE1591C9E2B33362C3E53146BCE6608E5FBD6A548E9D9F5E9D63D8D3DADE4F
-      1B5F33DDDD7385BFD3C96508290CCA9599E6D688C81FB1F4692C346B24E9A703
-      D451EF87B833EFDC91B7587B7F76F7B1EE73BAC93C2F269B68E0F0DDD26F0FBE
-      3D7E3223F89A004275711D51355D555D6D4CB575B535359572B5E7A9AA9659EA
-      6460025E59662F2C8C00B7A8FBCCC8628A28D638115231C005A28FF4A075CE89
-      E59E799E6B999DE6272CC4B16FB4B67A39DF1EFE21EF0F91FD659FDD1B0735B7
-      E8B73ECFDED4F856C66E56FB0C5D6E2B23834C83D4C794A7C764247AEA3A98F8
-      8664F1F8D890C08D2D12F3D7BA7B5720F30586DBBEDA4EFB75D5A349AE1EF70E
-      9269A68674C32F9835AE28D4EA7AF6C3D8FE60F75794F73DE3962F2D9375B1DC
-      043A27EC8DE37875D75AA39D6A46032E9A1AA9047567DB0FE2C75B756D3F5B65
-      779E671DB6FB4B2548B809A3C46EDCF9C36E4CE632955EB63C1D4E7F72ED66AF
-      132792BEB526D3FBFCC07D1187C73DEBDC8DFF0098E4DFED769B492E396E37F1
-      033C11EB86373DBE208E19B47947191F83E3196D3985CB5ECA72A7275AF2A5FF
-      00315F4367CE722F82CA97337873CD10AB782D2CF06AC567983E9EFF00ECC8D2
-      9A86ECD6673B94EFFF008A949B9EAA9A1DC78ADC7DCF929A5A6C65662F175147
-      9BEB9CC4F85A0C54392320C9D4D1E2E35FBDB9322F983D807BB03ED6D2CAD791
-      FDCA936F563B7C906DE82AEAEEAD1DD22C8EFA3E00CE5BC3F2C115A8EA43BEBE
-      DCAF7DCAF66EDB789917738AEB74918AC6D1C6526B190C6881CF7948D47899A8
-      254E9D2DD243E4D761E3F318F7D918AF93DB5B64EE2C8A9AEAAC563B64E18E4F
-      3F88822ACA8A1C6D6D765379E2EBE8E854452C324B48639AB26609046ACC109A
-      FB75B14F6B326EF71EDCDC5DD8C780EF732E88DCD03BAAA40EA4F0203D420CBB
-      7E204BEEEF34DADFDA4FCBF61EEF59EDDBA4DDE638ED21D73469ACA46CF25D23
-      84E20BC7A5E476511A2B1D26BB7B97B076C61BA8733B631FB9FB473995DC9567
-      1DFC7F7275EE36083358318CFE298ADB6BB9329B96BB234D87C2D736841E05D7
-      43A24A748E4792479E394F63BFBAE69B4DC27DB76D86D6DD35F870DD3EA4935E
-      879BC1484233C8B9E389350919805031839E798B6CB2E49BFDA6CB77DE2EAF6E
-      DF478D3D947A648FC3F1520F1DE77711C6F81D8B58B4BC211CBB92BDD5F9FDB9
-      0BEE29EB1A1A4A19BF854D574F963D6992CA646AA1A298D4AE3A7DD9B56AA6C3
-      51A6581A9FBAA68275A5A51E092395DFCE246E62B1BE61631C2A5E65D6014FAA
-      44404AD3588665D6DA3B34330677EF528A3475167296EDB4AFEF496E48103F86
-      5C49F42EEE4277683730168D049DFE2A23844FD374727C41B27FC1AABC1E47E3
-      EE3AAF003135B83C8E55E6A7AAA1A5C35364649DA96928AB2A371637014B4D8B
-      C266AAEBE8649129E9D0C725378674B2CC88300BDE18AF6DF9E2E62BFF00192E
-      92155D24CA502EA2CA227918BC918460097EE57D6A7B918F5D45FBBD3EDD73ED
-      B5A4FB6782F6124A4A94118727422B99E38408E3919D1CAAA0D0C9A245C3AA83
-      2B92A135D254DD6A215478D1CFD8C3153C8F344B041E496C93CAAAFA492ABA89
-      D41B8F71E432AC2109D35D3FC5A9BF89BA962E6D1A779D341095FE1146F2FF00
-      6DFEAAF55D7DFDB8B01D6BF253E2E4B93F4506F4C4F736CF8C0290B266B2B1EC
-      3A9DBF1D3C7552D2C68995CDD2434A8AE52357A95BD85FDCEBC89677BCC3EDFF
-      00B8EB68FAA6B4936F9FCDBB13EA0495D35F82225F15344C758C1EE8EEB63CA9
-      EE9FB3EF748122BE8774B5C6907C493E90C34D440EF91046BA8A8D4F9A67A12F
-      746D3C9524392CA475B5B414F48F539DA9A2931BFC696896181AA6AA9205D66B
-      5E6D2A5A08A02114B98C44FE9404DB7EE56931B780C08ECEA23075F875CD037A
-      7FA666E3A6AC471E84DBBED73DB5B5EDCF8EF118D9E47431F8DA748D4E83F193
-      C4A04C293A023F68E891EE687B5BE41ED2DD1B4E2D9583DB7B5F7ACF5B042DBE
-      9F218DCC613018F469F01B9EA68E9A85B27515993C9C504F4B4B23E3E4A5D0F1
-      CF0C8843FB9776D6E59E46DD2C3736DDE69F71B4009FA608E9248FFDA44AC4E8
-      5088595DD4481EA0A3A9561D63C6F11F3AFB99B36E9B32EC16D6BB3DF9703EA9
-      9E392185330DCBA04D6CF238478E32D0B474292A15657E882D57C05F92789CA0
-      A6A3D8345BA2957292534398A2DC5805C0D452C6B0352D5CC6AB21475AB4B903
-      52A5534A49E8742032DDA6A4F7AF906E6012CBBEBDB49E154A98E4F115BCD451
-      196A94FB32AD561D63B27DDC3DD1B6BC5863E5A8EEE2F1485912687C12A3E173
-      5747A3EAF87B4F69068475693D19F0663DBDD5B0637B03736497756759ABB77C
-      7B2B218A8B074D1C09570D361EA7395789CA4F99CBC304F2473D58955912F040
-      523E64C73E70F790DEF31BDC6C9631FEEC87B60F1D1DA435D2C5D630E8B1A120
-      109A7B8F7BD4E17307913EEF7FBB7946DEDB986FE43BD4FDF75F4AF188852A04
-      66431BB49228AA3CBAB85638E89F1196EA3F8B7D41D615D87ACDB38FA8A8931D
-      07DA40B593D0D653D2CB2BCF3C3542A4531C8D456D2C123C306B9E448FEA8824
-      BBFB8E799FDC7E68E638AF23DC2E40590D4E90549E0BA74D74004E5A8016F84B
-      118EA54E49F68795B956F36E96C6C4B342B450FA1827121B5519C951DA952547
-      1014E7A2A1FCCD76B4F00E92DC505323E129F21BC719513C24C314B91CA2E1AB
-      E8D24D323AA89A9B1CE51750D6F1B7B91BD80DC958F375834C7EB0A40E01F244
-      D60D3FDB3AD7F854F5177DE93687897922FA2B7FF100D3A310B8D6FE13807ED0
-      8DF6E9EAB9318B1445E9DFCA591199CB45E24D46411848FF00715E5D77FA12BA
-      ACC3E9EE7867046A1E7D62632C65867BBA137091C9A61AA8E11AF5929142C59A
-      1D30C4A5155432AB1D4E427AEC7FB3A4FB412B004945C7549C7C3F9FF93A1431
-      2448648C34CAD3D34CAB38D711489627022964498C2CC0C60DC8F51FC5AFEFC7
-      E03F68E943AA88A4D28BF0F5471EF21FAC5DEBFFD0D4BFE3E968FA936B48B182
-      ECF9D09794A792DB972808D0A0B3585FD5FF0014F60ADDC56FEE01FE8FFC757A
-      90F97DF4EDB6FF009FFC7CF42D49E3D66D18D064B4891B8F51700906C09650DF
-      5FECDBD97F46ACCC68CBC3A8EC58346EB26A1A2FA0A4454F24D95C6860854AF1
-      FD7DFBABF5898B00C63D4C586A29088DE4B05D41953F412CC1979FED0F7EEBDD
-      4C580CCA51C953FA99195090DA2EA0EBD475213CDB83EF44D298EAC9189456BD
-      65A9B414FA147F9C27F5DFD2D7055DAC4FA0850BEF4326BD3AFD91E9E815ED0C
-      2D4E7D70CF8E8659F7051EB4C6968E791AA286228ED424C41DD20333068EDC47
-      258F1A9B51D6D33988B89DD9A1AFFBCF412DEAC5AE046F6B07EB28FDBD345375
-      FE7335494790DFEE98B9E96231C54B48B0CF97A98CC9AFCB535719968B1BE540
-      A3E923EB0C7863ED65D6E76C24296A758FF8EF45D6DB54F3E86BD8F450701D2F
-      E930386DBD8FA7922A0435521D7022D52C954B4A58286CB4F24B25622CE34D96
-      4542DFDAF4F1ECA6699E447D38D5E9D1B08638C05D208E9DB2672D81A1A57A88
-      71FE2C951B4B4B494CF2A786197D352B51053146F3C9E91FB8E4AAFE91CFBBDA
-      8A4AAC7F869D59D5D1E853B7AC78FDB993C95351D6C54D25151CD4EEF553D797
-      8E387C3AFF00CA236D06434F394B2E953CDFDBFD6C073F046A7A9D16324A7435
-      95733489020829D8E98C5595912568692294191A38B56B72458A37F565BFBE47
-      8748268446BAFCEBD599FC0BC36E4C36E44EC9ADCC63A4DB993C5D5607756C4C
-      91CB629729B49EF23D4996281227ADA1C851A55D1B96F1AC901BA30362D5C6E3
-      1DA4B0DBB212CFE9D2A876292FE2BC170CA8FA1747DBD1FDEF3D8F49D63DE1D6
-      FDADB832D8DA6A77C6ED7C56DFEC0DB79E8372E6779C386AE3262F70E16AAA70
-      14189ABC661E80454D5D3BC556D538A2359777251CB8864BBB3BE099693E0F9F
-      5BB6B93B76E1B7493A9F0E1347D3EBFEA5E8A376150EF8F95BDEBBA65C16D7DA
-      98FC8652B576F516CBEB0CB51657258FA3C2D0E36917292E736F07DB15343BC6
-      6A692BE1D114932D6D5FED910A695F6DD636FB7EDFFE3F721020AE78D5BCBECF
-      4E94DDEE8DBBEE53FD2DB06795A8A83E370BFC5D33EC5C2633119E34B558E8B0
-      D5DB7DDF07FC3EA69BED32D47353D5CAF93FBDA395A330E79A4AA682A26F1C53
-      4810090B003D9BA69897B1C38AF156C7EDE83D7372CD7936A848684B543E0D7D
-      3AA5BEB5DA1455759BEB073E6EAB6FD6CFD91B8E9526C5991B2714D87AF7A4A6
-      8129E8278EB34A79A690B2C6CC00F40FD56532F6E08C285E890B54BBFA927ACF
-      BA51A92A72263EC7DE74B9F34EB6A8873395C6E5AA69E6686092066C96E0A79E
-      38DEE5BC7E29AE7EBF4BFB65D6190E99614703F886AE9D8E69A22CF04AE8E3CD
-      5B4FE5E5D31EDEDFDBF69BB23AFEB5B78EF0DCC30192A7836DCF9C49D2A62AA0
-      8F05223470CF511D63D1D7F85E379096D681FF00AFBB245086A242A917F44690
-      3A506FEFB49ADD31FB727F6F42D868BED63863F18891D85108599637A5A7D4B0
-      A282B2169046031D449D5EA62DF560C4CCCF7F76E3FB20D4D5D0DACC68B5B5FE
-      9203D47955235FB792568E39398D198B4EEF61218D8D9230E45FF4156D36F6D1
-      8C16A963D2C4933463D26EB16392E1434893856F339943C210F9ADA5010B21B5
-      F9D66FFD3F57BAF854FC5D38CE14F0E986AD9161956685677D5AF9285DC47A26
-      81C287D49294FC96B95FA7B6D86934EAFC73D31BB449079650E5241E611C8235
-      8D192F3A461B4DD8B8946A36D7E9FF005BDB6C2A001D3A8ECBAD81CD3A4B5552
-      0A81E695E5556689C424B2E92C58E9F50650D21E57C7A4E93A4FD7DD95CA1A03
-      D5D903C7E279F48DC9C1E0B2AC72D8ABF84A16087C8C595DBCCFCC976F5F0A2E
-      6FED644DA9B3F2E9291FB3A495647E32414064D11997D417C24D8588B4608BB7
-      D7E82FECCA03ABCFB6BFB7AAB0D2BF0669D37E1F3B98DAD9DC66E5DBB5B263B3
-      183AEA6C863EAA06D4F05553BDD5B4B9D1244E015746E248D983022FED5DCD9D
-      AEE56771B7DFC424B599191D4F983FF3F7F0B7E13DDD13C77D7FB4DFD9EF3B45
-      C18AFADE4578CAE6857FD3629E447E2524756F7D2FF27F62768D363E87275F4B
-      B5B7EAD38A6AADBF9499E2A1C9D4DC31ADDBD909408EAA39DC1BD3BB8AA8F95B
-      381ADB1779B7DB9DE797249A7B785AE765D5A96445AB20FE19117E1A7F1E9D07
-      E2C363ACD4F6FF00DE1E5BE718EDAD2EEE52CB993451A190D1253FC703B76B82
-      DF818F883E1A11DFD4CCFE13B6A3C7F6156E6371A64850474757B5329B7169B6
-      CE6A3A2A4A2A6ACC9D4CB4B5B155E16338FAA85FC28F2015AB23A492463C6518
-      B4BCE57371CBF15AEDDE197D42649AB326A2C4200C2921D60AEA655FD3A0201C
-      AB3DBA6DDCF70DA7344F7FBB78C91047B692DB45BCDA11017255EB1AE8607402
-      DFACACE1DD3B0816F19599779592B5317F662B2BCD1CB8BAB8A78228E3AE8D29
-      63AF334EB3A651B5B254688DA984919557B9B7B0D5C456A62468CC9E2B2A6A0E
-      34B70D4DA28BA7479A54EBA1E1F8BA14D8DDDEFD5BACFE0B4224968D1B6A1A55
-      E803D5AA24E224A298C38E39A74D9BA77F494581ADCAE06924CCD553BD1C0B4D
-      1E38C92D49AD6A96792968E49B1C267A7868667998C91240803B929ED5ED9B24
-      735F456B77308E23535D74034D305B4BE9AEA0A348249ED5CF45FBF7344916DB
-      2DDD85B3CD2A1455010B31D64E55094AE95462D528A806B38EB275BEE2C9EE9D
-      9F89CB6429AA229EB639EB262D8E4C3B4B4D254DE0A95A035F90923A7A9A4D12
-      467CD2210F707DD77EB0B6DB776B9B582505128ABDFAE869DC35E94A90D55380
-      DD6F95B73BADEF62B3BFB94612C8093AA3F0F15ED3A35BD14AD1877B06AD7574
-      0E7767CACD9BD4B87AEC46D3CAD1EEBEC790C9150D1504EB5988DBB368D295F9
-      D9E267A53353120FD9A33CF2385593C51966F62BE51F6D776E68BB8AEF72B77B
-      5D81724BAD1E41FC118F8BBBF8C8000C8D4DD01F9FBDE9D8392EC2EEC768BB8E
-      F79A5B504443AE3B734F8E661DB51C7C35D44B7C6517A49FC0CCFE4EBF617676
-      732D5936432791DFE9592E472553296A8C9D461E09A795E43A95E59A49AEFF00
-      F061F407D98FBD5B7DB45BDF2ED9DB42B1DBC56246840308AED41F67449F76FD
-      CAEE7E59E71DCAFA679AF26DD0317727B9DA305896F562D9FB7A3EB49594B570
-      A536B8E32AB760174B789A459245BB31D459B8FC69FF00695F70B3C5242D51AA
-      AC7FD8EB24619CCF18A9CAF5595F23B2FD99D5D4BBF7AC36BC1B676AF5AEE5A4
-      CAEFAC456B4AD4F5D94C0E52A30F43B8B6560E6988A7FB9C56E1AF9EA9691754
-      E94751789846807BC88E42B6E5FE649364E62DC5EE2E3982074B675F89124457
-      68E7929DDA5E3409ADB05D3BBB8F5893EEA5F736727C3CCBC9FB3A5A59F29DCA
-      49771B9ED7786431A5C59C25B1AA399DDFC25AB88DF526945E8A6F44FC89EC6E
-      9BC8D3E2F6CB8CC6DCC96491F25B364A5578F315950F4F124B493D3423250652
-      530431A3C6E4BA0546474F47B9279DB90B60E6DB77B8DC7F4B708E3A24FABE00
-      2ADDC09D0505492A460F76A0DDDD425EDDFBA3CD3C877515AED1FAFB5C9355ED
-      48ED91CD07690BE2090D02A90723B4865C757B180390AEC462F3999A1183CDE4
-      A8E8AA6BF07039AFA6C5E5AA6985455D2FDC859229EAB1F31D2ED6015D3EA3FB
-      385F7D1C16F73716B6773E35B46E55243DACE80D15A9F151C67EC3D74836E6BB
-      B9B1B1BBBEB4F02FA48D1DE3D5ABC290AD4A5783146C337A8E832F905DE9D7DD
-      4DB11EAF7256BE4B7564A9248F03B4E9678E97359A926FDAAA35D0C8B3C98BDB
-      B5285D6AE7D08ED033C503B4CC81445C8BC9BBDF356EFA36F87C2DB50FEA4E45
-      634F31A4E35C8BF122776685FB3A08FB97EE3F2D722F2EBCDBB4DE36F3203E15
-      AA10B24CC7075A9D4D140C352CCF4525198467C423A06FF97CEE5C9E67AEFB2B
-      33969E4ADC865BB36A6AAAEA2A6AEA266BB6DAC0AA44A679279CC7142A115DDD
-      ED1A01FD9F630F7D2CA0B2DFF97ED6D542431EDC000028FF004693F874AE4E4D
-      3F1740AFBAF6E979B97297386E17D2B4B753EF04B92496FF0071E1F525A81702
-      A4E951A757485F9C98DCA2F626C3DDB362B6C45B367DB757B472FB8F70C7357E
-      21B231E472196A2C5E562A19E9AB44F186D74DEA02401D0DD15D09CFB39736A7
-      63DEB6C17139DD05C2CE914740FA342233A1208A7E17FE1C376960DD06BEF196
-      1B88E67E5ADF25B1B55D81ED0DB49713A978F5EB7912390210F5D3DC95F8FBC3
-      6A018159414DD87D5BB3B05B6B23BB7A936FD36E3299F873387D9F82355351E2
-      32B8B49A2964A6DF54194DC598A9C4554E088522F1474D1C42A61901B164926C
-      7CC7BA5DDFC1B5EE93BC1FA651E792819D1CFE2B7291A070A724EA2E5BC371D1
-      B245CD7C97CBFB76D573BD6C76B15DFEB8963B586AC91C91D7B96ED649E668D9
-      C600D011104C8F5E8BCFC8CF8679EDBFB428BB5303B89774576425C94D96A14D
-      A716D6FE2B8AA04ABA81B931B1E3ABB238B92AE0A2A6FF002C4BC3F7217CF1EB
-      91A45239E43F766CAFB749B96AF6C3E961882687F1FC6D0EF41E1BEB547A166E
-      C3DDA2BA0D050F51A7BA5EC2EE563CBD69CF1B76E8B797733C9E346B6AB6FAE3
-      4D47C74D0EF1970A3F50767894F112A758E8DCFF0029E8C8EB2EDAD6B18897B0
-      B0BE47995CF85A1C0060E966D04DCFD0AD89B5CDB8F7167DE7180E60E57D3C7E
-      864FCF549D4E9F72A5FF0090873C0271FBD62FF8CC03A355F21FA53B57B577DF
-      53EFEEBCAAEBCA4A8EA17A9CE6271BBA66CA576632BB82BAA8494345578E5C5D
-      6EDAC2E1EAA929919EA675964918AAC811235758DB9179BF96B96365E65D937D
-      4BE75DD2913BC2A88891A8CB07D62691D598D1118019A559A9D4BBEE8F20F397
-      3973272673372BCFB5A49B23192349DA479249DCD423A786F0431B281591D493
-      E74001196AB3F94DD3DF3F17727BA3AAB3DD79B8E4AEECCA692BB259DC0E5F01
-      982DD415B51349B6AB30198ADA0786974B47389E969662D221F580AC194B2836
-      FE4BF71ADB6EE6582FF6F11D990123923913FC7828F184C81EA78A69775C11DB
-      56E9749B85DEEBEE27B497BBBF27DC6D7B9F897E0BBC90CD0C95DB989F01E191
-      D348E0FAD2376620F7281D1C4CDEC8D879FADFE29B9F64ED9DC195A5889932D9
-      9DAD8ACC657EDE9F4C094D14F578E9EA249CD3C9A112FC2B1D0B604FB8A6CF76
-      DE6C2DFE9B6EDDAE20B663F024CE89539AD15C01DD927ECAF5386E1B072F6E57
-      5F59BAF2FDA5CDF22FF6935B4523E9180B574624D0E951FC3AB4F453BE4C749F
-      C70EC0F8DFD95D8B4BD79B256BF68F59EE6CB6D9DC98FDAEFB6B3785C96124AD
-      A048A68B1B1622AEB862EA28E48DE9AA03A8F19D0DFA1BDC97EDE737F3F6C7EE
-      0EC1CBF27305DFD3DD6E10A4D0BCDE347224BA4F6973228D61836B4D3C73F887
-      50CFBADEDFFB59CCFED6F33F3447CB1B7FD4DA6D73C904E96C609217875A6446
-      2373E1904687AF034F23D6B67B63074795CCB514598821664A84A68C6133F973
-      54A526BAC38DC4D0D555CD0434C864FDE55F47EB1FABDF40771BD96DAD44AD6A
-      CCB8AFEA4694E1F13BB28525B1DBF975CB5DB36B82FAF3E9D2F93550D0785349
-      AEBABB7C38D09650351EFA7F4BCFADA17E026C3EB7EBEE8A7C77596E1CF6EAA3
-      C96E632EE6CBE776CEE3D955CFBA62DB380A1C92D0ED9DC8906561A1FB6A64A8
-      81B9468A45224D7E81CF0F7AF79DFB7BE754B8E61B186D644B6D312473473AF8
-      3E348C9AA4849526A483E751C3CFAEB07DDBF97B967973DBC36FCA9BA5CDEDBC
-      975AA7926827B56F1C430A3AA413AACA12881D3E256078FE1E8E35548C921485
-      96326B228E935B4A620D4D4E5B5C0AC2306474D49EAD3E8FAFB8A562574EED5F
-      0F77E7FEAFF7AEA7296E195C852356BC6AAF92FF00A97AA3CFE728F383F1BE77
-      FD9A9D3D992254C13EB469239F6518AA609D23A73148596E005BAFD756AF797F
-      F74F8E25FEBF46B98C9B4ED61FD19FB69DD5EB9FDF7E6767FF005AD2D89355F5
-      181F3FF15A107B73E9A7871E39E99FE39FF325DAD92C0E23667C881598FDC58F
-      A6A6C553768414F51538DCD51C4628A9A5DD54F8D46C8E2B2B1C62CF550432C1
-      3B0F23884EAD6B39F3D81DCA0BBB8DDF90C23D8BB17366582BC6C78F82CFD8E9
-      E611C829F0867C5093DB2FBCF6CF71636FB2FB9AF245BA46811370552F14AA28
-      ABF54A835C727934888C8FF195435D47D476975567A28F2DB7FB036066F1B322
-      48D90A5DDB899A08E11A9AA19A07AE5A879E28D54A44DE27D7C7D7DC33FD5DE6
-      3B077B5BED8EF619C1F80C2E0FCBBA9A7ED2357591B0734F286EF6E979B7F33E
-      DD3DA9FC6B7109EDF3F89C9AF98069D71CCF7E741ECC8122DD1DA5B171491E32
-      3C94B0CDB87195D55342AF54D1BE3F118B9ABF233BD508CAAF85246D696B2BFD
-      7D6BC9BCEBBC48EDB772E5EC85A4280AC6E0038F89DC045D3C734C1AFC3D3577
-      EE2FB7FCB7A06E9CDBB746238F5D0CC8E58674E9446773AA8780391EBD2EFA9F
-      B53AFBB2B6F4B9DEB3C95164F0B38F1C95B8B85A9625C8D535456B8C8625DE29
-      B1B5F3EA3396A8862AA935EA71ABEA45CCFCB3BDEC37C969CC50BC778BE4E757
-      60A0EC7F8590705D0C5169DA69D0DB92B9C797B9C36C9B72E58B88E4B0C65350
-      EF7ABB6B4C1473F1F780E6BA8AD788AE69A9EB71E293C89574D251F86B692A51
-      64C6559A92125791299E396A12A50FA6EEDCB5EC7D85B5BC33F8C3B5D5AA0AFC
-      634FC3C7B453A19CB1A4D0781F1C0C9DEADF01AFC55A518D7A215FCC6E970993
-      D93B1A8F259BA5C5E5F0B3E43358CC6CF435B57FDE48F5D1D265B1B88C8EBA6C
-      550E4A863A88EA4D3CCD24925321F1ABB8D0667F62E4BAB7DD777920B3796DE6
-      088EE1C0F08E4A3BA65CA1D2CB51A555D96A47118F3F7978ACAEB62D8927BF48
-      6FA032491A3073E2FC08E8AF5088E80ABB21EE283B2AD835678158AA29A249E4
-      5AA8649A48A08A1A79E42D080B2A46D021D72020104B68FE9EF22A652250461C
-      71E1C7AC325897401D09F898A58A4512456489C5E68DA554965F5940AC43DAEC
-      4DE366D6A16C5FD3ED30A1E07AAB5BAB104B9AF429E229F44128135992332C22
-      191648CEA883930CA9ABCB0BEABF0C4FD2FED2999A47D063206AEBD21EC71A68
-      74F5451EF247AC5CEBFFD1D4B3E3FC87FD136D7857546CEF9EFDC428C6451B83
-      2AE755ACD1471DBEAC7EB7F60BDDBFE4A371FED7FE3ABD0FF62FF9275B7FB6FF
-      008F9E85BB8450A7496D77D1FA9B495E6D2900E84D3F5FCEAF65DD1E7581586A
-      00BB0D5751272BAB5EB28B0AB5C16551F8FF005FDFBAF759161647D4A0A17E11
-      A4D4068652541573A97513A895FC7D7DD4B01C78F5AF0D88D463CF5C5848A18B
-      5A365D49AB5971A08D44F250466ED616BDBDF95C38A8E1D688743A5A8A475854
-      C962CCCF2905594CC9AE45E1AE5DC92AAA107D0016FD5EF7D36F52B53A8AD47C
-      27A01B75F786F6EBBDE592C4C58CDB393C52474B51427218B9E2985255406554
-      6ABC7D4D23CAD1CCCC9E560CC7C23FC7D88F6CDA6D2EAC62267224F3EE3C7FD5
-      FE4E835BA6F7B85A5ECA9104109CA768E1D4E87E4660328E8F96D813D1DD1B44
-      F80DCC6A231667F50A3CB50B9760CC15CF975F04DFD400BBEC4C84343709FB3A
-      4E39915F13DA166F5D5D0A5B43B13ABEA254AE8DAA61AF97C2562DE58969A149
-      E0924732D3FF0007ABAD8996565049917512ADAB42F3ED0CDB4CE1CEB92A74F4
-      AA0DEED245AE8F0E4AFC4D91FEF3D0E5B8B736C2ADC345BABB0776ED477ACAC5
-      A3A77A5CAE3B1B4B414FF6C7C4B8EC3A615720B24B10BCA46B736BDF58D3EE96
-      FB76E11BC81612635196A8ED3E5E7ABA3292FAC6E21F1E5BA0ACA7D0F485CD77
-      8F54489063B0BB9F0F0520822C755C1B5713BC7715764914E967C955E53194F4
-      E6391AE52DC23BF0A2EDEDFB6B0DD048EC74AC7F32A7FCBD209F7BB558B446EB
-      ABE40E7F974A4D9BB8F199AA19B7760BAAFB47B3769EC3AB8E873DFDDEDA2F5D
-      82A1ABA982B32B4CB966A4AB4C8B6BA6A279434EE914C90BA0BB587BD5DC66DE
-      914F7D1A39C0AE357FA566F8BF23D56D2692F20FA9B1DB269D10FE1566A1FE92
-      F11FED874BDDB3DE3BEF6B0CDE457A6BBAAB72B948854413EF414FB4B018EA39
-      A34AFC7AD0E0ABA86491CB537EEA3C5AE6923E1548D4ECD3D8ADDA7827738837
-      91EDAFFBD0E9D5DDEEACE5FA897659B5FA11F0FE4DD0C5B57E647C92DEFD4707
-      5152ED4D878312D7652A76EF6DEE9C15176476362B119BA0A9A0A6EBDEAEC3D7
-      E3ABB6C75D5364EA26993F8CCD45F7D0453068CDD23B1FFD3EDF1C36C05F0324
-      1115A8340457BB1D114B7F7B7538792DDC6B6A69A716F9F47CFF0096B77F6CAE
-      82972D9BCC414D4B97835D34584A8C6C994DED8CDC40C9459532E4D5E5AECF6E
-      AAE789D269FEEA398C2FA105804001E6C32EEE218E33A62F335001FE1AD48E87
-      1CAB1C7B5CB7578E95B9FC069A9D7E4085623FE33D0F9FCC17A461DACBB6FE6E
-      49D71BDF626D5EF2ABDBDB5B38BB871876E261BB125925FEEEE7EAB0B5B0C59E
-      C250F6051C0F4B0CD3C62966AF8175870F0FB47CB5BA3469FBAB5FEA462B4D5C
-      40C6AFB457EDCF4A799F6A06DD7772A4093FB534EED657830E278FC5E841F3EB
-      577DF3D6FBB3646F2DF7BE3059EC9D460733B9B2F93ACFE0D3E531194DA790CE
-      6467C8CF88DE3898A4865A1A9A392B1A2A6AE569286AA27BC732B39880FE6BD9
-      1E1511A54F51E47651AC81D9BB196A3FD5FEAFF2F41666F35BA7310156DCF97F
-      BD32278AAAB2B6A2BCEA8FD6B117AA79A6546D235696BAFF0067FA7BDA300DDF
-      C3ADCB04846989503FCC742075DD364376FDDB546265C3EEFDB2B43509BBF6D2
-      454EF54F95C9516230CF1227DAC759B83239BC8C74E2EB4B3DC873370DED4E89
-      E457686506251FC39D3F8BA4925C5BDA684BB8354A7E12BC0FFB5E92FBDF01BB
-      7AE737B9B65C916629F74EDCC9E4B6FD552454EF1D251E731CF20A9A49DA29DE
-      096AA38294B7852E5D0EB07D1A4B6B6502847992B1BAD469FF002F4A9F72BD8F
-      4089FBBE79C7F47AC7D1597CFEF6CDEF0DB79BA8972D971B2B2BB9F6C4323C74
-      EE2BF6828AECAE22248A109E4C9E184F6241F543192400DEE9736500891A24A6
-      93FB3ABDA6F3B92C8CCF32B2AE48A7E1E9578ACB52E7A80D661EAC54C6D52A9F
-      531D5533C5E37FB4AD8AE447550EBB7ABFCE00C5750B7B0DDDDBCF6F3BAC8B45
-      A7AF433B2BB8EFED3EA51F01A8DFD1FCBAE358B18412CA638D23D6F233346D18
-      BA6A0819D982A4C49376FA7FBC7B602B1353FCDA9FE1E952BAC8BAA20C7F23D3
-      457E3A6A47413D2CF8D76A68E5582A29AA69679A1AA8A29A9AA5448B18929A58
-      CEA8DDB5249190C1AD6F6D90A2A3B6BD386BA47F0FF2E93350950B399AA3548C
-      044C0C71AA46D11564911D154C52497FE80EAF4FBF05A701D28574F0F419334E
-      9155F132BA2C0C446B1CD248CCACFE579D5B407F31489EE14DD174721BFA7B53
-      1D0A92C33DBD2522A33D227231381246B08B4C5D8ABFF9D6213592574AC4A06A
-      65D3C9FE97F669038AA36BC8FF0057FA6E934EAC6371E5FEA3D262586DA893A4
-      F02C0124FE7D3EABFD78F666AD5D00647458F1A9D6C1E8F8F5FE5D31540E58A9
-      62AADE9E48B13C2B5BF2C3D98C4D8D2DD056F50976657AA6AE853DBBDF1DB9B5
-      B1D261B19BDB2D5184A94314F85CD8A5DC588A881A3F0BD2498FCF53E46034AF
-      11D0D1A85423F1EC37B872572B6E73ADCDC6CB18BC0752C91561753C756B8CA3
-      57E7D0A36AF7239E764B57B1B4E629DF6D71A5A19A93C2C3869D1309174D3141
-      4E845A5F979DB14D554F58F4FB2AA6A696278A19DB6BC34BE3497210E5A7555C
-      654D0A08EA6BE05924403C721D459496BFB237F6BB966489E257BB119E3FACC7
-      E14645F8C39C21A03F10F26E84B1FBE3CE8B3C372D16DEF320C1FA754E32091B
-      FB364C17152BC1BF10E9A73FF2A7B7B70C18882A72387A6FE0592A6CB6367A2C
-      252FDC435D4D495B411C924D5A6B5EA91A96BA45649B523EAF529F6AAC7DB5E5
-      6B16B978EDE473344518194E960581A691A74F722D08D2C3F0F48773F7939E77
-      48AC6396F224FA799648CA462A1C23A6A24D6BDAEC086D41BCFA0BAB3B47B16B
-      F094BB6EAB7AEE27C05224C90E223CA54D35068A992596713414EF1254F9A495
-      89F26BBDFD8922E5CD860BC96FE2DA20FAE703539405B181A58EAD34A7969E81
-      D3F37F345C6DF0ED536FF75FBB5010B1890AA771A9A85A6AA96FC55EA2EC3D89
-      B9BB1F71D26D7DAB406B723541E592491C41438FA3848FB9C8E52B65D34D418F
-      A6046B92421412A3EA541BEF5BD6DFB0EDD2EE1B8CDA204FCCBB79220E25CF90
-      5FF063A6796F96B77E6BDDADB67D96DFC4BA7C927091A0F8A491CE1117CD9B1E
-      5C481D5CD7C60DB18DC06CDA9C1E373F06E7C2E3B32F4B8AC9E351851579871F
-      043979A185EB675459B70AD4A2329F1C822120B87BFBC4DF71771B8BDDE21BB9
-      EC4DB5E490EA747E22A7B03607708F416FC42B4F2EB3FBD9EDA2D76AE5CBCDBA
-      CF734BDDBE1B8A46E83B1E8804842EB6ED337883506D2DA038E3D1964F299229
-      22890C111713D3CC243505903A44B1C86531A0256E34FA7DC72CC8164041D7EA
-      3E1EA5F44A1C2284FF0057FB5F97DBD573FF0030FA849F6EF58F8A52D1AE6F72
-      A7857F423A63F0FAC9161A6457722D73C0F73A7B035FDE3CCDAB8F830FFC7E4E
-      B163EF523FDD3727903B7EAA7FFAB71755D5D7BBEB29D6FBA28377E1683075D9
-      7C6177C77F1EC77F14A5A2AA720257414E668552BA9FFDD525F5465AEBCD88C8
-      0DFB63B5E62DB25DA6F6E678ED65F8FC37D0597F80B50F6379AF9FC3C3AC50E5
-      3E68BFE4EDEEDB7FDB2D2D66BF86BE1F8F1F88884FE309A80D63F037E1E23343
-      D0DD9FF995F20B3946F411EF28F054D2AC8B30DBB89C6632A25132DA50D5DF6D
-      364135FF0054994FB06597B43C8B612A4C76A79D969A7C691DC63FA1509FCBA9
-      1F75FBC27BA5BAC4F00DF22B58DB8FD3C31C6DFEF74671FED587459F2392C8E5
-      EB6A32396AFADCA642A487A9AEC855CF5B573B2AAAABCB5352F24CEE10051A99
-      B85F723DB5B5BDA44B6F6B6E91C09C110050BF605C0EA1DBCBCBBBFB89AF2FAE
-      649AE9CD59DD8BB93F32C493D189E93F94DD81D1180CA6DCDA58BDAB90A1CBE6
-      1F3750D9EA1C95554255BE3E0C63A4525165B1E9E0682993D2559B57E6DC7B00
-      F38FB6DB1F3ADEDB6E5BA5CDD25C430F863C374034EB2F9251FBB513E7D4B1ED
-      D7BD7CD3EDA6D777B46C7616535ACF73E31F19242DAF42C7DA524414D207E1F8
-      BCFA7FECDF98DD93DAFB2F21B1B72E0362438AC856637206A71988CA4391A7AC
-      C5D6435B493413D566EB21FF0075344C1E37530B14FF0059172DFB4BCBDCAFBB
-      C3BD6DF7F7CD7688E9A5DD19183820821630DFD2C11DC01E8D79CBEF01CDDCF3
-      CBF71CB7BB6D7B625949246F58E3903A3C6EAE181799C7E1D06A0F6332F490ED
-      0EF5DCBDE741B4B6F6E7A7D95B5719B12833CF805C1623218CA3924ACA6A6A99
-      286A1167C8E996A1B1C91405234896460A6C9EA06BCBBC97B7F25CFB9EE1B7BD
-      DDD4F7B245E2788E8E704AEB184F875D5EAC4D387760907397B91BAFB936BB06
-      D3BBC3B7595A6DB1CDE0F831BA21D6A1B43773D357861134851AC8AD17B9439C
-      1763760EDDC78C560F7BEE8C4E3148718AA2CDE421C63699FCE124C7098D1B40
-      D5035BA1428EDCB06F620BCD8362BE9CDD5E6D36F25C7F198D19FE1D3F1E9AEA
-      D3F8B56A1D0636BE68E68DAECBE876CE61BB82D2BABC3599D63E35CA7C14D596
-      14A13F10E872E85F967DA5F1CF1399C46C0A7DA12D2E732D066EB3FBCF83A8CC
-      4D1D7438DFE1E8F4860C8D122C5F6AE45886E5BEBEC15CEBED972E73FDDDA5D6
-      F535D096188C63C19020D0CFAF3547CEAEA4DF6DBDE7E6FF006AF6EDC6C79722
-      B1305D4EB2BFD442D2B0758F40D1A1D31A4FEDFC5D0CF91FE641F20729512554
-      B43D6F455CF3D1D50CA6236EE6B0F938A6A39FCD095AFC6EE7A7AC96073E9786
-      47785D09429663708C1EC1F235BC691ACDB83C3A48D0F3472250F69EC7848AFC
-      C51978D7A90AE3EF47EE4DD4DADADB688AE3529F1238268E4054D57BD2E0391F
-      C48C581AD08F513BA5FE72EEEEC4F913D63B8FE426EFDAF81D99B3E4DED9582B
-      60C14587A3C4E4337B16BB6F2A4B570475F92A98ABEA1220A93B4BE395C94B26
-      90A18E70F6776BD8390B98AC39136BBA9F78BAFA6423C4F119D23B859381D083
-      40D5C00D438D4E7A1BF20FDE0B76E67F74394774F7437DB2B4D92C3EAA4D7E0F
-      8291BC968D02AEAEF721C85A0724ABFC38C0B5D3F36BE2A46B74EEED9AD2A334
-      4607ACC9491BC9A801323BD0C924B01339BEA20694FA7E7DE320F697DD0639E4
-      8BDD34FE14FF00A0D7BBFE7EEB32A4F7F7D944AAFF00AE3EDBE270A788E7F3F8
-      0FAFFD0BD033F203E5F7C79CFF004376F6DEDB9DCFB372DB9729D7B9EC5E0311
-      4A6B2A92BF27574B3343454D8BABC7498E97EE2A2A0AE928411E9766F57B1672
-      27B5BCFD63CEFCA97DB8F275EC3B7C77F1BC9210A34202B562E1F5E00E3FB3A8
-      FF00DCEF7B7DABDC3DB6E79DB76AF71B6E9B76976B99218D1CBEB90A9A22C650
-      A1A9C68229EBD509758774EF3EA0CF41B976A7F00A9AD8A7A8964A0DC3B77139
-      FC3D4CB534B3D1AB5463ABA94C6E9124FAD215221D605D1BF4FBCE0E61E51DA7
-      9A6CDAC370F1D612000F1C8F1B8A1538753FD1D35E34E07AE6EF2B7B83BF723D
-      FC3BC6D3F4CF74AE6A93431CF09D418026371E8D5D1C3552A9D1BBD91FCCCFE4
-      2EC3A9ADFE0B84EA98F079BDC8771E6F0D47B1970D4F5B592C3491577DAD6627
-      234B5941355D3D225DE372FABD6757E9F7176EBF778E46DE2387EAEF7733790C
-      1E1C721B9F108505986A5742A4066383E58EDEA6BD93EF5DEE66C172E76FB1D9
-      C6DD3DD78B346B68D0AB921039578E4528CC106466B9A1A81D0F3BC3F9BE760E
-      630863D93B0311B2F3E0533F9B2B2526F6C355B09122A8A69E9AB69B155D1426
-      195DE27F2C8DE4080A0173EC19B57DD7366B4BDAEEFBEC97763DDDA9AA0718ED
-      20867527E10574814AD0FC2BD0F77BFBEA7306E5B73FEE3E5C86C374C1064D37
-      51BF7518156F0DC0F8B49D45B569A8196E890F78FCA4ECFF0092536C2AFEE5A4
-      C6D46DAD9592C90A68F696DF8B6DCB51439AA9C43EE2A4A6C8486B6965AE7A4C
-      4AAC1AEE2073A88376F72F7277B73CBBC8037AB7E549DD770BB8D2BE3C9E3696
-      457F04B20A1D157CFF0018F3EA09E7EF76B9B3DD1FDC17BCEF0C6DB56DD23FFB
-      8D00809491A3F1C23B5535948FB6BFD99E20F5665B77F976FC4ADFDB4B6FEFBD
-      8FBBBB1F31B5B7050AE5E82AD375615A5AAA5781A56A62C36A814994C748344F
-      04803A4C8E8D6238C7CBFF007E3DCED9373BED9778DAF6F877381F438F05FB4F
-      AFF6D947E28476B0219757594563F763F64798F61B0DFF0097F7FDD67DB6EA3F
-      12375B98CEA5235696FD0C3A1C3A1EE57528DA4F50323FCB4BE3C425CD166BB2
-      E48FCAA236973B868DCBC82365A468CEDC12A4B0ABFADF468E7FE41F6AEDFEF0
-      5CF2EBFAB67B786A7FBEDE9F6FF6BF0F45D27DD43DB046622EF7529FF35A3FD9
-      FD87FC6BA2B19EFE587DAF499BC87F75B776CCACDB8B5123D0546E193398ECD4
-      749759562ADC6D160F214F2D5C70CA8A5E290C72BFD025EC247B4FBC3F2D4D67
-      0FEF1DAEF1770D3DEB1F86F193EA8E6446D3AB3465A8F9F5115EFDD439BACF71
-      BBFDD3BD5849B4893F49A6F11240BABFD11123705E98AA1A1F97C3D59C7C69E9
-      BAEE88EBE8B6AE4B73CDBB73B5D59555D5796916B3F86D33D35353D1D0623074
-      13D64D263F0B8AA3A6658F578DDE491DDD1010831E7DC0E6B8B9CF7B7DD20DB8
-      5A59A20454EDD6DA892EF23A801E47273C74850A09D3ABACB1F6B3922E7DBBE5
-      B1B45D6F4F77B93CACEF2778414002C70A12488E303B6B42CC492A3E1E8D2633
-      23398E24869E48E6757824A6A868D111E2D00414CF0035269E7D4AFAD81F1DDB
-      4AFB8DAEAD93B8BBA91C750FF0B6AEDAA9FF007AEA58B1BD952685A477A1A820
-      FF00BCD31DC437FC67AADAEFFECDABDE5DA7DA389863ADA2EBCD93D4B59B6A67
-      C944B8EC16E231C75F5B92C962EB7294F2D4E42B28B7156410514F430B49FE4E
-      E4D440855A49D792F97A2DAB96F60BA6D0FBEDDEE4241A0EB923C8544708688A
-      6352CEB21A654786E7E1C71F71B9B5F7DE67E6BB589E44E5DB0DA1A1D4E34433
-      11ADDDE36954977133A246F1A57B0FEA22F1203B5A455929E6A4974197478A37
-      575D4C55AECADE894BC318001FCFB9AAE51B5B074EE0DD63040E35251F1A7A18
-      B12D57534B4AE17C92132CEABAD69A9FC732224B35740F097D2863E10EA28FFD
-      AFCFB4C7078F4ACD3F170E84BA1809A49223252BC7053186346F241F650C4A4D
-      44914C91BC9EAD654EAFCF01BD5ED12432EA3D83E2FF0027FAABF9F485E55A49
-      9CFF00ABFD5FEA1D513FBC92EB18BAFFD2D483A11C2F55ED6B2DD83E6EFCA8D4
-      ADB8B280A1D4E08525BF1F5F60BDDBFE4A171FED7FE3A3A90362FF009265BFE7
-      FF001F6E85B9640C432BAA08891296B93A080345CA857FA7FA9F65FD1DF59590
-      B6996148F5A491847974BC7EA57BB18C315D06ECC7569B8E2E3DEBAF752E394A
-      42F0CA11E41FAE5652195DF431F195D28A2403F1EAF6919B549E11E15E941023
-      8CC9E74FF0F51252042AA512245732812052C59DD9236914312D25FF00A8FAFB
-      7D2309C0F499999EAC0E7A8C1DFD3A9F44527A42A9B3A8D4EAEBAB84F1927E9E
-      DDEB7D057BB36063B7AF6AF5250646468F15B9F7052ED0CE3FDD4742C681AA92
-      B046B54F148B4CED4D24E124D0E55AD6E7D89F97EE91BC4824473A457B3E26E8
-      15CC96ACBF4D2C4E351EDCF0E8D47CE5F89FB87A5687A6B3594DA1B7B6EC99DE
-      A4DA4317B3711151AD5D1D21CA6E2C4D067E28A9A2497374FB969F146AE3AE2E
-      D2D51BC8E64D61CDEDF982CAEAEAE6DE08DD7C2FC47FCBD24BAE5CDCECB6EDBA
-      FA6284CF197A0FF4F4C7CA99EEE88E3E09619A6FB3C752C48F5391A407D54B5F
-      E5C5D3514B5F0C5F70E6159A196B433F11FA908E38F6BAE0A128D1C9C4745817
-      4E3CFAE7BA855D5759652393175B04547262F294F56C933C7E7A4A98E0A8121B
-      4D4D0398AA65B8F46A2A2DED45ABB3493C7F85C7F83AB9A9B661E2369D5D005B
-      67375347B8A8AAA2591EA9AA6345484F89A59434888AC514DD2EFEA16238D5FA
-      BDB9D225D54EEEB619FE57BDB93F5564B2FB617174BF6FBADE1C757D5E3EA29D
-      EA61A4CB53D1D5D2C75C93324113B64946429D1BF791FC91AE81248CD1FF0037
-      ED9FBFED12295FF52DD0987F0D29F1257CEBFB7A93F91B9824E5BBED4BABE9EE
-      481369FC64FC2FF97CB1D1B6F92FB0F79672AABB776CADCB419DC8528924A9A2
-      6A796AF263F7D624A698C3E6A686194C8BA493169F4AFEAF4FB8EB976E1A35FA
-      69A1649549A8A9E3FF0040F529F306D6AFFE33691AB42E3503C7FDE8B7447F62
-      FCB0ECBF8F3BC28AAA9B0B1C55D8EAF8EBAAF6D6740188932B43551D45255534
-      32531A6861F34285A2F50704DBEBEC666D92F6090099D636FC4BC757F0F51E9B
-      A92CE6D33DB26A1F2E85EDABF3B76CFC6DDD180EF3EA3D97B4BAE325D81B9B71
-      CFDB9B54BD2658D0E46ABEDF29479CD854FB8AAB37BBF1BB76B6AAA6A854D3D1
-      134D148AA34223802DFD5FDC2FD12DA75322AAE95FF52F4C49CC36BB3AFD5474
-      598926838FDB9E8DF7787F3E5C0FCA8EB2DF1F10F13F11778FC8CCBF7BE2AAFA
-      FE0C5E5F747F74A1AECE65E31FC073B89A0C4E0B2FB9857ECFCCC1FC5E8DE3FE
-      1D1D3494C266934A49EDCB2E419368B98B73B9BBD0D01D6694CA7E206BE45A9D
-      3B73EE047BAC2BB745B73CF713F6280A304E6BE7814F963D3AD7ABB77A6FE497
-      57555352F65523ED4DCFB5A9AB36C6624A5A9C7254E5A3887DBCB0E66A28EB26
-      A1CE7F1081D4EBD0E9571BEB0EE86FEC770B6DB7601B6BC532115EA3DBD8373B
-      395C5DC12803A00922A98E9229ABE38A090EA5923A5A84AA4594697631BA6A5D
-      128F545C9B2DC373CFB4B242F18A918E9443711DDA7F4FA1D7A9DA58570F52F9
-      4A4C6D250EE4AEDF752B345244D5EFB370F00C0013089669C50E7320B3430879
-      01910908A519BD9A6D6036AA9C741CDEFF005255FC34C7EDFF0037533B8BB223
-      EC5ACC866E918E2855D4E3286BF11468F92ABCF55E1F074F8FC6EEECE1C82C75
-      7166735884863AC7D6AE6747B97D5756AE22F0E698531FF1DE94A48D25BC0A53
-      E014AF452363EE56EA7EE4DA1B956568A970F9FA492BCC150A9511E2AB55F159
-      642C855E1964C2D5480A9FF762E96D439F77F0FC4B7001C50FFD0BD7A194433A
-      4A6B40475B48FF00287FE46DD2FF003DB707686777EFCAA7EA9ABC6E7D72F8CE
-      95D97B571194ECADF7D791AC52C5D814FB973F99FE05B7F0CF94C98A27829F0D
-      9595591279648167A7120377ABC4BCBABAB0B7758F708ADCB44AE8CDE23AA92E
-      233AD143500C12E48666A108F419ED91B6D7B48DF66B39268E6B82ADA6454F08
-      0354F114C7213ACB1CD1402BA6BA9800747B37E3CF50FF002E0EDCC3CFD0FF00
-      05B6D6EDC4ED8C867703B977A7CABADC165AAF745262D0ACFB8F6CEF4EC176C2
-      ED2DC340D4F255A3E1719E158E37499086D023AB2B89F7A823373BAAB8642542
-      1CA127229F10D3FCBA916531EDC44B67694434259B2AEB4075295C1520828471
-      143D6B2FF3C3E49E4BBBFE4DEE1DC35F21DE9352D14385A39F61E024A6DBD438
-      0C71A8ABA3A0C3D454D4AE4F70E2708B334504F343411DB5848F45AD23EDDB64
-      1FBB2256915275E0CCDF1FDBFEC751EDFEF73A6E5333D6489FC82FC3F674554D
-      425643054514C2489924A842CC55110958648191D3546C82FAD4E82B203ABD5E
-      D1B4662778A4A554D31FE4E8EE1992E2249A2AF84E352EAFF2F48DCA5303A342
-      A395428648E946969125F245245796F1448001665D4BFF002172F7C0C3BC67AB
-      F1E9275703BA4A444A1470B3684D11B33AB389751958C92A9BE9F55ED76FA7B5
-      113519353FFABFD8EA8456A7CFA494D445ECCFA9401A96462960A5A464013C7A
-      82955BAFD3D9AACC2A1479F493E995CD598D7A4C4F094665FD203FEBFA0E40BD
-      EE2FC6923FD6F6671CA0824F1A741BBBB6605E3A6901FE2FF0F4DAEBA6C17EBE
-      AB7D49B0B5EDFEC3DAC47D55AF1E83F2474A69FE97587FD7047FAFEEFD272A57
-      8F5EF7EEABD7BDFBAF743475C6E1EC9ADC1E4FA976247454549D9391A4C7E5EB
-      84315156E4D2916591F15539E9E41E3C598AA55E7A75FD68838B33EB096FF61B
-      0437B6FCCFBD33BC9B7A33A254B2A57F1AC6BF8F50D21CF99F8BB46990395374
-      E6BB9DBAEF92B97628920DD664491F48477D15AC6663C23A1D4E8388518C9D57
-      1FD1DD7B43D55B2E8B6A0CA419195B21356CF5D4D04F474B1FDEB81E2812B2A6
-      7A991296240A8D248CDA78370016C52E71DF65E65DDE6DCFE98C6BE18001209E
-      DFC46800CFF47EDEB3D7DBBE558792B9761D945CA4B3788CE5D159077D1401AC
-      B1202E0316AFE1F2E863AD95A612F920309874CBA919A468C3B98A370B1B2790
-      5E2E6C382DFD6E7D80A661157BBB7A922062E4EA4AB7AD3AAE0F9D349599C5EA
-      8C263825664725B93358DA086399224A8ABAD8B054B047279A54A78A592A9C2E
-      B2CA02B0BB7D7DCE5EC25CC76D3F36DE4F54B78ADA37351C003312719F8470E3
-      E9D631FDE82C2E6FECF9076FB440F753DF4D1A0A8CBBAC28A2A4855AB1A7F0FA
-      B0E892EE1E84ED8DABBF76F758E736A4D49BDF748A37C0E1932189AA5AF4AFAA
-      A8A285E3C85257CF8D8C7DC51C81F5CC9E30977B0E7DCF563CEDCB3B9EC77DCC
-      567BA06DA2DEBE23E871A280313A1903FC2574E919AE3AC5EDDFDADE7AD8F9AB
-      68E4CDCB6331F315F043047E246FAC3BB2291223B46328D5AB8A69AB507490DF
-      BD7DBB3ACB73556D0DED8CFE0DB868A0A4A8A9A2159435E2286BA9E3AAA66FB9
-      C7545652BF961914D95891F9E7D9A6C9BEED7CC7B6C3BBECF3F8D62E480F4299
-      4343DAE01F897D3A21E69E54DF7933789B61E64B3FA7DD6345664D68F45750E9
-      DD1B3A641F5FB7A8BB2F666E4EC2DCF89D9DB471FF00C5771E7259A2C6E3FEEA
-      8E87EE1E0A59EB6502A6BAA2968E3D14F4CEDEB717D361EAF6F6EFBB6DFB1EDD
-      73BAEE9378761105677A16D352A076A292D92BC0749F97797B76E6ADE6CB60D8
-      6D3C7DD6E598469A95351552E7B9C8418563DC475925D89BBA1C45367E5C1D64
-      383ACDC926D2A2CB4C228E82AF71448CF3E3296A5A458EA24A745FDC74D51C7A
-      86B61717A2EF3B535DBD825E235DA41E3941F1AC6DF0B91E5ABCB554B790EB6F
-      CB7BEC76316E92EDD20DB9EECDAA48748479D72630C4E48FC4455463515D4BD4
-      6DDDB4F3BB13716536A6E7A34C7E7B0F2C306428E2ACA2C82C12CF4D0D5C6A2A
-      F1F51554335E0A956BA48E05EDF5BFB736ADCECB78B2B7DCB6E975594A3521D2
-      5755091C1D54AE41F897A6F7CD8F72E5BDD6EF65DE2DC47B94040750E8E01601
-      877A3321ED61C18F597666CBDC7D81B86936AED3C7AE57395F1D54D4B44D5747
-      44248A86926AEAA63535D3D353A786969DDFD4EB7B5873EE9BBEEF61B1584BB8
-      6E5378566842B1D24F1200C004F165FC3D5B60D8775E66DD2DB67D96D84DB848
-      AEC135AA5742973972ABF083F8BA4C1055883F504861F4FA1B11ECCFA2904A12
-      3ACC253C0B7D3EBF4B9B7E6F703DB6620781A74A96E58685C63ACA67163A8BB7
-      F66FA8DCFD4DD49FA0F74F08F91E9FFAB560FADD8F971EB3C551A0B35EE6C3E8
-      C79F4FF6FF00C0FF00C47B65E3D5DBE7D2CB7BDD1A9FCF4FAF1C79FF009B57CF
-      A70C4D06433B94C76231B02D5643295D4743454A6486159AAEB2410431892564
-      8904924AA35B10BFD4FB6AE2586D2DEE6E277A411216272D85C9F87A51019EFE
-      E2DA0821D72BB8016A172F8FC5F6FC5ABEDEB866F1391C065B2784CB45F6793C
-      3D75463ABE9FCB0CAB056D1CED4F5101969DE486568E543EA4728D6E0FBB59DC
-      C1776D6F756CFAE09915C1F5056A1BBB2BD27BC8AE2CEE25B7B99344B13D0AF9
-      120F72E3895FE2AD3A9BB676B6E2DD73E63FBB947F7B3603095DB972ACD55494
-      8D4D88C598BEF6AC3554F12CED0F992F1C7791BFB2A7DB7B86E163B6ADB0BE6D
-      2B7132C29826AEFC07686D35D3C4F6FF004BAD6DF65B8EE73DDC9B6A6B96084C
-      CE7500C11389C9CD2A30B93E43AE3B6A9B71EE5AAA4D8F8069AAE5DC596A17A6
-      C4F9E0A782AF2D4D0D653D14865A978E1825482B664D4CE81B5F3FA45BDB81DB
-      EC43EF57A813C085D4C9A4B308C9058632C35203C0FC38EBDB64DBB6E01760B1
-      99DD2EA747F0F50553222BAA1CF0211DC56ABC73F08A34E420ACC5E42BF1D5A8
-      22AEC6D6D550D5C01E397C353493BD3D447E68898E6093211A8120DBF23DA984
-      C771143710F742E8083FD122ABC7863A4D34B716D3CD14E34DC44E55871A329A
-      1C8F8BBBE7FCBA5860BB0F378CC7E37053BC598DB988C95666F1DB73312D6D46
-      1E93375690A7F16828E3A95816BE37811975ABC32ADD268E58DDE3726BEE5FB2
-      B9B8B9BF8EB0EE13462379A3D2B218C6AFD3248D5A0D4FC2C08ED2851C02A28D
-      A39CB70B5B3B3DA65F0E7D9E095E64826D663499E9FA8AAA74EB045460A1C874
-      742E84F46CDF9C3FDCFABC96576B6D6976DD5E76904B96C353506DBABD9592CD
-      AB52403215F85C5D36D68151B1B468166A15C7CE933905A44B6985B73F66A4DC
-      E1B6B6DD3731730C0FA5242D309D23EE6D2247331AEB2712199180A80A7AC93D
-      93DFC836CB9BCBED9F6596CE5BA4AC91A25BBDABCC29DEF1A0B71A742A8D5108
-      1C3F6962381B1C57F32BEA19638E9B39B277E98603966FE23418EC0C151E75D1
-      538CA9868FF8FD5A539AD90489327DCB8A69B43032212563A9BEEFDCCF18D767
-      BBD9EA3A3B19E4229C1C31F0C5694520E81AC6AE0DD4B10FDE6B939C24775B06
-      E3E10692AE12119F89182091C0D5DCAE3C46647A37782C579B7F334EAB696974
-      F5C763E594348DE4ACAEDBB4B2B324CC1639B556557DE1745126BB4606B55D1A
-      92FEFC3EEFDCC6165077FB08DBFA2921F2F2C0A7A7E2F86B5EAE3EF37CB0F244
-      89CB1B9C886B967810E18FF4DAB5A2B571F1534E3A8D37F32FDB31CABFC23A7B
-      3A950268FCC729BB30F1D3C71695323353D3E0EAA56926B5CB174609FDAE3DEC
-      7B07B81426E79AE031D31A217AFF00BD191463EC39E9C6FBC76D5AEB69C9D740
-      83F8EE23A53FD288C9EEFB57A01B75FCEBEF8DEB9AA47C74784D9B81A7AEA699
-      B05B58E511EBDE29964A58F21B89AA5F353080423C8B4AF48AC3F58286DEC5FB
-      6FB3FC99B55A389C4D777650AF89368ECA8CE98E9E10AD7B4B8723F0B57A8F77
-      7F7BF9DF77BB8A481A1B2B14707C18358D74385798B7898F308501F314E93FBB
-      7BF3B83B4369536C4DD390A0ABC2D364AB3270B08F21FC6AA66ACA8964869F31
-      949B213CD93C753290891E854D2819AED72556D7C99CB1B0EE8FBC6DD6CE2ECA
-      043F0685A0A6A44545D0E7E22751F8BF0E3A21DE7DC4E6AE62D8D360DD2F11EC
-      04ACFAA87C43ABC9E42EDAD061402B4C57E2AEA46E1710548AEA9A7491C491D3
-      40D0899B4A936F1FD4A94792CD7FD6B7627F03D8898EB1A07C1D04C46A8DAE99
-      E851C7E3E5D11212D1B0AB9046D4ECEEB4C054F8A279359F201384D6FA92C9FE
-      A48F504722E9341F0F4E83AAAAC33D09B8EA646A548247A7A995A368E2A8FBD6
-      D73C89733E8789240F2482E88108D6CB7D36F6C9629A0AFC5ABA2898D3C43F6F
-      5449EF223AC6DEBFFFD3D46BA1B57FA2DDB0342D95F3A15AEDFE70E7B2C41257
-      F0B6FC7E3D82F78FF73E6FF6BFE01D483B17FC932DBFDB7FC7CF4325A400B989
-      A51A56348D2C3F7A523F72EC0B288C0FE9ECB0B2FC35E8E8C6ECB55E1D4958E4
-      8E77565122141EBBB15F5174737D45E4B28E53D3FEAB57BA49E5D5E246A8D698
-      FF0057975C269246AA684FA99C70CEAA03A2D810B183E8655FD2CA74DBDED545
-      2A78F4CC87BA40786AEA23B1003940AE54AA866174601B9375097D5FA79F6E67
-      AAFEA7FAA9D744C713A91E80447184D608BCB62BADB4586A63F55FF63EF401D5
-      41D6BFB3F9D7AF63F134B93DC5B6DEBD7272478EDC343938170C625CABCF491D
-      42CF0D0CB554F3C31D44F4B23C51B3AB0D6EA4FB5FB7CF2D95C24A1081EBFF00
-      15D166E96B1DE5BBC4C2ADE43FE2FA3B5DBDB6FB57B17B6313D73B8276CD5774
-      DF5BD0F5BE36AA7C855E520C16D8D8D90CC4B494D4F5151EAA9830F3E666A588
-      2AA8F1A1D1C69F6926B9B78679A5861F08BBE7BB556A78FF003AF4FA2DE5C5BC
-      56B3CDE222250301840070FF008AF3F97406F6F74A65B66EEAD8781ACC563E7C
-      96765DCB9A9F211D346AF5351916A132AA51BA2C5546AFF8626B50AC4A921EE4
-      1D427B39CC91465BCFA076E31A453C2178EAA9FB3A2A795AFD9D255E736D60AA
-      772C34596C76E5C06668F3143E3A3C3E569A7ABA78E8E9A6BC95155449E3B173
-      26B84AFE865E14C9239164AB0EDE9322EA7635ECCF44BF190451573D7BC6F531
-      D14499074416D11D3CD0C2D670C1BC86A1F4D87E39F6FB32AF13D227F89A9D6C
-      5DF047AEB6FF006C75164B746463FF004631E0F7F4357B39A3C6576773BDF1BA
-      32955B7736DB5B6DD44D0C0948BB3307849A0ACA8A3337DA0A9884904467127B
-      00EEFE3DB6E091A4267925396534541FB7FE3BD0F3685B6976A79E798411C642
-      AD454B9FB470E8C1FF00303FE615D2DF1F65D83B1FA4FAF6837AF68D67566271
-      3DC79F877761A5EB8C076FEDEAFC963774E171B9AC426497792D0E106352B852
-      7DAC0990F3AA54390C4351FB797335C25F5DEE4521999BB02E6B53C18700C29C
-      699AF47B37B9F15AD9C9B75BEDC24963D347A903495FC40E2BAF570C69D3E75E
-      B5FBDC1F22FB37B9F2BB83736F2DC343475C08929E870F8A868A829619248686
-      0C7D256C6F3652929286991FC11A4BE8E3FD57032B0D96CAC54C56F093F69D5F
-      E1FC5D473B86F57FB9307B99BF663A486D7FF72197C3D0E2B195996AECBE6B21
-      474B04CAD94CBD6CF352D4C3471D2216679A7A9AAAC31C6AECE759FF0003ECF2
-      DCC76F30F1BB7A2D11C933A2AE647345AFAFE7D6E4BFCA87E2AF407C45D97B8F
-      7B6EFA6C4F6B7CBAEC4DAD2E27757D9545149074FF005DE7611419AD9FD4B5B3
-      2859F7EC74FAD73D931696765147069A232BCF0DF3EF336E1BCDEC96560DE16D
-      8A71C7BD71C7D47C8FF97A9D791B64B0E5CB4827BA6F177F95AB238140828415
-      5F51520E3CE8788AF43B7F340F8FBF1A3757C75DB028AB606CDEDD12D64DBD92
-      5A7A2C857E36A7CB590626B0FDAB2CD28AA91E4931B917874077F1B7E893D853
-      95772DD6DF717919D7E1514F2EDFF8CF47DCD7B76D97B6290D19C96AD4638FF3
-      C7A7EDF96931D8DB2B2FB7FB1E5C56129985353D568A348CC5551D6D08796AA9
-      2B5E4956922C96332946BFE6C9692378CC7CBA7B9B62BA13C5E249F1FA7FAB1D
-      405B86D8D617A6DE0AE90B5E3D30D0EE9C8BC551B6F231565251E1B350E58616
-      658AA2AF01914743165F17F722430C75113ADD75F8AA5180919AE1BDAA86E0C0
-      5DB46AB7A7FC5F5A78BF793E9345BC5FC3E5DBFC8E3BBD7A13B790C1652B6AB7
-      82EF8C2E560DEB83A68F2389828AB6973FB5B3FB521A78695A6C5B532C698FCB
-      50B3A4332493106365D655839533BDACB6B05D413713A7450D463E2AFE2FE1E8
-      AADA2BE592E2D6E213AD1F56BC50AFFA5E82FEB5E903BFF75D764EBE7825D9DB
-      6052E432F0CF53063E5CABCD50131D8086A6A199FEE3315BA8378C3E8803FD0D
-      8FB2C96FD20408DF657A31B6DB9A491D9B8FA75697F1F3E54F687C59ECAD81DF
-      DD63B96B369EE2DB19F7AEA25A458668DB6EE3E45C2D31C98D0D4D1E0B389255
-      51BD149AA9EB29A4922652AFE9066F102EE20AA3C89202192453474743A95C7F
-      B38FCBA1F6D5731DA00B2DAC53594ABA6589AA03A1343DC29A48A0D241054852
-      841008BF4F9AFDB5FF000E5DD2E3E5060373D061B1F363719B777A6D1CE56494
-      3B67696E9DAD4E93CDB8F6664AAA39A1ACA2C9636ACC75F4750FE85685D1D674
-      90C808E5DB1E62FEB26E9F57664C33CA1BC521482C40A9A56A2ADE5D0EF98472
-      9587266CBFBB6FDE3BA8637022724B3A3C8EC43150149EE214900E380E1D69BB
-      DAD9D5D9AAB59B0FEE2BB0993CE64927DE34285E1CECB155C319C74D32C37648
-      6C1E28DA7D0174ADCEA71EE65B2DB991516EA5562780D3D41B75B9C523486DE2
-      D1ABF9F5D6D7DABB9EBA1AFAD6AAA3CBD14D8AA4DC5493D1434B154CD4B5FE68
-      A51478D891679EAA9BEDA68EA6023CA0C048D606A2D6EF648B1A4D0FF6918A1F
-      F4BFC5D1BEC77EFE2FD3CBFD9486A1BFA5E9FD11ABA63C8D3147692187C92481
-      69D6493D65D749D0DE311D95CB7A356B0A6FFEABD86D4EA15E8540D7A4964A8E
-      1961D26258A1648E3914C923A799AF7A97D4432B176274F1C6AE7DBB13C9136A
-      00D7FD58EB5C450F48AABA29657B461AFA8AD99CBB2DF51464BFA515122E47EA
-      5E3E9ECC61996319F2EA9E0BB7C231D26EA681F5C8595DE3606CC414D2BFD9B9
-      97E8C18D88FC1BFB5F1CEBA56986FF0057A745F35A392E0C75D431FEA3E7FE72
-      7A639A91D016F1B1163651A19EE2C05C03FDA26FECC23941C16EEE8A2E36F745
-      77D0D80DFC3ABF97AF4DD2C240E2CBA7F57D2C6C08B6A02C085F6AD1F4E0F0E8
-      8E7B52BAC0C53FD54AFCBA8A548E2C3FE29F5F4FFB51BFB7810C2A3A2F75142D
-      D71F7BE9AE86BE92DE58EDADBDB0195DCD4F515F86C1355498AB48FE3C2E6EB9
-      E234D918E9E04FB8AEFDE8F49810EAF56BB108C181FCE3B4DC6E3B3DF5BEDAE1
-      2EE551AFFE191A575254F6A76FE23FC34FC5D48BEDC6FD69B3F31ED57BBD44F2
-      6DD6C4F879348667A5240AB97CE340F5AE96D343713B3B75455F15339954ABC2
-      92EA53E17892A956548E749089D6A2066B107FCD91A5EC574FBC51DCF6F36FE3
-      0D1DD5FF007AD38A8F937AF9FE1EB3D765DD12E823F89865A8F2F8B3423D5781
-      07E16AA9CF4264B2F969AA4D345FBF1C71069219C37A6A048D10D508924F3D90
-      FA1974ADFF00C7D822E90EAABBF6B1F3F97ECEA44B58A461A500D5DBF8BA20FF
-      002763D1BE3A045E4D29D910C5106AA335F4E5B6C99DDA2BB2C6C2A0B0BEA6BF
-      F6748F4FB99FDA4FF925FB85EBFBBB38D3F827A777D9D63E7BFF009DDFD9E61F
-      0FEFAFF9FED6BFCFA1ABB02BA8F23B977EF74D54F01CA7C67CC777EDC8226602
-      5AA9337B7F1353B05A1F4B5E3A1C9676A512FF0043FEB7B41B1C13C1B7ECBCA7
-      1A1FA7E61876F94FA0F0E471715F9BA4684FE5D1EF366E16B79BBF317B8734E8
-      6F393E7DE205CF73F8D046D654F94724CE17F87FDAF414F6760713B93B0BE54C
-      B92C1E3B7065B1FF001DF66E4B032D563A9F235D43935C4627C991C519A0927A
-      4AD084EA921D0FCFF8FB1472FDE5D6DFB1FB6A96D7724168FBE4E9285764464F
-      11FB1F4B508FE8B63A01F3ADA586EDCD3EF4CB7BB743757A9CAD68F033462474
-      93C38FF523D418A3D2B52943FB7A60EA9DB741B6B707C13C826DBA3C367B2F07
-      6A55E66AD7174F8ECA665569AACE266CA4E208AAAB523A39C353BCCCF68DBD1C
-      1F6B3992FEE2FECFDE680EE4F2D9466C9621ACBA4795D610574AE47701E6B9E8
-      9392AC6DB65DCFEEDD789B325BEE5326E2F23F8623926C3786643405C2AB7617
-      AF6B63A43EE4DD15551F173AF70F26136E5451D77746E1DB95952F80A4927A3A
-      2A3CAD3E406421AE6563499AC8491F86A2AB4AC93D33B467D27D9C6DDB6449EE
-      36F374B773ACA9B447205F10D189423411E6883B913E152350E82DBAEFF3CBED
-      172DED8F636AD03EFD3C2C7C05AA20915F5ABE74C8EC28F2503BA3321AAF4AEC
-      8EDBDB78FDF3F322A30DD73B4F3555B3B13B1F23B430D55B6A86B2830F550D32
-      4F57558EC6AD385444113544D0C6025488ED22BA310C822BCBF9F66F6A62BBDF
-      6E618EEA49D277131532026803BEAFF6819BB92B8A367A31BAB3DA20E60F7BE4
-      B1E54B2964B486D9EDA37811921282AED1A69FF6E40D2B22AF7A9155E9C762FD
-      864B7EFC67EC4ADDB585DADBDF786D1ED44DD54F86C44581A2CB4384C4D7D361
-      3703E1692282969AA6B29653778E3449974E9F4AAFB4DBC89E0D979FF638EFA6
-      B9DA2D6EAD3C132378851A470D245E2336A2011F0B3165FCFA7B63B8B7BBE62F
-      6BF9A25DA2D6CB982EACAFBEA5618C44922C71BAC337828288EEA73A5541C528
-      17A4BF42E1A9F0FB7FAA31BB969362C98FEC9C866EAE0C152F5945BB772EF0C6
-      1AA9A9256DDDBCF34D3506D5A2C721BC4B4419D211A9918EAF669CE37125E5FF
-      0030DC6DED7AB358A441A5376618607A03FA1047A4CC5FCF5F13C0D29D11F215
-      BC361B472BDA6E6962D0EE2F238845889E7B94D4C3FC66EA4AA408832BE1EA60
-      BF10AD7A0CF09B0B6F765E0B25B330D85C650E6FAEBBAA5A5ABABA5A2821C8D6
-      75BEE2CD5551CFFC46B82FDD560C04F46DA7C85FC516951F5F621BADDAF761BB
-      B6DD2EAEE47B3BEDA810189D02EA340CBA0701E2573455D4DDC7E1E81369B2D8
-      7315A5CECD69671A5E6DFBB904840AEF6B348C0EB75153E1E9C549A0C0E3D28F
-      0592D8B571774764E0711B7704D45BB717B6B6D4C363D0EF1A0DB5B5E2A514B0
-      D543B5A28E968926DC8603E4AC74721F5FF689F68AF2D3768872B6C57B793CDA
-      AD9E69878E60324A4D48F18D5BF4EB88C1E1A7A34B2B9D95D39C39876FB4B687
-      4DD24309FA6138861514AAC2B415988CC847AF53A824EBDC7E57BA77663B6063
-      AB9B0DD75B4B72C585DD7B35F078FA5DDAB5D3A55D66370590BD6506172152B0
-      CE12270B22128C6DED9B84DEA7B5E55DBA7DD9E3125F4D1EB867D6ED0D1681E4
-      5ED7702A2A787C5A6BD3B11D8AD6E79BB7383624731EDF04DE1CF018D567D675
-      3246FDC2373A5B48391A8569D160DA39DA9CFF0071ED3DC9594B8EC7D4E4B7F6
-      0725351E1A8E3C6E3289A5CBD2388B1F4281A0A4A7401422FAFE9EAD5F5F63DD
-      C6D23B4E59DC76F8E491E34B39114BB6B73D8725BE227F8B87403DBEEA5BFE66
-      DAF72B88634924BD8DCAC60844EF5A041DCAABE9F1777C5D0E793AA4C1C7DE3D
-      8783C0E3B3BBE20EDAAFC52CD92C2D1EE1A7DB1B7AAEAAA2593291E2EAE0AAA5
-      867C85748D0095E3238E3F49F616822FAA3CABB25DDDBC3B57EEE57A23B46D34
-      8A0766B560484515D21BEDE84F705ACD39BB7DB3B449B775DCCA55D04AB146C6
-      AC741AAD49C569D2C703498FC56F17CDD0ED6A1C4E7F75FC71CB67371ECD8A85
-      E9717559F9EB28615A7870E8CB2D2D2E7522B494E7403EBB7D7D965DBCB73B62
-      59CBB8BCB676FBDA247356AE23009AB3F9B45E47FD2F465636F0DBEE8D7716DC
-      91DFDD6C2F24D005210C8481A7479092994FB7D7A68D8F5516687446FACAE170
-      B80DEA3B6DF6F473E37114FB6E1CBEDAA6A19278EA64A4A2868A87C78CAB1E05
-      90007FAFA89D4AF768CDBFF5BB6782E649B69FDDDE277B998A4C4E9A54D5FBC7
-      7696E91ECC4DD37266F57167141BAFEF4F0C14410EB8C296D5414140D8D5FECF
-      5172AF26E6DABF2120DD5B276CE062EB4C94191D9995836DD362EB68B2F3EE99
-      1063A6AF7A749B70B6760657996A4CBE45935DB498D47A04165B8F263EDDBA4F
-      2BEE085274F119C1410F1A57F4FC36E1A34D29A7F0B56D3789B86D9CF8374DA6
-      DA08F6D70F6CFE0842AE67F835D3F5BC41C75EAA835F3145366B6A6D1A0A1DCD
-      F23A936BEDD5D999DE9AC3D46DFC17F0BC6CBB7E8BB477054FF74AB31D4F88F1
-      9A38E6C2D5504B544041A75EB1EAE7D955A6E7B8DC4F61C873EE171FBD61DD24
-      1249ADFC436718F14397AEAA48AE138F953A11DEEC9B75ADBEE3EE6C1B6DB8D8
-      E7D9E178E2D09E0A5ECCFE018D63EE50D1942FC3F157A22F8E9144B1EA52CAD7
-      059402421653C7D7D4CC7FD61EE5CB943A5CAFC5D455B4CC014ECD41BECF5FF0
-      FF0021FD2E95B4D48F51A5A21A34DA49832AB3379034459E18D9D995B5FF006B
-      F48F57D3D934B308BE31A8705FCB3C7F2E8696F017D1D9A4713C335AAE40F5D5
-      FCBA7DA6A27761246248195B5C4C21D6CDE2D28CA9290B1072541436D0DABEB7
-      F65D2DC003C3343FEDBD7F9FDBE7D1B45007EE069FED7A5AE3F13297B1B69A94
-      334626081E460553517B468CD2AFF66F63A7FD7F647737828687B8631FEAF2E8
-      CA150A29C7FD374AFA4C03F848274A3959A515063D25CA09B41D57669200A2E2
-      EDE805BFD4FB2C92FB53D01CFC3FEAFF0057A74A7C15A52A6BD0858DA349D6C8
-      B13928270D1BEB6D4623E32123757432C76165D28CDF56BFB45DDAB3C7AF0405
-      7B532474226D9C52CB24319FD9F08758D621378E9CBBE89A58D5906A61640472
-      C7FDE7DA5924D0CC59CE9AF4B6B400FE1A742962306B4F1CF4A864658EAE462E
-      B1986033785D7C70AB4AEE15945D1049EBD3F8FCB6B751B9347FF8F754F10D78
-      63A74A3C3489493D6985E8AA1695E4929291E554A4A744F146AD02EB922628EC
-      563FA9E7FC3DED65849F5EEE997652A7FCABD5097BC87EB17FAFFFD4D46FA222
-      493AAF6B7ADD595F3764D6514C9FDE1CA3AC8AA2C58A281FD7D82F76FF009285
-      C7FB5FF8EAF520EC7FF24BB7FB1FFE3C7A1BBD4D0B1E64A8D2AB1CCE973ACFA4
-      0D0CFF00BBA8136FD36F653FE89D1FA0510EBF3D34EA26AA9594EB456883E940
-      182A23F0AEA86E75B6BFD561A87FADEF7A053A6BC43FEFB5A7AF5C1D23127909
-      28F36840EAEC0D85CE95E481766FF12DABDDBFD2D3AA15AB061C3AC65E5B08A3
-      492595C680B0A25D49B3056D76507EABFED5F4F77EAFD73B132C800D29115F55
-      982B6B06E849D4A7498D437BF2D750D3C7A6D543103E5FE0CF47AFAABE04F6DF
-      627C28EEDF9F52B262BA33A53B77AB7AA2B5648D46677CD5EFDDC984DA5BBF23
-      B58B552BC145D7792DF7B7E09A534F2C35B51949E286412E36A95771DCCBAFEA
-      2DED8BA29D0CD4246B2AE54D40A0019406258535A015F10749E7B8B3D315BDC3
-      B4724A032D451B40214906838D5B47FCD36248182F1F29B757637C6EAEA3A5E9
-      3DDF06376A76CEC0A754DF79AC0623706F7CCE2F36B05467300D999F1D574349
-      0256C62165A3A586709F5919D9DFD92EC57E39821966BD8556EA2968E8356819
-      A7E2AB7F0F9F426E6CDA9396C4516D133FEEF91410C69AC9A57F080BFCBAA72C
-      8FC89EEBA5ECBDBBD819FDFF00B8377EE4DA13C51E04EEEAB973D8FA7A2A5A91
-      512607F84D6BAD24185AF68ED34502C0E4393AC3F3EE4681228E25548540FF00
-      577750D5E967B873236A7F9F4C988EC25CFE6AB6AA78A2C76627C864326D45E2
-      2685A7ADAA96B6A0D12C85DF447E53646763A07D5FEBEECCB3C27C5E209FF0F4
-      FDBCE97042635F5CF6D6CCDA726ECC2459DCBD66176BE577460E9B70D7885EAA
-      9F0786CB66E8A1CA6561A0A483EEEAE2C353CE6ACD306533A40D1A94720FBB19
-      DDD43C8057D17E2FF57975A92C635308D45753D351E1D5D6F77F67F4C7C7E9F6
-      B7C43F897DB58EED1DCC86BB65764FC99DB34796A08A87059EDC94FF00C276BF
-      5861733E2ADC36E3CFE3B1B13E525A459931AF5AF02CD553A4B550D7688A79E4
-      6BADC2DD14FE0078B2FF0011CFECE9CDE1E0B7A6DF65741E303BC8A76B7E1A52
-      A31F334EA9C7B7F33B6EBB15B1369AA42D91C56EADD75EF864A1FB692931F515
-      A7126865C8278DE696A321846E1A30F2336AF40B0F627B89623143AEA1918E90
-      3F2E8350C0F1CF310E4A301C7A35BD37FCB57B87BAF63FF79F68E32929770EE6
-      AE969F6DEC6972628B23516852A7EF3290C904B498BC6177670A648E68618EEF
-      FD8B935BEE366679935E50E96FB5ABD195FDACBB6D9C37579DBE248EABF6279F
-      4D1B53E36FC8CF8BFDB5D75BEFB4BAA773EDDC2E0B7DE168323B867C0BE7F625
-      0A5763165A5A69F7262FEFF0021A8A5AB2FA1E4499A14242DFD40C65B79A4154
-      5C53A41B7EE305C4914D6F326B8DCF1EB608CBEF6DD384DBFB3BE4274A6569B2
-      387A3ABA53BEF65CCFF781E914529ABC0D63422638ECA5232F9F079C41A2B29F
-      44337FB544779608B2BDBCE3BD46AF9F53241B948D6B6F7F6B98F4564AF97D9D
-      47EE4DCBBF3B2363E477BE2EA24A7DA9BE7098BC8351E2EA056559DB53CD5389
-      C7AE4F1B344A98BCB62EB68674C851248B554F5088EFC1B021860892410C4831
-      E7F8B3D1E9BD7B84496BD8EABD53A7C92E94AAC4E326CE514991A9DBB1FD9E43
-      6EEE8FBB1976A8CB322B65A8DD453473E1F238DAC8FC73D348C45E30F60248DF
-      D8A76DDC552478247FD4D3F971E82FBCEDAEECF204ECF5F3EAAAB70C59DC266C
-      D46467962A9928C498BC9D2431B24AE51BC492B31D73D14E1193486B23F053FB
-      2A2F86485D157A015F5ACF6EDE39C293DA7A11B139FC66FBC50AEA36A6A2DCD4
-      917DBE53050C6636C9430A0D796A107579E5B7F9E8ADAD34FE473ED3CD6F2DAC
-      B21D75B6F2FB7A5D1DC437F16A7402EA38C034F31EA6BD3AED2DDF5DB3E9F735
-      052AD354D16EAC255612AFEF564965C6CE5F563F398D785E37A5CA622A43686E
-      54C6EE854DC7B61E1132A338EE07ADC170543D0D2A0AFF00C574BCF8E9B277FF
-      00C95EE1D9FD35B44CD53B8B77568A149E58E77C7EDCC162E79B259DDCF9D8D6
-      00D16276AE1D67AC90EA57620401AEE9EFD2C28EBF00E965B12422976017A3E5
-      FCC4FE496E0E95DC1B2BE1E745E61EAFA13A936B61B0F9CD9C6B31D518ADEEB9
-      C8A0CDD4FF007AC50E3951B79EE1A87FE23919E49AB1E0AA9E0851C2466363BD
-      B63F02DE391915EDF4FE2A540EEFF8BE8837D905C4AF6F24CDE9C7837F47A235
-      99C863721B0B3399DA9471EE5D99BBB234991931D9248D28762EFB66A2199A29
-      71B5E12928371D5D1534D68E26A68268394771E2406935AC7742DA581FB4741F
-      B77B88DBE9E50B44F3F36E834D8DB773ABB67353EDCCD363B78EC6C4E5AA6BE9
-      719988857E6B62E6A8A6A88AA1E3A7925334FB76BE8A6FB960D744AA80FD0153
-      A961D36D321452FA4F0E97C770F1496EC1C852EBF974D581CB4393A148E47924
-      AFA548CC9E601A4AA895DA55990AE8598A48DA5C5EEBF5BD8FB8FEEAD9927776
-      A053D499B6DD7D4C0A8BF127E2FF004DFE4EB9E5E822694D3008F52C835C6E75
-      146BCCE9A9C026390486CCEDF403FA7B474D25F3DBD1857893D266BB11E11E72
-      FA7443644063FDC94B00ECC91EA52EDA6E5F860F7F76F17B74F4A20A0ABFCFA4
-      BD4E3DD819453EA8C0644F5904F89B5A9556D3AC6BB83FABFD86AF6FC532AAFF
-      0069DDFE7E9D28BA7452AA3A617C7FD55632C0C6C42488C8F14C56CE14032218
-      839F4AEAB8F6BD6E7F133E757967B7F967A48F0AD29E5FB73D276AA0528EC632
-      A756921D59794D3A882DA6EF76B37D395F66713B02A15B1D135CD9AB2C8CEB8A
-      FF000FF83A4F4E151C836D4A6DA41B7F685ED73EAFA7B30859986A51D04AED63
-      49580A541F2FF567A8A9E3F5F915C9F1B95D122A5A4B8D05F523EA407EA382DF
-      D7DBE7576E9A7C5FF19E8B068ABEBA9C629FC5FB3FD5EBD770CF241247246DA5
-      A291254E148D684104AB020FD3DF99158386E0453AD248F19474F894D7F3E858
-      C0F79F666D55F1ED9DC030B4C12245A4A6C7E3EA221E35750EED92A7AEA89657
-      323B3BBBBB9249BFB0BDE725F2EEE4DAB70B1F1A4F52EEA7FE305401F20157A1
-      DED9EE5F386CDD9B4EE8B6F16301108C7CDD59989A92C492589E96D4BF2B3BF9
-      0278B7F4D098DC54218B07B6E2225047D5930EA5D2CB720FA5BFA7B21B8F6B79
-      0E42049B1A9D5DBFDA4DFF005B3A18D97BE7EEAAAD22E682BA73FD841EBFF34F
-      FDB7488DE9DC9DA3BFEB30F91DD5BA25CAD6EDDC91CBE16A863F118F9683244D
-      2C86646A0A1A42D2A35246CBAF52864FF13ECE764E4CE55E5E4BE8F68DAD628E
-      E63D122EB91F5A671DEE7D5B8741BE67F70B9FB9B9F6E9B9837C33C965319A16
-      D11466393B189EC44C8D09C7B569D34643B4FB27294BBCF1F5DBBF335347D815
-      F4B93DEB4EF503C5B8ABE82549A96AF2291A05966824452BA6D7B0BFB318396F
-      97EDA4DA27876C8524B046480E9CC6A70C13EDE88EEB9C79C2EE2E60B4B8DF2E
-      1E0DD24125E0AE2E1D1AAAF2530486A7C3D658BB6BB461DD6FBEA0DEFB861DDD
-      250418A933D0D6B475D36369618A8E1A09B4288E7A58A1A78C08DD194680D6D4
-      A0FBAC9CB5CBA76CFDCCFB44076C0ECFE195C2BB1662EBE849273FD26EBCBCDD
-      CE07776E635DF2E7F7C78623F1B57798C28409F3501476D31A41EA4CFDC5DB15
-      595C0672AF7D6E3AACC6D4A9CBD56DEC9D656BD556E2A7CF6A196968E7A91238
-      FBD53620DD546955D202FBA272BF2D476D7B6716CB025ADC0459100D2AE22F82
-      AABE9D392737739DC5D6DD7F3EFF0074F7B645CC2EEFA8C666F8F493FC7C3CE9
-      C053A67A0DF9BF2830392DAB45B9F314FB77335AB95C96163AB6FB1AAC845514
-      F58B53253B5D526155471B9B69D6D1826F61ED44BB3ECB2DEC3B8CDB7426FA35
-      D08F4C81A4AE9D5E9A5987E6DD23B7DD398E0B1B9DAA0DC661613B788F186C17
-      A83523C8D557570E02BD0A3B4FBB33D8BC5F7055E6B23B8F23BE7B1A8B6C2506
-      E9A49E28EB28F23B76BDAA7EF2B6A92682A6165A58523468549B0B371EC8773E
-      54B1B9B9E578ED2181368B179AB0907494912940BA4AF12C4EAFF8B146D3CD5B
-      CDB5BF374F732DCCBBDEE290813AB77A3C2F5A92195970A0294FF6DD07F55D9B
-      D995DBA60DED59BD33F57BAA9A8DE86973B515D2CB5B4F8F969A6A49A8E95E60
-      638298C13488511421D67F2C7D9CC7B0F2FC3B7B6D516D7026DC5EA6251A54BD
-      4105B4FC46AAB9F8BB57A219B7CE6BB8DD63DEE7DEAE64DD047A0484B1212851
-      954B600A315A6172DD71C2F63765603134FB7B09BC37162F0F4D5A95D4F8CA2A
-      D9E2822AA130AB0F146183A44D38F298C7EDBBB6A2A6EDEFD77B2EC17976F7B7
-      9B54125C94A172BF10A53FE3BDB5F8BFA5D5EC376E69B1B14DBAC777BA86D125
-      0C2346F84FC750BAAB4F32BF09E34E969B43B0A9369E2B7966A24DCD90EC9DE3
-      4995C5CF966ABA2A6C15243979A29EA326F142A6B26CA3BBC84EB45449349461
-      73ECB372DA1F71B9DAAD643026C56A51C2518C8DA3B427F0AA70E0DDC38FE1E8
-      E76ABE3B4D96EF7CA97126FF00768E864D48214D792E5477EBFF002FC27E2E83
-      FDAD9BDDBB42A5F23B533595C1D45543F6957262E7746A984EA93C73C29749D5
-      7EAA1C120FD2DECDF70836DDC90C5B85BC73229D4BAD7E13FD13E5F6744FB5C1
-      BB6D612EF6DB99A162B47D078AE788FC5FCFFA3D391DC7BBEA9F36F3EE2C9553
-      EF158E9F703CD54F354E6D28DD5E8E2AC13191E658243644042A016FD23DA536
-      FB6A0B70968805AE63C612BC74D3857CDBA3343BA3BDCBCB78EC6EBB64627325
-      3E0A86D5AB4F0D35EA15250D763ABE8EB31F34915752CB0D5525642E219E92BA
-      07592983B48008EA62963D6A0FFA9F7796EA19A1992651E1B60A91552A78D3FA
-      3434D5D3D0EDF245716E612DE28CABA9A1571C2BE5507217FCC3A7DA0CEEF4C6
-      65EBF7161B70E5A873196927A9CC65696AE6A697232CD2CB24B3D495223A8479
-      B5B7A870E6EBA7DA69A1DB26B686CAF2D236B78E811080DA70303D31FF0019E9
-      74106E76F72F776176E9733126470C4339A9C9F23AB3E5839C74CE33DBD20CBE
-      4F351EE1CB7F18CC534B4594C97DD4A6BEAA96A1D64929DAAA46924D25A016D0
-      46854005ADED51876B6B686DDACE3FA68CD512980479D3F3F3E35E8A3E8B784B
-      DB8BA8EFE6FAC9568EFA8EB2A7CAA6BFC3DBA74D1474E190DE7D8D93CEE17725
-      76E7CF643398144FE0B91AEAB6927C4B45768CC22A134236B3A8B69371EA2DED
-      B86C76382CEEEC61B1852D263DE8170F5F5A7FABD3AB5DFF0058AE6F6CEFE6BF
-      B892F211FA6EE7FB3A7C2723F8B8E34E9C96E9AF3FBEBB1372E2A1C1EE0DD99E
-      CBE2609DEAE0C6D764A6A8A6339692412BC6CC7CCF1973A35EAD0A6C965F6A2C
-      B6BD92C6E5EEECB6F862B8614D612869FC3FD1F9D3E2FC5D14EE371CCD7B6896
-      57BB84D2DB8C88CBD41E26BFD223CABC3F0F420F6076AEDDAFEACD9DD41B071D
-      BA68F6BE07315DB972F5DBAEBA86A32795CED72491C7041062D168A9B138FF00
-      3CCC83EB23BEB60ACA4925D9396EF22E62DD39A37BB9B67DCA58C42821055123
-      1E6C5F25DE82BE9A74FC3C0F39979AEC27E51D9B93397ED2EE3DA6DA779E469D
-      D0BC9338C2858FB0226A27FA44D6808C80D04A232AACCD66FEBAB81C69F4AB1E
-      3F3FE1EC65326A15E811677022745691B4FE7F970E9638CAB8F544CECE851D55
-      DE37B6A8C10C8E8ADEA1223FF64736F64775139560029C79FF00AB875206D977
-      1B2271C62BAB047960E6BABCBA11F1556A5A279119F5789DDCB206675259884F
-      F80E891A1E42E9BFFC1BD866F20349155C79FF00ABF8B3D0B2DE62748AE3FD5D
-      BD0B38958E68078EA90F992355FBD458150B9918F8F4B6B70433AA35806BEA3E
-      AE7D85EE9743905787A74651C840A8E3D2D28A0A5A9FB59D9F44B1AC6B3C5323
-      4ABE4D6A04450A9568D415234FADFF00D4F03DA654D1C063A79DF52547AF4AC8
-      69565A8B5353C0EC92059A3798D3155493C92B8534AA670F2154552EC9A6DFD7
-      DD97C830EACB294F1001E7FE5A742AE1E8904D4CF46A904DE52EF1CE1D16689A
-      38D898E48FF6FD7E46F4AAFE95170D72BECBEE45239FD6BFE7E94D6A80FE26E8
-      59A5869A585A6B8A7151E5B530A8243CF0FEDAC31B9A6767D6F720D8B02BF4E3
-      D97AF85ACE9E3FEAE1D571D3D430D1ACF0473C8634A8A79926AA8A5F2414F2A8
-      668C3A84495D4B3E9D7F8D3A85AFEDE5F8D3D7FC98AF5A11872E3C9875AE57BC
-      92EB177AFFD5D46FA16C7ABB6B333728F9D083C5FA75E7728ADA641A4DD80FEB
-      EC19BCFF00B9D37FB5FF0000EA40D93FE4956FFEDFFE3E7A17D247BAA36BFAB1
-      F202A888CA4320247ACE9517E2C6FECB73D1C77FCBAE98B2FF00654C7E650100
-      48FC413D7E46949666125EF651C7E7FC3DD5FAEC48746A2A35394B272543DDAE
-      C1F4A9D57E2DF4D23DFBAAF977D3A8F03A9693F69C4A8F22330983AF94005758
-      7521471A8006DC7BDF56E84BEA5EBBC876FF006C754F51E3F3B89DBD5DDB7D9B
-      B13ABB1DB9B3AB29C26DEAFEC0DD989DA7459FCD9895E5971389A8CAA4B2A469
-      A9D519473EDA7711472CA535E85269F60C7F3EBD044D34D042091AD80C71353C
-      0569C7CBE7D7D25FE467C61E8DEBAFE58FDFDFCB87AF7172536CFEA3F851B8F3
-      BB5656AC38FCAD5EF6D9FF00C4B7CE2F7867B21494F140BB9B7176B63E877064
-      2A2309E7AFAD9DC200C42B5B86F2D6AD7BB1F86690244ECD4FC6B7116B6D3DC4
-      ACA254A2D4F874A004107A238AD26BD6B5E6368E82E2E9A158CD08F09A264420
-      A85A989637566206A2A18E7557467ED0C6617B93E2075E6F6CB51656AB29D779
-      4CB6DD966C7D2D2D554F83294ED3E316BE819868A61279949470ACF1B3DEF73E
-      C2766DFBAF9B2FAC56BE04CA1FE55E3D499B9326F3C95B5DE49FDBC4E463BBE5
-      9EA85BB1B6466F0CF1D654D3408CD5AD08121F23AD6D3BC8BADE3005DDD6305F
-      F3A3D5EE5EB4913420030DD423B9C680B7826A54FE2C749FCF6CC931195C16E6
-      C3D5C1FC37311415F492472218691A5650F8E9F59F2A22D4978964640180B9FE
-      D7B3808D3C2FE12629D134674C882B43D2E924F1C89528AE79D6D0C8EDE2960D
-      2AB2C4EAAF60B244DA5B48FCFA79F64ACA51883F17422A5445AFE0CF48EDCD9C
-      AAC1765AE6F0CAF4B0C955479BC3CD23F90C95157052C8F1D4CEBE388C8933C8
-      8400BEB3EA1ECFED2758A2A2D0B8F2E83373195964FE23E9D097D58D53DA9BE3
-      1393A8A4A38C6DEA5A8FDD303353E2A2A7AE7C9D664F2D51A0EBAB79A691C2AA
-      203AAC8AC4924B77BDC2416F4A693D186DB6AB23AEAE3D6D23F053756DBEB0D8
-      FB9BB037BEE6976C637666DFDD3B9F6DE65A8DDF21570E0E287195C6BB15F682
-      B69EBEAB2993C73D1BB3C85A1A67B809A350576D99A78EE5244C34C953F8B4F7
-      74BF9AED269AD76B58F4931BC8695FE3A69FF7ACF45E7B13E5F637B72A29B6C6
-      F2A19E48E87B126CF5362F1DBC970145B932F8F4C7261F179EC6C0E63A091A7A
-      7A59A128A12508E1268E3727D8BA69D9E15485CE94A05F9AAF9FF83A04D8ED70
-      D85F3DC53B6551AFE4DF2FF57EDE893C1F23F3BD2DDEDDABB73319C893AFB72C
-      98BCC6D15A9A3738EA6C3E72399AB76CE7288495BFC4369578511B9F24D2C12B
-      89E03C30282F614DC0B4CC078BFB31D0D76DBC9F6CFD2C981FB7D7A35F99F91D
-      414BB3F1992DA102CBD7181A2A2A7CF6CE447FE2FB3CE6258EBEB26AEAB779AA
-      3294F9BADAD32D2E49A478E749D13D1204570849B3234AF9D2FF00EAA67A1A47
-      BA6881CC198134D7D7BBE5F2E83CEDEC36DEED5D93B9B2FD3B5B99A7DA78DDBB
-      8DCB55E56A2A4D4EDBDC2B3463CF433C34D2F9B1192A2A90D4CC655605D551EC
-      4A9744613697044C947FE7D2F94A6E16770207AAD2B5E03AAC0ED3D998B9365E
-      2675A748E8E985434CCFAAD054EB4F27DACF32978E52B35D6ED6708A0FD01F62
-      2B0B86697C18D0D31FCFA0E5FDBC49688F2C9DAA3FC1FEAF4E8A154EC9CC637C
-      7B9E0CF633038CA66353495ED531D257174957514A3A77134D31902DF4FD4FFB
-      1F63686129178773C40A7AF40533D26F120FF3742F6D2A0A7EC2C40CE929433A
-      D455E3AB65A280C7164EB69A1493F88C34F248C6856A44D79232749372807E9F
-      61ABFB816130B741A908A8E8596087748525B8C10734E8CB753F79F6DFC4DC56
-      F8CBFC6EAFC1EC9DFF00BEB198CDADB83B2A7C0E3735BEF13B56293EE2AB15B4
-      321B823ABC66DA5CAD788A7AF9A1A53553FDBC1A26511E86AED77825BA5825A7
-      770E9DDC76F96DEDDE5B19B48197FE2D3E5A7FDB7A745377B41D84FB8F23B837
-      FEE25DCFBAF72D6576737065EAB72E3373EE8CCD4E56A26A9AFAFCDD5A65278A
-      2C954D4316486AA5866666BA6806FEC54FB846ACD6EBF0F0E1EBD04FE8E7997C
-      795EB2F1E9174B9BEAEC6D5CF4C7AF7B0B3F9CD71865CC6EBA1A188D6FA34CB3
-      6131BB66B4CE1E056B2BBC96BDEE7DB320934D11F48E99086B95E857A2EC0930
-      D0D1CD84DA786DBB4CB4F509494DFC472790CB494394A37A79E9A5AE2209A3C5
-      C90486F1DD2292C9FB6400DECB9E5D0FA59DBB7A5F15B4A4A38414D5F2FF0057
-      D9D03C9E7C7B2D4D3BB53CD0975A6746318943F8008DF4B23D9F51F4D9BD3E93
-      FEABDA2645975071F674696F2CD03EB50747431D329CBE3E396980295604CEAC
-      1A448D8131BD3CA501493F70322B1367BEAB8F61B9D3C295D0F0071D0C6D98DC
-      4292A8C5074DF263DA594CD2278A9238CF8D907174678A6625422F85216B7F80
-      BFEA3EE8CA19574F1E94C5201AD4F0E9AE7C6C32246AAE4471460B2929270CD6
-      91E3676671A014B0FED30E38F6D97D27BBE23D2AF8AAEBF0F497CAD046D353EA
-      D5040A1F4B2078DCF8959495BE83E666FD5FF24EA3EDF865650FE1E5BAF68D79
-      D3E78E836CB81AA4406E63FA300503B0D22C7E87C8A58DFEBF5F67F681954357
-      8F4497CAC11D7F12F48AA8562E4DB90589E34DD6D6FCF0DECF216503FA24740B
-      BF8DB5EA2B915FD9D4022C6C0EA3FE1F5BFE7DAAE8A0AB163D75EFDD37D64546
-      247A4DB9BFD3FE27DD59828F9F4FC50B39F87A52E3A8FCB63A09424A90AA59B9
-      1767D245B52DFD5FD9B7B2AB9974D45787439DA36F12A2385C70E1E7E669FF00
-      1EFC3D2BA1DA934F18F1C5349754460F191E97BBC92AAACB691230AB6FD5EAFF
-      0063EC99B76547A17519F5FD83862BD08C6C31345531EBC69A7F87CFBBE5EB8F
-      9F5CE1D9F349685A17D469E59A39845E30ED18D4DC78F5298A36D44FD6DEF4FB
-      D2A90FAB1AA9A78FF97CFA65B61565D053CBE2A533DDFF001DFF0057AF523FB8
-      D57AA1511A313642A04B749597F6D645051D54EAB975BB0FE962BEDB1BEC3DC4
-      363F2FF57E5D6DF979C0402214FF0057FA81CFFBCF5DAED36BCF1B534E1444E8
-      0C8A8AC64896266F190D239058FA430B7A85CFFA9D7EF504238987C5FC8F4A23
-      D961549B54272B4EEF97FD0DD4A5DB125D56348E6D3A98C8082BA5F56B0158A4
-      8BA8862BE9FF0061FDAF6DB6E7F1316D3F2E962EDA0140A8BFF4571CFF0017E2
-      EB3C1B3E399DD9623A4158DD5048F53E177684C841D0ED7917E9A3FD7B7BA3EE
-      9285405BBBF9578FFAB3D6D36BB7D6CFE0AF0A7CE9FE9BEDFF005797537FB9F1
-      45594F1CB1EB528BA95D9E3A801D116265D56D444BE970DEAF55C2DFDB7FBCE5
-      31310F46FE5FEAF4FD9D565B08D0A1D2348EDFE97C38FF0057E7F175CE9F63A4
-      D34E563465430C0D29710C9AA56604AC73469E7659437EE211CF16E7DE9F7594
-      22D5F3C69F17FABECFF3748D2C20590B68CFAFFABFC3F6F4E0BB2DA282ED1181
-      26BC4EEF13CAE258CA5E38A3548BC647F68923410BEDA6DC89604B9EDE1E5FE7
-      E8CD63B4028AB83F176F4ED06C58CD49651E430428D3D22ACA4D998C5FE774C9
-      1405DEEA79F49D5CD87B4EDB94863A7C3DDF17FABE2E9A9638FC5D49C3ACFF00
-      DC38252ACC16244964769344662448D942A2BB33CA65000B7E8FAFE9FC7BD0DC
-      9D4535F6D3A67C28F3D83ACF1ED58A18E3984A91D2854F2433D39FB9852440F0
-      547843B3962AB73AFD166B71CDD97BC721D4FC5FC55FF57FC67EDE9E8D557403
-      F075362DAE92048353C907859F5B9851AA19A22B1A471FEA8C54AB9216365D08
-      357B4FF5AD5D5E75C7F47FCF4FE7D1B46D13AE84F857FD5F975D8D8AC1A795A9
-      93D50AC71C74D62A8921F3A6B90C661F1CAA80AA87F26BBFF67DECEE2CAAABAC
-      FC55EEE1FE9BFD5E5D5BC1898C84D3AC5FDD1124692CC619E6F544C860FB6333
-      785CAB7ECF8DAA29D18EBD4A00900FA021BDF85F50D13504F5AD69FB6BD59906
-      93A8F489AEDA11AC6E63423478C32D42B14F13C2A5E452BA271287D5C58DD003
-      F9F51B45BA485FB9F3F2C7FB14FF002F44F71630E9AAE02AFE2FE1FF008F70ED
-      E832CA6085282B65D6A6C5E12ED131259808D797FD1F936F625B6BD32B558E3E
-      7F1740FBDDB6050FA1195FE55D3FEAD3D258C3E27202D8DFD2C0DB57278209F4
-      B165FF0078F66AAFAC6AE83BE0782FA55335ED3FF457C2DF671A753A949402E1
-      85EE7860757F9BBF05ACBF5F69E4084F6F467665D050C64123F8BFD2FF00ABE5
-      D2BF1756A8D112ABA5A51124823562B7F485B6BD24C976BFFAC3D93DDC258369
-      3F873FEAF9742BB4B900A70F8A9FEAC74316DECD4CE911F1D87997D1E0895638
-      99421D0148740CA8D7203B2A33281EC257764AAEC7F174208EE4100E75743463
-      6B04F4CF594953F74D3244248D8448D43508BA5581264546490318F533BDEC49
-      F646F0BA3807B42F4B5665615E961452496FD71890B47044480582369BDA6B90
-      DE956B0BF1FEDBDFAA7F170EADE228E15E84CC52F921812142EA0165483D5244
-      346A2A432B4292CDA97D05ADFD4B69F6DB8AC6DD3F13057473F0F424E21AAEFE
-      092928E69204F12CD2B792699DD966B47042896AA4BD906A6D4C2FC7164D1A8F
-      245CFF00ABE7D29560C2A0F4ABA4AF8E182585FEDA8DA9E47827695D525D7571
-      A98A9E3499D5818DE32CE150F23F57B466328C58F02DD5643A63908EB5C3F791
-      FD630F5FFFD6D467A20FFC62BDB2092B1EACE69600005C67F2CDFB97B92C9C14
-      0BF9F60BDDBFE4A171FED7FE3ABD481B17FC92EDFED3FF001F6E85D240563A59
-      F4B0B31442A9A9AEE183BDD5817BFE755BD97F477D78A1D08C2ECAD761641217
-      409A2C1D4141A08FD5FEBFBF75EEB99531A78D4ABB301A8295E2DF802CC46BD5
-      CB7E3FE4DF7EEBDD7085FF006C3BA789A3D4B329D4C88D16A3A636765BA18DB5
-      6BB2EABFBF75EE9D3199BC9EDCC9E2B736127106576CE5315B9F1150A81A4832
-      980AFA7CB51481E424330AAA342BE8F491CFB6CE83556F85FB3FDEF1FE5EB514
-      8F0CA93C7F1A1D7FB3BBFC9D6EFDFCDBFE486E5C3EE3EB1EE9DA798DC72F5276
-      B6C5F8EF45BEF696DB90B54EF3E89EF28BB02BB77E4AB6B57FDC85253E0B2FBC
-      B0F0C3A80866558230AAD4EAC02EB05BDF4B7A262AD7C2432D787EA300C47E4E
-      C547C80A5074B2D9E5B0B3B411BFF8A55A3E0062391E30C00E05910335325D99
-      8FC47AD79FE3BD3535461BBCB6224B4F96DBB8AA8A9CBD14F5D91A54A4191C7C
-      6F92DB93D3E065929AAEAA1862AE865D31A185F532B3B20B7B677F8A48AE768D
-      C63A570AE7EDC7423E5336EFB76FBB648E4A0ABA7FB56AF5553D9FFC6FB1B2B5
-      F8CABA7C563E930A997A6A4AC582B69A91AAEA28EA2595A4AC6824A99AA073A4
-      08D179E4DB49F723D8332E98C65467A89B73592E677548D5578768E90BB8B666
-      1AABABB6F62F6F64A796AB0672586A881F1B530D2D564B0B5A8B5F514D34A908
-      A3A7C83D7AC851FD1E45770C85B47B14EDB3B192E2D65D3A978741ABCB74892D
-      DD5CEB6AD7F2E805822923A784379503868E9C488CD1C8B1BBAA8BA84D488627
-      52AEA0A8E081F528F708D237D4BC74F4BB6C91A4FD13C2BD7358FCA020555F24
-      B1A2EB4F45BD1FB8919B25A377FAFF0087B40A0A1A873D2C99237935BA2EA5FF
-      005631D2E7E2DD35526FC92871F4B3A0ACC63D6D6D552A13F6D02633330646B6
-      C58C4904229CBB3156D27FC6C3DD77288C96DA5DCE9E936DE34CAC3CB59EAEA3
-      73F74647AA76A54BF4AE4323D9D06E6DB74FB732BBBF202A68EA61C8EFBDA38C
-      A9DD3837C4CD45538DC861700D07DBCB298215595E70F339549BD926D54885DC
-      447EA2B8FF0029E8D776B53241149102CA8748FCFAAEFEAEEB5DE5DCDDC1BC28
-      30384C0544E365E6F77647251AD5D3E1F6EC582A16A8A4C9519D626A3A7A19E4
-      F1C2B0B902340234642A3D8916748624965C26AFF63A0F476724CED04457C4A7
-      FABFD5F67407F7151E5043B7E4CDD264A2CC53C591C0E4A5AF02292AD281E234
-      53C34EC229692311C643F900935DCB80E4A851B83EB9ADA5A50BA6A6A70E3D5F
-      6E5A4370BDC68EA06AF98FF374B7F8C7F24EBBA2B7FE3731BEF1106F5EBE184D
-      C1B2B70E3727452E4F1D94D8DBB68BEC739B3B755245E496A70938226A39A3D5
-      3E36AE113C171AE374D35BA5F42B1C5A85CAFA7F2E8C2D6E8D84B1C92696B73F
-      C5E75E3ABFD2F97432F74E1874E606AFB9BE386E7DCFBB3E2076454C38ADD188
-      A3C949519BEA5DC5903AE9369760C345526158EAD915B119729F6797A7023764
-      AB4F596A40975A61B84FF1F1924713FEAFDBD1A4975F4A9F5565ADB6B1823D3E
-      7FF3EF4447B27B1B3F598CC3550C038DA13C35D59B7A2A89EA8453D445532435
-      35D928E248A5A8AB82468CF80B68486588B101FD9F585A0B25D7220F17F97CBF
-      97418DC7729B72458B31DB838A71FCFF000FFC67A0D30DBAAAF2868A4CB55C33
-      BA56AC6C6A296365C7D7222BD087A3585236A2291D914259D7C919E4824C9E46
-      9051B8745C140C81D1B5C2D06327872597C1D149855ADAFA96CC63DF42AD066F
-      4A2D5A2D3048D1122B2925008DC32483D320F615E60B49035B5F47FD9F03F9F6
-      F429E5DB80FE2D8BFC7F127E593D6790C32B3ABC3E49846F1CB2B2B2F9046A35
-      A0436FD68E6FA7FB3ABF1ECA7C220D4310EA7A1671CB7C3FCBF3E804DC787FE0
-      75F3D3A295A4A871534BAEE3FCE58BA35FE9242EF66FC8D5EAF6710CC662CEDA
-      54FF0098741CBEB5689E4319FD3AF49AE59E4911A68DF5A0053C8AEE575986CC
-      96BD84A6CC0FE4FF00B57B76A7D7A41A47F18FE7FE6EA29A6F286726CEAAABC1
-      644D3AF5226949155401F53EABDBDEBAAF5DCEB285D4CBA9BD000242B322DDD5
-      95C25EFA42DD6DF9E3E9EFDD7BA5BECD7AA67ACA1D13CF4C512AC3890CC94B3A
-      E80F4D231BAA2CC92295BF371F4B37B437D1A08B5F87DDD0876B6200A3315E97
-      CF878E58CB23492992710BAC52A2048C809392AA394D47FA7D3FA7D588A494C6
-      2BA3A10C51AB52AD46EA2556395633E99A4215E36BC7FBA8805942BAB451E98D
-      5347A957FC7DA53296CD14FF0083A50A02850BC2BD20B33452DDC682554929FB
-      6648DF546249047FB613597B9D76BB7FAAFCB2884AE9143D3B18A2D3A0C33588
-      9C1D6B1CD131059D5632502594C9620CA4067939D2CBFA7D3FE2736776A30D43
-      8FF57CBA2CBB8E46CAEA00FF00ABFD5F3E90D538B7D6EC134A8668CFAB4B0D36
-      27586E01F569FF0061ECEE3BB5A11AF3FEAFF8BE8867DB7C567213FD5FEAC67A
-      6E38D94FE88DC9009B9175B37D001F4E57FC2FED41B94A7731A745C76726AF19
-      EEEEFB3F2EB19A2753A4E9FC107EABF5B5C1B93A4A9F773701886CF4D2ED650D
-      095FF27F9FE1EB9434C44B729F4E3EB661CDC580FF005BDEA59430C71E9FB4B1
-      D12F72D47FABF0F4B5C1C2A248F5009ABC68A8EB214690BDCA7A15D94E846FD2
-      0AD87B22DC1C956A64F436DAD12354D51D070D3FEAFF00579743E6068692AE32
-      6A56424472412A31F0930B790AB246C10B87074DCAEB17FAFAAFEC0B76F22395
-      89F1AB57E7FCFF00CDD0B21F0BE23DC3A1529F68192323C2018603F6F24ECAC5
-      EA22852CA220DA2549110A17D77727F4DBD95999EAC1AB5AFF00ABFD8E8CD522
-      38D02BD3E47B4095A6A95892F241FBCAE92D3522552EB134722CA9A844C8A141
-      66E7D36057D5EDAF1DAB4C52BFEAFF00553A6D2194313222E8EA249B3A96BE98
-      C6B1D2C92CA16F4F78962411C4F3DA32B1934F12C5FA94DF52B71616F6F25DC8
-      86A187FC6BAF3DB4729D40F5C5360C4BA9568229A28A4015E8D29EECC5233199
-      7C6C6429E257442A072A6E7FAA9FACF1168AEC4D7F97485A28D56946D5D64FEE
-      32C13CAB4F4EF2C93C444AA5342C51174F2BCBE528E65477D3A8270ABFE0BEF6
-      D73330A1A53AAF86B4A54F5CE6D8CD34D512C88F1CA8A889A51479A20E6DA5DF
-      509E696555D29AB4ADBF3EE9E33FAF4DC96D1C829534EB849B29E53131859143
-      9E43C51D432211F705D827ACC8ABCA72358D3ABF2762693D7B7A4ED6712E351A
-      F4EABB614931489ACA7EA9640B791E14F323A471462246B1D3A5C1BA200DFD7D
-      DE399D8E93C3AA1B48F4D751D5D37D4E0529FEE41A7A6589E9D9DA669C0A682A
-      2591123D20C6F301AE7E486E357E3DBCCCD4240AB7556855759D6DD639B1F1D4
-      878446ACB195F11834BC1370D15408E445652C238BD5A7F48FF55CB7B6A37762
-      2BC3A4753A4AD307A8AB8592A13554414EC1A38D190C834AAA5D23446D734644
-      AB1905342DCDEC757B6DE470CE1475AF901D497C178E748897D7524B24C5294C
-      4A148B428D1BFEF1969C5C3693A7E9CB69F6CEA24D17A7D2531D748527A7BA2C
-      0962B278EF47AD23558C469054D4411C24F9182684306A5B2EAD642B1BB2B73A
-      2C423B0E8C51CB45193F17F9BACF538786A29E99DE9E58EA60467F0CE520630A
-      4FE111495044A248DD5811A5429D2DA987B66099DF5EA1E7D79695EEE1D25F31
-      B5519CFDCC11FDCC8B2EA29E4BE962CF1A279228D3CB1016214FA94FA4FD7DAD
-      47746AA9EAA406143C3A037776CC314D54D09A8BC5108809A55D2F026B6578C2
-      E92FEB218EBF50BE924DD7D9FD8DFB553553E2FF008D7FC57443756E8016A1A9
-      E805C8623EDD9A35B94477026165566D52292B76D4C4E9E2DC1F4FB17DBDE095
-      6B5CFA741AB8B30A18A6AD3EBFD2E9A23A505DCD9CA5810A3F5150DC33073A98
-      13FDAF6B1E5344FE2E93C16EA25626AC9FC3FC5FEF5E7D38409246094652B712
-      10C752844B9D725800D6BF1FED5F8F69A42AE42B71E96C2CC86A0F6D7F97F174
-      B0C5CC7547E54468550B847755698BE940D1B96040F590401CA9F6517083BCA8
-      EEFF008ED3A3C82666346F869D0B386CBB88D26914C4F04A851DC0954901107A
-      53D6C962DA9B8B2FA7D905C5BAE0018D3D18A49E6DD181DBF592D520923F3032
-      1D20CD1E9052728C69D9743A4BE9B10E8A56EDF4FAFB27963F0DBE5D2B52B211
-      A8770E861C342F151CA22648DBF50F20D052699DD5A34553FB32225C8B0D45FF
-      00C7EAC52A181E95A3E904118E849A0A6A87928DBC7178C5247F72D1CF3A4B22
-      D899DDA491CA98995180BAEB523EBA7DB0C2288F73E93D2DB73A83AFA1E952B4
-      73353486645AE682166FDCD32C509914A9929E768E3323781554A0F407D27D3E
-      CBCC85BB0D34D7AB312CB30F4EB5B8F791BD631F5FFFD7D457A1E146EAFDB3AA
-      F7F2E6D837935681FC7F22ABA0023C4C5E3FF59BD82F76FF009285C7FB5FF8EA
-      F5206C5FF24CB7FB4FFC7DBA1942218DA357E0DD56FA4B5C851AC5C7A975FD3F
-      C7D9753A36F0FCF575C012225814246237564F159591D6EDE301B4904B9FED35
-      88FECFBD67AF7EAFFAA9D65D7A915BD6C74B0600AB3FF5D2BC2A29BF3F5BFA7D
-      DBA77A8F1BADC790B8478C246ECF0BC520259C3B140D187F4B5DAF6F4FBD75EE
-      BC92A0678A479A6130770C4AB46911500C42E018D5F57D3FE0C7FC7DD1B2180E
-      3D25764649929DCC857F3656EAE87BE3E58677B07E387C389B1F95A293787547
-      C64EAFEB97C7BB79A2CEE3B616EBDEBB26864AEC7C229CC8F8CCAE0E96691995
-      F46A81FD4159BDA5B2DBC47E3B572CF5FF0057FABF974FEE97649B708A140853
-      B7CC90A031D3F68F2E273C49E82BF8ED16DCC2EF0D9FBB770E7A9768E333F8AC
-      B60B734DBA2AA86831C23C652D663E824AAC8656A71D4340D4988AB87CACE5D4
-      4A3571C81ABEB0BABBDBBF421D5A5EBFF1B14E96EC37D6F67B93B4EFA1244A67
-      8641AD7D3A229DFF00D9DD27B5F73E66997B0A0CFC38ACA4ED83A5D8F4D0E608
-      AC8279A3A88856D3C34F898E92B113D72190A481DB497B6AF62FDB6CAEC5A44D
-      2A5242B9AFAF40BDEA7B08F70B88BEA41881ED2B95D3D146DEFF0021FF00BD14
-      14B57B53615763A8B6E5545264F32D9D8E392A6AB2334A282A1B1D4919A38A51
-      F69369F171EB71212182FB3DDBE31B7DC4D233D65714FF006BF8BA0E5DCC6E61
-      8747C087A49D46EBDB1B864C7D560E6FB7A8AB48EA7338FA970A132B5D33FDF4
-      F490848450C7F74FAFC4AB247A4DD1F4FA42CBFF000A6B76480F7B748ACD8C53
-      F8923513A5D6CBA942B5B8CAB86175588D7430CB1A330751E19A28C48246FDC2
-      A965B7A486F60FBD0498D87C21C7521599558E8E73A0F49DF8F637356E5B1D91
-      C46D9DD19BC3E369F271D6A6DCA5F1D554E5556A9F1540996AE31E360A596BAA
-      3F7F5CA2D0EBE2F6F667776A2558D7F169E82B6D3ADBCAED37C3ACF46573781F
-      957B9A6A2ADAECAD37566D2F0D55150F5DEDFCF4188C252636A04A2B167A612E
-      41EBA9AA012867AB79025ED18517F778AD6C604F06038AF1D3DDD6AE773B99DB
-      4A6948BF83CBEDE85AEA0EDAADF8B997CCE7E2DD9B2AA2BB358AC9E0E5A7A59E
-      095E6A2C853C587AEA282B904BE48D69639E194A4491DE791493E91EEFE1593A
-      98A78AB1FF0017CFFD2F497EA6E9099A396927A7FD0DD177F90DD8F4FDB7B9B2
-      3BBA92970B8FFBDAFA496A6A3092E689A8963A3968E1A8AFA5C8414F8E832555
-      1A97A89E8A2822ADA873318C3EB636BD81523B6087B90693D3D664A4BA88C53A
-      2ECD24B0DC3C82686A23F0CF1E9658A6A572AECA7C61543A950CA782ADEA1CDB
-      DA015F2E3D2B7D2C5D470E9CA8B2FB9F6D6D9DD7B6B6A6E3CA62B6B761E2A4DA
-      3BA7094B3D5350352CB3D265609321401A482AB1C321491C9E32078664F34247
-      EE2FB3080412CA4C9C4654FF004BE7D17933DAA3D0F6B8A1E8DC7C7ADAB4BDBF
-      B476AFC6FDDB827C66E4DF593DCEFD0BBE6AE8293098CC8765E3286AEB60DA19
-      ECF663451CDB6379231C747551CB1FDA4B560BF98D3246125D3DCDB49E2A2318
-      FCFEC1F17FBCF4E5A5BC573E0DAC4C12EDC367D7E2C7CBD00E89AF66F4AF6074
-      2F68375FEFED9B5BB622DC3252D763D2BE6A5AFA4AAC44F3BBEAA1CEE22AAAB1
-      7928685E07092C72BB46F1F2BC95F6B92F20B881E58A4AAD3FDB7FBCF49E4B4B
-      8B699239E120EAFCBF6F42C506E0C5E2EAF19BA2A9725FDD3CB0A4C0EFC9E9A2
-      F3D5E1E2A99571D83DED8D5468A192A312604A6AA85DD63A86A6841E1D4FB62D
-      02DC43716930EC271D2C943DADD4773050D173E9D2C7334B90C26E4ACDA99E86
-      48B3B8C5824758A211E3F2D8CC9D15264315B9715AA447A9C665F15530D54634
-      EB48E6FA7A49F641736925B33053FA4BFEAFE7D096D6E5678958B9F1BCFA6BAF
-      C5D0E6E9E26ADA64921D05956432472C6EC4C7A91E220C41B483C6AB8E1BDA15
-      BA9149083B2BD2F6B58C8A3FE2E3D22EB3AFA8C82D475534052324413A09A36B
-      C81AE5EC9281CE9E353F3F9F6AD77175F8874925DB20AF61E92B59B1770D3451
-      C94F0C3551CA048EB4EC4946D1E8122C9A2792326FFA16E5BFE41F6A12FE07F8
-      8107A46F61711975892AA78F5C315B43255FE77C9AD4E3E8E06912A67911E39D
-      48D05121120FD27D214FF685FEBF4F7696F922A686A93D5A0DBAE1DCB4D090A3
-      F8BA16715849309451C74A1648C462692510C624A8765505E7963085CEB93D3A
-      D9F8E3D924F30692590D695E84915B911A2A91A69D38B5205A745B81389A2BBC
-      6C59AF2BB81644F118880402598A9FF0FC2569626C7F93A53123A16A8C74C759
-      8E4AA2920678D598C6F09043C3A15CCBA8A0D12B2332347C9D57FA9E7DD4C919
-      8FB7E2EB4B1B87151DB5FF008AE9AE7C353EAF0343AE7791E4FDCF32056218A1
-      6D24867627D015811A348BDF4FB651CA1A7974B10D010319E9A721B41AA04665
-      679D1AC5E48E274A799A56D2EFA7D0EB22B2F3AC0E2C349E7DED2E3F5028F8B5
-      755C7882BD22AA768231599686A2A149D084C651848E47EEAC41BD61987E5AE3
-      F3F5F6B56E6441A4B693FEAFCBABB04F3C1E9A66D9A22AA123D3A491BE91E402
-      43A24689889407668B8913FD816E7DBBF5EFE1E1F1D50411EAD6173D42AAD892
-      2C21BD324BE5FF00391AA1464110054C68349553C7E031BFBB26E8DAB07B69C3
-      FD9EAC6D22D34619AF4C151B526855E6D2D643146A62B3162DA5A22147ABD696
-      B0BB6AFADFF1ED4A6E7ABB0FE2E9B369107D413BFA74A3C249E39078E6332278
-      9A28E9DC0770ECE046CDA0292ED6D2A559B4FB4B35C866C9A2F4F24623A2AFAF
-      4316D75785A081A999033EA55B011B552CDA135AE979BF7092DA4B3F1C7B0EDD
-      85760564FF008AE8DA298161A8777439EDF7A35A8D4A9216AA8E2899EA54CA57
-      46B54548E59FC9053473336903412A3E96F658CB4E1C3A338E735E3D0954748F
-      23544CF4F1BD2AADA165BD348D2A888D4A4E1986A8D046AC8E2EE755BF473ED9
-      F0D3F873D2856350C0F52A2C14B1D6A5424E8AD34758F3D1952E14CFF6E52459
-      6292578E4A7F1269D65B522DB57D6ECE9EFD3E5D7BA7D8315136A0F4FA4C2EB4
-      ED2398543467596923517658E37A86D3AD912FFA6D6F6A7AD75D260A06AA124A
-      A250F574E8BA29E55A85BA3B2008B33C21858BEA3A58DC0FCAFB4CD2C6A74B48
-      D5EAD4EA4CFB762ACF217A79AD6689492079347925BCAACEEEA9E34FAA8D51B8
-      B5EECA3DDFC2F3D79EB55F9751EAB0D0B52D329A18D1D58B3548A92B2543B87B
-      A47E7D34D108B4328D258D8FD7E9EF41199A8E3F3E93C91333390BD9D419700B
-      A6579240CBE4929AF2C6B4D2424D919C00BE41A220C410A19F81A981F6AF5AFA
-      B7EC3D343A63970507DBF8E3997C81C48D232322C43D055C2C684CA6A15B53A1
-      B95FF52D6F7A12A1D201CF4C683571E4C7AE759B724F52C346CF142B098E5867
-      D10F85E3F53B431476A96563FA83865F571F8F77D23D3AAD34F0A53E5D37556D
-      914E5A611A42BC307A8F0DD03C63CA1C40238D5B5B8080A861EA3F9BFBD69C7C
-      FA6C85A38033A7CBF9751D70CC196068A9E15A905638C02098C53A8609A74857
-      7791348401F480CBF5F77AF48C4127A0A75CE9B0E689218639078BCB334F1F9A
-      564696470CCD7AA20334B181761A5C1FCA86F7AD2BE9D5921955D1883C7A7496
-      85888E075F1D44F2C629F912A4F1491021CA794B48CC884A46E7E9F86FA7BD37
-      0E9679F504E3682BE178647D2219635314CA825658DE231B4718F0E81003EA0B
-      7FAE9FD5EF7D7B8740D6F5A0898D4790553AD3995DAA755346014A8D70B07826
-      308122CCA6CB6FAFF553ED65A9CE9F3AFF0093FD8E8BAE5F406F138D7A2C59FC
-      3869DD93EE5D105ED72DA6494DDA4916CCAB11765D1CD87B13DACA5050D3A269
-      1434A753E2BFEAFF0057EDE92670B2CA3D1F6FA95D159885F2282C0A9408E599
-      2CC058FD7F27E9ED7FD5A0C92DA7F3E9A36D5CF6EB1D4F836E4D348AA8B19444
-      46901113C834850B2481597C60117622E0FF008FB64DE281C3BBAB8B72748E95
-      549B5672636108673A3F4062DC85537760A2C858B7D46A0BE9E7DA27B82450E1
-      6BD2E48748A70FF0F4BFC36DA929C992A504EC9222CC8A92AC28225880522466
-      51AC055FA9E47AAE7DA09E652005E9F8D6BDB5E878DBB8E30AD29781E79A4884
-      3AC208A1409A5D5E694792549E70747D6DA97FB2BA75154D52B81E7D2E8400D4
-      1E9D0ED8CA17128F1AD8CD48D4F0DCB5349311A5093E3690A6A7B59FEA96D3F5
-      FAA5AF4B13E21D2E2862D4A90B45554EE61FF2974A98CD25A9D83431C4F22092
-      53237126A16E2E4F1ED14F2A2BA57A5B09D09A7E7FE1E946249E5A3925543349
-      009A62A02B6898A9FB8D6A8591A3AA57FC39D02C7EB6F65E32F5F227AABEAA4B
-      ABE2D3FE6EB5A8F7923D63475FFFD0D457A1C21EB0DB274393AB34CDFB6BA5BF
-      DCFE58594951AFFE0A3E87D82F78FF0073E6FF006BFE01D0FF0062FF00926DB7
-      FB6FF8F9E8629248A2900B328537B471974B805BD4AAA58900F079FAFB2FE8F3
-      A8CEF1A2E9607D6A230AB62EC598BA846BA31742DF4FF0F7EEBDD4B50A60B09C
-      D3B44E968954216655B160E2E80E8D5F50BEF5D7BAC5554C5A12D2A028514463
-      C448B0D21D1981F5B3337AADFF0022F75EEB9A048E458FC2A9E450A8DA1180D3
-      60C2151775B5EE79B7BAE915AF491D028908F8A9D1F0E8CC1D26EDE93AACDCD5
-      98FC4E63AD23ED2C6499FCB485A8E836C5447B3F7F22CEAC8B4D4CB4461CDCD0
-      31BC9354D47892FF004F778A4647897F0BBF54941922F1E414D1DBA978F55ADD
-      B9B89FB07F89D4D664E49B1AB11A6C1C757535DE5C6D3FDE40B55598FA6411A7
-      DD652BAA927AC13421A6851D964500585F6AAB6C948D30DD012EEEA5B97705FB
-      751E8B1647ADABE9DF1D3D7D5C5574D59185A37A49DAA699A10FA6031D4868A2
-      305ECBE83FDA1F5E7D9B3AB2F87DEC4B0E89B514ED5A63A16301B32B2AE96A76
-      E62A64C052BC58DCE6732147495356204A1FE2B4348993ADA55ABFB586B6BF2B
-      12879B44238D64041EEB35A3DBAFD436AAFF00A6F5E9642CCD17867F1374F79A
-      E9CC2F5FEE2487B2F195D2563E062ADDAF4984CBC503EE1A9D6865CBE4F2948E
-      64870B4B2B786368FF007A72ACD74B1012BCCE21F1148D5ABA7E1B7591A86B4F
-      974DF81C9B63F37055CC2D0BCD247570A4659043501A392FC359628A5D76BEAF
-      4FEABFB26991648CEAF8467F6742786E640E883490D8E97785EC3336F0C76C93
-      B88EDEDB74150D89A8A4A079B1F10845E38A929E9E048168CD53AAA8953F42B1
-      75D4F6F669964B66A77320FD9D06AE452E6E40FE33D1DEDEDD1D4BBBF6CEDEDD
-      F867ABDA5053EE2A1EB5ED0AE868AAAA23EBAC8D763A49F636777A63D9FEEF39
-      B764924F0D555528FBDA44705C4A6D192FB7DC2D24BBB9B46F8D7A32BADA2786
-      C2DEF22145E0FABD5B853D38744B373E237C7C7FDE7175C767ED8A2A9A3ABADA
-      2CDE526A58683746DBDE5B6B21566B29EB31599C70AC5ADC2D5471DD23094B55
-      1DD84888CCE8CBBB7FB48F8745055D4E97E3D63DE7D7D1EC48B72E2604AE9628
-      72310A27A8A458C4DB7EA6A71D9FD8B9D86A74B35445B9B6FE7676672EFE29E8
-      DE2B69D3EF73CCD35BA3BE9F8FFD5FEAFB3A57660B4A541E23A089D3C8034481
-      EFAB899D85ED7178D57D3A85B9F686A7A300814D2434E9E30547512D6BC54552
-      5320D4A7EC94C50C904F2D3912BD34D1CF1C90B796306DAC32EBB065FC8D34A9
-      1FEA4C7F4471EAD1DB34CC574507FABF6F4A3ABEC7EC7AAC9E3EAF29BBB71D46
-      4B6DCF4F260FEF723544E0E7A0414D48D8A893C71E226A18C948DA9FC656E6D6
-      D4DEF7E2BC91E82C7C2CE3E47D7ADB5AC71C91AB28F1750EE1F175621D3FB872
-      5DDBD17D95D7F58877DD66CDEB5DDBBFB0DB0772E506426A7D9DB6569F37BFF3
-      FB6F2798A9ADA8A4DC78F6A2ACAE823A6306992923081DE7285981ADA06A18E8
-      1CE914C756BF82EE5487E9E42CC1BBABE94FF57CFA21383C454FF19DE5B3F72D
-      2D56D6C06DDA53B7F7ECB90A8869247095E953363286F054B64E4AAADA40B0A5
-      32992A51F822305FD98C60DB972BF169FC5D222BE255191573E5C3AEBB1FB172
-      3BFAB36E19098E9F64EDBA1D99B52B25A4A7A7CD2ED7C1C93FF77A8B2B514F2C
-      A6A8E228E5F053095E4686982C7ADD00012CAC652CCF4AB74A134C423F0E463A
-      7FC1D3FEDFCE2E6E91E2A99A9A0CB4316991C594D4C8CA16392084048EC15492
-      16EC0DFF001EC86F2068DF52FC0C7A10595F09FF00447F6C38F4F8D0BC516933
-      2AC6A08407470FCE950E1031E17FC496F698F46527975D352DA95961280344A3
-      CBE30AFE3D64CA58DD15DEE874DB4F07FD8FB68E5A8DC3A50028883AF1D3C7AE
-      A3869EB202A4C91C6C15C950CAA0A0D64D38F181EA67B6B5B1205B9F7ED291FC
-      0AA3ADC64C95F15CF6F4E421D29E1521574B45196B968C68238F1956167E4DBF
-      DE7DB4FC1FF3E942A851403AE11B135EFAE29A4D50F0EB018A35B806D24F7BCA
-      5D5F5063CD978FC8F693ABF5964844D7BA2C65D951DD9B4B1210FA22B2830F90
-      EAD42E402BF403DFA9D7BA81261A9A6696A9AD24B288648BC4F346C3C17F129F
-      430584B2D9C8FEBFEDFDC320E7AB2B9028294EB2AE2EAEFE0080CD208E48FC92
-      4A23816431C8FEB58FC934A8C9E8BA906FFEABD2AD3002AF4EEE9CA0A6A3C3AF
-      4D8DF2A2A8863906A4334A6653E37D404B2B0610B0D63841FACD87FC17DB6642
-      E72057AF150727AC72E1290426210B982D33A9693D4B202A0412A469179A3080
-      5AE2FC7FAA37F7A7663D8DC7A5AA0048E53F085FF2F4DCFB720611C90C044840
-      F4C50A48F210583BC7A43B8595FD4A9E8F55B57F4F7479021551ABAD021CF60F
-      F57E7D772ECAA77874D3C5A67667F2B46A5D580521E27610EAF33117B0FA6AB0
-      1CFB6C4E146AD6C5BFD5FEAF3E9CF09D4D40A9E99BFB8AF0CAB240D1B2490EA8
-      299D7C322562155792689A221638A37FA13A8C86FCFE2E6E7C4D2083ABAF2C4D
-      E78EA3C3B7E587D6ACB14DE7654D4ABFB884AB09544A1744D236ABF02DC0FF00
-      69F6DA4B5049F8973D35523ED1D2BB0F93484AA4ED239A851491C455502DDE1D
-      72AF9142A3C91B489EB7B32F3CFB6248D947974A23B864C3743261AB44FE3495
-      CCAB24AD0A89D9A668E6BAC909772D2C2823315C2D9356AFC5BDB52455AAF467
-      14DC718E97B053C2E7CC2A24923974C30B4AAFFBA5E984056129A2210A156001
-      211BF3F4B7B65828CB8E94AB6A155E9DE3C58A5814072B1AAB2BC75324AE2787
-      5089CD41941792111DF86D4A87DDBE7D5BA7788C91300E267807022A681DE791
-      653AD961240015D2350BCA5C7FB4FB4EF1238D6DABADD698E9D21C5C95502B98
-      DE9E12BE4A84558CA49248D1CE8F7749C238964D767FF5BE9ED278D2FF0047FD
-      E7FD9E9BD5472AF81E5D42970B1C7592E884B554DA5245AA669515502793C3AD
-      1843028F4FA405770580D5ED5C65A44A9E3D3940B41E5D47868E56C947453C71
-      4C25A512453831D37EE14177FB85D5A68F4B47A9DCBBFA7481FD6B3111A2E9F3
-      FE7D3020FE9758EA706FA69DD6559C8FB796E630AB776611AAAF90136BD812E4
-      FAC86D2CCBA6F1336832B7C5D6844A06A739EA0BE1D210F2472A44D2D5BFED31
-      F2B142B109A2F020645758C16007A2E42F2DEDEF11F86B4E91E953D8C73D416A
-      18A58D9FC1239D339B7863697CEB1323C3246DE08E191D5ADA1C80BC7BA9B823
-      F0FF00ABF6754228A1BAC726144924CD263D19638925809B555553BC29E39824
-      0B182EA0840BADB57A78B0B7BD34D20F35FCBAA6AC6AF974CF3D1A4656CD4EB0
-      79C075965319D6CD68FC618C2CC805D9420F56B6E4FB5484B22B1EB7F3EA14B4
-      F514CD23B514D4D430A85FBD0AD5553A7C49A23A5A13465DA22CDF576BDC7D46
-      AB7BDF5E0452A0E3A6EC9D388BC6E2198A1922642F0C54F2C8FA247D10C2CB23
-      D3A36A5B89142A93F9F7BF90EA92FF0066DD02FBB842629D02ADFCD2EB595A16
-      8D09465D3A1D88011A4E2E0D8A9FC7B32B74A30407CBFCBD155C9D254571D17B
-      CB521964F33B48D7645744D500D112B5978D09144C486B35C5ED6F66E868294E
-      DE8B74AA209013ABAC189DB2959231562D148EB27AA3B0B69FD5A9959F5EB05B
-      9BDF4FF8FBDCB295040F2EAC8A65E2DC3A14315B39DA23522091A51121F02A2E
-      B72DA59CAB4912AB6941F4D08BA355FDA37B955C9F4E97AA00571D08B8AD9C95
-      3023888095C6BF23C6AB3C10DB984C8A4288E40DA7F4F3A6DAAFF5432CDDDDCE
-      7A50915680FC47A5052EDA7C68467542B0EA6F107742912A00C0EB56981593D6
-      182B3E85FD24AFBF510A9D473D3D1C67C4A0F5E847A1C263D69E86A68D5EA195
-      A459CCB380D04322C529705E37F2EB7F5C9C07F1E9207EA3ECBEA58B7A57A58A
-      BE4A3A58515044F54D0A8A7FBC484A54446517856431473A4611519B5A22FAF5
-      32316F74908D0E3E5D3B1F06E84CC6C11058645995544CF1CA199666D4AD1452
-      7950AFA924B051A56CC9EAF49F685E2D40339EEE945B26B7D2FC074E15486969
-      2AB208681A969A3A8A678A511C494DA225915911E488BE91A8E9750CCA2DFEBA
-      3E1253CABD2E686321867FDEBAD613DE48F58B5D7FFFD1D45BA19F4F58EDA0AB
-      76273366BB6803FBC396FECEA624B15FE83D83378FF73E6FF6BFE01D481B17FC
-      932DFED3FF001F6E85ED7E5576D53D386322F92E215364B121A4BFE90393A7FB
-      5ECBBA3BEB9C70A8402405D75A278CE965561FDAF55B559AEC587D7DE874D45F
-      8BAC50B206791025E47563E52AAAE6EA100D4966E3F4FF0064FBF63AF7E9FF00
-      AABD658827944E19E6920FD920B02210E04A4B7AF4B16FF69BB7BF74EF5C95FC
-      CC8EB1F1210DAC92892AC634FEB5FEC1007FC1BEBFA7DEBD7A4F2D344B4FF563
-      FCFD2F76EEF4AEC46D7DCFB06AE4AAACD9DBC32585CAEE2C452D6CB4D3D6D6ED
-      D5C9478F0F2AB04928D1324EF2C2A5448E8973E8B7B53653436F3AC935BAB8E8
-      BEE20B8BAB67B78EE7429635E8AAF7361AA7032D6E7302EF5D86AF2569E08FC8
-      3298509111143554EB09A79A91A0D69AC3B3005B58FD2DEC4D63796F72DD8FA4
-      57CF1D02EEECAEAD1BC29217A7AF974EBD3B83AD6EBDC8CF997C9559A98EAEAF
-      67ED68F0B1D5D054D33D3332D7652B64A1CAD4C38FACCAC0ED4D047046251134
-      8D511476D4210D2C02828C1B3EBD13B450DC33EAF8D07D9FB3A5AF4CCFDABB3B
-      2FB9B290D6F5945B5F37414B8FDED8CDFB554187C3647194D5C32BFC3689A069
-      73F164A96AE9C785A8B5492B100C2F19D1ED89847477BC7EFF00C3A73D2C85D9
-      7BA23D3276FEFAA7ECCDF791DD34B8A383C77DAD06330B855AB3543138CC6D38
-      02956A4474AB2A495B3CF50098E3E265E01BFB0EB48CEEFABE1AE3A11A05548C
-      8F849D47FD353A0C592C358B2B6A550EC015BF93E9F51E9E7DFABD5D1B4B4A2B
-      E4DFE4EB06C6C1CE7B5E2DD791DA996DD9B5F6C53D56F2CDD3E3A7820A818CDA
-      78997399378D2A268E2A91151625E49213A59E2527F07DBB3157B15875697268
-      3A451C4E9B824DF4BE224685DA9E617E2FD9D5A26ECF9C9D8DDD7B66976BD363
-      6936A6CACB9A1C3BE131A9064B78673138968A6C7C7BBB7754D1432573531102
-      4694904288208D35BE80DEC2C36E8F6F93C4033A48E859FBD25BC84009A2D9C6
-      929F2F5E8A3768ECAC86CAA9CB4B2C196A0A3C0E7692BF214926B4AEA5C5EE8A
-      7A79A1A898BAB4C24FBF8A3A77D47861FE3ECE36ABAD6EE96EDFB7FD5FEAFDBD
-      15EED691AC2F2153E1A2AFFBCF97427ED2DEB49BAB60D7EDCDCB999EBB6F4388
-      6C6AC794894E471D4390AC8A9A7678D8B32CF81A8916B29E41F4F03A9E1BD987
-      84F4D4BD1109E369116ADF1744F33784ACDBD99CA616BA38E3C9E2727538BC81
-      121D25A8A778A778C3051E19993C885472841FA7B6D815343C7A339082AF4E1A
-      57AC3455494559495D1C81DE09E331D9ACB7563248A24FD0AD22294FADBDD1D7
-      5AB0F975A8252B22923B4B742A6E2DB9167A0A7CB502C4B5A62497544D0FFB91
-      88ADD41749001347F40E7493A749FAFB2982492DDD95BFB3E8F66B64B98908F8
-      A9D26B656FCDCBD7B96196DB73D0C5948E0ABA78DF238CA7C8C34951551F81A7
-      34D501A296A68DD166812A44F024F0A48D19283D9B0652BABCBA0F3ABC2E541E
-      EE93192CBE633B98CAE6F3B93C9E733595ACABAECB65F35595190C9647235121
-      92B2B6BABEAA496AEB2AE7A87D6F248E4937BFBB757B8FC1F9F50B558D9751D2
-      58CBF860AE158052FF0080A79D3FDAF7EE93F4F5888DFF008B63100623EEA98F
-      963748E48AEDE92ACE3FE41F4FD7DA69CA9825038D0F4AE0655B9853F16B5FF0
-      53A1CE6498195D96412B4DE460D22C9E3754092AC2A58469132A700061A9BF4F
-      3EC8FA18759C089D992E019A28DA68D0833B8BC4E6CA3D31AA166FC291A791EF
-      44E2BD35FE85FEAF5EB24B15E40CA083297584B3A4D254690C3C8912AA9842CA
-      8DABD4C406F755915FE13D5BC45E343D6740B1D3F9110F90ABA46C2FADE3F1FA
-      3CC246B44413E9FF0055ED231A4FF2AF4B13588068CB53A3EDB6BE1F6C6DFF00
-      B3463BA47BF69BB37BCB23B031FD8543B46BF6B63FAF3AB062608D6B37CEDCCD
-      6FEDCFBBE9F2188DDFB4A16688A3E2C52BCD048CE63A36FBC0F948C946991BC2
-      CE47C43F2E889370BD93C651B400D5EC2C78FF0016AFE1F9745F779FC6FEE6EB
-      D93278CDDFB7B0B264F18A6A73106D0DC98BDDD45895F05355886B6B31950F4F
-      3D5D3C1511799293EEA99D5B547248049A1DBADB82C51DC59D5E1A5493DAD4FB
-      3A7EDB770D27D3DF5B225D569A81A807F9740D44C8B1488ED1A42EBE28A408B7
-      28FF00E734D421643247FD7EAFC71ECA5E32E294EE1D1EF86596A3875262A18E
-      567BA476D1024123099029891995CFA422B865040E0E9F52FB6DA41A4E734E9D
-      C8E3C7A9F1D0D3DA611C61E38FC2EAC1D58216FDD2888F3B091D95575B122E75
-      7B67EDEAEB1BCA188A69EA5AD192B56E20752D26891E60191D42280A5237D71C
-      686E545D85C7B6CCAA09A83D2D78D9A2007C5D71A7C7BC759E7865469167A657
-      8A38352E98D4C91C51B327ED79A26D02CAB728FA0D9BDD91C3772F97548E3648
-      E87CCF4F915347548CF0C6D4D4EFA9203A99E688150258E35952EDFBCECAA0AF
-      1C01FED2CBC4DDCDF87A521D48AD40E9CA7C4158591D643748E36935C7E50DC8
-      25222CF1AC92EA37451A01FD5EAF6965934BAA6780E9C0F2A2D21E1D06D9EA2F
-      B48485A7692490FA233295D0486B2B310558312CD61A39BA0F6A935382B5A2F4
-      CDC25698EF3D04B5B562826B08E525C47F7242ADE20FA5A6E011A14A80AADA7F
-      51FF0053F530481DF0476F480B480D2BD2FB6E6EA8C4912145552BADDE7F4B98
-      D7907CAA5F962B60EDCAEA27E83DA2B8B4600BB0C1E9E865209A8C743CE0B318
-      CA84579A78E03AD18B993C8862692E143949D3C914BC3155B5AD65E357B2B960
-      14200E97C731615E84FA36C7D632D3CB344C6354448B5C66A64F339D313EA6D4
-      C8B18D3C5EF63C7D7DA13130383907A50AC08EA7C14F4F04F1BD1D4AC49513F8
-      6486A01864A89D1DE195115996542851ADC325908164F6EC6E889A5AB5EEE949
-      9B1C3BBF974FD0C5288FC73494E6AD86A9DE9DA6148D3874595A488868D6214F
-      0A47132AB36AE4FB4C6A0E78F568C6B88AFF00ABD7AE5256059015594BAAC824
-      773E35767D64B2D9975454C5F5B1F4AEA217FA0F77589DD750E1D68C34C6BFE5
-      FECF588D3475061C84D09D71C739482A6632F8629296A2128E104C920F2482CA
-      834FE7DA88629233534E1D5D174AD09EA04ED2408D2A4C958C91698A8A57F2D3
-      D3CC278A596630831B3C3032803F4156FF0069F7592191CC87F075A72E3B94E0
-      0EA5450E3A58D9604915825E58A58C2A092AC1D50C1279BF6242DA8AB11FA7F3
-      7E7DDA285D5B3FC3D243420D4629D37D4D02398916D132353895F4C5239D2D65
-      F3C52CCACC92CD724869081FEB5FDBF4308F5AF4C90CA2BFC5D434861AA7AE87
-      C5219E1A794C480FEFD42532331F24A3ED8870D09FCB3851FE22EDD5FF00B4A6
-      3F2FB3A63C192BAEB9EA32E360AC824A9109ADA402278EA7FDDB1AB3243E18E3
-      FA318AA740D4C481A873EEE092D131F3EB691C81AA493D41A8C7D518AE6068E5
-      93C6B53134C8B140CDEB9A495D93C091EA8B404746BBB7A7F481ED52BAFC46B4
-      E9D8FE21D2333F1C2910632CAEB1C4D1C6A4C842A88D236554D461ABF1E8258B
-      7D3E961EDD88A3351BA4D3A9346E8B56EB9A29E15BA8F23333382C5E20D1F991
-      652A1495132E9E09FF007AF6756EBA4907D3FCDD17CB42C7570A740DD41469A0
-      8E2D243348EE5D83395B02E1625BAA29B6A6E6CA39F6B42D57A44581253E5D08
-      B81A296448E4863A53C44A8E9348D2BF90EA94A240E816658085FAFAADF8F696
-      6385F4FF00374FC62B803BBA1D70D86924FB529A9C1304968089239248E473E5
-      554D3314BB104BDD3FC3D3ECAA5959585071E8C628ABC3874ADA0C49F0C913AC
-      15F2C52CB4B3CF287106B0B1CD1286114459A9EC04B6F4DD7D3CFB4CEC58927A
-      744235549A8EB2FD94F4FA6278E3C9D5405E60418E9A1B6B554485E7694CB224
-      97B1E3D23DED0E935E9EA74E85599639DA278A3F2A3B43199A1903AA8998EBBC
-      64B05BAA1B58FD2C3F3B9240EC580A75E425169E74EA642E6AAAE09E9E561CCA
-      EBE2556A6291C88A81BC718793448349477B017BDFDB4EA594E9E3D5D1496047
-      0E841A46F50D728D6D233C5153C4D18F1A20D4000CAE23A55005C306628DFF00
-      05F6C787A5B531EEE94C0B4952453DA3FD9E958F5092D33296A8F2D48AB28631
-      1C89148E83C4262E19961656653AD9438D4BA4FB2CA7EA63857A3069E301CB57
-      875ABAFBC90EB16BAFFFD2D45FA2A276EAADB6CACC149CD0720001146E0C9D88
-      B8D0CC486FF1F60BDD811B8CE7ECFF008EAF5206C55FDD96DFEDFF00E3E7FD8E
-      8638CC6C2A015D6505F4BCA0B21550C51502958C0007D48FAFB2DFF074BFC566
-      93C36E1FEA3D70645E088BEA8FCC675127486B5829024B0FD5FEA7DDBA59D704
-      49F975087C926AD0FE91147A50AA85001572C2F6D2BEEB4F9F4D787FD2EBCB03
-      86626CAE486473650C4300000F7F4964D3E95E7DEFFC3D7BFEAE7FABF2E1D654
-      D519003BB2AEB014A8B86665651A4A292B1C67FB1F4FCFBF75665AA8038F59E3
-      6BB42B246E2375918CC88A10692190DDDB4A792C2C2FF8F7EE934ADE10213AE1
-      3C88CFA5041143FB885A6F26A625C58F8D4EA7F2AC8C00B1B31FCFBA28AB47DC
-      47D874F54F14B99124A15A371E91CFDABBBB178CACD935F06273F81889C7D352
-      E768A733D350D331A7A5A4867C7D5D1CB252414EA552396E881B8E3D8DADB74B
-      B8A08D068A05F315E8052D85B4D33B397004B5ED34E82BAA8A92AEBA7AAFB2A1
-      A232203E2A287C5081135D5544B2CF216545B6B2EEFA7FB5ED3BDCCD377C9F15
-      7A30B7B5861604161FE9BFE2FAC451C49767327903695600C60A0D40B058804B
-      AFFB7F6CF974A9A56935338E0B4FCCF58D5557FD5DACC6EE01716D43E8B6052F
-      C7ABDEFA4DD1AFF85990C1C5DF983DBBB91166DBBBF76EEF2EBECA8942B22D3E
-      F4DA597DB55353F40C869F1F949CAD883FE23DA2DC094B75987C48D51D1CED53
-      C6970F097C18D93F27F8BFD5FEA0106DFC84BD4BD9B8DEBFCB501AACA7596FEC
-      860B7363163BC930DBF9EABC4E4238258CB1325B1CCFA75692A47BD5C22DCC0D
-      73FE8720ECFF0067A451CF2DBDCC56633223F7FF00A6FF00557AB93EF9EB3DC7
-      DE387C3F66E6A862A5C3EF2922EAEAACF4088F16E6C0576169EBF66EE3A89236
-      FF008178DCAC2449AC7910AE8FC7B07EDD74BB7DCBC31D490E6B5EECF43FBEB3
-      FAEB4AB22F7A05C7F47AA87C1ECCADC1C9B864DD75EC73388DC391DA1BAF6E8D
-      74F90FB48653415390A14664138122FD082F76BFF87B91B5F8CC1787513ADB34
-      37134531EF85F49FB7ACFDB1B63372526337965DE2A9C841514FB333D5F4700A
-      7872A71D8A8A5D99BAA6B7ECFDCEE4DAF0A249FA49ABA292E351F6D4BF1B7FAB
-      CFA314708AD41DFD0161423055885810EBA41089136A52EED6D25AFABD2B6D5E
-      DBE9BE854D97907A8A6930F33C71AD2C6ED4D7D0CF2472335D51655D0C2173FD
-      1BD3FEDFD96DE46B1C6593E23D0876EBD59A578A5FC3C3FD54E94196DAF8FCCC
-      2CF29FB2ACB6882A6284689598AAA0AA45B3CB1C29FA4707FC7FB3ED1C378D6F
-      A01FECCFFABFC9D2B9ECE29D6B9F13F0E9FE2E827AEC357626A7C35B4ED1AEA6
-      10544435D25505E59E39481C95FD4A6CDECDC4DA94B28EDE89DAD3C20EB30FD5
-      5E9BD6368890CC4C8B7BBA8B15B13C22FA8587FB1F6E2B87151D17CBF1B7FABC
-      BA9304D534B529514AD69E2956446D43C6A623F5B152A4B1FF0055F5F7578964
-      56D55A1EACAA62923947F680EA3D1888043574945588ADE5AB8639940962B012
-      697959AF228F1DFF00AF371E9F4FB0E93FA8EBF87A1847986191FE33D728202F
-      2A24219186A6BA22B691C00BCAEB627F242FE3DD653FA6E3E5D6DF568CFE7D3B
-      49AE20C64D2AB0A160A23FDD2AEE755B953248221FA38D5A6FEA6F6960A8D78C
-      F5B8115F587F869D72890319226D2E220CED2378A37D2BEAB13E945491F5152B
-      6E3EBEE8433C8C07163D2DED48C55D954F42F753503478CC96E9DDADFC3B686E
-      3ADADC56DF9E4C6C5592D52947C5E2AB66AA95A15C5E35F24F2379DC68F2CA3D
-      1A9F57B175B58BADAA2E1B5F40CDCB713E2DCD1DC56831D138DBDB576F62FB4A
-      AD8628FF0011C4366B72D3543D64EF5D8D4C11587189415B1474F4792ADA9C9D
-      544A891C6E85A61C92AC9ECC6E156DAD507E0D1DDD07E059AE6E13C373E2BB74
-      34E02832D263D29F371893215333879522891D049506A5D7C74E8F1B490F91F4
-      9F4A15D376FD3EC037D247E3B341C1BE2FF63A956C23BA8AD21171A78629FE5E
-      9694F42EA4C9A1A28155C3D54D1AAC72A2DA255489D02BCE8A2E745FD4C3FDAB
-      D97773357CFA348E08986A35D5A7A9471BE0998BACD144F0050F344E0490A466
-      E400A65D57981BE81A89FA1F6D4B232E8008A74F47105182D5FD95EB2D3D0968
-      D169DBCD64917C81244D6CB60923232C6A240ECA3D4140E3FA5BDA5E9F0A00A0
-      E1D646A76481FC6EB28B48662ACD0BDCC968A379152594089D6DF8FD3F803DA8
-      87FB3FCFAA1FED3FDAFF0097AF53459559A56962317994CF13C6E8D4689E389B
-      C51879257334B2386D7A592CBFA7DDA4A686F5FF0067AAD65F2515FF0057CFA7
-      E6995D51E4749D9975C92877D778B493A521926F1B2B2D835B9FCAFAAFED2150
-      4D4F1EAF23945040E837DCD3B912C857CBAC482031D433432BBB899A258A4D06
-      378174B93FAB531B7B596E8B556F3E9B964AE5D7B7FD5E9D17ACF8485C3C5EA6
-      78959B59962D33AAE829E900BFFC1AEA19BFB3ECE63A05A8E3D17B480D1BCBA6
-      4A4C9D4C456D34718D40387501542111963A551416E79D5F8D4BAB9F7B75571A
-      5B857A6BC4F51D0A7B73783527DBD33C822F1DCBA2945E2476488EB95C00AABF
-      D1793EAF4FD3D975C5AA96C1E94ACE55EBD0EBB7F7B79754AD3059A34917D577
-      512CCD1967725C78808DBD3E9D44FB2A9ADC703953D2DB69039D2DF08E851A0D
-      D14D23A3B5A648A19343FED3C8D2C83458201A95D146B66F472DCD871ED1BC0D
-      90BFECF460D48DB48E94B165E39B4BD3D54A23882C32A5518152A08B7EF3C314
-      9E25FDB4717D0C5BFB42C3DD12DEA4AB6AA53AF020B50F4F30563490891E262C
-      A19A1899A2631C3A8B245F70A5239751B7E9E3F48FA0F6A23895000ABD28D6AA
-      A4271EB8C352F4D2544F04EEA278E44F0C888EB4F2C21C075F534913327A5D53
-      D24AEAF76D278533D5FC44F5EB9BCD8E9A41E5554AF9344750D049AE395955B4
-      4CE2411CBA1CBB0D1A54B6BD3F4E7DBA1069D7D34CFA940FC5E7D434B248F216
-      85D669809E19DE46F2C91132C7EBD0ACF3323EAF4EA16E17E9C54749A373C18F
-      5C9A3596783F709761248B3C6078E28F52B1F21074B2EB019383603FB46FEFC4
-      F5B77A54039EBB929E2AF8A689E4558255929A3D54D51ADEA5C1592A4CD278D5
-      CBA694467B051FE3EF55EABE2FCBAC2223411474F4A9E654490BD3C32AC6D181
-      6432460996334B4C40FAFEAF7431A6319EB6CC1698EEA74C596C8246DA25F124
-      2F15BCD3C61AFE206684C42C62B16525F572DFD3DB806A38E9A92551F11A2F40
-      B6E8CD472C6C24479208BCB201AAF1A3B4BC844FEC0563AC05508471A7DAC822
-      CD69DDD17CD32935F2E8BD67B28B53592E994B4608D2C090B187894B10550B6B
-      36BFD74DEFECE220454D7A2F620D3A0EB52ACCA59485BA0D71AAB5C17F5698DE
-      C5DBD3FEF7ED4AB31C711D202C439FB7A10B69D5CB4ECA2255D7296D523CC244
-      F44A02DC218F44A112C0A35EC3DA59C134FCFA596F26A146E23A32DB66784B43
-      398E149A28DD6295557EEE2951C388A38D46B30B24BC952C8E79FADBD93C9AF8
-      1A69E8FEDD51857F17427522323BA4B4D659AAA572D09FD61D0223A6A2B23CEC
-      3533DF4F1FE27DA5A9C791E9618D41C0C753AA3194EA58CAC90068FEE74C2B03
-      4D2AC968C2411C6E5279982F048218FA4AEAF6DF8A7FA3FB7FD8E9A65500007B
-      BA8F90C308E24996964A705A76F1BF0D2AA48B51E754999AA2CA2C5252A79E08
-      1F5F6E23165071D55942500EB84189F14895D1D448EECD12E9A7F50786A117C7
-      7351129FB79231A4D8E8623D5FDABB83ABC6AACC55B8F4A6A183CD52498D5E39
-      433C713931F9053A86BC7387D22668EF7F41D36F4F1ED994654FA74B215D29C3
-      8F4E063AC4A7D32426199A97C3534D0F9AA5A8FEEA294B389E63E1A9F185255C
-      041CAEA55F651FE89F9FF97A6DE476501B875AC6FBC90EB1A3AFFFD3D477A1D6
-      4FF453B60FEDBC77CEA2A962A118EE2CAEB792CF67053FC3E83D8337823EBE65
-      FF004BFF001D5EA40D8BFE4996FF0069FF008FB742F948C0121BC7F54900D0A8
-      24BA005D2DCDC3585EEA54FB2EE8EFAC550DE8003CDAF5C6F12C7E958873AA46
-      4166F169D21DBD42DFA7DEBAF75CE3F4C21554F0DA794649DEFC950C8BA9AEDF
-      EBADBDEFAF758D2475691923581DA56751759640A9185462C4278D90477D01AD
-      7F7AEBDD639269F40412425974334D54589915ACECAC8BE3453A091C9E5BDFBA
-      F75CA39CCF03ACC5048DE490945D2342314B2FD3C7AF5DB4FEA06DEF5D239632
-      4151EBD67904778C6958D112CBA3C8863B3DC00E18D8D9BFD57F6BDD1FCBA602
-      46AE55F8741DEE3DA558C6AB258B32D62CAEECF47E959D1E4FF3D2C3386D1280
-      5B84620AFB38B79E231277690BD164B6651B5C4289FCFF00DE7A42CE935349A2
-      A609A95814410CC8C8E4B01CC91DB96B1FA8E7DAB8D406F8C67A2C31321D650D
-      3A8AD27A895627D36B35B4DD5830375E4FEA6FCF3EDEA7552759AFC35FF57CFA
-      C88430D46DA9ADF5E090B60A74FF00648F7E3D5B43FF0001FD9D2B7635564B07
-      BA36F6E3C64552F2EDFCCE3721E48837EDAC557189159D57FB51920FD786E78F
-      6C5C48857C2D6BA8F5AB6662E922C2FA6BE9D181EC3C861315F2BB7AF66E5E9A
-      0188DC4DB7B776771F353AFF00955467F12B1671209180747ABCC50C8FE9B379
-      6A003F5B7B6644692C614032ABD19BF6EEB33D7B18E3D7FDB7574FF1F31F55B9
-      29F70F4A9C8FDC6DFC4C8B98DB50484CF570635D572186C9A99A7658A26A0AE8
-      59E6506CDE93FA7D816FC983C4BA4F889A743CDB4178BE8E4EE539E89D7F32BF
-      8D1B83ABB754D9EC66DC9E97B2371D3E13BAB6BC18E683314B592E04474BD93B
-      5772263EA6697195E568E9F310D3D418A49A9AA91D514383EC61CB1B9457D631
-      C3AF4F87D86B8CE72BEA31FE4E81FCE3B6CB617D0CCA809906B6A7AFFD059E9E
-      FAA3E3E9F92FB13F8163E820C443DDBD6151B8F6305AF8A6A2C26F1C3A54E7F1
-      18292BAABEDE3438EDC58B9E9511CA4A904E613EB73ECD0920B0196AF4536F1B
-      B68B8FC247FB6E1D52C56D057626BEAF1796A49E87298AAEABC757E3EA22786A
-      28AB68A7969EB286A21762455D25453BA3FF004643EEFD25EB2E2F252636AE96
-      A522D2F4F302EAD26ABC3AF4CAB75422EF1337FB1F6D491B307A5323A72DA45B
-      798C8E7B3A30B14D1B2432B186A2078E19D662BE3F2C35322696BC41F5A2092D
-      EA17E3D5A7EBEC3EDDAC50FC5D0BE291264F1535696EB0CF47155C8D4B90892A
-      68BC91045916422DC0BA5D9B4EB555B320040FEBEFD5A770E3D5D9559741E071
-      FB7A0873384ADC3CD5568FCB8A9DC7DB55B80F0981D8CB0A972404A8D69A5987
-      ABD27D563ECEA1B9B775402BE3F9FA741ABAB56B7901443E0038FCBA918ADAD3
-      66E862AAA3AFA44549BED2686A2395678E64B0BEA4122B42DAB55F48D5EF5717
-      460740C3B0FF00ABF974A6DEC639A0D402F894E84EDBB89ACC762C5255F8A778
-      A79428A5BB9923A97D7139F2471E9BB332FA88163FEA97D93DD3879030E1D1F5
-      8A18B5A1E1D29E18A4D715C2A150C5A4573A3490AA8F706E15349FF524FEAF68
-      B41D7AB1A6BD18D71D4A887DB54846D069DE3650E1802B6D3A1C3C9F9126BF45
-      D8F37F762C1684F552A1C508E9C2993C723420E97F22BF939669751255D4B588
-      632703FA30F6CD487D4B2693ABAB786E7410431F9F0E955265F704F86C8EDA93
-      756EE4DBF9962737B7A3DCBB9176DE493C463F0E5B0A99118BAC874A828AF090
-      8E030E429F767BCBA8B4E8BC7EEE9992C2CA5A3BD9A78878F4CB4B431D1434E2
-      182AA74A481FED69A479649A2333246E69C4F2C94F1AB53468BE865F44607D7D
-      B73DF5DCEB1C4F72E63D3DCBD3F6B63656C585B5B2AC8FE7F3E9FA9A9CCD5303
-      349510A92C51975C47D7E329178C81132ABC401FF5F52F07D97F0E1D18C11B26
-      1B830E9DE0A3A2AB15350851A7A6916060978A440E63B8884AFA492EA026A235
-      FABDA47F89BEDE954326AAD07C3D29C53CDA144910AA918C534324EEA5E11E32
-      34A3B03107FA292C48542D6527DD3A73EDEB1B524A6391A0292C936808121923
-      93C72117500DC95D4AC6E5401A7F47BD0705B4F9F4E10E4E926A475EA5C753DA
-      4A9AA4331D1153F8E190FF0094182658FC155180B24ADE562C965BA86624DBDD
-      BFC1D574D16BE5D49FE150AACBA3C7A2644B4B225E28E2807A0C8546A548CB1F
-      42EA0791F8F7EA75ED2C412A3A6C96821FD9A7918F8C0F1106D0D3E89E390232
-      4F3144F0DFD761AB45ACFEFDD6B34E18E83CCD50B494B3A3C4D5324328F0C3E8
-      00398ECF25D4BB184C77E07A4023DA984E9CB7C3D337119153AFA2E3B8E29229
-      9E2215086918DB54AAE159565B1019D6CC79D447057F1ECE6DCEB404744D20D3
-      93D074F208DF4DC04BDD2CCFEA5360C74C4C15AE4EAE3DABD2C68389E92C6CAA
-      0B31EEE9D692BCC43C8ACAEF186F1DD9ACDF511AF0FC2BFF00D0DEDA68B5104F
-      4EF88388F87D7FD8E96F8EDC3F6C49943A000B13A8CB74201B6840115198FF00
-      AE3DA7F03BF563FD5F9FF97A7964A50742162775D4021A390A6960E596421252
-      34BC29A41B02B7D2B6B3707DB325B8515A63A5093305A8E842A0DE72B246F532
-      481BCFA3FC9E41E30B1382249350592428FA8305BB5AFED235B06350DD2B5B9F
-      F570E847A7DD1F4669F50A7656D1132DD41524B2A00EA5B9B84E0DFF00DABDB4
-      D6AE32B9E95ADC8A6A34A75206E7D4EAE92AB249EB336A60F1A25CA1905FC923
-      4F737FED29E7F1ED334610D0F56FAB8C9CD7FD5F9F4F8370C522BC81A9E1924A
-      5732CAE5C246F233160A586962B75F4EA05EFA8FD3DB654FAF4DB4F1B3549FF0
-      FF009BAE0BB8A8D90C4B531CA0FEC36A9A3379E584C0B1C3A6D108A471C7EA1F
-      F437BAB29A1153D5BC507FD133F6F53D37225D3C8755B4ACA92346ACAAA9E38A
-      FA963292332F2B73A07BB693EA3AAF8A3D574FDBFEAFF0F4DD51BAE969A9A157
-      79E697C915149309A48E9923698957B2AFAD6041F8E747BF69A9E9B6B8073424
-      F4D35FBB1E299A2352A43C9AE39E3F22B08446886921D3185F2349FABF4B32FB
-      7C44FC2941D59AE804A28F2FF57FABF9F484DC3BB414B0902C29656935AD9535
-      040952815E31A974B2E96B83FA47B556D1D18D4FFABFD55E8B67975124740EE7
-      F3D573190874B3A482365BB8209565D4C513D656ED7B7D74D87B3148AA351E1D
-      24925D2B523A0BEB6A9657BBAC5AA28D55420259C2D8EA36F4BB2817B0E0FEAF
-      6AD53813D30B2921B571E9A2556BB3D98CA92A055588DACC75AB2BA298E41A4F
-      FC187BB03E5F87AD323549AD7A5063EB9E9E41AA32C1645D0408D9C947D5C125
-      1886FF00537B7FAAF6D3C7DB43D3913B1C9E3D0FBB532C8A21BB34A175328208
-      FF003AFA1D90AB2EB71FA2CD6E3D96CF1E0D7D3A33B797283CFA31D83C8B48A8
-      1238B505BC554EDE5D356DAFC7198DC107485E6FA4329B7B2A91698233D1CC72
-      6ACF9F4A188CD5306B90450D7C155154A7DB81A9110A9E7CA913DE448EEBAAD6
-      0DFA47B65BA5517E2E9CE97229354CD2E475D1D785F0C8D245AE2ABA51291295
-      558DD1639212BF56041FED7BF0E1D3175F127D9D41966A7A78DD225912113AD3
-      D35532F9608DDA3455501827895039457B2843F53EDD601908F51D68CCAD1E8F
-      2FE7D6382BC53C9F7A969E944514CB3184470C44C6F0BA246E14D34E6D6BB8E0
-      F249BFB6C8CF568FE09BEDE9682A22A8A489E969053834D58E62AC93CB26A894
-      BC36A95F253D5466417655D0FF00A7D97FD3BEBAD7CFFD9FF57F9F1D28AE8779
-      0FC34EB569F7913D63175FFFD4D49FA0031EA5DB814B85273AD7FD4A1D73B982
-      2DFEA49B7E9FF63EC17BB7FC942E3FDAFF00C747520EC5FF0024CB7FCFFE3EDD
-      0B90AEB6406C8A4FAB52D942AA7FA8789D563247EA2CB7D5FE1ECBBA3A1D6375
-      85209901692A18BE832B031323B6AD0F249A9ECD6365B7E91EF7D7BAE47F7248
-      8824AAA0540DA48D2ABA414F1FD1503717E2C79E7DEBAF7589980B053A8B4635
-      78E194322891915753A98836AFCDF81EF7D7BA8CD0A95791B4129E3D3131D6DE
-      41E4D4E349F12856653A748F57BD75EEA488D1563953C8ECD4D79A0685635323
-      056408FE465925E2F708145FDEFAF75C661AC790C69F7223F180EE4857B9D301
-      7BD8468CBFA82ADFDD7A4EF1467BBA91180E91F31A4E85EC1EF6BB37A82C61BC
-      7FA40E4F247BD3283C7ADAAF84758E3D71A981248CC7514F0554650AF8EA238E
-      60A090ABE86BE8B5FEB75FF0F770EEB90E7AACB1472A69755A7DBD23EB364E22
-      A5E434924D480222014819E94B1B92CAB32A890FF82BAFA7DAB8AFDA34D2C353
-      74826DBE290D50517AC145B22862A778AB7CB5552B76468CC9143A5A5D625D3A
-      82334C57D572CBEEB25FB4ABAA11A52BFEDBAAC1B622A69BAAEBF91EDE96144E
-      29A89618E9C5347186468E358D0E937E4F0A4B3A35FF003CFB4AE5E43A99F3D1
-      9C68A8802A8D3D3F6FEC554D445D79BC31D4D4F94197C2BE2B294592963FB2C9
-      4B83C81A0AB49BEE248E264AA8AA29C900AE874529FA7D9C5AC8CF6F9F21D105
-      DFE9DC2489860DD59CFC4ECDEFB833B43BBEB30191A0ACCAE12AE828CC70D4E3
-      696A71D5747518DA6A6A5CACA4D0CD352CB490AD31563EA23D36D5EC1FBA448E
-      92C7E5FEAFF2742DDAAEA559164EDD5F675703D7B8AA1EEEEEADFF00459ED8B0
-      D1EE27AEDAFDC3B1F6B5756BE43223159FC4C143B830192AE960A3691728C2B6
-      94388441A8471FF61412CD9AE56D1910392920D07FDB67A3CDD206DD61BB67B3
-      D12467C48CB1FC0352D1879FC4BD14EEE7F8F4DF14BB7FAB76A7575665F09B36
-      8A6C6F6FD36DEAB9995A969723B8EAB039EA6965630BC0301948756460FF0036
-      F4E6091C5FD447F64ED22B78A70303F0FD9D475751BC5A3C2D210FFA9A9D55F7
-      F381F8C751D1DF250F636371136376A7772E4B2B5B4E15053E03B5B6F4D0E3FB
-      036F33445A1492A84F49948AC48992B1DD381ED746DAE2573C4F45D748125D28
-      3F4FAA9648F84452CE559F502DA9FC63572437EA1A4FFB6FA7BBFAF4CAC65D09
-      AF70F2E861DAB92867DBE29DE68FEEA96534C6278FC933D38FDD8950687E1E2D
-      62FF005E3D905CA859DE9D0976B90B4143C1474B13FB645F5F9088D952CA488D
-      999C86720C4BE85B73F8F6C9CE3A34EB165A9A3CCD0CD8D7631C354AADAD910A
-      D34A1BC9E484F1608ADFED37BFABDFA06FA7911C1ECF3FB3AA36A9A2F0020CFC
-      BA62DBF839B012D6D23541AA8E78C4E1D5A284C5352FED93A7CBA58E993FD568
-      FF0063EF77D790DC48A6DEAAC196BF1749ECF6C7B4331932B4C2F4AAC734F555
-      1228572001123821E4A9B790491AC762298ACA9A7D45AF7D40DBEA9A76215597
-      D7A5D6C32C7D3A7D8A692457D1149FA746B091F3285B3152EEA8CA4AD8A9D16B
-      7B4DE2B7CBA5741D4908260229A1BF8C3B222903491A42108196EC49D2BCADBD
-      E9E466E3E5D6E345058FAF5D47AE982369007323AC3625D195B4C8E18991D505
-      AFAF42F3737B7B6BA7BD3A7BB4094F799D21327955E2D6CF023AEAF1A4F3C172
-      F1CF7E1D3EA7DFAE3E18FEC1FE5EB7FE6E9C1125A58CAC2BE4D2A8D1C46756BB
-      4A515640DA5E56456BF242EA1F5BFB4FE1BFA75B88F7A7FA6FF2F4EB400F9087
-      57468A252A924A0AFA4B2AE98CC9E30D2B16B917FF000F753D3F248EBA0A9E9D
-      E8C414CA8F4B6A8479A6FA296705FC68B5110D025D31B2D80FA696F69241476A
-      70E954234AEA07E2E9FA6552E65959E4D09037DBC928510ACBA02E9178A38C22
-      21B9279FF63EE9D3CA5B4D1BA740C44B1D9D1D6591114C8E91C48115DF480575
-      97D634AEAE197F3ED8A696D6BF174F7E1FE87F3EBD2B52C0BE6631C2C8B2CAD2
-      88234BEB29EB460AEC933CA9CB7E6DEF7AE41E43F6FF00B1D6EBE1F6F1EA6455
-      215FC691D324E823F3ACA238D75C9A8DC6B2598491E9FF005BFDA7DDAADEBD7B
-      C2FE97515EA28AA63F0C2F2888453C6B50B039F2D5354A444C6932C2E3554C87
-      FD5273FE1EDC8AAC1B58EAE8848EEF88B748BDCB8A530D4D324BFBDE1699BC4F
-      24293F8C46D690DD6402CA357E39FE800F6A94AC986C2F4C5C292BA4FF00A8F4
-      59376D20BCA038688331FD5CB92AC7533288C3486DFDAFED73ECDADE83B470FF
-      003F441300A73E9D02557188E6455511AAB28FCA93F96042826C4FFAAF6BFA2F
-      EB1C0B1925556ED72AC0EB6160C586ABAA975523DF9BBB89CF565629C3A5053F
-      9D63B20BFA81D24D9CAE90A35151ABF1FEC3DD1BE5D3C95A7774FB4CD3A0560E
-      CCE875AA090B396258580372BCB1B1FA37BA1A703D38A0B1A0E96B430D4C772D
-      1C922CA15ACE640AB21052C015D4A35373F803DB65109048CF4A14638D7A55D3
-      4F510CA25875246A242DE925265D2A1A40AAC521D2741163F4F6D911366B4FE5
-      D3A35FE5D73FE3552156432208C98CA90B78E5BB052AE182848FD7E861CFB49E
-      12920007AF76ABF5C8EF19540535059496756692FA0A801554153A63FCDDB57B
-      D341ABB33D51A5A607C34EB9FF007C258FC00C68638824BF6CB32085ACE7C727
-      92C64B429EAB0BA9FF001F75FA6D629C7AA99CFF00AA9D62AADE9378592091C4
-      C023BF93865D52B02236608656218B1E38F4EAF765B25D5DC31D68CE7C874CF5
-      3BD6A665652634FD458C4D6F2FA9C47E55627D777BDFF59F6F1B54E2BF1755F1
-      5BE7FB7A66A8DD524A8F1C64EB7802B4BE62E5DC8FD0158B9422FF009FAEAF6E
-      ADAC7C4FFABF2E9BF109CAF505B21256C6F1B3B12C1AD18791954D80351672CD
-      AD3D5A4E9F77D0A3F0F55624F9E69D61931F592FA893278E368EDA4B2DC38040
-      51A981017FAE9FF69BFB7558014231D34D18624D727A4FD763A60C2591AE818A
-      FA51C3E962C3429546624B7005C333FB7010063AA0888E04750DE99C98CE83A5
-      ACE2FA834845D4AB5D6E8575DCFF00AAD3C7BAEB1F3AF570C1D8A8E14EB0C4B2
-      2A9492F7D634190B302F704228B1935300DEF745C10075B8C32E3CEBD2DF0993
-      6A7AAA78600CAA5F9904AC58172A069BC6EB61E3F50FF55ED3C8954AFA74FC66
-      8E083D182DAF9DA87F182564A68605BD3B090544B305B19749288A52EBA781A4
-      7FB57B299E2E057A37B797A1B2872A64442E4AC2E3447224E15FEE4471AF9639
-      9222F098D756A401811F5D3ED06905A87874BE395ABD3E4D56863354CB4FE46D
-      1E46281D75695FD9251A38D34CC8A0D909E3F1EFC51694F2EBD3B6A63E84F51E
-      AEAA27303A23B89D1BF6C3BD4051789A5882168924F23482ED6B7E3F1EF631D2
-      7EA5AD7C6D234218359853B88A26644611F9B4451C9C89805B295F4053F5E2DE
-      E8D5D42BF0D3A5D0FF006495FE2EBB137DBC35CD1D59A64C8D1B430D1D54533B
-      63EB6A7CB254D5AB46E3C7E565E7D5A01FD1FAB8AA9D2CA7CEBD392E524FB3FC
-      FD6B31EE7AEB193AFFD5D48FA05241D57B6664E101CD249707F735EE2CA2C684
-      EAD2AA859C8FA5CFB066EFFEE7CDFED7FE3A3A90362FF9265BFDA7FE3E7A19D6
-      376B79521325D9963491F578A35275104323189CEB60C073ECB350AD2B9E8F3C
-      2ECD54ECEB1C94B0CB4F24618C6C8C8D1B33B25E652EED2BA162B21D40FF00A9
-      D45BF3EFC4D054F4D01C7E1EA3BB13A4F08BC8BAA846458F5B1403D48CAE4DF4
-      816F7BEAD8F83E5D629AEA19D11E460B611072246D6BF4B1E06AFF0054FEF7D5
-      BACCFE320680A50001C8BADC70C8469D4ADA89FC37BF75EEBDE50A9A5D1C1750
-      EA24623458F2AC4ADC90A78D3CEAE7DEBAF758BC9130662C1C33A21488949125
-      D4226432297B36A3A4BF1A7DFBAF75952368A46322C71A404058E2711DD0288D
-      7CAEE590B8939E2F61F8F7BEBDD7079FC76290248AE1FCA574B313A8F3E244B9
-      72ABE9E79D3EA3F8F7AEBDD7920AB908952192EE4DA3D4BA190EB64B1117A5F5
-      9B371EFDD7BA9209711F899D1E38CC8C8DA0BC09756D1746259C5F5FF6CFFC93
-      EFDD7BECEB8A2F05DB598C3A471BBD9999D91989B12B212DF9FC2FBDF5EE97FB
-      68D1E6B1D81DBF9111CF8BC7EF5C4D34D14BA3C11506F0ABA5DBF50AACF118E0
-      47C84F08B72B77526D6F6B6C99D619CAF1A744B710A9B88750ED27F9F5B32F4A
-      FC57C8EDDE98C1EEFDA1B424DE995EB58A97716C1D9F90AB8F6B3EE01999628B
-      198E9ABF290CF84A09719B92A608E2AA785D2D526C7D7EC01777466DCA1B3D62
-      3131D2EFF21EBD48B6F60F6BB64B7D1DB3CF7508AAC6BFD2FB7A259F30BA8FE6
-      036E7AFECFEEDEC0EBBF8EFB7E93AD31B8A68305BB64C0E1B0F85C8E45B294FB
-      0F2B253E7A8B7A762EF68EAE057348ED4A90496D14A23D56106DF73B1D82CF67
-      B7DB7D4CE8F972BF8F3475FE8FCFE7D00AF6E79877833497EDF412528AA38E9F
-      30DFE1FCBA24C3B43B6D7AE32FDD1D69DCC20DD38A15BB4E48321D4B81CE36E6
-      A6C7C4D1D5EE4C7ED3DC49558B9A0C8435C895B27F0BD4950AE19D945DC6BB75
-      94B7D0485A8C46597F167F97FC6BA0B6E925AD9784CECEF794C16FECFE79F8AB
-      F97560FB7700BFCCF7F961772D1D56720DF3F2D7A2B7060779652B68F199DDBF
-      26E1DDFB5366A5363AB21C0E72868A4C764B7F75E51BE272494BAA8EA72B4426
-      8B4FA40DDC40B04F48CFE950F4AA1923BAB3F1617ADC2F737CC1EB5785D32B89
-      B505B02741BAB47A7D2C87F21EEBA486E6FEDB5A34607CA9D569FE8FFCBF97FA
-      B1D083B0E92B4CF5355A5A4A375D008D251AA90F911444CEACCD1C6E75B59805
-      FF005FD97DF515110791FF0057F2E8D76C52754A7E023FE7EFF57ECE85386BD1
-      84A93C732323BAA191838926989D202AAF8A38C5FD26F603D9669EED5D085640
-      A857CCF59694BC52A0580C91CF214F246C55869624F1EBF21675B11E91E9BFBA
-      B1A8ED39EAF1A3211FC3D64994AAC9245118DEA9FC526840BE2965F53CB2BB6A
-      3E11C238E391EDB048C83D3AE0B2951C7ACF1410C6C7D6E111143C8ADE35163A
-      6471A89213C850598FEAF7476138214F0EA91A18AA5B4D3A728A255915556300
-      2A81233B124A6A655D2C14E9D3ABD42FFD7DB1A68CBACF69E94AA93434C57A76
-      8AEAF09F1A706EC8CDAD194359F91EA6F4E93EAE39F6D757EB3C713D811A0C9E
-      3FF28A75D3230706F6467B24B641A5D4AFE3FC3DFA49412E2ADD58F53E925A60
-      6389D019A486F138674D0C34858C398BC4BA63B28D60FD2CBED3A47AFCFAA904
-      E3CBACF12454C249646895998EB3240ECE6396630C31111AAA2A1D7C5F85F6A8
-      BA88F401DCBFE0E9D8A864407D7A7685DC454ECA03172823852398DF52318AEC
-      A8442A50FF00685BDF8F4FCD0B331D23FD47A714803C4F14B2C6D2484B69D40E
-      86042CF1D328525560665B857FAAFD7D95900C802FC5ABFD5FCFA50AA422A9F8
-      B49E9CA8245FBD916AD03D340B203AEEC264744591E3768D751BA8662B74D44A
-      F1EDB7428DA5B8F4FF00528196EC6071511C5212448269427921530AD93D4D74
-      B1B35CF23F1EEBD6C10B466E1D71C8D648B02CAC246F1C2E8B0BC8AE8E100428
-      8BFE64C8A749BAE9653EFDD541AE6BC7A8F4D5B21F592024A8C8E252BFB4FA02
-      8494278E477F225914DF416B702FEDD689D14330C1E9F8D8C4751C1E9ED2AA79
-      63796081D0AEA8A2696342C61888775432C66384D4B8409F922E7DB751D39E3A
-      E7E2FDBD3164A91AAA8F5485C353C5E4485A40EEF23833313C191BF5F0CBA788
-      FD3C7BA2A3138E904C19C00339E8BFEF3A3F3C9249118E41AB537EDFACA3C571
-      ACB488A2520FE46AFF000F6736CEB1A943C7A2A98671D01F578699E570A188B8
-      04C8A6E4871AB472A00423D9AEB1E7D21316707B7A9341B6EA2A0E90920F1FA8
-      A06058EA27F50F55DAFF00DAF6DB4CABF6F5610D4E4F4AEA0DAB2A1601486F4F
-      F61BD4416BA3B2682F6B7FBCAFB6DE61FEDBA7523D38181D2EB15B4E4888FB8A
-      555F33B089BD0B2CA347A74233025134DEDAB8FAFB61A6600903A7D61A6153A5
-      C63B6BC977FF0026B410227EE282CD3EBB00DA2DEA51AF4A9FEADF4F698CC755
-      4F4FA41E54AF4E551B6DD503157AB2D2B3226956A751146514204554811187E9
-      D373F8E7D3EFC25F51D2854455D2C7BBA4067B0042C8863778CC521578C9788A
-      DD6E9185E1E5D6966D2A1401F8F7E4901F8B8F4CCF16822A33D051591B40F321
-      4789410C15BF7148B1536217491A07205BD98212C0578F45EF47AD7874C93D6C
-      D4E0280DE9D07C6B6FDC57054823D21556E2FF0053C7B7000DC0F54662A2BE7D
-      449F213B2146791400556547700052084035FD41FF007C7DDFC3EEF974DF89D9
-      FD2E1D426A9924755122147521DD5B57074D9D0A028D1D979FF61EEDDA3CF3D5
-      35339D38EA763A36924B1176167F1DAEF2D8F8D42EA05175B71F5B8FAFBF31C7
-      5E404B0A79742C607089242F2C9A600ED0CCCEB117956360AA91A144676213E9
-      FD2E7DA2924A54039E964709A50701D08B4FB4CAD389E788A2B6B6765758C9D2
-      C8BAE2F31D244BA4B037FF0069BFB4A6E748AEA35E952DBBD35019EA3E5B6715
-      D023082CABE4F29721A12BA43122DA1DDADF8F51FF000FA792F9751E27A6DEDD
-      AB5A7495AEDAB28843AC514A627FB7560C850C63D45D634D3AD91DF47A999974
-      FBB8B901F20E9EAA6123E5D246B36E48E58C714A0A322AF9238E2694B8B974D4
-      06A885B4FF00A93ED425CA9E9A78DB201E9B17175104C816354915A375088575
-      9B866E15D78503917BFF008FB5024045470EAA62214B76D7ECE97F859AA164D0
-      A8EB69B5C27CA6FA884123196EC231C5B4FD5473ED24E9A857CBA5103E83ABA1
-      CB6FE41E49529C296B4426834ABCA8AA932C7324A5DD34335C1503961CDBD944
-      D0E95A814E97C52956240AB1A742553D4BC8B2853A9A5275EB0E21279214813D
-      FC625D20F20E9F69E31DAE7D3A56727E7D734698079FEE68E95FED65A7D0823A
-      8915A1B6AD1E705CF88EA09C37D6F6FAFBF134A927AB04D6DA57875352AA3665
-      11C28956626778E296375963291E89A9D0B2D834B0B6B752DEA2D75FD3EE84D6
-      A7CBA74C6C80AB376F5361645A7A9652D50C8A590EB1A523309528592DAC31D2
-      7E97FF006AF75FC51FDBFE43D797E25FF4BD6B33EE7AEB1BBAFFD6D4C3E3ED32
-      CBD47B5D8DDCEBDC12246A16EBA33F944727511AAE0F1FD3D827786A6E1718FE
-      1FF8E8EA48E5F8D1B6AB4278F7FF00C7DBA1A74EA9354C35CBA667565A7548E0
-      4554864803EB04CD3EBE2DF5F6563517E8F24AAC2CA3853A669230B2BB794CCC
-      0B84902F8F405D4C2C135AE84D5A6F7D4DFEBFE9729F3E903462875363AE6087
-      4458CAC86486F34BE392305C3237A2372644B38FD5FE3F4F7E1D6E2FC5D79E69
-      157C71966D5A0B2CAAE1412350BB2DE42802D87FB57F41EF7D3BD63D08A64F1E
-      B6489988778D59E566B125743C8D617D2401F8FAFBF75EEB8B31906828E446E1
-      5BC6A240C54EA3A0808F7429EFDD7BAE3A93C92E8914CDA119B521B6B04FEE33
-      B6947707960B7F7EEBDD7615650B21F1C884DA294AF3E6452AECAC759E07D0FD
-      07F67DFBAF751D67B11A9354B186453611791B50D0A8350609A4D95EEBA89FEC
-      FBF75EEA5C91AAC685E368A4851E4685673232951A4B110B32190B5ECBEB23DF
-      BAF75CA331AB941218DC4080A465D5162B3041AC85D2E757D3EA6FEFDD7BAC4B
-      AA43E537915C0426D7563A97F701E43025BEBEF7D7BAC94B4194AA8A4C2E1649
-      46633B554943410C0AC64A8CDBD6C73E0418F41D322E63EDC002E548BFB5760E
-      8B23C527F6650F44DB8C5AA24911F4CA8EADFEF3D6EA1D1DDA9BB7B53756D8F8
-      FB90C1D761E6CEF5ACFB3B3D8F78D5AAB6EEE3C86CDA2028E22B7124185C8A47
-      2F951810ED6B0FA7B8DF77B27496E670C59BC42AA17E2A8FF4BFEAF2EA4FDBEF
-      27BE16702314FD20588340005C9245001EB5C75AE4FF0033BD895D84F993B8B6
-      BE1377F7677266F01D7FB0D77260A1DBB93DCB81E9FDDED81593796C5C2EECCF
-      64A9F68E1B6F51D7C34D508D4513C50455FE39155E33695395AD5AFF006B5B99
-      2CA38C9F9693D457CDEEDB7EFB736C976F208E18EBC0F7B8D45ABFEA19E88362
-      F25BFE0C81926DD58FDAB9590C3470612B654DF9970926B8C2D36DA8A0ADA0C7
-      D5D02B7EDCD051C0101D7E7BB3B28AE2B76B64912390056E3FC5FE7E80D3CAB7
-      0C8DF120E15EE1F3EACABE2DFCBDECDF847B0F7CE5317BF762566777CD552E7B
-      2B59DAF4ED95DD790CAE3A961C2D0D143818F754D96A7DB3434924932D399A37
-      7AB9DD55231721A68ADEE6540B0B6AAFCF87471637B75B6DBC9244885B4F68D2
-      3AA57DFDB9DB78EF6DE3BB462F07866DD9B9F706E17C4ED8A09F17B76924CB65
-      2AF21530E0B1753575D363716D3CECF0C0F2CDE04754D7A47B21622377006549
-      FF008F74B0C86E17C62B4675D4DD39EC7C93D36406399A510E4122929A256562
-      2B55756BFAE889D95593EBFF0020B7B4177DC9A8FC5FEAFF0027467B74A43F85
-      DBA34F4302C323B2055B3B84BAAEA68CC8F71E43AD5B59436D47F07D932BB915
-      3C7A14785192581EB93AC0923AAF3326A3A3EE54BC7381A244528C590B44D717
-      17E3E9EF5D3BD649298C60C6F232C668C177777F3D9F4B05FB703CB1A2BAE852
-      7D458FF66DEF6450D3AF759629418D644D2194B2013C8C1F43106398B87F511A
-      6F6FA9FEBEF49184F853AD6A5FE21D3853EA2237954B2D8CFA22B308D3C6BA59
-      CB2328D65BD210FF00D1DEEAE8BA643F8BFCDD591C9D3A4769EA6894E88D7C53
-      4EF31F198E34D2357D00255B522E82D6FF001F68FA7AA29D3A4068CE88C2C311
-      91DE468624F3BB3AE985A4914695D113FF008B73FE3ED96FF44FCBADD0541F3E
-      9E74C50B696D2A6399A05F1386D25144B736319D42FCD8F03DD84A613A40E1D5
-      4B32E4814EBD1C88DADB46B5428AC02B790A955D2221A244693513F5E06AF7A1
-      FAB5D5E5E9D3B151244AF9B74FF03D9A3689A191E79BC0C22959963D6C9A84AC
-      751F3448BEB1F41F4FAFB4F2965D40791FE5D192E83571D3CC74E7C6237768D7
-      4B7A6E7CC03AB858A290C6BE362C3EBF5BE9FEA7DA6D4C1B51F8BABE91A74D3B
-      7ACD2451BC6AA4B471AC7A4CB5085665566049BADBD478661662DF8F7E662E6A
-      DC7AD800529D75E33297862F2486580B489383E3F246CEB1488DE65641235FEB
-      EABDADEEBD6F492B5F2EB14F42C249E08903C0B7AA48A1D76329658444D2170A
-      04C49D6340D5E8E7DFBAD0000A018EA1418F13E8402587C955F7139BB04A963A
-      75448C874E8690727FD471C8F6E34AECBA49C7572CFF00653A7E86BA4A7954BC
-      6EDFA97C6CCCC80426C4BEB4B27001F4DBFDBFB6FAAF58AB5A91DC158543C692
-      C7512F13A981B910AB316F4873CDBFB27F3F4F778B0EBD55C6A523CFA0D32984
-      0E82258E678D2EB316421D19D750776E5ECCE7527E3F0BED4AC843D7CB4D7A40
-      EA18D0363A46CBB35A4990C2EA53CBAEC4A9565F483238B5D18BEA1F40DA87AB
-      DAB8EE8EAD27D3AABDAAAA865CF4A0C5EC9809656834C874A4D232A223299512
-      3BC4242FA11547D6D73FD7E9ED3DC4EDABFA3D5A2B7CE29D2D69F672AC7E45A7
-      56F484560A47953D6AA5CC6C081A91AFFEB71EEBE386A28F4E9E8E15A6A1C3A7
-      AA4C35008A9E4A9414CD4D342F1AF920F1CB54CED108E3240257CAD6FF000F4B
-      7B67C73FC3D3DE12FA9E94FF00632C0923B535344629951020150954B12046F2
-      4BAD592EFE82889C11E9F6C48E02FC58D47A6CBCA940C3A9430B1AA93E24A7D4
-      AB158B32592E192285BD7A23791CFAB482DF52357ABDD3C4760497AF4A631AA3
-      D47E2E9159CC343506A19523A7103BB3BC4CEC42B431B189A46451A5E5909647
-      D57F4FB72294A9CF0E999C165A9355E802DC7B6C3CE658E26882428E4867F580
-      FE89150A058D553D2E2CCDCEAF6696F3353FA3D15BC7C0D727A093298D78993D
-      6EA9248CDA0A690CC6CC6260015F14A1B82DECC6292A2A4749594B62B8E93332
-      BC713AE90559B8880E6C17D2B0860A6CE57D57FECFB7E809D5E7D324381427B4
-      F582248C32C64468CECAE12E18C617D058E924E9D2BFDA1FABDEFECEAB5A9EE2
-      69D2D70540F2C8874AA35D846E15422588D4A51F9500052755FE9ED2CAE40AF4
-      A903126BEBFCBA31DB43069247024A2A2A119629239FC8D1CA9AE455F53B3338
-      8EFEAD36E0FF00674FB279E735C53A30812A680F1E86CA7C4D22F95DE9BCB338
-      8D8B28561E41E50BE0058FDB2C64FADF404D7EAF57B426463A813D198456A86A
-      53A8F558F49408250559D916459195A38D5D7CAE0C9A636978E2E2CA86FC7BF2
-      0E3D5D621269D438F4D0FB593532A4513AFA638A342E6311CACCC9E5745F1B43
-      24CBC692CE1B9FC9F76F10A970BC0F499EDD6B41D276BB694351E68994B5CC6E
-      0ABBAF8C8F4B5D836A755247E12C1AFCFBBACED93E7D34D6DE6083FCBA4AE436
-      9451CBA59E290BB97923593C8EC58946BC919F108030E349617F4FD7D9924FDA
-      83FA3FEAFF0057D9D69ADC0539C74DB1E0569E3F2CC174AA4EC34A36A740E104
-      53C458F875170BAAFABD5FEDAD2CEE180AE7A6FE9F1A89C52BFEAC74B0C5D39A
-      345AC731C022921772A1018A370758794960C190DFEB7E0FB44F2872518E3AB2
-      210D5A6357424D02C92C8B2C72208A486E1559AF0CA1D75946FA88892DC5AFF9
-      FECFB4EC0211A4E7A5BD3C7ED1962F1C514ABF7684C8F22B1574D3E79A26285D
-      1A15BE9B696FF11F96DB80E9C8BFB44AF0EA1D74D510F9258A09E5925902C0A8
-      B68E99E38D899124E6476A91E8F400AC47AADABDB63A7A5A6A8FF874F52A0AF0
-      F47208104CB1A2C134AAAE8C6B5E9DF4B95588885E285EC4B6AFD7FD6EBEDD54
-      4D4ACC3CBA695856BE8BD6B5BEE75EB1C3AFFFD7D4DFE3CC883A976B876111F2
-      66C89512E50FF78B2A7D4406FD5F4FF50BE9E357B03EF03FDD8DC1FB3FE383A9
-      2B979B56D36CBE84FF00C7DBA176A2594BC88618D1B4490CA63D61553D26365B
-      5A42D25FEA6C9FD38F65C8B4A357A357994AB28E3D45316B653A633A41055C02
-      B703F6D9427A75127F1FDAF57B73AA75874DD4CC9FB5336B8CA4C8FC04675E53
-      FDAC1FA0D3F8FF005FDEFAD75C249215B8FB9890B4B4E3C455752A317755BCAA
-      D6691A303EA580BFBD75EEB12BAB86F11205C82D7BB7E5AFE3BE91AFFE411EF7
-      D7BA911A170C7D00328509E9D608018683E9E0056FF6AE0FBA6B5F5EB680C9F0
-      F58AAA99CB468925420F1B91E308834B8BAF925E644F25BFB27FD7F7AD6BD5BC
-      06FE8FECEBCE9346C94E8C03B2C6FE59134C0A823B48BFB8EAC9213FA74DF85F
-      7606A2A3A6A4D48081E5D602B4D10776760E63334F74914045B177014596DA78
-      D44FFADEF63AA45E7D4BA60A94C1525697F08ECAFAD01F526B1205D4F6FE816C
-      BF4FEBEFDD3DD36D553143AC29B968C4B1682CC2743E86985C3B2A5F95BEAE38
-      3EFDD6BACA4B2A5C0074460284D417801D9D632487007D3F51E3DFBECE9AFF00
-      9A7F9FFA8F43575FE1B3898CC6653AFF001794DD7DD7BD7708D87D5582C352C3
-      54FB45EA290CBBC7B4EBD0D553CD166B6C6DBAA9CE259AD4F4256A32153220A4
-      8524576BE140FAEE1C08F4FF00A87FB6E893758E591112042F29F4FC3F6F4603
-      AA3F9986FBEAFC86D4C2EF5DD14B93DB9B3F2F5387EC7C8E3B2D97C7EFDECCD9
-      07235918C2BEF9C454C1B9E87390D5F821AB96859323590784CD23DE7F6B62DB
-      6CCBF896F6C190F9D3CFA50DCC1BCD9C50DAC776D6C422D5E3F8FF00D2FD9D23
-      FBA37E576FAAFDD351D4191CD60BA732D23D7ED1C6EF9CDE1B0FB9B1FB6F2124
-      D5989A1CAD1D14B5F4B36508A97334E419EA9FF71CA392AA3BB6B075B6B6B86B
-      64B72134695E1FEAC751C5D6EED2DEDCC4972F2C65AA49E34FF51E882E676AE1
-      68B1F052EF4ED7A5C464279DCC58FA332CF2B4524A4413241878A6AEC95555B4
-      8CD2F9C461201C3927DA79E380C92175D4FD6E362CBD985F43D44DD7B33AA769
-      458BA5D9BBDEABB3731598FF003E7ABEAF0726D2C660724596F4B8BC3CC27CCD
-      65A3D1FE53553C609B8F05BD6E826BCF0D7F4FE23D1A41009FBFC8748D6BEB72
-      352DD7820026E401A7F7032DCDB51FA0FF000F6466AF255F8F1E8DCB0521211F
-      EAFF0057E5D4CA4A8928AAA9AAD0BABD24D148A470E155D5DADA481A980FF79F
-      76D0CC8DFA8BF0FF00ABFC3D5D2AB3421A9A41C7FABFC1D196A19237811D03D4
-      45322BC7A1834644C81CA22A82235612FE79FAFD57D861C51DB51C83D0DE20AD
-      1C6470EB83420482554BBA4410465D636672CD1AA23B22A33C616E0DFF001FD7
-      DB7D3DD7752677A770191DB4889E6A91EA8995D46828B2A8925D25B97FECDEFC
-      F1EEF1FC5D524F80D3A8BE3864472E06869A36D409082551EB98065D28FA08B2
-      FF0087D0FB7BA4DD3B517EC82CF3B495332E8F402B0089092B7A68F4C74F0A2B
-      03EAD248FF006AF6C38AEB1E54E9F87FB34FB3A71525599A3918A6831C8DADDE
-      52F280EA6362974789BE96BDBE9ED29578C8634AF4FABA8D47D3A77A59219154
-      95593C5A5195A40F2EA0C34C9E242ACAC4A69BB5BDE82864ED1DFD3C323A7742
-      91C5A4A2B230935908FE200AC8929D04142A9AB5588FF7BF6D7847FA3FCBFCFD
-      6FA9F4D09D0A6274F198583CAD656F2EA06FA082021075F23573FD3EAD69A7E9
-      D78E6BD3D1C44146EDA74E54D4EAB1B35FC54EF16A08352B54427D0A2202ECA3
-      5C434E923538E3D5EDB92611FC38E95247A854E57A7A591D91E24D69529E1818
-      6B71286545059048D67508C2E58001BD3F8F684D09269D2AA0074B6074EF0B03
-      550BCB4DE5A5303BDD6531253C9611A912392AC181FA2FE7EBFED3AEB5D62926
-      52E67A8AA963A70021229CCBE434CC0B2448A199E331CADAC5F5F92C7EBEFDD7
-      B8753E385D6585B49F14A5DD22917F7C02469592408A29FC1FDAD44137E0FBD7
-      5EEA36848A4123A24B01049551A1227121559114B07F1A966BEA1629F5E7DFBA
-      F749FA9682162618CB4F33AB4DA2308C222599E470404796054E587AEDFA78F6
-      F244EE3528EAA6454233D748F112B4C1574293611A3C41C34258C924482E6604
-      B9BFA783A7EBEEFE1B53FB43FEAFCFAA09033500C751DA9A91AD0111AD3C4110
-      028E4AA164F51F2318F4B16FF9078FCFABDBA914A3F08EA8CF137139EA551D3C
-      0CC8C0A7885E23E58423C4E8FA82B0F200ACA6DA8DF96FED7B6A49194D00EB71
-      85E3F8BA5251C1E93E31E40CE4A00619E292477235211A64A98E12A34AEBD2BF
-      8F69FA7FA72767665635AF112E122589A38C7EDB9492077064468F5A33287B2E
-      96F535FDFBAF52A29E5D63803254CCF3BC6214414EB0253ACEA3D42433EBD2E6
-      594DD34FAB40B7E3DED8B31A9EB5E17FC2FF00974FB154C7E281FD2F3A472A41
-      0CF68A35B9D663923092B849469D37FF005D6FED3F87253FB4FE5D33E09F5ECE
-      9B66AEA29A822D123D45389A489E491DA44A891C6A787F74471CC8AC8523E395
-      E40F76D2FF00C43F67FB3D3E8CC134B75D4890D688D9D929D628002CB6F1BC4C
-      106A566D2D0812477D2FFD17E96F7B0AC38B1A75B2C6801E1D07FBA36ECB50D2
-      030164F1C52ACDABC760393E68D6FA8E97BB7F607FB6F6BEDE428A50FC5D249A
-      1AE40EDF97406E7F02493A15D814B42CD1B1560115A274FEB1B2370DCDF57E7D
-      9824C74D070E8BDD06AA578740CE5F1B35382C8B75479352D8C85BD3675525B5
-      8652DF4FF6AD5ED7A30E07A4726A02A0D00E93908459B84E58A054B2DEC74921
-      0FEA5B1FD5FF0005F6EF4C02357D9D097B6D753C5AA352BFB822503CA1B51FA9
-      2DA753359B8B73ED0DC54237DBD2E8FE2E8D26CE1153C31D4682D2014F148AC5
-      4BA06636452BE69102AA8F42FA16DF4F4FB239CE403C29D1ADBA956FCBA17A19
-      D218D8553434D4AE2584BA39759232A9A7CCF22429EABBDFEA0F047B4BD2F8C8
-      D49419EB3D451AC1594F13C7E88E35115A549CCE013123E828FE64554B0BEA77
-      F535EC38B45F8BA5737E1EA2CD8DF288A4827922D1526AA02D1AC6ACE5884468
-      618E2866A5B7D0100AFD6FEF6E996634A74D787562EA0D07588D1B992A0F810B
-      B9679922324688224740F0BDB54B14EEB71AF95D407D2DEFD1B106BF3EAB7014
-      1400E3A6C971D4FA1258E902C4AA04702E9678A46D2D37A50EA0A8CDA4F05558
-      7F5F6F091C514748F4AFF08E93E68AF1CD1B5140529A768A9E6442E9799C131C
-      D04A8C15643207BE922E3529D4DE9B7894A861DDD6D1428D2D9FE5D40A7A7969
-      641512C51E42465A98C094188A297D4244491204BC3E50026AD46DEABFD7DF8C
-      BE4075ED3DD5F3A7539D68008E79A62FC196584FA1A91D64F118DA4448D59E79
-      263E8B9205B4FA48F7421968C479F55D5AD4E8A57E7D4C93272474EEE52588B4
-      AC5FC91AC652347F1ABCD343278A14D635C6353BFBA7565D5A46AF8BA938EA93
-      592C8A268969E2912A56493589E2F2A8711C618DEA15588F505D6BF4F57D7DEB
-      FC3D6FACF3CF2CB0641199D19E3D68F1A219228A38652EA9A134AD8B5C392CC7
-      4A8B7F6BDDD3E25FB475E3F049F675AE07B9CBAC76EBFFD0D4ABE3FC500EA5DB
-      32BA3297933825740CC6409B8B24518066580CD1E8E01BF02FEC15BBD5B70B9D
-      59F87FE383A90F62629B55AE91DC75FF00C7CF42F864D6269BC10BCAC7F7642C
-      E5BEAC90CA14345ABD7FA47176FD5ECBA83D33D19EA2D50477F5E7F3464925E5
-      FF003C75AA2E95362C64222296D0DFED373C7BDF4EF587C7208DC82CB249E33A
-      D5EE0B7A01B1B581D206AE2CBFD3EBEFDD7BAE32DA98452B33B3A40B73F6E92B
-      C9A9CBAC4CB1989069D5FA8FF4F7EEBDD7A9F4D446F3443F0EC1256566D36E66
-      0F03BA027E972BCDAC3DFBAF759E89A0F2491CEB222850F0F8C23963673F4934
-      98CA3AEAB7FBDFB6E4FC3D3B0B62423CBFC95EB34D225ECF2420CA0AAA491F91
-      A653C35F9E40FAEA3FD3DEE87D3A78B2FF0010A751A5884B51A69C894C0C8C16
-      26321491E361A5DC016BA49F4D3ABD5EF694D23A4B2E9D46BC2BD709A3371695
-      DC2C9FBBA79F2489C494B2007D56D6BEBFF523DDBAD75DB946291093C4CFA9A3
-      B6A526341A2FF4042A6A00AFD4FBF75B3D71740D795D0A8F2B0513867D4B1311
-      AC5B5D814FD3F416FECF3EFDD7BAE9A9D11CB00E5D04ABFB4FA6C670049EB0EB
-      FB5E95034D8A9E3DFBAD7470768764758F54F40EE4FEEEE5B2947D95BD76CCB8
-      4DF3BB31D8966C96D1EB9C8672B60DCFB1B175953A23C7D5EF511D34D278D9A7
-      CA08503E8A5A599647AD6CA4BF9911B30A3770F86A7C8FAD17F6745F797F16DF
-      14D304FF00197C57FD5DBF9F55F1BFB0CFBF77E612A70B855C26D0DBB4D8DC62
-      D24951552D163971BE46A980492E9ADC8647215D5E66A99F4AF9EA4B12F602C3
-      1BDB9836B45B7D3DCAABC3F97408B4B1DC37191DA25AA313927F974D7DAB5991
-      AB718FA4AF8F1745410CC7292D5D4C91C2289A14FB3945523996543501E174D7
-      75252CAFAD8AFAC37092F212D70CCCDC7AB6E9B64561352DE20ABFCFA067068D
-      1448BB597D4ADE3FEF264E924FD96F39A899B174B349287792445FDC3A8E9F4D
-      FF001EDC9AE5632547C5D228ED649135AD34F4AB8A829A85E4AAB3D4D75635EB
-      32337EED4D4BB12EFE494AA3A8723D23F486F6512CAC47749415E8F6185120A8
-      4EED5FF3EF52A2659B512487599D18683E368ACAAADADB8B8F6D8D4CC1A945EA
-      C20FE97529B5EA01511DF4EA055BD3269BAA80643A4D80F57F8FB73ADE9D5FA1
-      5E19AFFABEDE862EBEAF7C863A7C4BBB06A26996225CB44B4D2DEE18104DB5B3
-      A71FA469B7A7D93DFC043F8A878F1E84DB45C2782909CD3FCFD2F2364858285A
-      955489446DC2D2E80A618125F2399243EA675E6E7F57B2AE8E7AE332C8CEDE29
-      1C97D615402CC15598DCBF9088BCA82EC40D4F61EDF000C81D2391DEB20F2EB1
-      C8F128817F7E499DE490AC314B732DC4601793446A1156FF00ABE9EEDD7BA748
-      0C61000C1260C8B08166501C346CFE44D24C920D2F726EBA7D3A8FB61FE2E9F8
-      B578694E14FF008AEA6333420332BBC411E473AD5DC3B1F40D1A3C8A2CC7E87D
-      47DB13FE0FB3A754822A3A9D4DA059E348C2BA3B554124613CA1E3D08581B92D
-      ABFD6BF37BFB4DD28F24FB3A7A8D2468A4095460118678DE246620C7C3132BA0
-      7288834B23DC7F6AD7F7795CB1257CB875E627CB8F53A826069FC6BE113CD1BC
-      E24864225559AC632033B00A63B321D219BE85BDA670EC0B370E97474D294F8B
-      4FF9FA75C74E893CA63A62C5E1A7469E711346CD03CAA20814CA678D1827ADEE
-      A18FE2F7F75291C9F1377F4AA0D345D5FEACF4FCEB52BAF53BCF2CEF70D24890
-      2D2A3A9B26844D654102DC6B26FF0051EAF65E70C47CFAB0F2E9C69E49510FDD
-      0A688A4113CA6342638CA901FC4AEFAD6C05F5DADEFDD7874E08B18A786974A8
-      8E0BC81BF706B77D37FED69F2B47FD9E0F034F1EF5D6BAEE9205A458E3479523
-      95D4CCABFE6996166951242CAF5256566FD203107FC2FEF7D5882A68C3A87E21
-      2A9825A59632B54D2CAF512B2C72FDCCA277684957A8111906909700AFF67FD4
-      FBAD74C750BE586448619E199199FCC3F600923B7843E9F1896337FD176B85E7
-      EACBED442542E47E21D68F50A9A36F3089EE8EF700394D11CA5354622A86D1FE
-      775E955E2FF9B7BBF5AEB90859D5E469032957F2347CAB37A91B532A92CB1FD4
-      FE783EFD24C55AABC4F4C88C1A991BFD5F9F53118C688F12ABCB1A3215B491C6
-      5591D8AC8E420080862E07207B4FA5FE100F4E1014B49D774F595229CD43C0B4
-      7AA30E91B4C5DDE4D655C48F06A48C486EE0C77E2DEFDA4FF037FABF2EAFE27F
-      C33F9F4F42B1FC49138D0188483C6A5D042C1DDDE405582AC0DAB56A1A9C81FD
-      47BD687FE13D7BC4FF00867F3EA6D2D7BD335546955340BAE69632FE930B378C
-      B08A7D2FEA40EAA382A1CFBDD0D6BA0D3AAEA3FC27F97F9FA942AD678BEC5E79
-      6405674908AD1057BC768984F1C91E82AC551AFEB5F4B73EE9D5BAE26A29DA47
-      A78E58E168A242B52AE9218D217556764588EAAAD083D2792A2DA6DEFDD6FE5D
-      448C995CACF2543D1AC6DAE9A590324C933C61C911C5CCCCB270B6FF0090BDFB
-      AD210FF09F3EA5D4445EA64104735421F0D524307951248DAEB3413AAC4EDFA2
-      E427E6455B903E9B5254D475BE90D94DB05C1AA8444E2AA45912361222A34880
-      4CF39E6513AC764E3D1ABF1ED5C4F807A4F343AF871E813DCBB6253672AB1B31
-      6907A157CD10575D655816BB20BB281ECC21980C1AF1E8B658BD7A05EAF0D2C5
-      52E5D228C13A10D8EA0C14EA2C459B531FC7A6C3DAF120A64745EC8CA0907A11
-      B69531574768D7532AA3204E50852AAD1A12AC5959C017D3ED15C95085AB9FF2
-      74BA215E1C6BD19BDB142BE254F2C92CFA95249D5DE4D723C916B79184B1401E
-      2083D1F443EC85CEAA93D1C5A282A718FF0063A11EA14471414CCEA80C45621A
-      E3958058F4C8F4E9AC79238D6F775D416DFE2BEF51AA6990B710B8E9585D3254
-      7C3D6795278E961A43046F0A8D548524103837D6D52C5C4ADAA3957E801FCEA5
-      B7A7DB2A580ECE963E8AF771A759A3F21114018CD344218FCE44D143E4747796
-      CC7D2E91AFD796D47F3EEFA998F77C3D57D7C1E1E7FEA3D40AAA79A330B244EC
-      D148B51A1AAC450A3222AC7345512323452488CB61AD069BDB49F6EA80A3B787
-      5A3A25E2749FF57D9D79A9A1A93054D4C32A5450C524E9E5136B810CD691E190
-      4E2641A8F22DCDC7D7DFB1D50C6BFEFA6FF57E5D704A74A999D962D0BA626F24
-      D37904CF514FA911608575892131A7A4905431B707DEC12381EB7F4F167F507F
-      ABF3E93A98D7585696AB49A7358C94E25895C59637950433AAE9415323F0EEC5
-      D992DA80F7EF84E1BAA3C11246A4A11FE4E9BB22AC92A3C74C5BCA639567BC69
-      03CB7D274A99182B2E8D37B1297E3E9EEBD2228BAC3798FE7D44401E28135543
-      DE225C85F346CE8CAE0BBBFEE0FE9ABF56952C7DFBAAFF00A2FF00B5FF002F51
-      9A1AA0664A79A365987912144323C4B2C7A2A24462E74AB2B92501FE9EFDC4D2
-      9D387AC9235A9A64054AC70BBAEB5D7268891A99E503F6C2ADAFABEB66BDFE9E
-      EE83B929D32641475D78D3FE7EB5E8F738F58F7D7FFFD1D493A0CB8EA7DAE239
-      648C3366CBE81A99986E3CC69D04A3188329D274FA8DFD82F76FF9285C7FB5FF
-      008EAF5206C7FF0024BB7FB1FF00E3C7A19BC916A5925131D616EC6DC48EE798
-      D43315176FED05E7D977477D4791A1640AC2569000CB3D83A196ECA4978FFE3A
-      D8151A2DEFDD7BAEC940EBA8BF010AB47A9647650753322E9D76278FC7F6BDFB
-      AF75D68483CBEB322EA532461CB2C45B90048E4A26BFF831F7EEBDD77E4F1BAD
-      8D974686631C815B571A34A393F56BA93ABEBEFDD7BACCD14A226789954AA292
-      49938493D4558070412E2CC2FF00EC3DFBADF5C1526312967052473A246BDAE1
-      175A12857CB183EAFA5EFEFDD6BA8B189685A76594F86A66FDF08182BC6FE903
-      5A34663D4E47AFF569F7EEB7D4A67D3018D4322D812835682ACD663230504BB8
-      F55FFA7F87BF75AF2EB833C9E9459BC723EB588A047D0C10927F008522DF81EF
-      DD7BAE912454212592491A48FD6503471C57B189480A9A5D381FEA57FAFBF75E
-      EB2221521C22BEB3EB727412A6F60A87D5220D3EAB7BF75EEB3CB0C0F4C20288
-      F4B2482EAE8650EF1B3CF1B49133B206888E19AE56DEF68EE8D58E5646F51D31
-      24692A84740C3E7C3AE4453CA02A3994AC265AD8DE3767F548F1CC0BC9AA2975
-      21D5F920F3EEAECEF9926673EA78FD9D6A2448D74A2855FE11D04FBFE862FB8A
-      790448F4B5741538D9A2284C3241F70B22C3246ED28B148D0F2D70C9716FEC9C
-      584A4C442F6B7FABFD8E897728834C1E4FECFA4008798D233E38D34AA2A0D318
-      D21AC0C6802E854FF6DED686622AFF00174564D7F4E21DBFEAF5EB2101AF1955
-      D40A316D7C7D435B50F49D36BFBD150450F0E9AEB8448C8DC2823D77D65AFE90
-      6424E93FA6CDFEC5BDEC000003AF759B4CA0C52294E085552FA4B457241B26A2
-      4B91F43EFDD18F4ABD9F5C2973D4E65D694D54AF4B32B48A89334A9E55B9E17F
-      625A7006A3CB7FAFED1DDC0CF0F6BF01D2CDB8AC2FE239D5ABA300648CAC5ABF
-      70BEB2CA49691F4C9E92EFE458A3723F1CA8FF005BD9151BD7A3F171F6FF002F
-      F374D550B50D14E1D63F24A54BAAB3C6C0C4F1F3759555F469B93A5B5D8FA74F
-      BB0A2D17AD88B5F7818EA44B0CD731A4EAC154C45DCA2DE47D48A4A852002E78
-      FEC9F7ED6BD6FC06FE8FECE9C22995608299AC661118A63273E490011F923163
-      AD1FF07FAFB67D3A750055A1E2BD4E4658F4AA53C71C8B63574ED7B90C8812F2
-      E92C5A36561AB9FA5AFC7B6E7F817A791F4971D6379DE290D8B6A91A32936B1E
-      358D3D0C6467248D0A7D2803AFAB55BEBEDBF04E8D59AF570EA4E9F3EA5C72B8
-      14E1742C0EEE6A0891D9D9A62AD1346E11258E232A1D4806921B57F6BDB3F2E9
-      CF974A481D4CF343AD4C8A2070FE572635D6B11D0E844514B2B9D0C9EEEFF0CB
-      F6FF009FABC74D6B5E15E9E2994CA111E3951E45444942BBB5CB962D183ACC8A
-      8FA952EC1989E57DA4E94F4FBA82A2C7ABC6F773084D2B2068C98C5E290B2190
-      85D3ADF5F8F57E9BFB4CD1126A5BA541D5815EBBA39C2CD4F0CD17892BD9D967
-      9A4574779DFF006D351B0B07731B310BFEF7EDB92368C853C7ABF4F893A2C5E2
-      96649A5909A26A8A3649A395A16624A4F1DCD3828397FC7FAAFD3EE9D6EBA46A
-      EB27DD40B25369819F40934B97958C10C40949259175BB3CC058589BF3A87BD7
-      54AEA5AC673D649AF13FF93FAA1124A639279CCD50E49080C8AA510AC8BC8E57
-      40B5D891EFDD5FA6B9C3C93471A049196550893278CB698D24D411DCC2C1E436
-      BB7D47D3FC37D6BA654A3612A4B2CF1D6CD14CE6448513C750C924863A779230
-      A9148BA6E5C807F16F6F9994A6829D53477EAAF53240630F3A35EA8B1A89E969
-      87DC48AAD2A1FB61A48D30B38FAE9F50E74DAFED8E9CEBD2B2BD32B4CD54889A
-      1A6855914D395F1CACA8117EB72C2C14717FA69F6AFAA751AA2A646697ED6742
-      F0841E6F12CE0A10AE14C8F2AA24AF0B1517FED73C9F4FBF75BEA6AD56BA6F13
-      80D32472F9E7572F2869642B136A78E04F0C658285FD7AFF00B4B6E4C33D6BE9
-      7EDFDA3A8E95354A513EE01A4F1BBF90AF958C896F1A29725A2D68751B961A8A
-      9BFB63C0FE91EBDE0CBFC0BD498AB8BBC894932CDA29DA578BC67CF21D453543
-      2B98A9DF92418C072E2DABD3ED27D2B57FB45A754F197F84F5369AA344889149
-      1B48C91CA11F4C4AC25B8D012525F542CF62794D47DD3C2FE974ED7ACB03AD37
-      9D679824224A76D2154912B4818A3EA99D175146B37D53DFA485A2153D5633DC
-      641E7FE4E94EC4C4B2C55493BC32D3A148A94A4A753A332052CA8CAB55A86A2D
-      E916FF001BFB67AB804D4F58692D5342F550D39922A5302408B22A4F25284558
-      D5E213388E4D0ECDA5BD6BA7D7C9F7E048E07AD7CA9D22B70609A6A50A608B98
-      D228EE80C7107914988B864D7A49D6DA484E381C72AE196BC067A4F32039391D
-      03F97DB125379D846CA63BCACCCA9A983B11AE385EEA046C2E14AF2BFEABDADF
-      12AB9381D2068F48A903A9381DBD2F8637F54752DAA9FCF1AC51D4B1BAA89227
-      B9643203C7056FE9F692E24D271C7A71134804F1E87BC32474D8B25647864A78
-      C88D7C6D79E57458CBB22C25049A794E346B637F65CD5AE3A39B4F0FBE9C33FB
-      7FD5C3A52FA488A19259FC714AFE46D112C0F32028EACCD73E0125B481A1350D
-      4ABEFC6327B95CF0FF0057AF4A3C272F415A7F2FB7AE6E646434CA15854C50C7
-      0C824136B915595869999547915BD44327A589FD43DDC0D3E7D37330A47EA3FC
-      9D753461A0900006A591958CAF2060BF6D2494BC78D04025509E4E1C6ABFBD9C
-      8A75B49515517C2FF57FABEDEBC9573E52286969A2A7F2C70BC4B4B23AE42374
-      95BF7296A1A2BC954222BE45911C105C0E79F7A44D3C389EAECE24A1519EA54B
-      4B0D404A79608A5BC32A56192A24681078CC49E1A6063BB89757EA6F7467560C
-      BD2CA8EB32D15340F0B2BC7098199E44925F22CB0C91E93523C651A3013F1F45
-      FA736F6DF55E9A6B96E5D65785E0A9658A042917905DC068CB1F190198B0B925
-      542FABDAAFC09F674999752CDE95FF003F49A68B4C73D21FB859D2B054892473
-      344CA4C64A23A450008CFE828BC8B6BE7DB6CC1467A4C62615E9BE4A734542D5
-      12429FC3E42650C8C64682491D927F2B965F5AFF00B47AB96E17DDBA6BA6A51E
-      830E958A1591E9919633116210C91878BD37217FDD9E86FC1F6AE0D5415E1A87
-      FABFC3D53D386BA7FABF2E991AA2409581DC228A430AA68FB794D4788BC2ECAA
-      1FCF1C8E08B7D087FF00907DD9230262DAF19E8AD4FEAFE6DFE1EA817DCCFD41
-      9D7FFFD2D49BA090B7546D976F23234B9BF4C4B7755FE3D985202AFA9F51FCB5
-      FF00DE3D82F76FF9285C7FB5FF008EAF5206C7FF0024BB7FB1FF00E3C7A13E69
-      659630D4C92690CA922CA8B4EC1189122A86D6C268CB6B17560DABFDABD970D3
-      AD3570E8E8F1E9F679619618C292D2C682FA51D545FEB791C2DD507D38B296D2
-      3DB8E1469D1C3A6D0B9FF4BD435998DB48530AC815CEBD65119407945846D662
-      3F4FBA015600F0EBD29E1E9D76E4CE8A801E53C8971A4A29B49F45E09466F57F
-      8FBBBA69D002F1EB517E2EB1CB0AC88D199E58D58C6FAE221406B00D1F974ABE
-      A7D3F9B85E3DB7D3DD729148812A238C95942C62D36A313AB5CBCA5A468C346A
-      A587176FF55EFDD7BAE3094D45944B2494CA11659E311AB302199C7959E4D42D
-      A357A95CF3FEA7DFBAF7528193C92017A932682F147E1090690A9AA60E04B225
-      81D2C6FEA1651EDC8D14AD48E92F584EA8A631688A36701B49596416B1FF0039
-      C21134C2D7FECFFC17DF9C200349CF548E562FA5B875D0892C498802D13A0742
-      C1953867008BB2B2FF004FA700FB6FA5BD4210DA679A492510B04489E47F2A1F
-      1C6419628EC8633AC73FEAFDFBAF74E326824E99CCCE91949250C3C720544579
-      8B94BA10C6C0A9B8E7FDA7DEBEDE9BFF009A9FEAFD9D718E401A38E425D4A085
-      E3694B9462DA1163259351F18563AAE493FE17F6EBAA0141F174CE7AE3EB5D44
-      B0D2CD23065D1AE445D0B66D2A0151A3F3EA3ABDB78383D2AE929BE6698E0A1D
-      74E61857214EBE47D32395F0B379092AA521924234A93F8B7F87B35B5650FA13
-      4D34FCFA25DD107805FCF57F9BA096270A7505FA6A0ECBCFE4900AEAF4DB8F6B
-      F87450AF10ABA8A1EB04C9100A1925779096D046A62AAFA6D6F4825757E9FED7
-      BF75AFA7FE9FF2EB309D74CAD2C4CA480CFF00A975A237A01D1CA2A5BD3FD2FE
-      FDD28EBA9182A199F42A58BBFEB66D2ED6D6155BF4A83FE1EFDD27F0FF00D16B
-      F3A7F3EB37AA16817C3E47842B977D5FB5EA1A7478C30672C14FF87BAB2EB565
-      F23D3F13CC823D21A9D180C364A0CD63A2ACA0728231E1AE59A593EEA19A1452
-      04374B9150DA8DF4F2BF4FE9EC8AEADFC07A6AEC3D086295664F87B874F51C69
-      0C2BC2DA551A24F2E990467D31F96FEA7A878FF5202AADCF1ED235757463132A
-      A255FA908C6265621046CC58A9669D10440290C8814469A82FD0FE9F74E9C528
-      41D14A7ECEA5793D0ECD0C6CE161D1246C969ACA6294BAAEB71727F573FD57D5
-      EFDD5BA94B2DA33764F0AA0D4ACDA27F5EA97C89AD9A492025B503C31F749416
-      D141EBD78751E431D4A785809248D03298C9080B9282C5993D48BFAC1E07B710
-      AE85078D3AF00C24423E1EBB467783542D04D1543349AC976495D65544E0FD52
-      252090058E95F757A460E9A74A030FE21D3F42AD49244DAC9A18E511C8CA8921
-      323C83C6238446A1C4E5C5ED728A3FAFB4AFA424ABE7D391E1D40E35E958668E
-      EB1C51921D8336BF4CC08040F5928AD0C4A751B025BDFBA7BAE70C891BB2C6D4
-      EA6425A3BDE27412B979B53CBAC383CD9AEB73ED0FFA6E947FCD2FCFFD47A992
-      CA88D16B61E48E58D50CB722F190575104B03E46B69E6FABFD8FB6A6560514F1
-      E9FE15EA58AD0C1A52C8AF17A3C1EA559222E141D0964D4FA8DF48B81EEA8843
-      F7263A6BC65F43D7382773195150E92159129EAAA17F6CA9118D484336AD16E3
-      5802FEDFF0D7FDF47FD5F974EE7D0F59A9EB9E4AB5405F4D394496691088A712
-      C16530BA318D6152A6EB63CFD2DED1B001885351D694B52AD83D729EAA960835
-      4ED2D4898BA12F1D4CF2127D718D4620C55D655D209F40E5B8FAFB4B7F09EBCC
-      CD5040AFAF52119025A2F1F8A0BB18D41F1462E7C861631692510AEA451F8F7A
-      EAC2B5A01D4CF034C8AD14D19F1482263C1935686709548435D45C24489CB0BF
-      ABDFBAF57A66A8A69FCB1C5500179CC8E595400648919FC7A15A41098D352956
-      D474AFE3D984AE563A0917575568E20B45A53A6DA8A2348A1E1E15B446A69DA3
-      54F186D413CAE3F75F59F4FD2C3E9FA7DA4F1E5FE33D5741A57FD129C7FD5FE6
-      EB0A94AA121286D2A00950D1A689A30B642ABA563458A4B1D4C4AEB27E9ED7F8
-      88A2882A7A79E40ABDAF9FF57E7D7A4A84920F0A542BF9DA4499A288908C5DC8
-      991F508CC2BC8B0FEA3F16F69FF23D33ACFF00BF07FABF3EA2A2CF0544E91A47
-      03CF1B832A84125A0913FB3221891AEDAD05EE5CDBDDBF2E936B5FE35FF57E5D
-      394F5AD2353D54D3CB0D45D637920490C30DB5092590B22C83C90215523535FF
-      0049FA37BD0F98EACCE94ED93F9F4E34C8B550392E8C2798F91AA024122AA893
-      4970CCE083A7D2490CDFEBFA7DEEEBE05FF4C7AB43F11FB3FCDD2A68BC7E08A1
-      A79A9BD51C80CC58DD22545650C91B87FB62A3EA2C2FFDA1FABDA1FCBA52BA28
-      7ECC74A02ED1C4161A44A80890D4F8CCE90D18AA0CC59CC6843AB94777D4C407
-      FA5FDB5AC7F18FE5D3BE10FE2EA3C9551CB4F07963969E79D2491E458CAD2D39
-      8F4CDE38C8965513B1BDB92AE01D3EDC5662149E3D347A49CF8FAAA87B28A229
-      55023C602468CB2B08C4CFF70E548460DA00F18096FAFB511CA43535E3A69A20
-      DF08CF5163C2FDBB413C2223A2B1E69C799855430C251854D1870ECC4DEC5384
-      B36AB8F7594860CC7E2A75E44086B5E97D4829F524C615951AF28950AC85D444
-      05C36958D1DA4416D2749BDFDA702A18118E9E5263C29A75CA58E26713334A88
-      8BA1610B67D23C4C1F4C686489A3607E8E7EBF5F6E0C507974E2C859BBBAC158
-      081147F7129446B9250C723C3708C15BD1775617F5DC15FD5FD9F7BC79F0E94B
-      085F85475C7CF4EEED4F249356CB3D5C4A4BC73C92A4A441A14395568A09CC7A
-      D1096561727E9EF47F97491D286BF87A8C691E2799A859A524A48AE59E15D711
-      78C53889184722199175157B3203C5DBDEAB4EB4ACC30071E9FD6B279A08AAA7
-      526A912A964A7699DFCDAD468B3A9322C5A96C38FED9B7D3DB3F89E9EBFE6E96
-      A15658FBFB87500554A6B816A58A969929CA2A46F3C2A65588348928F1C8F2BA
-      D4467E81974B9FA6917F018AF5E62FE2A007F4FAE3242C1EB2A0081A2D12C14F
-      4F1078BC31C91C4CCB27935346DAB51263B349E9F7ED6FD9D3869AA5AF0C74C5
-      5D34682ACCE90F8C22C71548AA768E72E3F6A491D48644566E552E9F4B9E7DD9
-      496A16E3D249DEBE1E93F87A6D4AB968289A0A8D3346CD0493CE7C9E175954AE
-      B3EA925560CDC0F53116F6FC4A1A4453C3A4FD27AA218191E7257CE19DA46811
-      E596342EFE29592E8F79827AAFFEB10DED7228D1D9F10E93943212C08A1E98F2
-      312494552C5E4866A788A7AD5E0921711AB45A56C6392292C3E9F93A6DEED17E
-      2E912876900D19CF5419EE61EA0AEBFFD3D4AFE3E228EA9DAE4A97F23E758235
-      B41B67B2C846AD48469B6AB6A5FF0079BFB05EEDFF00250B8FF6BFF1D5E87FB1
-      FF00C92A1FCFFE3EDD0C8FE1432BCF1C9134B748B5164F2DB48FD001D1297E75
-      FE9FF927D97746FF00D9D7CEBD738A08648696590B38264599CEA0B1C81D42AB
-      B190DDBD2496BB1FA7FC17DFBA77A8A2052B288DFC2ADAD7D12321657B893F71
-      8D84A19BD5A7FB3EECA6841A75EEB83995EC237434F0BA6A895D06B03C60064B
-      59353A7FC1BD3F4FED7BBF8A7F87A4FE1B71A75C504A4CB2491420A24CAAB019
-      523F1C8C562F349207D3A5975136B368F4FB6BA53D731FB6A9E20C57C31C729B
-      AD9825C999F4477666FE9FED2BEFDD7BAE66CC19E450118AB81A8B5DEE05822A
-      22FA8FABFAADBEBEFD5EBDE553C3AE3151B22B10969A5923107EE097CAAC195E
-      47F55E3247E9D4C55428F7747080E3A47247ADB52F0EB1843CC409914B866129
-      7F324A03811ACA7D7A5AFC0FC0E145BDD3AB244C8DA9A4AF5948612BAB292164
-      48A543A95D1783AD634254C8A7D57E40F76542EB556E9457AF0648F432B7DC0F
-      0B405E51A9830E7CC11D880ECCBEA1A6FCFBF347A56BAFA6A23F17585268B538
-      85246590A32C8F104122DDB523A3EA28AAC6FA48F57BAF4F75D874D4E8020855
-      10896E25513B3B7909950730A2FA7425C8BDBDFBAF75253479D8C9A2188FA4C0
-      199AA620803795CC9A0F8C2AEABA0FA71EF55F2E9AD5F829F2E9AEB6823CAD3B
-      A4A1DA89EF11D4AC8C1E465613C41EEF0AA3E820E9545FCFD7DB91CCD0B061D3
-      53C6B346038CF4054B11A6A99E097C7E486A64A665BA85251DA32A3C64292E45
-      C7F87B3F0C5D41386A7445F4C232FA387588B3128743312C09315BF694A70BEB
-      FC8FED30F76EA9D71825495D55D250EE3D2BA4BBB12DA3D5A574007EB7BDBEBE
-      F74EB496FE220771DC7A951C688B33344348274C773EAB72CCD760A49907E96B
-      8F7EEAAF0AC2A5A9ABFD5F67599F42296B30728B190BADE4F45D6C2C0302ACDE
-      A6D3EFC3874A90D13E5D386232D5585AC8EA295CBAB2049E2A893F6AA6029A1D
-      26753A5A520EA07EAA7E9C7B69E049FB1BE2FC3F2EA82EDE26471DA357763E2E
-      87D4589E0568099639112508C6CA8B7F55BD0A8B2ADC73A8B01FEABF21DA153A
-      58F7747EBA643A87C3D766A7C0B531AA4B218915A605224511B49A9986B1E399
-      D03DCFD3581FEDFC40603A76291529EBD6686695C43108917C70E9F33171A83E
-      B68B4A7ABCB2DD99B513C8BDBD3EF4CB5E1C7A50B302DA5BA9F14921A8A69A61
-      1CB46C26F2C45D744DF48D1012A5DE3F3FD107D08FF5FDB0D205D3D3F41D4895
-      9A60C5204469244B46C01750594B24A24F53471A9B332B7B635FEA6BCD3A7350
-      D3A74F59C3AC5514AB1BD33469A257A70F678E99C3C6EDFA48B24B623D28180F
-      AFBB4AEADC3AA014E9E61ACBC8F48A15E66D2FA149023496E5496D37B1427E97
-      B7D78F695A263E21E9F8C8428C06074F14880A471C2BEA53E38A62559D23F1BA
-      C41E3605D755D8DCFA1459BFDA7DA6C367A5B1CA0AF68C93D642A93C6EB2BF0D
-      1F89ECB14D1C8AC7C422590231F103E8E45BD5FEC7DDBAD75DA4CD0F956FE8A7
-      40699DB5BD36A1E910B9886BD48CEB6FAB9E2FC7BF75EE3D4E8105846A6DE377
-      953D6CFEA60753B6B63A58DDB511FEDBDABEABD73F1BB2C3791E28660915422A
-      1584B94643245A15A4B39B17B9B0FAFF00B57B4723AA498E9422064FB7A9D1D5
-      943124122B494B0C5109A48E5747A8923D3012AEBE39AC7963A99428F69E37A4
-      BABA7340D1A7ACF62C7C1339790FEE191BC22294471B3379468029E3465E18DE
-      D6FAFB7F4FCFA6CCBFD1E9CB171BC6862A57A18D74BB849E3E1E666555D0D1BC
-      683CB7BE80D7F493F4FAA2E9474EA239582248E8B52AD09090C6D0A7DC42AADA
-      DAECCE4C9127E574A71EFDD7A9D4BA949E295E5F0454CF25DA396312B127C4A8
-      DE566173AF56BD77F59FA0F7EEBDD2772547214A2759199A2756791CF9597421
-      9351D7137921591546AB5CFE07BF71200EBDF9F4D32C5490A99C53697B0FB8A4
-      81E5FD554D1A5C2EA50215075B0E00E7F3ED4A830D243C7AD671D75222A3941E
-      3D2E3F61151A2FAA2842EDAD98B32DAFFDA627E9EDF43E277FC38E928FECB03C
-      FA6E48E764F311E379242B1327AE34081896526171EA2159D5FF0049F75E90FC
-      BAF4463A70B13CB24EC86470ED23395BC85180D61555159EDA5405F55BDABC9E
-      ACB112BAC0EDA7F83A70090BCB2355C4B2075452AC19A33ADEF142B7F2C734CD
-      2A6B3A14599436AFAFB45714D11D3E5FE5E95472091B4AA5095A74EF1651E278
-      584529A556D463958EB457BC489A83BC72EB44562B186D039E0FB48450907A53
-      A06BD7D2CE1AB789454EB5A5A7786134E1C3B4CCB2AB8650AC118BBAB00E8C74
-      80180B7EAF6CF86DFC67F97F9BA7032B126B5CE69D7524CCD1EBD663D34CC0D3
-      C72CD6561278164F17AD1A6F1B310BA811FE37D43654F56FF8E57AE47ED69D03
-      D52471BAA0A959269FC8AC5B507AAA71348D248AB7F5FE357D0F1EF695EEAF5B
-      74D3F674D5F6E042B340D14429AA25152F24B3182346447F043526C9249531CC
-      8ACCC582836E5B8F77EAA09191D3B46D4F1B1C7411BC314680BD547010F1485A
-      268744736A73E2B680427D57FA7BF755EB95A57AAF0CB551BA792794244C9E57
-      5370D4A94D16909E3824D45D0B397B7FAFEFDD7BA95E19A55A757A76B352E98D
-      230F110A648B4FE9775792E49D2C4B16E3DD4AD69D3F1388F583C7AC1453E4D2
-      5AD73140B05332146D22AA6AA8542A92163455763A85836A2BCB7FB4ADE94141
-      D3E5AB006A641C7ECAF52A09A04AA6A7695A9630D2A0ACA9486370FF006EB23C
-      915328F07DB908DA197FDABF1EDB75D4083C3A488FA6BE9D739AB54C6B220634
-      8F0C7525CA49046BA25F1057108F1B394D2EA1BD0350FE97F7A4421958B1AD3A
-      DA950C4F974DD50F3BA34B4E6563758C44D2858DA08E4689A513082391AAA564
-      E4A339BDBFB25BDFA43951D3EB3A70F0FF00D5FCFA6CFBD8CB52A514F5AD0475
-      3FE58D534EA279638D2F5350BE456D69A9FD2CFEB2A87D3EFDE19A6AD473FEAF
-      CBAA49728CB20D1D73B40F0AFAA2A87684C9159E22A41211CC70C68D148A542F
-      A40B7F5F76514AF4C751E708F1B354040AA2CCCB230537D5ACB44E4BBA90D655
-      D25917927DDBAB30AA82735E93B3504D3AC6F0D285549D63BDDCC8A2A1254447
-      78DC8712066E42B59581F6A229963194A9EB418A1C53A6AABA45D25A290CAF0C
-      623999DA4D2F040EE16CA5826AF5F249706DCFE91ED620F43E4BD33346746BEB
-      5F6F730758F5D7FFD4D4DBE3AC1E7EAADB0EB70D0C99B5267406068DF70E6246
-      F11B7A0EB8C73A4F3C7B046F2C7F78CBFED7FE3ABD48DCBC80ED96CCE9DA757F
-      C7CF42E4822FB87A97A7777A78657851B5BAC6FA8790C524CC12F766BB3693EA
-      E07B41E9D1949F13A8FE2EB9333E8769033A5E4692C41892D724D3A44EC91C6C
-      C3FD537AB93EF7D5FA8411A595919A38E49F4C54D4D3B7F9C4453E491869FD7A
-      D5400090B7F7EEBDEBD6478A4A57753012E8232B1C9214896750CC64650CE408
-      D05D12C7D5EFDD6FFC1D74F1B96694A792430C8C10A07F3ACC1432B4234A7D0F
-      A469F4FF008FBF75AEB946C8232ED2A4EAA90A7943C61A231AADDA0238F269E1
-      C7E0B7D07BF75EEB92FD35C323AD33A2688D252237687969046F76642CBF8B36
-      9E7DFBADF5C555E799C53814F053A2A453CA51A59279AC38FD560A757AF57BF7
-      5EFB3AE962BA5A5412C2A9A09925D6B3247E95BEABB6B3AB535FEA4FBF75A3D7
-      085246A98E2D522791B990B690B115B2C44EB274F371616BFF004F760CCBC0F5
-      EEBA3115D36D31C65DD99DFC51C0A006FF00767A4046E5AFFD7DF99D8AD19B1D
-      7A9D3828F3C48CB187608C8D3C450DB90B4C44709FDC2ADE93F4E3DB2CC41F97
-      578C298C964C7FABCBF9F580C153F72864965A79E33A9A5823791A59B42E88D1
-      0B3A287079014F007BBF4CE835ED8ABD716A7710981D249E5BFAE698491B4B1B
-      BAB3472194CADE0BBF0A08F7EC75BD1F8B4375919612EF3185A73208A348140F
-      22A8244E6304DD90E81EB729761E9F6D6AFC5F974ABC28EA468C7483CEECBACC
-      855CD5B426085EA64D6695E1628C218F46BF2200232FA74B0D2C2FF9F66705F2
-      C712893516E8BA6DB0B3EA89A8BE9FEAF5E91190DA79AA156F2E3E678DAC2292
-      8DA3A942ABCABC4908F27898AFEA2ABECC05E5B7754AF0E89A6DB6EF4C63C10A
-      B5FC3DDD095B73646369E9209721134D5AF08964A795432A49E312451325EE9E
-      3705431251FF00D4FF0052897719448FE1D74F46969B72A8A49F02FF00ABFD5C
-      3AEB37B0282A69D66C3DE9AA0471F8E13A8D24AAA469490D98895BFB079BB5BF
-      D70E5BEE123C9A665C7FBCF4EDD6DF14F17622A956AFC5C7E5D04B2D25452C86
-      9EB9258AA926F1490CAA124496E34C662FD1AC861FEC7D9C192392A548D3D104
-      8CD116461A57D3AF52A096B28E9D4EA569A9A361AD1D8DE542CA407466047E90
-      0AFF00A9F4FBF3B688E690FC6063A4F1149268622752573D198A62C903388628
-      E2480F8CB39964964D3FAA411168FD1A974F26CC7493F5F6160EC46A66EFE86A
-      912811ABA669D4B34D095BAAFA645D6CE246E5C00B2C8B12FA192456BFA8B5FD
-      EFC4F975BF0D3FDF5FE0FF003F51D2869DDC540F34AE66D70AC723489E65D701
-      D08AEB0D9917D6085007F4F7A2E29DCF4EAC228F561323A990C29142630B1894
-      4D24C12391258A1D654ACA1A1FDB8FC9FAB4FF006BFD7F6C4C476D3874F75323
-      1C1018B8D0ECC5EC5EE857D6018F8161A4A708BFEF3ED3E7ADE0E0F0EB1CE84A
-      CB25399D2A5E23A193C6F2A69286350EECA80EAFF1B7ABDF87566001C7536391
-      DB4A45F8F5BA7F83C61234667E25019BE9FA7DEC2B3F68CF4E0E0B4F4E9DA985
-      4AC3333A0FB79396291C6B3CCD08F43A3A3EA58912327C6CBFA9BEBC5BDB332A
-      01DBC2BD6C3B2D74BD3A74590C90A4B02888F8C790B470949341576575D5A995
-      4B9FF0BFB67078F4B96BA1181CE9FF0057F87AE3E658B4449269B4A9543EDE55
-      462255D259C233BC8B2E8D2755894D3F40A356FAA759EA3C6C432168C6A49115
-      8059208A1D2FA535689B4C824D5F95BB73FD3DEA9C4F5B766118087BBAE2D5B3
-      221304CDAE7BE966D2EB0A48BC482365B2306E7E9625BDDE448FF11ABF5A88C9
-      A1C386D55E9CE2AC658E2086F2473A0AA6F1126509A4AC8F23AE9492708CACDF
-      A39E3DB7222535467F53A795D95753B557F9F5D554F04C86279C43E461F6B033
-      949A450E3F644D72522240F4EAB69F7E52C402DF174DB346783AFF0083A91453
-      4D4BA6B65A582AA683588A3789A49A2BBA812410C92331D0B6D4FA16DF55D3AB
-      96E545D3AF3ABA7564D469AD7A5C8903C715489E57609500079018E469F89BC8
-      17525488D80B2D94036F69ABD3FC7AC62AA74A74A49E608A8D34955513DD966F
-      3480ADCAF91CD3D878C237A7530E38F7EEBDD669D62D33BA2868C7F9D659190B
-      46E2EAEAA024710473FF00202F23DFBAF79749CA88BC452606405DA2A48AAFCA
-      A887CED7586411FADE6599B5056B075FF55EDCF11DC69773A7AAD1554903A6C6
-      A7A6493EF04AA6A263121AC312BBCE94AC1BF62199A331BE81C9FE8ABA8FE3DA
-      887FB33F67F97A666FC3D34AAC6EB2B49E78E29A38D638279DFCE8AD2073E949
-      4D95D79FC337F5F7BE8BFAC54E638EFF0070AF35A552B23440BDB50215CDC831
-      A5FE8348B13F91EFDF2EBC198768AD3ACB0E8444648E6135324D109AAA574558
-      E525247D25D4B892E0866E78F7BA06AEBE1D2D5544C246750F5E9C12A229A6A2
-      D04E983C4423C7A523A993F61C0764BFEF22DCFD2DC69BEA3EF46340B2368FF6
-      3ABF8DFD1FE7D2929EBA6B494B2C89A52B3C6AABAA4545B96450651A55C2B723
-      F48D5A6FED174F86046A5E1D678EAEA526732C818B48A1A31192EF23BDA9D821
-      0444110DF522E96BFEA1EEDA18FE1C75BA8EB34ED4950D25990C9EA2F3384768
-      BC6C1163A69249085D2EA6C3D2964BFBD18CC78D34EACC401F1D475929AAA4F1
-      D1539791A03491C9A5A37AB8883E421E252C5E0AD99D817E01FF00926FEF5D57
-      AF076796533431D3D1A42468679055C952933482A3EE259574911C84A599D95E
-      FF004FD3EFDD6BA9A94C2485E4A699E8AA2585FEE2A915750842957F34F50155
-      19A9E1E087BEBFF5573EFDD6FA7054A4A68A3A1579515D0EA8F5CE6D4EA7CAFA
-      5D93C70539762AC41BDEDF83ABDFBAD75D9D21AA99A6631EAA775489A52D1D42
-      05785E2950ACBA648ADA910682DC7BF67A76AF4A5314EA4C752923CCDA29C342
-      D269803DEAE678D9CA848ECA63545BDCDD0E9F7EFF000F4D53A8D51AA1899E17
-      00246E4C852632EB9849E4766F23A462459B4DA3161617FF000F7CFAF74D6A92
-      C7E181269BC91C93EB59965779BF43883C6CC0AAC2AA1DD97993558B7D7DE88A
-      F1EB7D4090C6649744C191101A99151F4C71966109691C2CAC7C8F6F55FF005F
-      EAF7BA9A53CBAAF76AAD469A758119400D4EA8F1A542C68DF6C829BCB5319694
-      B8285FC6B6BB300CD7FEBE9F7EFB7AB2F0018FFC5F588BCCD4C6112B12CF33D2
-      C962D234CFEB36F388CC5149AB4E86FEC7F66E3DFBAF75C321379A9697EFA18A
-      8E78D57C91521D021915F42CCEF2A698A7D09FED561C58FBF75561A94A9F3E99
-      AA238618DE89A29FCD189249E4AA3F6D053B474E03976924168DC4C3F6C11183
-      F41ECD538C1ABD0FFABF674EBAEA40BE7A7AD7BBDCBFD63975FFD5D26B60FF00
-      C7A989FF00B293FF00355DFF001E0FFC7A9FF173C87FC5A7FE6D7FC77FFA6AF2
-      FB24BBFF007224FF00707CBFB4F8F879FF0093E5D08B6EFF0071E2FF00928F9F
-      F63F0716F87FCBF3D5D28E5FA3FF00D95B7F63FCEFD3EA7F5FFC47B4E7FEA5BD
-      3EDC7FE5ABF9F59FFE51E1FF00B2BDFD127FD43FD0FF0099FF0068FF0055FE1E
-      FDFF0072DEBDE9FF00254EA0BFFC088FFECABFE8DFAFFE047F67FCDFF87F5FF6
-      1EFDFF0072DEBDFF00734EA427F6BFECADFF00E041FD1FF207EAFF00A68FF8D7
-      BF7FDCBBAF7A7FC953AE6BF593FECAEBFCC37E9FAFE3FCE7FCD8FEBEFDFF0072
-      DEB5FF00734EB0C1FE6A2FFB2B4FA7FBA3FCD7E98FFCD7F87FC45BDFBFEE5BD6
-      CFFD4D3ACA9FA23FFB2B9FF36DFA3F47D64FF37FF36FFAFF008DFDEBFEE5BD6B
-      FEE69D743FCD49FF006571F58FE9FE6BFE9E7F8FFA9F7BFF00B96F5BFF00B9A7
-      5C57FCD49FF656DFDAFD3FE6BE91FF009CFF0089FF000B7BF7FDCB7AF7FDCD3A
-      ECFF009D4FFB2B7FD29F5FF3BF54FD1FED3FD3FC6DEFDFF72DEBDFF734EB11FF
-      003555FF006565FE6DFEBFE6BEA3FE057FCDBFF55EF5FF0072DEB5FF00734EA4
-      527F9A4FFB2BAFF757FC04FF0035FA17F47FD11FED36F7B3C3FE59BD3F1FFD4D
-      FF002EB1AFFC0D87FECADBFCD4BFA7FE06FEBFF74FFCDAFF0057FED5EF5F87FE
-      59BC3F2EABE5FF002D7EBCFF00E6E9FF00ECADBF4B7EBFF37FA47FC07FF69FEB
-      FE1EF7FF0072EEB7FF00737EB2BFE87FFB2BBFD43F5FE8FD7FDBFF006AFF0089
-      F7E1FF0052EEB6DC4FFC95FF003EB9AFEA7FFB2BEFD23F4FEAFEDFEBFF0069FF
-      008DFBDFFDCBBAD7FDCDFAEA1FAFFDCDEFF9B4FF0033F5FA9FFAC7FD3DFBFEE5
-      DD787FD4DFA90BF55FFB2C3FD71FFBDFF67FDABFD4FBA1E3FF002CDFF2F5AF27
-      FF0092BF0FF375D4FF00E722FF00B2C3FF003E9FE7BF5FE3FCCFFCDDFF0053EE
-      C3FEA5DD54701FF256E1D276BBFCF3FF00D9517E9FF94EFF003DFE753F5FFB4F
-      FD176F6A62FECD7FDC2FF6BC3F2E93CBFDA49FF251FF006DC7F3EA250FFC0A83
-      FECA57FCE8FF00801FF02FFCDFFBABFE6F7F4FF68F7EFC3FF10BFC9D30BF1A7F
-      B9DC7F3FCBA58FE0FF00D9647EB1FF0005FD47FE4FFF0089F681BE23FF0024AE
-      3FEAFF0063E5D187FDCDBAC63F445FF6589FE6D3E9FA3F4FFBABFE6DFF004FF0
-      F6F7FDCBBAB0FF00A9BF5C5FEA3FECB0BF5CBFAFEBFA0FD3FDAFFD5FFB4FB69B
-      F17FC92FCF8FF97FCBD5879FFC963CBFD5FE6EA5D37FC067FF00B2CDFF0074FF
-      00C06FF80DFA3FB7FF00447FB4FBD7F17FC92BFD5EBD37FF00736EBBFEC2FF00
-      D966FF00BB3FE0BFAFF1FE3FEABFC7DDBFEE59D58F05FF0092B70FF29EB847FE
-      74FF00D965FD13FCDFF9DFF63FE1FEA7DFBFEE57D57FEE6DD674FD69FF0065A5
-      FA9BF47EBFD63F47FB57F5FF001F7EFF00B9674A3FEE75D731FE6FFEE757F58F
-      A7F9BFD52FFC9FFF0013ABDB7270FF0096579F1FF57EDEBDFF0073AEB327F9E4
-      FF00B2DBFF00367F47F9EFF37FD8FF009B7FF44FBAFF00DCA3A7CF14FF0092EF
-      FABD3ACE3FCFB7FD9717F998FE9FE7FF00DD9FABFE6CFF00A9FF0063EFDFF728
-      EADFF73FEA4FF64FFD975FF6FF00E0BF9FAFFD15EFDFF728EBDFF73EEA3A7E93
-      FF0065C7F54FD1FA7F40FAFF008FF4FF0069F7EFFB9475BFFB9FF53A6FF309FF
-      0065E3FAE3FF003DFE63EB17E8FF006BFF0053FF0020FBF7FDCA7A6E5F2FF92E
-      FE1F8BFD5FEF3D419FFCF527FD971FD2A3FCFF00F9EFF3FF00F289FE1FF1D3FD
-      AFDFBFEE53D35FF73AE9DE3FD7FF0073F5FE6DFF00CDFEBFD1FF005AFF00D57F
-      87BABF01FF00248E3E7D6E3F2FF92DFE5D4C83FE02C3FF006F06FF00327FCC7F
-      C05FD127F99FF9B3FF00117F6DFF00DC9BA51FF73FEB937E9A5FFB7847D13F57
-      E9FAB7FC05FF000FE9FEC7DEFF00EE4DD7BD3FE4BFD7A7FF00372FFDBC23F1FE
-      7FFCDFD07F9DFF007DF4F7EF3FF96375BFFB9FF519FF004C7FF65FFF00A5BF5F
-      E9FF0081317F9BFF0069FEBFF3774FBF7FDC9BAD7FDCFF00AC13FF009F1FF65F
-      1FE6AA3FCFFF009FFF0076FD3FE6D7FC74FF0090BDBBFF00728EB5FF0073EEB1
-      57FF00C09A4FFB2F3FF757FC0FFF00813FE6A5FF00809FF447FB46AF7EFF00B9
-      4F49FF00EE77D443F58FFECBA3FCE3FD7EBFE6E4FF0037FF00373FD57FB4DFDF
-      BFEE53D7BFEE77D750FF006BFECB9FFB7FE67FE0DFDAFF0089FF001F7EFF00B9
-      474A0FFD4FFA9117FC014FFB2EFF00D47FCD7FC01FF3A3F47FB57F5FF6BF7EFF
-      00B9475AFC5FF2DEE1F9F5993EBFF73EBF493F47D7F43FFBC7FAAFF0BFB6BFEE
-      4DD5BFEE7FD4D83F549FF6F02FF383FCC7EAFD2BFE73FE6E7FC45BDBB1FF0065
-      FF002C9FCBE1E9AFFB9E75C22FD137FD97FF00EA7FF35FA3EBFEEEFF006AFEBE
-      EAFC07FC91FF003E9DFF00B9FF005257F51FFB7847F986FD3FABFCE0FAFF00CD
-      8FEBFED5EE9FF726EBDFF73FEBC7FCD53FFDBC23FCD7E7FCD7F9B97FE03FFCDA
-      FF00A2757BF79FFCB1BADFFDCFFACF27F9B8BFEDE1FF00E724FF0039FE6FF4FF
-      00BABFE6E7FAAFF0F7AF5FF92375EFFB9FF53E2FF811FF00751EFF003C7FCD7F
-      C08FD317FD66FF0088D3EFDE5FF2C5EBDF8BFE760E3F9F5DB7E89FFEDE3FF5FE
-      D7E8FEC7F9FF00F1FF008D7BA7E2FF0096270FCFFE2BA77FF1E2E9B61FF8B8CF
-      FF006F0DFF00369FE67FE2E3FE6BFDDFFF0036FF00A7FB4FB70FFD49BA6D7E21
-      FF002B07E5C7A99FF28EDFF6F19FEDFF00D43FEBFED7FD15FED5EDAFC7FF002C
-      4FF2F54F3FF96FF50EB7FCF37FDBC37FCD4BFF00037FCF7E88FF0057FCDAFF00
-      55FED36F6E797FCB17A73F10FF009587FCBD36643FE0349FF65F5FA07FC5C3FE
-      037F9D8FFCE7FB47FD176F7EFF00B92F555E23FE560FCBA7283F43FF00DBC33E
-      89FE63F47EA93F5FF87FA9FF001BFBDFFDC9BAF7FDCFFA8ADF58BFEDE05FE6A7
-      FD5F5FD03FCD7FCDAFF8E9FE1EF5FF00726EB5FF0073FEB1547F9A1FF65FBFE7
-      24FF00811FE6BFCE9FA7FCDCFF0055FED5EEAFF09FF922FE7C3ABAF1FF009D87
-      F2EA0E43F49FFB2EFF00D09FF170FD3FE6C7D7FDA3FD4FFB4FB51FF728EAC9C0
-      7FCAC3F974443D8B7A8F3AFFD9}
+      0A544A504547496D616765EB870100FFD8FFE000104A46494600010200006400
+      640000FFEC00114475636B7900010004000000640000FFEE000E41646F626500
+      64C000000001FFDB008400010101010101010101010101010101010101010101
+      0101010101010101010101010101010101010101010102020202020202020202
+      0203030303030303030303010101010101010201010202020102020303030303
+      0303030303030303030303030303030303030303030303030303030303030303
+      030303030303030303030303FFC000110800F301F203011100021101031101FF
+      C400C5000001040301010100000000000000000004030506070208090A010001
+      0001040301010000000000000000000002010304050006070809100002020103
+      020404030603040706010D010203041121120500133141220651321407612308
+      71814233150991A152B1622436C1D1E172823416F0F192432546A25344E27383
+      647435A618B61719110002010302040404050206020201040301021100210312
+      043141050651612213F07132078191A1B114D142C1E1F1231508526233241672
+      82A243B23425FFDA000C03010002110311003F00F055C98FFEA9C8FF00FC7DBF
+      2F2FA890F8F91E99E54E50A17F0F8E83FCF1A1D3A1E3580529B493E07F71CFFB
+      71D6088A5ACD57075C11AEB9CF8F967C32475935959FE1A9D3FED3818C839E92
+      9688407C31AE8704E0FECF89E927C6B28C45F33FB0F8E72719FD87A1263852DF
+      F1A251750078E703C078E30303F6F9F43FB52FEF44A267185249D31F81D7F712
+      7FCBA1269628E8D01C9040F2270327C7C8F8119C7ECD7F1E909E5591F952E17C
+      B006403E20E73BB249C1F11FB31D249ACB73A504590BA6A58827CF3A10D83A64
+      0D30743D24D2F1A542636E1BE6F0007878AEBA67D27F1C759583CE8815878871
+      B481B8138276E8C5723D5A8D31D0C914A073146A5700646E603680A08C83B7E6
+      607D4D91E40E99C7484D2C4DE891126C1A0002E4F89C64818D7054F893E23A19
+      FCE963F2ACCA6E0085195276B47F3330C691E876AA839F2E92FF008D17C85A93
+      D842EAA71A9259F6B29F02BA0642463C34EB22687E74A4242606DD376511BC09
+      6076F9687208C698CE7A583134A28E02360085408AC4B7F30C9B5886D4FA50A6
+      4E0680E3C47407CE94452A90B073A02769D09318F1D02AEE41BF68F8951E075E
+      927F2AC36E344A45DB52AAA59F2A183A845D9BF0401E2483824A8F0EB01F1E14
+      B44ED121270E7019D77EE5EDB11A9050A92DE80463CFE18E945A92FC6B230A42
+      A25C209A4924529BBD2511B0E83F8010E34DBE5E7D213CAB3F7AFA217915880D
+      1A9DCB24AEC00DFBC1DA10150350410C3047F9E7EF4B079D262162C4F6CB024E
+      D700FA9351AE49507F8893F1D4F4934A2888A9EF788318D3685EE6E62D191BBF
+      80A1F1D8C00D37647405E385185BC72A77878E0AA80854708362E5B6124E9210
+      2269373608DAC060F9E98E9867A7554D49E9506EE40A9DB4915E3DB2C8920638
+      DB908DDB0CCA8D19F15006DD4E410233BC78C54AC6B36A7BFE912CEAF334A8FF
+      009A534088F85DC6593B0A0C87246CEEE340304839C466CC05BE3E3CA9F08795
+      4B389E0DEE4491832F66506358E0569AC82AB119BE9D1236768E4814B48A4282
+      07A9B0A41879738426788FCBF1A938B6E725803FE3453703347223CF56254D85
+      6A0950C35AD2C3EB90E678A0AD6643F37CC1E473E25B00A2EE5585893E3E5F95
+      C53A76E446B1F2F0B7CE0536D9E153B529223AFBE24949DAA5ABC6F21AEA0D71
+      A21FCB2E4E8E49F05C825E4CF7B5FF00C79D466C169883510BFC4BC4CEED0458
+      484EC87C238E3C2A45208CEE21896DCCDB8B127CC75371E59BCDEA13E3239530
+      D9E3E548923915D4460A84711862EDE2241B10BAB329CB02C3C7072465F5C809
+      B5472A408E54C16EA08A35EE1320760AC54299D0A003C49F43F6B38CE7207EDE
+      A4299A6D840F2A8D58AB99488D9C0639877A84763EBC091F48C0386CE0FF0089
+      CF4F86B4534473A0915D5987AB2A5D80640CF85F01213E9D09F50D0F444836A1
+      208AC0C2EC57D2493A97074C15CEE62AC51D5575D36E83A4FDEB2921558B6819
+      B6B0EE9500AA1C6594119190DA78759316AC2399E35F440547CA8A7018124920
+      8C1F53B1D8C31E5FB8F4BAA7E54278D2AB16D0170C0BE8B9C787CAAAF92BB519
+      BE6CEBE91E3AE509BD645ABE9502527465570A6420ED765C7A5A425772823CF1
+      903AC91145C0DF857DB019B5D07F18DAAA150291AED190A7D1E232C7F67483F5
+      A13E740951B8AAB1DBE64EDD4E9A13AB687E1FBFA59A43316A45A2EE6FF35400
+      3318CE1400C71B97D44939C67F6F974B3159CAF4298DF70656118744232A1800
+      72362839CE3035F13D183594832EE2C3058905936EE1AE769642C0165C27F8E7
+      4E941A482450C5082086CAAB634048CF80C30C007F0C8E8A9381F3A41D307003
+      2B05049DA01C6DF01E646BFE1D108ACA44E7E014FA46479FC0907E6D4673E67A
+      5A4AFC14311A0DC4EA4FE3E67CB19FC3AC3E3596A49C37C464B13BB1A9234F1F
+      3183D2834B4318BD5E7A6873A6B8D08C11A93D14D0C561DB0327049D4635CAFF
+      00BD9C60E31F1E9413C292B1119CE319CE9F86A3E1E0D9CE9D64C5679D606218
+      F0235DC4632718CE9E791D10359CE8465D7C3F6FE033F3675C6A75E941E54943
+      94D7C377C7F0FF000D4F4B3F952524E03786063E03071839D34CE7C7A5149489
+      D06304671F1CF963C719EB297E75815CE3503FCF393820F974B349537DA7F1FF
+      009171F32F8FC3F6F456ACB54439400727C89FFF007FB9AFC4FD449F0C7C3A1B
+      D67EF422AF8F8FE1F8FE1FB7AC9B561134A0181FFB67F6E3CB19E9294567B09F
+      2F0D4FFD1AF865BA49A503C6954503C41F3F21E38F4EBF875914B726D4BA2138
+      18D304EA3CBFDBE3D0934B47200352463C318275C633F1F13E3D09A5F3A25173
+      83E44EA7183F1603525B4F3E84F8527CA8C441938F86A3E3F864E06001E1E7D0
+      936A5E546A4614007427046A300820EA4F91F3E927F2A5BD1118208C8F33939C
+      1C9C1C12703C079749C2B083F8D2C63D001F2E776146A07868C739C92339E926
+      F583C795671A005411E200D339C9D4E7C33E233E18EB09F0A5E2629C634D0B67
+      2745D36AE1864FEEF23A6BD0137A21E3450DEA01DC41F1DA08520EE390DB3043
+      1C7EFF002FC049AC834AA445B01429240195C0014027C86575D3F123C7A49AC0
+      0C5EBEE0E3206DD9E966C11E1A052467C3F6E0F8F5973C0D29F1A11D58B963AE
+      490C0606D2146031C6D074FDE3A398102B2950996D40F50043290407CE034600
+      242827206013D672ACA2E38DC618AA10ADDB942B2A01F36E28F8C606B9C03FBF
+      5E80C52D1CA3726AC590CABA6922A81EA2D950B8C9C8C80376A3A1E1F9528A2E
+      2A8645DACECB265CC7919CEC3E94280EF02552350480320E08C7484D17EF4518
+      7D48AFB90C6A870EBB54B2042C8854966D09F3CE3E3E2724F2AC8E468BFA6FA7
+      318818440A20954248F206462AF2146C318F71206809C63C73D66A278F1A48AC
+      843DC903C75E7672E9A86FCB20E7B2AE8B9F5295CE0F811D0CC0E34A2FF2A2FE
+      85410CCB924EDDEB850CDE9620AA82A32809C29C6A30723402E6940B453847C6
+      078D9E352F87846C1928246562AB900B1676047FDFD34D32C97337E14EA891E7
+      5208F8F402191BBBB9C45287564908C6D936801624EE33E76838183AF865A2BB
+      5CD4944062A4B0F0D34B662A8A25990FA62C246AF124EE924849650CFB5C8FC4
+      8071807A8CD94059E752531DF4DE2A7D5383B8B5DA496091278D21825C992392
+      68FB52466C4B16D7768ECC7322B32829E0323760D6E4CEA2C0DAACB16DD8AC81
+      6E7F1E06A7FC27B6E4E5E9086AD5B525FAC9032588E1DD42BAC92D73F517E548
+      A69E0590EE44230A5B605D0EB4FBBDD2E16D4EC0633CA6E78D878FFAD5E6CF66
+      73A84C6A4E4F216FC78C797E152AE4BDBAD62AACBC855B15E7B97A8C4F5A24FA
+      67351E06921E4A546162510494A55030C885CEF3B860083877A034626054037E
+      2266E395E7E7E1563B8D8381EA433201810784CF3B45B88F1A845EE066B05A4A
+      756DC9585C7A50973D885D56CCC6083BE163AE5DAB82C7736E3B988D0F571877
+      11F511A889FD2FFAD516E36FCD01D3AA3C39F8D56BCD519D4AD893B68934AF14
+      6C95D1632912FA1A370CE8EACD22A6E193B58EA4F56FB7706D54B9D0837E04D5
+      7B6A8CC8CF1C8D1068C05569152693615CAC05B3B7B6ECC54B6A43027C3C6C51
+      96245402845AA2F3D31234A6492302456650AECDB593E5450A63425C37A4E0B6
+      9E03A948D6A8ACB7F2A8FDCABDD84058957B6A376D48D4481572993A86918939
+      CE71A648CF4F837A6C89B530CB5814DC30CDDD2C5C16CB6700320C0D5B713AE3
+      CB4E9D047E14111C2916881C9055D5403903E66DC1436D62A3386C9C6E231AE4
+      7593F9D2478563B18003C80F4028C3B782345F986F6DBFC43381D618AC13CAB0
+      48B53B97E504E037AB27D40B2A9D493A8CE9E1F8F59229209AFC5468A1CEE518
+      8D4855392C188C166500E3E1EA3A759491CB9D7D5465525F6614AB7A882C31BC
+      0D8A35DB93AFE18D7A1E74B43C8AECA240B80342C9E850D8DC36027195553938
+      C9CEBE5D10B50812682652E58603920B00401B828DEF92301595509CEB9C7874
+      43CF8521E3078564C37A46BB7450557193B49390C42804E7C0E8464749CE4564
+      4DA86914B336EC82D924E460E49F0D7C327F0E885B8561927CA90646032C006C
+      153FC4548623729C901588F2FC7A2F9521A1DE22BFC246A77781552300EDD082
+      74FD83A29A48BD26EA42020839CE9A96F13807C4E3A51135931F2A11D482AB81
+      9F482743825486C9CE983A8E88456100D7C318DA7000C26753F0D740060640FC
+      3A5BD27ED486D666D7CBCFC3031AE483AE84E31D288A4E27CEBE98C699C608C0
+      03523CFF006FE3D64FE54BC7E7497681D7427C353FE780323A2FDA9222B12806
+      7C173800283E1F863C3F0EB2690D0D27C464B68402723507F13F2F87E3D17ED4
+      941488776A08046478E4796063A514869065C6A40C0C600F4923E1A6817A29FC
+      E928775D723001C7963C3CFC4E3FEDE96C2B292209D7240C9FFAFC753938F2E9
+      6B291F2FFB06BE67F0071FE1D29ACA9CE3F1FF00EC4FC7FC7C3A49A48A88F26A
+      3FA9F23A7FF9FDCD7C727EA64FDBE23A59A58A1318F1C7FD200F3CE700F97495
+      94A2AE0FC31A64EA73F80F219E87F7A2E54BAAEA0FC4F86A58FF00D3AF584D64
+      52A91B6EC0CFF89F1C6A3C7C87F974934A289443A601C0F31E1A78E4E7C3FC3A
+      1245601464718382739F2503F84E49D75CFE03E1D0D2D1F1C634F01E92300683
+      43A93E192BE38E809A5145246A7035C92304630540C6483F88D75D7A434BFB51
+      41482718241C823C01519D30304E3F0CF404D2F1A5D5130D95C781F3C1CE5430
+      3E236B0FD99E967C2B081F8D2918201041D0E72068DF0CE48C67E1F1F2E909A4
+      8334B887014918CB0CF9ED523206B91BB3AFE1D24FE714B4E30AA768A143DC38
+      65385236EE04AE46481E58E81B8D28BFCE9DC53D9B5E546D8D92A407ED800300
+      ADEA0C4955F223E3D37AF90E34EC5BCA944AC370085C3E3054A6BA82F8C11A0D
+      3D2739C749AAB3493F2AFCD4D46536B16D03339192082D93B772E807C7A5D467
+      CA974FE758A71EBB54BA10ECDA76FC4824E49D07CA40031A79F4A727E559A38F
+      8D2A38F200703271AEE059078046625548209033F1EB3DCBE9A4D238D7D4A0D2
+      3AEEC01B0901157763683EA0B80DF213A0CFE27AC2E05AB00E429C61A6EA2328
+      A98C00406643EB001DC7D526D073E441D74D7A0D57934B146C1595776E8506D1
+      88D891DB658B72B26D5570E4E7D246BA7811D616F3A50052F3C31B4A24DE54CF
+      188241DB6D9192BB2421BD2A406040D7F1EB04D61009F3A2608CC81CAA492990
+      1ED46F99E476DA8A8D33AC6A244695861411B588D3E22785247214E15AA4C36B
+      22C7DC8D83009D97ED90FDC68D899460165FF7B21B07C3A1D6088AC514BFF4E6
+      2913E13B8EA4ED7916320120A498F0DCACC42A824E849000C74DB37E54F05A91
+      D1E3B08679217DB03AC48B2832A4C15374A24788C72B0035F4C91E03601191D4
+      7778B037A795493CA2A6353896091C8C815477279208E388C211F64C14ACB0E1
+      59FEA57421D7D4BAE49C437C9F9D4A556A9EF1FC7CD66C16B0EBB0BA7D4BC0B2
+      2157AE3657DE8BFF001116F751B4A96291F8E4F55F95F48F4FC4F1AB0C23534B
+      7C7C7ED56C52E22ADB492C224D259277DA57AC962093B8EC6282BBC4D345057D
+      A7B9F9AC32E8029070BD6BFB9CC71D8981CAF1F8F9FE1F8F8D6C7B2DB8CA6101
+      262F69F97E1F3ADC5FD30FE9DECFDC3F7A91253B5C44954F156805696F89A47E
+      5619549E3E7816B4038B1571146CC0C8C542FC7AE49F70FBEB1742E92CC195CB
+      6A58E1FDB1008324B4F2AEA3DB5DB7894B752DEFFB5B6C29AC93312259470817
+      58F0169AE96FEA07F411ECFE17DAD273DC4CF071ED578C78ECDB78EAC503F230
+      CB563A934A2C989DA3E431930032B11BD1509F9F83F697DD8EB89BDC38BA9A64
+      F6770E5B186E271DEE00B85B88240BFCAA7F47EB3D1BBCB265D826D460DF0128
+      141328016698D5740349274A995258063A787DEECF6857F6F53B2F6ACC11D8A7
+      C8B714FC4258A566F5882016775D88F7AD494E85678C2A3C41A39A43BBD2BB0B
+      7AF3A67516DDAAB2495650DAA080262C6C2E66E0DC0B78D681D6FA5E3D9338E0
+      CAD116323FF206F03C238CCDAD3AF5EE0E1525A625FA468047141DC58CA03316
+      370AAC4923190CB8854B39420AEE662CCC00DBB6D9CCC4CFC0F88AD0B73840E5
+      68FEBFD38D5657A91B73CB3342890C4E66648DA593B491A80804E4E42B7649C1
+      6054B10A3E51D5BA64D23CCD55E55926D510BDC70B36A54488931453480F7554
+      3B9642B12908F12EA742490720E57C3A9B8DEDC6E6A1645BDEA232D50BDCEEC8
+      D176DCA011C69ABED2EF1664902B0EE160DB72E58698F0EA487A659799A61789
+      23CB32AA3BACBB807DC3B8AC8CCF82728630E001A920EBAE7A7819A6CF1B71A6
+      C9502B9653B1C6B0E5B63A8C290B95397704F9E483A1E9C07F2A0223857C657D
+      24DCBB98009824055C3962FA1C00A3000F2F86744E1F2A48B4D23B57B8240402
+      768C0076305D32FA85553B324E7073D679510AFCF0B93BA588472AC8BDB54C32
+      B0058B0750BBD4227ABCFC0F875936B70A0820EA359084B18C111BE64DA4C7B9
+      DB38273182AB93B5B18F3603A424418A5D33C2B2347298018E71901B2090B92C
+      411A8234F1CEED3A1D706974CD2269C6A0AB142A572A819BE7CA12C599548076
+      E06BFE193D67B937A5D1163588A7E3B4A05C90577100161B86431573DB61AEBA
+      E064EBD297B5E934F3A1A4A4C034ADB4A06283B6BB72C738041193B81F890479
+      E7A20E0F0E349A68668088C13938D30A17B6A468005C8F9467F0C9FDFD1EABF8
+      50401C68592253A6D23C173B401E9D7030063D240235FDBD18263945244891C6
+      82963555C8037038D3E5207C46849D7F6746A69083C684ED918DC0804A9DD8D0
+      E012307553E47A29A13E7493236AD8CE34DC149191FB34242E35F1E979561F1A
+      43690430D73819D07C1803AF8E74FDBD2CDAB3CB9D28CBB770D093AE7507CC1D
+      07878E7ACACA40AEBA6E04E06318C7864E47C7C7A5A43E74848A41F50FE1C606
+      01C8F0CF8E01F1F0CF443F5AC341B6AB9C8CE4E7392C3CF3A674E8BC4507EF48
+      96196D343A609C6303035F31D60ACE543B8F319001C7C40C03A7E2A4F45E5591
+      6A18E46080353A7EFF00DFA1E96C6D49483A95F13E392703F0C69E7E1D2D6524
+      C34F2F0D30079118FD9AF4A3F4A4E1537C7EDFF91BE27A58FDA96A23CA0FFEA7
+      C963C45FB99233A0EFC9A790E929450A1725BCF1F0D40F3274FC3C74E93CF952
+      F2A54671A6A4788D0FC7271F0D7A4AC1C689451E03F664E70069900FF90E8669
+      478D128992A491A671F0FF004E00C9D3F7749F2A581F8D1691100019193B403A
+      E727C7C74D0743C6968F5830A4684A920FA7C7C01035C8DA0FEFE8241A5F952E
+      918F11E9523F886EC0391AEB904E3CBC3A4ACE746A2100E18EE3B4363072157C
+      40181B3C8FE3D079D2FEF4B22924E00201C8036938009D093FC59391E7D2528F
+      2A5B1E9C8F491E055986DF33E9CEAC7CFCB3D67ED5914B463E11B9DC3E5C0382
+      4E1496D40DDFE39F0E924560E34EB1A062AA502E18EC5C6E0A33965D5771C30F
+      50209C74D92409E545009A778291C336D529B9779DA000E3395F4B6769538F10
+      00FD9D34CFF9510069C3B0D2AAEE661B00501B38F5B632A3042AE3CC91B80CF4
+      1A84DA8F499069D6BD277C6E5EE139CB80E0C8031DCA307046E6C6834201FC4B
+      6D9072A7740811461E2669DD563492465CB3210E00C7A917D232CC003E3E7F87
+      49EF01734631DC0F2A718785B0ADBDD4C6C7D2C862DB230200C82CB8890B6012
+      3C0918E9BF7872E14BED15F952A78965735D8493B1551B63C226E723602406C0
+      DDA609048D74E88641C684A088AC178A6323058B287F3E54550AC8015C1DEE83
+      63B14074F1CE9F0E8CB88BD36169C3FA7B3405E389A30A4C4EC6290924329632
+      BE91C25E338C6068BE39D7A0D67F0A2F6E6FCEB28B8E224C855732A3C8639F2C
+      93384932DDC5D854A38043338DA480739E8B5D011E1C69BAC5095973B1A56DCD
+      2CC584A5A30114B4E5D808B6C83CB27715DC71A0E8F58FC2920F117AFB024D24
+      BBD9C11318ABA17648845DA96B60A165EDC7201285562DF2B1C9040C918149C4
+      D1F56169A515E3DE4170B59F6B64AA1292938DCA638D981271862060671865DA
+      2E7953800222A75C5D0826ED0949B0B3CE26B5F4E1E36AA5C960C8ACC5F0D1CA
+      572744936819F1EA36473FDB6A7F1A8E7C2A635B865882B3DB826B49205531C3
+      5ECFE5CA424AD3CCB2D88DC20DADBDCEEDE75627A84D9491C2054A44837AB2B8
+      BE2C7211D1962E396768E93C96A430CAC97C8912096A88628C46F376D036E5C3
+      EE3B8329049AECD9346A04F3B558E2C61F498BF3F3AB2385F6E24F2134C50897
+      65686D3356864AD207AF656C5A8A4BE9C771DC7DBA8A1504AF3A9770ADBCB30D
+      D539F72557D5AB99FF002B4923CA2ADF06D831F4C5809F83027F1FC6B657ED27
+      DA9E5BDE17AAF114784839D558E7E46C528619C3F0F5FE82CCF6AC6EA6216EC4
+      D32419193122E36BB1EE2C7CF3BB7B9B67D2368DB9DC64F6C6A5504903512CA0
+      0BDA6E7CC9E5C27A276BF42CBBCDCA2E9071904F188254DB971B47E42BD267E9
+      AFF4DFC67DB1F6F719CA59A8879AB7C371D14F72C44F25E696ACB3355B161CCA
+      D5CD81038CAAA845270B8C2F5E14EE8EECDC771F51CAF9B21C3D2F1652E1CA92
+      A18C045511A5B535FD6C01D31C5A9CEFBEE9C3B85FFF001CE973FC5C0C55D811
+      FEE4280C0DB5406D517E1E22B602DF1BC27BAA95CE1E586BDA5B55EDD735A54A
+      F2453A488ABB4248243623CC986D3231838EB467EBCD99B6D91717B7D4864CBE
+      DA636C60AB6A5F6F1BC29C8EC496542D05FDBD04410C9A6E0C3D4BA0EE71F505
+      2C9A194C8D408E333044481F23322BCDFF00EB5BF4E27ED77BE798B0226E5139
+      EE495B8BBA8B4EDFD3D8BB12D801D2752F3AD78A0EDCFBA310C64A7E726D2BD7
+      B4FED0F7D2F70748C784BA87C2BEA82D0C079F8FC8CC8220D758EBD876BD6BA6
+      E1EE1D9E2618F752082A3D390101ADFF008937598B1041B5F98BEEBF6DC5C61B
+      85E68A6B8AEF5D6A8DAB6C59B22A4ECA22ECC7F5102C31CC03D7FCAEE460EA19
+      9E4F4674EDDFBCA34D90F3E5691E36E5C6FF00B0E3BD5764306420F18E1CE4C1
+      FC6DE1CFF334DFB8F89E368B44B53EA245B55699BF039D2AD892101E33384DE6
+      45983394203281B75CE5761C1999FEB804131E75AE67C4A961316AABF95E3A78
+      64B0B27737C6EDF5063291B3449176CDA0373B14B2B82421C6C1E9C93A5962C8
+      0C01CFE3E26AB5F1DCCFC79D426DD5924699D13EA2248F699F091A92542B3471
+      689BBB8FA281BBCFF64FC6CB1E06A332C5C70A8DCF4A65CE1CC641D8C98FCC00
+      3B05728DB5F50D9F1C918E9E57113CEA3E904473A649EB482660DFCB0EE91E43
+      958C124841F395047978673FB4BA0A9F9D3645E28658C83AEE604611CE70848C
+      0523E4391E04FC3A534B4A3D61B480A5F1A060429207892A0124B1C8D7181E1D
+      0C9A5000A3A1ADB1955331AB36E3BB2115C80032E159946323D206E18D08C740
+      CF6BF1A5D226D46C34331CD203B543B46AEA9BB7328665407692A71A6350011E
+      1A74CB658226942003CA88148098C6BE08A778CED40DB4EC2AC492C81C8DC481
+      907C074872489E7471062906A6A10ED88019224C8464D8815B744C40F58D4633
+      83A63A40C69741F0A14522D3B8C300339CA97190331EE319C83DB015980F13FB
+      FA3D76BD269E426290B1598B90CA36A9C6DF56C2C307243E0953E1AFE3E5D12B
+      F85091CA82FA3CFA46BE391A83874048F503AA95C7ECC1D3A7357314D15FCE9B
+      2CC3B54A904060A376A58E30469FF674F2B5091A69A26848D064E703C8101837
+      88FE2CA67A78345011CE9B8A105B2146EF1C369953AE012007CFE1E07A3B73E1
+      422BEF6D5F52A4127391953FB06A3C3C33D2CC1A48BD7C78155B73021B77E1B7
+      5CFF0009190C0FE1E3FE1D66AF0ACF3E543C90B0D35C9C6A7193A93E393A6474
+      40FE559CE863E827767C3C80500118CB1F31AE7A202479D09A6E7D08F4124646
+      7519D7CBCBA216B509E342B6E1A81AEA491E449F33E1E38D7A2FDAB00A40A9CE
+      4B107520E8DAF8904E7C479EBD2F2B56456275C0C78F8FF8FCD8F87EDEB3F7A4
+      B50EF191A1F8E411E3E3A0F0F327A5F956473A1E45F1046327191E3AF81C7EC1
+      D152520C00F3F1074CE30324635D067C7A5AC22A7383F1FF00EC3F8FF0FC3C3F
+      CFC3ACA18A887263FF00A9F244E00FEA1707878E2C498C0FC3A4E74726287084
+      F8797EFC804E069F8743314A2297440319F2D3C7C463F667FC3CBA434B145226
+      3D38D4786991863F0F13F87FD7D0933443CE8A8D47E39CF928C7980C48C93F0C
+      7FD5D273ACA36388F90F12319D40C6A41006586078797424CFCA963F3A3E3427
+      00156380FEA200CB060CBA67381F1C608E82963952E9191A29DD93861B71E58D
+      A33A6483D09238D60116A2B0CB81823E51B43027D2A5305B5D40CFE1AF9F494B
+      C295403D3B483819DC01CE73A2E3E07C7E38E90CF3A513F8512A9900AED4034D
+      D93EA67F512EC47CA7E3E583F1E809F1A28A563DC19D770C363780C482149D9B
+      0E0E5738F1E908B567E16A7FAD0AB31DEAFE92AA506091A78123C863423FC3A6
+      49D34E2807E74F95A171203B331B481B6677292300238C81B46ED0FE3F1D3A65
+      98479D18524D486AD1925611B21D02B4676962ABBF719001B9C8407271903E1E
+      7D32CE05C1A78245AA51578F0CF1298D8C292C61A30E1926324AFB6311B00CA0
+      171EAC0235CE0751DB2C0FC29F54B4C54BF8AE1FB4EF3346B952E9047DA4669D
+      A1DA1B6C477E0C71C5E0CD86000D49C751F266B69E54FE3C40B9F2A753C6C8F3
+      1EFD60198C6E886BAC61D93722A24202821CB7801824781C9E9B190444DBE746
+      53991FA7F850CFC4C85DA328D1EF6091B06258BA11E9889668D6585352C48241
+      F1C9E9F5C82278D30C91C45111F0363B91FD446C8B2E18A1DF347BCA9C94DBB9
+      F78CE155D5868146800E89B3A8E1C4501C478114149C4989A412C51FE6096AB6
+      F670FBD9495925046F768E352572083B48CE723A25C9222680E32293978B8E34
+      589503261926291BC5610CCFBA38E791C179D1B0021C02B9DA73A744B9093FFB
+      507B71C685938646EEC2F52D249802381164593BB1310ACC4F6002EA9BC8D3D3
+      EAC9C74E0731334A540FCAA3F2F1FB96CC6210CE6488B84DB3011C70985D44A1
+      B698E495B760139C82345E9E0F4C69337A2AAD055963926AD71E0AC13BE83000
+      5D859DCBE5504453040209283D5A104833088044D1048F18A98D18DE29A08DE2
+      9239258136471AE19A37632AE72AAE9F94AAC53076E06DC8C7511AE0C70F8F89
+      A9481AACCE238D5B70B299A24AF17667B0A5239E49A3478A2B4D5A386288CAB1
+      CD2295593B6B16E258827D55B99829F33533122C7CBF6E756B701C74AB61167A
+      EED58584AF156B9B9AA52585D20964988645961962850B45004F4AF6F2C727AA
+      ADC3FA6660C711C4FC79FCEAD30A1D4345AFC0F01F3FF2F956D27B57D9F272D3
+      07A354721403D29E49116A54B33D0BD3A0E42DDF9E8249544735C9648155A78B
+      E98C6A37A29DADA7F52EA0BB6C67592AE01F12240B000DF85F8199E06B71E9FD
+      3B26E194A806483F31CE63F2F2F1AEFB7E80BF4F31F135792F73F2B4AE8AC138
+      B9B8EA9CC56E4695C8D0F175A6AA69C32470D4BB4A3795D9ED2203DF94B80AC5
+      0AF8F3EE977161EB7BD4D8AFAC23650C8924950324B92AACC11615588B7A9448
+      991BC772EFDBB67B75761B47FF00EE6F0004AB2B684006B578274B1244237A8E
+      960D2B20F49BDD9C8D5F6FD3733B300F04C206EDCCAAD295511223085A2364CC
+      C046858104A9CEA33C1BAB757CBAFF00E1B63BA27A7E1C4603175D6595584A05
+      3EA579740CC749556D426FCE3B7FA167EADB91ED2890C35095989B937074E99D
+      4D1113E15AB7EC5F7F70B5F9A8684FFD52A574E66CD5A16961A76E8DB7BF75EC
+      A03C9894CF5853E3A458A6505D61685A366DFA26BDB9DA1DA6D46EB0EAFE5E31
+      A90A9008617B1E2A4912AEB704EA0640AEEBDD5D87D4B3F4E7DDE2183267FE32
+      B644975C881134FF00F14696D790174260B870E069BB1FFAC7FB3567EE4FDA6E
+      42C7074629FDCDC3B70D2519FE9AB5AB86A3FB9B85324345E4ACE5E28A4CCC63
+      DC07A4499DF1AF5BFF00617798E9BD7B6FD433BBA6C4ED59B2FB992C966C4152
+      CB2BEE300036ACA80E966235473EFB69BEC69D4DFB7778C1765BD24824E954C9
+      8D5B26A69300B2A68989D50A2C6BCAE7DCFF0063F29EC7E5399E039BE29295AA
+      56DF8CB73BA355AF6EB462CC94D28FD552549B9A111EE53B4CA60FA566546532
+      30EBE82F6C75DDAF56D9E2DD6CF207C6EBA84193369983F4CD9871D5C7851774
+      745DC6C73E5199083A8092204192388FA87226D1239D69E73DC7C92442548A34
+      4B2F142CBDA8C42AB1C426EF383B33C848D31646901050956601475D236D9448
+      04F01F1F85731DDE2502447AA3F6E37E7E154E723C6C50491B3C2AFB177247D9
+      815646C15899A449279BB4ED21762C080A00006462EF0E591F3AA2C98E1BC6A1
+      56F8B68115E68C344A67443DDC46BDB5568CC717E6B05FCC002B670A719F1EA7
+      2651350992079545EFC2E11249AB13248AA118C8EC9831A888AB67F2DB0BAA93
+      A8D469D4A4706CA6D4C94B5A9866AEC19F603DD4324322C416400AB29054C640
+      74665F0D700E991E0E86A64A5E8734F78246148F532972415DCA32C141FCBC9D
+      74C671F8670BC5604BD1E38FEEB1015E42B8C22AE768D4AAB32292C4A9009CE8
+      479E47407240B538124F9C54820E1C10563C90FB3552102FE5B6D6316D5CC437
+      365D4B05C8F8E7A8AD9AF4E7B5E1450E3642BD948C49893714919BB51B30C12A
+      B06E2BBB1E2D8181A6707A03914F1A7340F09AFC38B62DB510F709728E8559B2
+      301FBC581CE030C2818C79E7A4F707E144B8E4450B6F8DFF00E5188C6C3B8FE8
+      DD247B76029E962194295CAF8E14F87C7172781AC38F945E935E21C81F94CDDB
+      5F526F11C80E354CA63B8C08F2F31D61CA2B062A1E6A1B51DF6391A6B26B1AB6
+      4786855815DC067C081A8E9C4C9C8503A5B8530D8A6D17AB6A3A9C26739D1546
+      4A8CE55C820F8E99EA42BC7CAA3148334C56EA1D3D581E08AD818C9C01B8788F
+      F3CF5211C536EB2698E4AA4AB104E465828CE4900E4B6E00838D71D480D7834C
+      C498E54DAF03162540F4E32400346008C8D0827007E27C0F4E83028220C57DED
+      E064EEC91865D467C8A8DC46D24E9D67ED4B48CB0952CCEB9F510739383AF98F
+      13E3FB7A5066D431791C28391030C91B883EAD4EBA69A1F2074F8F4E0E3424D3
+      74C18B609007FB31E39F1CE3E1D1FCA929BDC60EAC40D727072C09C8246B9237
+      7442B04D0E41248503C7C4939FF1D0E7ACA53148B60E80903C73E790318D7E3D
+      1509E3489033AE70D8F8671E4493E3D2F0AC8A45C7AB5F9863000F003CB03CC1
+      E941B5670143B60EBA7913E7A672727CF5E9692D4838240231A7F96BF1C79744
+      286A73DB6FFF00A13E27E6F8F87874922B26A29CA213CA7223CCDEB791E3AFD4
+      C99FD833D21345CAD4322E9F1D74C8C61BC3C3C4FE1FB3A1E3583F5A2D5493A8
+      193E93E5F01E23CFA199A2A2961CE4819F81181A8FD9E235FDFD0CD2DF851891
+      8CE1B0738C119C8FF780C65B1AE4F484F870A5161E745C4A70078E4363041249
+      D3E5CE72703FC3A13FA528123CE8E54DBB1B009C1CE09058FC4823E07CBA037B
+      52C08BD1657D2AB82154127233EA6F0DEC3FDD3A7424DEF594A2C5819D4AB1CA
+      8385C8C904364E02E9FB7CF1A7484FE74B16A2121F1D42952C4A282067C07AB5
+      51BB518F8740489A21E3CE89580B361339DBBB421000C376D65CE3F1D33E3FBB
+      A426D7A206884AA373104138420A91952D93B08276FF0009F03903A1D74B1E15
+      23A30962A720B2BA80436AC369C2865390580D49F31D4776A702F3E7536A543B
+      A41550AC8BB1D9723B8EA54946F5EA195BC0000FEE24C4772041A918C70F1A98
+      51AD1162912ED8886DDDD88C799029C1EDB8859F3903234D7E1A75172B9E752D
+      56E16A6F47878A49216382DE0A0AE0F7D103C884C6F1A61A495B07000C798D3A
+      84F988152B1E2047CBF7AB328FB6276A3149156864694589098B68978F8EA760
+      4B25A3146556B4D1B2FAFD7970741D5764DD00C431E1FACF879D4FC5B666BA81
+      A6FF0084471FEB52483D9C5A64EF33B44C4A24CD11B8AEF82156BC2B2956795D
+      7032D81E39C81D37FCAD2B3FE5F9D3876C49E1F89BFE54DB77DB2312D815F6AA
+      2B3CFDBD8EB0999C00E32E5609240060671E075242F52716E782B1F9545CBB69
+      931CEF49B7B76CBEDF4B452C58410F69B10C6C07D3B37A98BC9290A43820658E
+      7E3D39FC9427C66986DBB0E36FF0A6A9B8255B8EF0A9B12B978161B21A10A248
+      8447BD244CA1AC3176051589DFB4EA323A7D771E9BFE94C9C241812479D611FB
+      73BD04F708A50A9A761DA332B48E520745916640D3CA25981511863965CB2105
+      5B0E2E7BC49A1F6646A11C29B4F02D3C8254825AD124511B0D1CF2092C2B2776
+      77EEAC53089E503B7186041C01E3B8077DEBDCD30D8AF3CA827E1609D9614859
+      515CE1E68022A2B7718C222295E191DB60CBAA83A67CCF47EE30BCDE9BD37F2A
+      60B75A4AAD2AC90C4B1EFED15DA8AD663899212C14968D5A311637052E4EEDC4
+      83D3A1E7E748D23854AE97133D8BB46904FAD6B9242F346A489A6902C0457594
+      CAF1C85EBAE0B104875DC48070233E40AA492028E14FE3462E15448AB6780F6E
+      CB2196310490A386691AB465858E3D6468619422DBAB0CA893429FC1234C2304
+      92170B57B8DC28F9FF008FE47FCAACF6B819EC663C7CBFC6AEAF6E53E4695C80
+      BBD7826759E937778F162EF146A222BA5792DC124F46D2CD0A9C13802638DB1B
+      7A6837797136326E471E300FE5C47F4ABDD9ED9CE5009F236E11E1E07FAF8574
+      BBF457F65ABFDE1F7D50F6B1E5DA84FF00575E5546B96268395E12AC6D62CC6D
+      0B2341C8B40653FCC5DAF3194332AA2EDE0DF757BB72F6D7487DE63C7AC10470
+      1E96E44DC102DC8D847337EB5DB98369B0D867EAFBC66F676D8B59506EE27480
+      09044C91369E300C457A8EE17D9BC4FB17DADC7F1DC796FA6E378886268E66C0
+      0DC771F05611A22ED8923EDC2AA114AC7AE140F2F1E77062CDB7DBECBA874ADC
+      7B9D5BAA239CB8F2B65C6B8F24AB654518B50C901C2007268C81D4E8203A2F2C
+      DEF51DCF71F597CB9D5417CD0BA40B2BB92394DA4DC826D73C2B44FEFE7DCB8E
+      ED4E5162E4A842DC1C37EFC75E84115A8AFD0E3D391BF564BA9739BA5464B14E
+      1AA2C53EDB195E682468D4B45B9350E8FB6DC750DDFF003338197296F6B58129
+      1254004291A52FED937D3F513023D3DF6E3B2F6FD15716EB758B214DC0452723
+      68647738D1C63D3859E1CB1C79411015D15D82BC368CFB4FDE15EF7B9EBF3115
+      53CBF236A0E36FDC86BDDBFC6507792DF37C825D475AC6A996A5D903B395DF62
+      7BA649581527ADC7AA74FF0067A736222308902C0B130A08E4D71E16016C2BB5
+      BF4BC99709DB331C3B462EAAEC064D18F4A632B048F4BE35002CC22E3D2B688E
+      C6FDA5B31F2FED6956E5D879B920B7347341308DE5E3DDA6987D34CAC1C4E6A9
+      AC577BEAC42B004383D712EB3D536DD1B6CAFB9DB3E47C85915B5BAE866F6CEB
+      162B28A32F8FA8A864656AF16FDC0E9A7A775F070616DA236304113190691EA5
+      822356A0605802566548AE5AFF0071CFD2756E478EF747BCBDA5ED9A5C7CD258
+      F6F58939D9393BDC7465D9F9193955E3F8FA08B45638B89A9307FCB9EC174271
+      F9B0AF5E9EFB45DF9B8EDCEBA9DB3D4F2E57D9E2CB971292036A900E22DCC13E
+      9982141B9D378E93DABBADB77CF671E9FB8C832773E1C6ED110461C4C80B64C8
+      58B3391964480194E95D4C8C2BCCFF00BCBD9F6B8EBD246D1454638143CAB2D8
+      1716282A988456279D24985767AF245D9810B154976175DC597DF9D27A963DCE
+      10EA7529F28E3E46398327CB9F3E25D77A365D9E76475D304739E111E3CA2078
+      18F96BFF003BC0D6AF66C4A8B12466695454EF9B6E6178AB18994C4599FB8666
+      2482A5181504EDCF5B5E0CE5944DEDC6B4ECF82098F8F8E7502E7B8B2A259EC8
+      2B23D81DE94A491AACD347249556242CCEE2586B1670CAA6324024E475658B2E
+      A851C22DF1F8D56E5C464EAE3500BB426711A088D82097C0254320650CB1AFFA
+      8AB0DC41247EED26E370011C0D4374BF9535C7C7ACC922C8706348D01EC972B8
+      3BF6EF07286191B19CFA8E9F8747EE11C38D00404F9F8D7C8B8D7450DDB43AAC
+      8A5A45DC1E375F4857742E4AAB32AE4876D35D3A5392789A218C9F9453ED2E2A
+      44955C15CB6D67DCCC32F29D91A3AEE0AC776D7F128A48CF8EB19B28E74F2613
+      3278D3E9A5DA90344B2345B7696B28CA7D6AE0C6CABB5BD2A465C69B86875D19
+      6706D3F953E3132B1E62B31C737644CD0AB16DC8844B209518EAA920401668A6
+      0AD8036907E3D34720074CD60C3FDDC2B38F8C9CC8988F682A30922C928116F1
+      26653E81B4E148C788393A103A06CAA05CD3EB80F01C629CCF028ACF33F6DD8C
+      7940A01899D812622AC76AA1C81AE3CBC083963F904D8709A7C6D79FF750A283
+      05259480A11972A55C6F5760A2455DCA770C6D392468318E8BDD17343EC80083
+      CAA3D7E8B889946D507431ED211B5DC8CA71B4222B6E619F2D75D3A958B2826A
+      265C71C387F4A865AA5BD9C18D8247A615891BC0F5157C1CEEC67F7F5393279D
+      4064F0A8E58AAEC31856C06603527683AAB16F3D3C3C7FE8968F4C32902F714D
+      162A22BE83D3BF6ED1938014150CD8CB48C7C413D4856A608136E14CB622C673
+      A6E3A1190060B9D0699C2E307CBC074F86E14040FD68230046C38C789C677127
+      C012079E474724D011F9520F1AE0EB9006E70A0E4781DBAE99F339F0E96B2FCA
+      82688B6E07075C918D437C75DA3F76BD186FCA848FCE829610DEAD4E721411B4
+      038276EBA6069FE3D380914303F0A6B9A323276E3240C9600FE391E00E47F874
+      733F3ACE54114C124152410491920E3F0F1D33AF97596E349CE9275DC751E383
+      8D0646739C6BAE3C7A2F956738A1D86140183E3A0F864923E3AE3A59BD270F9D
+      0EDEAC8D4900E4E4EBFF00574B49E748942723047869819F3C6338D074A7C6B2
+      90287C07803FEDD413F0F0E8A692A778FC0FFC8DF0FF00F0FEDFC3C7ACA4BD45
+      F928C1E4F90C9F1BF74E31F19E5F2D068478F97404C510A412325803919C78E4
+      781F0008CE87A126D34714524603FF0016A4E001B719D09C6A0100FE03A19914
+      B17A3615F1383EA20E7233E9F0006A0900F424F2A514B85F07DBA1D01538042E
+      338D49190DE7F1E93CBC2B3CC53843010327555F121343EA1E9620005BC3F774
+      33E34405A8B854672EA50641D30495C6E5396C86F51C67E1D09F2ACF0F1A3508
+      F53105CAA8C163850E344C26369284F81F1E80CF0ACB4D2CB13B1CF6DDC32163
+      A313E0BEB08A063FD8723A13E147A7F3A5238844EAC030603D5B81522261AA95
+      C123193AFE1D0CD244514A3088AA4191A2202B8251A24FE59DC00D70A7F038C7
+      9F484CD1800D15576C9B130D8662555462524B95192771728574CF80CF4D34F3
+      E14E2F1A93D2844AB1C5B1630B22A34E1553385F577801E901B5275C01A67A8F
+      90C0F98A79402639D4CB8E26378D530C7BBB9610494443F2E5B72BC8C5C920E9
+      B71E3AF511CDAF4FA00A6DC6AD0E0A192D32950D11668C43224A18C932C8AD1A
+      6CB0581323A8030CA06A5B4C755F9F201C6E3E3C2A7625D6E22AE6E07844B161
+      636A8B3BE05766D4A35C9651245B522457795930AA8352E7C4823AA6CF9CAACC
+      C0E3F855CEDF6E0BC112387E2787E3C856CCFDBBFB5577DC36AC45C4A5B5BD10
+      16C0AE2095A10E804933C96268DA5581F6AAA9591F32E7E50CDD6A5D57AE61DA
+      206CE5463E17B7C7E9C2B6FE93D0F2EF1F4E10678F11F1FBD4C25FB676F8B557
+      B34252852746535337144324F56ECD5E7AC66A6F5693D690F73B849451B82EEC
+      88ABD770E768C6E3F3B788041832645A2A56E3A13E058612F7B45F8F88B40F19
+      A693EC7884A2CA996549E58EBA35586192CA48C645590D7ACCBD981965918386
+      5DE405C6DD5A78EA7E98902DCF9FE2789F2FF1AAB6E93A4FABE3E397F4A69E6F
+      D94B5D96B9AE204993BB04894DAADC9C21FCC4922C4874319ECBAB305C38206E
+      2449DAF50D60B4DC1BDE40F8E750B77B0545B0F4FCAFF1E07E751A9BDB0961AF
+      18A847BE853A96ED098AC5355481529DC8E60F177254B9BDF602A5B2019029D1
+      6D137814024D8B103F7FD3FD2AADF6BAA48175127F6FD7FD6A2D738982548D60
+      E3A2963DD1ACED5A50C29E5E201CC3136C69E572C15B6A82B9CA9032260DC4CD
+      E3FC6A265DBE95040E3E1CBFD69BE6F6FB4D1AC30D66AAD3CB341625984E85EC
+      949E6C0609B7290AB1640AAA5C00536E474FA678244831C2A2361E571789A88F
+      2FC6D74359E9F1D25456530B2CAD6A45EE2ED76FA47B2CC61924ADB8129AA01E
+      939CF5371E5633A8831F2A8CF8C0E56A8CD9E3817FA68A9464DB4804712C4D13
+      B169248A368ED4AF2CAB599C062F93DD6241D831D3E32732623E3E3C298D2498
+      02FF001FA54C785A2B5CC11CA91A5A8EDA3CECB1C71D78A392131D786A411A48
+      96ECF79B2B31DDB55B5DA00220E77B18FA63E3F0F2A9985403FF00B4D5CBEDFF
+      006EFD3625B709AF2B577BF24B3B06890E8EB2D682B135E09A499DA28A30C8C5
+      9768542D8349BACF36433788FEBE5E357BB6C447A984371FF4F0F2F1F2AB8382
+      F6C4B2DB8669A2E46BC965E08A6964A30C546EA412D79E49E178237EDD331C49
+      1BF666473DA937480C87AD6B7FBE098DB4E92A01E7706E3C78DED2398B5AB6EE
+      8FB0199806D418B73163C2FF002FE87C6BD0D7F6D0FD364556C0FB8176B98D2A
+      4505841271F2417F8C952ED9938DE3F8FB4E3B0B0CF4E382C48E58CD234A7215
+      90EEF147DE3EF37EABD531F6DE07CA1036AC8D874B36900491AC84D5AFD20318
+      E4BA8902BA477364C5DA5D9E70800F51EA4AD8F1831030F0C8C44925482545AE
+      D3ABC0F453F51BEF83EDDF6CDBA3C7BF764762BCBC720B115696A86B5F57C74D
+      C84614D7D82BE6530959537ED5CB10A7CE5B8DE6EBADF58CB833B30F53636465
+      D4EBEB2CD25D6219FD718D71E96041E242D77DA3ED3C3BDEA8BD4BA88D185167
+      11F4960F0BA1C219D53AA13582AD126C26B8C9EFCFB970C542D58BCBC9F3DED9
+      E7E8F314E07A767899B9EE38D5852AF273A7137DB898EE0B32BCB1C5764B51A8
+      8649E111B12E7AEABD0BA3E4918D1BDBCE8CA483A821E6B246A8600F08244833
+      06BD5FBBDAA63CEAA898D73E1D3220856264A05B921121599020FF007151F50D
+      22AABF6FF39EE6BB5F8FAB37012717C737B7BDC17A0A34AB0A6BC8FB7F91E6E0
+      B36B8A9AFDE781397F70729CCD16AF0D7867966AF25471BAD472B15BDDFF004F
+      DB625C8CB943E5D6818B7F6B2AC0681F4A052092400430FA088A9587778CEE11
+      DA4A2E55287EA3EE410080B2040BC981CCC457507F4E3F7192E5CE3DA9C57E87
+      111D4A478F7782B35BBBC6F21538F45E539DBFC0D48D56855B72AC31B598A69A
+      C3D7D9332BAC98E15DD9D233E1D5FC76099D51D750D406362555892033433843
+      C74FA91402227997DC8ED7C7D47A4E4DCB94CBBE7762C3536952AD9195302666
+      FAD9031618D9171EA2C8A414AE837BEBD8143EE2FB667F6DCEE5AB5E85AA48D5
+      2C76ECD0692A4F5660B204962FAA8AB5C78D77AC9144CE64747DA14E9DB2EB1B
+      9E979767B9E8E71E6DBE1080E20097C791447FBAC5115841D3AB1B363D6846B8
+      7561E59EDBEB99FB57AB7FC969B8064329D3914907C430562A1BD25598285565
+      D5A8792DFD6DFE99F90FB49F71F9236E9725C97B52EF35669D49C5691B95AB25
+      8AC97471CD628C5462E565B4B03453CB889154BC891804A37D20FB37F71B6DDD
+      3D0B143A2EFD71890082AC01D3A84CC0132A04CD86A3C6BADF76F434EA5D3F17
+      5FDA0D7B0DC8D40A8B8249B40662274DC31902F1C6B953CE71B05695008EEDDB
+      15612AF0B185B8D371EFB28AB259AEB1493558C1CBD88F633EECAE08DBD7A5B6
+      7B83914440527F188F03CFCAB816F76C30E4D30C5858F84CF0B711E245537CCD
+      33BADBCD44C8DFF1387B66C244AB1C55C3CC822560E3132EC51BD70A85B463D6
+      C387248014FC7855164C7A8B1616BDCD57D350AF2C6B02D78BBA58FE797F448C
+      A8CDB71215895F710343FEDEA78620CDEA0E451C3CE877E3476E131085AE083B
+      96638A2631471312E3EB5C7FF362DCB95C055C7AB2429E8BDC00DFE9F8E159ED
+      5ADC7E38D2A95658B11BE4B1ECCA2B8460964A85691D262C59D6368C7A751E8C
+      63523A06C809B562A146F3A77ADC64688249173105D9B8867109F976B0DEC739
+      8F182060303F0EA2E5C84F0E352B16224C45A2A49171C1E4785A12B14718FA79
+      02B3C92CC4C49DA8C3B302CDBFD4A00C0D71E198C725AE7D552461BC308B53AC
+      5EDE9EEC6CBF4863EDAA2B3C9BA0051DBB6CBDB0A1E4DD1AEE3939500EDF8F51
+      F26E02B7D54FE3DB97165323F0F8FC68D8B82358C85A3883AE04A5A164065FE2
+      2CB2AFA06D9B2F8D1401A7C6336E6FFF00A9F8FF004A97FC58BE9F55BF3A4DE8
+      2032A430E256694CB12B6628E15DDE023DD23C6AAD90C42E17CBA4FE4C73A706
+      D5A4A8075785232FB7ADC35BB6D0585594F7192400280446C67DCA0A49188D37
+      0604E80FC074ABBDC6EF761F1CA8CF4ECA1351062A23C8F1855DFEA150952D0E
+      F52194100AA4D90022AC6342CA41DC769F3EACF166040D354FB8C27FBA207855
+      6BCBD458E56200926DCE24080EDCA819FCCD8A87716C9034CF56B81E57C04553
+      65486A8959ACC4818119DCEC80A96299CE4B16041C91A1C1D3A988D1F2A8ACBA
+      449A62B55D096C80A416625B5566DE14A8F4F8E73A1F018F027A9686A3B0A8F5
+      9858B6ABB49042EA7F161B8E086DAA08FF000EA429B532C3C385368854E496C3
+      93A64AEE07523235C671E5A74EDE2D41C4D0B246AA75F5AE0EDF1C6E0D83A698
+      0D8FDE0F442F4240E143BC6480FA61C1D540DDFC2A5882028C3363F6FE1D28B7
+      0A4E3F2A6E9540246078E0281918048D09C9C6E27F1D7A701A16F2A6DB099DDB
+      94E4E3C319031A6ECFE3807F7744A6D59169A6D913E23E07234C8C687F880C74
+      E71F9D09E3143BA81A8F50F0C918C633E7E5AE87A507C6B0D0A50FF0FEFD083A
+      78E00C1FF674B59C69230E9939C7964E4E9A78E41FDFE5D648A1148952495181
+      E5E43C3E073E7D19ACA45D3273E27FEAFC0EA469E23AC1E06B3E7535DBF88FF9
+      1B6F87F9FF00EDAF45F1F8507E5C6A37C829FEA5C8FCB837AE919C0D7EA251FB
+      7381A7E3D364FCE9C15F1719F4A9F936FCB860F8D1BFDDF56727C7A6E8A8A8E3
+      0582E30B83F28D0918CE01C13A0F2D4FEDE86F16A5A5E35C16DA09D4B282BFE9
+      CEE7F1D3681E7D61E14A2898909D300E0643105136152C777FA41074FF003E84
+      F8F3A502D47468E57776F2091A6AA02FCDEAC1077608F8675E84911442F47A6E
+      540032AAB80846D0C9B49C14390D8DA1BC7C7A1E735869700AB019DCA09255C2
+      9F32ABE5B376D24675CE3E3D09368E7591E1444598E4DE2471AFE58524101B2B
+      B72720007200CFFD1D2406146239D2ACF96DE57684707F2C29209C6170F9C2A9
+      38F3F1E87CAB2C693472E5B2004DEAA766DDE59CFA594919FCC2BA81A69AF974
+      278D18834F1577965215630CE771609E82005642809656C03AE70C3CBA69A781
+      A35FD6A57C718C1382083A348ECE18A82DB989460BDB75DABA8CE4E0E478C5CB
+      3C8DEA46317BF1A9653C2C90951DC8F3BD3700D186622370BB37B38509B75D09
+      F2C8EA264E15242C70F1ABA783712D58E3608B2F788D8ACC248E3708AEDB1114
+      2956382CB8391E1D54E7FAE79454FC6A3488E3579FB1EC886D4212641343F4D2
+      230967EF24D0CD1CA1FB8EE0B4B22C05CA156270BB70D8EA937E938CDAC41F91
+      E5F07F3ABDE9F93FDC13CBF337F8FF005AECF7F6FCFB65C0FDC1E5B976E42E51
+      A1052A2FFF0012D5AC6C9E2952C4524734C278EA43F9A5094055C6E5CFA6500F
+      9A3EF175DDDF47DBE35DBEA2CCFC0092220D801279DF85BC4576AED538B63D2F
+      36FDB6EDB874D2A154E924B1B9983700490070BD8576BF97FD117DB6F737B678
+      EA668D7A7CCA71F0456390878F8C060D144A67EC6E0AF7963561FF0013DD8D98
+      E2442BE3C1F63DD5DE08A3A8EC59B3E262CC71FF00E80D8EA0485BEA055B4B29
+      5E306DAB9FB9017A9664DD6D31BF4ED64200DEB589025A2194DA4002449064DB
+      40FDE3FDB87DD5C0DCB93F05ED9B7EE645E41522E524B1F4D41EA5616E3A933D
+      4E3DCDC376AD48608C1264AA55493EA2A89BEF4BFBD58326209D51CEDB4CA905
+      64EA061A18FA597506F52F13201B1276FDAE6ECAEAEA9936DBAC18B74EA18A65
+      7F6CAC81E992029209D201326262F034DBEEB7E9ABEE17B2B9293BBED792BC96
+      2A55B13F13341058FA7938FB437CA962CA84686684A878E291E460EC7381E8E9
+      FDB9F70BA2754C43DBDC29127D53120F0B0F3E663E5E29BFED2CDB8C2375B00B
+      97687FB9487123FF0061688F0E3E3E1AEDCBFB0E6AF15FBD2B4EA9205BF7A315
+      25929584B0AD17F4BB6F4C2BF7BEA246468770090336EDAEBB0F47DA759C7974
+      A2C78033FF00F213E579F1F2AD1F75D1326166670638C471F9FE3CAAB5BBED99
+      EACC7BFDC14A59DED52944B505E46DB1BCAD50C0B5BBC21AF30077A03B8337C8
+      AC7ABCC1BC575F49BF3E31E53F3F9FEB54BBAE9CEA6DF4CDB871F2F94F87E951
+      2B7ED66740BC971BCA5AE4248ABA5AA945AAA0DF0C7515D24B307D6CB526AA95
+      D4BA3C4033B8C84621BAB4C5BD50C4E36509E267CFE520F2BFE754CFB0207A81
+      D5E03FADE08F31CF9546EF7B36C5AC452558F8968DBE8E3AE2196C3580EFBBB3
+      F54924C9DE9D24547965FC301769CCA4DF85320EA079FC78780FF1A8D9361908
+      B80A3F3FD7F493FE155BF3DC02A446011D8AFF004F66792082095B90B34D6468
+      9421119510D6D8C725B6ABBBE4782836387713F5192473B0AABC9B70BCB9FCE8
+      9E0A3FA8B3C6D549E5631D866EEBC6D29DD2F73B0AD5A5B15AD468F3CBBA75DE
+      C441217043650B5B87D2AC4F08F8FF002F3B53F831DC2CF0F8FF005F2ABFBDA3
+      C5D88169559CD7887275EF7F4F96DC5247C7D19ECCF4E294D9AD715925A524D0
+      806CA67D33092339330EB5BDEEE158161C54898E2601E0473F2F28F0AD9FA7ED
+      C960961AB813C04C719E56E3F8F8D741BF4B5FA61E6BEF97DC4E2FDB75CDFA50
+      44D4E396C5498492FF0049A8678E4E62D5296CC1162C52282AB02EAC6060E370
+      0AFC1FEE5F7FE3ED7E96D9712FBFBA790B8D412CCC63D2B018B1078A8124B00B
+      C6DD93A0F46DA6CF699BAD7536F6BA76D31EA24CFA8DC22C0E6ED001F224C72F
+      581ECFF667B57ED3FB3B81F6971B3F1DC7C3C6D2AD55EEDD4E3B8C3C8D98D0F7
+      F92E4DE015A29ADDA9B7330F5166240242961F3A7AF75DCBBFDE3EE31E5CAFD6
+      B74FACDC1C58F1EB242C83A9B4C81A487C648244402BCB7A96EFABF77756CBD4
+      7263CD9124E8C69AF27B68202A63106001124051CC805829E577EA2BDFB72EF2
+      CB463AE8ABC972B6ED5EA5724416457A77E6376CD89A4828D3A1327F4A929599
+      CC7399937C0EA4448AFB276AF497DBE35CD91DD8850DA892492D3CCC966BC8E1
+      16E178F6676576EECFA5749401F5664C48A190428051587F7B31C675AE545D4A
+      13FF009148D6C4726FEE5735538DE724E2388F6F7297B92E464E6390E2BFA5F2
+      12F1F5E8A4766E71B7EEC7CC53A7C22F29C5415F8D8452A71A3432DA0E5CA4B2
+      08CFA17A0EC5B2EDBF939B222E20141D4A096B0603492DA5BD47531B81C25448
+      D933E675C8B85E1F37FE409B48B02589373278F80131261DEC5F71DCF76C678A
+      FF00FD90DC03F1EF249EDBE4BDC9CB2705C7435697273F2166BDB69ED3725258
+      96C72A457AF0D68DB7C334B22C451FBB6BD6366BB31FC87DAFBAAC00C8A8BAD8
+      920004400B002CB316220AAA96B696F6898B1405B26B241898306E264F289FCE
+      26B6F7ED0FDCC8E3E2B8CE2B98B3C99BD15349BD9DC7F0627867E12F72DCAEDF
+      74C7C97196A4A3738DE3E9A5E2FC933CA9C71BF6216FA895A42ABCA7BA7A1BB3
+      B65DB84F6AFA99CCCC0F469600862D1E85035E907D222F6DB509B9DF365451ED
+      318DCEB45099131A4E36BCEA6521551E0B2A06F4880D5DA8FD307DC58FDC9453
+      DB3C8EEE3F908AAC713D0E4390827E49393A533713C8D7ECC1DC9C2D9B8AEDB2
+      791ED344F148C1A29236EBCFBB9E9F9361D58ED8311B0DC93EEB82CA54157C65
+      4052A4AE719570BA0601C7D53A02D797BEF4F64FFC764FFF0021D82FBBB27C84
+      874C6CB8CE261EEE369681E948128AB8830745874715557F710FD3FD3FB9FF00
+      6D872F3F1F7396A1EDF91DE6E2287661F70493D8E3B95AD522A125881EB0AD35
+      AB4B2CD1BB61D6BA81EA31E3AC7DA6EEBE9FDA3DD1FC2E94F930ED7242C6E011
+      971866561EE2080AB1E8C50723E81EE647F5C5527DACDFEDFA8ED773DABBC07F
+      93911F3622180C6C500D4093FDC00F4DAF2784135E413EE9FB34FB379DE6BDB3
+      6EEA4104152C43357E165A12457A1E496CB3D9ABCC0B17E94FC50A9382CAD302
+      5E100C65B6C9D7D32EDCEAA9D4B678F7682751FEE9B4458880667CB81E3CAB50
+      EE7E92761BF7DBE5950178401325AF2644006E0DE470AD50E7A93D49F6C76CAC
+      64BFD3C50A475E608E62995A44944A249E5AC6267412058828192CA73BF6DB28
+      64922B9CE7C44391FDB36F8F947CAA07678F496DCF1C54A4EECCFDC8613DA10C
+      6658F699DE086148B65721982AA0CA8035EAC53290B24D8540CD8AE6019F8FDA
+      9DE8FB727FA8EECEAD2C6B07648A71B4B2089D5A74929812C7DE6AC8034B9FCB
+      550CDA9180D64DC80B038F9FC73A918F6EDFDDC239787951B17B521669A1AE23
+      59577013B55881AB0067992C3453184ADAB59010C6DDCC1246E501CB2DBCE058
+      DBF7F8F3A31826578C7EDFD7E3CE9E62E06BC765D55582BAC3282D1C421441DE
+      46924090A0452CAC0B0F12C49C9EA3E4DCB14066F7F8E352F06D4372834F15F8
+      07291A1792484CCCA2768BD0A217D160B0486D9223EE6DA3FEF78755F93782F2
+      4031E3FBD5C61E98D91448926D560F0FEC1E5E6EDA55ADBC4F0C96557B65F918
+      96B4AEA65AF14881D73281B86859533A2E09A0DE75FD9619395F818FFD4C8E67
+      87F9D6D3D3FB43A8658D09E96E420B0BC5871E3F117AB06B7E9BBDF5CE4C838F
+      A52F2125E0D376A1DCD62B1EFCB148F2C15A37823924B69DB284A83BC1C31071
+      AA6EFEE3F43D92B1DC6418D5799B036045C9B88BDA7F0913BA6DBED5F57CED18
+      1753B4C8E6B1C66240BF198FC60C743BED47F6A0F7FF00BB5A8DBE7687F41AEF
+      64D7E456CC6C88822CACB1FD64753B522C534054C4646C48A14E40DE3CF7DCFF
+      00F68BA274D393074F3EF6403D3079998B4CDFC40F38E556FB9EDFEC3ED95193
+      AE6FB164CDA031C580ABE4321481022C410D7310799178AFEB6BF489ED4FD3CF
+      B778EA3C30334A82092ECEE24089EB08C92CAC8844EDDC5915A232C614B1251C
+      8417FF00663EE8756EFBDFBE6DE1010F05F826D0220C1E1C4026B3ACED3B73AB
+      F690EADD176EDB7C27269F590C582F3F4DD6787AA2E0C088278C1CDD202C4C22
+      8D2C24EED0A2AC8A91BF64BA3849A372AE888A707196273A1EBD7FB46950662D
+      5E77DF624C79088B1247E5F1E55527354228660555D2304C651CB36D71AED913
+      0876ED3AF8E7E3F0BCC0EC562D35AF6E3D262A117962DE42E301B27B6303070A
+      C31B98040BE5FEC1D58620789E355B93D40F9545ED0C13853B5B5254805FD5E3
+      BB72E5879E48EA7218E3C6A2308B9A8CDB5404E5542E4EDDFE2030603B9F03A7
+      F8F52509A64DFE54CEE23CE34C000871F3128D8C2311820F81F2F0E9F1229A9A
+      1DA28CE9BF23386F4B161AF8EDCEE3AFC3CFAC14363F3A424560B8058B7ABB98
+      D3192A4E1868CCD8F123CBE1D10E3159C05A9BE58B73104EC55C6E1B491A1D40
+      D9B839181AE833D38B61E74247E743C91A2A82BB7D58CE5750B820E74F4B9207
+      9F81E941FCA93CA9B2445390A843024EE0C400067C41F4E3F1E8C123E5596A6F
+      68411EA001C8C01AB32EA3E3B5B0DD14F871A48A1CC40EE661A93E2C7711E5BB
+      FDECF584F21C693F7A4245234CE3230D907D206303C0F8E339E8856728142326
+      AC54E83C34D49D09D3F6F4A3C0D272A19D7F60FDBAE9FF00667A2A4F9D4D777F
+      FE119FDDFF005FF9F451FB525EA39C8205E4F91C6377D6DCD73A03F52F818231
+      923C31D344F2E54626B08D5B5F18CE70338F83365FFD471E3F11D0922880FCE8
+      D11B2AA924681B1E19035182B8F81D0743334A689500EB963E4C0E33E18CE3D4
+      0E9A9F2CF97433E54B44AC2182ED273B776ACA5405CEE665F4F820F8F425AB23
+      951AA30A983B80C86F94EB9072A00D343A1C9E827F2A21C3CE8A0A30412B9C15
+      5046A720336091A390D8FC7F774337B5152F0E87D4BBD59DB087C410A1971B81
+      207ABA4634A009A5761076970376D3EA2106340095C109A9F981D35E901B70B5
+      6703590491B72940EA81A35C08FF008F79DA58905BC0E1BC463F0E9247E35838
+      D67142186D6C90AA76821576CBB8E4001CA9C85F127CBC3E28C7F3A30629DE92
+      86900C0C87D98DCA436DD01C9F951C28C90719235D7A61E628D6DC38548EA940
+      FBA0B0FDA560E3BC046C0A03AE590464239F0C7CBA11F165C5AFE14EE3602A61
+      C54C18A4E558BAB36D113A6C03217BB1AC88A17787F47810DA8CE36F515D6045
+      4BC641326ACAE3858EE470C32ACA1FB4A8876A4CE3B9DB2EFB55E008B2365CF7
+      15829DD8C0EABB22AC6A6E3F1F8D4C5B011C6B613D8B0A89D25DA5CD77A2AD14
+      2BBA3772CF224561A42C5E4611C81C12B858C649CA8141BF32BA579CFF009C55
+      DF4E3FEE099E23E3F7AEA8FE977DD3CAF09678AA5577D9A72F37EDC8EDD11C8C
+      F56CD98E79D4CC64E5AB2CEDF49CB3B03223C5344BB582A86DC7AE07F70BA6ED
+      F798DDF301EE2E2C8412A08040F022C5791041BCDEBD05D93BAC98F104C6C42B
+      3208B9379BC489927E9B0311238D7AE3F614DFD4FD9FEDEE48490595B5C45593
+      EA1219AB4177F2045DF8A09D629E38BD242AC8AA58790CF5E30C3D77374DE9B9
+      7114C4B8F0B66011CB28CCA54A06302FA4EB1A721D190C6351C278877374F1B3
+      EE4DE6D40650BB9681218A49D505812A4DC195263C6A5D5EE714ED244F6EA09A
+      AB4904F1B4AAAE2685F128612B215DAE4A81A8C00467C7AD3371DE7D37310BD6
+      B185CB87194220B7B8E09666BC7B6A599915048555060926A29E95BE545C8B8B
+      27B4E03290091045B84F2BCFE068AB9ECAF6A7B961962E5784E27923621304B2
+      58E3E9CB623DC0A48B1CD24723AC91C631904641DA478F5B2748DEF40DD147E9
+      790AEEB262C674AFA02B3312C000D0CD8D1419D58F583A7496069ED9F59EBBD1
+      D87F0F719B163569D3ADB437CD260833C20F8D6A17DD4FEDE3F6BFEE0D131FB6
+      DD7DAF3243B235587EA688924B113ADEB601EECB76AD71D888E4EC8B685D8F97
+      3BD747EF6EE5E89A72EDB32EF7A722216C93F4830B0E402AACCEC802AFF73A2B
+      C1315D0367F72D3741F1772ED172E479FF00731423020724FA609124FF006FA8
+      A82200D39F75FF0069A8784F68AC4BCC58E7B999A7B9739AB1C2BF1B071E9156
+      A352CD4ECC9EE56AF6D99B9232895D023C9122A9084967D936FF007FFA961EA9
+      FF00D9C2B8B6710A1B59324C7FFD720FA62FC034F946C3D1FA8F6175B76DB3BE
+      E36CF0BA0E450CF91D8B820AE35C8AB10847AFFBB89D24D6857DD8FD19F21EDA
+      E2F94E478EFAA8A3F6E43520BD62B57EC82F3559ED53410F126F3D88C88C4734
+      B3CF23B028222A23902F5DEDAFBAF8BA9E444DC681EEB10249F100DDF4DF8901
+      440833C4559756EC0C4A85F664BE95D560012B13AA0491E7AAF0470E7AA1CF7B
+      12BD115A28F8E35FEBAAADCE3EBC163927B9C93CF185AF217B73B8320FA590E4
+      4F00569B03D4CA17AA6CFAD2E6921C101A09B40F1E1F3F03C2B40DE743C98C91
+      A498F9FE1FB788AD7FBBF6FEA5C8CC32DCA2D1141DDAD2D4E46B59BCB14C563B
+      B5A2A95CDFA50A9454081880B13061A96EB67C7D5181913F98316E7363FE75AC
+      66E998C0811C3CC137E5CC0FE951AE43D9F256E5ED5A89A2115E9B8F44B3516D
+      5C94776B538D6AE42496E2B15C8DD346F99A18431DAC0A2998BBE0F8B4B13201
+      9E5C26FE17E5C89E750C6C332E5D6A2013F3F0B78CFCEF15757DB7E02BF21EF4
+      E26BD448EE728F7E22D13CD34556068A267AF32D882746AF4E67056BD4914CD1
+      222C6E872776A1DC5BEFE274CCB9D891855099E67C78F3F1616E735BCF6D74BF
+      E5750C7871AEAC8CE047993FA0F01C40E22BD81FE857F4C9ED9FB3FF006AF8AF
+      7088ABDCF75FBA6BA7257F908A32B5E05B11EE86A71F5658E06A3620EFB45304
+      C468233DACA1D7E7A77C75BDC778EFF71D54E53FC3D9B326345605B23185C68B
+      0E8DAB5CE4CCC581C7894E40322FA5A7FDCAEE0DD6DF723B276C1B0F4FDA34E6
+      060364CDFDC5CA9656C6A00F697C5BD40353DFEA54F2B724A34F8BE72A574A72
+      5C16B8986D33D7B8D1C30ADBABCAB53B4D6D2C531282890D595B0EC0BC4A58BF
+      22876EA9932EE31C6657D0E0156F6F221D0D8C329895239055B83732C779FB31
+      B5D8ED70E6DCEEF6AEF9322AE8CCCB0524B147C7AD749578325F228F4AC2E420
+      05E3DFDD89DF926868DBF705DE5E7B16A0E1A0AE92253E1383E1F93BD6B8E132
+      5C0D70F1F43DA11F22D35F922AB1C02A450A9685F2DD75FEDDC4AC9EEE90BA46
+      ABF1665008B5A4BC428264926C6BD2653F8A0AE3C0A980CBBB096C8CD0359361
+      AFDCD22249657D4496040AE70FDCEF72F0BC67353CF39E621E30F23C953E078B
+      E0EC72966C53E461A021AD1F192721EBBD5F9BE5EB47CB95016313C098732C0A
+      57B6742D96E73ED1507B6722AAB3B38500A96B93A7E92AB38FC749E10D7AFDC6
+      5C2031610D90470B917D2A7E5C7F026D5AC353958BBF52972762B71FCD50E322
+      6A30D1B11D686CD49E3B1619390E3F8EBB5920F77CAB3358BC9F555EC4D722B1
+      1C8E649121EB77DCED8B626C9814B6DD9FD448982207A59819C4234A1D2CA10A
+      B0100B556E0CD94645C59587B91613C45F90B4F3371241ADC4FB4FCD41EE7838
+      390C55677A5EE3BF4390E1EBFBA6A7176799E22EF1D1BFD256F6F72BCA2D799B
+      DA66791CB548721242A5E1789A7EB97770ECBF8E993190C0B206D431B3058369
+      755FFF00B23FB8F1E4C085ABFD82E6577DD0CA0018E14B01E9CB24CCFA8C0951
+      A4820DE01248AE967E9F7EF52715EF9A766E7B9E7E7E69F9F47BBEE85B1678B9
+      B919EDF1A9172FBECC538E4AF43ED6B314659E4EC34B4E2CC0AACFB4F9FBB9FA
+      3EE36BB7FE66C464DB67400C21234223874BAC32B3B28234B4860A64150C27F7
+      0F6B2F7076E6E7A3A63C7036F18B1E85C80B23160AAA46853996408523DC6D59
+      240247723DBF7B88F7F7B30B3AC1C9477F8A76B951046F05F58DFB6CD1BACD68
+      223C98658CB9902E15D95DD82F1FE999F0ED7266C59B2661B9DBAAE4C8A033EB
+      3AD551DF3B18006A0463625551203EB7503C19D5BA6F51ED2EE51A3561C98770
+      34399D58C9122410B240905B4E9264A865513E497FB99FDA6E23DA9F75F99FFD
+      354F90A8BCF4D6F9CBCF62A5DA7C6F233555EF59A0F5ED569ECD99A19D46F95E
+      4642D288A56578727E8E7FD77EEADDF58ED7C7FF0020EBEEE33A54482CA0F026
+      FE9B7F6C0611205EBB0F7DF4C3BFE93B4EA8B8C0CB976CACE54AB2B182665069
+      33CC8F4B71102057237DD1C6D5BAF7E51C555E2AA148E735845147CA4949E096
+      C2F21C94D2473CD34762BC90BAC6A2445454753236D1D7A9F679D9554072CDC3
+      CA66200E1C66FF0085AB816EF668EEC34E822FE168993E320FEC6F51B4F64477
+      2CFF004F11185EBD999658D2496C89A38D96428C605077A96050000B26242AA7
+      722CB6EA231AEB63C45B97C7C0A85FF167264F6801ABC3FD3FA70BDAA6F53D9B
+      B7798C534AF34CB0477236AF63E9668ECBC73D989E94B254B26646668D81DB62
+      33B5029CF5072F5158966F544C78DB85EE3CFC0F19AB0C5D1F2BFD23D26C3CBC
+      ED6BF2F1F2BD39AFB065B56268EB23F25591ABD708B02C960C918922AB3816E1
+      568269A20CC91C6CE212E532594F55DB8EB9871ACB32A9BF3FCC58F2FD62781A
+      BEDA76C6EB31D0B8CB00472BF80371FD63855A7EDEFD387BD390B50D7E3FDBD6
+      6FC82B5BB36A1B3C5DE3253ACF06DFA4686BC5277AD89E55EDC81D63693C42AF
+      A8EA9D43EE0745D9612F9F708ABA800750127E64D8471E7F8D6E1D2FEDC756DD
+      E65C38B1333372D264710163999368E31C22BA21FA7FFED67F757DE3C04BCBFB
+      87847E038D92536E2B7C9AB4374BC14F64E9D8EFC2F351687BBDA9220E7786C4
+      9EA1D79E7BEFFECA76F74BDCFF0013A6E419F30907490578922FC9AD266D116A
+      DCB67D0FB3BB51FF008FDC9BDC437EC57FDAC7EBC80985872A4AA4123D2EC1A0
+      93C2BA2FECBFEDB7F6EBDA14215F73F3ADC93B9C24134F626E37B2DDB8A742EB
+      1D736EC493502CDBF58F3B493206DBE6AEE1FF00B1BDCBD4F72C9B0C4B8D45F5
+      800373883781062DC7E55678BBE3A26D329C7D07A6E6CE8A20FBCC2660104E31
+      6D224104C9632D1A4ACCFE7E63F4F5F6738AB068701C4589A69ABF1EF1471345
+      505FA82DC34C71BD9491E58A19A1EE49DD71BD8300155487D15F77DF1DD9B80D
+      9B2E4D0258C9330402757F801CBC6446D0BD0BEE377266C58B2EE0EC3641495D
+      21558A3E82572703254E95D20E910492CC0ADB7F66BEF549F70394E421C53E36
+      952AF667FA4A54A36E3E2A3567558BB0C8D1B7F50486400FA224DAAD2300A323
+      58EBBD133F44D3971331CEFA4126099238692088B5B890620CD73CFB97F6A717
+      6B6C30E642FB8CF95D575B39F70E465BEAE3FEDC89E2CD242292C6B857FDD47E
+      E249EEAF7F4DED8A612C435C89E0AF11731D66990F72C568A40DF4E43E04817F
+      9B9046CC103DF3FF00587A21DBF463D5B398C8E6E60006391800789102019E34
+      7DC3B1FF0082EC8E9FD0F493B96C7ADE6354B5C19025805D22FC3849893C3BE5
+      B8F7865B06449219A32D11795C9DB28CEC65DA5195860E356048008C918F6CED
+      1D5D069FA4D79C7A9E074CA464FAC5BF1F8F9D54BCCC6ACD33B7737658967C86
+      1238F4F701395EF49927C4E807C0F5798254408AD6B3159BF1E755CF23098422
+      90BB5D4BBB019DA770043AE305F240F3C75698C96F9D56E5506F6A88591136E2
+      06753B304A823628C80D9D439C918C790F2EA6ADAA1B2DBCAA297C00C542EE03
+      D2C739380577360EECEE61F118F2EA5E3A8C489834CA543484EA8A32738DCB1E
+      B8C00A4A95246A7439D4F4F036F3A6AD3159489B94B91B42B6B83B883E58666C
+      F89F01A758279D645A6B068F318017019012A73BF0A582FA71A8C79FC7A506B3
+      85092C08DF2838F0504E02360901836721B19D3F1CF974409AC8B5374F0B7A88
+      551EA2A769FC7728750701C1D34F2F1E8C114342F6E31A39271BF1B705739CA6
+      DD35CEE39CF9F4526848934DB622D46D50ABBB3F2E3C18852DE0371527F77440
+      D270A11A12A0E541D0E0EFD00FE1C60E082DE39CE74FD9D2837A5E51CE8278C9
+      393E1E3803396F007F11D283149E7141BA907E033E1E18CE0F88CE87A304D279
+      50D22E99209C8F49D09CF913E07C4F44284DAF52FCFF00BA3FE46CFF00FA3FB3
+      A3FE9597FD6A39C821FEA7C86D2A48BB6356D47FE61F27CC1D4F9E9D35373E14
+      75847AA8046A09C78E327C73F039F0FC34E80F88E14B4E8DAB0326036724003C
+      41190E06747FDBE7D009A33E26950171A924824360AA8C7820C313AE74D327A1
+      ACA22200004A0C95DA36B30CEE53873824B367391FB88E91AD4B7A3630A137E3
+      6BA9232C405F97C341BBCB4F2C9F1E879F952ADFE544AA4846705C020118DC11
+      BE551A1F958F87FD7D0DBF1A3BF2E34A8043A49200C8EE7D44E73A8CB11A12AA
+      17F0C8E860524D66AEFBBD0031276ED3A9233919CE4EAB803FCFA488FC6B01F1
+      ACB246FF0033F2E738F4E30C14B26AADF1DA0E9D24FE5443F4A3231E9746DBA4
+      48C3D44E31EB0414420FC31A6A3F1E84F8D18205111A9428E4296704A2BE8195
+      54939CFCAAE00233AFC3391D21888149F216A7FA6E085DAC6308BE2E546E3B8B
+      142806158939D092C00F3E987A790C11E1539E315F21620A4CBF23A28B0CAB86
+      0E830092EAF10F1F954F90639879478F0A948790E1562F08019646B32EE92308
+      616946186F7025450C757ED2921482723419EA06512205854DC666EDE55B17EC
+      C8D6096BFD223CD1CF3868FBAEAF5DA01B5EB4F6609025AEDDC8D5B2098E30EB
+      E918DC7AD7F7DF4907881F11F2FCEAF366175809C49FC3CADC7FCEBA3FF6338E
+      E2CDF4A8FCCC3466AF2A729C4F23F5B46AF7A28654ECB58B33453C69557E8E15
+      8A343234AEFDCDDB5971C73BCF365C788E518CBA9055D42B344CCC0045EE4926
+      C05A38D769ECC5463EDB3E920CAB12070BF183636000E7F3AF5E3FA5BE5BFF00
+      577D90F6772D2595B86CD1911EC1440931A72185DD5EAC8D0CB0BCF0B6C28549
+      40B955F3F9FDDCB87D8DFF0055E86DA46D994E46470FA631CE4018A32E4862B0
+      550832A2EBF556A9F737063C5DE193718442E5C789ECC0DDD049E16F13208926
+      09B8153FDD2E467F697BCAF5A8ADC7C5B3C73CB118E39F91B562656B492CD1CB
+      2F214CD1778E45236C76D1998AB445536CBCD7A4217C40B49CAAC61A6C6E44DE
+      4E93C61A4E930C49935DABB0BA560EBDDB38B0E5C673A82A0C95C6AA3D240206
+      37D6010665B1100023202D291CE1BEFECFED670FC97276DE9492D259A45A6F2D
+      086C4971D52BC694AD4B22C8FF00501246F547DC79151488B29373F43CBBF918
+      42862DAA042DC5C1820585C8598E0798ABDEA5F6A363D593FF00AF851730042F
+      ABD4C0A8124B20112A4A8F4B6908588D6436C77B0FF523C473F64D6B1C759922
+      8E3B2564E322BB72C49250668ADD76A9256AD9922106F332B08DA23AEDDA7124
+      6EBADF41C685723E6C034FA19BD2405402C0882422A9606740D3165239A771FD
+      8FDF74EDBFF236B99351650464288A03DD583066B1274E82350616D522767782
+      F757B7FDC3145252B5048936F5481E27AD70B26E12AF6A55864261742189C842
+      3E1D599FB81B4DCAAAF7474FC78BA7FA941185359245CAE54F6F5E968F5B3C62
+      816D322B8DF53ED7EB1D1F2B26EB1B2B2C4B02193CAE245C10478834AF2FF6B7
+      D8BEEE984BEE2F6DF1BCABA3CB2FD3D8AEA209A47403EAE78F0914B3C523EF89
+      8AB3C2FEB8F0C73D6C3D1F163DDE461B6DEE647C45FF00D8C7A31CA9550729CE
+      C2C3DC71E90B93284019121961ED9777773747DB7F1BA7EEB226DD828BC31014
+      C855D40902D0C010AC3D2F20456B47BEBFB7CFE9D7DFF3BCEDEDE9388E41BBB9
+      B3C3A70284CB3FCE676BDC0720F682A831A198C9B6362830A4F53FA7F7DF75F4
+      FDE2F4FE81D486E9974ABA65C8C57DCBC80EA54221605575004B00498961B660
+      FB99D586109D4F67D3F3A0FEE6C4CAE47CF1E4459E67D3FD2B95BFA88FED1FC9
+      FB74F27CFF00B0B9DA7C97B5AD4F1DC5E25E1E767E52A5C8F8E7AF62D8A7527F
+      E9D390B0C6DBA5586050CCAEC54027A77697FD958CD8FA5772E218F7FA030756
+      4F6CE366F482CD0C184C301AEE250915B5F496ED4EF2CEDB5D8EBD97532BA8E3
+      CA57DB2D01611F500589E0BA412388E2471D3DF7F663DD1EC6F71BF0FCEF0BF4
+      7638C92E402CF1D56D4B4F9669B8F451D827B51E12CA9AB146B2C93A4F8472CA
+      A09F4EF47EF4E97D5F60BBBDA65071B806E44ADF98E3C3D530015B8E351F7BD9
+      7BED8EE8E0CB8CFA0C165921AD20F80BDB89BDA4C5747FFB757E8C7DD3F74FEE
+      3F03F70FDDBC0D58BDB9C5F275394E66ECF56AB51B5538C5E2EC7135ECAD9B93
+      5D8AE35BABD968C568DA3718729B8B47C23EF67DD1D9EC3A6E4EDAE959D7FE4B
+      72BED2C92AA8721642EED1A5718D4258B69BFE77C98D3B1FA33F70F5384EA595
+      586D5625F264D23495136F6C919199A06953A753421F4E5EEDBFC6701C518D6C
+      7135A63114A1C6CB7EBF1C152B491A986BAA1558114B0D8A7B51B061EBC67AF0
+      CF7063C07161DA62CB8771240753931E529EDB14656F56B50D914E440344E220
+      A64758078F76FF004CDF756DFF00B8E9B8C98F54E4C811B219604EA699D47FF2
+      3EA611F4CC57293EF87BA3DAF15AE59B91B371ADDB4A83935B146F546BAB1BCD
+      0DCB5C44B144B7EFF27579589AB47F4CED0DC6AC66D37C910D87B7FA6EB64184
+      1E3C6C62C38C88D0260130622C397B83B37A4F57DAF48C6D81710DB63D7ED85C
+      8ACC3500C98D8025503E22327AD75E1F7063F569573C9EFBABEEBE6395A697F9
+      26A54295CF6FC02C4FC1367DC76789B72729ED7BB5798E392F575BD6FDCB7D3B
+      3CAD4B02378CF1E2D09923691BAF41F6EF4CC1B6FF006F182732E4B06FA350D2
+      E34B41808A65196675692A4815B36F316324E839062D44ACCE95B48816F48220
+      1F389832345FDEDFD3EE44D6A7FE8356BD9E3B93968DCB56AE1AEDC8559A09FE
+      96BD0A54AC0ABCED516CBD3AF3A57104C5E58FCE497ACF4A4CB8DB427B8C432C
+      80048520892C4894310E4169100F82EAFB90565DC0E060C9E23C07FE5E1C2FC3
+      C4D0134B5ACF3362F9E3691E6DAC47CC7D2C50209B9CE46ECA92555DB4EC41C7
+      C7CB25041F5962762F24AED21FA899813B5E965DB8C7ADBF8F05249FA5458F11
+      AB4CFD21470007A566AB70E35CDB8399D4065331E337038C7CE4F3B4DAAD2F67
+      71BC9DAF6EF2DCCC9EC11271F1F211C9C9735C2FBCE1A8FC77F51E56682B1E72
+      B4B62CA72947949DCD7ADFD3567DB10732AC2AC8E756EAA708DDAE24DD819341
+      011F0933A544E83034951EA6D71788D50456D9D298A2127042161EA0C22E4812
+      24CF8580B7E9BA7F6FBDE7EE7E1FDC5C354E423F67C367919384B65E9B2DCE62
+      CF0BC152FF00D50FC6F38397ED7177E7E56C19AB8B724127D55C56AEE9223C7F
+      4FC7BB8BA4F4FDC6C32BA7BED8D750F559433B0C738F4DD42FA58ACCAAFAB558
+      EADC7A6BE4DCE49C79190AAE40A165492CACAAE483EE0224E90AC04692BA4833
+      DCBFD25FDE5ABCDDC96DC9CC71F1D8F70F257246F6655BEB6F97E2786ADC7D8B
+      9C7C92D00C070F529D3ADBC347145258584E4A842ADE4DEFBEDC1B67D6F81F2F
+      B78E55CCA8D63FBC3820EA420410781E60DF8BFDE2ECC4DD74943B5C19186CF0
+      A06DD32808F9B26455605C0FF75F296886665C4CF10490C17FEE3DFA538BEF2F
+      DBF8F97F6BF090DCF73C28CD56B41C6C97AC5AAF0509331D3A146ACAB564A3C7
+      CD3DC375A56090774B911C7B0F47FB21F7313B6BAE63C4ECF8B6597EA460AAD8
+      D6CE1B2042C9EB9246967D4BA012AD6AE47F6D3ADE2EABD3373DA1D6B26318D6
+      5B0BE56550991CE9339723299C8E130A620140C85480CCE4D7927F7C7DB3E6E9
+      B725C4DDE1B94866AB79E9B52E652096E41C971DFCE8AB963527543DB962A92C
+      35809217504293D7D36E8DDCBB1DD61C7B9C39B1B63649054DB49E7CC781605A
+      C678D52F58ECEEA5B5DCE4C193138878F50BC8FC8FFF00A481C08E152EFB6FF6
+      7FDF1EE7AE38FE2FDB17B94B16228440B0F1F6EDE78D9C39AB1CA61A92C70FD3
+      DCB893586944610619B1845157DC3DE7D1BA68F7F71B84C6AA4CCB0171C78B09
+      90081133C073AB2E89D95D5B7918FD92D2579723C3883CCF80FD8575D7EC87F6
+      DFF71FBCA4E3F92B1EC682B7108793E43926BF5B898254B33C35E1AD5EA452FB
+      7ACA8AD5E4694189C773D081371D0F96FBB7EFE6CF063CFB7E9BBB6C9BA50A00
+      42E6D24C90328625A041510787122BA2E4DBF65767E547EE5C9B75CC1C1F6946
+      2C8E66FF00485234C719200241242C91D7BE03F41BF6638FF6F709C7725ED8F6
+      B50F71C4B5AD3CFC4F07C1C75CAC51D5AB6035497894AAF60466746B421495DA
+      C12C4811AA79677BF78BBCB71D4C645DCE41B1DC7D3EE65C82016225999E1541
+      D2C5492A804F126B9EEF3EF0EEB1F51CF97A2EC76E7A0AB10A99312C8787D2E1
+      920A96054940C4429023539333B3F6FBEC17D97E325E4E9F0BC536565AD0496D
+      69C914C21779EE568AFD8AE38F8A49198ABFCA03AEDDC3186D5373DC9DC9D7B7
+      8A87739F360670DA175282903FBE2437D223DBE25AFE992CECBAD7DCEEFEDDAF
+      4EC6EF8517D44614285355958AA1F74A8E22E7D2660832349FEE2FEB5F861BF8
+      2F6CDEE238EA42CD180C70D9AC16B57AF21AA2944F0A4A24A6238CA978F79890
+      12211B57AD93A67DB8EA1BB7FE57504CEE4863704CF3049216F07C81278DCD77
+      0E81F637A6EC728DF770E639F7E55CF19967BEB6961EAD5274989366C864D73D
+      3EF1FDFBE4FDF10F2AF1DD68F9796D556AD1F1762C4BC7CDF5D76C7273D5B115
+      A7B3157FE970A05EDC4A23D823605A40D9EC3DB5D9583A61466C63D9869D4002
+      200504444EA2789922E3E98AEBDD23A66C7B6B02ED3A401EDAAA8059575D9029
+      62EA012C635312493AD9442911ACFEE1F7C72FC8869EDFB925BB7A1EE456ABF6
+      A7992BDD9E18EECA52787B70403929E76EDB22AAB981D9776D6D9BEECBA2EDB0
+      2FA7004C66E0C81201816373A62F371A80312264E4DD3616110491040062C045
+      EE4DAC04F05FCBA2BFA119E53EDDE66AA4160F3DCBD5B7C95092CCB3DB99E388
+      C15ED40D35781629A1ECED05000490490F93DAE23F76318FF94C0E8C06D83AA3
+      01E98E2678C8BCF8DBC38B731FBB18067E97B2DEEE198F4FC5B80B964AF16594
+      20982082BC7878153F5716FF005DFCADAE43EF3F3ED1584596A5AB1134D1B4A2
+      BB2CA2A4F1430BC4095317E682373E483F2FCBD7BE7EC2EC936DD9B8069F4BA8
+      3789B6A049F9DB90FC78D71BFBBD99F6BBEC5B746213162551C45B4A5BE7E924
+      F1E27F1E77F31148C5AC4A5E42C2579830EE289597D2B21DCC72E189041DC3C4
+      E3CFD19B4B268E11C3FCABCE5D4720CACCE4DCF1FF005AA7FDC316CC9DA35897
+      60C9C891831C856D40EEF90D31FBBABFDB024719AD477604C8AAAEF0975DA407
+      5DE14AB172A10AEE24655D04991F11A75738FF004AABC9711CEA1F7D08DF236A
+      E13D3B8671A1008D339C9F3C8CE3A9886FE5519A622A19746F720B2EB91951BB
+      242EE0BB89F027563AE09FDDD4A4B7CAA298269B8D64DE351EB40EA03361B2C4
+      283951FEC3D381AD7A08BDABF488A14AB81BC9209046D5D70430C0C6BA8393FB
+      BA59936E1591E343EC7CA82C0051AFF0E9A13AE093924E0799CFC7A598ACE03C
+      692D595D7036900314018B8254E300F82950703C7F1E8FE543484B0A30625B05
+      067003B06DB9F56E03D2307CC790CF4A0F871A43C6395374E8340DB491903D2B
+      9F51CAE40D4B020EBAE8463A2069081C0F0A01D4AB64CA98DAA4E0636EBF2E0E
+      4939D7A5E73159626D43C9AA9DE324AA843A11E7927D5FE96D7A2159E429B274
+      553E9520E84671A9C6AB80028007C3A21406E6809867465395D00D33E3820F89
+      D07EFE8C0AC228378F2080A00D33A69804E491E248FC7C7A298E3431531EDB7F
+      AD7FE48C7FE0FF0057878F473FB527E5C6A31C8465792E4B70C837AC80106403
+      F50FBB72820E8A7F79E9A247E34E0AFB1C4D90588607572492BB079B12000C33
+      AF8FEDE828E01BF2A2A252E49DA1630ACC08C30DEA016C93823232479FC3E3D0
+      9B0F3ACFDA8C55033B5F43A065553B83EDDC7D67465C0F2CEB9E92B39D171A80
+      D1E31B9F1B71950AEC0618B7812C307E001C7974247E545C0D1312AB31C85DCE
+      029C0C28048653819008F1F3F0F8E9D09F2ACF9D148BEA1B5416CB60E54AE871
+      E918C8009CE71A13A7406F4605FCEB168D867E6DC01553B73A20C3952403A124
+      9D35FC4F59CE96954CE4392485F4E4687462EB938272431275CE060F586F4910
+      695F5A090282400031DA7210E5CE5F01C0047C474260C470A5B85B71A352258E
+      3F549B1D8E1D446809646D0AEA0E50B1CE318FF2E92D4BCBCA9C62859CA90C85
+      A40CECE411B2389546DC65546C0A09C93AE75F2E80DAF440014F5C7465E70875
+      44286758896DEAB84F46E072FB40D4E09D7CBA65EC269D11F854DF8D60B34243
+      87D985061086672DE9664C1091343B46A3E61A9F8F511EE0F853EAF161C6ACAE
+      22BACC55176B4B264CAE61F4AA90AAB1C723AB48926E9F57214780525BA8197C
+      6A6E2BDF955F3ED04969C912D620A6E862B4CB318FEA732B6C10B302B1B6F8B0
+      0291BB1BCFA5B068B77A5AEDC6ADB6CC55BD1C79D6E2FDB8E4138A9262F5A95D
+      AB2D2411FD4CF69BE9E5535838856AD8EF03360891BB622630A85C6D20E85D7B
+      6E33E989D41B9479F191CB95E6E7C6BA676DEF3D8D4C0482238F3B70FF001F95
+      7ADDFED63CDF25CEFE9DE5A5CBB44D6389F73587A721B54A766E16EF17C5C546
+      DC4952462BC6CD253956BCC5151BB6510304627C1DF70F6FB6E9BF70F39445C7
+      872ED7536662C17190C5326B04FA182B023205721B48652AC454BFBA28F9B2F4
+      CDF9D675ECBDAE16271E47710D1A58819402A0C8104C4AD5CFF7A3DB718E7EFF
+      002A3EBF8E3258AE935AE26C4BC572A628B8F95D9E4E5D78DE4A8BF1D6120576
+      A8635B467DB20FCB196F3EED72603BCDC62442D8C6770038836200660BA4066F
+      A8C00096240135D1BED86FD9BA461E9E7DACC02310B95465C5272010311C98DC
+      6452C5465D4716894FACC2F2F7EF0D1B5EDA9E4B704C96F8B5E42DC8A914923D
+      81CD2F1546C42B6AB76AB4C29DF799EC47B26432319919563872DD37B7DF0665
+      1888D3B88009E5A64831C6E38495F0E66BD33B3CD9F42EE0D98A02010386A610
+      1B84AE90A47010AC1BD640827B53EE95AE212C49ED89C3D6B24C7C8727760AB5
+      A3E2A3B8A83924B46DEFAA94679645111DC6555098918CC98B0DF76F0CE41DC9
+      8C83828B968E11179F1E5E420D39BBCCBBD51EF2AB60D40804910EA645D48E1E
+      720CDAAFCF62FEA22248ED0BFEE39ABF332F23578EB3CB35B8DA0B66D5B4547A
+      4C2C33D5278BE382C53C5B9AD1611E06C512EABD57B3B2654D38B1EAC3A4B410
+      6D004C88F137045871F2A9CFD0B63BF4C69936F80ED71EAF4580061F4088FF00
+      7159DF5693014824496F4EF07B17F593C55389A83879A186586852BFCA5A9DD9
+      077D21967E42F5686DC3794C3B1E32AE8B8676064182BA267EDDEADD3B3FF2BA
+      4E57DBEE029FFE3620E9372AD054B0B45EF373EA36E55D73EC262EAA46F76F95
+      15DE59D31AA805A25531AB15D064906CD30A069FEED90F66FEA63DA1EE8E462E
+      3629D1648EBCD34F225A8051927A912CB2C75E5B6B59946C573146BB895F1030
+      33AEEF3075CDA9C5BA103DB652C3FF00200D954696F6D78D96CB3698AE6BDC3F
+      63BB87A26C9B7A575632EAAA3492E158C02C10B0E30198C41E1378BDB8BF767B
+      37DE70DCAB15CE32FC70958EFD4B0B1F69BBE1A14F45A530BC3392705BC412A7
+      5D3A919FB930753231F55C2DB77460FA95B4B3B15D328DF44EA1EE38C875013E
+      A7313CCB79DB7DCBDB5971EE1F1E7C391A4E37526469B9BA5C15E71F3E155BFB
+      D7F4A5F63FDFE0C5CB7B369BC32B432762B2410C6258D6DC956686C3579E7A0C
+      5EDB48457923491802E182A8EB73DBF72F56D96EBDAED2DF65C9EE14098F2185
+      1A958A7B99002B39902C0960ADEE41034AD5F74FFBA5DE1B1C5A3779716E4A82
+      03664D6CA095D405C4DD78B0241B820926ACEFB7FF006D3DA3F69BDBF5F81F6A
+      715C771F46082343254A95EA43257A6249154C68EE91C1556421413B428D7C30
+      2B3ABF706EBA5EF5B7FBBCE9D437FBA656C6D18DF132E250D90C6A6B06366761
+      8885672032B2A6B9D7FB8BAAF776F066DFB38C49231E296231EB22CB61258DCD
+      A493E72758FEFC7DC3F6F8ABCCC7665E469F2B4034BC3F2B5A4AC9C33C6EF5E7
+      53882392E4F296AD2D6581DE00D38586471BDD63D67A5B6EFAD653D577640DDE
+      5CCF942A00A835C6A0389D2142AA09F4800498AEF1F6B7B33AA637DBE74185FA
+      664B66C4C18E604065FEE21147A9721701C8427222FA559F909F763DD49EE26B
+      92437F8FE3B9249FDBD2F234AB35EB552CD1E6793FE9FCAC5EDF9044B7638E93
+      48BDC6920B26BDF9E408D246A919ED7DB5B3FE3E9F711B410D04C0321644F288
+      131225472AF4C9197A5E25C081DB6B2CAB918287518F81CD0482C418464B3630
+      85943166AE767B8F95A3C57397EC51A7C8FB861ED5C9E85599E6B069EFF70C36
+      CD4F737B9B8A9786BFB6945337E7D14A644F24888CD1048D3B6EC11B26DD0E46
+      C7880612786A8423D18CC8BC5C316B004C19269374EED8D83E46F7190C951713
+      E1A81004DC483F335435EE223F6C50A53F3BC0F2BCCF35EE5AD52188F373FB9E
+      A599B8A96D1A91F3FF0047C7F3BC6C06D98F8535B8C81E19EADAA3B0CE731490
+      4BB562DEB6F3214DAE4C78F6D8413E918C8D513A25918C7AB5642086579D3C55
+      960A6046C7EE904962410678F8C4C790F28A802FB6F84E3E6A9C5F27C7BDCBAB
+      5B93BF22194ADAA733F1735D6FA467FA392B4FDFE2AA4719BAF9791E368D808E
+      171609D47759B567C2FA71CAAF0B10180BF10443B13A0580322EC280ECC20F6D
+      901C6C0CC408B4C836332A227FA557D45F97A99172BB579F8A8AF7B83DBBCB72
+      146BD6BF22D8E3BE99F8C95EEB71626134F2B481996D58C46008A62A105A6E7F
+      8B98CE332B908C79155895B34EA11AA2008FED5BFD4B24D33B4F770908E0E851
+      2A4C4CC7398FD41F91B56CFF0005CB5CE639C8A5E0F89E1B961ED74E128847E3
+      397F727B3F9293994AFC3D6B5CD5B1EAB1C67336E83C91F275D28D679C98ABA2
+      8C249CE3A86CF160DB32EE5F222662E490CB8F2AE9972101E0CA0807136B6D3E
+      A73CD773DB6EC8CE0E2B30E02E41E1C7C40B5C45F85747FECE7B93969F9FF6B7
+      B8EF729627F71DC962AB5AC99A9D1BB0F0F30AB1D71EE9E2A38B8DE539B1C7AF
+      1F1D28EEB436B10A76A4D8CA9DAF3F778F4DC29B0DC6D7163036805841605819
+      3ED312CA93258A02BCC89E7BB20D86FB659BA7C2B6CDB097C89110FA5E153D3A
+      039D5AA2558B9569BB4FA02FB3FEFCE23DEDC1F1DEDEE6FE864E4B88A7C4C33D
+      686FCD6FEA6C43524AD0CB1DDFA6A86D7D43D37997B036205540CE4333794FAF
+      E0CBD3F2BE5DB21C3B72F24A81AB4AE321BD060BCC8F4C9209213192D5E0AFB8
+      9D9DD47B5FAAE6EB1D33DD5D9EE32652ACD8C2695660CC0A6A6D3A43843ACEA6
+      966214150203EF6FD0EFDA3F7CFBCAAFBD2D701EDDA6D1D0ADC54B521E244A5A
+      953B95EF411C9009208ADCB05B490A09D65458EDCE8C8C1805E93DAFF73FBB3A
+      4F6E27B5BB4FE164CAC5CFBA0E4C658AA13ED3696D7A191B4280E469B0646A5D
+      8FDE5EA5B6E9DFC3EA585B7BD49092B9B23DCCEB2158C31F6C6AE0BA64AA9D40
+      16D53DE1FD8BFA79FB394A4B11719ECDE3A29D2D23F21C8C34EE99EC5E9ED4F6
+      6479E64B31FD55E9ADB066518505869BDF7EBBBAEF5EE2EB19C9DC7BDBB051A1
+      61C2980CAAD2DA87B9104100E3C65607AD51CC1DCF59FBABDF3946CF6C77BA51
+      8118700384285D2442A6825548D7732CD0C64AAE96DF737DFEF6AF134218B833
+      566E56E3587E378B73153ECC756BCF6B9496D4B2068211DAAEAD1BAB48259655
+      8C80E406ADD9F47EA9BBDC3EA076F854AB2A80CE6E34B8191A324180D022FA89
+      FA41A9DD1BECFF005DEA1BB7C9D50645E9F8C28C9944BC96655C414086376219
+      4852AAACE0959239E3F79FF571EE0E14259E3793FA96B70E0A71F7A19CD6BB68
+      46EF5B8DBC91CB2C95E8D61BEC3A470F6C4B1C6F2C723216E97DBFF6FB1EFA17
+      70A74A19F54F3E6566DA888024CC1304031E92ED9FB3FDAFD3F6FF00FF00D4DB
+      92C324286423DC44305B224E95662C346B2E0E9670ACB20733BEE77EA03DF5CE
+      71B668F2BEE2AD7A949C7F2FFD36BF2766D343C34BF511D935EA39E49DA1B97C
+      D83DC9095EEB5640C090A57B8F6FF66F4CDB6747C589838749803D420C98D310
+      2385E351BC4CF56DAEC3A5F4CCC726C3060C0EE06AF6D550B951A50E422EC514
+      9D1701096D206A33CF2E57EE676F90F7358B36F94B754DA89228BBB3149E19A5
+      90C9DE86C58DD64482C7FF002525CE33B482BBBB66D3B718E1C088A8B9349BC0
+      9102D040B447323C24198D5371D534E77F53322B09E33C79C9BCFE34FD43EE25
+      DE5C9878CAF057861E3E4353EBF9068A4AD52490BC96E3B54561E30CB1CF64B2
+      44F1A2C5BD91A408AAAAC67E85876835672598B89D2B20902C21A5A204120926
+      010B2492DAEF326E1A314D818BF01E33613F2F954A3ED9F017BDF9EEBA94A49E
+      19EE579A6A73CB140BDA9927E4636E3A092FD7948B2FB2DE4CA85CC661842E13
+      B98A7EE3DF60E8DD31B300C31B00409B8853A88522DF4F0313A9C9BC4DB74CC7
+      9B739A770032208263800DC49E3CF8F92F9D7A04FD35FDACE33ED8FDB9B5F712
+      FC36AD4B5EB72156BC3115BEF56CCB5A18E0AFC74462AF1C1117572DDC67DD11
+      29AE761F1D774F58DE772F5F4E9B8154622EBA98CA83C4FA882C7C2F0013F9D7
+      16FBA5D733F70771EDFEDEF4D654C45F1B3169404063A8B1B9200D2102A82080
+      D6891E5A7F55FCCCDCEFDCEF744B68C3215E53968A28E1DF0C7DD16DD819A30C
+      D2A055C80BE18C0C8393D7D5FF00B53D3F1EC3B6B6A88082712493F2E55C97EE
+      DEF8EE3AD6452C0AA9205FC2C279F0AD30BB2585FC90844414BE88A701FD47D6
+      54805581F50D73E3E1D763C4AA46AE75E7FCEFA988122AB0F702ACE1B5041594
+      265BD5B838F16C9CC8C0E493E1D5BED411F2AA4DC906AA6E42063BD9642C571E
+      A7214B16192AA4B6594051E3E031D5DA002AA3244F1E150DE426051D1A3C8070
+      18B1D3CFCF2482010081E07A9882E2F515CF3A87598509C901577360286C6E62
+      301492700E3CC79752967854666FCA9B9A250030CAE318F2275F9C6B8C67CBCB
+      A388E343CABE768B1F503939DC46411E7A038074FF001CF49359F3A4A58F79DC
+      11F69C05C60B7A4F9807200523F69F3E8F856711E558F654AB858067C3782770
+      73A8DCA587A1803E5E3D64F3E5431424D13023C41762189DA0EEC12F18DC7B61
+      776A49D4674D31D18334240FC6829200C81C060EABFE80B182492BB0E4641DC7
+      4C63FDBD189FC290D373D5505F77A82283F28048D4820E772E0019D34F3E941A
+      C0204D033E14E40DDB0E35627764791186C315CE35C0D3F1E9470A4A6B91437C
+      EA08F59C00321860630318D7C33E23A216B8ACF9D032A9270703C02904904819
+      623539CF473CE90F9D0D221DBBB235C1D41D705879788D3AC06686A57E9FF4FF
+      00F6463E63F2FC7C3FCFA77F1E5593F2A8E5F0A393E44050C05FB3F330DC499E
+      46619FE24271AE0E9D346789A2B456006F2AD16E51E90480C149C8F496248D49
+      1A13D05F9D15E3CA974C8393EB192FE963DB0DB887603190700E73E03AC35838
+      538A8D18FA5C8F02AC48DAD90CCBA6E2BB8F89D7E1A1E822F457A2E3DDE4ABBE
+      4DD90CBB0E1B56D8DB8AEDD33E031FB3A136A599E34BC6A7E50082E016DB9D9B
+      973B83E7D5B95BCB419CF424FE5450409E547202AC0F839676666501092CA518
+      8030DAB104118F01D0D8FCA96FF89ACBD2C491BBF2B00EFC67258AEAD1903683
+      E38F01D2114B59EC1BBD7B4A820042F81A11B91B7614248A7C7FD3838F2E927C
+      292F44AC4E19DB7B0DECB1C877B6E9415D30BB88689869AFC4749C294795397A
+      DBB5DD4D872E522DA146D6CA9642DBF6AB32E707F769D013E14E493F2A2AB562
+      EE8A859F6B1EDA11DBF4B2065601FC70BF0C8C01A104749CBCA939DB8D3ED28D
+      1550133C7245223181485731C1A3D8491B3F9EAE755D02F881A74D370FC28819
+      B8A99D3564584468ABDD292C920689DC49287C0919836E956161955C2E319507
+      5EA2E48BD3F8C1A9FF00006599C40B2C9144CD1BC924880C722AC8A87064186E
+      D038248206D1E4075073280B3CEA7616B40ABDFD9B05DE4AE255A4A6C3BCF124
+      AA248ABAD8223995E2EFBC728ACF2D5ACDB1D8EE0FAAE4AF547B95554258C083
+      E7F17AB5D9EA6784127F0F3FCAD5B77F6D4C35249AB727C7FF004F8E493E991E
+      311D8B115C9D609A1A2FF570AF7565895A50E91AAEE7C163E09A5759C6C54362
+      3AA04F808137B7870BFF00AEFF00D073E351EDE750B278C037316BF90F0FC7C3
+      D2D7F679BBCBAB7BDF8386C5CAFC576E396CF17C8D6956B4D47858056F6FA417
+      67A52CC393AF7398BD8AC6D0CD70EC9188E3407C2DFF0061530E1EA7B4DE6118
+      1F7603901DD407660432912265634803533C01A9CE93BE776E2DA66EC54DC6E7
+      1643B9C3BA44C0FEA9C6B90139646A03437B480921A1820101A6BA95FA81F6A2
+      5BE19795867ABC50CC35AEF3527073727371B556C41259980AECD2BACAD15659
+      3746E762E832063C99B7DE9DAF572D8118ED1C73529FEE090C9EA24B32A05258
+      80589630B614F7D9EEB2DB6EA47A7E447CFF005326119C635C8E55828F558403
+      90AC32DCDCF19E447BFA958F6AFB6B919E3A8D629D386C72F3C125A87BF1BA86
+      E225E5AF71FCA3F1AD5528D6E45CD527B92C9248B3201194EEF5CE80D8F77B85
+      5042B33013737E2002355CC5F800241BF0F61753CF8FA8664CB96F923DB0C144
+      0595728AEA48624805A3D200D2DEB520683F2D2717C3BCEF0F28399F6AD0816E
+      DA96579A8C10D4114D53B31596AB1594A95EE5F67B8612D1CB248269233294ED
+      75FDB266DC69D49A378C600B312666E262481E99B8880601987B8D2A413C0719
+      F979DFF2A85713F7438EA1CF9AFCCAFF00EA2ABC65849B8785E8A5D8EDC90D8A
+      CB043C9B53A5D9E6CDCE3238E3BA2B98D5E40AAC0E086B4DCF42CCFB61936E3D
+      A765F59988B19D326521A4AEAE571E5136FBC073360660507081CEDE1C7C09F1
+      1F9D8BFF00F7017A296CCB5F909287D5F253255E260BB6A08A9D944BA8618265
+      926BD5E9DE5912178BBAD24734D348E1005CD065ECFC6F0AE8188492C40920C5
+      CF2917698820280499AB8C7BE38D54069D33C48E67FC828E7C4D5CFF006E3EFE
+      72F4D65864B2892ED87E8EFF00D135E9D60AB572B76FACF3F1BC78E46B59C865
+      B27689886580B46928D3FAD76763686C6BE99B898124F05B336923FF001E5FDD
+      722A7E0CB83728173494F54DC89D512244100810620C4ACE9620EDF7B23F54FC
+      AF21027154B938F8F9B8430DADD6AC20AC88AEB324B4A2792C996DA548D5B749
+      3180C3012EF0C71BBF5CEBAA7637B67DCC8921CDA16493C2E6D69F01326C0920
+      554EF7B5BB7B7199F71B8DBFBD9334868B3104190C4582FD464004331FA8B015
+      BEFF006CBF56162CAD786F4F330863B96AEC5CAFD344B56831692AD99F9392D5
+      278D2C5E7951D9E378E28FD31EF11E5F45DF76BEEF60DAF645F131850D8D9837
+      3910B632188132C012AB00915C63BA3ECAF4ADD2BE7E9DA4332A69D01A4B7060
+      3105C80E940A405705D8166D3ABD3F3DEBF7EF95E6EA491414E0E324B324957F
+      3EFD6B6C6E4C07D759AB566A8975A1AE2B88C194AC236A48A648A456704E9190
+      E2C7831C8C388972207AB2120972607D4403026E2F24B4DBF6D7DA8E9BD273AB
+      E6CA732A80D6464F42FD0ACC1CA02DA8B1D00BDD91823A10BAC1EFCFB9F372F1
+      47C771CDC4CE390B76E5E7AE72170568EE72B3D74838FA735BE264E42A4552C2
+      D34969C31442E99E313451A4C17ADA3A3749747F7328604031007FFB8C344C73
+      FEDE44C5745E9BD1363B2246B7F7D15170222B305C6AFA8E9D415F5B1765C8E5
+      8A7B64A12E86DA39EE0F6172349B9EAB7ECC35E0E2F8AE42CD6A3563AD4DEDF3
+      F5C5E3C64766DC12D96E4A36A7C0DD10C7B62964B555C966696049FA9ECB7B8C
+      22B8593A94124CC2B72008B12489E234902D048BE5DE62CEC912E323950D1C34
+      E90CD0634AA174D660FA5A5410AC56AABDF69798A52F015AF53E5A8F0F4F83A8
+      8697F5CE522BC9C54DCF58B2791A878BE127E25F89F7C35D35A826DFA2B72166
+      82548D432DC0EEED87B793DA28772CDC61482DA60FD4E1B563025B8B2DB54B18
+      A3D9F4B3BC3932612A71ABB0040B02AB7C4DC4EAC66F93E83A4DD071332E4BF4
+      E7CCF296520ABECC8EDF295EEDCE76B737CE730BC6D5A7C7F05C8BD08AE4BCFD
+      FE6CD94E338A332AA8684DB8265B021654824AD1D7ED7BCF1634F71B70570950
+      8555664B8930A14025A2E6749B6A0490C5ADC2F4F180E4C8497950102B334940
+      C14AA6A3ACCFA40F4E964604EA05A94F74FD92ABBBDC5663F6A729EEDE6AA5C9
+      66AD7E21CE4BC521E1EFF296A7E569C7C9AD3B5FD1679F8D4896CDA4691FBB8D
+      B5E480B36C3B5EED653855B7098768EB1FDA19830558312350049D2B0047F706
+      807B5E9F8B3AA4E30B9ADAB1B329642406D07492A5A08E04F84DE6A0BEF4FD3D
+      F23052E0FDB35AA7B92C2470513EEEF73D8945BA8F49A95BE5F8A6E653E8ADB7
+      0CDC2D7B2D2470506BEF23BC8891F7420369D37BD30367CBB9C8D855E4FB58C5
+      8EA2555825C6BD70012FA2C012626A29D86165847D6086116048C6DA58992405
+      56E7C04DE2A1577ED67BBB83F7671D6D0FD5CDFF000BC9503C9D3B7ECFAFCAF0
+      953948EF2DFAF14F578F6E5B8CBC6C358A55A784C62DC88EA8E445019CBDC5D3
+      771B27C6E74AC956D24652AE574E9376D0C202BB833A41048BB54CC3D333395C
+      B8994AF0BC4037372A44C5CE907CC72156F7B56CF3B5FE816FFB86CFB938C8AA
+      D1E0B8EE3D96DF2D7B87BDC6477B9AAFED79A5BDC7DC4AFCAD7E039F9256B086
+      6895E5B0A30B0C90A6A1D5B0ED7721BDAC430E4259CB0855652426B1A59650BA
+      01A4C12021E2C18DF74E67C0C3F8CA064F70EAE0AC75406C8449372224DED1C2
+      BA1DF6AFEF97B7BDBDEDCA900BF3D99B8E1C288FDA51F3562A59FF0085E46BDD
+      F7087E477D6B3C7453C33C959E482B5891AD5359991F7131714EE2ED2FE66673
+      B8C44EA274B051A4C82387AAEC21979030240990EA9DB19FAEEED5770D8D4E65
+      CBAF70F8D721C6591F1E0528D3EF9C6CA1C07C883DBCA71A140A03EF2CFF00AA
+      BA2D5DB87B3EE14E2AB71F4F8CB5EE3E602356F6FD35B14EF42F42678694D78C
+      FCC5CB493C17F66D46896348644C30E778BB1DF1E75CD8B0FF00F63D68AAA20E
+      93320DFD45649F512410A411A4470E4FB33B4476EAB8B1A667667F6719607311
+      AD0AE4F53840B8954E37C058160E59B22358EAB7BCFEF4F33EE0E325B1CAFBB3
+      85E3A87176ECF13C9DA9DF8DBBC7D04B125BADC4C62CD3A97447C55DE63DB9DD
+      36A281A0B16648CE0B3ED6DCFA676C22118F0E1C991DE1A02C131A498060C856
+      BA83300836AEAFB0EDEEDDEDCCE71F4DDA3E4DDE645C98CCE44D4C04B9796003
+      8C794E355760C881B49D2A1AB52BDCBFA85E7BDC96A0E4792F71F2FC7D7E38A2
+      D85A1C545ED797DBF56BC33DCB7CB4D24759EAF293C3C9C35D536C41DDC471C4
+      246EBA36C3B3716DC7B78911F2B70D4DEE062480145C15F4EA26F6124C0AD830
+      6C3A574DDB64C38B6F8D71B4920B364D4634C4E466600A92227499320499D29F
+      B9DF7D396E3F6D25A89EDFFA8AD173478C8A6E461A1CBD9AA2BD0160D4B53436
+      78BBF0BC12B7CC14A4B621676708C9D67B7FB3F6EFEB9F7406D1A88525265A01
+      1218410278C85602241AEEA7D57DB035B9399418369378B98079899B5A2B4D7D
+      CDF72F919FDBDCADB3C8D3E72E4F67EB2D579DE40E4B5816A3ABCC71E23AF257
+      259647EF46F046C6350301833754E9FDBD813798D341C58C2C023E504A349079
+      08218DCF316D473756CDFC5C995C82609BDBCE08B4703244551BC77BBA5E466A
+      B56BC368C9044E8040C3FA5D6780C974F21C7C9B18D5B9056AD2179CB2EA49F1
+      C93B867E96B8519DCAE963C4FD467D3A5BC54923D306B5DC3BF39B4A24EAE1E4
+      39C83C8C037F1FD6FF00F61FB3B92E5AEC4B5E7AD7B95BA9C5D9864AF6A286CD
+      46B12CE95A326074A55EC65166218C6584B16E60475A375CEA7836B8CEB0576C
+      85819120D849BFA88E5CE21A056D7D3B60CFEA786CB20F1FA63958112388F9DC
+      D74E7F4CBF69FDC49EECE1BEBA0698CF3F1B556C19B92962B9219E12D3413082
+      194472155365CACF858D823850A91F9DBEE0F71F4FC9D3F2A613F48668850458
+      D8893C2FA44AF1922649DB5722F4DD86E776E74E1C781D8B18E4A4C093049885
+      06258813CABD1E70DF6DABFB7FED2727C3738E97AA7F4DE4DD21B324B79A111C
+      B70455D61E5E39294192C82054853D4C739CF5E4ADA751DCBF5FC7BBC4ACB2EA
+      2549178F493A7FF617BC913706BC19D53BA72F58FB8583A8F4B538F70736204A
+      8081A426A627110ED6D5AF53B5808022BC507EADFD9B6786FBB3EF2B32D7ADC7
+      F7F9ABB1430548AAD7AB17D3BF60BC50447D10CD1A8946618F59082AAC303ECB
+      7DA7EA38F79DABB3405DCAE1524B125AF7824F31307D47848245EA77DD7D9654
+      EBD9F3A80A8EE4802200E46C4D88BDC73BDEB44B93A6C6CCF24EAE1A405C4526
+      F412961A15910AA26FC606E07E241EBB6616FF006C05E1E55C2B20249355A73F
+      5CB315DA0E9AC6E234099185761A33CAAA33A673F1C9EACF6F613C2A9F3C1B93
+      6AAA797ABDA98009A050402CA4316C65F2328777E0739FD87AB8C2C48BF1AAAC
+      A01E1C2A09C9C29B1995486D847A4A61833608D3270AA4F813A7EC3D4EC64F0A
+      88C2F50D993736C65C02727681B7F880D7E3E3FEDF2EA5293C4F1A8E626F43BC
+      68593717F4A9000D085F30AC74241D4FC47E3D2C9E548450EC9E8C11FC248C82
+      090482A464EE382469FBFA2537914BCFCE95665118880C33B862D966CA2A0006
+      C50C1BCFC7CC7EFEB00A1E741BC61B03D5B500003E40F57832E17C304791FDBF
+      059E7596AC1E1EDE0967C1665418525891824856DD97CED1E6467F7103CA87CC
+      50CD085970EC46CC05F487F494F219DBB0AE338D31A74530268381A67B319CB1
+      23118C6400A1555807538D48593CB1E034E8818F9D1114CF2853B488F1E95539
+      03C75CBA80012DAF4609E549140BC6A19001B5752C4FAC05F9509538DCE4AF87
+      E1F0E8879D09A01D086F26DAC54A15F529185C1CE436E3D2EA06C290CCF95016
+      02A1118274183A3103258E00C79039F3C9E8D6F49602054A3B43FD47FE48FF00
+      52FF00F17FD9E3D3926820546B9062392E4005C1FACB9A9040FF00CCCAB95FC7
+      034FFAFA6C88FCE9CA4A20C02A918C90FE90324021B710A72DA018035FC3A4F3
+      145268C8C3E5005055BD20E0B0C6A71919F01A1C67A1A5E747C58F9828C8424E
+      D6D08C00AC72092558E5B23071E47A0228BE74B44198AEF608AA09F1C861B48C
+      95538C633E63CBA13591CA8B8F1EB520950BBF6E8413B97275D72CC00F1274F1
+      E878D10269742745D76A100AE49656D4B2E460B8C8F8820FECE934DE96470A2A
+      150EAC703D40A9525F76495C61575DDAF9F893E39E90F8D2C52C232C59705CAC
+      9B492C36EBB625C3640386C0F138CFE1D0F0A583CED4E3040D102376990D2150
+      18AA8C8ED8C82A1B2D83F1FD87A12D3C2B3CA968E378D9C6D572C40653DCCB92
+      5B6055F14D880EE071A7F874363F3A598322E29C63DA2151825885237BE21C6D
+      207AF1BB3B63000271FB078E017A13F57953BC382AD1471CCA755264627613EB
+      6EF1C3288D02B6483EAD0F8E474DB789E068D78DEA5BC5BA4A57B68B5DC6DC13
+      26DACA2395646259DDCC8ACA4E3700771C6BA622E40649A90860D587C2068889
+      5048CAA1D59E594451618ACAEE13717469237040C8C6A4EBA755F98DA2A6E3B7
+      0ABC3D96B6A499218AAF6C427BAED118B2E92212B2157231B931D8894B05D46A
+      4EB4BBB215249BFC7C1AB4DA6AD5E91715B41ECBFF008B665B4B24FC83DB81E7
+      B7C85A30CD0F1E229D2D386925861431C4AAFBDD91404081B73A83ABEFB8488D
+      11C00E2797C7F4ADA3A731737FFE4917E71CF9FE33E5E26BD1DFF6A6FBADEDBE
+      07DDA9479B9EAC157DC69271BC44B66D497AE413DFB52BC6CB0D28BB95EC598E
+      A3A48668C47229528426075E16FF00B07D0B3E644DEFB072AE06D6E07A600004
+      82480788006A8BFAB9D774CDD3F75DC7D83B9D96C59BF958D866540540CA1033
+      306D5006900B082093C24902BBC7F7AB8DB373DA2D520AF0BCD6AF71EAB2CF1C
+      A69D54AF692CF253DC9A09148A678FAD2C6D1EC63216076B6DC1F19758DCFB9D
+      676DBF75FF00673E01EDC080CC255CA99F4E920A80EAAE43371026B40FB5F9B0
+      EDFB806E32BB0C698B212148D6C594AE354561F5FB8CAC1A4058E2264714BF51
+      DC35AB92355AB0D7E3E4E367894F3758C36395E2E49ED5DB3F4734533D8A8648
+      97886DF3911CF028AC9029591F6753EC6DDA22B64CA750688432035A38883FDC
+      2DC0DF570AF6F6C1B5F4FC5954B1D69AA48B428C603E30541862C22E41232333
+      6A513CB6FBA14399E12C34B6B9FB7CC4F6713D8B733DB13C4F999055A692D894
+      72097C2A42F45A31049032A7F1803D05DBB9F6FB95D3EDAE302CAA220F0326DE
+      98B9D7320C9E551B7DEE361255A091C4F1B7207F2B7E1CEB4D79BE579EA3CABF
+      17C7F3162B71E97DEDC514FC845C74558A52079596ADB8254FA611A23B995743
+      198DB09820753DAEDB699B08CD9F129CA56242969BFA641179B083CE45E6B5CC
+      6F931E6D26D8C1278C1B0BDFF5A6EE1B99E42848DCAD778ECD440C60B4123912
+      79E1EED94291D915653729B53730C6242D98CAF86413DC6D31E55F6184643C47
+      8036BC48D266E622E0D160DCBAE57C80FA04C1B5EF3FA45AF574701EE3B3CED3
+      838CE579565FAB92095A7EEC7FD2D968433FE4D7AF1096796792DCB2FAA05478
+      A3D046C1D8A6B9BCE9F8F66E73E0416B441D43511726C20002CD3279881377B5
+      DEB948D5EAFD3E7F9CF0ADA1FB39CD25769DEF54AB72C19AC6CE1E4B66B5469E
+      FC4E297132C914552E5AAF3BCBF4F6611336F8D9955594C98E79DC9B659FF6D8
+      858FAA24FA4DDAE4A823EA531C60C831577B3DCE4725327FF272336BFE1E36AE
+      897B0B8E9398A9C8B1BD726E6788E5F8F6149EACB1F1D3AA568AE56E3ACCCB79
+      E4352ABA4532A23299A4B66183FE21D41E3DD532E3DB6640E146175275F85E09
+      B81078893C964DAA6E7CF9711F68200AE8C0C197599F528832584898D2235642
+      115AAC5E2BED5723CE52AD4AEC77B83A942953E36BF2B256E6791B6538B97908
+      239ECDB838CB717B4F97B757B0962BEDB50345DB48822BA32D06FBAAED7679FD
+      DC7A59DA59964412D168265978B2F020F19A8CDD673E06251C1CCCC4E8071AC8
+      60092AACE9EF2869F54A19D4CD251811F8AFB132C4D3D4E2EE4DCDC6927D3FF5
+      112F11DA44B919AB3D48A59A3AEFF55C5DC13CB198E4656976C8AA44526F83BC
+      EED54F56440A790F50F3062F66F48BF2F988B55EA7B7C18D371D5B27B1B8652C
+      14A396007A813A67D2EA541D43D20E937758D9EE0FF483C8F2B41B87F6A73BCB
+      5DE2A3B732D8B334828D592E46EAEF248F0BD9E52BD9E3239668E19ACFD5D7DE
+      C76A00E00D4F3F78BE42FBADC155CAA20F8050C12F2400B2C3E905A4851769AE
+      5FBAFBB7D03A29F77AD6D931E7601C20FF0071EF203190B8DF590ACC89EDBC44
+      B1297CBDC7FA5CF7243EE5E16A8E04F27C6BD1E06BF25CAC1C5DFB0B2D2F6B5D
+      E7B8DE3386838C9DF96A7C7AD38E7AB692AD599A8068629A3066925916B17BE3
+      698B0362631B85CAE402C35066B3C91162C186A2648E2748A2E8FF0073FB7727
+      49DD6ECEF3F8FBB2CFA3017C6AA0E54C391B2EB1EDB36A21F19C99106604E456
+      011510DD927E93F98E5AE7156392E3F8C8269F8CAB4E19E955B70D5A134BC271
+      8DCBDABF14A95D236E6390E2E2667C0B69719F7A94956668393B93A86D308C98
+      535EDF2380B7D5A89557003ACA295F74215C8E1D49128AB7AD213EF5F43D8EDF
+      3E3DAB66C8173BBB07652D907BCE31AA105A463C6E469BE16C4ABA4EB46C604E
+      4FFB7DF18B7390BD439B97899790E3455FA4E39E84DC75DAD1547E1E4E07988E
+      D4FC9D8E6ABF31C5B323BCA16180C86315E78FC2DF79D7FAF749C5B75EA43033
+      655D78C8DC62C84643921515B13B84CBA80D3A8A066202B47FB959B2FF00B35B
+      76C298373D3B16655C9EB671915EE758CA9A0624C7ED37041A9B201ACE5C4FC6
+      95E77F4355E95011D8F6251B3CC71552CC70729C1A999EC5C9E0E1A086955E32
+      5B9F4D21E20A5943663613A42F14A44A632818DBFDC4EA193A8B74FC4F99B723
+      3BE36C420B17C7A8BAFA64B158D4C14958B8214EA3BA6CFEF4F6FF0051DF0CF8
+      F75ED6CB2B28F6F308F6F1A9CBA9CE40B23DD5F6A31B2942CAE83406D46A0F76
+      7E8EEFD2E3B8FBD629F3F2ADD924AFC4C3C9C3C9FB927E1F9AE10C7C818F899E
+      176AF4695AB7C5D6AF1D5645D91D976512C5082F7387EE1BA9894F69890CCBA5
+      54CCA95737D4C012DA81F55A38935B7F48FB87DB3D437D97060C9B619307B6EC
+      C193083872300352B1524AABBB96562B38D14FB6EF0B05F74FE93398E4BD8BCE
+      4B6A89E46A43552854E038841EDB9E3E46CDC1CCF15EE0E0A95D900B16E94B0D
+      AA7C909E2958D7B1D986C421E15EAF7A477E62F771EE709655F720E472181F49
+      52391D16171E90C0132D336B8FBC7A165EB38BA7E0C98F0BBCB7B8C0645D0874
+      E4C59B2A02143EA4C9B72ACB241D78D82BB0D6597ED1FBB7DBB7FDA54EBF1097
+      B87A96B9DB3EE9492AD2AF4658623C97B72566F79D65B917D0DCDB539184465A
+      1314A863EC4D2AC71EE2BDC1D3F7899B26463EFB2A7B641248FA725B19898F56
+      3278CC83A8093B9AEF1773B57099136F93D031CC9C92C0341C5F5875F5AB6320
+      10C858EA40691E6A1E4EA5E97DD2399A3CAFB828402F72F464F67DFA7C7F142E
+      3490D182872BC6D6E2EB50E4614B53DAB2D2C71477EC5C0BBED0817B6EEDB2ED
+      722FF032214DB398523282CF176D4A4B16530154024A2ACC26ABC6CCD8D426DB
+      149C0CDA549690749106E4CC1D200D260089400D511F7567E7FDB5CAF2B4F83E
+      52CF13C4F276793B542AD679B8CA77B94B1C3709EE0E1B831C6D2B1EE3E5B91B
+      B353B55E5AB0B4E09B8B1C4936F5895777EDDC7B3DE6146DCE357CCA126DAA17
+      53233EA3A1540208631F492C5624985D41D15E4317CEAA50E46BB48255C59401
+      7D4240008F22675A27F7A3F1C9350879E6E22EA5FE3797FA6166FF00296EB7BC
+      26AF1FD38E6D79CE366E52DD2A111B03BE249A83592EE89117C0DFB1747C7958
+      646C5EE268649854071037D1A18286274D880FA6012D1551B9DC65C4B01C4585
+      A491F9CDBC2F02F6AD40F74FBA928F290497AE4DEE55984925A69AED98391A1C
+      71735D6BC562FBB2BF27352425E24568EB4DE80F27CC7A7F4EE98726DCAE2518
+      6222002ACDC6485FED0DC0982C2F038569FBCDEE9C8A72CB883CE0C7E3CCFE9C
+      2B5FF98E6D2CDEB103C9C708A1FADA7F46CA91451D18EED5960812783B4E8F6A
+      B46F622B0EEEEE1440B203F97D6E7B5D9FB780380FA8C19E2492A41306781214
+      A8000FAC8E75AA6F37BAF29C7E99F508E42E0802238C1209266CA0DE2A6FEC8A
+      769E782E1B0F7D6D1838C8E3CD4E46B1E24CF13DF36C4065AF5EBB7682B484E6
+      328D92842B754FD5B2A2636C5017482E78A9D5074C4C126F61CE471B8AB8E91B
+      6FF703B9258C470220719E200E44F11E55D0DFB3BEDA5B93F1F6A84DC1AD8114
+      B578C83919E38160E5A6B1F5B7ADDCE5655E3E1A1CA5E6A6F22435493198FB4A
+      02361B85F756F4AE1C8B97DD89962A099402000A3512AA0804B719D46E2DD2BA
+      4602F9D6DA90CD80982799E0049F0AEB67E8D78ABD6BEE271BC372EF5EBC3C07
+      2553B11597821ADF486B5E7AE60E4FB37229EB5BAE86408F23193B91024ACABD
+      BF32FDC7CB871F4B6DC6032D950C9F39132A6208E1C22C6D632CFDCEDC0D9763
+      6FDF0A39CCF8B4FA46A69D4B7D2194920C7A80951A9A444375E7F54DF797DB3F
+      633ED5721CD73F1CA539B8BFA450ECAD50F0D8B6C034A90C8F1AD99E3899992B
+      C6A6494A9C608CF5A37DB9ED3DE775755DBF4DE9A88F91F0AE72EC492219A3D4
+      A480A3D48C582E93058482A3C21F6D3B79BAE7710EA3B9CCB8B61D39D72E5249
+      25E0C2A28B1258C49D561C031B578ADFBFBEE187DC7EECE4AED48E691392792E
+      ED9E18837E7C8DB70D1BCB1AC68AB80BBD95355048000FAE7D85D35FA774AC5B
+      7C91AF1A853C788F9807F4BD8D5F7DC7DFE2DE6FB2E6C4DAD5EE38733E2091F3
+      0262B47BDCEF5D9DE28599D3B8B1D75DDBB6AEE924EFC85719900721981034C0
+      18EBAEED031019BF1F3F2AE13BB005E797C7E3551F351B3C4CB0112C65965755
+      914ED2B98D0B1C1201EE11A103FC3ABAC33AAF5499D645AF79AA97990AB2332B
+      67D6C1571838288EBB813940AA353AEBA6B8EADB0C81355EC74926A037B288CB
+      B42ACA00DACA1881E6416DD8208C698CE7A968644F8544637B73A89CD1EE91C8
+      CED501B424025412B9C9CE01D40EA50234DE9961EA814D7390CC1940DABBB0C1
+      3048F10CC06ED772E31E7F0E9C59E14D9E35F554CAA1815568D5B20B1000C127
+      CCEE2C57CB18CF49C0DB8560117F1AFA3D45C868F240196F40CB20D235D53D3B
+      7539D7FC7ACE54845A690921F49059D9D8000004B635C6773646369F007CBA25
+      8ACE3CAD5876CA07566D41552198238D00538C38C77181CE8C0039E9664D245B
+      CC5374ABBC125D98B0081B28A231A050C06E6C6173E5D18FF1A48FCE9AA65EE3
+      87CEEC1195D4162A4E0E4E31AA8FFB7A298FC69391F0A6C9B6BBB3A831ED1B49
+      56620B10771C9F33E78C0C69F8F4401A41E7C281994B26187CBA13E437640C03
+      82E7034CF813E7D10A422F4D96885D01C64107231E9D304B614B16C9F207A317
+      F9D0936A6B70181F15618CA8F1619C68C3183EAD73D150F1A9776DFF00D0DFF2
+      467FF0FC7C3C3FDEE8BFA524FEF511E4F3FD579207D5B6FDCF038F0B126D21B0
+      739F3E94F0B51DC57E8B7463746631B8ED3B88D4119002E158AE31823C719D7A
+      6CC7034A3F4A3632C76ED2B1E4BBBB6A5B200F4EDC64A82DA69E3FB3244F0A2A
+      2628C0C900EBB0F810146D2A431270339FFDDD24DAB38DFC28C58805197DDF28
+      2C31DADA465739F5EEDC7C4E9D01F2E3440D191E04643A924BAE5800A0A0CB64
+      B7A49F220EB8193A743CE94CF0A531B060E8DB588208DA4A38F948F14ED0C03E
+      1AFC3A433C6B3F7A5816210EA36EE52C0E1B0A0E3D79C614E832078F9F496A21
+      FA5394754A18F0857F31B01F686380AC8AA11B23C7C47883A1CF420F2F2A3163
+      4E512FCFB9828C90DB989DC321B6ED19EE2865D49C9C907A0349CEF464501473
+      2323ABC7210FBCAC6EAEC32BBD9892CCBA1D17033A919E849A2200E1462D78D1
+      963679DE26DD3BC688DB4163841221219582AFA8670A3C0EB9E84B4DF9D244F1
+      A71882B1502578D1CA20AE9207465DCA0A17188988D81BD60780D4F42D6A5559
+      31CAA434155671215771198E375760C34705200517B7B01DB80C0EBE03A8EEC0
+      883C6A4A804D591C7C6ADB23204FB44518DCC6141283BA78809246ED4EE71A29
+      1A2E40F0EA0649E35293C08E15727B304B5241655A3468A036A28CA991CCD13A
+      08EAB3C01A691BB7B42AB32A82BAE3730351BC871A0FC0AB5DB7A6E78C4FE35B
+      27ED1E4A4912652AED7EF3C5D849A011D785229CADADEDB21911E486424312CB
+      B0104E743AC6F710D3630A3CFF002ABDD8B3EAF4FD64FF00AFC7CEBB2DFDB8EA
+      71DCC7DE2F61F142CD78F9CE6391B1F4B134823A3C5DFA10CF6D66A189F0B7AB
+      4224856392BDB819A50C0A322B75E54FBF99773B3ED7DCEEF0A4A22011176D6C
+      AAA0CC58B1049D484473048AF437646F70EDBA7E6CF9816C49832BB28E611189
+      10194F09047FE24C1060D7AEBF7351357DABC841BD8BF1BC632C33C8C5ECF7EB
+      C22186C1907A3B8240189C1072410CB953F32BA96EBA8E3F636DBA4555563C7D
+      4DFEE45819D3A0102214B80194E42B0838CF41CAB9BAF61CD034E6CF2CA042E9
+      66D45638C4580F91907D55C60FD4370CD4792A3CDF1B44BCDC55A9D2DF0D7D2B
+      F2155A7B9C7D9E50D68FEB78C9AA496661776C225A85805728F02A13D74AECAD
+      F823F8AED032282A418220813620C78907C2C66BDFFDA1ABA8747F67368CB6D4
+      AC3D25910FB5246A6E0501686892B3A99AB8FBFA81E56A7B8E0E5A68F8F68AB7
+      1BC8CD02D7E2E2A54E2ACD3D727914ADF4D224942B59AF592C45BEAF6A4B4E2B
+      9116CEDB7A87B37164DAE5C5ADC1C8EB24B49E07D3323D441254C3485F55E644
+      8DFE08C2EB00AA1603E51E3E247CE6003CEB449B825A934ED0F2B7B9E86B85E3
+      AC7280CB1A3416052E6694AAFCA2559A422C5691449B5E37110445671D7651BB
+      2CA0945C44FA82F9894365902C45AC44C920569EC83182012E786A1C858CDE0F
+      F81B0A97711EC7BB5F954B576AC62C4932D9921AF5A0821B51C46159944E241C
+      6C165A30C8EB872EF32E10B386EAAF73D5713E0D18492804492491C62DF511C0
+      8E1001BC08A95B6C29AC059D62E6C3F1B8B797F85EB67FDA7F6768F39778EAAB
+      5450A74E995B1538BB1CA4B0CB72B81587211FD7AD87805F13C71C5342A21756
+      C066388DF9FF0055EE87DA6277D5AF231B160A0806FA7D303D3C4826679731B1
+      6DBA626521182804F01313FE936F0F9115BB9F6D7ECB569AFD0E4AE3CCB638DB
+      AED4AA55A134ECD5A853A93C9567B13979DDCD6AEB1A36E08BB4911FCC1B9175
+      DEEACBED360C2574BADC9204124DC016E264889BDCD5B8D9A6D31B662A4E82A6
+      2080751D22FC6DE16E439D7557ED2FDA39BDDD4F91E3F82E0ABC74858E3CACCB
+      451B8CAB52032C12343C6E568D9B58E4DBE45127A339F94AF11EADD75F0B2AE7
+      2F933E43002C976637007F7198F835A377A778ECBB49F065DEE6D3934641ED86
+      0199CC30F581A914FB60DEDEA8337077D7DABFA79E2E8C7DFE41A19ACC9652ED
+      AB55E379649A1A92F1F3D0A7C9D8BCB69EDC359B8E51229243EEC124004D7EC7
+      61D7FAC6219B06166DA046CAF99D9862C4029B652BEA5D0C048504CB00C71886
+      3E5FEBDF77B7DBA7F6B661970AE328AAC6002C322E47C4A854216190E93CA240
+      0491565711F6B3DADC4444CDC7D5BFDAB72720F34F46840526793BC2D0869C15
+      2A95CE3004785C670093D44FF84DC610D9FA9E757C48C0E4D009C8B8803A32E1
+      666462B90B4CA212AA06A20168D33A877CF5DEA0F18F2BE2D58C63015DDA4011
+      A65D9DBC7FBA4CC5C0A1F99FB93F6B7D992414EEFB9BDBBC4CD7AC495A14DFD9
+      827B94DAAA586E42E468F569C907D6C6F2BD8940D4B13E9245961E9099CB8EDF
+      DBE477D78D4975C83DD7C708B9F263D4E419272B0D6EAF98314D2E8A439B2ECE
+      EF5EB989B79FC5DD64DB6240CCCDFDA8C188D0AC4332908C1422F00044309E7D
+      DAFEE2DEDC9BDC3EE0E3384FA2E66B51F70DBE3F87B1C4478AB2F0DC2D9A76AC
+      F217EEF275579292BF2D42592285ABF1AC84156136E0C13775FB45D636FB6C19
+      377A4667C38D5C94504825A718E5C0B29D7903E90032FA567B9F4BFB2BDBDBBD
+      A60F7F3E64DE1C0E73EA3AA329C6D01110AC05728DABDDC884CAC15BD67FFF00
+      D4EFB2914B9827B0298B27888792FA492214AE474E6B376BF27C7B4E66AB58C6
+      62D92CB2C10C4D20EEC888AEE25ECBECAFDC0D8BA67E97972E07C3B738F0042A
+      346D9E51B16A8F52B29B0592080524C1AD6B2FD9BE9015865EA989B22B12E91C
+      48234C3955D245F5EAC7CAC24814C51FF75FFB25C8C68B4E0BACF6ACF1D5F8C9
+      AAC3FD4564B33588E0B35FE96A5AB973FE16CC80B38CCEF1B66388614C8DF51F
+      FAF7DE3BCC6B8980C4B8806035392A55BDC521F2B311EABEA10780F4E9B827DA
+      8E878991CF541931B170C02C70B0BC01245B4C6906ECEC1A15E786FEE8BF6839
+      DF702F19DCAD578BB4965B84FEABC854E2F92B6689913919ADD4EE599B8CAE96
+      609EB406C88A4B162252A823719A8EBBF623BF0ED71EA67C98303332A28D2316
+      B170B9102BB1321892CE7480ACE42E912B07D9BE8D9F68BFC7EAA8BD5493AE50
+      B63892ABA0FA493201611E95245C80C7697DB9FAA0FB0FEF896B3C5CE5092D4D
+      D901E7A90C91C51C96FF00A1A589A653BD113902F49411BCB960A36173D73CEA
+      DD83DD18771EF758D8EA7640ADA534A6953848C8F01722E9C68027B4E4AA82AA
+      23331341BBFB4BDF9D2F0B1D83E2CFB504C7B39C316600E428AA0DD885F708E5
+      A44FAD5455BF53DB1F6DBDE1C74B171327B7798E36647AD2350B75A6E3E1592C
+      7D54B019206688C52DB0CF1C6A1933EA5F973D52E3EDFDCE76C5D27A6EE9BF9A
+      EA8DA32128BB72341CAF91B4AE460ECC571630AFA7500EC4637074EDC759EF4E
+      DDDE2BF501BCDBEF14861AD1864685D21806BC84805C9048B1FAA2AA3F7AFE94
+      3ED57B960E69E0F65F1515CB3C64B171FB3B71474AFD1BDFD538E5E3EB4A8FC3
+      A4534B23237715A361DB048C6EE936FBDEE5DA6FB2ED559B1E2C791D5753B01A
+      B194564CB9751C41722EA21C30C4AE5103E31FEDD6FBDB9F7D7BE7A4E4DB26E7
+      A865C9B54CE1B2061A8BA3A7B6E7237FF29650015D24329D644CC57353EE27E9
+      B6FF00B63DC7CDDEE260E4B83E07909058E4A873BCAD9F73CA78EA57E5FE99C7
+      49C8D865B15A5B5120A5B9A7AAFE12B48A8DE8DDFA67790DF851BBD39378B124
+      402AC4112D1E045A41B0E11C7D69D9FDFF00D0BACF46C1B5CEC997AAA80A8F83
+      1AE05D6C8BEEBAE3322019CA74AE4992811997D5A45FA82FB337A68A957E456C
+      5CA13D87F77F1FCAC079085E4A3C7707C7C5C76D97DBF621B3C45FA9C4717523
+      40EE1EBB18EC4EE55F749D3FB47BB1716467DB47B817DB885E6ED3671EA52CCC
+      C6D712AA0116DDB66FD3BAB623A1931E5C793DA742483EE9762D05E03AB64D60
+      150158EA0A3D2557967F717DAE5D14DE847B7EA50E0B9C8B89A57FEA6C235EAF
+      C9735EE2BDC6561C8D9827B16E46E4E184F7967CD89448C9239287D13DBDD489
+      1E96F7B336442CCB03D25531AB1D20803D2C6C47A4690408354DBFDA91771A56
+      0882389049F2E4408E1E55A85EEA32D0E4AB575A6269A24816B4B197ECCF4E35
+      4FA6A638D85FB52AD624C6B1CE650CBA15EDB2A8EA5D31866DB97D50A4991CC3
+      1E2751E13C495883E609AD1B7B813190D04B5E2E4085E022787CE6A13CB7B6EB
+      D4E552CC02F89653628F370A8160D17E3FDBAF3493C6F6629A7AB135990A2F71
+      86DEEAA80BBC0179B7DFBE4DBE96D1A44321E1AB5648820100DAF617826F1546
+      DB155DCFBBEAB820F3FA56472917E1F3AB03D8BED8333F29728C16162A54A296
+      6926696516F899561B05A793B26959907230C70C8A618EB8620105970F43D63A
+      86954C79088668004086B8B7F701A4922E5BF036D83A6ED9509CA92085E3E22C
+      60F2E300D809E56BF473EC97B43927F6FF000BCD2F1DCCDFE1AA7395AF08C5EA
+      71F1F24B245778CAD6A08A2E34D6AAF7A4A13EDAD31EEEE42B0EC889EB83778F
+      52C38F739B6E5B1AE76C45661B54486209D5274823D42D79696AE8FDBFAB2635
+      4C4C5723498917020122EB07E761E42BAF1FA51E33E83DE1C7AD1839182E4F6A
+      3B6238833B3509A16ADC9466CB898C688823937C1087655F5952AAA3CC7DF5BA
+      5CBB37D7A4802384DC5D7D3C493C20922784CD52FDDDDBA61ED0CE77271B612A
+      64B106320D2719D2BA54DC328D4D17B2996357FF00F757E7A9FB7BEC4703C472
+      11436E7E6AE729F47F5312DC78394E368D4FA4B91BBA4AFDD57B8EAACA3B9202
+      CC082A48DC3FEB574EDE65EEAF70B32B63C29AE0C02ACCF2254952860703A491
+      317AF1CFDA81806D7AEF52741A53160C696000391F23597C40C4387D161CC579
+      25FB99796599B30434DE185E19041DE88CC86C34A9330972123050808186C2F8
+      0A0E7AFA89DBD81C6110490483262780B7F9FEB5AD777E7C27215C6B044DA0C7
+      191E1C3C0584DAB4CB9CB4DDE58933180C658DD4E56453DC50ECC40DCC53D20E
+      325478F975D27063016471FF004AE3BB97F568B7C7C4557BCD440562AB1F642F
+      F376E1B71382A558657014EBF0FF002EACB04969278F8D56675B5AAA8E5B6133
+      376D99546E0C5586C9245DCE48CFCC724ED270C0674EADB093115599044D5756
+      47702A26832771FF004A91A9C11B3503C7C74FD9D4D5F4DBC6A1B4CDAA316577
+      EF19DB92410320E75CE76EA3F6631FECEA48200A023C0D00F186048181A60E42
+      86D115B4D345193FE3E7D106E549A62FCE9128A8ACBA95CB7FE27D70C7C46B8E
+      B0F8D0F114BC8B200AE8558378B6D02324050EBB0E402A7C35E96473ACE3429D
+      818068DC28DC5991C2ED0700BAAA90836A839C0C9E94564102869C2927607DA4
+      82A4A2B211E024703D4597277791C0E8852729B4D373975CA36D4DECB202CA41
+      F506006D1E058FE1838D3E1D148A0F3A6F915D8972339C063803706D377903AA
+      EA7CFF006F440CD649E14DD33C68B85452B8DE0B92986D837229607706D99CE7
+      1AFE1D382F42785B85344AABE941E6A855997602BAE372923049F3D339E885A8
+      49314DF226FDCA47A86E3E2BE2DE2A4E3D58234D7C3A2ACA0278CAE31FC2402C
+      0FE5963963E380CC31FEDE881F1A423C2A57EBFF0053FF00C8DBFE5FE0F87CDF
+      2FE3D1C8A1A895D42DCA5E54396FAFB7E59CB1B320DA49240006BE1E1FE3D61E
+      33440561186CEF38D54FA8EE409F87E21588CF4063851C5A8D8832B15DE53683
+      DBDC19BD246EC0C0275248FC327A135828FDA5D8B042996F522A7A44A32E1225
+      1F2809E39C1D4683A1F2AC201BD3846A10238C80E30768DC1959F6165DCE1F61
+      C7981A03D09A511C79D64C07A00F5152EA540F94E7E65CB13891573E58FDE3A0
+      E1446FC295400C4C5C8049281704AAC61146769190A776E5C6A5875878D609FC
+      68A449803246863DC0C6012B9F46413B4F9292D938E8640A5134E70C424EDB2E
+      8CA546D3B8308940442411B76866F1CFEDE82748A30229E63862707E78A54672
+      A137B26F071057572542162402E00DB819C8D7A6D98CF8D101E34F94EABCCBDD
+      073EA770AA8F23465955232EE48291B8D19896C6338DD805977837A7F44FCE9C
+      1A8E3D08E82562249A562FB14B8180F3952DB5F66D008C96C60EA400D66C7952
+      048344C357E658D9FB60C6B2332848599C02A4B29CEAC3006A4E7CB5E80BDA4F
+      0A2D378A7EAF095B289F50DDB960589A42802C32CBAE1E371E9842E3254FFBDE
+      1D30CC229C54BF9D4CB8959229E3B11ECCA4E9308E282496351046F399D8B651
+      8469099146A1A3DC74C1EA2BB4823CAA4229E22ACFE2A48A78958B2C7756C561
+      DC15550947920866994B3BC72F626793323292766A41C62AF2CCC7F6C1AB0C5A
+      45C7D5572FB4278638AF433B9479A293E9DC46CCD2D8864774569446C226B35C
+      8D0140531B40D3AA3DDC836E556FB3FAC8FCBE75D6DFEDEFEED9B8CFBFDEC0E5
+      390B038D91B976A5CAA71DC3347C94F62CD1964E3D95D603550BF2B52233AE3B
+      B2470B222ABBA1EBCDBF7CB609BAEC8DEE0592063D4BEAFF00C5849E3AACA4C1
+      161337835E85FB62CF9FA88DA118D9F2E1CB8D95A42FAF195F537004C9898BC7
+      8D7B5DE07968FDEBED9B735BAAB4C45627E36DEF0E86658A3AF64B07636E30C2
+      19C2B7A9D89D7218E17E5475DC3BACDD1CA6F7F898CEDF4C643EF0CAF0D31EE1
+      2D8B525C6908AEC080753302796F54E94DDB1D731E2C0E721645C89106092CBC
+      0683C564580E5102FCAEFD42F00BCEF23EEEAC0FA2870B42FDBE5D04261E269D
+      51359A72410C3578FB26DC94A2DE15665B36144ACCB3A9948D93B437AD8CE2C8
+      ABA41622264F21048B40E1311226C6BDC9F6E330C3DBDB44C84AFBF9F222E396
+      0D91DA15A5B5B0D2AE6274FB68742838CE80788FF7B2A727F5324DCDF1269DA9
+      2CB8AF423E28528EDD582A43C5A579EECF7AEF277EAF23763335B8EC12CAA64C
+      C7DB0CC9EB4ED2CB806355DB64D58C28962D30492D204055205948E7179B1DC3
+      A9E3F6F09D505A2391241B5C8F491E7691CA2F557FB4783A4FC9EEE3AAF13739
+      1FABB823BF678DA16978F635AB413ADA926B2F4ECC71DDB5F45507D12AC70CAA
+      D16D92575936BDFF005175C2064774C214583302D24911024586A6F5F1066400
+      46B7FC545C8214331F1123C4F1E313020447870AD9BF6A7D94A5EEEB356F53F6
+      FDA4ED912DFA75B9589F89AFC7559D055E5DAE5914499EC35A9912253F9DB140
+      0645DABA3751EE8CFB5C6D89F2A958B315F5491758136B03C2D7E46A76DF69B6
+      401F2882C6041F0126D131E3C85A794F44FD8FF616971DC7DDE62ADAABC8CF25
+      A7AB728D9E2638D2C40F59ED41C9C669623A7C7DA496E66190B9AEEB18557964
+      88A71AEA5DD193747DA24851E66DE52471802E3C38C4832F2753DB74FDEAEC9D
+      0AE36C61864040870DA5B1C349675271905615D59C9D2A8C6B7FBECEFE9E2E72
+      FC7D48FDC3C452BFC11E0B8FE3F8F6B29621FA5E3219B8CB90DC8AC3399E3E49
+      65E2D6AC91A849B61976BEC93AD03A8F50EA3BEC8D8BA6E17CB974B646222144
+      C4CF0265ACBC5B5085E478677EFDD5D9745CAD8FA1E7C987A8AEE59DC2956D59
+      74E442A57E938E327BAAC4B26A18E575256F8707ED7F6CFB0B856B023A3C5D4E
+      338CADFD479191E486255A1552BBDB779A49856831197201DAB9D738CF4FEC7B
+      7D76AEBD47ABB29DE850C8A1CAB7BFF44E323D2406048700A8631A6C01F2FF00
+      52EB3D73BB7A98C00E5DC6E73E76F6F18018FF00B8C5820000D4D789224F94D6
+      A5FDE3FD7C7DAEFB7BC633703668FB9EC77AE256FA6B224A73CF462696D4029D
+      09CDAAB288503B1930360F49DC481D57A7F6FF0075F75615E94708DB74F4CBEE
+      10A1B061009505B162562A8D9C050E5A4E3209C47FDC78E8BD13ECD66461B8EE
+      CDC9DA295BE3C6172661F3632862E204907EA1113C6FFBFDFDD1FEE0FBBAC337
+      B3F90E4FDB9C1068AFD27A095B8A9D3B886B41004E627744A6A2E13DDB4D1CB6
+      616DA22C307EBB1F6AFF00D7BD86DB71FF0025D580C9BC6B0566770A05880DF5
+      1B036120137336ADE76C7B13B4B0FF0017A36D067DC15D2DB8DC2ABBB9306402
+      3427A9437A4022069AE6C7BB3F531EEEF7BD6B9C9725C9BD9BDCC457E3E13DB7
+      C472FCB354E165916049226A969E79E9D0923692CC71C969C851DB8D955863B9
+      74BFB73D27A530C7B5C4A88A54BB9459789B93CCCD8902E6E648A0DD77F6E338
+      0ECE5DC83024C29B5C011A662447E5C235D3DD9F73B95E41A3B09CD5BE2789AF
+      1AC9780E40C96E496841DDAA932C75607E32FCAF2490BB306EFAC6BBCBB02837
+      1D976BECB0CEAC48F9DA63D36B9BF332381F224C40BD6AFBFEF9DEE401132B26
+      3E70C790B0E16F0F3E73C2A91E5FDF7C95992ECC9C9D112D68D6A5C14390B55C
+      5FE384DC74108103CC713BDBAEC6D3150D241BC6444E54ECBB7E87B6C68A9ED9
+      D04C8902C60FE906DE06FC6B4EDD7736E72642E1C6B0003737123FC789F0F2A2
+      791FB9336383E4695BE4EEF250A5AFE9FC99B12715C9527333C329AC6AB10B34
+      7210A04B34B1A85054ED76542C5D171B07C6CA83198958953F39E5F200FE951F
+      3771EE82A956626F7333FA5BF3914D5C6FBF6D497A97D6CF6ADF215297275ADF
+      E74D1C30EFDC29B5EB8D2C1243C7B473471C9B65940EECBB832B6C09B9E8988E
+      325554212390E5C605C13CC58701C22A56CFB93763496772F041326DE179B0FC
+      4F13E31560717F7FBDDFED56E65B8AE6A7812DDB75BE946DD9AF4396E3258A1E
+      3E7582CF1D0AED9E26823EDDB58FBF2FCCCBB430343BAEC9E97D415177385598
+      0B12012A6E781E464CACC0E02B67D9FDC0EADB146D399B40311274902D681783
+      C0F1E75D39FD3A7F748FB87EC3A3C4FB7EE5AE5EFF00B6A8F11C7713C5D5FEB9
+      C37B72E96E1AA4D5AAAF2D0D7A73C564DB8FBB22CB1B25C06241249221C2F9EB
+      BDFF00EBAF47EA9BAC9D4B60CD83A9BB36A7C672CE966D50ACACAC029365FA24
+      C850456F7B7EEDED9EE0C4A9DC7B0DB65CFA6D9720072830BA8092010FA7E932
+      049200264F577EC8FF0077BF64F2DC4A47F7062AF4F91860ABC74146CDE296FE
+      BAF41779188F20F3218DA7E1E18963BE5A7052348B3B2CD85A8780F5EFB09DD1
+      D2778074F5FE66D171E582CB0A59994EBC8CB193312E1341762F130C1159DA0F
+      52FB6DD8BDC43F97D0B7DFF1F9DF382D8986B85850554A80149032381A74AB30
+      524C823A2BEC2FBDBF657F529EDD85FDB3EE0E22DDCE4A8CE38F1DF636124B9C
+      6892578278BE8ECBC1124CB2A44E009A28C9D0061D798FB83B4FADF666F32B75
+      AC25063760AAF8A1356557C672075D4A8B832E8C8A8C8437052B15A76FBB4BBB
+      BEDF655EADB79DCF430E8C726221919464F4EA53AC2B34692C2E8CE0112456B4
+      FDEFFB1FEEFE0B86E1B9B4823F72AC7C8730ADCAC165A6E5EC0E6BFA6CAF272E
+      97A5B36D912D51C232CF2208582E10220799D1FADE5C18B1F50DEB04C5BB50C9
+      A9D64E837845320FAAE4A89FAA4EA9AEF7F6E7EE376CF5FDF6E7A4E663B22706
+      28C4CA0625F6BDC1A7114508255C16071A92E354B1662BC74FBCFF0060790E62
+      CF27CE7B9592313F256B9A822AF5B95A278DA863FEB76B86A95D6648E7E2F8F6
+      BAD35086A32D8AE934AFBE591F5EFDDABDF18F02E3DAECF92683254EA3F48724
+      830CC000ECD2AD0A00502BD118363B0DDED4E2D8E4F73D280B6A57882D8C4C7D
+      32562485F50311715CF9F7A7DAAF6BD7E5394BDEEC9F97BD1559F9BB7C443C15
+      1B70F18D72DD6AD055926B56BB428D49AC25792590ECB0B142C8CB334893AF74
+      E91DC9BDCBB64C5D3C63466081CBB02D00926009D440D400FA492082A015AD6B
+      A974AC38F291B8F70A2EA8004093633E0262FE5CF952B6FDABCCD8A9C943071B
+      353E268D2B8E9CAF6E08AFC3C7DF92A271969EBC7271D6795E1A6B6A95CBED9A
+      3B3958555C46C8371C3D4B6EBA19DC36E19D469FED2C01D427D415E2580B15BB
+      12266A8F3EC48C738D60471E60588F091CBCEC39544F8BE2A05F71BF1BC3D016
+      E937236A1A50D597BB3D4E3A1B71FD6490D38DEC19E840FDC90D991E3599B7C9
+      19906C924B2DD6E4B6C7F91BA7D197402C4D81622D26D0C6C348062C080640CD
+      B629CE31E259427CEC39DB98B9B9E3722BA51F6378EA464A52CE24AD59A5E212
+      28EBDCAB764AB02C8D5EAA71904DCC519E7A4B7FBCCAD1EE8CB22C924AB334CE
+      DC07BCF3B146020987995224F13ABD2403A6041BDF485D2140DE7A1B7B0D28A1
+      A07A413008816901A04F383C6E09B5773BF4CDC4BF2BEF6F6D192A2529786812
+      E2B1838BB3FD41EB85854426A246952366911DA4679255561B448D9917CB1DCA
+      C836F91703072ED104B73FEDE6D27E9B70E3E902B877DECDE7F07B5B790E720D
+      CB683EAC8BA355E4EA2759B101405524104A2C21D0DFEF39EE76E3FDCDC1FB73
+      FAB77925E0EAF3661AB02C7678F649EE505AC93452BBCF2C4B03170CCAE16452
+      A8003BBD71FF0055FA663DC26E7A82290572FB7EAE00A85906E784013C0C571D
+      EDBEA18769F6B31E128D87236F32B4CB13934848C8240001D5A4289FA492C4F0
+      F379EEB916FC33192552A21B4D1BD8836C3B6358CA448216778ED1694857970C
+      5C8CB6A00FA01D30FB6028E3E47E2DE42B917598CA4BB3789E1F17BDA6B5839C
+      580BB32C7258926976A7A0431075CA470BAEE446EE2A820AE8840C9EB72C17F0
+      8AE7FB8285A56F27C2AB7E46CA112C68851572A109210E4B6F7C8526255DC460
+      6469907AB5C4BE77AA8CAF248E555FF255279D98C8773E0B1CB37A8654901948
+      009DC4EA063F61EACB1E4516A8591644546A4E3806D8E3058840C71E441218AE
+      70A18EBF87F93A1E6E385475C73C78D305CE2C44F20D89B723D4177166DC4E57
+      2DB48D3E033F01D3CAFE1C684E38F9547ED5028EC0C51AAAE572414619766572
+      7C588FC467FCBA755E78DE9B643E0682FA4EF360ED046E62541652B82C743900
+      055C0231F1E9CF7001E741A4133CE849AB6C0B8FF79B6803D480E078B641565F
+      867539D3A50D48562811BD7F2D5012E7D0640353E00A9393BB249F11E275E9CB
+      11AB950DE64D37D8EE46ACA922B6D23712017C6D2C548C10141521BF68CF4434
+      9FCA878D33BB0707B8C5F5C0C925B0BA6D0739206FD3FF007F45C3E9A1200314
+      0CEFEA621A29405C0381B402B8C82110684B69E19F8F44B34979A6595B6AB84C
+      E888EFE4A18E0BC617CD4780235F139F2E9DA1334DEECF9CB9241EE6992A119F
+      242AF89C301FE03A391491E342BE171923D5E9DA30ACA318000D4000781CFEDE
+      88527ED41E32A41DC096D34030555581248DD8D4E7A5E359F570A987A7FD0DFF
+      00246EF94787C7FEFF00E1F2FE1D65240F2A88722AA791E4B682C4DEB21B042A
+      E4D9738D0138DC3F1FDC3A28BD671F9D6215C974273B0819046031650B924312
+      1A42300796B923A0B71A2134640BEB2487181829A9046DC33F9123273E18619F
+      8742784D2FED4E291953B5B2E580202EE5DAD9C85C1DDB8B0F49CF82FEEE87E7
+      4A078D1BBD9FD2BAE498D703D4C8BE0541CA80AB803424635F31D0DC5603F9D7
+      C4403D3B548DA372819619C1674DCE3606D98249D32303A16BD10347430AB91D
+      BF533A7A56465DC338C44E8EABB99146D6200F1C8E849228F89A3E3A6EAC076E
+      45D8C181DA5403E971BC13942BF10D8D3E3AF49A873E3443C0D3E54A2C4A18C0
+      F00C524066FCD7DF81DA237302E03293EA075F8E5877E468A3C785388AFAED31
+      94590968E4C90AB22A217124B2305750356DAA0EE231A63A689E7CE880320F2A
+      975569268628E28F0ED17D32B4625ED376DE063DA660BB18950CD9F26D4E7A8C
+      C6189352003C453E52E3A646C064449C61A491FF0028C61B227253132A777588
+      8463E63519E996CA34DB9538160DF81A7EA9C5C1602472C90D647EECF276D19B
+      6EE751DC487702C446AB9CAAFA15BC5B66586CA57C4D3AA80DE9D6B706BDC2AF
+      2C161408DBBD0EF9731B91911C76BB25C85DC1B705C7869A12CE4CE226E0FC78
+      53EB841B9B8F8F1A98D3E31671144210F6A567CBB248CF322C4C88D13AED32FA
+      51C05C060C1B7165DA4427CE6247D34F0C462D7A90C7514AC52CA17BD0CB057B
+      2D26C46685C3E5609990CA52494046C86C0763A805C3272AC698F8F8BD388BE3
+      C471AB53DB6F3E6BABE2D7D1D3852688C723CF2472826535E4DAC9FF000FBC28
+      DC54E1F6A1F2EA9F7441062D26DE1F8D5BED4B211171F1F1FB56EBFDAFF7A5EE
+      0F9FF6F737C3F356783F70457229E872A218D2B5586C496BBB240F569D859B90
+      B0D3C4F0DD26215DD4BBB76865396774748DBF50D9E6DAEEF1AE5DA953A926ED
+      11C648F4882192FA81889E3D7BB57AB67E9BB9C59B03E9CAC624810019079192
+      6410D6837E15EDEBF431EE39FDFBFA6CF697B82DCB49AF72B3F246F415DA103E
+      B4D8D96391B91C35AB43564E51364C523678F077294DC517E51FDD0E8A31F5EE
+      A7D1B6EEA746445C585982C40C6ED9199E74E201971FB84CEB52088824BEEE6E
+      19FBBB0EF98649C9B1C2FAC8E23D402A4319084100E95226083009E7CFEA4795
+      E4385F71DBE4FDCD716BB9B347877E3612B5A8D0E116195FB9662A77EBCF6B90
+      7E3E54024AEB66C5779678A37AD3C90BA46EC8C38B73B618F64271B296137663
+      6F152041B106162090CA083ECDEC2C3B06EDEDAFFC5E366DA066C9EEB4B13999
+      806B912B8C3AB1D24E31902623EB4D73C9EFB86F439DF7A2B47C85FF006FBD89
+      E39F89E5B92A2F6CC142B71FEE1B12D5B11ACA28B2CC36C7DC9A5C9788B9324C
+      6576F47F40F7369D324AAE5400864568B9641227D5E700703165815B0756C4CF
+      9955DC10A45ED7005E4000739B081C00020092FDBCF6DAD8F79D5E2FDC31DAAB
+      4ED72F4B83E42EC5151A3FF0DC857E521B6D24D255B942484A164996457EE2BE
+      18AB0184EB1D4463E9DEFED8A965C65C2924FD25639820F0208E11691C6361DB
+      3302AE0EA100587391E11E5F8D74B7ED0FD9D8E3E4695AE42B3D7E66EC3C6AC3
+      C656B91F71AD46956569AC294B95D122333B76E0DD2C56321E348C2AAF1DEAFD
+      C4486C08C1B106266388F236F2FD38999ABEA1D553A7EC1F718EDB74D5EE3303
+      CB508001520922E5E11958E93306BAD7F6B3EC0270330E5F93B05E39E3E36482
+      9446C1EE1ACEB7A19AD4AC209609E1982E610ABA6F0DAE36EA18FA3F5CEBAEA7
+      698CE3D99720E42AC402A6584C005D4024A826349F50AF22F7DFDDA6EAD8FF00
+      E3B6290E8720673A6DA8142100D419489F5927FB48E736B7DD2FBA1EC0FB0BED
+      2B1CDFB9B90E238443DC6E3E9AC956BD8BB2BBC711FA0E2E29A39EE08E59E369
+      56105821249C67AE97D3FB6F37409EDEE818133772642A5F72A44AE2690000B9
+      1BDBD40075B16E37D0C01E65DB5DBBD5FBE3A9406C87698E3DDCAFA8AA882406
+      C84101980609A8C48E15E6BBF575FADFFB81F7ABDE96BD9FC67B8AC7B63DA6B4
+      DA8AD0869CA949248B9410F2D6791E3B7BD7E469DFB7C4C70A1B1329AEA7BA02
+      12D8F44FDB5FB4BD2FB7F65FF29D4B18DCF556C9AF53193253FB4CCA310D2DA4
+      0D565E0001DBB12F4AED7C2DD33B71340758C999E1F2B10CC2ED1A42E9252140
+      1049BCCD7266CFBEB9FA9C05EE524BDCAAD0B9CACD04BC0DBE46CF2535A978FA
+      35ED5986CD8B70FD64145BEA8AB6C755421D142B48449E8C4E8FB2C999708C69
+      EEAA82180023518100189B7E36E316D37275CDD6256CA72314D446926780BF29
+      8BF0F381C6F457B8BEE4DBB505BAF62F7D450459DD842AB059E3A65597B00CF2
+      C5604DC7D19C24712AEC41114432655875B36DFA304D30A14C0F304189B0E679
+      9F1931C2B57DEF70BE44D24EA00CF9CF2BC70F0F28BD406CFBBACA442394CDC8
+      DAAF4A18519790865ADB5B8E10C74608A156EFB72104491BA46ED1BA6E0C4B60
+      1B34E9E241002A93E1E7C7F037BDE6AADFA8B69E65CAF8F970F39B0B58D565CA
+      FBC8F1B0ED669E4E52B3CB62BDD9E49DE0E1ACD97945915EAD8C6D9A0490ED1E
+      3BB611B88216DF0ECD58447A4DA3C7E6472FF3AA5CBBD28A449F7278F8133C27
+      9FEB51C9F9991C288DE12F271F0B5DB29DE88D9B1358069B98A731BF23C880A1
+      84CA8D1CE420219C752176EBE1026DFE3F21E5CAA37F25C9B45C5F94F87CCFEF
+      424FEE95AD6EB3913D59E1120B15AEC4F35AB063024825AC61869F1882132299
+      83B3EFF12541D106D0B2910349E6387EB27E5C3F1A0FE5B07BD8F39BFE5103E7
+      335927B9A5AB0BAD7531F268897793E4671F4F5C8DE26960EDCA9BD648E58F70
+      703B73890654460314FE186235FD1C00FF001F8E14FA6F1D1348B3712780FF00
+      5FD0D7DA3EE8B35390B334D1D5B8FF009FD9BB6AAAD9A95F7CB20B123F1F3C56
+      209BBD333B905778DBF964674C7D9ABA69161698304F85C447C4D3B8774FA883
+      72260F103F020FC0B53DF13EE89239B6569DAB451CCD2B57967F4C6ED210967E
+      AEE3AAD3AE24AE80C85E4ED9DA181C9610771B05712C264721FE038DA6D17A99
+      B7EA3A1A351B79C7E32780B0BDEAC5E23DCF6E6AB6EAC29D82CF2C4DCCDE8EBA
+      DFFA8A99B048B8B726AD515E6976CB2C5366689CC87764754DB9E9984C3309B7
+      D2385EDC22F6E022C6D5B26C7AEE55538F1133E2601B79C9038DE0DF8D5F7F67
+      BF537EFAFB55638FE478EF705EB5C63D9E3C4F46B9EDC757FE3A592D5778ECAB
+      C62CDAABDD222ACF124F2431BB77541C739EEFFB69D1BBA36EF8371810652AD0
+      C45F85B87818B9048048115D4BB47EE7F51E82E0B652D80912B622E60C836248
+      9B7389BD7A53FD20FF0076EF62FBA78EE23D95F764C9C12494ABF19C1F257978
+      98AA5D4AB7C523C8F342AF2466E32D5BA320669761AD2D88E5113E4057F9F7F7
+      5BFEB2F5FE941B7BD057F95B0C6DA8E01AD9413762AA5209E2244B80C6443355
+      B759ED1ED7EFADC7FCAF6B665D9F5FCAF9323A65C8AA8E74CAA623EA0B2E0E95
+      7851F4866B474E3DC9F6DBEDC7DE9E31B9EF6F72F1D9B2B5C5B4978EE4AAA5A9
+      E48E94924772A4E6A73120B80DE4590490C8653234521193BFCB7B34EA7DB21B
+      6FBCD58F3631257242EA2264280C1B828D222E6FA9604D5F45EF3EF0FB6FBB5E
+      99D576FA76ACDA61F1B363D25C028C03E2538CE86D3A5D42E90E93034F1BFF00
+      50DFA6883DB5CE59E2EF52E3AA51AD5EFC890D2E06B423954B96021E4E5B13ED
+      5A97EB548516D371F1C4EEB0A7E5999763F7CECBFB819B73B7F750B1C84A8967
+      274691F4C089926DAED7E3A6E3D73DB5DC5D37BC3A3E3EA9B4395B53438F7351
+      47D2095006A6284C9C63216E274B15B8E787BFBED7253F6DC22CF330537E58AF
+      250BDA9F8EBBC4D1A71DDFFD3DEDFE2ECC3CE5999D792E2ABCB337ACC1271D4E
+      69B755B00B3AF6FE83DCA73EF8E94D431F10BA958923DC761A388685910C3238
+      5F5A70ABDDCEC40C27190E103E9F5092C42C926C1425E10F31F315A57C447468
+      5E1C7CD764AA2FC176ED9B51F7E2A540D8B6B4A11CA4A2D4E95B8A4939022453
+      2D849A18E144F498075D6F719326E301CCA9A821000B166812748812DE9B594A
+      92C4DF556B298F162CBFC79FF74A9F5490A24C0D57E17B83323F0ADF5FB0F626
+      4838BE2527E2B95996E98DF968B85B72DAB3C62B440C5C65AB346CC70D2E01A0
+      252785114CB3C8242243BFAE33DE9A5864CCCAF8D227497580DE2C010753FF00
+      E24F0008045AAFFA5EDB32650DAB5146F16086F31122449BFF00E42C7857A5EF
+      D33707C3BFB13DA5CAADDE5EE1AFC74468453F661AE2C4F27235ECC965A28333
+      5736C1961FCC3222E04ACE723AF167716F7DEEB19F679B10640EB10DA114D983
+      643C400482481100D88B1F18FDEFEA5D453BAFA86C0E2DB630F98FB8564B6951
+      8D94282DE96D3E9711A49FA02F1AF3A3FDE3BDED5B9BFBF3C8FB765916D57E27
+      8B9CD310BA131DFB77791A1245E88A077689E861C348FB1B729556520FD1FF00
+      FA97B1C98BB30750803266CF278911A51E27FF00DDC7489B1E06B3AE6DD3A776
+      2F47DA640464C9D3C6422E0CE467837370CA01041D3171E7C30E7A2B73550A95
+      E6DD59446D2768413431025A2673BDE29AB1665504307719F4E093D7B4F66C8A
+      F24C4FE327FAD713EA23246902C3F31E1F31C2A9DBB42CD960CF97D0A82C0AC7
+      12165214A9C6E24B952D83A1C63AD971E640B689FDEB547C4E4DC71A86727C48
+      0CABB5762EE691D347F57A7D7DCDAC4865F0031F1C9D3A9B8B717BF135073610
+      7D3CEA196F8E08486195265EDB06C10176B96C0C83818C0C0FDDD4E5CD6F3A84
+      D84CDEA31C8505CAF63C4B1C170DBB3A654EEC850A3395C9D7C09F0127166BC1
+      E22A2B2193E34C12D4285E394EEDDF33E0851226E3B72401901B3A67CBA7CE40
+      6FC0D0AA998F2A8DD9A2652CCB1E6367640369073FEADD90E7693E1E7D3A8F6B
+      F1A6C8A6F3446D7ECA82D8F56E707728218EE4CE4FA9723CFF006F8F47EE09A6
+      8A89B1BD3158AE634930095DE015C02C5BCCAE84E01CFE3D3EAD3C78D34C937A
+      62951DB7220721779C0DBBF7107243EA362E73E032060F4E8603E543A4816A63
+      B511F177DBB582AEE6F80048650327258FF1634C7EC7034F0A0223871A60B1E8
+      2CC7D3E3B58A90DB83781C15D42E478F4F022229B22F7A6D9995D7B6A58313EA
+      2E436E18D635C1DC171E3F1D723C3A705CCD0F95072E7D06552A3B7B460E36EA
+      34DBAEA57C01C63A5FEB43069AA6560E4EBE2E770192554E4B15C96047F17C3A
+      701FCE9286932BEA42AD85F10841C8FE2F0D00C8FDFD10F3A481C6863B88C6ED
+      DAE5B0DEB5C633A120600E97F7A41531CFE1FF00D919F2F0F878F45159514BC7
+      B7C9720DB55B372E01B89DABFF00132A7A8606406F87EDEB0DEB05ABF2856D58
+      10491919DA0B36E1A062C4E7427040035D7A036A5A74AB1A92A25CAA9C28DC80
+      6136333B23649C0000F89C8C78E00379518A37D3112CA9A2C995705320A86C20
+      55190DE058838041E86949E75961D4068A440C0064F41C2330F5ABE5756DA4E3
+      4F01FB3A5B73A48333CA9C60AC3BDB88248CB15C8C6542B8562564509AE1805C
+      634C79F4CB3785181CC54828524B0DE9454DEF231EE2821C291B804C0550FB86
+      3D58071803C430EEC39D3CAB4E62B2978E37471324BDB7127674DAE8C919DC24
+      69970BB981CAA96C1C8E9AD662470A3D17E7C6A4F478FDAED24D5C58450CE43B
+      48AA508919B163B7DB0B18009C8DA4AE00CE7A659E7E74E0C77FEB4F4BC20334
+      71D72AF23EDCA1916431B48D2332190BBC4E1D4ED2341AEA3C4964E5B49E147E
+      CF2B54A29F12CABB37430B3C734F2028D1475EB85C3EE8F712F36D527B65486C
+      85F510B88CF904D4844278D49A0E38A7D2C325588EC6FCF899CC0B661119FA40
+      F603C30C123E5880D287C0192751D46390124836F8F8E14E6863622D523E13DB
+      C793BCD2D84DB0376DE70918AF18854859FE8F20806BC0CB1040A40320DDE9C9
+      68B9F3E85B71F889FDE9FC58B535FE9A945BE2E9D72F0D2AF3AD64EE46496561
+      0C6A13F3E6291A229DD02F86A49C7A8E018A3292353913525B169FA07A4FC7C7
+      F8D48F8CF6E588EB536B627AEC5A44DCA0432C8F08BBDC86B48B295755B0D22E
+      F2E237D840C01B8C3CBBA4D65148F1FCE3E238D4BC7B770016FCBFA7FAD4BA3A
+      7C7D69F8A952935F549955DBBAED0DA584CED1A855592355AF22A6E3821CEE4D
+      406EA0BE67218031FE1C2A56245916E1FAD4EFDB9C351AEF13A3CEE69DCCCDF9
+      31A8499944B10819DE78DE14B837812478040206ED7AABDD6EF2DF54411FEBE1
+      CBCEAF765D3F1B9001FA4C9FF2E238DEE2AE0E1EBD88E6ADC9F175A5BE21C1E4
+      23B3BE5152F949A1A93B4E214EE49348892C4513423606DD1E46B9BCCF89D0E3
+      CC42B3708B48E76BF0E07F3E062B72E95B5CAF914E252C15AFCEFC8F0F972FDA
+      BDA0FF0069DB3EE293F4BDC1AF3DC7DAA558B77F8D92CC5629CD2D7B966D1A92
+      D786C3B34155F8E8A368B6FA27859252AB23301F29BEFBEFFA66DFEE8EF194EB
+      DA1418D9F1E4D0F8F2C2AB1575603581AC6960C27520D2609D93EECED57160E8
+      CCEE0F523B36D4B1C318725350E249D5209F5058FED205337EABFDA3C747CF72
+      CD6A8CBC8A589FFADDDA1BA6A53C1C6D4867AEBCAF1F25492A7D44D569519272
+      927D341345236F6698A375CF3B3B7876F9176EADA74B155368604CAD8A82034C
+      08591161C457A1BECAF58DD6F7B653062C8B88A63F651ECEA721657F6DC36A89
+      775411EE32BA8002E2D42B953FFA12093EE1C75381B95E3B9679A7ED4756A586
+      B7538A924BBFD060FA1B32556B36A9C96EB46ED07D4086E82AED23C4D9EF78FA
+      AE45E905B283ED84E64417B6B3226059B8C4AF0804575AC80051FCC5FF006FDB
+      50CC6E0D86A33F4E9600BAC91E92090BC2B66BED9FDAFE5AB7BA1ECAADC8658A
+      DD17E46E7B8A9DAB2D4A4E3B964325FA3539253159B73F21256292663ACE32B2
+      88C9C1D43AB77161FE190C61AF1A48BC8B4911602645C8E44D47EA99365B6D96
+      AC8F8B3E0380845C6C04EBC6671B152740D01A625E14945316ED2FD80FB41478
+      1A49EE4B1C650AB7F9459A68A2AF159AA2AAB4CA5249685B6923AB30657951D4
+      9056C1DBB54281A4747E8DBBEF2EA29B6C2E7F8AB3AD83E9284581724002090C
+      4824691060915E24FBB3F70771D4F707A1EDB3656D9EDC80492ADAAC6407400B
+      0B85208E38C4C924D59FF7A3EF67B67ED17B37DC7C84FCA7B71F9FE378DB1252
+      E16C72689C95FBCF4E6B55E17A757EAB947DF1C266D61655894B9F48C75DE3F9
+      BBD729D9DD1763B73B660D8F36EB12B6B60DE96D79752B64860AEAB91CC36905
+      60681CEBB37B2B77DC7D4B067DEA6E717436796CBA08C7A54FA82B3424F153A4
+      933302C48F29BFAAEFD497BD3DF7EF693DC373941EE3A748492C0BC8F2F048B4
+      A27825AFC95130C134B52E716B3CCF254922D632C0BEE7257AF4C7DBDEC1D874
+      AE9EB8D9586E185C95962664193707FF002F1FD6BB4770F5BDBF4DC0BD2FA4A6
+      1C1D3F19B263B270D3A985B531004B5EE3F0AE6EFB93DC316E81AF5692C589B3
+      29DCB3579ACCB451A3A1C9CD272CF152938FB35DD9DEBA065955E3DE032B6EED
+      BB3E9B0084B01F2313C440BC8317E22F1636E65BDEA9EA058CCF8CF11CEE623C
+      B9DA6FC75BB9FF0079BD57B14E94D6E8DE9AECB54349460AF61A0B8AEF66AAC5
+      1D98638C4AEAEBF4EE412B88F0CC508DAF6DD39490D9002A00E7224703F878D6
+      A9BBEA040D284E927C20DF8FE7781F8785521CBF3D246D1352AC647AD0DDAED0
+      CC57E9268A4CC05E6AB39678C4D14AA08324B22480481830C8BCC7B60DF57F9F
+      C7E5E115479B7243828380E1CBE3F3F2A8CD8F71AF1EF5D83C33A0AD6D20B49F
+      5B0C766CCA658834F0B09252D5B77A0950B94C8C1C13246DC38813123C387F9D
+      34FBAD30493201F1BD46AFF2825A2659258A7B72CCB1F7D846CB1934E6860133
+      D89A545B91BB49DE63B3B2CCA73AE55FC7882B472FF3FDBC3C6A23E62C266FE7
+      F2F3E7FB533D9E5129D763448779222C2C3C6EE2A9655599AAC9262359D63C2B
+      11BDC0D5F50A43BEDEAB1179E1F1CA9BD7A79F9CFF004A8DC5EE1953EA17BB2C
+      5310C23977C6B56391591F5EE097B3DD8669C8EDED6763962C01E9DFE38200FE
+      DA05CC40F3A22AF3F50430B4F093235A8D1DE493FE18C28FDC808792569CCBB9
+      572FBD485242E343D236DC8903C3F1FDA9E1B9016F24D48EB7B905C8C844FCB9
+      90CE557B325B823495A182192355EE4ACF1993D1BC07223C6C1BD8C76DBE800D
+      3E9BB26C2C3F5F8F8F1A25F94A561A4869C9661965482A63BE524B4FDC32599A
+      794E23D980ABB40D85C673A63A6BD87FA9A207E959EF2926244802A635FDCF6A
+      BD8B0D2C55B8F12C70F72B8EE598F91778E1610588A1288D5E78943B45216F4A
+      1C8C81B61BECF19169279797CBFAD5862DD324CD8C7E7FE47C0D48A2E5E1FE9E
+      8DDC497B339B3B2E24BDB91A6260430ACA3122A64E3B45771CB364A8020E4C2D
+      AC80227C2A763DD018A49BCCDE7F4FF2AB338AB8F4E653C7F283EBBE878D798D
+      4E4E0EE569E3D95AF52A372B4BBE0CA33B324721690B1F9B78EA8379B4C59B13
+      0CC80E3D46C56C79C9078F2B91FB56D7D33A8E5DBBAB61C87DC85B86B8360403
+      FD0FEF5DCBFED75FAAFBFECEB31FB5FDD9EFFB1C5FB5A8ADBBD6A2E5DA5B10D7
+      A094A611F23C7CF5682490C75F9CAF4E2652F3FA2C33380177A786FF00EC97DA
+      AC3D6319EA1D3B62AFBD6B038D403AA7FBA5AE74172080A6540066C7D2BDBF9F
+      69DEFDA397A5EFE33F5AC657DA6CAE2749654650CDA542805CC17E27E55E88F9
+      8ADED4FBFDF6F97DEFEC4E728DFE43FA599ED72FC04F5AE16A82B3595B9F4325
+      291DCC332C8DF4A635796638CEE08EBF3EC6C7AB766F5CFF008BEA38B32A7B87
+      56A06C0903FB40881E9264C719830751E8BD43AA7DB5EE34E89D77113D1B3651
+      ED2E4908E4B6985CAB902C30D23DD0C42289882CA78F1FA9BE197DB3C153E25B
+      DB2798E4A0E4EC7257795E32AD8A34F8DE539CA5F514F8B341A479E840CB0DAB
+      AAC641F592C9382A823729DE3B1373FCDDDB6619C2028000C43165060B4F03FD
+      ABFF00A8889313EC5E89D51FA86D1B73B22EBB37C5EDE2C6591D8AE162AF94E4
+      1A759F52632029F6D571CB10E09E3C7BEF8CB507B8AA477B86B152D5BB79FEB3
+      CB43752B49C2AD5BF57977AFC7C907D11AF3F291C3B268D7FF0031DA61B2671B
+      7D4BD13738FF0080C71E556C489F4295275CA94969D5214B4A93F4EA17517ACE
+      A1B47C6E84AFACDF5198B083CA209E1CA63F0D9DFD3F345C4D9E27FAB4DC8BC5
+      1D79A9D5A2D1CD17253C9C6D7E42F475E078A39EEF133D6B1655390AA2BEC9F1
+      DC90059085E6BDF25F70993F88AA18992D2348D6554923E9706271B9691F48FA
+      6FB2747F7C6DD541D0FA97D45640122675111E9916320DED615EA53F4D9EE2E0
+      6C7DA2E3AD71D61A7A7C4D6B5579186268AE45565A535BB3711E0E2CD81F58E6
+      C319E38CBB3C81880A72ABE1BEB446DBB972ED37D85B26EB3321C7A895C6A3E9
+      F57AF1B106D023D71008926BC05F7A7A47554FB859B1EE902E7DCBABE3632858
+      3AA2A10D934FA069010B001560126CC7C9D7EBEB9EB9F72BEFF7DC1B92C1FD2E
+      98E5F94B2B72D258929723F516E39859E357E9EA431F7C3972932CF2000B34C5
+      80DBF553EC4ED93B7FB2B6288465CAD8D35005653D370F73306DA97482782815
+      D5FBBFA2B63D9ED3A0E50D89765B1C3886AF55D31A28D247A4917B00578B2D88
+      039957F81545990686BC9F973CB1B0AB3A9329105B722410CD21DDD97C88F2A1
+      4AF8BAFA8767D4172A2B5848E00DC7CBCBC79F3F23E6EEABD15B6CEC2E44D891
+      C78F1FF0E5CBE55DDBE3A5B056074FCA67382AC026C64898B878B5C6F8864A92
+      54674EAFF1EE31A8D608D51F1FA56A79B6B91BD0C08BDBE3FA540FDC1C24F5B7
+      331660CA109F438CE061D1BD2F94233A8F486191E07AB1DBEE838056AAB75B66
+      C4E75FD5155E5DE2E55591A4246DD36B000EBB41450AAC11F6E338F1031E3A9B
+      34CE0D871AAFC9848F530814C6DC5BB19241BA38F2CAAC3C1A40B820E54632A4
+      904E0E7CBA92B940E3C62A33E0933114D76B8BFC93804EA739C36E2CCA4B2AA9
+      1B998A8D4EEC03A74E0DC72A6FD981278D446EF1EFBA588C6C855B70071B949C
+      8231B724153A91807A94996C18545C98E4C1B0A659E9A2249208E547059839C8
+      52A777E5FAFD3E7818D727A7572127CA9B7C43C2F510B913A49B4444100E0FA9
+      58EE2599F7632549240FD9FBBA92990449A68A1E54C33570BBC60AFAB6866620
+      904B2AE32159B0849C69A6A474EAE43F8535A205F8CD476D559F6BBE0B0562B2
+      6092720E9B946DC804F8818CF9F4FAE41C39D34D8EA3B6A14C01B147CA41D31E
+      3AB9C1DCCA18E3073E38F1E9F56F1A69922FCAA3F2C623C0DC35562083B7687C
+      018C0DE4871F1D7F0D4F4F86934D911424CA446DEAC96555393A904E72371CEF
+      F4F8786BD1837F2A13E34DECE7D71672ADBCEEC11A329525148C9DDA6338E9C1
+      C679D05B9D37BE1032F8C8AA55F5C80AC738F2C13B7F6E3C3A3FDA92073A0CE0
+      6A090FA01AE7391AEED06A083E7D173A1361534ED1FF00F26FFF002467F9B1FC
+      DFE8F97F99F874B59515E4D15F91B618E82E59195D47F3E62324E0672C463CF1
+      D61A5E54B4182143659546A4AF9FCA0A9249CB10319C600D074069453947E921
+      70318D57D2BF2B0055F7ED61B958FCC01CF90E80F0A3E22960A371C6D40C3D19
+      1B5175F15231BCAE3CF43E5D21A4E514E3081E2B1866552C1D886C2F6DC1EE0D
+      43162DA780D083A9D018F2A300F134F55A0DFEB4AEF1EDCEF5919889666DBB19
+      51722289D86082D83A03F8B2CD6B9A700916B54A78CA5890860124DACC9B9416
+      00C9DA9635951D21ED23AE4FFA4E31903A8991ED6A7C219A9343C620B430AA95
+      A57B732BC6E4CCC685533AE257DEE373B8275F1F02319EA31C862398152131F8
+      F03FE1521E3A39EBD986489752D55B1089638F74B1A7713B48C0C8A8CCC55B19
+      07C35C663BBD8C9A7C23036153CAFC2ADC3845FA9B3F39AF134AD6A50929EFE7
+      B7188C39C100FAF07009275309B36833303E229E5C40F0A9BF11C42BB42731CA
+      F616102BF697B8DDF6547769A4779D8229014E729A10464E613E6BFCB9D4AC49
+      3C224F2A91D1E0E9DC9272D5B103C99916E71C92D3AD2CE4244D24A92C423AB6
+      4C0BB0B165049629E927A8EFB9648BDFC8DFFD6A426057327F6FCBE43E22A4D5
+      BD997E188C638EE5034C9562A75D78F97BF68168CD768658FD25D268C240A8AF
+      1CC85549DC9B4C47DF62264B2F39BF0F8E7CC71A958F63900BA9FCB8F85FF6F1
+      A90715EDA334734494269238D266BD337D67D458AE58C7146D1D2EFC08CD25A5
+      42BB650B345EA381201073EF825CB0B9B708FD7E5E563F2A9FB6E9E729855256
+      2F00DFE3F7153493DA32DF8D2586FD5A3C4C0F4E386DB9BAF4D2758ACA4B4788
+      5A54AC5AB72431A996D4B2AED32CCA5F0D2E0D53F52C78DA08273785A6391692
+      009E0A07207C2ADC745C8CA194E9C561264DF9811731C493E2278D4ABD8DEC6F
+      71FBB6C71B478CE3ED723BDAAD6A714F5526923B525B7ADF491D791E5AF259B5
+      63BB0A84C23590814EE573D52F57EE0D874C47CBBAC8A9009378B44C93C80106
+      FF00DB3E22B64E85DA5BEEA8EB8B0A3302201239CDC47E7C2D311706BA83FA7F
+      FED99F7CFEE1723C373F37B727ADC27217609B94AB3C924776A7175F955AD6EC
+      35E5AD1FD3ED08E60B1BBBC80ACA80C6DBC79B7BE3FEC8F67F414CBB3C79C64D
+      DE3431A6EB3A66E27870D40D8DC71115D4B69D83D3BA046EBB9B77836A2242BB
+      80EC6352AA0FA99980F4C0B70241315D9BFD3A7F6A2F62FB579F9FDC5F71682D
+      88AAFF004DBB56872BC9C3EE3595B8EE4A3B0961E3BC269BB11C3DC84B4A5211
+      F54308EC8AE9E4DEFCFF00B3DD63B8B6C7A676CBBE3703D5931290511A118B68
+      FA44B299681223589209EEFBC7B4FB5F086EDAC7FCFEAF94B2139109C78CE93E
+      D956612D9558970AA0D97D516AEB0F05EF2FB49F6E38C97DAFEDEB94E953E265
+      E415B8FAEB324535AABF513F208B6EE811B494A1A5212AF21D8B1EC1960DD797
+      736E3AE6F37590EE17266F7069793FEDE51A8696287D4A6496FEE20C0500493A
+      4F50EDAFB83DE5BD4EB7D5B164CBB8CE98E323412A8DA571FA12E0317500AA89
+      2DA8C08AE76FEA07F537C4F357E6BBC5704B347C3FD7CB5AD490F13778BE478E
+      94C152F598F94FA8EF7173C75A63DD8B74C9348A31DA9C2375D13B2FB3F73857
+      DBDDE4F564604A8D72AE64C09B9079131612444D7AB7EDD7DAEDDF6AF4C0BBDD
+      C333E7542EAAD911F1324B00719013302C3D27D0C8267DCC64A9D7CFB6BED3AB
+      CCCB172DC742D0354BEB7A92F3D27295EE71BDFB70F377798A7041DAAD5EA712
+      D13EE58274A3664608628A5725B7FEABD45B6C876F9889D3EA2B04340D3078CC
+      FF00EC350FFC888AE99D577836F847F2F5360C884108A864C685C259896D5989
+      58F4EB44058160848EB3FD92FB0EB4ED27B93DCCF0F24D6E387948AA58482421
+      A29E478E392B0B3342A1FEA092D89049090A707D479666DC6EFB87A9374BD9A9
+      5C7801761206B55640D1752C409685D4400CC015063C77F733EE9FBDB76E8BD0
+      836054638D9D4B09950090DA4318D20012BA5E4DF80BC7EF6FDEBF69FD8CF6BA
+      F23EE2B756ADABEDF4BC7D53623AD62456263B1728C4619E2B27894FCC3000A5
+      800172C40EBB4EC7A0750C8FFF00E23D2B6E1774A8E733AC050CE09503496034
+      121A072652CEB935471EEC9ECEDD777EF326E9CB2748DB7AB2E42A5966352E36
+      32AC0E582030936262057967FD4FFEA38FDCBF77FBB636E62CCF0F25CAC53C76
+      5FDC921E21EE54B514AF225468692D6A96ECC5208EC475C3358EE0891E50E0FB
+      3BEDEF6565E8FD2F6C995175A25C0C635411CDAE49F193711A8C4575DEE1EB3D
+      3369FF00D0E9C0A6D30E35C68351D30834810498102071BCF124D72C7DE9EED9
+      F999EE5758FB69C75577AB5658A5AEF71A72B88A7EF42B045271F3CD1C624621
+      8060082A182FA0BA6EC1702AB7326FE5FACDEF6FF1AE3BD4B7EFB8660C797EFF
+      00D3C6B5EF9EF70D8B31DFAF0D2E36D4CB51ADC925EAF1C97A0A91C44C93C569
+      3E966FAB370962E9B08202B2B2ED0BB56DF68808725809F1B4FCAF68AD5373BA
+      662550036E7FD6DCFE5F2AABAE5B9694E2CCF01FA89DBEA6BD9B71C9DEE41AEC
+      4D0D398DB89A45648EDBA82B9573B55BD209EAD171060545C47E51C6D55D933B
+      013F067855797F91AEB34693385956D2D59E0B524CACD1A19E2B4D2C7C7169EC
+      66CB299403BD5A25423F301EA563C4DC85A3947F8FC5FCAA13E552249BCDFE05
+      402C72FF0046F19B53C0F3C90958E1B0647895610F03406138FCD889555F5781
+      219B21BA94B84B08516F2A659CC8E7519B7CEC92BA95530C2D3801F677157708
+      F757494B8432C92B13B4206CED1E27A90B8473E342F90C79D0E79C92D23C4AD1
+      CA95A9FD3E080B23059104565207986E741EB752C515B52707017D92A662E4D3
+      2333358C401414B79ACBC911969E4D8CBB24AB2215EC9854472EE895A2893715
+      C0D8A345C803A354D3C8F0A2F72D062B04B3159816BA6E9668E18FB6B186D8C5
+      63631B6220BBADB8463B4A9000CB36063A238C9F5729A6FDD2CA40E35F2BD895
+      02D893F3910AC93C658C64A47346B142922AB1890993240C6E539CE707A26411
+      14AAED6F8E1523A1C8CCD8599F6B481EDC1DF1F9114C2121A2EE3B2C1DF9E38C
+      047EE7701037659C622E4C422C2D4FAE42548E5C6A4ABCB2CC913CF24681A30B
+      2C4F20525E2318AF2CA5103ADA8E1DCBBC9DC06338232D0DB111E75293206E76
+      A78E3F939DE358A35EE0A888B1C05C88EC59D855A4B0259CED915811138182EB
+      E1F3662E4C209F33FA0A909958A8F0F0F13E7FE1534E1FDE13D6B0B663B2D726
+      84A949C3C10989C662909586A2361209DCF7448DAB02AAC541EA06E362AEBA62
+      C7E3C7F4AB3DB7506C4E083A88F9083C26C3F5ABB7DAFEE3B5C53B4F4DBD752D
+      432D39A3B9EB9A688C4D1C759CC2B5AC44B6087495A14263C0200D4EA3D5BA66
+      2DCAE8CA01054822278CCF3916E53C6BA0F42EE1CDB01FEC922E0C86893E02D1
+      C7818E1CABD0E7F6D2FD7D7B5FEDE4DC07B0BDE57794E238BB372FC362D4F6D2
+      54E46D3C52CF4ADDE6AF5E998F8481F90B5125597D62C47DC7662D16DF05FF00
+      D85FB27D4FAB63DC75CE92832E5080E94D4845888075DCD94B47A5B1964882D5
+      E8339BA5FDCFED54E8257163EE4C208C0F92F218A3B2A42018DDCA05F71E4C0D
+      3214907B77FA8DFB45C27DE6F69F0DEEDF64DBA36EB011DB867A15104972BDDA
+      F75D25B13D135F95BB54BD88B7287630C6A7180B91E0AEDBEB3BFED5EA6DD337
+      A326A59D61A2C438E0093234FF0074449D3E355DF69BBEFA8F6075ADDF6C774A
+      66C79583210EE61194A0F4869C48D01A08D3AD88BC983C3BFD4DFDA193D84F4E
+      EFB86567E0EBF2F5F92E738935A695627A9159E30C9058B25B97E2A29C71E229
+      0493C91BCD340CBDB6923CFA77EDFF0074FF00CB87C5B511B96C7A71B0200F51
+      06E07A588264428200699835EAFD8755DA75FDA26EF604BE1E3A98833E957852
+      BE963A4EAB0FED602E8C46A6FB2E7E5389839A9A6E338EBB762E525BF4A2E539
+      1A72F3629F28226865B1B6E4EAE3FA74F0892C3496E37721164DFA9E91D6536D
+      B96C68AEEA8D8C2928AC1252640B0FEE06161081274C54C53B8C631C3FB7854B
+      6B06097242E813F52E9B925586A900EA1C3BB9FA41FD5251482953F71C7C556E
+      279CE23888E74AB1BC2BC0371F639DA7622983015CD3A932BC28E634EFAC7215
+      0C141EBC95DEDDAFBBE9DD48EEB6C8D9063CA43068F5AB0520A92AF0E01D42CD
+      C4061722B867DE6FB4E3B8BA62F58EDEC9932755C3932B15241394B8C5751670
+      59949B595B48B4C54CFF00501FA08FB57FA88A4DEE7F684FC6C97B9A98C8FC8B
+      4B0B56B7C2A45C84305786609BA18B8DBF83069B958B9D0A026EFEDDFDF0EE5E
+      CB1FC0DD8C876F85495536200659689625881057519E1E678EF4DFB9FF00F1E4
+      F6F7DC9D8E49C18D7196452338750203826183231631C0AA69FA8C7313EF1FF6
+      84F72D65BF73DBF143256838EB33C7C770AB24AD33D7969D2AF5AAD8BB6E516D
+      8C2A26314ACEF398D802864DEBE96ECFFF00B5BB13A36DBE27DE623D592DC658
+      C85022E74CA8F4C830620DEBEEBED5777E643B5DCB6C9D8AA05C834C4AD892C5
+      805007A8B9D336913238E7F753F4E9EE8FB67CBDFE2AF703CF5486192ED7AB27
+      31422AED3548AEDA812C100C3F4E0CB57676C91AC87F0C7AF3B57EE3F4DEE2D9
+      26E7167DB9760A48462618A8245F8F1FD2B54EE1FB799FA6E5236CB9326D5A74
+      B8D2CACA49D2C19491711CF9D50DEE6F61723154AF2F21463863597B703BC522
+      C761DC7E5D71BAA450C88B2EA7D64A93AE83037AE9DDC7B7CF94E3DBB6A3126E
+      3878F127F4AD37AC764EF3698C66DDA04131041F0B0FA40FC8FF00952FC9FB5E
+      088C91765B7C6F126099620CE63329EE97503738524160369D3C4E7ADB70752D
+      4241107F4AD073F48646D0C381F947FAFF009544ED70E906E458A32FBD820019
+      4E7055412FB7393E0DF0C6BD5862DD13724E98AA7CFB309F3BD45ED7065FB81E
+      BA24858889D14607AF126E68F2AA1770193A9246A7CA6A6E01E06479D573ED18
+      5E2A33738C42AED18190A77A615776CC824EA36EC18F3D74F8752D331E751DF0
+      098FEEA84723C7148DD824651890C776A183673EA236293E01B1FB3A9699B993
+      7A8AF8895AAFAE56DCEC4050CAC158EE002A790CFCACC776739CE9F0EA52E4E7
+      4D363FC85315989FB781AFA8EC06590B677AEE0EAE594066D741E3FB3A908DCE
+      A2B298F2A8D4F180583E5159492BB7C770C6175F98938C918EA50379F3A8EC22
+      472A89DD8F39664D8A8C502E3693EA195561804AE7C3E03A96A79D32CA39D45A
+      E000300A14A8249393AEEDA48CE5BFF97BBFD98C75210CF1A65C0A6696550850
+      E19D86D20E723C7071A9C6B9FC7A7978F95344D04EC4ABB07DCE36E4EDF95065
+      739201C1D7C3A705BE543403E01C9F50C6412CAB963E3B89F8819C0FC3A317A0
+      22877552A09F490D9054609201FE2D0B0DC3C33E23A204D271A9764FFBDFF22E
+      3E73F37C7F6F4B3591FBD315C2ADCBDE38DECF7AD7A5C02322C3A80C0051EBD4
+      68741F8F4A66B045655E166C0D40C7CA119BC1CA0DC17243641C647406056478
+      538428E55CE7591F6BC6C0991D8065236FCDE9F33E4C7F7F40638D18F2A2D514
+      6E28E30A558B12A87E0FF97E9DF1F8E0A67F03E7D01A5F314F15A16571B50839
+      DF1465596493E55DB11C7AB68941C1F138DB9F1E9963CA9D03C2A434A96F58D5
+      58ED76462BDC8CCCA242B97504E3B784D738C789F874C646B79D3AAA2A6F42B4
+      9215249710A345B5564976C7DC2B1A99630634758C86F02BF1233D427615271A
+      DADC6A61C4F196EC5911257631C91AAFD3A86982C6EF1C334F598C733EF6C7CC
+      0619436D240D21E5CAAAA49E3E3FE152F163666D205AACAE1FDB575D5648AB9B
+      6BB911992675FCECB22B651A394CCAF2EEDDA00A0A804375579B74B241316F2A
+      B1C7819F809352EAFC24C668285866AD16E8C4C1563545BD6E49A6AD33464545
+      816C2900CE8301B7107764086FB8B1C82E797C871FF4A7C6020E9361FE2785BF
+      C7FC6A5ABED4929A086D413D3B092A5C68E545B57A4696388D149E48D1E3819E
+      095B08247DED9DE81800611DE2B9D4A411116B0F3F9FC41A7F1ECF213EA523CB
+      8FC85B87E7572F0DC65B44E378FA9C71FEA36E94F5A7B1023B992448EBAF74D2
+      941ECE23568D89118761BCE08006B9BADE2A06C8EE3403378B71E7FAFE95B4EC
+      76046840875B089BF1F97CAD7ADCAFB4DFA4EFB9BF757895E578AE05ABF0125D
+      28BCC72DC9F186CF35C8D9FA54ACBC7D6E4F9B8796865482E3AABE62ADD8881D
+      EF282FD728EEAFBB3DB5DB0ED8B7F9BFFB28B25555CE902664AA10784C09693C
+      00AE95D23B03A8752C61CA1C7B723516682483C1802DA80E23F0E662BA67F6FF
+      00FB31FBB79FE278AE67DD3CCF19ED39F94E2B8F86BC1C3DAADCE45C6D285A47
+      B13DBE25AC71F4EDFF005A11579222B6DE585B74B28DEE605F3BF71FFDB4E95B
+      3CE76FB0C1973601A9CB302A5B92C5B508218190070161EAA30DD81D233E6C19
+      F739326FB6E42694C2E10B030EA0B0995B824A80584A9653A86E37B43FB3E7DA
+      3E2BDBF04FEF6F753F337E18A3578DEA352A9564EDC11F213456E8F3EBF475AD
+      495C4F8ED9EE48DB180091B2F17EE1FF00B49DDCE5375D3312E2C79729C60637
+      C39E0C9D2731D60A289D3AB4B390561353696B5C1DFBD9F8B3FF00C7ED7A264D
+      EE2FEDCAF9991C92070C4B885C9FA97DD8510D2D0146D47B1BF4AFFA3FFB0568
+      7B95B83F664DCB0A0DC84F7AD4DC5F20931867512FF4EA77A635603C84B3A8CA
+      A2C8E8AF28909EF03C77AFFDD0FB9DDDFED6D3A8EEF3A6C32178F69AFE8D4AAA
+      C52FA59AE58EA010A95936165B6EB7DF3DC1AB63DA7D39F6185B2E8FF6F16457
+      5D4B32F9002C0A85258A90BA9B4327A94D5C09FAA3FB7F02D8ADEDDB35B8CAF4
+      792FE9EBC451E221AB5ADC125AE668C172ADAAB582A5A97FA326546EDD13A18D
+      9BD5DAD0377DA7BEDC95DC6FB13BE620FD4C0100899D57965D4B2CC1998A80C4
+      A8502D71FD95EE7DCB265EABAB71B8C983DC395B317742170B94746624A0F75A
+      09886570E05B5EB2FBCFF54BC525CBBEEC7E47EBE2769783961E222B8BF5FCCF
+      D0D4AC9C3D213CD14F6FE95774F3A4ACD3C72570CB16C084EC7D1BEDFEE801B2
+      18CAC8D5EA88D064EA6B444C4458C89335D97A47DAAC5D3BA6274CC8A13430C8
+      A58A39440EEC59B40654731A53480AC8E417D448AE7BFB87F515CB7B82E59E26
+      DDDB9C947CB52E5BDCBC42477A4AEFC6D58AACD6125325AA96E44788D36AA4C2
+      DBE170E6276D58F6EE9FD8BB7D9E25CE11546264C6D699320400081C08613622
+      3501CBA863C7D3B62026CB1AE1CC1029D202EB41C9B480195CC9F50326350D2B
+      155FD1F7AF31F73EF70B6398B5CB4B745948F91E3EC55E3A1E6656AD1D09EF96
+      A55E922F2BC6D936F744D76398CAD1CA1B08369D833F4ADB741C5906D971C112
+      AC0B1412485F5162558441D04402B173352760D89BFD9DBA8C5B755BA82645B9
+      12656C2D117AEBFF00E943ED9FB867E738AE124E4EE54968B4B7A5B50FD2F2FC
+      7F2BEDEE12D5B1ED1B8D35A9903C17E9496A581A178F3B24578C0023EB887726
+      FCEF371ECEC15BF979B82AC29D410BE4FA9946A50A6C4C7032DC0F1CFBB9DD9D
+      3BA676D66DC3E0C79719270E30C5F1E54C991506E07A757A959712B870635295
+      6925EBB095FE8F8EA8F2DB90D6A94A159E69DDE4923AF5EAC32BCB308656290C
+      51460B3050B851F01A47ED8E9BB575197ACE3CE8F8B2E021D54E7C8405C80B2E
+      1C840004A3324E36D2A55B42CB2F829FF95BDDCAE1DB0F737395B4AA80016676
+      015645C926C099B9AF2A1FDC4FF54B77EE57DDEE624E2F968AD7B5383E6ECFB6
+      A9F1D4E6E41A8C515447E2E33CBF215B30596E763AE6EC55B6C32C0CEDB04AE2
+      651EF8FB33D96D83A3A754EA2A5BAAEEB1AE56C86E4EA86950E490413EA32559
+      893080815DFF0076CBDA1DB5B6EDDDBB2FB9844E68B1399C9670DA78E89F6D78
+      9D280026B8F3CEFB8A30D271934BCAC95A5B0D69238A645824E54237D74F2D8E
+      F473F7AD475114B181E22AA311A6E207A7B67B2D206550BA808E1CB95AE204F8
+      CF99AE47BEDF7BEC51F5113324F3BF3FC3C22395EA95F70FB93961C4D7FAEBF2
+      49C677ED7D252356A835FF00A6ED6BB62A5BB119747B929CCF9971216738C205
+      EB66DB6DD3DC8551EE733279F09F972B56B7BADC9090C6D2401E11C627F5AA5E
+      D7235E4685AA52795A395A0FA492CC5DEB4D663994AC7B1ABE157B2C1C2076CA
+      819566C7578B888B1B73AA462A7D405FE3E5556731CB4CA4C6BBA2AF109AB882
+      58B2998D59A185F3625D8656D410C0E08704674B3C5885CFF7556E4C84CE9FA4
+      55757B94B32CAB2C8CF1C8E249EC1CF7242205525222F21C13080CC19C0CF9B7
+      8096984701518E4E5CF9D41ED5F5B3358B72CA9298628817453B04ACCCEE0807
+      F2C1B121F01E249C6352F8C7CA22690BDAFC45335DBC892F6E3511451CCF3891
+      4194C6CF281B76A208D6BC050677633E2A0E065D4C5E3C4D305C2B11FDB4CBFD
+      41A9C6AF1B8123CFDA3219610E372AC936238FB963B9148D85EEA95034F9B3D3
+      C31CF1F0A6B5817B4D11072EAA1D2248A3992281434CE151A7467774C48ACA98
+      27D084871201B8F9745ECF33C294BDFCE944E50AC88D14122D888B1B2C007D81
+      84BF54BDB2E823497680576E4852A4E746CD1E983481C70A721C8C6D186159C0
+      924C98E232089655CEDDB5C4AF21CC8803190000EA3CBA64AC9834E87FEEE546
+      D5BD31317742CEE17BDB64523B724C03B4B3B850F334A912677B0CA818DA3396
+      DF18E029C190CD3FD2E657BA9B5C4603920EE8D1E16F537619E50D5BBA1230A8
+      7E71E1824E3A61F073F2A34C807CE8E8B9540C1E3EC1817B4CD58BCF34B1AC85
+      DA601951424B1EBA7933B69FC2AC360D36FEEA90B91B8AD49A8F212D7B109426
+      24688B191160293D6D82685258951E1B24490860242C4B8DBF3686364C4BA483
+      07FAF3A998B214F55A7E3F0E3568705CDDF5B89C66F8D25FA6051632D046A866
+      6EEC966C4762182386189181D7B2107CB939EAA373B6C4C9EE11227F1FC2D571
+      B6DE64D417FBBCAC3F1F955FDECDE4E4FA68EC3D5BC44376A598A1838EB0C278
+      E4ED4288CC88C5092AE899DECCC58AE4B65B4BEB3B139414C710508327E3F1E1
+      5D2BB67ABA6D58663A89570622FF00B13FBFCABD317F6EAFD68FB4EA53E0BEDF
+      D99F9AE3ABDB921A5C3DA1C399EBF336AD72ADC671BC4BCB2C1C74748C55BB8E
+      B3ADA9D77802452400DF34BFEC17D97EA39B73B9EBA898F2AACB3AEA82815353
+      3FD44993008D2205C18263D35D5BFE27EE4F6EE01B76C67AB6DF090A7233E384
+      1ADA174A323B128A3411A88242B0635D10FD6AFD98BDEE9F6773BCC7050FB7AC
+      71FCBC26D5F4E53B7DABF7F99A9171D5AAAF2091C73D88E38A1846D161A08CA8
+      648D6658E41E55FB71DCDFF13D6B1ECB7AF9573A64B44EA55521B819BC4B4C49
+      92098905AFB19DE7B25DCAF6D757FE4FF371E37C7882862157116762D8F542EA
+      667F57B63219BB942CB5E6CBEE2C57382F70BDD4A9591BFA0D45E428C94ABCB5
+      F8D99051D8A2FB568E0B311E3E1492097B761D6B92B2912664EBDD1D05B0EF76
+      031B312BEE92A431961EABE9991EA24309596BAC8B57A2F7C72EDF2928000241
+      23888E322387CAC3E74B7B43EF3721C6B430BF2E5A4863A902B2D87A4071E867
+      863A4129847B95F884B9F93185D9242776D555396BAC768E1DD02E31C234D88D
+      5EAB12D7FA4BE9B99906D249A6F69D60E372A594B800830070239C711C67C003
+      15BBFF006FFF005CDEF5F6AC7171FEDFF755CE552BD735AAD5AB6824359E0BB6
+      6D6FA94E4866A3720B7DD9659256AE92338DC70091D71FEB3F687A76F5FDFDD6
+      DD7136A0DA88B9B0892086054C003510018A8BD63B43B1BB9F2B66EABB2DBE6C
+      AEC4B301A5DCE954B3801C8555000D4028111C2378BEDC7F731E12EBC3FF00AA
+      67B10D56B152778C55B45E257B2B567805D921B1040F2A11B704A1915803BDA3
+      0FCBBADFD95EAFB793B21AB30040218781BC4CF33E7041E00C717EE0FF00AF7D
+      BFBFC6C7B6F2E9CE319139174AC9129216261A54DF9A804898DAC963FD38FEA0
+      EBBF2DCEF17C27D5A2C91F2BC74F242F0DC92065B75EB9EF665778A4B9196DF1
+      0DA4323029AB6A7B7EB3DE9D9ACD876B9F718D74CE3324C71103810481A411CA
+      5E645B976EF0FDD6FB6A3FE236CCDB9E9CE47B6CD8C640A2EA4C10C91E868863
+      3665218DA81FBBDFDB63ED4FDD43372DC12D7E2AE4B1CAB11329485658A9C152
+      15B09550078E56AF890806411310A068CDD5FB2BFEC2F7576FE9DA6EF5E444BB
+      031304963A64C4892400790245EA30FBBFB1DCE13B2EF4E9E3367B4E5C434BDC
+      DCC12036958500C03A7EA1263945FA92FED3BEE5F6DC97B99F6BAB5DA0F3FD52
+      D5A6A96248E822AC4BB644748DEF2328CA131AEBA1232C3D45D81FF687A7EF86
+      3DAF5321336989630099E244485F383527074FEC1EF724F44DC8DBEF09138B28
+      D0D302C84D9A6E564AF000C1AE437BDFF4E7F70BDA1CA5882D701C9B470CD384
+      9E6A532CD2C7031DB1A36248619408CB0DACC46E18246BD7AAFA27DC6EDFEAFB
+      75CB83718F5102C184027F22479C0AD3FADFDB4EB5B3DC32261764F1D3CBF51E
+      763F89AA9B91F637251194DAE3E7ACD10FCF59616773B1817498EDDCA5190B33
+      7C1718C81D6E3B3EBBB6CB1EDBAB4F083F947F4AD1FA8F6C6EF6AB197190C38D
+      BF7F9553DCF71914734A1958EC6D4AB2234580221198F678AE4823E03F6F5B26
+      DB765D41B47C1AD4773B138A41B7CBFA554BCC57DB23C4E18008C40C86D81431
+      0F22E016FC7F6E98CF56B8726A008E154B9534D56566208ACAE8186EC91DBDC8
+      C5B217070A5739D41F3CF8F564AD266A190A3D351DB25591B0A885582C8342AA
+      4E49C7A57CC78649EA5235437461C22A0FC8963B8820E631B372ED3A2A83B0A8
+      D41C67523F1F1D6C313454475373CAA23659D0B82CC80E76C65B72971A68FE00
+      789F2C8D3A98B7A8AF6F95466760DBD893BB07073B14A83E0ABA61B4CE33E5D4
+      A51151DC4DF9546E4192EB919D4F8EBB430C83E43C351AF8F4F8BD326930E154
+      FA97C0AF99F9863E030074516A1179342820A30C81BCAEBF8A138F86013E79F0
+      F8745C0D24733C687906460E76A649C63C490092324104FCBF81E885272A9A69
+      F8FF00C8B8F947CDF0F9BC3FCBF1E96B207EB516E47D5CA5F1A8C5EBA001A93F
+      F10E74F0C67E23A3A1B72A2EA85C866CE0AE574259880352701401B0EA753D36
+      D145E74ED0A10824258451EE8D8AED18466002A1F8AEFF0003E91E5A6DE80FEB
+      4A279D2D0C6CFDAD9924160A8410C5C12BB189501860EBAE000327A0363469E7
+      524A9196EE2AE766518A330014C618BA22A9520E49F529F01A67C7A8CE60D3CA
+      27870A98D748E2915B6ABBB61090118ECDAB2481FBC262598675C939000008EA
+      2BDEF52514454F38C8D6710202555446A0AC4C5EDC5EA915911111FB90A2BE9B
+      77601C0F0060E53126DAAA5E31702AE6F69D25212A07ACACCC08467699AA220E
+      E2A473B168A450F1ACA423053226D6C1EA977592016BFF005FC3F4AB7DB63D44
+      0B7C7C7F854EB8CE3EDF2907722706CCA36DD89D31324EE6D54A9B1123584AD9
+      8A448C10C4F71D574240EAA73E74C465ACA387E84FE5C7F3AB0DBE07CA6147CF
+      F611F855B67D8DCB58E425B7CE7156A835C96ADA8AB2FD3CC2AC57E655B16E31
+      148B664A685DA6991065A4619642E734197AC6DF1E2D38DD4C0238C491CBC279
+      0F2E56AD976FD133EEB2EA65601A2D6B49E36E5CCFEE2B777ECC7E8C3EE7FDC6
+      ECC9C7F16DC8F10399FA8B6F372B019B93E352B99A247E3AA5F8E3E42F5792E0
+      6B321FF8BAEB2448C0464C438D7777DDEE81DBE4E1CD974EE992140078CC1824
+      481631FDAC4345EF5D0FA4F66E04C7FC8EA39570EC838967B0BC950D7805B883
+      E1C4816AEECFE9E7FB6FFB0FD97C4D7E73DF61F9DF7547C7C9157679EC04AB74
+      F242E54B704EA62B097B87969C7DA937CD5652DBC4236A75E37EFBFBF5D7BAAE
+      2CF93A4EAC7D335102349034FF00B6DA957536927506D4A863E96612D4EEFF00
+      BDFA1F45CD8763DBB8172B2382F9DC025808680AC0FA5A60A9D0EA57EABC2F43
+      3D97ECBFB5BF6878FA7C34561A946D24EB0D37B1724A501B7325C942435E248F
+      8FAA88824658CC10207F42277114F08DDF72F53DEF533D43759720DCAE382571
+      AB82EB908519640766D201C8509B4431241355D43B83BCBBD09CDB5C2830228F
+      A55418505606A27512C48510CD682484622FB6F79F051568A59F96A75E1B7308
+      2096C49F4B119DA58EB2432C96041F4ECD6258D0F73660C8A4E15813AEB75ADE
+      6EB166E9E887F8EE0B7A6602C1F487F4B12C5546980D058DD218697B7EDEEA79
+      B31C7876F95F2E35D4C146A3A60B1601756A850C7D33F49024822B557EEFFDF2
+      A55394A35784E66AF33EDBE3E6E3ABFB8E0E22DC3CA52B2B75F8E86C99E1A54F
+      906B3147695BB7B3BAB6586D4277EB9D33B7933A055C27D4158032ABAD5402A5
+      090B62264888F1026BD1BF6E7EDBB7FC6E6DDF5BC2FB3EAF91323606CC8D8DD3
+      40C8560BBA692CB133A4A4CB0F4DB9E9F7B7DE34F97E1789B1C27B9F9892EFB8
+      E872C3DC5EDDA4797AF4B83979BB3C5D9F6BD6E3EBB428B7ECFD1FD79B16A3EE
+      470B57FCD5AE4156EA5DB3D1976BB8D3B9DBE21EDB0656654960A1B5EA3C84E9
+      D2A6099F4EAAF48F6EED72ECDF3EDF2E1C2BB6DB64C29833828D9336819173B3
+      3292546A18C2A183A58C364171ABDC9FBA6D71102FB87D93CA725CEDDE34F3B4
+      FDF3726E58DAE639492FF397EFD6B1CB506E4B8ABDCB549E4884172C48D0C44B
+      451991A5ED81BFE0E929BAC9FC4EA58971626D0D8404845D28AA74B696542265
+      05CFD46009ABADCE5D816FE2E4F6D7E918C582AE95D3A507905308262242C4D6
+      BF739F752FF2BC2D113717C4C752A54E366E6EAF1B72B57E46CF26F6264AF3DC
+      35238793E1248ABC30C9559A29A293B12231695CA0DDB61DB1876FB966F71CE4
+      76618CB292AAB0090354ABC92C1E0A91A948851259C9D408C3ED612C1059AF32
+      7CC718883C38FE5511E06EF35CADDE4845BA2E62DDAB53C93D88D8766182E729
+      34D5ADA4C2087DBB3544A41A78B013BAA348C76D5AE777B6DB6D7163113B6551
+      61E255402389C80C9D2DE079FA888A72A6E7D4FF00FCB264806FC8023C7C4456
+      F8FD94F635AE7793F6E53F6E49ED7E5B99E60721C3D85E2A1BB4849C7CB72D24
+      96AED9FADB460BDB1E458628D1448B5A360923B13D717EEFEACBB6C599B73EF6
+      3C38A180683EAD22CA2048B02C4DC6A370055D0CDB6E97B46EA1BB053A5E1539
+      3DC8162B7FA6C6E48173A6FEA6417AF48BFA7AFB591FDBDF6F56967558AED9A3
+      143377E1925BF1F6E3A6A817909C4337D185ADF950AC28220C40D0055F316B3D
+      7FABBBEE320C7B3C7EA0F045E410719592185C6B4D6DCC2335782FEEE77EB776
+      F576C58096DA63C84AE96010897FFF00AD750D7EAF539725E0137963AE3FDC4B
+      F54D37D9EFB63CD7B5BDAF1DF9BDC9CBF05C9476EFD29440694363E9F8E82BA4
+      6FC7725F5B2DE9AFEC6893B443819922D9B9FD1BF6A3B4B6FDEFD7B679F72D93
+      D8D93153AC69D666EE718624170097F5690BA1151B4B33B9F6D7B571ED76197B
+      E7AB22B60C4C06DB1904CE4E3EE1219749421744820824F3053C89FDC2F7EC1C
+      93F3BDF2F125EE5EE4B763B110A02E7210C08F25BAB49ED5CB324F3D7B196225
+      51125BC4712AC8A17E94742E8DFC4C38931803DBC6A162F038413004022D6BE9
+      B9315AE772F5A3BBDC656736776E369E662E4DC1F1B4D85507CBFB838F3C6599
+      E87765921146486378A55FA1B11D8B9F5604866B57E5A72D082321A28655D645
+      644C7E6EEBB5DBE4D603C45FF1E11E026794F85CF2D1B719D026AC5C445AF6E3
+      E32623C8F316E742F357D6EDB74B33C291CFF9E238619E28C288706B45DD8A27
+      57158858D5D501924C862A73D6C78316912B24FC7C1AD773E41ABD5C4D567779
+      8A946D384BD25556592CF1F2167C5446EE490C12B6F8FB16A19405328DCA3731
+      21869D5A63C5A87093CFE3FC2A03E622DC0555BC8F34FDC44999A22678E76FA9
+      58C3C86CB0794401CD7693EA860A6436132478E45863C400B5EA033DEF1FEB51
+      1BD79A69ED3C67B05D8D691FD13148E748D0EE800DEDDF850A82318C7C7C652E
+      33A6FC2A3B3C3F1A864B3C51444A29459438593D7224F622962EDAA97578B113
+      48378D010DE78D1E55BDA9A676893CE9B4CC91C67680F61FF2FB8C01B113BB80
+      4C2E36B22293E5E084F4E6924F950CC8BD221A330499ACBDE89C0134CCA5DF7C
+      9B964685E32598C79008206E6527438E967D5424827CE8691DB719F1DAAFE838
+      0AF889A5958CA23C7A492723D41B073B40E8E04515F8F2A5909893284096648E
+      5C98B70159B6AE85A57DC22728082017CE7C011D6102905AFC6958EE4B558E11
+      D256ED23ED95959F2AE4C6F2EF2D92B8257E5DA34F1D44A034BAA24D3847723E
+      EED475836BC8C5016B4A0E155A31215959DC15246EC027CC74D9C6290313C28E
+      AF61E490EF3F969B439DAA198EC3DBDC77773718D490D962BB7A128053AACC7E
+      54E95AD346155A48498CF6119FB8DE87EE3483D076CA374A3CD1948FD9861D2F
+      E54FE268E260D4AAA5D432E4168B15C47088E560BDCAF1AB49244CF217865951
+      7700E345CE07F0989913D303C6F53B1B862391AB2385BB1D8B31CD34C5EBBC51
+      2B89943491C4648249C446BE26605230C4B176F41FDBD54E7560A57CFF00AD58
+      E371333E1F855D1C45BE4D9AB4F0D88DE05567ABF536A3ED22AB831982B87199
+      649630A309EA2493A64F5419D10CABCDF8DAAF7699332655607F5ADE2FB09F78
+      2FFB1394A1C7CF071BD88F94E32D08A4A17DEFA762E5DB30B8B71722905696CC
+      B7B050C45846DB724E5BAE35DFBDAB8FAC6D3391AF536371C574DC006C549361
+      E3FD2BBD760F73AF4EDE62473A4AB8E01A63D5049040064881E5E55ED73F4A5E
+      FBA1F783EC9588EE4B56FD4E4AAD9FA9AD04B0589DA873158ADBA575234513F7
+      AD4B32386895582B2156CB75F1F3EE2F6DA76FF7166DBE456C4D8F321046A52D
+      A4904ADF828869126266C4517DDED90EDEEF2D87717462C832E3C5911EE1465C
+      66C50FF6B2055986956869585AE347EAD7ECB70543DC9EE5E0F94E2B8EE12B05
+      BD6B848A681D5452A1147629F292734A93F18A9644AD5A559AC42F1AAB467603
+      E9EBBF6EBB977BEC267DBE46C90C01208B86B69093AA446A10A44DE2457B37B5
+      BB876DDC9DA7B3EA7932AEE32BA01958DA32CB6B5D301847A0862A4386956692
+      6B853EFB53ED7B6609B97B8957EB0411DCAF2476E382B4B5ACB55BB1D430BC86
+      783B2639044DB0929962983D7B13A14753C3AD71AFB9A64832B2C089133C0CC8
+      913C6D354BD5B363C0F035689FCAC62D7E110797E04550FC9FDCA960925921E5
+      60E3EF464588A2980B51C8F718258978EFA382CC29DD0ACF306C60B600D32771
+      C1DB88EA15B197C46C48B111701B5107C97E57E315ADE5EB38CE42F998A2C0D2
+      24C47323483F8F854F78BFBCD95AF5A97257E78CCF1490CB627B75E492A8952D
+      C92AA06AB49A249ABB042CB239900F9708EB47BCED0067265C681E08200060C4
+      4736E06F1023C6E0D9E0EE2C58BDB389D9975483245B8980481123CE4FC81ADD
+      5FB4BFAABF757B4AD49C550E6A08A9E22B0F5AFACD59EE4ED3EDAD015AF68ECB
+      17199E132A584658407918244C0F21EE7FB63D3BA8631BACB89BDDB89483A445
+      CDC705B34153264289615B4275CD96FD48DF63C7914700C2489316991F9C8982
+      785BA63C07EBD7DD9478CB54FF00A9B4342B49439182283EB1ADF20909AF25B8
+      1AE4B6ACD0AB12C8239B1B1D9C11A6DC8EB826EFED06DB2660EA0FBEC0A93601
+      6498B00189E238813E706B54EA1F6C3B1BA96E06FB2EDC1DC323A124A855D40C
+      3050A1890095FAEC0EAE35757B37FB8C5ABB6ECD5F7270ABCAF1D25686C3AE6A
+      41D8AB2DDA9566B32CBDCB8D7764568B6DEDD646C1258642F5ACEFFECE6E3678
+      C66D8E7299B511FDC65A19808206998E458FCF8D681D5FFEBC76DEE953FE0B73
+      9769BD59F537A94D8E9800A9405A3D47DC2A3918AD9F5E77F4D9F77F8782E737
+      C5F074D9D8C100B2A299944B0ED492098A2C32EF49C155601D548FE1209D776F
+      D43BC7B6339C28D9CE40249533107FB84CF11CAD6F1AE4BBCE99F793B1778DB4
+      D866CFB9DA91A8C4665B1B82A754708256C6FCED5A97F7D3F47DFA6BFB8FC572
+      B43DADEE1E1FDBBCE4A665DF5EC577799E5AB1C95A38E31621DE2336017650DB
+      98E34F1EBA9F66FDF0EF7EDEDD62CBBCC59B3ECC44EA04581B93631C2DE57A9F
+      B6EE5EE9DE61D1DE3D17265DAE45FF00E6C78CE36432CA59A14AB70308DA6C26
+      6B8CFF0074BFB5DFDCBE20DDE43DBDCB51E769246EF5246AAB591E150EF2BCE6
+      0B9C9B575C68010448C7008D48F5CF6CFF00DA7ED9DE04C1D471BE1CC4C1F549
+      9E512A9ABCE0D85FE70CF64F6B75A7D3D3FAA634DE931EDE6C6D88C99B6A6241
+      3FFE99F1315CACFBA5FA7DFB9FEC4BD2273FED1E5EA8CC919912B7D423EC281F
+      74950D8882E0A907382738071A7A67B6FEE1F6CF5FC21FA7EEF13F913A4DF859
+      A0D73CEE3FB67DC7D2B27B8DB6C8DB53C193D4BF8B2922F20F9F2E15AAFCDF15
+      3549248E6578CAED32AB2BC521620672B203E93FBF51903AE8DB6DDA6540C841
+      9F306B97EF366FB6629907AC78DBF7AAD3928B7068E30157274240D092412300
+      01A0071AE3AB6C592F26A91D4F0169A81F24BB55D07A400FB89CE85908F3CFF1
+      0381D58E26BCF3A83914AD427907C229C1D49DCCA4B1DA0EDC30F01E1A75638E
+      A13C71A8E5861B481B8E5B1B34242E7C493A03A7EE23A94B34C18A6095C6F621
+      D75046548C8527778631FBBA7C4C5466E343B11820FA8F90F0D74F502341FF00
+      567A2E27CA907850C64035F98E067206D0BAFEDF563F01D101F952989AC5DC15
+      24062BE441C02A436DCA64601DBFBBA51E0692A5FB8FFA4FFC91F05F93E3F37F
+      33FCFA3814314C57940E4EF8041717EDE108D1B361C6DC004938D74F21F0E88F
+      0F2A6F852B03845DC304BA958C0D0860DA348597600B8F8924123CCF40451F1A
+      3E36526312CCD86023644D4A2EEDAB82E360008CE307D3D01A2022E69CABAE02
+      A172D9CB30D85486662E0EF72136BF8FE034CF4D35CC8F0A311C0D4A28C48326
+      5976AEF8B288B2168A301C65F7A10DDC5C6CDBBC781381D45698B53C0409A9AD
+      4444D9A0566109491D0C4D1A4A8364980EA96411E852747D4918F087926FC66A
+      521AB1F8D9005ADD8AF1C210B59AE5CAF754B3C6930DB651CD8966FE152ACA23
+      6C83E39ADCA0DF51E3F1CAAC309B888AB87DA94E804DB357927EE46E0528D94D
+      92A0A37E6AD5995AB132233AEECE117507B80AD16F72648F49800F13F1F1F855
+      CECD10D889F2F8F8FCEB69BD94BC35AEF9FA4E328FD7F21C5C069470B996AC50
+      4C4CCD072B6253C452B37164CC8B60999E0401591351A4F556DC051058B2AB5F
+      C7C257EA20728B03C64D6E3D2D70B36920025848F21E7C0133CEFE16AEE47E84
+      3EC8FD88F7B55AF72C574F724D07196A0E4B83F70CAF6A39792ABCB58A2F76A5
+      6806DA725200C8909B1292F31C9754057C81F773BA7BAFA66F136F0D8B6F932A
+      819104C2B44EA1CC012782DC092B735D27AB750CFDB9DB2BBEE8EB395F285390
+      2A9F6B482C0199FF00E43E9262069224968AECC50E07D95EC9E36BD9E3BDBFC6
+      54AFC171E6AD3992B57324140CB5E3756B8FEA8ABC51D752CEC42C70A68028C0
+      F2AF71E6CFB7DDB603B87DC65CB2C8EC75237FBA5756B479061588C842960D6C
+      6A4DB9BE2EB5DC9DCBBBFE26E375989CF901280955D41495031AC09330140BB1
+      1C4DEA93FB93F79FDD76783E46F7B5B934E1B8BA166CC33729424AAA914F5ED3
+      C0B51F962F25659D6E08A168925679243B47A2511F54D83A662DE918F71B5C4A
+      A492DA45DCBB162662420061448B0336B0EF5D85F6E7B7B6FD4F06DBAFE13B8D
+      E64C6AC31E40D7565D5AFDA80DA746A70CCA15544FD485EA94F66FDF1F740F71
+      721CDD05A7CDFB7A954B5479C4F70DDE664E226B77E1B75AFAF1F22CC9CA8B1C
+      870F33B06ACB241108D06D655AFDCBBDC76D62F68656C655C9E08A261837D445
+      80B1124EA904FF00E51D63ABF66F6DBF475E959D8ED7ABEB5C989B02E25CA131
+      E87C61815F6C84CA17EB866D64C866C9A60BEEAFBE7C859E1F91FE8BCC43EE0B
+      1C54F628BC5359A7C3D6FEB74ADF130C34EE23ED71C7FF00E9A95A488CF63E91
+      A65ECB2C72C255E6ECBB37026745CB8CE34786B02C74B03EA53CCEB10485D401
+      99208AB4E93D3365B6CCD9DB6E983528306588C646466B990B91B311242EB0B2
+      C0B2E495D66E7FF525C8730DED96E0BDC573DC1ED796DD1A6C785E3ABD7F7472
+      1666ABC855B1ED5FEBFCB5CAB7AE5BE2E09FE92B4364475BE9EAC13578C94ADB
+      BA16C3B0976E72FF002F12E1DD8527D4C742A82A464D2AA42AB11A98A9265995
+      8805A2CF00DA61C39B36DB19F7F26A857F562D4C41D6B8D58E3D4CC35B10BA99
+      8B82FEA35A61C87DF9E539C34DBDB9C8DC65852BC32B453DDE32397999A5BCD4
+      FE9A27A75B90B9C853A895A2B6668A3B9750ED7FCB932DD3B07656D76AADFCCC
+      6B249370AE4288993254293A8AC12A86E2EB679BACE5CA410E09B09123F083C2
+      0FF68B5C016BD40FDCDF7AAAF01C75B9ECF28FCC71FCADD82B5AE5BB5C5F23CA
+      58E3690E3A47A7C35BA9CAC512F1EFCB708277AEC61A913257D2449940D83A7F
+      6936F332E34C431E644242CB2A866D57C80A19211E27D4C65FE92A6A265EAF87
+      08F7B3B4A4C8B026DCD4F23C6620471906F5FDBF705A9A69EA7293D8E2EB43CB
+      D433F0BF5517201C732158735583F1CB5F96B7F4F7236BA249ABD4AF3CF948F2
+      C116EF1F4FC698FDDC015DFDB30F1A7E8B683EA9512A744067655E2609A0C7BC
+      76CAA8CCC13544588BC106FC499F903F856C57B0FDCD4A63625B9C7F1BC95B3F
+      D3E0100ABC6DCE33DC3CE896FD0B1C85B0D254BF76ECBC73D530A6D6032871DC
+      0C4681D73679520622CB8FD46E5C3634F4B05112000DAE4FCF9456E9D2CB3296
+      C8481E2BA78899371CC471B0F335D92FD10CF7607F67F11EE3E3F9C6B91F33C7
+      7BB2AFB8792E378E4BCA96A59AB50A68F639186D58E1BB3C64DBDCE277B31318
+      A19231B57CBFF72D36EFB8CB9303635C3051914B15F48969B7A49D4384800892
+      0D45EF95CFFF00E33BDDD60CAAD89F64F84E32CC0156863F42B8395490016214
+      2343BA598FA311CC50A5C2BFB82CC91D7E360A1272D3D899E2ECC549223396EF
+      2C8E8F31C85555CE5980075EB96F6FF4FCBB6C7832EDB017C99B33C6A5538CE3
+      563A88C9ADCFBD8DEDEDA63D42441613ABE6BAEC375BAEA63A3E005F7AD98625
+      500825C9D3C0810BC49278004D7975FEE39FA8FE1BEE5FBF9BDC5C2AD97F6657
+      B294AA2F355471B2579D125BB76FCB6A955E521E5B8EA972C4C2248240CEA9B9
+      99A37423DFBF64BB3B73D376F9771BBC6716F7331C9A41D44063C2E44126E490
+      22634A9040F456EF1A769F6A6D3B69B261CBB9C20FBAF8CB3626692A0A9750C6
+      502EAB059BAC8327867EFCE5C9B6CD3F1D5A48ECF31C84F4E69EF3525666FA2E
+      1E78D2594C51848A6E3E3864795541312C8A112439F60F4AC5E8550C756800DA
+      6D761FB9200F183245704EAF950B92E27D6C45E3C071FF00F6817F091135AF7C
+      8FB9D425C9164A482C475A6EF891A19E33196FA78B8E7B32468D3D09A48DDC46
+      2C1994783ED3B36CC3B68817B72FF13F3FC2B52CBBA104D84C7E9C23CC7E3F8D
+      547CE7291CD1CD1CF32C8561AF0A4B1D80FDD95C074AE863DE8C5620CB244FF2
+      28DC4EEDA1EE30E2D37F3AA9CAE5F872AABF97B5307359A502B17570B5DFBEF2
+      464A81399266748EB283904B279770291B45962511278FED50321BDF8557F6AE
+      34929AF32BC9B1FB2CCBB24310C3E2B076048C39662CC5703C71E5315401A87C
+      FF00CEA349260D305BB918327D3CA42A2234273A025555CB4AADDBEE9DE4E33B
+      82A818C923A7D56DEAE2680E9E2683B332C816329220CBEC860058D60AD84FE6
+      193787DD21D40DA4039391D38A8680C13E4290FC909B15D808DB38AEB176DC6D
+      1B99FBAC712B1D0952CB803D271D2E92693F6AC677EE3227AC4A8BAC6D22BBE4
+      3EF748CC8E0BB64EE3900800281803A4D3496E0687474266EFCB13F6AB4BF4CC
+      9205065678FD236957913617D1B2A7C3A400EAA2B479D0CD60A4B3A158E50BEA
+      95802A0A8DCCA2350D2140C5812C3002FF0089742831CA9A264C72A2E39D1565
+      131126D1B6075EDE0211B8771C14570C00C649D47C7A4D266DC2967952864044
+      2EABB2542CB33BAB77647258AFF111B1222BF0D4F9E0F59A6F1CA9098B8A57EA
+      9A054F072CAA7C3D6446595464921543C7A950095383E58428A6C29493029C6A
+      DD2C8ABDCC15D1115B2BDC63BDB6680290DF8961A6343D3193181F2A92848023
+      954B69DEEE1895D51A2DA9249DB42DDE28638FF2F73C78951A3181EA05811BBC
+      3A82F8E2E38D484E353AE1AC2B4A54B465711CA59245ACB112A4085A42721A30
+      B8DAB9C9DD804E9D57EE1205AA7E1C906F573F0D641095E331CAFDB9AC135604
+      952C48D3881F28D9DB1929E2CA47F1632D8EA8F320B9223E75738728B03F544F
+      88ABB3DB36C42F465B954D7B486ACCACD655E578C09BB6F2C76552AB5795E355
+      11AA6D881C685BAD6FAA601931B2AC158223FD2E0F9F3ADC7A16F0267427D2D2
+      20CFEF3683E1CABD7DFF00665FB914796FB75CBFB636DAE3F93A4F9B096276B9
+      1DBB2A62B356580BF336E3A23E9EC3E14D68A47236BB33AEF6F955FF006A3A0E
+      EB63DCD8FA86DC80AE51F1B80A3DB656825B56220C449BB713A401E9AECBF717
+      1E4EABF6F7A7752D25BF8BB86C4F2C242BAEAD400049426046B1A224AB132663
+      FAE7F625B33F2FC808E9D4FAA0DC8557EF579E1692B99A7FAF10CB1D18BFABD5
+      ACDBD5520533F70A97602366E3BF6D3703699D30649704CC8FEE0C4C5C704737
+      BC4082140245776FB11DC1B6EA1DB7FF001B2F91F0AC1953286C204172719323
+      D4E42E9042AB1603CB57EA1F8F978BE5EDB0B325EA4C63B1CA39BB56E19ADCD2
+      5A3F4FC4C6FB668A24B17BF9726C998B979917403E82762E75CFB65055532410
+      9622C22EFC8D871120442937AD9BB8D5D18A4FA24837F1910385AFC3F3AE71FB
+      A167E2EDB444A011C971C2C4F300676755B2EF3092292494041197C297318380
+      3C7BEF4CF6F718835F82F18E1CAD711CE2F135C83AAE6CD81CAA1014131122F6
+      9363C6D1F850DC773F7692AAD7B334552C464A2865DD14E91492A2EC68E5468F
+      6AA9C9CB6F0189C804167D861CD25D41C8A7F3161E57E3F848E74E60EA2C98F4
+      DF46991E56B78FFADCD5A1C47BBAEBC756D4979D6CC55D6C400BCA92565AACD2
+      D7486CE401F54C628867253786C654E75BDDF4AC435620A0E32D06C2F3C64795
+      CF9C473AB9C1D499F02E42C4308F1E1C45FCEC3FCEB68FDABF726E57A14E77E6
+      2177628F3453A33C366181960AEF70D548894796B4811646FCAEDE46320F5CEB
+      A976EE07CAE9ED11C608E226E74C93C889205E63C456D1B5EB39C621A7282BC4
+      83C27C4C41179F972AB7A7FBB014259A0F2CB2D7E35FE85D516581985654DB14
+      320EE5978BEAF2ACD82C5739603274F1DAEC58E3CA00C6727AAF7E3CCF000C5E
+      3803C89B6C3FF34CF83DF2EDEE01E98FD3F7FC79509FFF00717EFF00A104E78A
+      F705A8A38A6A2A2B4324F4639963AF1C524C60A36EAFE5CC707D68CCE4E18E9A
+      8E4EC2E8B9B203B9C2A4956324068249204B0371E46DCB8D13757CF95A5A1B42
+      5AD04C401C2F049E06AE5F687DEFF7CF2572A5B9393B56ACD72B86967962324B
+      75AB3A4AC3BF3076FCAC82C7F6E467AD3BAB768747DBE26C4B8D555BC0030166
+      DC078FFA55F6D737BB84E2DCAAB2B201A4ADA08E62795E3C2BA65F63FEF5727C
+      A8E269DDB13312560B00E2596178E499177249DF8195E6913250C474CB06D3AE
+      05DD7DB18B6991DB1A8D3C4458198F083C3C67F0BD726FB87D87D39B6197AA6D
+      71AAB3296038098122560D80244EAB181A6E2B60FEFBFDBCE03DD1ECEFEA9C84
+      BC304A756E4C1392A6BC819219841277228ED3010346F0B7CAB96DDAFCA0754D
+      D81DC3BDE9BD63F8B87DE9C8544A36982B22E578F1E7C22DC6B84FDBCEE9DD6C
+      3AEBF456C397362DCBAA10080A186A1EA1043FD43891116E24D78C6FD4656A34
+      FEE37BAA9519EBD94A9CE72F009ABC42186CF63919E269101F0123C2C7075C6A
+      7AFB0DF6FDB3E5EDCDAE6CC0876C286099225178FCAB9E7DC7C38B0F716E7162
+      2B6CCF30001F59F0B72AD40E6E4DB2290E33B085DAB823733304CE9AA86D48F2
+      EBA7EDD491715C9B7074B5AA03CA4DB158E32086528703D3B483EA207CD9F1FD
+      DE3AF56785648AAFCAD6F3AAEEEC814FA431CB1F4938C646EC06C1C11E3F03D5
+      A20355CE64D476CCB85209604F88395C961A69AFA893FBC752107E551D8CDEA3
+      D249B433608D4600C1539C007CC06D31FF00575200FCE9A6FD292EE02082FEAC
+      1DBE7AE4FF00A467231E791D2F0F9D070AC3560574006841F4107C35CE09FD9D
+      14C521079D212B2ED206873A1C635008603CF39D3A51337ACE1F3A997FE13FF2
+      26DF0FF3FF00DB4FC7A2AC9FDE9A6EB6792BFA6585FB0DBDB385C4F28000FF00
+      56E6C8C798E8CD3427F09ACEA9621C36BBC36F97760A066280EDC61B69393A8E
+      9B68E02896DF3A7080E54E570ABF9677004066570B20DC772ED6D31823FC3A03
+      73463841A7081DD9FC43B2C796243C81CB216ED2A46015248C641D0F874DB0B4
+      5183CAA4355E494C4CE59910636B6C46420FCBDC11A6F2BDBF3391F86B861E05
+      A9C5B99A99F1E3B5388E78CB0DC1B10E25AE33DD7679C6E319D831938D147511
+      E0AC8A9296600F0AB2B82ECA44C934EC9D89925B0CD228496BC9BA358C88C1EE
+      4911DC557180834F31D55E70C4D871E153D3840E1C6ACDF6D7373507819DE8C9
+      DB9A08A449E39A7FA38A385856C2E4A32A380A07E601B1372B2E7AAADCE00E08
+      322DCA2FE3F1F3AB3DA6738D81B48F1FD3F5F9F2ABAF82E7E492AA079AB7D658
+      9DCC11CAADDBAC15652335920FF87BF257276A236F54CB2A6F98B36B9B9DAAEB
+      B83A40FCFF001F0F1FDE056C5B4DD1550C480C4DBCBF01CE397E424D6DC7D92F
+      BD7CFF00DB7F7C711EE6E13909E4314776DF254A2E7B9586279AA349F474F979
+      56E0B3145492C2C71949374D95DECEDBB3CC3BC7B3F69DC1D35F69B841208D0D
+      A44827FB92DC644F9116115D17A175F1849DB6486DB64521D5BD4089074B0604
+      11C01B7EB7AF469FA4DFD5BFB7FF00501C4B701CE9A70F33F466ADB16268E093
+      94BAE2B259860A70A7D32BFD35E88BF6E473148583632A7AF04FDCFF00B6DD43
+      B4F2BE4552FB6CAE196030825819F46900BE96D4585FEA917347D7FB5F6BB5DA
+      AF7576A3BFB78F24BE100B7F1D40D41B5924B203633C25419E7797DC7FB5863E
+      22CDFA7CADF96A25A8AEC3C53E2DD08445D9B8205E32BD68BBEFCAF2F12F71B7
+      32857777F0F5724DA66DE6D5F1AF5164C672AB10543191C27502C2D278B093C0
+      DAFB6761FDC24CFD41367B9C185739C651B28F4BB4EA4D472B31818B093A4403
+      215178DB9D7F73FDAFEF2FAEE4F99B67905E5A950B14E29EA97A54EECD7AE55B
+      156AAF15C6CAB3C7343C4CD564921A71234C2365901952263D33A2750E9918F6
+      6853D96604DE5A0032753C812D2B73E9B7FED5E96E999BA664DB28D8157D9E48
+      2149D5ED850CACCCC44B28C8B900666376257D2D03457DE1CFF3D2731C986E26
+      D719EDDBBF476E58F949BFA170EFCB50E52516C59A1C7996B7310CCB157ED456
+      66AF58C6238255621E21D8BA56CF6436D8D95D5F789A97D235B0465B10CD7520
+      EA04A8669965224310CCB913767164670878866E622D0385A184F8F39AD7D79B
+      954E3AED0BAB6ADAF25627E738E9E87BB2BF1F4F8F75E46AF13C91E53E912286
+      9AC77EDED816B4B2578D18C4EC91C2643BCA62DBB674CE8554A28460D88B161A
+      4BAE99926545CB00C48D4012D150B1B3E3D40493320EA8824C4787E5600D563E
+      EFE763E0ECF37CF4D569F3F4E34A7C4F117B9359A5B17A3838EA6B17256D52A5
+      582A5BDF1C862635CCAD2EE80A9884128D9BA66CBF958F16D54B61732EEAB002
+      92C6545C922E246A88879D5A96AAB73B95C4326E1D4381693CF8795B9C5A49B7
+      083540BF2DCBF270F25667965B6EB538CB4B4C092BC5478E55AF352A30234371
+      0F174E1861635824719AD5DE6DDBCC6F16E6BB5DB6DCA2200BEA613C4B35C331
+      B8F51248D524EA60B11A83521DCE5C80E473A81D2638403C05E7D2047A600D20
+      99988B4F88E339635E0AF0415AC547AFDFA7170F2CB6EAC115A49DEED3857923
+      6EFC4A7786907D43A48140959DD5586BBBBCBB6190BB161903412E209223493A
+      617E5E9913E900122AEB6F9772BA540FF648B69BC4CC8BCB7E1241B4DC035D01
+      FB29EDE5E52AD1FA6E2E1E56F2F1DC1AD1AB1DEE3B9DBC2EC91D59BEA20B297E
+      E733553858A412CB140B9F0599536203C2FBC378D85DCE4C871E2D6F274B22E9
+      12208D210EBE00B7CD49935D63A00231AB3C04D235126C0C733C87E5C85775BF
+      48BF6C677F72701C47234E5E4EAD4749E7BD259BF0D6B308B566BD914CDB87B5
+      156A3B16212C424944DEA2A992BD78F3EE075FC79F0BBA1D08EC14890BA662E5
+      93532CCEA300903E90C601D77EEB7708EDFED3DD64C399716E9D748550A5812A
+      ACA182B4EA6172AE5559399306BA03FAF4F73F2FED7FD307BD1BDB6F656CC9C6
+      DDA1D8E366992EBD3B1C64D458D38A222E5935ADDA802AC08F2248F13BA76848
+      E977F6A7A56D3A8F76F48D96729FC4C39972010EF8F51D05E72328C63D48C006
+      18D8A15B39D2478E3ED4E3C39BB8B7BBFDDA1C99B16C32B21D1AA32B4E936074
+      B95D6CA4DBD2F043403E37FDE7EEE4B7F5D2457AF72B68D9922A97398BEB3DDE
+      EDFB4924125115FBD17D6DB7815A5CB964032351BD7EA6747E9EB84A855545D2
+      24288161179E4380B549EBDD41B24AC92C58F13C64C8E13F3379AD36F7A72B6F
+      909673257A952B11663925AB0258ADB64568649D1A3FCBB71AA42675D8CCA0C6
+      304FA89E9DD3B12E2D26E4DB8DBE3C3F1AE47D4B333E433A4013C387F9D52DCB
+      B5420724DCB2F20629C3CD4121B2F5E0408D09B02CCCA90B0EEED2D84CE5BCF1
+      93B0E3923DB09A6DC6D27CA05EB5DCBA6351693E17AAF2CF375E396495122852
+      14AD3382A486B71CA7682F00606262577160AF8CE87AB1C78DAC4D436CAA160F
+      21FAD577CCF2B5625DA6128024D0B3C3F9F059B6272FDE6C18E3716623853BB2
+      7B618F89026E1C65AA26570DCEC3C6A0B25AB139579268976C80F7A431C24C80
+      3CE8C556359590C6ADBCB861E0B83A1139405A885AF4D47B933468AF22349966
+      57F919DD0CDDE964760543A962C5411A601C903A70102E45034F1BD16BDB2999
+      228DBE48A26576677411A2EF06224B88C0566CA1C83A018C75924DC1AC11C4D0
+      F23B2A4B4CC71A44724456238D486506394ACAA77F756360307712718073D1C9
+      E33F951D35DA766EF08E40C8FDBB28DB84843C2562469D9951D5800707248014
+      635CF44B00C1E34D34D62D62348FB2921465DA87D1DC72831349295452194BE5
+      41D5F0353B7A50B26692605A82EE97D8A88C19461F3280C468A0A32800A2E35D
+      CD8C83A63182D2B127F0A489BF3A596552EBAEE1B1D0AC40FA641198E3740FB4
+      3367249C634D3C73D2580A4E14423B22B3CAE3685DEB8550BDC3B762953A86D7
+      5F0D0FF86100F0A502FE5439B0260E1B6602BB6D2A47F0970C548724BB681770
+      D58FEFC022E2926F029D294C23FCE7DCA548711165767DCCE5D5D1D8313A6188
+      C0D338CE9D32F7B5A9D42470A9550919E3500B7697F31448A0BA862818D7756C
+      F74302CA1339009C67C223A8A968C7F1AB1B887B11C31AF676C71C86CB42EDDD
+      8FB28C5225982849E22ECD9C8605B39FC4D7E4404C719A95883CF9D5ABEDDB76
+      A5912382C20B2CAA3BBF50209640C1234ECC89DA9239A42814207663FE86271D
+      54EE71280645BE556DB7C8E2263E756FFB7DEF199EBC8F2C4E63AE26924ECCCD
+      1C8641189D9983D89584ADB490EA496C95F122937689EDCD8ADFC7F2F0F8E357
+      9B2C990BD8F022FF001E15D76FED99F7F39EFB63F7A38DA11DF9178DE73DBDC8
+      F0D761AB2CD01FA835E7B7C6ACAD150EED992CDC8E20996EDC4B28DEC369DBE4
+      CFFB1FD8FB2EBFDA4FB8D3FF00D9C1991C13CC6A01F8B408524F024E9802F5E9
+      5FB61BBC5D7F6D93B5FAB85C9D3F3A82254368C98C8756034CC90193EA5003DC
+      988AF529FAA1AD07BCBED09E752B416ADD7EFC109137D5887B1637EF49E111D6
+      8AD24CAFB256412086663E962475F2FF00A1657E9DDCC9B50E74405040006982
+      C6C05AEC0C5C319B98B8FD97CD9BB77BFDBA333BE3C39141208D3AB5244153EA
+      2841595074EB4517106BC89FEAB7818F8FE72DBAA58B124BFD4DA4A579ABB319
+      8BB5A6B4936666E4A68E2CF72681A40F300EACAC580FA0DF6DB7A73ED1549000
+      D23509E1C208FED04F0062D63200AF4FF71ECCE35B821470E42388806F0387F8
+      D728FDF159A2313C29258114921B162713933D8B49139B5DB9E3758513CB76D5
+      2EE756DA33E93E8D901043102780116026D20DFF0009B0E526B8E75DDB9521B1
+      4320E2483C4C19E761E2604F3315557723865486493F884AC424824DC430316C
+      78D11C000EE2C07860B0048EB650ACC0B28E5F078CFC70B56AA722E32109B1BD
+      C5FC3C2FE7FB8BD587C2191C9A68F295B0BBE48B21639363AAB2CACA54F7477F
+      6E4A90173B3000CD36F02A8F74C4AD81E7F8795BC7E75B06CD0643A52608248E
+      03C0FE37B5A2381005ED8E207295BBD02B89E1456AF32BCB1A322456648E0686
+      165D89B16590C98723249D49D755DD7B19087234B7116F11264F1E422D5798D5
+      D5485120D8F01CE05AA7FC5896CF6EB19248ADC713470588BB824451D950D332
+      A28992BC664D9B5F7138C7A4E5A877457113900071937063CEC3C24C4DA3C6FC
+      2CF6ECC71848871C0F90117F919E74FDC3F01CAF21723A30E0C92CC1AD4DBFB8
+      C588649705161118705801EA058805C0F1AADE6FF6B8311CCE7D216C387CB8CC
+      FF004E02AF7A7ED73E4CDAF991FA73E569E1E3E75D29FB17FA66F747B9CC13A4
+      13C48D056B51A7D45642D14214D72E66669641146AA1CA804FAB233E1E75EF1F
+      B83B1D931C484336A23813C78F0B5CDC7E1575D57AEF4AEDADBFF2BACE5F6C18
+      50A01663C62E010244449135BA9CDD1F65FE97BD93C9FBF7DDF2D49B91A304AF
+      C4F12D3A0EF5CAB0BD948DDF1655E4410EC756C336E20FA727AE6FD1B0759FB9
+      5D731744E9EAEB81D80778E0A4813CAD79047878DAB98F5CEF1CDDEA8DB1D8B1
+      DAF6E60C65B365832560FA524A92CFC50CDA2795720BF50BFDCB7DEDF7078AE4
+      384E3EB27154EC2CD042F5F909E578E94CF62210A83022C4046AAC11402AE58E
+      75D3DA3D81FF005BBA2F6FEEF16F770DEEE6582414006A1067899BCFCC45724D
+      EF7BF6F76B6D3261ED8DA84DE3083999833B5D816FA44122385E2D315C63F767
+      333F2776DDEB165A69E7B52599D893DC679A4794B972BB0972E4E4E9FECEBD81
+      D37669B5C2B871AE9455007C840AF39754EA2FBADD3EE729D591D8B13E64926A
+      ABE46760449BD8ACC5D70369380705C641C9D4FF008F57789790E55AFE472493
+      CA6A03CC59F585077AB1D32307070464838CFABCBE3D58E14B542CCF78A86720
+      ECE58237A94038C1F48F48C6B90703E1FBFA9D8FD3509CDFCEA236588180D820
+      B0C670001F1D73966F0EA6A09BD463264530CB2919CEAD918CE48F1F51F1F989
+      FF002E9E02F4048E1490700E18E0E5B5D40607C3E2060F4B426C22BE994800A8
+      C0FC41F50CF96A0A8D71A1EB3952198B50CF261BE61A6BA6320EAD83FC27C3A3
+      17A19E5534DD27C4FF00C8F9F15F0FF4FCBF27E1E1D140F0E5497A06FB03C95E
+      1AE4DFB5B98E028DD65F27CF0011E3F878758684562AE5500230412A08380C87
+      19DC7427201F2F13AF874278D2D384322E1B248F491A8046D6C6801C39914824
+      9F2C671E1D011462D6A3E19829250170CE141083C4BE1482EDBA32ADE18F119C
+      FE0D91E34779A7BE38A2361CA636A92559B28546D6232361D2438048F3D3C32C
+      E41E14E2100D4CF8DB6D30FE632990B099BB6331C5180E9EA0634572EA493E6A
+      30013D44C8B15214FE66A7DC4DCAEB2CB1BC898C0DD3388E4684C71B58CC7AAB
+      6F0331BAA1D5B033A83D57E5C6489152B1E400DEA5D5390AB1C91CA10778B33A
+      C0B106A6ECAC0E5A59E69126919F001CBE1B46046D5EA164C2E4D8DBF5FCAA56
+      3CC034F3A9F713CEC6BB0B01592247990D71A9DF2BBF7A4AD3BF66255826D9B5
+      4EF61EA0C3502B336DE7CCF9D59E1DC69026C47C70F83579F01CA56B605D5921
+      E16AC986E46F1B534B5EA539614869405841FD42582F184C6C111C3B14322841
+      EAA0CF808F411ACF21172799F091323C395EB61DAEEC1879D24F133688B79DFF
+      00A4D6C27DA0FBBD63ED3F3DC57B978C8ADD6BF4471F5A3A77646838EB66F489
+      6DEC246B66E4B14F56B411CA9276BB5660701B6CD1C79D13BAFB4B69DC7B27D9
+      6E806C6C4B4817056C2F0399F1953C3D24D6F5DB9DCFB8E919E50B0464D0C09B
+      32B448E76238C8820DEF15E9EFF481FAC1F6DFDE7F6A9A1EE0BE957DD9C343D8
+      E524AD69796A1CE769DD6CF3FC35B868538E5E3F936921610AE406EEB008A0A0
+      F027DCEFB69BBEDBDD0C45F31E91919995911466C7AC962A0330248CA118A170
+      219D81370C3D77B55B784F59EDBC487687241C6A48F6A6340049F5AC078C9018
+      42AB0FA58EE2737EC5F69FBBEAC1CCD6A5C759E46768668B95ACD1D91C855815
+      66869C90F74D378B918C181DA4570B1CAC4292140E3D93A4EEBA7E3DB3E10597
+      3E67C6DEA072911AF1BBE26C8A3164630A65950412C4CAD40E87DE3DC1DB99DB
+      A66E32E6C7B440CAD89A57DB76F4B3831AC1C661C052A4B2A8912C6B8FDFA8AF
+      B55C9F11CD7BF2FF00BA3DBD7F8C366E519AA58F69F34293DE093C125A4E79A8
+      5111F25154A8827AB13BD3350493C80346E117A5F68F712BE1C1B7474FE4E3D4
+      AE99175046B82A927D2434AB58EA214588AF6576A755E8FD6FA4ED7374BDC366
+      C4D886AD40AB089E1AA493AA417D4DAA009241279E9EE3FB613FB6FF00A61E69
+      7884E0F9D8B9C6E2390E3A17EC5CAB56BD7AF2577E3E18E9DFAB5F8CB6CF6669
+      C1AF6A79A445886D1248DDB361D7D77D8DB2E0F73F938F46A52458924C863209
+      610A1482A04CF20246E974E66DAA804824153E922D606254F19F49E576B8AD62
+      E7B8B86256AFCB51E5BEBAA5C7A2D67939FF00A8C9538F6B286CA71F5606E165
+      FEA89D84D965E5819E30762A96DC3A06C776CF1936ED8FDA65D50A3482D16D44
+      EB1A6E6540683124C455564C6CF21E434C5EF17BC0B5EDC4C5AA9D1EC65E3295
+      4962BE279679EFD199E19238E3A74F9AA3C97D75DAB5A3823295AFD6E292B4F6
+      5A7558DA4ED6D7EE171B627576DC3B0658550A44892C51974A933C54BEA5502F
+      1AA469835EFD2B1E1C21813AF530B580041D445B9C004F2E17266ACAF68508E8
+      41625E524B0B345371F7451AB3970B59A4BF35AA542C53961156E451C107E5A4
+      A821171D5238DC2C89AEF58CE72E91B78D25597511CEC01604190496B9067402
+      491637FD1D10A9F7A0358C03CAF2011C380B4DA4C006E3B0BFA3CF6A77F9AE3F
+      DF89F47FD16DD2867B8F5E925CB34ECF25C0DCB3354BEDDDAB0D1590C10C5753
+      BAE6431D789D800BBBCBBF73BAA0C3B57E96DABF90095B9B101E2566E6C49530
+      22588E75BCABA7B0D8707FFEC32AB200E5093AD3D5E90D2CA0DA418B900C48F4
+      0DF60EECDCBDAF6AD0FEA4DCD707ED8A95AC7137645863B12C22A49438C96786
+      1AF57904B2FC7D9914FD446233B4B162E509F23EF86D7F971D4923164CC0681A
+      A59C9B2AE933F55F8C729E00F98BEEB61C5D3F06FF0077EC8DB754DF6465CA83
+      51507587CA14B33632A322A91EDB16130142868AAFFB99FBD386F6C7DA5AF539
+      7AF7ECD69A0B36122A4904B14D1DC5B3EDEB35AD99E0B495A1BF0F2ED1F71A33
+      23850B1AB6329DE3EC8F45C9B9EF30BB2D0B8F1302083F5155460E2E1CE920E9
+      2D120983A4551FD9EC253A3758EA790AFF001E130B833A8EA23200BE31A2606A
+      02F3A4B035E3E7DEDCCA5EB7C8426335EB19AC622AF6EB49D8487EA63A42B4D2
+      2CA0D79D6130FAE466EC68590BEBF51BA36D97160424CE481720DFC67CC71E1C
+      7918AD03B87773BBCB0214B70045AD6837E311C787856B473DCB4CF235A857E8
+      BB51CA2174765AD082C15E2EECA88D7046D1AE4856C90BE2C4F5BCEDF1441E20
+      FC7E15CDF75959C961C7F41F8F3AA52FD95A51085F6ECBA7BB1258843C50F77E
+      A7E9FBB24526F86C0FA753EA7215BE6556200BEC435FCC553E43A45F89AA9F95
+      B0F26CC3B866ED9482585E025513B4CE5E565324A26478CE1771C12303C2DB1A
+      4DBF3355F9258C8A869951ACC524CC5A5DD2D8991650C6D1B3996350A46E8444
+      AC73DBF501E4C74EA5281CAA3318F9D47BEA16DB2C2A802CC8F2CDB8648D8B24
+      8DDA6258E4220DA1B2B9F1CF8F5202F3A6C9BD6530428EFBC1495A2DA18BB6D6
+      501A465DB214D8E10900804ED196D7A48834336BF0A296462B14FBE4593D3240
+      33B17641DB4EC2148FB72B02155861704039C670503F0A49149CA6491D9B1199
+      A599D36AB879848D0B3193B6AAE0AAA311B80C6EC60820749C3870A556E74D92
+      3200AEFBC965FC8667116D61E9EE42C50C84AC9FC0C7691939F20A019A4304C5
+      04856395B1B36EFDC72CC88AC40EE6DDB94444900274233E1E7D3A78520898AF
+      C8C230C5B6928F2341E9070C400C704ED54C9C85C6A4E47486F4A200937BD632
+      287D76853908C14B1461216CAB6E62CFB4787878F874A0C509BD7D11A9562C9B
+      626C945C65959570191B6A02A71A2EA700E0E73D64C50C73E54B242B276F7300
+      0AF6D4EE08090CDAB78B1572BE3E474E84B11C2968980234B1EACE32519C0009
+      2FBB0CA99CB0DC0E3419CFC7C45AE26954DA6A475103CB1233B04560B1970739
+      590E2348C782ABE0107CD87C7A8EE2C4F3A7D18931356CD4655AC0AA495D7E8E
+      38D8317695C223491B6C1F28765C127D08D927400755EE20DA099A9F8DB44455
+      81EDC78E0BAAE922A468D0C90D870C4AB3247244A8144D196DE75DE3E546271D
+      56EE416583CEAC3164048BDB8D5D7EDE5B77AC4EF3CD2416E4AFB6CAA46228D6
+      38A447435D1A6FAA69FC08ED8C82BBB2C08028779A71A4448F8FC22AEF64CC72
+      192418F8FC7E55D26FD12CCBED4FBC1EC7E6E1B372B4F5ADA3D89616AA659629
+      33508B1499A59CB54B33A0419EF9250AC6AB903CF5F79B6E7A9F68EF364555D1
+      D2C083CBD563C2F1CEDC64CD7A3FED2E2DBE2EAF8BF9048C6CACAC188D30EA55
+      B501261678CF8580AF5F1ED59389FB89F6DFDC7C4D3B3C75B5AD79B919A8D458
+      FE8A3648A0B91177B950A2BDAB108694944640841D1CB75F25BB87699BA4F55C
+      1B98719463BB13E9D035299BEA27E90A41E51062A377336FBB3BBD365D473AE5
+      539308C6323312E64B211E879F4298512664117502BCC4FEA7FEDD43CD7B8B93
+      E628F1FDB992ECF66ED08AD25E692C34ADB38B5B56A7B1678DE3A92DCC357B55
+      DA4791197E71EAF607DBCEE06DA6CF1EDF3B808CB0A48220736811A98C7D4AC0
+      0041E1C3D9DD5F6CFD4712302F97DAC6ABAA02EB850A1AC02C344C202B7B5A2B
+      8F7F743DA163DBF255FA8A92D7DAF66A5C92B3996B492C3BDA610332D80A5959
+      410EE5564470061723D51DBBD531EF437B4C1A402B22F0784F0E17E03811E35C
+      9BAD6D0605062099048FD6266FF3B58D6B9C9C5CF6ED32C55E50259555F6AAB9
+      64925058B49B9048C651B87A42B328CF9F5BD8DD2E2C7EA20903FC3FA79F3AE7
+      AFB57DCE42C0199E1FE76BFE106A6FEDEA24DBA55E2DE2495EAA57632BA218CC
+      6B1EF91C0DC25DCEEC3271AE9AEEC52EFF0071FEDBB1FA44CDA79FEDC3E22AF3
+      A7ABCAE2530D602678445FF5F97E757B70DC05DB2D5A16A35D6B22B4F2493DB8
+      36A44E07D44924AE84496CC78281C16DFB46BD69BBCEA18B12B3866D7C040333
+      C871B09E31689ADAF6BB4664510B6F131C78F2B9F0F3AD8BFB7FF6F12F371AE1
+      9EDC95AC088C68C55499AC4863863AAB56C29AED1200570401B80CEA7AE71D7F
+      B88E3F700844659FC809F548BCDFF2E15B2F4FE9CA5F5E405B491FBF870F2BDB
+      C2BA57F643F4B5C4FB99E3E7F9292282A71482EC962CC2B0C091D4512CF23C46
+      A48D0B40B1F710E03BA378FA194F9EFBB3EE26F3693D3F6E0B64CA74800CFD5C
+      20861333079023CC1A67B9BBB767DAB8B085C6D9FA86585C6805F537A54112B2
+      0B781998980C0D65F7BBF5CDF6F3ECDACDEC6F6C7032DB938BE28C15F91A7668
+      2ADD35278EBC51C5605ABD6A1670CEEBBE0002AAFA54E55B60EC3FB19D73BA95
+      7AD750CC1572E592ACADE99049305554C5859B99BF31CB3AB1D9F4BDE3757EEE
+      CCFB8EA3949CDEC295F6D4B11FEDB441D57130B02186A6F491C37FD427EAAFEE
+      2FDE8B06BF39CAE38E8277B31D1A6DF4F510CBDFDC238240F68ED36597F36593
+      4F21A63DCDF6FBED5F6F765E3F77658A774CA0166BB5A3891E9E40FA40AE35DE
+      5F7177BD4F00E9BB25C783A6A9FA71FA470D3E1A8DA01D4C67C2B47398E46504
+      A860482EF2333BB6502E4050A401A64F878F9F5DBB6D81009E55C537DBBC8F72
+      49E3CED55EDF9F2AC7B88420CEF206E63A6E5249C91FFBFC3AB5C4B0622A8F23
+      822FC40A8172570ED3EA0C1772FA70AD863A632412B83E6343A6BD5862C63854
+      466B5F8D41391B2AD2386601B180140C12011DBFDBA788CEA7A9D890D4277136
+      A8F4F3EF5391823D38D32DB403F81C807FCBA90160D4763333C6A2375C92DEAC
+      7ED04FE3A1F9B0DD4C516F2A65FC4534990961E7E180400A3FD99273D3D16A6C
+      9FCEB06C91A8C1D5B18C7A73EADBF1C67A415860D7C675DB8C8272376EF863E0
+      7F847FB7A500CDE84F0A15CE5B07E0700F869F28D7C339FD9D150C5EA679FC47
+      FC8D9F03FF00C3E3F2F4727F4A4A17927FFEA57C1D196FDC418F528FF887CE0E
+      993FE3D0C5E900E55F37124077CB16C1DC1401FCBC903C0211E7F87EDE84CC52
+      F38E544AC819480BE82437893A2EE50A33E950DE3A7EEE862052F2A3ABC85085
+      DD80CAC7C0636ED209392C54B31C78E31D0B09F98A316F9D3C549A304231271B
+      8F6F6104B905517420EA0F978FE3D30E09BD383C2A4F46C08937448BB4320927
+      3AAE24520AA215771B564C0D402756071A3044986E34E06238549A9F2DDA95A5
+      0D0995D94CAB2A329EE3900A832F6CAC721C3004B042A1B39C7519F106114F2B
+      0E3530ADCBEE4899FB12AC3F9491C6E50234AEC1937C51A91868038763EA2342
+      413986D888F1BD484692054DA8730638523AC910492496577669195DD5B23132
+      616CA2CE8AF1EF8C80517F8725A0E4C1A8C9F8F8F9D4FC7934F089F8F815331C
+      D473534911FB46335E0EF6C2AE16696667E40D159A549ABCEC9229903AC41C03
+      92CF968076F0F713C7FD27F2A96BB8F4C8F8F38AB9E973B60592DF5D196EC3CF
+      564E49E2E4257586B4156184CF6CC95AD99E01176D594BA2A10510AAB3D2E6DA
+      2B0BA9E316B7399B5C5E7FAD5B60DDE453AA64F29BF973B1B445BF2AD97FB4BF
+      71B90F6BF3F539159C53A692548EDF193733FD29AEDDA24C53538799AD6AB8E3
+      60B9566B30B5A8DE1D9DF68A32CFE97D2FB87A0E0EA3B6389965A0C305989E7A
+      4CCC100C5F8026DC379E85D7F2EDB2869012002A48BC799B7E2444DB8C57617F
+      4A3FADFAFC17B8A970FEF4B17FDAB0DC5ABC5C1C4DD3C8DBA9C3D29F0D42B8E4
+      7984E4ADF337ACEC485247FA65C892425363BBF943EE6FDA2CD9B6F977FD1531
+      3E408F0C157549E2E116000A6F1726624C815D373B74BEF2E94763BCD29D4C7A
+      F1B398F5F205C15203499995278AF876E7DC7EDEF6FF00DDEF69C13519E93372
+      1C3C6788E7B8DB15ECAC2F6C56B14E4826880AB6A0CC8ECBBB431587D8537EF3
+      E4BEACBD5307575D97F1130E6DBE0C65D14E31A99F4222AA2FB617DEC93978C6
+      2C9932075592CDCD7B6BB8BA976075A29B80CF81339F770B83A5D46A56F12246
+      9BAF34590DA74D72E3EF1FE9B669B92BEFCA71039DBD7A5A77ED591566E3E1A9
+      5B86A57CF2EEBC77B7E7A228C77A592B8008924B12C0199E3C8CED3DBBDEFB8C
+      0176E58E209A9749BB069034B6B046A5218780E2019AF5E76DF7476FF57E9EB9
+      F66571624254632DA8B9C8EBED28CAE0B642A034DD551485008591A09CD7D83B
+      9C6DB92FDBF65F27EE2B1CE57E4B9AE14B7231DFAD6EBC77ED719DAFA169E3BF
+      6B90A4DC75989E769A55DC836090C6F22F61D9779AE5C4B8937298110AAB7A74
+      C5831BDD403A9485001F18040AD99367B2CD9F20C24B3E370AE083672AAE3518
+      B4A106FE2262403A7FC97DAEE4476AB7D6DFE222A166335F8FE4B90AF5B8FE44
+      0A71437D8F20D15BAB08A9C84243F1F2B9369265980788154EA5B6EE4C2318C8
+      42646C8A65954965F51D3E9904CA9B6403D3056CD730377D37924C86FA66D700
+      9BDF81B44DF8F0B0FB4B8CB1C7F32D156B1250ACFC5F15C771F1F0B678BE2E00
+      1634E34F1D3D9E50D7A76EFD68E3482DDA0F12CC95E69559ABE5D4F3E7C79F6A
+      0E40AF903B33170CDFFB480B242924B2A9060B2A9F5D8BFB31FC6C87D256DC14
+      0E00729E2795A09BDA0DBAC9FA71F73C3F6FB8FA5424E3D391B7CA455D27E43E
+      96958AAEED5B8C69F80E7295BE2514DAE1DB86669D6B86512D85977891599FCC
+      7F70B627ABE56CAAFA1124859323D4D0CA431957D7E998368E0606DBB4D9FF00
+      39555D9F1A4F1059581D2C03A3232E9696D243482B20ADC1AEECFE9213839783
+      7BFC6149AC728A391B1DA89D25E38B3C9512BB1B324D3C62481622CBDC742EC5
+      95BD240F386FBA66E37FDC3B7E9D997705D72AC1C7A4E9131AC93A401AD82EA2
+      57483AB8C4794BEFFEEFA90EA6BB7DE4AE0C3E859208C8203EA85014C12C01D2
+      1A0430B8AE667F77AFB995EFF2DFFA1AAB133F051433C820BFC7C4B5BBBC33DB
+      92F3C13C63EA218250D0490ABC9DB06494862046DEBBFF00ADFDB8C3ABEF7ACE
+      918F0BEE7228C63185D3A7268D034332816D408B1B006E5A8FB5B11E8BF6A71E
+      724FF277F9B26433221118A293366900B6AF4FA4AFD5027CC8F35CE0BD0CEA94
+      EB26CB0BDB64257BB627892B40638E09CA2CD9788336D12920E02C87D3F41B67
+      B7F6C8F51223F4E3CC7CFF00CC570FEA3BC6DC3BFA4069E33F80E1CF879FE354
+      37321F8F4B74C88EAEDB2892B243907B31CF287084BC8194A1553B814126001F
+      29DAB6E75C1124456999E71EA468106A95E6EF4B7099A3512AA92268CA2E4243
+      13CBDFB8E2148E60F13B6F65400F6FC0123ABDC08105EAA723199179FCAA07CB
+      DE9884432B3C32439469645965B091BC81833BC42658C11B485604819F124F56
+      38D4013CEA23B9E150EB48C14A663547759231DC8637EDC8A5E3C6D7EE097F30
+      1C31D08D7A949133CEA2B49BF8D011389F79660C546E906CC4B1C31B61DA40CD
+      8660AA094272C3F1D0BB1069BFDE95585E6B3B24900EDC8F1A3A615880514308
+      8B7886032148006BD611E149378345261E10CBB77551B9510C923AACAC173918
+      5740E0672B95C02703A53C284DE864903F784A4A890C724AC8016912342F144B
+      B888D0BC9FC5E45B5C818E90C8B52830BE558EE4EDA81292590FE5C8A592385B
+      1215661B882EAC49D832085F3CE32B0FEB41BAC41C862D1AEFC485F606DABB88
+      C464150D8383A78F982752A19835F2B9906C58D958A8C6FC8032490019001803
+      38C9F003ACB73E14A0CF0E349A6E2645DDBD0E4BBEC52E402CA1A365249C7991
+      8D0E71D190385612008ACA5903A61086258C3BCB06608CA7381B7E519037687E
+      1E67AC03F2A1B71AC77E47AF2A06DD84EABE076B30C68A078A81A83E7D641E55
+      933F2A523DAC5704B28665770362050CA4B769D03161960416518FDE3A4D34A2
+      4FCEA43C58532A48AF22AAB4892623521962089183100D19DEC738230553527A
+      6B20B1078D1A71BF1AB3F879CB42CAC91CD36C9252EEE8CEAB1334491448C5BF
+      2D5549218B6428C01D576617915311F554F38A9C48F0BCD0A411A7A44C56425D
+      640EB865712B0600801BF2CA020EB818ADCAA4F8CD4EC4F043456C67B1246116
+      60295A2B352C1469096ED2249826A3C717A652922920AEF591C152304B6B5D48
+      4FD5733F13F1C056C9B073A83444CF1FF0F8E35B61F6879DB107BBB866962B15
+      3EA67A31DC968C8B4453ADF50B31FA7776EDCF1DD8F0BF9921663267761401CB
+      3BCB68993A5675043008D1379311F841BD872E15DAFB0F799316FF0003288766
+      593E027F59F335EC83F4BD5F93B9F6F394ACF5593DBFCAFB4B8D8F8ABCAB2C55
+      2CBF2156DFD73D7B12564ACD38EF16B01656296189650CCD8F909F7171E63D43
+      266593B9C6F9C35D4C2DA665A40F6D595444FD2144C46D3F79B7BD236DD6BA76
+      E369943752C3B92F910C17555F6DB1EB50D30D1E83A4064166202CF06BF551C8
+      DCE226E7B93494CC395E6116E4D52B5EA5C7C137232CE6A244B6EBCDC9599A11
+      50D8912291668F67AE308DB477FF00B778137C716260069C674824162145CD88
+      500CE9058419B1915EB8CBB83B7E99B7DBE0D6A88800D654B0F4A99253D2C26C
+      0A123CCF13C94F7C41C8F2D3A7259B238AE324E36A58954D2A8C92F31614C75E
+      484C13BBC337211BE1E051B3466552723D41D15B0ED53F8DE93B970C40F51B20
+      E20C8B8522CDC78026B49EA38F2643A98B1008BD8193C391E7C222B5E64F6D29
+      7515A59FB92DA6AD4A38DD659ACCB1D8B11C93CA551A6865B1298F016329B980
+      1B70D8DDC7502165C08D32D22C04031E04013C4CFCED3A57B0257412433691E3
+      20904F8F2168E7F3AB2FD97F6E2E723C841DAA263E3AD3C72A57AC93CE2A0823
+      FA81B6CDD6FF008865872EACC0C673E0CAACE35BEB3DC18F06132F3994449206
+      A9B705E17B1E7F2240ABEE97D1FDD70C57FDAE42E7F527871BFF00AD6E3FB03E
+      D349EE8B5478FA90F1D3DCFA9A9C771F621978EB376598A470455ACD7AA64499
+      4C932CBA8915995F2000A4725EBBDD4BD3F1B66C8720C7059810C00173209E1C
+      34F23C3CC56EFB7D862C581B2E508A88BF5123D20093C2D60279F035D7BFB45F
+      A60AADEDEE3EFD3E2E1AD3C695DB91E5B934FA6B176CA0A467952C445DCD3292
+      8816011884C6ACC5CC859DBCB3DCDDF9B9CBD41F1BE466C4642A2DC00662C79F
+      3D533300088039F7727DCED8F6AEF1FA763C81F399FF00E387370E0020810469
+      D5A836A060682B6A3BF54BF78FDA1FA73FB5B66AFB4EDF1DF5B3579C4B6AAB41
+      34696678AC503C1BD0699658E9A4EC3332871B18278918B5FB59D87D57BF7B91
+      3275447F6C3030641D2086D61A20B4498B78F235CFFA23EEFA9E4DC77AF792E4
+      5DA6D8018313861ADE55F1652C0091C03282A41F509E07CA87DD7FBB3C9FBFB9
+      EB7C95F30A493496362C31AC63B323B148B2A0600F1D4161E6C7C7AFAA1DA7DA
+      3B5E83B04DAEDF568503899B8F8FF2AE41DE3DEDBAEBBBC393295D37E000B1E5
+      5AF9C9F2D12484B12A59447F293B48DAEBBB201D47EFD33E1D6FF836C63E55CC
+      377BE937B035587B839550D82B95D7241070401B574F12BF878F579B5C240BD5
+      06E3700CCF0355DF2BCBFA1C46C07C18800E73A7A739C646B9F1FDBD59E2C370
+      4D56E5C808B5AA156791CABE4A8CA95C6410E4EDF97CC1D3C8EBE7E7D4F5C751
+      0E43E5515B531C6F1B46A351E283518D4E727C41D3A92822C78D46634D162700
+      0275DD92BF36ADE07049C86C79FC3A7956FE7404DAA3B65B713E1B811E1924E4
+      78FC74EA4280229A3FA53592439381E3E19F1F13A7E071D39CA839D7EC8C000E
+      9F0D72189CEEC7F1600EB294D22DBB53FB0F911A684E40CE589FF0E968385244
+      E01C03A0193F8683C0939393AFC3A58F1A122A67FF008BFF00B1BF0F9BE1FF00
+      7BFCBA72B24D01748FEA7C865B23EBAE6307247FC4498C6846A7C33D2191402B
+      EAED3A3B06183A313A118C13B7E5DCB8F3F2E80DA8A6968A460CBB4E72BA865C
+      E1B5DA3C739503F6FE1D2452D169244325C4801390AA0AE72061833139C0D3CB
+      403A1BC5B8D14F8D392CED180E8595F3B946E62C1B7601773E18D99C039D7C80
+      E9B89B51034F74F90751B4EED880300106ECB000166C166652D81E6BE5D32C83
+      88A3047034F50CAB223AB13BD9152299958771C05D5D8E4234633AEE39234C74
+      CB2DE9C532239D4969585942C2E1A16492358C14662FD959232428018A827D58
+      CEDEA3BA9171C29E0D1F9D4EA370D0C1131EDD68FBDDA9E10B319E4724A76E05
+      950C7E943E9720C7939CE18884CA4491726A5298106A735A7A93490C50CB2C15
+      E2E3A58DED4724B089CF1CB69F8D52248A3590AD878FB920400B3B1F485CAC27
+      5602224CFEF13FA5494219A27D31FAF2A99D5E4294C287616C456AA42891D849
+      5AC8E56CC912177769E210031CCA4B61F0779FD9D4028E3529FA49F9454D5CA0
+      0016411FAD585C2DEEF86B50F237E3A565BE9196BCEC2792EC6CBC844FC8CBB2
+      3EFAD9E494484289151C290C02AB0ACDC628F495524788E0385BE42D533166FE
+      E5660A4C5BF3BFCCD5C1C1FBD21A525735A4B538863BD35DAE8BD86AF3A57923
+      E4AE18586523865CB9DA3B5DA760C014DABAEEF7A5FBC846402F1078DB90FC7F
+      39E15B2F4DEAF9B6ACA5598A89300F03CCC7C5ABB47FA58FEE3363D89C52F01E
+      E6E4AAAA71DC1D1A5C717A9FD5E8F211F1C90C321E56E259B069F20F392219EA
+      B1A364CA630D80AFD792BBFF00ECA66CDD43FE5BA16351B87C84B6A55B4927D2
+      196EB7F529868FA8104AD763C4FDABDED831ED7B80BE3DCA1D4B97198C924004
+      35F4B29E37060DC1E33DDDFB6BF717D9FF0079FD9D4396A776BCD0F2D509ED47
+      288AD32B2F6E796933ABCCABDBDE922E0940191B2BA9F15751ECADEF46EA19F6
+      FD5321C79F012C35161A98300AC48D5A822B124DFD018485135CF3AE748EADD9
+      7D535EDA726CC10D8F2804E361F528716133A4806249561078503FA80FB39FD4
+      78877AD68C50CD42DD4B3622A711AB5B8A8A78277A3CC5D8EC55B92F1C2B5757
+      7652F3422AF72371BE589D3A277236CF738B1EE0A1DE4005548B0164790BED97
+      7D500A96D5A74E40A7493DC7ED6FDC5C79731DAEE115B37B8ACA19DB53E4208D
+      58D0020396254095463974B29D28EBCA6E67ED67B71792FA4F717136BDBBC3CD
+      0ACD4F8EE378BE37920F7AB4D738F12497399A525FBD1548A84D5D6799CED642
+      AA70EAA3B7ECFB977BFC70FB67F773891A99997D26098084289620C0FDC1AF44
+      9F61D8B61CB8C8305B81B950C2C0C24A3292BC49F51E55A9FEEA4E2FDAB1B558
+      AC37153DBE36E09F86ABC1D399E19A8F2722C1C5A5AB73DCADC749242B1CF7AF
+      546334896FB50B9024EBA6F4CCD9FA8C641FEE20710ECE45996ED0002DCD511A
+      C0A6A61315037591F6A159801A8188820C44F1E00CDF991C2C6B6CFF004DDEE2
+      B227AB4ECD537A1F740B5CBCDC5A3A5EE42C71D62CCB56FDBB9CDDAE1D6EA5E4
+      9B8E69628FEAD8768C8FBB1DE1D736EFED896567C2D0D8A1434003540202A86E
+      10402748BC5AE09B9DB6457C2770CC31E4C0410C4B448FA7D01829035017525A
+      CA01210AFA35FD37F3F5791F685DE5B8CFAB9F8D88D4844F357823B7258A9511
+      6D158AB6F92752CAA6091DE595964003E30ABE52DC62DFE0EA9B8CBB6C5EE65C
+      38A582FA8A066015D67D4AFABD21D23206202906CDE2DFBC7B3CFB2EE1C5B0DF
+      1C6BBC60ED0198A05763A6ED017987501141592B324F07FF00BAD7396B9AFB83
+      52A4D5CB0A129861E0E0582AC3C8DFB17FB33DFE5256E3ACC5C7D7782B46B5E3
+      95E391A513D827B8194FB9FF00EB1635C1D04BE4031E56E36D256147A426A075
+      5FD7C7880788ADD7A86CDB6DD83D3C602D9713E10EBC5ACDFDA588208043007E
+      90202596B83DCE51713CB146679B91A92ADD70041155967AC56DFD65EFA7924B
+      0B29DC8CF114601994ED29890FB6F69914A836D04479DED039479FFA5702DDE1
+      2AF324E4064F848BC9E73E2238FE75407BA6C3D965B3613BD2CAB3486E0864A8
+      2C0768CC9B6200BAB519890ECA70C7183B580EB68D980A34AF09E1C7E26B52DE
+      43349BB1BCFC7855337A23122D94523BF2CA2159E42E6742854CEA8655D63589
+      7E62A830060E9D5EA1E5CAA9D967FC2ABDE412004CD34F01C2965688995E5276
+      908227DD1A10E48C8D0680E83AB04240A84C389E551DB2163044D8323AABCDDD
+      2761791A32ACCDF95246D1AE99DC086C9CE0E9210DFF000A68DACDE14DBA2166
+      74DE8A7B1DD965255B059C3481595867209D4641C6A33D3DC600A031C6BF2656
+      3C928ACEC56350FBE17EE001A562158B052A3C975009C8D3A326F41279C51BDC
+      6CC486C363B6B5A52913C92C911258B038FCC2BDC3EA2031FF007B5212DCAD7A
+      027C3852124AD1B80137C71A828D9469591D4E924A530FB7054100000699D32A
+      20FCCD10F08B560F2F70458C1D8CB11D9B1BF299B2DB9B20B4E01D7230727006
+      0F59029091C050F338919CB17DAC448A3712D20653B1BF286B803523E52707A2
+      8A489F94D7C4909662FB9C818D8352582AEE2C353A84DCDA1F0D73D6452739A5
+      820DC5997C5848E10039DECD8014805D186A3035071A63A4E73CE92D58B82652
+      5C07F9989EE0208D49D46D439C79E338001E8811CAC6B08F0E34908E23B86BBF
+      C182B21473B18FE5B13B404C8C1CFE18CF4A49E7582D454324713B3489BD644C
+      320C32894ED0E4932200542E33E7E63A1264F85129BC53A55231B513590EE842
+      60AA386CA26D39DCFDC6233AFC074D3F1A211CB8D4F281993B63D6151E58F6B1
+      75C3011B4854C9875669158363C318D3CE16483F3A958C7E75605595E19F11ED
+      B48C5198C2642AC13D21E58C156595860B1CED2C46B9EA030045F8D4D49067CE
+      B60BD91CC412AD6822B0CC8D5F6410C8B2C71C324EFF0056C8AE9B44922C9EAF
+      5E84FA4E42E7AD6BA8623727803FE55B0EC9D65526E387878FE95B67F69E47E6
+      B9CE2ABC1754979A999DA4AF0431D79DE6B3DA58A4006DA712B48EEA98750C08
+      5DAAC5798F778183A765761686883C6C27F1368E5E726BB0F636439B7D852752
+      EB13C05E780F2F1F98E55EE03ECB45523FB33ED0BE6DD0866E47D87EDE95F924
+      9DA38AA4163DB7C5DB766692491A924124C64ED96F485505BD2A47C7CEE7DAFB
+      FD73AA1CCD88647DC6544D64580CB00C8166550145BD5725A45EABBE3799F2F7
+      9E7DAE9CB931E1DEB809A6F91972BA0803EBD41428379930092678ADFABAF69F
+      B7ABC76F81B76E1A30F2172396B59AD6DA66B9141CCB9B33AF211D6838BB5353
+      8DE31791253DB8A590B2C3B778E95F6D379D41732EED14B32AF0204094B08924
+      49FA4DFD400F54C57B93B5FAB375CEDC47DD6AD69A665743633A160042C5C230
+      D7A3585D4002ACD5C2DF7B71B712EDBA34DC5B4AF6A0960978A6EFC733D3BCF5
+      A078CDCAA1D8499DE9B1650C587F0E9D7B0FA3EEB1B635CB946962A410F63054
+      13F498F2E511E35077DAD9E221AC441E307CC483E57F3A6AF63FB27936BFC5F2
+      34A9C2F11B555ADA1A8B34D4262C96A9CBC7D9925FAA924B323A4AE5BB710671
+      128700E5DEB3D6B02EDF260CAC43E968BC06E4C1844002E044981A8C557ECF60
+      E32860210B02644804DEC664CF1F0BC5EBA3DF687F4E32FBAEDD0B3C6F177798
+      E2DEC98A332D20B66C453314A658C9389AB514678B2AEAD13B6E0CB9504F9F7B
+      9BBE8EC71E44CB9063DC05930D658E3CA09B1820C81041135B66FB77D27B6F69
+      FC8EA99F160D0A5A320B9D326045CD813A4C5A0DEBA7DF6DFF004BFC77B3390B
+      3CDFBDEFC028F1493DC54AAD5B6F6628152D092711CDB9182020BBBE0FA93046
+      4F00EB7DEFBAEB18D763D304E4C9E99BCC93E98123F3000F199AE1DDD5F7A4F5
+      6D92F4CED0C2CDBDDC109A9C19058FA748953279DA4FD24C122B45FF0057BFDC
+      46BFB425E57D93EC18608B8CE324B3C34362B44CD2010B04CC93B5A7826AF329
+      772444AC5D94E3C777A3BED1FF00D797EAD8F0F5AEB85BDD70AFA4C41044D869
+      9066389369BD6B78F0F41EC654EA7D6756F3BA1C6BC9AA0A62CA608016012C9F
+      4DD98721200AE1B7DE1FD437BAFEEB1BBFD72C58B1134D69A0AD24CB34502BDB
+      92E771523DA9194070768906D07D400C8F6E768FDBDE95DAE106C51558289204
+      130A178F3E1E57E55A27787DC6DEF706DDF6EDE9DBCC0516006A91616102D698
+      88E55A51CC726CB34A91B468AA2419DD2156006F65475F5655BCF50593CBAEBB
+      8300000224D710DC6ECBB18222A05C8F3758280F69DF716675F16031B72BAB6D
+      60A31927381FE1678B6EE0C816AACCD979937AA96FF26F2CF287909C7A7D5807
+      780A06FD19805C608C803AB9C7886916AAC6C84DAA276EDE091AB780273AFA89
+      23C70A14752D14728A8CCF351E9AE066C1CE15C8C1246320E7383918234FC3A9
+      0AB17A8E588E3C29A66B419481838C780CB609F1DC700E0FC7A740BCD365A78D
+      364B2FA0F891BBC723D3923403C57C3A780A1D438533CEE3CF1E235DD938C69E
+      075C74E814334193AF90FC0EBF8838186D7F78E8A2839D24CDE580069E3A93F8
+      FF00178F974BCF9D671A4589CFAB2557423C368F220789033FBFA211F8D647E7
+      5F0B06070A7768324E3C8F913A93E3D60143C2A69B7FDCFF00EC8DDE7FCBF8FE
+      CFC7A3B7FF00C7F5F1A1A6FE41BFFA8DFCB0FF00F985B381E1FCF7DBA8FF0057
+      8E7CBA4343CBCAB152368D4E3E6D0E80E324E30327A134BC4510A0ED1AE994DE
+      40CE091F96436E070EBBB381E1FBBA027F3A2F334544E080CA554A1751E321DC
+      C3700AA41D34C139CEBFB7A4F3A51314A23BC786F12C5942BAF7371618DCA589
+      56527E1E07A13C6968F8E727B65893828CC171E1A004B024863B718F86B9E818
+      5108E74E95ED3FA0B3029B8B1C92AA5B710C47CBB4E06707E6CE4F4DB0A313E3
+      6A90D4BA418F6315DB13AA12C5FD25C3C6AE0B1DA5E48D7E50A98C69E3961927
+      8D380F854C2B7211569498A5576ED956502070AA1D1B77E5A2C319DD853A3121
+      8F860F514E30C229F0DA4DAA5F0723DD91434863837C50B44AC6A230D3B92B40
+      DB800D24793B58912364640CF515B1C7CE9D57BD4BB89E5A6411B41DC8922724
+      41016924581E421E59672F0CCAAEBE8077A1941C6ECF8C5C9864DFE3E38D4A4C
+      8434CC0AB2F86E5A38ABAD8AF620A4D2B0ED579C4CD1C52472CA91CF1538D608
+      E672A55849277704780C126B7361968613F1E3CBF4A998B2022D6F8F8F1A9957
+      E4A3212E131C44F6A3B2C924244B624B0EDD9CC3DA19B11A37E580E5B25D8A82
+      408193099D2648FF000F1BF854EC6E409F83E556DF17EEDB74B94E425AAD4A61
+      CFAC92C952BC61046F2DC6BB42B068E6992AC46E4A1F491D9016899B70006BBB
+      DE9F8F2625579F41E3E40413E76B70F315B2F4CEAB936D958A8059AD1F33204F
+      21278F2E135D0DFD2EFEAEBDD1F64798E32FC7CA893845E3E5866E2AE58BA939
+      A16399AFC85D8FBB69ACCF65DC316FA88818963946E1884E7807DCFF00B51D3F
+      BC364F8C628DD6A90C00B90A40B888FF00FC81120DEBAEF4AEB9D37A9EC8F44E
+      E11EE74EC809009338F241099164DCA863E441831C6BBFDF697F58FF00697EF2
+      A721EDABDCBF0BC549C9C33C35208F97A9CD0E428C8AB4AFCFFD568B4DC7410D
+      69AC46A5188746259BD3D789BBA7ED975DED7D8A61CD81BF8432176CC55CE746
+      650A10BB8246185190818C90CB22498151BDFB7FD43A73E2EB3DA398F50C9809
+      760BA1597DB21815C6AECCF3792A79440B1A8A7EA03F4E27DC09FD5B84179E95
+      4A15E94557DBC0CCEBC5C6669AF935994412CB3DB86A58ED2B410EF88BC6249D
+      D81D43A0F71EE7A46E3F83B87C7932024B34B155330258852A3EA1759F541014
+      035D5BEDBFDD6D964C1FF15D6CE24DEBE476393385139081EDAEA3242807226A
+      21DC6A50E53120AE477DD8F68BF1D4EBB4D5D2952E02EB721C6D99E086D7317C
+      5A492C4556EA53BE268E432DB86663099A28E5290E5FBB883BD76D7550F94853
+      AF2E740180242AC5A44AC1B060260912D6D3EAF41B6DFF009B8C6691A905C106
+      0153A4E8B0950600E04F022D417DB19AD7B77969AFBD4E0797EF7250D59A6E7A
+      EEDA13DB5A763E83DC71F6F9274AEDF4FBE39D4EEECCDB6241B55CB3FDC5ED6F
+      76A30139514212020B8048D58CFA44DE0A9B6A12C78802E36585F4281EF2BA11
+      741EAE223D275483175106E622BD0F7E917DC53F21F6EE57BB254FAEB8B05E65
+      E2E2FA715E8371D46BC50D84493B54F91655FE434BDC030EDB15B0BE3EEEC5C7
+      B2EE152A32E80DA40580CD2E75C64F4B010001783245AED5E42FBF7B3C7B7EEA
+      C6DB75CABB745D3194EA2726B76620C4BE304FD6174CFA46B61278FBFDD87DDB
+      C10FB8B53DB91A4952C5AE1FEB7E9EF71762117B79B7C7DEE46F6C56A7CBF197
+      6EF1C225945936125AC4EC2A148F6E7FD64E9F972749CBD4F10C9FC71974FA9F
+      530366D32599838D6C48BA10C0020EAA9B877E70FDB7D8F4EDF64C7973643959
+      42BB3E8427D28C0A85481074082BC60EAAE1A72B225DAF0718B5B90B0D0C405F
+      5876A3C9696DCD1D9C9A315482C579DE32D089584ECCA1492762AFB736434FFB
+      A0A89E13E116E3264738B7EB5C37A826B9C624C1FD66FC2247189BFEC358FDD6
+      5B8F9D0A48D24E245596ACF14D5E5578DF2BDD859FB426919C96DC32BEA030DF
+      2EEBB386598B719AD1F76BA721593C6A9EE4EC4A0B465774719895A1ED3B28DC
+      EDB91F718DF29BF6E01F50CE4EB8EAE31458D5564F01504B2B5A393BCF3CC1C3
+      486111AC4CAA51931E8DD848E500E3700003907A9EA49B72A86C34F1A60B4C57
+      6F74C4F04922B2E776F60BB8A24EC3BA0CAC231B8905581FC74908398B1A65A0
+      DE9B448AA65C992508526EDB2144D92848DD9D5C15124723FA491B718C640D5D
+      1C2996B5A2D49A4BB51A5D32CA23894E837961133090E5460E4E3006B8CE3A38
+      BDF9D079F2A22BB9FCC323132380806029291A4846194ECC80C33E7B7275EB1A
+      E6DC290F08E734BB49190BDF0300AB681412488D4A1181969506752013FBCF48
+      2D715809E0690084C8CF0A7A63650190BAED604B07902E4F7100009071FE5D2C
+      937A4E75F163126C52412AC595C3A92A08D4B348EA0AA31019740C4924FC1648
+      AC9117E15F3692CF918440A1DB1DCC0D325A455638C824671FE5D649FC6B0457
+      C8CEE69B0B95DB9460A02051962E34CB376D478EA478F4A450CC9BF2AF824462
+      46E50154E19B006D386509A0018061F89D475814CCD64B1F95272BA854F48621
+      4A9CA943B4062A0E8094645C839C28D3C35E8C0BDE8648ACA1983A18D8204611
+      2EA3030BEB566C100E7209CFCDFBFA4204C52DF8D3DF1DFEADE43472C6626572
+      BBA44249C12C7D5210069A82474C3C4C53A9E7E356271E16C6C4F490C4ABCCCC
+      CA72F260BABC8C224CE74638504EB9F0EA0E495626A6201C389AB028D4435D60
+      82091E67051EE3AC99DA8E5D819525030615D3006723F0EA0BB9B93153D1045A
+      E6ADFF006BC366A88D2293E9ABC914693CAE9DE562AA278C31557547B2B88D4B
+      2E17C0E8C7147BCF549373C870AB7DA160428E1E3C7E26B733EC0F1B273BEF5E
+      2F8E21C4D2DECD693F32B7D6F2115154A2A4F7E3A8971255591B337A54BE408F
+      39E4FDFDBA5D9F45CD9DBE954F55B542EAF558024889E027845EBB47DB8C0773
+      D5F1E2E649E27482749D37900198E7F3B57B60FB69C45CE1BECBF0DEDCE46BC7
+      C75A1C1CD14B04334732D48668814816D5667889880C285C95C952BBBD27E427
+      746E937BD6375ED62D58DF392ADA0CB2C8624923D2E9C127E99C930C4035FDE7
+      D5B6DBAFB8397A8EC9CE5C38F2E312411A99005274B006091727EA80662F5C4A
+      FD617B26E49CCF21C544DC9F39729539A9D748F9589F8F8B88E3E3B1C8CF5658
+      2D728B2256E04C8B2AC4448C92809B1D72C3B0FDBCEA78D0AE5618F1622C2C01
+      24318580DA665AE0924713EA06BD9FDA9D4D3A9F6C62EA0AAB830E5259869D2C
+      723C28C8C028576C9A7EA10185CDEC3997FF00A2FF00AAC2D6B9068CF1F5B94A
+      75A596BC71D88D459C896BBC90414E8C5C7225A4497EA963D8DEA0CCD115EBBA
+      B757FE31D183FF009D90900C8E1C0804962D224692645A3D5352CE02D9816E26
+      44DADE26D16E56F2E55BBFFA7BFD3958F742F117F91F6ADC963C720B4A99AF6D
+      E1FA6ABCC5CE304965EDF206FC70DBAF5FF3A3915276721DB72B31EB8EF7BF7D
+      0D83E4C3B7CC09F4CB5AE4A868002C589B10622D6B546EBDDCFD27B6764DBACF
+      B8C58F381051890CBA975295241526086044ADC8275802BAF1C6F07ED4FB49C0
+      71A7943EDA85B85AECF6E5920AB0496E49E3B12B7D64B65E3579A090C9D80D2C
+      71C488A91E8840E049FF002DD7BA94E1C6EFADE23EAE3CC0E1C089306E448BD7
+      943A9F5DEBBF707AA671B03BCF6F3B4228662B8D50A81A02830A542FB90A4B12
+      59AED7D00FD6E7EB4BDA353D9DC9FB7BDA7CA4F5EFFF004AE5567A907255AB41
+      736CC6AC728BB024CB8468982956F1652849208F42FD9DFB39D4B73D6F16F7A8
+      6103683263E286D1EAB09F3FD2F615B4F6D76D61EC1E9FBAEAFD73260CBD61B1
+      4E05F507C6749D44EA1E93262E26645A2BCBEFBD3DCD639CE4279A5E42769790
+      B93ED96794CF0BB48E23FA86EE769BB66352BBFE7230A4789EBE95746E978B63
+      B75C288A11140B08B0E5F9D715EBBD6F36FB70D932396D4C4993E3CFE2E6A9AB
+      37E578D8E4040181258EE201C4982ABE962A9818C1FC475B3A6050D1FDD5A8E4
+      DDB30FFD4D53BCE5C924632F7640086183BE3620A0C07DAFB495507418240C1C
+      F8F579831A8E42A873B34DE6AABE46CBF8F7480B91A3ECC2924F980AC08F023C
+      4F56C891CAA1BBD442D48E58B0DC506990D81BB52C741A807F0D7C7A96804729
+      A86CD26A3B6AD312E371C90468480DA961A96C1F8F52512992C67CA99E794B6E
+      DC719D0B018041D751E3E3F1D3A740F0A06BDF9536BB8271E9034FDA3E3F1F1E
+      9C0BCCD35CE906663951E07209C0F94E990478E479FC0F4E01484D053052C541
+      738D00040D482C75FE21FBFA2BF1A4A099BC4683D390401A609D07C4E3FCFA38
+      B50983489241CF91C60939381F8F88071D61159E7583B60E724FC41C1F100E7E
+      18CFC7A502B26913205041C7A88F5684FA4E70B9F007C0FE1D2C5E87F7A9AF73
+      F01FF23EEF1F2FF4FCBF27FED8E8E3E7C29269A6F37FF52E47248FF8EB9AFE1F
+      5129C788FC34F874878D057C5917768B8CE48040C0F1C7900467A18345C38D1A
+      AE18105D3638D752B80A4103E520631FE5D011454B24ABB81C927D7A8DBE98FD
+      2460658EEDDE7E43A1229457D599B6EDCB0059777A46D0C4900230D703073E24
+      9EB089A59A243E1432B03827319D36EE619395D0E9A91E5D0C5E94538D6B0599
+      54680B360E76B2B36D24000FA80DB9C69A0F1E80ADA8819F9CD3AD49BD648642
+      A7C51A42147A482635DA71B9B53FBBCFA6CAF2A2079D496B5C5528237DC8A77A
+      9D8BB9B508090E190B04240F00719F1E99604F1E14E8207CEA4F5AE49B005237
+      288F32B80369691B3832109865601401B70351E7D30C826689588F954A16E234
+      D1916964AEB231499C128F33408D32ED0237464C90B9017231A6A3A8AD8FCA29
+      D1909E26D53AA7C8C05A36667318023904CAA247608228FB52AC919770A3181B
+      50104E4E748593118B54BC7900F9CD4A69DF5DF1C28B19FA975863EE5890AA42
+      159A724A8EDC850C63D5BB72E31AE4E21BE3B49E3F2A96993972353DF6E73B89
+      1DA19666B30548247323B97919582C3F5302B2CCC950AEE11A0670BAA8C83D56
+      EE76D2208F493F11CAF563B6DC056907D407C4FCAACB7F7AC9CA2C6B2C915596
+      15B65E7AD34B5E6B6123127D2D292476322C8AA3BC1CAAF6F1A9C81D52E4E9C3
+      18369062C40207991FB79D6C9B7EA8EF914B1002CC904827C85FF3E16ABE3ED1
+      7DEBE5FD8FC846F4B8F7E440E3A78A0AF0D958DA5335EA96566984D2D93208DE
+      83864AC6371BC9C07258F3BEE9ECDDAF5ADB9C7998282D32470F4B2DA00FFCAD
+      AA45BC2D5D27B6BBCB3F4DCE1F08698E4C6586A060F958D948E37BD7A0CFD2EF
+      EBDFD9DEE1E03D9FEC1E6448DCF59B10F117AD6EB56A3966B546E7D7F1863B4D
+      25C926E3A640B6648BBF5D50B1670C446DE09FB9DF63BAA74CCDB9EB1B3D3FC4
+      53AC5941D3220F0D2035E01824F28935B4756ED4DAF7A6FB375DE8F9D31F5138
+      3DC1800D3FEEE32ACDA18598850C6F1EA0A26F227BF75FEC0CBEF978EF7B558D
+      BA1CC723C76CB1C9B56B1DA1C8CFC8D7E36E515FCAB90D34991AB32359854CF6
+      22253B50C83AE5DD03B9B75D275A6FD1836353C01506594092647A8C4186B020
+      1920D74DED3FB9DB4D8ED0F4CEE68C5BCDB62C8631AB5CE354391325F4B3E96F
+      714846F4637F51C8E82A19C0FE8C1BDAB52046B35EAC77795B0B3CC96DB92B7C
+      4731661A99B91E138A7865A66BA24724162790952CCECC03BD8750FB93B8DE64
+      05C02D2B8C2C46A0490A39A90C4917D20782AF0BC1F79FA1EE4BE2D9E3CCDEDA
+      0C8032FB63320246999CB6612487C682E247103A11F61BD89CFF00DBDE3EDACC
+      F1D99F93FA5BF61E2E4659A9DF0D1246278E9CA6BBD7B97C012DADD9560412EF
+      2BBEDE53DC7BC5EB1991F68F8D085054995E6415981F4CB004C702164115C27E
+      E7F7AF4AEEFDDE3281930E0D58D436301D2093A59C6AD4A9F4E222E0CFA55156
+      79D3FDD67ED1D2E6E1E3FEE2A40B1DBE3F88A9C3DAB16DDE1E36A6D9792BF024
+      5C83ACE56C5E9EE4AD04323429B95B0AFBDC37A93FEB3F736F3A7EE5BB733168
+      672CCBA486D56061644A80165B4EA88988116BD9C765D6FB033ED371EDB6FB69
+      9D9F15D55DB1B000C80A09F6C800B06612CA0DAD5E75BDC3CBAF056578E9A2DB
+      0472D94B95E08D8F72DB08671257B175E3B54CFD414656711B464771430EDE7E
+      88F4EC07320C80F2047CBC0C58FEBE1E35C8FACE418739C6B312640F13E04DF9
+      5A7871BDAB5C7DE302D99279D6CCD627B456FDA131590ADC92793BDDD675105A
+      161C3BC6C1746F980CE46DDB278F4C0D22C3F2FD2B4DDE6259D572CC24CF8F89
+      F1E71FAD52FCB6103636C32C4AC8A421691CE03AA2B2BAF64955C160FEAF03A6
+      3ABCC2C4C4F0AA4CC8009113505E4B02A48CC908781BB26C10FBF73346B2C298
+      204AB102BB895D0C808F01D58629981C2ABF2027E7513B3DC58A44788C324437
+      AA32C864659A40A5FB6AC1036846E396F000699EA624031CAA39100D36CAE5B6
+      10C368C483B7A3AE1546E665DA5DF77F11F5E3233A0E9E16A61A629457778E4D
+      F267D647AF59584849CC8082E0956CF8E074B17B71A1B1348B6E21F45DECE8E5
+      0B104B82C1582E80346B8CE00383FBFA306DC284C7E145C93C191206EEBE5468
+      850A6C7DAB095CE30412D92083A03AF480117A52DE744FCF2119649186E917B8
+      DBD5D9B0165DC576939C63769E035EB2F143CE0FE95834BBEB95DA14C644ADE8
+      C9043687232FB9B196DD95191F8759C2B09FC45264B285DAA3B72050DB656EDB
+      A8032A8A7D1237882078369AF4B038F3A498FA4DA807184DBF2FFA501F4312DB
+      1BD208C10468469918F1E8C4D61201B524146486DF22AA97D8CC4ED0036741A6
+      D1A01FEDE9381A49F1AC247D8A4E77065460771255830C2E75276AFF00AB763A
+      2009A4079F952F15998BC6E07A994FCA0B2CAC4B150D18D8A87D5A0008C9FDDD
+      2102294F09A7DA01DA4545C2C2FB2162F87DB336D508A19977B903C40C053A9D
+      3A65A23CE8D4733567F0331565644303AE54B3EDB312B08C8291B4ABB6357041
+      0AC029F0D740206E3C0F855863303C2AD7E06B3BAAEC9B6011C9BA2770023AB6
+      FC98C3B40CDDB51AE0B13E9DBE19A8DC3413156781491C7E75757114A18F8E59
+      D67B4B1CBDB59E2462D0441B74CA8CB2B48EB100CACAF964DC7C7C02D067C84B
+      91171C2AEF6F89428837E77F8FF5ADBBFD32F1177DD1F71FDA7C551061892ED6
+      82BDCDD62CBD3486F8B776CCC21411B4554771E472CA1236CB32AEEEB90FDCCD
+      CAED3B7F7599AEE50DAD79585027C49B789102BB5FDB52B8FAA617612A864DCC
+      9D24B11F88113C448F1AF69DC2CF250F677075A940B2495B8BA904707156EBCD
+      14F8D910346DD45684579802E0C79288D804B0DC7E46756C7BFDC7556C3B15CA
+      99F2E43A44E976D4D0009D2C18B6A102E645C9315A1F5BC98F77DCDBBCFB9784
+      7DC392D955811C4FAD1EF22C3D566224800C573FBEFAFDA6F73FBA3DC1CFDF87
+      8F95388E4DED24FC8DFAD2EEAF3AD512B54ECF1E60971F5E5A312B7776AC80ED
+      61136FDABA3753C7D1026DB3865DDE1203298043DB5299B48E604441BDEBD3BF
+      6FFBF7B7763DB9B7E95BACCA77D8D0018F1B58A9680F2F227443E81A6594891E
+      E0D3427DACFD2CF1D0DDF744D3F093F10D1BD2878F46BF6459E3EE47CA5117A3
+      7E4D584B6209A97D4878CC6CB3480305FCA5EB63EBDDFB9F738716DC640ED064
+      E910D631E9BC4188336F1B9AD83BA3EE674BE88BB3C9D2B2AE6670E5C85956C6
+      713E884310DEE7B64B161A440246B35BBF53DCFF006DFEDB53E3E98B94B8C6A5
+      5E336BB53440CB125799659DC22992D106031A408173B542A85193CDD3A3757E
+      BBBAFE504C9936E6C2419624890785A493C47015E77DD749EF4EF5DCE6DC2E2C
+      99B1E4721254C292CB0A26C9F56A2EC4C4925B55AB847FAF4FD6A47CF7253FB6
+      FD83CD5F1C70E4249ECF2B5FEAFD46ACB7EB3D682ECB66D3D828C916E9847004
+      5CAE23D883AF72FD8AFB36DB4DB8EA9D770A9CDA6151A39E921880AB169B5E78
+      DE4D6F5D47A863FB7DD0B1F48DB151D5D947BB931E98022E80AA8801BEA12C26
+      4EB62751E3A7BDBEE2735EE6798DEE554CCB20CC0A59EDDB12092496DD997BB6
+      7B9626169896DCACF8F9413D7B07A4F40D9F4EC6A36F8E2DF80881004080207C
+      BC6B8BF5BEE5DE7517273649BF01C4CCC937226E6F69AD7BE6F959A2B2DDC314
+      6AD128400842E8C8A91C8D1C6374C24863C9C618BB1639009EB73DBE052915A0
+      EEB333B193E98F8F9F0A825DE5630AFDB69A284E0B07EDC9853B5C292A0492FE
+      601865551A7EDC4E4C0667FBAAB5B35A070A86F217A39125F955E49890CD9DE3
+      7E170CAA19C31472C319C675C79CEC58C88F9545C8F2B7E3559F213BE598AE11
+      1BD271F316C92BE2412CA58E9E18FD9D59E316815059AD7A87D97C6E6C0C6E20
+      86243818CFCA08C01F13D490B1634C37091519B73104B061EA39D40F2C0C01F1
+      D7F6752954117E14CB101A9B0CCC73A907071FF8B40A33E1D3B0201A0D543311
+      E231E27CF1E246081A9C7443CE90DE902F8D7391A8D09504F9FF008E3A389E14
+      278D0D23EBA1C6BBC9D7182A468C324FFD3D28A4D4795084FCC7418000048072
+      4863E01588D3A2A4BF0A41988183803438030464699D3A2D23950999A4CB6571
+      91A03A1C9FC492DE383D64785671A159F519395D3C09C819FE1D71B87FD7D101
+      49C454DF78F8B7FC8D9F9BFCBC3E6FC7C3A28FDA9B8FDE9A7916FF00EA57F38D
+      2FDACE339FFCC499274F2F0E84F1314BCA911214CA920E70491E4413907F11F8
+      FEECF491E14BC2960FB48FF1F56A3048C1181E24748452834BAC873A6370000F
+      2C8C800118F31E5FE3D0D29314445E8CB12410E0606A436718073819C6A7F0E8
+      48A599A3932A0856DCC7539F5062FE014E14E31E24FC3A1B73A5A5D080461769
+      CAAE4FCDA614AE87E52DA9F2F2E9389F2A422F6A7343860A4052836EA98D75F5
+      3A00080C4E7E18FC3A037A3934F115A2A4B60EE90E371181BBD39C0249DCA71E
+      640C79F4D959A7018E3C2A415ED008AAF26E4DA582B81B7763B684E0E1A43BC8
+      C790CE71E3D34549BD2C9E1CA9EE2B5838F93121EE6DDB236D8DB02456D4A950
+      48007A723F0E9A294BAA2FCAA4D4EECAA235121EDCA9DB2ACE22122C88CD1963
+      B5113737A7E5D74CE49398EC8A795E9F5768F2A9241CB76B6E403B91C1918ED0
+      E1C2A32B33A65D3D382751863B71A9EA33E1BDAA463CD683C29DA973D6EACDF5
+      114B226F89CA6DB28220C5A509376C07DFD969340F9287C33A74C64C21960DE9
+      F4CCC1A41BFC7ED531E3FDC9246561924958B1B714B2A4ACE1D6C81DD24289D1
+      E73DC23209560C371660315D976A08D51E1F1F2AB1C59C81249D5F3F1A9DF05C
+      DC2A8A22B6F04B09ED4D22412BCA6ACED187D9B81DC4631B3701EAF31B81A9DD
+      6D4B7159E7F88AB9D96F74C1061A63E63CA7F6ABCBEDA7DD5E7BD8FCBD5F70F0
+      77A3824E2E58EE527692328966B5A36A291E9CEB6ABDCEDC9196C4D108832AF9
+      00068FDC5DAFB3EB5B56DA6F1251C107C60883044159E16331F8D744EDEEEBDD
+      748C85F1B02844303C0893689F9DED06BB2BF627FB911E07815E13DDB4AA1E61
+      6B449CB4B5EAD76511C7B2C56B31FD3CF3D587B81885C86DB34CA08C01D78F3B
+      EBFEB71DE6F86F7A5647F6431D009322788B813F8F21CEBAC8EA3DABDE0C9B9E
+      B4726DFA9A7ABFDB6F41910754962011A6406E51699ADB38FF00BA07DB2AD6EB
+      C97B80B49B20A7523AD2CE935C1552B34AEE121A92412DB892D094122208C63C
+      020965E78FFF005D7BA32E519D5D0E74C6115805D20026E438693C74910411A8
+      19500D77FF0086F6C7F1D93FE55D1CBB3DB1482CD06203EA090029BB1218F0B5
+      11C0FF0074EFB5F0D88392A16A6B5425B46A586B1FD34CD0C912C52CD2C7C4D0
+      9CDAB3B12C46770765D865CA02BB8C05FF00AC5DC3B3746C434EE3110E93A889
+      06D258107818079C41E10797B4BB2BA8ED7D9CBBF0992F1A3537871668B5C920
+      248853AA240D53FD70FEBAF86FBF3ED4E2FDB7EDF8F94A30C082CD9B1059B304
+      3718DC35E5AB2D2AD33ACB4599832C9DD0ED222C81914957ED9F67FED0F50ED6
+      EAB93A9F592B9770C4C161A9A48D45F534C3B1FAAD7F33C195C3D13B33A3EE36
+      1D1372F9B26E5C16688F4AFA40910C79F0D204817804F11FDE5C9CB72F722524
+      675AAF34CB1CB2431C462865B4DDC8EB908CE6CB4D9C018424E4C9DC5D9EC3E9
+      D8C63C496B10073F2E7F1F845F8AF56DC1CB9DDBCCDBE5371C38FE9E736AEEF8
+      8ADD6B0639EBAF7EA3131C4595A593B80C702C56121C4B0BA12A5723C76B1623
+      375889D62C6C7E3813543974BA988B8F8FCAAA5E5234B13BB2B9EE05950B5811
+      08842A1A100B22313B37641C6848D0E8C6EB09216FE354F9E0DA2AB6E5018A04
+      757CB233B28462E51B29894C63708E4963230703B8078E4756984F2AADC90048
+      A885D09949A37999F2ECED2BC5BCBAE1C344B13CAC1879927249D3CFA9C2FC62
+      A239244F1A4ACB0690F6D5D6394210EC8B808CCD228186218072549D0019D34C
+      F4483F314D93F950BB5728D20664C9250302CB265B466D48550C0F802411E5D3
+      B78A03C292C2809DC6C86032080A49D1480EA4770326DF8E01F23A9C93430BCF
+      8D63DC0CCBB8B6010CC460EE5DD919D4856006D3A9C11D2DE84C701599334819
+      9CC8BBB0D3857669B6B3121CA0059E3DCBF1D304E3CFA202D4B022458D671D80
+      BE285D98C8AE85FF003006236B3698D19079F863A4A488345C723F6D8A0313B9
+      7222241541BDC6225F48186D3E191D0C452816FC684B0A198F6400158E77021E
+      57277317563A6DDC06A74C67A704C50958F9D2390AEA06E1AE1BC0A675507524
+      83E67E273E1D67CF85240E548D82CC9B549C68C1082B86C1576236A80DE807C7
+      03F1C744B6A4311465389BE6EE8112A6A7798972BB048CA4A646AD8DA40C9F3F
+      8A3F08344A2D521A11C28A4E17748076A4EE6E60BDEDAF22AB2E090832BB751E
+      20FC23B926C7853AA04F9D4CB8FB7246E5656FA8907A731BB2EE457DC2360364
+      79495B40AB904E483D45C896F0A958F8FAB8D5A3C6725B6485D04C8D0495F3DB
+      257679CED3B62290493C8A460FCA71827CAAB2E380458CD586369E1C2AD5A3EE
+      091E7AF6E4791E100BCA0E03E0AC9DC74243A3B42464214D8C1403A1EA973601
+      0408AB6C5B820824FC7C728ADC1FD35FDC2ADEC9F7AD6BB7AFCBC7C6B04E9372
+      32C06786B25EE3E58E28AD4B1307A95256018C833B5E354C2A3E0F30FB83D01B
+      AC7496C389753EA042837F4B0248E44F91F9F115D53B0BAE63E99D401DC34290
+      412622EA789E4058CF9445778B81FEEA5F6EBD81ED6A7C3CC287BA6E0B15A3AD
+      560E731F4CF7A4F5C6B66736E155AF1CA2C089F6C688EB133891F29E2CDC7FD7
+      CEE8EA1BF72BE9D971FF007119D0140C1586324293EA6588F5166682056F9DD1
+      D0FB23B977A7AD63DE9DA6EB2050C98D1183B584C82A448176249260FF00EA5E
+      38AFEEC3F6C7DC95EF19B8F4A32250FA93C2B4B1DDB2EC2CDF8EF519E4B10F17
+      18658E8C5124914732F72CC7BC92C447AEEFFF00EB2F706CB202857223391AA3
+      4859D10405B4B0B16F4B10AC4CD88A6D9F63F6A666030F53719D0492CBA18588
+      05543B4C3DDBD404150B106692FBA7FDDBBD85C451929FDBFE1EAC9CD5C9278E
+      DADE35071F4247124064568E6924904724AA5628EB450057673290BB5AEBA07F
+      D5AEB1BEDFB6F7A9B9C5B6224841773C4C2C00A0DE4CCF20B724495E8FD97D33
+      32FF00CBEFB36F4A300AA8DA01511F5B5DE58C49962144C8B571B7EF2FEAA7DE
+      7EFBF73CDEE3A3EE8B1C5ACA8FC7D86E1F92B34A2821856692BD396A41B69F27
+      5259650ACA08662C8A5420551EB0ECDFB5BD27A174E5D86E36EB9594EA1EE206
+      24DA58137536B785EF249365D7FEE5EE64A746CA76FB203485C791842C5B547D
+      7C6E4DD8C4D69272FEECE46E492599B91B29258DED6966B1149DD4923512A181
+      EBC90C72F922C91C60B163E9CE4F69D974EDBE04098D1748E1023FCFF535C47A
+      AF57DCEE9CE6CB95CBB5C92D33E57FF1039F0A80DCE5A47F4465770D8A4ACB60
+      BEF72121DF898C693ABB2E01DC85B182C33D5D63C000E1F1FD2B57C9B877E7F1
+      F1FAD42F95BDD999F7CCB34B239C3B1C422591D0A988811C65B7B32B6015C823
+      3E7D4FC588C4DC0A819321D502A03C87209B24406320B23AB4594288ABEA5064
+      0C6432EFC6DC82ACB9F3EA76349E3510B820D466D7211C4240AE373221888621
+      9410436A4B3B90081E03F7752571DE996702A1772EE64500290E0FA0647CA000
+      CA5F254E87F681F8F53112D5159BCA6A3176CB6F6C3127C32B87D00C04DBA28D
+      3C7F1EA4A28E14DB3531D87538D76E33953AE09234C024E7F0E9E03953448A00
+      BB313A0031E1E78D30BAEA338FF3E9CD22C68093C45245F192011B74C1F1F3D3
+      E18CF59159CA859251A819C0D083E7E1A671E00F44073A43C668776DC30A060E
+      756C0273AE096F2E96E693E7483B80B81A364786350000413FC241F8E460F440
+      73ACA1589CE33E1F310C3D449D46E00E4F91F88E8A204D0F3A4DCE1BC864E833
+      9CFC3E620B641F8E75E940FCA929073AB67C548C0DCA34C608C0C64823A58A1E
+      06A73BC7C7FF00B171F379FF008787F97457A4A68E45C0E4B91C90DFF1B73247
+      E33C846A07896FC33D09E27E74A282EE67D473AFC7032C35D77139273F0D7A4B
+      565FF0A5636C78EBF81F223F038C63C31D67CAB28B0CA7C002E3E27424819382
+      4673F874078528F3A3A0620E7200F94920FA8630CA41C82BE44F88E8489A216A
+      3D492030D3CC64019DA741E1B46079F863F6F41CE8A7973A210B14C9C305233B
+      B0182E74196C7AB4CFE1D611CF9D6016A3526099D843065459164180E324ED41
+      B892A0F811803F0E823C6B39CD168E54839CE0A10AF8EE119048519FC75DD8D3
+      C3A1E3CA969DA09414126DD4E9B75DC0F8021C92C02A9073FE3A740451163114
+      ED15BC9632C8C64663EA001040CEEDEC30490C064675F1C740544795283F953B
+      C5C848523569C2222F9918F4E5028DD901CAB608F0DA3CF1D36538D3A1A2D47D
+      5E41A4765320DCC09C1F56C1BCA8889624A1DA030D7438C74DBE2B4D16B31C6A
+      5307201D72A151D0A306070064E24280956128F10C32303F67518A11C69D5788
+      8E34EF52FA36F2CC04AA10A1D15A42AC34DC03393B46339034C9F0CF519F1D49
+      5C906A5FC572F1B58CB9D8E114AAC8D1EE0364EAF1C6701A1CBCB8C6982DE074
+      1D41CB87D263E9A9B87399B902AC6AFC8A32C0C887BCE48919A459191B73AC72
+      AA09D3B8D5F01802092C3691E3D5364C372BCBE3CAAEF06E2C1AFABF38A9BF1F
+      CF55AF552AA8642B3EC824AAC90D5915EC27791E8D9511C4BB18EC94856CB107
+      4539ABCBB26C8C59BC39F1E1E23F6ABCC1BF38D4221207970B9F03FBD292FB92
+      569DF1CB0AE2333431CD6ED4B60451C091208A1FF8BCBCC15C98FD655D430520
+      2901B5E9F8D40F403F20071FC29D7EAB989BE43C60493603F1FCAF43F1FEE9B3
+      465B11D6E409AEB2D798B4491A7D5F6025B95AAC329923ACC91028183B9761A9
+      50A0073274EC6E0315F541FC395FC7E5CA831F56CD8E4239891F8C5EC0CC7E77
+      F2A91BFBA4B3B1A6D1493D9A62A59AA5432C2F1DDAAC1EAEE3891258400253DD
+      9033B0240D0471B10BF5836699FC0F1FC79585A9DC9BF6287DB32E444785C70F
+      C381B9E34D972F45D868DDD2AAC902CA872F566AF347366582742554C731DBDB
+      70ABF3A86046E224E3C4C5A478FE63CBFC4556E4781EA8048B788FF2F0FC2AB3
+      E5B9B7B892D369E29E186C318CCDDA92B44537C51B4922BAC8118B12FB049B8E
+      D6F1CF56D87004868831F1F16AABCFB8B152640AAC6FDC995A4DEF2A97472BDB
+      91E42C2529F50921DDBDD84718247A4827273A0EAE312A902C2A9F23FCEA21C8
+      38950A2978A5322B13242E3C51D4AE23F152E46307686191A1EA762107C6A1B9
+      959F3A60987D3E0CAA16520852AE64054FCA342BB181071F1CFE1D4953E1C2A3
+      10AB4D8F23B34819D1248C6A155B6C8ACC06039932A918F5606A18EBE3D3C205
+      B95347F4A1BBAAAD230742718055B2A4872AC4AB12B21C0F21819CF8EBD15E2D
+      42748E3C2BE8F099C4832502A26C5ED9DCD864C636284500F9673D2F100565AB
+      372A640EFEA6399190F87A48F53851919D724E98FF00351C2D430099A195DBD2
+      CA447DC4656604AA91B816070C4A06C780C0200F89E8A3F2A416B8AFAADB30BA
+      03F2A6D2DB9C2904AA1538DA36FF0016A31E5D281359079F1A5E2947AF3B58EF
+      DAC08C367761CF8EE0CB9F863FC08E85B8D612381ACA5C7702E5555E256D4E24
+      008231972588907AB008CE7FC484C5A922DC693539F436BE82C5FB640C80488C
+      B311F31D3235D7AC039F3A49FCE89DEB1AAC6CA769CB852339CEE5590A31DA57
+      4D0E3C71D65E66B3E546578F7C624543DB12156DF1A98C3684AEE1AE082A1891
+      9035D7A0637BD288533F9D38C0C19D8B12EBB08DCDBBB7131562B1C7821F70C6
+      34183E5F836D4F0E3E5521A33C68357972CA02B34257B2D98CFA537B46534D48
+      C31F1C1C0E987527F2A794816A9D55BB8DF878D574DEAAC37B18808849158688
+      2068A45DDAB288DBCFCFA819072E552F13FAAA67C57380B299DBE994B02CAE93
+      495A67863DB3468766E28F146ECEC188CAE00F0EABF2E3F013FBFC70A9D8F27F
+      E5565D4F720AEA5619A5865BE60656825CD892048CEC54B38AD5A9C659C7E583
+      BB036B80C075519767EE5D802078F09F95C9ABAC1BBF6AE09BC7CF87E023E0D3
+      B4DEE1E4AC55AD0417459146348A7A768413989A2648ABC90A344A4D678E0468
+      B692542EBA004C41B2C28E599624F11FAFEF5618FA9642B679D2781BDFE048A6
+      A93DCD36D8DEDDE81D2E2AC9DC8F0D2071DD8A331AD67468CD630B226F520166
+      2320A9E93F838CF05323E3F5E7583A965562EEF25B98E3E5C3C3CFF5A0796E6A
+      0E4629F94DA2131FD34525A89446D7EC847859DA9AA24893B4357B933EE65CB9
+      3E9DCAA570ED4E23EDF117B780F9F85E00F2E77A75FA8AE49CB61C24F89F979C
+      5CF9F2B5432FF306210469257960AC19D3BF61521599E3165CF677B1CA02469E
+      ADD9EA662DACB16E04F9557EEB79E9B411C78D43AF72114FBEDC5666B31A3486
+      582C068648E033B989E690EE596CCA180CAA670493D59A612AA14800D5465CC1
+      8EA524F1A8AC9CAA4270FDA2A4A861A10FF96F23C6A6578E392391A4C1D0B460
+      0C90C71D4D4C44FAB9D436C8A2FC4543F97E4A667CCA636926545D84891F6EC8
+      DA39515F604520EC18071B4EDF007A998F108A88F90B126A196AD3B862EE6566
+      0218DFD6C91BB300A0636BAB6D539DC341E1E3D49548E1C2A3BB547E6B62432A
+      3923460E151361604FAF7920F773E7AF525122F4D96078D462D4E8CECCCD2296
+      24AB2A633A804921B0A3034009EA4058E151CB106D34C1625075CEE2C4B6092B
+      805BC806F3C6BAF4F2AC5E9B279D00CD83804609F1F4EBA00411BB43A7C474E8
+      BD250B2BEE3FF8768F86DD7030092A48F89EB00A126F342B36321738C1C635DB
+      9D35D320E7A2F3ACFDE916C6D5F57A9BE740318D463F7F5979F2A4A44B8F8781
+      D00F0D3E393AE3F6F451493E3484AC0862B8249CB6A3E5F11E65751E235D7A2A
+      490785207235CE0674CE42E0838C039C055E88525601829C367006D60BE20824
+      EECE80039D3A5E54948B0F139CAB676907C0E980753AF80EB38D24D4D773FC3F
+      FB173FBFE1FB3F0E8A966987926CF297C6318BD6F38D73FF001126A4FF000E71
+      D09A0171E741EF181A6A0E98FC4E460797E3FB3AC8F0A5E3C2884707E620E343
+      A1F0F89C6B91E7E67A4222941A2D5F4C1271E04FE07007E3D0F0A5B1E34724C4
+      01820E4000938C1F9B3E24027A18F1AC044F9518B26E5CEE50835C310A4A803D
+      2A08C9D3E1D01F0A29E54AA49A963A7880BE1EB38CB796833FB3AC3E1CE924C5
+      E8D8CE5B539014B160C4FA46188F21E38F8741CA0F1A227C28C8DF255B248CEC
+      014E48DC01F4B0C16071839FDBF874916A51E7C29D164DA648C329DA37025BCF
+      695248F5065C6467E1E5D0473A28F1A596650770D5B2586707702078F96E539F
+      869D6452C91C2888ED3B3B3B3EC0CC7C1B6B1273A0C83E19FF00D8F425401480
+      DA69D6B5B11C8C53D44E18E76FCA0670496049035D339C797800209A204FCE9E
+      E97231ACBB8162C02A901F05970AAE49C29DCC3C31E07420EBD4774269D56A7E
+      A7C94659C9F40931B6462328B1B64E5C100EFC853E1E5FBD86C669D4600CF3A9
+      357BAE6589844A26070190065959880CE188230403E39383D457C600826D5315
+      FC054DB8FE5C7A638439475712771BD3DB0F8560B1081C2A238040209C9D0787
+      55B9700373C7955862CE5440F8FDAA423DCFF4D5E18AC2C1DA0432A98184AF5E
+      268DE553276652D0DA320F9F730201D5405EA29DA06691C7E3F6A95FC985018F
+      C73A67BBEE69E7B32B426210D8FCF7596BC72AB39D5E59632373BC64360AA8DA
+      0E1176E00771ED10083C47C7C7EB40FBA727CB8D0B17B82C2016563482B3DA47
+      493CE2996BA3C890C717A424C801F52681B04E4744DB65E078C7FA50AEE98379
+      53C45EEC782B18617689B777D234F416C999E156965EEB98CC5676A2AB64FF00
+      1A9214864ED54BCB70FF004FE9FD2A42EF7D0554C19B7C7C7CA9A790F75D8B8C
+      249F2C82350D0869CA158E57CC724BDD2EADB8B1F0208C1032357B1ED157E911
+      51F26E9D8FA8DA9964E6AB3BEE78A58A091771812C4A2298E4C472D247BFB084
+      02E42960DE03C0F5217011F3A8ED950B5E7F3A62E47948C4EEC844AAAF33A7A8
+      AA2773B4C1D7312CAED292D90D80A98C83BB3D48C584817B1A61DC0E1C2F519B
+      170B17596490651402CE598223BB0452FF002A9CEF40D9CF803939EA5AAC70A8
+      ACC39D34BDC89DA488FCC102233C71F88DA46F3182ED8249C8C9F03D3E16048A
+      61C88F0A023720A0C77430C64E580CB2E72C745F94A9FC09183D38785344F856
+      41CA0C863B8B1F40655666D30776EC06F883AE0797580723C2962D3CEB069C2E
+      D8915415D6555DBBF2C99318C1390CA011E3A918F3E880A49B50F14EAED2310E
+      4ED23418F5B9C90EC4B31DBE1E3AFF008F4B16B5278D679DEA4071852A0A9272
+      095C07DB85F4F9648F4E7C75EB287871AFB20C9232408E3555CAE01473B988F9
+      C1552478163E7F874A09E7C2B2D36A522774C49F9819999C6D18560F95FCB2C7
+      55703F69F2F0E948159C38D15BD444E59B73B97548994844C60B1230148C82A3
+      5CE7F0E8471AC8B79D222550A4615DE424F715990A618164F22CA4791C7E19E9
+      C26908E429C23460771765206D0176FAD58E19A298AEDC00D920E028E849E542
+      5BCEB3DE8709811EFDCCA40608ACC708ACB96CC6C463C80D3C7CB34C09349455
+      6B0A8712490B0CEC65937146462A59771F49898A7F11F1008E9B61CC0BD3CAC3
+      853CD7B8042620490C1C47EA98A101B60DD12F6F0172356255481A6063A8E449
+      9A39E54EDC7DF68CAAB486350E815D14B0254EE69638CEFDEAA492C46D1B8827
+      5D3A67324F0E35231B11535FEA53CF559A5677C62485669D4C71C0AA76011A30
+      516B6A90036D0377E1D44F6AFE15375D893C68E8FDC49152468DAB2141563601
+      A5C7A3EA9D6368DFBBB5FBC599F0501D08037150C9C1EA861F16A71771A5647C
+      71A393DC53C48D138296642965A38B09342D0893F324DCBBE34EC2E3B6490C4E
+      7C41CB0FB504CC5A9D5DC301A799BDB952AFC93F60203D89268256692C15AEAE
+      F64281677B9088DDAC00549665DA01503A0F6541F2F2A35CBC8D8C7C1A6DB5CA
+      DCA28B0BD80EAAA933F741FCB0BDD8C598C46C2616238DCA83921F4DC1B6E8AB
+      891E5A3CAB1B3B2FA27D3513B5CCB4C66809ACE773B4ACD077212B3260F6DDDD
+      64AE42BB316C9DCD8C018D64260D37BC53393317B1E34D2DCB412A8058C93AC9
+      23C36E7DC7F24576DE1216EF0657D08660751F2B6989031303E5151CE49F9D46
+      EEDFC91147262BFA42B1DB80F2E1D9DCEF31779A338272580D3381D4A4C70262
+      F4C179A67E4ADBF755A19D5B62EE59A41B746CEE095A405946DF4B123E707C31
+      D3E8807116A64B7E751A96DA87690162483B4687D5AED73805164257507C3703
+      820E3A7D579536CD06470A8B58B8371CB9D840D3183B8801B7152AA493A8C93E
+      3D3E14F01C69AD5E34D32CE4B6ED32F819C633E274D303D593E1E7E181D3A162
+      D404F85344D20191B1F0EC767CA17393A29FE15CE9F87F9F4E006682F4DE6400
+      B1C8539D57D44EBE3EAC1C8FC3F0E8C08E1484FE748EE24EBA8C6406F3C9D31E
+      3FE79C74BE543FB522DBBC7403439033E7A11A6E03E3D2D24F8D0C65D4E75192
+      0E463C41F51D4FCA7CB1D2C5AB24520C57231A9007A4F9FF00D014F974B13486
+      912C0903C0920EE3A0031A0C7C0745CA92693624E7507C70307439CE40390490
+      31AFEFF2E885AB292624E416D415D06093E5E7AF879F4B1E349349B30F0C786D
+      D7C3400F98D35CF8F9F5949539D3E27FE44F81FF00E1FD9D2FE1437A8EF21FFF
+      0033E43C7FF3D773E3BBFF0030FF002E7FCB1D21A5E541F98F0F0FFC5E5F3796
+      7E1D272A4A553E638FF50F0F0FFF0016BBBACA5A2A2F03FF00775C78F86BBF3E
+      5FB3A1E54B45A675FDDE38F8F9F96EE8697951699CBE3B99DAD9D9B31E3FC5BF
+      4D9F1C748D4B460CE4FF0033CBC76E7F7FFB9D07E54A6965F1FE2F987FDCCE9F
+      0D338FDDD6528FA79D39479DA3F99E298D98CF836319D71FE9CFE39E82B28E8F
+      E64F1F907F2FFEE8F97CB1F1E84F3A21C2B21FBF1BBFCF6FFF001E7FCBACE548
+      78D170E712FF00333B5BE5C67C5BF9F8D33F0FC3A46E0387C78560F8F0A32BE7
+      6363C76A7CBB73FCC18DDBB4CE7C3F1C674E80C7C4D2FC7C7C70A70AFE27E7F9
+      5B3B7F6363B99FE1CFC3F1CE9D3669CA7BAFBB2FFCCC623FFF00279F2F9B3EBC
+      78E7FDEFDDD347853A9C39D4A696EECA67EB31F998C76B6677C5FF0095C7AF38
+      F9B3A7EFEA2E4FC3E3C6A463FC6A6143C4EEFABC76E0DBF459DFFCD8F1B3B3EB
+      ED7FDFFE3D9D437F28E3F1C6A663FC6294FF00F3319FABC77C7CD9F1DB631B36
+      FABB9FE5B7767CBA69BEAFEDA34E1CE992F63EA5FF009F8ECD7F9F3DEF922CEE
+      C7AB3FE9FF007B18E8D3872E3F850F33F57C4516BBBE9E3DBF51B77B677F6766
+      EEFC5B76773F3B76EDDDDC7A73B7769B3A46FAAF1F03E3F5A51F4F3E358C7BF7
+      9FE7F837CBD9F97EABF87CFB59F9BF8BC3CBA13C070A23F8536CFF00CC83F9D8
+      D876F7BFF298FA81FF0098CFAFE9B18CEED71F8E7A797F0FC3E540FCBEAE1F85
+      056B3DCF4FD0E7B91E3E8367FA07C9DCF476FF00D59FE2E8C70FEB41CFFA536D
+      CF922CEFC60FF333DACEE931B76FAB67C33A6ECF4F271A672F0E7F8D344DFC99
+      3F9BB710F8E37672B9DD8FCCECFF00A7F877631D3C38F2F8FF001A6BFB79D0BF
+      FC86CF864673F3FF00357E6D9AECDBF0F2FC7A739D31CEB087C1FF009DF31C78
+      EDC7723FE5E3FDDF8EBE1E7D17F6D0F2FC2BED9CF77CF7ED39C6CEE636AFFF00
+      B0CE3C36EBFBFA45E14AD40CBFCE97C73D9D7BBF2E723C31A67FD38D3A7397C7
+      852FF4A5A9E7B9E9EE671E5B777F17F2FB9E8EDE3C3F0FC7A13C0527F4A223F0
+      3E3F22E366718EEC3F37976F3E39D77FE1D6521AC1BF95E7FCD97E5F97F99278
+      FF00BBFEAE9470A1E55F6AE7E99BE7C624CEDDBB36E35C7F16ECE36EDF57C34C
+      F58D583E9A207F222DFB36EE5CF733B73D9D3F93F99BBE18D319E97FA529E159
+      C3F236367F357E5F1F01FEBE94D21A728BE64C63FF0099FF00EAB3B17E3A633F
+      CCF2F0FC3A5A13C690B3FCCD3FFC98CF731D8CE64CF6F7E9B7FD38D3C31D21AC
+      3CBFC694873D96FE763BD1E31B77E367F163D5B3FEF6B9C74278D1F3A765DB91
+      FCCCED4DDD9EEE7E518EFF00F0631E1B7CB39D7A6A8C5151EDC43FCAC77A5C76
+      7BBDDC61F1BB3AF6F6E719D76EECEB8E993CF870A713F1FC3E3854965F3FFCDE
+      FF00CADDF4D8ED67B099F1FC8DDF0D9A6DC7E3D3238F2A79B8FF0075231EFDBA
+      7D678D7FE4F6739FCCC777769BF3FBB19CE9D2371E54E0E5F571F8F8F9D17067
+      BCBFF9EC77AD7FE6B67773D83FF9AC7AB77C7CB66DFC3A06FA7FB780F814A389
+      E3443FC8DFF98FE67FF9FF008E731E3B9F86EC6EF2DB9CE99EA3B71FE94F2FE3
+      FE3C281F24CE3E693E4C63F9137F371A76BFD5FEEEEE8C52FE7C7E3FCE809F39
+      9FE5F934FA6DBB73B5BF9FE7DCFF004E74DDFBFA35E02B0FD1FD699AEF73E91B
+      77D5637D3DD9FA5DBF2B63B9DBF5F731F26DD77633AF4F246AE5FAD30F3A79F2
+      F0A8F58DDD9837777F9E7E4ECF67E73F3F6FFF00999FFA7CB1D495E3CAA31E03
+      E7F134CD631F511E3EAB1DAFE1DDB7F9F27CBBBD5D9F8FFBFBBA74703C38D037
+      134C76FF009F37FE673DC6F877719FE2CFA73E1F8EDC7FBDD3C9C39500E1CE98
+      6CE7B8DF36EDEBE38EE63B87E3F95DCC7879EEC79E3A7470F2A68F2FF1A6A973
+      B7F0DFE9DDB7C73AFF00BDBB19F9B4CE71AE3A70501FAA8097F833F018DDE3F3
+      6BB31AE7E19F3F0E887E149403632DE3F8637787EFFF003CEBD19E359C8FCB95
+      2527F17CDE0DE38FF51F86BB73FE7D28E342385227E5FE2F0FFDFDBCF97FEC3A
+      CE7486857F16F9BC57E7C67C35CFE38F0FC3C3A2A43C68739CB78F87FBB9F2C6
+      73AEDF8FF9F455949BF8FEE1E1F0C79E3CBFCFA51C2B39FC4D267E597C7C0F8F
+      FE2F1C6B9E9690D61AEC1F379F8631E07E3AE3E3D28A4149B781FF003F8782F8
+      FF00D9D28E559CAA73FE1FF217F9FF00D7FE5D652DFE22BFFFD9}
   end
   object VersionLabel: TLabel
     Left = 432
-    Top = 225
+    Top = 227
     Width = 61
     Height = 13
     Alignment = taRightJustify
     Caption = 'VersionLabel'
     Font.Charset = DEFAULT_CHARSET
-    Font.Color = 7118329
+    Font.Color = 8755106
     Font.Height = -11
     Font.Name = 'MS Sans Serif'
     Font.Style = []
@@ -4079,13 +3182,13 @@
   end
   object InfoLabel: TTntLabel
     Left = 8
-    Top = 224
+    Top = 227
     Width = 93
     Height = 13
     Alignment = taCenter
     Caption = 'Progress: loading ...'
     Font.Charset = DEFAULT_CHARSET
-    Font.Color = 7118329
+    Font.Color = 8755106
     Font.Height = -11
     Font.Name = 'MS Sans Serif'
     Font.Style = []

Modified: Lobby/TASClient/TASClient.dpr
===================================================================
--- Lobby/TASClient/TASClient.dpr	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/TASClient.dpr	2010-03-20 16:42:21 UTC (rev 7438)
@@ -20,32 +20,8 @@
 program TASClient;
 
 uses
-  TBXDefaultTheme,
-  TBXOfficeXPTheme,
-  TBXAluminumTheme,
   rmkThemes in 'Themes\rmkThemes.pas',
-  TBXAthenTheme in 'Themes\TBXAthenTheme.pas',
-  TBXDreamTheme in 'Themes\TBXDreamTheme.pas',
-  TBXEosTheme in 'Themes\TBXEosTheme.pas',
   TBXMirandaTheme in 'Themes\TBXMirandaTheme.pas',
-  TBXMonaiTheme in 'Themes\TBXMonaiTheme.pas',
-  TBXMonaiXPTheme in 'Themes\TBXMonaiXPTheme.pas',
-  TBXNexos2Theme in 'Themes\TBXNexos2Theme.pas',
-  TBXNexos3Theme in 'Themes\TBXNexos3Theme.pas',
-  TBXNexos4Theme in 'Themes\TBXNexos4Theme.pas',
-  TBXNexos5Theme in 'Themes\TBXNexos5Theme.pas',
-  TBXNexosXTheme in 'Themes\TBXNexosXTheme.pas',
-  TBXOffice11AdaptiveTheme in 'Themes\TBXOffice11AdaptiveTheme.pas',
-  TBXOfficeCTheme in 'Themes\TBXOfficeCTheme.pas',
-  TBXReliferTheme in 'Themes\TBXReliferTheme.pas',
-  TBXRomaTheme in 'Themes\TBXRomaTheme.pas',
-  TBXSentimoXTheme in 'Themes\TBXSentimoXTheme.pas',
-  TBXTristan2Theme in 'Themes\TBXTristan2Theme.pas',
-  TBXTristanTheme in 'Themes\TBXTristanTheme.pas',
-  TBXWhidbeyTheme in 'Themes\TBXWhidbeyTheme.pas',
-  TBXXitoTheme in 'Themes\TBXXitoTheme.pas',
-  TBXZezioTheme in 'Themes\TBXZezioTheme.pas',
-  TBXOffice12Theme in 'Themes\TBXOffice12Theme.pas',
   Forms,
   MainUnit in 'MainUnit.pas' {MainForm},
   PreferencesFormUnit in 'PreferencesFormUnit.pas' {PreferencesForm},
@@ -76,7 +52,6 @@
   HighlightingUnit in 'HighlightingUnit.pas' {HighlightingForm},
   NewAccountUnit in 'NewAccountUnit.pas' {NewAccountForm},
   IgnoreListUnit in 'IgnoreListUnit.pas' {IgnoreListForm},
-  CustomColorUnit in 'CustomColorUnit.pas' {CustomColorForm},
   MuteListFormUnit in 'MuteListFormUnit.pas' {MuteListForm},
   MapListFormUnit in 'MapListFormUnit.pas' {MapListForm},
   LoginProgressFormUnit in 'LoginProgressFormUnit.pas' {LoginProgressForm},
@@ -92,7 +67,6 @@
   MsMultiPartFormData in 'MsMultiPartFormData.pas',
   ProgressBarWindow in 'ProgressBarWindow.pas' {ProgressBarForm},
   UploadReplayUnit in 'UploadReplayUnit.pas' {UploadReplayForm},
-  TBXMacOSXG32Theme in 'Themes\TBXMacOSXG32Theme.pas',
   AwayMessageFormUnit in 'AwayMessageFormUnit.pas' {AwayMessageForm},
   ColorsPreferenceUnit in 'ColorsPreferenceUnit.pas' {ColorsPreference},
   Math,
@@ -346,9 +320,6 @@
     Misc.TryToAddLog(MainUnit.StartDebugLog,'Creating IgnoreListForm ...');
   Application.CreateForm(TIgnoreListForm, IgnoreListForm);
   if MainUnit.Debug.Enabled then
-    Misc.TryToAddLog(MainUnit.StartDebugLog,'Creating CustomColorForm ...');
-  Application.CreateForm(TCustomColorForm, CustomColorForm);
-  if MainUnit.Debug.Enabled then
     Misc.TryToAddLog(MainUnit.StartDebugLog,'Creating MuteListForm ...');
   Application.CreateForm(TMuteListForm, MuteListForm);
   if MainUnit.Debug.Enabled then

Deleted: Lobby/TASClient/Themes/TBXAthenTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXAthenTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXAthenTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2553 +0,0 @@
-unit TBXAthenTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Athen' TBX theme &#169; 2004 Roy Magne Klever
-//
-//  Last updated: 24.08.2004
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-
-type
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXAthenTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-      override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated:
-      Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms, rmkThemes;
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  GradientBmp: TBitmap;
-  gradCol1, gradCol2,
-    gradHandle1, gradHandle2, gradHandle3,
-    gradBL, gradTL: TColor;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXAthenTheme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right);
-    Inc(Bottom);
-  end;
-end;
-
-function TTBXAthenTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := false;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXAthenTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := 6;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXAthenTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXAthenTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXAthenTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXAthenTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXAthenTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXAthenTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXAthenTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-      Border.X := 1
-    else
-      Border.X := 2;
-    Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXAthenTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 1;
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXAthenTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  R: TRect;
-  IsHoriz: boolean;
-begin
-  if TBXLoColor then
-    inherited
-  else if not Transparent then
-    with Canvas do
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if not RectVisible(Handle, R) then
-        Exit;
-
-      AColor := ColorToRGB(AColor);
-      if ((AViewType and VT_TOOLBAR = VT_TOOLBAR) and (AViewType and TVT_EMBEDDED
-        = TVT_EMBEDDED)) or
-        ((AViewType and VT_POPUP) = VT_POPUP) then
-      begin
-        FillRectEx(Canvas.Handle, R, AColor);
-      end
-      else
-      begin
-        if (ADockRect.Top = 0) and
-          (ADockRect.Left = 0) and
-          (ADockRect.Right = 0) and
-          (ADockRect.Bottom = 0) then
-          IsHoriz := (ARect.Right &gt; ARect.Bottom)
-        else
-          IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-        if IsHoriz then
-        begin
-          R.Top := R.Top - 1;
-          R.Bottom := R.Bottom + 1;
-          GradientGlass(Canvas, R, false, TGTopBottom);
-          R.Top := R.Top + 1;
-          R.Bottom := R.Bottom - 1;
-        end
-        else
-        begin
-          R.Left := R.Left - 1;
-          R.Right := R.Right + 1;
-          GradientGlass(Canvas, R, false, TGLeftRight);
-          R.Right := R.Right - 1;
-          R.Left := R.Left + 1;
-        end;
-      end;
-    end;
-end;
-
-procedure TTBXAthenTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if Font.Color = clNone then
-      Font.Color := GetPartColor(ItemInfo, ipText);
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXAthenTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  C, LowC: TColor;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then
-    begin
-      C := LowC;
-    end
-    else if BtnHot then
-      C := LowC
-    else if (Embedded) or (ItemInfo.ViewType = PVT_CHEVRONMENU) then
-    begin
-      FillRectEx(Canvas.Handle, R, clWhite);
-      FrameRectEx(Canvas.Handle, R, clSilver, True);
-    end
-    else
-      FrameRectEx(Canvas.Handle, R, $00D0D0D0, True); // rmkO
-  end;
-
-begin
-  LowC := clSilver;
-
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot then
-        begin
-          if BtnPressed then
-            GradientFill(Canvas, R, clWhite, clSilver, TGTopBottom)
-          else
-          begin
-            if (ItemInfo.ViewType and VT_POPUP) &lt;&gt; 0 then
-            begin
-              GradientGlass(Canvas, R, false, TGTopBottom);
-              Pen.Color := MenuItemColors[misHot, ipFrame];
-              MoveTo(R.Left, R.Top);
-              LineTo(R.Left, R.Bottom);
-            end
-            else
-              GradientGlass(Canvas, R, true, TGTopBottom);
-          end;
-        end
-        else
-          DrawLineEx(Canvas.Handle, R.Left - 1, R.Top + 1, R.Left - 1, R.Bottom
-            - 1, $00D0D0D0);
-        PaintEnabled(R, BtnPressed);
-        DrawLineEx(Canvas.Handle, R.Left - 1, R.Top + 1, R.Left - 1, R.Bottom -
-          1, clWhite)
-
-      end;
-      if BtnDisabled then
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame],
-          True);
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            GradientFill(Canvas, BR, clWhite, clSilver, TGTopBottom)
-          else if BtnHot then
-          begin
-            if ((ItemInfo.ViewType and VT_POPUP) &lt;&gt; 0) then
-            begin
-              GradientGlass(Canvas, BR, false, TGTopBottom);
-              Pen.Color := MenuItemColors[misHot, ipFrame];
-              MoveTo(BR.Left, BR.Top);
-              LineTo(BR.Left, BR.Bottom);
-            end
-            else
-              GradientGlass(Canvas, BR, true, TGTopBottom);
-          end;
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-          begin
-            Pen.Color := clWhite;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            GradientFill(Canvas, BR, clWhite, clSilver, TGTopBottom)
-          else if BtnHot then
-          begin
-            if ((ItemInfo.ViewType and VT_POPUP) &lt;&gt; 0) then
-            begin
-              GradientGlass(Canvas, BR, false, TGTopBottom);
-              Pen.Color := MenuItemColors[misHot, ipFrame];
-              MoveTo(BR.Left, BR.Bottom - 1);
-              LineTo(BR.Left, BR.Top);
-              LineTo(BR.Right, BR.Top);
-            end
-            else
-              GradientGlass(Canvas, BR, true, TGTopBottom);
-          end;
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-          begin
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := $00D0D0D0 // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-    Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then
-      Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1;
-      RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        SmartFrame(Canvas, R, RL, RR, $00B0B0B0, clNone);
-      end
-      else
-        SmartFrame(Canvas, R, RL, RR, $00C0C0C0, clNone);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        GradientGlass(Canvas, R, true, TGTopBottom);
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-      begin
-        GradientGlass(Canvas, R, true, TGTopBottom);
-        InflateRect(R, 1, 1);
-        SmartFrame(Canvas, R, RL, RR, Blend(BtnItemColors[bisHot, ipFrame],
-          clBlack, 90), clNone);
-      end
-      else
-      begin
-        GradientFill(Canvas, R, clWhite, clSilver, TGTopBottom);
-        InflateRect(R, 1, 1);
-        SmartFrame(Canvas, R, RL, RR, $00B0B0B0, $00D0D0D0);
-      end;
-      if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      begin
-        GradientGlass(Canvas, R, true, TGTopBottom);
-        SmartFrame(Canvas, R, RL, RR, BtnItemColors[bisHot, ipFrame], clNone);
-      end;
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      GradientGlass(Canvas, R, true, TGTopBottom);
-      InflateRect(R, 1, 1);
-      SmartFrame(Canvas, R, RL, RR, GetBtnColor(ItemInfo, ipFrame), clNone);
-    end;
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      GradientGlass(Canvas, R, false, TGTopBottom);
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-
-      GradientGlass(Canvas, R, false, TGTopBottom); // rmkB
-
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[bisHot, ipFrame], True);
-        GradientGlass(Canvas, R, true, TGTopBottom)
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        FrameRectEx(Canvas.Handle, R, $00D0D0D0, True);
-        GradientFill(Canvas, R, clWhite, clSilver, TGTopBottom);
-      end;
-
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-
-      DrawButtonBitmap(Canvas, R, clBlack);
-    end;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, true);
-    end
-    else if E and (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      GradientGlass(Canvas, R, false, TGTopBottom);
-      if Pushed then
-        if (ItemInfo.ViewType and VT_POPUP) &lt;&gt; 0 then
-          Canvas.Pen.Color := MenuItemColors[misHot, ipFrame]
-        else
-          Canvas.Pen.Color := BtnItemColors[bisSelected, ipFrame]
-      else if (ItemInfo.ViewType and VT_POPUP) &lt;&gt; 0 then
-        Canvas.Pen.Color := MenuItemColors[misHot, ipFrame]
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-function TTBXAthenTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXAthenTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-  Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      //if not (Selected or Pushed and not IsPopupParent) then
-      if Selected or Pushed then
-        //  OffsetRect(ARect, 1, 1)
-      else
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 14.04.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXAthenTheme.PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if (ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX then
-    with Canvas do
-    begin
-      R.Right := R.Left + ItemInfo.PopupMargin + 2;
-      Brush.Color := clWhite;
-      FillRect(R);
-      Inc(R.Left);
-      R.Right := ARect.Right - 1;
-    end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXAthenTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-    TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then
-        Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1;
-        RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        SmartFrame(Canvas, R, RL, RR, Pen.Color, clNone);
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          GradientGlass(Canvas, R, true, TGTopBottom);
-          Pen.Color := clSilver;
-          SmartFrame(Canvas, R, 1, 1, Pen.Color, clNone);
-          Pen.Color := Blend(BtnItemColors[bisHot, ipFrame], clBlack, 90);
-          SmartFrame(Canvas, R, 2, 2, Pen.Color, clNone);
-        end
-        else
-        begin
-          GradientGlass(Canvas, R, true, TGTopBottom);
-          Pen.Color := BtnItemColors[bisHot, ipFrame]
-        end;
-        InflateRect(R, 1, 1);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40);
-        SmartFrame(Canvas, R, RL, RR, Pen.Color, clNone);
-      end;
-      if ComboPart = cpSplitRight then
-        PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := PopupSeparatorColor
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    if ((Selected) and (Enabled)) then
-    begin
-      R2 := Arect;
-      InflateRect(R2, -1, -1);
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      if HoverKind = hkMouseHover then
-        InflateRect(R, -1, -1); // smaller button in menu?
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2 + 1;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clWhite);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, gradCol1);
-      end
-      else
-      begin
-        Top := Bottom div 2;
-        MoveTo(Left, Top);
-        LineTo(Right, Top);
-      end;
-    end
-    else if enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clWhite);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, gradCol1);
-    end;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    with R do
-    begin
-      if (Toolbarinfo.IsVertical) then
-      begin
-        GradientGlass(Canvas, R, false, TGLeftRight);
-
-        R2 := R;
-        R2.Top := R.Bottom - 1;
-        R2.Bottom := R2.Bottom + 1;
-
-        if ToolbarInfo.BorderStyle &lt;&gt; bsSingle then
-          exit;
-
-        GradientFill(Canvas, R2, gradBL, Blend(gradBL, gradCol2, 30),
-          TGLeftRight);
-
-        Pen.Color := gradBL;
-        MoveTo(Right - 1, Top + 1);
-        LineTo(Right - 1, Bottom - 1);
-
-        Pixels[Left, Top] := Blend(gradCol1, gradCol2, 60);
-        Pixels[Left, Bottom - 2] := Blend(gradCol1, gradCol2, 60);
-        Pixels[Left, Bottom - 1] := $00E0E0E0;
-
-        Pixels[Right - 2, Top] := Blend(gradCol1, gradCol2, 35);
-        Pixels[Right - 1, Top] := Blend(gradCol2, gradBL, 50);
-        Pixels[Right - 1, Bottom - 1] := gradCol1;
-        Pixels[Right - 2, Bottom - 2] := Blend(gradCol1, gradBL, 50);
-      end
-      else
-      begin
-        GradientGlass(Canvas, R, false, TGTopBottom);
-        R2 := R;
-        R2.Top := R.Top + 1;
-        R2.Left := R2.Right - 1;
-
-        if ToolbarInfo.BorderStyle &lt;&gt; bsSingle then
-          exit;
-        GradientFill(Canvas, R2, gradBL, Blend(gradBL, gradCol2, 45),
-          TGTopBottom);
-
-        Pen.Color := gradBL;
-        MoveTo(Left + 1, Bottom - 1);
-        LineTo(Right - 1, Bottom - 1);
-
-        Pixels[Left, Top] := Blend(gradCol1, gradCol2, 60);
-        Pixels[Left, Bottom - 1] := $00E0E0E0;
-        Pixels[Left, Bottom - 2] := Blend(gradCol1, gradBL, 50);
-
-        Pixels[Right - 2, Top] := Blend(gradCol1, gradCol2, 35);
-        Pixels[Right - 1, Top] := $00E0E0E0;
-        Pixels[Right - 1, Bottom - 1] := $00E0E0E0;
-        Pixels[Right - 2, Bottom - 2] := Blend(gradCol1, gradBL, 50);
-      end;
-    end;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Left, DragHandleOffsets[BtnVisible,
-          ToolbarInfo.DragHandleStyle]);
-        if BtnVisible then
-          Inc(R2.Top, Sz - 2);
-        R2.Right := R2.Left + 3;
-      end
-      else
-      begin
-        Inc(R2.Top, DragHandleOffsets[BtnVisible, ToolbarInfo.DragHandleStyle]);
-        if BtnVisible then
-          Dec(R2.Right, Sz - 2);
-        R2.Bottom := R2.Top + 3;
-      end;
-
-      Pen.Color := DragHandleColor;
-      if Horz then
-      begin
-        I := R2.Top + 3;
-        while I &lt; R2.Bottom - 3 do
-        begin
-          Pen.Color := $00A0A0A0;
-          MoveTo(R2.Left, I);
-          LineTo(R2.Right, I);
-          Pen.Color := clWhite;
-          MoveTo(R2.Left, I + 1);
-          LineTo(R2.Right, I + 1);
-          Inc(I, 2);
-        end;
-      end
-      else
-      begin
-        I := R2.Left + 3;
-        while I &lt; R2.Right - 3 do
-        begin
-          Pen.Color := clGray;
-          MoveTo(I, R2.Top);
-          LineTo(I, R2.Bottom);
-          Pen.Color := clWhite;
-          MoveTo(I + 1, R2.Top);
-          LineTo(I + 1, R2.Bottom);
-          Inc(I, 2);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[bisHot, ipFrame], True);
-        GradientGlass(Canvas, R2, true, TGTopBottom);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        GradientFill(Canvas, R2, clWhite, clSilver, TGTopBottom);
-        FrameRectEx(Canvas.Handle, R2, $00D0D0D0, True);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := $00E0E0E0;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXAthenTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      GradientGlass(Canvas, R, false, TGTopBottom);
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      GradientGlass(Canvas, R, false, TGLeftRight);
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[bisHot, ipFrame], True);
-        if IsVertical then
-          GradientGlass(Canvas, R2, true, TGTopBottom)
-        else
-          GradientGlass(Canvas, R2, true, TGLeftRight);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        if IsVertical then
-          GradientFill(Canvas, R2, clWhite, clSilver, TGTopBottom)
-        else
-          GradientFill(Canvas, R2, clWhite, clSilver, TGLeftRight);
-        FrameRectEx(Canvas.Handle, R2, $00D0D0D0, True);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end;
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXAthenTheme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := clSilver;
-  gradCol2 := clWhite;
-  gradHandle1 := clBtnFace;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-  gradBL := Blend(clGray, gradCol1, 30);
-  gradTL := Blend(gradCol1, gradCol2, 50);
-
-  { View/Window Colors }
-  MenubarColor := clWhite;
-  ToolbarColor := gradCol2;
-  PopupColor := clWhite;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := $00C0C0C0;
-
-  HotBtnFace := Blend(clHighlight, clWindow, 20);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := $00909090;
-  WinFrameColors[wfsActive, wfpCaption] := clWhite;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clBtnShadow, 180);
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := $00909090;
-  PnlFrameColors[wfsActive, wfpCaption] := clWhite;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := $00D0D0D0;
-
-  BtnItemColors[bisSelected, ipBody] := Blend(clHighlight, Blend(clBtnFace,
-    clWindow, 50), 10);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := $00D0D0D0;
-
-  BtnItemColors[bisPressed, ipBody] := Blend(clHighlight, clWindow, 30);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := clRed;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clMenuText;
-  SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody],
-    180);
-  BtnItemColors[bisHot, ipFrame] := Blend($00E0A030, $00D0D0D0, 60);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(clHighlight, clWindow, 50);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText],
-    BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := ToolbarColor;
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := Blend($00E0A030, $00D0D0D0, 60);
-  //PopupFrameColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := clSilver;
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-  DragHandleColor := Blend(clBtnShadow, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-  ToolbarSeparatorColor := Blend(clBtnShadow, clWindow, 70);
-  SetContrast(ToolbarSeparatorColor, ToolbarColor, 50);
-  PopupSeparatorColor := ToolbarSeparatorColor;
-  StatusPanelFrameColor := Blend(clWindow, clBtnFace, 30);
-  SetContrast(StatusPanelFrameColor, clBtnFace, 30);
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXAthenTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXAthenTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXAthenTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXAthenTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXAthenTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    GradientGlass(Canvas, R, true, TGTopBottom);
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame];
-  end
-  else
-  begin
-    Canvas.Brush.Color := clWhite;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := $00D0D0D0;
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clBtnFace;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clBtnFace;
-    Canvas.Pixels[Right + 1, Top] := clBtnFace;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clBtnFace;
-    Canvas.Pixels[Left, Bottom + 1] := clBtnFace;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  Canvas.Pen.Color := clBtnText;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXAthenTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const DC: HDC; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG, Aqua: Boolean);
-  var
-    GSize: Integer;
-    rc1, rc2, gc1, gc2, bc1, bc2, rc3, gc3, bc3, rc4, gc4, bc4,
-      r, g, b, y1, Counter, i, d1, d2, d3: Integer;
-    Brush: HBrush;
-  begin
-    if Aqua then
-    begin
-      rc1 := $F0;
-      rc2 := $80;
-      rc3 := $70;
-      rc4 := $B0;
-      gc1 := $F8;
-      gc2 := $B0;
-      gc3 := $E8;
-      gc4 := $FF;
-      bc1 := $FF;
-      bc2 := $E0;
-      bc3 := $F0;
-      bc4 := $FF;
-    end
-    else
-    begin
-      rc1 := $F0;
-      rc2 := $C0;
-      rc3 := $D8;
-      rc4 := $F0;
-      gc1 := $F0;
-      gc2 := $C0;
-      gc3 := $D8;
-      gc4 := $F0;
-      bc1 := $F0;
-      bc2 := $C0;
-      bc3 := $D8;
-      bc4 := $F0;
-    end;
-
-    if NewG then
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      y1 := GSize div 3;
-      d1 := y1;
-      d2 := y1 + y1;
-      for i := 0 to y1 do
-      begin
-        r := rc1 + (((rc2 - rc1) * (i)) div y1);
-        g := gc1 + (((gc2 - gc1) * (i)) div y1);
-        b := bc1 + (((bc2 - bc1) * (i)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      for i := y1 to d2 do
-      begin
-        r := rc2 + (((rc3 - rc2) * (i - d1)) div y1);
-        g := gc2 + (((gc3 - gc2) * (i - d1)) div y1);
-        b := bc2 + (((bc3 - bc2) * (i - d1)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      for i := d2 to GSize do
-      begin
-        r := rc3 + (((rc4 - rc3) * (i - d2)) div y1);
-        g := gc3 + (((gc4 - gc3) * (i - d2)) div y1);
-        b := bc3 + (((bc4 - bc3) * (i - d2)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end
-    else
-    begin
-      rc1 := GetRValue(ColorToRGB(StartColor));
-      gc1 := GetGValue(ColorToRGB(StartColor));
-      bc1 := GetBValue(ColorToRGB(StartColor));
-      rc2 := GetRValue(ColorToRGB(EndColor));
-      gc2 := GetGValue(ColorToRGB(EndColor));
-      bc2 := GetBValue(ColorToRGB(EndColor));
-
-      rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-      gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-      bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-      if rc3 &lt; 0 then
-        rc3 := 0
-      else if rc3 &gt; 255 then
-        rc3 := 255;
-      if gc3 &lt; 0 then
-        gc3 := 0
-      else if gc3 &gt; 255 then
-        gc3 := 255;
-      if bc3 &lt; 0 then
-        bc3 := 0
-      else if bc3 &gt; 255 then
-        bc3 := 255;
-
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-          Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-          Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-          Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-          Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                GradientFill(Canvas, R, clWhite, clSilver,
-                  TGTopBottom)
-              else
-                GradientFill(Canvas, R, clWhite, clSilver,
-                  TGTopBottom);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              if 1 = 1 then
-              begin
-                GradientGlass(Canvas, R, true, TGTopBottom);
-                Pen.Color := BtnItemColors[bisHot, ipFrame];
-              end
-              else
-              begin
-                GradientGlass(Canvas, R, true, TGTopBottom);
-                Pen.Color := clSilver;
-              end;
-            end
-            else
-            begin
-              GradientGlass(Canvas, R, true, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              GradientGlass(Canvas, R, true, TGTopBottom);
-              Pen.Color := BtnItemColors[bisSelected, ipFrame]; //clSilver;
-              InflateRect(R, 1, 1);
-            end
-            else
-            begin
-              InflateRect(R, -1, -1);
-              GradientFill(Canvas, R, clWhite, clSilver,
-                TGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                RadioGradient(Canvas.Handle, R, clWhite, clSilver, false, false)
-              else
-                RadioGradient(Canvas.Handle, R, clWhite, clSilver, false,
-                  false);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              if 1 = 1 then
-              begin
-                RadioGradient(Canvas.Handle, R, clNavy, clWhite, true, true);
-                Pen.Color := BtnItemColors[bisHot, ipFrame];
-              end
-              else
-              begin
-                RadioGradient(Canvas.Handle, R, clWhite, clNavy, false, true);
-                Pen.Color := clSilver;
-              end;
-            end
-            else
-            begin
-              RadioGradient(Canvas.Handle, R, clNavy, clWhite, true, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas.Handle, R, clWhite, clSilver, true, true);
-              Pen.Color := BtnItemColors[bisSelected, ipFrame];
-              InflateRect(R, 1, 1);
-            end
-            else
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas.Handle, R, clWhite, clSilver, false, false);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXAthenTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-var
-  Hi, Lo: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          GradientGlass(Canvas, R, false, TGTopBottom);
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3,
-            clBtnShadow);
-          DrawLineEx(Canvas.Handle, R.Right + 1, R.Top + 5, R.Right + 1, R.Bottom
-            - 2, clBtnHighLight);
-        end;
-      SBP_GRIPPER:
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Lo := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Hi := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXAthenTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  RegisterTBXTheme('Athen', TTBXAthenTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXDreamTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXDreamTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXDreamTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2629 +0,0 @@
-unit TBXDreamTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-//
-// 'Dream' theme &#169; 2004 Roy Magne Klever
-//
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE}
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXDreamTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms, rmkThemes;
-
-var
-  StockImgList      : TImageList;
-  CounterLock       : Integer;
-  GradientBmp       : TBitmap;
-  gradCol1, gradCol2,
-    gradHandle1, gradHandle2, gradHandle3,
-    gradBL, gradTL  : TColor;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXDreamTheme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right);
-    Inc(Bottom);
-  end;
-end;
-
-function TTBXDreamTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXDreamTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT           = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 7;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-
-    TMI_TLBR_SEPARATORSIZE: Result := 5;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXDreamTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXDreamTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1             : array[Boolean] of TBtnItemState = (bisDisabled,
-    bisDisabledHot);
-  BFlags2             : array[Boolean] of TBtnItemState = (bisSelected,
-    bisSelectedHot);
-  BFlags3           : array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B                 : TBtnItemState;
-  Embedded          : Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXDreamTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1             : array[Boolean] of TMenuItemState = (misDisabled,
-    misDisabledHot);
-  MFlags2           : array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1             : array[Boolean] of TBtnItemState = (bisDisabled,
-    bisDisabledHot);
-  BFlags2             : array[Boolean] of TBtnItemState = (bisSelected,
-    bisSelectedHot);
-  BFlags3           : array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M                 : TMenuItemState;
-  B                 : TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then Result := ToolbarColor;
-        if ItemPart = ipFrame then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-var
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize    : Integer;
-
-  Row               : PRGBTripleArray;
-  GradCol           : TRGBTriple;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then
-    rc3 := 0
-  else if rc3 &gt; 255 then
-    rc3 := 255;
-  if gc3 &lt; 0 then
-    gc3 := 0
-  else if gc3 &gt; 255 then
-    gc3 := 255;
-  if bc3 &lt; 0 then
-    bc3 := 0
-  else if bc3 &gt; 255 then
-    bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GradientBmp.Width := 1;
-    GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-    GSize := GradientBmp.Height;
-
-    y1 := GSize div 2;
-    for i := 0 to y1 - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[0] := GradCol;
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for i := y1 to GSize - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc3 + (((rc2 - rc3) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc3 + (((gc2 - gc3) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc3 + (((bc2 - bc3) * (i)) div GSize));
-      Row[0] := GradCol;
-    end;
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end
-  else
-  begin
-    GradientBmp.Width := (ARect.Right - ARect.Left) - 1;
-    GradientBmp.Height := 1;
-    GSize := GradientBmp.Width;
-
-    y1 := GSize div 2;
-    Row := PRGBTripleArray(GradientBmp.ScanLine[0]);
-    for i := 0 to y1 - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[i] := GradCol;
-    end;
-
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-
-    for i := y1 to GSize - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc2 + (((rc3 - rc2) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc2 + (((gc3 - gc2) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc2 + (((bc3 - bc2) * (i)) div GSize));
-      Row[i] := GradCol;
-    end;
-
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end;
-end;
-
-procedure GradientFill(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2, Counter, GSize: Integer;
-  Brush             : HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left, ARect.Top, ARect.Right,
-        ARect.Bottom - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left, ARect.Top, ARect.Right -
-        Counter, ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern           : array[0..15] of Byte =
-    ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern           : array[0..15] of Byte =
-    (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp               : TBitmap;
-  W, H              : Integer;
-  Index             : Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXDreamTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXDreamTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXDreamTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXDreamTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics          : array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics          : array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable         : Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-      Border.X := 1
-    else
-      Border.X := 2;
-    Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXDreamTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXDreamTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  R                 : TRect;
-begin
-  if not Transparent then
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if not RectVisible(Canvas.Handle, R) then Exit;
-
-    AColor := ColorToRGB(AColor);
-    if ((AViewType and VT_TOOLBAR = VT_TOOLBAR) and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) or
-      ((AViewType and VT_POPUP) = VT_POPUP) then
-    begin
-      FillRectEx(Canvas.Handle, R, AColor);
-    end
-    else
-    begin
-      if (ARect.Right &gt; ARect.Bottom) then
-        GradientFill(Canvas, R, $00DCD8D0, clWhite, TGTopBottom)
-      else
-        GradientFill(Canvas, R, $00DCD8D0, clWhite, TGLeftRight);
-    end;
-
-    {
-    if ((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      and (not (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW)
-      or ((AViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-      if IsHoriz then
-        GradientFill(Canvas, R, $00DCD8D0, clWhite, TGTopBottom)
-          //FillGradient(Canvas, R, $00DCD8D0, clWhite, TGTopBottom)
-      else
-        GradientFill(Canvas, R, $00DCD8D0, clWhite, TGLeftRight);
-      //FillGradient(Canvas, R, $00DCD8D0, clWhite, TGLeftRight);
-    end
-    else
-    begin
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      //FillGradient(Canvas, R, $00DCD8D0, clWhite, TGLeftRight);
-      FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-    end;
-    }
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R                 : TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if Font.Color = clNone then Font.Color := GetPartColor(ItemInfo, ipText);
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y              : Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXDreamTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern           : array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2                : TRect;
-  Bmp               : TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-
-const
-  ArrowColor        : array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR             : TRect;
-  X, Y              : Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then
-    else if BtnHot then
-    else if Embedded then
-    begin
-      FillRectEx(Canvas.Handle, R, $00F4F0F0);
-      FrameRectEx(Canvas.Handle, R, $00D0D0D0, True);
-    end else
-      FrameRectEx(Canvas.Handle, R, $00D0D0D0, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot then
-        begin
-          if BtnPressed then
-          begin
-            FillGradient(Canvas, R, clWhite, clSilver, TGTopBottom);
-            //GradientFill(Canvas, R, clWhite, clSilver, TGTopBottom);
-            Pen.Color := $00808080;
-            DrawLineEx(Canvas.Handle, R.Left - 1, R.Top, R.Left - 1, R.Bottom, $00808080);
-          end else
-          begin
-            FillRectEx(Canvas.Handle, R, $00F4F0F0);
-            Pen.Color := $00808080;
-            DrawLineEx(Canvas.Handle, R.Left - 1, R.Top, R.Left - 1, R.Bottom, $00808080);
-          end;
-        end else
-        begin
-          DrawLineEx(Canvas.Handle, R.Left - 1, R.Top + 1, R.Left - 1, R.Bottom - 1, $00D0D0D0);
-          DrawLineEx(Canvas.Handle, R.Left - 1, R.Top + 1, R.Left - 1, R.Bottom - 1, clWhite)
-        end;
-        PaintEnabled(R, BtnPressed);
-      end;
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame], True);
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient(Canvas, BR, clWhite, clSilver, TGTopBottom)
-            //GradientFill(Canvas, BR, clWhite, clSilver, TGTopBottom)
-          else
-          if BtnHot then
-          begin
-            FillRectEx(Canvas.Handle, BR, $00F4F0F0);
-            Pen.Color := $00808080;
-          end;
-          MoveTo(BR.Left, BR.Top);
-          LineTo(BR.Left, BR.Bottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-          begin
-            Pen.Color := clWhite;
-          end else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      R:= BR;
-      R.Top:= R.Top + 1;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient(Canvas, R, clWhite, clSilver, TGTopBottom)
-          else if BtnHot then
-          begin
-            FillRectEx(Canvas.Handle, BR, $00F4F0F0);
-            Pen.Color := $00808080;
-          end;
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-          begin
-            Pen.Color := clWindow;
-          end else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        if (BtnPressed) then
-          Pen.Color:= $00808080;
-        MoveTo(BR.Left, BR.Bottom - 1);
-        LineTo(BR.Left, BR.Top);
-        LineTo(BR.Right, BR.Top);
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R                 : TRect;
-  W                 : Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := $00D0D0D0 // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y              : Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT         : TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  R                 : TRect;
-  RL, RR            : Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then Dec(RR, 2); // 1
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1;
-      RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        ButtonFrame(Canvas, R, RL, RR, $00808080, clNone, $00A0A0A0);
-      end else
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, $00F0F0F0);
-        InflateRect(R, 1, 1);
-        ButtonFrame(Canvas, R, RL, RR, $00F0F0F0, clNone, clSilver);
-      end;
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        if Pushed then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, $00DCD8D0);
-          InflateRect(R, 1, 1);
-          ButtonFrame(Canvas, R, RL, RR, $00808080, clNone, $00909090);
-        end
-        else
-          ButtonFrame(Canvas, R, RL, RR, BtnItemColors[bisHot, ipFrame], clNone, clSilver);
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-
-      if not Pushed then
-      begin
-        if HoverKind = hkNone then
-        begin
-          GradientFill(Canvas, R, $00F0FDFF, $00D0F8FF, TGTopBottom);
-          InflateRect(R, 1, 1);
-          Pen.Color := $00A0A0A0;
-          RoundFrame(Canvas, R, 1, 1);
-          InflateRect(R, -1, -1);
-          Pen.Color := $00B0D4DF;
-          MoveTo(R.Left, R.Bottom - 2);
-          LineTo(R.Left, R.Top);
-          LineTo(R.Right, R.Top);
-          Pen.Color := $00808080;
-        end else
-        begin
-          GradientFill(Canvas, R, $0080E0FF, $002090E8, TGTopBottom);
-          InflateRect(R, 1, 1);
-          Pen.Color := $00A0A0A0;
-          RoundFrame(Canvas, R, 1, 1);
-          InflateRect(R, -1, -1);
-          Pen.Color := $0060B0E8;
-          MoveTo(R.Left, R.Bottom - 2);
-          LineTo(R.Left, R.Top);
-          LineTo(R.Right, R.Top);
-          Pen.Color := $00808080;
-        end;
-
-        InflateRect(R, 1, 1);
-        RoundFrame(Canvas, R, RL, RR);
-      end else
-      begin
-        InflateRect(R, 1, 1);
-        Pen.Color := $00D0D0D0;
-        RoundFrame(Canvas, R, 1, 1);
-        InflateRect(R, -1, -1);
-        FillGradient(Canvas, R, clWhite, clSilver, TGTopBottom);
-        Pen.Color := $00909090;
-        InflateRect(R, 1, 1);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-    end else
-    if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      Pen.Color := $00E0E0E0;
-      RoundFrame(Canvas, R, 1, 1);
-      InflateRect(R, -1, -1);
-      FillRectEx(Canvas.Handle, R, $00F4F0F0);
-      InflateRect(R, 1, 1);
-      Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates           : array[Boolean] of TWinFramestate = (wfsInactive,
-    wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState          : TWinFrameState;
-  BtnItemState      : TBtnItemState;
-  SaveIndex, X, Y   : Integer;
-  Sz                : TPoint;
-  R                 : TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel       : Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp             : TBitmap;
-    DC              : HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      GradientFill(Canvas, R, $00DCD8D0, clWhite, TGTopBottom);
-
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-
-      GradientFill(Canvas, R, $00DCD8D0, clWhite, TGTopBottom);
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R, clGray, True);
-        FillRectEx(Canvas.Handle, R, clWhite);
-        DrawButtonBitmap(Canvas, R, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        FrameRectEx(Canvas.Handle, R, clGray, True);
-        FillRectEx(Canvas.Handle, R, clSilver);
-        DrawButtonBitmap(Canvas, R, clWhite);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-        DrawButtonBitmap(Canvas, R, clBlack);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R                 : TRect;
-  E                 : Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      //FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if E and (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      GradientFill(Canvas, R, $00DCD8D0, clWhite, TGTopBottom);
-      //FillGradient(Canvas, R, $00DCD8D0, clWhite, TGTopBottom);
-      //FillRectEx(Canvas.Handle, R, $00DCD8D0 { $00d0d0d0});
-      if Pushed then
-        Canvas.Pen.Color := $00909090
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-function TTBXDreamTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXDreamTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-    Integer);
-var
-  HiContrast        : Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin // rmk Removed the shados under the glyphs
-        // aaa
-        //DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        //OffsetRect(ARect, 1, 1);
-        //DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        //OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index             : Integer;
-  X, Y              : Integer;
-  Bmp               : TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXDreamTheme.PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R                 : TRect;
-begin
-  R := ARect;
-  if (ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX then
-    with Canvas do
-    begin
-      R.Right := R.Left + ItemInfo.PopupMargin + 2;
-      Brush.Color := clWhite;
-      //FillRect(R);
-      Inc(R.Left);
-      R.Right := ARect.Right - 1;
-    end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXDreamTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT         : TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  R, R2             : TRect;
-  X, Y              : Integer;
-  ArrowWidth        : Integer;
-  ClrText           : TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-    TTBXItemInfo);
-  var
-    R               : TRect;
-    RL, RR          : Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1;
-        RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          GradientFill(Canvas, R, $00F0FDFF, $00D0F8FF, TGTopBottom);
-          Pen.Color := $00B0D4DF;
-          MoveTo(R.Left, R.Bottom - 2);
-          LineTo(R.Left, R.Top);
-          LineTo(R.Right, R.Top);
-          Pen.Color := $00808080;
-          InflateRect(R, 1, 1);
-          RoundFrame(Canvas, R, RL, RR);
-        end else
-        begin
-          GradientFill(Canvas, R, $0080E0FF, $002090E8, TGTopBottom);
-          Pen.Color := $0060B0E8;
-          MoveTo(R.Left, R.Bottom - 2);
-          LineTo(R.Left, R.Top);
-          LineTo(R.Right, R.Top);
-          Pen.Color := $00808080;
-          InflateRect(R, 1, 1);
-          RoundFrame(Canvas, R, RL, RR);
-        end;
-        InflateRect(R, 1, 1);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := clWhite
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := Arect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      InflateRect(R, -1, -1);
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR                : TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-    Pen.Color := PopupFrameColor;
-    Pixels[1, 1] := PopupFrameColor;
-    Pixels[R.Right - 1, 1] := PopupFrameColor;
-    Pixels[1, R.Bottom - 1] := PopupFrameColor;
-    Pixels[R.Right - 1, R.Bottom - 1] := PopupFrameColor;
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then Left := R.Left - 1;
-            if Right &gt;= R.Right then Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then Left := R.Left - 1;
-            if Right &gt;= R.Right then Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox         : Boolean;
-  R                 : TRect;
-  i                 : integer;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2 + 1;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clWhite);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, ToolbarColor);
-      end else
-      begin
-        Top := Bottom div 2;
-        i := 14;
-        while i &lt; Right - 14 do
-        begin
-          Canvas.Pixels[i, Top] := $00909090;
-          i := i + 3;
-        end;
-      end;
-    end
-    else if enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clWhite);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, ToolbarColor);
-    end;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets   : array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2,
-    0, 1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz                : Integer;
-  R2                : TRect;
-  I                 : Integer;
-  BtnVisible, Horz  : Boolean;
-  BtnItemState      : TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (ToolbarInfo.ViewType = VT_TOOLBAR)
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW)
-      or ((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-    begin
-
-      with R do
-      begin
-        if (R.Right &gt; R.Bottom) then
-        begin
-          R2 := r;
-          R2.Top := R2.Top + 2;
-          R2.Bottom := R.Bottom - 2;
-          GradientFill(Canvas, R, $00DCD8D0, clWhite, TGTopBottom);
-          GradientFill(Canvas, R2, $00DCD8D0, clWhite, TGTopBottom);
-        end
-        else
-          GradientFill(Canvas, R, $00DCD8D0, clWhite, TGLeftRight);
-        R2 := R;
-        R2.Left := R2.Right - 1;
-
-        R2.Top := R2.Top + 1;
-
-        Pen.Color := gradBL;
-        MoveTo(Left + 2, Bottom - 1);
-        LineTo(Right - 3, Bottom - 1);
-        LineTo(Right - 1, Bottom - 3);
-        LineTo(Right - 1, Top);
-
-        Pen.Color := clWhite;
-        MoveTo(Left + 1, Bottom - 2);
-        LineTo(Left, Bottom - 3);
-        LineTo(Left, Top + 2);
-        LineTo(Left + 2, Top);
-        LineTo(Right - 3, Top);
-        LineTo(Right - 1, Top + 2);
-
-        Pen.Color := $00E0E0E0;
-        MoveTo(Left, Top);
-        LineTo(Left, Top + 1);
-        LineTo(Left + 2, Top - 1);
-
-        MoveTo(Right - 1, Top);
-        LineTo(Right - 2, Top);
-        LineTo(Right, Top + 2);
-
-        MoveTo(Left, Bottom - 1);
-        LineTo(Left, Bottom - 2);
-        LineTo(Left + 2, Bottom);
-
-        MoveTo(Right - 1, Bottom - 2);
-        LineTo(Right - 2, Bottom - 1);
-        LineTo(Right, Bottom - 1);
-      end;
-      InflateRect(R, -2, -2);
-    end
-    else
-      InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-        if Horz then
-          OffsetRect(R2, -1, 0)
-        else
-          OffsetRect(R2, 0, -1);
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-        if Horz then
-          OffsetRect(R2, -1, 0)
-        else
-          OffsetRect(R2, 0, -1);
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := clWhite;
-          Pixels[R2.Left, i + 1] := clWhite;
-          Pixels[R2.Left + 1, i] := clWhite;
-          Pixels[R2.Left + 1, i + 1] := clBlack;
-          Pixels[R2.Left + 1, i + 2] := $00B0B0B0;
-          Pixels[R2.Left + 2, i + 2] := $00B0B0B0;
-          Pixels[R2.Left + 2, i + 1] := $00B0B0B0;
-          Pixels[R2.Left + 2, i] := $00B0B0B0;
-          Pixels[R2.Left, i + 2] := $00B0B0B0;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := clWhite;
-            Pixels[R2.Left + 4, i + 1] := clWhite;
-            Pixels[R2.Left + 4 + 1, i] := clWhite;
-            Pixels[R2.Left + 4 + 1, i + 1] := clBlack;
-            Pixels[R2.Left + 4 + 1, i + 2] := $00B0B0B0;
-            Pixels[R2.Left + 4 + 2, i + 2] := $00B0B0B0;
-            Pixels[R2.Left + 4 + 2, i + 1] := $00B0B0B0;
-            Pixels[R2.Left + 4 + 2, i] := $00B0B0B0;
-            Pixels[R2.Left + 4, i + 2] := $00B0B0B0;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := clWhite;
-          Pixels[i, R2.Top + 1] := clWhite;
-          Pixels[i + 1, R2.Top] := clWhite;
-          Pixels[i + 1, R2.Top + 1] := clBlack;
-          Pixels[i + 1, R2.Top + 2] := $00B0B0B0;
-          Pixels[i + 2, R2.Top + 2] := $00B0B0B0;
-          Pixels[i + 2, R2.Top + 1] := $00B0B0B0;
-          Pixels[i + 2, R2.Top] := $00B0B0B0;
-          Pixels[i, R2.Top + 2] := $00B0B0B0;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := clWhite;
-            Pixels[i, R2.Top + 1 + 4] := clWhite;
-            Pixels[i + 1, R2.Top + 4] := clWhite;
-            Pixels[i + 1, R2.Top + 1 + 4] := clBlack;
-            Pixels[i + 1, R2.Top + 2 + 4] := $00B0B0B0;
-            Pixels[i + 2, R2.Top + 2 + 4] := $00B0B0B0;
-            Pixels[i + 2, R2.Top + 1 + 4] := $00B0B0B0;
-            Pixels[i + 2, R2.Top + 4] := $00B0B0B0;
-            Pixels[i, R2.Top + 2 + 4] := $00B0B0B0;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-
-    if BtnVisible then
-    begin
-      R2 := R;
-
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R2, clGray, True);
-        FillRectEx(Canvas.Handle, R2, clWhite);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        FrameRectEx(Canvas.Handle, R2, clGray, True);
-        FillRectEx(Canvas.Handle, R2, clSilver);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end;
-      {
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-      }
-    end;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R                 : TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := $00E0E0E0;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXDreamTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor    : TColor;
-  I, Sz, Flags      : Integer;
-  R2                : TRect;
-  BtnItemState      : TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      GradientFill(Canvas, R, $00DCD8D0, clWhite, TGTopBottom);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-        clSilver);
-      R.Bottom := R.Bottom - 1;
-    end else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      GradientFill(Canvas, R, $00DCD8D0, clWhite, TGLeftRight);
-      DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom,
-        clSilver);
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R2, clGray, True);
-        FillRectEx(Canvas.Handle, R2, clWhite);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        FrameRectEx(Canvas.Handle, R2, clGray, True);
-        FillRectEx(Canvas.Handle, R2, clSilver);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end;
-    end;
-
-    R2 := R;
-    if IsVertical then
-    begin
-      Inc(R2.Top, 2);
-      Dec(R2.Bottom, 2);
-      Inc(R2.Left, 1);
-      i := R2.Top;
-      while (i &lt; R2.Bottom - 1) do
-      begin
-        Pixels[R2.Left, i] := clWhite;
-        Pixels[R2.Left, i + 1] := clWhite;
-        Pixels[R2.Left + 1, i] := clWhite;
-        Pixels[R2.Left + 1, i + 1] := clBlack;
-        Pixels[R2.Left + 1, i + 2] := $00B0B0B0;
-        Pixels[R2.Left + 2, i + 2] := $00B0B0B0;
-        Pixels[R2.Left + 2, i + 1] := $00B0B0B0;
-        Pixels[R2.Left + 2, i] := $00B0B0B0;
-        Pixels[R2.Left, i + 2] := $00B0B0B0;
-        Inc(i, 4);
-      end;
-    end
-    else
-    begin
-      Inc(R2.Left, 2);
-      Dec(R2.Right, 2);
-      Inc(R2.Top, 1);
-      i := R2.Left;
-      while (i &lt; R2.Right - 1) do
-      begin
-        Pixels[i, R2.Top] := clWhite;
-        Pixels[i, R2.Top + 1] := clWhite;
-        Pixels[i + 1, R2.Top] := clWhite;
-        Pixels[i + 1, R2.Top + 1] := clBlack;
-        Pixels[i + 1, R2.Top + 2] := $00B0B0B0;
-        Pixels[i + 2, R2.Top + 2] := $00B0B0B0;
-        Pixels[i + 2, R2.Top + 1] := $00B0B0B0;
-        Pixels[i + 2, R2.Top] := $00B0B0B0;
-        Pixels[i, R2.Top + 2] := $00B0B0B0;
-        Inc(i, 4);
-      end;
-    end;
-
-    if IsVertical then
-      InflateRect(R, -9, 0)
-    else
-      InflateRect(R, 0, -9);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXDreamTheme.SetupColorCache;
-var
-  HotBtnFace, DisabledText: TColor;
-
-begin
-  gradCol1 := $00DCD8D0;
-  gradCol2 := $00DCD8D0;
-  gradHandle1 := clBtnFace;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-  gradBL := $00B0B0B0;
-  gradTL := Blend(gradCol1, gradCol2, 50);
-
-  { View/Window Colors }
-  MenubarColor := clWhite;
-  ToolbarColor := $00DCD8D0;
-  PopupColor := clWhite;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := $00C0C0C0;
-  PopupSeparatorColor := clSilver;
-
-  HotBtnFace := Blend(clHighlight, clWindow, 20);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := clSilver;
-
-  WinFrameColors[wfsActive, wfpBorder] := $00909090;
-  WinFrameColors[wfsActive, wfpCaption] := clWhite;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clBtnShadow, 180);
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := $00909090;
-  PnlFrameColors[wfsActive, wfpCaption] := clWhite;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := $00D0D0D0;
-
-  BtnItemColors[bisSelected, ipBody] := Blend(clHighlight, Blend(clBtnFace,
-    clWindow, 50), 10);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := clSilver;
-
-  BtnItemColors[bisPressed, ipBody] := Blend(clHighlight, clWindow, 30);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := clRed;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clMenuText;
-  SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody],
-    180);
-  BtnItemColors[bisHot, ipFrame] := $00A0A0A0;
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(clHighlight, clWindow, 50);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText],
-    BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := ToolbarColor;
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := clSilver;
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-end;
-
-function TTBXDreamTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXDreamTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXDreamTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXDreamTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXDreamTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R                 : TRect;
-  X, Y, Sz          : Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    FillGradient(Canvas, R, $00F0F0F0, clWhite, TGTopBottom);
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame];
-  end
-  else
-  begin
-    Canvas.Brush.Color := clWhite;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := $00D0D0D0;
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clBtnFace;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clBtnFace;
-    Canvas.Pixels[Right + 1, Top] := clBtnFace;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clBtnFace;
-    Canvas.Pixels[Left, Bottom + 1] := clBtnFace;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  Canvas.Pen.Color := clBtnText;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXDreamTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs                : array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1,
-    3);
-var
-  X, Y              : Integer;
-  rc1, gc1, bc1,
-  rc2, gc2, bc2,
-  rc3, gc3, bc3,
-  y1, i, j, GSize   : Integer;
-  Row               : PRGBTripleArray;
-  GradCol           : TRGBTriple;
-  Brush             : HBrush;
-
-  procedure RadioGradient(const Canvas: TCanvas; const ARect: TRect;
-    const StartColor, EndColor: TColor; Shadow: TColor);
-  var
-    i               : integer;
-  begin
-    rc1 := GetRValue(ColorToRGB(StartColor));
-    gc1 := GetGValue(ColorToRGB(StartColor));
-    bc1 := GetBValue(ColorToRGB(StartColor));
-    rc2 := GetRValue(ColorToRGB(EndColor));
-    gc2 := GetGValue(ColorToRGB(EndColor));
-    bc2 := GetBValue(ColorToRGB(EndColor));
-
-    rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-    gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-    bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-    if rc3 &lt; 0 then rc3 := 0 else if rc3 &gt; 255 then rc3 := 255;
-    if gc3 &lt; 0 then gc3 := 0 else if gc3 &gt; 255 then gc3 := 255;
-    if bc3 &lt; 0 then bc3 := 0 else if bc3 &gt; 255 then bc3 := 255;
-
-    j:= 0;
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    if Shadow &lt;&gt; clWhite then
-    begin
-      i:= GSize;
-      Brush := CreateSolidBrush(Shadow);
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom
-       - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-      DeleteObject(Brush);
-      j:= 1;
-    end;
-
-    for i := 0 to GSize - j do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * i) div GSize)),
-            Byte(gc1 + (((gc2 - gc1) * i) div GSize)),
-            Byte(bc1 + (((bc2 - bc1) * i) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom
-        - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-      if Shadow &lt;&gt; clWhite then
-        Canvas.Pixels[ARect.Left + Offs[i], ARect.Bottom - i - 1]:= Shadow;
-      DeleteObject(Brush);
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                //GradientFill(Canvas, R, $0080E0FF, $002090E8, TGTopBottom)
-                GradientFill(Canvas, R, clWhite, clSilver, TGTopBottom)
-              else
-                //GradientFill(Canvas, R, $00F0FDFF, $00D0F8FF, TGTopBottom);
-                GradientFill(Canvas, R, clWhite, clSilver, TGTopBottom);
-              Pen.Color := clSilver;
-            end else
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              GradientFill(Canvas, R, $0080E0FF, $002090E8, TGTopBottom);
-              Pen.Color := $0060B0E8;
-              MoveTo(R.Left, R.Bottom - 2);
-              LineTo(R.Left, R.Top);
-              LineTo(R.Right, R.Top);
-              Pen.Color := $00808080;
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end else
-            begin
-              FillRectEx(Canvas.Handle, R, $00F4F0F0);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 0, 0);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              GradientFill(Canvas, R, $00F0FDFF, $00D0F8FF, TGTopBottom);
-              Pen.Color := $00B0D4DF;
-              MoveTo(R.Left, R.Bottom - 2);
-              LineTo(R.Left, R.Top);
-              LineTo(R.Right, R.Top);
-              Pen.Color := $00808080;
-              InflateRect(R, 1, 1);
-            end else
-              Pen.Color := clSilver;
-            RoundFrame(Canvas, R, 0, 0);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                RadioGradient(Canvas, R, clWhite, clSilver, clWhite)
-              else
-                RadioGradient(Canvas, R, clWhite, clSilver, clWhite);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              RadioGradient(Canvas, R, $0080E0FF, $002090E8, $0060B0E8);
-              Pen.Color := $00808080;
-            end else
-            begin
-              Pen.Width := 0;
-              Brush.Style := bsSolid;
-              Brush.Color := $00F4F0F0;
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y + 3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y + 11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y + 9)]);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas, R, $00F0FDFF, $00D0F8FF, $00B0D4DF);
-              Pen.Color := $00808080;
-              InflateRect(R, 1, 1);
-            end else
-              Pen.Color := clSilver;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y + 3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +  11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y + 9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXDreamTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-var
-  D         : Integer;
-  c1, c2, c3        : TColor;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          GradientFill(Canvas, R, $00DCD8D0, clWhite, TGTopBottom)
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3,
-            $00DCD8D0);
-          DrawLineEx(Canvas.Handle, R.Right + 1, R.Top + 5, R.Right + 1, R.Bottom
-            - 2, clWhite);
-        end;
-      SBP_GRIPPER:
-        begin
-          c1 := clWhite;
-          c2 := clBlack;
-          c3 := $00B0B0B0;
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := c1;
-            Pixels[Right - 12, Bottom - 3] := c1;
-            Pixels[Right - 11, Bottom - 4] := c1;
-            Pixels[Right - 11, Bottom - 3] := c2;
-            Pixels[Right - 11, Bottom - 2] := c3;
-            Pixels[Right - 10, Bottom - 2] := c3;
-            Pixels[Right - 10, Bottom - 3] := c3;
-            Pixels[Right - 10, Bottom - 4] := c3;
-            Pixels[Right - 12, Bottom - 2] := c3;
-
-            Pixels[Right - 8, Bottom - 4] := c1;
-            Pixels[Right - 8, Bottom - 3] := c1;
-            Pixels[Right - 7, Bottom - 4] := c1;
-            Pixels[Right - 7, Bottom - 3] := c2;
-            Pixels[Right - 7, Bottom - 2] := c3;
-            Pixels[Right - 6, Bottom - 2] := c3;
-            Pixels[Right - 6, Bottom - 3] := c3;
-            Pixels[Right - 6, Bottom - 4] := c3;
-            Pixels[Right - 8, Bottom - 2] := c3;
-
-            Pixels[Right - 4, Bottom - 4] := c1;
-            Pixels[Right - 4, Bottom - 3] := c1;
-            Pixels[Right - 3, Bottom - 4] := c1;
-            Pixels[Right - 3, Bottom - 3] := c2;
-            Pixels[Right - 3, Bottom - 2] := c3;
-            Pixels[Right - 2, Bottom - 2] := c3;
-            Pixels[Right - 2, Bottom - 3] := c3;
-            Pixels[Right - 2, Bottom - 4] := c3;
-            Pixels[Right - 4, Bottom - 2] := c3;
-
-            Pixels[Right - 8, Bottom - 8] := c1;
-            Pixels[Right - 8, Bottom - 7] := c1;
-            Pixels[Right - 7, Bottom - 8] := c1;
-            Pixels[Right - 7, Bottom - 7] := c2;
-            Pixels[Right - 7, Bottom - 6] := c3;
-            Pixels[Right - 6, Bottom - 6] := c3;
-            Pixels[Right - 6, Bottom - 7] := c3;
-            Pixels[Right - 6, Bottom - 8] := c3;
-            Pixels[Right - 8, Bottom - 6] := c3;
-
-            Pixels[Right - 4, Bottom - 8] := c1;
-            Pixels[Right - 4, Bottom - 7] := c1;
-            Pixels[Right - 3, Bottom - 8] := c1;
-            Pixels[Right - 3, Bottom - 7] := c2;
-            Pixels[Right - 3, Bottom - 6] := c3;
-            Pixels[Right - 2, Bottom - 6] := c3;
-            Pixels[Right - 2, Bottom - 7] := c3;
-            Pixels[Right - 2, Bottom - 8] := c3;
-            Pixels[Right - 4, Bottom - 6] := c3;
-
-            Pixels[Right - 4, Bottom - 12] := c1;
-            Pixels[Right - 4, Bottom - 11] := c1;
-            Pixels[Right - 3, Bottom - 12] := c1;
-            Pixels[Right - 3, Bottom - 11] := c2;
-            Pixels[Right - 3, Bottom - 10] := c3;
-            Pixels[Right - 2, Bottom - 10] := c3;
-            Pixels[Right - 2, Bottom - 11] := c3;
-            Pixels[Right - 2, Bottom - 12] := c3;
-            Pixels[Right - 4, Bottom - 10] := c3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXDreamTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then SetupColorCache;
-end;
-
-initialization
-  RegisterTBXTheme('Dream', TTBXDreamTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXEosTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXEosTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXEosTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2218 +0,0 @@
-unit TBXEosTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Eos' TBX theme &#169; 2004 Roy Magne Klever
-//
-//  Last updated: 12.09.2004
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-{*$DEFINE SMALL_CLOSE_BUTTON}// remove the asterisk for smaller close button size
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXEosTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor; override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins); override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean); override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect; ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer); override;
-  end;
-
-var
-  MenuButtons, BarLines, AltCaption,
-    Aqua, DarkAqua, CaptionOutline, DottedGrip: boolean;
-  SelGradient: integer;
-  HotColor, BaseColor, BaseShade: TColor;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0, clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockImgList.Free;
-end;
-
-{ TTBXEosTheme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right); Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right); Inc(Bottom);
-  end;
-end;
-
-function TTBXEosTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXEosTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 7;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-
-    TMI_TLBR_SEPARATORSIZE: Result := 5; //DEFAULT;
-
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXEosTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then Result := MenubarColor
-    else Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then Result := clWindow
-    else Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then Result := DockPanelColor;
-end;
-
-function TTBXEosTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then B := bisPressed
-    else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then Result := clWindowFrame
-        else if (Result = clNone) then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXEosTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then M := MFlags1[HoverKind = hkKeyboardHover]
-      else M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then B := bisPopupParent
-      else if Pushed then B := bisPressed
-      else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then Result := ToolbarColor;
-        if ItemPart = ipFrame then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div 2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXEosTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXEosTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXEosTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXEosTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2; {1} // rmkO
-      Border.Y := 2;
-    end else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else SetBorder(2, 2);
-  end
-  else SetBorder(0, 0);
-end;
-
-procedure TTBXEosTheme.GetMargins(MarginID: Integer; out Margins: TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXEosTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  R: TRect;
-begin
-  //if TBXLoColor then inherited
-  //else
-  IntersectRect(R, ARect, AClipRect);
-  if not Transparent then
-  with Canvas do
-  begin
-    Brush.Color := AColor;
-    FillRect(R);
-  end;
-end;
-
-procedure TTBXEosTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if (ItemInfo.ViewType and TVT_MENUBAR = TVT_MENUBAR) // Special menubar text painting
-      and (ItemInfo.HoverKind &lt;&gt; hkNone)
-      and (MenuButtons = false)
-    then
-      Font.Color := HotColor // rmkO This one was hard to find...
-    else
-    begin // This one was not easy to come up with... // rmkO
-      if (ItemInfo.ComboPart = cpSplitLeft) and (ItemInfo.IsPopupParent) then
-        Font.Color := HotColor
-      else
-        if Font.Color = clNone then Font.Color := GetPartColor(ItemInfo, ipText);
-    end;
-    if not Rotated then Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXEosTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := clWhite
-  else
-    if not ItemInfo.Enabled then
-      Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-    else
-      Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y - 2)]);
-end;
-
-procedure TTBXEosTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXEosTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then
-    else
-      if BtnHot then // Do nothing...
-      else
-        if Embedded then
-        begin
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-        end
-        else FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-        begin
-          Brush.Color := BtnItemColors[bisPressed, ipBody];
-          FillRect(R);
-        end else
-          PaintEnabled(R, BtnPressed);
-      end;
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame], True); // rmk Mod
-
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color:= BaseShade;
-      if not BtnDisabled then
-      begin
-        MoveTo(R.Left, R.Top);
-        LineTo(R.Left, R.Bottom);
-      end;
-
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and (EBSS_UP or EBSS_DOWN)) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        // Up button...
-        if (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0 then
-        begin
-          BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-          if BtnPressed then
-          begin
-            Brush.Color := BtnItemColors[bisPressed, ipBody];
-            FillRect(BR);
-          end else
-            if BtnHot then
-            begin
-              Brush.Color := BtnItemColors[bisHot, ipBody];
-              FillRect(BR);
-            end;
-          if (not BtnPressed) and (not BtnHot) then
-            Pen.Color:= BaseShade;
-          MoveTo(BR.Left, BR.Top);
-          LineTo(BR.Left, BR.Bottom);
-        end else
-
-        // Down button...
-        if (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0 then
-        begin
-          BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-          if BtnPressed then
-          begin
-            Brush.Color := BtnItemColors[bisPressed, ipBody];
-            FillRect(BR);
-          end
-          else
-            if BtnHot then
-            begin
-              Brush.Color := BtnItemColors[bisHot, ipBody];
-              FillRect(BR);
-            end;
-        end;
-        if (not BtnPressed) and (not BtnHot) then
-          Pen.Color:= BaseShade;
-        MoveTo(BR.Left, BR.Bottom - 1);
-        LineTo(BR.Left, BR.Top);
-        LineTo(BR.Right, BR.Top);
-      end;
-      BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-      PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0);
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame], True);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      if not BtnDisabled then Pen.Color := BtnItemColors[bisNormal, ipText];
-      if BtnHot then Pen.Color := BtnItemColors[bisHot, ipText];
-      if BtnPressed then Pen.Color := clBlack;
-      Brush.Color := Pen.Color;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (3 * R.Top + R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      if not BtnDisabled then Pen.Color := BtnItemColors[bisNormal, ipText];
-      if BtnHot then Pen.Color := BtnItemColors[bisHot, ipText];
-      if BtnPressed then Pen.Color := clBlack;
-      Brush.Color := Pen.Color;
-
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (R.Top + 3 * R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-    end;
-
-  end;
-end;
-
-procedure TTBXEosTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // rmkPS
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXEosTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXEosTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-
-    if ComboPart = cpSplitRight then Dec(R.Left);  // rmkPS
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := Blend(clHighLight, clWindow, 20);
-      end
-      else
-        Pen.Color := Blend(clHighLight, clWindow, 15);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot, ipBody], False, VT_UNKNOWN);
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      if not Pushed and (HoverKind = hkNone) then
-      begin
-        Brush.Color := BtnItemColors[bisSelected, ipBody];
-        InflateRect(R, -1, -1);
-        FillRect(R);
-        InflateRect(R, 1, 1);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end else
-      begin
-        Brush.Color := BtnItemColors[bisPressed, ipBody];
-        FillRect(R);
-        Pen.Color := BtnItemColors[bisPressed, ipFrame];
-      end;
-      if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      begin
-        Brush.Color := BtnItemColors[bisSelectedHot, ipBody];
-        FillRect(R);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end;
-    end
-    else
-      if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Brush.Color := GetBtnColor(ItemInfo, ipBody);
-        FillRect(R);
-        Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        with R do Rectangle(Left, Top, Right, Bottom);
-      end;
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXEosTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R, R2: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom - Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := PopupFrameColor;
-      with R do Rectangle(Left - 1, Top-1, Right + 1, Bottom + 1);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    // Caption
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      FillRect(R);
-
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      R.Bottom := R.Bottom - 1;
-
-      // rmkNew
-      if CaptionOutline then
-      begin
-        Font.Color := gradCol1;
-        R2 := R;
-        for y := -2 to 1 do
-          for x := -1 to 1 do
-          begin
-            R2.Top := R.Top + y;
-            R2.Left := R.Left + x;
-            DrawText(Canvas.Handle, WindowInfo.Caption, -1, R2,
-              DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-          end;
-        Font.Color := CaptionText;
-      end;
-
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    // Close button
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom, BodyColor);
-      Brush.Color := CaptionColor;
-      FillRect(R);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-        if not AltCaption then
-          FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-        DrawButtonBitmap(Canvas, R, BtnItemColors[BtnItemState, ipText]);
-      end else
-        if BtnItemState = bisPressed then
-        begin
-          FrameRectEx(Canvas.Handle, R, WinFrameColors[wfsActive, wfpCaption], True);
-          if not AltCaption then
-            FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-          DrawButtonBitmap(Canvas, R, BtnItemColors[BtnItemState, ipText]);
-        end else
-        begin
-          FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-          if not AltCaption then
-            FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-          if AltCaption then
-            DrawButtonBitmap(Canvas, R, HotColor)
-          else
-            DrawButtonBitmap(Canvas, R, WinFrameColors[wfsActive, wfpCaptionText]);
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXEosTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected {or Embedded} or (HoverKind &lt;&gt; hkNone) or // rmkO? Embedded ?
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      if Pushed then
-        Canvas.Pen.Color := BtnItemColors[bisSelected, ipFrame]
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 0, 0);
-    end;
-  end;
-end;
-
-
-function TTBXEosTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXEosTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := false; //IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex, IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := False; // ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178} 255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXEosTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXEosTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-    (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot, ipBody], False, VT_UNKNOWN);
-    end;
-end;
-
-procedure TTBXEosTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-  var
-    R: TRect;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-
-      if ComboPart = cpSplitRight then Dec(R.Left);
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-      end;
-
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-      begin
-        if ((Pushed or Selected) and Enabled) or ShowHover then
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot, ipBody], False, VT_UNKNOWN);
-        end;
-        Exit;
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          Pen.Color := BtnItemColors[bisSelected, ipFrame]
-        end else
-        begin
-          Pen.Color := BaseColor;
-        end;
-        Brush.Color:= BtnItemColors[bisSelected, ipBody];
-        FillRect(R);
-        InflateRect(R, 1, 1);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40); //rmkO
-      end;
-      if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then Pen.Color := $0068CAE6
-      else Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2:= ARect;
-    InflateRect(R2, -1, -1);
-
-    if ((Selected) and (Enabled)) then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      InflateRect(R, -1, -1); // smaller button in menu? rmkP
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXEosTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then Left := R.Left - 1;
-            if Right &gt;= R.Right then Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then Left := R.Left - 1;
-            if Right &gt;= R.Right then Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXEosTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, ToolbarSeparatorColor);
-      end else
-      begin
-        Top := Bottom div 2;
-        MoveTo(14, Top); LineTo(Right - 14, Top);
-      end;
-    end else if Enabled then
-    begin
-      Top := Top + 2;
-      Bottom := Bottom - 3;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, ToolbarSeparatorColor);
-    end;
-  end;
-end;
-
-procedure TTBXEosTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-   const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0, 1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      PaintBackgnd(Canvas, ZERO_RECT, R, R, MenubarColor, false, VT_UNKNOWN)
-    else
-      PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW)
-      then
-      if BarLines then
-      begin
-        if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor);
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, BarSepColor);
-        end else
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Left, R.Top, Blend(BarSepColor, clWhite,75)); // Left
-          DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right, R.Top,   Blend(BarSepColor, clWhite,75)); // Top
-
-          DrawLineEx(Canvas.Handle, R.Left + 1, R.Bottom - 1, R.Right, R.Bottom - 1,   BarSepColor);  // Bottom
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, BarSepColor);  // Right
-        end;
-      end else
-      begin
-        R2 := R;
-        while R2.Left &lt; R.Right do
-        begin
-          Canvas.Pixels[R2.Left, R.Bottom - 1] := BarSepColor;
-          R2.Left := R2.Left + 3;
-        end;
-        R2 := R;
-        while R2.Top &lt; R.Bottom - 1 do
-        begin
-          Canvas.Pixels[R2.Right - 1, R2.Top] := BarSepColor;
-          R2.Top := R2.Top + 3;
-        end;
-      end;
-    R.Top := R.Top + 1;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then R.Right := R.Left + Sz
-    else R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-        if Horz then
-          OffsetRect(R2, -2, 0)
-        else
-          OffsetRect(R2, 0, -2);
-      if Horz then
-      begin
-        Inc(R2.Top, 3);
-        Dec(R2.Bottom, 1);
-        Inc(R2.Left, 1);
-        if BtnVisible then begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end else
-      begin
-        Inc(R2.Left, 3);
-        Dec(R2.Right, 1);
-        Inc(R2.Top, 1);
-        if BtnVisible then begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXEosTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := Blend(BaseColor, $00404040, 45);
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXEosTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags, X, Y: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, true);
-      FrameRectEx(Canvas.Handle, R, ToolbarColor, False);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Left - 1, R.Top - 1, Blend(BarSepColor, clWhite,75)); // Left
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Top - 1, R.Right + 1, R.Top - 1, Blend(BarSepColor, clWhite,75)); // Top
-      DrawLineEx(Canvas.Handle, R.Left + 1, R.Bottom, R.Right, R.Bottom, BarSepColor); // Bottom
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, BarSepColor); // Right
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, ToolBarColor);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      if AltCaption then
-      begin
-        Brush.Color := PnlFrameColors[wfsActive, wfpCaption]; // rmkCap
-        FillRect(R);
-      end else
-      begin
-        Brush.Color := PnlFrameColors[wfsActive, wfpCaption];
-        FillRect(R);
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, ToolBarColor);
-      end;
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, ToolBarColor);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      if AltCaption then
-      begin
-        Brush.Color := PnlFrameColors[wfsActive, wfpCaption];
-        FillRect(R);
-      end else
-      begin
-        Brush.Color := PnlFrameColors[wfsActive, wfpCaption];
-        FillRect(R);
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom, BarSepColor);
-      end;
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-        if not AltCaption then
-          FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-        DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-      end else
-        if BtnItemState = bisPressed then
-        begin
-          FrameRectEx(Canvas.Handle, R2, WinFrameColors[wfsActive, wfpCaption], True);
-          if not AltCaption then
-            FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-          DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-        end else
-        begin
-          FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-          if not AltCaption then
-            FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-          if AltCaption then
-            DrawButtonBitmap(Canvas, R2, HotColor)
-          else
-            DrawButtonBitmap(Canvas, R2, WinFrameColors[wfsActive, wfpCaptionText]);
-        end;
-    end;
-
-    if IsVertical then InflateRect(R, -4, 0)
-    else InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    if AltCaption then
-      Font.Color := HotColor
-    else
-      Font.Color := WinFrameColors[wfsActive, wfpCaptionText];
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    // rmkNew
-    if CaptionOutline then
-    begin
-      R2 := R;
-      C := Font.Color;
-      Font.Color := gradCol1;
-      R2 := R;
-      for y := -1 to 2 do
-        for x := -1 to 1 do
-        begin
-          R2.Top := R.Top + y;
-          R2.Left := R.Left + x;
-          if IsVertical then DrawText(Canvas.Handle, Caption, -1, R2, Flags)
-          else DrawRotatedText(Canvas.Handle, string(Caption), R2, Flags);
-        end;
-      Font.Color := C;
-    end;
-
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXEosTheme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  //BaseColor:= clSilver;
-  //BaseColor:= $00e0A030;
-  //BaseColor:= $00F0D8B0;
-  //BaseColor:= $00B0D8F0;
-  //BaseColor:= $00B0F0D8;
-  //BaseColor:= $00F0D850;
-  //BaseColor:= $001040F0;
-  //BaseColor:= $00FFE0B0;
-
-  // My favourite - kaki
-  BaseColor:= $00e0ffff;
-  //BaseColor:= $00e0ffe0;
-  //BaseColor:= $00ffe0e0;
-
-  HotColor:= $0068cae6;
-
-  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := Blend(BaseColor, clWhite, 75); // clSilver;
-  gradHandle2 := Blend(BaseColor, clBlack, 35); // clGray;
-  gradHandle3 := clWhite;
-
-  gradBL := NearestMixedColor(BaseColor, gradCol1, 64);
-
-  MenubarColor := Blend(BaseColor, clBlack, 50);
-  ToolbarColor := MenuBarColor;
-
-  PopupColor := MenuBarColor;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := Blend(BaseColor, clBlack, 40);
-
-  BarSepColor := Blend(ToolBarColor, clBlack, 80);
-
-  EditFrameColor := Blend(ToolbarColor, clWhite, 90);
-  EditFrameDisColor := Blend(ToolbarColor, clWhite, 75); ;
-
-  HotBtnFace := BaseColor;
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := clgreen;
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(BaseColor, clBlack, 40);
-  WinFrameColors[wfsActive, wfpCaption] := Blend(BaseColor, clBlack, 40); {85}
-  WinFrameColors[wfsActive, wfpCaptionText] := clWhite;
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  PnlFrameColors[wfsActive, wfpCaption] := WinFrameColors[wfsActive, wfpCaption];
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive, wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], BaseColor, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clWhite;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clWhite, ToolbarColor, 25);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(BaseColor, clWhite, 75);
-
-  BtnItemColors[bisSelected, ipBody] := Blend(clWhite, ToolbarColor, 25);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := PopupFrameColor;
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, HotColor, 15);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := Blend(ToolbarColor, clBlack, 85);
-  BtnItemColors[bisHot, ipText] := HotColor;
-  BtnItemColors[bisHot, ipFrame]:= Blend(clWhite, ToolbarColor, 25);
-
-  BtnItemColors[bisDisabledHot, ipBody] := clRed; // ???
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(HotColor, clWhite, 75);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clWhite;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText], BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := BaseColor;
-
-  BtnItemColors[bisPopupParent, ipBody] := BtnItemColors[bisHot, ipBody];
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWhite;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := BtnItemColors[bisDisabled, ipText];
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(BaseColor, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(BaseColor, clWhite, 60);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := Blend(BaseColor, clBlack, 60);
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXEosTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXEosTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXEosTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXEosTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXEosTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    Canvas.Brush.Color:= BtnItemColors[bisHot, ipBody];
-    Canvas.FillRect(R);;
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame];
-  end
-  else
-  begin
-    Canvas.Brush.Color := ToolBarColor;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipFrame];
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 0, 0);
-  Canvas.Pen.Color := ToolBarColor;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if hot then
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipText]
-  else
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXEosTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then Canvas.Pen.Color := BtnItemColors[bisPressed, ipFrame]
-    else if Boolean(State and PFS_HOT) then Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame]
-    else Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then Canvas.Brush.Color := BtnItemColors[bisPressed, ipBody]
-    else if Boolean(State and PFS_HOT) then Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-    else if Boolean(State and PFS_MIXED) then Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else Canvas.Brush.Style:= bsClear;//[bisNormal, ipBody];
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then Result := BtnItemColors[bisHot, ipText]
-    else Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  {
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1); LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-  }
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          SetupPen;
-          SetupBrush;
-          //InflateRect(R, -1, -1);
-          //Brush.Color:= Pen.Color;
-          with R do Rectangle(Left, Top, Right, Bottom);
-          {
-          begin
-            if Boolean(State and not (PFS_CHECKED)) then
-            //if Boolean(State and (PFS_CHECKED or PFS_HOT)) then
-            begin
-              Pen.Color:= Blend(BarSepColor, ClWhite, 50);
-              MoveTo(R.Left, R.Bottom);
-              LineTo(R.Left, R.Top);
-              LineTo(R.Right, R.Top);
-              Pen.Color:= BarSepColor;
-              MoveTo(R.Right, R.Top);
-              LineTo(R.Right, R.Bottom);
-              LineTo(R.Left, R.Bottom);
-            end
-            else
-            begin
-              Pen.Color:= BarSepColor;
-              MoveTo(R.Left, R.Bottom - 1);
-              LineTo(R.Left, R.Top);
-              LineTo(R.Right, R.Top);
-              Pen.Color:= Blend(BarSepColor, ClWhite, 50);
-              MoveTo(R.Right, R.Top);
-              LineTo(R.Right, R.Bottom);
-              LineTo(R.Left, R.Bottom);
-              //Rectangle(Left, Top, Right, Bottom);
-            end;
-          end;
-          }
-          
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X - 2, Y)]);
-          end;
-        end;
-      PFC_RADIOBUTTON:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do Ellipse(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXEosTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  Color, Hi, Lo, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D - 2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolBarColor, False, VT_UNKNOWN);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right, R.Top, Blend(BarSepColor, clWhite,75)); // rmkO
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          R.Top := R.Top + 2;
-          R.Bottom := R.Bottom - 3;
-          R.Left := R.Right;
-          DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom, ToolbarSeparatorColor);
-        end;
-      SBP_GRIPPER:
-        if DottedGrip then
-        begin
-          Color := gradHandle1;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end else
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Hi := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Lo := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXEosTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then SetupColorCache;
-end;
-
-initialization
-  // Not in use yet... RMK
-  MenuButtons := false;
-  AltCaption := false;
-  CaptionOutline := false;
-  DottedGrip := true;
-  SelGradient := 1;
-  BarLines := true;
-  HotColor := clBlack;
-  DarkAqua := false;
-  Aqua := true;
-
-  BaseColor := $00F05010; //$00E0A030; // Should not be changed but... :)
-  BaseShade := clSilver;
-  BaseColor := $00A8A8A8; // Discret
-  RegisterTBXTheme('Eos', TTBXEosTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXMacOSXG32Theme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXMacOSXG32Theme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXMacOSXG32Theme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,1824 +0,0 @@
-unit TBXMacOSXG32Theme;
-
-interface
-
-{$I TB2Ver.inc}
-{$I TBX.inc}
-
-uses
-  Windows, Messages, Graphics, TBXThemes, TBXDefaultTheme, ImgList,
-  PngImage, GR32;
-
-type
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXMacOSXg32Theme= class(TTBXDefaultTheme)//TTBXTheme)//
-  private
-//    FInterpolationMode: Integer;
-    procedure EnlargeBitmap(Source:TBitmap32; Target:TCanvas; SourceRect, TargetRect:TRect; VSideSize:Integer=3; HSideSize:Integer=3); overload;
-    procedure DrawImage(Source:TBitmap32; Target:TCanvas; SourceRect:TRect; x,y: Integer);
-    Procedure DrawStripeBG(Target: TCanvas; R:TRect; AColor:TColor);
-  protected
-    { View/Window Colors }
-    DockColor: TColor;
-    MenuBarColor: TColor;
-    ToolbarColor: TColor;
-    StatusbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    PopupFrameColor: TColor;
-    WinFrameColors: array [TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array [TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array [TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array [TBtnItemState, TItemPart] of TColor;
-    SeparatorColor: TColor;
-    PopupSeparatorColor:TColor;
-    DefaultRoughness: Integer;
-    procedure SetupColorCache; virtual;
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect; DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintComboArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-  public
-//    property InterpolationMode: Integer read FInterpolationMode write FInterpolationMode default InterpolationModeNearestNeighbor;
-  end;
-
-Var
-  HotColor, BaseColor, BaseShade: TColor;
-
-implementation
-
-uses
-  TBXUtils, TB2Item, TB2Common, Classes, Controls, Forms, Commctrl,
-  SysUtils, ActiveX, TBXUxThemes, Types;
-
-{$R macr.RES}
-
-type TGraphicAccess = class(TGraphic);
-
-function PngObjectToBitmap32(APng: TPngObject; ADIB: TBitmap32): integer;
-var
-  i, j: integer;
-  P: PColor32;
-  A: PByte;
-  ABmp: TBitmap;
-  Canvas: TCanvas;
-begin
-  ABmp := TBitmap.Create;
-  try
-    // assign to the a bitmap
-    APng.AssignTo(ABmp);
-
-    // We now *draw* the bitmap to our bitmap.. this will clear alpha in places
-    // where drawn.. so we can use it later
-    ADib.SetSize(APng.Width, APng.Height);
-    ADib.Clear(clBlack32);
-    //ADib.Canvas.Draw(0,0, ABmp);
-    Canvas := TCanvas.Create;
-    try
-      Canvas.Handle := ADib.Handle;
-      TGraphicAccess(ABmp).Draw(Canvas, Rect(0, 0, ADib.Width, ADib.Height));
-    finally
-      Canvas.Free;
-    end;
-
-    // Flip the alpha channel
-    P := @ADib.Bits[0];
-    for i := 0 to ADib.Width * ADib.Height - 1 do begin
-      P^ := P^ XOR $FF000000;
-      inc(P);
-    end;
-
-    // The previous doesn't handle bitwise alpha info, so we do that here
-    for i := 0 to APng.Height - 1 do begin
-      A := PByte(APng.AlphaScanLine[i]);
-      if assigned(A) then begin
-        P := @ADib.Bits[i * ADib.Width];
-        for j := 0 to APng.Width - 1 do begin
-          P^ := SetAlpha(P^, A^);
-          inc(P); inc(A);
-        end;
-      end else
-        break;
-    end;
-
-    // Arriving here means &quot;all ok&quot;
-    Result := 1;
-  finally
-    //APng.Free;
-    ABmp.Free;
-  end;
-end;
-
-Var
-  StockBitmap: TBitmap = nil;
-
-Procedure DrawBitmap32Rect(AHDC:HDC; x,y: Integer; Bmp32:TBitmap32; const RSrc: TRect);
-Var
-  ImageWidth, ImageHeight: Integer;
-  I, J: Integer;
-  srcx, srcy:Integer;
-  Src: PColor32;
-  Dst: PColor;//^Cardinal;
-  S, C, CBRB, CBG: Cardinal;
-  Wt1, Wt2: Cardinal;
-Begin
-  If Not Assigned(StockBitmap) then
-  Begin
-    StockBitmap:= TBitmap.Create;
-    StockBitmap.HandleType:= bmDIB;
-    StockBitmap.PixelFormat:= pf32bit;
-  End;
-  ImageWidth := RSrc.Right - RSrc.Left;
-  ImageHeight := RSrc.Bottom - RSrc.Top;
-  {with Bmp32 do
-  begin
-    if Width &lt; ImageWidth then ImageWidth := Width;
-    if Height &lt; ImageHeight then ImageHeight :=  Height;
-  end;}
-  StockBitmap.Width:= ImageWidth;
-  StockBitmap.Height:= ImageHeight;
-  BitBlt(StockBitmap.Canvas.Handle, 0, 0, ImageWidth, ImageHeight,
-    AHDC, x, y, SRCCOPY);
-  srcx:= RSrc.Left;
-  srcy:= RSrc.Top;
-  for J := 0 to ImageHeight - 1 do
-  begin
-    Src := Bmp32.PixelPtr[srcx+0, srcy+J];
-    Dst := StockBitmap.ScanLine[J];
-    for I := 0 to ImageWidth - 1 do
-    begin
-      S := Src^;
-      Wt2:= (S and $FF000000) shr 24;
-      Wt1:= 255-Wt2;
-
-      CBRB := (Dst^ and $00FF00FF) * Wt1;
-      CBG  := (Dst^ and $0000FF00) * Wt1;
-      C := ((S and $FF00FF) * Wt2 + CBRB) and $FF00FF00 + ((S and $00FF00) * Wt2 + CBG) and $00FF0000;
-      Dst^ := C shr 8;
-      Inc(Src);
-      Inc(Dst);
-    end;
-  end;  
-  BitBlt(AHDC, x, y, ImageWidth, ImageHeight,
-    StockBitmap.Canvas.Handle, 0, 0, SRCCOPY);
-End;
-
-Procedure DrawBitmap32(AHDC:HDC; const RDest: TRect; Bmp32:TBitmap32);
-Var
-  ImageWidth, ImageHeight: Integer;
-  I, J: Integer;
-  Src: PColor32;
-  Dst: PColor;//^Cardinal;
-  S, C, CBRB, CBG: Cardinal;
-  Wt1, Wt2: Cardinal;
-Begin
-  If Not Assigned(StockBitmap) then
-  Begin
-    StockBitmap:= TBitmap.Create;
-    StockBitmap.HandleType:= bmDIB;
-    StockBitmap.PixelFormat:= pf32bit;
-  End;
-  ImageWidth := RDest.Right - RDest.Left;
-  ImageHeight := RDest.Bottom - RDest.Top;
-  with Bmp32 do
-  begin
-    if Width &lt; ImageWidth then ImageWidth := Width;
-    if Height &lt; ImageHeight then ImageHeight :=  Height;
-  end;
-  StockBitmap.Width:= ImageWidth;
-  StockBitmap.Height:= ImageHeight;
-  BitBlt(StockBitmap.Canvas.Handle, 0, 0, ImageWidth, ImageHeight,
-    AHDC, RDest.Left, RDest.Top, SRCCOPY);
-  for J := 0 to ImageHeight - 1 do
-  begin
-    Src := Bmp32.PixelPtr[0, J];
-    Dst := StockBitmap.ScanLine[J];
-    for I := 0 to ImageWidth - 1 do
-    begin
-      S := Src^;
-      Wt2:= (S and $FF000000) shr 24;
-      Wt1:= 255-Wt2;
-
-      CBRB := (Dst^ and $00FF00FF) * Wt1;
-      CBG  := (Dst^ and $0000FF00) * Wt1;
-      C := ((S and $FF00FF) * Wt2 + CBRB) and $FF00FF00 + ((S and $00FF00) * Wt2 + CBG) and $00FF0000;
-      Dst^ := C shr 8;
-      Inc(Src);
-      Inc(Dst);
-    end;
-  end;  
-  BitBlt(AHDC, RDest.Left, RDest.Top, ImageWidth, ImageHeight,
-    StockBitmap.Canvas.Handle, 0, 0, SRCCOPY);
-End;
-
-{ TTBXSimpleTheme }
-
-//Const
-  //FStretchFilter= sfLanczos;//sfNearest;//sfLinear;//sfMitchell;//sfSpline;//
-
-Type
-  TDrawStyle = (bsDefault, bsHover, bsDisabled, bsPushed, bsSelected, bsSelectedHover);
-  TCheckStatus = (cNone, cChecked, cMixed);
-
-var
-  StockBitmap321: TBitmap32 = nil;
-  StockBitmap322: TBitmap32 = nil;
-  {StockImgList: TImageList;
-  StockPatternBitmap: TBitmap;}
-  RadioM: TBitmap32 = nil;
-  CheckM: TBitmap32 = nil;
-  //BOTON: TBitmap32 = nil;
-  BOTON: TBitmap32;
-//  COMBOBUTTONGLYPH2: TBitmap32 = nil;
-  MDICLOSE: TBitmap32 = nil;
-
-  COMBOBOX : TBitmap32 = nil;
-  SPINBUTTONBACKGROUNDRIGHT : TBitmap32 = nil;
-  //TOOLBARBUTTONSImage : TBitmap32;
-  TOOLBARBUTTONS: TBitmap32 = nil;
-  TOOLBARBUTTONSSPLIT: TBitmap32 = nil;
-  TOOLBARBUTTONSSPLITDROPDOWN: TBitmap32 = nil;
-  SPINBUTTONBACKGROUNDUP: TBitmap32 = nil;
-  SPINBUTTONBACKGROUNDDOWN: TBitmap32 = nil;
-  CLOSEGLYPH: TBitmap32 = nil;
-  MINIMIZEGLYPH: TBitmap32 = nil;
-  MAXIMIZEGLYPH: TBitmap32 = nil;
-//  TOOLBARBUTTONSSPLITDROPDOWNGLYPH: TBitmap32 = nil;
-  CounterLock: Integer = 0;
-
-procedure InitializeStock;
-var
-  ResStream: TResourceStream;
-  P:TPngObject;
-begin
-  If Not Assigned(StockBitmap321) then
-  Begin
-    StockBitmap321:= TBitmap32.Create;
-    StockBitmap321.DrawMode:=dmBlend;
-    //StockBitmap321.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(StockBitmap322) then
-  Begin
-    StockBitmap322:= TBitmap32.Create;
-    StockBitmap322.DrawMode:=dmBlend;
-    //StockBitmap322.StretchFilter:= FStretchFilter;
-  End;
-
-  P:=TPngObject.Create;
-  If Not Assigned(RadioM) then
-  Begin
-    ResStream := TResourceStream.Create(HInstance, 'RADIOM', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    RadioM:= TBitmap32.Create;
-    PngObjectToBitmap32(P, RadioM);
-    RadioM.DrawMode:=dmBlend;
-    //RadioM.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(CheckM) then
-  Begin
-    ResStream := TResourceStream.Create(HInstance, 'CHECKM', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    CheckM:= TBitmap32.Create;
-    PngObjectToBitmap32(P, CheckM);
-    CheckM.DrawMode:=dmBlend;
-    //CheckM.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(BOTON) then
-  Begin
-    ResStream := TResourceStream.Create(HInstance, 'BOTON', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    BOTON:= TBitmap32.Create;
-    PngObjectToBitmap32(P, BOTON);
-    BOTON.DrawMode:=dmBlend;
-    //BOTON.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(TOOLBARBUTTONS) then
-  Begin
-    ResStream := TResourceStream.Create(HInstance, 'TOOLBARBUTTONS', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    TOOLBARBUTTONS:= TBitmap32.Create;
-    PngObjectToBitmap32(P, TOOLBARBUTTONS);
-    TOOLBARBUTTONS.DrawMode:=dmBlend;
-    //TOOLBARBUTTONS.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(TOOLBARBUTTONSSPLIT) then
-  Begin
-    ResStream := TResourceStream.Create(HInstance, 'TOOLBARBUTTONSSPLIT', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    TOOLBARBUTTONSSPLIT:= TBitmap32.Create;
-    PngObjectToBitmap32(P, TOOLBARBUTTONSSPLIT);
-    TOOLBARBUTTONSSPLIT.DrawMode:=dmBlend;
-    //TOOLBARBUTTONSSPLIT.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(TOOLBARBUTTONSSPLITDROPDOWN) then
-  Begin
-    ResStream := TResourceStream.Create(HInstance, 'TOOLBARBUTTONSSPLITDROPDOWN', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    TOOLBARBUTTONSSPLITDROPDOWN:= TBitmap32.Create;
-    PngObjectToBitmap32(P, TOOLBARBUTTONSSPLITDROPDOWN);
-    TOOLBARBUTTONSSPLITDROPDOWN.DrawMode:=dmBlend;
-    //TOOLBARBUTTONSSPLITDROPDOWN.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(SPINBUTTONBACKGROUNDRIGHT) then
-  Begin
-    ResStream := TResourceStream.Create(HInstance, 'SPINBUTTONBACKGROUNDRIGHT', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    SPINBUTTONBACKGROUNDRIGHT:= TBitmap32.Create;
-    PngObjectToBitmap32(P, SPINBUTTONBACKGROUNDRIGHT);
-    SPINBUTTONBACKGROUNDRIGHT.DrawMode:=dmBlend;
-    //SPINBUTTONBACKGROUNDRIGHT.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(COMBOBOX) then
-  Begin
-    ResStream:= TResourceStream.Create(HInstance, 'COMBOBOX', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    COMBOBOX:= TBitmap32.Create;
-    PngObjectToBitmap32(P, COMBOBOX);
-    COMBOBOX.DrawMode:=dmBlend;
-    //COMBOBOX.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(MDICLOSE) then
-  Begin
-    ResStream:= TResourceStream.Create(HInstance, 'MDICLOSE', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    MDICLOSE:= TBitmap32.Create;
-    PngObjectToBitmap32(P, MDICLOSE);
-    MDICLOSE.DrawMode:=dmBlend;
-    //MDICLOSE.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(SPINBUTTONBACKGROUNDUP) then
-  Begin
-    ResStream:= TResourceStream.Create(HInstance, 'SPINBUTTONBACKGROUNDUP', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    SPINBUTTONBACKGROUNDUP:= TBitmap32.Create;
-    PngObjectToBitmap32(P, SPINBUTTONBACKGROUNDUP);
-    SPINBUTTONBACKGROUNDUP.DrawMode:=dmBlend;
-    //SPINBUTTONBACKGROUNDUP.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(SPINBUTTONBACKGROUNDDOWN) then
-  Begin
-    ResStream:= TResourceStream.Create(HInstance, 'SPINBUTTONBACKGROUNDDOWN', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    SPINBUTTONBACKGROUNDDOWN:= TBitmap32.Create;
-    PngObjectToBitmap32(P, SPINBUTTONBACKGROUNDDOWN);
-    SPINBUTTONBACKGROUNDDOWN.DrawMode:=dmBlend;
-    //SPINBUTTONBACKGROUNDDOWN.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(CLOSEGLYPH) then
-  Begin
-    ResStream:= TResourceStream.Create(HInstance, 'CLOSEGLYPH', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    CLOSEGLYPH:= TBitmap32.Create;
-    PngObjectToBitmap32(P, CLOSEGLYPH);
-    CLOSEGLYPH.DrawMode:=dmBlend;
-    //CLOSEGLYPH.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(MINIMIZEGLYPH) then
-  Begin
-    ResStream:= TResourceStream.Create(HInstance, 'MINIMIZEGLYPH', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    MINIMIZEGLYPH:= TBitmap32.Create;
-    PngObjectToBitmap32(P, MINIMIZEGLYPH);
-    MINIMIZEGLYPH.DrawMode:=dmBlend;
-    //MINIMIZEGLYPH.StretchFilter:= FStretchFilter;
-  End;
-  If Not Assigned(MAXIMIZEGLYPH) then
-  Begin
-    ResStream:= TResourceStream.Create(HInstance, 'MAXIMIZEGLYPH', RT_RCDATA);
-    P.LoadFromStream(ResStream);
-    ResStream.Free;
-    MAXIMIZEGLYPH:= TBitmap32.Create;
-    PngObjectToBitmap32(P, MAXIMIZEGLYPH);
-    MAXIMIZEGLYPH.DrawMode:=dmBlend;
-    //MAXIMIZEGLYPH.StretchFilter:= FStretchFilter;
-  End;
-  P.Free;
-end;
-
-procedure FinalizeStock;
-begin
-end;
-
-procedure DrawCaptionArea(DC: HDC; R: TRect; Color: TColor; Vertical: Boolean);
-var
-  T: Integer;
-begin
-  if Vertical then
-  begin
-    T := (2 * R.Top + R.Bottom) div 3;
-    GradFill(DC, Rect(R.Left, R.Top, R.Right, T), Lighten(Color, 24), Color, gkVert);
-    GradFill(DC, Rect(R.Left, T, R.Right, R.Bottom), Color, Lighten(Color, -8), gkVert);
-  end
-  else
-  begin
-    T := (2 * R.Left + R.Right) div 3;
-    GradFill(DC, Rect(R.Left, R.Top, T, R.Bottom), Lighten(Color, 24), Color, gkHorz);
-    GradFill(DC, Rect(T, R.Top, R.Right, R.Bottom), Color, Lighten(Color, -8), gkHorz);
-  end;
-end;
-
-constructor TTBXMacOSXg32Theme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-//  FInterpolationMode:= InterpolationModeHighQuality;//InterpolationModeHighQualityBicubic;//InterpolationModeNearestNeighbor;//
-  SetupColorCache;
-end;
-
-destructor TTBXMacOSXg32Theme.Destroy;
-begin
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXMacOSXg32Theme.DrawImage(Source: TBitmap32; Target: TCanvas;
-  SourceRect:TRect; x, y: Integer);
-begin
-  //DrawBitmap32(Target.Handle, Rect(x,y,x+Source.
-  DrawBitmap32Rect(Target.Handle, x,y, Source, SourceRect);
-
-{  graphic:= TGPgraphics.Create(Target.Handle);
-  //graphic.SetInterpolationMode(FInterpolationMode);
-  With SourceRect do
-    graphic.DrawImage(Source,x,y,
-      Left,Top,Right-Left,Bottom-Top,UnitPixel);
-  graphic.Free;{}
-end;
-
-procedure TTBXMacOSXg32Theme.DrawStripeBG(Target: TCanvas; R: TRect; AColor:TColor);
-const
-  STRIPE_STEP = 4; {3}
-var
-  Y, I: Integer;
-  HighlightColor,ShadowColor:TColor;
-  DC: HDC;
-Begin
-  DC:= Target.Handle;
-
-  I := ColorIntensity(AColor);
-  if I &lt; 200 then I := (200 - I) div 20
-  else I := 0;
-  HighlightColor := GetNearestColor(DC, Lighten(AColor, 11 + I));
-  ShadowColor := GetNearestColor(DC, Lighten(AColor, -8)); {8}
-
-  //if not Transparent then
-  begin
-    {Target.Brush.Color := AColor;
-    Target.FillRect(R);}
-    FillRectEx(DC, R, AColor);
-  end;
-
-
-    Y:= R.Top mod (STRIPE_STEP);
-    Y := R.Top - Y;
-    while Y &lt; R.Bottom do
-    begin
-      DrawLineEx(DC, R.Left, Y, R.Right, Y, ShadowColor);
-      Inc(Y, 2);
-      DrawLineEx(DC, R.Left, Y, R.Right, Y, HighlightColor);
-      Inc(Y, 2);
-    end;
-
-
-{  Y:= R.Top mod (STRIPE_STEP*2);
-  Y := R.Top - Y;
-  R1:= Rect(R.Left,Y,R.Right,Y+STRIPE_STEP);
-  while R1.Bottom&lt; R.Bottom do
-  begin
-    FillRectEx(DC,R1,HighlightColor);
-    OffsetRect(R1,0,STRIPE_STEP);
-//    Inc(Y,STRIPE_STEP);
-    FillRectEx(DC,R1,ShadowColor);
-    OffsetRect(R1,0,STRIPE_STEP);
-//    Inc(Y,STRIPE_STEP);
-  end;}
-end;
-
-procedure TTBXMacOSXg32Theme.EnlargeBitmap(Source: TBitmap32; Target: TCanvas;
-  SourceRect, TargetRect: TRect; VSideSize, HSideSize: Integer);
-Var
-  R1:TRect;
-  R2:TRect;
-  tv2, th2: Integer;
-  trgWidth, trgHeight: Integer;
-  srcWidth, srcHeight: Integer;
-begin
-  srcWidth:= SourceRect.Right-SourceRect.Left;
-  srcHeight:= SourceRect.Bottom-SourceRect.Top;
-  If srcWidth-HSideSize*2&lt;2 then
-    HSideSize:=(srcWidth div 2)-1;
-  If srcHeight-VSideSize*2&lt;2 then
-    VSideSize:=(srcHeight div 2)-1;
-
-  trgWidth := TargetRect.Right- TargetRect.Left;
-  trgHeight:= TargetRect.Bottom-TargetRect.Top;
-  tv2:= trgHeight div 2;
-  tv2:= Min(tv2, VSideSize);
-  th2:= trgWidth div 2;
-  th2:= Min(th2, HSideSize);
-  StockBitmap321.SetSize(trgWidth, trgHeight);
-  StockBitmap321.Clear($00000000);
-  With SourceRect do
-  Begin
-    //Source.DrawTo(StockBitmap321, StockBitmap321.BoundsRect, SourceRect);
-    // center
-    r1:= Rect(th2,tv2,trgWidth-th2,trgHeight-tv2);
-    r2:= Rect(Left+HSideSize,Top+VSideSize,Right-HSideSize,Bottom-VSideSize);
-    Source.DrawTo(StockBitmap321, R1, R2);
-    // left
-    r1:= Rect(0,tv2,th2,trgHeight-tv2);
-    r2:= Rect(Left,Top+VSideSize,Left+HSideSize,Bottom-VSideSize);
-    Source.DrawTo(StockBitmap321, R1, R2);
-    // top
-    r1:= Rect(th2,0,trgWidth-th2,tv2);
-    r2:= Rect(Left+HSideSize,Top,Right-HSideSize,Top+VSideSize);
-    Source.DrawTo(StockBitmap321, R1, R2);
-    // right
-    r1:= Rect(trgWidth-th2,tv2,trgWidth,trgHeight-tv2);
-    r2:= Rect(Right-HSideSize,Top+VSideSize,Right,Bottom-VSideSize);
-    Source.DrawTo(StockBitmap321, R1, R2);
-    // bottom
-    r1:= Rect(th2,trgHeight-tv2,trgWidth-th2,trgHeight);
-    r2:= Rect(Left+HSideSize,Bottom-VSideSize,Right-HSideSize,Bottom);
-    Source.DrawTo(StockBitmap321, R1, R2);
-    // left top
-    r1:= Rect(0, 0, th2, tv2);
-    r2:= Rect(Left,Top,Left+HSideSize,Top+VSideSize);
-    Source.DrawTo(StockBitmap321, R1, R2);
-    // right top
-    r1:= Rect(trgWidth-th2, 0, trgWidth, tv2);
-    r2:= Rect(Right-HSideSize,Top,Right,Top+VSideSize);
-    Source.DrawTo(StockBitmap321, R1, R2);
-    // left bottom
-    r1:= Rect(0, trgHeight-tv2, th2, trgHeight);
-    r2:= Rect(Left,Bottom-VSideSize,Left+HSideSize,Bottom);
-    Source.DrawTo(StockBitmap321, R1, R2);
-    // right bottom
-    r1:= Rect(trgWidth-th2,trgHeight-tv2, trgWidth, trgHeight);
-    r2:= Rect(Right-HSideSize,Bottom-VSideSize,Right,Bottom);
-    Source.DrawTo(StockBitmap321, R1, R2);
-  End;
-  DrawBitmap32(Target.Handle, TargetRect, StockBitmap321);
-end;
-
-function TTBXMacOSXg32Theme.GetBtnColor(const ItemInfo: TTBXItemInfo;
-  ItemPart: TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then B := bisPressed
-    else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then Result := clWindowFrame
-        else if (Result = clNone) then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXMacOSXg32Theme.GetIntegerMetrics(Index: Integer): Integer;
-begin
-  case Index of
-    TMI_EDIT_BTNWIDTH: Result := 18;
-  else
-    Result := Inherited GetIntegerMetrics(Index);
-  end;
-end;
-
-function TTBXMacOSXg32Theme.GetItemColor(
-  const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXMacOSXg32Theme.GetItemImageBackground(
-  const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXMacOSXg32Theme.GetItemTextColor(
-  const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXMacOSXg32Theme.GetPartColor(const ItemInfo: TTBXItemInfo;
-  ItemPart: TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then M := MFlags1[HoverKind = hkKeyboardHover]
-      else M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then B := bisPopupParent
-      else if Pushed then B := bisPressed
-      else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then Result := ToolbarColor;
-        if ItemPart = ipFrame then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXMacOSXg32Theme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then Result := MenubarColor
-    else Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then Result := clWindow
-    else Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then Result := DockPanelColor;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintBackgnd(Canvas: TCanvas; const ADockRect,
-  ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean;
-  AViewType: Integer);
-var
-  R: TRect;
-begin
-  if TBXLoColor then inherited
-  else with Canvas do
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      {if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;}
-      DrawStripeBG(Canvas, R, AColor);
-    end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintButton(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-//  DC: HDC;
-  R: TRect;
-//  C: TColor;
-  ShowHover, Embedded: Boolean;
-//  RL, RR: Integer;
-  DrawStyle: TDrawStyle;
-//  State: TBtnItemState;
-  y, yInc, yStart: Integer;
-  biRect:TRect;
-begin
-//  DC := Canvas.Handle;
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-//    State:= bisNormal;
-    DrawStyle:= bsDefault;
-    If Not Enabled then
-      DrawStyle:= bsDisabled
-    Else If Pushed then
-      DrawStyle:= bsPushed
-    Else If (HoverKind &lt;&gt; hkNone) and (Not Selected) then
-      DrawStyle:= bsHover
-    Else If Selected then
-      If (HoverKind &lt;&gt; hkNone) then
-        DrawStyle:= bsSelectedHover
-      Else
-        DrawStyle:= bsSelected
-    ;
-
-    //Brush.Style:= bsClear;//bsSolid;//
-//    graphic:= TGPgraphics.Create(Canvas.Handle);
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    If ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-    Begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        //PaintBackgnd(Canvas, RECT(0,0,0,0), ARect, ARect, 0, False, VT_UNKNOWN);
-        DrawStripeBG(Canvas, ARect, MenuItemColors[misHot, ipBody]);
-    End else
-    if ComboPart = cpSplitRight then
-    Begin
-      // DropDown Right
-      yStart:= 0;
-      yInc:= TOOLBARBUTTONSSPLITDROPDOWN.Height div 6;
-      y:=0;
-      Case DrawStyle of
-        bsDefault:       If Embedded then  y:= 1 Else y:= 0;
-        bsHover:         y:= 1;
-        bsDisabled:      y:= 3;
-        bsPushed:        y:= 5;
-        bsSelected:      y:= 4;
-        bsSelectedHover: y:= 5;
-      End;//CASE
-      biRect:= Rect(0,yStart+yInc*y,TOOLBARBUTTONSSPLITDROPDOWN.Width,yStart+yInc*(y+1));
-      EnlargeBitmap(TOOLBARBUTTONSSPLITDROPDOWN, Canvas, biRect, R, 9, 5);
-      //Canvas.Draw(R.Left, R.Top, StockBMP);
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-      //EnlargeBitmap(BOTON, Canvas, biRect, R, 10, 12);
-      //EnlargeBitmap(BOTON, Canvas, biRect, R, 12);
-    End Else
-    if ComboPart = cpSplitLeft then
-    Begin
-      // Dropdown Left
-      yStart:= 0;
-      yInc:= TOOLBARBUTTONSSPLIT.Height div 6;
-      y:=0;
-      Case DrawStyle of
-        bsDefault:       If Embedded then  y:= 1 Else y:= 0;
-        bsHover:         y:= 1;
-        bsDisabled:      y:= 3;
-        bsPushed:        y:= 5;
-        bsSelected:      y:= 4;
-        bsSelectedHover: y:= 5;
-      End;//CASE
-      biRect:= Rect(0,yStart+yInc*y,TOOLBARBUTTONSSPLIT.Width,yStart+yInc*(y+1));
-      EnlargeBitmap(TOOLBARBUTTONSSPLIT, Canvas, biRect, R, 8, 3);
-      //Canvas.Draw(R.Left, R.Top, StockBMP);
-    End Else
-    Begin
-      If Embedded then
-      Begin
-        // Button
-        yStart:= 0;
-        yInc:= BOTON.Height div 5;
-        y:=0;
-        Case DrawStyle of
-          bsDefault:  //Pen.Color:= clWhite;
-            y:= 0;
-          bsHover:    //Pen.Color:= clLime;
-            y:= 1;
-          bsDisabled: //Pen.Color:= clBlack;
-            y:= 3;
-          bsPushed:   //Pen.Color:= clRed;
-            y:= 2;
-          bsSelected: //Pen.Color:= clBlue;
-            y:= 4;
-          bsSelectedHover:
-            y:= 1;
-        End;//CASE
-        biRect:= Rect(0,yStart+yInc*y,BOTON.Width,yStart+yInc*(y+1));
-        EnlargeBitmap(BOTON, Canvas, biRect, R, 11, 11);
-      End Else
-      Begin
-        // Tool Button
-        yStart:= 0;
-        yInc:= TOOLBARBUTTONS.Height div 6;
-        y:=0;
-        Case DrawStyle of
-          bsDefault:      y:= 0;
-          bsHover:        y:= 1;
-          bsDisabled:     y:= 3;
-          bsPushed:       y:= 2;
-          bsSelected:     y:= 4;
-          bsSelectedHover:y:= 5;
-        End;//CASE
-        biRect:= Rect(0,yStart+yInc*y,TOOLBARBUTTONS.Width,yStart+yInc*(y+1));
-        EnlargeBitmap(TOOLBARBUTTONS, Canvas, biRect, R, 7, 5);
-      End;
-    End;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintComboArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas, ItemInfo do
-  begin
-    X := (Left + Right) div 2 - 1;
-    Y := (Top + Bottom) div 2 - 1;
-    {If Not Enabled then
-      Pen.Color := clLtGray
-    Else
-      Pen.Color := clBlack;//GetPartColor(ItemInfo, ipText);{}
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-    Begin
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)]);
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)]);
-    End else
-    Begin
-      Y:= Y-1;
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-      Y:= Y+3;
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    End;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-begin
-  DrawStripeBG(Canvas, DockRect, ToolbarColor);//MenuItemColors[misHot, ipBody]);//
-end;
-
-procedure TTBXMacOSXg32Theme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect;
-  const DockPanelInfo: TTBXDockPanelInfo);
-var
-  DC: HDC;
-  Sz: Integer;
-  R2: TRect;
-  biRect:TRect;
-  Flags: Integer;
-  y, yStart, yInc:Integer;
-  CloseButtonDown, CloseButtonHover: Boolean;
-
-  procedure CaptionFill(R: TRect);
-  const
-    GRAD: array [Boolean] of TGradientKind = (gkHorz, gkVert);
-  begin
-    if USE_THEMES then
-      GradFill(DC, R, Lighten(ToolbarColor, 12), Lighten(ToolbarColor, -12), GRAD[DockPanelInfo.IsVertical])
-    else
-      FillRectEx(DC, R, ToolbarColor);
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with Canvas, DockPanelInfo do
-  begin
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-
-    { Border }
-    FrameRectEx(DC, R, ToolbarColor, True);
-    R2 := R;
-    if ShowCaption then
-      if IsVertical then Inc(R2.Top, Sz)
-      else Inc(R2.Left, Sz);
-    FrameRectEx(DC, R2, clWindow, False);
-
-    if not ShowCaption then Exit;
-
-    { Caption area }
-    if IsVertical then R.Bottom := R.Top + Sz
-    else R.Right := R.Left + Sz;
-    Windows.DrawEdge(Handle, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-
-    { Close button }
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      CloseButtonDown := (CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := R;
-      Brush.Color := ToolbarColor;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz;
-        R.Right := R2.Left;
-        CaptionFill(R2);
-        {InflateRect(R2, -1, -1);}
-        Inc(R2.Left,2);
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz;
-        R.Bottom := R2.Top;
-        CaptionFill(R2);
-        {InflateRect(R2, -1, -1);}
-        Dec(R2.Bottom,2);
-      end;
-
-      Flags := TS_NORMAL;
-      if CloseButtonDown then Flags := TS_PRESSED
-      else if CloseButtonHover then Flags := TS_HOT;
-      {DrawThemeBackground(TOOLBAR_THEME, DC, TP_BUTTON, Flags, R2, nil);
-      if CloseButtonDown then OffsetRect(R2, 1, 1);
-      InflateRect(R2, -2, -2);}
-
-      yStart:= 0;
-      yInc:= MDICLOSE.Height div 4;
-//      y:=0;
-      Case Flags of
-        TS_NORMAL : y:=0;
-        TS_PRESSED: y:=2;
-        TS_HOT    : y:=1;
-        Else        y:=3;
-      End;//CASE
-      biRect:= Rect(0,yStart+yInc*y,MDICLOSE.Width,yStart+yInc*(y+1));
-      InflateRect(R2, (((biRect.Right-biRect.Left)-(R2.Right-R2.Left)) div 2), (((biRect.Bottom-biRect.Top)-(R2.Bottom-R2.Top)) div 2));
-      OffsetRect(R2, 0, -1);
-      //EnlargeBitmap(MDICLOSE, Canvas, biRect, R2, 8,8);
-      DrawImage(MDICLOSE, Canvas, biRect, R2.Left, R2.Top);
-//      DrawButtonBitmap(Canvas, R2);
-    end;
-
-    { Caption }
-    CaptionFill(R);
-    if IsVertical then InflateRect(R, -2, 0)
-    else Inflaterect(R, 0, -2);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX;
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-
-  procedure Draw(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    if ItemInfo.IsVertical then Canvas.Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else Canvas.Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-
-begin
-  with ItemInfo, ARect do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-
-    if (Pushed or Selected) and (ComboPart &lt;&gt; cpSplitRight) then
-    begin
-      Inc(X); Inc(Y);
-    end;
-
-    if Enabled then
-    begin
-      {if Boolean(ItemOptions and IO_TOOLBARSTYLE) then Draw(clPopupText)
-      else Draw(GetPartColor(ItemInfo, ipText));}
-      Draw(GetPartColor(ItemInfo, ipText));
-    end
-    else
-    begin
-      //Inc(X); Inc(Y);
-      Draw(GetPartColor(ItemInfo, ipText));//clBtnHighlight);
-      {Dec(X); Dec(Y);
-      Draw(GetPartColor(ItemInfo, ipText));//clBtnHighlight);}
-    end;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintEditButton(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo;
-  ButtonInfo: TTBXEditBtnInfo);
-var
-//  DC: HDC;
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-//  StateFlags: Integer;
-  R, BR, biRect: TRect;
-//  C: TColor;
-  X, Y, yInc: Integer;
-begin
-//  DC := Canvas.Handle;
-  R := ARect;
-  with Canvas, ItemInfo do
-  begin
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      { DropDown button }
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      // Combo BOX
-      yInc:= SPINBUTTONBACKGROUNDRIGHT.Height div 4;
-      if BtnDisabled then y:=3
-      else if BtnPressed then y:=2
-      else if BtnHot then y:=1
-      else if Embedded then y:= 1
-      else y:= 0;
-      biRect:= Rect(0,yInc*y,SPINBUTTONBACKGROUNDRIGHT.Width,yInc*(y+1));
-
-      if BtnHot or BtnPressed then InflateRect(R, -1, -1)
-      else InflateRect(R, -2, -2);
-      EnlargeBitmap(SPINBUTTONBACKGROUNDRIGHT, Canvas, biRect, R, 7, 5);
-      PaintComboArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      { Paint spin buttons }
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      //if BtnHot then InflateRect(R, 1, 1);
-      if BtnHot or BtnPressed then InflateRect(R, -1, -1)
-      else InflateRect(R, -2, -2);
-
-      { Upper }
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom - 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      {if BtnDisabled then StateFlags := UPS_DISABLED
-      else if BtnPressed then StateFlags := UPS_PRESSED
-      else if BtnHot then StateFlags := UPS_HOT
-      else StateFlags := UPS_NORMAL;
-      DrawThemeBackground(SPIN_THEME, Handle, SPNP_UP, StateFlags, BR, nil);}
-      yInc:= SPINBUTTONBACKGROUNDUP.Height div 4;
-      if BtnDisabled then y:=3
-      else if BtnPressed then y:=2
-      else if BtnHot then y:=1
-      else if Embedded then y:= 1
-      else y:= 0;
-      biRect:= Rect(0,yInc*y,SPINBUTTONBACKGROUNDUP.Width,yInc*(y+1));
-      EnlargeBitmap(SPINBUTTONBACKGROUNDUP, Canvas, biRect, BR, 4, 3);
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      If BtnDisabled then Pen.Color := clBtnShadow
-      Else                Pen.Color := clBtnText;
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      { Lower }
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      {if BtnDisabled then StateFlags := DNS_DISABLED
-      else if BtnPressed then StateFlags := DNS_PRESSED
-      else if BtnHot then StateFlags := DNS_HOT
-      else StateFlags := DNS_NORMAL;
-      DrawThemeBackground(SPIN_THEME, Handle, SPNP_DOWN, StateFlags, BR, nil);}
-      yInc:= SPINBUTTONBACKGROUNDDOWN.Height div 4;
-      if BtnDisabled then y:=3
-      else if BtnPressed then y:=2
-      else if BtnHot then y:=1
-      else if Embedded then y:= 1
-      else y:= 0;
-      biRect:= Rect(0,yInc*y,SPINBUTTONBACKGROUNDDOWN.Width,yInc*(y+1));
-      EnlargeBitmap(SPINBUTTONBACKGROUNDDOWN, Canvas, biRect, BR, 4, 3);
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      If BtnDisabled then Pen.Color := clBtnShadow
-      Else                Pen.Color := clBtnText;
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-    end;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo;
-  const EditInfo: TTBXEditInfo);
-Var
-//  C:TColor;
-  R: TRect;
-begin
-  //inherited;
-  R:= ARect;
-  with ItemInfo do
-  Begin
-    if Enabled then
-    begin
-      if not ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED) and
-        not (Pushed or Selected or (HoverKind &lt;&gt; hkNone)) then
-      begin
-        InflateRect(R, -1, -1);
-        Canvas.Brush.Color:= clWindow;
-        Canvas.Brush.Style:= bsSolid;
-        Canvas.FillRect(R);
-      end Else
-      Begin
-        If not (Pushed or Selected or (HoverKind &lt;&gt; hkNone)) then
-          InflateRect(R, -1, -1);
-        EnlargeBitmap(COMBOBOX, Canvas, Rect(0,0,COMBOBOX.Width,COMBOBOX.Height), R, 6, 3);
-      End;
-    end Else
-    Begin
-      InflateRect(R, -1, -1);
-      Canvas.Pen.Color:= clWhite;
-      Canvas.Brush.Style:= bsClear;
-      Canvas.Rectangle(R);
-    End;
-  End;
-  if EditInfo.RightBtnWidth &gt; 0 then
-  Begin
-    R := ARect;
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  End;
-//  Canvas.Rectangle(ARect);
-end;
-
-procedure TTBXMacOSXg32Theme.PaintFloatingBorder(Canvas: TCanvas;
-  const ARect: TRect; const WindowInfo: TTBXWindowInfo);
-var
-  DC: HDC;
-  BorderColor, C: TColor;
-  I: Integer;
-  Sz: TPoint;
-  R,R2: TRect;
-  Size: TSize;
-  CaptionString: string;
-  IsPushed, IsHovered: Boolean;
-  BtnItemState: TBtnItemState;
-  SaveIndex: Integer;
-  y, yStart, yInc:Integer;
-  CloseButtonDown, CloseButtonHover: Boolean;
-  biRect:TRect;
-  Flags: Integer;
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with Canvas do
-  begin
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0  then
-    begin
-      R := ARect;
-      FrameRectEx(DC, R, WinFrameColors[wfsActive, wfpBorder], True);
-      FillRectEx(DC, R, GetViewColor(WindowInfo.ViewType));
-      //BtnItemColors[bisSelected, ipFrame]
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R:= ARect;
-      R.Bottom:= R.Top+GetSystemMetrics(SM_CYSMCAPTION)+WindowInfo.FloatingBorderSize.Y;
-      FrameRectEx(DC, R, BtnItemColors[bisSelected, ipFrame], True);
-      DrawCaptionArea(Handle, R, WinFrameColors[wfsActive, wfpBorder], True);
-
-      Font.Assign(SmCaptionFont);
-      Font.Color := clBtnText;
-      CaptionString := string(WindowInfo.Caption);
-      Size := TextExtent(CaptionString);
-      if Size.cx &gt; 0 then Inc(Size.cx, 16);
-
-      InflateRect(R, -2, 0);
-      Dec(R.Top, 2);
-
-      Brush.Style := bsClear;
-      DrawText(Canvas.Handle, PChar(CaptionString), Length(CaptionString), R,
-        DT_SINGLELINE or DT_CENTER or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-      Brush.Style := bsSolid;
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      CloseButtonDown := (WindowInfo.CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (WindowInfo.CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION));
-      with Windowinfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top) - 1;
-      {Dec(R.Bottom, 2);
-      Inc(R.Left, 3); Dec(R.Right);
-      Inc(R.Top);
-      Dec(R.Bottom);}
-
-      Flags := TS_NORMAL;
-      if CloseButtonDown then Flags := TS_PRESSED
-      else if CloseButtonHover then Flags := TS_HOT;
-      yStart:= 0;
-      yInc:= MDICLOSE.Height div 4;
-//      y:=0;
-      Case Flags of
-        TS_NORMAL : y:=0;
-        TS_PRESSED: y:=2;
-        TS_HOT    : y:=1;
-        Else        y:=3;
-      End;//CASE
-      biRect:= Rect(0,yStart+yInc*y,MDICLOSE.Width,yStart+yInc*(y+1));
-      InflateRect(R, (((biRect.Right-biRect.Left)-(R.Right-R.Left)) div 2), (((biRect.Bottom-biRect.Top)-(R.Bottom-R.Top)) div 2));
-      OffsetRect(R, 0, -1);
-      //EnlargeBitmap(MDICLOSE, Canvas, biRect, R, 8,8);
-      DrawImage(MDICLOSE, Canvas, biRect, R.Left, R.Top);
-    end;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintFrameControl(Canvas: TCanvas; R: TRect;
-  Kind, State: Integer; Params: Pointer);
-Var
-//  graphic: TGPgraphics;
-  y, yInc, yStart: Integer;
-  DrawStyle: TDrawStyle;
-  biRect: TRect;
-begin
-  with Canvas do
-  begin
-    //graphic:= TGPgraphics.Create(Canvas.Handle);
-    //graphic.SetInterpolationMode(FInterpolationMode);
-    DrawStyle:= bsDefault;
-    If Boolean(State and PFS_DISABLED) then
-      DrawStyle:= bsDisabled
-    Else If Boolean(State and PFS_PUSHED) then
-      DrawStyle:= bsPushed
-    Else If Boolean(State and PFS_HOT) then
-      DrawStyle:= bsHover
-    ;
-
-    case Kind of
-      PFC_CHECKBOX:
-        Begin
-          if Boolean(State and PFS_CHECKED) then
-            yStart:= CheckM.Height div 3
-          Else if Boolean(State and PFS_MIXED) then
-            yStart:= (CheckM.Height div 3) * 2
-          Else
-            yStart:= 0;
-          yInc:= CheckM.Height div 12;
-          y:= 0;
-          Case DrawStyle of
-            bsDefault:  y:= 0;
-              //graphic.DrawImage(CheckM, Rect(R), 0,yStart+yInc*0,CheckM.Width,yInc, UnitPixel);
-              //graphic.DrawImage(CheckM, R.Left,R.Top, 0,yStart+yInc*0,CheckM.Width,yInc, UnitPixel);
-            bsHover:    y:= 2;
-              //graphic.DrawImage(CheckM, Rect(R), 0,yStart+yInc*2,CheckM.Width,yInc, UnitPixel);
-              //graphic.DrawImage(CheckM, R.Left,R.Top, 0,yStart+yInc*2,CheckM.Width,yInc, UnitPixel);
-            bsDisabled: y:= 3;
-              //graphic.DrawImage(CheckM, Rect(R), 0,yStart+yInc*3,CheckM.Width,yInc, UnitPixel);
-              //graphic.DrawImage(CheckM, R.Left,R.Top, 0,yStart+yInc*3,CheckM.Width,yInc, UnitPixel);
-            bsPushed:   y:= 1;
-              //graphic.DrawImage(CheckM, Rect(R), 0,yStart+yInc*1,CheckM.Width,yInc, UnitPixel);
-              //graphic.DrawImage(CheckM, R.Left,R.Top, 0,yStart+yInc*1,CheckM.Width,yInc, UnitPixel);
-          End;//CASE
-          biRect:= Rect(0,yStart+yInc*y,CheckM.Width,yStart+yInc*(y+1));
-          DrawImage(CheckM, Canvas, biRect, R.Left, R.Top);
-        End;
-      PFC_RADIOBUTTON:
-        Begin
-          if Boolean(State and PFS_CHECKED) then
-            yStart:= RadioM.Height div 2
-          Else
-            yStart:= 0;
-          yInc:= RadioM.Height div 8;
-          Case DrawStyle of
-            bsDefault:  y:= 0;
-              //graphic.DrawImage(RadioM, Rect(R), 0,yStart+yInc*0,RadioM.Width,yInc, UnitPixel);
-              //graphic.DrawImage(RadioM, R.Left,R.Top, 0,yStart+yInc*0,RadioM.Width,yInc, UnitPixel);
-            bsHover:    y:= 2;
-              //graphic.DrawImage(RadioM, Rect(R), 0,yStart+yInc*2,RadioM.Width,yInc, UnitPixel);
-              //graphic.DrawImage(RadioM, R.Left,R.Top, 0,yStart+yInc*2,RadioM.Width,yInc, UnitPixel);
-            bsDisabled: y:= 3;
-              //graphic.DrawImage(RadioM, Rect(R), 0,yStart+yInc*3,RadioM.Width,yInc, UnitPixel);
-              //graphic.DrawImage(RadioM, R.Left,R.Top, 0,yStart+yInc*3,RadioM.Width,yInc, UnitPixel);
-            bsPushed:   y:= 1;
-              //graphic.DrawImage(RadioM, Rect(R), 0,yStart+yInc*1,RadioM.Width,yInc, UnitPixel);
-              //graphic.DrawImage(RadioM, R.Left,R.Top, 0,yStart+yInc*1,RadioM.Width,yInc, UnitPixel);
-          End;//CASE
-          biRect:= Rect(0,yStart+yInc*y,RadioM.Width,yStart+yInc*(y+1));
-          DrawImage(RadioM, Canvas, biRect, R.Left, R.Top);
-        End;
-      Else
-        inherited;
-    end;//case
-//    graphic.Free;{}
-  End;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList;
-  ImageIndex: Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      //HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-      BlendTBXIcon(Canvas, ARect, ImageList, ImageIndex, 178);
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-Var
-  y, yinc:Integer;
-  img: TBitmap32;
-  biRect, r: TRect;
-begin
-  case ButtonKind of
-    DFCS_CAPTIONMIN:     img:= MINIMIZEGLYPH;
-    DFCS_CAPTIONRESTORE: img:= MAXIMIZEGLYPH;
-    DFCS_CAPTIONCLOSE:   img:= CLOSEGLYPH;
-  else
-    Exit;
-  end;
-
-  yinc:= img.Height div 4;
-  If Not ItemInfo.Enabled then
-    y:= 3
-  Else If ItemInfo.Pushed or ItemInfo.Selected then
-    y:= 2
-  Else If ItemInfo.HoverKind&lt;&gt;hkNone then
-    y:= 1
-  Else
-    y:= 0;
-
-  biRect:= Rect(0,0+yInc*y,img.Width,0+yInc*(y+1));
-  R:= ARect;
-  InflateRect(R, (((biRect.Right-biRect.Left)-(R.Right-R.Left)) div 2), (((biRect.Bottom-biRect.Top)-(R.Bottom-R.Top)) div 2));
-  OffsetRect(R, 0, -1);
-  DrawImage(img, Canvas, biRect, R.Left, R.Top);
-end;
-
-procedure TTBXMacOSXg32Theme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then Pen.Color := clWhite //GetPartColor(ItemInfo, ipFrame)
-      else Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2:= ARect;
-    //InflateRect(R2, -1, -1);
-    if ((Selected) and (Enabled)) then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      //InflateRect(R, -1, -1);
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-    (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot, ipBody], False, VT_UNKNOWN);
-    end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      InflateRect(ARect, -2,0);
-      Top := (Bottom div 2);
-      while Left &lt; Right do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Left := Left + 3;
-      end;
-    end else if enabled then
-    begin
-      InflateRect(ARect, 0,-2);
-      Left := (Right div 2); // - 1;
-      while Top &lt; Bottom do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Top := Top + 3;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleSizes: array [Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((9, 0, 6), (14, 14, 14));
-  DragHandleOffsets: array [Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0, 2), (3, 0, 5));
-  GripperPart: array [Boolean] of Cardinal = (RP_GRIPPER, RP_GRIPPERVERT);
-  Pattern: array [0..15] of Byte = (0, 0, $CC, 0, $78, 0, $30, 0, $78, 0, $CC, 0, 0, 0, 0, 0);
-var
-//  DC: HDC;
-  DHSize: Integer;
-//  Sz: TSize;
-  R2: TRect;
-  Flags: Cardinal;
-  Z: Integer;
-  BtnVisible, Horz, CloseButtondown, CloseButtonHover: Boolean;
-  y, yStart, yInc:Integer;
-  biRect:TRect;
-begin
-  Canvas.FillRect(R);
-
-  { Border }
-  if ToolbarInfo.BorderStyle = bsSingle then
-    Frame3D(Canvas.Handle, R, Lighten(ToolbarInfo.EffectiveColor, 24), Lighten(ToolbarInfo.EffectiveColor, -32), False);
-  if not ToolbarInfo.AllowDrag then Exit;
-
-  BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-  Horz := not ToolbarInfo.IsVertical;
-
-  DHSize := GetTBXDragHandleSize(ToolbarInfo);
-  if Horz then R.Right := R.Left + DHSize
-  else R.Bottom := R.Top + DHSize;
-
-  { Drag handle area }
-  if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-  begin
-    R2 := R;
-    if Horz then Inc(R2.Top, 2)
-    else Inc(R2.Left, 2);
-    if BtnVisible then
-      if Horz then Inc(R2.Top, DHSize - 1)
-      else Dec(R2.Right, DHSize - 1);
-    With R2 do
-    if Not Horz then
-    begin
-      Top := (Bottom div 2);
-      while Left &lt; Right do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Left := Left + 3;
-      end;
-    end else
-    begin
-      Left := (Right div 2); // - 1;
-      while Top &lt; Bottom do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Top := Top + 3;
-      end;
-    end;
-  end;
-
-  { Close Button }
-  if BtnVisible then
-  begin
-    With Canvas do
-    Begin
-      CloseButtonDown := (ToolbarInfo.CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (ToolbarInfo.CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := GetTBXDockedCloseButtonRect(ToolbarInfo);
-      Brush.Color := ToolbarColor;
-      Flags := TS_NORMAL;
-      if CloseButtonDown then Flags := TS_PRESSED
-      else if CloseButtonHover then Flags := TS_HOT;
-      {DrawThemeBackground(TOOLBAR_THEME, DC, TP_BUTTON, Flags, R2, nil);
-      if CloseButtonDown then OffsetRect(R2, 1, 1);
-      InflateRect(R2, -2, -2);}
-
-      yStart:= 0;
-      yInc:= MDICLOSE.Height div 4;
-//      y:=0;
-      Case Flags of
-        TS_NORMAL : y:=0;
-        TS_PRESSED: y:=2;
-        TS_HOT    : y:=1;
-        Else        y:=3;
-      End;//CASE
-      biRect:= Rect(0,yStart+yInc*y,MDICLOSE.Width,yStart+yInc*(y+1));
-      InflateRect(R2, (((biRect.Right-biRect.Left)-(R2.Right-R2.Left)) div 2), (((biRect.Bottom-biRect.Top)-(R2.Bottom-R2.Top)) div 2));
-      OffsetRect(R2, 0, -1);
-      //EnlargeBitmap(MDICLOSE, Canvas, biRect, R2, 8,8);
-      DrawImage(MDICLOSE, Canvas, biRect, R2.Left, R2.Top);
-//      DrawButtonBitmap(Canvas, R2);
-    End;
-  end;
-end;
-
-procedure TTBXMacOSXg32Theme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-{  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := clSilver;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-
-  gradBL := NearestMixedColor(clGray, gradCol1, 64);}
-
-  MenubarColor := $00F7F7F7;
-  ToolbarColor := $00F7F7F7;
-
-  PopupColor := MenuBarColor;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clSilver;
-
-{  BarSepColor := $A0A0A0;
-
-  EditFrameColor := Blend(clSilver, clWhite, 80);
-  EditFrameDisColor := Blend(clSilver, clWhite, 50);}
-
-{  if Aqua then
-    BaseColor := $00E0A030 // Aqua
-  else
-    BaseColor := $00A8A8A8; // Discret}
-  BaseColor := $00E0A030; // Aqua
-  HotColor := clBlack;
-  PopupSeparatorColor := clBlack;
-
-  HotBtnFace := Blend(BaseColor, clWhite, 80);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := clSilver; //Blend(clGray, clWhite, 80);
-  //SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-  WinFrameColors[wfsActive, wfpCaption] := clSilver;
-  WinFrameColors[wfsActive, wfpCaptionText] := HotColor; //clWhite;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clGray, 180);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := clSilver; //Blend(clGray, clWhite, 80);
-  PnlFrameColors[wfsActive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive, wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clSilver; //clGray;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clGray, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clSilver;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := clDkGray;//Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 50);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := HotColor; //clWhite;
-  BtnItemColors[bisHot, ipFrame] := Blend(BaseColor, clWhite, 80);
-  //SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clWhite;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText], BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame], BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BaseColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBlack;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BaseColor;
-  MenuItemColors[misHot, ipText] := clWhite;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGray, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-{  DragHandleColor := Blend(clGray, clWhite, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);}
-
-{  ToolbarSeparatorColor := clBlack;
-  PopupSeparatorColor := ToolbarSeparatorColor;}
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-//  Undither(DragHandleColor);
-//  Undither(IconShadowColor);
-//  Undither(ToolbarSeparatorColor);
-//  Undither(PopupSeparatorColor);
-//  Undither(StatusPanelFrameColor);
-end;
-
-initialization
-  RegisterTBXTheme('MacOSx', TTBXMacOSXg32Theme);
-end.

Deleted: Lobby/TASClient/Themes/TBXMonaiTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXMonaiTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXMonaiTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,1445 +0,0 @@
-unit TBXMonaiTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Monai' TBX theme &#169; 2004 Roy Magne Klever
-//
-//  Last updated: 28.08.2004
-
-interface
-
-{$I TB2Ver.inc}
-{$I TBX.inc}
-
-uses
-  Windows, Messages, Graphics, TBXThemes, TBXDefaultTheme, ImgList;
-
-type
-  TTBXMonaiTheme = class(TTBXDefaultTheme)
-  protected
-    DockPanelColor: TColor;
-    DisabledColor: TColor;
-    procedure SetupColorCache; override;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access, etc. }
-    function  GetBooleanMetrics(Index: Integer): Boolean; override;
-    function  GetIntegerMetrics(Index: Integer): Integer; override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function  GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function  GetViewColor(AViewType: Integer): TColor; override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect; DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect; ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer); override;
-  end;
-
-implementation
-
-uses TBXUtils, TB2Item, TB2Common, Classes, Controls, Forms, Commctrl;
-
-var
-  StockImgList: TImageList;
-  StockPatternBitmap: TBitmap;
-  CounterLock: Integer = 0;
-
-procedure InitializeStock;
-begin
-  StockPatternBitmap := TBitmap.Create;
-  StockPatternBitmap.Width := 8;
-  StockPatternBitmap.Height := 8;
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0, clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockPatternBitmap.Free;
-  StockImgList.Free;
-end;
-
-procedure CreateDottedPattern(Color: TColor);
-var
-  Lo: TColor;
-begin
-  with StockPatternBitmap.Canvas do
-  begin
-    Brush.Color := Color;
-    Lo := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-    FillRect(Rect(0, 0, 8, 8));
-    Pixels[0, 0] := Lo;
-    Pixels[0, 1] := Lo;
-    Pixels[1, 0] := Lo;
-    Pixels[1, 1] := Lo;
-
-    Pixels[4, 0] := Lo;
-    Pixels[4, 1] := Lo;
-    Pixels[5, 0] := Lo;
-    Pixels[5, 1] := Lo;
-
-    Pixels[0, 4] := Lo;
-    Pixels[0, 5] := Lo;
-    Pixels[1, 4] := Lo;
-    Pixels[1, 5] := Lo;
-
-    Pixels[4, 4] := Lo;
-    Pixels[4, 5] := Lo;
-    Pixels[5, 4] := Lo;
-    Pixels[5, 5] := Lo;
-  end;
-end;
-
-procedure DotFill(Canvas: TCanvas; R: TRect; Color: TColor; Border: Integer);
-var
-  DC: HDC;
-  Pt: TPoint;
-  W, H, I, J: Integer;
-  Brush: HBRUSH;
-begin
-  if Color &lt;&gt; clNone then
-  begin
-    CreateDottedPattern(Color);
-    Canvas.Brush.Style := bsSolid;
-    Canvas.Brush.Color := Color;
-    Canvas.FillRect(R);
-  end;
-  InflateRect(R, -Border, -Border);
-  W := R.Right - R.Left;
-  H := R.Bottom - R.Top;
-  W := ((W - 2) div 4) * 4 + 2;
-  H := ((H - 2) div 4) * 4 + 2;
-  R.Left := (R.Right + R.Left - W - 1) div 2;
-  R.Right := R.Left + W;
-  R.Top := (R.Top + R.Bottom - H - 1) div 2;
-  R.Bottom := R.Top + H;
-
-  if Color &lt;&gt; clNone then
-  begin
-    DC := Canvas.Handle;
-    Brush := CreatePatternBrush(StockPatternBitmap.Handle);
-    GetWindowOrgEx(DC, Pt);
-    SetBrushOrgEx(DC, R.Left - Pt.X, R.Top - Pt.Y, nil);
-    Windows.FillRect(DC, R, Brush);
-    DeleteObject(Brush);
-  end
-  else
-  begin
-    for J := 0 to (R.Bottom - R.Top - 1) div 4 do
-      for I := 0 to (R.Right - R.Left - 1) div 4 do
-        begin
-          Canvas.Pixels[R.Left + I * 4 + 1, R.Top + J * 4 + 1] := clBtnHighlight;
-          Canvas.Pixels[R.Left + I * 4 + 2, R.Top + J * 4 + 2] := clBtnShadow;
-        end;
-  end;
-end;
-
-procedure DotFillNew(Canvas: TCanvas; R: TRect; Color: TColor; Border: Integer);
-var
-  DC: HDC;
-  Pt: TPoint;
-  Brush: HBRUSH;
-begin
-  CreateDottedPattern(Color);
-  Canvas.Brush.Color := Color;
-  Canvas.FillRect(R);
-  InflateRect(R, -Border, -Border);
-  DC := Canvas.Handle;
-  Brush := CreatePatternBrush(StockPatternBitmap.Handle);
-  GetWindowOrgEx(DC, Pt);
-  SetBrushOrgEx(DC, R.Left - Pt.X, R.Top - Pt.Y, nil);
-  Windows.FillRect(DC, R, Brush);
-  DeleteObject(Brush);
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect);
-const
-  Pattern: array [0..15] of Byte = ($C6, 0, $6C, 0, $38, 0, $38, 0, $6C, 0, $C6, 0, 0, 0, 0, 0);
-begin
-  DrawGlyph(Canvas.Handle, R, 7, 6, Pattern[0], clBtnText);
-end;
-
-procedure RoundFrame(DC: HDC; R: TRect; RL, RR: Integer; C: TColor);
-var
-  P: array [0..8] of TPoint;
-  OldPen, Pen: HPen;
-begin
-  if C &lt; 0 then C := GetSysColor(C and $FF);
-  with R do
-  begin
-    Dec(Right); Dec(Bottom);
-    with P[0] do begin X := Left + RL; Y := Top; end;
-    with P[1] do begin X := Right - RR; Y := Top; end;
-    with P[2] do begin X := Right; Y := Top + RR; end;
-    with P[3] do begin X := Right; Y := Bottom - RR; end;
-    with P[4] do begin X := Right - RR; Y := Bottom; end;
-    with P[5] do begin X := Left + RL; Y := Bottom; end;
-    with P[6] do begin X := Left; Y := Bottom - RL; end;
-    with P[7] do begin X := Left; Y := Top + RL; end;
-    with P[8] do begin X := Left + RL; Y := Top; end;
-    Pen := CreatePen(PS_SOLID, 1, C);
-    OldPen := SelectObject(DC, Pen);
-    Windows.Polyline(DC, P[0], 9);
-    SelectObject(DC, OldPen);
-    DeleteObject(Pen);
-    Inc(Right); Inc(Bottom);
-  end;
-end;
-
-{ TTBXMonaiTheme }
-
-function TTBXMonaiTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_EDITHEIGHTEVEN:            Result := False;
-    TMB_PAINTDOCKBACKGROUND:       Result := False;
-    TMB_SOLIDTOOLBARNCAREA:        Result := False;
-    TMB_SOLIDTOOLBARCLIENTAREA:    Result := False;
-  else
-    Result := inherited GetBooleanMetrics(Index);
-  end;
-end;
-
-function TTBXMonaiTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := ToolbarColor;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then Result := clBtnFace
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_POPUPMENU) = PVT_POPUPMENU then Result := clPopup
-    else if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then Result := clWindow
-    else if (AViewType and PVT_TOOLBOX) = PVT_TOOLBOX then Result := ToolbarColor
-    else if (AViewType and PVT_CHEVRONMENU) = PVT_CHEVRONMENU then Result := clPopup;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then Result := DockPanelColor;
-end;
-
-function TTBXMonaiTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := inherited GetItemColor(ItemInfo);
-end;
-
-function TTBXMonaiTheme.GetIntegerMetrics(Index: Integer): Integer;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH:         Result := 12;
-    TMI_MENU_MDI_DW:                 Result := 1;
-    TMI_MENU_MDI_DH:                 Result := 2;
-    TMI_EDIT_FRAMEWIDTH:             Result := 2;
-    TMI_EDIT_TEXTMARGINHORZ:         Result := 2;
-    TMI_EDIT_TEXTMARGINVERT:         Result := 1;
-    TMI_EDIT_BTNWIDTH:               Result := 14;
-  else
-    Result := inherited GetIntegerMetrics(Index);
-  end;
-end;
-
-function TTBXMonaiTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-var
-  InMenuBar, ToolbarStyle, ShowInactive: Boolean;
-begin
-  with ItemInfo do
-  begin
-    InMenuBar := (ItemInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR;
-    ToolbarStyle := Boolean(ItemOptions and IO_TOOLBARSTYLE);
-    ShowInactive := InMenubar and not Boolean(ItemOptions and IO_APPACTIVE);
-
-    if not ToolbarStyle and not Enabled and (HoverKind = hkKeyboardHover) then Result := clBtnShadow
-    else if not Enabled then Result := DisabledColor
-    else if not ToolbarStyle or InMenuBar then
-    begin
-      if HoverKind &lt;&gt; hkNone then Result := clHighlightText
-      else if ShowInactive then Result := clGrayText
-      else Result := clMenuText
-    end
-    else Result := clBtnText;
-  end;
-end;
-
-procedure TTBXMonaiTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array [Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array [Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-  Sz: Integer;
-begin
-  Sz := 0;
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]);
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]);
-      Exit;
-    end
-    else Sz := 2;
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_LISTBOX) = PVT_LISTBOX then Sz := 2
-    else Sz := 3;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]);
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]);
-      Exit;
-    end
-    else Sz := 2;
-  end;
-  Border.X := Sz;
-  Border.Y := Sz;
-end;
-
-procedure TTBXMonaiTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  R: TRect;
-begin
-  if TBXLoColor then inherited
-  else with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-
-    if (AViewType and TVT_MENUBAR = TVT_MENUBAR) or
-      (AViewType and DPVT_NORMAL = DPVT_NORMAL) or
-      ((AViewType and VT_TOOLBAR = VT_TOOLBAR) and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintCaption(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-  InMenuBar: Boolean;
-
-  procedure _Draw(Color: TColor);
-  begin
-    Canvas.Font.Color := Color;
-    if not Rotated then Windows.DrawText(Canvas.Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else DrawRotatedText(Canvas.Handle, ACaption, R, AFormat);
-  end;
-
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    InMenuBar := (ItemInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR;
-
-    if (Pushed or Selected) and not InMenuBar then OffsetRect(R, 1, 1);
-    C := Font.Color;
-    if C = clNone then C := GetItemTextColor(ItemInfo);
-    _Draw(C);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ArrowColor: array [Boolean] of TColor = (clBtnText, clMenuText);
-var
-  X, Y: Integer;
-  C: TColor;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    X := (Left + Right) div 2 + Ord(Pushed or Selected);
-    Y := (Top + Bottom) div 2 - 1 + Ord(Pushed or Selected);
-    if Enabled then C := ArrowColor[not Boolean(ItemOptions and IO_TOOLBARSTYLE)]
-    else C := DisabledColor;
-    Pen.Color := C;
-    Brush.Color := C;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  DC: HDC;
-  R: TRect;
-  C: TColor;
-  ShowHover, Embedded: Boolean;
-  RL, RR: Integer;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1; RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(DC, R, NearestMixedColor(clWindow, clBtnFace, 16));
-        InflateRect(R, 1, 1);
-        C := NearestMixedColor(clWindow, clBtnShadow, 64);
-      end
-      else
-        C := clBtnFace;
-      RoundFrame(DC, R, RL, RR, C);
-    end;
-
-    if (ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-      begin
-        Canvas.Brush.Color := clHighlight;
-        Canvas.FillRect(R);
-      end;
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-        DitherRect(DC, R, clWindow, clBtnHighlight)
-      else
-      begin
-        if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 128)
-        else C := clBtnHighlight;
-        DitherRect(DC, R, C, clBtnHighlight);
-      end;
-      with Canvas, R do
-      begin
-        PolyLineEx(DC, [Point(Left, Bottom - 2), Point(Left, Top), Point(Right - 1, Top)], clBtnFace);
-      end;
-      InflateRect(R, 1, 1);
-      RoundFrame(DC, R, RL, RR, clBtnShadow);
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      if HoverKind &lt;&gt; hkNone then
-      begin
-        if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-        else C := clBtnFace;
-        InflateRect(R, -1, -1);
-        DitherRect(DC, R, clBtnFace, C);
-        InflateRect(R, 1, 1);
-      end;
-      if not TBXLoColor then C := MixColors(clBtnShadow, clBtnFace, 192)
-      else C := clBtnShadow;
-      RoundFrame(DC, R, RL, RR, C);
-    end;
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-var
-  DC: HDC;
-  BorderColor, C: TColor;
-  SaveIndex: Integer;
-  Sz: TPoint;
-  R, R2: TRect;
-  Size: TSize;
-  CaptionString: string;
-  IsPushed, IsHovered: Boolean;
-begin
-  DC := Canvas.Handle;
-  with Canvas do
-  begin
-    BorderColor := NearestMixedColor(clBtnShadow, clBlack, 127);
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0  then
-    begin
-      R := ARect;
-      FrameRectEx(DC, R, BorderColor, True);
-      Windows.DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-      FrameRectEx(DC, R, clBtnFace, True);
-      FrameRectEx(DC, R, clBtnFace, True);
-
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with ARect, Sz do R2 := Rect(Left + X, Top + Y, Right - X, Bottom - Y);
-      with R2 do ExcludeClipRect(Canvas.Handle, Left, Top, Right, Bottom);
-      FillRectEx(DC, R, GetViewColor(WindowInfo.ViewType));
-      RestoreDC(DC, SaveIndex);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION));
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-
-      Dec(R.Bottom);
-      DrawLineEx(DC, R.Left, R.Bottom, R.Right, R.Bottom, clBtnFace);
-      Dec(R.Bottom);
-      DrawLineEx(DC, R.Left - 1, R.Bottom, R.Right + 1, R.Bottom, DisabledColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION));
-
-      Canvas.Font.Assign(SmCaptionFont);
-      Canvas.Font.Color := clBtnText;
-      CaptionString := string(WindowInfo.Caption);
-      Size := TextExtent(CaptionString);
-      if Size.cx &gt; 0 then Inc(Size.cx, 16);
-
-      if WindowInfo.Active and (Size.cx &lt; R.Right - R.Left) then
-      begin
-        if Size.cx = 0 then DotFill(Canvas, R, clBtnFace, 2)
-        else
-        begin
-          R2 := R;
-          R2.Right := (R.Left + R.Right - Size.cx) div 2;
-          DotFill(Canvas, R2, clBtnFace, 2);
-          R2.Right := R.Right;
-          R2.Left := (R.Left + R.Right + Size.cx) div 2;
-          DotFill(Canvas, R2, clBtnFace, 2);
-          R2.Right := R2.Left;
-          R2.Left := (R.Left + R.Right - Size.cx) div 2;
-          Brush.Color := clBtnFace;
-          FillRect(R2);
-        end;
-      end
-      else FillRectEx(DC, R, clBtnFace);
-
-      InflateRect(R, -2, 0);
-      Dec(R.Top, 2);
-
-      DrawText(DC, PChar(CaptionString), Length(CaptionString), R,
-        DT_SINGLELINE or DT_CENTER or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION));
-      with Windowinfo.FloatingBorderSize do OffsetRect(R, X, Y);
-
-      R.Left := R.Right - (R.Bottom - R.Top) - 1;      
-
-      FillRectEx(DC, R, clBtnFace);
-
-      Dec(R.Bottom, 2);
-      DrawLineEx(DC, R.Left, R.Bottom, R.Right, R.Bottom, DisabledColor);
-      Dec(R.Bottom, 2);
-      Inc(R.Left, 4);
-
-      IsPushed := (CDBS_PRESSED and WindowInfo.CloseButtonState) &lt;&gt; 0;
-      IsHovered := (CDBS_HOT and WindowInfo.CloseButtonState) &lt;&gt; 0;
-
-      if IsPushed or IsHovered then
-      begin
-        RoundFrame(DC, R, 1, 1, clBtnShadow);
-        InflateRect(R, -1, -1);
-        if IsPushed then FillRectEx(DC, R, clBtnHighlight)
-        else
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(DC, R, clBtnFace, C);
-        end;
-        if IsPushed then OffsetRect(R, 1, 1);
-      end;
-
-      DrawButtonBitmap(Canvas, R);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  DC: HDC;
-  R: TRect;
-  E: Boolean;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, DisabledColor, False);
-    end
-    else if Pushed or Selected {or Embedded} or (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, clWindow, False);
-      InflateRect(R, 1, 1);
-      RoundFrame(DC, R, 1, 1, DisabledColor);
-    end
-    else
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, DisabledColor, False);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array [Boolean] of TColor = (clBtnText, clMenuText);
-var
-  DC: HDC;
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  C: TColor;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-      else C := clBtnHighlight;
-      DitherRect(DC, R, C, clBtnHighlight);
-    end
-    else if BtnHot then
-    begin
-      if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 192)
-      else C := clBtnFace;
-      DitherRect(DC, R, clBtnFace, C)
-    end
-    else if Embedded then FillRectEx(DC, R, clBtnFace);
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-//    W := EditFrameWidth;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if BtnHot or BtnPressed then InflateRect(R, -1, -1)
-      else InflateRect(R, -2, -2);
-      if not BtnDisabled then
-      begin
-        PaintEnabled(R, BtnPressed);
-        DrawLineEx(DC, R.Left - 1, R.Top, R.Left - 1, R.Bottom, DisabledColor);
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and (EBSS_UP or EBSS_DOWN)) &lt;&gt; 0;
-      if BtnHot or BtnPressed then InflateRect(R, -1, -1)
-      else InflateRect(R, -2, -2);
-
-      if not BtnDisabled then
-      begin
-        { Upper button }
-        BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-
-        { Lower button }
-        BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0);
-
-        DrawLineEx(DC, R.Left - 1, R.Top, R.Left - 1, R.Bottom, DisabledColor);
-        Y := (R.Top + R.Bottom - 1) div 2;
-        DrawLineEx(DC, R.Left, Y, R.Right, Y, DisabledColor);
-        Y := (R.Top + R.Bottom) div 2;
-        DrawLineEx(DC, R.Left, Y, R.Right, Y, DisabledColor);
-      end;
-
-      { Arrows }
-      if not BtnDisabled then Pen.Color := ArrowColor[not Boolean(ItemOptions and IO_TOOLBARSTYLE)]
-      else Pen.Color := DisabledColor;
-      Brush.Color := Pen.Color;
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (3 * R.Top + R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (R.Top + 3 * R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  DC: HDC;
-  R: TRect;
-  W: Integer;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-  
-  if ItemInfo.Enabled then FillRectEx(DC, R, clWindow);
-  InflateRect(R, -1, -1);
-
-  with EditInfo do if LeftBtnWidth &gt; 0 then Inc(R.Left, LeftBtnWidth - 2);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    R.Left := R.Right - EditInfo.RightBtnWidth - W;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      if Selected or Pushed then OffsetRect(ARect, 1, 1);
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if Selected or Pushed then OffsetRect(ARect, 1, 1)
-      else
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      BlendTBXIcon(Canvas, ARect, ImageList, ImageIndex, 200);
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-    (not Enabled and (HoverKind = hkKeyboardHover)) then
-  begin
-    PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, clHighlight, False, VT_UNKNOWN);
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  DC: HDC;
-  R: TRect;
-  ShowImageOrCheck: Boolean;
-  IsCombo: Boolean;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with ItemInfo do
-  begin
-    ShowImageOrCheck := (ImageWidth &gt; 0) or Selected;
-    IsCombo := ((ItemOptions and IO_COMBO) &lt;&gt; 0);
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-
-    R := ARect;
-    if ShowImageOrCheck then Inc(R.Left, ItemInfo.PopupMargin + MenuImageTextSpace);
-    if IsCombo and Enabled then Dec(R.Right, ArrowWidth + 1);
-
-    PaintMenuItemFrame(Canvas, R, ItemInfo);
-
-    if IsCombo then
-    begin
-      R.Left := ARect.Right - ArrowWidth;
-      R.Right := ARect.Right;
-      if Enabled and (HoverKind &lt;&gt; hkNone) then
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, clHighlight, False, PVT_POPUPMENU)
-      else
-      begin
-        Dec(R.Left);
-        DrawLineEx(DC, R.Left, R.Top, R.Left, R.Bottom, DisabledColor);
-      end;
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then 
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3;
-      if not Enabled then
-      begin
-        if HoverKind = hkKeyboardHover then DrawArrow(clBtnShadow)
-        else DrawArrow(DisabledColor);
-      end
-      else if (HoverKind &lt;&gt; hkNone) {and not IsCombo} then DrawArrow(clHighlightText)
-      else DrawArrow(clMenuText);
-    end;
-
-    if ShowImageOrCheck and ((HoverKind &lt;&gt; hkNone) or Selected) then
-    begin
-      R.Left := ARect.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo);
-begin
-  Canvas.Brush.Color := GetNearestColor(Canvas.Handle, MixColors(clBtnShadow, clBlack, 127));
-  Canvas.FrameRect(R);
-  InflateRect(R, -1, -1);
-
-  if (PopupInfo.ViewType and PVT_LISTBOX) = PVT_LISTBOX then
-  begin
-    Windows.FillRect(Canvas.Handle, R, GetSysColorBrush(COLOR_WINDOW));
-  end
-  else if not USE_FLATMENUS or ((PopupInfo.ViewType and PVT_TOOLBOX) = PVT_TOOLBOX) then
-  begin
-    Windows.DrawEdge(Canvas.Handle, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-    Canvas.Brush.Color := ToolbarColor;
-    Canvas.FillRect(R);
-  end
-  else
-  begin
-    Canvas.Brush.Color := clPopup;
-    Canvas.FillRect(R);
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  DC: HDC;
-begin
-  DC := Canvas.Handle;
-  with ItemInfo, ARect do if Enabled then
-  begin
-    if Horizontal then
-    begin
-      Top := (Top + Bottom) div 2;
-      DrawLineEx(DC, Left + 1, Top, Right - 1, Top, DisabledColor)
-    end
-    else
-    begin
-      Left := (Left + Right) div 2;
-      DrawLineEx(DC, Left, Top + 1, Left, Bottom - 1, DisabledColor);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo);
-var
-  Sz: Integer;
-  R2: TRect;
-  C, SaveColor: TColor;
-  SaveStyle: TBrushStyle;
-  BtnVisible, Horz, CloseButtondown, CloseButtonHover: Boolean;
-begin
-  with Canvas do
-  begin
-    { Border }
-    SaveColor := Brush.Color;
-    SaveStyle := Brush.Style;
-    if ToolbarInfo.BorderStyle = bsSingle then
-      Windows.DrawEdge(Canvas.Handle, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-    FillRect(R);
-    Inflaterect(R, -1, -1);
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then R.Right := R.Left + Sz
-    else R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Left, 1);
-        Inc(R2.Right, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 1);
-          Dec(R2.Right, 4);
-        end;
-      end
-      else
-      begin
-        Dec(R2.Top, 1);
-        Inc(R2.Bottom, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 1);
-          Dec(R2.Bottom, 4);
-        end;
-      end;
-      InflateRect(R2, -1, -1);
-      if SaveStyle = bsClear then DotFill(Canvas, R2, clNone, 1)
-      else DotFill(Canvas, R2, SaveColor, 1);
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      CloseButtonDown := (ToolbarInfo.CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (ToolbarInfo.CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := GetTBXDockedCloseButtonRect(ToolbarInfo);
-      if Horz then OffsetRect(R2, -1, 0)
-      else Offsetrect(R2, 0, -1);
-
-      InflateRect(R2, -1, -1);
-      if CloseButtonDown or CloseButtonHover then
-      begin
-        if CloseButtonDown then
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-          else C := clBtnHighlight;
-          DitherRect(Canvas.Handle, R2, clBtnHighlight, C);
-        end
-        else
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(Canvas.Handle, R2, clBtnFace, C);
-        end;
-
-        InflateRect(R2, 1, 1);
-        if not TBXLoColor or not CloseButtonDown then
-          Pen.Color := NearestMixedColor(clBtnShadow, clBtnFace, 191)
-        else
-          Pen.Color := clBtnShadow;
-        RoundFrame(Canvas.Handle, R2, 1, 1, Pen.Color);
-      end;
-
-      if CloseButtonDown then OffsetRect(R2, 1, 1);
-      DrawButtonBitmap(Canvas, R2);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2 + Ord(ItemInfo.Pushed);
-    Y := (Top + Bottom - StockImgList.Height - 1) div 2 + Ord(ItemInfo.Pushed);
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  DrawGlyph(Canvas.Handle, X, Y, StockImgList, Index, clBtnText);
-end;
-
-function TTBXMonaiTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXMonaiTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-end;
-
-destructor TTBXMonaiTheme.Destroy;
-begin
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXMonaiTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-begin
-  // this theme does not support dock painting
-end;
-
-procedure TTBXMonaiTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect;
-  const DockPanelInfo: TTBXDockPanelInfo);
-var
-  DC: HDC;
-  Sz: Integer;
-  R2: TRect;
-  Flags: Integer;
-  CloseButtonDown, CloseButtonHover: Boolean;
-  C: TColor;
-  TextSize, TextSize2: TSize;
-begin
-  DC := Canvas.Handle;
-  with Canvas, DockPanelInfo do
-  begin
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-
-    { Border }
-    FrameRectEx(DC, R, ToolbarColor, True);
-    R2 := R;
-    if ShowCaption then
-      if IsVertical then Inc(R2.Top, Sz)
-      else Inc(R2.Left, Sz);
-    Brush.Color := DockPanelInfo.EffectiveColor;
-    FrameRect(R2);
-
-    if not ShowCaption then Exit;
-
-    C := DockPanelInfo.EffectiveColor;
-    Brush.Color := C;
-
-    R2 := R;
-    Pen.Color := NearestMixedColor(clBtnShadow, clBtnFace,  128);
-    if IsVertical then R.Bottom := R.Top + Sz
-    else R.Right := R.Left + Sz;
-    Windows.DrawEdge(Handle, R, BDR_RAISEDINNER, BF_RECT or BF_MIDDLE or BF_ADJUST);
-
-    { Close button }
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      CloseButtonDown := (CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := R;
-      Brush.Color := clBtnFace;
-
-      if IsVertical then
-      begin
-        Dec(R2.Right);
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Top := R2.Bottom - Sz + 2;
-        R.Bottom := R2.Top;
-      end;
-
-      InflateRect(R2, -2, -2);
-      if CloseButtonDown or CloseButtonHover then
-      begin
-        if CloseButtonDown then
-        begin
-          if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 126)
-          else C := clBtnHighlight;
-          DitherRect(DC, R2, clBtnHighlight, C);
-        end
-        else
-        begin
-          if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(DC, R2, clBtnFace, C);
-        end;
-
-        InflateRect(R2, 1, 1);
-        if not TBXLoColor or not CloseButtonDown then
-          C := NearestMixedColor(clBtnShadow, clBtnFace, 191)
-        else
-          C := clBtnShadow;
-
-        RoundFrame(DC, R2, 1, 1, C);
-      end;
-
-      if CloseButtonDown then OffsetRect(R2, 1, 1);
-      DrawButtonBitmap(Canvas, R2);
-    end;
-
-    { Caption }
-    Brush.Color := ToolbarColor;
-    if IsVertical then InflateRect(R, -1, 0)
-    else Inflaterect(R, 0, -1);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-
-    if IsVertical then
-    begin
-      TextSize := TextExtent(string(Caption));
-      if TextSize.Cx &gt; 0 then Inc(TextSize.Cx, 12);
-      if TextSize.Cx &lt; R.Right - R.Left then
-      begin
-        R2 := R;
-        Inc(R2.Top);
-        if TextSize.Cx = 0 then DotFill(Canvas, R2, clBtnFace, 1)
-        else
-        begin
-          R2.Right := (R.Left + R.Right - TextSize.cx) div 2;
-          Inc(R2.Left);
-          DotFill(Canvas, R2, clBtnFace, 1);
-          R2.Right := R.Right;
-          R2.Left := (R.Left + R.Right + TextSize.cx) div 2;
-          DotFill(Canvas, R2, clBtnFace, 1);
-          R2.Right := R2.Left;
-          R2.Left := (R.Left + R.Right - TextSize.cx) div 2;
-          FillRectEx(DC, R2, clBtnFace);
-        end;
-      end;
-    end
-    else
-    begin
-      TextSize2 := TextExtent(string(Caption));
-      TextSize.cx := TextSize2.cy;
-      TextSize.cy := TextSize2.cx;
-      if TextSize.cy &gt; 0 then Inc(TextSize.cy, 12);
-      if TextSize.cy &lt; R.Bottom - R.Top then
-      begin
-        R2 := R;
-        Inc(R2.Left);
-        if TextSize.cy = 0 then DotFill(Canvas, R2, clBtnFace, 1)
-        else
-        begin
-          R2.Bottom := (R.Top + R.Bottom - TextSize.cy) div 2;
-          Inc(R2.Top);
-          DotFill(Canvas, R2, clBtnFace, 1);
-          R2.Bottom := R.Bottom;
-          R2.Top := (R.Top + R.Bottom + TextSize.cy) div 2;
-          DotFill(Canvas, R2, clBtnFace, 1);
-          R2.Bottom := R2.Top;
-          R2.Top := (R.Top + R.Bottom - TextSize.cy) div 2;
-          FillRectEx(DC, R2, clBtnFace);
-        end;
-      end;
-    end;
-
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_CENTER or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX;
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  DC: HDC;
-  R: TRect;
-  X, Y, Sz: Integer;
-  C: Longword;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then DitherRect(DC, R, clBtnFace, clBtnHighlight)
-  else FillRectEx(DC, R, clBtnFace);
-  InflateRect(R, 1, 1);
-  RoundFrame(DC, R, 1, 1, NearestMixedColor(clWindow, clBtnShadow, 64));
-  C := GetSysColor(COLOR_BTNFACE);
-  with R do
-  begin
-    SetPixelV(DC, Left, Top, C);
-    SetPixelV(DC, Left, Top, C);
-    SetPixelV(DC, Right + 1, Top, C);
-    SetPixelV(DC, Right + 1, Bottom + 1, C);
-    SetPixelV(DC, Left, Bottom + 1, C);
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  Canvas.Pen.Color := clBtnText;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-  C: TColor;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then Canvas.Pen.Color := clBtnText
-    else if Boolean(State and PFS_HOT) then Canvas.Pen.Color := clBtnText
-    else Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-      else C := clBtnHighlight;
-      Canvas.Brush.Bitmap := AllocPatternBitmap(C, clBtnHighlight);
-    end
-    else if Boolean(State and PFS_HOT) then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-      else C := clBtnFace;
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clBtnFace, C);
-    end
-    else if Boolean(State and PFS_MIXED) then Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then Result := clBtnFace
-    else if Boolean(State and PFS_MIXED) then Result := clBtnShadow
-    else Result := clBtnText;
-  end;
-
-begin
-  with Canvas do case Kind of
-    PFC_CHECKBOX:
-      begin
-        SetupPen;
-        SetupBrush;
-        InflateRect(R, -1, -1);
-        with R do Rectangle(Left, Top, Right, Bottom);
-        Pen.Style := psSolid;
-        Brush.Style := bsSolid;
-
-        if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-        begin
-          X := (R.Left + R.Right) div 2 - 1;
-          Y := (R.Top + R.Bottom) div 2 + 1;
-          Pen.Color := TextColor;
-          Brush.Color := Pen.Color;
-          Polygon([Point(X-2, Y), Point(X, Y+2), Point(X+4, Y-2),
-            Point(X+4, Y-4), Point(X, Y), Point(X-2, Y-2), Point(X-2, Y)]);
-        end;
-      end;
-    PFC_RADIOBUTTON:
-      begin
-        SetupPen;
-        SetupBrush;
-        InflateRect(R, -1, -1);
-        with R do Ellipse(Left, Top, Right, Bottom);
-        Pen.Style := psSolid;
-        Brush.Style := bsSolid;
-        if Boolean(State and PFS_CHECKED) then
-        begin
-          InflateRect(R, -3, -3);
-          Pen.Color := TextColor;
-          Brush.Color := Pen.Color;
-          with R do Ellipse(Left, Top, Right, Bottom);
-        end;
-      end;
-  else
-    inherited;
-  end;
-end;
-
-procedure TTBXMonaiTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-var
-  Lo: TColor;
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, clBtnFace);
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, DisabledColor);
-        end;
-      SBP_GRIPPER:
-        begin
-          Lo := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          with R do begin
-            Pixels[Right - 12, Bottom - 4]:= Lo;
-            Pixels[Right - 12, Bottom - 3]:= Lo;
-            Pixels[Right - 11, Bottom - 4]:= Lo;
-            Pixels[Right - 11, Bottom - 3]:= Lo;
-
-            Pixels[Right - 8, Bottom - 4]:= Lo;
-            Pixels[Right - 8, Bottom - 3]:= Lo;
-            Pixels[Right - 7, Bottom - 4]:= Lo;
-            Pixels[Right - 7, Bottom - 3]:= Lo;
-
-            Pixels[Right - 4, Bottom - 4]:= Lo;
-            Pixels[Right - 4, Bottom - 3]:= Lo;
-            Pixels[Right - 3, Bottom - 4]:= Lo;
-            Pixels[Right - 3, Bottom - 3]:= Lo;
-
-            Pixels[Right - 8, Bottom - 8]:= Lo;
-            Pixels[Right - 8, Bottom - 7]:= Lo;
-            Pixels[Right - 7, Bottom - 8]:= Lo;
-            Pixels[Right - 7, Bottom - 7]:= Lo;
-
-            Pixels[Right - 4, Bottom - 8]:= Lo;
-            Pixels[Right - 4, Bottom - 7]:= Lo;
-            Pixels[Right - 3, Bottom - 8]:= Lo;
-            Pixels[Right - 3, Bottom - 7]:= Lo;
-
-            Pixels[Right - 4, Bottom - 12]:= Lo;
-            Pixels[Right - 4, Bottom - 11]:= Lo;
-            Pixels[Right - 3, Bottom - 12]:= Lo;
-            Pixels[Right - 3, Bottom - 11]:= Lo;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXMonaiTheme.SetupColorCache;
-begin
-  DockPanelColor := NearestMixedColor(clBtnFace, clWindow, 64);
-  if not TBXLoColor then DisabledColor := MixColors(clBtnShadow, clBtnFace, 210)
-  else DisabledColor := clBtnShadow;
-  ToolbarColor := clBtnFace;
-end;
-
-procedure TTBXMonaiTheme.GetMargins(MarginID: Integer; out Margins: TTBXMargins);
-begin
-  inherited;
-  if MarginID = MID_MENUITEM then
-  begin
-    Margins.TopHeight := 2;
-    Margins.BottomHeight := 2;
-  end;
-end;
-
-initialization
-
-RegisterTBXTheme('Monai', TTBXMonaiTheme);
-
-end.

Deleted: Lobby/TASClient/Themes/TBXMonaiXPTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXMonaiXPTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXMonaiXPTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,1490 +0,0 @@
-unit TBXMonaiXPTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Monai' TBX theme &#169; 2004 Roy Magne Klever
-//
-//  Last updated: 28.08.2004
-
-interface
-
-{$I TB2Ver.inc}
-{$I TBX.inc}
-
-uses
-  Windows, Messages, Graphics, TBXThemes, TBXDefaultTheme, ImgList;
-
-type
-  TTBXMonaiXPTheme = class(TTBXDefaultTheme)
-  protected
-    DockPanelColor: TColor;
-    DisabledColor: TColor;
-    procedure SetupColorCache; override;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access, etc. }
-    function  GetBooleanMetrics(Index: Integer): Boolean; override;
-    function  GetIntegerMetrics(Index: Integer): Integer; override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function  GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function  GetViewColor(AViewType: Integer): TColor; override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect; DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect; ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer); override;
-  end;
-
-implementation
-
-uses TBXUtils, TB2Item, TB2Common, Classes, Controls, Forms, Commctrl;
-
-var
-  StockImgList: TImageList;
-  StockPatternBitmap: TBitmap;
-  CounterLock: Integer = 0;
-
-procedure InitializeStock;
-begin
-  StockPatternBitmap := TBitmap.Create;
-  StockPatternBitmap.Width := 8;
-  StockPatternBitmap.Height := 8;
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0, clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockPatternBitmap.Free;
-  StockImgList.Free;
-end;
-
-procedure CreateDottedPattern(Color: TColor);
-var
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-begin
-  with StockPatternBitmap.Canvas do
-  begin
-    Brush.Color := Color;
-    Hi1:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 128));
-    Lo1:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 96));
-    Hi2:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-    Lo2:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 8));
-
-    Hi3:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-    Lo3:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-    Hi4:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-    FillRect(Rect(0, 0, 8, 8));
-    Pixels[0, 0]:= Hi1;
-    Pixels[0, 1]:= Hi2;
-    Pixels[1, 0]:= Lo1;
-    Pixels[1, 1]:= Lo2;
-    Pixels[1, 2]:= Hi4;
-    Pixels[2, 2]:= Hi3;
-    Pixels[2, 1]:= Lo3;
-
-    Pixels[4, 0]:= Hi1;
-    Pixels[4, 1]:= Hi2;
-    Pixels[5, 0]:= Lo1;
-    Pixels[5, 1]:= Lo2;
-    Pixels[5, 2]:= Hi4;
-    Pixels[6, 2]:= Hi3;
-    Pixels[6, 1]:= Lo3;
-
-    Pixels[0, 4]:= Hi1;
-    Pixels[0, 5]:= Hi2;
-    Pixels[1, 4]:= Lo1;
-    Pixels[1, 5]:= Lo2;
-    Pixels[1, 6]:= Hi4;
-    Pixels[2, 5]:= Hi3;
-    Pixels[2, 6]:= Lo3;
-
-    Pixels[4, 4]:= Hi1;
-    Pixels[4, 5]:= Hi2;
-    Pixels[5, 4]:= Lo1;
-    Pixels[5, 5]:= Lo2;
-    Pixels[5, 6]:= Hi4;
-    Pixels[6, 5]:= Hi3;
-    Pixels[6, 6]:= Lo3;
-  end;
-end;
-
-procedure DotFill(Canvas: TCanvas; R: TRect; Color: TColor; Border: Integer);
-var
-  DC: HDC;
-  Pt: TPoint;
-  W, H, I, J: Integer;
-  Brush: HBRUSH;
-begin
-  if Color &lt;&gt; clNone then
-  begin
-    CreateDottedPattern(Color);
-    Canvas.Brush.Style := bsSolid;
-    Canvas.Brush.Color := Color;
-    Canvas.FillRect(R);
-  end;
-  InflateRect(R, -Border, -Border);
-  W := R.Right - R.Left;
-  H := R.Bottom - R.Top;
-  W := ((W - 2) div 4) * 4 + 2;
-  H := ((H - 2) div 4) * 4 + 2;
-  R.Left := (R.Right + R.Left - W - 1) div 2;
-  R.Right := R.Left + W;
-  R.Top := (R.Top + R.Bottom - H - 1) div 2;
-  R.Bottom := R.Top + H;
-
-  if Color &lt;&gt; clNone then
-  begin
-    DC := Canvas.Handle;
-    Brush := CreatePatternBrush(StockPatternBitmap.Handle);
-    GetWindowOrgEx(DC, Pt);
-    SetBrushOrgEx(DC, R.Left - Pt.X, R.Top - Pt.Y, nil);
-    Windows.FillRect(DC, R, Brush);
-    DeleteObject(Brush);
-  end
-  else
-  begin
-    for J := 0 to (R.Bottom - R.Top - 1) div 4 do
-      for I := 0 to (R.Right - R.Left - 1) div 4 do
-        begin
-          Canvas.Pixels[R.Left + I * 4 + 1, R.Top + J * 4 + 1] := clBtnHighlight;
-          Canvas.Pixels[R.Left + I * 4 + 2, R.Top + J * 4 + 2] := clBtnShadow;
-        end;
-  end;
-end;
-
-procedure DotFillNew(Canvas: TCanvas; R: TRect; Color: TColor; Border: Integer);
-var
-  DC: HDC;
-  Pt: TPoint;
-  Brush: HBRUSH;
-begin
-  CreateDottedPattern(Color);
-  Canvas.Brush.Color := Color;
-  Canvas.FillRect(R);
-  InflateRect(R, -Border, -Border);
-  DC := Canvas.Handle;
-  Brush := CreatePatternBrush(StockPatternBitmap.Handle);
-  GetWindowOrgEx(DC, Pt);
-  SetBrushOrgEx(DC, R.Left - Pt.X, R.Top - Pt.Y, nil);
-  Windows.FillRect(DC, R, Brush);
-  DeleteObject(Brush);
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect);
-const
-  Pattern: array [0..15] of Byte = ($C6, 0, $6C, 0, $38, 0, $38, 0, $6C, 0, $C6, 0, 0, 0, 0, 0);
-begin
-  DrawGlyph(Canvas.Handle, R, 7, 6, Pattern[0], clBtnText);
-end;
-
-procedure RoundFrame(DC: HDC; R: TRect; RL, RR: Integer; C: TColor);
-var
-  P: array [0..8] of TPoint;
-  OldPen, Pen: HPen;
-begin
-  if C &lt; 0 then C := GetSysColor(C and $FF);
-  with R do
-  begin
-    Dec(Right); Dec(Bottom);
-    with P[0] do begin X := Left + RL; Y := Top; end;
-    with P[1] do begin X := Right - RR; Y := Top; end;
-    with P[2] do begin X := Right; Y := Top + RR; end;
-    with P[3] do begin X := Right; Y := Bottom - RR; end;
-    with P[4] do begin X := Right - RR; Y := Bottom; end;
-    with P[5] do begin X := Left + RL; Y := Bottom; end;
-    with P[6] do begin X := Left; Y := Bottom - RL; end;
-    with P[7] do begin X := Left; Y := Top + RL; end;
-    with P[8] do begin X := Left + RL; Y := Top; end;
-    Pen := CreatePen(PS_SOLID, 1, C);
-    OldPen := SelectObject(DC, Pen);
-    Windows.Polyline(DC, P[0], 9);
-    SelectObject(DC, OldPen);
-    DeleteObject(Pen);
-    Inc(Right); Inc(Bottom);
-  end;
-end;
-
-{ TTBXMonaiXPTheme }
-
-function TTBXMonaiXPTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_EDITHEIGHTEVEN:            Result := False;
-    TMB_PAINTDOCKBACKGROUND:       Result := False;
-    TMB_SOLIDTOOLBARNCAREA:        Result := False;
-    TMB_SOLIDTOOLBARCLIENTAREA:    Result := False;
-  else
-    Result := inherited GetBooleanMetrics(Index);
-  end;
-end;
-
-function TTBXMonaiXPTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := ToolbarColor;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then Result := clBtnFace
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_POPUPMENU) = PVT_POPUPMENU then Result := clPopup
-    else if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then Result := clWindow
-    else if (AViewType and PVT_TOOLBOX) = PVT_TOOLBOX then Result := clWindow
-    else if (AViewType and PVT_CHEVRONMENU) = PVT_CHEVRONMENU then Result := clPopup;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then Result := DockPanelColor;
-end;
-
-function TTBXMonaiXPTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := inherited GetItemColor(ItemInfo);
-end;
-
-function TTBXMonaiXPTheme.GetIntegerMetrics(Index: Integer): Integer;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH:         Result := 12;
-    TMI_MENU_MDI_DW:                 Result := 1;
-    TMI_MENU_MDI_DH:                 Result := 2;
-    TMI_EDIT_FRAMEWIDTH:             Result := 2;
-    TMI_EDIT_TEXTMARGINHORZ:         Result := 2;
-    TMI_EDIT_TEXTMARGINVERT:         Result := 1;
-    TMI_EDIT_BTNWIDTH:               Result := 14;
-  else
-    Result := inherited GetIntegerMetrics(Index);
-  end;
-end;
-
-function TTBXMonaiXPTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-var
-  InMenuBar, ToolbarStyle, ShowInactive: Boolean;
-begin
-  with ItemInfo do
-  begin
-    InMenuBar := (ItemInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR;
-    ToolbarStyle := Boolean(ItemOptions and IO_TOOLBARSTYLE);
-    ShowInactive := InMenubar and not Boolean(ItemOptions and IO_APPACTIVE);
-
-    if not ToolbarStyle and not Enabled and (HoverKind = hkKeyboardHover) then Result := clBtnShadow
-    else if not Enabled then Result := DisabledColor
-    else if not ToolbarStyle or InMenuBar then
-    begin
-      if HoverKind &lt;&gt; hkNone then Result := clHighlightText
-      else if ShowInactive then Result := clGrayText
-      else Result := clMenuText
-    end
-    else Result := clBtnText;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array [Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array [Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-  Sz: Integer;
-begin
-  Sz := 0;
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]);
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]);
-      Exit;
-    end
-    else Sz := 2;
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_LISTBOX) = PVT_LISTBOX then Sz := 2
-    else Sz := 3;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]);
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]);
-      Exit;
-    end
-    else Sz := 2;
-  end;
-  Border.X := Sz;
-  Border.Y := Sz;
-end;
-
-procedure TTBXMonaiXPTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-begin
- if not Transparent then
-  begin
-    Brush:= CreateSolidBrush(ColorToRGB(AColor));
-    IntersectRect(R, ARect, AClipRect);
-    FillRect(Canvas.Handle, R, Brush);
-    DeleteObject(Brush);
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintCaption(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-  InMenuBar: Boolean;
-
-  procedure _Draw(Color: TColor);
-  begin
-    Canvas.Font.Color := Color;
-    if not Rotated then Windows.DrawText(Canvas.Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else DrawRotatedText(Canvas.Handle, ACaption, R, AFormat);
-  end;
-
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    InMenuBar := (ItemInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR;
-
-    if (Pushed or Selected) and not InMenuBar then OffsetRect(R, 1, 1);
-    C := Font.Color;
-    if C = clNone then C := GetItemTextColor(ItemInfo);
-    _Draw(C);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ArrowColor: array [Boolean] of TColor = (clBtnText, clMenuText);
-var
-  X, Y: Integer;
-  C: TColor;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    X := (Left + Right) div 2 + Ord(Pushed or Selected);
-    Y := (Top + Bottom) div 2 - 1 + Ord(Pushed or Selected);
-    if Enabled then C := ArrowColor[not Boolean(ItemOptions and IO_TOOLBARSTYLE)]
-    else C := DisabledColor;
-    Pen.Color := C;
-    Brush.Color := C;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  DC: HDC;
-  R: TRect;
-  C: TColor;
-  ShowHover, Embedded: Boolean;
-  RL, RR: Integer;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1; RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(DC, R, NearestMixedColor(clWindow, clBtnFace, 16));
-        InflateRect(R, 1, 1);
-        C := NearestMixedColor(clWindow, clBtnShadow, 64);
-      end
-      else
-        C := clBtnFace;
-      RoundFrame(DC, R, RL, RR, C);
-    end;
-
-    if (ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-      begin
-        Canvas.Brush.Color := clHighlight;
-        Canvas.FillRect(R);
-      end;
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-        DitherRect(DC, R, clWindow, clBtnHighlight)
-      else
-      begin
-        if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 128)
-        else C := clBtnHighlight;
-        DitherRect(DC, R, C, clBtnHighlight);
-      end;
-      with Canvas, R do
-      begin
-        PolyLineEx(DC, [Point(Left, Bottom - 2), Point(Left, Top), Point(Right - 1, Top)], clBtnFace);
-      end;
-      InflateRect(R, 1, 1);
-      RoundFrame(DC, R, RL, RR, clBtnShadow);
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      if HoverKind &lt;&gt; hkNone then
-      begin
-        if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-        else C := clBtnFace;
-        InflateRect(R, -1, -1);
-        DitherRect(DC, R, clBtnFace, C);
-        InflateRect(R, 1, 1);
-      end;
-      if not TBXLoColor then C := MixColors(clBtnShadow, clBtnFace, 192)
-      else C := clBtnShadow;
-      RoundFrame(DC, R, RL, RR, C);
-    end;
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-var
-  DC: HDC;
-  BorderColor, C: TColor;
-  SaveIndex: Integer;
-  Sz: TPoint;
-  R, R2: TRect;
-  Size: TSize;
-  CaptionString: string;
-  IsPushed, IsHovered: Boolean;
-begin
-  DC := Canvas.Handle;
-  with Canvas do
-  begin
-    BorderColor := NearestMixedColor(clBtnShadow, clBlack, 127);
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0  then
-    begin
-      R := ARect;
-      FrameRectEx(DC, R, BorderColor, True);
-      Windows.DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-      FrameRectEx(DC, R, clBtnFace, True);
-      FrameRectEx(DC, R, clBtnFace, True);
-
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with ARect, Sz do R2 := Rect(Left + X, Top + Y, Right - X, Bottom - Y);
-      with R2 do ExcludeClipRect(Canvas.Handle, Left, Top, Right, Bottom);
-      FillRectEx(DC, R, GetViewColor(WindowInfo.ViewType));
-      RestoreDC(DC, SaveIndex);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION));
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-
-      Dec(R.Bottom);
-      DrawLineEx(DC, R.Left, R.Bottom, R.Right, R.Bottom, clBtnFace);
-      Dec(R.Bottom);
-      DrawLineEx(DC, R.Left - 1, R.Bottom, R.Right + 1, R.Bottom, DisabledColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION));
-
-      Canvas.Font.Assign(SmCaptionFont);
-      Canvas.Font.Color := clBtnText;
-      CaptionString := string(WindowInfo.Caption);
-      Size := TextExtent(CaptionString);
-      if Size.cx &gt; 0 then Inc(Size.cx, 16);
-
-      if WindowInfo.Active and (Size.cx &lt; R.Right - R.Left) then
-      begin
-        if Size.cx = 0 then DotFill(Canvas, R, clBtnFace, 2)
-        else
-        begin
-          R2 := R;
-          R2.Right := (R.Left + R.Right - Size.cx) div 2;
-          DotFill(Canvas, R2, clBtnFace, 2);
-          R2.Right := R.Right;
-          R2.Left := (R.Left + R.Right + Size.cx) div 2;
-          DotFill(Canvas, R2, clBtnFace, 2);
-          R2.Right := R2.Left;
-          R2.Left := (R.Left + R.Right - Size.cx) div 2;
-          Brush.Color := clBtnFace;
-          FillRect(R2);
-        end;
-      end
-      else FillRectEx(DC, R, clBtnFace);
-
-      InflateRect(R, -2, 0);
-      Dec(R.Top, 2);
-
-      DrawText(DC, PChar(CaptionString), Length(CaptionString), R,
-        DT_SINGLELINE or DT_CENTER or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION));
-      with Windowinfo.FloatingBorderSize do OffsetRect(R, X, Y);
-
-      R.Left := R.Right - (R.Bottom - R.Top) - 1;      
-
-      FillRectEx(DC, R, clBtnFace);
-
-      Dec(R.Bottom, 2);
-      DrawLineEx(DC, R.Left, R.Bottom, R.Right, R.Bottom, DisabledColor);
-      Dec(R.Bottom, 2);
-      Inc(R.Left, 4);
-
-      IsPushed := (CDBS_PRESSED and WindowInfo.CloseButtonState) &lt;&gt; 0;
-      IsHovered := (CDBS_HOT and WindowInfo.CloseButtonState) &lt;&gt; 0;
-
-      if IsPushed or IsHovered then
-      begin
-        RoundFrame(DC, R, 1, 1, clBtnShadow);
-        InflateRect(R, -1, -1);
-        if IsPushed then FillRectEx(DC, R, clBtnHighlight)
-        else
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(DC, R, clBtnFace, C);
-        end;
-        if IsPushed then OffsetRect(R, 1, 1);
-      end;
-
-      DrawButtonBitmap(Canvas, R);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  DC: HDC;
-  R: TRect;
-  E: Boolean;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, DisabledColor, False);
-    end
-    else if Pushed or Selected {or Embedded} or (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, clWindow, False);
-      InflateRect(R, 1, 1);
-      RoundFrame(DC, R, 1, 1, DisabledColor);
-    end
-    else
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, DisabledColor, False);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array [Boolean] of TColor = (clBtnText, clMenuText);
-var
-  DC: HDC;
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  C: TColor;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-      else C := clBtnHighlight;
-      DitherRect(DC, R, C, clBtnHighlight);
-    end
-    else if BtnHot then
-    begin
-      if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 192)
-      else C := clBtnFace;
-      DitherRect(DC, R, clBtnFace, C)
-    end
-    else if Embedded then FillRectEx(DC, R, clBtnFace);
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-//    W := EditFrameWidth;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if BtnHot or BtnPressed then InflateRect(R, -1, -1)
-      else InflateRect(R, -2, -2);
-      if not BtnDisabled then
-      begin
-        PaintEnabled(R, BtnPressed);
-        DrawLineEx(DC, R.Left - 1, R.Top, R.Left - 1, R.Bottom, DisabledColor);
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and (EBSS_UP or EBSS_DOWN)) &lt;&gt; 0;
-      if BtnHot or BtnPressed then InflateRect(R, -1, -1)
-      else InflateRect(R, -2, -2);
-
-      if not BtnDisabled then
-      begin
-        { Upper button }
-        BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-
-        { Lower button }
-        BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0);
-
-        DrawLineEx(DC, R.Left - 1, R.Top, R.Left - 1, R.Bottom, DisabledColor);
-        Y := (R.Top + R.Bottom - 1) div 2;
-        DrawLineEx(DC, R.Left, Y, R.Right, Y, DisabledColor);
-        Y := (R.Top + R.Bottom) div 2;
-        DrawLineEx(DC, R.Left, Y, R.Right, Y, DisabledColor);
-      end;
-
-      { Arrows }
-      if not BtnDisabled then Pen.Color := ArrowColor[not Boolean(ItemOptions and IO_TOOLBARSTYLE)]
-      else Pen.Color := DisabledColor;
-      Brush.Color := Pen.Color;
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (3 * R.Top + R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (R.Top + 3 * R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  DC: HDC;
-  R: TRect;
-  W: Integer;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-  
-  if ItemInfo.Enabled then FillRectEx(DC, R, clWindow);
-  InflateRect(R, -1, -1);
-
-  with EditInfo do if LeftBtnWidth &gt; 0 then Inc(R.Left, LeftBtnWidth - 2);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    R.Left := R.Right - EditInfo.RightBtnWidth - W;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      if Selected or Pushed then OffsetRect(ARect, 1, 1);
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if Selected or Pushed then OffsetRect(ARect, 1, 1)
-      else
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      BlendTBXIcon(Canvas, ARect, ImageList, ImageIndex, 200);
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-    (not Enabled and (HoverKind = hkKeyboardHover)) then
-  begin
-    PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, clHighlight, False, VT_UNKNOWN);
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  DC: HDC;
-  R: TRect;
-  ShowImageOrCheck: Boolean;
-  IsCombo: Boolean;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with ItemInfo do
-  begin
-    ShowImageOrCheck := (ImageWidth &gt; 0) or Selected;
-    IsCombo := ((ItemOptions and IO_COMBO) &lt;&gt; 0);
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-
-    R := ARect;
-    if ShowImageOrCheck then Inc(R.Left, ItemInfo.PopupMargin + MenuImageTextSpace);
-    if IsCombo and Enabled then Dec(R.Right, ArrowWidth + 1);
-
-    PaintMenuItemFrame(Canvas, R, ItemInfo);
-
-    if IsCombo then
-    begin
-      R.Left := ARect.Right - ArrowWidth;
-      R.Right := ARect.Right;
-      if Enabled and (HoverKind &lt;&gt; hkNone) then
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, clHighlight, False, PVT_POPUPMENU)
-      else
-      begin
-        Dec(R.Left);
-        DrawLineEx(DC, R.Left, R.Top, R.Left, R.Bottom, DisabledColor);
-      end;
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then 
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3;
-      if not Enabled then
-      begin
-        if HoverKind = hkKeyboardHover then DrawArrow(clBtnShadow)
-        else DrawArrow(DisabledColor);
-      end
-      else if (HoverKind &lt;&gt; hkNone) {and not IsCombo} then DrawArrow(clHighlightText)
-      else DrawArrow(clMenuText);
-    end;
-
-    if ShowImageOrCheck and ((HoverKind &lt;&gt; hkNone) or Selected) then
-    begin
-      R.Left := ARect.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo);
-begin
-  Canvas.Brush.Color := GetNearestColor(Canvas.Handle, MixColors(clBtnShadow, clBlack, 127));
-  Canvas.FrameRect(R);
-  InflateRect(R, -1, -1);
-
-  if (PopupInfo.ViewType and PVT_LISTBOX) = PVT_LISTBOX then
-  begin
-    Windows.FillRect(Canvas.Handle, R, GetSysColorBrush(COLOR_WINDOW));
-  end
-  else if not USE_FLATMENUS or ((PopupInfo.ViewType and PVT_TOOLBOX) = PVT_TOOLBOX) then
-  begin
-    Canvas.Brush.Color := DockPanelColor;  // ToolbarColor;
-    Canvas.FillRect(R);
-  end
-  else
-  begin
-    Canvas.Brush.Color := clPopup;
-    Canvas.FillRect(R);
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  DC: HDC;
-begin
-  DC := Canvas.Handle;
-  with ItemInfo, ARect do
-  if Enabled then
-  begin
-    if Horizontal then
-    begin
-      Top := Bottom div 2;
-      DrawLineEx(DC, Left + 1, Top, Right - 1, Top, DisabledColor)
-    end
-    else if enabled then
-    begin
-      Left := Right div 2;
-      DrawLineEx(DC, Left, Top + 1, Left, Bottom - 1, DisabledColor);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo);
-var
-  Sz: Integer;
-  R2: TRect;
-  C, SaveColor: TColor;
-  SaveStyle: TBrushStyle;
-  BtnVisible, Horz, CloseButtondown, CloseButtonHover: Boolean;
-begin
-  with Canvas do
-  begin
-    { Border }
-    SaveColor := Brush.Color;
-    SaveStyle := Brush.Style;
-    if ToolbarInfo.BorderStyle = bsSingle then
-      Windows.DrawEdge(Canvas.Handle, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-    FillRect(R);
-    Inflaterect(R, -1, -1);
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then R.Right := R.Left + Sz
-    else R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Left, 1);
-        Inc(R2.Right, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 1);
-          Dec(R2.Right, 4);
-        end;
-      end
-      else
-      begin
-        Dec(R2.Top, 1);
-        Inc(R2.Bottom, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 1);
-          Dec(R2.Bottom, 4);
-        end;
-      end;
-      InflateRect(R2, -1, -1);
-      if SaveStyle = bsClear then DotFillNew(Canvas, R2, clNone, 1)
-      else DotFillNew(Canvas, R2, SaveColor, 1);
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      CloseButtonDown := (ToolbarInfo.CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (ToolbarInfo.CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := GetTBXDockedCloseButtonRect(ToolbarInfo);
-      if Horz then OffsetRect(R2, -1, 0)
-      else Offsetrect(R2, 0, -1);
-
-      InflateRect(R2, -1, -1);
-      if CloseButtonDown or CloseButtonHover then
-      begin
-        if CloseButtonDown then
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-          else C := clBtnHighlight;
-          DitherRect(Canvas.Handle, R2, clBtnHighlight, C);
-        end
-        else
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(Canvas.Handle, R2, clBtnFace, C);
-        end;
-
-        InflateRect(R2, 1, 1);
-        if not TBXLoColor or not CloseButtonDown then
-          Pen.Color := NearestMixedColor(clBtnShadow, clBtnFace, 191)
-        else
-          Pen.Color := clBtnShadow;
-        RoundFrame(Canvas.Handle, R2, 1, 1, Pen.Color);
-      end;
-
-      if CloseButtonDown then OffsetRect(R2, 1, 1);
-      DrawButtonBitmap(Canvas, R2);
-    end;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2 + Ord(ItemInfo.Pushed);
-    Y := (Top + Bottom - StockImgList.Height - 1) div 2 + Ord(ItemInfo.Pushed);
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  DrawGlyph(Canvas.Handle, X, Y, StockImgList, Index, clBtnText);
-end;
-
-function TTBXMonaiXPTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXMonaiXPTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-end;
-
-destructor TTBXMonaiXPTheme.Destroy;
-begin
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXMonaiXPTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-begin
-  // this theme does not support dock painting
-end;
-
-procedure TTBXMonaiXPTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect;
-  const DockPanelInfo: TTBXDockPanelInfo);
-var
-  DC: HDC;
-  Sz: Integer;
-  R2: TRect;
-  Flags: Integer;
-  CloseButtonDown, CloseButtonHover: Boolean;
-  C: TColor;
-  TextSize, TextSize2: TSize;
-begin
-  DC := Canvas.Handle;
-  with Canvas, DockPanelInfo do
-  begin
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-
-    { Border }
-    FrameRectEx(DC, R, ToolbarColor, True);
-    R2 := R;
-    if ShowCaption then
-      if IsVertical then Inc(R2.Top, Sz)
-      else Inc(R2.Left, Sz);
-    Brush.Color := DockPanelInfo.EffectiveColor;
-    FrameRect(R2);
-
-    if not ShowCaption then Exit;
-
-    C := DockPanelInfo.EffectiveColor;
-    Brush.Color := C;
-
-    R2 := R;
-    Pen.Color := NearestMixedColor(clBtnShadow, clBtnFace,  128);
-    if IsVertical then R.Bottom := R.Top + Sz
-    else R.Right := R.Left + Sz;
-    Windows.DrawEdge(Handle, R, BDR_RAISEDINNER, BF_RECT or BF_MIDDLE or BF_ADJUST);
-
-    { Close button }
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      CloseButtonDown := (CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := R;
-      Brush.Color := clBtnFace;
-
-      if IsVertical then
-      begin
-        Dec(R2.Right);
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Top := R2.Bottom - Sz + 2;
-        R.Bottom := R2.Top;
-      end;
-
-      InflateRect(R2, -2, -2);
-      if CloseButtonDown or CloseButtonHover then
-      begin
-        if CloseButtonDown then
-        begin
-          if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 126)
-          else C := clBtnHighlight;
-          DitherRect(DC, R2, clBtnHighlight, C);
-        end
-        else
-        begin
-          if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(DC, R2, clBtnFace, C);
-        end;
-
-        InflateRect(R2, 1, 1);
-        if not TBXLoColor or not CloseButtonDown then
-          C := NearestMixedColor(clBtnShadow, clBtnFace, 191)
-        else
-          C := clBtnShadow;
-
-        RoundFrame(DC, R2, 1, 1, C);
-      end;
-
-      if CloseButtonDown then OffsetRect(R2, 1, 1);
-      DrawButtonBitmap(Canvas, R2);
-    end;
-
-    { Caption }
-    Brush.Color := ToolbarColor;
-    if IsVertical then InflateRect(R, -1, 0)
-    else Inflaterect(R, 0, -1);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-
-    if IsVertical then
-    begin
-      TextSize := TextExtent(string(Caption));
-      if TextSize.Cx &gt; 0 then Inc(TextSize.Cx, 12);
-      if TextSize.Cx &lt; R.Right - R.Left then
-      begin
-        R2 := R;
-        Inc(R2.Top);
-        if TextSize.Cx = 0 then DotFill(Canvas, R2, clBtnFace, 1)
-        else
-        begin
-          R2.Right := (R.Left + R.Right - TextSize.cx) div 2;
-          Inc(R2.Left);
-          DotFill(Canvas, R2, clBtnFace, 1);
-          R2.Right := R.Right;
-          R2.Left := (R.Left + R.Right + TextSize.cx) div 2;
-          DotFill(Canvas, R2, clBtnFace, 1);
-          R2.Right := R2.Left;
-          R2.Left := (R.Left + R.Right - TextSize.cx) div 2;
-          FillRectEx(DC, R2, clBtnFace);
-        end;
-      end;
-    end
-    else
-    begin
-      TextSize2 := TextExtent(string(Caption));
-      TextSize.cx := TextSize2.cy;
-      TextSize.cy := TextSize2.cx;
-      if TextSize.cy &gt; 0 then Inc(TextSize.cy, 12);
-      if TextSize.cy &lt; R.Bottom - R.Top then
-      begin
-        R2 := R;
-        Inc(R2.Left);
-        if TextSize.cy = 0 then DotFill(Canvas, R2, clBtnFace, 1)
-        else
-        begin
-          R2.Bottom := (R.Top + R.Bottom - TextSize.cy) div 2;
-          Inc(R2.Top);
-          DotFill(Canvas, R2, clBtnFace, 1);
-          R2.Bottom := R.Bottom;
-          R2.Top := (R.Top + R.Bottom + TextSize.cy) div 2;
-          DotFill(Canvas, R2, clBtnFace, 1);
-          R2.Bottom := R2.Top;
-          R2.Top := (R.Top + R.Bottom - TextSize.cy) div 2;
-          FillRectEx(DC, R2, clBtnFace);
-        end;
-      end;
-    end;
-
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_CENTER or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX;
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  DC: HDC;
-  R: TRect;
-  X, Y, Sz: Integer;
-  C: Longword;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then DitherRect(DC, R, clBtnFace, clBtnHighlight)
-  else FillRectEx(DC, R, clBtnFace);
-  InflateRect(R, 1, 1);
-  RoundFrame(DC, R, 1, 1, NearestMixedColor(clWindow, clBtnShadow, 64));
-  C := GetSysColor(COLOR_BTNFACE);
-  with R do
-  begin
-    SetPixelV(DC, Left, Top, C);
-    SetPixelV(DC, Left, Top, C);
-    SetPixelV(DC, Right + 1, Top, C);
-    SetPixelV(DC, Right + 1, Bottom + 1, C);
-    SetPixelV(DC, Left, Bottom + 1, C);
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  Canvas.Pen.Color := clBtnText;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-  C: TColor;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then Canvas.Pen.Color := clBtnText
-    else if Boolean(State and PFS_HOT) then Canvas.Pen.Color := clBtnText
-    else Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-      else C := clBtnHighlight;
-      Canvas.Brush.Bitmap := AllocPatternBitmap(C, clBtnHighlight);
-    end
-    else if Boolean(State and PFS_HOT) then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-      else C := clBtnFace;
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clBtnFace, C);
-    end
-    else if Boolean(State and PFS_MIXED) then Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then Result := clBtnFace
-    else if Boolean(State and PFS_MIXED) then Result := clBtnShadow
-    else Result := clBtnText;
-  end;
-
-begin
-  with Canvas do case Kind of
-    PFC_CHECKBOX:
-      begin
-        SetupPen;
-        SetupBrush;
-        InflateRect(R, -1, -1);
-        with R do Rectangle(Left, Top, Right, Bottom);
-        Pen.Style := psSolid;
-        Brush.Style := bsSolid;
-
-        if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-        begin
-          X := (R.Left + R.Right) div 2 - 1;
-          Y := (R.Top + R.Bottom) div 2 + 1;
-          Pen.Color := TextColor;
-          Brush.Color := Pen.Color;
-          Polygon([Point(X-2, Y), Point(X, Y+2), Point(X+4, Y-2),
-            Point(X+4, Y-4), Point(X, Y), Point(X-2, Y-2), Point(X-2, Y)]);
-        end;
-      end;
-    PFC_RADIOBUTTON:
-      begin
-        SetupPen;
-        SetupBrush;
-        InflateRect(R, -1, -1);
-        with R do Ellipse(Left, Top, Right, Bottom);
-        Pen.Style := psSolid;
-        Brush.Style := bsSolid;
-        if Boolean(State and PFS_CHECKED) then
-        begin
-          InflateRect(R, -3, -3);
-          Pen.Color := TextColor;
-          Brush.Color := Pen.Color;
-          with R do Ellipse(Left, Top, Right, Bottom);
-        end;
-      end;
-  else
-    inherited;
-  end;
-end;
-
-procedure TTBXMonaiXPTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-var
-  Color, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, clBtnFace);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 0, R.Right, R.Top + 0, clBtnShadow);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1,
-            NearestMixedColor(clBtnShadow, clBtnFace,  128));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 2, R.Right, R.Top + 2,
-            NearestMixedColor(clBtnShadow, clBtnFace,  64));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 3, R.Right, R.Top + 3,
-            NearestMixedColor(clBtnShadow, clBtnFace,  32));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 4, R.Right, R.Top + 4,
-            NearestMixedColor(clBtnShadow, clBtnFace,  12));
-
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 3, R.Right, R.Bottom - 3,
-            NearestMixedColor(clBtnShadow, clBtnFace,  8));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 2, R.Right, R.Bottom - 2,
-            NearestMixedColor(clBtnShadow, clBtnFace,  16));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            NearestMixedColor(clBtnShadow, clBtnFace,  24));
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, DisabledColor);
-        end;
-      SBP_GRIPPER:
-        begin
-          Color:= clBtnFace;
-          Hi1:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do begin
-            Pixels[Right - 12, Bottom - 4]:= Lo2;
-            Pixels[Right - 12, Bottom - 3]:= Hi2;
-            Pixels[Right - 11, Bottom - 4]:= Lo1;
-            Pixels[Right - 11, Bottom - 3]:= Hi1;
-            Pixels[Right - 11, Bottom - 2]:= Hi4;
-            Pixels[Right - 10, Bottom - 2]:= Hi3;
-            Pixels[Right - 10, Bottom - 3]:= Lo3;
-
-            Pixels[Right - 8, Bottom - 4]:= Lo2;
-            Pixels[Right - 8, Bottom - 3]:= Hi2;
-            Pixels[Right - 7, Bottom - 4]:= Lo1;
-            Pixels[Right - 7, Bottom - 3]:= Hi1;
-            Pixels[Right - 7, Bottom - 2]:= Hi4;
-            Pixels[Right - 6, Bottom - 2]:= Hi3;
-            Pixels[Right - 6, Bottom - 3]:= Lo3;
-
-            Pixels[Right - 4, Bottom - 4]:= Lo2;
-            Pixels[Right - 4, Bottom - 3]:= Hi2;
-            Pixels[Right - 3, Bottom - 4]:= Lo1;
-            Pixels[Right - 3, Bottom - 3]:= Hi1;
-            Pixels[Right - 3, Bottom - 2]:= Hi4;
-            Pixels[Right - 2, Bottom - 2]:= Hi3;
-            Pixels[Right - 2, Bottom - 3]:= Lo3;
-
-            Pixels[Right - 8, Bottom - 8]:= Lo2;
-            Pixels[Right - 8, Bottom - 7]:= Hi2;
-            Pixels[Right - 7, Bottom - 8]:= Lo1;
-            Pixels[Right - 7, Bottom - 7]:= Hi1;
-            Pixels[Right - 7, Bottom - 6]:= Hi4;
-            Pixels[Right - 6, Bottom - 6]:= Hi3;
-            Pixels[Right - 6, Bottom - 7]:= Lo3;
-
-            Pixels[Right - 4, Bottom - 8]:= Lo2;
-            Pixels[Right - 4, Bottom - 7]:= Hi2;
-            Pixels[Right - 3, Bottom - 8]:= Lo1;
-            Pixels[Right - 3, Bottom - 7]:= Hi1;
-            Pixels[Right - 3, Bottom - 6]:= Hi4;
-            Pixels[Right - 2, Bottom - 6]:= Hi3;
-            Pixels[Right - 2, Bottom - 7]:= Lo3;
-
-            Pixels[Right - 4, Bottom - 12]:= Lo2;
-            Pixels[Right - 4, Bottom - 11]:= Hi2;
-            Pixels[Right - 3, Bottom - 12]:= Lo1;
-            Pixels[Right - 3, Bottom - 11]:= Hi1;
-            Pixels[Right - 3, Bottom - 10]:= Hi4;
-            Pixels[Right - 2, Bottom - 10]:= Hi3;
-            Pixels[Right - 2, Bottom - 11]:= Lo3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXMonaiXPTheme.SetupColorCache;
-begin
-  DockPanelColor := NearestMixedColor(clBtnFace, clWindow, 64);
-  if not TBXLoColor then DisabledColor := MixColors(clBtnShadow, clBtnFace, 210)
-  else DisabledColor := clBtnShadow;
-  ToolbarColor := clBtnFace;
-end;
-
-procedure TTBXMonaiXPTheme.GetMargins(MarginID: Integer; out Margins: TTBXMargins);
-begin
-  inherited;
-  if MarginID = MID_MENUITEM then
-  begin
-    Margins.TopHeight := 2;
-    Margins.BottomHeight := 2;
-  end;
-end;
-
-initialization
-
-RegisterTBXTheme('MonaiXP', TTBXMonaiXPTheme);
-
-end.

Deleted: Lobby/TASClient/Themes/TBXNexos2Theme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXNexos2Theme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXNexos2Theme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,3000 +0,0 @@
-unit TBXNexos2Theme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Nexos2' TBX theme &#169; 2004 Roy Magne Klever
-//
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-{*$DEFINE SMALL_CLOSE_BUTTON}// remove the asterisk for smaller close button size
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXNexos2Theme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-        override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated:
-        Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  MenuButtons, BarLines, AltCaption,
-    CaptionOutline, DottedGrip, AltButton: boolean;
-  SelGradient: integer;
-  BaseColor, BaseShade: TColor;
-
-{$IFDEF DTM_Package}
-function TBXThemeName: shortstring; stdcall;
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-{$ENDIF}
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-{$IFDEF DTM_Package}
-exports
-  TBXThemeName,
-  TBXRegisterTheme;
-
-const
-  cThemeName = 'Nexos2';
-
-function TBXThemeName: shortstring; stdcall;
-begin
-  result := cThemeName;
-end;
-
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-begin
-  if RegisterTheme then
-    RegisterTBXTheme(cThemeName, TTBXZezioTheme)
-  else
-    UnregisterTBXTheme(cThemeName);
-end;
-{$ENDIF}
-
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-  GradientBmp: TBitmap;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXNexos2Theme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right);
-    Inc(Bottom);
-  end;
-end;
-
-procedure ButtonFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer; c1, c2, c3:
-  TColor);
-var
-  Color: TColor;
-begin
-  with Canvas, R do
-  begin
-    Color := Pen.Color;
-    Pen.Color := c1;
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-
-    if c2 &lt;&gt; clNone then
-    begin
-      Pen.Color := c2;
-      PolyLine([
-        Point(Right, Top + RR),
-          Point(Right, Bottom - RR),
-          Point(Right - RR, Bottom),
-          Point(Left + RL - 1, Bottom)
-          ]);
-    end;
-
-    Pen.Color := c3;
-    if RR &gt; 0 then
-    begin
-      Inc(Right);
-      MoveTo(Right - RR, Top);
-      LineTo(Right, Top + RR);
-      MoveTo(Right - RR, Bottom);
-      LineTo(Right, Bottom - RR);
-      Dec(Right);
-    end;
-
-    if RL &gt; 0 then
-    begin
-      Dec(Left);
-      MoveTo(Left + RL, Top);
-      LineTo(Left, Top + RL);
-      MoveTo(Left + RL, Bottom);
-      LineTo(Left, Bottom - RL);
-      Inc(Left);
-    end;
-
-    Inc(Right);
-    Inc(Bottom);
-    Pen.Color := Color;
-  end;
-end;
-
-function TTBXNexos2Theme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXNexos2Theme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-
-    TMI_MENU_IMGTEXTSPACE: Result := 3;
-    TMI_MENU_LCAPTIONMARGIN: Result := 3;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-
-    TMI_TLBR_SEPARATORSIZE: Result := 5; //DEFAULT;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXNexos2Theme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXNexos2Theme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXNexos2Theme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-var
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then
-    rc3 := 0
-  else if rc3 &gt; 255 then
-    rc3 := 255;
-  if gc3 &lt; 0 then
-    gc3 := 0
-  else if gc3 &gt; 255 then
-    gc3 := 255;
-  if bc3 &lt; 0 then
-    bc3 := 0
-  else if bc3 &gt; 255 then
-    bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GradientBmp.Width := 1;
-    GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-    GSize := GradientBmp.Height;
-
-    y1 := GSize div 2;
-    for i := 0 to y1 - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[0] := GradCol;
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for i := y1 to GSize - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc3 + (((rc2 - rc3) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc3 + (((gc2 - gc3) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc3 + (((bc2 - bc3) * (i)) div GSize));
-      Row[0] := GradCol;
-    end;
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end
-  else
-  begin
-    GradientBmp.Width := (ARect.Right - ARect.Left) - 1;
-    GradientBmp.Height := 1;
-    GSize := GradientBmp.Width;
-
-    y1 := GSize div 2;
-    Row := PRGBTripleArray(GradientBmp.ScanLine[0]);
-    for i := 0 to y1 - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[i] := GradCol;
-    end;
-
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-
-    for i := y1 to GSize - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc2 + (((rc3 - rc2) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc2 + (((gc3 - gc2) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc2 + (((bc3 - bc2) * (i)) div GSize));
-      Row[i] := GradCol;
-    end;
-
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom
-        - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXNexos2Theme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXNexos2Theme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXNexos2Theme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXNexos2Theme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) =
-    TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2; {1} // rmkO
-      Border.Y := 2;
-    end
-    else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXNexos2Theme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXNexos2Theme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-const
-  STRIPE_STEP = 3;
-var
-  HighlightColor: TColor;
-  ShadowColor: TColor;
-  Y, I: Integer;
-  R: TRect;
-begin
-  with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if not RectVisible(Handle, R) then
-      Exit;
-    if (AViewType and DPVT_NORMAL = DPVT_NORMAL)
-      or ((AViewType and VT_TOOLBAR = VT_TOOLBAR)
-      and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else if not Transparent then
-    begin
-      I := ColorIntensity(AColor);
-      if I &lt; 200 then
-        I := (200 - I) div 20
-      else
-        I := 0;
-      HighlightColor := GetNearestColor(Handle, Lighten(AColor, 8 + I));
-      ShadowColor := GetNearestColor(Handle, Lighten(AColor, -8));
-
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-        Y := (R.Top - ARect.Top) mod STRIPE_STEP;
-        Y := R.Top - Y;
-        while Y &lt; ARect.Bottom do
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, ShadowColor);
-          Inc(Y);
-          DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, HighlightColor);
-          Inc(Y, STRIPE_STEP - 1);
-        end;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if (ItemInfo.ViewType and TVT_MENUBAR = TVT_MENUBAR)
-      // Special menubar text painting
-    and (ItemInfo.HoverKind &lt;&gt; hkNone) and (MenuButtons = false) then
-      Font.Color := clWhite // rmkO This one was hard to find...
-    else
-    begin // This one was not easy to come up with... // rmkO
-      if (ItemInfo.ComboPart = cpSplitLeft) and (ItemInfo.IsPopupParent) then
-        Font.Color := clBlack
-      else
-        Font.Color := GetPartColor(ItemInfo, ipText);
-    end;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := clWhite //GetBtnColor(ItemInfo, ipText);
-  else if not ItemInfo.Enabled then
-    Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXNexos2Theme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then // Do nothing...
-    else if BtnHot then // Do nothing...
-    else if Embedded then
-    begin
-      FillRectEx(Canvas.Handle, R, ToolBarColor);
-      FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-    end
-    else
-      FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-          if SelGradient &lt;&gt; 0 then
-            FillGradient(Canvas, R, Blend(BaseColor, clBlack, 95),
-              Blend(BaseColor, clWhite, 10), TGTopBottom)
-          else
-            DitherRect(Canvas.Handle, R, clWindow, $00FFF0F0)
-        else
-          PaintEnabled(R, BtnPressed);
-      end;
-      if BtnDisabled then
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame],
-          True);
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color := BaseShade;
-      if not BtnDisabled then
-      begin
-        MoveTo(R.Left, R.Top);
-        LineTo(R.Left, R.Bottom);
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      // Upper button
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient(Canvas, BR, Blend(BaseColor, clBlack, 95),
-              Blend(BaseColor, clWhite, 10), TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite,
-              TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color := BaseShade;
-      MoveTo(BR.Left, BR.Top);
-      LineTo(BR.Left, BR.Bottom);
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color := GetPartColor(ItemInfo, ipText)
-      else
-        Pen.Color := clWhite;
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button...
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-          begin
-            FillGradient(Canvas, BR, Blend(BaseColor, clBlack, 95),
-              Blend(BaseColor, clWhite, 10), TGTopBottom);
-            Pen.Color := BaseColor;
-          end
-          else if BtnHot then
-          begin
-            FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite,
-              TGTopBottom);
-            Pen.Color := BaseColor;
-          end;
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color := BaseShade;
-      MoveTo(BR.Left, BR.Bottom - 1);
-      LineTo(BR.Left, BR.Top);
-      LineTo(BR.Right, BR.Top);
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color := GetPartColor(ItemInfo, ipText)
-      else
-        Pen.Color := clWhite;
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-    Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-
-      if (ItemInfo.ComboPart &lt;&gt; cpCombo) then
-      begin
-        if (not ItemInfo.Pushed) and
-          (ItemInfo.HoverKind = hkNone) then
-          Pen.Color := GetPartColor(ItemInfo, ipText)
-        else
-          Pen.Color := clWhite;
-      end
-      else
-        Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      if (ItemInfo.ComboPart &lt;&gt; cpCombo) then
-      begin
-        if (not ItemInfo.Pushed) and
-          (ItemInfo.HoverKind = hkNone) then
-          Pen.Color := GetPartColor(ItemInfo, ipText)
-        else
-          Pen.Color := clWhite;
-      end
-      else
-        Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end
-    else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXNexos2Theme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then
-      Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1;
-      RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := Blend(clHighLight, clWindow, 20);
-      end
-      else
-        Pen.Color := Blend(clHighLight, clWindow, 15);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-          ipBody], False, VT_UNKNOWN);
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-      begin
-        FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-        InflateRect(R, 1, 1);
-        ButtonFrame(Canvas, R, RL, RR, $00787878, $00A8A8A8, $00C0C0C0);
-        InflateRect(R, -1, -1);
-      end
-      else
-      begin
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        InflateRect(R, 1, 1);
-        ButtonFrame(Canvas, R, RL, RR, $00787878, $00A8A8A8, $00C0C0C0);
-        InflateRect(R, -1, -1);
-      end;
-
-      // ---
-      if (Selected and Pushed) then
-      begin
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        InflateRect(R, 1, 1);
-        ButtonFrame(Canvas, R, RL, RR, $00787878, $00A8A8A8, $00C0C0C0);
-      end
-      else if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      begin
-        FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-        InflateRect(R, 1, 1);
-        //ButtonFrame(Canvas, R, RL, RR, BaseColor, clNone, $00E0E0E0);
-        ButtonFrame(Canvas, R, RL, RR, $00484848, $00888888, $00C0C0C0);
-      end;
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), clWhite,
-        TGTopBottom);
-      InflateRect(R, 1, 1);
-      Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R, R2: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := WinFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack; //WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := PnlFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack; //PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    // Caption
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      // Alt caption...
-      if AltCaption then
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom) // rmkB
-      else
-      begin
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, False, VT_UNKNOWN);
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-          BarSepColor);
-      end;
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      R.Bottom := R.Bottom - 1;
-
-      // rmkNew
-      if CaptionOutline then
-      begin
-        Font.Color := gradCol1; //BaseColor;
-        R2 := R;
-        for y := -2 to 1 do
-          for x := -1 to 1 do
-          begin
-            R2.Top := R.Top + y;
-            R2.Left := R.Left + x;
-            DrawText(Canvas.Handle, WindowInfo.Caption, -1, R2,
-              DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX);
-          end;
-        Font.Color := CaptionText;
-      end;
-
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX);
-    end;
-
-    // Close button
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      if AltCaption then
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom) // rmkB
-      else
-      begin
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, False, VT_UNKNOWN);
-        DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom - 1, R.Right, R.Bottom -
-          1, BarSepColor);
-      end;
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        if AltCaption then
-        begin
-          FrameRectEx(Canvas.Handle, R, clBlack, True);
-          DrawButtonBitmap(Canvas, R, clWhite);
-        end
-        else
-        begin
-          FrameRectEx(Canvas.Handle, R, clGray, True);
-          FillRectEx(Canvas.Handle, R, clWhite);
-          DrawButtonBitmap(Canvas, R, clBlack);
-        end;
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        if AltCaption then
-        begin
-          FillGradient(Canvas, R, clWhite, BaseColor, TGTopBottom);
-          FrameRectEx(Canvas.Handle, R, BaseColor, True);
-          DrawButtonBitmap(Canvas, R, clBlack);
-        end
-        else
-        begin
-          FrameRectEx(Canvas.Handle, R, clGray, True);
-          FillRectEx(Canvas.Handle, R, clSilver);
-          DrawButtonBitmap(Canvas, R, clWhite);
-        end;
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        if not AltCaption then
-          FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-        if AltCaption then
-          DrawButtonBitmap(Canvas, R, clWhite)
-        else
-          DrawButtonBitmap(Canvas, R, clBlack);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected or (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, GetPartColor(ItemInfo, ipBody), gradCol2,
-        TGTopBottom);
-      if Pushed then
-        Canvas.Pen.Color := BaseColor //BtnItemColors[bisSelected, ipFrame]
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-function TTBXNexos2Theme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXNexos2Theme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-  Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-        //if Selected or Pushed then OffsetRect(ARect, 1, 1) else
-      begin // rmk Removed the shadows under the glyphs and added back 14.04.2003
-        {
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-        }
-
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 14.04.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXNexos2Theme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do
-    if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-        ipBody], False, VT_UNKNOWN);
-    end;
-end;
-
-procedure TTBXNexos2Theme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-    TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then
-        Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1;
-        RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-      begin
-        if ((Pushed or Selected) and Enabled) or ShowHover then
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-            ipBody], False, VT_UNKNOWN);
-        end;
-        Exit;
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          if SelGradient &lt;&gt; 0 then
-          begin
-            FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-            InflateRect(R, 1, 1);
-            ButtonFrame(Canvas, R, 2, 2, $00787878, $00A8A8A8, $00C0C0C0);
-            //ButtonFrame(Canvas, R, 2, 2, $00585858, $00989898, $00B0B0B0);
-          end
-          else
-            DitherRect(Canvas.Handle, R, clWindow, $00FFF0F0);
-          Pen.Color := BtnItemColors[bisSelected, ipFrame]
-        end
-        else
-        begin
-          FillGradient(Canvas, R, BtnItemColors[bisHot, ipBody], clWhite,
-            TGTopBottom);
-          Pen.Color := BaseColor; //BtnItemColors[bisHot, ipFrame]; // rmkP
-          InflateRect(R, 1, 1);
-          RoundFrame(Canvas, R, 2, 2);
-        end;
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40); //rmkO
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then
-        PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-
-    R := ARect;
-    //if (ImageWidth &gt; 0) or Selected then
-    //  Inc(R.Left, ItemInfo.PopupMargin + MenuImageTextSpace);
-    PaintMenuItemFrame(Canvas, R, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-
-    R := ARect;
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := clWhite //GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := R;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      Top := (Bottom div 2);
-      while Left &lt; Right do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Left := Left + 3;
-      end;
-    end
-    else if enabled then
-    begin
-      Left := (Right div 2); // - 1;
-      while Top &lt; Bottom do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Top := Top + 3;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    R.Top := R.Top - 1;
-    PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-      if BarLines then
-      begin
-        if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            clgray);
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom
-            - 1, BarSepColor);
-        end
-        else
-        begin
-          DrawLineEx(Canvas.Handle, R.Left + 1, R.Bottom - 1, R.Right, R.Bottom
-            - 1, BarSepColor); // Bottom
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 2, R.Right - 1, R.Bottom
-            - 1, BarSepColor); // Right
-        end;
-      end
-      else
-      begin
-        R2 := R;
-        while R2.Left &lt; R.Right do
-        begin
-          Canvas.Pixels[R2.Left, R.Bottom - 1] := BarSepColor;
-          R2.Left := R2.Left + 3;
-        end;
-        R2 := R;
-        while R2.Top &lt; R.Bottom - 1 do
-        begin
-          Canvas.Pixels[R2.Right - 1, R2.Top] := BarSepColor;
-          R2.Top := R2.Top + 3;
-        end;
-      end;
-    R.Top := R.Top + 1;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-        if Horz then
-          OffsetRect(R2, -1, 0)
-        else
-          OffsetRect(R2, 0, -1);
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := $00F0F0F0;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXNexos2Theme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags, X, Y: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      if AltCaption then
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom) // rmkB
-      else
-      begin
-        FillGradient(Canvas, R, gradCol2, gradHandle1, TGTopBottom); // rmkB
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-          BarSepColor);
-      end;
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      if AltCaption then
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGLeftRight) // rmkB
-      else
-      begin
-        FillGradient(Canvas, R, gradCol2, gradHandle1, TGLeftRight); // rmkB
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom,
-          BarSepColor);
-      end;
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        if AltCaption then
-        begin
-          FrameRectEx(Canvas.Handle, R2, clBlack, True);
-          DrawButtonBitmap(Canvas, R2, clWhite);
-        end
-        else
-        begin
-          FrameRectEx(Canvas.Handle, R2, clGray, True);
-          FillRectEx(Canvas.Handle, R2, clWhite);
-          DrawButtonBitmap(Canvas, R2, clBlack);
-        end;
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        if AltCaption then
-        begin
-          if IsVertical then
-            FillGradient(Canvas, R2, clWhite, BaseColor, TGTopBottom)
-          else
-            FillGradient(Canvas, R2, clWhite, BaseColor, TGLeftRight);
-          FrameRectEx(Canvas.Handle, R2, BaseColor, True);
-          DrawButtonBitmap(Canvas, R2, clBlack);
-        end
-        else
-        begin
-          FrameRectEx(Canvas.Handle, R2, clGray, True);
-          FillRectEx(Canvas.Handle, R2, clSilver);
-          DrawButtonBitmap(Canvas, R2, clWhite);
-        end;
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        if not AltCaption then
-          FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-        if AltCaption then
-          DrawButtonBitmap(Canvas, R2, clWhite
-            {BtnItemColors[BtnItemState, ipText]})
-        else
-          DrawButtonBitmap(Canvas, R, clBlack
-            {BtnItemColors[BtnItemState, ipText]});
-      end;
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    if AltCaption then
-      Font.Color := clWhite
-    else
-      Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    // rmkNew
-    if CaptionOutline then
-    begin
-      R2 := R;
-      C := Font.Color;
-      Font.Color := gradCol1; //BaseColor;
-      R2 := R;
-      for y := -2 to 1 do
-        for x := -1 to 1 do
-        begin
-          R2.Top := R.Top + y;
-          R2.Left := R.Left + x;
-          if IsVertical then
-            DrawText(Canvas.Handle, Caption, -1, R2, Flags)
-          else
-            DrawRotatedText(Canvas.Handle, string(Caption), R2, Flags);
-        end;
-      Font.Color := C;
-    end;
-
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXNexos2Theme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := clSilver;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-
-  gradBL := NearestMixedColor(clGray, gradCol1, 64);
-
-  MenubarColor := $00F4F4F4;
-  ToolbarColor := $00F4F4F4;
-
-  PopupColor := clWhite;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clSilver;
-
-  BarSepColor := $A0A0A0; //clGray;
-
-  EditFrameColor := Blend(clSilver, clWhite, 80);
-  EditFrameDisColor := Blend(clSilver, clWhite, 50);
-
-  HotBtnFace := Blend(BaseColor, clWhite, 80);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  WinFrameColors[wfsActive, wfpCaption] := clSilver;
-  WinFrameColors[wfsActive, wfpCaptionText] := clWhite;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clGray, 180);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  PnlFrameColors[wfsActive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive,
-    wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clGray;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clGray, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clSilver;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := clBlack;
-  BtnItemColors[bisSelected, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clWhite;
-  BtnItemColors[bisHot, ipFrame] := Blend(BaseColor, clWhite, 80);
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clBlack;
-  BtnItemColors[bisSelectedHot, ipFrame] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BaseColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBlack;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BaseColor;
-  MenuItemColors[misHot, ipText] := clWhite;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGray, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(clGray, clWhite, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := clBlack;
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXNexos2Theme.GetPopupShadowType: Integer;
-begin
-  //Result := PST_OFFICEXP;
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXNexos2Theme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXNexos2Theme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXNexos2Theme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXNexos2Theme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-    Canvas.Pen.Color := BaseColor;
-  end
-  else
-  begin
-    Canvas.Brush.Color := ToolBarColor;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := NearestMixedColor(clWhite, clGray, 64);
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clSilver;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clSilver;
-    Canvas.Pixels[Left, Bottom + 1] := clSilver;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if hot then
-    Canvas.Pen.Color := clWhite
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXNexos2Theme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const Canvas: TCanvas; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: boolean);
-  var
-    i: integer;
-  begin
-    rc1 := GetRValue(ColorToRGB(StartColor));
-    gc1 := GetGValue(ColorToRGB(StartColor));
-    bc1 := GetBValue(ColorToRGB(StartColor));
-    rc2 := GetRValue(ColorToRGB(EndColor));
-    gc2 := GetGValue(ColorToRGB(EndColor));
-    bc2 := GetBValue(ColorToRGB(EndColor));
-
-    rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-    gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-    bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-    if rc3 &lt; 0 then
-      rc3 := 0
-    else if rc3 &gt; 255 then
-      rc3 := 255;
-    if gc3 &lt; 0 then
-      gc3 := 0
-    else if gc3 &gt; 255 then
-      gc3 := 255;
-    if bc3 &lt; 0 then
-      bc3 := 0
-    else if bc3 &gt; 255 then
-      bc3 := 255;
-
-    if NewG then
-    begin
-      GradientBmp.Width := 1;
-      GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-      GSize := GradientBmp.Height;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-          Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-          Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-          Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-          Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end
-    else
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      for i := 0 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc1 + (((rc2 - rc1) * i) div GSize)),
-          Byte(gc1 + (((gc2 - gc1) * i) div GSize)),
-          Byte(bc1 + (((bc2 - bc1) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom
-          - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                FillGradient2(Canvas.Handle, R, clWhite, BaseShade {BaseColor},
-                  TGTopBottom)
-              else
-                FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              if AltButton then
-              begin
-                FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-                Pen.Color := BtnItemColors[bisHot, ipFrame];
-              end
-              else
-              begin
-                FillGradient2(Canvas.Handle, R, clWhite, {BaseShade} BaseColor,
-                  TGTopBottom);
-                Pen.Color := clSilver;
-              end;
-            end
-            else
-            begin
-              FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end
-            else
-              Pen.Color := clSilver;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                RadioGradient(Canvas, R, clWhite, BaseShade {BaseColor}, false)
-              else
-                RadioGradient(Canvas, R, clWhite, BaseShade {BaseColor}, true);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              if AltButton then
-              begin
-                RadioGradient(Canvas, R, BaseColor, clWhite, true);
-                Pen.Color := BtnItemColors[bisHot, ipFrame];
-              end
-              else
-              begin
-                RadioGradient(Canvas, R, clWhite, BaseColor, false);
-                Pen.Color := clSilver;
-              end;
-            end
-            else
-            begin
-              RadioGradient(Canvas, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas, R, clWhite, BaseShade, true);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end
-            else
-              Pen.Color := clSilver;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexos2Theme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  Color, Hi, Lo, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolBarColor, False,
-            VT_UNKNOWN);
-          //DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right, R.Top, BarSepColor); // rmkO
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          while R.Top &lt; R.Bottom - 1 do
-          begin
-            Canvas.Pixels[R.Right, R.Top] := ToolbarSeparatorColor;
-            R.Top := R.Top + 3;
-          end;
-        end;
-      SBP_GRIPPER:
-        if DottedGrip then
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end
-        else
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Hi := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Lo := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexos2Theme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-{$IFNDEF DTM_Package}
-initialization
-  MenuButtons := false;
-  AltCaption := true;
-  AltButton := true;
-  CaptionOutline := false;
-  DottedGrip := true;
-  SelGradient := 1;
-  BarLines := true;
-  //BaseColor:= $00D09020;  // Summer occean
-  //BaseColor := $0020D090; // Summer bris
-  BaseColor:= $0030C8A8;
-  //BaseColor:= $0000D0E5;
-    //BaseColor:= $0000C0E5;
-  //BaseColor:= $00D5C590;
-  //BaseColor:= $00E065A5;
-  //BaseColor:= $0065E0A5;
-  //BaseColor:= $005585E0;
-  //BaseColor := $00E0A565; // Aqua...
-  //BaseColor:= Blend(clHighlight, clWhite, 80);
-  //BaseColor:= Blend(Blend(clGreen, clYellow, 40), clRed, 65);
-  BaseShade := clSilver;
-  RegisterTBXTheme('Nexos2', TTBXNexos2Theme);
-{$ENDIF}
-end.
-

Deleted: Lobby/TASClient/Themes/TBXNexos3Theme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXNexos3Theme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXNexos3Theme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,3186 +0,0 @@
-unit TBXNexos3Theme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Nexos3' TBX theme &#169; 2004 Roy Magne Klever
-//
-//  Last updated: 12.09.2004
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE}
-
-type
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXNexos3Theme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  MenuButtons, BarLines, AltCaption,
-    Aqua, DarkAqua, CaptionOutline, DottedGrip: boolean;
-  SelGradient: integer;
-  HotColor, BaseColor, BaseShade: TColor;
-
-{$IFDEF DTM_Package}
-function TBXThemeName: shortstring; stdcall;
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-{$ENDIF}
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms, rmkThemes;
-
-{$IFDEF DTM_Package}
-exports
-  TBXThemeName,
-  TBXRegisterTheme;
-
-const
-  cThemeName = 'Nexos3';
-
-function TBXThemeName: shortstring; stdcall;
-begin
-  result := cThemeName;
-end;
-
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-begin
-  if RegisterTheme then
-    RegisterTBXTheme(cThemeName, TTBXNexos3Theme)
-  else
-    UnregisterTBXTheme(cThemeName);
-end;
-{$ENDIF}
-
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockImgList.Free;
-end;
-
-{ TTBXNexos3Theme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right);
-    Inc(Bottom);
-  end;
-end;
-
-function TTBXNexos3Theme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXNexos3Theme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 3;
-    TMI_MENU_LCAPTIONMARGIN: Result := 3;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := 5;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := -1;
-  end;
-end;
-
-function TTBXNexos3Theme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXNexos3Theme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXNexos3Theme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure GradientSpecial(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  GSize: Integer;
-  rc1, rc2, gc1, gc2, bc1, bc2, rc3, gc3, bc3,
-    y1, Counter: Integer;
-
-  Brush: HBrush;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then
-    rc3 := 0
-  else if rc3 &gt; 255 then
-    rc3 := 255;
-  if gc3 &lt; 0 then
-    gc3 := 0
-  else if gc3 &gt; 255 then
-    gc3 := 255;
-  if bc3 &lt; 0 then
-    bc3 := 0
-  else if bc3 &gt; 255 then
-    bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    y1 := GSize div 2;
-    for Counter := 0 to y1 - 1 do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for Counter := y1 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize)),
-        Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)),
-        Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    y1 := GSize div 2;
-    for Counter := 0 to y1 - 1 do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-      Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for Counter := y1 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize)),
-        Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)),
-        Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXNexos3Theme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXNexos3Theme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXNexos3Theme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXNexos3Theme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) =
-    TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end
-    else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXNexos3Theme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXNexos3Theme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-const
-  STRIPE_STEP = 4; {3}
-var
-  HighlightColor: TColor;
-  ShadowColor: TColor;
-  Y, I: Integer;
-  R: TRect;
-begin
-  with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if (AViewType and DPVT_NORMAL = DPVT_NORMAL)
-      or ((AViewType and VT_TOOLBAR = VT_TOOLBAR)
-      and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else if not Transparent then
-    begin
-      I := ColorIntensity(AColor);
-      if I &lt; 200 then
-        I := (200 - I) div 20
-      else
-        I := 0;
-      HighlightColor := GetNearestColor(Handle, Lighten(AColor, 11 + I));
-      ShadowColor := GetNearestColor(Handle, Lighten(AColor, -8));
-
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-
-      Y := (R.Top - ARect.Top) mod STRIPE_STEP;
-      Y := R.Top - Y;
-      while Y &lt; ARect.Bottom do
-      begin
-        DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, ShadowColor);
-        Inc(Y, 2);
-        DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, HighlightColor);
-        Inc(Y, 2);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if (ItemInfo.ViewType and TVT_MENUBAR = TVT_MENUBAR)
-      // Special menubar text painting
-    and (ItemInfo.HoverKind &lt;&gt; hkNone)
-      and (MenuButtons = false) then
-      Font.Color := clWhite // This one was hard to find...
-    else
-    begin // This one was not easy to come up with...
-      if (ItemInfo.ComboPart = cpSplitLeft) and (ItemInfo.IsPopupParent) then
-        Font.Color := clBlack
-      else if Font.Color = clNone then
-        Font.Color := GetPartColor(ItemInfo, ipText);
-    end;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := clBlack
-  else if not ItemInfo.Enabled then
-    Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXNexos3Theme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  var
-    C: TColor;
-  begin
-    if BtnDisabled then
-      C := EditFrameDisColor
-    else
-      C := EditFrameColor;
-    if Embedded then
-    begin
-      FillRectEx(Canvas.Handle, R, ToolBarColor);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end
-    else
-      FrameRectEx(Canvas.Handle, R, C, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-        begin
-          GradientGlass(Canvas, R, Aqua, True, TGTopBottom);
-          Pen.Color := BaseColor;
-        end
-        else if BtnHot then
-        begin
-          GradientGlass(Canvas, R, Aqua, TGTopBottom);
-          Pen.Color := BaseColor;
-        end
-        else
-        begin
-          PaintEnabled(R, BtnPressed);
-        end;
-      end;
-      if BtnDisabled then
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame],
-          True);
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color := BaseShade;
-      if not BtnDisabled then
-      begin
-        MoveTo(R.Left, R.Top);
-        LineTo(R.Left, R.Bottom);
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      // Upper button
-      Pen.Color := BaseShade;
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-          begin
-            GradientGlass(Canvas, BR, Aqua, True, TGTopBottom);
-            Pen.Color := BaseColor;
-          end
-          else if BtnHot then
-          begin
-            GradientGlass(Canvas, BR, Aqua, TGTopBottom);
-            Pen.Color := BaseColor;
-          end
-        end;
-        if (not BtnPressed) and (not BtnHot) then
-          Pen.Color := BaseShade;
-        MoveTo(BR.Left, BR.Top);
-        LineTo(BR.Left, BR.Bottom);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := clBlack; // GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button...
-      Pen.Color := BaseShade;
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-          begin
-            GradientGlass(Canvas, BR, Aqua, True, TGTopBottom);
-            Pen.Color := BaseColor;
-          end
-          else if BtnHot then
-          begin
-            GradientGlass(Canvas, BR, Aqua, TGTopBottom);
-            Pen.Color := BaseColor;
-          end;
-        end;
-        if (not BtnPressed) and (not BtnHot) then
-          Pen.Color := BaseShade;
-        MoveTo(BR.Left, BR.Bottom - 1);
-        LineTo(BR.Left, BR.Top);
-        LineTo(BR.Right, BR.Top);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := clBlack; // GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-    Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end
-    else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXNexos3Theme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then
-      Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1;
-      RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := clSilver;
-      end
-      else
-        Pen.Color := Blend(clSilver, clWhite, 80);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-          ipBody], False, VT_UNKNOWN);
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed then
-      begin
-        if HoverKind = hkNone then
-        begin
-          GradientGlass(Canvas, R, Aqua, rmkThemes.TGTopBottom);
-          InflateRect(R, 1, 1);
-          ButtonFrame(Canvas, R, RL, RR, BtnItemColors[bisSelected, ipFrame],
-            clNone, $00D0D0D0);
-        end
-        else
-        begin
-          GradientGlass(Canvas, R, Aqua, TGTopBottom);
-          InflateRect(R, 1, 1);
-          ButtonFrame(Canvas, R, RL, RR, BtnItemColors[bisSelectedHot, ipFrame],
-            clNone,
-            $00D8D8D8);
-        end;
-      end
-      else
-      begin
-        GradientFill(Canvas, R, $00E0E0E0, BaseShade, TGTopBottom);
-        InflateRect(R, 1, 1);
-        ButtonFrame(Canvas, R, RL, RR, $00585858, $00888888, $00A0A0A0);
-        Pen.Color := $00B6B6B6;
-        MoveTo(R.Left + RL, R.Top + 1);
-        LineTo(R.Right - RR, R.Top + 1);
-      end;
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      GradientGlass(Canvas, R, Aqua, rmkThemes.TGTopBottom);
-      InflateRect(R, 1, 1);
-      ButtonFrame(Canvas, R, RL, RR, GetBtnColor(ItemInfo, ipFrame), clNone,
-        $00D0D0D0);
-    end;
-
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R, R2: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := WinFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack;
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := PnlFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack;
-    end;
-
-    // Caption
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      if AltCaption then
-      begin
-        R2 := R;
-        InflateRect(R2, 1, 1);
-        R2.Bottom := R.Bottom;
-        GradientGlass(Canvas, R2, Aqua, rmkThemes.TGTopBottom);
-        DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom - 1, R.Right, R.Bottom -
-          1,
-          $00FFD090);
-      end
-      else
-      begin
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, False, VT_UNKNOWN);
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-          BarSepColor);
-      end;
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      R.Bottom := R.Bottom - 1;
-
-      if CaptionOutline then
-      begin
-        Font.Color := gradCol1;
-        R2 := R;
-        for y := -2 to 1 do
-          for x := -1 to 1 do
-          begin
-            R2.Top := R.Top + y;
-            R2.Left := R.Left + x;
-            DrawText(Canvas.Handle, WindowInfo.Caption, -1, R2,
-              DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-          end;
-        Font.Color := CaptionText;
-      end;
-
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    // Close button
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      if AltCaption then
-      begin
-        R2 := R;
-        InflateRect(R2, 1, 1);
-        R2.Bottom := R.Bottom;
-        GradientGlass(Canvas, R2, Aqua, rmkThemes.TGTopBottom);
-        DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom - 1, R.Right + 1, R.Bottom
-          - 1,
-          $00FFD090);
-      end
-      else
-      begin
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, False, VT_UNKNOWN);
-        DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom - 1, R.Right, R.Bottom -
-          1, BarSepColor);
-      end;
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        DrawButtonBitmap(Canvas, R2, $00E8E8E8);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        InflateRect(R2, -1, -1);
-        R2.Left := R2.Left + 1;
-        R2.Right := R2.Right - 1;
-        R2.Bottom := R2.Bottom - 1;
-        GradientFill(Canvas, R2, $00F0F0F0, $00D0D0D0, TGTopBottom);
-        Pen.Color := clSilver;
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clGray);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        DrawButtonBitmap(Canvas, R2, clBlack)
-      end;
-
-      {
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R, clGray, True);
-        if not AltCaption then
-          FillRectEx(Canvas.Handle, R, clWhite);
-        DrawButtonBitmap(Canvas, R, clWhite);
-      end else
-        if BtnItemState = bisPressed then
-        begin
-          FrameRectEx(Canvas.Handle, R, clGray, True);
-          if not AltCaption then
-            FillRectEx(Canvas.Handle, R, clSilver);
-          DrawButtonBitmap(Canvas, R, clWhite);
-        end else
-        begin
-          FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-          if not AltCaption then
-            FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-          if AltCaption then
-            DrawButtonBitmap(Canvas, R, HotColor)
-          else
-            DrawButtonBitmap(Canvas, R, clBlack);
-        end;
-        }
-    end;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-  C: TColor;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected or (HoverKind &lt;&gt; hkNone) or ((ItemOptions and
-      IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      if Pushed then
-        C := BtnItemColors[bisSelected, ipFrame]
-      else
-        C := GetPartColor(ItemInfo, ipFrame);
-      ButtonFrame(Canvas, R, 1, 1, c, clNone, $00D8D8D8);
-    end;
-  end;
-end;
-
-function TTBXNexos3Theme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXNexos3Theme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-    Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if Selected or Pushed then
-      else
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 255);
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXNexos3Theme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do
-    if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-        ipBody], False, VT_UNKNOWN);
-    end;
-end;
-
-procedure TTBXNexos3Theme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-    TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-    C: TColor;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then
-        Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1;
-        RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-      begin
-        if ((Pushed or Selected) and Enabled) or ShowHover then
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-            ipBody], False, VT_UNKNOWN);
-        end;
-        Exit;
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          GradientGlass(Canvas, R, Aqua, rmkThemes.TGTopBottom);
-          C := BtnItemColors[bisSelected, ipFrame];
-        end
-        else
-        begin
-          GradientGlass(Canvas, R, Aqua, rmkThemes.TGTopBottom);
-          C := BtnItemColors[bisSelectedHot, ipFrame];
-        end;
-        InflateRect(R, 1, 1);
-        ButtonFrame(Canvas, R, 2, 2, C, clNone, $00D8D8D8);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then
-        PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    if (ImageWidth &gt; 0) or Selected then
-      Inc(R.Left, ItemInfo.PopupMargin + MenuImageTextSpace);
-    PaintMenuItemFrame(Canvas, R, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := clWhite
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := Arect;
-    InflateRect(R2, -1, -1);
-
-    if ((Selected) and (Enabled)) then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      // InflateRect(R, -1, -1);
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      Top := (Bottom div 2);
-      while Left &lt; Right do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Left := Left + 3;
-      end;
-    end
-    else if enabled then
-    begin
-      Left := (Right div 2);
-      while Top &lt; Bottom do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Top := Top + 3;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Hi3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if not ToolbarInfo.IsVertical then
-      R.Top := R.Top - 2;
-
-    if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      PaintBackgnd(Canvas, ZERO_RECT, R, R, MenubarColor, false, VT_UNKNOWN)
-    else
-      PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-
-    if ToolbarInfo.BorderStyle = bsSingle then
-    begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-      if BarLines then
-      begin
-        if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            clgray);
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom
-            - 1, BarSepColor);
-        end
-        else
-        begin
-          DrawLineEx(Canvas.Handle, R.Left + 1, R.Bottom - 1, R.Right, R.Bottom
-            - 1, BarSepColor); // Bottom
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 3, R.Right - 1, R.Bottom
-            - 1, BarSepColor); // Right
-        end;
-      end
-      else
-      begin
-        R2 := R;
-        while R2.Left &lt; R.Right do
-        begin
-          Canvas.Pixels[R2.Left, R.Bottom - 1] := BarSepColor;
-          R2.Left := R2.Left + 3;
-        end;
-        R2 := R;
-        while R2.Top &lt; R.Bottom - 1 do
-        begin
-          Canvas.Pixels[R2.Right - 1, R2.Top] := BarSepColor;
-          R2.Top := R2.Top + 3;
-        end;
-      end;
-    end;
-    
-    R.Top := R.Top + 1;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-        if Horz then
-          OffsetRect(R2, -1, 0)
-        else
-          OffsetRect(R2, 0, -1);
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 2, i] := Hi3;
-          Pixels[R2.Left, i + 2] := Hi3;
-          Pixels[R2.Left + 1, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 1] := Hi3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 2, i] := Hi3;
-            Pixels[R2.Left + 4, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 1] := Hi3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top] := Hi3;
-          Pixels[i + 1, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 1] := Hi3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 4] := Hi3;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 1 + 4] := Hi3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      R2.Left := R2.Left + 1;
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      if BtnItemState = bisHot then
-      begin
-        GradientGlass(Canvas, R2, true, TGTopBottom);
-        ButtonFrame(Canvas, R2, 1, 1, clGray, clNone, clsilver);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        GradientFill(Canvas, R2, clWhite, clSilver, TGTopBottom);
-        FrameRectEx(Canvas.Handle, R2, $00D0D0D0, True);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := $00F0F0F0;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXNexos3Theme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags, X, Y: Integer;
-  R2, R3: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, $00E0E0E0 {clSilver} {clBtnFace}, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      if AltCaption then
-      begin
-        R3 := R;
-        InflateRect(R3, 1, 1);
-        R3.Bottom := R.Bottom;
-        GradientGlass(Canvas, R3, Aqua, rmkThemes.TGTopBottom);
-        DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom - 1, R.Right + 1, R.Bottom
-          - 1,
-          $00FFD090);
-      end
-      else
-      begin
-        GradientGlass(Canvas, R, Aqua, rmkThemes.TGTopBottom);
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-          BarSepColor);
-      end;
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      if AltCaption then
-      begin
-        R3 := R;
-        InflateRect(R3, 1, 1);
-        R3.Right := R.Right;
-        GradientGlass(Canvas, R, Aqua, rmkThemes.TGLeftRight);
-        Canvas.Pixels[R.Right - 1, R.Top] := clWhite;
-        Canvas.Pixels[R.Right - 1, R.Bottom - 1] := clWhite;
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top - 1, R.Right - 1, R.Bottom
-          + 1,
-          $00FFD090);
-      end
-      else
-      begin
-        GradientGlass(Canvas, R, Aqua, rmkThemes.TGLeftRight);
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom,
-          BarSepColor);
-      end;
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        DrawButtonBitmap(Canvas, R2, $00E8E8E8);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        InflateRect(R2, -1, -1);
-        GradientFill(Canvas, R2, $00F0F0F0, $00D0D0D0, TGTopBottom);
-        Pen.Color := clSilver;
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clGray);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        DrawButtonBitmap(Canvas, R2, clBlack)
-      end;
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    if AltCaption then
-      Font.Color := HotColor
-    else
-      Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    if CaptionOutline then
-    begin
-      R2 := R;
-      C := Font.Color;
-      Font.Color := gradCol1;
-      R2 := R;
-      for y := -1 to 2 do
-        for x := -1 to 1 do
-        begin
-          R2.Top := R.Top + y;
-          R2.Left := R.Left + x;
-          if IsVertical then
-            DrawText(Canvas.Handle, Caption, -1, R2, Flags)
-          else
-            DrawRotatedText(Canvas.Handle, string(Caption), R2, Flags);
-        end;
-      Font.Color := C;
-    end;
-
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXNexos3Theme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := clSilver;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-
-  gradBL := NearestMixedColor(clGray, gradCol1, 64);
-
-  MenubarColor := $00F7F7F7;
-  ToolbarColor := $00F7F7F7;
-
-  PopupColor := MenuBarColor;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clSilver;
-
-  BarSepColor := $A0A0A0;
-
-  EditFrameColor := Blend(clSilver, clWhite, 80);
-  EditFrameDisColor := Blend(clSilver, clWhite, 50);
-  ;
-
-  HotBtnFace := Blend(BaseColor, clWhite, 80);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  if Aqua then
-    BaseColor := $00E0A030 // Aqua
-  else
-    BaseColor := $00A8A8A8; // Discret
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  WinFrameColors[wfsActive, wfpCaption] := clSilver;
-  WinFrameColors[wfsActive, wfpCaptionText] := HotColor;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clGray, 180);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  PnlFrameColors[wfsActive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive,
-    wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clGray, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clSilver;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := Blend(BaseColor, clWhite, 90);
-    //$00a0a0a0;
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 50);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := HotColor;
-  BtnItemColors[bisHot, ipFrame] := Blend(BaseColor, clWhite, 80);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clBlack;
-  BtnItemColors[bisSelectedHot, ipFrame] := Blend(BaseColor, clWhite, 75);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BaseColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBlack;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BaseColor;
-  MenuItemColors[misHot, ipText] := clWhite;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGray, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(clGray, clWhite, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := clBlack;
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXNexos3Theme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXNexos3Theme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXNexos3Theme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXNexos3Theme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXNexos3Theme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    GradientGlass(Canvas, R, Aqua, rmkThemes.tGTopBottom);
-    Canvas.Pen.Color := BaseColor;
-  end
-  else
-  begin
-    Canvas.Brush.Color := ToolBarColor;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := NearestMixedColor(clWhite, clGray, 64);
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clSilver;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clSilver;
-    Canvas.Pixels[Left, Bottom + 1] := clSilver;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if hot then
-    Canvas.Pen.Color := clWhite
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXNexos3Theme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-const
-  DarkAqua: Boolean = False;
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-  Aqua: Boolean;
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-  Brush: HBrush;
-
-  procedure RadioGradient(const DC: HDC; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: Boolean);
-  var
-    GSize: Integer;
-    rc1, rc2, gc1, gc2, bc1, bc2, rc3, gc3, bc3, rc4, gc4, bc4,
-      r, g, b, y1, Counter, i, d1, d2, d3: Integer;
-
-    Brush: HBrush;
-  begin
-    if Aqua then
-    begin
-      rc1 := $F0;
-      rc2 := $80;
-      rc3 := $70;
-      rc4 := $B0;
-      gc1 := $F8;
-      gc2 := $B0;
-      gc3 := $E8;
-      gc4 := $FF;
-      bc1 := $FF;
-      bc2 := $E0;
-      bc3 := $F0;
-      bc4 := $FF;
-    end
-    else
-    begin
-      rc1 := $F8;
-      rc2 := $D8;
-      rc3 := $F0;
-      rc4 := $F8;
-      gc1 := $F8;
-      gc2 := $D8;
-      gc3 := $F0;
-      gc4 := $F8;
-      bc1 := $F8;
-      bc2 := $D8;
-      bc3 := $F0;
-      bc4 := $F8;
-    end;
-
-    if NewG then
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      y1 := GSize div 3;
-      d1 := y1;
-      d2 := y1 + y1;
-      for i := 0 to y1 do
-      begin
-        r := rc1 + (((rc2 - rc1) * (i)) div y1);
-        g := gc1 + (((gc2 - gc1) * (i)) div y1);
-        b := bc1 + (((bc2 - bc1) * (i)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      for i := y1 to d2 do
-      begin
-        r := rc2 + (((rc3 - rc2) * (i - d1)) div y1);
-        g := gc2 + (((gc3 - gc2) * (i - d1)) div y1);
-        b := bc2 + (((bc3 - bc2) * (i - d1)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      for i := d2 to GSize do
-      begin
-        r := rc3 + (((rc4 - rc3) * (i - d2)) div y1);
-        g := gc3 + (((gc4 - gc3) * (i - d2)) div y1);
-        b := bc3 + (((bc4 - bc3) * (i - d2)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end
-    else
-    begin
-      rc1 := GetRValue(ColorToRGB(StartColor));
-      gc1 := GetGValue(ColorToRGB(StartColor));
-      bc1 := GetBValue(ColorToRGB(StartColor));
-      rc2 := GetRValue(ColorToRGB(EndColor));
-      gc2 := GetGValue(ColorToRGB(EndColor));
-      bc2 := GetBValue(ColorToRGB(EndColor));
-
-      rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-      gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-      bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-      if rc3 &lt; 0 then
-        rc3 := 0
-      else if rc3 &gt; 255 then
-        rc3 := 255;
-      if gc3 &lt; 0 then
-        gc3 := 0
-      else if gc3 &gt; 255 then
-        gc3 := 255;
-      if bc3 &lt; 0 then
-        bc3 := 0
-      else if bc3 &gt; 255 then
-        bc3 := 255;
-
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-          Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-          Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-          Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-          Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-begin
-  Aqua := true;
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              GradientFill(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              GradientGlass(Canvas, R, True, tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end
-            else
-            begin
-              GradientGlass(Canvas, R, True, tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              GradientGlass(Canvas, R, True, tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-              InflateRect(R, 1, 1);
-            end
-            else
-            begin
-              InflateRect(R, -1, -1);
-              GradientGlass(Canvas, R, False, tGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, false);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              RadioGradient(Canvas.Handle, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end
-            else
-            begin
-              RadioGradient(Canvas.Handle, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-              InflateRect(R, 1, 1);
-            end
-            else
-            begin
-              InflateRect(R, -1, -1);
-              Aqua := false;
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, true);
-              Aqua := true;
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end
-          else
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := clWhite;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-{
-procedure TTBXNexos3Theme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const DC: HDC; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: Boolean);
-  var
-    GSize: Integer;
-    rc1, rc2, gc1, gc2, bc1, bc2, rc3, gc3, bc3, rc4, gc4, bc4,
-      r, g, b, y1, Counter, i, d1, d2, d3: Integer;
-
-    Brush: HBrush;
-  begin
-    if Aqua then
-    begin
-      if DarkAqua then
-      begin
-        rc1 := $D8; rc2 := $20; rc3 := $00; rc4 := $00;
-        gc1 := $D8; gc2 := $40; gc3 := $A0; gc4 := $FF;
-        bc1 := $FF; bc2 := $D0; bc3 := $E0; bc4 := $FF;
-      end else
-      begin
-        rc1 := $f0; rc2 := $80; rc3 := $70; rc4 := $B0;
-        gc1 := $f8; gc2 := $B0; gc3 := $E8; gc4 := $FF;
-        bc1 := $FF; bc2 := $E0; bc3 := $F0; bc4 := $FF;
-      end;
-    end else
-    begin
-    // Discret
-      rc1 := $F0; rc2 := $C0; rc3 := $D8; rc4 := $F0;
-      gc1 := $F0; gc2 := $C0; gc3 := $D8; gc4 := $F0;
-      bc1 := $F0; bc2 := $C0; bc3 := $D8; bc4 := $F0;
-    end;
-    if NewG then
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      y1 := GSize div 3;
-      d1 := y1;
-      d2 := y1 + y1;
-      for i := 0 to y1 do
-      begin
-        r := rc1 + (((rc2 - rc1) * (i)) div y1);
-        g := gc1 + (((gc2 - gc1) * (i)) div y1);
-        b := bc1 + (((bc2 - bc1) * (i)) div y1);
-        if r &lt; 0 then r := 0 else if r &gt; 255 then r := 255;
-        if g &lt; 0 then g := 0 else if g &gt; 255 then g := 255;
-        if b &lt; 0 then b := 0 else if b &gt; 255 then b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      for i := y1 to d2 do
-      begin
-        r := rc2 + (((rc3 - rc2) * (i - d1)) div y1);
-        g := gc2 + (((gc3 - gc2) * (i - d1)) div y1);
-        b := bc2 + (((bc3 - bc2) * (i - d1)) div y1);
-        if r &lt; 0 then r := 0 else if r &gt; 255 then r := 255;
-        if g &lt; 0 then g := 0 else if g &gt; 255 then g := 255;
-        if b &lt; 0 then b := 0 else if b &gt; 255 then b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      for i := d2 to GSize do
-      begin
-        r := rc3 + (((rc4 - rc3) * (i - d2)) div y1);
-        g := gc3 + (((gc4 - gc3) * (i - d2)) div y1);
-        b := bc3 + (((bc4 - bc3) * (i - d2)) div y1);
-        if r &lt; 0 then r := 0 else if r &gt; 255 then r := 255;
-        if g &lt; 0 then g := 0 else if g &gt; 255 then g := 255;
-        if b &lt; 0 then b := 0 else if b &gt; 255 then b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end else
-    begin
-      rc1 := GetRValue(ColorToRGB(StartColor));
-      gc1 := GetGValue(ColorToRGB(StartColor));
-      bc1 := GetBValue(ColorToRGB(StartColor));
-      rc2 := GetRValue(ColorToRGB(EndColor));
-      gc2 := GetGValue(ColorToRGB(EndColor));
-      bc2 := GetBValue(ColorToRGB(EndColor));
-
-      rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-      gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-      bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-      if rc3 &lt; 0 then rc3 := 0 else if rc3 &gt; 255 then rc3 := 255;
-      if gc3 &lt; 0 then gc3 := 0 else if gc3 &gt; 255 then gc3 := 255;
-      if bc3 &lt; 0 then bc3 := 0 else if bc3 &gt; 255 then bc3 := 255;
-
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-          Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-          Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-          Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-          Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then Result := BtnItemColors[bisHot, ipText]
-    else Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              GradientFill(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-            end else
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              GradientGlass(Canvas,R, Aqua, rmkThemes.tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end else
-            begin
-              GradientGlass(Canvas,R, Aqua, rmkThemes.tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              GradientGlass(Canvas,R, Aqua, rmkThemes.tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-              InflateRect(R, 1, 1);
-            end else
-            begin
-              InflateRect(R, -1, -1);
-              GradientSpecial(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X - 2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, false);
-              Pen.Color := clSilver;
-            end else
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-              begin
-                RadioGradient(Canvas.Handle, R, BaseColor, clWhite, true);
-                Pen.Color := BtnItemColors[bisHot, ipFrame];
-              end else
-              begin
-                RadioGradient(Canvas.Handle, R, BaseColor, clWhite, true);
-                Pen.Color := BtnItemColors[bisHot, ipFrame];
-              end;
-            InflateRect(R, 1, 1);
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y + 3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y + 11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y + 9)]);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-              InflateRect(R, 1, 1);
-            end else
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, false);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y + 3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y + 11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y + 9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-}
-
-procedure TTBXNexos3Theme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  Color, Hi, Lo, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY: PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolBarColor, False,
-        VT_UNKNOWN);
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          while R.Top &lt; R.Bottom - 1 do
-          begin
-            Canvas.Pixels[R.Right, R.Top] := ToolbarSeparatorColor;
-            R.Top := R.Top + 3;
-          end;
-        end;
-      SBP_GRIPPER:
-        if DottedGrip then
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end
-        else
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Hi := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Lo := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexos3Theme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-{$ifndef DTM_Package}
-
-initialization
-  MenuButtons := false;
-  AltCaption := true;
-  CaptionOutline := false;
-  DottedGrip := false;
-  SelGradient := 1;
-  BarLines := true;
-  HotColor := clBlack;
-  DarkAqua := false;
-  Aqua := true;
-
-  BaseColor := $00E0A030; // Should not be changed but... :)
-  BaseShade := clSilver;
-  RegisterTBXTheme('Nexos3', TTBXNexos3Theme);
-
-{$endif}
-end.
-

Deleted: Lobby/TASClient/Themes/TBXNexos4Theme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXNexos4Theme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXNexos4Theme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2992 +0,0 @@
-unit TBXNexos4Theme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Nexos4' TBX theme &#169; 2004 Roy Magne Klever
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-// Version for TBX version 2.1
-// Last updated: 02.12.2004
-
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE}
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXNexos4Theme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  MenuButtons, BarLines, AltCaption,
-    CaptionOutline, DottedGrip, AltButton: boolean;
-  SelGradient: integer;
-  BaseColor, BaseShade, SelColor: TColor;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-  GradientBmp: TBitmap;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXNexos4Theme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right);
-    Inc(Bottom);
-  end;
-end;
-
-function TTBXNexos4Theme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXNexos4Theme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := 5;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXNexos4Theme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXNexos4Theme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXNexos4Theme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-var
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then
-    rc3 := 0
-  else if rc3 &gt; 255 then
-    rc3 := 255;
-  if gc3 &lt; 0 then
-    gc3 := 0
-  else if gc3 &gt; 255 then
-    gc3 := 255;
-  if bc3 &lt; 0 then
-    bc3 := 0
-  else if bc3 &gt; 255 then
-    bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GradientBmp.Width := 1;
-    GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-    GSize := GradientBmp.Height;
-
-    y1 := GSize div 2;
-    for i := 0 to y1 - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[0] := GradCol;
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for i := y1 to GSize - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc3 + (((rc2 - rc3) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc3 + (((gc2 - gc3) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc3 + (((bc2 - bc3) * (i)) div GSize));
-      Row[0] := GradCol;
-    end;
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end
-  else
-  begin
-    GradientBmp.Width := (ARect.Right - ARect.Left) - 1;
-    GradientBmp.Height := 1;
-    GSize := GradientBmp.Width;
-
-    y1 := GSize div 2;
-    Row := PRGBTripleArray(GradientBmp.ScanLine[0]);
-    for i := 0 to y1 - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[i] := GradCol;
-    end;
-
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-
-    for i := y1 to GSize - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc2 + (((rc3 - rc2) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc2 + (((gc3 - gc2) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc2 + (((bc3 - bc2) * (i)) div GSize));
-      Row[i] := GradCol;
-    end;
-
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom
-        - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXNexos4Theme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXNexos4Theme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXNexos4Theme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXNexos4Theme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) =
-    TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2; {1} // rmkO
-      Border.Y := 2;
-    end
-    else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXNexos4Theme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXNexos4Theme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-const
-  STRIPE_STEP = 3;
-var
-  HighlightColor: TColor;
-  ShadowColor: TColor;
-  Y, I: Integer;
-  R: TRect;
-begin
-  with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if not RectVisible(Handle, R) then
-      Exit;
-    if (AViewType and DPVT_NORMAL = DPVT_NORMAL)
-      or ((AViewType and VT_TOOLBAR = VT_TOOLBAR)
-      and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else if not Transparent then
-    begin
-      I := ColorIntensity(AColor);
-      if I &lt; 200 then
-        I := (200 - I) div 20
-      else
-        I := 0;
-      HighlightColor := GetNearestColor(Handle, Lighten(AColor, 8 + I));
-      ShadowColor := GetNearestColor(Handle, Lighten(AColor, -8));
-
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-        Y := (R.Top - ARect.Top) mod STRIPE_STEP;
-        Y := R.Top - Y;
-        while Y &lt; ARect.Bottom do
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, ShadowColor);
-          Inc(Y);
-          DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, HighlightColor);
-          Inc(Y, STRIPE_STEP - 1);
-        end;
-      end;
-    end;
-
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if (ItemInfo.ViewType and TVT_MENUBAR = TVT_MENUBAR)
-    and (ItemInfo.HoverKind &lt;&gt; hkNone)
-      and (MenuButtons = false) then
-      Font.Color := MenuItemColors[misHot, ipText]
-    else
-    begin
-      C:= Font.Color;
-      if (ItemInfo.ComboPart = cpSplitLeft) and (ItemInfo.IsPopupParent) then
-        if C = clNone then C := clBlack
-      else
-        if C = clNone then C := GetPartColor(ItemInfo, ipText);
-      Font.Color := C;
-    end;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := clBlack //clWhite //GetBtnColor(ItemInfo, ipText);
-  else if not ItemInfo.Enabled then
-    Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXNexos4Theme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then
-      //FrameRectEx(Canvas.Handle, R, BtnItemColors[bisPressed, ipFrame])
-    else if BtnHot then // Do nothing...
-    else if Embedded then
-    begin
-      FillRectEx(Canvas.Handle, R, ToolBarColor);
-      FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-    end
-    else
-      FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-          if SelGradient &lt;&gt; 0 then
-            FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom)
-          else
-            DitherRect(Canvas.Handle, R, clWindow, $00FFF0F0)
-        else
-          PaintEnabled(R, BtnPressed);
-      end;
-      if BtnDisabled then
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame], True);
-          // rmk Mod
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      // Upper button
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient(Canvas, BR, clWhite, BaseShade, TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite,
-              TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button...
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient(Canvas, BR, clWhite, BaseShade, TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite,
-              TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-
-    {
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and (EBSS_UP or EBSS_DOWN)) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        // Up button...
-        if (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0 then
-        begin
-          BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-          if BtnPressed then
-            if SelGradient &lt;&gt; 0 then
-              FillGradient(Canvas.Handle, BR, clWhite, BaseShade, TGTopBottom)
-            else
-              DitherRect(Canvas, R, clWindow, $00fff0f0)
-          else
-          if BtnHot then
-            if SelGradient &lt;&gt; 0 then
-              FillGradient(Canvas.Handle, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom)
-            else
-              DitherRect(Canvas, R, clWindow, $00fff0f0);
-        end else
-
-        // Down button...
-        if (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0 then
-        begin
-          BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-          if BtnPressed then
-            if SelGradient &lt;&gt; 0 then
-              FillGradient(Canvas.Handle, BR, clWhite, BaseShade, TGTopBottom)
-            else
-              DitherRect(Canvas, R, clWindow, $00fff0f0)
-          else
-          if BtnHot then
-            if SelGradient &lt;&gt; 0 then
-              FillGradient(Canvas.Handle, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom)
-            else
-              DitherRect(Canvas, R, clWindow, $00fff0f0);
-        end else
-      end;
-      BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-      PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0);
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame]);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      if not BtnDisabled then Pen.Color:= clBlack;
-      if BtnHot then Pen.Color:= clWhite;
-      if BtnPressed then Pen.Color:= clBlack;
-      Brush.Color := Pen.Color;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (3 * R.Top + R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      if not BtnDisabled then Pen.Color:= clBlack;
-      if BtnHot then Pen.Color:= clWhite;
-      if BtnPressed then Pen.Color:= clBlack;
-      Brush.Color := Pen.Color;
-
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (R.Top + 3 * R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-    end;
-    }
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-    Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end
-    else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXNexos4Theme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then
-      Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1;
-      RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := Blend(clHighLight, clWindow, 20);
-      end
-      else
-        Pen.Color := Blend(clHighLight, clWindow, 15);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-          ipBody], False, VT_UNKNOWN);
-      // alt vesion
-      {
-      begin
-        Pen.Color := PopupFrameColor;
-        Canvas.Brush.Style := bsClear;
-        with R do Canvas.Rectangle(Left, Top, Right, Bottom);
-      end;
-      }
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-      begin
-        FillRectEx(Canvas.Handle, R, clWhite);
-        Pen.Color := $00A0A0A0; //BaseColor;
-      end
-      else
-      begin
-        FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end;
-
-      // ---
-      if (Selected and Pushed) then
-      begin
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end
-      else if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      begin
-        FillGradient(Canvas, R, SelColor, clWhite, TGTopBottom);
-        Pen.Color := BaseColor;
-      end;
-
-      // ---
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, RL, RR);
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), clWhite,
-        TGTopBottom);
-      InflateRect(R, 1, 1);
-      Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R, R2: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := WinFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack; //WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := PnlFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack; //PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    // Caption
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      // Alt caption...
-      if AltCaption then
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom) // rmkB
-      else
-      begin
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, False, VT_UNKNOWN);
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-          BarSepColor);
-      end;
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      R.Bottom := R.Bottom - 1;
-
-      // rmkNew
-      if CaptionOutline then
-      begin
-        Font.Color := gradCol1; //BaseColor;
-        R2 := R;
-        for y := -2 to 1 do
-          for x := -1 to 1 do
-          begin
-            R2.Top := R.Top + y;
-            R2.Left := R.Left + x;
-            DrawText(Canvas.Handle, WindowInfo.Caption, -1, R2,
-              DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX);
-          end;
-        Font.Color := CaptionText;
-      end;
-
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX);
-    end;
-
-    // Close button
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      if AltCaption then
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom) // rmkB
-      else
-      begin
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, False, VT_UNKNOWN);
-        DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom - 1, R.Right, R.Bottom -
-          1, BarSepColor);
-      end;
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        if AltCaption then
-        begin
-          FrameRectEx(Canvas.Handle, R, clBlack, True);
-          DrawButtonBitmap(Canvas, R, clWhite);
-        end
-        else
-        begin
-          FrameRectEx(Canvas.Handle, R, clGray, True);
-          FillRectEx(Canvas.Handle, R, clWhite);
-          DrawButtonBitmap(Canvas, R, clBlack);
-        end;
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        if AltCaption then
-        begin
-          FillGradient(Canvas, R, clWhite, BaseColor, TGTopBottom);
-          FrameRectEx(Canvas.Handle, R, BaseColor, True);
-          DrawButtonBitmap(Canvas, R, clBlack);
-        end
-        else
-        begin
-          FrameRectEx(Canvas.Handle, R, clGray, True);
-          FillRectEx(Canvas.Handle, R, clSilver);
-          DrawButtonBitmap(Canvas, R, clWhite);
-        end;
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        if not AltCaption then
-          FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-        if AltCaption then
-          DrawButtonBitmap(Canvas, R, clWhite
-            {BtnItemColors[BtnItemState, ipText]})
-        else
-          DrawButtonBitmap(Canvas, R, clBlack
-            {BtnItemColors[BtnItemState, ipText]});
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-  //Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    //Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    //  ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected {or Embedded} or (HoverKind &lt;&gt; hkNone) or
-      // rmkO? Embedded ?
-    ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, GetPartColor(ItemInfo, ipBody), gradCol2,
-        TGTopBottom);
-      if Pushed then
-        Canvas.Pen.Color := BtnItemColors[bisSelected, ipFrame]
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-function TTBXNexos4Theme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXNexos4Theme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-    Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-        //if Selected or Pushed then OffsetRect(ARect, 1, 1) else
-      begin // rmk Removed the shadows under the glyphs and added back 14.04.2003
-        {
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-        }
-
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 14.04.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXNexos4Theme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do
-    if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-        ipBody], False, VT_UNKNOWN);
-    end;
-end;
-
-procedure TTBXNexos4Theme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-    TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then
-        Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1;
-        RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-      begin
-        if ((Pushed or Selected) and Enabled) or ShowHover then
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-            ipBody], False, VT_UNKNOWN);
-        end;
-        Exit;
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          FillRectEx(Canvas.Handle, R, clWhite);
-          Pen.Color := $00A0A0A0; //BaseColor;
-          //FillGradient(Canvas, R, BaseShade, clWhite, TGTopBottom)
-          //Pen.Color := BtnItemColors[bisSelected, ipFrame]
-        end
-        else
-        begin
-          FillRectEx(Canvas.Handle, R, clWhite);
-          Pen.Color := BaseColor;
-          //FillGradient(Canvas, R, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-          //Pen.Color := BaseColor; //BtnItemColors[bisHot, ipFrame]; // rmkP
-        end;
-        InflateRect(R, 1, 1);
-        RoundFrame(Canvas, R, 2, 2);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40); //rmkO
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then
-        PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := clWhite //GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := R;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      InflateRect(R, -1, -1); // smaller button in menu? rmkP
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      Top := (Bottom div 2);
-      while Left &lt; Right do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Left := Left + 3;
-      end;
-    end
-    else if enabled then
-    begin
-      Left := (Right div 2); // - 1;
-      while Top &lt; Bottom do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Top := Top + 3;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    R.Top := R.Top - 1;
-    PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-      if BarLines then
-      begin
-        if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            clgray);
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom
-            - 1, BarSepColor);
-        end
-        else
-        begin
-          DrawLineEx(Canvas.Handle, R.Left + 1, R.Bottom - 1, R.Right, R.Bottom
-            - 1, BarSepColor); // Bottom
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 2, R.Right - 1, R.Bottom
-            - 1, BarSepColor); // Right
-        end;
-      end
-      else
-      begin
-        R2 := R;
-        while R2.Left &lt; R.Right do
-        begin
-          Canvas.Pixels[R2.Left, R.Bottom - 1] := BarSepColor;
-          R2.Left := R2.Left + 3;
-        end;
-        R2 := R;
-        while R2.Top &lt; R.Bottom - 1 do
-        begin
-          Canvas.Pixels[R2.Right - 1, R2.Top] := BarSepColor;
-          R2.Top := R2.Top + 3;
-        end;
-      end;
-    R.Top := R.Top + 1;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    {
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Left, DragHandleOffsets[BtnVisible, ToolbarInfo.DragHandleStyle]);
-        if BtnVisible then Inc(R2.Top, Sz - 2);
-        R2.Right := R2.Left + 3;
-      end
-      else
-      begin
-        Inc(R2.Top, DragHandleOffsets[BtnVisible, ToolbarInfo.DragHandleStyle]);
-        if BtnVisible then Dec(R2.Right, Sz - 2);
-        R2.Bottom := R2.Top + 3;
-      end;
-
-      Pen.Color := DragHandleColor;
-      if Horz then
-      begin
-        I := R2.Top + 3;
-        while I &lt; R2.Bottom - 3 do
-        begin
-          Pen.Color := $00c0c0c0;
-          MoveTo(R2.Left, I); LineTo(R2.Right, I);
-          Pen.Color := clWhite;
-          MoveTo(R2.Left, I + 1); LineTo(R2.Right, I + 1);
-          Inc(I, 3);
-        end;
-        Pen.Color := $00808080;//$00A0A0A0;
-        MoveTo(R2.Left, R2.Top + 3); LineTo(R2.Left, R.Bottom-3);
-        Pen.Color := clWhite;
-        MoveTo(R2.Right, R2.Top + 3); LineTo(R2.Right, R.Bottom-3);
-      end
-      else
-      begin
-        I := R2.Left + 3;
-        while I &lt; R2.Right - 3 do
-        begin
-          Pen.Color := clGray;
-          MoveTo(I, R2.Top); LineTo(I, R2.Bottom);
-          Pen.Color := clWhite;
-          MoveTo(I + 1, R2.Top); LineTo(I + 1, R2.Bottom);
-          Inc(I, 2);
-        end;
-      end;
-    end;
-    }
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := $00F0F0F0;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXNexos4Theme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags, X, Y: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      if AltCaption then
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom) // rmkB
-      else
-      begin
-        FillGradient(Canvas, R, $00F0F0F0, gradCol2, TGTopBottom); // rmkB
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-          BarSepColor);
-      end;
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      if AltCaption then
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGLeftRight) // rmkB
-      else
-      begin
-        FillGradient(Canvas, R, $00F0F0F0, gradCol2, TGLeftRight); // rmkB
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom,
-          BarSepColor);
-      end;
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        if AltCaption then
-        begin
-          FrameRectEx(Canvas.Handle, R2, clBlack, True);
-          DrawButtonBitmap(Canvas, R2, clWhite);
-        end
-        else
-        begin
-          FrameRectEx(Canvas.Handle, R2, clGray, True);
-          FillRectEx(Canvas.Handle, R2, clWhite);
-          DrawButtonBitmap(Canvas, R2, clBlack);
-        end;
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        if AltCaption then
-        begin
-          if IsVertical then
-            FillGradient(Canvas, R2, clWhite, BaseColor, TGTopBottom)
-          else
-            FillGradient(Canvas, R2, clWhite, BaseColor, TGLeftRight);
-          FrameRectEx(Canvas.Handle, R2, BaseColor, True);
-          DrawButtonBitmap(Canvas, R2, clBlack);
-        end
-        else
-        begin
-          FrameRectEx(Canvas.Handle, R2, clGray, True);
-          FillRectEx(Canvas.Handle, R2, clSilver);
-          DrawButtonBitmap(Canvas, R2, clWhite);
-        end;
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        if not AltCaption then
-          FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-        if AltCaption then
-          DrawButtonBitmap(Canvas, R2, clWhite
-            {BtnItemColors[BtnItemState, ipText]})
-        else
-          DrawButtonBitmap(Canvas, R2, clBlack
-            {BtnItemColors[BtnItemState, ipText]});
-      end;
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    if AltCaption then
-      Font.Color := clWhite
-    else
-      Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    // rmkNew
-    if CaptionOutline then
-    begin
-      R2 := R;
-      C := Font.Color;
-      Font.Color := gradCol1; //BaseColor;
-      R2 := R;
-      for y := -2 to 1 do
-        for x := -1 to 1 do
-        begin
-          R2.Top := R.Top + y;
-          R2.Left := R.Left + x;
-          if IsVertical then
-            DrawText(Canvas.Handle, Caption, -1, R2, Flags)
-          else
-            DrawRotatedText(Canvas.Handle, string(Caption), R2, Flags);
-        end;
-      Font.Color := C;
-    end;
-
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXNexos4Theme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := clSilver;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-
-  gradBL := NearestMixedColor(clGray, gradCol1, 64);
-
-  MenubarColor := $00F4F4F4;
-  ToolbarColor := $00F4F4F4;
-
-  PopupColor := clWhite;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clSilver;
-
-  BarSepColor := $A0A0A0; //clGray;
-
-  EditFrameColor := Blend(clSilver, clWhite, 80);
-  EditFrameDisColor := Blend(clSilver, clWhite, 50);
-  ;
-
-  HotBtnFace := Blend(BaseColor, clWhite, 80);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  //SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-  WinFrameColors[wfsActive, wfpCaption] := clSilver;
-  WinFrameColors[wfsActive, wfpCaptionText] := clWhite;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clGray, 180);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  PnlFrameColors[wfsActive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive,
-    wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clGray;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clGray, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clSilver;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clBlack;
-  //SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody], 180);
-  BtnItemColors[bisHot, ipFrame] := Blend(BaseColor, clWhite, 80);
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clWhite;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText],
-    BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BaseColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBlack;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BaseColor;
-  MenuItemColors[misHot, ipText] := clBlack;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGray, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(clGray, clWhite, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := clBlack;
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXNexos4Theme.GetPopupShadowType: Integer;
-begin
-  //Result := PST_OFFICEXP;
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXNexos4Theme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXNexos4Theme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXNexos4Theme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXNexos4Theme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-    Canvas.Pen.Color := BaseColor;
-  end
-  else
-  begin
-    Canvas.Brush.Color := ToolBarColor;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := NearestMixedColor(clWhite, clGray, 64);
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clSilver;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clSilver;
-    Canvas.Pixels[Left, Bottom + 1] := clSilver;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if hot then
-    Canvas.Pen.Color := clWhite
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXNexos4Theme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const Canvas: TCanvas; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: boolean);
-  var
-    i: integer;
-  begin
-    rc1 := GetRValue(ColorToRGB(StartColor));
-    gc1 := GetGValue(ColorToRGB(StartColor));
-    bc1 := GetBValue(ColorToRGB(StartColor));
-    rc2 := GetRValue(ColorToRGB(EndColor));
-    gc2 := GetGValue(ColorToRGB(EndColor));
-    bc2 := GetBValue(ColorToRGB(EndColor));
-
-    rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-    gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-    bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-    if rc3 &lt; 0 then
-      rc3 := 0
-    else if rc3 &gt; 255 then
-      rc3 := 255;
-    if gc3 &lt; 0 then
-      gc3 := 0
-    else if gc3 &gt; 255 then
-      gc3 := 255;
-    if bc3 &lt; 0 then
-      bc3 := 0
-    else if bc3 &gt; 255 then
-      bc3 := 255;
-
-    if NewG then
-    begin
-      GradientBmp.Width := 1;
-      GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-      GSize := GradientBmp.Height;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-          Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-          Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-          Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-          Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end
-    else
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      for i := 0 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc1 + (((rc2 - rc1) * i) div GSize)),
-          Byte(gc1 + (((gc2 - gc1) * i) div GSize)),
-          Byte(bc1 + (((bc2 - bc1) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom
-          - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                FillGradient2(Canvas.Handle, R, clWhite, BaseShade {BaseColor},
-                  TGTopBottom)
-              else
-                FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              if AltButton then
-              begin
-                FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-                Pen.Color := BtnItemColors[bisHot, ipFrame];
-              end
-              else
-              begin
-                FillGradient2(Canvas.Handle, R, clWhite, {BaseShade} BaseColor,
-                  TGTopBottom);
-                Pen.Color := clSilver;
-              end;
-            end
-            else
-            begin
-              FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              FillGradient(Canvas, R, BaseShade, clWhite, TGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end
-            else
-              Pen.Color := clSilver;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                RadioGradient(Canvas, R, clWhite, BaseShade {BaseColor}, false)
-              else
-                RadioGradient(Canvas, R, clWhite, BaseShade {BaseColor}, true);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              if AltButton then
-              begin
-                RadioGradient(Canvas, R, BaseColor, clWhite, true);
-                Pen.Color := BtnItemColors[bisHot, ipFrame];
-              end
-              else
-              begin
-                RadioGradient(Canvas, R, clWhite, BaseColor, false);
-                Pen.Color := clSilver;
-              end;
-            end
-            else
-            begin
-              RadioGradient(Canvas, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                  3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                  9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                  11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                  11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                  9)]);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas, R, BaseShade, clWhite, true);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end
-            else
-              Pen.Color := clSilver;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                  3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                  9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                  11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                  11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                  9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexos4Theme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  Color, Hi, Lo, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolBarColor, False,
-            VT_UNKNOWN);
-          //DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right, R.Top, BarSepColor); // rmkO
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          while R.Top &lt; R.Bottom - 1 do
-          begin
-            Canvas.Pixels[R.Right, R.Top] := ToolbarSeparatorColor;
-            R.Top := R.Top + 3;
-          end;
-        end;
-      SBP_GRIPPER:
-        if DottedGrip then
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end
-        else
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Hi := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Lo := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexos4Theme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  MenuButtons := false;
-  AltCaption := false;
-  AltButton := true;
-  CaptionOutline := false;
-  DottedGrip := false;
-  SelGradient := 1;
-  BarLines := true;
-  //BaseColor:= $00D09020;  // Summer occean
-  BaseColor := $0020D090; // Summer bris
-  //BaseColor:= $0020B0D0;
-  //BaseColor:= $0000D0E5;
-//  BaseColor:= $0000C0E5;
-  //  BaseColor:= $00D5C590;
-  //BaseColor:= $00E065A5;
-  //BaseColor:= $0065E0A5;
-  //BaseColor:= $005585E0;
-  //BaseColor := $00E0A565; // Aqua...
-  //BaseColor:= Blend(clHighlight, clWhite, 80);
-  //BaseColor:= Blend(Blend(clgreen, clYellow, 40), clRed, 65);
-  //BaseColor:= $00a0a0a0;
-  // BaseColor:= $00E0A030;
-  //BaseColor:= $ecd8c0;
-  //BaseColor:= $dac5bc;
-  BaseColor := $F6DAC9;
-  BaseShade := clSilver;
-  SelColor := Blend(BaseColor, BaseShade, 90);
-  RegisterTBXTheme('Nexos4', TTBXNexos4Theme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXNexos5Theme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXNexos5Theme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXNexos5Theme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2648 +0,0 @@
-unit TBXNexos5Theme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// $Id: TBXOfficeXPTheme.pas,v 1.55 2002/12/24 04:32:45 Alex Exp $
-//
-// Modified OfficeXP theme by Roy Magne Klever - I named it 'NEXOS2'
-//
-// 10.05.2003 - &#169; Roy Magne Klever
-//              <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//              First version.
-//
-// 13.05.2003 - &#169; Roy Magne Klever
-//              <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//              Version2.
-//
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-{*$DEFINE SMALL_CLOSE_BUTTON}// remove the asterisk for smaller close button size
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXNexos5Theme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function  GetBooleanMetrics(Index: Integer): Boolean; override;
-    function  GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint; override;
-    function  GetIntegerMetrics(Index: Integer): Integer; override;
-    function  GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor; override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function  GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function  GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins); override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean); override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect; DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect; ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer); override;
-  end;
-
-var
-  MenuButtons, BarLines, AltCaption,
-  CaptionOutline, DottedGrip, AltButton: boolean;
-  SelGradient: integer;
-  BaseColor, BaseShade, SelColor: TColor;
-
-{$IFDEF DTM_Package}
-function TBXThemeName: shortstring; stdcall;
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-{$ENDIF}
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-{$IFDEF DTM_Package}
-exports
-  TBXThemeName,
-  TBXRegisterTheme;
-
-const
-  cThemeName = 'Nexos5';
-
-function TBXThemeName: shortstring; stdcall;
-begin
-  result := cThemeName;
-end;
-
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-begin
-  if RegisterTheme then
-    RegisterTBXTheme(cThemeName, TTBXNexos5Theme)
-  else
-    UnregisterTBXTheme(cThemeName);
-end;
-{$ENDIF}
-
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-  GradientBmp: TBitmap;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0, clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXNexos5Theme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right); Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right); Inc(Bottom);
-  end;
-end;
-
-function TTBXNexos5Theme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN:         Result := False;
-    TMB_PAINTDOCKBACKGROUND:       Result:= True;
-    TMB_SOLIDTOOLBARNCAREA:        Result:= True;
-    TMB_SOLIDTOOLBARCLIENTAREA:    Result:= True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXNexos5Theme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := 5;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXNexos5Theme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then Result := MenubarColor
-    else Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then Result := clWindow
-    else Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then Result := DockPanelColor;
-end;
-
-function TTBXNexos5Theme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then B := bisPressed
-    else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then Result := clWindowFrame
-        else if (Result = clNone) then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXNexos5Theme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then M := MFlags1[HoverKind = hkKeyboardHover]
-      else M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then B := bisPopupParent
-      else if Pushed then B := bisPressed
-      else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then Result := ToolbarColor;
-        if ItemPart = ipFrame then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-var
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then rc3 := 0 else if rc3 &gt; 255 then rc3 := 255;
-  if gc3 &lt; 0 then gc3 := 0 else if gc3 &gt; 255 then gc3 := 255;
-  if bc3 &lt; 0 then bc3 := 0 else if bc3 &gt; 255 then bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GradientBmp.Width := 1;
-    GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-    GSize := GradientBmp.Height;
-
-    y1 := GSize div 2;
-    for i := 0 to y1 - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[0] := GradCol;
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for i := y1 to GSize - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc3 + (((rc2 - rc3) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc3 + (((gc2 - gc3) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc3 + (((bc2 - bc3) * (i)) div GSize));
-      Row[0] := GradCol;
-    end;
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end else
-  begin
-    GradientBmp.Width := (ARect.Right - ARect.Left) - 1;
-    GradientBmp.Height := 1;
-    GSize := GradientBmp.Width;
-
-    y1 := GSize div 2;
-    Row := PRGBTripleArray(GradientBmp.ScanLine[0]);
-    for i := 0 to y1 - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[i] := GradCol;
-    end;
-
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-
-    for i := y1 to GSize - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc2 + (((rc3 - rc2) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc2 + (((gc3 - gc2) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc2 + (((bc3 - bc2) * (i)) div GSize));
-      Row[i] := GradCol;
-    end;
-
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end else begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter, ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div 2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXNexos5Theme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXNexos5Theme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXNexos5Theme.GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXNexos5Theme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2; {1} // rmkO
-      Border.Y := 2;
-    end else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else SetBorder(2, 2);
-  end
-  else SetBorder(0, 0);
-end;
-
-procedure TTBXNexos5Theme.GetMargins(MarginID: Integer; out Margins: TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXNexos5Theme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-const
-  STRIPE_STEP = 5;
-var
-  ShadowColor: TColor;
-  Y: Integer;
-  R: TRect;
-begin
-  with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if not RectVisible(Handle, R) then Exit;
-    if (AViewType and DPVT_NORMAL = DPVT_NORMAL)
-      or ((AViewType and VT_TOOLBAR = VT_TOOLBAR)
-      and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else
-      if not Transparent then
-      begin
-        ShadowColor := GetNearestColor(Handle, Lighten(AColor, - 12));
-        if not Transparent then
-        begin
-          Brush.Color := AColor;
-          FillRect(R);
-          Y := (R.Top - ARect.Top) mod STRIPE_STEP;
-          Y := R.Top - Y;
-          while Y &lt; ARect.Bottom do
-          begin
-            DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, ShadowColor);
-            Inc(Y, STRIPE_STEP);
-          end;
-        end;
-      end;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if (ItemInfo.ViewType and TVT_MENUBAR = TVT_MENUBAR)
-    and (ItemInfo.HoverKind &lt;&gt; hkNone)
-      and (MenuButtons = false) then
-      Font.Color := MenuItemColors[misHot, ipText]
-    else
-    begin
-      C:= Font.Color;
-      if (ItemInfo.ComboPart = cpSplitLeft) and (ItemInfo.IsPopupParent) then
-        if C = clNone then C := clBlack
-      else
-        if C = clNone then C := GetPartColor(ItemInfo, ipText);
-      Font.Color := C;
-    end;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := clBlack //clWhite //GetBtnColor(ItemInfo, ipText);
-  else
-    if not ItemInfo.Enabled then
-      Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-    else
-      Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y - 2)]);
-end;
-
-procedure TTBXNexos5Theme.PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then //FrameRectEx(Canvas, R, BtnItemColors[bisPressed, ipFrame])
-    else
-      if BtnHot then // Do nothing...
-      else
-        if Embedded then
-        begin
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-        end
-        else FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-          if SelGradient &lt;&gt; 0 then
-            FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom)
-          else
-            DitherRect(Canvas.Handle, R, clWindow, $00FFF0F0)
-        else
-          PaintEnabled(R, BtnPressed);
-      end;
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame], True);
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      // Upper button
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient(Canvas, BR, clWhite, BaseShade, TGTopBottom)
-          else
-            if BtnHot then
-              FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button...
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient(Canvas, BR, clWhite, BaseShade, TGTopBottom)
-          else
-            if BtnHot then
-              FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-
-
-    {
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and (EBSS_UP or EBSS_DOWN)) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        // Up button...
-        if (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0 then
-        begin
-          BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-          if BtnPressed then
-            if SelGradient &lt;&gt; 0 then
-              FillGradient(Canvas.Handle, BR, clWhite, BaseShade, TGTopBottom)
-            else
-              DitherRect(Canvas, R, clWindow, $00fff0f0)
-          else
-          if BtnHot then
-            if SelGradient &lt;&gt; 0 then
-              FillGradient(Canvas.Handle, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom)
-            else
-              DitherRect(Canvas, R, clWindow, $00fff0f0);
-        end else
-
-        // Down button...
-        if (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0 then
-        begin
-          BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-          if BtnPressed then
-            if SelGradient &lt;&gt; 0 then
-              FillGradient(Canvas.Handle, BR, clWhite, BaseShade, TGTopBottom)
-            else
-              DitherRect(Canvas, R, clWindow, $00fff0f0)
-          else
-          if BtnHot then
-            if SelGradient &lt;&gt; 0 then
-              FillGradient(Canvas.Handle, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom)
-            else
-              DitherRect(Canvas, R, clWindow, $00fff0f0);
-        end else
-      end;
-      BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-      PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0);
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame]);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      if not BtnDisabled then Pen.Color:= clBlack;
-      if BtnHot then Pen.Color:= clWhite;
-      if BtnPressed then Pen.Color:= clBlack;
-      Brush.Color := Pen.Color;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (3 * R.Top + R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      if not BtnDisabled then Pen.Color:= clBlack;
-      if BtnHot then Pen.Color:= clWhite;
-      if BtnPressed then Pen.Color:= clBlack;
-      Brush.Color := Pen.Color;
-
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (R.Top + 3 * R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-    end;
-    }
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXNexos5Theme.PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1; RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := Blend(clHighLight, clWindow, 20);
-      end
-      else
-        Pen.Color := Blend(clHighLight, clWindow, 15);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot, ipBody], False, VT_UNKNOWN);
-        // alt vesion
-        {
-        begin
-          Pen.Color := PopupFrameColor;
-          Canvas.Brush.Style := bsClear;
-          with R do Canvas.Rectangle(Left, Top, Right, Bottom);
-        end;
-        }
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-      begin
-        FillRectEx(Canvas.Handle, R, clWhite);
-        Pen.Color := $00a0a0a0;//BaseColor;
-      end else
-      begin
-        //FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end;
-
-      // ---
-      if (Selected and Pushed) then
-      begin
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end else
-      if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      begin
-        FillGradient(Canvas, R, SelColor, clWhite, TGTopBottom);
-        Pen.Color := BaseColor;
-      end;
-
-      // ---
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, RL, RR);
-    end
-    else
-      if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        InflateRect(R, -1, -1);
-        FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), clWhite, TGTopBottom);
-        InflateRect(R, 1, 1);
-        Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom - Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := WinFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack;
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := clBlack
-      else
-        CaptionText := clBlack;
-    end;
-
-    // Caption
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-
-      FillGradient2(Canvas.Handle, R, $00d0d0d0, $00f0f0f0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom-1, R.Right, R.Bottom-1, BarSepColor);
-
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      R.Bottom := R.Bottom - 1;
-
-      Font.Color := CaptionText;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX);
-    end;
-
-    // Close button
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      //DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom, BodyColor);
-      Brush.Color := CaptionColor;
-      FillGradient2(Canvas.Handle, R, $00d0d0d0, $00f0f0f0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left -1, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        if AltCaption then
-        begin
-          InflateRect(R, -1, -1);
-          FillGradient(Canvas, R, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-          Pen.Color := BtnItemColors[bisHot, ipFrame];
-          RoundFrame(Canvas, R, 1, 1);
-          DrawButtonBitmap(Canvas, R, clWhite);
-        end else
-        begin
-          FrameRectEx(Canvas.Handle, R, clGray, True);
-          FillRectEx(Canvas.Handle, R, clWhite);
-          DrawButtonBitmap(Canvas, R, clBlack);
-        end;
-      end else
-        if BtnItemState = bisPressed then
-        begin
-          if AltCaption then
-          begin
-            InflateRect(R, -1, -1);
-            FillGradient2(Canvas.Handle, R, $00f0f0f0, $00d0d0d0, TGTopBottom);
-            Canvas.Pen.Color:= clSilver;
-            RoundFrame(Canvas, R,1,1);
-            DrawButtonBitmap(Canvas, R, clBlack);
-          end else
-          begin
-            FrameRectEx(Canvas.Handle, R, clGray, True);
-            FillRectEx(Canvas.Handle, R, clSilver);
-            DrawButtonBitmap(Canvas, R, clWhite);
-          end;
-        end else
-        begin
-          FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-          if not AltCaption then
-            FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-          if AltCaption then
-            DrawButtonBitmap(Canvas, R, clBlack {BtnItemColors[BtnItemState, ipText]})
-          else
-            DrawButtonBitmap(Canvas, R, clBlack {BtnItemColors[BtnItemState, ipText]});
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-  //Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    //Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    //  ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected {or Embedded} or (HoverKind &lt;&gt; hkNone) or // rmkO? Embedded ?
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, GetPartColor(ItemInfo, ipBody), gradCol2, TGTopBottom);
-      if Pushed then
-        Canvas.Pen.Color := BtnItemColors[bisSelected, ipFrame]
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-
-function TTBXNexos5Theme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXNexos5Theme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex, IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178} 255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXNexos5Theme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-    (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot, ipBody], False, VT_UNKNOWN);
-    end;
-end;
-
-procedure TTBXNexos5Theme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1; RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-      begin
-        if ((Pushed or Selected) and Enabled) or ShowHover then
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot, ipBody], False, VT_UNKNOWN);
-        end;
-        Exit;
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          FillRectEx(Canvas.Handle, R, clWhite);
-          Pen.Color := $00a0a0a0;//BaseColor;
-        end else
-        begin
-          FillRectEx(Canvas.Handle, R, clWhite);
-          Pen.Color := clGray;//BaseColor;
-        end;
-        InflateRect(R, 1, 1);
-        RoundFrame(Canvas, R, 2, 2);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40); //rmkO
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then Pen.Color := clWhite //GetPartColor(ItemInfo, ipFrame)
-      else Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2:= ARect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      InflateRect(R, -1, -1); // smaller button in menu? rmkP
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then Left := R.Left - 1;
-            if Right &gt;= R.Right then Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then Left := R.Left - 1;
-            if Right &gt;= R.Right then Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      Top := (Bottom div 2);
-      while Left &lt; Right do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Left := Left + 3;
-      end;
-    end else if enabled then
-    begin
-      Left := (Right div 2); // - 1;
-      while Top &lt; Bottom do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Top := Top + 3;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0, 1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1: TColor;
-  I, J: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    R.Top := R.Top - 3;
-    PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-    R.Top:= R.Top + 2;
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW)
-      then
-      if BarLines then
-      begin
-        if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor);
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, BarSepColor);
-        end else
-        begin
-          DrawLineEx(Canvas.Handle, R.Left + 1, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor); // Bottom
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 2, R.Right - 1, R.Bottom - 1, BarSepColor); // Right
-        end;
-      end else
-      begin
-        R2 := R;
-        while R2.Left &lt; R.Right do
-        begin
-          Canvas.Pixels[R2.Left, R.Bottom - 1] := BarSepColor;
-          R2.Left := R2.Left + 3;
-        end;
-        R2 := R;
-        while R2.Top &lt; R.Bottom - 1 do
-        begin
-          Canvas.Pixels[R2.Right - 1, R2.Top] := BarSepColor;
-          R2.Top := R2.Top + 3;
-        end;
-      end;
-    R.Top := R.Top + 1;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then R.Right := R.Left + Sz
-    else R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-
-    Hi1 := $00afafaf;
-    Lo1 := $00cecac7;
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then j:= 4 else j:= 2;
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pen.Color:= hi1;
-          MoveTo(R2.Left,i);
-          LineTo(R2.Left + j,i);
-          //Pixels[R2.Left + 1, i]:= clGray;
-          Pen.Color:= lo1;
-          MoveTo(R2.Left,i + 1);
-          LineTo(R2.Left + j,i + 1);
-          Pixels[R2.Left + 1, i + 1]:= Hi1;
-          Inc(i, 4);
-        end;
-      end else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pen.Color:= hi1;
-          MoveTo(i, R2.Top);
-          LineTo(i + j, R2.Top);
-          Pen.Color:= lo1;
-          MoveTo(i, R2.Top + 1);
-          LineTo(i + j, R2.Top + 1);
-          Inc(i, 4);
-          {
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-          }
-        end;
-      end;
-    end;
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var R: TRect;
-begin
-  Canvas.Pen.Width:= 0;
-  Canvas.Brush.Style:= bsSolid;
-  Canvas.Brush.Color:= $00f0f0f0;
-  R:= DockRect;
-  InFlateRect(R, 1,1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXNexos5Theme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags, X, Y: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then Pixels[Right - 1, Top] := clBtnFace
-        else Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then Pixels[Right - 1, Top] := C
-        else Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      if AltCaption then
-      begin
-        //FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom) // rmkB
-        FillGradient2(Canvas.Handle, R, $00d0d0d0, $00f0f0f0, TGTopBottom); // rmkB
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor);
-      end else
-      begin
-        FillGradient(Canvas, R, $00f0f0f0, gradCol2, TGTopBottom); // rmkB
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor);
-      end;
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      if AltCaption then
-      begin
-        //FillGradient(Canvas, R, gradCol1, gradCol2, TGLeftRight) // rmkB
-        FillGradient2(Canvas.Handle, R, $00d0d0d0, $00f0f0f0, TGLeftRight); // rmkB
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom, BarSepColor);
-      end else
-      begin
-        FillGradient(Canvas, R, $00f0f0f0, gradCol2, TGLeftRight); // rmkB
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom, BarSepColor);
-      end;
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient(Canvas, R2, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        Pen.Color := BtnItemColors[bisHot, ipFrame];
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end else
-      if BtnItemState = bisPressed then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient2(Canvas.Handle, R2, $00f0f0f0, $00d0d0d0, TGTopBottom);
-        Pen.Color := clSilver;
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-        DrawButtonBitmap(Canvas, R2, clBlack {BtnItemColors[BtnItemState, ipText]})
-      end;
-    end;
-
-    if IsVertical then InflateRect(R, -4, 0)
-    else InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    if AltCaption then
-      Font.Color := clBlack//clWhite
-    else
-      Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    // rmkNew
-    if CaptionOutline then
-    begin
-      R2 := R;
-      C := Font.Color;
-      Font.Color := gradCol1; //BaseColor;
-      R2 := R;
-      for y := -2 to 1 do
-        for x := -1 to 1 do
-        begin
-          R2.Top := R.Top + y;
-          R2.Left := R.Left + x;
-          if IsVertical then DrawText(Canvas.Handle, Caption, -1, R2, Flags)
-          else DrawRotatedText(Canvas.Handle, string(Caption), R2, Flags);
-        end;
-      Font.Color := C;
-    end;
-
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXNexos5Theme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := $00909090;//clSilver;
-  gradHandle2 := $00d8d4d0;//{{clSilver;//clGray;
-  gradHandle3 := $00d0d0d0;//clWhite;
-
-  gradBL := NearestMixedColor(clGray, gradCol1, 64);
-
-  MenubarColor := clWhite;//$00F4F4F4;
-  ToolbarColor := clWhite;//$00F4F4F4;
-
-  PopupColor := clWhite;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clSilver;
-
-  BarSepColor := $a8a8a8; //clGray;
-
-  EditFrameColor := Blend(clSilver, clWhite, 80);
-  EditFrameDisColor := Blend(clSilver, clWhite, 50); ;
-
-  HotBtnFace := Blend(BaseColor, clWhite, 80);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  //SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-  WinFrameColors[wfsActive, wfpCaption] := clSilver;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clGray, 180);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  PnlFrameColors[wfsActive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive, wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clGray;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clGray, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clSilver;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clBlack;
-  //SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody], 180);
-  BtnItemColors[bisHot, ipFrame] := Blend(BaseColor, clWhite, 80);
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clWhite;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText], BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame], BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BaseColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBlack;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BaseColor;
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];//clBlack;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGray, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(clGray, clWhite, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := clBlack;
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXNexos5Theme.GetPopupShadowType: Integer;
-begin
-  //Result := PST_OFFICEXP;
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXNexos5Theme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXNexos5Theme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXNexos5Theme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXNexos5Theme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-    Canvas.Pen.Color := BaseColor;
-  end
-  else
-  begin
-    Canvas.Brush.Color := ToolBarColor;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := NearestMixedColor(clWhite, clGray, 64);
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clSilver;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clSilver;
-    Canvas.Pixels[Left, Bottom + 1] := clSilver;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if hot then
-    Canvas.Pen.Color := clWhite
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXNexos5Theme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-  y1, i, GSize: Integer;
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const Canvas: TCanvas; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: boolean);
-  var
-    i: integer;
-  begin
-    rc1 := GetRValue(ColorToRGB(StartColor));
-    gc1 := GetGValue(ColorToRGB(StartColor));
-    bc1 := GetBValue(ColorToRGB(StartColor));
-    rc2 := GetRValue(ColorToRGB(EndColor));
-    gc2 := GetGValue(ColorToRGB(EndColor));
-    bc2 := GetBValue(ColorToRGB(EndColor));
-
-    rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-    gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-    bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-    if rc3 &lt; 0 then rc3 := 0 else if rc3 &gt; 255 then rc3 := 255;
-    if gc3 &lt; 0 then gc3 := 0 else if gc3 &gt; 255 then gc3 := 255;
-    if bc3 &lt; 0 then bc3 := 0 else if bc3 &gt; 255 then bc3 := 255;
-
-    if NewG then
-    begin
-      GradientBmp.Width := 1;
-      GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-      GSize := GradientBmp.Height;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-            Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-            Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i],  ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-            Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-            Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end else
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      for i := 0 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * i) div GSize)),
-            Byte(gc1 + (((gc2 - gc1) * i) div GSize)),
-            Byte(bc1 + (((bc2 - bc1) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then Result := BtnItemColors[bisHot, ipText]
-    else Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1); LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom)
-              else
-                FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-            end else
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end else
-            begin
-              FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              FillGradient(Canvas, R, BaseShade, clWhite, TGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end else
-              Pen.Color := clSilver;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X - 2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                RadioGradient(Canvas, R, clWhite, BaseShade, false)
-              else
-                RadioGradient(Canvas, R, clWhite, BaseShade, true);
-              Pen.Color := clSilver;
-            end else
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              RadioGradient(Canvas, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end else
-            begin
-              RadioGradient(Canvas, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style:= bsClear;
-            X:= R.Left;
-            Y:= R.Top;
-            Polygon([Point(X, Y + 8),      Point(X, Y + 4),      Point(X + 1, Y + 3),
-                     Point(X + 1, Y + 2),  Point(X + 2, Y + 1),  Point(X + 3, Y + 1),
-                     Point(X + 4, Y),      Point(X + 8, Y),      Point(X + 9, Y + 1),
-                     Point(X + 10, Y + 1),  Point(X + 11, Y + 2),  Point(X + 11, Y + 3),
-                     Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                     Point(X + 11, Y + 10),  Point(X + 10, Y + 11),  Point(X + 9, Y + 11),
-                     Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                     Point(X + 2, Y + 11),  Point(X + 1, Y + 10),  Point(X + 1, Y + 9)]);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas, R, BaseShade, clWhite, true);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end else
-              Pen.Color := clSilver;
-
-            Brush.Style:= bsClear;
-            X:= R.Left;
-            Y:= R.Top;
-            Polygon([Point(X, Y + 8),      Point(X, Y + 4),      Point(X + 1, Y + 3),
-                     Point(X + 1, Y + 2),  Point(X + 2, Y + 1),  Point(X + 3, Y + 1),
-                     Point(X + 4, Y),      Point(X + 8, Y),      Point(X + 9, Y + 1),
-                     Point(X + 10, Y + 1),  Point(X + 11, Y + 2),  Point(X + 11, Y + 3),
-                     Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                     Point(X + 11, Y + 10),  Point(X + 10, Y + 11),  Point(X + 9, Y + 11),
-                     Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                     Point(X + 2, Y + 11),  Point(X + 1, Y + 10),  Point(X + 1, Y + 9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexos5Theme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  Color, Hi, Lo, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D - 2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolBarColor, False, VT_UNKNOWN);
-          //DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right, R.Top, BarSepColor); // rmkO
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          while R.Top &lt; R.Bottom - 1 do
-          begin
-            Canvas.Pixels[R.Right, R.Top] := ToolbarSeparatorColor;
-            R.Top := R.Top + 3;
-          end;
-        end;
-      SBP_GRIPPER:
-        if DottedGrip then
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end else
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Hi := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Lo := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexos5Theme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then SetupColorCache;
-end;
-
-{$IFNDEF DTM_Package}
-initialization
-  MenuButtons := false;
-  AltCaption := true;
-  AltButton := false;
-  CaptionOutline := false;
-  DottedGrip := false;
-  SelGradient := 1;
-  BarLines := true;
-  BaseColor := $00E0A565; // Aqua...
-  BaseColor:= $f6dac9;
-  BaseShade := clSilver;
-  SelColor := Blend(BaseColor, BaseShade, 90);
-  RegisterTBXTheme('Nexos5', TTBXNexos5Theme);
-{$ENDIF}
-end.
-

Deleted: Lobby/TASClient/Themes/TBXNexosXTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXNexosXTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXNexosXTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2784 +0,0 @@
-unit TBXNexosXTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'NexosX' TBX theme &#169; 2004 Roy Magne Klever
-//
-//  Last updated: 02.12.2004
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-
-type
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXNexosXTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-      override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated:
-      Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  MenuButtons, BarLines, AltCaption,
-    CaptionOutline, DottedGrip, AltButton: boolean;
-  SelGradient: integer;
-  BaseColor, BaseShade: TColor;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms,
-  rmkThemes, TBXUxThemes;
-
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-  GradientBmp: TBitmap;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXNexosXTheme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right);
-    Inc(Bottom);
-  end;
-end;
-
-function TTBXNexosXTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXNexosXTheme.GetIntegerMetrics(Index: Integer): Integer;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-
-    TMI_MENU_IMGTEXTSPACE: Result := 3;
-    TMI_MENU_LCAPTIONMARGIN: Result := 3;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-
-    TMI_TLBR_SEPARATORSIZE: Result := 5;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := -1;
-  end;
-end;
-
-function TTBXNexosXTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXNexosXTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled,
-    bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected,
-    bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXNexosXTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled,
-    misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled,
-    bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected,
-    bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-var
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then
-    rc3 := 0
-  else if rc3 &gt; 255 then
-    rc3 := 255;
-  if gc3 &lt; 0 then
-    gc3 := 0
-  else if gc3 &gt; 255 then
-    gc3 := 255;
-  if bc3 &lt; 0 then
-    bc3 := 0
-  else if bc3 &gt; 255 then
-    bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GradientBmp.Width := 1;
-    GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-    GSize := GradientBmp.Height;
-
-    y1 := GSize div 2;
-    for i := 0 to y1 - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[0] := GradCol;
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for i := y1 to GSize - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc3 + (((rc2 - rc3) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc3 + (((gc2 - gc3) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc3 + (((bc2 - bc3) * (i)) div GSize));
-      Row[0] := GradCol;
-    end;
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end
-  else
-  begin
-    GradientBmp.Width := (ARect.Right - ARect.Left) - 1;
-    GradientBmp.Height := 1;
-    GSize := GradientBmp.Width;
-
-    y1 := GSize div 2;
-    Row := PRGBTripleArray(GradientBmp.ScanLine[0]);
-    for i := 0 to y1 - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[i] := GradCol;
-    end;
-
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-
-    for i := y1 to GSize - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc2 + (((rc3 - rc2) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc2 + (((gc3 - gc2) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc2 + (((bc3 - bc2) * (i)) div GSize));
-      Row[i] := GradCol;
-    end;
-
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom
-        - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXNexosXTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXNexosXTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXNexosXTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXNexosXTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) =
-    TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2; {1} // rmkO
-      Border.Y := 2;
-    end
-    else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXNexosXTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXNexosXTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-const
-  STRIPE_STEP = 3;
-var
-  HighlightColor: TColor;
-  ShadowColor: TColor;
-  Y, I: Integer;
-  R: TRect;
-begin
-  with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if not RectVisible(Handle, R) then
-      Exit;
-    if (AViewType and DPVT_NORMAL = DPVT_NORMAL)
-      or ((AViewType and VT_TOOLBAR = VT_TOOLBAR)
-      and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else if not Transparent then
-    begin
-      I := ColorIntensity(AColor);
-      if I &lt; 200 then
-        I := (200 - I) div 20
-      else
-        I := 0;
-      HighlightColor := GetNearestColor(Handle, Lighten(AColor, 8 + I));
-      ShadowColor := GetNearestColor(Handle, Lighten(AColor, -8));
-
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-        Y := (R.Top - ARect.Top) mod STRIPE_STEP;
-        Y := R.Top - Y;
-        while Y &lt; ARect.Bottom do
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, ShadowColor);
-          Inc(Y);
-          DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, HighlightColor);
-          Inc(Y, STRIPE_STEP - 1);
-        end;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if (ItemInfo.ViewType and TVT_MENUBAR = TVT_MENUBAR)
-    and (ItemInfo.HoverKind &lt;&gt; hkNone)
-      and (MenuButtons = false) then
-      Font.Color := MenuItemColors[misHot, ipText]
-    else
-    begin
-      C:= Font.Color;
-      if (ItemInfo.ComboPart = cpSplitLeft) and (ItemInfo.IsPopupParent) then
-        if C = clNone then C := clBlack
-      else
-        if C = clNone then C := GetPartColor(ItemInfo, ipText);
-      Font.Color := C;
-    end;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText)
-  else if not ItemInfo.Enabled then
-    Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXNexosXTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  var
-    C: TColor;
-  begin
-    if BtnDisabled then
-      C:= EditFrameDisColor
-    else
-      C:= EditFrameColor;
-    if Embedded then
-    begin
-      FillRectEx(Canvas.Handle, R, ToolBarColor);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end
-    else
-      FrameRectEx(Canvas.Handle, R, C, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-        begin
-          GradientGlass(Canvas, R, True, True, TGTopBottom);
-          Pen.Color:= BaseColor;
-        end
-        else
-        if BtnHot then
-        begin
-          GradientGlass(Canvas, R, True, TGTopBottom);
-          Pen.Color:= BaseColor;
-        end
-        else
-        begin
-          PaintEnabled(R, BtnPressed);
-        end;
-      end;
-      if BtnDisabled then
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame],
-          True);
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color:= BaseShade;
-      if not BtnDisabled then
-      begin
-        MoveTo(R.Left, R.Top);
-        LineTo(R.Left, R.Bottom);
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      // Upper button
-      Pen.Color:= BaseShade;
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-          begin
-            GradientGlass(Canvas, BR, True, True, TGTopBottom);
-            Pen.Color:= BaseColor;
-          end
-          else
-          if BtnHot then
-          begin
-            GradientGlass(Canvas, BR, True, TGTopBottom);
-            Pen.Color:= BaseColor;
-          end
-        end;
-        if (not BtnPressed) and (not BtnHot) then
-          Pen.Color:= BaseShade;
-        MoveTo(BR.Left, BR.Top);
-        LineTo(BR.Left, BR.Bottom);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button...
-      Pen.Color:= BaseShade;
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-          begin
-            GradientGlass(Canvas, BR, True, True, TGTopBottom);
-            Pen.Color:= BaseColor;
-          end
-          else
-          if BtnHot then
-          begin
-            GradientGlass(Canvas, BR, True, TGTopBottom);
-            Pen.Color:= BaseColor;
-          end;
-        end;
-        if (not BtnPressed) and (not BtnHot) then
-          Pen.Color:= BaseShade;
-        MoveTo(BR.Left, BR.Bottom - 1);
-        LineTo(BR.Left, BR.Top);
-        LineTo(BR.Right, BR.Top);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-    Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-         Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end
-    else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXNexosXTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then
-      Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1;
-      RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := Blend(clHighLight, clWindow, 20);
-      end
-      else
-        Pen.Color := Blend(clHighLight, clWindow, 15);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-          ipBody], False, VT_UNKNOWN);
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed then
-      begin
-        if HoverKind = hkNone then
-        begin
-          FillGradient(Canvas, R, BaseShade, $00B0B0B0, TGTopBottom);
-          InflateRect(R, 1, 1);
-          ButtonFrame(Canvas, R, RL, RR, $00484848, $00888888, $00A0A0A0);
-          Pen.Color := $00969696;
-          MoveTo(R.Left + RL, R.Top + 1);
-          LineTo(R.Right - RR, R.Top + 1);
-        end
-        else
-        begin
-          FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-          Pen.Color := $00E6E6E6;
-          MoveTo(R.Left, R.Top);
-          LineTo(R.Right, R.Top);
-          InflateRect(R, 1, 1);
-          ButtonFrame(Canvas, R, RL, RR, $00808080, clNone, $00A0A0A0);
-        end;
-      end
-      else
-      begin
-        FillGradient(Canvas, R, $00D0D0D0, $00B0B0B0, TGTopBottom);
-        InflateRect(R, 1, 1);
-        ButtonFrame(Canvas, R, RL, RR, $00484848, $00888888, $00CDCDCD);
-        Pen.Color := $00E6E6E6;
-        MoveTo(R.Left + RL, R.Top + 1);
-        LineTo(R.Right - RR, R.Top + 1);
-      end;
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, clWhite, $00E0E0E0, TGTopBottom);
-      InflateRect(R, 1, 1);
-      if RL = 2 then
-      begin
-        Pen.Color := $00D0D0D0;
-        RoundFrame(Canvas, R, 1, 1)
-      end
-      else
-      begin
-        Pen.Color := $00E8E8E8;
-        RoundFrame(Canvas, R, 0, 0);
-      end;
-      InflateRect(R, -1, -1);
-      Pen.Color := $00F6F6F6;
-      MoveTo(R.Left, R.Top);
-      LineTo(R.Right, R.Top);
-      Pen.Color := $00B0B0B0;
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive,
-    wfsActive);
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left - 1, Top - 1), Point(Right, Top - 1),
-              Point(Right, Bottom), Point(Left - 1, Bottom),
-              Point(Left - 1, Top - 1)])
-        else
-          Canvas.Polyline([
-            Point(Left - 1, Top - 1), Point(Right, Top - 1),
-              Point(Right, Bottom), Point(Left - 1, Bottom),
-              Point(Left - 1, Top - 1)]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      CaptionText := clBlack
-    else
-      CaptionText := clBlack;
-
-    // Caption
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      FillGradient2(Canvas.Handle, R, $00D0D0D0, $00F0F0F0, TGTopBottom);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-        BarSepColor);
-
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      R.Bottom := R.Bottom - 1;
-
-      Font.Color := CaptionText;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX);
-    end;
-
-    // Close button
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y - 1);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      R.Top := R.Top + 1;
-      FillGradient2(Canvas.Handle, R, $00D0D0D0, $00F0F0F0, TGTopBottom);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BarSepColor);
-      R.Top := R.Top - 1;
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        InflateRect(R, -1, -1);
-        GradientGlass(Canvas, R, true, TGTopBottom);
-        Pen.Color := BtnItemColors[bisHot, ipFrame];
-        RoundFrame(Canvas, R, 1, 1);
-        DrawButtonBitmap(Canvas, R, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        InflateRect(R, -1, -1);
-        FillGradient2(Canvas.Handle, R, $00F0F0F0, $00D0D0D0, TGTopBottom);
-        Canvas.Pen.Color := clSilver;
-        RoundFrame(Canvas, R, 1, 1);
-        DrawButtonBitmap(Canvas, R, clBlack);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        //if not AltCaption then
-        FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-        DrawButtonBitmap(Canvas, R, clBlack);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-begin
-  R:= ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected or (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      GradientGlass(Canvas, R, True, TGTopBottom);
-      if Pushed then
-        Canvas.Pen.Color := BaseColor //BtnItemColors[bisSelected, ipFrame]
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-function TTBXNexosXTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXNexosXTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-  Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      //if not (Selected or Pushed and not IsPopupParent) then
-      if Selected or Pushed then
-        OffsetRect(ARect, 1, 1)
-      else
-      begin
-        {
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-        }
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 14.04.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXNexosXTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do
-    if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-        ipBody], False, VT_UNKNOWN);
-    end;
-end;
-
-procedure TTBXNexosXTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-    TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then
-        Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1;
-        RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-      begin
-        if ((Pushed or Selected) and Enabled) or ShowHover then
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-            ipBody], False, VT_UNKNOWN);
-        end;
-        Exit;
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          FillGradient(Canvas, R, BaseShade, $00A0A0A0, TGTopBottom);
-          InflateRect(R, 1, 1);
-          Pen.Color := $00A6A6A6;
-          RoundFrame(Canvas, R, 1, 1);
-          Pen.Color := $00484848;
-          RoundFrame(Canvas, R, 2, 2);
-
-          Pen.Color := $00888888;
-          MoveTo(R.Left + 2, R.Bottom - 1);
-          LineTo(R.Right - 3, R.Bottom - 1);
-          LineTo(R.Right - 1, R.Bottom - 3);
-          LineTo(R.Right - 1, R.Top + 1);
-
-          InflateRect(R, -1, -1);
-          Pen.Color := $00969696;
-          MoveTo(R.Left + 1, R.Top);
-          LineTo(R.Right - 1, R.Top);
-        end
-        else
-        begin
-          FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-          InflateRect(R, 1, 1);
-          Pen.Color := $00A0A0A0;
-          RoundFrame(Canvas, R, 1, 1);
-          InflateRect(R, -1, -1);
-          Pen.Color := $00E6E6E6;
-          MoveTo(R.Left, R.Top);
-          LineTo(R.Right, R.Top);
-          Pen.Color := $00808080;
-          InflateRect(R, 1, 1);
-          RoundFrame(Canvas, R, 2, 2);
-        end;
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40); //rmkO
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then
-        PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-
-    R := ARect;
-    if (ImageWidth &gt; 0) or Selected then
-      Inc(R.Left, ItemInfo.PopupMargin + MenuImageTextSpace);
-    PaintMenuItemFrame(Canvas, R, ItemInfo);
-
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := clWhite //GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := R;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  if enabled then
-  begin
-    if Horizontal then
-    begin
-      Top := (Bottom div 2);
-      while Left &lt; Right do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Left := Left + 3;
-      end;
-    end
-    else
-    begin
-      Left := (Right div 2); // - 1;
-      while Top &lt; Bottom do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Top := Top + 3;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2,
-    0, 1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz, DHSize: Integer;
-  R2: TRect;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-  I: Integer;
-  C1, C2, C3, c4, c5: TColor;
-begin
-  with Canvas do
-  begin
-    R.Top := R.Top - 1;
-    PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (ToolbarInfo.ViewType = VT_TOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-      if BarLines then
-      begin
-        if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-        begin
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            clgray);
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom
-            - 1, BarSepColor);
-        end
-        else
-        begin
-          DrawLineEx(Canvas.Handle, R.Left + 1, R.Bottom - 1, R.Right, R.Bottom
-            - 1, BarSepColor); // Bottom
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 2, R.Right - 1, R.Bottom
-            - 1, BarSepColor); // Right
-        end;
-      end
-      else
-      begin
-        R2 := R;
-        while R2.Left &lt; R.Right do
-        begin
-          Canvas.Pixels[R2.Left, R.Bottom - 1] := BarSepColor;
-          R2.Left := R2.Left + 3;
-        end;
-        R2 := R;
-        while R2.Top &lt; R.Bottom - 1 do
-        begin
-          Canvas.Pixels[R2.Right - 1, R2.Top] := BarSepColor;
-          R2.Top := R2.Top + 3;
-        end;
-      end;
-    R.Top := R.Top + 1;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    // Drag Handle
-    DHSize := GetTBXDragHandleSize(ToolbarInfo);
-    if Horz then
-      R.Right := R.Left + DHSize
-    else
-      R.Bottom := R.Top + DHSize;
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-
-      c1 := $00999999;
-      c2 := $00A6A6A6;
-      c3 := $00B0B0B0;
-      c4 := $00FCFCFC;
-      c5 := $00D8E0E4;
-
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Left, DragHandleOffsets[BtnVisible,
-          ToolbarInfo.DragHandleStyle]);
-        if BtnVisible then
-          Inc(R2.Top, Sz - 2);
-        I:= R2.Top + 2;
-        while i &lt; R2.Bottom - 5 do
-        begin
-          Pixels[R2.Left    , i]:= c1;
-          Pixels[R2.Left + 1, i]:= c2;
-          Pixels[R2.Left + 2, i]:= c3;
-          Pixels[R2.Left   ,  i + 1]:= c4;
-          Pixels[R2.Left + 1, i + 1]:= c5;
-          Pixels[R2.Left + 2, i + 1]:= c5;
-          inc(i, 2);
-        end;
-        Pixels[R2.Left    , i]:= c1;
-        Pixels[R2.Left + 1, i]:= c2;
-        Pixels[R2.Left + 2, i]:= c3;
-
-        Pen.Color := C2;
-        MoveTo(R2.Left, R2.Top + 2);
-        LineTo(R2.Left, i);
-      end
-      else
-      begin
-        Inc(R2.Top, DragHandleOffsets[BtnVisible, ToolbarInfo.DragHandleStyle]);
-        if BtnVisible then
-          Dec(R2.Right, Sz - 2);
-        i:= R2.Left + 2;
-        while i &lt; R2.Right - 5 do
-        begin
-          Pixels[i, R2.Top    ]:= c1;
-          Pixels[i, R2.Top + 1]:= c2;
-          Pixels[i, R2.Top + 2]:= c3;
-          Pixels[i + 1, R2.Top    ]:= c4;
-          Pixels[i + 1, R2.Top + 1]:= c5;
-          Pixels[i + 1, R2.Top + 2]:= c5;
-          inc(i, 2);
-        end;
-        Pixels[i, R2.Top]:= c1;
-        Pixels[i, R2.Top + 1]:= c2;
-        Pixels[i, R2.Top + 2]:= c3;
-
-        Pen.Color := C2;
-        MoveTo(R2.Left + 2, R2.Top);
-        LineTo(i, R2.Top);
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      R2.Left := R2.Left + 1;
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[bisHot, ipFrame], True);
-        GradientGlass(Canvas, R2, true, TGTopBottom);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        GradientFill(Canvas, R2, clWhite, clSilver, TGTopBottom);
-        FrameRectEx(Canvas.Handle, R2, $00D0D0D0, True);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := $00F0F0F0;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXNexosXTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    R2 := R;
-
-    FrameRectEx(Canvas.Handle, R, $00E0E0E0, True);
-    FrameRectEx(Canvas.Handle, R, C, True);
-    with R do
-    begin
-      Pixels[Left, Top] := $00E0E0E0;
-      if IsVertical then
-        Pixels[Right - 1, Top] := $00E0E0E0
-      else
-        Pixels[Left, Bottom - 1] := $00E0E0E0;
-    end;
-
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clNone;
-      R.Bottom := R.Bottom + 1;
-      FillGradient2(Canvas.Handle, R, $00D0D0D0, $00F0F0F0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-        BarSepColor);
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clNone;
-      R.Right := R.Right + 1;
-      FillGradient2(Canvas.Handle, R, $00D0D0D0, $00F0F0F0, TGLeftRight); // rmkB
-      DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom,
-        BarSepColor);
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        InflateRect(R2, -1, -1);
-        GradientGlass(Canvas, R2, true, TGTopBottom);
-        Pen.Color := BtnItemColors[bisHot, ipFrame];
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient2(Canvas.Handle, R2, $00F0F0F0, $00D0D0D0, TGTopBottom);
-        Pen.Color := clSilver;
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-          True);
-        DrawButtonBitmap(Canvas, R2, clBlack)
-      end;
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXNexosXTheme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := clSilver;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-
-  gradBL := NearestMixedColor(clGray, gradCol1, 64);
-
-  MenubarColor := $00F4F4F4;
-  ToolbarColor := $00F4F4F4;
-
-  PopupColor := clWhite;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clSilver;
-
-  BarSepColor := $A0A0A0;
-
-  EditFrameColor := Blend(clSilver, clWhite, 80);
-  EditFrameDisColor := Blend(clSilver, clWhite, 50);
-
-  HotBtnFace := Blend(BaseColor, clWhite, 80);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  WinFrameColors[wfsActive, wfpCaption] := clSilver;
-  WinFrameColors[wfsActive, wfpCaptionText] := clWhite;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clGray, 180);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  PnlFrameColors[wfsActive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive,
-    wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clGray;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clGray, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clSilver;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clBlack; //clWhite;
-  BtnItemColors[bisHot, ipFrame] := Blend(BaseColor, clWhite, 80);
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clBlack;
-  BtnItemColors[bisSelectedHot, ipFrame] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BaseColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBlack;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BaseColor;
-  MenuItemColors[misHot, ipText] := clWhite;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGray, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(clGray, clWhite, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := clBlack;
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXNexosXTheme.GetPopupShadowType: Integer;
-begin
-  //Result := PST_OFFICEXP;
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXNexosXTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXNexosXTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXNexosXTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXNexosXTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    GradientGlass(Canvas, R, True, tGTopBottom);
-    Canvas.Pen.Color := BaseColor;
-  end
-  else
-  begin
-    Canvas.Brush.Color := ToolBarColor;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := NearestMixedColor(clWhite, clGray, 64);
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clSilver;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clSilver;
-    Canvas.Pixels[Left, Bottom + 1] := clSilver;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if hot then
-    Canvas.Pen.Color := clBlack
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXNexosXTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  DarkAqua: Boolean = False;
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1,
-    3);
-var
-  X, Y: Integer;
-  Aqua: Boolean;
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const DC: HDC; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: Boolean);
-  var
-    GSize: Integer;
-    rc1, rc2, gc1, gc2, bc1, bc2, rc3, gc3, bc3, rc4, gc4, bc4,
-      r, g, b, y1, Counter, i, d1, d2, d3: Integer;
-
-    Brush: HBrush;
-  begin
-    if Aqua then
-    begin
-      rc1 := $F0;
-      rc2 := $80;
-      rc3 := $70;
-      rc4 := $B0;
-      gc1 := $F8;
-      gc2 := $B0;
-      gc3 := $E8;
-      gc4 := $FF;
-      bc1 := $FF;
-      bc2 := $E0;
-      bc3 := $F0;
-      bc4 := $FF;
-    end
-    else
-    begin
-      rc1 := $F8;
-      rc2 := $D8;
-      rc3 := $F0;
-      rc4 := $F8;
-      gc1 := $F8;
-      gc2 := $D8;
-      gc3 := $F0;
-      gc4 := $F8;
-      bc1 := $F8;
-      bc2 := $D8;
-      bc3 := $F0;
-      bc4 := $F8;
-    end;
-
-    if NewG then
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      y1 := GSize div 3;
-      d1 := y1;
-      d2 := y1 + y1;
-      for i := 0 to y1 do
-      begin
-        r := rc1 + (((rc2 - rc1) * (i)) div y1);
-        g := gc1 + (((gc2 - gc1) * (i)) div y1);
-        b := bc1 + (((bc2 - bc1) * (i)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      for i := y1 to d2 do
-      begin
-        r := rc2 + (((rc3 - rc2) * (i - d1)) div y1);
-        g := gc2 + (((gc3 - gc2) * (i - d1)) div y1);
-        b := bc2 + (((bc3 - bc2) * (i - d1)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      for i := d2 to GSize do
-      begin
-        r := rc3 + (((rc4 - rc3) * (i - d2)) div y1);
-        g := gc3 + (((gc4 - gc3) * (i - d2)) div y1);
-        b := bc3 + (((bc4 - bc3) * (i - d2)) div y1);
-        if r &lt; 0 then
-          r := 0
-        else if r &gt; 255 then
-          r := 255;
-        if g &lt; 0 then
-          g := 0
-        else if g &gt; 255 then
-          g := 255;
-        if b &lt; 0 then
-          b := 0
-        else if b &gt; 255 then
-          b := 255;
-        Brush := CreateSolidBrush(
-          RGB(r, g, b));
-        Windows.FillRect(DC, Rect(ARect.Left + Offs[i], ARect.Top + i,
-          ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end
-    else
-    begin
-      rc1 := GetRValue(ColorToRGB(StartColor));
-      gc1 := GetGValue(ColorToRGB(StartColor));
-      bc1 := GetBValue(ColorToRGB(StartColor));
-      rc2 := GetRValue(ColorToRGB(EndColor));
-      gc2 := GetGValue(ColorToRGB(EndColor));
-      bc2 := GetBValue(ColorToRGB(EndColor));
-
-      rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-      gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-      bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-      if rc3 &lt; 0 then
-        rc3 := 0
-      else if rc3 &gt; 255 then
-        rc3 := 255;
-      if gc3 &lt; 0 then
-        gc3 := 0
-      else if gc3 &gt; 255 then
-        gc3 := 255;
-      if bc3 &lt; 0 then
-        bc3 := 0
-      else if bc3 &gt; 255 then
-        bc3 := 255;
-
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-          Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-          Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-          Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-          Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top +
-          i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-begin
-  Aqua := true;
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              GradientFill(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              GradientGlass(Canvas, R, True, tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end
-            else
-            begin
-              GradientGlass(Canvas, R, True, tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              GradientGlass(Canvas, R, True, tGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-              InflateRect(R, 1, 1);
-            end
-            else
-            begin
-              InflateRect(R, -1, -1);
-              GradientGlass(Canvas, R, False, tGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, false);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              RadioGradient(Canvas.Handle, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end
-            else
-            begin
-              RadioGradient(Canvas.Handle, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-              InflateRect(R, 1, 1);
-            end
-            else
-            begin
-              InflateRect(R, -1, -1);
-              Aqua := false;
-              RadioGradient(Canvas.Handle, R, clWhite, BaseShade, true);
-              //RadioGradient(Canvas.Handle, R, clWhite, BaseShade, false);
-              Aqua := true;
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexosXTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolBarColor, False, VT_UNKNOWN);
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          while R.Top &lt; R.Bottom - 1 do
-          begin
-            Canvas.Pixels[R.Right, R.Top] := ToolbarSeparatorColor;
-            R.Top := R.Top + 3;
-          end;
-        end;
-      SBP_GRIPPER:
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(BarSepColor); //LO
-                  DiagLine(clWhite); //HI
-                end;
-              9..12:
-                begin
-                  DiagLine(BarSepColor);
-                  DiagLine(clWhite);
-                  Inc(D);
-                end;
-            else
-              DiagLine(BarSepColor);
-              Inc(D, 1);
-              DiagLine(clWhite);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXNexosXTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  MenuButtons := false;
-  AltCaption := false;
-  AltButton := true;
-  DottedGrip := true;
-  BarLines := true;
-  BaseColor := $00D09020; // Summer occean
-  //BaseColor:= $0020D090;  // Summer bris
-  //BaseColor:= $0020B0D0;
-  //BaseColor:= $0000D0E5;
-  //BaseColor:= $0000C0E5;
-  //BaseColor:= $00D5C590;
-  //BaseColor:= $00E065A5;
-  //BaseColor:= $0065E0A5;
-  //BaseColor:= $005585E0;
-  //BaseColor := $00E0A565; // Aqua...
-  //BaseColor:= Blend(clHighlight, clWhite, 80);
-  //BaseColor:= Blend(Blend(clGreen, clYellow, 40), clRed, 65);
-  BaseShade := clSilver;
-  RegisterTBXTheme('NexosX', TTBXNexosXTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXOffice11AdaptiveTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXOffice11AdaptiveTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXOffice11AdaptiveTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2259 +0,0 @@
-unit TBXOffice11AdaptiveTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// &quot;Adaptive11&quot; TBX theme &#169;2004 Roy Magne Klever
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-// Version for TBX version 2.1
-// Last updated: 23.11.2004
-
-interface
-
-uses
-  SysUtils, Dialogs, Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-{*$DEFINE SMALL_CLOSE_BUTTON}// remove the asterisk for smaller close button size
-
-type
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXAdaptiveInfo = record
-    MenubarColor,
-      UseGradCol1,
-      UseGradCol2,
-      MenuHotColor,
-      MenuTextColor,
-      MenuFrameColor: TColor;
-  end;
-
-  TTBXOffice11AdaptiveTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    DockMixColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    // Other Colors
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  TBXAdaptiveInfo: TTBXAdaptiveInfo;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms, rmkThemes;
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL, gradTL:
-    TColor;
-  GradientBmp: TBitmap;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXOffice11AdaptiveTheme }
-
-function TTBXOffice11AdaptiveTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := True;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXOffice11AdaptiveTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 3;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := DEFAULT;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXOffice11AdaptiveTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := TBXAdaptiveInfo.MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXOffice11AdaptiveTheme.GetBtnColor(const ItemInfo: TTBXItemInfo;
-  ItemPart: TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXOffice11AdaptiveTheme.GetPartColor(const ItemInfo: TTBXItemInfo;
-  ItemPart: TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXOffice11AdaptiveTheme.GetItemColor(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXOffice11AdaptiveTheme.GetItemTextColor(const ItemInfo:
-  TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXOffice11AdaptiveTheme.GetItemImageBackground(const ItemInfo:
-  TTBXItemInfo): TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXOffice11AdaptiveTheme.GetViewBorder(ViewType: Integer; out Border:
-  TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-      Border.X := 1
-    else
-      Border.X := 2;
-    Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXOffice11AdaptiveTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 1;
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintBackgnd(Canvas: TCanvas; const
-  ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-  IsHoriz: boolean;
-begin
-    if not Transparent then
-  begin
-    if ((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-      if IsHoriz then
-      begin
-        R.Top := R.Top - 1;
-        R.Bottom := R.Bottom + 1;
-        GradientFill(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-        R.Bottom := R.Bottom - 1;
-        R.Top := R.Top + 1;
-      end
-      else
-      begin
-        R.Left := R.Left - 1;
-        R.Right := R.Right + 1;
-        GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-        R.Right := R.Right - 1;
-        R.Left := R.Left + 1;
-      end;
-    end
-    else
-    begin
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Left &lt;&gt; ARect.Left) or (ADockRect.Top &lt;&gt; ARect.Top)
-        or (ADockRect.Right &lt;&gt; ARect.Right) or (ADockRect.Bottom &lt;&gt; ARect.Bottom)
-      then
-        GradientFill(Canvas, R, gradCol2, gradCol1, TGLeftRight)
-      else
-        FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    C:= Font.Color;
-    if c= clNone then
-      Font.Color := GetPartColor(ItemInfo, ipText);
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintCheckMark(Canvas: TCanvas; ARect:
-  TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintChevron(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintEditButton(Canvas: TCanvas; const
-  ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-begin
-  R := ARect;
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-  InflateRect(R, 1, 1);
-  Inc(R.Left);
-  with Canvas do
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-          PaintButton(Canvas, R, ItemInfo)
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          R := ARect;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, R, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(R.Left - 1, R.Top);
-          LineTo(R.Left - 1, R.Bottom);
-        end;
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-          PaintButton(Canvas, BR, ItemInfo)
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Top := ARect.Top;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      { Lower button }
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-          PaintButton(Canvas, BR, ItemInfo)
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Bottom := ARect.Bottom;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-  Embedded: Boolean;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-  if not (ItemInfo.Enabled or Embedded) then
-    FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipText], True);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - W);
-
-  if ItemInfo.Enabled then
-  begin
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-      FrameRectEx(Canvas.Handle, R, ToolbarColor, true)
-    else
-    begin
-      Canvas.Brush.Color := clWindow;
-      Canvas.FrameRect(R);
-    end;
-  end;
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-  begin
-    Canvas.Brush.Color := clWindow;
-    Canvas.FillRect(R);
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-    begin
-      Canvas.Brush.Color := clBtnFace; //ToolbarColor;
-      R := ARect;
-      InflateRect(R, -1, -1);
-      Canvas.FrameRect(R);
-    end;
-  end;
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintButton(Canvas: TCanvas; const ARect:
-  TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    if ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) and not Selected then
-    begin
-      Brush.Color := GetNearestColor(Handle, MixColors(clBtnShadow, clBtnFace,
-        100));
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      FrameRect(R);
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      if (ComboPart = cpSplitLeft) and IsPopupParent then
-        Inc(R.Right);
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      if (Selected) and ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) then
-      begin
-        FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-      end
-      else
-        FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-      {
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-        if ((Pushed or Selected) and Enabled) or ((Enabled and (HoverKind &lt;&gt; hkNone)) or (not Enabled and (HoverKind = hkKeyboardHover))) then
-          GradientFill(Canvas, R, GradCol1, GradCol2, TGTopBottom);
-      }
-    end;
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintFloatingBorder(Canvas: TCanvas; const
-  ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := GradTL; // CaptionColor
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      FillRect(R);
-      //GradientFill(Canvas, R, GradCol1, GradCol2, TGTopBottom);
-      //DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, clBlack);
-      //DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-      //  clBlack);
-
-      InflateRect(R, -2, 0);
-      Brush.Style := bsClear;
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      FillRect(R);
-      //GradientFill(Canvas, R, GradCol1, GradCol2, TGTopBottom);
-      //DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom, clBlack);
-      //DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-      //  clBlack);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-      if FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]) then
-        DrawGlyph(BtnItemColors[BtnItemState, ipText])
-      else
-        DrawGlyph(CaptionText);
-    end;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintFrame(Canvas: TCanvas; const ARect:
-  TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  FrameRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipFrame), True);
-  FillRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipBody));
-end;
-
-function TTBXOffice11AdaptiveTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-    Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        // rmk 1.4.2003
-        //DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        //OffsetRect(ARect, 1, 1);
-        //DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        //OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintMDIButton(Canvas: TCanvas; ARect:
-  TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if ((ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX) then
-  begin
-    R.Right := R.Left + ItemInfo.PopupMargin + 2;
-    GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-    Inc(R.Left);
-    R.Right := ARect.Right - 1;
-  end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintMenuItem(Canvas: TCanvas; const ARect:
-  TRect; var ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    if Selected and Enabled then
-    begin
-      R := ARect;
-      R.Left := ARect.Left + 1;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-      //GradientFill(Canvas, R, GetBtnColor(ItemInfo, ipBody), gradCol2, TGTopBottom);
-    end;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect;
-  const PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintSeparator(Canvas: TCanvas; ARect:
-  TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        GradientFill(Canvas, R, gradCol1, gradCol2, tGLeftRight);
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-      // rmkPaint
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clWhite);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, gradCol1);
-      end
-      else
-      begin
-        Top := Bottom div 2;
-        MoveTo(Left, Top);
-        LineTo(Right, Top);
-      end;
-    end
-    else if Enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clWhite);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, gradCol1);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintToolbarNCArea(Canvas: TCanvas; R:
-  TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (ToolbarInfo.ViewType = VT_TOOLBAR)
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      with R do
-      begin
-        if (Toolbarinfo.IsVertical) then
-        begin
-          GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-          R2 := R;
-          R2.Top := R2.Bottom - 1;
-
-          if ToolbarInfo.BorderStyle &lt;&gt; bsSingle then exit;
-
-          GradientFill(Canvas, R2, gradCol1, gradCol2, TGLeftRight);
-
-          Pen.Color := gradBL;
-          MoveTo(Right - 1, Top + 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := gradCol1;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-
-          MoveTo(Left, Bottom - 2);
-          LineTo(Left, Bottom);
-        end
-        else
-        begin
-          GradientFill(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-          R2 := R;
-          R2.Top:= R.Top + 1;
-          R2.Left := R2.Right - 1;
-
-          if ToolbarInfo.BorderStyle &lt;&gt; bsSingle then exit;
-
-          GradientFill(Canvas, R2, GradBL, Blend(gradCol1, gradCol2, 50), TGTopBottom);
-          
-          Pen.Color := gradBL;
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pixels[Left, Top]:= Blend(gradCol1, gradCol2, 60);
-          Pixels[Left, Bottom - 1]:= gradCol1;
-          Pixels[Left, Bottom - 2]:= Blend(gradCol1, gradBL, 50);
-
-          Pixels[Right - 2, Top]:= Blend(gradCol1, gradCol2, 25);
-          Pixels[Right - 1, Bottom - 1]:= gradCol1;
-          Pixels[Right - 2, Bottom - 2]:= Blend(gradCol1, gradBL, 50);
-        end;
-      end;
-      InflateRect(R, -2, -2);
-    end
-    else
-    begin
-      GradientFill(Canvas, R, gradCol2, gradCol1, TGLeftRight);
-      InflateRect(R, -2, -2);
-    end;
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-        if Horz then
-          OffsetRect(R2, -1, 0)
-        else
-          OffsetRect(R2, 0, -1);
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-begin
-  GradientFill(Canvas, DockRect, gradCol2, gradCol1, TGLeftRight);
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintDockPanelNCArea(Canvas: TCanvas; R:
-  TRect; const DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    R2 := R;
-
-    FrameRectEx(Canvas.Handle, R, GradTL, True);
-    FrameRectEx(Canvas.Handle, R, C, True);
-    with R do
-    begin
-      Pixels[Left, Top] := $00E0E0E0;
-      if IsVertical then
-        Pixels[Right - 1, Top] := $00E0E0E0
-      else
-        Pixels[Left, Bottom - 1] := $00E0E0E0;
-    end;
-
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      HeaderColor := clNone;
-      R.Bottom := R.Bottom + 1;
-      GradientFill(Canvas, R, GradCol1, GradCol2, TGTopBottom);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-        clGray);
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      HeaderColor := clNone;
-      R.Right := R.Right + 1;
-      GradientFill(Canvas, R, GradCol1, GradCol2, TGLeftRight);
-      DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom,
-        clGray);
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-  {
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, TBXAdaptiveInfo.MenubarColor, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then Pixels[Right - 1, Top] := clBtnFace
-        else Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then Pixels[Right - 1, Top] := C
-        else Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-    end;
-
-    HeaderColor := TBXAdaptiveInfo.MenubarColor;
-    FillRectEx(Canvas.Handle, R, HeaderColor);
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-
-    if IsVertical then InflateRect(R, -4, 0)
-    else InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsSolid;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-  }
-end;
-
-procedure TTBXOffice11AdaptiveTheme.SetupColorCache;
-var
-  DC: HDC;
-  SwapC, C1, HotBtnFace, DisabledText: TColor;
-  i1, i2: integer;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  if USE_THEMES then
-  begin
-    gradCol1 := Blend(clGradientInactiveCaption, clGradientActiveCaption, 25);
-    gradCol2 := NearestMixedColor(clHighLight, clWindow, 8);
-
-    i1:= ColorIntensity(GradCol1);
-    i2:= ColorIntensity(GradCol2);
-
-    if i1 &gt; i2 then
-    begin
-      SwapC := gradCol1;
-      gradCol1 := gradCol2;
-      gradCol2 := SwapC;
-    end;
-
-    if IsDarkColor(gradCol1) then
-    begin
-      if (i2 - i1) &lt; 30 then
-        gradCol2 := Lighten(gradCol2, (i1 - i2));
-    end
-    else
-    if (i2 - i1) &lt; 30 then
-      gradCol1 := Lighten(gradCol1, (i1 - i2));
-
-    if i2 - i1 &gt; 40 then
-    begin
-      C1:= Blend(gradCol1, gradCol2, 80);
-      gradCol2:= Blend(gradCol1, gradCol2, 20);
-      gradCol1:= C1;
-    end;
-
-    gradHandle1 := NearestMixedColor(clHighLight, gradCol2, 48);
-    gradHandle2 := clHighLight;
-    gradHandle3 := gradCol2;
-
-    gradBL := clHighLight;
-    gradTL := Blend(gradCol1, gradCol2, 50);
-
-    DockMixColor := Blend(gradCol1, gradCol2, 50);
-
-    TBXAdaptiveInfo.MenubarColor := GradTL;
-    ToolbarColor := gradCol2;
-
-    HotBtnFace := Blend(clHighLight, clWindow, 70);
-    SetContrast(HotBtnFace, ToolbarColor, 50);
-
-    DisabledText := Blend(GradTL, clBlack, 75);
-
-    BtnItemColors[bisPressed, ipBody] := Blend(clHighLight, clWindow, 50);
-    BtnItemColors[bisPressed, ipText] := clHighlightText;
-    BtnItemColors[bisPressed, ipFrame] := clHighLight;
-    BtnItemColors[bisHot, ipBody] := HotBtnFace;
-    BtnItemColors[bisHot, ipText] := clHighLightText;
-    BtnItemColors[bisHot, ipFrame] := clHighlight;
-    SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-    MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-    MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-    MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-    TBXAdaptiveInfo.MenuHotColor := MenuItemColors[misHot, ipBody];
-    TBXAdaptiveInfo.MenuTextColor := MenuItemColors[misHot, ipText];
-    TBXAdaptiveInfo.MenuFrameColor := MenuItemColors[misHot, ipFrame];
-  end
-  else
-  begin
-    gradCol1 := clBtnFace;
-    gradCol2 := clWindow;
-    i1 := ColorIntensity(GradCol1);
-    i2 := ColorIntensity(GradCol2);
-
-    if i1 &gt; i2 then
-    begin
-      SwapC := gradCol1;
-      gradCol1 := gradCol2;
-      gradCol2 := SwapC;
-    end;
-
-    if IsDarkColor(gradCol1) then
-    begin
-      if (i2 - i1) &lt; 30 then
-        gradCol2 := Lighten(gradCol2, (i1 - i2));
-    end
-    else if (i2 - i1) &lt; 30 then
-      gradCol1 := Lighten(gradCol1, (i1 - i2));
-
-    gradHandle1 := gradCol1;
-    gradHandle2 := clBtnShadow;
-    gradHandle3 := clBtnHighlight;
-    gradBL := blend(clBtnShadow, gradCol1, 95);
-
-    {
-    gradCol1 := Blend(clBtnShadow, clBtnFace, 10);
-    gradCol2 := clWhite;
-    gradHandle1 := clBtnFace;
-    gradHandle2 := clGray;
-    gradHandle3 := clWhite;
-    gradBL := NearestMixedColor(clBtnShadow, gradCol1, 48);
-    }
-    
-    gradTL := clBtnFace;
-
-
-    TBXAdaptiveInfo.MenubarColor := clBtnFace;
-    ToolbarColor := gradCol2;
-
-    HotBtnFace := Blend(clHighlight, clWindow, 20);
-    SetContrast(HotBtnFace, ToolbarColor, 50);
-
-    DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-    BtnItemColors[bisPressed, ipBody] := Blend(clHighLight, clWindow, 30);
-    BtnItemColors[bisPressed, ipText] := clHighlightText;
-    BtnItemColors[bisPressed, ipFrame] := clHighLight;
-    BtnItemColors[bisHot, ipBody] := HotBtnFace;
-    BtnItemColors[bisHot, ipText] := clMenuText;
-    SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody],
-      180);
-    BtnItemColors[bisHot, ipFrame] := clHighlight;
-    SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-    MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-    MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-    MenuItemColors[misHot, ipFrame] := Blend(clHighLight, clWindow, 50);
-    TBXAdaptiveInfo.MenuHotColor := MenuItemColors[misHot, ipBody];
-    TBXAdaptiveInfo.MenuTextColor := MenuItemColors[misHot, ipText];
-    TBXAdaptiveInfo.MenuFrameColor := MenuItemColors[misHot, ipFrame];
-  end;
-
-  TBXAdaptiveInfo.UseGradCol2 := gradCol2;
-  TBXAdaptiveInfo.UseGradCol1 := gradCol1;
-
-  PopupColor := Blend(clBtnFace, clWindow, 143);
-  DockPanelColor := PopupColor;
-  PopupFrameColor := Blend(clBtnText, clHighLight, 20);
-  SetContrast(PopupFrameColor, PopupColor, 100);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clBtnText, gradCol1, 15);
-  SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-  WinFrameColors[wfsActive, wfpCaption] := TBXAdaptiveInfo.MenubarColor;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := Blend(clBtnText, gradCol1, 30);;
-  PnlFrameColors[wfsActive, wfpCaption] := TBXAdaptiveInfo.MenubarColor;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := clNone;
-
-  BtnItemColors[bisSelected, ipBody] := Blend(clHighLight, Blend(clBtnFace,
-    clWindow, 50), 10);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := clHighLight;
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(clHighlight, clWindow, 50);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clHighlightText;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText],
-    BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := ToolbarColor;
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := PopupFrameColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-  DragHandleColor := Blend(clBtnShadow, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-  ToolbarSeparatorColor := Blend(clBtnShadow, clWindow, 70);
-  SetContrast(ToolbarSeparatorColor, ToolbarColor, 50);
-  PopupSeparatorColor := ToolbarSeparatorColor;
-  StatusPanelFrameColor := Blend(clWindow, clBtnFace, 30);
-  SetContrast(StatusPanelFrameColor, clBtnFace, 30);
-
-  Undither(TBXAdaptiveInfo.MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXOffice11AdaptiveTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_OFFICEXP;
-end;
-
-constructor TTBXOffice11AdaptiveTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXOffice11AdaptiveTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipFrame]
-  else
-    Canvas.Brush.Color := clBtnShadow;
-  Canvas.FrameRect(R);
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-  else
-    Canvas.Brush.Color := clBtnFace;
-  InflateRect(R, -1, -1);
-  Canvas.FillRect(R);
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if Hot then
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipText]
-  else
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintFrameControl(Canvas: TCanvas; R: TRect;
-  Kind, State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Pen.Color := BtnItemColors[bisPressed, ipFrame]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame]
-    else
-      Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Brush.Color := BtnItemColors[bisPressed, ipBody]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-    else if Boolean(State and PFS_MIXED) then
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else
-      Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Rectangle(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-      PFC_RADIOBUTTON:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Ellipse(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.PaintStatusBar(Canvas: TCanvas; R: TRect;
-  Part: Integer);
-var
-  Color, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D: integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, TBXAdaptiveInfo.MenubarColor);
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 2);
-          FrameRectEx(Canvas.Handle, R, StatusPanelFrameColor, True);
-        end;
-      SBP_GRIPPER:
-        begin
-          Color := gradHandle1;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXOffice11AdaptiveTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  RegisterTBXTheme('Office11Adaptive', TTBXOffice11AdaptiveTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXOffice12Theme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXOffice12Theme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXOffice12Theme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2355 +0,0 @@
-unit TBXOffice12Theme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Office12' TBX theme &#169;2004-2007 Roy Magne Klever + Boris Yankov
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-// Version for TBX version 2.1
-//
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE}
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXOffice12Theme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    procedure SetupColorCache; virtual;
-
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-      override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated:
-      Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  GradientMenu: boolean = False;//true;
-  ThemeExtraLightCl, ThemeLightCl, ThemeMediumCl, ThemeDarkCl, ThemeExtraDarkCl: TColor; // very important
-  ThemeDarkestCl: TColor;
-  gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  TBVert: Boolean;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockImgList.Free;
-end;
-
-{ TTBXOffice12Theme }
-
-function TTBXOffice12Theme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False; {true}
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXOffice12Theme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := DEFAULT;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXOffice12Theme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := ThemeExtraLightCl;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXOffice12Theme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := ThemeDarkCl;
-      end;
-    end;
-  end;
-end;
-
-function TTBXOffice12Theme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := ThemeDarkCl;
-      end;
-    end;
-  end;
-end;
-
-function AsByte(Num: Integer): Byte;
-begin
-  if Num &lt; 0 then
-    Result := 0
-  else
-    Result := Num;
-end;
-
-procedure TopBottomGradient(const DC: HDC; bc1: Integer; const ARect: TRect; bc3: Integer; gc3: Integer; rc3: Integer; rc2: Integer; gc1: Integer; gc2: Integer; bc2: Integer; rc1: Integer);
-var
-  Brush: HBRUSH;
-  Counter: Integer;
-  y1: Integer;
-  GSize: Integer;
-  R, G, B: Byte;
-begin
-  GSize := (ARect.Bottom - ARect.Top) - 1;
-  if GSize = 0 then
-    GSize := 1;
-
-  // division by zero fixing
-  y1 := GSize div 2;
-  for Counter := 0 to y1 - 1 do
-  begin
-    Brush := CreateSolidBrush(RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)), Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)), Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-    Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right, ARect.Bottom), Brush);
-    DeleteObject(Brush);
-  end;
-
-  if rc2 &gt; rc1 then
-  begin
-    rc3 := rc2;
-    gc3 := gc2;
-    bc3 := bc2;
-  end;
-
-  for Counter := y1 to GSize do
-  begin
-    R := AsByte(rc3 + (((rc2 - rc3) * (Counter)) div GSize));
-    G := AsByte(gc3 + (((gc2 - gc3) * (Counter)) div GSize));
-    B := AsByte(bc3 + (((bc2 - bc3) * (Counter)) div GSize));
-    Brush := CreateSolidBrush(RGB(R, G, B));
-    Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right, ARect.Bottom), Brush);
-    DeleteObject(Brush);
-  end;
-end;
-
-procedure LeftRightGradient(rc2: Integer; gc2: Integer; bc2: Integer; rc1: Integer; gc1: Integer; bc1: Integer; rc3: Integer; gc3: Integer; bc3: Integer; const DC: HDC; const ARect: TRect);
-var
-  GSize: Integer;
-  y1: Integer;
-  Counter: Integer;
-  Brush: HBRUSH;
-begin
-
-  GSize := (ARect.Right - ARect.Left) - 1;
-  y1 := GSize div 2;
-  for Counter := 0 to y1 - 1 do
-  begin
-    Brush := CreateSolidBrush(RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)), Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)), Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-    Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right, ARect.Bottom), Brush);
-    DeleteObject(Brush);
-  end;
-  if rc2 &gt; rc1 then
-  begin
-    rc3 := rc2;
-    gc3 := gc2;
-    bc3 := bc2;
-  end;
-  Exit;
-  for Counter := y1 to GSize do
-  begin
-    Brush := CreateSolidBrush(RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize)), Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)), Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-    Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right, ARect.Bottom), Brush);
-    DeleteObject(Brush);
-  end;
-end;
-
-procedure FillGradient(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2,
-    rc3, gc3, bc3: Integer;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 8);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 8);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 8);
-
-  if Direction = tGTopBottom then
-    TopBottomGradient(DC, bc1, ARect, bc3, gc3, rc3, rc2, gc1, gc2, bc2, rc1)
-  else
-    LeftRightGradient(rc2, gc2, bc2, rc1, gc1, bc1, rc3, gc3, bc3, DC, ARect);
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2,
-    bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom
-        - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXOffice12Theme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXOffice12Theme.GetItemTextColor(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXOffice12Theme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXOffice12Theme.GetViewBorder(ViewType: Integer; out Border:
-  TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-      Border.X := 1
-    else
-      Border.X := 2;
-    Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXOffice12Theme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXOffice12Theme.PaintBackgnd(Canvas: TCanvas; const ADockRect,
-  ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-  IsHoriz: boolean;
-begin
-  if (not Transparent) then
-  begin
-    {
-    if (((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((AViewType and TVT_MENUBAR) = TVT_MENUBAR) and (GradientMenu = true)))
-      and (not (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    }
-    if ((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-      if IsHoriz then
-      begin
-        TBVert := false;
-        FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGTopBottom)
-      end
-      else
-      begin
-        TBVert := true;
-        FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGLeftRight);
-      end;
-    end
-    else
-    begin
-      //if (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)
-      //or (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)
-      //then
-      TBVert := false;
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-      {
-      if ((AViewType and TVT_NORMALTOOLBAR) &lt;&gt; TVT_NORMALTOOLBAR)
-        and ((AViewType and TVT_MENUBAR) &lt;&gt; TVT_MENUBAR)
-        and ((AViewType and PVT_CHEVRONMENU) &lt;&gt; PVT_CHEVRONMENU)
-        and ((AViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX) then
-      begin
-        R.Right := R.Right - 1;
-        //FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-        R.Right := R.Left + 24;
-        // this value is hardcoded but should be ItemInfo.PopupMargin
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-        //FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      end;
-      }
-    end;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    Font.Color := GetPartColor(ItemInfo, ipText);
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXOffice12Theme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-begin
-  R := ARect;
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-    and ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-  InflateRect(R, 1, 1);
-  Inc(R.Left);
-  with Canvas do
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-          PaintButton(Canvas, R, ItemInfo)
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          R := ARect;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, R, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(R.Left - 1, R.Top);
-          LineTo(R.Left - 1, R.Bottom);
-        end;
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        // rmk 14.04.2003
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient(Canvas.Handle, BR, ThemeLightCl, GetBtnColor(ItemInfo,
-              ipBody), TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipBody),
-              ThemeLightCl, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Top := ARect.Top;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient(Canvas.Handle, BR, ThemeLightCl, GetBtnColor(ItemInfo,
-              ipBody), TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipBody),
-              ThemeLightCl, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Bottom := ARect.Bottom;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-end;
-
-procedure TTBXOffice12Theme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;  
-  Embedded: Boolean;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-  if not (ItemInfo.Enabled or Embedded) then
-    FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipText], True);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 1);
-
-  if ItemInfo.Enabled then
-  begin
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-      FrameRectEx(Canvas.Handle, R, ThemeExtraLightCl, True)
-    else
-    begin
-      Canvas.Brush.Color := clWindow;
-      Canvas.FrameRect(R);
-    end;
-  end
-  else
-    InflateRect(R, -1, -1);
-
-  if ItemInfo.Enabled then
-  begin
-    Canvas.Brush.Color := clWindow;
-    Canvas.FillRect(R);
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-    begin
-      Canvas.Brush.Color := ThemeExtraLightCl;
-      R := ARect;
-      InflateRect(R, -1, -1);
-      Canvas.FrameRect(R);
-    end;
-  end;
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintButton(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    if ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) and not Selected then
-    begin  
-      Brush.Color := GetNearestColor(Handle, MixColors(ThemeDarkCl, ThemeExtraLightCl, 100));
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      FrameRect(R);
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      //if (ComboPart = cpSplitLeft) and IsPopupParent then
-      //  Inc(R.Right);
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      if (Selected) and ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) then
-      begin
-        if IsVertical then
-        begin
-          if ComboPart = cpSplitLeft then
-          begin
-            R2 := R;
-            R2.Right := R2.Right + 12;
-            FillGradient(Canvas.Handle, R2, GetBtnColor(ItemInfo, ipBody),
-              ThemeLightCl, TGLeftRight);
-          end
-          else
-          begin
-            // FOUND: OVER STATE
-            FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-              ThemeLightCl, TGLeftRight);
-          end;
-        end
-        else // FOUND: SELECTED
-          FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-            ThemeLightCl, TGTopBottom);
-      end
-      else
-      begin
-        if (HoverKind &lt;&gt; hkNone) and (((ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-          or ((ViewType and VT_POPUP) = VT_POPUP)) then
-        begin
-          if Pushed then
-          begin
-            if IsVertical then
-            begin
-              if (ComboPart = cpSplitLeft) or (ComboPart = cpSplitRight) then
-              begin
-                if (ComboPart = cpSplitRight) then
-                begin
-                  FillGradient(Canvas.Handle, R, ThemeLightCl, ThemeMediumCl,
-                    TGLeftRight);
-                end
-                else
-                begin
-                  R2 := R;
-                  R2.Right := R.Right + 12;
-                  FillGradient(Canvas.Handle, R2, ThemeLightCl, ThemeMediumCl,
-                    TGLeftRight);
-                end;
-              end
-              else
-                FillGradient(Canvas.Handle, R, ThemeLightCl, ThemeMediumCl, TGLeftRight);
-            end
-            else
-              FillGradient(Canvas.Handle, R, ThemeLightCl, ThemeMediumCl, TGTopBottom);
-          end
-          else if IsVertical then
-          begin
-            if (ComboPart = cpSplitLeft) or (ComboPart = cpSplitRight) then
-            begin
-              if (ComboPart = cpSplitRight) then
-              begin
-                MoveTo(R.Left, R.Top);
-                LineTo(R.Left, R.Bottom);
-              end
-              else
-              begin
-                R2 := R;
-                R2.Right := R.Right + 12;
-                FillGradient(Canvas.Handle, R2, GetBtnColor(ItemInfo, ipBody),
-                  ThemeLightCl, TGLeftRight);
-              end;
-            end
-            else
-              FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-                ThemeLightCl, TGLeftRight);
-          end
-          else
-            FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-              ThemeLightCl, TGTopBottom);
-        end
-        else
-//          FillRectEx(Canvas.Handle, R, $D8C8C1);
-//          FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-      end;
-    end;
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := $00602000;//WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGTopBottom);
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGTopBottom);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-      if FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]) then
-        DrawButtonBitmap(Canvas, R, BtnItemColors[BtnItemState, ipText])
-      else
-        DrawButtonBitmap(Canvas, R, CaptionText);
-    end;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintFrame(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  with ItemInfo do
-    if Enabled and (HoverKind &lt;&gt; hkNone) then
-      //rmk Info: this is the painting of menu item selected...
-      FillGradient(Canvas.Handle, R, GetPartColor(ItemInfo, ipBody), ThemeLightCl,
-        TGTopBottom);
-  FrameRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipFrame), True);
-end;
-
-function TTBXOffice12Theme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXOffice12Theme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-  Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := False;//ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          ThemeDarkCl);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin // rmk Removed the shadows under the glyphs and added back 14.04.2003
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 14.04.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXOffice12Theme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if (ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX then
-    with Canvas do
-    begin
-      Inc(R.Left); // changed by Boris
-      R.Right := R.Left + ItemInfo.PopupMargin + 1;//2;
-      Brush.Color := ToolbarColor;
-      FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGLeftRight);
-      Inc(R.Left);
-      R.Right := ARect.Right - 1;
-    end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXOffice12Theme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := ARect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R := R2;
-      R.Left := R2.Left + 1;
-      R.Right := R.Left + ItemInfo.PopupMargin - 2;
-      if HoverKind = hkNone then
-        FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True)
-      else
-      begin
-        Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        MoveTo(R.Right, R.Top);
-        LineTo(R.Right, R.Bottom);
-      end;
-      FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody), ThemeLightCl,
-        TGTopBottom);
-    end;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-             
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        Inc(R.Left);
-        R.Right := ItemInfo.PopupMargin + 2; // changed by Boris
-        Brush.Color := ToolbarColor;
-        FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGLeftRight);
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      if not enabled then Exit;
-
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clWhite);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, ThemeMediumCl);
-      end
-      else
-      begin
-        Top := Bottom div 2;
-        MoveTo(Left, Top);
-        LineTo(Right - 2, Top);
-      end;
-    end
-    else if enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clWhite);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, ThemeMediumCl {GradBL});
-    end;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR) and
-      (GradientMenu = true))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      with R do
-      begin
-        if (R.Right &gt; R.Bottom) then
-        begin
-          FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGTopBottom);
-          R2 := R;
-          R2.Left := R2.Right - 1;
-          FillGradient(Canvas.Handle, R2, GradBL, ThemeExtraLightCl, TGTopBottom);
-
-          Pen.Color := gradBL;
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := ThemeExtraLightCl; //gradCol1;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-          MoveTo(Right - 2, Top);
-          LineTo(Right - 2, Top + 1);
-          Pen.Color := ThemeMediumCl;
-          MoveTo(Right - 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 2);
-        end
-        else
-        begin
-          FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGLeftRight);
-          R2 := R;
-          R2.Top := R2.Bottom - 1;
-          FillGradient(Canvas.Handle, R2, GradBL, ThemeMediumCl, TGLeftRight);
-          Pen.Color := gradBL;
-          MoveTo(Right - 1, Top + 1);
-          LineTo(Right - 1, Bottom - 1);
-          Pen.Color := ThemeMediumCl;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-          MoveTo(Left, Bottom - 2);
-          LineTo(Left, Bottom);
-          MoveTo(Right - 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 2);
-        end;
-      end;
-      InflateRect(R, -2, -2);
-    end
-    else
-    begin
-      Canvas.Brush.Color := MenubarColor;
-      Canvas.FillRect(R);
-      InflateRect(R, -2, -2);
-    end;
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := ThemeExtraLightCl;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXOffice12Theme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(ThemeExtraLightCl));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, ThemeExtraLightCl, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := ThemeExtraLightCl;
-        if IsVertical then
-          Pixels[Right - 1, Top] := ThemeExtraLightCl
-        else
-          Pixels[Left, Bottom - 1] := ThemeExtraLightCl;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, ThemeDarkCl);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := ThemeExtraLightCl;
-      R.Bottom := R.Bottom + 1;
-      FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGTopBottom);
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := ThemeExtraLightCl;
-      R.Right := R.Right + 1;
-      FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGLeftRight); // rmkB
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := $00602000;// TODO
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear; //bsSolid;   // rmkB
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXOffice12Theme.SetupColorCache;
-var
-  DC: HDC;
-  DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradHandle1 := clGreen;
-  gradHandle2 := clRed;
-  gradHandle3 := clWhite;
-  // gradBL = gradient bottom line just for your information...
-  gradBL := NearestMixedColor(ThemeDarkCl, ThemeMediumCl, 64); //CustomBtnShadow;
-
-  { View/Window Colors }
-  MenubarColor := ThemeMediumCl;
-  ToolbarColor := ThemeLightCl;
-  PopupColor := clWindow; //Blend(clGreen, clWindow, 143);
-  DockPanelColor := PopupColor;
-  PopupFrameColor := ThemeMediumCl;
-  SetContrast(PopupFrameColor, PopupColor, 100);
-
-  DisabledText := Blend(ThemeDarkCl, $707070, 150);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(ThemeExtraLightCl, ThemeDarkCl, 15);
-  SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 100);
-  WinFrameColors[wfsActive, wfpCaption] := ThemeDarkCl;
-  WinFrameColors[wfsActive, wfpCaptionText] := ThemeExtraLightCl;
-  //clBtnHighlight; // rmkB
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], ThemeDarkCl, 200);
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := ThemeExtraLightCl;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], ThemeExtraLightCl, 150);
-
-  PnlFrameColors[wfsActive, wfpBorder] := ThemeDarkCl;
-  PnlFrameColors[wfsActive, wfpCaption] := ThemeExtraLightCl;
-  PnlFrameColors[wfsActive, wfpCaptionText] := ThemeExtraLightCl;
-  PnlFrameColors[wfsInactive, wfpBorder] := ThemeDarkCl;
-  PnlFrameColors[wfsInactive, wfpCaption] := ThemeExtraLightCl;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], ThemeExtraLightCl, 150);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := ThemeDarkestCl;//$00602000; // TODO
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 150);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 100);
-  BtnItemColors[bisDisabled, ipFrame] := clNone;
-
-  // checked btn + tab selected, Body color is only for tab!
-  BtnItemColors[bisSelected, ipBody] := Blend(ThemeLightCl, ThemeMediumCl, 50);
-  BtnItemColors[bisSelected, ipText] := ThemeDarkestCl;// BtnItemColors[bisNormal, ipText];
-//  SetContrast(BtnItemColors[bisSelected, ipText], BtnItemColors[bisSelected, ipBody], 100);
-  BtnItemColors[bisSelected, ipFrame] := Blend(ThemeExtraDarkCl, ThemeDarkestCl, 50);//ThemeHighlight;// $a85e33;
-
-  // ribbon tab pressed
-  BtnItemColors[bisPressed, ipBody] := ThemeExtraDarkCl; //Blend(ThemeHighlight, clWindow, 50);
-  BtnItemColors[bisPressed, ipText] := clWhite; // ThemeHighlightText;
-  SetContrast(BtnItemColors[bisPressed, ipText], BtnItemColors[bisPressed, ipBody], 100);
-  BtnItemColors[bisPressed, ipFrame] := ThemeDarkCl;
-
-  // btn over and unchecked tabs
-  BtnItemColors[bisHot, ipBody] := ThemeMediumCl;
-  BtnItemColors[bisHot, ipText] := ThemeDarkCl;
-  SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody], 180);
-  BtnItemColors[bisHot, ipFrame] := ThemeMediumCl; //$d0b0a0;
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := ThemeExtraDarkCl;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := ThemeExtraDarkCl;
-
-  BtnItemColors[bisSelectedHot, ipBody] := ThemeExtraDarkCl;//Blend(ThemeHighlight, clWindow, 50);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  // Normal text on tabs
-  BtnItemColors[bisSelectedHot, ipText] := clWhite;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText], BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := ThemeExtraDarkCl;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame], BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := ToolbarColor;
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := PopupFrameColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := $00602000;//clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipText] := ThemeDarkestCl;
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80); // 145?
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clRed, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := ThemeExtraDarkCl;
-
-  DragHandleColor := Blend(ThemeDarkCl, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, ThemeExtraDarkCl, 25);
-  ToolbarSeparatorColor := Blend(ThemeDarkCl, clWindow, 70);
-  SetContrast(ToolbarSeparatorColor, ToolbarColor, 50);
-  PopupSeparatorColor := ToolbarSeparatorColor;
-  StatusPanelFrameColor := ThemeDarkCl;// Blend(clWindow, ThemeExtraLightCl, 30);
-  SetContrast(StatusPanelFrameColor, ThemeExtraLightCl, 30);
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXOffice12Theme.GetPopupShadowType: Integer;
-begin
-  //Result := PST_OFFICEXP;
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXOffice12Theme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXOffice12Theme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXOffice12Theme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXOffice12Theme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipFrame]
-  else
-    Canvas.Brush.Color := ThemeDarkCl;
-  Canvas.FrameRect(R);
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-  else
-    Canvas.Brush.Color := ThemeExtraLightCl;
-  InflateRect(R, -1, -1);
-  Canvas.FillRect(R);
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if Hot then
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipText]
-  else
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXOffice12Theme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Pen.Color := ThemeDarkCl
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Pen.Color := BtnItemColors[bisPressed, ipFrame]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame]
-    else
-      Canvas.Pen.Color := ThemeDarkCl;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Brush.Color := BtnItemColors[bisPressed, ipBody]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-    else if Boolean(State and PFS_MIXED) then
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, ThemeExtraLightCl)
-    else
-      Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := ThemeDarkCl
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Rectangle(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-      PFC_RADIOBUTTON:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Ellipse(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXOffice12Theme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-var
-  Color, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillGradient(Canvas.Handle, R, ThemeMediumCl, ThemeLightCl, TGTopBottom);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right, R.Top, ThemeExtraDarkCl);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1, ThemeLightCl);
-  {        FillRectEx(Canvas.Handle, R, CustomBtnFace);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 0, R.Right, R.Top + 0,
-            NearestMixedColor(CustomBtnShadow, CustomBtnFace, 200));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1,
-            NearestMixedColor(CustomBtnShadow, CustomBtnFace, 128));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 2, R.Right, R.Top + 2,
-            NearestMixedColor(CustomBtnShadow, CustomBtnFace, 64));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 3, R.Right, R.Top + 3,
-            NearestMixedColor(CustomBtnShadow, CustomBtnFace, 32));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 4, R.Right, R.Top + 4,
-            NearestMixedColor(CustomBtnShadow, CustomBtnFace, 12));
-
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 3, R.Right, R.Bottom - 3,
-            NearestMixedColor(CustomBtnShadow, CustomBtnFace, 8));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 2, R.Right, R.Bottom - 2,
-            NearestMixedColor(CustomBtnShadow, CustomBtnFace, 16));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            NearestMixedColor(CustomBtnShadow, CustomBtnFace, 24));}
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3,
-            ThemeDarkCl);
-          DrawLineEx(Canvas.Handle, R.Right + 1, R.Top + 5, R.Right + 1, R.Bottom
-            - 2, clBtnHighLight);
-        end;
-      {begin
-        if Part = SBP_PANE then Dec(R.Right, 3);
-        DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, StatusPanelFrameColor);
-      end;}
-      SBP_GRIPPER:
-        begin
-          Color := ThemeExtraLightCl;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, ThemeDarkCl, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, ThemeDarkCl, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, ThemeDarkCl, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, ThemeDarkCl, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXOffice12Theme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  RegisterTBXTheme('Office12', TTBXOffice12Theme);
-
-  ThemeDarkestCl := clBlack; // text color on buttons, captions, etc.
-  ThemeExtraLightCl := clWhite; // tbx background color
-  ThemeLightCl := $00EEE4DE; // is mixed with ThemeMediumCl to render backgrounds, buttons, checkboxes etc.
-  ThemeMediumCl := $00D7C1B3; // is mixed with ThemeLightCl to render backgrounds, buttons, checkboxes etc.
-  ThemeDarkCl := $00C9AC9B; // at the edges of forms, edges of groupboxes, buttons, checkboxes etc.
-  ThemeExtraDarkCl := $00B79079; // rarely used. At the edges of tabs, for example.
-end.
-

Deleted: Lobby/TASClient/Themes/TBXOfficeCTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXOfficeCTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXOfficeCTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2394 +0,0 @@
-unit TBXOfficeCTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'OfficeC' TBX theme &#169;2004 Roy Magne Klever
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-//  Version for TBX version 2.1
-//  Last updated: 02.12.2004
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-
-type
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXOfficeCTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    DisabledEdit: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-        override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated:
-        Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-  procedure SetThemeColors(c1, c2, c3, c4: TColor);
-
-var
-  GradientMenu,
-    GradientBack: boolean;
-  UseAdaptive: Boolean;
-  UseGradColor1,
-    UseGradColor2,
-    HoverColor1,
-    HoverColor2: TColor;
-  MenubarColor: TColor;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms, rmkThemes;
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-  GradientBmp: TBitmap;
-  TBVert: Boolean;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXOfficeCTheme }
-
-function TTBXOfficeCTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := True;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXOfficeCTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := DEFAULT;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXOfficeCTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXOfficeCTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled,
-    bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected,
-    bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXOfficeCTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled,
-    misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled,
-    bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected,
-    bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2,
-    bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left, ARect.Bottom - Counter -
-        1, ARect.Right, ARect.Bottom - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Right - Counter - 1, ARect.Top,
-        ARect.Right - Counter, ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  GSize: Integer;
-  rc1, rc2, gc1, gc2, bc1, bc2, rc3, gc3, bc3,
-    y1, Counter: Integer;
-
-  Brush: HBrush;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then
-    rc3 := 0
-  else if rc3 &gt; 255 then
-    rc3 := 255;
-  if gc3 &lt; 0 then
-    gc3 := 0
-  else if gc3 &gt; 255 then
-    gc3 := 255;
-  if bc3 &lt; 0 then
-    bc3 := 0
-  else if bc3 &gt; 255 then
-    bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    y1 := GSize div 2;
-    for Counter := 0 to y1 - 1 do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for Counter := y1 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize {GSize})),
-        Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)),
-        Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    y1 := GSize div 2;
-    for Counter := 0 to y1 - 1 do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-      Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for Counter := y1 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize)),
-        Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)),
-        Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXOfficeCTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXOfficeCTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXOfficeCTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXOfficeCTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 1;
-      Border.Y := 1;
-    end
-    else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-    //Border.Y := 1; {2}
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXOfficeCTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXOfficeCTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-  IsHoriz: boolean;
-begin
-  if (not Transparent) then
-  begin
-    if (((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((AViewType and TVT_MENUBAR) = TVT_MENUBAR) and (GradientMenu = true)))
-      and (not (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-      if IsHoriz then
-      begin
-        TBVert := false;
-        R.Top := R.Top - 1;
-        R.Bottom := R.Bottom + 1;
-        GradientFill(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-        R.Bottom := R.Bottom - 1;
-        R.Top := R.Top + 1;
-      end
-      else
-      begin
-        TBVert := true;
-        R.Left := R.Left - 1;
-        R.Right := R.Right + 1;
-        GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-        R.Right := R.Right - 1;
-        R.Left := R.Left + 1;
-      end;
-    end
-    else
-    begin
-      TBVert := false;
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-      if ((AViewType and TVT_NORMALTOOLBAR) &lt;&gt; TVT_NORMALTOOLBAR)
-        and ((AViewType and TVT_MENUBAR) &lt;&gt; TVT_MENUBAR)
-        and ((AViewType and PVT_CHEVRONMENU) &lt;&gt; PVT_CHEVRONMENU)
-        and ((AViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX) then
-      begin
-        if GradientBack then
-          FillGradient(Canvas, R, gradCol1, gradCol2, TGLeftRight)
-        else
-        begin
-          R.Right := R.Left + 24;
-          {this value is hardcoded but should be ItemInfo.PopupMargin}
-          FillGradient(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-        end;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    C:= Font.Color;
-    if c = clNone then
-      Font.Color := GetPartColor(ItemInfo, ipText);
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXOfficeCTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-begin
-  R := ARect;
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-    and ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-  InflateRect(R, 1, 1);
-  Inc(R.Left);
-  with Canvas do
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-          PaintButton(Canvas, R, ItemInfo)
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          R := ARect;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, R, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(R.Left - 1, R.Top);
-          LineTo(R.Left - 1, R.Bottom);
-        end;
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        // rmk 14.04.2003
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient(Canvas, BR, gradCol2, gradCol1, TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas, BR, HoverColor2, HoverColor1, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Top := ARect.Top;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient(Canvas, BR, gradCol2, gradCol1, TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas, BR, HoverColor2, HoverColor1, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Bottom := ARect.Bottom;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-end;
-
-procedure TTBXOfficeCTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-  Embedded: Boolean;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-  if not (ItemInfo.Enabled or Embedded) then
-    FrameRectEx(Canvas.Handle, R, DisabledEdit, True);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-      FrameRectEx(Canvas.Handle, R, clBtnface, True)
-    else
-    begin
-      Canvas.Brush.Color := clWindow;
-      Canvas.FrameRect(R);
-    end;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-  begin
-    Canvas.Brush.Color := clWindow;
-    Canvas.FillRect(R);
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-    begin
-      Canvas.Brush.Color := clBtnFace; //rmk April 0406
-      R := ARect;
-      InflateRect(R, -1, -1);
-      Canvas.FrameRect(R);
-    end;
-  end;
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  R, R2: TRect;
-  ShowHover: Boolean;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-
-    if (ComboPart = cpSplitLeft) and IsPopupParent then
-      Inc(R.Right);
-    if ComboPart = cpSplitRight then
-      Dec(R.Left);
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (HoverKind &lt;&gt; hkNone) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        if Pushed then
-          if GradientBack then
-            FillRectEx(Canvas.Handle, R, UseGradColor1)
-          else
-            FillRectEx(Canvas.Handle, R, PopupColor)
-        else
-          FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), gradCol2,
-            TGTopBottom);
-      FrameRectEx(Canvas.Handle, R, PopupFrameColor, True);
-      Exit;
-    end;
-
-    FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-    if ShowHover and not (Pushed or Selected) and Enabled then
-    begin // Hover button...
-      if TBVert then
-      begin
-        if ComboPart = cpSplitLeft then
-        begin
-          R2 := R;
-          R2.Right := R2.Right + 12;
-          FillGradient(Canvas, R2, HoverColor2, HoverColor1, TGLeftRight)
-        end
-        else if ComboPart &lt;&gt; cpSplitRight then
-          FillGradient(Canvas, R, HoverColor2, HoverColor1, TGLeftRight);
-      end
-      else
-        FillGradient(Canvas, R, HoverColor2, HoverColor1, TGTopBottom);
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      if not Pushed and (HoverKind = hkNone) then
-        if IsVertical then // Selected Items no not pressed
-          FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), gradCol1,
-            TGLeftRight)
-        else
-          FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), gradCol1,
-            TGTopBottom)
-      else if IsPopupParent then
-        if GradientBack then
-          FillRectEx(Canvas.Handle, R, UseGradColor1)
-        else
-          FillRectEx(Canvas.Handle, R, PopupColor)
-      else if TBVert then
-      begin
-        if ComboPart = cpSplitLeft then
-        begin
-          R2 := R;
-          R2.Right := R2.Right + 12;
-          FillGradient(Canvas, R2, gradCol2, gradCol1, TGLeftRight)
-        end
-        else
-          FillGradient(Canvas, R, gradCol2, gradCol1, TGLeftRight);
-      end
-      else
-        FillGradient(Canvas, R, gradCol2, gradCol1, TGTopBottom);
-    end;
-
-    if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      if TBVert then
-      begin
-        if ComboPart = cpSplitLeft then
-        begin
-          R2 := R;
-          R2.Right := R2.Right + 12;
-          FillGradient(Canvas, R2, HoverColor1, HoverColor2, TGLeftRight)
-        end
-        else if ComboPart &lt;&gt; cpSplitRight then
-          FillGradient(Canvas, R, HoverColor1, HoverColor2, TGLeftRight);
-      end
-      else
-        FillGradient(Canvas, R, HoverColor1, HoverColor2, TGTopBottom);
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive,
-    wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      //FillRect(R);
-      FillGradient(Canvas, R, gradCol2, gradCol1, TGTopBottom); // rmkB
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear; //rmkB
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      //FillRect(R);
-      FillGradient(Canvas, R, gradCol2, gradCol1, TGTopBottom); // rmkB
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-      // rmk I did change this too paint close button correct...
-      if FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]) then
-        DrawButtonBitmap(Canvas, R, BtnItemColors[BtnItemState, ipText])
-          //DrawGlyph(BtnItemColors[BtnItemState, ipText])
-      else
-        DrawButtonBitmap(Canvas, R, CaptionText);
-      //DrawGlyph(CaptionText);
-    end;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  with ItemInfo do
-    if Enabled and (HoverKind &lt;&gt; hkNone) then
-      //rmk Info: this is the painting of menu item selected...
-      FillGradient(Canvas, R, HoverColor2, HoverColor1, TGTopBottom);
-  //FillGradient(Canvas.Handle, R, GetPartColor(ItemInfo, ipBody), gradCol2, TGTopBottom);
-  FrameRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipFrame), True);
-end;
-
-function TTBXOfficeCTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXOfficeCTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-  Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin // rmk Removed the shadows under the glyphs and added back 14.04.2003
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 14.04.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXOfficeCTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if (ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX then
-    with Canvas do
-    begin
-      R.Right := R.Left + ItemInfo.PopupMargin + 2;
-      Brush.Color := ToolbarColor;
-      //FillRect(R);  // rmkA
-      Inc(R.Left);
-      R.Right := ARect.Right - 1;
-    end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXOfficeCTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := ARect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R := R2;
-      R.Left := R.Left + 1;
-      R.Right := R.Left + ItemInfo.PopupMargin - 2;
-      if HoverKind = hkNone then
-        FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      if ItemInfo.HoverKind &lt;&gt; hkNone then
-        FillGradient(Canvas, R, Blend(HoverColor2, clWindow, 50), HoverColor1,
-          TGTopBottom)
-      else
-        FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-    end;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        //FillRect(R);    // rmkA
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      // rmkPaint
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, gradCol2);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, gradCol1);
-      end
-      else
-      begin
-        Top := Bottom div 2;
-        MoveTo(Left, Top);
-        LineTo(Right - 2, Top);
-      end;
-    end
-    else if Enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, gradCol2);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, gradCol1 {GradBL});
-    end;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2,
-    0, 1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (GradientMenu
-      = false)) then
-    begin
-      Brush.Color := MenuBarColor;
-      FillRect(R);
-    end;
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR) and
-      (GradientMenu = true))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      with R do
-      begin
-        if (Toolbarinfo.IsVertical) then
-        begin
-          GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-          R2 := R;
-          R2.Top := R2.Bottom - 1;
-
-          if ToolbarInfo.BorderStyle &lt;&gt; bsSingle then exit;
-
-          GradientFill(Canvas, R2, gradCol1, gradCol2, TGLeftRight);
-
-          Pen.Color := gradBL;
-          MoveTo(Right - 1, Top + 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := Blend(MenuBarColor, gradCol2, 75);
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-
-          MoveTo(Left, Bottom - 2);
-          LineTo(Left, Bottom);
-        end
-        else
-        begin
-          GradientFill(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-          R2 := R;
-          R2.Top:= R.Top + 1;
-          R2.Left := R2.Right - 1;
-
-          if ToolbarInfo.BorderStyle &lt;&gt; bsSingle then exit;
-
-          GradientFill(Canvas, R2, GradBL, Blend(gradCol1, gradCol2, 50), TGTopBottom);
-
-          Pen.Color := gradBL;
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pixels[Left, Top]:= Blend(MenuBarColor, gradCol2, 75);
-          Pixels[Left, Bottom - 1]:= gradCol1;
-          Pixels[Left, Bottom - 2]:= Blend(gradCol1, gradBL, 50);
-
-          Pixels[Right - 2, Top]:= Blend(MenuBarColor, gradCol2, 75);
-          Pixels[Right - 1, Top]:= MenuBarColor;
-          Pixels[Right - 1, Bottom - 1]:= gradCol1;
-          Pixels[Right - 2, Bottom - 2]:= Blend(gradCol1, gradBL, 50);
-        end;
-      end;
-      InflateRect(R, -2, -2);
-    end
-    else
-      InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := MenuBarColor;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXOfficeCTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, MenuBarColor, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := MenuBarColor; //clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := MenuBarColor //clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      //R.Bottom := R.Top + Sz;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      FillGradient(Canvas, R, gradCol2, gradCol1, TGTopBottom); // rmkB
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      FillGradient(Canvas, R, gradCol2, gradCol1, TGLeftRight); // rmkB
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear; //bsSolid;   // rmkB
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure SetThemeColors(c1, c2, c3, c4: TColor);
-begin
-  UseGradColor1 := c1;
-  UseGradColor2 := c2;
-  HoverColor1 := c3;
-  HoverColor2 := c4;
-end;
-
-procedure TTBXOfficeCTheme.SetupColorCache;
-var
-  DC: HDC;
-  C1, HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  c1 := NearestMixedColor(UseGradColor2, clWhite, 64);
-
-  gradCol1 := UseGradColor2;
-  gradCol2 := UseGradColor1;
-
-  gradHandle1 := Blend(UseGradColor2, clWhite, 48);
-  gradHandle2 := Blend(UseGradColor2, clBlack, 75);
-  gradHandle3 := c1;
-  gradBL := Blend(gradCol1, clBlack, 75);
-
-  HotBtnFace := Blend(UseGradColor2, clWindow, 70);
-  MenubarColor := NearestMixedColor(gradCol2, gradCol1, 128);
-
-  ToolbarColor := gradCol2;
-  PopupColor := Blend(gradCol2, clWindow, 143);
-  DockPanelColor := PopupColor;
-  PopupFrameColor := Blend(clBtnText, gradCol1, 20);
-  SetContrast(PopupFrameColor, PopupColor, 100);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clBtnText, gradCol1, 15);
-  SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-  WinFrameColors[wfsActive, wfpCaption] := MenubarColor;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-
-  PnlFrameColors[wfsActive, wfpCaption] := MenubarColor;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(UseGradColor2, clBtnText, 80);
-  DisabledEdit := DisabledText; //Blend(HoverColor2, GradCol1, 20);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := gradCol1;
-  PnlFrameColors[wfsInactive, wfpBorder] := gradCol2;
-  PnlFrameColors[wfsInactive, wfpCaption] := MenubarColor;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-  BtnItemColors[bisDisabled, ipFrame] := clNone;
-
-  BtnItemColors[bisSelected, ipBody] := Blend(UseGradColor2, Blend(clBtnFace,
-    clWindow, 50), 10);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := UseGradColor2;
-
-  BtnItemColors[bisPressed, ipBody] := Blend(UseGradColor2, clWindow, 50);
-  BtnItemColors[bisPressed, ipText] := NearestMixedColor(clHighLightText,
-    clBlack, 48);
-  BtnItemColors[bisPressed, ipFrame] := UseGradColor2;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := NearestMixedColor(clHighLightText, clBlack,
-    48); //clHighLightText;
-  BtnItemColors[bisHot, ipFrame] := Blend(HoverColor1, HoverColor2, 20);
-  //UseGradColor2;
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := UseGradColor2;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(UseGradColor2, clWindow, 50);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clHighlightText;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText],
-    BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := HoverColor2;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(UseGradColor2, clWindow, 50);
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisHot, ipText];
-  //BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := PopupFrameColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := DisabledText;
-  //SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80); // 145?
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := UseGradColor2;
-
-  DragHandleColor := Blend(clBtnShadow, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := Blend(UseGradColor2, clWindow, 70);
-  SetContrast(ToolbarSeparatorColor, ToolbarColor, 50);
-  if GradientBack then
-    PopupSeparatorColor := UseGradColor2
-  else
-    PopupSeparatorColor := ToolbarSeparatorColor;
-
-  StatusPanelFrameColor := Blend(clWindow, clBtnFace, 30);
-  SetContrast(StatusPanelFrameColor, clBtnFace, 30);
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXOfficeCTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_OFFICEXP;
-end;
-
-constructor TTBXOfficeCTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXOfficeCTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXOfficeCTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXOfficeCTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  if Hot then
-  begin
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipFrame];
-    Canvas.FrameRect(R);
-    InflateRect(R, -1, -1);
-    FillGradient(Canvas, R, HoverColor2, HoverColor1, TGTopBottom);
-  end
-  else
-  begin
-    Canvas.Brush.Color := gradCol1;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := gradCol2;
-    InflateRect(R, -1, -1);
-    Canvas.FillRect(R);
-  end;
-
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if Hot then
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipText]
-  else
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXOfficeCTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Pen.Color := BtnItemColors[bisPressed, ipFrame]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame]
-    else
-      Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Brush.Color := BtnItemColors[bisPressed, ipBody]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-    else if Boolean(State and PFS_MIXED) then
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else
-      Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Rectangle(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-      PFC_RADIOBUTTON:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Ellipse(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXOfficeCTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-var
-  Color, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, MenubarColor);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 0, R.Right, R.Top + 0,
-            NearestMixedColor(gradCol1, MenubarColor, 200));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1,
-            NearestMixedColor(gradCol1, MenubarColor, 128));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 2, R.Right, R.Top + 2,
-            NearestMixedColor(gradCol1, MenubarColor, 64));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 3, R.Right, R.Top + 3,
-            NearestMixedColor(gradCol1, MenubarColor, 32));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 4, R.Right, R.Top + 4,
-            NearestMixedColor(gradCol1, MenubarColor, 12));
-
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 3, R.Right, R.Bottom - 3,
-            NearestMixedColor(gradCol1, MenubarColor, 8));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 2, R.Right, R.Bottom - 2,
-            NearestMixedColor(gradCol1, MenubarColor, 16));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            NearestMixedColor(gradCol1, MenubarColor, 24));
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3,
-            gradCol1);
-          DrawLineEx(Canvas.Handle, R.Right + 1, R.Top + 5, R.Right + 1, R.Bottom
-            - 2, gradCol2);
-        end;
-      {begin
-        if Part = SBP_PANE then Dec(R.Right, 3);
-        DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, StatusPanelFrameColor);
-      end;}
-      SBP_GRIPPER:
-        begin
-          Color := gradHandle1;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, gradHandle2, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, gradHandle3, 72));
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXOfficeCTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  GradientMenu := true;
-  GradientBack := true;
-  SetThemeColors(Blend(clWhite, clYellow, 75), Blend(clGreen, clYellow, 25),
-    clWhite, Blend(clGreen, clYellow, 25));
-
-  RegisterTBXTheme('OfficeC', TTBXOfficeCTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXOfficeKTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXOfficeKTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXOfficeKTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2158 +0,0 @@
-unit TBXOfficeKTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-//
-// OfficeKtheme &#169;2004 Roy Magne Klever
-//
-// Version for TBX 2.1 done 9. aug. 2004
-//
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-{*$DEFINE SMALL_CLOSE_BUTTON}// remove the asterisk for smaller close button size
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXOfficeKTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  GradientMenu: boolean;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockImgList.Free;
-end;
-
-{ TTBXOfficeKTheme }
-
-function TTBXOfficeKTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := True;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXOfficeKTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-
-    TMI_TLBR_SEPARATORSIZE: Result := DEFAULT;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXOfficeKTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXOfficeKTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXOfficeKTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2,
-    bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom
-        - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXOfficeKTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXOfficeKTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXOfficeKTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXOfficeKTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-      Border.X := 1
-    else
-      Border.X := 2;
-    Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXOfficeKTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXOfficeKTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-  IsHoriz: boolean;
-begin
-  if (not Transparent) then
-  begin
-    if (((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((AViewType and TVT_MENUBAR) = TVT_MENUBAR) and (GradientMenu = true)))
-      and (not (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-      if IsHoriz then
-      begin
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      end
-      else
-      begin
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-      end;
-    end
-    else
-    begin
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-      if ((AViewType and TVT_NORMALTOOLBAR) &lt;&gt; TVT_NORMALTOOLBAR)
-        and ((AViewType and TVT_MENUBAR) &lt;&gt; TVT_MENUBAR)
-        and ((AViewType and PVT_CHEVRONMENU) &lt;&gt; PVT_CHEVRONMENU)
-        and ((AViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX) then
-      begin
-        R.Right := R.Right - 2;
-        //FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-        R.Right := R.Left + 24;
-          {this value is hardcoded but should be ItemInfo.PopupMargin}
-        //FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    Font.Color := GetPartColor(ItemInfo, ipText);
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXOfficeKTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-begin
-  R := ARect;
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-    and ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-  InflateRect(R, 1, 1);
-  Inc(R.Left);
-  with Canvas do
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-          PaintButton(Canvas, R, ItemInfo)
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          R := ARect;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, R, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(R.Left - 1, R.Top);
-          LineTo(R.Left - 1, R.Bottom);
-        end;
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        // rmk 14.04.2003
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // rmkA BR = Button Rectangle
-          FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-            gradCol2, TGTopBottom);
-          //FillGradient(Canvas.Handle, R, gradCol2, GetBtnColor(ItemInfo, ipBody), TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Top := ARect.Top;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      { Lower button }
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin // rmkA
-          //FillGradient(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipBody), gradCol2, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Bottom := ARect.Bottom;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-end;
-
-procedure TTBXOfficeKTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-  Embedded: Boolean;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-  if not (ItemInfo.Enabled or Embedded) then
-    FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipText], True);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True)
-    else
-    begin
-      Canvas.Brush.Color := clWindow;
-      Canvas.FrameRect(R);
-    end;
-  end;
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-  begin
-    Canvas.Brush.Color := clWindow;
-    Canvas.FillRect(R);
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-    begin
-      Canvas.Brush.Color := clBtnFace;
-      R := ARect;
-      InflateRect(R, -1, -1);
-      Canvas.FrameRect(R);
-    end;
-  end;
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    if ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) and not Selected then
-    begin
-      Brush.Color := GetNearestColor(Handle, MixColors(clBtnShadow, clBtnFace,
-        100));
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      FrameRect(R);
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      if (ComboPart = cpSplitLeft) and IsPopupParent then
-        Inc(R.Right);
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      if (Selected) and (((ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-        or ((ViewType and VT_POPUP) = VT_POPUP)) then
-      begin
-        if IsVertical then
-          FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-            gradCol2, TGLeftRight)
-        else
-          FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-            gradCol2, TGTopBottom);
-      end
-      else
-      begin
-        if (HoverKind &lt;&gt; hkNone) and ((((ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-          or ((ViewType and VT_POPUP) = VT_POPUP))) then
-        begin
-          if Pushed then
-            if IsVertical then
-              FillGradient(Canvas.Handle, R, gradCol2, GetBtnColor(ItemInfo,
-                ipBody), TGLeftRight)
-            else
-              FillGradient(Canvas.Handle, R, gradCol2, GetBtnColor(ItemInfo,
-                ipBody), TGTopBottom)
-          else if IsVertical then
-            FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGLeftRight)
-          else
-            FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGTopBottom);
-        end
-        else
-          FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-      end;
-    end;
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGTopBottom);
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGTopBottom);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-      if FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]) then
-        DrawButtonBitmap(Canvas, R, BtnItemColors[BtnItemState, ipText])
-      else
-        DrawButtonBitmap(Canvas, R, CaptionText);
-    end;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  with ItemInfo do
-    if Enabled and (HoverKind &lt;&gt; hkNone) then
-      //rmk Info: this is the painting of menu item selected...
-      FillGradient(Canvas.Handle, R, GetPartColor(ItemInfo, ipBody), gradCol2,
-        TGTopBottom);
-  FrameRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipFrame), True);
-end;
-
-function TTBXOfficeKTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXOfficeKTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-    Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXOfficeKTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if (ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX then
-    with Canvas do
-    begin
-      R.Right := R.Left + ItemInfo.PopupMargin + 2;
-      Brush.Color := ToolbarColor;
-      Inc(R.Left);
-      R.Right := ARect.Right - 1;
-    end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXOfficeKTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := Arect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R := R2;
-      R.Left := R.Left + 1;
-      R.Right := R.Left + ItemInfo.PopupMargin - 2;
-      FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody), gradCol2,
-        TGTopBottom);
-    end;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        //FillRect(R);    // rmkA
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      // rmkPaint
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clWhite);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, gradCol1);
-      end
-      else
-      begin
-        Top := Bottom div 2;
-        MoveTo(Left, Top);
-        LineTo(Right - 2, Top);
-      end;
-    end
-    else if enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clWhite);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, gradCol1 {GradBL});
-    end;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR) and
-        (GradientMenu = true))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      with R do
-      begin
-        if (R.Right &gt; R.Bottom) then
-        begin
-          FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-          R2 := R;
-          R2.Left := R2.Right - 1;
-          FillGradient(Canvas.Handle, R2, GradBL, clBtnFace, TGTopBottom);
-
-          Pen.Color := gradBL;
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := clbtnFace;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-          MoveTo(Right - 2, Top);
-          LineTo(Right - 2, Top + 1);
-          Pen.Color := gradCol1;
-          MoveTo(Right - 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 2);
-
-        end
-        else
-        begin
-          FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-          R2 := R;
-          R2.Top := R2.Bottom - 1;
-          FillGradient(Canvas.Handle, R2, GradBL, gradCol1, TGLeftRight);
-
-          Pen.Color := gradBL;
-          ;
-          MoveTo(Right - 1, Top + 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := gradCol1;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-          MoveTo(Left, Bottom - 2);
-          LineTo(Left, Bottom);
-          MoveTo(Right - 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 2);
-        end;
-      end;
-      InflateRect(R, -2, -2);
-    end
-    else
-    begin
-      Canvas.Brush.Color := MenubarColor;
-      Canvas.FillRect(R);
-      InflateRect(R, -2, -2);
-    end;
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := clBtnFace;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXOfficeKTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      //R.Bottom := R.Top + Sz;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGTopBottom); // rmkB
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGLeftRight); // rmkB
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear; //bsSolid;   // rmkB
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXOfficeKTheme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  // gradColors rmk
-  // Standard
-  //gradCol1:= clBtnFace;
-  gradCol1 := NearestMixedColor(clBtnShadow, clBtnFace, 48); //clBtnShadow;
-  gradCol2 := clWhite;
-  gradHandle1 := clBtnFace;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-  // gradBL = gradient bottom line just for your information...
-  gradBL := NearestMixedColor(clBtnShadow, gradCol1, 64); //clBtnShadow;
-  // gradColors rmk end
-
-  { View/Window Colors }
-  MenubarColor := clBtnFace;
-  ToolbarColor := gradCol2;
-  PopupColor := clWindow; //Blend(clBtnFace, clWindow, 143);
-  DockPanelColor := PopupColor;
-  PopupFrameColor := Blend(clBtnText, clBtnShadow, 20);
-  SetContrast(PopupFrameColor, PopupColor, 100);
-
-  HotBtnFace := Blend(clHighlight, clWindow, 30);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clBtnText, clBtnShadow, 15);
-  SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-  WinFrameColors[wfsActive, wfpCaption] := clBtnShadow;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-    //clBtnHighlight; // rmkB
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clBtnShadow, 180);
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsActive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-  PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := clNone;
-  BtnItemColors[bisSelected, ipBody] := Blend(clHighlight, Blend(clBtnFace,
-    clWindow, 50), 10);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := clHighlight;
-  BtnItemColors[bisPressed, ipBody] := Blend(clHighlight, clWindow, 50);
-  BtnItemColors[bisPressed, ipText] := clHighlightText;
-  BtnItemColors[bisPressed, ipFrame] := clHighlight;
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clMenuText;
-  SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody],
-    180);
-  BtnItemColors[bisHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(clHighlight, clWindow, 50);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clHighlightText;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText],
-    BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-  BtnItemColors[bisPopupParent, ipBody] := ToolbarColor;
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := PopupFrameColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80); // 145?
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-  DragHandleColor := Blend(clBtnShadow, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-  ToolbarSeparatorColor := Blend(clBtnShadow, clWindow, 70);
-  SetContrast(ToolbarSeparatorColor, ToolbarColor, 50);
-  PopupSeparatorColor := ToolbarSeparatorColor;
-  StatusPanelFrameColor := Blend(clWindow, clBtnFace, 30);
-  SetContrast(StatusPanelFrameColor, clBtnFace, 30);
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXOfficeKTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_OFFICEXP;
-end;
-
-constructor TTBXOfficeKTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXOfficeKTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXOfficeKTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXOfficeKTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipFrame]
-  else
-    Canvas.Brush.Color := clBtnShadow;
-  Canvas.FrameRect(R);
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-  else
-    Canvas.Brush.Color := clBtnFace;
-  InflateRect(R, -1, -1);
-  Canvas.FillRect(R);
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if Hot then
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipText]
-  else
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXOfficeKTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Pen.Color := BtnItemColors[bisPressed, ipFrame]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame]
-    else
-      Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Brush.Color := BtnItemColors[bisPressed, ipBody]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-    else if Boolean(State and PFS_MIXED) then
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else
-      Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Rectangle(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-      PFC_RADIOBUTTON:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Ellipse(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXOfficeKTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-var
-  Color, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, clBtnFace);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 0, R.Right, R.Top + 0,
-            NearestMixedColor(clBtnShadow, clBtnFace, 200));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1,
-            NearestMixedColor(clBtnShadow, clBtnFace, 128));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 2, R.Right, R.Top + 2,
-            NearestMixedColor(clBtnShadow, clBtnFace, 64));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 3, R.Right, R.Top + 3,
-            NearestMixedColor(clBtnShadow, clBtnFace, 32));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 4, R.Right, R.Top + 4,
-            NearestMixedColor(clBtnShadow, clBtnFace, 12));
-
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 3, R.Right, R.Bottom - 3,
-            NearestMixedColor(clBtnShadow, clBtnFace, 8));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 2, R.Right, R.Bottom - 2,
-            NearestMixedColor(clBtnShadow, clBtnFace, 16));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            NearestMixedColor(clBtnShadow, clBtnFace, 24));
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3,
-            clBtnShadow);
-          DrawLineEx(Canvas.Handle, R.Right + 1, R.Top + 5, R.Right + 1, R.Bottom
-            - 2, clBtnHighLight);
-        end;
-      {begin
-        if Part = SBP_PANE then Dec(R.Right, 3);
-        DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, StatusPanelFrameColor);
-      end;}
-      SBP_GRIPPER:
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXOfficeKTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  RegisterTBXTheme('OfficeK', TTBXOfficeKTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXReliferTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXReliferTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXReliferTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2407 +0,0 @@
-unit TBXReliferTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-//
-// 'SentimoX'
-//
-// 01.06.2004 - &#169; Roy Magne Klever
-//              <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//              First version.
-
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-{*$DEFINE SMALL_CLOSE_BUTTON}// remove the asterisk for smaller close button size
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXReliferTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-    Light3d: TColor;
-    Dark3d: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function  GetBooleanMetrics(Index: Integer): Boolean; override;
-    function  GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint; override;
-    function  GetIntegerMetrics(Index: Integer): Integer; override;
-    function  GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor; override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function  GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function  GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins); override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean); override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect; DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect; ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer); override;
-  end;
-
-var
-  MenuButtons,AltCaption,
-  CaptionOutline, DottedGrip: boolean;
-  SelGradient: integer;
-  BaseColor, BaseShade, SelColor: TColor;
-
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-  GradientBmp: TBitmap;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0, clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXReliferTheme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right); Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right); Inc(Bottom);
-  end;
-end;
-
-function TTBXReliferTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT:    Result:= False;
-    TMB_EDITHEIGHTEVEN:            Result:= False;
-    TMB_PAINTDOCKBACKGROUND:       Result:= True;
-    TMB_SOLIDTOOLBARNCAREA:        Result:= True;
-    TMB_SOLIDTOOLBARCLIENTAREA:    Result:= True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXReliferTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 4;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-
-    TMI_TLBR_SEPARATORSIZE: Result := 6;
-
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXReliferTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then Result := MenubarColor
-    else Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then Result := clWindow
-    else Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then Result := DockPanelColor;
-end;
-
-function TTBXReliferTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then B := bisPressed
-    else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then Result := clWindowFrame
-        else if (Result = clNone) then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXReliferTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then M := MFlags1[HoverKind = hkKeyboardHover]
-      else M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then B := bisPopupParent
-      else if Pushed then B := bisPressed
-      else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then Result := ToolbarColor;
-        if ItemPart = ipFrame then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-var
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then rc3 := 0 else if rc3 &gt; 255 then rc3 := 255;
-  if gc3 &lt; 0 then gc3 := 0 else if gc3 &gt; 255 then gc3 := 255;
-  if bc3 &lt; 0 then bc3 := 0 else if bc3 &gt; 255 then bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GradientBmp.Width := 1;
-    GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-    GSize := GradientBmp.Height;
-
-    y1 := GSize div 2;
-    for i := 0 to y1 - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[0] := GradCol;
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for i := y1 to GSize - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc3 + (((rc2 - rc3) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc3 + (((gc2 - gc3) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc3 + (((bc2 - bc3) * (i)) div GSize));
-      Row[0] := GradCol;
-    end;
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end else
-  begin
-    GradientBmp.Width := (ARect.Right - ARect.Left) - 1;
-    GradientBmp.Height := 1;
-    GSize := GradientBmp.Width;
-
-    y1 := GSize div 2;
-    Row := PRGBTripleArray(GradientBmp.ScanLine[0]);
-    for i := 0 to y1 - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[i] := GradCol;
-    end;
-
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-
-    for i := y1 to GSize - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc2 + (((rc3 - rc2) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc2 + (((gc3 - gc2) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc2 + (((bc3 - bc2) * (i)) div GSize));
-      Row[i] := GradCol;
-    end;
-
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end else begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter, ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div 2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXReliferTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXReliferTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXReliferTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXReliferTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2; {1} // rmkO
-      Border.Y := 2;
-    end else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else SetBorder(2, 2);
-  end
-  else SetBorder(0, 0);
-end;
-
-procedure TTBXReliferTheme.GetMargins(MarginID: Integer; out Margins: TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXReliferTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var R: TRect;
-begin
-  with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if not RectVisible(Handle, R) then Exit;
-    if (AViewType and DPVT_NORMAL = DPVT_NORMAL)
-      or ((AViewType and VT_TOOLBAR = VT_TOOLBAR)
-      and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end else
-    if not Transparent then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if (ItemInfo.ViewType and TVT_MENUBAR = TVT_MENUBAR)
-    and (ItemInfo.HoverKind &lt;&gt; hkNone)
-      and (MenuButtons = false) then
-      Font.Color := MenuItemColors[misHot, ipText]
-    else
-    begin
-      C:= Font.Color;
-      if (ItemInfo.ComboPart = cpSplitLeft) and (ItemInfo.IsPopupParent) then
-        if C = clNone then C := clBlack
-      else
-        if C = clNone then C := GetPartColor(ItemInfo, ipText);
-      Font.Color := C;
-    end;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := clBlack //GetBtnColor(ItemInfo, ipText)
-  else
-    if not ItemInfo.Enabled then
-      Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-    else
-      Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y - 2)]);
-end;
-
-procedure TTBXReliferTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then //FrameRectEx(Canvas, R, BtnItemColors[bisPressed, ipFrame])
-    else
-      if BtnHot then // Do nothing...
-      else
-        if Embedded then
-        begin
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-        end
-        else FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-          FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom)
-        else
-          PaintEnabled(R, BtnPressed);
-      end;
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame], True); // rmk Mod
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      // Upper button
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient2(Canvas.Handle, BR, clWhite, BaseShade, TGTopBottom)
-          else
-            if BtnHot then
-              FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button...
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient2(Canvas.Handle, BR, clWhite, BaseShade, TGTopBottom)
-          else
-            if BtnHot then
-              FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXReliferTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1; RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := Blend(clHighLight, clWindow, 20);
-      end
-      else
-        Pen.Color := Blend(clHighLight, clWindow, 15);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        if ShowHover then
-        begin
-          if Pushed then
-          begin
-            Canvas.Brush.Color := $00e0e0e0;
-            Canvas.FillRect(R);
-            DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right-1, R.Top, Dark3d);
-            DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom - 1, Dark3d);
-            DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, Light3d);
-            DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, Light3d);
-          end else
-          begin
-            InflateRect(R, -1, -1);
-            FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), clWhite, TGTopBottom);
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 0, 0); // rmkNew
-          end;
-        end;
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-      begin
-        FillGradient(Canvas, R, ToolBarColor, clWhite, TGTopBottom);
-        Pen.Color := $00c0c0c0;
-      end else
-      begin
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end;
-
-      // ---
-      if (Selected and Pushed) then
-      begin
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end else
-      if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      begin
-        FillGradient(Canvas, R, SelColor, clWhite, TGTopBottom);
-        Pen.Color := BaseColor;
-      end;
-
-      // ---
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, RL, RR);
-    end
-    else
-      if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        InflateRect(R, -1, -1);
-        FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), clWhite, TGTopBottom);
-        InflateRect(R, 1, 1);
-        Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom - Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := WinFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack;
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := clBlack;
-    end;
-
-    // Caption
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-
-      FillGradient2(Canvas.Handle, R, $00d0d0d0, $00f0f0f0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom-1, R.Right, R.Bottom-1, BarSepColor);
-
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      R.Bottom := R.Bottom - 1;
-
-      Font.Color := CaptionText;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX);
-    end;
-
-    // Close button
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y - 1);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      Brush.Color := CaptionColor;
-      FillGradient2(Canvas.Handle, R, $00d0d0d0, $00f0f0f0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left -1, R.Bottom, R.Right, R.Bottom, BarSepColor);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        InflateRect(R, -1, -1);
-        FillGradient(Canvas, R, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        Pen.Color := BtnItemColors[bisHot, ipFrame];
-        RoundFrame(Canvas, R, 1, 1);
-        DrawButtonBitmap(Canvas, R, clWhite);
-      end else
-        if BtnItemState = bisPressed then
-        begin
-          InflateRect(R, -1, -1);
-          FillGradient2(Canvas.Handle, R, $00f0f0f0, $00d0d0d0, TGTopBottom);
-          Canvas.Pen.Color:= clSilver;
-          RoundFrame(Canvas, R,1,1);
-          DrawButtonBitmap(Canvas, R, clBlack);
-        end else
-        begin
-          FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-          if not AltCaption then
-            FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-          if AltCaption then
-            DrawButtonBitmap(Canvas, R, clBlack)
-          else
-            DrawButtonBitmap(Canvas, R, clBlack);
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected or (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, GetPartColor(ItemInfo, ipBody), gradCol2, TGTopBottom);
-      if Pushed then
-        Canvas.Pen.Color := BtnItemColors[bisSelected, ipFrame]
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-
-function TTBXReliferTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXReliferTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex, IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXReliferTheme.PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  with ItemInfo do
-  if (Enabled and (HoverKind &lt;&gt; hkNone)) or (not Enabled and (HoverKind = hkKeyboardHover)) then
-  begin
-    R:= ARect;
-    Canvas.Pen.Color := Light3D;
-    Canvas.MoveTo(R.Left, R.Bottom);
-    Canvas.LineTo(R.Left, R.Top);
-    Canvas.LineTo(R.Right, R.Top);
-    Canvas.Pen.Color := Dark3D;
-    Canvas.MoveTo(R.Right - 1, R.Top);
-    Canvas.LineTo(R.Right - 1, R.Bottom - 1);
-    Canvas.LineTo(R.Left, R.Bottom - 1);
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1; RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        //InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          Canvas.Brush.Color := $00d0d0d0;
-          Canvas.FillRect(R);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right-1, R.Top, Dark3d);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom - 1, Dark3d);
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, Light3d);
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, Light3d);
-          //FillGradient(Canvas, R, ToolBarColor, clWhite, TGTopBottom);
-          //Pen.Color := $00c0c0c0;
-        end else
-        begin
-          Canvas.Brush.Color := $00f0f0f0;
-          Canvas.FillRect(R);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right-1, R.Top, Dark3d);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom - 1, Dark3d);
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, Light3d);
-          DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, Light3d);
-          //FillRectEx(Canvas.Handle, R, clWhite);
-          //Pen.Color := BtnItemColors[bisHot, ipFrame];
-        end;
-        //InflateRect(R, 1, 1);
-        //RoundFrame(Canvas, R, 2, 2);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then Pen.Color := clWhite
-      else Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2:= Arect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      InflateRect(R, -1, -1);
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo);
-var
-  hi1, hi2: TColor;
-begin
-  with Canvas do
-  begin
-    //Brush.Color := PopupFrameColor;
-
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    hi1:= clWhite;
-    hi2:= $00d0d0d0;;
-    DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right, R.Top, hi1); // Bottom
-    DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom - 1, hi1); // Right
-    DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, hi2); // Bottom
-    DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, hi2); // Right
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      Top := (Bottom div 2);// - 1;
-      Pen.Color:= Dark3d;
-      MoveTo(Left + 2, Top);
-      LineTo(Right - 2, Top);
-      inc(Top);
-      Pen.Color:= Light3d;
-      MoveTo(Left + 2, Top);
-      LineTo(Right - 2, Top);
-    end else if enabled then
-    begin
-      Left := (Right div 2) - 1;
-      Pen.Color:= Dark3d;
-      MoveTo(Left, Top+2);
-      LineTo(Left, Bottom-2);
-      inc(left);
-      Pen.Color:= Light3d;
-      MoveTo(Left, Top+2);
-      LineTo(Left, Bottom-2);
-    end;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0, 1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1: TColor;
-  I, J: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    R.Top := R.Top - 3;
-    PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-    R.Top:= R.Top + 2;
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW)
-    then
-    begin
-      DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right-1, R.Top + 1, Light3d); // Top
-      DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Left, R.Bottom - 1, Light3d); // Left
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, Dark3d); // Bottom
-      DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, Dark3d); // Right
-    end;
-
-    R.Top := R.Top + 1;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then R.Right := R.Left + Sz
-    else R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-
-
-    Hi1 := $008f8f8f;
-    Lo1 := $00aeaaa7;
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then j:= 4 else j:= 2;
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pen.Color:= Hi1;
-          MoveTo(R2.Left,i);
-          LineTo(R2.Left + j,i);
-          Pen.Color:= Lo1;
-          MoveTo(R2.Left,i + 1);
-          LineTo(R2.Left + j,i + 1);
-          Inc(i, 4);
-        end;
-      end else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pen.Color:= Hi1;
-          MoveTo(i, R2.Top);
-          LineTo(i + j, R2.Top);
-          Pen.Color:= Lo1;
-          MoveTo(i, R2.Top + 1);
-          LineTo(i + j, R2.Top + 1);
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var R: TRect;
-begin
-  Canvas.Pen.Width:= 0;
-  Canvas.Brush.Style:= bsSolid;
-  Canvas.Brush.Color:= $00e0e0e0;
-  R:= DockRect;
-  InFlateRect(R, 1,1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXReliferTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    R2 := R;
-
-      FrameRectEx(Canvas.Handle, R, $00e0e0e0{clBtnFace}, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := $00e0e0e0;
-        if IsVertical then Pixels[Right - 1, Top] := $00e0e0e0
-        else Pixels[Left, Bottom - 1] := $00e0e0e0;
-      end;
-
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clNone;
-      R.Bottom := R.Bottom + 1;
-      FillGradient2(Canvas.Handle, R, $00d0d0d0, $00f0f0f0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor);
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clNone;
-      R.Right := R.Right + 1;
-      FillGradient2(Canvas.Handle, R, $00d0d0d0, $00f0f0f0, TGLeftRight); // rmkB
-      DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom, BarSepColor);
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient(Canvas, R2, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        Pen.Color := BtnItemColors[bisHot, ipFrame];
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end else
-      if BtnItemState = bisPressed then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient2(Canvas.Handle, R2, $00f0f0f0, $00d0d0d0, TGTopBottom);
-        Pen.Color := clSilver;
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-        DrawButtonBitmap(Canvas, R2, clBlack)
-      end;
-    end;
-
-    if IsVertical then InflateRect(R, -4, 0)
-    else InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    if AltCaption then
-      Font.Color := clBlack
-    else
-      Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXReliferTheme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := $00909090;
-  gradHandle2 := $00d8d4d0;
-  gradHandle3 := $00d0d0d0;
-
-  gradBL := NearestMixedColor(clGray, gradCol1, 64);
-
-  Light3d:= clWhite;
-  Dark3d:= clSilver;
-
-  MenubarColor := $00f0f0f0;
-  ToolbarColor := $00f0f0f0;
-
-  PopupColor := $00f0f0f0;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clSilver;
-
-  BarSepColor := $a8a8a8;
-
-  EditFrameColor := Blend(clSilver, clWhite, 80);
-  EditFrameDisColor := Blend(clSilver, clWhite, 50); ;
-
-  HotBtnFace := Blend(BaseColor, clWhite, 80);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  WinFrameColors[wfsActive, wfpCaption] := clSilver;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clGray, 180);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  PnlFrameColors[wfsActive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive, wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clGray;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clGray, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clSilver;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clBlack;
-  BtnItemColors[bisHot, ipFrame] := Blend(BaseColor, clWhite, 80);
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clWhite;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText], BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame], BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BaseColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBlack;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BaseColor;
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];//clBlack;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGray, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(clGray, clWhite, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := clBlack;
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXReliferTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXReliferTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXReliferTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXReliferTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXReliferTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-    Canvas.Pen.Color := BaseColor;
-  end
-  else
-  begin
-    Canvas.Brush.Color := ToolBarColor;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := NearestMixedColor(clWhite, clGray, 64);
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clSilver;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clSilver;
-    Canvas.Pixels[Left, Bottom + 1] := clSilver;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if hot then
-    Canvas.Pen.Color := clWhite
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXReliferTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-  y1, i, GSize: Integer;
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const Canvas: TCanvas; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: boolean);
-  var
-    i: integer;
-  begin
-    rc1 := GetRValue(ColorToRGB(StartColor));
-    gc1 := GetGValue(ColorToRGB(StartColor));
-    bc1 := GetBValue(ColorToRGB(StartColor));
-    rc2 := GetRValue(ColorToRGB(EndColor));
-    gc2 := GetGValue(ColorToRGB(EndColor));
-    bc2 := GetBValue(ColorToRGB(EndColor));
-
-    rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-    gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-    bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-    if rc3 &lt; 0 then rc3 := 0 else if rc3 &gt; 255 then rc3 := 255;
-    if gc3 &lt; 0 then gc3 := 0 else if gc3 &gt; 255 then gc3 := 255;
-    if bc3 &lt; 0 then bc3 := 0 else if bc3 &gt; 255 then bc3 := 255;
-
-    if NewG then
-    begin
-      GradientBmp.Width := 1;
-      GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-      GSize := GradientBmp.Height;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-            Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-            Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i],  ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-            Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-            Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end else
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      for i := 0 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * i) div GSize)),
-            Byte(gc1 + (((gc2 - gc1) * i) div GSize)),
-            Byte(bc1 + (((bc2 - bc1) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then Result := BtnItemColors[bisHot, ipText]
-    else Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1); LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                FillGradient2(Canvas.Handle, R, clWhite, BaseShade{BaseColor}, TGTopBottom)
-              else
-                FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-            end else
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end else
-            begin
-              FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              FillGradient(Canvas, R, BaseShade, clWhite, TGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end else
-              Pen.Color := clSilver;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X - 2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                RadioGradient(Canvas, R, clWhite, BaseShade, false)
-              else
-                RadioGradient(Canvas, R, clWhite, BaseShade, true);
-              Pen.Color := clSilver;
-            end else
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              RadioGradient(Canvas, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end else
-            begin
-              RadioGradient(Canvas, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style:= bsClear;
-            X:= R.Left;
-            Y:= R.Top;
-            Polygon([Point(X, Y + 8),      Point(X, Y + 4),      Point(X + 1, Y + 3),
-                     Point(X + 1, Y + 2),  Point(X + 2, Y + 1),  Point(X + 3, Y + 1),
-                     Point(X + 4, Y),      Point(X + 8, Y),      Point(X + 9, Y + 1),
-                     Point(X + 10, Y + 1),  Point(X + 11, Y + 2),  Point(X + 11, Y + 3),
-                     Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                     Point(X + 11, Y + 10),  Point(X + 10, Y + 11),  Point(X + 9, Y + 11),
-                     Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                     Point(X + 2, Y + 11),  Point(X + 1, Y + 10),  Point(X + 1, Y + 9)]);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas, R, BaseShade, clWhite, true);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end else
-              Pen.Color := clSilver;
-
-            Brush.Style:= bsClear;
-            X:= R.Left;
-            Y:= R.Top;
-            Polygon([Point(X, Y + 8),      Point(X, Y + 4),      Point(X + 1, Y + 3),
-                     Point(X + 1, Y + 2),  Point(X + 2, Y + 1),  Point(X + 3, Y + 1),
-                     Point(X + 4, Y),      Point(X + 8, Y),      Point(X + 9, Y + 1),
-                     Point(X + 10, Y + 1),  Point(X + 11, Y + 2),  Point(X + 11, Y + 3),
-                     Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                     Point(X + 11, Y + 10),  Point(X + 10, Y + 11),  Point(X + 9, Y + 11),
-                     Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                     Point(X + 2, Y + 11),  Point(X + 1, Y + 10),  Point(X + 1, Y + 9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXReliferTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  Color, Hi, Lo, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D - 2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolBarColor, False, VT_UNKNOWN);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1, Light3d); // rmkO
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          if Part = SBP_LASTPANE then Exit;
-          R.Left := R.Right - 1;
-          Pen.Color:= Dark3d;
-          MoveTo(R.Left, R.Top + 2);
-          LineTo(R.Left, R.Bottom - 2);
-          inc(R.left);
-          Pen.Color:= Light3D;
-          MoveTo(R.Left, R.Top + 2);
-          LineTo(R.Left, R.Bottom - 2);
-        end;
-      SBP_GRIPPER:
-        if DottedGrip then
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end else
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Hi := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Lo := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXReliferTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then SetupColorCache;
-end;
-
-initialization
-  MenuButtons := false;
-  DottedGrip := false;
-  BaseColor:= $f6dac9;
-  BaseShade := clSilver;
-  SelColor := Blend(BaseColor, BaseShade, 90);
-  RegisterTBXTheme('Relifer', TTBXReliferTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXRomaTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXRomaTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXRomaTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,1539 +0,0 @@
-unit TBXRomaTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Roma' TBX theme &#169; 2004 Roy Magne Klever
-//
-//  Last updated: 28.08.2004
-
-interface
-
-{$I TB2Ver.inc}
-{$I TBX.inc}
-
-uses
-  Windows, Messages, Graphics, TBXThemes, TBXDefaultTheme, ImgList;
-
-type
-  TTBXRomaTheme = class(TTBXDefaultTheme)
-  protected
-    DockPanelColor: TColor;
-    DisabledColor: TColor;
-    procedure SetupColorCache; override;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access, etc. }
-    function  GetBooleanMetrics(Index: Integer): Boolean; override;
-    function  GetIntegerMetrics(Index: Integer): Integer; override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function  GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function  GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function  GetViewColor(AViewType: Integer): TColor; override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect; DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect; ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer); override;
-  end;
-
-implementation
-
-uses TBXUtils, TB2Item, TB2Common, Classes, Controls, Forms, Commctrl;
-
-var
-  StockImgList: TImageList;
-  StockPatternBitmap: TBitmap;
-  CounterLock: Integer = 0;
-
-procedure InitializeStock;
-begin
-  StockPatternBitmap := TBitmap.Create;
-  StockPatternBitmap.Width := 8;
-  StockPatternBitmap.Height := 8;
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0, clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockPatternBitmap.Free;
-  StockImgList.Free;
-end;
-
-procedure CreateDottedPattern(Color: TColor);
-var
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-begin
-  with StockPatternBitmap.Canvas do
-  begin
-    Brush.Color := Color;
-    Hi1:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 128));
-    Lo1:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 96));
-    Hi2:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-    Lo2:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 8));
-
-    Hi3:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-    Lo3:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-    Hi4:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-    FillRect(Rect(0, 0, 8, 8));
-    Pixels[0, 0]:= Hi1;
-    Pixels[0, 1]:= Hi2;
-    Pixels[1, 0]:= Lo1;
-    Pixels[1, 1]:= Lo2;
-    Pixels[1, 2]:= Hi4;
-    Pixels[2, 2]:= Hi3;
-    Pixels[2, 1]:= Lo3;
-
-    Pixels[4, 0]:= Hi1;
-    Pixels[4, 1]:= Hi2;
-    Pixels[5, 0]:= Lo1;
-    Pixels[5, 1]:= Lo2;
-    Pixels[5, 2]:= Hi4;
-    Pixels[6, 2]:= Hi3;
-    Pixels[6, 1]:= Lo3;
-
-    Pixels[0, 4]:= Hi1;
-    Pixels[0, 5]:= Hi2;
-    Pixels[1, 4]:= Lo1;
-    Pixels[1, 5]:= Lo2;
-    Pixels[1, 6]:= Hi4;
-    Pixels[2, 5]:= Hi3;
-    Pixels[2, 6]:= Lo3;
-
-    Pixels[4, 4]:= Hi1;
-    Pixels[4, 5]:= Hi2;
-    Pixels[5, 4]:= Lo1;
-    Pixels[5, 5]:= Lo2;
-    Pixels[5, 6]:= Hi4;
-    Pixels[6, 5]:= Hi3;
-    Pixels[6, 6]:= Lo3;
-  end;
-end;
-
-procedure DotFill(Canvas: TCanvas; R: TRect; Color: TColor; Border: Integer);
-var
-  DC: HDC;
-  Pt: TPoint;
-  W, H, I, J: Integer;
-  Brush: HBRUSH;
-begin
-  if Color &lt;&gt; clNone then
-  begin
-    CreateDottedPattern(Color);
-    Canvas.Brush.Style := bsSolid;
-    Canvas.Brush.Color := Color;
-    Canvas.FillRect(R);
-  end;
-  InflateRect(R, -Border, -Border);
-  W := R.Right - R.Left;
-  H := R.Bottom - R.Top;
-  W := ((W - 2) div 4) * 4 + 2;
-  H := ((H - 2) div 4) * 4 + 2;
-  R.Left := (R.Right + R.Left - W - 1) div 2;
-  R.Right := R.Left + W;
-  R.Top := (R.Top + R.Bottom - H - 1) div 2;
-  R.Bottom := R.Top + H;
-
-  if Color &lt;&gt; clNone then
-  begin
-    DC := Canvas.Handle;
-    Brush := CreatePatternBrush(StockPatternBitmap.Handle);
-    GetWindowOrgEx(DC, Pt);
-    SetBrushOrgEx(DC, R.Left - Pt.X, R.Top - Pt.Y, nil);
-    Windows.FillRect(DC, R, Brush);
-    DeleteObject(Brush);
-  end
-  else
-  begin
-    for J := 0 to (R.Bottom - R.Top - 1) div 4 do
-      for I := 0 to (R.Right - R.Left - 1) div 4 do
-        begin
-          Canvas.Pixels[R.Left + I * 4 + 1, R.Top + J * 4 + 1] := clBtnHighlight;
-          Canvas.Pixels[R.Left + I * 4 + 2, R.Top + J * 4 + 2] := clBtnShadow;
-        end;
-  end;
-end;
-
-procedure DotFillNew(Canvas: TCanvas; R: TRect; Color: TColor; Border: Integer);
-var
-  DC: HDC;
-  Pt: TPoint;
-  Brush: HBRUSH;
-begin
-  CreateDottedPattern(Color);
-  Canvas.Brush.Color := Color;
-  Canvas.FillRect(R);
-  InflateRect(R, -Border, -Border);
-  DC := Canvas.Handle;
-  Brush := CreatePatternBrush(StockPatternBitmap.Handle);
-  GetWindowOrgEx(DC, Pt);
-  SetBrushOrgEx(DC, R.Left - Pt.X, R.Top - Pt.Y, nil);
-  Windows.FillRect(DC, R, Brush);
-  DeleteObject(Brush);
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect);
-const
-  Pattern: array [0..15] of Byte = ($C6, 0, $6C, 0, $38, 0, $38, 0, $6C, 0, $C6, 0, 0, 0, 0, 0);
-begin
-  DrawGlyph(Canvas.Handle, R, 7, 6, Pattern[0], clBtnText);
-end;
-
-procedure RoundFrame(DC: HDC; R: TRect; RL, RR: Integer; C: TColor);
-var
-  P: array [0..8] of TPoint;
-  OldPen, Pen: HPen;
-begin
-  if C &lt; 0 then C := GetSysColor(C and $FF);
-  with R do
-  begin
-    Dec(Right); Dec(Bottom);
-    with P[0] do begin X := Left + RL; Y := Top; end;
-    with P[1] do begin X := Right - RR; Y := Top; end;
-    with P[2] do begin X := Right; Y := Top + RR; end;
-    with P[3] do begin X := Right; Y := Bottom - RR; end;
-    with P[4] do begin X := Right - RR; Y := Bottom; end;
-    with P[5] do begin X := Left + RL; Y := Bottom; end;
-    with P[6] do begin X := Left; Y := Bottom - RL; end;
-    with P[7] do begin X := Left; Y := Top + RL; end;
-    with P[8] do begin X := Left + RL; Y := Top; end;
-    Pen := CreatePen(PS_SOLID, 1, C);
-    OldPen := SelectObject(DC, Pen);
-    Windows.Polyline(DC, P[0], 9);
-    SelectObject(DC, OldPen);
-    DeleteObject(Pen);
-    Inc(Right); Inc(Bottom);
-  end;
-end;
-
-{ TTBXRomaTheme }
-
-function TTBXRomaTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_EDITHEIGHTEVEN:            Result := False;
-    TMB_PAINTDOCKBACKGROUND:       Result := False;
-    TMB_SOLIDTOOLBARNCAREA:        Result := False;
-    TMB_SOLIDTOOLBARCLIENTAREA:    Result := False;
-  else
-    Result := inherited GetBooleanMetrics(Index);
-  end;
-end;
-
-function TTBXRomaTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := ToolbarColor;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then Result := clBtnFace
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_POPUPMENU) = PVT_POPUPMENU then Result := clPopup
-    else if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then Result := clWindow
-    else if (AViewType and PVT_TOOLBOX) = PVT_TOOLBOX then Result := clWindow
-    else if (AViewType and PVT_CHEVRONMENU) = PVT_CHEVRONMENU then Result := clPopup;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then Result := DockPanelColor;
-end;
-
-function TTBXRomaTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := inherited GetItemColor(ItemInfo);
-end;
-
-function TTBXRomaTheme.GetIntegerMetrics(Index: Integer): Integer;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH:         Result := 12;
-    TMI_MENU_MDI_DW:                 Result := 1;
-    TMI_MENU_MDI_DH:                 Result := 2;
-    TMI_EDIT_FRAMEWIDTH:             Result := 2;
-    TMI_EDIT_TEXTMARGINHORZ:         Result := 2;
-    TMI_EDIT_TEXTMARGINVERT:         Result := 1;
-    TMI_EDIT_BTNWIDTH:               Result := 14;
-  else
-    Result := inherited GetIntegerMetrics(Index);
-  end;
-end;
-
-function TTBXRomaTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-var
-  InMenuBar, ToolbarStyle, ShowInactive: Boolean;
-begin
-  with ItemInfo do
-  begin
-    InMenuBar := (ItemInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR;
-    ToolbarStyle := Boolean(ItemOptions and IO_TOOLBARSTYLE);
-    ShowInactive := InMenubar and not Boolean(ItemOptions and IO_APPACTIVE);
-
-    if not ToolbarStyle and not Enabled and (HoverKind = hkKeyboardHover) then Result := clBtnShadow
-    else if not Enabled then Result := DisabledColor
-    else if not ToolbarStyle or InMenuBar then
-    begin
-      if HoverKind &lt;&gt; hkNone then Result := clHighlightText
-      else if ShowInactive then Result := clGrayText
-      else Result := clMenuText
-    end
-    else Result := clBtnText;
-  end;
-end;
-
-procedure TTBXRomaTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array [Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array [Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-  Sz: Integer;
-begin
-  Sz := 0;
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]);
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]);
-      Exit;
-    end
-    else Sz := 2;
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_LISTBOX) = PVT_LISTBOX then Sz := 2
-    else Sz := 3;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]);
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]);
-      Exit;
-    end
-    else Sz := 2;
-  end;
-  Border.X := Sz;
-  Border.Y := Sz;
-end;
-
-procedure TTBXRomaTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-const
-  STRIPE_STEP = 3;
-var
-  HighlightColor: TColor;
-  ShadowColor: TColor;
-  Y, I: Integer;
-  R: TRect;
-begin
-  if TBXLoColor then inherited
-  else with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if (AViewType and TVT_MENUBAR = TVT_MENUBAR) or
-      (AViewType and DPVT_NORMAL = DPVT_NORMAL) or
-      ((AViewType and VT_TOOLBAR = VT_TOOLBAR) and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else
-    begin
-      I := ColorIntensity(AColor);
-      if I &lt; 200 then I := (200 - I) div 20
-      else I := 0;
-      HighlightColor := GetNearestColor(Handle, Lighten(AColor, 8 + I));
-      ShadowColor := GetNearestColor(Handle, Lighten(AColor, -8));
-
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-
-      Y := (R.Top - ARect.Top) mod STRIPE_STEP;
-      Y := R.Top - Y;
-      while Y &lt; ARect.Bottom do
-      begin
-        DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, ShadowColor);
-        Inc(Y);
-        DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, HighlightColor);
-        Inc(Y, STRIPE_STEP - 1);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintCaption(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-  InMenuBar: Boolean;
-
-  procedure _Draw(Color: TColor);
-  begin
-    Canvas.Font.Color := Color;
-    if not Rotated then Windows.DrawText(Canvas.Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else DrawRotatedText(Canvas.Handle, ACaption, R, AFormat);
-  end;
-
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    InMenuBar := (ItemInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR;
-
-    if (Pushed or Selected) and not InMenuBar then OffsetRect(R, 1, 1);
-    C := Font.Color;
-    if C = clNone then C := GetItemTextColor(ItemInfo);
-    _Draw(C);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ArrowColor: array [Boolean] of TColor = (clBtnText, clMenuText);
-var
-  X, Y: Integer;
-  C: TColor;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    X := (Left + Right) div 2 + Ord(Pushed or Selected);
-    Y := (Top + Bottom) div 2 - 1 + Ord(Pushed or Selected);
-    if Enabled then C := ArrowColor[not Boolean(ItemOptions and IO_TOOLBARSTYLE)]
-    else C := DisabledColor;
-    Pen.Color := C;
-    Brush.Color := C;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  DC: HDC;
-  R: TRect;
-  C: TColor;
-  ShowHover, Embedded: Boolean;
-  RL, RR: Integer;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1; RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(DC, R, NearestMixedColor(clWindow, clBtnFace, 16));
-        InflateRect(R, 1, 1);
-        C := NearestMixedColor(clWindow, clBtnShadow, 64);
-      end
-      else
-        C := clBtnFace;
-      RoundFrame(DC, R, RL, RR, C);
-    end;
-
-    if (ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-      begin
-        Canvas.Brush.Color := clHighlight;
-        Canvas.FillRect(R);
-      end;
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-        DitherRect(DC, R, clWindow, clBtnHighlight)
-      else
-      begin
-        if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 128)
-        else C := clBtnHighlight;
-        DitherRect(DC, R, C, clBtnHighlight);
-      end;
-      {
-      with Canvas, R do
-      begin
-        PolyLineEx(DC, [Point(Left, Bottom - 2), Point(Left, Top), Point(Right - 1, Top)], clBtnFace);
-      end;
-      }
-      InflateRect(R, 1, 1);
-      RoundFrame(DC, R, RL, RR, clBtnShadow);
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      if HoverKind &lt;&gt; hkNone then
-      begin
-        if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-        else C := clBtnFace;
-        InflateRect(R, -1, -1);
-        DitherRect(DC, R, clBtnFace, C);
-        InflateRect(R, 1, 1);
-      end;
-      if not TBXLoColor then C := MixColors(clBtnShadow, clBtnFace, 192)
-      else C := clBtnShadow;
-      RoundFrame(DC, R, RL, RR, C);
-    end;
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-var
-  DC: HDC;
-  BorderColor, C: TColor;
-  SaveIndex: Integer;
-  Sz: TPoint;
-  R, R2: TRect;
-  Size: TSize;
-  CaptionString: string;
-  IsPushed, IsHovered: Boolean;
-begin
-  DC := Canvas.Handle;
-  with Canvas do
-  begin
-    BorderColor := NearestMixedColor(clBtnShadow, clBlack, 127);
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0  then
-    begin
-      R := ARect;
-      FrameRectEx(DC, R, BorderColor, True);
-      Windows.DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-      FrameRectEx(DC, R, clBtnFace, True);
-      FrameRectEx(DC, R, clBtnFace, True);
-
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with ARect, Sz do R2 := Rect(Left + X, Top + Y, Right - X, Bottom - Y);
-      with R2 do ExcludeClipRect(Canvas.Handle, Left, Top, Right, Bottom);
-      FillRectEx(DC, R, GetViewColor(WindowInfo.ViewType));
-      RestoreDC(DC, SaveIndex);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION));
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-
-      Dec(R.Bottom);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, clBtnFace);
-      Dec(R.Bottom);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right + 1, R.Bottom, DisabledColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION));
-
-      Font.Assign(SmCaptionFont);
-      Font.Color:= clBtnText;
-      CaptionString:= string(WindowInfo.Caption);
-      Size := TextExtent(CaptionString);
-      if Size.cx &gt; 0 then Inc(Size.cx, 16);
-      R2 := R;
-      R2.Top:= R2.Top - 1;
-      Brush.Color:= clBtnFace;
-      FillRect(R2);
-      InflateRect(R, -2, 0);
-      Dec(R.Top, 2);
-
-      DrawText(Canvas.Handle, PChar(CaptionString), Length(CaptionString), R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION));
-      with Windowinfo.FloatingBorderSize do OffsetRect(R, X, Y);
-
-      R.Left := R.Right - (R.Bottom - R.Top) - 1;      
-
-      FillRectEx(DC, R, clBtnFace);
-
-      Dec(R.Bottom, 2);
-      DrawLineEx(DC, R.Left, R.Bottom, R.Right, R.Bottom, DisabledColor);
-      Dec(R.Bottom, 2);
-      Inc(R.Left, 4);
-
-      IsPushed := (CDBS_PRESSED and WindowInfo.CloseButtonState) &lt;&gt; 0;
-      IsHovered := (CDBS_HOT and WindowInfo.CloseButtonState) &lt;&gt; 0;
-
-      if IsPushed or IsHovered then
-      begin
-        RoundFrame(DC, R, 1, 1, clBtnShadow);
-        InflateRect(R, -1, -1);
-        if IsPushed then FillRectEx(DC, R, clBtnHighlight)
-        else
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(DC, R, clBtnFace, C);
-        end;
-        if IsPushed then OffsetRect(R, 1, 1);
-      end;
-
-      DrawButtonBitmap(Canvas, R);
-    end;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  DC: HDC;
-  R: TRect;
-  E: Boolean;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, DisabledColor, False);
-    end
-    else if Pushed or Selected {or Embedded} or (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, clWindow, False);
-      InflateRect(R, 1, 1);
-      RoundFrame(DC, R, 1, 1, DisabledColor);
-    end
-    else
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(DC, R, DisabledColor, False);
-    end;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array [Boolean] of TColor = (clBtnText, clMenuText);
-var
-  DC: HDC;
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  C: TColor;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-      else C := clBtnHighlight;
-      DitherRect(DC, R, C, clBtnHighlight);
-    end
-    else if BtnHot then
-    begin
-      if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 192)
-      else C := clBtnFace;
-      DitherRect(DC, R, clBtnFace, C)
-    end
-    else if Embedded then FillRectEx(DC, R, clBtnFace);
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-//    W := EditFrameWidth;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if BtnHot or BtnPressed then InflateRect(R, -1, -1)
-      else InflateRect(R, -2, -2);
-      if not BtnDisabled then
-      begin
-        PaintEnabled(R, BtnPressed);
-        DrawLineEx(DC, R.Left - 1, R.Top, R.Left - 1, R.Bottom, DisabledColor);
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and (EBSS_UP or EBSS_DOWN)) &lt;&gt; 0;
-      if BtnHot or BtnPressed then InflateRect(R, -1, -1)
-      else InflateRect(R, -2, -2);
-
-      if not BtnDisabled then
-      begin
-        { Upper button }
-        BR := R; BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-
-        { Lower button }
-        BR := R; BR.Top := (R.Top + R.Bottom) div 2;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0);
-
-        DrawLineEx(DC, R.Left - 1, R.Top, R.Left - 1, R.Bottom, DisabledColor);
-        Y := (R.Top + R.Bottom - 1) div 2;
-        DrawLineEx(DC, R.Left, Y, R.Right, Y, DisabledColor);
-        Y := (R.Top + R.Bottom) div 2;
-        DrawLineEx(DC, R.Left, Y, R.Right, Y, DisabledColor);
-      end;
-
-      { Arrows }
-      if not BtnDisabled then Pen.Color := ArrowColor[not Boolean(ItemOptions and IO_TOOLBARSTYLE)]
-      else Pen.Color := DisabledColor;
-      Brush.Color := Pen.Color;
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (3 * R.Top + R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      X := (R.Left + R.Right) div 2 + Ord(BtnPressed);
-      Y := (R.Top + 3 * R.Bottom) div 4 + Ord(BtnPressed);
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-    end;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  DC: HDC;
-  R: TRect;
-  W: Integer;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-  
-  if ItemInfo.Enabled then FillRectEx(DC, R, clWindow);
-  InflateRect(R, -1, -1);
-
-  with EditInfo do if LeftBtnWidth &gt; 0 then Inc(R.Left, LeftBtnWidth - 2);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    R.Left := R.Right - EditInfo.RightBtnWidth - W;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      if Selected or Pushed then OffsetRect(ARect, 1, 1);
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if Selected or Pushed then OffsetRect(ARect, 1, 1)
-      else
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      BlendTBXIcon(Canvas, ARect, ImageList, ImageIndex, 200);
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-    (not Enabled and (HoverKind = hkKeyboardHover)) then
-  begin
-    PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, clHighlight, False, VT_UNKNOWN);
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  DC: HDC;
-  R: TRect;
-  ShowImageOrCheck: Boolean;
-  IsCombo: Boolean;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with ItemInfo do
-  begin
-    ShowImageOrCheck := (ImageWidth &gt; 0) or Selected;
-    IsCombo := ((ItemOptions and IO_COMBO) &lt;&gt; 0);
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-
-    R := ARect;
-    if ShowImageOrCheck then Inc(R.Left, ItemInfo.PopupMargin + MenuImageTextSpace);
-    if IsCombo and Enabled then Dec(R.Right, ArrowWidth + 1);
-
-    PaintMenuItemFrame(Canvas, R, ItemInfo);
-
-    if IsCombo then
-    begin
-      R.Left := ARect.Right - ArrowWidth;
-      R.Right := ARect.Right;
-      if Enabled and (HoverKind &lt;&gt; hkNone) then
-        PaintBackgnd(Canvas, ZERO_RECT, R, R, clHighlight, False, PVT_POPUPMENU)
-      else
-      begin
-        Dec(R.Left);
-        DrawLineEx(DC, R.Left, R.Top, R.Left, R.Bottom, DisabledColor);
-      end;
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then 
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3;
-      if not Enabled then
-      begin
-        if HoverKind = hkKeyboardHover then DrawArrow(clBtnShadow)
-        else DrawArrow(DisabledColor);
-      end
-      else if (HoverKind &lt;&gt; hkNone) {and not IsCombo} then DrawArrow(clHighlightText)
-      else DrawArrow(clMenuText);
-    end;
-
-    if ShowImageOrCheck and ((HoverKind &lt;&gt; hkNone) or Selected) then
-    begin
-      R.Left := ARect.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo);
-begin
-  Canvas.Brush.Color := GetNearestColor(Canvas.Handle, MixColors(clBtnShadow, clBlack, 127));
-  Canvas.FrameRect(R);
-  InflateRect(R, -1, -1);
-
-  if (PopupInfo.ViewType and PVT_LISTBOX) = PVT_LISTBOX then
-  begin
-    Windows.FillRect(Canvas.Handle, R, GetSysColorBrush(COLOR_WINDOW));
-  end
-  else if not USE_FLATMENUS or ((PopupInfo.ViewType and PVT_TOOLBOX) = PVT_TOOLBOX) then
-  begin
-    Canvas.Brush.Color := DockPanelColor;  // ToolbarColor;
-    Canvas.FillRect(R);
-  end
-  else
-  begin
-    Canvas.Brush.Color := clPopup;
-    Canvas.FillRect(R);
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  DC: HDC;
-begin
-  DC := Canvas.Handle;
-  with ItemInfo, ARect do
-  if Enabled then
-  begin
-    if Horizontal then
-    begin
-      Top := Bottom div 2;
-      DrawLineEx(DC, Left + 1, Top, Right - 1, Top, DisabledColor)
-    end
-    else if enabled then
-    begin
-      Left := Right div 2;
-      DrawLineEx(DC, Left, Top + 1, Left, Bottom - 1, DisabledColor);
-    end;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo);
-var
-  I, Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  BtnVisible, Horz, CloseButtondown, CloseButtonHover: Boolean;
-begin
-  with Canvas do
-  begin
-    { Border }
-    if ToolbarInfo.BorderStyle = bsSingle then
-      Windows.DrawEdge(Canvas.Handle, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-    FillRect(R);
-    Inflaterect(R, -1, -1);
-
-    { Drag Handle }
-    if not ToolbarInfo.AllowDrag then Exit;
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then R.Right := R.Left + Sz
-    else R.Bottom := R.Top + Sz;
-
-    C:= clBtnFace;
-    Hi1:= GetNearestColor(Handle, MixColors(c, clBtnShadow, 64));
-    Lo1:= GetNearestColor(Handle, MixColors(c, clBtnShadow, 48));
-    Hi2:= GetNearestColor(Handle, MixColors(c, clBtnShadow, 32));
-    Lo2:= GetNearestColor(Handle, MixColors(c, clBtnShadow, 16));
-    Hi3:= GetNearestColor(Handle, MixColors(c, clBtnHighlight, 128));
-    Lo3:= GetNearestColor(Handle, MixColors(c, clBtnHighlight, 96));
-    Hi4:= GetNearestColor(Handle, MixColors(c, clBtnHighlight, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2:= R;
-      if Horz then
-      begin
-        Dec(R2.Right,1);
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          if BtnVisible then
-          begin
-            Dec(R2.Right, Sz - 2);
-            if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-            begin
-              Inc(R2.Left, 2);
-              Dec(R2.Right, 2);
-            end else
-            begin
-              Inc(R2.Left, 4);
-              Dec(R2.Right, 4);
-            end;
-          end;
-        end;
-        i:= R2.Top;
-        while (i &lt; R2.Bottom-3) do
-        begin
-          Pixels[R2.Left,         i]:= Hi1;
-          Pixels[R2.Left,     i + 1]:= Hi2;
-          Pixels[R2.Left +     1, i]:= Lo1;
-          Pixels[R2.Left + 1, i + 1]:= Lo2;
-          Pixels[R2.Left + 1, i + 2]:= Hi4;
-          Pixels[R2.Left + 2, i + 2]:= Hi3;
-          Pixels[R2.Left + 2, i + 1]:= Lo3;
-          Inc(i, 4);
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[3 + R2.Left,         i]:= Hi1;
-            Pixels[3 + R2.Left,     i + 1]:= Hi2;
-            Pixels[3 + R2.Left +     1, i]:= Lo1;
-            Pixels[3 + R2.Left + 1, i + 1]:= Lo2;
-            Pixels[3 + R2.Left + 1, i + 2]:= Hi4;
-            Pixels[3 + R2.Left + 2, i + 2]:= Hi3;
-            Pixels[3 + R2.Left + 2, i + 1]:= Lo3;
-            Inc(i, 4);
-          end;
-        end;
-      end else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then begin
-          Dec(R2.Right, Sz - 2);
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then begin
-            Inc(R2.Top, 2);
-            Dec(R2.Bottom, 2);
-          end else begin
-            Inc(R2.Top, 4);
-            Dec(R2.Bottom, 4);
-          end;
-        end;
-        i:= R2.Left;
-        while (i &lt; R2.Right-3) do
-        begin
-          Pixels[i,         R2.Top]:= Hi1;
-          Pixels[i,     R2.Top + 1]:= Hi2;
-          Pixels[i + 1,     R2.Top]:= Lo1;
-          Pixels[i + 1, R2.Top + 1]:= Lo2;
-          Pixels[i + 1, R2.Top + 2]:= Hi4;
-          Pixels[i + 2, R2.Top + 2]:= Hi3;
-          Pixels[i + 2, R2.Top + 1]:= Lo3;
-          Inc(i, 4);
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i,         R2.Top + 3]:= Hi1;
-            Pixels[i,     R2.Top + 1 + 3]:= Hi2;
-            Pixels[i + 1,     R2.Top + 3]:= Lo1;
-            Pixels[i + 1, R2.Top + 1 + 3]:= Lo2;
-            Pixels[i + 1, R2.Top + 2 + 3]:= Hi4;
-            Pixels[i + 2, R2.Top + 2 + 3]:= Hi3;
-            Pixels[i + 2, R2.Top + 1 + 3]:= Lo3;
-            Inc(i, 4);
-          end;
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      CloseButtonDown := (ToolbarInfo.CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (ToolbarInfo.CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := GetTBXDockedCloseButtonRect(ToolbarInfo);
-      if Horz then OffsetRect(R2, -1, 0)
-      else Offsetrect(R2, 0, -1);
-
-      InflateRect(R2, -1, -1);
-      if CloseButtonDown or CloseButtonHover then
-      begin
-        if CloseButtonDown then
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-          else C := clBtnHighlight;
-          DitherRect(Canvas.Handle, R2, clBtnHighlight, C);
-        end
-        else
-        begin
-          if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(Canvas.Handle, R2, clBtnFace, C);
-        end;
-
-        InflateRect(R2, 1, 1);
-        if not TBXLoColor or not CloseButtonDown then
-          Pen.Color := NearestMixedColor(clBtnShadow, clBtnFace, 191)
-        else
-          Pen.Color := clBtnShadow;
-        RoundFrame(Canvas.Handle, R2, 1, 1, Pen.Color);
-      end;
-
-      if CloseButtonDown then OffsetRect(R2, 1, 1);
-      DrawButtonBitmap(Canvas, R2);
-    end;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2 + Ord(ItemInfo.Pushed);
-    Y := (Top + Bottom - StockImgList.Height - 1) div 2 + Ord(ItemInfo.Pushed);
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  DrawGlyph(Canvas.Handle, X, Y, StockImgList, Index, clBtnText);
-end;
-
-function TTBXRomaTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXRomaTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-end;
-
-destructor TTBXRomaTheme.Destroy;
-begin
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXRomaTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-begin
-  // this theme does not support dock painting
-end;
-
-procedure TTBXRomaTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect;
-  const DockPanelInfo: TTBXDockPanelInfo);
-var
-  DC: HDC;
-  Sz: Integer;
-  R2: TRect;
-  Flags: Integer;
-  CloseButtonDown, CloseButtonHover: Boolean;
-  C: TColor;
-  TextSize: TSize;
-begin
-  DC := Canvas.Handle;
-  with Canvas, DockPanelInfo do
-  begin
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-
-    { Border }
-    FrameRectEx(DC, R, ToolbarColor, True);
-    R2 := R;
-    if ShowCaption then
-      if IsVertical then Inc(R2.Top, Sz)
-      else Inc(R2.Left, Sz);
-    Brush.Color := DockPanelInfo.EffectiveColor;
-    FrameRect(R2);
-
-    if not ShowCaption then Exit;
-
-    C := DockPanelInfo.EffectiveColor;
-    Brush.Color := C;
-
-    R2 := R;
-    Pen.Color := NearestMixedColor(clBtnShadow, clBtnFace,  128);
-    if IsVertical then R.Bottom := R.Top + Sz
-    else R.Right := R.Left + Sz;
-    Windows.DrawEdge(Handle, R, BDR_RAISEDINNER, BF_RECT or BF_MIDDLE or BF_ADJUST);
-
-    { Close button }
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      CloseButtonDown := (CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := R;
-      Brush.Color := clBtnFace;
-
-      if IsVertical then
-      begin
-        Dec(R2.Right);
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Top := R2.Bottom - Sz + 2;
-        R.Bottom := R2.Top;
-      end;
-
-      InflateRect(R2, -2, -2);
-      if CloseButtonDown or CloseButtonHover then
-      begin
-        if CloseButtonDown then
-        begin
-          if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 126)
-          else C := clBtnHighlight;
-          DitherRect(DC, R2, clBtnHighlight, C);
-        end
-        else
-        begin
-          if not TBXLoColor then C := NearestMixedColor(clBtnHighlight, clBtnFace, 192)
-          else C := clBtnFace;
-          DitherRect(DC, R2, clBtnFace, C);
-        end;
-
-        InflateRect(R2, 1, 1);
-        if not TBXLoColor or not CloseButtonDown then
-          C := NearestMixedColor(clBtnShadow, clBtnFace, 191)
-        else
-          C := clBtnShadow;
-
-        RoundFrame(DC, R2, 1, 1, C);
-      end;
-
-      if CloseButtonDown then OffsetRect(R2, 1, 1);
-      DrawButtonBitmap(Canvas, R2);
-    end;
-
-    { Caption }
-    Brush.Color:= ToolbarColor;
-    if IsVertical then InflateRect(R, -1, 0)
-    else Inflaterect(R, 0, -1);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-
-    TextSize := TextExtent(string(Caption));
-    if IsVertical then
-    begin
-      if TextSize.Cx &gt; 0 then Inc(TextSize.Cx, 12);
-      if TextSize.Cx &lt; R.Right - R.Left then
-      begin
-        R2 := R;
-        Inc(R2.Top);
-        FillRect(R2);
-      end;
-    end;
-
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  DC: HDC;
-  R: TRect;
-  X, Y, Sz: Integer;
-  C: Longword;
-begin
-  DC := Canvas.Handle;
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then DitherRect(DC, R, clBtnFace, clBtnHighlight)
-  else FillRectEx(DC, R, clBtnFace);
-  InflateRect(R, 1, 1);
-  RoundFrame(DC, R, 1, 1, NearestMixedColor(clWindow, clBtnShadow, 64));
-  C := GetSysColor(COLOR_BTNFACE);
-  with R do
-  begin
-    SetPixelV(DC, Left, Top, C);
-    SetPixelV(DC, Left, Top, C);
-    SetPixelV(DC, Right + 1, Top, C);
-    SetPixelV(DC, Right + 1, Bottom + 1, C);
-    SetPixelV(DC, Left, Bottom + 1, C);
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  Canvas.Pen.Color := clBtnText;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-  C: TColor;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then Canvas.Pen.Color := clBtnText
-    else if Boolean(State and PFS_HOT) then Canvas.Pen.Color := clBtnText
-    else Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 126)
-      else C := clBtnHighlight;
-      Canvas.Brush.Bitmap := AllocPatternBitmap(C, clBtnHighlight);
-    end
-    else if Boolean(State and PFS_HOT) then
-    begin
-      if not TBXLoColor then C := MixColors(clBtnHighlight, clBtnFace, 192)
-      else C := clBtnFace;
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clBtnFace, C);
-    end
-    else if Boolean(State and PFS_MIXED) then Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then Result := clBtnFace
-    else if Boolean(State and PFS_MIXED) then Result := clBtnShadow
-    else Result := clBtnText;
-  end;
-
-begin
-  with Canvas do case Kind of
-    PFC_CHECKBOX:
-      begin
-        SetupPen;
-        SetupBrush;
-        InflateRect(R, -1, -1);
-        with R do Rectangle(Left, Top, Right, Bottom);
-        Pen.Style := psSolid;
-        Brush.Style := bsSolid;
-
-        if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-        begin
-          X := (R.Left + R.Right) div 2 - 1;
-          Y := (R.Top + R.Bottom) div 2 + 1;
-          Pen.Color := TextColor;
-          Brush.Color := Pen.Color;
-          Polygon([Point(X-2, Y), Point(X, Y+2), Point(X+4, Y-2),
-            Point(X+4, Y-4), Point(X, Y), Point(X-2, Y-2), Point(X-2, Y)]);
-        end;
-      end;
-    PFC_RADIOBUTTON:
-      begin
-        SetupPen;
-        SetupBrush;
-        InflateRect(R, -1, -1);
-        with R do Ellipse(Left, Top, Right, Bottom);
-        Pen.Style := psSolid;
-        Brush.Style := bsSolid;
-        if Boolean(State and PFS_CHECKED) then
-        begin
-          InflateRect(R, -3, -3);
-          Pen.Color := TextColor;
-          Brush.Color := Pen.Color;
-          with R do Ellipse(Left, Top, Right, Bottom);
-        end;
-      end;
-  else
-    inherited;
-  end;
-end;
-
-procedure TTBXRomaTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-var
-  Color, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, clBtnFace);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 0, R.Right, R.Top + 0, clBtnShadow);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1,
-            NearestMixedColor(clBtnShadow, clBtnFace,  128));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 2, R.Right, R.Top + 2,
-            NearestMixedColor(clBtnShadow, clBtnFace,  64));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 3, R.Right, R.Top + 3,
-            NearestMixedColor(clBtnShadow, clBtnFace,  32));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 4, R.Right, R.Top + 4,
-            NearestMixedColor(clBtnShadow, clBtnFace,  12));
-
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 3, R.Right, R.Bottom - 3,
-            NearestMixedColor(clBtnShadow, clBtnFace,  8));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 2, R.Right, R.Bottom - 2,
-            NearestMixedColor(clBtnShadow, clBtnFace,  16));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            NearestMixedColor(clBtnShadow, clBtnFace,  24));
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, DisabledColor);
-        end;
-      SBP_GRIPPER:
-        begin
-          Color:= clBtnFace;
-          Hi1:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2:= GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4:= GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do begin
-            Pixels[Right - 12, Bottom - 4]:= Lo2;
-            Pixels[Right - 12, Bottom - 3]:= Hi2;
-            Pixels[Right - 11, Bottom - 4]:= Lo1;
-            Pixels[Right - 11, Bottom - 3]:= Hi1;
-            Pixels[Right - 11, Bottom - 2]:= Hi4;
-            Pixels[Right - 10, Bottom - 2]:= Hi3;
-            Pixels[Right - 10, Bottom - 3]:= Lo3;
-
-            Pixels[Right - 8, Bottom - 4]:= Lo2;
-            Pixels[Right - 8, Bottom - 3]:= Hi2;
-            Pixels[Right - 7, Bottom - 4]:= Lo1;
-            Pixels[Right - 7, Bottom - 3]:= Hi1;
-            Pixels[Right - 7, Bottom - 2]:= Hi4;
-            Pixels[Right - 6, Bottom - 2]:= Hi3;
-            Pixels[Right - 6, Bottom - 3]:= Lo3;
-
-            Pixels[Right - 4, Bottom - 4]:= Lo2;
-            Pixels[Right - 4, Bottom - 3]:= Hi2;
-            Pixels[Right - 3, Bottom - 4]:= Lo1;
-            Pixels[Right - 3, Bottom - 3]:= Hi1;
-            Pixels[Right - 3, Bottom - 2]:= Hi4;
-            Pixels[Right - 2, Bottom - 2]:= Hi3;
-            Pixels[Right - 2, Bottom - 3]:= Lo3;
-
-            Pixels[Right - 8, Bottom - 8]:= Lo2;
-            Pixels[Right - 8, Bottom - 7]:= Hi2;
-            Pixels[Right - 7, Bottom - 8]:= Lo1;
-            Pixels[Right - 7, Bottom - 7]:= Hi1;
-            Pixels[Right - 7, Bottom - 6]:= Hi4;
-            Pixels[Right - 6, Bottom - 6]:= Hi3;
-            Pixels[Right - 6, Bottom - 7]:= Lo3;
-
-            Pixels[Right - 4, Bottom - 8]:= Lo2;
-            Pixels[Right - 4, Bottom - 7]:= Hi2;
-            Pixels[Right - 3, Bottom - 8]:= Lo1;
-            Pixels[Right - 3, Bottom - 7]:= Hi1;
-            Pixels[Right - 3, Bottom - 6]:= Hi4;
-            Pixels[Right - 2, Bottom - 6]:= Hi3;
-            Pixels[Right - 2, Bottom - 7]:= Lo3;
-
-            Pixels[Right - 4, Bottom - 12]:= Lo2;
-            Pixels[Right - 4, Bottom - 11]:= Hi2;
-            Pixels[Right - 3, Bottom - 12]:= Lo1;
-            Pixels[Right - 3, Bottom - 11]:= Hi1;
-            Pixels[Right - 3, Bottom - 10]:= Hi4;
-            Pixels[Right - 2, Bottom - 10]:= Hi3;
-            Pixels[Right - 2, Bottom - 11]:= Lo3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXRomaTheme.SetupColorCache;
-begin
-  DockPanelColor := NearestMixedColor(clBtnFace, clWindow, 64);
-  if not TBXLoColor then DisabledColor := MixColors(clBtnShadow, clBtnFace, 210)
-  else DisabledColor := clBtnShadow;
-  ToolbarColor := clBtnFace;
-end;
-
-procedure TTBXRomaTheme.GetMargins(MarginID: Integer; out Margins: TTBXMargins);
-begin
-  inherited;
-  if MarginID = MID_MENUITEM then
-  begin
-    Margins.TopHeight := 2;
-    Margins.BottomHeight := 2;
-  end;
-end;
-
-initialization
-
-RegisterTBXTheme('Roma', TTBXRomaTheme);
-
-end.

Deleted: Lobby/TASClient/Themes/TBXSentimoXTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXSentimoXTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXSentimoXTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2526 +0,0 @@
-unit TBXSentimoXTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'SentimoX' TBX theme &#169; 2004 Roy Magne Klever
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-// Version for TBX version 2.1
-// Last updated: 02.12.2004
-
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-{*$DEFINE SMALL_CLOSE_BUTTON}// remove the asterisk for smaller close button size
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXSentimoXTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-    Light3d: TColor;
-    Dark3d: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor; override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins); override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean); override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect; DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect; ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer); override;
-  end;
-
-var
-  MenuButtons, AltCaption,
-    CaptionOutline, DottedGrip: boolean;
-  SelGradient       : integer;
-  BaseColor, BaseShade, SelColor: TColor;
-
-{$IFDEF DTM_Package}
-function TBXThemeName: shortstring; stdcall;
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-{$ENDIF}
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-{$IFDEF DTM_Package}
-exports
-  TBXThemeName,
-  TBXRegisterTheme;
-
-const
-  cThemeName = 'SentimoX';
-
-function TBXThemeName: shortstring; stdcall;
-begin
-  result := cThemeName;
-end;
-
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-begin
-  if RegisterTheme then
-    RegisterTBXTheme(cThemeName, TTBXZezioTheme)
-  else
-    UnregisterTBXTheme(cThemeName);
-end;
-{$ENDIF}
-
-const
-  ZERO_RECT         : TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList      : TImageList;
-  CounterLock       : Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-  GradientBmp       : TBitmap;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0, clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXSentimoXTheme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right);
-    Inc(Bottom);
-  end;
-end;
-
-function TTBXSentimoXTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXSentimoXTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT           = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 4;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := 6;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXSentimoXTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXSentimoXTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  BFlags1           : array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2           : array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3           : array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B                 : TBtnItemState;
-  Embedded          : Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXSentimoXTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  MFlags1           : array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2           : array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1           : array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2           : array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3           : array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M                 : TMenuItemState;
-  B                 : TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then Result := ToolbarColor;
-        if ItemPart = ipFrame then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-var
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize    : Integer;
-
-  Row               : PRGBTripleArray;
-  GradCol           : TRGBTriple;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then
-    rc3 := 0
-  else if rc3 &gt; 255 then
-    rc3 := 255;
-  if gc3 &lt; 0 then
-    gc3 := 0
-  else if gc3 &gt; 255 then
-    gc3 := 255;
-  if bc3 &lt; 0 then
-    bc3 := 0
-  else if bc3 &gt; 255 then
-    bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GradientBmp.Width := 1;
-    GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-    GSize := GradientBmp.Height;
-
-    y1 := GSize div 2;
-    for i := 0 to y1 - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[0] := GradCol;
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for i := y1 to GSize - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc3 + (((rc2 - rc3) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc3 + (((gc2 - gc3) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc3 + (((bc2 - bc3) * (i)) div GSize));
-      Row[0] := GradCol;
-    end;
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end
-  else
-  begin
-    GradientBmp.Width := (ARect.Right - ARect.Left) - 1;
-    GradientBmp.Height := 1;
-    GSize := GradientBmp.Width;
-
-    y1 := GSize div 2;
-    Row := PRGBTripleArray(GradientBmp.ScanLine[0]);
-    for i := 0 to y1 - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[i] := GradCol;
-    end;
-
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-
-    for i := y1 to GSize - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc2 + (((rc3 - rc2) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc2 + (((gc3 - gc2) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc2 + (((bc3 - bc2) * (i)) div GSize));
-      Row[i] := GradCol;
-    end;
-
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2, Counter, GSize: Integer;
-  Brush             : HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter, ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern           : array[0..15] of Byte =
-    ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern           : array[0..15] of Byte =
-    (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp               : TBitmap;
-  W, H              : Integer;
-  Index             : Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div 2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXSentimoXTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXSentimoXTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXSentimoXTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXSentimoXTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics          : array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics          : array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable         : Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2; {1} // rmkO
-      Border.Y := 2;
-    end
-    else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXSentimoXTheme.GetMargins(MarginID: Integer; out Margins: TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXSentimoXTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  R                 : TRect;
-begin
-  with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if not RectVisible(Handle, R) then Exit;
-    if (AViewType and DPVT_NORMAL = DPVT_NORMAL)
-      or ((AViewType and VT_TOOLBAR = VT_TOOLBAR)
-      and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else if not Transparent then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if (ItemInfo.ViewType and TVT_MENUBAR = TVT_MENUBAR)
-    and (ItemInfo.HoverKind &lt;&gt; hkNone)
-      and (MenuButtons = false) then
-      Font.Color := MenuItemColors[misHot, ipText]
-    else
-    begin
-      C:= Font.Color;
-      if (ItemInfo.ComboPart = cpSplitLeft) and (ItemInfo.IsPopupParent) then
-        if C = clNone then C := clBlack
-      else
-        if C = clNone then C := GetPartColor(ItemInfo, ipText);
-      Font.Color := C;
-    end;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y              : Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := clBlack //GetBtnColor(ItemInfo, ipText)
-  else if not ItemInfo.Enabled then
-    Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y - 2)]);
-end;
-
-procedure TTBXSentimoXTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  Pattern           : array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2                : TRect;
-  Bmp               : TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor        : array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR             : TRect;
-  X, Y              : Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then //FrameRectEx(Canvas, R, BtnItemColors[bisPressed, ipFrame])
-    else if BtnHot then // Do nothing...
-    else if Embedded then
-    begin
-      FillRectEx(Canvas.Handle, R, ToolBarColor);
-      FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-    end
-    else
-      FrameRectEx(Canvas.Handle, R, EditFrameColor, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-          FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom)
-        else
-          PaintEnabled(R, BtnPressed);
-      end;
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame], True); // rmk Mod
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      // Upper button
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient2(Canvas.Handle, BR, clWhite, BaseShade, TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button...
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient2(Canvas.Handle, BR, clWhite, BaseShade, TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas, BR, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-            Pen.Color := clWhite
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R                 : TRect;
-  W                 : Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y              : Integer;
-begin
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end
-    else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXSentimoXTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R                 : TRect;
-  RL, RR            : Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1;
-      RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := Blend(clHighLight, clWindow, 20);
-      end
-      else
-        Pen.Color := Blend(clHighLight, clWindow, 15);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        if ShowHover then
-        begin
-          if Pushed then
-          begin
-            Canvas.Brush.Color := $00E0E0E0;
-            Canvas.FillRect(R);
-            DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right - 1, R.Top, Dark3d); // Top
-            DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom - 1, Dark3d); // Left
-            DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, Light3d); // Bottom
-            DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, Light3d); // Right
-          end
-          else
-          begin
-            InflateRect(R, -1, -1);
-            FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), clWhite, TGTopBottom);
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 0, 0); // rmkNew
-            //RoundFrame(Canvas, R, 1, 1);
-          end;
-        end;
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed and (HoverKind = hkNone) then
-      begin
-        FillGradient(Canvas, R, ToolBarColor, clWhite, TGTopBottom);
-        Pen.Color := $00C0C0C0;
-      end
-      else
-      begin
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end;
-
-      // ---
-      if (Selected and Pushed) then
-      begin
-        FillGradient2(Canvas.Handle, R, clWhite, BaseShade, TGTopBottom);
-        Pen.Color := BtnItemColors[bisSelected, ipFrame];
-      end
-      else if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      begin
-        FillGradient(Canvas, R, SelColor, clWhite, TGTopBottom);
-        Pen.Color := BaseColor;
-      end;
-
-      // ---
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, RL, RR);
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, GetBtnColor(ItemInfo, ipBody), clWhite, TGTopBottom);
-      InflateRect(R, 1, 1);
-      Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates         : array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-  ZERO_RECT         : TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState          : TWinFrameState;
-  BtnItemState      : TBtnItemState;
-  SaveIndex, X, Y   : Integer;
-  Sz                : TPoint;
-  R                 : TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel       : Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp             : TBitmap;
-    DC              : HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom - Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      if AltCaption then
-        CaptionText := WinFrameColors[WinState, wfpCaptionText]
-      else
-        CaptionText := clBlack;
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := clBlack;
-    end;
-
-    // Caption
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-
-      FillGradient2(Canvas.Handle, R, $00D0D0D0, $00F0F0F0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor);
-
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      R.Bottom := R.Bottom - 1;
-
-      Font.Color := CaptionText;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX);
-    end;
-
-    // Close button
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y - 1);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      Brush.Color := CaptionColor;
-      FillGradient2(Canvas.Handle, R, $00D0D0D0, $00F0F0F0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom, BarSepColor);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        InflateRect(R, -1, -1);
-        FillGradient(Canvas, R, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        Pen.Color := BtnItemColors[bisHot, ipFrame];
-        RoundFrame(Canvas, R, 1, 1);
-        DrawButtonBitmap(Canvas, R, clWhite);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        InflateRect(R, -1, -1);
-        FillGradient2(Canvas.Handle, R, $00F0F0F0, $00D0D0D0, TGTopBottom);
-        Canvas.Pen.Color := clSilver;
-        RoundFrame(Canvas, R, 1, 1);
-        DrawButtonBitmap(Canvas, R, clBlack);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-        if not AltCaption then
-          FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-        if AltCaption then
-          DrawButtonBitmap(Canvas, R, clBlack)
-        else
-          DrawButtonBitmap(Canvas, R, clBlack);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R                 : TRect;
-  E                 : Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected or (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, GetPartColor(ItemInfo, ipBody), gradCol2, TGTopBottom);
-      if Pushed then
-        Canvas.Pen.Color := BtnItemColors[bisSelected, ipFrame]
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-function TTBXSentimoXTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXSentimoXTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer);
-var
-  HiContrast        : Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex, IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index             : Integer;
-  X, Y              : Integer;
-  Bmp               : TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXSentimoXTheme.PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R                 : TRect;
-begin
-  with ItemInfo do
-    if (Enabled and (HoverKind &lt;&gt; hkNone)) or (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      R := ARect;
-      InflateRect(R, -1, -1);
-      FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-      InflateRect(R, 1, 1);
-      Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame];
-      RoundFrame(Canvas, R, 0, 0);
-    end;
-end;
-
-procedure TTBXSentimoXTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-var
-  R, R2             : TRect;
-  X, Y              : Integer;
-  ArrowWidth        : Integer;
-  ClrText           : TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-  var
-    R               : TRect;
-    RL, RR          : Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1;
-        RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          FillGradient(Canvas, R, ToolBarColor, clWhite, TGTopBottom);
-          Pen.Color := $00C0C0C0;
-        end
-        else
-        begin
-          FillRectEx(Canvas.Handle, R, clWhite);
-          Pen.Color := BtnItemColors[bisHot, ipFrame];
-        end;
-        InflateRect(R, 1, 1);
-        RoundFrame(Canvas, R, 2, 2);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := clWhite
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := Arect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      InflateRect(R, -1, -1);
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo);
-var
-  hi1, hi2          : TColor;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupColor;
-    FillRect(R);
-    hi1 := clWhite;
-    hi2 := $00D0D0D0;
-    DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right, R.Top, hi1);
-    DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom - 1, hi1);
-    DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, hi2);
-    DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, hi2);
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      Top := (Bottom div 2);
-      Pen.Color := Dark3d;
-      MoveTo(Left + 2, Top);
-      LineTo(Right - 2, Top);
-      inc(Top);
-      Pen.Color := Light3d;
-      MoveTo(Left + 2, Top);
-      LineTo(Right - 2, Top);
-    end
-    else if enabled then
-    begin
-      Left := (Right div 2) - 1;
-      Pen.Color := Dark3d;
-      MoveTo(Left, Top + 2);
-      LineTo(Left, Bottom - 2);
-      inc(left);
-      Pen.Color := Light3d;
-      MoveTo(Left, Top + 2);
-      LineTo(Left, Bottom - 2);
-    end;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets : array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0, 1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz                : Integer;
-  R2                : TRect;
-  C                 : TColor;
-  Hi1, Lo1          : TColor;
-  I, J              : Integer;
-  BtnVisible, Horz  : Boolean;
-  BtnItemState      : TBtnItemState;
-begin
-  with Canvas do
-  begin
-    R.Top := R.Top - 3;
-    PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-    R.Top := R.Top + 2;
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right - 1, R.Top + 1, Light3d); // Top
-      DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Left, R.Bottom - 1, Light3d); // Left
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, Dark3d); // Bottom
-      DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom - 1, Dark3d); // Right
-    end;
-
-    R.Top := R.Top + 1;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-
-    Hi1 := $008F8F8F;
-    Lo1 := $00AEAAA7;
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-        j := 4
-      else
-        j := 2;
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pen.Color := Hi1;
-          MoveTo(R2.Left, i);
-          LineTo(R2.Left + j, i);
-          Pen.Color := Lo1;
-          MoveTo(R2.Left, i + 1);
-          LineTo(R2.Left + j, i + 1);
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pen.Color := Hi1;
-          MoveTo(i, R2.Top);
-          LineTo(i + j, R2.Top);
-          Pen.Color := Lo1;
-          MoveTo(i, R2.Top + 1);
-          LineTo(i + j, R2.Top + 1);
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      if BtnItemState = bisHot then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient(Canvas, R2, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        Pen.Color := BtnItemColors[bisHot, ipFrame];
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient2(Canvas.Handle, R2, $00F0F0F0, $00D0D0D0, TGTopBottom);
-        Pen.Color := clSilver;
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-        DrawButtonBitmap(Canvas, R2, clBlack)
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R                 : TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := $00E0E0E0;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXSentimoXTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor    : TColor;
-  Sz, Flags: Integer;
-  R2                : TRect;
-  BtnItemState      : TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    R2 := R;
-
-    FrameRectEx(Canvas.Handle, R, $00E0E0E0, True);
-    FrameRectEx(Canvas.Handle, R, C, True);
-    with R do
-    begin
-      Pixels[Left, Top] := $00E0E0E0;
-      if IsVertical then
-        Pixels[Right - 1, Top] := $00E0E0E0
-      else
-        Pixels[Left, Bottom - 1] := $00E0E0E0;
-    end;
-
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clNone;
-      R.Bottom := R.Bottom + 1;
-      FillGradient2(Canvas.Handle, R, $00D0D0D0, $00F0F0F0, TGTopBottom); // rmkB
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, BarSepColor);
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clNone;
-      R.Right := R.Right + 1;
-      FillGradient2(Canvas.Handle, R, $00D0D0D0, $00F0F0F0, TGLeftRight); // rmkB
-      DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom, BarSepColor);
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient(Canvas, R2, BtnItemColors[bisHot, ipBody], clWhite, TGTopBottom);
-        Pen.Color := BtnItemColors[bisHot, ipFrame];
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end
-      else if BtnItemState = bisPressed then
-      begin
-        InflateRect(R2, -1, -1);
-        FillGradient2(Canvas.Handle, R2, $00F0F0F0, $00D0D0D0, TGTopBottom);
-        Pen.Color := clSilver;
-        RoundFrame(Canvas, R2, 1, 1);
-        DrawButtonBitmap(Canvas, R2, clWhite);
-      end
-      else
-      begin
-        FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-        DrawButtonBitmap(Canvas, R2, clBlack)
-      end;
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXSentimoXTheme.SetupColorCache;
-var
-  DC                : HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := Blend(BaseColor, clWhite, 80);
-  gradCol2 := clWhite;
-
-  gradHandle1 := $00909090;
-  gradHandle2 := $00D8D4D0;
-  gradHandle3 := $00D0D0D0;
-
-  gradBL := NearestMixedColor(clGray, gradCol1, 64);
-
-  Light3d := clWhite;
-  Dark3d := clSilver;
-
-  MenubarColor := $00F0F0F0;
-  ToolbarColor := $00F0F0F0;
-
-  PopupColor := $00F0F0F0;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clSilver;
-
-  BarSepColor := $A8A8A8;
-
-  EditFrameColor := Blend(clSilver, clWhite, 80);
-  EditFrameDisColor := Blend(clSilver, clWhite, 50);
-  ;
-
-  HotBtnFace := Blend(BaseColor, clWhite, 80);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  WinFrameColors[wfsActive, wfpCaption] := clSilver;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clGray, 180);
-
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clSilver, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := Blend(clGray, clWhite, 80);
-  PnlFrameColors[wfsActive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsActive, wfpCaptionText] := WinFrameColors[wfsActive, wfpCaptionText];
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clGray;
-  PnlFrameColors[wfsInactive, wfpCaption] := clSilver;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clGray, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clWhite;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clSilver;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := Blend(clSilver, clWhite, 50);
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clBlack;
-  BtnItemColors[bisHot, ipFrame] := Blend(BaseColor, clWhite, 80);
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clWhite;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText], BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame], BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBlack;
-  BtnItemColors[bisPopupParent, ipFrame] := BaseColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBlack;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGray, clWhite, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BaseColor;
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText]; //clBlack;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGray, clWhite, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(clGray, clWhite, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := clBlack;
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXSentimoXTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXSentimoXTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXSentimoXTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXSentimoXTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXSentimoXTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R                 : TRect;
-  X, Y, Sz          : Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    FillGradient(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-    Canvas.Pen.Color := BaseColor;
-  end
-  else
-  begin
-    Canvas.Brush.Color := ToolBarColor;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := NearestMixedColor(clWhite, clGray, 64);
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clSilver;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Top] := clSilver;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clSilver;
-    Canvas.Pixels[Left, Bottom + 1] := clSilver;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if hot then
-    Canvas.Pen.Color := clWhite
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXSentimoXTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs              : array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y              : Integer;
-
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize    : Integer;
-  Row               : PRGBTripleArray;
-  GradCol           : TRGBTriple;
-  Brush             : HBrush;
-
-  procedure RadioGradient(const Canvas: TCanvas; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: boolean);
-  var
-    i               : integer;
-  begin
-    rc1 := GetRValue(ColorToRGB(StartColor));
-    gc1 := GetGValue(ColorToRGB(StartColor));
-    bc1 := GetBValue(ColorToRGB(StartColor));
-    rc2 := GetRValue(ColorToRGB(EndColor));
-    gc2 := GetGValue(ColorToRGB(EndColor));
-    bc2 := GetBValue(ColorToRGB(EndColor));
-
-    rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-    gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-    bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-    if rc3 &lt; 0 then
-      rc3 := 0
-    else if rc3 &gt; 255 then
-      rc3 := 255;
-    if gc3 &lt; 0 then
-      gc3 := 0
-    else if gc3 &gt; 255 then
-      gc3 := 255;
-    if bc3 &lt; 0 then
-      bc3 := 0
-    else if bc3 &gt; 255 then
-      bc3 := 255;
-
-    if NewG then
-    begin
-      GradientBmp.Width := 1;
-      GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-      GSize := GradientBmp.Height;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-          Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-          Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-          Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-          Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end
-    else
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      for i := 0 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-          RGB(Byte(rc1 + (((rc2 - rc1) * i) div GSize)),
-          Byte(gc1 + (((gc2 - gc1) * i) div GSize)),
-          Byte(bc1 + (((bc2 - bc1) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                FillGradient2(Canvas.Handle, R, clWhite, BaseShade {BaseColor}, TGTopBottom)
-              else
-                FillGradient(Canvas, R, clWhite, BaseShade, TGTopBottom);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end
-            else
-            begin
-              FillGradient(Canvas, R, BaseColor, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              FillGradient(Canvas, R, BaseShade, clWhite, TGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end
-            else
-              Pen.Color := clSilver;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X - 2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                RadioGradient(Canvas, R, clWhite, BaseShade, false)
-              else
-                RadioGradient(Canvas, R, clWhite, BaseShade, true);
-              Pen.Color := clSilver;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              RadioGradient(Canvas, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end
-            else
-            begin
-              RadioGradient(Canvas, R, BaseColor, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y + 3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y + 11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y + 9)]);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas, R, BaseShade, clWhite, true);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end
-            else
-              Pen.Color := clSilver;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y + 3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y + 11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y + 9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXSentimoXTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-const
-  ZERO_RECT         : TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  Color, Hi, Lo, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D, Sz, i          : Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D - 2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolBarColor, False, VT_UNKNOWN);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1, Light3d); // rmkO
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          if Part = SBP_LASTPANE then Exit;
-          R.Left := R.Right - 1;
-          Pen.Color := Dark3d;
-          MoveTo(R.Left, R.Top + 2);
-          LineTo(R.Left, R.Bottom - 2);
-          inc(R.left);
-          Pen.Color := Light3D;
-          MoveTo(R.Left, R.Top + 2);
-          LineTo(R.Left, R.Bottom - 2);
-        end;
-      SBP_GRIPPER:
-        if DottedGrip then
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end
-        else
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Hi := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Lo := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXSentimoXTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then SetupColorCache;
-end;
-
-{$IFNDEF DTM_Package}
-initialization
-  MenuButtons := false;
-  DottedGrip := false;
-  BaseColor := $F6DAC9;
-  BaseShade := clSilver;
-  SelColor := Blend(BaseColor, BaseShade, 90);
-  RegisterTBXTheme('SentimoX', TTBXSentimoXTheme);
-{$ENDIF}
-end.
-

Deleted: Lobby/TASClient/Themes/TBXTristan2Theme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXTristan2Theme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXTristan2Theme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2327 +0,0 @@
-unit TBXTristan2Theme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Tristan2' TBX theme &#169;2004 Roy Magne Klever
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-// Version for TBX version 2.1
-// Last updated: 02.12.2004
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE}
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXTristan2Theme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-      override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated:
-      Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  GradientMenu: boolean;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-  TBVert: Boolean;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockImgList.Free;
-end;
-
-{ TTBXTristan2Theme }
-
-function TTBXTristan2Theme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False; {true}
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXTristan2Theme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := DEFAULT;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXTristan2Theme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXTristan2Theme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXTristan2Theme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  GSize: Integer;
-  rc1, rc2, gc1, gc2, bc1, bc2,
-    rc3, gc3, bc3,
-    y1, Counter: Integer;
-
-  Brush: HBrush;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 8);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 8);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 8);
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    y1 := GSize div 2;
-    for Counter := 0 to y1 - 1 do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for Counter := y1 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize {GSize})),
-        Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)),
-        Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    y1 := GSize div 2;
-    for Counter := 0 to y1 - 1 do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-      Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for Counter := y1 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize)),
-        Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)),
-        Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2,
-    bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom
-        - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXTristan2Theme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXTristan2Theme.GetItemTextColor(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXTristan2Theme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXTristan2Theme.GetViewBorder(ViewType: Integer; out Border:
-  TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-      Border.X := 1
-    else
-      Border.X := 2;
-    Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXTristan2Theme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXTristan2Theme.PaintBackgnd(Canvas: TCanvas; const ADockRect,
-  ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-  IsHoriz: boolean;
-begin
-  if (not Transparent) then
-  begin
-    {
-    if (((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((AViewType and TVT_MENUBAR) = TVT_MENUBAR) and (GradientMenu = true)))
-      and (not (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    }
-    if ((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-      if IsHoriz then
-      begin
-        TBVert := false;
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom)
-      end
-      else
-      begin
-        TBVert := true;
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-      end;
-    end
-    else
-    begin
-      //if (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)
-      //or (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)
-      //then
-      TBVert := false;
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-      {
-      if ((AViewType and TVT_NORMALTOOLBAR) &lt;&gt; TVT_NORMALTOOLBAR)
-        and ((AViewType and TVT_MENUBAR) &lt;&gt; TVT_MENUBAR)
-        and ((AViewType and PVT_CHEVRONMENU) &lt;&gt; PVT_CHEVRONMENU)
-        and ((AViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX) then
-      begin
-        R.Right := R.Right - 1;
-        //FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-        R.Right := R.Left + 24;
-        // this value is hardcoded but should be ItemInfo.PopupMargin
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-        //FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      end;
-      }
-    end;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    C := Font.Color;
-    Brush.Style := bsClear;
-    if C = clNone then C := GetItemTextColor(ItemInfo);
-    Font.Color := C;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXTristan2Theme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-begin
-  R := ARect;
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-    and ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-  InflateRect(R, 1, 1);
-  Inc(R.Left);
-  with Canvas do
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-          PaintButton(Canvas, R, ItemInfo)
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          R := ARect;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, R, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(R.Left - 1, R.Top);
-          LineTo(R.Left - 1, R.Bottom);
-        end;
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        // rmk 14.04.2003
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient(Canvas.Handle, BR, gradCol2, GetBtnColor(ItemInfo,
-              ipBody), TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Top := ARect.Top;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient(Canvas.Handle, BR, gradCol2, GetBtnColor(ItemInfo,
-              ipBody), TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Bottom := ARect.Bottom;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-end;
-
-procedure TTBXTristan2Theme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-  Embedded: Boolean;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-  if not (ItemInfo.Enabled or Embedded) then
-    FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipText], True);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True)
-    else
-    begin
-      Canvas.Brush.Color := clWindow;
-      Canvas.FrameRect(R);
-    end;
-  end;
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-  begin
-    Canvas.Brush.Color := clWindow;
-    Canvas.FillRect(R);
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-    begin
-      Canvas.Brush.Color := clBtnFace; //ToolbarColor;  //rmk April 0406
-      R := ARect;
-      InflateRect(R, -1, -1);
-      Canvas.FrameRect(R);
-    end;
-  end;
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintButton(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    if ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) and not Selected then
-    begin
-      Brush.Color := GetNearestColor(Handle, MixColors(clBtnShadow, clBtnFace,
-        100));
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      FrameRect(R);
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      //if (ComboPart = cpSplitLeft) and IsPopupParent then
-      //  Inc(R.Right);
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      if (Selected) and ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) then
-      begin
-        if IsVertical then
-        begin
-          if ComboPart = cpSplitLeft then
-          begin
-            R2 := R;
-            R2.Right := R2.Right + 12;
-            FillGradient(Canvas.Handle, R2, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGLeftRight);
-          end
-          else
-          begin
-            FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGLeftRight);
-          end;
-        end
-        else
-          FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-            gradCol2, TGTopBottom);
-      end
-      else
-      begin
-        if (HoverKind &lt;&gt; hkNone) and (((ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-          or ((ViewType and VT_POPUP) = VT_POPUP)) then
-        begin
-          if Pushed then
-          begin
-            if IsVertical then
-            begin
-              if (ComboPart = cpSplitLeft) or (ComboPart = cpSplitRight) then
-              begin
-                if (ComboPart = cpSplitRight) then
-                begin
-                  FillGradient(Canvas.Handle, R, gradCol2, gradCol1,
-                    TGLeftRight);
-                end
-                else
-                begin
-                  R2 := R;
-                  R2.Right := R.Right + 12;
-                  FillGradient(Canvas.Handle, R2, gradCol2, gradCol1,
-                    TGLeftRight);
-                end;
-              end
-              else
-                FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGLeftRight);
-            end
-            else
-              FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGTopBottom);
-          end
-          else if IsVertical then
-          begin
-            if (ComboPart = cpSplitLeft) or (ComboPart = cpSplitRight) then
-            begin
-              if (ComboPart = cpSplitRight) then
-              begin
-                MoveTo(R.Left, R.Top);
-                LineTo(R.Left, R.Bottom);
-              end
-              else
-              begin
-                R2 := R;
-                R2.Right := R.Right + 12;
-                FillGradient(Canvas.Handle, R2, GetBtnColor(ItemInfo, ipBody),
-                  gradCol2, TGLeftRight);
-              end;
-            end
-            else
-              FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-                gradCol2, TGLeftRight);
-          end
-          else
-            FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGTopBottom);
-        end
-        else
-          FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-      end;
-    end;
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-      if FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]) then
-        DrawButtonBitmap(Canvas, R, BtnItemColors[BtnItemState, ipText])
-      else
-        DrawButtonBitmap(Canvas, R, CaptionText);
-    end;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintFrame(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  with ItemInfo do
-    if Enabled and (HoverKind &lt;&gt; hkNone) then
-      //rmk Info: this is the painting of menu item selected...
-      FillGradient(Canvas.Handle, R, GetPartColor(ItemInfo, ipBody), gradCol2,
-        TGTopBottom);
-  FrameRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipFrame), True);
-end;
-
-function TTBXTristan2Theme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXTristan2Theme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-  Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin // rmk Removed the shadows under the glyphs and added back 14.04.2003
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 14.04.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXTristan2Theme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if (ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX then
-    with Canvas do
-    begin
-      R.Right := R.Left + ItemInfo.PopupMargin + 2;
-      Brush.Color := ToolbarColor;
-      FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-      Inc(R.Left);
-      R.Right := ARect.Right - 1;
-    end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXTristan2Theme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := ARect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R := R2;
-      R.Left := R2.Left + 1;
-      R.Right := R.Left + ItemInfo.PopupMargin - 2;
-      if HoverKind = hkNone then
-        FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True)
-      else
-      begin
-        Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        MoveTo(R.Right, R.Top);
-        LineTo(R.Right, R.Bottom);
-      end;
-      FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody), gradCol2,
-        TGTopBottom);
-    end;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      if not enabled then Exit;
-
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clWhite);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, gradCol1);
-      end
-      else
-      begin
-        Top := Bottom div 2;
-        MoveTo(Left, Top);
-        LineTo(Right - 2, Top);
-      end;
-    end
-    else if enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clWhite);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, gradCol1 {GradBL});
-    end;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR) and
-      (GradientMenu = true))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      with R do
-      begin
-        if (R.Right &gt; R.Bottom) then
-        begin
-          FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-          R2 := R;
-          R2.Left := R2.Right - 1;
-          FillGradient(Canvas.Handle, R2, GradBL, clBtnFace, TGTopBottom);
-
-          Pen.Color := gradBL;
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := clbtnFace; //gradCol1;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-          MoveTo(Right - 2, Top);
-          LineTo(Right - 2, Top + 1);
-          Pen.Color := gradCol1;
-          MoveTo(Right - 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 2);
-        end
-        else
-        begin
-          FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-          R2 := R;
-          R2.Top := R2.Bottom - 1;
-          FillGradient(Canvas.Handle, R2, GradBL, gradCol1, TGLeftRight);
-          Pen.Color := gradBL;
-          MoveTo(Right - 1, Top + 1);
-          LineTo(Right - 1, Bottom - 1);
-          Pen.Color := gradCol1;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-          MoveTo(Left, Bottom - 2);
-          LineTo(Left, Bottom);
-          MoveTo(Right - 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 2);
-        end;
-      end;
-      InflateRect(R, -2, -2);
-    end
-    else
-    begin
-      Canvas.Brush.Color := MenubarColor;
-      Canvas.FillRect(R);
-      InflateRect(R, -2, -2);
-    end;
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := clBtnFace;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXTristan2Theme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight); // rmkB
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear; //bsSolid;   // rmkB
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXTristan2Theme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := NearestMixedColor(clBtnShadow, clBtnFace, 48); //clBtnShadow;
-  gradCol2 := clWhite;
-  gradHandle1 := clBtnFace;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-  // gradBL = gradient bottom line just for your information...
-  gradBL := NearestMixedColor(clBtnShadow, gradCol1, 64); //clBtnShadow;
-
-  { View/Window Colors }
-  MenubarColor := clBtnFace;
-  ToolbarColor := gradCol2;
-  PopupColor := clWindow; //Blend(clBtnFace, clWindow, 143);
-  DockPanelColor := PopupColor;
-  PopupFrameColor := Blend(clBtnText, clBtnShadow, 20);
-  SetContrast(PopupFrameColor, PopupColor, 100);
-
-  HotBtnFace := Blend(clHighlight, clWindow, 30);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clBtnText, clBtnShadow, 15);
-  SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-  WinFrameColors[wfsActive, wfpCaption] := clBtnShadow;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-  //clBtnHighlight; // rmkB
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clBtnShadow, 180);
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsActive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-  PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := clNone;
-
-  BtnItemColors[bisSelected, ipBody] := Blend(clHighlight, Blend(clBtnFace,
-    clWindow, 50), 10);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := clHighlight;
-
-  BtnItemColors[bisPressed, ipBody] := Blend(clHighlight, clWindow, 50);
-  BtnItemColors[bisPressed, ipText] := clHighlight; // clHighlightText; // rmkB
-  BtnItemColors[bisPressed, ipFrame] := clHighlight;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clMenuText;
-  SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody],
-    180);
-  BtnItemColors[bisHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(clHighlight, clWindow, 50);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clHighlightText;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText],
-    BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := ToolbarColor;
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := PopupFrameColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80); // 145?
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-  DragHandleColor := Blend(clBtnShadow, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-  ToolbarSeparatorColor := Blend(clBtnShadow, clWindow, 70);
-  SetContrast(ToolbarSeparatorColor, ToolbarColor, 50);
-  PopupSeparatorColor := ToolbarSeparatorColor;
-  StatusPanelFrameColor := Blend(clWindow, clBtnFace, 30);
-  SetContrast(StatusPanelFrameColor, clBtnFace, 30);
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXTristan2Theme.GetPopupShadowType: Integer;
-begin
-  //Result := PST_OFFICEXP;
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXTristan2Theme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXTristan2Theme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXTristan2Theme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXTristan2Theme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipFrame]
-  else
-    Canvas.Brush.Color := clBtnShadow;
-  Canvas.FrameRect(R);
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-  else
-    Canvas.Brush.Color := clBtnFace;
-  InflateRect(R, -1, -1);
-  Canvas.FillRect(R);
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if Hot then
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipText]
-  else
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXTristan2Theme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Pen.Color := BtnItemColors[bisPressed, ipFrame]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame]
-    else
-      Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Brush.Color := BtnItemColors[bisPressed, ipBody]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-    else if Boolean(State and PFS_MIXED) then
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else
-      Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Rectangle(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-      PFC_RADIOBUTTON:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Ellipse(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXTristan2Theme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-var
-  Color, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, clBtnFace);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 0, R.Right, R.Top + 0,
-            NearestMixedColor(clBtnShadow, clBtnFace, 200));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1,
-            NearestMixedColor(clBtnShadow, clBtnFace, 128));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 2, R.Right, R.Top + 2,
-            NearestMixedColor(clBtnShadow, clBtnFace, 64));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 3, R.Right, R.Top + 3,
-            NearestMixedColor(clBtnShadow, clBtnFace, 32));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 4, R.Right, R.Top + 4,
-            NearestMixedColor(clBtnShadow, clBtnFace, 12));
-
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 3, R.Right, R.Bottom - 3,
-            NearestMixedColor(clBtnShadow, clBtnFace, 8));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 2, R.Right, R.Bottom - 2,
-            NearestMixedColor(clBtnShadow, clBtnFace, 16));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            NearestMixedColor(clBtnShadow, clBtnFace, 24));
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3,
-            clBtnShadow);
-          DrawLineEx(Canvas.Handle, R.Right + 1, R.Top + 5, R.Right + 1, R.Bottom
-            - 2, clBtnHighLight);
-        end;
-      {begin
-        if Part = SBP_PANE then Dec(R.Right, 3);
-        DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, StatusPanelFrameColor);
-      end;}
-      SBP_GRIPPER:
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXTristan2Theme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  RegisterTBXTheme('Tristan2', TTBXTristan2Theme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXTristanTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXTristanTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXTristanTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2365 +0,0 @@
-unit TBXTristanTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Tristan' TBX theme &#169; 2004 Roy Magne Klever
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-// Version for TBX version 2.1
-// Last updated: 02.12.2004
-
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE}
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXTristanTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  GradientMenu: boolean;
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockImgList.Free;
-end;
-
-{ TTBXTristanTheme }
-
-function TTBXTristanTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := True;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXTristanTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := DEFAULT;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXTristanTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXTristanTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXTristanTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  GSize: Integer;
-  rc1, rc2, gc1, gc2, bc1, bc2,
-    rc3, gc3, bc3,
-    y1, Counter: Integer;
-
-  Brush: HBrush;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    y1 := GSize div 2;
-    for Counter := 0 to y1 - 1 do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for Counter := y1 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize {GSize})),
-        Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)),
-        Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top + Counter, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    y1 := GSize div 2;
-    for Counter := 0 to y1 - 1 do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div y1)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div y1)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div y1))));
-      Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for Counter := y1 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc2 - rc3) * (Counter)) div GSize)),
-        Byte(gc3 + (((gc2 - gc3) * (Counter)) div GSize)),
-        Byte(bc3 + (((bc2 - bc3) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left + Counter, ARect.Top, ARect.Right,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure FillGradient2(const DC: HDC; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2,
-    bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom
-        - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(DC, Rect(ARect.Left, ARect.Top, ARect.Right - Counter,
-        ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXTristanTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXTristanTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXTristanTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXTristanTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-      Border.X := 2
-    else
-      Border.X := 2;
-    if (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX then
-      Border.Y := 2
-    else
-      Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXTristanTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3; {1}
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXTristanTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-  IsHoriz: boolean;
-begin
-  if (not Transparent) then
-  begin
-    if (((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((AViewType and TVT_MENUBAR) = TVT_MENUBAR) and (GradientMenu = true)))
-      and (not (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)
-      and (not (AViewType and TVT_FLOATING = TVT_FLOATING)))
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-      if IsHoriz then
-      begin
-        if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-          FillGradient2(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom)
-        else
-          FillGradient2(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      end
-      else
-      begin
-        if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-          FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight)
-        else
-          FillGradient2(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-      end;
-    end
-    else
-    begin
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      if (AViewType and TVT_FLOATING = TVT_FLOATING) then
-      begin
-        //FillGradient2(Canvas.Handle, R, clBtnFace, gradCol2, TGLeftRight);
-        FillRect(Canvas.Handle, R, Brush);
-      end
-      else
-        FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-      if ((AViewType and TVT_NORMALTOOLBAR) &lt;&gt; TVT_NORMALTOOLBAR)
-        and ((AViewType and TVT_MENUBAR) &lt;&gt; TVT_MENUBAR)
-        and ((AViewType and PVT_CHEVRONMENU) &lt;&gt; PVT_CHEVRONMENU)
-        and ((AViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX) then
-      begin
-        FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight); // rmkC
-        //R.Right:= R.Left + 24; {this value is hardcoded but should be ItemInfo.PopupMargin}
-        //FillGradient2(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-        //FillGradient(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    C := Font.Color;
-    Brush.Style := bsClear;
-    if C = clNone then C := GetItemTextColor(ItemInfo);
-    Font.Color := C;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXTristanTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-begin
-  R := ARect;
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-    and ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-  InflateRect(R, 1, 1);
-  Inc(R.Left);
-  with Canvas do
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-          PaintButton(Canvas, R, ItemInfo)
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          R := ARect;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, R, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(R.Left - 1, R.Top);
-          LineTo(R.Left - 1, R.Bottom);
-        end;
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        // rmk 14.04.2003
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            FillGradient(Canvas.Handle, BR, gradCol2, GetBtnColor(ItemInfo,
-              ipBody), TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Top := ARect.Top;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            FillGradient(Canvas.Handle, BR, gradCol2, GetBtnColor(ItemInfo,
-              ipBody), TGTopBottom)
-          else if BtnHot then
-            FillGradient(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipBody),
-              gradCol2, TGTopBottom);
-          FrameRectEx(Canvas.Handle, BR, GetBtnColor(ItemInfo, ipFrame), True);
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          BR.Left := ARect.Left;
-          BR.Bottom := ARect.Bottom;
-          BR.Right := ARect.Right;
-          if not Embedded then
-          begin
-            FrameRectEx(Canvas.Handle, BR, clWindow, True);
-            Pen.Color := clWindow;
-          end
-          else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-          MoveTo(BR.Left - 1, BR.Top);
-          LineTo(BR.Left - 1, BR.Bottom);
-        end;
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-end;
-
-procedure TTBXTristanTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-  Embedded: Boolean;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-  if not (ItemInfo.Enabled or Embedded) then
-    FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipText], True);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True)
-    else
-    begin
-      Canvas.Brush.Color := clWindow;
-      Canvas.FrameRect(R);
-    end;
-  end;
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-  begin
-    Canvas.Brush.Color := clWindow;
-    Canvas.FillRect(R);
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-    begin
-      Canvas.Brush.Color := clBtnFace; //ToolbarColor;  //rmk April 0406
-      R := ARect;
-      InflateRect(R, -1, -1);
-      Canvas.FrameRect(R);
-    end;
-  end;
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    if ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) and not Selected then
-    begin
-      Brush.Color := GetNearestColor(Handle, MixColors(clBtnShadow, clBtnFace,
-        100));
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      FrameRect(R);
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      if (ComboPart = cpSplitLeft) and IsPopupParent then Inc(R.Right);
-      if ComboPart = cpSplitRight then Dec(R.Left);
-      if ((Selected) and ((ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-        or ((ViewType and VT_POPUP) = VT_POPUP))
-        and (ItemInfo.ViewType and PVT_CHEVRONMENU &lt;&gt; PVT_CHEVRONMENU) then
-      begin
-        if IsVertical then
-          FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-            gradCol2, TGLeftRight)
-        else
-          FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-            gradCol2, TGTopBottom);
-      end
-      else
-      begin
-        if (HoverKind &lt;&gt; hkNone) and (((ViewType and VT_TOOLBAR) = VT_TOOLBAR)
-          or ((ViewType and VT_POPUP) = VT_POPUP)) then
-        begin
-          if Pushed then
-          begin
-            if IsVertical then
-              FillGradient2(Canvas.Handle, R, gradCol2, GetBtnColor(ItemInfo,
-                ipBody), TGLeftRight)
-            else
-              FillGradient2(Canvas.Handle, R, gradCol2, GetBtnColor(ItemInfo,
-                ipBody), TGTopBottom)
-          end
-          else
-          begin
-            if IsVertical then
-            begin
-              if ((ViewType and VT_POPUP) = VT_POPUP) and
-                (ItemInfo.ViewType and PVT_CHEVRONMENU &lt;&gt; PVT_CHEVRONMENU) then
-                FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-                  gradCol2, TGLeftRight)
-              else
-                FillGradient2(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-                  gradCol2, TGLeftRight)
-            end
-            else
-            begin
-              if (((ViewType and VT_POPUP) = VT_POPUP) or
-                ((ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-                and (ItemInfo.ViewType and PVT_CHEVRONMENU &lt;&gt; PVT_CHEVRONMENU)
-                  then
-                FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-                  gradCol2, TGTopBottom)
-              else
-                FillGradient2(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody),
-                  gradCol2, TGTopBottom);
-            end;
-          end;
-        end
-        else
-          FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-      end;
-    end;
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      //FillRect(R);
-      FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGTopBottom); // rmkB
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear; //rmkB
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      //FillRect(R);
-      FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGTopBottom); // rmkB
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-      if FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]) then
-        DrawButtonBitmap(Canvas, R, BtnItemColors[BtnItemState, ipText])
-      else
-        DrawButtonBitmap(Canvas, R, CaptionText);
-    end;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  with ItemInfo do
-    if Enabled and (HoverKind &lt;&gt; hkNone) then
-      //rmk Info: this is the painting of menu item selected...
-      FillGradient(Canvas.Handle, R, GetPartColor(ItemInfo, ipBody), gradCol2,
-        TGTopBottom);
-  FrameRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipFrame), True);
-end;
-
-function TTBXTristanTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXTristanTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-    Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex,
-          IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin // rmk Removed the shadows under the glyphs and added back 14.04.2003
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 14.04.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178}
-        255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXTristanTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if (ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX then
-    with Canvas do
-    begin
-      R.Right := R.Left + ItemInfo.PopupMargin + 2;
-      Brush.Color := ToolbarColor;
-      Inc(R.Left);
-      R.Right := ARect.Right - 1;
-    end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXTristanTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := ARect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R := R2;
-      R.Left := R2.Left + 1;
-      R.Right := R.Left + ItemInfo.PopupMargin - 2;
-      if HoverKind = hkNone then
-        FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-      FillGradient(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody), gradCol2,
-        TGTopBottom);
-    end;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        //FillRect(R);    // rmkA
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      // rmkPaint
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clWhite);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, gradCol1);
-      end
-      else
-      begin
-        Top := Bottom div 2;
-        MoveTo(Left, Top);
-        LineTo(Right - 2, Top);
-      end;
-    end
-    else if enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clWhite);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, gradCol1 {GradBL});
-    end;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR) and
-        (GradientMenu = true))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      with R do
-      begin
-        if (R.Right &gt; R.Bottom) then
-        begin
-          FillGradient2(Canvas.Handle, R, gradCol1, gradCol2, TGTopBottom);
-          R2 := R;
-          R2.Left := R2.Right - 1;
-          FillGradient2(Canvas.Handle, R2, GradBL, clBtnFace, TGTopBottom);
-          Pen.Color := gradBL;
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := clbtnFace;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-          MoveTo(Right - 1, Top);
-          LineTo(Right - 3, Top + 1);
-          Pen.Color := gradCol1;
-          MoveTo(Right - 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 2);
-        end
-        else
-        begin
-          FillGradient2(Canvas.Handle, R, gradCol1, gradCol2, TGLeftRight);
-          R2 := R;
-          R2.Top := R2.Bottom - 1;
-          FillGradient2(Canvas.Handle, R2, GradBL, gradCol1, TGLeftRight); //rmkC
-
-          Pen.Color := gradBL;
-          ;
-          MoveTo(Right - 1, Top + 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := gradCol1;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-          MoveTo(Left, Bottom - 2);
-          LineTo(Left, Bottom);
-          MoveTo(Right - 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 2);
-        end;
-      end;
-      InflateRect(R, -2, -2);
-    end
-    else
-    begin
-      Canvas.Brush.Color := MenubarColor;
-      Canvas.FillRect(R);
-      InflateRect(R, -2, -2);
-    end;
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := clBtnFace;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXTristanTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then
-          Pixels[Right - 1, Top] := clBtnFace
-        else
-          Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then
-        Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else
-        Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then
-          Pixels[Right - 1, Top] := C
-        else
-          Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      //R.Bottom := R.Top + Sz;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGTopBottom); // rmkB
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      FillGradient(Canvas.Handle, R, gradCol2, gradCol1, TGLeftRight); // rmkB
-      R.Right := R.Right - 1;
-    end;
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear; //bsSolid;   // rmkB
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXTristanTheme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  // gradColors rmk
-  // Standard
-  //gradCol1:= clBtnFace;
-  gradCol1 := NearestMixedColor(clBtnShadow, clBtnFace, 48); //clBtnShadow;
-  gradCol2 := clWhite;
-  gradHandle1 := clBtnFace;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-  // gradBL = gradient bottom line just for your information...
-  gradBL := NearestMixedColor(clBtnShadow, gradCol1, 64); //clBtnShadow;
-  // gradColors rmk end
-
-  if TBXLoColor then
-  begin
-    { View/Window Colors }
-    MenubarColor := clBtnFace;
-    ToolbarColor := clBtnFace;
-    PopupColor := clWindow;
-    DockPanelColor := clWindow;
-    StatusPanelFrameColor := clBtnShadow;
-
-    PopupFrameColor := clBtnText;
-    WinFrameColors[wfsActive, wfpBorder] := clBtnShadow;
-    WinFrameColors[wfsActive, wfpCaption] := clBtnShadow;
-    WinFrameColors[wfsActive, wfpCaptionText] := clBtnHighlight;
-    WinFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-    WinFrameColors[wfsInactive, wfpCaption] := clBtnShadow;
-    WinFrameColors[wfsInactive, wfpCaptionText] := clBtnHighlight;
-
-    PnlFrameColors[wfsActive, wfpBorder] := clBtnShadow;
-    PnlFrameColors[wfsActive, wfpCaption] := clBtnFace;
-    PnlFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-    PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-    PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-    PnlFrameColors[wfsInactive, wfpCaptionText] := clBtnText;
-
-    MenuItemColors[misNormal, ipBody] := clNone;
-    MenuItemColors[misNormal, ipText] := clWindowText;
-    MenuItemColors[misNormal, ipFrame] := clNone;
-    MenuItemColors[misDisabled, ipBody] := clNone;
-    MenuItemColors[misDisabled, ipText] := clGrayText;
-    MenuItemColors[misDisabled, ipFrame] := clNone;
-    MenuItemColors[misHot, ipBody] := clWindow;
-    MenuItemColors[misHot, ipText] := clWindowtext;
-    MenuItemColors[misHot, ipFrame] := clHighlight;
-    MenuItemColors[misDisabledHot, ipBody] := clWindow;
-    MenuItemColors[misDisabledHot, ipText] := clGrayText;
-    MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-    BtnItemColors[bisNormal, ipBody] := clNone;
-    BtnItemColors[bisNormal, ipText] := clBtnText;
-    BtnItemColors[bisNormal, ipFrame] := clNone;
-    BtnItemColors[bisDisabled, ipBody] := clNone;
-    BtnItemColors[bisDisabled, ipText] := clBtnShadow;
-    BtnItemColors[bisDisabled, ipFrame] := clNone;
-    BtnItemColors[bisSelected, ipBody] := clWindow;
-    BtnItemColors[bisSelected, ipText] := clWindowText;
-    BtnItemColors[bisSelected, ipFrame] := clHighlight;
-    BtnItemColors[bisPressed, ipBody] := clHighlight;
-    BtnItemColors[bisPressed, ipText] := clHighlightText;
-    BtnItemColors[bisPressed, ipFrame] := clHighlight;
-    BtnItemColors[bisHot, ipBody] := clWindow;
-    BtnItemColors[bisHot, ipText] := clWindowText;
-    BtnItemColors[bisHot, ipFrame] := clHighlight;
-    BtnItemColors[bisDisabledHot, ipBody] := clWindow;
-    BtnItemColors[bisDisabledHot, ipText] := clBtnShadow;
-    BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-    BtnItemColors[bisSelectedHot, ipBody] := clHighlight;
-    BtnItemColors[bisSelectedHot, ipText] := clHighlightText;
-    BtnItemColors[bisSelectedHot, ipFrame] := clHighlight;
-    BtnItemColors[bisPopupParent, ipBody] := clBtnFace;
-    BtnItemColors[bisPopupParent, ipText] := clBtnText;
-    BtnItemColors[bisPopupParent, ipFrame] := PopupFrameColor;
-
-    { Other Colors }
-    DragHandleColor := clBtnText;
-    IconShadowColor := clBtnFace;
-    PopupSeparatorColor := clBtnShadow;
-    ToolbarSeparatorColor := clBtnShadow;
-  end
-  else
-  begin
-    { View/Window Colors }
-    MenubarColor := clBtnFace;
-    ToolbarColor := gradCol2;
-    PopupColor := clWindow; //Blend(clBtnFace, clWindow, 143);
-    DockPanelColor := PopupColor;
-    PopupFrameColor := Blend(clBtnText, clBtnShadow, 20);
-    SetContrast(PopupFrameColor, PopupColor, 100);
-
-    HotBtnFace := Blend(clHighlight, clWindow, 30);
-    SetContrast(HotBtnFace, ToolbarColor, 50);
-    DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-    WinFrameColors[wfsActive, wfpBorder] := Blend(clBtnText, clBtnShadow, 15);
-    SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-    WinFrameColors[wfsActive, wfpCaption] := clBtnShadow;
-    WinFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-      //clBtnHighlight; // rmkB
-    SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clBtnShadow, 180);
-    WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-      wfpBorder];
-    WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-    WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-    SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-    PnlFrameColors[wfsActive, wfpBorder] := clBtnShadow;
-    PnlFrameColors[wfsActive, wfpCaption] := clBtnFace;
-    PnlFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-    PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-    PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-    PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-    SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-    BtnItemColors[bisNormal, ipBody] := clNone;
-    BtnItemColors[bisNormal, ipText] := clBtnText;
-    SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-    BtnItemColors[bisNormal, ipFrame] := clNone;
-    BtnItemColors[bisDisabled, ipBody] := clNone;
-    BtnItemColors[bisDisabled, ipText] := DisabledText;
-    SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-    BtnItemColors[bisDisabled, ipFrame] := clNone;
-    BtnItemColors[bisSelected, ipBody] := Blend(clHighlight, Blend(clBtnFace,
-      clWindow, 50), 10);
-    SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-    BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-    BtnItemColors[bisSelected, ipFrame] := Blend(clHighLight, clWindow, 50);
-      //clHighlight; // rmkPclHighlight;
-    BtnItemColors[bisPressed, ipBody] := Blend(clHighlight, clWindow, 50);
-    BtnItemColors[bisPressed, ipText] := Blend(clHighlight, clWindow, 50);
-      // clHighlightText;
-    BtnItemColors[bisPressed, ipFrame] := Blend(clHighLight, clWindow, 30);
-      //clHighlight; // rmkP
-    BtnItemColors[bisHot, ipBody] := HotBtnFace;
-    BtnItemColors[bisHot, ipText] := clMenuText;
-    //SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody], 180);
-    BtnItemColors[bisHot, ipFrame] := Blend(clHighLight, clWindow, 50);
-      //clHighlight; // rmkP
-    SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-    BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-    BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-    BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-    BtnItemColors[bisSelectedHot, ipBody] := Blend(clHighlight, clWindow, 50);
-    SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-    BtnItemColors[bisSelectedHot, ipText] := clHighlightText;
-    SetContrast(BtnItemColors[bisSelectedHot, ipText],
-      BtnItemColors[bisSelectedHot, ipBody], 180);
-    BtnItemColors[bisSelectedHot, ipFrame] := Blend(clHighLight, clWindow, 50);
-      //clHighlight; // rmkPclHighlight;
-    SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-      BtnItemColors[bisSelectedHot, ipBody], 100);
-    BtnItemColors[bisPopupParent, ipBody] := ToolbarColor;
-    BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-    BtnItemColors[bisPopupParent, ipFrame] := PopupFrameColor;
-
-    MenuItemColors[misNormal, ipBody] := clNone;
-    MenuItemColors[misNormal, ipText] := clWindowText;
-    SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-    MenuItemColors[misNormal, ipFrame] := clNone;
-    MenuItemColors[misDisabled, ipBody] := clNone;
-    MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-    SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80); // 145?
-    MenuItemColors[misDisabled, ipFrame] := clNone;
-    MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-    MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-    MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame]; // rmkP
-
-    MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-    MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-    MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-    DragHandleColor := Blend(clBtnShadow, clWindow, 75);
-    SetContrast(DragHandleColor, ToolbarColor, 85);
-    IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-    ToolbarSeparatorColor := Blend(clBtnShadow, clWindow, 70);
-    SetContrast(ToolbarSeparatorColor, ToolbarColor, 50);
-    PopupSeparatorColor := ToolbarSeparatorColor;
-    StatusPanelFrameColor := Blend(clWindow, clBtnFace, 30);
-    SetContrast(StatusPanelFrameColor, clBtnFace, 30);
-
-    Undither(MenubarColor);
-    Undither(ToolbarColor);
-    Undither(PopupColor);
-    Undither(DockPanelColor);
-    Undither(PopupFrameColor);
-    Undither(WinFrameColors[wfsActive, wfpBorder]);
-    Undither(WinFrameColors[wfsActive, wfpCaption]);
-    Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-    Undither(WinFrameColors[wfsInactive, wfpBorder]);
-    Undither(WinFrameColors[wfsInactive, wfpCaption]);
-    Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-    Undither(PnlFrameColors[wfsActive, wfpBorder]);
-    Undither(PnlFrameColors[wfsActive, wfpCaption]);
-    Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-    Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-    Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-    Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-    Undither(BtnItemColors[bisNormal, ipBody]);
-    Undither(BtnItemColors[bisNormal, ipText]);
-    Undither(BtnItemColors[bisNormal, ipFrame]);
-    Undither(BtnItemColors[bisDisabled, ipBody]);
-    Undither(BtnItemColors[bisDisabled, ipText]);
-    Undither(BtnItemColors[bisDisabled, ipFrame]);
-    Undither(BtnItemColors[bisSelected, ipBody]);
-    Undither(BtnItemColors[bisSelected, ipText]);
-    Undither(BtnItemColors[bisSelected, ipFrame]);
-    Undither(BtnItemColors[bisPressed, ipBody]);
-    Undither(BtnItemColors[bisPressed, ipText]);
-    Undither(BtnItemColors[bisPressed, ipFrame]);
-    Undither(BtnItemColors[bisHot, ipBody]);
-    Undither(BtnItemColors[bisHot, ipText]);
-    Undither(BtnItemColors[bisHot, ipFrame]);
-    Undither(BtnItemColors[bisDisabledHot, ipBody]);
-    Undither(BtnItemColors[bisDisabledHot, ipText]);
-    Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-    Undither(BtnItemColors[bisSelectedHot, ipBody]);
-    Undither(BtnItemColors[bisSelectedHot, ipText]);
-    Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-    Undither(BtnItemColors[bisPopupParent, ipBody]);
-    Undither(BtnItemColors[bisPopupParent, ipText]);
-    Undither(BtnItemColors[bisPopupParent, ipFrame]);
-    Undither(MenuItemColors[misNormal, ipBody]);
-    Undither(MenuItemColors[misNormal, ipText]);
-    Undither(MenuItemColors[misNormal, ipFrame]);
-    Undither(MenuItemColors[misDisabled, ipBody]);
-    Undither(MenuItemColors[misDisabled, ipText]);
-    Undither(MenuItemColors[misDisabled, ipFrame]);
-    Undither(MenuItemColors[misHot, ipBody]);
-    Undither(MenuItemColors[misHot, ipText]);
-    Undither(MenuItemColors[misHot, ipFrame]);
-    Undither(MenuItemColors[misDisabledHot, ipBody]);
-    Undither(MenuItemColors[misDisabledHot, ipText]);
-    Undither(MenuItemColors[misDisabledHot, ipFrame]);
-    Undither(DragHandleColor);
-    Undither(IconShadowColor);
-    Undither(ToolbarSeparatorColor);
-    Undither(PopupSeparatorColor);
-    Undither(StatusPanelFrameColor);
-  end;
-end;
-
-function TTBXTristanTheme.GetPopupShadowType: Integer;
-begin
-  //Result := PST_WINDOWS2K;
-  Result := PST_OFFICEXP;
-end;
-
-constructor TTBXTristanTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXTristanTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXTristanTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXTristanTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipFrame]
-  else
-    Canvas.Brush.Color := clBtnShadow;
-  Canvas.FrameRect(R);
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-  else
-    Canvas.Brush.Color := clBtnFace;
-  InflateRect(R, -1, -1);
-  Canvas.FillRect(R);
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if Hot then
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipText]
-  else
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXTristanTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Pen.Color := BtnItemColors[bisPressed, ipFrame]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame]
-    else
-      Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Brush.Color := BtnItemColors[bisPressed, ipBody]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-    else if Boolean(State and PFS_MIXED) then
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else
-      Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Rectangle(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-      PFC_RADIOBUTTON:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Ellipse(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXTristanTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-var
-  Color, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, clBtnFace);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 0, R.Right, R.Top + 0,
-            NearestMixedColor(clBtnShadow, clBtnFace, 200));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1,
-            NearestMixedColor(clBtnShadow, clBtnFace, 128));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 2, R.Right, R.Top + 2,
-            NearestMixedColor(clBtnShadow, clBtnFace, 64));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 3, R.Right, R.Top + 3,
-            NearestMixedColor(clBtnShadow, clBtnFace, 32));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 4, R.Right, R.Top + 4,
-            NearestMixedColor(clBtnShadow, clBtnFace, 12));
-
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 3, R.Right, R.Bottom - 3,
-            NearestMixedColor(clBtnShadow, clBtnFace, 8));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 2, R.Right, R.Bottom - 2,
-            NearestMixedColor(clBtnShadow, clBtnFace, 16));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            NearestMixedColor(clBtnShadow, clBtnFace, 24));
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3,
-            clBtnShadow);
-          DrawLineEx(Canvas.Handle, R.Right + 1, R.Top + 5, R.Right + 1, R.Bottom
-            - 2, clBtnHighLight);
-        end;
-      {begin
-        if Part = SBP_PANE then Dec(R.Right, 3);
-        DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, StatusPanelFrameColor);
-      end;}
-      SBP_GRIPPER:
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXTristanTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-initialization
-  RegisterTBXTheme('Tristan', TTBXTristanTheme);
-end.
-

Deleted: Lobby/TASClient/Themes/TBXWhidbeyTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXWhidbeyTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXWhidbeyTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2244 +0,0 @@
-unit TBXWhidbeyTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// &quot;Whidbey&quot; TBX theme &#169;2004 Roy Magne Klever
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-// Version for TBX version 2.1
-// Last updated: 02.12.2004
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE}
-{.$DEFINE ALT_HEADER_STYLE}
-{.$DEFINE ALT_VISUAL_STYLE}
-
-type
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXWhidbeyTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-      override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated:
-      Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-{$IFDEF DTM_Package}
-function TBXThemeName: shortstring; stdcall;
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-{$ENDIF}
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms, rmkThemes;
-
-{$IFDEF DTM_Package}
-exports
-  TBXThemeName,
-  TBXRegisterTheme;
-
-const
-  cThemeName = 'Whidbey';
-
-function TBXThemeName: shortstring; stdcall;
-begin
-  result := cThemeName;
-end;
-
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-begin
-  if RegisterTheme then
-    RegisterTBXTheme(cThemeName, TTBXWhidbeyTheme)
-  else
-    UnregisterTBXTheme(cThemeName);
-end;
-{$ENDIF}
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  GradientBmp: TBitmap;
-  gradCol1, gradCol2, gradHandle1, gradHandle2, gradHandle3, gradBL: TColor;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXWhidbeyTheme }
-
-function TTBXWhidbeyTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := True;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXWhidbeyTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-
-    TMI_MENU_IMGTEXTSPACE: Result := 3;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-
-    TMI_TLBR_SEPARATORSIZE: Result := DEFAULT;
-
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXWhidbeyTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXWhidbeyTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXWhidbeyTheme.GetPartColor(const ItemInfo: TTBXItemInfo;
-  ItemPart: TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-{
-procedure GradientFill(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2,
-    bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then
-  begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    if GSize = 0 then
-      GSize := 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left, ARect.Bottom - Counter -
-        1, ARect.Right, ARect.Bottom - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end
-  else
-  begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    if GSize = 0 then
-      GSize := 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Right - Counter - 1, ARect.Top,
-        ARect.Right - Counter, ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-}
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXWhidbeyTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXWhidbeyTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXWhidbeyTheme.GetItemImageBackground(const ItemInfo:
-  TTBXItemInfo): TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXWhidbeyTheme.GetViewBorder(ViewType: Integer; out Border:
-  TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-      Border.X := 1
-    else
-      Border.X := 2;
-    Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXWhidbeyTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3;
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect,
-  ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-  IsHoriz: boolean;
-begin
-  if not Transparent then
-  begin
-    if ((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      and (not (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-      if IsHoriz then
-      begin
-        R.Top := R.Top - 1;
-        R.Bottom := R.Bottom + 1;
-        GradientFill(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-        R.Bottom := R.Bottom - 1;
-        R.Top := R.Top + 1;
-      end
-      else
-      begin
-        R.Left := R.Left - 1;
-        R.Right := R.Right + 1;
-        GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-        R.Right := R.Right - 1;
-        R.Left := R.Left + 1;
-      end;
-    end
-    else
-    begin
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      //The rects are compared to determine if we're drawing a toolbar, not a popup menu...
-      if (ADockRect.Left &lt;&gt; ARect.Left) or (ADockRect.Top &lt;&gt; ARect.Top)
-        or (ADockRect.Right &lt;&gt; ARect.Right) or (ADockRect.Bottom &lt;&gt; ARect.Bottom)
-          then
-        GradientFill(Canvas, R, gradCol2, clBtnFace, TGLeftRight)
-      else
-        FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if Font.Color = clNone then Font.Color := GetPartColor(ItemInfo, ipText);
-    //Font.Color := GetPartColor(ItemInfo, ipText);
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXWhidbeyTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintEditButton(Canvas: TCanvas; const ARect:
-  TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  var
-    C: TColor;
-  begin
-    if BtnDisabled then
-      C := GetBtnColor(ItemInfo, ipFrame)
-    else if BtnHot or BtnPressed then
-      C := BtnItemColors[bisHot, ipFrame]
-    else
-    begin
-      if Embedded then
-        c := blend(gradCol1, gradCol2, 90)
-      else
-      begin
-        if (ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR then
-          c := blend(gradCol1, gradCol2, 90)
-        else
-          c := clWindow;
-      end;
-    end;
-    if Embedded then
-    begin
-      if not (BtnPressed or BtnHot) then
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end
-    else
-      FrameRectEx(Canvas.Handle, R, C, True);
-  end;
-
-begin
-  R := ARect;
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-  Inc(R.Left);
-  with Canvas do
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot then
-        begin
-          InflateRect(R, 1, 1);
-          PaintButton(Canvas, R, ItemInfo);
-          PaintEnabled(R, BtnPressed);
-        end
-        else
-          PaintEnabled(R, BtnPressed);
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-
-      // Upper button
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot then
-        begin
-          InflateRect(BR, 1, 1);
-          PaintButton(Canvas, BR, ItemInfo);
-          PaintEnabled(BR, BtnPressed);
-        end
-        else
-          PaintEnabled(BR, BtnPressed);
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      if (not BtnPressed) then
-        Pen.Color := GetPartColor(ItemInfo, ipText)
-      else
-        Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot then
-        begin
-          InflateRect(BR, 1, 1);
-          BR.Top := BR.Top + 1;
-          PaintButton(Canvas, BR, ItemInfo);
-          PaintEnabled(BR, BtnPressed);
-        end
-        else
-        begin
-          PaintEnabled(BR, BtnPressed);
-        end;
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      if (not BtnPressed) then
-        Pen.Color := GetPartColor(ItemInfo, ipText)
-      else
-        Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-  Embedded: Boolean;
-begin
-  R := ARect;
-  if ItemInfo.HoverKind &lt;&gt; hkNone then
-    FrameRectEx(Canvas.Handle, R, BtnItemColors[bisHot, ipFrame], true);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-  Embedded := ((ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-    ((ItemInfo.ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-  if not (ItemInfo.Enabled or Embedded) then
-    FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipText], true);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      if Embedded then
-        FrameRectEx(Canvas.Handle, R, blend(gradCol1, gradCol2, 90), True)
-      else
-        FrameRectEx(Canvas.Handle, R, clWindow, True)
-    else
-    begin
-      Canvas.Brush.Color := clWindow;
-      Canvas.FrameRect(R);
-    end;
-  end;
-  if ItemInfo.Enabled then
-  begin
-    Canvas.Brush.Color := clWindow;
-    Canvas.FillRect(R);
-    if ((ItemInfo.ViewType and VT_TOOLBAR) &lt;&gt; VT_TOOLBAR) and
-      (GetPartColor(ItemInfo, ipFrame) = clNone) then
-    begin
-      Canvas.Brush.Color := blend(gradCol1, gradCol2, 90);
-      R := ARect;
-      InflateRect(R, -1, -1);
-      Canvas.FrameRect(R);
-    end;
-  end;
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then
-      Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else
-      Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintButton(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-
-    if ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) and not Selected then
-    begin
-      Brush.Color := clRed;
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-      FrameRect(R);
-    end
-    else
-    begin
-      if ((ItemInfo.ViewType and TVT_EMBEDDED) &lt;&gt; 0) and (HoverKind = hkNone)
-        then
-        FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), true)
-      else
-        FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), true);
-      if (ComboPart = cpSplitLeft) and IsPopupParent then
-        Inc(R.Right);
-      if ComboPart = cpSplitRight then
-        Dec(R.Left);
-
-      if (Selected) and ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) then
-      begin
-        if (HoverKind &lt;&gt; hkNone) then
-        begin
-          if Pushed then
-            FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody))
-          else
-{$IFDEF ALT_VISUAL_STYLE}
-            FillRectEx(Canvas.Handle, R, Blend($0080E0FF, $002090E8, 50));
-{$ELSE}
-            FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-{$ENDIF}
-        end
-        else
-{$IFDEF ALT_VISUAL_STYLE}
-          GradientFill(Canvas, R, $0080E0FF, $002090E8, TGTopBottom);
-{$ELSE}
-          FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-{$ENDIF}
-      end
-      else
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (HoverKind &lt;&gt;
-        hkNone)
-      then
-      begin
-        FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-        //GradientFill(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-      end
-      else
-        FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-    end;
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then
-      Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do
-        ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom -
-          Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      FillRect(R);
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) -
-        1);
-      with WindowInfo.FloatingBorderSize do
-        OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom,
-        BodyColor);
-      Brush.Color := CaptionColor;
-      FillRect(R);
-      with R do
-      begin
-        X := (Left + Right - StockImgList.Width + 1) div 2;
-        Y := (Top + Bottom - StockImgList.Height) div 2;
-      end;
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-      if FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]) then
-        DrawGlyph(BtnItemColors[BtnItemState, ipText])
-      else
-        DrawGlyph(CaptionText);
-    end;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect;
-  const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  with ItemInfo do
-    if Enabled and (HoverKind &lt;&gt; hkNone) then
-      FillRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipBody));
-  FrameRectEx(Canvas.Handle, R, GetPartColor(ItemInfo, ipFrame), True);
-end;
-
-function TTBXWhidbeyTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXWhidbeyTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-  Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 255);
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXWhidbeyTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if ((ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX) then
-  begin
-    R.Right := R.Left + ItemInfo.PopupMargin + 2;
-    GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-    Inc(R.Left);
-    R.Right := ARect.Right - 1;
-  end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXWhidbeyTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y, I: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    ClrText := GetPartColor(ItemInfo, ipText);
-
-    R := ARect;
-    PaintMenuItemFrame(Canvas, R, ItemInfo);
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := GetPartColor(ItemInfo, ipFrame)
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    if Selected and Enabled then
-    begin
-      R2 := ARect;
-      if HoverKind = hkNone then
-      begin
-        InflateRect(R2, -1, -1);
-        i := 2;
-        R := R2;
-        R.Left := R2.Left + 1;
-        R.Right := R.Left + ItemInfo.PopupMargin - i;
-        FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-{$IFDEF ALT_VISUAL_STYLE}
-        GradientFill(Canvas, R, $0080E0FF, $002090E8, TGTopBottom)
-{$ELSE}
-        FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody))
-{$ENDIF}
-      end
-      else
-      begin
-{$IFDEF ALT_VISUAL_STYLE}
-        i := 0;
-{$ELSE}
-        InflateRect(R2, -1, -1);
-        i := 2;
-{$ENDIF}
-        R := R2;
-        R.Left := R2.Left + 1;
-        R.Right := R.Left + ItemInfo.PopupMargin - i;
-        FrameRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipFrame), True);
-{$IFDEF ALT_VISUAL_STYLE}
-        FillRectEx(Canvas.Handle, R, Blend($0080E0FF, $002090E8, 50));
-{$ELSE}
-        FillRectEx(Canvas.Handle, R, GetBtnColor(ItemInfo, ipBody));
-{$ENDIF}
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := PopupColor;//ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      if not enabled then
-        exit;
-
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clBtnHighLight);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top,
-          ToolbarSeparatorColor);
-      end
-      else
-      begin
-        Top := Bottom div 2;
-        Left := Left + 1;
-        Right := Right - 1;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, PopupSeparatorColor);
-      end;
-    end
-    else
-    if enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clBtnHighLight);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom,
-        ToolbarSeparatorColor);
-    end;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  C: TColor;
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (ToolbarInfo.ViewType = VT_TOOLBAR)
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-    begin
-      with R do
-      begin
-        if (Toolbarinfo.IsVertical) then
-        begin
-          GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-          R2 := R;
-          R2.Top := R2.Bottom - 1;
-
-          if ToolbarInfo.BorderStyle &lt;&gt; bsSingle then exit;
-
-          GradientFill(Canvas, R2, gradCol1, gradCol2, TGLeftRight);
-
-          Pen.Color := gradBL;
-          MoveTo(Right - 1, Top + 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pen.Color := gradCol1;
-          MoveTo(Left, Top);
-          LineTo(Left, Top + 1);
-
-          MoveTo(Left, Bottom - 2);
-          LineTo(Left, Bottom);
-        end
-        else
-        begin
-          GradientFill(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-          R2 := R;
-          R2.Top:= R.Top + 1;
-          R2.Left := R2.Right - 1;
-
-          if ToolbarInfo.BorderStyle &lt;&gt; bsSingle then exit;
-
-          GradientFill(Canvas, R2, GradBL, Blend(gradCol1, gradCol2, 50), TGTopBottom);
-
-
-          Pen.Color := gradBL;
-          MoveTo(Left + 1, Bottom - 1);
-          LineTo(Right - 1, Bottom - 1);
-
-          Pixels[Left, Top]:= Blend(gradCol1, gradCol2, 60);
-          Pixels[Left, Bottom - 1]:= gradCol1;
-          Pixels[Left, Bottom - 2]:= Blend(gradCol1, gradBL, 50);
-
-          Pixels[Right - 2, Top]:= Blend(gradCol1, gradCol2, 25);
-          Pixels[Right - 1, Bottom - 1]:= gradCol1;
-          Pixels[Right - 2, Bottom - 2]:= Blend(gradCol1, gradBL, 50);
-        end;
-      end;
-      InflateRect(R, -2, -2);
-    end
-    else
-    begin
-      GradientFill(Canvas, R, gradCol2, clBtnFace, TGLeftRight);
-      InflateRect(R, -2, -2);
-    end;
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    // Drag Handle
-    c := gradHandle1;
-    Brush.Color := c;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-        if Horz then
-          OffsetRect(R2, -2, 0)
-        else
-          OffsetRect(R2, 0, -2);
-      if Horz then
-      begin
-        Inc(R2.Top, 4);
-        Dec(R2.Bottom, 2);
-        Inc(R2.Left, 1);
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        i := R2.Top;
-        while (i &lt; R2.Bottom - 3) do
-        begin
-          Pixels[R2.Left, i] := Hi1;
-          Pixels[R2.Left, i + 1] := Hi2;
-          Pixels[R2.Left + 1, i] := Lo1;
-          Pixels[R2.Left + 1, i + 1] := Lo2;
-          Pixels[R2.Left + 1, i + 2] := Hi4;
-          Pixels[R2.Left + 2, i + 2] := Hi3;
-          Pixels[R2.Left + 2, i + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[R2.Left + 4, i] := Hi1;
-            Pixels[R2.Left + 4, i + 1] := Hi2;
-            Pixels[R2.Left + 4 + 1, i] := Lo1;
-            Pixels[R2.Left + 4 + 1, i + 1] := Lo2;
-            Pixels[R2.Left + 4 + 1, i + 2] := Hi4;
-            Pixels[R2.Left + 4 + 2, i + 2] := Hi3;
-            Pixels[R2.Left + 4 + 2, i + 1] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end
-      else
-      begin
-        Inc(R2.Left, 4);
-        Dec(R2.Right, 2);
-        Inc(R2.Top, 1);
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        i := R2.Left;
-        while (i &lt; R2.Right - 3) do
-        begin
-          Pixels[i, R2.Top] := Hi1;
-          Pixels[i, R2.Top + 1] := Hi2;
-          Pixels[i + 1, R2.Top] := Lo1;
-          Pixels[i + 1, R2.Top + 1] := Lo2;
-          Pixels[i + 1, R2.Top + 2] := Hi4;
-          Pixels[i + 2, R2.Top + 2] := Hi3;
-          Pixels[i + 2, R2.Top + 1] := Lo3;
-          if ToolbarInfo.DragHandleStyle = DHS_DOUBLE then
-          begin
-            Pixels[i, R2.Top + 4] := Hi1;
-            Pixels[i, R2.Top + 1 + 4] := Hi2;
-            Pixels[i + 1, R2.Top + 4] := Lo1;
-            Pixels[i + 1, R2.Top + 1 + 4] := Lo2;
-            Pixels[i + 1, R2.Top + 2 + 4] := Hi4;
-            Pixels[i + 2, R2.Top + 2 + 4] := Hi3;
-            Pixels[i + 2, R2.Top + 1 + 4] := Lo3;
-          end;
-          Inc(i, 4);
-        end;
-      end;
-    end;
-
-    // Close button
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect;
-  const DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  C: TColor;
-{$IFDEF ALT_HEADER_STYLE}
-  Hi1, Lo1, Hi2, Lo2, Hi3, Lo3, Hi4: TColor;
-  i: integer;
-{$ENDIF}
-  Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    R2 := R;
-
-    FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-    FrameRectEx(Canvas.Handle, R, C, True);
-    with R do
-    begin
-      Pixels[Left, Top] := clBtnFace;
-      if IsVertical then
-        Pixels[Right - 1, Top] := clBtnFace
-      else
-        Pixels[Left, Bottom - 1] := clBtnFace;
-    end;
-
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-{$IFDEF ALT_HEADER_STYLE}
-    C := clBtnShadow;
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      GradientFill(Canvas, R, gradCol1, gradCol2, TGTopBottom);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      GradientFill(Canvas, R, gradCol1, gradCol2, TGLeftRight);
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-    end;
-{$ELSE}
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz;
-      GradientFill(Canvas, R, gradCol2, clBtnFace, TGLeftRight);
-    end
-    else
-    begin
-      R.Right := R.Left + Sz;
-      GradientFill(Canvas, R, gradCol2, clBtnFace, TGTopBottom);
-    end;
-{$ENDIF}
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-      BtnItemState := GetBtnItemState(CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame],
-        True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-
-{$IFDEF ALT_HEADER_STYLE}
-    c := gradHandle1;
-    Hi1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 64));
-    Lo1 := GetNearestColor(Handle, MixColors(c, gradHandle2, 48));
-    Hi2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 32));
-    Lo2 := GetNearestColor(Handle, MixColors(c, gradHandle2, 16));
-    Hi3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 128));
-    Lo3 := GetNearestColor(Handle, MixColors(c, gradHandle3, 96));
-    Hi4 := GetNearestColor(Handle, MixColors(c, gradHandle3, 72));
-    R2 := R;
-    if IsVertical then
-    begin
-      Inc(R2.Top, 2);
-      Dec(R2.Bottom, 2);
-      Inc(R2.Left, 1);
-      i := R2.Top;
-      while (i &lt; R2.Bottom - 1) do
-      begin
-        Pixels[R2.Left, i] := Hi1;
-        Pixels[R2.Left, i + 1] := Hi2;
-        Pixels[R2.Left + 1, i] := Lo1;
-        Pixels[R2.Left + 1, i + 1] := Lo2;
-        Pixels[R2.Left + 1, i + 2] := Hi4;
-        Pixels[R2.Left + 2, i + 2] := Hi3;
-        Pixels[R2.Left + 2, i + 1] := Lo3;
-        Inc(i, 4);
-      end;
-    end
-    else
-    begin
-      Inc(R2.Left, 2);
-      Dec(R2.Right, 2);
-      Inc(R2.Top, 1);
-      i := R2.Left;
-      while (i &lt; R2.Right - 1) do
-      begin
-        Pixels[i, R2.Top] := Hi1;
-        Pixels[i, R2.Top + 1] := Hi2;
-        Pixels[i + 1, R2.Top] := Lo1;
-        Pixels[i + 1, R2.Top + 1] := Lo2;
-        Pixels[i + 1, R2.Top + 2] := Hi4;
-        Pixels[i + 2, R2.Top + 2] := Hi3;
-        Pixels[i + 2, R2.Top + 1] := Lo3;
-        Inc(i, 4);
-      end;
-    end;
-    if IsVertical then
-      InflateRect(R, -9, 0)
-    else
-      InflateRect(R, 0, -9);
-{$ELSE}
-    if IsVertical then
-      InflateRect(R, -4, 0)
-    else
-      InflateRect(R, 0, -4);
-{$ENDIF}
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-begin
-  GradientFill(Canvas, DockRect, gradCol2, clBtnFace, TGLeftRight);
-end;
-
-procedure TTBXWhidbeyTheme.SetupColorCache;
-var
-  DC: HDC;
-  SwapC, HotBtnFace, DisabledText: TColor;
-  i1, i2: integer;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := clBtnFace;
-  gradCol2 := clWindow;
-  i1 := ColorIntensity(GradCol1);
-  i2 := ColorIntensity(GradCol2);
-
-  if i1 &gt; i2 then
-  begin
-    SwapC := gradCol1;
-    gradCol1 := gradCol2;
-    gradCol2 := SwapC;
-  end;
-
-  if IsDarkColor(gradCol1) then
-  begin
-    if (i2 - i1) &lt; 30 then
-      gradCol2 := Lighten(gradCol2, (i1 - i2));
-  end
-  else if (i2 - i1) &lt; 30 then
-    gradCol1 := Lighten(gradCol1, (i1 - i2));
-
-  gradHandle1 := gradCol1;
-  gradHandle2 := clBtnShadow;
-  gradHandle3 := clBtnHighlight;
-  gradBL := blend(clBtnShadow, gradCol1, 95);
-
-  MenubarColor := Blend(gradCol1, gradCol2, 50);
-  ToolbarColor := Blend(gradCol1, gradCol2, 50);
-  PopupColor := Blend(clBtnFace, clWindow, 143);
-  DockPanelColor := PopupColor;
-  PopupFrameColor := Blend(clBtnText, clBtnShadow, 20);
-  SetContrast(PopupFrameColor, PopupColor, 100);
-
-  HotBtnFace := Blend(clHighlight, clWindow, 20);
-  DisabledText := blend(clBtnText, gradCol2, 50);
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clBtnText, clBtnShadow, 15);
-  SetContrast(WinFrameColors[wfsActive, wfpBorder], ToolbarColor, 120);
-  WinFrameColors[wfsActive, wfpCaption] := clBtnShadow;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBtnHighlight;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clBtnShadow, 180);
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsActive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clBtnText;
-  PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-
-  BtnItemColors[bisDisabled, ipFrame] := clNone;
-  BtnItemColors[bisSelected, ipBody] := Blend(clHighlight, Blend(clBtnFace,
-    clWindow, 50), 10);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := clHighlight;
-  BtnItemColors[bisPressed, ipBody] := Blend(clHighlight, clWindow, 50);
-  BtnItemColors[bisPressed, ipText] := clHighlightText;
-  BtnItemColors[bisPressed, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisPressed, ipFrame], ToolbarColor, 80);
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clMenuText;
-  SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody],
-    180);
-  BtnItemColors[bisHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisHot, ipFrame], ToolbarColor, 100);
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(clHighlight, clWindow, 40);
-
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clHighlightText;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText],
-    BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame],
-    BtnItemColors[bisSelectedHot, ipBody], 100);
-  BtnItemColors[bisPopupParent, ipBody] := Blend(clBtnFace, clWindow, 183);//ToolbarColor;
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := PopupFrameColor;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-
-  MenuItemColors[misNormal, ipFrame] := clNone;
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := DisabledText;
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-  DragHandleColor := Blend(clBtnShadow, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-  ToolbarSeparatorColor := Blend(clBtnShadow, clWindow, 70);
-  PopupSeparatorColor := ToolbarSeparatorColor;
-  SetContrast(PopupSeparatorColor, PopupColor, 50);
-  StatusPanelFrameColor := Blend(clWindow, clBtnFace, 30);
-  SetContrast(StatusPanelFrameColor, clBtnFace, 30);
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXWhidbeyTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_OFFICEXP;
-end;
-
-constructor TTBXWhidbeyTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXWhidbeyTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXWhidbeyTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXWhidbeyTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipFrame]
-  else
-    Canvas.Brush.Color := clBtnShadow;
-  Canvas.FrameRect(R);
-  if Hot then
-    Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-  else
-    Canvas.Brush.Color := clBtnFace;
-  InflateRect(R, -1, -1);
-  Canvas.FillRect(R);
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  if Hot then
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipText]
-  else
-    Canvas.Pen.Color := BtnItemColors[bisNormal, ipText];
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-var
-  X, Y: Integer;
-
-  procedure SetupPen;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Pen.Color := clBtnShadow
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Pen.Color := BtnItemColors[bisPressed, ipFrame]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame]
-    else
-      Canvas.Pen.Color := clBtnShadow;
-  end;
-
-  procedure SetupBrush;
-  begin
-    Canvas.Brush.Style := bsSolid;
-    if Boolean(State and PFS_DISABLED) then
-      Canvas.Brush.Style := bsClear
-    else if Boolean(State and PFS_PUSHED) then
-      Canvas.Brush.Color := BtnItemColors[bisPressed, ipBody]
-    else if Boolean(State and PFS_HOT) then
-      Canvas.Brush.Color := BtnItemColors[bisHot, ipBody]
-    else if Boolean(State and PFS_MIXED) then
-      Canvas.Brush.Bitmap := AllocPatternBitmap(clWindow, clBtnFace)
-    else
-      Canvas.Brush.Style := bsClear;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1);
-      LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Rectangle(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-      PFC_RADIOBUTTON:
-        begin
-          SetupPen;
-          SetupBrush;
-          InflateRect(R, -1, -1);
-          with R do
-            Ellipse(Left, Top, Right, Bottom);
-          Pen.Style := psSolid;
-          Brush.Style := bsSolid;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXWhidbeyTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-var
-  D, Sz: integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas, R do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Handle, R, clBtnFace);
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 2);
-          FrameRectEx(Handle, R, StatusPanelFrameColor, True);
-        end;
-      SBP_GRIPPER:
-        begin
-          D := 0;
-          Sz := Min(Right - Left, Bottom - Top);
-          case Sz of
-            0..8:
-              begin
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-              end;
-            9..11:
-              begin
-                DiagLine(clBtnFace);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-                DiagLine(clBtnFace);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-                DiagLine(clBtnFace);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-              end;
-            12..14:
-              begin
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnShadow);
-                DiagLine(clBtnHighlight);
-              end;
-          else
-            begin
-              DiagLine(clBtnShadow);
-              DiagLine(clBtnShadow);
-              DiagLine(clBtnHighlight);
-              DiagLine(clBtnFace);
-              DiagLine(clBtnShadow);
-              DiagLine(clBtnShadow);
-              DiagLine(clBtnShadow);
-              DiagLine(clBtnHighlight);
-              DiagLine(clBtnFace);
-              DiagLine(clBtnShadow);
-              DiagLine(clBtnShadow);
-              DiagLine(clBtnShadow);
-              DiagLine(clBtnHighlight);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXWhidbeyTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-{$IFNDEF DTM_Package}
-initialization
-  RegisterTBXTheme('Whidbey', TTBXWhidbeyTheme);
-{$ENDIF}
-
-end.
-

Deleted: Lobby/TASClient/Themes/TBXXitoTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXXitoTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXXitoTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2384 +0,0 @@
-unit TBXXitoTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-//
-// Xito theme by Roy Magne Klever
-//
-// 18.10.2003 - Roy Magne Klever <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roy.magne at os.ino.no</A>
-//              First version...
-//              &#169;2003 Roy Magne Klever
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE} // remove the asterisk to change appearance of disabled images
-{*$DEFINE SMALL_CLOSE_BUTTON}// remove the asterisk for smaller close button size
-
-type
-  TGradDir = (tGLeftRight, tGTopBottom);
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXXitoTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor; override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins); override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer); override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated: Boolean); override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect; DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect; ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo: TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer); override;
-  end;
-
-{$IFDEF DTM_Package}
-function TBXThemeName: shortstring; stdcall;
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-{$ENDIF}
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms;
-
-{$IFDEF DTM_Package}
-exports
-  TBXThemeName,
-  TBXRegisterTheme;
-
-const
-  cThemeName = 'Xito';
-
-function TBXThemeName: shortstring; stdcall;
-begin
-  result := cThemeName;
-end;
-
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-begin
-  if RegisterTheme then
-    RegisterTBXTheme(cThemeName, TTBXZezioTheme)
-  else
-    UnregisterTBXTheme(cThemeName);
-end;
-{$ENDIF}
-
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-  GradientBmp: TBitmap;
-  gradCol1, gradCol2,
-    gradHandle1, gradHandle2, gradHandle3,
-    gradBL, gradTL: TColor;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0, clWhite);
-  GradientBmp := TBitmap.Create;
-  GradientBmp.PixelFormat := pf24bit;
-end;
-
-procedure FinalizeStock;
-begin
-  GradientBmp.Free;
-  StockImgList.Free;
-end;
-
-{ TTBXXitoTheme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right); Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right); Inc(Bottom);
-  end;
-end;
-
-function TTBXXitoTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT:    Result:= False;
-    TMB_EDITHEIGHTEVEN:            Result:= False;
-    TMB_PAINTDOCKBACKGROUND:       Result:= True;
-    TMB_SOLIDTOOLBARNCAREA:        Result:= True;
-    TMB_SOLIDTOOLBARCLIENTAREA:    Result:= True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXXitoTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-
-    TMI_MENU_IMGTEXTSPACE: Result := 0;
-    TMI_MENU_LCAPTIONMARGIN: Result := 8;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 7;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-
-    TMI_TLBR_SEPARATORSIZE: Result := 5;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := DEFAULT;
-  end;
-end;
-
-function TTBXXitoTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then Result := MenubarColor
-    else Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then Result := clWindow
-    else Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then Result := DockPanelColor;
-end;
-
-function TTBXXitoTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then B := bisPressed
-    else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then Result := clWindowFrame
-        else if (Result = clNone) then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXXitoTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-    with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then M := MFlags1[HoverKind = hkKeyboardHover]
-      else M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then B := bisPopupParent
-      else if Pushed then B := bisPressed
-      else if Selected then B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-      if ItemPart = ipBody then Result := ToolbarColor;
-      if ItemPart = ipFrame then Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure FillGradient(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-var
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-    y1, i, GSize: Integer;
-
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-begin
-  rc2 := GetRValue(ColorToRGB(StartColor));
-  gc2 := GetGValue(ColorToRGB(StartColor));
-  bc2 := GetBValue(ColorToRGB(StartColor));
-  rc1 := GetRValue(ColorToRGB(EndColor));
-  gc1 := GetGValue(ColorToRGB(EndColor));
-  bc1 := GetBValue(ColorToRGB(EndColor));
-
-  rc3 := rc1 + (((rc2 - rc1) * 15) div 9);
-  gc3 := gc1 + (((gc2 - gc1) * 15) div 9);
-  bc3 := bc1 + (((bc2 - bc1) * 15) div 9);
-
-  if rc3 &lt; 0 then rc3 := 0 else if rc3 &gt; 255 then rc3 := 255;
-  if gc3 &lt; 0 then gc3 := 0 else if gc3 &gt; 255 then gc3 := 255;
-  if bc3 &lt; 0 then bc3 := 0 else if bc3 &gt; 255 then bc3 := 255;
-
-  if Direction = tGTopBottom then
-  begin
-    GradientBmp.Width := 1;
-    GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-    GSize := GradientBmp.Height;
-
-    y1 := GSize div 2;
-    for i := 0 to y1 - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[0] := GradCol;
-    end;
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-    for i := y1 to GSize - 1 do
-    begin
-      Row := PRGBTripleArray(GradientBmp.ScanLine[i]);
-      GradCol.rgbtRed := Byte(rc3 + (((rc2 - rc3) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc3 + (((gc2 - gc3) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc3 + (((bc2 - bc3) * (i)) div GSize));
-      Row[0] := GradCol;
-    end;
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end else
-  begin
-    GradientBmp.Width := (ARect.Right - ARect.Left) - 1;
-    GradientBmp.Height := 1;
-    GSize := GradientBmp.Width;
-
-    y1 := GSize div 2;
-    Row := PRGBTripleArray(GradientBmp.ScanLine[0]);
-    for i := 0 to y1 - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc1 + (((rc2 - rc1) * (i)) div y1));
-      GradCol.rgbtGreen := Byte(gc1 + (((gc2 - gc1) * (i)) div y1));
-      GradCol.rgbtBlue := Byte(bc1 + (((bc2 - bc1) * (i)) div y1));
-      Row[i] := GradCol;
-    end;
-
-    if rc2 &gt; rc1 then
-    begin
-      rc3 := rc2;
-      gc3 := gc2;
-      bc3 := bc2;
-    end;
-
-    for i := y1 to GSize - 1 do
-    begin
-      GradCol.rgbtRed := Byte(rc2 + (((rc3 - rc2) * (i)) div GSize));
-      GradCol.rgbtGreen := Byte(gc2 + (((gc3 - gc2) * (i)) div GSize));
-      GradCol.rgbtBlue := Byte(bc2 + (((bc3 - bc2) * (i)) div GSize));
-      Row[i] := GradCol;
-    end;
-
-    Canvas.StretchDraw(ARect, GradientBmp);
-  end;
-end;
-
-procedure GradientFill(const Canvas: TCanvas; const ARect: TRect;
-  const StartColor, EndColor: TColor;
-  const Direction: TGradDir);
-var
-  rc1, rc2, gc1, gc2, bc1, bc2, Counter, GSize: Integer;
-  Brush: HBrush;
-begin
-  rc1 := GetRValue(ColorToRGB(StartColor));
-  gc1 := GetGValue(ColorToRGB(StartColor));
-  bc1 := GetBValue(ColorToRGB(StartColor));
-  rc2 := GetRValue(ColorToRGB(EndColor));
-  gc2 := GetGValue(ColorToRGB(EndColor));
-  bc2 := GetBValue(ColorToRGB(EndColor));
-
-  if Direction = tGTopBottom then begin
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom - Counter), Brush);
-      DeleteObject(Brush);
-    end;
-  end else begin
-    GSize := (ARect.Right - ARect.Left) - 1;
-    for Counter := 0 to GSize do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * (Counter)) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * (Counter)) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * (Counter)) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left, ARect.Top, ARect.Right - Counter, ARect.Bottom), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div 2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXXitoTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXXitoTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipText);
-end;
-
-function TTBXXitoTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXXitoTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if (ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then Border.X := 1
-    else Border.X := 2;
-    Border.Y := 2;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else SetBorder(2, 2);
-  end
-  else SetBorder(0, 0);
-end;
-
-procedure TTBXXitoTheme.GetMargins(MarginID: Integer; out Margins: TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3;
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXXitoTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect: TRect;
-  AColor: TColor; Transparent: Boolean; AViewType: Integer);
-var
-  Brush: HBrush;
-  R: TRect;
-  IsHoriz: boolean;
-begin
-  if not Transparent then
-  begin
-    if ((AViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      and (not (AViewType and TVT_EMBEDDED = TVT_EMBEDDED))
-      or ((AViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW)
-      or ((AViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-    begin
-      IntersectRect(R, ARect, AClipRect);
-      if (ADockRect.Top = 0) and
-        (ADockRect.Left = 0) and
-        (ADockRect.Right = 0) and
-        (ADockRect.Bottom = 0) then
-        IsHoriz := (ARect.Right &gt; ARect.Bottom)
-      else
-        IsHoriz := Abs(R.Right - R.Left) &gt; Abs(R.Bottom - R.Top);
-
-      if IsHoriz then
-        FillGradient(Canvas, R, $00f0f0f0, clWhite, TGTopBottom)
-      else
-        FillGradient(Canvas, R, $00f0f0f0, clWhite, TGLeftRight);
-    end else
-    begin
-      Brush := CreateSolidBrush(ColorToRGB(AColor));
-      IntersectRect(R, ARect, AClipRect);
-      FillRect(Canvas.Handle, R, Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    Brush.Style := bsClear;
-    if Font.Color = clNone then Font.Color := GetPartColor(ItemInfo, ipText);
-    if not Rotated then Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  Canvas.Pen.Color := GetBtnColor(ItemInfo, ipText);
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y - 2)]);
-end;
-
-procedure TTBXXitoTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  begin
-    if Pressed then
-    else
-      if BtnHot then
-      else
-        if Embedded then
-        begin
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          FrameRectEx(Canvas.Handle, R, $00d0d0d0, True);
-        end
-        else FrameRectEx(Canvas.Handle, R, $00d0d0d0, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot then
-        begin
-          if BtnPressed then
-          begin
-            FillRectEx(Canvas.Handle, R, $00c0c0c0);
-            Pen.Color := $00909090;
-            DrawLineEx(Canvas.Handle, R.Left - 1, R.Top, R.Left - 1, R.Bottom, $00909090);
-          end else
-          begin
-            FillRectEx(Canvas.Handle, R, $00e0e0e0);
-            Pen.Color := $00909090;
-            DrawLineEx(Canvas.Handle, R.Left - 1, R.Top, R.Left - 1, R.Bottom, $00909090);
-          end;
-        end else
-        begin
-          DrawLineEx(Canvas.Handle, R.Left - 1, R.Top + 1, R.Left - 1, R.Bottom - 1, $00d0d0d0);
-          DrawLineEx(Canvas.Handle, R.Left - 1, R.Top + 1, R.Left - 1, R.Bottom - 1, clWhite)
-        end;
-        PaintEnabled(R, BtnPressed);
-      end;
-      if BtnDisabled then FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame], True);
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      { Upper button }
-
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          if BtnPressed then
-            GradientFill(Canvas, BR, clWhite, clSilver, TGTopBottom)
-          else
-            if BtnHot then
-            begin
-              FillRectEx(Canvas.Handle, BR, $00d0d0d0);
-              Pen.Color := $00808080;
-            end;
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-          begin
-            Pen.Color := clWhite;
-          end
-          else Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-            GradientFill(Canvas, BR, clWhite, clSilver, TGTopBottom)
-          else
-            if BtnHot then
-              begin
-                FillRectEx(Canvas.Handle, BR, $00d0d0d0);
-                Pen.Color := $00808080;
-              end;
-        end
-        else if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-        begin
-          if not Embedded then
-          begin
-            Pen.Color := clWindow;
-          end else
-            Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        end;
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      Pen.Color := GetPartColor(ItemInfo, ipText);
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do if RightBtnWidth &gt; 0 then Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := $00d0d0d0 // Should be central...
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWhite;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWhite;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  with ARect, Canvas do
-  begin
-    X := (Left + Right) div 2;
-    Y := (Top + Bottom) div 2 - 1;
-    Pen.Color := GetPartColor(ItemInfo, ipText);
-    Brush.Color := Pen.Color;
-    if ItemInfo.IsVertical then Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-    else Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then Dec(RR,2); // 1
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1; RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := Blend(clHighLight, clWindow, 20);
-      end
-      else
-        Pen.Color := Blend(clHighLight, clWindow, 15);
-      RoundFrame(Canvas, R, RL, RR);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        if Pushed then
-        begin
-
-          Pen.Color := $00d0d0d0;
-          RoundFrame(Canvas, R, 1, 1);
-
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, $00d0d0d0);
-          Pen.Color := $00808080;
-          InflateRect(R, 1, 1);
-          RoundFrame(Canvas, R, 1, 1);
-        end else
-        begin
-          Pen.Color := BtnItemColors[bisHot, ipFrame];
-          RoundFrame(Canvas, R, 1, 1);
-        end;
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-
-      if not Pushed and (HoverKind = hkNone) then
-      begin
-        FillRectEx(Canvas.Handle, R, $00d8d8d8);
-        Pen.Color := $00b8b8b8;
-        MoveTo(R.Left, R.Bottom-2); LineTo(R.Left, R.Top); LineTo(R.Right, R.Top);
-        Pen.Color := $00f8f8f8;
-        InflateRect(R, 1, 1);
-        RoundFrame(Canvas, R, RL, RR);
-      end else
-      begin
-        InflateRect(R, 1, 1);
-        Pen.Color := $00d0d0d0;
-        RoundFrame(Canvas, R, 1, 1);
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, $00c0c0c0);
-        Pen.Color := $00909090;
-        InflateRect(R, 1, 1);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if Selected and (not Pushed) and (HoverKind &lt;&gt; hkNone) then
-      begin
-        Pen.Color := $00d0d0d0;
-        RoundFrame(Canvas, R, 1, 1);
-
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, $00d0d0d0);
-        Pen.Color := $00808080;
-        InflateRect(R, 1, 1);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-    end
-    else
-      if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Pen.Color := $00e0e0e0;
-        RoundFrame(Canvas, R, 1, 1);
-
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, $00e0e0e0);
-        InflateRect(R, 1, 1);
-        Pen.Color := GetBtnColor(ItemInfo, ipFrame);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-    if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  WinStates: array[Boolean] of TWinFramestate = (wfsInactive, wfsActive);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if not WindowInfo.Active then Result := bisDisabled
-    else if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  WinState: TWinFrameState;
-  BtnItemState: TBtnItemState;
-  SaveIndex, X, Y: Integer;
-  Sz: TPoint;
-  R: TRect;
-  BodyColor, CaptionColor, CaptionText: TColor;
-  IsDockPanel: Boolean;
-
-  procedure DrawGlyph(C: TColor);
-  var
-    Bmp: TBitmap;
-    DC: HDC;
-  begin
-    Bmp := TBitmap.Create;
-    try
-      Bmp.Monochrome := True;
-      StockImgList.GetBitmap(0, Bmp);
-      Canvas.Brush.Color := C;
-      DC := Canvas.Handle;
-      SetTextColor(DC, clBlack);
-      SetBkColor(DC, clWhite);
-      BitBlt(DC, X, Y, StockImgList.Width, StockImgList.Height,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    finally
-      Bmp.Free;
-    end;
-  end;
-
-begin
-  with Canvas do
-  begin
-    WinState := WinStates[WindowInfo.Active];
-    IsDockPanel := (WindowInfo.ViewType and VT_DOCKPANEL) = VT_DOCKPANEL;
-    BodyColor := Brush.Color;
-
-    if (WRP_BORDER and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := ARect;
-
-      if not IsDockPanel then
-        Brush.Color := WinFrameColors[WinState, wfpBorder]
-      else
-        Brush.Color := PnlFrameColors[WinState, wfpBorder];
-      SaveIndex := SaveDC(Canvas.Handle);
-      Sz := WindowInfo.FloatingBorderSize;
-      with R, Sz do ExcludeClipRect(Canvas.Handle, Left + X, Top + Y, Right - X, Bottom - Y);
-      FillRect(R);
-      RestoreDC(Canvas.Handle, SaveIndex);
-      InflateRect(R, -Sz.X, -Sz.Y);
-      Pen.Color := BodyColor;
-      with R do
-        if not IsDockPanel then
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom - 1),
-              Point(Right - 1, Bottom),
-              Point(Left, Bottom), Point(Left - 1, Bottom - 1),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ])
-        else
-          Canvas.Polyline([
-            Point(Left, Top - 1), Point(Right - 1, Top - 1),
-              Point(Right, Top), Point(Right, Bottom),
-              Point(Left - 1, Bottom),
-              Point(Left - 1, Top), Point(Left, Top - 1)
-              ]);
-    end;
-
-    if not WindowInfo.ShowCaption then Exit;
-
-    if (WindowInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-    begin
-      CaptionColor := WinFrameColors[WinState, wfpCaption];
-      CaptionText := WinFrameColors[WinState, wfpCaptionText];
-    end
-    else
-    begin
-      CaptionColor := PnlFrameColors[WinState, wfpCaption];
-      CaptionText := PnlFrameColors[WinState, wfpCaptionText];
-    end;
-
-    { Caption }
-    if (WRP_CAPTION and WindowInfo.RedrawPart) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, BodyColor);
-
-      if ((CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0) and
-        ((WRP_CLOSEBTN and WindowInfo.RedrawPart) &lt;&gt; 0) then
-        Dec(R.Right, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-
-      Brush.Color := CaptionColor;
-      FillGradient(Canvas, R, $00f0f0f0, gradCol2, TGTopBottom);
-
-      InflateRect(R, -2, 0);
-      Font.Assign(SmCaptionFont);
-      Font.Color := CaptionText;
-      Brush.Style := bsClear;
-      DrawText(Canvas.Handle, WindowInfo.Caption, -1, R,
-        DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX);
-    end;
-
-    { Close button }
-    if (CDBS_VISIBLE and WindowInfo.CloseButtonState) &lt;&gt; 0 then
-    begin
-      R := Rect(0, 0, WindowInfo.ClientWidth, GetSystemMetrics(SM_CYSMCAPTION) - 1);
-      with WindowInfo.FloatingBorderSize do OffsetRect(R, X, Y);
-      R.Left := R.Right - (R.Bottom - R.Top);
-      DrawLineEx(Canvas.Handle, R.Left - 1, R.Bottom, R.Right, R.Bottom, BodyColor);
-      Brush.Color := CaptionColor;
-
-      FillGradient(Canvas, R, $00f0f0f0, gradCol2, TGTopBottom);
-
-      BtnItemState := GetBtnItemState(WindowInfo.CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R, clGray, True);
-        FillRectEx(Canvas.Handle, R, clWhite);
-        DrawButtonBitmap(Canvas, R, clBlack);
-      end else
-      if BtnItemState = bisPressed then
-      begin
-        FrameRectEx(Canvas.Handle, R, clGray, True);
-        FillRectEx(Canvas.Handle, R, clSilver);
-        DrawButtonBitmap(Canvas, R, clWhite);
-      end else
-      begin
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipFrame], True);
-        FillRectEx(Canvas.Handle, R, BtnItemColors[BtnItemState, ipBody]);
-        DrawButtonBitmap(Canvas, R, clBlack);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if E and (HoverKind &lt;&gt; hkNone) or
-      ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      FillRectEx(Canvas.Handle, R, $00d0d0d0);
-      if Pushed then
-        Canvas.Pen.Color := $00909090
-      else
-        Canvas.Pen.Color := GetPartColor(ItemInfo, ipFrame);
-      InflateRect(R, 1, 1);
-      RoundFrame(Canvas, R, 1, 1);
-    end;
-  end;
-end;
-
-function TTBXXitoTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXXitoTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-{$IFNDEF ALTERNATIVE_DISABLED_STYLE}
-    HiContrast := IsDarkColor(GetItemImageBackground(ItemInfo), 64);
-
-    if not Enabled then
-    begin
-      DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-        BtnItemColors[bisDisabled, ipText]);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconFullShadow(Canvas, ARect, ImageList, ImageIndex, IconShadowColor);
-        OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 178);
-{$ELSE}
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex, clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if not (Selected or Pushed and not IsPopupParent) then
-      begin // rmk Removed the shados under the glyphs
-        // aaa
-        //DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        //OffsetRect(ARect, 1, 1);
-        //DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        //OffsetRect(ARect, -2, -2);
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else // rmk 17.08.2003 Removed washed out glyphs
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, {178} 255);
-{$ENDIF}
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXXitoTheme.PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-begin
-  R := ARect;
-  if (ItemInfo.ViewType and PVT_TOOLBOX) &lt;&gt; PVT_TOOLBOX then with Canvas do
-  begin
-    R.Right := R.Left + ItemInfo.PopupMargin + 2;
-    Brush.Color := clWhite;
-    FillRect(R);
-    Inc(R.Left);
-    R.Right := ARect.Right - 1;
-  end;
-  PaintFrame(Canvas, R, ItemInfo);
-end;
-
-procedure TTBXXitoTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo: TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 1; RL := 1;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          FillRectEx(Canvas.Handle, R, $00d8d8d8);
-          Pen.Color := $00b8b8b8;
-          MoveTo(R.Left, R.Bottom-2); LineTo(R.Left, R.Top); LineTo(R.Right, R.Top);
-          Pen.Color := $00c4c4c4;
-          MoveTo(R.Left, R.Bottom-1); LineTo(R.Right-1, R.Bottom-1); LineTo(R.Right-1, R.Top);
-
-          Pen.Color := clWhite;
-          InflateRect(R, 1, 1);
-          RoundFrame(Canvas, R, 2, 2);
-        end else
-        begin
-          FillRectEx(Canvas.Handle, R, $00d0d0d0);
-          Pen.Color := $00909090;
-          InflateRect(R, 1, 1);
-          RoundFrame(Canvas, R, 2, 2);
-        end;
-        InflateRect(R, 1, 1);
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    PaintMenuItemFrame(Canvas, ARect, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-    R := ARect;
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then Pen.Color := clWhite
-      else Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2:= Arect;
-    InflateRect(R2, -1, -1);
-
-    if Selected and Enabled then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      InflateRect(R, -1, -1);
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-    Pen.Color:= PopupFrameColor;
-    Pixels[1,1]:= PopupFrameColor;
-    Pixels[R.Right - 1, 1]:= PopupFrameColor;
-    Pixels[1, R.Bottom - 1]:= PopupFrameColor;
-    Pixels[R.Right - 1, R.Bottom - 1]:= PopupFrameColor;
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then Left := R.Left - 1;
-            if Right &gt;= R.Right then Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then Left := R.Left - 1;
-            if Right &gt;= R.Right then Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-var
-  IsToolbox: Boolean;
-  R: TRect;
-  i: integer;
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal then
-    begin
-      IsToolbox := (ViewType and PVT_TOOLBOX) = PVT_TOOLBOX;
-      if ((ItemOptions and IO_TOOLBARSTYLE) = 0) and not IsToolBox then
-      begin
-        R := ARect;
-        R.Right := ItemInfo.PopupMargin + 2;
-        Brush.Color := ToolbarColor;
-        Inc(Left, ItemInfo.PopupMargin + 9);
-        Pen.Color := PopupSeparatorColor;
-      end
-      else
-        Pen.Color := ToolbarSeparatorColor;
-
-      if (ItemInfo.ViewType and VT_TOOLBAR) = VT_TOOLBAR then
-      begin
-        Top := Bottom div 2 +1;
-        Left := Left + 4;
-        Right := Right - 2;
-        Bottom := Top + 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, clWhite);
-        Top := Top - 1;
-        Left := Left - 1;
-        Right := Right - 1;
-        DrawLineEx(Canvas.Handle, Left, Top, Right, Top, gradCol1);
-      end else
-      begin
-        Top := Bottom div 2;
-        i:= 14;
-        while i &lt; Right - 14 do
-        begin
-          Canvas.Pixels[i, Top] := $00909090;
-          i := i + 3;
-        end;
-      end;
-    end else if enabled then
-    begin
-      Top := Top + 4;
-      Bottom := Bottom - 2;
-      Left := Right div 2;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, clWhite);
-      Top := Top - 1;
-      Left := Left - 1;
-      Bottom := Bottom - 1;
-      DrawLineEx(Canvas.Handle, Left, Top, Left, Bottom, gradCol1);
-    end;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0, 1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  Sz: Integer;
-  R2: TRect;
-  I: Integer;
-  BtnVisible, Horz: Boolean;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas do
-  begin
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW)
-      or ((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR)
-      then
-    begin
-
-      with R do begin
-        if (R.Right &gt; R.Bottom) then
-        begin
-          R2 := r;
-          R2.Top := R2.Top + 2;
-          R2.Bottom := R.Bottom - 2;
-          FillGradient(Canvas, R, $00f0f0f0, clWhite, TGTopBottom);
-          FillGradient(Canvas, R2, $00f0f0f0, clWhite, TGTopBottom);
-        end else
-          FillGradient(Canvas, R, $00f0f0f0, clWhite, TGLeftRight);
-        R2 := R;
-        R2.Left := R2.Right - 1;
-
-        R2.Top := R2.Top + 1;
-
-        Pen.Color := gradBL;
-        MoveTo(Left + 2, Bottom - 1);
-        LineTo(Right - 3, Bottom - 1);
-        LineTo(Right - 1, Bottom - 3);
-        LineTo(Right - 1, Top);
-
-        Pen.Color := clWhite;
-        MoveTo(Left + 1, Bottom - 2);
-        LineTo(Left, Bottom - 3);
-        LineTo(Left, Top + 2);
-        LineTo(Left + 2, Top);
-        LineTo(Right - 3, Top);
-        LineTo(Right - 1, Top + 2);
-
-        Pen.Color := $00e0e0e0;
-        MoveTo(Left, Top);
-        LineTo(Left, Top + 1);
-        LineTo(Left + 2, Top - 1);
-
-        MoveTo(Right - 1, Top);
-        LineTo(Right - 2, Top);
-        LineTo(Right, Top + 2);
-
-        MoveTo(Left, Bottom - 1);
-        LineTo(Left, Bottom - 2);
-        LineTo(Left + 2, Bottom);
-
-        MoveTo(Right - 1, Bottom - 2);
-        LineTo(Right - 2, Bottom - 1);
-        LineTo(Right, Bottom - 1);
-      end;
-      InflateRect(R, -2, -2);
-    end else
-      InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then R.Right := R.Left + Sz
-    else R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Inc(R2.Left, DragHandleOffsets[BtnVisible, ToolbarInfo.DragHandleStyle]);
-        if BtnVisible then Inc(R2.Top, Sz - 2);
-        R2.Right := R2.Left + 3;
-      end
-      else
-      begin
-        Inc(R2.Top, DragHandleOffsets[BtnVisible, ToolbarInfo.DragHandleStyle]);
-        if BtnVisible then Dec(R2.Right, Sz - 2);
-        R2.Bottom := R2.Top + 3;
-      end;
-
-      Pen.Color := DragHandleColor;
-      if Horz then
-      begin
-        I := R2.Top + 3;
-        while I &lt; R2.Bottom - 3 do
-        begin
-          Pen.Color := $00A0A0A0;
-          MoveTo(R2.Left, I); LineTo(R2.Right, I);
-          Pen.Color := clWhite;
-          MoveTo(R2.Left, I + 1); LineTo(R2.Right, I + 1);
-          Inc(I, 2);
-        end;
-      end
-      else
-      begin
-        I := R2.Left + 3;
-        while I &lt; R2.Right - 3 do
-        begin
-          Pen.Color := $00a0a0a0;
-          MoveTo(I, R2.Top); LineTo(I, R2.Bottom);
-          Pen.Color := clWhite;
-          MoveTo(I + 1, R2.Top); LineTo(I + 1, R2.Bottom);
-          Inc(I, 2);
-        end;
-      end;
-    end;
-
-    { Close button }
-    if BtnVisible then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        Dec(R2.Right);
-        R2.Bottom := R2.Top + R2.Right - R2.Left;
-      end
-      else
-      begin
-        Dec(R2.Bottom);
-        R2.Left := R2.Right - R2.Bottom + R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(ToolbarInfo.CloseButtonState);
-      FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-      FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-      DrawButtonBitmap(Canvas, R2, BtnItemColors[BtnItemState, ipText]);
-    end;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var R: TRect;
-begin
-  Canvas.Pen.Width:= 0;
-  Canvas.Brush.Style:= bsSolid;
-  Canvas.Brush.Color:= $00e0e0e0;
-  R:= DockRect;
-  InFlateRect(R, 1,1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXXitoTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const DockPanelInfo: TTBXDockPanelInfo);
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then Result := bisHot
-    else Result := bisNormal;
-  end;
-
-var
-  C, HeaderColor: TColor;
-  I, Sz, Flags: Integer;
-  R2: TRect;
-  BtnItemState: TBtnItemState;
-begin
-  with Canvas, DockPanelInfo do
-  begin
-    C := Brush.Color; // Dock panel passes its body color in Canvas.Brush
-    I := ColorIntensity(ColorToRGB(clBtnFace));
-    R2 := R;
-    if not TBXLoColor and (I in [64..250]) then
-    begin
-      FrameRectEx(Canvas.Handle, R, clBtnFace, True);
-      FrameRectEx(Canvas.Handle, R, C, True);
-      with R do
-      begin
-        Pixels[Left, Top] := clBtnFace;
-        if IsVertical then Pixels[Right - 1, Top] := clBtnFace
-        else Pixels[Left, Bottom - 1] := clBtnFace;
-      end;
-    end
-    else
-    begin
-      FrameRectEx(Canvas.Handle, R, C, True);
-      if I &lt; 64 then Brush.Bitmap := AllocPatternBitmap(C, clWhite)
-      else Brush.Bitmap := AllocPatternBitmap(C, clBtnShadow);
-      FrameRect(R);
-      with R do
-      begin
-        Pixels[Left, Top] := C;
-        if IsVertical then Pixels[Right - 1, Top] := C
-        else Pixels[Left, Bottom - 1] := C;
-      end;
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end;
-    R := R2;
-    InflateRect(R, -BorderSize.X, -BorderSize.Y);
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-    if IsVertical then
-    begin
-      R.Bottom := R.Top + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Bottom := R.Bottom + 1;
-      FillGradient(Canvas, R, $00f0f0f0, gradCol2, TGTopBottom);
-      DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1, clSilver);
-      R.Bottom := R.Bottom - 1;
-    end
-    else
-    begin
-      R.Right := R.Left + Sz - 1;
-      DrawLineEx(Canvas.Handle, R.Right, R.Top, R.Right, R.Bottom, C);
-      HeaderColor := clBtnFace;
-      R.Right := R.Right + 1;
-      FillGradient(Canvas, R, $00f0f0f0, gradCol2, TGLeftRight);
-      DrawLineEx(Canvas.Handle, R.Right - 1, R.Top, R.Right - 1, R.Bottom, clSilver);
-      R.Right := R.Right - 1;
-    end;
-
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz + 1;
-        R.Right := R2.Left;
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz + 1;
-        R.Bottom := R2.Top;
-      end;
-
-      BtnItemState := GetBtnItemState(CloseButtonState);
-
-      if BtnItemState = bisHot then
-      begin
-        FrameRectEx(Canvas.Handle, R2, clGray, True);
-        FillRectEx(Canvas.Handle, R2, clWhite);
-        DrawButtonBitmap(Canvas, R2, clBlack);
-      end else
-        if BtnItemState = bisPressed then
-        begin
-          FrameRectEx(Canvas.Handle, R2, clGray, True);
-          FillRectEx(Canvas.Handle, R2, clSilver);
-          DrawButtonBitmap(Canvas, R2, clWhite);
-        end else
-        begin
-          FrameRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipFrame], True);
-          FillRectEx(Canvas.Handle, R2, BtnItemColors[BtnItemState, ipBody]);
-          DrawButtonBitmap(Canvas, R2, clBlack);
-        end;
-    end;
-
-    if IsVertical then InflateRect(R, -4, 0)
-    else InflateRect(R, 0, -4);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBlack;
-    Brush.Color := HeaderColor;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_HIDEPREFIX;
-
-    if IsVertical then DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-  end;
-end;
-
-procedure TTBXXitoTheme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-
-  gradCol1 := NearestMixedColor(clBtnShadow, clBtnFace, 48);
-  gradCol2 := clWhite;
-  gradHandle1 := clBtnFace;
-  gradHandle2 := clGray;
-  gradHandle3 := clWhite;
-  gradBL := $00b0b0b0;
-  gradTL := Blend(gradCol1, gradCol2, 50);
-
-  { View/Window Colors }
-  MenubarColor := clWhite;
-  ToolbarColor := gradCol2;
-  PopupColor := clWhite;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := $00C0C0C0;
-
-  HotBtnFace := Blend(clHighlight, clWindow, 20);
-  SetContrast(HotBtnFace, ToolbarColor, 50);
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-
-  WinFrameColors[wfsActive, wfpBorder] := $00909090;
-  WinFrameColors[wfsActive, wfpCaption] := clWhite;
-  WinFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  SetContrast(WinFrameColors[wfsActive, wfpCaptionText], clBtnShadow, 180);
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(WinFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  PnlFrameColors[wfsActive, wfpBorder] := $00909090;
-  PnlFrameColors[wfsActive, wfpCaption] := clWhite;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clBlack;
-  PnlFrameColors[wfsInactive, wfpBorder] := clBtnShadow;
-  PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := DisabledText;
-  SetContrast(PnlFrameColors[wfsInactive, wfpCaptionText], clBtnFace, 120);
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := DisabledText;
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := $00D0D0D0;
-
-  BtnItemColors[bisSelected, ipBody] := Blend(clHighlight, Blend(clBtnFace, clWindow, 50), 10);
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := clSilver;
-
-  BtnItemColors[bisPressed, ipBody] := Blend(clHighlight, clWindow, 30);
-  BtnItemColors[bisPressed, ipText] := clBlack;
-  BtnItemColors[bisPressed, ipFrame] := clRed;
-
-  BtnItemColors[bisHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisHot, ipText] := clMenuText;
-  SetContrast(BtnItemColors[bisHot, ipText], BtnItemColors[bisHot, ipBody], 180);
-  BtnItemColors[bisHot, ipFrame] := $00a0a0a0;
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clHighlight;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(clHighlight, clWindow, 50);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clBlack;
-  SetContrast(BtnItemColors[bisSelectedHot, ipText], BtnItemColors[bisSelectedHot, ipBody], 180);
-  BtnItemColors[bisSelectedHot, ipFrame] := clHighlight;
-  SetContrast(BtnItemColors[bisSelectedHot, ipFrame], BtnItemColors[bisSelectedHot, ipBody], 100);
-
-  BtnItemColors[bisPopupParent, ipBody] := ToolbarColor;
-  BtnItemColors[bisPopupParent, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisPopupParent, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clWindowText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := BtnItemColors[bisHot, ipBody];
-  MenuItemColors[misHot, ipText] := BtnItemColors[bisHot, ipText];
-  MenuItemColors[misHot, ipFrame] := clSilver;
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 70);
-  MenuItemColors[misDisabledHot, ipFrame] := clHighlight;
-
-  DragHandleColor := Blend(clBtnShadow, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-  ToolbarSeparatorColor := Blend(clBtnShadow, clWindow, 70);
-  SetContrast(ToolbarSeparatorColor, ToolbarColor, 50);
-  PopupSeparatorColor := $00909090;
-  StatusPanelFrameColor := Blend(clWindow, clBtnFace, 30);
-  SetContrast(StatusPanelFrameColor, clBtnFace, 30);
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXXitoTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXXitoTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXXitoTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXXitoTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXXitoTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  X, Y, Sz: Integer;
-begin
-  R := ARect;
-  InflateRect(R, -1, -1);
-  if Hot then
-  begin
-    FillGradient(Canvas, R, $00f0f0f0, clWhite, TGTopBottom);
-    Canvas.Pen.Color := BtnItemColors[bisHot, ipFrame];
-  end
-  else
-  begin
-    Canvas.Brush.Color := clWhite;
-    Canvas.FillRect(R);
-    Canvas.Pen.Color := $00D0D0D0;
-  end;
-  InflateRect(R, 1, 1);
-
-  RoundFrame(Canvas, R, 1, 1);
-  Canvas.Pen.Color := clBtnFace;
-  with R do
-  begin
-    Canvas.Pixels[Left, Top] := clBtnFace;
-    Canvas.Pixels[Right + 1, Top] := clBtnFace;
-    Canvas.Pixels[Right + 1, Bottom + 1] := clBtnFace;
-    Canvas.Pixels[Left, Bottom + 1] := clBtnFace;
-  end;
-
-  { Arrow }
-  X := (R.Left + R.Right) div 2;
-  Y := (R.Top + R.Bottom) div 2;
-  Sz := Min(X - R.Left, Y - R.Top) * 3 div 4;
-  Canvas.Pen.Color := clBtnText;
-  Canvas.Brush.Color := Canvas.Pen.Color;
-  case ButtonType of
-    PSBT_UP:
-      begin
-        Inc(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y - Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_DOWN:
-      begin
-        Y := (R.Top + R.Bottom - 1) div 2;
-        Dec(Y, Sz div 2);
-        Canvas.Polygon([Point(X + Sz, Y), Point(X, Y + Sz), Point(X - Sz, Y)]);
-      end;
-    PSBT_LEFT:
-      begin
-        Inc(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X - Sz, Y), Point(X, Y - Sz)]);
-      end;
-    PSBT_RIGHT:
-      begin
-        X := (R.Left + R.Right - 1) div 2;
-        Dec(X, Sz div 2);
-        Canvas.Polygon([Point(X, Y + Sz), Point(X + Sz, Y), Point(X, Y - Sz)]);
-      end;
-  end;
-end;
-
-procedure TTBXXitoTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer; Params: Pointer);
-type
-  PRGBTripleArray = ^TRGBTripleArray;
-  TRGBTripleArray = array[0..1024] of TRGBTriple;
-  TGradientColors = array[0..255] of TRGBTriple;
-const
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-
-  rc1, gc1, bc1, rc2, gc2, bc2, rc3, gc3, bc3,
-  y1, i, GSize: Integer;
-  Row: PRGBTripleArray;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const Canvas: TCanvas; const ARect: TRect;
-    const StartColor, EndColor: TColor;
-    const NewG: boolean);
-  var
-    i: integer;
-  begin
-    rc1 := GetRValue(ColorToRGB(StartColor));
-    gc1 := GetGValue(ColorToRGB(StartColor));
-    bc1 := GetBValue(ColorToRGB(StartColor));
-    rc2 := GetRValue(ColorToRGB(EndColor));
-    gc2 := GetGValue(ColorToRGB(EndColor));
-    bc2 := GetBValue(ColorToRGB(EndColor));
-
-    rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-    gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-    bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-    if rc3 &lt; 0 then rc3 := 0 else if rc3 &gt; 255 then rc3 := 255;
-    if gc3 &lt; 0 then gc3 := 0 else if gc3 &gt; 255 then gc3 := 255;
-    if bc3 &lt; 0 then bc3 := 0 else if bc3 &gt; 255 then bc3 := 255;
-
-    if NewG then
-    begin
-      GradientBmp.Width := 1;
-      GradientBmp.Height := (ARect.Bottom - ARect.Top) - 1;
-      GSize := GradientBmp.Height;
-
-      y1 := GSize div 2;
-      for i := 0 to y1 - 1 do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc2 + (((rc1 - rc2) * i) div y1)),
-            Byte(gc2 + (((gc1 - gc2) * i) div y1)),
-            Byte(bc2 + (((bc1 - bc2) * i) div y1))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i],  ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-      if rc1 &gt; rc2 then
-      begin
-        rc3 := rc1;
-        gc3 := gc1;
-        bc3 := bc1;
-      end;
-      for i := y1 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc3 + (((rc1 - rc3) * i) div GSize)),
-            Byte(gc3 + (((gc1 - gc3) * i) div GSize)),
-            Byte(bc3 + (((bc1 - bc3) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Top + i, ARect.Right - Offs[i], ARect.Top + i + 1), Brush);
-        DeleteObject(Brush);
-      end;
-    end else
-    begin
-      GSize := (ARect.Bottom - ARect.Top) - 1;
-      for i := 0 to GSize do
-      begin
-        Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * i) div GSize)),
-            Byte(gc1 + (((gc2 - gc1) * i) div GSize)),
-            Byte(bc1 + (((bc2 - bc1) * i) div GSize))));
-        Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-        DeleteObject(Brush);
-      end;
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then Result := BtnItemColors[bisHot, ipText]
-    else Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with Canvas, R do
-    begin
-      Pen.Color := C;
-      MoveTo(Right - 1 - X, Bottom - 1); LineTo(Right, Bottom - X - 2);
-      Inc(X);
-    end;
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                FillGradient(Canvas, R, clWhite, clSilver, TGTopBottom)
-              else
-                FillGradient(Canvas, R, clWhite, clSilver, TGTopBottom);
-              Pen.Color := clSilver;
-            end else
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              FillGradient(Canvas, R, clSilver, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end else
-            begin
-              FillGradient(Canvas, R, $00f0f0f0, clWhite, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 1, 1);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              FillGradient(Canvas, R, $00d0d0d0, clWhite, TGTopBottom);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end else
-              Pen.Color := clSilver;
-            RoundFrame(Canvas, R, 1, 1);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X - 2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-                RadioGradient(Canvas, R, clWhite, clSilver, false)
-              else
-                RadioGradient(Canvas, R, clWhite, clSilver, true);
-              Pen.Color := clSilver;
-            end else
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              RadioGradient(Canvas, R, clSilver, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end else
-            begin
-              RadioGradient(Canvas, R, $00f0f0f0, clWhite, true);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            Brush.Style:= bsClear;
-            X:= R.Left;
-            Y:= R.Top;
-            Polygon([Point(X, Y + 8),      Point(X, Y + 4),      Point(X + 1, Y + 3),
-                     Point(X + 1, Y + 2),  Point(X + 2, Y + 1),  Point(X + 3, Y + 1),
-                     Point(X + 4, Y),      Point(X + 8, Y),      Point(X + 9, Y + 1),
-                     Point(X + 10, Y + 1),  Point(X + 11, Y + 2),  Point(X + 11, Y + 3),
-                     Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                     Point(X + 11, Y + 10),  Point(X + 10, Y + 11),  Point(X + 9, Y + 11),
-                     Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                     Point(X + 2, Y + 11),  Point(X + 1, Y + 10),  Point(X + 1, Y + 9)]);
-          end else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas, R, $00d0d0d0, clWhite, true);
-              Pen.Color := clSilver;
-              InflateRect(R, 1, 1);
-            end else
-              Pen.Color := clSilver;
-
-            Brush.Style:= bsClear;
-            X:= R.Left;
-            Y:= R.Top;
-            Polygon([Point(X, Y + 8),      Point(X, Y + 4),      Point(X + 1, Y + 3),
-                     Point(X + 1, Y + 2),  Point(X + 2, Y + 1),  Point(X + 3, Y + 1),
-                     Point(X + 4, Y),      Point(X + 8, Y),      Point(X + 9, Y + 1),
-                     Point(X + 10, Y + 1),  Point(X + 11, Y + 2),  Point(X + 11, Y + 3),
-                     Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y + 9),
-                     Point(X + 11, Y + 10),  Point(X + 10, Y + 11),  Point(X + 9, Y + 11),
-                     Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y + 11),
-                     Point(X + 2, Y + 11),  Point(X + 1, Y + 10),  Point(X + 1, Y + 9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXXitoTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-var
-  Hi, Lo: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D - 2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillGradient(Canvas, R, $00f0f0f0, clWhite, TGTopBottom);
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then Dec(R.Right, 3);
-          DrawLineEx(Canvas.Handle, R.Right, R.Top + 4, R.Right, R.Bottom - 3, clBtnShadow);
-          DrawLineEx(Canvas.Handle, R.Right + 1, R.Top + 5, R.Right + 1, R.Bottom - 2, clBtnHighLight);
-        end;
-      SBP_GRIPPER:
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Lo := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Hi := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXXitoTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then SetupColorCache;
-end;
-
-{$IFNDEF DTM_Package}
-initialization
-  RegisterTBXTheme('Xito', TTBXXitoTheme);
-{$ENDIF}
-end.
-

Deleted: Lobby/TASClient/Themes/TBXZezioTheme.pas
===================================================================
--- Lobby/TASClient/Themes/TBXZezioTheme.pas	2010-03-19 16:14:12 UTC (rev 7437)
+++ Lobby/TASClient/Themes/TBXZezioTheme.pas	2010-03-20 16:42:21 UTC (rev 7438)
@@ -1,2356 +0,0 @@
-unit TBXZezioTheme;
-
-// TBX Package
-// Copyright 2001-2002 Alex A. Denisov. All Rights Reserved
-// See TBX.chm for license and installation instructions
-//
-// 'Zezio' TBX theme &#169; 2004 Roy Magne Klever
-// <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">roymagne at rmklever.com</A>
-//
-// Version for TBX version 2.1
-// Last updated: 02.12.2004
-
-interface
-
-uses
-  Windows, Messages, Graphics, TBXThemes, ImgList;
-
-{$DEFINE ALTERNATIVE_DISABLED_STYLE}
-
-type
-  TItemPart = (ipBody, ipText, ipFrame);
-  TBtnItemState = (bisNormal, bisDisabled, bisSelected, bisPressed, bisHot,
-    bisDisabledHot, bisSelectedHot, bisPopupParent);
-  TMenuItemState = (misNormal, misDisabled, misHot, misDisabledHot);
-  TWinFramePart = (wfpBorder, wfpCaption, wfpCaptionText);
-  TWinFrameState = (wfsActive, wfsInactive);
-
-  TTBXZezioTheme = class(TTBXTheme)
-  private
-    procedure TBXSysCommand(var Message: TMessage); message TBX_SYSCOMMAND;
-  protected
-    { View/Window Colors }
-    MenubarColor: TColor;
-    ToolbarColor: TColor;
-    PopupColor: TColor;
-    DockPanelColor: TColor;
-    BarSepColor: TColor;
-    EditFrameColor: TColor;
-    EditFrameDisColor: TColor;
-
-    PopupFrameColor: TColor;
-    WinFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    PnlFrameColors: array[TWinFrameState, TWinFramePart] of TColor;
-    MenuItemColors: array[TMenuItemState, TItemPart] of TColor;
-    BtnItemColors: array[TBtnItemState, TItemPart] of TColor;
-
-    { Other Colors }
-    DragHandleColor: TColor;
-    PopupSeparatorColor: TColor;
-    ToolbarSeparatorColor: TColor;
-    IconShadowColor: TColor;
-    StatusPanelFrameColor: TColor;
-    DisabledColor: TColor;
-
-    procedure SetupColorCache; virtual;
-  protected
-    { Internal Methods }
-    function GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-    function GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart: TItemPart):
-      TColor;
-  public
-    constructor Create(const AName: string); override;
-    destructor Destroy; override;
-
-    { Metrics access}
-    function GetBooleanMetrics(Index: Integer): Boolean; override;
-    function GetImageOffset(Canvas: TCanvas; const ItemInfo: TTBXItemInfo;
-      ImageList: TCustomImageList): TPoint; override;
-    function GetIntegerMetrics(Index: Integer): Integer; override;
-    function GetItemColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor; override;
-    function GetItemImageBackground(const ItemInfo: TTBXItemInfo): TColor;
-      override;
-    procedure GetMargins(MarginID: Integer; out Margins: TTBXMargins); override;
-    function GetPopupShadowType: Integer; override;
-    procedure GetViewBorder(ViewType: Integer; out Border: TPoint); override;
-    function GetViewColor(AViewType: Integer): TColor; override;
-    procedure GetViewMargins(ViewType: Integer; out Margins: TTBXMargins);
-      override;
-
-    { Painting routines }
-    procedure PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect, AClipRect:
-      TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-      override;
-    procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintCaption(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo; const ACaption: string; AFormat: Cardinal; Rotated:
-      Boolean);
-      override;
-    procedure PaintCheckMark(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintChevron(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintDock(Canvas: TCanvas; const ClientRect, DockRect: TRect;
-      DockPosition: Integer); override;
-    procedure PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-      DockPanelInfo: TTBXDockPanelInfo); override;
-    procedure PaintDropDownArrow(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintEditButton(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo); override;
-    procedure PaintEditFrame(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo; const EditInfo: TTBXEditInfo); override;
-    procedure PaintFloatingBorder(Canvas: TCanvas; const ARect: TRect; const
-      WindowInfo: TTBXWindowInfo); override;
-    procedure PaintFrame(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintImage(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ImageList: TCustomImageList; ImageIndex: Integer); override;
-    procedure PaintMDIButton(Canvas: TCanvas; ARect: TRect; const ItemInfo:
-      TTBXItemInfo; ButtonKind: Cardinal); override;
-    procedure PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var ItemInfo:
-      TTBXItemInfo); override;
-    procedure PaintMenuItemFrame(Canvas: TCanvas; const ARect: TRect; const
-      ItemInfo: TTBXItemInfo); override;
-    procedure PaintPageScrollButton(Canvas: TCanvas; const ARect: TRect;
-      ButtonType: Integer; Hot: Boolean); override;
-    procedure PaintPopupNCArea(Canvas: TCanvas; R: TRect; const PopupInfo:
-      TTBXPopupInfo); override;
-    procedure PaintSeparator(Canvas: TCanvas; ARect: TRect; ItemInfo:
-      TTBXItemInfo; Horizontal, LineSeparator: Boolean); override;
-    procedure PaintToolbarNCArea(Canvas: TCanvas; R: TRect; const ToolbarInfo:
-      TTBXToolbarInfo); override;
-    procedure PaintFrameControl(Canvas: TCanvas; R: TRect; Kind, State: Integer;
-      Params: Pointer); override;
-    procedure PaintStatusBar(Canvas: TCanvas; R: TRect; Part: Integer);
-      override;
-  end;
-
-var
-  MenuButtons, BarLines, AltCaption,
-    Aqua, DarkAqua, CaptionOutline, DottedGrip: boolean;
-  SelGradient: integer;
-  HotColor, BaseColor, BaseShade: TColor;
-
-{$IFDEF DTM_Package}
-function TBXThemeName: shortstring; stdcall;
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-{$ENDIF}
-
-implementation
-
-{.$R tbx_glyphs.res}
-
-uses
-  TBXUtils, TB2Common, TB2Item, Classes, Controls, Commctrl, Forms, rmkThemes,
-  TBXUxThemes, TBX;
-
-{$IFDEF DTM_Package}
-exports
-  TBXThemeName,
-  TBXRegisterTheme;
-
-const
-  cThemeName = 'Zezio';
-
-function TBXThemeName: shortstring; stdcall;
-begin
-  result := cThemeName;
-end;
-
-procedure TBXRegisterTheme(RegisterTheme: boolean); stdcall;
-begin
-  if RegisterTheme then
-    RegisterTBXTheme(cThemeName, TTBXZezioTheme)
-  else
-    UnregisterTBXTheme(cThemeName);
-end;
-{$ENDIF}
-
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  StockImgList: TImageList;
-  CounterLock: Integer;
-
-procedure InitializeStock;
-begin
-  StockImgList := TImageList.Create(nil);
-  StockImgList.Handle := ImageList_LoadBitmap(HInstance, 'TBXGLYPHS', 16, 0,
-    clWhite);
-end;
-
-procedure FinalizeStock;
-begin
-  StockImgList.Free;
-end;
-
-{ TTBXZezioTheme }
-
-procedure RoundFrame(Canvas: TCanvas; R: TRect; RL, RR: Integer);
-begin
-  with Canvas, R do
-  begin
-    Dec(Right);
-    Dec(Bottom);
-    PolyLine([
-      Point(Left + RL, Top),
-        Point(Right - RR, Top),
-        Point(Right, Top + RR),
-        Point(Right, Bottom - RR),
-        Point(Right - RR, Bottom),
-        Point(Left + RL, Bottom),
-        Point(Left, Bottom - RL),
-        Point(Left, Top + RL),
-        Point(Left + RL, Top)
-        ]);
-    Inc(Right);
-    Inc(Bottom);
-  end;
-end;
-
-function TTBXZezioTheme.GetBooleanMetrics(Index: Integer): Boolean;
-begin
-  case Index of
-    TMB_OFFICEXPPOPUPALIGNMENT: Result := False;
-    TMB_EDITHEIGHTEVEN: Result := False;
-    TMB_PAINTDOCKBACKGROUND: Result := True;
-    TMB_SOLIDTOOLBARNCAREA: Result := True;
-    TMB_SOLIDTOOLBARCLIENTAREA: Result := True;
-  else
-    Result := False;
-  end;
-end;
-
-function TTBXZezioTheme.GetIntegerMetrics(Index: Integer): Integer;
-const
-  DEFAULT = -1;
-begin
-  case Index of
-    TMI_SPLITBTN_ARROWWIDTH: Result := 12;
-    TMI_DROPDOWN_ARROWWIDTH: Result := 8;
-    TMI_DROPDOWN_ARROWMARGIN: Result := 3;
-    TMI_MENU_IMGTEXTSPACE: Result := 3;
-    TMI_MENU_LCAPTIONMARGIN: Result := 3;
-    TMI_MENU_RCAPTIONMARGIN: Result := 3;
-    TMI_MENU_SEPARATORSIZE: Result := 3;
-    TMI_MENU_MDI_DW: Result := 2;
-    TMI_MENU_MDI_DH: Result := 2;
-    TMI_TLBR_SEPARATORSIZE: Result := 5;
-    TMI_EDIT_MENURIGHTINDENT: Result := 1;
-    TMI_EDIT_FRAMEWIDTH: Result := 1;
-    TMI_EDIT_TEXTMARGINHORZ: Result := 2;
-    TMI_EDIT_TEXTMARGINVERT: Result := 2;
-    TMI_EDIT_BTNWIDTH: Result := 14;
-  else
-    Result := -1;
-  end;
-end;
-
-function TTBXZezioTheme.GetViewColor(AViewType: Integer): TColor;
-begin
-  Result := clBtnFace;
-  if (AViewType and VT_TOOLBAR) = VT_TOOLBAR then
-  begin
-    if (AViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      Result := MenubarColor
-    else
-      Result := ToolbarColor;
-  end
-  else if (AViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (AViewType and PVT_LISTBOX) = PVT_LISTBOX then
-      Result := clWindow
-    else
-      Result := PopupColor;
-  end
-  else if (AViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-    Result := DockPanelColor;
-end;
-
-function TTBXZezioTheme.GetBtnColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  B: TBtnItemState;
-  Embedded: Boolean;
-begin
-  with ItemInfo do
-  begin
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    if not Enabled then
-      B := BFlags1[HoverKind = hkKeyboardHover]
-    else if ItemInfo.IsPopupParent then
-      B := bisPopupParent
-    else if Pushed then
-      B := bisPressed
-    else if Selected then
-      B := BFlags2[HoverKind &lt;&gt; hkNone]
-    else
-      B := BFlags3[HoverKind &lt;&gt; hkNone];
-    Result := BtnItemColors[B, ItemPart];
-    if Embedded then
-    begin
-      if (ItemPart = ipBody) and (Result = clNone) then
-        Result := ToolbarColor;
-      if ItemPart = ipFrame then
-      begin
-        if Selected then
-          Result := clWindowFrame
-        else if (Result = clNone) then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-function TTBXZezioTheme.GetPartColor(const ItemInfo: TTBXItemInfo; ItemPart:
-  TItemPart): TColor;
-const
-  MFlags1: array[Boolean] of TMenuItemState = (misDisabled, misDisabledHot);
-  MFlags2: array[Boolean] of TMenuItemState = (misNormal, misHot);
-  BFlags1: array[Boolean] of TBtnItemState = (bisDisabled, bisDisabledHot);
-  BFlags2: array[Boolean] of TBtnItemState = (bisSelected, bisSelectedHot);
-  BFlags3: array[Boolean] of TBtnItemState = (bisNormal, bisHot);
-var
-  IsMenuItem, Embedded: Boolean;
-  M: TMenuItemState;
-  B: TBtnItemState;
-begin
-  with ItemInfo do
-  begin
-    IsMenuItem := ((ViewType and PVT_POPUPMENU) = PVT_POPUPMENU) and
-      ((ItemOptions and IO_TOOLBARSTYLE) = 0) and (ItemInfo.ComboPart = cpNone);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-    if IsMenuItem then
-    begin
-      if not Enabled then
-        M := MFlags1[HoverKind = hkKeyboardHover]
-      else
-        M := MFlags2[HoverKind &lt;&gt; hkNone];
-      Result := MenuItemColors[M, ItemPart];
-    end
-    else
-    begin
-      if not Enabled then
-        B := BFlags1[HoverKind = hkKeyboardHover]
-      else if ItemInfo.IsPopupParent then
-        B := bisPopupParent
-      else if Pushed then
-        B := bisPressed
-      else if Selected then
-        B := BFlags2[HoverKind &lt;&gt; hkNone]
-      else
-        B := BFlags3[HoverKind &lt;&gt; hkNone];
-      Result := BtnItemColors[B, ItemPart];
-      if Embedded and (Result = clNone) then
-      begin
-        if ItemPart = ipBody then
-          Result := ToolbarColor;
-        if ItemPart = ipFrame then
-          Result := clBtnShadow;
-      end;
-    end;
-  end;
-end;
-
-procedure DrawButtonBitmap(Canvas: TCanvas; R: TRect; Color: TColor);
-const
-{$IFNDEF SMALL_CLOSE_BUTTON}
-  Pattern: array[0..15] of Byte =
-  ($C3, 0, $66, 0, $3C, 0, $18, 0, $3C, 0, $66, 0, $C3, 0, 0, 0);
-{$ELSE}
-  Pattern: array[0..15] of Byte =
-  (0, 0, $63, 0, $36, 0, $1C, 0, $1C, 0, $36, 0, $63, 0, 0, 0);
-{$ENDIF}
-var
-  Bmp: TBitmap;
-  W, H: Integer;
-  Index: Integer;
-begin
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern);
-    Index := SaveDC(Canvas.Handle);
-    Canvas.Brush.Color := Color;
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    W := 8;
-    H := 7;
-    with R do
-    begin
-      BitBlt(Canvas.Handle, (Left + Right - W + 1) div 2, (Top + Bottom - H) div
-        2, W, H,
-        Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-    end;
-    RestoreDC(Canvas.Handle, Index);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-function TTBXZezioTheme.GetItemColor(const ItemInfo: TTBXItemInfo): TColor;
-begin
-  Result := GetPartColor(ItemInfo, ipBody);
-  if Result = clNone then
-    Result := GetViewColor(ItemInfo.ViewType);
-end;
-
-function TTBXZezioTheme.GetItemTextColor(const ItemInfo: TTBXItemInfo): TColor;
-var
-  InMenuBar, ToolbarStyle, ShowInactive: Boolean;
-begin
-  with ItemInfo do
-  begin
-    InMenuBar := (ItemInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR;
-    ToolbarStyle := Boolean(ItemOptions and IO_TOOLBARSTYLE);
-    ShowInactive := InMenubar and not Boolean(ItemOptions and IO_APPACTIVE);
-
-    if not ToolbarStyle and not Enabled and (HoverKind = hkKeyboardHover) then
-      Result := clBtnShadow
-    else
-    if not Enabled then
-      Result := DisabledColor
-    else
-    if not ToolbarStyle or InMenuBar then
-    begin
-      if HoverKind &lt;&gt; hkNone then
-        Result := clHighlightText
-      else
-      if ShowInactive then
-        Result := clGrayText
-      else
-        Result := clMenuText
-    end
-    else
-      Result := clBtnText;
-  end;
-end;
-
-function TTBXZezioTheme.GetItemImageBackground(const ItemInfo: TTBXItemInfo):
-  TColor;
-begin
-  Result := GetBtnColor(ItemInfo, ipBody);
-  if Result = clNone then
-    result := GetViewColor(ItemInfo.ViewType);
-end;
-
-procedure TTBXZezioTheme.GetViewBorder(ViewType: Integer; out Border: TPoint);
-const
-  XMetrics: array[Boolean] of Integer = (SM_CXDLGFRAME, SM_CXFRAME);
-  YMetrics: array[Boolean] of Integer = (SM_CYDLGFRAME, SM_CYFRAME);
-var
-  Resizable: Boolean;
-
-  procedure SetBorder(X, Y: Integer);
-  begin
-    Border.X := X;
-    Border.Y := Y;
-  end;
-
-begin
-  if ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) or ((ViewType and TVT_MENUBAR) =
-    TVT_MENUBAR) then
-  begin
-    if (ViewType and TVT_FLOATING) = TVT_FLOATING then
-    begin
-      Resizable := (ViewType and TVT_RESIZABLE) = TVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else if (ViewType and VT_POPUP) = VT_POPUP then
-  begin
-    if (ViewType and PVT_POPUPMENU) = PVT_POPUPMENU then
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end
-    else
-    begin
-      Border.X := 2;
-      Border.Y := 2;
-    end;
-  end
-  else if (ViewType and VT_DOCKPANEL) = VT_DOCKPANEL then
-  begin
-    if (ViewType and DPVT_FLOATING) = DPVT_FLOATING then
-    begin
-      Resizable := (ViewType and DPVT_RESIZABLE) = DPVT_RESIZABLE;
-      Border.X := GetSystemMetrics(XMetrics[Resizable]) - 1;
-      Border.Y := GetSystemMetrics(YMetrics[Resizable]) - 1;
-    end
-    else
-      SetBorder(2, 2);
-  end
-  else
-    SetBorder(0, 0);
-end;
-
-procedure TTBXZezioTheme.GetMargins(MarginID: Integer; out Margins:
-  TTBXMargins);
-begin
-  with Margins do
-    case MarginID of
-      MID_TOOLBARITEM:
-        begin
-          LeftWidth := 2;
-          RightWidth := 2;
-          TopHeight := 2;
-          BottomHeight := 2;
-        end;
-      MID_STATUSPANE:
-        begin
-          LeftWidth := 3;
-          RightWidth := 3;
-          TopHeight := 1;
-          BottomHeight := 1;
-        end;
-      MID_MENUITEM:
-        begin
-          LeftWidth := 1;
-          RightWidth := 1;
-          TopHeight := 3;
-          BottomHeight := 3;
-        end;
-    else
-      LeftWidth := 0;
-      RightWidth := 0;
-      TopHeight := 0;
-      BottomHeight := 0;
-    end;
-end;
-
-procedure TTBXZezioTheme.PaintBackgnd(Canvas: TCanvas; const ADockRect, ARect,
-  AClipRect: TRect; AColor: TColor; Transparent: Boolean; AViewType: Integer);
-const
-  STRIPE_STEP = 3;
-var
-  HighlightColor: TColor;
-  ShadowColor: TColor;
-  Y, I: Integer;
-  R: TRect;
-begin
-  with Canvas do
-  begin
-    IntersectRect(R, ARect, AClipRect);
-    if (AViewType and DPVT_NORMAL = DPVT_NORMAL)
-      or ((AViewType and VT_TOOLBAR = VT_TOOLBAR)
-      and (AViewType and TVT_EMBEDDED = TVT_EMBEDDED)) then
-    begin
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-    end
-    else if not Transparent then
-    begin
-      I := ColorIntensity(AColor);
-      if I &lt; 200 then
-        I := (200 - I) div 20
-      else
-        I := 0;
-      HighlightColor := GetNearestColor(Handle, Lighten(AColor, 8 + I));
-      ShadowColor := GetNearestColor(Handle, Lighten(AColor, -8));
-
-      if not Transparent then
-      begin
-        Brush.Color := AColor;
-        FillRect(R);
-      end;
-
-      Y := (R.Top - ARect.Top) mod STRIPE_STEP;
-      Y := R.Top - Y;
-      while Y &lt; ARect.Bottom do
-      begin
-        DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, ShadowColor);
-        Inc(Y);
-        DrawLineEx(Canvas.Handle, R.Left, Y, R.Right, Y, HighlightColor);
-        Inc(Y, STRIPE_STEP - 1);
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintCaption(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo; const ACaption: string;
-  AFormat: Cardinal; Rotated: Boolean);
-var
-  R: TRect;
-  C: TColor;
-begin
-  with ItemInfo, Canvas do
-  begin
-    R := ARect;
-    C := Font.Color;
-    Brush.Style := bsClear;
-    if C = clNone then C := GetItemTextColor(ItemInfo);
-    Font.Color := C;
-    if not Rotated then
-      Windows.DrawText(Handle, PChar(ACaption), Length(ACaption), R, AFormat)
-    else
-      DrawRotatedText(Handle, ACaption, R, AFormat);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintCheckMark(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  X, Y: Integer;
-begin
-  X := (ARect.Left + ARect.Right) div 2 - 2;
-  Y := (ARect.Top + ARect.Bottom) div 2 + 1;
-  if ItemInfo.Enabled and (Iteminfo.HoverKind &lt;&gt; hkNone) then
-    Canvas.Pen.Color := clBlack
-  else if not ItemInfo.Enabled then
-    Canvas.Pen.Color := MenuItemColors[misDisabled, ipText]
-  else
-    Canvas.Pen.Color := clBlack;
-  Canvas.Polyline([Point(X - 2, Y - 2), Point(X, Y), Point(X + 4, Y - 4),
-    Point(X + 4, Y - 3), Point(X, Y + 1), Point(X - 2, Y - 1), Point(X - 2, Y -
-      2)]);
-end;
-
-procedure TTBXZezioTheme.PaintChevron(Canvas: TCanvas; ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-const
-  Pattern: array[Boolean, 0..15] of Byte = (
-    ($CC, 0, $66, 0, $33, 0, $66, 0, $CC, 0, 0, 0, 0, 0, 0, 0),
-    ($88, 0, $D8, 0, $70, 0, $20, 0, $88, 0, $D8, 0, $70, 0, $20, 0));
-var
-  R2: TRect;
-  Bmp: TBitmap;
-begin
-  R2 := ARect;
-  PaintButton(Canvas, ARect, ItemInfo);
-  if not ItemInfo.IsVertical then
-  begin
-    R2.Top := 4;
-    R2.Bottom := R2.Top + 5;
-    Inc(R2.Left, 2);
-    R2.Right := R2.Left + 8;
-  end
-  else
-  begin
-    R2.Left := R2.Right - 9;
-    R2.Right := R2.Left + 5;
-    Inc(R2.Top, 2);
-    R2.Bottom := R2.Top + 8;
-  end;
-  Bmp := TBitmap.Create;
-  try
-    Bmp.Handle := CreateBitmap(8, 8, 1, 1, @Pattern[ItemInfo.IsVertical]);
-    Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-    SetTextColor(Canvas.Handle, clBlack);
-    SetBkColor(Canvas.Handle, clWhite);
-    with R2 do
-      BitBlt(Canvas.Handle, Left, Top, Right - Left,
-        Bottom - Top, Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  finally
-    Bmp.Free;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintEditButton(Canvas: TCanvas; const ARect: TRect;
-  var ItemInfo: TTBXItemInfo; ButtonInfo: TTBXEditBtnInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  BtnDisabled, BtnHot, BtnPressed, Embedded: Boolean;
-  R, BR: TRect;
-  X, Y: Integer;
-  SaveItemInfoPushed: Boolean;
-
-  procedure PaintEnabled(R: TRect; Pressed: Boolean);
-  var
-    C: TColor;
-  begin
-    if BtnDisabled then
-      C := EditFrameDisColor
-    else
-      C := EditFrameColor;
-    if Embedded then
-    begin
-      FillRectEx(Canvas.Handle, R, ToolBarColor);
-      FrameRectEx(Canvas.Handle, R, C, True);
-    end
-    else
-      FrameRectEx(Canvas.Handle, R, C, True);
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    Inc(R.Left);
-    Embedded := ((ViewType and VT_TOOLBAR) = VT_TOOLBAR) and
-      ((ViewType and TVT_EMBEDDED) = TVT_EMBEDDED);
-
-    if ButtonInfo.ButtonType = EBT_DROPDOWN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBDS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBDS_HOT) &lt;&gt; 0;
-      BtnPressed := (ButtonInfo.ButtonState and EBDS_PRESSED) &lt;&gt; 0;
-
-      if not BtnDisabled then
-      begin
-        if BtnPressed then
-        begin
-          GradientFill(Canvas, R, Blend(clBtnHigHlight, clBtnFace, 60),
-            Blend(clBtnFace, clBtnShadow, 60), TGTopBottom);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clBtnFace, clBtnShadow, 45);
-          MoveTo(R.Left + 1, R.Top + 1);
-          LineTo(R.Right - 1, R.Top + 1);
-          Pen.Color := clBtnShadow;
-        end
-        else if BtnHot then
-        begin
-          GradientFill(Canvas, R, clBtnFace, clBtnHighLight, TGTopBottom);
-          InflateRect(R, 1, 1);
-          Pen.Color := EditFrameColor;
-        end
-        else
-        begin
-          PaintEnabled(R, BtnPressed);
-        end;
-      end;
-      if BtnDisabled then
-        FrameRectEx(Canvas.Handle, R, BtnItemColors[bisDisabled, ipFrame],
-          True);
-      if (not BtnPressed) and (not BtnHot) then
-        Pen.Color := EditFrameColor;
-      if not BtnDisabled then
-      begin
-        MoveTo(R.Left, R.Top);
-        LineTo(R.Left, R.Bottom);
-      end;
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-    end
-    else if ButtonInfo.ButtonType = EBT_SPIN then
-    begin
-      BtnDisabled := (ButtonInfo.ButtonState and EBSS_DISABLED) &lt;&gt; 0;
-      BtnHot := (ButtonInfo.ButtonState and EBSS_HOT) &lt;&gt; 0;
-
-      // Upper button
-      Pen.Color := clBtnShadow;
-      BR := R;
-      BR.Bottom := (R.Top + R.Bottom + 1) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0;
-      SaveItemInfoPushed := ItemInfo.Pushed;
-      ItemInfo.Pushed := BtnPressed;
-
-      if not BtnDisabled then
-      begin
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          // BR = Button Rectangle
-          BR.Bottom := BR.Bottom - 1;
-          if BtnPressed then
-          begin
-            GradientFill(Canvas, BR, Blend(clBtnHigHlight, clBtnFace, 60),
-              Blend(clBtnFace, clBtnShadow, 60), TGTopBottom);
-            InflateRect(BR, 1, 1);
-            Pen.Color := Blend(clBtnFace, clBtnShadow, 45);
-            MoveTo(BR.Left + 1, BR.Top + 1);
-            LineTo(BR.Right - 1, BR.Top + 1);
-            Pen.Color := clBtnShadow;
-          end
-          else if BtnHot then
-          begin
-            GradientFill(Canvas, BR, clBtnFace, clBtnHighLight, TGTopBottom);
-            InflateRect(BR, 1, 1);
-            Pen.Color := EditFrameColor;
-          end;
-          BR.Bottom := BR.Bottom + 1;
-        end;
-        if (not BtnPressed) and (not BtnHot) then
-          Pen.Color := EditFrameColor;
-        MoveTo(BR.Left, BR.Top);
-        LineTo(BR.Left, BR.Bottom);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom - 1) div 2;
-      if not BtnDisabled then
-        Pen.Color := ArrowColor[not Boolean(ItemOptions and IO_TOOLBARSTYLE)]
-      else
-        Pen.Color := DisabledColor;
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y + 1), Point(X + 2, Y + 1), Point(X, Y - 1)]);
-
-      // Lower button...
-      Pen.Color := BaseShade;
-      BR := R;
-      BR.Top := (R.Top + R.Bottom) div 2;
-      BtnPressed := (ButtonInfo.ButtonState and EBSS_DOWN) &lt;&gt; 0;
-      if btnHot or btnPressed then
-        BR.Top := Br.Top + 1;
-
-      ItemInfo.Pushed := BtnPressed;
-      if not BtnDisabled then
-      begin
-        PaintEnabled(BR, (ButtonInfo.ButtonState and EBSS_UP) &lt;&gt; 0);
-        if BtnPressed or BtnHot or Embedded then
-        begin
-          if BtnPressed then
-          begin
-            GradientFill(Canvas, BR, Blend(clBtnHigHlight, clBtnFace, 60),
-              Blend(clBtnFace, clBtnShadow, 60), TGTopBottom);
-            InflateRect(BR, 1, 1);
-            Pen.Color := Blend(clBtnFace, clBtnShadow, 45);
-            MoveTo(BR.Left + 1, BR.Top + 1);
-            LineTo(BR.Right - 1, BR.Top + 1);
-            Pen.Color := clBtnShadow;
-          end
-          else if BtnHot then
-          begin
-            GradientFill(Canvas, BR, clBtnFace, clBtnHighLight, TGTopBottom);
-            InflateRect(BR, 1, 1);
-            Pen.Color := EditFrameColor;
-          end
-        end;
-        if (not BtnPressed) and (not BtnHot) then
-          Pen.Color := EditFrameColor;
-        MoveTo(BR.Left, BR.Bottom - 1);
-        LineTo(BR.Left, BR.Top);
-        LineTo(BR.Right, BR.Top);
-      end;
-
-      X := (BR.Left + BR.Right) div 2;
-      Y := (BR.Top + BR.Bottom) div 2;
-      if not BtnDisabled then
-        Pen.Color := ArrowColor[not Boolean(ItemOptions and IO_TOOLBARSTYLE)]
-      else
-        Pen.Color := DisabledColor;
-      Brush.Color := Pen.Color;
-      Polygon([Point(X - 2, Y - 1), Point(X + 2, Y - 1), Point(X, Y + 1)]);
-      ItemInfo.Pushed := SaveItemInfoPushed;
-    end;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintEditFrame(Canvas: TCanvas;
-  const ARect: TRect; var ItemInfo: TTBXItemInfo; const EditInfo: TTBXEditInfo);
-var
-  R: TRect;
-  W: Integer;
-begin
-  R := ARect;
-  PaintFrame(Canvas, R, ItemInfo);
-  W := EditFrameWidth;
-  InflateRect(R, -W, -W);
-
-  with EditInfo do
-    if RightBtnWidth &gt; 0 then
-      Dec(R.Right, RightBtnWidth - 2);
-
-  if ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := EditFrameColor // Should be central...
-    else
-      Canvas.Brush.Color := EditFrameDisColor;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWindow;
-  end;
-
-  if not ItemInfo.Enabled then
-  begin
-    if ItemInfo.HoverKind = hkNone then
-      Canvas.Brush.Color := BtnItemColors[bisDisabled, ipFrame]
-    else
-      Canvas.Brush.Color := clWindow;
-    Canvas.FrameRect(R);
-    Canvas.Brush.Color := clWindow;
-  end;
-
-  InflateRect(R, -1, -1);
-  if ItemInfo.Enabled then
-    Canvas.FillRect(R);
-
-  if EditInfo.RightBtnWidth &gt; 0 then
-  begin
-    R := ARect;
-    InflateRect(R, -W, -W);
-    R.Left := R.Right - EditInfo.RightBtnWidth;
-    PaintEditButton(Canvas, R, ItemInfo, EditInfo.RightBtnInfo);
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintDropDownArrow(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ArrowColor: array[Boolean] of TColor = (clBtnText, clMenuText);
-var
-  X, Y: Integer;
-  C: TColor;
-begin
-  if ItemInfo.Enabled then
-    C := ArrowColor[not Boolean(ItemInfo.ItemOptions and IO_TOOLBARSTYLE)]
-  else
-    C := DisabledColor;
-  with ARect, Canvas do
-    if (ItemInfo.ComboPart = cpNone) or (ItemInfo.ComboPart = cpCombo) then
-    begin
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 - 1;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 + 1;
-      end;
-      Pen.Color := C;
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-
-      if ItemInfo.IsVertical then
-      begin
-        X := (Left + Right) div 2 + 2;
-        Y := (Top + Bottom) div 2;
-      end
-      else
-      begin
-        X := (Left + Right) div 2;
-        Y := (Top + Bottom) div 2 - 2;
-      end;
-      Pen.Color := C;
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X + 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y - 2)]);
-    end
-    else
-    begin
-      X := (Left + Right) div 2;
-      Y := (Top + Bottom) div 2 - 1;
-      Pen.Color := C;
-      Brush.Color := Pen.Color;
-      if ItemInfo.IsVertical then
-        Polygon([Point(X, Y + 2), Point(X, Y - 2), Point(X - 2, Y)])
-      else
-        Polygon([Point(X - 2, Y), Point(X + 2, Y), Point(X, Y + 2)]);
-    end;
-end;
-
-procedure TTBXZezioTheme.PaintButton(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  RL, RR: Integer;
-  ShowHover, Embedded: Boolean;
-begin
-  R := ARect;
-  with ItemInfo, Canvas do
-  begin
-    ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover));
-    Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-      (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-    RL := 2;
-    RR := 2;
-
-    if ComboPart = cpSplitRight then
-    begin
-      Dec(R.Left);
-      Dec(RL);
-    end;
-    if ComboPart = cpSplitLeft then
-      Dec(RR);
-    if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-    begin
-      RR := 1;
-      RL := 1;
-    end;
-
-    if Embedded and not ShowHover then
-    begin
-      if Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        FillRectEx(Canvas.Handle, R, ToolBarColor);
-        InflateRect(R, 1, 1);
-        Pen.Color := clBtnShadow;
-      end
-      else
-        Pen.Color := clBtnFace;
-      SmartFrame(Canvas, R, RL, RR, Pen.Color, clNone);
-    end;
-
-    if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) then
-    begin
-      if ((Pushed or Selected) and Enabled) or ShowHover then
-        PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-          ipBody], False, VT_UNKNOWN);
-      Exit;
-    end;
-
-    if (Pushed or Selected) and Enabled then
-    begin
-      InflateRect(R, -1, -1);
-      if not Pushed then
-      begin
-        if HoverKind = hkNone then
-        begin
-          GradientFill(Canvas, R, clBtnHighLight, clBtnFace, TGTopBottom);
-          InflateRect(R, 1, 1);
-          SmartFrame(Canvas, R, RL, RR, clBtnShadow, Blend(clBtnShadow,
-            clBtnFace, 50));
-          Pen.Color := Blend(clBtnShadow, clBtnFace, 25);
-          MoveTo(R.Left + RL, R.Top + 1);
-          LineTo(R.Right - RR, R.Top + 1);
-        end
-        else
-        begin
-          GradientFill(Canvas, R, clBtnFace, clBtnHighLight, TGTopBottom);
-          InflateRect(R, 1, 1);
-          SmartFrame(Canvas, R, RL, RR, GetBtnColor(ItemInfo, ipFrame), clNone);
-        end;
-      end
-      else
-      begin
-        GradientFill(Canvas, R, Blend(clBtnHigHlight, clBtnFace, 60),
-          Blend(clBtnFace, clBtnShadow, 60), TGTopBottom);
-        InflateRect(R, 1, 1);
-        SmartFrame(Canvas, R, RL, RR, clBtnShadow, Blend(clBtnShadow, clBtnFace,
-          50));
-        Pen.Color := Blend(clBtnFace, clBtnShadow, 45);
-        MoveTo(R.Left + RL, R.Top + 1);
-        LineTo(R.Right - RR, R.Top + 1);
-      end;
-    end
-    else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      InflateRect(R, -1, -1);
-      GradientFill(Canvas, R, clBtnFace, clBtnHighLight, TGTopBottom);
-      InflateRect(R, 1, 1);
-      SmartFrame(Canvas, R, RL, RR, GetBtnColor(ItemInfo, ipFrame), clNone);
-    end;
-
-    if ComboPart = cpSplitRight then
-      PaintDropDownArrow(Canvas, R, ItemInfo);
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintFloatingBorder(Canvas: TCanvas; const ARect:
-  TRect;
-  const WindowInfo: TTBXWindowInfo);
-const
-  SPI_GETGRADIENTCAPTIONS = $1008;
-  DC_GRADIENT = $20;
-  ActiveCaptionFlags: array[Boolean] of Integer = (0, DC_ACTIVE);
-  GradientCaptionFlags: array[Boolean] of Integer = (0, DC_GRADIENT);
-  CaptionBkColors: array[Boolean, Boolean] of Integer =
-  ((COLOR_INACTIVECAPTION, COLOR_ACTIVECAPTION),
-    (COLOR_GRADIENTINACTIVECAPTION, COLOR_GRADIENTACTIVECAPTION));
-  ButtonStateFlags: array[Boolean] of Integer = (0, DFCS_PUSHED);
-var
-  R, R2: TRect;
-  DC: HDC;
-  Gradient, ShowCloseBtn: Boolean;
-  B: BOOL;
-begin
-  DC := Canvas.Handle;
-
-  with WindowInfo do
-  begin
-    R := ARect;
-    if (WRP_BORDER and RedrawPart) &lt;&gt; 0 then
-    begin
-      R2 := R;
-      with FloatingBorderSize do
-        InflateRect(R2, -X, -Y);
-      SaveDC(DC);
-      with R2 do
-        ExcludeClipRect(DC, Left, Top, Right, Bottom);
-      Windows.DrawEdge(DC, R, EDGE_RAISED, BF_RECT or BF_MIDDLE);
-      RestoreDC(DC, -1);
-    end;
-
-    if not WindowInfo.ShowCaption then
-      Exit;
-    Gradient := SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, @B, 0) and B;
-    ShowCloseBtn := (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0;
-    R := GetTBXCloseButtonRect(WindowInfo, True);
-
-    if (WRP_CAPTION and RedrawPart) &lt;&gt; 0 then
-    begin
-      if ShowCloseBtn then
-      begin
-        SaveDC(DC);
-        with R do
-          ExcludeClipRect(DC, Left, Top, Right, Bottom);
-      end;
-      R2 := GetTBXCaptionRect(WindowInfo, True, ShowCloseBtn);
-      DrawCaption(ParentHandle, DC, R2, DC_TEXT or DC_SMALLCAP or
-        ActiveCaptionFlags[Active] or GradientCaptionFlags[Gradient]);
-      if ShowCloseBtn then
-        RestoreDC(DC, -1);
-      R2 := GetTBXCaptionRect(WindowInfo, True, False);
-      R2.Top := R2.Bottom;
-      Inc(R2.Bottom);
-      FillRect(DC, R2, GetSysColorBrush(COLOR_BTNFACE));
-    end;
-
-    if ShowCloseBtn then
-    begin
-      R2 := R;
-      InflateRect(R2, -2, -2);
-      if (WRP_CAPTION and RedrawPart) &lt;&gt; 0 then
-      begin
-        SaveDC(DC);
-        with R2 do
-          ExcludeClipRect(DC, Left, Top, Right, Bottom);
-        FillRect(DC, R, GetSysColorBrush(CaptionBkColors[Gradient,
-          WindowInfo.Active]));
-        RestoreDC(DC, -1);
-      end;
-      if (WRP_CLOSEBTN and RedrawPart) &lt;&gt; 0 then
-        DrawFrameControl(DC, R2, DFC_CAPTION, DFCS_CAPTIONCLOSE or
-          ButtonStateFlags[(CDBS_PRESSED and CloseButtonState) &lt;&gt; 0]);
-    end;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintFrame(Canvas: TCanvas; const ARect: TRect; const
-  ItemInfo: TTBXItemInfo);
-var
-  R: TRect;
-  E: Boolean;
-  C: TColor;
-begin
-  R := ARect;
-  with ItemInfo do
-  begin
-    E := Enabled or (not Enabled and (HoverKind = hkKeyboardHover));
-    if not E then
-    begin
-      InflateRect(R, -1, -1);
-      FrameRectEx(Canvas.Handle, R, ToolBarColor, True);
-    end
-    else if Pushed or Selected or (HoverKind &lt;&gt; hkNone) or ((ItemOptions and
-      IO_DESIGNING) &lt;&gt; 0) then
-    begin
-      if Pushed then
-        C := BtnItemColors[bisSelected, ipFrame]
-      else
-        C := GetPartColor(ItemInfo, ipFrame);
-      SmartFrame(Canvas, R, 1, 1, c, clNone);
-    end;
-  end;
-end;
-
-function TTBXZezioTheme.GetImageOffset(Canvas: TCanvas;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList): TPoint;
-begin
-  Result.X := 0;
-  if not (ImageList is TTBCustomImageList) then
-    with ItemInfo do
-      if Enabled and (HoverKind &lt;&gt; hkNone) and
-        not (Selected or Pushed and not IsPopupParent) then
-        Result.X := -1;
-  Result.Y := Result.X
-end;
-
-procedure TTBXZezioTheme.PaintImage(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ImageList: TCustomImageList; ImageIndex:
-  Integer);
-var
-  HiContrast: Boolean;
-begin
-  with ItemInfo do
-  begin
-    if ImageList is TTBCustomImageList then
-    begin
-      TTBCustomImageList(ImageList).DrawState(Canvas, ARect.Left, ARect.Top,
-        ImageIndex, Enabled, (HoverKind &lt;&gt; hkNone), Selected);
-      Exit;
-    end;
-
-    HiContrast := ColorIntensity(GetItemImageBackground(ItemInfo)) &lt; 80;
-    if not Enabled then
-    begin
-      if not HiContrast then
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 0)
-      else
-        DrawTBXIconFlatShadow(Canvas, ARect, ImageList, ImageIndex,
-          clBtnShadow);
-    end
-    else if Selected or Pushed or (HoverKind &lt;&gt; hkNone) then
-    begin
-      if Selected or Pushed then
-      begin
-        {
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-        }
-      end
-      else
-      begin
-        {
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, 1, 1);
-        DrawTBXIconShadow(Canvas, ARect, ImageList, ImageIndex, 1);
-        OffsetRect(ARect, -2, -2);
-        }
-      end;
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast);
-    end
-    else if HiContrast or TBXHiContrast or TBXLoColor then
-      DrawTBXIcon(Canvas, ARect, ImageList, ImageIndex, HiContrast)
-    else
-      HighlightTBXIcon(Canvas, ARect, ImageList, ImageIndex, clWindow, 255);
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintMDIButton(Canvas: TCanvas; ARect: TRect;
-  const ItemInfo: TTBXItemInfo; ButtonKind: Cardinal);
-var
-  Index: Integer;
-  X, Y: Integer;
-  Bmp: TBitmap;
-begin
-  PaintButton(Canvas, ARect, ItemInfo);
-  with ARect do
-  begin
-    X := (Left + Right - StockImgList.Width) div 2;
-    Y := (Top + Bottom - StockImgList.Height) div 2;
-  end;
-  case ButtonKind of
-    DFCS_CAPTIONMIN: Index := 2;
-    DFCS_CAPTIONRESTORE: Index := 3;
-    DFCS_CAPTIONCLOSE: Index := 0;
-  else
-    Exit;
-  end;
-  Bmp := TBitmap.Create;
-  Bmp.Monochrome := True;
-  StockImgList.GetBitmap(Index, Bmp);
-  Canvas.Brush.Color := GetPartColor(ItemInfo, ipText);
-  SetTextColor(Canvas.Handle, clBlack);
-  SetBkColor(Canvas.Handle, clWhite);
-  BitBlt(Canvas.Handle, X, Y, StockImgList.Width, StockImgList.Height,
-    Bmp.Canvas.Handle, 0, 0, ROP_DSPDxax);
-  Bmp.Free;
-end;
-
-procedure TTBXZezioTheme.PaintMenuItemFrame(Canvas: TCanvas;
-  const ARect: TRect; const ItemInfo: TTBXItemInfo);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-begin
-  with ItemInfo do
-    if (Enabled and (HoverKind &lt;&gt; hkNone)) or
-      (not Enabled and (HoverKind = hkKeyboardHover)) then
-    begin
-      PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-        ipBody], False, VT_UNKNOWN);
-    end;
-end;
-
-procedure TTBXZezioTheme.PaintMenuItem(Canvas: TCanvas; const ARect: TRect; var
-  ItemInfo: TTBXItemInfo);
-var
-  R, R2: TRect;
-  X, Y: Integer;
-  ArrowWidth: Integer;
-  ClrText: TColor;
-
-  procedure DrawArrow(AColor: TColor);
-  begin
-    Canvas.Pen.Color := AColor;
-    Canvas.Brush.Color := AColor;
-    Canvas.Polygon([Point(X, Y - 3), Point(X, Y + 3), Point(X + 3, Y)]);
-  end;
-
-  procedure PaintButton(Canvas: TCanvas; const ARect: TRect; const ItemInfo:
-    TTBXItemInfo);
-  var
-    R: TRect;
-    RL, RR: Integer;
-    ShowHover, Embedded: Boolean;
-  begin
-    R := ARect;
-    with ItemInfo, Canvas do
-    begin
-      ShowHover := (Enabled and (HoverKind &lt;&gt; hkNone)) or
-        (not Enabled and (HoverKind = hkKeyboardHover));
-      Embedded := (ViewType and VT_TOOLBAR = VT_TOOLBAR) and
-        (ViewType and TVT_EMBEDDED = TVT_EMBEDDED);
-      RL := 2;
-      RR := 2;
-
-      if ComboPart = cpSplitRight then
-      begin
-        Dec(R.Left);
-        Dec(RL);
-      end;
-      if ComboPart = cpSplitLeft then
-        Dec(RR);
-      if (ItemInfo.ItemOptions and IO_TOOLBARSTYLE) = 0 then
-      begin
-        RR := 2;
-        RL := 2;
-      end;
-
-      if Embedded and not ShowHover then
-      begin
-        if Enabled then
-        begin
-          InflateRect(R, -1, -1);
-          FillRectEx(Canvas.Handle, R, ToolBarColor);
-          InflateRect(R, 1, 1);
-          Pen.Color := Blend(clHighLight, clWindow, 20);
-        end
-        else
-          Pen.Color := Blend(clHighLight, clWindow, 15);
-        SmartFrame(Canvas, R, RL, RR, Pen.Color, clNone);
-      end;
-
-      if ((ViewType and TVT_MENUBAR) = TVT_MENUBAR) and (not MenuButtons) then
-      begin
-        if ((Pushed or Selected) and Enabled) or ShowHover then
-        begin
-          PaintBackgnd(Canvas, ZERO_RECT, ARect, ARect, MenuItemColors[misHot,
-            ipBody], False, VT_UNKNOWN);
-        end;
-        Exit;
-      end;
-
-      if (Pushed or Selected) and Enabled then
-      begin
-        InflateRect(R, -1, -1);
-        if not Pushed and (HoverKind = hkNone) then
-        begin
-          GradientFill(Canvas, R, clBtnHighLight, clBtnFace, TGTopBottom);
-          InflateRect(R, 1, 1);
-          SmartFrame(Canvas, R, RL, RR, clBtnShadow, Blend(clBtnShadow,
-            clBtnFace, 50));
-          Pen.Color := Blend(clBtnShadow, clBtnFace, 25);
-          MoveTo(R.Left + RL, R.Top + 1);
-          LineTo(R.Right - RR, R.Top + 1);
-        end
-        else
-        begin
-          GradientFill(Canvas, R, clBtnFace, clBtnHighLight, TGTopBottom);
-          InflateRect(R, 1, 1);
-          SmartFrame(Canvas, R, RL, RR, GetBtnColor(ItemInfo, ipFrame), clNone);
-        end;
-      end
-      else if ShowHover or ((ItemOptions and IO_DESIGNING) &lt;&gt; 0) then
-      begin
-        Canvas.Pen.Color := Blend(clred, clWindow, 40);
-        RoundFrame(Canvas, R, RL, RR);
-      end;
-      if ComboPart = cpSplitRight then
-        PaintDropDownArrow(Canvas, R, ItemInfo);
-    end;
-  end;
-
-begin
-  with Canvas, ItemInfo do
-  begin
-    R := ARect;
-    ArrowWidth := GetSystemMetrics(SM_CXMENUCHECK);
-    if (ImageWidth &gt; 0) or Selected then
-      Inc(R.Left, ItemInfo.PopupMargin + MenuImageTextSpace);
-    PaintMenuItemFrame(Canvas, R, ItemInfo);
-    ClrText := GetPartColor(ItemInfo, ipText);
-
-    if (ItemOptions and IO_COMBO) &lt;&gt; 0 then
-    begin
-      X := R.Right - ArrowWidth - 1;
-      if not ItemInfo.Enabled then
-        Pen.Color := ClrText
-      else if HoverKind = hkMouseHover then
-        Pen.Color := clWhite
-      else
-        Pen.Color := PopupSeparatorColor;
-      MoveTo(X, R.Top + 1);
-      LineTo(X, R.Bottom - 1);
-    end;
-
-    if (ItemOptions and IO_SUBMENUITEM) &lt;&gt; 0 then
-    begin
-      Y := ARect.Bottom div 2;
-      X := ARect.Right - ArrowWidth * 2 div 3 - 1;
-      DrawArrow(ClrText);
-    end;
-
-    R2 := Arect;
-    InflateRect(R2, -1, -1);
-
-    if ((Selected) and (Enabled)) then
-    begin
-      R.Left := R2.Left;
-      R.Right := R.Left + ItemInfo.PopupMargin;
-      PaintButton(Canvas, R, ItemInfo);
-    end;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintPopupNCArea(Canvas: TCanvas; R: TRect; const
-  PopupInfo: TTBXPopupInfo);
-var
-  PR: TRect;
-begin
-  with Canvas do
-  begin
-    Brush.Color := PopupFrameColor;
-    FrameRect(R);
-    InflateRect(R, -1, -1);
-    Brush.Color := PopupColor;
-    FillRect(R);
-
-    if not IsRectEmpty(PopupInfo.ParentRect) then
-    begin
-      PR := PopupInfo.ParentRect;
-      if not IsRectEmpty(PR) then
-        with PR do
-        begin
-          Pen.Color := ToolbarColor;
-          if Bottom = R.Top then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Bottom - 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Top = R.Bottom then
-          begin
-            if Left &lt;= R.Left then
-              Left := R.Left - 1;
-            if Right &gt;= R.Right then
-              Right := R.Right + 1;
-            MoveTo(Left + 1, Top);
-            LineTo(Right - 1, Top);
-          end;
-          if Right = R.Left then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Right - 1, Top + 1);
-            LineTo(Right - 1, Bottom - 1);
-          end
-          else if Left = R.Right then
-          begin
-            if Top &lt;= R.Top then
-              Top := R.Top - 1;
-            if Bottom &gt;= R.Bottom then
-              Bottom := R.Bottom + 1;
-            MoveTo(Left, Top + 1);
-            LineTo(Left, Bottom - 1);
-          end;
-        end;
-    end;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintSeparator(Canvas: TCanvas; ARect: TRect;
-  ItemInfo: TTBXItemInfo; Horizontal, LineSeparator: Boolean);
-begin
-  with ItemInfo, ARect, Canvas do
-  begin
-    if Horizontal and Enabled then
-    begin
-      Top := (Bottom div 2);
-      while Left &lt; Right do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Left := Left + 3;
-      end;
-    end
-    else
-    if Enabled then
-    begin
-      Left := (Right div 2);
-      while Top &lt; Bottom do
-      begin
-        Canvas.Pixels[Left, Top] := clBlack;
-        Top := Top + 3;
-      end;
-    end;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintToolbarNCArea(Canvas: TCanvas; R: TRect;
-  const ToolbarInfo: TTBXToolbarInfo);
-const
-  Pattern: array[0..15] of Byte = (0, 0, $CC, 0, $78, 0, $30, 0, $78, 0, $CC, 0,
-    0, 0, 0, 0);
-  DragHandleOffsets: array[Boolean, DHS_DOUBLE..DHS_SINGLE] of Integer = ((2, 0,
-    1), (5, 0, 5));
-
-  function GetBtnItemState(BtnState: Integer): TBtnItemState;
-  begin
-    if (BtnState and CDBS_PRESSED) &lt;&gt; 0 then
-      Result := bisPressed
-    else if (BtnState and CDBS_HOT) &lt;&gt; 0 then
-      Result := bisHot
-    else
-      Result := bisNormal;
-  end;
-
-var
-  Sz, Z: Integer;
-  R2: TRect;
-  j: Integer;
-  BtnVisible, Horz, CloseButtondown, CloseButtonHover: Boolean;
-begin
-  with Canvas do
-  begin
-    if not ToolbarInfo.IsVertical then
-      j := -1
-    else
-      j := +1;
-    R.Top := R.Top + j;
-    if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      PaintBackgnd(Canvas, ZERO_RECT, R, R, MenubarColor, false, VT_UNKNOWN)
-    else
-      PaintBackgnd(Canvas, ZERO_RECT, R, R, ToolbarColor, false, VT_UNKNOWN);
-    R.Top := R.Top - j;
-    if ((ToolbarInfo.ViewType and TVT_NORMALTOOLBAR) = TVT_NORMALTOOLBAR)
-      or (((ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR))
-      or ((ToolbarInfo.ViewType and TVT_TOOLWINDOW) = TVT_TOOLWINDOW) then
-      if (ToolbarInfo.ViewType and TVT_MENUBAR) = TVT_MENUBAR then
-      begin
-        DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right - 1, R.Top,
-          clBtnHighLight); // Top
-        DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom - 1,
-          clBtnHighLight); // Left
-        DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-          clBtnShadow);
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom
-          - 1, clBtnShadow);
-      end
-      else
-      begin
-        DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Right - 1, R.Top,
-          clBtnHighLight); // Top
-        DrawLineEx(Canvas.Handle, R.Left, R.Top, R.Left, R.Bottom - 1,
-          clBtnHighLight); // Left
-        DrawLineEx(Canvas.Handle, R.Left + 1, R.Bottom - 1, R.Right, R.Bottom -
-          1, clBtnShadow); // Bottom
-        DrawLineEx(Canvas.Handle, R.Right - 1, R.Top + 1, R.Right - 1, R.Bottom
-          - 1, clBtnShadow); // Right
-      end;
-    InflateRect(R, -2, -2);
-
-    if not ToolbarInfo.AllowDrag then
-      Exit;
-
-    BtnVisible := (ToolbarInfo.CloseButtonState and CDBS_VISIBLE) &lt;&gt; 0;
-    Sz := GetTBXDragHandleSize(ToolbarInfo);
-    Horz := not ToolbarInfo.IsVertical;
-    if Horz then
-      R.Right := R.Left + Sz
-    else
-      R.Bottom := R.Top + Sz;
-
-    { Drag Handle }
-    if ToolbarInfo.DragHandleStyle &lt;&gt; DHS_NONE then
-    begin
-      R2 := R;
-      if Horz then
-      begin
-        R2.Top := R2.Top + 2;
-        R2.Bottom := R2.Bottom - 2;
-        R2.Right := R2.Right - 1;
-        if BtnVisible then
-        begin
-          Inc(R2.Top, Sz - 2);
-          Inc(R2.Left, 4);
-          Dec(R2.Right, 4);
-        end;
-        GradientFill(Canvas, R2, clBtnFace, clBtnShadow, TGLeftRight);
-        DrawLineEx(Canvas.Handle, R2.Left, R2.Top + 1, R2.Left, R2.Bottom - 1,
-          Blend(clBtnFace, clBtnHighLight, 50));
-      end
-      else
-      begin
-        R2.Left := R2.Left + 2;
-        R2.Right := R2.Right - 2;
-        if BtnVisible then
-        begin
-          Dec(R2.Right, Sz - 2);
-          Inc(R2.Top, 4);
-          Dec(R2.Bottom, 4);
-        end;
-        R2.Bottom := R2.Bottom - 1;
-        GradientFill(Canvas, R2, clBtnFace, clBtnShadow, TGTopBottom);
-        DrawLineEx(Canvas.Handle, R2.Left + 1, R2.Top, R2.Right - 1, R2.Top,
-          Blend(clBtnFace, clBtnHighLight, 50));
-      end;
-    end;
-
-    { Close Button }
-    if BtnVisible then
-    begin
-      CloseButtonDown := (ToolbarInfo.CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (ToolbarInfo.CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := GetTBXDockedCloseButtonRect(ToolbarInfo);
-      Z := 2;
-      if Horz then
-      begin
-        Dec(R2.Bottom, Z);
-        Dec(R2.Right, Z);
-      end
-      else
-      begin
-        Dec(R2.Bottom, Z);
-        Inc(R2.Left, Z);
-      end;
-
-      if CloseButtonDown then
-      begin
-        Windows.DrawEdge(Canvas.Handle, R2, BDR_SUNKENOUTER, BF_RECT);
-        OffsetRect(R2, 1, 1);
-      end
-      else if CloseButtonHover then
-        Windows.DrawEdge(Canvas.Handle, R2, BDR_RAISEDINNER, BF_RECT);
-      DrawGlyph(Canvas.Handle, R2, 7, 7, Pattern[0], clBtnText);
-    end;
-  end;
-end;
-
-procedure TTBXZezioTheme.PaintDock(Canvas: TCanvas; const ClientRect,
-  DockRect: TRect; DockPosition: Integer);
-var
-  R: TRect;
-begin
-  Canvas.Pen.Width := 0;
-  Canvas.Brush.Style := bsSolid;
-  Canvas.Brush.Color := clBtnFace;
-  R := DockRect;
-  InFlateRect(R, 1, 1);
-  Canvas.Rectangle(R);
-end;
-
-procedure TTBXZezioTheme.PaintDockPanelNCArea(Canvas: TCanvas; R: TRect; const
-  DockPanelInfo: TTBXDockPanelInfo);
-var
-  DC: HDC;
-  Sz: Integer;
-  R2: TRect;
-  Flags: Integer;
-  CloseButtonDown, CloseButtonHover: Boolean;
-
-  procedure CaptionFill(R: TRect);
-  const
-    GRAD: array[Boolean] of TGradientKind = (gkHorz, gkVert);
-  begin
-    if USE_THEMES then
-      GradFill(DC, R, Lighten(ToolbarColor, 12), Lighten(ToolbarColor, -12),
-        GRAD[DockPanelInfo.IsVertical])
-    else
-      FillRectEx(DC, R, ToolbarColor);
-  end;
-
-begin
-  DC := Canvas.Handle;
-  with Canvas, DockPanelInfo do
-  begin
-    Sz := GetSystemMetrics(SM_CYSMCAPTION);
-
-    { Border }
-    FrameRectEx(DC, R, ToolbarColor, True);
-    R2 := R;
-    if ShowCaption then
-      if IsVertical then
-        Inc(R2.Top, Sz)
-      else
-        Inc(R2.Left, Sz);
-    FrameRectEx(DC, R2, clWindow, False);
-
-    if not ShowCaption then
-      Exit;
-
-    { Caption area }
-    if IsVertical then
-      R.Bottom := R.Top + Sz
-    else
-      R.Right := R.Left + Sz;
-    Windows.DrawEdge(Handle, R, BDR_RAISEDINNER, BF_RECT or BF_ADJUST);
-
-    { Close button }
-    if (CDBS_VISIBLE and CloseButtonState) &lt;&gt; 0 then
-    begin
-      CloseButtonDown := (CloseButtonState and CDBS_PRESSED) &lt;&gt; 0;
-      CloseButtonHover := (CloseButtonState and CDBS_HOT) &lt;&gt; 0;
-      R2 := R;
-      Brush.Color := ToolbarColor;
-      if IsVertical then
-      begin
-        R2.Left := R2.Right - Sz;
-        R.Right := R2.Left;
-        CaptionFill(R2);
-        InflateRect(R2, -1, -1);
-        Inc(R2.Left);
-      end
-      else
-      begin
-        R2.Top := R2.Bottom - Sz;
-        R.Bottom := R2.Top;
-        CaptionFill(R2);
-        InflateRect(R2, -1, -1);
-        Dec(R2.Bottom);
-      end;
-      if CloseButtonDown then
-      begin
-        Windows.DrawEdge(DC, R2, BDR_SUNKENOUTER, BF_RECT);
-        OffsetRect(R2, 1, 1);
-      end
-      else if CloseButtonHover then
-        Windows.DrawEdge(DC, R2, BDR_RAISEDINNER, BF_RECT);
-      InflateRect(R2, -2, -2);
-      DrawButtonBitmap(Canvas, R2, clBtnText);
-    end;
-
-    { Caption }
-    CaptionFill(R);
-    if IsVertical then
-      InflateRect(R, -2, 0)
-    else
-      Inflaterect(R, 0, -2);
-    Font.Assign(SmCaptionFont);
-    Font.Color := clBtnText;
-    Brush.Style := bsClear;
-    Flags := DT_SINGLELINE or DT_VCENTER or DT_END_ELLIPSIS or DT_NOPREFIX;
-    if IsVertical then
-      DrawText(Canvas.Handle, Caption, -1, R, Flags)
-    else
-      DrawRotatedText(Canvas.Handle, string(Caption), R, Flags);
-    Brush.Style := bsSolid;
-  end;
-end;
-
-procedure TTBXZezioTheme.SetupColorCache;
-var
-  DC: HDC;
-  HotBtnFace, DisabledText: TColor;
-
-  procedure Undither(var C: TColor);
-  begin
-    if C &lt;&gt; clNone then
-      C := GetNearestColor(DC, ColorToRGB(C));
-  end;
-
-begin
-  DC := StockCompatibleBitmap.Canvas.Handle;
-  MenubarColor := clBtnFace;
-  ToolbarColor := clBtnFace;
-
-  PopupColor := clWindow;
-  DockPanelColor := PopupColor;
-  PopupFrameColor := clBtnshadow;
-
-  EditFrameColor := clBtnShadow;
-  EditFrameDisColor := Blend(clBtnFace, clWindow, 75);
-  ;
-
-  BaseColor := clHighLight;
-  HotBtnFace := clBtnHighlight;
-  DisabledText := Blend(clBtnshadow, clWindow, 90);
-  DisabledColor := DisabledText;
-
-  WinFrameColors[wfsActive, wfpBorder] := Blend(clBtnShadow, clWhite, 80);
-  WinFrameColors[wfsActive, wfpCaption] := clBtnFace;
-  WinFrameColors[wfsActive, wfpCaptionText] := clCaptionText;
-  WinFrameColors[wfsInactive, wfpBorder] := WinFrameColors[wfsActive,
-    wfpBorder];
-  WinFrameColors[wfsInactive, wfpCaption] := BaseColor;
-  WinFrameColors[wfsInactive, wfpCaptionText] := clSilver;
-
-  PnlFrameColors[wfsActive, wfpBorder] := WinFrameColors[wfsActive, wfpBorder];
-  PnlFrameColors[wfsActive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsActive, wfpCaptionText] := clCaptionText;
-
-  PnlFrameColors[wfsInactive, wfpBorder] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaption] := clBtnFace;
-  PnlFrameColors[wfsInactive, wfpCaptionText] := clBtnFace;
-
-  BtnItemColors[bisNormal, ipBody] := clNone;
-  BtnItemColors[bisNormal, ipText] := clBtnText;
-  SetContrast(BtnItemColors[bisNormal, ipText], ToolbarColor, 180);
-  BtnItemColors[bisNormal, ipFrame] := clNone;
-
-  BtnItemColors[bisDisabled, ipBody] := clNone;
-  BtnItemColors[bisDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(BtnItemColors[bisDisabled, ipText], ToolbarColor, 80);
-  BtnItemColors[bisDisabled, ipFrame] := Blend(clBtnFace, clWindow, 50);
-
-  BtnItemColors[bisSelected, ipBody] := clNone;
-  SetContrast(BtnItemColors[bisSelected, ipBody], ToolbarColor, 5);
-  BtnItemColors[bisSelected, ipText] := BtnItemColors[bisNormal, ipText];
-  BtnItemColors[bisSelected, ipFrame] := clBtnShadow;
-
-  BtnItemColors[bisPressed, ipBody] := Blend(BaseColor, clWhite, 50);
-  BtnItemColors[bisPressed, ipText] := clBtnText;
-  BtnItemColors[bisPressed, ipFrame] := BaseColor;
-
-  BtnItemColors[bisHot, ipBody] := Blend(clHighlight, clWindow, 20);
-  BtnItemColors[bisHot, ipText] := clBtnText;
-  BtnItemColors[bisHot, ipFrame] := clBtnShadow;
-
-  BtnItemColors[bisDisabledHot, ipBody] := HotBtnFace;
-  BtnItemColors[bisDisabledHot, ipText] := DisabledText;
-  BtnItemColors[bisDisabledHot, ipFrame] := clNone;
-
-  BtnItemColors[bisSelectedHot, ipBody] := Blend(BaseColor, clWhite, 25);
-  SetContrast(BtnItemColors[bisSelectedHot, ipBody], ToolbarColor, 30);
-  BtnItemColors[bisSelectedHot, ipText] := clBtnText;
-  BtnItemColors[bisSelectedHot, ipFrame] := clBtnShadow;
-
-  BtnItemColors[bisPopupParent, ipBody] := Blend(BaseColor, clWhite, 80);
-  BtnItemColors[bisPopupParent, ipText] := clBtnText;
-  BtnItemColors[bisPopupParent, ipFrame] := clBtnShadow;
-
-  MenuItemColors[misNormal, ipBody] := clNone;
-  MenuItemColors[misNormal, ipText] := clBtnText;
-  SetContrast(MenuItemColors[misNormal, ipText], PopupColor, 180);
-  MenuItemColors[misNormal, ipFrame] := clNone;
-
-  MenuItemColors[misDisabled, ipBody] := clNone;
-  MenuItemColors[misDisabled, ipText] := Blend(clGrayText, clWindow, 70);
-  SetContrast(MenuItemColors[misDisabled, ipText], PopupColor, 80);
-  MenuItemColors[misDisabled, ipFrame] := clNone;
-
-  MenuItemColors[misHot, ipBody] := clHighLight;
-  MenuItemColors[misHot, ipText] := clHighLightText;
-  MenuItemColors[misHot, ipFrame] := BtnItemColors[bisHot, ipFrame];
-
-  MenuItemColors[misDisabledHot, ipBody] := PopupColor;
-  MenuItemColors[misDisabledHot, ipText] := Blend(clGrayText, clWindow, 50);
-  MenuItemColors[misDisabledHot, ipFrame] := clNone;
-
-  DragHandleColor := Blend(clGrayText, clWindow, 75);
-  SetContrast(DragHandleColor, ToolbarColor, 85);
-  IconShadowColor := Blend(clBlack, HotBtnFace, 25);
-
-  ToolbarSeparatorColor := clBtnText;
-  PopupSeparatorColor := ToolbarSeparatorColor;
-
-  Undither(MenubarColor);
-  Undither(ToolbarColor);
-  Undither(PopupColor);
-  Undither(DockPanelColor);
-  Undither(PopupFrameColor);
-  Undither(WinFrameColors[wfsActive, wfpBorder]);
-  Undither(WinFrameColors[wfsActive, wfpCaption]);
-  Undither(WinFrameColors[wfsActive, wfpCaptionText]);
-  Undither(WinFrameColors[wfsInactive, wfpBorder]);
-  Undither(WinFrameColors[wfsInactive, wfpCaption]);
-  Undither(WinFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsActive, wfpBorder]);
-  Undither(PnlFrameColors[wfsActive, wfpCaption]);
-  Undither(PnlFrameColors[wfsActive, wfpCaptionText]);
-  Undither(PnlFrameColors[wfsInactive, wfpBorder]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaption]);
-  Undither(PnlFrameColors[wfsInactive, wfpCaptionText]);
-  Undither(BtnItemColors[bisNormal, ipBody]);
-  Undither(BtnItemColors[bisNormal, ipText]);
-  Undither(BtnItemColors[bisNormal, ipFrame]);
-  Undither(BtnItemColors[bisDisabled, ipBody]);
-  Undither(BtnItemColors[bisDisabled, ipText]);
-  Undither(BtnItemColors[bisDisabled, ipFrame]);
-  Undither(BtnItemColors[bisSelected, ipBody]);
-  Undither(BtnItemColors[bisSelected, ipText]);
-  Undither(BtnItemColors[bisSelected, ipFrame]);
-  Undither(BtnItemColors[bisPressed, ipBody]);
-  Undither(BtnItemColors[bisPressed, ipText]);
-  Undither(BtnItemColors[bisPressed, ipFrame]);
-  Undither(BtnItemColors[bisHot, ipBody]);
-  Undither(BtnItemColors[bisHot, ipText]);
-  Undither(BtnItemColors[bisHot, ipFrame]);
-  Undither(BtnItemColors[bisDisabledHot, ipBody]);
-  Undither(BtnItemColors[bisDisabledHot, ipText]);
-  Undither(BtnItemColors[bisDisabledHot, ipFrame]);
-  Undither(BtnItemColors[bisSelectedHot, ipBody]);
-  Undither(BtnItemColors[bisSelectedHot, ipText]);
-  Undither(BtnItemColors[bisSelectedHot, ipFrame]);
-  Undither(BtnItemColors[bisPopupParent, ipBody]);
-  Undither(BtnItemColors[bisPopupParent, ipText]);
-  Undither(BtnItemColors[bisPopupParent, ipFrame]);
-  Undither(MenuItemColors[misNormal, ipBody]);
-  Undither(MenuItemColors[misNormal, ipText]);
-  Undither(MenuItemColors[misNormal, ipFrame]);
-  Undither(MenuItemColors[misDisabled, ipBody]);
-  Undither(MenuItemColors[misDisabled, ipText]);
-  Undither(MenuItemColors[misDisabled, ipFrame]);
-  Undither(MenuItemColors[misHot, ipBody]);
-  Undither(MenuItemColors[misHot, ipText]);
-  Undither(MenuItemColors[misHot, ipFrame]);
-  Undither(MenuItemColors[misDisabledHot, ipBody]);
-  Undither(MenuItemColors[misDisabledHot, ipText]);
-  Undither(MenuItemColors[misDisabledHot, ipFrame]);
-  Undither(DragHandleColor);
-  Undither(IconShadowColor);
-  Undither(ToolbarSeparatorColor);
-  Undither(PopupSeparatorColor);
-  Undither(StatusPanelFrameColor);
-end;
-
-function TTBXZezioTheme.GetPopupShadowType: Integer;
-begin
-  Result := PST_WINDOWS2K;
-end;
-
-constructor TTBXZezioTheme.Create(const AName: string);
-begin
-  inherited;
-  if CounterLock = 0 then
-    InitializeStock;
-  Inc(CounterLock);
-  AddTBXSysChangeNotification(Self);
-  SetupColorCache;
-end;
-
-destructor TTBXZezioTheme.Destroy;
-begin
-  RemoveTBXSysChangeNotification(Self);
-  Dec(CounterLock);
-  if CounterLock = 0 then
-    FinalizeStock;
-  inherited;
-end;
-
-procedure TTBXZezioTheme.GetViewMargins(ViewType: Integer;
-  out Margins: TTBXMargins);
-begin
-  Margins.LeftWidth := 0;
-  Margins.TopHeight := 0;
-  Margins.RightWidth := 0;
-  Margins.BottomHeight := 0;
-end;
-
-procedure TTBXZezioTheme.PaintPageScrollButton(Canvas: TCanvas;
-  const ARect: TRect; ButtonType: Integer; Hot: Boolean);
-var
-  R: TRect;
-  Flags: Integer;
-begin
-  R := ARect;
-  if Hot then
-    Flags := DFCS_FLAT
-  else
-    Flags := 0;
-  case ButtonType of
-    PSBT_UP: Flags := Flags or DFCS_SCROLLUP;
-    PSBT_DOWN: Flags := Flags or DFCS_SCROLLDOWN;
-    PSBT_LEFT: Flags := Flags or DFCS_SCROLLLEFT;
-    PSBT_RIGHT: Flags := Flags or DFCS_SCROLLRIGHT;
-  end;
-  Windows.DrawFrameControl(Canvas.Handle, R, DFC_SCROLL, Flags);
-end;
-
-procedure TTBXZezioTheme.PaintFrameControl(Canvas: TCanvas; R: TRect; Kind,
-  State: Integer; Params: Pointer);
-const
-  Offs: array[0..10] of integer = (3, 1, 1, 0, 0, 0, 0, 0, 1, 1, 3);
-var
-  X, Y: Integer;
-  rc1, gc1, bc1,
-    rc2, gc2, bc2,
-    rc3, gc3, bc3,
-    y1, i, j, GSize: Integer;
-  GradCol: TRGBTriple;
-  Brush: HBrush;
-
-  procedure RadioGradient(const Canvas: TCanvas; const ARect: TRect;
-    const StartColor, EndColor: TColor; Shadow: TColor);
-  var
-    i: integer;
-  begin
-    rc1 := GetRValue(ColorToRGB(StartColor));
-    gc1 := GetGValue(ColorToRGB(StartColor));
-    bc1 := GetBValue(ColorToRGB(StartColor));
-    rc2 := GetRValue(ColorToRGB(EndColor));
-    gc2 := GetGValue(ColorToRGB(EndColor));
-    bc2 := GetBValue(ColorToRGB(EndColor));
-
-    rc3 := rc2 + (((rc1 - rc2) * 15) div 9);
-    gc3 := gc2 + (((gc1 - gc2) * 15) div 9);
-    bc3 := bc2 + (((bc1 - bc2) * 15) div 9);
-
-    if rc3 &lt; 0 then
-      rc3 := 0
-    else if rc3 &gt; 255 then
-      rc3 := 255;
-    if gc3 &lt; 0 then
-      gc3 := 0
-    else if gc3 &gt; 255 then
-      gc3 := 255;
-    if bc3 &lt; 0 then
-      bc3 := 0
-    else if bc3 &gt; 255 then
-      bc3 := 255;
-
-    j := 0;
-    GSize := (ARect.Bottom - ARect.Top) - 1;
-    if Shadow &lt;&gt; clNone then
-    begin
-      i := GSize;
-      Brush := CreateSolidBrush(Shadow);
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom
-        - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-      DeleteObject(Brush);
-      j := 1;
-    end;
-
-    for i := 0 to GSize - j do
-    begin
-      Brush := CreateSolidBrush(
-        RGB(Byte(rc1 + (((rc2 - rc1) * i) div GSize)),
-        Byte(gc1 + (((gc2 - gc1) * i) div GSize)),
-        Byte(bc1 + (((bc2 - bc1) * i) div GSize))));
-      Windows.FillRect(Canvas.Handle, Rect(ARect.Left + Offs[i], ARect.Bottom
-        - i - 1, ARect.Right - Offs[i], ARect.Bottom - i), Brush);
-      DeleteObject(Brush);
-    end;
-  end;
-
-  function TextColor: TColor;
-  begin
-    if Boolean(State and PFS_DISABLED) then
-      Result := BtnItemColors[bisDisabled, ipText]
-    else if Boolean(State and PFS_PUSHED) then
-      Result := BtnItemColors[bisPressed, ipText]
-    else if Boolean(State and PFS_MIXED) then
-      Result := clBtnShadow
-    else if Boolean(State and PFS_HOT) then
-      Result := BtnItemColors[bisHot, ipText]
-    else
-      Result := BtnItemColors[bisNormal, ipText];
-  end;
-
-begin
-  with Canvas do
-    case Kind of
-      PFC_CHECKBOX:
-        begin
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              GradientFill(Canvas, R, Blend(clBtnHigHlight, clBtnFace, 60),
-                Blend(clBtnFace, clBtnShadow, 60), TGTopBottom);
-              Pen.Color := Blend(clBtnShadow, clBtnFace, 25);
-              MoveTo(R.Left, R.Top);
-              LineTo(R.Right, R.Top);
-              Pen.Color := clBtnShadow;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              GradientFill(Canvas, R, clBtnFace, clBtnHighLight, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end
-            else
-            begin
-              GradientFill(Canvas, R, clBtnFace, clBtnHighLight, TGTopBottom);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            RoundFrame(Canvas, R, 0, 0);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              GradientFill(Canvas, R, clBtnHighLight, clBtnFace, TGTopBottom);
-              Pen.Color := Blend(clBtnShadow, clBtnFace, 25);
-              MoveTo(R.Left, R.Top);
-              LineTo(R.Right, R.Top);
-              InflateRect(R, 1, 1);
-              Pen.Color := clBtnShadow;
-            end
-            else
-              Pen.Color := clBtnShadow;
-            RoundFrame(Canvas, R, 0, 0);
-            Pen.Style := psSolid;
-            Brush.Style := bsSolid;
-          end;
-
-          if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-          begin
-            X := (R.Left + R.Right) div 2 - 1;
-            Y := (R.Top + R.Bottom) div 2 + 1;
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            Polygon([Point(X - 2, Y), Point(X, Y + 2), Point(X + 4, Y - 2),
-              Point(X + 4, Y - 4), Point(X, Y), Point(X - 2, Y - 2), Point(X -
-                2, Y)]);
-          end;
-        end;
-
-      PFC_RADIOBUTTON:
-        begin
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_HOT) then
-          begin
-            InflateRect(R, -1, -1);
-            if Boolean(State and PFS_PUSHED) then
-            begin
-              RadioGradient(Canvas, R, Blend(clBtnHigHlight, clBtnFace, 60),
-                Blend(clBtnFace, clBtnShadow, 60), Blend(clBtnShadow, clBtnFace,
-                25));
-              Pen.Color := clBtnShadow;
-            end
-            else if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              RadioGradient(Canvas, R, clBtnFace, clBtnHighLight, clNone);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end
-            else
-            begin
-              RadioGradient(Canvas, R, clBtnFace, clBtnHighLight, clNone);
-              Pen.Color := BtnItemColors[bisHot, ipFrame];
-            end;
-            InflateRect(R, 1, 1);
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end
-          else
-          begin
-            if Boolean(State and (PFS_CHECKED or PFS_MIXED)) then
-            begin
-              InflateRect(R, -1, -1);
-              RadioGradient(Canvas, R, clBtnHighLight, clBtnFace,
-                Blend(clBtnShadow, clBtnFace, 25));
-              Pen.Color := clBtnShadow;
-              InflateRect(R, 1, 1);
-            end
-            else
-              Pen.Color := clBtnShadow;
-
-            Brush.Style := bsClear;
-            X := R.Left;
-            Y := R.Top;
-            Polygon([Point(X, Y + 8), Point(X, Y + 4), Point(X + 1, Y + 3),
-              Point(X + 1, Y + 2), Point(X + 2, Y + 1), Point(X + 3, Y + 1),
-                Point(X + 4, Y), Point(X + 8, Y), Point(X + 9, Y + 1),
-                Point(X + 10, Y + 1), Point(X + 11, Y + 2), Point(X + 11, Y +
-                3),
-                Point(X + 12, Y + 4), Point(X + 12, Y + 8), Point(X + 11, Y +
-                9),
-                Point(X + 11, Y + 10), Point(X + 10, Y + 11), Point(X + 9, Y +
-                11),
-                Point(X + 8, Y + 12), Point(X + 4, Y + 12), Point(X + 3, Y +
-                11),
-                Point(X + 2, Y + 11), Point(X + 1, Y + 10), Point(X + 1, Y +
-                9)]);
-          end;
-          InflateRect(R, -1, -1);
-          Pen.Style := psSolid;
-          Brush.Style := bsClear;
-          if Boolean(State and PFS_CHECKED) then
-          begin
-            InflateRect(R, -3, -3);
-            Pen.Color := TextColor;
-            Brush.Color := Pen.Color;
-            with R do
-              Ellipse(Left, Top, Right, Bottom);
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXZezioTheme.PaintStatusBar(Canvas: TCanvas; R: TRect; Part:
-  Integer);
-const
-  ZERO_RECT: TRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);
-var
-  Color, Hi, Lo, Lo1, Hi1, Lo2, Hi2, Lo3, Hi3, Hi4: TColor;
-  D, Sz, i: Integer;
-
-  procedure DiagLine(C: TColor);
-  begin
-    with R do
-      DrawLineEx(Canvas.Handle, Right - 1 - D, Bottom - 1, Right, Bottom - D -
-        2, C);
-    Inc(D);
-  end;
-
-begin
-  with Canvas do
-    case Part of
-      SBP_BODY:
-        begin
-          FillRectEx(Canvas.Handle, R, clBtnFace);
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 0, R.Right, R.Top + 0,
-            Blend(clBtnShadow, cl3DDkShadow, 70));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 1, R.Right, R.Top + 1,
-            NearestMixedColor(clBtnShadow, clBtnFace, 128));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 2, R.Right, R.Top + 2,
-            NearestMixedColor(clBtnShadow, clBtnFace, 64));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 3, R.Right, R.Top + 3,
-            NearestMixedColor(clBtnShadow, clBtnFace, 32));
-          DrawLineEx(Canvas.Handle, R.Left, R.Top + 4, R.Right, R.Top + 4,
-            NearestMixedColor(clBtnShadow, clBtnFace, 12));
-
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 3, R.Right, R.Bottom - 3,
-            NearestMixedColor(clBtnShadow, clBtnFace, 8));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 2, R.Right, R.Bottom - 2,
-            NearestMixedColor(clBtnShadow, clBtnFace, 16));
-          DrawLineEx(Canvas.Handle, R.Left, R.Bottom - 1, R.Right, R.Bottom - 1,
-            NearestMixedColor(clBtnShadow, clBtnFace, 24));
-        end;
-      SBP_PANE, SBP_LASTPANE:
-        begin
-          if Part = SBP_PANE then
-            Dec(R.Right, 3);
-          while R.Top &lt; R.Bottom - 1 do
-          begin
-            Canvas.Pixels[R.Right, R.Top] := ToolbarSeparatorColor;
-            R.Top := R.Top + 3;
-          end;
-        end;
-      SBP_GRIPPER:
-        if DottedGrip then
-        begin
-          Color := clBtnFace;
-          Hi1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 64));
-          Lo1 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 48));
-          Hi2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 32));
-          Lo2 := GetNearestColor(Handle, MixColors(Color, clBtnShadow, 16));
-          Hi3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 128));
-          Lo3 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 96));
-          Hi4 := GetNearestColor(Handle, MixColors(Color, clBtnHighlight, 72));
-
-          with R do
-          begin
-            Pixels[Right - 12, Bottom - 4] := Lo2;
-            Pixels[Right - 12, Bottom - 3] := Hi2;
-            Pixels[Right - 11, Bottom - 4] := Lo1;
-            Pixels[Right - 11, Bottom - 3] := Hi1;
-            Pixels[Right - 11, Bottom - 2] := Hi4;
-            Pixels[Right - 10, Bottom - 2] := Hi3;
-            Pixels[Right - 10, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 4] := Lo2;
-            Pixels[Right - 8, Bottom - 3] := Hi2;
-            Pixels[Right - 7, Bottom - 4] := Lo1;
-            Pixels[Right - 7, Bottom - 3] := Hi1;
-            Pixels[Right - 7, Bottom - 2] := Hi4;
-            Pixels[Right - 6, Bottom - 2] := Hi3;
-            Pixels[Right - 6, Bottom - 3] := Lo3;
-
-            Pixels[Right - 4, Bottom - 4] := Lo2;
-            Pixels[Right - 4, Bottom - 3] := Hi2;
-            Pixels[Right - 3, Bottom - 4] := Lo1;
-            Pixels[Right - 3, Bottom - 3] := Hi1;
-            Pixels[Right - 3, Bottom - 2] := Hi4;
-            Pixels[Right - 2, Bottom - 2] := Hi3;
-            Pixels[Right - 2, Bottom - 3] := Lo3;
-
-            Pixels[Right - 8, Bottom - 8] := Lo2;
-            Pixels[Right - 8, Bottom - 7] := Hi2;
-            Pixels[Right - 7, Bottom - 8] := Lo1;
-            Pixels[Right - 7, Bottom - 7] := Hi1;
-            Pixels[Right - 7, Bottom - 6] := Hi4;
-            Pixels[Right - 6, Bottom - 6] := Hi3;
-            Pixels[Right - 6, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 8] := Lo2;
-            Pixels[Right - 4, Bottom - 7] := Hi2;
-            Pixels[Right - 3, Bottom - 8] := Lo1;
-            Pixels[Right - 3, Bottom - 7] := Hi1;
-            Pixels[Right - 3, Bottom - 6] := Hi4;
-            Pixels[Right - 2, Bottom - 6] := Hi3;
-            Pixels[Right - 2, Bottom - 7] := Lo3;
-
-            Pixels[Right - 4, Bottom - 12] := Lo2;
-            Pixels[Right - 4, Bottom - 11] := Hi2;
-            Pixels[Right - 3, Bottom - 12] := Lo1;
-            Pixels[Right - 3, Bottom - 11] := Hi1;
-            Pixels[Right - 3, Bottom - 10] := Hi4;
-            Pixels[Right - 2, Bottom - 10] := Hi3;
-            Pixels[Right - 2, Bottom - 11] := Lo3;
-          end;
-        end
-        else
-        begin
-          Sz := Min(R.Right - R.Left, R.Bottom - R.Top);
-          Lo := NearestMixedColor(clBtnFace, clBtnHighlight, 64);
-          Hi := NearestMixedColor(clBtnFace, clBtnShadow, 64);
-
-          D := 2;
-          for I := 1 to 3 do
-          begin
-            case Sz of
-              0..8:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                end;
-              9..12:
-                begin
-                  DiagLine(Lo);
-                  DiagLine(Hi);
-                  Inc(D);
-                end;
-            else
-              DiagLine(Lo);
-              Inc(D, 1);
-              DiagLine(Hi);
-              Inc(D, 1);
-            end;
-          end;
-        end;
-    end;
-end;
-
-procedure TTBXZezioTheme.TBXSysCommand(var Message: TMessage);
-begin
-  if Message.WParam = TSC_VIEWCHANGE then
-    SetupColorCache;
-end;
-
-{$IFNDEF DTM_Package}
-initialization
-  RegisterTBXTheme('Zezio', TTBXZezioTheme);
-{$ENDIF}
-end.
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002207.html">[Taspring-linux-commit] r7437 - Lobby/TASClient
</A></li>
	<LI>Next message: <A HREF="002209.html">[Taspring-linux-commit] r7439 - Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2208">[ date ]</a>
              <a href="thread.html#2208">[ thread ]</a>
              <a href="subject.html#2208">[ subject ]</a>
              <a href="author.html#2208">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
