<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5666 - in trunk/rts: Game Sim/Weapons
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5666%20-%20in%20trunk/rts%3A%20Game%20Sim/Weapons&In-Reply-To=%3C20080405141531.06D3B46B1%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000446.html">
   <LINK REL="Next"  HREF="000448.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5666 - in trunk/rts: Game Sim/Weapons</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5666%20-%20in%20trunk/rts%3A%20Game%20Sim/Weapons&In-Reply-To=%3C20080405141531.06D3B46B1%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5666 - in trunk/rts: Game Sim/Weapons">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Apr  5 16:15:30 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000446.html">[Taspring-linux-commit] r5665 - in trunk/rts/System: . Net
</A></li>
        <LI>Next message: <A HREF="000448.html">[Taspring-linux-commit] r5667 - in trunk: rts/Game rts/System	rts/System/Net tools/DedicatedServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#447">[ date ]</a>
              <a href="thread.html#447">[ thread ]</a>
              <a href="subject.html#447">[ subject ]</a>
              <a href="author.html#447">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-04-05 16:15:29 +0200 (Sat, 05 Apr 2008)
New Revision: 5666

Modified:
   trunk/rts/Game/GameHelper.cpp
   trunk/rts/Game/GameHelper.h
   trunk/rts/Sim/Weapons/BeamLaser.cpp
   trunk/rts/Sim/Weapons/Cannon.cpp
   trunk/rts/Sim/Weapons/EmgCannon.cpp
   trunk/rts/Sim/Weapons/FlameThrower.cpp
   trunk/rts/Sim/Weapons/LaserCannon.cpp
   trunk/rts/Sim/Weapons/LightingCannon.cpp
   trunk/rts/Sim/Weapons/MissileLauncher.cpp
   trunk/rts/Sim/Weapons/PlasmaRepulser.cpp
   trunk/rts/Sim/Weapons/Rifle.cpp
   trunk/rts/Sim/Weapons/StarburstLauncher.cpp
   trunk/rts/Sim/Weapons/TorpedoLauncher.cpp
Log:
fix up the weapon TryTarget() functions for avoidNeutral

Modified: trunk/rts/Game/GameHelper.cpp
===================================================================
--- trunk/rts/Game/GameHelper.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Game/GameHelper.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -667,53 +667,30 @@
 	}
 }
 
-bool CGameHelper::TestCone(const float3 &amp;from, const float3 &amp;dir,float length, float spread, int allyteam,CUnit* owner)
-{
-	int quads[1000];
-	int* endQuad = quads;
-	qf-&gt;GetQuadsOnRay(from,dir,length,endQuad);
 
-	for (int* qi = quads; qi != endQuad; ++qi) {
-		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
-			if((*ui)==owner)
-				continue;
-			CUnit* u=*ui;
-			float3 dif=u-&gt;midPos-from;
-			float closeLength=dif.dot(dir);
-			if(closeLength&lt;=0)
-				continue;//closeLength=0;
-			if(closeLength&gt;length)
-				closeLength=length;
-			float3 closeVect=dif-dir*closeLength;
-			float r=u-&gt;radius+spread*closeLength+1;
-			if(closeVect.SqLength() &lt; r*r){
-				return true;
-			}
-		}
-	}
-	return false;
-}
 
 bool CGameHelper::LineFeatureCol(const float3&amp; start, const float3&amp; dir, float length)
 {
 	int quads[1000];
 	int* endQuad = quads;
-	qf-&gt;GetQuadsOnRay(start,dir,length,endQuad);
+	qf-&gt;GetQuadsOnRay(start, dir, length, endQuad);
 
-	for(int* qi=quads;qi!=endQuad;++qi){
+	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 		for (list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
-			if(!(*ui)-&gt;blocking)
+			if (!(*ui)-&gt;blocking)
 				continue;
-			float3 dif=(*ui)-&gt;midPos-start;
-			float closeLength=dif.dot(dir);
-			if(closeLength&lt;0)
+
+			float3 dif = (*ui)-&gt;midPos - start;
+			float closeLength = dif.dot(dir);
+
+			if (closeLength &lt; 0)
 				continue;
-			if(closeLength&gt;length)
+			if (closeLength &gt; length)
 				continue;
-			float3 closeVect=dif-dir*closeLength;
-			if(closeVect.SqLength() &lt; (*ui)-&gt;sqRadius){
+
+			float3 closeVect = dif - dir * closeLength;
+			if (closeVect.SqLength() &lt; (*ui)-&gt;sqRadius) {
 				return true;
 			}
 		}
@@ -721,17 +698,20 @@
 	return false;
 }
 
+
 float CGameHelper::GuiTraceRayFeature(const float3&amp; start, const float3&amp; dir, float length, CFeature*&amp; feature)
 {
-	float nearHit=length;
-	vector&lt;int&gt; quads=qf-&gt;GetQuadsOnRay(start,dir,length);
+	float nearHit = length;
+	vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
+	vector&lt;int&gt;::iterator qi;
 
-	vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 		list&lt;CFeature*&gt;::const_iterator ui;
+
 		for (ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
 			CFeature* f = *ui;
+
 			if ((f-&gt;allyteam &gt;= 0) &amp;&amp; !gu-&gt;spectatingFullView &amp;&amp;
 			    (f-&gt;allyteam != gu-&gt;myAllyTeam) &amp;&amp;
 			    !loshandler-&gt;InLos(f-&gt;pos, gu-&gt;myAllyTeam)) {
@@ -741,32 +721,35 @@
 				continue;
 			}
 			float3 dif = f-&gt;midPos-start;
-			float closeLength=dif.dot(dir);
-			if(closeLength&lt;0)
+			float closeLength = dif.dot(dir);
+
+			if (closeLength &lt; 0)
 				continue;
-			if(closeLength&gt;nearHit)
+			if (closeLength &gt; nearHit)
 				continue;
-			float3 closeVect=dif-dir*closeLength;
-			if(closeVect.SqLength() &lt; f-&gt;sqRadius){
+
+			float3 closeVect = dif - dir * closeLength;
+			if (closeVect.SqLength() &lt; f-&gt;sqRadius) {
 				nearHit = closeLength;
 				feature = f;
 			}
 		}
 	}
+
 	return nearHit;
 }
 
 float3 CGameHelper::GetUnitErrorPos(const CUnit* unit, int allyteam)
 {
-	float3 pos=unit-&gt;midPos;
-	if(gs-&gt;Ally(allyteam,unit-&gt;allyteam) || (unit-&gt;losStatus[allyteam] &amp; LOS_INLOS)){
+	float3 pos = unit-&gt;midPos;
+	if (gs-&gt;Ally(allyteam,unit-&gt;allyteam) || (unit-&gt;losStatus[allyteam] &amp; LOS_INLOS)) {
 		// ^ it's one of our own, or it's in LOS, so don't add an error ^
-	} else if((!gameSetup || gameSetup-&gt;ghostedBuildings) &amp;&amp; (unit-&gt;losStatus[allyteam] &amp; LOS_PREVLOS) &amp;&amp; (unit-&gt;losStatus[allyteam] &amp; LOS_CONTRADAR) &amp;&amp; !unit-&gt;mobility){
+	} else if ((!gameSetup || gameSetup-&gt;ghostedBuildings) &amp;&amp; (unit-&gt;losStatus[allyteam] &amp; LOS_PREVLOS) &amp;&amp; (unit-&gt;losStatus[allyteam] &amp; LOS_CONTRADAR) &amp;&amp; !unit-&gt;mobility) {
 		// ^ this is a ghosted building, so don't add an error ^
-	} else if((unit-&gt;losStatus[allyteam] &amp; LOS_INRADAR)){
-		pos+=unit-&gt;posErrorVector*radarhandler-&gt;radarErrorSize[allyteam];
+	} else if ((unit-&gt;losStatus[allyteam] &amp; LOS_INRADAR)) {
+		pos += unit-&gt;posErrorVector * radarhandler-&gt;radarErrorSize[allyteam];
 	} else {
-		pos+=unit-&gt;posErrorVector*radarhandler-&gt;baseRadarErrorSize*2;
+		pos += unit-&gt;posErrorVector * radarhandler-&gt;baseRadarErrorSize * 2;
 	}
 	return pos;
 }
@@ -801,18 +784,18 @@
 float3 CGameHelper::Pos2BuildPos(const BuildInfo&amp; buildInfo)
 {
 	float3 pos;
-	if(buildInfo.GetXSize()&amp;2)
-		pos.x=floor((buildInfo.pos.x)/(SQUARE_SIZE*2))*SQUARE_SIZE*2+8;
+	if (buildInfo.GetXSize() &amp; 2)
+		pos.x = floor((buildInfo.pos.x    ) / (SQUARE_SIZE * 2)) * SQUARE_SIZE * 2 + 8;
 	else
-		pos.x=floor((buildInfo.pos.x+8)/(SQUARE_SIZE*2))*SQUARE_SIZE*2;
+		pos.x = floor((buildInfo.pos.x + 8) / (SQUARE_SIZE * 2)) * SQUARE_SIZE * 2;
 
-	if(buildInfo.GetYSize()&amp;2)
-		pos.z=floor((buildInfo.pos.z)/(SQUARE_SIZE*2))*SQUARE_SIZE*2+8;
+	if (buildInfo.GetYSize() &amp; 2)
+		pos.z = floor((buildInfo.pos.z    ) / (SQUARE_SIZE * 2)) * SQUARE_SIZE * 2 + 8;
 	else
-		pos.z=floor((buildInfo.pos.z+8)/(SQUARE_SIZE*2))*SQUARE_SIZE*2;
+		pos.z = floor((buildInfo.pos.z + 8) / (SQUARE_SIZE * 2)) * SQUARE_SIZE * 2;
 
-	pos.y=uh-&gt;GetBuildHeight(pos,buildInfo.def);
-	if(buildInfo.def-&gt;floater &amp;&amp; pos.y&lt;0)
+	pos.y = uh-&gt;GetBuildHeight(pos,buildInfo.def);
+	if (buildInfo.def-&gt;floater &amp;&amp; pos.y &lt; 0)
 		pos.y = -buildInfo.def-&gt;waterline;
 
 	return pos;
@@ -820,61 +803,140 @@
 
 void CGameHelper::Update(void)
 {
-	std::list&lt;WaitingDamage*&gt;* wd=&amp;waitingDamages[gs-&gt;frameNum&amp;127];
-	while(!wd-&gt;empty()){
-		WaitingDamage* w=wd-&gt;back();
+	std::list&lt;WaitingDamage*&gt;* wd = &amp;waitingDamages[gs-&gt;frameNum&amp;127];
+	while (!wd-&gt;empty()) {
+		WaitingDamage* w = wd-&gt;back();
 		wd-&gt;pop_back();
-		if(uh-&gt;units[w-&gt;target])
-			uh-&gt;units[w-&gt;target]-&gt;DoDamage(w-&gt;damage,w-&gt;attacker==-1?0:uh-&gt;units[w-&gt;attacker],w-&gt;impulse,w-&gt;weaponId);
+		if (uh-&gt;units[w-&gt;target])
+			uh-&gt;units[w-&gt;target]-&gt;DoDamage(w-&gt;damage, w-&gt;attacker == -1? 0: uh-&gt;units[w-&gt;attacker], w-&gt;impulse, w-&gt;weaponId);
 		delete w;
 	}
 }
 
-bool CGameHelper::TestTrajectoryCone(const float3 &amp;from, const float3 &amp;flatdir,float length, float linear, float quadratic, float spread, float baseSize, int allyteam,CUnit* owner)
+
+
+// return true if there is an allied unit within
+// the firing cone of &lt;owner&gt; (that might be hit)
+bool CGameHelper::TestAllyCone(const float3&amp; from, const float3&amp; dir, float length, float spread, int allyteam, CUnit* owner)
 {
 	int quads[1000];
 	int* endQuad = quads;
-	qf-&gt;GetQuadsOnRay(from,flatdir,length,endQuad);
+	qf-&gt;GetQuadsOnRay(from, dir, length, endQuad);
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 		for (list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
-			if((*ui)==owner)
+			CUnit* u = *ui;
+
+			if (u == owner)
 				continue;
-			CUnit* u=*ui;
-			float3 dif=u-&gt;midPos-from;
-			float3 flatdif(dif.x,0,dif.z);
-			float closeFlatLength=flatdif.dot(flatdir);
-			if(closeFlatLength&lt;=0)
-				continue;//closeLength=0;
-			if(closeFlatLength&gt;length)
-				closeFlatLength=length;
-/*
-			float3 newfrom=from+flatdir*closeFlatLength;
-			newfrom.y+=(linear+quadratic*closeFlatLength)*closeFlatLength;
-			geometricObjects-&gt;AddLine(newfrom-UpVector*(spread*closeFlatLength+baseSize),newfrom+UpVector*(spread*closeFlatLength+baseSize),3,0,16);
-/**/
-			if(fabs(linear-quadratic*closeFlatLength)&lt;0.15f){		//relativly flat region -&gt; use approximation
-				dif.y-=(linear+quadratic*closeFlatLength)*closeFlatLength;
 
-				float3 closeVect=dif-flatdir*closeFlatLength;
-				float r=u-&gt;radius+spread*closeFlatLength+baseSize;
-				if(closeVect.SqLength() &lt; r*r){
+			float3 dif = u-&gt;midPos - from;
+			float closeLength = dif.dot(dir);
+
+			if (closeLength &lt;= 0)
+				continue;
+			if (closeLength &gt; length)
+				closeLength = length;
+
+			float3 closeVect = dif - dir * closeLength;
+			float r = u-&gt;radius + spread * closeLength + 1;
+
+			if (closeVect.SqLength() &lt; r * r) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+// same as TestAllyCone, but looks for neutral units
+bool CGameHelper::TestNeutralCone(const float3&amp; from, const float3&amp; dir, float length, float spread, CUnit* owner)
+{
+	int quads[1000];
+	int* endQuad = quads;
+	qf-&gt;GetQuadsOnRay(from, dir, length, endQuad);
+
+	for (int* qi = quads; qi != endQuad; ++qi) {
+		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
+
+		for (list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+			CUnit* u = *ui;
+
+			if (u == owner)
+				continue;
+
+			if (u-&gt;neutral || (gs-&gt;useLuaGaia &amp;&amp; u-&gt;team == gs-&gt;gaiaTeamID) || (u-&gt;team == MAX_TEAMS - 1)) {
+				float3 dif = u-&gt;midPos - from;
+				float closeLength = dif.dot(dir);
+
+				if (closeLength &lt;= 0)
+					continue;
+				if (closeLength &gt; length)
+					closeLength = length;
+
+				float3 closeVect = dif - dir * closeLength;
+				float r = u-&gt;radius + spread * closeLength + 1;
+
+				if (closeVect.SqLength() &lt; r * r) {
 					return true;
 				}
+			}
+		}
+	}
+	return false;
+}
+
+
+
+// return true if there is an allied unit within
+// the firing trajectory of &lt;owner&gt; (that might
+// be hit)
+bool CGameHelper::TestTrajectoryAllyCone(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, int allyteam, CUnit* owner)
+{
+	int quads[1000];
+	int* endQuad = quads;
+	qf-&gt;GetQuadsOnRay(from, flatdir, length, endQuad);
+
+	for (int* qi = quads; qi != endQuad; ++qi) {
+		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
+		for (list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
+			CUnit* u = *ui;
+
+			if (u == owner)
+				continue;
+
+			float3 dif = u-&gt;midPos-from;
+			float3 flatdif(dif.x, 0, dif.z);
+			float closeFlatLength = flatdif.dot(flatdir);
+
+			if (closeFlatLength &lt;= 0)
+				continue;
+			if (closeFlatLength &gt; length)
+				closeFlatLength = length;
+
+			if (fabs(linear - quadratic * closeFlatLength) &lt; 0.15f) {
+				// relatively flat region -&gt; use approximation
+				dif.y -= (linear + quadratic * closeFlatLength) * closeFlatLength;
+
+				float3 closeVect = dif - flatdir * closeFlatLength;
+				float r = u-&gt;radius + spread * closeFlatLength + baseSize;
+				if (closeVect.SqLength() &lt; r * r) {
+					return true;
+				}
 			} else {
-				float3 newfrom=from+flatdir*closeFlatLength;
-				newfrom.y+=(linear+quadratic*closeFlatLength)*closeFlatLength;
-				float3 dir=flatdir;
-				dir.y=linear+quadratic*closeFlatLength;
+				float3 newfrom = from + flatdir * closeFlatLength;
+				newfrom.y += (linear + quadratic * closeFlatLength) * closeFlatLength;
+				float3 dir = flatdir;
+				dir.y = linear + quadratic * closeFlatLength;
 				dir.Normalize();
 
-				dif=u-&gt;midPos-newfrom;
-				float closeLength=dif.dot(dir);
+				dif = u-&gt;midPos - newfrom;
+				float closeLength = dif.dot(dir);
 
-				float3 closeVect=dif-dir*closeLength;
-				float r=u-&gt;radius+spread*closeFlatLength+baseSize;
-				if(closeVect.SqLength() &lt; r*r){
+				float3 closeVect = dif - dir * closeLength;
+				float r = u-&gt;radius + spread * closeFlatLength + baseSize;
+				if (closeVect.SqLength() &lt; r * r) {
 					return true;
 				}
 			}
@@ -882,3 +944,59 @@
 	}
 	return false;
 }
+
+// same as TestTrajectoryAllyCone, but looks for neutral units
+bool CGameHelper::TestTrajectoryNeutralCone(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, CUnit* owner)
+{
+	int quads[1000];
+	int* endQuad = quads;
+	qf-&gt;GetQuadsOnRay(from, flatdir, length, endQuad);
+
+	for (int* qi = quads; qi != endQuad; ++qi) {
+		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
+		for (list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+			CUnit* u = *ui;
+
+			if (u == owner)
+				continue;
+
+			if (u-&gt;neutral || (gs-&gt;useLuaGaia &amp;&amp; u-&gt;team == gs-&gt;gaiaTeamID) || (u-&gt;team == MAX_TEAMS - 1)) {
+				float3 dif = u-&gt;midPos - from;
+				float3 flatdif(dif.x, 0, dif.z);
+				float closeFlatLength = flatdif.dot(flatdir);
+
+				if (closeFlatLength &lt;= 0)
+					continue;
+				if (closeFlatLength &gt; length)
+					closeFlatLength = length;
+
+				if (fabs(linear - quadratic * closeFlatLength) &lt; 0.15f) {
+					// relatively flat region -&gt; use approximation
+					dif.y -= (linear + quadratic * closeFlatLength) * closeFlatLength;
+
+					float3 closeVect = dif - flatdir * closeFlatLength;
+					float r = u-&gt;radius + spread * closeFlatLength + baseSize;
+					if (closeVect.SqLength() &lt; r * r) {
+						return true;
+					}
+				} else {
+					float3 newfrom = from + flatdir * closeFlatLength;
+					newfrom.y += (linear + quadratic * closeFlatLength) * closeFlatLength;
+					float3 dir = flatdir;
+					dir.y = linear + quadratic * closeFlatLength;
+					dir.Normalize();
+
+					dif = u-&gt;midPos - newfrom;
+					float closeLength = dif.dot(dir);
+
+					float3 closeVect = dif - dir * closeLength;
+					float r = u-&gt;radius + spread * closeFlatLength + baseSize;
+					if (closeVect.SqLength() &lt; r * r) {
+						return true;
+					}
+				}
+			}
+		}
+	}
+	return false;
+}

Modified: trunk/rts/Game/GameHelper.h
===================================================================
--- trunk/rts/Game/GameHelper.h	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Game/GameHelper.h	2008-04-05 14:15:29 UTC (rev 5666)
@@ -28,8 +28,11 @@
 public:
 	CGameHelper(CGame* game);
 	virtual ~CGameHelper();
-	bool TestCone(const float3&amp; from,const float3&amp; dir,float length,float spread,int allyteam,CUnit* owner);
-	bool TestTrajectoryCone(const float3 &amp;from, const float3 &amp;flatdir,float length, float linear, float quadratic, float spread, float baseSize, int allyteam, CUnit* owner);
+	bool TestAllyCone(const float3&amp; from, const float3&amp; dir, float length, float spread, int allyteam, CUnit* owner);
+	bool TestNeutralCone(const float3&amp; from, const float3&amp; dir, float length, float spread, CUnit* owner);
+	bool TestTrajectoryAllyCone(const float3 &amp;from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, int allyteam, CUnit* owner);
+	bool TestTrajectoryNeutralCone(const float3 &amp;from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, CUnit* owner);
+
 	void GetEnemyUnits(const float3&amp; pos,float radius,int searchAllyteam,std::vector&lt;int&gt;&amp; found);
 	CUnit* GetClosestUnit(const float3&amp; pos,float radius);
 	CUnit* GetClosestEnemyUnit(const float3&amp; pos,float radius,int searchAllyteam);

Modified: trunk/rts/Sim/Weapons/BeamLaser.cpp
===================================================================
--- trunk/rts/Sim/Weapons/BeamLaser.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/BeamLaser.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -79,7 +79,7 @@
 	}
 }
 
-bool CBeamLaser::TryTarget(const float3&amp; pos,bool userTarget,CUnit* unit)
+bool CBeamLaser::TryTarget(const float3&amp; pos, bool userTarget,CUnit* unit)
 {
 	if (!CWeapon::TryTarget(pos, userTarget, unit))
 		return false;
@@ -94,7 +94,7 @@
 		}
 	}
 
-	float3 dir = pos-weaponMuzzlePos;
+	float3 dir = pos - weaponMuzzlePos;
 	float length = dir.Length();
 
 	if (length == 0)
@@ -109,14 +109,19 @@
 			return false;
 	}
 
-	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length))
+	float spread = (accuracy + sprayangle) * (1 - owner-&gt;limExperience * 0.7f);
+
+	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length)) {
 		return false;
-
+	}
 	if (avoidFriendly) {
-		float spread = (accuracy + sprayangle) * (1 - owner-&gt;limExperience * 0.7f);
-		if (helper-&gt;TestCone(weaponMuzzlePos, dir, length, spread, owner-&gt;allyteam, owner))
+		if (helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, spread, owner-&gt;allyteam, owner))
 			return false;
 	}
+	if (avoidNeutral) {
+		if (helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, spread, owner))
+			return false;
+	}
 
 	return true;
 }

Modified: trunk/rts/Sim/Weapons/Cannon.cpp
===================================================================
--- trunk/rts/Sim/Weapons/Cannon.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/Cannon.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -93,75 +93,60 @@
 	CWeapon::Update();
 }
 
-bool CCannon::TryTarget(const float3 &amp;pos,bool userTarget,CUnit* unit)
+bool CCannon::TryTarget(const float3 &amp;pos, bool userTarget, CUnit* unit)
 {
-
-	if(!CWeapon::TryTarget(pos,userTarget,unit))
-	{
+	if (!CWeapon::TryTarget(pos, userTarget, unit)) {
 		return false;
 	}
 
-	if(!weaponDef-&gt;waterweapon) {
-		if(unit)
-		{
-			if(unit-&gt;isUnderWater)
-			{
+	if (!weaponDef-&gt;waterweapon) {
+		if (unit) {
+			if (unit-&gt;isUnderWater) {
 				return false;
 			}
 		} else {
-			if(pos.y&lt;0)
-			{
+			if (pos.y &lt; 0) {
 				return false;
 			}
 		}
 	}
 
-	if (projectileSpeed == 0)
-	{
+	if (projectileSpeed == 0) {
 		return true;
 	}
-	float3 dif(pos-weaponMuzzlePos);
 
+	float3 dif(pos - weaponMuzzlePos);
 	float3 dir(GetWantedDir(dif));
 
-	if(dir.SqLength() == 0){
+	if (dir.SqLength() == 0) {
 		return false;
 	}
 
-	float3 flatdir(dif.x,0,dif.z);
-	float flatlength=flatdir.Length();
-	if(flatlength==0) {
+	float3 flatdir(dif.x, 0, dif.z);
+	float flatlength = flatdir.Length();
+	if (flatlength == 0) {
 		return true;
 	}
-	flatdir/=flatlength;
+	flatdir /= flatlength;
 
-	float gc=ground-&gt;TrajectoryGroundCol(weaponMuzzlePos, flatdir, flatlength-10,
+	float gc = ground-&gt;TrajectoryGroundCol(weaponMuzzlePos, flatdir, flatlength - 10,
 			dir.y , gravity / (projectileSpeed * projectileSpeed) * 0.5f);
-	if(gc&gt;0) {
+	if (gc &gt; 0) {
 		return false;
 	}
 
-/*	gc=ground-&gt;LineGroundCol(wpos+dir*(length*0.5f),pos,false);
-	if(gc&gt;0 &amp;&amp; gc&lt;length*0.40f)
+	float quadratic = gravity / (projectileSpeed * projectileSpeed) * 0.5f;
+	float spread = (accuracy + sprayangle) * 0.6f * (1 - owner-&gt;limExperience * 0.9f) * 0.9f;
+
+	if (avoidFriendly &amp;&amp; helper-&gt;TestTrajectoryAllyCone(weaponMuzzlePos, flatdir,
+		flatlength - 30, dir.y, quadratic, spread, 3, owner-&gt;allyteam, owner)) {
 		return false;
-*/
-	if(avoidFriendly &amp;&amp; helper-&gt;TestTrajectoryCone(weaponMuzzlePos, flatdir,
-		flatlength-30, dir.y, gravity /
-		(projectileSpeed * projectileSpeed) * 0.5f,
-		(accuracy+sprayangle) * 0.6f * (1-owner-&gt;limExperience * 0.9f) * 0.9f,
-		3, owner-&gt;allyteam, owner))
-	{
-		return false;
 	}
-/*	if(helper-&gt;TestCone(weaponPos,dir,length*0.5f,(accuracy+sprayangle)*1.2f*(1-owner-&gt;limExperience*0.9f)*0.9f,owner-&gt;allyteam,owner)){
+	if (avoidNeutral &amp;&amp; helper-&gt;TestTrajectoryNeutralCone(weaponMuzzlePos, flatdir,
+		flatlength - 30, dir.y, quadratic, spread, 3, owner)) {
 		return false;
 	}
-	float3 dir2(dif);
-	dir2.y+=predictTime*predictTime*gs-&gt;gravity;		//compensate for the earlier up prediction
-	dir2.Normalize();
-	if(helper-&gt;TestCone(weaponPos+dir*(length*0.5f),dir2,length*0.5f,(accuracy+sprayangle)*!userTarget*(1-owner-&gt;limExperience*0.9f)*0.6f,owner-&gt;allyteam,owner)){
-		return false;
-	}*/
+
 	return true;
 }
 

Modified: trunk/rts/Sim/Weapons/EmgCannon.cpp
===================================================================
--- trunk/rts/Sim/Weapons/EmgCannon.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/EmgCannon.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -40,37 +40,44 @@
 	CWeapon::Update();
 }
 
-bool CEmgCannon::TryTarget(const float3&amp; pos,bool userTarget,CUnit* unit)
+bool CEmgCannon::TryTarget(const float3&amp; pos, bool userTarget, CUnit* unit)
 {
-	if(!CWeapon::TryTarget(pos,userTarget,unit))
+	if (!CWeapon::TryTarget(pos, userTarget, unit))
 		return false;
 
 	if (!weaponDef-&gt;waterweapon) {
-		if(unit){
-			if(unit-&gt;isUnderWater)
+		if (unit) {
+			if (unit-&gt;isUnderWater)
 				return false;
 		} else {
-			if(pos.y&lt;0)
+			if (pos.y &lt; 0)
 				return false;
 		}
 	}
 
-	float3 dir=pos-weaponMuzzlePos;
-	float length=dir.Length();
-	if(length==0)
+	float3 dir = pos - weaponMuzzlePos;
+	float length = dir.Length();
+	if (length == 0)
 		return true;
 
-	dir/=length;
+	dir /= length;
 
-	float g=ground-&gt;LineGroundCol(weaponMuzzlePos,pos);
-	if(g&gt;0 &amp;&amp; g&lt;length*0.9f)
+	float g = ground-&gt;LineGroundCol(weaponMuzzlePos, pos);
+	if (g &gt; 0 &amp;&amp; g &lt; length * 0.9f)
 		return false;
 
-	if(avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos,dir,length))
+	float spread = (accuracy + sprayangle) * (1 - owner-&gt;limExperience * 0.5f);
+
+	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length)) {
 		return false;
+	}
+	if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, spread, owner-&gt;allyteam, owner)) {
+		return false;
+	}
+	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, spread, owner)) {
+		return false;
+	}
 
-	if(avoidFriendly &amp;&amp; helper-&gt;TestCone(weaponMuzzlePos,dir,length,(accuracy+sprayangle)*(1-owner-&gt;limExperience*0.5f),owner-&gt;allyteam,owner))
-		return false;
 	return true;
 }
 

Modified: trunk/rts/Sim/Weapons/FlameThrower.cpp
===================================================================
--- trunk/rts/Sim/Weapons/FlameThrower.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/FlameThrower.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -39,38 +39,42 @@
 		sound-&gt;PlaySample(fireSoundId, owner, fireSoundVolume);
 }
 
-bool CFlameThrower::TryTarget(const float3 &amp;pos,bool userTarget,CUnit* unit)
+bool CFlameThrower::TryTarget(const float3 &amp;pos, bool userTarget, CUnit* unit)
 {
-	if(!CWeapon::TryTarget(pos,userTarget,unit))
+	if (!CWeapon::TryTarget(pos, userTarget, unit))
 		return false;
 
 	if (!weaponDef-&gt;waterweapon) {
-		if(unit){
-			if(unit-&gt;isUnderWater)
+		if (unit) {
+			if (unit-&gt;isUnderWater)
 				return false;
 		} else {
-			if(pos.y&lt;0)
+			if (pos.y &lt; 0)
 				return false;
 		}
 	}
 
-	float3 dir=pos-weaponMuzzlePos;
-	float length=dir.Length();
-	if(length==0)
+	float3 dir = pos - weaponMuzzlePos;
+	float length = dir.Length();
+	if (length == 0)
 		return true;
 
-	dir/=length;
+	dir /= length;
 
-	float g=ground-&gt;LineGroundCol(weaponMuzzlePos,pos);
-	if(g&gt;0 &amp;&amp; g&lt;length*0.9f)
+	float g = ground-&gt;LineGroundCol(weaponMuzzlePos, pos);
+	if (g &gt; 0 &amp;&amp; g &lt; length * 0.9f)
 		return false;
 
-	if(avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos,dir,length))
+	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length)) {
 		return false;
-
-	if(avoidFriendly &amp;&amp; helper-&gt;TestCone(weaponMuzzlePos,dir,length,(accuracy+sprayangle),owner-&gt;allyteam,owner)){
+	}
+	if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, (accuracy + sprayangle), owner-&gt;allyteam, owner)) {
 		return false;
 	}
+	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, (accuracy + sprayangle), owner)) {
+		return false;
+	}
+
 	return true;
 }
 

Modified: trunk/rts/Sim/Weapons/LaserCannon.cpp
===================================================================
--- trunk/rts/Sim/Weapons/LaserCannon.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/LaserCannon.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -39,43 +39,51 @@
 	CWeapon::Update();
 }
 
-bool CLaserCannon::TryTarget(const float3&amp; pos,bool userTarget,CUnit* unit)
+bool CLaserCannon::TryTarget(const float3&amp; pos, bool userTarget, CUnit* unit)
 {
-	if(!CWeapon::TryTarget(pos,userTarget,unit))
+	if (!CWeapon::TryTarget(pos, userTarget, unit))
 		return false;
 
-	if(unit){
-		if(unit-&gt;isUnderWater &amp;&amp; !weaponDef-&gt;waterweapon)
+	if (unit) {
+		if (unit-&gt;isUnderWater &amp;&amp; !weaponDef-&gt;waterweapon)
 			return false;
 	} else {
-		if(pos.y&lt;0 &amp;&amp; !weaponDef-&gt;waterweapon)
+		if (pos.y &lt; 0 &amp;&amp; !weaponDef-&gt;waterweapon)
 			return false;
 	}
 
-	float3 dir=pos-weaponMuzzlePos;
-	float length=dir.Length();
-	if(length==0)
+	float3 dir = pos - weaponMuzzlePos;
+	float length = dir.Length();
+	if (length == 0)
 		return true;
 
-	dir/=length;
+	dir /= length;
 
-	if(!onlyForward){		//skip ground col testing for aircrafts
-		float g=ground-&gt;LineGroundCol(weaponMuzzlePos,pos);
-		if(g&gt;0 &amp;&amp; g&lt;length*0.9f)
+	if (!onlyForward) {
+		// skip ground col testing for aircraft
+		float g = ground-&gt;LineGroundCol(weaponMuzzlePos, pos);
+		if (g &gt; 0 &amp;&amp; g &lt; length * 0.9f)
 			return false;
 	}
-	if(avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos,dir,length))
+
+	float spread = (accuracy + sprayangle) * (1 - owner-&gt;limExperience * 0.7f);
+
+	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length)) {
 		return false;
+	}
+	if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, spread, owner-&gt;allyteam, owner)) {
+		return false;
+	}
+	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, spread, owner)) {
+		return false;
+	}
 
-	if(avoidFriendly &amp;&amp; helper-&gt;TestCone(weaponMuzzlePos,dir,length,(accuracy+sprayangle)*(1-owner-&gt;limExperience*0.7f),owner-&gt;allyteam,owner))
-		return false;
 	return true;
 }
 
 void CLaserCannon::Init(void)
 {
 	CWeapon::Init();
-//	muzzleFlareSize=0.5f;
 }
 
 void CLaserCannon::Fire(void)

Modified: trunk/rts/Sim/Weapons/LightingCannon.cpp
===================================================================
--- trunk/rts/Sim/Weapons/LightingCannon.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/LightingCannon.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -39,37 +39,42 @@
 	CWeapon::Update();
 }
 
-bool CLightingCannon::TryTarget(const float3&amp; pos,bool userTarget,CUnit* unit)
+bool CLightingCannon::TryTarget(const float3&amp; pos, bool userTarget, CUnit* unit)
 {
-	if(!CWeapon::TryTarget(pos,userTarget,unit))
+	if (!CWeapon::TryTarget(pos, userTarget, unit))
 		return false;
 
-	if(!weaponDef-&gt;waterweapon) {
-		if(unit){
-			if(unit-&gt;isUnderWater)
+	if (!weaponDef-&gt;waterweapon) {
+		if (unit) {
+			if (unit-&gt;isUnderWater)
 				return false;
 		} else {
-			if(pos.y&lt;0)
+			if (pos.y &lt; 0)
 				return false;
 		}
 	}
 
-	float3 dir=pos-weaponMuzzlePos;
-	float length=dir.Length();
-	if(length==0)
+	float3 dir = pos - weaponMuzzlePos;
+	float length = dir.Length();
+	if (length == 0)
 		return true;
 
-	dir/=length;
+	dir /= length;
 
-	float g=ground-&gt;LineGroundCol(weaponMuzzlePos,pos);
-	if(g&gt;0 &amp;&amp; g&lt;length*0.9f)
+	float g = ground-&gt;LineGroundCol(weaponMuzzlePos, pos);
+	if (g &gt; 0 &amp;&amp; g &lt; length * 0.9f)
 		return false;
 
-	if(avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos,dir,length))
+	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length)) {
 		return false;
+	}
+	if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, (accuracy + sprayangle), owner-&gt;allyteam, owner)) {
+		return false;
+	}
+	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, (accuracy + sprayangle), owner)) {
+		return false;
+	}
 
-	if(avoidFriendly &amp;&amp; helper-&gt;TestCone(weaponMuzzlePos,dir,length,(accuracy+sprayangle),owner-&gt;allyteam,owner))
-		return false;
 	return true;
 }
 

Modified: trunk/rts/Sim/Weapons/MissileLauncher.cpp
===================================================================
--- trunk/rts/Sim/Weapons/MissileLauncher.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/MissileLauncher.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -115,9 +115,12 @@
 		if (gc &gt; 0)
 			return false;
 
-		if (avoidFriendly &amp;&amp; helper-&gt;TestTrajectoryCone(weaponMuzzlePos, flatdir, flatlength - 30, linear, quadratic, 0, 8, owner-&gt;allyteam, owner)) {
+		if (avoidFriendly &amp;&amp; helper-&gt;TestTrajectoryAllyCone(weaponMuzzlePos, flatdir, flatlength - 30, linear, quadratic, 0, 8, owner-&gt;allyteam, owner)) {
 			return false;
 		}
+		if (avoidNeutral &amp;&amp; helper-&gt;TestTrajectoryNeutralCone(weaponMuzzlePos, flatdir, flatlength - 30, linear, quadratic, 0, 8, owner)) {
+			return false;
+		}
 	} else {
 		float length = dir.Length();
 		if (length == 0)
@@ -126,7 +129,7 @@
 		dir /= length;
 
 		if (!onlyForward) {
-			//skip ground col testing for aircrafts
+			// skip ground col testing for aircraft
 			float g = ground-&gt;LineGroundCol(weaponMuzzlePos, pos);
 			if (g &gt; 0 &amp;&amp; g &lt; length * 0.9f)
 				return false;
@@ -136,8 +139,13 @@
 			if (owner-&gt;frontdir.dot(goaldir) &lt; maxAngleDif)
 				return false;
 		}
-		if (avoidFriendly &amp;&amp; helper-&gt;TestCone(weaponMuzzlePos, dir, length, (accuracy + sprayangle), owner-&gt;allyteam, owner))
+
+		if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, (accuracy + sprayangle), owner-&gt;allyteam, owner)) {
 			return false;
+		}
+		if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, (accuracy + sprayangle), owner)) {
+			return false;
+		}
 	}
 	return true;
 }

Modified: trunk/rts/Sim/Weapons/PlasmaRepulser.cpp
===================================================================
--- trunk/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -88,6 +88,9 @@
 	rechargeDelay -= (rechargeDelay &gt; 0) ? 1 : 0;
 	
 	if (startShowingShield) {
+		// one-time iteration when shield first goes online
+		// (adds the projectile parts, this assumes owner is
+		// not mobile)
 		startShowingShield = false;
 		if (couldBeVisible) {
 			// 32 parts
@@ -151,7 +154,7 @@
 				if (gs-&gt;Team(owner-&gt;team)-&gt;energy &gt; weaponDef-&gt;shieldEnergyUse) {
 					rechargeDelay = defRechargeDelay;
 					if (weaponDef-&gt;shieldRepulser) {
-					  // bounce the projectile
+						// bounce the projectile
 						const int type = (*pi)-&gt;ShieldRepulse(this, weaponPos,
 						                                      weaponDef-&gt;shieldForce,
 						                                      weaponDef-&gt;shieldMaxSpeed);

Modified: trunk/rts/Sim/Weapons/Rifle.cpp
===================================================================
--- trunk/rts/Sim/Weapons/Rifle.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/Rifle.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -48,33 +48,40 @@
 	CWeapon::Update();
 }
 
-bool CRifle::TryTarget(const float3 &amp;pos,bool userTarget,CUnit* unit)
+bool CRifle::TryTarget(const float3 &amp;pos, bool userTarget, CUnit* unit)
 {
-	if(!CWeapon::TryTarget(pos,userTarget,unit))
+	if (!CWeapon::TryTarget(pos, userTarget, unit))
 		return false;
 
-	if(unit){
-		if(unit-&gt;isUnderWater)
+	if (unit) {
+		if (unit-&gt;isUnderWater)
 			return false;
 	} else {
-		if(pos.y&lt;0)
+		if (pos.y &lt; 0)
 			return false;
 	}
 
-	float3 dir=pos-weaponMuzzlePos;
-	float length=dir.Length();
-	if(length==0)
+	float3 dir = pos - weaponMuzzlePos;
+	float length = dir.Length();
+	if (length == 0)
 		return true;
 
-	dir/=length;
+	dir /= length;
 
-	float g=ground-&gt;LineGroundCol(weaponMuzzlePos,pos);
-	if(g&gt;0 &amp;&amp; g&lt;length*0.9f)
+	float g = ground-&gt;LineGroundCol(weaponMuzzlePos, pos);
+	if (g &gt; 0 &amp;&amp; g &lt; length * 0.9f)
 		return false;
 
-	if(helper-&gt;TestCone(weaponMuzzlePos,dir,length,(accuracy+sprayangle)*(1-owner-&gt;limExperience*0.9f),owner-&gt;allyteam,owner)){
+	float spread = (accuracy + sprayangle) * (1 - owner-&gt;limExperience * 0.9f);
+
+	if (helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, spread, owner-&gt;allyteam, owner)) {
+		// note: check avoidFriendly?
 		return false;
 	}
+	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, spread, owner)) {
+		return false;
+	}
+
 	return true;
 }
 

Modified: trunk/rts/Sim/Weapons/StarburstLauncher.cpp
===================================================================
--- trunk/rts/Sim/Weapons/StarburstLauncher.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/StarburstLauncher.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -64,22 +64,27 @@
 		sound-&gt;PlaySample(fireSoundId,owner,fireSoundVolume);
 }
 
-bool CStarburstLauncher::TryTarget(const float3&amp; pos,bool userTarget,CUnit* unit)
+bool CStarburstLauncher::TryTarget(const float3&amp; pos, bool userTarget, CUnit* unit)
 {
-	if(!CWeapon::TryTarget(pos,userTarget,unit))
+	if (!CWeapon::TryTarget(pos, userTarget, unit))
 		return false;
 
-	if(unit){
-		if(unit-&gt;isUnderWater &amp;&amp; !weaponDef-&gt;waterweapon)
+	if (unit) {
+		if (unit-&gt;isUnderWater &amp;&amp; !weaponDef-&gt;waterweapon)
 			return false;
 	} else {
-		if(pos.y&lt;0 &amp;&amp; !weaponDef-&gt;waterweapon)
+		if (pos.y &lt; 0 &amp;&amp; !weaponDef-&gt;waterweapon)
 			return false;
 	}
 
-	if(avoidFriendly &amp;&amp; helper-&gt;TestCone(weaponMuzzlePos,
-			(weaponDef-&gt;fixedLauncher ? weaponDir : UpVector), 100, 0, owner-&gt;allyteam, owner))
+	if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos,
+		(weaponDef-&gt;fixedLauncher? weaponDir: UpVector), 100, 0, owner-&gt;allyteam, owner)) {
 		return false;
+	}
+	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos,
+		(weaponDef-&gt;fixedLauncher? weaponDir: UpVector), 100, 0, owner)) {
+		return false;
+	}
 
 	return true;
 }

Modified: trunk/rts/Sim/Weapons/TorpedoLauncher.cpp
===================================================================
--- trunk/rts/Sim/Weapons/TorpedoLauncher.cpp	2008-04-05 13:21:05 UTC (rev 5665)
+++ trunk/rts/Sim/Weapons/TorpedoLauncher.cpp	2008-04-05 14:15:29 UTC (rev 5666)
@@ -58,14 +58,12 @@
 //	}
 	float3 startSpeed;
 	if (!weaponDef-&gt;fixedLauncher) {
-		startSpeed=dir*weaponDef-&gt;startvelocity;
+		startSpeed = dir * weaponDef-&gt;startvelocity;
 	}
 	else {
-		startSpeed=weaponDir*weaponDef-&gt;startvelocity;
+		startSpeed = weaponDir * weaponDef-&gt;startvelocity;
 	}
 
-//	if(onlyForward)
-//		startSpeed+=owner-&gt;speed*0.5f;
 	SAFE_NEW CTorpedoProjectile(weaponMuzzlePos, startSpeed, owner, areaOfEffect, projectileSpeed,
 		tracking, weaponDef-&gt;flighttime == 0? (int) (range / projectileSpeed + 25): weaponDef-&gt;flighttime,
 		targetUnit, weaponDef);
@@ -74,28 +72,35 @@
 		sound-&gt;PlaySample(fireSoundId, owner, fireSoundVolume);
 }
 
-bool CTorpedoLauncher::TryTarget(const float3&amp; pos,bool userTarget,CUnit* unit)
+bool CTorpedoLauncher::TryTarget(const float3&amp; pos, bool userTarget, CUnit* unit)
 {
-	if(!CWeapon::TryTarget(pos,userTarget,unit))
+	if (!CWeapon::TryTarget(pos, userTarget, unit))
 		return false;
 
-	if(unit){
-		if(!(weaponDef-&gt;submissile) &amp;&amp; unit-&gt;unitDef-&gt;canhover)
+	if (unit) {
+		if (!(weaponDef-&gt;submissile) &amp;&amp; unit-&gt;unitDef-&gt;canhover)
 			return false;
-		if(!(weaponDef-&gt;submissile) &amp;&amp; unit-&gt;unitDef-&gt;canfly &amp;&amp; unit-&gt;pos.y&gt;0)
+		if (!(weaponDef-&gt;submissile) &amp;&amp; unit-&gt;unitDef-&gt;canfly &amp;&amp; unit-&gt;pos.y &gt; 0)
 			return false;
 	}
-	if(!(weaponDef-&gt;submissile) &amp;&amp; ground-&gt;GetHeight2(pos.x,pos.z)&gt;0)
+	if (!(weaponDef-&gt;submissile) &amp;&amp; ground-&gt;GetHeight2(pos.x, pos.z) &gt; 0)
 		return 0;
 
-	float3 dir=pos-weaponMuzzlePos;
-	float length=dir.Length();
-	if(length==0)
+	float3 dir = pos-weaponMuzzlePos;
+	float length = dir.Length();
+	if (length == 0)
 		return true;
 
-	dir/=length;
+	dir /= length;
+	// +0.05f since torpedoes have an unfortunate tendency to hit own ships due to movement
+	float spread = (accuracy + sprayangle) + 0.05f;
 
-	if(avoidFriendly &amp;&amp; helper-&gt;TestCone(weaponMuzzlePos,dir,length,(accuracy+sprayangle)+0.05f,owner-&gt;allyteam,owner))	//+0.05f since torpedoes has an unfortunate tendency to hit own ships due to movement
+	if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, spread, owner-&gt;allyteam, owner)) {
 		return false;
+	}
+	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, spread, owner)) {
+		return false;
+	}
+
 	return true;
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000446.html">[Taspring-linux-commit] r5665 - in trunk/rts/System: . Net
</A></li>
	<LI>Next message: <A HREF="000448.html">[Taspring-linux-commit] r5667 - in trunk: rts/Game rts/System	rts/System/Net tools/DedicatedServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#447">[ date ]</a>
              <a href="thread.html#447">[ thread ]</a>
              <a href="subject.html#447">[ subject ]</a>
              <a href="author.html#447">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
