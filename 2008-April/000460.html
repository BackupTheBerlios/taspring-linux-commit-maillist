<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5679 - trunk/rts/ExternalAI
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5679%20-%20trunk/rts/ExternalAI&In-Reply-To=%3C20080408123359.D237A4682%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000459.html">
   <LINK REL="Next"  HREF="000461.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5679 - trunk/rts/ExternalAI</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5679%20-%20trunk/rts/ExternalAI&In-Reply-To=%3C20080408123359.D237A4682%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5679 - trunk/rts/ExternalAI">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Tue Apr  8 14:33:59 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000459.html">[Taspring-linux-commit] r5678 - trunk/rts/Sim/Path
</A></li>
        <LI>Next message: <A HREF="000461.html">[Taspring-linux-commit] r5680 - trunk/AI/Global/KAIK-0.13
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#460">[ date ]</a>
              <a href="thread.html#460">[ thread ]</a>
              <a href="subject.html#460">[ subject ]</a>
              <a href="author.html#460">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-04-08 14:33:59 +0200 (Tue, 08 Apr 2008)
New Revision: 5679

Modified:
   trunk/rts/ExternalAI/AICallback.cpp
   trunk/rts/ExternalAI/AICallback.h
   trunk/rts/ExternalAI/IAICallback.h
Log:
add some callbacks to the global AI interface for dealing with neutral units

Modified: trunk/rts/ExternalAI/AICallback.cpp
===================================================================
--- trunk/rts/ExternalAI/AICallback.cpp	2008-04-07 19:05:19 UTC (rev 5678)
+++ trunk/rts/ExternalAI/AICallback.cpp	2008-04-08 12:33:59 UTC (rev 5679)
@@ -542,6 +542,23 @@
 	return 0;
 }
 
+bool CAICallback::IsUnitNeutral(int unitid) {
+	verify();
+
+	if (CHECK_UNITID(unitid)) {
+		CUnit* unit = uh-&gt;units[unitid];
+
+		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
+			if ((gs-&gt;useLuaGaia &amp;&amp; unit-&gt;team == gs-&gt;gaiaTeamID) || (unit-&gt;team == MAX_TEAMS - 1))
+				return true;
+			if (unit-&gt;neutral)
+				return true;
+		}
+	}
+
+	return 0;
+}
+
 int CAICallback::InitPath(float3 start,float3 end,int pathType)
 {
 	return pathManager-&gt;RequestPath(moveinfo-&gt;moveData.at(pathType),start,end);
@@ -557,90 +574,159 @@
 	pathManager-&gt;DeletePath(pathid);
 }
 
-float CAICallback::GetPathLength(float3 start,float3 end,int pathType)
+float CAICallback::GetPathLength(float3 start, float3 end, int pathType)
 {
-//	return pathfinder-&gt;GetPathLength(start,end,pathType);
+	// return pathfinder-&gt;GetPathLength(start, end, pathType);
 	return 0;
 }
 
-int CAICallback::GetEnemyUnits(int *units)
+
+
+
+int CAICallback::GetEnemyUnits(int* units)
 {
+	verify();
 	list&lt;CUnit*&gt;::iterator ui;
-	int a=0;
+	int a = 0;
 
-	verify ();
-	for(list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();++ui){
-		if(!gs-&gt;Ally((*ui)-&gt;allyteam,gs-&gt;AllyTeam(team)) &amp;&amp; ((*ui)-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
-			units[a++]=(*ui)-&gt;id;
+	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
+			if (!IsUnitNeutral(u-&gt;id)) {
+				units[a++] = u-&gt;id;
+			}
 		}
 	}
+
 	return a;
 }
 
-
-int CAICallback::GetEnemyUnitsInRadarAndLos(int *units)
+int CAICallback::GetEnemyUnitsInRadarAndLos(int* units)
 {
+	verify();
 	list&lt;CUnit*&gt;::iterator ui;
-	int a=0;
+	int a = 0;
 
-	verify ();
-	for(list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();++ui){
-		if(!gs-&gt;Ally((*ui)-&gt;allyteam,gs-&gt;AllyTeam(team)) &amp;&amp; ((*ui)-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INLOS|LOS_INRADAR))){
-			units[a++]=(*ui)-&gt;id;
+	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INLOS | LOS_INRADAR))) {
+			if (!IsUnitNeutral(u-&gt;id)) {
+				units[a++] = u-&gt;id;
+			}
 		}
 	}
+
 	return a;
 }
 
+int CAICallback::GetEnemyUnits(int* units, const float3&amp; pos, float radius)
+{
+	verify();
+	vector&lt;CUnit*&gt; unit = qf-&gt;GetUnitsExact(pos, radius);
+	vector&lt;CUnit*&gt;::iterator ui;
+	int a = 0;
 
-int CAICallback::GetEnemyUnits(int *units,const float3&amp; pos,float radius)
+	for (ui = unit.begin(); ui != unit.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
+			if (!IsUnitNeutral(u-&gt;id)) {
+				units[a] = u-&gt;id;
+				++a;
+			}
+		}
+	}
+
+	return a;
+}
+
+
+int CAICallback::GetFriendlyUnits(int *units)
 {
-	verify ();
-	vector&lt;CUnit*&gt; unit=qf-&gt;GetUnitsExact(pos,radius);
+	verify();
+	int a = 0;
 
+	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team))) {
+			// IsUnitNeutral does a LOS check, but inconsequential
+			// since we can always see friendly units anyway
+			if (!IsUnitNeutral(u-&gt;id)) {
+				units[a++] = u-&gt;id;
+			}
+		}
+	}
+
+	return a;
+}
+
+int CAICallback::GetFriendlyUnits(int *units, const float3&amp; pos, float radius)
+{
+	verify();
+	vector&lt;CUnit*&gt; unit = qf-&gt;GetUnitsExact(pos, radius);
 	vector&lt;CUnit*&gt;::iterator ui;
-	int a=0;
+	int a = 0;
 
-	for(ui=unit.begin();ui!=unit.end();++ui){
-		if(!gs-&gt;Ally((*ui)-&gt;allyteam,gs-&gt;AllyTeam(team)) &amp;&amp; ((*ui)-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
-			units[a]=(*ui)-&gt;id;
-			++a;
+	for (ui = unit.begin(); ui != unit.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team))) {
+			// IsUnitNeutral does a LOS check, but inconsequential
+			// since we can always see friendly units anyway
+			if (!IsUnitNeutral(u-&gt;id)) {
+				units[a] = u-&gt;id;
+				++a;
+			}
 		}
 	}
+
 	return a;
 }
 
-int CAICallback::GetFriendlyUnits(int *units)
+
+int CAICallback::GetNeutralUnits(int* units)
 {
-	int a=0;
+	verify();
+	int a = 0;
 
-	verify ();
-	for(list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();++ui){
-		if(gs-&gt;Ally((*ui)-&gt;allyteam,gs-&gt;AllyTeam(team))){
-			units[a++]=(*ui)-&gt;id;
+	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+		CUnit* u = *ui;
+
+		// IsUnitNeutral does the LOS check
+		if (IsUnitNeutral(u-&gt;id)) {
+			units[a++] = u-&gt;id;
 		}
 	}
+
 	return a;
 }
 
-int CAICallback::GetFriendlyUnits(int *units,const float3&amp; pos,float radius)
+int CAICallback::GetNeutralUnits(int* units, const float3&amp; pos, float radius)
 {
-	verify ();
-	vector&lt;CUnit*&gt; unit=qf-&gt;GetUnitsExact(pos,radius);
-
+	verify();
+	vector&lt;CUnit*&gt; unit = qf-&gt;GetUnitsExact(pos, radius);
 	vector&lt;CUnit*&gt;::iterator ui;
-	int a=0;
+	int a = 0;
 
-	for(ui=unit.begin();ui!=unit.end();++ui){
-		if(gs-&gt;Ally((*ui)-&gt;allyteam,gs-&gt;AllyTeam(team))){
-			units[a]=(*ui)-&gt;id;
+	for (ui = unit.begin(); ui != unit.end(); ++ui) {
+		CUnit* u = *ui;
+
+		// IsUnitNeutral does the LOS check
+		if (IsUnitNeutral(u-&gt;id)) {
+			units[a] = u-&gt;id;
 			++a;
 		}
 	}
+
 	return a;
 }
 
 
+
+
 int CAICallback::GetMapWidth()
 {
 	return gs-&gt;mapx;

Modified: trunk/rts/ExternalAI/AICallback.h
===================================================================
--- trunk/rts/ExternalAI/AICallback.h	2008-04-07 19:05:19 UTC (rev 5678)
+++ trunk/rts/ExternalAI/AICallback.h	2008-04-08 12:33:59 UTC (rev 5679)
@@ -6,18 +6,18 @@
 class CGroupHandler;
 class CGroup;
 
-class CAICallback : public IAICallback
+class CAICallback: public IAICallback
 {
 public:
-	CAICallback (int Team, CGroupHandler *GH);
-	~CAICallback ();
+	CAICallback(int Team, CGroupHandler* GH);
+	~CAICallback();
 
 	int team;
 	bool noMessages;
-	CGroupHandler *gh;
-	CGroup *group; // only in case it's a group AI
+	CGroupHandler* gh;
+	CGroup* group; // only in case it's a group AI
 
-	void verify ();
+	void verify();
 
 	void SendStartPos(bool ready, float3 pos);
 	void SendTextMsg(const char* text, int zone);
@@ -25,63 +25,62 @@
 	void AddNotification(float3 pos, float3 color, float alpha);
 	bool PosInCamera(float3 pos, float radius);
 
-//get the current game time, there is 30 frames per second at normal speed
 	int GetCurrentFrame();
 	int GetMyTeam();
 	int GetMyAllyTeam();
 	int GetPlayerTeam(int player);
 	const char* GetTeamSide(int team);
-	// returns the size of the created area, this is initialized to all 0 if not previously created
-	//set something to !0 to tell other ais that the area is already initialized when they try to create it
-	//the exact internal format of the memory areas is up to the ais to keep consistent
 	void* CreateSharedMemArea(char* name, int size);
-	//release your reference to a memory area.
 	void ReleasedSharedMemArea(char* name);
 
-	int CreateGroup(char* dll,unsigned aiNumber);							//creates a group and return the id it was given, return -1 on failure (dll didnt exist etc)
-	void EraseGroup(int groupid);											//erases a specified group
-	bool AddUnitToGroup(int unitid,int groupid);		//adds a unit to a specific group, if it was previously in a group its removed from that, return false if the group didnt exist or didnt accept the unit
-	bool RemoveUnitFromGroup(int unitid);						//removes a unit from its group
-	int GetUnitGroup(int unitid);										//returns the group a unit belongs to, -1 if no group
-	const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid);	//the commands that this unit can understand, other commands will be ignored
+	int CreateGroup(char* dll, unsigned aiNumber);
+	void EraseGroup(int groupid);
+	bool AddUnitToGroup(int unitid, int groupid);
+	bool RemoveUnitFromGroup(int unitid);
+	int GetUnitGroup(int unitid);
+	const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid);
 	int GiveGroupOrder(int unitid, Command* c);
 
 	int GiveOrder(int unitid,Command* c);
 	const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid);
 	const CCommandQueue* GetCurrentUnitCommands(int unitid);
 
-	int GetUnitAiHint(int unitid);				//integer telling something about the units main function, not implemented yet
+	int GetUnitAiHint(int unitid);
 	int GetUnitTeam(int unitid);
 	int GetUnitAllyTeam(int unitid);
-	float GetUnitHealth(int unitid);			//the units current health
-	float GetUnitMaxHealth(int unitid);		//the units max health
-	float GetUnitSpeed(int unitid);				//the units max speed
-	float GetUnitPower(int unitid);				//sort of the measure of the units overall power
-	float GetUnitExperience(int unitid);	//how experienced the unit is (0.0-1.0)
-	float GetUnitMaxRange(int unitid);		//the furthest any weapon of the unit can fire
+	float GetUnitHealth(int unitid);
+	float GetUnitMaxHealth(int unitid);
+	float GetUnitSpeed(int unitid);
+	float GetUnitPower(int unitid);
+	float GetUnitExperience(int unitid);
+	float GetUnitMaxRange(int unitid);
 	bool IsUnitActivated (int unitid);
-	bool UnitBeingBuilt(int unitid);			//returns true if the unit is currently being built
-	const UnitDef* GetUnitDef(int unitid);	//this returns the units unitdef struct from which you can read all the statistics of the unit, dont try to change any values in it, dont use this if you dont have to risk of changes in it
+	bool UnitBeingBuilt(int unitid);
+	const UnitDef* GetUnitDef(int unitid);
 	float3 GetUnitPos(int unitid);
-	int GetBuildingFacing(int unitid);		//returns building facing (0-3)
+	int GetBuildingFacing(int unitid);
 	bool IsUnitCloaked(int unitid);
 	bool IsUnitParalyzed(int unitid);
+	bool IsUnitNeutral(int unitid);
 	bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
 
 	const UnitDef* GetUnitDef(const char* unitName);
 
-	int InitPath(float3 start,float3 end,int pathType);
+	int InitPath(float3 start, float3 end, int pathType);
 	float3 GetNextWaypoint(int pathid);
 	void FreePath(int pathid);
 
-	float GetPathLength(float3 start,float3 end,int pathType);
+	float GetPathLength(float3 start, float3 end, int pathType);
 
-	int GetEnemyUnits(int *units);					//returns all known enemy units
-	int GetEnemyUnitsInRadarAndLos(int *units);
-	int GetEnemyUnits(int *units,const float3&amp; pos,float radius); //returns all known enemy units within radius from pos
-	int GetFriendlyUnits(int *units);					//returns all friendly units
-	int GetFriendlyUnits(int *units,const float3&amp; pos,float radius); //returns all friendly units within radius from pos
+	int GetEnemyUnits(int* units);
+	int GetEnemyUnitsInRadarAndLos(int* units);
+	int GetEnemyUnits(int* units, const float3&amp; pos,float radius);
+	int GetFriendlyUnits(int* units);
+	int GetFriendlyUnits(int* units, const float3&amp; pos,float radius);
+	int GetNeutralUnits(int* units);
+	int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
 
+
 	int GetMapWidth();
 	int GetMapHeight();
 	const float* GetHeightMap();
@@ -89,10 +88,10 @@
 	float GetMaxHeight();
 	const float* GetSlopeMap();
 	const unsigned short* GetLosMap();
-	const unsigned short* GetRadarMap();		//a square with value zero means you dont have radar to the square, this is 1/8 the resolution of the standard map
-	const unsigned short* GetJammerMap();		//a square with value zero means you dont have radar jamming on the square, this is 1/8 the resolution of the standard map
-	const unsigned char* GetMetalMap();			//this map shows the metal density on the map, this is half the resolution of the standard map
-	const char *GetMapName ();
+	const unsigned short* GetRadarMap();
+	const unsigned short* GetJammerMap();
+	const unsigned char* GetMetalMap();
+	const char* GetMapName ();
 	const char* GetModName();
 
 	float GetMaxMetal();
@@ -102,7 +101,7 @@
 	float GetTidalStrength();
 	float GetGravity();
 
-	float GetElevation(float x,float z);
+	float GetElevation(float x, float z);
 
 	void LineDrawerStartPath(const float3&amp; pos, const float* color);
 	void LineDrawerFinishPath();
@@ -113,59 +112,59 @@
 	void LineDrawerRestart();
 	void LineDrawerRestartSameColor();
 
-	int CreateSplineFigure(float3 pos1,float3 pos2,float3 pos3,float3 pos4,float width,int arrow,int lifetime,int group);
-	int CreateLineFigure(float3 pos1,float3 pos2,float width,int arrow,int lifetime,int group);
-	void SetFigureColor(int group,float red,float green,float blue,float alpha);
+	int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group);
+	int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group);
+	void SetFigureColor(int group,float red, float green, float blue, float alpha);
 	void DeleteFigureGroup(int group);
 
-	void DrawUnit(const char* name,float3 pos,float rotation,int lifetime,int team,bool transparent,bool drawBorder,int facing);
+	void DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing);
 
-	bool CanBuildAt(const UnitDef* unitDef,float3 pos, int facing);
-	float3 ClosestBuildSite(const UnitDef* unitdef,float3 pos,float searchRadius,int minDist, int facing);	//returns the closest position from a position that the building can be built, minDist is the distance in squares that the building must keep to other buildings (to make it easier to create paths through a base)
+	bool CanBuildAt(const UnitDef* unitDef, float3 pos, int facing);
+	float3 ClosestBuildSite(const UnitDef* unitdef, float3 pos, float searchRadius, int minDist, int facing);
 
-	float GetMetal();				//stored metal for team
+	float GetMetal();
 	float GetMetalIncome();
 	float GetMetalUsage();
-	float GetMetalStorage();				//metal storage for team
+	float GetMetalStorage();
 
-	float GetEnergy();				//stored energy for team
+	float GetEnergy();
 	float GetEnergyIncome();
 	float GetEnergyUsage();
-	float GetEnergyStorage();				//energy storage for team
+	float GetEnergyStorage();
 
-	int GetFeatures (int *features, int max);
-	int GetFeatures (int *features, int max, const float3&amp; pos, float radius);
+	int GetFeatures(int* features, int max);
+	int GetFeatures(int* features, int max, const float3&amp; pos, float radius);
 	const FeatureDef* GetFeatureDef (int feature);
-	float GetFeatureHealth (int feature);
-	float GetFeatureReclaimLeft (int feature);
+	float GetFeatureHealth(int feature);
+	float GetFeatureReclaimLeft(int feature);
 	float3 GetFeaturePos (int feature);
 
-	// future callback extensions
-	bool GetProperty(int unit, int property, void *dst);
-	bool GetValue(int id, void *dst);
-	int HandleCommand(int commandId, void *data);
+	bool GetProperty(int unit, int property, void* dst);
+	bool GetValue(int id, void* dst);
+	int HandleCommand(int commandId, void* data);
 
-	int GetFileSize (const char *name); // return -1 when the file doesn't exist
-	bool ReadFile (const char *name, void *buffer,int bufferLen); // returns false when file doesn't exist or buffer is too small
-	int GetFileSize (const char *name, const char* modes); // return -1 when the file doesn't exist
-	bool ReadFile (const char *name, const char* modes, void *buffer,int bufferLen); // returns false when file doesn't exist or buffer is too small
+	int GetFileSize(const char* name);
+	bool ReadFile(const char* name, void* buffer,int bufferLen);
+	int GetFileSize(const char* name, const char* modes);
+	bool ReadFile(const char* name, const char* modes, void* buffer, int bufferLen);
 
 	int GetNumUnitDefs();
 	void GetUnitDefList (const UnitDef** list);
 
-	int GetSelectedUnits(int *units);
+	int GetSelectedUnits(int* units);
 	float3 GetMousePos();
-	int GetMapPoints(PointMarker *pm, int maxPoints);
-	int GetMapLines(LineMarker *lm, int maxLines);
+	int GetMapPoints(PointMarker* pm, int maxPoints);
+	int GetMapLines(LineMarker* lm, int maxLines);
 
 	float GetUnitDefRadius(int def);
 	float GetUnitDefHeight(int def);
 
 	const WeaponDef* GetWeapon(const char* weaponname);
 
-	bool CanBuildUnit(int unitDefID);  //return false if a unit cannot currently be created
+	// false if a unit cannot currently be created
+	bool CanBuildUnit(int unitDefID);
 
-	virtual const float3 *GetStartPos();
+	virtual const float3* GetStartPos();
 
 	// NOTES:
 	// 1. 'data' can be NULL to skip passing in a string

Modified: trunk/rts/ExternalAI/IAICallback.h
===================================================================
--- trunk/rts/ExternalAI/IAICallback.h	2008-04-07 19:05:19 UTC (rev 5678)
+++ trunk/rts/ExternalAI/IAICallback.h	2008-04-08 12:33:59 UTC (rev 5679)
@@ -12,8 +12,7 @@
 struct WeaponDef;
 class CCommandQueue;
 
-// GetProperty() constants
-                            // Data buffer will be filled with this:
+// GetProperty() constants ------------ data type that buffer will be filled with:
 #define AIVAL_UNITDEF					1 // const UnitDef*
 #define AIVAL_CURRENT_FUEL				2 // float
 #define AIVAL_STOCKPILED				3 // int
@@ -21,22 +20,22 @@
 #define AIVAL_UNIT_MAXSPEED				5 // float
 
 // GetValue() constants
-#define AIVAL_NUMDAMAGETYPES              1 // int
-#define AIVAL_EXCEPTION_HANDLING          2 // bool
-#define AIVAL_MAP_CHECKSUM                3 // unsinged int
-#define AIVAL_DEBUG_MODE                  4 // bool
-#define AIVAL_GAME_MODE                   5 // int
-#define AIVAL_GAME_PAUSED                 6 // bool
-#define AIVAL_GAME_SPEED_FACTOR           7 // float
-#define AIVAL_GUI_VIEW_RANGE              8 // float
-#define AIVAL_GUI_SCREENX                 9 // float
-#define AIVAL_GUI_SCREENY                10 // float
-#define AIVAL_GUI_CAMERA_DIR             11 // float3
-#define AIVAL_GUI_CAMERA_POS             12 // float3
-#define AIVAL_LOCATE_FILE_R              15 // char*
-#define AIVAL_LOCATE_FILE_W              16 // char*
-#define AIVAL_UNIT_LIMIT                 17 // int
-#define AIVAL_SCRIPT                     18 // const char* - buffer for pointer to char
+#define AIVAL_NUMDAMAGETYPES			1 // int
+#define AIVAL_EXCEPTION_HANDLING		2 // bool
+#define AIVAL_MAP_CHECKSUM				3 // unsinged int
+#define AIVAL_DEBUG_MODE				4 // bool
+#define AIVAL_GAME_MODE					5 // int
+#define AIVAL_GAME_PAUSED				6 // bool
+#define AIVAL_GAME_SPEED_FACTOR			7 // float
+#define AIVAL_GUI_VIEW_RANGE			8 // float
+#define AIVAL_GUI_SCREENX				9 // float
+#define AIVAL_GUI_SCREENY				10 // float
+#define AIVAL_GUI_CAMERA_DIR			11 // float3
+#define AIVAL_GUI_CAMERA_POS			12 // float3
+#define AIVAL_LOCATE_FILE_R				15 // char*
+#define AIVAL_LOCATE_FILE_W				16 // char*
+#define AIVAL_UNIT_LIMIT				17 // int
+#define AIVAL_SCRIPT					18 // const char* - buffer for pointer to char
 
 struct UnitResourceInfo
 {
@@ -70,7 +69,7 @@
 struct AIHCAddMapPoint ///&lt; result of HandleCommand is 1 - ok supported
 {
 	float3 pos; ///&lt; on this position, only x and z matter
-	char *label; ///&lt; create this text on pos in my team color
+	char* label; ///&lt; create this text on pos in my team color
 };
 
 struct AIHCAddMapLine ///&lt; result of HandleCommand is 1 - ok supported
@@ -97,27 +96,31 @@
 	virtual void SendTextMsg(const char* text, int zone) = 0;
 	virtual void SetLastMsgPos(float3 pos) = 0;
 	virtual void AddNotification(float3 pos, float3 color, float alpha) = 0;
-	virtual bool PosInCamera(float3 pos, float radius) = 0;	// checks if pos is within view of the current camera, using radius as a margin
+	// checks if pos is within view of the current camera, using radius as a margin
+	virtual bool PosInCamera(float3 pos, float radius) = 0;
 
-	//get the current game time, there is 30 frames per second at normal speed
+	// get the current game time, there are 30 frames per second at normal speed
 	virtual int GetCurrentFrame() = 0;
-	virtual int GetMyTeam()=0;
-	virtual int GetMyAllyTeam()=0;
+	virtual int GetMyTeam() = 0;
+	virtual int GetMyAllyTeam() = 0;
 	virtual int GetPlayerTeam(int player) = 0;
 	virtual const char* GetTeamSide(int team) = 0;
 	// returns the size of the created area, this is initialized to all 0 if not previously created
-	//set something to !0 to tell other ais that the area is already initialized when they try to create it
-	//the exact internal format of the memory areas is up to the ais to keep consistent
-	virtual void* CreateSharedMemArea(char* name, int size)=0;
-	//release your reference to a memory area.
-	virtual void ReleasedSharedMemArea(char* name)=0;
+	// set something to !0 to tell other AI's that the area is already initialized when they try to
+	// create it (the exact internal format of the memory areas is up to the AI's to keep consistent)
+	virtual void* CreateSharedMemArea(char* name, int size) = 0;
+	// release your reference to a memory area
+	virtual void ReleasedSharedMemArea(char* name) = 0;
 
-	virtual int CreateGroup(char* dll,unsigned aiNumber) = 0;				//creates a group and return the id it was given, return -1 on failure (dll didnt exist etc)
-	virtual void EraseGroup(int groupid) = 0;											//erases a specified group
-	virtual bool AddUnitToGroup(int unitid,int groupid) = 0;		//adds a unit to a specific group, if it was previously in a group its removed from that, return false if the group didnt exist or didnt accept the unit
-	virtual bool RemoveUnitFromGroup(int unitid) = 0;						//removes a unit from its group
-	virtual int GetUnitGroup(int unitid) = 0;										//returns the group a unit belongs to, -1 if no group
-	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid) = 0;	//the commands that this unit can understand, other commands will be ignored
+	virtual int CreateGroup(char* dll, unsigned aiNumber) = 0;							// creates a group and return the id it was given, return -1 on
+																						// failure (dll didn't exist, etc)
+	virtual void EraseGroup(int groupid) = 0;											// erases a specified group
+	virtual bool AddUnitToGroup(int unitid, int groupid) = 0;							// adds a unit to a specific group, if it was previously in a group
+																						// it is removed from that, return false if the group didn't exist
+																						// or didn't accept the unit
+	virtual bool RemoveUnitFromGroup(int unitid) = 0;									// removes a unit from its group
+	virtual int GetUnitGroup(int unitid) = 0;											// returns the group a unit belongs to, -1 if none
+	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid) = 0;	// the commands that this unit can understand, other commands will be ignored
 	virtual int GiveGroupOrder(int unitid, Command* c) = 0;
 
 	virtual int GiveOrder(int unitid,Command* c) = 0;
@@ -125,146 +128,162 @@
 	virtual const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid) = 0;
 	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid) = 0;
 
-	virtual int GetUnitAiHint(int unitid) = 0;				//integer telling something about the units main function, not implemented yet
+	// these functions always work on allied units, but for
+	// enemies only when you have LOS on them (so watch out
+	// when calling GetUnitDef)
+	virtual int GetUnitAiHint(int unitid) = 0;				// integer telling something about the units main function, not implemented yet
 	virtual int GetUnitTeam(int unitid) = 0;
 	virtual int GetUnitAllyTeam(int unitid) = 0;
-	virtual float GetUnitHealth(int unitid) = 0;			//the units current health
-	virtual float GetUnitMaxHealth(int unitid) = 0;		//the units max health
-	virtual float GetUnitSpeed(int unitid) = 0;				//the units max speed
-	virtual float GetUnitPower(int unitid) = 0;				//sort of the measure of the units overall power
-	virtual float GetUnitExperience(int unitid) = 0;	//how experienced the unit is (0.0f-1.0f)
-	virtual float GetUnitMaxRange(int unitid) = 0;		//the furthest any weapon of the unit can fire
+	virtual float GetUnitHealth(int unitid) = 0;			// the unit's current health
+	virtual float GetUnitMaxHealth(int unitid) = 0;			// the unit's max health
+	virtual float GetUnitSpeed(int unitid) = 0;				// the unit's max speed
+	virtual float GetUnitPower(int unitid) = 0;				// sort of the measure of the units overall power
+	virtual float GetUnitExperience(int unitid) = 0;		// how experienced the unit is (0.0f-1.0f)
+	virtual float GetUnitMaxRange(int unitid) = 0;			// the furthest any weapon of the unit can fire
 	virtual bool IsUnitActivated (int unitid) = 0;
-	virtual bool UnitBeingBuilt(int unitid) = 0;			//returns true if the unit is currently being built
-	virtual const UnitDef* GetUnitDef(int unitid) = 0;	//this returns the units unitdef struct from which you can read all the statistics of the unit, dont try to change any values in it, dont use this if you dont have to risk of changes in it
+	virtual bool UnitBeingBuilt(int unitid) = 0;			// true if the unit is currently being built
+	virtual const UnitDef* GetUnitDef(int unitid) = 0;		// returns the unit's unitdef struct from which you can read all the
+															// statistics of the unit, do NOT try to change any values in it
 	virtual float3 GetUnitPos(int unitid) = 0;
-	virtual int GetBuildingFacing(int unitid) = 0;		//returns building facing (0-3)
+	virtual int GetBuildingFacing(int unitid) = 0;			// returns the unit's build facing (0-3)
 	virtual bool IsUnitCloaked(int unitid) = 0;
 	virtual bool IsUnitParalyzed(int unitid) = 0;
+	virtual bool IsUnitNeutral(int unitid) = 0;
 	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo) = 0;
 
 	virtual const UnitDef* GetUnitDef(const char* unitName) = 0;
 
-	//the following functions allows the dll to use the built in pathfinder
-	//call InitPath and you get a pathid back
-	//use this to call GetNextWaypoint to get subsequent waypoints, the waypoints are centered on 8*8 squares
-	//note that the pathfinder calculates the waypoints as needed so dont retrieve them until they are needed
-	//the waypoints x and z coordinate is returned in x and z while y is used for error codes
-	//&gt;=0 =worked ok,-2=still thinking call again,-1= end of path reached or invalid path
-	virtual int InitPath(float3 start,float3 end,int pathType) = 0;
+	// the following functions allow the dll to use the built-in pathfinder
+	// * call InitPath and you get a pathid back
+	// * use this to call GetNextWaypoint to get subsequent waypoints, the waypoints are centered on 8*8 squares
+	// * note that the pathfinder calculates the waypoints as needed so don't retrieve them until they are needed
+	// * the waypoint's x and z coordinates are returned in x and z while y is used for error codes
+	//   y &gt;= 0: worked ok, y = -2: still thinking call again, y = -1: end of path reached or invalid path
+	virtual int InitPath(float3 start, float3 end, int pathType) = 0;
 	virtual float3 GetNextWaypoint(int pathid) = 0;
 	virtual void FreePath(int pathid) = 0;
 
-	//This function returns the approximate path cost between two points(note that it needs to calculate the complete path so its somewhat expansive)
-	virtual float GetPathLength(float3 start,float3 end,int pathType)=0;
+	// returns the approximate path cost between two points(note that
+	// it needs to calculate the complete path so somewhat expensive)
+	// note: currently disabled, always returns 0
+	virtual float GetPathLength(float3 start, float3 end, int pathType) = 0;
 
-	//the following function return the units into arrays that must be allocated by the dll
-	//10000 is currently the max amount of units so that should be a safe size for the array
-	//the return value indicates how many units was returned, the rest of the array is unchanged
-	virtual int GetEnemyUnits(int *units)=0;					//returns all known enemy units (all in los)
-	virtual int GetEnemyUnits(int *units,const float3&amp; pos,float radius)=0; //returns all known enemy units within radius from pos
-	virtual int GetEnemyUnitsInRadarAndLos(int *units)=0;       //returns all enemy units in radar and los
-	virtual int GetFriendlyUnits(int *units)=0;					//returns all friendly units
-	virtual int GetFriendlyUnits(int *units,const float3&amp; pos,float radius)=0; //returns all friendly units within radius from pos
+	// the following function return the units into arrays that must be allocated by the dll
+	// * 10000 is currently the max amount of units so that should be a safe size for the array
+	// * the return value indicates how many units were returned, the rest of the array is unchanged
+	// * all forms of GetEnemyUnits and GetFriendlyUnits filter out any neutrals, use the GetNeutral
+	//   callbacks to retrieve them
+	virtual int GetEnemyUnits(int* units) = 0;										// returns all known (in LOS) enemy units
+	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius) = 0;		// returns all known enemy units within radius from pos
+	virtual int GetEnemyUnitsInRadarAndLos(int* units) = 0;							// returns all enemy units in radar and los
+	virtual int GetFriendlyUnits(int* units) = 0;									// returns all friendly units
+	virtual int GetFriendlyUnits(int* units, const float3&amp; pos, float radius) = 0;	// returns all friendly units within radius from pos
+	virtual int GetNeutralUnits(int* units) = 0;									// returns all known (in LOS) neutral units
+	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius) = 0;	// returns all known neutral units within radius from pos
 
-	//the following functions are used to get information about the map
-	//dont modify or delete any of the pointers returned
-	//the maps are stored from top left and each data position is 8*8 in size
-	//to get info about a position x,y look at location
-	//(int(y/8))*GetMapWidth()+(int(x/8))
-	//some of the maps are stored in a lower resolution than this though
-	virtual int GetMapWidth()=0;
-	virtual int GetMapHeight()=0;
-	virtual const float* GetHeightMap()=0;						//this is the height for the center of the squares, this differs slightly from the drawn map since it uses the height at the corners
-	virtual float GetMinHeight()=0; // readmap-&gt;minHeight
-	virtual float GetMaxHeight()=0; // readmap-&gt;maxHeight
-	virtual const float* GetSlopeMap()=0; // slopemap, half the resolution of the standard map
-	//the values are 1 minus the y component of the (average) facenormal of the square.
-	virtual const unsigned short* GetLosMap()=0;			//a square with value zero means you dont have los to the square, this is half the resolution of the standard map
-	virtual const unsigned short* GetRadarMap()=0;		//a square with value zero means you dont have radar to the square, this is 1/8 the resolution of the standard map
-	virtual const unsigned short* GetJammerMap()=0;		//a square with value zero means you dont have radar jamming on the square, this is 1/8 the resolution of the standard map
-	virtual const unsigned char* GetMetalMap()=0;			//this map shows the metal density on the map, this is half the resolution of the standard map
-	virtual const char* GetMapName()=0;
-	virtual const char* GetModName()=0;
+	// the following functions are used to get information about the map
+	// * do NOT modify or delete any of the pointers returned
+	// * the maps are stored from top left and each data position is 8*8 in size
+	// * to get info about a position (x, y) look at location (int(y / 8)) * GetMapWidth() + (int(x / 8))
+	// * note that some of the maps are stored in a lower resolution than this
+	virtual int GetMapWidth() = 0;
+	virtual int GetMapHeight() = 0;
+	virtual const float* GetHeightMap() = 0;			// this is the height for the center of the squares, this differs slightly from the drawn map since it uses the height at the corners
+	virtual float GetMinHeight() = 0;					// readmap-&gt;minHeight
+	virtual float GetMaxHeight() = 0;					// readmap-&gt;maxHeight
+	virtual const float* GetSlopeMap() = 0;				// slopemap, half the resolution of the standard map (values are 1
+														// minus the y-component of the (average) facenormal of the square)
+	virtual const unsigned short* GetLosMap() = 0;		// a square with value zero means you don't have LOS coverage on it, half the resolution of the standard map
+	virtual const unsigned short* GetRadarMap() = 0;	// a square with value zero means you don't have radar coverage on it, 1/8 the resolution of the standard map
+	virtual const unsigned short* GetJammerMap() = 0;	// a square with value zero means you don't have radar jamming coverage on it, 1/8 the resolution of the standard map
+	virtual const unsigned char* GetMetalMap() = 0;		// this map shows the metal density on the map, half the resolution of the standard map
+	virtual const char* GetMapName() = 0;
+	virtual const char* GetModName() = 0;
 
-	virtual float GetElevation(float x,float z)=0;		//Gets the elevation of the map at position x,z
+	virtual float GetElevation(float x, float z) = 0;	// gets the elevation of the map at position (x, z)
 
-	virtual float GetMaxMetal()=0;			//returns what metal value 255 in the metal map is worth
-	virtual float GetExtractorRadius()=0;			//returns extraction radius for metal extractors
-	virtual float GetMinWind()=0;
-	virtual float GetMaxWind()=0;
-	virtual float GetTidalStrength()=0;
-	virtual float GetGravity()=0;
+	virtual float GetMaxMetal() = 0;					// returns what metal value 255 in the metal map is worth
+	virtual float GetExtractorRadius() = 0;				// returns extraction radius for metal extractors
+	virtual float GetMinWind() = 0;
+	virtual float GetMaxWind() = 0;
+	virtual float GetTidalStrength() = 0;
+	virtual float GetGravity() = 0;
 
-	// the linedrawer interface.
-	// this allows you to draw command-like lines and figures.
-	// use these only from within CGroupAI::DrawCommands()
-	virtual void LineDrawerStartPath(const float3&amp; pos, const float* color)=0;
-	virtual void LineDrawerFinishPath()=0;
-	virtual void LineDrawerDrawLine(const float3&amp; endPos, const float* color)=0;
-	virtual void LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color)=0;
-	virtual void LineDrawerDrawIconAtLastPos(int cmdID)=0;
-	virtual void LineDrawerBreak(const float3&amp; endPos, const float* color)=0;
-	virtual void LineDrawerRestart()=0;
-	virtual void LineDrawerRestartSameColor()=0;
+	// linedrawer interface functions
+	// * these allow you to draw command-like lines and figures
+	// * use these only from within CGroupAI::DrawCommands()
+	virtual void LineDrawerStartPath(const float3&amp; pos, const float* color) = 0;
+	virtual void LineDrawerFinishPath() = 0;
+	virtual void LineDrawerDrawLine(const float3&amp; endPos, const float* color) = 0;
+	virtual void LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color) = 0;
+	virtual void LineDrawerDrawIconAtLastPos(int cmdID) = 0;
+	virtual void LineDrawerBreak(const float3&amp; endPos, const float* color) = 0;
+	virtual void LineDrawerRestart() = 0;
+	virtual void LineDrawerRestartSameColor() = 0;
 
-	//the following functions allow the ai to draw figures in the world
-	//each figure is part of a group
-	//when creating figures use 0 as group to get a new one, the return value is the new group
-	//the lifetime is how many frames a figure should live before being autoremoved, 0 means no removal
-	//arrow!=0 means that the figure will get an arrow at the end
-	virtual int CreateSplineFigure(float3 pos1,float3 pos2,float3 pos3,float3 pos4,float width,int arrow,int lifetime,int group)=0;	//This function creates a cubic beizer spline figure
-	virtual int CreateLineFigure(float3 pos1,float3 pos2,float width,int arrow,int lifetime,int group)=0;
-	virtual void SetFigureColor(int group,float red,float green,float blue,float alpha)=0;
-	virtual void DeleteFigureGroup(int group)=0;
+	// the following functions allow the AI to draw figures in the world
+	// * each figure is part of a group
+	// * when creating figures use 0 as group to get a new one, the return value is the new group
+	// * the lifetime is how many frames a figure should live before being autoremoved, 0 means no removal
+	// * arrow != 0 means that the figure will get an arrow at the end
+	//
+	// creates a cubic Bezier spline figure (from pos1 to pos4 with control points pos2 and pos3)
+	virtual int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group) = 0;
+	virtual int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group) = 0;
+	virtual void SetFigureColor(int group, float red, float green, float blue, float alpha) = 0;
+	virtual void DeleteFigureGroup(int group) = 0;
 
-	//this function allows you to draw units in the map, of course they dont really exist,they just show up on the local players screen
-	//they will be drawn in the standard pose before any scripts are run
-	//the rotation is in radians,team affects the color of the unit
-	virtual void DrawUnit(const char* name,float3 pos,float rotation,int lifetime,int team,bool transparent,bool drawBorder,int facing=0)=0;
+	// this function allows you to draw units in the map
+	// * they only show up on the local player's screen
+	// * they will be drawn in the &quot;standard pose&quot; (as if before any COB scripts are run)
+	// * the rotation is in radians, team affects the color of the unit
+	virtual void DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing = 0) = 0;
 
-	virtual bool CanBuildAt(const UnitDef* unitDef,float3 pos,int facing=0) = 0;
-	virtual float3 ClosestBuildSite(const UnitDef* unitdef,float3 pos,float searchRadius,int minDist,int facing=0) = 0;	//returns the closest position from a position that the building can be built, minDist is the distance in squares that the building must keep to other buildings (to make it easier to create paths through a base)
+	virtual bool CanBuildAt(const UnitDef* unitDef, float3 pos, int facing = 0) = 0;
+	// returns the closest position from a given position that the building can be built at
+	// minDist is the distance in squares that the building must keep to other buildings (to
+	// make it easier to create paths through a base)
+	virtual float3 ClosestBuildSite(const UnitDef* unitdef, float3 pos, float searchRadius, int minDist, int facing = 0) = 0;
 
-	// future callback extensions
-	virtual bool GetProperty(int id, int property, void *dst)=0;
-	virtual bool GetValue(int id, void *dst)=0;
-	virtual int HandleCommand(int commandId, void *data)=0;
+	// for certain future callback extensions
+	virtual bool GetProperty(int id, int property, void* dst) = 0;
+	virtual bool GetValue(int id, void* dst) = 0;
+	virtual int HandleCommand(int commandId, void* data) = 0;
 
-	virtual int GetFileSize (const char *name)=0;// return -1 when the file doesn't exist
-	virtual bool ReadFile (const char *name, void *buffer,int bufferLen)=0;// returns false when file doesn't exist or buffer is too small
+	virtual int GetFileSize(const char* name) = 0;								// return -1 when the file doesn't exist
+	virtual bool ReadFile(const char* name, void* buffer, int bufferLen) = 0;	// returns false when file doesn't exist or buffer is too small
 
 	// added by alik
-	virtual int GetSelectedUnits(int *units)=0;
-	virtual float3 GetMousePos()=0;
-	virtual int GetMapPoints(PointMarker *pm, int maxPoints)=0;
-	virtual int GetMapLines(LineMarker *lm, int maxLines)=0;
+	virtual int GetSelectedUnits(int* units) = 0;
+	virtual float3 GetMousePos() = 0;
+	virtual int GetMapPoints(PointMarker* pm, int maxPoints) = 0;
+	virtual int GetMapLines(LineMarker* lm, int maxLines) = 0;
 
-	virtual float GetMetal() = 0;				//stored metal for team
-	virtual float GetMetalIncome() = 0;
-	virtual float GetMetalUsage() = 0;
-	virtual float GetMetalStorage() = 0;				//metal storage for team
+	virtual float GetMetal() = 0;					// current metal level for team
+	virtual float GetMetalIncome() = 0;				// current metal income for team
+	virtual float GetMetalUsage() = 0;				// current metal usage for team
+	virtual float GetMetalStorage() = 0;			// curent metal storage capacity for team
 
-	virtual float GetEnergy() = 0;				//stored energy for team
-	virtual float GetEnergyIncome() = 0;
-	virtual float GetEnergyUsage() = 0;
-	virtual float GetEnergyStorage() = 0;				//energy storage for team
+	virtual float GetEnergy() = 0;					// current energy level for team
+	virtual float GetEnergyIncome() = 0;			// current energy income for team
+	virtual float GetEnergyUsage() = 0;				// current energy usage for team
+	virtual float GetEnergyStorage() = 0;			// curent energy storage capacity for team
 
-	virtual int GetFeatures (int *features, int max) = 0;
-	virtual int GetFeatures (int *features, int max, const float3&amp; pos, float radius) = 0;
-	virtual const FeatureDef* GetFeatureDef (int feature) = 0;
-	virtual float GetFeatureHealth (int feature) = 0;
-	virtual float GetFeatureReclaimLeft (int feature) = 0;
-	virtual float3 GetFeaturePos (int feature) = 0;
+	virtual int GetFeatures(int *features, int max) = 0;
+	virtual int GetFeatures(int *features, int max, const float3&amp; pos, float radius) = 0;
+	virtual const FeatureDef* GetFeatureDef(int feature) = 0;
+	virtual float GetFeatureHealth(int feature) = 0;
+	virtual float GetFeatureReclaimLeft(int feature) = 0;
+	virtual float3 GetFeaturePos(int feature) = 0;
 
 	virtual int GetNumUnitDefs() = 0;
-	virtual void GetUnitDefList (const UnitDef** list) = 0;
-	virtual float GetUnitDefHeight(int def) = 0; // forces loading of the unit model
-	virtual float GetUnitDefRadius(int def) = 0; // forces loading of the unit model
+	virtual void GetUnitDefList(const UnitDef** list) = 0;
+	virtual float GetUnitDefHeight(int def) = 0;	// forces loading of the unit model
+	virtual float GetUnitDefRadius(int def) = 0;	// forces loading of the unit model
 
 	virtual const WeaponDef* GetWeapon(const char* weaponname) = 0;
 
-	virtual const float3 *GetStartPos() = 0;
+	virtual const float3* GetStartPos() = 0;
 
 	// NOTES:
 	// 1. 'data' can be setup to NULL to skip passing in a string


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000459.html">[Taspring-linux-commit] r5678 - trunk/rts/Sim/Path
</A></li>
	<LI>Next message: <A HREF="000461.html">[Taspring-linux-commit] r5680 - trunk/AI/Global/KAIK-0.13
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#460">[ date ]</a>
              <a href="thread.html#460">[ thread ]</a>
              <a href="subject.html#460">[ subject ]</a>
              <a href="author.html#460">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
