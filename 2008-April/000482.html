<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5702 - in trunk/AI/Global: . RAI-0.553	RAI-0.553/CodeBlocks RAI-0.553/CodeBlocks/.objs	RAI-0.553/DevC RAI-0.553/Krogs Metal Class v0.4 RAI-0.553/VS2005
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5702%20-%20in%20trunk/AI/Global%3A%20.%20RAI-0.553%0A%09RAI-0.553/CodeBlocks%20RAI-0.553/CodeBlocks/.objs%0A%09RAI-0.553/DevC%20RAI-0.553/Krogs%20Metal%20Class%20v0.4%20RAI-0.553/VS2005&In-Reply-To=%3C20080411211902.3876D46C5%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000481.html">
   <LINK REL="Next"  HREF="000488.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5702 - in trunk/AI/Global: . RAI-0.553	RAI-0.553/CodeBlocks RAI-0.553/CodeBlocks/.objs	RAI-0.553/DevC RAI-0.553/Krogs Metal Class v0.4 RAI-0.553/VS2005</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5702%20-%20in%20trunk/AI/Global%3A%20.%20RAI-0.553%0A%09RAI-0.553/CodeBlocks%20RAI-0.553/CodeBlocks/.objs%0A%09RAI-0.553/DevC%20RAI-0.553/Krogs%20Metal%20Class%20v0.4%20RAI-0.553/VS2005&In-Reply-To=%3C20080411211902.3876D46C5%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5702 - in trunk/AI/Global: . RAI-0.553	RAI-0.553/CodeBlocks RAI-0.553/CodeBlocks/.objs	RAI-0.553/DevC RAI-0.553/Krogs Metal Class v0.4 RAI-0.553/VS2005">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Apr 11 21:40:04 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000481.html">[Taspring-linux-commit] r5701 - trunk/rts/Game
</A></li>
        <LI>Next message: <A HREF="000488.html">[Taspring-linux-commit] r5703 - branches
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#482">[ date ]</a>
              <a href="thread.html#482">[ thread ]</a>
              <a href="subject.html#482">[ subject ]</a>
              <a href="author.html#482">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-04-11 21:40:03 +0200 (Fri, 11 Apr 2008)
New Revision: 5702

Added:
   trunk/AI/Global/RAI-0.553/
   trunk/AI/Global/RAI-0.553/Builder.cpp
   trunk/AI/Global/RAI-0.553/Builder.h
   trunk/AI/Global/RAI-0.553/BuilderPlacement.cpp
   trunk/AI/Global/RAI-0.553/BuilderPlacement.h
   trunk/AI/Global/RAI-0.553/CodeBlocks/
   trunk/AI/Global/RAI-0.553/CodeBlocks/(Bot-libs).lnk
   trunk/AI/Global/RAI-0.553/CodeBlocks/.objs/
   trunk/AI/Global/RAI-0.553/CodeBlocks/.objs/Krogs Metal Class v0.4/
   trunk/AI/Global/RAI-0.553/CodeBlocks/RAI.cbp
   trunk/AI/Global/RAI-0.553/CodeBlocks/RAI.layout
   trunk/AI/Global/RAI-0.553/CombatManager.cpp
   trunk/AI/Global/RAI-0.553/CombatManager.h
   trunk/AI/Global/RAI-0.553/DevC/
   trunk/AI/Global/RAI-0.553/DevC/(Bot-libs).lnk
   trunk/AI/Global/RAI-0.553/DevC/Ming/
   trunk/AI/Global/RAI-0.553/DevC/RAI.dev
   trunk/AI/Global/RAI-0.553/DevC/RAI.layout
   trunk/AI/Global/RAI-0.553/DevC/crtbegin.o
   trunk/AI/Global/RAI-0.553/DevC/crtend.o
   trunk/AI/Global/RAI-0.553/DevC/dllcrt2.o
   trunk/AI/Global/RAI-0.553/GMetalMap.cpp
   trunk/AI/Global/RAI-0.553/GMetalMap.h
   trunk/AI/Global/RAI-0.553/GTerrainMap.cpp
   trunk/AI/Global/RAI-0.553/GTerrainMap.h
   trunk/AI/Global/RAI-0.553/Global.cpp
   trunk/AI/Global/RAI-0.553/Global.h
   trunk/AI/Global/RAI-0.553/GlobalAIs.cpp
   trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/
   trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/MetalMap.cpp
   trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/MetalMap.h
   trunk/AI/Global/RAI-0.553/LogFile.cpp
   trunk/AI/Global/RAI-0.553/LogFile.h
   trunk/AI/Global/RAI-0.553/PowerManager.cpp
   trunk/AI/Global/RAI-0.553/PowerManager.h
   trunk/AI/Global/RAI-0.553/RAI.cpp
   trunk/AI/Global/RAI-0.553/RAI.h
   trunk/AI/Global/RAI-0.553/SWeaponManager.cpp
   trunk/AI/Global/RAI-0.553/SWeaponManager.h
   trunk/AI/Global/RAI-0.553/UnitDef.cpp
   trunk/AI/Global/RAI-0.553/UnitDef.h
   trunk/AI/Global/RAI-0.553/UnitManager.cpp
   trunk/AI/Global/RAI-0.553/UnitManager.h
   trunk/AI/Global/RAI-0.553/VS2005/
   trunk/AI/Global/RAI-0.553/VS2005/RAI.sln
   trunk/AI/Global/RAI-0.553/VS2005/RAI.vcproj
   trunk/AI/Global/RAI-0.553/readme.txt
Log:
add Reth's cool RAI (v0.553)
 * build it with &quot;scons RAI-0.553&quot;
 * replace the &quot;#include &quot;Sim/Features/FeatureDef.h&quot;&quot;
   directives by &quot;#include &quot;Sim/Misc/FeatureDef.h&quot;&quot;
   to make it compile against the .76b1 source, no
   other changes are needed


Added: trunk/AI/Global/RAI-0.553/Builder.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/Builder.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/Builder.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,1494 @@
+#include &quot;Builder.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//struct WeaponDef;
+//#include &lt;set&gt;
+#include &quot;Sim/Features/FeatureDef.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+
+sBuildQuarry::sBuildQuarry(sRAIBuildList *buildlist)
+{
+	BL=buildlist;
+	if( BL != 0 )
+		BL-&gt;unitsActive++;
+	builderID=-1;
+	RS=0;
+	tryCount=0;
+};
+
+sBuildQuarry::~sBuildQuarry()
+{
+	if( BL != 0 )
+		BL-&gt;unitsActive--;
+};
+
+bool sBuildQuarry::IsValid(int frame)
+{
+	if( int(creationID.size()) == 0 &amp;&amp; builderID == -1 &amp;&amp; frame &gt;= deletionFrame )
+		return false;
+	return true;
+};
+
+void sBuildQuarry::SetRS(sResourceSpot* rs)
+{
+	if( RS != 0 )
+		RS-&gt;builderID=-1;
+	RS = rs;
+	if( RS != 0 )
+		RS-&gt;builderID=builderID;
+};
+// ------------------------------------------------------------------------------------------------
+
+cBuilder::cBuilder(IAICallback* callback, cRAI* global)
+{
+	cb = callback;
+	G = global;
+	UDR = G-&gt;UDH;
+	for( map&lt;int,sRAIUnitDef&gt;::iterator iU=UDR-&gt;UDR.begin(); iU!=UDR-&gt;UDR.end(); iU++ )
+		if( int(iU-&gt;second.ud-&gt;wreckName.size()) &gt; 0 )
+			UDRResurrect.insert(srPair(iU-&gt;second.ud-&gt;wreckName,&amp;iU-&gt;second));
+
+	l=G-&gt;l;
+	bInitiated=false;
+	ConDrainEnergyDebug=0;
+	ConDrainMetalDebug=0;
+	ConDrainFrameDebug=0;
+	ConEnergyLost=0;
+	ConMetalLost=0;
+	ConEnergyDrain=0;
+	ConMetalDrain=0;
+	ConEnergyRate=0;
+	ConMetalRate=0;
+	ConEnergyStorage=0;
+	ConMetalStorage=0;
+
+	for( int i=0; i&lt;8; i++ )
+		BQSize[i]=0;
+	Prerequisite=0;
+
+	*l&lt;&lt;&quot;\n Loading cPowerManager ...&quot;;
+	PM = new cPowerManager(cb,G);
+	BP = 0;
+}
+
+cBuilder::~cBuilder()
+{
+	if( int(G-&gt;Units.size()) == 0 )
+	{
+		*l&lt;&lt;&quot;\n cBuilder Debug:&quot;;
+		*l&lt;&lt;&quot;\n  clearing Build Quarry ...&quot;;
+		while( BQSize[0] &gt; 0 )
+			BQRemove(0);
+
+		*l&lt;&lt;&quot;\n  Builders Active      = &quot;&lt;&lt;int(UBuilder.size());
+		*l&lt;&lt;&quot;\n  Constructions Active = &quot;&lt;&lt;int(UConstruction.size());
+		*l&lt;&lt;&quot;\n  Metal Cost Limit     = &quot;&lt;&lt;MCostLimit;
+		*l&lt;&lt;&quot;\n  Energy Cost Limit    = &quot;&lt;&lt;ECostLimit;
+		*l&lt;&lt;&quot;\n  Const Energy Drain   = &quot;&lt;&lt;ConEnergyDrain;
+		*l&lt;&lt;&quot;\n  Const Metal Drain    = &quot;&lt;&lt;ConMetalDrain;
+		*l&lt;&lt;&quot;\n  Const Energy Rate    = &quot;&lt;&lt;ConEnergyRate;
+		*l&lt;&lt;&quot;\n  Const Metal Rate     = &quot;&lt;&lt;ConMetalRate;
+		*l&lt;&lt;&quot;\n  Const Energy Storage = &quot;&lt;&lt;ConEnergyStorage;
+		*l&lt;&lt;&quot;\n  Const Metal Storage  = &quot;&lt;&lt;ConMetalStorage;
+//		if( ConEnergyRate != 0 || ConMetalRate != 0 || ConEnergyStorage != 0 || ConMetalStorage != 0 )
+//			*l&lt;&lt;&quot;\n ERROR!&quot;;
+	}
+
+	if( BP != 0 )
+		delete BP;
+	delete PM;
+}
+
+void cBuilder::UnitCreated(const int&amp; unit, UnitInfo *U)
+{
+	if( BP == 0 )
+	{
+		*l&lt;&lt;&quot;\n Loading cBuilderPlacement ...&quot;;
+		BP = new cBuilderPlacement(cb,G);
+	}
+	// Attempts to identify which Build Quarry this new unit belongs to.
+	int iBQIndex=-1;
+	for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++)
+	{
+		if(	BQ[iBQ]-&gt;creationUDID==U-&gt;ud-&gt;id &amp;&amp; BQ[iBQ]-&gt;builderID &gt; -1 &amp;&amp; G-&gt;ValidateUnit(BQ[iBQ]-&gt;builderID) &amp;&amp; int(cb-&gt;GetCurrentUnitCommands(BQ[iBQ]-&gt;builderID)-&gt;size())&gt;0 )
+		{
+			const Command *c=&amp;cb-&gt;GetCurrentUnitCommands(BQ[iBQ]-&gt;builderID)-&gt;front();
+			if( c-&gt;id == -U-&gt;ud-&gt;id )
+			{
+				if( int(c-&gt;params.size()) &gt;= 3 ) // (0.73b1): for some reason human issued build commands do not have params
+				{
+					float fx = cb-&gt;GetUnitPos(unit).x - c-&gt;params.at(0);
+					float fz = cb-&gt;GetUnitPos(unit).z - c-&gt;params.at(2);
+					float fx2 = cb-&gt;GetUnitPos(unit).x - cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID).x;
+					float fz2 = cb-&gt;GetUnitPos(unit).z - cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID).z;
+					float fMarginOfError=BQ[iBQ]-&gt;builderUI-&gt;ud-&gt;buildDistance + 50;
+					if( fMarginOfError &lt; 300 )
+						fMarginOfError = 300;
+
+					// The margin of error in position can be quite large, the size of units can distort their intended build positions
+					// Thus constructers, which are set to build at a certain position, can build at a distance that even exceeds their build distance (or at least, that is what these variables have told me during testing)
+					if( (fx &lt; fMarginOfError &amp;&amp; fx &gt; -fMarginOfError &amp;&amp; fz &lt; fMarginOfError &amp;&amp; fz &gt; -fMarginOfError) ||
+						(fx2 &lt; fMarginOfError &amp;&amp; fx2 &gt; -fMarginOfError &amp;&amp; fz2 &lt; fMarginOfError &amp;&amp; fz2 &gt; -fMarginOfError) )
+					{
+//						*l&lt;&lt;&quot;\n\nUnit Position:  x=&quot;&lt;&lt;cb-&gt;GetUnitPos(unit).x&lt;&lt;&quot; z=&quot;&lt;&lt;cb-&gt;GetUnitPos(unit).z;
+//						*l&lt;&lt;&quot;\nBuilder Position: x=&quot;&lt;&lt;cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID).x&lt;&lt;&quot; z=&quot;&lt;&lt;cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID).z;
+//						*l&lt;&lt;&quot;\nBOrder Position:  x=&quot;&lt;&lt;c-&gt;params.at(0)&lt;&lt;&quot; z=&quot;&lt;&lt;c-&gt;params.at(2);
+//						*l&lt;&lt;&quot;\nMarginOfError: &quot;&lt;&lt;fMarginOfError&lt;&lt;&quot;\n\n&quot;;
+						if( iBQIndex &gt; -1 ) // It found more than 1 possible Build Quarry match
+						{
+							*l&lt;&lt;&quot;\nWARNING: Creation Def Conflict, code needs works.&quot;;
+						}
+						iBQIndex=iBQ;
+					}
+				}
+			}
+		}
+	}
+	int humanCreated=-1;
+	if( iBQIndex == -1 ) // This is a bit more thorough check for a human builder
+	{
+		G-&gt;ValidateAllUnits();
+		for(map&lt;int,UnitInfo&gt;::iterator iU=G-&gt;Units.begin(); iU!=G-&gt;Units.end(); iU++)
+		{
+			if(	cb-&gt;GetCurrentUnitCommands(iU-&gt;first)-&gt;size() &gt; 0 )
+			{
+				const Command *c=&amp;cb-&gt;GetCurrentUnitCommands(iU-&gt;first)-&gt;front();
+				if( c-&gt;id == -U-&gt;ud-&gt;id &amp;&amp; int(c-&gt;params.size()) == 0 )
+				{
+					float fx2 = cb-&gt;GetUnitPos(unit).x - cb-&gt;GetUnitPos(iU-&gt;first).x;
+					float fz2 = cb-&gt;GetUnitPos(unit).z - cb-&gt;GetUnitPos(iU-&gt;first).z;
+					float fMarginOfError=iU-&gt;second.ud-&gt;buildDistance + 150;
+					if( fMarginOfError &lt; 300 )
+						fMarginOfError = 300;
+
+					if( fx2 &lt; fMarginOfError &amp;&amp; fx2 &gt; -fMarginOfError &amp;&amp; fz2 &lt; fMarginOfError &amp;&amp; fz2 &gt; -fMarginOfError )
+					{
+						humanCreated = iU-&gt;first;
+					}
+				}
+			}
+		}
+	}
+	if( iBQIndex &gt;= 0 )
+	{
+		typedef pair&lt;int,UnitConstructionInfo&gt; iuPair;
+		UConstruction.insert(iuPair(unit,UnitConstructionInfo(BQ[iBQIndex],unit,U)));
+		U-&gt;AIDisabled=false;
+	}
+	else if( humanCreated &gt;= 0 &amp;&amp; (U-&gt;ud-&gt;speed &gt; 0 || int(U-&gt;udr-&gt;BuildOptions.size()) == 0) )
+	{
+		U-&gt;AIDisabled=true;
+	}
+	else
+	{
+		// This case can occur 4 ways: 1) starting units 2) resurrected units 3) RAI failed to identify it's builder 4) factory built by human player
+		U-&gt;AIDisabled=false;
+	}
+	if( !U-&gt;AIDisabled )
+		U-&gt;udr-&gt;UnitConstructsActive.insert(unit);
+}
+
+void cBuilder::UnitFinished(const int&amp; unit, UnitInfo *U)
+{
+	if( bInitiated &amp;&amp; UConstruction.find(unit) != UConstruction.end() )
+	{
+		UnitConstructionInfo *pUCQ=&amp;UConstruction.find(unit)-&gt;second;
+		if( pUCQ-&gt;BQAbandoned )
+		{
+			UConstruction.erase(unit); // Remove from list of units being built
+		}
+		else
+		{
+			if( int(cb-&gt;GetCurrentUnitCommands(unit)-&gt;size()) == 0 &amp;&amp; UBuilder.find(pUCQ-&gt;BQ-&gt;builderID) != UBuilder.end() )
+			{
+				if( pUCQ-&gt;BQ-&gt;builderUI-&gt;ud-&gt;speed == 0 )
+				{
+					Command c;
+					c.id=CMD_MOVE;
+					float3 fPos=cb-&gt;GetUnitPos(unit);
+					fPos.x+=-100+rand()%201;
+					if( cb-&gt;GetBuildingFacing(pUCQ-&gt;BQ-&gt;builderID) == 2 )
+						fPos.z-=150+rand()%201;
+					else
+						fPos.z+=150+rand()%201;
+					fPos.y=cb-&gt;GetElevation(fPos.x,fPos.z);
+					c.params.push_back(fPos.x);
+					c.params.push_back(fPos.y);
+					c.params.push_back(fPos.z);
+					cb-&gt;GiveOrder(unit,&amp;c);
+					U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+150;
+				}
+			}
+			BQRemove(pUCQ-&gt;BQ-&gt;index); // Remove from global build instructions
+		}
+	}
+	U-&gt;udr-&gt;UnitsActive.insert(unit);
+	U-&gt;udr-&gt;UnitConstructsActive.erase(unit);
+	UnitAssignBuildList(unit,U);
+	U-&gt;udr-&gt;CheckUnitLimit();
+	U-&gt;udr-&gt;CheckBuildOptions();
+	if( U-&gt;ud-&gt;speed == 0 )
+	{
+		for(map&lt;int,UnitInfo*&gt;::iterator i=UNanos.begin(); i!=UNanos.end(); i++ )
+		{
+			if( cb-&gt;GetUnitPos(unit).distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; i-&gt;second-&gt;ud-&gt;buildDistance )
+			{
+				i-&gt;second-&gt;UGuarding.insert(cRAI::iupPair(unit,U));
+				U-&gt;UGuards.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+				if( U-&gt;pBOL != 0 &amp;&amp; U-&gt;pBOL-&gt;task == TASK_CONSTRUCT &amp;&amp; int(U-&gt;udr-&gt;BuildOptions.size()) &gt; 0 )
+					i-&gt;second-&gt;UAssist.insert(cRAI::iupPair(unit,U));
+			}
+		}
+		if( U-&gt;udr-&gt;IsNano() )
+		{
+			UNanos.insert(cRAI::iupPair(unit,U));
+			for(map&lt;int,UnitInfo*&gt;::iterator i=G-&gt;UImmobile.begin(); i!=G-&gt;UImmobile.end(); i++ )
+			{
+				if( i-&gt;first != unit &amp;&amp; i-&gt;second-&gt;UnitFinished &amp;&amp; cb-&gt;GetUnitPos(unit).distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; U-&gt;ud-&gt;buildDistance )
+				{
+					U-&gt;UGuarding.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+					i-&gt;second-&gt;UGuards.insert(cRAI::iupPair(unit,U));
+					if( i-&gt;second-&gt;pBOL-&gt;task == TASK_CONSTRUCT &amp;&amp; int(i-&gt;second-&gt;udr-&gt;BuildOptions.size()) &gt; 0 )
+						U-&gt;UAssist.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+				}
+			}
+		}
+	}
+}
+
+void cBuilder::UnitDestroyed(const int&amp; unit, UnitInfo* U)
+{
+	if( !U-&gt;UnitFinished )
+	{
+		if( UConstruction.find(unit) != UConstruction.end() )
+		{
+			if( !UConstruction.find(unit)-&gt;second.BQAbandoned )
+			{
+				UConstruction.find(unit)-&gt;second.BQ-&gt;creationID.remove(unit);
+			}
+			UConstruction.erase(unit);
+		}
+		U-&gt;udr-&gt;UnitConstructsActive.erase(unit);
+	}
+	else
+	{
+		U-&gt;udr-&gt;UnitsActive.erase(unit);
+		U-&gt;pBOL-&gt;RBL-&gt;unitsActive--;
+		U-&gt;udr-&gt;CheckUnitLimit();
+		U-&gt;udr-&gt;CheckBuildOptions();
+		if( U-&gt;ud-&gt;speed == 0 )
+		{
+			if( U-&gt;udr-&gt;IsNano() )
+			{
+				UNanos.erase(unit);
+				for(map&lt;int,UnitInfo*&gt;::iterator i=U-&gt;UGuarding.begin(); i!=U-&gt;UGuarding.end(); i++ )
+					i-&gt;second-&gt;UGuards.erase(unit);
+			}
+			for(map&lt;int,UnitInfo*&gt;::iterator i=U-&gt;UGuards.begin(); i!=U-&gt;UGuards.end(); i++ )
+			{
+				i-&gt;second-&gt;UGuarding.erase(unit);
+				i-&gt;second-&gt;UAssist.erase(unit);
+			}
+		}
+	}
+}
+
+void cBuilder::UnitAssignBuildList(const int&amp; unit, UnitInfo *U, bool bInitialized)
+{
+	if( bInitialized )
+		U-&gt;pBOL-&gt;RBL-&gt;unitsActive--;
+	float fBestV=-1;	// Value
+	int iBestI=-1;		// Index
+	for(int i=0; i&lt;U-&gt;udr-&gt;ListSize; i++ )
+	{
+		sRAIBuildList* BL=U-&gt;udr-&gt;List[i]-&gt;RBL;
+		if( BL-&gt;unitsActive &lt; BL-&gt;minUnits &amp;&amp; (iBestI == -1 || U-&gt;udr-&gt;List[iBestI]-&gt;RBL-&gt;minUnits == 0 || float(BL-&gt;unitsActive)/float(BL-&gt;minUnits) &lt; fBestV) )
+		{
+			iBestI = i;
+			fBestV = float(BL-&gt;unitsActive)/float(BL-&gt;minUnits);
+		}
+		else if( fBestV == -1 || ( BL-&gt;priority &gt; 0 &amp;&amp; U-&gt;udr-&gt;List[iBestI]-&gt;RBL-&gt;unitsActive &gt;= U-&gt;udr-&gt;List[iBestI]-&gt;RBL-&gt;minUnits &amp;&amp; float(1+BL-&gt;unitsActive)/float(BL-&gt;priority) &lt; fBestV ) )
+		{
+			iBestI = i;
+			fBestV = float(1+BL-&gt;unitsActive)/float(BL-&gt;priority);
+		}
+	}
+
+	if( iBestI == -1 )
+	{
+		*l&lt;&lt;&quot;\n\nWARNING: unknown unit type in use: ud-&gt;id=&quot;&lt;&lt;U-&gt;ud-&gt;id;
+//		cb-&gt;SendTextMsg(&quot;unknown unit type in use&quot;,0);
+		U-&gt;udr-&gt;UnitsActive.erase(unit);
+		U-&gt;AIDisabled=true;
+		return;
+	}
+	U-&gt;pBOL=U-&gt;udr-&gt;List[iBestI];
+	U-&gt;pBOL-&gt;RBL-&gt;unitsActive++;
+}
+
+void cBuilder::UBuilderFinished(const int&amp; unit, UnitInfo *U)
+{
+	UBuilder.insert(cRAI::iupPair(unit,U));
+	if( int(U-&gt;udr-&gt;UnitsActive.size()) == 1 )
+		UpdateUDRCost();
+}
+
+void cBuilder::UBuilderDestroyed(const int&amp; unit, UnitInfo *U)
+{
+	if( U-&gt;BuildQ != 0 )
+		BQAssignBuilder(U-&gt;BuildQ-&gt;index,-1,0);
+
+	UBuilder.erase(unit);
+	if( int(U-&gt;udr-&gt;UnitsActive.size()) == 0 )
+		UpdateUDRCost();
+}
+
+void cBuilder::UBuilderIdle(const int&amp; unit,UnitInfo *U)
+{
+	int iFrame = cb-&gt;GetCurrentFrame();
+	float fOnOffPower = PM-&gt;NeededOnOffPower;
+	float fCloakPower = PM-&gt;NeededCloakPower;
+	if( fCloakPower &gt; 0.10*cb-&gt;GetEnergyIncome() )
+		fCloakPower = 0.10*cb-&gt;GetEnergyIncome();
+	float fWeaponPower = PM-&gt;NeededWeaponPower;
+	if( fWeaponPower &gt; 0.25*cb-&gt;GetEnergyIncome() )
+		fWeaponPower = 0.25*cb-&gt;GetEnergyIncome();
+	float MRatio;
+	if( cb-&gt;GetMetalIncome() == 0 || cb-&gt;GetMetalUsage() == 0 )
+		MRatio=1;
+	else
+		MRatio=0.5*(cb-&gt;GetMetalUsage()/cb-&gt;GetMetalIncome());
+	float ERatio;
+	if( cb-&gt;GetEnergyIncome() == 0 || cb-&gt;GetEnergyUsage() == 0 )
+		ERatio=1;
+	else
+		ERatio=0.5*(cb-&gt;GetEnergyUsage()/cb-&gt;GetEnergyIncome());
+	float MetalRate=cb-&gt;GetMetalIncome()-cb-&gt;GetMetalUsage()+0.75*PM-&gt;MetalProduction+0.1*PM-&gt;MetalProductionEtoM+0.75*ConMetalRate;
+	float EnergyRate=cb-&gt;GetEnergyIncome()-cb-&gt;GetEnergyUsage()-fOnOffPower-fCloakPower-fWeaponPower+0.75*ConEnergyRate;
+
+	// This is a very poor attempt to correct the values reported by callback, however having this makes a big difference when the commander is building it's first few units
+	if( ConDrainFrameDebug+15 &gt;= cb-&gt;GetCurrentFrame() )
+	{
+		MetalRate+=ConDrainMetalDebug;
+		EnergyRate+=ConDrainEnergyDebug;
+/*
+		*l&lt;&lt;&quot;\n\n CF:&quot;&lt;&lt;cb-&gt;GetCurrentFrame()&lt;&lt;&quot; DF:&quot;&lt;&lt;ConDrainFrameDebug&lt;&lt;&quot; Dif:&quot;&lt;&lt;cb-&gt;GetCurrentFrame()- ConDrainFrameDebug;
+		*l&lt;&lt;&quot;\n Metal/Energy Usage: &quot;&lt;&lt;cb-&gt;GetMetalUsage()&lt;&lt;&quot;/&quot;&lt;&lt;cb-&gt;GetEnergyUsage();
+		*l&lt;&lt;&quot;\n Debugging Metal/Energy Rates: &quot;&lt;&lt;ConDrainMetalDebug&lt;&lt;&quot;/&quot;&lt;&lt;ConDrainEnergyDebug;
+*/
+	}
+	else
+	{
+		ConDrainMetalDebug=0;
+		ConDrainEnergyDebug=0;
+	}
+	Command c;
+	bool HaveOrders;
+	if( U-&gt;BuildQ != 0 )
+	{
+		if( int(U-&gt;BuildQ-&gt;creationID.size())&gt;0 &amp;&amp; cb-&gt;GetUnitHealth(U-&gt;BuildQ-&gt;creationID.front()) &lt;= 0 )
+			U-&gt;BuildQ-&gt;creationID.pop_front();
+		if( int(U-&gt;BuildQ-&gt;creationID.size()) == 0 )
+			U-&gt;BuildQ-&gt;tryCount++;
+
+		if( !U-&gt;BuildQ-&gt;IsValid(iFrame) || U-&gt;BuildQ-&gt;tryCount &gt; 4 )
+		{
+			BQRemove(U-&gt;BuildQ-&gt;index);
+			HaveOrders=false;
+		}
+		else
+		{
+			c.id=-U-&gt;BuildQ-&gt;creationUDID;
+			HaveOrders=true;
+		}
+	}
+	else
+	{
+		HaveOrders=false;
+	}
+	if( !HaveOrders &amp;&amp; int(U-&gt;udr-&gt;BuildOptions.size()) &gt; 0 )
+	{
+		for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++) // Checking old build orders
+		{
+			if( !BQ[iBQ]-&gt;IsValid(iFrame) || 
+				(iFrame &gt; BQ[iBQ]-&gt;deletionFrame+9000 &amp;&amp; // 9000f = 5mins
+				 int(BQ[iBQ]-&gt;creationID.size()) &gt; 0 &amp;&amp;
+				 cb-&gt;GetUnitHealth(BQ[iBQ]-&gt;creationID.front()) &lt; 0.02*cb-&gt;GetUnitMaxHealth(BQ[iBQ]-&gt;creationID.front()) ) )
+			{
+				if( BQ[iBQ]-&gt;builderID &gt; -1 )
+				{
+					BQ[iBQ]-&gt;builderUI-&gt;commandTimeOut=1;
+				}
+				BQRemove(iBQ--);
+			}
+		}
+		if(    BQSize[0] &lt; 30 &amp;&amp; BQSize[0] &lt; int(UBuilder.size())+1 &amp;&amp; UDR-&gt;BLActive &gt; 0 )
+		{
+			G-&gt;ValidateUnitList(&amp;UBuilder);
+			BP-&gt;CheckBlockedRList();
+		}
+		while( BQSize[0] &lt; 30 &amp;&amp; BQSize[0] &lt; int(UBuilder.size())+1 &amp;&amp; UDR-&gt;BLActive &gt; 0 )
+		{
+//			*l&lt;&lt;&quot;\n\n NBO&quot;;
+//			if( Prerequisite != 0 ) *l&lt;&lt;&quot;(Prerequisite: &quot;&lt;&lt;Prerequisite-&gt;creationUD-&gt;ud-&gt;humanName&lt;&lt;&quot;)&quot;;
+
+			float fBestV=-1;	// Value
+			int iBestI=-1;		// Index
+			for(int i=0; i&lt;UDR-&gt;BLSize; i++ )
+			{
+				UDR-&gt;BL[i]-&gt;UDefActiveTemp = UDR-&gt;BL[i]-&gt;UDefActive;
+			}
+			for(int i=0; i&lt;UDR-&gt;BLActive; i++ )
+			{
+				// If a prerequisite is being built or this list is unimportant, then make sure this list can build something that already has a prerequisite
+				if( Prerequisite != 0 || UDR-&gt;BL[i]-&gt;minUnits == 0 )
+				{
+					for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+					{
+						if( !UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;HasPrerequisite )
+						{
+							UDR-&gt;BL[i]-&gt;UDefActiveTemp--;
+							UDR-&gt;BL[i]-&gt;UDefSwitch(iud,UDR-&gt;BL[i]-&gt;UDefActiveTemp);
+						}
+					}
+				}
+				// make sure the first few extractors are built at the closest metal spots available by restricting the wrong types
+				if( UDR-&gt;BL[i] == UDR-&gt;BLMetalL )
+				{
+					if( UDR-&gt;BL[i]-&gt;unitsActive &lt; UDR-&gt;BL[i]-&gt;minUnits )
+					{
+						float3 Pos = cb-&gt;GetUnitPos(unit);
+						set&lt;int&gt; best;
+						sResourceSpot* RSbest;
+						for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+						{
+							int mapbody=G-&gt;GetCurrentMapBody(UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;ud,Pos);
+							sResourceSpot* RS = BP-&gt;FindResourceSpot(Pos,UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;ud,mapbody);
+							if( RS != 0 )
+							{
+								if( int(best.size()) == 0 || RS == RSbest )
+								{
+									best.insert(iud);
+									RSbest = RS;
+								}
+								else if( Pos.distance2D(RS-&gt;location) &lt; Pos.distance2D(RSbest-&gt;location) )
+								{
+									best.clear();
+									best.insert(iud);
+									RSbest = RS;
+								}
+							}
+						}
+						if( int(best.size()) &gt; 0 )
+						{
+							for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+							{
+								if( best.find(iud) == best.end() )
+								{
+									UDR-&gt;BL[i]-&gt;UDefActiveTemp--;
+									UDR-&gt;BL[i]-&gt;UDefSwitch(iud,UDR-&gt;BL[i]-&gt;UDefActiveTemp);
+								}
+							}
+						}
+					}
+				}
+				else if( int(G-&gt;UImmobileWater.size()) == 0 ) // restrict the building of most water units until 1)something important(extractor) has been built in it or 2) the active builder is close to the water
+				{
+					float3 pos = cb-&gt;GetUnitPos(unit);
+					G-&gt;CorrectPosition(&amp;pos);
+					MapSector *MS = &amp;G-&gt;TM-&gt;Sector[G-&gt;TM-&gt;GetSector(pos)];
+					if( MS-&gt;Land &amp;&amp; (MS-&gt;AltSector == 0 || MS-&gt;Pos.distance2D(MS-&gt;AltSector-&gt;Pos) &gt; 750.0f ) )
+					{
+						for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+						{
+							sRAIUnitDef *udr = UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD;
+							if( udr-&gt;ud-&gt;minWaterDepth &gt;= 0 || (udr-&gt;WeaponGuardRange &gt; 0 &amp;&amp; udr-&gt;WeaponSeaEff.BestRange &gt; 0) )
+							{
+								UDR-&gt;BL[i]-&gt;UDefActiveTemp--;
+								UDR-&gt;BL[i]-&gt;UDefSwitch(iud,UDR-&gt;BL[i]-&gt;UDefActiveTemp);
+							}
+						}
+					}
+				}
+//				*l&lt;&lt;&quot;\n&quot;&lt;&lt;UDR-&gt;BL[i]-&gt;Name&lt;&lt;&quot; BuildList &quot;&lt;&lt;UDR-&gt;BL[i]-&gt;unitsActive&lt;&lt;&quot;/&quot;&lt;&lt;UDR-&gt;BL[i]-&gt;priority&lt;&lt;&quot;: Min=&quot;&lt;&lt;UDR-&gt;BL[i]-&gt;minUnits&lt;&lt;&quot; UDefActiveTemp=&quot;&lt;&lt;UDR-&gt;BL[i]-&gt;UDefActiveTemp;
+				if( UDR-&gt;BL[i]-&gt;UDefActiveTemp == 0 ) {}
+				else if( UDR-&gt;BL[i]-&gt;unitsActive &lt; UDR-&gt;BL[i]-&gt;minUnits &amp;&amp; (fBestV&lt;0 || UDR-&gt;BL[iBestI]-&gt;minUnits == 0 || float(UDR-&gt;BL[i]-&gt;unitsActive)/float(UDR-&gt;BL[i]-&gt;minUnits) &lt; fBestV) )
+				{
+					iBestI = i;
+					fBestV = float(UDR-&gt;BL[iBestI]-&gt;unitsActive)/float(UDR-&gt;BL[iBestI]-&gt;minUnits);
+				}
+				else if( fBestV&lt;0 || (UDR-&gt;BL[i]-&gt;priority &gt; 0 &amp;&amp; UDR-&gt;BL[iBestI]-&gt;unitsActive &gt;= UDR-&gt;BL[iBestI]-&gt;minUnits &amp;&amp; float(1+UDR-&gt;BL[i]-&gt;unitsActive)/float(UDR-&gt;BL[i]-&gt;priority) &lt; fBestV ) )
+				{
+					iBestI = i;
+					fBestV = float(1+UDR-&gt;BL[i]-&gt;unitsActive)/float(UDR-&gt;BL[i]-&gt;priority);
+				}
+			}
+			if( iBestI == -1 ) // ? hopefully won't happen
+			{
+				*l&lt;&lt;&quot;\n\nERROR: No BuildList Choice Available.&quot;;
+				cb-&gt;SendTextMsg(&quot;ERROR: No BuildList Choice Available.&quot;,5);
+				break;
+			}
+
+			sRAIBuildList *BL = UDR-&gt;BL[iBestI];
+			int iBuildType=1;
+
+			if( BL == UDR-&gt;BLEnergy || BL == UDR-&gt;BLEnergyL )
+				iBuildType=2;
+			else if( BL == UDR-&gt;BLMetal || BL == UDR-&gt;BLMetalL )
+				iBuildType=3;
+			else if( BL == UDR-&gt;BLBuilder )
+				iBuildType=4;
+
+			if( BL-&gt;unitsActive &lt; BL-&gt;minUnits )
+			{
+				for( int iud=BL-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+				{
+					if( !BL-&gt;UDef[iud]-&gt;RUD-&gt;HasPrerequisite )
+					{
+						BL-&gt;UDefActiveTemp--;
+						BL-&gt;UDefSwitch(iud,BL-&gt;UDefActiveTemp);
+					}
+				}
+				if( BL-&gt;UDefActiveTemp == 0 )
+					BL-&gt;UDefActiveTemp = BL-&gt;UDefActive;
+			}
+			iBestI = rand()%BL-&gt;UDefActiveTemp;
+			sRAIUnitDef *udr = BL-&gt;UDef[iBestI]-&gt;RUD;
+//			*l&lt;&lt;&quot;\n Option Seleted: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+
+			if( !udr-&gt;HasPrerequisite &amp;&amp; BQSize[4] &lt; 5 )
+			{
+				int oldID=udr-&gt;ud-&gt;id;
+				udr=&amp;UDR-&gt;UDR.find(udr-&gt;GetPrerequisite())-&gt;second;
+				if( udr-&gt;ud-&gt;id != oldID )
+				{
+					iBuildType=7;
+//					*l&lt;&lt;&quot;\n Prerequisite Seleted: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+				}
+			}
+			float fBuildTime=udr-&gt;ud-&gt;buildTime/U-&gt;ud-&gt;buildSpeed;
+			float EnergyDemand = 0;
+			float MetalDemand = 0;
+			float ConstructerDemand=0;
+			float EnergyStorageDemand=0;
+			float MetalStorageDemand=0;
+
+			if( BL-&gt;unitsActive &gt;= BL-&gt;minUnits &amp;&amp; BL != UDR-&gt;BLEnergy &amp;&amp; BL != UDR-&gt;BLMetal &amp;&amp; BL != UDR-&gt;BLMetalL )
+			{
+				if( (UDR-&gt;BLEnergyL-&gt;UDefActiveTemp &gt; 0 || UDR-&gt;BLEnergy-&gt;UDefActiveTemp &gt; 0) &amp;&amp; BQSize[2] &lt; 5 &amp;&amp; BQSize[2] &lt; 0.4*BQSize[0] )
+					EnergyDemand = -(fBuildTime*(EnergyRate+udr-&gt;EnergyDifference)+cb-&gt;GetEnergy()-0.25*ConEnergyLost-udr-&gt;ud-&gt;energyCost)*ERatio/UDR-&gt;EnergyToMetalRatio;
+
+				if( (UDR-&gt;BLMetalL-&gt;UDefActiveTemp &gt; 0 || UDR-&gt;BLMetal-&gt;UDefActiveTemp &gt; 0) &amp;&amp; BQSize[3] &lt; 5 &amp;&amp; BQSize[3] &lt; 0.4*BQSize[0] &amp;&amp; !( EnergyDemand&gt;0 &amp;&amp; udr-&gt;HighEnergyDemand ) )
+				{
+					if( UDR-&gt;BLMetalL-&gt;UDefActiveTemp == 0 )
+						MetalRate=cb-&gt;GetMetalIncome()-cb-&gt;GetMetalUsage()+PM-&gt;MetalProduction+PM-&gt;MetalProductionEtoM+ConMetalRate;
+
+					MetalDemand = -(fBuildTime*(MetalRate+udr-&gt;MetalDifference)+cb-&gt;GetMetal()-0.25*ConMetalLost-udr-&gt;ud-&gt;metalCost)*MRatio;
+					if( MetalDemand &lt;= 0 &amp;&amp; UDR-&gt;BLMetalL-&gt;UDefActiveTemp &gt; 0 &amp;&amp; BQSize[3] == 0 )
+						MetalDemand=2;
+				}
+
+				if( UDR-&gt;BLBuilder-&gt;UDefActiveTemp &gt; 0 &amp;&amp; BQSize[4] &lt; 2 &amp;&amp; BQSize[4] &lt; 0.3*BQSize[0] )
+				{
+					if( EnergyRate &gt; 0 &amp;&amp; MetalRate &gt; 0 &amp;&amp; 30.0*EnergyRate+cb-&gt;GetEnergy()-(0.6+0.1*BQSize[4])*cb-&gt;GetEnergyStorage() &gt; 0 &amp;&amp; 30.0*MetalRate+cb-&gt;GetMetal()-(0.6+0.1*BQSize[4])*cb-&gt;GetMetalStorage() &gt; 0 )
+						ConstructerDemand=1;
+				}
+
+				if( UDR-&gt;BLEnergyStorage-&gt;UDefActiveTemp &gt; 0 &amp;&amp; BQSize[5] &lt; 1 )
+					EnergyStorageDemand=-(cb-&gt;GetEnergyStorage()+ConEnergyStorage-0.20*udr-&gt;ud-&gt;energyCost);
+
+				if( UDR-&gt;BLMetalStorage-&gt;UDefActiveTemp &gt; 0 &amp;&amp; BQSize[6] &lt; 1 )
+					MetalStorageDemand=-(cb-&gt;GetMetalStorage()+ConMetalStorage-0.20*udr-&gt;ud-&gt;metalCost);
+			}
+/*
+*l&lt;&lt;&quot;\n CB&quot;;
+*l&lt;&lt;&quot;\n   Metal  =&quot;&lt;&lt;cb-&gt;GetMetal();
+*l&lt;&lt;&quot;   Metal Income  =&quot;&lt;&lt;cb-&gt;GetMetalIncome();
+*l&lt;&lt;&quot;   Metal Usage  =&quot;&lt;&lt;cb-&gt;GetMetalUsage();
+*l&lt;&lt;&quot;   Metal Storage  =&quot;&lt;&lt;cb-&gt;GetMetalStorage();
+*l&lt;&lt;&quot;\n   Energy =&quot;&lt;&lt;cb-&gt;GetEnergy();
+*l&lt;&lt;&quot;   Energy Income =&quot;&lt;&lt;cb-&gt;GetEnergyIncome();
+*l&lt;&lt;&quot;   Energy Usage =&quot;&lt;&lt;cb-&gt;GetEnergyUsage();
+*l&lt;&lt;&quot;   Energy Storage =&quot;&lt;&lt;cb-&gt;GetEnergyStorage();
+*l&lt;&lt;&quot;\n Con Energy Lost =&quot;&lt;&lt;ConEnergyLost;
+*l&lt;&lt;&quot;\n Metal Energy Lost =&quot;&lt;&lt;ConMetalLost;
+*l&lt;&lt;&quot;\n MetalProduction=&quot;&lt;&lt;PM-&gt;MetalProduction;
+*l&lt;&lt;&quot;\n MetalProductionEtoM=&quot;&lt;&lt;PM-&gt;MetalProductionEtoM;
+*l&lt;&lt;&quot;\n fOnOffPower=&quot;&lt;&lt;fOnOffPower;
+*l&lt;&lt;&quot;\n fWeaponPower=&quot;&lt;&lt;fWeaponPower;
+*l&lt;&lt;&quot;\n fCloakPower=&quot;&lt;&lt;fCloakPower;
+*l&lt;&lt;&quot;\n Build Time=&quot;&lt;&lt;fBuildTime;
+*l&lt;&lt;&quot;\n Name=&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+*l&lt;&lt;&quot;\n   metalCost=&quot;&lt;&lt;udr-&gt;ud-&gt;metalCost;
+*l&lt;&lt;&quot;\n   energyCost=&quot;&lt;&lt;udr-&gt;ud-&gt;energyCost;
+*l&lt;&lt;&quot;\n   metalUpkeep=&quot;&lt;&lt;udr-&gt;ud-&gt;metalUpkeep;
+*l&lt;&lt;&quot;\n   metalMake=&quot;&lt;&lt;udr-&gt;ud-&gt;metalMake;
+*l&lt;&lt;&quot;\n   energyUpkeep=&quot;&lt;&lt;udr-&gt;ud-&gt;energyUpkeep;
+*l&lt;&lt;&quot;\n   energyMake=&quot;&lt;&lt;udr-&gt;ud-&gt;energyMake;
+*l&lt;&lt;&quot;\n   HighEnergyDemand=&quot;&lt;&lt;udr-&gt;HighEnergyDemand;
+*l&lt;&lt;&quot;\n   extractsMetal=&quot;&lt;&lt;udr-&gt;ud-&gt;extractsMetal;
+*l&lt;&lt;&quot;\n BQSize&quot;; for( int i=0; i&lt;8; i++ ) *l&lt;&lt;&quot; [&quot;&lt;&lt;i&lt;&lt;&quot;]=&quot;&lt;&lt;BQSize[i];
+*l&lt;&lt;&quot;\n EnergyDemand=&quot;&lt;&lt;EnergyDemand;
+*l&lt;&lt;&quot;\n MetalDemand=&quot;&lt;&lt;MetalDemand;
+*l&lt;&lt;&quot;\n EnergyStorageDemand=&quot;&lt;&lt;EnergyStorageDemand;
+*l&lt;&lt;&quot;\n MetalStorageDemand=&quot;&lt;&lt;MetalStorageDemand;
+*l&lt;&lt;&quot;\n ConstructerDemand=&quot;&lt;&lt;ConstructerDemand;
+*/
+			float fHigh=0;
+			if( EnergyDemand &gt; fHigh )
+			{
+				fHigh=EnergyDemand;
+				iBuildType=2;
+				if( UDR-&gt;BLEnergyL-&gt;UDefActiveTemp &gt; 0 )
+					BL=UDR-&gt;BLEnergyL;
+				else
+					BL=UDR-&gt;BLEnergy;
+			}
+			if( MetalDemand &gt; fHigh )
+			{
+				fHigh=MetalDemand;
+				iBuildType=3;
+
+				if( UDR-&gt;BLMetalL-&gt;UDefActiveTemp &gt; 0 )
+					BL=UDR-&gt;BLMetalL;
+				else
+				{
+					BL=UDR-&gt;BLMetal;
+				}
+			}
+			if( ConstructerDemand &gt; fHigh )
+			{
+				fHigh=ConstructerDemand;
+				iBuildType=4;
+				BL=UDR-&gt;BLBuilder;
+			}
+			if( EnergyStorageDemand &gt; fHigh )
+			{
+				fHigh=EnergyStorageDemand;
+				iBuildType=5;
+				BL=UDR-&gt;BLEnergyStorage;
+			}
+			if( MetalStorageDemand &gt; fHigh )
+			{
+				fHigh=MetalStorageDemand;
+				iBuildType=6;
+				BL=UDR-&gt;BLMetalStorage;
+			}
+			if( fHigh &gt; 0 )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+BL-&gt;Name+&quot;(a=&quot;&lt;&lt;BL-&gt;UDefActiveTemp&lt;&lt;&quot;) Build Type=&quot;&lt;&lt;iBuildType;
+				int iIndex=rand()%BL-&gt;UDefActiveTemp;
+//				*l&lt;&lt;&quot; BL Index=&quot;&lt;&lt;iIndex;
+				udr = BL-&gt;UDef[iIndex]-&gt;RUD;
+//				*l&lt;&lt;&quot;\n  2-6 Demand Alternative Selected: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+				if( !udr-&gt;HasPrerequisite &amp;&amp; BQSize[4] &lt; 5 &amp;&amp; BQSize[4] &lt;= 0.5*BQSize[0] )
+				{
+					int oldID=udr-&gt;ud-&gt;id;
+					udr=&amp;UDR-&gt;UDR.find(udr-&gt;GetPrerequisite())-&gt;second;
+					if( udr-&gt;ud-&gt;id != oldID )
+					{
+						iBuildType=7;
+//						*l&lt;&lt;&quot;\n Prerequisite Seleted: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+					}
+				}
+			}
+			bool bPrerequisiteOptionsChecked=false;
+			int iBest=-1;
+			int Count=0;
+			for(map&lt;int,sRAIUnitDef*&gt;::iterator iP=udr-&gt;PrerequisiteOptions.begin(); iP!=udr-&gt;PrerequisiteOptions.end() &amp;&amp; !bPrerequisiteOptionsChecked; iP++)
+			{
+				for(set&lt;int&gt;::iterator iU=iP-&gt;second-&gt;UnitsActive.begin(); iU!=iP-&gt;second-&gt;UnitsActive.end() &amp;&amp; !bPrerequisiteOptionsChecked; iU++ )
+				{
+					if( UBuilder.find(*iU) != UBuilder.end() &amp;&amp; UBuilder.find(*iU)-&gt;second-&gt;BuildQ == 0 &amp;&amp; *iU != unit )
+					{
+						if( int(cb-&gt;GetCurrentUnitCommands(*iU)-&gt;size()) == 0 || cb-&gt;GetCurrentUnitCommands(*iU)-&gt;front().id == CMD_WAIT )
+						{
+							UBuilder.find(*iU)-&gt;second-&gt;commandTimeOut=cb-&gt;GetCurrentFrame();
+						}
+						bPrerequisiteOptionsChecked=true;
+					}
+				}
+			}
+			if( !bPrerequisiteOptionsChecked &amp;&amp; BQSize[4] &lt; 3 &amp;&amp; BQSize[4] &lt;= 0.3*BQSize[0] &amp;&amp; Prerequisite == 0 &amp;&amp; rand()%5 == 0 )
+			{
+				int oldID=udr-&gt;ud-&gt;id;
+				udr=&amp;UDR-&gt;UDR.find(udr-&gt;GetPrerequisiteNewBuilder())-&gt;second;
+				if( udr-&gt;ud-&gt;id != oldID )
+				{
+					if( udr-&gt;UnitConstructs == 0 &amp;&amp;
+						((UDR-&gt;BLMetalL-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLMetal-&gt;UDefSize == 0) || 0.25*cb-&gt;GetMetalIncome() &gt; udr-&gt;ud-&gt;metalCost/UDR-&gt;AverageConstructSpeed ) &amp;&amp;
+						((UDR-&gt;BLEnergyL-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLEnergy-&gt;UDefSize == 0) || 0.25*cb-&gt;GetEnergyIncome() &gt; udr-&gt;ud-&gt;energyCost/UDR-&gt;AverageConstructSpeed) )
+					{
+//						*l&lt;&lt;&quot;\n New Builder Selected: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+						iBuildType=4;
+					}
+					else
+						udr=&amp;UDR-&gt;UDR.find(oldID)-&gt;second;
+				}
+			}
+			BQAdd(udr,BL,iBuildType);
+			if( Prerequisite == 0 &amp;&amp; iBuildType == 7 &amp;&amp; int(udr-&gt;UnitsActive.size()) == 0 )
+			{
+				Prerequisite = BQ[BQSize[0]-1];
+			}
+			MetalRate=cb-&gt;GetMetalIncome()-cb-&gt;GetMetalUsage()+0.75*PM-&gt;MetalProduction+0.1*PM-&gt;MetalProductionEtoM+0.75*ConMetalRate;
+			EnergyRate=cb-&gt;GetEnergyIncome()-cb-&gt;GetEnergyUsage()-fOnOffPower-fCloakPower-fWeaponPower+0.75*ConEnergyRate;
+		}
+		// Search existing build orders
+		float Demand[8]; // index = type, higher value mean that type should be built first
+		Demand[1] = 0;
+		Demand[2] = 3;
+		Demand[3] = 3;
+		if( cb-&gt;GetEnergy()*(cb-&gt;GetEnergyIncome()/cb-&gt;GetEnergyUsage()) &lt; cb-&gt;GetMetal()*(cb-&gt;GetMetalIncome()/cb-&gt;GetMetalUsage()) )
+			Demand[2]++;
+		else
+			Demand[3]++;
+		Demand[4] = 2;
+		if( MetalIsFavorable(0.75f) &amp;&amp; EnergyIsFavorable(0.75f) &amp;&amp; int(G-&gt;Units.size()) &gt;= 5 )
+			Demand[4]+=3;
+		Demand[5] = 1;
+		Demand[6] = 1;
+		Demand[7] = 6;
+		int iBest=-1;
+		for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++)
+		{
+			if( BQ[iBQ]-&gt;builderID == -1 &amp;&amp; U-&gt;udr-&gt;BuildOptions.find(BQ[iBQ]-&gt;creationUDID) != U-&gt;udr-&gt;BuildOptions.end() )
+			{
+				if( iBest == -1 || BQ[iBQ]==Prerequisite || (BQ[iBest]!=Prerequisite &amp;&amp; (Demand[BQ[iBQ]-&gt;type] &gt; Demand[BQ[iBest]-&gt;type] || (BQ[iBest]-&gt;type==BQ[iBQ]-&gt;type &amp;&amp; BQ[iBest]-&gt;creationUD-&gt;HighEnergyDemand &amp;&amp; !BQ[iBQ]-&gt;creationUD-&gt;HighEnergyDemand) ) ) )
+				{
+					iBest=iBQ;
+				}
+			}
+		}
+		if( iBest &gt;= 0 )
+		{
+			BQAssignBuilder(iBest,unit,U);
+			HaveOrders=true;
+			c.id=-U-&gt;BuildQ-&gt;creationUDID;
+		}
+	}
+/*
+	for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++) // Build Quarry Debug
+	{
+		*l&lt;&lt;&quot;\nBQ #&quot;&lt;&lt;iBQ+1;
+		*l&lt;&lt;&quot;:  BID=&quot;&lt;&lt;BQ[iBQ]-&gt;builderID;
+		if( int(BQ[iBQ]-&gt;creationID.size()) &gt; 0 )
+		{
+			*l&lt;&lt;&quot; CID=&quot;&lt;&lt;BQ[iBQ]-&gt;creationID.front();
+		}
+		*l&lt;&lt;&quot; CUDID=&quot;&lt;&lt;BQ[iBQ]-&gt;creationUDID;
+	}
+*/
+	if( int(U-&gt;URepair.size()) &gt; 0 )
+	{
+		while( int(U-&gt;URepair.size()) &gt; 0 &amp;&amp; ( cb-&gt;GetUnitDef(U-&gt;URepair.begin()-&gt;first) == 0 || cb-&gt;GetUnitHealth(U-&gt;URepair.begin()-&gt;first) == cb-&gt;GetUnitMaxHealth(U-&gt;URepair.begin()-&gt;first) ) )
+			U-&gt;URepair.erase(U-&gt;URepair.begin()-&gt;first);
+
+		if( int(U-&gt;URepair.size()) &gt; 0 )
+		{
+			c.id = CMD_REPAIR;
+			c.params.push_back(U-&gt;URepair.begin()-&gt;first);
+			cb-&gt;GiveOrder(unit, &amp;c);
+			return;
+		}
+	}
+	if( !HaveOrders &amp;&amp; U-&gt;ud-&gt;canResurrect &amp;&amp; U-&gt;ud-&gt;speed &gt; 0 )
+	{
+		UpdateKnownFeatures(unit,U);
+		if( int(ResDebris.size()) &gt; 0 )
+		{
+			int iBest=-1;
+			float3 Pos = cb-&gt;GetUnitPos(unit);
+			float3 debPos;
+			for( map&lt;int,float3&gt;::iterator iR=ResDebris.begin(); iR!=ResDebris.end(); iR++ )
+			{
+				if( (iBest == -1 || Pos.distance(debPos) &gt; Pos.distance(iR-&gt;second)) &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;mapBody,iR-&gt;second) )
+				{
+					iBest = iR-&gt;first;
+					debPos= ResDebris.find(iBest)-&gt;second;
+				}
+			}
+			if( iBest != -1 )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is resurrecting.&quot;;
+				c.id=CMD_RESURRECT;
+//				c.params.push_back(iBest);
+				c.params.push_back(debPos.x); // ! Work Around   Spring Version: v0.74b3
+				c.params.push_back(debPos.y);
+				c.params.push_back(debPos.z);
+				c.params.push_back(25.0f);
+				cb-&gt;GiveOrder(unit, &amp;c);
+				float fTime=Pos.distance(debPos)/(U-&gt;ud-&gt;speed/3.0);
+				U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+1500+30*int(fTime);
+				ResDebris.erase(iBest);
+				return;
+			}
+		}
+	}
+	if( !HaveOrders &amp;&amp; U-&gt;ud-&gt;canReclaim &amp;&amp; U-&gt;ud-&gt;speed &gt; 0 &amp;&amp; !U-&gt;ud-&gt;isCommander )
+	{
+		while( int(Decomission.size()) &gt; 0 &amp;&amp; cb-&gt;GetUnitDef(*Decomission.begin()) == 0 )
+		{
+			Decomission.erase(*Decomission.begin());
+		}
+		if( int(Decomission.size()) &gt; 0 &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;mapBody,cb-&gt;GetUnitPos(*Decomission.begin())) )
+		{
+//			*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/Decomissioning.&quot;;
+			c.id=CMD_RECLAIM;
+			c.params.push_back(*Decomission.begin());
+			cb-&gt;GiveOrder(unit, &amp;c);
+			return;
+		}
+		if( int(FeatureDebris.size()) &gt; 0 &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;mapBody,FeatureDebris.begin()-&gt;second) )
+		{
+			map&lt;int,float3&gt;::iterator i=FeatureDebris.begin();
+			float3 fPos = i-&gt;second;
+
+			int *F = new int[1];
+			if( cb-&gt;GetFeatures(F,1,i-&gt;second,20.0) == 1 )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/Clearing.&quot;;
+				c.id=CMD_RECLAIM;
+				c.params.push_back(fPos.x); // ! Work Around   Spring Version: v0.74b3
+				c.params.push_back(fPos.y);
+				c.params.push_back(fPos.z);
+				c.params.push_back(80.0);
+				cb-&gt;GiveOrder(unit, &amp;c);
+
+				float fTime=cb-&gt;GetUnitPos(unit).distance(fPos)/(U-&gt;ud-&gt;speed/3.0);
+				U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+150+30*int(fTime);
+				FeatureDebris.erase(i-&gt;first);
+				delete [] F;
+				return;
+			}
+			delete [] F;
+			FeatureDebris.erase(i-&gt;first);
+		}
+		if( cb-&gt;GetMetal() &lt; 0.15*cb-&gt;GetMetalStorage() || !MetalIsFavorable(0.5f) )
+		{
+			UpdateKnownFeatures(unit,U);
+			if( int(MetalDebris.size()) &gt; 0 )
+			{
+				int iBest=-1;
+				float3 Pos = cb-&gt;GetUnitPos(unit);
+				float3 debPos;
+				for( map&lt;int,float3&gt;::iterator iM=MetalDebris.begin(); iM!=MetalDebris.end(); iM++ )
+				{
+					if( (iBest == -1 || Pos.distance(debPos) &gt; Pos.distance(iM-&gt;second)) &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;mapBody,iM-&gt;second) )
+					{
+						iBest = iM-&gt;first;
+						debPos = iM-&gt;second;
+					}
+				}
+				if( iBest != -1 )
+				{
+//					*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/E Gathering.&quot;;
+					c.id=CMD_RECLAIM;
+//					c.params.push_back(iBest);
+					c.params.push_back(debPos.x); // ! Work Around   Spring Version: v0.74b3
+					c.params.push_back(debPos.y);
+					c.params.push_back(debPos.z);
+					c.params.push_back(25.0f);
+					cb-&gt;GiveOrder(unit, &amp;c);
+
+					float fTime=Pos.distance(debPos)/(U-&gt;ud-&gt;speed/3.0);
+					U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+1500+30*int(fTime);
+					MetalDebris.erase(iBest);
+					return;
+				}
+			}
+		}
+		if( cb-&gt;GetEnergy() &lt; 0.15*cb-&gt;GetEnergyStorage() || !EnergyIsFavorable(0.5f) )
+		{
+			UpdateKnownFeatures(unit,U);
+			if( int(EnergyDebris.size()) &gt; 0 )
+			{
+				int iBest=-1;
+				float3 Pos = cb-&gt;GetUnitPos(unit);
+				float3 debPos;
+				for( map&lt;int,float3&gt;::iterator iE=EnergyDebris.begin(); iE!=EnergyDebris.end(); iE++ )
+				{
+					if( (iBest == -1 || Pos.distance(debPos) &gt; Pos.distance(iE-&gt;second)) &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;mapBody,iE-&gt;second) )
+					{
+						iBest = iE-&gt;first;
+						debPos = iE-&gt;second;
+					}
+				}
+				if( iBest != -1 )
+				{
+//					*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/M Gathering.&quot;;
+					c.id=CMD_RECLAIM;
+					c.params.push_back(debPos.x); // ! Work Around   Spring Version: v0.74b3
+					c.params.push_back(debPos.y);
+					c.params.push_back(debPos.z);
+					c.params.push_back(25.0f);
+					cb-&gt;GiveOrder(unit, &amp;c);
+					float fTime=Pos.distance(debPos)/(U-&gt;ud-&gt;speed/3.0);
+					U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+1500+30*int(fTime);
+					EnergyDebris.erase(iBest);
+					return;
+				}
+			}
+		}
+	}
+	// If this unit has nothing else to do, and resources are favorable, continuously build military units
+	if( !HaveOrders &amp;&amp; BQSize[0]&lt;40 &amp;&amp; MetalIsFavorable(0.35f,0.94f) &amp;&amp; EnergyIsFavorable(0.70f,0.94f) )
+	{
+		vector&lt;int&gt; build;
+		for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=U-&gt;udr-&gt;BuildOptions.begin(); iB!=U-&gt;udr-&gt;BuildOptions.end(); iB++ )
+		{
+			if( iB-&gt;second-&gt;CanBeBuilt )
+			{
+				for( int iBL=0; iBL&lt;iB-&gt;second-&gt;ListSize; iBL++ )
+				{
+					if( iB-&gt;second-&gt;List[iBL]-&gt;RBL-&gt;Name == &quot;Mobile Anti-Land/Air&quot; ||
+						(iB-&gt;second-&gt;List[iBL]-&gt;RBL-&gt;Name == &quot;Mobile Anti-Naval&quot; &amp;&amp; iB-&gt;second-&gt;List[iBL]-&gt;RBL-&gt;priority &gt; 0 ) )
+					{
+						build.push_back(iB-&gt;first);
+						break;
+					}
+				}
+			}
+		}
+
+		if( int(build.size()) &gt; 0 )
+		{
+			int iRan=rand()%int(build.size());
+				BQAdd(&amp;UDR-&gt;UDR.find(U-&gt;udr-&gt;BuildOptions.find(build.at(iRan))-&gt;first)-&gt;second,0,1);
+			BQAssignBuilder(BQSize[0]-1,unit,U);
+			c.id=-U-&gt;BuildQ-&gt;creationUDID;
+			HaveOrders=true;
+		}
+	}
+	if( HaveOrders &amp;&amp; c.id &lt; 0 ) // Has Build Orders
+	{
+		if( int(U-&gt;BuildQ-&gt;creationID.size()) &gt; 0 )
+		{
+//			*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Repair/Building&quot;;
+			c.id = CMD_REPAIR;
+			c.params.push_back(U-&gt;BuildQ-&gt;creationID.front());
+			cb-&gt;GiveOrder(unit, &amp;c);
+			return;
+		}
+
+		const UnitDef *bd=U-&gt;BuildQ-&gt;creationUD-&gt;ud;
+		if( U-&gt;BuildQ-&gt;RS != 0 )
+		{
+			if( U-&gt;BuildQ-&gt;RS-&gt;unitID &gt; -1 &amp;&amp; U-&gt;BuildQ-&gt;RS-&gt;enemy )
+			{
+				if( U-&gt;ud-&gt;canCapture )
+				{
+//					*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Capture/Building.&quot;;
+					c.id = CMD_CAPTURE;
+					c.params.push_back(U-&gt;BuildQ-&gt;RS-&gt;unitID);
+					cb-&gt;GiveOrder(unit, &amp;c);
+				}
+				else if( U-&gt;ud-&gt;canReclaim )
+				{
+//					*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/Building.&quot;;
+					c.id = CMD_RECLAIM;
+					c.params.push_back(U-&gt;BuildQ-&gt;RS-&gt;unitID);
+					cb-&gt;GiveOrder(unit, &amp;c);
+				}
+				else
+				{
+					*l&lt;&lt;&quot;\nWARNING: Can Not Reclaim/Capture Enemy&quot;;
+					BQAssignBuilder(U-&gt;BuildQ-&gt;index,-1,0); // unassign builder
+				}
+				return;
+			}
+			if( U-&gt;BuildQ-&gt;RS-&gt;BuildOptions.find(bd-&gt;id)-&gt;second.RBRanked )
+			{
+				BQRemove(U-&gt;BuildQ-&gt;index);
+				return;
+			}
+		}
+		float3 fBuildPos = BP-&gt;FindBuildPosition(U-&gt;BuildQ);
+		if( !cb-&gt;CanBuildAt(bd,fBuildPos) )
+		{
+			if( U-&gt;ud-&gt;speed==0.0 &amp;&amp; bd-&gt;speed&gt;0.0 ) { fBuildPos=cb-&gt;GetUnitPos(unit); } // Fix for gundam v1.1 mod(CanBuildAt almost always fails).  Unfortunately this condition assumes that all immobile constructers build mobile units at their center
+			else if( U-&gt;BuildQ-&gt;RS != 0 &amp;&amp; U-&gt;BuildQ-&gt;RS-&gt;unitID &gt; -1 &amp;&amp; cb-&gt;GetUnitTeam(U-&gt;BuildQ-&gt;RS-&gt;builderID) == cb-&gt;GetUnitTeam(U-&gt;BuildQ-&gt;RS-&gt;unitID) &amp;&amp; U-&gt;ud-&gt;canReclaim )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/Upgrade/Building.&quot;;
+				c.id = CMD_RECLAIM;
+				c.params.push_back(U-&gt;BuildQ-&gt;RS-&gt;unitID);
+				cb-&gt;GiveOrder(unit, &amp;c);
+				return;
+			}
+			else
+			{
+				if( !U-&gt;BuildQ-&gt;creationUD-&gt;CanBeBuilt ) // usually this means an intended limited resource is no longer available
+				{
+					BQRemove(U-&gt;BuildQ-&gt;index);
+					U-&gt;commandTimeOut=1;
+				}
+				else
+				{
+					*l&lt;&lt;&quot;\nWARNING: (&quot;&lt;&lt;unit&lt;&lt;&quot;)&quot;&lt;&lt;U-&gt;ud-&gt;humanName&lt;&lt;&quot; can not build a '&quot;&lt;&lt;bd-&gt;humanName&lt;&lt;&quot;' at selected position: x=&quot;&lt;&lt;fBuildPos.x&lt;&lt;&quot; y=&quot;&lt;&lt;fBuildPos.y&lt;&lt;&quot; z=&quot;&lt;&lt;fBuildPos.z;
+					BQAssignBuilder(U-&gt;BuildQ-&gt;index,-1,0); // unassign builder
+				}
+				return;
+			}
+		}
+
+//		*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Building a &quot;+bd-&gt;humanName+&quot;(&quot;&lt;&lt;-c.id&lt;&lt;&quot;)&quot;;
+		c.params.push_back(fBuildPos.x);
+		c.params.push_back(fBuildPos.y);
+		c.params.push_back(fBuildPos.z);
+
+		if( int(U-&gt;BuildQ-&gt;creationUD-&gt;BuildOptions.size()) &gt; 0 )
+		{
+			float3 fBuildPosH = fBuildPos;
+			fBuildPosH.z+=48.0f;
+//			fBuildPosH.y=cb-&gt;GetElevation(fBuildPosH.x,fBuildPosH.z);
+			float3 fBuildPosL = fBuildPos;
+			fBuildPosL.z-=48.0f;
+//			fBuildPosL.y=cb-&gt;GetElevation(fBuildPosL.x,fBuildPosL.z);
+			if( fBuildPos.z/8 &gt;= cb-&gt;GetMapHeight()-5-(U-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;ysize/2) ||
+				(cb-&gt;CanBuildAt(bd,fBuildPosL) &amp;&amp; !cb-&gt;CanBuildAt(bd,fBuildPosH) ) )
+				c.params.push_back(2);
+		}
+		cb-&gt;GiveOrder(unit, &amp;c);
+		return;
+	}
+	if( !HaveOrders &amp;&amp; U-&gt;ud-&gt;canAssist ) // Assist Build
+	{
+		if( U-&gt;ud-&gt;speed &gt; 0 )
+		{
+			int BestIndex=-1;
+			float3 fPos=cb-&gt;GetUnitPos(unit);
+			float BestDis;
+			for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++)
+			{
+				if( BQ[iBQ]-&gt;builderID &gt;= 0 &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;mapBody,cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID)) )
+				{	
+					float Dis=fPos.distance(cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID));
+					if( BestIndex == -1 || Dis &lt; BestDis )
+					{
+						BestIndex=iBQ;
+						BestDis=Dis;
+					}
+				}
+			}
+
+			if( BestIndex &gt; 0 )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Assisting &quot;&lt;&lt;BQ[BestIndex]-&gt;builderUI-&gt;ud-&gt;humanName;
+				c.id = CMD_GUARD;
+				c.params.push_back(BQ[BestIndex]-&gt;builderID);
+				//c.timeOut=cb-&gt;GetCurrentFrame()+360;
+				U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+600;
+				cb-&gt;GiveOrder(unit, &amp;c);
+				return;
+			}
+		}
+		else
+		{
+			for( map&lt;int,UnitInfo*&gt;::iterator i = U-&gt;UAssist.begin(); i != U-&gt;UAssist.end(); i++ )
+			{
+				if( i-&gt;second-&gt;BuildQ != 0 )
+				{
+					c.id = CMD_GUARD;
+					c.params.push_back(i-&gt;first);
+					U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+600;
+					cb-&gt;GiveOrder(unit, &amp;c);
+					return;
+				}
+			}
+		}
+	}
+//	*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Waiting&quot;;
+	U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+600;
+
+	if( U-&gt;ud-&gt;speed == 0.0 ) // Work Around  Spring Version: v0.74.b1
+	{
+		return;
+	}
+
+	c.id = CMD_WAIT;
+	//c.timeOut=cb-&gt;GetCurrentFrame()+600;
+	cb-&gt;GiveOrder(unit, &amp;c);
+}
+/*
+void cBuilder::UBuilderDamaged(const int&amp; unit, int attacker, float3 dir)
+{
+}
+*/
+bool cBuilder::UBuilderMoveFailed(const int&amp; unit, UnitInfo *U)
+{
+	int iF;
+	int *F = new int[10];
+	int FSize = cb-&gt;GetFeatures(F,10,cb-&gt;GetUnitPos(unit),90);
+	for( iF=0; iF &lt; FSize; iF++ )
+		if( cb-&gt;GetFeatureDef(F[iF])-&gt;destructable )
+			break;
+	if( iF &lt; FSize )
+	{
+		if( U-&gt;ud-&gt;canReclaim )
+		{
+//			*l&lt;&lt;&quot; &quot;+UBuilder.find(unit)-&gt;second.ud-&gt;name+&quot; is Reclaiming &quot;;
+			Command c;
+			c.id=CMD_RECLAIM;
+			float3 fPos = cb-&gt;GetUnitPos(unit);
+			c.params.push_back(fPos.x); // ! Work Around   Spring Version: v0.74b3
+			c.params.push_back(fPos.y);
+			c.params.push_back(fPos.z);
+			c.params.push_back(90.0);
+			//c.params.push_back(F[0]);
+
+			U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+1200;
+			cb-&gt;GiveOrder(unit, &amp;c);
+
+			fPos = cb-&gt;GetFeaturePos(F[iF]);
+			delete [] F;
+			return true;
+		}
+		else
+		{
+			if( FeatureDebris.find(F[iF]) == FeatureDebris.end() ) // Add to reclaim list
+			{
+				FeatureDebris.insert(ifPair(F[iF],cb-&gt;GetUnitPos(unit)));
+			}
+		}
+	}
+	delete [] F;
+	return false;
+}
+
+void cBuilder::HandleEvent(const IGlobalAI::PlayerCommandEvent *pce)
+{
+	for( vector&lt;int&gt;::const_iterator i=pce-&gt;units.begin(); i!=pce-&gt;units.end(); i++ )
+	{
+		if( UBuilder.find(*i) != UBuilder.end() )
+		{
+			UnitInfo* U = UBuilder.find(*i)-&gt;second;
+			if( U-&gt;BuildQ != 0 )
+			{
+				if( pce-&gt;command.options == RIGHT_MOUSE_KEY &amp;&amp; pce-&gt;command.id &lt; 0 )
+				{
+					if( int(U-&gt;BuildQ-&gt;creationID.size())&gt;0 &amp;&amp; U-&gt;BuildQ-&gt;creationUDID == -pce-&gt;command.id )
+					{
+						G-&gt;UnitDestroyed(U-&gt;BuildQ-&gt;creationID.front(),-1);
+					}
+				}
+				else if( pce-&gt;command.options != SHIFT_KEY )
+					BQAssignBuilder(U-&gt;BuildQ-&gt;index,-1,0);
+			}
+		}
+	}
+}
+
+void cBuilder::UpdateUDRCost()
+{
+//	if( MCostUpdate &lt; 0.2*MCostLimit &amp;&amp; MCostUpdate &gt; -0.2*MCostLimit &amp;&amp;
+//		ECostUpdate &lt; 0.2*ECostLimit &amp;&amp; ECostUpdate &gt; -0.2*ECostLimit )
+//		return;
+	MCostLimit = cb-&gt;GetMetalIncome()+PM-&gt;MetalProduction+0.15*PM-&gt;MetalProductionEtoM;
+	ECostLimit = cb-&gt;GetEnergyIncome();
+	if( MCostLimit &gt; 110.0 || (UDR-&gt;BLMetal-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLMetalL-&gt;UDefSize == 0) )
+		MCostLimit=9.9e8;
+	if( ECostLimit &gt; 110.0*UDR-&gt;EnergyToMetalRatio || (UDR-&gt;BLEnergy-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLEnergyL-&gt;UDefSize == 0) )
+		ECostLimit=9.9e8;
+
+//	*l&lt;&lt;&quot;\n Rechecking Unit Costs and Determining Active BL Options ...&quot;;
+	for( map&lt;int,sRAIUnitDef&gt;::iterator i=UDR-&gt;UDR.begin(); i!=UDR-&gt;UDR.end(); i++ )
+	{
+		sRAIUnitDef *udr = &amp;i-&gt;second;
+		if( udr-&gt;MetalPCost &lt; MCostLimit &amp;&amp; udr-&gt;EnergyPCost &lt; ECostLimit )
+		{
+			if( udr-&gt;RBCost )
+			{	// enabling
+				udr-&gt;RBCost = false;
+				udr-&gt;CheckBuildOptions();
+			}
+		}
+		else if( udr-&gt;MetalPCost &gt; 1.5*MCostLimit || udr-&gt;EnergyPCost &gt; 1.5*ECostLimit )
+		{
+			if( !udr-&gt;RBCost )
+			{	// disabling
+				udr-&gt;RBCost = true;
+				udr-&gt;CheckBuildOptions();
+			}
+		}
+	}
+	for(int iBL=0; iBL&lt;UDR-&gt;BLSize; iBL++)
+	{
+		if( UDR-&gt;BL[iBL]-&gt;minUnits &gt; 0 &amp;&amp; UDR-&gt;BL[iBL]-&gt;UDefSize &gt; 0 &amp;&amp; UDR-&gt;BL[iBL]-&gt;UDefSize &gt; UDR-&gt;BL[iBL]-&gt;UDefActive )
+		{
+//			*l&lt;&lt;&quot;\n Determining Cheapest for '&quot;&lt;&lt;UDR-&gt;BL[iBL]-&gt;Name&lt;&lt;&quot;' BuildList ...&quot;;
+			sRAIUnitDef *BestLandudr=0,*BestWaterudr=0; // NOTE: the same udr may be selected for both, may also already be enabled
+			float BestLandCost,BestWaterCost;
+			bool BestLandCanBuildConstructers,BestWaterCanBuildConstructers; // only used in determining the cheapest constructer
+
+			for(int iU=0; iU&lt;UDR-&gt;BL[iBL]-&gt;UDefSize; iU++)
+			{
+				sRAIUnitDef *udr=UDR-&gt;BL[iBL]-&gt;UDef[iU]-&gt;RUD;
+				if( !udr-&gt;Disabled &amp;&amp; udr-&gt;HasPrerequisite )
+				{
+					bool CanBuildConstructers = false; // only used in determining the cheapest constructer
+					for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=udr-&gt;BuildOptions.begin(); iB!=udr-&gt;BuildOptions.end(); iB++)
+					{
+						if( !iB-&gt;second-&gt;Disabled &amp;&amp; int(iB-&gt;second-&gt;BuildOptions.size()) &gt; 0 )
+						{
+							CanBuildConstructers = true;
+							break;
+						}
+					}
+					float Cost = udr-&gt;MetalPCost + udr-&gt;EnergyPCost*UDR-&gt;EnergyToMetalRatio;
+					if( udr-&gt;ud-&gt;minWaterDepth &lt; 0 )
+					{
+						if( BestLandudr == 0 ||
+							(CanBuildConstructers &amp;&amp; !BestLandCanBuildConstructers) ||
+							(Cost &lt; BestLandCost &amp;&amp; (CanBuildConstructers || !BestLandCanBuildConstructers) ) )
+						{
+							BestLandudr = udr;
+							BestLandCost = Cost;
+							BestLandCanBuildConstructers = CanBuildConstructers;
+						}
+					}
+					if( udr-&gt;ud-&gt;maxWaterDepth &gt; -G-&gt;TM-&gt;MaxWaterDepth || udr-&gt;ud-&gt;floater )
+					{
+						if( BestWaterudr == 0 ||
+							(CanBuildConstructers &amp;&amp; !BestWaterCanBuildConstructers) ||
+							(Cost &lt; BestWaterCost &amp;&amp; (CanBuildConstructers || !BestWaterCanBuildConstructers) ) )
+						{
+							BestWaterudr = udr;
+							BestWaterCost = Cost;
+							BestWaterCanBuildConstructers = CanBuildConstructers;
+						}
+					}
+				}
+			}
+			if( BestLandudr != 0 &amp;&amp; (BestWaterudr == 0 || BestLandCost &lt; 3*BestWaterCost) )
+			{
+//				*l&lt;&lt;&quot;\nBestLandudr=&quot;&lt;&lt;BestLandudr-&gt;ud-&gt;humanName;
+				if( BestLandudr-&gt;RBCost )
+				{
+					BestLandudr-&gt;RBCost = false;
+					BestLandudr-&gt;CheckBuildOptions();
+				}
+			}
+			if( BestWaterudr != 0 &amp;&amp; (BestLandudr == 0 || BestWaterCost &lt; 3*BestLandCost) )
+			{
+//				*l&lt;&lt;&quot;\nBestWaterudr=&quot;&lt;&lt;BestWaterudr-&gt;ud-&gt;humanName;
+				if( BestWaterudr-&gt;RBCost )
+				{
+					BestWaterudr-&gt;RBCost = false;
+					BestWaterudr-&gt;CheckBuildOptions();
+				}
+			}
+		}
+	}
+	for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++)
+	{
+		if( BQ[iBQ]-&gt;creationUD-&gt;RBCost )
+		{
+			*l&lt;&lt;&quot;\n (Low Resources) Abandoning Construction: &quot;&lt;&lt;BQ[iBQ]-&gt;creationUD-&gt;ud-&gt;humanName;
+			BQRemove(iBQ--);
+		}
+	}
+/*
+	*l&lt;&lt;&quot;\n\n Displaying Active Build List Options ...&quot;;
+	for(int iBL=0; iBL&lt;UDR-&gt;BLActive; iBL++ )
+	{
+		*l&lt;&lt;&quot;\n  &quot;&lt;&lt;UDR-&gt;BL[iBL]-&gt;Name&lt;&lt;&quot; BuildList: &quot;;
+		for(int iBO=0; iBO&lt;UDR-&gt;BL[iBL]-&gt;UDefActive; iBO++)
+			*l&lt;&lt;&quot; &quot;+UDR-&gt;BL[iBL]-&gt;UDef[iBO]-&gt;RUD-&gt;ud-&gt;humanName+&quot; &quot;;
+	}
+	*l&lt;&lt;&quot;\n\n&quot;;
+*/
+}
+
+void cBuilder::UpdateKnownFeatures(const int&amp; unit, UnitInfo *U)
+{
+/*
+	*l&lt;&lt;&quot;\nUpdate: M&quot;;
+	set&lt;int&gt; deletion;
+	for( map&lt;int,FeatureDef*&gt;::iterator iM=MetalDebris.begin(); iM!=MetalDebris.end(); iM++ )
+	{
+		if( cb-&gt;GetFeatureDef(iM-&gt;first) == 0 )
+			deletion.insert(iM-&gt;first);
+	}
+	*l&lt;&lt;&quot;s=&quot;&lt;&lt;deletion.size();
+	for( set&lt;int&gt;::iterator iM=deletion.begin(); iM!=deletion.end(); iM++ )
+	{
+		MetalDebris.erase(*iM);
+	}
+	deletion.clear();
+	*l&lt;&lt;&quot;\nUpdate: E&quot;;
+	for( map&lt;int,FeatureDef*&gt;::iterator iE=EnergyDebris.begin(); iE!=EnergyDebris.end(); iE++ )
+	{
+		if( cb-&gt;GetFeatureHealth(iE-&gt;first) == 0.0f )
+			deletion.insert(iE-&gt;first);
+	}
+	*l&lt;&lt;&quot;s=&quot;&lt;&lt;deletion.size();
+	for( set&lt;int&gt;::iterator iE=deletion.begin(); iE!=deletion.end(); iE++ )
+	{
+		EnergyDebris.erase(*iE);
+	}
+*/
+	int *F = new int[15];
+	int FeatureSize = cb-&gt;GetFeatures(F,15,cb-&gt;GetUnitPos(unit),750);
+	for( int iF=0; iF&lt;FeatureSize; iF++ )
+	{
+		const FeatureDef* fd = cb-&gt;GetFeatureDef(F[iF]);
+		if( fd-&gt;reclaimable )
+		{
+			if( fd-&gt;metal &gt;= 40 )
+			{
+				if( MetalDebris.find(F[iF]) == MetalDebris.end() )
+					MetalDebris.insert(ifPair(F[iF],cb-&gt;GetFeaturePos(F[iF])));
+			}
+			if( fd-&gt;energy &gt;= 40 )
+			{
+				if( EnergyDebris.find(F[iF]) == EnergyDebris.end() )
+					EnergyDebris.insert(ifPair(F[iF],cb-&gt;GetFeaturePos(F[iF])));
+			}
+			if( UDRResurrect.find(fd-&gt;myName) != UDRResurrect.end() )
+			{
+				if( ResDebris.find(F[iF]) == ResDebris.end() )
+					ResDebris.insert(ifPair(F[iF],cb-&gt;GetFeaturePos(F[iF])));
+			}
+		}
+	}
+	delete [] F;
+}
+
+bool cBuilder::MetalIsFavorable(float storage,float production)
+{
+	if( UDR-&gt;BLMetalL-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLMetal-&gt;UDefSize == 0 )
+		return true;
+	if( cb-&gt;GetMetal() &gt; storage*cb-&gt;GetMetalStorage() &amp;&amp; cb-&gt;GetMetalIncome() &gt; production*(cb-&gt;GetMetalUsage()-ConDrainMetalDebug) )
+		return true;
+	return false;
+}
+
+bool cBuilder::EnergyIsFavorable(float storage,float production)
+{
+	if( UDR-&gt;BLEnergyL-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLEnergy-&gt;UDefSize == 0 )
+		return true;
+	if( cb-&gt;GetEnergy() &gt; storage*cb-&gt;GetEnergyStorage() &amp;&amp; cb-&gt;GetEnergyIncome() &gt; production*(cb-&gt;GetEnergyUsage()-ConDrainEnergyDebug) )
+		return true;
+	return false;
+}
+
+void cBuilder::BQAssignBuilder(int index, const int&amp; unit, UnitInfo* U)
+{
+//*l&lt;&lt;&quot;\nBQAssignBuilder(&quot;&lt;&lt;index&lt;&lt;&quot;,&quot;&lt;&lt;unit&lt;&lt;&quot;,-)&quot;;
+	if( BQ[index]-&gt;builderID &gt;= 0 )
+	{
+		const UnitDef* ud=BQ[index]-&gt;builderUI-&gt;ud;
+		ConEnergyLost+=int(ud-&gt;energyCost);
+		ConMetalLost+=int(ud-&gt;metalCost);
+		ConEnergyDrain+=int(ud-&gt;energyCost/(ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+		ConMetalDrain+=int(ud-&gt;metalCost/(ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+
+		BQ[index]-&gt;builderUI-&gt;BuildQ=0;
+		if( U!= 0 &amp;&amp; U-&gt;BuildQ != 0 )
+			U-&gt;BuildQ-&gt;builderID=-1;
+		if( BQ[index]-&gt;RS != 0 )
+		{
+			BQ[index]-&gt;RS-&gt;builderID = -1;
+			BQ[index]-&gt;SetRS(0);
+		}
+	}
+	BQ[index]-&gt;builderID=unit;
+	BQ[index]-&gt;builderUI=U;
+	if( unit &gt;= 0 )
+	{
+		BQ[index]-&gt;deletionFrame=1200+cb-&gt;GetCurrentFrame();
+		ConEnergyLost-=int(U-&gt;ud-&gt;energyCost);
+		ConMetalLost-=int(U-&gt;ud-&gt;metalCost);
+		ConEnergyDrain-=int(U-&gt;ud-&gt;energyCost/(U-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+		ConMetalDrain-=int(U-&gt;ud-&gt;metalCost/(U-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+		BQ[index]-&gt;builderUI-&gt;BuildQ=BQ[index];
+		float3 pos = cb-&gt;GetUnitPos(unit);
+		int mapbody=G-&gt;GetCurrentMapBody(BQ[index]-&gt;creationUD-&gt;ud,pos);
+		if( BP-&gt;NeedsResourceSpot(BQ[index]-&gt;creationUD-&gt;ud,mapbody) )
+		{
+			sResourceSpot* RS = BP-&gt;FindResourceSpot(pos,BQ[index]-&gt;creationUD-&gt;ud,U-&gt;mapBody);
+			BQ[index]-&gt;SetRS(RS);
+			if( RS != 0 )
+			{
+				BQ[index]-&gt;RS-&gt;builderID = unit;
+				BQ[index]-&gt;RS-&gt;builderUI = U;
+			}
+		}
+	}
+}
+/*
+void cBuilder::BQAssignConstruct(int index, const int&amp; unit, sRAIUnitDef *udr)
+{
+
+}
+*/
+void cBuilder::BQAdd(sRAIUnitDef *udr, sRAIBuildList *BL, int type)
+{
+//	*l&lt;&lt;&quot;\n (New Build Order Added): &quot;+udr-&gt;ud-&gt;humanName;
+	BQ[BQSize[0]] = new sBuildQuarry(BL);
+	BQ[BQSize[0]]-&gt;index = BQSize[0];
+	BQ[BQSize[0]]-&gt;creationUD=udr;
+	BQ[BQSize[0]]-&gt;creationUDID=udr-&gt;ud-&gt;id;
+	BQ[BQSize[0]]-&gt;type = type;
+	BQ[BQSize[0]]-&gt;deletionFrame=1200+cb-&gt;GetCurrentFrame();
+	BQSize[0]++;
+	BQSize[type]++;
+	udr-&gt;UnitConstructs++;
+	udr-&gt;CheckUnitLimit();
+	ConEnergyLost+=int(udr-&gt;ud-&gt;energyCost);
+	ConMetalLost+=int(udr-&gt;ud-&gt;metalCost);
+	ConEnergyDrain+=int(udr-&gt;ud-&gt;energyCost/(udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+	ConMetalDrain+=int(udr-&gt;ud-&gt;metalCost/(udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+	ConEnergyRate+=int(udr-&gt;EnergyDifference);
+	ConMetalRate+=int(udr-&gt;MetalDifference);
+	ConEnergyStorage+=int(udr-&gt;ud-&gt;energyStorage);
+	ConMetalStorage+=int(udr-&gt;ud-&gt;metalStorage);
+}
+
+void cBuilder::BQRemove(int index)
+{
+	if( BQ[index] == Prerequisite )
+	{
+		Prerequisite = 0;
+	}
+
+	sRAIUnitDef *udr=BQ[index]-&gt;creationUD;
+	if( BQ[index]-&gt;builderID &gt;= 0 )
+	{
+		ConDrainEnergyDebug=udr-&gt;ud-&gt;energyCost/(udr-&gt;ud-&gt;buildTime/BQ[index]-&gt;builderUI-&gt;ud-&gt;buildSpeed);
+		ConDrainMetalDebug=udr-&gt;ud-&gt;metalCost/(udr-&gt;ud-&gt;buildTime/BQ[index]-&gt;builderUI-&gt;ud-&gt;buildSpeed);
+		ConDrainFrameDebug=cb-&gt;GetCurrentFrame();
+	}
+
+	BQAssignBuilder(index,-1,0);
+	BQSize[0]--;
+	BQSize[BQ[index]-&gt;type]--;
+	udr-&gt;UnitConstructs--;
+	udr-&gt;CheckUnitLimit();
+
+	ConEnergyLost-=int(udr-&gt;ud-&gt;energyCost);
+	ConMetalLost-=int(udr-&gt;ud-&gt;metalCost);
+	ConEnergyDrain-=int(udr-&gt;ud-&gt;energyCost/(udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+	ConMetalDrain-=int(udr-&gt;ud-&gt;metalCost/(udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+
+	ConEnergyRate-=int(udr-&gt;EnergyDifference);
+	ConMetalRate-=int(udr-&gt;MetalDifference);
+	ConEnergyStorage-=int(udr-&gt;ud-&gt;energyStorage);
+	ConMetalStorage-=int(udr-&gt;ud-&gt;metalStorage);
+
+	sBuildQuarry *sTemp=BQ[index];
+	BQ[index]=BQ[BQSize[0]];
+	BQ[BQSize[0]]=sTemp;
+	BQ[index]-&gt;index=index;
+
+	for( list&lt;int&gt;::iterator i=BQ[BQSize[0]]-&gt;creationID.begin(); i!=BQ[BQSize[0]]-&gt;creationID.end(); i++ )
+		if( UConstruction.find(*i) != UConstruction.end() )
+		{
+			if( cb-&gt;UnitBeingBuilt(*i) )
+				UConstruction.find(*i)-&gt;second.BQAbandoned=true;
+			else
+				UConstruction.erase(*i); // Remove from construction list
+		}
+
+	delete BQ[BQSize[0]];
+}

Added: trunk/AI/Global/RAI-0.553/Builder.h
===================================================================
--- trunk/AI/Global/RAI-0.553/Builder.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/Builder.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,134 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_BUILDER_H
+#define RAI_BUILDER_H
+
+struct sBuildQuarry;
+class cBuilder;
+
+#include &quot;RAI.h&quot;
+#include &quot;PowerManager.h&quot;
+//#include &lt;map&gt;
+//#include &lt;set&gt;
+#include &lt;deque&gt;
+#include &lt;list&gt;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+
+struct sBuildQuarry
+{
+	sBuildQuarry(sRAIBuildList *buildlist);
+	~sBuildQuarry();
+	bool IsValid(int frame);
+	void SetRS(sResourceSpot *rs);
+
+	int builderID;			// ID of the assigned builder, otherwise -1
+	UnitInfo *builderUI;	// valid if 'builderID' is set
+	list&lt;int&gt; creationID;   // ID of who is being built, I definied this as an array to work around a bug involving misordered calls of UnitDestroyed, UnitCreated - in other words at rare temporary moments this list will hold 2 unit ids.   Spring Version: v0.72b1-0.73b1
+	int creationUDID;		// ID of what is being built
+	sRAIUnitDef *creationUD;// always valid
+	sResourceSpot *RS;		// The resource this must be built at
+	sRAIBuildList *BL;		// used to update unitsActive
+
+	int index;				// stores the index value of its own array
+	int type;				// 1=Normal,2=Energy,3=Metal,4=Constructer,5=Energy Storage,6=Metal Storage,7=prerequisite
+	int deletionFrame;		// If a unit does not choose to build the option by this frame, then delete the Build Quarry
+	int tryCount;			// failed to build, probably due to enemy attacks
+};
+
+class cBuilder
+{
+public:
+	cBuilder(IAICallback *callback, cRAI *global);
+	virtual ~cBuilder();
+
+	void UnitCreated(const int&amp; unit, UnitInfo *U);
+	void UnitFinished(const int&amp; unit, UnitInfo *U);
+	void UnitDestroyed(const int&amp; unit, UnitInfo *U);
+	void UnitAssignBuildList(const int&amp; unit, UnitInfo *U, bool bInitialized=false); // bInitialized is unused, was ment to support a unit changing tasks
+
+	void UBuilderFinished(const int&amp; unit, UnitInfo *U);
+	void UBuilderDestroyed(const int&amp; unit, UnitInfo *U);
+	void UBuilderIdle(const int&amp; unit, UnitInfo *U);
+//	void UBuilderDamaged(const int&amp; unit,int attacker,float3 dir);
+	bool UBuilderMoveFailed(const int&amp; unit, UnitInfo *U); // returns true if a solution was found
+	void HandleEvent(const IGlobalAI::PlayerCommandEvent *pce);
+	void UpdateUDRCost();
+	void UpdateKnownFeatures(const int&amp; unit, UnitInfo *U);
+
+	bool bInitiated;	// initialized as false, set to true after set conditions have been meet, usually about 30-60 frames into the game
+	cPowerManager *PM;
+	cBuilderPlacement *BP;
+
+	map&lt;int,UnitInfo*&gt; UBuilder;	// List of builders, key value = unit ID
+	map&lt;int,UnitInfo*&gt; UNanos;
+	set&lt;int&gt; Decomission;			// Builders will reclaim these units in there free time
+private:
+	cRAI *G;
+	cRAIUnitDefHandler *UDR;// G-&gt;UDH
+	cLogFile *l;			// G-&gt;l
+	IAICallback *cb;		// G-&gt;cb
+
+	float MCostLimit;
+//	float MCostUpdate;
+	float ECostLimit;
+//	float ECostUpdate;
+	float ConDrainEnergyDebug;
+	float ConDrainMetalDebug;
+	int ConDrainFrameDebug;
+	int ConEnergyLost;
+	int ConMetalLost;
+	int ConEnergyDrain;		// How much Energy will be drained when all constructions have started, positive value, does not include contructions that have already begun
+	int ConMetalDrain;		// How much Metal will be drained when all constructions have started, positive value, does not include contructions that have already begun
+	int ConEnergyRate;		// How much extra Energy will be produced when all constructions have completed 
+	int ConMetalRate;		// How much extra Metal will be produced when all constructions have completed
+	int ConEnergyStorage;	// How much extra Energy Storage will there be when all constructions have completed
+	int ConMetalStorage;	// How much extra Metal Storage will there be when all constructions have completed
+	bool MetalIsFavorable(float storage=0.50f,float production=1.0f); // returns true if there is no metal production or the ratio of both is met
+	bool EnergyIsFavorable(float storage=0.50f,float production=1.0f); // returns true if there is no energy production or the ratio of both is met
+
+	sBuildQuarry *BQ[40];
+	sBuildQuarry *Prerequisite; // Limits RAI from building more than one at a time
+	int BQSize[8]; // index 0 = total, other indexs accessed by iType.  Value of index is equal to counter
+	void BQAssignBuilder(int index, const int&amp; unit, UnitInfo* U);
+//	void BQAssignConstruct(int index, const int&amp; unit, sRAIUnitDef *udr);
+	void BQAdd(sRAIUnitDef *udr, sRAIBuildList *BL, int type);
+	void BQRemove(int index);
+
+	struct UnitConstructionInfo
+	{
+		UnitConstructionInfo(sBuildQuarry *BuildQuarry, const int&amp; unit, UnitInfo* UI)
+		{
+			U=UI;
+			unitID = unit;
+			BQ = BuildQuarry;
+			BQ-&gt;creationID.push_front(unit);
+			BQAbandoned=false;
+		};
+		~UnitConstructionInfo()
+		{
+		};
+
+		bool BQAbandoned;
+		sBuildQuarry *BQ; // valid if BQAbandoned=false
+		UnitInfo *U;	// Always valid
+		int unitID;
+	};
+	map&lt;int,UnitConstructionInfo&gt; UConstruction;	// List of what is being built, key value = unit ID
+
+	// due to crash bugs in spring 0.74b3, the position is about the only safe information that could be gathered and stored.
+	typedef pair&lt;int,float3&gt; ifPair;
+	map&lt;int,float3&gt; FeatureDebris;			// List of features that are blocking the paths of our units
+	typedef pair&lt;int,FeatureDef*&gt; ifdPair;
+	map&lt;int,float3&gt; MetalDebris;			// List of metal reclaimables found
+	map&lt;int,float3&gt; EnergyDebris;			// List of energy reclaimables found
+	map&lt;int,float3&gt; ResDebris;				// List of resurrectables found
+	typedef pair&lt;string,sRAIUnitDef*&gt; srPair;
+	map&lt;string,sRAIUnitDef*&gt; UDRResurrect;	// List of what can be resurrected
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/BuilderPlacement.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/BuilderPlacement.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/BuilderPlacement.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,839 @@
+#include &quot;BuilderPlacement.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+#include &lt;set&gt;
+
+sResourceSpotBO::sResourceSpotBO(sRAIUnitDef* UDR )
+{
+	udr=UDR;
+	CanBuild=false;
+	RBRanged=true;
+	RBBlocked=false;
+	RBRanked=false;
+}
+
+void sResourceSpotBO::CheckBuild()
+{
+	if( RBBlocked || RBRanked || RBRanged )
+	{
+		if( CanBuild )
+		{
+			CanBuild=false;
+			udr-&gt;SetULConstructs(udr-&gt;UnitLimit[1]-1);
+		}
+	}
+	else
+	{
+		if( !CanBuild )
+		{
+			CanBuild=true;
+			udr-&gt;SetULConstructs(udr-&gt;UnitLimit[1]+1);
+		}
+	}
+}
+
+sResourceSpot::sResourceSpot(IAICallback* callback, float3 position, int ID, const FeatureDef* featureUD)
+{
+	cb=callback;
+	featureID=ID;
+	featureD=featureUD;
+	unitID=-1;
+	builderID=-1;
+	location=position;
+	ally=false;
+	enemy=false;
+	if( featureID == -1 ) // metal spot
+	{
+		type=1;
+		searchRadius=cb-&gt;GetExtractorRadius()/2.0f;
+		if( searchRadius &lt; 16.0f )
+			searchRadius = 16.0f;
+	}
+	else // geo spot
+	{
+		type=2;
+		searchRadius=48.0f;
+	}
+	disApart=3;
+//	unitLostFrame=-99999;
+};
+
+void sResourceSpot::CheckBlocked()
+{
+	for( map&lt;int,sResourceSpotBO&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+	{
+		float3 fBuildSite=cb-&gt;ClosestBuildSite(iB-&gt;second.udr-&gt;ud,location,searchRadius,disApart);
+		if( !cb-&gt;CanBuildAt(iB-&gt;second.udr-&gt;ud,fBuildSite) &amp;&amp; (unitID == -1 || enemy || ally ) )
+			iB-&gt;second.RBBlocked=true;
+		else
+			iB-&gt;second.RBBlocked=false;
+		iB-&gt;second.CheckBuild();
+	}
+}
+
+void sResourceSpot::CheckRanked()
+{
+	for( map&lt;int,sResourceSpotBO&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+	{
+		if( unitID == -1 ||
+			( type == 1 &amp;&amp; iB-&gt;second.udr-&gt;ud-&gt;extractsMetal &gt;= 1.5*unitUD-&gt;ud-&gt;extractsMetal ) ||
+			( type == 2 &amp;&amp; iB-&gt;second.udr-&gt;ud-&gt;metalCost &gt;= 1.85*unitUD-&gt;ud-&gt;metalCost &amp;&amp; (unitUD-&gt;ud-&gt;techLevel &lt;= 0 || iB-&gt;second.udr-&gt;ud-&gt;techLevel &gt; unitUD-&gt;ud-&gt;techLevel ) ) )
+		{
+			iB-&gt;second.RBRanked = false;
+		}
+		else
+		{
+			iB-&gt;second.RBRanked = true;
+		}
+		iB-&gt;second.CheckBuild();
+	}
+}
+
+void sResourceSpot::SetRanged(bool inRange)
+{
+	for( map&lt;int,sResourceSpotBO&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+	{
+		iB-&gt;second.RBRanged = !inRange;
+		iB-&gt;second.CheckBuild();
+	}
+}
+
+cBuilderPlacement::cBuilderPlacement(IAICallback* callback, cRAI* global)
+{
+	G=global;
+	l=global-&gt;l;
+	cb=callback;
+
+//	MapW=8.0*cb-&gt;GetMapWidth();
+//	MapH=8.0*cb-&gt;GetMapHeight();
+//	SectorXSize = cb-&gt;GetMapWidth()/32;
+//	SectorZSize = cb-&gt;GetMapHeight()/32;
+//	Sector = new BuildSector[SectorXSize*SectorZSize];
+
+	if( int(G-&gt;Units.size()) == 0 )
+		*l&lt;&lt;&quot;\nERROR: G-&gt;Units&quot;;
+
+	int UnitLimit = 500; //cb-&gt;GetValue();
+	float3 StartLocation=cb-&gt;GetUnitPos(G-&gt;Units.begin()-&gt;first);
+	int MetalSpotLimit = G-&gt;RG-&gt;KMM-&gt;NumSpotsFound;
+	if( MetalSpotLimit &gt; UnitLimit/4 )
+		MetalSpotLimit = UnitLimit/4;
+	if( MetalSpotLimit &gt; 350 )
+		MetalSpotLimit = 350;
+	int GeoSpotLimit = int(G-&gt;RG-&gt;GeoSpot.size());
+	if( GeoSpotLimit &gt; UnitLimit/25 )
+		GeoSpotLimit = UnitLimit/25;
+	if( GeoSpotLimit &gt; 50 )
+		GeoSpotLimit = 50;
+	ResourceSize=0;
+
+	*l&lt;&lt;&quot;\n    Metal Spots : &quot;&lt;&lt;MetalSpotLimit;
+	*l&lt;&lt;&quot;\n      Geo Spots : &quot;&lt;&lt;GeoSpotLimit;
+
+	set&lt;int&gt; Seleted;
+	for( int iM=0; iM &lt; MetalSpotLimit; iM++ ) // Finding Nearest Metal Spots
+	{
+		int iBest=-1;
+		float fBest=0;
+		for( int iS=0; iS&lt;int(G-&gt;RG-&gt;KMM-&gt;VectoredSpots.size()); iS++ )
+		{
+			if( Seleted.find(iS) == Seleted.end() )
+			{
+				if( iBest == -1 || StartLocation.distance2D(G-&gt;RG-&gt;KMM-&gt;VectoredSpots.at(iS)) &lt; fBest )
+				{
+					iBest=iS;
+					fBest=StartLocation.distance2D(G-&gt;RG-&gt;KMM-&gt;VectoredSpots.at(iS));
+				}
+			}
+		}
+		Seleted.insert(iBest);
+		Resources[ResourceSize++] = new sResourceSpot(cb,G-&gt;RG-&gt;KMM-&gt;VectoredSpots.at(iBest));
+	}
+
+	Seleted.clear();
+	for( int iG=MetalSpotLimit; iG &lt; MetalSpotLimit+GeoSpotLimit; iG++ ) // Finding Nearest Geo Spots
+	{
+		int iBest=-1;
+		float fBest=0;
+		for(set&lt;int&gt;::iterator iS=G-&gt;RG-&gt;GeoSpot.begin(); iS!=G-&gt;RG-&gt;GeoSpot.end(); iS++)
+		{
+			if( Seleted.find(*iS) == Seleted.end() )
+			{
+				if( iBest == -1 || StartLocation.distance2D(cb-&gt;GetFeaturePos(*iS)) &lt; fBest )
+				{
+					iBest=*iS;
+					fBest=StartLocation.distance2D(cb-&gt;GetFeaturePos(*iS));
+				}
+			}
+		}
+		Seleted.insert(iBest);
+		Resources[ResourceSize++] = new sResourceSpot(cb,cb-&gt;GetFeaturePos(iBest),iBest,cb-&gt;GetFeatureDef(iBest));
+	}
+
+	for( int iR=0; iR&lt;ResourceSize; iR++ ) // Updating BuildOptions, Validating Resources
+	{
+		sRAIBuildList *BL;
+		if( Resources[iR]-&gt;type==1 )
+		{
+			BL=G-&gt;UDH-&gt;BLMetalL;
+			for( int i=0; i&lt;BL-&gt;UDefSize; i++ )
+			{
+				sRAIUnitDef* udr=BL-&gt;UDef[i]-&gt;RUD;
+				float3 BuildLoc=cb-&gt;ClosestBuildSite(udr-&gt;ud,Resources[iR]-&gt;location,Resources[iR]-&gt;searchRadius,0);
+				if( cb-&gt;CanBuildAt(udr-&gt;ud,BuildLoc) )
+				{
+					Resources[iR]-&gt;BuildOptions.insert(irbPair(udr-&gt;ud-&gt;id,sResourceSpotBO(udr)));
+				}
+			}
+		}
+		else if( Resources[iR]-&gt;type==2 )
+		{
+			BL=G-&gt;UDH-&gt;BLEnergyL;
+			for( map&lt;int,sRAIUnitDef&gt;::iterator iUD=G-&gt;UDH-&gt;UDR.begin(); iUD!=G-&gt;UDH-&gt;UDR.end(); iUD++ )
+			{
+				if( iUD-&gt;second.ud-&gt;needGeo &amp;&amp; !iUD-&gt;second.Disabled &amp;&amp; int(iUD-&gt;second.PrerequisiteOptions.size()) &gt; 0 )
+				{
+					float3 BuildLoc=cb-&gt;ClosestBuildSite(iUD-&gt;second.ud,Resources[iR]-&gt;location,Resources[iR]-&gt;searchRadius,0);
+					if( cb-&gt;CanBuildAt(iUD-&gt;second.ud,BuildLoc) )
+					{
+						Resources[iR]-&gt;BuildOptions.insert(irbPair(iUD-&gt;second.ud-&gt;id,sResourceSpotBO(&amp;iUD-&gt;second)));
+					}
+				}
+			}
+		}
+
+		if( int(Resources[iR]-&gt;BuildOptions.size()) == 0 ) // NOTE: This unfortunately occurs when the starting unit is a factory on top of a resource
+		{
+			*l&lt;&lt;&quot;\nWARNING: &quot;&lt;&lt;(Resources[iR]-&gt;type==1?&quot;Metal&quot;:&quot;Energy&quot;)&lt;&lt;&quot; Resource located at (x&quot;&lt;&lt;Resources[iR]-&gt;location.x;
+			*l&lt;&lt;&quot; z&quot;&lt;&lt;Resources[iR]-&gt;location.z&lt;&lt;&quot; y&quot;&lt;&lt;Resources[iR]-&gt;location.y&lt;&lt;&quot;) can not be built at.&quot;;
+			delete Resources[iR];
+			Resources[iR] = Resources[ResourceSize-1];
+			ResourceSize--;
+			iR--;
+		}
+		else
+			ResRemaining.insert(irPair(iR,Resources[iR]));
+	}
+
+	float Distance[400][400]; // required for Visual Studios
+//	float Distance[ResourceSize][ResourceSize];
+
+	for( int iR1=0; iR1&lt;ResourceSize; iR1++ )
+		for( int iR2=iR1+1; iR2&lt;ResourceSize; iR2++ )
+		{
+			Distance[iR1][iR2] = 0;
+			
+//			*l&lt;&lt;&quot;\n\n P1.x&quot;&lt;&lt;Resources[iR1]-&gt;location.x&lt;&lt;&quot; P1.y&quot;&lt;&lt;Resources[iR1]-&gt;location.y&lt;&lt;&quot; P1.z&quot;&lt;&lt;Resources[iR1]-&gt;location.z;
+//			*l&lt;&lt;&quot;\n P2.x&quot;&lt;&lt;Resources[iR2]-&gt;location.x&lt;&lt;&quot; P2.y&quot;&lt;&lt;Resources[iR2]-&gt;location.y&lt;&lt;&quot; P2.z&quot;&lt;&lt;Resources[iR2]-&gt;location.z;
+
+			// distance is calculated in 50 segments to take slope in consideration
+			for( int i=0; i&lt;50; i++ )
+			{
+				float x = -0.02*(Resources[iR1]-&gt;location.x-Resources[iR2]-&gt;location.x);
+				float z = -0.02*(Resources[iR1]-&gt;location.z-Resources[iR2]-&gt;location.z);
+				float3 Pos1 = Resources[iR1]-&gt;location;
+				Pos1.x += i*x;
+				Pos1.z += i*z;
+				float3 Pos2 = Resources[iR1]-&gt;location;
+				Pos2.x += (i+1)*x;
+				Pos2.z += (i+1)*z;
+
+				Pos1.y = cb-&gt;GetElevation(Pos1.x,Pos1.z)*0.125*Pos1.distance2D(Pos2);
+				Pos2.y = cb-&gt;GetElevation(Pos2.x,Pos2.z)*0.125*Pos1.distance2D(Pos2);
+
+//				*l&lt;&lt;&quot;\n x*)&quot;&lt;&lt;Pos1.x&lt;&lt;&quot; z*)&quot;&lt;&lt;Pos1.z&lt;&lt;&quot; y*)&quot;&lt;&lt;Pos1.y;
+//				*l&lt;&lt;&quot;\n x)&quot;&lt;&lt;Pos1.x-Pos2.x&lt;&lt;&quot; z)&quot;&lt;&lt;Pos1.z-Pos2.z&lt;&lt;&quot; y)&quot;&lt;&lt;Pos1.y-Pos2.y&lt;&lt;&quot; Pos1.distance(Pos2)=&quot;&lt;&lt;Pos1.distance(Pos2);
+
+				Distance[iR1][iR2] += Pos1.distance(Pos2);
+			}
+			Distance[iR2][iR1] = Distance[iR1][iR2];
+
+//			*l&lt;&lt;&quot;\n  Distance[&quot;&lt;&lt;iR1&lt;&lt;&quot;][&quot;&lt;&lt;iR2&lt;&lt;&quot;] &quot;&lt;&lt;Distance[iR1][iR2];
+		}
+
+	if( ResourceSize &gt; 0 ) // First Link Algorithm
+	{
+		set&lt;int&gt; RSList1;
+		set&lt;int&gt; RSList2;
+		RSList1.insert(0);
+		for( int i=1; i&lt;ResourceSize; i++ )
+			RSList2.insert(i);
+
+		int R1;
+		int R2;
+		while( int(RSList2.size()) &gt; 0 )
+		{
+			R1 = -1;
+			for( set&lt;int&gt;::iterator iR1=RSList1.begin(); iR1!=RSList1.end(); iR1++ )
+			{
+				for( set&lt;int&gt;::iterator iR2=RSList2.begin(); iR2!=RSList2.end(); iR2++ )
+				{
+					if( R1 == -1 || Distance[R1][R2] &gt; Distance[*iR1][*iR2] )
+					{
+						R1=*iR1;
+						R2=*iR2;
+					}
+				}
+			}
+			RSList1.insert(R2);
+			RSList2.erase(R2);
+			Resources[R1]-&gt;Linked.insert(irPair(R2,Resources[R2]));
+			Resources[R2]-&gt;Linked.insert(irPair(R1,Resources[R1]));
+//			*l&lt;&lt;&quot;\nDistance[&quot;&lt;&lt;R1&lt;&lt;&quot;][&quot;&lt;&lt;R2&lt;&lt;&quot;] &quot;&lt;&lt;Distance[R1][R2];
+		}
+	}
+
+	for( int iR1=0; iR1&lt;ResourceSize; iR1++ ) // Second Link Algorithm
+	{
+		if( (Resources[iR1]-&gt;Linked.size()) == 1 )
+		{
+			int bestI=-1;
+			for( int iR2=0; iR2&lt;ResourceSize; iR2++ )
+			{
+				if( iR2 != iR1 &amp;&amp; Distance[iR1][iR2] &lt; Distance[iR2][Resources[iR1]-&gt;Linked.begin()-&gt;first] &amp;&amp; Distance[iR1][iR2] &lt; 3*Distance[iR1][Resources[iR1]-&gt;Linked.begin()-&gt;first] &amp;&amp; ( bestI == -1 || Distance[iR1][iR2] &lt; Distance[iR1][bestI] ) )
+				{
+					bestI = iR2;
+				}
+			}
+			if( bestI &gt; -1 )
+			{
+				Resources[iR1]-&gt;Linked.insert(irPair(bestI,Resources[bestI]));
+				Resources[bestI]-&gt;Linked.insert(irPair(iR1,Resources[iR1]));
+/*
+				if( cb-&gt;GetMyTeam() == 0 ) // Debug Lines
+				{
+				float3 Pos1=Resources[iR1]-&gt;location;
+				float3 Pos2=Resources[bestI]-&gt;location;
+				Pos1.y+=50.0;
+				Pos2.y+=50.0;
+				cb-&gt;CreateLineFigure(Pos1,Pos2,40,0,900000,0);
+				}
+*/
+			}
+		}
+	}
+
+	for( int iR=0; iR&lt;ResourceSize; iR++ ) // Setting Linked Distance 2
+	{
+		for( map&lt;int,sResourceSpot*&gt;::iterator iRL=Resources[iR]-&gt;Linked.begin(); iRL!=Resources[iR]-&gt;Linked.end(); iRL++ )
+		{
+			if( Resources[iR]-&gt;LinkedD2.find(iRL-&gt;first) == Resources[iR]-&gt;LinkedD2.end() )
+				Resources[iR]-&gt;LinkedD2.insert(irPair(iRL-&gt;first,Resources[iRL-&gt;first]));
+			for( map&lt;int,sResourceSpot*&gt;::iterator iRL2=Resources[iRL-&gt;first]-&gt;Linked.begin(); iRL2!=Resources[iRL-&gt;first]-&gt;Linked.end(); iRL2++ )
+			{
+				if( iRL2-&gt;first != iR &amp;&amp; Resources[iR]-&gt;LinkedD2.find(iRL2-&gt;first) == Resources[iR]-&gt;LinkedD2.end() )
+					Resources[iR]-&gt;LinkedD2.insert(irPair(iRL2-&gt;first,Resources[iRL2-&gt;first]));
+			}
+		}
+	}
+
+	for( int iR=0; iR&lt;ResourceSize; iR++ )
+		Resources[iR]-&gt;SetRanged();
+/*
+	if( cb-&gt;GetMyTeam() == 0 )
+	for( int iR=0; iR&lt;ResourceSize; iR++ ) // Debug Lines
+	{
+		for( int iR2=iR+1; iR2&lt;ResourceSize; iR2++ )
+		{
+			if( Resources[iR]-&gt;Linked.find(iR2) != Resources[iR]-&gt;Linked.end() )
+			{
+				float3 Pos1=Resources[iR]-&gt;location;
+				float3 Pos2=Resources[iR2]-&gt;location;
+				Pos1.y+=50.0;
+				Pos2.y+=50.0;
+				cb-&gt;CreateLineFigure(Pos1,Pos2,10,0,900000,0);
+			}
+		}
+
+		*l&lt;&lt;&quot;\n R(&quot;&lt;&lt;iR&lt;&lt;&quot;) type=&quot;&lt;&lt;Resources[iR]-&gt;type&lt;&lt;&quot; L(&quot;&lt;&lt;Resources[iR]-&gt;Linked.size()&lt;&lt;&quot;):&quot;;
+		for( map&lt;int,sResourceSpot*&gt;::iterator RL=Resources[iR]-&gt;Linked.begin(); RL!=Resources[iR]-&gt;Linked.end(); RL++ )
+			*l&lt;&lt;&quot; &quot;&lt;&lt;RL-&gt;first;
+		*l&lt;&lt;&quot;\t B(&quot;&lt;&lt;Resources[iR]-&gt;BuildOptions.size()&lt;&lt;&quot;):&quot;;
+		for( map&lt;int,sResourceSpotBO&gt;::iterator RS=Resources[iR]-&gt;BuildOptions.begin(); RS!=Resources[iR]-&gt;BuildOptions.end(); RS++ )
+			*l&lt;&lt;&quot; &quot;&lt;&lt;RS-&gt;first;
+	}
+*/
+}
+
+cBuilderPlacement::~cBuilderPlacement()
+{
+	for( int i=0; i&lt;ResourceSize; i++ )
+		delete Resources[i];
+//	delete [] Sector;
+}
+
+void cBuilderPlacement::UResourceCreated(int unit, UnitInfo *U)
+{
+	if( !NeedsResourceSpot(U-&gt;ud,U-&gt;mapBody) )
+		return;
+
+	if( U-&gt;ud-&gt;extractsMetal &gt; 0.0f )
+		UExtractor.insert(cRAI::iupPair(unit,U));
+	else if( U-&gt;ud-&gt;needGeo )
+		UGeoPlant.insert(cRAI::iupPair(unit,U));
+
+	int iR=GetResourceIndex(unit,U-&gt;ud);
+	if( iR == -1 )
+	{
+//		cb-&gt;SendTextMsg(&quot;TEST: Decomission: iR = -1&quot;,0);
+//		G-&gt;Build-&gt;Decomission.insert(unit); // broken
+		return;
+	}
+
+	if( Resources[iR]-&gt;unitID == -1 || !Resources[iR]-&gt;BuildOptions.find(U-&gt;ud-&gt;id)-&gt;second.RBRanked )
+	{
+		SetResourceOwner(iR,Resources[iR],unit,U-&gt;udr);
+		U-&gt;RS = Resources[iR];
+	}
+	else if( !U-&gt;AIDisabled )
+	{
+//		cb-&gt;SendTextMsg(&quot;TEST: Decomission: ranked&quot;,0);
+		G-&gt;Build-&gt;Decomission.insert(unit);
+	}
+}
+
+void cBuilderPlacement::UResourceDestroyed(int unit, UnitInfo *U)
+{
+	if( !NeedsResourceSpot(U-&gt;ud,U-&gt;mapBody) )
+		return;
+
+	if( U-&gt;ud-&gt;extractsMetal &gt; 0.0f )
+		UExtractor.erase(unit);
+	else if( U-&gt;ud-&gt;needGeo )
+		UGeoPlant.erase(unit);
+
+	if( U-&gt;RS != 0 &amp;&amp; U-&gt;RS-&gt;unitID == unit )
+	{
+		for( int iR=0; iR&lt;ResourceSize; iR++ )
+		{
+			if(	Resources[iR]-&gt;unitID == unit )
+			{
+				SetResourceOwner(iR,U-&gt;RS,-1);
+				break;
+			}
+		}
+	}
+}
+
+void cBuilderPlacement::EResourceEnterLOS(int enemy, EnemyInfo *E)
+{
+	if( !NeedsResourceSpot(E-&gt;ud,-1) )
+		return;
+
+	int iR=GetResourceIndex(enemy,E-&gt;ud);
+	if( iR == -1 )
+		return;
+
+	if( Resources[iR]-&gt;unitID == -1 || !Resources[iR]-&gt;BuildOptions.find(E-&gt;ud-&gt;id)-&gt;second.RBRanked )
+	{
+		Resources[iR]-&gt;unitID=enemy;
+		Resources[iR]-&gt;unitUD=E-&gt;udr;
+		Resources[iR]-&gt;enemy = true;
+		E-&gt;RS = Resources[iR];
+
+		if( Resources[iR]-&gt;builderID &gt; -1 &amp;&amp; G-&gt;ValidateUnit(Resources[iR]-&gt;builderID) &amp;&amp; int(cb-&gt;GetCurrentUnitCommands(Resources[iR]-&gt;builderID)-&gt;size())&gt;0 &amp;&amp; Resources[iR]-&gt;BuildOptions.find(-cb-&gt;GetCurrentUnitCommands(Resources[iR]-&gt;builderID)-&gt;begin()-&gt;id) != Resources[iR]-&gt;BuildOptions.end() )
+		{
+			if( Resources[iR]-&gt;builderUI-&gt;ud-&gt;canCapture )
+			{
+				Command c;
+				c.id = CMD_CAPTURE;
+				c.params.push_back(enemy);
+				cb-&gt;GiveOrder(Resources[iR]-&gt;builderID, &amp;c);
+			}
+			else if ( Resources[iR]-&gt;builderUI-&gt;ud-&gt;canReclaim )
+			{
+				Command c;
+				c.id = CMD_RECLAIM;
+				c.params.push_back(enemy);
+				cb-&gt;GiveOrder(Resources[iR]-&gt;builderID, &amp;c);
+			}
+		}
+	}
+}
+
+bool cBuilderPlacement::CanBuildAtMapBody(float3 fBuildPos, const UnitDef* bd, int BuilderMapBody)
+{
+	int ConstructMapBody=G-&gt;GetCurrentMapBody(bd,fBuildPos);
+	if( ConstructMapBody == -2 )
+		return false;
+	if( BuilderMapBody == -1 || ConstructMapBody == BuilderMapBody || BuilderMapBody == -2 ) // MapBody == -2 really should return false, but the only time i've known this to happen is TA mods - commander starts were they shouldnt
+		return true;
+	if( G-&gt;TM-&gt;MapB[BuilderMapBody]-&gt;Sector.find(G-&gt;TM-&gt;GetSector(fBuildPos)) == G-&gt;TM-&gt;MapB[BuilderMapBody]-&gt;Sector.end() )
+		return false;
+	return true;
+}
+
+bool cBuilderPlacement::NeedsResourceSpot(const UnitDef* bd, int ConstructMapBody)
+{
+	if( !bd-&gt;needGeo &amp;&amp; bd-&gt;extractsMetal==0 )
+		return false;
+	if( ConstructMapBody &lt; 0 ) // assume it should return true, it either can't be built here or it can be built anywhere
+		return true;
+	if( bd-&gt;extractsMetal&gt;0 &amp;&amp; G-&gt;TM-&gt;MapB[ConstructMapBody]-&gt;MetalMap )
+		return false;
+	return true;
+}
+
+sResourceSpot* cBuilderPlacement::FindResourceSpot(float3&amp; pos, const UnitDef* bd, int BuilderMapBody)
+{
+//	*l&lt;&lt;&quot;\nFindResourceSpot(&quot;&lt;&lt;bd-&gt;humanName&lt;&lt;&quot;,&quot;&lt;&lt;BuilderMapBody&lt;&lt;&quot;, x&quot;&lt;&lt;pos.x&lt;&lt;&quot; z&quot;&lt;&lt;pos.z&lt;&lt;&quot; y&quot;&lt;&lt;pos.y&lt;&lt;&quot;)&quot;;
+	if( !NeedsResourceSpot(bd,G-&gt;GetCurrentMapBody(bd,pos)) )
+		return 0;
+
+	UpdateAllyResources();
+	map&lt;int,sResourceSpot*&gt;* RL;
+	if( int(UExtractor.size()) == 0 &amp;&amp; int(UGeoPlant.size()) == 0 &amp;&amp; int(ResRemaining.size()) &gt; 0 )
+	{
+//		*l&lt;&lt;&quot;\n\n(No Resources) - Alternative Search&quot;;
+		RL=&ResRemaining;
+		CheckBlockedRList(RL);
+	}
+	else
+		RL=&Resource;
+	float fBest=0;
+	int iBest=-1;
+	for( map&lt;int,sResourceSpot*&gt;::iterator iR=RL-&gt;begin(); iR!=RL-&gt;end(); iR++ )
+	{
+		if( iR-&gt;second-&gt;builderID == -1 &amp;&amp;
+			iR-&gt;second-&gt;BuildOptions.find(bd-&gt;id) != iR-&gt;second-&gt;BuildOptions.end() &amp;&amp;
+			!iR-&gt;second-&gt;BuildOptions.find(bd-&gt;id)-&gt;second.RBBlocked &amp;&amp;
+			!iR-&gt;second-&gt;BuildOptions.find(bd-&gt;id)-&gt;second.RBRanked)
+		{
+			int CMB = G-&gt;GetCurrentMapBody(bd,pos);
+			if( G-&gt;TM-&gt;CanMoveToPos(BuilderMapBody,iR-&gt;second-&gt;location) || (!G-&gt;TM-&gt;MapB[BuilderMapBody]-&gt;Water &amp;&amp; CMB &gt;= 0 &amp;&amp; G-&gt;TM-&gt;MapB[CMB]-&gt;Water) )
+			{
+				float fDis=pos.distance(iR-&gt;second-&gt;location);
+				if( iBest==-1 || fDis &lt; fBest )
+				{
+					iBest=iR-&gt;first;
+					fBest=fDis;
+				}
+			}
+		}
+	}
+	if( iBest == -1 )
+	{
+		*l&lt;&lt;&quot;\nWARNING: Search for resource has failed: &quot;&lt;&lt;bd-&gt;humanName;
+		return 0;
+	}
+
+	return Resources[iBest];
+}
+
+float3 cBuilderPlacement::FindBuildPosition(sBuildQuarry *BQ)
+{
+	const UnitDef* bd = BQ-&gt;creationUD-&gt;ud;
+	if( BQ-&gt;RS != 0 ) // Resource is set
+		return cb-&gt;ClosestBuildSite(bd,BQ-&gt;RS-&gt;location,BQ-&gt;RS-&gt;searchRadius,BQ-&gt;RS-&gt;disApart);
+
+	float3 Pos=cb-&gt;GetUnitPos(BQ-&gt;builderID);
+	int mapBody = G-&gt;GetCurrentMapBody(BQ-&gt;creationUD-&gt;ud,Pos);
+	if( NeedsResourceSpot(BQ-&gt;creationUD-&gt;ud,mapBody) )
+	{
+		Pos.x = -2;
+		Pos.z = -2;
+		Pos.y = -2;
+		return Pos;
+	}
+	else if( FindWeaponPlacement(BQ-&gt;builderUI,Pos) )
+	{
+		Pos.x+=rand()%81-40;
+		Pos.z+=rand()%81-40;
+		G-&gt;CorrectPosition(&amp;Pos);
+	}
+	else if( BQ-&gt;builderUI-&gt;ud-&gt;speed == 0.0 )
+	{
+		Pos.x+=rand()%int(1.8*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance)-0.9*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance;
+		Pos.z+=rand()%int(1.8*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance)-0.9*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance;
+		G-&gt;CorrectPosition(&amp;Pos);
+		float3 BuildPos = cb-&gt;ClosestBuildSite(bd,Pos,BQ-&gt;builderUI-&gt;ud-&gt;buildDistance,5);
+		if( BuildPos.x &lt;= 0 &amp;&amp; BuildPos.y &lt;= 0 &amp;&amp; BuildPos.z &lt;= 0 )
+			BuildPos = cb-&gt;ClosestBuildSite(bd,cb-&gt;GetUnitPos(BQ-&gt;builderID),BQ-&gt;builderUI-&gt;ud-&gt;buildDistance+25,1);
+
+//		if( cb-&gt;CanBuildAt(BQ-&gt;builderUI-&gt;ud,cb-&gt;GetUnitPos(BQ-&gt;builderID),cb-&gt;GetBuildingFacing(BQ-&gt;builderID)) )
+		return BuildPos;
+	}
+	else
+	{
+		Pos.x+=rand()%int(0.9*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance)-0.45*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance;
+		Pos.z+=rand()%int(0.9*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance)-0.45*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance;
+		G-&gt;CorrectPosition(&amp;Pos);
+	}
+	if( !CanBuildAtMapBody(Pos,bd,BQ-&gt;builderUI-&gt;mapBody) )//&amp;&amp; bd-&gt;extractsMetal == 0.0 &amp;&amp; !bd-&gt;needGeo )
+	{
+		Pos=G-&gt;TM-&gt;Sector[G-&gt;TM-&gt;GetSector(Pos)].AltSector-&gt;Pos;
+	}
+
+	float fSearchRadius=1000.0f;
+	int iDisApart=10;
+	int iMB=G-&gt;GetCurrentMapBody(bd,Pos);
+	if( iMB&gt;=0 &amp;&amp; G-&gt;TM-&gt;MapB[iMB]-&gt;Water )
+		iDisApart=15;
+	else if( bd-&gt;speed &gt; 0 )
+		iDisApart=5;
+	else if( int(bd-&gt;buildOptions.size())&gt;0 )
+		iDisApart=15;
+	if( iDisApart &lt; int(bd-&gt;kamikazeDist/8.0) )
+		iDisApart = int(bd-&gt;kamikazeDist/8.0);
+
+	float3 bpos = cb-&gt;ClosestBuildSite(bd,Pos,fSearchRadius,iDisApart);
+	if( bpos.x == -1 )
+	{
+		bpos = cb-&gt;ClosestBuildSite(bd,Pos,2500.0f,iDisApart);
+		if( bpos.x == -1 )
+			return Pos;
+	}
+	return bpos;
+}
+
+bool cBuilderPlacement::FindWeaponPlacement(UnitInfo *U, float3&amp; pos)
+{
+	if( U-&gt;BuildQ-&gt;creationUD-&gt;WeaponGuardRange == 0 )
+		return false;
+
+	if( U-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;minWaterDepth &lt; 0 &amp;&amp; U-&gt;BuildQ-&gt;creationUD-&gt;WeaponSeaEff.BestRange &gt; 0 )
+	{
+		G-&gt;CorrectPosition(&amp;pos);
+		MapSector* MS = &amp;G-&gt;TM-&gt;Sector[G-&gt;TM-&gt;GetSector(pos)];
+		if( MS-&gt;Land &amp;&amp; MS-&gt;AltSector != 0 )
+			pos = MS-&gt;AltSector-&gt;Pos;
+		return true;
+	}
+
+	int BID = -1;
+	for(map&lt;int,UnitInfo*&gt;::iterator i=G-&gt;UImmobile.begin(); i!=G-&gt;UImmobile.end(); i++ )
+	{
+		if( i-&gt;second-&gt;udr-&gt;WeaponGuardRange == 0 &amp;&amp; int(i-&gt;second-&gt;UDefences.size()) == 0 &amp;&amp; CanBuildAtMapBody(cb-&gt;GetUnitPos(i-&gt;first),U-&gt;BuildQ-&gt;creationUD-&gt;ud,U-&gt;mapBody) )
+		{
+			if( BID == -1 || pos.distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; pos.distance2D(cb-&gt;GetUnitPos(BID)) )
+				BID = i-&gt;first;
+		}
+	}
+
+	if( BID &gt; 0 )
+	{
+		pos = cb-&gt;GetUnitPos(BID);
+		return true;
+	}
+
+	return false;
+}
+
+void cBuilderPlacement::CheckBlockedRList( map&lt;int,sResourceSpot*&gt; *RL )
+{
+	if( RL == 0 )
+		RL = &Resource;
+	set&lt;int&gt; del;
+	for( map&lt;int,sResourceSpot*&gt;::iterator iR=RL-&gt;begin(); iR!=RL-&gt;end(); iR++ )
+	{
+		if( iR-&gt;second-&gt;unitID == -1 )
+			iR-&gt;second-&gt;CheckBlocked();
+		else if( cb-&gt;GetUnitHealth(iR-&gt;second-&gt;unitID) &lt;= 0 )
+		{
+			del.insert(iR-&gt;first);
+		}
+	}
+	while( int(del.size()) &gt; 0 )
+	{
+		if( RL-&gt;find(*del.begin()) != RL-&gt;end() )
+		{
+			sResourceSpot* RS = RL-&gt;find(*del.begin())-&gt;second;
+			SetResourceOwner(*del.begin(),RS,-1);
+			RS-&gt;CheckBlocked();
+		}
+		del.erase(del.begin());
+	}
+}
+
+void cBuilderPlacement::UpdateAllyResources()
+{
+	int *Units = new int[5000];
+	int UnitsSize;
+	try
+	{
+		UnitsSize = cb-&gt;GetFriendlyUnits(Units);
+	}
+	catch(...)
+	{
+		cb-&gt;SendTextMsg(&quot;ERROR: more than 5000 Friendly Units, increase limit.&quot;,0);
+		*l&lt;&lt;&quot;\n\nERROR: more than 5000 Friendly Units, increase limit.\n&quot;;
+		delete [] Units;
+		return;
+	}
+
+	for( int iU=0; iU&lt;UnitsSize; iU++ )
+	{
+		const UnitDef* ud=cb-&gt;GetUnitDef(Units[iU]);
+		if( !NeedsResourceSpot(ud,-1) || G-&gt;Units.find(Units[iU]) != G-&gt;Units.end() )
+		{
+			Units[iU--]=Units[--UnitsSize];
+		}
+		else
+		{
+			int iR=GetResourceIndex(Units[iU],ud);
+			if( iR &gt; -1 )
+			{
+				if( Resources[iR]-&gt;unitID == -1 || !Resources[iR]-&gt;BuildOptions.find(ud-&gt;id)-&gt;second.RBRanked )
+				{
+					SetResourceOwner(iR,Resources[iR],Units[iU],&amp;G-&gt;UDH-&gt;UDR.find(ud-&gt;id)-&gt;second);
+				}
+			}
+		}
+	}
+
+	delete [] Units;
+}
+
+int cBuilderPlacement::GetResourceIndex(const int &amp;unit, const UnitDef* ud)
+{
+	int iBest=-1;
+	float fBest;
+	for( int iR=0; iR&lt;ResourceSize; iR++ )
+	{
+		if(	Resources[iR]-&gt;unitID == unit )
+			return iR;
+		if( (Resources[iR]-&gt;type == 1 &amp;&amp; ud-&gt;extractsMetal&gt;0.0 ) ||
+			(Resources[iR]-&gt;type == 2 &amp;&amp; ud-&gt;needGeo ) )
+		{
+			float dis=Resources[iR]-&gt;location.distance2D(cb-&gt;GetUnitPos(unit));
+			if( dis &lt;= Resources[iR]-&gt;searchRadius &amp;&amp; Resources[iR]-&gt;BuildOptions.find(ud-&gt;id) != Resources[iR]-&gt;BuildOptions.end() &amp;&amp; (iBest==-1 || dis &lt; fBest) )
+			{
+				iBest = iR;
+				fBest = dis;
+			}
+		}
+	}
+	return iBest;
+}
+
+void cBuilderPlacement::SetResourceOwner(int RSindex, sResourceSpot* RS, int unit, sRAIUnitDef* udr)
+{
+	if( int(Resource.size()) == 0 &amp;&amp; unit &gt;= 0 )
+		for( int iR=0; iR&lt;ResourceSize; iR++ )
+			Resources[iR]-&gt;SetRanged(false);
+
+/*	*l&lt;&lt;&quot;\n\nSetResourceOwner(&quot;&lt;&lt;RSindex&lt;&lt;&quot;,_,&quot;&lt;&lt;unit&lt;&lt;&quot;,{&quot;&lt;&lt;(udr==0?&quot;0&quot;:udr-&gt;ud-&gt;humanName)&lt;&lt;&quot;})&quot;;
+	*l&lt;&lt;&quot;\n - Resources Available (&quot;&lt;&lt;Resource.size()&lt;&lt;&quot;):&quot;;
+	for( map&lt;int,sResourceSpot*&gt;::iterator iR=Resource.begin(); iR!=Resource.end(); iR++ )
+		*l&lt;&lt;&quot; &quot;&lt;&lt;iR-&gt;first;
+*/
+	int oldunit = RS-&gt;unitID;
+	RS-&gt;unitID=unit;
+	RS-&gt;unitUD=udr;
+	RS-&gt;enemy = false;
+	if( unit &gt;= 0 &amp;&amp; cb-&gt;GetUnitAllyTeam(unit) != cb-&gt;GetMyAllyTeam() )
+		RS-&gt;ally = true;
+	else
+		RS-&gt;ally = false;
+	sRAIBuildList *BL;
+	if( RS-&gt;type == 1 )
+		BL=G-&gt;UDH-&gt;BLMetalL;
+	else
+		BL=G-&gt;UDH-&gt;BLEnergyL;
+	if( unit &gt;= 0 &amp;&amp; oldunit == -1 )
+	{
+		if( Resource.find( RSindex ) == Resource.end() )
+		{
+			RS-&gt;SetRanged();
+			Resource.insert(irPair(RSindex,RS));
+			ResRemaining.erase(RSindex);
+		}
+		for( map&lt;int,sResourceSpot*&gt;::iterator iR=RS-&gt;Linked.begin(); iR!=RS-&gt;Linked.end(); iR++ )
+		{
+			if( Resource.find(iR-&gt;first) == Resource.end() )
+			{
+				iR-&gt;second-&gt;SetRanged();
+				Resource.insert(irPair(iR-&gt;first,iR-&gt;second));
+				ResRemaining.erase(iR-&gt;first);
+			}
+			for( map&lt;int,sResourceSpot*&gt;::iterator iR2=iR-&gt;second-&gt;Linked.begin(); iR2!=iR-&gt;second-&gt;Linked.end(); iR2++ )
+			{
+				if( Resource.find(iR2-&gt;first) == Resource.end() )
+				{
+					iR2-&gt;second-&gt;SetRanged();
+					Resource.insert(irPair(iR2-&gt;first,iR2-&gt;second));
+					ResRemaining.erase(iR2-&gt;first);
+				}
+			}
+		}
+	}
+	else if( unit == -1 )
+	{
+		set&lt;int&gt; RSL;
+		RSL.insert(RSindex);
+		for( map&lt;int,sResourceSpot*&gt;::iterator iR=RS-&gt;LinkedD2.begin(); iR!=RS-&gt;LinkedD2.end(); iR++ )
+		{
+			if( Resource.find(iR-&gt;first) != Resource.end() &amp;&amp; ( iR-&gt;second-&gt;unitID == -1 || iR-&gt;second-&gt;enemy ) )
+				RSL.insert(iR-&gt;first);
+		}
+		bool found;
+		while( int(RSL.size()) &gt; 0 )
+		{
+			found=false;
+			for( map&lt;int,sResourceSpot*&gt;::iterator iR=Resources[*RSL.begin()]-&gt;LinkedD2.begin(); iR!=Resources[*RSL.begin()]-&gt;LinkedD2.end(); iR++ )
+			{
+				if( Resources[iR-&gt;first]-&gt;unitID &gt; -1 &amp;&amp; !Resources[iR-&gt;first]-&gt;enemy )
+				{
+					found = true;
+					break;
+				}
+			}
+
+			if( !found )
+			{
+				Resources[*RSL.begin()]-&gt;SetRanged(false);
+				ResRemaining.insert(irPair(*RSL.begin(),Resources[*RSL.begin()]));
+				Resource.erase(*RSL.begin());
+			}
+			RSL.erase(RSL.begin());
+		}
+	}
+	RS-&gt;CheckRanked();
+	if( int(Resource.size()) == 0 )
+		for( int iR=0; iR&lt;ResourceSize; iR++ )
+			Resources[iR]-&gt;SetRanged(true);
+/*
+	*l&lt;&lt;&quot;\n - Resources Available (&quot;&lt;&lt;Resource.size()&lt;&lt;&quot;):&quot;;
+	for( map&lt;int,sResourceSpot*&gt;::iterator iR=Resource.begin(); iR!=Resource.end(); iR++ )
+		*l&lt;&lt;&quot; &quot;&lt;&lt;iR-&gt;first;
+
+	BL=G-&gt;UDH-&gt;BLMetalL;
+	for( int i=0; i&lt;BL-&gt;UDefSize; i++ )
+	{
+		sRAIUnitDef* udrTemp=BL-&gt;UDef[i]-&gt;RUD;
+		if( !udrTemp-&gt;Disabled )
+		{
+			*l&lt;&lt;&quot;\n&quot;+udrTemp-&gt;ud-&gt;humanName;
+			if( udrTemp-&gt;RBPrereq )
+				*l&lt;&lt;&quot;(RBPrereq)&quot;;
+			if( udrTemp-&gt;RBCost )
+				*l&lt;&lt;&quot;(RBCost)&quot;;
+			if( udrTemp-&gt;RBUnitLimit )
+				*l&lt;&lt;&quot;(RBUnitLimit)&quot;;
+			*l&lt;&lt;&quot;: &quot;&lt;&lt;udrTemp-&gt;UnitsActive.size()&lt;&lt;&quot;+&quot;&lt;&lt;udrTemp-&gt;UnitConstructs&lt;&lt;&quot;/&quot;&lt;&lt;udrTemp-&gt;UnitLimit[0];
+		}
+	}
+	BL=G-&gt;UDH-&gt;BLEnergyL;
+	for( int i=0; i&lt;BL-&gt;UDefSize; i++ )
+	{
+		sRAIUnitDef* udrTemp=BL-&gt;UDef[i]-&gt;RUD;
+		if( !udrTemp-&gt;Disabled )
+		{
+			*l&lt;&lt;&quot;\n&quot;+udrTemp-&gt;ud-&gt;humanName;
+			if( udrTemp-&gt;RBPrereq )
+				*l&lt;&lt;&quot;(RBPrereq)&quot;;
+			if( udrTemp-&gt;RBCost )
+				*l&lt;&lt;&quot;(RBCost)&quot;;
+			if( udrTemp-&gt;RBUnitLimit )
+				*l&lt;&lt;&quot;(RBUnitLimit)&quot;;
+			*l&lt;&lt;&quot;: &quot;&lt;&lt;udrTemp-&gt;UnitsActive.size()&lt;&lt;&quot;+&quot;&lt;&lt;udrTemp-&gt;UnitConstructs&lt;&lt;&quot;/&quot;&lt;&lt;udrTemp-&gt;UnitLimit[0];
+		}
+	}
+
+	*l&lt;&lt;&quot;\n Empty Resources Available:&quot;;
+	for( map&lt;int,sResourceSpot*&gt;::iterator iR=Resource.begin(); iR!=Resource.end(); iR++ )
+		if( iR-&gt;second-&gt;unitID == -1 || iR-&gt;second-&gt;enemy )
+			*l&lt;&lt;&quot; &quot;&lt;&lt;iR-&gt;first;
+	*l&lt;&lt;&quot;\n\n&quot;;
+*/
+}

Added: trunk/AI/Global/RAI-0.553/BuilderPlacement.h
===================================================================
--- trunk/AI/Global/RAI-0.553/BuilderPlacement.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/BuilderPlacement.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,132 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_BUILDER_PLACEMENT_H
+#define RAI_BUILDER_PLACEMENT_H
+
+struct sResourceSpot;
+class cBuilderPlacement;
+
+#include &quot;RAI.h&quot;
+#include &quot;Builder.h&quot;
+#include &quot;Sim/Features/FeatureDef.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+
+struct sResourceSpotBO
+{
+	sResourceSpotBO(sRAIUnitDef* UDR );
+	void CheckBuild();
+	sRAIUnitDef *udr;	// This is the unit in question
+	bool RBBlocked;
+	bool RBRanked;
+	bool RBRanged;
+	bool CanBuild;	// not blocked, not outranked, not outranged - used to adjust SetULConstructs()
+};
+
+struct sResourceSpot
+{
+	sResourceSpot(IAICallback* callback, float3 position, int ID=-1, const FeatureDef* featureUD=0);
+	void CheckBlocked();	// Note: this will not work in a UnitDestroyed Event, since the dead extractor still exists at that moment
+	void CheckRanked();		// For the moment, only called from SetResourceOwner()
+	void SetRanged(bool inRange=true);
+
+	int featureID;				// Valid if it's a Geo Spot, otherwise -1
+	const FeatureDef *featureD;	// Valid if 'featureID' is set
+	int unitID;					// Valid if a unit is occuping this spot, otherwise -1
+	sRAIUnitDef *unitUD;		// Valid if 'UnitID' is set
+	int builderID;				// Valid if a builder has been assigned to this spot, otherwise -1
+	UnitInfo *builderUI;		// Valid if 'BuilderID' is set
+	bool enemy;
+	bool ally;
+
+	int type;					// 1=metal/Non-Feature, 2=geo/Feature
+	float searchRadius;
+	int disApart;
+
+	float3 location;
+	map&lt;int,sResourceSpotBO&gt; BuildOptions;	// The posible units that can be build at this location
+	map&lt;int,sResourceSpot*&gt; Linked;		// key value = Resources[] index
+	map&lt;int,sResourceSpot*&gt; LinkedD2;	// key value = Resources[] index, All 'Linked' Resources as well as their Linked Resources
+//	int unitLostFrame;
+	IAICallback* cb;	// used in CheckBlocked()
+};
+
+class cBuilderPlacement
+{
+public:
+	cBuilderPlacement(IAICallback* callback, cRAI* global);
+	~cBuilderPlacement();
+	void UResourceCreated(int unit, UnitInfo *U);
+	void UResourceDestroyed(int unit, UnitInfo *U);
+	void EResourceEnterLOS(int enemy, EnemyInfo *E);
+
+	bool NeedsResourceSpot(const UnitDef* bd, int ConstructMapBody);
+	sResourceSpot* FindResourceSpot(float3&amp; pos, const UnitDef* bd, int BuilderMapBody); // called when a builder has been assigned
+	float3 FindBuildPosition(sBuildQuarry *BQ);
+	void CheckBlockedRList( map&lt;int,sResourceSpot*&gt; *RL = 0 ); // CheckBlocked for all resource spots on this list
+
+private:
+	bool FindWeaponPlacement(UnitInfo *U, float3&amp; pos);
+	void UpdateAllyResources(); // determines what resources allies have gained or lost
+	bool CanBuildAtMapBody(float3 fBuildPos, const UnitDef* bd, int BuilderMapBody); // NOTE: returns false if the land mass was too small to be recorded
+
+	cLogFile *l;
+	cRAI *G;
+	IAICallback *cb;
+	map&lt;int,UnitInfo*&gt; UExtractor;
+	map&lt;int,UnitInfo*&gt; UGeoPlant;
+
+	int GetResourceIndex(const int &amp;unit, const UnitDef* ud);
+	typedef pair&lt;int,sResourceSpotBO&gt; irbPair;
+	sResourceSpot *Resources[400]; // List of all limited resources (metal,geo)
+	int ResourceSize;
+	typedef pair&lt;int,sResourceSpot*&gt; irPair;
+	// A sResourceSpot is only on one list at a given time
+	map&lt;int,sResourceSpot*&gt; Resource;		// Available Resource Spots
+	map&lt;int,sResourceSpot*&gt; ResRemaining;	// A Resource that can not be reached
+	void SetResourceOwner(int RSindex, sResourceSpot *RS, int unit, sRAIUnitDef *udr=0);
+/*
+	struct BuildGroup
+	{
+		BuildGroup(int unit)
+		{
+			RS=0;
+			units.insert(unit);
+		};
+		BuildGroup(sResourceSpot *Resource)
+		{
+			RS=Resource;
+			location=RS-&gt;location;
+			x=32.0;
+			z=32.0;
+		};
+		float3 location;
+		float x;
+		float z;
+		int type; // 
+		sResourceSpot *RS;
+		set&lt;int&gt; units;
+	};
+	struct BuildSector
+	{
+		BuildSector() {};
+		set&lt;BuildGroup&gt; LocalGroup;
+		set&lt;BuildGroup*&gt; Group;
+	};
+	set&lt;BuildGroup*&gt; BorderResource; // Hostile Bordering resource
+	set&lt;BuildGroup*&gt; DefenceDemand; // Possible groups to built a defence into
+	set&lt;BuildGroup*&gt; JammerDemand; // Possible groups to built a radar/sonar jammer into
+	void GroupAdd(BuildGroup *G);
+	void GroupRemove(BuildGroup *G);
+	BuildSector *Sector;
+	int SectorXSize;
+	int SectorZSize;
+	float MapW;	// x
+	float MapH;	// z
+*/
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/CodeBlocks/(Bot-libs).lnk
===================================================================
(Binary files differ)


Property changes on: trunk/AI/Global/RAI-0.553/CodeBlocks/(Bot-libs).lnk
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/AI/Global/RAI-0.553/CodeBlocks/RAI.cbp
===================================================================
--- trunk/AI/Global/RAI-0.553/CodeBlocks/RAI.cbp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/CodeBlocks/RAI.cbp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,163 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;!DOCTYPE CodeBlocks_project_file&gt;
+&lt;CodeBlocks_project_file&gt;
+	&lt;FileVersion major=&quot;1&quot; minor=&quot;1&quot;/&gt;
+	&lt;Project&gt;
+		&lt;Option title=&quot;RAI DLL&quot;/&gt;
+		&lt;Option makefile=&quot;Makefile&quot;/&gt;
+		&lt;Option makefile_is_custom=&quot;0&quot;/&gt;
+		&lt;Option compiler=&quot;0&quot;/&gt;
+		&lt;Build&gt;
+			&lt;Target title=&quot;default&quot;&gt;
+				&lt;Option output=&quot;RAI.dll&quot;/&gt;
+				&lt;Option working_dir=&quot;.&quot;/&gt;
+				&lt;Option object_output=&quot;.objs&quot;/&gt;
+				&lt;Option deps_output=&quot;.deps&quot;/&gt;
+				&lt;Option type=&quot;3&quot;/&gt;
+				&lt;Option compiler=&quot;0&quot;/&gt;
+				&lt;Option createStaticLib=&quot;1&quot;/&gt;
+			&lt;/Target&gt;
+		&lt;/Build&gt;
+		&lt;Compiler&gt;
+			&lt;Add option=&quot;-O3&quot;/&gt;
+			&lt;Add option=&quot;-DBUILD_DLL&quot;/&gt;
+			&lt;Add directory=&quot;..\..\..\..\rts&quot;/&gt;
+			&lt;Add directory=&quot;..\..\..\..\rts\System&quot;/&gt;
+			&lt;Add directory=&quot;..\..\..\..\..\mingwlibs\include&quot;/&gt;
+		&lt;/Compiler&gt;
+		&lt;Unit filename=&quot;..\Builder.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\Builder.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\BuilderPlacement.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\BuilderPlacement.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\CombatManager.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\CombatManager.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\GMetalMap.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\GMetalMap.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\GTerrainMap.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\GTerrainMap.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\Global.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\Global.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\GlobalAIs.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\Krogs Metal Class v0.4\MetalMap.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\Krogs Metal Class v0.4\MetalMap.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\LogFile.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\LogFile.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\PowerManager.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\PowerManager.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\RAI.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\RAI.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\SWeaponManager.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\SWeaponManager.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\UnitDef.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\UnitDef.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\UnitManager.cpp&quot;&gt;
+			&lt;Option compilerVar=&quot;CPP&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+		&lt;Unit filename=&quot;..\UnitManager.h&quot;&gt;
+			&lt;Option compilerVar=&quot;&quot;/&gt;
+			&lt;Option compile=&quot;0&quot;/&gt;
+			&lt;Option link=&quot;0&quot;/&gt;
+			&lt;Option target=&quot;default&quot;/&gt;
+		&lt;/Unit&gt;
+	&lt;/Project&gt;
+&lt;/CodeBlocks_project_file&gt;

Added: trunk/AI/Global/RAI-0.553/CodeBlocks/RAI.layout
===================================================================
--- trunk/AI/Global/RAI-0.553/CodeBlocks/RAI.layout	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/CodeBlocks/RAI.layout	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,13 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;!DOCTYPE CodeBlocks_layout_file&gt;
+&lt;CodeBlocks_layout_file&gt;
+	&lt;File name=&quot;..\LogFile.h&quot; open=&quot;0&quot; top=&quot;0&quot;&gt;
+		&lt;Cursor position=&quot;318&quot; topLine=&quot;0&quot;/&gt;
+	&lt;/File&gt;
+	&lt;File name=&quot;..\UnitManager.cpp&quot; open=&quot;0&quot; top=&quot;0&quot;&gt;
+		&lt;Cursor position=&quot;6256&quot; topLine=&quot;258&quot;/&gt;
+	&lt;/File&gt;
+	&lt;Expand folder=&quot;/Sources&quot;/&gt;
+	&lt;Expand folder=&quot;/Headers/Krogs Metal Class v0.4&quot;/&gt;
+	&lt;Expand folder=&quot;/Headers&quot;/&gt;
+&lt;/CodeBlocks_layout_file&gt;

Added: trunk/AI/Global/RAI-0.553/CombatManager.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/CombatManager.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/CombatManager.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,433 @@
+#include &quot;CombatManager.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+
+cCombatManager::cCombatManager(IAICallback* callback, cRAI* Global)
+{
+	cb=callback;
+	G=Global;
+	l=G-&gt;l;
+}
+
+cCombatManager::~cCombatManager()
+{
+}
+
+void cCombatManager::UnitIdle(const int&amp; unit, UnitInfo *U)
+{
+//*l&lt;&lt;&quot;(cui) -eID=&quot;&lt;&lt;U-&gt;enemyID;
+	if( ValidateEnemy(unit,U) )
+	{
+		if( CanAttack(U,U-&gt;E,GetEnemyPosition(U-&gt;enemyID,U-&gt;E)) == 0 )
+		{
+			U-&gt;enemyID=-1;
+		}
+	}
+	float3 fPos=cb-&gt;GetUnitPos(unit);
+	if( U-&gt;enemyID == -1 )
+	{
+		while( (U-&gt;enemyID=GetClosestEnemy(fPos,U)) &gt; 0 &amp;&amp; !ValidateEnemy(unit,U) ) {}
+	}
+	float fDis = -1;
+	if( U-&gt;enemyID &gt;= 0 )
+	{
+		fDis = fPos.distance(GetEnemyPosition(U-&gt;enemyID,U-&gt;E));
+		if( fDis == 0 )
+			fDis = 1;
+	}
+	if( U-&gt;enemyID == -1 || (U-&gt;pBOL-&gt;task != TASK_ASSAULT &amp;&amp; fDis &gt; 2.5*8*U-&gt;ud-&gt;losRadius) )
+	{
+		U-&gt;bInCombat=false;
+		U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame();
+		return;
+	}
+	else if( CommandDGun(unit,U) )
+		return;
+	else if( U-&gt;enemyEff == 0 || (U-&gt;pBOL-&gt;task != TASK_ASSAULT &amp;&amp; fDis &gt; 1.75*U-&gt;enemyEff-&gt;BestRange ) || (U-&gt;ud-&gt;isCommander &amp;&amp; cb-&gt;GetUnitHealth(unit)/U-&gt;ud-&gt;health &lt;= 0.66 ) ) // || G-&gt;Enemies.find(U-&gt;enemyID)-&gt;second.ud-&gt;kamikazeDist &gt; fDis
+	{
+		float3 EPos = GetEnemyPosition(U-&gt;enemyID,U-&gt;E);
+		CommandRun(unit,U,EPos);
+		return;
+	}
+	else if( CommandCapture(unit,U,fDis) || CommandManeuver(unit,U,fDis) )
+		return;
+	else
+	{
+		float3 EPos = GetEnemyPosition(U-&gt;enemyID,U-&gt;E);
+		Command c;
+		if( U-&gt;ud-&gt;canAttack &amp;&amp; (U-&gt;E-&gt;inLOS || U-&gt;E-&gt;inRadar) )
+		{
+			c.id = CMD_ATTACK;
+			c.params.push_back(U-&gt;enemyID);
+		}
+		else if( U-&gt;ud-&gt;canAttack &amp;&amp; (U-&gt;udr-&gt;IsBomber &amp;&amp; U-&gt;E-&gt;posLocked) )
+		{
+			c.id = CMD_ATTACK;
+			c.params.push_back(EPos.x);
+			c.params.push_back(EPos.y);
+			c.params.push_back(EPos.z);
+		}
+		else // cant see enemy or Mod Workaround: Combat Lords - cant be given attack orders
+		{
+			c.id = CMD_MOVE;
+			c.params.push_back(EPos.x -100.0 +rand()%201 );
+			c.params.push_back(EPos.y);
+			c.params.push_back(EPos.z -100.0 +rand()%201 );
+		}
+
+		cb-&gt;GiveOrder(unit, &amp;c);
+		U-&gt;commandTimeOut=int(GetNextUpdate(fDis,U));
+	}
+}
+
+void cCombatManager::UnitDamaged(const int&amp; unitID, UnitInfo* U, const int&amp; attackerID, EnemyInfo* A, float3&amp; dir)
+{
+	ValidateEnemy(unitID,U,false);
+	if( attackerID &gt;= 0 &amp;&amp; attackerID != U-&gt;enemyID )
+	{
+		float3 Pos = cb-&gt;GetUnitPos(unitID);
+		float3 APos = GetEnemyPosition(attackerID,A);
+		if( U-&gt;enemyID == -1 || Pos.distance(APos) &lt; Pos.distance(GetEnemyPosition(U-&gt;enemyID,U-&gt;E)) )
+		{
+			if( CanAttack(U, A, APos) != 0 &amp;&amp; (U-&gt;Group==0 || U-&gt;Group-&gt;Enemies.find(attackerID) != U-&gt;Group-&gt;Enemies.end()) )
+			{
+				U-&gt;enemyID=attackerID;
+				U-&gt;E = A;
+				U-&gt;enemyEff = CanAttack(U, A, APos);
+			}
+		}
+	}
+	if( U-&gt;bInCombat )
+	{
+		if( U-&gt;ud-&gt;isCommander )
+		{
+			if( int(cb-&gt;GetCurrentUnitCommands(unitID)-&gt;size()) == 0 )
+				UnitIdle(unitID,U);
+			else if( cb-&gt;GetCurrentUnitCommands(unitID)-&gt;front().id != CMD_MOVE )
+			{
+				if( cb-&gt;GetUnitHealth(unitID)/U-&gt;ud-&gt;health &lt;= 0.66 || 
+					(cb-&gt;GetUnitHealth(unitID)/U-&gt;ud-&gt;health &lt;= 0.9 &amp;&amp; cb-&gt;GetCurrentUnitCommands(unitID)-&gt;front().id == CMD_CAPTURE) )
+					UnitIdle(unitID,U);
+			}
+		}
+		return;
+	}
+	if( U-&gt;BuildQ != 0 &amp;&amp; U-&gt;BuildQ-&gt;RS != 0 )
+	{
+		U-&gt;BuildQ-&gt;tryCount = 4; // If the project is destroyed, give up on it
+	}
+	U-&gt;bInCombat=true;
+	if( U-&gt;enemyID == -1 )
+	{
+		if( attackerID &gt;= 0 )
+		{
+			float3 APos = GetEnemyPosition(attackerID,A);
+			CommandRun(unitID,U,APos);
+		}
+		else
+		{
+			float3 EPos = cb-&gt;GetUnitPos(unitID);
+			EPos.x += dir.x*700;
+			EPos.z += dir.z*700;
+			EPos.y = cb-&gt;GetElevation(EPos.x,EPos.z);
+			CommandRun(unitID,U,EPos);
+		}
+	}
+	else
+	{
+		UnitIdle(unitID,U);
+	}
+}
+
+bool cCombatManager::CommandDGun(const int&amp; unitID, UnitInfo *U)
+{
+	if( U-&gt;udr-&gt;DGun == 0 || cb-&gt;GetEnergy() &lt; U-&gt;udr-&gt;DGun-&gt;energycost )
+		return false;
+
+	float3 EPos = GetEnemyPosition(U-&gt;enemyID,U-&gt;E);
+	float EDis = EPos.distance(cb-&gt;GetUnitPos(unitID));
+	if( EDis &gt; 1.05*U-&gt;udr-&gt;DGun-&gt;range )
+		return false;
+
+	if( U-&gt;ud-&gt;isCommander )
+	{
+		if( U-&gt;E-&gt;ud != 0 &amp;&amp; U-&gt;E-&gt;ud-&gt;isCommander )
+		{
+			CommandRun(unitID,U,EPos);
+			return true;
+		}
+	}
+	Command c;
+	c.id=CMD_DGUN;
+	c.params.push_back(EPos.x);
+	c.params.push_back(EPos.y);
+	c.params.push_back(EPos.z);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+	U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+5;
+	return true;
+}
+
+bool cCombatManager::CommandCapture(const int&amp; unitID, UnitInfo* U, const float&amp; EDis)
+{
+	if( !U-&gt;ud-&gt;canCapture ) //|| EDis &gt; 1.5*U-&gt;ud-&gt;buildDistance )
+		return false;
+
+	if( U-&gt;ud-&gt;isCommander &amp;&amp; cb-&gt;GetUnitHealth(unitID)/U-&gt;ud-&gt;health &lt;= 0.9 )
+		return false;
+
+	if( !U-&gt;E-&gt;inLOS || (!cb-&gt;IsUnitParalyzed(U-&gt;enemyID) &amp;&amp; 1.5*U-&gt;ud-&gt;speed &lt; U-&gt;E-&gt;ud-&gt;speed) )
+		return false;
+
+	Command c;
+	c.id = CMD_CAPTURE;
+	c.params.push_back(U-&gt;enemyID);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+	return true;
+}
+/*
+bool cCombatManager::CommandTrap(const int&amp; unitID, UnitInfo* U, const float&amp; EDis)
+{
+	if( !U-&gt;E-&gt;inLOS || U-&gt;ud-&gt;transportMass &lt; U-&gt;E-&gt;ud-&gt;mass )
+		return false;
+	if( U-&gt;ud-&gt;transportCapacity == 0 )
+		return false;
+
+	Command c;
+	c.id = CMD_LOAD_UNITS;
+	c.params.push_back(U-&gt;enemyID);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+	return true;
+}
+*/
+bool cCombatManager::CommandManeuver(const int&amp; unitID, UnitInfo *U, const float&amp; EDis)
+{
+	if( U-&gt;ud-&gt;canfly || U-&gt;E-&gt;ud == 0 || !U-&gt;E-&gt;inLOS || U-&gt;enemyEff-&gt;BestRange &lt;= 1.15*cb-&gt;GetUnitMaxRange(U-&gt;enemyID) || EDis &gt; 3500.0 || int(G-&gt;UMobile.size()) &gt; 60 )
+		return false;
+
+	float3 Pos=cb-&gt;GetUnitPos(unitID);
+	float3 EPos=GetEnemyPosition(U-&gt;enemyID,U-&gt;E);
+
+	if( U-&gt;ud-&gt;minWaterDepth &lt; 0 &amp;&amp; Pos.y &lt;= 0 &amp;&amp; U-&gt;udr-&gt;WeaponSeaEff.BestRange == 0 )
+	{
+		int iS=G-&gt;TM-&gt;GetSector(EPos);
+		if( G-&gt;TM-&gt;SectorValid(iS) &amp;&amp; G-&gt;TM-&gt;Sector[iS].AltSector != 0 )
+		{
+			Pos=G-&gt;TM-&gt;Sector[iS].AltSector-&gt;Pos;
+			Pos.x+=128-rand()%256;
+			Pos.z+=128-rand()%256;
+			Command c;
+			c.id = CMD_MOVE;
+			c.params.push_back(Pos.x);
+			c.params.push_back(cb-&gt;GetElevation(Pos.x,Pos.z));
+			c.params.push_back(Pos.z);
+			cb-&gt;GiveOrder(unitID, &amp;c);
+			U-&gt;commandTimeOut=int(GetNextUpdate(EDis,U));
+			return true;
+		}
+	}
+	if( EDis &lt; 0.70*U-&gt;enemyEff-&gt;BestRange || EDis &gt; U-&gt;enemyEff-&gt;BestRange )
+	{
+		float fDisAway=(0.87*U-&gt;enemyEff-&gt;BestRange-EDis);
+		Pos.x+=(Pos.x-EPos.x)*(fDisAway/EDis);
+		Pos.z+=(Pos.z-EPos.z)*(fDisAway/EDis);
+
+		if( !G-&gt;TM-&gt;CanMoveToPos(U-&gt;mapBody,Pos) )
+			return false;
+
+		Command c;
+		c.id = CMD_MOVE;
+		c.params.push_back(Pos.x);
+		c.params.push_back(cb-&gt;GetElevation(Pos.x,Pos.z));
+		c.params.push_back(Pos.z);
+		cb-&gt;GiveOrder(unitID, &amp;c);
+		U-&gt;commandTimeOut=int(GetNextUpdate(EDis,U));
+		return true;
+	}
+	return false;
+}
+
+void cCombatManager::CommandRun(const int&amp; unitID, UnitInfo *U, float3&amp; EPos)
+{
+	float3 Pos=cb-&gt;GetUnitPos(unitID);
+	Pos.x+=Pos.x-EPos.x;
+	Pos.z+=Pos.z-EPos.z;
+	G-&gt;CorrectPosition(&amp;Pos);
+	Command c;
+	c.id = CMD_MOVE;
+	c.params.push_back(Pos.x);
+	c.params.push_back(cb-&gt;GetElevation(Pos.x,Pos.z));
+	c.params.push_back(Pos.z);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+	U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+210;
+}
+
+int cCombatManager::GetClosestEnemy(float3 Pos, UnitInfo* U)
+{
+	U-&gt;enemyID=-1;
+	if( !G-&gt;UnitM-&gt;ActiveAttackOrders() ) // these two function need improvement, for now ill just use a short cut
+	{
+		return GetClosestThreat(Pos, U);
+	}
+	sWeaponEfficiency* weTemp;
+	float fDis,fTemp;
+	float3 fE;
+	for( map&lt;int,EnemyInfo&gt;::iterator E=G-&gt;Enemies.begin(); E!=G-&gt;Enemies.end(); E++ )
+	{
+		fE=GetEnemyPosition(E-&gt;first,&amp;E-&gt;second);
+		if( (weTemp = CanAttack(U,&amp;E-&gt;second,fE)) != 0 )
+		{
+			fTemp=Pos.distance(fE);
+			if( U-&gt;enemyID == -1 || fTemp &lt; fDis )
+			{
+				U-&gt;enemyID=E-&gt;first;
+				U-&gt;E = &amp;E-&gt;second;
+				U-&gt;enemyEff = weTemp;
+				fDis=fTemp;
+			}
+		}
+	}
+	if( U-&gt;enemyID != -1 &amp;&amp; U-&gt;Group != 0 )
+	{
+		G-&gt;UnitM-&gt;GroupAddEnemy(U-&gt;enemyID,U-&gt;E,U-&gt;Group);
+	}
+	return U-&gt;enemyID;
+}
+
+int cCombatManager::GetClosestThreat(float3 Pos, UnitInfo* U)
+{
+	sWeaponEfficiency* weTemp;
+	float fDis,fTemp;
+	float3 fE;
+	set&lt;int&gt; del;
+	for( map&lt;int,EnemyInfo*&gt;::iterator E=G-&gt;EThreat.begin(); E!=G-&gt;EThreat.end(); E++ )
+	{
+		fE=GetEnemyPosition(E-&gt;first,E-&gt;second);
+		if( E-&gt;second-&gt;baseThreatFrame &gt; cb-&gt;GetCurrentFrame()+3600 ||
+			(E-&gt;second-&gt;baseThreatFrame &gt; cb-&gt;GetCurrentFrame()+1200 &amp;&amp; G-&gt;UImmobile.find(E-&gt;second-&gt;baseThreatID) == G-&gt;UImmobile.end() ) ||
+			(E-&gt;second-&gt;ud != 0 &amp;&amp; G-&gt;UImmobile.find(E-&gt;second-&gt;baseThreatID) != G-&gt;UImmobile.end() &amp;&amp; 1.3*E-&gt;second-&gt;ud-&gt;maxWeaponRange &lt; fE.distance(cb-&gt;GetUnitPos(E-&gt;second-&gt;baseThreatID)) ) )
+		{
+			E-&gt;second-&gt;baseThreatID = -1;
+			E-&gt;second-&gt;baseThreatFrame = -1;
+			del.insert(E-&gt;first);
+		}
+		else if( (weTemp = CanAttack(U,E-&gt;second,fE)) != 0 )
+		{
+			fTemp=Pos.distance(fE);
+			if( U-&gt;enemyID == -1 || fTemp &lt; fDis )
+			{
+				U-&gt;enemyID=E-&gt;first;
+				U-&gt;E = E-&gt;second;
+				U-&gt;enemyEff = weTemp;
+				fDis=fTemp;
+			}
+		}
+	}
+	while( int(del.size()) &gt; 0 )
+	{
+		if( !G-&gt;UnitM-&gt;ActiveAttackOrders() )
+		{
+			EnemyInfo* E = G-&gt;EThreat.find(*del.begin())-&gt;second;
+			while( int(E-&gt;AttackGroups.size()) &gt; 0 )
+				G-&gt;UnitM-&gt;GroupRemoveEnemy(*del.begin(),E,E-&gt;AttackGroups.begin()-&gt;second);
+		}
+		G-&gt;EThreat.erase(*del.begin());
+		del.erase(*del.begin());
+	}
+	if( U-&gt;enemyID != -1 &amp;&amp; U-&gt;Group != 0 )
+	{
+		G-&gt;UnitM-&gt;GroupAddEnemy(U-&gt;enemyID,U-&gt;E,U-&gt;Group);
+	}
+	return U-&gt;enemyID;
+}
+
+float3 cCombatManager::GetEnemyPosition(const int&amp; enemyID, EnemyInfo* E)
+{
+	if( E-&gt;posLocked || (!E-&gt;inLOS &amp;&amp; !E-&gt;inRadar) )
+		return E-&gt;position;
+	return cb-&gt;GetUnitPos(enemyID);
+}
+
+float cCombatManager::GetNextUpdate(const float &amp;Distance, UnitInfo* U)
+{
+	if( U-&gt;ud-&gt;speed == 0.0 )
+		return cb-&gt;GetCurrentFrame()+90.0;
+	float fFrame=30.0*((Distance-U-&gt;enemyEff-&gt;BestRange)/(5.0*U-&gt;ud-&gt;speed));
+	if( int(G-&gt;UMobile.size()) &gt; 45 )
+		fFrame*=3;
+	if( fFrame &gt; 90.0 )
+		return cb-&gt;GetCurrentFrame()+fFrame;
+	return cb-&gt;GetCurrentFrame()+90.0;
+}
+
+sWeaponEfficiency* cCombatManager::CanAttack(UnitInfo* U, EnemyInfo *E, const float3&amp; EPos)
+{
+	if( !G-&gt;TM-&gt;CanMoveToPos(U-&gt;mapBody,EPos) )
+	{
+		return 0;
+	}
+	float fElevation=cb-&gt;GetElevation(EPos.x,EPos.z);
+	if( EPos.y &lt; 0.0 &amp;&amp; U-&gt;udr-&gt;WeaponSeaEff.BestRange &gt; 0 )
+	{
+		return &amp;U-&gt;udr-&gt;WeaponSeaEff;
+	}
+	if( EPos.y-fElevation&gt;50.0 &amp;&amp; U-&gt;udr-&gt;WeaponAirEff.BestRange &gt; 0 )
+	{
+		return &amp;U-&gt;udr-&gt;WeaponAirEff;
+	}
+	if( EPos.y-fElevation&lt;=50.0 &amp;&amp; EPos.y &gt;= -15.0 &amp;&amp; U-&gt;udr-&gt;WeaponLandEff.BestRange &gt; 0 )
+	{
+		return &amp;U-&gt;udr-&gt;WeaponLandEff;
+	}
+	return 0;
+}
+
+bool cCombatManager::ValidateEnemy(const int&amp; unitID, UnitInfo* U, bool IdleIfInvalid)
+{
+	if( U-&gt;enemyID == -1 || G-&gt;Enemies.find(U-&gt;enemyID) == G-&gt;Enemies.end() )
+	{
+		U-&gt;enemyID=-1;
+		if( IdleIfInvalid )
+			U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+90;
+		return false;
+	}
+	if( cb-&gt;GetUnitDef(U-&gt;enemyID) != 0 &amp;&amp; cb-&gt;GetUnitAllyTeam(unitID) == cb-&gt;GetUnitAllyTeam(U-&gt;enemyID) ) // ! Work Around   Spring Version: v0.72b1-0.75b2
+	{
+		*l&lt;&lt;&quot;\nWARNING: ValidateEnemy: ally has captured an enemy U-&gt;enemyID=&quot;&lt;&lt;U-&gt;enemyID;
+		G-&gt;EnemyDestroyed(U-&gt;enemyID,-1);
+		U-&gt;enemyID=-1;
+		return false;
+	}
+	float3 EPos=cb-&gt;GetUnitPos(U-&gt;enemyID);
+	if( U-&gt;Group == 0 )
+	{
+		U-&gt;E = &amp;G-&gt;Enemies.find(U-&gt;enemyID)-&gt;second;
+		U-&gt;enemyEff = CanAttack(U,U-&gt;E,EPos);
+	}
+	if( EPos.x != 0 || EPos.z != 0 || EPos.y != 0 ) // Position is valid
+	{
+		if( !U-&gt;E-&gt;inLOS &amp;&amp; !U-&gt;E-&gt;inRadar &amp;&amp; cb-&gt;GetUnitPos(unitID).distance2D(GetEnemyPosition(U-&gt;enemyID,U-&gt;E)) &lt; 100.0f ) // the enemy id was reused, hopefully thats the only time this happens
+		{
+			*l&lt;&lt;&quot;\nWARNING: ValidateEnemy: Enemy position is valid, but is not in LOS/Radar U-&gt;enemyID=&quot;&lt;&lt;U-&gt;enemyID;
+			G-&gt;EnemyRemove(U-&gt;enemyID,U-&gt;E);
+			U-&gt;enemyID=-1;
+			return false;
+		}
+		return true;
+	}
+	if( U-&gt;E-&gt;inLOS || U-&gt;E-&gt;inRadar ) // ! Work Around   Spring Version: v0.72b1-0.75b2
+	{
+		*l&lt;&lt;&quot;\nWARNING: ValidateEnemy: Enemy Position Invalid  ID=&quot;&lt;&lt;U-&gt;enemyID;
+		if( U-&gt;E-&gt;inLOS )
+			G-&gt;DebugEnemyEnterLOSError++;
+		if( U-&gt;E-&gt;inRadar )
+			G-&gt;DebugEnemyEnterRadarError++;
+	}
+	else if( cb-&gt;GetUnitPos(unitID).distance2D(U-&gt;E-&gt;position) &gt; 300.0f )
+	{
+		return true;
+	}
+	G-&gt;EnemyRemove(U-&gt;enemyID,U-&gt;E);
+	U-&gt;enemyID=-1;
+	if( IdleIfInvalid )
+		U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+90;
+	return false;
+}

Added: trunk/AI/Global/RAI-0.553/CombatManager.h
===================================================================
--- trunk/AI/Global/RAI-0.553/CombatManager.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/CombatManager.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,42 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_COMBAT_MANAGER_H
+#define RAI_COMBAT_MANAGER_H
+
+class cCombatManager;
+
+#include &quot;RAI.h&quot;
+//#include &quot;LogFile.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+
+class cCombatManager
+{
+public:
+	cCombatManager(IAICallback* callback, cRAI* Global);
+	~cCombatManager();
+
+	void UnitIdle(const int&amp; unit, UnitInfo *U);
+	void UnitDamaged(const int&amp; unitID, UnitInfo* U, const int&amp; attackerID, EnemyInfo* A, float3&amp; dir);
+	bool CommandDGun(const int&amp; unitID, UnitInfo* U);
+	bool CommandCapture(const int&amp; unitID, UnitInfo* U, const float&amp; EDis);
+//	bool CommandTrap(const int&amp; unitID, UnitInfo* U, const float&amp; EDis);
+	bool CommandManeuver(const int&amp; unitID, UnitInfo* U, const float&amp; EDis);
+	void CommandRun(const int&amp; unitID, UnitInfo* U, float3&amp; EPos);
+	int GetClosestEnemy(float3 Pos, UnitInfo* U);
+	float3 GetEnemyPosition(const int&amp; enemyID, EnemyInfo* E);
+	float GetNextUpdate(const float&amp; Distance, UnitInfo* U);
+	sWeaponEfficiency* CanAttack(UnitInfo* U, EnemyInfo* E, const float3&amp; EPos);
+	bool ValidateEnemy(const int&amp; unitID, UnitInfo* U, bool IdleIfInvalid=true);
+
+private:
+	int GetClosestThreat(float3 Pos, UnitInfo* U);
+	cLogFile *l;
+	IAICallback* cb;
+	cRAI* G;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/DevC/(Bot-libs).lnk
===================================================================
(Binary files differ)


Property changes on: trunk/AI/Global/RAI-0.553/DevC/(Bot-libs).lnk
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/AI/Global/RAI-0.553/DevC/RAI.dev
===================================================================
--- trunk/AI/Global/RAI-0.553/DevC/RAI.dev	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/DevC/RAI.dev	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,389 @@
+[Project]
+FileName=RAI.dev
+Name=RAI
+UnitCount=27
+Type=3
+Ver=1
+ObjFiles=
+Includes=..\..\..\..\rts;..\..\..\..\rts\system;..\..\..\..\..\mingwlibs\include
+Libs=
+PrivateResource=
+ResourceIncludes=
+MakeIncludes=
+Compiler=-DBUILDING_DLL=1_@@_
+CppCompiler=-DBUILDING_DLL=1_@@_
+Linker=--no-export-all-symbols --add-stdcall-alias_@@_C:/Dev-Cpp/lib/libgdi32.a_@@_
+IsCpp=1
+Icon=
+ExeOutput=
+ObjectOutput=Ming
+OverrideOutput=1
+OverrideOutputName=RAI.dll
+HostApplication=
+Folders=Header,&quot;Krogs Metal Class v0.4&quot;,Source
+CommandLine=
+UseCustomMakefile=0
+CustomMakefile=
+IncludeVersionInfo=0
+SupportXPThemes=0
+CompilerSet=0
+CompilerSettings=0011000000010000000100
+
+[Unit11]
+FileName=..\GMetalMap.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit13]
+FileName=..\GTerrainMap.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit15]
+FileName=..\LogFile.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit20]
+FileName=..\SWeaponManager.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit21]
+FileName=..\SWeaponManager.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit22]
+FileName=..\UnitDef.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit23]
+FileName=..\UnitDef.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit24]
+FileName=..\UnitManager.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit25]
+FileName=..\UnitManager.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit27]
+FileName=..\Krogs Metal Class v0.4\MetalMap.h
+CompileCpp=1
+Folder=Krogs Metal Class v0.4
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit28]
+FileName=..\TaskSuicide.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit29]
+FileName=..\TaskSupport.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit30]
+FileName=..\TaskSupport.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[VersionInfo]
+Major=0
+Minor=1
+Release=1
+Build=1
+LanguageID=1033
+CharsetID=1252
+CompanyName=
+FileVersion=
+FileDescription=Developed using the Dev-C++ IDE
+InternalName=
+LegalCopyright=
+LegalTrademarks=
+OriginalFilename=
+ProductName=
+ProductVersion=
+AutoIncBuildNr=0
+
+[Unit31]
+FileName=..\TaskTransport.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit32]
+FileName=..\TaskTransport.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit34]
+FileName=..\Krogs Metal Class v0.4\MetalMap.h
+CompileCpp=1
+Folder=Krogs Metal Class v0.4
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit33]
+FileName=..\Krogs Metal Class v0.4\MetalMap.cpp
+CompileCpp=1
+Folder=Krogs Metal Class v0.4
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit14]
+FileName=..\LogFile.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit26]
+FileName=..\Krogs Metal Class v0.4\MetalMap.cpp
+CompileCpp=1
+Folder=Krogs Metal Class v0.4
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit1]
+FileName=..\Builder.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit2]
+FileName=..\Builder.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit3]
+FileName=..\BuilderPlacement.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit4]
+FileName=..\BuilderPlacement.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit5]
+FileName=..\CombatManager.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit6]
+FileName=..\CombatManager.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit7]
+FileName=..\Global.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit8]
+FileName=..\Global.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit9]
+FileName=..\GlobalAIs.cpp
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit10]
+FileName=..\GMetalMap.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit12]
+FileName=..\GTerrainMap.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit16]
+FileName=..\PowerManager.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit17]
+FileName=..\PowerManager.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit18]
+FileName=..\RAI.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit19]
+FileName=..\RAI.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+

Added: trunk/AI/Global/RAI-0.553/DevC/RAI.layout
===================================================================
--- trunk/AI/Global/RAI-0.553/DevC/RAI.layout	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/DevC/RAI.layout	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,241 @@
+[Editor_0]
+CursorCol=1
+CursorRow=35
+TopLine=35
+LeftChar=1
+Open=0
+Top=0
+[Editor_29]
+CursorCol=1
+CursorRow=39
+TopLine=14
+LeftChar=1
+Open=0
+Top=0
+[Editor_28]
+CursorCol=1
+CursorRow=29
+TopLine=4
+LeftChar=1
+Open=0
+Top=0
+[Editors]
+Order=
+Focused=-1
+[Editor_1]
+Open=0
+Top=0
+CursorCol=31
+CursorRow=29
+TopLine=18
+LeftChar=1
+[Editor_2]
+Open=0
+Top=0
+CursorCol=2
+CursorRow=69
+TopLine=35
+LeftChar=1
+[Editor_3]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=40
+TopLine=4
+LeftChar=1
+[Editor_4]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=31
+TopLine=1
+LeftChar=1
+[Editor_5]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=37
+TopLine=1
+LeftChar=1
+[Editor_6]
+Open=0
+Top=0
+CursorCol=13
+CursorRow=18
+TopLine=4
+LeftChar=1
+[Editor_7]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=30
+TopLine=1
+LeftChar=1
+[Editor_8]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=31
+TopLine=1
+LeftChar=1
+[Editor_9]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=41
+TopLine=4
+LeftChar=1
+[Editor_10]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=6
+TopLine=1
+LeftChar=1
+[Editor_11]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=37
+TopLine=1
+LeftChar=1
+[Editor_12]
+Open=0
+Top=0
+CursorCol=13
+CursorRow=24
+TopLine=1
+LeftChar=1
+[Editor_13]
+Open=0
+Top=0
+CursorCol=4
+CursorRow=39
+TopLine=16
+LeftChar=1
+[Editor_14]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=24
+TopLine=1
+LeftChar=1
+[Editor_15]
+Open=0
+Top=0
+CursorCol=3
+CursorRow=15
+TopLine=1
+LeftChar=1
+[Editor_16]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=17
+TopLine=1
+LeftChar=1
+[Editor_17]
+Open=0
+Top=0
+CursorCol=6
+CursorRow=25
+TopLine=1
+LeftChar=1
+[Editor_18]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=48
+TopLine=11
+LeftChar=1
+[Editor_19]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=110
+TopLine=74
+LeftChar=1
+[Editor_20]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=42
+TopLine=5
+LeftChar=1
+[Editor_21]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=39
+TopLine=2
+LeftChar=1
+[Editor_22]
+Open=0
+Top=0
+CursorCol=24
+CursorRow=105
+TopLine=137
+LeftChar=1
+[Editor_23]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=303
+TopLine=267
+LeftChar=1
+[Editor_24]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=67
+TopLine=21
+LeftChar=1
+[Editor_25]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=39
+TopLine=1
+LeftChar=1
+[Editor_26]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=48
+TopLine=11
+LeftChar=1
+[Editor_27]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=39
+TopLine=14
+LeftChar=1
+[Editor_30]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=57
+TopLine=32
+LeftChar=1
+[Editor_31]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=38
+TopLine=16
+LeftChar=1
+[Editor_32]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=393
+TopLine=330
+LeftChar=1
+[Editor_33]
+Open=0
+Top=0
+CursorCol=1
+CursorRow=50
+TopLine=25
+LeftChar=1

Added: trunk/AI/Global/RAI-0.553/DevC/crtbegin.o
===================================================================
(Binary files differ)


Property changes on: trunk/AI/Global/RAI-0.553/DevC/crtbegin.o
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/AI/Global/RAI-0.553/DevC/crtend.o
===================================================================
(Binary files differ)


Property changes on: trunk/AI/Global/RAI-0.553/DevC/crtend.o
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/AI/Global/RAI-0.553/DevC/dllcrt2.o
===================================================================
(Binary files differ)


Property changes on: trunk/AI/Global/RAI-0.553/DevC/dllcrt2.o
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/AI/Global/RAI-0.553/GMetalMap.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/GMetalMap.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/GMetalMap.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,40 @@
+#include &quot;GMetalMap.h&quot;
+#include &lt;set&gt;
+
+cRMetalMap::cRMetalMap(IAICallback* cb, cLogFile* l)
+{
+	*l&lt;&lt;&quot;\n Get Max Metal: &quot;&lt;&lt;cb-&gt;GetMaxMetal();
+
+	int MetalZSize =cb-&gt;GetMapHeight() / 2;
+	int MetalXSize =cb-&gt;GetMapWidth() / 2;
+	int XtractorRadius = int(cb-&gt;GetExtractorRadius()/16.0);
+	const unsigned char *MetalMap = cb-&gt;GetMetalMap();
+	set&lt;int&gt; Remaining;
+	set&lt;int&gt; Discarded;
+	set&lt;int&gt; Current;
+	for(int z=0; z &lt; MetalZSize; z++)
+	{
+//		*l&lt;&lt;&quot;\n&quot;;
+		for(int x=0; x &lt; MetalXSize; x++)
+		{
+//			*l&lt;&lt;&quot; &quot;&lt;&lt;MetalMap[z*MetalXSize + x];
+			if( MetalMap[z*MetalXSize + x] &gt; '0' )
+			{
+				Remaining.insert(z*MetalXSize + x);
+//				*l&lt;&lt;&quot;*&quot;;
+			}
+		}
+	}
+
+	while( int(Remaining.size()) &gt; 0 )
+	{
+		int m = *Remaining.begin();
+		Remaining.erase(m);
+		Current.insert(m);
+	}
+}
+
+cRMetalMap::~cRMetalMap()
+{
+
+}

Added: trunk/AI/Global/RAI-0.553/GMetalMap.h
===================================================================
--- trunk/AI/Global/RAI-0.553/GMetalMap.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/GMetalMap.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,22 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_METALMAP_H
+#define RAI_METALMAP_H
+
+#include &quot;ExternalAI/IAICallback.h&quot;
+#include &quot;LogFile.h&quot;
+
+class cRMetalMap
+{
+public:
+	cRMetalMap(IAICallback* callback, cLogFile* logfile);
+	virtual ~cRMetalMap();
+
+private:
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/GTerrainMap.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/GTerrainMap.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/GTerrainMap.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,345 @@
+#include &quot;GTerrainMap.h&quot;
+#include &lt;set&gt;
+//#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+//#include &quot;StdAfx.h&quot;
+//#include &quot;CommanderScript.h&quot;
+//#include &quot;Map/ReadMap.h&quot;
+//#include &quot;TdfParser.h&quot;
+//#include &quot;Other/SunParser.h&quot;
+//#include &quot;OTAI/SunParser.h&quot;
+
+cTerrainMap::cTerrainMap(IAICallback* cb, cLogFile* logfile)
+{
+	l=logfile;
+	*l&lt;&lt;&quot;\n Loading cTerrainMap ...&quot;;
+	PercentMetal=0;
+	PercentLand=0;
+	// cb-&gt;GetMapWidth(),cb-&gt;GetMapHeight()  8/8 Map Unit
+	SectorZSize = cb-&gt;GetMapHeight()/32; // 32*8/32*8 = 512/512 Map Display Unit
+	SectorXSize = cb-&gt;GetMapWidth()/(cb-&gt;GetMapHeight()/SectorZSize);
+	*l&lt;&lt;&quot;\n  Sector Size = x&quot;&lt;&lt;SectorXSize&lt;&lt;&quot; z&quot;&lt;&lt;SectorZSize;
+	Sector = new MapSector[SectorXSize*SectorZSize];
+	int i;
+	for(int z=0; z &lt; SectorZSize; z++)
+	{
+		for(int x=0; x &lt; SectorXSize; x++)
+		{
+			i=(z*SectorXSize)+x;
+			Sector[i].Pos.x=x*256+128; // Center Position of Block
+			Sector[i].Pos.z=z*256+128; //
+			Sector[i].Pos.y=cb-&gt;GetElevation(Sector[i].Pos.x,Sector[i].Pos.z);
+		}
+	}
+
+	const int SearchHeight=cb-&gt;GetMapHeight()/4; // 4*8/4*8 = 32/32 Search Block Unit
+	const int SearchWidth =cb-&gt;GetMapWidth()/(cb-&gt;GetMapHeight()/SearchHeight);
+	const float DtoS=8.0*(cb-&gt;GetMapHeight()/SearchHeight); // 32, Distance index to Search index conversion
+	const int StoS=SearchHeight/SectorZSize;				// 8, Search index to Sector index conversion
+	const int StoM=(cb-&gt;GetMapHeight()/SearchHeight)/2;		// 2, Search index to MetalMap index conversion
+	*l&lt;&lt;&quot;\n  Distance to Search Index = &quot;&lt;&lt;DtoS;
+	*l&lt;&lt;&quot;\n  Search Index to Sector Index = &quot;&lt;&lt;StoS;
+	*l&lt;&lt;&quot;\n  Search Index to MetalMap Index = &quot;&lt;&lt;StoM;
+	*l&lt;&lt;&quot;\n  Search Size = x&quot;&lt;&lt;SearchWidth&lt;&lt;&quot; z&quot;&lt;&lt;SearchHeight;
+	*l&lt;&lt;&quot;\n  Search Width * Search Height = &quot;&lt;&lt;SearchWidth*SearchHeight;
+
+	set&lt;int&gt; m;
+	for(int z=0; z &lt; SearchHeight; z++)
+	{
+		for(int x=0; x &lt; SearchWidth; x++)
+		{
+			i=z*SearchWidth+x;
+			m.insert(i);
+		}
+	}
+
+	*l&lt;&lt;&quot;\n  Searching Map for Land Masses ...&quot;;
+	const unsigned char *MetalMapArray = cb-&gt;GetMetalMap();
+	typedef pair&lt;int,MapSector*&gt; imPair;
+	MapBodySize=0;
+	int MBIndex;
+	deque&lt;int&gt; Search;
+	while( int(m.size())&gt;0 || int(Search.size())&gt;0 )
+	{
+		if( int(Search.size()) &gt; 0 )
+		{
+			int x=Search.front()%SearchWidth;
+			int z=Search.front()/SearchWidth;
+
+			if( (cb-&gt;GetElevation(DtoS*x+DtoS/2,DtoS*z+DtoS/2) &lt;= 0.0 &amp;&amp; MapB[MBIndex]-&gt;Water) ||
+				(cb-&gt;GetElevation(DtoS*x+DtoS/2,DtoS*z+DtoS/2) &gt; 0.0 &amp;&amp; !MapB[MBIndex]-&gt;Water) )
+			{
+				MapB[MBIndex]-&gt;PercentOfMap+=1.0;
+				if( MetalMapArray[StoM*z*StoM*SearchWidth + StoM*x] &gt; 0 )
+					MapB[MBIndex]-&gt;PercentMetal+=1.0;
+
+				i=SectorXSize*(z/StoS)+(x/StoS);
+				if( MapB[MBIndex]-&gt;Sector.find(i) == MapB[MBIndex]-&gt;Sector.end() )
+					MapB[MBIndex]-&gt;Sector.insert(imPair(i,&amp;Sector[i]));
+
+				i=z*SearchWidth+x;
+				if( m.find(i-1)!=m.end() &amp;&amp; x &gt; 0 ) // Search left
+				{
+					Search.push_back(i-1);
+					m.erase(i-1);
+				}
+				if( m.find(i+1)!=m.end() &amp;&amp; x &lt; SearchWidth-1 ) // Search right
+				{
+					Search.push_back(i+1);
+					m.erase(i+1);
+				}				
+				if( m.find(i-SearchWidth)!=m.end() &amp;&amp; z &gt; 0 ) // Search up
+				{
+					Search.push_back(i-SearchWidth);
+					m.erase(i-SearchWidth);
+				}				
+				if( m.find(i+SearchWidth)!=m.end() &amp;&amp; z &lt; SearchHeight-1 ) // Search down
+				{
+					Search.push_back(i+SearchWidth);
+					m.erase(i+SearchWidth);
+				}		
+			}
+			else
+				m.insert(Search.front()); // not the same land mass, add back to global list
+			Search.pop_front();
+		}
+		else
+		{
+			if( MapBodySize == 50 || (MapBodySize&gt;0 &amp;&amp; (MapB[MapBodySize-1]-&gt;PercentOfMap &lt;= 16.0 || MapB[MapBodySize-1]-&gt;PercentOfMap/(SearchWidth*SearchHeight) &lt;= 0.005 ) ) ) // Too mand landmasses detected.  find, erase &amp; ignore the smallest landmass
+			{
+				if( MapBodySize == 50 )
+				{
+					*l&lt;&lt;&quot;\nWARNING: Land Mass Limit Reached (possible error).&quot;;
+				}
+
+				MBIndex=-1;
+				for( int iMB=0; iMB&lt;MapBodySize; iMB++ )
+				{
+					if( MBIndex == -1 || MapB[MBIndex]-&gt;PercentOfMap &gt; MapB[iMB]-&gt;PercentOfMap )
+						MBIndex = iMB;
+				}
+				delete MapB[MBIndex];
+				MapBodySize--;
+			}
+			else
+				MBIndex=MapBodySize;
+
+			i=*m.begin();
+			int x=i%SearchWidth;
+			int z=i/SearchWidth;
+
+			Search.push_back(i);
+			m.erase(i);
+			MapB[MBIndex]=new MapBody(MBIndex);
+			if( cb-&gt;GetElevation(DtoS*x+DtoS/2,DtoS*z+DtoS/2) &lt;= 0 )
+			{
+				MapB[MBIndex]-&gt;Water=true;
+			}
+			else
+			{
+				MapB[MBIndex]-&gt;Water=false;
+			}
+			MapBodySize++;
+		}
+	}
+	if( MapBodySize&gt;0 &amp;&amp; MapB[MapBodySize-1]-&gt;PercentOfMap &lt;= 32.0 )
+	{
+		delete MapB[MapBodySize-1];
+		MapBodySize--;
+	}
+
+	*l&lt;&lt;&quot;\n  Calculating PercentOfMap &amp; Determining Sector Types ...&quot;;
+	MetalMapWater=false;
+	MetalMapLand=false;
+	typedef pair&lt;int,MapBody*&gt; ibPair;
+	for( int iMB=0; iMB&lt;MapBodySize; iMB++ )
+	{
+		MapB[iMB]-&gt;PercentMetal = 100.0*(MapB[iMB]-&gt;PercentMetal/MapB[iMB]-&gt;PercentOfMap);
+		MapB[iMB]-&gt;PercentOfMap *= 100.0/(SearchWidth*SearchHeight);
+		for( map&lt;int,MapSector*&gt;::iterator iS=MapB[iMB]-&gt;Sector.begin(); iS!=MapB[iMB]-&gt;Sector.end(); iS++ )
+		{
+			iS-&gt;second-&gt;mb.insert(ibPair(iMB,MapB[iMB]));
+			if( MapB[iMB]-&gt;Water )
+				iS-&gt;second-&gt;Water=true;
+			else
+				iS-&gt;second-&gt;Land=true;
+		}
+
+		if( MapB[iMB]-&gt;PercentOfMap &gt;= 10.0 &amp;&amp; MapB[iMB]-&gt;PercentMetal &gt;= 90.0 &amp;&amp; cb-&gt;GetExtractorRadius() &lt;= 45.0 )
+		{
+			MapB[iMB]-&gt;MetalMap = true;
+			if( MapB[iMB]-&gt;Water )
+				MetalMapWater=true;
+			else
+				MetalMapLand=true;
+		}
+		else
+		{
+			MapB[iMB]-&gt;MetalMap = false;
+		}
+	}
+
+	MapBMainLand=0;
+	MapBMainWater=0;
+	for( int i=0; i&lt;MapBodySize; i++ )
+	{
+		if( !MapB[i]-&gt;Water &amp;&amp; (MapBMainLand == 0 || MapBMainLand-&gt;PercentOfMap &lt; MapB[i]-&gt;PercentOfMap) )
+			MapBMainLand=MapB[i];
+		if( MapB[i]-&gt;Water &amp;&amp; (MapBMainWater == 0 || MapBMainWater-&gt;PercentOfMap &lt; MapB[i]-&gt;PercentOfMap) )
+			MapBMainWater=MapB[i];
+	}
+
+	*l&lt;&lt;&quot;\n  Determining Closest Sectors for each Sector by Land Mass ...&quot;;
+	for( int iS=0; iS&lt;SectorXSize*SectorZSize; iS++ )
+	{
+		for( int iMB=0; iMB&lt;MapBodySize; iMB++ )
+		{
+			float fClosest=-1.0;
+			int iBest=-1;
+			for( map&lt;int,MapSector*&gt;::iterator iMS=MapB[iMB]-&gt;Sector.begin(); iMS!=MapB[iMB]-&gt;Sector.end(); iMS++ )
+			{
+				if( iBest == -1 || Sector[iS].Pos.distance(iMS-&gt;second-&gt;Pos) &lt; fClosest )
+				{
+					fClosest = Sector[iS].Pos.distance(iMS-&gt;second-&gt;Pos);
+					iBest = iMS-&gt;first;
+				}
+			}
+			Sector[iS].ms.insert(imPair(iMB,&amp;Sector[iBest]));
+		}
+
+		int BestBody;
+		for( int iMB=0; iMB&lt;MapBodySize; iMB++ )
+		{
+			if( (Sector[iS].Land &amp;&amp; Sector[iS].ms.find(iMB)-&gt;second-&gt;Water) ||
+				(Sector[iS].Water &amp;&amp; Sector[iS].ms.find(iMB)-&gt;second-&gt;Land) )
+			{
+				if( Sector[iS].AltSector == 0 || MapB[iMB]-&gt;PercentOfMap &gt; 1.75*MapB[BestBody]-&gt;PercentOfMap ||
+					(1.75*MapB[iMB]-&gt;PercentOfMap &gt; MapB[BestBody]-&gt;PercentOfMap &amp;&amp;
+					2.25*Sector[iS].Pos.distance(Sector[iS].ms.find(iMB)-&gt;second-&gt;Pos) &lt; Sector[iS].Pos.distance(Sector[iS].ms.find(BestBody)-&gt;second-&gt;Pos)) )
+				{
+					BestBody=iMB;
+					Sector[iS].AltSector=Sector[iS].ms.find(iMB)-&gt;second;
+				}
+			}
+		}
+		if( !Sector[iS].Land &amp;&amp; !Sector[iS].Water )
+			Sector[iS].AltSector = &amp;Sector[iS];
+	}
+
+	*l&lt;&lt;&quot;\n  Displaying Land/Water Masses ...&quot;;
+	for( int i=0; i&lt;MapBodySize; i++ )
+	{
+		*l&lt;&lt;&quot;\n  &quot;;
+		if( MapB[i]-&gt;Water )
+			*l&lt;&lt;&quot;Water Mass &quot;;
+		else
+			*l&lt;&lt;&quot;Land Mass  &quot;;
+
+		*l&lt;&lt;&quot;(&quot;&lt;&lt;i+1&lt;&lt;&quot;), occuping &quot;&lt;&lt;MapB[i]-&gt;PercentOfMap&lt;&lt;&quot;% of the map (&quot;&lt;&lt;MapB[i]-&gt;PercentMetal&lt;&lt;&quot;% Metal) &quot;;
+		if( MapB[i]-&gt;MetalMap )
+			*l&lt;&lt;&quot;(MetalMap)&quot;;
+		*l&lt;&lt;&quot;, has been detected in Sectors:&quot;;
+		for( map&lt;int,MapSector*&gt;::iterator iM=MapB[i]-&gt;Sector.begin(); iM!=MapB[i]-&gt;Sector.end(); iM++ )
+		{
+			*l&lt;&lt;&quot; (&quot;&lt;&lt;int(iM-&gt;second-&gt;Pos.x/256)&lt;&lt;&quot;,&quot;&lt;&lt;int(iM-&gt;second-&gt;Pos.z/256)&lt;&lt;&quot;)&quot;;
+		}
+	}
+
+	if( MetalMapLand )
+		*l&lt;&lt;&quot;\n  (Land Metal Map Detected)&quot;;   
+	if( MetalMapWater )
+		*l&lt;&lt;&quot;\n  (Water Metal Map Detected)&quot;;   
+
+	int MapHeight=(cb-&gt;GetMapHeight())/2;
+	int MapWidth=(cb-&gt;GetMapWidth())/2;
+	for(int z=0; z &lt; MapHeight; z++)
+		for(int x=0; x &lt; MapWidth; x++)
+		{
+			i=(z*MapWidth)+x;
+			if( MetalMapArray[i] &gt; 0 )
+				PercentMetal=((PercentMetal*i)+1)/(i+1);
+			else
+				PercentMetal=((PercentMetal*i)+0)/(i+1);
+		}
+	PercentMetal*=100.0;
+	*l&lt;&lt;&quot;\n  Map Metal Percent: &quot;&lt;&lt;PercentMetal&lt;&lt;&quot;%&quot;;
+
+	MaxWaterDepth=0;
+	MapHeight=cb-&gt;GetMapHeight();
+	MapWidth =cb-&gt;GetMapWidth();
+	const float *HeightMapArray = cb-&gt;GetHeightMap();
+	for(int z=0; z &lt; MapHeight; z++)
+		for(int x=0; x &lt; MapWidth; x++)
+		{
+			i=(z*MapWidth)+x;
+			if( HeightMapArray[i] &gt; 0 )
+				PercentLand=((PercentLand*i)+1)/(i+1);
+			else
+				PercentLand=((PercentLand*i)+0)/(i+1);
+			if( HeightMapArray[i] &lt; MaxWaterDepth )
+				MaxWaterDepth = HeightMapArray[i];
+		}
+	PercentLand*=100.0;
+	*l&lt;&lt;&quot;\n  Map Land Percent: &quot;&lt;&lt;PercentLand&lt;&lt;&quot;%&quot;;
+	*l&lt;&lt;&quot;\n  Max Water Depth: &quot;&lt;&lt;MaxWaterDepth;
+	if( MaxWaterDepth == 0 )
+		MaxWaterDepth = -1; // important for calculations that use this
+/*
+	*l&lt;&lt;&quot;\n  Loading Map &quot;;
+	string s = &quot;maps/&quot;;
+	s += cb-&gt;GetMapName();
+	int size = cb-&gt;GetFileSize(s.c_str());
+    if(size == -1)
+    {
+		*l&lt;&lt;&quot;\nERROR: File not found: &quot;&lt;&lt;s;
+        return;
+    }
+	*l&lt;&lt;&quot;\nFile: '&quot;&lt;&lt;s&lt;&lt;&quot;' size=&quot;&lt;&lt;size;
+	char *buf = new char[size];
+	*l&lt;&lt;&quot;.&quot;;
+	cb-&gt;ReadFile(s.c_str(),buf, size);
+
+	*l&lt;&lt;&quot;\nreading it&quot;;
+	for( int i=0; i&lt;size; i++ )
+	{
+		if(*buf == '[') //sectionname
+		{
+			string thissection = &quot;&quot;;
+			while(*(++buf)!=']')
+			{
+				thissection += *buf;
+			}
+			*l&lt;&lt;&quot;\nSection=&quot;&lt;&lt;thissection;
+		}
+	}
+*l&lt;&lt;&quot;\ndone?&quot;;
+*/
+}
+
+cTerrainMap::~cTerrainMap()
+{
+	for( int i=0; i&lt;MapBodySize; i++ )
+		delete MapB[i];
+	delete [] Sector;
+}
+
+int cTerrainMap::GetSector(const float3&amp; Position)
+{
+	return SectorXSize*(int(Position.z)/256) + int(Position.x)/256;
+}
+
+bool cTerrainMap::CanMoveToPos(int MapBody, float3 Destination)
+{
+	int iS = GetSector(Destination);
+	if( !SectorValid(iS) )
+		return false;
+	if( MapBody == -1 || Sector[iS].mb.find(MapBody) != Sector[iS].mb.end() || MapBody == -2 ) // MapBody == -2 mean the unit probably cant move 'at all', but go ahead and let it try
+		return true;
+	return false;
+}
+
+bool cTerrainMap::SectorValid(const int&amp; SectorI)
+{
+	if( SectorI &lt; 0 || SectorI &gt; SectorXSize*SectorZSize -1 )
+		return false;
+	return true;
+}

Added: trunk/AI/Global/RAI-0.553/GTerrainMap.h
===================================================================
--- trunk/AI/Global/RAI-0.553/GTerrainMap.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/GTerrainMap.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,83 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_TERRAIN_MAP_H
+#define RAI_TERRAIN_MAP_H
+
+struct MapBody;
+struct MapSector;
+
+#include &quot;ExternalAI/IAICallback.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;LogFile.h&quot;
+#include &lt;map&gt;
+
+//#define SECTOR_SIZE 256
+
+struct MapSector
+{
+	MapSector()
+	{
+		Water=false;
+		Land=false;
+		AltSector=0;
+	};
+	bool Water;
+	bool Land;
+	float3 Pos;				// center of the sector, same as unit positions
+	MapSector* AltSector;	// if land then best water sector, if water then best land sector, else self
+	map&lt;int,MapBody*&gt; mb;	// key = MapBody index
+	map&lt;int,MapSector*&gt; ms; // key = MapBody index, closest sector of this land mass, equal to self if this sector is part of the same land mass.
+};
+
+struct MapBody
+{
+	MapBody(int Index)
+	{
+		index=Index;
+		PercentOfMap=0.0;
+		PercentMetal=0.0;
+		MetalMap=false;
+	};
+	bool Water;
+	int index;
+	float PercentOfMap; // 0-100
+	float PercentMetal; // 0-100
+	bool MetalMap;
+	map&lt;int,MapSector*&gt; Sector; // key = sector index
+};
+
+class cTerrainMap
+{
+public:
+	cTerrainMap(IAICallback* cb, cLogFile* logfile);
+	~cTerrainMap();
+
+	int GetSector(const float3&amp; Position); // use SectorValid() to insure the index is valid
+	bool CanMoveToPos(int MapBody, float3 Destination);
+	bool SectorValid(const int&amp; SectorI);
+
+	bool MetalMapLand;
+	bool MetalMapWater;
+	float PercentMetal;
+	float PercentLand;
+	float MaxWaterDepth;
+
+	MapSector *Sector;
+	int SectorXSize;
+	int SectorZSize;
+
+	MapBody *MapB[50];
+	int MapBodySize;
+	MapBody *MapBMainLand;	// Largest Land Mass, otherwise = 0
+	MapBody *MapBMainWater; // Largest Water Mass, otherwise = 0
+
+private:
+	cLogFile *l;
+//	IAICallback* cb;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/Global.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/Global.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/Global.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,183 @@
+#include &quot;Global.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;Sim/Features/FeatureDef.h&quot;
+#include &lt;time.h&gt;		// time(NULL)
+
+cRAIGlobal::cRAIGlobal(IAICallback* cb)
+{
+	ClearLogFiles(cb);
+	l=new cLogFile(&quot;RAIGlobal_LastGame.log&quot;,false);
+	*l&lt;&lt;&quot;Loading ...&quot;;
+
+/*
+	int *F = new int[10000];
+	int FSize = cb-&gt;GetFeatures(F,10000)
+	*l&lt;&lt;&quot;\n cb-&gt;GetFeatures(F,10000) no longer crashes.&quot;;
+*/
+//	*l&lt;&lt;&quot;\n Team=&quot;&lt;&lt;cb-&gt;GetMyTeam();
+	int seed = time(NULL);
+	srand(seed);
+//	*l&lt;&lt;&quot;\n Random Seed = &quot;&lt;&lt;seed;
+
+	*l&lt;&lt;&quot;\n Mod = &quot;&lt;&lt;cb-&gt;GetModName();
+	*l&lt;&lt;&quot;\n Map = &quot;&lt;&lt;cb-&gt;GetMapName();
+
+	AIs=0;
+	TM = new cTerrainMap(cb,l);
+
+	*l&lt;&lt;&quot;\n Loading cMetalMap ...&quot;;
+	KMM = new CMetalMap(cb);
+	KMM-&gt;Init();
+
+//	RMM = new cRMetalMap(cb,l);
+
+	const UnitDef **uds = new const UnitDef*[cb-&gt;GetNumUnitDefs()];
+	cb-&gt;GetUnitDefList(uds);
+	int minXSize=-1;
+	int minZSize=-1;
+	int udSize=cb-&gt;GetNumUnitDefs();
+	for( int iud=udSize-1; iud&gt;=0; iud-- )
+	{
+		if( uds[iud] == 0 ) // War Alien VS Human v1.0 workaround
+		{
+			cb-&gt;SendTextMsg(&quot;WARNING: Mod Unit Definition Invalid.&quot;,0);
+			*l&lt;&lt;&quot;\n  WARNING: (unitdef-&gt;id=&quot;&lt;&lt;iud+1&lt;&lt;&quot;) Mod UnitDefList[&quot;&lt;&lt;iud&lt;&lt;&quot;] = 0&quot;;
+			udSize--;
+			uds[iud] = uds[udSize];
+		}
+		else if( uds[iud]-&gt;extractsMetal &gt; 0 &amp;&amp; (minXSize == -1 || 8*uds[iud]-&gt;xsize &lt; minXSize ) )
+		{
+			minXSize=8*uds[iud]-&gt;xsize;
+			minZSize=8*uds[iud]-&gt;ysize;
+		}
+	}
+
+	*l&lt;&lt;&quot;\n Validating Metal Spots ...&quot;;
+	float searchDis=cb-&gt;GetExtractorRadius()/2.0f;
+	if( searchDis &lt; 16.0f )
+		searchDis = 16.0f;
+	for(int iM=int(KMM-&gt;VectoredSpots.size())-1; iM&gt;=0; iM--)
+	{
+		KMM-&gt;VectoredSpots.at(iM).y=cb-&gt;GetElevation(KMM-&gt;VectoredSpots.at(iM).x,KMM-&gt;VectoredSpots.at(iM).z);
+		float3 Location=KMM-&gt;VectoredSpots.at(iM);
+		bool CanBuilt=false;
+		for( int iud=0; iud&lt;udSize; iud++ )
+		{
+			const UnitDef* ud=uds[iud];
+			if( ud-&gt;extractsMetal &gt; 0.0 )
+			{
+				float3 Pos=cb-&gt;ClosestBuildSite(ud,KMM-&gt;VectoredSpots.at(iM),searchDis,0);
+				if( cb-&gt;CanBuildAt(ud,Pos) )
+				{
+					CanBuilt=true;
+					iud=udSize; // End Loop
+				}
+			}
+		}
+		if( CanBuilt )
+		{
+			for(int iM2=0; iM2&lt;iM; iM2++)
+			{
+				if( Location.distance2D(KMM-&gt;VectoredSpots.at(iM2)) &lt;= 8.0+minXSize || Location.distance2D(KMM-&gt;VectoredSpots.at(iM2)) &lt;= 8.0+minZSize )
+				{
+					float3 Location2=KMM-&gt;VectoredSpots.at(iM2);
+					*l&lt;&lt;&quot;\n  Metal Resource located at (x&quot;&lt;&lt;Location2.x&lt;&lt;&quot; z&quot;&lt;&lt;Location2.z&lt;&lt;&quot; y&quot;&lt;&lt;Location2.y&lt;&lt;&quot;) is unusable in this mod (due to close distance to other metal spots).&quot;;
+					KMM-&gt;VectoredSpots.erase(KMM-&gt;VectoredSpots.begin()+iM2);
+					KMM-&gt;NumSpotsFound--;
+					iM--;
+					iM2--;
+				}
+			}
+		}
+		if( !CanBuilt )
+		{
+			*l&lt;&lt;&quot;\n  Metal Resource located at (x&quot;&lt;&lt;Location.x&lt;&lt;&quot; z&quot;&lt;&lt;Location.z&lt;&lt;&quot; y&quot;&lt;&lt;Location.y&lt;&lt;&quot;) is unusable in this mod (due to the lack of a required extractor).&quot;;
+			KMM-&gt;VectoredSpots.erase(KMM-&gt;VectoredSpots.begin()+iM);
+			KMM-&gt;NumSpotsFound--;
+		}
+	}
+
+	*l&lt;&lt;&quot;\n Metal Spots Found: &quot;&lt;&lt;KMM-&gt;NumSpotsFound;
+
+	*l&lt;&lt;&quot;\n Finding Geo Spots ...&quot;;
+	int *F = new int[10000];
+	float3 pos;
+	int FSize = cb-&gt;GetFeatures(F,10000,pos,99999); // Work Around - Spring Version: v0.75b2
+	for(int i=0; i&lt;FSize; i++)
+	{
+		const FeatureDef *fd = cb-&gt;GetFeatureDef(F[i]);
+		if( fd-&gt;geoThermal )
+		{
+			bool CanBuild=false;
+			float3 Location=cb-&gt;GetFeaturePos(F[i]);
+			for( int iud=0; iud&lt;udSize; iud++ )
+			{
+				const UnitDef* ud=uds[iud];
+				if( ud-&gt;needGeo )
+				{
+					float3 BuildLoc=cb-&gt;ClosestBuildSite(ud,Location,48.0f,0);
+					if( cb-&gt;CanBuildAt(ud,BuildLoc) )
+					{
+						CanBuild=true;
+						iud=cb-&gt;GetNumUnitDefs(); // End Loop
+					}
+				}
+			}
+
+			if( !CanBuild )
+				*l&lt;&lt;&quot;\n  Energy Resource located at (x&quot;&lt;&lt;Location.x&lt;&lt;&quot; z&quot;&lt;&lt;Location.z&lt;&lt;&quot; y&quot;&lt;&lt;Location.y&lt;&lt;&quot;) is unusable in this mod.&quot;;
+			else
+				GeoSpot.insert(F[i]);
+		}
+	}
+	delete [] uds;
+	delete [] F;
+	if( FSize == 10000 )
+	{
+		cb-&gt;SendTextMsg(&quot;ERROR: not all features were searched for Geo Build Options&quot;,5);
+		*l&lt;&lt;&quot;\nERROR: not all features were searched for Geo Build Options&quot;;
+	}
+
+	*l&lt;&lt;&quot;\n Geo Spots Found: &quot;&lt;&lt;int(GeoSpot.size());
+	*l&lt;&lt;&quot;\nLoading Complete.&quot;;
+}
+
+cRAIGlobal::~cRAIGlobal()
+{
+	*l&lt;&lt;&quot;\n\nShuting Down&quot;;
+	delete KMM;
+	delete TM;
+	*l&lt;&lt;&quot; ... Complete.&quot;;
+	delete l;
+}
+
+void cRAIGlobal::ClearLogFiles(IAICallback* cb)
+{
+	char s1[32] = &quot;AI/RAI/&quot;; cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, s1);
+	char s2[32] = &quot;AI/RAI/Metal/&quot;; cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, s2);
+
+	string sDir=&quot;AI/RAI/&quot;;
+	string sFile;
+
+	sFile=sDir+&quot;RAIGlobal_LastGame.log&quot;;
+	remove(sFile.c_str());
+	for( int i=0; i&lt;10; i++ )
+	{	
+		char c[2];
+		sprintf(c, &quot;%i&quot;,i);
+		sFile=sDir+&quot;RAI&quot;+string(c)+&quot;_LastGame.log&quot;;
+		remove(sFile.c_str());
+	}
+
+	for( int i=0; i&lt;10; i++ ) // RAI v0.30-v0.355 log files
+	{	
+		char c[2];
+		sprintf(c, &quot;%i&quot;,i);
+		string sFile=sDir+&quot;AI&quot;+string(c)+&quot;_LastGame.log&quot;;
+		remove(sFile.c_str());
+	}
+//	sFile=sDir+&quot;Prerequisite.log&quot;;
+//	remove(sFile.c_str());
+//	sFile=sDir+&quot;Debug.log&quot;;
+//	remove(sFile.c_str());
+}

Added: trunk/AI/Global/RAI-0.553/Global.h
===================================================================
--- trunk/AI/Global/RAI-0.553/Global.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/Global.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,35 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_GLOBAL_H
+#define RAI_GLOBAL_H
+
+class cRAIGlobal;
+
+#include &quot;Krogs Metal Class v0.4/MetalMap.h&quot;
+#include &quot;GTerrainMap.h&quot;
+//#include &quot;GMetalMap.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+#include &lt;set&gt;
+
+class cRAIGlobal
+{
+public:
+	cRAIGlobal(IAICallback* callback);
+	~cRAIGlobal();
+
+	cTerrainMap *TM;
+	CMetalMap* KMM;
+//	cRMetalMap* RMM;
+	set&lt;int&gt; GeoSpot;
+	int AIs;
+
+private:
+	void ClearLogFiles(IAICallback* callback);
+	cLogFile *l;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/GlobalAIs.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/GlobalAIs.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/GlobalAIs.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,30 @@
+#include &quot;RAI.h&quot;
+#include &quot;ExternalAI/aibase.h&quot;
+//#include &lt;set&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+
+std::set&lt;IGlobalAI*&gt; ais;
+
+DLL_EXPORT int GetGlobalAiVersion()
+{
+	return GLOBAL_AI_INTERFACE_VERSION;
+}
+
+DLL_EXPORT void GetAiName(char* name)
+{
+	strcpy(name,AI_NAME);
+}
+
+DLL_EXPORT IGlobalAI* GetNewAI()
+{
+	cRAI* ai=new cRAI;
+	ais.insert(ai);
+	return ai;
+}
+
+DLL_EXPORT void ReleaseAI(IGlobalAI* i)
+{
+	delete (cRAI*)i;
+	ais.erase(i);
+}

Added: trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/MetalMap.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/MetalMap.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/MetalMap.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,392 @@
+#include &quot;MetalMap.h&quot;
+#include &quot;time.h&quot;
+
+CMetalMap::CMetalMap(IAICallback* callback)
+{
+	this-&gt;callback=callback;
+	MinMetalForSpot = 30;	// from 0-255, the minimum percentage of metal a spot needs to have
+							//from the maximum to be saved. Prevents crappier spots in between taken spaces.
+							//They are still perfectly valid and will generate metal mind you!
+	MaxSpots = 15000; //If more spots than that are found the map is considered a metalmap, tweak this as needed
+	MetalMapHeight =callback-&gt;GetMapHeight() / 2; //metal map has 1/2 resolution of normal map
+	MetalMapWidth =callback-&gt;GetMapWidth() / 2;
+	TotalCells = MetalMapHeight * MetalMapWidth;
+	XtractorRadius = int(callback-&gt;GetExtractorRadius()/16.0);
+	DoubleRadius = XtractorRadius * 2;
+	SquareRadius = XtractorRadius * XtractorRadius; //used to speed up loops so no recalculation needed
+	DoubleSquareRadius = DoubleRadius * DoubleRadius; // same as above 
+	MexArrayA = new unsigned char [TotalCells];	
+	MexArrayB = new unsigned char [TotalCells];
+	MexArrayC = new unsigned char [TotalCells]; //used for drawing the TGA, not really needed with a couple of changes
+	TempAverage = new int [TotalCells];
+	TotalMetal = MaxMetal = NumSpotsFound = 0; //clear variables just in case!
+	Stopme = false;
+	//L(&quot;Metal class logging works!&quot;);
+}
+
+CMetalMap::~CMetalMap()
+{
+	delete [] MexArrayA;
+	delete [] MexArrayB;
+	delete [] MexArrayC;
+	delete [] TempAverage;
+}
+
+void CMetalMap::Init()
+{
+	callback-&gt;SendTextMsg(&quot;KAI Metal Class by Krogothe&quot;,0); // Leave this line if you want to use this class in your AI
+	if(!LoadMetalMap()) //if theres no available load file, create one and save it
+	{
+		GetMetalPoints();
+		SaveMetalMap();
+	}
+	char k[200];
+	sprintf(k,&quot;Metal Spots Found %i&quot;,NumSpotsFound);
+	callback-&gt;SendTextMsg(k,0);
+}
+
+void CMetalMap::GetMetalPoints()
+{		
+	// Time stuff:
+	int timetaken = clock();
+
+	int* xend = new int[DoubleRadius+1]; 
+	for (int a=0;a&lt;DoubleRadius+1;a++){ 
+		float z=a-XtractorRadius;
+		float floatsqrradius = SquareRadius;
+		xend[a]=int(sqrt(floatsqrradius-z*z));
+	}
+	//Load up the metal Values in each pixel
+	const unsigned char *metalMapArray = callback-&gt;GetMetalMap();
+	double TotalMetalDouble  = 0;
+	for (int i = 0; i &lt; TotalCells; i++){
+		TotalMetalDouble +=  MexArrayA[i] = metalMapArray[i];		// Count the total metal so you can work out an average of the whole map
+	}
+	AverageMetal = TotalMetalDouble / TotalCells;  //do the average
+	
+	// Quick test for no metal map:
+	if(TotalMetalDouble &lt; 0.9){
+		// The map dont have any metal, just stop.
+		NumSpotsFound = 0;
+		delete[] xend;
+		timetaken = time (NULL) - timetaken;
+		char c[200];
+		sprintf(c,&quot;Time taken to generate spots: %i seconds.&quot;,timetaken);
+		//L(&quot;Time taken to generate spots: &quot; &lt;&lt; timetaken &lt;&lt; &quot; seconds.&quot;);
+		return;
+	}
+	// Now work out how much metal each spot can make by adding up the metal from nearby spots
+	for (int y = 0; y &lt; MetalMapHeight; y++){
+		for (int x = 0; x &lt; MetalMapWidth; x++){
+			TotalMetal = 0;			
+			if(x == 0 &amp;&amp; y == 0) // First Spot needs full calculation
+			for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
+				if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+					for (int sx=x-xend[a];sx&lt;=x+xend[a];sx++){ 
+						if (sx &gt;= 0 &amp;&amp; sx &lt; MetalMapWidth){
+							TotalMetal += MexArrayA[sy * MetalMapWidth + sx]; //get the metal from all pixels around the extractor radius  
+						}
+					} 
+				}
+			}
+			// Quick calc test:		
+			if(x &gt; 0)
+			{
+				TotalMetal = TempAverage[y * MetalMapWidth + x -1];
+				for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
+					if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+						int addX = x+xend[a];
+						int remX = x-xend[a] -1;
+						if(addX &lt; MetalMapWidth)
+							TotalMetal += MexArrayA[sy * MetalMapWidth + addX];
+						if(remX &gt;= 0)
+							TotalMetal -= MexArrayA[sy * MetalMapWidth + remX];
+					}
+				}
+			} else if(y &gt; 0){
+				// x == 0 here
+				TotalMetal = TempAverage[(y-1) * MetalMapWidth];
+				// Remove the top half:
+				int a = XtractorRadius;
+				for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
+					if (sx &lt; MetalMapWidth){
+						int remY = y-xend[a] -1;
+						if(remY &gt;= 0)
+							TotalMetal -= MexArrayA[remY * MetalMapWidth + sx];
+					}
+				}
+				// Add the bottom half:
+				a = XtractorRadius;
+				for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
+					if (sx &lt; MetalMapWidth){
+						int addY = y+xend[a];
+						if(addY &lt; MetalMapHeight)
+							TotalMetal += MexArrayA[addY * MetalMapWidth + sx];
+					}
+				}
+
+				TotalMetal = TotalMetal; // Comment out for debug
+			}
+			TempAverage[y * MetalMapWidth + x] = TotalMetal; //set that spots metal making ability (divide by cells to values are small)
+			if (MaxMetal &lt; TotalMetal)
+				MaxMetal = TotalMetal;  //find the spot with the highest metal to set as the map's max
+		}
+	}
+	// Make a list for the distribution of values
+	int * valueDist = new int[256];
+	for (int i = 0; i &lt; 256; i++){ // Clear the array (useless?)
+		valueDist[i] = 0;
+	}
+
+	for (int i = 0; i &lt; TotalCells; i++){ // this will get the total metal a mex placed at each spot would make
+		MexArrayB[i] = TempAverage[i] * 255 / MaxMetal;  //scale the metal so any map will have values 0-255, no matter how much metal it has
+		MexArrayC[i] = 0; // clear out the array since its never been used.
+		int value = MexArrayB[i];
+		valueDist[value]++;
+	}
+	
+	// Find the current best value
+	int bestValue = 0;
+	int numberOfValues = 0;
+	int usedSpots = 0;
+	for (int i = 255; i &gt;= 0; i--){
+		if(valueDist[i] != 0){
+			bestValue = i;
+			numberOfValues = valueDist[i];
+			break;
+		}
+	}
+
+	// Make a list of the indexes of the best spots
+	if(numberOfValues &gt; 256) // Make shure that the list wont be too big
+		numberOfValues = 256;
+	int *bestSpotList = new int[numberOfValues];	
+	for (int i = 0; i &lt; TotalCells; i++){			
+		if (MexArrayB[i] == bestValue){
+			// Add the index of this spot to the list.
+			bestSpotList[usedSpots] = i;
+			usedSpots++;
+			if(usedSpots == numberOfValues){
+				// The list is filled, stop the loop.
+				usedSpots = 0;
+				break;
+			}
+		}
+	}
+
+	int printDebug1 = 100;
+	for (int a = 0; a &lt; MaxSpots; a++){	
+		if(!Stopme){
+			TempMetal = 0; //reset tempmetal so it can find new spots
+			// Take the first spot
+			int speedTempMetal_x;
+			int speedTempMetal_y;
+			int speedTempMetal = 0;
+			bool found = false;
+			while(!found){				
+				if(usedSpots == numberOfValues){
+					// The list is empty now, refill it:
+					// Make a list of all the best spots:
+					for (int i = 0; i &lt; 256; i++){ // Clear the array
+						valueDist[i] = 0;
+					}
+					// Find the metal distribution
+					for (int i = 0; i &lt; TotalCells; i++){
+						int value = MexArrayB[i];
+						valueDist[value]++;
+					}
+					// Find the current best value
+					bestValue = 0;
+					numberOfValues = 0;
+					usedSpots = 0;
+					for (int i = 255; i &gt;= 0; i--){
+						if(valueDist[i] != 0){
+							bestValue = i;
+							numberOfValues = valueDist[i];
+							break;
+						}
+					}
+					// Make a list of the indexes of the best spots
+					if(numberOfValues &gt; 256) // Make sure that the list wont be too big
+						numberOfValues = 256;
+					delete[] bestSpotList;
+					bestSpotList = new int[numberOfValues];
+					
+					for (int i = 0; i &lt; TotalCells; i++){			
+						if (MexArrayB[i] == bestValue){
+							// Add the index of this spot to the list.
+							bestSpotList[usedSpots] = i;
+							usedSpots++;
+							if(usedSpots == numberOfValues){
+								// The list is filled, stop the loop.
+								usedSpots = 0;
+								break;
+							}
+						}
+					}
+				}
+				// The list is not empty now.
+				int spotIndex = bestSpotList[usedSpots];
+				if(MexArrayB[spotIndex] == bestValue){
+					// The spot is still valid, so use it
+					speedTempMetal_x = spotIndex%MetalMapWidth;
+					speedTempMetal_y = spotIndex/MetalMapWidth;
+					speedTempMetal = bestValue;
+					found = true;
+				}
+				// Update the bestSpotList index
+				usedSpots++;
+			}			
+			coordx = speedTempMetal_x;
+			coordy = speedTempMetal_y;
+			TempMetal = speedTempMetal;
+		}
+		if (TempMetal &lt; MinMetalForSpot)
+			Stopme = 1; // if the spots get too crappy it will stop running the loops to speed it all up
+
+		if (!Stopme){
+
+			BufferSpot.x=coordx * 16 + 8; // format metal coords to game-coords
+			BufferSpot.z=coordy * 16 + 8;
+			BufferSpot.y=TempMetal *callback-&gt;GetMaxMetal() * MaxMetal / 255; //Gets the actual amount of metal an extractor can make
+			VectoredSpots.push_back(BufferSpot);
+			MexArrayC[coordy * MetalMapWidth + coordx] = TempMetal; //plot TGA array (not necessary) for debug
+			NumSpotsFound += 1;
+			
+			// Small speedup of &quot;wipes the metal around the spot so its not counted twice&quot;:
+			for (int sy=coordy-XtractorRadius,a=0;sy&lt;=coordy+XtractorRadius;sy++,a++){
+				if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+					int clearXStart = coordx-xend[a];
+					int clearXEnd = coordx+xend[a];
+					if(clearXStart &lt; 0)
+						clearXStart = 0;
+					if(clearXEnd &gt;= MetalMapWidth)
+						clearXEnd = MetalMapWidth -1;
+					for(int xClear = clearXStart; xClear &lt;= clearXEnd; xClear++){
+						MexArrayA[sy * MetalMapWidth + xClear] = 0; //wipes the metal around the spot so its not counted twice
+						MexArrayB[sy * MetalMapWidth + xClear] = 0;
+						TempAverage[sy * MetalMapWidth + xClear] = 0;						
+					}
+				}
+			}
+
+			// Redo the whole averaging process around the picked spot so other spots can be found around it
+			for (int y = coordy - DoubleRadius; y &lt;= coordy + DoubleRadius; y++)
+			{
+				if(y &gt;=0 &amp;&amp; y &lt; MetalMapHeight)
+				{
+					for (int x = coordx - DoubleRadius; x &lt;= coordx + DoubleRadius; x++)
+					{						
+						if(x &gt;=0 &amp;&amp; x &lt; MetalMapWidth)
+						{
+							TotalMetal = 0;
+							if(x == 0 &amp;&amp; y == 0) // Comment out for debug
+								for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
+									if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+										for (int sx=x-xend[a];sx&lt;=x+xend[a];sx++){ 
+											if (sx &gt;= 0 &amp;&amp; sx &lt; MetalMapWidth){
+												TotalMetal += MexArrayA[sy * MetalMapWidth + sx]; //get the metal from all pixels around the extractor radius  
+											}
+										} 
+									}
+								}
+
+							// Quick calc test:
+							if(x &gt; 0){
+								TotalMetal = TempAverage[y * MetalMapWidth + x -1];
+								for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
+									if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+										int addX = x+xend[a];
+										int remX = x-xend[a] -1;
+										if(addX &lt; MetalMapWidth)
+											TotalMetal += MexArrayA[sy * MetalMapWidth + addX];
+										if(remX &gt;= 0)
+											TotalMetal -= MexArrayA[sy * MetalMapWidth + remX];
+									}
+								}
+							} 
+							else if(y &gt; 0){
+								// x == 0 here
+								TotalMetal = TempAverage[(y-1) * MetalMapWidth];
+								// Remove the top half:
+								int a = XtractorRadius;
+								for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
+									if (sx &lt; MetalMapWidth){
+										int remY = y-xend[a] -1;
+										if(remY &gt;= 0)
+											TotalMetal -= MexArrayA[remY * MetalMapWidth + sx];
+									}
+								}
+								// Add the bottom half:
+								a = XtractorRadius;
+								for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
+									if (sx &lt; MetalMapWidth){
+										int addY = y+xend[a];
+										if(addY &lt; MetalMapHeight)
+											TotalMetal += MexArrayA[addY * MetalMapWidth + sx];
+									}
+								}
+							}
+							TempAverage[y * MetalMapWidth + x] = TotalMetal;
+							MexArrayB[y * MetalMapWidth + x] = TotalMetal * 255 / MaxMetal; //set that spots metal amount 
+							// end
+						}
+					}
+				}
+			}
+		}
+	}
+	// Kill the lists:
+	delete[] bestSpotList;
+	delete[] valueDist;
+	delete[] xend;
+	if (NumSpotsFound &gt; MaxSpots * 0.95){ // 0.95 used for for reliability, fucking with is bad juju
+		callback-&gt;SendTextMsg(&quot;Metal Map Found&quot;,0);
+		NumSpotsFound = 0; //no point in saving spots if the map is a metalmap
+	}
+	timetaken = clock() - timetaken;
+	char c[200];
+	sprintf(c,&quot;Time taken to generate spots: %ims.&quot;,timetaken);
+	//L(&quot;Time taken to generate spots: &quot; &lt;&lt; timetaken &lt;&lt; &quot;ms.&quot;);
+	//callback-&gt;SendTextMsg(c,0);
+	
+}
+
+void CMetalMap::SaveMetalMap()
+{
+	string filename = string(&quot;AI/RAI/Metal/&quot;) + string(callback-&gt;GetMapName());
+	filename.resize(filename.size()-3);
+	filename += string(&quot;Metal&quot;);
+	FILE *save_file = fopen(filename.c_str(), &quot;wb&quot;);
+	fwrite(&amp;NumSpotsFound, sizeof(int), 1, save_file);
+	//L(&quot;Spots found: &quot; &lt;&lt; NumSpotsFound &lt;&lt; &quot; AverageMetal: &quot; &lt;&lt; AverageMetal);
+	fwrite(&amp;AverageMetal, sizeof(float), 1, save_file);
+	for(int i = 0; i &lt; NumSpotsFound; i++){
+		////L(&quot;Loaded i: &quot; &lt;&lt; i &lt;&lt; &quot;, x; &quot; &lt;&lt; VectoredSpots[i].x &lt;&lt; &quot;, y; &quot; &lt;&lt; VectoredSpots[i].z &lt;&lt; &quot;, value: &quot; &lt;&lt; VectoredSpots[i].y );
+		fwrite(&amp;VectoredSpots[i], sizeof(float3), 1, save_file);
+	}
+	fclose(save_file);
+//	callback-&gt;SendTextMsg(&quot;Metal Spots created and saved!&quot;,0);
+}
+
+bool CMetalMap::LoadMetalMap()
+{
+	string filename = string(&quot;AI/RAI/Metal/&quot;) + string(callback-&gt;GetMapName());
+	filename.resize(filename.size()-3);
+	filename += string(&quot;Metal&quot;);
+	FILE *load_file;
+	// load Spots if file exists 
+	if(load_file = fopen(filename.c_str(), &quot;rb&quot;)){
+		fread(&amp;NumSpotsFound, sizeof(int), 1, load_file);
+		VectoredSpots.resize(NumSpotsFound);
+		fread(&amp;AverageMetal, sizeof(float), 1, load_file);
+		for(int i = 0; i &lt; NumSpotsFound; i++){
+			fread(&amp;VectoredSpots[i], sizeof(float3), 1, load_file);
+			////L(&quot;Loaded i: &quot; &lt;&lt; i &lt;&lt; &quot;, x; &quot; &lt;&lt; VectoredSpots[i].x &lt;&lt; &quot;, y; &quot; &lt;&lt; VectoredSpots[i].z &lt;&lt; &quot;, value: &quot; &lt;&lt; VectoredSpots[i].y );
+		}
+		fclose(load_file);
+//		callback-&gt;SendTextMsg(&quot;Metal Spots loaded from file&quot;,0);
+		return true;
+	}
+		return false;
+}

Added: trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/MetalMap.h
===================================================================
--- trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/MetalMap.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/Krogs Metal Class v0.4/MetalMap.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,47 @@
+#ifndef METALMAP_H
+#define METALMAP_H
+
+#pragma once
+#include &quot;ExternalAI/IAICallback.h&quot;
+
+class CMetalMap
+{
+public:
+
+	CMetalMap(IAICallback* callback);
+	virtual ~CMetalMap();
+	void Init();
+	int NumSpotsFound;
+	float AverageMetal;
+	vector&lt;float3&gt; VectoredSpots;
+
+private:
+	void GetMetalPoints();
+	void SaveMetalMap();
+	bool LoadMetalMap();
+
+	float3 BufferSpot;
+	bool Stopme;
+	int MaxSpots;
+	int MetalMapHeight;
+	int MetalMapWidth;
+	int TotalCells;
+	int SquareRadius;
+	int DoubleSquareRadius;
+	int TotalMetal;
+	int MaxMetal;
+	int TempMetal;
+	int coordx;
+	int coordy;
+	int Minradius;
+	int MinMetalForSpot;
+	int XtractorRadius;
+	int DoubleRadius;
+	unsigned char* MexArrayA;	
+	unsigned char* MexArrayB;
+	unsigned char* MexArrayC; 
+	int* TempAverage;
+	IAICallback* callback;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/LogFile.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/LogFile.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/LogFile.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,78 @@
+#include &quot;LogFile.h&quot;
+
+//#include &lt;fstream&gt;
+//#include &lt;stdlib.h&gt;
+//#include &lt;iostream&gt;
+#include &lt;stdio.h&gt;
+
+using namespace std;
+
+cLogFile::cLogFile(string sFilename, bool bAppend)
+{
+	logFileName=&quot;AI/RAI/&quot;+sFilename;
+	if( !bAppend )
+	{
+		FILE * pFile;
+		pFile = fopen(logFileName.c_str(),&quot;wt&quot;);
+		fclose(pFile);
+//		ofstream oLog( logFileName.c_str() );
+//		oLog.close();
+	}
+
+	logFile = fopen(logFileName.c_str(),&quot;at&quot;);
+//	logFile = new ofstream();
+//	logFile-&gt;open( logFileName.c_str(), ios::app );
+}
+
+cLogFile::~cLogFile()
+{
+	fclose(logFile);
+//	logFile-&gt;close();
+//	delete logFile;
+}
+
+cLogFile&amp; cLogFile::operator&lt;&lt;(float message)
+{
+	if( message - int(message) &gt; 0.0 )
+		fprintf(logFile, &quot;%1.2f&quot;, message);
+	else
+		fprintf(logFile, &quot;%1.0f&quot;, message);
+	return *this;
+}
+/*
+cLogFile&amp; cLogFile::operator&lt;&lt;(const char* message)
+{
+	fprintf(logFile, &quot;%s&quot;, message);
+	return *this;
+}
+*/
+cLogFile&amp; cLogFile::operator&lt;&lt;(string message)
+{
+	fprintf(logFile, &quot;%s&quot;, message.c_str());
+	return *this;
+}
+
+void cLogFile::Write(string message)
+{
+	fprintf(logFile, &quot;%s&quot;, message.c_str());
+//  fputs(message.c_str(),logFile);
+//  *logFile&lt;&lt;message.c_str();
+//	logFile-&gt;flush();
+}
+
+void cLogFile::Write(float message)
+{
+	if( message - int(message) &gt; 0.0 )
+		fprintf(logFile, &quot;%1.2f&quot;, message);
+	else
+		fprintf(logFile, &quot;%1.0f&quot;, message);
+//	*logFile&lt;&lt;message;
+//	logFile-&gt;flush();
+}
+/*
+void cLogFile::Write(int message)
+{
+	*logFile&lt;&lt;message;
+	logFile-&gt;flush();
+}
+*/

Added: trunk/AI/Global/RAI-0.553/LogFile.h
===================================================================
--- trunk/AI/Global/RAI-0.553/LogFile.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/LogFile.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,31 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_LOGFILE_H
+#define RAI_LOGFILE_H
+
+#include &quot;ExternalAI/IAICallback.h&quot;
+
+class cLogFile
+{
+public:
+	cLogFile(string sFilename, bool bAppend=true);
+	~cLogFile();
+
+	cLogFile&amp; operator&lt;&lt;(float message);
+//	cLogFile&amp; operator&lt;&lt;(const char* message);
+	cLogFile&amp; operator&lt;&lt;(string message);
+
+	void Write(string message);
+	void Write(float message);
+//	void Write(int message);
+private:
+	string logFileName;
+//	ofstream *logFile;
+	FILE *logFile;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/PowerManager.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/PowerManager.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/PowerManager.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,270 @@
+#include &quot;PowerManager.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;LogFile.h&quot;
+
+cPowerManager::cPowerManager(IAICallback* callback, cRAI* global)
+{
+	G=global;
+	l=G-&gt;l;
+	cb=callback;
+
+	NeededCloakPower=0;
+	NeededOnOffPower=0;
+	NeededWeaponPower=0;
+	MetalProductionEtoM=0;
+	MetalProduction=0;
+}
+
+cPowerManager::~cPowerManager()
+{
+	*l&lt;&lt;&quot;\n cPowerManager Debug:&quot;;
+	*l&lt;&lt;&quot;\n  Needed Cloak Power     = &quot;&lt;&lt;NeededCloakPower;
+	*l&lt;&lt;&quot;\n  Needed On/Off Power    = &quot;&lt;&lt;NeededOnOffPower;
+	*l&lt;&lt;&quot;\n  Needed Weapon Power    = &quot;&lt;&lt;NeededWeaponPower;
+	*l&lt;&lt;&quot;\n  Extra Metal EtoM       = &quot;&lt;&lt;MetalProductionEtoM;
+	*l&lt;&lt;&quot;\n  Extra Metal Production = &quot;&lt;&lt;MetalProduction;
+//	if( NeededCloakPower != 0.0 || NeededOnOffPower != 0.0 || NeededWeaponPower != 0.0 || MetalProductionEtoM != 0.0 || MetalProduction != 0.0 )
+//		*l&lt;&lt;&quot;\n  ERROR!&quot;;
+}
+
+void cPowerManager::UnitFinished(int unit, UnitInfo *U)
+{
+	NeededWeaponPower+=U-&gt;udr-&gt;WeaponCostMax;
+
+	if( U-&gt;ud-&gt;canCloak )
+	{
+		mCloakUnits.insert(cRAI::iupPair(unit,U));
+		U-&gt;CloakUI = new sPowerUnitInfo(cb-&gt;IsUnitCloaked(unit));
+		if( !U-&gt;CloakUI-&gt;active )
+			NeededCloakPower+=int(U-&gt;udr-&gt;CloakCostMax);
+	}
+	if( U-&gt;ud-&gt;onoffable )
+	{
+		map&lt;int,UnitInfo*&gt; *pmPI = 0;
+		if( U-&gt;udr-&gt;EnergyDifference &lt; 0 &amp;&amp; U-&gt;udr-&gt;MetalDifference &gt; 0 &amp;&amp; G-&gt;UDH-&gt;EnergyToMetalRatio*U-&gt;udr-&gt;MetalDifference &lt; -U-&gt;udr-&gt;EnergyDifference )
+		{
+			pmPI = &mEtoMConverter;
+			if( !cb-&gt;IsUnitActivated(unit) )
+			{
+				MetalProductionEtoM+=U-&gt;udr-&gt;MetalDifference;
+				NeededOnOffPower+=U-&gt;ud-&gt;energyUpkeep;
+			}
+		}
+		else if( U-&gt;ud-&gt;energyUpkeep &lt;= 0 &amp;&amp; U-&gt;udr-&gt;EnergyDifference &gt; 0 &amp;&amp; U-&gt;udr-&gt;MetalDifference &lt; 0 &amp;&amp; U-&gt;udr-&gt;EnergyDifference &lt; G-&gt;UDH-&gt;EnergyToMetalRatio*-U-&gt;udr-&gt;MetalDifference )
+		{
+			pmPI = &mMtoEConverter;
+		}
+		else if( U-&gt;ud-&gt;energyUpkeep &gt; 0 )
+		{
+			pmPI = &mOnOffUnits;
+			if( !cb-&gt;IsUnitActivated(unit) )
+			{
+				MetalProduction+=U-&gt;udr-&gt;MetalDifference;
+				NeededOnOffPower+=U-&gt;ud-&gt;energyUpkeep;
+			}
+		}
+		else if( U-&gt;ud-&gt;activateWhenBuilt &amp;&amp; !cb-&gt;IsUnitActivated(unit) ) // solar panals are turned off when given, RAI does not manage there power
+		{
+			Command c;
+			c.id=CMD_ONOFF;
+			c.params.push_back(1);
+			cb-&gt;GiveOrder(unit, &amp;c);
+		}
+		
+		if( pmPI != 0 )
+		{
+			pmPI-&gt;insert(cRAI::iupPair(unit,U));
+			U-&gt;PowerUI = new sPowerUnitInfo(cb-&gt;IsUnitActivated(unit));
+		}
+	}
+}
+
+void cPowerManager::UnitDestroyed(int unit, UnitInfo *U)
+{
+	NeededWeaponPower-=U-&gt;udr-&gt;WeaponCostMax;
+
+	if( mCloakUnits.find(unit) != mCloakUnits.end() )
+	{
+		if( !U-&gt;CloakUI-&gt;active )
+			NeededCloakPower-=int(U-&gt;udr-&gt;CloakCostMax);
+		mCloakUnits.erase(unit);
+		delete U-&gt;CloakUI;
+	}
+
+	if( U-&gt;ud-&gt;onoffable )
+	{
+		map&lt;int,UnitInfo*&gt; *pmPI = 0;
+		if( mEtoMConverter.find(unit) != mEtoMConverter.end() )
+		{
+			pmPI = &mEtoMConverter;
+			if( !U-&gt;PowerUI-&gt;active )
+			{
+				MetalProductionEtoM-=U-&gt;udr-&gt;MetalDifference;
+				NeededOnOffPower-=U-&gt;ud-&gt;energyUpkeep;
+			}
+		}
+		else if( mMtoEConverter.find(unit) != mMtoEConverter.end() )
+		{
+			pmPI = &mMtoEConverter;
+		}
+		else if( mOnOffUnits.find(unit) != mOnOffUnits.end() )
+		{
+			pmPI = &mOnOffUnits;
+			if( !U-&gt;PowerUI-&gt;active )
+			{
+				MetalProduction-=U-&gt;udr-&gt;MetalDifference;
+				NeededOnOffPower-=U-&gt;ud-&gt;energyUpkeep;
+			}
+		}
+
+		if( pmPI != 0 )
+		{
+			pmPI-&gt;erase(unit);
+			delete U-&gt;PowerUI;
+		}
+	}
+}
+
+void cPowerManager::Update()
+{
+	float fMetal=cb-&gt;GetMetalIncome()-cb-&gt;GetMetalUsage();
+	float fPower=cb-&gt;GetEnergyIncome()-cb-&gt;GetEnergyUsage();
+
+	for( map&lt;int,UnitInfo*&gt;::iterator iU = mCloakUnits.begin(); iU!=mCloakUnits.end(); iU++ )
+	{
+		float fDrain=iU-&gt;second-&gt;udr-&gt;CloakCostMax;
+		if( fDrain &gt; fPower )
+		{
+			if( iU-&gt;second-&gt;CloakUI-&gt;active &amp;&amp; !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{	// Turn OFF
+				NeededCloakPower+=fDrain;
+				fPower+=fDrain;
+				iU-&gt;second-&gt;CloakUI-&gt;active = false;
+
+				Command c;
+				c.id=CMD_CLOAK;
+				c.params.push_back(0);
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+		else if( fDrain*4 &lt; fPower )
+		{
+			if( !iU-&gt;second-&gt;CloakUI-&gt;active &amp;&amp; !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{	// Turn ON
+				NeededCloakPower-=fDrain;
+				fPower-=fDrain;
+				iU-&gt;second-&gt;CloakUI-&gt;active = true;
+
+				Command c;
+				c.id=CMD_CLOAK;
+				c.params.push_back(1);
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+	}
+
+	for( map&lt;int,UnitInfo*&gt;::iterator iU = mEtoMConverter.begin(); iU!=mEtoMConverter.end(); iU++ )
+	{
+		//float fDrain=-iU-&gt;second-&gt;udr-&gt;EnergyDifference; // positive value ( if you include the - )
+		float fDrain=iU-&gt;second-&gt;udr-&gt;ud-&gt;energyUpkeep; // positive value
+
+		if( cb-&gt;GetMetal() &gt; 0.85*cb-&gt;GetMetalStorage() || cb-&gt;GetEnergy()+(FUPDATE_POWER/30.0)*(fPower-fDrain) &lt; 0.75*cb-&gt;GetEnergyStorage() )
+		{
+			if( iU-&gt;second-&gt;PowerUI-&gt;active &amp;&amp; !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{	// Turn OFF
+				MetalProductionEtoM+=iU-&gt;second-&gt;udr-&gt;MetalDifference;
+				NeededOnOffPower+=fDrain;
+				fPower+=fDrain;
+				iU-&gt;second-&gt;PowerUI-&gt;active = false;
+
+				Command c;
+				c.id=CMD_ONOFF;
+				c.params.push_back(0);
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+		else if( cb-&gt;GetEnergy()+2.0*(FUPDATE_POWER/30.0)*(fPower-fDrain) &gt; 0.75*cb-&gt;GetEnergyStorage() )
+		{
+			if( !iU-&gt;second-&gt;PowerUI-&gt;active &amp;&amp; !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{	// Turn ON
+				MetalProductionEtoM-=iU-&gt;second-&gt;udr-&gt;MetalDifference;
+				NeededOnOffPower-=fDrain;
+				fPower-=fDrain;
+				iU-&gt;second-&gt;PowerUI-&gt;active = true;
+
+				Command c;
+				c.id=CMD_ONOFF;
+				c.params.push_back(1);
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+	}
+
+	for( map&lt;int,UnitInfo*&gt;::iterator iU = mMtoEConverter.begin(); iU!=mMtoEConverter.end(); iU++ )
+	{
+		float fDrain=-iU-&gt;second-&gt;udr-&gt;MetalDifference; // positive value ( if you include the - )
+
+		if( cb-&gt;GetEnergy() &gt; 0.85*cb-&gt;GetEnergyStorage() || cb-&gt;GetMetal()+(FUPDATE_POWER/30.0)*(fMetal-fDrain) &lt; 0.85*cb-&gt;GetMetalStorage() )
+		{
+			if( iU-&gt;second-&gt;PowerUI-&gt;active &amp;&amp; !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{	// Turn OFF
+				fMetal+=fDrain;
+				iU-&gt;second-&gt;PowerUI-&gt;active = false;
+
+				Command c;
+				c.id=CMD_ONOFF;
+				c.params.push_back(0);
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+		else if( cb-&gt;GetMetal()+2.0*(FUPDATE_POWER/30.0)*(fMetal-fDrain) &gt; 0.85*cb-&gt;GetMetalStorage() )
+		{
+			if( !iU-&gt;second-&gt;PowerUI-&gt;active &amp;&amp; !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{	// Turn ON
+				fMetal-=fDrain;
+				iU-&gt;second-&gt;PowerUI-&gt;active = true;
+
+				Command c;
+				c.id=CMD_ONOFF;
+				c.params.push_back(1);
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+	}
+
+	for( map&lt;int,UnitInfo*&gt;::iterator iU = mOnOffUnits.begin(); iU!=mOnOffUnits.end(); iU++ )
+	{
+		float fDrain=iU-&gt;second-&gt;udr-&gt;ud-&gt;energyUpkeep; // positive value
+		if( cb-&gt;GetEnergy()+(FUPDATE_POWER/30.0)*(fPower-fDrain) &lt; 0 )
+		{
+			if( iU-&gt;second-&gt;PowerUI-&gt;active &amp;&amp; !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{	// Turn OFF
+				MetalProduction+=iU-&gt;second-&gt;udr-&gt;MetalDifference;
+				NeededOnOffPower+=fDrain;
+				fPower+=fDrain;
+				iU-&gt;second-&gt;PowerUI-&gt;active = false;
+
+				Command c;
+				c.id=CMD_ONOFF;
+				c.params.push_back(0);
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+		else if( cb-&gt;GetEnergy()+2.0*(FUPDATE_POWER/30.0)*(fPower-fDrain) &gt; 0 )
+		{
+			if( !iU-&gt;second-&gt;PowerUI-&gt;active &amp;&amp; !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{	// Turn ON
+				MetalProduction-=iU-&gt;second-&gt;udr-&gt;MetalDifference;
+				NeededOnOffPower-=fDrain;
+				fPower-=fDrain;
+				iU-&gt;second-&gt;PowerUI-&gt;active = true;
+
+				Command c;
+				c.id=CMD_ONOFF;
+				c.params.push_back(1);
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+	}
+}

Added: trunk/AI/Global/RAI-0.553/PowerManager.h
===================================================================
--- trunk/AI/Global/RAI-0.553/PowerManager.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/PowerManager.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,54 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_POWERMANAGER_H
+#define RAI_POWERMANAGER_H
+
+struct sPowerUnitInfo;
+class cPowerManager;
+
+//#include &quot;LogFile.h&quot;
+#include &quot;RAI.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &lt;map&gt;
+
+struct sPowerUnitInfo
+{
+	sPowerUnitInfo(bool on)
+	{
+		active = on;
+	}
+	bool active;
+};
+
+class cPowerManager
+{
+public:
+	cPowerManager(IAICallback *callback, cRAI* global);
+	~cPowerManager();
+
+	void UnitFinished(int unit, UnitInfo *U);	// called by all units
+	void UnitDestroyed(int unit, UnitInfo *U);	// called by all units
+	void Update();
+
+	// these variables are used to aid the build class in it's decisions
+	int NeededCloakPower;		// Amount of energy need to turn on all Cloak Units, does not include units already on
+	int NeededOnOffPower;		// Amount of energy need to turn on all EtoMconverter &amp; OnOff Units, does not include units already on
+	int NeededWeaponPower;		// Amount of energy drain from all unit weapons passed through this class, per 30 frames
+	int MetalProductionEtoM;	// Amount of metal that would be produced if all metal makers where on, does not include units already on
+	int MetalProduction;		// Amount of metal production lost from extractors or other effective metal productions
+
+private:
+	cLogFile *l;
+	IAICallback *cb;
+	cRAI *G;
+	map&lt;int,UnitInfo*&gt; mCloakUnits;		// key = unit id
+	map&lt;int,UnitInfo*&gt; mMtoEConverter;	// key = unit id, Metal to Energy
+	map&lt;int,UnitInfo*&gt; mEtoMConverter;	// key = unit id, Energy to Metal
+	map&lt;int,UnitInfo*&gt; mOnOffUnits;		// key = unit id, units that should rarely be turned off
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/RAI.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/RAI.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/RAI.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,891 @@
+#include &quot;RAI.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+//#include &quot;ExternalAI/IAICheats.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+//#include &quot;LogFile.h&quot;
+//#include &lt;vector&gt;
+//#include &lt;iostream&gt;
+
+namespace std
+{
+	void _xlen(){};
+}
+
+UnitInfo::UnitInfo(sRAIUnitDef *runitdef)
+{
+	udr=runitdef;
+	ud=runitdef-&gt;ud;
+
+	AIDisabled=false;
+	HumanOrder=false;
+	UnitFinished=false;
+	bInCombat=false;
+	lastUnitIdleFrame=0;
+	lastUnitDamagedFrame=0;
+	commandTimeOut=-1;
+	enemyID=-1;
+	E=0;
+	enemyEff=0;
+	pBOL=0;
+	RS=0;
+	BuildQ=0;
+	CloakUI=0;
+	PowerUI=0;
+	SWeaponUI=0;
+	Group=0;
+}
+
+EnemyInfo::EnemyInfo()
+{
+	inLOS=false;
+	inRadar=false;
+	baseThreatFrame=-1;
+	baseThreatID=-1;
+	ud=0;
+	udr=0;
+	RS=0;
+	posLocked=false;
+}
+
+cRAI::cRAI()
+{
+	DebugEnemyEnterLOS=0;
+	DebugEnemyLeaveLOS=0;
+	DebugEnemyEnterRadar=0;
+	DebugEnemyLeaveRadar=0;
+	DebugEnemyDestroyedLOS=0;
+	DebugEnemyDestroyedRadar=0;
+	DebugEnemyEnterLOSError=0;
+	DebugEnemyLeaveLOSError=0;
+	DebugEnemyEnterRadarError=0;
+	DebugEnemyLeaveRadarError=0;
+}
+
+cRAI::~cRAI()
+{
+	*l&lt;&lt;&quot;\n\nSHUTING DOWN ...&quot;;
+	*l&lt;&lt;&quot;\n cRAI Debug:&quot;;
+
+	*l&lt;&lt;&quot;\n  clearing Units size=&quot;&lt;&lt;int(Units.size())&lt;&lt;&quot;: &quot;;
+	while( int(Units.size()) &gt; 0 )
+		UnitDestroyed(Units.begin()-&gt;first,-1);
+
+	*l&lt;&lt;&quot;\n  clearing Enemies size=&quot;&lt;&lt;Enemies.size()&lt;&lt;&quot;: &quot;;
+	while( int(Enemies.size()) &gt; 0 )
+		EnemyDestroyed(Enemies.begin()-&gt;first,-1);
+
+	int ERadar,ELOS;
+	*l&lt;&lt;&quot;\n Enemys (Enter LOS - Errors)                        = &quot;&lt;&lt;DebugEnemyEnterLOS&lt;&lt;&quot; = &quot;&lt;&lt;DebugEnemyEnterLOS+DebugEnemyEnterLOSError&lt;&lt;&quot;-&quot;&lt;&lt;DebugEnemyEnterLOSError;
+	*l&lt;&lt;&quot;\n Enemys (Leave LOS + Destroyed in LOS - Errors)     = &quot;&lt;&lt;DebugEnemyLeaveLOS+DebugEnemyDestroyedLOS&lt;&lt;&quot; = &quot;&lt;&lt;DebugEnemyLeaveLOS+DebugEnemyLeaveLOSError&lt;&lt;&quot;+&quot;&lt;&lt;DebugEnemyDestroyedLOS&lt;&lt;&quot;-&quot;&lt;&lt;DebugEnemyLeaveLOSError;
+	*l&lt;&lt;&quot;\n Enemies Remaining in LOS                           = &quot;&lt;&lt;(ELOS=DebugEnemyEnterLOS-DebugEnemyLeaveLOS-DebugEnemyDestroyedLOS);
+	*l&lt;&lt;&quot;\n Enemys (Enter Radar - Errors)                      = &quot;&lt;&lt;DebugEnemyEnterRadar&lt;&lt;&quot; = &quot;&lt;&lt;DebugEnemyEnterRadar+DebugEnemyEnterRadarError&lt;&lt;&quot;-&quot;&lt;&lt;DebugEnemyEnterRadarError;
+	*l&lt;&lt;&quot;\n Enemys (Leave Radar + Destroyed in Radar - Errors) = &quot;&lt;&lt;DebugEnemyLeaveRadar+DebugEnemyDestroyedRadar&lt;&lt;&quot; = &quot;&lt;&lt;DebugEnemyLeaveRadar+DebugEnemyLeaveRadarError&lt;&lt;&quot;+&quot;&lt;&lt;DebugEnemyDestroyedRadar&lt;&lt;&quot;-&quot;&lt;&lt;DebugEnemyLeaveRadarError;
+	*l&lt;&lt;&quot;\n Enemies Remaining in Radar                         = &quot;&lt;&lt;(ERadar=DebugEnemyEnterRadar-DebugEnemyLeaveRadar-DebugEnemyDestroyedRadar);
+	*l&lt;&lt;&quot;\n Enemies Remaining                                  = &quot;&lt;&lt;int(Enemies.size());
+	*l&lt;&lt;&quot;\n Units Remaining                                    = &quot;&lt;&lt;UnitM-&gt;GroupSize;
+	*l&lt;&lt;&quot;\n Groups Remaining                                   = &quot;&lt;&lt;UnitM-&gt;GroupSize;
+	if( UnitM-&gt;GroupSize != 0 || ELOS != 0 || ERadar != 0 )
+		*l&lt;&lt;&quot;\n ERROR!&quot;;
+
+	delete UnitM;
+	delete Build;
+	delete SWM;
+	delete CombatM;
+
+	RG-&gt;AIs--;
+	if( RG-&gt;AIs == 0 )
+	{
+	*l&lt;&lt;&quot;\n deleting RAIGlobal ...&quot;;
+		delete RAIGlobal;
+		RAIGlobal=0;
+	}
+
+	*l&lt;&lt;&quot;\n deleting UDH ...&quot;;
+	delete UDH;
+
+	*l&lt;&lt;&quot;\nSHUTDOWN Complete.&quot;;
+
+	delete l;
+}
+
+void cRAI::InitAI(IGlobalAICallback* callback, int team)
+{
+	cb=callback-&gt;GetAICallback();
+
+	if( RAIGlobal == 0 )
+		RAIGlobal = new cRAIGlobal(cb);
+
+	char c[2];
+	sprintf(c, &quot;%i&quot;, cb-&gt;GetMyTeam());
+	l=new cLogFile(&quot;RAI&quot;+string(c)+&quot;_LastGame.log&quot;,false);
+
+	*l&lt;&lt;&quot;Loading ...&quot;;
+	*l&lt;&lt;&quot;\n Team = &quot;&lt;&lt;cb-&gt;GetMyTeam();
+	*l&lt;&lt;&quot;\n Ally Team = &quot;&lt;&lt;cb-&gt;GetMyAllyTeam();
+	if( RAIGlobal == 0 )
+	{
+		*l&lt;&lt;&quot;\nLoading RAIGlobal ...&quot;;
+		RAIGlobal = new cRAIGlobal(cb);
+	}
+	RG = RAIGlobal;
+	TM = RG-&gt;TM;
+	RG-&gt;AIs++;
+
+	*l&lt;&lt;&quot;\nLoading cRAIUnitDefHandler ...&quot;;
+	UDH = new cRAIUnitDefHandler(cb,RG,l);
+
+	UnitM = new cUnitManager(cb,this);
+	Build = new cBuilder(cb,this);
+	SWM = new cSWeaponManager(cb,this);
+	CombatM = new cCombatManager(cb,this);
+	*l&lt;&lt;&quot;\nLoading Complete.&quot;;
+/*
+	if( cb-&gt;GetUnitDef(&quot;arm_retaliator&quot;) != 0 ) // XTA Cheat Nuke Test
+	{
+		IAICheats *cheat=callback-&gt;GetCheatInterface();
+		float3 pos = *cb-&gt;GetStartPos();
+		float3 pos2 = *cb-&gt;GetStartPos();
+		float3 pos3 = *cb-&gt;GetStartPos();
+		if( pos.x &lt; 8*cb-&gt;GetMapWidth() - pos.x )
+		{
+			pos.x = 1;
+			pos2.x = 200;
+			pos3.x = 1;
+		}
+		else
+		{
+			pos.x = 8*cb-&gt;GetMapWidth();
+			pos2.x = pos.x - 200;
+			pos3.x = pos.x;
+		}
+		if( pos.z &lt; 8*cb-&gt;GetMapHeight() - pos.z )
+		{
+			pos.z = 1;
+			pos2.z = 1;
+			pos3.z = 200;
+		}
+		else
+		{
+			pos.z = 8*cb-&gt;GetMapHeight();
+			pos2.z = pos.z;
+			pos3.z = pos.z - 200;
+		}
+		pos = cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_retaliator&quot;),pos,1500,0);
+		cheat-&gt;CreateUnit(&quot;arm_retaliator&quot;,pos);
+
+		cheat-&gt;CreateUnit(&quot;arm_moho_metal_maker&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_moho_metal_maker&quot;),pos,1500,3));
+		cheat-&gt;CreateUnit(&quot;arm_fusion_reactor&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_fusion_reactor&quot;),pos,1500,3));
+		cheat-&gt;CreateUnit(&quot;arm_energy_storage&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_energy_storage&quot;),pos,1500,3));
+		cheat-&gt;CreateUnit(&quot;arm_annihilator&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_annihilator&quot;),pos,1500,10));
+		cheat-&gt;CreateUnit(&quot;arm_annihilator&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_annihilator&quot;),pos,1500,10));
+		cheat-&gt;CreateUnit(&quot;arm_annihilator&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_annihilator&quot;),pos,1500,10));
+	}
+*/
+}
+
+void cRAI::UnitCreated(int unit)
+{
+	const UnitDef* ud=cb-&gt;GetUnitDef(unit);
+//	*l&lt;&lt;&quot;\nUnitCreated(&quot;; *l&lt;&lt;unit&lt;&lt;&quot;)[&quot;+ud-&gt;humanName+&quot;]&quot;;
+	Units.insert(iuPair(unit,UnitInfo(&amp;UDH-&gt;UDR.find(ud-&gt;id)-&gt;second)));
+	UnitInfo* U = &amp;Units.find(unit)-&gt;second;
+	U-&gt;mapBody = GetCurrentMapBody(ud,cb-&gt;GetUnitPos(unit));
+
+	if( ud-&gt;speed == 0 )
+	{
+		for(map&lt;int,UnitInfo*&gt;::iterator i=UImmobile.begin(); i!=UImmobile.end(); i++ )
+		{
+			if( U-&gt;udr-&gt;WeaponGuardRange &gt; 0 &amp;&amp; i-&gt;second-&gt;udr-&gt;WeaponGuardRange == 0 &amp;&amp; cb-&gt;GetUnitPos(unit).distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; U-&gt;udr-&gt;WeaponGuardRange )
+			{
+				U-&gt;UDefending.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+				i-&gt;second-&gt;UDefences.insert(cRAI::iupPair(unit,U));
+			}
+			else if( U-&gt;udr-&gt;WeaponGuardRange == 0 &amp;&amp; i-&gt;second-&gt;udr-&gt;WeaponGuardRange &gt; 0 &amp;&amp; cb-&gt;GetUnitPos(unit).distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; i-&gt;second-&gt;udr-&gt;WeaponGuardRange )
+			{
+				U-&gt;UDefences.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+				i-&gt;second-&gt;UDefending.insert(cRAI::iupPair(unit,U));
+			}
+		}
+		UImmobile.insert(iupPair(unit,U));
+		if( U-&gt;ud-&gt;minWaterDepth &gt;= 0 )
+			UImmobileWater.insert(unit);
+	}
+	else
+		UMobile.insert(iupPair(unit,U));
+
+	Build-&gt;UnitCreated(unit,U);
+	Build-&gt;BP-&gt;UResourceCreated(unit,U);
+//	*l&lt;&lt;&quot; UC(end)&quot;;
+}
+
+void cRAI::UnitFinished(int unit)
+{
+//	*l&lt;&lt;&quot;\nUnitFinished(&quot;&lt;&lt;unit&lt;&lt;&quot;)&quot;;
+	if( Units.find(unit) == Units.end() ) // Occurs if a player canceled a build order with more than one quaried and something still finished
+	{
+		UnitCreated(unit);
+	}
+
+	UnitInfo *U = &amp;Units.find(unit)-&gt;second;
+	U-&gt;UnitFinished = true;
+	if( U-&gt;AIDisabled )
+	{
+//		*l&lt;&lt;&quot; UF(end)&quot;;
+		return;
+	}
+
+	Build-&gt;UnitFinished(unit,U);
+	if( U-&gt;AIDisabled )
+	{
+//		*l&lt;&lt;&quot; UF(end)&quot;;
+		return;
+	}
+
+	Build-&gt;PM-&gt;UnitFinished(unit,U);
+	SWM-&gt;UnitFinished(unit,U-&gt;udr);
+	UnitM-&gt;UnitFinished(unit,U);
+
+	if( U-&gt;ud-&gt;highTrajectoryType == 2 &amp;&amp; rand()%4 == 0 )
+	{
+		Command c;
+		c.id = CMD_TRAJECTORY;
+		c.params.push_back(1);
+		cb-&gt;GiveOrder(unit,&amp;c);
+	}
+//	*l&lt;&lt;&quot; UF(end)&quot;;
+}
+
+void cRAI::UnitDestroyed(int unit,int attacker)
+{
+//	*l&lt;&lt;&quot;\nUnitDestroyed(&quot;&lt;&lt;unit&lt;&lt;&quot;,&quot;&lt;&lt;attacker&lt;&lt;&quot;)&quot;;
+	if( Units.find(unit) == Units.end() ) // Occurs if a player canceled a build order with more than one quaried and something was still being worked on
+	{
+//		*l&lt;&lt;&quot;(PC)UDe(end)&quot;;
+		return;
+	}
+	UnitInfo *U = &amp;Units.find(unit)-&gt;second;
+
+	if( !U-&gt;AIDisabled )
+	{
+		Build-&gt;UnitDestroyed(unit,U);
+		if( U-&gt;UnitFinished )
+		{
+			Build-&gt;PM-&gt;UnitDestroyed(unit,U);
+			SWM-&gt;UnitDestroyed(unit);
+			UnitM-&gt;UnitDestroyed(unit,U);
+		}
+	}
+	Build-&gt;BP-&gt;UResourceDestroyed(unit,U);
+	if( U-&gt;ud-&gt;speed == 0 )
+	{
+		for(map&lt;int,UnitInfo*&gt;::iterator i=U-&gt;UDefending.begin(); i!=U-&gt;UDefending.end(); i++ )
+			i-&gt;second-&gt;UDefences.erase(unit);
+		for(map&lt;int,UnitInfo*&gt;::iterator i=U-&gt;UDefences.begin(); i!=U-&gt;UDefences.end(); i++ )
+			i-&gt;second-&gt;UDefending.erase(unit);
+		UImmobile.erase(unit);
+		if( U-&gt;ud-&gt;minWaterDepth &gt;= 0 )
+			UImmobileWater.erase(unit);
+	}
+	else
+		UMobile.erase(unit);
+	Units.erase(unit);
+//	*l&lt;&lt;&quot; UDe(end)&quot;;
+}
+
+void cRAI::EnemyEnterLOS(int enemy)
+{
+//	*l&lt;&lt;&quot;\nEnemyEnterLOS(&quot;&lt;&lt;enemy&lt;&lt;&quot;)&quot;;
+	if( cb-&gt;GetUnitHealth(enemy) &lt;= 0 ) // ! Work Around   Spring Version: v0.72b1-0.75b2
+	{
+		DebugEnemyEnterLOSError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyEnterLOS(): enemy is either dead or not in LOS&quot;;
+//		*l&lt;&lt;&quot; EEL(end)&quot;;
+		return;
+	}
+	DebugEnemyEnterLOS++;
+
+	if( Enemies.find(enemy) == Enemies.end() )
+		Enemies.insert(iePair(enemy,EnemyInfo()));
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	E-&gt;inLOS=true;
+	E-&gt;ud=cb-&gt;GetUnitDef(enemy);
+	E-&gt;udr=&amp;UDH-&gt;UDR.find(E-&gt;ud-&gt;id)-&gt;second;
+	if( E-&gt;ud-&gt;speed == 0 )
+	{
+		E-&gt;position = cb-&gt;GetUnitPos(enemy);
+		E-&gt;posLocked = true;
+	}
+
+	UnitM-&gt;EnemyEnterLOS(enemy,E);
+	Build-&gt;BP-&gt;EResourceEnterLOS(enemy,E);
+//	*l&lt;&lt;&quot; EEL(end)&quot;;
+}
+
+void cRAI::EnemyLeaveLOS(int enemy)
+{
+//	*l&lt;&lt;&quot;\nEnemyLeaveLOS(&quot;&lt;&lt;enemy&lt;&lt;&quot;)&quot;;
+	if( Enemies.find(enemy) == Enemies.end() ) // ! Work Around  Spring Version: v0.72b1-0.75b2
+	{
+		DebugEnemyLeaveLOSError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyLeaveLOS(): unknown unit id&quot;;
+//		*l&lt;&lt;&quot; ELL(end)&quot;;
+		return;
+	}
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	if( !E-&gt;inLOS ) // Spring Version: v0.76b1
+	{
+		DebugEnemyLeaveLOSError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyLeaveLOS(): not in LOS&quot;;
+//		*l&lt;&lt;&quot; ELL(end)&quot;;
+		return;
+	}
+
+	DebugEnemyLeaveLOS++;
+	E-&gt;inLOS=false;
+	if( !E-&gt;inRadar )
+	{
+		if( !E-&gt;posLocked )
+			E-&gt;position = cb-&gt;GetUnitPos(enemy);
+		if( !TM-&gt;SectorValid(TM-&gt;GetSector(E-&gt;position)) )
+			EnemyRemove(enemy,E);
+	}
+//	*l&lt;&lt;&quot; ELL(end)&quot;;
+}
+
+void cRAI::EnemyEnterRadar(int enemy)
+{
+//	*l&lt;&lt;&quot;\nEnemyEnterRadar(&quot;&lt;&lt;enemy&lt;&lt;&quot;)&quot;;
+	if( cb-&gt;GetUnitPos(enemy).x &lt;= 0 &amp;&amp; cb-&gt;GetUnitPos(enemy).y &lt;= 0 &amp;&amp; cb-&gt;GetUnitPos(enemy).z &lt;= 0 ) // ! Work Around   Spring Version: v0.72b1-0.75b2
+	{
+		DebugEnemyEnterRadarError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyEnterRadar(): enemy position is invalid&quot;;
+//		*l&lt;&lt;&quot; EER(end)&quot;;
+		return;
+	}
+	DebugEnemyEnterRadar++;
+
+	if( Enemies.find(enemy) == Enemies.end() )
+		Enemies.insert(iePair(enemy,EnemyInfo()));
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	E-&gt;inRadar=true;
+
+	UnitM-&gt;EnemyEnterRadar(enemy,E);
+//	*l&lt;&lt;&quot; EER(end)&quot;;
+}
+
+void cRAI::EnemyLeaveRadar(int enemy)
+{
+//	*l&lt;&lt;&quot;\nEnemyLeaveRadar(&quot;&lt;&lt;enemy&lt;&lt;&quot;)&quot;;
+	if( Enemies.find(enemy) == Enemies.end() ) // ! Work Around   Spring Version: v0.72b1-0.75b2
+	{
+		DebugEnemyLeaveRadarError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyLeaveRadar(): unknown unit id&quot;;
+//		*l&lt;&lt;&quot; ELR(end)&quot;;
+		return;
+	}
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	if( !E-&gt;inRadar ) // Spring Version: v0.76b1
+	{
+		DebugEnemyLeaveRadarError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyLeaveRadar(): not in radar&quot;;
+//		*l&lt;&lt;&quot; ELR(end)&quot;;
+		return;
+	}
+
+	DebugEnemyLeaveRadar++;
+	E-&gt;inRadar=false;
+	if( !E-&gt;inLOS )
+	{
+		if( !E-&gt;posLocked )
+			E-&gt;position = cb-&gt;GetUnitPos(enemy);
+		if( !TM-&gt;SectorValid(TM-&gt;GetSector(E-&gt;position)) )
+			EnemyRemove(enemy,E);
+	}
+//	*l&lt;&lt;&quot; ELR(end)&quot;;
+}
+
+void cRAI::EnemyDestroyed(int enemy,int attacker)
+{
+//	*l&lt;&lt;&quot;\nEnemyDestroyed(&quot;&lt;&lt;enemy&lt;&lt;&quot;,&quot;&lt;&lt;attacker&lt;&lt;&quot;)&quot;;
+	if( Enemies.find(enemy) == Enemies.end() ) // ! Work Around   Spring Version: v0.72b1-0.75b2
+	{
+		*l&lt;&lt;&quot;\nWARNING: EnemyDestroyed(): unknown unit id&quot;;
+//		*l&lt;&lt;&quot; ED(end)&quot;;
+		return;
+	}
+
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	if( E-&gt;inLOS )
+		DebugEnemyDestroyedLOS++;
+	if( E-&gt;inRadar )
+		DebugEnemyDestroyedRadar++;
+	EnemyRemove(enemy,E);
+//	*l&lt;&lt;&quot; ED(end)&quot;;
+}
+
+void cRAI::EnemyRemove(int enemy, EnemyInfo *E)
+{
+	if( E-&gt;RS != 0 &amp;&amp; E-&gt;RS-&gt;unitID == enemy )
+	{
+		E-&gt;RS-&gt;unitID=-1;
+		E-&gt;RS-&gt;unitUD=0;
+		E-&gt;RS-&gt;enemy = false;
+	}
+	if( E-&gt;baseThreatID != -1 )
+		EThreat.erase(enemy);
+	while( int(E-&gt;AttackGroups.size()) &gt; 0 )
+		UnitM-&gt;GroupRemoveEnemy(enemy,E,E-&gt;AttackGroups.begin()-&gt;second);
+	Enemies.erase(enemy);
+}
+
+void cRAI::EnemyDamaged(int damaged,int attacker,float damage,float3 dir)
+{
+
+}
+
+void cRAI::UnitIdle(int unit)
+{
+//	*l&lt;&lt;&quot;\nUI(&quot;&lt;&lt;unit&lt;&lt;&quot;)&quot;;
+	if( Units.find(unit) == Units.end() ) // ! Work Around   Spring Version: v0.72b1-0.75b2
+	{
+		*l&lt;&lt;&quot;\nWARNING: UnitIdle(): unknown unit id&quot;;
+//		*l&lt;&lt;&quot; UI(end)&quot;;
+		return;
+	}
+	UnitInfo *U = &amp;Units.find(unit)-&gt;second;
+	if( U-&gt;AIDisabled || cb-&gt;UnitBeingBuilt(unit) || cb-&gt;IsUnitParalyzed(unit) )
+	{
+//		*l&lt;&lt;&quot; UI(end)&quot;;
+		return;
+	}
+	if( int(cb-&gt;GetCurrentUnitCommands(unit)-&gt;size()) &gt; 0 )
+	{
+//		*l&lt;&lt;&quot; UI(end)&quot;;
+		return;
+	}
+	U-&gt;HumanOrder=false;
+
+	if( cb-&gt;GetCurrentFrame() &lt;= U-&gt;lastUnitIdleFrame+15 ) // !! Occurs if enemy attack order fails/...possibly some other reason
+	{
+		U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+15;
+//		*l&lt;&lt;&quot; UI(end)&quot;;
+		return;
+	}
+	U-&gt;lastUnitIdleFrame=cb-&gt;GetCurrentFrame();
+	U-&gt;commandTimeOut=-1;
+	if( U-&gt;bInCombat )
+	{
+		CombatM-&gt;UnitIdle(unit,U);
+//		*l&lt;&lt;&quot; UI(end)&quot;;
+		return;
+	}
+	UnitM-&gt;UnitIdle(unit,U);
+//	*l&lt;&lt;&quot; UI(end)&quot;;
+}
+
+void cRAI::GotChatMsg(const char* msg,int player)
+{
+
+}
+
+void cRAI::UnitDamaged(int unit,int attacker,float damage,float3 dir)
+{
+//	*l&lt;&lt;&quot;\nUnitDamaged(&quot;&lt;&lt;unit&lt;&lt;&quot;,&quot;&lt;&lt;attacker&lt;&lt;&quot;,&quot;&lt;&lt;damage&lt;&lt;&quot;,x&quot;&lt;&lt;dir.x&lt;&lt;&quot; z&quot;&lt;&lt;dir.z&lt;&lt;&quot; y&quot;&lt;&lt;dir.y&lt;&lt;&quot;)&quot;;
+	if( cb-&gt;UnitBeingBuilt(unit) || cb-&gt;IsUnitParalyzed(unit) || cb-&gt;GetUnitHealth(unit) &lt;= 0.0 )
+	{
+//		*l&lt;&lt;&quot; UDa(end)&quot;;
+		return;
+	}
+
+	UnitInfo *U = &amp;Units.find(unit)-&gt;second;
+	if( cb-&gt;GetCurrentFrame() &lt;= U-&gt;lastUnitDamagedFrame+15 )
+	{
+//		*l&lt;&lt;&quot; UDa(end)&quot;;
+		return;
+	}
+	U-&gt;lastUnitDamagedFrame=cb-&gt;GetCurrentFrame();
+
+	EnemyInfo *E=0;
+	if( Enemies.find(attacker) != Enemies.end() )
+		E = &amp;Enemies.find(attacker)-&gt;second;
+	else
+		attacker = -1;
+
+	if( U-&gt;ud-&gt;speed==0 )
+	{
+		if( E != 0 )
+		{
+			E-&gt;baseThreatFrame=cb-&gt;GetCurrentFrame();
+			E-&gt;baseThreatID=unit;
+			if( EThreat.find(attacker) == EThreat.end() )
+			{
+				EThreat.insert(iepPair(attacker,E));
+				for( int i=0; i&lt;UnitM-&gt;GroupSize; i++ )
+				{
+					if( int(UnitM-&gt;Group[i]-&gt;Enemies.size()) == 0 &amp;&amp; !UnitM-&gt;Group[i]-&gt;Units.begin()-&gt;second-&gt;ud-&gt;canLoopbackAttack )
+					{
+						int enemyID = CombatM-&gt;GetClosestEnemy(cb-&gt;GetUnitPos(UnitM-&gt;Group[i]-&gt;Units.begin()-&gt;first),UnitM-&gt;Group[i]-&gt;Units.begin()-&gt;second);
+					}
+				}
+			}
+		}
+		ValidateUnitList(&amp;U-&gt;UGuards);
+		for( map&lt;int,UnitInfo*&gt;::iterator i = U-&gt;UGuards.begin(); i != U-&gt;UGuards.end(); i++ )
+		{
+			if( int(i-&gt;second-&gt;URepair.size()) == 0 &amp;&amp; !IsHumanControled(i-&gt;first,i-&gt;second) )
+			{
+				Command c;
+				c.id = CMD_REPAIR;
+				c.params.push_back(unit);
+				cb-&gt;GiveOrder(i-&gt;first, &amp;c);
+			}
+			if( i-&gt;second-&gt;URepair.find(unit) == i-&gt;second-&gt;URepair.end() )
+				i-&gt;second-&gt;URepair.insert(iupPair(unit,U));
+		}
+		if( U-&gt;ud-&gt;canReclaim &amp;&amp; attacker &gt; -1 &amp;&amp; U-&gt;udr-&gt;IsNano() &amp;&amp; cb-&gt;GetUnitPos(unit).distance2D(cb-&gt;GetUnitPos(attacker)) &lt; U-&gt;ud-&gt;buildDistance &amp;&amp; !IsHumanControled(unit,U) )
+		{
+			if( cb-&gt;GetCurrentUnitCommands(unit)-&gt;size() == 0 || (cb-&gt;GetCurrentUnitCommands(unit)-&gt;front().id != CMD_REPAIR &amp;&amp; cb-&gt;GetCurrentUnitCommands(unit)-&gt;front().id != CMD_RECLAIM) )
+			{
+				Command c;
+				c.id = CMD_RECLAIM;
+				c.params.push_back(attacker);
+				cb-&gt;GiveOrder(unit, &amp;c);
+			}
+		}
+	}
+	if( U-&gt;AIDisabled || U-&gt;pBOL-&gt;task&lt;=0 || U-&gt;ud-&gt;speed==0 )
+	{
+//		*l&lt;&lt;&quot; UDa(end)&quot;;
+		return;
+	}
+
+	if( E != 0 &amp;&amp; U-&gt;Group != 0 &amp;&amp; U-&gt;Group-&gt;Enemies.find(attacker) == U-&gt;Group-&gt;Enemies.end() )
+	{
+		if( E-&gt;baseThreatID != -1 || UnitM-&gt;ActiveAttackOrders() )
+			UnitM-&gt;GroupAddEnemy(attacker,E,U-&gt;Group);
+	}
+
+	if( !IsHumanControled(unit,U) )
+		CombatM-&gt;UnitDamaged(unit,U,attacker,E,dir);
+//	*l&lt;&lt;&quot; UDa(end)&quot;;
+}
+
+void cRAI::UnitMoveFailed(int unit)
+{
+//	*l&lt;&lt;&quot;\nUnitMoveFailed(&quot;&lt;&lt;unit&lt;&lt;&quot;)&quot;;
+	if( UMobile.find(unit) == UMobile.end() ) // ! Work Around   Spring Version: v0.72b1-0.74b1
+	{
+//		*l&lt;&lt;&quot; UMF(end)&quot;;
+		return;
+	}
+
+	UnitInfo *U = UMobile.find(unit)-&gt;second;
+	if( U-&gt;AIDisabled || cb-&gt;IsUnitParalyzed(unit) ||
+		Build-&gt;UBuilderMoveFailed(unit,U) || UnitM-&gt;UnitMoveFailed(unit,U) ||
+		int(cb-&gt;GetCurrentUnitCommands(unit)-&gt;size()) &gt; 0 )
+	{
+//		*l&lt;&lt;&quot; UMF(end)&quot;;
+		return;
+	}
+
+//	*l&lt;&lt;U-&gt;ud-&gt;humanName+&quot; is waiting.&quot;;
+	Command c;
+	c.id=CMD_WAIT;
+	//c.timeOut=cb-&gt;GetCurrentFrame()+120;
+	cb-&gt;GiveOrder(unit,&amp;c);
+	U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+90;
+//	*l&lt;&lt;&quot; UMF(end)&quot;;
+}
+
+int cRAI::HandleEvent(int msg,const void* data)
+{
+//	*l&lt;&lt;&quot;\nHandleEvent(&quot;&lt;&lt;msg&lt;&lt;&quot;,&quot;&lt;&lt;&quot;~&quot;&lt;&lt;&quot;)&quot;;
+	switch (msg)
+	{
+	case AI_EVENT_UNITGIVEN:
+		{
+			const IGlobalAI::ChangeTeamEvent* cte = (const IGlobalAI::ChangeTeamEvent*) data;
+			if( cte-&gt;newteam != cb-&gt;GetMyTeam() )
+			{
+				cb-&gt;SendTextMsg(&quot;cRAI::HandleEvent-AI_EVENT_UNITGIVEN: This AI is out of date, check for a more recent one.&quot;,0);
+				*l&lt;&lt;&quot;\nERROR: cRAI::HandleEvent-AI_EVENT_UNITGIVEN: This AI is out of date, check for a more recent one.\n&quot;;
+			}
+
+			if( Enemies.find(cte-&gt;unit) != Enemies.end() )
+				EnemyDestroyed(cte-&gt;unit,-1);
+
+			if( cb-&gt;GetUnitHealth(cte-&gt;unit) &lt;= 0 ) // ! Work Around   Spring Version: v0.74b1-0.75b2
+			{
+				*l&lt;&lt;&quot;\nWARNING: HandleEvent-AI_EVENT_UNITGIVEN: Given Unit is Dead&quot;;
+				return 0;
+			}
+
+			UnitCreated(cte-&gt;unit);
+			Units.find(cte-&gt;unit)-&gt;second.AIDisabled=false;
+			Units.find(cte-&gt;unit)-&gt;second.commandTimeOut = 0;
+			if( !cb-&gt;UnitBeingBuilt(cte-&gt;unit) )
+				UnitFinished(cte-&gt;unit);
+		}
+		break;
+	case AI_EVENT_UNITCAPTURED:
+		{
+			const IGlobalAI::ChangeTeamEvent* cte = (const IGlobalAI::ChangeTeamEvent*) data;
+			if( cte-&gt;oldteam != cb-&gt;GetMyTeam() )
+			{
+				cb-&gt;SendTextMsg(&quot;cRAI::HandleEvent-AI_EVENT_UNITCAPTURED: This AI is out of date, check for a more recent one.&quot;,0);
+				*l&lt;&lt;&quot;\nERROR: cRAI::HandleEvent-AI_EVENT_UNITCAPTURED: This AI is out of date, check for a more recent one.\n&quot;;
+			}
+
+			UnitDestroyed(cte-&gt;unit,-1);
+		}
+		break;
+	case AI_EVENT_PLAYER_COMMAND:
+		{
+			const IGlobalAI::PlayerCommandEvent* pce = (const IGlobalAI::PlayerCommandEvent*) data;
+			bool ImportantCommand=false;
+			if( pce-&gt;command.id &lt; 0 )
+				ImportantCommand = true;
+			switch( pce-&gt;command.id )
+			{
+			case CMD_MOVE:
+			case CMD_PATROL:
+			case CMD_FIGHT:
+			case CMD_ATTACK:
+			case CMD_AREA_ATTACK:
+			case CMD_GUARD:
+			case CMD_REPAIR:
+			case CMD_LOAD_UNITS:
+			case CMD_UNLOAD_UNITS:
+			case CMD_UNLOAD_UNIT:
+			case CMD_RECLAIM:
+			case CMD_DGUN:
+			case CMD_RESTORE:
+			case CMD_RESURRECT:
+			case CMD_CAPTURE:
+				ImportantCommand = true;
+			}
+
+			for( int i=0; i&lt;int(pce-&gt;units.size()); i++ )
+			{
+				if( Units.find(pce-&gt;units.at(i)) == Units.end() ) // ! Work Around   Spring Version: v0.75b2
+				{
+					*l&lt;&lt;&quot;\nWARNING: HandleEvent-AI_EVENT_PLAYER_COMMAND: unknown unit id=&quot;&lt;&lt;pce-&gt;units.at(i);
+//					pce-&gt;units.erase(pce-&gt;units.begin()+i);
+//					i--;
+				}
+				else if( ImportantCommand )
+					Units.find(pce-&gt;units.at(i))-&gt;second.HumanOrder = true;
+			}
+			if( ImportantCommand )
+			{
+				Build-&gt;HandleEvent(pce);
+			}
+			else if( pce-&gt;command.id == CMD_SELFD )
+			{
+				for( vector&lt;int&gt;::const_iterator i=pce-&gt;units.begin(); i!=pce-&gt;units.end(); i++ )
+					UnitDestroyed(*i,-1);
+			}
+		}
+		break;
+	}
+//	*l&lt;&lt;&quot; HE(end)&quot;;
+	return 0;
+}
+
+void cRAI::Update()
+{
+	frame=cb-&gt;GetCurrentFrame();
+	if(!Build-&gt;bInitiated)
+	{
+		if( frame &gt; 210 || ( cb-&gt;GetMetalIncome()&gt;0 &amp;&amp; cb-&gt;GetMetalIncome()&lt;0.9*cb-&gt;GetMetalStorage() ) || ( cb-&gt;GetEnergyIncome()&gt;0 &amp;&amp; cb-&gt;GetEnergyIncome()&lt;0.9*cb-&gt;GetEnergyStorage() ) )
+		{
+			*l&lt;&lt;&quot;\nbInitiated=true - Frame=&quot;&lt;&lt;frame&lt;&lt;&quot; Metal Income=&quot;&lt;&lt;cb-&gt;GetMetalIncome()&lt;&lt;&quot; Energy Income=&quot;&lt;&lt;cb-&gt;GetEnergyIncome()&lt;&lt;&quot;\n&quot;;
+			Build-&gt;UpdateUDRCost();
+				for(map&lt;int,UnitInfo&gt;::iterator i=Units.begin(); i!=Units.end(); i++ )
+					if( cb-&gt;GetCurrentUnitCommands(i-&gt;first)-&gt;size() == 0 &amp;&amp; !i-&gt;second.AIDisabled )
+						UnitIdle(i-&gt;first);
+			Build-&gt;bInitiated=true;
+		}
+	}
+	if(frame%FUPDATE_MINIMAL)
+	{
+		return;
+	}
+
+//	*l&lt;&lt;&quot;\nUpdate()&quot;;
+	ValidateAllUnits();
+	for(map&lt;int,UnitInfo&gt;::iterator iU=Units.begin(); iU!=Units.end(); iU++)
+	{
+		if( !iU-&gt;second.AIDisabled &amp;&amp; !cb-&gt;UnitBeingBuilt(iU-&gt;first) &amp;&amp; iU-&gt;second.pBOL-&gt;task &gt; 0 )
+		{
+			if( iU-&gt;second.commandTimeOut &gt;= 0 &amp;&amp; frame &gt;= iU-&gt;second.commandTimeOut &amp;&amp; !IsHumanControled(iU-&gt;first,&amp;iU-&gt;second) )
+			{
+//				*l&lt;&lt;&quot;\nStopping &quot;&lt;&lt;iU-&gt;second.ud-&gt;humanName&lt;&lt;&quot;.&quot;;
+				Command c;
+				c.id=CMD_STOP;
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+				iU-&gt;second.commandTimeOut=-1;
+			}
+			else if( frame &gt; iU-&gt;second.lastUnitIdleFrame+FUPDATE_UNITS &amp;&amp; cb-&gt;GetCurrentUnitCommands(iU-&gt;first)-&gt;size() == 0 )
+			{
+//				*l&lt;&lt;&quot;\nUnit was Idle  Name=&quot;&lt;&lt;iU-&gt;second.ud-&gt;name;
+				UnitIdle(iU-&gt;first);
+			}
+		}
+	}
+
+	if(!(frame%FUPDATE_POWER))
+	{
+		Build-&gt;PM-&gt;Update();
+		SWM-&gt;Update();
+	}
+	if(!(frame%FUPDATE_BUILDLIST))	// Currently every 1 minute
+	{
+		Build-&gt;UpdateUDRCost();
+	}
+//	*l&lt;&lt;&quot; U(end)&quot;;
+}
+
+void cRAI::CorrectPosition(float3* Position)
+{
+	if( Position-&gt;x &lt; 1 )
+		Position-&gt;x = 1;
+	else if( Position-&gt;x &gt; 8*cb-&gt;GetMapWidth()-1 )
+		Position-&gt;x = 8*cb-&gt;GetMapWidth()-1;
+	if( Position-&gt;z &lt; 1 )
+		Position-&gt;z = 1;
+	else if( Position-&gt;z &gt; 8*cb-&gt;GetMapHeight()-1 )
+		Position-&gt;z = 8*cb-&gt;GetMapHeight()-1;
+	Position-&gt;y = cb-&gt;GetElevation(Position-&gt;x,Position-&gt;z);
+}
+
+int cRAI::GetCurrentMapBody(const UnitDef* ud, float3 Position)
+{
+	if( ud-&gt;canfly || ud-&gt;canhover )
+		return -1;
+
+	if( ud-&gt;movedata == 0 &amp;&amp; ud-&gt;minWaterDepth &lt; 0 &amp;&amp; -ud-&gt;maxWaterDepth &lt;= TM-&gt;MaxWaterDepth )
+		return -1;
+
+	if( ud-&gt;movedata != 0 &amp;&amp; ud-&gt;minWaterDepth &lt; 0 &amp;&amp; -ud-&gt;movedata-&gt;depth &lt;= TM-&gt;MaxWaterDepth )
+		return -1;
+
+	int iS = TM-&gt;GetSector(Position);
+	if( !TM-&gt;SectorValid(iS) )
+	{
+		CorrectPosition(&amp;Position);
+		iS = TM-&gt;GetSector(Position);
+	}
+	for( map&lt;int,MapBody*&gt;::iterator iB=TM-&gt;Sector[iS].mb.begin(); iB!=TM-&gt;Sector[iS].mb.end(); iB++ )
+	{
+		if( iB-&gt;second-&gt;Water &amp;&amp; ud-&gt;minWaterDepth &gt;= 0 )
+			return iB-&gt;first;
+		else if( !iB-&gt;second-&gt;Water &amp;&amp; ud-&gt;minWaterDepth &lt; 0 )
+			return iB-&gt;first;
+	}
+	return -2;
+}
+
+float3 cRAI::GetRandomPosition(int MapBody)
+{
+	float3 Pos;
+	if( MapBody &lt; 0 )
+	{
+		Pos.x=1.0 + rand()%7 + 8.0*(rand()%cb-&gt;GetMapWidth());
+		Pos.z=1.0 + rand()%7 + 8.0*(rand()%cb-&gt;GetMapHeight());
+		Pos.y=cb-&gt;GetElevation(Pos.x,Pos.z);
+		return Pos;
+	}
+
+	vector&lt;int&gt; Temp;
+	for( map&lt;int,MapSector*&gt;::iterator iS=TM-&gt;MapB[MapBody]-&gt;Sector.begin(); iS!=TM-&gt;MapB[MapBody]-&gt;Sector.end(); iS++ )
+		Temp.push_back(iS-&gt;first);
+	int iS=Temp.at(rand()%int(Temp.size()));
+	Pos.x=TM-&gt;Sector[iS].Pos.x - 127.0 + rand()%255;
+	Pos.z=TM-&gt;Sector[iS].Pos.z - 127.0 + rand()%255;
+	Pos.y=cb-&gt;GetElevation(Pos.x,Pos.z);
+	return Pos;
+}
+
+bool cRAI::ValidateUnit(const int&amp; unitID)
+{
+	if( cb-&gt;GetUnitDef(unitID) == 0 ) // ! Work Around   Spring Version: v0.74b1-0.75b2
+	{
+		*l&lt;&lt;&quot;\nWARNING: ValidateUnit(): iU-&gt;first=&quot;&lt;&lt;unitID;
+		UnitDestroyed(unitID,-1);
+		return false;
+	}
+	return true;
+}
+
+bool cRAI::ValidateUnitList(map&lt;int,UnitInfo*&gt; *UL)
+{
+	int ULsize = UL-&gt;size();
+	for(map&lt;int,UnitInfo*&gt;::iterator iU=UL-&gt;begin(); iU!=UL-&gt;end(); iU++)
+	{
+		if( !ValidateUnit(iU-&gt;first) )
+		{
+			// The iterator has becomes invalid at this point
+			if( ULsize == 1 ) // if true then the list is now empty, and may have been deleted (UL is invalid)
+				return false;
+			else
+				return ValidateUnitList(UL);
+		}
+	}
+	return true;
+}
+
+void cRAI::ValidateAllUnits()
+{
+	for(map&lt;int,UnitInfo&gt;::iterator iU=Units.begin(); iU!=Units.end(); iU++)
+	{
+		if( !ValidateUnit(iU-&gt;first) )
+		{
+			// The iterator has becomes invalid at this point
+			ValidateAllUnits();
+			return;
+		}
+	}
+}
+
+bool cRAI::IsHumanControled(const int&amp; unit,UnitInfo *U)
+{
+	if( int(cb-&gt;GetCurrentUnitCommands(unit)-&gt;size()) == 0 )
+		return false;
+	if( U-&gt;HumanOrder )
+		return true;
+	return false;
+}
+
+void cRAI::DebugDrawLine(float3 StartPos, float distance, int direction, float xposoffset, float zposoffset, float yposoffset, int lifetime, int arrow, float width, int group)
+{
+	StartPos.x+=xposoffset;
+	StartPos.z+=zposoffset;
+	StartPos.y+=yposoffset;
+	float3 EndPos=StartPos;
+	switch( direction )
+	{
+	case 0:
+			EndPos.x+=distance;
+		break;
+	case 1:
+			EndPos.z+=distance;
+		break;
+	case 2:
+			EndPos.x-=distance;
+		break;
+	case 3:
+			EndPos.z-=distance;
+		break;
+	}
+	cb-&gt;CreateLineFigure(StartPos,EndPos,width,arrow,lifetime,group);
+}
+
+void cRAI::DebugDrawShape(float3 CenterPos, float linelength, float width, int arrow, float yposoffset, int lifetime, int sides, int group)
+{
+	DebugDrawLine(CenterPos,linelength,0,-linelength/2,linelength/2,yposoffset,lifetime,arrow,width,group);
+	DebugDrawLine(CenterPos,linelength,1,-linelength/2,-linelength/2,yposoffset,lifetime,arrow,width,group);
+	DebugDrawLine(CenterPos,linelength,2,linelength/2,-linelength/2,yposoffset,lifetime,arrow,width,group);
+	DebugDrawLine(CenterPos,linelength,3,linelength/2,linelength/2,yposoffset,lifetime,arrow,width,group);
+}

Added: trunk/AI/Global/RAI-0.553/RAI.h
===================================================================
--- trunk/AI/Global/RAI-0.553/RAI.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/RAI.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,169 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_IGLOBALAI_H
+#define RAI_IGLOBALAI_H
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+struct UnitInfo;
+struct EnemyInfo;
+class cRAI;
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+#include &quot;Global.h&quot;
+#include &quot;UnitDef.h&quot;
+#include &quot;BuilderPlacement.h&quot;
+#include &quot;Builder.h&quot;
+#include &quot;UnitManager.h&quot;
+#include &quot;SWeaponManager.h&quot;
+#include &quot;PowerManager.h&quot;
+#include &quot;CombatManager.h&quot;
+//#include &lt;list&gt;
+//#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &lt;map&gt;
+
+const char AI_NAME[]=&quot;RAI v0.553&quot;;
+
+struct UnitInfo
+{
+	UnitInfo(sRAIUnitDef *runitdef);
+
+	bool AIDisabled;
+	bool HumanOrder;
+	bool UnitFinished;	// Work Around: for cb-&gt;UnitBeingBuilt(), which will not work if UnitDestroyed() fails to trigger immediatly after a unit's death   Spring Version: v0.74b3
+	bool bInCombat;
+	int lastUnitIdleFrame;		// Guard: Prevent UnitIdle from executing too many times in rapid succession
+	int lastUnitDamagedFrame;	// Guard: Prevent UnitDamaged from executing too many times in rapid succession
+	int commandTimeOut;			// Work Around: for the currently broken command.timeout   Spring Version: v0.72b1
+
+	int enemyID;
+	EnemyInfo* E;	// valid if 'enemyID' &amp; 'Group' are set, otherwise this must be updated before used
+	sWeaponEfficiency* enemyEff;
+
+	int mapBody;
+	const UnitDef *ud;		// Always valid
+	sRAIUnitDef *udr;		// Always valid
+	sRAIUnitDefBL *pBOL;	// Valid if AIDisabled=false
+	sResourceSpot *RS;		// Extracter/Geo, otherwise = 0
+	sBuildQuarry *BuildQ;	// Valid if building something, otherwise = 0
+	map&lt;int,UnitInfo*&gt; UGuards;			// Hubs/Nanos guarding this unit
+	map&lt;int,UnitInfo*&gt; UGuarding;		// Hubs/Nanos only, Units being guarded
+	map&lt;int,UnitInfo*&gt; UAssist;			// Hubs/Nanos only, Units it will assist with building
+	map&lt;int,UnitInfo*&gt; URepair;			// Hubs/Nanos only, Units that are in need of repairs
+	map&lt;int,UnitInfo*&gt; UDefences;		// Defences build near this unit
+	map&lt;int,UnitInfo*&gt; UDefending;		// Defences Only, buildings near this unit
+//	map&lt;int,sResourceSpot*&gt; Resources;	// Hubs only, the only resources this unit can build at
+
+	sPowerUnitInfo* CloakUI; // I can not rely on cb-&gt;IsUnitCloaked(unit), since I need to keep track of power variables.
+	sPowerUnitInfo* PowerUI; // I can not rely on cb-&gt;IsUnitActivated(unit), same reason
+	sSWeaponUnitInfo *SWeaponUI; // Valid if unit has a stock weapon, otherwise = 0
+	sRAIGroup *Group;
+};
+
+struct EnemyInfo
+{
+	EnemyInfo();
+
+	bool inLOS;
+	bool inRadar;
+	int baseThreatFrame;// last frame it attacked one of our immobile units
+	int baseThreatID;	// what unit of ours did it last attack
+	const UnitDef *ud;	// valid if the enemy was in LOS at least once, otherwise = 0
+	sRAIUnitDef *udr;	// same as above
+	sResourceSpot *RS;	// Enemy Extracter/Geo, otherwise = 0
+	map&lt;sRAIGroup*,sRAIGroup*&gt; AttackGroups;
+
+	float3 position;	// last known position, used if not in LOS or Radar
+	bool posLocked;		// This unit does not move and its 'position' was saved while in LOS
+};
+
+using namespace std;
+
+static cRAIGlobal *RAIGlobal=0;
+// how offen lists are updated on interval by frame.  Note: generally 30 frames per second
+// Ideally I would have setup my AI to run entirely off of events but for numerous reasons I couldn't avoid making use of the global update
+// hopefully the process time this takes up will be trivial
+#define FUPDATE_MINIMAL 90		// 3 seconds - the minimal time for an update.  NOTE: excluding FUPDATE_UNITS, this value needs to be 'a factor' of the other FUPDATE values
+#define FUPDATE_UNITS 900		// 30 seconds - unit is checked for idleness - should never happen, but it does.
+#define FUPDATE_POWER 360		// 12 seconds - all units are checked for on/off or cloak/uncloak tasks
+#define FUPDATE_BUILDLIST 1800	// 1 minutes - redetermines the available build options - half unnessessary since this is also called by events, hence the longer delay
+
+class cRAI : public IGlobalAI  
+{
+public:
+	cRAI();
+	virtual ~cRAI();
+	void InitAI(IGlobalAICallback* callback, int team);
+	void UnitCreated(int unit);						// called when a new unit is created on ai team
+	void UnitFinished(int unit);					// called when a unit has finished being build
+	void UnitDestroyed(int unit,int attacker);		// called when a unit is destroyed
+	void EnemyEnterLOS(int enemy);					// called when an enemy unit enters the &quot;line of sight&quot; of you or your ally
+	void EnemyLeaveLOS(int enemy);					// called when an enemy unit exits the &quot;line of sight&quot; of you and your allies
+	void EnemyEnterRadar(int enemy);				// called when an enemy unit enters the radar of you or your ally
+	void EnemyLeaveRadar(int enemy);				// called when an enemy unit exits the radar of you and your allies
+	void EnemyDestroyed(int enemy,int attacker);	// called if an enemy inside los or radar dies
+	void EnemyRemove(int enemy, EnemyInfo *E);
+	void EnemyDamaged(int damaged,int attacker,float damage,float3 dir); // called when an enemy inside los or radar is damaged
+	void UnitIdle(int unit);						// called when a unit go idle and is not assigned to any group
+	void GotChatMsg(const char* msg,int player);	// called when someone writes a chat msg
+	void UnitDamaged(int damaged,int attacker,float damage,float3 dir); // called when one of your units are damaged
+	void UnitMoveFailed(int unit);
+	int HandleEvent (int msg,const void *data);
+	void Update();			// called every frame
+
+	void CorrectPosition(float3* Position);
+	int GetCurrentMapBody(const UnitDef* ud, float3 Position); // returns MapB index if &gt;=0, -1 = any mb, -2 = error(unit can not exist at this position)
+	float3 GetRandomPosition(int MapBody=-1); // Will crash if it is both (&gt; 0 and invalid)
+
+	// used to check if the UnitDestroyed() event failed to trigger properly for units,  Work Around - Spring Version: v0.74b3-0.75b2
+	bool ValidateUnit(const int&amp; unitID); // returns true if the unitID exists in-game, unitID is assumed to have been valid up to this point
+	bool ValidateUnitList(map&lt;int,UnitInfo*&gt; *UL); // returns true if at least one unit on the list is valid
+	void ValidateAllUnits();
+
+	bool IsHumanControled(const int&amp; unit,UnitInfo *U); // this function will crash if the 'unit' id is invalid
+
+	typedef pair&lt;int,UnitInfo&gt; iuPair;		// used to access Units
+	typedef pair&lt;int,UnitInfo*&gt; iupPair;	// used to access UImmobile,UMobile
+	map&lt;int,UnitInfo&gt; Units;	// Complete record of all owned units, key value = unit id
+	map&lt;int,UnitInfo*&gt; UImmobile;
+	map&lt;int,UnitInfo*&gt; UMobile;
+	set&lt;int&gt; UImmobileWater;	// Only used to help the builder class
+	typedef pair&lt;int,EnemyInfo&gt; iePair;
+	typedef pair&lt;int,EnemyInfo*&gt; iepPair;
+	map&lt;int,EnemyInfo&gt; Enemies;
+	map&lt;int,EnemyInfo*&gt; EThreat;	// These enemies have attacked our immobile units
+	cLogFile *l;
+
+	void DebugDrawLine(float3 StartPos, float distance, int direction, float xposoffset=0, float zposoffset=0, float yposoffset=50, int lifetime=9000, int arrow=0, float width=5.0, int group=1); // direction 0-3, counter-clock wise, 0=right
+	void DebugDrawShape(float3 CenterPos, float linelength, float width=5.0, int arrow=0, float yposoffset=50, int lifetime=9000, int sides=4, int group=1); // incomplete, sides is always 4
+	int frame;
+	int DebugEnemyEnterLOS;
+	int DebugEnemyLeaveLOS;
+	int DebugEnemyEnterRadar;
+	int DebugEnemyLeaveRadar;
+	int DebugEnemyDestroyedLOS;
+	int DebugEnemyDestroyedRadar;
+	int DebugEnemyEnterLOSError;
+	int DebugEnemyLeaveLOSError;
+	int DebugEnemyEnterRadarError;
+	int DebugEnemyLeaveRadarError;
+
+	cBuilder *Build;
+	cCombatManager *CombatM;
+	cUnitManager *UnitM;
+	cRAIUnitDefHandler *UDH;
+	cRAIGlobal *RG;
+	cTerrainMap *TM; // RG-&gt;TM
+private:
+	IAICallback *cb;
+	cSWeaponManager *SWM;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/SWeaponManager.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/SWeaponManager.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/SWeaponManager.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,109 @@
+#include &quot;SWeaponManager.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+
+cSWeaponManager::cSWeaponManager(IAICallback* callback, cRAI* global)
+{
+	G=global;
+	l=global-&gt;l;
+	cb=callback;
+}
+
+cSWeaponManager::~cSWeaponManager()
+{
+
+}
+
+void cSWeaponManager::UnitFinished(int unit, sRAIUnitDef* udRAI)
+{
+	if( udRAI-&gt;SWeapon == 0 )
+		return;
+
+	typedef pair&lt;int,sSWeaponUnitInfo&gt; isPair;
+	mWeapon.insert(isPair(unit,sSWeaponUnitInfo(udRAI)));
+}
+
+void cSWeaponManager::UnitDestroyed(int unit)
+{
+	if( mWeapon.find(unit) != mWeapon.end() )
+		mWeapon.erase(unit);
+}
+
+void cSWeaponManager::UnitIdle(int unit, sSWeaponUnitInfo* U)
+{
+	if( U-&gt;StockPile &gt; 0 &amp;&amp; U-&gt;udr-&gt;SWeapon-&gt;manualfire &amp;&amp; int(G-&gt;Enemies.size()) &gt;= 1+(G-&gt;UMobile.size()/20) )
+	{
+		set&lt;int&gt; Targets;
+		set&lt;int&gt; ImmobileTargets;
+		for( map&lt;int,EnemyInfo&gt;::iterator iE=G-&gt;Enemies.begin(); iE!=G-&gt;Enemies.end(); iE++ )
+		{
+			if( cb-&gt;GetUnitPos(unit).distance(G-&gt;CombatM-&gt;GetEnemyPosition(iE-&gt;first,&amp;iE-&gt;second)) &lt;= U-&gt;udr-&gt;SWeapon-&gt;range )
+			{
+				if( iE-&gt;second.ud != 0 &amp;&amp; iE-&gt;second.ud-&gt;speed == 0 )
+					ImmobileTargets.insert(iE-&gt;first);
+				else if( iE-&gt;second.inLOS || iE-&gt;second.inRadar )
+					Targets.insert(iE-&gt;first);
+			}
+		}
+
+		if( int(ImmobileTargets.size()) &gt; 0 || int(Targets.size()) &gt; 0 )
+		{
+			set&lt;int&gt;::iterator iE;
+			if( int(ImmobileTargets.size()) &gt; 0 )
+			{
+				iE = ImmobileTargets.begin();
+				for( int i=0; i &lt; rand()%int(ImmobileTargets.size()); i++ )
+					iE++;
+			}
+			else
+			{
+				iE = Targets.begin();
+				for( int i=0; i &lt; rand()%int(Targets.size()); i++ )
+					iE++;
+			}
+
+			EnemyInfo *E = &amp;G-&gt;Enemies.find(*iE)-&gt;second;
+			U-&gt;StockPile--;
+			Command c;
+			c.id = CMD_ATTACK;
+			if( E-&gt;inLOS || E-&gt;inRadar )
+				c.params.push_back(*iE);
+			else
+			{
+				float3 Pos = G-&gt;CombatM-&gt;GetEnemyPosition(*iE,E);
+				c.params.push_back(Pos.x);
+				c.params.push_back(Pos.y);
+				c.params.push_back(Pos.z);
+			}
+			cb-&gt;GiveOrder(unit,&amp;c);
+			return;
+		}
+	}
+	else if( U-&gt;StockPile &lt; 5 || !U-&gt;udr-&gt;SWeapon-&gt;manualfire )
+	{
+		if( ((G-&gt;UDH-&gt;BLMetal-&gt;UDefActive == 0 &amp;&amp; G-&gt;UDH-&gt;BLMetalL-&gt;UDefActive == 0) || 0.66*cb-&gt;GetMetalIncome() &gt; U-&gt;udr-&gt;SWeapon-&gt;metalcost/U-&gt;udr-&gt;SWeapon-&gt;reload) &amp;&amp;
+			((G-&gt;UDH-&gt;BLEnergy-&gt;UDefActive == 0 &amp;&amp; G-&gt;UDH-&gt;BLEnergyL-&gt;UDefActive == 0) || 0.66*cb-&gt;GetEnergyIncome() &gt; U-&gt;udr-&gt;SWeapon-&gt;energycost/U-&gt;udr-&gt;SWeapon-&gt;reload) )
+		{
+			U-&gt;StockPile++;
+			Command c;
+			c.id = CMD_STOCKPILE;
+			cb-&gt;GiveOrder(unit, &amp;c);
+			return;
+		}
+	}
+
+	UnitInfo *UI = &amp;G-&gt;Units.find(unit)-&gt;second;
+	if( UI-&gt;pBOL-&gt;task &lt;= 1 )
+	{
+		Command c;
+		c.id = CMD_WAIT;
+		cb-&gt;GiveOrder(unit, &amp;c);
+		UI-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+300;
+	}
+}
+
+void cSWeaponManager::Update()
+{
+	for( map&lt;int,sSWeaponUnitInfo&gt;::iterator iU = mWeapon.begin(); iU!=mWeapon.end(); iU++ )
+		if( !G-&gt;IsHumanControled(iU-&gt;first,&amp;G-&gt;Units.find(iU-&gt;first)-&gt;second) )
+			UnitIdle(iU-&gt;first,&amp;iU-&gt;second);
+}

Added: trunk/AI/Global/RAI-0.553/SWeaponManager.h
===================================================================
--- trunk/AI/Global/RAI-0.553/SWeaponManager.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/SWeaponManager.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,47 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_STOCKWEAPON_MANAGER_H
+#define RAI_STOCKWEAPON_MANAGER_H
+
+struct sSWeaponUnitInfo;
+class cSWeaponManager;
+
+#include &quot;Builder.h&quot;
+//#include &quot;LogFile.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &lt;map&gt;
+
+struct sSWeaponUnitInfo
+{
+	sSWeaponUnitInfo(sRAIUnitDef* udRAI)
+	{
+		StockPile=0;
+		udr=udRAI;
+	};
+	int StockPile;
+	sRAIUnitDef* udr;
+};
+
+class cSWeaponManager
+{
+public:
+	cSWeaponManager(IAICallback *callback, cRAI* global);
+	~cSWeaponManager();
+
+	void UnitFinished(int unit, sRAIUnitDef* udRAI);
+	void UnitDestroyed(int unit);
+	void UnitIdle(int unit, sSWeaponUnitInfo* U);
+	void Update();
+
+private:
+	cLogFile *l;
+	IAICallback* cb;
+	cRAI* G;
+	map&lt;int,sSWeaponUnitInfo&gt; mWeapon;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/UnitDef.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/UnitDef.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/UnitDef.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,1791 @@
+#include &quot;UnitDef.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+
+// ------------------------------------------------------------------------------------------------
+
+sRAIUnitDefBL::sRAIUnitDefBL(sRAIUnitDef* RAIud, sRAIBuildList* BuildList, float Efficiency, int Task)
+{
+	RUD=RAIud;
+	RUD-&gt;List[RUD-&gt;ListSize++]=this;
+	RBL=BuildList;
+	RBL-&gt;UDef[RBL-&gt;UDefSize++]=this;
+	if( Efficiency &gt; 0 )
+		efficiency = Efficiency;
+	else
+		efficiency = -1;
+	if( Task &gt; 0 )
+		task = Task;
+	else
+		task = -1;
+};
+sRAIUnitDefBL::~sRAIUnitDefBL()
+{
+	for(int iUD=0; iUD&lt;RBL-&gt;UDefSize; iUD++ )
+	{
+		if( RBL-&gt;UDef[iUD] == this )
+		{
+			RBL-&gt;UDefSize--;
+			if( iUD &lt; RBL-&gt;UDefSize )
+				RBL-&gt;UDef[iUD]=RBL-&gt;UDef[RBL-&gt;UDefSize];
+			iUD=RBL-&gt;UDefSize; // end loop
+		}
+	}
+	for(int iBL=0; iBL&lt;RUD-&gt;ListSize; iBL++ )
+	{
+		if( RUD-&gt;List[iBL] == this )
+		{
+			RUD-&gt;ListSize--;
+			if( iBL &lt; RUD-&gt;ListSize )
+				RUD-&gt;List[iBL]=RUD-&gt;List[RUD-&gt;ListSize];
+			iBL=RUD-&gt;ListSize; // end loop
+		}
+	}
+};
+
+// ------------------------------------------------------------------------------------------------
+
+sRAIUnitDef::sRAIUnitDef(const UnitDef *unitdef, IAICallback* cb, cRAIGlobal* G, float EnergyToMetalRatio, cLogFile *l, float MaxFiringRange)
+{
+	ud=unitdef;
+//*l&lt;&lt;&quot;\n   &quot;+ud-&gt;humanName+&quot;(&quot;+ud-&gt;name+&quot;)(&quot;&lt;&lt;ud-&gt;id&lt;&lt;&quot;)&quot;;
+//	if( ud-&gt;canAssist ) *l&lt;&lt;&quot; (ud-&gt;canAssist)&quot;;
+//	if( ud-&gt;canBuild ) *l&lt;&lt;&quot; (ud-&gt;canBuild)&quot;;
+//	if( ud-&gt;canReclaim ) *l&lt;&lt;&quot; (ud-&gt;canReclaim)&quot;;
+//	if( ud-&gt;canResurrect ) *l&lt;&lt;&quot; (ud-&gt;canResurrect)&quot;;
+//	if( ud-&gt;canRepair ) *l&lt;&lt;&quot; (ud-&gt;canRepair)&quot;;
+//	if( ud-&gt;buildSpeed &gt; 0 ) { *l&lt;&lt;&quot; ud-&gt;buildSpeed=&quot;&lt;&lt;ud-&gt;buildSpeed; }
+//	if( ud-&gt;buildDistance &gt; 0 ) { *l&lt;&lt;&quot; ud-&gt;buildDistance=&quot;&lt;&lt;ud-&gt;buildDistance; }
+//	if( ud-&gt;buildOptions.size() &gt; 0) { *l&lt;&lt;&quot; ud-&gt;buildOptions.size()=&quot;&lt;&lt;ud-&gt;buildOptions.size(); }
+//	if( ud-&gt;movedata != 0 ) *l&lt;&lt;&quot; maxSlope=&quot;&lt;&lt;ud-&gt;movedata-&gt;maxSlope&lt;&lt;&quot; depth=&quot;&lt;&lt;ud-&gt;movedata-&gt;depth&lt;&lt;&quot; depthMod=&quot;&lt;&lt;ud-&gt;movedata-&gt;depthMod;
+//	if( ud-&gt;stealth ) *l&lt;&lt;&quot; (ud-&gt;stealth)&quot;;
+//	if( ud-&gt;canKamikaze ) *l&lt;&lt;&quot; (ud-&gt;canKamikaze)&quot;;
+//	if( ud-&gt;turnRate &gt; 0 ) *l&lt;&lt;&quot; ud-&gt;turnRate=&quot;&lt;&lt;ud-&gt;turnRate;
+//	*l&lt;&lt;&quot; ud-&gt;armorType=&quot;&lt;&lt;ud-&gt;armorType;
+//	if( ud-&gt;extractsMetal &gt; 0) { *l&lt;&lt;&quot; extractsMetal=&quot;&lt;&lt;ud-&gt;extractsMetal; }
+//	if( ud-&gt;extractRange &gt; 0) { *l&lt;&lt;&quot; extractRange=&quot;&lt;&lt;ud-&gt;extractRange; }
+//	*l&lt;&lt;&quot; ud-&gt;windGenerator=&quot;&lt;&lt;ud-&gt;windGenerator;
+//	*l&lt;&lt;&quot; ud-&gt;energyUpkeep=&quot;&lt;&lt;ud-&gt;energyUpkeep;
+//	*l&lt;&lt;&quot; ud-&gt;ysize=&quot;&lt;&lt;ud-&gt;ysize;
+//	*l&lt;&lt;&quot; ud-&gt;buildingDecalDecaySpeed=&quot;&lt;&lt;ud-&gt;buildingDecalDecaySpeed;
+//	*l&lt;&lt;&quot; ud-&gt;buildingDecalSizeX=&quot;&lt;&lt;ud-&gt;buildingDecalSizeX;
+//	*l&lt;&lt;&quot; ud-&gt;buildingDecalSizeY=&quot;&lt;&lt;ud-&gt;buildingDecalSizeY;
+//	*l&lt;&lt;&quot; ud-&gt;buildingDecalType=&quot;&lt;&lt;ud-&gt;buildingDecalType;
+//	*l&lt;&lt;&quot; ud-&gt;aihint=&quot;&lt;&lt;ud-&gt;aihint;
+//	*l&lt;&lt;&quot; ud-&gt;category=&quot;&lt;&lt;ud-&gt;category;
+//	*l&lt;&lt;&quot; ud-&gt;categoryString=&quot;&lt;&lt;ud-&gt;categoryString;
+//	*l&lt;&lt;&quot; ud-&gt;wantedHeight=&quot;&lt;&lt;ud-&gt;wantedHeight;
+//	*l&lt;&lt;&quot; ud-&gt;speed=&quot;&lt;&lt;ud-&gt;speed;
+//	*l&lt;&lt;&quot; ud-&gt;mass=&quot;&lt;&lt;ud-&gt;mass;
+//	*l&lt;&lt;&quot; ud-&gt;transportMass=&quot;&lt;&lt;ud-&gt;transportMass;
+// What is ud-&gt;transportSize?
+//	*l&lt;&lt;&quot; xsize=&quot;&lt;&lt;ud-&gt;xsize;
+//	*l&lt;&lt;&quot; ysize=&quot;&lt;&lt;ud-&gt;ysize;
+//	*l&lt;&lt;&quot; ud-&gt;canhover=&quot;&lt;&lt;ud-&gt;canhover;
+//	*l&lt;&lt;&quot; ud-&gt;canfly=&quot;&lt;&lt;ud-&gt;canfly;
+//	*l&lt;&lt;&quot; cb-&gt;GetUnitDefHeight(ud-&gt;id)=&quot;&lt;&lt;cb-&gt;GetUnitDefHeight(ud-&gt;id);
+//	if( ud-&gt;canSubmerge ) *l&lt;&lt;&quot; (canSubmerge)&quot;;
+//	*l&lt;&lt;&quot; maxWaterDepth=&quot;&lt;&lt;ud-&gt;maxWaterDepth;
+//	*l&lt;&lt;&quot; minWaterDepth=&quot;&lt;&lt;ud-&gt;minWaterDepth;
+//	if( ud-&gt;movedata != 0 ) *l&lt;&lt;&quot; maxSlope=&quot;&lt;&lt;ud-&gt;movedata-&gt;maxSlope&lt;&lt;&quot; depth=&quot;&lt;&lt;ud-&gt;movedata-&gt;depth&lt;&lt;&quot; depthMod=&quot;&lt;&lt;ud-&gt;movedata-&gt;depthMod;
+//	*l&lt;&lt;&quot; maxSlope=&quot;&lt;&lt;ud-&gt;maxSlope;
+//	*l&lt;&lt;&quot; deathExplosion=&quot;&lt;&lt;ud-&gt;deathExplosion;
+//	*l&lt;&lt;&quot; energyStorage=&quot;&lt;&lt;ud-&gt;energyStorage;
+//	*l&lt;&lt;&quot; ud-&gt;maxThisUnit=&quot;&lt;&lt;ud-&gt;maxThisUnit;
+//	*l&lt;&lt;&quot; ud-&gt;losRadius=&quot;&lt;&lt;ud-&gt;losRadius;
+//	*l&lt;&lt;&quot; ud-&gt;health=&quot;&lt;&lt;ud-&gt;health;
+//	*l&lt;&lt;&quot; ud-&gt;energyCost=&quot;&lt;&lt;ud-&gt;energyCost;
+//	*l&lt;&lt;&quot; ud-&gt;metalCost=&quot;&lt;&lt;ud-&gt;metalCost;
+//	*l&lt;&lt;&quot; ud-&gt;buildTime=&quot;&lt;&lt;ud-&gt;buildTime;
+//	*l&lt;&lt;&quot; ud-&gt;maxThisUnit=&quot;&lt;&lt;ud-&gt;maxThisUnit;
+	ListSize=0;
+	SetUnitLimit(ud-&gt;maxThisUnit);
+	CanBuild=false;
+	CanBeBuilt=false;
+	HasPrerequisite=false;
+	Disabled=false;
+	RBUnitLimit=false;
+	RBCost=true;
+	RBPrereq=true;
+	WeaponCostMax=0;
+	DGun=0;
+	SWeapon=0;
+	UnitConstructs=0;
+	IsBomber=false;
+	MetalDifference=ud-&gt;makesMetal-ud-&gt;metalUpkeep+ud-&gt;metalMake+2000.0*ud-&gt;extractsMetal; // Needs work -&gt; 2000.0*ud-&gt;extractsMetal
+	EnergyDifference=ud-&gt;energyMake-ud-&gt;energyUpkeep;
+	if( ud-&gt;tidalGenerator &gt; 0 )
+		EnergyDifference+=cb-&gt;GetTidalStrength();
+	if( ud-&gt;windGenerator &gt; 0 &amp;&amp; (cb-&gt;GetMaxWind()-cb-&gt;GetMinWind())/2 + cb-&gt;GetMinWind() &gt;= 11 )
+		EnergyDifference+=(cb-&gt;GetMaxWind()-cb-&gt;GetMinWind())/2 + cb-&gt;GetMinWind();
+	if( EnergyDifference &lt; 0 &amp;&amp; EnergyToMetalRatio*MetalDifference+EnergyDifference &lt; 0 )
+		HighEnergyDemand=true;
+	else
+		HighEnergyDemand=false;
+
+	MetalPCost  =  0.0080f*ud-&gt;metalCost  + 0.00080f*ud-&gt;metalCost *0.01f*float(rand()%101);
+	EnergyPCost = (0.0022f*ud-&gt;energyCost + 0.00022f*ud-&gt;energyCost*0.01f*float(rand()%101))*EnergyToMetalRatio;
+
+	if( MetalPCost &lt; MetalDifference )
+		MetalPCost = MetalDifference;
+
+	if( EnergyPCost &lt; EnergyDifference )
+		EnergyPCost = EnergyDifference;
+
+	if( EnergyPCost &lt; 1.5*ud-&gt;energyUpkeep )
+		EnergyPCost = 1.5*ud-&gt;energyUpkeep;
+/*
+	*l&lt;&lt;&quot; EnergyPCost=&quot;&lt;&lt;EnergyPCost;
+	*l&lt;&lt;&quot; EnergyDifference=&quot;&lt;&lt;EnergyDifference;
+	*l&lt;&lt;&quot; MetalPCost=&quot;&lt;&lt;MetalPCost;
+	*l&lt;&lt;&quot; MetalDifference=&quot;&lt;&lt;MetalDifference;
+*/
+	if( ud-&gt;speed &gt; 0 )
+		CloakCostMax = ud-&gt;cloakCostMoving;
+	else
+		CloakCostMax = ud-&gt;cloakCost;
+
+	int iFHCount=0;
+	for( map&lt;int,string&gt;::const_iterator iB=ud-&gt;buildOptions.begin(); iB!=ud-&gt;buildOptions.end(); iB++ )
+	{
+		if( cb-&gt;GetUnitDef(iB-&gt;second.c_str()) == 0 )
+		{
+			cb-&gt;SendTextMsg(&quot;WARNING: Mod Unit Definition Missing.&quot;,0);
+			*l&lt;&lt;&quot;\nWARNING: No Unit Definition was found for '&quot;&lt;&lt;iB-&gt;second.c_str()&lt;&lt;&quot;'. &quot;;
+		}
+		else if( cb-&gt;GetUnitDef(iB-&gt;second.c_str())-&gt;canfly || cb-&gt;GetUnitDef(iB-&gt;second.c_str())-&gt;canhover )
+			iFHCount++;
+	}
+	bool AirHovConstructer=false;
+	if( int(ud-&gt;buildOptions.size())&gt;=1 &amp;&amp; float(iFHCount)/float(ud-&gt;buildOptions.size()) &gt;= 0.5 )
+		AirHovConstructer=true;
+
+	for( int i=0; i&lt;G-&gt;TM-&gt;MapBodySize; i++ )
+	{
+		mb.insert(i);
+		if( ud-&gt;extractsMetal&gt;0 || ud-&gt;needGeo || ud-&gt;canfly || ud-&gt;canhover ||
+			(ud-&gt;minWaterDepth &lt; 0 &amp;&amp; ud-&gt;maxWaterDepth &gt;= -G-&gt;TM-&gt;MaxWaterDepth) ) {}
+		else if( G-&gt;TM-&gt;MapB[i]-&gt;PercentOfMap &lt; 1.5 )
+			mb.erase(i);
+		else
+		{
+			if( (ud-&gt;minWaterDepth &gt;= 0 &amp;&amp; G-&gt;TM-&gt;MapB[i]-&gt;Water) || // Water Unit and Water Mass  OR
+				(ud-&gt;minWaterDepth &lt; 0 &amp;&amp; !G-&gt;TM-&gt;MapB[i]-&gt;Water) ) // Land Unit and Land Mass
+			{
+				if( G-&gt;TM-&gt;MapB[i]-&gt;PercentOfMap &lt; 20.0 )
+				{
+					if( ud-&gt;canmove &amp;&amp; !AirHovConstructer )
+						mb.erase(i);
+				}
+			}
+			else
+				mb.erase(i);
+		}
+	}
+	if( int(mb.size()) == 0 )
+	{
+		Disabled=true;
+		CheckBuildOptions();
+	}
+
+	if( ud-&gt;kamikazeDist &gt; 0 )
+	{
+		if( ud-&gt;minWaterDepth &lt; 0 &amp;&amp; WeaponLandEff.BestRange &lt; ud-&gt;kamikazeDist )
+		{
+			WeaponLandEff.BestRange = ud-&gt;kamikazeDist;
+		}
+		if( ud-&gt;maxWaterDepth &gt;= -G-&gt;TM-&gt;MaxWaterDepth &amp;&amp; WeaponSeaEff.BestRange &lt; ud-&gt;kamikazeDist )
+		{
+			WeaponSeaEff.BestRange = ud-&gt;kamikazeDist;
+		}
+	}
+
+	WeaponGuardRange = 0;
+	for(std::vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator iW=ud-&gt;weapons.begin(); iW!=ud-&gt;weapons.end(); iW++)
+	{
+		if( iW-&gt;def-&gt;reload!=0 )
+			WeaponCostMax+=int(iW-&gt;def-&gt;energycost/iW-&gt;def-&gt;reload);
+//		*l&lt;&lt;&quot; W=&quot;&lt;&lt;iW-&gt;def-&gt;name;
+//		*l&lt;&lt;&quot; def-&gt;onlyTarget=&quot;&lt;&lt;iW-&gt;def-&gt;onlyTargetCategory;
+//		*l&lt;&lt;&quot; onlyTarget=&quot;&lt;&lt;iW-&gt;onlyTargetCat;
+//		*l&lt;&lt;&quot; badTarget=&quot;&lt;&lt;iW-&gt;badTargetCat;
+//		if( iW-&gt;def-&gt;waterweapon ) *l&lt;&lt;&quot;(Water)&quot;;
+//		if( iW-&gt;def-&gt;stockpile ) *l&lt;&lt;&quot;(Stock)&quot;;
+//		if( iW-&gt;def-&gt;manualfire ) *l&lt;&lt;&quot;(Manual)&quot;;
+//		if( iW-&gt;def-&gt;coverageRange &gt; 0 ) *l&lt;&lt;&quot;(c=&quot;&lt;&lt;iW-&gt;def-&gt;coverageRange&lt;&lt;&quot;)&quot;;
+//		if( iW-&gt;def-&gt;shieldRadius &gt; 0 ) *l&lt;&lt;&quot;(sh=&quot;&lt;&lt;iW-&gt;def-&gt;shieldRadius&lt;&lt;&quot;)&quot;;
+//		if( *iW-&gt;def-&gt;damages.GetDefaultDamage() &gt; 0 ) *l&lt;&lt;&quot;(d=&quot;&lt;&lt;*iW-&gt;def-&gt;damages.GetDefaultDamage()&lt;&lt;&quot;)&quot;;
+//		if( iW-&gt;def-&gt;salvosize &gt; 0 ) *l&lt;&lt;&quot;(sa=&quot;&lt;&lt;iW-&gt;def-&gt;salvosize&lt;&lt;&quot;)&quot;;
+//		if( iW-&gt;def-&gt;reload &gt; 0 ) *l&lt;&lt;&quot;(re=&quot;&lt;&lt;iW-&gt;def-&gt;reload&lt;&lt;&quot;)&quot;;
+//		if( iW-&gt;def-&gt;range &gt; 0 ) *l&lt;&lt;&quot;(ra=&quot;&lt;&lt;iW-&gt;def-&gt;range&lt;&lt;&quot;)&quot;;
+//		*l&lt;&lt;&quot; s=&quot;&lt;&lt;iW-&gt;def-&gt;salvosize;
+//		*l&lt;&lt;&quot; selfExplode=&quot;&lt;&lt;iW-&gt;def-&gt;selfExplode;
+//		*l&lt;&lt;&quot; areaOfEffect=&quot;&lt;&lt;iW-&gt;def-&gt;areaOfEffect;
+		if( ud-&gt;canDGun &amp;&amp; iW-&gt;def-&gt;manualfire )
+		{
+			DGun=iW-&gt;def;
+//			*l&lt;&lt;&quot;(DGun)&quot;;
+		}
+		if( iW-&gt;def-&gt;stockpile )
+		{
+			SWeapon=iW-&gt;def;
+//			*l&lt;&lt;&quot;(SWeapon)&quot;;
+		}
+		if( iW-&gt;def-&gt;dropped )
+			IsBomber = true;
+
+		if( ud-&gt;speed == 0 &amp;&amp; iW-&gt;def-&gt;range &gt; 250 &amp;&amp; iW-&gt;def-&gt;coverageRange == 0 &amp;&amp; (!iW-&gt;def-&gt;manualfire || iW-&gt;def-&gt;range &lt; MaxFiringRange ) )
+		{
+			float NewGuardRange = iW-&gt;def-&gt;range;
+			if( iW-&gt;def-&gt;range &gt; 550 )
+			{
+				NewGuardRange = 550.0f + 0.25*(iW-&gt;def-&gt;range-550.0f);
+				if( NewGuardRange &gt; 1100.0f )
+					NewGuardRange = 1100.0f;
+			}
+			if( WeaponGuardRange &lt; NewGuardRange )
+				WeaponGuardRange = NewGuardRange;
+		}
+//		if( iW-&gt;def-&gt;selfExplode )
+//			Destruct=iW-&gt;def;
+	}
+
+	SetBestWeaponEff(&amp;WeaponLandEff,1,MaxFiringRange);
+	SetBestWeaponEff(&amp;WeaponAirEff,2,MaxFiringRange);
+	SetBestWeaponEff(&amp;WeaponSeaEff,3,MaxFiringRange);
+
+//	*l&lt;&lt;&quot;(&quot;);
+//	if( WeaponLandEff.BestRange &gt; 0 ) *l&lt;&lt;&quot;L&quot;;
+//	if( WeaponAirEff.BestRange &gt; 0 ) *l&lt;&lt;&quot;A&quot;;
+//	if( WeaponSeaEff.BestRange &gt; 0 ) *l&lt;&lt;&quot;S&quot;;
+//	*l&lt;&lt;&quot; WeaponGuardRange=&quot;&lt;&lt;WeaponGuardRange;
+//	*l&lt;&lt;&quot; BestWeaponRange=&quot;&lt;&lt;BestWeaponRange&lt;&lt;&quot; &quot;;
+//	*l&lt;&lt;&quot;)&quot;;
+
+	if( ud-&gt;needGeo )
+	{
+		int NewUnitLimit=0;
+		for( set&lt;int&gt;::iterator i=G-&gt;GeoSpot.begin(); i!=G-&gt;GeoSpot.end(); i++ )
+		{
+			if( cb-&gt;CanBuildAt(ud,cb-&gt;ClosestBuildSite(ud,cb-&gt;GetFeaturePos(*i),64,0)) )
+			{
+				NewUnitLimit++;
+			}
+		}
+//		SetUnitLimit(NewUnitLimit);
+		if( NewUnitLimit == 0 )
+		{
+			Disabled = true;
+			CheckBuildOptions();
+		}
+	}
+	else if( ud-&gt;extractsMetal &gt; 0 &amp;&amp; ((ud-&gt;minWaterDepth &gt;= 0 &amp;&amp; !G-&gt;TM-&gt;MetalMapWater) || (ud-&gt;minWaterDepth &lt; 0 &amp;&amp; !G-&gt;TM-&gt;MetalMapLand)) )
+	{
+		int NewUnitLimit=0;
+		for( vector&lt;float3&gt;::iterator i=G-&gt;KMM-&gt;VectoredSpots.begin(); i!=G-&gt;KMM-&gt;VectoredSpots.end(); i++ )
+		{
+			if( cb-&gt;CanBuildAt(ud,cb-&gt;ClosestBuildSite(ud,*i,64,0)) )
+			{
+				NewUnitLimit++;
+			}
+		}
+//		SetUnitLimit(NewUnitLimit);
+		if( NewUnitLimit == 0 )
+		{
+			Disabled = true;
+			CheckBuildOptions();
+		}
+	}
+}
+
+int sRAIUnitDef::GetPrerequisite()
+{
+	int iBest=-1;
+	vector&lt;int&gt; vTempIDList; // Unit ID
+	set&lt;int&gt; sTemp; // searchable record of vTempIDList contents
+	for( map&lt;int,sRAIPrerequisite&gt;::iterator iP=AllPrerequisiteOptions.begin(); iP!=AllPrerequisiteOptions.end(); iP++ )
+		if( int(iP-&gt;second.udr-&gt;UnitsActive.size()) &gt; 0 )
+		{
+			if( iBest == -1 || iBest &gt; iP-&gt;second.buildLine ) // New or Better buildline was found
+			{
+				iBest = iP-&gt;second.buildLine;
+				vTempIDList.clear();
+				sTemp.clear();
+			}
+			if( iBest == iP-&gt;second.buildLine )
+			{
+				for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=iP-&gt;second.udr-&gt;BuildOptions.begin(); iB!=iP-&gt;second.udr-&gt;BuildOptions.end(); iB++ )
+					if( iB-&gt;second-&gt;CanBeBuilt &amp;&amp; AllPrerequisiteOptions.find(iB-&gt;first) != AllPrerequisiteOptions.end() &amp;&amp; AllPrerequisiteOptions.find(iB-&gt;first)-&gt;second.buildLine == iBest-1 &amp;&amp; sTemp.find(iB-&gt;first)==sTemp.end() &amp;&amp; iB-&gt;second-&gt;GetBuildList(&quot;Constructer&quot;) != 0 &amp;&amp; iB-&gt;second-&gt;GetBuildList(&quot;Constructer&quot;)-&gt;udIndex &lt; iB-&gt;second-&gt;GetBuildList(&quot;Constructer&quot;)-&gt;RBL-&gt;UDefActiveTemp )
+					{
+						vTempIDList.push_back(iB-&gt;first);
+						sTemp.insert(iB-&gt;first);
+					}
+			}
+		}
+
+	if( int(vTempIDList.size()) &gt; 0 )
+	{
+		int i=rand()%int(vTempIDList.size());
+		return AllPrerequisiteOptions.find(vTempIDList.at(i))-&gt;first;
+	}
+
+	return ud-&gt;id;
+};
+
+int sRAIUnitDef::GetPrerequisiteNewBuilder()
+{
+	vector&lt;int&gt; vTempIDList;
+	for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=PrerequisiteOptions.begin(); iP!=PrerequisiteOptions.end(); iP++ )
+	{
+		if( iP-&gt;second-&gt;CanBeBuilt &amp;&amp; (iP-&gt;second-&gt;ListSize &gt; 1 || iP-&gt;second-&gt;List[0]-&gt;efficiency &gt;= 0.5 || PrerequisiteOptions.size() == 1 ) )
+		{
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iP2=iP-&gt;second-&gt;PrerequisiteOptions.begin(); iP2!=iP-&gt;second-&gt;PrerequisiteOptions.end(); iP2++ )
+			{
+				if( int(iP2-&gt;second-&gt;UnitsActive.size()) &gt; 0 )
+				{
+					vTempIDList.push_back(iP-&gt;first);
+					break;
+				}
+			}
+		}
+	}
+	if( int(vTempIDList.size()) &gt; 0 )
+	{
+		int i=rand()%int(vTempIDList.size());
+		return PrerequisiteOptions.find(vTempIDList.at(i))-&gt;first;
+	}
+
+	return GetPrerequisite();
+}
+
+void sRAIUnitDef::SetUnitLimit(int num)
+{
+	UnitLimit[0]=num;
+	if( UnitLimit[0] &gt; ud-&gt;maxThisUnit )
+		UnitLimit[0] = ud-&gt;maxThisUnit;
+	CheckUnitLimit();
+}
+
+void sRAIUnitDef::SetULConstructs(int num)
+{
+	UnitLimit[1] = num;
+	UnitLimit[0] = UnitLimit[1] + int(UnitsActive.size()) + int(UnitConstructsActive.size());
+	SetUnitLimit(UnitLimit[0]);
+}
+
+sRAIUnitDefBL* sRAIUnitDef::GetBuildList(string Name)
+{
+	for( int iBL=0; iBL&lt;ListSize; iBL++ )
+		if( List[iBL]-&gt;RBL-&gt;Name == Name )
+			return List[iBL];
+	return 0;
+}
+
+void sRAIUnitDef::CheckUnitLimit()
+{
+	if( int(UnitsActive.size())+UnitConstructs &gt;= UnitLimit[0] )
+	{
+		if( !RBUnitLimit )
+		{
+			RBUnitLimit = true;
+			CheckBuildOptions();
+		}
+	}
+	else
+	{
+		if( RBUnitLimit )
+		{
+			RBUnitLimit = false;
+			CheckBuildOptions();
+		}
+	}
+}
+
+void sRAIUnitDef::CheckBuildOptions()
+{
+	bool CouldBuild = CanBuild;
+	CanBuild = int(UnitsActive.size()) &gt; 0;
+	if( CouldBuild != CanBuild )
+	{
+		if( CanBuild )
+		{
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+				if( !iB-&gt;second-&gt;HasPrerequisite )
+					iB-&gt;second-&gt;HasPrerequisite = true;
+		}
+		else
+		{
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+			{
+				bool StillHasPrereq = false;
+				for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=iB-&gt;second-&gt;PrerequisiteOptions.begin(); iP!=iB-&gt;second-&gt;PrerequisiteOptions.end(); iP++ )
+				{
+					if( iP-&gt;second-&gt;CanBuild )
+					{
+						StillHasPrereq = true;
+						break;
+					}
+				}
+				if( !StillHasPrereq )
+				{
+					iB-&gt;second-&gt;HasPrerequisite = false;
+				}
+			}
+		}
+	}
+
+	bool CouldBeBuilt = CanBeBuilt;
+	CanBeBuilt = !(Disabled || RBUnitLimit || RBCost || RBPrereq);
+	if( CouldBeBuilt != CanBeBuilt )
+	{
+		for( int i=0; i&lt;ListSize; i++ )
+		{
+			if( CanBeBuilt )
+			{
+				// Enabling
+				List[i]-&gt;RBL-&gt;Disable(List[i]-&gt;udIndex,false);
+			}
+			else
+			{
+				// Disabling
+				List[i]-&gt;RBL-&gt;Disable(List[i]-&gt;udIndex);
+			}
+		}
+	}
+
+	if( CouldBuild || CouldBeBuilt != CanBuild || CanBeBuilt )
+	{
+		if( CanBuild || CanBeBuilt )
+		{
+			// Enabling
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+			{
+				if( iB-&gt;second-&gt;RBPrereq )
+				{
+					iB-&gt;second-&gt;RBPrereq = false;
+					iB-&gt;second-&gt;CheckBuildOptions();
+				}
+			}
+		}
+		else
+		{
+			// Disabling
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+			{
+				if( !iB-&gt;second-&gt;RBPrereq )
+				{
+					bool prereq = false;
+					for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=iB-&gt;second-&gt;PrerequisiteOptions.begin(); iP!=iB-&gt;second-&gt;PrerequisiteOptions.end(); iP++ )
+					{
+						if( iP-&gt;second-&gt;CanBuild || iP-&gt;second-&gt;CanBeBuilt )
+						{
+							prereq = true;
+							break;
+						}
+					}
+					if( !prereq )
+					{
+						iB-&gt;second-&gt;RBPrereq = true;
+						iB-&gt;second-&gt;CheckBuildOptions();
+					}
+				}
+			}
+		}
+	}
+}
+
+bool sRAIUnitDef::IsCategory(string category)
+{
+	for( int i=0; i&lt;=int(ud-&gt;categoryString.size()-category.size()); i++ )
+	{
+		bool found = true;
+		for( int c = 0; c &lt; int(category.size()); c++ )
+			if( ud-&gt;categoryString.at(i+c) != category.at(c) )
+			{
+				found = false;
+				i = int(ud-&gt;categoryString.size()); // end loop
+				c = int(category.size()); // end loop
+			}
+		if( found )
+			return true;
+	}
+	return false;
+}
+
+bool sRAIUnitDef::IsNano()
+{
+	if( int(BuildOptions.size()) == 0 &amp;&amp; ud-&gt;buildDistance &gt; 0 &amp;&amp; ud-&gt;buildSpeed &gt; 0 )
+		return true;
+	return false;
+}
+
+bool sRAIUnitDef::CheckWeaponType(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator udw, int type)
+{
+	switch( type )
+	{
+	case 1: // Land
+		{
+			if( udw-&gt;def-&gt;waterweapon )
+				return false;
+		}
+		break;
+	case 2: // Air
+		{
+			if( udw-&gt;def-&gt;waterweapon )
+				return false;
+		}
+		break;
+	case 3: // Sea
+		{
+			if( !udw-&gt;def-&gt;waterweapon )
+				return false;
+		}
+		break;
+	}
+	return true;
+}
+
+void sRAIUnitDef::SetBestWeaponEff(sWeaponEfficiency *we, int type, float MaxFiringRange)
+{
+	float fRange=-1;
+	float fVal=0;
+	for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator iW=ud-&gt;weapons.begin(); iW!=ud-&gt;weapons.end(); iW++)
+	{
+		if( CheckWeaponType(iW,type) )
+		{
+			float fRangeTemp=iW-&gt;def-&gt;range;
+			if( fRangeTemp &gt; MaxFiringRange )
+				fRangeTemp = MaxFiringRange;
+
+			float fValTemp=0;
+			for(std::vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator iW2=ud-&gt;weapons.begin(); iW2!=ud-&gt;weapons.end(); iW2++)
+			{
+				if( CheckWeaponType(iW,type) )
+				{
+					float fRange=iW2-&gt;def-&gt;range;
+					if( fRange &gt; MaxFiringRange )
+						fRange = MaxFiringRange;
+					if( fRange &gt;= fRangeTemp )
+						fValTemp+=iW2-&gt;def-&gt;damages.GetDefaultDamage()*fRangeTemp/iW2-&gt;def-&gt;reload;
+					if( fRangeTemp &gt; ud-&gt;losRadius )
+						fValTemp*=0.5;
+				}
+			}
+
+			if( fRange == -1 || fValTemp&gt;fVal )
+			{
+				fRange=fRangeTemp;
+				fVal=fValTemp;
+			}
+		}
+	}
+
+	we-&gt;BestRange = fRange;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+sRAIBuildList::sRAIBuildList(int MaxDefSize, cRAIUnitDefHandler *UDRHandler)
+{
+	UDR = UDRHandler;
+	index = UDR-&gt;BLSize;
+	UDef = new sRAIUnitDefBL*[MaxDefSize];
+	UDefSize=0;
+	UDefActive=0;
+	priority=-1;
+	minUnits=0;
+	minEfficiency=1.0;
+	unitsActive=0;
+	Name = &quot;Undefined&quot;;
+}
+
+sRAIBuildList::~sRAIBuildList()
+{
+	for(int i=0; i&lt;UDefSize; i++)
+		delete UDef[i];
+	delete [] UDef;
+}
+
+void sRAIBuildList::Disable(int udIndex, bool value)
+{
+	if( value == true )
+	{
+		UDefActive--;
+		if( UDefActive == 0 )
+		{
+			UDR-&gt;BLActive--;
+			UDR-&gt;BLSwitch(index,UDR-&gt;BLActive);
+		}
+	}
+	UDefSwitch(udIndex,UDefActive);
+	if( value == false )
+	{
+		UDefActive++;
+		if( UDefActive == 1 )
+		{
+			UDR-&gt;BLSwitch(index,UDR-&gt;BLActive);
+			UDR-&gt;BLActive++;
+		}
+	}
+}
+
+void sRAIBuildList::UDefSwitch(int index1, int index2)
+{
+	sRAIUnitDefBL *pRUD = UDef[index1];
+	UDef[index1] = UDef[index2];
+	UDef[index2] = pRUD;
+	UDef[index1]-&gt;udIndex=index1;
+	UDef[index2]-&gt;udIndex=index2;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+cRAIUnitDefHandler::cRAIUnitDefHandler(IAICallback* cb, cRAIGlobal* G, cLogFile *log)
+{
+	l=log;
+	const UnitDef **uds = new const UnitDef*[cb-&gt;GetNumUnitDefs()];
+	cb-&gt;GetUnitDefList(uds);
+	int udSize=cb-&gt;GetNumUnitDefs();
+
+	*l&lt;&lt;&quot;\n Reading All Unit Definitions (Frame=&quot;&lt;&lt;cb-&gt;GetCurrentFrame()&lt;&lt;&quot;) ...  &quot;;
+	for( int iud=cb-&gt;GetNumUnitDefs()-1; iud&gt;=0; iud-- )
+	{
+		if( uds[iud] == 0 ) // Work-around: War Alien VS Human v1.0 (as well as other possible mods)
+		{
+			*l&lt;&lt;&quot;\n  WARNING: (unitdef-&gt;id=&quot;&lt;&lt;iud+1&lt;&lt;&quot;) Mod UnitDefList[&quot;&lt;&lt;iud&lt;&lt;&quot;] = 0&quot;;
+			udSize--;
+			uds[iud] = uds[udSize];
+		}
+	}
+
+	AverageConstructSpeed=0;
+	float fMetalCostTotal=0;
+	float fEnergyCostTotal=0;
+	int Constructs=0;
+	for( int iud=0; iud&lt;udSize; iud++ )
+	{
+		const UnitDef* ud=uds[iud];
+		fMetalCostTotal+=ud-&gt;metalCost;
+		fEnergyCostTotal+=ud-&gt;energyCost;
+		if( ud-&gt;canBuild )
+		{
+			AverageConstructSpeed+=ud-&gt;buildSpeed;
+			Constructs++;
+		}
+	}
+	if( fMetalCostTotal == 0 )
+	{
+		fMetalCostTotal = 1;
+		*l&lt;&lt;&quot;\n  No Metal Usage.&quot;;
+	}
+	if( fEnergyCostTotal == 0 )
+	{
+		fEnergyCostTotal = 1;
+		*l&lt;&lt;&quot;\n  No Energy Usage.&quot;;
+	}
+	EnergyToMetalRatio = fEnergyCostTotal/fMetalCostTotal;
+	if( EnergyToMetalRatio &gt; 40.0f ) // having this too high only causes problems with the cost limits
+		EnergyToMetalRatio = 40.0f;
+
+	*l&lt;&lt;&quot;\n  Average Metal Cost = &quot;&lt;&lt;fMetalCostTotal/udSize;
+	*l&lt;&lt;&quot;\n  Average Energy Cost = &quot;&lt;&lt;fEnergyCostTotal/udSize;
+	*l&lt;&lt;&quot;\n  Energy to Metal Ratio = &quot;&lt;&lt;EnergyToMetalRatio;
+
+	if( Constructs == 0 )
+	{
+		AverageConstructSpeed = 1;
+		*l&lt;&lt;&quot;\n  No Constructers Detected ...&quot;;
+	}
+	else
+	{
+		AverageConstructSpeed/=Constructs;
+		*l&lt;&lt;&quot;\n  Average Construction Speed = &quot;&lt;&lt;AverageConstructSpeed;
+	}
+
+	float MaxFiringRange=8.0*(cb-&gt;GetMapWidth()-1.0+cb-&gt;GetMapHeight()-1.0)/2.0;
+	typedef pair&lt;int,sRAIUnitDef&gt; iuPair;
+	for( int iud=0; iud&lt;udSize; iud++ )
+	{
+		const UnitDef* ud=uds[iud];
+		UDR.insert(iuPair(ud-&gt;id,*new sRAIUnitDef(ud,cb,G,EnergyToMetalRatio,l,MaxFiringRange)));
+	}
+	delete [] uds;
+
+	*l&lt;&lt;&quot;\n Reading UnitDef Build Options ...&quot;;
+	typedef pair&lt;int,sRAIUnitDef*&gt; iupPair; // used to access UDR-&gt;BuildOptions &amp; UDR-&gt;PrerequisiteOptions
+	typedef pair&lt;int,sRAIPrerequisite&gt; ipPair; // used to access UDR-&gt;AllPrerequisiteOptions
+	for( map&lt;int,sRAIUnitDef&gt;::iterator iU=UDR.begin(); iU!=UDR.end(); iU++ )
+	{
+		const UnitDef* ud = iU-&gt;second.ud;
+		for(map&lt;int,string&gt;::const_iterator iBO=ud-&gt;buildOptions.begin(); iBO!=ud-&gt;buildOptions.end(); iBO++ )
+		{
+			const UnitDef* bd = cb-&gt;GetUnitDef(iBO-&gt;second.c_str());
+			if( bd == 0 )
+			{
+				cb-&gt;SendTextMsg(&quot;WARNING: Mod Unit Definition Invalid.&quot;,0);
+				*l&lt;&lt;&quot;\n  WARNING: (unitdef-&gt;id=&quot;&lt;&lt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;ud-&gt;humanName&lt;&lt;&quot; has an invalid unitdef-&gt;buildOption '&quot;&lt;&lt;iBO-&gt;second.c_str()&lt;&lt;&quot;'&quot;;
+			}
+			else
+			{
+				sRAIUnitDef *U=&amp;UDR.find(bd-&gt;id)-&gt;second;
+				iU-&gt;second.BuildOptions.insert(iupPair(bd-&gt;id,U));
+				U-&gt;PrerequisiteOptions.insert(iupPair(ud-&gt;id,&amp;iU-&gt;second));
+			}
+		}
+	}
+
+	*l&lt;&lt;&quot;\n Determining All Build Options and Prerequisites ...&quot;;
+	for( map&lt;int,sRAIUnitDef&gt;::iterator iU=UDR.begin(); iU!=UDR.end(); iU++ )
+	{
+		vector&lt;sBuildLine&gt; vTemp;
+		vTemp.clear();
+		for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=iU-&gt;second.PrerequisiteOptions.begin(); iB!=iU-&gt;second.PrerequisiteOptions.end(); iB++ )
+			vTemp.push_back(sBuildLine(iB-&gt;first,1));
+		for(int iT=0; iT&lt;int(vTemp.size()); iT++ )
+		{
+			if( iU-&gt;second.AllPrerequisiteOptions.find(vTemp[iT].ID) == iU-&gt;second.AllPrerequisiteOptions.end() )
+			{
+				for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=UDR.find(vTemp[iT].ID)-&gt;second.PrerequisiteOptions.begin(); iB!=UDR.find(vTemp[iT].ID)-&gt;second.PrerequisiteOptions.end(); iB++ )
+					vTemp.push_back(sBuildLine(iB-&gt;first,vTemp[iT].BL+1));
+				iU-&gt;second.AllPrerequisiteOptions.insert(ipPair(vTemp[iT].ID,sRAIPrerequisite(&amp;UDR.find(vTemp[iT].ID)-&gt;second)));
+				iU-&gt;second.AllPrerequisiteOptions.find(vTemp[iT].ID)-&gt;second.buildLine=vTemp[iT].BL;
+			}
+			else if( iU-&gt;second.AllPrerequisiteOptions.find(vTemp[iT].ID)-&gt;second.buildLine &gt; vTemp[iT].BL )
+				iU-&gt;second.AllPrerequisiteOptions.find(vTemp[iT].ID)-&gt;second.buildLine=vTemp[iT].BL;
+		}
+		if( !iU-&gt;second.ud-&gt;isCommander &amp;&amp; int(iU-&gt;second.AllPrerequisiteOptions.size()) == 0 )
+			*l&lt;&lt;&quot;\n  WARNING: (&quot;&lt;&lt;iU-&gt;first&lt;&lt;&quot;)&quot;&lt;&lt;iU-&gt;second.ud-&gt;humanName&lt;&lt;&quot; is a non-commander unit that can not be built.&quot;;
+	}
+/*
+*l&lt;&lt;&quot;\n\nDisplaying All Build Options &amp; All Prerequisite Options for All Units ...&quot;;
+for(map&lt;int,sRAIUnitDef&gt;::iterator iU=UDR.begin(); iU!=UDR.end(); iU++ )
+{
+	*l&lt;&lt;&quot;\n(&quot;&lt;&lt;iU-&gt;second.ud-&gt;id&lt;&lt;&quot;)&quot;+iU-&gt;second.ud-&gt;humanName+&quot; (size=&quot;&lt;&lt;iU-&gt;second.BuildOptions.size()&lt;&lt;&quot;):&quot;;
+	for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=UDR.find(iU-&gt;second.ud-&gt;id)-&gt;second.BuildOptions.begin(); iB!=UDR.find(iU-&gt;second.ud-&gt;id)-&gt;second.BuildOptions.end(); iB++ )
+	{
+		*l&lt;&lt;&quot;  &quot;+iB-&gt;second-&gt;ud-&gt;humanName;
+	}
+	*l&lt;&lt;&quot;\n(&quot;&lt;&lt;iU-&gt;second.ud-&gt;id&lt;&lt;&quot;)&quot;+iU-&gt;second.ud-&gt;humanName+&quot; (size=&quot;&lt;&lt;iU-&gt;second.AllPrerequisiteOptions.size()&lt;&lt;&quot;):&quot;;
+	for( map&lt;int,sRAIPrerequisite&gt;::iterator iP=UDR.find(iU-&gt;second.ud-&gt;id)-&gt;second.AllPrerequisiteOptions.begin(); iP!=UDR.find(iU-&gt;second.ud-&gt;id)-&gt;second.AllPrerequisiteOptions.end(); iP++ )
+	{
+		*l&lt;&lt;&quot; &quot;+iP-&gt;second.udr-&gt;ud-&gt;humanName;
+		*l&lt;&lt;&quot;(&quot;&lt;&lt;iP-&gt;second.buildLine&lt;&lt;&quot;)&quot;;
+	}
+}
+*l&lt;&lt;&quot;\n&quot;;
+*/
+	*l&lt;&lt;&quot;\n Determining Unit Efficiencies ...&quot;;
+	const int ARMOR		=0;
+	const int SPEED		=1;
+	const int MANUVER	=2;
+	const int BUILD		=3;
+	const int BUILDOPT	=4;
+	const int ENERGYP	=5;
+	const int ENERGYS	=6;
+	const int METALP	=7;
+	const int METALS	=8;
+	const int AIRBASE	=9;
+	const int RADAR		=10;
+	const int RADARJAM	=11;
+	const int SONAR		=12;
+	const int SONARJAM	=13;
+	const int TRANSPORT	=14;
+	const int TARGETING	=15;
+	const int BOMB		=16;
+	const int STOCKW	=17;
+	const int ANTIMIS	=18;
+	const int SHIELD	=19;
+	const int WEAPON	=20;
+	const int WEAPONSEA	=21;
+	const int UPGRADE	=22;
+	const int COST		=23;
+	const int ESIZE		=24;
+
+//	double UE[cb-&gt;GetNumUnitDefs()][ESIZE]; // Unit Efficency
+	double UE[5000][ESIZE]; // needed for Visual Studios
+	for( map&lt;int,sRAIUnitDef&gt;::iterator iUD=UDR.begin(); iUD!=UDR.end(); iUD++ )
+	{
+		sRAIUnitDef *udr=&amp;iUD-&gt;second;
+		const UnitDef* ud=iUD-&gt;second.ud;
+		int i=iUD-&gt;first-1;
+		float cost=ud-&gt;energyCost+(ud-&gt;metalCost*EnergyToMetalRatio);
+		if( cost == 0 ) cost=1;
+
+		UE[i][COST]=cost;
+		UE[i][ARMOR]=ud-&gt;health/cost;
+		UE[i][SPEED]=ud-&gt;speed;
+
+		UE[i][BUILD]=(ud-&gt;buildSpeed*ud-&gt;buildDistance)/cost;
+		if( ud-&gt;isCommander )
+			UE[i][BUILD]*=2;
+		UE[i][BUILDOPT]=int(ud-&gt;buildOptions.size()) + 8.0*ud-&gt;canResurrect;
+		for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=udr-&gt;BuildOptions.begin(); iB!=udr-&gt;BuildOptions.end(); iB++ )
+			if( (iB-&gt;second-&gt;PrerequisiteOptions.size()) == 1 )
+			{
+				UE[i][BUILDOPT] += 2;
+
+				if( UE[i][BUILDOPT] &lt; 15 )
+					UE[i][BUILDOPT] = 15;
+			}
+		if( UE[i][BUILDOPT] == 0 &amp;&amp; (!ud-&gt;canRepair || ud-&gt;isAirBase) )
+			UE[i][BUILD]=0;
+
+		UE[i][MANUVER]=1.5*ud-&gt;canfly + 1.0*ud-&gt;canCloak + 0.5*ud-&gt;canhover + 0.5*ud-&gt;stealth + 0.5*(ud-&gt;minWaterDepth&lt;0 &amp;&amp; ud-&gt;maxWaterDepth &gt; -G-&gt;TM-&gt;MaxWaterDepth);
+
+		UE[i][ENERGYS]=ud-&gt;energyStorage/cost;
+		if( 10*ud-&gt;energyStorage &lt; fEnergyCostTotal/udSize || ud-&gt;energyStorage &lt; 500 )
+			UE[i][ENERGYS] = 0;
+
+		UE[i][ENERGYP]=udr-&gt;EnergyDifference/cost;
+		if( 1000*udr-&gt;EnergyDifference &lt; ud-&gt;energyCost )
+			UE[i][ENERGYP]=0;
+
+		if( fEnergyCostTotal == 1 )
+		{
+			UE[i][ENERGYP]=0;
+			UE[i][ENERGYS]=0;
+		}
+
+		UE[i][METALS]=ud-&gt;metalStorage/cost;
+		if( 2.5*ud-&gt;metalStorage &lt; fMetalCostTotal/udSize || ud-&gt;metalStorage &lt; 500 )
+			UE[i][METALS]=0;
+
+		UE[i][METALP]=udr-&gt;MetalDifference/cost;
+		if( 1000*udr-&gt;MetalDifference &lt; ud-&gt;metalCost )
+			UE[i][METALP]=0;
+
+		UE[i][RADAR]=ud-&gt;radarRadius + 0.20*ud-&gt;losRadius;
+		UE[i][RADARJAM]=ud-&gt;jammerRadius;
+		UE[i][SONAR]=ud-&gt;sonarRadius + 0.20*ud-&gt;losRadius;
+		UE[i][SONARJAM]=ud-&gt;sonarJamRadius;
+		UE[i][AIRBASE]=(ud-&gt;buildSpeed*ud-&gt;isAirBase);
+
+		UE[i][TRANSPORT]=ud-&gt;transportMass+(0.1*ud-&gt;transportCapacity*ud-&gt;transportMass);
+		if( ud-&gt;transportCapacity == 0 )
+			UE[i][TRANSPORT] = 0;
+		UE[i][TARGETING]=float(ud-&gt;targfac)/cost;
+
+		UE[i][BOMB]=ud-&gt;kamikazeDist;
+		UE[i][STOCKW]=0;
+		UE[i][ANTIMIS]=0;
+		UE[i][SHIELD]=0;
+		UE[i][WEAPON]=0;
+		UE[i][WEAPONSEA]=0;
+		for(std::vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator iW=ud-&gt;weapons.begin(); iW!=ud-&gt;weapons.end(); iW++)
+		{
+			float reload=iW-&gt;def-&gt;reload;
+			if( reload == 0 )
+			{
+				*l&lt;&lt;&quot;\n\nWARNING: the weapon '&quot;&lt;&lt;iW-&gt;name&lt;&lt;&quot;' belonging to (&quot;&lt;&lt;iUD-&gt;first&lt;&lt;&quot;)&quot;&lt;&lt;iUD-&gt;second.ud-&gt;humanName&lt;&lt;&quot; has a 0 reload time.&quot;;
+				reload = 10;
+			}
+			float range=iW-&gt;def-&gt;range;
+			if( range &gt; MaxFiringRange )
+				range = MaxFiringRange;
+
+			if( iW-&gt;def-&gt;stockpile )
+			{
+				if( iW-&gt;def-&gt;manualfire )
+				{
+					UE[i][STOCKW] = iW-&gt;def-&gt;damages.GetDefaultDamage()*range/reload;
+					float fWCost=(iW-&gt;def-&gt;metalcost*EnergyToMetalRatio)+iW-&gt;def-&gt;energycost;
+					if(fWCost==0)
+						fWCost=1;
+					UE[i][STOCKW]/=fWCost;
+				}
+				else if( iW-&gt;def-&gt;coverageRange &gt; 0 )
+				{
+					float rangeC=iW-&gt;def-&gt;coverageRange;
+					if( rangeC &gt; MaxFiringRange )
+						rangeC = MaxFiringRange;
+
+					UE[i][ANTIMIS] = rangeC/reload;
+					float fWCost=(iW-&gt;def-&gt;metalcost*EnergyToMetalRatio)+iW-&gt;def-&gt;energycost;
+					if(fWCost==0)
+						fWCost=1;
+					UE[i][ANTIMIS]/=fWCost;
+				}
+			}
+			else if( iW-&gt;def-&gt;shieldRadius &gt; 0 )
+			{
+				UE[i][SHIELD]=iW-&gt;def-&gt;shieldPower*iW-&gt;def-&gt;shieldRadius*iW-&gt;def-&gt;shieldPowerRegen;
+			}
+			else if( iW-&gt;def-&gt;damages.GetDefaultDamage() &gt; 0 )
+			{
+				if( iW-&gt;def-&gt;waterweapon )
+					UE[i][WEAPONSEA]=iW-&gt;def-&gt;salvosize*iW-&gt;def-&gt;damages.GetDefaultDamage()*range/reload;
+				else
+				{
+					UE[i][WEAPON]=iW-&gt;def-&gt;salvosize*iW-&gt;def-&gt;damages.GetDefaultDamage()*range/reload;
+				}
+			}
+		}
+
+		if( udr-&gt;IsCategory(&quot;UPGRADE&quot;) )
+		{
+			*l&lt;&lt;&quot;\n  Upgrade Category Tag found: &quot;&lt;&lt;ud-&gt;humanName;
+			UE[i][BUILD]=0;
+			UE[i][RADAR]=0;
+			UE[i][TARGETING]=0;
+			UE[i][WEAPON]=0;
+			UE[i][UPGRADE]=1.0f;
+		}
+		else
+			UE[i][UPGRADE]=0;
+
+		if( udr-&gt;IsCategory(&quot;NOTARGET&quot;) ) // Just used in mod(Kernal Panic), Hopefully...
+		{
+			*l&lt;&lt;&quot;\n  NoTarget Category Tag found: &quot;&lt;&lt;ud-&gt;humanName;
+			UE[i][WEAPON]=0;
+		}
+
+		if( int(udr-&gt;PrerequisiteOptions.size()) == 0 || ud-&gt;isFeature )
+		{
+			UE[i][ENERGYP]=0;
+			UE[i][ENERGYS]=0;
+			UE[i][METALP]=0;
+			UE[i][METALS]=0;
+			UE[i][RADAR]=0;
+			UE[i][RADARJAM]=0;
+			UE[i][SONAR]=0;
+			UE[i][SONARJAM]=0;
+			UE[i][UPGRADE]=0;
+		}
+	}
+
+	for( int e=0; e&lt;ESIZE; e++ )
+	{
+		double Max=0;
+		for( int i=0; i&lt;cb-&gt;GetNumUnitDefs(); i++ )
+			if( UDR.find(i+1) != UDR.end() &amp;&amp; UE[i][e]&gt;Max &amp;&amp; int(UDR.find(i+1)-&gt;second.PrerequisiteOptions.size()) &gt; 0 &amp;&amp; ( int(UDR.find(i+1)-&gt;second.PrerequisiteOptions.size()) &gt; 1 || UDR.find(i+1)-&gt;second.PrerequisiteOptions.begin()-&gt;first != i+1 ) )
+			{
+				Max=UE[i][e];
+			}
+		if( Max == 0 )
+		{
+			for( int i=0; i&lt;cb-&gt;GetNumUnitDefs(); i++ )
+				if( UDR.find(i+1) != UDR.end() &amp;&amp; UE[i][e]&gt;Max )
+					Max=UE[i][e];
+		}
+		if( Max &gt; 0 )
+			for( int i=0; i&lt;cb-&gt;GetNumUnitDefs(); i++ )
+			{
+				if( UDR.find(i+1) != UDR.end() )
+				{
+					sRAIUnitDef *udr = &amp;UDR.find(i+1)-&gt;second;
+					UE[i][e]/=Max;
+					if( udr != 0 &amp;&amp; udr-&gt;PrerequisiteOptions.size() &lt;= 1 &amp;&amp; ( int(udr-&gt;PrerequisiteOptions.size()) == 0 || udr-&gt;PrerequisiteOptions.begin()-&gt;first == i+1 ) )
+					{
+						if( UE[i][e] &gt; 1.01f )
+							UE[i][e] = 1.01f;
+						else if( UE[i][e] &gt; 0.0f &amp;&amp; UE[i][e] &lt; 0.1f )
+							UE[i][e] = 0.1f;
+					}
+				}
+			}
+	}
+/*
+	*l&lt;&lt;&quot;\n\nDisplaying Unit Efficency Table ...&quot;;
+	for( int i=0; i&lt;cb-&gt;GetNumUnitDefs(); i++ ) // Unit Efficency Debug
+		if( UDR.find(i+1) != UDR.end() )
+		{
+			*l&lt;&lt;&quot;\n(&quot;&lt;&lt;i+1&lt;&lt;&quot;) &quot;+UDR.find(i+1)-&gt;second.ud-&gt;humanName;
+			for( int e=0; e&lt;ESIZE; e++ )
+				if( UE[i][e] != 0 )
+					*l&lt;&lt;&quot; [&quot;&lt;&lt;e&lt;&lt;&quot;]:&quot;&lt;&lt;100*UE[i][e]&lt;&lt;&quot;%&quot;;
+		}
+	*l&lt;&lt;&quot;\n&quot;;
+*/
+	*l&lt;&lt;&quot;\n Creating the Build Lists ...&quot;;
+	BLSize=0;
+	BLActive=0;
+	for(int iBL=0; iBL&lt;35; iBL++)
+	{
+		BL[BLSize] = new sRAIBuildList(cb-&gt;GetNumUnitDefs(),this);
+		float fAverageTaskEfficiency=0;
+		for( map&lt;int,sRAIUnitDef&gt;::iterator iUD=UDR.begin(); iUD!=UDR.end(); iUD++ )
+		{
+			int i=iUD-&gt;first-1;
+			sRAIUnitDef *udr=&amp;iUD-&gt;second;
+			const UnitDef* ud=iUD-&gt;second.ud;
+			float fCost=ud-&gt;energyCost+(ud-&gt;metalCost*EnergyToMetalRatio);
+			float fValue=0;
+			int iTask=-1;
+			switch(iBL)
+			{
+			case 0:
+				BLBuilder = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Constructer&quot;;
+				if( UE[i][BUILD] == 0 || ( UE[i][BUILDOPT] == 0 &amp;&amp; ud-&gt;speed == 0) ) break;
+
+				// BuildOption Var
+				fValue+=0.7*UE[i][BUILD] + 0.7*UE[i][BUILDOPT] + 0.2*UE[i][MANUVER] + 0.1*UE[i][SPEED] + 0.1*UE[i][ARMOR] + 0.1*UE[i][ENERGYP] + 0.1*UE[i][METALP];
+				iTask=TASK_CONSTRUCT;
+
+				// BuildList Var.
+				BL[BLSize]-&gt;priority=10;
+				BL[BLSize]-&gt;minUnits=2;
+				BL[BLSize]-&gt;minEfficiency=0.5f;
+
+				break;
+			case 1:
+				BL[BLSize]-&gt;Name= &quot;Immobile Assist Constructer&quot;;
+				if( ud-&gt;speed &gt; 0 || UE[i][BUILDOPT] &gt; 0 || UE[i][BUILD] == 0 ) break;
+
+				fValue=UE[i][BUILD];
+				iTask=TASK_CONSTRUCT;
+
+				BL[BLSize]-&gt;priority=5;
+				BL[BLSize]-&gt;minEfficiency=2.0f;
+				break;
+			case 2:
+				BLEnergyL = BL[BLSize];
+				BL[BLSize]-&gt;Name= &quot;Energy Production (Geothermal)&quot;;
+				if( UE[i][ENERGYP] &lt;= 0 || !ud-&gt;needGeo ) break;
+
+				fValue=2.0*UE[i][ENERGYP] + 0.2*UE[i][ARMOR];
+
+				BL[BLSize]-&gt;minEfficiency=0.5f;
+				break;
+			case 3:
+				BLEnergy = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Energy Production&quot;;
+				if( UE[i][ENERGYP] &lt;= 0.0 || ud-&gt;needGeo || ud-&gt;extractsMetal &gt; 0 ) break;
+
+				fValue=2.0*UE[i][ENERGYP] + 0.2*UE[i][ARMOR];
+				if( ud-&gt;speed &gt; 0 )
+					iTask=TASK_NONE;
+
+				BL[BLSize]-&gt;minUnits=2;
+				BL[BLSize]-&gt;minEfficiency=1.01f;
+				break;
+			case 4:
+				BLMetalL = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Metal Production (Extractor)&quot;;
+				if( ud-&gt;extractsMetal &lt;= 0 ) break;
+
+				fValue=2.0*UE[i][METALP] + 0.1*UE[i][ARMOR]*UE[i][METALP];
+
+				BL[BLSize]-&gt;minUnits=2;
+				BL[BLSize]-&gt;minEfficiency=0.5f;
+				break;
+			case 5:
+				BLMetal = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Metal Production&quot;;
+				if( UE[i][METALP] &lt;= 0.0 || ud-&gt;needGeo || (ud-&gt;extractsMetal &gt; 0.0 &amp;&amp; ((ud-&gt;minWaterDepth &gt;= 0.0 &amp;&amp; !G-&gt;TM-&gt;MetalMapWater) || (ud-&gt;minWaterDepth &lt; 0.0 &amp;&amp; !G-&gt;TM-&gt;MetalMapLand))) ) break;
+
+				fValue=2.0*UE[i][METALP] + 0.1*UE[i][ARMOR]*UE[i][METALP];
+				if( UE[i][ENERGYP] &lt; 0.0f )
+					fValue+=0.1*UE[i][ENERGYP];
+
+				if( ud-&gt;speed &gt; 0 )
+					iTask=TASK_NONE;
+
+				BL[BLSize]-&gt;minEfficiency=1.01f;
+				break;
+			case 6:
+				BLEnergyStorage = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Energy Storage&quot;;
+				if( UE[i][ENERGYS] &lt;= 0.0 ) break;
+
+				fValue=2.0*UE[i][ENERGYS] + 0.2*UE[i][ARMOR];
+				if( ud-&gt;speed &gt; 0 )
+					iTask=TASK_NONE;
+
+				BL[BLSize]-&gt;minEfficiency=2.0f;
+				break;
+			case 7:
+				BLMetalStorage = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Metal Storage&quot;;
+				if( UE[i][METALS] &lt;= 0.0 ) break;
+
+				fValue=2.0*UE[i][METALS] + 0.2*UE[i][ARMOR];
+				if( ud-&gt;speed &gt; 0 )
+					iTask=TASK_NONE;
+
+				BL[BLSize]-&gt;minEfficiency=2.0f;
+				break;
+			case 8:
+				BLMobileRadar = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Mobile Radar&quot;;
+				if( ud-&gt;radarRadius &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][RADAR] / UE[i][COST];
+				iTask=TASK_SCOUT;
+
+				BL[BLSize]-&gt;priority=3;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 9:
+				BL[BLSize]-&gt;Name=&quot;Immobile Radar&quot;;
+				if( ud-&gt;radarRadius &lt;= 0 || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][RADAR] / UE[i][COST];
+
+				BL[BLSize]-&gt;priority=4;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 10:
+				BL[BLSize]-&gt;Name=&quot;Mobile Radar Jammer&quot;;
+				if( ud-&gt;jammerRadius &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][RADARJAM] / UE[i][COST];
+				iTask=TASK_SUPPORT;
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 11:
+				BL[BLSize]-&gt;Name=&quot;Immobile Radar Jammer&quot;;
+				if( ud-&gt;jammerRadius &lt;= 0 || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][RADARJAM] / UE[i][COST];
+				fValue/=fCost;
+
+				BL[BLSize]-&gt;priority=4;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 12:
+				BL[BLSize]-&gt;Name=&quot;Mobile Sonar&quot;;
+				if( ud-&gt;sonarRadius &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][SONAR] / UE[i][COST];
+				iTask=TASK_SCOUT;
+
+				if( G-&gt;TM-&gt;PercentLand &lt; 97.0 )
+					BL[BLSize]-&gt;priority=int(1.0+((100.0-G-&gt;TM-&gt;PercentLand)/100.0)*4.0);
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 13:
+				BL[BLSize]-&gt;Name=&quot;Immobile Sonar&quot;;
+				if( ud-&gt;sonarRadius &lt;= 0 || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][SONAR] / UE[i][COST];
+
+				BL[BLSize]-&gt;priority=int(((100.0-G-&gt;TM-&gt;PercentLand)/100.0)*7.0);
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 14:
+				BL[BLSize]-&gt;Name=&quot;Mobile Sonar Jammer&quot;;
+				if( ud-&gt;sonarJamRadius &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][SONARJAM] / UE[i][COST];
+				iTask=TASK_SUPPORT;
+
+				BL[BLSize]-&gt;priority=int(((100.0-G-&gt;TM-&gt;PercentLand)/100.0)*2.0);
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 15:
+				BL[BLSize]-&gt;Name=&quot;Immobile Sonar Jammer&quot;;
+				if( ud-&gt;sonarJamRadius &lt;= 0 || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][SONARJAM] / UE[i][COST];
+
+				BL[BLSize]-&gt;priority=int(((100.0-G-&gt;TM-&gt;PercentLand)/100.0)*5.0);
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+/*
+			case 16: // Check for immobile scouts
+				BL[BLSize]-&gt;Name=&quot;Immobile Recon&quot;;
+				break;
+			case 17: // Check for scouts
+				BL[BLSize]-&gt;Name=&quot;Mobile Recon&quot;;
+				break;
+*/
+			case 18:
+				BL[BLSize]-&gt;Name=&quot;Mobile Bomb&quot;;
+				if( !ud-&gt;canKamikaze || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][BOMB];
+				iTask=TASK_SUICIDE;
+
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				BL[BLSize]-&gt;priority=2;
+				break;
+			case 19:
+				BL[BLSize]-&gt;Name=&quot;Immobile Bomb&quot;;
+				if( !ud-&gt;canKamikaze || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][BOMB];
+
+//				BL[BLSize]-&gt;priority=2;
+				break;
+			case 20:
+				BL[BLSize]-&gt;Name=&quot;Transport&quot;;
+				if( ud-&gt;transportCapacity &lt;= 0 ) break;
+
+				fValue=UE[i][TRANSPORT] + UE[i][MANUVER];
+				iTask=TASK_TRANSPORT;
+
+				BL[BLSize]-&gt;minEfficiency=0.1f;
+				break;
+			case 21:
+				BL[BLSize]-&gt;Name=&quot;Targeting Facility&quot;;
+				if( !ud-&gt;targfac ) break;
+
+				fValue=UE[i][TARGETING];
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+/*
+			case 22:
+				BL[BLSize]-&gt;Name=&quot;Immobile Anti-Air&quot;;
+				break;
+			case 23:
+				BL[BLSize]-&gt;Name=&quot;Mobile Anti-Air&quot;;
+				break;
+			case 24:
+				BL[BLSize]-&gt;Name=&quot;Immobile Anti-Land&quot;;
+				break;
+			case 25:
+				BL[BLSize]-&gt;Name=&quot;Mobile Anti-Land&quot;;
+				break;
+*/
+			case 24:
+				BL[BLSize]-&gt;Name=&quot;Immobile Anti-Land/Air&quot;;
+				if( UE[i][WEAPON] &lt;= 0 || ud-&gt;canKamikaze || ud-&gt;speed &gt; 0.0 || int(udr-&gt;BuildOptions.size()) &gt; 0 ) break;
+
+				fValue=1.3*UE[i][WEAPON] + 0.7*UE[i][ARMOR];
+
+				BL[BLSize]-&gt;priority=int(15.0+(G-&gt;TM-&gt;PercentLand/100.0)*15.0);
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				break;
+			case 25:
+				BL[BLSize]-&gt;Name=&quot;Mobile Anti-Land/Air&quot;;
+				if( UE[i][WEAPON] &lt;= 0 || ud-&gt;canKamikaze || ud-&gt;speed == 0.0 || int(udr-&gt;BuildOptions.size()) &gt; 0 ) break;
+
+				fValue=1.3*UE[i][WEAPON] + 0.5*UE[i][ARMOR] + 0.1*UE[i][MANUVER] + 0.1*UE[i][SPEED];
+				iTask=TASK_ASSAULT;
+
+				BL[BLSize]-&gt;priority=int(18.0+(G-&gt;TM-&gt;PercentLand/100.0)*18.0);
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				break;
+			case 26:
+				BL[BLSize]-&gt;Name=&quot;Immobile Anti-Naval&quot;;
+				if( UE[i][WEAPONSEA] &lt;= 0 || ud-&gt;canKamikaze || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=1.3*UE[i][WEAPONSEA] + 0.7*UE[i][ARMOR];
+
+				BL[BLSize]-&gt;priority=int(((100.0-G-&gt;TM-&gt;PercentLand)/100.0)*12.0);
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				break;
+			case 27:
+				BL[BLSize]-&gt;Name=&quot;Mobile Anti-Naval&quot;;
+				if( UE[i][WEAPONSEA] &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=1.3*UE[i][WEAPONSEA] + 0.5*UE[i][ARMOR] + 0.1*UE[i][MANUVER] + 0.1*UE[i][SPEED];
+				iTask=TASK_ASSAULT;
+
+				BL[BLSize]-&gt;priority=int(((100.0-G-&gt;TM-&gt;PercentLand)/100.0)*18.0);
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				break;
+			case 28:
+				BL[BLSize]-&gt;Name=&quot;Anti-Missile&quot;;
+				if( UE[i][ANTIMIS] &lt;= 0 ) break;
+
+				fValue=UE[i][ANTIMIS];
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 29:
+				BL[BLSize]-&gt;Name=&quot;Stockpile Weapon&quot;;
+				if( UE[i][STOCKW] &lt;= 0 ) break;
+
+				fValue=UE[i][STOCKW];
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 30:
+				BL[BLSize]-&gt;Name=&quot;Anti-Weapon(Shields)&quot;;
+				if( UE[i][SHIELD] &lt;= 0 ) break;
+			
+				fValue=UE[i][SHIELD];
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 31:
+				BLAirBase = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Air Base&quot;;
+				if( !ud-&gt;isAirBase || UE[i][BUILDOPT] &gt; 0 ) break;
+
+				fValue=UE[i][AIRBASE];
+
+				BL[BLSize]-&gt;priority=2;
+				BL[BLSize]-&gt;minEfficiency=0.75f;
+				break;
+			case 32:
+				BL[BLSize]-&gt;Name=&quot;Wall&quot;;
+				if( int(udr-&gt;PrerequisiteOptions.size()) == 0 || !ud-&gt;isFeature ) break;
+
+				fValue=1;
+
+				break;
+			case 33:
+				BL[BLSize]-&gt;Name=&quot;Upgrade&quot;;
+				if( UE[i][UPGRADE] == 0 ) break;
+
+				fValue = 1;
+
+				BL[BLSize]-&gt;priority=10;
+				break;
+			}
+
+			if( fValue &gt; 0.0 )
+			{
+				fAverageTaskEfficiency=((fAverageTaskEfficiency*BL[BLSize]-&gt;UDefSize) + fValue)/(BL[BLSize]-&gt;UDefSize+1);
+				new sRAIUnitDefBL(&amp;iUD-&gt;second,BL[BLSize],fValue,iTask);
+			}
+		}
+
+		if( BL[BLSize]-&gt;Name == &quot;Undefined&quot; )
+		{
+			delete BL[BLSize];
+			BLSize--;
+		}
+		else if( BL[BLSize]-&gt;UDefSize == 0 )
+		{
+			BL[BLSize]-&gt;minUnits=0;
+			BL[BLSize]-&gt;priority=-1;
+		}
+		else
+		{
+			if( BL[BLSize]-&gt;priority == 0 ) // SafeGuard
+				BL[BLSize]-&gt;priority = -1;
+
+			for(int iud=0; iud&lt;BL[BLSize]-&gt;UDefSize; iud++)
+			{
+				if( BL[BLSize]-&gt;UDef[iud]-&gt;efficiency/fAverageTaskEfficiency &gt;= 8.0 ) // Check for absurdly unbalanced units, needed for Gundam v1.1
+				{
+					float fEffDecrease=BL[BLSize]-&gt;UDef[iud]-&gt;efficiency-(7.75*fAverageTaskEfficiency);
+					BL[BLSize]-&gt;UDef[iud]-&gt;efficiency-=fEffDecrease;
+					fAverageTaskEfficiency-=fEffDecrease/BL[BLSize]-&gt;UDefSize;
+					iud=-1; // Start Over
+				}
+			}
+			float max=0;
+			for(int iud=0; iud&lt;BL[BLSize]-&gt;UDefSize; iud++)
+			{
+				BL[BLSize]-&gt;UDef[iud]-&gt;efficiency/=fAverageTaskEfficiency;
+				if( max == 0 || max &lt; BL[BLSize]-&gt;UDef[iud]-&gt;efficiency )
+					max = BL[BLSize]-&gt;UDef[iud]-&gt;efficiency;
+			}
+			if( BL[BLSize]-&gt;minEfficiency &gt; 1 &amp;&amp; BL[BLSize]-&gt;minEfficiency &lt;= max/3.0f )
+			{
+				BL[BLSize]-&gt;minEfficiency = max/2.5f;
+				*l&lt;&lt;&quot;\n  Setting &quot;&lt;&lt;BL[BLSize]-&gt;Name&lt;&lt;&quot; Min. Efficiency to '&quot;&lt;&lt;BL[BLSize]-&gt;minEfficiency&lt;&lt;&quot;'.&quot;;
+			}
+		}
+		BLSize++;
+	}
+/*
+*l&lt;&lt;&quot;\n\nDEBUGGING: Build List&quot;;
+for(int iBL=0; iBL&lt;BLSize; iBL++ )
+{
+	*l&lt;&lt;&quot;\n&quot;+BL[iBL]-&gt;Name+&quot; BuildList #&quot;&lt;&lt;iBL+1&lt;&lt;&quot; (size=&quot;&lt;&lt;BL[iBL]-&gt;UDefSize&lt;&lt;&quot;):&quot;;
+	for(int iud=0; iud&lt;BL[iBL]-&gt;UDefSize; iud++)
+		*l&lt;&lt;&quot;  (&quot;&lt;&lt;BL[iBL]-&gt;UDef[iud]-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;+BL[iBL]-&gt;UDef[iud]-&gt;RUD-&gt;ud-&gt;name+&quot; &quot;&lt;&lt;BL[iBL]-&gt;UDef[iud]-&gt;efficiency;
+}
+*l&lt;&lt;&quot;\nUndefined BuildList:&quot;;
+for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end(); iud++ )
+	if( iud-&gt;second.ListSize == 0 )
+		*l&lt;&lt;&quot;  (&quot;&lt;&lt;iud-&gt;second.ud-&gt;id&lt;&lt;&quot;)&quot;+iud-&gt;second.ud-&gt;name;
+*l&lt;&lt;&quot;\n&quot;;
+*/
+/*
+*l&lt;&lt;&quot;\n\nDEBUGGING: Build Options ...&quot;;
+	for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end(); iud++ )
+	{
+		*l&lt;&lt;&quot;\n(&quot;&lt;&lt;iud-&gt;second.ud-&gt;id&lt;&lt;&quot;) Name=&quot;+iud-&gt;second.ud-&gt;humanName+&quot; &quot;;
+		*l&lt;&lt;&quot; LS=&quot;&lt;&lt;iud-&gt;second.ListSize;
+		for(int iBL=0; iBL&lt;iud-&gt;second.ListSize; iBL++)
+		{
+			sRAIUnitDefBL *pBOL=iud-&gt;second.List[iBL];
+			*l&lt;&lt;&quot;\n  LN=&quot;&lt;&lt; pBOL-&gt;RBL-&gt;Name;
+			*l&lt;&lt;&quot; iBL=&quot;&lt;&lt;iBL;
+			*l&lt;&lt;&quot; UDefSize=&quot;&lt;&lt; pBOL-&gt;RBL-&gt;UDefSize;
+			*l&lt;&lt;&quot; priority=&quot;&lt;&lt; pBOL-&gt;RBL-&gt;priority;
+			*l&lt;&lt;&quot; fEfficiency=&quot;&lt;&lt;pBOL-&gt;efficiency;
+			*l&lt;&lt;&quot; iTask=&quot;&lt;&lt;pBOL-&gt;task;
+		}
+		*l&lt;&lt;&quot;\n&quot;;
+	}
+*l&lt;&lt;&quot;\n&quot;;
+*/
+	*l&lt;&lt;&quot;\n Removing inappropriate build options ...&quot;;
+	for(int iud=0; iud&lt;BLBuilder-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr=BLBuilder-&gt;UDef[iud]-&gt;RUD;
+		if( int(udr-&gt;BuildOptions.size()) == 0 &amp;&amp; udr-&gt;ListSize &gt; 1 )
+		{
+			if( UE[udr-&gt;ud-&gt;id-1][BUILDOPT] == 0 ) // BUILDOPT includes 'resurrect' ability
+			{
+//				*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLBuilder-&gt;Name&lt;&lt;&quot; Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+				delete BLBuilder-&gt;UDef[iud--];
+			}
+			else
+			{
+//				*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLBuilder-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+				BLBuilder-&gt;UDef[iud]-&gt;efficiency /= 5.0f; // This will discourage using certain units as constructers, was needed for MOD: Blox
+			}
+		}
+		else if( udr-&gt;ud-&gt;isCommander )
+		{
+			sRAIUnitDefBL* bestEP = 0;
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB = udr-&gt;BuildOptions.begin(); iB != udr-&gt;BuildOptions.end(); iB++ )
+			{
+				for(int iL=0; iL&lt;iB-&gt;second-&gt;ListSize; iL++)
+				{
+					if( iB-&gt;second-&gt;List[iL]-&gt;RBL == BLEnergy &amp;&amp; (bestEP == 0 || bestEP-&gt;efficiency &lt; iB-&gt;second-&gt;List[iL]-&gt;efficiency) )
+					{
+						bestEP = iB-&gt;second-&gt;List[iL];
+					}
+				}
+			}
+			if( bestEP != 0 &amp;&amp; bestEP-&gt;RUD-&gt;ListSize &gt; 1 &amp;&amp; bestEP-&gt;efficiency &lt; BLEnergy-&gt;minEfficiency )
+			{
+				*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLEnergy-&gt;Name&lt;&lt;&quot; Increased ... (&quot;&lt;&lt;bestEP-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;bestEP-&gt;RUD-&gt;ud-&gt;humanName;
+				bestEP-&gt;efficiency *= 3.0f; // This will encourage using certain units as Energy Production, was needed for MOD: Epic Legions
+			}
+		}
+	}
+
+	// Adjusts the buildlist for useage on a metalmap
+	if( G-&gt;TM-&gt;MetalMapLand || G-&gt;TM-&gt;MetalMapWater )
+	{
+		*l&lt;&lt;&quot;\n Check '&quot;+BLMetal-&gt;Name+&quot; BuildList' for usage on a metal map.&quot;;
+		float Low=-1.0;
+		for(int i=0; i&lt;BLMetal-&gt;UDefSize; i++ ) // Find lowest extractor efficiency
+			if( (Low == -1.0 || Low &gt; BLMetal-&gt;UDef[i]-&gt;efficiency) &amp;&amp; BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;extractsMetal &gt; 0.0 )
+				Low = BLMetal-&gt;UDef[i]-&gt;efficiency;
+		if( Low &gt; 0 )
+		{
+			for(int i=0; i&lt;BLMetal-&gt;UDefSize; i++ ) // Disable metal makers below this efficiency
+				if( BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;extractsMetal &lt;= 0.0 ) // Low &gt; BLMetal-&gt;UDef[i]-&gt;efficiency &amp;&amp;
+				{
+					if( BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ListSize == 1 )
+					{
+						BLMetal-&gt;UDef[i]-&gt;RUD-&gt;Disabled = true;
+						BLMetal-&gt;UDef[i]-&gt;RUD-&gt;CheckBuildOptions();
+//						*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLMetal-&gt;Name&lt;&lt;&quot; Disabled ... (&quot;&lt;&lt;BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;humanName;
+					}
+					else
+					{
+//						*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLMetal-&gt;Name&lt;&lt;&quot; Removed ... (&quot;&lt;&lt;BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;humanName;
+						delete BLMetal-&gt;UDef[i--];
+					}
+				}
+		}
+	}
+
+	// If a &quot;extractor&quot; can be used for some other task, remove it from &quot;Metal Production&quot; and discourage its useage as anything but an extractor, was needed for MOD: FF
+	for(int iud=0; iud&lt;BLMetalL-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLMetalL-&gt;UDef[iud]-&gt;RUD;
+		if( udr-&gt;ListSize &gt; 1 )
+		{
+			for( int i=0; i&lt;udr-&gt;ListSize; i++ )
+				if( udr-&gt;List[i]-&gt;RBL == BLMetal )
+				{
+//					*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLMetalL-&gt;Name&lt;&lt;&quot; Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+					delete BLMetalL-&gt;UDef[iud--];
+					break;
+				}
+				else if( udr-&gt;List[i]-&gt;RBL != BLMetalL )
+				{
+//					*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;udr-&gt;List[i]-&gt;RBL-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+					udr-&gt;List[i]-&gt;efficiency /= 2.0f;
+				}
+		}
+	}
+
+	// If a &quot;geo-energy plant&quot; can be used for some other task, discourage its useage as anything but an &quot;geo-energy plant&quot;, was needed for MOD: FF
+	for(int iud=0; iud&lt;BLEnergyL-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLEnergyL-&gt;UDef[iud]-&gt;RUD;
+		if( udr-&gt;ListSize &gt; 1 )
+		{
+			for( int i=0; i&lt;udr-&gt;ListSize; i++ )
+				if( udr-&gt;List[i]-&gt;RBL != BLEnergyL )
+				{
+//					*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;udr-&gt;List[i]-&gt;RBL-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+					udr-&gt;List[i]-&gt;efficiency /= 2.0f;
+				}
+		}
+	}
+
+	// If a low efficiency &quot;metal producer&quot; can be used for some other task, discourage its use as a &quot;metal producer&quot;, was needed for MOD: CvC
+	for(int iud=0; iud&lt;BLMetal-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLMetal-&gt;UDef[iud]-&gt;RUD;
+		if( UE[udr-&gt;ud-&gt;id-1][METALP] &lt; 0.15 &amp;&amp; udr-&gt;ListSize &gt; 1 )
+		{
+//			*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLMetal-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+			BLMetal-&gt;UDef[iud]-&gt;efficiency /= 5.0f;
+		}
+	}
+
+	// If a low efficiency &quot;energy producer&quot; can be used for some other task, discourage its use as a &quot;energy producer&quot;, was needed for MOD: FF
+	for(int iud=0; iud&lt;BLEnergy-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLEnergy-&gt;UDef[iud]-&gt;RUD;
+		if( UE[udr-&gt;ud-&gt;id-1][ENERGYP] &lt; 0.15 &amp;&amp; udr-&gt;ListSize &gt; 1 )
+		{
+//			*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLEnergy-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+			BLEnergy-&gt;UDef[iud]-&gt;efficiency /= 5.0f;
+		}
+	}
+
+	for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end(); iud++ )
+	{
+		if( iud-&gt;second.ListSize &gt; 1 )
+		{
+			int iBestIndex=0;
+			for(int iT=0; iT&lt;iud-&gt;second.ListSize; iT++) // Finds the task this unit is best at
+				if( iud-&gt;second.List[iT]-&gt;efficiency/iud-&gt;second.List[iT]-&gt;RBL-&gt;minEfficiency &gt; iud-&gt;second.List[iBestIndex]-&gt;efficiency/iud-&gt;second.List[iBestIndex]-&gt;RBL-&gt;minEfficiency )
+					iBestIndex=iT;
+
+			// Remove inappropreiate tasks based off of estimiated efficiency
+			for(int iT=0; iT&lt;iud-&gt;second.ListSize; iT++)
+			{
+				sRAIBuildList *BL = iud-&gt;second.List[iT]-&gt;RBL;
+				if( iT != iBestIndex &amp;&amp; iud-&gt;second.List[iT]-&gt;efficiency &lt; BL-&gt;minEfficiency )
+				{
+					int iBestLIndex=-1;
+					if( 3*iud-&gt;second.List[iT]-&gt;efficiency &gt;= BL-&gt;minEfficiency )
+					{
+						for(int i=0; i&lt;BL-&gt;UDefSize; i++)
+						{
+							if( BL-&gt;UDef[i]-&gt;RUD-&gt;Disabled ) {}
+							else if( iBestLIndex == -1 || BL-&gt;UDef[iBestLIndex]-&gt;efficiency &lt; BL-&gt;UDef[i]-&gt;efficiency )
+								iBestLIndex = i;
+						}
+					}
+
+					if( iT != iBestLIndex )
+					{
+//*l&lt;&lt;&quot;\nRemoving &quot;+iud-&gt;second.ud-&gt;humanName+&quot; from buildlist: &quot;+iud-&gt;second.List[iT]-&gt;BL-&gt;Name&lt;&lt;&quot; Eff=&quot;&lt;&lt;iud-&gt;second.List[iT]-&gt;efficiency;
+						delete iud-&gt;second.List[iT];
+						if( iBestIndex == iud-&gt;second.ListSize )
+							iBestIndex = iT;
+						iT--;
+					}
+				}
+			}
+		}
+
+		if( iud-&gt;second.ListSize == 1 &amp;&amp; iud-&gt;second.List[0]-&gt;efficiency&lt;=0.05 )
+		{
+			iud-&gt;second.SetUnitLimit(1);
+			*l&lt;&lt;&quot;\n The unit (&quot;&lt;&lt;iud-&gt;second.ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;iud-&gt;second.ud-&gt;humanName&lt;&lt;&quot; had a very low efficiency rating in all areas, limiting to build only one.&quot;;
+		}
+	}
+
+	// Restrict all HoverCraft from land or water maps but only if they are not needed for unique build options or tasks
+	if( (G-&gt;TM-&gt;MapBMainLand != 0 &amp;&amp; G-&gt;TM-&gt;MapBMainLand-&gt;PercentOfMap &gt; 90) ||
+		(G-&gt;TM-&gt;MapBMainWater != 0 &amp;&amp; G-&gt;TM-&gt;MapBMainWater-&gt;PercentOfMap &gt; 90) )
+	{
+		bool UseHoverCraft=false;
+		set&lt;int&gt; HoverCraftFactory;
+		for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end() &amp;&amp; !UseHoverCraft; iud++ )
+		{
+			// check if its a HoverCraftFactory
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB = iud-&gt;second.BuildOptions.begin(); iB != iud-&gt;second.BuildOptions.end(); iB++ )
+			{
+				if( !iB-&gt;second-&gt;Disabled )
+				{
+					if( iB-&gt;second-&gt;ud-&gt;canhover )
+						HoverCraftFactory.insert(iud-&gt;first);
+					else
+					{
+						HoverCraftFactory.erase(iud-&gt;first); // in case it was added
+						break;
+					}
+				}
+			}
+
+			if( !iud-&gt;second.Disabled &amp;&amp; iud-&gt;second.ud-&gt;canhover )
+			{
+				// check if it is needed for a unique task
+				for(int iT=0; iT&lt;iud-&gt;second.ListSize; iT++)
+				{
+					sRAIBuildList *BL = iud-&gt;second.List[iT]-&gt;RBL;
+					bool Alternative=false;
+					for(int iud2=0; iud2&lt;BL-&gt;UDefSize; iud2++)
+					{
+						if( !BL-&gt;UDef[iud2]-&gt;RUD-&gt;Disabled &amp;&amp; !BL-&gt;UDef[iud2]-&gt;RUD-&gt;ud-&gt;canhover )
+						{
+							Alternative=true;
+							iud2 = BL-&gt;UDefSize; // end loop
+						}
+					}
+					if( !Alternative )
+						UseHoverCraft = true;
+				}
+
+				// check if it has a unique build option
+				for( map&lt;int,sRAIUnitDef*&gt;::iterator iB = iud-&gt;second.BuildOptions.begin(); iB != iud-&gt;second.BuildOptions.end() &amp;&amp; !UseHoverCraft; iB++ )
+				{
+					if( !iB-&gt;second-&gt;Disabled )
+					{
+						bool Alternative=false;
+						for(map&lt;int,sRAIUnitDef*&gt;::iterator iP = iB-&gt;second-&gt;PrerequisiteOptions.begin(); iP != iB-&gt;second-&gt;PrerequisiteOptions.end(); iP++ )
+						{
+							if( !iP-&gt;second-&gt;Disabled &amp;&amp; !iP-&gt;second-&gt;ud-&gt;canhover )
+							{
+								Alternative=true;
+							}
+						}
+						if( !Alternative )
+							UseHoverCraft = true;
+					}
+				}
+			}
+		}
+
+		if( !UseHoverCraft )
+		{
+			*l&lt;&lt;&quot;\n Disabling all hovercraft &amp; their factories ...&quot;;
+			for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end() &amp;&amp; !UseHoverCraft; iud++ )
+			{
+				if( iud-&gt;second.ud-&gt;canhover || HoverCraftFactory.find(iud-&gt;first) != HoverCraftFactory.end() )
+				{
+					iud-&gt;second.Disabled=true;
+					iud-&gt;second.CheckBuildOptions();
+				}
+			}
+		}
+	}
+
+	for(int iud=0; iud&lt;BLBuilder-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLBuilder-&gt;UDef[iud]-&gt;RUD;
+
+		// TEMPORARY, limits hubs from building extractors/geos/metalmakers - but only if something else can build it
+		if( udr-&gt;ud-&gt;speed == 0 )
+		{
+			set&lt;int&gt; deletion;
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator i=udr-&gt;BuildOptions.begin(); i!=udr-&gt;BuildOptions.end(); i++ )
+			{
+				if( i-&gt;second-&gt;ud-&gt;speed == 0 )
+					if( i-&gt;second-&gt;ud-&gt;needGeo || i-&gt;second-&gt;ud-&gt;extractsMetal &gt; 0 || i-&gt;second-&gt;HighEnergyDemand )
+					{
+						bool alternative=false;
+						for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=i-&gt;second-&gt;PrerequisiteOptions.begin(); iP!=i-&gt;second-&gt;PrerequisiteOptions.end(); iP++)
+							if( iP-&gt;second-&gt;ud-&gt;speed &gt; 0 &amp;&amp; !iP-&gt;second-&gt;Disabled )
+								alternative = true;
+						if( alternative )
+							deletion.insert(i-&gt;first);
+					}
+			}
+			for( set&lt;int&gt;::iterator i=deletion.begin(); i!=deletion.end(); i++ )
+			{
+				sRAIUnitDef *udr2 = udr-&gt;BuildOptions.find(*i)-&gt;second;
+//				*l&lt;&lt;&quot;\n  (Special Rule) Resource Build Option Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName&lt;&lt;&quot; -&gt; (&quot;&lt;&lt;udr2-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr2-&gt;ud-&gt;humanName;
+				udr-&gt;BuildOptions.erase(udr2-&gt;ud-&gt;id);
+				udr2-&gt;PrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+				udr2-&gt;AllPrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+			}
+		}
+
+		// limit boat constructers from building land defences - but only if something else can build it
+		if( udr-&gt;ud-&gt;speed &gt; 0 &amp;&amp; udr-&gt;ud-&gt;minWaterDepth &gt;= 0 )
+		{
+			set&lt;int&gt; deletion;
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator i=udr-&gt;BuildOptions.begin(); i!=udr-&gt;BuildOptions.end(); i++ )
+			{
+				if( i-&gt;second-&gt;ud-&gt;speed == 0 &amp;&amp; i-&gt;second-&gt;WeaponGuardRange &gt; 0 &amp;&amp; i-&gt;second-&gt;ud-&gt;minWaterDepth &lt; 0 )
+				{
+					bool alternative=false;
+					for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=i-&gt;second-&gt;PrerequisiteOptions.begin(); iP!=i-&gt;second-&gt;PrerequisiteOptions.end(); iP++)
+						if( iP-&gt;second-&gt;ud-&gt;speed &gt; 0 &amp;&amp; !iP-&gt;second-&gt;Disabled &amp;&amp; iP-&gt;second-&gt;ud-&gt;minWaterDepth &lt; 0 )
+							alternative = true;
+					if( alternative )
+						deletion.insert(i-&gt;first);
+				}
+			}
+			for( set&lt;int&gt;::iterator i=deletion.begin(); i!=deletion.end(); i++ )
+			{
+				sRAIUnitDef *udr2 = udr-&gt;BuildOptions.find(*i)-&gt;second;
+//				*l&lt;&lt;&quot;\n  (Special Rule) Defence Build Option Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName&lt;&lt;&quot; -&gt; (&quot;&lt;&lt;udr2-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr2-&gt;ud-&gt;humanName;
+				udr-&gt;BuildOptions.erase(udr2-&gt;ud-&gt;id);
+				udr2-&gt;PrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+				udr2-&gt;AllPrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+			}
+		}
+
+		// limit mobile land constructers from build underwater extractors
+		if( udr-&gt;ud-&gt;movedata != 0 &amp;&amp; !udr-&gt;ud-&gt;canfly &amp;&amp; !udr-&gt;ud-&gt;canhover &amp;&amp; udr-&gt;ud-&gt;minWaterDepth &lt; 0 &amp;&amp; -udr-&gt;ud-&gt;movedata-&gt;depth &gt; G-&gt;TM-&gt;MaxWaterDepth )
+		{
+			set&lt;int&gt; deletion;
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator i=udr-&gt;BuildOptions.begin(); i!=udr-&gt;BuildOptions.end(); i++ )
+				if( -i-&gt;second-&gt;ud-&gt;minWaterDepth &lt; 0 &amp;&amp; i-&gt;second-&gt;ud-&gt;extractsMetal &gt; 0 )
+					deletion.insert(i-&gt;first);
+			for( set&lt;int&gt;::iterator i=deletion.begin(); i!=deletion.end(); i++ )
+			{
+				sRAIUnitDef *udr2 = udr-&gt;BuildOptions.find(*i)-&gt;second;
+//				*l&lt;&lt;&quot;\n  (Special Rule) Extractor Build Option Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName&lt;&lt;&quot; -&gt; (&quot;&lt;&lt;udr2-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr2-&gt;ud-&gt;humanName;
+				udr-&gt;BuildOptions.erase(udr2-&gt;ud-&gt;id);
+				udr2-&gt;PrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+				udr2-&gt;AllPrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+			}
+		}
+	}
+
+	*l&lt;&lt;&quot;\n Updating Unit Limits for Metal/Geo build options ...&quot;;
+	for( int i=0; i&lt;BLMetalL-&gt;UDefSize; i++ )
+		BLMetalL-&gt;UDef[i]-&gt;RUD-&gt;SetULConstructs(0);
+	if( BLMetalL-&gt;UDefSize == 0 &amp;&amp; BLMetal-&gt;UDefSize &gt; 0 )
+		BLMetal-&gt;minUnits = 2;
+	if( BLMetalL-&gt;UDefSize == 0 &amp;&amp; BLEnergyL-&gt;minUnits == 0 &amp;&amp; int(G-&gt;GeoSpot.size()) &gt; 0 )
+		BLEnergyL-&gt;minUnits = 1;
+	for( int i=0; i&lt;BLEnergyL-&gt;UDefSize; i++ )
+		BLEnergyL-&gt;UDef[i]-&gt;RUD-&gt;SetULConstructs(0);
+
+	for(int ib=0; ib&lt;BLSize; ib++ )
+		for(int iu=0; iu&lt;BL[ib]-&gt;UDefSize; iu++)
+			BL[ib]-&gt;UDef[iu]-&gt;udIndex=iu;
+
+	*l&lt;&lt;&quot;\n\n Build List Result ...&quot;;
+	for(int iBL=0; iBL&lt;BLSize; iBL++ )
+	{
+		*l&lt;&lt;&quot;\n  &quot;+BL[iBL]-&gt;Name+&quot; BuildList&quot;;
+		if( BL[iBL]-&gt;UDefSize==0 ||
+			(BL[iBL]-&gt;priority &lt;= 0 &amp;&amp; BL[iBL]!=BLBuilder &amp;&amp; BL[iBL]!=BLEnergyL &amp;&amp; BL[iBL]!=BLEnergy &amp;&amp; BL[iBL]!=BLMetalL
+			 &amp;&amp; BL[iBL]!=BLMetal &amp;&amp; BL[iBL]!=BLEnergyStorage &amp;&amp; BL[iBL]!=BLMetalStorage ) )
+			 *l&lt;&lt;&quot; (disabled)&quot;;
+		*l&lt;&lt;&quot;:  &quot;;
+		for(int iud=0; iud&lt;BL[iBL]-&gt;UDefSize; iud++)
+		{
+			*l&lt;&lt;&quot; &quot;+BL[iBL]-&gt;UDef[iud]-&gt;RUD-&gt;ud-&gt;humanName+&quot;(&quot;;
+			if( BL[iBL]-&gt;UDef[iud]-&gt;RUD-&gt;Disabled )
+				*l&lt;&lt;&quot;disabled&quot;;
+			else
+				*l&lt;&lt;BL[iBL]-&gt;UDef[iud]-&gt;efficiency;
+			*l&lt;&lt;&quot;)&quot;;
+		}
+	}
+	*l&lt;&lt;&quot;\n List of Undefined Units:&quot;;
+	for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end(); iud++ )
+		if( iud-&gt;second.ListSize == 0 )
+			*l&lt;&lt;&quot;  &quot;+iud-&gt;second.ud-&gt;humanName;
+	*l&lt;&lt;&quot;\n&quot;;
+}
+
+cRAIUnitDefHandler::~cRAIUnitDefHandler()
+{
+	for(int i=0; i&lt;BLSize; i++)
+		delete BL[i];
+}
+
+void cRAIUnitDefHandler::BLSwitch(int index1, int index2)
+{
+	sRAIBuildList *pRBL = BL[index1];
+	BL[index1] = BL[index2];
+	BL[index2] = pRBL;
+	BL[index1]-&gt;index=index1;
+	BL[index2]-&gt;index=index2;
+}

Added: trunk/AI/Global/RAI-0.553/UnitDef.h
===================================================================
--- trunk/AI/Global/RAI-0.553/UnitDef.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/UnitDef.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,178 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_UNITDEF_H
+#define RAI_UNITDEF_H
+
+struct sRAIUnitDefBL;
+struct sRAIUnitDef;
+struct sRAIBuildList;
+class cRAIUnitDefHandler;
+
+//#include &quot;LogFile.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &lt;map&gt;
+//#include &lt;set&gt;
+#include &quot;Global.h&quot;
+
+const int TASK_NONE = 1; // uses default combat behaviors
+const int TASK_CONSTRUCT = 2;
+const int TASK_ASSAULT = 3;
+const int TASK_SCOUT = 4;
+const int TASK_SUICIDE = 5;
+const int TASK_SUPPORT = 6;
+const int TASK_TRANSPORT = 7;
+
+struct sWeaponEfficiency
+{
+	float BestRange;	// Best range for fighting this enemy
+	float rate;			// unused
+};
+
+struct sRAIPrerequisite
+{
+	sRAIPrerequisite(sRAIUnitDef* RAIud)
+	{
+		udr=RAIud;
+		buildLine=0;
+	};
+	sRAIUnitDef *udr;
+	int buildLine;		// This refers to how many other builders must be build to reach this option
+};
+
+struct sRAIUnitDefBL
+{
+	sRAIUnitDefBL(sRAIUnitDef* RAIud, sRAIBuildList* BuildList, float Efficiency=-1.0, int Task=-1);
+	~sRAIUnitDefBL();
+
+	sRAIUnitDef* RUD;
+	sRAIBuildList* RBL;
+
+	int udIndex;
+//	int listIndex;
+	float efficiency;
+	int task;
+};
+
+struct sRAIUnitDef
+{
+	sRAIUnitDef(const UnitDef *unitdef, IAICallback* callback, cRAIGlobal* G, float EnergyToMetalRatio, cLogFile *l, float MaxFiringRange=3000.0);
+	int GetPrerequisite(); // returns UnitDef ID
+	int GetPrerequisiteNewBuilder();
+	void SetUnitLimit(int num);
+	void SetULConstructs(int num); // sets the number of units that can be built excluding 'UnitsActive' &amp;&amp; 'UnitConstructsActive'
+	sRAIUnitDefBL* GetBuildList(string Name);
+
+	sRAIUnitDefBL *List[35];	// possible lists a unit may be assigned to
+	int ListSize;				// 'List' array size in use
+	int UnitLimit[2];			// [0]: virtual unit limit, max units RAI is willing to build, ud-&gt;maxThisUnit is considered  [1]: remaining geospots/metalspots, basicly a construction unit limit
+	bool HighEnergyDemand;		// This unit requires an unbalanced amount of energy to remain active, EX: metal makers, moho-mines in XTA
+	float MetalDifference;		// How much metal will this produce/cost when active
+	float EnergyDifference;		// How much energy will this produce/cost when active
+	float MetalPCost;			// How much metal production is needed to consider building this
+	float EnergyPCost;			// How much energy production is needed to consider building this
+	float CloakCostMax;			// = to moving cost for units that can move, = to normal cost for units that can not
+	int WeaponCostMax;			// energy drain per second if firing all weapons continuously
+	const WeaponDef *DGun;		// valid if ud-&gt;canDGun=true &amp;&amp; a dgun was found, otherwise 0
+	const WeaponDef *SWeapon;	// valid if a weapon is iW-&gt;def-&gt;stockpile &amp;&amp; iW-&gt;def-&gt;manualfire, otherwise 0
+	map&lt;int,sRAIUnitDef*&gt; BuildOptions;					// key value = UnitDef ID, You could think of this as an improved version of UnitDef-&gt;buildOptions
+	map&lt;int,sRAIUnitDef*&gt; PrerequisiteOptions;			// key value = UnitDef ID, a list of the types of units can build this unit
+	map&lt;int,sRAIPrerequisite&gt; AllPrerequisiteOptions;	// key value = UnitDef ID, a list of anything that can build this unit, or somthing that can build a unit that can build this unit, or so on..
+//	map&lt;int,sWeaponEfficiency&gt; WeaponEff;				// key value = Enemy UnitDef ID
+	sWeaponEfficiency WeaponLandEff;	// used if enemy unitdef is unknown
+	sWeaponEfficiency WeaponAirEff;		// used if enemy unitdef is unknown
+	sWeaponEfficiency WeaponSeaEff;		// used if enemy unitdef is unknown
+	float WeaponGuardRange;				// Base Defences only, distance for nearby structures to be considered 'guarded'
+	set&lt;int&gt; WeaponDamageType;			// types of armors that this unit can damage
+//	map&lt;int,sRAIPrerequisite&gt; AllBuildOptions;			// key value = UnitDef ID, complete list of anything that this unit can build
+	set&lt;int&gt; mb;				// key = MapBody index, list of map bodys this unit can be built at
+	const UnitDef* ud;			// Always valid
+
+	void CheckUnitLimit();		// called after 'UnitsActive' or 'UnitConstructs' is modified, updates 'RBUnitLimit'
+	void CheckBuildOptions();	// called after 'RBUnitLimit','RBCost','RBPrereq','Disabled' or 'UnitsActive' is modified, updates 'CanBuild','CanBeBuilt','RBPrereq', and 'HasPrerequisite' for all 'BuildOptions'
+
+	set&lt;int&gt; UnitsActive;			// existing units of this type, used to determine active build options
+	set&lt;int&gt; UnitConstructsActive;	// existing constructions of this type
+	int UnitConstructs;		// units of this type being built, used to help determine active build options
+	bool CanBuild;			// 'UnitsActive' is &gt; 0
+	bool CanBeBuilt;		// reverse result of (Disabled, RBUnitLimit, RBCost, RBPrereq) - in other words, RAI is willing to build this
+	bool HasPrerequisite;	// A unit in 'PrerequisiteOptions' has 'CanBuild' enabled
+	bool Disabled;			// RAI will not build this unit, however it may still use the unit if gained through given,captured,resurrected
+	bool RBUnitLimit;		// (R)estrict (B)uilding: the Max of this Unit has been built
+	bool RBCost;			// (R)estrict (B)uilding: the Cost is too high to build right now
+	bool RBPrereq;			// (R)estrict (B)uilding: No buildline of units in &quot;AllPrerequisiteOptions&quot; have 'CanBuild or CanBeBuilt' enabled
+
+	bool IsBomber;
+	bool IsNano();
+	bool IsCategory(string category); // only used during initialization
+private:
+	bool CheckWeaponType(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator udw, int type); // type = 1-3 (land,air,sea), only used during initialization
+	void SetBestWeaponEff(sWeaponEfficiency *we, int type, float MaxFiringRange); // only used during initialization
+};
+
+struct sRAIBuildList
+{
+	sRAIBuildList(int MaxDefSize, cRAIUnitDefHandler *UDRHandler);
+	~sRAIBuildList();
+	void Disable(int udIndex, bool value=true);
+	void UDefSwitch(int index1, int index2);
+
+	string Name;
+	sRAIUnitDefBL **UDef;	// Possible Units to Build on this list, index is valid if &lt; UDefSize
+	int UDefActive;			// 'UDef' indexes below this value have 'CanBeBuilt=true', for later entries 'CanBeBuilt=false'
+	int UDefActiveTemp;		// Same as UDefActive, but may be moddifed to temperaryly disable some units within 'UDefActive'
+	int UDefSize;
+	int priority;			// Amount to build compared to other build lists, if this = -1 then these units are only built from special demand needs
+	int minUnits;			// Build at least this many before building anything else, however build demands will take presidence.  Also, this used to rate the importantance of the buildlist
+	float minEfficiency;	// The minimal efficiency a unit needs to be accepted for use in this build list.  Note: 1.0 = average value (default)
+							// Remember that it is not uncommon for there to be a unit this is bad at everything, such units are assigned to the task they are least bad at in respect to MinEfficiency
+	int unitsActive;		// The ammount of units build from this list, used to keep track of the ratio of build options
+
+	cRAIUnitDefHandler *UDR;
+	int index;
+};
+
+class cRAIUnitDefHandler
+{
+public:
+	cRAIUnitDefHandler(IAICallback* callback, cRAIGlobal* G, cLogFile *log);
+	~cRAIUnitDefHandler();
+
+	map&lt;int,sRAIUnitDef&gt; UDR;	// complete record of all unit definitions found, key value = Unit Def ID
+	sRAIBuildList *BL[35];
+	int BLSize;
+	int BLActive;
+	void BLSwitch(int index1, int index2);
+
+	// special buildlists
+	sRAIBuildList *BLBuilder;
+	sRAIBuildList *BLEnergy;
+	sRAIBuildList *BLEnergyL;
+	sRAIBuildList *BLMetal;
+	sRAIBuildList *BLMetalL;
+	sRAIBuildList *BLEnergyStorage;
+	sRAIBuildList *BLMetalStorage;
+	sRAIBuildList *BLMobileRadar;
+	sRAIBuildList *BLAirBase;
+
+	float EnergyToMetalRatio;
+	float AverageConstructSpeed;
+private:
+	struct sBuildLine
+	{
+		sBuildLine(int id, int bl)
+		{
+			ID=id;
+			BL=bl;
+		};
+		int ID;	// UnitDef ID
+		int BL;	// BuildLine, the amount of prerequisites that need to be build to reach this option
+	};
+	cLogFile *l;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/UnitManager.cpp
===================================================================
--- trunk/AI/Global/RAI-0.553/UnitManager.cpp	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/UnitManager.cpp	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,503 @@
+#include &quot;UnitManager.h&quot;
+//#include &quot;LogFile.h&quot;
+
+sRAIGroup::sRAIGroup(int Index)
+{
+	index=Index;
+}
+
+sRAIGroup::~sRAIGroup()
+{
+	for( map&lt;int,EnemyInfo*&gt;::iterator i=Enemies.begin(); i!=Enemies.end(); i++ )
+	{
+		i-&gt;second-&gt;AttackGroups.erase(this);
+	}
+}
+
+cUnitManager::cUnitManager(IAICallback* callback, cRAI* Global)
+{
+	cb=callback;
+	G=Global;
+	l=G-&gt;l;
+	GroupSize=0;
+	AttackOrders=false;
+	SLSize=0;
+}
+
+void cUnitManager::UnitFinished(int unit,UnitInfo *U)
+{
+//	*l&lt;&lt;&quot; (t=&quot;&lt;&lt;U-&gt;pBOL-&gt;task&lt;&lt;&quot;)&quot;;
+	switch( U-&gt;pBOL-&gt;task )
+	{
+	case TASK_CONSTRUCT:
+		G-&gt;Build-&gt;UBuilderFinished(unit,U);
+		break;
+	case TASK_ASSAULT:
+		{
+			UAssault.insert(cRAI::iupPair(unit,U));
+			UpdateGroupSize();
+			Assign(unit,U);
+			if( ActiveAttackOrders() )
+				SendAttackGroups();
+		}
+		break;
+	case TASK_SCOUT:
+		{
+			UScout.insert(isPair(unit,sScoutUnitInfo()));
+		}
+		break;
+	case TASK_SUICIDE:
+		{
+			USuicide.insert(cRAI::iupPair(unit,U));
+		}
+		break;
+	case TASK_SUPPORT:
+		{
+			USupport.insert(unit);
+		}
+		break;
+	case TASK_TRANSPORT:
+		{
+			UTrans.insert(itPair(unit,sTransportUnitInfo(U-&gt;ud)));
+		}
+		break;
+	}
+}
+
+void cUnitManager::UnitDestroyed(int unit,UnitInfo *U)
+{
+//	*l&lt;&lt;&quot; (t=&quot;&lt;&lt;U-&gt;pBOL-&gt;task&lt;&lt;&quot;)&quot;;
+	switch( U-&gt;pBOL-&gt;task )
+	{
+	case TASK_CONSTRUCT:
+		G-&gt;Build-&gt;UBuilderDestroyed(unit,U);
+		break;
+	case TASK_ASSAULT:
+		{
+			UAssault.erase(unit);
+			UpdateGroupSize();
+
+			U-&gt;Group-&gt;Units.erase(unit);
+			if( int(U-&gt;Group-&gt;Units.size()) == 0 )
+			{
+				GroupSize--;
+				sRAIGroup* RGroup=Group[U-&gt;Group-&gt;index];
+				Group[U-&gt;Group-&gt;index]=Group[GroupSize];
+				Group[U-&gt;Group-&gt;index]-&gt;index = U-&gt;Group-&gt;index;
+				delete RGroup;
+			}
+		}
+		break;
+	case TASK_SCOUT:
+		{
+			UScout.erase(unit);
+		}
+		break;
+	case TASK_SUICIDE:
+		{
+			USuicide.erase(unit);
+		}
+		break;
+	case TASK_SUPPORT:
+		{
+			USupport.erase(unit);
+		}
+		break;
+	case TASK_TRANSPORT:
+		{
+			UTrans.erase(unit);
+		}
+		break;
+	}
+}
+
+void cUnitManager::UnitIdle(int unit,UnitInfo *U)
+{
+//	*l&lt;&lt;&quot; (t=&quot;&lt;&lt;U-&gt;pBOL-&gt;task&lt;&lt;&quot;)&quot;;
+	switch( U-&gt;pBOL-&gt;task )
+	{
+	case TASK_CONSTRUCT:
+		G-&gt;Build-&gt;UBuilderIdle(unit,U);
+		break;
+	case TASK_ASSAULT:
+		{
+			if( int(U-&gt;Group-&gt;Enemies.size()) &gt; 0 )
+			{
+				U-&gt;bInCombat = true;
+				U-&gt;commandTimeOut = 0;
+				return;
+			}
+			if( G-&gt;UDH-&gt;BLMobileRadar-&gt;UDefActive == 0 &amp;&amp; G-&gt;Enemies.size() &lt; 15 &amp;&amp; int(G-&gt;Enemies.size()) &lt;= int(UAssault.size())/2 )
+			{
+				int num=0;
+				for( map&lt;int,UnitInfo*&gt;::iterator iU = U-&gt;Group-&gt;Units.begin(); iU != U-&gt;Group-&gt;Units.end(); iU++ )
+				{
+					if( cb-&gt;GetUnitPos(iU-&gt;first).distance2D(U-&gt;Group-&gt;ScoutPoint) &lt; 350.0f )
+						num++;
+				}
+				if( num &gt;= 1+int(U-&gt;Group-&gt;Units.size())/2 )
+				{
+					U-&gt;Group-&gt;ScoutPoint = G-&gt;GetRandomPosition(U-&gt;mapBody);
+					for( map&lt;int,UnitInfo*&gt;::iterator iU = U-&gt;Group-&gt;Units.begin(); iU != U-&gt;Group-&gt;Units.end(); iU++ )
+						iU-&gt;second-&gt;commandTimeOut = 0;
+				}
+
+				Command c;
+				if( cb-&gt;GetUnitPos(unit).distance2D(U-&gt;Group-&gt;ScoutPoint) &lt; 350.0f )
+				{
+					c.id = CMD_WAIT;
+					U-&gt;commandTimeOut = cb-&gt;GetCurrentFrame() + 300;
+					//c.timeOut = cb-&gt;GetCurrentFrame() + 300;
+
+				}
+				else
+				{
+					c.id = CMD_MOVE;
+					c.params.push_back(U-&gt;Group-&gt;ScoutPoint.x);
+					c.params.push_back(U-&gt;Group-&gt;ScoutPoint.y);
+					c.params.push_back(U-&gt;Group-&gt;ScoutPoint.z);
+				}
+				cb-&gt;GiveOrder(unit, &amp;c);
+			}
+			else
+			{
+				Command c;
+				if( cb-&gt;GetUnitPos(unit).distance2D(U-&gt;Group-&gt;RallyPoint) &lt; 400 )
+				{
+					c.id = CMD_WAIT;
+					U-&gt;commandTimeOut = cb-&gt;GetCurrentFrame() + 900;
+					//c.timeOut = cb-&gt;GetCurrentFrame() + 300;
+
+				}
+				else
+				{
+					c.id = CMD_MOVE;
+					c.params.push_back(U-&gt;Group-&gt;RallyPoint.x);
+					c.params.push_back(U-&gt;Group-&gt;RallyPoint.y);
+					c.params.push_back(U-&gt;Group-&gt;RallyPoint.z);
+				}
+				cb-&gt;GiveOrder(unit, &amp;c);
+			}
+		}
+		break;
+	case TASK_SCOUT:
+		{
+			sScoutUnitInfo *S = &amp;UScout.find(unit)-&gt;second;
+			if( S-&gt;ScoutLocAssigned )
+			{
+				float3 Pos=cb-&gt;GetUnitPos(unit);
+				const UnitDef* ud = cb-&gt;GetUnitDef(unit);
+
+				if( Pos.x - S-&gt;SL-&gt;location.x &gt; 100 || Pos.x - S-&gt;SL-&gt;location.x &lt; -100 || Pos.z - S-&gt;SL-&gt;location.z &gt; 100 || Pos.z - S-&gt;SL-&gt;location.z &lt; -100 )
+				{
+					Command c;
+					c.id = CMD_MOVE;
+					c.params.push_back(S-&gt;SL-&gt;location.x);
+					c.params.push_back(S-&gt;SL-&gt;location.y);
+					c.params.push_back(S-&gt;SL-&gt;location.z);
+					cb-&gt;GiveOrder(unit, &amp;c);
+				}
+				return;
+			}
+			if( SLSize&gt;0 )
+			{
+				S-&gt;SL= SL[0];
+				SL[0]=SL[--SLSize];
+				UnitIdle(unit,U);
+				return;
+			}
+			Command c;
+			c.id = CMD_MOVE;
+			float3 movePos=G-&gt;GetRandomPosition(U-&gt;mapBody);
+			c.params.push_back(movePos.x);
+			c.params.push_back(movePos.y);
+			c.params.push_back(movePos.z);
+			cb-&gt;GiveOrder(unit, &amp;c);
+		}
+		break;
+	case TASK_SUICIDE:
+		{
+			Command c;
+			if( int(G-&gt;Enemies.size()) &gt; 0 &amp;&amp; G-&gt;CombatM-&gt;GetClosestEnemy(cb-&gt;GetUnitPos(unit), U) &gt;= 0 )
+			{
+				int iRan=rand()%int(G-&gt;Enemies.size());
+				map&lt;int,EnemyInfo&gt;::iterator iE=G-&gt;Enemies.begin();
+				for( int i=0; i&lt;iRan; i++,iE++ ) {}
+
+				U-&gt;bInCombat=true;
+				U-&gt;enemyID=iE-&gt;first;
+				U-&gt;E = &amp;iE-&gt;second;
+				U-&gt;enemyEff = G-&gt;CombatM-&gt;CanAttack(U,U-&gt;E,G-&gt;CombatM-&gt;GetEnemyPosition(U-&gt;enemyID,U-&gt;E));
+
+				c.id = CMD_ATTACK;
+				c.params.push_back(iE-&gt;first);
+				cb-&gt;GiveOrder(unit,&amp;c);
+				return;
+			}
+
+			c.id = CMD_MOVE;
+			float3 movePos=G-&gt;GetRandomPosition(U-&gt;mapBody);
+			c.params.push_back(movePos.x);
+			c.params.push_back(movePos.y);
+			c.params.push_back(movePos.z);
+			cb-&gt;GiveOrder(unit, &amp;c);
+		}
+		break;
+	case TASK_SUPPORT:
+		{
+			Command c;
+			c.id = CMD_WAIT;
+			cb-&gt;GiveOrder(unit, &amp;c);
+		}
+		break;
+	case TASK_TRANSPORT:
+		{
+			sTransportUnitInfo *T = &amp;UTrans.find(unit)-&gt;second;
+			if( T-&gt;AssistID == -1 )
+			{
+				Command c;
+				c.id = CMD_WAIT;
+				cb-&gt;GiveOrder(unit, &amp;c);
+
+				U-&gt;commandTimeOut=cb-&gt;GetCurrentFrame()+450;
+			}
+			else
+			{
+
+			}
+		}
+		break;
+	}
+}
+
+void cUnitManager::EnemyEnterLOS(int enemy,EnemyInfo *E)
+{
+	EnemyEnterRadar(enemy,E);
+}
+
+void cUnitManager::EnemyEnterRadar(int enemy,EnemyInfo *E)
+{
+	if( ActiveAttackOrders() )
+		SendAttackGroups();
+}
+
+bool cUnitManager::UnitMoveFailed(int unit, UnitInfo *U)
+{
+	if( int(UTrans.size()) == 0 )
+		return false;
+	for( map&lt;int,sTransportUnitInfo&gt;::iterator iT=UTrans.begin(); iT!=UTrans.end(); iT++ )
+	{
+		if( iT-&gt;second.AssistID == -1 &amp;&amp; iT-&gt;second.ud-&gt;transportMass &gt;= U-&gt;ud-&gt;mass )
+		{
+			iT-&gt;second.AssistID=unit;
+			//return true;
+		}
+	}
+	return false;
+}
+
+void cUnitManager::UpdateGroupSize()
+{
+	MaxGroupMSize=5+int(UAssault.size())/4;
+}
+
+bool cUnitManager::ActiveAttackOrders()
+{
+	if( int(G-&gt;Enemies.size()) == 0 )
+	{
+//		if( AttackOrders ) cb-&gt;SendTextMsg(&quot;Defending&quot;,5);
+		AttackOrders=false;
+	}
+	else if( int(UAssault.size()) &gt;= 66 || (int(UAssault.size()) &gt;= 6 &amp;&amp; int(UAssault.size()) &gt; 0.8*G-&gt;Enemies.size()) || G-&gt;UDH-&gt;BLBuilder-&gt;UDefActive == 0 )
+	{
+//		if( !AttackOrders ) cb-&gt;SendTextMsg(&quot;Attacking&quot;,5);
+		AttackOrders=true;
+	}
+	else if( int(UAssault.size()) &lt;= 4 || (int(UAssault.size()) &lt;= 44 &amp;&amp; int(UAssault.size()) &lt; 0.533*G-&gt;Enemies.size()) )
+	{
+		if( AttackOrders )
+		{
+//			cb-&gt;SendTextMsg(&quot;Defending&quot;,5);
+			AttackOrders=false;
+			for( int i=0; i&lt;GroupSize; i++ ) // TEMP
+			{
+				set&lt;int&gt; del;
+				for( map&lt;int,EnemyInfo*&gt;::iterator iE = Group[i]-&gt;Enemies.begin(); iE != Group[i]-&gt;Enemies.end(); iE++ )
+				{
+					if( iE-&gt;second-&gt;baseThreatID == -1 )
+					{
+						del.insert(iE-&gt;first);
+					}
+				}
+				while( int(del.size()) &gt; 0 )
+				{
+					GroupRemoveEnemy(*del.begin(),Group[i]-&gt;Enemies.find(*del.begin())-&gt;second,Group[i]);
+					del.erase(*del.begin());
+				}
+			}
+		}
+	}
+
+	return AttackOrders;
+}
+
+void cUnitManager::GroupAddUnit(int unit, UnitInfo* U, sRAIGroup* Gr)
+{
+	Gr-&gt;Units.insert(cRAI::iupPair(unit,U));
+	U-&gt;Group = Gr;
+	if( int(Gr-&gt;Enemies.size()) &gt; 0 )
+		U-&gt;bInCombat = true;
+}
+
+void cUnitManager::GroupAddEnemy(int enemy, EnemyInfo *E, sRAIGroup* Gr)
+{
+	if( !G-&gt;ValidateUnitList(&amp;Gr-&gt;Units) )
+		return;
+
+	Gr-&gt;Enemies.insert(cRAI::iepPair(enemy,E));
+	E-&gt;AttackGroups.insert(ggPair(Gr,Gr));
+	if( Gr-&gt;Enemies.size() == 1 )
+	{
+		for( map&lt;int,UnitInfo*&gt;::iterator iU = Gr-&gt;Units.begin(); iU != Gr-&gt;Units.end(); iU++ )
+		{
+			iU-&gt;second-&gt;bInCombat=true;
+			if( !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{
+				Command c;
+				c.id=CMD_STOP;
+				cb-&gt;GiveOrder(iU-&gt;first, &amp;c);
+			}
+		}
+	}
+}
+
+void cUnitManager::GroupRemoveEnemy(int enemy, EnemyInfo *E, sRAIGroup* Gr)
+{
+	if( !G-&gt;ValidateUnitList(&amp;Gr-&gt;Units) )
+		return;
+
+	Gr-&gt;Enemies.erase(enemy);
+	E-&gt;AttackGroups.erase(Gr);
+	for( map&lt;int,UnitInfo*&gt;::iterator iU = Gr-&gt;Units.begin(); iU != Gr-&gt;Units.end(); iU++ )
+	{
+		if( iU-&gt;second-&gt;enemyID == enemy )
+		{
+			iU-&gt;second-&gt;enemyID = -1;
+			if( !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+			{
+				iU-&gt;second-&gt;commandTimeOut=1;
+			}
+		}
+	}
+	if( int(Gr-&gt;Enemies.size()) == 0 &amp;&amp; int(G-&gt;EThreat.size()) == 0 &amp;&amp; !ActiveAttackOrders() )
+	{
+		GroupResetRallyPoint(Gr);
+		Gr-&gt;ScoutPoint = G-&gt;GetRandomPosition(Gr-&gt;Units.begin()-&gt;second-&gt;mapBody);
+	}
+}
+
+void cUnitManager::GroupResetRallyPoint(sRAIGroup* Gr)
+{
+	float3 GPos = cb-&gt;GetUnitPos(Gr-&gt;Units.begin()-&gt;first);
+	UnitInfo* GU = Gr-&gt;Units.begin()-&gt;second;
+	int iBest=-1;
+	UnitInfo* uBest;
+
+	G-&gt;ValidateUnitList(&amp;G-&gt;UImmobile);
+	for(map&lt;int,UnitInfo*&gt;::iterator iU=G-&gt;UImmobile.begin(); iU!=G-&gt;UImmobile.end(); iU++)
+	{
+		if( G-&gt;TM-&gt;CanMoveToPos(GU-&gt;mapBody,cb-&gt;GetUnitPos(iU-&gt;first)) &amp;&amp; GPos.distance2D(cb-&gt;GetUnitPos(iU-&gt;first)) &lt; GPos.distance2D(cb-&gt;GetUnitPos(iBest)) )
+		{
+			iBest = iU-&gt;first;
+			uBest = iU-&gt;second;
+		}
+	}
+
+	if( iBest != -1 )
+		Gr-&gt;RallyPoint = cb-&gt;GetUnitPos(iBest);
+	else
+		Gr-&gt;RallyPoint = GPos;
+
+//	G-&gt;DebugDrawShape(Gr-&gt;RallyPoint,100.0f,50,0,50,900);
+
+	if( Gr-&gt;RallyPoint.x &lt; 8*cb-&gt;GetMapWidth() - Gr-&gt;RallyPoint.x )
+		Gr-&gt;RallyPoint.x -= 300;
+	else
+		Gr-&gt;RallyPoint.x += 300;
+	if( Gr-&gt;RallyPoint.z &lt; 8*cb-&gt;GetMapHeight() - Gr-&gt;RallyPoint.z )
+		Gr-&gt;RallyPoint.z -= 300;
+	else
+		Gr-&gt;RallyPoint.z += 300;
+
+	Gr-&gt;RallyPoint.x += -250.0f + rand()%501;
+	Gr-&gt;RallyPoint.z += -250.0f + rand()%501;
+	G-&gt;CorrectPosition(&amp;Gr-&gt;RallyPoint);
+
+//	G-&gt;DebugDrawShape(Gr-&gt;RallyPoint,100.0f,25,0,50,900);
+
+	float3 pos = cb-&gt;ClosestBuildSite(GU-&gt;ud,Gr-&gt;RallyPoint,800,15);
+	if( pos.x &lt;= 0 &amp;&amp; pos.y &lt;= 0 &amp;&amp; pos.z &lt;= 0 )
+		pos = cb-&gt;ClosestBuildSite(GU-&gt;ud,Gr-&gt;RallyPoint,800,3);
+	if( pos.x &lt;= 0 &amp;&amp; pos.y &lt;= 0 &amp;&amp; pos.z &lt;= 0 )
+		Gr-&gt;RallyPoint = GPos;
+	else
+		Gr-&gt;RallyPoint = pos;
+
+//	G-&gt;DebugDrawShape(Gr-&gt;RallyPoint,100.0f,5,0,50,900);
+}
+
+void cUnitManager::Assign(int unit,UnitInfo *U)
+{
+	set&lt;int&gt; Grs;
+	for( int i=0; i&lt;GroupSize; i++ )
+	{
+		if( U-&gt;mapBody == Group[i]-&gt;Units.begin()-&gt;second-&gt;mapBody &amp;&amp;
+			U-&gt;ud-&gt;canLoopbackAttack == Group[i]-&gt;Units.begin()-&gt;second-&gt;udr-&gt;ud-&gt;canLoopbackAttack &amp;&amp;
+			int(Group[i]-&gt;Units.size()) &lt; MaxGroupMSize )
+		{
+			Grs.insert(i);
+			for(map&lt;int,UnitInfo*&gt;::iterator GM=Group[i]-&gt;Units.begin(); GM!=Group[i]-&gt;Units.end(); GM++)
+			{
+				sRAIUnitDef* udr = GM-&gt;second-&gt;udr;
+				if( U-&gt;ud-&gt;speed &gt; 1.5*udr-&gt;ud-&gt;speed || 1.5*U-&gt;ud-&gt;speed &lt; udr-&gt;ud-&gt;speed )
+				{
+					Grs.erase(i);
+					break;
+				}
+			}
+		}
+	}
+
+	if( GroupSize == 25 &amp;&amp; int(Grs.size()) == 0 )
+	{
+		*l&lt;&lt;&quot;\nWARNING: Maximum number of groups reached&quot;;
+		Grs.insert(24);
+	}
+
+	if( int(Grs.size()) &gt; 0 )
+	{
+		GroupAddUnit(unit,U,Group[*Grs.begin()]);
+	}
+	else
+	{
+		Group[GroupSize] = new sRAIGroup(GroupSize);
+		sRAIGroup* Gr = Group[GroupSize];
+		GroupSize++;
+
+		GroupAddUnit(unit,U,Gr);
+		Gr-&gt;ScoutPoint = G-&gt;GetRandomPosition(U-&gt;mapBody);
+		GroupResetRallyPoint(Gr);
+	}
+}
+
+void cUnitManager::SendAttackGroups()
+{
+	for( int i=0; i&lt;GroupSize; i++ )
+	{
+		if( int(Group[i]-&gt;Enemies.size()) == 0 &amp;&amp; (int(Group[i]-&gt;Units.size()) &gt;= 4 || G-&gt;UDH-&gt;BLBuilder-&gt;UDefActive == 0) )
+		{
+			int enemyID = G-&gt;CombatM-&gt;GetClosestEnemy(cb-&gt;GetUnitPos(Group[i]-&gt;Units.begin()-&gt;first),Group[i]-&gt;Units.begin()-&gt;second);
+//			EnemyInfo* E = Group[i]-&gt;Units.begin()-&gt;second-&gt;E;
+		}
+	}
+}

Added: trunk/AI/Global/RAI-0.553/UnitManager.h
===================================================================
--- trunk/AI/Global/RAI-0.553/UnitManager.h	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/UnitManager.h	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,104 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_UNIT_MANAGER_H
+#define RAI_UNIT_MANAGER_H
+
+struct sRAIGroup;
+class cUnitManager;
+
+#include &quot;RAI.h&quot;
+//#include &quot;LogFile.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+//#include &lt;map&gt;
+
+struct sRAIGroup
+{
+	sRAIGroup(int Index);
+	~sRAIGroup();
+
+	int index;
+	map&lt;int,UnitInfo*&gt; Units;
+	map&lt;int,EnemyInfo*&gt; Enemies;
+
+	float3 RallyPoint;
+	float3 ScoutPoint;
+//	UnitInfo* Radar;
+//	UnitInfo* Jammer;
+//	UnitInfo* AntiMis;
+//	UnitInfo* Engineer;
+};
+
+class cUnitManager
+{
+public:
+	cUnitManager(IAICallback* callback, cRAI* Global);
+	~cUnitManager() {};
+
+	void UnitFinished(int unit,UnitInfo *U);
+	void UnitDestroyed(int unit,UnitInfo *U);
+	void UnitIdle(int unit,UnitInfo *U);
+	void EnemyEnterLOS(int enemy,EnemyInfo *E);
+	void EnemyEnterRadar(int enemy,EnemyInfo *E);
+	bool UnitMoveFailed(int unit,UnitInfo *U);
+	void UpdateGroupSize();
+	bool ActiveAttackOrders();
+	void GroupAddUnit(int unit, UnitInfo* U, sRAIGroup* Gr);
+	void GroupAddEnemy(int enemy, EnemyInfo *E, sRAIGroup* Gr);
+	void GroupRemoveEnemy(int enemy, EnemyInfo *E, sRAIGroup* Gr);
+	void GroupResetRallyPoint(sRAIGroup* Gr);
+
+//	bool AssaultScouts;
+
+	sRAIGroup* Group[25];
+//	sRAIGroup* Commander;
+	int GroupSize;
+private:
+
+	bool AttackOrders;
+	typedef pair&lt;sRAIGroup*,sRAIGroup*&gt; ggPair;
+
+	int MaxGroupMSize;
+	void Assign(int unit,UnitInfo *U);
+	void SendAttackGroups();
+
+	map&lt;int,UnitInfo*&gt; UAssault;	// key = unit id
+	map&lt;int,UnitInfo*&gt; USuicide;
+	set&lt;int&gt; USupport;
+
+	struct sTransportUnitInfo
+	{
+		sTransportUnitInfo(const UnitDef *unitdef) { ud=unitdef; AssistID=-1; };
+		const UnitDef *ud;
+		int AssistID;
+	};
+	typedef pair&lt;int,sTransportUnitInfo&gt; itPair;
+	map&lt;int,sTransportUnitInfo&gt; UTrans;
+
+	struct sScoutLocation
+	{
+		int ScoutID;
+		float3 location;
+	};
+	sScoutLocation *SL[20];
+	int SLSize;
+	struct sScoutUnitInfo
+	{
+		sScoutUnitInfo() { ScoutLocAssigned=false; };
+		sScoutLocation *SL;
+		bool ScoutLocAssigned;
+	};
+	typedef pair&lt;int,sScoutUnitInfo&gt; isPair;
+	map&lt;int,sScoutUnitInfo&gt; UScout;
+
+	IAICallback *cb;
+	cRAI* G;
+	cLogFile *l;
+};
+
+#endif

Added: trunk/AI/Global/RAI-0.553/VS2005/RAI.sln
===================================================================
--- trunk/AI/Global/RAI-0.553/VS2005/RAI.sln	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/VS2005/RAI.sln	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,19 @@
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RAI&quot;, &quot;RAI.vcproj&quot;, &quot;{A3E41465-AFF9-484D-A4D4-694DBAE7285D}&quot;
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{A3E41465-AFF9-484D-A4D4-694DBAE7285D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A3E41465-AFF9-484D-A4D4-694DBAE7285D}.Debug|Win32.Build.0 = Debug|Win32
+		{A3E41465-AFF9-484D-A4D4-694DBAE7285D}.Release|Win32.ActiveCfg = Release|Win32
+		{A3E41465-AFF9-484D-A4D4-694DBAE7285D}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal

Added: trunk/AI/Global/RAI-0.553/VS2005/RAI.vcproj
===================================================================
--- trunk/AI/Global/RAI-0.553/VS2005/RAI.vcproj	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/VS2005/RAI.vcproj	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,332 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
+&lt;VisualStudioProject
+	ProjectType=&quot;Visual C++&quot;
+	Version=&quot;8.00&quot;
+	Name=&quot;RAI&quot;
+	ProjectGUID=&quot;{A3E41465-AFF9-484D-A4D4-694DBAE7285D}&quot;
+	RootNamespace=&quot;NewAI&quot;
+	Keyword=&quot;Win32Proj&quot;
+	&gt;
+	&lt;Platforms&gt;
+		&lt;Platform
+			Name=&quot;Win32&quot;
+		/&gt;
+	&lt;/Platforms&gt;
+	&lt;ToolFiles&gt;
+	&lt;/ToolFiles&gt;
+	&lt;Configurations&gt;
+		&lt;Configuration
+			Name=&quot;Debug|Win32&quot;
+			OutputDirectory=&quot;$(ConfigurationName)&quot;
+			IntermediateDirectory=&quot;$(ConfigurationName)&quot;
+			ConfigurationType=&quot;2&quot;
+			CharacterSet=&quot;2&quot;
+			WholeProgramOptimization=&quot;1&quot;
+			&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				Optimization=&quot;0&quot;
+				FavorSizeOrSpeed=&quot;0&quot;
+				AdditionalIncludeDirectories=&quot;../../../../rts;../../../../rts/system&quot;
+				PreprocessorDefinitions=&quot;WIN32;_DEBUG;_WINDOWS;_USRDLL;NEWAI_EXPORTS&quot;
+				MinimalRebuild=&quot;true&quot;
+				BasicRuntimeChecks=&quot;3&quot;
+				RuntimeLibrary=&quot;3&quot;
+				UsePrecompiledHeader=&quot;0&quot;
+				WarningLevel=&quot;3&quot;
+				Detect64BitPortabilityProblems=&quot;true&quot;
+				DebugInformationFormat=&quot;4&quot;
+				DisableSpecificWarnings=&quot;4244;4996;4800;4018;4267&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedResourceCompilerTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				Version=&quot;0.55&quot;
+				LinkIncremental=&quot;2&quot;
+				GenerateDebugInformation=&quot;true&quot;
+				SubSystem=&quot;2&quot;
+				TargetMachine=&quot;1&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCALinkTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCManifestTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCXDCMakeTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCBscMakeTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCFxCopTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCAppVerifierTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCWebDeploymentTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;
+			/&gt;
+		&lt;/Configuration&gt;
+		&lt;Configuration
+			Name=&quot;Release|Win32&quot;
+			OutputDirectory=&quot;$(ConfigurationName)&quot;
+			IntermediateDirectory=&quot;$(ConfigurationName)&quot;
+			ConfigurationType=&quot;2&quot;
+			CharacterSet=&quot;1&quot;
+			WholeProgramOptimization=&quot;1&quot;
+			&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				FavorSizeOrSpeed=&quot;1&quot;
+				AdditionalIncludeDirectories=&quot;../../../../rts;../../../../rts/system;../../../../../mingwlibs/include;$(NOINHERIT)&quot;
+				PreprocessorDefinitions=&quot;WIN32;NDEBUG;_WINDOWS;_USRDLL;NEWAI_EXPORTS&quot;
+				RuntimeLibrary=&quot;2&quot;
+				UsePrecompiledHeader=&quot;0&quot;
+				WarningLevel=&quot;3&quot;
+				Detect64BitPortabilityProblems=&quot;true&quot;
+				DebugInformationFormat=&quot;3&quot;
+				DisableSpecificWarnings=&quot;4244;4996;4018;4267&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedResourceCompilerTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				Version=&quot;0.55&quot;
+				LinkIncremental=&quot;1&quot;
+				GenerateDebugInformation=&quot;true&quot;
+				SubSystem=&quot;2&quot;
+				OptimizeReferences=&quot;2&quot;
+				EnableCOMDATFolding=&quot;2&quot;
+				TargetMachine=&quot;1&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCALinkTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCManifestTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCXDCMakeTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCBscMakeTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCFxCopTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCAppVerifierTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCWebDeploymentTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;
+			/&gt;
+		&lt;/Configuration&gt;
+	&lt;/Configurations&gt;
+	&lt;References&gt;
+	&lt;/References&gt;
+	&lt;Files&gt;
+		&lt;Filter
+			Name=&quot;Source Files&quot;
+			Filter=&quot;cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx&quot;
+			UniqueIdentifier=&quot;{4FC737F1-C7A5-4376-A066-2A32D752A2FF}&quot;
+			&gt;
+			&lt;File
+				RelativePath=&quot;..\Builder.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\BuilderPlacement.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\CombatManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\Global.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\GMetalMap.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\GTerrainMap.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\LogFile.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\PowerManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\RAI.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\SWeaponManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\UnitDef.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\UnitManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Resource Files&quot;
+			Filter=&quot;rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav&quot;
+			UniqueIdentifier=&quot;{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}&quot;
+			&gt;
+			&lt;File
+				RelativePath=&quot;..\GlobalAIs.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;Filter
+				Name=&quot;Krog&apos;s Metal Class v0.4&quot;
+				&gt;
+				&lt;File
+					RelativePath=&quot;..\Krogs Metal Class v0.4\MetalMap.cpp&quot;
+					&gt;
+					&lt;FileConfiguration
+						Name=&quot;Debug|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							ObjectFile=&quot;$(IntDir)\$(InputName)1.obj&quot;
+							XMLDocumentationFileName=&quot;$(IntDir)\$(InputName)1.xdc&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+					&lt;FileConfiguration
+						Name=&quot;Release|Win32&quot;
+						&gt;
+						&lt;Tool
+							Name=&quot;VCCLCompilerTool&quot;
+							ObjectFile=&quot;$(IntDir)\$(InputName)1.obj&quot;
+							XMLDocumentationFileName=&quot;$(IntDir)\$(InputName)1.xdc&quot;
+						/&gt;
+					&lt;/FileConfiguration&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\Krogs Metal Class v0.4\MetalMap.h&quot;
+					&gt;
+				&lt;/File&gt;
+			&lt;/Filter&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Header Files&quot;
+			Filter=&quot;h;hpp;hxx;hm;inl;inc;xsd&quot;
+			UniqueIdentifier=&quot;{93995380-89BD-4b04-88EB-625FBE52EBFB}&quot;
+			&gt;
+			&lt;File
+				RelativePath=&quot;..\Builder.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\BuilderPlacement.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\CombatManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\Global.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\GMetalMap.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\GTerrainMap.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\LogFile.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\PowerManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\RAI.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\SWeaponManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\UnitDef.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\UnitManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+	&lt;/Files&gt;
+	&lt;Globals&gt;
+	&lt;/Globals&gt;
+&lt;/VisualStudioProject&gt;

Added: trunk/AI/Global/RAI-0.553/readme.txt
===================================================================
--- trunk/AI/Global/RAI-0.553/readme.txt	                        (rev 0)
+++ trunk/AI/Global/RAI-0.553/readme.txt	2008-04-11 19:40:03 UTC (rev 5702)
@@ -0,0 +1,45 @@
+_____________________________________________________
+
+RAI - Skirmish AI for the Spring Game Engine
+Author: Reth / Michael Vadovszki
+_____________________________________________________
+
+Forum Link:
+  <A HREF="http://spring.clan-sy.com/phpbb/viewtopic.php?t=7924">http://spring.clan-sy.com/phpbb/viewtopic.php?t=7924</A>
+
+Compiling:
+ - as of v0.76b1, the mingwlibs dependency is needed to compile an AI.
+    - <A HREF="http://spring.clan-sy.com/wiki/Engine_Development#SCONS.2FMinGW">http://spring.clan-sy.com/wiki/Engine_Development#SCONS.2FMinGW</A>
+    - <A HREF="http://spring.clan-sy.com/dl/spring-mingwlibs-v10.exe">http://spring.clan-sy.com/dl/spring-mingwlibs-v10.exe</A>
+ - while compiling,
+    - the RAI source folder was located in {spring source}/AI/Global/
+    - the mingwlibs folder was in the same directory as the
+      {spring source} directory
+
+ - CodeBlocks - I barely used this one, it should be able to compile a
+   working dll but I have not been keeping it up-to-date, so who knows.
+    - website: <A HREF="http://www.codeblocks.org/">http://www.codeblocks.org/</A>
+    - (OS - Windows Vista):  unless you know what you are doing then
+      you might want to just give up right now, getting it to work
+      probably won't be easy.
+ - Visual Studios 2005 - The dlls that it compiles will not work with
+   spring at this point, I now only use it as a writing aid.
+    - The project configuration starts on debug, switch it to release.
+ - DevC - the last few RAIs were compiled using this project
+   (DevC v4.9.9.2 with WinPorts GCC for Windows v4.1.1 incorporated
+   into it)
+    - website: <A HREF="http://www.bloodshed.net/devcpp.html">http://www.bloodshed.net/devcpp.html</A>
+    - updating GCC to 4.1.1 isn't a necessary step
+    - I had DevC installed on the default C directory, a dll in the
+      DevC directory was included in the project file.
+    - The .o files in the DevC project directory were copied directly
+      from the DevC directories to resolve a Vista/DevC bug.
+    - (OS - Windows Vista): Compiler Options &gt; Directories &gt; Libraries:
+      Add &quot;{DevC directory}\lib\gcc\mingw32\3.4.2&quot;
+
+
+Copyright: GPL
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License or
+    any later version.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000481.html">[Taspring-linux-commit] r5701 - trunk/rts/Game
</A></li>
	<LI>Next message: <A HREF="000488.html">[Taspring-linux-commit] r5703 - branches
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#482">[ date ]</a>
              <a href="thread.html#482">[ thread ]</a>
              <a href="subject.html#482">[ subject ]</a>
              <a href="author.html#482">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
