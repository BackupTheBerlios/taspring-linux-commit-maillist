<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5752 - in branches/gml/rts: ExternalAI	Game Game/Camera Game/StartScripts Game/UI Lua Map Map/SM3	Map/SM3/terrain Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim/Features	Sim/MoveTypes Sim/Path Sim/Projectiles Sim/Units	Sim/Units/COB Sim/Units/CommandAI Sim/Weapons System	System/Net System/Platform System/Platform/Win System/Script	build/vstudio8 lib lib/gml lib/luabind/luabind/detail	lib/luabind/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5752%20-%20in%20branches/gml/rts%3A%20ExternalAI%0A%09Game%20Game/Camera%20Game/StartScripts%20Game/UI%20Lua%20Map%20Map/SM3%0A%09Map/SM3/terrain%20Map/SMF%20Rendering%20Rendering/Env%20Rendering/GL%0A%09Rendering/Textures%20Rendering/UnitModels%20Sim/Features%0A%09Sim/MoveTypes%20Sim/Path%20Sim/Projectiles%20Sim/Units%0A%09Sim/Units/COB%20Sim/Units/CommandAI%20Sim/Weapons%20System%0A%09System/Net%20System/Platform%20System/Platform/Win%20System/Script%0A%09build/vstudio8%20lib%20lib/gml%20lib/luabind/luabind/detail%0A%09lib/luabind/src&In-Reply-To=%3C20080417234109.25A2B46AE%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000531.html">
   <LINK REL="Next"  HREF="000533.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5752 - in branches/gml/rts: ExternalAI	Game Game/Camera Game/StartScripts Game/UI Lua Map Map/SM3	Map/SM3/terrain Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim/Features	Sim/MoveTypes Sim/Path Sim/Projectiles Sim/Units	Sim/Units/COB Sim/Units/CommandAI Sim/Weapons System	System/Net System/Platform System/Platform/Win System/Script	build/vstudio8 lib lib/gml lib/luabind/luabind/detail	lib/luabind/src</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5752%20-%20in%20branches/gml/rts%3A%20ExternalAI%0A%09Game%20Game/Camera%20Game/StartScripts%20Game/UI%20Lua%20Map%20Map/SM3%0A%09Map/SM3/terrain%20Map/SMF%20Rendering%20Rendering/Env%20Rendering/GL%0A%09Rendering/Textures%20Rendering/UnitModels%20Sim/Features%0A%09Sim/MoveTypes%20Sim/Path%20Sim/Projectiles%20Sim/Units%0A%09Sim/Units/COB%20Sim/Units/CommandAI%20Sim/Weapons%20System%0A%09System/Net%20System/Platform%20System/Platform/Win%20System/Script%0A%09build/vstudio8%20lib%20lib/gml%20lib/luabind/luabind/detail%0A%09lib/luabind/src&In-Reply-To=%3C20080417234109.25A2B46AE%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5752 - in branches/gml/rts: ExternalAI	Game Game/Camera Game/StartScripts Game/UI Lua Map Map/SM3	Map/SM3/terrain Map/SMF Rendering Rendering/Env Rendering/GL	Rendering/Textures Rendering/UnitModels Sim/Features	Sim/MoveTypes Sim/Path Sim/Projectiles Sim/Units	Sim/Units/COB Sim/Units/CommandAI Sim/Weapons System	System/Net System/Platform System/Platform/Win System/Script	build/vstudio8 lib lib/gml lib/luabind/luabind/detail	lib/luabind/src">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Apr 18 01:41:08 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000531.html">[Taspring-linux-commit] r5751 - trunk/rts/lib/luabind/luabind/detail
</A></li>
        <LI>Next message: <A HREF="000533.html">[Taspring-linux-commit] r5753 - trunk/Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#532">[ date ]</a>
              <a href="thread.html#532">[ thread ]</a>
              <a href="subject.html#532">[ subject ]</a>
              <a href="author.html#532">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zerver
Date: 2008-04-18 01:41:06 +0200 (Fri, 18 Apr 2008)
New Revision: 5752

Added:
   branches/gml/rts/lib/gml/
   branches/gml/rts/lib/gml/gml.cpp
   branches/gml/rts/lib/gml/gml.h
   branches/gml/rts/lib/gml/gmlcls.h
   branches/gml/rts/lib/gml/gmldef.h
   branches/gml/rts/lib/gml/gmlfun.h
   branches/gml/rts/lib/gml/gmlimp.h
   branches/gml/rts/lib/gml/gmlsrv.h
Modified:
   branches/gml/rts/ExternalAI/AICallback.cpp
   branches/gml/rts/ExternalAI/AICheats.cpp
   branches/gml/rts/ExternalAI/AICheats.h
   branches/gml/rts/ExternalAI/GroupHandler.cpp
   branches/gml/rts/ExternalAI/IAICallback.h
   branches/gml/rts/ExternalAI/IAICheats.h
   branches/gml/rts/Game/Camera/CameraController.cpp
   branches/gml/rts/Game/Camera/CameraController.h
   branches/gml/rts/Game/Camera/FPSController.cpp
   branches/gml/rts/Game/Camera/FPSController.h
   branches/gml/rts/Game/Camera/FreeController.cpp
   branches/gml/rts/Game/Camera/FreeController.h
   branches/gml/rts/Game/Camera/LuaCameraCtrl.h
   branches/gml/rts/Game/Camera/OverheadController.cpp
   branches/gml/rts/Game/Camera/OverheadController.h
   branches/gml/rts/Game/Camera/OverviewController.cpp
   branches/gml/rts/Game/Camera/OverviewController.h
   branches/gml/rts/Game/Camera/RotOverheadController.cpp
   branches/gml/rts/Game/Camera/RotOverheadController.h
   branches/gml/rts/Game/Camera/SmoothController.cpp
   branches/gml/rts/Game/Camera/SmoothController.h
   branches/gml/rts/Game/Camera/TWController.cpp
   branches/gml/rts/Game/Camera/TWController.h
   branches/gml/rts/Game/CameraHandler.cpp
   branches/gml/rts/Game/CameraHandler.h
   branches/gml/rts/Game/Game.cpp
   branches/gml/rts/Game/Game.h
   branches/gml/rts/Game/GameController.cpp
   branches/gml/rts/Game/GameHelper.h
   branches/gml/rts/Game/GameServer.cpp
   branches/gml/rts/Game/GameServer.h
   branches/gml/rts/Game/PlayerRoster.cpp
   branches/gml/rts/Game/PreGame.cpp
   branches/gml/rts/Game/PreGame.h
   branches/gml/rts/Game/SelectedUnits.cpp
   branches/gml/rts/Game/SelectedUnits.h
   branches/gml/rts/Game/StartScripts/CommanderScript.cpp
   branches/gml/rts/Game/StartScripts/CommanderScript.h
   branches/gml/rts/Game/StartScripts/Script.cpp
   branches/gml/rts/Game/StartScripts/Script.h
   branches/gml/rts/Game/UI/EndGameBox.cpp
   branches/gml/rts/Game/UI/EndGameBox.h
   branches/gml/rts/Game/UI/MiniMap.cpp
   branches/gml/rts/Game/UI/MouseHandler.cpp
   branches/gml/rts/Game/UI/SelectionKeyHandler.cpp
   branches/gml/rts/Lua/LuaMaterial.h
   branches/gml/rts/Lua/LuaSyncedCtrl.cpp
   branches/gml/rts/Lua/LuaSyncedRead.cpp
   branches/gml/rts/Lua/LuaUnitDefs.cpp
   branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp
   branches/gml/rts/Lua/LuaUnsyncedRead.cpp
   branches/gml/rts/Map/ReadMap.h
   branches/gml/rts/Map/SM3/Frustum.cpp
   branches/gml/rts/Map/SM3/Sm3GroundDrawer.cpp
   branches/gml/rts/Map/SM3/Sm3Map.cpp
   branches/gml/rts/Map/SM3/terrain/QuadRenderData.cpp
   branches/gml/rts/Map/SM3/terrain/Terrain.cpp
   branches/gml/rts/Map/SM3/terrain/TerrainBase.h
   branches/gml/rts/Map/SMF/BFGroundDrawer.cpp
   branches/gml/rts/Map/SMF/BFGroundDrawer.h
   branches/gml/rts/Map/SMF/BFGroundTextures.h
   branches/gml/rts/Map/SMF/SmfReadMap.cpp
   branches/gml/rts/Map/SMF/SmfReadMap.h
   branches/gml/rts/Rendering/Env/AdvTreeDrawer.cpp
   branches/gml/rts/Rendering/Env/GrassDrawer.cpp
   branches/gml/rts/Rendering/GL/VertexArray.cpp
   branches/gml/rts/Rendering/GL/VertexArray.h
   branches/gml/rts/Rendering/GL/VertexArrayRange.cpp
   branches/gml/rts/Rendering/GL/myGL.cpp
   branches/gml/rts/Rendering/GL/myGL.h
   branches/gml/rts/Rendering/GroundDecalHandler.cpp
   branches/gml/rts/Rendering/Textures/nv_dds.h
   branches/gml/rts/Rendering/UnitModels/3DOParser.cpp
   branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp
   branches/gml/rts/Rendering/UnitModels/UnitDrawer.h
   branches/gml/rts/Sim/Features/FeatureHandler.cpp
   branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp
   branches/gml/rts/Sim/Path/PathEstimator.cpp
   branches/gml/rts/Sim/Path/PathEstimator.h
   branches/gml/rts/Sim/Path/PathFinder.h
   branches/gml/rts/Sim/Projectiles/Projectile.cpp
   branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp
   branches/gml/rts/Sim/Units/COB/CobInstance.cpp
   branches/gml/rts/Sim/Units/CommandAI/Command.h
   branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp
   branches/gml/rts/Sim/Units/Unit.cpp
   branches/gml/rts/Sim/Units/Unit.h
   branches/gml/rts/Sim/Units/UnitDef.h
   branches/gml/rts/Sim/Units/UnitDefHandler.cpp
   branches/gml/rts/Sim/Units/UnitHandler.cpp
   branches/gml/rts/Sim/Units/UnitLoader.cpp
   branches/gml/rts/Sim/Units/UnitTracker.cpp
   branches/gml/rts/Sim/Weapons/Cannon.cpp
   branches/gml/rts/System/BaseNetProtocol.cpp
   branches/gml/rts/System/DemoReader.cpp
   branches/gml/rts/System/DemoReader.h
   branches/gml/rts/System/LoadSaveHandler.cpp
   branches/gml/rts/System/Net/Net.h
   branches/gml/rts/System/Net/PackPacket.h
   branches/gml/rts/System/Net/UDPConnection.cpp
   branches/gml/rts/System/Net/UDPConnection.h
   branches/gml/rts/System/Net/UDPListener.h
   branches/gml/rts/System/Platform/FileSystem.h
   branches/gml/rts/System/Platform/Win/AVIGenerator.cpp
   branches/gml/rts/System/Platform/Win/DxSound.cpp
   branches/gml/rts/System/Platform/Win/DxSound.h
   branches/gml/rts/System/Script/LuaBinder.cpp
   branches/gml/rts/System/Script/LuaFunctions.cpp
   branches/gml/rts/System/Script/LuaFunctions.h
   branches/gml/rts/System/myMath.h
   branches/gml/rts/build/vstudio8/rts.vcproj
   branches/gml/rts/lib/luabind/luabind/detail/class_rep.hpp
   branches/gml/rts/lib/luabind/luabind/detail/enum_maker.hpp
   branches/gml/rts/lib/luabind/luabind/detail/garbage_collector.hpp
   branches/gml/rts/lib/luabind/luabind/detail/overload_rep.hpp
   branches/gml/rts/lib/luabind/luabind/detail/policy.hpp
   branches/gml/rts/lib/luabind/src/object_rep.cpp
Log:


Modified: branches/gml/rts/ExternalAI/AICallback.cpp
===================================================================
--- branches/gml/rts/ExternalAI/AICallback.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/ExternalAI/AICallback.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -1226,10 +1226,10 @@
 			*(float*)data = gu-&gt;viewSizeY;
 			return true;
 		}case AIVAL_GUI_CAMERA_DIR:{
-			*(float3*)data = camCtrl-&gt;GetDir();
+			*(float3*)data = camHandler-&gt;GetCurrentController().GetDir();
 			return true;
 		}case AIVAL_GUI_CAMERA_POS:{
-			*(float3*)data = camCtrl-&gt;GetPos();
+			*(float3*)data = camHandler-&gt;GetCurrentController().GetPos();
 			return true;
 		}case AIVAL_LOCATE_FILE_R:{
 			std::string f((char*) data);

Modified: branches/gml/rts/ExternalAI/AICheats.cpp
===================================================================
--- branches/gml/rts/ExternalAI/AICheats.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/ExternalAI/AICheats.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -18,26 +18,25 @@
 
 using namespace std;
 
-CAICheats::CAICheats(CGlobalAI* ai)
-:	ai(ai)
+CAICheats::CAICheats(CGlobalAI* ai): ai(ai)
 {
 }
 
 CAICheats::~CAICheats(void)
 {}
 
-bool CAICheats::OnlyPassiveCheats ()
+bool CAICheats::OnlyPassiveCheats()
 {
-	if (!gameServer) // if we are not server, cheats will cause desync
-	{
+	if (!gameServer) {
+		// if we are NOT server, cheats will cause desync
 		return true;
 	}
-	else if (gameSetup &amp;&amp; (gameSetup-&gt;numPlayers == 1)) // assuming AIs dont count on numPlayers
-	{
+	else if (gameSetup &amp;&amp; (gameSetup-&gt;numPlayers == 1)) {
+		// assuming AI's dont count on numPlayers
 		return false;
 	}
-	else // disable it in case we are not sure
-	{
+	else {
+		// disable it in case we are not sure
 		return true;
 	}
 }
@@ -50,27 +49,27 @@
 void CAICheats::SetMyHandicap(float handicap)
 {
 	if (!OnlyPassiveCheats()) {
-		gs-&gt;Team(ai-&gt;team)-&gt;handicap=1+handicap/100;
+		gs-&gt;Team(ai-&gt;team)-&gt;handicap = 1 + handicap / 100;
 	}
 }
 
 void CAICheats::GiveMeMetal(float amount)
 {
 	if (!OnlyPassiveCheats())
-		gs-&gt;Team(ai-&gt;team)-&gt;metal+=amount;
+		gs-&gt;Team(ai-&gt;team)-&gt;metal += amount;
 }
 
 void CAICheats::GiveMeEnergy(float amount)
 {
 	if (!OnlyPassiveCheats())
-		gs-&gt;Team(ai-&gt;team)-&gt;energy+=amount;
+		gs-&gt;Team(ai-&gt;team)-&gt;energy += amount;
 }
 
-int CAICheats::CreateUnit(const char* name,float3 pos)
+int CAICheats::CreateUnit(const char* name, float3 pos)
 {
-	if(!OnlyPassiveCheats()) {
-		CUnit* u=unitLoader.LoadUnit(name,pos,ai-&gt;team,false,0,NULL);
-		if(u)
+	if (!OnlyPassiveCheats()) {
+		CUnit* u = unitLoader.LoadUnit(name, pos, ai-&gt;team, false, 0, NULL);
+		if (u)
 			return u-&gt;id;
 	}
 	return 0;
@@ -79,8 +78,8 @@
 const UnitDef* CAICheats::GetUnitDef(int unitid)
 {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;unitDef;
 	}
 	return 0;
@@ -90,49 +89,94 @@
 float3 CAICheats::GetUnitPos(int unitid)
 {
 	if (!CHECK_UNITID(unitid)) return ZeroVector;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;pos;
 	}
 	return ZeroVector;
 
 }
 
-int CAICheats::GetEnemyUnits(int *units)
+int CAICheats::GetEnemyUnits(int* units)
 {
 	list&lt;CUnit*&gt;::iterator ui;
-	int a=0;
+	int a = 0;
 
-	for(list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();++ui){
-		if(!gs-&gt;Ally((*ui)-&gt;allyteam,gs-&gt;AllyTeam(ai-&gt;team))){
-			units[a++]=(*ui)-&gt;id;
+	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(ai-&gt;team))) {
+			if (!IsUnitNeutral(u-&gt;id)) {
+				units[a++] = u-&gt;id;
+			}
 		}
 	}
+
 	return a;
 }
 
-int CAICheats::GetEnemyUnits(int *units,const float3&amp; pos,float radius)
+int CAICheats::GetEnemyUnits(int* units, const float3&amp; pos, float radius)
 {
-	vector&lt;CUnit*&gt; unit=qf-&gt;GetUnitsExact(pos,radius);
+	vector&lt;CUnit*&gt; unit = qf-&gt;GetUnitsExact(pos, radius);
+	vector&lt;CUnit*&gt;::iterator ui;
+	int a = 0;
 
+	for (ui = unit.begin(); ui != unit.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(ai-&gt;team))) {
+			if (!IsUnitNeutral(u-&gt;id)) {
+				units[a] = u-&gt;id;
+				++a;
+			}
+		}
+	}
+
+	return a;
+}
+
+
+
+int CAICheats::GetNeutralUnits(int* units)
+{
+	int a = 0;
+
+	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (IsUnitNeutral(u-&gt;id)) {
+			units[a++] = u-&gt;id;
+		}
+	}
+
+	return a;
+}
+
+int CAICheats::GetNeutralUnits(int* units, const float3&amp; pos, float radius)
+{
+	vector&lt;CUnit*&gt; unit = qf-&gt;GetUnitsExact(pos, radius);
 	vector&lt;CUnit*&gt;::iterator ui;
-	int a=0;
+	int a = 0;
 
-	for(ui=unit.begin();ui!=unit.end();++ui){
-		if(!gs-&gt;Ally((*ui)-&gt;allyteam,gs-&gt;AllyTeam(ai-&gt;team))){
-			units[a]=(*ui)-&gt;id;
+	for (ui = unit.begin(); ui != unit.end(); ++ui) {
+		CUnit* u = *ui;
+
+		if (IsUnitNeutral(u-&gt;id)) {
+			units[a] = u-&gt;id;
 			++a;
 		}
 	}
+
 	return a;
-
 }
 
+
+
 int CAICheats::GetUnitTeam(int unitid)
 {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;team;
 	}
 	return 0;
@@ -141,8 +185,8 @@
 int CAICheats::GetUnitAllyTeam(int unitid)
 {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;allyteam;
 	}
 	return 0;
@@ -151,8 +195,8 @@
 float CAICheats::GetUnitHealth(int unitid)			//the units current health
 {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;health;
 	}
 	return 0;
@@ -161,8 +205,8 @@
 float CAICheats::GetUnitMaxHealth(int unitid)		//the units max health
 {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;maxHealth;
 	}
 	return 0;
@@ -171,8 +215,8 @@
 float CAICheats::GetUnitPower(int unitid)				//sort of the measure of the units overall power
 {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;power;
 	}
 	return 0;
@@ -181,38 +225,38 @@
 float CAICheats::GetUnitExperience(int unitid)	//how experienced the unit is (0.0-1.0)
 {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;experience;
 	}
 	return 0;
 }
 
-bool CAICheats::IsUnitActivated (int unitid)
+bool CAICheats::IsUnitActivated(int unitid)
 {
 	if (!CHECK_UNITID(unitid)) return false;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;activated;
 	}
 	return false;
 }
 
-bool CAICheats::UnitBeingBuilt (int unitid)
+bool CAICheats::UnitBeingBuilt(int unitid)
 {
 	if (!CHECK_UNITID(unitid)) return false;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;beingBuilt;
 	}
 	return false;
 }
 
-bool CAICheats::GetUnitResourceInfo (int unitid, UnitResourceInfo *i)
+bool CAICheats::GetUnitResourceInfo(int unitid, UnitResourceInfo *i)
 {
 	if (!CHECK_UNITID(unitid)) return false;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		i-&gt;energyMake = unit-&gt;energyMake;
 		i-&gt;energyUse = unit-&gt;energyUse;
 		i-&gt;metalMake = unit-&gt;metalMake;
@@ -225,8 +269,8 @@
 const CCommandQueue* CAICheats::GetCurrentUnitCommands(int unitid)
 {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit *unit = uh-&gt;units[unitid];
-	if (unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return &amp;unit-&gt;commandAI-&gt;commandQue;
 	}
 	return 0;
@@ -234,8 +278,8 @@
 
 int CAICheats::GetBuildingFacing(int unitid) {
 	if (!CHECK_UNITID(unitid)) return 0;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;buildFacing;
 	}
 	return 0;
@@ -243,8 +287,8 @@
 
 bool CAICheats::IsUnitCloaked(int unitid) {
 	if (!CHECK_UNITID(unitid)) return false;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;isCloaked;
 	}
 	return false;
@@ -252,21 +296,38 @@
 
 bool CAICheats::IsUnitParalyzed(int unitid){
 	if (!CHECK_UNITID(unitid)) return false;
-	CUnit* unit=uh-&gt;units[unitid];
-	if(unit){
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
 		return unit-&gt;stunned;
 	}
 	return 0;
 }
 
+
+bool CAICheats::IsUnitNeutral(int unitid) {
+	if (!CHECK_UNITID(unitid))
+		return false;
+
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit) {
+		if ((gs-&gt;useLuaGaia &amp;&amp; unit-&gt;team == gs-&gt;gaiaTeamID) || (unit-&gt;team == MAX_TEAMS - 1))
+			return true;
+		if (unit-&gt;neutral)
+			return true;
+	}
+
+	return 0;
+}
+
+
 bool CAICheats::GetProperty(int id, int property, void *data)
 {
 	switch (property) {
-		case AIVAL_UNITDEF:{
+		case AIVAL_UNITDEF: {
 			if (!CHECK_UNITID(id)) return false;
-			CUnit *unit = uh-&gt;units[id];
+			CUnit* unit = uh-&gt;units[id];
 			if (unit) {
-				(*(const UnitDef**)data) = unit-&gt;unitDef;
+				(*(const UnitDef**) data) = unit-&gt;unitDef;
 				return true;
 			}
 			break;
@@ -277,19 +338,14 @@
 	return false; // never reached
 }
 
-bool CAICheats::GetValue(int id, void *data)
+bool CAICheats::GetValue(int id, void* data)
 {
-	/*switch (id) {
-		default:
-			return false;
-	}*/
 	return false;
 }
 
-int CAICheats::HandleCommand (int commandId, void *data)
+int CAICheats::HandleCommand(int commandId, void *data)
 {
-	switch (commandId)
-	{
+	switch (commandId) {
 		case AIHCQuerySubVersionId:
 			return 1; // current version of Handle Command interface
 		default:

Modified: branches/gml/rts/ExternalAI/AICheats.h
===================================================================
--- branches/gml/rts/ExternalAI/AICheats.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/ExternalAI/AICheats.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,49 +4,49 @@
 #include &quot;IAICheats.h&quot;
 class CGlobalAI;
 
-class CAICheats :
-	public IAICheats
+class CAICheats: public IAICheats
 {
 	CGlobalAI* ai;
 public:
 	CAICheats(CGlobalAI* ai);
 	~CAICheats(void);
 
-	void SetMyHandicap(float handicap);			//same as the value in the game setup file (currently gives bonus on collected resources)
+	void SetMyHandicap(float handicap);
 
-	void GiveMeMetal(float amount);					//give selected amount of metal
-	void GiveMeEnergy(float amount);				//give selected amount of energy;
+	void GiveMeMetal(float amount);
+	void GiveMeEnergy(float amount);
 
-	int CreateUnit(const char* name,float3 pos);		//creates a unit with the selected name at pos
+	int CreateUnit(const char* name, float3 pos);
 
-	//the following commands works exactly like those in the standard interface except that they dont do any los checks
-	const UnitDef* GetUnitDef(int unitid);	//this returns the units unitdef struct from which you can read all the statistics of the unit, dont try to change any values in it, dont use this if you dont have to risk of changes in it
-	float3 GetUnitPos(int unitid);				//note that x and z are the horizontal axises while y represent height
-	int GetEnemyUnits(int *units);					//returns all known enemy units
-	int GetEnemyUnits(int *units,const float3&amp; pos,float radius); //returns all known enemy units within radius from pos
+	const UnitDef* GetUnitDef(int unitid);
+	float3 GetUnitPos(int unitid);
+	int GetEnemyUnits(int* units);
+	int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
+	int GetNeutralUnits(int* units);
+	int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
 
-	int GetUnitTeam (int unitid);
-	int GetUnitAllyTeam (int unitid);
-	float GetUnitHealth (int unitid);			//the units current health
-	float GetUnitMaxHealth (int unitid);		//the units max health
-	float GetUnitPower(int unitid);				//sort of the measure of the units overall power
-	float GetUnitExperience (int unitid);	//how experienced the unit is (0.0f-1.0f)
-	bool IsUnitActivated (int unitid); 
-	bool UnitBeingBuilt (int unitid);			//returns true if the unit is currently being built
-	bool GetUnitResourceInfo (int unitid, UnitResourceInfo* resourceInfo);
+	int GetUnitTeam(int unitid);
+	int GetUnitAllyTeam(int unitid);
+	float GetUnitHealth(int unitid);
+	float GetUnitMaxHealth(int unitid);
+	float GetUnitPower(int unitid);
+	float GetUnitExperience(int unitid);
+	bool IsUnitActivated(int unitid);
+	bool UnitBeingBuilt(int unitid);
+	bool IsUnitNeutral(int unitid);
+	bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
 	const CCommandQueue* GetCurrentUnitCommands(int unitid);
 
-	int GetBuildingFacing(int unitid);		//returns building facing (0-3)
+	int GetBuildingFacing(int unitid);
 	bool IsUnitCloaked(int unitid);
 	bool IsUnitParalyzed(int unitid);
 
 	bool OnlyPassiveCheats();
 	void EnableCheatEvents(bool enable);
 
-	// future callback extensions
-	bool GetProperty(int unit, int property, void *dst);
-	bool GetValue(int id, void *dst);
-	int HandleCommand(int commandId, void *data); 
+	bool GetProperty(int unit, int property, void* dst);
+	bool GetValue(int id, void* dst);
+	int HandleCommand(int commandId, void* data);
 };
 
 #endif

Modified: branches/gml/rts/ExternalAI/GroupHandler.cpp
===================================================================
--- branches/gml/rts/ExternalAI/GroupHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/ExternalAI/GroupHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -190,7 +190,7 @@
 			p+=(*gi)-&gt;pos;
 		}
 		p/=groups[num]-&gt;units.size();
-		camCtrl-&gt;SetPos(p);
+		camHandler-&gt;GetCurrentController().SetPos(p);
 	}
 
 	selectedUnits.SelectGroup(num);
@@ -244,7 +244,7 @@
 			p+=(*gi)-&gt;pos;
 		}
 		p/=groups[num]-&gt;units.size();
-		camCtrl-&gt;SetPos(p);
+		camHandler-&gt;GetCurrentController().SetPos(p);
 	}
 
 	selectedUnits.SelectGroup(num);

Modified: branches/gml/rts/ExternalAI/IAICallback.h
===================================================================
--- branches/gml/rts/ExternalAI/IAICallback.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/ExternalAI/IAICallback.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -123,7 +123,7 @@
 	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid) = 0;	// the commands that this unit can understand, other commands will be ignored
 	virtual int GiveGroupOrder(int unitid, Command* c) = 0;
 
-	virtual int GiveOrder(int unitid,Command* c) = 0;
+	virtual int GiveOrder(int unitid, Command* c) = 0;
 
 	virtual const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid) = 0;
 	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid) = 0;

Modified: branches/gml/rts/ExternalAI/IAICheats.h
===================================================================
--- branches/gml/rts/ExternalAI/IAICheats.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/ExternalAI/IAICheats.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -10,46 +10,57 @@
 class SPRING_API IAICheats
 {
 public:
-	//note that all of these commands are network insecure
-	//that is they are not transmitted over the network and will cause sync errors
-	//so only use them with a single player
+	// note that all of the non-readonly commands are network-
+	// insecure: they aren't transmitted over the network and
+	// thus will cause sync errors, so do not use them when 2
+	// or more players are around (although you actually can't,
+	// since they call OnlyPassiveCheats() internally)
 
-	virtual void SetMyHandicap(float handicap)=0;			//same as the value in the game setup file (currently gives bonus on collected resources)
+	// this function has the same effect as setting a handicap value
+	// in the GameSetup script (currently gives a bonus on collected
+	// resources)
+	virtual void SetMyHandicap(float handicap) = 0;
 
-	virtual void GiveMeMetal(float amount)=0;					//give selected amount of metal
-	virtual void GiveMeEnergy(float amount)=0;				//give selected amount of energy;
+	virtual void GiveMeMetal(float amount) = 0;			// give selected amount of metal
+	virtual void GiveMeEnergy(float amount) = 0;		// give selected amount of energy
 
-	virtual int CreateUnit(const char* name,float3 pos)=0;		//creates a unit with the selected name at pos
+	// creates a unit with the selected name at pos
+	virtual int CreateUnit(const char* name, float3 pos) = 0;
 
-	//the following commands works exactly like those in the standard interface except that they dont do any los checks
-	virtual const UnitDef* GetUnitDef(int unitid)=0;	//this returns the units unitdef struct from which you can read all the statistics of the unit, dont try to change any values in it, dont use this if you dont have to risk of changes in it
-	virtual float3 GetUnitPos(int unitid)=0;				//note that x and z are the horizontal axises while y represent height
-	virtual int GetEnemyUnits(int *units)=0;					//returns all known enemy units
-	virtual int GetEnemyUnits(int *units,const float3&amp; pos,float radius)=0; //returns all known enemy units within radius from pos
 
-	virtual int GetUnitTeam (int unitid)=0;
-	virtual int GetUnitAllyTeam (int unitid)=0;
-	virtual float GetUnitHealth (int unitid)=0;			//the units current health
-	virtual float GetUnitMaxHealth (int unitid)=0;		//the units max health
-	virtual float GetUnitPower(int unitid)=0;				//sort of the measure of the units overall power
-	virtual float GetUnitExperience (int unitid)=0;	//how experienced the unit is (0.0-1.0)
-	virtual bool IsUnitActivated (int unitid)=0; 
-	virtual bool UnitBeingBuilt (int unitid)=0;			//returns true if the unit is currently being built
-	virtual bool GetUnitResourceInfo (int unitid, UnitResourceInfo* resourceInfo)=0;
-	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid)=0;
-	
-	virtual int GetBuildingFacing(int unitid)=0;		//returns building facing (0-3)
-	virtual bool IsUnitCloaked(int unitid)=0;
-	virtual bool IsUnitParalyzed(int unitid)=0;
 
-	virtual bool OnlyPassiveCheats()=0;
-	virtual void EnableCheatEvents(bool enable)=0;
+	// the following commands work exactly like those in the standard
+	// callback interface, except that they don't do any LOS checks
+	virtual const UnitDef* GetUnitDef(int unitid) = 0;
+	virtual float3 GetUnitPos(int unitid) = 0;
+	virtual int GetEnemyUnits(int* units) = 0;
+	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius) = 0;
+	virtual int GetNeutralUnits(int* units) = 0;
+	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius) = 0;
 
-	// future callback extensions
-	virtual bool GetProperty(int id, int property, void *dst)=0;
-	virtual bool GetValue(int id, void *dst)=0;
-	virtual int HandleCommand(int commandId, void *data)=0;
+	virtual int GetUnitTeam(int unitid) = 0;
+	virtual int GetUnitAllyTeam(int unitid) = 0;
+	virtual float GetUnitHealth(int unitid) = 0;
+	virtual float GetUnitMaxHealth(int unitid) = 0;
+	virtual float GetUnitPower(int unitid) = 0;
+	virtual float GetUnitExperience(int unitid) = 0;
+	virtual bool IsUnitActivated(int unitid) = 0;
+	virtual bool UnitBeingBuilt(int unitid) = 0;
+	virtual bool IsUnitNeutral(int unitid) = 0;
+	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo) = 0;
+	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid) = 0;
 
+	virtual int GetBuildingFacing(int unitid) = 0;
+	virtual bool IsUnitCloaked(int unitid) = 0;
+	virtual bool IsUnitParalyzed(int unitid) = 0;
+
+	virtual bool OnlyPassiveCheats() = 0;
+	virtual void EnableCheatEvents(bool enable) = 0;
+
+	virtual bool GetProperty(int id, int property, void* dst) = 0;
+	virtual bool GetValue(int id, void* dst) = 0;
+	virtual int HandleCommand(int commandId, void* data) = 0;
+
 	DECLARE_PURE_VIRTUAL(~IAICheats())
 };
 

Modified: branches/gml/rts/Game/Camera/CameraController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/CameraController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/CameraController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -2,19 +2,10 @@
 
 #include &quot;Platform/ConfigHandler.h&quot;
 
-#ifdef _WIN32
-#define DEFAULT_MOUSE_SCALE 0.01f
-#else
-#define DEFAULT_MOUSE_SCALE 0.003f
-#endif
 
-
-CCameraController* camCtrl = NULL;
-
-
-CCameraController::CCameraController(int _num) : num(_num), pos(2000, 70, 1800)
+CCameraController::CCameraController() : pos(2000, 70, 1800)
 {
-	mouseScale = configHandler.GetFloat(&quot;FPSMouseScale&quot;, DEFAULT_MOUSE_SCALE);
+	mouseScale = configHandler.GetFloat(&quot;FPSMouseScale&quot;, 0.01f);
 	scrollSpeed = 1;
 	fov = 45.0f;
 	enabled = true;

Modified: branches/gml/rts/Game/Camera/CameraController.h
===================================================================
--- branches/gml/rts/Game/Camera/CameraController.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/CameraController.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,12 +4,12 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-#include &quot;GlobalStuff.h&quot;
+#include &quot;float3.h&quot;
 
 class CCameraController
 {
 public:
-	CCameraController(int num);
+	CCameraController();
 	virtual ~CCameraController(void);
 
 	virtual const std::string GetName() const = 0;
@@ -24,7 +24,7 @@
 	virtual float3 GetPos()=0;
 	virtual float3 GetDir()=0;
 
-	float GetFOV() { return fov; }
+	float GetFOV() const { return fov; };
 
 	virtual void SetPos(const float3&amp; newPos) { pos = newPos; };
 	virtual bool DisableTrackingByKey() { return true; }
@@ -36,8 +36,7 @@
 	virtual bool SetState(const std::vector&lt;float&gt;&amp; fv) = 0;
 	virtual void SetTrackingInfo(const float3&amp; pos, float radius) { SetPos(pos); }
 
-//FIXME		virtual const std::vector&lt;std::string&gt;&amp; GetStateNames() const = 0;
-	const int num;
+	/// should this mode appear when we toggle the camera controller?
 	bool enabled;
 	
 protected:
@@ -49,7 +48,4 @@
 };
 
 
-extern CCameraController* camCtrl;
-
-
 #endif // __CAMERA_CONTROLLER_H__

Modified: branches/gml/rts/Game/Camera/FPSController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/FPSController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/FPSController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,9 +7,8 @@
 
 using namespace std;
 
-CFPSController::CFPSController(int num)
-	: CCameraController(num),
-	oldHeight(300)
+CFPSController::CFPSController()
+	: oldHeight(300)
 {
 	scrollSpeed = configHandler.GetInt(&quot;FPSScrollSpeed&quot;, 10) * 0.1f;
 	enabled = !!configHandler.GetInt(&quot;FPSEnabled&quot;, 1);
@@ -107,7 +106,6 @@
 
 void CFPSController::GetState(std::vector&lt;float&gt;&amp; fv) const
 {
-	fv.push_back(/*  0 */ (float)num);
 	fv.push_back(/*  1 */ pos.x);
 	fv.push_back(/*  2 */ pos.y);
 	fv.push_back(/*  3 */ pos.z);
@@ -122,19 +120,19 @@
 
 bool CFPSController::SetState(const std::vector&lt;float&gt;&amp; fv)
 {
-	if ((fv.size() != 11) || (fv[0] != (float)num)) {
+	if (fv.size() != 10) {
 		return false;
 	}
-	pos.x = fv[1];
-	pos.y = fv[2];
-	pos.z = fv[3];
-	dir.x = fv[4];
-	dir.y = fv[5];
-	dir.z = fv[6];
-	camera-&gt;rot.x = fv[7];
-	camera-&gt;rot.y = fv[8];
-	camera-&gt;rot.z = fv[9];
-	oldHeight = fv[10];
+	pos.x = fv[0];
+	pos.y = fv[1];
+	pos.z = fv[2];
+	dir.x = fv[3];
+	dir.y = fv[4];
+	dir.z = fv[5];
+	camera-&gt;rot.x = fv[6];
+	camera-&gt;rot.y = fv[7];
+	camera-&gt;rot.z = fv[8];
+	oldHeight = fv[9];
 	return true;
 }
 

Modified: branches/gml/rts/Game/Camera/FPSController.h
===================================================================
--- branches/gml/rts/Game/Camera/FPSController.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/FPSController.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -8,7 +8,7 @@
 class CFPSController : public CCameraController
 {
 public:
-	CFPSController(int num);
+	CFPSController();
 
 	const std::string GetName() const { return &quot;fps&quot;; }
 

Modified: branches/gml/rts/Game/Camera/FreeController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/FreeController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/FreeController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -19,9 +19,8 @@
 //        - rename it?  ;-)
 //
 
-CFreeController::CFreeController(int num)
-	: CCameraController(num),
-	dir(0.0f, 0.0f, 0.0f),
+CFreeController::CFreeController()
+	: dir(0.0f, 0.0f, 0.0f),
 	vel(0.0f, 0.0f, 0.0f),
 	avel(0.0f, 0.0f, 0.0f),
 	prevVel(0.0f, 0.0f, 0.0f),
@@ -395,7 +394,6 @@
 
 void CFreeController::GetState(std::vector&lt;float&gt;&amp; fv) const
 {
-	fv.push_back(/*  0 */ (float)num);
 	fv.push_back(/*  1 */ pos.x);
 	fv.push_back(/*  2 */ pos.y);
 	fv.push_back(/*  3 */ pos.z);
@@ -430,37 +428,37 @@
 
 bool CFreeController::SetState(const std::vector&lt;float&gt;&amp; fv)
 {
-	if ((fv.size() != 28) || (fv[0] != (float)num)) {
+	if (fv.size() != 27) {
 		return false;
 	}
-	pos.x = fv[1];
-	pos.y = fv[2];
-	pos.z = fv[3];
-	dir.x = fv[4];
-	dir.y = fv[5];
-	dir.z = fv[6];
-	camera-&gt;rot.x = fv[7];
-	camera-&gt;rot.y = fv[8];
-	camera-&gt;rot.z = fv[9];
+	pos.x = fv[0];
+	pos.y = fv[1];
+	pos.z = fv[2];
+	dir.x = fv[3];
+	dir.y = fv[4];
+	dir.z = fv[5];
+	camera-&gt;rot.x = fv[6];
+	camera-&gt;rot.y = fv[7];
+	camera-&gt;rot.z = fv[8];
 
-	fov         =  fv[10];
-	gndOffset   =  fv[11];
-	gravity     =  fv[12];
-	slide       =  fv[13];
-	scrollSpeed =  fv[14];
-	tiltSpeed   =  fv[15];
-	velTime     =  fv[16];
-	avelTime    =  fv[17];
-	autoTilt    =  fv[18];
-	goForward   = (fv[19] &gt; 0.0f);
-	invertAlt   = (fv[20] &gt; 0.0f);
-	gndLock     = (fv[21] &gt; 0.0f);
-	prevVel.x   =  fv[22];
-	prevVel.y   =  fv[23];
-	prevVel.z   =  fv[24];
-	prevAvel.x  =  fv[25];
-	prevAvel.y  =  fv[26];
-	prevAvel.z  =  fv[27];
+	fov         =  fv[9];
+	gndOffset   =  fv[10];
+	gravity     =  fv[11];
+	slide       =  fv[12];
+	scrollSpeed =  fv[13];
+	tiltSpeed   =  fv[14];
+	velTime     =  fv[15];
+	avelTime    =  fv[16];
+	autoTilt    =  fv[17];
+	goForward   = (fv[18] &gt; 0.0f);
+	invertAlt   = (fv[19] &gt; 0.0f);
+	gndLock     = (fv[20] &gt; 0.0f);
+	prevVel.x   =  fv[21];
+	prevVel.y   =  fv[22];
+	prevVel.z   =  fv[23];
+	prevAvel.x  =  fv[24];
+	prevAvel.y  =  fv[25];
+	prevAvel.z  =  fv[26];
 
 	return true;
 }

Modified: branches/gml/rts/Game/Camera/FreeController.h
===================================================================
--- branches/gml/rts/Game/Camera/FreeController.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/FreeController.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,7 +7,7 @@
 
 class CFreeController : public CCameraController {
 public:
-	CFreeController(int num);
+	CFreeController();
 
 	const std::string GetName() const { return &quot;free&quot;; }
 

Modified: branches/gml/rts/Game/Camera/LuaCameraCtrl.h
===================================================================
--- branches/gml/rts/Game/Camera/LuaCameraCtrl.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/LuaCameraCtrl.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,7 +7,7 @@
 
 class CLuaCameraCtrl : public CCameraController {
 public:
-	CLuaCameraCtrl(int num);
+	CLuaCameraCtrl();
 
 	const std::string GetName() const { return &quot;lua&quot;; }
 

Modified: branches/gml/rts/Game/Camera/OverheadController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/OverheadController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/OverheadController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -13,9 +13,8 @@
 
 extern Uint8 *keys;
 
-COverheadController::COverheadController(int num)
-	: CCameraController(num),
-	height(500),zscale(0.5f),
+COverheadController::COverheadController()
+	: height(500),zscale(0.5f),
 	oldAltHeight(500),
 	maxHeight(10000),
 	changeAltHeight(true),
@@ -154,7 +153,6 @@
 
 void COverheadController::GetState(std::vector&lt;float&gt;&amp; fv) const
 {
-	fv.push_back(/* 0 */ (float)num);
 	fv.push_back(/* 1 */ pos.x);
 	fv.push_back(/* 2 */ pos.y);
 	fv.push_back(/* 3 */ pos.z);
@@ -168,17 +166,17 @@
 
 bool COverheadController::SetState(const std::vector&lt;float&gt;&amp; fv)
 {
-	if ((fv.size() != 10) || (fv[0] != (float)num)) {
+	if (fv.size() != 9) {
 		return false;
 	}
-	pos.x   =  fv[1];
-	pos.y   =  fv[2];
-	pos.z   =  fv[3];
-	dir.x   =  fv[4];
-	dir.y   =  fv[5];
-	dir.z   =  fv[6];
-	height  =  fv[7];
-	zscale  =  fv[8];
-	flipped = (fv[9] &gt; 0.0f);
+	pos.x   =  fv[0];
+	pos.y   =  fv[1];
+	pos.z   =  fv[2];
+	dir.x   =  fv[3];
+	dir.y   =  fv[4];
+	dir.z   =  fv[5];
+	height  =  fv[6];
+	zscale  =  fv[7];
+	flipped = (fv[8] &gt; 0.0f);
 	return true;
 }

Modified: branches/gml/rts/Game/Camera/OverheadController.h
===================================================================
--- branches/gml/rts/Game/Camera/OverheadController.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/OverheadController.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,7 +7,7 @@
 class COverheadController : public CCameraController
 {
 public:
-	COverheadController(int num);
+	COverheadController();
 
 	const std::string GetName() const { return &quot;ta&quot;; }
 

Modified: branches/gml/rts/Game/Camera/OverviewController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/OverviewController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/OverviewController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -5,8 +5,7 @@
 #include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;LogOutput.h&quot;
 
-COverviewController::COverviewController(int num)
-	: CCameraController(num)
+COverviewController::COverviewController()
 {
 	enabled = false;
 }
@@ -74,7 +73,6 @@
 
 void COverviewController::GetState(std::vector&lt;float&gt;&amp; fv) const
 {
-	fv.push_back(/* 0 */ (float)num);
 	fv.push_back(/* 1 */ pos.x);
 	fv.push_back(/* 2 */ pos.y);
 	fv.push_back(/* 3 */ pos.z);
@@ -82,11 +80,11 @@
 
 bool COverviewController::SetState(const std::vector&lt;float&gt;&amp; fv)
 {
-	if ((fv.size() != 4) || (fv[0] != (float)num)) {
+	if (fv.size() != 3) {
 		return false;
 	}
-	pos.x = fv[1];
-	pos.y = fv[2];
-	pos.z = fv[3];
+	pos.x = fv[0];
+	pos.y = fv[1];
+	pos.z = fv[2];
 	return true;
 }

Modified: branches/gml/rts/Game/Camera/OverviewController.h
===================================================================
--- branches/gml/rts/Game/Camera/OverviewController.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/OverviewController.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -8,7 +8,7 @@
 class COverviewController : public CCameraController
 {
 public:
-	COverviewController(int num);
+	COverviewController();
 
 	const std::string GetName() const { return &quot;ov&quot;; }
 

Modified: branches/gml/rts/Game/Camera/RotOverheadController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/RotOverheadController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/RotOverheadController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -6,18 +6,10 @@
 #include &quot;Map/Ground.h&quot;
 
 
-#ifdef _WIN32
-#define DEFAULT_MOUSE_SCALE 0.01f
-#else
-#define DEFAULT_MOUSE_SCALE 0.003f
-#endif
-
-
-CRotOverheadController::CRotOverheadController(int num)
-	: CCameraController(num),
-	oldHeight(500)
+CRotOverheadController::CRotOverheadController()
+	: oldHeight(500)
 {
-	mouseScale = configHandler.GetFloat(&quot;RotOverheadMouseScale&quot;, DEFAULT_MOUSE_SCALE);
+	mouseScale = configHandler.GetFloat(&quot;RotOverheadMouseScale&quot;, 0.01f);
 	scrollSpeed = configHandler.GetInt(&quot;RotOverheadScrollSpeed&quot;,10)*0.1f;
 	enabled=!!configHandler.GetInt(&quot;RotOverheadEnabled&quot;,1);
 	fov = configHandler.GetFloat(&quot;RotOverheadFOV&quot;, 45.0f);
@@ -108,7 +100,6 @@
 
 void CRotOverheadController::GetState(std::vector&lt;float&gt;&amp; fv) const
 {
-	fv.push_back(/*  0 */ (float)num);
 	fv.push_back(/*  1 */ pos.x);
 	fv.push_back(/*  2 */ pos.y);
 	fv.push_back(/*  3 */ pos.z);
@@ -123,19 +114,19 @@
 
 bool CRotOverheadController::SetState(const std::vector&lt;float&gt;&amp; fv)
 {
-	if ((fv.size() != 11) || (fv[0] != (float)num)) {
+	if (fv.size() != 10) {
 		return false;
 	}
-	pos.x = fv[1];
-	pos.y = fv[2];
-	pos.z = fv[3];
-	dir.x = fv[4];
-	dir.y = fv[5];
-	dir.z = fv[6];
-	camera-&gt;rot.x = fv[7];
-	camera-&gt;rot.y = fv[8];
-	camera-&gt;rot.z = fv[9];
-	oldHeight = fv[10];
+	pos.x = fv[0];
+	pos.y = fv[1];
+	pos.z = fv[2];
+	dir.x = fv[3];
+	dir.y = fv[4];
+	dir.z = fv[5];
+	camera-&gt;rot.x = fv[6];
+	camera-&gt;rot.y = fv[7];
+	camera-&gt;rot.z = fv[8];
+	oldHeight = fv[9];
 	return true;
 }
 

Modified: branches/gml/rts/Game/Camera/RotOverheadController.h
===================================================================
--- branches/gml/rts/Game/Camera/RotOverheadController.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/RotOverheadController.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -8,7 +8,7 @@
 class CRotOverheadController : public CCameraController
 {
 public:
-	CRotOverheadController(int num);
+	CRotOverheadController();
 
 	const std::string GetName() const { return &quot;rot&quot;; }
 

Modified: branches/gml/rts/Game/Camera/SmoothController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/SmoothController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/SmoothController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -15,9 +15,8 @@
 
 extern Uint8 *keys;
 
-SmoothController::SmoothController(int num)
-	: CCameraController(num),
-	height(500),zscale(0.5f),
+SmoothController::SmoothController()
+	: height(500),zscale(0.5f),
 	oldAltHeight(500),
 	maxHeight(10000),
 	changeAltHeight(true),
@@ -199,7 +198,6 @@
 
 void SmoothController::GetState(std::vector&lt;float&gt;&amp; fv) const
 {
-	fv.push_back(/* 0 */ (float)num);
 	fv.push_back(/* 1 */ pos.x);
 	fv.push_back(/* 2 */ pos.y);
 	fv.push_back(/* 3 */ pos.z);
@@ -213,18 +211,18 @@
 
 bool SmoothController::SetState(const std::vector&lt;float&gt;&amp; fv)
 {
-	if ((fv.size() != 10) || (fv[0] != (float)num)) {
+	if (fv.size() != 9) {
 		return false;
 	}
-	pos.x   =  fv[1];
-	pos.y   =  fv[2];
-	pos.z   =  fv[3];
-	dir.x   =  fv[4];
-	dir.y   =  fv[5];
-	dir.z   =  fv[6];
-	height  =  fv[7];
-	zscale  =  fv[8];
-	flipped = (fv[9] &gt; 0.0f);
+	pos.x   =  fv[0];
+	pos.y   =  fv[1];
+	pos.z   =  fv[2];
+	dir.x   =  fv[3];
+	dir.y   =  fv[4];
+	dir.z   =  fv[5];
+	height  =  fv[6];
+	zscale  =  fv[7];
+	flipped = (fv[8] &gt; 0.0f);
 	return true;
 }
 

Modified: branches/gml/rts/Game/Camera/SmoothController.h
===================================================================
--- branches/gml/rts/Game/Camera/SmoothController.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/SmoothController.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -11,7 +11,7 @@
 class SmoothController : public CCameraController
 {
 public:
-	SmoothController(int num);
+	SmoothController();
 	~SmoothController();
 
 	const std::string GetName() const { return &quot;sm&quot;; }

Modified: branches/gml/rts/Game/Camera/TWController.cpp
===================================================================
--- branches/gml/rts/Game/Camera/TWController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/TWController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -10,8 +10,7 @@
 
 extern Uint8 *keys;
 
-CTWController::CTWController(int num)
-	: CCameraController(num)
+CTWController::CTWController()
 {
 	scrollSpeed = configHandler.GetInt(&quot;TWScrollSpeed&quot;,10) * 0.1f;
 	enabled = !!configHandler.GetInt(&quot;TWEnabled&quot;,1);
@@ -110,7 +109,6 @@
 
 void CTWController::GetState(std::vector&lt;float&gt;&amp; fv) const
 {
-	fv.push_back(/* 0 */ (float)num);
 	fv.push_back(/* 1 */ pos.x);
 	fv.push_back(/* 2 */ pos.y);
 	fv.push_back(/* 3 */ pos.z);
@@ -121,14 +119,14 @@
 
 bool CTWController::SetState(const std::vector&lt;float&gt;&amp; fv)
 {
-	if ((fv.size() != 7) || (fv[0] != (float)num)) {
+	if (fv.size() != 6) {
 		return false;
 	}
-	pos.x = fv[1];
-	pos.y = fv[2];
-	pos.z = fv[3];
-	camera-&gt;rot.x = fv[4];
-	camera-&gt;rot.y = fv[5];
-	camera-&gt;rot.z = fv[6];
+	pos.x = fv[0];
+	pos.y = fv[1];
+	pos.z = fv[2];
+	camera-&gt;rot.x = fv[3];
+	camera-&gt;rot.y = fv[4];
+	camera-&gt;rot.z = fv[5];
 	return true;
 }

Modified: branches/gml/rts/Game/Camera/TWController.h
===================================================================
--- branches/gml/rts/Game/Camera/TWController.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Camera/TWController.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,7 +7,7 @@
 class CTWController : public CCameraController
 {
 public:
-	CTWController(int num);
+	CTWController();
 
 	const std::string GetName() const { return &quot;tw&quot;; }
 

Modified: branches/gml/rts/Game/CameraHandler.cpp
===================================================================
--- branches/gml/rts/Game/CameraHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/CameraHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -12,26 +12,26 @@
 #include &quot;Game/Action.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;GlobalStuff.h&quot;
 
 
 CCameraHandler* camHandler = NULL;
 
 
-CCameraHandler::CCameraHandler() : currCamCtrl(camCtrl)
+CCameraHandler::CCameraHandler()
 {
 	cameraTime=0.0f;
 	cameraTimeLeft=0.0f;
-	preControlCamNum=0;
 	
 	//fps camera must always be the first one in the list
 	std::vector&lt;CCameraController*&gt;&amp; camCtrls = camControllers;
-	camCtrls.push_back(new CFPSController         (camCtrls.size())); // 0  (first)
-	camCtrls.push_back(new COverheadController    (camCtrls.size())); // 1
-	camCtrls.push_back(new CTWController          (camCtrls.size())); // 2
-	camCtrls.push_back(new CRotOverheadController (camCtrls.size())); // 3
-	camCtrls.push_back(new CFreeController        (camCtrls.size())); // 4
-	camCtrls.push_back(new SmoothController       (camCtrls.size())); // 5
-	camCtrls.push_back(new COverviewController    (camCtrls.size())); // 6  (last)
+	camCtrls.push_back(new CFPSController()); // 0  (first)
+	camCtrls.push_back(new COverheadController()); // 1
+	camCtrls.push_back(new CTWController()); // 2
+	camCtrls.push_back(new CRotOverheadController()); // 3
+	camCtrls.push_back(new CFreeController()); // 4
+	camCtrls.push_back(new SmoothController()); // 5
+	camCtrls.push_back(new COverviewController()); // 6
 
 	int mode = configHandler.GetInt(&quot;CamMode&quot;, 1);
 	mode = std::max(0, std::min(mode, (int)camControllers.size() - 1));
@@ -57,7 +57,6 @@
 		delete camControllers.back();
 		camControllers.pop_back();
 	}
-	camCtrl = NULL;
 }
 
 
@@ -101,7 +100,6 @@
 		return;
 	}
 
-	preControlCamNum = currCamCtrlNum;
 	CameraTransition(1.0f);
 
 	CCameraController* oldCamCtrl = currCamCtrl;
@@ -115,7 +113,7 @@
 
 void CCameraHandler::PushMode()
 {
-	controllerStack.push(currCamCtrl-&gt;num);
+	controllerStack.push(GetCurrentControllerNum());
 }
 
 

Modified: branches/gml/rts/Game/CameraHandler.h
===================================================================
--- branches/gml/rts/Game/CameraHandler.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/CameraHandler.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -29,16 +29,17 @@
 	void SaveView(const std::string&amp; name);
 	bool LoadView(const std::string&amp; name);
 	
-	CCameraController* &currCamCtrl;
-	std::vector&lt;CCameraController*&gt; camControllers;
+	CCameraController&amp; GetCurrentController() {return *currCamCtrl;};
+	int GetCurrentControllerNum() const {return currCamCtrlNum;};
+	const std::vector&lt;CCameraController*&gt;&amp; GetAvailableControllers() const {return camControllers;};
 	
 	virtual void PushAction(const Action&amp;);
 	
 private:
+	std::vector&lt;CCameraController*&gt; camControllers;
 	std::stack&lt;unsigned&gt; controllerStack;
+	CCameraController* currCamCtrl;
 	int currCamCtrlNum;
-	int preControlCamNum;
-	CCameraController* overviewController;
 	
 	float cameraTime;
 	float cameraTimeLeft;

Modified: branches/gml/rts/Game/Game.cpp
===================================================================
--- branches/gml/rts/Game/Game.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Game.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -10,7 +10,6 @@
 #include &lt;locale&gt;
 
 #include &quot;Rendering/GL/myGL.h&quot;
-#include &lt;GL/glu.h&gt;
 #include &lt;SDL_keyboard.h&gt;
 #include &lt;SDL_keysym.h&gt;
 #include &lt;SDL_mouse.h&gt;
@@ -95,6 +94,7 @@
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;Sim/Path/PathManager.h&quot;
 #include &quot;Sim/Projectiles/Projectile.h&quot;
+#include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Units/COB/CobEngine.h&quot;
 #include &quot;Sim/Units/COB/CobFile.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
@@ -147,6 +147,11 @@
 #include &lt;boost/thread/thread.hpp&gt;
 #include &lt;boost/bind.hpp&gt;
 
+#include &lt;boost/thread/barrier.hpp&gt;
+
+#include &quot;lib/gml/gmlsrv.h&quot;
+gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+
 GLfloat LightDiffuseLand[] = { 0.8f, 0.8f, 0.8f, 1.0f };
 GLfloat LightAmbientLand[] = { 0.2f, 0.2f, 0.2f, 1.0f };
 GLfloat FogLand[] =          { 0.7f, 0.7f, 0.8f, 0.0f };
@@ -158,7 +163,6 @@
 extern bool fullscreen;
 extern string stupidGlobalMapname;
 
-
 CGame* game = NULL;
 
 CR_BIND(CGame, (std::string(&quot;&quot;), std::string(&quot;&quot;), NULL));
@@ -449,6 +453,8 @@
 	lastMoveUpdate = lastframe;
 	lastUpdateRaw = lastframe;
 	updateDeltaSeconds = 0.0f;
+	script = CScriptHandler::Instance().chosenScript;
+	assert(script);
 
 	glFogfv(GL_FOG_COLOR,FogLand);
 	glFogf(GL_FOG_START, 0.0f);
@@ -986,7 +992,7 @@
 				pos += (*it)-&gt;midPos;
 			}
 			pos /= (float)selUnits.size();
-			camCtrl-&gt;SetPos(pos);
+			camHandler-&gt;GetCurrentController().SetPos(pos);
 			camHandler-&gt;CameraTransition(0.6f);
 		}
 	}
@@ -1100,7 +1106,7 @@
 		grouphandlers[gu-&gt;myTeam]-&gt;GroupCommand(9);
 	}
 	else if (cmd == &quot;lastmsgpos&quot;) {
-		camCtrl-&gt;SetPos(infoConsole-&gt;lastMsgPos);
+		camHandler-&gt;GetCurrentController().SetPos(infoConsole-&gt;lastMsgPos);
 		camHandler-&gt;CameraTransition(0.6f);
 	}
 	else if (((cmd == &quot;chat&quot;)     || (cmd == &quot;chatall&quot;) ||
@@ -1993,7 +1999,7 @@
 
 		if (unitName == &quot;all&quot;) {
 		// player entered &quot;.give all&quot;
-			int sqSize = (int) ceil(sqrt((float) unitDefHandler-&gt;numUnitDefs));
+			int sqSize = (int) streflop::ceil(streflop::sqrt((float) unitDefHandler-&gt;numUnitDefs));
 			int currentNumUnits = gs-&gt;Team(team)-&gt;units.size();
 			int numRequestedUnits = unitDefHandler-&gt;numUnitDefs;
 
@@ -2034,7 +2040,7 @@
 			if (unitDef != NULL) {
 				int xsize = unitDef-&gt;xsize;
 				int zsize = unitDef-&gt;ysize;
-				int squareSize = (int) ceil(sqrt((float) numRequestedUnits));
+				int squareSize = (int) streflop::ceil(streflop::sqrt((float) numRequestedUnits));
 				int total = numRequestedUnits;
 
 				float3 minpos = pos;
@@ -2066,7 +2072,7 @@
 				if (featureDef) {
 					int xsize = featureDef-&gt;xsize;
 					int zsize = featureDef-&gt;ysize;
-					int squareSize = (int) ceil(sqrt((float) numRequestedUnits));
+					int squareSize = (int) streflop::ceil(streflop::sqrt((float) numRequestedUnits));
 					int total = amount; // FIXME -- feature count limit?
 
 					float3 minpos = pos;
@@ -2271,8 +2277,6 @@
 	good_fpu_control_registers(&quot;CGame::Update&quot;);
 
 	mouse-&gt;EmptyMsgQueUpdate();
-	script = CScriptHandler::Instance().chosenScript;
-	assert(script);
 	thisFps++;
 
 	unsigned timeNow = SDL_GetTicks();
@@ -2316,7 +2320,8 @@
 		CInputReceiver::CollectGarbage();
 	}
 
-	UpdateUI();
+	if (!skipping)
+		UpdateUI();
 	net-&gt;Update();
 
 #ifdef DEBUG
@@ -2394,6 +2399,7 @@
 	//transparent stuff
 	glEnable(GL_BLEND);
 	glDepthFunc(GL_LEQUAL);
+
 	if (drawGround) {
 		if (treeDrawer-&gt;drawTrees) {
 			treeDrawer-&gt;DrawGrass();
@@ -2484,9 +2490,22 @@
 	return true;
 }
 
+#if GML_ENABLE_DRAWALL
+bool CGame::Draw() {
+#else
+bool CGame::DrawMT() {
+#endif
+	gmlProcessor.Work(&amp;CGame::DrawMTcb,NULL,NULL,this,gmlThreadCount,TRUE,NULL,1,2,2,FALSE);
+	return TRUE;
+}
 
-bool CGame::Draw()
-{
+
+#if GML_ENABLE_DRAWALL
+bool CGame::DrawMT() {
+#else
+bool CGame::Draw() {
+#endif
+
 	ASSERT_UNSYNCED_MODE;
 
 	SetDrawMode(normalDraw);
@@ -2834,7 +2853,7 @@
 	const float cw = fontScale * font-&gt;CalcCharWidth(c);
 	const float csx = inputTextPosX + (fontScale * caretWidth);
 	glDisable(GL_TEXTURE_2D);
-	const float f = 0.5f * (1.0f + sin((float)SDL_GetTicks() * 0.015f));
+	const float f = 0.5f * (1.0f + streflop::sin((float)SDL_GetTicks() * 0.015f));
 	glColor4f(f, f, f, 0.75f);
 	glRectf(csx, inputTextPosY, csx + cw, inputTextPosY + font-&gt;GetHeight() * fontScale);
 	glEnable(GL_TEXTURE_2D);
@@ -2877,11 +2896,33 @@
 //	grouphandler-&gt;team=gu-&gt;myTeam;
 	CLuaUI::UpdateTeams();
 	ENTER_SYNCED;
+	script-&gt;GameStart();
 
 }
 
-void CGame::SimFrame()
-{
+
+// This will be run by a separate thread in parallel with the Sim
+// ONLY 100% THREAD SAFE UNSYNCED STUFF HERE PLEASE
+void CGame::UnsyncedStuff() {
+	if(!skipping) {
+		infoConsole-&gt;Update();
+	}
+}
+
+
+#if GML_ENABLE_SIM
+void CGame::SimFrame() {
+#else
+void CGame::SimFrameMT() {
+#endif
+	gmlProcessor.Work(&amp;CGame::SimFrameMTcb,NULL,NULL,this,2,FALSE,NULL,1,2,2,FALSE,&amp;CGame::UnsyncedStuffcb);
+}
+
+#if GML_ENABLE_SIM
+void CGame::SimFrameMT() {
+#else
+void CGame::SimFrame() {
+#endif
 	good_fpu_control_registers(&quot;CGame::SimFrame&quot;);
 	lastFrameTime = SDL_GetTicks();
 	ASSERT_SYNCED_MODE;
@@ -2907,7 +2948,10 @@
 	ENTER_UNSYNCED;
 
 	if (!skipping) {
-		infoConsole-&gt;Update();
+#if !GML_ENABLE_SIM
+    UnsyncedStuff();
+#endif
+//		infoConsole-&gt;Update();
 		waitCommandsAI.Update();
 		geometricObjects-&gt;Update();
 		if(!(gs-&gt;frameNum &amp; 7))
@@ -3081,11 +3125,12 @@
 		if(que &lt; leastQue)
 			leastQue = que;
 	}
-
-	// make sure ClientReadNet returns at least every 15 game frames
-	// so CGame can process keyboard input, and render etc.
-	if (gameServer)
+	else
+	{
+		// make sure ClientReadNet returns at least every 15 game frames
+		// so CGame can process keyboard input, and render etc.
 		timeLeft = 15.0f;
+	}
 
 	// really process the messages
 	while (timeLeft &gt; 0.0f &amp;&amp; (packet = net-&gt;GetData()) != NULL)
@@ -3317,6 +3362,9 @@
 
 			case NETMSG_KEYFRAME: {
 				int serverframenum = *(int*)(inbuf+1);
+#ifndef SYNCCHECK
+				net-&gt;SendKeyFrame(serverframenum-1);
+#endif
 				if (gs-&gt;frameNum == (serverframenum - 1))
 				{
 					// everything ok, fall through
@@ -3335,8 +3383,6 @@
 				net-&gt;SendSyncResponse(gu-&gt;myPlayerNum, gs-&gt;frameNum, CSyncChecker::GetChecksum());
 				if ((gs-&gt;frameNum &amp; 4095) == 0) // reset checksum every ~2.5 minute gametime
 					CSyncChecker::NewFrame();
-#else
-				net-&gt;SendNewFrame();
 #endif
 				AddTraffic(-1, packetCode, dataLength);
 
@@ -3666,7 +3712,7 @@
 								}
 								camHandler-&gt;PushMode();
 								camHandler-&gt;SetCameraMode(0);
-								((CFPSController*)camCtrl)-&gt;SetPos(unit-&gt;midPos);
+								dynamic_cast&lt;CFPSController&amp;&gt;(camHandler-&gt;GetCurrentController()).SetPos(unit-&gt;midPos);
 								selectedUnits.ClearSelected();
 							}
 							ENTER_SYNCED;
@@ -3734,9 +3780,6 @@
 
 void CGame::UpdateUI()
 {
-	if (skipping) {
-		return;
-	}
 	ASSERT_UNSYNCED_MODE;
 	//move camera if arrow keys pressed
 #ifdef DIRECT_CONTROL_ALLOWED
@@ -3750,7 +3793,7 @@
 		float3 pos=owner-&gt;pos+owner-&gt;frontdir*relPos.z+owner-&gt;updir*relPos.y+owner-&gt;rightdir*relPos.x;
 		pos+=UpVector*7;
 
-		((CFPSController*)camHandler-&gt;camControllers[0])-&gt;SetPos(pos);
+		camHandler-&gt;GetCurrentController().SetPos(pos);
 	} else
 #endif
 	{
@@ -3781,11 +3824,11 @@
 			disableTracker = true;
 		}
 
-		if (disableTracker &amp;&amp; camCtrl-&gt;DisableTrackingByKey()) {
+		if (disableTracker &amp;&amp; camHandler-&gt;GetCurrentController().DisableTrackingByKey()) {
 			unitTracker.Disable();
 		}
 		movement.z = cameraSpeed;
-		camCtrl-&gt;KeyMove(movement);
+		camHandler-&gt;GetCurrentController().KeyMove(movement);
 
 		movement=float3(0,0,0);
 
@@ -3810,15 +3853,15 @@
 			}
 		}
 		movement.z=cameraSpeed;
-		camCtrl-&gt;ScreenEdgeMove(movement);
+		camHandler-&gt;GetCurrentController().ScreenEdgeMove(movement);
 
 		if(camMove[4])
-			camCtrl-&gt;MouseWheelMove(gu-&gt;lastFrameTime*200*cameraSpeed);
+			camHandler-&gt;GetCurrentController().MouseWheelMove(gu-&gt;lastFrameTime*200*cameraSpeed);
 		if(camMove[5])
-			camCtrl-&gt;MouseWheelMove(-gu-&gt;lastFrameTime*200*cameraSpeed);
+			camHandler-&gt;GetCurrentController().MouseWheelMove(-gu-&gt;lastFrameTime*200*cameraSpeed);
 	}
 
-	camCtrl-&gt;Update();
+	camHandler-&gt;GetCurrentController().Update();
 
 	if(chatting &amp;&amp; !userWriting){
 		consoleHistory-&gt;AddLine(userInput);
@@ -4021,7 +4064,7 @@
 
 			glBegin(GL_LINE_STRIP);
 			for(int b=0;b&lt;=80;++b){
-				glVertexf3(pos+(v2*sin(b*2*PI/80)+v3*cos(b*2*PI/80))*radius);
+				glVertexf3(pos+(v2*streflop::sin(b*2*PI/80)+v3*streflop::cos(b*2*PI/80))*radius);
 			}
 			glEnd();
 
@@ -4035,7 +4078,7 @@
 
 				glBegin(GL_LINE_STRIP);
 				for(int b=0;b&lt;=80;++b){
-					glVertexf3(pos+(v2*sin(b*2*PI/80)+v3*cos(b*2*PI/80))*radius);
+					glVertexf3(pos+(v2*streflop::sin(b*2*PI/80)+v3*streflop::cos(b*2*PI/80))*radius);
 				}
 				glEnd();
 			}
@@ -4044,11 +4087,11 @@
 				glVertexf3(pos);
 				glVertexf3(w-&gt;targetPos);
 
-				glVertexf3(pos+(v2*sin(PI*0.25f)+v3*cos(PI*0.25f))*radius);
-				glVertexf3(pos+(v2*sin(PI*1.25f)+v3*cos(PI*1.25f))*radius);
+				glVertexf3(pos+(v2*streflop::sin(PI*0.25f)+v3*streflop::cos(PI*0.25f))*radius);
+				glVertexf3(pos+(v2*streflop::sin(PI*1.25f)+v3*streflop::cos(PI*1.25f))*radius);
 
-				glVertexf3(pos+(v2*sin(PI*-0.25f)+v3*cos(PI*-0.25f))*radius);
-				glVertexf3(pos+(v2*sin(PI*-1.25f)+v3*cos(PI*-1.25f))*radius);
+				glVertexf3(pos+(v2*streflop::sin(PI*-0.25f)+v3*streflop::cos(PI*-0.25f))*radius);
+				glVertexf3(pos+(v2*streflop::sin(PI*-1.25f)+v3*streflop::cos(PI*-1.25f))*radius);
 			}
 			if((w-&gt;targetPos-camera-&gt;pos).Normalize().dot(camera-&gt;forward)&lt;0.7f){
 				glVertexf3(w-&gt;targetPos);

Modified: branches/gml/rts/Game/Game.h
===================================================================
--- branches/gml/rts/Game/Game.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/Game.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,17 +7,11 @@
 
 #include &lt;time.h&gt;
 #include &lt;string&gt;
-#include &lt;deque&gt;
-#include &lt;set&gt;
 #include &lt;map&gt;
 #include &quot;SDL_types.h&quot;
 
-#include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
-#include &quot;Player.h&quot;
 #include &quot;GameController.h&quot;
 
-#define FRAME_HISTORY 16
-
 class CScript;
 class CBaseWater;
 class CAVIGenerator;
@@ -34,14 +28,17 @@
 {
 public:
 	CR_DECLARE(CGame);			//Don't use CGame pointer in CR_MEMBER()!!!
-	void UpdateUI();
-	void ClientReadNet();
 	void PostLoad();
 
-	void SimFrame();
-	void StartPlaying();
-	bool DrawWorld();
+	void SimFrameMT();
+	static void SimFrameMTcb(void *c) {((CGame *)c)-&gt;SimFrameMT();}
+
 	bool Draw();
+	bool DrawMT();
+
+	static void DrawMTcb(void *c) {((CGame *)c)-&gt;DrawMT();}
+	void UnsyncedStuff();
+	static void UnsyncedStuffcb(void *c) {((CGame *)c)-&gt;UnsyncedStuff();}
 	bool Update();
 	int KeyReleased(unsigned short k);
 	int KeyPressed(unsigned short k,bool isRepeat);
@@ -175,6 +172,13 @@
 	std::map&lt;int, PlayerTrafficInfo&gt; playerTraffic;
 
 private:
+	void ClientReadNet();
+	void UpdateUI();
+	bool DrawWorld();
+	
+	void SimFrame();
+	void StartPlaying();
+	
 	// to smooth out SimFrame calls
 	int leastQue;       ///&lt; Lowest value of que in the past second.
 	float timeLeft;     ///&lt; How many SimFrame() calls we still may do.

Modified: branches/gml/rts/Game/GameController.cpp
===================================================================
--- branches/gml/rts/Game/GameController.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/GameController.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -30,9 +30,16 @@
 {
 	return true;
 }
+/*
+bool CGameController::Draw2(void)
+{
+	return true;
+}*/
+/*bool CGameController::DrawMT(void)
+{
+	return true;
+}*/
 
-
-
 bool CGameController::Update(void)
 {
 	return true;

Modified: branches/gml/rts/Game/GameHelper.h
===================================================================
--- branches/gml/rts/Game/GameHelper.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/GameHelper.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -83,8 +83,8 @@
 	std::list&lt;WaitingDamage*&gt; waitingDamages[128];		//probably a symptom of some other problems but im getting paranoid about putting whole classes into high trafic stl containers instead of pointers to them
 
 private:
-	bool CGameHelper::TestConeHelper(const float3&amp; from, const float3&amp; dir, float length, float spread, const CUnit* u);
-	bool CGameHelper::TestTrajectoryConeHelper(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, const CUnit* u);
+	bool TestConeHelper(const float3&amp; from, const float3&amp; dir, float length, float spread, const CUnit* u);
+	bool TestTrajectoryConeHelper(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, const CUnit* u);
 };
 
 extern CGameHelper* helper;

Modified: branches/gml/rts/Game/GameServer.cpp
===================================================================
--- branches/gml/rts/Game/GameServer.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/GameServer.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,7 +4,9 @@
 #include &lt;ctime&gt;
 #include &lt;boost/bind.hpp&gt;
 #include &lt;boost/format.hpp&gt;
+#include &lt;boost/version.hpp&gt;
 #include &lt;SDL_timer.h&gt;
+#include &lt;cmath&gt;
 
 #ifndef NO_AVI
 #include &quot;Game.h&quot;
@@ -28,6 +30,10 @@
 #include &lt;iostream&gt;
 #endif
 
+#if _MSC_VER 
+namespace std { using ::ceil; }
+#endif
+
 /// frames until a syncchech will time out and a warning is given out
 const int SYNCCHECK_TIMEOUT = 300;
 
@@ -209,42 +215,11 @@
 		// fast-read and send demo data
 		while (serverframenum &lt; targetframe)
 		{
-			unsigned char demobuffer[netcode::NETWORK_BUFFER_SIZE];
-			unsigned length = 0;
-	
-			if ( (length = demoReader-&gt;GetData(demobuffer, netcode::NETWORK_BUFFER_SIZE, modGameTime)) &gt; 0 )
-			{
-				if (demobuffer[0] == NETMSG_NEWFRAME || demobuffer[0] == NETMSG_KEYFRAME)
-				{
-					serverframenum++;
-					if (demobuffer[0] == NETMSG_KEYFRAME)
-						serverNet-&gt;SendKeyFrame(serverframenum);
-					else
-						serverNet-&gt;SendNewFrame();
-	
-				}
-				else if ( demobuffer[0] != NETMSG_GAMEDATA &amp;&amp;
-						demobuffer[0] != NETMSG_SETPLAYERNUM &amp;&amp;
-						demobuffer[0] != NETMSG_USER_SPEED &amp;&amp;
-						demobuffer[0] != NETMSG_INTERNAL_SPEED &amp;&amp;
-						demobuffer[0] != NETMSG_PAUSE) // dont send these from demo
-				{
-					serverNet-&gt;RawSend(demobuffer, length);
-				}
-			}
 			modGameTime = demoReader-&gt;GetNextReadTime()+0.1f; // skip time
-	
-			if (demoReader-&gt;ReachedEnd()) {
-				delete demoReader;
-				demoReader = 0;
-				log.Message(DemoEnd);
-				gameEndTime = SDL_GetTicks();
-				break;
-			}
+			SendDemoData(true);
 			if (serverframenum % 20 == 0)
 				serverNet-&gt;Update(); // send some data
 		}
-		lastTick = SDL_GetTicks();
 		CommandMessage msg2(&quot;skip end&quot;, SERVER_PLAYER);
 		serverNet-&gt;SendData(msg2.Pack());
 		serverNet-&gt;Update();
@@ -267,6 +242,43 @@
 	return playerstring;
 }
 
+void CGameServer::SendDemoData(const bool skipping)
+{
+	RawPacket* buf = 0;
+	while ( (buf = demoReader-&gt;GetData(modGameTime)) )
+	{
+		unsigned msgCode = static_cast&lt;unsigned&gt;(buf-&gt;data[0]);
+		if (msgCode == NETMSG_NEWFRAME || msgCode == NETMSG_KEYFRAME)
+		{
+			// we can't use CreateNewFrame() here
+			lastTick = SDL_GetTicks();
+			serverframenum++;
+#ifdef SYNCCHECK
+			if (!skipping)
+				outstandingSyncFrames.push_back(serverframenum);
+#endif
+			serverNet-&gt;SendData(buf);
+		}
+		else if ( msgCode != NETMSG_GAMEDATA &amp;&amp;
+						msgCode != NETMSG_SETPLAYERNUM &amp;&amp;
+						msgCode != NETMSG_USER_SPEED &amp;&amp;
+						msgCode != NETMSG_INTERNAL_SPEED &amp;&amp;
+						msgCode != NETMSG_PAUSE) // dont send these from demo
+		{
+			if (msgCode == NETMSG_GAMEOVER)
+				sentGameOverMsg = true;
+			serverNet-&gt;SendData(buf);
+		}
+	}
+
+	if (demoReader-&gt;ReachedEnd()) {
+		delete demoReader;
+		demoReader = 0;
+		log.Message(DemoEnd);
+		gameEndTime = SDL_GetTicks();
+	}
+}
+
 void CGameServer::Message(const std::string&amp; message)
 {
 	serverNet-&gt;SendSystemMessage(SERVER_PLAYER, message);
@@ -399,45 +411,10 @@
 	}
 
 	// when hosting a demo, read from file and broadcast data
-	if (demoReader != 0) {
-		unsigned char demobuffer[netcode::NETWORK_BUFFER_SIZE];
-		unsigned length = 0;
-
-		while ( (length = demoReader-&gt;GetData(demobuffer, netcode::NETWORK_BUFFER_SIZE, modGameTime)) &gt; 0 ) {
-			if (demobuffer[0] == NETMSG_NEWFRAME || demobuffer[0] == NETMSG_KEYFRAME)
-			{
-				// we can't use CreateNewFrame() here
-				CheckSync();
-				lastTick = SDL_GetTicks();
-				serverframenum++;
-				if (demobuffer[0] == NETMSG_KEYFRAME)
-					serverNet-&gt;SendKeyFrame(serverframenum);
-				else
-					serverNet-&gt;SendNewFrame();
-#ifdef SYNCCHECK
-				outstandingSyncFrames.push_back(serverframenum);
-#endif
-			}
-			else if ( demobuffer[0] != NETMSG_GAMEDATA &amp;&amp;
-			          demobuffer[0] != NETMSG_SETPLAYERNUM &amp;&amp;
-			          demobuffer[0] != NETMSG_USER_SPEED &amp;&amp;
-			          demobuffer[0] != NETMSG_INTERNAL_SPEED &amp;&amp;
-			          demobuffer[0] != NETMSG_PAUSE) // dont send these from demo
-			{
-				serverNet-&gt;RawSend(demobuffer, length);
-			}
-			else if ( demobuffer[0] != NETMSG_GAMEOVER )
-			{
-				sentGameOverMsg = true;
-			}
-		}
-
-		if (demoReader-&gt;ReachedEnd()) {
-			delete demoReader;
-			demoReader = 0;
-			log.Message(DemoEnd);
-			gameEndTime = SDL_GetTicks();
-		}
+	if (demoReader != 0)
+	{
+		CheckSync();
+		SendDemoData();
 	}
 
 	ServerReadNet();
@@ -505,7 +482,7 @@
 			{
 				const unsigned char* inbuf = packet-&gt;data;
 				switch (inbuf[0]){
-					case NETMSG_NEWFRAME:
+					case NETMSG_KEYFRAME:
 						players[a]-&gt;ping = serverframenum-*(int*)&amp;inbuf[1];
 						break;
 
@@ -685,7 +662,7 @@
 								delayedSyncResponseFrame = serverframenum;
 								log.Warning(format(DelayedSyncResponse) %players[a]-&gt;name %frameNum %serverframenum);
 							}
-							// update players' ping (if !defined(SYNCCHECK) this is done in NETMSG_NEWFRAME)
+							// update players' ping (if !defined(SYNCCHECK) this is done in NETMSG_KEYFRAME)
 							players[a]-&gt;ping = serverframenum - frameNum;
 						}
 #endif
@@ -1027,10 +1004,12 @@
 
 	GenerateAndSendGameID();
 	if (setup) {
-		for (int a = 0; a &lt; MAX_TEAMS; ++a)
+		for (int a = 0; a &lt; setup-&gt;numTeams; ++a)
 		{
-			if (teams[a])
+			if (teams[a]) // its a player
 				serverNet-&gt;SendStartPos(SERVER_PLAYER, a, 1, teams[a]-&gt;startpos.x, teams[a]-&gt;startpos.y, teams[a]-&gt;startpos.z);
+			else // maybe an AI?
+				serverNet-&gt;SendStartPos(SERVER_PLAYER, a, 1, setup-&gt;startPos[a].x, setup-&gt;startPos[a].y, setup-&gt;startPos[a].z);
 		}
 	}
 
@@ -1210,7 +1189,14 @@
 
 void CGameServer::CreateNewFrame(bool fromServerThread, bool fixedFrameTime)
 {
+#if BOOST_VERSION &gt;= 103500
+	if (!fromServerThread)
+		boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex, boost::defer_lock);
+	else
+		boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex);
+#else
 	boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex,!fromServerThread);
+#endif
 	CheckSync();
 	int newFrames = 1;
 
@@ -1229,7 +1215,7 @@
 
 		timeLeft+=GAME_SPEED*internalSpeed*float(timeElapsed)/1000.0f;
 		lastTick=currentTick;
-		newFrames = (timeLeft &gt; 0) ? ceil(timeLeft) : 0;
+		newFrames = (timeLeft &gt; 0) ? std::ceil(timeLeft) : 0;
 		timeLeft -= newFrames;
 	}
 

Modified: branches/gml/rts/Game/GameServer.h
===================================================================
--- branches/gml/rts/Game/GameServer.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/GameServer.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -117,6 +117,9 @@
 	void GenerateAndSendGameID();
 	std::string GetPlayerNames(const std::vector&lt;int&gt;&amp; indices) const;
 	
+	/// read data from demo and send it to clients
+	void SendDemoData(const bool skipping=false);
+	
 	/**
 	@brief skip frames
 	

Modified: branches/gml/rts/Game/PlayerRoster.cpp
===================================================================
--- branches/gml/rts/Game/PlayerRoster.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/PlayerRoster.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,7 +7,6 @@
 #include &quot;Player.h&quot;
 #include &quot;Team.h&quot;
 
-
 static int CompareAllies     (const void* a, const void* b);
 static int CompareTeamIDs    (const void* a, const void* b);
 static int ComparePlayerNames(const void* a, const void* b);

Modified: branches/gml/rts/Game/PreGame.cpp
===================================================================
--- branches/gml/rts/Game/PreGame.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/PreGame.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -5,11 +5,13 @@
 #include &lt;SDL_timer.h&gt;
 #include &lt;SDL_types.h&gt;
 #include &lt;set&gt;
+#include &lt;cmath&gt;
 #include &quot;Game.h&quot;
 #include &quot;Team.h&quot;
 #include &quot;FPUCheck.h&quot;
 #include &quot;GameServer.h&quot;
 #include &quot;GameSetup.h&quot;
+#include &quot;GameData.h&quot;
 #include &quot;NetProtocol.h&quot;
 #include &quot;DemoRecorder.h&quot;
 #include &quot;DemoReader.h&quot;
@@ -31,6 +33,13 @@
 #include &quot;UI/MouseHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
+// msvc behaves really strange
+#if _MSC_VER
+namespace std {
+	using ::cos;
+	using ::sin;
+}
+#endif
 
 CPreGame* pregame=0;
 
@@ -257,7 +266,7 @@
 		const float cw = fontScale * font-&gt;CalcCharWidth(c);
 		const float csx = xStart + (fontScale * caretWidth);
 		glDisable(GL_TEXTURE_2D);
-		const float f = 0.5f * (1.0f + sin((float)SDL_GetTicks() * 0.015f));
+		const float f = 0.5f * (1.0f + std::sin((float)SDL_GetTicks() * 0.015f));
 		glColor4f(f, f, f, 0.75f);
 		glRectf(csx, yStart, csx + cw, yStart + fontScale * font-&gt;GetHeight());
 		glEnable(GL_TEXTURE_2D);
@@ -486,17 +495,17 @@
 	logOutput.Print(&quot;Pre-scanning demo file for game data...&quot;);
 	CDemoReader scanner(demoName, 0);
 
-	unsigned char demobuffer[netcode::NETWORK_BUFFER_SIZE];
-	unsigned length = 0;
 	gu-&gt;myPlayerNum = scanner.GetFileHeader().maxPlayerNum + 1;
 
-	while ( (length = scanner.GetData(demobuffer, netcode::NETWORK_BUFFER_SIZE, INT_MAX)) &gt; 0) {
-		if (demobuffer[0] == NETMSG_GAMEDATA)
+	RawPacket* buf = 0;
+	while ( (buf = scanner.GetData(static_cast&lt;float&gt;(INT_MAX))) ) {
+		if (buf-&gt;data[0] == NETMSG_GAMEDATA)
 		{
-			const RawPacket packet(demobuffer, length);
-			serverStartupData = new GameData(packet);
+			serverStartupData = new GameData(*buf);
+			delete buf;
 			break;
 		}
+		delete buf;
 		if (scanner.ReachedEnd())
 		{
 			throw content_error(&quot;End of demo reached and no game data found&quot;);

Modified: branches/gml/rts/Game/PreGame.h
===================================================================
--- branches/gml/rts/Game/PreGame.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/PreGame.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,13 +4,12 @@
 #include &lt;string&gt;
 
 #include &quot;GameController.h&quot;
-#include &quot;GameData.h&quot;
 
 class CglList;
 class CInfoConsole;
 class CLoadSaveHandler;
-
-namespace netcode{
+class GameData;
+namespace netcode {
 	class RawPacket;
 }
 

Modified: branches/gml/rts/Game/SelectedUnits.cpp
===================================================================
--- branches/gml/rts/Game/SelectedUnits.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/SelectedUnits.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -822,7 +822,12 @@
 	netcode::PackPacket* packet = new netcode::PackPacket(msgLen);
 	*packet &lt;&lt; static_cast&lt;unsigned char&gt;(NETMSG_AICOMMANDS) &lt;&lt; static_cast&lt;unsigned short&gt;(msgLen) &lt;&lt; static_cast&lt;unsigned char&gt;(gu-&gt;myPlayerNum);
 	
-	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(unitIDCount) &lt;&lt; unitIDs;
+	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(unitIDCount);
+	for (std::vector&lt;int&gt;::const_iterator it = unitIDs.begin(); it != unitIDs.end(); ++it)
+	{
+		*packet &lt;&lt; static_cast&lt;short&gt;(*it);
+	}
+
 	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(commandCount);
 	for (unsigned i = 0; i &lt; commandCount; ++i) {
 		const Command&amp; cmd = commands[i];

Modified: branches/gml/rts/Game/SelectedUnits.h
===================================================================
--- branches/gml/rts/Game/SelectedUnits.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/SelectedUnits.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -57,8 +57,7 @@
 	void SetCommandPage(int page);
 	void SendSelection(void);
 	void SendCommand(Command&amp; c);
-	void SendCommandsToUnits(const vector&lt;int&gt;&amp; unitIDs,
-	                         const vector&lt;Command&gt;&amp; commands);
+	void SendCommandsToUnits(const vector&lt;int&gt;&amp; unitIDs, const vector&lt;Command&gt;&amp; commands);
 };
 
 extern CSelectedUnits selectedUnits;

Modified: branches/gml/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/StartScripts/CommanderScript.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -32,12 +32,8 @@
 }
 
 
-void CCommanderScript::Update(void)
+void CCommanderScript::GameStart()
 {
-	if (gs-&gt;frameNum != 0) {
-		return;
-	}
-
 	if (gameSetup) {
 		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
 

Modified: branches/gml/rts/Game/StartScripts/CommanderScript.h
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/StartScripts/CommanderScript.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -9,7 +9,7 @@
 public:
 	CCommanderScript(void);
 	virtual ~CCommanderScript(void);
-	void Update(void);
+	virtual void GameStart();
 };
 
 #endif // __COMMANDER_SCRIPT_H__

Modified: branches/gml/rts/Game/StartScripts/Script.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/Script.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/StartScripts/Script.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -41,6 +41,9 @@
 {
 }
 
+void CScript::GameStart()
+{
+}
 
 std::string CScript::GetMapName()
 {

Modified: branches/gml/rts/Game/StartScripts/Script.h
===================================================================
--- branches/gml/rts/Game/StartScripts/Script.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/StartScripts/Script.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -17,6 +17,7 @@
 	virtual ~CScript();
 
 	virtual void ScriptSelected();
+	virtual void GameStart();
 	virtual std::string GetMapName();
 	virtual std::string GetModName();
 

Modified: branches/gml/rts/Game/UI/EndGameBox.cpp
===================================================================
--- branches/gml/rts/Game/UI/EndGameBox.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/UI/EndGameBox.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -21,11 +21,11 @@
 
 	if(num==0)
 		return &quot;0&quot;;
-	if(fabs(num)&lt;10*mul){
+	if(std::fabs(num)&lt;10*mul){
 		sprintf(c,&quot;%.1f&quot;,num);
-	} else if(fabs(num)&lt;10000*mul){
+	} else if(std::fabs(num)&lt;10000*mul){
 		sprintf(c,&quot;%.0f&quot;,num);
-	} else if(fabs(num)&lt;10000000*mul){
+	} else if(std::fabs(num)&lt;10000000*mul){
 		sprintf(c,&quot;%.0fk&quot;,num/1000);
 	} else {
 		sprintf(c,&quot;%.0fM&quot;,num/1000000);
@@ -145,7 +145,7 @@
 
 	if(dispMode&gt;0){
 		if(mx&gt;box.x1+0.01f &amp;&amp; mx&lt;box.x1+0.12f &amp;&amp; my&lt;box.y1+0.57f &amp;&amp; my&gt;box.y1+0.571f-stats.size()*0.02f){
-			int sel=(int)floor(-(my-box.y1-0.57f)*50);
+			int sel=(int)std::floor(-(my-box.y1-0.57f)*50);
 
 			if(button==1) {
 				stat1=sel;
@@ -277,7 +277,7 @@
 
 		if(mx&gt;box.x1+0.01f &amp;&amp; mx&lt;box.x1+0.12f &amp;&amp; my&lt;box.y1+0.57f &amp;&amp; my&gt;box.y1+0.571f-stats.size()*0.02f){
 
-			int sel=(int)floor(-(my-box.y1-0.57f)*50);
+			int sel=(int)std::floor(-(my-box.y1-0.57f)*50);
 
 			glColor4f(0.7f,0.2f,0.2f,guiAlpha);
 			glDisable(GL_TEXTURE_2D);

Modified: branches/gml/rts/Game/UI/EndGameBox.h
===================================================================
--- branches/gml/rts/Game/UI/EndGameBox.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/UI/EndGameBox.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -5,7 +5,17 @@
 #include &lt;list&gt;
 #include &lt;vector&gt;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &lt;cmath&gt;
 
+
+// msvc behaves really strange
+#if _MSC_VER
+namespace std {
+	using ::fabs;
+	using ::floor;
+}
+#endif
+
 class CEndGameBox :
 	public CInputReceiver
 {
@@ -48,8 +58,8 @@
 		void AddStat(int team,float value){
 			if(value&gt;max)
 				max=value;
-			if(values[team].size()&gt;0 &amp;&amp; fabs(value-values[team].back())&gt;maxdif)
-				maxdif=fabs(value-values[team].back());
+			if(values[team].size()&gt;0 &amp;&amp; std::fabs(value-values[team].back())&gt;maxdif)
+				maxdif=std::fabs(value-values[team].back());
 
 			values[team].push_back(value);
 		}

Modified: branches/gml/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/gml/rts/Game/UI/MiniMap.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/UI/MiniMap.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -640,7 +640,7 @@
 	float3 clickPos;
 	clickPos.x = (float(x - xpos)) / width * gs-&gt;mapx * 8;
 	clickPos.z = (float(y - (gu-&gt;viewSizeY - ypos - height))) / height * gs-&gt;mapy * 8;
-	camCtrl-&gt;SetPos(clickPos);
+	camHandler-&gt;GetCurrentController().SetPos(clickPos);
 	unitTracker.Disable();
 }
 

Modified: branches/gml/rts/Game/UI/MouseHandler.cpp
===================================================================
--- branches/gml/rts/Game/UI/MouseHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/UI/MouseHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -24,6 +24,7 @@
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/Team.h&quot;
+#include &quot;Game/Player.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
@@ -173,7 +174,7 @@
 	}
 
 	if (buttons[SDL_BUTTON_MIDDLE].pressed &amp;&amp; (activeReceiver == NULL)) {
-		camCtrl-&gt;MouseMove(float3(dx, dy, invertMouse ? -1.0f : 1.0f));
+		camHandler-&gt;GetCurrentController().MouseMove(float3(dx, dy, invertMouse ? -1.0f : 1.0f));
 		unitTracker.Disable();
 		return;
 	}
@@ -464,7 +465,7 @@
 	if (luaUI &amp;&amp; luaUI-&gt;MouseWheel(up, value)) {
 		return;
 	}
-	camCtrl-&gt;MouseWheelMove(value);
+	camHandler-&gt;GetCurrentController().MouseWheelMove(value);
 }
 
 
@@ -645,7 +646,7 @@
 	move.x = dx;
 	move.y = dy;
 	move.z = invertMouse? -1.0f : 1.0f;
-	camCtrl-&gt;MouseMove(move);
+	camHandler-&gt;GetCurrentController().MouseMove(move);
 
 	if (gu-&gt;active) {
 		mouseInput-&gt;SetPos(int2(lastx, lasty));

Modified: branches/gml/rts/Game/UI/SelectionKeyHandler.cpp
===================================================================
--- branches/gml/rts/Game/UI/SelectionKeyHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Game/UI/SelectionKeyHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -3,7 +3,6 @@
 #include &lt;SDL_keysym.h&gt;
 #include &lt;SDL_types.h&gt;
 #include &quot;Game/Camera/CameraController.h&quot;
-#include &quot;Game/Camera/FPSController.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/CameraHandler.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
@@ -514,8 +513,8 @@
 
 		selectedUnits.AddUnit(sel);
 		camHandler-&gt;CameraTransition(0.8f);
-		if(camCtrl!=camHandler-&gt;camControllers[0]){
-			camCtrl-&gt;SetPos(sel-&gt;pos);
+		if(camHandler-&gt;GetCurrentControllerNum() != 0){
+			camHandler-&gt;GetCurrentController().SetPos(sel-&gt;pos);
 		} else {	//fps camera
 
 			if(camera-&gt;rot.x&gt;-1)
@@ -527,7 +526,7 @@
 			wantedCamDir.z=(float)(cos(camera-&gt;rot.y)*cos(camera-&gt;rot.x));
 			wantedCamDir.Normalize();
 
-			((CFPSController*)camHandler-&gt;camControllers[0])-&gt;SetPos(sel-&gt;pos - wantedCamDir*800);
+			camHandler-&gt;GetCurrentController().SetPos(sel-&gt;pos - wantedCamDir*800);
 		}
 	} else if(s==&quot;SelectNum&quot;){
 		ReadDelimiter(selectString);

Modified: branches/gml/rts/Lua/LuaMaterial.h
===================================================================
--- branches/gml/rts/Lua/LuaMaterial.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Lua/LuaMaterial.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -202,7 +202,7 @@
 
 	public:
 		void Clear() { units.clear(); }
-		const vector&lt;CUnit*&gt;&amp; GetUnits() const { return units; }
+		const GML_VECTOR&lt;CUnit*&gt;&amp; GetUnits() const { return units; }
 
 		void Ref();
 		void UnRef();
@@ -218,7 +218,7 @@
 
 	private:
 		int refCount;
-		vector&lt;CUnit*&gt; units;
+		GML_VECTOR&lt;CUnit*&gt; units;
 };
 
 

Modified: branches/gml/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- branches/gml/rts/Lua/LuaSyncedCtrl.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Lua/LuaSyncedCtrl.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -1228,7 +1228,7 @@
 	else if (lua_isboolean(L, 3)) {
 		const float defDist = unit-&gt;unitDef-&gt;decloakDistance;
 		if (lua_toboolean(L, 3)) {
-			unit-&gt;decloakDistance = fabsf(defDist);
+			unit-&gt;decloakDistance = streflop::fabsf(defDist);
 		} else {
 			unit-&gt;decloakDistance = defDist;
 		}

Modified: branches/gml/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- branches/gml/rts/Lua/LuaSyncedRead.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Lua/LuaSyncedRead.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -23,6 +23,7 @@
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/Team.h&quot;
+#include &quot;Game/Player.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;

Modified: branches/gml/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnitDefs.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Lua/LuaUnitDefs.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -852,6 +852,7 @@
 	ADD_FLOAT(&quot;frontToSpeed&quot;, ud.frontToSpeed);
 	ADD_FLOAT(&quot;speedToFront&quot;, ud.speedToFront);
 	ADD_FLOAT(&quot;myGravity&quot;,    ud.myGravity);
+	ADD_FLOAT(&quot;verticalSpeed&quot;,ud.verticalSpeed);
 
 	ADD_FLOAT(&quot;maxBank&quot;,      ud.maxBank);
 	ADD_FLOAT(&quot;maxPitch&quot;,     ud.maxPitch);

Modified: branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Lua/LuaUnsyncedCtrl.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -20,6 +20,7 @@
 #include &quot;Game/Game.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/Team.h&quot;
+#include &quot;Game/Player.h&quot;
 #include &quot;Game/UI/CommandColors.h&quot;
 #include &quot;Game/UI/CursorIcons.h&quot;
 #include &quot;Game/UI/MouseHandler.h&quot;
@@ -626,7 +627,7 @@
 		transTime = (float)lua_tonumber(L, 4);
 	}
 
-	camCtrl-&gt;SetPos(pos);
+	camHandler-&gt;GetCurrentController().SetPos(pos);
 	camHandler-&gt;CameraTransition(transTime);
 
 	return 0;
@@ -670,7 +671,7 @@
 		}
 	}
 
-	lua_pushboolean(L, camCtrl-&gt;SetState(camState));
+	lua_pushboolean(L, camHandler-&gt;GetCurrentController().SetState(camState));
 	camHandler-&gt;CameraTransition(camTime);
 
 	if (CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {

Modified: branches/gml/rts/Lua/LuaUnsyncedRead.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnsyncedRead.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Lua/LuaUnsyncedRead.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -636,11 +636,10 @@
 	CheckNoArgs(L, __FUNCTION__);
 
 	lua_newtable(L);
-	const int count = (int)camHandler-&gt;camControllers.size();
-	for (int i = 0; i &lt; count; i++) {
-		const CCameraController* cc = camHandler-&gt;camControllers[i];
-		lua_pushstring(L, cc-&gt;GetName().c_str());
-		lua_pushnumber(L, cc-&gt;num);
+	const std::vector&lt;CCameraController*&gt;&amp; cc = camHandler-&gt;GetAvailableControllers();
+	for (int i = 0; i &lt; cc.size(); ++i) {
+		lua_pushstring(L, cc[i]-&gt;GetName().c_str());
+		lua_pushnumber(L, i);
 		lua_rawset(L, -3);
 	}
 
@@ -655,15 +654,15 @@
 	lua_newtable(L);
 
 	lua_pushstring(L, &quot;mode&quot;);
-	lua_pushnumber(L, camCtrl-&gt;num);
+	lua_pushnumber(L, camHandler-&gt;GetCurrentControllerNum());
 	lua_rawset(L, -3);
 	lua_pushstring(L, &quot;name&quot;);
-	lua_pushstring(L, camCtrl-&gt;GetName().c_str());
+	lua_pushstring(L, camHandler-&gt;GetCurrentController().GetName().c_str());
 	lua_rawset(L, -3);
 
 
 	vector&lt;float&gt; camState;
-	camCtrl-&gt;GetState(camState);
+	camHandler-&gt;GetCurrentController().GetState(camState);
 	for (int i = 0; i &lt; (int)camState.size(); i++) {
 		lua_pushnumber(L, i + 1);
 		lua_pushnumber(L, camState[i]);

Modified: branches/gml/rts/Map/ReadMap.h
===================================================================
--- branches/gml/rts/Map/ReadMap.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/ReadMap.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -6,8 +6,7 @@
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
-#define GLEW_STATIC
-#include &lt;GL/glew.h&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;float3.h&quot;
 #include &quot;MetalMap.h&quot;
 #include &quot;TdfParser.h&quot;

Modified: branches/gml/rts/Map/SM3/Frustum.cpp
===================================================================
--- branches/gml/rts/Map/SM3/Frustum.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SM3/Frustum.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -9,8 +9,7 @@
 
 #include &quot;Frustum.h&quot;
 
-#define GLEW_STATIC
-#include &lt;GL/glew.h&gt; 
+#include &quot;Rendering/GL/myGL.h&quot;
 
 
 void Frustum::InversePlanes ()

Modified: branches/gml/rts/Map/SM3/Sm3GroundDrawer.cpp
===================================================================
--- branches/gml/rts/Map/SM3/Sm3GroundDrawer.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SM3/Sm3GroundDrawer.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -8,8 +8,7 @@
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
-#define GLEW_STATIC
-#include &lt;GL/glew.h&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 
 #include &lt;SDL_keysym.h&gt;

Modified: branches/gml/rts/Map/SM3/Sm3Map.cpp
===================================================================
--- branches/gml/rts/Map/SM3/Sm3Map.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SM3/Sm3Map.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,8 +4,7 @@
 #include &quot;Sm3GroundDrawer.h&quot;
 
 #include &quot;LogOutput.h&quot;
-#define GLEW_STATIC
-#include &lt;GL/glew.h&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;IL/il.h&gt;
 #include &lt;SDL_types.h&gt;
 #include &quot;Rendering/ShadowHandler.h&quot;

Modified: branches/gml/rts/Map/SM3/terrain/QuadRenderData.cpp
===================================================================
--- branches/gml/rts/Map/SM3/terrain/QuadRenderData.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SM3/terrain/QuadRenderData.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -28,8 +28,7 @@
 */
 
 #include &quot;StdAfx.h&quot;
-#define GLEW_STATIC
-#include &lt;GL/glew.h&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
 
 #include &quot;TerrainBase.h&quot;
 #include &quot;TerrainNode.h&quot;

Modified: branches/gml/rts/Map/SM3/terrain/Terrain.cpp
===================================================================
--- branches/gml/rts/Map/SM3/terrain/Terrain.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SM3/terrain/Terrain.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -28,8 +28,7 @@
 */
 #include &quot;StdAfx.h&quot;
 
-#define GLEW_STATIC
-#include &lt;GL/glew.h&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
 
 #include &quot;TerrainBase.h&quot;
 #include &quot;Terrain.h&quot;

Modified: branches/gml/rts/Map/SM3/terrain/TerrainBase.h
===================================================================
--- branches/gml/rts/Map/SM3/terrain/TerrainBase.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SM3/terrain/TerrainBase.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -29,8 +29,7 @@
 #ifndef TERRAIN_BASE_H
 #define TERRAIN_BASE_H
 
-#define GLEW_STATIC
-#include &lt;GL/glew.h&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
 
 #include &quot;../Frustum.h&quot;
 #include &quot;Matrix44f.h&quot;

Modified: branches/gml/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundDrawer.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SMF/BFGroundDrawer.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -13,6 +13,11 @@
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
+#include &quot;lib/gml/gmlsrv.h&quot;
+#define GML_ENABLE_DRAWGROUND 1
+#define GML_ENABLE_DRAWGROUNDSHADOW 1
+extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+
 using std::min;
 using std::max;
 
@@ -86,7 +91,29 @@
 }
 
 
+inline void CBFGroundDrawer::DrawVertexAMT(CVertexArray *ma, int x, int y)
+{
+	float height = heightData[y * heightDataX + x];
+	if (waterDrawn &amp;&amp; height &lt; 0) {
+		height *= 2;
+	}
 
+	ma-&gt;AddVertexQ0(x * SQUARE_SIZE, height, y * SQUARE_SIZE);
+}
+
+inline void CBFGroundDrawer::DrawVertexAMT(CVertexArray *ma, int x, int y, float height)
+{
+	if (waterDrawn &amp;&amp; height &lt; 0) {
+		height *= 2;
+	}
+	ma-&gt;AddVertexQ0(x * SQUARE_SIZE, height, y * SQUARE_SIZE);
+}
+
+inline void CBFGroundDrawer::EndStripMT(CVertexArray *ma)
+{
+	ma-&gt;EndStripQ();
+}
+
 inline bool CBFGroundDrawer::BigTexSquareRowVisible(int bty) {
 	static int mapWidth = (gs-&gt;mapx &lt;&lt; 3);
 	static int bigTexH = (gs-&gt;mapy &lt;&lt; 3) / numBigTexY;
@@ -138,7 +165,486 @@
 }
 
 
+inline void CBFGroundDrawer::DrawGroundVertexArrayMT(CVertexArray * &amp;ma)
+{
+	ma-&gt;DrawArray0(GL_TRIANGLE_STRIP);
+	ma = GetVertexArray();
+	ma-&gt;Initialize();
+}
 
+int neededLod=0;
+int maxIdx=0;
+
+bool CBFGroundDrawer::DrawMT(int bty) {
+	unsigned int overrideVP=mt_overrideVP;
+#define CLAMP(i) std::max(0, std::min((i), maxIdx))
+	if (!BigTexSquareRowVisible(bty)) {
+		// skip this entire row of squares if we can't see it
+		return true;
+	}
+
+	CVertexArray *ma = GetVertexArray();
+	ma-&gt;Initialize();
+
+	bool inStrip = false;
+	int x,y;
+	// only process the necessary big squares in the x direction
+	int sx = 0;
+	int ex = numBigTexX;
+	float x0, x1;
+	std::vector&lt;fline&gt;::iterator fli;
+
+
+	for (fli = left.begin(); fli != left.end(); fli++) {
+		x0 = ((fli-&gt;base / SQUARE_SIZE + fli-&gt;dir *  (bty * bigSquareSize)                 ));
+		x1 = ((fli-&gt;base / SQUARE_SIZE + fli-&gt;dir * ((bty * bigSquareSize) + bigSquareSize)));
+
+		if (x0 &gt; x1)
+			x0 = x1;
+
+		x0 /= bigSquareSize;
+
+		if (x0 &gt; sx)
+			sx = (int) x0;
+	}
+	for (fli = right.begin(); fli != right.end(); fli++) {
+		x0 = ((fli-&gt;base / SQUARE_SIZE + fli-&gt;dir *  (bty * bigSquareSize)                 )) + bigSquareSize;
+		x1 = ((fli-&gt;base / SQUARE_SIZE + fli-&gt;dir * ((bty * bigSquareSize) + bigSquareSize))) + bigSquareSize;
+
+		if (x0 &lt; x1)
+			x0 = x1;
+
+		x0 /= bigSquareSize;
+
+		if (x0 &lt; ex)
+			ex = (int) x0;
+	}
+
+
+	for (int btx = sx; btx &lt; ex; ++btx) {
+		// must be in drawLos mode or shadows must be off
+		if (DrawExtraTex() || !shadowHandler-&gt;drawShadows) {
+			textures-&gt;SetTexture(btx, bty);
+			SetTexGen(1.0f / 1024, 1.0f / 1024, -btx, -bty);
+
+			if (overrideVP) {
+				glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 11, -btx, -bty, 0, 0);
+			}
+		} else {
+			textures-&gt;SetTexture(btx, bty);
+			glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 11, -btx, -bty, 0, 0);
+		}
+
+		for (int lod = 1; lod &lt; neededLod; lod &lt;&lt;= 1) {
+			float cx2 = (cam2-&gt;pos.x / (SQUARE_SIZE));
+			float cy2 = (cam2-&gt;pos.z / (SQUARE_SIZE));
+
+			float oldcamxpart = 0.0f;
+			float oldcamypart = 0.0f;
+
+			int hlod = lod &gt;&gt; 1;
+			int dlod = lod &lt;&lt; 1;
+
+			int cx = (int)cx2;
+			int cy = (int)cy2;
+
+			if(lod&gt;1) {
+				int cxo = (cx / hlod) * hlod;
+				int cyo = (cy / hlod) * hlod;
+				float cx2o = (cxo / lod) * lod;
+				float cy2o = (cyo / lod) * lod;
+				oldcamxpart = (cx2 - cx2o) / (lod);
+				oldcamypart = (cy2 - cy2o) / (lod);
+			}
+
+			cx = (cx / lod) * lod;
+			cy = (cy / lod) * lod;
+			int ysquaremod = ((cy) % (dlod)) / lod;
+			int xsquaremod = ((cx) % (dlod)) / lod;
+
+			float camxpart = (cx2 - ((cx / (dlod)) * dlod)) / (dlod);
+			float camypart = (cy2 - ((cy / (dlod)) * dlod)) / (dlod);
+
+			int minty =  bty      * bigSquareSize;
+			int maxty = (bty + 1) * bigSquareSize;
+			int mintx =  btx      * bigSquareSize;
+			int maxtx = (btx + 1) * bigSquareSize;
+
+			int minly = cy + (-viewRadius + 3 - ysquaremod) * lod;
+			int maxly = cy + ( viewRadius - 1 - ysquaremod) * lod;
+			int minlx = cx + (-viewRadius + 3 - xsquaremod) * lod;
+			int maxlx = cx + ( viewRadius - 1 - xsquaremod) * lod;
+
+			int xstart = max(minlx, mintx);
+			int xend   = min(maxlx, maxtx);
+			int ystart = max(minly, minty);
+			int yend   = min(maxly, maxty);
+
+			for (y = ystart; y &lt; yend; y += lod) {
+				int xs = xstart;
+				int xe = xend;
+				int xt0, xt1;
+				std::vector&lt;fline&gt;::iterator fli;
+
+
+				for (fli = left.begin(); fli != left.end(); fli++) {
+					xt0 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir *  y       )) / lod * lod - lod;
+					xt1 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir * (y + lod))) / lod * lod - lod;
+
+					if (xt0 &gt; xt1) xt0 = xt1;
+					if (xt0 &gt; xs) xs = xt0;
+				}
+				for (fli = right.begin(); fli != right.end(); fli++) {
+					xt0 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir *  y       )) / lod * lod + lod;
+					xt1 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir * (y + lod))) / lod * lod + lod;
+
+					if (xt0 &lt; xt1) xt0 = xt1;
+					if (xt0 &lt; xe) xe = xt0;
+				}
+
+				int nloop=(xe-xs)/lod+1;
+				ma-&gt;EnlargeArrays(52*nloop, 14*nloop+1); // includes one extra for final endstrip
+
+				for (x = xs; x &lt; xe; x += lod) {
+					if ((lod == 1) ||
+						(x &gt; (cx) + viewRadius * hlod) || (x &lt; (cx) - viewRadius * hlod) ||
+						(y &gt; (cy) + viewRadius * hlod) || (y &lt; (cy) - viewRadius * hlod)) {
+							// normal terrain
+							if (!inStrip) {
+								DrawVertexAMT(ma, x, y      );
+								DrawVertexAMT(ma, x, y + lod);
+								inStrip = true;
+							}
+
+							DrawVertexAMT(ma, x + lod, y      );
+							DrawVertexAMT(ma, x + lod, y + lod);
+					} else {
+						// inre begr&#65533;sning mot f&#65533;eg&#65533;nde lod
+						if ((x &gt;= (cx) + viewRadius * hlod)) {
+							int idx1 = CLAMP((y       ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod), idx1HLOD = CLAMP(idx1 + hlod);
+							int idx2 = CLAMP((y +  lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod), idx2HLOD = CLAMP(idx2 + hlod);
+							int idx3 = CLAMP((y + hlod) * heightDataX + x),                              idx3HLOD = CLAMP(idx3 + hlod);
+							float h1 = (heightData[idx1] + heightData[idx2   ]) * 0.5f * (1 - oldcamxpart) + heightData[idx3    ] * (oldcamxpart);
+							float h2 = (heightData[idx1] + heightData[idx1LOD]) * 0.5f * (1 - oldcamxpart) + heightData[idx1HLOD] * (oldcamxpart);
+							float h3 = (heightData[idx2] + heightData[idx1LOD]) * 0.5f * (1 - oldcamxpart) + heightData[idx3HLOD] * (oldcamxpart);
+							float h4 = (heightData[idx2] + heightData[idx2LOD]) * 0.5f * (1 - oldcamxpart) + heightData[idx2HLOD] * (oldcamxpart);
+
+							if (inStrip) {
+								EndStripMT(ma);
+								inStrip = false;
+							}
+
+							DrawVertexAMT(ma, x,        y           );
+							DrawVertexAMT(ma, x,        y + hlod, h1);
+							DrawVertexAMT(ma, x + hlod, y,        h2);
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							EndStripMT(ma);
+							DrawVertexAMT(ma, x,        y + hlod, h1);
+							DrawVertexAMT(ma, x,        y +  lod    );
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							DrawVertexAMT(ma, x + hlod, y +  lod, h4);
+							EndStripMT(ma);
+							DrawVertexAMT(ma, x + hlod, y +  lod, h4);
+							DrawVertexAMT(ma, x +  lod, y +  lod    );
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							DrawVertexAMT(ma, x +  lod, y           );
+							DrawVertexAMT(ma, x + hlod, y,        h2);
+							EndStripMT(ma);
+						}
+						if ((x &lt;= (cx) - viewRadius * hlod)) {
+							int idx1 = CLAMP((y       ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod), idx1HLOD = CLAMP(idx1 + hlod);
+							int idx2 = CLAMP((y +  lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod), idx2HLOD = CLAMP(idx2 + hlod);
+							int idx3 = CLAMP((y + hlod) * heightDataX + x), idx3LOD = CLAMP(idx3 + lod), idx3HLOD = CLAMP(idx3 + hlod);
+							float h1 = (heightData[idx1LOD] + heightData[idx2LOD]) * 0.5f * (oldcamxpart) + heightData[idx3LOD ] * (1 - oldcamxpart);
+							float h2 = (heightData[idx1   ] + heightData[idx1LOD]) * 0.5f * (oldcamxpart) + heightData[idx1HLOD] * (1 - oldcamxpart);
+							float h3 = (heightData[idx2   ] + heightData[idx1LOD]) * 0.5f * (oldcamxpart) + heightData[idx3HLOD] * (1 - oldcamxpart);
+							float h4 = (heightData[idx2   ] + heightData[idx2LOD]) * 0.5f * (oldcamxpart) + heightData[idx2HLOD] * (1 - oldcamxpart);
+
+							if (inStrip) {
+								EndStripMT(ma);
+								inStrip = false;
+							}
+
+							DrawVertexAMT(ma, x +  lod, y + hlod, h1);
+							DrawVertexAMT(ma, x +  lod, y           );
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							DrawVertexAMT(ma, x + hlod, y,        h2);
+							EndStripMT(ma);
+							DrawVertexAMT(ma, x +  lod, y +  lod    );
+							DrawVertexAMT(ma, x +  lod, y + hlod, h1);
+							DrawVertexAMT(ma, x + hlod, y +  lod, h4);
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							EndStripMT(ma);
+							DrawVertexAMT(ma, x + hlod, y,        h2);
+							DrawVertexAMT(ma, x,        y           );
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							DrawVertexAMT(ma, x,        y +  lod    );
+							DrawVertexAMT(ma, x + hlod, y +  lod, h4);
+							EndStripMT(ma);
+						}
+						if ((y &gt;= (cy) + viewRadius * hlod)) {
+							int idx1 = (y       ) * heightDataX + x, idx1LOD = CLAMP(idx1 + lod), idx1HLOD = CLAMP(idx1 + hlod);
+							int idx2 = (y +  lod) * heightDataX + x, idx2LOD = CLAMP(idx2 + lod);
+							int idx3 = (y + hlod) * heightDataX + x, idx3LOD = CLAMP(idx3 + lod), idx3HLOD = CLAMP(idx3 + hlod);
+							float h1 = (heightData[idx1   ] + heightData[idx1LOD]) * 0.5f * (1 - oldcamypart) + heightData[idx1HLOD] * (oldcamypart);
+							float h2 = (heightData[idx1   ] + heightData[idx2   ]) * 0.5f * (1 - oldcamypart) + heightData[idx3    ] * (oldcamypart);
+							float h3 = (heightData[idx2   ] + heightData[idx1LOD]) * 0.5f * (1 - oldcamypart) + heightData[idx3HLOD] * (oldcamypart);
+							float h4 = (heightData[idx2LOD] + heightData[idx1LOD]) * 0.5f * (1 - oldcamypart) + heightData[idx3LOD ] * (oldcamypart);
+
+							if (inStrip) {
+								EndStripMT(ma);
+								inStrip = false;
+							}
+
+							DrawVertexAMT(ma, x,        y           );
+							DrawVertexAMT(ma, x,        y + hlod, h2);
+							DrawVertexAMT(ma, x + hlod, y,        h1);
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							DrawVertexAMT(ma, x +  lod, y           );
+							DrawVertexAMT(ma, x +  lod, y + hlod, h4);
+							EndStripMT(ma);
+							DrawVertexAMT(ma, x,        y + hlod, h2);
+							DrawVertexAMT(ma, x,        y +  lod    );
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							DrawVertexAMT(ma, x +  lod, y +  lod    );
+							DrawVertexAMT(ma, x +  lod, y + hlod, h4);
+							EndStripMT(ma);
+						}
+						if ((y &lt;= (cy) - viewRadius * hlod)) {
+							int idx1 = CLAMP((y       ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod);
+							int idx2 = CLAMP((y +  lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod), idx2HLOD = CLAMP(idx2 + hlod);
+							int idx3 = CLAMP((y + hlod) * heightDataX + x), idx3LOD = CLAMP(idx3 + lod), idx3HLOD = CLAMP(idx3 + hlod);
+							float h1 = (heightData[idx2   ] + heightData[idx2LOD]) * 0.5f * (oldcamypart) + heightData[idx2HLOD] * (1 - oldcamypart);
+							float h2 = (heightData[idx1   ] + heightData[idx2   ]) * 0.5f * (oldcamypart) + heightData[idx3    ] * (1 - oldcamypart);
+							float h3 = (heightData[idx2   ] + heightData[idx1LOD]) * 0.5f * (oldcamypart) + heightData[idx3HLOD] * (1 - oldcamypart);
+							float h4 = (heightData[idx2LOD] + heightData[idx1LOD]) * 0.5f * (oldcamypart) + heightData[idx3LOD ] * (1 - oldcamypart);
+
+							if (inStrip) {
+								EndStripMT(ma);
+								inStrip = false;
+							}
+
+							DrawVertexAMT(ma, x,        y + hlod, h2);
+							DrawVertexAMT(ma, x,        y +  lod    );
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							DrawVertexAMT(ma, x + hlod, y +  lod, h1);
+							DrawVertexAMT(ma, x +  lod, y + hlod, h4);
+							DrawVertexAMT(ma, x +  lod, y +  lod    );
+							EndStripMT(ma);
+							DrawVertexAMT(ma, x +  lod, y + hlod, h4);
+							DrawVertexAMT(ma, x +  lod, y           );
+							DrawVertexAMT(ma, x + hlod, y + hlod, h3);
+							DrawVertexAMT(ma, x,        y           );
+							DrawVertexAMT(ma, x,        y + hlod, h2);
+							EndStripMT(ma);
+						}
+					}
+				}
+
+				if (inStrip) {
+					EndStripMT(ma);
+					inStrip = false;
+				}
+			}
+
+			int yst=max(ystart - lod, minty);
+			int yed=min(yend + lod, maxty);
+			int nloop=(yed-yst)/lod+1;
+			ma-&gt;EnlargeArrays(8*nloop, 2*nloop);
+
+			// rita yttre begr&#65533;snings yta mot n&#65533;ta lod
+			if (maxlx &lt; maxtx &amp;&amp; maxlx &gt;= mintx) {
+				x = maxlx;
+				for (y = yst; y &lt; yed; y += lod) {
+					DrawVertexAMT(ma, x, y      );
+					DrawVertexAMT(ma, x, y + lod);
+
+					if (y % (dlod)) {
+						int idx1 = CLAMP((y      ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod);
+						int idx2 = CLAMP((y + lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod);
+						int idx3 = CLAMP((y - lod) * heightDataX + x), idx3LOD = CLAMP(idx3 + lod);
+						float h = ((heightData[idx3LOD] +
+							heightData[idx2LOD]) * 0.5f) * (1 - camxpart) +
+							heightData[idx1LOD] * (camxpart);
+
+						DrawVertexAMT(ma, x + lod, y,       h);
+						DrawVertexAMT(ma, x + lod, y + lod   );
+					} else {
+						int idx1 = CLAMP((y       ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod);
+						int idx2 = CLAMP((y +  lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod);
+						int idx3 = CLAMP((y + dlod) * heightDataX + x), idx3LOD = CLAMP(idx3 + lod);
+						float h = (heightData[idx1LOD] +
+							heightData[idx3LOD]) * 0.5f * (1 - camxpart) +
+							heightData[idx2LOD] * (camxpart);
+
+						DrawVertexAMT(ma, x + lod, y);
+						DrawVertexAMT(ma, x + lod, y + lod, h);
+					}
+					EndStripMT(ma);
+				}
+			}
+
+			if (minlx &gt; mintx &amp;&amp; minlx &lt; maxtx) {
+				x = minlx - lod;
+				for (y = yst; y &lt; yed; y += lod) {
+					if (y % (dlod)) {
+						int idx1 = CLAMP((y      ) * heightDataX + x);
+						int idx2 = CLAMP((y + lod) * heightDataX + x);
+						int idx3 = CLAMP((y - lod) * heightDataX + x);
+						float h = ((heightData[idx3] +
+							heightData[idx2]) * 0.5f) * (camxpart) +
+							heightData[idx1] * (1 - camxpart);
+
+						DrawVertexAMT(ma, x, y,       h);
+						DrawVertexAMT(ma, x, y + lod   );
+					} else {
+						int idx1 = CLAMP((y       ) * heightDataX + x);
+						int idx2 = CLAMP((y +  lod) * heightDataX + x);
+						int idx3 = CLAMP((y + dlod) * heightDataX + x);
+						float h = (heightData[idx1] +
+							heightData[idx3]) * 0.5f * (camxpart) +
+							heightData[idx2] * (1 - camxpart);
+
+						DrawVertexAMT(ma, x, y);
+						DrawVertexAMT(ma, x, y + lod, h);
+					}
+					DrawVertexAMT(ma, x + lod, y      );
+					DrawVertexAMT(ma, x + lod, y + lod);
+					EndStripMT(ma);
+				}
+			}
+
+			if (maxly &lt; maxty &amp;&amp; maxly &gt; minty) {
+				y = maxly;
+				int xs = max(xstart - lod, mintx);
+				int xe = min(xend + lod,   maxtx);
+				int xt0, xt1;
+				std::vector&lt;fline&gt;::iterator fli;
+
+
+				for (fli = left.begin(); fli != left.end(); fli++) {
+					xt0 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir *  y       )) / lod * lod - lod;
+					xt1 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir * (y + lod))) / lod * lod - lod;
+
+					if (xt0 &gt; xt1) xt0 = xt1;
+					if (xt0 &gt; xs) xs = xt0;
+				}
+				for (fli = right.begin(); fli != right.end(); fli++) {
+					xt0 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir *  y       )) / lod * lod + lod;
+					xt1 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir * (y + lod))) / lod * lod + lod;
+
+					if (xt0 &lt; xt1) xt0 = xt1;
+					if (xt0 &lt; xe) xe = xt0;
+				}
+
+
+				if (xs &lt; xe) {
+					x = xs;
+					int nloop=(xe-xs)/lod+2; // one extra for if statment
+					ma-&gt;EnlargeArrays(2*nloop, 1);
+					if (x % (dlod)) {
+						int idx2     = CLAMP((y + lod) * heightDataX + x),
+							idx2PLOD = CLAMP(idx2 + lod),
+							idx2MLOD = CLAMP(idx2 - lod);
+						float h = ((heightData[idx2MLOD] +
+							heightData[idx2PLOD]) * 0.5f) * (1 - camypart) +
+							heightData[idx2    ] * (camypart);
+
+						DrawVertexAMT(ma, x, y);
+						DrawVertexAMT(ma, x, y + lod, h);
+					} else {
+						DrawVertexAMT(ma, x, y      );
+						DrawVertexAMT(ma, x, y + lod);
+					}
+					for (x = xs; x &lt; xe; x += lod) {
+						if (x % (dlod)) {
+							DrawVertexAMT(ma, x + lod, y      );
+							DrawVertexAMT(ma, x + lod, y + lod);
+						} else {
+							int idx2      = CLAMP((y + lod) * heightDataX + x),
+								idx2PLOD  = CLAMP(idx2 +  lod),
+								idx2PLOD2 = CLAMP(idx2 + dlod);
+							float h = (heightData[idx2PLOD2] +
+								heightData[idx2     ]) * 0.5f * (1 - camypart) +
+								heightData[idx2PLOD ] * (camypart);
+
+							DrawVertexAMT(ma, x + lod, y);
+							DrawVertexAMT(ma, x + lod, y + lod, h);
+						}
+					}
+					EndStripMT(ma);
+				}
+			}
+
+			if (minly &gt; minty &amp;&amp; minly &lt; maxty) {
+				y = minly - lod;
+				int xs = max(xstart - lod, mintx);
+				int xe = min(xend + lod,   maxtx);
+				int xt0, xt1;
+				std::vector&lt;fline&gt;::iterator fli;
+
+
+				for (fli = left.begin(); fli != left.end(); fli++) {
+					xt0 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir *  y       )) / lod * lod - lod;
+					xt1 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir * (y + lod))) / lod * lod - lod;
+
+					if (xt0 &gt; xt1) xt0 = xt1;
+					if (xt0 &gt; xs) xs = xt0;
+				}
+				for (fli = right.begin(); fli != right.end(); fli++) {
+					xt0 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir *  y       )) / lod * lod + lod;
+					xt1 = ((int) (fli-&gt;base / (SQUARE_SIZE) + fli-&gt;dir * (y + lod))) / lod * lod + lod;
+
+					if (xt0 &lt; xt1) xt0 = xt1;
+					if (xt0 &lt; xe) xe = xt0;
+				}
+
+
+				if (xs &lt; xe) {
+					x = xs;
+					int nloop=(xe-xs)/lod+2; // one extra for if statment
+					ma-&gt;EnlargeArrays(2*nloop, 1);
+					if (x % (dlod)) {
+						int idx1     = CLAMP((y) * heightDataX + x),
+							idx1PLOD = CLAMP(idx1 + lod),
+							idx1MLOD = CLAMP(idx1 - lod);
+						float h = ((heightData[idx1MLOD] +
+							heightData[idx1PLOD]) * 0.5f) * (camypart) +
+							heightData[idx1    ] * (1 - camypart);
+
+						DrawVertexAMT(ma, x, y,       h);
+						DrawVertexAMT(ma, x, y + lod   );
+					} else {
+						DrawVertexAMT(ma, x, y      );
+						DrawVertexAMT(ma, x, y + lod);
+					}
+
+					for (x = xs; x &lt; xe; x+= lod) {
+						if (x % (dlod)) {
+							DrawVertexAMT(ma, x + lod, y      );
+							DrawVertexAMT(ma, x + lod, y + lod);
+						} else {
+							int idx1      = CLAMP((y) * heightDataX + x),
+								idx1PLOD  = CLAMP(idx1 +  lod),
+								idx1PLOD2 = CLAMP(idx1 + dlod);
+							float h = (heightData[idx1PLOD2] +
+								heightData[idx1     ]) * 0.5f * (camypart) +
+								heightData[idx1PLOD ] * (1 - camypart);
+
+							DrawVertexAMT(ma, x + lod, y,       h);
+							DrawVertexAMT(ma, x + lod, y + lod   );
+						}
+					}
+					EndStripMT(ma);
+				}
+			}
+		}
+		DrawGroundVertexArrayMT(ma);
+	}
+	return true;
+}
+
+
 void CBFGroundDrawer::Draw(bool drawWaterReflection, bool drawUnitReflection, unsigned int overrideVP)
 {
 	if (wireframe) {
@@ -161,8 +667,8 @@
 	textures-&gt;DrawUpdate();
 
 	int x, y;
-	const int neededLod = int((gu-&gt;viewRange * 0.125f) / viewRadius) &lt;&lt; 1;
-	const int maxIdx = ((gs-&gt;mapx + 1) * (gs-&gt;mapy + 1)) - 1;
+	neededLod = int((gu-&gt;viewRange * 0.125f) / viewRadius) &lt;&lt; 1;
+	maxIdx = ((gs-&gt;mapx + 1) * (gs-&gt;mapy + 1)) - 1;
 	#define CLAMP(i) std::max(0, std::min((i), maxIdx))
 
 	UpdateCamRestraints();
@@ -186,6 +692,10 @@
 	float camxpart = 0.0f, oldcamxpart;
 	float camypart = 0.0f, oldcamypart;
 
+#if GML_ENABLE_DRAWGROUND
+	mt_overrideVP=overrideVP;
+	gmlProcessor.Work(NULL,&amp;CBFGroundDrawer::DrawMTcb,NULL,this,gmlThreadCount,FALSE,NULL,numBigTexY,50,100,TRUE,NULL);
+#else
 	for (int bty = 0; bty &lt; numBigTexY; ++bty) {
 		if (!BigTexSquareRowVisible(bty)) {
 			// skip this entire row of squares if we can't see it
@@ -625,6 +1135,7 @@
 			DrawGroundVertexArray();
 		}
 	}
+#endif
 
 	ResetTextureUnits(drawWaterReflection, overrideVP);
 	glDisable(GL_CULL_FACE);
@@ -694,8 +1205,288 @@
 }
 
 
+bool CBFGroundDrawer::DrawShadowPassMT(int nlod) {
+	CVertexArray *ma = GetVertexArray();
+	ma-&gt;Initialize();
 
+	bool inStrip=false;
+	int x,y;
+	int lod=1&lt;&lt;nlod;
 
+	float cx2 = (camera-&gt;pos.x / (SQUARE_SIZE));
+	float cy2 = (camera-&gt;pos.z / (SQUARE_SIZE));
+
+	float oldcamxpart = 0.0f;
+	float oldcamypart = 0.0f;
+
+	int hlod = lod &gt;&gt; 1;
+	int dlod = lod &lt;&lt; 1;
+
+	int cx = (int)cx2;
+	int cy = (int)cy2;
+	if(lod&gt;1) {
+		int cxo = (cx / hlod) * hlod;
+		int cyo = (cy / hlod) * hlod;
+		float cx2o = (cxo / lod) * lod;
+		float cy2o = (cyo / lod) * lod;
+		oldcamxpart = (cx2 - cx2o) / (lod);
+		oldcamypart = (cy2 - cy2o) / (lod);
+	}
+
+	cx = (cx / lod) * lod;
+	cy = (cy / lod) * lod;
+	int ysquaremod = ((cy) % (dlod)) / lod;
+	int xsquaremod = ((cx) % (dlod)) / lod;
+
+	float camxpart = (cx2 - ((cx / (dlod)) * dlod)) / (dlod);
+	float camypart = (cy2 - ((cy / (dlod)) * dlod)) / (dlod);
+
+	int minty = 0;
+	int maxty = gs-&gt;mapy;
+	int mintx = 0;
+	int maxtx = gs-&gt;mapx;
+
+	int minly = cy + (-viewRadius + 3 - ysquaremod) * lod;
+	int maxly = cy + ( viewRadius - 1 - ysquaremod) * lod;
+	int minlx = cx + (-viewRadius + 3 - xsquaremod) * lod;
+	int maxlx = cx + ( viewRadius - 1 - xsquaremod) * lod;
+
+	int xstart = max(minlx, mintx);
+	int xend   = min(maxlx, maxtx);
+	int ystart = max(minly, minty);
+	int yend   = min(maxly, maxty);
+
+	for (y = ystart; y &lt; yend; y += lod) {
+		int xs = xstart;
+		int xe = xend;
+
+		int nloop=(xe-xs)/lod+1;
+		ma-&gt;EnlargeArrays(52*nloop, 14*nloop+1); // includes one extra for final endstrip
+		for (x = xs; x &lt; xe; x += lod) {
+			if ((lod == 1) ||
+				(x &gt; (cx) + viewRadius * hlod) || (x &lt; (cx) - viewRadius * hlod) ||
+				(y &gt; (cy) + viewRadius * hlod) || (y &lt; (cy) - viewRadius * hlod)) {
+					if (!inStrip) {
+						DrawVertexAMT(ma, x, y      );
+						DrawVertexAMT(ma, x, y + lod);
+						inStrip = true;
+					}
+					DrawVertexAMT(ma, x + lod, y      );
+					DrawVertexAMT(ma, x + lod, y + lod);
+			} else {  //inre begr&#65533;sning mot f&#65533;eg&#65533;nde lod
+				if((x&gt;=(cx)+viewRadius*hlod)){
+					float h1=(heightData[(y)*heightDataX+x]+heightData[(y+lod)*heightDataX+x])*0.5f*(1-oldcamxpart)+heightData[(y+hlod)*heightDataX+x]*(oldcamxpart);
+					float h2=(heightData[(y)*heightDataX+x]+heightData[(y)*heightDataX+x+lod])*0.5f*(1-oldcamxpart)+heightData[(y)*heightDataX+x+hlod]*(oldcamxpart);
+					float h3=(heightData[(y+lod)*heightDataX+x]+heightData[(y)*heightDataX+x+lod])*0.5f*(1-oldcamxpart)+heightData[(y+hlod)*heightDataX+x+hlod]*(oldcamxpart);
+					float h4=(heightData[(y+lod)*heightDataX+x]+heightData[(y+lod)*heightDataX+x+lod])*0.5f*(1-oldcamxpart)+heightData[(y+lod)*heightDataX+x+hlod]*(oldcamxpart);
+
+					if(inStrip){
+						EndStripMT(ma);
+						inStrip=false;
+					}
+					DrawVertexAMT(ma, x,y);
+					DrawVertexAMT(ma, x,y+hlod,h1);
+					DrawVertexAMT(ma, x+hlod,y,h2);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					EndStripMT(ma);
+					DrawVertexAMT(ma, x,y+hlod,h1);
+					DrawVertexAMT(ma, x,y+lod);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					DrawVertexAMT(ma, x+hlod,y+lod,h4);
+					EndStripMT(ma);
+					DrawVertexAMT(ma, x+hlod,y+lod,h4);
+					DrawVertexAMT(ma, x+lod,y+lod);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					DrawVertexAMT(ma, x+lod,y);
+					DrawVertexAMT(ma, x+hlod,y,h2);
+					EndStripMT(ma);
+				}
+				if((x&lt;=(cx)-viewRadius*hlod)){
+					float h1=(heightData[(y)*heightDataX+x+lod]+heightData[(y+lod)*heightDataX+x+lod])*0.5f*(oldcamxpart)+heightData[(y+hlod)*heightDataX+x+lod]*(1-oldcamxpart);
+					float h2=(heightData[(y)*heightDataX+x]+heightData[(y)*heightDataX+x+lod])*0.5f*(oldcamxpart)+heightData[(y)*heightDataX+x+hlod]*(1-oldcamxpart);
+					float h3=(heightData[(y+lod)*heightDataX+x]+heightData[(y)*heightDataX+x+lod])*0.5f*(oldcamxpart)+heightData[(y+hlod)*heightDataX+x+hlod]*(1-oldcamxpart);
+					float h4=(heightData[(y+lod)*heightDataX+x]+heightData[(y+lod)*heightDataX+x+lod])*0.5f*(oldcamxpart)+heightData[(y+lod)*heightDataX+x+hlod]*(1-oldcamxpart);
+
+					if(inStrip){
+						EndStripMT(ma);
+						inStrip=false;
+					}
+					DrawVertexAMT(ma, x+lod,y+hlod,h1);
+					DrawVertexAMT(ma, x+lod,y);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					DrawVertexAMT(ma, x+hlod,y,h2);
+					EndStripMT(ma);
+					DrawVertexAMT(ma, x+lod,y+lod);
+					DrawVertexAMT(ma, x+lod,y+hlod,h1);
+					DrawVertexAMT(ma, x+hlod,y+lod,h4);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					EndStripMT(ma);
+					DrawVertexAMT(ma, x+hlod,y,h2);
+					DrawVertexAMT(ma, x,y);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					DrawVertexAMT(ma, x,y+lod);
+					DrawVertexAMT(ma, x+hlod,y+lod,h4);
+					EndStripMT(ma);
+				}
+				if((y&gt;=(cy)+viewRadius*hlod)){
+					float h1=(heightData[(y)*heightDataX+x]+heightData[(y)*heightDataX+x+lod])*0.5f*(1-oldcamypart)+heightData[(y)*heightDataX+x+hlod]*(oldcamypart);
+					float h2=(heightData[(y)*heightDataX+x]+heightData[(y+lod)*heightDataX+x])*0.5f*(1-oldcamypart)+heightData[(y+hlod)*heightDataX+x]*(oldcamypart);
+					float h3=(heightData[(y+lod)*heightDataX+x]+heightData[(y)*heightDataX+x+lod])*0.5f*(1-oldcamypart)+heightData[(y+hlod)*heightDataX+x+hlod]*(oldcamypart);
+					float h4=(heightData[(y+lod)*heightDataX+x+lod]+heightData[(y)*heightDataX+x+lod])*0.5f*(1-oldcamypart)+heightData[(y+hlod)*heightDataX+x+lod]*(oldcamypart);
+
+					if(inStrip){
+						EndStripMT(ma);
+						inStrip=false;
+					}
+					DrawVertexAMT(ma, x,y);
+					DrawVertexAMT(ma, x,y+hlod,h2);
+					DrawVertexAMT(ma, x+hlod,y,h1);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					DrawVertexAMT(ma, x+lod,y);
+					DrawVertexAMT(ma, x+lod,y+hlod,h4);
+					EndStripMT(ma);
+					DrawVertexAMT(ma, x,y+hlod,h2);
+					DrawVertexAMT(ma, x,y+lod);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					DrawVertexAMT(ma, x+lod,y+lod);
+					DrawVertexAMT(ma, x+lod,y+hlod,h4);
+					EndStripMT(ma);
+				}
+				if((y&lt;=(cy)-viewRadius*hlod)){
+					float h1=(heightData[(y+lod)*heightDataX+x]+heightData[(y+lod)*heightDataX+x+lod])*0.5f*(oldcamypart)+heightData[(y+lod)*heightDataX+x+hlod]*(1-oldcamypart);
+					float h2=(heightData[(y)*heightDataX+x]+heightData[(y+lod)*heightDataX+x])*0.5f*(oldcamypart)+heightData[(y+hlod)*heightDataX+x]*(1-oldcamypart);
+					float h3=(heightData[(y+lod)*heightDataX+x]+heightData[(y)*heightDataX+x+lod])*0.5f*(oldcamypart)+heightData[(y+hlod)*heightDataX+x+hlod]*(1-oldcamypart);
+					float h4=(heightData[(y+lod)*heightDataX+x+lod]+heightData[(y)*heightDataX+x+lod])*0.5f*(oldcamypart)+heightData[(y+hlod)*heightDataX+x+lod]*(1-oldcamypart);
+
+					if(inStrip){
+						EndStripMT(ma);
+						inStrip=false;
+					}
+					DrawVertexAMT(ma, x,y+hlod,h2);
+					DrawVertexAMT(ma, x,y+lod);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					DrawVertexAMT(ma, x+hlod,y+lod,h1);
+					DrawVertexAMT(ma, x+lod,y+hlod,h4);
+					DrawVertexAMT(ma, x+lod,y+lod);
+					EndStripMT(ma);
+					DrawVertexAMT(ma, x+lod,y+hlod,h4);
+					DrawVertexAMT(ma, x+lod,y);
+					DrawVertexAMT(ma, x+hlod,y+hlod,h3);
+					DrawVertexAMT(ma, x,y);
+					DrawVertexAMT(ma, x,y+hlod,h2);
+					EndStripMT(ma);
+				}
+			}
+		}
+		if(inStrip){
+			EndStripMT(ma);
+			inStrip=false;
+		}
+	}
+
+	int yst=max(ystart - lod, minty);
+	int yed=min(yend + lod, maxty);
+	int nloop=(yed-yst)/lod+1;
+	ma-&gt;EnlargeArrays(8*nloop, 2*nloop);
+	//rita yttre begr&#65533;snings yta mot n&#65533;ta lod
+	if(maxlx&lt;maxtx &amp;&amp; maxlx&gt;=mintx){
+		x=maxlx;
+		for(y=yst;y&lt;yed;y+=lod){
+			DrawVertexAMT(ma, x,y);
+			DrawVertexAMT(ma, x,y+lod);
+			if(y%(lod*2)){
+				float h=((heightData[(y-lod)*heightDataX+x+lod]+heightData[(y+lod)*heightDataX+x+lod])*0.5f)*(1-camxpart)+heightData[(y)*heightDataX+x+lod]*(camxpart);
+				DrawVertexAMT(ma, x+lod,y,h);
+				DrawVertexAMT(ma, x+lod,y+lod);
+			} else {
+				DrawVertexAMT(ma, x+lod,y);
+				float h=(heightData[(y)*heightDataX+x+lod]+heightData[(y+lod*2)*heightDataX+x+lod])*0.5f*(1-camxpart)+heightData[(y+lod)*heightDataX+x+lod]*(camxpart);
+				DrawVertexAMT(ma, x+lod,y+lod,h);
+			}
+			EndStripMT(ma);
+		}
+	}
+	if(minlx&gt;mintx &amp;&amp; minlx&lt;maxtx){
+		x=minlx-lod;
+		for(y=yst;y&lt;yed;y+=lod){
+			if(y%(lod*2)){
+				float h=((heightData[(y-lod)*heightDataX+x]+heightData[(y+lod)*heightDataX+x])*0.5f)*(camxpart)+heightData[(y)*heightDataX+x]*(1-camxpart);
+				DrawVertexAMT(ma, x,y,h);
+				DrawVertexAMT(ma, x,y+lod);
+			} else {
+				DrawVertexAMT(ma, x,y);
+				float h=(heightData[(y)*heightDataX+x]+heightData[(y+lod*2)*heightDataX+x])*0.5f*(camxpart)+heightData[(y+lod)*heightDataX+x]*(1-camxpart);
+				DrawVertexAMT(ma, x,y+lod,h);
+			}
+			DrawVertexAMT(ma, x+lod,y);
+			DrawVertexAMT(ma, x+lod,y+lod);
+			EndStripMT(ma);
+		}
+	}
+	if(maxly&lt;maxty &amp;&amp; maxly&gt;minty){
+		y=maxly;
+		int xs=max(xstart-lod,mintx);
+		int xe=min(xend+lod,maxtx);
+		if(xs&lt;xe){
+			x=xs;
+			int nloop=(xe-xs)/lod+2; // one extra for if statment
+			ma-&gt;EnlargeArrays(2*nloop, 1);
+			if(x%(lod*2)){
+				DrawVertexAMT(ma, x,y);
+				float h=((heightData[(y+lod)*heightDataX+x-lod]+heightData[(y+lod)*heightDataX+x+lod])*0.5f)*(1-camypart)+heightData[(y+lod)*heightDataX+x]*(camypart);
+				DrawVertexAMT(ma, x,y+lod,h);
+			} else {
+				DrawVertexAMT(ma, x,y);
+				DrawVertexAMT(ma, x,y+lod);
+			}
+			for(x=xs;x&lt;xe;x+=lod){
+				if(x%(lod*2)){
+					DrawVertexAMT(ma, x+lod,y);
+					DrawVertexAMT(ma, x+lod,y+lod);
+				} else {
+					DrawVertexAMT(ma, x+lod,y);
+					float h=(heightData[(y+lod)*heightDataX+x+2*lod]+heightData[(y+lod)*heightDataX+x])*0.5f*(1-camypart)+heightData[(y+lod)*heightDataX+x+lod]*(camypart);
+					DrawVertexAMT(ma, x+lod,y+lod,h);
+				}
+			}
+			EndStripMT(ma);
+		}
+	}
+	if(minly&gt;minty &amp;&amp; minly&lt;maxty){
+		y=minly-lod;
+		int xs=max(xstart-lod,mintx);
+		int xe=min(xend+lod,maxtx);
+		if(xs&lt;xe){
+			x=xs;
+			int nloop=(xe-xs)/lod+2; // one extra for if statment
+			ma-&gt;EnlargeArrays(2*nloop, 1);
+			if(x%(lod*2)){
+				float h=((heightData[(y)*heightDataX+x-lod]+heightData[(y)*heightDataX+x+lod])*0.5f)*(camypart)+heightData[(y)*heightDataX+x]*(1-camypart);
+				DrawVertexAMT(ma, x,y,h);
+				DrawVertexAMT(ma, x,y+lod);
+			} else {
+				DrawVertexAMT(ma, x,y);
+				DrawVertexAMT(ma, x,y+lod);
+			}
+			for(x=xs;x&lt;xe;x+=lod){
+				if(x%(lod*2)){
+					DrawVertexAMT(ma, x+lod,y);
+					DrawVertexAMT(ma, x+lod,y+lod);
+				} else {
+					float h=(heightData[(y)*heightDataX+x+2*lod]+heightData[(y)*heightDataX+x])*0.5f*(camypart)+heightData[(y)*heightDataX+x+lod]*(1-camypart);
+					DrawVertexAMT(ma, x+lod,y,h);
+					DrawVertexAMT(ma, x+lod,y+lod);
+				}
+			}
+			EndStripMT(ma);
+		}
+	}
+
+	DrawGroundVertexArrayMT(ma);
+	return true;
+}
+
+
 void CBFGroundDrawer::DrawShadowPass(void)
 {
 	va = GetVertexArray();
@@ -715,6 +1506,9 @@
 	glBindProgramARB(GL_VERTEX_PROGRAM_ARB, groundShadowVP);
 	glEnable(GL_VERTEX_PROGRAM_ARB);
 
+#if GML_ENABLE_DRAWGROUNDSHADOW
+	gmlProcessor.Work(NULL,&amp;CBFGroundDrawer::DrawShadowPassMTcb,NULL,this,gmlThreadCount,FALSE,NULL,NUM_LODS+1,50,100,TRUE,NULL);
+#else
 	for (int lod = 1; lod &lt; (2 &lt;&lt; NUM_LODS); lod *= 2) {
 		int cx = (((int) (camera-&gt;pos.x / SQUARE_SIZE)) / lod) * lod;
 		int cy = (((int) (camera-&gt;pos.z / SQUARE_SIZE)) / lod) * lod;
@@ -964,6 +1758,7 @@
 
 		DrawGroundVertexArray();
 	}
+#endif
 
 	glDisable(GL_POLYGON_OFFSET_FILL);
 	glDisable(GL_CULL_FACE);

Modified: branches/gml/rts/Map/SMF/BFGroundDrawer.h
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundDrawer.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SMF/BFGroundDrawer.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -52,6 +52,17 @@
 	unsigned int groundFPShadow;
 	bool waterDrawn;
 
+	volatile unsigned int mt_overrideVP;
+
+  bool DrawMT(int bty);
+	static void DrawMTcb(void *c,int bty) {((CBFGroundDrawer *)c)-&gt;DrawMT(bty);}
+	void DrawVertexAMT(CVertexArray *ma, int x, int y);
+	void DrawVertexAMT(CVertexArray *ma, int x, int y, float height);
+  void EndStripMT(CVertexArray *ma);
+  void DrawGroundVertexArrayMT(CVertexArray * &amp;ma);
+	bool DrawShadowPassMT(int nlod);
+	static void DrawShadowPassMTcb(void *c,int nlod) {((CBFGroundDrawer *)c)-&gt;DrawShadowPassMT(nlod);}
+
 	inline void DrawVertexA(int x, int y);
 	inline void DrawVertexA(int x, int y, float height);
 	inline void EndStrip();

Modified: branches/gml/rts/Map/SMF/BFGroundTextures.h
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundTextures.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SMF/BFGroundTextures.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,8 +4,7 @@
 #ifndef __BF_GROUND_TEXTURES_H__
 #define __BF_GROUND_TEXTURES_H__
 
-#define GLEW_STATIC
-#include &lt;GL/glew.h&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
 
 class CFileHandler;
 class CSmfReadMap;

Modified: branches/gml/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- branches/gml/rts/Map/SMF/SmfReadMap.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SMF/SmfReadMap.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -15,6 +15,9 @@
 #include &quot;bitops.h&quot;
 #include &quot;mmgr.h&quot;
 
+#include &quot;lib/gml/gmlsrv.h&quot;
+extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+
 using namespace std;
 
 CR_BIND_DERIVED(CSmfReadMap, CReadMap, (&quot;&quot;))
@@ -304,7 +307,42 @@
 	glActiveTextureARB(GL_TEXTURE0_ARB);
 }
 
+#if GML_EXPERIMENTAL
+#include &quot;system/timeprofiler.h&quot;
+void CSmfReadMap::GridVisMT(int yy) {
+	int y=yy+mt_sy;
+	int quadSize=mt_quadSize;
+	int extraSize=mt_extraSize;
+	CReadMap::IQuadDrawer *qd=mt_qd;
 
+	int sx=mt_sxi;
+	int ex=mt_exi;
+	float xtest,xtest2;
+	std::vector&lt;CBFGroundDrawer::fline&gt;::iterator fli;
+	for(fli=groundDrawer-&gt;left.begin();fli!=groundDrawer-&gt;left.end();fli++){
+		xtest=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*(y*quadSize)));
+		xtest2=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*((y*quadSize)+quadSize)));
+		if(xtest&gt;xtest2)
+			xtest=xtest2;
+		xtest=xtest/quadSize;
+		if(xtest-extraSize&gt;sx)
+			sx=((int)xtest)-extraSize;
+	}
+	for(fli=groundDrawer-&gt;right.begin();fli!=groundDrawer-&gt;right.end();fli++){
+		xtest=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*(y*quadSize)));
+		xtest2=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*((y*quadSize)+quadSize)));
+		if(xtest&lt;xtest2)
+			xtest=xtest2;
+		xtest=xtest/quadSize;
+		if(xtest+extraSize&lt;ex)
+			ex=((int)xtest)+extraSize;
+	}
+
+	for(int x=sx;x&lt;=ex;x++)
+		qd-&gt;DrawQuad (x,y);
+}
+#endif
+
 void CSmfReadMap::GridVisibility (CCamera *cam, int quadSize, float maxdist, CReadMap::IQuadDrawer *qd, int extraSize)
 {
 	int cx=(int)(cam-&gt;pos.x/(SQUARE_SIZE*quadSize));
@@ -321,15 +359,33 @@
 	if(ey&gt;=header.mapy/quadSize)
 		ey=header.mapy/quadSize-1;
 
+	int sxi=cx-drawSquare;
+	if(sxi&lt;0)
+		sxi=0;
+	int exi=cx+drawSquare;
+	if(exi&gt;drawQuadsX-1)
+		exi=drawQuadsX-1;
+ 
+#if GML_EXPERIMENTAL // it appears this does not improve performance
+	int domt=GetTickCount()&amp;(1&lt;&lt;14);
+	SCOPED_TIMER(domt?&quot;TestMT&quot;:&quot;Test&quot;);
+
+	if(GML_EXP_MODE() &amp;&amp; domt) { // requires 1+ey-sy&lt;32
+		mt_quadSize=quadSize;
+		mt_extraSize=extraSize;
+		mt_qd=qd;
+		mt_sy=sy;
+		mt_exi=exi;
+		mt_sxi=sxi;
+		gmlProcessor.Work(NULL,&amp;CSmfReadMap::GridVisMTcb,NULL,this,gmlThreadCount,FALSE,NULL,1+ey-sy,50,100,TRUE,NULL);
+		return;
+	}
+#endif
+
 	for(int y=sy;y&lt;=ey;y++){
-		int sx=cx-drawSquare;
-		if(sx&lt;0)
-			sx=0;
-		int ex=cx+drawSquare;
-		if(ex&gt;drawQuadsX-1)
-			ex=drawQuadsX-1;
+		int sx=sxi;
+		int ex=exi;
 		float xtest,xtest2;
-
 		std::vector&lt;CBFGroundDrawer::fline&gt;::iterator fli;
 		for(fli=groundDrawer-&gt;left.begin();fli!=groundDrawer-&gt;left.end();fli++){
 			xtest=((fli-&gt;base/SQUARE_SIZE+fli-&gt;dir*(y*quadSize)));

Modified: branches/gml/rts/Map/SMF/SmfReadMap.h
===================================================================
--- branches/gml/rts/Map/SMF/SmfReadMap.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Map/SMF/SmfReadMap.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -22,6 +22,17 @@
 	void GridVisibility(CCamera *cam, int quadSize, float maxdist, IQuadDrawer *cb, int extraSize);
 	CBaseGroundDrawer* GetGroundDrawer();
 	float* GetHeightmap() { return heightmap; }
+
+#if GML_EXPERIMENTAL
+	volatile int mt_sy;
+	volatile int mt_quadSize;
+	volatile int mt_extraSize;
+	CReadMap::IQuadDrawer * volatile mt_qd;
+	volatile int mt_sxi;
+	volatile int mt_exi;
+	void GridVisMT(int yy);
+	static void GridVisMTcb(void *c, int yy) {((CSmfReadMap *)c)-&gt;GridVisMT(yy);}
+#endif
 	
 	int GetNumFeatureTypes ();
 	int GetNumFeatures ();

Modified: branches/gml/rts/Rendering/Env/AdvTreeDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -392,38 +392,39 @@
 					}
 				}
 			}
-			//draw trees that has been marked as falling
-			glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,10,0,0,0,0);
-			glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,13,  camera-&gt;right.x,camera-&gt;right.y,camera-&gt;right.z,0);
-			glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,9,  camera-&gt;up.x,camera-&gt;up.y,camera-&gt;up.z,0);
-			for(std::list&lt;FallingTree&gt;::iterator fti=fallingTrees.begin();fti!=fallingTrees.end();){
-				float3 pos=fti-&gt;pos-UpVector*(fti-&gt;fallPos*20);
-				if(camera-&gt;InView(pos+float3(0,MAX_TREE_HEIGHT/2,0),MAX_TREE_HEIGHT/2)){
-					float ang=fti-&gt;fallPos*PI;
-					float3 up(fti-&gt;dir.x*sin(ang),cos(ang),fti-&gt;dir.z*sin(ang));
-					float3 z(up.cross(float3(-1,0,0)));
-					z.Normalize();
-					float3 x(up.cross(z));
-					CMatrix44f transMatrix(pos,x,up,z);
+		}
+		//draw trees that has been marked as falling
+		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,10,0,0,0,0);
+		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,13,  camera-&gt;right.x,camera-&gt;right.y,camera-&gt;right.z,0);
+		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,9,  camera-&gt;up.x,camera-&gt;up.y,camera-&gt;up.z,0);
+		for(std::list&lt;FallingTree&gt;::iterator fti=fallingTrees.begin();fti!=fallingTrees.end();){
+			float3 pos=fti-&gt;pos-UpVector*(fti-&gt;fallPos*20);
+			if(camera-&gt;InView(pos+float3(0,MAX_TREE_HEIGHT/2,0),MAX_TREE_HEIGHT/2)){
+				float ang=fti-&gt;fallPos*PI;
+				float3 up(fti-&gt;dir.x*sin(ang),cos(ang),fti-&gt;dir.z*sin(ang));
+				float3 z(up.cross(float3(-1,0,0)));
+				z.Normalize();
+				float3 x(up.cross(z));
+				CMatrix44f transMatrix(pos,x,up,z);
 
-					glPushMatrix();
-					glMultMatrixf(&amp;transMatrix[0]);
+				glPushMatrix();
+				glMultMatrixf(&amp;transMatrix[0]);
 
-					int type=fti-&gt;type;
-					int displist;
-					if(type&lt;8){
-						displist=treeGen-&gt;pineDL+type;
-					} else {
-						type-=8;
-						displist=treeGen-&gt;leafDL+type;
-					}
-					glCallList(displist);
+				int type=fti-&gt;type;
+				int displist;
+				if(type&lt;8){
+					displist=treeGen-&gt;pineDL+type;
+				} else {
+					type-=8;
+					displist=treeGen-&gt;leafDL+type;
+				}
+				glCallList(displist);
 
-					glPopMatrix();
-				}
-				++fti;
+				glPopMatrix();
 			}
+			++fti;
 		}
+
 		glDisable( GL_VERTEX_PROGRAM_ARB );
 
 		if(shadowHandler-&gt;drawShadows &amp;&amp; !gd-&gt;DrawExtraTex()){

Modified: branches/gml/rts/Rendering/Env/GrassDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/GrassDrawer.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/Env/GrassDrawer.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -6,7 +6,6 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
-#include &lt;GL/glu.h&gt;	
 #include &quot;AdvTreeDrawer.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;LogOutput.h&quot;
@@ -158,9 +157,9 @@
 class CGrassBlockDrawer : public CReadMap::IQuadDrawer
 {
 public:
-	std::vector&lt;InviewGrass*&gt; inviewGrass;
-	std::vector&lt;InviewNearGrass*&gt; inviewNearGrass;
-	CVertexArray* va;
+	GML_VECTOR_EXP&lt;InviewGrass*&gt; inviewGrass;
+	GML_VECTOR_EXP&lt;InviewNearGrass*&gt; inviewNearGrass;
+//	CVertexArray* va;
 	int cx,cy;
 	CGrassDrawer *gd;
 
@@ -244,7 +243,7 @@
 		if(!grass[curModSquare].va){
 			grass[curModSquare].va=SAFE_NEW CVertexArray;;
 			grass[curModSquare].pos=float3((x+0.5f)*SQUARE_SIZE*blockMapSize,ground-&gt;GetHeight2((x+0.5f)*SQUARE_SIZE*blockMapSize,(y+0.5f)*SQUARE_SIZE*blockMapSize),(y+0.5f)*SQUARE_SIZE*blockMapSize);
-			va=grass[curModSquare].va;
+			CVertexArray* va=grass[curModSquare].va;
 			va-&gt;Initialize();
 			for(int y2=0;y2&lt;grassBlockSize;y2++){
 				for(int x2=0;x2&lt;grassBlockSize;x2++){
@@ -404,8 +403,10 @@
 	drawer.cy=(int)(camera-&gt;pos.z/(SQUARE_SIZE*blockMapSize));
 	drawer.gd = this;
 
+	GML_EXP_MODE_ENABLE()
 	readmap-&gt;GridVisibility (camera, blockMapSize, maxGrassDist, &amp;drawer);
-	CVertexArray *va = drawer.va;
+	GML_EXP_MODE_DISABLE()
+	//CVertexArray *va = drawer.va;
 	
 	float grassDistance=maxGrassDist;
 
@@ -451,7 +452,7 @@
 		glActiveTextureARB(GL_TEXTURE0_ARB);
 	}
 
-	for(std::vector&lt;InviewGrass*&gt;::iterator gi=drawer.inviewGrass.begin();gi!=drawer.inviewGrass.end();++gi){
+	for(GML_VECTOR_EXP&lt;InviewGrass*&gt;::iterator gi=drawer.inviewGrass.begin();gi!=drawer.inviewGrass.end();++gi){
 		if((*gi)-&gt;dist+128&lt;grassDistance)
 			glColor4f(0.62f,0.62f,0.62f,1);			
 		else
@@ -468,11 +469,14 @@
 		int texPart=min(15,(int)max(0,(int)((ang+PI/16-PI/2)/PI*30)));
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,10, texPart/16.0f,0,0,0.0f);
 		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,11,  -v.x,-v.y,-v.z,0);
+
 		grass[(*gi)-&gt;num].va-&gt;DrawArrayTN(GL_QUADS);
+
 		delete *gi;	
 	}
+
 	glColor4f(0.62f,0.62f,0.62f,1);			
-	for(std::vector&lt;InviewNearGrass*&gt;::iterator gi=drawer.inviewNearGrass.begin();gi!=drawer.inviewNearGrass.end();++gi){
+	for(GML_VECTOR_EXP&lt;InviewNearGrass*&gt;::iterator gi=drawer.inviewNearGrass.begin();gi!=drawer.inviewNearGrass.end();++gi){
 		int x=(*gi)-&gt;x;
 		int y=(*gi)-&gt;y;
 		if(grassMap[(y)*gs-&gt;mapx/grassSquareSize+(x)]){
@@ -495,7 +499,7 @@
 			rand();
 			rand();
 			int numGrass=numTurfs;
-			va=GetVertexArray();
+			CVertexArray *va=GetVertexArray();
 			va-&gt;Initialize();
 			for(int a=0;a&lt;numGrass;a++){
 				float dx=(x+fRand(1))*SQUARE_SIZE*grassSquareSize;

Modified: branches/gml/rts/Rendering/GL/VertexArray.cpp
===================================================================
--- branches/gml/rts/Rendering/GL/VertexArray.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/GL/VertexArray.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -11,250 +11,243 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CVertexArray::CVertexArray()
-{
+CVertexArray::CVertexArray() {
 	drawArray=SAFE_NEW float[1000];
 	stripArray=SAFE_NEW int[100];
+	Initialize();
+	drawArraySize=drawArray+1000;
+	stripArraySize=stripArray+100;
+}
 
-	drawArraySize=1000;
-	stripArraySize=100;
+CVertexArray::~CVertexArray() {
+	delete [] drawArray;
+	delete [] stripArray;
 }
 
-CVertexArray::~CVertexArray()
-{
-	delete[] drawArray;
-	delete[] stripArray;
+void CVertexArray::Initialize() {
+	drawArrayPos=drawArray;
+	stripArrayPos=stripArray;
 }
 
-void CVertexArray::Initialize()
-{
-	stripIndex=0;
-	drawIndex=0;
+int CVertexArray::drawIndex() {
+	return drawArrayPos-drawArray;
 }
 
-bool CVertexArray::IsReady()
-{
-	return true; 
+bool CVertexArray::IsReady() {
+	return true;
 }
 
-void CVertexArray::EndStrip()
-{
-	if(stripIndex&gt;stripArraySize-4)
+void CVertexArray::EndStrip() {
+	if((char *)stripArrayPos&gt;(char *)stripArraySize-4*sizeof(int))
 		EnlargeStripArray();
 
-	stripArray[stripIndex++]=drawIndex;
+	*stripArrayPos++=((char *)drawArrayPos-(char *)drawArray);
 }
 
-void CVertexArray::AddVertex0(const float3&amp; pos)
-{
-	if(drawIndex&gt;drawArraySize-10)
+inline void CVertexArray::CheckEnlargeDrawArray() {
+	if((char *)drawArrayPos&gt;(char *)drawArraySize-10*sizeof(float))
 		EnlargeDrawArray();
+}
 
-	drawArray[drawIndex++]=pos.x;
-	drawArray[drawIndex++]=pos.y;
-	drawArray[drawIndex++]=pos.z;
+
+void CVertexArray::EnlargeArrays(int vertexes, int strips) {
+	while((char *)drawArrayPos&gt;(char *)drawArraySize-3*sizeof(float)*vertexes)
+		EnlargeDrawArray();
+
+	while((char *)stripArrayPos&gt;(char *)stripArraySize-sizeof(int)*strips)
+		EnlargeStripArray();
 }
 
-void CVertexArray::DrawArray0(int drawType,int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
-	glEnableClientState(GL_VERTEX_ARRAY);
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
-	glDisableClientState(GL_VERTEX_ARRAY);						
+void CVertexArray::EndStripQ() {
+	*stripArrayPos++=((char *)drawArrayPos-(char *)drawArray);
 }
 
-void CVertexArray::AddVertexC(const float3&amp; pos,unsigned char* color)
-{
-	if(drawIndex&gt;drawArraySize-10)
+
+void CVertexArray::AddVertexQ0(float x, float y, float z) {
+	*drawArrayPos++=x;
+	*drawArrayPos++=y;
+	*drawArrayPos++=z;
+}
+
+
+void CVertexArray::AddVertex0(const float3&amp; pos) {
+	if(drawArrayPos&gt;drawArraySize-10)
 		EnlargeDrawArray();
 
-	drawArray[drawIndex++]=pos.x;
-	drawArray[drawIndex++]=pos.y;
-	drawArray[drawIndex++]=pos.z;
-	drawArray[drawIndex++]=*((float*)(color));
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
 }
 
-void CVertexArray::DrawArrayC(int drawType,int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
+
+inline void CVertexArray::DrawArrays(int drawType, int stride) {
+	int newIndex,oldIndex=0;
+	int *stripArrayPtr=stripArray;
+	while(stripArrayPtr&lt;stripArrayPos) {
+		newIndex=(*stripArrayPtr++)/stride;
+		glDrawArrays(drawType,oldIndex,newIndex-oldIndex);
+		oldIndex=newIndex;
+	}
+}
+
+inline void CVertexArray::CheckEndStrip() {
+	if(stripArrayPos==stripArray || *(stripArrayPos-1)!=((char *)drawArrayPos-(char *)drawArray))
 		EndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
-	glColorPointer(4,GL_UNSIGNED_BYTE,stride,&amp;drawArray[3]);
+}
+
+
+
+void CVertexArray::DrawArray0(int drawType,int stride) {
+	CheckEndStrip();
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
 	glEnableClientState(GL_VERTEX_ARRAY);
+	DrawArrays(drawType, stride);
+	glDisableClientState(GL_VERTEX_ARRAY);                                          
+}
+
+void CVertexArray::AddVertexC(const float3&amp; pos,unsigned char* color) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=*((float*)(color));
+}
+
+void CVertexArray::DrawArrayC(int drawType,int stride) {
+	CheckEndStrip();
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glColorPointer(4,GL_UNSIGNED_BYTE,stride,drawArray+3);
+	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_COLOR_ARRAY);
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
-	glDisableClientState(GL_VERTEX_ARRAY);						
+	DrawArrays(drawType, stride);
+	glDisableClientState(GL_VERTEX_ARRAY);                                          
 	glDisableClientState(GL_COLOR_ARRAY);
 }
 
-void CVertexArray::AddVertexT(const float3&amp; pos,float tx,float ty)
-{
-	if(drawIndex&gt;drawArraySize-10)
-		EnlargeDrawArray();
-
-	drawArray[drawIndex++]=pos.x;
-	drawArray[drawIndex++]=pos.y;
-	drawArray[drawIndex++]=pos.z;
-	drawArray[drawIndex++]=tx;
-	drawArray[drawIndex++]=ty;
+void CVertexArray::AddVertexT(const float3&amp; pos,float tx,float ty) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=tx;
+	*drawArrayPos++=ty;
 }
 
-void CVertexArray::DrawArrayT(int drawType,int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
-	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[3]);
+void CVertexArray::DrawArrayT(int drawType,int stride) {
+	CheckEndStrip();
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
+	DrawArrays(drawType, stride);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-	glDisableClientState(GL_VERTEX_ARRAY);						
+	glDisableClientState(GL_VERTEX_ARRAY);                                          
 }
 
-void CVertexArray::AddVertexT2(const float3&amp; pos,float tx,float ty,float t2x,float t2y)
-{
-	if(drawIndex&gt;drawArraySize-10)
-		EnlargeDrawArray();
-
-	drawArray[drawIndex++]=pos.x;
-	drawArray[drawIndex++]=pos.y;
-	drawArray[drawIndex++]=pos.z;
-	drawArray[drawIndex++]=tx;
-	drawArray[drawIndex++]=ty;
-	drawArray[drawIndex++]=t2x;
-	drawArray[drawIndex++]=t2y;
+void CVertexArray::AddVertexT2(const float3&amp; pos,float tx,float ty,float t2x,float t2y) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=tx;
+	*drawArrayPos++=ty;
+	*drawArrayPos++=t2x;
+	*drawArrayPos++=t2y;
 }
 
-void CVertexArray::DrawArrayT2(int drawType,int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
-	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[3]);
+void CVertexArray::DrawArrayT2(int drawType,int stride) {
+	CheckEndStrip();
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
 
 	glClientActiveTextureARB(GL_TEXTURE1_ARB);
-	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[5]);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+5);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glClientActiveTextureARB(GL_TEXTURE0_ARB);
-
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
+	DrawArrays(drawType, stride);
 	glClientActiveTextureARB(GL_TEXTURE1_ARB);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glClientActiveTextureARB(GL_TEXTURE0_ARB);
 
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-	glDisableClientState(GL_VERTEX_ARRAY);						
+	glDisableClientState(GL_VERTEX_ARRAY);                                          
 }
 
-void CVertexArray::AddVertexTN(const float3&amp; pos,float tx,float ty, const float3&amp; norm)
-{
-	if(drawIndex&gt;drawArraySize-10)
-		EnlargeDrawArray();
-
-	drawArray[drawIndex++]=pos.x;
-	drawArray[drawIndex++]=pos.y;
-	drawArray[drawIndex++]=pos.z;
-	drawArray[drawIndex++]=tx;
-	drawArray[drawIndex++]=ty;
-	drawArray[drawIndex++]=norm.x;
-	drawArray[drawIndex++]=norm.y;
-	drawArray[drawIndex++]=norm.z;
+void CVertexArray::AddVertexTN(const float3&amp; pos,float tx,float ty,const float3&amp; norm) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=tx;
+	*drawArrayPos++=ty;
+	*drawArrayPos++=norm.x;
+	*drawArrayPos++=norm.y;
+	*drawArrayPos++=norm.z;
 }
 
-void CVertexArray::DrawArrayTN(int drawType, int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
-	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[3]);
-	glNormalPointer(GL_FLOAT,stride,&amp;drawArray[5]);
+void CVertexArray::DrawArrayTN(int drawType, int stride) {
+	CheckEndStrip();
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
+	glNormalPointer(GL_FLOAT,stride,drawArray+5);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_NORMAL_ARRAY);
-	
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
+	DrawArrays(drawType, stride);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-	glDisableClientState(GL_VERTEX_ARRAY);						
+	glDisableClientState(GL_VERTEX_ARRAY);                                          
 	glDisableClientState(GL_NORMAL_ARRAY);
 }
 
-void CVertexArray::AddVertexTC(const float3&amp; pos,float tx,float ty,unsigned char* col)
-{
-	if(drawIndex&gt;drawArraySize-10)
-		EnlargeDrawArray();
-
-	drawArray[drawIndex++]=pos.x;
-	drawArray[drawIndex++]=pos.y;
-	drawArray[drawIndex++]=pos.z;
-	drawArray[drawIndex++]=tx;
-	drawArray[drawIndex++]=ty;
-	drawArray[drawIndex++]=*((float*)(col));
+void CVertexArray::AddVertexTC(const float3&amp; pos,float tx,float ty,unsigned char* col) {
+	CheckEnlargeDrawArray();
+	*drawArrayPos++=pos.x;
+	*drawArrayPos++=pos.y;
+	*drawArrayPos++=pos.z;
+	*drawArrayPos++=tx;
+	*drawArrayPos++=ty;
+	*drawArrayPos++=*((float*)(col));
 }
 
-void CVertexArray::DrawArrayTC(int drawType, int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
-	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
-	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[3]);
-	glColorPointer(4,GL_UNSIGNED_BYTE,stride,&amp;drawArray[5]);
+void CVertexArray::DrawArrayTC(int drawType, int stride) {
+	CheckEndStrip();
+	glVertexPointer(3,GL_FLOAT,stride,drawArray);
+	glTexCoordPointer(2,GL_FLOAT,stride,drawArray+3);
+	glColorPointer(4,GL_UNSIGNED_BYTE,stride,drawArray+5);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_COLOR_ARRAY);
-	
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
+	DrawArrays(drawType, stride);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-	glDisableClientState(GL_VERTEX_ARRAY);						
+	glDisableClientState(GL_VERTEX_ARRAY);                                          
 	glDisableClientState(GL_COLOR_ARRAY);
 }
 
-void CVertexArray::EnlargeDrawArray()
-{
-	float* tempArray=SAFE_NEW float[drawArraySize*2];
-	for(int a=0;a&lt;drawIndex;++a)
-		tempArray[a]=drawArray[a];
+void CVertexArray::EnlargeDrawArray() {
+	int pos=drawArrayPos-drawArray;
+	int oldsize=drawArraySize-drawArray;
+	int newsize=oldsize*2;
+	float* tempArray=SAFE_NEW float[newsize];
+	memcpy(tempArray,drawArray,oldsize*sizeof(float));
 
-	drawArraySize*=2;
-	delete[] drawArray;
+	delete [] drawArray;
 	drawArray=tempArray;
+	drawArraySize=drawArray+newsize;
+	drawArrayPos=drawArray+pos;
 }
 
-void CVertexArray::EnlargeStripArray()
-{
-	int* tempArray=SAFE_NEW int[stripArraySize*2];
-	for(int a=0;a&lt;stripIndex;++a)
-		tempArray[a]=stripArray[a];
+void CVertexArray::EnlargeStripArray() {
+	int pos=stripArrayPos-stripArray;
+	int oldsize=stripArraySize-stripArray;
+	int newsize=oldsize*2;
 
-	stripArraySize*=2;
-	delete[] stripArray;
+	int* tempArray=SAFE_NEW int[newsize];
+	memcpy(tempArray,stripArray,oldsize*sizeof(int));
+
+	delete [] stripArray;
 	stripArray=tempArray;
-}
+	stripArraySize=stripArray+newsize;
+	stripArrayPos=stripArray+pos;
+}
\ No newline at end of file

Modified: branches/gml/rts/Rendering/GL/VertexArray.h
===================================================================
--- branches/gml/rts/Rendering/GL/VertexArray.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/GL/VertexArray.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -23,19 +23,26 @@
 	void DrawArray0(int drawType,int stride=12);
 	void AddVertexC(const float3&amp; pos,unsigned char* color);
 	void DrawArrayC(int drawType,int stride=16);
-
 	void EnlargeStripArray();
 	void EnlargeDrawArray();
 	void EndStrip();
 	bool IsReady();
+  void CheckEnlargeDrawArray();
+	void CheckEndStrip();
+  void DrawArrays(int drawType, int stride);
+  void EnlargeArrays(int vertexes, int strips);
+	void EndStripQ();
+	void AddVertexQ0(float x, float y, float z);
 
+	int drawIndex();
+
 	float* drawArray;
-	int drawArraySize;
-	int drawIndex;
+	float* drawArrayPos;
+	float* drawArraySize;
 
 	int* stripArray;
-	int stripArraySize;
-	int stripIndex;
+	int* stripArrayPos;
+	int* stripArraySize;
 };
 
 #endif /* VERTEXARRAY_H */

Modified: branches/gml/rts/Rendering/GL/VertexArrayRange.cpp
===================================================================
--- branches/gml/rts/Rendering/GL/VertexArrayRange.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/GL/VertexArrayRange.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -10,57 +10,44 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CVertexArrayRange::CVertexArrayRange(float* mem,int size)
-{
+CVertexArrayRange::CVertexArrayRange(float* mem,int size) {
 	delete[] drawArray;
 
 	drawArray=mem;
-	drawArraySize=size;
+	drawArraySize=mem+size;
 
   glGenFencesNV(1, &amp;fence);
   glEnableClientState(GL_VERTEX_ARRAY_RANGE_NV);
 }
 
-CVertexArrayRange::~CVertexArrayRange()
-{
+CVertexArrayRange::~CVertexArrayRange() {
 	glDeleteFencesNV(1,&amp;fence);
 }
 
-void CVertexArrayRange::Initialize()
-{
-	stripIndex=0;
-	drawIndex=0;
+void CVertexArrayRange::Initialize() {
+	CVertexArray::Initialize();
 
 	glFinishFenceNV(fence);
 }
 
-bool CVertexArrayRange::IsReady()
-{
+bool CVertexArrayRange::IsReady() {
 	return !!glTestFenceNV(fence);
 }
 
-void CVertexArrayRange::DrawArrayT(int drawType,int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
+void CVertexArrayRange::DrawArrayT(int drawType,int stride) {
+	CheckEndStrip();
 	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
 	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[3]);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
+	DrawArrays(drawType, stride);
   glSetFenceNV(fence, GL_ALL_COMPLETED_NV);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glDisableClientState(GL_VERTEX_ARRAY);						
 }
 
-void CVertexArrayRange::DrawArrayT2(int drawType,int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
+void CVertexArrayRange::DrawArrayT2(int drawType,int stride) {
+	CheckEndStrip();
   glEnableClientState(GL_VERTEX_ARRAY_RANGE_NV);
 	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
 	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[3]);
@@ -71,12 +58,7 @@
 	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[5]);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glClientActiveTextureARB(GL_TEXTURE0_ARB);
-
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
+	DrawArrays(drawType, stride);
 	glClientActiveTextureARB(GL_TEXTURE1_ARB);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glClientActiveTextureARB(GL_TEXTURE0_ARB);
@@ -87,10 +69,8 @@
   glDisableClientState(GL_VERTEX_ARRAY_RANGE_NV);
 }
 
-void CVertexArrayRange::DrawArrayTN(int drawType, int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
+void CVertexArrayRange::DrawArrayTN(int drawType, int stride) {
+	CheckEndStrip();
 //  glEnableClientState(GL_VERTEX_ARRAY_RANGE_NV);
 	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
 	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[3]);
@@ -98,12 +78,7 @@
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_NORMAL_ARRAY);
-	
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
+	DrawArrays(drawType, stride);
   glSetFenceNV(fence, GL_ALL_COMPLETED_NV);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glDisableClientState(GL_VERTEX_ARRAY);						
@@ -111,10 +86,8 @@
 //  glDisableClientState(GL_VERTEX_ARRAY_RANGE_NV);
 }
 
-void CVertexArrayRange::DrawArrayTC(int drawType, int stride)
-{
-	if(stripIndex==0 || stripArray[stripIndex-1]!=drawIndex)
-		EndStrip();
+void CVertexArrayRange::DrawArrayTC(int drawType, int stride) {
+	CheckEndStrip();
 //  glDisableClientState(GL_VERTEX_ARRAY_RANGE_NV);
 	glVertexPointer(3,GL_FLOAT,stride,&amp;drawArray[0]);
 	glTexCoordPointer(2,GL_FLOAT,stride,&amp;drawArray[3]);
@@ -122,12 +95,7 @@
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_COLOR_ARRAY);
-	
-	int oldIndex=0;
-	for(int a=0;a&lt;stripIndex;a++){
-		glDrawArrays(drawType,oldIndex*4/stride,stripArray[a]*4/stride-oldIndex*4/stride);
-		oldIndex=stripArray[a];
-	}
+	DrawArrays(drawType, stride);
   glSetFenceNV(fence, GL_ALL_COMPLETED_NV);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glDisableClientState(GL_VERTEX_ARRAY);						
@@ -135,7 +103,6 @@
 //  glDisableClientState(GL_VERTEX_ARRAY_RANGE_NV);
 }
 
-void CVertexArrayRange::EnlargeDrawArray()
-{
-	drawIndex-=40;
+void CVertexArrayRange::EnlargeDrawArray() {
+	drawArrayPos-=40;
 }

Modified: branches/gml/rts/Rendering/GL/myGL.cpp
===================================================================
--- branches/gml/rts/Rendering/GL/myGL.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/GL/myGL.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -25,18 +25,35 @@
 
 static GLuint startupTexture = 0;
 
-
+#if GML_ENABLE
+static CVertexArray vertexArrays1[GML_MAX_NUM_THREADS];
+static CVertexArray vertexArrays2[GML_MAX_NUM_THREADS];
+static CVertexArray* currentVertexArrays[GML_MAX_NUM_THREADS];
+#endif
+//BOOL gmlVertexArrayEnable=0;
 /******************************************************************************/
 /******************************************************************************/
 
 CVertexArray* GetVertexArray()
 {
+#if GML_ENABLE // each thread gets its own array to avoid conflicts
+//	if(gmlVertexArrayEnable) {
+		int thread=gmlThreadNumber;
+		if(currentVertexArrays[thread]==&amp;vertexArrays1[thread]){
+			currentVertexArrays[thread]=&amp;vertexArrays2[thread];
+		} else {
+			currentVertexArrays[thread]=&amp;vertexArrays1[thread];
+		}
+		return currentVertexArrays[thread];
+//	}
+#else
 	if(currentVertexArray==vertexArray1){
 		currentVertexArray=vertexArray2;
 	} else {
 		currentVertexArray=vertexArray1;
 	}
 	return currentVertexArray;
+#endif
 }
 
 

Modified: branches/gml/rts/Rendering/GL/myGL.h
===================================================================
--- branches/gml/rts/Rendering/GL/myGL.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/GL/myGL.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -5,6 +5,7 @@
 
 #include &lt;string&gt;
 #include &lt;GL/glew.h&gt;
+#include &quot;lib/gml/gml.h&quot;
 #include &quot;float3.h&quot;
 
 inline void glVertexf3(const float3 &amp;v)

Modified: branches/gml/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/GroundDecalHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/GroundDecalHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -415,7 +415,8 @@
 					const int start = 5;
 					const int stride = 6;
 
-					for (int i = start; i &lt; scar-&gt;scarQuads-&gt;drawIndex; i += stride) {
+					int sdi=scar-&gt;scarQuads-&gt;drawIndex();
+					for (int i = start; i &lt; sdi; i += stride) {
 						scar-&gt;scarQuads-&gt;drawArray[i] = c;
 					}
 				}

Modified: branches/gml/rts/Rendering/Textures/nv_dds.h
===================================================================
--- branches/gml/rts/Rendering/Textures/nv_dds.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/Textures/nv_dds.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -14,7 +14,7 @@
 
 #include &quot;Rendering/GL/myGL.h&quot;
 #if defined(__APPLE__)
-#include &lt;OpenGL/gl.h&gt;
+//#include &lt;OpenGL/gl.h&gt;
 #include &lt;OpenGL/glext.h&gt;
 #endif
 

Modified: branches/gml/rts/Rendering/UnitModels/3DOParser.cpp
===================================================================
--- branches/gml/rts/Rendering/UnitModels/3DOParser.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/UnitModels/3DOParser.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -498,7 +498,7 @@
 		}
 	}
 	va-&gt;DrawArrayTN(GL_QUADS);
-	if(va2-&gt;drawIndex!=0)
+	if(va2-&gt;drawIndex()!=0)
 		va2-&gt;DrawArrayTN(GL_TRIANGLES);
 }
 

Modified: branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -41,6 +41,8 @@
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;mmgr.h&quot;
 
+#include &quot;lib/gml/gmlsrv.h&quot;
+extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 
 CUnitDrawer* unitDrawer;
 static bool luaDrawing = false; // FIXME
@@ -263,20 +265,115 @@
 }
 
 
+bool CUnitDrawer::DrawUnitMT(CUnit *unit) {
+	bool drawReflection=mt_drawReflection;
+	bool drawRefraction=mt_drawRefraction;
+	CUnit *excludeUnit=mt_excludeUnit;
+#ifdef DIRECT_CONTROL_ALLOWED
+	if (unit == excludeUnit) {
+		return true;
+	}
+#endif
+	if (unit-&gt;noDraw) {
+		return true;
+	}
+	if (camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 30)) {
+		if (gs-&gt;Ally(unit-&gt;allyteam,gu-&gt;myAllyTeam) ||
+			(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) ||
+			gu-&gt;spectatingFullView) {
+
+				if (drawReflection) {
+					float3 zeroPos;
+					if (unit-&gt;midPos.y &lt; 0.0f) {
+						zeroPos = unit-&gt;midPos;
+					} else {
+						const float dif = unit-&gt;midPos.y - camera-&gt;pos.y;
+						zeroPos = camera-&gt;pos  * (unit-&gt;midPos.y / dif) +
+							unit-&gt;midPos * (-camera-&gt;pos.y / dif);
+					}
+					if (ground-&gt;GetApproximateHeight(zeroPos.x, zeroPos.z) &gt; unit-&gt;radius) {
+						return true;
+					}
+				}
+
+				if (drawRefraction) {
+					if (unit-&gt;pos.y &gt; 0.0f) {
+						return true;
+					}
+				}
+
+				float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
+				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+				float realIconLength = iconLength * (iconDistMult * iconDistMult);
+				if (sqDist&gt;realIconLength) {
+					drawIcon.push_back(unit);
+					unit-&gt;isIcon = true;
+				}
+				else {
+					unit-&gt;isIcon = false;
+
+					float farLength = unit-&gt;sqRadius * (unitDrawDist * unitDrawDist);
+					if (sqDist&gt;farLength) {
+						drawFar.push_back(unit);
+					} else {
+						DrawUnit(unit);
+					}
+
+					if ((sqDist &lt; (unitDrawDist * unitDrawDist * 500)) &amp;&amp; showHealthBars) {
+						drawStat.push_back(unit);
+					}
+				}
+		}
+		else if (unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_PREVLOS) {
+			unit-&gt;isIcon = true;
+
+			if ((!gameSetup || gameSetup-&gt;ghostedBuildings) &amp;&amp; !(unit-&gt;mobility)) {
+				// it's a building we've had LOS on once,
+				// add it to the vector of cloaked units
+				float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
+				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+				float realIconLength = iconLength * (iconDistMult * iconDistMult);
+
+				if (sqDist &lt; realIconLength) {
+					if (unit-&gt;model-&gt;textureType) {
+						drawCloakedS3O.push_back(unit);
+					} else {
+						drawCloaked.push_back(unit);
+					}
+					unit-&gt;isIcon = false;
+				}
+			}
+			if ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INRADAR)) {
+				if (!(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_CONTRADAR)) {
+					drawRadarIcon.push_back(unit);
+				} else if (unit-&gt;isIcon) {
+					// this prevents us from drawing icons on top of ghosted buildings
+					drawIcon.push_back(unit);
+				}
+			}
+		} else if ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INRADAR)) {
+			drawRadarIcon.push_back(unit);
+		}
+	}
+	return true;
+}
+
+
 void CUnitDrawer::Draw(bool drawReflection, bool drawRefraction)
 {
 	ASSERT_UNSYNCED_MODE;
 
-	vector&lt;CUnit*&gt; drawFar;
-	vector&lt;CUnit*&gt; drawStat;
+	drawFar.clear();
+	drawStat.clear();
+
 	drawCloaked.clear();
 	drawCloakedS3O.clear();
 
 	glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
 	glFogfv(GL_FOG_COLOR, FogLand);
 
-	vector&lt;CUnit*&gt; drawIcon;
-	vector&lt;CUnit*&gt; drawRadarIcon;
+	drawIcon.clear();
+	drawRadarIcon.clear();
 
 	if (drawReflection) {
 		CUnit::SetLODFactor(LODScale * LODScaleReflection);
@@ -292,9 +389,14 @@
 	CUnit* excludeUnit = drawReflection ? NULL : gu-&gt;directControl;
 #endif
 
+#if GML_ENABLE_DRAWUNIT
+	mt_drawReflection=drawReflection;
+	mt_drawRefraction=drawRefraction;
+	mt_excludeUnit=excludeUnit;
+	gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DrawUnitMTcb,this,gmlThreadCount,FALSE,&amp;uh-&gt;activeUnits,uh-&gt;activeUnits.size(),50,100,TRUE);
+#else
 	for (list&lt;CUnit*&gt;::iterator usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
 		CUnit* unit = *usi;
-
 #ifdef DIRECT_CONTROL_ALLOWED
 		if (unit == excludeUnit) {
 			continue;
@@ -382,6 +484,7 @@
 			}
 		}
 	}
+#endif
 
 	std::multimap&lt;int, TempDrawUnit&gt;::iterator ti;
 	for (ti = tempDrawUnits.begin(); ti != tempDrawUnits.end(); ++ti) {
@@ -410,7 +513,7 @@
 	glEnable(GL_FOG);
 	glFogfv(GL_FOG_COLOR, FogLand);
 
-	for (vector&lt;CUnit*&gt;::iterator usi = drawFar.begin(); usi != drawFar.end(); usi++) {
+	for (GML_VECTOR&lt;CUnit*&gt;::iterator usi = drawFar.begin(); usi != drawFar.end(); usi++) {
 		DrawFar(*usi);
 	}
 
@@ -419,7 +522,7 @@
 	if (!drawReflection) {
 		// Draw unit icons and radar blips.
 		glAlphaFunc(GL_GREATER, 0.5f);
-		vector&lt;CUnit*&gt;::iterator ui;
+		GML_VECTOR&lt;CUnit*&gt;::iterator ui;
 		for (ui = drawIcon.begin(); ui != drawIcon.end(); ++ui) {
 			DrawIcon(*ui, false);
 		}
@@ -457,7 +560,7 @@
 		bin-&gt;Execute(*currMat);
 		currMat = (LuaMaterial*)bin;
 
-		const vector&lt;CUnit*&gt;&amp; units = bin-&gt;GetUnits();
+		const GML_VECTOR&lt;CUnit*&gt;&amp; units = bin-&gt;GetUnits();
 		const int count = (int)units.size();
 		for (int i = 0; i &lt; count; i++) {
 			CUnit* unit = units[i];
@@ -571,6 +674,44 @@
 /******************************************************************************/
 /******************************************************************************/
 
+
+bool CUnitDrawer::DrawUnitShadowMT(CUnit *unit) {
+	if ((gs-&gt;Ally(unit-&gt;allyteam, gu-&gt;myAllyTeam)     ||
+		(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) ||
+		gu-&gt;spectatingFullView)
+		&amp;&amp; camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 700)) {
+
+			// FIXME: test against the shadow projection intersection
+			float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
+			float farLength = unit-&gt;sqRadius * (unitDrawDist * unitDrawDist);
+
+			if (sqDist &lt; farLength) {
+				float iconDistMult = iconHandler-&gt;GetDistance(unit-&gt;unitDef-&gt;iconType);
+				float realIconLength = iconLength * (iconDistMult * iconDistMult);
+
+				if (sqDist &lt; realIconLength) {
+					if (!unit-&gt;isCloaked) {
+						if (unit-&gt;lodCount &lt;= 0) {
+							DrawUnitNow(unit);
+						} else {
+							LuaUnitMaterial&amp; unitMat = unit-&gt;luaMats[LUAMAT_SHADOW];
+							const unsigned lod = unit-&gt;CalcLOD(unitMat.GetLastLOD());
+							unit-&gt;currentLOD = lod;
+							LuaUnitLODMaterial* lodMat = unitMat.GetMaterial(lod);
+
+							if ((lodMat != NULL) &amp;&amp; lodMat-&gt;IsActive()) {
+								lodMat-&gt;AddUnit(unit);
+							} else {
+								DrawUnitNow(unit);
+							}
+						}
+					}
+				}
+			}
+	}
+	return true;
+}
+
 void CUnitDrawer::DrawShadowPass(void)
 {
 	ASSERT_UNSYNCED_MODE;
@@ -585,6 +726,9 @@
 
 	CUnit::SetLODFactor(LODScale * LODScaleShadow);
 
+#if GML_ENABLE_DRAWUNIT
+	gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DrawUnitShadowMTcb,this,gmlThreadCount,FALSE,&amp;uh-&gt;activeUnits,uh-&gt;activeUnits.size(),50,100,TRUE);
+#else
 	list&lt;CUnit*&gt;::iterator usi;
 	for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
 		CUnit* unit = *usi;
@@ -623,6 +767,7 @@
 			}
 		}
 	}
+#endif
 
 	glDisable(GL_VERTEX_PROGRAM_ARB);
 
@@ -832,10 +977,10 @@
 }
 
 
-void CUnitDrawer::DrawCloakedUnitsHelper(std::vector&lt;CUnit*&gt;&amp; dC, std::list&lt;GhostBuilding*&gt;&amp; gB, bool is_s3o)
+void CUnitDrawer::DrawCloakedUnitsHelper(GML_VECTOR&lt;CUnit*&gt;&amp; dC, std::list&lt;GhostBuilding*&gt;&amp; gB, bool is_s3o)
 {
 	// cloaked units and living ghosted buildings (stored in same vector)
-	for (vector&lt;CUnit*&gt;::iterator ui = dC.begin(); ui != dC.end(); ++ui) {
+	for (GML_VECTOR&lt;CUnit*&gt;::iterator ui = dC.begin(); ui != dC.end(); ++ui) {
 		CUnit* unit = *ui;
 
 		if ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) || gu-&gt;spectatingFullView) {
@@ -1466,26 +1611,28 @@
 	camera = realCam;
 }
 
-
 void CUnitDrawer::QueS3ODraw(CWorldObject* object, int textureType)
 {
+#if !GML_ENABLE
 	while (quedS3Os.size() &lt;= textureType)
-		quedS3Os.push_back(std::vector&lt;CWorldObject*&gt;());
-
+		quedS3Os.push_back(GML_VECTOR&lt;CWorldObject*&gt;());
+#endif
 	quedS3Os[textureType].push_back(object);
+#if !GML_ENABLE
 	usedS3OTextures.insert(textureType);
+#endif
 }
 
-
 void CUnitDrawer::DrawQuedS3O(void)
 {
 	SetupForS3ODrawing();
 
+#if !GML_ENABLE
 	for (std::set&lt;int&gt;::iterator uti = usedS3OTextures.begin(); uti != usedS3OTextures.end(); ++uti) {
 		const int tex = *uti;
 		texturehandler-&gt;SetS3oTexture(tex);
 
-		for (std::vector&lt;CWorldObject*&gt;::iterator ui = quedS3Os[tex].begin(); ui != quedS3Os[tex].end(); ++ui) {
+		for (GML_VECTOR&lt;CWorldObject*&gt;::iterator ui = quedS3Os[tex].begin(); ui != quedS3Os[tex].end(); ++ui) {
 			DrawWorldObjectS3O(*ui);
 		}
 
@@ -1493,6 +1640,18 @@
 	}
 
 	usedS3OTextures.clear();
+#else
+	int sz=quedS3Os.size();
+	for(int tex=0; tex&lt;sz;++tex) {
+		if(quedS3Os[tex].size()&gt;0) {
+			texturehandler-&gt;SetS3oTexture(tex);
+			for(GML_VECTOR&lt;CWorldObject*&gt;::iterator ui = quedS3Os[tex].begin(); ui != quedS3Os[tex].end(); ++ui){
+				DrawWorldObjectS3O(*ui);
+			}
+			quedS3Os[tex].clear();
+		}
+	}
+#endif
 	CleanUpS3ODrawing();
 }
 

Modified: branches/gml/rts/Rendering/UnitModels/UnitDrawer.h
===================================================================
--- branches/gml/rts/Rendering/UnitModels/UnitDrawer.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Rendering/UnitModels/UnitDrawer.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -26,12 +26,20 @@
 
 	void Update(void);
 
+  volatile bool mt_drawReflection;
+  volatile bool mt_drawRefraction;
+	CUnit * volatile mt_excludeUnit;
+
 	void Draw(bool drawReflection, bool drawRefraction = false);
 	void DrawUnit(CUnit* unit);
+	bool DrawUnitMT(CUnit *unit);
+	static void DrawUnitMTcb(void *c,CUnit *unit) {((CUnitDrawer *)c)-&gt;DrawUnitMT(unit);}
 	void DrawUnitLOD(CUnit* unit);
 
 	void DrawCloakedUnits(void);									// cloaked units must be drawn after all others
 	void DrawShadowPass(void);
+  bool DrawUnitShadowMT(CUnit *unit);
+	static void DrawUnitShadowMTcb(void *c,CUnit *unit) {((CUnitDrawer *)c)-&gt;DrawUnitShadowMT(unit);}
 	void SetupForUnitDrawing(void);
 	void CleanUpUnitDrawing(void);
 	void SetupForS3ODrawing(void);
@@ -61,9 +69,15 @@
 	void DrawFeatureS3O(CFeature*);									// was CFeature::DrawS3O()
 	void DrawWorldObjectS3O(CWorldObject*);
 
-	std::vector&lt;CUnit*&gt; drawCloaked;
-	std::vector&lt;CUnit*&gt; drawCloakedS3O;
+	GML_VECTOR&lt;CUnit*&gt; drawCloaked;
+	GML_VECTOR&lt;CUnit*&gt; drawCloakedS3O;
 
+	GML_VECTOR&lt;CUnit*&gt; drawFar;
+	GML_VECTOR&lt;CUnit*&gt; drawStat;
+
+	GML_VECTOR&lt;CUnit*&gt; drawIcon;
+	GML_VECTOR&lt;CUnit*&gt; drawRadarIcon;
+
 	CVertexArray* va;
 
 	bool advShading;
@@ -133,7 +147,7 @@
 	void QueS3ODraw(CWorldObject* object,int textureType);
 	void DrawQuedS3O(void);
 
-	std::vector&lt;std::vector&lt;CWorldObject*&gt; &gt; quedS3Os;
+	GML_CLASSVECTOR&lt;GML_VECTOR&lt;CWorldObject*&gt; &gt; quedS3Os;
 	std::set&lt;int&gt; usedS3OTextures;
 
 	void SetS3OTeamColour(int team);
@@ -154,7 +168,7 @@
 	void CleanupBasicS3OTexture1(void);
 	void CleanupBasicS3OTexture0(void);
 	void DrawIcon(CUnit * unit, bool asRadarBlip);
-	void DrawCloakedUnitsHelper(std::vector&lt;CUnit*&gt;&amp; dC, std::list&lt;GhostBuilding*&gt;&amp; gB, bool is_s3o);
+	void DrawCloakedUnitsHelper(GML_VECTOR&lt;CUnit*&gt;&amp; dC, std::list&lt;GhostBuilding*&gt;&amp; gB, bool is_s3o);
 };
 
 extern CUnitDrawer* unitDrawer;

Modified: branches/gml/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Features/FeatureHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Features/FeatureHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -26,7 +26,6 @@
 #include &quot;Sim/Units/CommandAI/BuilderCAI.h&quot;
 #include &quot;System/TimeProfiler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
-#include &lt;GL/glu.h&gt; // after myGL.h
 #include &quot;mmgr.h&quot;
 #include &quot;creg/STL_List.h&quot;
 #include &quot;creg/STL_Set.h&quot;

Modified: branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -657,9 +657,11 @@
 	float3 &amp;speed = owner-&gt;speed;
 
 	float speedf = speed.Length();
-	float goalLength = (goalPos - pos).Length() + 0.01f;
+	float goalLength = (goalPos - pos).Length2D() + 0.01f;
 	float3 goalDir = (goalPos - pos) / goalLength;
+	float3 adjustedGoalDir = float3(goalPos.x,0,goalPos.z) - float3(pos.x,0,pos.z);
 	goalDir.Normalize();
+	adjustedGoalDir.Normalize();
 
 	float aileron = 0.0f;
 	float rudder = 0.0f;
@@ -679,9 +681,9 @@
 		otherThreat = max(1200.0f, goalLength) / otherLength * 0.036f;
 	}
 
-	float goalDot = rightdir.dot(goalDir);
-	goalDot /= goalDir.dot(frontdir) * 0.5f + 0.501f;
-	if (goalDir.dot(frontdir) &lt; -0.1f &amp;&amp; goalLength &lt; turnRadius
+	float goalDot = rightdir.dot(adjustedGoalDir);
+	goalDot /= adjustedGoalDir.dot(frontdir) * 0.5f + 0.501f;
+	if (adjustedGoalDir.dot(frontdir) &lt; -0.1f &amp;&amp; goalLength &lt; turnRadius
 #ifdef DIRECT_CONTROL_ALLOWED
 		&amp;&amp; (!owner-&gt;directControl || owner-&gt;directControl-&gt;mouse2)
 #endif

Modified: branches/gml/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- branches/gml/rts/Sim/Path/PathEstimator.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Path/PathEstimator.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,7 +4,6 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
-#include &quot;Platform/FileSystem.h&quot;
 #include &lt;fstream&gt;
 
 #include &quot;Map/Ground.h&quot;
@@ -14,8 +13,10 @@
 
 #include &quot;lib/minizip/zip.h&quot;
 #include &quot;FileSystem/ArchiveZip.h&quot;
+#include &quot;Platform/FileSystem.h&quot;
 
 #include &lt;boost/bind.hpp&gt;
+#include &lt;boost/version.hpp&gt;
 
 #define PATHDEBUG false
 
@@ -118,7 +119,7 @@
 
 
 
-void CPathEstimator::SpawnThreads(int numThreads, bool init) {
+void CPathEstimator::SpawnThreads(int numThreads, int stage) {
 	if (threads.size() != numThreads) {
 		threads.resize(numThreads);
 		pathFinders.resize(numThreads);
@@ -140,26 +141,31 @@
 		const int minBlock = threadIdx * blocksPerThread;
 		const int maxBlock = minBlock + blocksPerThread + blocksRem;
 
-		if (init) {
+		if (stage == 0) {
 			threads[threadIdx] = SAFE_NEW
 				boost::thread(boost::bind(&amp;CPathEstimator::InitVerticesAndBlocks, this, minVertex, maxVertex, minBlock, maxBlock));
-		} else {
+		}
+		if (stage == 1) {
+			threads[threadIdx] = SAFE_NEW
+				boost::thread(boost::bind(&amp;CPathEstimator::CalculateBlockOffsets, this, minBlock, maxBlock, threadIdx));
+		}
+		if (stage == 2) {
 			// allocate one private CPathFinder object per thread
 			pathFinders[threadIdx] = SAFE_NEW CPathFinder();
 
 			threads[threadIdx] = SAFE_NEW
-				boost::thread(boost::bind(&amp;CPathEstimator::CalcOffsetsAndPathCosts, this, minBlock, maxBlock, threadIdx));
+				boost::thread(boost::bind(&amp;CPathEstimator::EstimatePathCosts, this, minBlock, maxBlock, threadIdx));
 		}
 	}
 }
 
-void CPathEstimator::JoinThreads(int numThreads, bool init) {
+void CPathEstimator::JoinThreads(int numThreads, int stage) {
 	for (int threadIdx = 0; threadIdx &lt; numThreads; threadIdx++) {
 		threads[threadIdx]-&gt;join();
 		delete threads[threadIdx];
 		threads[threadIdx] = 0x0;
 
-		if (!init) {
+		if (stage == 2) {
 			delete pathFinders[threadIdx];
 			pathFinders[threadIdx] = 0x0;
 		}
@@ -167,11 +173,16 @@
 }
 
 void CPathEstimator::InitEstimator(const std::string&amp; name) {
-	int numThreads = configHandler.GetInt(&quot;HardwareThreadCount&quot;, 1);
+	#if ((BOOST_VERSION / 100) % 1000 &lt;= 34)
+	int numThreads = configHandler.GetInt(&quot;HardwareThreadCount&quot;, 2);
+	#else
+	int numThreads = boost::thread::hardware_concurrency();
+	#endif
 
 	if (numThreads &gt; 1) {
-		SpawnThreads(numThreads, true);
-		JoinThreads(numThreads, true);
+		// spawn the threads for InitVerticesAndBlocks()
+		SpawnThreads(numThreads, 0);
+		JoinThreads(numThreads, 0);
 
 		char loadMsg[512];
 		sprintf(loadMsg, &quot;Reading estimate path costs (using %d threads)&quot;, numThreads);
@@ -182,10 +193,12 @@
 			sprintf(calcMsg, &quot;Analyzing map accessibility (block-size %d)&quot;, BLOCK_SIZE);
 			PrintLoadMsg(calcMsg);
 
-			// re-spawn the threads for the wrapper which calls
-			// CalculateBlockOffsets() and EstimatePathCosts()
-			SpawnThreads(numThreads, false);
-			JoinThreads(numThreads, false);
+			// re-spawn the threads for CalculateBlockOffsets()
+			SpawnThreads(numThreads, 1);
+			JoinThreads(numThreads, 1);
+			// re-spawn the threads for EstimatePathCosts()
+			SpawnThreads(numThreads, 2);
+			JoinThreads(numThreads, 2);
 
 			WriteFile(name);
 		}
@@ -194,7 +207,7 @@
 		InitVertices(0, nbrOfVertices);
 		InitBlocks(0, nbrOfBlocks);
 
-		PrintLoadMsg(&quot;Reading estimate path costs&quot;);
+		PrintLoadMsg(&quot;Reading estimate path costs (using %d thread)&quot;, 1);
 
 		if (!ReadFile(name)) {
 			char calcMsg[512];
@@ -209,6 +222,7 @@
 }
 
 
+
 // wrapper
 void CPathEstimator::InitVerticesAndBlocks(int minVertex, int maxVertex, int minBlock, int maxBlock) {
 	InitVertices(minVertex, maxVertex);
@@ -239,8 +253,14 @@
 }
 
 
+
 // wrapper
 void CPathEstimator::CalcOffsetsAndPathCosts(int minBlock, int maxBlock, int threadID) {
+	// NOTE: EstimatePathCosts() [B] is temporally dependent on CalculateBlockOffsets() [A],
+	// A must be completely finished before B_i can be safely called. This means we cannot
+	// let thread i execute (A_i, B_i), but instead have to split the work such that every
+	// thread finishes its part of A before any starts B_i. Hence this wrapper function is
+	// no longer called when more than one thread is spawned in InitEstimator().
 	CalculateBlockOffsets(minBlock, maxBlock, threadID);
 	EstimatePathCosts(minBlock, maxBlock, threadID);
 }
@@ -265,20 +285,17 @@
 	for (int move = 0; move &lt; moveinfo-&gt;moveData.size(); move++) {
 		MoveData* mdi = moveinfo-&gt;moveData[move];
 
-		/*
-		char calcMsg[512];
-		sprintf(calcMsg, &quot;Estimating path costs for blocks %d to %d (block-size %d, path-type %d of %d)&quot;,
-			minBlock, maxBlock, BLOCK_SIZE, mdi-&gt;pathType, moveinfo-&gt;moveData.size());
-		*/
-
-		{
+		if (threadID == -1) {
+			char calcMsg[512];
+			sprintf(calcMsg, &quot;Estimating path costs for blocks %d to %d (block-size %d, path-type %d of %d, thread-ID %d)&quot;,
+				minBlock, maxBlock, BLOCK_SIZE, mdi-&gt;pathType, moveinfo-&gt;moveData.size(), -1);
+			PrintLoadMsg(calcMsg);
+		} else {
 			boost::mutex::scoped_lock lock(loadMsgMutex);
 
-			// NOTE: locking PrintLoadMsg() is not enough?
-			// PrintLoadMsg(calcMsg);
-
-			logOutput.Print(&quot;Estimating path costs for blocks %d to %d (block-size %d, path-type %d of %d)&quot;,
-				minBlock, maxBlock, BLOCK_SIZE, mdi-&gt;pathType, moveinfo-&gt;moveData.size());
+			// NOTE: locking PrintLoadMsg() is not enough, can't call it here
+			logOutput.Print(&quot;Estimating path costs for blocks %d to %d (block-size %d, path-type %d of %d, thread-ID %d)&quot;,
+				minBlock, maxBlock, BLOCK_SIZE, mdi-&gt;pathType, moveinfo-&gt;moveData.size(), threadID);
 		}
 
 		for (int idx = minBlock; idx &lt; maxBlock; idx++) {

Modified: branches/gml/rts/Sim/Path/PathEstimator.h
===================================================================
--- branches/gml/rts/Sim/Path/PathEstimator.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Path/PathEstimator.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -99,8 +99,8 @@
 		void CalculateBlockOffsets(int, int, int);
 		void EstimatePathCosts(int, int, int);
 	
-		void SpawnThreads(int, bool);
-		void JoinThreads(int, bool);
+		void SpawnThreads(int, int);
+		void JoinThreads(int, int);
 
 		boost::mutex loadMsgMutex;
 		std::vector&lt;CPathFinder*&gt; pathFinders;

Modified: branches/gml/rts/Sim/Path/PathFinder.h
===================================================================
--- branches/gml/rts/Sim/Path/PathFinder.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Path/PathFinder.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -97,22 +97,54 @@
 		typedef int size_type;
 		typedef OpenSquare* reference;
 		typedef const OpenSquare* const_reference;
+		typedef OpenSquare** iterator;
+		typedef const OpenSquare* const* const_iterator;
 
+		// gcc 4.3 requires concepts, so give them to it
+		value_type&amp; operator[](size_type idx) { return buf[idx]; }
+		const value_type&amp; operator[](size_type idx) const { return buf[idx]; }
+
+		typedef iterator pointer;
+		typedef const_iterator const_pointer;
+		typedef int difference_type;
+
+		// XXX don't use this
+		// FIXME write proper versions of those
+		typedef OpenSquare** reverse_iterator;
+		typedef const OpenSquare* const* const_reverse_iterator;
+		reverse_iterator rbegin() { return 0; }
+		reverse_iterator rend() { return 0; }
+		const_reverse_iterator rbegin() const { return 0; }
+		const_reverse_iterator rend() const { return 0; }
+		myVector(int, const value_type&amp;) { abort(); }
+		myVector(iterator, iterator) { abort(); }
+		void insert(iterator, const value_type&amp;) { abort(); }
+		void insert(iterator, const size_type&amp;, const value_type&amp;) { abort(); }
+		void insert(iterator, iterator, iterator) { abort(); }
+		void erase(iterator, iterator) { abort(); }
+		void erase(iterator) { abort(); }
+		void erase(iterator, iterator, iterator) { abort(); }
+		void swap(myVector&amp;) { abort(); }
+		// end of concept hax
+
 		int bufPos;
 		OpenSquare* buf[MAX_SEARCHED_SQUARES];
 
 		myVector() {bufPos=-1;}
 
-		inline void push_back(OpenSquare* os)			{buf[++bufPos]=os;}
-		inline void pop_back()										{--bufPos;}
-		inline OpenSquare* back() const						{return buf[bufPos];}
-		inline const value_type&amp; front() const		{return buf[0];}
-		inline value_type&amp; front()								{return buf[0];}
-		inline bool empty() const									{return (bufPos&lt;0);}
-		inline size_type size()										{return bufPos+1;}
-		inline OpenSquare** begin()								{return &amp;buf[0];}
-		inline OpenSquare** end()									{return &amp;buf[bufPos+1];}
-		inline void clear()												{bufPos=-1;}
+		inline void push_back(OpenSquare* os)	{buf[++bufPos]=os;}
+		inline void pop_back()			{--bufPos;}
+		inline OpenSquare* back() const		{return buf[bufPos];}
+		inline const value_type&amp; front() const	{return buf[0];}
+		inline value_type&amp; front()		{return buf[0];}
+		inline bool empty() const		{return (bufPos&lt;0);}
+		inline size_type size() const		{return bufPos+1;}
+		inline size_type max_size() const	{return 1&lt;&lt;30;}
+		inline iterator begin()			{return &amp;buf[0];}
+		inline iterator end()			{return &amp;buf[bufPos+1];}
+		inline const_iterator begin() const	{return &amp;buf[0];}
+		inline const_iterator end() const	{return &amp;buf[bufPos+1];}
+		inline void clear()			{bufPos=-1;}
 	};
 
   class myPQ : public std::priority_queue&lt;OpenSquare*,myVector,lessCost&gt;{

Modified: branches/gml/rts/Sim/Projectiles/Projectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Projectile.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Projectiles/Projectile.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -119,7 +119,7 @@
 void CProjectile::DrawArray()
 {
 	va-&gt;DrawArrayTC(GL_QUADS);
-	ph-&gt;currentParticles+=va-&gt;drawIndex/24;		//each particle quad is 24 values large
+	ph-&gt;currentParticles+=va-&gt;drawIndex()/24;		//each particle quad is 24 values large
 	va=GetVertexArray();
 	va-&gt;Initialize();
 	inArray=false;

Modified: branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -422,7 +422,7 @@
 		tp+=interPos;
 		va-&gt;AddVertexTN(tp,tex-&gt;xstart,tex-&gt;yend,tn);
 	}
-	drawnPieces+=va-&gt;drawIndex/32;
+	drawnPieces+=va-&gt;drawIndex()/32;
 	va-&gt;DrawArrayTN(GL_QUADS);
 
 	unitDrawer-&gt;CleanUpUnitDrawing();
@@ -460,7 +460,7 @@
 					va-&gt;AddVertexTN(tp,verts[i].textureX,verts[i].textureY,tn);
 				}
 			}
-			drawnPieces+=va-&gt;drawIndex/32;
+			drawnPieces+=va-&gt;drawIndex()/32;
 			va-&gt;DrawArrayTN(GL_QUADS);
 		}
 	}

Modified: branches/gml/rts/Sim/Units/COB/CobInstance.cpp
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobInstance.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/COB/CobInstance.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -124,6 +124,9 @@
 #define WEAPON_SPRAY             128 // get (with fake set)
 #define WEAPON_RANGE             129 // get (with fake set)
 #define WEAPON_PROJECTILE_SPEED  130 // get (with fake set)
+#define MIN                      131 // get
+#define MAX                      132 // get
+#define ABS                      133 // get
 
 // NOTE: shared variables use codes [1024 - 5119]
 
@@ -1117,7 +1120,8 @@
 		if (u == NULL)
 			return -1;
 		else
-			return u-&gt;heading;}
+			return u-&gt;heading;
+	}
 	case TARGET_ID:
 		if (unit-&gt;weapons[p1-1]) {
 			CWeapon* weapon = unit-&gt;weapons[p1-1];
@@ -1250,6 +1254,12 @@
 
 		return weapon-&gt;AttackGround(pos, userTarget) ? 1 : 0;
 	}
+	case MIN:
+		return min(p1, p2);
+	case MAX:
+		return max(p1, p2);
+	case ABS:
+		return abs(p1);
 	case FLANK_B_MODE:
 		return unit-&gt;flankingBonusMode;
 	case FLANK_B_DIR:
@@ -1405,10 +1415,20 @@
 #ifndef _CONSOLE
 	switch(val) {
 		case ACTIVATION: {
-			Command c;
-			c.id = CMD_ONOFF;
-			c.params.push_back(param == 0 ? 0 : 1);
-			unit-&gt;commandAI-&gt;GiveCommand(c);
+			if(unit-&gt;unitDef-&gt;onoffable) {
+				Command c;
+				c.id = CMD_ONOFF;
+				c.params.push_back(param == 0 ? 0 : 1);
+				unit-&gt;commandAI-&gt;GiveCommand(c);
+			}
+			else {
+				if(param == 0) {
+					unit-&gt;Deactivate();
+				}
+				else {
+					unit-&gt;Activate();
+				}
+			}
 			break;
 		}
 		case STANDINGMOVEORDERS: {

Modified: branches/gml/rts/Sim/Units/CommandAI/Command.h
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/Command.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/CommandAI/Command.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -92,12 +92,14 @@
 #define INTERNAL_ORDER  (DONT_REPEAT)
 
 
-struct Command {
+struct Command
+{
 	CR_DECLARE_STRUCT(Command);
 
 	Command()
 	: options(0), tag(0), timeOut(INT_MAX) {};
 
+	void AddParam(float par) {params.push_back(par);};
 	int id;                     // CMD_xxx code  (custom codes can also be used)
 	unsigned char options;      // option bits
 	std::vector&lt;float&gt; params;  // command parameters

Modified: branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -20,6 +20,9 @@
 #include &quot;mmgr.h&quot;
 #include &quot;creg/STL_List.h&quot;
 
+#define AIRTRANSPORT_DOCKING_RADIUS 16
+#define AIRTRANSPORT_DOCKING_ANGLE 50
+
 static void ScriptCallback(int retCode,void* p1,void* p2)
 {
 	((CTransportCAI*)p1)-&gt;ScriptReady();
@@ -167,7 +170,7 @@
 					am-&gt;SetWantedAltitude(unit-&gt;model-&gt;height);
 					am-&gt;maxDrift=1;
 					//logOutput.Print(&quot;cai dist %f %f %f&quot;,owner-&gt;pos.distance(wantedPos),owner-&gt;pos.distance2D(wantedPos),owner-&gt;pos.y-wantedPos.y);
-					if(owner-&gt;pos.distance(wantedPos)&lt;4 &amp;&amp; abs(owner-&gt;heading-unit-&gt;heading)&lt;50 &amp;&amp; owner-&gt;updir.dot(UpVector)&gt;0.995f){
+					if(owner-&gt;pos.distance(wantedPos)&lt;AIRTRANSPORT_DOCKING_RADIUS &amp;&amp; abs(owner-&gt;heading-unit-&gt;heading)&lt;AIRTRANSPORT_DOCKING_ANGLE &amp;&amp; owner-&gt;updir.dot(UpVector)&gt;0.995f){
 						am-&gt;dontCheckCol=false;
 						am-&gt;dontLand=true;
 						std::vector&lt;int&gt; args;

Modified: branches/gml/rts/Sim/Units/Unit.cpp
===================================================================
--- branches/gml/rts/Sim/Units/Unit.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/Unit.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -1609,7 +1609,7 @@
 	self-&gt;delayedWreckLevel = retCode;
 }
 
-void CUnit::KillUnit(bool selfDestruct, bool reclaimed, CUnit* attacker)
+void CUnit::KillUnit(bool selfDestruct, bool reclaimed, CUnit* attacker, bool showDeathSequence)
 {
 	if (isDead) {
 		return;
@@ -1634,7 +1634,7 @@
 	}
 	gs-&gt;Team(this-&gt;lineage)-&gt;LeftLineage(this);
 
-	if (!reclaimed &amp;&amp; !beingBuilt) {
+	if (showDeathSequence &amp;&amp; (!reclaimed &amp;&amp; !beingBuilt)) {
 		string exp;
 		if (selfDestruct) {
 			exp = unitDef-&gt;selfDExplosion;

Modified: branches/gml/rts/Sim/Units/Unit.h
===================================================================
--- branches/gml/rts/Sim/Units/Unit.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/Unit.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -370,7 +370,7 @@
 	void UpdateLosStatus(int allyTeam);
 
 public:
-	virtual void KillUnit(bool SelfDestruct,bool reclaimed, CUnit *attacker);
+	virtual void KillUnit(bool SelfDestruct,bool reclaimed, CUnit *attacker, bool showDeathSequence = true);
 	virtual void LoadSave(CLoadSaveInterface* file, bool loading);
 	virtual void IncomingMissile(CMissileProjectile* missile);
 	void TempHoldFire(void);

Modified: branches/gml/rts/Sim/Units/UnitDef.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitDef.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/UnitDef.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -286,6 +286,7 @@
 	float maxPitch;
 	float turnRadius;
 	float wantedHeight;
+	float verticalSpeed;
 	bool canCrash;
 	bool hoverAttack;
 	bool airStrafe;

Modified: branches/gml/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitDefHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/UnitDefHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -461,6 +461,7 @@
 	ud.maxBank = udTable.GetFloat(&quot;maxBank&quot;, 0.8f);         // max roll
 	ud.maxPitch = udTable.GetFloat(&quot;maxPitch&quot;, 0.45f);      // max pitch this plane tries to keep
 	ud.turnRadius = udTable.GetFloat(&quot;turnRadius&quot;, 500.0f); // hint to the ai about how large turn radius this plane needs
+	ud.verticalSpeed = udTable.GetFloat(&quot;verticalSpeed&quot;, 3.0f); // speed of takeoff and landing, at least for gunships
 
 	ud.maxAileron  = udTable.GetFloat(&quot;maxAileron&quot;,  0.015f); // turn speed around roll axis
 	ud.maxElevator = udTable.GetFloat(&quot;maxElevator&quot;, 0.01f);  // turn speed around pitch axis

Modified: branches/gml/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/UnitHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -113,7 +113,7 @@
 
 CUnitHandler::CUnitHandler(bool serializing)
 :
-	maxUnits(500),
+	maxUnits(5000),
 	maxUnitRadius(0.0f),
 	lastDamageWarning(0),
 	lastCmdDamageWarning(0),

Modified: branches/gml/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitLoader.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/UnitLoader.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -260,6 +260,7 @@
 			mt-&gt;orgWantedHeight=mt-&gt;wantedHeight;
 			mt-&gt;dontLand = ud-&gt;DontLand ();
 			mt-&gt;collide = ud-&gt;collide;
+			mt-&gt;altitudeRate = ud-&gt;verticalSpeed;
 
 			unit-&gt;moveType = mt;
 		}

Modified: branches/gml/rts/Sim/Units/UnitTracker.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitTracker.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Units/UnitTracker.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -2,7 +2,6 @@
 #include &quot;UnitTracker.h&quot;
 #include &quot;Unit.h&quot;
 #include &quot;UnitHandler.h&quot;
-#include &quot;Game/Camera/CameraController.h&quot;
 #include &quot;Game/Camera/FPSController.h&quot;
 #include &quot;Game/CameraHandler.h&quot;
 #include &quot;Game/Camera.h&quot;
@@ -243,14 +242,16 @@
 		lastFollowUnit=0;
 	}
 
-	CFPSController* fpsCamera = (CFPSController*) camHandler-&gt;camControllers[0];
-
 	if(timeOut&gt;0){
 		timeOut++;
 		camera-&gt;forward=oldCamDir;
 		camera-&gt;pos=oldCamPos;
-		fpsCamera-&gt;SetDir(oldCamDir);
-		fpsCamera-&gt;SetPos(oldCamPos);
+		if (camHandler-&gt;GetCurrentControllerNum() == 0)
+		{
+			CFPSController&amp; fpsCamera = dynamic_cast&lt;CFPSController&amp;&gt;(camHandler-&gt;GetCurrentController());
+			fpsCamera.SetDir(oldCamDir);
+			fpsCamera.SetPos(oldCamPos);
+		}
 		if(timeOut&gt;15){
 			timeOut=0;
 		}
@@ -258,7 +259,7 @@
 	}
 
 	// non-FPS camera modes  (immediate positional tracking)
-	if (camCtrl != camHandler-&gt;camControllers[0]) {
+	if (camHandler-&gt;GetCurrentControllerNum() != 0) {
 		float3 pos;
 		switch (trackMode) {
 			case TrackAverage: {
@@ -274,8 +275,7 @@
 				break;
 			}
 		}
-		CCameraController* currentCam = camCtrl;
-		currentCam-&gt;SetTrackingInfo(pos, u-&gt;radius * 2.7182818f);
+		camHandler-&gt;GetCurrentController().SetTrackingInfo(pos, u-&gt;radius * 2.7182818f);
 		return;
 	}
 
@@ -293,14 +293,18 @@
 	trackDir.Normalize();
 
 	camera-&gt;pos=trackPos;
-	fpsCamera-&gt;SetPos(trackPos);
 
 	camera-&gt;forward = u-&gt;pos + (u-&gt;speed * gu-&gt;timeOffset) - camera-&gt;pos;
 	camera-&gt;forward.Normalize();
 	camera-&gt;forward += trackDir;
 	camera-&gt;forward.Normalize();
-	fpsCamera-&gt;SetDir(camera-&gt;forward);
-
+	if (camHandler-&gt;GetCurrentControllerNum() == 0)
+	{
+		CFPSController&amp; fpsCamera = dynamic_cast&lt;CFPSController&amp;&gt;(camHandler-&gt;GetCurrentController());
+		fpsCamera.SetDir(camera-&gt;forward);
+		fpsCamera.SetPos(trackPos);
+	}
+	
 	if(doRoll){
 		oldUp[gs-&gt;frameNum%32] = u-&gt;updir;
 		float3 up(0,0,0);

Modified: branches/gml/rts/Sim/Weapons/Cannon.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/Cannon.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/Sim/Weapons/Cannon.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -154,7 +154,7 @@
 void CCannon::Fire(void)
 {
 	float3 diff = targetPos-weaponMuzzlePos;
-	float3 dir=GetWantedDir(diff);
+	float3 dir=(diff.Length() &gt; 2.0) ? GetWantedDir(diff) : diff; //prevent vertical aim when emit-sfx firing the weapon
 	dir+=(gs-&gt;randVector()*sprayangle+salvoError)*(1-owner-&gt;limExperience*0.9f);
 	dir.Normalize();
 #ifdef TRACE_SYNC

Modified: branches/gml/rts/System/BaseNetProtocol.cpp
===================================================================
--- branches/gml/rts/System/BaseNetProtocol.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/BaseNetProtocol.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -1,3 +1,5 @@
+#include &lt;map&gt;
+#include &lt;set&gt;
 #include &quot;BaseNetProtocol.h&quot;
 
 #include &quot;Rendering/InMapDraw.h&quot;

Modified: branches/gml/rts/System/DemoReader.cpp
===================================================================
--- branches/gml/rts/System/DemoReader.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/DemoReader.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,6 +7,7 @@
 #include &quot;Sync/Syncify.h&quot;
 #include &quot;Game/GameSetup.h&quot;
 #endif
+#include &quot;Net/RawPacket.h&quot;
 #include &quot;Game/GameVersion.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 
@@ -77,15 +78,15 @@
 	}
 }
 
-unsigned CDemoReader::GetData(unsigned char *buf, const unsigned length, float curTime)
+netcode::RawPacket* CDemoReader::GetData(float curTime)
 {
 	if (ReachedEnd())
 		return 0;
 
 	// when paused, modGameTime wont increase so no seperate check needed
 	if (nextDemoRead &lt; curTime) {
-		playbackDemo-&gt;Read((void*)(buf), chunkHeader.length);
-		unsigned ret = chunkHeader.length;
+		netcode::RawPacket* buf = new netcode::RawPacket(chunkHeader.length);
+		playbackDemo-&gt;Read((void*)(buf-&gt;data), chunkHeader.length);
 		bytesRemaining -= chunkHeader.length;
 
 		playbackDemo-&gt;Read((void*)&amp;chunkHeader, sizeof(chunkHeader));
@@ -93,7 +94,7 @@
 		nextDemoRead = chunkHeader.modGameTime + demoTimeOffset;
 		bytesRemaining -= sizeof(chunkHeader);
 
-		return ret;
+		return buf;
 	} else {
 		return 0;
 	}

Modified: branches/gml/rts/System/DemoReader.h
===================================================================
--- branches/gml/rts/System/DemoReader.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/DemoReader.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,6 +4,7 @@
 #include &quot;Demo.h&quot;
 
 class CFileHandler;
+namespace netcode { class RawPacket; }
 
 /**
 @brief Utility class for reading demofiles
@@ -19,9 +20,9 @@
 	
 	/**
 	@brief read from demo file
-	@return Amount of data read (bytes)
+	@return The data read (or 0 if no data), don't forget to delete it
 	*/
-	unsigned GetData(unsigned char *buf, const unsigned length, float curTime);
+	netcode::RawPacket* GetData(float curTime);
 
 	/**
 	@brief Wether the demo has reached the end

Modified: branches/gml/rts/System/LoadSaveHandler.cpp
===================================================================
--- branches/gml/rts/System/LoadSaveHandler.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/LoadSaveHandler.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -14,6 +14,7 @@
 #include &quot;Sim/Misc/AirBaseHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
+#include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;creg/Serializer.h&quot;

Modified: branches/gml/rts/System/Net/Net.h
===================================================================
--- branches/gml/rts/System/Net/Net.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Net/Net.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -8,15 +8,13 @@
 
 #include &quot;RawPacket.h&quot;
 
-typedef netcode::RawPacket RawPacket;
+using netcode::RawPacket;
 
 namespace netcode {
 
 class CConnection;
 class UDPListener;
 
-const unsigned NETWORK_BUFFER_SIZE = 40000;
-
 /**
 @brief Interface for low level networking
 Low level network connection (basically a fast TCP-like layer on top of UDP)

Modified: branches/gml/rts/System/Net/PackPacket.h
===================================================================
--- branches/gml/rts/System/Net/PackPacket.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Net/PackPacket.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,6 +4,7 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &lt;assert.h&gt;
+#include &lt;cstring&gt;
 
 #include &quot;RawPacket.h&quot;
 
@@ -29,7 +30,7 @@
 		unsigned size = vec.size()* sizeof(element);
 		if (size &gt; 0) {
 			assert(size + pos &lt;= length);
-			memcpy((data+pos), (void*)(&amp;vec[0]), size);
+                        std::memcpy((data+pos), (void*)(&amp;vec[0]), size);
 			pos += size;
 		}
 		return *this;

Modified: branches/gml/rts/System/Net/UDPConnection.cpp
===================================================================
--- branches/gml/rts/System/Net/UDPConnection.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Net/UDPConnection.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -53,7 +53,7 @@
 
 void UDPConnection::SendData(const unsigned char *data, const unsigned length)
 {
-	if(outgoingLength+length&gt;=NETWORK_BUFFER_SIZE){
+	if(outgoingLength+length&gt;=UDPBufferSize){
 		throw network_error(&quot;Buffer overflow in UDPConnection (SendData)&quot;);
 	}
 	memcpy(&amp;outgoingData[outgoingLength],data,length);

Modified: branches/gml/rts/System/Net/UDPConnection.h
===================================================================
--- branches/gml/rts/System/Net/UDPConnection.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Net/UDPConnection.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -2,7 +2,6 @@
 #define _REMOTE_CONNECTION
 
 #include &quot;Connection.h&quot;
-#include &quot;Net.h&quot;
 #include &quot;UDPSocket.h&quot;
 #include &quot;RawPacket.h&quot;
 
@@ -13,6 +12,8 @@
 
 namespace netcode {
 
+const unsigned UDPBufferSize = 8192;
+
 /**
 How Spring protocolheader looks like (size in bytes):
 4 (int): number of packet (continuous)
@@ -90,7 +91,7 @@
 	sockaddr_in addr;
 
 	///outgoing stuff (pure data without header) waiting to be sended
-	unsigned char outgoingData[NETWORK_BUFFER_SIZE];
+	unsigned char outgoingData[UDPBufferSize];
 	unsigned outgoingLength;
 
 	/// packets the other side didn't ack'ed until now

Modified: branches/gml/rts/System/Net/UDPListener.h
===================================================================
--- branches/gml/rts/System/Net/UDPListener.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Net/UDPListener.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -3,6 +3,7 @@
 
 #include &lt;boost/noncopyable.hpp&gt;
 #include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/weak_ptr.hpp&gt;
 #include &lt;list&gt;
 #include &lt;queue&gt;
 

Modified: branches/gml/rts/System/Platform/FileSystem.h
===================================================================
--- branches/gml/rts/System/Platform/FileSystem.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Platform/FileSystem.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -15,6 +15,11 @@
 #include &lt;iosfwd&gt;
 #include &lt;vector&gt;
 
+// winapi redifines this which breaks things
+#if defined(CreateDirectory)
+# undef CreateDirectory
+#endif
+
 /**
  * @brief native file system handling abstraction
  */

Modified: branches/gml/rts/System/Platform/Win/AVIGenerator.cpp
===================================================================
--- branches/gml/rts/System/Platform/Win/AVIGenerator.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Platform/Win/AVIGenerator.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -4,7 +4,7 @@
 #include &quot;LogOutput.h&quot;
 
 #include &lt;windows.h&gt;
-#include &lt;GL/gl.h&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
 #if defined(_WIN32) &amp;&amp; defined(__MINGW32__)
 #include &lt;GL/glext.h&gt;
 #endif

Modified: branches/gml/rts/System/Platform/Win/DxSound.cpp
===================================================================
--- branches/gml/rts/System/Platform/Win/DxSound.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Platform/Win/DxSound.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -131,7 +131,7 @@
 
 void CDxSound::StopStream() { oggStream.Stop(); }
 void CDxSound::PauseStream() { oggStream.TogglePause(); }
-unsigned int CDxSound::GetStreamTime() { oggStream.GetPlayTime(); }
+unsigned int CDxSound::GetStreamTime() { return oggStream.GetPlayTime(); }
 void CDxSound::SetStreamVolume(float v) { oggStream.SetVolume(v); }
 
 

Modified: branches/gml/rts/System/Platform/Win/DxSound.h
===================================================================
--- branches/gml/rts/System/Platform/Win/DxSound.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Platform/Win/DxSound.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -3,6 +3,8 @@
 
 #include &quot;Sound.h&quot;
 
+#define NOMINMAX
+
 #ifndef _WINSOCKAPI_
 	#define _WINSOCKAPI_
 	#include &lt;dsound.h&gt;

Modified: branches/gml/rts/System/Script/LuaBinder.cpp
===================================================================
--- branches/gml/rts/System/Script/LuaBinder.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Script/LuaBinder.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -48,6 +48,8 @@
 
 	virtual void Update() { check( call&lt;void&gt;(&quot;Update&quot;); );	}
 	static void Update_static(CScript *ptr) { ptr-&gt;CScript::Update(); }
+	virtual void GameStart() { check( call&lt;void&gt;(&quot;GameStart&quot;); );	}
+	static void GameStart_static(CScript *ptr) { ptr-&gt;CScript::GameStart(); }
 	virtual string GetMapName() { string x; check( x = call&lt;string&gt;(&quot;GetMapName&quot;); ); return x; }
 	static string GetMapName_static(CScript *ptr) { return ptr-&gt;CScript::GetMapName(); }
 	virtual string GetModName() { string x; check( x = call&lt;string&gt;(&quot;GetModName&quot;); ); return x; }
@@ -187,15 +189,19 @@
 		class_&lt;CGlobalSyncedStuff&gt;(&quot;GlobalSynced&quot;)
 			.def_readonly(&quot;frameNum&quot;, &amp;CGlobalSyncedStuff::frameNum)
 			.def_readonly(&quot;mapx&quot;, &amp;CGlobalSyncedStuff::mapx)
+			.def_readonly(&quot;activeTeams&quot;, &amp;CGlobalSyncedStuff::activeTeams)
 			.def_readonly(&quot;mapy&quot;, &amp;CGlobalSyncedStuff::mapy),
-
-		class_&lt;SFloat3&gt;(&quot;float3&quot;)
+			
+		class_&lt;SFloat3&gt;(&quot;sfloat3&quot;)
 			.def(constructor&lt;const float, const float, const float&gt;())
 			.def_readwrite(&quot;x&quot;, &amp;SFloat3::x)
 			.def_readwrite(&quot;y&quot;, &amp;SFloat3::y)
 			.def_readwrite(&quot;z&quot;, &amp;SFloat3::z)
 			.def(&quot;__tostring&quot;, &amp;FloatToString),
 
+		class_&lt;float3, SFloat3&gt;(&quot;float3&quot;)
+			.def(constructor&lt;const float, const float, const float&gt;()),
+
 		class_&lt;CWorldObject&gt;(&quot;WorldObject&quot;)
 			.def_readonly(&quot;pos&quot;, &amp;CWorldObject::pos),
 
@@ -259,7 +265,7 @@
 			.def(constructor&lt;&gt;())
 			.def_readwrite(&quot;id&quot;, &amp;Command::id)
 			.def_readwrite(&quot;options&quot;, &amp;Command::options)
-			.def(&quot;AddParam&quot;, &amp;CommandAddParam),
+			.def(&quot;AddParam&quot;, &amp;Command::AddParam),
 
 		// Access to spring's various global handlers are grouped into
 		// relevant lua namespaces to present a nice(r) interface than just exporting
@@ -270,7 +276,8 @@
 			def(&quot;GetNumAt&quot;, &amp;GetNumUnitsAt),
 			def(&quot;GetAt&quot;, &amp;GetUnitsAt, raw(_1)),
 			def(&quot;GetSelected&quot;, &amp;GetSelectedUnits, raw(_1)),
-			def(&quot;SendSelection&quot;, &amp;SendSelectedUnits)
+			def(&quot;SendSelection&quot;, &amp;SendSelectedUnits),
+			def(&quot;Remove&quot;, &amp;RemoveUnit)
 		],
 
 		namespace_(&quot;unitdefhandler&quot;)

Modified: branches/gml/rts/System/Script/LuaFunctions.cpp
===================================================================
--- branches/gml/rts/System/Script/LuaFunctions.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Script/LuaFunctions.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -56,16 +56,17 @@
 		u-&gt;held-&gt;commandAI-&gt;GiveCommand(*c);
 	}
 
-	void CommandAddParam(Command* c, float p)
-	{
-		c-&gt;params.push_back(p);
-	}
-
 	CObject_pointer&lt;CUnit&gt;* UnitLoaderLoadUnit(string name, float3 pos, int team, bool buil)
 	{
 		CUnit* x = unitLoader.LoadUnit(name, pos, team, buil, 0, NULL);
 		return SAFE_NEW CObject_pointer&lt;CUnit&gt;(x);
 	}
+	
+	void RemoveUnit(CObject_pointer&lt;CUnit&gt;* u)
+	{
+		if (u-&gt;held)
+			u-&gt;held-&gt;KillUnit(false, false, 0, false);
+	}
 
 	CObject_pointer&lt;CFeature&gt;* FeatureLoaderLoadFeature( string name, float3 pos, int team )
 	{

Modified: branches/gml/rts/System/Script/LuaFunctions.h
===================================================================
--- branches/gml/rts/System/Script/LuaFunctions.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/Script/LuaFunctions.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -31,11 +31,11 @@
 	void EndGame();
 	void UnitGiveCommand(CObject_pointer&lt;CUnit&gt;* u, Command* c);
 	CObject_pointer&lt;CUnit&gt;* UnitGetTransporter(CObject_pointer&lt;CUnit&gt;* u);
-	void CommandAddParam(Command* c, float p);
 	//luabind::object GetUnitDefList( lua_State* L );
 	int GetNumUnitDefs();
 	//CObject_pointer&lt;UnitDef&gt;* GetUnitDefById( int id );
 	CObject_pointer&lt;CUnit&gt;* UnitLoaderLoadUnit(std::string name, float3 pos, int team, bool buil);
+	void RemoveUnit(CObject_pointer&lt;CUnit&gt;* u);
 	CObject_pointer&lt;CFeature&gt;* FeatureLoaderLoadFeature( std::string name, float3 pos, int team );
 	luabind::object GetFeaturesAt(lua_State* L, const float3&amp; pos, float radius);
 	int GetNumUnitsAt(const float3&amp; pos, float radius);

Modified: branches/gml/rts/System/myMath.h
===================================================================
--- branches/gml/rts/System/myMath.h	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/System/myMath.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -7,6 +7,7 @@
 
 #define SHORTINT_MAXVALUE	32768
 
+
 extern float2 headingToVectorTable[1024];
 
 inline short int GetHeadingFromFacing(int facing)
@@ -86,7 +87,7 @@
 	// If h goes beyond SHORTINT_MAXVALUE, the following 
 	// conversion to a short int crashes.
 	//this change destroys the whole meaning with using short ints....
-	int iy = (int) (asin(vec.y)*(SHORTINT_MAXVALUE/PI));
+	int iy = (int) (streflop::asin(vec.y)*(SHORTINT_MAXVALUE/PI));
 	iy %= SHORTINT_MAXVALUE;
 	ret.y=(short int) iy;
 	ret.x=GetHeadingFromVector(vec.x, vec.z);

Modified: branches/gml/rts/build/vstudio8/rts.vcproj
===================================================================
--- branches/gml/rts/build/vstudio8/rts.vcproj	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/build/vstudio8/rts.vcproj	2008-04-17 23:41:06 UTC (rev 5752)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
 &lt;VisualStudioProject
 	ProjectType=&quot;Visual C++&quot;
-	Version=&quot;8,00&quot;
+	Version=&quot;8.00&quot;
 	Name=&quot;rts&quot;
 	ProjectGUID=&quot;{A0F70264-A7B7-4FE7-A5BE-298CD3A0758F}&quot;
 	RootNamespace=&quot;rts&quot;
@@ -11091,6 +11091,38 @@
 					&lt;/FileConfiguration&gt;
 				&lt;/File&gt;
 			&lt;/Filter&gt;
+			&lt;Filter
+				Name=&quot;gml&quot;
+				&gt;
+				&lt;File
+					RelativePath=&quot;..\..\lib\gml\gml.cpp&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\lib\gml\gml.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\lib\gml\gmlcls.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\lib\gml\gmldef.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\lib\gml\gmlfun.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\lib\gml\gmlimp.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\lib\gml\gmlsrv.h&quot;
+					&gt;
+				&lt;/File&gt;
+			&lt;/Filter&gt;
 		&lt;/Filter&gt;
 		&lt;File
 			RelativePath=&quot;.\resource.h&quot;

Added: branches/gml/rts/lib/gml/gml.cpp
===================================================================
--- branches/gml/rts/lib/gml/gml.cpp	                        (rev 0)
+++ branches/gml/rts/lib/gml/gml.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -0,0 +1,842 @@
+// GML - OpenGL Multithreading Library
+// for Spring <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
+// Author: Mattias &quot;zerver&quot; Radeskog
+// (C) Ware Zerver Tech. <A HREF="http://zerver.net">http://zerver.net</A>
+// Ware Zerver Tech. licenses this library
+// to be used freely for any purpose, as
+// long as this notice remains unchanged
+
+// GML works by &quot;patching&quot; all OpenGL calls. It is injected via a #include &quot;gml.h&quot; statement located in myGL.h.
+// All files that need GL should therefore include myGL.h. INCLUDING gl.h, glu.h, glext.h ... IS FORBIDDEN.
+// When a client thead (gmlThreadNumber &gt; 0) executes a GL call, it is redirected into a queue.
+// The server thread (gmlThreadNumber = 0) will then consume GL calls from the queues of each thread.
+// When the server thread makes a GL call, it calls directly into OpenGL of course.
+
+// Since a single server thread makes all GL calls, there is no point in multithreading code that contains
+// lots of GL calls but almost no CPU intensive calculations. Also, there is no point in multithreading
+// functions that take very short execution time to complete. The overhead of starting and managing the threads
+// will defeat any possible performance benefit.
+
+// Certain calls need synchronization. For example, all glGet*** functions return a value that must
+// be available to the thread immediately. The client thread works around this by requesting the
+// server to run in synced mode. This means the client will halt and ask the server to begin consuming
+// GL calls from its queue until it reaches the sync point containing the GL call that returns the value.
+// Running synced is expensive performance wise, so glGet*** etc should be avoided at all cost in threaded code.
+
+// Instructions for adding new GL functions to GML:
+// 1. add the   GML_MAKEFUN***(Function, ...)   statement to the long list of declarations at the end of gmlfun.h
+// 2. add the corresponding   GML_MAKEHANDLER***(Function)   statment to the QueueHandler function below
+// 3. add   #undef glFunction   to the list in the upper half of gmldef.h
+// 4. add   #define glFunction gmlFunction   to the list in the lower half of gmldef.h
+// Please note: Some functions may require more advanced coding to implement
+// If a function is not yet supported by GML, a compile error pointing to 'GML_FUNCTION_NOT_IMPLEMENTED' will occur
+
+#include &quot;stdafx.h&quot;
+#include &quot;gmlcls.h&quot;
+
+#define EXEC_RUN (BYTE *)NULL
+#define EXEC_SYNC (BYTE *)-1
+
+// TLS (thread local storage) thread identifier
+__declspec(thread) int gmlThreadNumber=0;
+int gmlThreadCount=GML_CPU_COUNT; // number of threads to use
+int gmlThreadCountOverride=0; // number of threads to use (can be manually overridden here)
+
+bool gmlExperimentalMode=false;
+
+// gmlCPUCount returns the number of CPU cores
+// it was taken from the latest version of boost
+// boost::thread::hardware_concurrency()
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#else
+#ifdef __linux__
+#include &lt;sys/sysinfo.h&gt;
+#elif defined(__APPLE__) || defined(__FreeBSD__)
+#include &lt;sys/types.h&gt;
+#include &lt;sys/sysctl.h&gt;
+#elif defined(__sun)
+#include &lt;unistd.h&gt;
+#endif
+#endif
+unsigned gmlCPUCount() {
+#ifdef WIN32
+	SYSTEM_INFO info={0};
+	GetSystemInfo(&amp;info);
+	return info.dwNumberOfProcessors;
+#else
+#if defined(PTW32_VERSION) || defined(__hpux)
+	return pthread_num_processors_np();
+#elif defined(__linux__)
+	return get_nprocs();
+#elif defined(__APPLE__) || defined(__FreeBSD__)
+	int count;
+	size_t size=sizeof(count);
+	return sysctlbyname(&quot;hw.ncpu&quot;,&amp;count,&amp;size,NULL,0)?0:count;
+#elif defined(__sun)
+	int const count=sysconf(_SC_NPROCESSORS_ONLN);
+	return (count&gt;0)?count:0;
+#else
+	return 0;
+#endif
+#endif
+}
+
+// cache maps for gmlInit
+std::map&lt;GLenum,GLint&gt; gmlGetIntegervCache;
+std::map&lt;GLenum,GLfloat&gt; gmlGetFloatvCache;
+std::map&lt;GLenum,std::string&gt; gmlGetStringCache;
+
+// params to be cached by gmlInit
+GLenum gmlIntParams[]={GL_MAX_TEXTURE_SIZE,GL_MAX_TEXTURE_UNITS,GL_MAX_TEXTURE_IMAGE_UNITS_ARB,GL_MAX_TEXTURE_COORDS_ARB,GL_MAX_TEXTURE_UNITS_ARB,GL_UNPACK_ALIGNMENT};
+GLenum gmlFloatParams[]={GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT};
+GLenum gmlStringParams[]={GL_VERSION,GL_VENDOR,GL_RENDERER,GL_EXTENSIONS};
+
+// gmlInit caches certain glGet return values to
+// reduce the need for synced queue execution
+BOOL gmlInited=FALSE;
+void gmlInit() {
+	if(gmlInited)
+		return;
+	for(int i=0; i&lt;sizeof(gmlIntParams)/sizeof(GLenum); ++i) {
+   	GLint gi;
+ 	  glGetIntegerv(gmlIntParams[i],&amp;gi);
+		gmlGetIntegervCache[gmlIntParams[i]]=gi;
+	}
+	for(int i=0; i&lt;sizeof(gmlFloatParams)/sizeof(GLenum); ++i) {
+   	GLfloat fi;
+ 	  glGetFloatv(gmlFloatParams[i],&amp;fi);
+		gmlGetFloatvCache[gmlFloatParams[i]]=fi;
+	}
+	for(int i=0; i&lt;sizeof(gmlStringParams)/sizeof(GLenum); ++i) {
+		std::string si=(char *)glGetString(gmlStringParams[i]);
+		gmlGetStringCache[gmlStringParams[i]]=si;
+	}
+	gmlInited=TRUE;
+}
+
+EXTERN inline GLhandleARB glCreateShader_VERTEX() {
+	return glCreateShader(GL_VERTEX_SHADER);
+}
+EXTERN inline GLhandleARB glCreateShader_FRAGMENT() {
+	return glCreateShader(GL_FRAGMENT_SHADER);
+}
+EXTERN inline GLhandleARB glCreateShaderObjectARB_VERTEX() {
+	return glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+}
+EXTERN inline GLhandleARB glCreateShaderObjectARB_FRAGMENT() {
+	return glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+}
+gmlQueue gmlQueues[GML_MAX_NUM_THREADS];
+
+boost::thread *gmlThreads[GML_MAX_NUM_THREADS];
+
+// Item server instances
+gmlSingleItemServer&lt;GLhandleARB, PFNGLCREATEPROGRAMPROC *__w64&gt; gmlProgramServer(&amp;glCreateProgram, 2, 0);
+gmlSingleItemServer&lt;GLhandleARB, PFNGLCREATEPROGRAMOBJECTARBPROC *__w64&gt; gmlProgramObjectARBServer(&amp;glCreateProgramObjectARB, 2, 0);
+
+gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (__cdecl *)(void)&gt; gmlShaderServer_VERTEX(&amp;glCreateShader_VERTEX, 2, 0);
+gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (__cdecl *)(void)&gt; gmlShaderServer_FRAGMENT(&amp;glCreateShader_FRAGMENT, 2, 0);
+
+gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (__cdecl *)(void)&gt; gmlShaderObjectARBServer_VERTEX(&amp;glCreateShaderObjectARB_VERTEX, 2, 0);
+gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (__cdecl *)(void)&gt; gmlShaderObjectARBServer_FRAGMENT(&amp;glCreateShaderObjectARB_FRAGMENT, 2, 0);
+gmlSingleItemServer&lt;GLUquadric *, GLUquadric *(__stdcall *)(void)&gt; gmlQuadricServer(&amp;gluNewQuadric, 100, 25);
+
+gmlMultiItemServer&lt;GLuint, GLsizei, void (__stdcall *)(GLsizei,GLuint *)&gt; gmlTextureServer(&amp;glGenTextures, 100, 25);
+gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSARBPROC *__w64&gt; gmlBufferARBServer(&amp;glGenBuffersARB, 2, 0);
+gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENFENCESNVPROC *__w64&gt; gmlFencesNVServer(&amp;glGenFencesNV, 2, 0);
+gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENPROGRAMSARBPROC *__w64&gt; gmlProgramsARBServer(&amp;glGenProgramsARB, 2, 0);
+gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENRENDERBUFFERSEXTPROC *__w64&gt; gmlRenderbuffersEXTServer(&amp;glGenRenderbuffersEXT, 2, 0);
+gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENFRAMEBUFFERSEXTPROC *__w64&gt; gmlFramebuffersEXTServer(&amp;glGenFramebuffersEXT, 2, 0);
+gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENQUERIESPROC *__w64&gt; gmlQueryServer(&amp;glGenQueries, 20, 5);
+
+
+// GMLqueue implementation
+gmlQueue::gmlQueue():
+ReadPos(0),WritePos(0),WriteSize(0),Read(0),Write(0),Locked1(FALSE),Locked2(FALSE),Reloc(FALSE),Sync(EXEC_RUN),WasSynced(FALSE),
+ClientState(0),
+CPsize(0), CPtype(0), CPstride(0), CPpointer(NULL), 
+EFPstride(0), EFPpointer(NULL), 
+IPtype(0), IPstride(0), IPpointer(NULL), 
+NPtype(0), NPstride(0), NPpointer(NULL), 
+TCPsize(0), TCPtype(0), TCPstride(0), TCPpointer(NULL) 
+{
+	Queue1=(BYTE *)malloc(GML_INIT_QUEUE_SIZE*sizeof(BYTE));
+	Queue2=(BYTE *)malloc(GML_INIT_QUEUE_SIZE*sizeof(BYTE));
+	Pos1=Queue1;
+	Pos2=Queue2;
+	Size1=Queue1+GML_INIT_QUEUE_SIZE;
+	Size2=Queue2+GML_INIT_QUEUE_SIZE;
+}
+
+BYTE *gmlQueue::Realloc(BYTE **e) {
+	int oldsize=WriteSize-Write;
+	int newsize=oldsize*2;
+	int oldpos=WritePos-Write;
+	int olde=0;
+	if(e)
+		olde=*e-Write;
+	if(Write==Queue1) {
+		*(BYTE * volatile *)&amp;Write=Queue1=(BYTE *)realloc(Queue1,newsize);
+		Size1=Queue1+newsize;
+	}
+	else {
+		*(BYTE * volatile *)&amp;Write=Queue2=(BYTE *)realloc(Queue2,newsize);
+		Size2=Queue2+newsize;
+	}  
+	*(BYTE * volatile *)&amp;WritePos=Write+oldpos;
+	*(BYTE * volatile *)&amp;WriteSize=Write+newsize;
+
+	Reloc=FALSE;
+	if(e)
+		*e=Write+olde;
+	return WritePos;
+}
+
+BYTE *gmlQueue::WaitRealloc(BYTE **e) {
+	int olde=0;
+	if(e)
+		olde=*e-Write;
+
+	Reloc=TRUE;
+	while(Reloc)
+		boost::thread::yield();
+
+	if(e)
+		*e=(BYTE *)*(BYTE * volatile *)&amp;Write+olde;
+	return (BYTE *)*(BYTE * volatile *)&WritePos;
+}
+
+void gmlQueue::ReleaseWrite(BOOL final) {
+	if(Write==NULL)
+		return;
+	if(Write==Queue1) {
+		if(final) {
+			while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
+				boost::thread::yield();
+		}
+		if(WasSynced) {
+			Sync=WritePos;
+			while(Sync==WritePos)
+				boost::thread::yield();
+			WasSynced=FALSE;
+		}
+		Pos1=WritePos;
+		Locks1.Unlock();
+		Locked1=FALSE;
+	}
+	else {
+		if(final) {
+			while(*(BYTE * volatile *)&amp;Pos1!=Queue1)
+				boost::thread::yield();
+		}
+		if(WasSynced) {
+			Sync=WritePos;
+			while(Sync==WritePos)
+				boost::thread::yield();
+			WasSynced=FALSE;
+		}
+		Pos2=WritePos;
+		Locks2.Unlock();
+		Locked2=FALSE;
+	}
+	Write=NULL;
+	WritePos=NULL;
+	WriteSize=NULL;
+}
+
+BOOL gmlQueue::GetWrite(BOOL critical) {
+	do {
+		if(!Locked1 &amp;&amp; Pos1==Queue1) {
+			if(Locks1.Lock()) {
+				Locked1=TRUE;
+				ReleaseWrite(FALSE);
+				WritePos=Write=Queue1;
+				WriteSize=Size1;
+				return TRUE;
+			}
+		}
+		if(!Locked2 &amp;&amp; Pos2==Queue2) {
+			if(Locks2.Lock()) {
+				Locked2=TRUE;
+				ReleaseWrite(FALSE);
+				WritePos=Write=Queue2;
+				WriteSize=Size2;
+				return TRUE;
+			}
+		}
+		boost::thread::yield();
+	} while(critical);
+	return FALSE;
+}
+
+void gmlQueue::ReleaseRead() {
+	if(Read==NULL)
+		return;
+	if(Read==Queue1) {
+		Pos1=Queue1;
+		Locks1.Unlock();
+		Locked1=FALSE;
+	}
+	else {
+		Pos2=Queue2;
+		Locks2.Unlock();
+		Locked2=FALSE;
+	}
+	Read=NULL;
+	ReadPos=NULL;
+}
+
+BOOL gmlQueue::GetRead() {
+	if(!Locked1 &amp;&amp; Pos1!=Queue1) {
+		if(Locks1.Lock()) {
+			Locked1=TRUE;
+			Read=Queue1;
+			ReadPos=Pos1;
+			return TRUE;
+		}
+	}
+	if(!Locked2 &amp;&amp; Pos2!=Queue2) {
+		if(Locks2.Lock()) {
+			Locked2=TRUE;
+			Read=Queue2;
+			ReadPos=Pos2;
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+
+void gmlQueue::SyncRequest() {
+	if(Write==Queue1) {
+		while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
+			boost::thread::yield();
+	}
+	if(Write==Queue2) {
+		while(*(BYTE * volatile *)&amp;Pos1!=Queue1)
+			boost::thread::yield();
+	}
+	BYTE *wp=WritePos;
+	*(BYTE * volatile *)&amp;WritePos=wp;
+	WasSynced=TRUE;
+	Sync=EXEC_SYNC;
+	while(Sync==EXEC_SYNC)
+		boost::thread::yield();
+}
+
+
+// Handler definition macros
+// These handlers execute GL commands from the queues
+#define GML_MAKEHANDLER0(name) case gml##name##Enum:\
+	gl##name();\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER0R(name) case gml##name##Enum:\
+	((gml##name##Data *)p)-&gt;ret=gl##name();\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER1(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER1R(name) case gml##name##Enum:\
+	((gml##name##Data *)p)-&gt;ret=gl##name(((gml##name##Data *)p)-&gt;A);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER2(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER2R(name) case gml##name##Enum:\
+	((gml##name##Data *)p)-&gt;ret=gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER3(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER4(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER5(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER6(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER7(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER8(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER9(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER9R(name) case gml##name##Enum:\
+	((gml##name##Data *)p)-&gt;ret=gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I);\
+        p+=sizeof(gml##name##Data);\
+        break;
+
+#define GML_MAKEHANDLER10(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I,((gml##name##Data *)p)-&gt;J);\
+        p+=sizeof(gml##name##Data);\
+        break;
+//glTexImage1D
+#define GML_MAKEHANDLER8S(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)+1);\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glTexImage2D
+#define GML_MAKEHANDLER9S(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)+1);\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glTexImage3D
+#define GML_MAKEHANDLER10S(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I,((gml##name##Data *)p)+1);\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glColor4fv
+#define GML_MAKEHANDLER1V(name) case gml##name##Enum:\
+	gl##name((&amp;((gml##name##Data *)p)-&gt;A));\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glFogfv
+#define GML_MAKEHANDLER2V(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,(&amp;((gml##name##Data *)p)-&gt;B));\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glLight
+#define GML_MAKEHANDLER3V(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,(&amp;((gml##name##Data *)p)-&gt;C));\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glUniformMatrix4fv
+#define GML_MAKEHANDLER4V(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,(&amp;((gml##name##Data *)p)-&gt;D));\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glBufferDataARB
+#define GML_MAKEHANDLER4VS(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,(&amp;((gml##name##Data *)p)-&gt;C),((gml##name##Data *)p)-&gt;D);\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glShaderSource
+#define GML_MAKEHANDLER4VSS(name,type) case gml##name##Enum:\
+	ptr=(BYTE *)((gml##name##Data *)p)+((gml##name##Data *)p)-&gt;lensize;\
+	for(int i=0; i&lt;((gml##name##Data *)p)-&gt;B; ++i) {\
+		GLint j=((GLint *)&amp;((gml##name##Data *)p)-&gt;C)[i];\
+		(&amp;((gml##name##Data *)p)-&gt;C)[i]=(type *)ptr;\
+		ptr+=j;\
+	}\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,(&amp;((gml##name##Data *)p)-&gt;C),NULL);\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glCompressedTexImage1DARB
+#define GML_MAKEHANDLER7V(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,(&amp;((gml##name##Data *)p)-&gt;G));\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glCompressedTexImage2DARB
+#define GML_MAKEHANDLER8V(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,(&amp;((gml##name##Data *)p)-&gt;H));\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glCompressedTexImage3DARB
+#define GML_MAKEHANDLER9V(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,(&amp;((gml##name##Data *)p)-&gt;I));\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//gluBuild2DMipmaps
+#define GML_MAKEHANDLER7S(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)+1);\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+//glLight
+#define GMLMAKESUBHANDLER2(flag,fun,arg,name)\
+	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+ 	  fun(0,ptr);\
+	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
+	}
+#define GMLMAKESUBHANDLER3(flag,fun,arg,name)\
+	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+ 	  fun(((gml##name##Data *)p)-&gt;arg##type,0,ptr);\
+	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
+	}
+#define GMLMAKESUBHANDLER4(flag,fun,arg,name)\
+	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+ 	  fun(((gml##name##Data *)p)-&gt;arg##size,((gml##name##Data *)p)-&gt;arg##type,0,ptr);\
+	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
+	}
+#define GMLMAKESUBHANDLERVA(name)\
+	for(int i=0; i&lt;((gml##name##Data *)p)-&gt;VAcount; ++i) {\
+	  VAstruct *va=(VAstruct *)ptr;\
+ 	  glVertexAttribPointer(va-&gt;target,va-&gt;size,va-&gt;type,va-&gt;normalized,0,ptr+sizeof(VAstruct));\
+	  ptr+=va-&gt;totalsize;\
+	}
+
+
+#define GML_MAKEHANDLER3VDA(name) case gml##name##Enum:\
+	ptr=(BYTE *)(((gml##name##Data *)p)+1);\
+	GMLMAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
+	GMLMAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
+	GMLMAKESUBHANDLER4(GL_TEXTURE_COORD_ARRAY,glTexCoordPointer,TCP,name)\
+	GMLMAKESUBHANDLER3(GL_INDEX_ARRAY,glIndexPointer,IP,name)\
+	GMLMAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
+	GMLMAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
+	GMLMAKESUBHANDLERVA(name)\
+	gl##name(((gml##name##Data *)p)-&gt;A,0/*((gml##name##Data *)p)-&gt;B*/,((gml##name##Data *)p)-&gt;C);\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+
+#define GML_MAKEHANDLER4VDE(name) case gml##name##Enum:\
+	ptr=(BYTE *)(((gml##name##Data *)p)+1);\
+	ptr+=((gml##name##Data *)p)-&gt;IDXtotalsize;\
+	GMLMAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
+	GMLMAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
+	GMLMAKESUBHANDLER4(GL_TEXTURE_COORD_ARRAY,glTexCoordPointer,TCP,name)\
+	GMLMAKESUBHANDLER3(GL_INDEX_ARRAY,glIndexPointer,IP,name)\
+	GMLMAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
+	GMLMAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
+	GMLMAKESUBHANDLERVA(name)\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)+1);\
+        p+=((gml##name##Data *)p)-&gt;size;\
+        break;
+
+
+#include &quot;gmlfun.h&quot;
+// this item server instance needs gmlDeleteLists from gmlfun.h, that is why it is declared down here
+gmlItemSequenceServer&lt;GLuint, GLsizei,GLuint (__stdcall *)(GLsizei)&gt; gmlListServer(&amp;glGenLists, &amp;gmlDeleteLists, 100, 25, 20, 5);
+
+// queue handler - exequtes one GL command from queue (pointed to by p)
+// ptr is a temporary variable used inside the handlers
+inline void QueueHandler(BYTE *&amp;p, BYTE *&amp;ptr) {
+		switch(*(int *)p) {
+  			GML_MAKEHANDLER1(Disable)
+				GML_MAKEHANDLER1(Enable)
+				GML_MAKEHANDLER2(BindTexture)
+				GML_MAKEHANDLER3(TexParameteri)
+				GML_MAKEHANDLER1(ActiveTextureARB)
+				GML_MAKEHANDLER4(Color4f)
+				GML_MAKEHANDLER3(Vertex3f)
+				GML_MAKEHANDLER3(TexEnvi)
+				GML_MAKEHANDLER2(TexCoord2f)
+				GML_MAKEHANDLER6(ProgramEnvParameter4fARB)
+				GML_MAKEHANDLER0(End)
+				GML_MAKEHANDLER1(Begin)
+				GML_MAKEHANDLER1(MatrixMode)
+				GML_MAKEHANDLER2(Vertex2f)
+				GML_MAKEHANDLER0(PopMatrix)
+				GML_MAKEHANDLER0(PushMatrix)
+				GML_MAKEHANDLER0(LoadIdentity)
+				GML_MAKEHANDLER3(Translatef)
+				GML_MAKEHANDLER2(BlendFunc)
+				GML_MAKEHANDLER1(CallList)
+				GML_MAKEHANDLER3(Color3f)
+				GML_MAKEHANDLER9S(TexImage2D)
+				GML_MAKEHANDLER1V(Color4fv)
+				GML_MAKEHANDLER2(BindProgramARB)
+				GML_MAKEHANDLER3(Scalef)
+				GML_MAKEHANDLER4(Viewport)
+				GML_MAKEHANDLER2V(DeleteTextures)
+				GML_MAKEHANDLER3(MultiTexCoord2fARB)
+				GML_MAKEHANDLER2(AlphaFunc)
+				GML_MAKEHANDLER1(DepthMask)
+				GML_MAKEHANDLER1(LineWidth)
+				GML_MAKEHANDLER2(BindFramebufferEXT)
+				GML_MAKEHANDLER4(Rotatef)
+				GML_MAKEHANDLER2(DeleteLists)
+				GML_MAKEHANDLER1(DisableClientState)
+				GML_MAKEHANDLER1(EnableClientState)
+				GML_MAKEHANDLER4(Rectf)
+				GML_MAKEHANDLER3V(Lightfv)
+				GML_MAKEHANDLER7S(uBuild2DMipmaps)
+				GML_MAKEHANDLER1(Clear)
+				GML_MAKEHANDLER0(EndList)
+				GML_MAKEHANDLER2(NewList)
+				GML_MAKEHANDLER4(ClearColor)
+				GML_MAKEHANDLER2(PolygonMode)
+				GML_MAKEHANDLER1(ActiveTexture)
+				GML_MAKEHANDLER2(Fogf)
+				GML_MAKEHANDLER1V(MultMatrixf)
+				GML_MAKEHANDLER6(Ortho)
+				GML_MAKEHANDLER0(PopAttrib)
+				GML_MAKEHANDLER3V(Materialfv)
+				GML_MAKEHANDLER2(PolygonOffset)
+				GML_MAKEHANDLER1(PushAttrib)
+				GML_MAKEHANDLER1(CullFace)
+				GML_MAKEHANDLER4(ColorMask)
+				GML_MAKEHANDLER1V(Vertex3fv)
+				GML_MAKEHANDLER3V(TexGenfv)
+				GML_MAKEHANDLER2(Vertex2d)
+				GML_MAKEHANDLER4(VertexPointer)
+				GML_MAKEHANDLER3VDA(DrawArrays)
+				GML_MAKEHANDLER2V(Fogfv)
+				GML_MAKEHANDLER5(FramebufferTexture2DEXT)
+				GML_MAKEHANDLER4(TexCoordPointer)
+				GML_MAKEHANDLER9S(TexSubImage2D)
+				GML_MAKEHANDLER2V(ClipPlane)
+				GML_MAKEHANDLER4(Color4d)
+				GML_MAKEHANDLER2(LightModeli)
+				GML_MAKEHANDLER3(TexGeni)
+				GML_MAKEHANDLER3(TexParameterf)
+				GML_MAKEHANDLER8(CopyTexSubImage2D)
+				GML_MAKEHANDLER2V(DeleteFramebuffersEXT)
+				GML_MAKEHANDLER1V(LoadMatrixf)
+				GML_MAKEHANDLER1(ShadeModel)
+				GML_MAKEHANDLER1(UseProgram)
+				GML_MAKEHANDLER1(ClientActiveTextureARB)
+				GML_MAKEHANDLER2V(DeleteRenderbuffersEXT)
+				GML_MAKEHANDLER0(Flush)
+				GML_MAKEHANDLER3(Normal3f)
+				GML_MAKEHANDLER1(UseProgramObjectARB)
+				GML_MAKEHANDLER8V(CompressedTexImage2DARB)
+				GML_MAKEHANDLER1(DeleteObjectARB)
+				GML_MAKEHANDLER2(Fogi)
+				GML_MAKEHANDLER1V(MultMatrixd)
+				GML_MAKEHANDLER2(PixelStorei)
+				GML_MAKEHANDLER2(PointParameterf)
+				GML_MAKEHANDLER3(TexCoord3f)
+				GML_MAKEHANDLER2(Uniform1i)
+				GML_MAKEHANDLER2(BindRenderbufferEXT)
+				GML_MAKEHANDLER1V(Color3fv)
+				GML_MAKEHANDLER1(DepthFunc)
+				GML_MAKEHANDLER2(Hint)
+				GML_MAKEHANDLER1(LogicOp)
+				GML_MAKEHANDLER3(StencilOp)
+				GML_MAKEHANDLER3V(TexEnvfv)
+				GML_MAKEHANDLER4V(UniformMatrix4fv)
+				GML_MAKEHANDLER4(uOrtho2D)
+				GML_MAKEHANDLER2(AttachObjectARB)
+				GML_MAKEHANDLER2(BindBufferARB)
+				GML_MAKEHANDLER1V(Color3ubv)
+				GML_MAKEHANDLER2(DetachObjectARB)
+				GML_MAKEHANDLER4(FramebufferRenderbufferEXT)
+				GML_MAKEHANDLER2(LineStipple)
+				GML_MAKEHANDLER1V(LoadMatrixd)
+				GML_MAKEHANDLER2(SetFenceNV)
+				GML_MAKEHANDLER3(StencilFunc)
+				GML_MAKEHANDLER10S(TexImage3D)
+				GML_MAKEHANDLER2(Uniform1f)
+				GML_MAKEHANDLER1(ClearStencil)
+				GML_MAKEHANDLER4(ColorPointer)
+				GML_MAKEHANDLER1(DeleteShader)
+				GML_MAKEHANDLER4VDE(DrawElements)
+				GML_MAKEHANDLER1(GenerateMipmapEXT)
+				GML_MAKEHANDLER3(Materialf)
+				GML_MAKEHANDLER3(NormalPointer)
+				GML_MAKEHANDLER3V(ProgramEnvParameter4fvARB)
+				GML_MAKEHANDLER4(RenderbufferStorageEXT)
+				GML_MAKEHANDLER1(StencilMask)
+				GML_MAKEHANDLER4(Uniform3f)
+				GML_MAKEHANDLER4(uPerspective)
+				GML_MAKEHANDLER1(ActiveStencilFaceEXT)
+				GML_MAKEHANDLER2(AttachShader)
+				GML_MAKEHANDLER10(BlitFramebufferEXT)
+				GML_MAKEHANDLER4VS(BufferDataARB)
+				GML_MAKEHANDLER1(ClearDepth)
+				GML_MAKEHANDLER3(Color3ub)
+				GML_MAKEHANDLER7V(CompressedTexImage1DARB)
+				GML_MAKEHANDLER9V(CompressedTexImage3DARB)
+				GML_MAKEHANDLER1(DrawBuffer)
+				GML_MAKEHANDLER1(FrontFace)
+				GML_MAKEHANDLER6(Frustum)
+				GML_MAKEHANDLER1(LinkProgramARB)
+				GML_MAKEHANDLER2(MultiTexCoord1f)
+				GML_MAKEHANDLER3(MultiTexCoord2f)
+				GML_MAKEHANDLER4(MultiTexCoord3f)
+				GML_MAKEHANDLER5(MultiTexCoord4f)
+				GML_MAKEHANDLER2V(PointParameterfv)
+				GML_MAKEHANDLER1(PointSize)
+				GML_MAKEHANDLER4V(ProgramStringARB)
+				GML_MAKEHANDLER3(SecondaryColor3f)
+				GML_MAKEHANDLER1(TexCoord1f)
+				GML_MAKEHANDLER4(TexCoord4f)
+				GML_MAKEHANDLER3(TexEnvf)
+				GML_MAKEHANDLER3(TexGenf)
+				GML_MAKEHANDLER8S(TexImage1D)
+				GML_MAKEHANDLER2(Uniform1iARB)
+				GML_MAKEHANDLER3(Uniform2f)
+				GML_MAKEHANDLER3(Uniform2fARB)
+				GML_MAKEHANDLER3(Uniform2i)
+				GML_MAKEHANDLER4(Uniform3fARB)
+				GML_MAKEHANDLER4(Uniform3i)
+				GML_MAKEHANDLER5(Uniform4f)
+				GML_MAKEHANDLER5(Uniform4i)
+				GML_MAKEHANDLER4V(UniformMatrix2fv)
+				GML_MAKEHANDLER4V(UniformMatrix3fv)
+				GML_MAKEHANDLER4(Vertex4f)
+				GML_MAKEHANDLER1(uDeleteQuadric)
+				GML_MAKEHANDLER2(uQuadricDrawStyle)
+				GML_MAKEHANDLER4(uSphere)
+				GML_MAKEHANDLER4(ClearAccum)
+				GML_MAKEHANDLER4(Color4ub)
+				GML_MAKEHANDLER1V(Color4ubv)
+				GML_MAKEHANDLER1(CompileShader)
+				GML_MAKEHANDLER1(CompileShaderARB)
+				GML_MAKEHANDLER8(CopyTexImage2D)
+				GML_MAKEHANDLER2V(DeleteBuffersARB)
+				GML_MAKEHANDLER2V(DeleteFencesNV)
+				GML_MAKEHANDLER1(DeleteProgram)
+				GML_MAKEHANDLER2V(DeleteProgramsARB)
+				GML_MAKEHANDLER2(DetachShader)
+				GML_MAKEHANDLER1(DisableVertexAttribArrayARB)
+				GML_MAKEHANDLER2V(DrawBuffersARB)
+				GML_MAKEHANDLER1(EdgeFlag)
+				GML_MAKEHANDLER1(EnableVertexAttribArrayARB)
+				GML_MAKEHANDLER0(Finish)
+				GML_MAKEHANDLER1(FinishFenceNV)
+				GML_MAKEHANDLER1(FogCoordf)
+				GML_MAKEHANDLER3(Lightf)
+				GML_MAKEHANDLER1(LinkProgram)
+				GML_MAKEHANDLER1V(Normal3fv)
+				GML_MAKEHANDLER2(RasterPos2i)
+				GML_MAKEHANDLER1(ReadBuffer)
+				GML_MAKEHANDLER4(Scissor)
+				GML_MAKEHANDLER4VSS(ShaderSource,GLchar)
+				GML_MAKEHANDLER4VSS(ShaderSourceARB,GLcharARB)
+				GML_MAKEHANDLER1V(TexCoord2fv)
+				GML_MAKEHANDLER3V(TexParameterfv)
+				GML_MAKEHANDLER3(Translated)
+				GML_MAKEHANDLER3V(Uniform1fv)
+				GML_MAKEHANDLER5(Uniform4fARB)
+				GML_MAKEHANDLER4V(UniformMatrix4fvARB)
+				GML_MAKEHANDLER6(VertexAttribPointerARB)
+				GML_MAKEHANDLER9(uLookAt)
+				GML_MAKEHANDLER2V(LightModelfv)
+
+				GML_MAKEHANDLER2V(DeleteQueries)
+				GML_MAKEHANDLER1(BlendEquation)
+				GML_MAKEHANDLER2(StencilMaskSeparate)
+				GML_MAKEHANDLER4(StencilFuncSeparate)
+				GML_MAKEHANDLER4(StencilOpSeparate)
+				GML_MAKEHANDLER2(BeginQuery)
+				GML_MAKEHANDLER1(EndQuery)
+				GML_MAKEHANDLER3(GetQueryObjectuiv)
+				GML_MAKEHANDLER2(BlendEquationSeparate)
+				GML_MAKEHANDLER4(BlendFuncSeparate)
+				GML_MAKEHANDLER6(uCylinder)
+
+				GML_MAKEHANDLER2(GetIntegerv)
+				GML_MAKEHANDLER1R(CheckFramebufferStatusEXT)
+				GML_MAKEHANDLER2(GetFloatv)
+				GML_MAKEHANDLER1R(GetString)
+				GML_MAKEHANDLER2R(GetUniformLocationARB)
+				GML_MAKEHANDLER7(ReadPixels)
+				GML_MAKEHANDLER0R(GetError)
+				GML_MAKEHANDLER3(GetObjectParameterivARB)
+				GML_MAKEHANDLER2R(GetUniformLocation)
+				GML_MAKEHANDLER2(GetDoublev)
+				GML_MAKEHANDLER3(GetProgramiv)
+				GML_MAKEHANDLER7(GetActiveUniform)
+				GML_MAKEHANDLER2R(GetAttribLocationARB)
+				GML_MAKEHANDLER4(GetInfoLogARB)
+				GML_MAKEHANDLER4(GetProgramInfoLog)
+				GML_MAKEHANDLER3(GetProgramivARB)
+				GML_MAKEHANDLER4(GetShaderInfoLog)
+				GML_MAKEHANDLER3(GetShaderiv)
+				GML_MAKEHANDLER1R(IsRenderbufferEXT)
+				GML_MAKEHANDLER2R(MapBufferARB)
+				GML_MAKEHANDLER9R(uProject)
+				GML_MAKEHANDLER9R(uScaleImage)
+				GML_MAKEHANDLER1R(TestFenceNV)
+
+				GML_MAKEHANDLER3(IndexPointer)
+				GML_MAKEHANDLER2(EdgeFlagPointer)
+				GML_MAKEHANDLER4(TrackMatrixNV)
+		}
+}
+
+// Execute - executes all GL commands in the current read queue.
+// Execution is non-synced
+void gmlQueue::Execute() {
+  BYTE *p=Read;
+  BYTE *e=ReadPos;
+  BYTE *ptr=NULL;
+	int procs=0;
+
+  while(p&lt;e) {
+//   	GML_DEBUG(&quot;Cmd &quot;,*(int *)p);
+    QueueHandler(p,ptr);
+		++procs;
+	}
+//	GML_DEBUG(&quot;Execute &quot;,procs);
+}
+
+extern void gmlUpdateServers();
+
+// Execute - executes all GL commands in the current read queue.
+// Execution is synced (this means it will stop at certain points
+// to return values to the worker thread)
+void gmlQueue::ExecuteSynced() {
+  BYTE *p=Write;
+  BYTE *e=WritePos;
+  BYTE *ptr=NULL;
+	BOOL isq1=Write==Queue1;
+	BOOL end=FALSE;
+	int procs=0;
+  int updserv=0;
+
+  while(TRUE) {
+		if(!end) {
+			while(TRUE) {
+  			if(Reloc)
+	  			e=Realloc(&amp;p);
+				if(((++updserv)%GML_UPDSRV_INTERVAL)==0)
+					gmlUpdateServers();
+				BYTE *s=(BYTE *)Sync;
+				if(s!=EXEC_RUN) {
+  				if(s!=EXEC_SYNC) { // end addr ready
+	  				end=TRUE;
+		  			e=s;
+     	  		Sync=EXEC_RUN;
+						break;
+					}
+    			if(p==*(BYTE * volatile *)&amp;WritePos) // reached sync point
+    	  		Sync=EXEC_RUN;
+				}
+				if(p&lt;*(BYTE * volatile *)&amp;WritePos)
+					break;
+			}
+		}
+		if(end) {
+			if(p==e)
+				break;
+		}
+//   	GML_DEBUG(&quot;CmdSync &quot;,*(int *)p);
+		QueueHandler(p,ptr);
+		++procs;
+	}
+//  GML_DEBUG(&quot;ExecuteSync &quot;,procs);
+	if(isq1) {
+		while(Locked1)
+			boost::thread::yield();
+		Pos1=Queue1;
+	}
+	else {
+		while(Locked2)
+			boost::thread::yield();
+		Pos2=Queue2;
+	}
+}

Added: branches/gml/rts/lib/gml/gml.h
===================================================================
--- branches/gml/rts/lib/gml/gml.h	                        (rev 0)
+++ branches/gml/rts/lib/gml/gml.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -0,0 +1,151 @@
+// GML - OpenGL Multithreading Library
+// for Spring <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
+// Author: Mattias &quot;zerver&quot; Radeskog
+// (C) Ware Zerver Tech. <A HREF="http://zerver.net">http://zerver.net</A>
+// Ware Zerver Tech. licenses this library
+// to be used freely for any purpose, as
+// long as this notice remains unchanged
+
+#ifndef GML_H
+#define GML_H
+
+#include &lt;set&gt;
+#include &lt;map&gt;
+#include &lt;GL/glew.h&gt;
+#include &lt;boost/thread/mutex.hpp&gt;
+#include &lt;boost/thread/thread.hpp&gt;
+#include &lt;boost/detail/atomic_count.hpp&gt;
+
+#include &quot;gmlcls.h&quot;
+
+extern __declspec(thread) int gmlThreadNumber;
+extern gmlQueue gmlQueues[GML_MAX_NUM_THREADS];
+
+#include &quot;gmlfun.h&quot;
+
+extern boost::thread *gmlThreads[GML_MAX_NUM_THREADS];
+
+extern gmlSingleItemServer&lt;GLhandleARB, PFNGLCREATEPROGRAMPROC *__w64&gt; gmlProgramServer;
+extern gmlSingleItemServer&lt;GLhandleARB, PFNGLCREATEPROGRAMOBJECTARBPROC *__w64&gt; gmlProgramObjectARBServer;
+
+extern gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (__cdecl *)(void)&gt; gmlShaderServer_VERTEX;
+extern gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (__cdecl *)(void)&gt; gmlShaderServer_FRAGMENT;
+
+extern gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (__cdecl *)(void)&gt; gmlShaderObjectARBServer_VERTEX;
+extern gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (__cdecl *)(void)&gt; gmlShaderObjectARBServer_FRAGMENT;
+extern gmlSingleItemServer&lt;GLUquadric *, GLUquadric *(__stdcall *)(void)&gt; gmlQuadricServer;
+
+extern void gmlInit();
+
+EXTERN inline GLhandleARB gmlCreateProgram() {
+	return gmlProgramServer.GetItems();
+}
+EXTERN inline GLhandleARB gmlCreateProgramObjectARB() {
+	return gmlProgramObjectARBServer.GetItems();
+}
+EXTERN inline GLhandleARB gmlCreateShader(GLenum type) {
+	if(type==GL_VERTEX_SHADER)
+  	  return gmlShaderServer_VERTEX.GetItems();
+	if(type==GL_FRAGMENT_SHADER)
+  	  return gmlShaderServer_FRAGMENT.GetItems();
+	return 0;
+}
+EXTERN inline GLhandleARB gmlCreateShaderObjectARB(GLenum type) {
+	if(type==GL_VERTEX_SHADER_ARB)
+  	  return gmlShaderObjectARBServer_VERTEX.GetItems();
+	if(type==GL_FRAGMENT_SHADER_ARB)
+  	  return gmlShaderObjectARBServer_FRAGMENT.GetItems();
+	return 0;
+}
+EXTERN inline GLUquadric *gmluNewQuadric() {
+	return gmlQuadricServer.GetItems();
+}
+
+
+extern gmlMultiItemServer&lt;GLuint, GLsizei, void (__stdcall *)(GLsizei,GLuint *)&gt; gmlTextureServer;
+extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSARBPROC *__w64&gt; gmlBufferARBServer;
+extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENFENCESNVPROC *__w64&gt; gmlFencesNVServer;
+extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENPROGRAMSARBPROC *__w64&gt; gmlProgramsARBServer;
+extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENRENDERBUFFERSEXTPROC *__w64&gt; gmlRenderbuffersEXTServer;
+extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENFRAMEBUFFERSEXTPROC *__w64&gt; gmlFramebuffersEXTServer;
+extern gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENQUERIESPROC *__w64&gt; gmlQueryServer;
+
+EXTERN inline void gmlGenTextures(GLsizei n, GLuint *items) {
+	gmlTextureServer.GetItems(n, items);
+}
+EXTERN inline void gmlGenBuffersARB(GLsizei n, GLuint *items) {
+	gmlBufferARBServer.GetItems(n, items);
+}
+EXTERN inline void gmlGenFencesNV(GLsizei n, GLuint *items) {
+	gmlFencesNVServer.GetItems(n, items);
+}
+EXTERN inline void gmlGenProgramsARB(GLsizei n, GLuint *items) {
+	gmlProgramsARBServer.GetItems(n, items);
+}
+EXTERN inline void gmlGenRenderbuffersEXT(GLsizei n, GLuint *items) {
+	gmlRenderbuffersEXTServer.GetItems(n, items);
+}
+EXTERN inline void gmlGenFramebuffersEXT(GLsizei n, GLuint *items) {
+	gmlFramebuffersEXTServer.GetItems(n, items);
+}
+EXTERN inline void gmlGenQueries(GLsizei n, GLuint *items) {
+	gmlQueryServer.GetItems(n, items);
+}
+
+
+
+extern gmlItemSequenceServer&lt;GLuint, GLsizei,GLuint (__stdcall *)(GLsizei)&gt; gmlListServer;
+
+EXTERN inline GLuint gmlGenLists(GLsizei items) {
+  return gmlListServer.GetItems(items);
+}
+
+EXTERN inline void gmlUpdateServers() {
+	gmlProgramServer.GenerateItems();
+	gmlProgramObjectARBServer.GenerateItems();
+	gmlShaderServer_VERTEX.GenerateItems();
+	gmlShaderServer_FRAGMENT.GenerateItems();
+	gmlShaderObjectARBServer_VERTEX.GenerateItems();
+	gmlShaderObjectARBServer_FRAGMENT.GenerateItems();
+	gmlQuadricServer.GenerateItems();
+
+	gmlTextureServer.GenerateItems();
+	gmlBufferARBServer.GenerateItems();
+	gmlFencesNVServer.GenerateItems();
+	gmlProgramsARBServer.GenerateItems();
+	gmlRenderbuffersEXTServer.GenerateItems();
+	gmlFramebuffersEXTServer.GenerateItems();
+	gmlQueryServer.GenerateItems();
+
+	gmlListServer.GenerateItems();
+}
+
+#if GML_ENABLE
+#include &quot;gmlimp.h&quot;
+#include &quot;gmldef.h&quot;
+#define GML_VECTOR gmlVector
+#define GML_CLASSVECTOR gmlClassVector
+#else
+#define GML_VECTOR std::vector
+#define GML_CLASSVECTOR std::vector
+#endif
+
+extern bool gmlExperimentalMode;
+
+#if GML_ENABLE &amp;&amp; GML_EXPERIMENTAL
+#define GML_VECTOR_EXP gmlVector
+#define GML_CLASSVECTOR_EXP gmlClassVector
+#define GML_EXP_MODE() gmlExperimentalMode
+#define GML_EXP_MODE_ENABLE() gmlExperimentalMode=true;
+#define GML_EXP_MODE_DISABLE() gmlExperimentalMode=false;
+#else
+#define GML_VECTOR_EXP std::vector
+#define GML_CLASSVECTOR_EXP std::vector
+#define GML_EXP_MODE() 0
+#define GML_EXP_MODE_ENABLE()
+#define GML_EXP_MODE_DISABLE()
+#endif
+
+
+
+#endif
\ No newline at end of file

Added: branches/gml/rts/lib/gml/gmlcls.h
===================================================================
--- branches/gml/rts/lib/gml/gmlcls.h	                        (rev 0)
+++ branches/gml/rts/lib/gml/gmlcls.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -0,0 +1,629 @@
+// GML - OpenGL Multithreading Library
+// for Spring <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
+// Author: Mattias &quot;zerver&quot; Radeskog
+// (C) Ware Zerver Tech. <A HREF="http://zerver.net">http://zerver.net</A>
+// Ware Zerver Tech. licenses this library
+// to be used freely for any purpose, as
+// long as this notice remains unchanged
+
+#ifndef GMLCLASSES_H
+#define GMLCLASSES_H
+
+#include &lt;GL/glew.h&gt;
+#include &lt;boost/thread/mutex.hpp&gt;
+#include &lt;boost/thread/thread.hpp&gt;
+#include &lt;boost/detail/atomic_count.hpp&gt;
+
+#define GML_ENABLE 1 // opengl multithread enable
+#define GML_ENABLE_SIM (GML_ENABLE &amp;&amp; 1) // runs the sim in a separate thread
+#define GML_ENABLE_DRAWALL (GML_ENABLE &amp;&amp; 0) // draws everything in a separate thread (for testing only, will degrade performance)
+#define GML_ENABLE_DRAWUNIT (GML_ENABLE &amp;&amp; 1) // draws units using multithreading
+#define GML_SERVER_GLCALL 1 // allow the server thread (0) to make direct GL calls
+#define GML_INIT_QUEUE_SIZE 10 // initial queue size, will be reallocated, but must be &gt;= 1
+#define GML_USE_NO_ERROR 1 // glGetError always returns success (to improve performance)
+#define GML_USE_DEFAULT 1// compile/link/buffer status always returns TRUE/COMPLETE (to improve performance)
+#define GML_USE_CACHE 1 // certain glGet calls may use data cached during gmlInit (to improve performance)
+//#define GML_USE_QUADRIC_SERVER 1 // use server thread to create/delete quadrics
+#define GML_UPDSRV_INTERVAL 10
+#define GML_EXPERIMENTAL 0
+
+extern int gmlThreadCount;
+extern int gmlThreadCountOverride;
+extern unsigned gmlCPUCount();
+#define GML_CPU_COUNT (gmlThreadCountOverride?gmlThreadCountOverride:gmlCPUCount())
+#define GML_MAX_NUM_THREADS 32
+#define GML_IF_SERVER_THREAD() if(GML_SERVER_GLCALL &amp;&amp; (!GML_ENABLE || gmlThreadNumber==0))
+
+typedef unsigned char       BYTE;
+typedef int                 BOOL;
+
+#define TRUE 1
+#define FALSE 0
+#define EXTERN
+
+#define GML_ERROR(str,val)\
+FILE *f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
+if(f) {\
+	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+	fclose(f);\
+}\
+Sleep(1000);
+
+#define GML_DEBUG(str,val)\
+FILE *f=fopen(&quot;C:\\GMLDBG.TXT&quot;,&quot;a&quot;);\
+if(f) {\
+	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+	fclose(f);\
+}
+
+
+inline void operator%=(boost::detail::atomic_count&amp; a, long val) {
+#ifdef BOOST_AC_USE_PTHREADS
+	a.~boost::detail::atomic_count();
+#endif
+  new (&amp;a) boost::detail::atomic_count(val);
+}
+
+#include &lt;iterator&gt;
+
+template&lt;class T&gt;
+struct gmlVectorIter {
+	T *p; 
+	gmlVectorIter() {} 
+	gmlVectorIter(T *d) {p=d;} 
+	void operator=(const typename gmlVectorIter&lt;T&gt; &amp;i) {p=i.p;}
+	typename gmlVectorIter&lt;T&gt; &amp;operator++() {++p; return *this;} 
+	typename gmlVectorIter&lt;T&gt; operator++(int) {return typename gmlVectorIter&lt;T&gt;(p++);} 
+	int operator!=(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p!=i.p;}
+
+	int operator-(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p-i.p;}
+	int operator&lt;(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p&lt;i.p;}
+	typename gmlVectorIter&lt;T&gt; &amp;operator--() {--p; return *this;} 
+	typename gmlVectorIter&lt;T&gt; operator--(int) {return typename gmlVectorIter&lt;T&gt;(p--);} 
+//	typename gmlVectorIter&lt;T&gt; operator-(const typename gmlVectorIter&lt;T&gt; &amp;i) {return typename gmlVectorIter&lt;T&gt;(p-i.p);}
+	typename gmlVectorIter&lt;T&gt; operator+(int i) const {return typename gmlVectorIter&lt;T&gt;(p+i);}
+	typename gmlVectorIter&lt;T&gt; operator-(int i) const {return typename gmlVectorIter&lt;T&gt;(p-i);}
+	int operator==(const typename gmlVectorIter&lt;T&gt; &amp;i) const {return p==i.p;}
+	T &amp;operator*() {return *p;}
+
+	typedef std::random_access_iterator_tag iterator_category;
+	typedef T                          value_type;
+	typedef int/*ptrdiff_t*/                  difference_type;
+	typedef T*                         pointer;
+	typedef T&amp;                         reference;
+};
+
+
+template&lt;class T&gt;
+class gmlClassVector {
+	T *data;
+	boost::detail::atomic_count count;
+	boost::detail::atomic_count added;
+	int maxsize;
+	int doshrink;
+	int shrinksize;
+	int nalloc;
+
+public:
+	gmlClassVector():doshrink(0),shrinksize(0),nalloc(0),count(0),added(0) {
+		data=(T *)malloc(1*sizeof(T));
+		*(volatile int *)&amp;maxsize=1;
+	}
+
+	~gmlClassVector() {
+		if(added&gt;nalloc)
+			nalloc=added;
+		for(int i=0; i&lt;nalloc; ++i)
+			data[i].~T();
+		free(data);
+	}
+
+	typedef typename gmlVectorIter&lt;T&gt; iterator;
+
+	iterator begin() {
+		return iterator(data);
+	}
+
+	iterator end() {
+		return iterator(data+added);
+	}
+
+	long size() const {
+		return added;
+	}
+
+	const T &amp;operator[](int i) const {
+		return data[i];
+	}
+
+	T &amp;operator[](int i) {
+		int sz;
+		while(TRUE) {
+			if(added&lt;=i) {
+				if(count&lt;=i) {
+					if((sz=++count)&lt;=i+1) {
+						if(added==sz-1) {
+							while(sz&gt;*(volatile int *)&amp;maxsize)
+								;
+							if(sz==maxsize)
+								Expand();
+							else
+								while(*(volatile int *)&amp;maxsize&lt;sz)
+									;
+							new (data+sz-1) T();
+          		++added;
+						}
+						else {
+							--count;
+							while(count!=added)
+								boost::thread::yield();
+						}
+					}
+					else {
+						--count;
+					}
+				}
+			}
+			else {
+				return data[i];
+			}
+		}
+	}
+
+	void push_back(T &amp;d) {
+		while(TRUE) {
+			int sz=++count;
+			if(added==sz-1) {
+				while(sz&gt;*(volatile int *)&amp;maxsize)
+					;
+				if(sz==maxsize)
+					Expand();
+				else
+					while(*(volatile int *)&amp;maxsize&lt;sz)
+						;
+				data[sz-1]=d;
+				++added;
+				return;
+			}
+			else {
+				--count;
+				while(count!=added)
+					boost::thread::yield();
+			}
+		}
+	}
+
+	void Expand() {
+		while(added&lt;maxsize-1)
+			;
+		shrinksize=maxsize;
+		int ms2=maxsize&lt;&lt;1;
+		data=(T *)realloc(data,ms2*sizeof(T));
+		*(volatile int *)&amp;maxsize=ms2; // dont reorder
+	}
+
+	void Shrink() {
+		int ms=maxsize&gt;&gt;1;
+		shrinksize=ms&gt;&gt;1;
+		doshrink=0;
+		for(int i=ms; i&lt;nalloc; ++i)
+			data[i].~T();
+		if(ms&lt;nalloc)
+			nalloc=ms;
+		data=(T *)realloc(data,ms*sizeof(T));
+		*(volatile int *)&amp;maxsize=ms;
+	}
+
+	void clear() { // not thread safe
+		if(added&gt;nalloc)
+			nalloc=added;
+		int sz=count;
+		count%=0;
+		added%=0;
+		if(sz&gt;=shrinksize)
+			doshrink=0;
+		else if(++doshrink&gt;=10)
+ 			Shrink();
+	}
+};
+
+template&lt;class T&gt;
+class gmlVector {
+	T *data;
+	boost::detail::atomic_count count;
+	boost::detail::atomic_count added;
+	int maxsize;
+	int doshrink;
+	int shrinksize;
+
+public:
+	gmlVector():doshrink(0),shrinksize(0),count(0),added(0) {
+		data=(T *)malloc(1*sizeof(T));
+		*(volatile int *)&amp;maxsize=1;
+	}
+	gmlVector&lt;T&gt; &amp;operator=(const typename gmlVector&lt;T&gt; &amp;vec) {
+		free(data);
+		memcpy(this,&amp;vec,sizeof(typename gmlVector&lt;T&gt;));
+		data=(T *)malloc(vec.maxsize*sizeof(T));
+		memcpy(data,vec.data,vec.maxsize*sizeof(T));
+		return *this;
+	}
+
+	~gmlVector() {
+		free(data);
+	}
+
+	typedef typename gmlVectorIter&lt;T&gt; iterator;
+
+	iterator begin() {
+		return iterator(data);
+	}
+
+	iterator end() {
+		return iterator(data+added);
+	}
+
+	long size() const {
+		return added;
+	}
+
+	const T &amp;operator[](int i) const {
+		return data[i];
+	}
+
+	T &amp;operator[](int i) {
+		return data[i];
+	}
+
+	void push_back(T &amp;d) { // thread safe
+    int sz=++count;
+  	while(sz&gt;*(volatile int *)&amp;maxsize)
+			;
+		if(sz==maxsize)
+			Expand();
+		else
+  		while(*(volatile int *)&amp;maxsize&lt;sz)
+				;
+		data[sz-1]=d;
+		++added;
+	}
+
+	void Expand() {
+		while(added&lt;maxsize-1)
+			;
+		shrinksize=maxsize;
+		int ms2=maxsize&lt;&lt;1;
+		data=(T *)realloc(data,ms2*sizeof(T));
+		*(volatile int *)&amp;maxsize=ms2; // dont reorder
+	}
+
+	void Shrink() {
+		int ms=maxsize&gt;&gt;1;
+		shrinksize=ms&gt;&gt;1;
+		doshrink=0;
+		data=(T *)realloc(data,ms*sizeof(T));
+		*(volatile int *)&amp;maxsize=ms;
+	}
+
+	void clear() { // not thread safe
+		int sz=count;
+		count%=0;
+		added%=0;
+		if(sz&gt;=shrinksize)
+			doshrink=0;
+		else if(++doshrink&gt;=10)
+ 			Shrink();
+	}
+};
+
+
+class gmlLock {
+  boost::try_mutex sl_mutex;
+  boost::try_mutex::scoped_try_lock sl_lock;
+
+public:
+	gmlLock():sl_lock(sl_mutex,false) {
+	}
+	virtual ~gmlLock() {
+	}
+	bool Lock() {
+		try {
+			return sl_lock.try_lock();
+		} 
+		catch(boost::lock_error&amp;) {
+			return false;
+		}
+	}
+	void Unlock() {
+		sl_lock.unlock();
+	}
+};
+
+
+struct VAdata {
+  GLint size;
+  GLenum type;
+  GLboolean normalized;
+  GLsizei stride;
+  void *pointer;
+  VAdata(){}
+  VAdata(GLint si, GLenum ty, GLboolean no, GLsizei st, void *po):
+    size(si),type(ty),normalized(no),stride(st),pointer(po) {}
+};
+
+struct VAstruct {
+  GLuint target;
+  GLint size;
+  GLenum type;
+  GLboolean normalized;
+  GLsizei stride;
+  int totalsize;
+};
+
+
+struct gmlQueue {
+	std::map&lt;GLuint,VAdata&gt; VAmap;
+	std::set&lt;GLuint&gt; VAset;
+
+	BYTE *ReadPos;
+	BYTE *WritePos;
+	BYTE *Pos1;
+	BYTE *Pos2;
+
+	BYTE *WriteSize;
+	BYTE *Size1;
+	BYTE *Size2;
+
+	BYTE *Read;
+	BYTE *Write;
+	BYTE *Queue1;
+	BYTE *Queue2;
+
+	gmlLock Locks1;
+	gmlLock Locks2;
+	volatile BOOL Locked1;
+	volatile BOOL Locked2;
+
+	volatile BOOL Reloc;
+	BYTE * volatile Sync;
+	BOOL WasSynced;
+
+	GLenum ClientState;
+    // VertexPointer
+	GLint VPsize;
+	GLenum VPtype;
+	GLsizei VPstride;
+	GLvoid *VPpointer;
+    // ColorPointer
+	GLint CPsize;
+	GLenum CPtype;
+	GLsizei CPstride;
+	GLvoid *CPpointer;
+    // EdgeFlagPointer
+	GLsizei EFPstride;
+	GLboolean *EFPpointer;
+    // IndexPointer
+	GLenum IPtype;
+	GLsizei IPstride;
+	GLvoid *IPpointer;
+    // NormalPointer
+	GLenum NPtype;
+	GLsizei NPstride;
+	GLvoid *NPpointer;
+    // TexCoordPointer
+	GLint TCPsize;
+	GLenum TCPtype;
+	GLsizei TCPstride;
+	GLvoid *TCPpointer;
+
+	gmlQueue();
+
+	BYTE *Realloc(BYTE **e=NULL);
+  BYTE *WaitRealloc(BYTE **e=NULL);
+	void ReleaseWrite(BOOL final=TRUE);
+	BOOL GetWrite(BOOL critical);
+	void ReleaseRead();
+	BOOL GetRead();
+	void SyncRequest();
+	void Execute();
+	void ExecuteSynced();
+};
+
+
+template&lt;class T,class S, class C&gt;
+class gmlItemSequenceServer {
+	typedef void (*delitemseqfun)(T, S);
+	C genfun;
+	delitemseqfun delfun;
+	boost::detail::atomic_count req;
+	boost::detail::atomic_count avail;
+	int pregen;
+	int arr_size;
+	T *item_arr;
+	boost::detail::atomic_count req_large;
+	boost::detail::atomic_count avail_large;
+	boost::detail::atomic_count size_large;
+	int pregen_large;	
+	int large_arr_size;
+	T *large_item_arr;
+	T *large_size_arr;
+
+public:
+	gmlItemSequenceServer(C gf, delitemseqfun df, int sz, int pg, int sz_l, int pg_l):
+			req(0),avail(0),req_large(0),avail_large(0),size_large(2) {
+		genfun=gf;
+		delfun=df;
+		pregen=pg;
+		arr_size=sz;
+		item_arr=new T[arr_size];
+		memset(item_arr,0,arr_size*sizeof(T));
+		pregen_large=pg_l;
+		large_arr_size=sz_l;
+		large_item_arr=new T[large_arr_size];
+		large_size_arr=new T[large_arr_size];
+		memset(large_item_arr,0,large_arr_size*sizeof(T));
+		memset(large_size_arr,0,large_arr_size*sizeof(T));
+	}
+
+	virtual ~gmlItemSequenceServer() {
+		delete [] item_arr;
+		delete [] large_item_arr;
+		delete [] large_size_arr;
+	}
+
+	inline void GenerateItems() {
+		// small
+    int i;    
+		while(avail&lt;req+pregen &amp;&amp; item_arr[i=(avail%arr_size)]==0) {
+  		*(volatile T *)(item_arr+i)=(*genfun)(1);
+      ++avail;
+		}
+		// large
+		while(avail_large&lt;req_large+pregen_large &amp;&amp; large_size_arr[i=(avail_large%large_arr_size)]==0) {
+			int gensize=size_large;
+  		*(volatile T *)(large_item_arr+i)=(*genfun)(gensize);
+  		*(volatile T *)(large_size_arr+i)=gensize;
+      ++avail_large;
+		}
+	}
+
+	inline T GetItems(S n) {
+		GML_IF_SERVER_THREAD() {
+			return (*genfun)(n);
+		}
+		if(n==1) {
+			long num=++req;
+			while(avail&lt;num) // waiting
+				boost::thread::yield();
+			T *ip=item_arr+(num-1)%arr_size;
+			T ipv=*ip;
+			*(volatile T *)ip=0;
+			return ipv;
+		}
+		if(n==0)
+			return 0;
+		while(size_large&lt;n)
+			++size_large;
+		while(TRUE) {
+			long num=++req_large;
+			while(avail_large&lt;num) // waiting
+				boost::thread::yield();
+			int idx=(num-1)%large_arr_size;
+			T ip=large_item_arr[idx];
+			T *sz=large_size_arr+idx;
+			T szv=*sz;
+			if(szv&gt;n)
+				(*delfun)(ip+szv,szv-n); // del excessive
+			if(szv&lt;n)
+				(*delfun)(ip,szv); // del all
+			*(volatile T *)sz=0;
+			if(szv&gt;=n)
+				return ip;
+		}
+	}
+};
+
+
+template&lt;class T, class C&gt;
+class gmlSingleItemServer {
+	C genfun;
+	boost::detail::atomic_count req;
+	boost::detail::atomic_count avail;
+	int pregen;
+	int arr_size;
+	T *arr;
+
+public:
+	gmlSingleItemServer(C gf, int sz, int pg):req(0),avail(0) {
+		genfun=gf;
+		pregen=pg;
+		arr_size=sz;
+		arr=new T[arr_size];
+		memset(arr,0,arr_size*sizeof(T));
+	}
+
+	virtual ~gmlSingleItemServer() {
+		delete [] arr;
+	}
+
+	inline void GenerateItems() {
+    int i;    
+		while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
+  		*(volatile T *)(arr+i)=(*genfun)();
+      ++avail;
+		}
+	}
+
+	inline T GetItems() {
+		GML_IF_SERVER_THREAD() {
+			return (*genfun)();
+		}
+		long num=++req;
+		while(avail&lt;num) // waiting
+			boost::thread::yield();
+		T *ip=arr+(num-1)%arr_size;
+		T ret=*ip;
+		*(volatile T *)ip=0;
+		return ret;
+	}
+};
+
+
+template&lt;class T, class S, class C&gt;
+class gmlMultiItemServer {
+	C genfun;
+	boost::detail::atomic_count req;
+	boost::detail::atomic_count avail;
+	int pregen;
+	int arr_size;
+	T *arr;
+
+public:
+	gmlMultiItemServer(C gf, int sz, int pg):req(0),avail(0) {
+		genfun=gf;
+		pregen=pg;
+		arr_size=sz;
+		arr=new T[arr_size];
+		memset(arr,0,arr_size*sizeof(T));
+	}
+
+	virtual ~gmlMultiItemServer() {
+		delete [] arr;
+	}
+
+	inline void GenerateItems() {
+    int i;    
+		while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
+			T val;
+  		(*genfun)(1,&amp;val);
+			*(volatile T *)(arr+i)=val;
+      ++avail;
+		}
+	}
+
+	inline void GetItems(S n, T *data) {
+		GML_IF_SERVER_THREAD() {
+			(*genfun)(n,data);
+			return;
+		}
+		for(int i=0; i&lt;n; ++i) {
+			long num=++req;
+			while(avail&lt;num) // waiting
+				boost::thread::yield();
+			T *ip=arr+(num-1)%arr_size;;
+			data[i]=*ip;
+			*(volatile T *)ip=0;
+		}
+	}
+};
+
+
+
+
+
+
+
+
+
+
+#endif
\ No newline at end of file

Added: branches/gml/rts/lib/gml/gmldef.h
===================================================================
--- branches/gml/rts/lib/gml/gmldef.h	                        (rev 0)
+++ branches/gml/rts/lib/gml/gmldef.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -0,0 +1,508 @@
+// GML - OpenGL Multithreading Library
+// for Spring <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
+// Author: Mattias &quot;zerver&quot; Radeskog
+// (C) Ware Zerver Tech. <A HREF="http://zerver.net">http://zerver.net</A>
+// Ware Zerver Tech. licenses this library
+// to be used freely for any purpose, as
+// long as this notice remains unchanged
+
+#undef glDisable
+#undef glEnable
+#undef glBindTexture
+#undef glTexParameteri
+#undef glActiveTextureARB
+#undef glColor4f
+#undef glVertex3f
+#undef glTexEnvi
+#undef glTexCoord2f
+#undef glProgramEnvParameter4fARB
+#undef glEnd
+#undef glBegin
+#undef glMatrixMode
+#undef glVertex2f
+#undef glPopMatrix
+#undef glPushMatrix
+#undef glLoadIdentity
+#undef glTranslatef
+#undef glBlendFunc
+#undef glCallList
+#undef glColor3f
+#undef glTexImage2D
+#undef glColor4fv
+#undef glBindProgramARB
+#undef glScalef
+#undef glViewport
+#undef glDeleteTextures
+#undef glMultiTexCoord2fARB
+#undef glAlphaFunc
+#undef glDepthMask
+#undef glLineWidth
+#undef glBindFramebufferEXT
+#undef glRotatef
+#undef glDeleteLists
+#undef glDisableClientState
+#undef glEnableClientState
+#undef glRectf
+#undef glLightfv
+#undef gluBuild2DMipmaps
+#undef glClear
+#undef glEndList
+#undef glNewList
+#undef glClearColor
+#undef glPolygonMode
+#undef glActiveTexture
+#undef glFogf
+#undef glMultMatrixf
+#undef glOrtho
+#undef glPopAttrib
+#undef glMaterialfv
+#undef glPolygonOffset
+#undef glPushAttrib
+#undef glCullFace
+#undef glColorMask
+#undef glVertex3fv
+#undef glTexGenfv
+#undef glVertex2d
+#undef glVertexPointer
+#undef glDrawArrays
+#undef glFogfv
+#undef glFramebufferTexture2DEXT
+#undef glTexCoordPointer
+#undef glTexSubImage2D
+#undef glClipPlane
+#undef glColor4d
+#undef glLightModeli
+#undef glTexGeni
+#undef glTexParameterf
+#undef glCopyTexSubImage2D
+#undef glDeleteFramebuffersEXT
+#undef glLoadMatrixf
+#undef glShadeModel
+#undef glUseProgram
+#undef glClientActiveTextureARB
+#undef glDeleteRenderbuffersEXT
+#undef glFlush
+#undef glNormal3f
+#undef glUseProgramObjectARB
+#undef glCompressedTexImage2DARB
+#undef glDeleteObjectARB
+#undef glFogi
+#undef glMultMatrixd
+#undef glPixelStorei
+#undef glPointParameterf
+#undef glTexCoord3f
+#undef glUniform1i
+#undef glBindRenderbufferEXT
+#undef glColor3fv
+#undef glDepthFunc
+#undef glHint
+#undef glLogicOp
+#undef glStencilOp
+#undef glTexEnvfv
+#undef glUniformMatrix4fv
+#undef gluOrtho2D
+#undef glAttachObjectARB
+#undef glBindBufferARB
+#undef glColor3ubv
+#undef glDetachObjectARB
+#undef glFramebufferRenderbufferEXT
+#undef glLineStipple
+#undef glLoadMatrixd
+#undef glSetFenceNV
+#undef glStencilFunc
+#undef glTexImage3D
+#undef glUniform1f
+#undef glClearStencil
+#undef glColorPointer
+#undef glDeleteShader
+#undef glDrawElements
+#undef glGenerateMipmapEXT
+#undef glMaterialf
+#undef glNormalPointer
+#undef glProgramEnvParameter4fvARB
+#undef glRenderbufferStorageEXT
+#undef glStencilMask
+#undef glUniform3f
+#undef gluPerspective
+#undef glActiveStencilFaceEXT
+#undef glAttachShader
+#undef glBlitFramebufferEXT
+#undef glBufferDataARB
+#undef glClearDepth
+#undef glColor3ub
+#undef glCompressedTexImage1DARB
+#undef glCompressedTexImage3DARB
+#undef glDrawBuffer
+#undef glFrontFace
+#undef glFrustum
+#undef glLinkProgramARB
+#undef glMultiTexCoord1f
+#undef glMultiTexCoord2f
+#undef glMultiTexCoord3f
+#undef glMultiTexCoord4f
+#undef glPointParameterfv
+#undef glPointSize
+#undef glProgramStringARB
+#undef glSecondaryColor3f
+#undef glTexCoord1f
+#undef glTexCoord4f
+#undef glTexEnvf
+#undef glTexGenf
+#undef glTexImage1D
+#undef glUniform1iARB
+#undef glUniform2f
+#undef glUniform2fARB
+#undef glUniform2i
+#undef glUniform3fARB
+#undef glUniform3i
+#undef glUniform4f
+#undef glUniform4i
+#undef glUniformMatrix2fv
+#undef glUniformMatrix3fv
+#undef glVertex4f
+#undef gluDeleteQuadric
+#undef gluQuadricDrawStyle
+#undef gluSphere
+#undef glClearAccum
+#undef glColor4ub
+#undef glColor4ubv
+#undef glCompileShader
+#undef glCompileShaderARB
+#undef glCopyTexImage2D
+#undef glDeleteBuffersARB
+#undef glDeleteFencesNV
+#undef glDeleteProgram
+#undef glDeleteProgramsARB
+#undef glDetachShader
+#undef glDisableVertexAttribArrayARB
+#undef glDrawBuffersARB
+#undef glEdgeFlag
+#undef glEnableVertexAttribArrayARB
+#undef glFinish
+#undef glFinishFenceNV
+#undef glFogCoordf
+#undef glLightf
+#undef glLinkProgram
+#undef glNormal3fv
+#undef glRasterPos2i
+#undef glReadBuffer
+#undef glScissor
+#undef glShaderSource
+#undef glShaderSourceARB
+#undef glTexCoord2fv
+#undef glTexParameterfv
+#undef glTranslated
+#undef glUniform1fv
+#undef glUniform4fARB
+#undef glUniformMatrix4fvARB
+#undef glVertexAttribPointerARB
+#undef gluLookAt
+#undef glLightModelfv
+
+#undef glDeleteQueries
+#undef glBlendEquation
+#undef glStencilMaskSeparate
+#undef glStencilFuncSeparate
+#undef glStencilOpSeparate
+#undef glBeginQuery
+#undef glEndQuery
+#undef glGetQueryObjectuiv
+#undef glBlendEquationSeparate
+#undef glBlendFuncSeparate
+#undef gluCylinder
+
+#undef glGetIntegerv
+#undef glCheckFramebufferStatusEXT
+#undef glGetFloatv
+#undef glGetString
+#undef glGetUniformLocationARB
+#undef glReadPixels
+#undef glGetError
+#undef glGetObjectParameterivARB
+#undef glGetUniformLocation
+#undef glGetDoublev
+#undef glGetProgramiv
+#undef glGetActiveUniform
+#undef glGetAttribLocationARB
+#undef glGetInfoLogARB
+#undef glGetProgramInfoLog
+#undef glGetProgramivARB
+#undef glGetShaderInfoLog
+#undef glGetShaderiv
+#undef glIsRenderbufferEXT
+#undef glMapBufferARB
+#undef gluProject
+#undef gluScaleImage
+#undef glIndexPointer
+#undef glEdgeFlagPointer
+#undef glTrackMatrixNV
+#undef glTestFenceNV
+
+#undef glCreateProgram
+#undef glCreateProgramObjectARB
+#undef glCreateShader
+#undef glCreateShaderObjectARB
+#undef gluNewQuadric
+
+#undef glGenTextures
+#undef glGenBuffersARB
+#undef glGenFencesNV
+#undef glGenProgramsARB
+#undef glGenRenderbuffersEXT
+#undef glGenFramebuffersEXT
+#undef glGenQueries
+
+#undef glGenLists
+
+
+
+
+
+
+#define glDisable gmlDisable
+#define glEnable gmlEnable
+#define glBindTexture gmlBindTexture
+#define glTexParameteri gmlTexParameteri
+#define glActiveTextureARB gmlActiveTextureARB
+#define glColor4f gmlColor4f
+#define glVertex3f gmlVertex3f
+#define glTexEnvi gmlTexEnvi
+#define glTexCoord2f gmlTexCoord2f
+#define glProgramEnvParameter4fARB gmlProgramEnvParameter4fARB
+#define glEnd gmlEnd
+#define glBegin gmlBegin
+#define glMatrixMode gmlMatrixMode
+#define glVertex2f gmlVertex2f
+#define glPopMatrix gmlPopMatrix
+#define glPushMatrix gmlPushMatrix
+#define glLoadIdentity gmlLoadIdentity
+#define glTranslatef gmlTranslatef
+#define glBlendFunc gmlBlendFunc
+#define glCallList gmlCallList
+#define glColor3f gmlColor3f
+#define glTexImage2D gmlTexImage2D
+#define glColor4fv gmlColor4fv
+#define glBindProgramARB gmlBindProgramARB
+#define glScalef gmlScalef
+#define glViewport gmlViewport
+#define glDeleteTextures gmlDeleteTextures
+#define glMultiTexCoord2fARB gmlMultiTexCoord2fARB
+#define glAlphaFunc gmlAlphaFunc
+#define glDepthMask gmlDepthMask
+#define glLineWidth gmlLineWidth
+#define glBindFramebufferEXT gmlBindFramebufferEXT
+#define glRotatef gmlRotatef
+#define glDeleteLists gmlDeleteLists
+#define glDisableClientState gmlDisableClientState
+#define glEnableClientState gmlEnableClientState
+#define glRectf gmlRectf
+#define glLightfv gmlLightfv
+#define gluBuild2DMipmaps gmluBuild2DMipmaps
+#define glClear gmlClear
+#define glEndList gmlEndList
+#define glNewList gmlNewList
+#define glClearColor gmlClearColor
+#define glPolygonMode gmlPolygonMode
+#define glActiveTexture gmlActiveTexture
+#define glFogf gmlFogf
+#define glMultMatrixf gmlMultMatrixf
+#define glOrtho gmlOrtho
+#define glPopAttrib gmlPopAttrib
+#define glMaterialfv gmlMaterialfv
+#define glPolygonOffset gmlPolygonOffset
+#define glPushAttrib gmlPushAttrib
+#define glCullFace gmlCullFace
+#define glColorMask gmlColorMask
+#define glVertex3fv gmlVertex3fv
+#define glTexGenfv gmlTexGenfv
+#define glVertex2d gmlVertex2d
+#define glVertexPointer gmlVertexPointer
+#define glDrawArrays gmlDrawArrays
+#define glFogfv gmlFogfv
+#define glFramebufferTexture2DEXT gmlFramebufferTexture2DEXT
+#define glTexCoordPointer gmlTexCoordPointer
+#define glTexSubImage2D gmlTexSubImage2D
+#define glClipPlane gmlClipPlane
+#define glColor4d gmlColor4d
+#define glLightModeli gmlLightModeli
+#define glTexGeni gmlTexGeni
+#define glTexParameterf gmlTexParameterf
+#define glCopyTexSubImage2D gmlCopyTexSubImage2D
+#define glDeleteFramebuffersEXT gmlDeleteFramebuffersEXT
+#define glLoadMatrixf gmlLoadMatrixf
+#define glShadeModel gmlShadeModel
+#define glUseProgram gmlUseProgram
+#define glClientActiveTextureARB gmlClientActiveTextureARB
+#define glDeleteRenderbuffersEXT gmlDeleteRenderbuffersEXT
+#define glFlush gmlFlush
+#define glNormal3f gmlNormal3f
+#define glUseProgramObjectARB gmlUseProgramObjectARB
+#define glCompressedTexImage2DARB gmlCompressedTexImage2DARB
+#define glDeleteObjectARB gmlDeleteObjectARB
+#define glFogi gmlFogi
+#define glMultMatrixd gmlMultMatrixd
+#define glPixelStorei gmlPixelStorei
+#define glPointParameterf gmlPointParameterf
+#define glTexCoord3f gmlTexCoord3f
+#define glUniform1i gmlUniform1i
+#define glBindRenderbufferEXT gmlBindRenderbufferEXT
+#define glColor3fv gmlColor3fv
+#define glDepthFunc gmlDepthFunc
+#define glHint gmlHint
+#define glLogicOp gmlLogicOp
+#define glStencilOp gmlStencilOp
+#define glTexEnvfv gmlTexEnvfv
+#define glUniformMatrix4fv gmlUniformMatrix4fv
+#define gluOrtho2D gmluOrtho2D
+#define glAttachObjectARB gmlAttachObjectARB
+#define glBindBufferARB gmlBindBufferARB
+#define glColor3ubv gmlColor3ubv
+#define glDetachObjectARB gmlDetachObjectARB
+#define glFramebufferRenderbufferEXT gmlFramebufferRenderbufferEXT
+#define glLineStipple gmlLineStipple
+#define glLoadMatrixd gmlLoadMatrixd
+#define glSetFenceNV gmlSetFenceNV
+#define glStencilFunc gmlStencilFunc
+#define glTexImage3D gmlTexImage3D
+#define glUniform1f gmlUniform1f
+#define glClearStencil gmlClearStencil
+#define glColorPointer gmlColorPointer
+#define glDeleteShader gmlDeleteShader
+#define glDrawElements gmlDrawElements
+#define glGenerateMipmapEXT gmlGenerateMipmapEXT
+#define glMaterialf gmlMaterialf
+#define glNormalPointer gmlNormalPointer
+#define glProgramEnvParameter4fvARB gmlProgramEnvParameter4fvARB
+#define glRenderbufferStorageEXT gmlRenderbufferStorageEXT
+#define glStencilMask gmlStencilMask
+#define glUniform3f gmlUniform3f
+#define gluPerspective gmluPerspective
+#define glActiveStencilFaceEXT gmlActiveStencilFaceEXT
+#define glAttachShader gmlAttachShader
+#define glBlitFramebufferEXT gmlBlitFramebufferEXT
+#define glBufferDataARB gmlBufferDataARB
+#define glClearDepth gmlClearDepth
+#define glColor3ub gmlColor3ub
+#define glCompressedTexImage1DARB gmlCompressedTexImage1DARB
+#define glCompressedTexImage3DARB gmlCompressedTexImage3DARB
+#define glDrawBuffer gmlDrawBuffer
+#define glFrontFace gmlFrontFace
+#define glFrustum gmlFrustum
+#define glLinkProgramARB gmlLinkProgramARB
+#define glMultiTexCoord1f gmlMultiTexCoord1f
+#define glMultiTexCoord2f gmlMultiTexCoord2f
+#define glMultiTexCoord3f gmlMultiTexCoord3f
+#define glMultiTexCoord4f gmlMultiTexCoord4f
+#define glPointParameterfv gmlPointParameterfv
+#define glPointSize gmlPointSize
+#define glProgramStringARB gmlProgramStringARB
+#define glSecondaryColor3f gmlSecondaryColor3f
+#define glTexCoord1f gmlTexCoord1f
+#define glTexCoord4f gmlTexCoord4f
+#define glTexEnvf gmlTexEnvf
+#define glTexGenf gmlTexGenf
+#define glTexImage1D gmlTexImage1D
+#define glUniform1iARB gmlUniform1iARB
+#define glUniform2f gmlUniform2f
+#define glUniform2fARB gmlUniform2fARB
+#define glUniform2i gmlUniform2i
+#define glUniform3fARB gmlUniform3fARB
+#define glUniform3i gmlUniform3i
+#define glUniform4f gmlUniform4f
+#define glUniform4i gmlUniform4i
+#define glUniformMatrix2fv gmlUniformMatrix2fv
+#define glUniformMatrix3fv gmlUniformMatrix3fv
+#define glVertex4f gmlVertex4f
+#define gluDeleteQuadric gmluDeleteQuadric
+#define gluQuadricDrawStyle gmluQuadricDrawStyle
+#define gluSphere gmluSphere
+#define glClearAccum gmlClearAccum
+#define glColor4ub gmlColor4ub
+#define glColor4ubv gmlColor4ubv
+#define glCompileShader gmlCompileShader
+#define glCompileShaderARB gmlCompileShaderARB
+#define glCopyTexImage2D gmlCopyTexImage2D
+#define glDeleteBuffersARB gmlDeleteBuffersARB
+#define glDeleteFencesNV gmlDeleteFencesNV
+#define glDeleteProgram gmlDeleteProgram
+#define glDeleteProgramsARB gmlDeleteProgramsARB
+#define glDetachShader gmlDetachShader
+#define glDisableVertexAttribArrayARB gmlDisableVertexAttribArrayARB
+#define glDrawBuffersARB gmlDrawBuffersARB
+#define glEdgeFlag gmlEdgeFlag
+#define glEnableVertexAttribArrayARB gmlEnableVertexAttribArrayARB
+#define glFinish gmlFinish
+#define glFinishFenceNV gmlFinishFenceNV
+#define glFogCoordf gmlFogCoordf
+#define glLightf gmlLightf
+#define glLinkProgram gmlLinkProgram
+#define glNormal3fv gmlNormal3fv
+#define glRasterPos2i gmlRasterPos2i
+#define glReadBuffer gmlReadBuffer
+#define glScissor gmlScissor
+#define glShaderSource
+#define glShaderSourceARB
+#define glTexCoord2fv gmlTexCoord2fv
+#define glTexParameterfv gmlTexParameterfv
+#define glTranslated gmlTranslated
+#define glUniform1fv gmlUniform1fv
+#define glUniform4fARB gmlUniform4fARB
+#define glUniformMatrix4fvARB gmlUniformMatrix4fvARB
+#define glVertexAttribPointerARB gmlVertexAttribPointerARB
+#define gluLookAt gmluLookAt
+#define glLightModelfv gmlLightModelfv
+
+#define glDeleteQueries gmlDeleteQueries
+#define glBlendEquation gmlBlendEquation
+#define glStencilMaskSeparate gmlStencilMaskSeparate
+#define glStencilFuncSeparate gmlStencilFuncSeparate
+#define glStencilOpSeparate gmlStencilOpSeparate
+#define glBeginQuery gmlBeginQuery
+#define glEndQuery gmlEndQuery
+#define glGetQueryObjectuiv gmlGetQueryObjectuiv
+#define glBlendEquationSeparate gmlBlendEquationSeparate
+#define glBlendFuncSeparate gmlBlendFuncSeparate
+#define gluCylinder gmluCylinder
+
+#define glGetIntegerv gmlGetIntegerv
+#define glCheckFramebufferStatusEXT gmlCheckFramebufferStatusEXT
+#define glGetFloatv gmlGetFloatv
+#define glGetString gmlGetString
+#define glGetUniformLocationARB gmlGetUniformLocationARB
+#define glReadPixels gmlReadPixels
+#define glGetError gmlGetError
+#define glGetObjectParameterivARB gmlGetObjectParameterivARB
+#define glGetUniformLocation gmlGetUniformLocation
+#define glGetDoublev gmlGetDoublev
+#define glGetProgramiv gmlGetProgramiv
+#define glGetActiveUniform gmlGetActiveUniform
+#define glGetAttribLocationARB gmlGetAttribLocationARB
+#define glGetInfoLogARB gmlGetInfoLogARB
+#define glGetProgramInfoLog gmlGetProgramInfoLog
+#define glGetProgramivARB gmlGetProgramivARB
+#define glGetShaderInfoLog gmlGetShaderInfoLog
+#define glGetShaderiv gmlGetShaderiv
+#define glIsRenderbufferEXT gmlIsRenderbufferEXT
+#define glMapBufferARB gmlMapBufferARB
+#define gluProject gmluProject
+#define gluScaleImage gmluScaleImage
+#define glIndexPointer gmlIndexPointer
+#define glEdgeFlagPointer gmlEdgeFlagPointer
+#define glTrackMatrixNV gmlTrackMatrixNV
+#define glTestFenceNV gmlTestFenceNV
+
+#define glCreateProgram gmlCreateProgram
+#define glCreateProgramObjectARB gmlCreateProgramObjectARB
+#define glCreateShader gmlCreateShader
+#define glCreateShaderObjectARB gmlCreateShaderObjectARB
+#define gluNewQuadric gmluNewQuadric
+
+#define glGenTextures gmlGenTextures
+#define glGenBuffersARB gmlGenBuffersARB
+#define glGenFencesNV gmlGenFencesNV
+#define glGenProgramsARB gmlGenProgramsARB
+#define glGenRenderbuffersEXT gmlGenRenderbuffersEXT
+#define glGenFramebuffersEXT gmlGenFramebuffersEXT
+#define glGenQueries gmlGenQueries
+
+#define glGenLists gmlGenLists
\ No newline at end of file

Added: branches/gml/rts/lib/gml/gmlfun.h
===================================================================
--- branches/gml/rts/lib/gml/gmlfun.h	                        (rev 0)
+++ branches/gml/rts/lib/gml/gmlfun.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -0,0 +1,1138 @@
+// GML - OpenGL Multithreading Library
+// for Spring <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
+// Author: Mattias &quot;zerver&quot; Radeskog
+// (C) Ware Zerver Tech. <A HREF="http://zerver.net">http://zerver.net</A>
+// Ware Zerver Tech. licenses this library
+// to be used freely for any purpose, as
+// long as this notice remains unchanged
+
+#ifndef GMLFUN_H
+#define GMLFUN_H
+
+#include &lt;set&gt;
+#include &lt;map&gt;
+
+
+#define GML_NERROR_FUN(str,val)\
+f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
+if(f) {\
+	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+	fclose(f);\
+}
+
+#define GML_ERROR_FUN(str,val)\
+FILE *f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
+if(f) {\
+	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+	fclose(f);\
+}
+
+#define GML_DEBUG_FUN(str,val)\
+FILE *f=fopen(&quot;C:\\GMLDBG.TXT&quot;,&quot;a&quot;);\
+if(f) {\
+	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+	fclose(f);\
+}
+
+extern std::map&lt;GLenum,GLint&gt; gmlGetIntegervCache;
+extern std::map&lt;GLenum,GLfloat&gt; gmlGetFloatvCache;
+extern std::map&lt;GLenum,std::string&gt; gmlGetStringCache;
+#define GML_CACHE(d,v,c,K,R) if(GML_USE_CACHE) {std::map&lt;d,v&gt;::iterator it=c.find(K); if(it!=c.end()) {*R=(*it).second; return;}}
+#define GML_CACHE_RET_STR(d,v,c,K) if(GML_USE_CACHE) {std::map&lt;d,v&gt;::iterator it=c.find(K); if(it!=c.end()) {return (GLubyte *)(*it).second.c_str();}}
+#define GML_DEFAULT(c,r) if(GML_USE_DEFAULT &amp;&amp; (c)) {r; return;}
+#define GML_DEFAULT_RET(c,r) if(GML_USE_DEFAULT &amp;&amp; (c)) {return r;}
+#define GML_DEFAULT_ERROR() if(GML_USE_NO_ERROR) return GL_NO_ERROR;
+
+EXTERN inline int gmlNumArgsTexImage(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+		//teximage, build2dmip
+		case GL_COLOR_INDEX:
+		case GL_RED:
+		case GL_GREEN:
+		case GL_BLUE:
+		case GL_ALPHA:
+		case GL_LUMINANCE:
+		case GL_DEPTH_COMPONENT:
+			return 1;
+		case GL_LUMINANCE_ALPHA:
+			return 2;
+		case GL_RGB:
+		case GL_BGR_EXT:
+			return 3;
+		case GL_RGBA:
+		case GL_BGRA_EXT:
+			return 4;
+		default:
+//      GML_NERROR_FUN(&quot;gmlNumArgsTexImage&quot;, datatype)
+			return 0;
+	}
+}
+
+EXTERN inline int gmlNumArgsLightMat(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+// glLight, glMaterial
+		case GL_AMBIENT:
+		case GL_DIFFUSE:
+		case GL_SPECULAR:
+		case GL_EMISSION: // material
+		case GL_AMBIENT_AND_DIFFUSE: //mat
+		case GL_POSITION:
+			return 4;
+		case GL_SPOT_DIRECTION:
+		case GL_COLOR_INDEXES: //mat
+			return 3;
+		case GL_SHININESS: // mat
+		case GL_SPOT_EXPONENT:
+		case GL_SPOT_CUTOFF:
+		case GL_CONSTANT_ATTENUATION:
+		case GL_LINEAR_ATTENUATION:
+		case GL_QUADRATIC_ATTENUATION:
+			return 1;
+		default:
+//      GML_NERROR_FUN(&quot;gmlNumArgsLightMat&quot;, datatype)
+			return 0;
+	}
+}
+
+EXTERN inline int gmlNumArgsFog(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+//glFog
+		case GL_FOG_MODE:
+		case GL_FOG_DENSITY:
+		case GL_FOG_START:
+		case GL_FOG_END:
+		case GL_FOG_INDEX:
+			return 1;
+		case GL_FOG_COLOR:
+			return 4;
+		default:
+//      GML_NERROR_FUN(&quot;gmlNumArgsFog&quot;, datatype)
+			return 0;
+	}
+}
+
+EXTERN inline int gmlNumArgsTexGen(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+//glTexGen
+		case GL_TEXTURE_GEN_MODE:
+			return 1;
+		case GL_OBJECT_PLANE:
+		case GL_EYE_PLANE:
+			return 4;
+		default:
+//      GML_NERROR_FUN(&quot;gmlNumArgsTexGen&quot;, datatype)
+			return 0;
+	}
+}
+
+EXTERN inline int gmlNumArgsTexEnv(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+//glTexEnv
+		case GL_TEXTURE_ENV_MODE:
+			return 1;
+		case GL_TEXTURE_ENV_COLOR:
+			return 4;
+		default:
+//      GML_NERROR_FUN(&quot;gmlNumArgsTexEnv&quot;, datatype)
+			return 0;
+	}
+}
+
+EXTERN inline int gmlNumArgsPointParam(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+//glPointParametefv
+		case GL_POINT_SIZE_MIN:
+		case GL_POINT_SIZE_MAX:
+		case GL_POINT_FADE_THRESHOLD_SIZE:
+		case GL_POINT_SPRITE_COORD_ORIGIN:
+			return 1;
+		case GL_POINT_DISTANCE_ATTENUATION:
+			return 3;
+		default:
+//      GML_NERROR_FUN(&quot;gmlNumArgsPointParam&quot;, datatype)
+			return 0;
+	}
+}
+
+EXTERN inline int gmlNumArgsTexParam(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+//glTexParameterfv
+		case GL_TEXTURE_MIN_FILTER:
+		case GL_TEXTURE_MAG_FILTER:
+		case GL_TEXTURE_WRAP_S:
+		case GL_TEXTURE_WRAP_T:
+		case GL_TEXTURE_PRIORITY:
+			return 1;
+		case GL_TEXTURE_BORDER_COLOR:
+			return 4;
+		default:
+//      GML_NERROR_FUN(&quot;gmlNumArgsTexParam&quot;, datatype)
+			return 0;
+	}
+}
+
+EXTERN inline int gmlNumArgsLightModel(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+//glLightModelfv
+		case GL_LIGHT_MODEL_LOCAL_VIEWER:
+		case GL_LIGHT_MODEL_TWO_SIDE:
+			return 1;
+		case GL_LIGHT_MODEL_AMBIENT:
+			return 4;
+		default:
+//      GML_NERROR_FUN(&quot;gmlNumArgsLightModel&quot;, datatype)
+			return 0;
+	}
+}
+
+EXTERN inline int gmlSizeOf(int datatype) {
+//	FILE *f;
+	switch(datatype) {
+		case GL_UNSIGNED_BYTE:
+			return sizeof(GLubyte);
+		case GL_BYTE:
+			return sizeof(GLbyte);
+		case GL_BITMAP:
+			return sizeof(GLubyte);
+		case GL_UNSIGNED_SHORT:
+			return sizeof(GLushort);
+		case GL_SHORT:
+			return sizeof(GLshort);
+		case GL_UNSIGNED_INT:
+			return sizeof(GLuint);
+		case GL_INT:
+			return sizeof(GLint);
+		case GL_FLOAT:
+			return sizeof(GLfloat);
+		case GL_DOUBLE:
+			return sizeof(GLdouble);
+		default:
+//      GML_NERROR_FUN(&quot;gmlSizeOf&quot;, datatype)
+			return 0;
+	}
+}
+
+
+#define GML_MAKEVAR() int type;
+#define GML_MAKEVAR_A(ftype1) GML_MAKEVAR() ftype1 A;
+#define GML_MAKEVAR_B(ftype1,ftype2) GML_MAKEVAR_A(ftype1) ftype2 B;
+#define GML_MAKEVAR_C(ftype1,ftype2,ftype3) GML_MAKEVAR_B(ftype1,ftype2) ftype3 C;
+#define GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4) GML_MAKEVAR_C(ftype1,ftype2,ftype3) ftype4 D;
+#define GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5) GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4) ftype5 E;
+#define GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6) GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5) ftype6 F;
+#define GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7) GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6) ftype7 G;
+#define GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8) GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7) ftype8 H;
+#define GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9) GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8) ftype9 I;
+#define GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10) GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9) ftype10 J;
+#define GML_MAKEVAR_SIZE() int size;
+#define GML_MAKEVAR_RET(ft) volatile ft ret;
+
+#define GML_MAKEASS_A() p-&gt;A=A;
+#define GML_MAKEASS_B() GML_MAKEASS_A() p-&gt;B=B;
+#define GML_MAKEASS_C() GML_MAKEASS_B() p-&gt;C=C;
+#define GML_MAKEASS_D() GML_MAKEASS_C() p-&gt;D=D;
+#define GML_MAKEASS_E() GML_MAKEASS_D() p-&gt;E=E;
+#define GML_MAKEASS_F() GML_MAKEASS_E() p-&gt;F=F;
+#define GML_MAKEASS_G() GML_MAKEASS_F() p-&gt;G=G;
+#define GML_MAKEASS_H() GML_MAKEASS_G() p-&gt;H=H;
+#define GML_MAKEASS_I() GML_MAKEASS_H() p-&gt;I=I;
+#define GML_MAKEASS_J() GML_MAKEASS_I() p-&gt;J=J;
+
+#define GML_RETVAL(ft) return (ft)*(volatile ft *)&amp;(p-&gt;ret);
+
+#define GML_RELOC()\
+     while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+       qd-&gt;WaitRealloc();
+
+#define GML_PREP_FIXED(name)\
+     gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];\
+     int datasize=sizeof(gml##name##Data);\
+     GML_RELOC()\
+     gml##name##Data *p=(gml##name##Data *)qd-&gt;WritePos;\
+	 p-&gt;type=gml##name##Enum;
+
+#define GML_UPD_POS()\
+     qd-&gt;WritePos+=datasize;
+
+#define GML_UPD_SIZE()\
+  	 p-&gt;size=datasize;\
+
+#define GML_PREP_VAR(name,sizefun)\
+     gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];\
+	 int size=sizefun;\
+     int datasize=sizeof(gml##name##Data)+size;\
+     GML_RELOC()\
+     gml##name##Data *p=(gml##name##Data *)qd-&gt;WritePos;\
+     p-&gt;type=gml##name##Enum;
+
+#define GML_PREP_VAR_SIZE(name,sizefun)\
+ 	 GML_PREP_VAR(name,sizefun)\
+	 GML_UPD_SIZE()
+
+#define GML_COND(stmt)\
+  GML_IF_SERVER_THREAD() {\
+    stmt;\
+	return;\
+  }
+
+#define GML_COND_RET(stmt)\
+  GML_IF_SERVER_THREAD() {\
+    return stmt;\
+  }
+
+EXTERN inline void gmlSync(gmlQueue *qd) {
+	qd-&gt;SyncRequest();
+}
+
+#define GML_SYNC_COND(arg,x) arg;
+
+#define GML_SYNC() gmlSync(qd)
+
+#define GML_MAKEFUN0(name) struct gml##name##Data {\
+  GML_MAKEVAR()\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name() {\
+  GML_COND(gl##name())\
+  GML_PREP_FIXED(name)\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN0R(name,ftypeR,cache) struct gml##name##Data {\
+  GML_MAKEVAR()\
+  GML_MAKEVAR_RET(ftypeR)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline ftypeR gml##name() {\
+  GML_COND_RET(gl##name())\
+	cache\
+  GML_PREP_FIXED(name)\
+  GML_UPD_POS()\
+  GML_SYNC();\
+  GML_RETVAL(ftypeR)\
+}
+
+#define GML_MAKEFUN1(name,ftype1) struct gml##name##Data {\
+  GML_MAKEVAR_A(ftype1)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A) {\
+  GML_COND(gl##name(A))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_A()\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN1R(name,ftype1,ftypeR,cache) struct gml##name##Data {\
+  GML_MAKEVAR_A(ftype1)\
+  GML_MAKEVAR_RET(ftypeR)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline ftypeR gml##name(ftype1 A) {\
+  GML_COND_RET(gl##name(A))\
+	cache\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_A()\
+  GML_UPD_POS()\
+  GML_SYNC();\
+  GML_RETVAL(ftypeR)\
+}
+
+#define GML_MAKEFUN2(name,ftype1,ftype2,cache,...) struct gml##name##Data {\
+  GML_MAKEVAR_B(ftype1,ftype2)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B) {\
+  GML_COND(gl##name(A,B))\
+	cache\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_B()\
+  GML_UPD_POS()\
+  GML_SYNC_COND(__VA_ARGS__,)\
+}
+
+#define GML_MAKEFUN2R(name,ftype1,ftype2,ftypeR) struct gml##name##Data {\
+  GML_MAKEVAR_B(ftype1,ftype2)\
+  GML_MAKEVAR_RET(ftypeR)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline ftypeR gml##name(ftype1 A,ftype2 B) {\
+  GML_COND_RET(gl##name(A,B))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_B()\
+  GML_UPD_POS()\
+  GML_SYNC();\
+  GML_RETVAL(ftypeR)\
+}
+
+#define GML_MAKEFUN3(name,ftype1,ftype2,ftype3,cache,...) struct gml##name##Data {\
+  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C) {\
+  GML_COND(gl##name(A,B,C))\
+	cache\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_C()\
+  GML_UPD_POS()\
+  GML_SYNC_COND(__VA_ARGS__,)\
+}
+
+#define GML_MAKEFUN4(name,ftype1,ftype2,ftype3,ftype4,...) struct gml##name##Data {\
+  GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D) {\
+  GML_COND(gl##name(A,B,C,D))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_D()\
+  GML_UPD_POS()\
+  GML_SYNC_COND(__VA_ARGS__,)\
+}
+
+#define GML_MAKEFUN5(name,ftype1,ftype2,ftype3,ftype4,ftype5) struct gml##name##Data {\
+  GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E) {\
+  GML_COND(gl##name(A,B,C,D,E))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_E()\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN6(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6) struct gml##name##Data {\
+  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F) {\
+  GML_COND(gl##name(A,B,C,D,E,F))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_F()\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN7(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,...) struct gml##name##Data {\
+  GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_G()\
+  GML_UPD_POS()\
+  GML_SYNC_COND(__VA_ARGS__,)\
+}
+
+#define GML_MAKEFUN8(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8) struct gml##name##Data {\
+  GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G,H))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_H()\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN9(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9) struct gml##name##Data {\
+  GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_I()\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN9R(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftypeR) struct gml##name##Data {\
+  GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
+  GML_MAKEVAR_RET(ftypeR)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline ftypeR gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
+  GML_COND_RET(gl##name(A,B,C,D,E,F,G,H,I))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_I()\
+  GML_UPD_POS()\
+  GML_SYNC();\
+  GML_RETVAL(ftypeR)\
+}
+
+
+#define GML_MAKEFUN10(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10) struct gml##name##Data {\
+  GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 J) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_J()\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN7S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,sizefun) struct gml##name##Data {\
+  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+  GML_MAKEVAR_SIZE()\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G))\
+  GML_PREP_VAR_SIZE(name,sizefun)\
+  GML_MAKEASS_F()\
+  memcpy(p+1,G,size);\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN8S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,sizefun) struct gml##name##Data {\
+  GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
+  GML_MAKEVAR_SIZE()\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G,H))\
+  GML_PREP_VAR_SIZE(name,sizefun)\
+  GML_MAKEASS_G()\
+  memcpy(p+1,H,size);\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN9S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,sizefun,nullok) struct gml##name##Data {\
+  GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
+  GML_MAKEVAR_SIZE()\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
+  GML_PREP_VAR_SIZE(name,sizefun)\
+  GML_MAKEASS_H()\
+	if(!nullok || I!=NULL)\
+    memcpy(p+1,I,size);\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN10S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10,sizefun) struct gml##name##Data {\
+  GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
+  GML_MAKEVAR_SIZE()\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 J) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
+  GML_PREP_VAR_SIZE(name,sizefun)\
+  GML_MAKEASS_I()\
+  memcpy(p+1,J,size);\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN1V(name,ftype1,count,cnst) struct gml##name##Data {\
+  GML_MAKEVAR()\
+  GML_MAKEVAR_SIZE()\
+  ftype1 A;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(cnst ftype1* A) {\
+  GML_COND(gl##name(A))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype1))\
+  memcpy(&amp;(p-&gt;A),A,size+sizeof(ftype1));\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN2V(name,ftype1,ftype2,count,cnst) struct gml##name##Data {\
+  GML_MAKEVAR_A(ftype1)\
+  GML_MAKEVAR_SIZE()\
+  ftype2 B;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, cnst ftype2* B) {\
+  GML_COND(gl##name(A,B))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype2))\
+  GML_MAKEASS_A()\
+  memcpy(&amp;(p-&gt;B),B,size+sizeof(ftype2));\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN3V(name,ftype1,ftype2,ftype3,count,cnst) struct gml##name##Data {\
+  GML_MAKEVAR_B(ftype1,ftype2)\
+  GML_MAKEVAR_SIZE()\
+  ftype3 C;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, cnst ftype3* C) {\
+  GML_COND(gl##name(A,B,C))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype3))\
+  GML_MAKEASS_B()\
+  memcpy(&amp;(p-&gt;C),C,size+sizeof(ftype3));\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN4V(name,ftype1,ftype2,ftype3,ftype4,count,cnst) struct gml##name##Data {\
+  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+  GML_MAKEVAR_SIZE()\
+  ftype4 D;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, cnst ftype4 *D) {\
+  GML_COND(gl##name(A,B,C,D))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype4))\
+  GML_MAKEASS_C()\
+  memcpy(&amp;(p-&gt;D),D,size+sizeof(ftype4));\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN4VS(name,ftype1,ftype2,ftype3,ftype4,count) struct gml##name##Data {\
+  GML_MAKEVAR_B(ftype1,ftype2)\
+  ftype4 D;\
+  GML_MAKEVAR_SIZE()\
+  ftype3 C;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 *C, ftype4 D) {\
+  GML_COND(gl##name(A,B,C,D))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype3))\
+  GML_MAKEASS_B()\
+  p-&gt;D=D;\
+  memcpy(&amp;(p-&gt;C),C,size+sizeof(ftype3));\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN4VSS(name,ftype1,ftype2,ftype3,ftype4,count) struct gml##name##Data {\
+  GML_MAKEVAR_B(ftype1,ftype2)\
+  int lensize;\
+  GML_MAKEVAR_SIZE()\
+  ftype3 C;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 *C, ftype4 *D) {\
+  GML_COND(gl##name(A,B,C,D))\
+  GML_PREP_VAR(name,(count-1)*sizeof(ftype3))\
+  GML_MAKEASS_B()\
+  /*p-&gt;C=D;*/\
+/*  memcpy(&amp;(p-&gt;D),D,size+sizeof(ftype4));*/\
+  p-&gt;lensize=datasize;\
+  BYTE *e=(BYTE *)p+datasize;\
+  for(int i=0; i&lt;B; ++i) {\
+	  BOOL len=!D || D[i]&lt;0;\
+	  GLint sl=(len?strlen(C[i]):D[i])+1;\
+	  datasize+=sl;\
+	  ((GLint *)&amp;(p-&gt;C))[i]=sl;\
+      --sl;\
+      while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+        p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+      memcpy(e,C[i],sl);\
+	  e+=sl;\
+	  *e='\0';\
+      ++e;\
+  }\
+  GML_UPD_SIZE()\
+  GML_UPD_POS()\
+}
+
+
+#define GML_MAKEFUN7V(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,count,cnst) struct gml##name##Data {\
+  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+  GML_MAKEVAR_SIZE()\
+  ftype7 G;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, cnst ftype7 *G) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype7))\
+  GML_MAKEASS_F()\
+  memcpy(&amp;(p-&gt;G),G,size+sizeof(ftype7));\
+  GML_UPD_POS()\
+}
+
+
+#define GML_MAKEFUN8V(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,count,cnst) struct gml##name##Data {\
+  GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
+  GML_MAKEVAR_SIZE()\
+  ftype8 H;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, cnst /*ftype8*/void* H) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G,H))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype8))\
+  GML_MAKEASS_G()\
+  memcpy(&amp;(p-&gt;H),H,size+sizeof(ftype8));\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN9V(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,count,cnst) struct gml##name##Data {\
+  GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
+  GML_MAKEVAR_SIZE()\
+  ftype9 I;\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, cnst ftype9 *I) {\
+  GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype9))\
+  GML_MAKEASS_H()\
+  memcpy(&amp;(p-&gt;I),I,size+sizeof(ftype9));\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN1CS(name,ftype1,arg) struct gml##name##Data {\
+  GML_MAKEVAR_A(ftype1)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A) {\
+  GML_COND(gl##name(A))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_A()\
+  qd-&gt;ClientState arg (1&lt;&lt;(A-GL_VERTEX_ARRAY));\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN1VA(name,ftype1,arg,fun) struct gml##name##Data {\
+  GML_MAKEVAR_A(ftype1)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A) {\
+  GML_COND(gl##name(A))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_A()\
+  qd-&gt;arg##set.fun(A);\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN2P(name,ftype1,ftype2,arg) struct gml##name##Data {\
+  GML_MAKEVAR_B(ftype1,ftype2)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B) {\
+  GML_COND(gl##name(A,B))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_B()\
+  qd-&gt;arg##stride=A;\
+  qd-&gt;arg##pointer=B;\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN3P(name,ftype1,ftype2,ftype3,arg) struct gml##name##Data {\
+  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C) {\
+  GML_COND(gl##name(A,B,C))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_C()\
+  qd-&gt;arg##type=A;\
+  qd-&gt;arg##stride=B;\
+  qd-&gt;arg##pointer=C;\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN4P(name,ftype1,ftype2,ftype3,ftype4,arg) struct gml##name##Data {\
+  GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D) {\
+  GML_COND(gl##name(A,B,C,D))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_D()\
+  qd-&gt;arg##size=A;\
+  qd-&gt;arg##type=B;\
+  qd-&gt;arg##stride=C;\
+  qd-&gt;arg##pointer=D;\
+  GML_UPD_POS()\
+}
+
+#define GML_MAKEFUN6P(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,arg) struct gml##name##Data {\
+  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F) {\
+  GML_COND(gl##name(A,B,C,D,E,F))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_F()\
+  qd-&gt;arg##map[A]=arg##data(B,C,D,E,F);\
+  GML_UPD_POS()\
+}
+
+#define GML_MEMCOPY()\
+	for(int i=0; i&lt;C; ++i) {\
+  	  BYTE *e2=e;\
+  	  BYTE *v2=v;\
+	  for(int j=0; j&lt;itemsize; ++j) {\
+	    *e2=*v2;\
+		++e2;\
+		++v2;\
+	  }\
+/*    	   memcpy(e,v,itemsize);*/\
+	  e+=itemsize;\
+	  v+=itemstride;\
+    }\
+
+
+#define GML_MAKESUBFUNDA(name,pre,arg,sizefun,sizeass,typeass)\
+  if(qd-&gt;ClientState &amp; (1&lt;&lt;(pre-GL_VERTEX_ARRAY))) {\
+    sizeass;\
+    typeass;\
+	int itemsize=sizefun;\
+	p-&gt;arg##totalsize=itemsize*C;\
+    datasize+=p-&gt;arg##totalsize;\
+    while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+      p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+	int itemstride=qd-&gt;arg##stride;\
+	if(itemstride==0)\
+    itemstride=itemsize;\
+    BYTE *v=(BYTE *)qd-&gt;arg##pointer+B*itemstride;\
+	GML_MEMCOPY()\
+  }
+
+#define GML_MAKEPOINTERDATA()\
+  GLenum ClientState;\
+  GLint VPsize;\
+  GLenum VPtype;\
+  int VPtotalsize;\
+  GLint CPsize;\
+  GLenum CPtype;\
+  int CPtotalsize;\
+  GLint TCPsize;\
+  GLenum TCPtype;\
+  int TCPtotalsize;\
+  GLenum IPtype;\
+  int IPtotalsize;\
+  GLenum NPtype;\
+  int NPtotalsize;\
+  int EFPtotalsize;\
+  int VAcount;
+
+#define GML_MAKESUBFUNVA(name)\
+  p-&gt;VAcount=qd-&gt;VAset.size();\
+  std::set&lt;GLuint&gt;::iterator si=qd-&gt;VAset.begin();\
+  while(si!=qd-&gt;VAset.end()) {\
+    std::map&lt;GLuint,VAdata&gt;::iterator mi=qd-&gt;VAmap.find(*si);\
+/*	if(mi!=qd-&gt;VAmap.end()) {*/\
+\
+    VAdata *vd=&amp;(mi-&gt;second);\
+	int itemsize=vd-&gt;size*gmlSizeOf(vd-&gt;type);\
+	int totalsize=itemsize*C+sizeof(VAstruct);\
+  datasize+=totalsize;\
+	while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+    p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+\
+  VAstruct *vs=(VAstruct *)e;\
+  e+=sizeof(VAstruct);\
+  vs-&gt;target=*si;\
+  vs-&gt;size=vd-&gt;size;\
+  vs-&gt;type=vd-&gt;type;\
+  vs-&gt;normalized=vd-&gt;normalized;\
+  vs-&gt;totalsize=totalsize;\
+	int itemstride=vd-&gt;stride;\
+	if(itemstride==0)\
+    itemstride=itemsize;\
+\
+  BYTE *v=(BYTE *)vd-&gt;pointer+B*itemstride;\
+	GML_MEMCOPY()\
+  \
+/*	}*/\
+    ++si;\
+  }
+
+
+#define GML_MAKEFUN3VDA(name,ftype1,ftype2,ftype3) struct gml##name##Data {\
+  GML_MAKEVAR_A(ftype1)\
+/*  ftype2 B;*/\
+  ftype3 C;\
+  GML_MAKEPOINTERDATA()\
+  GML_MAKEVAR_SIZE()\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C) {\
+  GML_COND(gl##name(A,B,C))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_A()\
+/*p-&gt;B=B;*/\
+  p-&gt;C=C;\
+  p-&gt;ClientState=qd-&gt;ClientState;\
+  BYTE *e=(BYTE *)(p+1);\
+  GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype)\
+  GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype)\
+  GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype)\
+  GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype)\
+  GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype)\
+  GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,)\
+  GML_MAKESUBFUNVA(name)\
+  GML_UPD_SIZE()\
+  GML_UPD_POS()\
+}
+
+
+#define GML_MAKEFUN4VDE(name,ftype1,ftype2,ftype3,ftype4) struct gml##name##Data {\
+  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+/*  ftype4 D;*/\
+  GML_MAKEPOINTERDATA()\
+  int IDXtotalsize;\
+  GML_MAKEVAR_SIZE()\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D) {\
+  GML_COND(gl##name(A,B,C,D))\
+  GML_PREP_VAR(name,B*gmlSizeOf(C))\
+  p-&gt;IDXtotalsize=size;\
+  GML_MAKEASS_C()\
+/*p-&gt;D=D;*/\
+  p-&gt;ClientState=qd-&gt;ClientState;\
+  BYTE *e=(BYTE *)(p+1);\
+  memcpy(e,D,size);\
+  e+=size;\
+  GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype)\
+  GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype)\
+  GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype)\
+  GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype)\
+  GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype)\
+  GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,)\
+  GML_MAKESUBFUNVA(name)\
+  GML_UPD_SIZE()\
+  GML_UPD_POS()\
+}
+
+
+
+const int __FIRSTLINE__=__LINE__;
+GML_MAKEFUN1(Disable,GLenum)
+GML_MAKEFUN1(Enable,GLenum)
+GML_MAKEFUN2(BindTexture,GLenum,GLuint,)
+GML_MAKEFUN3(TexParameteri,GLenum,GLenum,GLint,)
+GML_MAKEFUN1(ActiveTextureARB,GLenum)
+GML_MAKEFUN4(Color4f,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN3(Vertex3f,GLfloat,GLfloat,GLfloat,)
+GML_MAKEFUN3(TexEnvi,GLenum,GLenum,GLint,)
+GML_MAKEFUN2(TexCoord2f,GLfloat,GLfloat,)
+GML_MAKEFUN6(ProgramEnvParameter4fARB,GLenum,GLuint,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN0(End)
+GML_MAKEFUN1(Begin,GLenum)
+GML_MAKEFUN1(MatrixMode,GLenum)
+GML_MAKEFUN2(Vertex2f,GLfloat,GLfloat,)
+GML_MAKEFUN0(PopMatrix)
+GML_MAKEFUN0(PushMatrix)
+GML_MAKEFUN0(LoadIdentity)
+GML_MAKEFUN3(Translatef,GLfloat,GLfloat,GLfloat,)
+GML_MAKEFUN2(BlendFunc,GLenum,GLenum,)
+GML_MAKEFUN1(CallList,GLuint)
+GML_MAKEFUN3(Color3f,GLfloat,GLfloat,GLfloat,)
+GML_MAKEFUN9S(TexImage2D,GLenum,GLint,GLint,GLsizei,GLsizei,GLint,GLenum,GLenum,const GLvoid *,D*E*gmlNumArgsTexImage(G)*gmlSizeOf(H),TRUE)
+GML_MAKEFUN1V(Color4fv,GLfloat,4,const)
+GML_MAKEFUN2(BindProgramARB,GLenum,GLuint,)
+GML_MAKEFUN3(Scalef,GLfloat,GLfloat,GLfloat,)
+GML_MAKEFUN4(Viewport,GLint,GLint,GLsizei,GLsizei)
+GML_MAKEFUN2V(DeleteTextures,GLsizei,GLuint,A,const)
+GML_MAKEFUN3(MultiTexCoord2fARB,GLenum,GLfloat,GLfloat,)
+GML_MAKEFUN2(AlphaFunc,GLenum,GLclampf,)
+GML_MAKEFUN1(DepthMask,GLboolean)
+GML_MAKEFUN1(LineWidth,GLfloat)
+GML_MAKEFUN2(BindFramebufferEXT,GLenum,GLuint,)
+GML_MAKEFUN4(Rotatef,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN2(DeleteLists,GLuint,GLsizei,)
+GML_MAKEFUN1CS(DisableClientState,GLenum,&amp;=~)
+GML_MAKEFUN1CS(EnableClientState,GLenum,|=)
+GML_MAKEFUN4(Rectf,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN3V(Lightfv,GLenum,GLenum,GLfloat,gmlNumArgsLightMat(B),const)
+GML_MAKEFUN7S(uBuild2DMipmaps,GLenum,GLint,GLsizei,GLsizei,GLenum,GLenum,const GLvoid *,C*D*gmlNumArgsTexImage(E)*gmlSizeOf(F))
+GML_MAKEFUN1(Clear,GLbitfield)
+GML_MAKEFUN0(EndList)
+GML_MAKEFUN2(NewList,GLuint,GLenum,)
+GML_MAKEFUN4(ClearColor,GLclampf,GLclampf,GLclampf,GLclampf)
+GML_MAKEFUN2(PolygonMode,GLenum,GLenum,)
+GML_MAKEFUN1(ActiveTexture,GLenum)
+GML_MAKEFUN2(Fogf,GLenum,GLfloat,)
+GML_MAKEFUN1V(MultMatrixf,GLfloat,16,const)
+GML_MAKEFUN6(Ortho,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble)
+GML_MAKEFUN0(PopAttrib)
+GML_MAKEFUN3V(Materialfv,GLenum,GLenum,GLfloat,gmlNumArgsLightMat(B),const)
+GML_MAKEFUN2(PolygonOffset,GLfloat,GLfloat,)
+GML_MAKEFUN1(PushAttrib,GLbitfield)
+GML_MAKEFUN1(CullFace,GLenum)
+GML_MAKEFUN4(ColorMask,GLboolean,GLboolean,GLboolean,GLboolean)
+GML_MAKEFUN1V(Vertex3fv,GLfloat,3,)
+GML_MAKEFUN3V(TexGenfv,GLenum,GLenum,GLfloat,gmlNumArgsTexGen(B),)
+GML_MAKEFUN2(Vertex2d,GLdouble,GLdouble,)
+GML_MAKEFUN4P(VertexPointer,GLint,GLenum,GLsizei,GLvoid *, VP)
+GML_MAKEFUN3VDA(DrawArrays,GLenum,GLint,GLsizei)
+GML_MAKEFUN2V(Fogfv,GLenum,GLfloat,gmlNumArgsFog(A),)
+GML_MAKEFUN5(FramebufferTexture2DEXT,GLenum,GLenum,GLenum,GLuint,GLint)
+GML_MAKEFUN4P(TexCoordPointer,GLint,GLenum,GLsizei,GLvoid *, TCP)
+GML_MAKEFUN9S(TexSubImage2D,GLenum,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,const GLvoid *,E*F*gmlNumArgsTexImage(G)*gmlSizeOf(H),FALSE)
+GML_MAKEFUN2V(ClipPlane,GLenum,GLdouble,4,const)
+GML_MAKEFUN4(Color4d,GLdouble,GLdouble,GLdouble,GLdouble)
+GML_MAKEFUN2(LightModeli,GLenum,GLint,)
+GML_MAKEFUN3(TexGeni,GLenum,GLenum,GLint,)
+GML_MAKEFUN3(TexParameterf,GLenum,GLenum,GLfloat,)
+GML_MAKEFUN8(CopyTexSubImage2D,GLenum,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei)
+GML_MAKEFUN2V(DeleteFramebuffersEXT,GLsizei,GLuint,A,const)
+GML_MAKEFUN1V(LoadMatrixf,GLfloat,16,)
+GML_MAKEFUN1(ShadeModel,GLenum)
+GML_MAKEFUN1(UseProgram,GLuint)
+GML_MAKEFUN1(ClientActiveTextureARB,GLenum)
+GML_MAKEFUN2V(DeleteRenderbuffersEXT,GLsizei,GLuint,A,const)
+GML_MAKEFUN0(Flush)
+GML_MAKEFUN3(Normal3f,GLfloat,GLfloat,GLfloat,)
+GML_MAKEFUN1(UseProgramObjectARB,GLhandleARB)
+GML_MAKEFUN8V(CompressedTexImage2DARB,GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,GLsizei,char,G,)
+GML_MAKEFUN1(DeleteObjectARB,GLhandleARB)
+GML_MAKEFUN2(Fogi,GLenum,GLint,)
+GML_MAKEFUN1V(MultMatrixd,GLdouble,16,const)
+GML_MAKEFUN2(PixelStorei,GLenum,GLint,)
+GML_MAKEFUN2(PointParameterf,GLenum,GLfloat,)
+GML_MAKEFUN3(TexCoord3f,GLfloat,GLfloat,GLfloat,)
+GML_MAKEFUN2(Uniform1i,GLint,GLint,)
+GML_MAKEFUN2(BindRenderbufferEXT,GLenum,GLuint,)
+GML_MAKEFUN1V(Color3fv,GLfloat,3,const)
+GML_MAKEFUN1(DepthFunc,GLenum)
+GML_MAKEFUN2(Hint,GLenum,GLenum,)
+GML_MAKEFUN1(LogicOp,GLenum)
+GML_MAKEFUN3(StencilOp,GLenum,GLenum,GLenum,)
+GML_MAKEFUN3V(TexEnvfv,GLenum,GLenum,GLfloat,gmlNumArgsTexEnv(B),)
+GML_MAKEFUN4V(UniformMatrix4fv,GLint,GLsizei,GLboolean,GLfloat,16*B,)
+GML_MAKEFUN4(uOrtho2D,GLdouble,GLdouble,GLdouble,GLdouble)
+GML_MAKEFUN2(AttachObjectARB,GLhandleARB,GLhandleARB,)
+GML_MAKEFUN2(BindBufferARB,GLenum,GLuint,)
+GML_MAKEFUN1V(Color3ubv,GLubyte,3,)
+GML_MAKEFUN2(DetachObjectARB,GLhandleARB,GLhandleARB,)
+GML_MAKEFUN4(FramebufferRenderbufferEXT,GLenum,GLenum,GLenum,GLuint)
+GML_MAKEFUN2(LineStipple,GLint,GLushort,)
+GML_MAKEFUN1V(LoadMatrixd,GLdouble,16,const)
+GML_MAKEFUN2(SetFenceNV,GLuint,GLenum,)
+GML_MAKEFUN3(StencilFunc,GLenum,GLint,GLuint,)
+GML_MAKEFUN10S(TexImage3D,GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,GLint,GLenum,GLenum,const GLvoid *,D*E*F*gmlNumArgsTexImage(H)*gmlSizeOf(I))
+GML_MAKEFUN2(Uniform1f,GLint,GLfloat,)
+GML_MAKEFUN1(ClearStencil,GLint)
+GML_MAKEFUN4P(ColorPointer,GLint,GLenum,GLsizei,GLvoid *, CP)
+GML_MAKEFUN1(DeleteShader,GLuint)
+GML_MAKEFUN4VDE(DrawElements,GLenum,GLsizei,GLenum,GLvoid *)
+GML_MAKEFUN1(GenerateMipmapEXT,GLenum)
+GML_MAKEFUN3(Materialf,GLenum,GLenum,GLfloat,)
+GML_MAKEFUN3P(NormalPointer,GLenum,GLsizei,GLvoid *, NP)
+GML_MAKEFUN3V(ProgramEnvParameter4fvARB,GLenum,GLuint,GLfloat,4,)
+GML_MAKEFUN4(RenderbufferStorageEXT,GLenum,GLenum,GLsizei,GLsizei)
+GML_MAKEFUN1(StencilMask,GLuint)
+GML_MAKEFUN4(Uniform3f,GLint,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN4(uPerspective,GLdouble,GLdouble,GLdouble,GLdouble)
+GML_MAKEFUN1(ActiveStencilFaceEXT,GLenum)
+GML_MAKEFUN2(AttachShader,GLuint,GLuint,)
+GML_MAKEFUN10(BlitFramebufferEXT,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLbitfield,GLenum)
+GML_MAKEFUN4VS(BufferDataARB,GLenum,GLsizei,char,GLenum,B)
+GML_MAKEFUN1(ClearDepth,GLclampd)
+GML_MAKEFUN3(Color3ub,GLubyte,GLubyte,GLubyte,)
+GML_MAKEFUN7V(CompressedTexImage1DARB,GLenum,GLint,GLenum,GLsizei,GLint,GLsizei,char,F,)
+GML_MAKEFUN9V(CompressedTexImage3DARB,GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,GLint,GLsizei,char,H,)
+GML_MAKEFUN1(DrawBuffer,GLenum)
+GML_MAKEFUN1(FrontFace,GLenum)
+GML_MAKEFUN6(Frustum,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble)
+GML_MAKEFUN1(LinkProgramARB,GLhandleARB)
+GML_MAKEFUN2(MultiTexCoord1f,GLenum,GLfloat,)
+GML_MAKEFUN3(MultiTexCoord2f,GLenum,GLfloat,GLfloat,)
+GML_MAKEFUN4(MultiTexCoord3f,GLenum,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN5(MultiTexCoord4f,GLenum,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN2V(PointParameterfv,GLenum,GLfloat,gmlNumArgsPointParam(A),)
+GML_MAKEFUN1(PointSize,GLfloat)
+GML_MAKEFUN4V(ProgramStringARB,GLenum,GLenum,GLsizei,char,C,)
+GML_MAKEFUN3(SecondaryColor3f,GLfloat,GLfloat,GLfloat,)
+GML_MAKEFUN1(TexCoord1f,GLfloat)
+GML_MAKEFUN4(TexCoord4f,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN3(TexEnvf,GLenum,GLenum,GLfloat,)
+GML_MAKEFUN3(TexGenf,GLenum,GLenum,GLfloat,)
+GML_MAKEFUN8S(TexImage1D,GLenum,GLint,GLint,GLsizei,GLint,GLenum,GLenum,const GLvoid *,D*gmlNumArgsTexImage(F)*gmlSizeOf(G))
+GML_MAKEFUN2(Uniform1iARB,GLint,GLint,)
+GML_MAKEFUN3(Uniform2f,GLint,GLfloat,GLfloat,)
+GML_MAKEFUN3(Uniform2fARB,GLint,GLfloat,GLfloat,)
+GML_MAKEFUN3(Uniform2i,GLint,GLint,GLint,)
+GML_MAKEFUN4(Uniform3fARB,GLint,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN4(Uniform3i,GLint,GLint,GLint,GLint)
+GML_MAKEFUN5(Uniform4f,GLint,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN5(Uniform4i,GLint,GLint,GLint,GLint,GLint)
+GML_MAKEFUN4V(UniformMatrix2fv,GLint,GLsizei,GLboolean,GLfloat,4*B,)
+GML_MAKEFUN4V(UniformMatrix3fv,GLint,GLsizei,GLboolean,GLfloat,9*B,)
+GML_MAKEFUN4(Vertex4f,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN1(uDeleteQuadric,GLUquadric *)
+GML_MAKEFUN2(uQuadricDrawStyle,GLUquadric *,GLenum,)
+GML_MAKEFUN4(uSphere,GLUquadric *,GLdouble,GLint,GLint)
+GML_MAKEFUN4(ClearAccum,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN4(Color4ub,GLubyte,GLubyte,GLubyte,GLubyte)
+GML_MAKEFUN1V(Color4ubv,GLubyte,4,)
+GML_MAKEFUN1(CompileShader,GLuint)
+GML_MAKEFUN1(CompileShaderARB,GLhandleARB)
+GML_MAKEFUN8(CopyTexImage2D,GLenum,GLint,GLenum,GLint,GLint,GLsizei,GLsizei,GLint)
+GML_MAKEFUN2V(DeleteBuffersARB,GLsizei,GLuint,A,)
+GML_MAKEFUN2V(DeleteFencesNV,GLsizei,GLuint,A,)
+GML_MAKEFUN1(DeleteProgram,GLuint)
+GML_MAKEFUN2V(DeleteProgramsARB,GLsizei,GLuint,A,)
+GML_MAKEFUN2(DetachShader,GLuint,GLuint,)
+GML_MAKEFUN1VA(DisableVertexAttribArrayARB,GLuint,VA,erase)
+GML_MAKEFUN2V(DrawBuffersARB,GLsizei,GLenum,A,)
+GML_MAKEFUN1(EdgeFlag,GLboolean)
+GML_MAKEFUN1VA(EnableVertexAttribArrayARB,GLuint,VA,insert)
+GML_MAKEFUN0(Finish)
+GML_MAKEFUN1(FinishFenceNV,GLuint)
+GML_MAKEFUN1(FogCoordf,GLfloat)
+GML_MAKEFUN3(Lightf,GLenum,GLenum,GLfloat,)
+GML_MAKEFUN1(LinkProgram,GLuint)
+GML_MAKEFUN1V(Normal3fv,GLfloat,3,)
+GML_MAKEFUN2(RasterPos2i,GLint,GLint,)
+GML_MAKEFUN1(ReadBuffer,GLenum)
+GML_MAKEFUN4(Scissor,GLint,GLint,GLsizei,GLsizei)
+GML_MAKEFUN4VSS(ShaderSource,GLuint,GLsizei,const GLchar*,GLint,B)
+GML_MAKEFUN4VSS(ShaderSourceARB,GLhandleARB,GLsizei,const GLcharARB*,GLint,B)
+GML_MAKEFUN1V(TexCoord2fv,GLfloat,2,)
+GML_MAKEFUN3V(TexParameterfv,GLenum,GLenum,GLfloat,gmlNumArgsTexParam(B),)
+GML_MAKEFUN3(Translated,GLdouble,GLdouble,GLdouble,)
+GML_MAKEFUN3V(Uniform1fv,GLint,GLsizei,GLfloat,B,)
+GML_MAKEFUN5(Uniform4fARB,GLint,GLfloat,GLfloat,GLfloat,GLfloat)
+GML_MAKEFUN4V(UniformMatrix4fvARB,GLint,GLsizei,GLboolean,GLfloat,16*B,);
+GML_MAKEFUN6P(VertexAttribPointerARB,GLuint,GLint,GLenum,GLboolean,GLsizei,void *,VA)
+GML_MAKEFUN9(uLookAt,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble)
+GML_MAKEFUN2V(LightModelfv,GLenum,GLfloat,gmlNumArgsLightModel(A),const)
+
+GML_MAKEFUN2V(DeleteQueries,GLsizei,GLuint,A,const)
+GML_MAKEFUN1(BlendEquation,GLenum)
+GML_MAKEFUN2(StencilMaskSeparate,GLenum,GLuint,)
+GML_MAKEFUN4(StencilFuncSeparate,GLenum,GLenum,GLint,GLuint)
+GML_MAKEFUN4(StencilOpSeparate,GLenum,GLenum,GLenum,GLenum)
+GML_MAKEFUN2(BeginQuery,GLenum,GLuint,)
+GML_MAKEFUN1(EndQuery,GLenum)
+GML_MAKEFUN3(GetQueryObjectuiv,GLuint,GLenum,GLuint *,,GML_SYNC())
+GML_MAKEFUN2(BlendEquationSeparate,GLenum,GLenum,)
+GML_MAKEFUN4(BlendFuncSeparate,GLenum,GLenum,GLenum,GLenum)
+GML_MAKEFUN6(uCylinder,GLUquadric *,GLdouble,GLdouble,GLdouble,GLint,GLint)
+
+GML_MAKEFUN2(GetIntegerv,GLenum, GLint *,GML_CACHE(GLenum,GLint,gmlGetIntegervCache,A,B),GML_SYNC())
+GML_MAKEFUN1R(CheckFramebufferStatusEXT,GLenum, GLenum,GML_DEFAULT_RET(A==GL_FRAMEBUFFER_EXT,GL_FRAMEBUFFER_COMPLETE_EXT))
+GML_MAKEFUN2(GetFloatv,GLenum, GLfloat *,GML_CACHE(GLenum,GLfloat,gmlGetFloatvCache,A,B),GML_SYNC())
+GML_MAKEFUN1R(GetString,GLenum, const GLubyte *,GML_CACHE_RET_STR(GLenum,std::string,gmlGetStringCache,A))
+GML_MAKEFUN2R(GetUniformLocationARB,GLhandleARB, const GLcharARB *, GLint)
+GML_MAKEFUN7(ReadPixels,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,GLvoid *,GML_SYNC())
+GML_MAKEFUN0R(GetError,GLenum,GML_DEFAULT_ERROR())
+GML_MAKEFUN3(GetObjectParameterivARB,GLhandleARB,GLenum,GLint *,GML_DEFAULT(B==GL_OBJECT_COMPILE_STATUS_ARB || B==GL_OBJECT_LINK_STATUS_ARB,*C=GL_TRUE),GML_SYNC())
+GML_MAKEFUN2R(GetUniformLocation,GLint, const GLchar *, GLint)
+GML_MAKEFUN2(GetDoublev,GLenum, GLdouble *,,GML_SYNC())
+GML_MAKEFUN3(GetProgramiv,GLuint,GLenum,GLint *,,GML_SYNC())
+GML_MAKEFUN7(GetActiveUniform,GLuint,GLuint,GLsizei,GLsizei *,GLint *,GLenum *,GLchar *,GML_SYNC())
+GML_MAKEFUN2R(GetAttribLocationARB,GLhandleARB, const GLcharARB *, GLint)
+GML_MAKEFUN4(GetInfoLogARB,GLhandleARB,GLsizei,GLsizei *,GLcharARB *,GML_SYNC())
+GML_MAKEFUN4(GetProgramInfoLog,GLuint,GLsizei,GLsizei *,GLchar *,GML_SYNC())
+GML_MAKEFUN3(GetProgramivARB,GLenum,GLenum,GLint *,,GML_SYNC())
+GML_MAKEFUN4(GetShaderInfoLog,GLuint,GLsizei,GLsizei *,GLchar *,GML_SYNC())
+GML_MAKEFUN3(GetShaderiv,GLuint,GLenum,GLint *,GML_DEFAULT(B==GL_COMPILE_STATUS,*C=GL_TRUE),GML_SYNC())
+GML_MAKEFUN1R(IsRenderbufferEXT,GLuint,GLboolean,)
+GML_MAKEFUN2R(MapBufferARB,GLenum,GLenum,GLvoid *)
+GML_MAKEFUN9R(uProject,GLdouble,GLdouble,GLdouble,const GLdouble *,const GLdouble *,const GLint *,GLdouble *,GLdouble *,GLdouble *,int)
+GML_MAKEFUN9R(uScaleImage,GLenum,GLint,GLint,GLenum,const void *,GLint,GLint,GLenum,void *,int)
+GML_MAKEFUN1R(TestFenceNV,GLuint,GLboolean,)
+
+GML_MAKEFUN3P(IndexPointer,GLenum,GLsizei,GLvoid *, IP)
+GML_MAKEFUN2P(EdgeFlagPointer,GLsizei,GLboolean *, EFP)
+GML_MAKEFUN4(TrackMatrixNV,GLenum,GLuint,GLenum,GLenum)
+
+
+
+#endif
\ No newline at end of file

Added: branches/gml/rts/lib/gml/gmlimp.h
===================================================================
--- branches/gml/rts/lib/gml/gmlimp.h	                        (rev 0)
+++ branches/gml/rts/lib/gml/gmlimp.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -0,0 +1,3122 @@
+// GML - OpenGL Multithreading Library
+// Author: Mattias &quot;zerver&quot; Radeskog
+// (C) Ware Zerver Tech. <A HREF="http://zerver.net">http://zerver.net</A>
+// Ware Zerver Tech. licenses this library to
+// be used freely, for any purpose, within the
+// Spring project <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
+// as long as this notice remains unchanged
+
+#undef glAccum
+#undef glActiveStencilFaceEXT
+#undef glActiveTexture
+#undef glActiveTextureARB
+#undef glActiveVaryingNV
+#undef glAddSwapHintRectWIN
+#undef glAlphaFragmentOp1ATI
+#undef glAlphaFragmentOp2ATI
+#undef glAlphaFragmentOp3ATI
+#undef glAlphaFunc
+#undef glApplyTextureEXT
+#undef glAreProgramsResidentNV
+#undef glAreTexturesResident
+#undef glAreTexturesResidentEXT
+#undef glArrayElement
+#undef glArrayElementEXT
+#undef glArrayObjectATI
+#undef glAsyncMarkerSGIX
+#undef glAttachObjectARB
+#undef glAttachShader
+#undef glBegin
+#undef glBeginFragmentShaderATI
+#undef glBeginOcclusionQueryNV
+#undef glBeginQuery
+#undef glBeginQueryARB
+#undef glBeginSceneEXT
+#undef glBeginTransformFeedbackNV
+#undef glBeginVertexShaderEXT
+#undef glBindAttribLocation
+#undef glBindAttribLocationARB
+#undef glBindBuffer
+#undef glBindBufferARB
+#undef glBindBufferBaseNV
+#undef glBindBufferOffsetNV
+#undef glBindBufferRangeNV
+#undef glBindFragDataLocationEXT
+#undef glBindFragmentShaderATI
+#undef glBindFramebufferEXT
+#undef glBindLightParameterEXT
+#undef glBindMaterialParameterEXT
+#undef glBindParameterEXT
+#undef glBindProgramARB
+#undef glBindProgramNV
+#undef glBindRenderbufferEXT
+#undef glBindTexGenParameterEXT
+#undef glBindTexture
+#undef glBindTextureEXT
+#undef glBindTextureUnitParameterEXT
+#undef glBindVertexArrayAPPLE
+#undef glBindVertexShaderEXT
+#undef glBinormalPointerEXT
+#undef glBitmap
+#undef glBlendColor
+#undef glBlendColorEXT
+#undef glBlendEquation
+#undef glBlendEquationEXT
+#undef glBlendEquationSeparate
+#undef glBlendEquationSeparateEXT
+#undef glBlendFunc
+#undef glBlendFuncSeparate
+#undef glBlendFuncSeparateEXT
+#undef glBlitFramebufferEXT
+#undef glBufferData
+#undef glBufferDataARB
+#undef glBufferRegionEnabledEXT
+#undef glBufferSubData
+#undef glBufferSubDataARB
+#undef glCallList
+#undef glCallLists
+#undef glCheckFramebufferStatusEXT
+#undef glClampColorARB
+#undef glClear
+#undef glClearAccum
+#undef glClearColor
+#undef glClearColorIiEXT
+#undef glClearColorIuiEXT
+#undef glClearDepth
+#undef glClearDepthdNV
+#undef glClearDepthfOES
+#undef glClearIndex
+#undef glClearStencil
+#undef glClientActiveTexture
+#undef glClientActiveTextureARB
+#undef glClientActiveVertexStreamATI
+#undef glClipPlane
+#undef glClipPlanefOES
+#undef glColor3b
+#undef glColor3bv
+#undef glColor3d
+#undef glColor3dv
+#undef glColor3f
+#undef glColor3fVertex3fSUN
+#undef glColor3fVertex3fvSUN
+#undef glColor3fv
+#undef glColor3hNV
+#undef glColor3hvNV
+#undef glColor3i
+#undef glColor3iv
+#undef glColor3s
+#undef glColor3sv
+#undef glColor3ub
+#undef glColor3ubv
+#undef glColor3ui
+#undef glColor3uiv
+#undef glColor3us
+#undef glColor3usv
+#undef glColor4b
+#undef glColor4bv
+#undef glColor4d
+#undef glColor4dv
+#undef glColor4f
+#undef glColor4fNormal3fVertex3fSUN
+#undef glColor4fNormal3fVertex3fvSUN
+#undef glColor4fv
+#undef glColor4hNV
+#undef glColor4hvNV
+#undef glColor4i
+#undef glColor4iv
+#undef glColor4s
+#undef glColor4sv
+#undef glColor4ub
+#undef glColor4ubVertex2fSUN
+#undef glColor4ubVertex2fvSUN
+#undef glColor4ubVertex3fSUN
+#undef glColor4ubVertex3fvSUN
+#undef glColor4ubv
+#undef glColor4ui
+#undef glColor4uiv
+#undef glColor4us
+#undef glColor4usv
+#undef glColorFragmentOp1ATI
+#undef glColorFragmentOp2ATI
+#undef glColorFragmentOp3ATI
+#undef glColorMask
+#undef glColorMaskIndexedEXT
+#undef glColorMaterial
+#undef glColorPointer
+#undef glColorPointerEXT
+#undef glColorPointerListIBM
+#undef glColorPointervINTEL
+#undef glColorSubTable
+#undef glColorSubTableEXT
+#undef glColorTable
+#undef glColorTableEXT
+#undef glColorTableParameterfv
+#undef glColorTableParameterfvSGI
+#undef glColorTableParameteriv
+#undef glColorTableParameterivSGI
+#undef glColorTableSGI
+#undef glCombinerInputNV
+#undef glCombinerOutputNV
+#undef glCombinerParameterfNV
+#undef glCombinerParameterfvNV
+#undef glCombinerParameteriNV
+#undef glCombinerParameterivNV
+#undef glCombinerStageParameterfvNV
+#undef glCompileShader
+#undef glCompileShaderARB
+#undef glCompressedTexImage1D
+#undef glCompressedTexImage1DARB
+#undef glCompressedTexImage2D
+#undef glCompressedTexImage2DARB
+#undef glCompressedTexImage3D
+#undef glCompressedTexImage3DARB
+#undef glCompressedTexSubImage1D
+#undef glCompressedTexSubImage1DARB
+#undef glCompressedTexSubImage2D
+#undef glCompressedTexSubImage2DARB
+#undef glCompressedTexSubImage3D
+#undef glCompressedTexSubImage3DARB
+#undef glConvolutionFilter1D
+#undef glConvolutionFilter1DEXT
+#undef glConvolutionFilter2D
+#undef glConvolutionFilter2DEXT
+#undef glConvolutionParameterf
+#undef glConvolutionParameterfEXT
+#undef glConvolutionParameterfv
+#undef glConvolutionParameterfvEXT
+#undef glConvolutionParameteri
+#undef glConvolutionParameteriEXT
+#undef glConvolutionParameteriv
+#undef glConvolutionParameterivEXT
+#undef glCopyColorSubTable
+#undef glCopyColorSubTableEXT
+#undef glCopyColorTable
+#undef glCopyColorTableSGI
+#undef glCopyConvolutionFilter1D
+#undef glCopyConvolutionFilter1DEXT
+#undef glCopyConvolutionFilter2D
+#undef glCopyConvolutionFilter2DEXT
+#undef glCopyPixels
+#undef glCopyTexImage1D
+#undef glCopyTexImage1DEXT
+#undef glCopyTexImage2D
+#undef glCopyTexImage2DEXT
+#undef glCopyTexSubImage1D
+#undef glCopyTexSubImage1DEXT
+#undef glCopyTexSubImage2D
+#undef glCopyTexSubImage2DEXT
+#undef glCopyTexSubImage3D
+#undef glCopyTexSubImage3DEXT
+#undef glCreateProgram
+#undef glCreateProgramObjectARB
+#undef glCreateShader
+#undef glCreateShaderObjectARB
+#undef glCullFace
+#undef glCullParameterdvEXT
+#undef glCullParameterfvEXT
+#undef glCurrentPaletteMatrixARB
+#undef glDeleteAsyncMarkersSGIX
+#undef glDeleteBufferRegionEXT
+#undef glDeleteBuffers
+#undef glDeleteBuffersARB
+#undef glDeleteFencesAPPLE
+#undef glDeleteFencesNV
+#undef glDeleteFragmentShaderATI
+#undef glDeleteFramebuffersEXT
+#undef glDeleteLists
+#undef glDeleteObjectARB
+#undef glDeleteOcclusionQueriesNV
+#undef glDeleteProgram
+#undef glDeleteProgramsARB
+#undef glDeleteProgramsNV
+#undef glDeleteQueries
+#undef glDeleteQueriesARB
+#undef glDeleteRenderbuffersEXT
+#undef glDeleteShader
+#undef glDeleteTextures
+#undef glDeleteTexturesEXT
+#undef glDeleteVertexArraysAPPLE
+#undef glDeleteVertexShaderEXT
+#undef glDepthBoundsEXT
+#undef glDepthBoundsdNV
+#undef glDepthFunc
+#undef glDepthMask
+#undef glDepthRange
+#undef glDepthRangedNV
+#undef glDepthRangefOES
+#undef glDetachObjectARB
+#undef glDetachShader
+#undef glDetailTexFuncSGIS
+#undef glDisable
+#undef glDisableClientState
+#undef glDisableIndexedEXT
+#undef glDisableVariantClientStateEXT
+#undef glDisableVertexAttribArray
+#undef glDisableVertexAttribArrayARB
+#undef glDrawArrays
+#undef glDrawArraysEXT
+#undef glDrawArraysInstancedEXT
+#undef glDrawBuffer
+#undef glDrawBufferRegionEXT
+#undef glDrawBuffers
+#undef glDrawBuffersARB
+#undef glDrawBuffersATI
+#undef glDrawElementArrayAPPLE
+#undef glDrawElementArrayATI
+#undef glDrawElements
+#undef glDrawElementsInstancedEXT
+#undef glDrawPixels
+#undef glDrawRangeElementArrayAPPLE
+#undef glDrawRangeElementArrayATI
+#undef glDrawRangeElements
+#undef glDrawRangeElementsEXT
+#undef glEdgeFlag
+#undef glEdgeFlagPointer
+#undef glEdgeFlagPointerEXT
+#undef glEdgeFlagPointerListIBM
+#undef glEdgeFlagv
+#undef glElementPointerAPPLE
+#undef glElementPointerATI
+#undef glEnable
+#undef glEnableClientState
+#undef glEnableIndexedEXT
+#undef glEnableVariantClientStateEXT
+#undef glEnableVertexAttribArray
+#undef glEnableVertexAttribArrayARB
+#undef glEnd
+#undef glEndFragmentShaderATI
+#undef glEndList
+#undef glEndOcclusionQueryNV
+#undef glEndQuery
+#undef glEndQueryARB
+#undef glEndSceneEXT
+#undef glEndTransformFeedbackNV
+#undef glEndVertexShaderEXT
+#undef glEvalCoord1d
+#undef glEvalCoord1dv
+#undef glEvalCoord1f
+#undef glEvalCoord1fv
+#undef glEvalCoord2d
+#undef glEvalCoord2dv
+#undef glEvalCoord2f
+#undef glEvalCoord2fv
+#undef glEvalMapsNV
+#undef glEvalMesh1
+#undef glEvalMesh2
+#undef glEvalPoint1
+#undef glEvalPoint2
+#undef glExecuteProgramNV
+#undef glExtractComponentEXT
+#undef glFeedbackBuffer
+#undef glFinalCombinerInputNV
+#undef glFinish
+#undef glFinishAsyncSGIX
+#undef glFinishFenceAPPLE
+#undef glFinishFenceNV
+#undef glFinishObjectAPPLE
+#undef glFinishTextureSUNX
+#undef glFlush
+#undef glFlushPixelDataRangeNV
+#undef glFlushRasterSGIX
+#undef glFlushVertexArrayRangeAPPLE
+#undef glFlushVertexArrayRangeNV
+#undef glFogCoordPointer
+#undef glFogCoordPointerEXT
+#undef glFogCoordPointerListIBM
+#undef glFogCoordd
+#undef glFogCoorddEXT
+#undef glFogCoorddv
+#undef glFogCoorddvEXT
+#undef glFogCoordf
+#undef glFogCoordfEXT
+#undef glFogCoordfv
+#undef glFogCoordfvEXT
+#undef glFogCoordhNV
+#undef glFogCoordhvNV
+#undef glFogFuncSGIS
+#undef glFogf
+#undef glFogfv
+#undef glFogi
+#undef glFogiv
+#undef glFragmentColorMaterialEXT
+#undef glFragmentColorMaterialSGIX
+#undef glFragmentLightModelfEXT
+#undef glFragmentLightModelfSGIX
+#undef glFragmentLightModelfvEXT
+#undef glFragmentLightModelfvSGIX
+#undef glFragmentLightModeliEXT
+#undef glFragmentLightModeliSGIX
+#undef glFragmentLightModelivEXT
+#undef glFragmentLightModelivSGIX
+#undef glFragmentLightfEXT
+#undef glFragmentLightfSGIX
+#undef glFragmentLightfvEXT
+#undef glFragmentLightfvSGIX
+#undef glFragmentLightiEXT
+#undef glFragmentLightiSGIX
+#undef glFragmentLightivEXT
+#undef glFragmentLightivSGIX
+#undef glFragmentMaterialfEXT
+#undef glFragmentMaterialfSGIX
+#undef glFragmentMaterialfvEXT
+#undef glFragmentMaterialfvSGIX
+#undef glFragmentMaterialiEXT
+#undef glFragmentMaterialiSGIX
+#undef glFragmentMaterialivEXT
+#undef glFragmentMaterialivSGIX
+#undef glFrameZoomSGIX
+#undef glFramebufferRenderbufferEXT
+#undef glFramebufferTexture1DEXT
+#undef glFramebufferTexture2DEXT
+#undef glFramebufferTexture3DEXT
+#undef glFramebufferTextureEXT
+#undef glFramebufferTextureFaceEXT
+#undef glFramebufferTextureLayerEXT
+#undef glFreeObjectBufferATI
+#undef glFrontFace
+#undef glFrustum
+#undef glFrustumfOES
+#undef glGenAsyncMarkersSGIX
+#undef glGenBuffers
+#undef glGenBuffersARB
+#undef glGenFencesAPPLE
+#undef glGenFencesNV
+#undef glGenFragmentShadersATI
+#undef glGenFramebuffersEXT
+#undef glGenLists
+#undef glGenOcclusionQueriesNV
+#undef glGenProgramsARB
+#undef glGenProgramsNV
+#undef glGenQueries
+#undef glGenQueriesARB
+#undef glGenRenderbuffersEXT
+#undef glGenSymbolsEXT
+#undef glGenTextures
+#undef glGenTexturesEXT
+#undef glGenVertexArraysAPPLE
+#undef glGenVertexShadersEXT
+#undef glGenerateMipmapEXT
+#undef glGetActiveAttrib
+#undef glGetActiveAttribARB
+#undef glGetActiveUniform
+#undef glGetActiveUniformARB
+#undef glGetActiveVaryingNV
+#undef glGetArrayObjectfvATI
+#undef glGetArrayObjectivATI
+#undef glGetAttachedObjectsARB
+#undef glGetAttachedShaders
+#undef glGetAttribLocation
+#undef glGetAttribLocationARB
+#undef glGetBooleanIndexedvEXT
+#undef glGetBooleanv
+#undef glGetBufferParameteriv
+#undef glGetBufferParameterivARB
+#undef glGetBufferPointerv
+#undef glGetBufferPointervARB
+#undef glGetBufferSubData
+#undef glGetBufferSubDataARB
+#undef glGetClipPlane
+#undef glGetClipPlanefOES
+#undef glGetColorTable
+#undef glGetColorTableEXT
+#undef glGetColorTableParameterfv
+#undef glGetColorTableParameterfvEXT
+#undef glGetColorTableParameterfvSGI
+#undef glGetColorTableParameteriv
+#undef glGetColorTableParameterivEXT
+#undef glGetColorTableParameterivSGI
+#undef glGetColorTableSGI
+#undef glGetCombinerInputParameterfvNV
+#undef glGetCombinerInputParameterivNV
+#undef glGetCombinerOutputParameterfvNV
+#undef glGetCombinerOutputParameterivNV
+#undef glGetCombinerStageParameterfvNV
+#undef glGetCompressedTexImage
+#undef glGetCompressedTexImageARB
+#undef glGetConvolutionFilter
+#undef glGetConvolutionFilterEXT
+#undef glGetConvolutionParameterfv
+#undef glGetConvolutionParameterfvEXT
+#undef glGetConvolutionParameteriv
+#undef glGetConvolutionParameterivEXT
+#undef glGetDetailTexFuncSGIS
+#undef glGetDoublev
+#undef glGetError
+#undef glGetFenceivNV
+#undef glGetFinalCombinerInputParameterfvNV
+#undef glGetFinalCombinerInputParameterivNV
+#undef glGetFloatv
+#undef glGetFogFuncSGIS
+#undef glGetFragDataLocationEXT
+#undef glGetFragmentLightfvEXT
+#undef glGetFragmentLightfvSGIX
+#undef glGetFragmentLightivEXT
+#undef glGetFragmentLightivSGIX
+#undef glGetFragmentMaterialfvEXT
+#undef glGetFragmentMaterialfvSGIX
+#undef glGetFragmentMaterialivEXT
+#undef glGetFragmentMaterialivSGIX
+#undef glGetFramebufferAttachmentParameterivEXT
+#undef glGetHandleARB
+#undef glGetHistogram
+#undef glGetHistogramEXT
+#undef glGetHistogramParameterfv
+#undef glGetHistogramParameterfvEXT
+#undef glGetHistogramParameteriv
+#undef glGetHistogramParameterivEXT
+#undef glGetImageTransformParameterfvHP
+#undef glGetImageTransformParameterivHP
+#undef glGetInfoLogARB
+#undef glGetIntegerIndexedvEXT
+#undef glGetIntegerv
+#undef glGetInvariantBooleanvEXT
+#undef glGetInvariantFloatvEXT
+#undef glGetInvariantIntegervEXT
+#undef glGetLightfv
+#undef glGetLightiv
+#undef glGetLocalConstantBooleanvEXT
+#undef glGetLocalConstantFloatvEXT
+#undef glGetLocalConstantIntegervEXT
+#undef glGetMapAttribParameterfvNV
+#undef glGetMapAttribParameterivNV
+#undef glGetMapControlPointsNV
+#undef glGetMapParameterfvNV
+#undef glGetMapParameterivNV
+#undef glGetMapdv
+#undef glGetMapfv
+#undef glGetMapiv
+#undef glGetMaterialfv
+#undef glGetMaterialiv
+#undef glGetMinmax
+#undef glGetMinmaxEXT
+#undef glGetMinmaxParameterfv
+#undef glGetMinmaxParameterfvEXT
+#undef glGetMinmaxParameteriv
+#undef glGetMinmaxParameterivEXT
+#undef glGetObjectBufferfvATI
+#undef glGetObjectBufferivATI
+#undef glGetObjectParameterfvARB
+#undef glGetObjectParameterivARB
+#undef glGetOcclusionQueryivNV
+#undef glGetOcclusionQueryuivNV
+#undef glGetPixelMapfv
+#undef glGetPixelMapuiv
+#undef glGetPixelMapusv
+#undef glGetPixelTransformParameterfvEXT
+#undef glGetPixelTransformParameterivEXT
+#undef glGetPointerv
+#undef glGetPointervEXT
+#undef glGetPolygonStipple
+#undef glGetProgramEnvParameterdvARB
+#undef glGetProgramEnvParameterfvARB
+#undef glGetProgramInfoLog
+#undef glGetProgramLocalParameterdvARB
+#undef glGetProgramLocalParameterfvARB
+#undef glGetProgramNamedParameterdvNV
+#undef glGetProgramNamedParameterfvNV
+#undef glGetProgramParameterdvNV
+#undef glGetProgramParameterfvNV
+#undef glGetProgramStringARB
+#undef glGetProgramStringNV
+#undef glGetProgramiv
+#undef glGetProgramivARB
+#undef glGetProgramivNV
+#undef glGetQueryObjecti64vEXT
+#undef glGetQueryObjectiv
+#undef glGetQueryObjectivARB
+#undef glGetQueryObjectui64vEXT
+#undef glGetQueryObjectuiv
+#undef glGetQueryObjectuivARB
+#undef glGetQueryiv
+#undef glGetQueryivARB
+#undef glGetRenderbufferParameterivEXT
+#undef glGetSeparableFilter
+#undef glGetSeparableFilterEXT
+#undef glGetShaderInfoLog
+#undef glGetShaderSource
+#undef glGetShaderSourceARB
+#undef glGetShaderiv
+#undef glGetSharpenTexFuncSGIS
+#undef glGetString
+#undef glGetTexBumpParameterfvATI
+#undef glGetTexBumpParameterivATI
+#undef glGetTexEnvfv
+#undef glGetTexEnviv
+#undef glGetTexFilterFuncSGIS
+#undef glGetTexGendv
+#undef glGetTexGenfv
+#undef glGetTexGeniv
+#undef glGetTexImage
+#undef glGetTexLevelParameterfv
+#undef glGetTexLevelParameteriv
+#undef glGetTexParameterIivEXT
+#undef glGetTexParameterIuivEXT
+#undef glGetTexParameterPointervAPPLE
+#undef glGetTexParameterfv
+#undef glGetTexParameteriv
+#undef glGetTrackMatrixivNV
+#undef glGetTransformFeedbackVaryingNV
+#undef glGetUniformBufferSizeEXT
+#undef glGetUniformLocation
+#undef glGetUniformLocationARB
+#undef glGetUniformOffsetEXT
+#undef glGetUniformfv
+#undef glGetUniformfvARB
+#undef glGetUniformiv
+#undef glGetUniformivARB
+#undef glGetUniformuivEXT
+#undef glGetVariantArrayObjectfvATI
+#undef glGetVariantArrayObjectivATI
+#undef glGetVariantBooleanvEXT
+#undef glGetVariantFloatvEXT
+#undef glGetVariantIntegervEXT
+#undef glGetVariantPointervEXT
+#undef glGetVaryingLocationNV
+#undef glGetVertexAttribArrayObjectfvATI
+#undef glGetVertexAttribArrayObjectivATI
+#undef glGetVertexAttribIivEXT
+#undef glGetVertexAttribIuivEXT
+#undef glGetVertexAttribPointerv
+#undef glGetVertexAttribPointervARB
+#undef glGetVertexAttribPointervNV
+#undef glGetVertexAttribdv
+#undef glGetVertexAttribdvARB
+#undef glGetVertexAttribdvNV
+#undef glGetVertexAttribfv
+#undef glGetVertexAttribfvARB
+#undef glGetVertexAttribfvNV
+#undef glGetVertexAttribiv
+#undef glGetVertexAttribivARB
+#undef glGetVertexAttribivNV
+#undef glGlobalAlphaFactorbSUN
+#undef glGlobalAlphaFactordSUN
+#undef glGlobalAlphaFactorfSUN
+#undef glGlobalAlphaFactoriSUN
+#undef glGlobalAlphaFactorsSUN
+#undef glGlobalAlphaFactorubSUN
+#undef glGlobalAlphaFactoruiSUN
+#undef glGlobalAlphaFactorusSUN
+#undef glHint
+#undef glHistogram
+#undef glHistogramEXT
+#undef glImageTransformParameterfHP
+#undef glImageTransformParameterfvHP
+#undef glImageTransformParameteriHP
+#undef glImageTransformParameterivHP
+#undef glIndexFuncEXT
+#undef glIndexMask
+#undef glIndexMaterialEXT
+#undef glIndexPointer
+#undef glIndexPointerEXT
+#undef glIndexPointerListIBM
+#undef glIndexd
+#undef glIndexdv
+#undef glIndexf
+#undef glIndexfv
+#undef glIndexi
+#undef glIndexiv
+#undef glIndexs
+#undef glIndexsv
+#undef glIndexub
+#undef glIndexubv
+#undef glInitNames
+#undef glInsertComponentEXT
+#undef glInterleavedArrays
+#undef glIsAsyncMarkerSGIX
+#undef glIsBuffer
+#undef glIsBufferARB
+#undef glIsEnabled
+#undef glIsEnabledIndexedEXT
+#undef glIsFenceAPPLE
+#undef glIsFenceNV
+#undef glIsFramebufferEXT
+#undef glIsList
+#undef glIsObjectBufferATI
+#undef glIsOcclusionQueryNV
+#undef glIsProgram
+#undef glIsProgramARB
+#undef glIsProgramNV
+#undef glIsQuery
+#undef glIsQueryARB
+#undef glIsRenderbufferEXT
+#undef glIsShader
+#undef glIsTexture
+#undef glIsTextureEXT
+#undef glIsVariantEnabledEXT
+#undef glIsVertexArrayAPPLE
+#undef glLightEnviEXT
+#undef glLightModelf
+#undef glLightModelfv
+#undef glLightModeli
+#undef glLightModeliv
+#undef glLightf
+#undef glLightfv
+#undef glLighti
+#undef glLightiv
+#undef glLineStipple
+#undef glLineWidth
+#undef glLinkProgram
+#undef glLinkProgramARB
+#undef glListBase
+#undef glLoadIdentity
+#undef glLoadMatrixd
+#undef glLoadMatrixf
+#undef glLoadName
+#undef glLoadProgramNV
+#undef glLoadTransposeMatrixd
+#undef glLoadTransposeMatrixdARB
+#undef glLoadTransposeMatrixf
+#undef glLoadTransposeMatrixfARB
+#undef glLockArraysEXT
+#undef glLogicOp
+#undef glMap1d
+#undef glMap1f
+#undef glMap2d
+#undef glMap2f
+#undef glMapBuffer
+#undef glMapBufferARB
+#undef glMapControlPointsNV
+#undef glMapGrid1d
+#undef glMapGrid1f
+#undef glMapGrid2d
+#undef glMapGrid2f
+#undef glMapObjectBufferATI
+#undef glMapParameterfvNV
+#undef glMapParameterivNV
+#undef glMaterialf
+#undef glMaterialfv
+#undef glMateriali
+#undef glMaterialiv
+#undef glMatrixIndexPointerARB
+#undef glMatrixIndexubvARB
+#undef glMatrixIndexuivARB
+#undef glMatrixIndexusvARB
+#undef glMatrixMode
+#undef glMinmax
+#undef glMinmaxEXT
+#undef glMultMatrixd
+#undef glMultMatrixf
+#undef glMultTransposeMatrixd
+#undef glMultTransposeMatrixdARB
+#undef glMultTransposeMatrixf
+#undef glMultTransposeMatrixfARB
+#undef glMultiDrawArrays
+#undef glMultiDrawArraysEXT
+#undef glMultiDrawElementArrayAPPLE
+#undef glMultiDrawElements
+#undef glMultiDrawElementsEXT
+#undef glMultiDrawRangeElementArrayAPPLE
+#undef glMultiModeDrawArraysIBM
+#undef glMultiModeDrawElementsIBM
+#undef glMultiTexCoord1d
+#undef glMultiTexCoord1dARB
+#undef glMultiTexCoord1dv
+#undef glMultiTexCoord1dvARB
+#undef glMultiTexCoord1f
+#undef glMultiTexCoord1fARB
+#undef glMultiTexCoord1fv
+#undef glMultiTexCoord1fvARB
+#undef glMultiTexCoord1hNV
+#undef glMultiTexCoord1hvNV
+#undef glMultiTexCoord1i
+#undef glMultiTexCoord1iARB
+#undef glMultiTexCoord1iv
+#undef glMultiTexCoord1ivARB
+#undef glMultiTexCoord1s
+#undef glMultiTexCoord1sARB
+#undef glMultiTexCoord1sv
+#undef glMultiTexCoord1svARB
+#undef glMultiTexCoord2d
+#undef glMultiTexCoord2dARB
+#undef glMultiTexCoord2dv
+#undef glMultiTexCoord2dvARB
+#undef glMultiTexCoord2f
+#undef glMultiTexCoord2fARB
+#undef glMultiTexCoord2fv
+#undef glMultiTexCoord2fvARB
+#undef glMultiTexCoord2hNV
+#undef glMultiTexCoord2hvNV
+#undef glMultiTexCoord2i
+#undef glMultiTexCoord2iARB
+#undef glMultiTexCoord2iv
+#undef glMultiTexCoord2ivARB
+#undef glMultiTexCoord2s
+#undef glMultiTexCoord2sARB
+#undef glMultiTexCoord2sv
+#undef glMultiTexCoord2svARB
+#undef glMultiTexCoord3d
+#undef glMultiTexCoord3dARB
+#undef glMultiTexCoord3dv
+#undef glMultiTexCoord3dvARB
+#undef glMultiTexCoord3f
+#undef glMultiTexCoord3fARB
+#undef glMultiTexCoord3fv
+#undef glMultiTexCoord3fvARB
+#undef glMultiTexCoord3hNV
+#undef glMultiTexCoord3hvNV
+#undef glMultiTexCoord3i
+#undef glMultiTexCoord3iARB
+#undef glMultiTexCoord3iv
+#undef glMultiTexCoord3ivARB
+#undef glMultiTexCoord3s
+#undef glMultiTexCoord3sARB
+#undef glMultiTexCoord3sv
+#undef glMultiTexCoord3svARB
+#undef glMultiTexCoord4d
+#undef glMultiTexCoord4dARB
+#undef glMultiTexCoord4dv
+#undef glMultiTexCoord4dvARB
+#undef glMultiTexCoord4f
+#undef glMultiTexCoord4fARB
+#undef glMultiTexCoord4fv
+#undef glMultiTexCoord4fvARB
+#undef glMultiTexCoord4hNV
+#undef glMultiTexCoord4hvNV
+#undef glMultiTexCoord4i
+#undef glMultiTexCoord4iARB
+#undef glMultiTexCoord4iv
+#undef glMultiTexCoord4ivARB
+#undef glMultiTexCoord4s
+#undef glMultiTexCoord4sARB
+#undef glMultiTexCoord4sv
+#undef glMultiTexCoord4svARB
+#undef glNewBufferRegionEXT
+#undef glNewList
+#undef glNewObjectBufferATI
+#undef glNormal3b
+#undef glNormal3bv
+#undef glNormal3d
+#undef glNormal3dv
+#undef glNormal3f
+#undef glNormal3fVertex3fSUN
+#undef glNormal3fVertex3fvSUN
+#undef glNormal3fv
+#undef glNormal3hNV
+#undef glNormal3hvNV
+#undef glNormal3i
+#undef glNormal3iv
+#undef glNormal3s
+#undef glNormal3sv
+#undef glNormalPointer
+#undef glNormalPointerEXT
+#undef glNormalPointerListIBM
+#undef glNormalPointervINTEL
+#undef glNormalStream3bATI
+#undef glNormalStream3bvATI
+#undef glNormalStream3dATI
+#undef glNormalStream3dvATI
+#undef glNormalStream3fATI
+#undef glNormalStream3fvATI
+#undef glNormalStream3iATI
+#undef glNormalStream3ivATI
+#undef glNormalStream3sATI
+#undef glNormalStream3svATI
+#undef glOrtho
+#undef glOrthofOES
+#undef glPNTrianglesfATI
+#undef glPNTrianglesiATI
+#undef glPassTexCoordATI
+#undef glPassThrough
+#undef glPixelDataRangeNV
+#undef glPixelMapfv
+#undef glPixelMapuiv
+#undef glPixelMapusv
+#undef glPixelStoref
+#undef glPixelStorei
+#undef glPixelTexGenSGIX
+#undef glPixelTransferf
+#undef glPixelTransferi
+#undef glPixelTransformParameterfEXT
+#undef glPixelTransformParameterfvEXT
+#undef glPixelTransformParameteriEXT
+#undef glPixelTransformParameterivEXT
+#undef glPixelZoom
+#undef glPointParameterf
+#undef glPointParameterfARB
+#undef glPointParameterfEXT
+#undef glPointParameterfv
+#undef glPointParameterfvARB
+#undef glPointParameterfvEXT
+#undef glPointParameteriNV
+#undef glPointParameterivNV
+#undef glPointSize
+#undef glPollAsyncSGIX
+#undef glPolygonMode
+#undef glPolygonOffset
+#undef glPolygonOffsetEXT
+#undef glPolygonStipple
+#undef glPopAttrib
+#undef glPopClientAttrib
+#undef glPopMatrix
+#undef glPopName
+#undef glPrimitiveRestartIndexNV
+#undef glPrimitiveRestartNV
+#undef glPrioritizeTextures
+#undef glPrioritizeTexturesEXT
+#undef glProgramBufferParametersIivNV
+#undef glProgramBufferParametersIuivNV
+#undef glProgramBufferParametersfvNV
+#undef glProgramEnvParameter4dARB
+#undef glProgramEnvParameter4dvARB
+#undef glProgramEnvParameter4fARB
+#undef glProgramEnvParameter4fvARB
+#undef glProgramEnvParameterI4iNV
+#undef glProgramEnvParameterI4ivNV
+#undef glProgramEnvParameterI4uiNV
+#undef glProgramEnvParameterI4uivNV
+#undef glProgramEnvParameters4fvEXT
+#undef glProgramEnvParametersI4ivNV
+#undef glProgramEnvParametersI4uivNV
+#undef glProgramLocalParameter4dARB
+#undef glProgramLocalParameter4dvARB
+#undef glProgramLocalParameter4fARB
+#undef glProgramLocalParameter4fvARB
+#undef glProgramLocalParameterI4iNV
+#undef glProgramLocalParameterI4ivNV
+#undef glProgramLocalParameterI4uiNV
+#undef glProgramLocalParameterI4uivNV
+#undef glProgramLocalParameters4fvEXT
+#undef glProgramLocalParametersI4ivNV
+#undef glProgramLocalParametersI4uivNV
+#undef glProgramNamedParameter4dNV
+#undef glProgramNamedParameter4dvNV
+#undef glProgramNamedParameter4fNV
+#undef glProgramNamedParameter4fvNV
+#undef glProgramParameter4dNV
+#undef glProgramParameter4dvNV
+#undef glProgramParameter4fNV
+#undef glProgramParameter4fvNV
+#undef glProgramParameteriEXT
+#undef glProgramParameters4dvNV
+#undef glProgramParameters4fvNV
+#undef glProgramStringARB
+#undef glProgramVertexLimitNV
+#undef glPushAttrib
+#undef glPushClientAttrib
+#undef glPushMatrix
+#undef glPushName
+#undef glRasterPos2d
+#undef glRasterPos2dv
+#undef glRasterPos2f
+#undef glRasterPos2fv
+#undef glRasterPos2i
+#undef glRasterPos2iv
+#undef glRasterPos2s
+#undef glRasterPos2sv
+#undef glRasterPos3d
+#undef glRasterPos3dv
+#undef glRasterPos3f
+#undef glRasterPos3fv
+#undef glRasterPos3i
+#undef glRasterPos3iv
+#undef glRasterPos3s
+#undef glRasterPos3sv
+#undef glRasterPos4d
+#undef glRasterPos4dv
+#undef glRasterPos4f
+#undef glRasterPos4fv
+#undef glRasterPos4i
+#undef glRasterPos4iv
+#undef glRasterPos4s
+#undef glRasterPos4sv
+#undef glReadBuffer
+#undef glReadBufferRegionEXT
+#undef glReadPixels
+#undef glReadVideoPixelsSUN
+#undef glRectd
+#undef glRectdv
+#undef glRectf
+#undef glRectfv
+#undef glRecti
+#undef glRectiv
+#undef glRects
+#undef glRectsv
+#undef glReferencePlaneSGIX
+#undef glRenderMode
+#undef glRenderbufferStorageEXT
+#undef glRenderbufferStorageMultisampleCoverageNV
+#undef glRenderbufferStorageMultisampleEXT
+#undef glReplacementCodePointerSUN
+#undef glReplacementCodeubSUN
+#undef glReplacementCodeubvSUN
+#undef glReplacementCodeuiColor3fVertex3fSUN
+#undef glReplacementCodeuiColor3fVertex3fvSUN
+#undef glReplacementCodeuiColor4fNormal3fVertex3fSUN
+#undef glReplacementCodeuiColor4fNormal3fVertex3fvSUN
+#undef glReplacementCodeuiColor4ubVertex3fSUN
+#undef glReplacementCodeuiColor4ubVertex3fvSUN
+#undef glReplacementCodeuiNormal3fVertex3fSUN
+#undef glReplacementCodeuiNormal3fVertex3fvSUN
+#undef glReplacementCodeuiSUN
+#undef glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN
+#undef glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN
+#undef glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN
+#undef glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN
+#undef glReplacementCodeuiTexCoord2fVertex3fSUN
+#undef glReplacementCodeuiTexCoord2fVertex3fvSUN
+#undef glReplacementCodeuiVertex3fSUN
+#undef glReplacementCodeuiVertex3fvSUN
+#undef glReplacementCodeuivSUN
+#undef glReplacementCodeusSUN
+#undef glReplacementCodeusvSUN
+#undef glRequestResidentProgramsNV
+#undef glResetHistogram
+#undef glResetHistogramEXT
+#undef glResetMinmax
+#undef glResetMinmaxEXT
+#undef glResizeBuffersMESA
+#undef glRotated
+#undef glRotatef
+#undef glSampleCoverage
+#undef glSampleCoverageARB
+#undef glSampleMapATI
+#undef glSampleMaskEXT
+#undef glSampleMaskSGIS
+#undef glSamplePatternEXT
+#undef glSamplePatternSGIS
+#undef glScaled
+#undef glScalef
+#undef glScissor
+#undef glSecondaryColor3b
+#undef glSecondaryColor3bEXT
+#undef glSecondaryColor3bv
+#undef glSecondaryColor3bvEXT
+#undef glSecondaryColor3d
+#undef glSecondaryColor3dEXT
+#undef glSecondaryColor3dv
+#undef glSecondaryColor3dvEXT
+#undef glSecondaryColor3f
+#undef glSecondaryColor3fEXT
+#undef glSecondaryColor3fv
+#undef glSecondaryColor3fvEXT
+#undef glSecondaryColor3hNV
+#undef glSecondaryColor3hvNV
+#undef glSecondaryColor3i
+#undef glSecondaryColor3iEXT
+#undef glSecondaryColor3iv
+#undef glSecondaryColor3ivEXT
+#undef glSecondaryColor3s
+#undef glSecondaryColor3sEXT
+#undef glSecondaryColor3sv
+#undef glSecondaryColor3svEXT
+#undef glSecondaryColor3ub
+#undef glSecondaryColor3ubEXT
+#undef glSecondaryColor3ubv
+#undef glSecondaryColor3ubvEXT
+#undef glSecondaryColor3ui
+#undef glSecondaryColor3uiEXT
+#undef glSecondaryColor3uiv
+#undef glSecondaryColor3uivEXT
+#undef glSecondaryColor3us
+#undef glSecondaryColor3usEXT
+#undef glSecondaryColor3usv
+#undef glSecondaryColor3usvEXT
+#undef glSecondaryColorPointer
+#undef glSecondaryColorPointerEXT
+#undef glSecondaryColorPointerListIBM
+#undef glSelectBuffer
+#undef glSeparableFilter2D
+#undef glSeparableFilter2DEXT
+#undef glSetFenceAPPLE
+#undef glSetFenceNV
+#undef glSetFragmentShaderConstantATI
+#undef glSetInvariantEXT
+#undef glSetLocalConstantEXT
+#undef glShadeModel
+#undef glShaderOp1EXT
+#undef glShaderOp2EXT
+#undef glShaderOp3EXT
+#undef glShaderSource
+#undef glShaderSourceARB
+#undef glSharpenTexFuncSGIS
+#undef glSpriteParameterfSGIX
+#undef glSpriteParameterfvSGIX
+#undef glSpriteParameteriSGIX
+#undef glSpriteParameterivSGIX
+#undef glStencilFunc
+#undef glStencilFuncSeparate
+#undef glStencilFuncSeparateATI
+#undef glStencilMask
+#undef glStencilMaskSeparate
+#undef glStencilOp
+#undef glStencilOpSeparate
+#undef glStencilOpSeparateATI
+#undef glStringMarkerGREMEDY
+#undef glSwizzleEXT
+#undef glTagSampleBufferSGIX
+#undef glTangentPointerEXT
+#undef glTbufferMask3DFX
+#undef glTestFenceAPPLE
+#undef glTestFenceNV
+#undef glTestObjectAPPLE
+#undef glTexBufferEXT
+#undef glTexBumpParameterfvATI
+#undef glTexBumpParameterivATI
+#undef glTexCoord1d
+#undef glTexCoord1dv
+#undef glTexCoord1f
+#undef glTexCoord1fv
+#undef glTexCoord1hNV
+#undef glTexCoord1hvNV
+#undef glTexCoord1i
+#undef glTexCoord1iv
+#undef glTexCoord1s
+#undef glTexCoord1sv
+#undef glTexCoord2d
+#undef glTexCoord2dv
+#undef glTexCoord2f
+#undef glTexCoord2fColor3fVertex3fSUN
+#undef glTexCoord2fColor3fVertex3fvSUN
+#undef glTexCoord2fColor4fNormal3fVertex3fSUN
+#undef glTexCoord2fColor4fNormal3fVertex3fvSUN
+#undef glTexCoord2fColor4ubVertex3fSUN
+#undef glTexCoord2fColor4ubVertex3fvSUN
+#undef glTexCoord2fNormal3fVertex3fSUN
+#undef glTexCoord2fNormal3fVertex3fvSUN
+#undef glTexCoord2fVertex3fSUN
+#undef glTexCoord2fVertex3fvSUN
+#undef glTexCoord2fv
+#undef glTexCoord2hNV
+#undef glTexCoord2hvNV
+#undef glTexCoord2i
+#undef glTexCoord2iv
+#undef glTexCoord2s
+#undef glTexCoord2sv
+#undef glTexCoord3d
+#undef glTexCoord3dv
+#undef glTexCoord3f
+#undef glTexCoord3fv
+#undef glTexCoord3hNV
+#undef glTexCoord3hvNV
+#undef glTexCoord3i
+#undef glTexCoord3iv
+#undef glTexCoord3s
+#undef glTexCoord3sv
+#undef glTexCoord4d
+#undef glTexCoord4dv
+#undef glTexCoord4f
+#undef glTexCoord4fColor4fNormal3fVertex4fSUN
+#undef glTexCoord4fColor4fNormal3fVertex4fvSUN
+#undef glTexCoord4fVertex4fSUN
+#undef glTexCoord4fVertex4fvSUN
+#undef glTexCoord4fv
+#undef glTexCoord4hNV
+#undef glTexCoord4hvNV
+#undef glTexCoord4i
+#undef glTexCoord4iv
+#undef glTexCoord4s
+#undef glTexCoord4sv
+#undef glTexCoordPointer
+#undef glTexCoordPointerEXT
+#undef glTexCoordPointerListIBM
+#undef glTexCoordPointervINTEL
+#undef glTexEnvf
+#undef glTexEnvfv
+#undef glTexEnvi
+#undef glTexEnviv
+#undef glTexFilterFuncSGIS
+#undef glTexGend
+#undef glTexGendv
+#undef glTexGenf
+#undef glTexGenfv
+#undef glTexGeni
+#undef glTexGeniv
+#undef glTexImage1D
+#undef glTexImage2D
+#undef glTexImage3D
+#undef glTexImage3DEXT
+#undef glTexImage4DSGIS
+#undef glTexParameterIivEXT
+#undef glTexParameterIuivEXT
+#undef glTexParameterf
+#undef glTexParameterfv
+#undef glTexParameteri
+#undef glTexParameteriv
+#undef glTexScissorFuncINTEL
+#undef glTexScissorINTEL
+#undef glTexSubImage1D
+#undef glTexSubImage1DEXT
+#undef glTexSubImage2D
+#undef glTexSubImage2DEXT
+#undef glTexSubImage3D
+#undef glTexSubImage3DEXT
+#undef glTexSubImage4DSGIS
+#undef glTextureFogSGIX
+#undef glTextureLightEXT
+#undef glTextureMaterialEXT
+#undef glTextureNormalEXT
+#undef glTextureRangeAPPLE
+#undef glTrackMatrixNV
+#undef glTransformFeedbackAttribsNV
+#undef glTransformFeedbackVaryingsNV
+#undef glTranslated
+#undef glTranslatef
+#undef glUniform1f
+#undef glUniform1fARB
+#undef glUniform1fv
+#undef glUniform1fvARB
+#undef glUniform1i
+#undef glUniform1iARB
+#undef glUniform1iv
+#undef glUniform1ivARB
+#undef glUniform1uiEXT
+#undef glUniform1uivEXT
+#undef glUniform2f
+#undef glUniform2fARB
+#undef glUniform2fv
+#undef glUniform2fvARB
+#undef glUniform2i
+#undef glUniform2iARB
+#undef glUniform2iv
+#undef glUniform2ivARB
+#undef glUniform2uiEXT
+#undef glUniform2uivEXT
+#undef glUniform3f
+#undef glUniform3fARB
+#undef glUniform3fv
+#undef glUniform3fvARB
+#undef glUniform3i
+#undef glUniform3iARB
+#undef glUniform3iv
+#undef glUniform3ivARB
+#undef glUniform3uiEXT
+#undef glUniform3uivEXT
+#undef glUniform4f
+#undef glUniform4fARB
+#undef glUniform4fv
+#undef glUniform4fvARB
+#undef glUniform4i
+#undef glUniform4iARB
+#undef glUniform4iv
+#undef glUniform4ivARB
+#undef glUniform4uiEXT
+#undef glUniform4uivEXT
+#undef glUniformBufferEXT
+#undef glUniformMatrix2fv
+#undef glUniformMatrix2fvARB
+#undef glUniformMatrix2x3fv
+#undef glUniformMatrix2x4fv
+#undef glUniformMatrix3fv
+#undef glUniformMatrix3fvARB
+#undef glUniformMatrix3x2fv
+#undef glUniformMatrix3x4fv
+#undef glUniformMatrix4fv
+#undef glUniformMatrix4fvARB
+#undef glUniformMatrix4x2fv
+#undef glUniformMatrix4x3fv
+#undef glUnlockArraysEXT
+#undef glUnmapBuffer
+#undef glUnmapBufferARB
+#undef glUnmapObjectBufferATI
+#undef glUpdateObjectBufferATI
+#undef glUseProgram
+#undef glUseProgramObjectARB
+#undef glValidateProgram
+#undef glValidateProgramARB
+#undef glVariantArrayObjectATI
+#undef glVariantPointerEXT
+#undef glVariantbvEXT
+#undef glVariantdvEXT
+#undef glVariantfvEXT
+#undef glVariantivEXT
+#undef glVariantsvEXT
+#undef glVariantubvEXT
+#undef glVariantuivEXT
+#undef glVariantusvEXT
+#undef glVertex2d
+#undef glVertex2dv
+#undef glVertex2f
+#undef glVertex2fv
+#undef glVertex2hNV
+#undef glVertex2hvNV
+#undef glVertex2i
+#undef glVertex2iv
+#undef glVertex2s
+#undef glVertex2sv
+#undef glVertex3d
+#undef glVertex3dv
+#undef glVertex3f
+#undef glVertex3fv
+#undef glVertex3hNV
+#undef glVertex3hvNV
+#undef glVertex3i
+#undef glVertex3iv
+#undef glVertex3s
+#undef glVertex3sv
+#undef glVertex4d
+#undef glVertex4dv
+#undef glVertex4f
+#undef glVertex4fv
+#undef glVertex4hNV
+#undef glVertex4hvNV
+#undef glVertex4i
+#undef glVertex4iv
+#undef glVertex4s
+#undef glVertex4sv
+#undef glVertexArrayParameteriAPPLE
+#undef glVertexArrayRangeAPPLE
+#undef glVertexArrayRangeNV
+#undef glVertexAttrib1d
+#undef glVertexAttrib1dARB
+#undef glVertexAttrib1dNV
+#undef glVertexAttrib1dv
+#undef glVertexAttrib1dvARB
+#undef glVertexAttrib1dvNV
+#undef glVertexAttrib1f
+#undef glVertexAttrib1fARB
+#undef glVertexAttrib1fNV
+#undef glVertexAttrib1fv
+#undef glVertexAttrib1fvARB
+#undef glVertexAttrib1fvNV
+#undef glVertexAttrib1hNV
+#undef glVertexAttrib1hvNV
+#undef glVertexAttrib1s
+#undef glVertexAttrib1sARB
+#undef glVertexAttrib1sNV
+#undef glVertexAttrib1sv
+#undef glVertexAttrib1svARB
+#undef glVertexAttrib1svNV
+#undef glVertexAttrib2d
+#undef glVertexAttrib2dARB
+#undef glVertexAttrib2dNV
+#undef glVertexAttrib2dv
+#undef glVertexAttrib2dvARB
+#undef glVertexAttrib2dvNV
+#undef glVertexAttrib2f
+#undef glVertexAttrib2fARB
+#undef glVertexAttrib2fNV
+#undef glVertexAttrib2fv
+#undef glVertexAttrib2fvARB
+#undef glVertexAttrib2fvNV
+#undef glVertexAttrib2hNV
+#undef glVertexAttrib2hvNV
+#undef glVertexAttrib2s
+#undef glVertexAttrib2sARB
+#undef glVertexAttrib2sNV
+#undef glVertexAttrib2sv
+#undef glVertexAttrib2svARB
+#undef glVertexAttrib2svNV
+#undef glVertexAttrib3d
+#undef glVertexAttrib3dARB
+#undef glVertexAttrib3dNV
+#undef glVertexAttrib3dv
+#undef glVertexAttrib3dvARB
+#undef glVertexAttrib3dvNV
+#undef glVertexAttrib3f
+#undef glVertexAttrib3fARB
+#undef glVertexAttrib3fNV
+#undef glVertexAttrib3fv
+#undef glVertexAttrib3fvARB
+#undef glVertexAttrib3fvNV
+#undef glVertexAttrib3hNV
+#undef glVertexAttrib3hvNV
+#undef glVertexAttrib3s
+#undef glVertexAttrib3sARB
+#undef glVertexAttrib3sNV
+#undef glVertexAttrib3sv
+#undef glVertexAttrib3svARB
+#undef glVertexAttrib3svNV
+#undef glVertexAttrib4Nbv
+#undef glVertexAttrib4NbvARB
+#undef glVertexAttrib4Niv
+#undef glVertexAttrib4NivARB
+#undef glVertexAttrib4Nsv
+#undef glVertexAttrib4NsvARB
+#undef glVertexAttrib4Nub
+#undef glVertexAttrib4NubARB
+#undef glVertexAttrib4Nubv
+#undef glVertexAttrib4NubvARB
+#undef glVertexAttrib4Nuiv
+#undef glVertexAttrib4NuivARB
+#undef glVertexAttrib4Nusv
+#undef glVertexAttrib4NusvARB
+#undef glVertexAttrib4bv
+#undef glVertexAttrib4bvARB
+#undef glVertexAttrib4d
+#undef glVertexAttrib4dARB
+#undef glVertexAttrib4dNV
+#undef glVertexAttrib4dv
+#undef glVertexAttrib4dvARB
+#undef glVertexAttrib4dvNV
+#undef glVertexAttrib4f
+#undef glVertexAttrib4fARB
+#undef glVertexAttrib4fNV
+#undef glVertexAttrib4fv
+#undef glVertexAttrib4fvARB
+#undef glVertexAttrib4fvNV
+#undef glVertexAttrib4hNV
+#undef glVertexAttrib4hvNV
+#undef glVertexAttrib4iv
+#undef glVertexAttrib4ivARB
+#undef glVertexAttrib4s
+#undef glVertexAttrib4sARB
+#undef glVertexAttrib4sNV
+#undef glVertexAttrib4sv
+#undef glVertexAttrib4svARB
+#undef glVertexAttrib4svNV
+#undef glVertexAttrib4ubNV
+#undef glVertexAttrib4ubv
+#undef glVertexAttrib4ubvARB
+#undef glVertexAttrib4ubvNV
+#undef glVertexAttrib4uiv
+#undef glVertexAttrib4uivARB
+#undef glVertexAttrib4usv
+#undef glVertexAttrib4usvARB
+#undef glVertexAttribArrayObjectATI
+#undef glVertexAttribI1iEXT
+#undef glVertexAttribI1ivEXT
+#undef glVertexAttribI1uiEXT
+#undef glVertexAttribI1uivEXT
+#undef glVertexAttribI2iEXT
+#undef glVertexAttribI2ivEXT
+#undef glVertexAttribI2uiEXT
+#undef glVertexAttribI2uivEXT
+#undef glVertexAttribI3iEXT
+#undef glVertexAttribI3ivEXT
+#undef glVertexAttribI3uiEXT
+#undef glVertexAttribI3uivEXT
+#undef glVertexAttribI4bvEXT
+#undef glVertexAttribI4iEXT
+#undef glVertexAttribI4ivEXT
+#undef glVertexAttribI4svEXT
+#undef glVertexAttribI4ubvEXT
+#undef glVertexAttribI4uiEXT
+#undef glVertexAttribI4uivEXT
+#undef glVertexAttribI4usvEXT
+#undef glVertexAttribIPointerEXT
+#undef glVertexAttribPointer
+#undef glVertexAttribPointerARB
+#undef glVertexAttribPointerNV
+#undef glVertexAttribs1dvNV
+#undef glVertexAttribs1fvNV
+#undef glVertexAttribs1hvNV
+#undef glVertexAttribs1svNV
+#undef glVertexAttribs2dvNV
+#undef glVertexAttribs2fvNV
+#undef glVertexAttribs2hvNV
+#undef glVertexAttribs2svNV
+#undef glVertexAttribs3dvNV
+#undef glVertexAttribs3fvNV
+#undef glVertexAttribs3hvNV
+#undef glVertexAttribs3svNV
+#undef glVertexAttribs4dvNV
+#undef glVertexAttribs4fvNV
+#undef glVertexAttribs4hvNV
+#undef glVertexAttribs4svNV
+#undef glVertexAttribs4ubvNV
+#undef glVertexBlendARB
+#undef glVertexBlendEnvfATI
+#undef glVertexBlendEnviATI
+#undef glVertexPointer
+#undef glVertexPointerEXT
+#undef glVertexPointerListIBM
+#undef glVertexPointervINTEL
+#undef glVertexStream2dATI
+#undef glVertexStream2dvATI
+#undef glVertexStream2fATI
+#undef glVertexStream2fvATI
+#undef glVertexStream2iATI
+#undef glVertexStream2ivATI
+#undef glVertexStream2sATI
+#undef glVertexStream2svATI
+#undef glVertexStream3dATI
+#undef glVertexStream3dvATI
+#undef glVertexStream3fATI
+#undef glVertexStream3fvATI
+#undef glVertexStream3iATI
+#undef glVertexStream3ivATI
+#undef glVertexStream3sATI
+#undef glVertexStream3svATI
+#undef glVertexStream4dATI
+#undef glVertexStream4dvATI
+#undef glVertexStream4fATI
+#undef glVertexStream4fvATI
+#undef glVertexStream4iATI
+#undef glVertexStream4ivATI
+#undef glVertexStream4sATI
+#undef glVertexStream4svATI
+#undef glVertexWeightPointerEXT
+#undef glVertexWeightfEXT
+#undef glVertexWeightfvEXT
+#undef glVertexWeighthNV
+#undef glVertexWeighthvNV
+#undef glViewport
+#undef glWeightPointerARB
+#undef glWeightbvARB
+#undef glWeightdvARB
+#undef glWeightfvARB
+#undef glWeightivARB
+#undef glWeightsvARB
+#undef glWeightubvARB
+#undef glWeightuivARB
+#undef glWeightusvARB
+#undef glWindowPos2d
+#undef glWindowPos2dARB
+#undef glWindowPos2dMESA
+#undef glWindowPos2dv
+#undef glWindowPos2dvARB
+#undef glWindowPos2dvMESA
+#undef glWindowPos2f
+#undef glWindowPos2fARB
+#undef glWindowPos2fMESA
+#undef glWindowPos2fv
+#undef glWindowPos2fvARB
+#undef glWindowPos2fvMESA
+#undef glWindowPos2i
+#undef glWindowPos2iARB
+#undef glWindowPos2iMESA
+#undef glWindowPos2iv
+#undef glWindowPos2ivARB
+#undef glWindowPos2ivMESA
+#undef glWindowPos2s
+#undef glWindowPos2sARB
+#undef glWindowPos2sMESA
+#undef glWindowPos2sv
+#undef glWindowPos2svARB
+#undef glWindowPos2svMESA
+#undef glWindowPos3d
+#undef glWindowPos3dARB
+#undef glWindowPos3dMESA
+#undef glWindowPos3dv
+#undef glWindowPos3dvARB
+#undef glWindowPos3dvMESA
+#undef glWindowPos3f
+#undef glWindowPos3fARB
+#undef glWindowPos3fMESA
+#undef glWindowPos3fv
+#undef glWindowPos3fvARB
+#undef glWindowPos3fvMESA
+#undef glWindowPos3i
+#undef glWindowPos3iARB
+#undef glWindowPos3iMESA
+#undef glWindowPos3iv
+#undef glWindowPos3ivARB
+#undef glWindowPos3ivMESA
+#undef glWindowPos3s
+#undef glWindowPos3sARB
+#undef glWindowPos3sMESA
+#undef glWindowPos3sv
+#undef glWindowPos3svARB
+#undef glWindowPos3svMESA
+#undef glWindowPos4dMESA
+#undef glWindowPos4dvMESA
+#undef glWindowPos4fMESA
+#undef glWindowPos4fvMESA
+#undef glWindowPos4iMESA
+#undef glWindowPos4ivMESA
+#undef glWindowPos4sMESA
+#undef glWindowPos4svMESA
+#undef glWriteMaskEXT
+
+#undef gluBeginCurve
+#undef gluBeginPolygon
+#undef gluBeginSurface
+#undef gluBeginTrim
+#undef gluBuild1DMipmaps
+#undef gluBuild2DMipmaps
+#undef gluCylinder
+#undef gluDeleteNurbsRenderer
+#undef gluDeleteQuadric
+#undef gluDeleteTess
+#undef gluDisk
+#undef gluEndCurve
+#undef gluEndPolygon
+#undef gluEndSurface
+#undef gluEndTrim
+#undef gluErrorString
+#undef gluErrorStringWIN
+#undef gluErrorUnicodeStringEXT
+#undef gluGetNurbsProperty
+#undef gluGetString
+#undef gluGetTessProperty
+#undef gluLoadSamplingMatrices
+#undef gluLookAt
+#undef gluNewNurbsRenderer
+#undef gluNewQuadric
+#undef gluNewTess
+#undef gluNextContour
+#undef gluNurbsCallback
+#undef gluNurbsCurve
+#undef gluNurbsProperty
+#undef gluNurbsSurface
+#undef gluOrtho2D
+#undef gluPartialDisk
+#undef gluPerspective
+#undef gluPickMatrix
+#undef gluProject
+#undef gluPwlCurve
+#undef gluQuadricCallback
+#undef gluQuadricDrawStyle
+#undef gluQuadricNormals
+#undef gluQuadricOrientation
+#undef gluQuadricTexture
+#undef gluScaleImage
+#undef gluSphere
+#undef gluTessBeginContour
+#undef gluTessBeginPolygon
+#undef gluTessCallback
+#undef gluTessEndContour
+#undef gluTessEndPolygon
+#undef gluTessNormal
+#undef gluTessProperty
+#undef gluTessVertex
+#undef gluUnProject
+
+
+
+
+#define glAccum GML_FUNCTION_NOT_IMPLEMENTED
+#define glActiveStencilFaceEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glActiveTexture GML_FUNCTION_NOT_IMPLEMENTED
+#define glActiveTextureARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glActiveVaryingNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glAddSwapHintRectWIN GML_FUNCTION_NOT_IMPLEMENTED
+#define glAlphaFragmentOp1ATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glAlphaFragmentOp2ATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glAlphaFragmentOp3ATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glAlphaFunc GML_FUNCTION_NOT_IMPLEMENTED
+#define glApplyTextureEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glAreProgramsResidentNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glAreTexturesResident GML_FUNCTION_NOT_IMPLEMENTED
+#define glAreTexturesResidentEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glArrayElement GML_FUNCTION_NOT_IMPLEMENTED
+#define glArrayElementEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glArrayObjectATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glAsyncMarkerSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glAttachObjectARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glAttachShader GML_FUNCTION_NOT_IMPLEMENTED
+#define glBegin GML_FUNCTION_NOT_IMPLEMENTED
+#define glBeginFragmentShaderATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glBeginOcclusionQueryNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glBeginQuery GML_FUNCTION_NOT_IMPLEMENTED
+#define glBeginQueryARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glBeginSceneEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBeginTransformFeedbackNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glBeginVertexShaderEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindAttribLocation GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindAttribLocationARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindBuffer GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindBufferARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindBufferBaseNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindBufferOffsetNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindBufferRangeNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindFragDataLocationEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindFragmentShaderATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindFramebufferEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindLightParameterEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindMaterialParameterEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindParameterEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindProgramARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindProgramNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindRenderbufferEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindTexGenParameterEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindTexture GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindTextureEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindTextureUnitParameterEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindVertexArrayAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glBindVertexShaderEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBinormalPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBitmap GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendColor GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendColorEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendEquation GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendEquationEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendEquationSeparate GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendEquationSeparateEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendFunc GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendFuncSeparate GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlendFuncSeparateEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBlitFramebufferEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBufferData GML_FUNCTION_NOT_IMPLEMENTED
+#define glBufferDataARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glBufferRegionEnabledEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glBufferSubData GML_FUNCTION_NOT_IMPLEMENTED
+#define glBufferSubDataARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCallList GML_FUNCTION_NOT_IMPLEMENTED
+#define glCallLists GML_FUNCTION_NOT_IMPLEMENTED
+#define glCheckFramebufferStatusEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glClampColorARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glClear GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearAccum GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearColor GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearColorIiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearColorIuiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearDepth GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearDepthdNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearDepthfOES GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearIndex GML_FUNCTION_NOT_IMPLEMENTED
+#define glClearStencil GML_FUNCTION_NOT_IMPLEMENTED
+#define glClientActiveTexture GML_FUNCTION_NOT_IMPLEMENTED
+#define glClientActiveTextureARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glClientActiveVertexStreamATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glClipPlane GML_FUNCTION_NOT_IMPLEMENTED
+#define glClipPlanefOES GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3b GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3bv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3ub GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3ubv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3ui GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3uiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3us GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor3usv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4b GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4bv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4d GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4f GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4fNormal3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4fNormal3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4i GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4s GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4ub GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4ubVertex2fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4ubVertex2fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4ubVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4ubVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4ubv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4ui GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4uiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4us GML_FUNCTION_NOT_IMPLEMENTED
+#define glColor4usv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorFragmentOp1ATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorFragmentOp2ATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorFragmentOp3ATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorMask GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorMaskIndexedEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorMaterial GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorPointerListIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorPointervINTEL GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorSubTable GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorSubTableEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorTable GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorTableEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorTableParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorTableParameterfvSGI GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorTableParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorTableParameterivSGI GML_FUNCTION_NOT_IMPLEMENTED
+#define glColorTableSGI GML_FUNCTION_NOT_IMPLEMENTED
+#define glCombinerInputNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glCombinerOutputNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glCombinerParameterfNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glCombinerParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glCombinerParameteriNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glCombinerParameterivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glCombinerStageParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompileShader GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompileShaderARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexImage1D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexImage1DARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexImage2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexImage2DARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexImage3D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexImage3DARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexSubImage1D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexSubImage1DARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexSubImage2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexSubImage2DARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexSubImage3D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCompressedTexSubImage3DARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionFilter1D GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionFilter1DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionFilter2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionFilter2DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionParameterf GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionParameterfEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionParameteri GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionParameteriEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glConvolutionParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyColorSubTable GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyColorSubTableEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyColorTable GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyColorTableSGI GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyConvolutionFilter1D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyConvolutionFilter1DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyConvolutionFilter2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyConvolutionFilter2DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyPixels GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexImage1D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexImage1DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexImage2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexImage2DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexSubImage1D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexSubImage1DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexSubImage2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexSubImage2DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexSubImage3D GML_FUNCTION_NOT_IMPLEMENTED
+#define glCopyTexSubImage3DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCreateProgram GML_FUNCTION_NOT_IMPLEMENTED
+#define glCreateProgramObjectARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCreateShader GML_FUNCTION_NOT_IMPLEMENTED
+#define glCreateShaderObjectARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glCullFace GML_FUNCTION_NOT_IMPLEMENTED
+#define glCullParameterdvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCullParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glCurrentPaletteMatrixARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteAsyncMarkersSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteBufferRegionEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteBuffers GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteBuffersARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteFencesAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteFencesNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteFragmentShaderATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteFramebuffersEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteLists GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteObjectARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteOcclusionQueriesNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteProgram GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteProgramsARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteProgramsNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteQueries GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteQueriesARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteRenderbuffersEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteShader GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteTextures GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteTexturesEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteVertexArraysAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glDeleteVertexShaderEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDepthBoundsEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDepthBoundsdNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glDepthFunc GML_FUNCTION_NOT_IMPLEMENTED
+#define glDepthMask GML_FUNCTION_NOT_IMPLEMENTED
+#define glDepthRange GML_FUNCTION_NOT_IMPLEMENTED
+#define glDepthRangedNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glDepthRangefOES GML_FUNCTION_NOT_IMPLEMENTED
+#define glDetachObjectARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glDetachShader GML_FUNCTION_NOT_IMPLEMENTED
+#define glDetailTexFuncSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glDisable GML_FUNCTION_NOT_IMPLEMENTED
+#define glDisableClientState GML_FUNCTION_NOT_IMPLEMENTED
+#define glDisableIndexedEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDisableVariantClientStateEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDisableVertexAttribArray GML_FUNCTION_NOT_IMPLEMENTED
+#define glDisableVertexAttribArrayARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawArrays GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawArraysEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawArraysInstancedEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawBuffer GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawBufferRegionEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawBuffers GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawBuffersARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawBuffersATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawElementArrayAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawElementArrayATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawElements GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawElementsInstancedEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawPixels GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawRangeElementArrayAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawRangeElementArrayATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawRangeElements GML_FUNCTION_NOT_IMPLEMENTED
+#define glDrawRangeElementsEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glEdgeFlag GML_FUNCTION_NOT_IMPLEMENTED
+#define glEdgeFlagPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glEdgeFlagPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glEdgeFlagPointerListIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glEdgeFlagv GML_FUNCTION_NOT_IMPLEMENTED
+#define glElementPointerAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glElementPointerATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glEnable GML_FUNCTION_NOT_IMPLEMENTED
+#define glEnableClientState GML_FUNCTION_NOT_IMPLEMENTED
+#define glEnableIndexedEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glEnableVariantClientStateEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glEnableVertexAttribArray GML_FUNCTION_NOT_IMPLEMENTED
+#define glEnableVertexAttribArrayARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glEnd GML_FUNCTION_NOT_IMPLEMENTED
+#define glEndFragmentShaderATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glEndList GML_FUNCTION_NOT_IMPLEMENTED
+#define glEndOcclusionQueryNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glEndQuery GML_FUNCTION_NOT_IMPLEMENTED
+#define glEndQueryARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glEndSceneEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glEndTransformFeedbackNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glEndVertexShaderEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalCoord1d GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalCoord1dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalCoord1f GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalCoord1fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalCoord2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalCoord2dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalCoord2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalCoord2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalMapsNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalMesh1 GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalMesh2 GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalPoint1 GML_FUNCTION_NOT_IMPLEMENTED
+#define glEvalPoint2 GML_FUNCTION_NOT_IMPLEMENTED
+#define glExecuteProgramNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glExtractComponentEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFeedbackBuffer GML_FUNCTION_NOT_IMPLEMENTED
+#define glFinalCombinerInputNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glFinish GML_FUNCTION_NOT_IMPLEMENTED
+#define glFinishAsyncSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFinishFenceAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glFinishFenceNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glFinishObjectAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glFinishTextureSUNX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFlush GML_FUNCTION_NOT_IMPLEMENTED
+#define glFlushPixelDataRangeNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glFlushRasterSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFlushVertexArrayRangeAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glFlushVertexArrayRangeNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordPointerListIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordd GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoorddEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoorddv GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoorddvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordf GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordfEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordhNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogCoordhvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogFuncSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogf GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogi GML_FUNCTION_NOT_IMPLEMENTED
+#define glFogiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentColorMaterialEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentColorMaterialSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightModelfEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightModelfSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightModelfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightModelfvSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightModeliEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightModeliSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightModelivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightModelivSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightfEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightfSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightfvSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightiSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentLightivSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentMaterialfEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentMaterialfSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentMaterialfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentMaterialfvSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentMaterialiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentMaterialiSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentMaterialivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFragmentMaterialivSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFrameZoomSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glFramebufferRenderbufferEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFramebufferTexture1DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFramebufferTexture2DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFramebufferTexture3DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFramebufferTextureEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFramebufferTextureFaceEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFramebufferTextureLayerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glFreeObjectBufferATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glFrontFace GML_FUNCTION_NOT_IMPLEMENTED
+#define glFrustum GML_FUNCTION_NOT_IMPLEMENTED
+#define glFrustumfOES GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenAsyncMarkersSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenBuffers GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenBuffersARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenFencesAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenFencesNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenFragmentShadersATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenFramebuffersEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenLists GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenOcclusionQueriesNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenProgramsARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenProgramsNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenQueries GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenQueriesARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenRenderbuffersEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenSymbolsEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenTextures GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenTexturesEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenVertexArraysAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenVertexShadersEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGenerateMipmapEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetActiveAttrib GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetActiveAttribARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetActiveUniform GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetActiveUniformARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetActiveVaryingNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetArrayObjectfvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetArrayObjectivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetAttachedObjectsARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetAttachedShaders GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetAttribLocation GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetAttribLocationARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetBooleanIndexedvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetBooleanv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetBufferParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetBufferParameterivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetBufferPointerv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetBufferPointervARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetBufferSubData GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetBufferSubDataARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetClipPlane GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetClipPlanefOES GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTable GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTableEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTableParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTableParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTableParameterfvSGI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTableParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTableParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTableParameterivSGI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetColorTableSGI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetCombinerInputParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetCombinerInputParameterivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetCombinerOutputParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetCombinerOutputParameterivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetCombinerStageParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetCompressedTexImage GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetCompressedTexImageARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetConvolutionFilter GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetConvolutionFilterEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetConvolutionParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetConvolutionParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetConvolutionParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetConvolutionParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetDetailTexFuncSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetDoublev GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetError GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFenceivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFinalCombinerInputParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFinalCombinerInputParameterivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFloatv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFogFuncSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragDataLocationEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragmentLightfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragmentLightfvSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragmentLightivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragmentLightivSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragmentMaterialfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragmentMaterialfvSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragmentMaterialivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFragmentMaterialivSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetFramebufferAttachmentParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetHandleARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetHistogram GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetHistogramEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetHistogramParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetHistogramParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetHistogramParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetHistogramParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetImageTransformParameterfvHP GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetImageTransformParameterivHP GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetInfoLogARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetIntegerIndexedvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetIntegerv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetInvariantBooleanvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetInvariantFloatvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetInvariantIntegervEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetLightfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetLightiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetLocalConstantBooleanvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetLocalConstantFloatvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetLocalConstantIntegervEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMapAttribParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMapAttribParameterivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMapControlPointsNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMapParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMapParameterivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMapdv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMapfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMapiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMaterialfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMaterialiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMinmax GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMinmaxEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMinmaxParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMinmaxParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMinmaxParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetMinmaxParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetObjectBufferfvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetObjectBufferivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetObjectParameterfvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetObjectParameterivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetOcclusionQueryivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetOcclusionQueryuivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetPixelMapfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetPixelMapuiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetPixelMapusv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetPixelTransformParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetPixelTransformParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetPointerv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetPointervEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetPolygonStipple GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramEnvParameterdvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramEnvParameterfvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramInfoLog GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramLocalParameterdvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramLocalParameterfvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramNamedParameterdvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramNamedParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramParameterdvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramStringARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramStringNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetProgramivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetQueryObjecti64vEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetQueryObjectiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetQueryObjectivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetQueryObjectui64vEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetQueryObjectuiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetQueryObjectuivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetQueryiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetQueryivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetRenderbufferParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetSeparableFilter GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetSeparableFilterEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetShaderInfoLog GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetShaderSource GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetShaderSourceARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetShaderiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetSharpenTexFuncSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetString GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexBumpParameterfvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexBumpParameterivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexEnvfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexEnviv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexFilterFuncSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexGendv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexGenfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexGeniv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexImage GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexLevelParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexLevelParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexParameterIivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexParameterIuivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexParameterPointervAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTexParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTrackMatrixivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetTransformFeedbackVaryingNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformBufferSizeEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformLocation GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformLocationARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformOffsetEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformfvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetUniformuivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVariantArrayObjectfvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVariantArrayObjectivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVariantBooleanvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVariantFloatvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVariantIntegervEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVariantPointervEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVaryingLocationNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribArrayObjectfvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribArrayObjectivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribIivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribIuivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribPointerv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribPointervARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribPointervNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribdv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribdvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribdvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribfvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glGetVertexAttribivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glGlobalAlphaFactorbSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glGlobalAlphaFactordSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glGlobalAlphaFactorfSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glGlobalAlphaFactoriSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glGlobalAlphaFactorsSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glGlobalAlphaFactorubSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glGlobalAlphaFactoruiSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glGlobalAlphaFactorusSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glHint GML_FUNCTION_NOT_IMPLEMENTED
+#define glHistogram GML_FUNCTION_NOT_IMPLEMENTED
+#define glHistogramEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glImageTransformParameterfHP GML_FUNCTION_NOT_IMPLEMENTED
+#define glImageTransformParameterfvHP GML_FUNCTION_NOT_IMPLEMENTED
+#define glImageTransformParameteriHP GML_FUNCTION_NOT_IMPLEMENTED
+#define glImageTransformParameterivHP GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexFuncEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexMask GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexMaterialEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexPointerListIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexd GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexdv GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexf GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexi GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexs GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexsv GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexub GML_FUNCTION_NOT_IMPLEMENTED
+#define glIndexubv GML_FUNCTION_NOT_IMPLEMENTED
+#define glInitNames GML_FUNCTION_NOT_IMPLEMENTED
+#define glInsertComponentEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glInterleavedArrays GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsAsyncMarkerSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsBuffer GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsBufferARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsEnabled GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsEnabledIndexedEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsFenceAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsFenceNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsFramebufferEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsList GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsObjectBufferATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsOcclusionQueryNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsProgram GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsProgramARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsProgramNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsQuery GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsQueryARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsRenderbufferEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsShader GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsTexture GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsTextureEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsVariantEnabledEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glIsVertexArrayAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glLightEnviEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glLightModelf GML_FUNCTION_NOT_IMPLEMENTED
+#define glLightModelfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glLightModeli GML_FUNCTION_NOT_IMPLEMENTED
+#define glLightModeliv GML_FUNCTION_NOT_IMPLEMENTED
+#define glLightf GML_FUNCTION_NOT_IMPLEMENTED
+#define glLightfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glLighti GML_FUNCTION_NOT_IMPLEMENTED
+#define glLightiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glLineStipple GML_FUNCTION_NOT_IMPLEMENTED
+#define glLineWidth GML_FUNCTION_NOT_IMPLEMENTED
+#define glLinkProgram GML_FUNCTION_NOT_IMPLEMENTED
+#define glLinkProgramARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glListBase GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadIdentity GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadMatrixd GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadMatrixf GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadName GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadProgramNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadTransposeMatrixd GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadTransposeMatrixdARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadTransposeMatrixf GML_FUNCTION_NOT_IMPLEMENTED
+#define glLoadTransposeMatrixfARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glLockArraysEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glLogicOp GML_FUNCTION_NOT_IMPLEMENTED
+#define glMap1d GML_FUNCTION_NOT_IMPLEMENTED
+#define glMap1f GML_FUNCTION_NOT_IMPLEMENTED
+#define glMap2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glMap2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapBuffer GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapBufferARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapControlPointsNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapGrid1d GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapGrid1f GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapGrid2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapGrid2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapObjectBufferATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapParameterfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMapParameterivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMaterialf GML_FUNCTION_NOT_IMPLEMENTED
+#define glMaterialfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMateriali GML_FUNCTION_NOT_IMPLEMENTED
+#define glMaterialiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMatrixIndexPointerARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMatrixIndexubvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMatrixIndexuivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMatrixIndexusvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMatrixMode GML_FUNCTION_NOT_IMPLEMENTED
+#define glMinmax GML_FUNCTION_NOT_IMPLEMENTED
+#define glMinmaxEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultMatrixd GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultMatrixf GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultTransposeMatrixd GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultTransposeMatrixdARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultTransposeMatrixf GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultTransposeMatrixfARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiDrawArrays GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiDrawArraysEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiDrawElementArrayAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiDrawElements GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiDrawElementsEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiDrawRangeElementArrayAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiModeDrawArraysIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiModeDrawElementsIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1d GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1f GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1i GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1s GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord1svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2i GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2s GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord2svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord3svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4d GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4f GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4i GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4s GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glMultiTexCoord4svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glNewBufferRegionEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glNewList GML_FUNCTION_NOT_IMPLEMENTED
+#define glNewObjectBufferATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3b GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3bv GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormal3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalPointerListIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalPointervINTEL GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3bATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3bvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3dATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3dvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3fATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3fvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3iATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3ivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3sATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glNormalStream3svATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glOrtho GML_FUNCTION_NOT_IMPLEMENTED
+#define glOrthofOES GML_FUNCTION_NOT_IMPLEMENTED
+#define glPNTrianglesfATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glPNTrianglesiATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glPassTexCoordATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glPassThrough GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelDataRangeNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelMapfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelMapuiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelMapusv GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelStoref GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelStorei GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelTexGenSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelTransferf GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelTransferi GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelTransformParameterfEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelTransformParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelTransformParameteriEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelTransformParameterivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glPixelZoom GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointParameterf GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointParameterfARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointParameterfEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointParameterfvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointParameterfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointParameteriNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointParameterivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glPointSize GML_FUNCTION_NOT_IMPLEMENTED
+#define glPollAsyncSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glPolygonMode GML_FUNCTION_NOT_IMPLEMENTED
+#define glPolygonOffset GML_FUNCTION_NOT_IMPLEMENTED
+#define glPolygonOffsetEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glPolygonStipple GML_FUNCTION_NOT_IMPLEMENTED
+#define glPopAttrib GML_FUNCTION_NOT_IMPLEMENTED
+#define glPopClientAttrib GML_FUNCTION_NOT_IMPLEMENTED
+#define glPopMatrix GML_FUNCTION_NOT_IMPLEMENTED
+#define glPopName GML_FUNCTION_NOT_IMPLEMENTED
+#define glPrimitiveRestartIndexNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glPrimitiveRestartNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glPrioritizeTextures GML_FUNCTION_NOT_IMPLEMENTED
+#define glPrioritizeTexturesEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramBufferParametersIivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramBufferParametersIuivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramBufferParametersfvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameter4dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameter4dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameter4fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameter4fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameterI4iNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameterI4ivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameterI4uiNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameterI4uivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParameters4fvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParametersI4ivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramEnvParametersI4uivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameter4dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameter4dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameter4fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameter4fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameterI4iNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameterI4ivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameterI4uiNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameterI4uivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParameters4fvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParametersI4ivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramLocalParametersI4uivNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramNamedParameter4dNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramNamedParameter4dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramNamedParameter4fNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramNamedParameter4fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramParameter4dNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramParameter4dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramParameter4fNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramParameter4fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramParameteriEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramParameters4dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramParameters4fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramStringARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glProgramVertexLimitNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glPushAttrib GML_FUNCTION_NOT_IMPLEMENTED
+#define glPushClientAttrib GML_FUNCTION_NOT_IMPLEMENTED
+#define glPushMatrix GML_FUNCTION_NOT_IMPLEMENTED
+#define glPushName GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos2dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos2i GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos2iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos2s GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos2sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos4d GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos4dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos4f GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos4i GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos4iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos4s GML_FUNCTION_NOT_IMPLEMENTED
+#define glRasterPos4sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glReadBuffer GML_FUNCTION_NOT_IMPLEMENTED
+#define glReadBufferRegionEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glReadPixels GML_FUNCTION_NOT_IMPLEMENTED
+#define glReadVideoPixelsSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glRectd GML_FUNCTION_NOT_IMPLEMENTED
+#define glRectdv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRectf GML_FUNCTION_NOT_IMPLEMENTED
+#define glRectfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRecti GML_FUNCTION_NOT_IMPLEMENTED
+#define glRectiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glRects GML_FUNCTION_NOT_IMPLEMENTED
+#define glRectsv GML_FUNCTION_NOT_IMPLEMENTED
+#define glReferencePlaneSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glRenderMode GML_FUNCTION_NOT_IMPLEMENTED
+#define glRenderbufferStorageEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glRenderbufferStorageMultisampleCoverageNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glRenderbufferStorageMultisampleEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodePointerSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeubSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeubvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiColor3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiColor3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiColor4fNormal3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiColor4ubVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiColor4ubVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiNormal3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiNormal3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiTexCoord2fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiTexCoord2fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuiVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeuivSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeusSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glReplacementCodeusvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glRequestResidentProgramsNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glResetHistogram GML_FUNCTION_NOT_IMPLEMENTED
+#define glResetHistogramEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glResetMinmax GML_FUNCTION_NOT_IMPLEMENTED
+#define glResetMinmaxEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glResizeBuffersMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glRotated GML_FUNCTION_NOT_IMPLEMENTED
+#define glRotatef GML_FUNCTION_NOT_IMPLEMENTED
+#define glSampleCoverage GML_FUNCTION_NOT_IMPLEMENTED
+#define glSampleCoverageARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glSampleMapATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glSampleMaskEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSampleMaskSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glSamplePatternEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSamplePatternSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glScaled GML_FUNCTION_NOT_IMPLEMENTED
+#define glScalef GML_FUNCTION_NOT_IMPLEMENTED
+#define glScissor GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3b GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3bEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3bv GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3bvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3dEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3dvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3fEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3fvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3iEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3ivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3sEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3svEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3ub GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3ubEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3ubv GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3ubvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3ui GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3uiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3us GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3usEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3usv GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColor3usvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColorPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColorPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSecondaryColorPointerListIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glSelectBuffer GML_FUNCTION_NOT_IMPLEMENTED
+#define glSeparableFilter2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glSeparableFilter2DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSetFenceAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glSetFenceNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glSetFragmentShaderConstantATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glSetInvariantEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glSetLocalConstantEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glShadeModel GML_FUNCTION_NOT_IMPLEMENTED
+#define glShaderOp1EXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glShaderOp2EXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glShaderOp3EXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glShaderSource GML_FUNCTION_NOT_IMPLEMENTED
+#define glShaderSourceARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glSharpenTexFuncSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glSpriteParameterfSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glSpriteParameterfvSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glSpriteParameteriSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glSpriteParameterivSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glStencilFunc GML_FUNCTION_NOT_IMPLEMENTED
+#define glStencilFuncSeparate GML_FUNCTION_NOT_IMPLEMENTED
+#define glStencilFuncSeparateATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glStencilMask GML_FUNCTION_NOT_IMPLEMENTED
+#define glStencilMaskSeparate GML_FUNCTION_NOT_IMPLEMENTED
+#define glStencilOp GML_FUNCTION_NOT_IMPLEMENTED
+#define glStencilOpSeparate GML_FUNCTION_NOT_IMPLEMENTED
+#define glStencilOpSeparateATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glStringMarkerGREMEDY GML_FUNCTION_NOT_IMPLEMENTED
+#define glSwizzleEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTagSampleBufferSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glTangentPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTbufferMask3DFX GML_FUNCTION_NOT_IMPLEMENTED
+#define glTestFenceAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glTestFenceNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTestObjectAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexBufferEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexBumpParameterfvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexBumpParameterivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1d GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1f GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1i GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1s GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord1sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fColor3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fColor3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fColor4fNormal3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fColor4fNormal3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fColor4ubVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fColor4ubVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fNormal3fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fNormal3fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fVertex3fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fVertex3fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2i GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2s GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord2sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4d GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4f GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4fColor4fNormal3fVertex4fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4fColor4fNormal3fVertex4fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4fVertex4fSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4fVertex4fvSUN GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4i GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4s GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoord4sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoordPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoordPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoordPointerListIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexCoordPointervINTEL GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexEnvf GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexEnvfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexEnvi GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexEnviv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexFilterFuncSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexGend GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexGendv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexGenf GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexGenfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexGeni GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexGeniv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexImage1D GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexImage2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexImage3D GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexImage3DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexImage4DSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexParameterIivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexParameterIuivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexParameterf GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexParameterfv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexParameteri GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexParameteriv GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexScissorFuncINTEL GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexScissorINTEL GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexSubImage1D GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexSubImage1DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexSubImage2D GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexSubImage2DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexSubImage3D GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexSubImage3DEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTexSubImage4DSGIS GML_FUNCTION_NOT_IMPLEMENTED
+#define glTextureFogSGIX GML_FUNCTION_NOT_IMPLEMENTED
+#define glTextureLightEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTextureMaterialEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTextureNormalEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glTextureRangeAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glTrackMatrixNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTransformFeedbackAttribsNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTransformFeedbackVaryingsNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glTranslated GML_FUNCTION_NOT_IMPLEMENTED
+#define glTranslatef GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1f GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1i GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform1uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2i GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform2uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform3uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4f GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4i GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniform4uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformBufferEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix2fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix2x3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix2x4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix3fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix3x2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix3x4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix4fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix4x2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUniformMatrix4x3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glUnlockArraysEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glUnmapBuffer GML_FUNCTION_NOT_IMPLEMENTED
+#define glUnmapBufferARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glUnmapObjectBufferATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glUpdateObjectBufferATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glUseProgram GML_FUNCTION_NOT_IMPLEMENTED
+#define glUseProgramObjectARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glValidateProgram GML_FUNCTION_NOT_IMPLEMENTED
+#define glValidateProgramARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantArrayObjectATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantbvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantdvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantsvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantubvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantuivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVariantusvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2i GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2s GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex2sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4d GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4f GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4i GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4s GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertex4sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexArrayParameteriAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexArrayRangeAPPLE GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexArrayRangeNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1d GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1dNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1f GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1fNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1s GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1sNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib1svNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2dNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2fNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2s GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2sNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib2svNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3dNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3fNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3sNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib3svNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4Nbv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4NbvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4Niv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4NivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4Nsv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4NsvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4Nub GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4NubARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4Nubv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4NubvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4Nuiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4NuivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4Nusv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4NusvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4bv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4bvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4d GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4dNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4f GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4fNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4hNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4s GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4sNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4svNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4ubNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4ubv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4ubvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4ubvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4uiv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4uivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4usv GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttrib4usvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribArrayObjectATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI1iEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI1ivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI1uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI1uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI2iEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI2ivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI2uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI2uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI3iEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI3ivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI3uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI3uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI4bvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI4iEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI4ivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI4svEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI4ubvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI4uiEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI4uivEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribI4usvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribIPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribPointerARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribPointerNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs1dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs1fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs1hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs1svNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs2dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs2fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs2hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs2svNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs3dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs3fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs3hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs3svNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs4dvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs4fvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs4hvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs4svNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexAttribs4ubvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexBlendARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexBlendEnvfATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexBlendEnviATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexPointer GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexPointerListIBM GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexPointervINTEL GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream2dATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream2dvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream2fATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream2fvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream2iATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream2ivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream2sATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream2svATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream3dATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream3dvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream3fATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream3fvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream3iATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream3ivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream3sATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream3svATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream4dATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream4dvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream4fATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream4fvATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream4iATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream4ivATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream4sATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexStream4svATI GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexWeightPointerEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexWeightfEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexWeightfvEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexWeighthNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glVertexWeighthvNV GML_FUNCTION_NOT_IMPLEMENTED
+#define glViewport GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightPointerARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightbvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightdvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightfvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightsvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightubvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightuivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWeightusvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2d GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2dMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2dvMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2f GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2fMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2fvMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2i GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2iMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2ivMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2s GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2sMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos2svMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3d GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3dARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3dMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3dv GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3dvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3dvMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3f GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3fARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3fMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3fv GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3fvARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3fvMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3i GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3iARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3iMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3iv GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3ivARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3ivMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3s GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3sARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3sMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3sv GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3svARB GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos3svMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos4dMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos4dvMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos4fMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos4fvMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos4iMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos4ivMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos4sMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWindowPos4svMESA GML_FUNCTION_NOT_IMPLEMENTED
+#define glWriteMaskEXT GML_FUNCTION_NOT_IMPLEMENTED
+
+#define gluBeginCurve GML_FUNCTION_NOT_IMPLEMENTED
+#define gluBeginPolygon GML_FUNCTION_NOT_IMPLEMENTED
+#define gluBeginSurface GML_FUNCTION_NOT_IMPLEMENTED
+#define gluBeginTrim GML_FUNCTION_NOT_IMPLEMENTED
+#define gluBuild1DMipmaps GML_FUNCTION_NOT_IMPLEMENTED
+#define gluBuild2DMipmaps GML_FUNCTION_NOT_IMPLEMENTED
+#define gluCylinder GML_FUNCTION_NOT_IMPLEMENTED
+#define gluDeleteNurbsRenderer GML_FUNCTION_NOT_IMPLEMENTED
+#define gluDeleteQuadric GML_FUNCTION_NOT_IMPLEMENTED
+#define gluDeleteTess GML_FUNCTION_NOT_IMPLEMENTED
+#define gluDisk GML_FUNCTION_NOT_IMPLEMENTED
+#define gluEndCurve GML_FUNCTION_NOT_IMPLEMENTED
+#define gluEndPolygon GML_FUNCTION_NOT_IMPLEMENTED
+#define gluEndSurface GML_FUNCTION_NOT_IMPLEMENTED
+#define gluEndTrim GML_FUNCTION_NOT_IMPLEMENTED
+#define gluErrorString GML_FUNCTION_NOT_IMPLEMENTED
+#define gluErrorStringWIN GML_FUNCTION_NOT_IMPLEMENTED
+#define gluErrorUnicodeStringEXT GML_FUNCTION_NOT_IMPLEMENTED
+#define gluGetNurbsProperty GML_FUNCTION_NOT_IMPLEMENTED
+#define gluGetString GML_FUNCTION_NOT_IMPLEMENTED
+#define gluGetTessProperty GML_FUNCTION_NOT_IMPLEMENTED
+#define gluLoadSamplingMatrices GML_FUNCTION_NOT_IMPLEMENTED
+#define gluLookAt GML_FUNCTION_NOT_IMPLEMENTED
+#define gluNewNurbsRenderer GML_FUNCTION_NOT_IMPLEMENTED
+#define gluNewQuadric GML_FUNCTION_NOT_IMPLEMENTED
+#define gluNewTess GML_FUNCTION_NOT_IMPLEMENTED
+#define gluNextContour GML_FUNCTION_NOT_IMPLEMENTED
+#define gluNurbsCallback GML_FUNCTION_NOT_IMPLEMENTED
+#define gluNurbsCurve GML_FUNCTION_NOT_IMPLEMENTED
+#define gluNurbsProperty GML_FUNCTION_NOT_IMPLEMENTED
+#define gluNurbsSurface GML_FUNCTION_NOT_IMPLEMENTED
+#define gluOrtho2D GML_FUNCTION_NOT_IMPLEMENTED
+#define gluPartialDisk GML_FUNCTION_NOT_IMPLEMENTED
+#define gluPerspective GML_FUNCTION_NOT_IMPLEMENTED
+#define gluPickMatrix GML_FUNCTION_NOT_IMPLEMENTED
+#define gluProject GML_FUNCTION_NOT_IMPLEMENTED
+#define gluPwlCurve GML_FUNCTION_NOT_IMPLEMENTED
+#define gluQuadricCallback GML_FUNCTION_NOT_IMPLEMENTED
+#define gluQuadricDrawStyle GML_FUNCTION_NOT_IMPLEMENTED
+#define gluQuadricNormals GML_FUNCTION_NOT_IMPLEMENTED
+#define gluQuadricOrientation GML_FUNCTION_NOT_IMPLEMENTED
+#define gluQuadricTexture GML_FUNCTION_NOT_IMPLEMENTED
+#define gluScaleImage GML_FUNCTION_NOT_IMPLEMENTED
+#define gluSphere GML_FUNCTION_NOT_IMPLEMENTED
+#define gluTessBeginContour GML_FUNCTION_NOT_IMPLEMENTED
+#define gluTessBeginPolygon GML_FUNCTION_NOT_IMPLEMENTED
+#define gluTessCallback GML_FUNCTION_NOT_IMPLEMENTED
+#define gluTessEndContour GML_FUNCTION_NOT_IMPLEMENTED
+#define gluTessEndPolygon GML_FUNCTION_NOT_IMPLEMENTED
+#define gluTessNormal GML_FUNCTION_NOT_IMPLEMENTED
+#define gluTessProperty GML_FUNCTION_NOT_IMPLEMENTED
+#define gluTessVertex GML_FUNCTION_NOT_IMPLEMENTED
+#define gluUnProject GML_FUNCTION_NOT_IMPLEMENTED

Added: branches/gml/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/gml/rts/lib/gml/gmlsrv.h	                        (rev 0)
+++ branches/gml/rts/lib/gml/gmlsrv.h	2008-04-17 23:41:06 UTC (rev 5752)
@@ -0,0 +1,281 @@
+// GML - OpenGL Multithreading Library
+// for Spring <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
+// Author: Mattias &quot;zerver&quot; Radeskog
+// (C) Ware Zerver Tech. <A HREF="http://zerver.net">http://zerver.net</A>
+// Ware Zerver Tech. licenses this library
+// to be used freely for any purpose, as
+// long as this notice remains unchanged
+
+#ifndef GMLSRV_H
+#define GMLSRV_H
+
+#include &lt;boost/thread/barrier.hpp&gt;
+#include  &lt;boost/bind.hpp&gt;
+
+#define GML_MAX_EXEC_DEPTH 4
+
+template&lt;class R, class A, typename U&gt;
+struct gmlExecState {
+// 	void (*workfun)(int);
+	R (*worker)(void *);
+	R (*workerarg)(void *,A);
+	R (*workeriter)(void *,U);
+	void* workerclass;
+	int maxthreads;
+	BOOL syncmode;
+	int num_units;
+	typename std::list&lt;U&gt; *iter;
+	int limit1;
+	int limit2;
+	BOOL serverwork;
+	void (*serverfun)(void *);
+
+	boost::detail::atomic_count UnitCounter;
+	gmlExecState(R (*wrk)(void *)=NULL,R (*wrka)(void *,A)=NULL,R (*wrki)(void *,U)=NULL,
+		void* cls=NULL,int mt=0,BOOL sm=FALSE,int nu=0,typename std::list&lt;U&gt; *it=NULL,int l1=1,int l2=1,BOOL sw=FALSE,void (*swf)(void *)=NULL):
+	worker(wrk),workerarg(wrka),workeriter(wrki),workerclass(cls),maxthreads(mt),
+		syncmode(sm),num_units(nu),iter(it),limit1(l1),limit2(l2),serverwork(sw),serverfun(swf),UnitCounter(-1) {
+	}
+
+	void ExecServerFun() {
+		if(serverfun)
+		  (*serverfun)(workerclass);
+	}
+
+	void ExecAll(int &amp;pos, typename std::list&lt;U&gt;::iterator &amp;it) {
+		int i=UnitCounter;
+		if(i&gt;=num_units)
+			return;
+		if(workeriter) {
+			while(++i&lt;num_units) {
+  			(*workeriter)(workerclass,*it);
+				++it;
+				++pos;
+			}
+		}
+		else if(worker) {
+			while(++i&lt;num_units)
+  			(*worker)(workerclass);
+		}
+		else if(workerarg) {
+			while(++i&lt;num_units)
+  			(*workerarg)(workerclass,i);
+		}
+    UnitCounter%=num_units;
+	}
+
+	BOOL Exec(int &amp;pos, typename std::list&lt;U&gt;::iterator &amp;it) {
+		int i=++UnitCounter;
+		if(i&gt;=num_units)
+			return FALSE;
+		if(workeriter) {
+			while(pos&lt;i) {
+				++it;
+				++pos;
+			}
+			(*workeriter)(workerclass,*it);
+		}
+		else if(worker) {
+			(*worker)(workerclass);
+		}
+		else if(workerarg) {
+			(*workerarg)(workerclass,i);
+		}
+//					(*workfun)(i);
+		return TRUE;
+	}
+
+};
+
+
+template&lt;class R,class A, typename U&gt;
+class gmlClientServer {
+public:
+//	volatile bool barg1,barg2;
+//	void * volatile parg1;
+	int ExecDepth;
+	typename gmlExecState&lt;R,A,U&gt; ExecState[GML_MAX_EXEC_DEPTH];
+  boost::barrier Barrier; 
+	boost::thread *threads[GML_MAX_NUM_THREADS];
+	BOOL inited;
+	boost::detail::atomic_count threadcnt;
+	boost::detail::atomic_count ClientsReady;
+	BOOL newwork;
+/*
+	void (*clientfun[GML_MAX_NUM_THREADS])(void *);
+	void* clientclass[GML_MAX_NUM_THREADS];
+	void ExecClientFun(int thread) {
+		void **c=clientclass+thread;
+		if(*c &amp;&amp; ExecDepth==0) {
+		  (*clientfun[thread])(*c);
+      *c=NULL;
+		}
+	}
+*/
+
+	gmlClientServer():threadcnt(0),ClientsReady(0),Barrier(GML_CPU_COUNT),ExecDepth(0),newwork(FALSE) {
+		//ExecState-&gt;workfun=wf;
+//			memset(clientclass,0,GML_MAX_NUM_THREADS*sizeof(void *));
+		inited=FALSE;
+	}
+
+	~gmlClientServer() {
+	}
+
+	void gmlServer() {
+
+		do {
+			ClientsReady%=0;
+			if(newwork&gt;0)
+				++ExecDepth;
+			typename gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
+			if(newwork==0)
+				ex-&gt;UnitCounter%=-1;
+			BOOL execswf=newwork&gt;=0;
+			newwork=0;
+
+			Barrier.wait();
+      
+			if(execswf)
+			  ex-&gt;ExecServerFun();
+
+//  		ExecClientFun(0);
+
+			typename std::list&lt;U&gt;::iterator it;
+			if(ex-&gt;workeriter)
+				it=ex-&gt;iter-&gt;begin();
+			int pos=0;
+//      int nproc=0;
+			if(gmlThreadCount&gt;1) {
+				while(ClientsReady&lt;=gmlThreadCount+1) {
+					gmlUpdateServers();
+					BOOL processed=FALSE;
+					for(int i=1; i&lt;gmlThreadCount; ++i) {
+						gmlQueue *qd=&amp;gmlQueues[i];
+						if(qd-&gt;Reloc)
+							qd-&gt;Realloc();
+						if(qd-&gt;GetRead()) {
+							qd-&gt;Execute();
+							qd-&gt;ReleaseRead();
+							processed=TRUE;
+						}
+						if(qd-&gt;Sync) {
+							qd-&gt;ExecuteSynced();
+							processed=TRUE;
+						}
+					}
+					if(GML_SERVER_GLCALL &amp;&amp; ex-&gt;serverwork &amp;&amp; !processed) {
+						if(ex-&gt;Exec(pos,it)) {
+							//						++nproc;
+						}
+					}
+					if(ClientsReady&gt;=gmlThreadCount-1)
+						++ClientsReady;
+				}
+			}
+			else {
+				ex-&gt;ExecAll(pos,it);
+//				while(ex-&gt;Exec(pos,it,(void *)this))
+//					;
+			}
+//			GML_DEBUG(&quot;server &quot;,nproc)
+			if(ExecDepth&gt;0 &amp;&amp; !*(volatile int *)&amp;newwork) {
+				--ExecDepth;
+				newwork=-1;
+			}
+
+		} while(*(volatile int *)&amp;newwork);
+	}
+
+	void WorkInit() {
+		if(!inited) {
+  		gmlInit();
+			for(int i=1; i&lt;gmlThreadCount; ++i)
+				threads[i]=new boost::thread(boost::bind&lt;void, gmlClientServer, gmlClientServer*&gt;(&amp;gmlClientServer::gmlClient, this));
+			inited=TRUE;
+		}
+	}
+
+	void Work(R (*wrk)(void *),R (*wrka)(void *,A), R (*wrkit)(void *,U),void *cls,int mt,BOOL sm, typename std::list&lt;U&gt; *it,int nu,int l1,int l2,BOOL sw,void (*swf)(void *)=NULL) {
+		if(gmlThreadNumber!=0) {
+			NewWork(wrk,wrka,wrkit,cls,mt,sm,it,nu,l1,l2,sw,swf);
+			return;
+		}
+  	typename gmlExecState&lt;R,A,U&gt; *ex=ExecState;
+		new (ex) typename gmlExecState&lt;R,A,U&gt;(wrk,wrka,wrkit,cls,mt,sm,nu,it,l1,l2,sw,swf);
+		if(!inited)
+			WorkInit();
+		gmlServer();
+	}
+
+	void NewWork(R (*wrk)(void *),R (*wrka)(void *,A), R (*wrkit)(void *,U),void *cls,int mt,BOOL sm, typename std::list&lt;U&gt; *it,int nu,int l1,int l2,BOOL sw,void (*swf)(void *)=NULL) {
+		gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];
+		qd-&gt;ReleaseWrite();
+
+  	typename gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
+		new (ex+1) typename gmlExecState&lt;R,A,U&gt;(wrk,wrka,wrkit,cls,mt,sm,nu,it,l1,l2,sw,swf);
+		newwork=TRUE;
+
+		++ClientsReady;	
+		gmlClientSub();
+
+		Barrier.wait();
+
+		qd-&gt;GetWrite(TRUE);
+		if(ex-&gt;syncmode)
+			qd-&gt;SyncRequest();
+
+	}
+
+	void gmlClientSub() {
+		Barrier.wait();
+
+		typename gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
+    
+		int thread=gmlThreadNumber;
+		if(thread&gt;=ex-&gt;maxthreads) {
+  		++ClientsReady;	
+			return;
+		}
+
+		typename std::list&lt;U&gt;::iterator it;
+		if(ex-&gt;workeriter)
+			it=((typename std::list&lt;U&gt; *)*(typename std::list&lt;U&gt; * volatile *)&amp;ex-&gt;iter)-&gt;begin();
+		int pos=0;
+
+		int processed=0;
+		gmlQueue *qd=&amp;gmlQueues[thread];
+
+		qd-&gt;GetWrite(TRUE); 
+
+//		ExecClientFun(thread);
+
+		if(ex-&gt;syncmode)
+			qd-&gt;SyncRequest();
+
+		while(ex-&gt;Exec(pos,it)) {
+			++processed;
+
+//			int exproc=processed;
+			if(qd-&gt;WasSynced &amp;&amp; qd-&gt;GetWrite(TRUE))
+				processed=0;
+			if(processed&gt;=ex-&gt;limit1 &amp;&amp; qd-&gt;GetWrite(processed&gt;=ex-&gt;limit2))
+				processed=0;
+//			if(exproc!=processed) {
+//				GML_DEBUG(&quot;client &quot;,exproc)
+//			}
+		}
+		qd-&gt;ReleaseWrite();
+		++ClientsReady;	
+	}
+
+	void gmlClient() {
+		gmlThreadNumber=++threadcnt;
+		streflop_init&lt;streflop::Simple&gt;();
+		while(1) {
+      gmlClientSub();
+		}
+	}
+};
+
+#endif
\ No newline at end of file

Modified: branches/gml/rts/lib/luabind/luabind/detail/class_rep.hpp
===================================================================
--- branches/gml/rts/lib/luabind/luabind/detail/class_rep.hpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/lib/luabind/luabind/detail/class_rep.hpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -31,7 +31,11 @@
 #include &lt;list&gt;
 
 #include &lt;luabind/config.hpp&gt;
-#include &lt;luabind/detail/object_rep.hpp&gt;
+
+namespace luabind { namespace detail {
+    class object_rep;
+}}
+
 #include &lt;luabind/detail/construct_rep.hpp&gt;
 #include &lt;luabind/detail/garbage_collector.hpp&gt;
 #include &lt;luabind/detail/operator_id.hpp&gt;
@@ -42,12 +46,16 @@
 #include &lt;luabind/handle.hpp&gt;
 #include &lt;luabind/detail/primitives.hpp&gt;
 
-#ifdef BOOST_MSVC
+
+#if defined(BOOST_MSVC) || (__GNUC__ &gt;= 4 &amp;&amp; __GNUC_MINOR__ &gt;= 3)
 // msvc doesn't have two-phase, but requires
 // method_rep (and overload_rep) to be complete
 // because of its std::list implementation.
 // gcc on the other hand has two-phase but doesn't
 // require method_rep to be complete.
+//
+// gcc 4.3 includes boost_concept_check library which
+// also requires method_rep to be complete.
 #include &lt;luabind/detail/method_rep.hpp&gt;
 #endif
 
@@ -396,4 +404,6 @@
 
 //#include &lt;luabind/detail/overload_rep_impl.hpp&gt;
 
+#include &lt;luabind/detail/object_rep.hpp&gt;
+
 #endif // LUABIND_CLASS_REP_HPP_INCLUDED

Modified: branches/gml/rts/lib/luabind/luabind/detail/enum_maker.hpp
===================================================================
--- branches/gml/rts/lib/luabind/luabind/detail/enum_maker.hpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/lib/luabind/luabind/detail/enum_maker.hpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -32,17 +32,8 @@
 
 namespace luabind
 {
-	struct value;
+        struct value_vector;
 
-	struct value_vector : public std::vector&lt;value&gt;
-	{
-		// a bug in intel's compiler forces us to declare these constructors explicitly.
-		value_vector();
-		virtual ~value_vector();
-		value_vector(const value_vector&amp; v);
-		value_vector&amp; operator,(const value&amp; rhs);
-	};
-
 	struct value
 	{
 	friend class std::vector&lt;value&gt;;
@@ -55,21 +46,26 @@
 		const char* name_;
 		int val_;
 
-		value_vector operator,(const value&amp; rhs) const
-		{
-			value_vector v;
+                // due to boost_concept_check in gcc 4.3, this
+                // has to be defined later, after value_vector
+                // is a complete type
+		value_vector operator,(const value&amp; rhs) const;
 
-			v.push_back(*this);
-			v.push_back(rhs);
-
-			return v;
-		}
-
 	private: 
 
 		value() {}
 	};
 
+	struct value_vector : public std::vector&lt;value&gt;
+	{
+		// a bug in intel's compiler forces us to declare these constructors explicitly.
+		value_vector();
+		virtual ~value_vector();
+		value_vector(const value_vector&amp; v);
+		value_vector&amp; operator,(const value&amp; rhs);
+	};
+
+
 	inline value_vector::value_vector()
 		: std::vector&lt;value&gt;()
 	{
@@ -117,6 +113,17 @@
 			template&lt;class T&gt; void operator,(T const&amp;) const;
 		};
 	}
+
+
+        inline value_vector value::operator,(const value&amp; rhs) const
+        {
+                value_vector v;
+
+                v.push_back(*this);
+                v.push_back(rhs);
+
+                return v;
+        }
 }
 
 #endif // LUABIND_ENUM_MAKER_HPP_INCLUDED

Modified: branches/gml/rts/lib/luabind/luabind/detail/garbage_collector.hpp
===================================================================
--- branches/gml/rts/lib/luabind/luabind/detail/garbage_collector.hpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/lib/luabind/luabind/detail/garbage_collector.hpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -24,6 +24,7 @@
 #ifndef LUABIND_GARBAGE_COLLECTOR_HPP_INCLUDED
 #define LUABIND_GARBAGE_COLLECTOR_HPP_INCLUDED
 
+#include &lt;lua.h&gt;
 #include &lt;luabind/config.hpp&gt;
 
 namespace luabind { namespace detail

Modified: branches/gml/rts/lib/luabind/luabind/detail/overload_rep.hpp
===================================================================
--- branches/gml/rts/lib/luabind/luabind/detail/overload_rep.hpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/lib/luabind/luabind/detail/overload_rep.hpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -34,18 +34,27 @@
 #include &lt;boost/preprocessor/repeat.hpp&gt;
 #include &lt;vector&gt;
 
+// actually, this causes a #include cyclic dependency, which causes
+// overload_rep to not be #defined when it is necessary. (in method_rep.hpp)
+
+// actually, gcc cannot see pointer_converters before it sees class_rep
+//#if defined(BOOST_MSVC) // || (__GNUC__ &gt;= 4 &amp;&amp; __GNUC_MINOR__ &gt;= 3)
+//#include &lt;luabind/detail/policy.hpp&gt;
+//#endif
+
 #include &lt;luabind/detail/overload_rep_base.hpp&gt;
 
 #include &lt;luabind/detail/is_indirect_const.hpp&gt;
 
-#ifndef BOOST_MSVC
-#include &lt;luabind/detail/policy.hpp&gt;
-#endif
 
 namespace luabind { namespace detail
 {
 	struct dummy_ {};
 
+        // gcc 4.3 barfs without this
+        template&lt;int, class&gt; struct find_conversion_policy;
+
+
 	// this class represents a specific overload of a member-function.
 	struct overload_rep: public overload_rep_base
 	{

Modified: branches/gml/rts/lib/luabind/luabind/detail/policy.hpp
===================================================================
--- branches/gml/rts/lib/luabind/luabind/detail/policy.hpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/lib/luabind/luabind/detail/policy.hpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -44,13 +44,13 @@
 #include &lt;boost/tuple/tuple.hpp&gt;
 #include &lt;boost/version.hpp&gt;
 
+#include &lt;luabind/detail/class_rep.hpp&gt;
 #include &lt;luabind/detail/class_registry.hpp&gt;
 #include &lt;luabind/detail/primitives.hpp&gt;
 #include &lt;luabind/detail/object_rep.hpp&gt;
 #include &lt;luabind/detail/typetraits.hpp&gt;
 #include &lt;luabind/detail/class_cache.hpp&gt;
 #include &lt;luabind/detail/debug.hpp&gt;
-#include &lt;luabind/detail/class_rep.hpp&gt;
 
 #include &lt;boost/type_traits/add_reference.hpp&gt;
 
@@ -468,34 +468,39 @@
 		typedef boost::mpl::bool_&lt;false&gt; is_value_converter;
 		typedef pointer_converter type;
 		
+		// has to be outside of the class
+		// because gcc 4.3 barfs otherwise
 		template&lt;class T&gt;
-		void apply(lua_State* L, T* ptr)
+		void apply(lua_State* L, T* ptr);
+	};
+
+	template&lt;class T&gt;
+	inline void pointer_converter&lt;cpp_to_lua&gt;::apply(lua_State* L, T* ptr)
+	{
+		if (ptr == 0) 
 		{
-			if (ptr == 0) 
-			{
-				lua_pushnil(L);
-				return;
-			}
+			lua_pushnil(L);
+			return;
+		}
 
-			if (luabind::get_back_reference(L, ptr))
-				return;
+		if (luabind::get_back_reference(L, ptr))
+			return;
 
-			class_rep* crep = get_class_rep&lt;T&gt;(L);
+		class_rep* crep = get_class_rep&lt;T&gt;(L);
 
-			// if you get caught in this assert you are
-			// trying to use an unregistered type
-			assert(crep &amp;&amp; &quot;you are trying to use an unregistered type&quot;);
+		// if you get caught in this assert you are
+		// trying to use an unregistered type
+		assert(crep &amp;&amp; &quot;you are trying to use an unregistered type&quot;);
 
-			// create the struct to hold the object
-			void* obj = lua_newuserdata(L, sizeof(object_rep));
-			//new(obj) object_rep(ptr, crep, object_rep::owner, destructor_s&lt;T&gt;::apply);
-			new(obj) object_rep(ptr, crep, 0, 0);
+		// create the struct to hold the object
+		void* obj = lua_newuserdata(L, sizeof(object_rep));
+		//new(obj) object_rep(ptr, crep, object_rep::owner, destructor_s&lt;T&gt;::apply);
+		new(obj) object_rep(ptr, crep, 0, 0);
 
-			// set the meta table
-			detail::getref(L, crep-&gt;metatable_ref());
-			lua_setmetatable(L, -2);
-		}
-	};
+		// set the meta table
+		detail::getref(L, crep-&gt;metatable_ref());
+		lua_setmetatable(L, -2);
+	}
 
 	template&lt;class T&gt; struct make_pointer { typedef T* type; };
 	template&lt;&gt;
@@ -1277,6 +1282,11 @@
 namespace luabind { namespace
 {
 #if defined(__BORLANDC__) || (BOOST_VERSION &gt;= 103400 &amp;&amp; defined(__GNUC__))
+# if (BOOST_VERSION &gt;= 103500 &amp;&amp; __GNUC__ &gt;= 4 &amp;&amp; __GNUC_MINOR__ &gt;= 3)
+  static boost::arg&lt;0&gt; return_value;
+  static boost::arg&lt;0&gt; result;
+#  define LUABIND_PLACEHOLDER_ARG(N) boost::arg&lt;N&gt;&amp;
+# else
   static inline boost::arg&lt;0&gt; return_value()
   {
 	  return boost::arg&lt;0&gt;();
@@ -1286,7 +1296,8 @@
   {
 	  return boost::arg&lt;0&gt;();
   }
-# define LUABIND_PLACEHOLDER_ARG(N) boost::arg&lt;N&gt;(*)()
+#  define LUABIND_PLACEHOLDER_ARG(N) boost::arg&lt;N&gt;(*)()
+# endif
 #elif defined(BOOST_MSVC) || defined(__MWERKS__)
   static boost::arg&lt;0&gt; return_value;
   static boost::arg&lt;0&gt; result;

Modified: branches/gml/rts/lib/luabind/src/object_rep.cpp
===================================================================
--- branches/gml/rts/lib/luabind/src/object_rep.cpp	2008-04-17 19:52:14 UTC (rev 5751)
+++ branches/gml/rts/lib/luabind/src/object_rep.cpp	2008-04-17 23:41:06 UTC (rev 5752)
@@ -20,8 +20,8 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 // OR OTHER DEALINGS IN THE SOFTWARE.
 
+#include &lt;luabind/detail/class_rep.hpp&gt;
 #include &lt;luabind/detail/object_rep.hpp&gt;
-#include &lt;luabind/detail/class_rep.hpp&gt;
 
 namespace luabind { namespace detail
 {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000531.html">[Taspring-linux-commit] r5751 - trunk/rts/lib/luabind/luabind/detail
</A></li>
	<LI>Next message: <A HREF="000533.html">[Taspring-linux-commit] r5753 - trunk/Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#532">[ date ]</a>
              <a href="thread.html#532">[ thread ]</a>
              <a href="subject.html#532">[ subject ]</a>
              <a href="author.html#532">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
