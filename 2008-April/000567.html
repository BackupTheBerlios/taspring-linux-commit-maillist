<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5787 - in trunk: AI/Group/EconomyAI	rts/ExternalAI rts/Game rts/Game/Camera rts/Game/StartScripts	rts/Game/UI rts/Lua rts/Map rts/Rendering rts/Rendering/Env	rts/Rendering/UnitModels rts/Sim/Features rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Path rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Units/UnitTypes rts/Sim/Weapons rts/System	rts/System/FileSystem rts/System/Platform/Linux
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5787%20-%20in%20trunk%3A%20AI/Group/EconomyAI%0A%09rts/ExternalAI%20rts/Game%20rts/Game/Camera%20rts/Game/StartScripts%0A%09rts/Game/UI%20rts/Lua%20rts/Map%20rts/Rendering%20rts/Rendering/Env%0A%09rts/Rendering/UnitModels%20rts/Sim/Features%20rts/Sim/Misc%0A%09rts/Sim/MoveTypes%20rts/Sim/Path%20rts/Sim/Projectiles%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Units%0A%09rts/Sim/Units/COB%20rts/Sim/Units/CommandAI%0A%09rts/Sim/Units/UnitTypes%20rts/Sim/Weapons%20rts/System%0A%09rts/System/FileSystem%20rts/System/Platform/Linux&In-Reply-To=%3C20080426174900.EF40B46CB%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000566.html">
   <LINK REL="Next"  HREF="000568.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5787 - in trunk: AI/Group/EconomyAI	rts/ExternalAI rts/Game rts/Game/Camera rts/Game/StartScripts	rts/Game/UI rts/Lua rts/Map rts/Rendering rts/Rendering/Env	rts/Rendering/UnitModels rts/Sim/Features rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Path rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Units/UnitTypes rts/Sim/Weapons rts/System	rts/System/FileSystem rts/System/Platform/Linux</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5787%20-%20in%20trunk%3A%20AI/Group/EconomyAI%0A%09rts/ExternalAI%20rts/Game%20rts/Game/Camera%20rts/Game/StartScripts%0A%09rts/Game/UI%20rts/Lua%20rts/Map%20rts/Rendering%20rts/Rendering/Env%0A%09rts/Rendering/UnitModels%20rts/Sim/Features%20rts/Sim/Misc%0A%09rts/Sim/MoveTypes%20rts/Sim/Path%20rts/Sim/Projectiles%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Units%0A%09rts/Sim/Units/COB%20rts/Sim/Units/CommandAI%0A%09rts/Sim/Units/UnitTypes%20rts/Sim/Weapons%20rts/System%0A%09rts/System/FileSystem%20rts/System/Platform/Linux&In-Reply-To=%3C20080426174900.EF40B46CB%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5787 - in trunk: AI/Group/EconomyAI	rts/ExternalAI rts/Game rts/Game/Camera rts/Game/StartScripts	rts/Game/UI rts/Lua rts/Map rts/Rendering rts/Rendering/Env	rts/Rendering/UnitModels rts/Sim/Features rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Path rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Units/UnitTypes rts/Sim/Weapons rts/System	rts/System/FileSystem rts/System/Platform/Linux">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Apr 26 19:48:59 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000566.html">[Taspring-linux-commit] r5786 - in trunk/rts: Lua	Rendering/UnitModels Sim/Features Sim/Misc Sim/Units build/vstudio8
</A></li>
        <LI>Next message: <A HREF="000568.html">[Taspring-linux-commit] r5788 - in trunk/AI/Global: AAI KAI-0.2	KAIK-0.13 RAI-0.553 RAI-0.553/Krogs Metal Class v0.4
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#567">[ date ]</a>
              <a href="thread.html#567">[ thread ]</a>
              <a href="subject.html#567">[ subject ]</a>
              <a href="author.html#567">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-04-26 19:48:56 +0200 (Sat, 26 Apr 2008)
New Revision: 5787

Modified:
   trunk/AI/Group/EconomyAI/BoHandler.cpp
   trunk/AI/Group/EconomyAI/BoHandler.h
   trunk/AI/Group/EconomyAI/Helper.cpp
   trunk/AI/Group/EconomyAI/Helper.h
   trunk/AI/Group/EconomyAI/MetalMap.cpp
   trunk/AI/Group/EconomyAI/MetalMap.h
   trunk/rts/ExternalAI/AICallback.cpp
   trunk/rts/ExternalAI/Group.h
   trunk/rts/ExternalAI/GroupHandler.cpp
   trunk/rts/ExternalAI/GroupHandler.h
   trunk/rts/Game/Camera/OverheadController.cpp
   trunk/rts/Game/Camera/OverviewController.cpp
   trunk/rts/Game/Camera/SmoothController.cpp
   trunk/rts/Game/ConsoleHistory.cpp
   trunk/rts/Game/ConsoleHistory.h
   trunk/rts/Game/Game.cpp
   trunk/rts/Game/GameHelper.cpp
   trunk/rts/Game/PreGame.cpp
   trunk/rts/Game/SelectedUnits.cpp
   trunk/rts/Game/SelectedUnits.h
   trunk/rts/Game/SelectedUnitsAI.cpp
   trunk/rts/Game/StartScripts/AirScript.cpp
   trunk/rts/Game/StartScripts/CommanderScript.cpp
   trunk/rts/Game/StartScripts/CommanderScript2.cpp
   trunk/rts/Game/StartScripts/GlobalAITestScript.cpp
   trunk/rts/Game/StartScripts/ScriptHandler.cpp
   trunk/rts/Game/StartScripts/SpawnScript.cpp
   trunk/rts/Game/StartScripts/SpawnScript.h
   trunk/rts/Game/Team.cpp
   trunk/rts/Game/UI/CursorIcons.cpp
   trunk/rts/Game/UI/EndGameBox.cpp
   trunk/rts/Game/UI/GuiHandler.cpp
   trunk/rts/Game/UI/GuiHandler.h
   trunk/rts/Game/UI/KeyAutoBinder.h
   trunk/rts/Game/UI/KeyBindings.h
   trunk/rts/Game/UI/KeyCodes.cpp
   trunk/rts/Game/UI/KeyCodes.h
   trunk/rts/Game/UI/KeySet.cpp
   trunk/rts/Game/UI/KeySet.h
   trunk/rts/Game/UI/LuaUI.h
   trunk/rts/Game/UI/MiniMap.cpp
   trunk/rts/Game/UI/MouseCursor.cpp
   trunk/rts/Game/UI/MouseCursor.h
   trunk/rts/Game/UI/MouseHandler.cpp
   trunk/rts/Game/UI/MouseHandler.h
   trunk/rts/Game/UI/QuitBox.cpp
   trunk/rts/Game/UI/ResourceBar.cpp
   trunk/rts/Game/UI/SelectionKeyHandler.cpp
   trunk/rts/Game/UI/SelectionKeyHandler.h
   trunk/rts/Game/UI/ShareBox.cpp
   trunk/rts/Game/UI/StartPosSelecter.cpp
   trunk/rts/Game/UI/TooltipConsole.cpp
   trunk/rts/Game/WaitCommandsAI.cpp
   trunk/rts/Game/WordCompletion.cpp
   trunk/rts/Game/WordCompletion.h
   trunk/rts/Lua/LuaHandleSynced.cpp
   trunk/rts/Lua/LuaOpenGL.cpp
   trunk/rts/Lua/LuaRules.cpp
   trunk/rts/Map/BaseGroundDrawer.cpp
   trunk/rts/Map/BasicMapDamage.cpp
   trunk/rts/Rendering/Env/DynWater.cpp
   trunk/rts/Rendering/FartextureHandler.cpp
   trunk/rts/Rendering/InMapDraw.cpp
   trunk/rts/Rendering/UnitModels/3DModelParser.cpp
   trunk/rts/Rendering/UnitModels/3DModelParser.h
   trunk/rts/Rendering/UnitModels/3DOParser.h
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Rendering/UnitModels/s3oParser.cpp
   trunk/rts/Rendering/UnitModels/s3oParser.h
   trunk/rts/Sim/Features/Feature.cpp
   trunk/rts/Sim/Features/FeatureHandler.h
   trunk/rts/Sim/Misc/QuadField.cpp
   trunk/rts/Sim/Misc/RadarHandler.cpp
   trunk/rts/Sim/MoveTypes/AirMoveType.cpp
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
   trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
   trunk/rts/Sim/Path/PathEstimator.cpp
   trunk/rts/Sim/Path/PathEstimator.h
   trunk/rts/Sim/Path/PathFinder.cpp
   trunk/rts/Sim/Path/PathFinder.h
   trunk/rts/Sim/Path/PathManager.cpp
   trunk/rts/Sim/Path/PathManager.h
   trunk/rts/Sim/Projectiles/PieceProjectile.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
   trunk/rts/Sim/Units/COB/CobEngine.cpp
   trunk/rts/Sim/Units/COB/CobEngine.h
   trunk/rts/Sim/Units/COB/CobFile.cpp
   trunk/rts/Sim/Units/COB/CobFile.h
   trunk/rts/Sim/Units/COB/CobInstance.cpp
   trunk/rts/Sim/Units/COB/CobInstance.h
   trunk/rts/Sim/Units/COB/CobThread.cpp
   trunk/rts/Sim/Units/COB/CobThread.h
   trunk/rts/Sim/Units/CommandAI/Command.h
   trunk/rts/Sim/Units/CommandAI/CommandAI.cpp
   trunk/rts/Sim/Units/CommandAI/FactoryCAI.h
   trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp
   trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/Sim/Units/UnitLoader.h
   trunk/rts/Sim/Units/UnitTracker.cpp
   trunk/rts/Sim/Units/UnitTracker.h
   trunk/rts/Sim/Units/UnitTypes/Builder.h
   trunk/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp
   trunk/rts/Sim/Units/UnitTypes/Factory.h
   trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp
   trunk/rts/Sim/Weapons/BeamLaser.cpp
   trunk/rts/Sim/Weapons/PlasmaRepulser.cpp
   trunk/rts/Sim/Weapons/Weapon.cpp
   trunk/rts/System/FileSystem/Archive7Zip.cpp
   trunk/rts/System/FileSystem/Archive7Zip.h
   trunk/rts/System/FileSystem/ArchiveBase.cpp
   trunk/rts/System/FileSystem/ArchiveBase.h
   trunk/rts/System/FileSystem/ArchiveBuffered.cpp
   trunk/rts/System/FileSystem/ArchiveBuffered.h
   trunk/rts/System/FileSystem/ArchiveDir.cpp
   trunk/rts/System/FileSystem/ArchiveDir.h
   trunk/rts/System/FileSystem/ArchiveHPI.cpp
   trunk/rts/System/FileSystem/ArchiveHPI.h
   trunk/rts/System/FileSystem/ArchiveScanner.cpp
   trunk/rts/System/FileSystem/ArchiveScanner.h
   trunk/rts/System/FileSystem/ArchiveZip.cpp
   trunk/rts/System/FileSystem/ArchiveZip.h
   trunk/rts/System/FileSystem/VFSHandler.cpp
   trunk/rts/System/FileSystem/VFSHandler.h
   trunk/rts/System/LoadSaveHandler.cpp
   trunk/rts/System/Platform/Linux/OpenALSound.cpp
   trunk/rts/System/Platform/Linux/OpenALSound.h
   trunk/rts/System/SpringApp.cpp
Log:
more Spring header cleaning

Modified: trunk/AI/Group/EconomyAI/BoHandler.cpp
===================================================================
--- trunk/AI/Group/EconomyAI/BoHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/AI/Group/EconomyAI/BoHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -23,7 +23,7 @@
 
 void CBoHandler::ClearBuildOptions()
 {
-	for(map&lt;string,BOInfo*&gt;::iterator boi=allBO.begin();boi!=allBO.end();++boi)
+	for (std::map&lt;std::string,BOInfo*&gt;::iterator boi=allBO.begin();boi!=allBO.end();++boi)
 		delete boi-&gt;second;
 	allBO.clear();
 }
@@ -32,7 +32,7 @@
 {
 	if(unitDef-&gt;buildOptions.empty())
 		return;
-	for(map&lt;int,string&gt;::const_iterator boi=unitDef-&gt;buildOptions.begin();boi!=unitDef-&gt;buildOptions.end();++boi)
+	for (std::map&lt;int, std::string&gt;::const_iterator boi=unitDef-&gt;buildOptions.begin();boi!=unitDef-&gt;buildOptions.end();++boi)
 	{
 		if(allBO.find(boi-&gt;second)!=allBO.end())
 			continue;
@@ -43,7 +43,7 @@
 		info-&gt;energyCost	= ud-&gt;energyCost;
 		info-&gt;metalCost		= ud-&gt;metalCost;
 		info-&gt;buildTime		= ud-&gt;buildTime; // this is always 1 or bigger
-		info-&gt;totalCost		= max(1.0f,info-&gt;energyCost + (info-&gt;metalCost / mmkrME));
+		info-&gt;totalCost		= std::max(1.0f,info-&gt;energyCost + (info-&gt;metalCost / mmkrME));
 		info-&gt;isMex			= (ud-&gt;type==&quot;MetalExtractor&quot;) ? true : false;
 		info-&gt;isGeo			= (ud-&gt;needGeo) ? true : false;
 
@@ -63,9 +63,9 @@
 			else // calculate the allowed spacing
 			{
 				info-&gt;spacing = wd-&gt;areaOfEffect * (maxDamage - maxLoss) / (maxDamage - maxLoss * wd-&gt;edgeEffectiveness);
-				info-&gt;spacing = max(info-&gt;spacing, 0.0f);
+				info-&gt;spacing = std::max(info-&gt;spacing, 0.0f);
 			}
-			info-&gt;spacing = min(info-&gt;spacing, 0.5 * maxPartitionRadius);
+			info-&gt;spacing = std::min(info-&gt;spacing, 0.5 * maxPartitionRadius);
 		}
 		else
 		{
@@ -73,9 +73,9 @@
 		}
 
 		info-&gt;mp = ud-&gt;extractsMetal*avgMetal + ud-&gt;metalMake + ud-&gt;makesMetal - ud-&gt;metalUpkeep;
-		info-&gt;ep = ud-&gt;energyMake - ud-&gt;energyUpkeep + ud-&gt;tidalGenerator*tidalStrength + min(ud-&gt;windGenerator,avgWind);
-		info-&gt;me = info-&gt;mp / max(ud-&gt;energyUpkeep,1.0f);
-		info-&gt;em = info-&gt;ep / max(ud-&gt;metalUpkeep,1.0f);
+		info-&gt;ep = ud-&gt;energyMake - ud-&gt;energyUpkeep + ud-&gt;tidalGenerator * tidalStrength + std::min(ud-&gt;windGenerator,avgWind);
+		info-&gt;me = info-&gt;mp / std::max(ud-&gt;energyUpkeep, 1.0f);
+		info-&gt;em = info-&gt;ep / std::max(ud-&gt;metalUpkeep, 1.0f);
 
 		allBO[info-&gt;name] = info;
 
@@ -91,7 +91,7 @@
 		BOchanged = false;
 		bestMetal.clear();
 		bestEnergy.clear();
-		for(map&lt;string,BOInfo*&gt;::const_iterator boi=allBO.begin();boi!=allBO.end();++boi)
+		for (std::map&lt;std::string,BOInfo*&gt;::const_iterator boi=allBO.begin();boi!=allBO.end();++boi)
 		{
 			BOInfo* info = boi-&gt;second;
 			if(info-&gt;mp &gt; 0) bestMetal.push_back(info);

Modified: trunk/AI/Group/EconomyAI/BoHandler.h
===================================================================
--- trunk/AI/Group/EconomyAI/BoHandler.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/AI/Group/EconomyAI/BoHandler.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -2,7 +2,7 @@
 
 struct BOInfo
 {
-	string name;
+	std::string name;
 
 	float mp;	// metal production
 	float ep;	// energy production
@@ -24,8 +24,8 @@
 {
 	bool operator()(BOInfo* const&amp; bo1, BOInfo* const&amp; bo2)
 	{
-		bool sameMetal	= max(bo1-&gt;mp,bo2-&gt;mp) / min(bo1-&gt;mp,bo2-&gt;mp) &lt; 3 ? true : false;
-		bool sameCost	= max(bo1-&gt;totalCost,bo2-&gt;totalCost) / min(bo1-&gt;totalCost,bo2-&gt;totalCost) &lt; 10 ? true : false;
+		bool sameMetal	= std::max(bo1-&gt;mp,bo2-&gt;mp) / std::min(bo1-&gt;mp,bo2-&gt;mp) &lt; 3 ? true : false;
+		bool sameCost	= std::max(bo1-&gt;totalCost, bo2-&gt;totalCost) / std::min(bo1-&gt;totalCost,bo2-&gt;totalCost) &lt; 10 ? true : false;
 
 		if( sameMetal &amp;&amp;  sameCost) return bo1-&gt;me &gt; bo2-&gt;me;
 		if(!sameMetal &amp;&amp;  sameCost) return bo1-&gt;mp &gt; bo2-&gt;mp;
@@ -37,8 +37,8 @@
 {
 	bool operator()(BOInfo* const&amp; bo1, BOInfo* const&amp; bo2)
 	{
-		bool sameEnergy	= max(bo1-&gt;ep,bo2-&gt;ep) / min(bo1-&gt;ep,bo2-&gt;ep) &lt; 3 ? true : false;
-		bool sameCost	= max(bo1-&gt;totalCost,bo2-&gt;totalCost) / min(bo1-&gt;totalCost,bo2-&gt;totalCost) &lt; 10 ? true : false;
+		bool sameEnergy	= std::max(bo1-&gt;ep,bo2-&gt;ep) / std::min(bo1-&gt;ep,bo2-&gt;ep) &lt; 3 ? true : false;
+		bool sameCost	= std::max(bo1-&gt;totalCost, bo2-&gt;totalCost) / std::min(bo1-&gt;totalCost,bo2-&gt;totalCost) &lt; 10 ? true : false;
 
 		if( sameEnergy &amp;&amp;  sameCost) return bo1-&gt;em &gt; bo2-&gt;em;
 		if(!sameEnergy &amp;&amp;  sameCost) return bo1-&gt;ep &gt; bo2-&gt;ep;
@@ -58,9 +58,9 @@
 		void AddBuildOptions(const UnitDef* unitDef);
 		void SortBuildOptions();
 
-		map&lt;string,BOInfo*&gt; allBO;
-		vector&lt;BOInfo*&gt; bestMetal;	// ordered buildoptions for best metal production
-		vector&lt;BOInfo*&gt; bestEnergy;	// ordered buildoptions for best energy production
+		std::map&lt;std::string,BOInfo*&gt; allBO;
+		std::vector&lt;BOInfo*&gt; bestMetal;	// ordered buildoptions for best metal production
+		std::vector&lt;BOInfo*&gt; bestEnergy;	// ordered buildoptions for best energy production
 	private:
 		IAICallback* aicb;
 		bool BOchanged;

Modified: trunk/AI/Group/EconomyAI/Helper.cpp
===================================================================
--- trunk/AI/Group/EconomyAI/Helper.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/AI/Group/EconomyAI/Helper.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -67,16 +67,15 @@
 	// get the best M / E ratio for metalmakers and get a unitdef for a geo
 	mmkrME	= 0;
 	geoDef	= 0;
-	map&lt;string,const UnitDef*&gt; targetBO;
+	std::map&lt;std::string,const UnitDef*&gt; targetBO;
 	int size = aicb-&gt;GetFriendlyUnits(&amp;(friendlyUnits.front()));
-	for(int i=0;i&lt;size;i++)
-	{
+
+	for (int i = 0; i &lt; size; i++) {
 		if(myTeam != aicb-&gt;GetUnitTeam(friendlyUnits[i]))
 			continue;
 		ParseBuildOptions(targetBO,aicb-&gt;GetUnitDef(friendlyUnits[i]),true);
 	}
-	for(map&lt;string,const UnitDef*&gt;::iterator boi=targetBO.begin();boi!=targetBO.end();++boi)
-	{
+	for (std::map&lt;std::string, const UnitDef*&gt;::iterator boi = targetBO.begin(); boi != targetBO.end(); ++boi) {
 		const UnitDef* ud = boi-&gt;second;
 		if(ud-&gt;isMetalMaker)
 		{
@@ -114,16 +113,14 @@
 	// get the best M / E ratio for metalmakers and get a unitdef for a geo
 	mmkrME	= 0;
 	geoDef	= 0;
-	map&lt;string,const UnitDef*&gt; targetBO;
+	std::map&lt;std::string, const UnitDef*&gt; targetBO;
 	int size = aicb-&gt;GetFriendlyUnits(&amp;(friendlyUnits.front()));
-	for(int i=0;i&lt;size;i++)
-	{
+	for (int i = 0; i &lt; size; i++) {
 		if(myTeam != aicb-&gt;GetUnitTeam(friendlyUnits[i]))
 			continue;
 		ParseBuildOptions(targetBO,aicb-&gt;GetUnitDef(friendlyUnits[i]),true);
 	}
-	for(map&lt;string,const UnitDef*&gt;::iterator boi=targetBO.begin();boi!=targetBO.end();++boi)
-	{
+	for (std::map&lt;std::string, const UnitDef*&gt;::iterator boi = targetBO.begin(); boi != targetBO.end(); ++boi) {
 		const UnitDef* ud = boi-&gt;second;
 		if(ud-&gt;isMetalMaker)
 		{
@@ -140,16 +137,14 @@
 		mmkrME = 1/100;
 }
 
-pair&lt;int,int&gt; CHelper::BuildNameToId(string name, int unit)
+pair&lt;int,int&gt; CHelper::BuildNameToId(std::string name, int unit)
 {
-	pair&lt;int,int&gt; commandPair;
+	std::pair&lt;int, int&gt; commandPair;
 	commandPair.first	= 0;
 	commandPair.second	= 0;
-	const vector&lt;CommandDescription&gt;* cd=aicb-&gt;GetUnitCommands(unit);
-	for(vector&lt;CommandDescription&gt;::const_iterator cdi=cd-&gt;begin();cdi!=cd-&gt;end();++cdi)
-	{
-		if(cdi-&gt;id&lt;0 &amp;&amp; cdi-&gt;name==name)
-		{
+	const std::vector&lt;CommandDescription&gt;* cd=aicb-&gt;GetUnitCommands(unit);
+	for (std::vector&lt;CommandDescription&gt;::const_iterator cdi=cd-&gt;begin();cdi!=cd-&gt;end();++cdi) {
+		if(cdi-&gt;id&lt;0 &amp;&amp; cdi-&gt;name==name) {
 			commandPair.first	= cdi-&gt;id;
 			commandPair.second	= cdi-&gt;type;
 			break;
@@ -158,14 +153,12 @@
 	return commandPair;
 }
 
-string CHelper::BuildIdToName(int id, int unit)
+std::string CHelper::BuildIdToName(int id, int unit)
 {
-	string name = &quot;&quot;;
-	const vector&lt;CommandDescription&gt;* cd=aicb-&gt;GetUnitCommands(unit);
-	for(vector&lt;CommandDescription&gt;::const_iterator cdi=cd-&gt;begin();cdi!=cd-&gt;end();++cdi)
-	{
-		if(cdi-&gt;id&lt;0 &amp;&amp; cdi-&gt;id==id)
-		{
+	std::string name = &quot;&quot;;
+	const std::vector&lt;CommandDescription&gt;* cd=aicb-&gt;GetUnitCommands(unit);
+	for (std::vector&lt;CommandDescription&gt;::const_iterator cdi=cd-&gt;begin();cdi!=cd-&gt;end();++cdi) {
+		if(cdi-&gt;id&lt;0 &amp;&amp; cdi-&gt;id==id) {
 			name = cdi-&gt;name;
 			break;
 		}
@@ -173,7 +166,7 @@
 	return name;
 }
 
-void CHelper::ParseBuildOptions(map&lt;string,const UnitDef*&gt; &amp;targetBO, const UnitDef *unitDef, bool recursive)
+void CHelper::ParseBuildOptions(std::map&lt;std::string,const UnitDef*&gt; &amp;targetBO, const UnitDef *unitDef, bool recursive)
 {
 	if(unitDef==0)
 		return;
@@ -181,8 +174,7 @@
 		return;
 	if(targetBO.find(unitDef-&gt;name)!=targetBO.end())
 		return;
-	for(map&lt;int,string&gt;::const_iterator boi=unitDef-&gt;buildOptions.begin();boi!=unitDef-&gt;buildOptions.end();++boi)
-	{
+	for (std::map&lt;int, std::string&gt;::const_iterator boi=unitDef-&gt;buildOptions.begin();boi!=unitDef-&gt;buildOptions.end();++boi) {
 		if(targetBO.find(boi-&gt;second)!=targetBO.end())
 			continue;
 		const UnitDef* ud=aicb-&gt;GetUnitDef(boi-&gt;second.c_str());
@@ -194,7 +186,7 @@
 	}
 }
 
-float3 CHelper::FindBuildPos(string name, bool isMex, bool isGeo, float distance, int builder)
+float3 CHelper::FindBuildPos(std::string name, bool isMex, bool isGeo, float distance, int builder)
 {
 	const UnitDef* ud = aicb-&gt;GetUnitDef(name.c_str());
 	if(ud==0)

Modified: trunk/AI/Group/EconomyAI/Helper.h
===================================================================
--- trunk/AI/Group/EconomyAI/Helper.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/AI/Group/EconomyAI/Helper.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -15,19 +15,19 @@
 		virtual ~CHelper();
 		void PostLoad();
 
-		pair&lt;int,int&gt; BuildNameToId(string name, int unit);
-		string	BuildIdToName(int id, int unit);
-		float3	FindBuildPos(string name, bool isMex, bool isGeo, float distance, int builder);
+		std::pair&lt;int,int&gt; BuildNameToId(std::string name, int unit);
+		std::string	BuildIdToName(int id, int unit);
+		float3 FindBuildPos(std::string name, bool isMex, bool isGeo, float distance, int builder);
 		void	DrawBuildArea();
 		void	NewLocation(float3 centerPos, float radius);
 		void	ResetLocations();
 		void	AssignMetalMakerAI();
 		void	SendTxt(const char *fmt, ...);
-		void	ParseBuildOptions(map&lt;string,const UnitDef*&gt; &amp;targetBO, const UnitDef* unitDef, bool recursive);
+		void	ParseBuildOptions(std::map&lt;std::string,const UnitDef*&gt; &amp;targetBO, const UnitDef* unitDef, bool recursive);
 
 		float3	errorPos;
 		CMetalMap* metalMap;
-		vector&lt;int&gt; friendlyUnits;
+		std::vector&lt;int&gt; friendlyUnits;
 		int myTeam;
 		float extractorRadius;
 		float mmkrME;						// metalmaker M / E ratio
@@ -36,13 +36,13 @@
 		CGroupAI *owner;
 	private:
 		bool	IsMetalSpotAvailable(float3 spot,float extraction);
-		int		FindMetalSpots(float3 pos, float radius, vector&lt;float3&gt;* mexSpots);
+		int		FindMetalSpots(float3 pos, float radius, std::vector&lt;float3&gt;* mexSpots);
 
 		struct partition
 		{
 			CR_DECLARE_STRUCT(partition);
 			float3 pos;
-			string name;
+			std::string name;
 			bool taken;
 			bool empty;
 		};
@@ -54,10 +54,10 @@
 			float partitionRadius;
 			int numPartitions;
 			int squarePartitions;
-			vector&lt;float3&gt; mexSpots;
-			vector&lt;partition&gt; partitions;
+			std::vector&lt;float3&gt; mexSpots;
+			std::vector&lt;partition&gt; partitions;
 		};
-		vector&lt;location*&gt; locations;
+		std::vector&lt;location*&gt; locations;
 		int metalMakerAIid;
 		const UnitDef* geoDef;
 		float drawColor[4];

Modified: trunk/AI/Group/EconomyAI/MetalMap.cpp
===================================================================
--- trunk/AI/Group/EconomyAI/MetalMap.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/AI/Group/EconomyAI/MetalMap.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -414,10 +414,10 @@
 void CMetalMap::SaveMetalMap()
 {
 	char buffer[1000];
-	string filename = string(&quot;AI/HelperAI/MexData/&quot;) + string(aicb-&gt;GetMapName());
+	std::string filename = std::string(&quot;AI/HelperAI/MexData/&quot;) + std::string(aicb-&gt;GetMapName());
 	filename.resize(filename.size()-3);
-	filename += string(&quot;Mv&quot;);
-	filename += string(M_CLASS_VERSION);
+	filename += std::string(&quot;Mv&quot;);
+	filename += std::string(M_CLASS_VERSION);
 
 	strcpy(buffer, filename.c_str());
 	aicb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
@@ -444,10 +444,10 @@
 bool CMetalMap::LoadMetalMap()
 {
 	char buffer[1000];
-	string filename = string(&quot;AI/HelperAI/MexData/&quot;) + string(aicb-&gt;GetMapName());
+	std::string filename = std::string(&quot;AI/HelperAI/MexData/&quot;) + std::string(aicb-&gt;GetMapName());
 	filename.resize(filename.size()-3);
-	filename += string(&quot;Mv&quot;);
-	filename += string(M_CLASS_VERSION);
+	filename += std::string(&quot;Mv&quot;);
+	filename += std::string(M_CLASS_VERSION);
 
 	strcpy(buffer, filename.c_str());
 	aicb-&gt;GetValue(AIVAL_LOCATE_FILE_R, buffer);

Modified: trunk/AI/Group/EconomyAI/MetalMap.h
===================================================================
--- trunk/AI/Group/EconomyAI/MetalMap.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/AI/Group/EconomyAI/MetalMap.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -18,7 +18,7 @@
 	int NumSpotsFound;
 	float AverageMetal;
 	float AverageMetalPerSpot;
-	vector&lt;float3&gt; VectoredSpots;
+	std::vector&lt;float3&gt; VectoredSpots;
 	bool IsMetalMap;
 	void SaveMetalMap();
 	bool LoadMetalMap();

Modified: trunk/rts/ExternalAI/AICallback.cpp
===================================================================
--- trunk/rts/ExternalAI/AICallback.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/ExternalAI/AICallback.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -666,10 +666,10 @@
 int CAICallback::GetEnemyUnits(int* units)
 {
 	verify();
-	list&lt;CUnit*&gt;::iterator ui;
+	std::list&lt;CUnit*&gt;::iterator ui;
 	int a = 0;
 
-	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
 		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
@@ -685,10 +685,10 @@
 int CAICallback::GetEnemyUnitsInRadarAndLos(int* units)
 {
 	verify();
-	list&lt;CUnit*&gt;::iterator ui;
+	std::list&lt;CUnit*&gt;::iterator ui;
 	int a = 0;
 
-	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
 		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team)) &amp;&amp; (u-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INLOS | LOS_INRADAR))) {
@@ -728,7 +728,7 @@
 	verify();
 	int a = 0;
 
-	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
 		if (gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(team))) {
@@ -772,7 +772,7 @@
 	verify();
 	int a = 0;
 
-	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+	for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
 		// IsUnitNeutral does the LOS check
@@ -1057,8 +1057,8 @@
 			bool good=true;
 			int xsize=bi.GetXSize();
 			int ysize=bi.GetYSize();
-			for(int z2=max(0,zs-ysize/2-minDist);z2&lt;min(gs-&gt;mapy,zs+(ysize+1)/2+minDist);++z2){
-				for(int x2=max(0,xs-xsize/2-minDist);x2&lt;min(gs-&gt;mapx,xs+(xsize+1)/2+minDist);++x2){
+			for(int z2=std::max(0,zs-ysize/2-minDist);z2&lt;std::min(gs-&gt;mapy,zs+(ysize+1)/2+minDist);++z2){
+				for(int x2=std::max(0,xs-xsize/2-minDist);x2&lt;std::min(gs-&gt;mapx,xs+(xsize+1)/2+minDist);++x2){
 					CSolidObject* so = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(z2 * gs-&gt;mapx + x2);
 					if(so &amp;&amp; so-&gt;immobile &amp;&amp; !dynamic_cast&lt;CFeature*&gt;(so)){
 						good=false;
@@ -1067,8 +1067,8 @@
 				}
 			}
 			//Checking factories near - factory can open yard for building
-			if (good) for(int z2=max(0,zs-ysize/2-minDist-2);z2&lt;min(gs-&gt;mapy,zs+(ysize+1)/2+minDist+2);++z2){
-				for(int x2=max(0,xs-xsize/2-minDist-2);x2&lt;min(gs-&gt;mapx,xs+(xsize+1)/2+minDist+2);++x2){
+			if (good) for(int z2=std::max(0,zs-ysize/2-minDist-2);z2&lt;std::min(gs-&gt;mapy,zs+(ysize+1)/2+minDist+2);++z2){
+				for(int x2=std::max(0,xs-xsize/2-minDist-2);x2&lt;std::min(gs-&gt;mapx,xs+(xsize+1)/2+minDist+2);++x2){
 					CSolidObject* so = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(z2 * gs-&gt;mapx + x2);
 					if(so &amp;&amp; so-&gt;immobile &amp;&amp; dynamic_cast&lt;CFactory*&gt;(so) &amp;&amp; ((CFactory*)so)-&gt;opening){
 						good=false;
@@ -1527,7 +1527,7 @@
 
 	for (int i=0;i&lt;inMapDrawer-&gt;numQuads;i++){
 		if(!inMapDrawer-&gt;drawQuads[i].points.empty()){
-			for(list&lt;CInMapDraw::MapPoint&gt;::iterator mp=inMapDrawer-&gt;drawQuads[i].points.begin();mp!=inMapDrawer-&gt;drawQuads[i].points.end();++mp){
+			for(std::list&lt;CInMapDraw::MapPoint&gt;::iterator mp=inMapDrawer-&gt;drawQuads[i].points.begin();mp!=inMapDrawer-&gt;drawQuads[i].points.end();++mp){
 				if(mp-&gt;color==gs-&gt;Team(team)-&gt;color) { //Maybe add so that markers of your ally team would be also found?
 					pm[a].pos=mp-&gt;pos;
 					pm[a].color=mp-&gt;color;
@@ -1551,7 +1551,7 @@
 
 	for (int i=0;i&lt;inMapDrawer-&gt;numQuads;i++){
 		if(!inMapDrawer-&gt;drawQuads[i].points.empty()){
-			for(list&lt;CInMapDraw::MapLine&gt;::iterator ml=inMapDrawer-&gt;drawQuads[i].lines.begin();ml!=inMapDrawer-&gt;drawQuads[i].lines.end();++ml){
+			for(std::list&lt;CInMapDraw::MapLine&gt;::iterator ml=inMapDrawer-&gt;drawQuads[i].lines.begin();ml!=inMapDrawer-&gt;drawQuads[i].lines.end();++ml){
 				if(ml-&gt;color==gs-&gt;Team(team)-&gt;color){ //Maybe add so that markers of your ally team would be also found?
 					lm[a].pos=ml-&gt;pos;
 					lm[a].color=ml-&gt;color;

Modified: trunk/rts/ExternalAI/Group.h
===================================================================
--- trunk/rts/ExternalAI/Group.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/ExternalAI/Group.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -18,8 +18,6 @@
 class CGroupAICallback;
 class CGroupHandler;
 
-using namespace std;
-
 class CGroup : public CObject
 {
 public:

Modified: trunk/rts/ExternalAI/GroupHandler.cpp
===================================================================
--- trunk/rts/ExternalAI/GroupHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/ExternalAI/GroupHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -92,7 +92,7 @@
 			(*ai)-&gt;DrawCommands();
 }
 
-void CGroupHandler::TestDll(string name)
+void CGroupHandler::TestDll(std::string name)
 {
 	typedef int (* GETGROUPAIVERSION)();
 	typedef const char ** (* GETAINAMELIST)();
@@ -144,7 +144,7 @@
 		AIKey key;
 		key.dllName=name;
 		key.aiNumber=i;
-		availableAI[key]=string(aiNameList[i]);
+		availableAI[key] = std::string(aiNameList[i]);
 	}
 //	logOutput &lt;&lt; name.c_str() &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; &quot;\n&quot;;
 	delete lib;
@@ -196,7 +196,7 @@
 	selectedUnits.SelectGroup(num);
 }
 
-void CGroupHandler::GroupCommand(int num, const string&amp; cmd)
+void CGroupHandler::GroupCommand(int num, const std::string&amp; cmd)
 {
 	if ((cmd == &quot;set&quot;) || (cmd == &quot;add&quot;)) {
 		if (cmd == &quot;set&quot;) {
@@ -291,15 +291,15 @@
 	delete group;
 }
 
-map&lt;AIKey,string&gt; CGroupHandler::GetSuitedAis(const CUnitSet&amp; units)
+std::map&lt;AIKey, std::string&gt; CGroupHandler::GetSuitedAis(const CUnitSet&amp; units)
 {
 	typedef bool (* ISUNITSUITED)(unsigned aiNumber,const UnitDef* unitDef);
 	ISUNITSUITED IsUnitSuited;
 
-	map&lt;AIKey,string&gt; suitedAis;
+	std::map&lt;AIKey, std::string&gt; suitedAis;
 	suitedAis[defaultKey]=&quot;default&quot;;
 
-	map&lt;AIKey,string&gt;::iterator aai;
+	std::map&lt;AIKey, std::string&gt;::iterator aai;
 	for(aai=availableAI.begin();aai!=availableAI.end();++aai)
 	{
 		SharedLib *lib;

Modified: trunk/rts/ExternalAI/GroupHandler.h
===================================================================
--- trunk/rts/ExternalAI/GroupHandler.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/ExternalAI/GroupHandler.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -13,8 +13,6 @@
 class CGroup;
 class CUnitSet;
 
-using namespace std;
-
 class CGroupHandler
 {
 public:
@@ -26,24 +24,24 @@
 	void Update();
 	void DrawCommands();
 	void GroupCommand(int num);
-	void GroupCommand(int num, const string&amp; cmd);
+	void GroupCommand(int num, const std::string&amp; cmd);
 	CGroup* CreateNewGroup(AIKey aiKey);
 	void RemoveGroup(CGroup* group);
 	void Load(std::istream *s);
 	void Save(std::ostream *s);
 
-	vector&lt;CGroup*&gt; groups;
-	map&lt;AIKey,string&gt; availableAI;
+	std::vector&lt;CGroup*&gt; groups;
+	std::map&lt;AIKey, std::string&gt; availableAI;
 
-	map&lt;AIKey,string&gt; GetSuitedAis(const CUnitSet&amp; units);
-	map&lt;AIKey,string&gt; lastSuitedAis;
+	std::map&lt;AIKey, std::string&gt; GetSuitedAis(const CUnitSet&amp; units);
+	std::map&lt;AIKey, std::string&gt; lastSuitedAis;
 
 	int team;
 protected:
 	void FindDlls(void);
-	void TestDll(string name);
+	void TestDll(std::string name);
 
-	vector&lt;int&gt; freeGroups;
+	std::vector&lt;int&gt; freeGroups;
 	int firstUnusedGroup;
 private:
 	AIKey defaultKey;

Modified: trunk/rts/Game/Camera/OverheadController.cpp
===================================================================
--- trunk/rts/Game/Camera/OverheadController.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/Camera/OverheadController.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -110,7 +110,7 @@
 
 float3 COverheadController::GetPos()
 {
-	maxHeight=9.5f*max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
+	maxHeight = 9.5f * std::max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
 
 	if (pos.x &lt; 0.01f) { pos.x = 0.01f; }
 	if (pos.z &lt; 0.01f) { pos.z = 0.01f; }

Modified: trunk/rts/Game/Camera/OverviewController.cpp
===================================================================
--- trunk/rts/Game/Camera/OverviewController.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/Camera/OverviewController.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -32,7 +32,7 @@
 	pos.x = gs-&gt;mapx * 4.0f;
 	pos.z = gs-&gt;mapy * 4.0f;
 	const float aspect = (gu-&gt;viewSizeX / gu-&gt;viewSizeY);
-	const float height = max(pos.x / aspect, pos.z);
+	const float height = std::max(pos.x / aspect, pos.z);
 	pos.y = ground-&gt;GetHeight(pos.x, pos.z) + (2.5f * height);
 	return pos;
 }

Modified: trunk/rts/Game/Camera/SmoothController.cpp
===================================================================
--- trunk/rts/Game/Camera/SmoothController.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/Camera/SmoothController.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -155,7 +155,7 @@
 
 float3 SmoothController::GetPos()
 {
-	maxHeight=9.5f*max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
+	maxHeight = 9.5f * std::max(gs-&gt;mapx,gs-&gt;mapy);		//map not created when constructor run
 
 	if (pos.x &lt; 0.01f) { pos.x = 0.01f; }
 	if (pos.z &lt; 0.01f) { pos.z = 0.01f; }

Modified: trunk/rts/Game/ConsoleHistory.cpp
===================================================================
--- trunk/rts/Game/ConsoleHistory.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/ConsoleHistory.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -30,9 +30,9 @@
 }
 
 
-bool CConsoleHistory::AddLine(const string&amp; msg)
+bool CConsoleHistory::AddLine(const std::string&amp; msg)
 {
-	string message;
+	std::string message;
 	if ((msg.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (msg[1] == ':')) {
 		message = msg.substr(2);
 	} else {
@@ -42,7 +42,7 @@
 }
 
 	
-bool CConsoleHistory::AddLineRaw(const string&amp; msg)
+bool CConsoleHistory::AddLineRaw(const std::string&amp; msg)
 {
 	if (msg.empty()) {
 		return false; // do not save blank lines
@@ -66,9 +66,9 @@
 }
 
 
-string CConsoleHistory::NextLine(const string&amp; current)
+std::string CConsoleHistory::NextLine(const std::string&amp; current)
 {
-	string prefix, message;
+	std::string prefix, message;
 	if ((current.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (current[1] == ':')) {
 		prefix  = current.substr(0, 2);
 		message = current.substr(2);
@@ -103,9 +103,9 @@
 }
 
 
-string CConsoleHistory::PrevLine(const string&amp; current)
+std::string CConsoleHistory::PrevLine(const std::string&amp; current)
 {
-	string prefix, message;
+	std::string prefix, message;
 	if ((current.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (current[1] == ':')) {
 		prefix  = current.substr(0, 2);
 		message = current.substr(2);

Modified: trunk/rts/Game/ConsoleHistory.h
===================================================================
--- trunk/rts/Game/ConsoleHistory.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/ConsoleHistory.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -7,24 +7,22 @@
 #include &lt;string&gt;
 #include &lt;list&gt;
 
-using namespace std;
-
 class CConsoleHistory
 {
 public:
 	CConsoleHistory();
 	~CConsoleHistory();
 	void ResetPosition();
-	bool AddLine(const string&amp; msg);
-	string NextLine(const string&amp; current);
-	string PrevLine(const string&amp; current);
+	bool AddLine(const std::string&amp; msg);
+	std::string NextLine(const std::string&amp; current);
+	std::string PrevLine(const std::string&amp; current);
 
 protected:
-	bool AddLineRaw(const string&amp; msg);
+	bool AddLineRaw(const std::string&amp; msg);
 
 protected:
-	list&lt;string&gt; lines;
-	list&lt;string&gt;::const_iterator pos;
+	std::list&lt;std::string&gt; lines;
+	std::list&lt;std::string&gt;::const_iterator pos;
 	static unsigned int MaxLines;
 };
 

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/Game.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -697,7 +697,7 @@
 			else if (action.command == &quot;chatswitchall&quot;) {
 				if ((userInput.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (userInput[1] == ':')) {
 					userInput = userInput.substr(2);
-					writingPos = max(0, writingPos - 2);
+					writingPos = std::max(0, writingPos - 2);
 				}
 				userInputPrefix = &quot;&quot;;
 				break;
@@ -757,11 +757,11 @@
 				break;
 			}
 			else if (action.command == &quot;edit_prev_char&quot;) {
-				writingPos = max(0, min((int)userInput.length(), writingPos - 1));
+				writingPos = std::max(0, std::min((int)userInput.length(), writingPos - 1));
 				break;
 			}
 			else if (action.command == &quot;edit_next_char&quot;) {
-				writingPos = max(0, min((int)userInput.length(), writingPos + 1));
+				writingPos = std::max(0, std::min((int)userInput.length(), writingPos + 1));
 				break;
 			}
 			else if (action.command == &quot;edit_prev_word&quot;) {
@@ -913,7 +913,7 @@
 			next = std::max(0, atoi(action.extra.c_str()) % 4);
 		} else {
 			const int current = configHandler.GetInt(&quot;ReflectiveWater&quot;, 1);
-			next = (max(0, current) + 1) % 4;
+			next = (std::max(0, current) + 1) % 4;
 		}
 		configHandler.SetInt(&quot;ReflectiveWater&quot;, next);
 		logOutput.Print(&quot;Set water rendering mode to %i (%s)&quot;, next, rmodes[next]);
@@ -1201,7 +1201,7 @@
 		const char* startPtr = action.extra.c_str();
 		float volume = (float)strtod(startPtr, &amp;endPtr);
 		if (endPtr != startPtr) {
-			gameSoundVolume = max(0.0f, min(1.0f, volume));
+			gameSoundVolume = std::max(0.0f, std::min(1.0f, volume));
 			sound-&gt;SetVolume(gameSoundVolume);
 			configHandler.SetInt(&quot;SoundVolume&quot;, (int)(gameSoundVolume * 100.0f));
 		}
@@ -1442,10 +1442,10 @@
 		}
 	}
 	else if (cmd == &quot;incguiopacity&quot;) {
-		CInputReceiver::guiAlpha = min(CInputReceiver::guiAlpha+0.1f,1.0f);
+		CInputReceiver::guiAlpha = std::min(CInputReceiver::guiAlpha+0.1f,1.0f);
 	}
 	else if (cmd == &quot;decguiopacity&quot;) {
-		CInputReceiver::guiAlpha = max(CInputReceiver::guiAlpha-0.1f,0.0f);
+		CInputReceiver::guiAlpha = std::max(CInputReceiver::guiAlpha-0.1f,0.0f);
 	}
 
 	else if (cmd == &quot;screenshot&quot;) {
@@ -1512,7 +1512,7 @@
 			if (crossSize &gt; 0.0f) {
 				crossSize = -crossSize;
 			} else {
-				crossSize = max(1.0f, -crossSize);
+				crossSize = std::max(1.0f, -crossSize);
 			}
 		} else {
 			crossSize = atof(action.extra.c_str());
@@ -1694,7 +1694,7 @@
 	}
 	else if (cmd == &quot;maxparticles&quot;) {
 		if (ph &amp;&amp; !action.extra.empty()) {
-			const int value = max(1, atoi(action.extra.c_str()));
+			const int value = std::max(1, atoi(action.extra.c_str()));
 			ph-&gt;SetMaxParticles(value);
 			logOutput.Print(&quot;Set maximum particles to: %i&quot;, value);
 		}
@@ -3562,8 +3562,8 @@
 				int team1=gs-&gt;players[player]-&gt;team;
 				int team2=inbuf[2];
 				bool shareUnits=!!inbuf[3];
-				float metalShare=min(*(float*)&amp;inbuf[4],(float)gs-&gt;Team(team1)-&gt;metal);
-				float energyShare=min(*(float*)&amp;inbuf[8],(float)gs-&gt;Team(team1)-&gt;energy);
+				float metalShare=std::min(*(float*)&amp;inbuf[4],(float)gs-&gt;Team(team1)-&gt;metal);
+				float energyShare=std::min(*(float*)&amp;inbuf[8],(float)gs-&gt;Team(team1)-&gt;energy);
 
 				if (metalShare != 0.0f) {
 					if (!luaRules || luaRules-&gt;AllowResourceTransfer(team1, team2, &quot;m&quot;, metalShare)) {
@@ -3930,8 +3930,8 @@
 		return;
 
 	file &lt;&lt; &quot;Frame &quot; &lt;&lt; gs-&gt;frameNum &lt;&lt;&quot;\n&quot;;
-	list&lt;CUnit*&gt;::iterator usi;
-	for(usi=uh-&gt;activeUnits.begin();usi!=uh-&gt;activeUnits.end();usi++){
+	std::list&lt;CUnit*&gt;::iterator usi;
+	for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); usi++) {
 		CUnit* u=*usi;
 		file &lt;&lt; &quot;Unit &quot; &lt;&lt; u-&gt;id &lt;&lt; &quot;\n&quot;;
 		file &lt;&lt; &quot;  xpos &quot; &lt;&lt; u-&gt;pos.x &lt;&lt; &quot; ypos &quot; &lt;&lt; u-&gt;pos.y &lt;&lt; &quot; zpos &quot; &lt;&lt; u-&gt;pos.z &lt;&lt; &quot;\n&quot;;
@@ -4096,7 +4096,7 @@
 			glEnd();
 
 			if(!w-&gt;onlyForward){
-				float dist=min(w-&gt;owner-&gt;directControl-&gt;targetDist,w-&gt;range*0.9f);
+				float dist=std::min(w-&gt;owner-&gt;directControl-&gt;targetDist,w-&gt;range*0.9f);
 				pos=w-&gt;weaponPos+w-&gt;wantedDir*dist;
 				v1=(pos-camera-&gt;pos).Normalize();
 				v2=(v1.cross(UpVector)).Normalize();
@@ -4483,7 +4483,7 @@
 {
 	const float fOrig = (float)orig / 255.0f;
 	float luaVal = tbl.GetFloat(channel, fOrig);
-	luaVal = max(0.0f, min(1.0f, luaVal));
+	luaVal = std::max(0.0f, std::min(1.0f, luaVal));
 	return (unsigned char)(luaVal * 255.0f);
 }
 

Modified: trunk/rts/Game/GameHelper.cpp
===================================================================
--- trunk/rts/Game/GameHelper.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/GameHelper.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -215,7 +215,7 @@
 		for (int* qi = quads; qi != endQuad; ++qi) {
 			const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 
-			for (list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
+			for (std::list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
 				if (!(*ui)-&gt;blocking)
 					continue;
 
@@ -241,7 +241,7 @@
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
@@ -291,7 +291,7 @@
 
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			CUnit* unit = *ui;
 			if (unit == exclude) {
@@ -364,11 +364,11 @@
 	vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
-			if((*ui)==exclude)
+			if ((*ui)==exclude)
 				continue;
-			if(gs-&gt;Ally((*ui)-&gt;allyteam,allyteam) || ((*ui)-&gt;losStatus[allyteam] &amp; LOS_INLOS)){
+			if (gs-&gt;Ally((*ui)-&gt;allyteam,allyteam) || ((*ui)-&gt;losStatus[allyteam] &amp; LOS_INLOS)){
 				float3 dif=(*ui)-&gt;midPos-start;
 				float closeLength=dif.dot(dir);
 				if(closeLength&lt;0)
@@ -380,7 +380,7 @@
 					length=closeLength;
 					hit=*ui;
 				}
-			} else if(useRadar &amp;&amp; radarhandler-&gt;InRadar(*ui,allyteam)){
+			} else if (useRadar &amp;&amp; radarhandler-&gt;InRadar(*ui,allyteam)){
 				float3 dif=(*ui)-&gt;midPos+(*ui)-&gt;posErrorVector*radarhandler-&gt;radarErrorSize[allyteam]-start;
 				float closeLength=dif.dot(dir);
 				if(closeLength&lt;0)
@@ -409,16 +409,16 @@
 	float secDamage = weapon-&gt;weaponDef-&gt;damages[0]*weapon-&gt;salvoSize/weapon-&gt;reloadTime*30;			//how much damage the weapon deal over 1 seconds
 	bool paralyzer = !!weapon-&gt;weaponDef-&gt;damages.paralyzeDamageTime;
 
-	vector&lt;int&gt; quads = qf-&gt;GetQuads(pos,radius+(aHeight-max(0.f,readmap-&gt;minheight))*heightMod);
+	std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos,radius+(aHeight - std::max(0.f,readmap-&gt;minheight))*heightMod);
 
 	int tempNum = gs-&gt;tempNum++;
-	vector&lt;int&gt;::iterator qi;
-	for(qi = quads.begin(); qi != quads.end(); ++qi) {
-		for(int t = 0; t &lt; gs-&gt;activeAllyTeams; ++t) {
+	std::vector&lt;int&gt;::iterator qi;
+	for (qi = quads.begin(); qi != quads.end(); ++qi) {
+		for (int t = 0; t &lt; gs-&gt;activeAllyTeams; ++t) {
 			if (gs-&gt;Ally(attacker-&gt;allyteam, t)) {
 				continue;
 			}
-			list&lt;CUnit*&gt;::const_iterator ui;
+			std::list&lt;CUnit*&gt;::const_iterator ui;
 			const std::list&lt;CUnit*&gt;&amp; allyTeamUnits = qf-&gt;GetQuad(*qi).teamUnits[t];
 			for (ui = allyTeamUnits.begin(); ui != allyTeamUnits.end(); ++ui) {
 				CUnit* unit = *ui;
@@ -465,7 +465,7 @@
 						if (weapon-&gt;hasTargetWeight) {
 							value *= weapon-&gt;TargetWeight(unit);
 						}
-						targets.insert(pair&lt;float, CUnit*&gt;(value, unit));
+						targets.insert(std::pair&lt;float, CUnit*&gt;(value, unit));
 					}
 				}
 			}
@@ -491,8 +491,8 @@
 	int tempNum = gs-&gt;tempNum++;
 	vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
-		const list&lt;CUnit*&gt;&amp; units = qf-&gt;GetQuad(*qi).units;
-		list&lt;CUnit*&gt;::const_iterator ui;
+		const std::list&lt;CUnit*&gt;&amp; units = qf-&gt;GetQuad(*qi).units;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = units.begin(); ui != units.end(); ++ui) {
 			CUnit* unit = *ui;
 			if (unit-&gt;tempNum != tempNum) {
@@ -528,7 +528,7 @@
 	vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam) &amp;&amp; (((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))){
 				(*ui)-&gt;tempNum=tempNum;
@@ -552,11 +552,11 @@
 
 	if (sphere) {  // includes target radius
 		float closeDist = radius;
-		vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius + uh-&gt;maxUnitRadius);
-		vector&lt;int&gt;::const_iterator qi;
+		std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius + uh-&gt;maxUnitRadius);
+		std::vector&lt;int&gt;::const_iterator qi;
 		for (qi = quads.begin(); qi != quads.end(); ++qi) {
-			const list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
-			list&lt;CUnit*&gt;::const_iterator ui;
+			const std::list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
+			std::list&lt;CUnit*&gt;::const_iterator ui;
 			for (ui = quadUnits.begin(); ui!= quadUnits.end(); ++ui) {
 				CUnit* unit = *ui;
 				if (unit-&gt;tempNum != tempNum &amp;&amp;
@@ -573,11 +573,11 @@
 	}
 	else { // cylinder  (doesn't included target radius)
 		float closeDistSq = radius * radius;
-		vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
-		vector&lt;int&gt;::const_iterator qi;
+		std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
+		std::vector&lt;int&gt;::const_iterator qi;
 		for (qi = quads.begin(); qi != quads.end(); ++qi) {
-			const list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
-			list&lt;CUnit*&gt;::const_iterator ui;
+			const std::list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
+			std::list&lt;CUnit*&gt;::const_iterator ui;
 			for (ui = quadUnits.begin(); ui!= quadUnits.end(); ++ui) {
 				CUnit* unit = *ui;
 				if (unit-&gt;tempNum != tempNum &amp;&amp;
@@ -599,13 +599,13 @@
 {
 	float closeDist=radius*radius;
 	CUnit* closeUnit=0;
-	vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
+	std::vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
 
 	int tempNum=gs-&gt;tempNum++;
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam)){
 				(*ui)-&gt;tempNum=tempNum;
@@ -627,10 +627,10 @@
 	vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
 
 	int tempNum=gs-&gt;tempNum++;
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;unitDef-&gt;canfly &amp;&amp; (*ui)-&gt;tempNum!=tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam) &amp;&amp; !(*ui)-&gt;crashing &amp;&amp; (((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))){
 				(*ui)-&gt;tempNum=tempNum;
@@ -648,13 +648,13 @@
 void CGameHelper::GetEnemyUnits(const float3 &amp;pos, float radius, int searchAllyteam, vector&lt;int&gt; &amp;found)
 {
 	float sqRadius=radius*radius;
-	vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
+	std::vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
 
 	int tempNum=gs-&gt;tempNum++;
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CUnit*&gt;::const_iterator ui;
+		std::list&lt;CUnit*&gt;::const_iterator ui;
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam) &amp;&amp; (((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))){
 				(*ui)-&gt;tempNum=tempNum;
@@ -676,7 +676,7 @@
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
+		for (std::list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
 			if (!(*ui)-&gt;blocking)
 				continue;
 
@@ -701,12 +701,12 @@
 float CGameHelper::GuiTraceRayFeature(const float3&amp; start, const float3&amp; dir, float length, CFeature*&amp; feature)
 {
 	float nearHit = length;
-	vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
+	std::vector&lt;int&gt;::iterator qi;
 
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		list&lt;CFeature*&gt;::const_iterator ui;
+		std::list&lt;CFeature*&gt;::const_iterator ui;
 
 		for (ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
 			CFeature* f = *ui;
@@ -824,7 +824,7 @@
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
@@ -849,7 +849,7 @@
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
@@ -899,7 +899,7 @@
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.teamUnits[allyteam].begin(); ui != quad.teamUnits[allyteam].end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)
@@ -923,7 +923,7 @@
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
-		for (list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::const_iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			CUnit* u = *ui;
 
 			if (u == owner)

Modified: trunk/rts/Game/PreGame.cpp
===================================================================
--- trunk/rts/Game/PreGame.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/PreGame.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -197,10 +197,10 @@
 			return 0;
 		}
 		else if(k==SDLK_LEFT) {
-			writingPos = max(0, min((int)userInput.length(), writingPos - 1));
+			writingPos = std::max(0, std::min((int)userInput.length(), writingPos - 1));
 		}
 		else if(k==SDLK_RIGHT) {
-			writingPos = max(0, min((int)userInput.length(), writingPos + 1));
+			writingPos = std::max(0, std::min((int)userInput.length(), writingPos + 1));
 		}
 		else if(k==SDLK_HOME) {
 			writingPos = 0;

Modified: trunk/rts/Game/SelectedUnits.cpp
===================================================================
--- trunk/rts/Game/SelectedUnits.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/SelectedUnits.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -463,7 +463,7 @@
 					(guihandler-&gt;commands[guihandler-&gt;inCommand].id &lt; 0)))) {
 			bool myColor = true;
 			glColor4fv(cmdColors.buildBox);
-			list&lt;CBuilderCAI*&gt;::const_iterator bi;
+			std::list&lt;CBuilderCAI*&gt;::const_iterator bi;
 			for (bi = uh-&gt;builderCAIs.begin(); bi != uh-&gt;builderCAIs.end(); ++bi) {
 				CBuilderCAI* builder = *bi;
 				if (builder-&gt;owner-&gt;team == gu-&gt;myTeam) {

Modified: trunk/rts/Game/SelectedUnits.h
===================================================================
--- trunk/rts/Game/SelectedUnits.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/SelectedUnits.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -11,8 +11,6 @@
 #include &quot;Sim/Units/UnitSet.h&quot;
 class CFeature;
 
-using namespace std;
-
 class CSelectedUnits : public CObject
 {
 public:

Modified: trunk/rts/Game/SelectedUnitsAI.cpp
===================================================================
--- trunk/rts/Game/SelectedUnitsAI.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/SelectedUnitsAI.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -356,7 +356,7 @@
 	std::multimap&lt;float,int&gt; orderedUnits;
 	CreateUnitOrder(orderedUnits,player);
 
-	for(multimap&lt;float,int&gt;::iterator oi=orderedUnits.begin();oi!=orderedUnits.end();++oi){
+	for (std::multimap&lt;float,int&gt;::iterator oi=orderedUnits.begin();oi!=orderedUnits.end();++oi){
 		nextPos = MoveToPos(oi-&gt;second, nextPos, sd, c);
 	}
 }
@@ -373,7 +373,7 @@
 			if(range&lt;1)
 				range=2000;		//give weaponless units a long range to make them go to the back
 			float value=(ud-&gt;metalCost*60+ud-&gt;energyCost)/unit-&gt;maxHealth*range;
-			out.insert(pair&lt;float,int&gt;(value,*ui));
+			out.insert(std::pair&lt;float,int&gt;(value,*ui));
 		}
 	}
 }
@@ -573,8 +573,8 @@
 	}
 	const int allyTeam = gs-&gt;AllyTeam(p-&gt;team);
 
-	const float3 mins(min(pos0.x, pos1.x), 0.0f, min(pos0.z, pos1.z));
-	const float3 maxs(max(pos0.x, pos1.x), 0.0f, max(pos0.z, pos1.z));
+	const float3 mins(std::min(pos0.x, pos1.x), 0.0f, std::min(pos0.z, pos1.z));
+	const float3 maxs(std::max(pos0.x, pos1.x), 0.0f, std::max(pos0.z, pos1.z));
 
 	vector&lt;CUnit*&gt; tmpUnits = qf-&gt;GetUnitsExact(mins, maxs);
 

Modified: trunk/rts/Game/StartScripts/AirScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/AirScript.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/StartScripts/AirScript.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -141,7 +141,7 @@
 				break;
 			}
 		}
-		timeOut=min(1,timeOut+1);
+		timeOut=std::min(1,timeOut+1);
 	}
 	if(timeOut&gt;0){
 		timeOut++;

Modified: trunk/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/CommanderScript.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/StartScripts/CommanderScript.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -39,14 +39,14 @@
 		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
 
 		// make a map of all side names  (assumes contiguous sections)
-		std::map&lt;string, string&gt; sideMap;
+		std::map&lt;std::string, std::string&gt; sideMap;
 		char sideText[64];
 		for (int side = 0;
 				 SNPRINTF(sideText, sizeof(sideText), &quot;side%i&quot;, side),
 				 p.SectionExist(sideText); // the test
 				 side++) {
-			const string sideName =
-				StringToLower(p.SGetValueDef(&quot;arm&quot;, string(sideText) + &quot;\\name&quot;));
+			const std::string sideName =
+				StringToLower(p.SGetValueDef(&quot;arm&quot;, std::string(sideText) + &quot;\\name&quot;));
 			sideMap[sideName] = sideText;
 		}
 
@@ -70,11 +70,11 @@
 				globalAI-&gt;CreateGlobalAI(a, gameSetup-&gt;aiDlls[a].c_str());
 			}
 
-			std::map&lt;string, string&gt;::const_iterator it = sideMap.find(team-&gt;side);
+			std::map&lt;std::string, std::string&gt;::const_iterator it = sideMap.find(team-&gt;side);
 
 			if (it != sideMap.end()) {
-				const string&amp; sideSection = it-&gt;second;
-				const string cmdrType =
+				const std::string&amp; sideSection = it-&gt;second;
+				const std::string cmdrType =
 					StringToLower(p.SGetValueDef(&quot;armcom&quot;, sideSection + &quot;\\commander&quot;));
 
 				CUnit* unit = unitLoader.LoadUnit(cmdrType, team-&gt;startPos, a, false, 0, NULL);
@@ -92,10 +92,8 @@
 	}
 	else {
 		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
-		const string s0 =
-			StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
-		const string s1 =
-			StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
+		const std::string s0 = StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
+		const std::string s1 = StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
 
 		TdfParser p2;
 		CMapInfo::OpenTDF(stupidGlobalMapname, p2);

Modified: trunk/rts/Game/StartScripts/CommanderScript2.cpp
===================================================================
--- trunk/rts/Game/StartScripts/CommanderScript2.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/StartScripts/CommanderScript2.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -37,8 +37,8 @@
 		gs-&gt;Team(1)-&gt;metalStorage=1000;
 
 		TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
-		string s0 = StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
-		string s1 = StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
+		std::string s0 = StringToLower(p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;));
+		std::string s1 = StringToLower(p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;));
 
 		TdfParser p2;
 		CMapInfo::OpenTDF (stupidGlobalMapname, p2);

Modified: trunk/rts/Game/StartScripts/GlobalAITestScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -42,8 +42,8 @@
 			gs-&gt;Team(1)-&gt;metalStorage = 1000;
 
 			TdfParser p(&quot;gamedata/sidedata.tdf&quot;);
-			string s0 = p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;);
-			string s1 = p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;);
+			std::string s0 = p.SGetValueDef(&quot;armcom&quot;, &quot;side0\\commander&quot;);
+			std::string s1 = p.SGetValueDef(&quot;corcom&quot;, &quot;side1\\commander&quot;);
 
 			TdfParser p2;
 			CMapInfo::OpenTDF(stupidGlobalMapname, p2);

Modified: trunk/rts/Game/StartScripts/ScriptHandler.cpp
===================================================================
--- trunk/rts/Game/StartScripts/ScriptHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/StartScripts/ScriptHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -59,8 +59,8 @@
 void CScriptHandler::StartLua()
 {
 #ifndef NO_LUA
-	std::vector&lt;string&gt; files = hpiHandler-&gt;GetFilesInDir(&quot;startscripts&quot;);
-	for (std::vector&lt;string&gt;::iterator i = files.begin(); i != files.end(); ++i) {
+	std::vector&lt;std::string&gt; files = hpiHandler-&gt;GetFilesInDir(&quot;startscripts&quot;);
+	for (std::vector&lt;std::string&gt;::iterator i = files.begin(); i != files.end(); ++i) {
 		char buffer[16000];
 		const int returned = hpiHandler-&gt;LoadFile(std::string(&quot;startscripts/&quot;+*i), buffer);
 		CLuaBinder* lua = SAFE_NEW CLuaBinder();
@@ -100,7 +100,7 @@
 }
 
 /** Called by the CScript constructors to add themselves to the CScriptHandler. */
-void CScriptHandler::AddScript(string name, CScript *s)
+void CScriptHandler::AddScript(std::string name, CScript *s)
 {
 	scripts[name] = s;
 }

Modified: trunk/rts/Game/StartScripts/SpawnScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/SpawnScript.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/StartScripts/SpawnScript.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -33,8 +33,8 @@
 		LoadSpawns();
 
 		TdfParser p(&quot;gamedata/sidedata.tdf&quot;);
-		string s0=p.SGetValueDef(&quot;armcom&quot;,&quot;side0\\commander&quot;);
-		string s1=p.SGetValueDef(&quot;corcom&quot;,&quot;side1\\commander&quot;);
+		std::string s0=p.SGetValueDef(&quot;armcom&quot;,&quot;side0\\commander&quot;);
+		std::string s1=p.SGetValueDef(&quot;corcom&quot;,&quot;side1\\commander&quot;);
 
 		TdfParser p2;
 		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
@@ -153,7 +153,7 @@
 
 std::string CSpawnScript::LoadToken(CFileHandler&amp; file)
 {
-	string s;
+	std::string s;
 	char c;
 
 	while (!file.Eof()) {

Modified: trunk/rts/Game/StartScripts/SpawnScript.h
===================================================================
--- trunk/rts/Game/StartScripts/SpawnScript.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/StartScripts/SpawnScript.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -7,7 +7,6 @@
 #include &lt;vector&gt;
 #include &quot;FileSystem/FileHandler.h&quot;
 
-using namespace std;
 class CSpawnScript :
 	public CScript
 {
@@ -23,7 +22,7 @@
 
 	struct Spawn {
 		int frame;
-		string name;
+		std::string name;
 	};
 
 	std::list&lt;Spawn&gt; spawns;

Modified: trunk/rts/Game/Team.cpp
===================================================================
--- trunk/rts/Game/Team.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/Team.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -255,9 +255,9 @@
 void CTeam::Died()
 {
 	if (leader &gt;= 0)
-		logOutput.Print(CMessages::Tr(&quot;Team%i(%s) is no more&quot;).c_str(), teamNum, gs-&gt;players[leader]-&gt;playerName.c_str());
+		logOutput.Print(CMessages::Tr(&quot;Team %i (%s) is no more&quot;).c_str(), teamNum, gs-&gt;players[leader]-&gt;playerName.c_str());
 	else
-		logOutput.Print(CMessages::Tr(&quot;Team%i is no more&quot;).c_str(), teamNum);
+		logOutput.Print(CMessages::Tr(&quot;Team %i is no more&quot;).c_str(), teamNum);
 	isDead = true;
 	luaCallIns.TeamDied(teamNum);
 	net-&gt;SendTeamDied(gu-&gt;myPlayerNum, teamNum);
@@ -307,8 +307,8 @@
 	for(int a=0; a &lt; gs-&gt;activeTeams; ++a){
 		if((a != teamNum) &amp;&amp; gs-&gt;AlliedTeams(teamNum,a)){
 			CTeam* team = gs-&gt;Team(a);
-			eShare += max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy);
-			mShare += max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal);
+			eShare += std::max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy);
+			mShare += std::max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal);
 		}
 	}
 
@@ -317,20 +317,20 @@
 	delayedMetalShare = 0;
 	delayedEnergyShare = 0;
 
-	const float eExcess = max(0.0f, energy - (energyStorage * energyShare));
-	const float mExcess = max(0.0f, metal  - (metalStorage  * metalShare));
+	const float eExcess = std::max(0.0f, energy - (energyStorage * energyShare));
+	const float mExcess = std::max(0.0f, metal  - (metalStorage  * metalShare));
 
 	float de=0,dm=0;
-	if(eShare&gt;0)
-		de=min(1.0f,eExcess/eShare);
-	if(mShare&gt;0)
-		dm=min(1.0f,mExcess/mShare);
+	if (eShare &gt; 0)
+		de = std::min(1.0f,eExcess/eShare);
+	if (mShare &gt; 0)
+		dm = std::min(1.0f,mExcess/mShare);
 
 	for(int a=0; a &lt; gs-&gt;activeTeams; ++a){
 		if((a != teamNum) &amp;&amp; gs-&gt;AlliedTeams(teamNum,a)){
 			CTeam* team = gs-&gt;Team(a);
 
-			const float edif = max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy) * de;
+			const float edif = std::max(0.0f, (team-&gt;energyStorage * 0.99f) - team-&gt;energy) * de;
 			energy -= edif;
 			energySent += edif;
 			currentStats.energySent += edif;
@@ -338,7 +338,7 @@
 			team-&gt;energyReceived += edif;
 			team-&gt;currentStats.energyReceived += edif;
 
-			const float mdif = max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal) * dm;
+			const float mdif = std::max(0.0f, (team-&gt;metalStorage * 0.99f) - team-&gt;metal) * dm;
 			metal -= mdif;
 			metalSent += mdif;
 			currentStats.metalSent += mdif;
@@ -368,9 +368,9 @@
 	CUnit::ChangeTeam(), hence it'd cause a random amount of the shared units
 	to be killed if the commander is among them. Also, &quot;.take&quot; would kill all
 	units once it transfered the commander. */
-	if(gs-&gt;gameMode==1 &amp;&amp; numCommanders&lt;=0 &amp;&amp; !gaia){
-		for(list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();++ui){
-			if((*ui)-&gt;team==teamNum &amp;&amp; !(*ui)-&gt;unitDef-&gt;isCommander)
+	if (gs-&gt;gameMode==1 &amp;&amp; numCommanders&lt;=0 &amp;&amp; !gaia){
+		for(std::list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();++ui){
+			if ((*ui)-&gt;team==teamNum &amp;&amp; !(*ui)-&gt;unitDef-&gt;isCommander)
 				(*ui)-&gt;KillUnit(true,false,0);
 		}
 		// Set to 1 to prevent above loop from being done every update.
@@ -433,7 +433,7 @@
 void CTeam::LeftLineage(CUnit* unit)
 {
 	if (gs-&gt;gameMode == 2 &amp;&amp; unit-&gt;id == this-&gt;lineageRoot) {
-		for(list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
+		for (std::list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 			if ((*ui)-&gt;lineage == this-&gt;teamNum)
 				(*ui)-&gt;KillUnit(true, false, 0);
 		}

Modified: trunk/rts/Game/UI/CursorIcons.cpp
===================================================================
--- trunk/rts/Game/UI/CursorIcons.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/CursorIcons.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -212,7 +212,7 @@
 		case CMD_AUTOREPAIRLEVEL:
 */
 		default: {
-			map&lt;int, string&gt;::const_iterator it = customTypes.find(cmd);
+			std::map&lt;int, std::string&gt;::const_iterator it = customTypes.find(cmd);
 			if (it == customTypes.end()) {
 				return NULL;
 			}
@@ -220,7 +220,7 @@
 		}
 	}
 
-	map&lt;std::string, CMouseCursor *&gt;::const_iterator it;
+	std::map&lt;std::string, CMouseCursor *&gt;::const_iterator it;
 	it = mouse-&gt;cursorCommandMap.find(cursorName);
 	if (it != mouse-&gt;cursorCommandMap.end()) {
 		return it-&gt;second;
@@ -228,8 +228,3 @@
 	
 	return NULL;
 }
-
-
-
-
-

Modified: trunk/rts/Game/UI/EndGameBox.cpp
===================================================================
--- trunk/rts/Game/UI/EndGameBox.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/EndGameBox.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -306,8 +306,8 @@
 			maxy=std::max(stats[stat1].maxdif,stat2!=-1?stats[stat2].maxdif:0)/CTeam::statsPeriod;
 
 		int numPoints=stats[0].values[0].size();
-		float scalex=0.54f/max(1.0f,numPoints-1.0f);
-		float scaley=0.54f/maxy;
+		float scalex=0.54f / std::max(1.0f,numPoints-1.0f);
+		float scaley=0.54f / maxy;
 
 		for (int a = 0; a &lt; 5; ++a) {
 			font-&gt;glPrintAt(box.x1 + 0.12f, box.y1 + 0.07f + (a * 0.135f), 0.8f,

Modified: trunk/rts/Game/UI/GuiHandler.cpp
===================================================================
--- trunk/rts/Game/UI/GuiHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/GuiHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -156,7 +156,7 @@
 }
 
 
-static bool SafeAtoF(float&amp; var, const string&amp; value)
+static bool SafeAtoF(float&amp; var, const std::string&amp; value)
 {
 	char* endPtr;
 	const char* startPtr = value.c_str();
@@ -176,20 +176,20 @@
 	CFileHandler ifs(filename);
 	CSimpleParser parser(ifs);
 
-	string deadStr = &quot;&quot;;
-	string prevStr = &quot;&quot;;
-	string nextStr = &quot;&quot;;
-	string fillOrderStr = &quot;&quot;;
+	std::string deadStr = &quot;&quot;;
+	std::string prevStr = &quot;&quot;;
+	std::string nextStr = &quot;&quot;;
+	std::string fillOrderStr = &quot;&quot;;
 
 	while (true) {
-		const string line = parser.GetCleanLine();
+		const std::string line = parser.GetCleanLine();
 		if (line.empty()) {
 			break;
 		}
 
-		vector&lt;string&gt; words = parser.Tokenize(line, 1);
+		std::vector&lt;std::string&gt; words = parser.Tokenize(line, 1);
 
-		const string command = StringToLower(words[0]);
+		const std::string command = StringToLower(words[0]);
 
 		if ((command == &quot;dropshadows&quot;) &amp;&amp; (words.size() &gt; 1)) {
 			dropShadows = !!atoi(words[1].c_str());
@@ -272,12 +272,12 @@
 	}
 
 	// sane clamps
-	xIcons      = max(2,      xIcons);
-	yIcons      = max(2,      yIcons);
-	xIconSize   = max(0.010f, xIconSize);
-	yIconSize   = max(0.010f, yIconSize);
-	iconBorder  = max(0.0f,   iconBorder);
-	frameBorder = max(0.0f,   frameBorder);
+	xIcons      = std::max(2,      xIcons);
+	yIcons      = std::max(2,      yIcons);
+	xIconSize   = std::max(0.010f, xIconSize);
+	yIconSize   = std::max(0.010f, yIconSize);
+	iconBorder  = std::max(0.0f,   iconBorder);
+	frameBorder = std::max(0.0f,   frameBorder);
 
 	xIconStep = xIconSize + (iconBorder * 2.0f);
 	yIconStep = yIconSize + (iconBorder * 2.0f);
@@ -358,7 +358,7 @@
 		fillOrder.push_back(i);
 	}
 
-	// split the string into slot names
+	// split the std::string into slot names
 	std::vector&lt;std::string&gt; slotNames = CSimpleParser::Tokenize(text, 0);
 	if ((int)slotNames.size() != iconsPerPage) {
 		return;
@@ -402,7 +402,7 @@
 }
 
 
-bool CGuiHandler::ReloadConfig(const string&amp; filename)
+bool CGuiHandler::ReloadConfig(const std::string&amp; filename)
 {
 	LoadConfig(filename);
 	activePage = 0;
@@ -426,7 +426,7 @@
 }
 
 
-void CGuiHandler::AppendPrevAndNext(vector&lt;CommandDescription&gt;&amp; cmds)
+void CGuiHandler::AppendPrevAndNext(std::vector&lt;CommandDescription&gt;&amp; cmds)
 {
 	CommandDescription cd;
 
@@ -480,7 +480,7 @@
 			if (samePage) {
 				for (int ii = 0; ii &lt; iconsCount; ii++) {
 					if (inCommand == icons[ii].commandsID) {
-						activePage = min(maxPage, (ii / iconsPerPage));;
+						activePage = std::min(maxPage, (ii / iconsPerPage));;
 						selectedUnits.SetCommandPage(activePage);
 					}
 				}
@@ -540,8 +540,8 @@
 	ac = selectedUnits.GetAvailableCommands();
 	ConvertCommands(ac.commands);
 
-	vector&lt;CommandDescription&gt; hidden;
-	vector&lt;CommandDescription&gt;::const_iterator cdi;
+	std::vector&lt;CommandDescription&gt; hidden;
+	std::vector&lt;CommandDescription&gt;::const_iterator cdi;
 
 	// separate the visible/hidden icons
 	for (cdi = ac.commands.begin(); cdi != ac.commands.end(); ++cdi){
@@ -567,7 +567,7 @@
 	const int prevPageCmd = cmdCount + 0;
 	const int nextPageCmd = cmdCount + 1;
 
-	maxPage    = max(0, pageCount - 1);
+	maxPage    = std::max(0, pageCount - 1);
 	iconsCount = pageCount * iconsPerPage;
 
 	// resize the icon array if required
@@ -640,9 +640,9 @@
 	if (validInCommand) {
 		RevertToCmdDesc(cmdDesc, defCmd, samePage);
 	} else if (useSelectionPage) {
-		activePage = min(maxPage, ac.commandPage);
+		activePage = std::min(maxPage, ac.commandPage);
 	}
-	activePage = min(maxPage, activePage);
+	activePage = std::min(maxPage, activePage);
 }
 
 
@@ -655,7 +655,7 @@
 	// get the commands to process
 	CSelectedUnits::AvailableCommandsStruct ac;
 	ac = selectedUnits.GetAvailableCommands();
-	vector&lt;CommandDescription&gt; cmds = ac.commands;
+	std::vector&lt;CommandDescription&gt; cmds = ac.commands;
 	if (cmds.size() &gt; 0) {
 		ConvertCommands(cmds);
 		AppendPrevAndNext(cmds);
@@ -664,14 +664,14 @@
 	// call for a custom layout
 	int tmpXicons = xIcons;
 	int tmpYicons = yIcons;
-	vector&lt;int&gt; removeCmds;
-	vector&lt;CommandDescription&gt; customCmds;
-	vector&lt;int&gt; onlyTextureCmds;
-	vector&lt;CLuaUI::ReStringPair&gt; reTextureCmds;
-	vector&lt;CLuaUI::ReStringPair&gt; reNamedCmds;
-	vector&lt;CLuaUI::ReStringPair&gt; reTooltipCmds;
-	vector&lt;CLuaUI::ReParamsPair&gt; reParamsCmds;
-	map&lt;int, int&gt; iconMap;
+	std::vector&lt;int&gt; removeCmds;
+	std::vector&lt;CommandDescription&gt; customCmds;
+	std::vector&lt;int&gt; onlyTextureCmds;
+	std::vector&lt;CLuaUI::ReStringPair&gt; reTextureCmds;
+	std::vector&lt;CLuaUI::ReStringPair&gt; reNamedCmds;
+	std::vector&lt;CLuaUI::ReStringPair&gt; reTooltipCmds;
+	std::vector&lt;CLuaUI::ReParamsPair&gt; reParamsCmds;
+	std::map&lt;int, int&gt; iconMap;
 
 	if (!luaUI-&gt;LayoutButtons(tmpXicons, tmpYicons, cmds,
 	                          removeCmds, customCmds,
@@ -702,7 +702,7 @@
 		}
 	}
 	// remove unwanted commands  (and mark all as onlyKey)
-	vector&lt;CommandDescription&gt; tmpCmds;
+	std::vector&lt;CommandDescription&gt; tmpCmds;
 	for (i = 0; i &lt; cmds.size(); i++) {
 		if (removeIDs.find(i) == removeIDs.end()) {
 			cmds[i].onlyKey = true;
@@ -766,8 +766,8 @@
 	for (i = 0; i &lt; reParamsCmds.size(); i++) {
 		const int index = reParamsCmds[i].cmdIndex;
 		if ((index &gt;= 0) &amp;&amp; (index &lt; cmdCount)) {
-			const map&lt;int, string&gt;&amp; params = reParamsCmds[i].params;
-			map&lt;int, string&gt;::const_iterator pit;
+			const map&lt;int, std::string&gt;&amp; params = reParamsCmds[i].params;
+			map&lt;int, std::string&gt;::const_iterator pit;
 			for (pit = params.begin(); pit != params.end(); ++pit) {
 				const int p = pit-&gt;first;
 				if ((p &gt;= 0) &amp;&amp; (p &lt; (int)cmds[index].params.size())) {
@@ -781,7 +781,7 @@
 	}
 
 	// build the iconList from the map
-	vector&lt;int&gt; iconList;
+	std::vector&lt;int&gt; iconList;
 	int nextPos = 0;
 	map&lt;int, int&gt;::iterator mit;
 	for (mit = iconMap.begin(); mit != iconMap.end(); ++mit) {
@@ -848,11 +848,11 @@
 	iconsCount   = tmpIconsCount;
 	iconsPerPage = tmpIconsPerPage;
 
-	maxPage = max(0, pageCount - 1);
+	maxPage = std::max(0, pageCount - 1);
 	if (useSelectionPage) {
-		activePage = min(maxPage, ac.commandPage);
+		activePage = std::min(maxPage, ac.commandPage);
 	} else {
-		activePage = min(maxPage, activePage);
+		activePage = std::min(maxPage, activePage);
 	}
 
 	buttonBox.x1 = xPos;
@@ -884,7 +884,7 @@
 }
 
 
-void CGuiHandler::ConvertCommands(vector&lt;CommandDescription&gt;&amp; cmds)
+void CGuiHandler::ConvertCommands(std::vector&lt;CommandDescription&gt;&amp; cmds)
 {
 	if (newAttackMode) {
 		const int count = (int)cmds.size();
@@ -1241,7 +1241,7 @@
 					&quot;Choose the AI you want to assign to this group.\n&quot;
 					&quot;Select \&quot;None\&quot; to cancel or \&quot;default\&quot; to create a group without an AI\n&quot;
 					&quot;assigned.&quot;;
-				vector&lt;string&gt;::const_iterator pi;
+				std::vector&lt;std::string&gt;::const_iterator pi;
 				for (pi = ++cd.params.begin(); pi != cd.params.end(); ++pi) {
 					list-&gt;AddItem(pi-&gt;c_str(),&quot;&quot;);
 				}
@@ -1329,8 +1329,8 @@
 
 	int xSlot = int((fx - (buttonBox.x1 + frameBorder)) / xIconStep);
 	int ySlot = int(((buttonBox.y2 - frameBorder) - fy) / yIconStep);
-	xSlot = min(max(xSlot, 0), xIcons - 1);
-	ySlot = min(max(ySlot, 0), yIcons - 1);
+	xSlot = std::min(std::max(xSlot, 0), xIcons - 1);
+	ySlot = std::min(std::max(ySlot, 0), yIcons - 1);
   const int ii = (activePage * iconsPerPage) + (ySlot * xIcons) + xSlot;
   if ((ii &gt;= 0) &amp;&amp; (ii &lt; iconsCount)) {
 		if ((fx &gt; icons[ii].selection.x1) &amp;&amp; (fx &lt; icons[ii].selection.x2) &amp;&amp;
@@ -1360,7 +1360,7 @@
 };
 
 
-static bool ParseCustomCmdMods(string&amp; cmd, ModGroup&amp; in, ModGroup&amp; out)
+static bool ParseCustomCmdMods(std::string&amp; cmd, ModGroup&amp; in, ModGroup&amp; out)
 {
 	const char* c = cmd.c_str();
 	if (*c != '@') {
@@ -1417,7 +1417,7 @@
 }
 
 
-void CGuiHandler::RunCustomCommands(const vector&lt;string&gt;&amp; cmds, bool rmb)
+void CGuiHandler::RunCustomCommands(const std::vector&lt;std::string&gt;&amp; cmds, bool rmb)
 {
 	static int depth = 0;
 	if (depth &gt; 8) {
@@ -1426,7 +1426,7 @@
 	depth++;
 
 	for (int p = 0; p &lt; (int)cmds.size(); p++) {
-		string copy = cmds[p];
+		std::string copy = cmds[p];
 		ModGroup inMods;  // must match for the action to execute
 		ModGroup outMods; // controls the state of the modifiers  (ex: &quot;group1&quot;)
 		if (ParseCustomCmdMods(copy, inMods, outMods)) {
@@ -1511,7 +1511,7 @@
 	if (cd.params.size() &gt;= 2) { maxV = atof(cd.params[1].c_str()); }
 	const int minX = (gu-&gt;viewSizeX * 1) / 4;
 	const int maxX = (gu-&gt;viewSizeX * 3) / 4;
-	const int effX = max(min(mouse-&gt;lastx, maxX), minX);
+	const int effX = std::max(std::min(mouse-&gt;lastx, maxX), minX);
 	const float factor = float(effX - minX) / float(maxX - minX);
 
 	return (minV + (factor * (maxV - minV)));
@@ -1610,7 +1610,7 @@
 		const int iconPos = IconAtPos(mouse-&gt;lastx, mouse-&gt;lasty);
 		const int iconCmd = (iconPos &gt;= 0) ? icons[iconPos].commandsID : -1;
 		if ((iconCmd &gt;= 0) &amp;&amp; (iconCmd &lt; commands.size())) {
-			string cmd = &quot;unbindaction &quot; + commands[iconCmd].action;
+			std::string cmd = &quot;unbindaction &quot; + commands[iconCmd].action;
 			keyBindings-&gt;Command(cmd);
 			logOutput.Print(&quot;%s&quot;, cmd.c_str());
 		}
@@ -1655,7 +1655,7 @@
 }
 
 
-void CGuiHandler::RunLayoutCommand(const string&amp; command)
+void CGuiHandler::RunLayoutCommand(const std::string&amp; command)
 {
 	if (command.find(&quot;reload&quot;) == 0) {
 		if (CLuaHandle::GetActiveHandle() != NULL) {
@@ -1708,7 +1708,7 @@
 
 bool CGuiHandler::ProcessBuildActions(const Action&amp; action)
 {
-	const string arg = StringToLower(action.extra);
+	const std::string arg = StringToLower(action.extra);
 	if (action.command == &quot;buildspacing&quot;) {
 		if (arg == &quot;inc&quot;) {
 			buildSpacing++;
@@ -1867,7 +1867,7 @@
 				 (cmdType == CMDTYPE_ICON_BUILDING))) {
 			for (int ii = 0; ii &lt; iconsCount; ii++) {
 				if (icons[ii].commandsID == a) {
-					activePage = min(maxPage, (ii / iconsPerPage));
+					activePage = std::min(maxPage, (ii / iconsPerPage));
 					selectedUnits.SetCommandPage(activePage);
 				}
 			}
@@ -1895,7 +1895,7 @@
 						c.options = RIGHT_MOUSE_KEY | SHIFT_KEY | CONTROL_KEY;
 					}
 				}
-				else if (action.extra.find(&quot;queued&quot;) != string::npos) {
+				else if (action.extra.find(&quot;queued&quot;) != std::string::npos) {
 					c.options |= SHIFT_KEY;
 				}
 				GiveCommand(c);
@@ -1935,10 +1935,10 @@
 					float maxV = 100.0f;
 					if (cd.params.size() &gt;= 1) { minV = atof(cd.params[0].c_str()); }
 					if (cd.params.size() &gt;= 2) { maxV = atof(cd.params[1].c_str()); }
-					value = max(min(value, maxV), minV);
+					value = std::max(std::min(value, maxV), minV);
 					Command c;
 					c.options = 0;
-					if (action.extra.find(&quot;queued&quot;) != string::npos) {
+					if (action.extra.find(&quot;queued&quot;) != std::string::npos) {
 						c.options = SHIFT_KEY;
 					}
 					c.id = cd.id;
@@ -1975,7 +1975,7 @@
 			case CMDTYPE_COMBO_BOX:
 			if (GetInputReceivers().empty() || dynamic_cast&lt;CglList*&gt;(GetInputReceivers().front()) == NULL) {
 				CommandDescription&amp; cd = cmdDesc;
-				vector&lt;string&gt;::iterator pi;
+				std::vector&lt;std::string&gt;::iterator pi;
 				// check for an action bound to a specific entry
 				if (!action.extra.empty() &amp;&amp; (iconCmd &lt; 0)) {
 					int p = 0;
@@ -2051,7 +2051,7 @@
 }
 
 
-void CGuiHandler::MenuChoice(string s)
+void CGuiHandler::MenuChoice(std::string s)
 {
 	if (activeReceiver == list) {
 		activeReceiver = NULL;
@@ -2064,7 +2064,7 @@
 		switch (cd.type) {
 			case CMDTYPE_COMBO_BOX: {
 				inCommand = -1;
-				vector&lt;string&gt;::iterator pi;
+				std::vector&lt;std::string&gt;::iterator pi;
 				int a = 0;
 				for (pi = ++cd.params.begin(); pi != cd.params.end(); ++pi) {
 					if (*pi == s) {
@@ -2110,7 +2110,7 @@
 
 std::string CGuiHandler::GetTooltip(int x, int y)
 {
-	string s;
+	std::string s;
 	if (luaUI != NULL) {
 		s = luaUI-&gt;GetTooltip(x, y);
 		if (!s.empty()) {
@@ -2379,7 +2379,7 @@
 					return defaultRet;
 				}
 				float3 pos2=camera-&gt;pos+mouse-&gt;dir*dist;
-				c.params.push_back(min(maxRadius,pos.distance2D(pos2)));
+				c.params.push_back(std::min(maxRadius,pos.distance2D(pos2)));
 			}
 			CreateOptions(c,(button==SDL_BUTTON_LEFT?0:1));
 			return c;}
@@ -2602,7 +2602,7 @@
 }
 
 
-static string StripColorCodes(const string&amp; text)
+static std::string StripColorCodes(const std::string&amp; text)
 {
 	std::string nocolor;
 	const int len = (int)text.size();
@@ -2617,14 +2617,14 @@
 }
 
 
-static string FindCornerText(const string&amp; corner, const vector&lt;string&gt;&amp; params)
+static std::string FindCornerText(const std::string&amp; corner, const vector&lt;std::string&gt;&amp; params)
 {
 	for (int p = 0; p &lt; (int)params.size(); p++) {
 		if (params[p].find(corner) == 0) {
 			return params[p].substr(corner.length());
 		}
 	}
-	return string(&quot;&quot;);
+	return std::string(&quot;&quot;);
 }
 
 
@@ -2686,8 +2686,8 @@
 }
 
 
-static inline bool ParseTextures(const string&amp; texString,
-                                 string&amp; tex1, string&amp; tex2,
+static inline bool ParseTextures(const std::string&amp; texString,
+                                 std::string&amp; tex1, std::string&amp; tex2,
                                  float&amp; xscale, float&amp; yscale)
 {
 	// format:  &quot;&amp;&lt;xscale&gt;x&lt;yscale&gt;&amp;&lt;tex&gt;1&amp;&lt;tex2&gt;&quot;  --  &lt;&gt;'s are not included
@@ -2707,13 +2707,13 @@
 	const int tex1Len = c - tex1Start;
 	c++;
 	tex1 = c; // draw 'tex2' first
-	tex2 = string(tex1Start, tex1Len);
+	tex2 = std::string(tex1Start, tex1Len);
 
 	return true;
 }
 
 
-static inline bool BindUnitTexByString(const string&amp; str)
+static inline bool BindUnitTexByString(const std::string&amp; str)
 {
 	char* endPtr;
 	const char* startPtr = str.c_str() + 1; // skip the '#'
@@ -2736,7 +2736,7 @@
 }
 
 
-static bool BindTextureString(const string&amp; str)
+static bool BindTextureString(const std::string&amp; str)
 {
 	if (str[0] == '#') {
 		return BindUnitTexByString(str);
@@ -2752,8 +2752,8 @@
 		return false;
 	}
 
-	string tex1;
-	string tex2;
+	std::string tex1;
+	std::string tex2;
 	float xscale = 1.0f;
 	float yscale = 1.0f;
 
@@ -2847,7 +2847,7 @@
 	const float textBorder2 = (2.0f * textBorder);
 	float xScale = (xIconSize - textBorder2) / tWidth;
 	float yScale = (yIconSize - textBorder2 - yShrink) / tHeight;
-	const float fontScale = min(xScale, yScale);
+	const float fontScale = std::min(xScale, yScale);
 
 	const float xCenter = 0.5f * (b.x1 + b.x2);
 	const float yCenter = 0.5f * (b.y1 + (b.y2 + yShrink));
@@ -2967,8 +2967,8 @@
 	}
 
 	const int mouseIcon   = IconAtPos(mouse-&gt;lastx, mouse-&gt;lasty);
-	const int buttonStart = min(iconsCount, activePage * iconsPerPage);
-	const int buttonEnd   = min(iconsCount, buttonStart + iconsPerPage);
+	const int buttonStart = std::min(iconsCount, activePage * iconsPerPage);
+	const int buttonEnd   = std::min(iconsCount, buttonStart + iconsPerPage);
 
 	for (int ii = buttonStart; ii &lt; buttonEnd; ii++) {
 
@@ -3048,7 +3048,7 @@
 			// draw the text
 			if (!usedTexture || !onlyTexture) {
 				// command name (or parameter)
-				string toPrint = cmdDesc.name;
+				std::string toPrint = cmdDesc.name;
 				if (cmdDesc.type == CMDTYPE_ICON_MODE) {
 					const int opt = atoi(cmdDesc.params[0].c_str()) + 1;
 					if (opt &lt; cmdDesc.params.size()) {
@@ -3192,7 +3192,7 @@
 			glDisable(GL_TEXTURE_2D);
 			glColor4f(1.0f, 1.0f, 1.0f, 0.8f);
 			const float mouseX = (float)mouse-&gt;lastx / (float)gu-&gt;viewSizeX;
-			const float slideX = min(max(mouseX, 0.25f), 0.75f);
+			const float slideX = std::min(std::max(mouseX, 0.25f), 0.75f);
 			//const float mouseY = 1.0f - (float)(mouse-&gt;lasty - 16) / (float)gu-&gt;viewSizeY;
 			glColor4f(1.0f, 1.0f, 0.0f, 0.8f);
 			glRectf(0.235f, 0.45f, 0.25f, 0.55f);
@@ -3498,7 +3498,7 @@
 								color = grey;
 							}
 						}
-						const float radius = min(maxRadius, pos.distance2D(pos2));
+						const float radius = std::min(maxRadius, pos.distance2D(pos2));
 						if (!onMinimap) {
 							DrawArea(pos, radius, color);
 						}
@@ -3997,7 +3997,7 @@
 	pos1 += (pos1 - pos2);
 	const int maxSteps = 256;
 	const float frontLen = (pos1 - pos2).Length2D();
-	const int steps = min(maxSteps, max(1, int(frontLen / 16.0f)));
+	const int steps = std::min(maxSteps, std::max(1, int(frontLen / 16.0f)));
 
 	glDisable(GL_FOG);
 	glBegin(GL_QUAD_STRIP);
@@ -4091,10 +4091,10 @@
                                  bool invColorSelect)
 {
 	BoxData boxData;
-	boxData.mins = float3(min(pos0.x, pos1.x), readmap-&gt;minheight - 250.0f,
-                        min(pos0.z, pos1.z));
-	boxData.maxs = float3(max(pos0.x, pos1.x), readmap-&gt;maxheight + 10000.0f,
-	                      max(pos0.z, pos1.z));
+	boxData.mins = float3(std::min(pos0.x, pos1.x), readmap-&gt;minheight - 250.0f,
+                        std::min(pos0.z, pos1.z));
+	boxData.maxs = float3(std::max(pos0.x, pos1.x), readmap-&gt;maxheight + 10000.0f,
+	                      std::max(pos0.z, pos1.z));
 
 	glDisable(GL_TEXTURE_2D);
 	glDisable(GL_FOG);
@@ -4166,10 +4166,10 @@
 		return;
 	}
 
-	const float3 mins(min(pos0.x, pos1.x), readmap-&gt;minheight - 250.0f,
-	                  min(pos0.z, pos1.z));
-	const float3 maxs(max(pos0.x, pos1.x), readmap-&gt;maxheight + 10000.0f,
-	                  max(pos0.z, pos1.z));
+	const float3 mins(std::min(pos0.x, pos1.x), readmap-&gt;minheight - 250.0f,
+	                  std::min(pos0.z, pos1.z));
+	const float3 maxs(std::max(pos0.x, pos1.x), readmap-&gt;maxheight + 10000.0f,
+	                  std::max(pos0.z, pos1.z));
 
 	glDisable(GL_TEXTURE_2D);
 	glDisable(GL_FOG);

Modified: trunk/rts/Game/UI/GuiHandler.h
===================================================================
--- trunk/rts/Game/UI/GuiHandler.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/GuiHandler.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -45,15 +45,15 @@
 		                                   const BuildInfo&amp; endInfo);
 		                                   // start.def has to be end.def
 
-		bool ReloadConfig(const string&amp; filename);
+		bool ReloadConfig(const std::string&amp; filename);
 
 		void ForceLayoutUpdate() { forceLayoutUpdate = true; }
 
 		int GetMaxPage()    const { return maxPage; }
 		int GetActivePage() const { return activePage; }
 
-		void RunLayoutCommand(const string&amp; command);
-		void RunCustomCommands(const vector&lt;string&gt;&amp; cmds, bool rmb);
+		void RunLayoutCommand(const std::string&amp; command);
+		void RunCustomCommands(const std::vector&lt;std::string&gt;&amp; cmds, bool rmb);
 
  		bool GetInvertQueueKey() const { return invertQueueKey; }
  		void SetInvertQueueKey(bool value) { invertQueueKey = value; }
@@ -71,7 +71,7 @@
 		bool SetActiveCommand(const Action&amp; action, const CKeySet&amp; ks, int actionIndex);
 
 	public:
-		vector&lt;CommandDescription&gt; commands;
+		std::vector&lt;CommandDescription&gt; commands;
 		int inCommand;
 		int buildFacing;
 		int buildSpacing;
@@ -79,14 +79,14 @@
 	private:
 		void GiveCommand(const Command&amp; cmd, bool fromUser = true) const;
 
-		void MenuChoice(string s);
+		void MenuChoice(std::string s);
 		static void MenuSelection(std::string s);
 
 		void LayoutIcons(bool useSelectionPage);
 		bool LayoutCustomIcons(bool useSelectionPage);
 		void ResizeIconArray(unsigned int size);
-		void AppendPrevAndNext(vector&lt;CommandDescription&gt;&amp; cmds);
- 		void ConvertCommands(vector&lt;CommandDescription&gt;&amp;);
+		void AppendPrevAndNext(std::vector&lt;CommandDescription&gt;&amp; cmds);
+ 		void ConvertCommands(std::vector&lt;CommandDescription&gt;&amp;);
 
 		int  FindInCommandPage();
 		void RevertToCmdDesc(const CommandDescription&amp; cmdDesc,

Modified: trunk/rts/Game/UI/KeyAutoBinder.h
===================================================================
--- trunk/rts/Game/UI/KeyAutoBinder.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/KeyAutoBinder.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -7,7 +7,6 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &lt;set&gt;
-using namespace std;
 
 #include &quot;Lua/LuaHandle.h&quot;
 

Modified: trunk/rts/Game/UI/KeyBindings.h
===================================================================
--- trunk/rts/Game/UI/KeyBindings.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/KeyBindings.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -14,8 +14,6 @@
 #include &quot;Game/Console.h&quot;
 #include &quot;Game/Action.h&quot;
 
-using namespace std;
-
 class CUnit;
 class CFileHandler;
 class CSimpleParser;
@@ -27,18 +25,18 @@
 		CKeyBindings();
 		~CKeyBindings();
 
-		bool Load(const string&amp; filename);
-		bool Save(const string&amp; filename) const;
+		bool Load(const std::string&amp; filename);
+		bool Save(const std::string&amp; filename) const;
 		void Print() const;
 
-		typedef vector&lt;Action&gt; ActionList;
-		typedef vector&lt;string&gt; HotkeyList;
+		typedef std::vector&lt;Action&gt; ActionList;
+		typedef std::vector&lt;std::string&gt; HotkeyList;
 
 		const ActionList&amp; GetActionList(const CKeySet&amp; ks) const;
-		const HotkeyList&amp; GetHotkeys(const string&amp; action) const;
+		const HotkeyList&amp; GetHotkeys(const std::string&amp; action) const;
 
 		virtual void PushAction(const Action&amp;);
-		bool Command(const string&amp; line);
+		bool Command(const std::string&amp; line);
 
 		int GetFakeMetaKey() const { return fakeMetaKey; }
 
@@ -52,40 +50,40 @@
 		void Sanitize();
 		void BuildHotkeyMap();
 
-		bool Bind(const string&amp; keystring, const string&amp; action);
-		bool UnBind(const string&amp; keystring, const string&amp; action);
-		bool UnBindKeyset(const string&amp; keystr);
-		bool UnBindAction(const string&amp; action);
-		bool SetFakeMetaKey(const string&amp; keystring);
-		bool AddKeySymbol(const string&amp; keysym, const string&amp; code);
-		bool AddNamedKeySet(const string&amp; name, const string&amp; keyset);
-		bool ParseTypeBind(CSimpleParser&amp; parser, const string&amp; line);
+		bool Bind(const std::string&amp; keystring, const std::string&amp; action);
+		bool UnBind(const std::string&amp; keystring, const std::string&amp; action);
+		bool UnBindKeyset(const std::string&amp; keystr);
+		bool UnBindAction(const std::string&amp; action);
+		bool SetFakeMetaKey(const std::string&amp; keystring);
+		bool AddKeySymbol(const std::string&amp; keysym, const std::string&amp; code);
+		bool AddNamedKeySet(const std::string&amp; name, const std::string&amp; keyset);
+		bool ParseTypeBind(CSimpleParser&amp; parser, const std::string&amp; line);
 
-		bool ParseKeySet(const string&amp; keystr, CKeySet&amp; ks) const;
-		bool RemoveCommandFromList(ActionList&amp; al, const string&amp; command);
+		bool ParseKeySet(const std::string&amp; keystr, CKeySet&amp; ks) const;
+		bool RemoveCommandFromList(ActionList&amp; al, const std::string&amp; command);
 
 		bool FileSave(FILE* file) const;
 
 	protected:
-		typedef map&lt;CKeySet, ActionList&gt; KeyMap; // keyset to action
+		typedef std::map&lt;CKeySet, ActionList&gt; KeyMap; // keyset to action
 		KeyMap bindings;
 
-		typedef map&lt;string, HotkeyList&gt; ActionMap; // action to keyset
+		typedef std::map&lt;std::string, HotkeyList&gt; ActionMap; // action to keyset
 		ActionMap hotkeys;
 
-		typedef map&lt;string, CKeySet&gt; NamedKeySetMap; // user defined keysets
+		typedef std::map&lt;std::string, CKeySet&gt; NamedKeySetMap; // user defined keysets
 		NamedKeySetMap namedKeySets;
 
 		struct BuildTypeBinding {
-			string keystr;         // principal keyset
-			vector&lt;string&gt; reqs;   // requirements
-			vector&lt;string&gt; sorts;  // sorting criteria
-			vector&lt;string&gt; chords; // enumerated keyset chords
+			std::string keystr;         // principal keyset
+			std::vector&lt;std::string&gt; reqs;   // requirements
+			std::vector&lt;std::string&gt; sorts;  // sorting criteria
+			std::vector&lt;std::string&gt; chords; // enumerated keyset chords
 		};
-		vector&lt;BuildTypeBinding&gt; typeBindings;
+		std::vector&lt;BuildTypeBinding&gt; typeBindings;
 
 		// commands that use both Up and Down key presses
-		set&lt;string&gt; statefulCommands;
+		std::set&lt;std::string&gt; statefulCommands;
 
 		int debug;
 		int fakeMetaKey;

Modified: trunk/rts/Game/UI/KeyCodes.cpp
===================================================================
--- trunk/rts/Game/UI/KeyCodes.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/KeyCodes.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -13,9 +13,9 @@
 CKeyCodes* keyCodes = NULL;
 
 
-int CKeyCodes::GetCode(const string&amp; name) const
+int CKeyCodes::GetCode(const std::string&amp; name) const
 {
-	map&lt;string, int&gt;::const_iterator it = nameToCode.find(name);
+	std::map&lt;std::string, int&gt;::const_iterator it = nameToCode.find(name);
 	if (it == nameToCode.end()) {
 		return -1;
 	}
@@ -23,9 +23,9 @@
 }
 
 
-string CKeyCodes::GetName(int code) const
+std::string CKeyCodes::GetName(int code) const
 {
-	map&lt;int, string&gt;::const_iterator it = codeToName.find(code);
+	std::map&lt;int, std::string&gt;::const_iterator it = codeToName.find(code);
 	if (it == codeToName.end()) {
 		char buf[64];
 		SNPRINTF(buf, sizeof(buf), &quot;0x%03X&quot;, code);
@@ -35,9 +35,9 @@
 }
 
 
-string CKeyCodes::GetDefaultName(int code) const
+std::string CKeyCodes::GetDefaultName(int code) const
 {
-	map&lt;int, string&gt;::const_iterator it = defaultCodeToName.find(code);
+	std::map&lt;int, std::string&gt;::const_iterator it = defaultCodeToName.find(code);
 	if (it == defaultCodeToName.end()) {
 		char buf[64];
 		SNPRINTF(buf, sizeof(buf), &quot;0x%03X&quot;, code);
@@ -47,16 +47,16 @@
 }
 
 
-bool CKeyCodes::AddKeySymbol(const string&amp; name, int code)
+bool CKeyCodes::AddKeySymbol(const std::string&amp; name, int code)
 {
 	if ((code &lt; 0) || !IsValidLabel(name)) {
 		return false;
 	}
 	
-	const string keysym = StringToLower(name);
+	const std::string keysym = StringToLower(name);
 
 	// do not allow existing keysyms to be renamed
-	map&lt;string, int&gt;::const_iterator name_it = nameToCode.find(keysym);
+	std::map&lt;std::string, int&gt;::const_iterator name_it = nameToCode.find(keysym);
 	if (name_it != nameToCode.end()) {
 		return false;
 	}
@@ -68,7 +68,7 @@
 }
 
 
-bool CKeyCodes::IsValidLabel(const string&amp; label)
+bool CKeyCodes::IsValidLabel(const std::string&amp; label)
 {
 	if (label.empty()) {
 		return false;
@@ -99,7 +99,7 @@
 }
 
 
-void CKeyCodes::AddPair(const string&amp; name, int code)
+void CKeyCodes::AddPair(const std::string&amp; name, int code)
 {
 	if (nameToCode.find(name) == nameToCode.end()) {
 		nameToCode[name] = code;
@@ -135,7 +135,7 @@
 	// ASCII mapped keysyms
 	for (unsigned char i = ' '; i &lt;= '~'; ++i) {
 		if (!isupper(i)) {
-			AddPair(string(1, i), i);
+			AddPair(std::string(1, i), i);
 		}
 	}
 
@@ -242,7 +242,7 @@
 
 void CKeyCodes::PrintNameToCode() const
 {
-	map&lt;string, int&gt;::const_iterator it;
+	std::map&lt;std::string, int&gt;::const_iterator it;
 	for (it = nameToCode.begin(); it != nameToCode.end(); ++it) {
 		logOutput.Print(&quot;KEYNAME: %13s = 0x%03X\n&quot;, it-&gt;first.c_str(), it-&gt;second);
 	}
@@ -251,7 +251,7 @@
 
 void CKeyCodes::PrintCodeToName() const
 {
-	map&lt;int, string&gt;::const_iterator it;
+	std::map&lt;int, std::string&gt;::const_iterator it;
 	for (it = codeToName.begin(); it != codeToName.end(); ++it) {
 		logOutput.Print(&quot;KEYCODE: 0x%03X = '%s'\n&quot;, it-&gt;first, it-&gt;second.c_str());
 	}
@@ -261,15 +261,15 @@
 void CKeyCodes::SaveUserKeySymbols(FILE* file) const
 {
 	bool output = false;
-	map&lt;string, int&gt;::const_iterator user_it;
+	std::map&lt;std::string, int&gt;::const_iterator user_it;
 	for (user_it = nameToCode.begin(); user_it != nameToCode.end(); ++user_it) {
-		map&lt;string, int&gt;::const_iterator def_it;
-		const string&amp; keysym = user_it-&gt;first;
+		std::map&lt;std::string, int&gt;::const_iterator def_it;
+		const std::string&amp; keysym = user_it-&gt;first;
 		def_it = defaultNameToCode.find(keysym);
 		if (def_it == defaultNameToCode.end()) {
 			// this keysym is not standard
 			const int code = user_it-&gt;second;
-			string name = GetDefaultName(code);
+			std::string name = GetDefaultName(code);
 			if (name.empty()) {
 				char buf[16];
 				SNPRINTF(buf, 16, &quot;0x%03X&quot;, code);

Modified: trunk/rts/Game/UI/KeyCodes.h
===================================================================
--- trunk/rts/Game/UI/KeyCodes.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/KeyCodes.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -8,20 +8,17 @@
 #include &lt;string&gt;
 #include &lt;map&gt;
 
-using namespace std;
-
-
 class CKeyCodes {
 	public:
 		CKeyCodes();
 		void Reset();
 
-		int GetCode(const string&amp; name) const;
+		int GetCode(const std::string&amp; name) const;
 
-		string GetName(int code) const;
-		string GetDefaultName(int code) const;
+		std::string GetName(int code) const;
+		std::string GetDefaultName(int code) const;
 
-		bool AddKeySymbol(const string&amp; name, int code);
+		bool AddKeySymbol(const std::string&amp; name, int code);
 
 		bool IsModifier(int code) const;
 
@@ -31,16 +28,16 @@
 		void SaveUserKeySymbols(FILE* file) const;
 
 	public:
-		static bool IsValidLabel(const string&amp; label);
+		static bool IsValidLabel(const std::string&amp; label);
 
 	protected:
-		void AddPair(const string&amp; name, int code);
+		void AddPair(const std::string&amp; name, int code);
 
 	protected:
-		map&lt;string, int&gt; nameToCode;
-		map&lt;int, string&gt; codeToName;
-		map&lt;string, int&gt; defaultNameToCode;
-		map&lt;int, string&gt; defaultCodeToName;
+		std::map&lt;std::string, int&gt; nameToCode;
+		std::map&lt;int, std::string&gt; codeToName;
+		std::map&lt;std::string, int&gt; defaultNameToCode;
+		std::map&lt;int, std::string&gt; defaultCodeToName;
 };
 
 extern CKeyCodes* keyCodes;

Modified: trunk/rts/Game/UI/KeySet.cpp
===================================================================
--- trunk/rts/Game/UI/KeySet.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/KeySet.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -56,16 +56,16 @@
 }
 
 
-string CKeySet::GetString(bool useDefaultKeysym) const
+std::string CKeySet::GetString(bool useDefaultKeysym) const
 {
-	string name;
+	std::string name;
 	if (useDefaultKeysym) {
 		name = keyCodes-&gt;GetDefaultName(key);
 	} else {
 		name = keyCodes-&gt;GetName(key);
 	}
 	
-	string modstr;
+	std::string modstr;
 #ifndef DISALLOW_RELEASE_BINDINGS
 	if (modifiers &amp; KS_RELEASE) { modstr += &quot;Up+&quot;; }
 #endif
@@ -79,7 +79,7 @@
 }
 
 
-bool CKeySet::ParseModifier(string&amp; s, const string&amp; token, const string&amp; abbr)
+bool CKeySet::ParseModifier(std::string&amp; s, const std::string&amp; token, const std::string&amp; abbr)
 {
 	if (s.find(token) == 0) {
 		s.erase(0, token.size());
@@ -94,11 +94,11 @@
 }
 
 
-bool CKeySet::Parse(const string&amp; token)
+bool CKeySet::Parse(const std::string&amp; token)
 {
 	Reset();
 
-	string s = StringToLower(token);
+	std::string s = StringToLower(token);
 
 	// parse the modifiers
 	while (!s.empty()) {

Modified: trunk/rts/Game/UI/KeySet.h
===================================================================
--- trunk/rts/Game/UI/KeySet.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/KeySet.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -7,9 +7,7 @@
 #include &lt;string&gt;
 #include &lt;map&gt;
 
-using namespace std;
 
-
 class CKeySet {
 	public:
 		CKeySet() { Reset(); }
@@ -18,9 +16,9 @@
 		void Reset();
 		void SetAnyBit();
 		void ClearModifiers();
-		bool Parse(const string&amp; token);
+		bool Parse(const std::string&amp; token);
 
-		string GetString(bool useDefaultKeysym) const;
+		std::string GetString(bool useDefaultKeysym) const;
 
 		enum CKeySetModifiers {
 			KS_ALT     = (1 &lt;&lt; 0),
@@ -59,7 +57,7 @@
 		}
 
 	protected:
-		bool ParseModifier(string&amp; s, const string&amp; token, const string&amp; abbr);
+		bool ParseModifier(std::string&amp; s, const std::string&amp; token, const std::string&amp; abbr);
 
 	protected:
 		int key;

Modified: trunk/rts/Game/UI/LuaUI.h
===================================================================
--- trunk/rts/Game/UI/LuaUI.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/LuaUI.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -8,7 +8,6 @@
 #include &lt;vector&gt;
 #include &lt;map&gt;
 #include &quot;SDL_types.h&quot;
-using namespace std;
 
 #include &quot;Lua/LuaHandle.h&quot;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;

Modified: trunk/rts/Game/UI/MiniMap.cpp
===================================================================
--- trunk/rts/Game/UI/MiniMap.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/MiniMap.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -103,7 +103,7 @@
 
 	unitBaseSize =
 		atof(configHandler.GetString(&quot;MiniMapUnitSize&quot;, &quot;2.5&quot;).c_str());
-	unitBaseSize = max(0.0f, unitBaseSize);
+	unitBaseSize = std::max(0.0f, unitBaseSize);
 
 	unitExponent =
 		atof(configHandler.GetString(&quot;MiniMapUnitExp&quot;, &quot;0.25&quot;).c_str());
@@ -113,7 +113,7 @@
 
 	useIcons = !!configHandler.GetInt(&quot;MiniMapIcons&quot;, 1);
 
-	drawCommands = max(0, configHandler.GetInt(&quot;MiniMapDrawCommands&quot;, 1));
+	drawCommands = std::max(0, configHandler.GetInt(&quot;MiniMapDrawCommands&quot;, 1));
 
 	simpleColors = !!configHandler.GetInt(&quot;SimpleMiniMapColors&quot;, 0);
 
@@ -341,12 +341,12 @@
 		if (words.size() &gt;= 2) {
 			unitBaseSize = atof(words[1].c_str());
 		}
-		unitBaseSize = max(0.0f, unitBaseSize);
+		unitBaseSize = std::max(0.0f, unitBaseSize);
 		UpdateGeometry();
 	}
 	else if (command == &quot;drawcommands&quot;) {
 		if (words.size() &gt;= 2) {
-			drawCommands = max(0, atoi(words[1].c_str()));
+			drawCommands = std::max(0, atoi(words[1].c_str()));
 
 		} else {
 			drawCommands = (drawCommands &gt; 0) ? 0 : 1;
@@ -462,13 +462,13 @@
 	if (mouseMove) {
 		xpos += dx;
 		ypos -= dy;
-		xpos = max(0, xpos);
+		xpos = std::max(0, xpos);
 		if (gu-&gt;dualScreenMode) {
-			xpos = min((2 * gu-&gt;viewSizeX) - width, xpos);
+			xpos = std::min((2 * gu-&gt;viewSizeX) - width, xpos);
 		} else {
-			xpos = min(gu-&gt;viewSizeX - width, xpos);
+			xpos = std::min(gu-&gt;viewSizeX - width, xpos);
 		}
-		ypos = max(5, min(gu-&gt;viewSizeY - height, ypos));
+		ypos = std::max(5, std::min(gu-&gt;viewSizeY - height, ypos));
 		UpdateGeometry();
 		return;
 	}
@@ -477,18 +477,18 @@
 		ypos   -= dy;
 		width  += dx;
 		height += dy;
-		height = min(gu-&gt;viewSizeY, height);
+		height = std::min(gu-&gt;viewSizeY, height);
 		if (gu-&gt;dualScreenMode) {
-			width = min(2 * gu-&gt;viewSizeX, width);
+			width = std::min(2 * gu-&gt;viewSizeX, width);
 		} else {
-			width = min(gu-&gt;viewSizeX, width);
+			width = std::min(gu-&gt;viewSizeX, width);
 		}
 		if (keys[SDLK_LSHIFT]) {
 			width = (height * gs-&gt;mapx) / gs-&gt;mapy;
 		}
-		width = max(5, width);
-		height = max(5, height);
-		ypos = min(gu-&gt;viewSizeY - height, ypos);
+		width = std::max(5, width);
+		height = std::max(5, height);
+		ypos = std::min(gu-&gt;viewSizeY - height, ypos);
 		UpdateGeometry();
 		return;
 	}
@@ -560,11 +560,11 @@
 		SetMaximizedGeometry();
 	}
 	else {
-		width = max(1, min(width, gu-&gt;viewSizeX));
-		height = max(1, min(height, gu-&gt;viewSizeY));
-		ypos = max(slaveDrawMode ? 0 : buttonSize, ypos);
-		ypos = min(gu-&gt;viewSizeY - height, ypos);
-		xpos = max(0, min(gu-&gt;viewSizeX - width, xpos));
+		width = std::max(1, std::min(width, gu-&gt;viewSizeX));
+		height = std::max(1, std::min(height, gu-&gt;viewSizeY));
+		ypos = std::max(slaveDrawMode ? 0 : buttonSize, ypos);
+		ypos = std::min(gu-&gt;viewSizeY - height, ypos);
+		xpos = std::max(0, std::min(gu-&gt;viewSizeX - width, xpos));
 	}
 	lastWindowSizeX = gu-&gt;viewSizeX;
 	lastWindowSizeY = gu-&gt;viewSizeY;
@@ -657,10 +657,10 @@
 		// use a selection box
 		const float3 newPos = GetMapPosition(x, y);
 		const float3 oldPos = GetMapPosition(bp.x, bp.y);
-		const float xmin = min(oldPos.x, newPos.x);
-		const float xmax = max(oldPos.x, newPos.x);
-		const float zmin = min(oldPos.z, newPos.z);
-		const float zmax = max(oldPos.z, newPos.z);
+		const float xmin = std::min(oldPos.x, newPos.x);
+		const float xmax = std::max(oldPos.x, newPos.x);
+		const float zmin = std::min(oldPos.z, newPos.z);
+		const float zmax = std::max(oldPos.z, newPos.z);
 
 		CUnitSet::iterator ui;
 		CUnitSet&amp; selection = selectedUnits.selectedUnits;
@@ -945,7 +945,7 @@
 	const float xPixels = radius * float(width) / float(gs-&gt;mapx * SQUARE_SIZE);
 	const float yPixels = radius * float(height) / float(gs-&gt;mapy * SQUARE_SIZE);
 	const int lod = (int)(0.25 * log2(1.0f + (xPixels * yPixels)));
-	const int lodClamp = max(0, min(circleListsCount - 1, lod));
+	const int lodClamp = std::max(0, std::min(circleListsCount - 1, lod));
 	glCallList(circleLists + lodClamp);
 
 	glPopMatrix();
@@ -1006,8 +1006,8 @@
 	glScalef(+1.0f / (gs-&gt;mapx * SQUARE_SIZE), -1.0f / (gs-&gt;mapy * SQUARE_SIZE), 1.0);
 
 	// draw the units
-	list&lt;CUnit*&gt;::iterator ui;
-	for(ui=uh-&gt;activeUnits.begin();ui!=uh-&gt;activeUnits.end();ui++){
+	std::list&lt;CUnit*&gt;::iterator ui;
+	for (ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ui++) {
 		DrawUnit(*ui);
 	}
 
@@ -1494,7 +1494,7 @@
 {
 	const float baseSize = gs-&gt;mapx * SQUARE_SIZE;
 	glBegin(GL_LINES);
-	list&lt;Notification&gt;::iterator ni = notes.begin();
+	std::list&lt;Notification&gt;::iterator ni = notes.begin();
 	while (ni != notes.end()) {
 		const float age = gu-&gt;gameTime - ni-&gt;creationTime;
 		if (age &gt; 2) {

Modified: trunk/rts/Game/UI/MouseCursor.cpp
===================================================================
--- trunk/rts/Game/UI/MouseCursor.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/MouseCursor.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -50,8 +50,8 @@
 		frame.startTime = animPeriod;
 		animPeriod += frame.length;
 		frame.endTime = animPeriod;
-		xmaxsize = max(frame.image.xOrigSize, xmaxsize);
-		ymaxsize = max(frame.image.yOrigSize, ymaxsize);
+		xmaxsize = std::max(frame.image.xOrigSize, xmaxsize);
+		ymaxsize = std::max(frame.image.yOrigSize, ymaxsize);
 	}
 
 	if (hotSpot == TopLeft) {
@@ -66,7 +66,7 @@
 
 CMouseCursor::~CMouseCursor(void)
 {
-	vector&lt;ImageData&gt;::iterator it;
+	std::vector&lt;ImageData&gt;::iterator it;
 	for (it = images.begin(); it != images.end(); ++it) {
 		glDeleteTextures(1, &amp;it-&gt;texture);
 	}
@@ -83,20 +83,20 @@
 
 	CSimpleParser parser(specFH);
 	int lastFrame = 123456789;
-	map&lt;string, int&gt; imageIndexMap;
+	std::map&lt;std::string, int&gt; imageIndexMap;
 
 	while (true) {
 		const string line = parser.GetCleanLine();
 		if (line.empty()) {
 			break;
 		}
-		const vector&lt;string&gt; words = parser.Tokenize(line, 2);
-		const string command = StringToLower(words[0]);
+		const std::vector&lt;std::string&gt; words = parser.Tokenize(line, 2);
+		const std::string command = StringToLower(words[0]);
 
 		if ((command == &quot;frame&quot;) &amp;&amp; (words.size() &gt;= 2)) {
-			const string imageName = words[1];
-			const float length = max(minFrameLength, (float)atof(words[2].c_str()));
-			map&lt;string, int&gt;::iterator iit = imageIndexMap.find(imageName);
+			const std::string imageName = words[1];
+			const float length = std::max(minFrameLength, (float)atof(words[2].c_str()));
+			std::map&lt;std::string, int&gt;::iterator iit = imageIndexMap.find(imageName);
 			if (iit != imageIndexMap.end()) {
 				FrameData frame(images[iit-&gt;second], length);
 				frames.push_back(frame);

Modified: trunk/rts/Game/UI/MouseCursor.h
===================================================================
--- trunk/rts/Game/UI/MouseCursor.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/MouseCursor.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -5,8 +5,6 @@
 #include &lt;vector&gt;
 #include &quot;Rendering/GL/myGL.h&quot;
 
-using namespace std;
-
 class CBitmap;
 
 
@@ -14,7 +12,7 @@
 	public:
 		enum HotSpot {TopLeft, Center};
 
-		static CMouseCursor* New(const string &amp;name, HotSpot hs);
+		static CMouseCursor* New(const std::string &amp;name, HotSpot hs);
 
 		~CMouseCursor(void);
 
@@ -44,18 +42,18 @@
 		};
 
 	protected:	
-		CMouseCursor(const string &amp;name, HotSpot hs);
-		bool LoadCursorImage(const string&amp; name, struct ImageData&amp; image);
-		bool BuildFromSpecFile(const string&amp; name);
-		bool BuildFromFileNames(const string&amp; name, int lastFrame);
+		CMouseCursor(const std::string &amp;name, HotSpot hs);
+		bool LoadCursorImage(const std::string&amp; name, struct ImageData&amp; image);
+		bool BuildFromSpecFile(const std::string&amp; name);
+		bool BuildFromFileNames(const std::string&amp; name, int lastFrame);
 		CBitmap* getAlignedBitmap(const CBitmap &amp;orig);
 		void setBitmapTransparency(CBitmap &amp;bm, int r, int g, int b);
 
 	protected:	
 		HotSpot hotSpot;
 
-		vector&lt;ImageData&gt; images;
-		vector&lt;FrameData&gt; frames;
+		std::vector&lt;ImageData&gt; images;
+		std::vector&lt;FrameData&gt; frames;
 
 		float animTime;
 		float animPeriod;

Modified: trunk/rts/Game/UI/MouseHandler.cpp
===================================================================
--- trunk/rts/Game/UI/MouseHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/MouseHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -81,7 +81,7 @@
 	doubleClickTime = (float)configHandler.GetInt(&quot;DoubleClickTime&quot;, 200) / 1000.0f;
 
 	scrollWheelSpeed = (float)configHandler.GetInt(&quot;ScrollWheelSpeed&quot;, 25);
-	scrollWheelSpeed = max(-255.0f, min(255.0f, scrollWheelSpeed));
+	scrollWheelSpeed = std::max(-255.0f, std::min(255.0f, scrollWheelSpeed));
 }
 
 CMouseHandler::~CMouseHandler()

Modified: trunk/rts/Game/UI/MouseHandler.h
===================================================================
--- trunk/rts/Game/UI/MouseHandler.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/MouseHandler.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -74,8 +74,8 @@
 	                       const std::string&amp; fileName,
 	                       CMouseCursor::HotSpot hotSpot,
 	                       bool overwrite);
-	bool ReplaceMouseCursor(const string&amp; oldName,
-	                        const string&amp; newName,
+	bool ReplaceMouseCursor(const std::string&amp; oldName,
+	                        const std::string&amp; newName,
 	                        CMouseCursor::HotSpot hotSpot);
 	void SafeDeleteCursor(CMouseCursor* cursor);
 

Modified: trunk/rts/Game/UI/QuitBox.cpp
===================================================================
--- trunk/rts/Game/UI/QuitBox.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/QuitBox.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -138,7 +138,7 @@
 		else
 			teamName = &quot;uncontrolled&quot;;
 
-		string ally, dead;
+		std::string ally, dead;
 		if (gs-&gt;Ally(gu-&gt;myAllyTeam, gs-&gt;AllyTeam(actualTeam))) {
 			ally = &quot; &lt;Ally&gt;)&quot;;
 		} else {

Modified: trunk/rts/Game/UI/ResourceBar.cpp
===================================================================
--- trunk/rts/Game/UI/ResourceBar.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/ResourceBar.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -36,7 +36,7 @@
 }
 
 
-static string FloatToSmallString(float num,float mul=1){
+static std::string FloatToSmallString(float num, float mul = 1) {
 	char c[50];
 
 	if(num==0)
@@ -243,13 +243,13 @@
 		moveBox=true;
 		if(!gu-&gt;spectating){
 			if(InBox(mx,my,box+metalBox)){
-				moveBox=false;
-				float metalShare=max(0.f,min(1.f,(mx-(box.x1+metalBox.x1))/(metalBox.x2-metalBox.x1)));
+				moveBox = false;
+				float metalShare = std::max(0.f, std::min(1.f,(mx-(box.x1+metalBox.x1))/(metalBox.x2-metalBox.x1)));
 				net-&gt;SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, metalShare, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare);
 			}
 			if(InBox(mx,my,box+energyBox)){
-				moveBox=false;
-				float energyShare=max(0.f,min(1.f,(mx-(box.x1+energyBox.x1))/(energyBox.x2-energyBox.x1)));
+				moveBox = false;
+				float energyShare = std::max(0.f, std::min(1.f,(mx-(box.x1+energyBox.x1))/(energyBox.x2-energyBox.x1)));
 				net-&gt;SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, gs-&gt;Team(gu-&gt;myTeam)-&gt;metalShare, energyShare);
 			}
 		}

Modified: trunk/rts/Game/UI/SelectionKeyHandler.cpp
===================================================================
--- trunk/rts/Game/UI/SelectionKeyHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/SelectionKeyHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -34,13 +34,13 @@
 
 	while(ifs.peek()!=EOF &amp;&amp; !ifs.eof()){
 		ifs &gt;&gt; buf;
-		string key(buf);
+		std::string key(buf);
 
 		if(ifs.peek()==EOF || ifs.eof())
 			break;
 
 		ifs &gt;&gt; buf;
-		string sel(buf);
+		std::string sel(buf);
 
 		HotKey hk;
 
@@ -50,7 +50,7 @@
 		hk.alt=false;
 
 		while(true){
-			string s=ReadToken(key);
+			std::string s=ReadToken(key);
 
 			if(s==&quot;Shift&quot;){
 				hk.shift=true;
@@ -96,9 +96,9 @@
 	return false;
 }
 
-string CSelectionKeyHandler::ReadToken(string&amp; s)
+std::string CSelectionKeyHandler::ReadToken(std::string&amp; s)
 {
-	string ret;
+	std::string ret;
 	// change made.  avoiding repeated substr calls...
 /*	int index = 0;
 	//char c=s[index];
@@ -109,14 +109,14 @@
 	if ( index == s.length() )
 		s.clear();
 	else
-		s = s.substr(index, string::npos);
+		s = s.substr(index, std::string::npos);
 */
 	if (s.empty())
-		return string();
+		return std::string();
 
 	char c=s[0];
 	while(c &amp;&amp; c!='_' &amp;&amp; c!='+'){
-		s=s.substr(1,string::npos);
+		s=s.substr(1,std::string::npos);
 		ret+=c;
 		c=s[0];
 	}
@@ -125,11 +125,11 @@
 }
 
 
-string CSelectionKeyHandler::ReadDelimiter(string&amp; s)
+std::string CSelectionKeyHandler::ReadDelimiter(std::string&amp; s)
 {
-	string ret = s.substr(0, 1);
+	std::string ret = s.substr(0, 1);
 	if (s.size() &gt;= 1) {
-		s = s.substr(1, string::npos);
+		s = s.substr(1, std::string::npos);
 	} else {
 		s = &quot;&quot;;
 	}
@@ -137,12 +137,12 @@
 }
 
 
-void CSelectionKeyHandler::DoSelection(string selectString)
+void CSelectionKeyHandler::DoSelection(std::string selectString)
 {
-	list&lt;CUnit*&gt; selection;
+	std::list&lt;CUnit*&gt; selection;
 
 //	guicontroller-&gt;AddText(selectString.c_str());
-	string s=ReadToken(selectString);
+	std::string s=ReadToken(selectString);
 
 	if(s==&quot;AllMap&quot;){
 		if (!gu-&gt;spectatingFullSelect) {
@@ -153,8 +153,8 @@
 			}
 		} else {
 			// all units
-			list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
-			for(list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
+			std::list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
+			for (std::list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
 				selection.push_back(*ui);
 			}
 		}
@@ -162,16 +162,16 @@
 		if (!gu-&gt;spectatingFullSelect) {
 			// team units in viewport
 			CUnitSet* tu=&amp;gs-&gt;Team(gu-&gt;myTeam)-&gt;units;
-			for(CUnitSet::iterator ui=tu-&gt;begin();ui!=tu-&gt;end();++ui){
-				if(camera-&gt;InView((*ui)-&gt;midPos,(*ui)-&gt;radius)){
+			for (CUnitSet::iterator ui=tu-&gt;begin();ui!=tu-&gt;end();++ui){
+				if (camera-&gt;InView((*ui)-&gt;midPos,(*ui)-&gt;radius)){
 					selection.push_back(*ui);
 				}
 			}
 		} else {
 		  // all units in viewport
-			list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
-			for(list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
-				if(camera-&gt;InView((*ui)-&gt;midPos,(*ui)-&gt;radius)){
+			std::list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
+			for (std::list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
+				if (camera-&gt;InView((*ui)-&gt;midPos,(*ui)-&gt;radius)){
 					selection.push_back(*ui);
 				}
 			}
@@ -193,8 +193,8 @@
 			}
 		} else {
 		  // all units in mouse range
-			list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
-			for(list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
+			std::list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
+			for(std::list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
 				if(mp.distance((*ui)-&gt;pos)&lt;maxDist){
 					selection.push_back(*ui);
 				}
@@ -213,7 +213,7 @@
 	ReadDelimiter(selectString);
 
 	while(true){
-		string s=ReadDelimiter(selectString);
+		std::string s=ReadDelimiter(selectString);
 		if(s==&quot;+&quot;)
 			break;
 
@@ -228,7 +228,7 @@
 		}
 
 		if(s==&quot;Builder&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if((*ui)-&gt;unitDef-&gt;buildSpeed&gt;0){
@@ -237,12 +237,12 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Building&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if(dynamic_cast&lt;CBuilding*&gt;(*ui)){
@@ -251,58 +251,58 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Commander&quot;){
 			unsigned int comCat=CCategoryHandler::Instance()-&gt;GetCategory(&quot;COMMANDER&quot;);
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui!=selection.end()) {
 				bool filterTrue=false;
-				if((*ui)-&gt;category &amp; comCat){	//fix with better test for commander
+				if ((*ui)-&gt;category &amp; comCat){	//fix with better test for commander
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not) {
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Transport&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if((*ui)-&gt;unitDef-&gt;transportCapacity&gt;0){
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not) {
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Aircraft&quot;){
 			unsigned int acCat=CCategoryHandler::Instance()-&gt;GetCategory(&quot;VTOL&quot;);
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
-				if((*ui)-&gt;category &amp; acCat){
+				if ((*ui)-&gt;category &amp; acCat){
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not) {
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Weapons&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if(!(*ui)-&gt;weapons.empty()){
@@ -311,7 +311,7 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
@@ -319,16 +319,16 @@
 			ReadDelimiter(selectString);
 			float minRange=atof(ReadToken(selectString).c_str());
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
-				if((*ui)-&gt;maxRange&gt;minRange){
+				if ((*ui)-&gt;maxRange&gt;minRange) {
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not) {
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
@@ -336,16 +336,16 @@
 			ReadDelimiter(selectString);
 			float minHealth=atof(ReadToken(selectString).c_str());
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
-				if((*ui)-&gt;health&gt;minHealth){
+				if ((*ui)-&gt;health&gt;minHealth){
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
@@ -353,7 +353,7 @@
 			ReadDelimiter(selectString);
 			float minHealth=atof(ReadToken(selectString).c_str())*0.01f;//convert from percent
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if((*ui)-&gt;health/(*ui)-&gt;maxHealth &gt; minHealth){
@@ -362,18 +362,18 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;InPrevSel&quot;){
-			set&lt;int&gt; prevTypes;
+			std::set&lt;int&gt; prevTypes;
 			CUnitSet* tu=&amp;selectedUnits.selectedUnits;
-			for(CUnitSet::iterator si=tu-&gt;begin();si!=tu-&gt;end();++si){
+			for (CUnitSet::iterator si=tu-&gt;begin();si!=tu-&gt;end();++si){
 				prevTypes.insert((*si)-&gt;aihint);
 			}
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if(prevTypes.find((*ui)-&gt;aihint)!=prevTypes.end()){		//should move away from aihint
 					filterTrue=true;
@@ -381,30 +381,30 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;NameContain&quot;){
 			ReadDelimiter(selectString);
-			string name=ReadToken(selectString);
+			std::string name=ReadToken(selectString);
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
-				if((*ui)-&gt;unitDef-&gt;humanName.find(name)!=string::npos){
+				if ((*ui)-&gt;unitDef-&gt;humanName.find(name)!=std::string::npos){
 					filterTrue=true;
 				}
-				if(filterTrue ^ _not){
+				if (filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Idle&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if((*ui)-&gt;commandAI-&gt;commandQue.empty()){
 					filterTrue=true;
@@ -412,13 +412,13 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Waiting&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if(!(*ui)-&gt;commandAI-&gt;commandQue.empty() &amp;&amp;
 				   ((*ui)-&gt;commandAI-&gt;commandQue.front().id == CMD_WAIT)){
@@ -427,13 +427,13 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;InHotkeyGroup&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if((*ui)-&gt;group){
 					filterTrue=true;
@@ -441,13 +441,13 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
-		} else if(s==&quot;Radar&quot;){
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
-			while(ui!=selection.end()){
+		} else if (s == &quot;Radar&quot;) {
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			while (ui != selection.end()) {
 				bool filterTrue=false;
 				if((*ui)-&gt;radarRadius || (*ui)-&gt;sonarRadius || (*ui)-&gt;jammerRadius){
 					filterTrue=true;
@@ -455,16 +455,16 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
 		} else if(s==&quot;Category&quot;){
 			ReadDelimiter(selectString);
-			string catname=ReadToken(selectString);
+			std::string catname=ReadToken(selectString);
 			unsigned int cat=CCategoryHandler::Instance()-&gt;GetCategory(catname);
 
-			list&lt;CUnit*&gt;::iterator ui=selection.begin();
+			std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
 			while(ui!=selection.end()){
 				bool filterTrue=false;
 				if((*ui)-&gt;category==cat){
@@ -473,7 +473,7 @@
 				if(filterTrue ^ _not){
 					++ui;
 				} else {
-					list&lt;CUnit*&gt;::iterator prev=ui++;
+					std::list&lt;CUnit*&gt;::iterator prev=ui++;
 					selection.erase(prev);
 				}
 			}
@@ -495,7 +495,7 @@
 	}
 
 	if(s==&quot;SelectAll&quot;){
-		for(list&lt;CUnit*&gt;::iterator ui=selection.begin();ui!=selection.end();++ui)
+		for (std::list&lt;CUnit*&gt;::iterator ui=selection.begin();ui!=selection.end();++ui)
 			selectedUnits.AddUnit(*ui);
 	} else if(s==&quot;SelectOne&quot;){
 		if(selection.empty())
@@ -505,7 +505,7 @@
 
 		CUnit* sel = NULL;
 		int a=0;
-		for(list&lt;CUnit*&gt;::iterator ui=selection.begin();ui!=selection.end() &amp;&amp; a&lt;=selectNumber;++ui,++a)
+		for (std::list&lt;CUnit*&gt;::iterator ui=selection.begin();ui!=selection.end() &amp;&amp; a&lt;=selectNumber;++ui,++a)
 			sel=*ui;
 
 		if (sel == NULL)
@@ -538,10 +538,10 @@
 		if(selectNumber&gt;=selection.size())
 			selectNumber=0;
 
-		list&lt;CUnit*&gt;::iterator ui=selection.begin();
-		for(int a=0;a&lt;selectNumber;++a)
+		std::list&lt;CUnit*&gt;::iterator ui=selection.begin();
+		for (int a=0;a&lt;selectNumber;++a)
 			++ui;
-		for(int a=0;a&lt;num;++ui,++a){
+		for (int a=0;a&lt;num;++ui,++a){
 			if(ui==selection.end())
 				ui=selection.begin();
 			selectedUnits.AddUnit(*ui);
@@ -559,8 +559,8 @@
 		if(selectNumber&gt;=selection.size())
 			selectNumber=0;
 
-		list&lt;CUnit*&gt;::iterator ui=selection.begin();
-		for(int a=0;a&lt;selectNumber;++a)
+		std::list&lt;CUnit*&gt;::iterator ui = selection.begin();
+		for (int a = 0; a &lt; selectNumber; ++a)
 			++ui;
 		for(int a=0;a&lt;num;++ui,++a){
 			if(ui==selection.end())

Modified: trunk/rts/Game/UI/SelectionKeyHandler.h
===================================================================
--- trunk/rts/Game/UI/SelectionKeyHandler.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/SelectionKeyHandler.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -4,8 +4,6 @@
 #include &quot;InputReceiver.h&quot;
 #include &lt;vector&gt;
 
-using namespace std;
-
 class CSelectionKeyHandler :
 	public CInputReceiver
 {
@@ -14,8 +12,8 @@
 	~CSelectionKeyHandler(void);
 	bool KeyPressed(unsigned short key, bool isRepeat);
 	bool KeyReleased(unsigned short key);
-	string ReadToken(string&amp; s);
-	string ReadDelimiter(string&amp; s);
+	std::string ReadToken(std::string&amp; s);
+	std::string ReadDelimiter(std::string&amp; s);
 
 	struct HotKey {
 		unsigned char key;
@@ -23,10 +21,10 @@
 		bool control;
 		bool alt;
 
-		string select;
+		std::string select;
 	};
-	vector&lt;HotKey&gt; hotkeys;
-	void DoSelection(string selectString);
+	std::vector&lt;HotKey&gt; hotkeys;
+	void DoSelection(std::string selectString);
 
 	int selectNumber;	//used to go through all possible units when selecting only a few
 };

Modified: trunk/rts/Game/UI/ShareBox.cpp
===================================================================
--- trunk/rts/Game/UI/ShareBox.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/ShareBox.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -184,7 +184,7 @@
 		//if (gs-&gt;Team(actualTeam)-&gt;gaia) continue;
 
 		const float alpha = (shareTeam == actualTeam) ? 0.8f : 0.4f;
-		string teamName;
+		std::string teamName;
 
 		if (gs-&gt;Team(actualTeam)-&gt;leader &gt;= 0) {
 			teamName = gs-&gt;players[gs-&gt;Team(actualTeam)-&gt;leader]-&gt;playerName;
@@ -192,7 +192,7 @@
 			teamName = &quot;Uncontrolled&quot;;
 		}
 
-		string ally, dead;
+		std::string ally, dead;
 		if (gs-&gt;Ally(gu-&gt;myAllyTeam, gs-&gt;AllyTeam(actualTeam))) {
 			glColor4f(0.5f, 1.0f, 0.5f, alpha);
 			ally = &quot; &lt;Ally&gt;&quot;;
@@ -259,12 +259,12 @@
 		if(InBox(mx,my,box+okBox) || InBox(mx,my,box+applyBox) || InBox(mx,my,box+cancelBox) || InBox(mx,my,box+unitBox) || InBox(mx,my,box+metalBox) || InBox(mx,my,box+energyBox) || InBox(mx,my,box+teamBox))
 			moveBox=false;
 		if(InBox(mx,my,box+metalBox)){
-			metalMove=true;
-			metalShare=max(0.f,min(1.f,(mx-box.x1-metalBox.x1)/(metalBox.x2-metalBox.x1)));
+			metalMove = true;
+			metalShare = std::max(0.f, std::min(1.f,(mx-box.x1-metalBox.x1)/(metalBox.x2-metalBox.x1)));
 		}
 		if(InBox(mx,my,box+energyBox)){
-			energyMove=true;
-			energyShare=max(0.f,min(1.f,(mx-box.x1-energyBox.x1)/(energyBox.x2-energyBox.x1)));
+			energyMove = true;
+			energyShare = std::max(0.f, std::min(1.f,(mx-box.x1-energyBox.x1)/(energyBox.x2-energyBox.x1)));
 		}
 		if(InBox(mx,my,box+teamBox)){
 			int team=(int)((box.y1+teamBox.y2-my)/0.025f);
@@ -320,10 +320,10 @@
 		box.y2+=MouseMoveY(dy);
 	}
 	if(metalMove){
-		metalShare=max(0.f,min(1.f,(mx-box.x1-metalBox.x1)/(metalBox.x2-metalBox.x1)));
+		metalShare = std::max(0.f, std::min(1.f,(mx-box.x1-metalBox.x1)/(metalBox.x2-metalBox.x1)));
 	}
 	if(energyMove){
-		energyShare=max(0.f,min(1.f,(mx-box.x1-energyBox.x1)/(energyBox.x2-energyBox.x1)));
+		energyShare = std::max(0.f, std::min(1.f,(mx-box.x1-energyBox.x1)/(energyBox.x2-energyBox.x1)));
 	}
 	if(InBox(mx,my,box+teamBox)){
 		int team=(int)((box.y1+teamBox.y2-my)/0.025f);

Modified: trunk/rts/Game/UI/StartPosSelecter.cpp
===================================================================
--- trunk/rts/Game/UI/StartPosSelecter.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/StartPosSelecter.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -188,7 +188,7 @@
 	const float ySize = (readyBox.y2 - readyBox.y1);
 	const float xSize = (readyBox.x2 - readyBox.x1);
 
-	const float fontScale = 0.9f * min(xSize/unitWidth, ySize/unitHeight);
+	const float fontScale = 0.9f * std::min(xSize/unitWidth, ySize/unitHeight);
 	const float yPos = readyBox.y1 + (0.1f * ySize);
 	const float xPos = 0.5f * (readyBox.x1 + readyBox.x2);
 

Modified: trunk/rts/Game/UI/TooltipConsole.cpp
===================================================================
--- trunk/rts/Game/UI/TooltipConsole.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/UI/TooltipConsole.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -336,7 +336,7 @@
 	}
 
 	char tmp[512];
-	const CMapInfo::TerrainType* tt = &amp;mapInfo-&gt;terrainTypes[readmap-&gt;typemap[min(gs-&gt;hmapx*gs-&gt;hmapy-1,max(0,((int)pos.z/16)*gs-&gt;hmapx+((int)pos.x/16)))]];
+	const CMapInfo::TerrainType* tt = &amp;mapInfo-&gt;terrainTypes[readmap-&gt;typemap[std::min(gs-&gt;hmapx*gs-&gt;hmapy-1, std::max(0,((int)pos.z/16)*gs-&gt;hmapx+((int)pos.x/16)))]];
 	string ttype = tt-&gt;name;
 	sprintf(tmp, &quot;Pos %.0f %.0f Elevation %.0f\nTerrain type: %s\n&quot;
 	             &quot;Speeds T/K/H/S %.2f %.2f %.2f %.2f\nHardness %.0f Metal %.1f&quot;,

Modified: trunk/rts/Game/WaitCommandsAI.cpp
===================================================================
--- trunk/rts/Game/WaitCommandsAI.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/WaitCommandsAI.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -653,7 +653,7 @@
 	static char buf[32];
 	if (enabled) {
 		const int remaining =
-			1 + (max(0, (endFrame - gs-&gt;frameNum - 1)) / GAME_SPEED);
+			1 + (std::max(0, (endFrame - gs-&gt;frameNum - 1)) / GAME_SPEED);
 		SNPRINTF(buf, sizeof(buf), &quot;%i&quot;, remaining);
 	} else {
 		SNPRINTF(buf, sizeof(buf), &quot;%i&quot;, duration / GAME_SPEED);
@@ -879,10 +879,10 @@
 {
 	units.clear();
 
-	const float3 mins(min(pos0.x, pos1.x), 0.0f, min(pos0.z, pos1.z));
-	const float3 maxs(max(pos0.x, pos1.x), 0.0f, max(pos0.z, pos1.z));
+	const float3 mins(std::min(pos0.x, pos1.x), 0.0f, std::min(pos0.z, pos1.z));
+	const float3 maxs(std::max(pos0.x, pos1.x), 0.0f, std::max(pos0.z, pos1.z));
 
-	vector&lt;CUnit*&gt; tmpUnits = qf-&gt;GetUnitsExact(mins, maxs);
+	std::vector&lt;CUnit*&gt; tmpUnits = qf-&gt;GetUnitsExact(mins, maxs);
 
 	const int count = (int)tmpUnits.size();
 	for (int i = 0; i &lt; count; i++) {

Modified: trunk/rts/Game/WordCompletion.cpp
===================================================================
--- trunk/rts/Game/WordCompletion.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/WordCompletion.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -102,7 +102,7 @@
 }
 
 
-void CWordCompletion::AddWord(const string&amp; word,
+void CWordCompletion::AddWord(const std::string&amp; word,
                               bool startOfLine, bool unitName, bool minimap)
 {
 	if (!word.empty()) {
@@ -112,15 +112,15 @@
 }
 
 
-vector&lt;string&gt; CWordCompletion::Complete(string&amp; msg) const
+std::vector&lt;std::string&gt; CWordCompletion::Complete(std::string&amp; msg) const
 {
-	vector&lt;string&gt; partials;
+	std::vector&lt;std::string&gt; partials;
 
 	const bool unitName = (msg.find(&quot;/give &quot;) == 0);
 	const bool minimap = (msg.find(&quot;/minimap &quot;) == 0);
 	  
 	// strip &quot;a:&quot; and &quot;s:&quot; prefixes
-	string prefix, rawmsg;
+	std::string prefix, rawmsg;
 	if ((msg.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (msg[1] == ':')) {
 		prefix = msg.substr(0, 2);
 		rawmsg = msg.substr(2);
@@ -129,21 +129,21 @@
 	}
 
 	// the word fragment
-	string::size_type startPos = rawmsg.find_last_of(' ');
-	const bool startOfLine = (startPos == string::npos);
+	std::string::size_type startPos = rawmsg.find_last_of(' ');
+	const bool startOfLine = (startPos == std::string::npos);
 	startPos = startOfLine ? 0 : startPos + 1;
-	const string fragment(rawmsg, startPos, string::npos);
+	const std::string fragment(rawmsg, startPos, std::string::npos);
 	if (fragment.empty()) {
 		return partials;
 	}
-	const string::size_type fragLen = fragment.size();
+	const std::string::size_type fragLen = fragment.size();
 
 	// pick a decent spot to start scanning
-	map&lt;string,WordProperties&gt;::const_iterator start;
+	std::map&lt;std::string, WordProperties&gt;::const_iterator start;
 	start = words.lower_bound(fragment);
 
 	// make a list of valid possible matches
-	map&lt;string,WordProperties&gt;::const_iterator it;
+	std::map&lt;std::string, WordProperties&gt;::const_iterator it;
 	for (it = start; it != words.end(); it++) {
 		const int cmp = it-&gt;first.compare(0, fragLen, fragment);
 		if (cmp &lt; 0) continue;
@@ -154,28 +154,28 @@
 			partials.push_back(it-&gt;first);
 		}
 	}
-	  
+
 	if (partials.empty()) {
 		return partials; // no possible matches
 	}
-	  
+
 	if (partials.size() == 1) {
 		msg = prefix + rawmsg.substr(0, startPos) + partials[0];
 		partials.clear();
 		return partials; // single match
 	}
-	  
+
 	// add as much of the match as possible
-	const string&amp; firstStr = partials[0];
-	const string&amp; lastStr = partials[partials.size() - 1];
+	const std::string&amp; firstStr = partials[0];
+	const std::string&amp; lastStr = partials[partials.size() - 1];
 	unsigned int i = 0;
-	unsigned int least = min(firstStr.size(), lastStr.size());
+	unsigned int least = std::min(firstStr.size(), lastStr.size());
 	for (i = 0; i &lt; least; i++) {
 		if (firstStr[i] != lastStr[i]) {
 			break;
 		}
 	}
 	msg = prefix + rawmsg.substr(0, startPos) + partials[0].substr(0, i);
-	  
+
 	return partials;
 }

Modified: trunk/rts/Game/WordCompletion.h
===================================================================
--- trunk/rts/Game/WordCompletion.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Game/WordCompletion.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -8,17 +8,15 @@
 #include &lt;vector&gt;
 #include &lt;map&gt;
 
-using namespace std;
-
 class CWordCompletion
 {
 	public:
 		CWordCompletion();
 		~CWordCompletion();
 		void Reset();
-		void AddWord(const string&amp; word,
+		void AddWord(const std::string&amp; word,
 		             bool startOfLine, bool unitName, bool minimap);
-		vector&lt;string&gt; Complete(string&amp; msg) const; // returns partial matches
+		std::vector&lt;std::string&gt; Complete(std::string&amp; msg) const; // returns partial matches
 
 	protected:
 		class WordProperties {
@@ -32,7 +30,7 @@
 				bool unitName;
 				bool minimap;
 		};
-		map&lt;string, WordProperties&gt; words;
+		std::map&lt;std::string, WordProperties&gt; words;
 };
 
 #endif /* WORD_COMPLETION_H */

Modified: trunk/rts/Lua/LuaHandleSynced.cpp
===================================================================
--- trunk/rts/Lua/LuaHandleSynced.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Lua/LuaHandleSynced.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -651,7 +651,6 @@
 	}
 
 	// get the result
-	const int args = lua_gettop(L);
 	if (!lua_isstring(L, -1)) {
 		lua_pop(L, 1);
 		return syncData;
@@ -927,7 +926,7 @@
 		const float diff  = (upper - lower);
 		const float r = gs-&gt;randFloat(); // [0,1], not [0,1) ?
 		int value = lower + (int)(r * (diff + 1));
-		value = max(lower, min(upper, value));
+		value = std::max(lower, std::min(upper, value));
 		lua_pushnumber(L, value);
 	}
 	else {

Modified: trunk/rts/Lua/LuaOpenGL.cpp
===================================================================
--- trunk/rts/Lua/LuaOpenGL.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Lua/LuaOpenGL.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -1293,7 +1293,7 @@
 			if (tmpLod &lt; 0) {
 				useLOD = false;
 			} else {
-				lod = min(unit-&gt;lodCount - 1, (unsigned int)tmpLod);
+				lod = std::min(unit-&gt;lodCount - 1, (unsigned int)tmpLod);
 			}
 		}
 		unit-&gt;currentLOD = lod;
@@ -1354,7 +1354,7 @@
 			if (tmpLod &lt; 0) {
 				useLOD = false;
 			} else {
-				lod = min(unit-&gt;lodCount - 1, (unsigned int)tmpLod);
+				lod = std::min(unit-&gt;lodCount - 1, (unsigned int)tmpLod);
 			}
 		}
 		unit-&gt;currentLOD = lod;
@@ -1747,7 +1747,7 @@
 	const int divs =   (int)lua_tonumber(L, 5);
 
 	if ((args &gt;= 6) &amp;&amp; lua_isnumber(L, 6)) {
-		const float slope = (float)lua_tonumber(L, 6);
+		// const float slope = (float) lua_tonumber(L, 6);
 		glBallisticCircle(pos, r, NULL, divs);
 	} else {
 		glSurfaceCircle(pos, r, divs);
@@ -1797,14 +1797,14 @@
 	const int mapzi = (gs-&gt;mapy + 1);
 	const float* heightmap = readmap-&gt;GetHeightmap();
 
-	const float xs = max(0.0f, min(float3::maxxpos, x0)); // x start
-	const float xe = max(0.0f, min(float3::maxxpos, x1)); // x end
-	const float zs = max(0.0f, min(float3::maxzpos, z0)); // z start
-	const float ze = max(0.0f, min(float3::maxzpos, z1)); // z end
-	const int xis = max(0, min(mapxi, int((xs + 0.5f) / SQUARE_SIZE)));
-	const int xie = max(0, min(mapxi, int((xe + 0.5f) / SQUARE_SIZE)));
-	const int zis = max(0, min(mapzi, int((zs + 0.5f) / SQUARE_SIZE)));
-	const int zie = max(0, min(mapzi, int((ze + 0.5f) / SQUARE_SIZE)));
+	const float xs = std::max(0.0f, std::min(float3::maxxpos, x0)); // x start
+	const float xe = std::max(0.0f, std::min(float3::maxxpos, x1)); // x end
+	const float zs = std::max(0.0f, std::min(float3::maxzpos, z0)); // z start
+	const float ze = std::max(0.0f, std::min(float3::maxzpos, z1)); // z end
+	const int xis = std::max(0, std::min(mapxi, int((xs + 0.5f) / SQUARE_SIZE)));
+	const int xie = std::max(0, std::min(mapxi, int((xe + 0.5f) / SQUARE_SIZE)));
+	const int zis = std::max(0, std::min(mapzi, int((zs + 0.5f) / SQUARE_SIZE)));
+	const int zie = std::max(0, std::min(mapzi, int((ze + 0.5f) / SQUARE_SIZE)));
 	if ((xis &gt;= xie) || (zis &gt;= zie)) {
 		return 0;
 	}

Modified: trunk/rts/Lua/LuaRules.cpp
===================================================================
--- trunk/rts/Lua/LuaRules.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Lua/LuaRules.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -946,7 +946,7 @@
 	}
 
 	// get the results
-	const int retArgs = min(lua_gettop(L) - top, (MAX_LUA_COB_ARGS - 1));
+	const int retArgs = std::min(lua_gettop(L) - top, (MAX_LUA_COB_ARGS - 1));
 	for (int a = 1; a &lt;= retArgs; a++) {
 		const int index = (a + top);
 		if (lua_isnumber(L, index)) {

Modified: trunk/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- trunk/rts/Map/BaseGroundDrawer.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Map/BaseGroundDrawer.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -253,7 +253,7 @@
 							if (gs-&gt;cheatEnabled &amp;&amp; md-&gt;moveMath-&gt;IsBlocked2(*md, x*2+1, y*2+1) &amp; (CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN)) {
 								m = 0.0f;
 							}
-							m = min(1.0f, (float)sqrt(m));
+							m = std::min(1.0f, (float)sqrt(m));
 							const int a=y*gs-&gt;pwr2mapx/2+x;
 							infoTexMem[a*4+0]=255-int(m*255.0f);
 							infoTexMem[a*4+1]=int(m*255.0f);
@@ -272,7 +272,7 @@
 						if (myAirLos[alx + (aly * loshandler-&gt;airSizeX)]) {
 							float extractDepth = extractDepthMap[(y * gs-&gt;hmapx) + x];
 							// a single pow(x, 0.25) call would be faster?
-							infoTexMem[a*4]=(unsigned char)min(255.0f,(float)sqrt(sqrt(extractDepth))*900);
+							infoTexMem[a*4]=(unsigned char)std::min(255.0f,(float)sqrt(sqrt(extractDepth))*900);
 						} else {
 							infoTexMem[a*4]=0;
 						}

Modified: trunk/rts/Map/BasicMapDamage.cpp
===================================================================
--- trunk/rts/Map/BasicMapDamage.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Map/BasicMapDamage.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -30,7 +30,7 @@
 
 	for(int a=0;a&lt;=200;++a){
 		float r=a/200.0f;
-		float d=cos((r-0.1f)*(PI+0.3f))*(1-r)*(0.5f+0.5f*cos(max(0.0f,r*3-2)*PI));
+		float d=cos((r-0.1f)*(PI+0.3f))*(1-r)*(0.5f+0.5f*cos(std::max(0.0f,r*3-2)*PI));
 		craterTable[a]=d;
 	}
 	for(int a=201;a&lt;10000;++a){
@@ -68,10 +68,10 @@
 	e-&gt;pos=pos;
 	e-&gt;strength=strength;
 	e-&gt;ttl=10;
-	e-&gt;x1=max((int)(pos.x-radius)/SQUARE_SIZE,2);
-	e-&gt;x2=min((int)(pos.x+radius)/SQUARE_SIZE,gs-&gt;mapx-3);
-	e-&gt;y1=max((int)(pos.z-radius)/SQUARE_SIZE,2);
-	e-&gt;y2=min((int)(pos.z+radius)/SQUARE_SIZE,gs-&gt;mapy-3);
+	e-&gt;x1=std::max((int)(pos.x-radius)/SQUARE_SIZE,2);
+	e-&gt;x2=std::min((int)(pos.x+radius)/SQUARE_SIZE,gs-&gt;mapx-3);
+	e-&gt;y1=std::max((int)(pos.z-radius)/SQUARE_SIZE,2);
+	e-&gt;y2=std::min((int)(pos.z+radius)/SQUARE_SIZE,gs-&gt;mapy-3);
 
 	float* heightmap = readmap-&gt;GetHeightmap();
 	float baseStrength=-pow(strength,0.6f)*3/mapHardness;
@@ -169,10 +169,10 @@
 	}
 
 	float3 n1,n2,n3,n4;
-	int decy=max(0,y1-1);
-	int incy=min(gs-&gt;mapy-1,y2+1);
-	int decx=max(0,x1-1);
-	int incx=min(gs-&gt;mapx-1,x2+1);
+	int decy=std::max(0,y1-1);
+	int incy=std::min(gs-&gt;mapy-1,y2+1);
+	int decx=std::max(0,x1-1);
+	int incx=std::min(gs-&gt;mapx-1,x2+1);
 
 	for(int y=decy;y&lt;=incy;y++) {
 		for(int x=decx;x&lt;=incx;x++)
@@ -195,9 +195,9 @@
 		}
 	}
 
-	for(int y=max(2,(y1&amp;0xfffffe));y&lt;=min(gs-&gt;mapy-3,y2);y+=2)
+	for(int y=std::max(2,(y1&amp;0xfffffe));y&lt;=std::min(gs-&gt;mapy-3,y2);y+=2)
 	{
-		for(int x=max(2,(x1&amp;0xfffffe));x&lt;=min(gs-&gt;mapx-3,x2);x+=2)
+		for(int x=std::max(2,(x1&amp;0xfffffe));x&lt;=std::min(gs-&gt;mapx-3,x2);x+=2)
 		{
 			float3 e1(-SQUARE_SIZE*4,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],0);
 			float3 e2( 0,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y+3)*(gs-&gt;mapx+1)+x-1],-SQUARE_SIZE*4);
@@ -218,10 +218,10 @@
 	featureHandler-&gt;TerrainChanged(x1,y1,x2,y2);
 	readmap-&gt;HeightmapUpdated(x1,x2,y1,y2);
 
-	decy=max(0,(y1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
-	incy=min(qf-&gt;GetNumQuadsZ()-1,(y2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
-	decx=max(0,(x1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
-	incx=min(qf-&gt;GetNumQuadsX()-1,(x2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
+	decy=std::max(0,(y1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
+	incy=std::min(qf-&gt;GetNumQuadsZ()-1,(y2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
+	decx=std::max(0,(x1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
+	incx=std::min(qf-&gt;GetNumQuadsX()-1,(x2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
 
 	for(int y=decy;y&lt;=incy;y++){
 		for(int x=decx;x&lt;=incx;x++){

Modified: trunk/rts/Rendering/Env/DynWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/DynWater.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/Env/DynWater.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -174,9 +174,9 @@
 		for(int x=0;x&lt;64;++x){
 			float dx=x-31.5f;
 			float dist=sqrt(dx*dx+dy*dy);
-			temp[(y*64+x)*4+0]=max(0.0f,1-dist/30.f)*max(0.0f,1-dist/30.f);
-			temp[(y*64+x)*4+1]=max(0.0f,1-dist/30.f);
-			temp[(y*64+x)*4+2]=max(0.0f,1-dist/30.f)*max(0.0f,1-dist/30.f);
+			temp[(y*64+x)*4+0]=std::max(0.0f,1-dist/30.f)*std::max(0.0f,1-dist/30.f);
+			temp[(y*64+x)*4+1]=std::max(0.0f,1-dist/30.f);
+			temp[(y*64+x)*4+2]=std::max(0.0f,1-dist/30.f)*std::max(0.0f,1-dist/30.f);
 			temp[(y*64+x)*4+3]=0;
 		}
 	}
@@ -380,8 +380,8 @@
 
 	oldCamPosBig=camPosBig;
 
-	camPosBig.x=floor(max((float)WH_SIZE, min((float)gs-&gt;mapx*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.x))/(W_SIZE*16))*(W_SIZE*16);
-	camPosBig.z=floor(max((float)WH_SIZE, min((float)gs-&gt;mapy*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.z))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig.x=floor(std::max((float)WH_SIZE, std::min((float)gs-&gt;mapx*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.x))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig.z=floor(std::max((float)WH_SIZE, std::min((float)gs-&gt;mapy*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.z))/(W_SIZE*16))*(W_SIZE*16);
 
 	glDisable(GL_DEPTH_TEST);
 	glDepthMask(0);
@@ -842,8 +842,8 @@
 	va=GetVertexArray();
 	va-&gt;Initialize();
 
-	camPosBig2.x=floor(max((float)WH_SIZE, min((float)gs-&gt;mapx*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.x))/(W_SIZE*16))*(W_SIZE*16);
-	camPosBig2.z=floor(max((float)WH_SIZE, min((float)gs-&gt;mapy*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.z))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig2.x=floor(std::max((float)WH_SIZE, std::min((float)gs-&gt;mapx*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.x))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig2.z=floor(std::max((float)WH_SIZE, std::min((float)gs-&gt;mapy*SQUARE_SIZE-WH_SIZE, (float)camera-&gt;pos.z))/(W_SIZE*16))*(W_SIZE*16);
 
 	for(int lod=1;lod&lt;(2&lt;&lt;5);lod*=2){
 		int cx=(int)(cam2-&gt;pos.x/(WSQUARE_SIZE));
@@ -865,10 +865,10 @@
 		int minlx=cx+(-viewRadius+2-xsquaremod)*lod;
 		int maxlx=cx+(viewRadius-xsquaremod)*lod;
 
-		int xstart=max(minlx,mintx);
-		int xend=min(maxlx,maxtx);
-		int ystart=max(minly,minty);
-		int yend=min(maxly,maxty);
+		int xstart=std::max(minlx,mintx);
+		int xend=std::min(maxlx,maxtx);
+		int ystart=std::max(minly,minty);
+		int yend=std::min(maxly,maxty);
 
 		for(int y=ystart;y&lt;yend;y+=lod){
 			int xs=xstart;
@@ -1233,15 +1233,15 @@
 {
 	if(pos.y&gt;size || size &lt; 8)
 		return;
-	explosions.push_back(Explosion(pos,min(size*20,strength),size));
+	explosions.push_back(Explosion(pos,std::min(size*20,strength),size));
 }
 
 void CDynWater::DrawUpdateSquare(float dx,float dy, int* resetTexs)
 {
-	float startx=max(0.f, -dx/WF_SIZE);
-	float starty=max(0.f, -dy/WF_SIZE);
-	float endx=min(1.f, 1-dx/WF_SIZE);
-	float endy=min(1.f, 1-dy/WF_SIZE);
+	float startx=std::max(0.f, -dx/WF_SIZE);
+	float starty=std::max(0.f, -dy/WF_SIZE);
+	float endx=std::min(1.f, 1-dx/WF_SIZE);
+	float endy=std::min(1.f, 1-dy/WF_SIZE);
 
 	DrawSingleUpdateSquare(startx,starty,endx,endy);
 

Modified: trunk/rts/Rendering/FartextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/FartextureHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/FartextureHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -77,7 +77,7 @@
 	GLfloat LightDiffuseLand2[]=	{ 0.0f, 0.0f, 0.0f, 1.0f };
 	GLfloat LightAmbientLand2[]=	{ 0.6f, 0.6f, 0.6f, 1.0f };
 	for(int a=0;a&lt;3;++a)
-		LightAmbientLand2[a]=min(1.f,unitDrawer-&gt;unitAmbientColor[a]+unitDrawer-&gt;unitSunColor[a]*0.2f);
+		LightAmbientLand2[a] = std::min(1.f,unitDrawer-&gt;unitAmbientColor[a]+unitDrawer-&gt;unitSunColor[a]*0.2f);
 	glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbientLand2);
 	glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuseLand2);
 	glLightfv(GL_LIGHT1, GL_SPECULAR, LightAmbientLand2);

Modified: trunk/rts/Rendering/InMapDraw.cpp
===================================================================
--- trunk/rts/Rendering/InMapDraw.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/InMapDraw.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -435,10 +435,10 @@
 			const float radius = 100.0f;
 			const int maxY = drawQuadsY - 1;
 			const int maxX = drawQuadsX - 1;
-			const int yStart = (int) max(0,    int((pos.z - radius) * quadScale));
-			const int xStart = (int) max(0,    int((pos.x - radius) * quadScale));
-			const int yEnd   = (int) min(maxY, int((pos.z + radius) * quadScale));
-			const int xEnd   = (int) min(maxX, int((pos.x + radius) * quadScale));
+			const int yStart = (int) std::max(0,    int((pos.z - radius) * quadScale));
+			const int xStart = (int) std::max(0,    int((pos.x - radius) * quadScale));
+			const int yEnd   = (int) std::min(maxY, int((pos.z + radius) * quadScale));
+			const int xEnd   = (int) std::min(maxX, int((pos.x + radius) * quadScale));
 
 			for (int y = yStart; y &lt;= yEnd; ++y) {
 				for (int x = xStart; x &lt;= xEnd; ++x) {

Modified: trunk/rts/Rendering/UnitModels/3DModelParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModelParser.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/UnitModels/3DModelParser.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -20,11 +20,11 @@
 	delete units3oparser;
 }
 
-S3DOModel* C3DModelParser::Load3DModel(string name, float scale, int side)
+S3DOModel* C3DModelParser::Load3DModel(std::string name, float scale, int side)
 {
 	// TODO: abstract this
 	StringToLowerInPlace(name);
-	if (name.find(&quot;.s3o&quot;) != string::npos)
+	if (name.find(&quot;.s3o&quot;) != std::string::npos)
 		return units3oparser-&gt;LoadS3O(name, scale, side);
 	else
 		return unit3doparser-&gt;Load3DO(name, scale, side);
@@ -41,7 +41,7 @@
 }
 */
 
-LocalS3DOModel *C3DModelParser::CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces)
+LocalS3DOModel *C3DModelParser::CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces)
 {
 	LocalS3DOModel* lm;
 	if (model-&gt;rootobject3do) {

Modified: trunk/rts/Rendering/UnitModels/3DModelParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModelParser.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/UnitModels/3DModelParser.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -5,13 +5,10 @@
 #include &lt;string&gt;
 #include &quot;Matrix44f.h&quot;
 
-using namespace std;
-
-
 struct S3DO;
 struct SS3O;
-class	C3DOParser;
-class	CS3OParser;
+class C3DOParser;
+class CS3OParser;
 struct S3DOModel;
 struct LocalS3DOModel;
 
@@ -22,9 +19,9 @@
 	C3DModelParser(void);
 	~C3DModelParser(void);
 
-	S3DOModel* Load3DModel(string name, float scale = 1.0f, int side = 1);
+	S3DOModel* Load3DModel(std::string name, float scale = 1.0f, int side = 1);
 	// S3DOModel* Load3DO(string name,float scale,int side,const float3&amp; offsets);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces);
+	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
 
 	C3DOParser* unit3doparser;
 	CS3OParser* units3oparser;
@@ -40,7 +37,7 @@
 	int numobjects;
 	float radius;
 	float height;
-	string name;
+	std::string name;
 	int farTextureNum;
 	float maxx,maxy,maxz;
 	float minx,miny,minz;
@@ -58,8 +55,8 @@
 {
 	float3 offset;
 	unsigned int displist;
-	vector&lt;unsigned int&gt; lodDispLists;
-	string name;
+	std::vector&lt;unsigned int&gt; lodDispLists;
+	std::string name;
 	std::vector&lt;LocalS3DO*&gt; childs;
 	LocalS3DO *parent;
 	S3DO *original3do;

Modified: trunk/rts/Rendering/UnitModels/3DOParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/3DOParser.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/UnitModels/3DOParser.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -12,9 +12,7 @@
 #include &lt;set&gt;
 #include &quot;3DModelParser.h&quot;
 
-using namespace std;
 class CMatrix44f;
-
 class CFileHandler;
 
 struct S3DOVertex {
@@ -91,9 +89,9 @@
 public:
 	C3DOParser();
 	virtual ~C3DOParser();
-	S3DOModel* Load3DO(string name,float scale=1,int side=1);
-	// S3DOModel* Load3DO(string name,float scale,int side,const float3&amp; offsets);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces);
+	S3DOModel* Load3DO(std::string name, float scale = 1, int side = 1);
+	// S3DOModel* Load3DO(std::string name,float scale,int side,const float3&amp; offsets);
+	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
 
 private:
 	void FindCenter(S3DO* object);
@@ -110,10 +108,10 @@
 	std::string GetText(int pos);
 	bool ReadChild(int pos,S3DO* root,int side, int *numobj);
 	void DrawSub(S3DO* o);
-	void CreateLocalModel(S3DO *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	void CreateLocalModel(S3DO *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
 
-	map&lt;string,S3DOModel*&gt; units;
-	set&lt;string&gt; teamtex;
+	std::map&lt;std::string, S3DOModel*&gt; units;
+	std::set&lt;std::string&gt; teamtex;
 
 	int curOffset;
 	unsigned char* fileBuf;

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -293,7 +293,7 @@
 	CUnit* excludeUnit = drawReflection ? NULL : gu-&gt;directControl;
 #endif
 
-	for (list&lt;CUnit*&gt;::iterator usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
+	for (std::list&lt;CUnit*&gt;::iterator usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
 		CUnit* unit = *usi;
 
 #ifdef DIRECT_CONTROL_ALLOWED
@@ -586,7 +586,7 @@
 
 	CUnit::SetLODFactor(LODScale * LODScaleShadow);
 
-	list&lt;CUnit*&gt;::iterator usi;
+	std::list&lt;CUnit*&gt;::iterator usi;
 	for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
 		CUnit* unit = *usi;
 
@@ -1388,7 +1388,7 @@
 			if (dot &lt; 0)
 				dot = 0;
 
-			float exp = min(1.f, powf(dot, exponent) + powf(dot, 3) * 0.25f);
+			float exp = std::min(1.f, powf(dot, exponent) + powf(dot, 3) * 0.25f);
 			buf[(y * size + x) * 4 + 0] = (unsigned char) (suncolor.x * exp * 255);
 			buf[(y * size + x) * 4 + 1] = (unsigned char) (suncolor.y * exp * 255);
 			buf[(y * size + x) * 4 + 2] = (unsigned char) (suncolor.z * exp * 255);
@@ -1949,7 +1949,7 @@
 	glRectf(-5.0f, 4.0f, +5.0f, 6.0f);
 
 	// healthbar
-	const float hpp = max(0.0f, unit-&gt;health / unit-&gt;maxHealth);
+	const float hpp = std::max(0.0f, unit-&gt;health / unit-&gt;maxHealth);
 	const float hEnd = hpp * 10.0f;
 
 	if (unit-&gt;stunned) {

Modified: trunk/rts/Rendering/UnitModels/s3oParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/s3oParser.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/UnitModels/s3oParser.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -41,7 +41,7 @@
 
 CS3OParser::~CS3OParser()
 {
-	map&lt;string,S3DOModel*&gt;::iterator ui;
+	std::map&lt;std::string,S3DOModel*&gt;::iterator ui;
 	for(ui=units.begin();ui!=units.end();++ui){
 		DeleteSS3O(ui-&gt;second-&gt;rootobjects3o);
 		delete ui-&gt;second;
@@ -56,14 +56,14 @@
 	delete o;
 }
 
-S3DOModel* CS3OParser::LoadS3O(string name,float scale,int side)
+S3DOModel* CS3OParser::LoadS3O(std::string name,float scale,int side)
 {
-	if(name.find(&quot;.&quot;)==string::npos)
+	if(name.find(&quot;.&quot;)==std::string::npos)
 		name+=&quot;.s3o&quot;;
 
 	StringToLowerInPlace(name);
 
-	map&lt;string,S3DOModel*&gt;::iterator ui;
+	std::map&lt;std::string,S3DOModel*&gt;::iterator ui;
 	if((ui=units.find(name))!=units.end()){
 		return ui-&gt;second;
 	}
@@ -123,7 +123,7 @@
 	return model;
 }
 
-LocalS3DOModel* CS3OParser::CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces)
+LocalS3DOModel* CS3OParser::CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces)
 {
 	LocalS3DOModel *lmodel = SAFE_NEW LocalS3DOModel;
 	lmodel-&gt;numpieces = model-&gt;numobjects;
@@ -141,7 +141,7 @@
 	return lmodel;
 }
 
-void CS3OParser::CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum)
+void CS3OParser::CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum)
 {
 	PUSH_CODE_MODE;
 	ENTER_SYNCED;
@@ -163,10 +163,10 @@
 
 	//Not found? Try again with partial matching
 	if (cur == pieces-&gt;size()) {
-		string &amp;s1 = lmodel-&gt;pieces[*piecenum].name;
+		std::string &amp;s1 = lmodel-&gt;pieces[*piecenum].name;
 		for (cur = 0; cur &lt; pieces-&gt;size(); ++cur) {
-			string &amp;s2 = (*pieces)[cur].name;
-			int maxcompare = min(s1.size(), s2.size());
+			std::string &amp;s2 = (*pieces)[cur].name;
+			int maxcompare = std::min(s1.size(), s2.size());
 			int j;
 			for (j = 0; j &lt; maxcompare; ++j) {
 				if (s1[j] != s2[j]) {
@@ -259,22 +259,22 @@
 
 	std::vector&lt;SS3OVertex&gt;::iterator vi;
 	for(vi=object-&gt;vertices.begin();vi!=object-&gt;vertices.end();++vi){
-		maxx=max(maxx,vi-&gt;pos.x);
-		maxy=max(maxy,vi-&gt;pos.y);
-		maxz=max(maxz,vi-&gt;pos.z);
+		maxx=std::max(maxx,vi-&gt;pos.x);
+		maxy=std::max(maxy,vi-&gt;pos.y);
+		maxz=std::max(maxz,vi-&gt;pos.z);
 
-		minx=min(minx,vi-&gt;pos.x);
-		miny=min(miny,vi-&gt;pos.y);
-		minz=min(minz,vi-&gt;pos.z);
+		minx=std::min(minx,vi-&gt;pos.x);
+		miny=std::min(miny,vi-&gt;pos.y);
+		minz=std::min(minz,vi-&gt;pos.z);
 	}
 	for(si=object-&gt;childs.begin();si!=object-&gt;childs.end();++si){
-		maxx=max(maxx,(*si)-&gt;offset.x+(*si)-&gt;maxx);
-		maxy=max(maxy,(*si)-&gt;offset.y+(*si)-&gt;maxy);
-		maxz=max(maxz,(*si)-&gt;offset.z+(*si)-&gt;maxz);
+		maxx=std::max(maxx,(*si)-&gt;offset.x+(*si)-&gt;maxx);
+		maxy=std::max(maxy,(*si)-&gt;offset.y+(*si)-&gt;maxy);
+		maxz=std::max(maxz,(*si)-&gt;offset.z+(*si)-&gt;maxz);
 
-		minx=min(minx,(*si)-&gt;offset.x+(*si)-&gt;minx);
-		miny=min(miny,(*si)-&gt;offset.y+(*si)-&gt;miny);
-		minz=min(minz,(*si)-&gt;offset.z+(*si)-&gt;minz);
+		minx=std::min(minx,(*si)-&gt;offset.x+(*si)-&gt;minx);
+		miny=std::min(miny,(*si)-&gt;offset.y+(*si)-&gt;miny);
+		minz=std::min(minz,(*si)-&gt;offset.z+(*si)-&gt;minz);
 	}
 	object-&gt;maxx=maxx;
 	object-&gt;maxy=maxy;

Modified: trunk/rts/Rendering/UnitModels/s3oParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/s3oParser.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Rendering/UnitModels/s3oParser.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -38,8 +38,8 @@
 	CS3OParser();
 	virtual ~CS3OParser();
 
-	S3DOModel* LoadS3O(string name,float scale=1,int side=1);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces);
+	S3DOModel* LoadS3O(std::string name, float scale = 1, int side = 1);
+	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
 
 private:
 	SS3O* LoadPiece(unsigned char* buf, int offset,S3DOModel* model);
@@ -47,9 +47,9 @@
 	void FindMinMax(SS3O *object);
 	void DrawSub(SS3O* o);
 	void CreateLists(SS3O *o);
-	void CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	void CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
 
-	map&lt;string,S3DOModel*&gt; units;
+	std::map&lt;std::string,S3DOModel*&gt; units;
 };
 
 #endif /* S3OPARSER_H */

Modified: trunk/rts/Sim/Features/Feature.cpp
===================================================================
--- trunk/rts/Sim/Features/Feature.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Features/Feature.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -255,7 +255,7 @@
 		}
 
 		// Work out how much to try to put back, based on the speed this unit would reclaim at.
-		const float part = (100 - amount) * 0.02f / max(10.0f, (def-&gt;metal + def-&gt;energy));
+		const float part = (100 - amount) * 0.02f / std::max(10.0f, (def-&gt;metal + def-&gt;energy));
 
 		// Work out how much that will cost
 		const float metalUse  = part * def-&gt;metal;
@@ -295,7 +295,7 @@
 			return true;
 		}
 
-		const float part = ((100 - amount) * 0.02f / max(10.0f, (def-&gt;reclaimTime)));
+		const float part = ((100 - amount) * 0.02f / std::max(10.0f, (def-&gt;reclaimTime)));
 
 		if (luaRules &amp;&amp; !luaRules-&gt;AllowFeatureBuildStep(builder, this, part)) {
 			return false;

Modified: trunk/rts/Sim/Features/FeatureHandler.h
===================================================================
--- trunk/rts/Sim/Features/FeatureHandler.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Features/FeatureHandler.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -53,7 +53,7 @@
 
 private:
 	void AddFeatureDef(const std::string&amp; name, FeatureDef* feature);
-	const FeatureDef* CreateFeatureDef(const LuaTable&amp; luaTable, const string&amp; name);	
+	const FeatureDef* CreateFeatureDef(const LuaTable&amp; luaTable, const std::string&amp; name);
 
 private:
 	std::map&lt;std::string, const FeatureDef*&gt; featureDefs;

Modified: trunk/rts/Sim/Misc/QuadField.cpp
===================================================================
--- trunk/rts/Sim/Misc/QuadField.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Misc/QuadField.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -67,11 +67,11 @@
 	pos.CheckInBounds();
 
 	vector&lt;int&gt; ret;
-	int maxx = min(((int)(pos.x + radius)) / QUAD_SIZE + 1, numQuadsX - 1);
-	int maxz = min(((int)(pos.z + radius)) / QUAD_SIZE + 1, numQuadsZ - 1);
+	int maxx = std::min(((int)(pos.x + radius)) / QUAD_SIZE + 1, numQuadsX - 1);
+	int maxz = std::min(((int)(pos.z + radius)) / QUAD_SIZE + 1, numQuadsZ - 1);
 
-	int minx = max(((int)(pos.x - radius)) / QUAD_SIZE, 0);
-	int minz = max(((int)(pos.z - radius)) / QUAD_SIZE, 0);
+	int minx = std::max(((int)(pos.x - radius)) / QUAD_SIZE, 0);
+	int minz = std::max(((int)(pos.z - radius)) / QUAD_SIZE, 0);
 
 	if (maxz &lt; minz || maxx &lt; minx)
 		return ret;
@@ -91,11 +91,11 @@
 {
 	pos.CheckInBounds();
 
-	int maxx = min(((int)(pos.x + radius)) / QUAD_SIZE + 1, numQuadsX - 1);
-	int maxz = min(((int)(pos.z + radius)) / QUAD_SIZE + 1, numQuadsZ - 1);
+	int maxx = std::min(((int)(pos.x + radius)) / QUAD_SIZE + 1, numQuadsX - 1);
+	int maxz = std::min(((int)(pos.z + radius)) / QUAD_SIZE + 1, numQuadsZ - 1);
 
-	int minx = max(((int)(pos.x - radius)) / QUAD_SIZE, 0);
-	int minz = max(((int)(pos.z - radius)) / QUAD_SIZE, 0);
+	int minx = std::max(((int)(pos.x - radius)) / QUAD_SIZE, 0);
+	int minz = std::max(((int)(pos.z - radius)) / QUAD_SIZE, 0);
 
 	if (maxz &lt; minz || maxx &lt; minx)
 		return;
@@ -124,10 +124,10 @@
 		if(qi2==newQuads.end())
 			return;
 	}
-	vector&lt;int&gt;::iterator qi;
-	for(qi=unit-&gt;quads.begin();qi!=unit-&gt;quads.end();++qi){
-		list&lt;CUnit*&gt;::iterator ui;
-		for(ui=baseQuads[*qi].units.begin();ui!=baseQuads[*qi].units.end();++ui){
+	std::vector&lt;int&gt;::iterator qi;
+	for (qi = unit-&gt;quads.begin(); qi != unit-&gt;quads.end(); ++qi) {
+		std::list&lt;CUnit*&gt;::iterator ui;
+		for (ui = baseQuads[*qi].units.begin(); ui != baseQuads[*qi].units.end(); ++ui) {
 			if(*ui==unit){
 				baseQuads[*qi].units.erase(ui);
 				break;
@@ -147,9 +147,9 @@
 	unit-&gt;quads=newQuads;
 }
 
-vector&lt;CUnit*&gt; CQuadField::GetUnits(const float3&amp; pos,float radius)
+std::vector&lt;CUnit*&gt; CQuadField::GetUnits(const float3&amp; pos,float radius)
 {
-	vector&lt;CUnit*&gt; units;
+	std::vector&lt;CUnit*&gt; units;
 
 	int* endQuad=tempQuads;
 	GetQuads(pos,radius,endQuad);
@@ -158,8 +158,8 @@
 
 	for(int* a=tempQuads;a!=endQuad;++a){
 		Quad&amp; quad = baseQuads[*a];
-		for(list&lt;CUnit*&gt;::iterator ui=quad.units.begin();ui!=quad.units.end();++ui){
-			if((*ui)-&gt;tempNum!=tempNum){
+		for (std::list&lt;CUnit*&gt;::iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
+			if ((*ui)-&gt;tempNum!=tempNum){
 				(*ui)-&gt;tempNum=tempNum;
 				units.push_back(*ui);
 			}
@@ -169,22 +169,18 @@
 	return units;
 }
 
-vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; pos,float radius)
+std::vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; pos,float radius)
 {
-	vector&lt;CUnit*&gt; units;
-/*	if(pos.x&lt;0 || pos.z&lt;0 || pos.x&gt;gs-&gt;mapx*SQUARE_SIZE || pos.z&gt;gs-&gt;mapy*SQUARE_SIZE){
-		logOutput.Print(&quot;Trying to get units outside map %.0f %.0f&quot;,pos.x,pos.z);
-		return units;
-	}*/
+	std::vector&lt;CUnit*&gt; units;
 
 	int* endQuad=tempQuads;
 	GetQuads(pos,radius,endQuad);
 
 	int tempNum=gs-&gt;tempNum++;
 
-	for(int* a=tempQuads;a!=endQuad;++a){
+	for (int* a=tempQuads;a!=endQuad;++a){
 		Quad&amp; quad = baseQuads[*a];
-		for(list&lt;CUnit*&gt;::iterator ui=quad.units.begin();ui!=quad.units.end();++ui){
+		for (std::list&lt;CUnit*&gt;::iterator ui=quad.units.begin();ui!=quad.units.end();++ui){
 			float totRad=radius+(*ui)-&gt;radius;
 			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; (pos-(*ui)-&gt;midPos).SqLength()&lt;totRad*totRad){
 				(*ui)-&gt;tempNum=tempNum;
@@ -196,18 +192,17 @@
 	return units;
 }
 
-vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; mins, const float3&amp; maxs)
+std::vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; mins, const float3&amp; maxs)
 {
-	vector&lt;CUnit*&gt; units;
+	std::vector&lt;CUnit*&gt; units;
+	std::vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
 
-	vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
-
 	int tempNum = gs-&gt;tempNum++;
 
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
-		list&lt;CUnit*&gt;&amp; quadUnits = baseQuads[*qi].units;
-		list&lt;CUnit*&gt;::iterator ui;
+		std::list&lt;CUnit*&gt;&amp; quadUnits = baseQuads[*qi].units;
+		std::list&lt;CUnit*&gt;::iterator ui;
 		for (ui = quadUnits.begin(); ui != quadUnits.end(); ++ui) {
 			CUnit* unit = *ui;
 			const float3&amp; pos = unit-&gt;midPos;
@@ -223,12 +218,12 @@
 	return units;
 }
 
-vector&lt;int&gt; CQuadField::GetQuadsOnRay(const float3&amp; start, float3 dir, float length)
+std::vector&lt;int&gt; CQuadField::GetQuadsOnRay(const float3&amp; start, float3 dir, float length)
 {
 	int* end = tempQuads;
 	GetQuadsOnRay(start,dir,length,end);
 
-	return vector&lt;int&gt;(tempQuads,end);
+	return std::vector&lt;int&gt;(tempQuads, end);
 }
 
 void CQuadField::GetQuadsOnRay(float3 start, float3 dir,float length, int*&amp; dst)
@@ -366,9 +361,9 @@
 void CQuadField::RemoveUnit(CUnit* unit)
 {
 	std::vector&lt;int&gt;::iterator qi;
-	for(qi=unit-&gt;quads.begin();qi!=unit-&gt;quads.end();++qi){
-		list&lt;CUnit*&gt;::iterator ui;
-		for(ui=baseQuads[*qi].units.begin();ui!=baseQuads[*qi].units.end();++ui){
+	for (qi = unit-&gt;quads.begin(); qi != unit-&gt;quads.end(); ++qi) {
+		std::list&lt;CUnit*&gt;::iterator ui;
+		for (ui = baseQuads[*qi].units.begin(); ui != baseQuads[*qi].units.end(); ++ui) {
 			if(*ui==unit){
 				baseQuads[*qi].units.erase(ui);
 				break;
@@ -415,10 +410,10 @@
 
 	int tempNum=gs-&gt;tempNum++;
 
-	vector&lt;int&gt;::iterator qi;
-	for(qi=quads.begin();qi!=quads.end();++qi){
-		list&lt;CFeature*&gt;::iterator fi;
-		for(fi=baseQuads[*qi].features.begin();fi!=baseQuads[*qi].features.end();++fi){
+	std::vector&lt;int&gt;::iterator qi;
+	for (qi = quads.begin(); qi != quads.end(); ++qi) {
+		std::list&lt;CFeature*&gt;::iterator fi;
+		for (fi = baseQuads[*qi].features.begin(); fi != baseQuads[*qi].features.end(); ++fi) {
 			float totRad=radius+(*fi)-&gt;radius;
 			if((*fi)-&gt;tempNum!=tempNum &amp;&amp; (pos-(*fi)-&gt;midPos).SqLength()&lt;totRad*totRad){
 				(*fi)-&gt;tempNum=tempNum;
@@ -430,19 +425,18 @@
 	return features;
 }
 
-vector&lt;CFeature*&gt; CQuadField::GetFeaturesExact(const float3&amp; mins,
+std::vector&lt;CFeature*&gt; CQuadField::GetFeaturesExact(const float3&amp; mins,
                                                const float3&amp; maxs)
 {
-	vector&lt;CFeature*&gt; features;
+	std::vector&lt;CFeature*&gt; features;
+	std::vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
 
-	vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
-
 	int tempNum = gs-&gt;tempNum++;
 
-	vector&lt;int&gt;::iterator qi;
+	std::vector&lt;int&gt;::iterator qi;
 	for(qi = quads.begin(); qi != quads.end(); ++qi) {
-		list&lt;CFeature*&gt;&amp; quadFeatures = baseQuads[*qi].features;
-		list&lt;CFeature*&gt;::iterator fi;
+		std::list&lt;CFeature*&gt;&amp; quadFeatures = baseQuads[*qi].features;
+		std::list&lt;CFeature*&gt;::iterator fi;
 		for (fi = quadFeatures.begin(); fi != quadFeatures.end(); ++fi) {
 			CFeature* feature = *fi;
 			const float3&amp; pos = feature-&gt;midPos;
@@ -458,22 +452,16 @@
 	return features;
 }
 
-vector&lt;CSolidObject*&gt; CQuadField::GetSolidsExact(const float3&amp; pos,float radius)
+std::vector&lt;CSolidObject*&gt; CQuadField::GetSolidsExact(const float3&amp; pos,float radius)
 {
-	vector&lt;CSolidObject*&gt; solids;
-/*	if(pos.x&lt;0 || pos.z&lt;0 || pos.x&gt;gs-&gt;mapx*SQUARE_SIZE || pos.z&gt;gs-&gt;mapy*SQUARE_SIZE){
-		logOutput.Print(&quot;Trying to get units outside map %.0f %.0f&quot;,pos.x,pos.z);
-		return units;
-	}*/
+	std::vector&lt;CSolidObject*&gt; solids;
+	std::vector&lt;int&gt; quads = GetQuads(pos,radius);
+	int tempNum = gs-&gt;tempNum++;
 
-	vector&lt;int&gt; quads=GetQuads(pos,radius);
-
-	int tempNum=gs-&gt;tempNum++;
-
-	vector&lt;int&gt;::iterator qi;
-	for(qi=quads.begin();qi!=quads.end();++qi){
-		list&lt;CUnit*&gt;::iterator ui;
-		for(ui=baseQuads[*qi].units.begin();ui!=baseQuads[*qi].units.end();++ui){
+	std::vector&lt;int&gt;::iterator qi;
+	for (qi = quads.begin(); qi != quads.end(); ++qi) {
+		std::list&lt;CUnit*&gt;::iterator ui;
+		for (ui = baseQuads[*qi].units.begin(); ui != baseQuads[*qi].units.end(); ++ui) {
 			if (!(*ui)-&gt;blocking)
 				continue;
 
@@ -484,7 +472,7 @@
 			}
 		}
 
-		list&lt;CFeature*&gt;::iterator fi;
+		std::list&lt;CFeature*&gt;::iterator fi;
 		for(fi=baseQuads[*qi].features.begin();fi!=baseQuads[*qi].features.end();++fi){
 			if (!(*fi)-&gt;blocking)
 				continue;
@@ -500,15 +488,15 @@
 	return solids;
 }
 
-vector&lt;int&gt; CQuadField::GetQuadsRectangle(const float3&amp; pos,const float3&amp; pos2)
+std::vector&lt;int&gt; CQuadField::GetQuadsRectangle(const float3&amp; pos,const float3&amp; pos2)
 {
-	vector&lt;int&gt; ret;
+	std::vector&lt;int&gt; ret;
 
-	int maxx = max(0, min(((int)(pos2.x)) / QUAD_SIZE + 1, numQuadsX - 1));
-	int maxz = max(0, min(((int)(pos2.z)) / QUAD_SIZE + 1, numQuadsZ - 1));
+	int maxx = std::max(0, std::min(((int)(pos2.x)) / QUAD_SIZE + 1, numQuadsX - 1));
+	int maxz = std::max(0, std::min(((int)(pos2.z)) / QUAD_SIZE + 1, numQuadsZ - 1));
 
-	int minx = max(0, min(((int)(pos.x)) / QUAD_SIZE, numQuadsX - 1));
-	int minz = max(0, min(((int)(pos.z)) / QUAD_SIZE, numQuadsZ - 1));
+	int minx = std::max(0, std::min(((int)(pos.x)) / QUAD_SIZE, numQuadsX - 1));
+	int minz = std::max(0, std::min(((int)(pos.z)) / QUAD_SIZE, numQuadsZ - 1));
 
 	if (maxz &lt; minz || maxx &lt; minx)
 		return ret;
@@ -531,7 +519,7 @@
 
 	for(int* a=tempQuads;a!=endQuad;++a){
 		Quad&amp; quad = baseQuads[*a];
-		for(list&lt;CUnit*&gt;::iterator ui=quad.units.begin();ui!=quad.units.end();++ui){
+		for (std::list&lt;CUnit*&gt;::iterator ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
 			if((*ui)-&gt;tempNum!=tempNum){
 				(*ui)-&gt;tempNum=tempNum;
 				*dstUnit=(*ui);
@@ -539,7 +527,7 @@
 			}
 		}
 
-		for(list&lt;CFeature*&gt;::iterator fi=quad.features.begin();fi!=quad.features.end();++fi){
+		for (std::list&lt;CFeature*&gt;::iterator fi = quad.features.begin(); fi != quad.features.end(); ++fi) {
 			float totRad=radius+(*fi)-&gt;radius;
 			if((*fi)-&gt;tempNum!=tempNum &amp;&amp; (pos-(*fi)-&gt;midPos).SqLength()&lt;totRad*totRad){
 				(*fi)-&gt;tempNum=tempNum;

Modified: trunk/rts/Sim/Misc/RadarHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/RadarHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Misc/RadarHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -131,17 +131,17 @@
 
 void CRadarHandler::AddMapArea(int2 pos, int radius, std::vector&lt;unsigned short&gt;&amp; map, int amount)
 {
-	int sx=max(0,pos.x-radius);
-	int ex=min(xsize-1,pos.x+radius);
-	int sy=max(0,pos.y-radius);
-	int ey=min(ysize-1,pos.y+radius);
+	int sx = std::max(0,pos.x-radius);
+	int ex = std::min(xsize-1,pos.x+radius);
+	int sy = std::max(0,pos.y-radius);
+	int ey = std::min(ysize-1,pos.y+radius);
 
-	int rr=radius*radius;
-	for(int y=sy;y&lt;=ey;++y){
-		int rrx=rr-(pos.y-y)*(pos.y-y);
-		for(int x=sx;x&lt;=ex;++x){
-			if((pos.x-x)*(pos.x-x)&lt;=rrx){
-				map[y*xsize+x]+=amount;
+	int rr = radius * radius;
+	for (int y = sy; y &lt;= ey; ++y) {
+		int rrx = rr - (pos.y - y) * (pos.y - y);
+		for (int x = sx; x &lt;= ex; ++x) {
+			if ((pos.x - x) * (pos.x - x) &lt;= rrx) {
+				map[y * xsize + x] += amount;
 			}
 		}
 	}

Modified: trunk/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -219,7 +219,7 @@
 			owner-&gt;pos = pos;
 
 			owner-&gt;AddBuildPower(unit-&gt;unitDef-&gt;buildSpeed/30,unit);
-			owner-&gt;currentFuel = min (owner-&gt;unitDef-&gt;maxFuel, owner-&gt;currentFuel + (owner-&gt;unitDef-&gt;maxFuel / (GAME_SPEED * owner-&gt;unitDef-&gt;refuelTime)));
+			owner-&gt;currentFuel = std::min (owner-&gt;unitDef-&gt;maxFuel, owner-&gt;currentFuel + (owner-&gt;unitDef-&gt;maxFuel / (GAME_SPEED * owner-&gt;unitDef-&gt;refuelTime)));
 
 			if (owner-&gt;health &gt;= owner-&gt;maxHealth - 1 &amp;&amp; owner-&gt;currentFuel &gt;= owner-&gt;unitDef-&gt;maxFuel) {
 				airBaseHandler-&gt;LeaveLandingPad(reservedPad);
@@ -241,7 +241,7 @@
 #endif
 		owner-&gt;restTime = 0;
 		if (owner-&gt;userTarget || owner-&gt;userAttackGround) {
-			inefficientAttackTime = min(inefficientAttackTime, (float)gs-&gt;frameNum - owner-&gt;lastFireWeapon);
+			inefficientAttackTime = std::min(inefficientAttackTime, (float)gs-&gt;frameNum - owner-&gt;lastFireWeapon);
 			if (owner-&gt;userTarget) {
 				goalPos = owner-&gt;userTarget-&gt;pos;
 			} else {
@@ -274,7 +274,7 @@
 		owner-&gt;crashing = true;
 		UpdateAirPhysics(crashRudder, crashAileron, crashElevator, 0, owner-&gt;frontdir);
 		SAFE_NEW CSmokeProjectile(owner-&gt;midPos, gs-&gt;randVector() * 0.08f, 100 + gs-&gt;randFloat() * 50, 5, 0.2f, owner, 0.4f);
-		if (!(gs-&gt;frameNum &amp; 3) &amp;&amp; max(0.f, ground-&gt;GetApproximateHeight(pos.x, pos.z)) + 5 + owner-&gt;radius &gt; pos.y)
+		if (!(gs-&gt;frameNum &amp; 3) &amp;&amp; std::max(0.f, ground-&gt;GetApproximateHeight(pos.x, pos.z)) + 5 + owner-&gt;radius &gt; pos.y)
 			owner-&gt;KillUnit(true, false, 0);
 		break;
 	case AIRCRAFT_TAKEOFF:
@@ -373,7 +373,7 @@
 void CAirMoveType::SlowUpdate(void)
 {
 	if (aircraftState != AIRCRAFT_LANDED &amp;&amp; owner-&gt;unitDef-&gt;maxFuel &gt; 0)
-		owner-&gt;currentFuel = max (0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
+		owner-&gt;currentFuel = std::max(0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
 
 	if (owner-&gt;pos != oldSlowUpdatePos) {
 		oldSlowUpdatePos = owner-&gt;pos;
@@ -563,7 +563,7 @@
 		}
 	} else {
 		float gHeight2 = ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40);
-		float hdif = max(gHeight, gHeight2) + 60 - pos.y - frontdir.y * speedf * 20;
+		float hdif = std::max(gHeight, gHeight2) + 60 - pos.y - frontdir.y * speedf * 20;
 		float minPitch;//=min(1.0f,hdif/(maxElevator*speedf*speedf*20));
 
 		if (hdif &lt; -(maxElevator * speedf * speedf * 20)) {
@@ -610,7 +610,7 @@
 	if(groundTarget)
 		engine = 1;
 	else
-		engine = min(1.f, (float)(goalLength / owner-&gt;maxRange + 1 - goalDir.dot(frontdir) * 0.7f));
+		engine = std::min(1.f, (float)(goalLength / owner-&gt;maxRange + 1 - goalDir.dot(frontdir) * 0.7f));
 
 	UpdateAirPhysics(rudder, aileron, elevator, engine, owner-&gt;frontdir);
 /*
@@ -680,7 +680,7 @@
 		float3 otherDif = lastColWarning-&gt;pos - pos;
 		float otherLength = otherDif.Length();
 		otherDir = otherDif / (otherLength + 0.01f);
-		otherThreat = max(1200.0f, goalLength) / otherLength * 0.036f;
+		otherThreat = std::max(1200.0f, goalLength) / otherLength * 0.036f;
 	}
 
 	float goalDot = rightdir.dot(adjustedGoalDir);
@@ -744,7 +744,7 @@
 		}
 		if (notColliding) {
 			float gHeight2 = ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40);
-			float hdif = max(gHeight, gHeight2) + wantedHeight - pos.y - frontdir.y * speedf * 20;
+			float hdif = std::max(gHeight, gHeight2) + wantedHeight - pos.y - frontdir.y * speedf * 20;
 			if (hdif &lt; -(maxElevator * speedf * speedf * 20) &amp;&amp; frontdir.y &gt; -maxPitch) {
 				elevator = -1;
 			} else if (hdif &gt; (maxElevator * speedf * speedf * 20) &amp;&amp; frontdir.y &lt; maxPitch) {
@@ -876,7 +876,7 @@
 	float dist = dif.Length();
 	dif /= dist;
 
-	float wsf = min(owner-&gt;maxSpeed, dist / speedf * 1.8f * maxAcc);
+	float wsf = std::min(owner-&gt;maxSpeed, dist / speedf * 1.8f * maxAcc);
 	float3 wantedSpeed = dif * wsf;
 
 	float3 delta = wantedSpeed - speed;
@@ -958,7 +958,7 @@
 #ifdef DIRECT_CONTROL_ALLOWED
 	if (owner-&gt;directControl) {
 		if ((pos.y - gHeight) &gt; wantedHeight * 1.2f) {
-			engine = max(0.0f, min(engine, 1 - (pos.y - gHeight - wantedHeight * 1.2f) / wantedHeight));
+			engine = std::max(0.0f, std::min(engine, 1 - (pos.y - gHeight - wantedHeight * 1.2f) / wantedHeight));
 		}
 		// check next position given current (unadjusted) pos and speed
 		nextPosInBounds = (pos + speed).CheckInBounds();

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -309,7 +309,7 @@
 					currentDistanceToWaypoint &lt; BreakingDistance(currentSpeed) + SQUARE_SIZE) {
 					wantedSpeed = std::min((float) wantedSpeed, (float) (sqrt(currentDistanceToWaypoint * -owner-&gt;mobility-&gt;maxBreaking)));
 				}
-				wantedSpeed *= max(0.0f, std::min(1.0f, desiredVelocity.dot(owner-&gt;frontdir) + 0.1f));
+				wantedSpeed *= std::max(0.0f, std::min(1.0f, desiredVelocity.dot(owner-&gt;frontdir) + 0.1f));
 				SetDeltaSpeed();
 			}
 		} else {
@@ -458,7 +458,7 @@
 	//Sets the new goal.
 	goalPos = moveGoalPos;
 	goalRadius = goalRadius;
-	requestedSpeed = min(speed, maxSpeed * 2);
+	requestedSpeed = std::min(speed, maxSpeed * 2);
 	requestedTurnRate = owner-&gt;mobility-&gt;maxTurnRate;
 	atGoal = false;
 	useMainHeading = false;
@@ -548,7 +548,7 @@
 			nextDeltaSpeedUpdate=gs-&gt;frameNum;
 		} else {
 			deltaSpeed=accRate;
-			nextDeltaSpeedUpdate=(int)(gs-&gt;frameNum+min((float)8,dif/accRate));
+			nextDeltaSpeedUpdate = (int)(gs-&gt;frameNum + std::min((float)8,dif/accRate));
 		}
 	}else {		//break, Breakrate = -3*accRate
 		if(dif &gt; -3*accRate){
@@ -556,7 +556,7 @@
 			nextDeltaSpeedUpdate=gs-&gt;frameNum+1;
 		} else {
 			deltaSpeed = -3*accRate;
-			nextDeltaSpeedUpdate=(int)(gs-&gt;frameNum+min((float)8,dif/(-3*accRate)));
+			nextDeltaSpeedUpdate = (int)(gs-&gt;frameNum + std::min((float)8,dif/(-3*accRate)));
 		}
 	}
 	//float3 temp=UpVector*wSpeed;
@@ -578,9 +578,9 @@
 	deltaHeading = wantedHeading - heading;
 
 	if(deltaHeading&gt;0){
-		heading += min(deltaHeading,(short)turnRate);
+		heading += std::min(deltaHeading,(short)turnRate);
 	} else {
-		heading += max((short)-turnRate,deltaHeading);
+		heading += std::max((short)-turnRate,deltaHeading);
 	}
 
 	owner-&gt;frontdir = GetVectorFromHeading(heading);
@@ -1697,11 +1697,11 @@
 {
 	float goalDist=goalPos.distance2D(owner-&gt;pos);
 
-	int minx=(int)max(0.f,(goalPos.x-goalDist)/(SQUARE_SIZE*2));
-	int minz=(int)max(0.f,(goalPos.z-goalDist)/(SQUARE_SIZE*2));
+	int minx = (int) std::max(0.f,(goalPos.x-goalDist)/(SQUARE_SIZE*2));
+	int minz = (int) std::max(0.f,(goalPos.z-goalDist)/(SQUARE_SIZE*2));
 
-	int maxx=(int)min(float(gs-&gt;hmapx-1),(goalPos.x+goalDist)/(SQUARE_SIZE*2));
-	int maxz=(int)min(float(gs-&gt;hmapy-1),(goalPos.z+goalDist)/(SQUARE_SIZE*2));
+	int maxx = (int) std::min(float(gs-&gt;hmapx-1),(goalPos.x+goalDist)/(SQUARE_SIZE*2));
+	int maxz = (int) std::min(float(gs-&gt;hmapy-1),(goalPos.z+goalDist)/(SQUARE_SIZE*2));
 
 	MoveData* md=owner-&gt;unitDef-&gt;movedata;
 	CMoveMath* mm=md-&gt;moveMath;

Modified: trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -94,7 +94,7 @@
 {
 	// aircraft need some marginals to avoid uber stacking
 	// when lots of them are ordered to one place
-	maxDrift = max(16.0f, distance);
+	maxDrift = std::max(16.0f, distance);
 	goalPos = newPos;
 	oldGoalPos = newPos;
 	forceHeading = false;
@@ -562,7 +562,7 @@
 	float wantedBank = 0.0f;
 	if (!noBanking) wantedBank = rightdir.dot(deltaSpeed)/accRate*0.5f;
 
-	float limit=min(1.0f,goalPos.distance2D(owner-&gt;pos)*0.15f);
+	float limit = std::min(1.0f,goalPos.distance2D(owner-&gt;pos)*0.15f);
 	if(wantedBank&gt;limit)
 		wantedBank=limit;
 	else if(wantedBank&lt;-limit)
@@ -570,9 +570,9 @@
 
 	//Adjust our banking to the desired value
 	if (currentBank &gt; wantedBank)
-		currentBank -= min(0.03f, currentBank - wantedBank);
+		currentBank -= std::min(0.03f, currentBank - wantedBank);
 	else
-		currentBank += min(0.03f, wantedBank - currentBank);
+		currentBank += std::min(0.03f, wantedBank - currentBank);
 
 	// Calculate a suitable upvector
 	updir = rightdir.cross(frontdir);
@@ -613,8 +613,9 @@
 	}
 
 	speed.y = yspeed;
-	float h = pos.y - max(ground-&gt;GetHeight(pos.x, pos.z),
-						  ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40));
+	float h = pos.y - std::max(
+		ground-&gt;GetHeight(pos.x, pos.z),
+		ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40));
 
 	if (h &lt; 4) {
 		speed.x *= 0.95f;
@@ -648,10 +649,10 @@
 	}
 
 	if (speed.y &gt; ws) {
-		speed.y = max(ws, speed.y - accRate * 1.5f);
+		speed.y = std::max(ws, speed.y - accRate * 1.5f);
 	} else {
 		// let them accelerate upward faster if close to ground
-		speed.y = min(ws, speed.y + accRate * (h &lt; 20? 2.0f: 0.7f));
+		speed.y = std::min(ws, speed.y + accRate * (h &lt; 20? 2.0f: 0.7f));
 	}
 
 	pos += speed;
@@ -774,7 +775,7 @@
 
 					owner-&gt;pos = pos;
 					owner-&gt;AddBuildPower(unit-&gt;unitDef-&gt;buildSpeed / 30, unit);
-					owner-&gt;currentFuel = min(owner-&gt;unitDef-&gt;maxFuel,
+					owner-&gt;currentFuel = std::min(owner-&gt;unitDef-&gt;maxFuel,
 							owner-&gt;currentFuel + (owner-&gt;unitDef-&gt;maxFuel
 									/ (GAME_SPEED * owner-&gt;unitDef-&gt;refuelTime)));
 
@@ -885,7 +886,7 @@
 void CTAAirMoveType::SlowUpdate(void)
 {
 	if (aircraftState != AIRCRAFT_LANDED &amp;&amp; owner-&gt;unitDef-&gt;maxFuel &gt; 0)
-		owner-&gt;currentFuel = max(0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
+		owner-&gt;currentFuel = std::max(0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
 
 	if (!reservedPad &amp;&amp; aircraftState == AIRCRAFT_FLYING 
 			&amp;&amp; owner-&gt;health &lt; owner-&gt;maxHealth * repairBelowHealth) {

Modified: trunk/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- trunk/rts/Sim/Path/PathEstimator.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Path/PathEstimator.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -41,13 +41,13 @@
 const float PATHCOST_INFINITY = 10000000;
 const int SQUARES_TO_UPDATE = 600;
 
-extern string stupidGlobalMapname;
+extern std::string stupidGlobalMapname;
 
 
 /*
  * constructor, loads precalculated data if it exists
  */
-CPathEstimator::CPathEstimator(CPathFinder* pf, unsigned int BSIZE, unsigned int mmOpt, string name):
+CPathEstimator::CPathEstimator(CPathFinder* pf, unsigned int BSIZE, unsigned int mmOpt, std::string name):
 	pathFinder(pf),
 	BLOCK_SIZE(BSIZE),
 	BLOCK_PIXEL_SIZE(BSIZE * SQUARE_SIZE),
@@ -437,8 +437,8 @@
 	}
 
 	// error-check
-	upperX = min(upperX, nbrOfBlocksX - 1);
-	upperZ = min(upperZ, nbrOfBlocksZ - 1);
+	upperX = std::min(upperX, nbrOfBlocksX - 1);
+	upperZ = std::min(upperZ, nbrOfBlocksZ - 1);
 	if (lowerX &lt; 0) lowerX = 0;
 	if (lowerZ &lt; 0) lowerZ = 0;
 
@@ -784,13 +784,13 @@
  * try to read offset and vertices data from file, return false on failure
  * TODO: Read-error-check.
  */
-bool CPathEstimator::ReadFile(string name)
+bool CPathEstimator::ReadFile(std::string name)
 {
 	unsigned int hash = Hash();
 	char hashString[50];
 	sprintf(hashString, &quot;%u&quot;, hash);
 
-	string filename = string(&quot;maps/paths/&quot;) + stupidGlobalMapname.substr(0, stupidGlobalMapname.find_last_of('.') + 1) + hashString + &quot;.&quot; + name + &quot;.zip&quot;;
+	std::string filename = std::string(&quot;maps/paths/&quot;) + stupidGlobalMapname.substr(0, stupidGlobalMapname.find_last_of('.') + 1) + hashString + &quot;.&quot; + name + &quot;.zip&quot;;
 
 	// open file for reading from a suitable location (where the file exists)
 	CArchiveZip* pfile = SAFE_NEW CArchiveZip(filesystem.LocateFile(filename));
@@ -831,7 +831,7 @@
 /*
  * try to write offset and vertex data to file
  */
-void CPathEstimator::WriteFile(string name) {
+void CPathEstimator::WriteFile(std::string name) {
 	// We need this directory to exist
 	if (!filesystem.CreateDirectory(&quot;maps/paths&quot;))
 		return;
@@ -840,7 +840,7 @@
 	char hashString[50];
 	sprintf(hashString,&quot;%u&quot;,hash);
 
-	string filename = string(&quot;maps/paths/&quot;) + stupidGlobalMapname.substr(0, stupidGlobalMapname.find_last_of('.') + 1) + hashString + &quot;.&quot; + name + &quot;.zip&quot;;
+	std::string filename = std::string(&quot;maps/paths/&quot;) + stupidGlobalMapname.substr(0, stupidGlobalMapname.find_last_of('.') + 1) + hashString + &quot;.&quot; + name + &quot;.zip&quot;;
 	zipFile file;
 
 	// open file for writing in a suitable location
@@ -1037,8 +1037,8 @@
 	int xm = (int) (pos.x / (SQUARE_SIZE * BLOCK_SIZE));
 	int ym = (int) (pos.z / (SQUARE_SIZE * BLOCK_SIZE));
 
-	for (int y = max(0, ym - 1); y &lt;= min(nbrOfBlocksZ - 1, ym + 1); ++y) {
-		for (int x = max(0, xm - 1); x &lt;= min(nbrOfBlocksX - 1, xm + 1); ++x) {
+	for (int y = std::max(0, ym - 1); y &lt;= std::min(nbrOfBlocksZ - 1, ym + 1); ++y) {
+		for (int x = std::max(0, xm - 1); x &lt;= std::min(nbrOfBlocksX - 1, xm + 1); ++x) {
 			startPos.push_back(float3(blockState[y * nbrOfBlocksX + x].sqrCenter[pathType].x * SQUARE_SIZE, 0, blockState[y * nbrOfBlocksX+x].sqrCenter[pathType].y * SQUARE_SIZE));
 		}
 	}

Modified: trunk/rts/Sim/Path/PathEstimator.h
===================================================================
--- trunk/rts/Sim/Path/PathEstimator.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Path/PathEstimator.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -36,7 +36,7 @@
 		 *		name of the corresponding map.
 		 *		Ex. PE-name &quot;pe&quot; + Mapname &quot;Desert&quot; =&gt; &quot;Desert.pe&quot;
 		 */
-		CPathEstimator(CPathFinder* pathFinder, unsigned int BLOCK_SIZE, unsigned int moveMathOpt, string name);
+		CPathEstimator(CPathFinder* pathFinder, unsigned int BLOCK_SIZE, unsigned int moveMathOpt, std::string name);
 		~CPathEstimator();
 
 		// note: thread-safety (see PathFinder.cpp)?
@@ -125,7 +125,7 @@
 				inline bool operator==(const OpenBlock&amp; ob) { return blocknr == ob.blocknr; }
 		};
 
-		struct lessCost: public binary_function&lt;OpenBlock*, OpenBlock*, bool&gt; {
+		struct lessCost: public std::binary_function&lt;OpenBlock*, OpenBlock*, bool&gt; {
 			inline bool operator() (const OpenBlock* x, const OpenBlock* y) const {
 				return (x-&gt;cost &gt; y-&gt;cost);
 			}
@@ -155,19 +155,19 @@
 		void FinishSearch(const MoveData&amp; moveData, Path&amp; path);
 		void ResetSearch();
 
-		bool ReadFile(string name);
-		void WriteFile(string name);
+		bool ReadFile(std::string name);
+		void WriteFile(std::string name);
 		unsigned int Hash();
 
 		CPathFinder* pathFinder;
 
-		int nbrOfBlocksX, nbrOfBlocksZ, nbrOfBlocks;							// Number of blocks on map.
-		BlockInfo* blockState;													// Map over all blocks and there states.
-		OpenBlock openBlockBuffer[MAX_SEARCHED_BLOCKS];							// The buffer to be used in the priority-queue.
-		OpenBlock *openBlockBufferPointer;										// Pointer to the current position in the buffer.
-		priority_queue&lt;OpenBlock*, vector&lt;OpenBlock*&gt;, lessCost&gt; openBlocks;	// The priority-queue used to select next block to be searched.
-		list&lt;int&gt; dirtyBlocks;													// List of blocks changed in last search.
-		list&lt;SingleBlock&gt; needUpdate;											// Blocks that may need an update due to map changes.
+		int nbrOfBlocksX, nbrOfBlocksZ, nbrOfBlocks;									// Number of blocks on map.
+		BlockInfo* blockState;															// Map over all blocks and there states.
+		OpenBlock openBlockBuffer[MAX_SEARCHED_BLOCKS];									// The buffer to be used in the priority-queue.
+		OpenBlock *openBlockBufferPointer;												// Pointer to the current position in the buffer.
+		std::priority_queue&lt;OpenBlock*, std::vector&lt;OpenBlock*&gt;, lessCost&gt; openBlocks;	// The priority-queue used to select next block to be searched.
+		std::list&lt;int&gt; dirtyBlocks;														// List of blocks changed in last search.
+		std::list&lt;SingleBlock&gt; needUpdate;												// Blocks that may need an update due to map changes.
 
 		static const int PATH_DIRECTIONS = 8;
 		static const int PATH_DIRECTION_VERTICES = PATH_DIRECTIONS / 2;

Modified: trunk/rts/Sim/Path/PathFinder.cpp
===================================================================
--- trunk/rts/Sim/Path/PathFinder.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Path/PathFinder.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -198,7 +198,7 @@
 	path.pathCost = PATHCOST_INFINITY;
 
 	//Store som basic data.
-	maxNodesToBeSearched = min((unsigned int)MAX_SEARCHED_SQUARES, maxNodes);
+	maxNodesToBeSearched = std::min((unsigned int)MAX_SEARCHED_SQUARES, maxNodes);
 	this-&gt;testMobile=testMobile;
 	this-&gt;exactPath = exactPath;
 	this-&gt;needPath=needPath;

Modified: trunk/rts/Sim/Path/PathFinder.h
===================================================================
--- trunk/rts/Sim/Path/PathFinder.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Path/PathFinder.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -6,7 +6,6 @@
 #include &quot;Sim/MoveTypes/MoveMath/MoveMath.h&quot;
 #include &lt;queue&gt;
 #include &lt;list&gt;
-using namespace std;
 
 class CPathFinderDef;
 
@@ -160,9 +159,9 @@
 	unsigned int maxNodesToBeSearched;
 	myPQ openSquares;
 
-	SquareState* squareState;		//Map of all squares on map.
-	//list&lt;int&gt; dirtySquares;			//Squares tested by search.
-	vector&lt;int&gt; dirtySquares;
+	SquareState* squareState;			// Map of all squares on map.
+	// std::list&lt;int&gt; dirtySquares;		// Squares tested by search.
+	std::vector&lt;int&gt; dirtySquares;
 
 	int2 directionVector[16];		//Unit square-movement in given direction.
 	float moveCost[16];				//The cost of moving in given direction.

Modified: trunk/rts/Sim/Path/PathManager.cpp
===================================================================
--- trunk/rts/Sim/Path/PathManager.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Path/PathManager.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -302,7 +302,7 @@
 		return float3(-1,-1,-1);
 
 	//Find corresponding multipath.
-	map&lt;unsigned int, MultiPath*&gt;::iterator pi = pathMap.find(pathId);
+	std::map&lt;unsigned int, MultiPath*&gt;::iterator pi = pathMap.find(pathId);
 	if(pi == pathMap.end())
 		return float3(-1,-1,-1);
 	MultiPath* multiPath = pi-&gt;second;
@@ -358,7 +358,7 @@
 		return;
 
 	//Find the multipath.
-	map&lt;unsigned int, MultiPath*&gt;::iterator pi = pathMap.find(pathId);
+	std::map&lt;unsigned int, MultiPath*&gt;::iterator pi = pathMap.find(pathId);
 	if(pi == pathMap.end())
 		return;
 	MultiPath* multiPath = pi-&gt;second;
@@ -405,10 +405,10 @@
 	glDisable(GL_TEXTURE_2D);
 	glDisable(GL_LIGHTING);
 	glLineWidth(3);
-	map&lt;unsigned int, MultiPath*&gt;::iterator pi;
+	std::map&lt;unsigned int, MultiPath*&gt;::iterator pi;
 	for(pi = pathMap.begin(); pi != pathMap.end(); pi++) {
 		MultiPath* path = pi-&gt;second;
-		list&lt;float3&gt;::iterator pvi;
+		std::list&lt;float3&gt;::iterator pvi;
 
 		//Start drawing a line.
 		glBegin(GL_LINE_STRIP);
@@ -451,34 +451,34 @@
 
 
 void CPathManager::GetEstimatedPath(unsigned int pathId,
-                                      vector&lt;float3&gt;&amp; points,
-                                      vector&lt;int&gt;&amp; starts) const
+	std::vector&lt;float3&gt;&amp; points,
+	std::vector&lt;int&gt;&amp; starts) const
 {
 	points.clear();
 	starts.clear();
 
-	map&lt;unsigned int, MultiPath*&gt;::const_iterator pi = pathMap.find(pathId);
+	std::map&lt;unsigned int, MultiPath*&gt;::const_iterator pi = pathMap.find(pathId);
 	if (pi == pathMap.end()) {
 		return;
 	}
 	const MultiPath* path = pi-&gt;second;
 
-	list&lt;float3&gt;::const_reverse_iterator pvi;
+	std::list&lt;float3&gt;::const_reverse_iterator pvi;
 
 	starts.push_back(points.size());
-	const list&lt;float3&gt;&amp; dtlPoints = path-&gt;detailedPath.path;
+	const std::list&lt;float3&gt;&amp; dtlPoints = path-&gt;detailedPath.path;
 	for (pvi = dtlPoints.rbegin(); pvi != dtlPoints.rend(); pvi++) {
 		points.push_back(*pvi);
 	}
 
 	starts.push_back(points.size());
-	const list&lt;float3&gt;&amp; estPoints = path-&gt;estimatedPath.path;
+	const std::list&lt;float3&gt;&amp; estPoints = path-&gt;estimatedPath.path;
 	for (pvi = estPoints.rbegin(); pvi != estPoints.rend(); pvi++) {
 		points.push_back(*pvi);
 	}
 
 	starts.push_back(points.size());
-	const list&lt;float3&gt;&amp; est2Points = path-&gt;estimatedPath2.path;
+	const std::list&lt;float3&gt;&amp; est2Points = path-&gt;estimatedPath2.path;
 	for (pvi = est2Points.rbegin(); pvi != est2Points.rend(); pvi++) {
 		points.push_back(*pvi);
 	}

Modified: trunk/rts/Sim/Path/PathManager.h
===================================================================
--- trunk/rts/Sim/Path/PathManager.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Path/PathManager.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -3,7 +3,6 @@
 
 #include &lt;map&gt;
 #include &quot;IPath.h&quot;
-using namespace std;
 
 class CSolidObject;
 class CPathFinder;
@@ -77,7 +76,7 @@
 			The list of starting indices for the different estimation levels
 	*/
 	void GetEstimatedPath(unsigned int pathId,
-	                        vector&lt;float3&gt;&amp; points, vector&lt;int&gt;&amp; starts) const;
+		std::vector&lt;float3&gt;&amp; points, std::vector&lt;int&gt;&amp; starts) const;
 
 
 	/*
@@ -148,7 +147,7 @@
 	CPathEstimator* pe;
 	CPathEstimator* pe2;
 
-	map&lt;unsigned int, MultiPath*&gt; pathMap;
+	std::map&lt;unsigned int, MultiPath*&gt; pathMap;
 	unsigned int nextPathId;
 
 	CMoveMath* ground;

Modified: trunk/rts/Sim/Projectiles/PieceProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/PieceProjectile.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Projectiles/PieceProjectile.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -352,7 +352,7 @@
 				dir2.Normalize();
 
 				float a1 = ((1 - 0.0f / (Smoke_Time)) * 255) * (0.7f + fabs(dif.dot(dir)));
-				float alpha = min(255.0f, max(0.f, a1));
+				float alpha = std::min(255.0f, std::max(0.f, a1));
 				col[0] = (unsigned char) (color * alpha);
 				col[1] = (unsigned char) (color * alpha);
 				col[2] = (unsigned char) (color * alpha);
@@ -364,7 +364,7 @@
 				if (age &lt; 8)
 					a2 = 0;
 
-				alpha = min(255.0f, max(0.f, a2));
+				alpha = std::min(255.0f, std::max(0.f, a2));
 				col2[0] = (unsigned char) (color * alpha);
 				col2[1] = (unsigned char) (color * alpha);
 				col2[2] = (unsigned char) (color * alpha);

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -343,7 +343,7 @@
 
 			float a1 = (1.0f / (Smoke_Time)) * 255;
 			a1 *= 0.7f + fabs(dif.dot(dir));
-			float alpha = min(255.0f, max(0.0f, a1));
+			float alpha = std::min(255.0f, std::max(0.0f, a1));
 			col[0] = (unsigned char) (color * alpha);
 			col[1] = (unsigned char) (color * alpha);
 			col[2] = (unsigned char) (color * alpha);
@@ -356,7 +356,7 @@
 				a2 = 0;
 
 			a2 *= 0.7f + fabs(dif2.dot(oldDir));
-			alpha = min(255.0f, max(0.0f, a2));
+			alpha = std::min(255.0f, std::max(0.0f, a2));
 			col2[0] = (unsigned char) (color * alpha);
 			col2[1] = (unsigned char) (color * alpha);
 			col2[2] = (unsigned char) (color * alpha);
@@ -466,7 +466,7 @@
 	if (ttl &gt; 0) {
 		// steer away twice as fast as we can steer toward target
 		float3 dif2 = sdir - dir;
-		float tracking = max(shieldForce * 0.05f, weaponDef-&gt;turnrate * 2);
+		float tracking = std::max(shieldForce * 0.05f, weaponDef-&gt;turnrate * 2);
 
 		if (dif2.Length() &lt; tracking) {
 			dir = sdir;

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -73,7 +73,7 @@
 	this-&gt;uptime=uptime;
 	if (weaponDef) {
 		if (weaponDef-&gt;flighttime == 0) {
-			ttl=(int)min(3000.f,uptime+weaponDef-&gt;range/maxSpeed+100);
+			ttl = (int) std::min(3000.f,uptime+weaponDef-&gt;range/maxSpeed+100);
 		}
 		else {
 			ttl=weaponDef-&gt;flighttime;
@@ -280,7 +280,7 @@
 
 			float a1=(1-float(0)/(Smoke_Time))*255;
 			a1*=0.7f+fabs(dif.dot(dir));
-			int alpha=min(255,(int)max(0.f,a1));
+			int alpha = std::min(255, (int) std::max(0.f,a1));
 			col[0]=(unsigned char) (color*alpha);
 			col[1]=(unsigned char) (color*alpha);
 			col[2]=(unsigned char) (color*alpha);
@@ -290,7 +290,7 @@
 			a2*=0.7f+fabs(dif2.dot(oldSmokeDir));
 			if(age&lt;8)
 				a2=0;
-			alpha=min(255,(int)max(0.f,a2));
+			alpha = std::min(255, (int) std::max(0.f,a2));
 			col2[0]=(unsigned char) (color*alpha);
 			col2[1]=(unsigned char) (color*alpha);
 			col2[2]=(unsigned char) (color*alpha);
@@ -350,8 +350,8 @@
 		for(float a=0;a&lt;ospeed+0.6f;a+=0.15f){
 			float ageMod;
 			if(createAgeMods){
-				if(missileAge&lt;20)
-					ageMod=1;
+				if (missileAge &lt; 20)
+					ageMod = 1;
 				else
 					ageMod=0.6f+rand()*0.8f/RAND_MAX;
 				oldInfos[age]-&gt;ageMods.push_back(ageMod);
@@ -362,13 +362,13 @@
 			float3 interPos=opos-odir*(age*0.5f+a);
 			float drawsize;
 			col[3]=1;
-			if(missileAge&lt;20){
-				float alpha=max(0.f,((1-age2)*(1-age2)));
+			if (missileAge &lt; 20) {
+				float alpha = std::max(0.f,((1-age2)*(1-age2)));
 				col[0]=(unsigned char) (255*alpha);
 				col[1]=(unsigned char) (200*alpha);
 				col[2]=(unsigned char) (150*alpha);
 			} else {
-				float alpha=max(0.f,((1-age2)*max(0.f,(1-age2))));
+				float alpha = std::max(0.f,((1-age2) * std::max(0.f,(1-age2))));
 				col[0]=(unsigned char) (255*alpha);
 				col[1]=(unsigned char) (200*alpha);
 				col[2]=(unsigned char) (150*alpha);
@@ -428,15 +428,16 @@
 {
 	float3 sdir=pos-shieldPos;
 	sdir.Normalize();
-	if(ttl &gt; 0){
-		float3 dif2=sdir-dir;
-		float tracking=max(shieldForce*0.05f,weaponDef-&gt;turnrate*2);		//steer away twice as fast as we can steer toward target
-		if(dif2.Length()&lt;tracking){
-			dir=sdir;
+	if (ttl &gt; 0) {
+		float3 dif2 = sdir - dir;
+		// steer away twice as fast as we can steer toward target
+		float tracking = std::max(shieldForce * 0.05f, weaponDef-&gt;turnrate * 2);
+		if (dif2.Length() &lt; tracking) {
+			dir = sdir;
 		} else {
-			dif2-=dir*(dif2.dot(dir));
+			dif2 -= dir * (dif2.dot(dir));
 			dif2.Normalize();
-			dir+=dif2*tracking;
+			dir += dif2 * tracking;
 			dir.Normalize();
 		}
 		return 2;

Modified: trunk/rts/Sim/Units/COB/CobEngine.cpp
===================================================================
--- trunk/rts/Sim/Units/COB/CobEngine.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/COB/CobEngine.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -29,10 +29,10 @@
 CCobEngine::~CCobEngine(void)
 {
 	//Should delete all things that the scheduler knows
-	for (list&lt;CCobThread *&gt;::iterator i = running.begin(); i != running.end(); ++i) {
+	for (std::list&lt;CCobThread *&gt;::iterator i = running.begin(); i != running.end(); ++i) {
 		delete *i;
 	}
-	for (list&lt;CCobThread *&gt;::iterator i = wantToRun.begin(); i != wantToRun.end(); ++i) {
+	for (std::list&lt;CCobThread *&gt;::iterator i = wantToRun.begin(); i != wantToRun.end(); ++i) {
 		delete *i;
 	}
 	while (sleeping.size() &gt; 0) {
@@ -43,7 +43,7 @@
 	}
 
 	//Free all cobfiles
-	for (map&lt;string, CCobFile *&gt;::iterator i = cobFiles.begin(); i != cobFiles.end(); ++i) {
+	for (std::map&lt;std::string, CCobFile *&gt;::iterator i = cobFiles.begin(); i != cobFiles.end(); ++i) {
 		delete i-&gt;second;
 	}
 }
@@ -105,8 +105,8 @@
 	logOutput.Print(&quot;----&quot;);
 #endif
 
-	//Advance all running threads
-	for (list&lt;CCobThread *&gt;::iterator i = running.begin(); i != running.end(); ++i) {
+	// Advance all running threads
+	for (std::list&lt;CCobThread *&gt;::iterator i = running.begin(); i != running.end(); ++i) {
 		//logOutput.Print(&quot;Now 1running %d: %s&quot;, GCurrentTime, (*i)-&gt;GetName().c_str());
 #ifdef _CONSOLE
 		printf(&quot;----\n&quot;);
@@ -119,13 +119,14 @@
 		}
 	}
 
-	//A thread can never go from running-&gt;running, so clear the list
-	//note: if preemption was to be added, this would no longer hold
-	//however, ta scripts can not run preemptively anyway since there isn't any synchronization methods available
+	// A thread can never go from running-&gt;running, so clear the list
+	// note: if preemption was to be added, this would no longer hold
+	// however, ta scripts can not run preemptively anyway since there
+	// isn't any synchronization methods available
 	running.clear();
 
-	//The threads that just ran may have added new threads that should run next tick
-	for (list&lt;CCobThread *&gt;::iterator i = wantToRun.begin(); i != wantToRun.end(); ++i) {
+	// The threads that just ran may have added new threads that should run next tick
+	for (std::list&lt;CCobThread *&gt;::iterator i = wantToRun.begin(); i != wantToRun.end(); ++i) {
 		running.push_front(*i);
 	}
 	wantToRun.clear();
@@ -162,13 +163,13 @@
 		}
 	}
 
-	//Tick all instances that have registered themselves as animating
-	list&lt;CCobInstance *&gt;::iterator it = animating.begin();
-	list&lt;CCobInstance *&gt;::iterator curit;
-	while (it != animating.end()) {			
-		curit = it++;		
+	// Tick all instances that have registered themselves as animating
+	std::list&lt;CCobInstance *&gt;::iterator it = animating.begin();
+	std::list&lt;CCobInstance *&gt;::iterator curit;
+	while (it != animating.end()) {
+		curit = it++;
 		if ((*curit)-&gt;Tick(deltaTime) == -1)
-			animating.erase(curit);		
+			animating.erase(curit);
 	}
 }
 

Modified: trunk/rts/Sim/Units/COB/CobEngine.h
===================================================================
--- trunk/rts/Sim/Units/COB/CobEngine.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/COB/CobEngine.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -18,9 +18,7 @@
 class CCobInstance;
 class CCobFile;
 
-using namespace std;
-
-class CCobThreadPtr_less : public binary_function&lt;CCobThread *, CCobThread *, bool&gt; {
+class CCobThreadPtr_less : public std::binary_function&lt;CCobThread *, CCobThread *, bool&gt; {
 	CCobThread *a, *b;
 public:
 	bool operator() (const CCobThread *const &amp;a, const CCobThread *const &amp;b) const {return a-&gt;GetWakeTime() &gt; b-&gt;GetWakeTime();}
@@ -30,11 +28,11 @@
 class CCobEngine
 {
 protected:
-	list&lt;CCobThread *&gt; running;
-	list&lt;CCobThread *&gt; wantToRun;				//Threads are added here if they are in Running. And moved to real running after running is empty
-	priority_queue&lt;CCobThread *, vector&lt;CCobThread *&gt;, CCobThreadPtr_less&gt; sleeping;
-	list&lt;CCobInstance *&gt; animating;				//hash would be optimal. but not crucial.
-	map&lt;string, CCobFile *&gt; cobFiles;
+	std::list&lt;CCobThread *&gt; running;
+	std::list&lt;CCobThread *&gt; wantToRun;				//Threads are added here if they are in Running. And moved to real running after running is empty
+	std::priority_queue&lt;CCobThread *, vector&lt;CCobThread *&gt;, CCobThreadPtr_less&gt; sleeping;
+	std::list&lt;CCobInstance *&gt; animating;				//hash would be optimal. but not crucial.
+	std::map&lt;std::string, CCobFile *&gt; cobFiles;
 	CCobThread *curThread;
 public:
 	CCobEngine(void);
@@ -44,10 +42,10 @@
 	void RemoveInstance(CCobInstance *instance);
 	void Tick(int deltaTime);
 	void SetCurThread(CCobThread *cur);
-	void ShowScriptError(const string&amp; msg);
-	CCobFile&amp; GetCobFile(const string&amp; name);
-	CCobFile&amp; ReloadCobFile(const string&amp; name);
-	const CCobFile* GetScriptAddr(const string&amp; name) const;
+	void ShowScriptError(const std::string&amp; msg);
+	CCobFile&amp; GetCobFile(const std::string&amp; name);
+	CCobFile&amp; ReloadCobFile(const std::string&amp; name);
+	const CCobFile* GetScriptAddr(const std::string&amp; name) const;
 };
 
 extern CCobEngine GCobEngine;

Modified: trunk/rts/Sim/Units/COB/CobFile.cpp
===================================================================
--- trunk/rts/Sim/Units/COB/CobFile.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/COB/CobFile.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -230,7 +230,7 @@
 
 int CCobFile::getFunctionId(const string &amp;name)
 {
-	map&lt;string, int&gt;::iterator i;
+	std::map&lt;std::string, int&gt;::iterator i;
 	if ((i = scriptMap.find(name)) != scriptMap.end()) {
 		return i-&gt;second;
 	}

Modified: trunk/rts/Sim/Units/COB/CobFile.h
===================================================================
--- trunk/rts/Sim/Units/COB/CobFile.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/COB/CobFile.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -16,8 +16,6 @@
 // Should return true for scripts that should have debug output. 
 #define COB_DEBUG_FILTER (script.name == &quot;scripts/ARMJETH.cob&quot;)
 
-using namespace std;
-
 class CFileHandler;
 
 //These are mapped by the CCobFile at startup to make common function calls faster
@@ -54,21 +52,21 @@
 class CCobFile
 {
 public:
-	vector&lt;string&gt; scriptNames;
-	vector&lt;int&gt; scriptOffsets;
-	vector&lt;int&gt; scriptLengths;			//Assumes that the scripts are sorted by offset in the file
-	vector&lt;string&gt; pieceNames;
-	vector&lt;int&gt; scriptIndex;
-	vector&lt;int&gt; sounds;
-	map&lt;string, int&gt; scriptMap;
-	vector&lt;LuaHashString&gt; luaScripts;
+	std::vector&lt;std::string&gt; scriptNames;
+	std::vector&lt;int&gt; scriptOffsets;
+	std::vector&lt;int&gt; scriptLengths;			//Assumes that the scripts are sorted by offset in the file
+	std::vector&lt;std::string&gt; pieceNames;
+	std::vector&lt;int&gt; scriptIndex;
+	std::vector&lt;int&gt; sounds;
+	std::map&lt;std::string, int&gt; scriptMap;
+	std::vector&lt;LuaHashString&gt; luaScripts;
 	int* code;
 	int numStaticVars;
-	string name;
+	std::string name;
 public:
-	CCobFile(CFileHandler &amp;in, string name);
+	CCobFile(CFileHandler &amp;in, std::string name);
 	~CCobFile(void);
-	int getFunctionId(const string &amp;name);
+	int getFunctionId(const std::string &amp;name);
 };
 
 #endif // __COB_FILE_H__

Modified: trunk/rts/Sim/Units/COB/CobInstance.cpp
===================================================================
--- trunk/rts/Sim/Units/COB/CobInstance.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/COB/CobInstance.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -172,7 +172,7 @@
 	//Can't delete the thread here because that would confuse the scheduler to no end
 	//Instead, mark it as dead. It is the function calling Tick that is responsible for delete.
 	//Also unregister all callbacks
-	for (list&lt;CCobThread *&gt;::iterator i = threads.begin(); i != threads.end(); ++i) {
+	for (std::list&lt;CCobThread *&gt;::iterator i = threads.begin(); i != threads.end(); ++i) {
 		(*i)-&gt;state = CCobThread::Dead;
 		(*i)-&gt;SetCallback(NULL, NULL, NULL);
 	}
@@ -180,11 +180,11 @@
 	// Remove us from possible animation ticking (should only be needed when anims.size() &gt; 0
 	GCobEngine.RemoveInstance(this);
 
-	for (list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
+	for (std::list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
 
 		//All threads blocking on animations can be killed safely from here since the scheduler does not
 		//know about them
-		for (list&lt;CCobThread *&gt;::iterator j = (*i)-&gt;listeners.begin(); j != (*i)-&gt;listeners.end(); ++j) {
+		for (std::list&lt;CCobThread *&gt;::iterator j = (*i)-&gt;listeners.begin(); j != (*i)-&gt;listeners.end(); ++j) {
 			delete *j;
 		}
 		delete *i;
@@ -192,7 +192,7 @@
 }
 int CCobInstance::Call(const string &amp;fname)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	return Call(fname, x, NULL, NULL, NULL);
 }
 
@@ -203,14 +203,14 @@
 
 int CCobInstance::Call(const string &amp;fname, int p1)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	x.push_back(p1);
 	return Call(fname, x, NULL, NULL, NULL);
 }
 
 int CCobInstance::Call(const string &amp;fname, CBCobThreadFinish cb, void *p1, void *p2)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	return Call(fname, x, cb, p1, p2);
 }
 
@@ -227,13 +227,13 @@
 
 int CCobInstance::Call(int id)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	return Call(id, x, NULL, NULL, NULL);
 }
 
 int CCobInstance::Call(int id, int p1)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	x.push_back(p1);
 	return Call(id, x, NULL, NULL, NULL);
 }
@@ -245,7 +245,7 @@
 
 int CCobInstance::Call(int id, CBCobThreadFinish cb, void *p1, void *p2)
 {
-	vector&lt;int&gt; x;
+	std::vector&lt;int&gt; x;
 	return Call(id, x, cb, p1, p2);
 }
 
@@ -398,7 +398,7 @@
 // Unblocks all threads waiting on this animation
 void CCobInstance::UnblockAll(struct AnimInfo * anim)
 {
-	list&lt;CCobThread *&gt;::iterator li;
+	std::list&lt;CCobThread *&gt;::iterator li;
 
 	for (li = anim-&gt;listeners.begin(); li != anim-&gt;listeners.end(); ++li) {
 		//Not sure how to do this more cleanly.. Will probably rewrite it
@@ -420,8 +420,8 @@
 int CCobInstance::Tick(int deltaTime)
 {
 	int done;
-	list&lt;struct AnimInfo *&gt;::iterator it = anims.begin();
-	list&lt;struct AnimInfo *&gt;::iterator cur;
+	std::list&lt;struct AnimInfo *&gt;::iterator it = anims.begin();
+	std::list&lt;struct AnimInfo *&gt;::iterator cur;
 
 	while (it != anims.end()) {
 		//Advance it, so we can erase cur safely
@@ -461,7 +461,7 @@
 //Returns anims list
 struct CCobInstance::AnimInfo *CCobInstance::FindAnim(AnimType type, int piece, int axis)
 {
-	for (list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
+	for (std::list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
 		if (((*i)-&gt;type == type) &amp;&amp; ((*i)-&gt;piece == piece) &amp;&amp; ((*i)-&gt;axis == axis))
 			return *i;
 	}
@@ -471,7 +471,7 @@
 // Returns true if an animation was found and deleted
 void CCobInstance::RemoveAnim(AnimType type, int piece, int axis)
 {
-	for (list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
+	for (std::list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
 		if (((*i)-&gt;type == type) &amp;&amp; ((*i)-&gt;piece == piece) &amp;&amp; ((*i)-&gt;axis == axis)) {
 
 			// We need to unblock threads waiting on this animation, otherwise they will be lost in the void
@@ -795,7 +795,7 @@
 
 void CCobInstance::Signal(int signal)
 {
-	for (list&lt;CCobThread *&gt;::iterator i = threads.begin(); i != threads.end(); ++i) {
+	for (std::list&lt;CCobThread *&gt;::iterator i = threads.begin(); i != threads.end(); ++i) {
 		if ((signal &amp; (*i)-&gt;signalMask) != 0) {
 			(*i)-&gt;state = CCobThread::Dead;
 			//logOutput.Print(&quot;Killing a thread %d %d&quot;, signal, (*i)-&gt;signalMask);
@@ -1256,9 +1256,9 @@
 		return weapon-&gt;AttackGround(pos, userTarget) ? 1 : 0;
 	}
 	case MIN:
-		return min(p1, p2);
+		return std::min(p1, p2);
 	case MAX:
-		return max(p1, p2);
+		return std::max(p1, p2);
 	case ABS:
 		return abs(p1);
 	case FLANK_B_MODE:
@@ -1609,7 +1609,7 @@
 		case SHIELD_POWER: {
 			if (unit-&gt;shieldWeapon != NULL) {
 				CPlasmaRepulser* shield = (CPlasmaRepulser*)unit-&gt;shieldWeapon;
-				shield-&gt;curPower = max(0.0f, float(param) / float(COBSCALE));
+				shield-&gt;curPower = std::max(0.0f, float(param) / float(COBSCALE));
 			}
 			break;
 		}

Modified: trunk/rts/Sim/Units/COB/CobInstance.h
===================================================================
--- trunk/rts/Sim/Units/COB/CobInstance.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/COB/CobInstance.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -24,14 +24,12 @@
 class CCobInstance;
 class CUnit;
 
-using namespace std;
-
 typedef void (*CBCobThreadFinish) (int retCode, void *p1, void *p2);
 
 struct PieceInfo {
 	int coords[3];
 	int rot[3];
-	string name;
+	std::string name;
 	bool updated;
 	bool visible;
 };
@@ -65,9 +63,9 @@
 		int dest;		//means final position when turning or moving, final speed when spinning
 		int accel;		//used for spinning, can be negative
 		bool interpolated;	//true if this animation is a result of interpolating a direct move/turn
-		list&lt;CCobThread *&gt; listeners;
+		std::list&lt;CCobThread *&gt; listeners;
 	};
-	list&lt;struct AnimInfo *&gt; anims;
+	std::list&lt;struct AnimInfo *&gt; anims;
 	CUnit *unit;
 	bool yardOpen;
 	void UnblockAll(struct AnimInfo * anim);
@@ -80,9 +78,9 @@
 
 public:
 	bool busy;
-	vector&lt;int&gt; staticVars;
-	list&lt;CCobThread *&gt; threads;
-	vector&lt;struct PieceInfo&gt; pieces;	
+	std::vector&lt;int&gt; staticVars;
+	std::list&lt;CCobThread *&gt; threads;
+	std::vector&lt;struct PieceInfo&gt; pieces;	
 	bool smoothAnim;
 	const CCobFile* GetScriptAddr() const { return &script; }
 
@@ -99,19 +97,19 @@
 	inline       CUnit* GetUnit()       { return unit; }
 	inline const CUnit* GetUnit() const { return unit; }
 	void InitVars();
-	int Call(const string &amp;fname);
-	int Call(const string &amp;fname, int p1);
-	int Call(const string &amp;fname, vector&lt;int&gt; &amp;args);
-	int Call(const string &amp;fname, CBCobThreadFinish cb, void *p1, void *p2);
-	int Call(const string &amp;fname, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
+	int Call(const std::string &amp;fname);
+	int Call(const std::string &amp;fname, int p1);
+	int Call(const std::string &amp;fname, std::vector&lt;int&gt; &amp;args);
+	int Call(const std::string &amp;fname, CBCobThreadFinish cb, void *p1, void *p2);
+	int Call(const std::string &amp;fname, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
 	int Call(int id);
-	int Call(int id, vector&lt;int&gt; &amp;args);
+	int Call(int id, std::vector&lt;int&gt; &amp;args);
 	int Call(int id, int p1);
 	int Call(int id, CBCobThreadFinish cb, void *p1, void *p2);
-	int Call(int id, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
-	int RawCall(int fn, vector&lt;int&gt; &amp;args);
-	int RawCall(int fn, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
-	int RealCall(int functionId, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
+	int Call(int id, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
+	int RawCall(int fn, std::vector&lt;int&gt; &amp;args);
+	int RawCall(int fn, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
+	int RealCall(int functionId, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
 	int Tick(int deltaTime);
 	int MoveToward(int &amp;cur, int dest, int speed);
 	int TurnToward(int &amp;cur, int dest, int speed);
@@ -141,7 +139,7 @@
 	void TurnSmooth(int piece, int axis, int destination, int delta, int deltaTime);
 	bool HasScriptFunction(int id);
 	bool FunctionExist(int id);
-	int GetFunctionId(const string&amp; funcName) const;
+	int GetFunctionId(const std::string&amp; funcName) const;
 };
 
 #endif // __COB_INSTANCE_H__

Modified: trunk/rts/Sim/Units/COB/CobThread.cpp
===================================================================
--- trunk/rts/Sim/Units/COB/CobThread.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/COB/CobThread.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -923,10 +923,10 @@
 	const int r2 = GET_LONG_PC(); // arg count
 
 	// setup the parameter array
-	const int size = (int)stack.size();
-	const int argCount = min(r2, MAX_LUA_COB_ARGS);
-	const int start = max(0, size - r2);
-	const int end = min(size, start + argCount);
+	const int size = (int) stack.size();
+	const int argCount = std::min(r2, MAX_LUA_COB_ARGS);
+	const int start = std::max(0, size - r2);
+	const int end = std::min(size, start + argCount);
 	int a = 0;
 	for (int i = start; i &lt; end; i++) {
 		luaArgs[a] = stack[i];

Modified: trunk/rts/Sim/Units/COB/CobThread.h
===================================================================
--- trunk/rts/Sim/Units/COB/CobThread.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/COB/CobThread.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -10,8 +10,6 @@
 class CCobFile;
 class CCobInstance;
 
-using namespace std;
-
 class CCobThread : public CObject
 {
 protected:

Modified: trunk/rts/Sim/Units/CommandAI/Command.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/Command.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/CommandAI/Command.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -6,10 +6,6 @@
 #include &lt;limits.h&gt; // for INT_MAX
 #include &quot;creg/creg.h&quot;
 
-
-using namespace std; // FIXME -- should not have this in an external interface?
-
-
 // cmds lower than 0 is reserved for build options (cmd -x = unitdefs[x])
 #define CMD_STOP                   0
 #define CMD_INSERT                 1

Modified: trunk/rts/Sim/Units/CommandAI/CommandAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -958,8 +958,8 @@
 					BuildInfo bc(c);
 					BuildInfo bt(t);
 					if (bc.def &amp;&amp; bt.def
-					    &amp;&amp; fabs(bc.pos.x - bt.pos.x) * 2 &lt;= max(bc.GetXSize(), bt.GetXSize()) * SQUARE_SIZE
-					    &amp;&amp; fabs(bc.pos.z - bt.pos.z) * 2 &lt;= max(bc.GetYSize(), bt.GetYSize()) * SQUARE_SIZE) {
+					    &amp;&amp; fabs(bc.pos.x - bt.pos.x) * 2 &lt;= std::max(bc.GetXSize(), bt.GetXSize()) * SQUARE_SIZE
+					    &amp;&amp; fabs(bc.pos.z - bt.pos.z) * 2 &lt;= std::max(bc.GetYSize(), bt.GetYSize()) * SQUARE_SIZE) {
 						return ci;
 					}
 				} else {
@@ -1058,8 +1058,8 @@
 						const float dist2Z = 2.0f * fabs(cbi.pos.z - tbi.pos.z);
 						const float addSizeX = SQUARE_SIZE * (cbi.GetXSize() + tbi.GetXSize());
 						const float addSizeZ = SQUARE_SIZE * (cbi.GetYSize() + tbi.GetYSize());
-						const float maxSizeX = SQUARE_SIZE * max(cbi.GetXSize(), tbi.GetXSize());
-						const float maxSizeZ = SQUARE_SIZE * max(cbi.GetYSize(), tbi.GetYSize());
+						const float maxSizeX = SQUARE_SIZE * std::max(cbi.GetXSize(), tbi.GetXSize());
+						const float maxSizeZ = SQUARE_SIZE * std::max(cbi.GetYSize(), tbi.GetYSize());
 						if (cbi.def &amp;&amp; tbi.def &amp;&amp;
 						    ((dist2X &gt; maxSizeX) || (dist2Z &gt; maxSizeZ)) &amp;&amp;
 						    ((dist2X &lt; addSizeX) &amp;&amp; (dist2Z &lt; addSizeZ))) {

Modified: trunk/rts/Sim/Units/CommandAI/FactoryCAI.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/FactoryCAI.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/CommandAI/FactoryCAI.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -5,8 +5,6 @@
 #include &lt;string&gt;
 #include &lt;map&gt;
 
-using namespace std;
-
 class CFactoryCAI :
 	public CCommandAI
 {
@@ -15,8 +13,8 @@
 	CR_DECLARE_SUB(BuildOption);
 	struct BuildOption {
 		CR_DECLARE_STRUCT(BuildOption)
-		string name;
-		string fullName;
+		std::string name;
+		std::string fullName;
 		int numQued;
 	};
 
@@ -40,7 +38,7 @@
 
 	CCommandQueue newUnitCommands;
 
-	map&lt;int,BuildOption&gt; buildOptions;
+	std::map&lt;int, BuildOption&gt; buildOptions;
 
 	bool building;
 

Modified: trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -335,7 +335,7 @@
 		const Command&amp; c = *it;
 		if ((c.id == CMD_SET_WANTED_MAX_SPEED) &amp;&amp; (c.params.size() &gt;= 1)) {
 			const float defMaxSpeed = owner-&gt;maxSpeed;
-			const float newMaxSpeed = min(c.params[0], defMaxSpeed);
+			const float newMaxSpeed = std::min(c.params[0], defMaxSpeed);
 			if (newMaxSpeed &gt; 0)
 				owner-&gt;moveType-&gt;SetMaxSpeed(newMaxSpeed);
 		}
@@ -733,7 +733,7 @@
 				// FIXME kill magic frame number
 				if (gs-&gt;frameNum &gt; lastCloseInTry + MAX_CLOSE_IN_RETRY_TICKS) {
 					owner-&gt;moveType-&gt;KeepPointingTo(orderTarget,
-							min((float) (owner-&gt;losRadius * SQUARE_SIZE * 2),
+							std::min((float) (owner-&gt;losRadius * SQUARE_SIZE * 2),
 									owner-&gt;maxRange * 0.9f), true);
 				}
 			}
@@ -748,7 +748,7 @@
 			{
 				StopMove();
 				owner-&gt;moveType-&gt;KeepPointingTo(orderTarget,
-						min((float) (owner-&gt;losRadius * SQUARE_SIZE * 2),
+						std::min((float) (owner-&gt;losRadius * SQUARE_SIZE * 2),
 								owner-&gt;maxRange * 0.9f), true);
 			} else if(tempOrder &amp;&amp; owner-&gt;moveState == 0){
 				SetGoal(lastUserGoal, owner-&gt;pos);

Modified: trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -344,7 +344,7 @@
 			return true;
 		}
 	} else {
-		for (float y = max(emptyRadius, center.z - radius); y &lt; min(float(gs-&gt;mapy * SQUARE_SIZE - emptyRadius), center.z + radius); y += SQUARE_SIZE) {
+		for (float y = std::max(emptyRadius, center.z - radius); y &lt; std::min(float(gs-&gt;mapy * SQUARE_SIZE - emptyRadius), center.z + radius); y += SQUARE_SIZE) {
 			float dy = y - center.z;
 			float rx = radius * radius - dy * dy;
 
@@ -353,7 +353,7 @@
 
 			rx = sqrt(rx);
 
-			for (float x = max(emptyRadius, center.x - rx); x &lt; min(float(gs-&gt;mapx * SQUARE_SIZE - emptyRadius), center.x + rx); x += SQUARE_SIZE) {
+			for (float x = std::max(emptyRadius, center.x - rx); x &lt; std::min(float(gs-&gt;mapx * SQUARE_SIZE - emptyRadius), center.x + rx); x += SQUARE_SIZE) {
 				float unloadPosHeight = ground-&gt;GetApproximateHeight(x, y);
 
 				if (unloadPosHeight &lt; (0 - unitToUnload-&gt;unitDef-&gt;maxWaterDepth))
@@ -396,7 +396,7 @@
 bool CTransportCAI::FindEmptyDropSpots(float3 startpos, float3 endpos, std::list&lt;float3&gt;&amp; dropSpots) {
 	//should only be used by air
 
-	CTransportUnit* transport=(CTransportUnit*)owner;
+	CTransportUnit* transport = (CTransportUnit*)owner;
 	//dropSpots.clear();
 	float gap = 25.5; //TODO - set tag for this?
 	float3 dir = endpos - startpos;
@@ -405,19 +405,16 @@
 	float3 nextPos = startpos;
 	float3 pos;
 
-	list&lt;CTransportUnit::TransportedUnit&gt;::iterator ti = transport-&gt;transported.begin();
+	std::list&lt;CTransportUnit::TransportedUnit&gt;::iterator ti = transport-&gt;transported.begin();
 	dropSpots.push_front(nextPos);
 
-	//first spot
+	// first spot
 	if (ti!=transport-&gt;transported.end()) {
-		//float3 p = nextPos; //test to make intended land spots visible
-		//inMapDrawer-&gt;CreatePoint(p,ti-&gt;unit-&gt;unitDef-&gt;name);
-		//p.z +=transport-&gt;transportCapacityUsed*5;
 		nextPos += dir*(gap + ti-&gt;unit-&gt;radius);
 		ti++;
 	}
 
-	//remaining spots
+	// remaining spots
 	if (dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType)) {
 		while (ti != transport-&gt;transported.end() &amp;&amp; startpos.distance(nextPos) &lt; startpos.distance(endpos)) {
 			nextPos += dir*(ti-&gt;unit-&gt;radius);
@@ -463,7 +460,7 @@
 	float spread = u-&gt;radius * ((CTransportUnit*) owner)-&gt;unitDef-&gt;unloadSpread;
 	float3 found;
 
-	bool canUnload = FindEmptySpot(pos, max(16.0f, radius), spread, found, u);
+	bool canUnload = FindEmptySpot(pos, std::max(16.0f, radius), spread, found, u);
 
 	if (canUnload) {
 		Command c2;
@@ -503,7 +500,7 @@
 
 			approachVector = startingDropPos-owner-&gt;pos;
 			approachVector.Normalize();
-			canUnload = FindEmptyDropSpots(pos, pos + approachVector*max(16.0f,radius), dropSpots);
+			canUnload = FindEmptyDropSpots(pos, pos + approachVector * std::max(16.0f,radius), dropSpots);
 
 		} else if (!dropSpots.empty() ) {
 			//make sure we check current spot infront of us each unload
@@ -553,7 +550,7 @@
 	float3 found;
 	//((CTransportUnit*)owner)-&gt;transported
 
-	bool canUnload=FindEmptySpot(pos,max(16.0f,radius),((CTransportUnit*)owner)-&gt;transported.front().unit-&gt;radius  * ((CTransportUnit*)owner)-&gt;unitDef-&gt;unloadSpread,
+	bool canUnload=FindEmptySpot(pos, std::max(16.0f,radius),((CTransportUnit*)owner)-&gt;transported.front().unit-&gt;radius  * ((CTransportUnit*)owner)-&gt;unitDef-&gt;unloadSpread,
 								found,((CTransportUnit*)owner)-&gt;transported.front().unit);
 	if(canUnload){
 
@@ -999,7 +996,7 @@
 			float radius = c.params[3];
 			float spread = u-&gt;radius * transport-&gt;unitDef-&gt;unloadSpread;
 			float3 found;
-			bool canUnload = FindEmptySpot(pos, max(16.0f, radius), spread, found, u);
+			bool canUnload = FindEmptySpot(pos, std::max(16.0f, radius), spread, found, u);
 			if(!canUnload) return false;
 			break;
 		}

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -874,7 +874,7 @@
 	if (paralyzeTime == 0) { // real damage
 		if (damage &gt; 0.0f) {
 			// Dont log overkill damage (so dguns/nukes etc dont inflate values)
-			const float statsdamage = max(0.0f, min(maxHealth - health, damage));
+			const float statsdamage = std::max(0.0f, std::min(maxHealth - health, damage));
 			if (attacker) {
 				gs-&gt;Team(attacker-&gt;team)-&gt;currentStats.damageDealt += statsdamage;
 			}
@@ -906,7 +906,7 @@
 				if (paralyzeDamage &gt; health) {
 					stunned = true;
 				}
-				paralyzeDamage = min(paralyzeDamage, maxParaDmg);
+				paralyzeDamage = std::min(paralyzeDamage, maxParaDmg);
 			}
 		}
 		else { // paralyzation healing
@@ -928,7 +928,7 @@
 		if ((attacker != NULL) &amp;&amp; !gs-&gt;Ally(allyteam, attacker-&gt;allyteam)) {
 			attacker-&gt;AddExperience(0.1f * experienceMod
 			                             * (power / attacker-&gt;power)
-			                             * (damage + min(0.0f, health)) / maxHealth);
+			                             * (damage + std::min(0.0f, health)) / maxHealth);
 			ENTER_UNSYNCED;
 			const int warnFrame = (gs-&gt;frameNum - 100);
 			if ((team == gu-&gt;myTeam)
@@ -1889,7 +1889,7 @@
 
 	const float3 diff = (pos - camera-&gt;pos);
 	const float dist = diff.dot(camera-&gt;forward);
-	const float lpp = max(0.0f, dist * lodFactor);
+	const float lpp = std::max(0.0f, dist * lodFactor);
 	for (/* no-op */; lastLOD != 0; lastLOD--) {
 		if (lpp &gt; lodLengths[lastLOD]) {
 			break;
@@ -1911,7 +1911,7 @@
 	const float3 diff = (camera-&gt;pos - pos);
 	const float  dot  = diff.dot(sun);
 	const float3 gap  = diff - (sun * dot);
-	const float  lpp  = max(0.0f, gap.Length() * lodFactor);
+	const float  lpp  = std::max(0.0f, gap.Length() * lodFactor);
 
 	for (/* no-op */; lastLOD != 0; lastLOD--) {
 		if (lpp &gt; lodLengths[lastLOD]) {
@@ -1948,7 +1948,7 @@
 
 	// TA does some special handling depending on weapon count
 	if (weapons.size() &gt; 1)
-		relMax = max(relMax, 3000);
+		relMax = std::max(relMax, 3000);
 
 	// Call initializing script functions
 	cob-&gt;Call(COBFN_Create);

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -478,7 +478,7 @@
 		string lname = StringToLower(ud.name);
 
 		if (gameSetup-&gt;restrictedUnits.find(lname) != gameSetup-&gt;restrictedUnits.end()) {
-			ud.maxThisUnit = min(ud.maxThisUnit, gameSetup-&gt;restrictedUnits.find(lname)-&gt;second);
+			ud.maxThisUnit = std::min(ud.maxThisUnit, gameSetup-&gt;restrictedUnits.find(lname)-&gt;second);
 		}
 	}
 
@@ -1031,7 +1031,7 @@
 	}
 
 	fprintf(f, &quot;\nTech Levels for \&quot;%s\&quot;\n&quot;, modname.c_str());
-	multimap&lt;int, string&gt; entries;
+	std::multimap&lt;int, std::string&gt; entries;
 	std::map&lt;std::string, int&gt;::const_iterator uit;
 	for (uit = unitID.begin(); uit != unitID.end(); uit++) {
 		const string&amp; unitName = uit-&gt;first;
@@ -1041,11 +1041,11 @@
 			SNPRINTF(buf, sizeof(buf), &quot; %3i:  %-15s  // %s :: %s\n&quot;,
 							 ud-&gt;techLevel, unitName.c_str(),
 							 ud-&gt;humanName.c_str(), ud-&gt;tooltip.c_str());
-			entries.insert(pair&lt;int, string&gt;(ud-&gt;techLevel, buf));
+			entries.insert(std::pair&lt;int, string&gt;(ud-&gt;techLevel, buf));
 		}
 	}
 	int prevLevel = -2;
-	multimap&lt;int, string&gt;::iterator eit;
+	std::multimap&lt;int, std::string&gt;::iterator eit;
 	for (eit = entries.begin(); eit != entries.end(); ++eit) {
 		if (eit-&gt;first != prevLevel) {
 			fprintf(f, &quot;\n&quot;);

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -136,7 +136,7 @@
 	unit-&gt;buildTime = ud-&gt;buildTime;
 	unit-&gt;aihint = ud-&gt;aihint;
 	unit-&gt;tooltip = ud-&gt;humanName + &quot; - &quot; + ud-&gt;tooltip;
-	unit-&gt;armoredMultiple = max(0.0001f, ud-&gt;armoredMultiple);		//armored multiple of 0 will crash spring
+	unit-&gt;armoredMultiple = std::max(0.0001f, ud-&gt;armoredMultiple);		//armored multiple of 0 will crash spring
 	unit-&gt;wreckName = ud-&gt;wreckName;
 
 	unit-&gt;realLosRadius = (int) (ud-&gt;losRadius);
@@ -324,7 +324,7 @@
 
 
 	if (ud-&gt;floater)
-		unit-&gt;pos.y = max(-ud-&gt;waterline, ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z));
+		unit-&gt;pos.y = std::max(-ud-&gt;waterline, ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z));
 	else
 		unit-&gt;pos.y = ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z);
 
@@ -347,7 +347,7 @@
 
 	// TA does some special handling depending on weapon count
 	if (unit-&gt;weapons.size() &gt; 1)
-		relMax = max(relMax, 3000);
+		relMax = std::max(relMax, 3000);
 
 	// Call initializing script functions
 	unit-&gt;cob-&gt;Call(COBFN_Create);
@@ -501,10 +501,10 @@
 		BuildInfo bi(unitDef, unit-&gt;pos, unit-&gt;buildFacing);
 		bi.pos = helper-&gt;Pos2BuildPos(bi);
 		const float hss = 0.5f * SQUARE_SIZE;
-		const int tx1 = (int)max(0.0f ,(bi.pos.x - (bi.GetXSize() * hss)) / SQUARE_SIZE);
-		const int tz1 = (int)max(0.0f ,(bi.pos.z - (bi.GetYSize() * hss)) / SQUARE_SIZE);
-		const int tx2 = min(gs-&gt;mapx, tx1 + bi.GetXSize());
-		const int tz2 = min(gs-&gt;mapy, tz1 + bi.GetYSize());
+		const int tx1 = (int) std::max(0.0f ,(bi.pos.x - (bi.GetXSize() * hss)) / SQUARE_SIZE);
+		const int tz1 = (int) std::max(0.0f ,(bi.pos.z - (bi.GetYSize() * hss)) / SQUARE_SIZE);
+		const int tx2 = std::min(gs-&gt;mapx, tx1 + bi.GetXSize());
+		const int tz2 = std::min(gs-&gt;mapy, tz1 + bi.GetYSize());
 		float* heightmap = readmap-&gt;GetHeightmap();
 		for(int z = tz1; z &lt;= tz2; z++){
 			for(int x = tx1; x &lt;= tx2; x++){

Modified: trunk/rts/Sim/Units/UnitLoader.h
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitLoader.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -10,7 +10,6 @@
 
 #include &quot;UnitDef.h&quot;
 
-using namespace std;
 struct GuiSoundSet;
 
 class CUnitLoader
@@ -19,8 +18,8 @@
 	CUnitLoader();
 	virtual ~CUnitLoader();
 
-	CUnit* LoadUnit(const string&amp; name,float3 pos, int team,
-	                bool build, int facing, const CUnit* builder /* can be NULL */);
+	CUnit* LoadUnit(const std::string&amp; name, float3 pos, int team,
+		bool build, int facing, const CUnit* builder /* can be NULL */);
 	void FlattenGround(const CUnit* unit);
 
 	CWeapon* LoadWeapon(const WeaponDef* weapondef, CUnit* owner, const UnitDef::UnitDefWeapon* udw);

Modified: trunk/rts/Sim/Units/UnitTracker.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTracker.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitTracker.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -128,14 +128,14 @@
 
 void CUnitTracker::CleanTrackGroup()
 {
-	set&lt;int&gt;::iterator it = trackGroup.begin();
+	std::set&lt;int&gt;::iterator it = trackGroup.begin();
 
 	while (it != trackGroup.end()) {
 		if (uh-&gt;units[*it] != NULL) {
 			it++;
 			continue;
 		}
-		set&lt;int&gt;::iterator it_next = it;
+		std::set&lt;int&gt;::iterator it_next = it;
 		it_next++;
 		if (trackUnit == *it) {
 			if (it_next == trackGroup.end()) {
@@ -163,7 +163,7 @@
 		return;
 	}
 
-	set&lt;int&gt;::iterator it = trackGroup.find(trackUnit);
+	std::set&lt;int&gt;::iterator it = trackGroup.find(trackUnit);
 	if (it == trackGroup.end()) {
 		trackUnit = *trackGroup.begin();
 	}
@@ -195,7 +195,7 @@
 float3 CUnitTracker::CalcAveragePos() const
 {
 	float3 p(0,0,0);
-	set&lt;int&gt;::const_iterator it;
+	std::set&lt;int&gt;::const_iterator it;
 	for (it = trackGroup.begin(); it != trackGroup.end(); ++it) {
 		p += uh-&gt;units[*it]-&gt;midPos;
 	}
@@ -208,7 +208,7 @@
 {
 	float3 minPos(+1e9f, +1e9f, +1e9f);
 	float3 maxPos(-1e9f, -1e9f, -1e9f);
-	set&lt;int&gt;::const_iterator it;
+	std::set&lt;int&gt;::const_iterator it;
 	for (it = trackGroup.begin(); it != trackGroup.end(); ++it) {
 		const float3&amp; p = uh-&gt;units[*it]-&gt;midPos;
 		if (p.x &lt; minPos.x) { minPos.x = p.x; }

Modified: trunk/rts/Sim/Units/UnitTracker.h
===================================================================
--- trunk/rts/Sim/Units/UnitTracker.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitTracker.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -4,8 +4,6 @@
 #include &lt;set&gt;
 #include &quot;float.h&quot;
 
-using namespace std;
-
 class CUnit;
 
 class CUnitTracker
@@ -45,7 +43,7 @@
 
 		int trackMode;
 		int trackUnit;
-		set&lt;int&gt; trackGroup;
+		std::set&lt;int&gt; trackGroup;
 		
 		int timeOut;
 		int lastFollowUnit;

Modified: trunk/rts/Sim/Units/UnitTypes/Builder.h
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Builder.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitTypes/Builder.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -9,7 +9,6 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 
-using namespace std;
 class CFeature;
 
 class CBuilder : public CUnit
@@ -81,7 +80,7 @@
 	float3 terraformCenter;
 	float terraformRadius;
 
-	string nextBuildType;
+	std::string nextBuildType;
 	float3 nextBuildPos;
 };
 

Modified: trunk/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -102,9 +102,9 @@
 
 	//Finding neighbours
 	std::vector&lt;CUnit*&gt; cu = qf-&gt;GetUnits(pos, extractionRange + maxExtractionRange);
-	maxExtractionRange = max(extractionRange, maxExtractionRange);
+	maxExtractionRange = std::max(extractionRange, maxExtractionRange);
 
-	for(std::vector&lt;CUnit*&gt;::iterator ui = cu.begin(); ui != cu.end(); ++ui) {
+	for (std::vector&lt;CUnit*&gt;::iterator ui = cu.begin(); ui != cu.end(); ++ui) {
 		if(typeid(**ui) == typeid(CExtractorBuilding) &amp;&amp; *ui != this) {
 			CExtractorBuilding *eb = (CExtractorBuilding*)*ui;
 			if(eb-&gt;pos.distance2D(this-&gt;pos) &lt; (eb-&gt;extractionRange + this-&gt;extractionRange)) {
@@ -119,12 +119,14 @@
 	//Calculating area of control and metalExtract.
 	//TODO: Improve this method.
 	metalExtract = 0;
-	int xBegin = max(0,           (int)((pos.x - extractionRange) / METAL_MAP_SQUARE_SIZE));
-	int xEnd   = min(gs-&gt;mapx/2-1,(int)((pos.x + extractionRange) / METAL_MAP_SQUARE_SIZE));
-	int zBegin = max(0,           (int)((pos.z - extractionRange) / METAL_MAP_SQUARE_SIZE));
-	int zEnd   = min(gs-&gt;mapy/2-1,(int)((pos.z + extractionRange) / METAL_MAP_SQUARE_SIZE));
-	for(int x = xBegin; x &lt;= xEnd; x++) {
-		for(int z = zBegin; z &lt;= zEnd; z++) {	//Going thru the whole (x,z)-square...
+	int xBegin = std::max(0,           (int)((pos.x - extractionRange) / METAL_MAP_SQUARE_SIZE));
+	int xEnd   = std::min(gs-&gt;mapx/2-1,(int)((pos.x + extractionRange) / METAL_MAP_SQUARE_SIZE));
+	int zBegin = std::max(0,           (int)((pos.z - extractionRange) / METAL_MAP_SQUARE_SIZE));
+	int zEnd   = std::min(gs-&gt;mapy/2-1,(int)((pos.z + extractionRange) / METAL_MAP_SQUARE_SIZE));
+
+	for (int x = xBegin; x &lt;= xEnd; x++) {
+		for (int z = zBegin; z &lt;= zEnd; z++) {
+			// go through the whole (x, z)-square
 			const float3 msqrPos((x + 0.5f) * METAL_MAP_SQUARE_SIZE, pos.y,
 			                     (z + 0.5f) * METAL_MAP_SQUARE_SIZE);	//Center of metalsquare.
 			const float sqrCenterDistance = msqrPos.distance2D(this-&gt;pos);

Modified: trunk/rts/Sim/Units/UnitTypes/Factory.h
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Factory.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitTypes/Factory.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -8,8 +8,6 @@
 #include &quot;Building.h&quot;
 #include &lt;string&gt;
 
-using namespace std;
-
 class CFactory : public CBuilding
 {
 public:
@@ -19,7 +17,7 @@
 	virtual ~CFactory();
 	void PostLoad();
 	void StopBuild();
-	void StartBuild(string type);
+	void StartBuild(std::string type);
 	void Update();
 	void DependentDied(CObject* o);
 	void FinishedBuilding(void);
@@ -33,7 +31,7 @@
 	float buildSpeed;
 
 	bool quedBuild;						//if we have a unit that we want to start to nanolath when script is ready
-	string nextBuild;
+	std::string nextBuild;
 	CUnit* curBuild;					//unit that we are nanolathing
 	bool opening;
 

Modified: trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -52,11 +52,11 @@
 void CTransportUnit::Update()
 {
 	CUnit::Update();
-	list&lt;TransportedUnit&gt;::iterator ti;
+	std::list&lt;TransportedUnit&gt;::iterator ti;
 	for (ti = transported.begin(); ti != transported.end(); ++ti) {
 		float3 relPos;
 		if (ti-&gt;piece &gt;= 0) {
-			relPos = localmodel-&gt;GetPiecePos(max(0, ti-&gt;piece));
+			relPos = localmodel-&gt;GetPiecePos(std::max(0, ti-&gt;piece));
 		} else {
 			relPos = float3(0.0f, -1000.0f, 0.0f);
 		}
@@ -80,8 +80,8 @@
 
 void CTransportUnit::DependentDied(CObject* o)
 {
-	for(list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
-		if(ti-&gt;unit==o){
+	for (std::list&lt;TransportedUnit&gt;::iterator ti = transported.begin(); ti != transported.end(); ++ti) {
+		if (ti-&gt;unit == o) {
 			transportCapacityUsed-=ti-&gt;size;
 			transportMassUsed-=ti-&gt;mass;
 			transported.erase(ti);
@@ -95,7 +95,7 @@
 
 void CTransportUnit::KillUnit(bool selfDestruct,bool reclaimed, CUnit *attacker)
 {
-	list&lt;TransportedUnit&gt;::iterator ti;
+	std::list&lt;TransportedUnit&gt;::iterator ti;
 	for (ti = transported.begin(); ti != transported.end(); ++ti) {
 		ti-&gt;unit-&gt;transporter = 0;
 		ti-&gt;unit-&gt;DeleteDeathDependence(this);
@@ -184,7 +184,7 @@
 		return;
 	}
 
-	list&lt;TransportedUnit&gt;::iterator ti;
+	std::list&lt;TransportedUnit&gt;::iterator ti;
 	for (ti = transported.begin(); ti != transported.end(); ++ti) {
 		if (ti-&gt;unit == unit) {
 			this-&gt;DeleteDeathDependence(unit);
@@ -219,10 +219,10 @@
 
 void CTransportUnit::DetachUnitFromAir(CUnit* unit, float3 pos) {
 
-	if(unit-&gt;transporter != this)
+	if (unit-&gt;transporter != this)
 		return;
 
-	for (list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
+	for (std::list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
 		if (ti-&gt;unit==unit) {
 			this-&gt;DeleteDeathDependence(unit);
 			unit-&gt;DeleteDeathDependence(this);
@@ -259,11 +259,11 @@
 
 void CTransportUnit::DetachUnitFromAir(CUnit* unit)
 {
-	if(unit-&gt;transporter != this)
+	if (unit-&gt;transporter != this)
 		return;
 
-	for(list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
-		if(ti-&gt;unit==unit){
+	for (std::list&lt;TransportedUnit&gt;::iterator ti=transported.begin();ti!=transported.end();++ti){
+		if (ti-&gt;unit == unit) {
 			this-&gt;DeleteDeathDependence(unit);
 			unit-&gt;DeleteDeathDependence(this);
 			unit-&gt;transporter=0;

Modified: trunk/rts/Sim/Weapons/BeamLaser.cpp
===================================================================
--- trunk/rts/Sim/Weapons/BeamLaser.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Weapons/BeamLaser.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -256,7 +256,7 @@
 		actualRange += hit-&gt;radius*targetBorder;
 	}
 	// make it possible to always hit with some minimal intensity (melee weapons have use for that)
-	float intensity=max(minIntensity, 1-(curLength)/(actualRange*2));
+	float intensity = std::max(minIntensity, 1-(curLength)/(actualRange*2));
 
 	if(curLength&lt;maxLength) {
 		// Dynamic Damage

Modified: trunk/rts/Sim/Weapons/PlasmaRepulser.cpp
===================================================================
--- trunk/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -125,11 +125,11 @@
 		if (weaponDef-&gt;visibleShield) {
 			drawAlpha += 1.0f;
 		}
-		drawAlpha = min(1.0f, drawAlpha * weaponDef-&gt;shieldAlpha);
+		drawAlpha = std::min(1.0f, drawAlpha * weaponDef-&gt;shieldAlpha);
 		const bool drawMe = (drawAlpha &gt; 0.0f);
 
 		if (drawMe || wasDrawn) {
-			const float colorMix = min(1.0f, curPower / max(1.0f, weaponDef-&gt;shieldPower));
+			const float colorMix = std::min(1.0f, curPower / std::max(1.0f, weaponDef-&gt;shieldPower));
 			const float3 color = (weaponDef-&gt;shieldGoodColor * colorMix) +
 													 (weaponDef-&gt;shieldBadColor * (1.0f - colorMix));
 			std::list&lt;CShieldPartProjectile*&gt;::iterator si;
@@ -182,7 +182,7 @@
 								}
 							if (i == hasGfx.end()) {
 								hasGfx.insert(hasGfx.end(),*pi);
-								const float colorMix = min(1.0f, curPower / max(1.0f, weaponDef-&gt;shieldPower));
+								const float colorMix = std::min(1.0f, curPower / std::max(1.0f, weaponDef-&gt;shieldPower));
 								const float3 color = (weaponDef-&gt;shieldGoodColor * colorMix) +
 								                     (weaponDef-&gt;shieldBadColor * (1.0f - colorMix));
 								SAFE_NEW CRepulseGfx(owner, *pi, radius, color);

Modified: trunk/rts/Sim/Weapons/Weapon.cpp
===================================================================
--- trunk/rts/Sim/Weapons/Weapon.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/Sim/Weapons/Weapon.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -358,7 +358,7 @@
 				} else {
 					owner-&gt;UseEnergy(energyFireCost);
 					owner-&gt;UseMetal(metalFireCost);
-					owner-&gt;currentFuel = max(0.0f, owner-&gt;currentFuel - fuelUsage);
+					owner-&gt;currentFuel = std::max(0.0f, owner-&gt;currentFuel - fuelUsage);
 				}
 				if(weaponDef-&gt;stockpile)
 					reloadStatus=gs-&gt;frameNum+60;
@@ -379,7 +379,7 @@
 			// FIXME  -- never reached?
 			if (TryTarget(targetPos,haveUserTarget,targetUnit) &amp;&amp; !weaponDef-&gt;stockpile) {
 				// update the energy and metal required counts
-				const int minPeriod = max(1, (int)(reloadTime / owner-&gt;reloadSpeed));
+				const int minPeriod = std::max(1, (int)(reloadTime / owner-&gt;reloadSpeed));
 				const float averageFactor = 1.0f / (float)minPeriod;
 				gs-&gt;Team(owner-&gt;team)-&gt;energyPull += averageFactor * energyFireCost;
 				gs-&gt;Team(owner-&gt;team)-&gt;metalPull += averageFactor * metalFireCost;
@@ -846,7 +846,7 @@
 		owner-&gt;maxRange = range;
 	}
 
-	muzzleFlareSize = min(areaOfEffect*0.2f,min(1500.f,weaponDef-&gt;damages[0])*0.003f);
+	muzzleFlareSize = std::min(areaOfEffect * 0.2f, std::min(1500.f, weaponDef-&gt;damages[0]) * 0.003f);
 
 	if (weaponDef-&gt;interceptor)
 		interceptHandler.AddInterceptorWeapon(this);

Modified: trunk/rts/System/FileSystem/Archive7Zip.cpp
===================================================================
--- trunk/rts/System/FileSystem/Archive7Zip.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/Archive7Zip.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -24,7 +24,7 @@
 	return SZE_FAIL;
 }
 
-CArchive7Zip::CArchive7Zip(const string&amp; name) :
+CArchive7Zip::CArchive7Zip(const std::string&amp; name):
 	CArchiveBuffered(name),
 	curSearchHandle(1),
 	isOpen(false)
@@ -56,7 +56,7 @@
 	for (unsigned i = 0; i &lt; db.Database.NumFiles; ++i) {
 		CFileItem* fi = db.Database.Files + i;
 		if (fi-&gt;Size &gt; 0) {
-			string name = fi-&gt;Name;
+			std::string name = fi-&gt;Name;
 			//SetSlashesForwardToBack(name);
 
 			FileData fd;
@@ -79,20 +79,20 @@
 	}
 }
 
-unsigned int CArchive7Zip::GetCrc32 (const string&amp; fileName)
+unsigned int CArchive7Zip::GetCrc32 (const std::string&amp; fileName)
 {
-	string lower = StringToLower(fileName);
+	std::string lower = StringToLower(fileName);
 	FileData fd = fileData[lower];
 	return fd.crc;
 }
 
-ABOpenFile_t* CArchive7Zip::GetEntireFile(const string&amp; fName)
+ABOpenFile_t* CArchive7Zip::GetEntireFile(const std::string&amp; fName)
 {
 	if (!isOpen)
 		return NULL;
 
 	// Figure out the file index
-	string fileName = StringToLower(fName);
+	std::string fileName = StringToLower(fName);
 	
 	if (fileData.find(fileName) == fileData.end())
 		return NULL;
@@ -133,7 +133,7 @@
 	return of;
 }
 
-void CArchive7Zip::SetSlashesForwardToBack(string&amp; name)
+void CArchive7Zip::SetSlashesForwardToBack(std::string&amp; name)
 {
 	for (unsigned int i = 0; i &lt; name.length(); ++i) {
 		if (name[i] == '/')
@@ -141,7 +141,7 @@
 	}
 }
 
-int CArchive7Zip::FindFiles(int cur, string* name, int* size)
+int CArchive7Zip::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {
 		curSearchHandle++;

Modified: trunk/rts/System/FileSystem/Archive7Zip.h
===================================================================
--- trunk/rts/System/FileSystem/Archive7Zip.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/Archive7Zip.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -22,13 +22,13 @@
 	struct FileData {
 		int fp;
 		int size;
-		string origName;
+		std::string origName;
 		unsigned int crc;
 	};
-	map&lt;string, FileData&gt; fileData;
+	std::map&lt;std::string, FileData&gt; fileData;
 
 	int curSearchHandle;
-	map&lt;int, map&lt;string, FileData&gt;::iterator&gt; searchHandles;
+	std::map&lt;int, std::map&lt;std::string, FileData&gt;::iterator&gt; searchHandles;
 
 	CFileInStream archiveStream;
 	CArchiveDatabaseEx db;
@@ -36,14 +36,14 @@
 	ISzAlloc allocTempImp;
 
 	bool isOpen;
-	virtual ABOpenFile_t* GetEntireFile(const string&amp; fName);
-	void SetSlashesForwardToBack(string&amp; name);
+	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fName);
+	void SetSlashesForwardToBack(std::string&amp; name);
 public:
-	CArchive7Zip(const string&amp; name);
+	CArchive7Zip(const std::string&amp; name);
 	virtual ~CArchive7Zip(void);
 	virtual bool IsOpen();
-	virtual int FindFiles(int cur, string* name, int* size);
-	virtual unsigned int GetCrc32 (const string&amp; fileName);
+	virtual int FindFiles(int cur, std::string* name, int* size);
+	virtual unsigned int GetCrc32 (const std::string&amp; fileName);
 };
 
 #endif

Modified: trunk/rts/System/FileSystem/ArchiveBase.cpp
===================================================================
--- trunk/rts/System/FileSystem/ArchiveBase.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveBase.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -4,7 +4,7 @@
 #include &quot;lib/7zip/7zCrc.h&quot;
 };
 
-unsigned int CArchiveBase::GetCrc32 (const string&amp; fileName)
+unsigned int CArchiveBase::GetCrc32(const std::string&amp; fileName)
 {
 	UInt32 crc;
 	unsigned char buffer [65536];
@@ -16,7 +16,7 @@
 
 	while (!this-&gt;Eof(handle)) {
 		int maxRead = this-&gt;ReadFile(handle, &amp;buffer, sizeof(buffer));
-		CrcUpdate (&amp;crc, buffer, maxRead);
+		CrcUpdate(&amp;crc, buffer, maxRead);
 	}
 
 	this-&gt;CloseFile(handle);

Modified: trunk/rts/System/FileSystem/ArchiveBase.h
===================================================================
--- trunk/rts/System/FileSystem/ArchiveBase.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveBase.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -5,23 +5,21 @@
 
 #include &lt;string&gt;
 
-using namespace std;
-
 class CArchiveBase
 {
 public:
-	CArchiveBase(const string&amp; archiveName) {};
+	CArchiveBase(const std::string&amp; archiveName) {};
 	virtual ~CArchiveBase();
 	virtual bool IsOpen() = 0;
-	virtual int OpenFile(const string&amp; fileName) = 0;
+	virtual int OpenFile(const std::string&amp; fileName) = 0;
 	virtual int ReadFile(int handle, void* buffer, int numBytes) = 0;
 	virtual void CloseFile(int handle) = 0;
 	virtual void Seek(int handle, int pos) = 0;
 	virtual int Peek(int handle) = 0;
 	virtual bool Eof(int handle) = 0;
 	virtual int FileSize(int handle) = 0;
-	virtual int FindFiles(int cur, string* name, int* size) = 0;
-	virtual unsigned int GetCrc32 (const string&amp; fileName);
+	virtual int FindFiles(int cur, std::string* name, int* size) = 0;
+	virtual unsigned int GetCrc32 (const std::string&amp; fileName);
 };
 
 #endif

Modified: trunk/rts/System/FileSystem/ArchiveBuffered.cpp
===================================================================
--- trunk/rts/System/FileSystem/ArchiveBuffered.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveBuffered.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -3,7 +3,7 @@
 #include &quot;ArchiveBuffered.h&quot;
 #include &quot;mmgr.h&quot;
 
-CArchiveBuffered::CArchiveBuffered(const string&amp; name) :
+CArchiveBuffered::CArchiveBuffered(const std::string&amp; name):
 	CArchiveBase(name),
 	curFileHandle(1)
 {
@@ -11,13 +11,13 @@
 
 CArchiveBuffered::~CArchiveBuffered(void)
 {
-	for (map&lt;int, ABOpenFile_t*&gt;::iterator i = fileHandles.begin(); i != fileHandles.end(); ++i) {
+	for (std::map&lt;int, ABOpenFile_t*&gt;::iterator i = fileHandles.begin(); i != fileHandles.end(); ++i) {
 		free((i-&gt;second)-&gt;data);
 		delete i-&gt;second;
 	}
 }
 
-int CArchiveBuffered::OpenFile(const string&amp; fileName)
+int CArchiveBuffered::OpenFile(const std::string&amp; fileName)
 {
 	ABOpenFile_t* fh = GetEntireFile(fileName);
 	if (!fh)
@@ -33,7 +33,7 @@
 {
 	ABOpenFile_t* of = fileHandles[handle];
 
-	int maxRead = min(numBytes, of-&gt;size - of-&gt;pos);
+	int maxRead = std::min(numBytes, of-&gt;size - of-&gt;pos);
 	memcpy(buffer, of-&gt;data + of-&gt;pos, maxRead);
 	of-&gt;pos += maxRead;
 
@@ -50,7 +50,7 @@
 void CArchiveBuffered::Seek(int handle, int pos)
 {
 	ABOpenFile_t* of = fileHandles[handle];
-	of-&gt;pos = min(pos, of-&gt;size);
+	of-&gt;pos = std::min(pos, of-&gt;size);
 }
 
 int CArchiveBuffered::Peek(int handle)

Modified: trunk/rts/System/FileSystem/ArchiveBuffered.h
===================================================================
--- trunk/rts/System/FileSystem/ArchiveBuffered.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveBuffered.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -17,12 +17,12 @@
 {
 protected:
 	int curFileHandle;
-	map&lt;int, ABOpenFile_t*&gt; fileHandles;
-	virtual ABOpenFile_t* GetEntireFile(const string&amp; fileName) = 0;
+	std::map&lt;int, ABOpenFile_t*&gt; fileHandles;
+	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fileName) = 0;
 public:
-	CArchiveBuffered(const string&amp; name);
+	CArchiveBuffered(const std::string&amp; name);
 	virtual ~CArchiveBuffered(void);
-	virtual int OpenFile(const string&amp; fileName);
+	virtual int OpenFile(const std::string&amp; fileName);
 	virtual int ReadFile(int handle, void* buffer, int numBytes);
 	virtual void CloseFile(int handle);
 	virtual void Seek(int handle, int pos);

Modified: trunk/rts/System/FileSystem/ArchiveDir.cpp
===================================================================
--- trunk/rts/System/FileSystem/ArchiveDir.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveDir.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -18,7 +18,7 @@
 	return it-&gt;second;
 }
 
-CArchiveDir::CArchiveDir(const string&amp; archivename) :
+CArchiveDir::CArchiveDir(const std::string&amp; archivename) :
 		CArchiveBase(archivename),
 		archiveName(archivename + '/'),
 		curFileHandle(0),
@@ -92,7 +92,7 @@
 	return GetFileHandler(handle)-&gt;FileSize();
 }
 
-int CArchiveDir::FindFiles(int cur, string* name, int* size)
+int CArchiveDir::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {
 		cur = ++curSearchHandle;

Modified: trunk/rts/System/FileSystem/ArchiveDir.h
===================================================================
--- trunk/rts/System/FileSystem/ArchiveDir.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveDir.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -27,17 +27,17 @@
 
 public:
 
-	CArchiveDir(const string&amp; archiveName);
+	CArchiveDir(const std::string&amp; archiveName);
 	virtual ~CArchiveDir(void);
 	virtual bool IsOpen();
-	virtual int OpenFile(const string&amp; fileName);
+	virtual int OpenFile(const std::string&amp; fileName);
 	virtual int ReadFile(int handle, void* buffer, int numBytes);
 	virtual void CloseFile(int handle);
 	virtual void Seek(int handle, int pos);
 	virtual int Peek(int handle);
 	virtual bool Eof(int handle);
 	virtual int FileSize(int handle);
-	virtual int FindFiles(int cur, string* name, int* size);
+	virtual int FindFiles(int cur, std::string* name, int* size);
 };
 
 #endif

Modified: trunk/rts/System/FileSystem/ArchiveHPI.cpp
===================================================================
--- trunk/rts/System/FileSystem/ArchiveHPI.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveHPI.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -5,7 +5,7 @@
 
 using namespace hpiutil;
 
-CArchiveHPI::CArchiveHPI(const string&amp; name) :
+CArchiveHPI::CArchiveHPI(const std::string&amp; name):
 	CArchiveBuffered(name),
 	curSearchHandle(1)
 {
@@ -16,7 +16,7 @@
 	std::vector&lt;hpientry_ptr&gt; ret = HPIGetFiles(*hpi);
 	for (std::vector&lt;hpientry_ptr&gt;::iterator it = ret.begin(); it != ret.end(); it++) {
 		if (!(*it)-&gt;directory) {
-			string name = StringToLower((*it)-&gt;path());
+			std::string name = StringToLower((*it)-&gt;path());
 			fileSizes[name] = (*it)-&gt;size;
 		}
 	}
@@ -33,9 +33,9 @@
 	return (hpi != NULL);
 }
 
-ABOpenFile_t* CArchiveHPI::GetEntireFile(const string&amp; fileName)
+ABOpenFile_t* CArchiveHPI::GetEntireFile(const std::string&amp; fileName)
 {
-	string name = StringToLower(fileName);
+	std::string name = StringToLower(fileName);
 
 	hpientry_ptr f = HPIOpenFile(*hpi, (const char*)name.c_str());
 	if (!f.get())
@@ -57,7 +57,7 @@
 	return of;
 }
 
-int CArchiveHPI::FindFiles(int cur, string* name, int* size)
+int CArchiveHPI::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {
 		curSearchHandle++;

Modified: trunk/rts/System/FileSystem/ArchiveHPI.h
===================================================================
--- trunk/rts/System/FileSystem/ArchiveHPI.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveHPI.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -11,14 +11,15 @@
 protected:
 	hpiutil::hpifile *hpi;
 	int curSearchHandle;
-	map&lt;string, int&gt; fileSizes;			// hpiutil doesn't provide a way to determine this for a given file
-	map&lt;int, map&lt;string, int&gt;::iterator&gt; searchHandles;
-	virtual ABOpenFile_t* GetEntireFile(const string&amp; fileName);
+	// hpiutil doesn't provide a way to determine this for a given file
+	std::map&lt;std::string, int&gt; fileSizes;
+	std::map&lt;int, std::map&lt;std::string, int&gt;::iterator&gt; searchHandles;
+	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fileName);
 public:
-	CArchiveHPI(const string&amp; name);
+	CArchiveHPI(const std::string&amp; name);
 	virtual ~CArchiveHPI(void);
 	virtual bool IsOpen();
-	virtual int FindFiles(int cur, string* name, int* size);
+	virtual int FindFiles(int cur, std::string* name, int* size);
 };
 
 #endif

Modified: trunk/rts/System/FileSystem/ArchiveScanner.cpp
===================================================================
--- trunk/rts/System/FileSystem/ArchiveScanner.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveScanner.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -50,10 +50,10 @@
 {
 	char buf[32];
 	sprintf(buf, &quot;ArchiveCacheV%i.txt&quot;, INTERNAL_VER);
-	return string(buf);
+	return std::string(buf);
 }
 
-CArchiveScanner::ModData CArchiveScanner::GetModData(TdfParser* p, const string&amp; section)
+CArchiveScanner::ModData CArchiveScanner::GetModData(TdfParser* p, const std::string&amp; section)
 {
 	ModData md;
 	md.name = &quot;&quot;;
@@ -95,14 +95,14 @@
 	// so make sure it doesn't keep adding stuff to the name everytime
 	// Spring/unitsync is loaded.
 
-	if (md.name.find(md.version) == string::npos) {
+	if (md.name.find(md.version) == std::string::npos) {
 		md.name += &quot; &quot; + md.version;
 	}
 
 	return md;
 }
 
-void CArchiveScanner::Scan(const string&amp; curPath, bool checksum)
+void CArchiveScanner::Scan(const std::string&amp; curPath, bool checksum)
 {
 	InitCrcTable();
 	isDirty = true;
@@ -111,7 +111,7 @@
 	std::vector&lt;std::string&gt; found = filesystem.FindFiles(curPath, &quot;*&quot;, flags);
 
 	for (std::vector&lt;std::string&gt;::iterator it = found.begin(); it != found.end(); ++it) {
-		string fullName = *it;
+		std::string fullName = *it;
 
 		// Strip
 		const char lastFullChar = fullName[fullName.size() - 1];
@@ -119,19 +119,19 @@
 			fullName = fullName.substr(0, fullName.size() - 1);
 		}
 
-		const string fn    = filesystem.GetFilename(fullName);
-		const string fpath = filesystem.GetDirectory(fullName);
-		const string lcfn    = StringToLower(fn);
-		const string lcfpath = StringToLower(fpath);
+		const std::string fn    = filesystem.GetFilename(fullName);
+		const std::string fpath = filesystem.GetDirectory(fullName);
+		const std::string lcfn    = StringToLower(fn);
+		const std::string lcfpath = StringToLower(fpath);
 
 		// Exclude archivefiles found inside directory archives (.sdd)
-		if (lcfpath.find(&quot;.sdd&quot;) != string::npos) {
+		if (lcfpath.find(&quot;.sdd&quot;) != std::string::npos) {
 			continue;
 		}
 
 		// Exclude archivefiles found inside hidden directories
-		if ((lcfpath.find(&quot;/hidden/&quot;)   != string::npos) ||
-		    (lcfpath.find(&quot;\\hidden\\&quot;) != string::npos)) {
+		if ((lcfpath.find(&quot;/hidden/&quot;)   != std::string::npos) ||
+		    (lcfpath.find(&quot;\\hidden\\&quot;) != std::string::npos)) {
 			continue;
 		}
 
@@ -144,7 +144,7 @@
 			// Determine whether to rely on the cached info or not
 			bool cached = false;
 
-			map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcfn);
+			std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcfn);
 			if (aii != archiveInfo.end()) {
 
 				// This archive may have been obsoleted, do not process it if so
@@ -193,7 +193,7 @@
 				CArchiveBase* ar = CArchiveFactory::OpenArchive(fullName);
 				if (ar) {
 					int cur;
-					string name;
+					std::string name;
 					int size;
 					ArchiveInfo ai;
 
@@ -201,17 +201,17 @@
 					while (cur != 0) {
 						//printf(&quot;found %s %d\n&quot;, name.c_str(), size);
 
-						string ext = StringToLower(name.substr(name.find_last_of('.') + 1));
+						std::string ext = StringToLower(name.substr(name.find_last_of('.') + 1));
 
 						// only accept new format maps
 						if (ext == &quot;smf&quot; || ext == &quot;sm3&quot;) {
 							MapData md;
-							if (name.find_last_of('\\') == string::npos &amp;&amp; name.find_last_of('/') == string::npos) {
+							if (name.find_last_of('\\') == std::string::npos &amp;&amp; name.find_last_of('/') == std::string::npos) {
 								md.name = name;
 								md.virtualPath = &quot;/&quot;;
 							}
 							else {
-								if (name.find_last_of('\\') == string::npos) {
+								if (name.find_last_of('\\') == std::string::npos) {
 									md.name = name.substr(name.find_last_of('/') + 1);
 									md.virtualPath = name.substr(0, name.find_last_of('/') + 1);	// include the backslash
 								} else {
@@ -275,13 +275,12 @@
 	}
 
 	// Now we'll have to parse the replaces-stuff found in the mods
-	for (map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (vector&lt;string&gt;::iterator i = aii-&gt;second.modData.replaces.begin(); i != aii-&gt;second.modData.replaces.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (std::vector&lt;std::string&gt;::iterator i = aii-&gt;second.modData.replaces.begin(); i != aii-&gt;second.modData.replaces.end(); ++i) {
 
-			string lcname = StringToLower(*i);
+			std::string lcname = StringToLower(*i);
+			std::map&lt;std::string, ArchiveInfo&gt;::iterator ar = archiveInfo.find(lcname);
 
-			map&lt;string, ArchiveInfo&gt;::iterator ar = archiveInfo.find(lcname);
-
 			// If it's not there, we will create a new entry
 			if (ar == archiveInfo.end()) {
 				ArchiveInfo tmp;
@@ -304,14 +303,14 @@
 
 /** Get CRC of the data in the specified file. Returns 0 if file could not be opened. */
 
-unsigned int CArchiveScanner::GetCRC(const string&amp; filename)
+unsigned int CArchiveScanner::GetCRC(const std::string&amp; filename)
 {
 	UInt32 crc;
 	UInt32 digest = 0;
 	CArchiveBase* ar;
-	list&lt;string&gt; files;
-	string innerName;
-	string lowerName;
+	std::list&lt;std::string&gt; files;
+	std::string innerName;
+	std::string lowerName;
 	int innerSize;
 	int cur = 0;
 
@@ -332,7 +331,7 @@
 	files.sort();
 
 	// Add all files in sorted order
-	for (list&lt;string&gt;::iterator i = files.begin(); i != files.end(); i++ ) {
+	for (std::list&lt;std::string&gt;::iterator i = files.begin(); i != files.end(); i++ ) {
 		digest = CrcCalculateDigest(i-&gt;data(), i-&gt;size());
 		CrcUpdateUInt32(&amp;crc, digest);
 		CrcUpdateUInt32(&amp;crc, ar-&gt;GetCrc32(*i));
@@ -369,7 +368,7 @@
 		ArchiveInfo ai;
 		char keyb[100];
 		sprintf(keyb, &quot;ArchiveCache\\Archive%d\\&quot;, i);
-		string key = keyb;
+		std::string key = keyb;
 
 		ai.origName = p.SGetValueDef(&quot;&quot;, key + &quot;Name&quot;);
 
@@ -382,7 +381,7 @@
 		for (int m = 0; m &lt; numMaps; ++m) {
 			char mapb[100];
 			sprintf(mapb, &quot;%sMap%d\\&quot;, key.c_str(), m);
-			string map = mapb;
+			std::string map = mapb;
 
 			MapData md;
 			md.name = p.SGetValueDef(&quot;&quot;, map + &quot;Name&quot;);
@@ -395,7 +394,7 @@
 			ai.modData = GetModData(&amp;p, key + &quot;Mod&quot;);
 		}
 
-		string lcname = StringToLower(ai.origName);
+		std::string lcname = StringToLower(ai.origName);
 
 		archiveInfo[lcname] = ai;
 	}
@@ -413,8 +412,8 @@
 		return;
 
 	// First delete all outdated information
-	for (map&lt;string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ) {
-		map&lt;string, ArchiveInfo&gt;::iterator next = i;
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ) {
+		std::map&lt;std::string, ArchiveInfo&gt;::iterator next = i;
 		next++;
 		if (!i-&gt;second.updated) {
 			archiveInfo.erase(i);
@@ -426,7 +425,7 @@
 	fprintf(out, &quot;\tNumArchives=%d;\n&quot;, archiveInfo.size());
 	fprintf(out, &quot;\tInternalVer=%d;\n&quot;, INTERNAL_VER);
 	int cur = 0;
-	for (map&lt;string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
 		fprintf(out, &quot;\t[ARCHIVE%d]\n\t{\n&quot;, cur);
 		fprintf(out, &quot;\t\tName=%s;\n&quot;, i-&gt;second.origName.c_str());
 		fprintf(out, &quot;\t\tPath=%s;\n&quot;, i-&gt;second.path.c_str());
@@ -436,7 +435,7 @@
 
 		fprintf(out, &quot;\t\tNumMaps=%d;\n&quot;, i-&gt;second.mapData.size());
 		int curmap = 0;
-		for (vector&lt;MapData&gt;::iterator mi = i-&gt;second.mapData.begin(); mi != i-&gt;second.mapData.end(); ++mi) {
+		for (std::vector&lt;MapData&gt;::iterator mi = i-&gt;second.mapData.begin(); mi != i-&gt;second.mapData.end(); ++mi) {
 			fprintf(out, &quot;\t\t[MAP%d]\n\t\t{\n&quot;, curmap);
 			//WriteData(out, *mi);
 			fprintf(out, &quot;\t\t\tName=%s;\n&quot;, (*mi).name.c_str());
@@ -475,14 +474,14 @@
 
 			fprintf(out, &quot;\t\t\tNumDependencies=%d;\n&quot;, i-&gt;second.modData.dependencies.size());
 			int curdep = 0;
-			for (vector&lt;string&gt;::iterator dep = i-&gt;second.modData.dependencies.begin(); dep != i-&gt;second.modData.dependencies.end(); ++dep) {
+			for (std::vector&lt;std::string&gt;::iterator dep = i-&gt;second.modData.dependencies.begin(); dep != i-&gt;second.modData.dependencies.end(); ++dep) {
 				fprintf(out, &quot;\t\t\tDepend%d=%s;\n&quot;, curdep, (*dep).c_str());
 				curdep++;
 			}
 
 			fprintf(out, &quot;\t\t\tNumReplaces=%d;\n&quot;, i-&gt;second.modData.replaces.size());
 			int currep = 0;
-			for (vector&lt;string&gt;::iterator rep = i-&gt;second.modData.replaces.begin(); rep != i-&gt;second.modData.replaces.end(); ++rep) {
+			for (std::vector&lt;std::string&gt;::iterator rep = i-&gt;second.modData.replaces.begin(); rep != i-&gt;second.modData.replaces.end(); ++rep) {
 				fprintf(out, &quot;\t\t\tReplace%d=%s;\n&quot;, currep++, (*rep).c_str());
 			}
 
@@ -498,11 +497,11 @@
 	isDirty = false;
 }
 
-vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetPrimaryMods() const
+std::vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetPrimaryMods() const
 {
-	vector&lt;ModData&gt; ret;
+	std::vector&lt;ModData&gt; ret;
 
-	for (map&lt;string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
 		if (i-&gt;second.modData.name != &quot;&quot;) {
 
 			if (i-&gt;second.modData.modType != 1)
@@ -518,11 +517,11 @@
 	return ret;
 }
 
-vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetAllMods() const
+std::vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetAllMods() const
 {
-	vector&lt;ModData&gt; ret;
+	std::vector&lt;ModData&gt; ret;
 
-	for (map&lt;string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
 		if (i-&gt;second.modData.name != &quot;&quot;) {
 			// Add the archive the mod is in as the first dependency
 			ModData md = i-&gt;second.modData;
@@ -534,7 +533,7 @@
 	return ret;
 }
 
-vector&lt;string&gt; CArchiveScanner::GetArchives(const string&amp; root, int depth)
+std::vector&lt;std::string&gt; CArchiveScanner::GetArchives(const std::string&amp; root, int depth)
 {
 	// Protect against circular dependencies
 	// (worst case depth is if all archives form one huge dependency chain)
@@ -542,11 +541,9 @@
 		throw content_error(&quot;Circular dependency&quot;);
 	}
 
-	vector&lt;string&gt; ret;
-
-	string lcname = StringToLower(ModNameToModArchive(root));
-
-	map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	std::vector&lt;std::string&gt; ret;
+	std::string lcname = StringToLower(ModNameToModArchive(root));
+	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end())
 		return ret;
 
@@ -563,9 +560,9 @@
 		return ret;
 
 	// add depth-first
-	for (vector&lt;string&gt;::iterator i = aii-&gt;second.modData.dependencies.begin(); i != aii-&gt;second.modData.dependencies.end(); ++i) {
-		vector&lt;string&gt; dep = GetArchives(*i, depth + 1);
-		for (vector&lt;string&gt;::iterator j = dep.begin(); j != dep.end(); ++j) {
+	for (std::vector&lt;std::string&gt;::iterator i = aii-&gt;second.modData.dependencies.begin(); i != aii-&gt;second.modData.dependencies.end(); ++i) {
+		std::vector&lt;std::string&gt; dep = GetArchives(*i, depth + 1);
+		for (std::vector&lt;std::string&gt;::iterator j = dep.begin(); j != dep.end(); ++j) {
 			ret.push_back(*j);
 		}
 	}
@@ -573,12 +570,12 @@
 	return ret;
 }
 
-vector&lt;string&gt; CArchiveScanner::GetMaps()
+std::vector&lt;std::string&gt; CArchiveScanner::GetMaps()
 {
-	vector&lt;string&gt; ret;
+	std::vector&lt;std::string&gt; ret;
 
-	for (map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (std::vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
 			ret.push_back((*i).name);
 		}
 	}
@@ -586,12 +583,12 @@
 	return ret;
 }
 
-vector&lt;string&gt; CArchiveScanner::GetArchivesForMap(const string&amp; mapName)
+std::vector&lt;std::string&gt; CArchiveScanner::GetArchivesForMap(const std::string&amp; mapName)
 {
-	vector&lt;string&gt; ret;
+	std::vector&lt;std::string&gt; ret;
 
-	for (map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
+	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (std::vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
 			if (mapName == (*i).name) {
 				return GetArchives(aii-&gt;first);
 			}
@@ -601,19 +598,19 @@
 	return ret;
 }
 
-unsigned int CArchiveScanner::GetArchiveChecksum(const string&amp; name)
+unsigned int CArchiveScanner::GetArchiveChecksum(const std::string&amp; name)
 {
-	string lcname = name;
+	std::string lcname = name;
 
 	// Strip path-info if present
-	if (lcname.find_last_of('\\') != string::npos)
+	if (lcname.find_last_of('\\') != std::string::npos)
 		lcname = lcname.substr(lcname.find_last_of('\\') + 1);
-	if (lcname.find_last_of('/') != string::npos)
+	if (lcname.find_last_of('/') != std::string::npos)
 		lcname = lcname.substr(lcname.find_last_of('/') + 1);
 
 	StringToLowerInPlace(lcname);
 
-	map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end()) {
 		return 0;
 	}
@@ -621,19 +618,19 @@
 	return aii-&gt;second.checksum;
 }
 
-std::string CArchiveScanner::GetArchivePath(const string&amp; name)
+std::string CArchiveScanner::GetArchivePath(const std::string&amp; name)
 {
-	string lcname = name;
+	std::string lcname = name;
 
 	// Strip path-info if present
-	if (lcname.find_last_of('\\') != string::npos)
+	if (lcname.find_last_of('\\') != std::string::npos)
 		lcname = lcname.substr(lcname.find_last_of('\\') + 1);
-	if (lcname.find_last_of('/') != string::npos)
+	if (lcname.find_last_of('/') != std::string::npos)
 		lcname = lcname.substr(lcname.find_last_of('/') + 1);
 
 	StringToLowerInPlace(lcname);
 
-	map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end()) {
 		return 0;
 	}
@@ -642,12 +639,12 @@
 }
 
 /** Get checksum of all required archives depending on selected mod. */
-unsigned int CArchiveScanner::GetModChecksum(const string&amp; root)
+unsigned int CArchiveScanner::GetModChecksum(const std::string&amp; root)
 {
 	unsigned int checksum = 0;
-	vector&lt;string&gt; ars = GetArchives(root);
+	std::vector&lt;std::string&gt; ars = GetArchives(root);
 
-	for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
+	for (std::vector&lt;std::string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
 	{
 		checksum ^= GetArchiveChecksum(*i);
 	}
@@ -655,18 +652,18 @@
 }
 
 /** Get checksum of all required archives depending on selected map. */
-unsigned int CArchiveScanner::GetMapChecksum(const string&amp; mapName)
+unsigned int CArchiveScanner::GetMapChecksum(const std::string&amp; mapName)
 {
 	unsigned int checksum = 0;
-	vector&lt;string&gt; ars = GetArchivesForMap(mapName);
+	std::vector&lt;std::string&gt; ars = GetArchivesForMap(mapName);
 
-	for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
+	for (std::vector&lt;std::string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
 		checksum ^= GetArchiveChecksum(*i);
 	return checksum;
 }
 
 /** Check if calculated mod checksum equals given checksum. Throws content_error if not equal. */
-void CArchiveScanner::CheckMod(const string&amp; root, unsigned checksum)
+void CArchiveScanner::CheckMod(const std::string&amp; root, unsigned checksum)
 {
 	unsigned local = GetModChecksum(root);
 	if (local != checksum) {
@@ -680,7 +677,7 @@
 }
 
 /** Check if calculated map checksum equals given checksum. Throws content_error if not equal. */
-void CArchiveScanner::CheckMap(const string&amp; mapName, unsigned checksum)
+void CArchiveScanner::CheckMap(const std::string&amp; mapName, unsigned checksum)
 {
 	unsigned local = GetMapChecksum(mapName);
 	if (local != checksum) {

Modified: trunk/rts/System/FileSystem/ArchiveScanner.h
===================================================================
--- trunk/rts/System/FileSystem/ArchiveScanner.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveScanner.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -7,8 +7,6 @@
 
 #include &lt;stdio.h&gt;
 
-using namespace std;
-
 /*
  * This class searches through a given directory and its subdirectories looking for archive files.
  * When it finds one, it figures out what kind of archive it is (i.e. if it is a map or a mod currently).
@@ -25,38 +23,38 @@
 {
 public:
 	struct MapData {
-		string name;
-		string virtualPath;					// Where in the archive the map can be found
+		std::string name;
+		std::string virtualPath;					// Where in the archive the map can be found
 	};
 	struct ModData {
-		string name;        // ex:  Original Total Annihilation v2.3
-		string shortName;   // ex:  OTA
-		string version;     // ex:  v2.3
-		string mutator;     // ex:  deployment
-		string game;        // ex:  Total Annihilation
-		string shortGame;   // ex:  TA
-		string description; // ex:  Little units blowing up other little units
+		std::string name;							// ex:  Original Total Annihilation v2.3
+		std::string shortName;						// ex:  OTA
+		std::string version;						// ex:  v2.3
+		std::string mutator;						// ex:  deployment
+		std::string game;							// ex:  Total Annihilation
+		std::string shortGame;						// ex:  TA
+		std::string description;					// ex:  Little units blowing up other little units
 		int modType;
-		vector&lt;string&gt; dependencies;		// Archives it depends on
-		vector&lt;string&gt; replaces;			// This archive obsoletes these ones
+		std::vector&lt;std::string&gt; dependencies;		// Archives it depends on
+		std::vector&lt;std::string&gt; replaces;			// This archive obsoletes these ones
 	};
 	CArchiveScanner(void);
 	std::string GetFilename();
 	void ReadCacheData(const std::string&amp; filename);
 	void WriteCacheData(const std::string&amp; filename);
 	virtual ~CArchiveScanner(void);
-	void Scan(const string&amp; curPath, bool checksum = false);
-	vector&lt;ModData&gt; GetPrimaryMods() const;
-	vector&lt;ModData&gt; GetAllMods() const;
-	vector&lt;string&gt; GetArchives(const string&amp; root, int depth = 0);
-	vector&lt;string&gt; GetMaps();
-	vector&lt;string&gt; GetArchivesForMap(const string&amp; mapName);
-	unsigned int GetArchiveChecksum(const string&amp; name);
-	std::string GetArchivePath(const string&amp; name);
-	unsigned int GetModChecksum(const string&amp; root);
-	unsigned int GetMapChecksum(const string&amp; mapName);
-	void CheckMod(const string&amp; root, unsigned checksum); // these throw a content_error if checksum doesn't match
-	void CheckMap(const string&amp; mapName, unsigned checksum);
+	void Scan(const std::string&amp; curPath, bool checksum = false);
+	std::vector&lt;ModData&gt; GetPrimaryMods() const;
+	std::vector&lt;ModData&gt; GetAllMods() const;
+	std::vector&lt;std::string&gt; GetArchives(const std::string&amp; root, int depth = 0);
+	std::vector&lt;std::string&gt; GetMaps();
+	std::vector&lt;std::string&gt; GetArchivesForMap(const std::string&amp; mapName);
+	unsigned int GetArchiveChecksum(const std::string&amp; name);
+	std::string GetArchivePath(const std::string&amp; name);
+	unsigned int GetModChecksum(const std::string&amp; root);
+	unsigned int GetMapChecksum(const std::string&amp; mapName);
+	void CheckMod(const std::string&amp; root, unsigned checksum); // these throw a content_error if checksum doesn't match
+	void CheckMap(const std::string&amp; mapName, unsigned checksum);
 	std::string ModNameToModArchive(const std::string&amp; s) const;
 	std::string ModArchiveToModName(const std::string&amp; s) const;
 	ModData ModNameToModData(const std::string&amp; s) const;
@@ -64,19 +62,19 @@
 
 protected:
 	struct ArchiveInfo {
-		string path;
-		string origName;					// Could be useful to have the non-lowercased name around
+		std::string path;
+		std::string origName;					// Could be useful to have the non-lowercased name around
 		unsigned int modified;
-		vector&lt;MapData&gt; mapData;
+		std::vector&lt;MapData&gt; mapData;
 		ModData modData;
 		unsigned int checksum;
 		bool updated;
-		string replaced;					// If not empty, use that archive instead
+		std::string replaced;					// If not empty, use that archive instead
 	};
-	map&lt;string, ArchiveInfo&gt; archiveInfo;
-	ModData GetModData(TdfParser* p, const string&amp; section);
-	unsigned int GetCRC(const string&amp; filename);
-	unsigned int GetDirectoryCRC(const string&amp; curPath);
+	std::map&lt;std::string, ArchiveInfo&gt; archiveInfo;
+	ModData GetModData(TdfParser* p, const std::string&amp; section);
+	unsigned int GetCRC(const std::string&amp; filename);
+	unsigned int GetDirectoryCRC(const std::string&amp; curPath);
 	bool isDirty;
 	//void WriteModData(FILE* out, const ModData&amp; data);	// Helper to write out dependencies
 };

Modified: trunk/rts/System/FileSystem/ArchiveZip.cpp
===================================================================
--- trunk/rts/System/FileSystem/ArchiveZip.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveZip.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -3,7 +3,7 @@
 #include &lt;algorithm&gt;
 #include &quot;mmgr.h&quot;
 
-CArchiveZip::CArchiveZip(const string&amp; name) :
+CArchiveZip::CArchiveZip(const std::string&amp; name):
 	CArchiveBuffered(name),
 	curSearchHandle(1)
 {
@@ -21,7 +21,7 @@
 	for (int ret = unzGoToFirstFile(zip); ret == UNZ_OK; ret = unzGoToNextFile(zip)) {
 		unz_file_info info;
 		char fname[512];
-		string name;
+		std::string name;
 
 		unzGetCurrentFileInfo(zip, &amp;info, fname, 512, NULL, 0, NULL, 0);
 
@@ -47,9 +47,9 @@
 		unzClose(zip);
 }
 
-unsigned int CArchiveZip::GetCrc32 (const string&amp; fileName)
+unsigned int CArchiveZip::GetCrc32 (const std::string&amp; fileName)
 {
-	string lower = StringToLower(fileName);
+	std::string lower = StringToLower(fileName);
 	FileData fd = fileData[lower];
 	return fd.crc;
 }
@@ -59,17 +59,17 @@
 	return (zip != NULL);
 }
 
-class zip_exception : public exception {};
+class zip_exception: public std::exception {};
 
 // To simplify things, files are always read completely into memory from the zipfile, since zlib does not
 // provide any way of reading more than one file at a time
-ABOpenFile_t* CArchiveZip::GetEntireFile(const string&amp; fName)
+ABOpenFile_t* CArchiveZip::GetEntireFile(const std::string&amp; fName)
 {
 	// Don't allow opening files on missing/invalid archives
 	if (!zip)
 		return NULL;
 
-	string fileName = StringToLower(fName);
+	std::string fileName = StringToLower(fName);
 
 	//if (unzLocateFile(zip, fileName.c_str(), 2) != UNZ_OK) 
 	//	return 0;
@@ -106,7 +106,7 @@
 	return of;
 }
 
-int CArchiveZip::FindFiles(int cur, string* name, int* size)
+int CArchiveZip::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {
 		curSearchHandle++;
@@ -126,7 +126,7 @@
 	return cur;
 }
 
-void CArchiveZip::SetSlashesForwardToBack(string&amp; name)
+void CArchiveZip::SetSlashesForwardToBack(std::string&amp; name)
 {
 	for (unsigned int i = 0; i &lt; name.length(); ++i) {
 		if (name[i] == '/')
@@ -134,7 +134,7 @@
 	}
 }
 
-void CArchiveZip::SetSlashesBackToForward(string&amp; name)
+void CArchiveZip::SetSlashesBackToForward(std::string&amp; name)
 {
 	for (unsigned int i = 0; i &lt; name.length(); ++i) {
 		if (name[i] == '\\')

Modified: trunk/rts/System/FileSystem/ArchiveZip.h
===================================================================
--- trunk/rts/System/FileSystem/ArchiveZip.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/ArchiveZip.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -18,22 +18,22 @@
 	struct FileData {
 		unz_file_pos fp;
 		int size;
-		string origName;
+		std::string origName;
 		unsigned int crc;
 	};
 	unzFile zip;
-	map&lt;string, FileData&gt; fileData;		// using unzLocateFile is quite slow
+	std::map&lt;std::string, FileData&gt; fileData;		// using unzLocateFile is quite slow
 	int curSearchHandle;
-	map&lt;int, map&lt;string, FileData&gt;::iterator&gt; searchHandles;
-	virtual ABOpenFile_t* GetEntireFile(const string&amp; fileName);
-	void SetSlashesForwardToBack(string&amp; name);
-	void SetSlashesBackToForward(string&amp; name);
+	std::map&lt;int, std::map&lt;std::string, FileData&gt;::iterator&gt; searchHandles;
+	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fileName);
+	void SetSlashesForwardToBack(std::string&amp; name);
+	void SetSlashesBackToForward(std::string&amp; name);
 public:
-	CArchiveZip(const string&amp; name);
+	CArchiveZip(const std::string&amp; name);
 	virtual ~CArchiveZip(void);
 	virtual bool IsOpen();
-	virtual int FindFiles(int cur, string* name, int* size);
-	virtual unsigned int GetCrc32 (const string&amp; fileName);
+	virtual int FindFiles(int cur, std::string* name, int* size);
+	virtual unsigned int GetCrc32 (const std::string&amp; fileName);
 };
 
 #endif

Modified: trunk/rts/System/FileSystem/VFSHandler.cpp
===================================================================
--- trunk/rts/System/FileSystem/VFSHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/VFSHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -15,7 +15,7 @@
 }
 
 // Override determines whether if conflicts overwrites an existing entry in the virtual filesystem or not
-bool CVFSHandler::AddArchive(string arName, bool override)
+bool CVFSHandler::AddArchive(std::string arName, bool override)
 {
 	CArchiveBase* ar = archives[arName];
 	if (!ar) {
@@ -27,7 +27,7 @@
 	}
 
 	int cur;
-	string name;
+	std::string name;
 	int size;
 
 	for (cur = ar-&gt;FindFiles(0, &amp;name, &amp;size); cur != 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size)) {
@@ -47,17 +47,17 @@
 
 CVFSHandler::~CVFSHandler(void)
 {
-	for (map&lt;string, CArchiveBase*&gt;::iterator i = archives.begin(); i != archives.end(); ++i) {
+	for (std::map&lt;std::string, CArchiveBase*&gt;::iterator i = archives.begin(); i != archives.end(); ++i) {
 		delete i-&gt;second;
 	}
 }
 
-int CVFSHandler::LoadFile(string name, void* buffer)
+int CVFSHandler::LoadFile(std::string name, void* buffer)
 {
 	StringToLowerInPlace(name);
 	filesystem.ForwardSlashes(name);
 
-	map&lt;string, FileData&gt;::iterator fi = files.find(name);
+	std::map&lt;std::string, FileData&gt;::iterator fi = files.find(name);
 	if (fi == files.end()) {
 		return -1;
 	}
@@ -75,12 +75,12 @@
 	return fsize;
 }
 
-int CVFSHandler::GetFileSize(string name)
+int CVFSHandler::GetFileSize(std::string name)
 {
 	StringToLowerInPlace(name);
 	filesystem.ForwardSlashes(name);
 
-	map&lt;string, FileData&gt;::iterator fi = files.find(name);
+	std::map&lt;std::string, FileData&gt;::iterator fi = files.find(name);
 	if (fi == files.end()) {
 		return -1;
 	}
@@ -103,41 +103,41 @@
 }
 
 // Returns all the files in the given (virtual) directory without the preceeding pathname
-vector&lt;string&gt; CVFSHandler::GetFilesInDir(string dir)
+std::vector&lt;std::string&gt; CVFSHandler::GetFilesInDir(std::string dir)
 {
-	vector&lt;string&gt; ret;
+	std::vector&lt;std::string&gt; ret;
 	StringToLowerInPlace(dir);
 	filesystem.ForwardSlashes(dir);
 
-	map&lt;string, FileData&gt;::const_iterator filesStart = files.begin();
-	map&lt;string, FileData&gt;::const_iterator filesEnd   = files.end();
+	std::map&lt;std::string, FileData&gt;::const_iterator filesStart = files.begin();
+	std::map&lt;std::string, FileData&gt;::const_iterator filesEnd   = files.end();
 
 	// Non-empty directories to look in should have a trailing backslash
 	if (!dir.empty()) {
-		string::size_type dirLast = (dir.length() - 1);
+		std::string::size_type dirLast = (dir.length() - 1);
 		if (dir[dirLast] != '/') {
 			dir += &quot;/&quot;;
 			dirLast++;
 		}
 		// limit the iterator range
-		string dirEnd = dir;
+		std::string dirEnd = dir;
 		dirEnd[dirLast] = dirEnd[dirLast] + 1;
 		filesStart = files.lower_bound(dir);
 		filesEnd   = files.upper_bound(dirEnd);
 	}
 
 	while (filesStart != filesEnd) {
-		const string path = filesystem.GetDirectory(filesStart-&gt;first);
+		const std::string path = filesystem.GetDirectory(filesStart-&gt;first);
 
 		// Test to see if this file start with the dir path
 		if (path.compare(0, dir.length(), dir) == 0) {
 
 			// Strip pathname
-			const string name = filesStart-&gt;first.substr(dir.length());
+			const std::string name = filesStart-&gt;first.substr(dir.length());
 
 			// Do not return files in subfolders
-			if ((name.find('/') == string::npos) &amp;&amp;
-			    (name.find('\\') == string::npos)) {
+			if ((name.find('/') == std::string::npos) &amp;&amp;
+			    (name.find('\\') == std::string::npos)) {
 				ret.push_back(name);
 			}
 		}
@@ -149,46 +149,46 @@
 
 
 // Returns all the sub-directories in the given (virtual) directory without the preceeding pathname
-vector&lt;string&gt; CVFSHandler::GetDirsInDir(string dir)
+std::vector&lt;std::string&gt; CVFSHandler::GetDirsInDir(std::string dir)
 {
-	vector&lt;string&gt; ret;
+	std::vector&lt;std::string&gt; ret;
 	StringToLowerInPlace(dir);
 	filesystem.ForwardSlashes(dir);
 
-	map&lt;string, FileData&gt;::const_iterator filesStart = files.begin();
-	map&lt;string, FileData&gt;::const_iterator filesEnd   = files.end();
+	std::map&lt;std::string, FileData&gt;::const_iterator filesStart = files.begin();
+	std::map&lt;std::string, FileData&gt;::const_iterator filesEnd   = files.end();
 
 	// Non-empty directories to look in should have a trailing backslash
 	if (!dir.empty()) {
-		string::size_type dirLast = (dir.length() - 1);
+		std::string::size_type dirLast = (dir.length() - 1);
 		if (dir[dirLast] != '/') {
 			dir += &quot;/&quot;;
 			dirLast++;
 		}
 		// limit the iterator range
-		string dirEnd = dir;
+		std::string dirEnd = dir;
 		dirEnd[dirLast] = dirEnd[dirLast] + 1;
 		filesStart = files.lower_bound(dir);
 		filesEnd   = files.upper_bound(dirEnd);
 	}
 
-	set&lt;string&gt; dirs;
+	std::set&lt;std::string&gt; dirs;
 
 	while (filesStart != filesEnd) {
-		const string path = filesystem.GetDirectory(filesStart-&gt;first);
+		const std::string path = filesystem.GetDirectory(filesStart-&gt;first);
 		// Test to see if this file start with the dir path
 		if (path.compare(0, dir.length(), dir) == 0) {
 			// Strip pathname
-			const string name = filesStart-&gt;first.substr(dir.length());
-			const string::size_type slash = name.find_first_of(&quot;/\\&quot;);
-			if (slash != string::npos) {
+			const std::string name = filesStart-&gt;first.substr(dir.length());
+			const std::string::size_type slash = name.find_first_of(&quot;/\\&quot;);
+			if (slash != std::string::npos) {
 				dirs.insert(name.substr(0, slash + 1));
 			}
 		}
 		filesStart++;
 	}
 
-	for (set&lt;string&gt;::const_iterator it = dirs.begin(); it != dirs.end(); ++it) {
+	for (std::set&lt;std::string&gt;::const_iterator it = dirs.begin(); it != dirs.end(); ++it) {
 		ret.push_back(*it);
 	}
 

Modified: trunk/rts/System/FileSystem/VFSHandler.h
===================================================================
--- trunk/rts/System/FileSystem/VFSHandler.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/FileSystem/VFSHandler.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -7,8 +7,6 @@
 
 class CArchiveBase;
 
-using namespace std;
-
 class CVFSHandler
 {
 protected:
@@ -17,19 +15,19 @@
 		int size;
 		bool dynamic;
 	};
-	map&lt;string, FileData&gt; files; 
-	map&lt;string, CArchiveBase*&gt; archives;
+	std::map&lt;std::string, FileData&gt; files; 
+	std::map&lt;std::string, CArchiveBase*&gt; archives;
 public:
 	CVFSHandler();
 	virtual ~CVFSHandler();
 
-	int LoadFile(string name, void* buffer);
-	int GetFileSize(string name);
+	int LoadFile(std::string name, void* buffer);
+	int GetFileSize(std::string name);
 
-	vector&lt;string&gt; GetFilesInDir(string dir);
-	vector&lt;string&gt; GetDirsInDir(string dir);
+	std::vector&lt;std::string&gt; GetFilesInDir(std::string dir);
+	std::vector&lt;std::string&gt; GetDirsInDir(std::string dir);
 
-	bool AddArchive(string arName, bool override);
+	bool AddArchive(std::string arName, bool override);
 };
 
 extern CVFSHandler* hpiHandler;

Modified: trunk/rts/System/LoadSaveHandler.cpp
===================================================================
--- trunk/rts/System/LoadSaveHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/LoadSaveHandler.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -126,7 +126,7 @@
 			return;
 		}
 
-		string scriptText;
+		std::string scriptText;
 		if (gameSetup) {
 			scriptText = gameSetup-&gt;gameSetupText;
 		}

Modified: trunk/rts/System/Platform/Linux/OpenALSound.cpp
===================================================================
--- trunk/rts/System/Platform/Linux/OpenALSound.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/Platform/Linux/OpenALSound.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -14,6 +14,7 @@
 #include &quot;SDL_types.h&quot;
 #include &quot;Platform/byteorder.h&quot;
 #include &quot;OpenALSound.h&quot;
+#include &quot;OggStream.h&quot;
 #include &quot;mmgr.h&quot;
 
 // Ogg-Vorbis audio stream object
@@ -71,7 +72,7 @@
 		alDeleteSources(1,&amp;Sources[i]);
 	}
 	delete[] Sources;
-	map&lt;string, ALuint&gt;::iterator it;
+	std::map&lt;std::string, ALuint&gt;::iterator it;
 	for (it = soundMap.begin(); it != soundMap.end(); ++it) {
 		alDeleteBuffers(1, &amp;it-&gt;second);
 	}
@@ -374,7 +375,7 @@
 }
 
 
-ALuint COpenALSound::LoadALBuffer(const string&amp; path)
+ALuint COpenALSound::LoadALBuffer(const std::string&amp; path)
 {
 	Uint8* buf = 0;
 	ALuint buffer;
@@ -408,9 +409,9 @@
 }
 
 
-ALuint COpenALSound::GetWaveId(const string&amp; path, bool _hardFail)
+ALuint COpenALSound::GetWaveId(const std::string&amp; path, bool _hardFail)
 {
-	map&lt;string, ALuint&gt;::const_iterator it = soundMap.find(path);
+	std::map&lt;std::string, ALuint&gt;::const_iterator it = soundMap.find(path);
 	if (it != soundMap.end()) {
 		return it-&gt;second;
 	}

Modified: trunk/rts/System/Platform/Linux/OpenALSound.h
===================================================================
--- trunk/rts/System/Platform/Linux/OpenALSound.h	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/Platform/Linux/OpenALSound.h	2008-04-26 17:48:56 UTC (rev 5787)
@@ -10,15 +10,11 @@
 #include &lt;AL/alc.h&gt;
 #include &quot;SDL_types.h&quot;
 
-#include &quot;OggStream.h&quot;
 
-
-using namespace std;
-
-class COpenALSound : public CSound
+class COpenALSound: public CSound
 {
 public:
-	ALuint GetWaveId(const string&amp; path, bool hardFail);
+	ALuint GetWaveId(const std::string&amp; path, bool hardFail);
 	void Update();
 	void PlaySample(int id, float volume);
 	void PlaySample(int id, const float3&amp; p, float volume);
@@ -39,7 +35,7 @@
 	bool ReadWAV(const char* name, Uint8* buf, int size, ALuint albuffer);
 
 private:
-	ALuint LoadALBuffer(const string&amp; path);
+	ALuint LoadALBuffer(const std::string&amp; path);
 	void PlaySample(int id, const float3 &amp;p, float volume, bool relative);
 
 	int maxSounds;
@@ -50,7 +46,7 @@
 	void UpdateListener();
 	void Enqueue(ALuint src);
 	
-	map&lt;string, ALuint&gt; soundMap; // filename, index into Buffers
+	std::map&lt;std::string, ALuint&gt; soundMap; // filename, index into Buffers
 	float3 posScale;
 	ALuint* Sources;
 };

Modified: trunk/rts/System/SpringApp.cpp
===================================================================
--- trunk/rts/System/SpringApp.cpp	2008-04-26 11:41:57 UTC (rev 5786)
+++ trunk/rts/System/SpringApp.cpp	2008-04-26 17:48:56 UTC (rev 5787)
@@ -251,7 +251,7 @@
 	if (!fsaa)
 		return false;
 	SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS,1);
-	GLuint fsaalevel = max(min(configHandler.GetInt(&quot;FSAALevel&quot;, 2), 8), 0);
+	GLuint fsaalevel = std::max(std::min(configHandler.GetInt(&quot;FSAALevel&quot;, 2), 8), 0);
 
 	make_even_number(fsaalevel);
 
@@ -892,7 +892,7 @@
 								} else {
 									if (i &lt; SDLK_DELETE) {
 										const int len = (int)ac-&gt;userInput.length();
-										ac-&gt;writingPos = max(0, min(len, ac-&gt;writingPos));
+										ac-&gt;writingPos = std::max(0, std::min(len, ac-&gt;writingPos));
 										char str[2] = { char(i), 0 };
 										ac-&gt;userInput.insert(ac-&gt;writingPos, str);
 										ac-&gt;writingPos++;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000566.html">[Taspring-linux-commit] r5786 - in trunk/rts: Lua	Rendering/UnitModels Sim/Features Sim/Misc Sim/Units build/vstudio8
</A></li>
	<LI>Next message: <A HREF="000568.html">[Taspring-linux-commit] r5788 - in trunk/AI/Global: AAI KAI-0.2	KAIK-0.13 RAI-0.553 RAI-0.553/Krogs Metal Class v0.4
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#567">[ date ]</a>
              <a href="thread.html#567">[ thread ]</a>
              <a href="subject.html#567">[ subject ]</a>
              <a href="author.html#567">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
