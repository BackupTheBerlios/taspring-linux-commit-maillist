<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5778 - in trunk/rts: ExternalAI Game Lua	Rendering/Textures Rendering/UnitModels Sim/Features Sim/Misc	Sim/Projectiles Sim/Projectiles/Unsynced	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Weapons	build/vstudio8
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5778%20-%20in%20trunk/rts%3A%20ExternalAI%20Game%20Lua%0A%09Rendering/Textures%20Rendering/UnitModels%20Sim/Features%20Sim/Misc%0A%09Sim/Projectiles%20Sim/Projectiles/Unsynced%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%20Sim/Weapons%0A%09build/vstudio8&In-Reply-To=%3C20080425185616.29D2746AE%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000557.html">
   <LINK REL="Next"  HREF="000559.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5778 - in trunk/rts: ExternalAI Game Lua	Rendering/Textures Rendering/UnitModels Sim/Features Sim/Misc	Sim/Projectiles Sim/Projectiles/Unsynced	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Weapons	build/vstudio8</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5778%20-%20in%20trunk/rts%3A%20ExternalAI%20Game%20Lua%0A%09Rendering/Textures%20Rendering/UnitModels%20Sim/Features%20Sim/Misc%0A%09Sim/Projectiles%20Sim/Projectiles/Unsynced%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%20Sim/Weapons%0A%09build/vstudio8&In-Reply-To=%3C20080425185616.29D2746AE%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5778 - in trunk/rts: ExternalAI Game Lua	Rendering/Textures Rendering/UnitModels Sim/Features Sim/Misc	Sim/Projectiles Sim/Projectiles/Unsynced	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Weapons	build/vstudio8">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Apr 25 20:56:15 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000557.html">[Taspring-linux-commit] r5777 - in trunk/rts: Game System/Net
</A></li>
        <LI>Next message: <A HREF="000559.html">[Taspring-linux-commit] r5779 - trunk/Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#558">[ date ]</a>
              <a href="thread.html#558">[ thread ]</a>
              <a href="subject.html#558">[ subject ]</a>
              <a href="author.html#558">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-04-25 20:56:13 +0200 (Fri, 25 Apr 2008)
New Revision: 5778

Added:
   trunk/rts/Sim/Misc/CollisionHandler.cpp
   trunk/rts/Sim/Misc/CollisionHandler.h
   trunk/rts/Sim/Misc/CollisionVolumeData.h
Removed:
   trunk/rts/Sim/Misc/CollisionVolume.cpp
   trunk/rts/Sim/Misc/CollisionVolume.h
Modified:
   trunk/rts/ExternalAI/AICallback.cpp
   trunk/rts/ExternalAI/AICheats.cpp
   trunk/rts/Game/GameHelper.cpp
   trunk/rts/Game/PlayerRoster.cpp
   trunk/rts/Game/WaitCommandsAI.h
   trunk/rts/Lua/LuaMaterial.cpp
   trunk/rts/Lua/LuaSyncedCtrl.cpp
   trunk/rts/Lua/LuaSyncedCtrl.h
   trunk/rts/Rendering/Textures/TextureHandler.cpp
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Sim/Features/Feature.cpp
   trunk/rts/Sim/Features/Feature.h
   trunk/rts/Sim/Features/FeatureDef.h
   trunk/rts/Sim/Features/FeatureHandler.cpp
   trunk/rts/Sim/Misc/LosHandler.h
   trunk/rts/Sim/Misc/RadarHandler.h
   trunk/rts/Sim/Projectiles/FlareProjectile.cpp
   trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
   trunk/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/Unit.h
   trunk/rts/Sim/Units/UnitDef.h
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/Sim/Weapons/bombdropper.cpp
   trunk/rts/build/vstudio8/rts.vcproj
Log:
refactor CCollisionVolume into a CCollisionHandler and a CollisionVolumeData
struct, both unit and feature objects now store a copy of their unitdef's and
featuredef's CollisionVolumeData instance for individual runtime manipulation

add two Lua synced callouts for controlling the collision volume properties:
SetUnitCollisionVolumeData(id, xs, ys, zs, xo, yo, zo, vtype, ptype, paxis)
and SetFeatureCollisionVolumeData() (same args)

get rid of the 'using namespace std' in Unit.h


Modified: trunk/rts/ExternalAI/AICallback.cpp
===================================================================
--- trunk/rts/ExternalAI/AICallback.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/ExternalAI/AICallback.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -612,14 +612,16 @@
 }
 
 bool CAICallback::IsUnitParalyzed(int unitid){
-	verify ();
+	verify();
+
 	if (CHECK_UNITID(unitid)) {
-		CUnit* unit=uh-&gt;units[unitid];
-		if(unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)){
+		CUnit* unit = uh-&gt;units[unitid];
+		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
 			return unit-&gt;stunned;
 		}
 	}
-	return 0;
+
+	return false;
 }
 
 bool CAICallback::IsUnitNeutral(int unitid) {
@@ -629,14 +631,12 @@
 		CUnit* unit = uh-&gt;units[unitid];
 
 		if (unit &amp;&amp; (unit-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS)) {
-			if ((gs-&gt;useLuaGaia &amp;&amp; unit-&gt;team == gs-&gt;gaiaTeamID) || (unit-&gt;team == MAX_TEAMS - 1))
+			if (unit-&gt;IsNeutral())
 				return true;
-			if (unit-&gt;neutral)
-				return true;
 		}
 	}
 
-	return 0;
+	return false;
 }
 
 int CAICallback::InitPath(float3 start,float3 end,int pathType)

Modified: trunk/rts/ExternalAI/AICheats.cpp
===================================================================
--- trunk/rts/ExternalAI/AICheats.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/ExternalAI/AICheats.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -294,13 +294,16 @@
 	return false;
 }
 
-bool CAICheats::IsUnitParalyzed(int unitid){
-	if (!CHECK_UNITID(unitid)) return false;
+bool CAICheats::IsUnitParalyzed(int unitid) {
+	if (!CHECK_UNITID(unitid))
+		return false;
+
 	CUnit* unit = uh-&gt;units[unitid];
 	if (unit) {
 		return unit-&gt;stunned;
 	}
-	return 0;
+
+	return false;
 }
 
 
@@ -310,13 +313,10 @@
 
 	CUnit* unit = uh-&gt;units[unitid];
 	if (unit) {
-		if ((gs-&gt;useLuaGaia &amp;&amp; unit-&gt;team == gs-&gt;gaiaTeamID) || (unit-&gt;team == MAX_TEAMS - 1))
-			return true;
-		if (unit-&gt;neutral)
-			return true;
+		return (unit-&gt;IsNeutral());
 	}
 
-	return 0;
+	return false;
 }
 
 

Modified: trunk/rts/Game/GameHelper.cpp
===================================================================
--- trunk/rts/Game/GameHelper.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Game/GameHelper.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -248,9 +248,8 @@
 				continue;
 			if (ignoreAllies &amp;&amp; u-&gt;allyteam == owner-&gt;allyteam)
 				continue;
-			if (ignoreNeutrals) {
-				if ((gs-&gt;useLuaGaia &amp;&amp; u-&gt;team == gs-&gt;gaiaTeamID) || (u-&gt;team == MAX_TEAMS - 1)) continue;
-				if (u-&gt;neutral) continue;
+			if (ignoreNeutrals &amp;&amp; u-&gt;IsNeutral()) {
+				continue;
 			}
 
 			float3 dif = u-&gt;midPos - start;
@@ -856,7 +855,7 @@
 			if (u == owner)
 				continue;
 
-			if (u-&gt;neutral || (gs-&gt;useLuaGaia &amp;&amp; u-&gt;team == gs-&gt;gaiaTeamID) || (u-&gt;team == MAX_TEAMS - 1)) {
+			if (u-&gt;IsNeutral()) {
 				if (TestConeHelper(from, dir, length, spread, u))
 					return true;
 			}
@@ -930,7 +929,7 @@
 			if (u == owner)
 				continue;
 
-			if (u-&gt;neutral || (gs-&gt;useLuaGaia &amp;&amp; u-&gt;team == gs-&gt;gaiaTeamID) || (u-&gt;team == MAX_TEAMS - 1)) {
+			if (u-&gt;IsNeutral()) {
 				if (TestTrajectoryConeHelper(from, flatdir, length, linear, quadratic, spread, baseSize, u))
 					return true;
 			}
@@ -942,7 +941,7 @@
 
 
 /** helper for TestTrajectoryAllyCone and TestTrajectoryNeutralCone
-    @return true if the unit u is in the firing cone, false otherwise */
+    @return true if the unit u is in the firing trajectory, false otherwise */
 bool CGameHelper::TestTrajectoryConeHelper(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, const CUnit* u)
 {
 	float3 dif = u-&gt;midPos - from;

Modified: trunk/rts/Game/PlayerRoster.cpp
===================================================================
--- trunk/rts/Game/PlayerRoster.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Game/PlayerRoster.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -239,8 +239,8 @@
 	}
 
 	// sort by player name
-	const string aName = StringToLower(aP-&gt;playerName);
-	const string bName = StringToLower(bP-&gt;playerName);
+	const std::string aName = StringToLower(aP-&gt;playerName);
+	const std::string bName = StringToLower(bP-&gt;playerName);
 	return strcmp(aName.c_str(), bName.c_str());
 }
 

Modified: trunk/rts/Game/WaitCommandsAI.h
===================================================================
--- trunk/rts/Game/WaitCommandsAI.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Game/WaitCommandsAI.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -72,7 +72,7 @@
 				virtual void Update() = 0;
 				virtual void Draw() const { return; }
 				virtual void AddUnitPosition(const float3&amp; pos) const { return; }
-				virtual const string&amp; GetStateText() const { return noText; }
+				virtual const std::string&amp; GetStateText() const { return noText; }
 			public:
 				time_t GetDeadTime() const { return deadTime; }
 				float GetCode() const { return code; }
@@ -99,7 +99,7 @@
 				static KeyType GetNewKey();
 			private:
 				static KeyType keySource;
-				static const string noText;
+				static const std::string noText;
 				void PostLoad();
 		};
 
@@ -115,7 +115,7 @@
 				void RemoveUnit(CUnit* unit);
 				void Update();
 				void Draw() const;
-				const string&amp; GetStateText() const;
+				const std::string&amp; GetStateText() const;
 				int GetDuration() const { return duration; }
 			private:
 				TimeWait(const Command&amp; cmd, CUnit* unit);

Modified: trunk/rts/Lua/LuaMaterial.cpp
===================================================================
--- trunk/rts/Lua/LuaMaterial.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Lua/LuaMaterial.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -121,7 +121,7 @@
 
 bool LuaUnitMaterial::SetLastLOD(unsigned int lod)
 {
-	lastLOD = min(lod, lodCount - 1);
+	lastLOD = std::min(lod, lodCount - 1);
 	return true;
 }
 
@@ -331,7 +331,7 @@
 		glUniformMatrix4fv(cameraLoc, 1, GL_FALSE, array);
 	}
 
-	const int maxTex = max(texCount, prev.texCount);
+	const int maxTex = std::max(texCount, prev.texCount);
 	for (int t = 0; t &lt; maxTex; t++) {
 		glActiveTexture(GL_TEXTURE0 + t);
 		textures[t].Execute(prev.textures[t]);
@@ -367,7 +367,7 @@
 		return cmp;
 	}
 
-	const int maxTex = min(a.texCount, b.texCount);
+	const int maxTex = std::min(a.texCount, b.texCount);
 	for (int t = 0; t &lt; maxTex; t++) {
 		cmp = LuaMatTexture::Compare(a.textures[t], b.textures[t]);
 		if (cmp != 0) {

Modified: trunk/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -31,6 +31,7 @@
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
 #include &quot;Sim/Misc/DamageArray.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
@@ -128,6 +129,8 @@
 	REGISTER_LUA_CFUNC(SetUnitLineage);
 	REGISTER_LUA_CFUNC(SetUnitNeutral);
 	REGISTER_LUA_CFUNC(SetUnitTarget);
+	REGISTER_LUA_CFUNC(SetUnitCollisionVolumeData);
+
 	REGISTER_LUA_CFUNC(SetUnitPhysics);
 	REGISTER_LUA_CFUNC(SetUnitPosition);
 	REGISTER_LUA_CFUNC(SetUnitVelocity);
@@ -147,6 +150,7 @@
 	REGISTER_LUA_CFUNC(SetFeaturePosition);
 	REGISTER_LUA_CFUNC(SetFeatureDirection);
 	REGISTER_LUA_CFUNC(SetFeatureNoSelect);
+	REGISTER_LUA_CFUNC(SetFeatureCollisionVolumeData);
 
 	REGISTER_LUA_CFUNC(CallCOBScript);
 	REGISTER_LUA_CFUNC(CallCOBScriptCB);
@@ -261,7 +265,7 @@
 	}
 	const int unitID = (int)lua_tonumber(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
-		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
+		luaL_error(L, &quot;%s(): Bad unitID: %d\n&quot;, caller, unitID);
 	}
 	CUnit* unit = uh-&gt;units[unitID];
 	if (unit == NULL) {
@@ -312,7 +316,7 @@
 	}
 	const int teamID = (int)lua_tonumber(L, index);
 	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
-		luaL_error(L, &quot;%s(): Bad teamID: %i&quot;, caller, teamID);
+		luaL_error(L, &quot;%s(): Bad teamID: %d&quot;, caller, teamID);
 	}
 	CTeam* team = gs-&gt;Team(teamID);
 	if (team == NULL) {
@@ -327,11 +331,11 @@
 	luaL_checknumber(L, index);
 	const int unitID = (int)lua_tonumber(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
-		luaL_error(L, &quot;Bad unitID: %i\n&quot;, unitID);
+		luaL_error(L, &quot;Bad unitID: %d\n&quot;, unitID);
 	}
 	CUnit* unit = uh-&gt;units[unitID];
 	if (unit == NULL) {
-		luaL_error(L, &quot;Bad unitID: %i\n&quot;, unitID);
+		luaL_error(L, &quot;Bad unitID: %d\n&quot;, unitID);
 	}
 	return unit;
 }
@@ -342,11 +346,11 @@
 	luaL_checknumber(L, index);
 	const int playerID = (int)lua_tonumber(L, index);
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
-		luaL_error(L, &quot;Bad playerID: %i\n&quot;, playerID);
+		luaL_error(L, &quot;Bad playerID: %d\n&quot;, playerID);
 	}
 	CPlayer* player = gs-&gt;players[playerID];
 	if (player == NULL) {
-		luaL_error(L, &quot;Bad playerID: %i\n&quot;, playerID);
+		luaL_error(L, &quot;Bad playerID: %d\n&quot;, playerID);
 	}
 	return player;
 }
@@ -736,7 +740,6 @@
 	if ((unit == NULL) || (unit-&gt;cob == NULL)) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
 
 	int arg = 2;
 	bool splitData = false;
@@ -823,18 +826,18 @@
 		teamID = (int)lua_tonumber(L, 6);
 	}
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
-		luaL_error(L, &quot;CreateUnit(): bad team number: %i&quot;, teamID);
+		luaL_error(L, &quot;CreateUnit(): bad team number: %d&quot;, teamID);
 	}
 
 	if (gs-&gt;AllyTeam(teamID) &gt;= gs-&gt;activeAllyTeams) {
 		// FIXME: there's a segv in CLosHandler::LosAddAir,
 		//        this is a dirty hack to avoid it
-		luaL_error(L, &quot;CreateUnit(): inactive team: %i&quot;, teamID);
+		luaL_error(L, &quot;CreateUnit(): inactive team: %d&quot;, teamID);
 	}
 
 
 	if (!FullCtrl() &amp;&amp; (CtrlTeam() != teamID)) {
-		luaL_error(L, &quot;Error in CreateUnit(), bad team %i&quot;, teamID);
+		luaL_error(L, &quot;Error in CreateUnit(), bad team %d&quot;, teamID);
 		return 0;
 	}
 
@@ -1447,6 +1450,42 @@
 }
 
 
+int LuaSyncedCtrl::SetUnitCollisionVolumeData(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+
+	if (unit == NULL) {
+		return 0;
+	}
+	if (unit-&gt;collisionVolumeData == NULL) {
+		return 0;
+	}
+
+	const int args = lua_gettop(L);
+	if (args == 10) {
+		const float xs = float(lua_tonumber(L, 2));
+		const float ys = float(lua_tonumber(L, 3));
+		const float zs = float(lua_tonumber(L, 4));
+		const float xo = float(lua_tonumber(L, 5));
+		const float yo = float(lua_tonumber(L, 6));
+		const float zo = float(lua_tonumber(L, 7));
+		const int vType = int(lua_tonumber(L,  8));
+		const int tType = int(lua_tonumber(L,  9));
+		const int pAxis = int(lua_tonumber(L, 10));
+
+		const float3 scales(xs, ys, zs);
+		const float3 offsets(xo, yo, zo);
+
+		unit-&gt;collisionVolumeData-&gt;Init(scales, offsets, vType, tType, pAxis);
+	} else {
+		luaL_error(L, &quot;Incorrect arguments to SetUnitCollisionVolumeData()&quot;);
+	}
+
+	return 0;
+}
+
+
+
 int LuaSyncedCtrl::SetUnitMoveGoal(lua_State* L)
 {
 	CheckAllowGameChanges(L);
@@ -1815,7 +1854,7 @@
 
 	const int allyTeam = (team &lt; 0) ? -1 : gs-&gt;AllyTeam(team);
 	if (!CanControlFeatureAllyTeam(allyTeam)) {
-		luaL_error(L, &quot;CreateFeature() bad team permission %i&quot;, team);
+		luaL_error(L, &quot;CreateFeature() bad team permission %d&quot;, team);
 	}
 
 	if (inCreateFeature) {
@@ -1975,6 +2014,40 @@
 }
 
 
+int LuaSyncedCtrl::SetFeatureCollisionVolumeData(lua_State* L)
+{
+	CFeature* feature = ParseFeature(L, __FUNCTION__, 1);
+	if (feature == NULL) {
+		return 0;
+	}
+	if (feature-&gt;collisionVolumeData == NULL) {
+		return 0;
+	}
+
+	const int args = lua_gettop(L);
+	if (args == 10) {
+		const float xs = float(lua_tonumber(L, 2));
+		const float ys = float(lua_tonumber(L, 3));
+		const float zs = float(lua_tonumber(L, 4));
+		const float xo = float(lua_tonumber(L, 5));
+		const float yo = float(lua_tonumber(L, 6));
+		const float zo = float(lua_tonumber(L, 7));
+		const int vType = int(lua_tonumber(L,  8));
+		const int tType = int(lua_tonumber(L,  9));
+		const int pAxis = int(lua_tonumber(L, 10));
+
+		const float3 scales(xs, ys, zs);
+		const float3 offsets(xo, yo, zo);
+
+		feature-&gt;collisionVolumeData-&gt;Init(scales, offsets, vType, tType, pAxis);
+	} else {
+		luaL_error(L, &quot;Incorrect arguments to SetFeatureCollisionVolumeData()&quot;);
+	}
+
+	return 0;
+}
+
+
 /******************************************************************************/
 /******************************************************************************/
 

Modified: trunk/rts/Lua/LuaSyncedCtrl.h
===================================================================
--- trunk/rts/Lua/LuaSyncedCtrl.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Lua/LuaSyncedCtrl.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -68,6 +68,7 @@
 		static int SetUnitLineage(lua_State* L);
 		static int SetUnitNeutral(lua_State* L);
 		static int SetUnitTarget(lua_State* L);
+		static int SetUnitCollisionVolumeData(lua_State* L);
 
 		static int SetUnitPhysics(lua_State* L);
 		static int SetUnitPosition(lua_State* L);
@@ -88,6 +89,7 @@
 		static int SetFeaturePosition(lua_State* L);
 		static int SetFeatureDirection(lua_State* L);
 		static int SetFeatureNoSelect(lua_State* L);
+		static int SetFeatureCollisionVolumeData(lua_State* L);
 
 		static int LevelHeightMap(lua_State* L);
 		static int AdjustHeightMap(lua_State* L);

Modified: trunk/rts/Rendering/Textures/TextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/Textures/TextureHandler.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Rendering/Textures/TextureHandler.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -64,7 +64,7 @@
 		files.push_back(*fi);
 	}
 
-	set&lt;string&gt; usedNames;
+	std::set&lt;string&gt; usedNames;
 
 	for(std::vector&lt;std::string&gt;::iterator fi = files.begin(); fi != files.end(); ++fi) {
 		std::string s = std::string(*fi);
@@ -230,7 +230,7 @@
 
 CTextureHandler::~CTextureHandler()
 {
-	map&lt;string,UnitTexture*&gt;::iterator tti;
+	std::map&lt;string,UnitTexture*&gt;::iterator tti;
 	for(tti=textures.begin();tti!=textures.end();++tti){
 		delete tti-&gt;second;
 	}
@@ -342,9 +342,9 @@
 	for(int a=0;a&lt;bm-&gt;ysize*bm-&gt;xsize;++a){
 		if(bm-&gt;mem[a*4]==bm-&gt;mem[a*4+2] &amp;&amp; bm-&gt;mem[a*4+1]==0){
 			float lum=bm-&gt;mem[a*4]/255.0f;
-			bm-&gt;mem[a*4+0]=(unsigned char)(min(255,int(teamCol[0]*lum*1.5f)));
-			bm-&gt;mem[a*4+1]=(unsigned char)(min(255,int(teamCol[1]*lum*1.5f)));
-			bm-&gt;mem[a*4+2]=(unsigned char)(min(255,int(teamCol[2]*lum*1.5f)));
+			bm-&gt;mem[a*4+0]=(unsigned char)(std::min(255,int(teamCol[0]*lum*1.5f)));
+			bm-&gt;mem[a*4+1]=(unsigned char)(std::min(255,int(teamCol[1]*lum*1.5f)));
+			bm-&gt;mem[a*4+2]=(unsigned char)(std::min(255,int(teamCol[2]*lum*1.5f)));
 		}
 	}
 	return tex;

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -30,7 +30,7 @@
 
 #include &quot;ExternalAI/Group.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
-#include &quot;Sim/Misc/CollisionVolume.h&quot;
+#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/BuilderCAI.h&quot;
@@ -1704,13 +1704,13 @@
 		GLUquadricObj* q = gluNewQuadric();
 		gluQuadricDrawStyle(q, GLU_LINE);
 
-		CCollisionVolume* vol = unit-&gt;unitDef-&gt;collisionVolume;
+		CollisionVolumeData* data = unit-&gt;collisionVolumeData;
 
-		switch (vol-&gt;GetVolumeType()) {
+		switch (data-&gt;GetVolumeType()) {
 			case COLVOL_TYPE_ELLIPSOID: {
 				// scaled sphere: radius, slices, stacks
-				glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
-				glScalef(vol-&gt;GetHScale(0), vol-&gt;GetHScale(1), vol-&gt;GetHScale(2));
+				glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
+				glScalef(data-&gt;GetHScale(0), data-&gt;GetHScale(1), data-&gt;GetHScale(2));
 				gluSphere(q, 1.0f, 20, 20);
 			} break;
 			case COLVOL_TYPE_CYLINDER: {
@@ -1719,23 +1719,23 @@
 				// (cylinder base is drawn at unit center by default so add offset
 				// by half major axis to visually match the mathematical situation,
 				// height of the cylinder equals the unit's full major axis)
-				switch (vol-&gt;GetPrimaryAxis()) {
+				switch (data-&gt;GetPrimaryAxis()) {
 					case COLVOL_AXIS_X: {
-						glTranslatef(-(vol-&gt;GetHScale(0)), 0.0f, 0.0f);
-						glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
-						glScalef(vol-&gt;GetScale(0), vol-&gt;GetHScale(1), vol-&gt;GetHScale(2));
+						glTranslatef(-(data-&gt;GetHScale(0)), 0.0f, 0.0f);
+						glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
+						glScalef(data-&gt;GetScale(0), data-&gt;GetHScale(1), data-&gt;GetHScale(2));
 						glRotatef( 90.0f, 0.0f, 1.0f, 0.0f);
 					} break;
 					case COLVOL_AXIS_Y: {
-						glTranslatef(0.0f, -(vol-&gt;GetHScale(1)), 0.0f);
-						glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
-						glScalef(vol-&gt;GetHScale(0), vol-&gt;GetScale(1), vol-&gt;GetHScale(2));
+						glTranslatef(0.0f, -(data-&gt;GetHScale(1)), 0.0f);
+						glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
+						glScalef(data-&gt;GetHScale(0), data-&gt;GetScale(1), data-&gt;GetHScale(2));
 						glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);
 					} break;
 					case COLVOL_AXIS_Z: {
-						glTranslatef(0.0f, 0.0f, -(vol-&gt;GetHScale(2)));
-						glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
-						glScalef(vol-&gt;GetHScale(0), vol-&gt;GetHScale(1), vol-&gt;GetScale(2));
+						glTranslatef(0.0f, 0.0f, -(data-&gt;GetHScale(2)));
+						glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
+						glScalef(data-&gt;GetHScale(0), data-&gt;GetHScale(1), data-&gt;GetScale(2));
 					} break;
 				}
 
@@ -1743,8 +1743,8 @@
 			} break;
 			case COLVOL_TYPE_BOX: {
 				// scaled cube: length, width, height
-				glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
-				glScalef(vol-&gt;GetScale(0), vol-&gt;GetScale(1), vol-&gt;GetScale(2));
+				glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
+				glScalef(data-&gt;GetScale(0), data-&gt;GetScale(1), data-&gt;GetScale(2));
 				gluMyCube(1.0f);
 			} break;
 		}

Modified: trunk/rts/Sim/Features/Feature.cpp
===================================================================
--- trunk/rts/Sim/Features/Feature.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Features/Feature.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -14,7 +14,7 @@
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
-#include &quot;Sim/Misc/CollisionVolume.h&quot;
+#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
 #include &quot;Sim/Projectiles/FireProjectile.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.h&quot;
@@ -54,6 +54,7 @@
 
 CFeature::CFeature()
 :	def(0),
+	collisionVolumeData(0),
 	inUpdateQue(false),
 	reclaimLeft(1),
 	fireTime(0),
@@ -80,21 +81,25 @@
 
 CFeature::~CFeature(void)
 {
-	if(blocking){
+	if (blocking) {
 		UnBlock();
 	}
+
 	qf-&gt;RemoveFeature(this);
-	if(def-&gt;drawType==DRAWTYPE_TREE)
+
+	if (def-&gt;drawType == DRAWTYPE_TREE)
 		treeDrawer-&gt;DeleteTree(pos);
 
-	if(myFire){
+	if (myFire) {
 		myFire-&gt;StopFire();
-		myFire=0;
+		myFire = 0;
 	}
 
 	if (def-&gt;geoThermal) {
 		CGeoThermSmokeProjectile::GeoThermDestroyed(this);
 	}
+
+	delete collisionVolumeData; collisionVolumeData = NULL;
 }
 
 void CFeature::PostLoad()
@@ -162,21 +167,30 @@
 		SetRadius(model-&gt;radius);
 		midPos = pos + model-&gt;relMidPos;
 
+		// copy the FeatureDef volume archetype data
+		collisionVolumeData = SAFE_NEW CollisionVolumeData();
+		collisionVolumeData-&gt;Copy(def-&gt;collisionVolumeData);
+
 		// CFeatureHandler left this volume's axis-scales uninitialized
-		if (def-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_X) &lt; 0.01f &amp;&amp;
-			def-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Y) &lt; 0.01f &amp;&amp;
-			def-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Z) &lt; 0.01f) {
-			def-&gt;collisionVolume-&gt;SetDefaultScale(model-&gt;radius);
+		// (ie. no &quot;collisionVolumeScales&quot; tag was defined in FeatureDef)
+		if (collisionVolumeData-&gt;GetScale(COLVOL_AXIS_X) &lt; 0.01f &amp;&amp;
+			collisionVolumeData-&gt;GetScale(COLVOL_AXIS_Y) &lt; 0.01f &amp;&amp;
+			collisionVolumeData-&gt;GetScale(COLVOL_AXIS_Z) &lt; 0.01f) {
+			collisionVolumeData-&gt;SetDefaultScale(model-&gt;radius);
 		}
 	}
 	else if (def-&gt;drawType == DRAWTYPE_TREE) {
 		SetRadius(TREE_RADIUS);
 		midPos = pos + (UpVector * TREE_RADIUS);
 		height = 2 * TREE_RADIUS;
-		def-&gt;collisionVolume-&gt;SetDefaultScale(TREE_RADIUS);
+
+		// copy the FeatureDef volume archetype data
+		collisionVolumeData = SAFE_NEW CollisionVolumeData();
+		collisionVolumeData-&gt;Copy(def-&gt;collisionVolumeData);
+		collisionVolumeData-&gt;SetDefaultScale(TREE_RADIUS);
 	}
 	else {
-		// geothermal
+		// geothermal (no collision volume)
 		SetRadius(0.0f);
 		midPos = pos;
 	}

Modified: trunk/rts/Sim/Features/Feature.h
===================================================================
--- trunk/rts/Sim/Features/Feature.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Features/Feature.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -15,6 +15,7 @@
 class CUnit;
 struct DamageArray;
 class CFireProjectile;
+struct CollisionVolumeData;
 
 class CFeature : public CSolidObject, public boost::noncopyable
 {
@@ -66,6 +67,7 @@
 
 	const FeatureDef* def;
 	std::string defName;
+	CollisionVolumeData* collisionVolumeData;
 
 	CMatrix44f transMatrix;
 //	float3 residualImpulse;	//impulse energy that havent been acted on

Modified: trunk/rts/Sim/Features/FeatureDef.h
===================================================================
--- trunk/rts/Sim/Features/FeatureDef.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Features/FeatureDef.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -6,7 +6,7 @@
 #define DRAWTYPE_NONE -1
 
 struct S3DOModel;
-class CCollisionVolume;
+struct CollisionVolumeData;
 
 struct FeatureDef
 {
@@ -20,7 +20,7 @@
 		xsize(0), ysize(0), reclaimTime(0) {}
 
 	S3DOModel* LoadModel(int team) const;
-	CCollisionVolume* collisionVolume;
+	CollisionVolumeData* collisionVolumeData;
 
 	std::string myName;
 	std::string description;

Modified: trunk/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- trunk/rts/Sim/Features/FeatureHandler.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Features/FeatureHandler.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -22,7 +22,7 @@
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
-#include &quot;Sim/Misc/CollisionVolume.h&quot;
+#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/BuilderCAI.h&quot;
 #include &quot;System/TimeProfiler.h&quot;
@@ -131,9 +131,10 @@
 	for (CFeatureSet::iterator fi = activeFeatures.begin(); fi != activeFeatures.end(); ++fi) {
 		// unsavory, but better than a memleak
 		FeatureDef* fd = (FeatureDef*) (*fi)-&gt;def;
-		if (fd-&gt;collisionVolume) {
-			delete fd-&gt;collisionVolume;
-			fd-&gt;collisionVolume = 0;
+
+		if (fd-&gt;collisionVolumeData) {
+			delete fd-&gt;collisionVolumeData;
+			fd-&gt;collisionVolumeData = 0;
 		}
 
 		delete *fi;
@@ -145,9 +146,10 @@
 		std::map&lt;std::string, const FeatureDef*&gt;::iterator fi = featureDefs.begin();
 
 		FeatureDef* fd = (FeatureDef*) fi-&gt;second;
-		if (fd-&gt;collisionVolume) {
-			delete fd-&gt;collisionVolume;
-			fd-&gt;collisionVolume = 0;
+
+		if (fd-&gt;collisionVolumeData) {
+			delete fd-&gt;collisionVolumeData;
+			fd-&gt;collisionVolumeData = 0;
 		}
 
 		delete fi-&gt;second;
@@ -245,8 +247,9 @@
 	fd-&gt;collisionVolumeOffsets = fdTable.GetFloat3(&quot;collisionVolumeOffsets&quot;, ZeroVector);
 	fd-&gt;collisionVolumeTest = fdTable.GetInt(&quot;collisionVolumeTest&quot;, COLVOL_TEST_CONT);
 
-	// initialize the (per-featuredef) collision-volume
-	fd-&gt;collisionVolume = SAFE_NEW CCollisionVolume(fd-&gt;collisionVolumeType,
+	// initialize the (per-featuredef) collision-volume,
+	// all CFeature instances hold a copy of this object
+	fd-&gt;collisionVolumeData = SAFE_NEW CollisionVolumeData(fd-&gt;collisionVolumeType,
 		fd-&gt;collisionVolumeScales, fd-&gt;collisionVolumeOffsets, fd-&gt;collisionVolumeTest);
 
 
@@ -318,8 +321,8 @@
 			fd-&gt;myName = name;
 			fd-&gt;description = &quot;Tree&quot;;
 			fd-&gt;mass = 20;
-			// trees by default have spheres of fixed radius (TREE_RADIUS)
-			fd-&gt;collisionVolume = SAFE_NEW CCollisionVolume(&quot;&quot;, ZeroVector, ZeroVector, COLVOL_TEST_DISC);
+			// trees by default have spherical collision volumes of fixed radius &lt;TREE_RADIUS&gt;
+			fd-&gt;collisionVolumeData = SAFE_NEW CollisionVolumeData(&quot;&quot;, ZeroVector, ZeroVector, COLVOL_TEST_DISC);
 			AddFeatureDef(name, fd);
 		}
 		else if (name.find(&quot;geovent&quot;) != string::npos) {
@@ -341,7 +344,7 @@
 			fd-&gt;myName = name;
 			fd-&gt;mass = 100000;
 			// geothermals have no collision volume at all
-			fd-&gt;collisionVolume = 0;
+			fd-&gt;collisionVolumeData = 0;
 			AddFeatureDef(name, fd);
 		}
 		else {

Added: trunk/rts/Sim/Misc/CollisionHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/CollisionHandler.cpp	                        (rev 0)
+++ trunk/rts/Sim/Misc/CollisionHandler.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -0,0 +1,611 @@
+#include &lt;iostream&gt;
+
+#include &quot;System/float3.h&quot;
+#include &quot;System/Matrix44f.h&quot;
+
+#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sim/Features/Feature.h&quot;
+
+#include &quot;CollisionHandler.h&quot;
+#include &quot;CollisionVolumeData.h&quot;
+
+#define ZVec ZeroVector
+
+CR_BIND(CCollisionHandler, );
+CR_BIND(CollisionVolumeData, );
+	CR_REG_METADATA(CollisionVolumeData, (
+		CR_MEMBER(axisScales),
+		CR_MEMBER(axisHScales),
+		CR_MEMBER(axisHScalesSq),
+		CR_MEMBER(axisHIScales),
+		CR_MEMBER(axisOffsets),
+		CR_MEMBER(volumeBoundingRadius),
+		CR_MEMBER(volumeBoundingRadiusSq),
+		CR_MEMBER(volumeType),
+		CR_MEMBER(testType),
+		CR_MEMBER(primaryAxis),
+		CR_MEMBER(secondaryAxes),
+		CR_MEMBER(spherical)
+	));
+
+unsigned int CCollisionHandler::numCollisionTests = 0;
+unsigned int CCollisionHandler::numIntersectionTests = 0;
+
+
+
+bool CCollisionHandler::DetectHit(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	bool r = false;
+
+	switch (u-&gt;collisionVolumeData-&gt;testType) {
+		// Collision(CUnit*) does not need p1 or q
+		case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(u, p0       ); numCollisionTests    += 1; } break;
+		case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(u, p0, p1, q); numIntersectionTests += 1; } break;
+	}
+
+	return r;
+}
+
+bool CCollisionHandler::DetectHit(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	bool r = false;
+
+	switch (f-&gt;collisionVolumeData-&gt;testType) {
+		// Collision(CFeature*) does not need p1 or q
+		case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(f, p0       ); numCollisionTests    += 1; } break;
+		case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(f, p0, p1, q); numIntersectionTests += 1; } break;
+	}
+
+	return r;
+}
+
+
+
+
+
+
+bool CCollisionHandler::Collision(const CUnit* u, const float3&amp; p)
+{
+	const CollisionVolumeData* d = u-&gt;collisionVolumeData;
+
+	if ((u-&gt;midPos - p).SqLength() &gt; d-&gt;volumeBoundingRadiusSq) {
+		return false;
+	} else {
+		if (d-&gt;spherical) {
+			return true;
+		} else {
+			// NOTE: we have to translate by relMidPos (which is where
+			// collision volume gets drawn) since GetTransformMatrix()
+			// does not
+			CMatrix44f m;
+			u-&gt;GetTransformMatrix(m);
+			m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
+			m.Translate(d-&gt;axisOffsets.x, d-&gt;axisOffsets.y, d-&gt;axisOffsets.z);
+
+			return CCollisionHandler::Collision(d, m, p);
+		}
+	}
+}
+
+bool CCollisionHandler::Collision(const CFeature* f, const float3&amp; p)
+{
+	const CollisionVolumeData* d = f-&gt;collisionVolumeData;
+
+	if ((f-&gt;midPos - p).SqLength() &gt; d-&gt;volumeBoundingRadiusSq) {
+		return false;
+	} else {
+		if (d-&gt;spherical) {
+			return true;
+		} else {
+			// NOTE: CFeature does not have a relMidPos member
+			CMatrix44f m(f-&gt;transMatrix);
+			m.Translate(d-&gt;axisOffsets.x, d-&gt;axisOffsets.y, d-&gt;axisOffsets.z);
+
+			return CCollisionHandler::Collision(d, m, p);
+		}
+	}
+}
+
+
+
+// test if point &lt;p&gt; (in world-coors) lies inside the
+// volume whose transformation matrix is given by &lt;m&gt;
+bool CCollisionHandler::Collision(const CollisionVolumeData* d, const CMatrix44f&amp; m, const float3&amp; p)
+{
+	// get the inverse volume transformation matrix and
+	// apply it to the projectile's position, then test
+	// if the transformed position lies within the axis-
+	// aligned collision volume
+	CMatrix44f mInv = m.Invert();
+	float3 pi = mInv.Mul(p);
+	bool hit = false;
+
+	switch (d-&gt;volumeType) {
+		case COLVOL_TYPE_ELLIPSOID: {
+			if (d-&gt;spherical) {
+				hit = (pi.dot(pi) &lt;= d-&gt;axisHScalesSq.x);
+			} else {
+				const float f1 = (pi.x * pi.x) / d-&gt;axisHScalesSq.x;
+				const float f2 = (pi.y * pi.y) / d-&gt;axisHScalesSq.y;
+				const float f3 = (pi.z * pi.z) / d-&gt;axisHScalesSq.z;
+				hit = ((f1 + f2 + f3) &lt;= 1.0f);
+			}
+		} break;
+		case COLVOL_TYPE_CYLINDER: {
+			switch (d-&gt;primaryAxis) {
+				case COLVOL_AXIS_X: {
+					const bool xPass = (pi.x &gt; -d-&gt;axisHScales.x  &amp;&amp;  pi.x &lt; d-&gt;axisHScales.x);
+					const float yRat = (pi.y * pi.y) / d-&gt;axisHScalesSq.y;
+					const float zRat = (pi.z * pi.z) / d-&gt;axisHScalesSq.z;
+					hit = (xPass &amp;&amp; (yRat + zRat &lt;= 1.0f));
+				} break;
+				case COLVOL_AXIS_Y: {
+					const bool yPass = (pi.y &gt; -d-&gt;axisHScales.y  &amp;&amp;  pi.y &lt; d-&gt;axisHScales.y);
+					const float xRat = (pi.x * pi.x) / d-&gt;axisHScalesSq.x;
+					const float zRat = (pi.z * pi.z) / d-&gt;axisHScalesSq.z;
+					hit = (yPass &amp;&amp; (xRat + zRat &lt;= 1.0f));
+				} break;
+				case COLVOL_AXIS_Z: {
+					const bool zPass = (pi.z &gt; -d-&gt;axisHScales.z  &amp;&amp;  pi.z &lt; d-&gt;axisHScales.z);
+					const float xRat = (pi.x * pi.x) / d-&gt;axisHScalesSq.x;
+					const float yRat = (pi.y * pi.y) / d-&gt;axisHScalesSq.y;
+					hit = (zPass &amp;&amp; (xRat + yRat &lt;= 1.0f));
+				} break;
+			}
+		} break;
+		case COLVOL_TYPE_BOX: {
+			const bool b1 = (pi.x &gt; -d-&gt;axisHScales.x  &amp;&amp;  pi.x &lt; d-&gt;axisHScales.x);
+			const bool b2 = (pi.y &gt; -d-&gt;axisHScales.y  &amp;&amp;  pi.y &lt; d-&gt;axisHScales.y);
+			const bool b3 = (pi.z &gt; -d-&gt;axisHScales.z  &amp;&amp;  pi.z &lt; d-&gt;axisHScales.z);
+			hit = (b1 &amp;&amp; b2 &amp;&amp; b3);
+		} break;
+	}
+
+	return hit;
+}
+
+
+
+
+
+
+bool CCollisionHandler::Intersect(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	const CollisionVolumeData* d = u-&gt;collisionVolumeData;
+
+	CMatrix44f m;
+	u-&gt;GetTransformMatrix(m);
+	m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
+	m.Translate(d-&gt;axisOffsets.x, d-&gt;axisOffsets.y, d-&gt;axisOffsets.z);
+
+	return CCollisionHandler::Intersect(d, m, p0, p1, q);
+}
+
+bool CCollisionHandler::Intersect(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	const CollisionVolumeData* d = f-&gt;collisionVolumeData;
+
+	CMatrix44f m(f-&gt;transMatrix);
+	m.Translate(d-&gt;axisOffsets.x, d-&gt;axisOffsets.y, d-&gt;axisOffsets.z);
+
+	return CCollisionHandler::Intersect(d, m, p0, p1, q);
+}
+
+/*
+bool CCollisionHandler::IntersectAlt(const collisionVolumeData* d, const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery*)
+{
+	// alternative numerical integration method (unused)
+	const float delta = 1.0f;
+	const float length = (p1 - p0).Length();
+	const float3 dir = (p1 - p0).Normalize();
+
+	for (float t = 0.0f; t &lt;= length; t += delta) {
+		if (::Collision(d, m, p0 + dir * t)) return true;
+	}
+
+	return false;
+}
+*/
+
+
+
+// test if ray from &lt;p0&gt; to &lt;p1&gt; (in world-coors) intersects
+// the volume whose transformation matrix is given by &lt;m&gt;
+bool CCollisionHandler::Intersect(const CollisionVolumeData* d, const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+{
+	CMatrix44f mInv = m.Invert();
+	const float3 pi0 = mInv.Mul(p0);
+	const float3 pi1 = mInv.Mul(p1);
+	bool intersect = false;
+
+	// minimum and maximum (x, y, z) coordinates of transformed ray
+	const float rminx = MIN(pi0.x, pi1.x), rminy = MIN(pi0.y, pi1.y), rminz = MIN(pi0.z, pi1.z);
+	const float rmaxx = MAX(pi0.x, pi1.x), rmaxy = MAX(pi0.y, pi1.y), rmaxz = MAX(pi0.z, pi1.z);
+
+	// minimum and maximum (x, y, z) coordinates of (bounding box around) volume
+	const float vminx = -d-&gt;axisHScales.x, vminy = -d-&gt;axisHScales.y, vminz = -d-&gt;axisHScales.z;
+	const float vmaxx =  d-&gt;axisHScales.x, vmaxy =  d-&gt;axisHScales.y, vmaxz =  d-&gt;axisHScales.z;
+
+	// check if ray segment misses (bounding box around) volume
+	// (if so, then no further intersection tests are necessary)
+	if (rmaxx &lt; vminx || rminx &gt; vmaxx) { return false; }
+	if (rmaxy &lt; vminy || rminy &gt; vmaxy) { return false; }
+	if (rmaxz &lt; vminz || rminz &gt; vmaxz) { return false; }
+
+	switch (d-&gt;volumeType) {
+		case COLVOL_TYPE_ELLIPSOID: {
+			intersect = CCollisionHandler::IntersectEllipsoid(d, pi0, pi1, q);
+		} break;
+		case COLVOL_TYPE_CYLINDER: {
+			intersect = CCollisionHandler::IntersectCylinder(d, pi0, pi1, q);
+		} break;
+		case COLVOL_TYPE_BOX: {
+			intersect = CCollisionHandler::IntersectBox(d, pi0, pi1, q);
+		} break;
+	}
+
+	return intersect;
+}
+
+bool CCollisionHandler::IntersectEllipsoid(const CollisionVolumeData* d, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+{
+	// transform the volume-space points into (unit) sphere-space (requires fewer
+	// float-ops than solving the surface equation for arbitrary ellipsoid volumes)
+	const float3 pii0 = float3(pi0.x * d-&gt;axisHIScales.x, pi0.y * d-&gt;axisHIScales.y, pi0.z * d-&gt;axisHIScales.z);
+	const float3 pii1 = float3(pi1.x * d-&gt;axisHIScales.x, pi1.y * d-&gt;axisHIScales.y, pi1.z * d-&gt;axisHIScales.z);
+	const float rSq = 1.0f;
+
+	if (pii0.dot(pii0) &lt;= rSq /* &amp;&amp; pii1.dot(pii1) &lt;= rSq */) {
+		// terminate early in the special case
+		// that shot originated within volume
+		if (q) {
+			q-&gt;b0 = true; q-&gt;b1 = true;
+			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
+			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
+		}
+		return true;
+	}
+
+	// get the ray direction in unit-sphere space
+	const float3 dir = (pii1 - pii0).Normalize();
+
+	// solves [ x^2 + y^2 + z^2 == r^2 ] for t
+	// (&lt;A&gt; represents dir.dot(dir), equal to 1
+	// since ray direction already normalized)
+	const float A = 1.0f;
+	const float B = (pii0 * 2.0f).dot(dir);
+	const float C = pii0.dot(pii0) - rSq;
+	const float D = (B * B) - (4.0f * A * C);
+
+	if (D &lt; -EPS) {
+		return false;
+	} else {
+		// get the length of the ray segment in volume-space
+		const float segLenSq = (pi1 - pi0).SqLength();
+
+		if (D &lt; EPS) {
+			// one solution for t
+			const float t0 = -B * 0.5f;
+			// const float t0 = -B / (2.0f * A);
+			// get the intersection point in sphere-space
+			const float3 pTmp = pii0 + (dir * t0);
+			// get the intersection point in volume-space
+			const float3 p0(pTmp.x * d-&gt;axisHScales.x, pTmp.y * d-&gt;axisHScales.y, pTmp.z * d-&gt;axisHScales.z);
+			// get the distance from the start of the segment
+			// to the intersection point in volume-space
+			const float dSq0 = (p0 - pi0).SqLength();
+			// if the intersection point is closer to p0 than
+			// the end of the ray segment, the hit is valid
+			const bool b0 = (t0 &gt; 0.0f &amp;&amp; dSq0 &lt;= segLenSq);
+
+			if (q) {
+				q-&gt;b0 = b0; q-&gt;b1 = false;
+				q-&gt;t0 = t0; q-&gt;t1 = 0.0f;
+				q-&gt;p0 = p0; q-&gt;p1 = ZVec;
+			}
+
+			return b0;
+		} else {
+			// two solutions for t
+			const float rD = sqrt(D);
+			const float t0 = (-B + rD) * 0.5f;
+			const float t1 = (-B - rD) * 0.5f;
+			// const float t0 = (-B + rD) / (2.0f * A);
+			// const float t1 = (-B - rD) / (2.0f * A);
+			// get the intersection points in sphere-space
+			const float3 pTmp0 = pii0 + (dir * t0);
+			const float3 pTmp1 = pii0 + (dir * t1);
+			// get the intersection points in volume-space
+			const float3 p0(pTmp0.x * d-&gt;axisHScales.x, pTmp0.y * d-&gt;axisHScales.y, pTmp0.z * d-&gt;axisHScales.z);
+			const float3 p1(pTmp1.x * d-&gt;axisHScales.x, pTmp1.y * d-&gt;axisHScales.y, pTmp1.z * d-&gt;axisHScales.z);
+			// get the distances from the start of the ray
+			// to the intersection points in volume-space
+			const float dSq0 = (p0 - pi0).SqLength();
+			const float dSq1 = (p1 - pi0).SqLength();
+			// if one of the intersection points is closer to p0
+			// than the end of the ray segment, the hit is valid
+			const bool b0 = (t0 &gt; 0.0f &amp;&amp; dSq0 &lt;= segLenSq);
+			const bool b1 = (t1 &gt; 0.0f &amp;&amp; dSq1 &lt;= segLenSq);
+
+			if (q) {
+				q-&gt;b0 = b0; q-&gt;b1 = b1;
+				q-&gt;t0 = t0; q-&gt;t1 = t1;
+				q-&gt;p0 = p0; q-&gt;p1 = p1;
+			}
+
+			return (b0 || b1);
+		}
+	}
+}
+
+bool CCollisionHandler::IntersectCylinder(const CollisionVolumeData* d, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+{
+	// get the ray direction in volume space
+	const float3 dir = (pi1 - pi0).Normalize();
+
+	// end-cap plane normals
+	float3 n0;
+	float3 n1;
+
+	// pi0 transformed to unit-cylinder space
+	float3 pii0;
+	bool pass = false;
+
+	// pi0.dot(pi0), pi0.dot(dir), dir.dot(dir)
+	const float pxSq = pi0.x * pi0.x, pxdx = pi0.x * dir.x, dxSq = dir.x * dir.x;
+	const float pySq = pi0.y * pi0.y, pydy = pi0.y * dir.y, dySq = dir.y * dir.y;
+	const float pzSq = pi0.z * pi0.z, pzdz = pi0.z * dir.z, dzSq = dir.z * dir.z;
+	const float saSq = d-&gt;axisHScalesSq.x;
+	const float sbSq = d-&gt;axisHScalesSq.y;
+	const float scSq = d-&gt;axisHScalesSq.z;
+
+	float A = 0.0f, B = 0.0f, C = 0.0f;
+
+	switch (d-&gt;primaryAxis) {
+		case COLVOL_AXIS_X: {
+			// see if start of ray lies between end-caps
+			pass = (pi0.x &gt; -d-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; d-&gt;axisHScales.x);
+			pii0 = float3(pi0.x, pi0.y * d-&gt;axisHIScales.y, pi0.z * d-&gt;axisHIScales.z);
+
+			n0 = float3( 1.0f, 0.0f, 0.0f);
+			n1 = float3(-1.0f, 0.0f, 0.0f);
+
+			// get the parameters for the (2D)
+			// yz-plane ellipse surface equation
+			A = (dySq / sbSq) + (dzSq / scSq);
+			B = ((2.0f * pydy) / sbSq) + ((2.0f * pzdz) / scSq);
+			C = (pySq / sbSq) + (pzSq / scSq) - 1.0f;
+		} break;
+		case COLVOL_AXIS_Y: {
+			// see if start of ray lies between end-caps
+			pass = (pi0.y &gt; -d-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; d-&gt;axisHScales.y);
+			pii0 = float3(pi0.x * d-&gt;axisHIScales.x, pi0.y, pi0.z * d-&gt;axisHIScales.z);
+
+			n0 = float3(0.0f,  1.0f, 0.0f);
+			n1 = float3(0.0f, -1.0f, 0.0f);
+
+			// get the parameters for the (2D)
+			// xz-plane ellipse surface equation
+			A = (dxSq / saSq) + (dzSq / scSq);
+			B = ((2.0f * pxdx) / saSq) + ((2.0f * pzdz) / scSq);
+			C = (pxSq / saSq) + (pzSq / scSq) - 1.0f;
+		} break;
+		case COLVOL_AXIS_Z: {
+			// see if start of ray lies between end-caps
+			pass = (pi0.z &gt; -d-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; d-&gt;axisHScales.z);
+			pii0 = float3(pi0.x * d-&gt;axisHIScales.x, pi0.y * d-&gt;axisHIScales.y, pi0.z);
+
+			n0 = float3(0.0f, 0.0f,  1.0f);
+			n1 = float3(0.0f, 0.0f, -1.0f);
+
+			// get the parameters for the (2D)
+			// xy-plane ellipse surface equation
+			A = (dxSq / saSq) + (dySq / sbSq);
+			B = ((2.0f * pxdx) / saSq) + ((2.0f * pydy) / sbSq);
+			C = (pxSq / saSq) + (pySq / sbSq) - 1.0f;
+		} break;
+	}
+
+	if (pass &amp;&amp; pii0.dot(pii0) &lt;= 1.0f) {
+		// terminate early in the special case
+		// that shot originated within volume
+		if (q) {
+			q-&gt;b0 = true; q-&gt;b1 = true;
+			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
+			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
+		}
+		return true;
+	}
+
+	const int pAx = d-&gt;primaryAxis;
+	const int sAx0 = d-&gt;secondaryAxes[0];
+	const int sAx1 = d-&gt;secondaryAxes[1];
+	const float D = (B * B) - (4.0f * A * C);
+
+	if (D &lt; -EPS) {
+		return false;
+	} else {
+		// get the length of the ray segment in volume-space
+		const float segLenSq = (pi1 - pi0).SqLength();
+
+		float3 p0; float t0 = 0.0f, r0 = 0.0f, dSq0 = 0.0f; bool b0 = false;
+		float3 p1; float t1 = 0.0f, r1 = 0.0f, dSq1 = 0.0f; bool b1 = false;
+
+		if (D &lt; EPS) {
+			// one solution for t
+			t0 = -D / (2.0f * A); p0 = pi0 + (dir * t0);
+
+			if (p0[pAx] &gt; -d-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; d-&gt;axisHScales[pAx]) {
+				// intersection point &lt;p0&gt; falls between cylinder
+				// caps, check if it also lies on our ray segment
+				dSq0 = (p0 - pi0).SqLength();
+				b0 = (/* t0 &gt; 0.0f &amp;&amp; */ dSq0 &lt;= segLenSq);
+			} else {
+				// &lt;p&gt; does not fall between end-caps but ray
+				// segment might still intersect one, so test
+				// for intersection against the cap planes
+				t0 = -(n0.dot(pi0) + d-&gt;axisHScales[pAx]) / n0.dot(dir); p0 = pi0 + (dir * t0);
+				t1 = -(n1.dot(pi0) - d-&gt;axisHScales[pAx]) / n1.dot(dir); p1 = pi0 + (dir * t1);
+				r0 = (((p0[sAx0] * p0[sAx0]) / d-&gt;axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / d-&gt;axisHScalesSq[sAx1]));
+				r1 = (((p1[sAx0] * p1[sAx0]) / d-&gt;axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / d-&gt;axisHScalesSq[sAx1]));
+				b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f);
+				b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f);
+			}
+		} else {
+			// two solutions for t
+			const float rD = sqrt(D);
+			t0 = (-B + rD) / (2.0f * A); p0 = pi0 + (dir * t0);
+			t1 = (-B - rD) / (2.0f * A); p1 = pi0 + (dir * t1);
+
+			// test the 1st intersection point
+			// along the cylinder's major axis
+			if (p0[pAx] &gt; -d-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; d-&gt;axisHScales[pAx]) {
+				// intersection point &lt;p0&gt; falls between cylinder
+				// caps, check if it also lies on our ray segment
+				dSq0 = (p0 - pi0).SqLength();
+				b0 = (/* t0 &gt; 0.0f &amp;&amp; */ dSq0 &lt;= segLenSq);
+			}
+
+			// test the 2nd intersection point
+			// along the cylinder's major axis
+			if (p1[pAx] &gt; -d-&gt;axisHScales[pAx]  &amp;&amp;  p1[pAx] &lt; d-&gt;axisHScales[pAx]) {
+				// intersection point &lt;p1&gt; falls between cylinder
+				// caps, check if it also lies on our ray segment
+				dSq1 = (p1 - pi0).SqLength();
+				b1 = (/* t1 &gt; 0.0f &amp;&amp; */ dSq1 &lt;= segLenSq);
+			}
+		}
+
+		if (!b0 &amp;&amp; !b1) {
+			// neither p0 nor p1 lies on ray segment (or falls between
+			// the cylinder end-caps) but segment might still intersect
+			// a cap, so do extra test for intersection against the cap
+			// planes
+			// NOTE: DIV0 if normal and dir are orthogonal?
+			t0 = -(n0.dot(pi0) + d-&gt;axisHScales[pAx]) / n0.dot(dir);
+			t1 = -(n1.dot(pi0) - d-&gt;axisHScales[pAx]) / n1.dot(dir);
+			p0 = pi0 + (dir * t0); dSq0 = (p0 - pi0).SqLength();
+			p1 = pi0 + (dir * t1); dSq1 = (p1 - pi0).SqLength();
+			r0 = (((p0[sAx0] * p0[sAx0]) / d-&gt;axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / d-&gt;axisHScalesSq[sAx1]));
+			r1 = (((p1[sAx0] * p1[sAx0]) / d-&gt;axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / d-&gt;axisHScalesSq[sAx1]));
+			b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f &amp;&amp; dSq0 &lt;= segLenSq);
+			b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f &amp;&amp; dSq1 &lt;= segLenSq);
+		}
+
+		if (q) {
+			q-&gt;b0 = b0; q-&gt;b1 = b1;
+			q-&gt;t0 = t0; q-&gt;t1 = t1;
+			q-&gt;p0 = p0; q-&gt;p1 = p1;
+		}
+
+		return (b0 || b1);
+	}
+}
+
+bool CCollisionHandler::IntersectBox(const CollisionVolumeData* d, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+{
+	const bool ba = (pi0.x &gt; -d-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; d-&gt;axisHScales.x);
+	const bool bb = (pi0.y &gt; -d-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; d-&gt;axisHScales.y);
+	const bool bc = (pi0.z &gt; -d-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; d-&gt;axisHScales.z);
+
+	if ((ba &amp;&amp; bb &amp;&amp; bc) /* &amp;&amp; (bd &amp;&amp; be &amp;&amp; bf) */) {
+		// terminate early in the special case
+		// that shot originated within volume
+		if (q) {
+			q-&gt;b0 = true; q-&gt;b1 = true;
+			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
+			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
+		}
+		return true;
+	}
+
+	float tn = -9999999.9f;
+	float tf =  9999999.9f;
+	float t0 =  0.0f;
+	float t1 =  0.0f;
+	float t2 =  0.0f;
+
+	const float3 dir = (pi1 - pi0).Normalize();
+
+	if (dir.x &gt; -EPS &amp;&amp; dir.x &lt; EPS) {
+		if (pi0.x &lt; -d-&gt;axisHScales.x  ||  pi0.x &gt; d-&gt;axisHScales.x) {
+			return false;
+		}
+	} else {
+		if (dir.x &gt; 0.0f) {
+			t0 = (-d-&gt;axisHScales.x - pi0.x) / dir.x;
+			t1 = ( d-&gt;axisHScales.x - pi0.x) / dir.x;
+		} else {
+			t1 = (-d-&gt;axisHScales.x - pi0.x) / dir.x;
+			t0 = ( d-&gt;axisHScales.x - pi0.x) / dir.x;
+		}
+
+		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
+		if (t0 &gt; tn) { tn = t0; }
+		if (t1 &lt; tf) { tf = t1; }
+		if (tn &gt; tf) { return false; }
+		if (tf &lt; 0.0f) { return false; }
+	}
+
+	if (dir.y &gt; -EPS &amp;&amp; dir.y &lt; EPS) {
+		if (pi0.y &lt; -d-&gt;axisHScales.y  ||  pi0.y &gt; d-&gt;axisHScales.y) {
+			return false;
+		}
+	} else {
+		if (dir.y &gt; 0.0f) {
+			t0 = (-d-&gt;axisHScales.y - pi0.y) / dir.y;
+			t1 = ( d-&gt;axisHScales.y - pi0.y) / dir.y;
+		} else {
+			t1 = (-d-&gt;axisHScales.y - pi0.y) / dir.y;
+			t0 = ( d-&gt;axisHScales.y - pi0.y) / dir.y;
+		}
+
+		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
+		if (t0 &gt; tn) { tn = t0; }
+		if (t1 &lt; tf) { tf = t1; }
+		if (tn &gt; tf) { return false; }
+		if (tf &lt; 0.0f) { return false; }
+	}
+
+	if (dir.z &gt; -EPS &amp;&amp; dir.z &lt; EPS) {
+		if (pi0.z &lt; -d-&gt;axisHScales.z  ||  pi0.z &gt; d-&gt;axisHScales.z) {
+			return false;
+		}
+	} else {
+		if (dir.z &gt; 0.0f) {
+			t0 = (-d-&gt;axisHScales.z - pi0.z) / dir.z;
+			t1 = ( d-&gt;axisHScales.z - pi0.z) / dir.z;
+		} else {
+			t1 = (-d-&gt;axisHScales.z - pi0.z) / dir.z;
+			t0 = ( d-&gt;axisHScales.z - pi0.z) / dir.z;
+		}
+
+		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
+		if (t0 &gt; tn) { tn = t0; }
+		if (t1 &lt; tf) { tf = t1; }
+		if (tn &gt; tf) { return false; }
+		if (tf &lt; 0.0f) { return false; }
+	}
+
+	// get the intersection points in volume-space
+	const float3 p0 = pi0 + (dir * tn);
+	const float3 p1 = pi0 + (dir * tf);
+	// get the length of the ray segment in volume-space
+	const float segLenSq = (pi1 - pi0).SqLength();
+	// get the distances from the start of the ray
+	// to the intersection points in volume-space
+	const float dSq0 = (p0 - pi0).SqLength();
+	const float dSq1 = (p1 - pi0).SqLength();
+	// if one of the intersection points is closer to p0
+	// than the end of the ray segment, the hit is valid
+	const bool b0 = (dSq0 &lt;= segLenSq);
+	const bool b1 = (dSq1 &lt;= segLenSq);
+
+	if (q) {
+		q-&gt;b0 = b0; q-&gt;b1 = b1;
+		q-&gt;t0 = tn; q-&gt;t1 = tf;
+		q-&gt;p0 = p0; q-&gt;p1 = p1;
+	}
+
+	return (b0 || b1);
+}

Added: trunk/rts/Sim/Misc/CollisionHandler.h
===================================================================
--- trunk/rts/Sim/Misc/CollisionHandler.h	                        (rev 0)
+++ trunk/rts/Sim/Misc/CollisionHandler.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -0,0 +1,55 @@
+#ifndef COLLISION_HANDLER_H
+#define COLLISION_HANDLER_H
+
+#include &quot;StdAfx.h&quot;
+#include &quot;creg/creg.h&quot;
+
+struct CollisionVolumeData;
+class CUnit;
+class CFeature;
+
+struct CollisionQuery {
+	CollisionQuery() {
+		// (0, 0, 0) is volume-space center, so
+		// impossible to obtain as actual points
+		// except in the special cases
+		b0 = false; t0 = 0.0f; p0 = ZeroVector;
+		b1 = false; t1 = 0.0f; p1 = ZeroVector;
+	}
+
+	bool b0, b1;
+	float t0, t1;
+	float3 p0, p1;
+};
+
+// responsible for detecting hits between projectiles
+// and world objects (units, features), each WO has a
+// collision volume
+class CCollisionHandler {
+	public:
+		CR_DECLARE(CCollisionHandler)
+
+		CCollisionHandler() {}
+		~CCollisionHandler() {}
+
+		static bool DetectHit(const CUnit*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0);
+		static bool DetectHit(const CFeature*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0);
+
+	private:
+		static bool Collision(const CUnit*, const float3&amp;);
+		static bool Collision(const CFeature*, const float3&amp;);
+		static bool Collision(const CollisionVolumeData*, const CMatrix44f&amp;, const float3&amp;);
+
+		static bool Intersect(const CUnit*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
+		static bool Intersect(const CFeature*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
+		static bool Intersect(const CollisionVolumeData*, const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q);
+
+		static bool IntersectEllipsoid(const CollisionVolumeData*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+		static bool IntersectCylinder(const CollisionVolumeData*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+		static bool IntersectBox(const CollisionVolumeData*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+
+		static unsigned int numCollisionTests;
+		static unsigned int numIntersectionTests;
+};
+
+#endif

Deleted: trunk/rts/Sim/Misc/CollisionVolume.cpp
===================================================================
--- trunk/rts/Sim/Misc/CollisionVolume.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Misc/CollisionVolume.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -1,729 +0,0 @@
-#include &lt;iostream&gt;
-
-#include &quot;System/float3.h&quot;
-#include &quot;System/Matrix44f.h&quot;
-
-#include &quot;Sim/Units/Unit.h&quot;
-#include &quot;Sim/Features/Feature.h&quot;
-
-#include &quot;CollisionVolume.h&quot;
-
-
-#define MIN(a, b) std::min((a), (b))
-#define MAX(a, b) std::max((a), (b))
-// #define MIN (((a) &lt; (b))? (a): (b))
-// #define MAX (((a) &gt; (b))? (a): (b))
-#define EPS 0.001f
-
-
-CR_BIND(CCollisionVolume, );
-CR_REG_METADATA(CCollisionVolume, (
-	CR_MEMBER(axisScales),
-	CR_MEMBER(axisHScales),
-	CR_MEMBER(axisHScalesSq),
-	CR_MEMBER(axisHIScales),
-	CR_MEMBER(axisOffsets),
-	CR_MEMBER(volumeBoundingRadius),
-	CR_MEMBER(volumeBoundingRadiusSq),
-	CR_MEMBER(volumeType),
-	CR_MEMBER(testType),
-	CR_MEMBER(primaryAxis),
-	CR_MEMBER(secondaryAxes),
-	CR_MEMBER(spherical)
-));
-
-
-CCollisionVolume::CCollisionVolume(const std::string&amp; volTypeStr, const float3&amp; volScales, const float3&amp; volOffsets, int tstType)
-{
-	// note: primaryAxis is only relevant for cylinders
-	primaryAxis = COLVOL_AXIS_Z;
-	volumeType = COLVOL_TYPE_ELLIPSOID;
-	testType = tstType;
-
-	if (volTypeStr.size() &gt; 0) {
-		// note: case-sensitivity?
-		if (volTypeStr.find(&quot;Ell&quot;) != std::string::npos) {
-			volumeType = COLVOL_TYPE_ELLIPSOID;
-		}
-
-		if (volTypeStr.find(&quot;Cyl&quot;) != std::string::npos) {
-			volumeType = COLVOL_TYPE_CYLINDER;
-
-			if (volTypeStr.size() == 4) {
-				if (volTypeStr[3] == 'X') { primaryAxis = COLVOL_AXIS_X; }
-				if (volTypeStr[3] == 'Y') { primaryAxis = COLVOL_AXIS_Y; }
-				if (volTypeStr[3] == 'Z') { primaryAxis = COLVOL_AXIS_Z; }
-			}
-		}
-
-		if (volTypeStr.find(&quot;Box&quot;) != std::string::npos) {
-			volumeType = COLVOL_TYPE_BOX;
-		}
-	}
-
-	// set the full-axis lengths
-	axisScales.x = volScales.x;
-	axisScales.y = volScales.y;
-	axisScales.z = volScales.z;
-
-	// set the half-axis lengths and squared lengths
-	axisHScales.x = axisScales.x * 0.5f; axisHScalesSq.x = axisHScales.x * axisHScales.x;
-	axisHScales.y = axisScales.y * 0.5f; axisHScalesSq.y = axisHScales.y * axisHScales.y;
-	axisHScales.z = axisScales.z * 0.5f; axisHScalesSq.z = axisHScales.z * axisHScales.z;
-
-	// set the inverted half-axis lengths
-	axisHIScales.x = 1.0f / axisHScales.x;
-	axisHIScales.y = 1.0f / axisHScales.y;
-	axisHIScales.z = 1.0f / axisHScales.z;
-
-	// set the axis offsets
-	axisOffsets.x = volOffsets.x;
-	axisOffsets.y = volOffsets.y;
-	axisOffsets.z = volOffsets.z;
-
-	// if all axes (or half-axes) are equal in scale, volume is a sphere
-	spherical = ((volumeType == COLVOL_TYPE_ELLIPSOID) &amp;&amp;
-				 (fabsf(axisHScales.x - axisHScales.y) &lt; EPS) &amp;&amp;
-				 (fabsf(axisHScales.y - axisHScales.z) &lt; EPS));
-
-	switch (primaryAxis) {
-		case COLVOL_AXIS_X: {
-			secondaryAxes[0] = COLVOL_AXIS_Y; // (pAx + 1) % 3;
-			secondaryAxes[1] = COLVOL_AXIS_Z; // (pAx + 2) % 3;
-		} break;
-		case COLVOL_AXIS_Y: {
-			secondaryAxes[0] = COLVOL_AXIS_X; // (pAx + 1) % 3;
-			secondaryAxes[1] = COLVOL_AXIS_Z; // (pAx + 2) % 3;
-		} break;
-		case COLVOL_AXIS_Z: {
-			secondaryAxes[0] = COLVOL_AXIS_X; // (pAx + 1) % 3;
-			secondaryAxes[1] = COLVOL_AXIS_Y; // (pAx + 2) % 3;
-		} break;
-	}
-
-	// set the radius of the minimum bounding sphere
-	// that encompasses this custom collision volume
-	// (for early-out testing)
-	switch (volumeType) {
-		case COLVOL_TYPE_BOX: {
-			// would be an over-estimation for cylinders
-			volumeBoundingRadiusSq = axisHScalesSq.x + axisHScalesSq.y + axisHScalesSq.z;
-			volumeBoundingRadius = sqrt(volumeBoundingRadiusSq);
-		} break;
-		case COLVOL_TYPE_CYLINDER: {
-			const float prhs = axisHScales[primaryAxis     ];	// primary axis half-scale
-			const float sahs = axisHScales[secondaryAxes[0]];	// 1st secondary axis half-scale
-			const float sbhs = axisHScales[secondaryAxes[1]];	// 2nd secondary axis half-scale
-			const float mshs = MAX(sahs, sbhs);					// max. secondary axis half-scale
-
-			volumeBoundingRadiusSq = prhs * prhs + mshs * mshs;
-			volumeBoundingRadius = sqrt(volumeBoundingRadiusSq);
-		} break;
-		case COLVOL_TYPE_ELLIPSOID: {
-			if (spherical) {
-				// MAX(x, y, z) would suffice here too
-				volumeBoundingRadius = axisHScales.x;
-			} else {
-				volumeBoundingRadius = MAX(axisHScales.x, MAX(axisHScales.y, axisHScales.z));
-			}
-
-			volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
-		} break;
-	}
-}
-
-// called iif unit or feature defines no custom volume
-void CCollisionVolume::SetDefaultScale(const float s)
-{
-	// &lt;s&gt; is the object's default radius (not its diameter)
-	// so we need to double it to get the full-length scales
-	axisScales.x = s * 2.0f;
-	axisScales.y = s * 2.0f;
-	axisScales.z = s * 2.0f;
-
-	axisHScales.x = s; axisHScalesSq.x = axisHScales.x * axisHScales.x;
-	axisHScales.y = s; axisHScalesSq.y = axisHScales.y * axisHScales.y;
-	axisHScales.z = s; axisHScalesSq.z = axisHScales.z * axisHScales.z;
-
-	axisHIScales.x = 1.0f / axisHScales.x;
-	axisHIScales.y = 1.0f / axisHScales.y;
-	axisHIScales.z = 1.0f / axisHScales.z;
-
-	spherical = true;
-	volumeBoundingRadius = s;
-	volumeBoundingRadiusSq = s * s;
-}
-
-
-
-
-
-
-bool CCollisionVolume::DetectHit(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	bool r = false;
-
-	switch (testType) {
-		// Collision(CUnit*) does not need p1 or q
-		case COLVOL_TEST_DISC: { r = Collision(u, p0       ); } break;
-		case COLVOL_TEST_CONT: { r = Intersect(u, p0, p1, q); } break;
-	}
-
-	return r;
-}
-
-bool CCollisionVolume::DetectHit(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	bool r = false;
-
-	switch (testType) {
-		// Collision(CFeature*) does not need p1 or q
-		case COLVOL_TEST_DISC: { r = Collision(f, p0       ); } break;
-		case COLVOL_TEST_CONT: { r = Intersect(f, p0, p1, q); } break;
-	}
-
-	return r;
-}
-
-
-
-
-
-
-bool CCollisionVolume::Collision(const CUnit* u, const float3&amp; p) const
-{
-	if ((u-&gt;midPos - p).SqLength() &gt; volumeBoundingRadiusSq) {
-		return false;
-	} else {
-		if (spherical) {
-			return true;
-		} else {
-			// NOTE: we have to translate by relMidPos (which is where
-			// collision volume gets drawn) since GetTransformMatrix()
-			// does not
-			CMatrix44f m;
-			u-&gt;GetTransformMatrix(m);
-			m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
-			m.Translate(axisOffsets.x, axisOffsets.y, axisOffsets.z);
-
-			return Collision(m, p);
-		}
-	}
-}
-
-bool CCollisionVolume::Collision(const CFeature* f, const float3&amp; p) const
-{
-	if ((f-&gt;midPos - p).SqLength() &gt; volumeBoundingRadiusSq) {
-		return false;
-	} else {
-		if (spherical) {
-			return true;
-		} else {
-			// NOTE: CFeature does not have a relMidPos member
-			CMatrix44f m(f-&gt;transMatrix);
-			m.Translate(axisOffsets.x, axisOffsets.y, axisOffsets.z);
-
-			return Collision(m, p);
-		}
-	}
-}
-
-
-
-// test if point &lt;p&gt; (in world-coors) lies inside the
-// volume whose transformation matrix is given by &lt;m&gt;
-bool CCollisionVolume::Collision(const CMatrix44f&amp; m, const float3&amp; p) const
-{
-	// get the inverse volume transformation matrix and
-	// apply it to the projectile's position, then test
-	// if the transformed position lies within the axis-
-	// aligned collision volume
-	CMatrix44f mInv = m.Invert();
-	float3 pi = mInv.Mul(p);
-	bool hit = false;
-
-	switch (volumeType) {
-		case COLVOL_TYPE_ELLIPSOID: {
-			if (spherical) {
-				hit = (pi.dot(pi) &lt;= axisHScalesSq.x);
-			} else {
-				const float f1 = (pi.x * pi.x) / axisHScalesSq.x;
-				const float f2 = (pi.y * pi.y) / axisHScalesSq.y;
-				const float f3 = (pi.z * pi.z) / axisHScalesSq.z;
-				hit = ((f1 + f2 + f3) &lt;= 1.0f);
-			}
-		} break;
-		case COLVOL_TYPE_CYLINDER: {
-			switch (primaryAxis) {
-				case COLVOL_AXIS_X: {
-					const bool xPass = (pi.x &gt; -axisHScales.x &amp;&amp; pi.x &lt; axisHScales.x);
-					const float yRat = (pi.y * pi.y) / axisHScalesSq.y;
-					const float zRat = (pi.z * pi.z) / axisHScalesSq.z;
-					hit = (xPass &amp;&amp; (yRat + zRat &lt;= 1.0f));
-				} break;
-				case COLVOL_AXIS_Y: {
-					const bool yPass = (pi.y &gt; -axisHScales.y &amp;&amp; pi.y &lt; axisHScales.y);
-					const float xRat = (pi.x * pi.x) / axisHScalesSq.x;
-					const float zRat = (pi.z * pi.z) / axisHScalesSq.z;
-					hit = (yPass &amp;&amp; (xRat + zRat &lt;= 1.0f));
-				} break;
-				case COLVOL_AXIS_Z: {
-					const bool zPass = (pi.z &gt; -axisHScales.z &amp;&amp; pi.z &lt; axisHScales.z);
-					const float xRat = (pi.x * pi.x) / axisHScalesSq.x;
-					const float yRat = (pi.y * pi.y) / axisHScalesSq.y;
-					hit = (zPass &amp;&amp; (xRat + yRat &lt;= 1.0f));
-				} break;
-			}
-		} break;
-		case COLVOL_TYPE_BOX: {
-			const bool b1 = (pi.x &gt; -axisHScales.x &amp;&amp; pi.x &lt; axisHScales.x);
-			const bool b2 = (pi.y &gt; -axisHScales.y &amp;&amp; pi.y &lt; axisHScales.y);
-			const bool b3 = (pi.z &gt; -axisHScales.z &amp;&amp; pi.z &lt; axisHScales.z);
-			hit = (b1 &amp;&amp; b2 &amp;&amp; b3);
-		} break;
-	}
-
-	return hit;
-}
-
-
-
-
-
-
-bool CCollisionVolume::Intersect(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	CMatrix44f m;
-	u-&gt;GetTransformMatrix(m);
-	m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
-	m.Translate(axisOffsets.x, axisOffsets.y, axisOffsets.z);
-
-	return Intersect(m, p0, p1, q);
-}
-
-bool CCollisionVolume::Intersect(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	CMatrix44f m(f-&gt;transMatrix);
-	m.Translate(axisOffsets.x, axisOffsets.y, axisOffsets.z);
-
-	return Intersect(m, p0, p1, q);
-}
-
-/*
-bool CCollisionVolume::IntersectAlt(const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery*) const
-{
-	// alternative numerical integration method (unused)
-	const float delta = 1.0f;
-	const float length = (p1 - p0).Length();
-	const float3 dir = (p1 - p0).Normalize();
-
-	for (float t = 0.0f; t &lt;= length; t += delta) {
-		if (Collision(m, p0 + dir * t)) return true;
-	}
-
-	return false;
-}
-*/
-
-
-
-// test if ray from &lt;p0&gt; to &lt;p1&gt; (in world-coors) intersects
-// the volume whose transformation matrix is given by &lt;m&gt;
-bool CCollisionVolume::Intersect(const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q) const
-{
-	CMatrix44f mInv = m.Invert();
-	const float3 pi0 = mInv.Mul(p0);
-	const float3 pi1 = mInv.Mul(p1);
-	bool intersect = false;
-
-	// minimum and maximum (x, y, z) coordinates of transformed ray
-	const float rminx = MIN(pi0.x, pi1.x), rminy = MIN(pi0.y, pi1.y), rminz = MIN(pi0.z, pi1.z);
-	const float rmaxx = MAX(pi0.x, pi1.x), rmaxy = MAX(pi0.y, pi1.y), rmaxz = MAX(pi0.z, pi1.z);
-
-	// minimum and maximum (x, y, z) coordinates of (bounding box around) volume
-	const float vminx = -axisHScales.x, vminy = -axisHScales.y, vminz = -axisHScales.z;
-	const float vmaxx =  axisHScales.x, vmaxy =  axisHScales.y, vmaxz =  axisHScales.z;
-
-	// check if ray segment misses (bounding box around) volume
-	// (if so, then no further intersection tests are necessary)
-	if (rmaxx &lt; vminx || rminx &gt; vmaxx) { return false; }
-	if (rmaxy &lt; vminy || rminy &gt; vmaxy) { return false; }
-	if (rmaxz &lt; vminz || rminz &gt; vmaxz) { return false; }
-
-	switch (volumeType) {
-		case COLVOL_TYPE_ELLIPSOID: {
-			intersect = IntersectEllipsoid(pi0, pi1, q);
-		} break;
-		case COLVOL_TYPE_CYLINDER: {
-			intersect = IntersectCylinder(pi0, pi1, q);
-		} break;
-		case COLVOL_TYPE_BOX: {
-			intersect = IntersectBox(pi0, pi1, q);
-		} break;
-	}
-
-	return intersect;
-}
-
-bool CCollisionVolume::IntersectEllipsoid(const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q) const
-{
-	// transform the volume-space points into (unit) sphere-space (requires fewer
-	// float-ops than solving the surface equation for arbitrary ellipsoid volumes)
-	const float3 pii0 = float3(pi0.x * axisHIScales.x, pi0.y * axisHIScales.y, pi0.z * axisHIScales.z);
-	const float3 pii1 = float3(pi1.x * axisHIScales.x, pi1.y * axisHIScales.y, pi1.z * axisHIScales.z);
-	const float rSq = 1.0f;
-
-	if (pii0.dot(pii0) &lt;= rSq /* &amp;&amp; pii1.dot(pii1) &lt;= rSq */) {
-		// terminate early in the special case
-		// that shot originated within volume
-		if (q) {
-			q-&gt;b0 = true; q-&gt;b1 = true;
-			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
-			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
-		}
-		return true;
-	}
-
-	// get the ray direction in unit-sphere space
-	const float3 dir = (pii1 - pii0).Normalize();
-
-	// solves [ x^2 + y^2 + z^2 == r^2 ] for t
-	// (&lt;A&gt; represents dir.dot(dir), equal to 1
-	// since ray direction already normalized)
-	const float A = 1.0f;
-	const float B = (pii0 * 2.0f).dot(dir);
-	const float C = pii0.dot(pii0) - rSq;
-	const float D = (B * B) - (4.0f * A * C);
-
-	if (D &lt; -EPS) {
-		return false;
-	} else {
-		// get the length of the ray segment in volume-space
-		const float segLenSq = (pi1 - pi0).SqLength();
-
-		if (D &lt; EPS) {
-			// one solution for t
-			const float t0 = -B * 0.5f;
-			// const float t0 = -B / (2.0f * A);
-			// get the intersection point in sphere-space
-			const float3 pTmp = pii0 + (dir * t0);
-			// get the intersection point in volume-space
-			const float3 p0(pTmp.x * axisHScales.x, pTmp.y * axisHScales.y, pTmp.z * axisHScales.z);
-			// get the distance from the start of the segment
-			// to the intersection point in volume-space
-			const float dSq0 = (p0 - pi0).SqLength();
-			// if the intersection point is closer to p0 than
-			// the end of the ray segment, the hit is valid
-			const bool b0 = (t0 &gt; 0.0f &amp;&amp; dSq0 &lt;= segLenSq);
-
-			if (q) {
-				q-&gt;b0 = b0; q-&gt;b1 = false;
-				q-&gt;t0 = t0; q-&gt;t1 = 0.0f;
-				q-&gt;p0 = p0; q-&gt;p1 = ZVec;
-			}
-
-			return b0;
-		} else {
-			// two solutions for t
-			const float rD = sqrt(D);
-			const float t0 = (-B + rD) * 0.5f;
-			const float t1 = (-B - rD) * 0.5f;
-			// const float t0 = (-B + rD) / (2.0f * A);
-			// const float t1 = (-B - rD) / (2.0f * A);
-			// get the intersection points in sphere-space
-			const float3 pTmp0 = pii0 + (dir * t0);
-			const float3 pTmp1 = pii0 + (dir * t1);
-			// get the intersection points in volume-space
-			const float3 p0(pTmp0.x * axisHScales.x, pTmp0.y * axisHScales.y, pTmp0.z * axisHScales.z);
-			const float3 p1(pTmp1.x * axisHScales.x, pTmp1.y * axisHScales.y, pTmp1.z * axisHScales.z);
-			// get the distances from the start of the ray
-			// to the intersection points in volume-space
-			const float dSq0 = (p0 - pi0).SqLength();
-			const float dSq1 = (p1 - pi0).SqLength();
-			// if one of the intersection points is closer to p0
-			// than the end of the ray segment, the hit is valid
-			const bool b0 = (t0 &gt; 0.0f &amp;&amp; dSq0 &lt;= segLenSq);
-			const bool b1 = (t1 &gt; 0.0f &amp;&amp; dSq1 &lt;= segLenSq);
-
-			if (q) {
-				q-&gt;b0 = b0; q-&gt;b1 = b1;
-				q-&gt;t0 = t0; q-&gt;t1 = t1;
-				q-&gt;p0 = p0; q-&gt;p1 = p1;
-			}
-
-			return (b0 || b1);
-		}
-	}
-}
-
-bool CCollisionVolume::IntersectCylinder(const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q) const
-{
-	// get the ray direction in volume space
-	const float3 dir = (pi1 - pi0).Normalize();
-
-	// end-cap plane normals
-	float3 n0;
-	float3 n1;
-
-	// pi0 transformed to unit-cylinder space
-	float3 pii0;
-	bool pass;
-
-	// pi0.dot(pi0), pi0.dot(dir), dir.dot(dir)
-	const float pxSq = pi0.x * pi0.x, pxdx = pi0.x * dir.x, dxSq = dir.x * dir.x;
-	const float pySq = pi0.y * pi0.y, pydy = pi0.y * dir.y, dySq = dir.y * dir.y;
-	const float pzSq = pi0.z * pi0.z, pzdz = pi0.z * dir.z, dzSq = dir.z * dir.z;
-	const float saSq = axisHScalesSq.x;
-	const float sbSq = axisHScalesSq.y;
-	const float scSq = axisHScalesSq.z;
-
-	float A = 0.0f, B = 0.0f, C = 0.0f;
-
-	switch (primaryAxis) {
-		case COLVOL_AXIS_X: {
-			// see if start of ray lies between end-caps
-			pass = (pi0.x &gt; -axisHScales.x &amp;&amp; pi0.x &lt; axisHScales.x);
-			pii0 = float3(pi0.x, pi0.y * axisHIScales.y, pi0.z * axisHIScales.z);
-
-			n0 = float3( 1.0f, 0.0f, 0.0f);
-			n1 = float3(-1.0f, 0.0f, 0.0f);
-
-			// get the parameters for the (2D)
-			// yz-plane ellipse surface equation
-			A = (dySq / sbSq) + (dzSq / scSq);
-			B = ((2.0f * pydy) / sbSq) + ((2.0f * pzdz) / scSq);
-			C = (pySq / sbSq) + (pzSq / scSq) - 1.0f;
-		} break;
-		case COLVOL_AXIS_Y: {
-			// see if start of ray lies between end-caps
-			pass = (pi0.y &gt; -axisHScales.y &amp;&amp; pi0.y &lt; axisHScales.y);
-			pii0 = float3(pi0.x * axisHIScales.x, pi0.y, pi0.z * axisHIScales.z);
-
-			n0 = float3(0.0f,  1.0f, 0.0f);
-			n1 = float3(0.0f, -1.0f, 0.0f);
-
-			// get the parameters for the (2D)
-			// xz-plane ellipse surface equation
-			A = (dxSq / saSq) + (dzSq / scSq);
-			B = ((2.0f * pxdx) / saSq) + ((2.0f * pzdz) / scSq);
-			C = (pxSq / saSq) + (pzSq / scSq) - 1.0f;
-		} break;
-		case COLVOL_AXIS_Z: {
-			// see if start of ray lies between end-caps
-			pass = (pi0.z &gt; -axisHScales.z &amp;&amp; pi0.z &lt; axisHScales.z);
-			pii0 = float3(pi0.x * axisHIScales.x, pi0.y * axisHIScales.y, pi0.z);
-
-			n0 = float3(0.0f, 0.0f,  1.0f);
-			n1 = float3(0.0f, 0.0f, -1.0f);
-
-			// get the parameters for the (2D)
-			// xy-plane ellipse surface equation
-			A = (dxSq / saSq) + (dySq / sbSq);
-			B = ((2.0f * pxdx) / saSq) + ((2.0f * pydy) / sbSq);
-			C = (pxSq / saSq) + (pySq / sbSq) - 1.0f;
-		} break;
-	}
-
-	if (pass &amp;&amp; pii0.dot(pii0) &lt;= 1.0f) {
-		// terminate early in the special case
-		// that shot originated within volume
-		if (q) {
-			q-&gt;b0 = true; q-&gt;b1 = true;
-			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
-			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
-		}
-		return true;
-	}
-
-	const int pAx = primaryAxis;
-	const int sAx0 = secondaryAxes[0];
-	const int sAx1 = secondaryAxes[1];
-	const float D = (B * B) - (4.0f * A * C);
-
-	if (D &lt; -EPS) {
-		return false;
-	} else {
-		// get the length of the ray segment in volume-space
-		const float segLenSq = (pi1 - pi0).SqLength();
-
-		float3 p0; float t0 = 0.0f, r0 = 0.0f, dSq0 = 0.0f; bool b0 = false;
-		float3 p1; float t1 = 0.0f, r1 = 0.0f, dSq1 = 0.0f; bool b1 = false;
-
-		if (D &lt; EPS) {
-			// one solution for t
-			t0 = -D / (2.0f * A); p0 = pi0 + (dir * t0);
-
-			if (p0[pAx] &gt; -axisHScales[pAx] &amp;&amp; p0[pAx] &lt; axisHScales[pAx]) {
-				// intersection point &lt;p0&gt; falls between cylinder
-				// caps, check if it also lies on our ray segment
-				dSq0 = (p0 - pi0).SqLength();
-				b0 = (/* t0 &gt; 0.0f &amp;&amp; */ dSq0 &lt;= segLenSq);
-			} else {
-				// &lt;p&gt; does not fall between end-caps but ray
-				// segment might still intersect one, so test
-				// for intersection against the cap planes
-				t0 = -(n0.dot(pi0) + axisHScales[pAx]) / n0.dot(dir); p0 = pi0 + (dir * t0);
-				t1 = -(n1.dot(pi0) - axisHScales[pAx]) / n1.dot(dir); p1 = pi0 + (dir * t1);
-				r0 = (((p0[sAx0] * p0[sAx0]) / axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / axisHScalesSq[sAx1]));
-				r1 = (((p1[sAx0] * p1[sAx0]) / axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / axisHScalesSq[sAx1]));
-				b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f);
-				b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f);
-			}
-		} else {
-			// two solutions for t
-			const float rD = sqrt(D);
-			t0 = (-B + rD) / (2.0f * A); p0 = pi0 + (dir * t0);
-			t1 = (-B - rD) / (2.0f * A); p1 = pi0 + (dir * t1);
-
-			// test the 1st intersection point
-			// along the cylinder's major axis
-			if (p0[pAx] &gt; -axisHScales[pAx] &amp;&amp; p0[pAx] &lt; axisHScales[pAx]) {
-				// intersection point &lt;p0&gt; falls between cylinder
-				// caps, check if it also lies on our ray segment
-				dSq0 = (p0 - pi0).SqLength();
-				b0 = (/* t0 &gt; 0.0f &amp;&amp; */ dSq0 &lt;= segLenSq);
-			}
-
-			// test the 2nd intersection point
-			// along the cylinder's major axis
-			if (p1[pAx] &gt; -axisHScales[pAx] &amp;&amp; p1[pAx] &lt; axisHScales[pAx]) {
-				// intersection point &lt;p1&gt; falls between cylinder
-				// caps, check if it also lies on our ray segment
-				dSq1 = (p1 - pi0).SqLength();
-				b1 = (/* t1 &gt; 0.0f &amp;&amp; */ dSq1 &lt;= segLenSq);
-			}
-		}
-
-		if (!b0 &amp;&amp; !b1) {
-			// neither p0 nor p1 lies on ray segment (or falls between
-			// the cylinder end-caps) but segment might still intersect
-			// a cap, so do extra test for intersection against the cap
-			// planes
-			// NOTE: DIV0 if normal and dir are orthogonal?
-			t0 = -(n0.dot(pi0) + axisHScales[pAx]) / n0.dot(dir);
-			t1 = -(n1.dot(pi0) - axisHScales[pAx]) / n1.dot(dir);
-			p0 = pi0 + (dir * t0); dSq0 = (p0 - pi0).SqLength();
-			p1 = pi0 + (dir * t1); dSq1 = (p1 - pi0).SqLength();
-			r0 = (((p0[sAx0] * p0[sAx0]) / axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / axisHScalesSq[sAx1]));
-			r1 = (((p1[sAx0] * p1[sAx0]) / axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / axisHScalesSq[sAx1]));
-			b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f &amp;&amp; dSq0 &lt;= segLenSq);
-			b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f &amp;&amp; dSq1 &lt;= segLenSq);
-		}
-
-		if (q) {
-			q-&gt;b0 = b0; q-&gt;b1 = b1;
-			q-&gt;t0 = t0; q-&gt;t1 = t1;
-			q-&gt;p0 = p0; q-&gt;p1 = p1;
-		}
-
-		return (b0 || b1);
-	}
-}
-
-bool CCollisionVolume::IntersectBox(const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q) const
-{
-	const bool ba = (pi0.x &gt; -axisHScales.x &amp;&amp; pi0.x &lt; axisHScales.x);
-	const bool bb = (pi0.y &gt; -axisHScales.y &amp;&amp; pi0.y &lt; axisHScales.y);
-	const bool bc = (pi0.z &gt; -axisHScales.z &amp;&amp; pi0.z &lt; axisHScales.z);
-
-	if ((ba &amp;&amp; bb &amp;&amp; bc) /* &amp;&amp; (bd &amp;&amp; be &amp;&amp; bf) */) {
-		// terminate early in the special case
-		// that shot originated within volume
-		if (q) {
-			q-&gt;b0 = true; q-&gt;b1 = true;
-			q-&gt;t0 = 0.0f; q-&gt;t1 = 0.0f;
-			q-&gt;p0 = ZVec; q-&gt;p1 = ZVec;
-		}
-		return true;
-	}
-
-	float tn = -9999999.9f;
-	float tf =  9999999.9f;
-	float t0 =  0.0f;
-	float t1 =  0.0f;
-	float t2 =  0.0f;
-
-	const float3 dir = (pi1 - pi0).Normalize();
-
-	if (dir.x &gt; -EPS &amp;&amp; dir.x &lt; EPS) {
-		if (pi0.x &lt; -axisHScales.x || pi0.x &gt; axisHScales.x) {
-			return false;
-		}
-	} else {
-		if (dir.x &gt; 0.0f) {
-			t0 = (-axisHScales.x - pi0.x) / dir.x;
-			t1 = ( axisHScales.x - pi0.x) / dir.x;
-		} else {
-			t1 = (-axisHScales.x - pi0.x) / dir.x;
-			t0 = ( axisHScales.x - pi0.x) / dir.x;
-		}
-
-		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
-		if (t0 &gt; tn) { tn = t0; }
-		if (t1 &lt; tf) { tf = t1; }
-		if (tn &gt; tf) { return false; }
-		if (tf &lt; 0.0f) { return false; }
-	}
-
-	if (dir.y &gt; -EPS &amp;&amp; dir.y &lt; EPS) {
-		if (pi0.y &lt; -axisHScales.y || pi0.y &gt; axisHScales.y) {
-			return false;
-		}
-	} else {
-		if (dir.y &gt; 0.0f) {
-			t0 = (-axisHScales.y - pi0.y) / dir.y;
-			t1 = ( axisHScales.y - pi0.y) / dir.y;
-		} else {
-			t1 = (-axisHScales.y - pi0.y) / dir.y;
-			t0 = ( axisHScales.y - pi0.y) / dir.y;
-		}
-
-		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
-		if (t0 &gt; tn) { tn = t0; }
-		if (t1 &lt; tf) { tf = t1; }
-		if (tn &gt; tf) { return false; }
-		if (tf &lt; 0.0f) { return false; }
-	}
-
-	if (dir.z &gt; -EPS &amp;&amp; dir.z &lt; EPS) {
-		if (pi0.z &lt; -axisHScales.z || pi0.z &gt; axisHScales.z) {
-			return false;
-		}
-	} else {
-		if (dir.z &gt; 0.0f) {
-			t0 = (-axisHScales.z - pi0.z) / dir.z;
-			t1 = ( axisHScales.z - pi0.z) / dir.z;
-		} else {
-			t1 = (-axisHScales.z - pi0.z) / dir.z;
-			t0 = ( axisHScales.z - pi0.z) / dir.z;
-		}
-
-		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
-		if (t0 &gt; tn) { tn = t0; }
-		if (t1 &lt; tf) { tf = t1; }
-		if (tn &gt; tf) { return false; }
-		if (tf &lt; 0.0f) { return false; }
-	}
-
-	// get the intersection points in volume-space
-	const float3 p0 = pi0 + (dir * tn);
-	const float3 p1 = pi0 + (dir * tf);
-	// get the length of the ray segment in volume-space
-	const float segLenSq = (pi1 - pi0).SqLength();
-	// get the distances from the start of the ray
-	// to the intersection points in volume-space
-	const float dSq0 = (p0 - pi0).SqLength();
-	const float dSq1 = (p1 - pi0).SqLength();
-	// if one of the intersection points is closer to p0
-	// than the end of the ray segment, the hit is valid
-	const bool b0 = (dSq0 &lt;= segLenSq);
-	const bool b1 = (dSq1 &lt;= segLenSq);
-
-	if (q) {
-		q-&gt;b0 = b0; q-&gt;b1 = b1;
-		q-&gt;t0 = tn; q-&gt;t1 = tf;
-		q-&gt;p0 = p0; q-&gt;p1 = p1;
-	}
-
-	return (b0 || b1);
-}

Deleted: trunk/rts/Sim/Misc/CollisionVolume.h
===================================================================
--- trunk/rts/Sim/Misc/CollisionVolume.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Misc/CollisionVolume.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -1,83 +0,0 @@
-#ifndef COLLISION_VOLUME_H
-#define COLLISION_VOLUME_H
-
-#include &quot;StdAfx.h&quot;
-#include &quot;creg/creg.h&quot;
-
-#define ZVec ZeroVector
-
-enum COLVOL_TYPES {COLVOL_TYPE_ELLIPSOID, COLVOL_TYPE_CYLINDER, COLVOL_TYPE_BOX};
-enum COLVOL_AXES {COLVOL_AXIS_X, COLVOL_AXIS_Y, COLVOL_AXIS_Z};
-enum COLVOL_TESTS {COLVOL_TEST_DISC, COLVOL_TEST_CONT};
-
-class CUnit;
-class CFeature;
-
-struct CollisionQuery {
-	CollisionQuery() {
-		// (0, 0, 0) is volume-space center, so
-		// impossible to obtain as actual points
-		// except in the special cases
-		b0 = false; t0 = 0.0f; p0 = ZVec;
-		b1 = false; t1 = 0.0f; p1 = ZVec;
-	}
-
-	bool b0, b1;
-	float t0, t1;
-	float3 p0, p1;
-};
-
-class CCollisionVolume {
-	public:
-		CR_DECLARE(CCollisionVolume)
-
-		CCollisionVolume() {}
-		CCollisionVolume(const std::string&amp;, const float3&amp;, const float3&amp;, int);
-		~CCollisionVolume() {}
-
-		void SetDefaultScale(const float);
-
-		bool DetectHit(const CUnit*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0) const;
-		bool DetectHit(const CFeature*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0) const;
-
-		int GetVolumeType() const { return volumeType; }
-		int GetTestType() const { return testType; }
-		int GetPrimaryAxis() const { return primaryAxis; }
-		float GetBoundingRadius() const { return volumeBoundingRadius; }
-		float GetBoundingRadiusSq() const { return volumeBoundingRadiusSq; }
-		float GetScale(int axis) const { return axisScales[axis]; }
-		float GetHScale(int axis) const { return axisHScales[axis]; }
-		float GetHScaleSq(int axis) const { return axisHScalesSq[axis]; }
-		float GetOffset(int axis) const { return axisOffsets[axis]; }
-		bool IsSphere() const { return spherical; }
-
-	private:
-		bool Collision(const CUnit*, const float3&amp;) const;
-		bool Collision(const CFeature*, const float3&amp;) const;
-		bool Intersect(const CUnit*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q) const;
-		bool Intersect(const CFeature*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q) const;
-
-		bool Collision(const CMatrix44f&amp;, const float3&amp;) const;
-		bool Intersect(const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-		bool IntersectAlt(const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-
-		bool IntersectEllipsoid(const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-		bool IntersectCylinder(const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-		bool IntersectBox(const float3&amp;, const float3&amp;, CollisionQuery* q) const;
-
-		float3 axisScales;					// full-length axis scales
-		float3 axisHScales;					// half-length axis scales
-		float3 axisHScalesSq;				// half-length axis scales (squared)
-		float3 axisHIScales;				// half-length axis scales (inverted)
-		float3 axisOffsets;
-
-		float volumeBoundingRadius;			// radius of minimally-bounding sphere around volume
-		float volumeBoundingRadiusSq;		// squared radius of minimally-bounding sphere
-		int volumeType;
-		int testType;
-		int primaryAxis;
-		int secondaryAxes[2];
-		bool spherical;
-};
-
-#endif

Added: trunk/rts/Sim/Misc/CollisionVolumeData.h
===================================================================
--- trunk/rts/Sim/Misc/CollisionVolumeData.h	                        (rev 0)
+++ trunk/rts/Sim/Misc/CollisionVolumeData.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -0,0 +1,169 @@
+#ifndef COLLISION_VOLUME_DATA_H
+#define COLLISION_VOLUME_DATA_H
+
+#include &quot;StdAfx.h&quot;
+#include &quot;creg/creg.h&quot;
+
+#define EPS 0.001f
+#define MIN(a, b) std::min((a), (b))
+#define MAX(a, b) std::max((a), (b))
+
+enum COLVOL_TYPES {COLVOL_TYPE_ELLIPSOID, COLVOL_TYPE_CYLINDER, COLVOL_TYPE_BOX};
+enum COLVOL_AXES {COLVOL_AXIS_X, COLVOL_AXIS_Y, COLVOL_AXIS_Z};
+enum COLVOL_TESTS {COLVOL_TEST_DISC, COLVOL_TEST_CONT};
+
+struct CollisionVolumeData {
+	CR_DECLARE_STRUCT(CollisionVolumeData);
+
+	CollisionVolumeData() {}
+	CollisionVolumeData(const std::string&amp; volTypeStr, const float3&amp; volScales, const float3&amp; volOffsets, int tstType) {
+		// note: primaryAxis is only relevant for cylinders
+		primaryAxis = COLVOL_AXIS_Z;
+		volumeType = COLVOL_TYPE_ELLIPSOID;
+		testType = tstType;
+
+		if (volTypeStr.size() &gt; 0) {
+			// note: case-sensitivity?
+			if (volTypeStr.find(&quot;Ell&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_ELLIPSOID;
+			}
+
+			if (volTypeStr.find(&quot;Cyl&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_CYLINDER;
+
+				if (volTypeStr.size() == 4) {
+					if (volTypeStr[3] == 'X') { primaryAxis = COLVOL_AXIS_X; }
+					if (volTypeStr[3] == 'Y') { primaryAxis = COLVOL_AXIS_Y; }
+					if (volTypeStr[3] == 'Z') { primaryAxis = COLVOL_AXIS_Z; }
+				}
+			}
+
+			if (volTypeStr.find(&quot;Box&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_BOX;
+			}
+		}
+
+		Init(volScales, volOffsets, volumeType, testType, primaryAxis);
+	}
+
+
+	void SetDefaultScale(const float s) {
+		// called iif unit or feature defines no custom volume,
+		// &lt;s&gt; is the object's default RADIUS (not its diameter)
+		// so we need to double it to get the full-length scales
+		const float3 scales(s * 2.0f, s * 2.0f, s * 2.0f);
+
+		Init(scales, ZeroVector, COLVOL_TYPE_ELLIPSOID, COLVOL_TEST_DISC, 0);
+	}
+
+
+	void Init(const float3&amp; scales, const float3&amp; offsets, int vType, int tType, int pAxis) {
+		// assign these here too, since SetData() can
+		// be called from outside of the constructor
+		primaryAxis = pAxis % 3;
+		volumeType = vType % 3;
+		testType = tType % 2;
+
+		axisScales.x = scales.x;  axisHScales.x = scales.x * 0.5f;  axisHScalesSq.x = axisHScales.x * axisHScales.x;
+		axisScales.y = scales.y;  axisHScales.y = scales.y * 0.5f;  axisHScalesSq.y = axisHScales.y * axisHScales.y;
+		axisScales.z = scales.z;  axisHScales.z = scales.z * 0.5f;  axisHScalesSq.z = axisHScales.z * axisHScales.z;
+
+		axisHIScales.x = 1.0f / axisHScales.x;  axisOffsets.x = offsets.x;
+		axisHIScales.y = 1.0f / axisHScales.y;  axisOffsets.y = offsets.y;
+		axisHIScales.z = 1.0f / axisHScales.z;  axisOffsets.z = offsets.z;
+
+		// if all axes (or half-axes) are equal in scale, volume is a sphere
+		spherical = ((volumeType == COLVOL_TYPE_ELLIPSOID) &amp;&amp;
+					(fabsf(axisHScales.x - axisHScales.y) &lt; EPS) &amp;&amp;
+					(fabsf(axisHScales.y - axisHScales.z) &lt; EPS));
+
+		switch (primaryAxis) {
+			case COLVOL_AXIS_X: {
+				secondaryAxes[0] = COLVOL_AXIS_Y; // (pAx + 1) % 3;
+				secondaryAxes[1] = COLVOL_AXIS_Z; // (pAx + 2) % 3;
+			} break;
+			case COLVOL_AXIS_Y: {
+				secondaryAxes[0] = COLVOL_AXIS_X; // (pAx + 1) % 3;
+				secondaryAxes[1] = COLVOL_AXIS_Z; // (pAx + 2) % 3;
+			} break;
+			case COLVOL_AXIS_Z: {
+				secondaryAxes[0] = COLVOL_AXIS_X; // (pAx + 1) % 3;
+				secondaryAxes[1] = COLVOL_AXIS_Y; // (pAx + 2) % 3;
+			} break;
+		}
+
+		// set the radius of the minimum bounding sphere
+		// that encompasses this custom collision volume
+		// (for early-out testing)
+		switch (volumeType) {
+			case COLVOL_TYPE_BOX: {
+				// would be an over-estimation for cylinders
+				volumeBoundingRadiusSq = axisHScalesSq.x + axisHScalesSq.y + axisHScalesSq.z;
+				volumeBoundingRadius = sqrt(volumeBoundingRadiusSq);
+			} break;
+			case COLVOL_TYPE_CYLINDER: {
+				const float prhs = axisHScales[primaryAxis     ];	// primary axis half-scale
+				const float sahs = axisHScales[secondaryAxes[0]];	// 1st secondary axis half-scale
+				const float sbhs = axisHScales[secondaryAxes[1]];	// 2nd secondary axis half-scale
+				const float mshs = MAX(sahs, sbhs);					// max. secondary axis half-scale
+
+				volumeBoundingRadiusSq = prhs * prhs + mshs * mshs;
+				volumeBoundingRadius = sqrt(volumeBoundingRadiusSq);
+			} break;
+			case COLVOL_TYPE_ELLIPSOID: {
+				if (spherical) {
+					// MAX(x, y, z) would suffice here too
+					volumeBoundingRadius = axisHScales.x;
+				} else {
+					volumeBoundingRadius = MAX(axisHScales.x, MAX(axisHScales.y, axisHScales.z));
+				}
+
+				volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
+			} break;
+		}
+	}
+
+	void Copy(const CollisionVolumeData* src) {
+		axisScales = src-&gt;axisScales;
+		axisHScales = src-&gt;axisHScales;
+		axisHScalesSq = src-&gt;axisHScalesSq;
+		axisHIScales = src-&gt;axisHIScales;
+		axisOffsets = src-&gt;axisOffsets;
+		volumeBoundingRadius = src-&gt;volumeBoundingRadius;
+		volumeBoundingRadiusSq = src-&gt;volumeBoundingRadiusSq;
+		volumeType = src-&gt;volumeType;
+		testType = src-&gt;testType;
+		primaryAxis = src-&gt;primaryAxis;
+		secondaryAxes[0] = src-&gt;secondaryAxes[0];
+		secondaryAxes[1] = src-&gt;secondaryAxes[1];
+		spherical = src-&gt;spherical;
+	}
+
+	int GetVolumeType() const { return volumeType; }
+	int GetTestType() const { return testType; }
+	int GetPrimaryAxis() const { return primaryAxis; }
+	float GetBoundingRadius() const { return volumeBoundingRadius; }
+	float GetBoundingRadiusSq() const { return volumeBoundingRadiusSq; }
+	float GetScale(int axis) const { return axisScales[axis]; }
+	float GetHScale(int axis) const { return axisHScales[axis]; }
+	float GetHScaleSq(int axis) const { return axisHScalesSq[axis]; }
+	float GetOffset(int axis) const { return axisOffsets[axis]; }
+	bool IsSphere() const { return spherical; }
+
+
+	float3 axisScales;					// full-length axis scales
+	float3 axisHScales;					// half-length axis scales
+	float3 axisHScalesSq;				// half-length axis scales (squared)
+	float3 axisHIScales;				// half-length axis scales (inverted)
+	float3 axisOffsets;
+
+	float volumeBoundingRadius;			// radius of minimally-bounding sphere around volume
+	float volumeBoundingRadiusSq;		// squared radius of minimally-bounding sphere
+	int volumeType;
+	int testType;
+	int primaryAxis;
+	int secondaryAxes[2];
+	bool spherical;
+};
+
+#endif

Modified: trunk/rts/Sim/Misc/LosHandler.h
===================================================================
--- trunk/rts/Sim/Misc/LosHandler.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Misc/LosHandler.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -63,19 +63,19 @@
 		if(unit-&gt;alwaysVisible)
 			return true;
 		if(unit-&gt;useAirLos){
-			return !!airLosMap[allyteam][(max(0,min(airSizeY-1,((int(unit-&gt;pos.z*invAirDiv)))))*airSizeX) + max(0,min(airSizeX-1,((int(unit-&gt;pos.x*invAirDiv)))))];
+			return !!airLosMap[allyteam][(std::max(0,std::min(airSizeY-1,((int(unit-&gt;pos.z*invAirDiv)))))*airSizeX) + std::max(0,std::min(airSizeX-1,((int(unit-&gt;pos.x*invAirDiv)))))];
 		} else {
 			if(unit-&gt;isUnderWater &amp;&amp; !radarhandler-&gt;InRadar(unit,allyteam))
 				return false;
-			return !!losMap[allyteam][max(0,min(losSizeY-1,((int)(unit-&gt;pos.z*invLosDiv))))*losSizeX+ max(0,min(losSizeX-1,((int)(unit-&gt;pos.x*invLosDiv))))];
+			return !!losMap[allyteam][std::max(0,std::min(losSizeY-1,((int)(unit-&gt;pos.z*invLosDiv))))*losSizeX+ std::max(0,std::min(losSizeX-1,((int)(unit-&gt;pos.x*invLosDiv))))];
 		}
 	}
 
 	bool InLos(const CWorldObject* object, int allyteam) {
 		if(object-&gt;useAirLos)
-			return !!airLosMap[allyteam][(max(0,min(airSizeY-1,((int(object-&gt;pos.z*invAirDiv)))))*airSizeX) + max(0,min(airSizeX-1,((int(object-&gt;pos.x*invAirDiv)))))] | object-&gt;alwaysVisible;
+			return !!airLosMap[allyteam][(std::max(0,std::min(airSizeY-1,((int(object-&gt;pos.z*invAirDiv)))))*airSizeX) + std::max(0,std::min(airSizeX-1,((int(object-&gt;pos.x*invAirDiv)))))] | object-&gt;alwaysVisible;
 		else
-			return !!losMap[allyteam][max(0,min(losSizeY-1,((int)(object-&gt;pos.z*invLosDiv))))*losSizeX+ max(0,min(losSizeX-1,((int)(object-&gt;pos.x*invLosDiv))))] | object-&gt;alwaysVisible;
+			return !!losMap[allyteam][std::max(0,std::min(losSizeY-1,((int)(object-&gt;pos.z*invLosDiv))))*losSizeX+ std::max(0,std::min(losSizeX-1,((int)(object-&gt;pos.x*invLosDiv))))] | object-&gt;alwaysVisible;
 	}
 
 	bool InLos(float3 pos, int allyteam) {

Modified: trunk/rts/Sim/Misc/RadarHandler.h
===================================================================
--- trunk/rts/Sim/Misc/RadarHandler.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Misc/RadarHandler.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -22,8 +22,8 @@
 	bool InRadar(const float3&amp; pos, int allyteam) {
 		const int gx = (int)pos.x / (SQUARE_SIZE * RADAR_SIZE);
 		const int gz = (int)pos.z / (SQUARE_SIZE * RADAR_SIZE);
-		const int square = max(0, min(ysize - 1, gz)) * xsize +
-		                   max(0, min(xsize - 1, gx));
+		const int square = std::max(0, std::min(ysize - 1, gz)) * xsize +
+		                   std::max(0, std::min(xsize - 1, gx));
 		if (pos.y &lt; -0.5f) {
 			return (sonarMaps[allyteam][square] &amp;&amp; !commonSonarJammerMap[square]);
 		}
@@ -38,7 +38,7 @@
 	bool InRadar(const CUnit* unit, int allyteam) {
 		if(unit-&gt;stealth)
 			return false;
-		int square=max(0,min(ysize-1,(int)unit-&gt;pos.z/(SQUARE_SIZE*RADAR_SIZE)))*xsize+max(0,min(xsize-1,(int)unit-&gt;pos.x/(SQUARE_SIZE*RADAR_SIZE)));
+		int square=std::max(0,std::min(ysize-1,(int)unit-&gt;pos.z/(SQUARE_SIZE*RADAR_SIZE)))*xsize+std::max(0,std::min(xsize-1,(int)unit-&gt;pos.x/(SQUARE_SIZE*RADAR_SIZE)));
 		if(unit-&gt;isUnderWater){
 			return (!!sonarMaps[allyteam][square]) &amp;&amp; !commonSonarJammerMap[square];
 		}
@@ -50,7 +50,7 @@
 	}
 
 	bool InSeismicDistance(const CUnit* unit, int allyteam) {
-		int square=max(0,min(ysize-1,(int)unit-&gt;pos.z/(SQUARE_SIZE*RADAR_SIZE)))*xsize+max(0,min(xsize-1,(int)unit-&gt;pos.x/(SQUARE_SIZE*RADAR_SIZE)));
+		int square=std::max(0,std::min(ysize-1,(int)unit-&gt;pos.z/(SQUARE_SIZE*RADAR_SIZE)))*xsize+std::max(0,std::min(xsize-1,(int)unit-&gt;pos.x/(SQUARE_SIZE*RADAR_SIZE)));
 		return !!seismicMaps[allyteam][square];
 	}
 

Modified: trunk/rts/Sim/Projectiles/FlareProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/FlareProjectile.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Projectiles/FlareProjectile.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -96,7 +96,7 @@
 
 	inArray=true;
 	unsigned char col[4];
-	float alpha=max(0.0f,1-(gs-&gt;frameNum-activateFrame)*alphaFalloff);
+	float alpha=std::max(0.0f,1-(gs-&gt;frameNum-activateFrame)*alphaFalloff);
 	col[0]=(unsigned char)alpha*255;
 	col[1]=(unsigned char)(alpha*0.5f)*255;
 	col[2]=(unsigned char)(alpha*0.2f)*255;

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -20,7 +20,7 @@
 #include &quot;Rendering/Textures/TextureHandler.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
-#include &quot;Sim/Misc/CollisionVolume.h&quot;
+#include &quot;Sim/Misc/CollisionHandler.h&quot;
 #include &quot;Sim/Projectiles/Unsynced/ShieldPartProjectile.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
@@ -637,19 +637,12 @@
 					continue;
 
 				if (p-&gt;collisionFlags &amp; COLLISION_NONEUTRAL) {
-					if ((gs-&gt;useLuaGaia &amp;&amp; unit-&gt;team == gs-&gt;gaiaTeamID) || (unit-&gt;team == MAX_TEAMS - 1)) {
-						// Gaia-team unit, count it as neutral
+					if (unit-&gt;IsNeutral()) {
 						continue;
 					}
-					if (unit-&gt;neutral) {
-						// ordinary neutral unit
-						continue;
-					}
 				}
 
-				const CCollisionVolume* vol = unit-&gt;unitDef-&gt;collisionVolume;
-
-				if (vol-&gt;DetectHit(unit, p-&gt;pos, p-&gt;pos + p-&gt;speed)) {
+				if (CCollisionHandler::DetectHit(unit, p-&gt;pos, p-&gt;pos + p-&gt;speed)) {
 					p-&gt;Collision(unit);
 					break;
 				}
@@ -658,13 +651,11 @@
 			if (!(p-&gt;collisionFlags &amp; COLLISION_NOFEATURE)) {
 				for (CFeature** fi = tempFeatures; fi != endFeature; ++fi) {
 					CFeature* feature = *fi;
-					// geothermals do not have a collision volume
+					// geothermals do not have a collision volume, skip
 					if (!feature-&gt;blocking || feature-&gt;def-&gt;geoThermal)
 						continue;
 
-					const CCollisionVolume* vol = feature-&gt;def-&gt;collisionVolume;
-
-					if (vol-&gt;DetectHit(feature, p-&gt;pos, p-&gt;pos + p-&gt;speed)) {
+					if (CCollisionHandler::DetectHit(feature, p-&gt;pos, p-&gt;pos + p-&gt;speed)) {
 						p-&gt;Collision(feature);
 						break;
 					}

Modified: trunk/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -76,7 +76,7 @@
 
 	inArray=true;
 	unsigned char col[4];
-	float alpha=min(255,age*10);
+	float alpha=std::min(255,age*10);
 	col[0]=(unsigned char)(color.x*alpha);
 	col[1]=(unsigned char)(color.y*alpha);
 	col[2]=(unsigned char)(color.z*alpha);
@@ -103,7 +103,7 @@
 		}
 	}
 	drawsize=7;
-	alpha=min(10,age/2);
+	alpha=std::min(10,age/2);
 	col[0]=(unsigned char)(color.x*alpha);
 	col[1]=(unsigned char)(color.y*alpha);
 	col[2]=(unsigned char)(color.z*alpha);

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -106,7 +106,7 @@
 
 		if (ttl &gt; 0) {
 			if (curSpeed &lt; maxSpeed)
-				curSpeed += max(0.2f, tracking);
+				curSpeed += std::max(0.2f, tracking);
 			if (target) {
 				float3 targPos;
 				if ((target-&gt;midPos - pos).SqLength() &lt; 150 * 150 || !owner)

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -30,6 +30,7 @@
 #include &quot;Sim/Misc/AirBaseHandler.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
+#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
@@ -83,6 +84,7 @@
 
 CUnit::CUnit ()
 :	unitDef(0),
+	collisionVolumeData(0),
 	team(0),
 	maxHealth(100),
 	health(100),
@@ -233,11 +235,11 @@
 
 CUnit::~CUnit()
 {
-	if(delayedWreckLevel&gt;=0){
+	if (delayedWreckLevel &gt;= 0) {
 		featureHandler-&gt;CreateWreckage(pos,wreckName, heading, buildFacing, delayedWreckLevel,team,-1,true,unitDef-&gt;name);
 	}
 
-	if(unitDef-&gt;isAirBase){
+	if (unitDef-&gt;isAirBase) {
 		airBaseHandler-&gt;DeregisterAirBase(this);
 	}
 
@@ -253,18 +255,17 @@
 	}
 #endif
 
-	if(activated &amp;&amp; unitDef-&gt;targfac){
-		radarhandler-&gt;radarErrorSize[allyteam]*=radarhandler-&gt;targFacEffect;
+	if (activated &amp;&amp; unitDef-&gt;targfac) {
+		radarhandler-&gt;radarErrorSize[allyteam] *= radarhandler-&gt;targFacEffect;
 	}
 
-//	if(!beingBuilt){
 	SetMetalStorage(0);
 	SetEnergyStorage(0);
-//	}
 
-	delete commandAI;     commandAI    = NULL;
-	delete moveType;      moveType     = NULL;
-	delete prevMoveType;  prevMoveType = NULL;
+	delete commandAI;           commandAI           = NULL;
+	delete moveType;            moveType            = NULL;
+	delete prevMoveType;        prevMoveType        = NULL;
+	delete collisionVolumeData; collisionVolumeData = NULL;
 
 	if (group) {
 		group-&gt;RemoveUnit(this);
@@ -272,14 +273,14 @@
 	group = NULL;
 
 	std::vector&lt;CWeapon*&gt;::iterator wi;
-	for(wi=weapons.begin();wi!=weapons.end();++wi)
+	for (wi = weapons.begin(); wi != weapons.end(); ++wi)
 		delete *wi;
 
 	qf-&gt;RemoveUnit(this);
 	loshandler-&gt;DelayedFreeInstance(los);
-	los=0;
+	los = 0;
 
-	if(hasRadarCapacity)
+	if (hasRadarCapacity)
 		radarhandler-&gt;RemoveUnit(this);
 
 	delete cob;

Modified: trunk/rts/Sim/Units/Unit.h
===================================================================
--- trunk/rts/Sim/Units/Unit.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Units/Unit.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -27,13 +27,13 @@
 struct S3DOModel;
 struct UnitDef;
 struct UnitTrackStruct;
+struct CollisionVolumeData;
 
 #ifdef DIRECT_CONTROL_ALLOWED
 	struct DirectControlStruct;
 #endif
 
 class CTransportUnit;
-using namespace std;
 
 
 // LOS state bits
@@ -115,13 +115,18 @@
 	void CalculateTerrainType();
 	void UpdateTerrainType();
 
+	bool IsNeutral() const {
+		return ((gs-&gt;useLuaGaia &amp;&amp; team == gs-&gt;gaiaTeamID) || (team == MAX_TEAMS - 1) || neutral);
+	}
+
 	enum ChangeType{
 		ChangeGiven,
 		ChangeCaptured
 	};
 	virtual bool ChangeTeam(int team, ChangeType type);
 
-	const UnitDef *unitDef;
+	const UnitDef* unitDef;
+	CollisionVolumeData* collisionVolumeData;
 	std::string unitDefName;
 
 	std::vector&lt;float&gt;         modParams;    // mod controlled parameters

Modified: trunk/rts/Sim/Units/UnitDef.h
===================================================================
--- trunk/rts/Sim/Units/UnitDef.h	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Units/UnitDef.h	2008-04-25 18:56:13 UTC (rev 5778)
@@ -12,7 +12,7 @@
 struct WeaponDef;
 struct S3DOModel;
 struct UnitImage;
-class CCollisionVolume;
+struct CollisionVolumeData;
 class CExplosionGenerator;
 
 const int MAX_UNITS = 10000;
@@ -99,7 +99,7 @@
 	std::string filename;
 	int id;					// unique id for this type of unit
 
-	CCollisionVolume* collisionVolume;
+	CollisionVolumeData* collisionVolumeData;
 	const UnitDef* decoyDef;
 
 	int aihint;

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -21,7 +21,7 @@
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
-#include &quot;Sim/Misc/CollisionVolume.h&quot;
+#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
 #include &quot;Sim/Misc/DamageArrayHandler.h&quot;
 #include &quot;Sim/Misc/SensorHandler.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
@@ -93,7 +93,7 @@
 		unitDefs[id].id = id;
 		unitDefs[id].buildangle = 0;
 		unitDefs[id].unitImage  = 0;
-		unitDefs[id].collisionVolume = 0;
+		unitDefs[id].collisionVolumeData = 0;
 		unitDefs[id].techLevel  = -1;
 		unitDefs[id].decoyDef   = NULL;
 		unitID[unitName] = id;
@@ -132,7 +132,8 @@
 			unitDefs[i].unitImage = 0;
 		}
 
-		delete unitDefs[i].collisionVolume;
+		delete unitDefs[i].collisionVolumeData;
+		unitDefs[i].collisionVolumeData = 0;
 	}
 	delete[] unitDefs;
 	delete weaponDefHandler;
@@ -732,7 +733,8 @@
 	ud.collisionVolumeTest = udTable.GetInt(&quot;collisionVolumeTest&quot;, COLVOL_TEST_DISC);
 
 	// initialize the (per-unitdef) collision-volume
-	ud.collisionVolume = SAFE_NEW CCollisionVolume(ud.collisionVolumeType,
+	// all CUnit instances hold a copy of this object
+	ud.collisionVolumeData = SAFE_NEW CollisionVolumeData(ud.collisionVolumeType,
 		ud.collisionVolumeScales, ud.collisionVolumeOffsets, ud.collisionVolumeTest);
 
 

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -26,7 +26,7 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
-#include &quot;Sim/Misc/CollisionVolume.h&quot;
+#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
 #include &quot;Sim/MoveTypes/AirMoveType.h&quot;
 #include &quot;Sim/MoveTypes/GroundMoveType.h&quot;
 #include &quot;Sim/MoveTypes/TAAirMoveType.h&quot;
@@ -306,15 +306,20 @@
 	unit-&gt;model = ud-&gt;LoadModel(team);
 	unit-&gt;SetRadius(unit-&gt;model-&gt;radius);
 
-	// CUnitLoader left this volume's axis-scales uninitialized
-	if (ud-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_X) &lt; 0.01f &amp;&amp;
-		ud-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Y) &lt; 0.01f &amp;&amp;
-		ud-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Z) &lt; 0.01f) {
+	// copy the UnitDef volume archetype data
+	unit-&gt;collisionVolumeData = SAFE_NEW CollisionVolumeData();
+	unit-&gt;collisionVolumeData-&gt;Copy(ud-&gt;collisionVolumeData);
+
+	// CUnitDefHandler left this volume's axis-scales uninitialized
+	// (ie. no &quot;collisionVolumeScales&quot; tag was defined in UnitDef)
+	if (unit-&gt;collisionVolumeData-&gt;GetScale(COLVOL_AXIS_X) &lt; 0.01f &amp;&amp;
+		unit-&gt;collisionVolumeData-&gt;GetScale(COLVOL_AXIS_Y) &lt; 0.01f &amp;&amp;
+		unit-&gt;collisionVolumeData-&gt;GetScale(COLVOL_AXIS_Z) &lt; 0.01f) {
 		// aircraft still get half-size spheres for coldet purposes
 		// if no custom volume is defined (unit-&gt;model-&gt;radius and
 		// unit-&gt;radius themselves are no longer altered)
 		const float scaleFactor = (ud-&gt;canfly)? 0.5f: 1.0f;
-		ud-&gt;collisionVolume-&gt;SetDefaultScale(unit-&gt;model-&gt;radius * scaleFactor);
+		unit-&gt;collisionVolumeData-&gt;SetDefaultScale(unit-&gt;model-&gt;radius * scaleFactor);
 	}
 
 

Modified: trunk/rts/Sim/Weapons/bombdropper.cpp
===================================================================
--- trunk/rts/Sim/Weapons/bombdropper.cpp	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/Sim/Weapons/bombdropper.cpp	2008-04-25 18:56:13 UTC (rev 5778)
@@ -64,7 +64,7 @@
 				predict=0;
 			float3 hitpos=owner-&gt;pos+owner-&gt;speed*predict;
 			float speedf=owner-&gt;speed.Length();
-			if(hitpos.distance2D(targetPos)&lt;max(1,(salvoSize-1))*speedf*salvoDelay*0.5f+bombMoveRange){
+			if(hitpos.distance2D(targetPos)&lt;std::max(1,(salvoSize-1))*speedf*salvoDelay*0.5f+bombMoveRange){
 				subClassReady=true;
 			}
 		}
@@ -111,10 +111,10 @@
 		float3 dir=owner-&gt;speed;
 		dir.Normalize();
 		dir+=(gs-&gt;randVector()*sprayangle+salvoError)*(1-owner-&gt;limExperience*0.9f); //add a random spray
-		dir.y=min(0.0f,dir.y);
+		dir.y=std::min(0.0f,dir.y);
 		dir.Normalize();
 		dif-=dir*dif.dot(dir);
-		dif/=max(0.01f,predict);
+		dif/=std::max(0.01f,predict);
 		float size=dif.Length();
 		if(size&gt;1.0f)
 			dif/=size*1.0f;

Modified: trunk/rts/build/vstudio8/rts.vcproj
===================================================================
--- trunk/rts/build/vstudio8/rts.vcproj	2008-04-25 18:48:53 UTC (rev 5777)
+++ trunk/rts/build/vstudio8/rts.vcproj	2008-04-25 18:56:13 UTC (rev 5778)
@@ -2967,7 +2967,7 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Sim\Misc\CollisionVolume.cpp&quot;
+					RelativePath=&quot;..\..\Sim\Misc\CollisionHandler.cpp&quot;
 					&gt;
 					&lt;FileConfiguration
 						Name=&quot;Debug|Win32&quot;
@@ -3003,10 +3003,14 @@
 					&lt;/FileConfiguration&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Sim\Misc\CollisionVolume.h&quot;
+					RelativePath=&quot;..\..\Sim\Misc\CollisionHandler.h&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;..\..\Sim\Misc\CollisionVolumeData.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\Sim\Misc\DamageArray.cpp&quot;
 					&gt;
 				&lt;/File&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000557.html">[Taspring-linux-commit] r5777 - in trunk/rts: Game System/Net
</A></li>
	<LI>Next message: <A HREF="000559.html">[Taspring-linux-commit] r5779 - trunk/Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#558">[ date ]</a>
              <a href="thread.html#558">[ thread ]</a>
              <a href="subject.html#558">[ subject ]</a>
              <a href="author.html#558">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
