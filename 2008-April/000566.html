<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5786 - in trunk/rts: Lua	Rendering/UnitModels Sim/Features Sim/Misc Sim/Units build/vstudio8
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5786%20-%20in%20trunk/rts%3A%20Lua%0A%09Rendering/UnitModels%20Sim/Features%20Sim/Misc%20Sim/Units%20build/vstudio8&In-Reply-To=%3C20080426114159.DD2BB46CB%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000565.html">
   <LINK REL="Next"  HREF="000567.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5786 - in trunk/rts: Lua	Rendering/UnitModels Sim/Features Sim/Misc Sim/Units build/vstudio8</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5786%20-%20in%20trunk/rts%3A%20Lua%0A%09Rendering/UnitModels%20Sim/Features%20Sim/Misc%20Sim/Units%20build/vstudio8&In-Reply-To=%3C20080426114159.DD2BB46CB%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5786 - in trunk/rts: Lua	Rendering/UnitModels Sim/Features Sim/Misc Sim/Units build/vstudio8">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Apr 26 13:41:59 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000565.html">[Taspring-linux-commit] r5785 - in trunk/rts/Sim: Features Misc	Units
</A></li>
        <LI>Next message: <A HREF="000567.html">[Taspring-linux-commit] r5787 - in trunk: AI/Group/EconomyAI	rts/ExternalAI rts/Game rts/Game/Camera rts/Game/StartScripts	rts/Game/UI rts/Lua rts/Map rts/Rendering rts/Rendering/Env	rts/Rendering/UnitModels rts/Sim/Features rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Path rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Units/UnitTypes rts/Sim/Weapons rts/System	rts/System/FileSystem rts/System/Platform/Linux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#566">[ date ]</a>
              <a href="thread.html#566">[ thread ]</a>
              <a href="subject.html#566">[ subject ]</a>
              <a href="author.html#566">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-04-26 13:41:57 +0200 (Sat, 26 Apr 2008)
New Revision: 5786

Added:
   trunk/rts/Sim/Misc/CollisionVolume.h
Removed:
   trunk/rts/Sim/Misc/CollisionVolumeData.h
Modified:
   trunk/rts/Lua/LuaSyncedCtrl.cpp
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Sim/Features/Feature.cpp
   trunk/rts/Sim/Features/Feature.h
   trunk/rts/Sim/Features/FeatureDef.h
   trunk/rts/Sim/Features/FeatureHandler.cpp
   trunk/rts/Sim/Misc/CollisionHandler.cpp
   trunk/rts/Sim/Misc/CollisionHandler.h
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/Unit.h
   trunk/rts/Sim/Units/UnitDef.h
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/build/vstudio8/rts.vcproj
Log:
replace the Copy() by a copy ctor (and remove the redundant Data postfix everywhere)

Modified: trunk/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-04-26 11:41:57 UTC (rev 5786)
@@ -31,7 +31,7 @@
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
-#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Misc/DamageArray.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
@@ -1457,7 +1457,7 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	if (unit-&gt;collisionVolumeData == NULL) {
+	if (unit-&gt;collisionVolume == NULL) {
 		return 0;
 	}
 
@@ -1476,7 +1476,7 @@
 		const float3 scales(xs, ys, zs);
 		const float3 offsets(xo, yo, zo);
 
-		unit-&gt;collisionVolumeData-&gt;Init(scales, offsets, vType, tType, pAxis);
+		unit-&gt;collisionVolume-&gt;Init(scales, offsets, vType, tType, pAxis);
 	} else {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitCollisionVolumeData()&quot;);
 	}
@@ -2020,7 +2020,7 @@
 	if (feature == NULL) {
 		return 0;
 	}
-	if (feature-&gt;collisionVolumeData == NULL) {
+	if (feature-&gt;collisionVolume == NULL) {
 		return 0;
 	}
 
@@ -2039,7 +2039,7 @@
 		const float3 scales(xs, ys, zs);
 		const float3 offsets(xo, yo, zo);
 
-		feature-&gt;collisionVolumeData-&gt;Init(scales, offsets, vType, tType, pAxis);
+		feature-&gt;collisionVolume-&gt;Init(scales, offsets, vType, tType, pAxis);
 	} else {
 		luaL_error(L, &quot;Incorrect arguments to SetFeatureCollisionVolumeData()&quot;);
 	}

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-04-26 11:41:57 UTC (rev 5786)
@@ -30,7 +30,7 @@
 
 #include &quot;ExternalAI/Group.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
-#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/BuilderCAI.h&quot;
@@ -1704,13 +1704,13 @@
 		GLUquadricObj* q = gluNewQuadric();
 		gluQuadricDrawStyle(q, GLU_LINE);
 
-		CollisionVolumeData* data = unit-&gt;collisionVolumeData;
+		CollisionVolume* vol = unit-&gt;collisionVolume;
 
-		switch (data-&gt;GetVolumeType()) {
+		switch (vol-&gt;GetVolumeType()) {
 			case COLVOL_TYPE_ELLIPSOID: {
 				// scaled sphere: radius, slices, stacks
-				glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
-				glScalef(data-&gt;GetHScale(0), data-&gt;GetHScale(1), data-&gt;GetHScale(2));
+				glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
+				glScalef(vol-&gt;GetHScale(0), vol-&gt;GetHScale(1), vol-&gt;GetHScale(2));
 				gluSphere(q, 1.0f, 20, 20);
 			} break;
 			case COLVOL_TYPE_CYLINDER: {
@@ -1719,23 +1719,23 @@
 				// (cylinder base is drawn at unit center by default so add offset
 				// by half major axis to visually match the mathematical situation,
 				// height of the cylinder equals the unit's full major axis)
-				switch (data-&gt;GetPrimaryAxis()) {
+				switch (vol-&gt;GetPrimaryAxis()) {
 					case COLVOL_AXIS_X: {
-						glTranslatef(-(data-&gt;GetHScale(0)), 0.0f, 0.0f);
-						glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
-						glScalef(data-&gt;GetScale(0), data-&gt;GetHScale(1), data-&gt;GetHScale(2));
+						glTranslatef(-(vol-&gt;GetHScale(0)), 0.0f, 0.0f);
+						glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
+						glScalef(vol-&gt;GetScale(0), vol-&gt;GetHScale(1), vol-&gt;GetHScale(2));
 						glRotatef( 90.0f, 0.0f, 1.0f, 0.0f);
 					} break;
 					case COLVOL_AXIS_Y: {
-						glTranslatef(0.0f, -(data-&gt;GetHScale(1)), 0.0f);
-						glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
-						glScalef(data-&gt;GetHScale(0), data-&gt;GetScale(1), data-&gt;GetHScale(2));
+						glTranslatef(0.0f, -(vol-&gt;GetHScale(1)), 0.0f);
+						glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
+						glScalef(vol-&gt;GetHScale(0), vol-&gt;GetScale(1), vol-&gt;GetHScale(2));
 						glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);
 					} break;
 					case COLVOL_AXIS_Z: {
-						glTranslatef(0.0f, 0.0f, -(data-&gt;GetHScale(2)));
-						glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
-						glScalef(data-&gt;GetHScale(0), data-&gt;GetHScale(1), data-&gt;GetScale(2));
+						glTranslatef(0.0f, 0.0f, -(vol-&gt;GetHScale(2)));
+						glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
+						glScalef(vol-&gt;GetHScale(0), vol-&gt;GetHScale(1), vol-&gt;GetScale(2));
 					} break;
 				}
 
@@ -1743,8 +1743,8 @@
 			} break;
 			case COLVOL_TYPE_BOX: {
 				// scaled cube: length, width, height
-				glTranslatef(data-&gt;GetOffset(0), data-&gt;GetOffset(1), data-&gt;GetOffset(2));
-				glScalef(data-&gt;GetScale(0), data-&gt;GetScale(1), data-&gt;GetScale(2));
+				glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));
+				glScalef(vol-&gt;GetScale(0), vol-&gt;GetScale(1), vol-&gt;GetScale(2));
 				gluMyCube(1.0f);
 			} break;
 		}

Modified: trunk/rts/Sim/Features/Feature.cpp
===================================================================
--- trunk/rts/Sim/Features/Feature.cpp	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Features/Feature.cpp	2008-04-26 11:41:57 UTC (rev 5786)
@@ -14,7 +14,7 @@
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
-#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Projectiles/FireProjectile.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.h&quot;
@@ -54,7 +54,7 @@
 
 CFeature::CFeature()
 :	def(0),
-	collisionVolumeData(0),
+	collisionVolume(0),
 	inUpdateQue(false),
 	reclaimLeft(1),
 	fireTime(0),
@@ -99,7 +99,7 @@
 		CGeoThermSmokeProjectile::GeoThermDestroyed(this);
 	}
 
-	delete collisionVolumeData; collisionVolumeData = NULL;
+	delete collisionVolume; collisionVolume = NULL;
 }
 
 void CFeature::PostLoad()
@@ -168,15 +168,14 @@
 		midPos = pos + model-&gt;relMidPos;
 
 		// copy the FeatureDef volume archetype data
-		collisionVolumeData = SAFE_NEW CollisionVolumeData();
-		collisionVolumeData-&gt;Copy(def-&gt;collisionVolumeData);
+		collisionVolume = SAFE_NEW CollisionVolume(def-&gt;collisionVolume);
 
 		// CFeatureHandler left this volume's axis-scales uninitialized
 		// (ie. no &quot;collisionVolumeScales&quot; tag was defined in FeatureDef)
-		if (collisionVolumeData-&gt;GetScale(COLVOL_AXIS_X) &lt;= 1.0f &amp;&amp;
-			collisionVolumeData-&gt;GetScale(COLVOL_AXIS_Y) &lt;= 1.0f &amp;&amp;
-			collisionVolumeData-&gt;GetScale(COLVOL_AXIS_Z) &lt;= 1.0f) {
-			collisionVolumeData-&gt;SetDefaultScale(model-&gt;radius);
+		if (collisionVolume-&gt;GetScale(COLVOL_AXIS_X) &lt;= 1.0f &amp;&amp;
+			collisionVolume-&gt;GetScale(COLVOL_AXIS_Y) &lt;= 1.0f &amp;&amp;
+			collisionVolume-&gt;GetScale(COLVOL_AXIS_Z) &lt;= 1.0f) {
+			collisionVolume-&gt;SetDefaultScale(model-&gt;radius);
 		}
 	}
 	else if (def-&gt;drawType == DRAWTYPE_TREE) {
@@ -185,9 +184,8 @@
 		height = 2 * TREE_RADIUS;
 
 		// copy the FeatureDef volume archetype data
-		collisionVolumeData = SAFE_NEW CollisionVolumeData();
-		collisionVolumeData-&gt;Copy(def-&gt;collisionVolumeData);
-		collisionVolumeData-&gt;SetDefaultScale(TREE_RADIUS);
+		collisionVolume = SAFE_NEW CollisionVolume(def-&gt;collisionVolume);
+		collisionVolume-&gt;SetDefaultScale(TREE_RADIUS);
 	}
 	else {
 		// geothermal (no collision volume)

Modified: trunk/rts/Sim/Features/Feature.h
===================================================================
--- trunk/rts/Sim/Features/Feature.h	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Features/Feature.h	2008-04-26 11:41:57 UTC (rev 5786)
@@ -15,7 +15,7 @@
 class CUnit;
 struct DamageArray;
 class CFireProjectile;
-struct CollisionVolumeData;
+struct CollisionVolume;
 
 class CFeature : public CSolidObject, public boost::noncopyable
 {
@@ -67,7 +67,7 @@
 
 	const FeatureDef* def;
 	std::string defName;
-	CollisionVolumeData* collisionVolumeData;
+	CollisionVolume* collisionVolume;
 
 	CMatrix44f transMatrix;
 //	float3 residualImpulse;	//impulse energy that havent been acted on

Modified: trunk/rts/Sim/Features/FeatureDef.h
===================================================================
--- trunk/rts/Sim/Features/FeatureDef.h	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Features/FeatureDef.h	2008-04-26 11:41:57 UTC (rev 5786)
@@ -6,7 +6,7 @@
 #define DRAWTYPE_NONE -1
 
 struct S3DOModel;
-struct CollisionVolumeData;
+struct CollisionVolume;
 
 struct FeatureDef
 {
@@ -20,7 +20,7 @@
 		xsize(0), ysize(0), reclaimTime(0) {}
 
 	S3DOModel* LoadModel(int team) const;
-	CollisionVolumeData* collisionVolumeData;
+	CollisionVolume* collisionVolume;
 
 	std::string myName;
 	std::string description;

Modified: trunk/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- trunk/rts/Sim/Features/FeatureHandler.cpp	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Features/FeatureHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
@@ -22,7 +22,7 @@
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
-#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/BuilderCAI.h&quot;
 #include &quot;System/TimeProfiler.h&quot;
@@ -132,9 +132,9 @@
 		// unsavory, but better than a memleak
 		FeatureDef* fd = (FeatureDef*) (*fi)-&gt;def;
 
-		if (fd-&gt;collisionVolumeData) {
-			delete fd-&gt;collisionVolumeData;
-			fd-&gt;collisionVolumeData = 0;
+		if (fd-&gt;collisionVolume) {
+			delete fd-&gt;collisionVolume;
+			fd-&gt;collisionVolume = 0;
 		}
 
 		delete *fi;
@@ -147,9 +147,9 @@
 
 		FeatureDef* fd = (FeatureDef*) fi-&gt;second;
 
-		if (fd-&gt;collisionVolumeData) {
-			delete fd-&gt;collisionVolumeData;
-			fd-&gt;collisionVolumeData = 0;
+		if (fd-&gt;collisionVolume) {
+			delete fd-&gt;collisionVolume;
+			fd-&gt;collisionVolume = 0;
 		}
 
 		delete fi-&gt;second;
@@ -249,7 +249,7 @@
 
 	// initialize the (per-featuredef) collision-volume,
 	// all CFeature instances hold a copy of this object
-	fd-&gt;collisionVolumeData = SAFE_NEW CollisionVolumeData(fd-&gt;collisionVolumeType,
+	fd-&gt;collisionVolume = SAFE_NEW CollisionVolume(fd-&gt;collisionVolumeType,
 		fd-&gt;collisionVolumeScales, fd-&gt;collisionVolumeOffsets, fd-&gt;collisionVolumeTest);
 
 
@@ -322,7 +322,7 @@
 			fd-&gt;description = &quot;Tree&quot;;
 			fd-&gt;mass = 20;
 			// trees by default have spherical collision volumes of fixed radius &lt;TREE_RADIUS&gt;
-			fd-&gt;collisionVolumeData = SAFE_NEW CollisionVolumeData(&quot;&quot;, ZeroVector, ZeroVector, COLVOL_TEST_DISC);
+			fd-&gt;collisionVolume = SAFE_NEW CollisionVolume(&quot;&quot;, ZeroVector, ZeroVector, COLVOL_TEST_DISC);
 			AddFeatureDef(name, fd);
 		}
 		else if (name.find(&quot;geovent&quot;) != string::npos) {
@@ -344,7 +344,7 @@
 			fd-&gt;myName = name;
 			fd-&gt;mass = 100000;
 			// geothermals have no collision volume at all
-			fd-&gt;collisionVolumeData = 0;
+			fd-&gt;collisionVolume = 0;
 			AddFeatureDef(name, fd);
 		}
 		else {

Modified: trunk/rts/Sim/Misc/CollisionHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/CollisionHandler.cpp	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Misc/CollisionHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
@@ -8,13 +8,13 @@
 #include &quot;Sim/Features/Feature.h&quot;
 
 #include &quot;CollisionHandler.h&quot;
-#include &quot;CollisionVolumeData.h&quot;
+#include &quot;CollisionVolume.h&quot;
 
 #define ZVec ZeroVector
 
 CR_BIND(CCollisionHandler, );
-CR_BIND(CollisionVolumeData, );
-	CR_REG_METADATA(CollisionVolumeData, (
+CR_BIND(CollisionVolume, );
+	CR_REG_METADATA(CollisionVolume, (
 		CR_MEMBER(axisScales),
 		CR_MEMBER(axisHScales),
 		CR_MEMBER(axisHScalesSq),
@@ -38,7 +38,7 @@
 {
 	bool r = false;
 
-	switch (u-&gt;collisionVolumeData-&gt;testType) {
+	switch (u-&gt;collisionVolume-&gt;testType) {
 		// Collision(CUnit*) does not need p1 or q
 		case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(u, p0       ); numCollisionTests    += 1; } break;
 		case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(u, p0, p1, q); numIntersectionTests += 1; } break;
@@ -51,7 +51,7 @@
 {
 	bool r = false;
 
-	switch (f-&gt;collisionVolumeData-&gt;testType) {
+	switch (f-&gt;collisionVolume-&gt;testType) {
 		// Collision(CFeature*) does not need p1 or q
 		case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(f, p0       ); numCollisionTests    += 1; } break;
 		case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(f, p0, p1, q); numIntersectionTests += 1; } break;
@@ -67,12 +67,12 @@
 
 bool CCollisionHandler::Collision(const CUnit* u, const float3&amp; p)
 {
-	const CollisionVolumeData* d = u-&gt;collisionVolumeData;
+	const CollisionVolume* v = u-&gt;collisionVolume;
 
-	if ((u-&gt;midPos - p).SqLength() &gt; d-&gt;volumeBoundingRadiusSq) {
+	if ((u-&gt;midPos - p).SqLength() &gt; v-&gt;volumeBoundingRadiusSq) {
 		return false;
 	} else {
-		if (d-&gt;spherical) {
+		if (v-&gt;spherical) {
 			return true;
 		} else {
 			// NOTE: we have to translate by relMidPos (which is where
@@ -81,28 +81,28 @@
 			CMatrix44f m;
 			u-&gt;GetTransformMatrix(m);
 			m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
-			m.Translate(d-&gt;axisOffsets.x, d-&gt;axisOffsets.y, d-&gt;axisOffsets.z);
+			m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
 
-			return CCollisionHandler::Collision(d, m, p);
+			return CCollisionHandler::Collision(v, m, p);
 		}
 	}
 }
 
 bool CCollisionHandler::Collision(const CFeature* f, const float3&amp; p)
 {
-	const CollisionVolumeData* d = f-&gt;collisionVolumeData;
+	const CollisionVolume* v = f-&gt;collisionVolume;
 
-	if ((f-&gt;midPos - p).SqLength() &gt; d-&gt;volumeBoundingRadiusSq) {
+	if ((f-&gt;midPos - p).SqLength() &gt; v-&gt;volumeBoundingRadiusSq) {
 		return false;
 	} else {
-		if (d-&gt;spherical) {
+		if (v-&gt;spherical) {
 			return true;
 		} else {
 			// NOTE: CFeature does not have a relMidPos member
 			CMatrix44f m(f-&gt;transMatrix);
-			m.Translate(d-&gt;axisOffsets.x, d-&gt;axisOffsets.y, d-&gt;axisOffsets.z);
+			m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
 
-			return CCollisionHandler::Collision(d, m, p);
+			return CCollisionHandler::Collision(v, m, p);
 		}
 	}
 }
@@ -111,7 +111,7 @@
 
 // test if point &lt;p&gt; (in world-coors) lies inside the
 // volume whose transformation matrix is given by &lt;m&gt;
-bool CCollisionHandler::Collision(const CollisionVolumeData* d, const CMatrix44f&amp; m, const float3&amp; p)
+bool CCollisionHandler::Collision(const CollisionVolume* v, const CMatrix44f&amp; m, const float3&amp; p)
 {
 	// get the inverse volume transformation matrix and
 	// apply it to the projectile's position, then test
@@ -121,43 +121,43 @@
 	float3 pi = mInv.Mul(p);
 	bool hit = false;
 
-	switch (d-&gt;volumeType) {
+	switch (v-&gt;volumeType) {
 		case COLVOL_TYPE_ELLIPSOID: {
-			if (d-&gt;spherical) {
-				hit = (pi.dot(pi) &lt;= d-&gt;axisHScalesSq.x);
+			if (v-&gt;spherical) {
+				hit = (pi.dot(pi) &lt;= v-&gt;axisHScalesSq.x);
 			} else {
-				const float f1 = (pi.x * pi.x) / d-&gt;axisHScalesSq.x;
-				const float f2 = (pi.y * pi.y) / d-&gt;axisHScalesSq.y;
-				const float f3 = (pi.z * pi.z) / d-&gt;axisHScalesSq.z;
+				const float f1 = (pi.x * pi.x) / v-&gt;axisHScalesSq.x;
+				const float f2 = (pi.y * pi.y) / v-&gt;axisHScalesSq.y;
+				const float f3 = (pi.z * pi.z) / v-&gt;axisHScalesSq.z;
 				hit = ((f1 + f2 + f3) &lt;= 1.0f);
 			}
 		} break;
 		case COLVOL_TYPE_CYLINDER: {
-			switch (d-&gt;primaryAxis) {
+			switch (v-&gt;primaryAxis) {
 				case COLVOL_AXIS_X: {
-					const bool xPass = (pi.x &gt; -d-&gt;axisHScales.x  &amp;&amp;  pi.x &lt; d-&gt;axisHScales.x);
-					const float yRat = (pi.y * pi.y) / d-&gt;axisHScalesSq.y;
-					const float zRat = (pi.z * pi.z) / d-&gt;axisHScalesSq.z;
+					const bool xPass = (pi.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi.x &lt; v-&gt;axisHScales.x);
+					const float yRat = (pi.y * pi.y) / v-&gt;axisHScalesSq.y;
+					const float zRat = (pi.z * pi.z) / v-&gt;axisHScalesSq.z;
 					hit = (xPass &amp;&amp; (yRat + zRat &lt;= 1.0f));
 				} break;
 				case COLVOL_AXIS_Y: {
-					const bool yPass = (pi.y &gt; -d-&gt;axisHScales.y  &amp;&amp;  pi.y &lt; d-&gt;axisHScales.y);
-					const float xRat = (pi.x * pi.x) / d-&gt;axisHScalesSq.x;
-					const float zRat = (pi.z * pi.z) / d-&gt;axisHScalesSq.z;
+					const bool yPass = (pi.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi.y &lt; v-&gt;axisHScales.y);
+					const float xRat = (pi.x * pi.x) / v-&gt;axisHScalesSq.x;
+					const float zRat = (pi.z * pi.z) / v-&gt;axisHScalesSq.z;
 					hit = (yPass &amp;&amp; (xRat + zRat &lt;= 1.0f));
 				} break;
 				case COLVOL_AXIS_Z: {
-					const bool zPass = (pi.z &gt; -d-&gt;axisHScales.z  &amp;&amp;  pi.z &lt; d-&gt;axisHScales.z);
-					const float xRat = (pi.x * pi.x) / d-&gt;axisHScalesSq.x;
-					const float yRat = (pi.y * pi.y) / d-&gt;axisHScalesSq.y;
+					const bool zPass = (pi.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi.z &lt; v-&gt;axisHScales.z);
+					const float xRat = (pi.x * pi.x) / v-&gt;axisHScalesSq.x;
+					const float yRat = (pi.y * pi.y) / v-&gt;axisHScalesSq.y;
 					hit = (zPass &amp;&amp; (xRat + yRat &lt;= 1.0f));
 				} break;
 			}
 		} break;
 		case COLVOL_TYPE_BOX: {
-			const bool b1 = (pi.x &gt; -d-&gt;axisHScales.x  &amp;&amp;  pi.x &lt; d-&gt;axisHScales.x);
-			const bool b2 = (pi.y &gt; -d-&gt;axisHScales.y  &amp;&amp;  pi.y &lt; d-&gt;axisHScales.y);
-			const bool b3 = (pi.z &gt; -d-&gt;axisHScales.z  &amp;&amp;  pi.z &lt; d-&gt;axisHScales.z);
+			const bool b1 = (pi.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi.x &lt; v-&gt;axisHScales.x);
+			const bool b2 = (pi.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi.y &lt; v-&gt;axisHScales.y);
+			const bool b3 = (pi.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi.z &lt; v-&gt;axisHScales.z);
 			hit = (b1 &amp;&amp; b2 &amp;&amp; b3);
 		} break;
 	}
@@ -172,28 +172,28 @@
 
 bool CCollisionHandler::Intersect(const CUnit* u, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
 {
-	const CollisionVolumeData* d = u-&gt;collisionVolumeData;
+	const CollisionVolume* v = u-&gt;collisionVolume;
 
 	CMatrix44f m;
 	u-&gt;GetTransformMatrix(m);
 	m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
-	m.Translate(d-&gt;axisOffsets.x, d-&gt;axisOffsets.y, d-&gt;axisOffsets.z);
+	m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
 
-	return CCollisionHandler::Intersect(d, m, p0, p1, q);
+	return CCollisionHandler::Intersect(v, m, p0, p1, q);
 }
 
 bool CCollisionHandler::Intersect(const CFeature* f, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
 {
-	const CollisionVolumeData* d = f-&gt;collisionVolumeData;
+	const CollisionVolume* v = f-&gt;collisionVolume;
 
 	CMatrix44f m(f-&gt;transMatrix);
-	m.Translate(d-&gt;axisOffsets.x, d-&gt;axisOffsets.y, d-&gt;axisOffsets.z);
+	m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
 
-	return CCollisionHandler::Intersect(d, m, p0, p1, q);
+	return CCollisionHandler::Intersect(v, m, p0, p1, q);
 }
 
 /*
-bool CCollisionHandler::IntersectAlt(const collisionVolumeData* d, const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery*)
+bool CCollisionHandler::IntersectAlt(const collisionVolume* d, const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery*)
 {
 	// alternative numerical integration method (unused)
 	const float delta = 1.0f;
@@ -212,7 +212,7 @@
 
 // test if ray from &lt;p0&gt; to &lt;p1&gt; (in world-coors) intersects
 // the volume whose transformation matrix is given by &lt;m&gt;
-bool CCollisionHandler::Intersect(const CollisionVolumeData* d, const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
+bool CCollisionHandler::Intersect(const CollisionVolume* v, const CMatrix44f&amp; m, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q)
 {
 	CMatrix44f mInv = m.Invert();
 	const float3 pi0 = mInv.Mul(p0);
@@ -224,8 +224,8 @@
 	const float rmaxx = MAX(pi0.x, pi1.x), rmaxy = MAX(pi0.y, pi1.y), rmaxz = MAX(pi0.z, pi1.z);
 
 	// minimum and maximum (x, y, z) coordinates of (bounding box around) volume
-	const float vminx = -d-&gt;axisHScales.x, vminy = -d-&gt;axisHScales.y, vminz = -d-&gt;axisHScales.z;
-	const float vmaxx =  d-&gt;axisHScales.x, vmaxy =  d-&gt;axisHScales.y, vmaxz =  d-&gt;axisHScales.z;
+	const float vminx = -v-&gt;axisHScales.x, vminy = -v-&gt;axisHScales.y, vminz = -v-&gt;axisHScales.z;
+	const float vmaxx =  v-&gt;axisHScales.x, vmaxy =  v-&gt;axisHScales.y, vmaxz =  v-&gt;axisHScales.z;
 
 	// check if ray segment misses (bounding box around) volume
 	// (if so, then no further intersection tests are necessary)
@@ -233,27 +233,27 @@
 	if (rmaxy &lt; vminy || rminy &gt; vmaxy) { return false; }
 	if (rmaxz &lt; vminz || rminz &gt; vmaxz) { return false; }
 
-	switch (d-&gt;volumeType) {
+	switch (v-&gt;volumeType) {
 		case COLVOL_TYPE_ELLIPSOID: {
-			intersect = CCollisionHandler::IntersectEllipsoid(d, pi0, pi1, q);
+			intersect = CCollisionHandler::IntersectEllipsoid(v, pi0, pi1, q);
 		} break;
 		case COLVOL_TYPE_CYLINDER: {
-			intersect = CCollisionHandler::IntersectCylinder(d, pi0, pi1, q);
+			intersect = CCollisionHandler::IntersectCylinder(v, pi0, pi1, q);
 		} break;
 		case COLVOL_TYPE_BOX: {
-			intersect = CCollisionHandler::IntersectBox(d, pi0, pi1, q);
+			intersect = CCollisionHandler::IntersectBox(v, pi0, pi1, q);
 		} break;
 	}
 
 	return intersect;
 }
 
-bool CCollisionHandler::IntersectEllipsoid(const CollisionVolumeData* d, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+bool CCollisionHandler::IntersectEllipsoid(const CollisionVolume* v, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
 {
 	// transform the volume-space points into (unit) sphere-space (requires fewer
 	// float-ops than solving the surface equation for arbitrary ellipsoid volumes)
-	const float3 pii0 = float3(pi0.x * d-&gt;axisHIScales.x, pi0.y * d-&gt;axisHIScales.y, pi0.z * d-&gt;axisHIScales.z);
-	const float3 pii1 = float3(pi1.x * d-&gt;axisHIScales.x, pi1.y * d-&gt;axisHIScales.y, pi1.z * d-&gt;axisHIScales.z);
+	const float3 pii0 = float3(pi0.x * v-&gt;axisHIScales.x, pi0.y * v-&gt;axisHIScales.y, pi0.z * v-&gt;axisHIScales.z);
+	const float3 pii1 = float3(pi1.x * v-&gt;axisHIScales.x, pi1.y * v-&gt;axisHIScales.y, pi1.z * v-&gt;axisHIScales.z);
 	const float rSq = 1.0f;
 
 	if (pii0.dot(pii0) &lt;= rSq /* &amp;&amp; pii1.dot(pii1) &lt;= rSq */) {
@@ -291,7 +291,7 @@
 			// get the intersection point in sphere-space
 			const float3 pTmp = pii0 + (dir * t0);
 			// get the intersection point in volume-space
-			const float3 p0(pTmp.x * d-&gt;axisHScales.x, pTmp.y * d-&gt;axisHScales.y, pTmp.z * d-&gt;axisHScales.z);
+			const float3 p0(pTmp.x * v-&gt;axisHScales.x, pTmp.y * v-&gt;axisHScales.y, pTmp.z * v-&gt;axisHScales.z);
 			// get the distance from the start of the segment
 			// to the intersection point in volume-space
 			const float dSq0 = (p0 - pi0).SqLength();
@@ -317,8 +317,8 @@
 			const float3 pTmp0 = pii0 + (dir * t0);
 			const float3 pTmp1 = pii0 + (dir * t1);
 			// get the intersection points in volume-space
-			const float3 p0(pTmp0.x * d-&gt;axisHScales.x, pTmp0.y * d-&gt;axisHScales.y, pTmp0.z * d-&gt;axisHScales.z);
-			const float3 p1(pTmp1.x * d-&gt;axisHScales.x, pTmp1.y * d-&gt;axisHScales.y, pTmp1.z * d-&gt;axisHScales.z);
+			const float3 p0(pTmp0.x * v-&gt;axisHScales.x, pTmp0.y * v-&gt;axisHScales.y, pTmp0.z * v-&gt;axisHScales.z);
+			const float3 p1(pTmp1.x * v-&gt;axisHScales.x, pTmp1.y * v-&gt;axisHScales.y, pTmp1.z * v-&gt;axisHScales.z);
 			// get the distances from the start of the ray
 			// to the intersection points in volume-space
 			const float dSq0 = (p0 - pi0).SqLength();
@@ -339,7 +339,7 @@
 	}
 }
 
-bool CCollisionHandler::IntersectCylinder(const CollisionVolumeData* d, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+bool CCollisionHandler::IntersectCylinder(const CollisionVolume* v, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
 {
 	// get the ray direction in volume space
 	const float3 dir = (pi1 - pi0).Normalize();
@@ -356,17 +356,17 @@
 	const float pxSq = pi0.x * pi0.x, pxdx = pi0.x * dir.x, dxSq = dir.x * dir.x;
 	const float pySq = pi0.y * pi0.y, pydy = pi0.y * dir.y, dySq = dir.y * dir.y;
 	const float pzSq = pi0.z * pi0.z, pzdz = pi0.z * dir.z, dzSq = dir.z * dir.z;
-	const float saSq = d-&gt;axisHScalesSq.x;
-	const float sbSq = d-&gt;axisHScalesSq.y;
-	const float scSq = d-&gt;axisHScalesSq.z;
+	const float saSq = v-&gt;axisHScalesSq.x;
+	const float sbSq = v-&gt;axisHScalesSq.y;
+	const float scSq = v-&gt;axisHScalesSq.z;
 
 	float A = 0.0f, B = 0.0f, C = 0.0f;
 
-	switch (d-&gt;primaryAxis) {
+	switch (v-&gt;primaryAxis) {
 		case COLVOL_AXIS_X: {
 			// see if start of ray lies between end-caps
-			pass = (pi0.x &gt; -d-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; d-&gt;axisHScales.x);
-			pii0 = float3(pi0.x, pi0.y * d-&gt;axisHIScales.y, pi0.z * d-&gt;axisHIScales.z);
+			pass = (pi0.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; v-&gt;axisHScales.x);
+			pii0 = float3(pi0.x, pi0.y * v-&gt;axisHIScales.y, pi0.z * v-&gt;axisHIScales.z);
 
 			n0 = float3( 1.0f, 0.0f, 0.0f);
 			n1 = float3(-1.0f, 0.0f, 0.0f);
@@ -379,8 +379,8 @@
 		} break;
 		case COLVOL_AXIS_Y: {
 			// see if start of ray lies between end-caps
-			pass = (pi0.y &gt; -d-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; d-&gt;axisHScales.y);
-			pii0 = float3(pi0.x * d-&gt;axisHIScales.x, pi0.y, pi0.z * d-&gt;axisHIScales.z);
+			pass = (pi0.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; v-&gt;axisHScales.y);
+			pii0 = float3(pi0.x * v-&gt;axisHIScales.x, pi0.y, pi0.z * v-&gt;axisHIScales.z);
 
 			n0 = float3(0.0f,  1.0f, 0.0f);
 			n1 = float3(0.0f, -1.0f, 0.0f);
@@ -393,8 +393,8 @@
 		} break;
 		case COLVOL_AXIS_Z: {
 			// see if start of ray lies between end-caps
-			pass = (pi0.z &gt; -d-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; d-&gt;axisHScales.z);
-			pii0 = float3(pi0.x * d-&gt;axisHIScales.x, pi0.y * d-&gt;axisHIScales.y, pi0.z);
+			pass = (pi0.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; v-&gt;axisHScales.z);
+			pii0 = float3(pi0.x * v-&gt;axisHIScales.x, pi0.y * v-&gt;axisHIScales.y, pi0.z);
 
 			n0 = float3(0.0f, 0.0f,  1.0f);
 			n1 = float3(0.0f, 0.0f, -1.0f);
@@ -418,9 +418,9 @@
 		return true;
 	}
 
-	const int pAx = d-&gt;primaryAxis;
-	const int sAx0 = d-&gt;secondaryAxes[0];
-	const int sAx1 = d-&gt;secondaryAxes[1];
+	const int pAx = v-&gt;primaryAxis;
+	const int sAx0 = v-&gt;secondaryAxes[0];
+	const int sAx1 = v-&gt;secondaryAxes[1];
 	const float D = (B * B) - (4.0f * A * C);
 
 	if (D &lt; -EPS) {
@@ -436,7 +436,7 @@
 			// one solution for t
 			t0 = -D / (2.0f * A); p0 = pi0 + (dir * t0);
 
-			if (p0[pAx] &gt; -d-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; d-&gt;axisHScales[pAx]) {
+			if (p0[pAx] &gt; -v-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; v-&gt;axisHScales[pAx]) {
 				// intersection point &lt;p0&gt; falls between cylinder
 				// caps, check if it also lies on our ray segment
 				dSq0 = (p0 - pi0).SqLength();
@@ -445,10 +445,10 @@
 				// &lt;p&gt; does not fall between end-caps but ray
 				// segment might still intersect one, so test
 				// for intersection against the cap planes
-				t0 = -(n0.dot(pi0) + d-&gt;axisHScales[pAx]) / n0.dot(dir); p0 = pi0 + (dir * t0);
-				t1 = -(n1.dot(pi0) - d-&gt;axisHScales[pAx]) / n1.dot(dir); p1 = pi0 + (dir * t1);
-				r0 = (((p0[sAx0] * p0[sAx0]) / d-&gt;axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / d-&gt;axisHScalesSq[sAx1]));
-				r1 = (((p1[sAx0] * p1[sAx0]) / d-&gt;axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / d-&gt;axisHScalesSq[sAx1]));
+				t0 = -(n0.dot(pi0) + v-&gt;axisHScales[pAx]) / n0.dot(dir); p0 = pi0 + (dir * t0);
+				t1 = -(n1.dot(pi0) - v-&gt;axisHScales[pAx]) / n1.dot(dir); p1 = pi0 + (dir * t1);
+				r0 = (((p0[sAx0] * p0[sAx0]) / v-&gt;axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / v-&gt;axisHScalesSq[sAx1]));
+				r1 = (((p1[sAx0] * p1[sAx0]) / v-&gt;axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / v-&gt;axisHScalesSq[sAx1]));
 				b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f);
 				b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f);
 			}
@@ -460,7 +460,7 @@
 
 			// test the 1st intersection point
 			// along the cylinder's major axis
-			if (p0[pAx] &gt; -d-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; d-&gt;axisHScales[pAx]) {
+			if (p0[pAx] &gt; -v-&gt;axisHScales[pAx]  &amp;&amp;  p0[pAx] &lt; v-&gt;axisHScales[pAx]) {
 				// intersection point &lt;p0&gt; falls between cylinder
 				// caps, check if it also lies on our ray segment
 				dSq0 = (p0 - pi0).SqLength();
@@ -469,7 +469,7 @@
 
 			// test the 2nd intersection point
 			// along the cylinder's major axis
-			if (p1[pAx] &gt; -d-&gt;axisHScales[pAx]  &amp;&amp;  p1[pAx] &lt; d-&gt;axisHScales[pAx]) {
+			if (p1[pAx] &gt; -v-&gt;axisHScales[pAx]  &amp;&amp;  p1[pAx] &lt; v-&gt;axisHScales[pAx]) {
 				// intersection point &lt;p1&gt; falls between cylinder
 				// caps, check if it also lies on our ray segment
 				dSq1 = (p1 - pi0).SqLength();
@@ -483,12 +483,12 @@
 			// a cap, so do extra test for intersection against the cap
 			// planes
 			// NOTE: DIV0 if normal and dir are orthogonal?
-			t0 = -(n0.dot(pi0) + d-&gt;axisHScales[pAx]) / n0.dot(dir);
-			t1 = -(n1.dot(pi0) - d-&gt;axisHScales[pAx]) / n1.dot(dir);
+			t0 = -(n0.dot(pi0) + v-&gt;axisHScales[pAx]) / n0.dot(dir);
+			t1 = -(n1.dot(pi0) - v-&gt;axisHScales[pAx]) / n1.dot(dir);
 			p0 = pi0 + (dir * t0); dSq0 = (p0 - pi0).SqLength();
 			p1 = pi0 + (dir * t1); dSq1 = (p1 - pi0).SqLength();
-			r0 = (((p0[sAx0] * p0[sAx0]) / d-&gt;axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / d-&gt;axisHScalesSq[sAx1]));
-			r1 = (((p1[sAx0] * p1[sAx0]) / d-&gt;axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / d-&gt;axisHScalesSq[sAx1]));
+			r0 = (((p0[sAx0] * p0[sAx0]) / v-&gt;axisHScalesSq[sAx0]) + ((p0[sAx1] * p0[sAx1]) / v-&gt;axisHScalesSq[sAx1]));
+			r1 = (((p1[sAx0] * p1[sAx0]) / v-&gt;axisHScalesSq[sAx0]) + ((p1[sAx1] * p1[sAx1]) / v-&gt;axisHScalesSq[sAx1]));
 			b0 = (t0 &gt; 0.0f &amp;&amp; r0 &lt;= 1.0f &amp;&amp; dSq0 &lt;= segLenSq);
 			b1 = (t1 &gt; 0.0f &amp;&amp; r1 &lt;= 1.0f &amp;&amp; dSq1 &lt;= segLenSq);
 		}
@@ -503,11 +503,11 @@
 	}
 }
 
-bool CCollisionHandler::IntersectBox(const CollisionVolumeData* d, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
+bool CCollisionHandler::IntersectBox(const CollisionVolume* v, const float3&amp; pi0, const float3&amp; pi1, CollisionQuery* q)
 {
-	const bool ba = (pi0.x &gt; -d-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; d-&gt;axisHScales.x);
-	const bool bb = (pi0.y &gt; -d-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; d-&gt;axisHScales.y);
-	const bool bc = (pi0.z &gt; -d-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; d-&gt;axisHScales.z);
+	const bool ba = (pi0.x &gt; -v-&gt;axisHScales.x  &amp;&amp;  pi0.x &lt; v-&gt;axisHScales.x);
+	const bool bb = (pi0.y &gt; -v-&gt;axisHScales.y  &amp;&amp;  pi0.y &lt; v-&gt;axisHScales.y);
+	const bool bc = (pi0.z &gt; -v-&gt;axisHScales.z  &amp;&amp;  pi0.z &lt; v-&gt;axisHScales.z);
 
 	if ((ba &amp;&amp; bb &amp;&amp; bc) /* &amp;&amp; (bd &amp;&amp; be &amp;&amp; bf) */) {
 		// terminate early in the special case
@@ -529,16 +529,16 @@
 	const float3 dir = (pi1 - pi0).Normalize();
 
 	if (dir.x &gt; -EPS &amp;&amp; dir.x &lt; EPS) {
-		if (pi0.x &lt; -d-&gt;axisHScales.x  ||  pi0.x &gt; d-&gt;axisHScales.x) {
+		if (pi0.x &lt; -v-&gt;axisHScales.x  ||  pi0.x &gt; v-&gt;axisHScales.x) {
 			return false;
 		}
 	} else {
 		if (dir.x &gt; 0.0f) {
-			t0 = (-d-&gt;axisHScales.x - pi0.x) / dir.x;
-			t1 = ( d-&gt;axisHScales.x - pi0.x) / dir.x;
+			t0 = (-v-&gt;axisHScales.x - pi0.x) / dir.x;
+			t1 = ( v-&gt;axisHScales.x - pi0.x) / dir.x;
 		} else {
-			t1 = (-d-&gt;axisHScales.x - pi0.x) / dir.x;
-			t0 = ( d-&gt;axisHScales.x - pi0.x) / dir.x;
+			t1 = (-v-&gt;axisHScales.x - pi0.x) / dir.x;
+			t0 = ( v-&gt;axisHScales.x - pi0.x) / dir.x;
 		}
 
 		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
@@ -549,16 +549,16 @@
 	}
 
 	if (dir.y &gt; -EPS &amp;&amp; dir.y &lt; EPS) {
-		if (pi0.y &lt; -d-&gt;axisHScales.y  ||  pi0.y &gt; d-&gt;axisHScales.y) {
+		if (pi0.y &lt; -v-&gt;axisHScales.y  ||  pi0.y &gt; v-&gt;axisHScales.y) {
 			return false;
 		}
 	} else {
 		if (dir.y &gt; 0.0f) {
-			t0 = (-d-&gt;axisHScales.y - pi0.y) / dir.y;
-			t1 = ( d-&gt;axisHScales.y - pi0.y) / dir.y;
+			t0 = (-v-&gt;axisHScales.y - pi0.y) / dir.y;
+			t1 = ( v-&gt;axisHScales.y - pi0.y) / dir.y;
 		} else {
-			t1 = (-d-&gt;axisHScales.y - pi0.y) / dir.y;
-			t0 = ( d-&gt;axisHScales.y - pi0.y) / dir.y;
+			t1 = (-v-&gt;axisHScales.y - pi0.y) / dir.y;
+			t0 = ( v-&gt;axisHScales.y - pi0.y) / dir.y;
 		}
 
 		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }
@@ -569,16 +569,16 @@
 	}
 
 	if (dir.z &gt; -EPS &amp;&amp; dir.z &lt; EPS) {
-		if (pi0.z &lt; -d-&gt;axisHScales.z  ||  pi0.z &gt; d-&gt;axisHScales.z) {
+		if (pi0.z &lt; -v-&gt;axisHScales.z  ||  pi0.z &gt; v-&gt;axisHScales.z) {
 			return false;
 		}
 	} else {
 		if (dir.z &gt; 0.0f) {
-			t0 = (-d-&gt;axisHScales.z - pi0.z) / dir.z;
-			t1 = ( d-&gt;axisHScales.z - pi0.z) / dir.z;
+			t0 = (-v-&gt;axisHScales.z - pi0.z) / dir.z;
+			t1 = ( v-&gt;axisHScales.z - pi0.z) / dir.z;
 		} else {
-			t1 = (-d-&gt;axisHScales.z - pi0.z) / dir.z;
-			t0 = ( d-&gt;axisHScales.z - pi0.z) / dir.z;
+			t1 = (-v-&gt;axisHScales.z - pi0.z) / dir.z;
+			t0 = ( v-&gt;axisHScales.z - pi0.z) / dir.z;
 		}
 
 		if (t0 &gt; t1) { t2 = t1; t1 = t0; t0 = t2; }

Modified: trunk/rts/Sim/Misc/CollisionHandler.h
===================================================================
--- trunk/rts/Sim/Misc/CollisionHandler.h	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Misc/CollisionHandler.h	2008-04-26 11:41:57 UTC (rev 5786)
@@ -4,7 +4,7 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;creg/creg.h&quot;
 
-struct CollisionVolumeData;
+struct CollisionVolume;
 class CUnit;
 class CFeature;
 
@@ -38,15 +38,15 @@
 	private:
 		static bool Collision(const CUnit*, const float3&amp;);
 		static bool Collision(const CFeature*, const float3&amp;);
-		static bool Collision(const CollisionVolumeData*, const CMatrix44f&amp;, const float3&amp;);
+		static bool Collision(const CollisionVolume*, const CMatrix44f&amp;, const float3&amp;);
 
 		static bool Intersect(const CUnit*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
 		static bool Intersect(const CFeature*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
-		static bool Intersect(const CollisionVolumeData*, const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q);
+		static bool Intersect(const CollisionVolume*, const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q);
 
-		static bool IntersectEllipsoid(const CollisionVolumeData*, const float3&amp;, const float3&amp;, CollisionQuery* q);
-		static bool IntersectCylinder(const CollisionVolumeData*, const float3&amp;, const float3&amp;, CollisionQuery* q);
-		static bool IntersectBox(const CollisionVolumeData*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+		static bool IntersectEllipsoid(const CollisionVolume*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+		static bool IntersectCylinder(const CollisionVolume*, const float3&amp;, const float3&amp;, CollisionQuery* q);
+		static bool IntersectBox(const CollisionVolume*, const float3&amp;, const float3&amp;, CollisionQuery* q);
 
 		static unsigned int numCollisionTests;
 		static unsigned int numIntersectionTests;

Copied: trunk/rts/Sim/Misc/CollisionVolume.h (from rev 5785, trunk/rts/Sim/Misc/CollisionVolumeData.h)
===================================================================
--- trunk/rts/Sim/Misc/CollisionVolume.h	                        (rev 0)
+++ trunk/rts/Sim/Misc/CollisionVolume.h	2008-04-26 11:41:57 UTC (rev 5786)
@@ -0,0 +1,172 @@
+#ifndef COLLISION_VOLUME_H
+#define COLLISION_VOLUME_H
+
+#include &quot;StdAfx.h&quot;
+#include &quot;creg/creg.h&quot;
+
+#define EPS 0.001f
+#define MIN(a, b) std::min((a), (b))
+#define MAX(a, b) std::max((a), (b))
+
+enum COLVOL_TYPES {COLVOL_TYPE_ELLIPSOID, COLVOL_TYPE_CYLINDER, COLVOL_TYPE_BOX};
+enum COLVOL_AXES {COLVOL_AXIS_X, COLVOL_AXIS_Y, COLVOL_AXIS_Z};
+enum COLVOL_TESTS {COLVOL_TEST_DISC, COLVOL_TEST_CONT};
+
+struct CollisionVolume {
+	CR_DECLARE_STRUCT(CollisionVolume);
+
+	CollisionVolume() {}
+	CollisionVolume(const CollisionVolume* src) {
+		axisScales = src-&gt;axisScales;
+		axisHScales = src-&gt;axisHScales;
+		axisHScalesSq = src-&gt;axisHScalesSq;
+		axisHIScales = src-&gt;axisHIScales;
+		axisOffsets = src-&gt;axisOffsets;
+		volumeBoundingRadius = src-&gt;volumeBoundingRadius;
+		volumeBoundingRadiusSq = src-&gt;volumeBoundingRadiusSq;
+		volumeType = src-&gt;volumeType;
+		testType = src-&gt;testType;
+		primaryAxis = src-&gt;primaryAxis;
+		secondaryAxes[0] = src-&gt;secondaryAxes[0];
+		secondaryAxes[1] = src-&gt;secondaryAxes[1];
+		spherical = src-&gt;spherical;
+	}
+
+	CollisionVolume(const std::string&amp; volTypeStr, const float3&amp; volScales, const float3&amp; volOffsets, int tstType) {
+		// note: primaryAxis is only relevant for cylinders
+		primaryAxis = COLVOL_AXIS_Z;
+		volumeType = COLVOL_TYPE_ELLIPSOID;
+		testType = tstType;
+
+		if (volTypeStr.size() &gt; 0) {
+			// note: case-sensitivity?
+			if (volTypeStr.find(&quot;Ell&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_ELLIPSOID;
+			}
+
+			if (volTypeStr.find(&quot;Cyl&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_CYLINDER;
+
+				if (volTypeStr.size() == 4) {
+					if (volTypeStr[3] == 'X') { primaryAxis = COLVOL_AXIS_X; }
+					if (volTypeStr[3] == 'Y') { primaryAxis = COLVOL_AXIS_Y; }
+					if (volTypeStr[3] == 'Z') { primaryAxis = COLVOL_AXIS_Z; }
+				}
+			}
+
+			if (volTypeStr.find(&quot;Box&quot;) != std::string::npos) {
+				volumeType = COLVOL_TYPE_BOX;
+			}
+		}
+
+		Init(volScales, volOffsets, volumeType, testType, primaryAxis);
+	}
+
+
+	void SetDefaultScale(const float s) {
+		// called iif unit or feature defines no custom volume,
+		// &lt;s&gt; is the object's default RADIUS (not its diameter)
+		// so we need to double it to get the full-length scales
+		const float3 scales(s * 2.0f, s * 2.0f, s * 2.0f);
+
+		Init(scales, ZeroVector, COLVOL_TYPE_ELLIPSOID, COLVOL_TEST_DISC, COLVOL_AXIS_Z);
+	}
+
+
+	void Init(const float3&amp; scales, const float3&amp; offsets, int vType, int tType, int pAxis) {
+		// assign these here too, since SetData() can
+		// be called from outside of the constructor
+		primaryAxis = pAxis % 3;
+		volumeType = vType % 3;
+		testType = tType % 2;
+
+		axisScales.x = (scales.x &lt; 1.0f)? 1.0f: scales.x;  axisHScales.x = axisScales.x * 0.5f;  axisHScalesSq.x = axisHScales.x * axisHScales.x;
+		axisScales.y = (scales.y &lt; 1.0f)? 1.0f: scales.y;  axisHScales.y = axisScales.y * 0.5f;  axisHScalesSq.y = axisHScales.y * axisHScales.y;
+		axisScales.z = (scales.z &lt; 1.0f)? 1.0f: scales.z;  axisHScales.z = axisScales.z * 0.5f;  axisHScalesSq.z = axisHScales.z * axisHScales.z;
+
+		axisHIScales.x = 1.0f / axisHScales.x;  axisOffsets.x = offsets.x;
+		axisHIScales.y = 1.0f / axisHScales.y;  axisOffsets.y = offsets.y;
+		axisHIScales.z = 1.0f / axisHScales.z;  axisOffsets.z = offsets.z;
+
+		// if all axes (or half-axes) are equal in scale, volume is a sphere
+		spherical = ((volumeType == COLVOL_TYPE_ELLIPSOID) &amp;&amp;
+					(fabsf(axisHScales.x - axisHScales.y) &lt; EPS) &amp;&amp;
+					(fabsf(axisHScales.y - axisHScales.z) &lt; EPS));
+
+		// secondaryAxes[0] = (primaryAxis + 1) % 3;
+		// secondaryAxes[1] = (primaryAxis + 2) % 3;
+
+		switch (primaryAxis) {
+			case COLVOL_AXIS_X: {
+				secondaryAxes[0] = COLVOL_AXIS_Y;
+				secondaryAxes[1] = COLVOL_AXIS_Z;
+			} break;
+			case COLVOL_AXIS_Y: {
+				secondaryAxes[0] = COLVOL_AXIS_X;
+				secondaryAxes[1] = COLVOL_AXIS_Z;
+			} break;
+			case COLVOL_AXIS_Z: {
+				secondaryAxes[0] = COLVOL_AXIS_X;
+				secondaryAxes[1] = COLVOL_AXIS_Y;
+			} break;
+		}
+
+		// set the radius of the minimum bounding sphere
+		// that encompasses this custom collision volume
+		// (for early-out testing)
+		switch (volumeType) {
+			case COLVOL_TYPE_BOX: {
+				// would be an over-estimation for cylinders
+				volumeBoundingRadiusSq = axisHScalesSq.x + axisHScalesSq.y + axisHScalesSq.z;
+				volumeBoundingRadius = sqrt(volumeBoundingRadiusSq);
+			} break;
+			case COLVOL_TYPE_CYLINDER: {
+				const float prhs = axisHScales[primaryAxis     ];	// primary axis half-scale
+				const float sahs = axisHScales[secondaryAxes[0]];	// 1st secondary axis half-scale
+				const float sbhs = axisHScales[secondaryAxes[1]];	// 2nd secondary axis half-scale
+				const float mshs = MAX(sahs, sbhs);					// max. secondary axis half-scale
+
+				volumeBoundingRadiusSq = prhs * prhs + mshs * mshs;
+				volumeBoundingRadius = sqrtf(volumeBoundingRadiusSq);
+			} break;
+			case COLVOL_TYPE_ELLIPSOID: {
+				if (spherical) {
+					// MAX(x, y, z) would suffice here too
+					volumeBoundingRadius = axisHScales.x;
+				} else {
+					volumeBoundingRadius = MAX(axisHScales.x, MAX(axisHScales.y, axisHScales.z));
+				}
+
+				volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
+			} break;
+		}
+	}
+
+	int GetVolumeType() const { return volumeType; }
+	int GetTestType() const { return testType; }
+	int GetPrimaryAxis() const { return primaryAxis; }
+	float GetBoundingRadius() const { return volumeBoundingRadius; }
+	float GetBoundingRadiusSq() const { return volumeBoundingRadiusSq; }
+	float GetScale(int axis) const { return axisScales[axis]; }
+	float GetHScale(int axis) const { return axisHScales[axis]; }
+	float GetHScaleSq(int axis) const { return axisHScalesSq[axis]; }
+	float GetOffset(int axis) const { return axisOffsets[axis]; }
+	bool IsSphere() const { return spherical; }
+
+
+	float3 axisScales;					// full-length axis scales
+	float3 axisHScales;					// half-length axis scales
+	float3 axisHScalesSq;				// half-length axis scales (squared)
+	float3 axisHIScales;				// half-length axis scales (inverted)
+	float3 axisOffsets;
+
+	float volumeBoundingRadius;			// radius of minimally-bounding sphere around volume
+	float volumeBoundingRadiusSq;		// squared radius of minimally-bounding sphere
+	int volumeType;
+	int testType;
+	int primaryAxis;
+	int secondaryAxes[2];
+	bool spherical;
+};
+
+#endif

Deleted: trunk/rts/Sim/Misc/CollisionVolumeData.h
===================================================================
--- trunk/rts/Sim/Misc/CollisionVolumeData.h	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Misc/CollisionVolumeData.h	2008-04-26 11:41:57 UTC (rev 5786)
@@ -1,172 +0,0 @@
-#ifndef COLLISION_VOLUME_DATA_H
-#define COLLISION_VOLUME_DATA_H
-
-#include &quot;StdAfx.h&quot;
-#include &quot;creg/creg.h&quot;
-
-#define EPS 0.001f
-#define MIN(a, b) std::min((a), (b))
-#define MAX(a, b) std::max((a), (b))
-
-enum COLVOL_TYPES {COLVOL_TYPE_ELLIPSOID, COLVOL_TYPE_CYLINDER, COLVOL_TYPE_BOX};
-enum COLVOL_AXES {COLVOL_AXIS_X, COLVOL_AXIS_Y, COLVOL_AXIS_Z};
-enum COLVOL_TESTS {COLVOL_TEST_DISC, COLVOL_TEST_CONT};
-
-struct CollisionVolumeData {
-	CR_DECLARE_STRUCT(CollisionVolumeData);
-
-	CollisionVolumeData() {}
-	CollisionVolumeData(const std::string&amp; volTypeStr, const float3&amp; volScales, const float3&amp; volOffsets, int tstType) {
-		// note: primaryAxis is only relevant for cylinders
-		primaryAxis = COLVOL_AXIS_Z;
-		volumeType = COLVOL_TYPE_ELLIPSOID;
-		testType = tstType;
-
-		if (volTypeStr.size() &gt; 0) {
-			// note: case-sensitivity?
-			if (volTypeStr.find(&quot;Ell&quot;) != std::string::npos) {
-				volumeType = COLVOL_TYPE_ELLIPSOID;
-			}
-
-			if (volTypeStr.find(&quot;Cyl&quot;) != std::string::npos) {
-				volumeType = COLVOL_TYPE_CYLINDER;
-
-				if (volTypeStr.size() == 4) {
-					if (volTypeStr[3] == 'X') { primaryAxis = COLVOL_AXIS_X; }
-					if (volTypeStr[3] == 'Y') { primaryAxis = COLVOL_AXIS_Y; }
-					if (volTypeStr[3] == 'Z') { primaryAxis = COLVOL_AXIS_Z; }
-				}
-			}
-
-			if (volTypeStr.find(&quot;Box&quot;) != std::string::npos) {
-				volumeType = COLVOL_TYPE_BOX;
-			}
-		}
-
-		Init(volScales, volOffsets, volumeType, testType, primaryAxis);
-	}
-
-
-	void SetDefaultScale(const float s) {
-		// called iif unit or feature defines no custom volume,
-		// &lt;s&gt; is the object's default RADIUS (not its diameter)
-		// so we need to double it to get the full-length scales
-		const float3 scales(s * 2.0f, s * 2.0f, s * 2.0f);
-
-		Init(scales, ZeroVector, COLVOL_TYPE_ELLIPSOID, COLVOL_TEST_DISC, COLVOL_AXIS_Z);
-	}
-
-
-	void Init(const float3&amp; scales, const float3&amp; offsets, int vType, int tType, int pAxis) {
-		// assign these here too, since SetData() can
-		// be called from outside of the constructor
-		primaryAxis = pAxis % 3;
-		volumeType = vType % 3;
-		testType = tType % 2;
-
-		axisScales.x = (scales.x &lt; 1.0f)? 1.0f: scales.x;  axisHScales.x = axisScales.x * 0.5f;  axisHScalesSq.x = axisHScales.x * axisHScales.x;
-		axisScales.y = (scales.y &lt; 1.0f)? 1.0f: scales.y;  axisHScales.y = axisScales.y * 0.5f;  axisHScalesSq.y = axisHScales.y * axisHScales.y;
-		axisScales.z = (scales.z &lt; 1.0f)? 1.0f: scales.z;  axisHScales.z = axisScales.z * 0.5f;  axisHScalesSq.z = axisHScales.z * axisHScales.z;
-
-		axisHIScales.x = 1.0f / axisHScales.x;  axisOffsets.x = offsets.x;
-		axisHIScales.y = 1.0f / axisHScales.y;  axisOffsets.y = offsets.y;
-		axisHIScales.z = 1.0f / axisHScales.z;  axisOffsets.z = offsets.z;
-
-		// if all axes (or half-axes) are equal in scale, volume is a sphere
-		spherical = ((volumeType == COLVOL_TYPE_ELLIPSOID) &amp;&amp;
-					(fabsf(axisHScales.x - axisHScales.y) &lt; EPS) &amp;&amp;
-					(fabsf(axisHScales.y - axisHScales.z) &lt; EPS));
-
-		// secondaryAxes[0] = (primaryAxis + 1) % 3;
-		// secondaryAxes[1] = (primaryAxis + 2) % 3;
-
-		switch (primaryAxis) {
-			case COLVOL_AXIS_X: {
-				secondaryAxes[0] = COLVOL_AXIS_Y;
-				secondaryAxes[1] = COLVOL_AXIS_Z;
-			} break;
-			case COLVOL_AXIS_Y: {
-				secondaryAxes[0] = COLVOL_AXIS_X;
-				secondaryAxes[1] = COLVOL_AXIS_Z;
-			} break;
-			case COLVOL_AXIS_Z: {
-				secondaryAxes[0] = COLVOL_AXIS_X;
-				secondaryAxes[1] = COLVOL_AXIS_Y;
-			} break;
-		}
-
-		// set the radius of the minimum bounding sphere
-		// that encompasses this custom collision volume
-		// (for early-out testing)
-		switch (volumeType) {
-			case COLVOL_TYPE_BOX: {
-				// would be an over-estimation for cylinders
-				volumeBoundingRadiusSq = axisHScalesSq.x + axisHScalesSq.y + axisHScalesSq.z;
-				volumeBoundingRadius = sqrt(volumeBoundingRadiusSq);
-			} break;
-			case COLVOL_TYPE_CYLINDER: {
-				const float prhs = axisHScales[primaryAxis     ];	// primary axis half-scale
-				const float sahs = axisHScales[secondaryAxes[0]];	// 1st secondary axis half-scale
-				const float sbhs = axisHScales[secondaryAxes[1]];	// 2nd secondary axis half-scale
-				const float mshs = MAX(sahs, sbhs);					// max. secondary axis half-scale
-
-				volumeBoundingRadiusSq = prhs * prhs + mshs * mshs;
-				volumeBoundingRadius = sqrtf(volumeBoundingRadiusSq);
-			} break;
-			case COLVOL_TYPE_ELLIPSOID: {
-				if (spherical) {
-					// MAX(x, y, z) would suffice here too
-					volumeBoundingRadius = axisHScales.x;
-				} else {
-					volumeBoundingRadius = MAX(axisHScales.x, MAX(axisHScales.y, axisHScales.z));
-				}
-
-				volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
-			} break;
-		}
-	}
-
-	void Copy(const CollisionVolumeData* src) {
-		axisScales = src-&gt;axisScales;
-		axisHScales = src-&gt;axisHScales;
-		axisHScalesSq = src-&gt;axisHScalesSq;
-		axisHIScales = src-&gt;axisHIScales;
-		axisOffsets = src-&gt;axisOffsets;
-		volumeBoundingRadius = src-&gt;volumeBoundingRadius;
-		volumeBoundingRadiusSq = src-&gt;volumeBoundingRadiusSq;
-		volumeType = src-&gt;volumeType;
-		testType = src-&gt;testType;
-		primaryAxis = src-&gt;primaryAxis;
-		secondaryAxes[0] = src-&gt;secondaryAxes[0];
-		secondaryAxes[1] = src-&gt;secondaryAxes[1];
-		spherical = src-&gt;spherical;
-	}
-
-	int GetVolumeType() const { return volumeType; }
-	int GetTestType() const { return testType; }
-	int GetPrimaryAxis() const { return primaryAxis; }
-	float GetBoundingRadius() const { return volumeBoundingRadius; }
-	float GetBoundingRadiusSq() const { return volumeBoundingRadiusSq; }
-	float GetScale(int axis) const { return axisScales[axis]; }
-	float GetHScale(int axis) const { return axisHScales[axis]; }
-	float GetHScaleSq(int axis) const { return axisHScalesSq[axis]; }
-	float GetOffset(int axis) const { return axisOffsets[axis]; }
-	bool IsSphere() const { return spherical; }
-
-
-	float3 axisScales;					// full-length axis scales
-	float3 axisHScales;					// half-length axis scales
-	float3 axisHScalesSq;				// half-length axis scales (squared)
-	float3 axisHIScales;				// half-length axis scales (inverted)
-	float3 axisOffsets;
-
-	float volumeBoundingRadius;			// radius of minimally-bounding sphere around volume
-	float volumeBoundingRadiusSq;		// squared radius of minimally-bounding sphere
-	int volumeType;
-	int testType;
-	int primaryAxis;
-	int secondaryAxes[2];
-	bool spherical;
-};
-
-#endif

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-04-26 11:41:57 UTC (rev 5786)
@@ -30,7 +30,7 @@
 #include &quot;Sim/Misc/AirBaseHandler.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
-#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
@@ -84,7 +84,7 @@
 
 CUnit::CUnit ()
 :	unitDef(0),
-	collisionVolumeData(0),
+	collisionVolume(0),
 	team(0),
 	maxHealth(100),
 	health(100),
@@ -262,10 +262,10 @@
 	SetMetalStorage(0);
 	SetEnergyStorage(0);
 
-	delete commandAI;           commandAI           = NULL;
-	delete moveType;            moveType            = NULL;
-	delete prevMoveType;        prevMoveType        = NULL;
-	delete collisionVolumeData; collisionVolumeData = NULL;
+	delete commandAI;       commandAI       = NULL;
+	delete moveType;        moveType        = NULL;
+	delete prevMoveType;    prevMoveType    = NULL;
+	delete collisionVolume; collisionVolume = NULL;
 
 	if (group) {
 		group-&gt;RemoveUnit(this);

Modified: trunk/rts/Sim/Units/Unit.h
===================================================================
--- trunk/rts/Sim/Units/Unit.h	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Units/Unit.h	2008-04-26 11:41:57 UTC (rev 5786)
@@ -27,7 +27,7 @@
 struct S3DOModel;
 struct UnitDef;
 struct UnitTrackStruct;
-struct CollisionVolumeData;
+struct CollisionVolume;
 
 #ifdef DIRECT_CONTROL_ALLOWED
 	struct DirectControlStruct;
@@ -126,7 +126,7 @@
 	virtual bool ChangeTeam(int team, ChangeType type);
 
 	const UnitDef* unitDef;
-	CollisionVolumeData* collisionVolumeData;
+	CollisionVolume* collisionVolume;
 	std::string unitDefName;
 
 	std::vector&lt;float&gt;         modParams;    // mod controlled parameters

Modified: trunk/rts/Sim/Units/UnitDef.h
===================================================================
--- trunk/rts/Sim/Units/UnitDef.h	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Units/UnitDef.h	2008-04-26 11:41:57 UTC (rev 5786)
@@ -12,7 +12,7 @@
 struct WeaponDef;
 struct S3DOModel;
 struct UnitImage;
-struct CollisionVolumeData;
+struct CollisionVolume;
 class CExplosionGenerator;
 
 const int MAX_UNITS = 10000;
@@ -99,7 +99,7 @@
 	std::string filename;
 	int id;					// unique id for this type of unit
 
-	CollisionVolumeData* collisionVolumeData;
+	CollisionVolume* collisionVolume;
 	const UnitDef* decoyDef;
 
 	int aihint;

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-04-26 11:41:57 UTC (rev 5786)
@@ -21,7 +21,7 @@
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
-#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Misc/DamageArrayHandler.h&quot;
 #include &quot;Sim/Misc/SensorHandler.h&quot;
 #include &quot;Sim/ModInfo.h&quot;
@@ -93,7 +93,7 @@
 		unitDefs[id].id = id;
 		unitDefs[id].buildangle = 0;
 		unitDefs[id].unitImage  = 0;
-		unitDefs[id].collisionVolumeData = 0;
+		unitDefs[id].collisionVolume = 0;
 		unitDefs[id].techLevel  = -1;
 		unitDefs[id].decoyDef   = NULL;
 		unitID[unitName] = id;
@@ -132,8 +132,8 @@
 			unitDefs[i].unitImage = 0;
 		}
 
-		delete unitDefs[i].collisionVolumeData;
-		unitDefs[i].collisionVolumeData = 0;
+		delete unitDefs[i].collisionVolume;
+		unitDefs[i].collisionVolume = 0;
 	}
 	delete[] unitDefs;
 	delete weaponDefHandler;
@@ -734,7 +734,7 @@
 
 	// initialize the (per-unitdef) collision-volume
 	// all CUnit instances hold a copy of this object
-	ud.collisionVolumeData = SAFE_NEW CollisionVolumeData(ud.collisionVolumeType,
+	ud.collisionVolume = SAFE_NEW CollisionVolume(ud.collisionVolumeType,
 		ud.collisionVolumeScales, ud.collisionVolumeOffsets, ud.collisionVolumeTest);
 
 

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-04-26 11:41:57 UTC (rev 5786)
@@ -26,7 +26,7 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
-#include &quot;Sim/Misc/CollisionVolumeData.h&quot;
+#include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/MoveTypes/AirMoveType.h&quot;
 #include &quot;Sim/MoveTypes/GroundMoveType.h&quot;
 #include &quot;Sim/MoveTypes/TAAirMoveType.h&quot;
@@ -307,19 +307,18 @@
 	unit-&gt;SetRadius(unit-&gt;model-&gt;radius);
 
 	// copy the UnitDef volume archetype data
-	unit-&gt;collisionVolumeData = SAFE_NEW CollisionVolumeData();
-	unit-&gt;collisionVolumeData-&gt;Copy(ud-&gt;collisionVolumeData);
+	unit-&gt;collisionVolume = SAFE_NEW CollisionVolume(ud-&gt;collisionVolume);
 
 	// CUnitDefHandler left this volume's axis-scales uninitialized
 	// (ie. no &quot;collisionVolumeScales&quot; tag was defined in UnitDef)
-	if (unit-&gt;collisionVolumeData-&gt;GetScale(COLVOL_AXIS_X) &lt;= 1.0f &amp;&amp;
-		unit-&gt;collisionVolumeData-&gt;GetScale(COLVOL_AXIS_Y) &lt;= 1.0f &amp;&amp;
-		unit-&gt;collisionVolumeData-&gt;GetScale(COLVOL_AXIS_Z) &lt;= 1.0f) {
+	if (unit-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_X) &lt;= 1.0f &amp;&amp;
+		unit-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Y) &lt;= 1.0f &amp;&amp;
+		unit-&gt;collisionVolume-&gt;GetScale(COLVOL_AXIS_Z) &lt;= 1.0f) {
 		// aircraft still get half-size spheres for coldet purposes
 		// if no custom volume is defined (unit-&gt;model-&gt;radius and
 		// unit-&gt;radius themselves are no longer altered)
 		const float scaleFactor = (ud-&gt;canfly)? 0.5f: 1.0f;
-		unit-&gt;collisionVolumeData-&gt;SetDefaultScale(unit-&gt;model-&gt;radius * scaleFactor);
+		unit-&gt;collisionVolume-&gt;SetDefaultScale(unit-&gt;model-&gt;radius * scaleFactor);
 	}
 
 

Modified: trunk/rts/build/vstudio8/rts.vcproj
===================================================================
--- trunk/rts/build/vstudio8/rts.vcproj	2008-04-25 23:26:09 UTC (rev 5785)
+++ trunk/rts/build/vstudio8/rts.vcproj	2008-04-26 11:41:57 UTC (rev 5786)
@@ -3007,7 +3007,7 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Sim\Misc\CollisionVolumeData.h&quot;
+					RelativePath=&quot;..\..\Sim\Misc\CollisionVolume.h&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000565.html">[Taspring-linux-commit] r5785 - in trunk/rts/Sim: Features Misc	Units
</A></li>
	<LI>Next message: <A HREF="000567.html">[Taspring-linux-commit] r5787 - in trunk: AI/Group/EconomyAI	rts/ExternalAI rts/Game rts/Game/Camera rts/Game/StartScripts	rts/Game/UI rts/Lua rts/Map rts/Rendering rts/Rendering/Env	rts/Rendering/UnitModels rts/Sim/Features rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Path rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Units/UnitTypes rts/Sim/Weapons rts/System	rts/System/FileSystem rts/System/Platform/Linux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#566">[ date ]</a>
              <a href="thread.html#566">[ thread ]</a>
              <a href="subject.html#566">[ subject ]</a>
              <a href="author.html#566">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
